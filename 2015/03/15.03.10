00:04:40 <johnchen902> help
00:04:53 <johnchen902> @help
00:04:53 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:15:53 * hackagebot warp-tls 3.0.3 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-3.0.3 (MichaelSnoyman)
00:27:48 <safinaskar> is there some containers for data in haskell, which are internally implemented as something like pointers and thus can be very fast be compared (because equaliation is as fast as pointer comparision). i. e. i want to write "let a = Container some_big_data in a == a" -- here "a == a" is very fast, because pointers only are compared
00:30:23 <johnchen902> @pf \l r -> (`div` 2) (l + r)
00:30:23 <lambdabot> Maybe you meant: pl bf
00:30:30 <johnchen902> @pl \l r -> (`div` 2) (l + r)
00:30:30 <lambdabot> ((`div` 2) .) . (+)
01:19:39 <mroman> No instance for (Control.Monad.Catch.MonadThrow (ServerPartT IO))
01:19:48 <mroman> Now I'm beginning to understand why people don't tend to use Haskell
01:21:42 <mroman> toStrict x = BS.concat . BL.toChunks $ x
01:21:48 <mroman> ^- why does that require MonadThrow?
01:24:56 <ChristianS> mroman: works for me when i try that in ghci
01:45:35 <nilg> guys, how to have disjunctions in a type class constraint?
01:46:08 <nilg> like: ((Num a) or (String a)) => ...
01:46:47 <greeny> mroman: which packages did BS and BL represent?
01:48:56 <Guest58471> where can I find [] data type definition?
01:49:15 <merijn> nilg: Simple answer: You can't do that
01:49:36 <zyla> nilg: why would you want to do that?
01:49:45 <merijn> nilg: Complex answer: You might be able to fake something somewhat similar using a list of like 10 extensions, but it won't be pretty and probably won't let you do what you want
01:50:00 <merijn> nilg: Also "String a" is nonsense, because String has kind * it doesn't take an argument
01:51:24 <merijn> Guest58471: The list syntax is valid haskell for user defined operators, so it's a special built-in syntax
01:52:02 <bergmark> Guest58471: :i [] in ghci
01:52:06 <merijn> Guest58471: It's basically just "data [] a = [] | a : ([] a)" or, translated to user writable names: "data List a = Nil | a : List a"
01:52:39 <greeny> Guest58471: and it is defined in GHC.Types
01:53:13 <Guest58471> merijn: yeah didn't know it's an in built syntax...
01:53:18 <greeny> you can view the source code of every module on hackage
01:54:41 <Guest58471> There is a question on haskell cafe about why [] == [] true
01:54:50 <jTT_> hi, I havent been programming in haskell in a while. i just set up things and was wondering what happened to sandboxes as cabal sandbox init seems not to work any more
01:55:20 <merijn> jTT_: Define "seems to not work anymore"
01:55:37 <geekosaur> Guest58471, yes, and it's been answered correctly twice; it has less to do with the definition of lists than with defaulting
01:55:49 <merijn> Guest58471: "[] == []" is only True for lists whose contents are Eq
01:55:53 <jTT_> as in: merijin: cabal: unrecognised command: sandbox (try --help)
01:56:07 <merijn> jTT_: Oh, linux? Installed GHC from apt or what not?
01:56:09 <geekosaur> you have an ancient cabal-install
01:56:19 <johnchen902> @pl \n b -> reverse (tonodes0 n (reverse b))
01:56:19 <lambdabot> (reverse .) . (. reverse) . tonodes0
01:56:35 <merijn> > ([] :: [IO ()]) == [] -- type error
01:56:36 <jTT_> merijin: yeah from apt-get etc
01:56:37 <lambdabot>  No instance for (GHC.Classes.Eq (GHC.Types.IO ()))
01:56:37 <lambdabot>    arising from a use of ‘GHC.Classes.==’
01:56:51 <merijn> jTT_: Your distro is shipping stupidly ancient software
01:57:02 <jTT_> merijin: okok, cheers
01:57:10 <merijn> I recommend installing the binary GHC release
01:57:18 <jTT_> will do, thanks
01:57:32 <Guest58471> merijn: geekosaur: yeah so it defaults to ()
01:57:35 <Guest58471> ?
01:57:38 <merijn> Guest58471: Yeah
01:57:39 <greeny> jTT_: https://www.haskell.org/downloads/linux
01:58:02 <geekosaur> ExtendedDefaultRules disables the Num constraint requirement for defaulting and adds () to the list of default types as a fallback
01:58:18 <Guest58471> how can I make my type (isomorphic to List) default to x?
01:58:36 <Kujanator> geekosaur, hi not sure if you remember me from yesterday but you and ski were helping with the short circuit boolean or operator. My internet went down last night and I never got the chance to thank you. I'm trying to do the short circuit and now, and think i've done the first part  but am not sure what to return if the first term is false. I know i need to return false but am not sure how. Here's what I've got so far : evalB (a :&&
01:58:49 <Guest58471> > data List a = Cons a (List a) | Nil
01:58:50 <lambdabot>  <hint>:1:1: parse error on input ‘data’
01:59:02 <Guest58471> data List a = Cons a (List a) | Nil
01:59:14 <Guest58471> Nil == Nil gives type error
01:59:23 <geekosaur> Kujanator, IRC has a fairly short line length limit, enforced by the server. what you just said chopped off at "evalB (a :&&"
01:59:29 <geekosaur> use shorter lines instead
01:59:40 <greeny> Guest58471: what function do want to write?
01:59:44 <Kujanator> geekosaur, oh ok. the code is evalB (a :&&: b) s0 = let (s1, na) = evalB a s0                        in if na then let (s2, nb) = evalB b s1 in (s2, nb)                         else 
01:59:53 <Kujanator> sorry about the weird spacing
02:00:01 <geekosaur> (that said I hope I'm not staying up much longer; only awake because my sinuses decided to explode an hour ago)
02:00:07 <tdammers> Guest58471: it doesn't if you implement Eq
02:00:41 <tdammers> Guest58471: you can probably even *derive* Eq there
02:01:34 <tdammers> > data List a = Cons a (List a) | Nil deriving (Eq); Nil == Nil
02:01:35 <lambdabot>  <hint>:1:1: parse error on input ‘data’
02:01:43 <Guest58471> tdammers: Ah, I see
02:02:13 <nilg> zyla: http://lpaste.net/124366 basically I'd like to have just one And constructor, not 3 (TVAnd, ConceptAnd and PerdicateAnd)
02:02:57 <Guest58471> I just wanted to know if built in List do implement the Eq instance
02:03:10 <Kujanator> geekosaur, oh ok, thanks anyway
02:03:19 <tdammers> Guest58471: [a] is Eq iff a is Eq
02:03:59 <tdammers> instance Eq a => Eq [a]
02:04:21 <merijn> tdammers: Misuse of Eq
02:04:24 <merijn> eh
02:04:29 <merijn> misuse of iff
02:04:36 <merijn> [a] is Eq if a is Eq
02:04:37 <tdammers> merijn: really?
02:05:17 <tdammers> wouldn't that require OverlappingInstances or some such?
02:05:18 <merijn> You could make overlapping instances that don't require Eq on a
02:05:40 <merijn> I'm not even sure they'd need that
02:06:03 <tdammers> I sure had ghc complain when trying to declare instances for String / [Char]
02:06:13 <nilg> I want a magical or! http://lpaste.net/124366 please help...
02:06:13 <merijn> Oh, it requires FlexibleInstances
02:06:21 <tdammers> possibly
02:06:28 <tdammers> let me check...
02:06:45 <merijn> Because you're declaring an instance without type variables
02:07:11 <tdammers> hmm, I did enable OverlappingInstances in string-convert
02:07:40 <tdammers> ah no, but that was so I could have:
02:07:44 <tdammers> instance (ToString a, FromString b) => StringConvert a b where
02:07:58 <tdammers> as well as more specific instances for special cases
02:08:12 <tdammers> e.g. strict <-> lazy texts
02:15:59 * hackagebot witherable 0.1.2 - Generalization of filter and catMaybes  http://hackage.haskell.org/package/witherable-0.1.2 (FumiakiKinoshita)
02:26:24 <gnimmelf> quiz: I use a lot of modules that I havent added to the `.cabal`-file, how do I get them in there most automagically?
02:27:22 <gnimmelf> ...from commandline, on Ubuntu
02:28:01 <quchen2> gnimmelf: I use a shell script to do that for me
02:28:23 <yoshuawuyts> is there a solid overview of haskell/FP patterns anywhere? I know most of them are published as papers, but I can't be bothered to search for 'em.
02:29:25 <quchen2> gnimmelf: find ./src | grep -E '\.hsc?$' | xargs -d"\n" cat | grep "^module" | sed 's/^module \([0-9a-zA-Z.]\+\).*/\1/' | sort
02:30:00 <Rembane> quchen2: Trivial! :D
02:30:59 <Cale> I guess you could cabal init and race through the questions (giving a bogus name for the package) and then copy/paste the list of modules from the .cabal file it generates to the real one
02:31:49 <merijn> yoshuawuyts: Tekmo's blog has a few good ones
02:32:06 <merijn> http://www.haskellforall.com/
02:32:12 <merijn> Although it doesn't appear to have an index?
02:32:18 <gnimmelf> quchen2: thats all my stuff listed, I think I need the "other" dependencies, like `cabal install` -> `Could not find module ‘Data.Text.Encoding’`
02:32:31 <yoshuawuyts> merijn: oooh, thanks!
02:32:37 <gnimmelf> ..with the correct semver
02:32:48 <yoshuawuyts> merijn: I can plow through that, just needed a place to start :D
02:32:59 <merijn> yoshuawuyts: Three that spring to mind are: http://www.haskellforall.com/2012/09/the-functor-design-pattern.html
02:33:04 <merijn> http://www.haskellforall.com/2012/08/the-category-design-pattern.html
02:33:11 <merijn> And http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
02:33:49 <yoshuawuyts> this makes me happy, thanks! ^^
02:34:07 <merijn> Studying the comonad, contravariant and free packages (well, blogposts about them) would be good too
02:34:19 <merijn> Assuming that Monad/Applicative already make sense as a "pattern"
02:38:14 <Cale> yoshuawuyts, merijn: I really hesitate to call things like this "patterns", when they're really just libraries. If we didn't have type classes, then perhaps monads would be a pattern (though one which would be used much less frequently, because most of the benefit that comes from recognising you have a monad comes from the library support)
02:39:32 <merijn> Cale: Sure
02:40:11 <merijn> Cale: But Tekmo's "pattern" posts are basically "how do you recognise you could slightly restructure your data to fit into class X" + "why would you want to do that"
02:40:57 <dario`> meta-emeta-ctrl-Mctrl-?
02:40:59 <merijn> I don't think monads in themselves are patterns. But it's useful to see that a slight generalisation/rejumbling of your data lets you make it a Functor/Applicative/Monad/Monoid/Comonad/whatever
02:41:21 <quchen2> Tekmo's patterns are about idiomatic code. In Java which certainly popularized patterns, they are about unidiomatic code.
02:42:10 <Cale> Yeah, and that's often a good thing to try to do. It's good to think about what *actual* design patterns we have though, in order to speculate about future programming languages. There aren't so many which are crystal clear at the moment. The one thing I always like to link when this comes up is SPJ's talk about combinator libraries though.
02:42:48 <Cale> http://ulf.wiger.net/weblog/2008/02/29/simon-peyton-jones-composing-contracts-an-adventure-in-financial-engineering/
02:43:34 <tdammers> well, if there is one pattern that is really common in Haskell, it has to be "(E)DSL"
02:44:33 <tdammers> but really, I think Haskell, more than most other languages, tends to bake patterns and abstractions into explicit things, rather than describing them as "out-of-band" conventions
02:44:34 <Cale> This approach to problem solving by constructing data types that encode the problem space in such a way that the solutions to problems can be built up from the solutions to their parts is I think the closest thing we have to a design pattern.
02:45:29 <Cale> Design patterns aren't really something you want your language to have. Ideally if you can spot something repetitive that you're doing, you can abstract that out into a library and never have to do it again.
02:45:41 <Cale> (or at least save a lot of the work)
02:46:09 <tdammers> design patterns aren't that bad; but what people call "design patterns" are usually more like "code patterns"
02:47:35 <tdammers> and some of the popular design patterns are really design patterns, but implementing them in something like Java requires plenty of repetitive boilerplate code, so people tend to mistake the repetitive code for being the "pattern"
02:47:52 <quchen2> Cale: I don't want to use the term like that. A design pattern is a design you repeatedly find useful. That's a very nice thing to have in a language. What you don't want to have is being forced into awkward designs by your language.
02:48:19 <Cale> quchen2: But do you really call it a design pattern when it just means "use library X"?
02:48:49 <merijn> I want to use the term pattern for patterns on how to design your libraries/APIs
02:49:01 <Cale> In my mind, things stop being design patterns the moment we understand them well enough to turn them into code.
02:49:14 <quchen2> Cale: Hmm. Let's pick pipes as an example. It's an amazing pattern built upon free monads (also a pattern) that can be packed in a library.
02:49:21 <Cale> (and we make our languages expressive enough for that to work)
02:49:26 <tdammers> again, "design pattern" != "code pattern"
02:49:41 <Cale> quchen2: Yeah, I wouldn't call pipes or free monads a design pattern
02:49:47 <tdammers> Factory, for example, is a useful design approach
02:49:50 <Cale> They're just libraries we can use.
02:49:53 <quchen2> I'd say using pipes and structuring your program to make use of them is a pattern that lets you design a program around it. It's a totally different thing than Java's "design patterns" though.
02:50:02 <tdammers> but if you have to type the same boilerplate code to make it happen every time, then something is wrong
02:50:28 <quchen2> Cale: Libraries mostly abstract over patterns as well. I really think we should use "design pattern" in the word sense.
02:50:44 <quchen2> But that probably won't ever happen, so your standpoint is pretty safe :-P
02:51:00 * hackagebot keter 1.3.9 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.3.9 (MichaelSnoyman)
02:51:51 <Cale> Maybe the whole idea of using category theory to understand the structure of programs is a design pattern, though that's even more hazy than the combinator library example.
02:52:04 <tdammers> otoh, if you implement your "factory" as just a function that returns other functions based on the parameters it receives - then the design approach is still there, but the code pattern is reduced to "use a higher-order function"
02:52:43 <Cale> One day when mathematicians and programmers are finally writing in the same language, using category theory will no longer be a design pattern.
02:53:31 <Cale> Yeah, design patterns also can't be features of the language in my mind.
02:53:48 <tdammers> I guess that's what I'm trying to say
02:53:50 <Cale> It's a derisive word we use to refer to the stuff we're not good at.
02:53:53 <quchen2> Cale: The "anonymous function" design pattern :-D
02:54:27 <tdammers> the way I see it, design patterns aren't bad as long as they are exactly that
02:54:32 <yoshuawuyts> still waiting for the "pattern designer design pattern"
02:54:51 <tdammers> you develop a design approach that works well on a certain class of problems, and remember it
02:54:57 <Cale> (but at the same time, stuff which we understand well enough that maybe we can envision a future in which those aren't patterns any more, but either part of the language or a library in it)
02:55:23 <tdammers> maybe
02:55:31 <yoshuawuyts> Cale: that seems like a nice philosophy
02:55:45 <tdammers> but actually, many of these design patterns are already perfectly trivial and concise to write
02:56:41 <quchen2> Cale: We'll have to wait just a little longer until Haskell's doomed to succeed.
02:57:36 <merijn> Cale: The languages of mathematicians is dangerously implicit and ambiguous in many cases :p
02:57:45 <mroman> greeny: ByteString Strict and Lazy
02:58:06 <mroman> but nvm fixed it.
02:58:40 <merijn> mroman: A more common way to abbreviate those than BS and BL (something to consider for other readers) would be BS and LBS respectively
02:58:50 <yoshuawuyts> Going super speculative, but I don't think Haskell will ever really go mainstream. Also don't think that's bad.
02:59:10 <Cale> Actually, thinking about it a little more, the design-pattern nature of writing combinators has been significantly lessened by languages like ML and Haskell which have algebraic data types
02:59:31 <Cale> Back when people were first using that pattern in scheme, it was much more of a convention
02:59:44 <solatis> is there any way to make 'cabal test' print out messages to stdout as they come in, not just after completing all the tests?
03:00:31 <solatis> maybe i'll just run dist/build/test-suite/test-suite manually...
03:00:58 <Cale> In Haskell, it's a lot more of an obvious thing to do -- define a recursive data type that describes problems in your problem domain, and then a bunch of functions which take it apart recursively to solve various aspects of those problems.
03:01:07 <tdammers> one could argue that do notation and comprehensions are patterns baked into syntax sugar...
03:01:32 <merijn> yoshuawuyts: It's already slowly going mainstream, imo
03:01:43 <merijn> yoshuawuyts: There's increasing number of big companies deploying haskell
03:02:01 <solatis> well, i think functional programming as a whole is becoming mainstream
03:02:03 <tdammers> not mainstream in the wordpress sense though... don't think anyone would want that
03:02:08 <merijn> And I expect the mandated adoption of Swift will only increase demand
03:02:09 <solatis> haskell becoming more mainstream is a side-effect of that
03:02:22 <Cale> tdammers: b...b... but clckwrks
03:02:25 <tdammers> it's a two-way thing
03:02:32 <Kujanator> Hi, would someone be able to check if my implementation of short circuit AND and OR operators is correct. Thanks. http://pastebin.com/msdnEsfZ
03:02:34 <yoshuawuyts> solatis: yeah, that sounds about right
03:02:36 <tdammers> Cale: oh, yeah.. right... :x
03:02:58 <tdammers> anyway, lots of concepts and approaches from haskell have made it back into mainstream programming
03:03:05 <solatis> i think haskell is very important in the academic sense
03:03:13 <solatis> yes exactly tdammers, that is what i was about to say
03:03:17 <merijn> Kujanator: I don't know what any of the types of those things are and the layout is pretty atrocious, tbh
03:03:18 <Cale> Kujanator: looks correct
03:03:25 <solatis> just look at concepts such as map/reduce in python
03:03:29 <tdammers> you can't call yourself a serious applications programming language anymore if you don't have anonymous functions these days, for example
03:03:30 <Cale> but yeah, fix your layout :)
03:03:33 <Cale> if foo
03:03:36 <Cale>   then bar
03:03:38 <Cale>   else quux
03:03:46 <tdammers> functional programming style has grown increasingly popular in JS
03:04:03 <merijn> I don't think that's my sort of FP, though
03:04:05 <solatis> tdammers, you mean callback hell? :)
03:04:12 <tdammers> solatis: haha... welp
03:04:22 <solatis> but yeah agreed
03:04:22 <Kujanator> ahh ok, wasn't sure how formatting worked. Thanks.
03:04:22 <merijn> I think Swift with's it's type system and generics will do more to convince people haskell isn't scary
03:04:32 <solatis> javascript -> coffeescript -> purescript
03:04:39 <solatis> also, scala and clojure
03:04:42 <solatis> and now f#
03:04:43 <tdammers> no, I mean how people are jumping off the "let's try to make JavaScript's OOP into Java" bandwagon
03:04:57 <merijn> Hell, I've already seen people come here asking "hey, my Objective-C shop is adopting swift and my haskell colleague wrote this, can someone help explain?"
03:05:06 <tdammers> and start going for simpler solutions that typically rely heavily on closures and higher-order functions
03:05:12 <solatis> merijn, haha
03:05:12 <merijn> Turns out it was basically parser combinators + Either monad
03:05:15 <solatis> merijn, that happened?
03:05:32 <solatis> parser combinators are hardly functional programming
03:05:36 <solatis> so is the either monad
03:05:48 <solatis> Go completely embraced the "either monad" into oblivion
03:05:53 <merijn> solatis: Yeah, it was like a week or so ago, blogpost on parser combinators + either
03:05:56 <merijn> No it didn't
03:06:00 <merijn> It did the opposite
03:06:01 * hackagebot buildable 0.1.0.3 - Typeclass for builders of linear data structures  http://hackage.haskell.org/package/buildable-0.1.0.3 (IvanMiljenovic)
03:06:05 <merijn> It requires explicit error checks
03:06:09 <solatis> yeah true
03:06:11 <Cale> I dunno, I consider parser combinator libraries a pretty good example of functional programming
03:06:12 <merijn> You can't short-circuit
03:06:13 <solatis> let me rephrase
03:06:19 <solatis> there is no fmap
03:06:21 <merijn> Which is the entire point of the either monad
03:06:25 <solatis> so, it is all the bad things of the Either monad
03:06:31 <solatis> without the good things
03:06:36 <solatis> like Java's forced exception handling
03:06:40 <quchen2> Cale: After working with ANTLR for a couple of weeks now, I couldn't agree more :-P
03:06:44 <merijn> Cale: I meant that more of a "getting people to believe haskell isn't scary" example
03:07:09 <merijn> solatis: I think Java's checked exceptions are the only thing it got right
03:07:29 <merijn> Trying to write exception-safe haskell I've concluded one thing: Unchecked exceptions are stupid as fuck
03:07:39 <tdammers> parser combinators are highly functional
03:07:51 <solatis> merijn, right, but now there is: ExceptT !!
03:07:56 * solatis is being sarcastic
03:08:05 <merijn> solatis: That's not an alternative
03:08:08 <solatis> i know
03:08:10 <tdammers> a parser is a function that takes a token stream and turns it into a parse tree traversal plus a remaining token stream
03:08:13 <merijn> I want throwIO exceptions, but checked
03:08:34 <merijn> I actually have an idea on how to implement, but don't have time. Trying to recruit a bachelor student to do it as a thesis project
03:08:34 <tdammers> a combinator is a function that takes n parsers and combines them into one
03:08:37 <tdammers> vOv
03:08:45 <tdammers> if that's not functional, I don't know what it
03:08:47 <tdammers> *is
03:08:49 <merijn> So if anyone is in NL and wants to do a bachelor/masters project... ;)
03:08:55 <solatis> tdammers, try to look at f#'s fparsec
03:09:03 <solatis> it uses a mutable state
03:09:06 <solatis> :o
03:09:14 <tdammers> merijn: I'm in NL :D
03:09:22 <solatis> merijn, i am dutch
03:09:36 <tdammers> merijn: don't think I'm in a position for academic endeavors though :D
03:09:46 <merijn> solatis: Looking for a master/bachelor project? :p
03:10:08 <solatis> no, maybe 10 years ago
03:10:09 <solatis> :)
03:10:12 <merijn> Awww
03:10:20 <solatis> right now i have actual code to ship
03:10:23 <solatis> :'(
03:11:00 <tdammers> solatis: consider a career switch to game programming... then maybe you'll have a ship to code instead of code to ship
03:11:18 <frerich> Ouch.
03:11:40 <tdammers> yeah, I know... I'll see myself out...
03:13:00 <gfixler> tdammers: it happens
03:13:11 <gfixler> I work in games, and I know a few people who've coded ships.
03:13:41 <tdammers> and then shipped the code
03:13:45 <tdammers> full circle.
03:13:46 <gfixler> yep
03:14:27 <gfixler> Nants ingonyama bagithi Baba
03:16:02 * hackagebot jailbreak-cabal 1.3 - Strip version restrictions from build dependencies in Cabal files.  http://hackage.haskell.org/package/jailbreak-cabal-1.3 (PeterSimons)
03:26:02 * hackagebot generic-accessors 0.1.0.1 - stringly-named getters for generic data  http://hackage.haskell.org/package/generic-accessors-0.1.0.1 (GregHorn)
03:26:04 * hackagebot Plot-ho-matic 0.5.0.2 - Real-time line plotter for protobuf-like data  http://hackage.haskell.org/package/Plot-ho-matic-0.5.0.2 (GregHorn)
03:37:40 <mpickering> Does anyone remember the name of the library which added a type parameter to IO actions to specify which effects are offered?
03:38:37 <merijn> extensible-effects ?
03:38:44 <merijn> There's like a billion libraries like that
03:38:49 <merijn> Most aren't too fast, though
03:43:22 <mpickering> no I'm thinking of something specific to IO
03:43:45 <mpickering> readFile :: RIO '[ReadFile] String
03:43:55 <mpickering> so you know it can't access a webserver for example
03:46:58 <fractalsea> Is there a way of forking MonadIOs? I have a stack of monad transformers that I want to be avilable to both threads, e.g. a logger. Maybe what I’m thinking of is nonsensical!
03:47:13 <echo-area> Optimizing functions by induction is quite impressive
03:48:54 <mpickering> fractalsea: What behaviour do you expect?
03:50:23 <fractalsea> mpickering: I want to be able to log to the same logger in child threads. I am also working in ExcepT in the main thread, I would like it if the child thread has an error, it will propogate to a error type in the main thread, but I have a feeling that’s not possible
03:51:49 <mpickering> no .. I dont think so
03:52:32 <mpickering> If you want to write to the same logger in child threads you can pass the MVar in explicitly
03:52:47 <mpickering> errors across threads you need to look at async exceptions I think but be careful
03:52:59 <mpickering> someone more qualified will be able to give you a more in depth anwer
03:53:12 <Cale> This is an excellent example of why using monad transformers over IO for things that you can already pretty much do in IO is not always the best plan.
03:55:27 <merijn> As someone more qualified: Async exceptions are an eternal pit of misery and bugs and you're better off becoming a gardener...
03:55:32 <merijn> :p
03:55:39 <fractalsea> mpickering: Thank you
03:56:33 <fractalsea> Cale: Yeah they are nice a lot of the time, but I’ve already had a lot of frustration over libraries that assume a concrete IO type.
03:56:44 <fractalsea> merjin: Good to know ;)
03:57:16 <Cale> fractalsea: But like, in this case, it's not even really well defined what it would mean to fork an arbitrary m-action for some MonadIO m
03:57:33 <fractalsea> merjin: So what do you think is the best way of signalling to the main thread that something went wrong in a child?
03:57:58 <lpaste> echo-area pasted “Optimize by induction” at http://lpaste.net/124376
03:58:36 <echo-area> But I have one question.  The above is the construction in the book, the below is mine.  They are equivalent, right?
03:58:47 <fractalsea> Cale: Yeah I understand enough to know that I’m trying to do something that probably fundamentally doesn’t really make sense, but my understanding is still too limited to get where I’m going wrong
03:58:50 <merijn> fractalsea: Most sanity preserving way? Post updates/errors to a Chan/MVar that the main thread reads
03:59:05 <lpaste> echo-area revised “Optimize by induction”: “No title” at http://lpaste.net/124376
03:59:49 <Cale> echo-area: Yeah, you just combined some steps
04:00:13 <fractalsea> merijn: Hmm OK, makes sense
04:00:16 <echo-area> And I use induction from right to left instead of left to right
04:00:31 <echo-area> Thanks
04:00:37 <Cale> fractalsea: Yeah, usually the answer is "just don't let things go wrong in a way that the main thread has to care about"
04:00:46 <fractalsea> merjin: I’m already reading from STM, so I could just let the child thread die, and then handle an error where the main thread can’t read from the STM
04:00:59 <Cale> fractalsea: It really depends on why you're forking the thread in the first place.
04:01:32 <Cale> fractalsea: If you're forking the thread to asynchronously do something to produce a value that the main thread will need later, use the async library
04:01:41 <fractalsea> Cale: OK, well it’s basically a few http servers I have running to receive requests that the main thread reads from
04:01:58 <Cale> (which will propagate the exception to the main thread when it tries to wait for the value)
04:02:08 <fractalsea> Cale: Ah OK
04:02:15 <Cale> Yeah, that sounds like the sort of thing the async library is rather good at
04:03:05 <fractalsea> Thanks
04:21:06 * hackagebot htsn-import 0.2.4 - Import XML files from The Sports Network into an RDBMS.  http://hackage.haskell.org/package/htsn-import-0.2.4 (MichaelOrlitzky)
05:01:08 * hackagebot unbound-generics 0.1 - Reimplementation of Unbound using GHC Generics  http://hackage.haskell.org/package/unbound-generics-0.1 (AlekseyKliger)
05:03:46 <safinaskar> is there some containers for data in haskell, which are internally implemented as something like pointers and thus can be very fast be compared (because comparision is as fast as pointer comparision). i. e. i want to write "let a = Container some_big_data in a == a" -- here "a == a" is very fast, because pointers only are compared
05:06:08 * hackagebot threads-supervisor 1.0.3.0 - Simple, IO-based library for Erlang-style thread supervision  http://hackage.haskell.org/package/threads-supervisor-1.0.3.0 (AlfredoDiNapoli)
05:06:28 <dcoutts> safinaskar: you can assign things unique ids yourself of course
05:18:48 <safinaskar> dcoutts: okey, but then i should generate random numbers, and this is state. but i want to write pure functional program without passing random generator to functions
05:19:04 <safinaskar> dcoutts: or i can use sequentional numbers, but then, again, i have state
05:20:18 <jtanguy> you can generate unique identifiers without randomness
05:20:46 <jtanguy> UUID version 5 is hash-based
05:21:02 <L8D> UUID v3 is hash-based too
05:21:13 <jtanguy> yes too
05:21:26 <L8D> UUID v4 is the only random version actually
05:21:44 <L8D> but UUID v{1,2} are time-based and something
05:21:51 <jtanguy> iirc v3 is based on md5 and v5 on sha1
05:27:39 <c_wraith> safinaskar: any form of unique naming is a fundamentally stateful operation. Haskell is just forcing you to accept that.
05:28:16 <yoshuawuyts> c_wraith: that sounds philosophical
05:28:26 <mniip> is there a way to mimick the => type operator?
05:28:47 <mniip> 'type a :- (b :: Constraint) = b => a' doesn't appear to have the expected semantics
05:28:48 <product--> When I see <T> and <S,T> generics in code, I wonder what went wrong in the language and think back to the Haskell.
05:28:49 <product--> Is it just me?
05:29:17 <c_wraith> yoshuawuyts: There's a lot of approaching the edge of philosophy when you consider the limits of what is possible.
05:29:21 <merijn> mniip: There's no way to tell whether 'b' is constraining any part of 'a' in that type
05:29:50 <mniip> merijn, well 'type' is supposed to be more of a macro?
05:30:15 <mniip> oh well, type variables being calculated *after* 'type' inlining makes even less sense
05:30:34 <merijn> mniip: type influences scoping
05:31:24 <quchen2> product--: Those expressions just mean that types are parametric, which is something Haskell also has, albeit with better syntax.
05:31:32 <merijn> "type Foo a = Bar a => Baz a; foo :: Foo a -> Int -> Bool" becomes "foo :: (forall a . Bar a => Baz a) -> Int -> Bool"
05:31:57 <merijn> quchen2: I think product-- is complaining about how verbose generics are in other languages
05:32:37 <product--> yeah they appear everywhere
05:33:07 <hodapp> Haskell generics do seem to be quite effortless.
05:33:31 <product--> but haskell has other issues like, if one guy makes stuff in an IO monad i can't plug it into my code unless I turn my whole code into IO monadic
05:33:36 <product--> and etc for other monads
05:34:13 <quchen2> Calling <S> Foo<S> flatMap(final Function<? super T, Foo<S>> mapper) verbose? Haskell snob!
05:34:28 <hodapp> product--: what do you mean? if you wrote pure code?
05:34:45 <mniip> product--, unsafePerformIO!
05:53:05 <safinaskar> dcoutts: jtanguy: c_wraith: thanks. i will consider hashs
05:54:11 <yoshuawuyts> does anyone have a good writeup about monads? Pretty sure that question's being asked a lot, but curious if there's on you like in particular
05:54:55 * yoshuawuyts wants to understand the universe
05:55:45 <L8D> yoshuawuyts: did you check for that in bitemyapp's thingy?
05:56:39 <yoshuawuyts> L8D: you mean this one? http://bitemyapp.com/posts/2014-03-24-monads-bind-join-actions.html
05:56:48 <yoshuawuyts> L8D: hadn't seen it before, thanks!
05:56:58 <L8D> https://github.com/bitemyapp/learnhaskell
05:56:59 <c_wraith> yoshuawuyts: It's hard (maybe impossible) for a *good* writeup about monads to even exist
05:57:02 <Haskellfant> the only way to understand monads is to use them. trying to learn about them by reading & watching videos doesn't help. (ofc this is only my personal experience)
05:57:25 <L8D> yoshuawuyts: that is not a good writeup about monads
05:57:32 <L8D> in fact it doesn't even go over monads
05:57:52 <L8D> yoshuawuyts: By "bitemyapp's thingy" I meant https://github.com/bitemyapp/learnhaskell
05:58:08 <L8D> which is a great way to learn Haskell but I don't know where you're at
05:58:13 <c_wraith> yoshuawuyts: the problem isn't that the concept is hard - it's actually easy.  The problem is that it's so abstract that most people have no way to relate to the idea until they have enough experience
05:58:35 <L8D> GUYS GUYS GUYS HOLD UP DON'T START GIVING SPEECHES ON WHY MONADS ARE THIS AND THAT
05:58:42 <L8D> this has happened way too many timed
05:58:51 <frerich> yoshuawuyts : I think https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/ is a pretty nice read about the issues with writing  things about 'monads'.
05:58:54 <yoshuawuyts> c_wraith: going on the tour of looking for "monads in JavaScript", since that's what I use all day it might be the best to make it *click*
05:58:54 <L8D> don't get carried away when someone comes into the channel asking about monads
05:59:51 <yoshuawuyts> L8D: hah, maybe there should be a canned response for whenever asks about monads :P 
05:59:52 <tdammers> I liked the burrito metaphor
05:59:55 <L8D> yoshuawuyts: DrBoolean's Monad-A-Day videos are interesting because they go over common monad transformers from Haskell but implemented in JavaScript
05:59:57 <tdammers> until I got it
06:00:30 <tdammers> anyhow... bind, return, pure code, typeclasses, done.
06:00:31 <L8D> yoshuawuyts: but they only go over monad transformers and don't go over monads as a whole
06:00:39 <yoshuawuyts> L8D: you got a link for that?
06:01:09 <L8D> yoshuawuyts: https://vimeo.com/105300347
06:01:24 <yoshuawuyts> L8D: ooh, thanks! :D :D
06:01:45 <L8D> yoshuawuyts: actually hold on
06:01:55 <L8D> yoshuawuyts: he has other videos going over functors and monads
06:02:08 <L8D> from a JavaScript perspective
06:02:13 <L8D> if that's what you're looking for
06:02:25 <L8D> https://www.youtube.com/watch?v=ww2Z1URx-G0 maybe?
06:02:53 <yoshuawuyts> lol @ the first comment
06:02:55 <yoshuawuyts> > This talk is rubbish. I got many things incorrect. Please skip this one.???
06:02:56 <lambdabot>  <hint>:1:76:
06:02:56 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
06:03:07 <L8D> lol
06:03:13 <yoshuawuyts> L8D: but it's probably useful nevertheless. Thanks for sharing ^^
06:03:20 <L8D> https://www.youtube.com/watch?v=AvgwKjTPMmM this one
06:04:30 <L8D> yoshuawuyts: where have I seen your nick before?
06:05:07 <yoshuawuyts> L8D: maybe something in a JavaScript channel? If you ever pass by Amsterdam you might've seen me around?
06:05:21 <L8D> yoshuawuyts: oh I've seen you from the js channel
06:05:35 <L8D> weird
06:06:10 * hackagebot yesod-core 1.4.8.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.8.2 (MichaelSnoyman)
06:06:37 <yoshuawuyts> L8D: hah ^^
06:06:42 <yoshuawuyts> not sure I can handle all the fame
06:07:13 <L8D> yoshuawuyts: wait I've seen you're website before
06:08:03 <L8D> hm...
06:08:37 <clrnd> your*
06:10:17 <yoshuawuyts> L8D: hah, wow. the internet is pretty amazing
06:11:10 * hackagebot keter 1.3.9.1 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.3.9.1 (MichaelSnoyman)
06:12:11 <EvanR> if i create a forkIO thread that creates a broadcast TChan, then occasionally writes to it, but noone has a reference to this chan to dup it, will the thread be considered pointless and be collected?
06:12:40 <EvanR> i guess this is really a question about pointless threads surviving
06:12:56 <EvanR> they have no effect on anything can they be eliminated automatically
06:14:48 <L8D> EvanR: yeah I'd be willing to bet it'll get collected
06:15:02 <EvanR> that would be awesome but how do you know
06:15:25 <juanpablo_> Is there an equivalent of the bifunctor instance for (,) from bifunctors in Prelude?
06:15:41 <L8D> GHC is so good that it finds threads that are waiting on a {T,M}Var when no other thread has a reference to that Var
06:15:56 <L8D> and it is so liberal that it terminates that thread
06:16:11 <L8D> or throws an error(?) in the parent thread
06:16:16 <supki> juanpablo_: no
06:16:31 <yoshuawuyts> ohey, I think I understand monads now
06:16:34 <L8D> I've seen the VM do nastily-awesome things with GC
06:16:40 <bennofs> EvanR: I don't think GHC can terminate that thread. It doesn't know if that thread will ever do something else
06:16:41 <supki> juanpablo_: although Data.Bifunctor will move to base in GHC 7.10
06:17:04 <juanpablo_> supki: omg that sounds awesome.
06:17:05 <L8D> I wouldn't doubt it would silently collect a TChan that no one was listening to
06:17:16 <L8D> doubt that it*
06:17:20 <juanpablo_> oh well. the bifunctors package is quite small anyway
06:17:27 <EvanR> bennofs: thats what i figured
06:19:57 <mniip> what would the kind of (->) be
06:20:14 <mniip> ah right
06:20:23 <L8D> EvanR: it raises an error
06:20:26 <mniip> so this is where asterisks come from
06:20:34 <EvanR> L8D: what does
06:20:49 <L8D> EvanR: when a thread blocks indefinitely on an MVar
06:20:52 <EvanR> bennofs: it seems somebody else has thought about this https://wiki.haskell.org/Old-reactive "garbage collecting futures"
06:21:14 <bennofs> L8D: reading from an MVar/blocking on a TVar could raise an error when nobody writes to it
06:21:23 <EvanR> L8D: i know that much, but i was referring to a live thread that writes to a inaccessible broadcast TCHan
06:21:53 <Kujanator> Can someone explain a situation when 'evalB (b1 :&: b2) st' can return a different state to 'evalB (b1 :&&: b2) st' where the difference is one is short circuit and the other eager.
06:22:21 <EvanR> or one that just loops
06:22:32 <c_wraith> Kujanator: are b1 and b2 expressions of type Bool?
06:22:56 <Kujanator> c_wraith, yeah, sorry I should have said.
06:23:11 <c_wraith> Kujanator: the eager one has more potential bottom values
06:23:22 <EvanR> or one that only reads TVars and does nothing with the results
06:23:31 <EvanR> would be cool if those didnt have to exist ;)
06:23:50 <Kujanator> c_wraith, I don't know what 'has more bottom values' means
06:23:54 <c_wraith> @let True :&: True = True ; _ :&: _ = False
06:23:55 <lambdabot>  .L.hs:170:6: Not in scope: data constructor ‘:&:’
06:23:55 <lambdabot>  
06:23:55 <lambdabot>  .L.hs:171:3: Not in scope: data constructor ‘:&:’
06:24:04 <c_wraith> oh, right
06:24:11 <c_wraith> @let True &: True = True ; _ &: _ = False
06:24:14 <lambdabot>  Defined.
06:24:32 <c_wraith> > if Flase && undefined then 1 else 2
06:24:33 <lambdabot>  Not in scope: data constructor ‘Flase’
06:24:34 <lambdabot>  Perhaps you meant ‘False’ (imported from Data.Bool)
06:24:37 <c_wraith> > if False && undefined then 1 else 2
06:24:39 <lambdabot>  2
06:24:43 <c_wraith> > if False &: undefined then 1 else 2
06:24:45 <lambdabot>  2
06:24:57 <c_wraith> Whoops, not strict enough. :)
06:25:00 <c_wraith> @undefine
06:25:01 <lambdabot> Undefined.
06:25:21 <jaseemabid> Hello everyone! I'm having some issues with hunit. I have my main defined as `main = runTestTT $ TestList [testSimple, testFail]`. Running main in ghci shows 2 tests, and one failing as expected. Running the same with cabal shows only one test and status passed. What is going wring here?
06:25:48 <c_wraith> @let True &: True = True ; True &: False = False ; False &: True = False ; False &: False = False
06:25:50 <lambdabot>  Defined.
06:25:55 <c_wraith> > if False && undefined then 1 else 2
06:25:57 <lambdabot>  2
06:26:02 <L8D> @let (&:) = \b b' -> b && b' :: !Bool -> !Bool -> !Bool
06:26:02 <lambdabot>  Parse failed: Parse error: !
06:26:05 <c_wraith> > if False &: undefined then 1 else 2
06:26:07 <lambdabot>  *Exception: Prelude.undefined
06:26:11 * hackagebot pcg-random 0.1.1.0 - Haskell bindings to the PCG random number generator.  http://hackage.haskell.org/package/pcg-random-0.1.1.0 (cchalmers)
06:26:21 <c_wraith> Kujanator: that's the difference
06:26:25 <L8D> @let (&:) = \b b' -> seq b' (b && b') :: !Bool -> !Bool -> !Bool
06:26:26 <lambdabot>  Parse failed: Parse error: !
06:26:33 <L8D> @let (&:) = \b b' -> seq b' (b && b') :: Bool -> Bool -> Bool
06:26:34 <lambdabot>  .L.hs:154:6:
06:26:35 <lambdabot>      Multiple declarations of ‘&:’
06:26:35 <lambdabot>      Declared at: .L.hs:150:1
06:26:37 <c_wraith> L8D: don't do that
06:26:43 <c_wraith> L8D: it errors. :)
06:26:54 <L8D> c_wraith: I thought that's what you wanted to do
06:26:58 <c_wraith> L8D: (@let is a shared namespace)
06:27:10 <L8D> oh
06:27:16 <L8D> that's what you're saying
06:27:42 <L8D> > if seq undefined True then 1 else 2
06:27:44 <lambdabot>  *Exception: Prelude.undefined
06:27:57 <L8D> there you go c_
06:28:09 <c_wraith> L8D: I feel like you missed the point entirely. :)
06:28:11 <Kujanator> c_wraith, thank you.
06:28:16 <L8D> lol
06:28:45 <c_wraith> Kujanator: bottom values are exceptions or infinite loops - things that don't return normally
06:29:07 <L8D> @let 1 
06:29:07 <c_wraith> Kujanator: stricter evaluation leads to more inputs that result in bottom values
06:29:07 <lambdabot>  Parse failed: TemplateHaskell is not enabled
06:29:10 <L8D> oops
06:29:14 <L8D> @let 1 + 2 = 4
06:29:17 <lambdabot>  Defined.
06:29:18 <L8D> mwahahahahahahahaha
06:29:23 <c_wraith> > 2 + 3
06:29:25 <lambdabot>  Ambiguous occurrence ‘+’
06:29:25 <lambdabot>  It could refer to either ‘L.+’, defined at L.hs:157:3
06:29:25 <lambdabot>                        or ‘GHC.Num.+’,
06:29:25 <L8D> i'll stop not
06:29:29 <c_wraith> @undefine
06:29:29 <lambdabot> Undefined.
06:29:33 <L8D> damnit
06:29:41 <L8D> *cries*
06:29:42 <EvanR> ggeeez
06:29:59 <L8D> sorry I'm spamming the chat so much
06:31:33 * frerich pictures a room of 1519 people golfclapping ;-)
06:33:56 <Kujanator> c_wraith, so this one, if False &: undefined then 1 else 2, is the eager operator one which checks the undefined even though it knows the answer is already false?
06:36:45 <jtanguy> i'd say it doesn't know the answer is false
06:40:44 <EvanR> ... i just used unsafePerformIO and it worked .... but for how long
06:40:58 <silver> 7 days
06:41:18 <asdasdasd> Hello fellow hasklers! Me and my CogSci beginner team has a weird problem: a function has return type [[Int]]. We generate this list of lists with the line: "let array =  take (fst size) (repeat (replicate (snd size) (0 :: Int)))", the compiler gives the error Couldn't match type ‘[Int]’ with ‘Int’     Expected type: [Int]       Actual type: [[Int]]     In the first argument of ‘return’
06:41:22 <EvanR> so think of it like a bonus effect which youll need regenerated periodically
06:41:36 <EvanR> like quad damage
06:41:39 <clrnd> asdasdasd, why not paste the line in lpaste.net?
06:42:03 <clrnd> asdasdasd, what is `size`?
06:42:28 <asdasdasd> a tuple with length of the two dimensions
06:42:41 <asdasdasd> lpaste.net, maybe i'll look it up
06:43:19 <clrnd> asdasdasd, it works here, are you sure that's the source of the error?
06:43:50 <aawe> asdasdasd: paste the offending line (the one with "return")
06:44:09 <asdasdasd> return array
06:44:38 <asdasdasd> i modified the name for unnecessary info
06:44:42 <clrnd> asdasdasd, and where are you "returning to"?
06:45:28 <asdasdasd> Right img -> do  			let array = Functions_imghax.konturAnalys img 			print(array)
06:45:57 <fizruk> is <$!> defined somewhere as strict fmap?
06:46:01 <asdasdasd> konturAnalys img is the function with the error code
06:46:25 <asdasdasd> wow, code without linebreaks is bad
06:46:27 <asdasdasd> sorry!
06:47:52 <Kujanator> jtanguy: just seen your reply, if the first term is false in an AND isn't it always false? What other term can make it true?
06:47:56 <asdasdasd> http://lpaste.net/124393
06:48:12 <aawe> asdasdasd: replace "return array" with "array"
06:48:58 <clrnd> asdasdasd, return is of type `a -> f a`
06:49:13 <aawe> return is a monad function, it wraps the value into a monad which in this case is the list monad []
06:49:14 <clrnd> asdasdasd, it seems to me tou just want your function to return the konturArray
06:49:18 <asdasdasd> aawe: wow, thanks! amazing the kind of errors haskell brings
06:49:50 <asdasdasd> aha, thanks
06:50:02 <phaul> asdasdasd: also remove the `do' 
06:50:28 <exio4> asdasdasd: you don't need to use do there
06:50:30 <phaul> you want let blah = ... ; in konturArray
06:50:58 <phaul> ; is the newline
06:51:31 <clrnd> asdasdasd, I;ve annotated a nicer way: http://lpaste.net/124393
06:51:34 <asdasdasd> so do is not needed if you want to execute several lines of code sequentially?
06:51:49 <jtanguy> Kujanator: i didn't say it would make it true
06:52:29 <exio4> asdasdasd: you normally don't care about the order of things in pure functions
06:52:34 <jtanguy> it's like it evaluates both operands in order to lookup the truth table
06:53:01 <exio4> you can pattern match on the where, too
06:53:03 <asdasdasd> clrnd: thanks man, these new ways of writing things keep surprising me! :)
06:53:54 <exio4> where (height,width) = (dynamicMap ... , dynamicMap ...)
06:53:55 <asdasdasd> great lot of help from you guys, thanks a lot! :)
06:54:10 <mridul_seth> I am thinking of starting functional programming (haskell or ocaml). What are some good online resources to start with ? :)
06:54:42 <clrnd> asdasdasd, `do` is only syntax sugar, check this out: http://en.wikibooks.org/wiki/Haskell/do_notation
06:54:56 <rom1504> mridul_seth: maybe http://learnyouahaskell.com/chapters
06:55:31 <clrnd> mridul_seth, https://github.com/bitemyapp/learnhaskell
06:56:40 <mridul_seth> thanks :)
06:56:43 <mridul_seth> How difficult is to move from one functional language to another?
06:57:17 <clrnd> mridul_seth, depends from to which
06:57:38 <mniip> is there a way to control fixity of type-level operators? infixrl doesn't seem to work
06:57:45 <mridul_seth> for example between haskell and ocaml 
06:59:15 <clrnd> mridul_seth, it's a really hard question :P, for example I had a hard time with ocaml
07:01:57 <mroman> I'd say moving from Haskell to a less pure functional programming language is easier than from a less pure to a more pure one.
07:02:26 <EvanR> youll be better prepared to wrangle impurities
07:02:38 <mroman> (fwiw people seem to claim Java as a functional programming language since recent new features)
07:02:49 <tdammers> mroman: moving from Haskell back into the impure world is painful thpough
07:02:58 <mroman> tdammers: I know right.
07:03:06 <mroman> I'm always using ++ instead of + when not coding Haskell.
07:03:09 <mroman> That really sucks.
07:03:35 <jaseemabid> I'm writing a small library and I'm unable to import it into my test files. Not sure where to start. Any help appreciated. Its all in the same cabal sandbox, so I was hoping it to just work. 
07:03:44 <exio4> mroman: that's not related to purity 
07:03:48 <merijn> Is there a nice haskell plotting library?
07:03:50 <mroman> tdammers: I have most trouble with using Exceptions as Control Flow.
07:04:09 <merijn> I'm using matplotlib now, but looking over code I wrote a few months back it's completely ununderstandable
07:04:32 <mroman> like void foo() { bar(); buz(); /* buz may abort with exception */ barabaz(); }
07:04:38 <paxcoder> Geez, how do I do time arithmetic? I just want to know if the difference betwee two time points is more than a day.
07:04:43 <mroman> of course, in real code no comment says that buz will do that.
07:04:55 <tdammers> mroman: you can't do exceptions right...
07:04:59 <paxcoder> (one of those points being current time)
07:05:12 <tdammers> unchecked exception -> too implicit; checked exceptions -> too much boilerplate
07:05:14 <tdammers> :D
07:05:20 <mroman> but Java has varargs
07:05:25 <mroman> you can do cool stuff with varargs.
07:05:34 <tdammers> Java has null references
07:05:40 <tdammers> *everything* is a Maybe
07:05:52 <mroman> as in if(required(req1(), req2(), req3())) { ... } else { nope }
07:06:05 <mroman> where required is (boolean... bools)
07:06:09 <jaseemabid> I can go to the specific test file in emacs, compile and then everything seems to be ok. runhaskell test/Test.hs or cabal test is unable to require the library. How can I ask cabal/runHaskell to look for libraries in the src/ folder also?
07:06:17 <mroman> I prefer that to exception and nested ifs and stuff
07:06:18 <clrnd> everything is wrapped in fromJust too
07:06:38 <mroman> I'd even prefer it to &&
07:06:54 <tdammers> type Java = MaybeT ErrorT RWST IO ()
07:07:42 <exio4> merijn: I only plotted things in "quick and dirty scripts", using easyplot there, and found it good enough, but probably not what you want
07:07:49 <tdammers> anyway, Java always baffles me with how inconsistent it is about compile-time guarantees
07:08:01 <merijn> tdammers: I have an idea on how to infer checked exceptions so you can mostly ignore them in type signatures but still write functions that guarantee "won't throw exceptions", how's that sound?
07:08:13 <tdammers> merijn: in Java?
07:08:17 <merijn> tdammers: No, haskell
07:08:39 <merijn> tdammers: I'm not sure it can be retro-fitted in GHC without becomg to Haskell Report violating, though
07:09:04 <tdammers> would be cool, I guess
07:11:12 * hackagebot xcffib 0.2.1 - A cffi-based python binding for X  http://hackage.haskell.org/package/xcffib-0.2.1 (TychoAndersen)
07:13:12 <idem-pyon-tent> Using kind polymorphism, is there any way to a generalized functor class that subsumes both Functor and Bifunctor?
07:16:28 <safinaskar> yoshuawuyts: look for monads in "learn you a haskell". very good
07:18:07 <haskellhelppls> Hi, where should I write the Int list when defining ask? http://lpaste.net/124396
07:18:09 <yoshuawuyts> safinaskar: hah, thanks. I understand them now though. All I needed was an example in syntax I know to make it *click*. If someone said: "ES6 promises are basically a monad" I'd have understood
07:18:37 <EvanR> whats an ES6 promise?
07:19:08 <tdammers> standardized promises API based on all the popular pre-ES6 implementation that were making rounds?
07:19:41 <rzetterberg> haskellhelppls: Try using elem as infix instead: "x `elem` ["a", "b", "c", "d"]"
07:19:48 <yoshuawuyts> EvanR: EcmaScript 6, aka ES2015, aka JavaScript 6
07:19:53 <EvanR> a
07:20:20 <EvanR> how are they a monad
07:20:36 <haskellhelppls> rzetterberg: That is not our problem exactly... We want to implement this list [0,0,0,0] in the ask-function
07:21:04 <rzetterberg> haskellhelppls: Sorry, thought the problem was with the warning.
07:21:10 <merijn> EvanR: "data Promise a" plus async callback "a -> Promise b"?
07:21:26 <yoshuawuyts> EvanR: well, they wrap functions that are then chained to do chain data through. My explenation skills aren't very good though :p
07:21:29 <EvanR> oh is that how it works ok
07:21:36 <EvanR> similar to "jquery is a monad"
07:21:36 <haskellhelppls> :rzetterberg: no worries... but do you understand our current problem? I'm kind of stuck.. :(
07:21:46 <merijn> EvanR: Basically, Promises are Async from async library
07:21:58 <merijn> which, incidentally is a monad too
07:22:06 <yoshuawuyts> merijn: hah, thanks :P
07:22:24 <yoshuawuyts> s/explenation/explanation/
07:22:42 <merijn> yoshuawuyts: On that note, you should look at async for the haskell way of handling async operations
07:22:54 <clrnd> if Java is a monad transformer stack, JS is that + unsafePerformIO
07:23:03 <rzetterberg> haskellhelppls: Not really. If you explain what you are trying to achieve and what problems you encounter I could probably help you though :)
07:23:07 <yoshuawuyts> merijn: the async module on npm you mean? which parts are haskelly from that?
07:23:25 <EvanR> clrnd: dont make my head explode first thing in th morning
07:23:37 <clrnd> :P
07:23:52 <greeny> haskellhelppls: even your base case dont seem to work for me. ask takes two parameters...
07:24:22 <greeny> use: ask [] _ = putStrLn "..."
07:24:32 <yoshuawuyts> clrnd: not sure what all that meant but sounds like it ain't going well for JS :P
07:24:56 <merijn> yoshuawuyts: No, the haskell library async
07:24:59 <merijn> @hackage async
07:24:59 <lambdabot> http://hackage.haskell.org/package/async
07:25:15 <tdammers> well, at least in JS you can have closures without introducing a meaningless anonymous class
07:25:18 <yoshuawuyts> lambdabot: ohi, you're pretty neat
07:25:19 <clrnd> I'm gonna say it only once: JS is the best mainstream language we have available
07:25:39 * clrnd hides under a rock
07:25:41 <tdammers> clrnd: what a cruel truth
07:25:43 <haskellhelppls> Okay. I'm trying to create a "sorting-hat" as in harry potter. So using this program, one will answer different 10 questions, and can answer using 4 different alternatives. http://lpaste.net/124397  We want it so that answering alternative "a" will increase the first element of a list as this [0,0,0,0] to [1,0,0,0] 
07:25:45 * EvanR increments clrnd's counter
07:25:56 <EvanR> (for number of times he said that)
07:25:59 <EvanR> currently 1
07:26:11 <greeny> haskellhelppls: entcoundering same problem on the second case. why do you omit the integer array?
07:26:13 * hackagebot diagrams-rubiks-cube 0.1.0.0 - Library for drawing the Rubik's Cube.  http://hackage.haskell.org/package/diagrams-rubiks-cube-0.1.0.0 (TimBaumann)
07:26:14 <yoshuawuyts> hahaha, wow.
07:26:34 <haskellhelppls> greeny: have u tried using the latest code i sent? http://lpaste.net/124397
07:26:50 <yoshuawuyts> merijn: thanks, will plow through it to improve my h4cksc477 5k1775
07:26:51 <EvanR> javascript and haskell are practically all you ever need ;)
07:27:00 <EvanR> browser vs desktop / browser
07:27:08 <yoshuawuyts> and incidentally my understanding of life
07:27:10 <EvanR> poor phones :(
07:27:27 <jameseb> haskellhelppls: a 4-tuple of Ints may be what you want instead of a list of Ints
07:27:56 <merijn> yoshuawuyts: As far as I know about JS promises/what not (very little), async is basically everything they do and more, except implemented as library instead of building it into the language
07:27:58 <tdammers> I sense integer blindness
07:28:23 <tdammers> data House = Ravenclaw | Gryffindor | Hufflepuff | Slytherin
07:29:02 * EvanR uses eyedrops to cure status effect
07:29:03 <yoshuawuyts> merijn: as it should be imo. JS is going to be of C++ like proportions soon
07:29:25 <tdammers> collect answers into a list, sort, group, count lengths
07:29:28 <tdammers> vOv
07:29:54 <haskellhelppls> tdammers: how?
07:31:21 <haskellhelppls> jameseb: How shall I implement that tho?
07:31:57 <saep> haskellhelppls: step by step ;)
07:32:51 <jameseb> haskellhelppls: (Int, Int, Int, Int)
07:33:05 <jameseb> what tdammers said would work too
07:33:31 <jameseb> not sure which would be more efficient
07:34:01 <clrnd> efficiency is not the issue ....
07:34:05 <jameseb> true
07:34:18 <haskellhelppls> jameseb: Thanks!! it works now I think
07:35:16 <jameseb> haskellhelppls: defining a House type as tdammers suggested would be a good idea
07:35:33 <haskellhelppls> it worked doing (Int, Int, Int, Int) though...
07:35:43 <haskellhelppls> feels less complicated aswell
07:35:55 <EvanR> using Ints might be less complicated
07:35:59 <EvanR> and harder to get right
07:36:00 <jameseb> because then you can make ask a pure function rather than having it all in IO
07:36:09 <Guest25565> hello we have tried to define this function, but whenever we get an input that is not an Int the program crashes. how do we make it not crash and instead get an error message that doesnt close it down?
07:36:22 <Guest25565> http://lpaste.net/124398
07:36:32 <jameseb> well, maybe not ask
07:37:35 <clrnd> Guest25565, use reads and pattern match on an empty string https://hackage.haskell.org/package/base-4.7.0.2/docs/Text-Read.html
07:37:36 <aawe> Guest14990: readMay
07:37:40 <aawe> :t readMay
07:37:41 <lambdabot> Not in scope: ‘readMay’
07:37:42 <clrnd> that too
07:37:45 <aawe> :t readMaybe
07:37:46 <lambdabot> Not in scope: ‘readMaybe’
07:37:49 <aawe> hmpf
07:37:54 <clrnd> :t Safe.readMay
07:37:55 <lambdabot> Read a => String -> Maybe a
07:38:00 <tdammers> ok, here's how I'd approach it
07:38:16 <Guest25565> how do we use readMaybe?
07:38:19 <tdammers> first, you need a function that asks a question and returns the answer into IO
07:38:24 <jameseb> haskellhelppls: you could have ask :: String -> [String] -> IO House
07:38:43 <tdammers> askQuestion :: String -> [(House, String)] -> IO House
07:38:44 <yoshuawuyts> merijn: ohey, you work at the UvA
07:39:00 <tdammers> (where the first argument is the question, and the second is a list of possible answers)
07:39:03 <yoshuawuyts> merijn: or well, assuming github.com/merijn is you :P
07:39:26 <tdammers> askQuestion :: (String, [(House, String)]) -> IO House -- would also work
07:39:48 <tdammers> or, even better, bake it into a data type:
07:39:49 <exio4> I used an ad-hoc tree for my "QA" toy program 
07:39:52 <merijn> yoshuawuyts: Yeah
07:39:59 <clrnd> > let mx = Safe.readMay '5' :: Int in maybe 0 id mx
07:40:00 <lambdabot>  Not in scope: ‘Safe.readMay’
07:40:13 <tdammers> data Question = Question { questionText :: String, answerOptions :: [(House, String)] }
07:40:13 <yoshuawuyts> merijn: cool! I'm logging of now though, thanks for all the help ^^
07:40:31 <tdammers> then you can declare a list of questions somewhere
07:40:38 <tdammers> questions :: [Question]
07:40:46 <tdammers> easy peasy
07:41:09 <tdammers> now you need to create a function that asks *all* the questions, in order, rather than just one
07:41:18 <tdammers> askQuestions :: [Question] -> IO [House]
07:41:30 <tdammers> forM or mapM can do that for you
07:41:39 <tdammers> or you could write the recursion yourself
07:42:04 <clrnd> > readMay "5.0" Maybe Float
07:42:05 <lambdabot>  Not in scope: ‘readMay’Not in scope: data constructor ‘Maybe’Not in scope: d...
07:42:12 <clrnd> > readMay "5.0" :; Maybe Float
07:42:13 <lambdabot>  <hint>:1:16: parse error on input ‘;’
07:42:15 <tdammers> then once you have collected the answers, you can use a bunch of standard functions from Data.List to massage the flat list of answers into a suitable format
07:42:15 <clrnd> > readMay "5.0" :: Maybe Float
07:42:16 <CogNub> Btw, I shared this chatroom in our programming tools for cognitive scientists course at uni. Expect a few people with little to no programing experience.
07:42:16 <lambdabot>  Not in scope: ‘readMay’
07:42:23 <aawe> > Safe.readMay "5.0" :: Maybe Float
07:42:24 <lambdabot>  Not in scope: ‘Safe.readMay’
07:42:28 <merijn> clrnd: Please experiment in PM
07:42:34 <clrnd> sorry merijn 
07:42:49 <merijn> Also, why bother with the safe package, since 7.6 GHC ships with readMaybe in Text.Read
07:42:52 <CogNub> Also with little to no experience of IRC
07:42:58 <haskellhelppls> tdammers: wouldnt this work? data p = Points {gryffP :: Int, slythP :: Int, huffleP :: Int, ravenP :: Int}
07:43:29 <tdammers> haskellhelppls: yes, that would also work, but updating records makes for slightly messy code
07:44:03 <tdammers> plus it makes it harder to factor out the "ask question" part such that it doesn't rely on the Points structure
07:44:22 <haskellhelppls> tdammers: getting this error message when trying that code: "Malformed head of type or class declaration: p"
07:44:26 <tdammers> (btw., it's data Points = Point { ... }; not data p = Points { ... })
07:44:32 <haskellhelppls> ah right!
07:44:53 <tdammers> case matters :D
07:45:09 <tdammers> another approach would be using Map (or HashMap)
07:45:10 <haskellhelppls> ya :D now I get an error on the "{"
07:45:32 <tdammers> data Points = Points { ... }
07:47:08 <haskellhelppls> tdammers: why doesn't this work? http://lpaste.net/124402 :(
07:48:16 <tdammers> define "doesn't work"
07:48:21 <xandaros> Is there a function that does the opposite of lookup? Should look something like Eq a => [(a,b)] -> a -> b -> [(a,b)]. Basically changes a value in the map
07:48:22 <clrnd> Guest25565, like this http://lpaste.net/124398
07:48:42 <xandaros> Couldn't find one and I wonder why it wouldn't exist
07:48:57 <EvanR> xandaros: probably because its not a great datastructure to do that with
07:49:02 <geekosaur> ^
07:49:09 <tdammers> xandaros: performance? if you need to update data structures like that, you're probably better off using Map or HashMap or sth
07:49:19 <haskellhelppls> when trying to run the program in winGHCI I get a 10 meter long error message
07:49:24 <geekosaur> if you switch to something sensible like Map then there are a number of ways to change values in the map
07:49:30 <mniip> 'instance Foo r => Foo r' is not an error?
07:49:54 <xandaros> hmm, guess I'll use map then
07:50:30 <tdammers> :t Data.Map.insert
07:50:30 <lambdabot> Ord k => k -> a -> M.Map k a -> M.Map k a
07:51:04 <geekosaur> linked lists are going to be slow for anything but their intended purpose (a loop encoded as a data structure, in which case it can often fuse and make very fast loops)
07:51:39 <greeny> haskellhelppls: e.g. you still missed to add a parameter to ask
07:51:49 <xandaros> I was going to use Map in the end anyway, but I wanted to use a list first, since using Map is always so unwieldy (need to import qualified and I already use M)
07:51:54 <tdammers> haskellhelppls: read the first part of the error message
07:51:56 <greeny> to ask two arguments belong
07:52:07 <tdammers> it tells you exactly what is wrong there
07:52:11 <tdammers> fix that error and try again
07:52:14 <tdammers> rinse and repeat
07:54:39 <TobiasH_> Hi, I'm writing a small webservice with scotty and realized its memory consumption goes up much over its running time. I made a very short minimal example that I think mimiks my problem. The actual code is straight from the scotty docs ( http://codepad.org/xTTDHZzl ) and the test simply requests pages from the server ( http://codepad.org/zbMWK6S9 ). Here ( http://codepad.org/FT2hdYBW ) is the condensed output of my test. It shows 
07:55:35 <TobiasH_> ... Does anybody have an idea how I can prevent this from happening?
08:02:29 <gentaz> hi! new guy here and a hobbyist programmer. Just had a look at haskell. Anyone can recommend a starter book to learn the language?
08:03:08 <lifter> gentaz: http://learnyouahaskell.com
08:03:29 <c_wraith> gentaz: I think http://bitemyapp.com/posts/2014-12-31-functional-education.html is a pretty good list of resources, including their problems.  And yes, they all have some big problems at the moment
08:03:40 <lifter> ^ this
08:04:35 <lifter> gentaz: https://github.com/bitemyapp/learnhaskell
08:06:11 <benzrf> gentaz: don't use LYAH, it has some issues
08:06:13 <frerich> TobiasH_ : Quite curious what the answer to your question is going to be, since I noticed the same thing (though with a different program) while trying some things with Scotty.
08:06:16 <benzrf> gentaz: i second https://github.com/bitemyapp/learnhaskell
08:06:32 <clrnd> TobiasH_, lets see
08:06:46 <clrnd> compiling
08:06:48 <gentaz> benzrf: issues as in? 
08:06:54 <frerich> TobiasH_ : Resource usage of Haskell still eludes me at times, the whole 'non-strict by default' idea makes for a pretty tricky "cost model".
08:07:24 <geekosaur> beyond being somewhat dated and the author has vanished so no updates, we've found that many people have trouble actualy learning haskell *concepts* from it
08:07:25 <TobiasH_> freerich: OK, good to know you have this too with the scotty examples.
08:07:48 <geekosaur> you can learn how to read the language but it's not so good at the "why"
08:07:49 <benzrf> gentaz: it does a bad job of helping you understand how pieces fit together
08:08:02 <benzrf> gentaz: you learn the semantics of the language but not how to think with them
08:08:05 <lifter> YMMV
08:08:22 <TobiasH_> frerich : OK, good to know you have this too with the scotty examples.
08:09:02 <creichert> TobiasH_: do you know how to profile a Haskell app?
08:09:16 <gentaz> thank you! I will give https://github.com/bitemyapp/learnhaskell a look. And is this the right place to ask doubts or is there a seperate channel dedicated to that?
08:09:33 <creichert> gentaz: here or #haskell-beginners
08:09:35 <benzrf> gentaz: this channel is fine but #haskell-beginners is possibly better
08:09:48 <Cale> http://www.seas.upenn.edu/~cis194/spring13/lectures.html
08:10:08 <TobiasH_> creichert : Only from what I read in RWH. I have no experience yet.
08:10:22 <TobiasH_> creichert : Only from what I read in RWH. I have no experience yet.
08:10:36 <gentaz> Thank you
08:10:47 <Cale> I'm starting to become a little bit upset with the existence of #haskell-beginners as separate from #haskell
08:11:01 <Cale> Beginner questions are every bit as welcome here
08:11:16 <Cale> Having the separate channel makes that unclear
08:11:30 <clrnd> TobiasH_, your test doesn't work here, it consumes constant memory
08:12:13 <TobiasH_> clrnd: Mhh, strange. I also tested it under Windows 7 with the same result.
08:12:23 <clrnd> TobiasH_, how much does it grow? when does it stop?
08:12:27 <creichert> TobiasH_: the profiling techniques in RWH would probably work just fine for you to get a better idea if there is a problem
08:13:13 <creichert> not to discourage you from asking further here, though.
08:13:41 <TobiasH_> clrnd: I will leave it running a bit longer to check. My small webservice ( http://codereview.stackexchange.com/questions/82357/small-web-service-using-scotty ) consumes about 100MB after a week.
08:13:50 <Cale> (It's not that I have something against channels for particular study groups of beginners, it's just that the generic naming suggests the wrong thing)
08:14:14 <TobiasH_> creichert: I tried it, but it complains about missing profiling libs, and I was not yet able to install them.
08:14:16 <clrnd> Cale, I felt the same thing when first heard of it, but it seems to work quite well
08:14:51 <Cale> clrnd: Well, sort of. There are a lot more beginners lurking in #haskell, I suspect
08:15:27 <Cale> clrnd: and there's a benefit for all the beginners who are lurking but aren't necessarily talking when beginner questions get answered
08:15:39 <creichert> This channel might be intimidating for some beginners. Maybe haskell-beginners makes them more comfortable to ask questions
08:16:26 <Cale> Yeah, but that's sort of my point, they shouldn't be! Having the separate channel makes it appear as if beginner questions wouldn't be welcome here, while that is *absolutely* not the case.
08:16:30 <clrnd> Cale, yes, but I've seen a couple of hour-long conversations, which can't happen here
08:16:52 <frerich> AFAIK somebody started #haskell-beginners because he was dissatisfied with the 'pedagogy' in #haskell; in a few cases, very basic beginner questions were answered by half a dozen people with twice the number of (usually pointless, err, point-free) solutions.
08:16:57 <clrnd> well let's rename it to #beginners-in-haskell
08:17:30 <clrnd> it's not just that, it's difficult to mantain a conversations here, it's quite crowded as you can see
08:17:35 <TobiasH_> I've now opened an issue ( https://github.com/scotty-web/scotty/issues/155 ). Perhaps I will find out there. Thanks, and have a nice day. :)
08:17:48 <clrnd> I'm not pro-or-against the channel under discussion, just my 2 cents
08:18:04 <clrnd> TobiasH_, that example you linked is quite complicated, it could have nothing to do with Scotty!
08:18:18 <clrnd> TobiasH_, also, GHC 7.6 is quite old
08:19:59 <TobiasH_> clnd: Really? This ( http://codepad.org/xTTDHZzl ) is complicated? It's just copied from here ( http://hackage.haskell.org/package/scotty ).
08:20:15 <merijn> creichert: tbh, I learned a ton from conversation I didn't understand while lurking here as a beginner
08:20:47 <clrnd> TobiasH_, no, the 100MB one
08:20:57 <TobiasH_> clnd: Under Windows 7 I reproduced the problem with GHC 7.8.3.
08:21:06 <exio4> TobiasH_: are you compiling with -O2? 
08:21:23 <TobiasH_> clrnd: Yes, the 100MB one is quite big. I will let the small example run over night to see what happens.
08:21:26 <merijn> TobiasH_: 100MB as listed by windows?
08:21:32 <TobiasH_> exio4: Yes.
08:21:47 <clrnd> merijn, 100MB is another example
08:21:49 <TobiasH_> marijn: Yes, shown in the task manager.
08:21:52 <clrnd> exio4, ^
08:22:15 <clrnd> TobiasH_, or did you manage to make it consume 100MB on windows? maybe I missread
08:22:20 <clrnd> the simple example
08:22:29 <merijn> TobiasH_: And what does the program do, exactly?
08:23:12 <TobiasH_> clrnd: No. Sorry for my description. The small example uses a few MB in windows and Linux. The complex code uses 100MB in Windows. I have not tested it under Linux.
08:23:34 <merijn> I'm not sure the 100MB memory consumption is a problem?
08:23:53 <exio4> merijn: http://codereview.stackexchange.com/questions/82357/small-web-service-using-scotty 
08:24:08 <merijn> exio4: Yes, I looked at it, I have no clue what that's supposed to be doing
08:24:11 <TobiasH_> merijn: It starts with a few MB and grows with time. The highest point was about 150 MB after two weeks or so, so I restarted it then.
08:24:33 <merijn> Isn't this just memory growth from doing IO?
08:25:02 <TobiasH_> merijn: Why has the memory to grow from doing IO?
08:25:06 <merijn> I mean, if you're reading in X MB of data, you need that much memory. I dunno how much/what data this is reading, but it doesn't sound unreasonable
08:25:27 <merijn> TobiasH_: If you read in and process an X MB file that has to be somewhere
08:25:58 <tdammers> merijn: but the trivial scotty example also seems to leak memory
08:26:16 <TobiasH_> merijn: The loaded JSON data is not even one MB. And when I restart the app, it load the data and then runs with only a few MB of memory. The memory consumtion only grows over many days.
08:26:23 <merijn> hmm
08:26:37 <merijn> I've never used scotty, so no idea
08:27:20 <clrnd> I tried the simple example, and couldn't make it leak
08:28:00 <clrnd> it grows until it's a constant 34436 VSZ, 3768 RSS
08:28:14 <tdammers> maybe something weird going on in conduit?
08:28:30 <mniip> I'm guessing the typechecker isn't lazy?
08:28:56 <aawe> TobiasH_: see if this helps you: http://neilmitchell.blogspot.se/2013/02/chasing-space-leak-in-shake.html
08:28:59 <mniip> right, it isn't
08:28:59 <clrnd> TobiasH_, only difference I run the test with 'curl -s > /dev/null'
08:29:28 <clrnd> (don't have time for installin prof libs)
08:31:03 <TobiasH_> clrnd: Do you get the same result as me if you run the tests like I do?
08:31:15 <clrnd> let's see
08:31:27 <tyfghuijpko> hello! Anyone know something like reverse but that generates all possible kombinations of a list of four elements? 
08:31:43 <Cale> > permutations [1,2,3,4]
08:31:45 <lambdabot>  [[1,2,3,4],[2,1,3,4],[3,2,1,4],[2,3,1,4],[3,1,2,4],[1,3,2,4],[4,3,2,1],[3,4,...
08:31:58 <clrnd> TobiasH_, no leak
08:32:35 <TobiasH_> clrnd: Mhh, ok. I hope someone reading the issue I just opened can reproduce it.
08:33:33 <tyfghuijpko> do you have to import a package to use permutations? 
08:35:59 <fractalsea> Is it possible with the package monad-logger, with the transofmer LoggingT, to write the log to both stdout and a file?
08:36:34 <johnw> fractalsea: yes
08:36:43 <johnw> you can write whatever logging function you like
08:37:10 <tyfghuijpko> can you use permutations on [aa,ab,ac,ad]?
08:37:44 <fractalsea> johnw: I’m confused though, because it seems to only accept a single “LogSource”, and I can only run runLoggingT once right?
08:38:05 <johnw> LoggingT is just a ReaderT that holds onto a function
08:38:16 <johnw> you should be able to stick any function you want into it
08:38:38 <johnw> if you can't, then you can newtype your own ReaderT and make it an instance of MonadLogger
08:39:20 <johnw> note: the only real reason to ever use MonadLogger is so that you can opt of logging entirely using runNoLoggingT
08:39:26 <johnw> otherwise, it's not worth the abstraction
08:40:02 <johnw> ah, good, there's even MonadLoggerIO now
08:40:09 <Cale> TobiasH_: I think I can reproduce it.
08:40:34 <johnw> fractalsea: the LoggingT constructor takes a function; a LogSource is just an enum indicates Warning, Debug, etc.
08:40:35 <TobiasH_> Cale: Great, thank you very much.
08:40:37 <Cale> TobiasH_: (it's quite a slow leak here, so a bit hard to spot, but it shows up in heap profiling)
08:41:17 * hackagebot hakyll 4.6.7.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.6.7.0 (JasperVanDerJeugt)
08:41:21 <Cale> oh, hang on, no
08:41:28 <Cale> er...
08:41:44 <TobiasH_> Cale: haha
08:42:04 <fractalsea> johnw: Isn’t that LogLevel?
08:42:10 <johnw> oh, sorry
08:42:14 <johnw> LogSource should just be a string
08:42:19 <johnw> which you can use to mean whatever you want
08:43:00 <Cale> I did a longer profile and all of a sudden the profile looks bumpy -- the bit that was expanding before drops off dramatically at one point...
08:43:06 <fractalsea> johnw: Ah so I need to define my own function like runStderrLoggingT but which prints to a file?
08:43:11 <Cale> Let me keep trying
08:43:13 <johnw> yep
08:43:31 <fractalsea> johnw: hmm, OK, thanks.
08:45:47 <TobiasH_> Cale: Cool, I appreciate your effort. Could you post on github ( https://github.com/scotty-web/scotty/issues/155 ) if you have a result? I have to leave here soon.
08:46:16 <Cale> TobiasH_: http://cale.yi.org/share/ScottyMemoryTest.pdf
08:46:17 * hackagebot rest-gen 0.17.0.1 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.17.0.1 (AdamBergmark)
08:46:50 <Cale> TobiasH_: The horizontal scale is a bit weird, I think that's actual CPU time used, while the program is heavily I/O bound, so it doesn't actually use much real CPU time
08:47:10 <Cale> TobiasH_: that's what I got after running it for a couple of minutes
08:47:50 <TobiasH_> Cale: OK, so in your case it goes down again after some time.
08:47:56 <Cale> yeah
08:47:59 <xnull_> i have {-# LANGUAGE OverloadedStrings #-} above all my imports in a module; in that same module, i'm trying to call a function with an argument of type Data.Text.Text, but i give it a string literal. my ghc does not seem to think that this string literal can be interpreted as a Data.Text.Text value
08:48:10 <xnull_> i have imported Data.Text
08:48:14 <tyfghuijpko> permutations doesn't seem to work on this: [aa,ab,ac,ad], anyone know something like it that work work on that list? 
08:48:21 <TobiasH_> Cale: I had mine running for 10 minutes and it did not go down. At least in the output of ps in the terminal.
08:48:23 <Cale> TobiasH_: Well, the actual allocated memory drops. GHC won't necessarily free that memory to the OS.
08:48:55 <Cale> TobiasH_: (it'll hang on to it and just reuse it for other stuff)
08:49:22 <Cale> tyfghuijpko: What do you mean it doesn't work?
08:49:35 <c_wraith> I believe the current state of the world is that GHC will return pages to the OS if they are totally unused
08:49:41 <Cale> tyfghuijpko: if aa, ab, ac and ad are in scope, then it should
08:49:46 <TobiasH_> Cale: Ah, OK. But at some point it should free something and not just grow and grow, I guess.
08:49:47 <ChristianS> Xnuk: the LANGUAGE pragma must go *before* module ..., not after it. otherwise, it should work.
08:49:48 <c_wraith> And it has enough totally unused pages
08:50:04 <ChristianS> xnull_, sorry -> the LANGUAGE pragma must go *before* module ..., not after it. otherwise, it should work.
08:50:25 <xnull_> oh, thank you! :)
08:50:51 <Cale> tyfghuijpko: did you mean to write something like  permutations ["aa","ab","ac","ad"] ?
08:51:39 <ChristianS> xnull_: i don't know why ghc doesn't complain when you do that wrong, it has bitten me before.
08:51:59 <Cale> I wonder why we even see this weird spiky memory usage
08:52:33 <tyfghuijpko> cale : I have several lists like [aa,ab,ac,ad] and would like to have all the combinations of them, but permutations doesn't seem to work. do I need "" on every two letters? 
08:52:47 <Cale> Like, is there a Chan somewhere which is getting filled up and discharged at intervals or something?
08:53:14 <Cale> tyfghuijpko: Well, aa is a variable name
08:54:14 <Cale> > let aa = 1; ab = 2; ac = 3; ad = 4 in permutations [aa,ab,ac,ad]
08:54:16 <lambdabot>  [[1,2,3,4],[2,1,3,4],[3,2,1,4],[2,3,1,4],[3,1,2,4],[1,3,2,4],[4,3,2,1],[3,4,...
08:54:19 <Jesin> Is there a way to get GHC to produce a warning if you (for example) write a "Monad instance" that does not satisfy the monad laws?
08:54:20 <TobiasH_> Cale: Thanks again. But I have to go now. cu
08:54:33 <meretrix> I'm trying to learn Lens.. what's wrong with my type signature?
08:54:34 <meretrix> @let _1 f (a,b) = (,b) <$> f a :: Lens (a,x) (b,x) a b
08:54:35 <lambdabot>  .L.hs:151:15:
08:54:36 <lambdabot>      Couldn't match type ‘(a0, t2)’ with ‘(a1, x1) -> f1 (b1, x1)’
08:54:36 <lambdabot>      Expected type: (a1 -> f1 b1) -> (a1, x1) -> f1 (b1, x1)
08:54:45 <Cale> Jesin: No, GHC has no way of checking them.
08:54:54 <Cale> Jesin: or requiring you to provide a proof, even
08:55:09 <Jesin> Cale: is there something that does?
08:55:40 <Cale> Jesin: In a dependently typed language like Coq, Agda, or Idris, you can define monads in such a way that proofs of the laws are required.
08:55:41 <tyfghuijpko> Cale: Well, as i said i have several list of that type so to let every two letters be a number wouldn't work.. 
08:55:45 <merijn> Jesin: Dependently languages might be able to do it, but in general this is an open area of research
08:56:03 <Cale> (but even then, the proofs aren't necessarily trivial to provide, they're usually much longer than the definition of the operations)
08:56:05 <xnull_> dependently-typed*
08:56:06 <c_wraith> Cale: there are problems, though, in that equality can be non-decideable.
08:56:17 <c_wraith> Cale: so proving identity can be impossible
08:56:31 <Cale> c_wraith: In real cases?
08:56:44 <Cale> I had no trouble checking that all the mtl monads were monads in Coq, at least.
08:57:01 <c_wraith> Cale: What about something like Coyoneda's Functor instance?
08:57:08 <Cale> Haven't tried that
08:57:28 <Cale> What do you get stuck on?
08:57:57 <c_wraith> I haven't tried it.  Coq may have the tools - I'm just suspicious about it.
08:57:59 <Cale> Also, are you allowing yourself extensionality?
08:58:20 <bajshanna> How do we get this to work? Help pls http://lpaste.net/124409
08:58:26 <c_wraith> I don't think it's possible without extensionality
08:58:54 <Jesin> Cale, merijn: so automated theorem proving just isn't that good yet?
08:59:06 <c_wraith> bajshanna: your indentation is a mess.  Don't mix tabs and spaces
08:59:06 <Cale> bajshanna: Move all that stuff out of the definition of main
08:59:17 <Cale> oh, and yeah, don't use tabs
08:59:40 <merijn> Jesin: Indeed it's not
08:59:43 <Cale> Essentially every decent text editor has an option you can turn on to convert tabs into spaces automatically
09:00:14 <merijn> Jesin: The other problem is that GHC's underlying theory isn't all that amenable to such proofs to begin with
09:00:56 <c_wraith> Yeah, GHC's underlying theory isn't actually consistent, due to bottoms..
09:01:05 <c_wraith> :t let x = x in x
09:01:06 <lambdabot> t
09:01:11 <c_wraith> I have proved EVERYTHING!
09:02:02 <Jesin> oh right
09:02:20 <aawe> map absurd []
09:02:24 <aawe> > map absurd []
09:02:26 <lambdabot>  Not in scope: ‘absurd’
09:02:54 <Jesin> > map (let x = x in x) []
09:02:56 <lambdabot>  []
09:03:08 <Jesin> (is that what you meant, aawe?)
09:03:19 <bajshanna> cale: ok so if I remove the indentations will it work? or do I need to remove "main = do" aswell?
09:03:25 <Cale> I expect that automated theorem proving will remain somewhat difficult forever. Eventually we'll have computers which do a good job of simulating what cortexes do, and we can put them through a mathematics education perhaps, but that's not so different from just asking #haskell to write you a proof.
09:03:50 <tdammers> except that killing mathematicians is no longer unethical
09:04:16 <Cale> bajshanna: Well, you don't really have anything real inside that do-block as it is
09:04:24 <Cale> bajshanna: So for now, you might as well remove it.
09:04:35 <Cale> bajshanna: You might want to write a proper main.
09:04:39 <Jesin> Cale: I suspect that human cortexes may not be the optimal machine for theorem-proving.
09:05:02 <c_wraith> Automated theorem proving is undecideable.  All we can do is give it better hueristics for cases we know how to solve.  Eventually we might categorize all commonly-used proof methods. :)
09:05:10 <Cale> Jesin: Sure, but machines that carry out the algorithm that cortexes are performing might be pretty good.
09:05:28 <Jesin> Cale: hmm, I suppose so.
09:05:32 <Cale> and they wouldn't get tired
09:05:34 <tdammers> funnily though, "is automated theorem proving decidable" is decidable
09:06:12 <Jesin> Cale: as long as you keep them connected to a reliable power supply, of course
09:06:28 <c_wraith> tdammers: is that funny in the same way as "equality on computable reals is noncomputable"?
09:07:40 <tdammers> c_wraith: more meta
09:09:13 <clrnd> Gödel Likes This
09:09:15 <Jesin> would a halting oracle be sufficient to decide the consistency of Peano arithmetic?
09:09:46 <c_wraith> Jesin: no.  Goedel's theorem shows that nothing you add can make it consistent
09:09:57 <c_wraith> Jesin: err, complete
09:10:34 <Jesin> c_wraith: nothing COMPUTABLE you add can make it consistent
09:10:38 <clrnd> time is so funny
09:10:53 <kaidelong> @instances-importing Alternative
09:10:53 <lambdabot> Couldn't find class `Alternative'. Try @instances-importing
09:11:02 <kaidelong> <|> is just mplus?
09:11:16 <geekosaur> you need to specify the things to import...
09:11:21 <c_wraith> kaidelong: if the Alternative and Monadplus instances agree
09:11:33 <c_wraith> kaidelong: and they usually do.  But sometimes not!
09:11:55 <kaidelong> c_wraith: sounds like there should be a law
09:12:09 <c_wraith> kaidelong: the problem is that there are too many possible laws
09:16:32 <JoshieAS> what does the octothorpe denote in typing?
09:16:49 <JoshieAS> like I# or +# or Int#?
09:16:52 <Jesin> c_wraith: a theory in which the set of axioms is defined as the set of all true statements is complete. What Godel proved is that no complete theory powerful enough to express Peano arithmetic can have a computably enumerable set of axioms.
09:16:53 <c_wraith> JoshieAS: it's a convention for unboxed internal types
09:17:40 <JoshieAS> so no pointers/allocations?
09:18:02 <c_wraith> JoshieAS: though of the three you listed, only Int# is a type.  I# is a constructor, and +# is primitive addition
09:18:14 <Yuras> > 'e' ` elem ` "hello"
09:18:15 <lambdabot>  True
09:18:25 <c_wraith> JoshieAS: represented as the raw machine type, rather than as a thunk
09:18:26 <Yuras> space is allowed here ^ o_O?
09:18:36 <JoshieAS> ah, yes, thank you for clarifying
09:18:54 <geekosaur> spaces are fine, yes
09:19:12 <Jesin> c_wraith: if you are allowed to use arbitrary sets of axioms, then you can have a complete theory of Peano arithmetic. My question was whether a halting oracle would be powerful enough to allow the computation of a complete theory of Peano arithmetic, or whether you need a different type of oracle.
09:24:08 <clrnd> Yuras, haskell syntax can be ... fantastic, doesn't it?
09:25:33 <Yuras> clrnd: it is too arbitrary IMO. I just reread HR, and yes -- there is no restriction on spaces here. But probably it is a misfeature
09:25:52 <Yuras> unless there is good reason for it to exist
09:26:16 <exio4> I guess it is a nice way to make something like this valid
09:26:18 <clrnd> > succ `   fmap        ` Just 5
09:26:19 <lambdabot>  Just 6
09:26:31 <exio4> where f = a `abc` b
09:26:48 <exio4>       g = a `ab ` e 
09:27:07 <EvanR> i thought about that but
09:27:12 <EvanR> g = a `ab`  e
09:27:34 <EvanR> also its probably pretty easy to just throw in "and then skip whitespace" into the parser
09:27:44 <EvanR> so they did
09:28:02 <clrnd> many whitespace --such parsing
09:28:33 <Yuras> exio4: I never understand why people align everything -- too many noise in diffs. but yes, the space could be useful if you like alignment.
09:28:46 * clrnd desperately needs a dogefull haskell language
09:29:13 <Welkin> well, haskell is perfect for writing DSLs and compilers
09:29:22 <wcaleb> newbie haskell question: how do i expose a module that is in a hidden package?
09:29:25 <Welkin> you can make the language yourself
09:29:43 <Welkin> wcaleb: what do you mean?
09:29:56 <Welkin> is this a warning that cabal gave you?
09:30:07 <Welkin> if so, just add the package to the list of dependenciesi n your .cabal
09:30:11 <wcaleb> when i try to import a module (or load in ghci) i get a warning that the module is part of a hidden package
09:30:21 <wcaleb> Welkin: so only way around it is to build with cabal?
09:30:27 <Welkin> in ghci?
09:30:31 <Welkin> I have never run into that
09:30:32 <wcaleb> yes, in ghci
09:30:48 <Welkin> are you running ghci inside of a sandbox?
09:30:58 <gcganley> wcaleb: what package is it?
09:31:04 <c_wraith> wcaleb: if you're normally compiling with cabal, you can use cabal repl to get a repl session with the same packages as during compilation
09:31:06 <dcoutts> wcaleb: some packages are by default hidden, but not many (notably the ghc package)
09:31:32 <wcaleb> it's Pandoc; not running ghci inside a sandbox
09:31:40 <Jesin> <Yuras> exio4: I never understand why people align everything -- too many noise in diffs. but yes, the space could be useful if you like alignment.
09:32:10 <Jesin> This is why whenever I have a multi-line block, I usually start it on a new line
09:32:17 <clrnd> but I want to `(==) such Eq a many a so a so Bool`
09:32:44 <Yuras> Jesin: the same here
09:32:47 <wcaleb> maybe problem is that I can only import all of Text.Pandoc, not individual modules like Text.Pandoc.Parsing?
09:33:27 <Jesin> this way you can have everything align nicely while only using a single tab character for each level of indentation
09:34:23 <Welkin> Jesin: we don't use tabs
09:35:02 <Yuras> Welkin: we?
09:35:12 <Jesin> Welkin: a single sequence-of-four-spaces, then. Who is "we" and why don't "we" use tabs?
09:35:16 <Welkin> haskell doesn't make sense with tabs
09:35:27 <clrnd> nothing makes, tabs are evil
09:35:32 <Welkin> sometimes you indent by 2 spaces, other times 3, or 4
09:35:38 <Jesin> Welkin: "whenever I have a multi-line block, I usually start it on a new line"
09:35:39 <Welkin> or even many more, like 12
09:35:40 <clrnd> not even tsvs!
09:36:00 <sleepomeno> When I use the lens package makeFields does not seem to work for types with cycles. Anyone knows it this is the case and how to deal with it?
09:36:00 <Jesin> Welkin: therefore Haskell written in the way I write Haskell makes perfect sense with tabs.
09:36:02 <Welkin> to line up statements and equal signs
09:36:19 <Yuras> I dropped tabs because of one reason: they don't work well with -XCPP. Otherwise they are OK
09:36:43 <jtanguy> wcaleb: Text.Pandoc.Parsing is not exposed by the library, hence the hidden warning
09:36:48 <Jesin> Yuras: why don't they work well with -XCPP?
09:37:29 <wcaleb> jtanguy: thanks; newbie here; how could you tell that without the warning?
09:38:05 <Yuras> Jesin: because many cpp implementations doesn't respect tabs. IIRC clang by default replace then with spaces breaking the layout
09:38:20 <merijn> Yuras: heh? no
09:38:25 <merijn> The problem is with #
09:38:37 <jtanguy> well the warning could refer to a hidden package, like dcoutts said. In the case of pandoc, I took a quick look at the hackage page
09:38:50 <c_wraith> merijn: CPP also chokes on using ' in identifiers
09:38:51 <Yuras> merijn: there is a number of issues with clang and cpp :)
09:39:01 <Jesin> Yuras: as long as each tab gets replaced with the same number of spaces, that shouldn't be a problem unless you are mixing tabs and spaces in a broken way
09:39:04 <merijn> The C standard's spec for CPP technically doesn't allow them anywhere except the start of a line, but GHC haskell source DOES have # in places and of course ' breaks
09:39:09 <merijn> Yuras: This is not an issue with clang
09:39:29 <merijn> Yuras: Haskell can't be sensibly preprocessed by a standards compliant CPP
09:40:01 <jtanguy> wcaleb: Text.Pandoc.Parsing is not listed there. it can be confirmed by looking at the pandoc.cabal (Text.Pandoc.Parsing is listed in Other-Modules)
09:40:01 <merijn> So the fact that we can somehow get gcc's CPP to be non-standards compliant for haskell is a bug in gcc
09:40:53 <Yuras> merijn: yes, cpp in haskell is a pure evil. but it is still widely used
09:41:12 <merijn> Yuras: Anyway, clang CPP doesn't change tabs, because it's not allowed to do that
09:41:19 <wcaleb> jtanguy: thanks; another stupid question; if i moved it to exposed modules in the cabal file and rebuilt, would it then be exposed?
09:41:45 <merijn> wcaleb: Yes
09:42:03 <Yuras> Jesin: cpp may do whatever it wants, e.g. replace tabs with one space, or 8. because C doesn't depend on layout
09:42:50 <merijn> Yuras: CPP can't do whatever it wants, there's a rigid specification of exactly what it does in the standard of what it does
09:44:09 <Yuras> merijn: https://github.com/haskell/cabal/issues/2210
09:46:12 <Yuras> merijn: https://gcc.gnu.org/onlinedocs/cpp/Overview.html
09:46:22 * hackagebot cuda 0.6.6.0 - FFI binding to the CUDA interface for programming NVIDIA GPUs  http://hackage.haskell.org/package/cuda-0.6.6.0 (TrevorMcDonell)
09:46:27 <Yuras> merijn: Also, you cannot rely on it preserving characteristics of the input which are not significant to C-family languages. If a Makefile is preprocessed, all the hard tabs will be removed, and the Makefile will not work. 
09:47:12 <Yuras> merijn: I have no idea about the standard, but cpp messes tabs more often then spaces
09:49:44 <fmapE> Is there a nullary constraint type that inhabits the Constraint kind?
09:50:13 <fmapE> (I'm writing a type family whose output kind is Constraint, and need no constraint at all in one of the cases)
09:50:28 <exio4> fmapE: () ? 
09:50:32 <exio4> the empty constraint
09:51:11 <merijn> fmapE: Yeah, () is the one you want, see for example: https://gist.github.com/merijn/6130082
09:51:27 <fmapE> exio4, merijn: "Expected a constraint, but ‘()’ has kind ‘*’"
09:51:32 <ReinH> fmapE: are you using https://hackage.haskell.org/package/constraints ?
09:51:48 <merijn> Yuras: You might be right, in the sense that CPP does not have to preserve whitespace as is
09:52:13 <quchen> merijn: Oh, type families aren't linear? Interesting
09:52:14 <fmapE> ReinH: nope.
09:52:15 <merijn> fmapE: Explicit signature/annotation? If you look at that gist, it should compile with 7.8 and later (maybe 7.6? I forget)
09:52:31 <merijn> quchen: What do you mean?
09:52:32 <fmapE> I don't have an explicit signature on the output, let me do that...
09:52:42 <merijn> fmapE: It defaults to *, afaik
09:52:46 <quchen> merijn: Maybe I meant the instances. Or "the pattern matching" in your gist.
09:53:07 <merijn> quchen: oh, the double use of 'a' on line 6?
09:53:11 <quchen> Yes
09:53:17 <exio4> closed type families
09:53:17 <merijn> quchen: Closed type families aren't, indeed :)
09:53:27 <exio4> 7.8 feature
09:53:47 <quchen> I see.
09:53:48 <merijn> <3 closed type families
09:54:00 <quchen> And I can't get an empty Constraint to work either.
09:54:12 <quchen> I tried all (permutations of) extensions I thought might work.
09:54:20 <fmapE> merijn: That seems to have fixed it. Thank you!
09:54:21 <merijn> Which GHC and do you have the same set of extensions mine does?
09:54:33 <merijn> :k () :: Constraint
09:54:33 <lambdabot> parse error on input ‘::’
09:54:38 <merijn> hmmm
09:54:45 <quchen> merijn: Your gist works, but the ()::Constraint doesn't
09:55:08 <quchen> () `asTypeOf` Eq Int -- ;-)
09:55:11 <fmapE> 7.8.4, and I have yours +  I think
09:55:30 <quchen> asKindOf, rather
09:55:47 <merijn> There's an asKinddOf?
09:55:50 <fmapE> quchen, merijn: I put the Constraint type annotation on the type family, not the () type
09:55:58 <quchen> merijn: No, I don't think so.
09:56:08 <merijn> fmapE: Right, the return kind for type families is * unless annotated
09:56:19 * fmapE wants his dependent types back
09:56:44 <fmapE> merijn: Huh. Because it was complaining that () was *, not that my other case (that was a Constraint) wasn't *
09:57:08 <fmapE> So I assumed it had inferred the Constraint kind for the type family from the first case, and then was complaining about () having kind * and not matching that inference
09:57:47 <sgronblo> Why am I getting this "Not in scope: type constructor or class ‘ParseError’"? I have imported Text.Parsec.Prim/Combinator/Char.
09:58:32 <sgronblo> Oh maybe it is Text.Parsec.Error?
10:01:46 <jtanguy> it could mean that parsec exports the Type but not it's constructors
10:02:33 <unsafer> is there any way using pipes-bytestring to hint when it can release a chunk of data?
10:04:55 <merijn> unsafer: Why would you need to hint that? That's what the garbage collector is for?
10:07:48 <unsafer> The GC does fine when everything goes through sequentially, but I'm parsing the bytestrings into some data type, and then I need to reorder them in some intermediate data structure. The GC isn't releasing the already-parsed bytestrings even though I don't need them anymore.
10:08:17 <EvanR> if you dont need the bytestring anymore
10:08:29 <EvanR> but you need some of the substrings, you can use copy
10:08:31 <merijn> unsafer: You need to add some strictness, then
10:08:31 <geekosaur> that makes me think your hint is to not be holding onto the bytestring wherever you are doing so
10:08:31 <juanpablo_> I have a list `Monad m => [m a]`, is there a general way to turn it into `Monad m => m [a]`?
10:08:47 <merijn> :t sequence
10:08:48 <lambdabot> Monad m => [m a] -> m [a]
10:09:00 <merijn> juanpablo_: Also, witness the magic of hoogle
10:09:03 <juanpablo_> merijn: thanks. Now I feel silly :(
10:09:08 <merijn> @hoogle Monad m => [m a] -> m [a]
10:09:10 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
10:09:10 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
10:09:10 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
10:09:42 <ReinH> juanpablo_: You didn't know a thing and now you do. Nothing to feel silly about.
10:09:51 <juanpablo_> ReinH: thanks
10:10:01 <ReinH> We all didn't know that thing at one point.
10:10:14 <merijn> Better still
10:10:18 <merijn> Now you know two things
10:10:30 <juanpablo_> Relevant? http://xkcd.com/1053/
10:10:39 <merijn> 1) the fact that sequence exists and 2) the fact that it's mere type is enough for hoogle to find it
10:11:24 <S11001001> juanpablo_: you can frequently make your own structures traversable, and there is even a DeriveTraversable extension, thus introducing the 3rd 'sequence' listed by lambdabot
10:12:28 <S11001001> https://ocharles.org.uk/blog/guest-posts/2014-12-15-deriving.html
10:13:18 <ReinH> juanpablo_: Yep :)
10:13:46 <ReinH> merijn: With (2) being the far more valuable thing :)
10:18:34 <S11001001> juanpablo_: following the edwardk school of typeclass instantiation, I derive Data, Typeable, Generic, Functor, Foldable, Traversable on everything that can support them
10:19:01 <juanpablo_> S11001001: how much compilation overhead does that induce?
10:19:21 <S11001001> juanpablo_: unnoticeable
10:19:35 <juanpablo_> Awesome. I think I'll do the same
10:23:23 <clrnd> is haskell webscale?
10:23:49 <unsafer> merijn: I'm not sure what I'm doing wrong then. I even tried deepseq-ing each parsed element but the bytestrings are still hanging around.
10:26:20 <aaronweiss74> clrnd: if you mean that seriously, yesod massively outperforms other web frameworks (like node and php) from what I've seen.
10:26:54 <Cale> clrnd: http://www.gar1t.com/blog/mongo-db-is-web-scale.html
10:26:55 <clrnd> aaronweiss74, not a fan of yesod's over-reliance on Template Haskell
10:27:24 <clrnd> hahah love this vid
10:27:32 <aaronweiss74> clrnd: snap is 2x as fast as node.
10:27:39 <aaronweiss74> happstack is slightly faster than that.
10:28:05 <aaronweiss74> http://yannesposito.com/Scratch/img/blog/Yesod-tutorial-for-newbies/haskell-benchmark.png
10:28:33 <clrnd> aaronweiss74, I know, I once even tried to put haskell higher on https://www.techempower.com/benchmarks/
10:28:49 <clrnd> couldn't though, no idea why it's not higher ...
10:29:52 <aaronweiss74> So, if you mean is it webscale as a serious question, all of your options outperform everything else.
10:31:02 <clrnd> any idea why wai is below nodejs there?
10:31:06 <JoshieAS> wow, just took a quick look at Yesod and I'm sold
10:31:54 <aaronweiss74> Unsure. I don't know much about the methodology here.
10:32:37 <clrnd> the benchmark is by snoyberg, so I don't think it's a silly mistake
10:32:50 <clrnd> (wai's at least)
10:33:05 <aaronweiss74> Yeah, I hope it wouldn't be something like what happens a lot with Rust benchmarks where people never run optimizations.
10:34:32 <Cale> If you're using the term "web scale" unironically, you don't deserve benchmarks with reasonable methodology anyway ;)
10:35:05 <clrnd> jaja, I wasn't :P
10:35:13 <aaronweiss74> I find it interesting how much Java dominates these benchmarks though.
10:35:28 <creichert> Looks like the benchmarks were run on ghc 7.4.1
10:35:34 <creichert> https://github.com/TechEmpower/FrameworkBenchmarks/tree/master/frameworks/Haskell/yesod
10:35:41 <creichert> https://groups.google.com/forum/?fromgroups=#!searchin/yesodweb/techempower/yesodweb/PQcoZ89KBto/1BjjzPAAd30J
10:35:50 <creichert> some discussion there about a slow random number generator in the original results
10:36:13 <clrnd> creichert, oh thanks, I was looking for this
10:40:33 <ReinH> S11001001, juanpablo_: I often make data structures polymorphic just so I can make them instances of Functor, Traversable. This ends up making them much easier to work with.
10:40:50 <ReinH> Then I use type synonyms to talk about specializations.
10:41:27 <ReinH> Also Monad if they have some notion of effectful computation or substitution.
10:41:48 <ReinH> You get the typeclass behaviors for free and the laws make it easier to reason about them.
10:44:06 <clrnd> creichert, they use GHC 7.8.3
10:44:12 <clrnd> the README just wasn't updated
10:45:08 <ptcek> how can one, for example, read numbers from stdin and output odd ones to stdout and even ones to stderr?? continuously in unix pipe??
10:45:50 <clrnd> I bet conduit can do that
10:45:50 <c_wraith> ptcek: what does a pipe have to do with anything?
10:46:45 <ptcek> c_wraith: maybe nothing, just to process it continuously and not after EOF is reached
10:47:33 <c_wraith> ptcek: The only thing even the slightest bit tricky about this program is writing to stderr requires an import.
10:47:47 <c_wraith> ptcek: everything else just sort of.. works
10:49:04 <c_wraith> ptcek: start with something easy - say a program that reads input and echoes it.  Then modify it to convert the input to numbers.  Then branch based on whether the numbers are even or odd.  Finally, write to appropriate streams in each branch
10:49:27 <ptcek> c_wraith: I used interact for stdout only, but when I added stderr, it waits until eof is reached
10:49:38 <sgronblo> Trying to figure out why this line "s <- many (char 'M')" results in some complaint about no instance for (Stream String Data.Functor.Identity.Identity Char)
10:49:39 <ReinH> ptcek: Then don't use interact.
10:49:55 <c_wraith> ptcek: yeah, don't use interact.  It's too limited
10:49:56 <sgronblo> I thought there should be an instance of Stream for [tok] Monad tok ?
10:50:19 <ptcek> I am not using interact anymore, as it takes (String -> String)
10:51:04 <ptcek> I'll try to prepare minimal example...
10:58:56 <sgronblo> Am I misunderstanding something?
11:01:25 * hackagebot hlibBladeRF 0.1.0.6 - Haskell binding to libBladeRF SDR library  http://hackage.haskell.org/package/hlibBladeRF-0.1.0.6 (eocallaghan)
11:04:05 <ReinH> ptcek: It's easy to write this using pipes based on the tutorial http://hackage.haskell.org/package/pipes-4.1.4/docs/Pipes-Tutorial.html
11:06:22 <aloiscochard> any have done some bluetooth stuff with haskell? the only thing I found is the package `simple-bluetooth`, but looking at the reverse deps it's used for anything on hackage...
11:06:48 <raek> I've made a memory profiling plot using "+RTS -p -hy" and "hp2ps". Now the plot lists some data constructs (I think?), but also "*"
11:06:53 <raek> what does "*" mean?
11:08:42 <raek> this is the plot in question: http://raek.se/dump/Main.ps
11:17:30 <lpaste> ptcek pasted “No title” at http://lpaste.net/124421
11:21:29 <tnks> we're trying to understand how hackage render's PolyKind.  We see "Show (Proxy k s)" in Hackage, but in the source, we see:  "
11:21:38 <tnks> "instance Show (Proxy s) where ..."
11:21:45 <tnks> https://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Proxy.html#t:Proxy
11:21:52 <tnks> https://hackage.haskell.org/package/base-4.7.0.2/docs/src/Data-Proxy.html#Proxy
11:22:29 <tnks> is the answer "Hackage sometimes doesn't keep up with all the GHC extensions perfectly"
11:22:55 <tnks> or is it "no, Hackage actually makes sense once you understand X or Y"?
11:24:52 <Cale> tnks: You're not really asking about hackage, you're asking about haddock, the documentation generator
11:25:03 <Cale> haddock doesn't perfectly keep up with ghc extensions
11:25:17 <Cale> In this case, it's rendering kind variables which are implicit at the source level
11:26:16 <Cale> Haddock is based on the GHC API, so it can often sort of deal with new extensions, but sometimes displays things in a not-entirely-appropriate way.
11:33:06 <rui1> What's the clearest explanation about the monomorphic restriction you know, that it is at least to a usefull extent correct?
11:33:52 <tnks> Cale: oh, sorry, I typed Hackage, I meant Haddock -- typo.
11:34:09 <Cale> rui1: https://www.haskell.org/onlinereport/decls.html#sect4.5.5 is pretty good
11:34:14 <glguy> rui1: If something looks like it's not a function it should behave like it's not a function. You should be able to think that it will only need to evaluate once
11:34:21 <tnks> Cale: thanks for the clarificatino.
11:36:26 * hackagebot broccoli 0.1.0.0 - Small library for interactive functional programs.  http://hackage.haskell.org/package/broccoli-0.1.0.0 (evanrinehart)
11:37:12 <Cale> rui1: But if you want something a bit less technical, basically, "it disallows pattern bindings which are type class polymorphic" is almost correct.
11:37:26 <Cale> Oh, well, ones which don't have explicit type signatures, anyway
11:38:03 <rui1> Humm
11:38:33 <Cale> pattern bindings are things which aren't written with explicit function arguments
11:38:46 <phaazon> why isn’t TupleSections a default?
11:39:12 <phaazon> I don’t see why a dude would go “nah it would break my code”
11:39:15 <phaazon> would it?
11:39:22 <Qfwfq> \
11:39:35 <EvanR> or dudette
11:39:36 <jaseemabid> I have an obvious test that should fail, but hunit is reporting it as success. Also the test count seems to be 1 all the time. Test: https://github.com/jaseemabid/lisper/blob/master/test/Test.hs. Build logs: https://travis-ci.org/jaseemabid/lisper/builds/53837679. Can someone please have a look and tell me where its going wrong?
11:39:46 <phaazon> or dudette yeah
11:39:52 <phaazon> or maybe a dog
11:39:55 <ptcek> c_wraith: hm, seems I it was buffering issues... setting explicitly LineBuffering on stdout solved my problem
11:39:59 <EvanR> more likely a cat
11:40:01 <phaazon> dogskell
11:40:18 <c_wraith> ptcek: yeah, buffering can be problematic
11:40:35 <phaazon> anyway, I hope such extensions will enter the next standard
11:40:56 <phaazon> I often find myself grgrgring at such errors
11:41:04 <phaazon> “Please enable TupleSections”
11:41:09 <phaazon> “Please enable KindSignatures”
11:41:13 <isBEKaml> hi, has anyone built ghc 7.8.4 from source on linux? how long would it take? 
11:41:14 <Cale> phaazon: I don't know how much TupleSections even gets used
11:41:21 <phaazon> I do
11:41:24 <Cale> isBEKaml: A while
11:41:27 <glguy> phaazon: It's rather uncommon
11:41:29 <phaazon> it makes my code nicer 
11:41:35 <phaazon> instead of
11:41:41 <Cale> isBEKaml: If you're not hacking on GHC, you shouldn't be compiling it yoursefl
11:41:42 <phaazon> fmap (\x -> (x,3))
11:41:47 <isBEKaml> Cale: that's a good, unhelpful answer :-)
11:41:49 <phaazon> I can just write fmap (,3)
11:42:03 <Cale> isBEKaml: heh, well, it depends on your hardware
11:42:20 <phaazon> it would actually have a lot of sense that TupleSections gets into the next standard
11:42:21 <isBEKaml> Cale: I have to, because the binaries don't install properly on Slackware 14.1 (I got 7.6.2, though)
11:42:31 <phaazon> because it’s kinda the same feature as partial application
11:42:33 <isBEKaml> Cale: glibc incompatible, I guess
11:42:35 <Cale> isBEKaml: hmm
11:42:36 <phaazon> fmap (*3)
11:42:37 <exio4> isBEKaml: depends on hardware, my 512mb DO vps needed over 3 hours, my desktop compiled it in 20~minutes while watching a movie 
11:42:39 <rui1> Cale: So, stuff that looks like its not a function can't be of type "Num a => a", but can be Int or "a" ?
11:42:39 <phaazon> fmap (,1)
11:42:42 <phaazon> and so on
11:42:47 <phaazon> (,) is a function
11:43:20 <Cale> rui1: basically, yeah
11:43:28 <isBEKaml> exio4: I see. On my laptop, it's well over an hour 
11:43:49 <Cale> isBEKaml: Yeah, that's not unreasonable
11:44:27 <exio4> I'd say 1hs - 2hs should be somewhat common, yeah 
11:44:27 <Cale> isBEKaml: On a fast multicore machine, you can build it in 20 minutes if you use make -j
11:44:46 <isBEKaml> Cale: Okay, thanks. AFAIK, this isn't multi-core
11:44:57 <ptcek> I am confused! hGetBuffering stdout reports LineBuffering, but there is still no output after hundreds of lines.... set explicitly hGetBuffering to LineBuffering and everything works as expected. What am I missing?
11:45:01 <isBEKaml> this is an old toshiba machine
11:45:21 <bramgg> Why might I be getting a "no instance for" error on one computer but my code works on another, when both computers have the same version of GHC and necessary packages?
11:45:27 <Cale> ptcek: weird
11:45:32 <arkeet> bramgg: what's the error?
11:45:33 <glguy> ptcek: Are you redirecting the output to a file, perhaps?
11:45:38 <arkeet> like the exact error
11:45:47 <arkeet> and relevant code
11:45:59 <ptcek> glguy: yes
11:46:20 <bramgg> arkeet: No instance for (MonadIO (Web.Scotty.Internal.Types.ActionT Text IO)) arising from use of 'liftIO'
11:46:22 <glguy> ptcek: stdout is line buffered only when outputing to a terminal device, and block buffered otherwise
11:47:44 <isBEKaml> Cale: one more question, if you don't mind. Does building ghc from source require that happy and alex also be installed along with ghc 7.6?
11:48:37 <ptcek> glguy: that makes perfect sense then! Thx a lot
11:48:40 <isBEKaml> atleast configure didn't complain about them 
11:50:02 <phaazon> hm
11:50:15 <funfunctor> hi
11:50:16 <Cale> isBEKaml: hmm... it's been a while so I don't remember. If it didn't complain, probably just let it go. Maybe it includes a copy of them.
11:50:21 <phaazon> @hoogle (Functor f,Functor g) => (a -> b) -> f (g a) -> f (g b)
11:50:23 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
11:50:24 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
11:50:24 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
11:50:49 <phaazon> @let (<$$>) :: (Functor f,Functor g) => (a -> b) -> f (g a) -> f (g b); (<$$>) = fmap . fmap
11:50:51 <lambdabot>  Defined.
11:51:11 <phaazon> > (*2) <$$> (1,Just 45)
11:51:13 <lambdabot>  (1,Just 90)
11:51:51 <glguy> phaazon: You can experiment with lambdabot in /msg
11:52:41 <Cale> isBEKaml: My source directory for 7.8.4 which I just freshly unpacked contains an already compiled Happy parser
11:52:50 <Cale> isBEKaml: So it seems you shouldn't need Happy to build it
11:53:54 <phaazon> glguy: I was curious
11:54:01 <phaazon> I thought it’d have existed
11:54:03 <phaazon> like huh
11:54:06 <phaazon> (.:)
11:54:10 <phaazon> I don’t remember
11:54:31 <isBEKaml> Cale: weird, I don't see it among the sources. Plus, configure didn't display any version info for Happy and Alex. 
11:55:05 <SCHAAP137> anyone made some music already with the Vivid package?
11:55:13 <Cale> isBEKaml: compiler/parser/ParserCore.hs
11:55:22 <funfunctor> I'm using the following http://lpaste.net/124423 to generate a binary file that is meant to represent a tone but when I plot say the real component in Octave it looks like a BPSK signal, either I am miss-understand the math or something else is happening?
11:55:55 <isBEKaml> Cale: oh, thanks!
11:56:25 <xtianw> Hi, can someone tell me what this GHC error means? https://gist.github.com/xtian/ffde3dc2a7f4f70055e8#file-build-log
11:56:48 <angrygoats> >
11:57:46 <Cale> xtianw: Try deleting the .hi and .o files and building again
11:57:59 <Cale> xtianw: that's really weird
11:58:06 <ReinH> cabal clean should do that
11:58:09 <ReinH> Cale: note that it's clang
11:58:21 <Cale> oh, is it?
11:58:27 <ReinH> "clang: error: linker command failed with exit code 1 (use -v to see invocation)"
11:58:34 <Cale> ah
11:58:54 <Cale> Does ghc actually work with clang?
11:59:16 <funfunctor> ReinH: check your path because clang involcates binutils under the hood for the linker
11:59:28 <xtianw> Same thing after `cabal clean`
11:59:31 <funfunctor> the tooling is a bit of a mess in the frontend because every distro wants to mess with crap
12:01:06 <ReinH> funfunctor: it's not my issue
12:01:21 <ReinH> Cale: it does up until it doesn't
12:01:56 <ReinH> Cale: I had to completely rebuild my Haskell environment with gcc once clang broke. :(
12:02:03 <ClaudiusMaximus> SCHAAP137: i've used hsc3 for some experiments some years ago, what does vivid provide that isn't already there in hsc3?
12:03:04 <SCHAAP137> no idea ClaudiusMaximus, i'm not familiar with hsc3
12:03:46 <SCHAAP137> I'll check it out
12:16:28 * hackagebot hydrogen-prelude 0.15 - Hydrogen Prelude  http://hackage.haskell.org/package/hydrogen-prelude-0.15 (JulianFleischer)
12:22:15 <nitrix> Hi guys.
12:22:26 <nitrix> I made my first huge realisation today, that functions are functors too.
12:22:33 <nitrix> instance Functor ((->) r) where fmap f g = f . g
12:22:40 <nitrix> I don't get what the `r` means though.
12:23:06 <ReinH> nitrix: Same thing as instance Functor (Either a)
12:23:10 <ReinH> It's a type variable.
12:23:24 <ReinH> It means that ((->) r) is a Functor for all types r.
12:24:16 <nitrix> It's the "all types r" that I don't understand.
12:24:19 <nitrix> Take the list for example:
12:24:24 <nitrix> instance Functor [] where fmap = map
12:24:37 <ReinH> Functor instances must be of kind * -> *
12:24:40 <ReinH> :k Either
12:24:41 <lambdabot> * -> * -> *
12:24:48 <ReinH> Either is the wrong kind, but Either a is the right kind
12:24:58 <ReinH> (->) is the wrong kind, but ((->) r) is the right kind.
12:25:02 <nitrix> AH
12:25:14 <nitrix> ReinH: Your words are golden :)
12:25:18 <ReinH> nitrix: :)
12:25:30 <ReinH> Both cases are partially applied type constructors
12:25:40 <jacquerie> > mineBitcoins
12:25:42 <lambdabot>  Not in scope: ‘mineBitcoins’
12:25:42 <ReinH> where we don't care what the first argument is, but it has to exist
12:25:46 <jacquerie> worth a try.
12:26:25 <tdammers> unsafeMineBitcoins -- hah!
12:26:54 <muzzle> In the sodium FRP package how do I implement two behaviours that are mutually dependent ?
12:27:25 <clrnd>  <IO [Bitcoin]>
12:30:20 <Cale> > map (+1) . filter (/= 0) $ zipWith mod (scanl (*) 1 [1..]) [1..]
12:30:21 <lambdabot>  [2,3,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,10...
12:32:02 <isBEKaml> Cale: that's got to win the shortest prime number generator contest :-)
12:32:21 <Cale> nah, there are much shorter ones
12:32:51 <isBEKaml> Cale: is it on codegolf se somewhere?
12:33:02 <Cale> > nubBy(((>1).).gcd)[2..]
12:33:04 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:33:06 <isBEKaml> CodeGolf Stack exchange
12:33:19 <jacquerie> :t nubBy
12:33:20 <lambdabot> (a -> a -> Bool) -> [a] -> [a]
12:33:26 <mmachenry> Cale: Nice
12:33:27 <ReinH> Cale: zipWith mod is quite nice
12:33:57 <isBEKaml> Cale: nice
12:34:16 <Cale> I'm not actually sure my first "prime generator" is actually correct. It ought to be testing if the nth entry is n-1 really, rather than testing that it's not 0
12:34:29 <Cale> That's why 3 shows up twice
12:35:08 <Cale> (it's just lucky that it's prime, I don't know if the exceptions always will be)
12:35:39 <isBEKaml> Cale: why do people write (section .) instead of flip?
12:35:53 <Cale> You mean instead of flip (.)?
12:35:53 <isBEKaml> that's an annoying use of . operator
12:35:56 <isBEKaml> yes
12:36:05 <Cale> whoops
12:36:26 <Cale> ((f .) . g) x y
12:36:38 <kadoban> It'd be nice if there was a flipped (.) in prelude somewhere. Is it me or is it like 2x as natural that way? I tend to just make my own.
12:36:41 <Cale> -> (f .) (g x) y
12:37:01 <jle`> the more i think about it the more i feel like overloaded record fields is a bad idea
12:37:03 <Cale> -> (f . (g x)) y
12:37:17 <Cale> -> f (g x y)
12:37:24 <jle`> kadoban: it's not in prelude but it's in Control.Category
12:37:31 <jle`> the name is a little awkward
12:37:44 <jle`> but i feel like (.) as it is is much more natural
12:37:49 <jle`> (f . g) x = f (g x)
12:37:53 <jle`> it is normal composition order
12:38:01 <Cale> isBEKaml: We're not flipping (.) anywhere here anyway
12:38:14 <jle`> wouldn't it be weird of (g . f) = \x -> f (g x) ... they go backwards
12:38:35 <Cale> Yeah, I prefer ordinary order of composition for the most part
12:38:37 <kadoban> jle`: Oh huh, I didn't know that. (>>>) I guess? Neat.
12:39:00 <Cale> > nubBy(((.)(>1)).gcd)[2..]
12:39:02 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:39:19 <isBEKaml> Cale: I just went from (f .) . g == (flip f) . g
12:39:19 <Cale> isBEKaml: You could write it like that as well, but it's a couple more characters for the extra parens
12:39:32 <Cale> isBEKaml: That's not true
12:39:46 <Cale> (f .) is not at all the same thing as flip f
12:39:57 <Cale> (f .) is (.) f
12:40:04 <Cale> (.) and flip have very different types
12:40:13 <Cale> :t (.)
12:40:14 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:40:16 <Cale> :t flip
12:40:17 <lambdabot> (a -> b -> c) -> b -> a -> c
12:40:54 <Cale> :t (.) ?f
12:40:55 <lambdabot> (?f::b -> c) => (a -> b) -> a -> c
12:41:00 <Cale> :t flip ?f
12:41:00 <lambdabot> (?f::a -> b -> c) => b -> a -> c
12:41:56 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
12:41:56 <isBEKaml> :t (flip ?f .)
12:41:57 <lambdabot> (?f::a1 -> b -> c) => (a -> b) -> a -> a1 -> c
12:41:58 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:43:09 <Cale> ^^ this prime generator is worth thinking about :)
12:45:03 <isBEKaml> :t . . .
12:45:04 <lambdabot> parse error on input ‘.’
12:45:11 <isBEKaml> :t (.) . (.)
12:45:11 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
12:45:35 <Cale> :t fmap
12:45:36 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:45:39 <Cale> :t fmap . fmap
12:45:40 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
12:46:18 <bramgg> "cabal update" -> "there is a new version of cabal-install available" -> "cabal install cabal-install" & repeat forever
12:46:27 <isBEKaml> Cale: yeah :-)
12:46:33 <bramgg> why does it keep saying there's a new version of cabal-install after I've just installed it?
12:46:46 <isBEKaml> Cale: I must have shorted my wires somewhere :D
12:46:55 <kadoban> bramgg: Maybe you're not using the version it installed? Check your path.
12:46:56 <Cale> f x = e -> x and f1 x = e' -> x  gives  (a -> b) -> (e -> e' -> a) -> (e -> e' -> b)
12:47:01 <clrnd> Cale, what's the '?f' notation?
12:47:08 <Cale> clrnd: Implicit parameters
12:47:29 <Cale> clrnd: It's handy when you want to ask for the type of something that happens to have free variables in it
12:47:42 <clrnd> Cale, googling, thanks
12:47:55 <Cale> :t foldr (?f) 0 [1..]
12:47:56 <lambdabot> (?f::a -> b -> b, Num b, Num a, Enum a) => b
12:48:18 <bramgg> kadoban: what would my path tell me?
12:48:19 <Cale> > let ?f x y = x + y in foldr (?f) 0 [1..]
12:48:20 <lambdabot>  <hint>:1:5: Parse error in pattern: ?f
12:48:30 <Cale> err
12:48:43 <isBEKaml> bramgg: maybe you have multiple versions of cabal on your path?
12:49:29 <Cale> > let ?f = \x y -> x + y in foldr (?f) 0 [1..10]
12:49:30 <lambdabot>  55
12:49:34 <Cale> Interesting
12:49:51 <Cale> I didn't know you weren't allowed to use function bindings to define implicit parameters
12:50:33 <kadoban> bramgg: I mean check that it's actually running the binary you think it is, or that cabal thinks it should maybe.
12:52:44 <bramgg> kadoban: Sorry I don't understand... "~/.cabal/bin" is in my path..?
12:53:50 <kadoban> bramgg: What does `which cabal` say? What does 'cabal --version' say? Does it match whatever cabal-install you just installed?
12:54:31 <greeny> bramgg: i had the same issue. i went to haskell.org and downloaded the current version. This problem appeared for me because the version my distro rep were so old.
12:55:08 <unsafer> I'm trying to build up a data structure from an pipes-attoparsec parser and the GC is leaving the bytestrings in memory even after they have been parsed. Anything I can do to get them GC'd? My heap profile looks like this: http://puu.sh/guP9S/95ceee11f0.png
12:55:28 <kqr> I just reimplemented half of a typeclass in PYthon by manually passing around the vtable thing
12:55:36 <bramgg> kadoban: which cabal is "/usr/local/bin/cabal". Cabal version is 1.18.1.3, cabal-install version is 1.18.0.5.
12:55:38 <kqr> makes me appreciate the work GHC does
12:55:48 <kqr> and helped with understanding why type classes are so powerful
12:56:21 <user11>  /join #security
12:56:21 <kadoban> bramgg: So it's not running the ~/.cabal/bin/ version, which is presumably what 'cabal install cabal-install' is updating. You understand what's going on now?
12:56:43 <int-e> unsafer: Hmm, does the parsed data contain sub-bytestrings of the input? it might be worthwhile to copy them (using Bytestring's `copy` function)
12:56:51 <nuser> > sum [1..10]
12:56:52 <lambdabot>  55
12:56:57 <HeladoDeBrownie> kqr, you may or may not have noticed: if not for the implicit passing, a typeclass would be as good as a datatype
12:57:12 <HeladoDeBrownie> kqr, some languages actually do have implicit passing of values of datatypes (e.g., agda)
12:57:20 <bramgg> kadoban: ah okay, thanks
12:57:25 <mauke> > 10 * (10 + 1) `div` 2
12:57:26 <lambdabot>  55
12:57:33 <shachaf> Type classes do more than "implicit passing".
12:57:35 <bramgg> kadoban: should I just remove /usr/local/bin/cabal then?
12:57:58 <unsafer> int-e: Nope, parsing them into vectors/ints
12:58:06 <mauke> bramgg: what does echo "$PATH" say?
12:58:09 <isBEKaml> :t ((. ?f) . ?g)
12:58:10 <lambdabot> (?g::a -> b -> c, ?f::a1 -> b) => a -> a1 -> c
12:58:25 <kadoban> bramgg: Maybe? I don't use my OS's version, so that's what I'd do (uninstall it). Slightly safer might be to rearrange your $PATH so ~/.cabal/bin is near the beginning instead of near the end.
12:58:42 <shachaf> For example "instance Show a => Show [a]" means you have an instance Show [[[[Int]]]]. That instance doesn't exist anywhere at compile time.
12:58:48 <isBEKaml> :t flip (?f . ?g)
12:58:48 <lambdabot> (?g::a -> b1, ?f::b1 -> b -> c) => b -> a -> c
12:59:27 <kqr> :t (?f . ?g)
12:59:28 <lambdabot> (?g::a -> b, ?f::b -> c) => a -> c
12:59:34 <kqr> what's that ? notation? new to me
12:59:38 <clrnd> I don't like ImplicitParams, meh, feels like a global binding kind of
12:59:55 <clrnd> kqr, just asked the same question: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/other-type-extensions.html#implicit-parameters
13:00:31 <kqr> oh
13:00:40 <kqr> that's quite a bit more than I thought it'd be
13:00:44 <clrnd> yeah
13:00:47 <clrnd> me too
13:01:26 <kqr> I have to admit it's kinda cool that you can do it, though
13:01:28 <kqr> heh
13:01:48 <unsafer> int-e: I've tried to use seq/deepseq on the parsed values just to make sure no laziness is present but the heap profile stays the same. Any other ideas?
13:02:22 <mauke> .oO( do you copy? )
13:03:50 <unsafer> I'm not sure what I'd copy, since I'm not storing any bytestrings.
13:04:16 <HeladoDeBrownie> shachaf, i don't see how that's fundamentally different from, e.g., this translation: makeListShow :: ShowData a -> ShowData [a]
13:05:19 <shachaf> It's not (though you need rank-2 types for type class dictionaries sometimes too). But it's not just that GHC figures out which dictionary to pass, it'll figure out how to make the appropriate dictionary.
13:05:39 <HeladoDeBrownie> shachaf, oh, okay, i understand what you're saying now.
13:05:50 <int-e> unsafer: Actually it's strange that the myParser stuff also survives on the heap.
13:06:30 <shachaf> Last I heard Agda's "implicit passing" thing didn't do anything like that.
13:11:33 <int-e> unsafer: But I'm not sure what to make of that, except that it suggests that some incomplete parsing could still be resumed when the heap profile is taken. (I have not used nor looked at pipes-attoparsec; it's conceivable that there are pitfalls in there)
13:15:54 <funfunctor> :t encode
13:15:56 <lambdabot> Not in scope: ‘encode’
13:23:47 <mmachenry> Does LYAH book have a contact for corrects? I find it no where on the site.
13:24:48 <mmachenry> *corrections
13:25:54 <S11001001> mmachenry: 3rd question http://learnyouahaskell.com/faq
13:27:20 <S11001001> mmachenry: list of existing at http://learnyouahaskell.com/errata
13:27:24 <mmachenry> Thank you, I should have mentioned I did find that. I meant something more tied to the errata page. 
13:27:49 <mmachenry> Yeah that page has no form for actually submitting one so just cold emailing the author is probably the only way I guess.
13:28:51 <jle`> mmachenry: yes this is a notorious topic
13:29:10 <jle`> the LYAH author has somewhat disappeared off the face of the haskell world since its publication i think
13:29:34 <mauke> yeah, he poured all of his haskell knowledge into this demonic book
13:29:46 <mauke> now he has nothing left
13:29:57 <jle`> he has just nothing left right
13:30:21 <mauke> true
13:30:35 <jle`> acse of false identity
13:30:38 <jle`> *case of false identity
13:31:22 <jle`> his first product too
13:31:28 <jle`> okay i'll stop
13:31:45 <r0x> hi
13:31:58 <joel2> I'd like to add mapMonotonic to the bimap package.
13:31:59 <joel2> The author and maintainer (Stuart Cook) appears to have disappeared.
13:31:59 <jle`> hi r0x :D
13:32:10 <jle`> what is bimap?
13:32:15 <joel2> Is there a typical way to share these changes
13:32:19 * mauke appears
13:32:22 * mauke disappears
13:32:29 <joel2> It's a map that allows looking up by key or by value
13:33:27 <joel2> I could just make a fork, but I'd rather contribute to the current package
13:34:00 <mmachenry> jle`, mauke: That's too bad. It's a pretty good book. There's an errata page. I'm just hoping to add one point to it.
13:34:48 <mmachenry> I think it's a really good intro to the language. I wish I'd known about it before I was past that point. I read a few less good books and then got to the point where I could read Real World Haskell and that was great.
13:41:34 <loki__> Hi, I have a possibly very stupid question but am chewing on it for quite some time now. It is about this code: http://lpaste.net/124435 Why cant I use the [CHAR] returned by the function composition and STORE it before I output it?
13:42:29 <dmwit> joel2: I think a fairly standard approach is to write to a few mailing lists encouraging people to object to your takeover.
13:42:55 <EvanR> loki__: line 12 you are using a let = instead of a <-
13:43:05 <joel2> Ok. Thanks.
13:43:28 <EvanR> loki__: and you are using =<< when the left hand function isnt an IO function, so you probably want fmap instead
13:45:23 <dmwit> joel2: It occurs to me that since the advent of Hackage2, you may actually need some help from a Hackage admin. Not sure exactly what or who.
13:45:40 <dmwit> (Used to be, anyone could upload a new version of a package at any time. Now there's some access controls.)
13:45:51 <simg> would anyone be willing to look at my stack overflow question about multiple file uploads using digestive-functors? (thanks in advance)  http://stackoverflow.com/questions/28973312/digestive-functors-multiple-file-upload-field
13:46:40 <loki__> EvanR: I'll look it up, thanks
13:47:14 <squiggles> hail internet, does anyone know of a function that could perform this set of matching, [1,2,3,4] -> [((1,2),(3,4)),((1,3),(2,4)),((1,4),(2,3))]
13:47:36 <EvanR> loki__: before you do that, make sure you understand why the code you have now is wrong. look at the types
13:47:57 <joel2> I'll post to cafe once I have it building against Quickcheck2. 
13:48:34 <EvanR> :t (=<<)
13:48:35 <lambdabot> Monad m => (a -> m b) -> m a -> m b
13:48:57 <kadoban> squiggles: That seems pretty ambiguous…what rules do you actually want it to follow? Is it…choose the first one and then one of the other ones, and then put the rest in a separate tuple?
13:49:32 <EvanR> loki__: in your code instead of (a -> IO b) you have (ByteString -> String)
13:49:49 <squiggles> kadoban: my apologies, i'm looking to match each item within the list with a partner if it doesn't already have one
13:50:07 <squiggles> for the first, I matched 1 with 2, therefore 3 would match with 4
13:50:18 <squiggles> another combination could be matching 1 with 3, and therefore 2 with 4
13:50:18 <kadoban> squiggles: What should it do on lists of more than 4 items? What should it do on empty lists? What should it do on lists of one item? Err, what does that mean, if it doesn't already have a partner?
13:50:58 <dmwit> kadoban: I think the tuples (both layers) are intended to be unordered.
13:51:19 <dmwit> kadoban: So this gives all sets of (unordered) pairs.
13:51:21 <dmwit> ...maybe
13:51:33 <kadoban> Ohhh, maybe? So the…top level tuples of the result aren't meaningful?
13:51:47 <squiggles> no
13:52:13 <kadoban> squiggles: Should they actually be there? Or should it just be [(1,2),(3,4),(1,3)…] ?
13:52:17 <dmwit> squiggles: If you can work out how to make it work, the species package might make this exceptionally easy.
13:52:29 <dmwit> squiggles: You might ping byorgey (the author, and a big proponent of the idea).
13:52:53 <glguy> > let example zs = [(x,y) | x:xs <- tails zs, y <- xs] in example [1..4]
13:52:55 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
13:53:16 <squiggles> kadoban: they should be there, I'd like to keep a list of the possible combinations
13:53:41 <Javran> is "hoogle data all" trying to grab all data from hackage regardless of what I have installed on my machine?
13:53:42 <kadoban> squiggles: Okay, but what do they mean, the top level tuples? What order are they in?
13:54:21 <dmwit> kadoban: Think [a] -> [Set (a, a)], probably.
13:54:38 <squiggles> Oh, I was just trying to separate the results of the matching
13:54:51 <dmwit> [a] -> [Set { (x, y) : (a, a) | x < y }], perhaps, in an imaginary world with dependent contract types. ;-)
13:54:52 <squiggles> 1->2, 3->4 and 2->3, 1->4 and 1->4, 2->3
13:55:24 <squiggles> err 1->3, 2->4
13:56:02 <kadoban> I don't get it, unless what glguy said is what you want. I guess I'll let the people who apparently do figure it out.
13:56:38 <dmwit> I don't think glguy got it (yet).
13:57:18 <glguy> I didn't see that the original at tuples of tuples
13:57:50 <dmwit> squiggles: It's not hard to code up, but i can't think of any particularly useful building blocks that are already implemented (other than what I suggested above).
13:57:54 <squiggles> maybe I can reclarify
13:58:25 <squiggles>  I have a list of numbers, lets say 1 through 4. I am looking to produce a list, the first in the list would be (1,3) and (2,4), where 1 is associated with 3, and 2 is associated with 4
13:58:38 <squiggles> alternatively 2 could be associated with 3, and 1 could be associated with 4
13:59:12 <glguy> You're just going to have to implement it, it doesn't exist as something in a common library
13:59:17 <squiggles> understood
13:59:41 <squiggles> thank you
14:03:21 <dmwit> > let { select = go [] where { go bs [] = []; go bs (e:es) = (bs, e, es) : go (e:bs) es }; pairs [] = [[]]; pairs (x:xs) = do { (bs, y, es) <- select xs; remainder <- pairs (bs++es); return ((x,y):remainder) } } in pairs [1..4]
14:03:22 <lambdabot>  [[(1,2),(3,4)],[(1,3),(2,4)],[(1,4),(3,2)]]
14:04:29 <lpaste> glguy pasted “mappings” at http://lpaste.net/124436
14:05:39 <glguy> squiggles: ^ maybe that?
14:05:42 <squiggles> wow
14:06:17 <squiggles> I am going to need some time to read the code, I am new to haskell
14:07:16 <arkeet> @let { select = go [] where { go bs [] = []; go bs (e:es) = (bs, e, es) : go (e:bs) es }; pairs [] = [[]]; pairs (x:xs) = do { (bs, y, es) <- select xs; remainder <- pairs (bs++es); return ((x,y):remainder) } }
14:07:18 <lambdabot>  Defined.
14:07:20 <arkeet> > pairs [1..5]
14:07:21 <lambdabot>  []
14:07:27 <arkeet> > pairs [1..6]
14:07:29 <lambdabot>  [[(1,2),(3,4),(5,6)],[(1,2),(3,5),(4,6)],[(1,2),(3,6),(5,4)],[(1,3),(2,4),(5...
14:08:04 <arkeet> > select [1..5]
14:08:05 <lambdabot>  [([],1,[2,3,4,5]),([1],2,[3,4,5]),([2,1],3,[4,5]),([3,2,1],4,[5]),([4,3,2,1]...
14:08:30 <arkeet> ah, different from the usual select.
14:09:19 <SCHAAP137> i'm attempting to install the package hsc3, but i get an error during cabal install: `bitSizeMaybe' is not a (visible) method of class `Bits'
14:09:29 <SCHAAP137> ghci 7.6.3, ubuntu 14.04
14:09:59 <glguy> SCHAAP137: bitSizeMaybe is new in GHC 7.8
14:10:00 <squiggles> that is a correct production, that is fantastic
14:10:08 <nkar> I'm writing a library that capitalizes all words except articles and prepositions.  the main function is titlecase :: Text -> Titlecase where Titlecase is a newtype wrapper around Text.  I'm seeking opinions on whether wrapping like that is reasonable in a library.
14:10:17 <SCHAAP137> ah, okay
14:10:29 <glguy> SCHAAP137: Note http://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Bits.html#v:bitSizeMaybe
14:10:36 <glguy> "Since: 4.7.0.0"
14:10:41 <arkeet> nkar: why the newtype?
14:10:56 <bergmark> nkar: yes! much better than Text -> Text
14:11:12 <arkeet> SCHAAP137: so the library doesn't specify the right lower bound on the version of base.
14:11:21 <arkeet> maybe you can compile an older version.
14:11:35 <arkeet> what module produces that error?
14:11:54 <SCHAAP137> arkeet, Sound/SC3/UGen/Type.hs
14:11:54 <nkar> arkeet: for typesafety: you know what's titlecase'd and what's not..  the disadvantage is that users would need to write their own functions in order to work with Titlecase
14:12:26 <nkar> bergmark: thanks!
14:13:03 <arkeet> SCHAAP137: ok, try building hsc3-0.14
14:13:10 <tdammers> is there going to be any logic that relies on the fact that a given string is titlecased?
14:13:12 <arkeet> or upgrading ghc :)
14:13:27 <nkar> tdammers: what do you mean by logic?
14:13:45 <HeladoDeBrownie> nkar, do any operations' invariants break if their input is not titlecased?
14:13:49 <bergmark> nkar: one of my biggest gripes with what i'm working on now is that there are too few textual types, you never know what format it's in and it's easy to mix them up
14:13:52 <HeladoDeBrownie> (essentially what tdammers asked)
14:14:05 <tdammers> nkar: well, any code really that takes a titlecased string, and wouldn't make sense if the string weren't titlecased
14:14:26 <SCHAAP137> works! thanks arkeet 
14:14:55 <arkeet> SCHAAP137: and then bug the maintainer about it.
14:16:33 <nkar> tdammers: not in the library.  nothing accepts Titlecase except unTitlecase (from the newtype).  I'm planning to define a few instances for my usecase (so I could use it with yesod)
14:17:22 <nkar> tdammers: the idea is that if users want more, they'll define Titlecase functions themselves
14:17:37 <nkar> which is trivial since it's just a wrapper
14:17:46 <nkar> does it make sense?
14:17:53 <squiggles> kadoban, dmwit, glguy, thank you for your time and effort. I will evaluate what you have provide so I can continue my education with haskell
14:18:10 <HeladoDeBrownie> nkar, are you saying you're also exporting its constructor?
14:18:18 <tdammers> again, if titlecased text is conceptually a different beast, then yes, but I'd expect the titlecase operation to be mostly just cosmetic
14:18:29 <tdammers> same league as substrings and such
14:18:36 <tdammers> or text search/replace
14:24:28 <SCHAAP137> allright arkeet i notified the maintainer
14:24:58 <nkar> HeladoDeBrownie: I'm not sure about this either.  the pro is that not exporting means no nonsense like Titlecase "foo", the con is that some users will never be able to use it if the library does not provide a function they need.  so, I'd rather export everything (except helper functions), but opinions are welcome on this issue
14:25:25 <benzrf> :t (-)
14:25:26 <lambdabot> Num a => a -> a -> a
14:25:40 <HeladoDeBrownie> nkar, in that case you don't really gain much beyond a reminder that "hey, this part should be titletext"; no actual safety, in other words
14:26:13 <HeladoDeBrownie> nkar, and if it's just a reminder you want, using 'type' would probably serve just as well.
14:26:24 <HeladoDeBrownie> then you can use all Text operations with it, since it literally is Text
14:29:38 <nkar> HeladoDeBrownie: I guess I'll not be exporting the value constructor, then.  it should be the last (or second to last) step before rendering, so you shouldn't need to operate on it directly anyway.  I'll just provide the instances I need.  if someone complains, I'll provide more.
14:29:50 <nkar> thanks for your input!
14:30:35 <bergmark> nkar: you can also export the constructor from an "Internal" module so people don't use it by accident
14:30:36 <HeladoDeBrownie> as far as i can tell it'd make a nicer interface just to use Text, but obviously i don't have the full picture
14:32:31 <nkar> bergmark: I considered that (that's what edwardk suggests in the typeclasses talk, right?), but I'm afraid that beginners will find that module and abuse it.
14:33:49 <bergmark> another option that i've used for non-empty text is to have overTextUnsafe :: (Text -> Text) -> NonEmpty -> NonEmpty
14:34:32 <bergmark> if you even end up with an empty text value you know that function is being called incorrectly somewhere
14:34:38 <bergmark> s/even/ever
14:38:05 <edwardk> nkar: Mark it as clearly unsupported. plaster it with warnings and deprecations, but if the guts aren't there, I'm not in a hurry to pick up a dependnecy on a library that will force me to stop work until the maintainer gets around to adding an instance, or worse until they -don't- get around to adding the instance because they want to keep their
14:38:05 <edwardk> dependencies minimal.
14:38:38 <edwardk> your mileage may vary, but access to all the parts I need is a very large component in my decision about whether to incur a dependency.
14:41:27 <mmachenry> I know I need to have the profiling libraries for all of my dependencies just to profile my own code, but is there a simple way to get the data for the dependencies out of the report?
14:41:34 * hackagebot clustering 0.1.1 - High performance clustering algorithms  http://hackage.haskell.org/package/clustering-0.1.1 (kaizhang)
14:42:28 <dmj`> jle`: PING
14:46:53 <HeladoDeBrownie> how can i ask cabal to compute whether a given package set meets all relevant version restrictions, without installing the packages in question?
14:47:37 <nkar> HeladoDeBrownie: iirc, cabal freeze does it, but it also create a freeze file
14:47:41 <kadoban> HeladoDeBrownie: --dry-run ?
14:48:21 <HeladoDeBrownie> kadoban, i think that's probably what i wanted, thanks
14:48:42 <kadoban> Sure
14:49:32 <HeladoDeBrownie> nkar, that looks possibly useful as well, thanks
14:49:38 <nkar> sure
14:51:35 * hackagebot logfloat 0.13.1 - Log-domain floating point numbers  http://hackage.haskell.org/package/logfloat-0.13.1 (WrenThornton)
14:53:31 <nkar> edwardk: okay, I'm convinced.  after all, I'm releasing the library so others could benefit from it.  I can always restrict it in the application (which serves the purpose without imposing burden on library users)
14:54:50 <indiagreen> supki: do you know what could be the reason for libnotify randomly deciding whether to call the action callback or not? It only works approximately every 3rd time for me
14:55:08 <jle`> dmj` pong but you're offline now T_T
15:02:12 <mmachenry> What are the best tutorials for reading profiler output with an eye toward "Did I miss making anything strict that should be?" and also "Am I experiencing too many STM rollbacks where I should switch to atomic actions?" 
15:02:40 <byorgey> dmwit: squiggles ' problem would be exceptionally easy with the species package, but unfortunately the version on Hackage right now doesn't build =(
15:02:46 <byorgey> maybe I'll try to get it compiling again soon
15:03:01 <dfeuer> Ping int-e 
15:03:25 <byorgey> basically squiggles wants to enumerate structures of the species E . E2
15:03:31 <byorgey> if I understood correctly
15:04:38 <funfunctor> hi
15:05:00 <funfunctor> how can I tell encodeFile to encode in little endian?
15:05:29 <funfunctor> > import Data.Binary
15:05:30 <lambdabot>  <hint>:1:1: parse error on input ‘import’
15:05:33 <funfunctor> :t encode
15:05:33 <nkar> mmachenry: search for ezyang posts
15:05:33 <lambdabot> Not in scope: ‘encode’
15:05:41 <glguy> funfunctor: Data.Binary's Binary class is for when you don't care how something is encoded
15:05:58 <nkar> mmachenry: the keywords are: lazy leaks
15:06:10 <nkar> mmachenry: space leaks, too
15:06:27 <glguy> funfunctor: If you want to emit a specific format you can use the operations in Data.Binary.Put to emit that format. You'll use "runPut" at the end
15:06:38 <funfunctor> glguy: how do you mean? It took me ages to debug my program that had a trinity mixture of a int overflow, reversed data and endian ordering issue :p
15:06:54 <funfunctor> glguy: ah ok
15:07:17 <glguy> funfunctor: Data.Binary's Binary class isn't for parsing a predefined format, it's a convenience class for serializing your data to be read back in by the same class
15:08:30 <funfunctor> glguy: well this is my program http://lpaste.net/124442
15:09:11 <funfunctor> its only really a test case for something else, I didn't expect it to take so long.. endian bug makes it look like the signal is BPSK (QAM-2) modulated
15:09:31 <funfunctor> I did the maths and worked out its the same thing
15:09:38 <funfunctor> that's how I realised
15:09:56 <glguy> encodeFile isn't appropriate for encoding an audio file. You can define: myAudioFormat :: [(Int16,Int16)] -> Put
15:10:27 <glguy> and then: runPut . myAudioFormat :: [(Int16,Int16)] -> ByteString
15:11:14 <kadoban> funfunctor: Should I ask what the "Buy me breakfast license" is? Heh.
15:11:47 <funfunctor> kadoban: I made it up yesterday while spending all my time debugging my test case :'(
15:12:08 <kadoban> :)
15:12:20 <funfunctor> glguy: technically its not a audio file but yea something similar
15:12:44 <mmachenry> nkar: These are great, thanks.
15:17:42 <nkar> mmachenry: also: http://apfelmus.nfshost.com/blog/2013/08/21-space-invariants.html http://johantibell.com/files/haskell-performance-patterns.html http://neilmitchell.blogspot.nl/2013/02/chasing-space-leak-in-shake.html
15:18:00 <funfunctor> glguy: isn't Word16le unsigned though?
15:18:02 <mmachenry> Awesome.
15:18:07 <nkar> :)
15:18:12 <funfunctor> glguy: I need Int16 which is signed
15:19:09 <glguy> funfunctor: You'll need to convert your Int16's to Word16s, and then write them
15:19:31 <Peaker> glguy: why not write them directly as signed int16s?
15:19:48 <funfunctor> Peaker: Put monad does not have putIntXY
15:20:13 <Peaker> oh that sounds like an oversight
15:20:25 <funfunctor> I suspect because negative numbers can be encoded in different ways Peaker
15:20:37 <Peaker> only in insane alternate universes and distant past
15:20:45 <rori> is the haskell implementations of SSL/TLS competitive?
15:20:48 <rori> well tested?
15:20:48 <glguy> Because Word16s have a standard encoding an Int16 might happen to be 2s complement or not
15:20:50 <Peaker> 2s complement is the only way that makes sense
15:21:07 <Peaker> who does anything besides 2s complement these days?
15:21:16 <funfunctor> Peaker: not necessarily, it depends what you are encoding for..
15:21:27 <Peaker> (terrible name for such a natural system, "2s complement", makes it sound much more arbitrary than it is)
15:21:36 * hackagebot haskell-neo4j-client 0.3.0.11 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.3.0.11 (asilvestre)
15:21:44 <Peaker> funfunctor: what would you prefer a different encoding for?
15:21:48 <funfunctor> glguy: so I need to compute the two-complement myself to translate the type?
15:22:13 <funfunctor> Peaker: /I/ don't right now.. but if Put is to be general then it should only support Word
15:22:27 <funfunctor> I can see why its not a oversight
15:24:33 <Peaker> funfunctor: it has big-endian vs. little-endian. at the very least it should have putLe2sComp  or such
15:24:53 <Peaker> though I don't think anyone would ever expect anything but 2s complement for a "default" signed whole number encodign
15:24:58 <funfunctor> Peaker: I guess it could support that
15:35:32 <Kareesh> Hi Gents. I am recruiting for ZFUND. We are looking for 3 intermediate / senior developers. We have two positions available for HTML5 mobile ready developers and one position for a Graphics artist. We are offering the opportunity to stay in our 5 star resort in near-central Barcelona, Spain for the length of the project. We are offering a 3,000 – 4,500 euro wage depending on the skill and experience of the app
15:35:32 <Kareesh> licant. The villa is three minutes from the beach, all services and amenities are located near by and we have a gourmet/boutique chef in house. We estimate the length of the project to be around 2 – 3 months. If you wish you to apply for more information, please send your C.V to george@enabl.es. You may PM or Email me for more information. Thank you. George. 
15:35:44 <funfunctor> Is there already a function that computes the 2s complement?
15:36:42 <Peaker> funfunctor: that's the beauty of 2s complement. You don't have to "compute it"
15:36:51 <Peaker> funfunctor: just reinterpret the unsigned word as a signed, and it all works out
15:36:54 <Axman6> Kareesh: I'm not sure solisitation is really on topic here. if you want to advertise a haskell job, then haskell-cafe would be better
15:37:27 <Peaker> funfunctor: if you subtract 1 from 0, using the ordinary subtraction algorithm, ignoring sign altogether, the result you get is ...1111   which is exactly -1 in 2s complement
15:37:30 <ReinH> They aren't even Haskell jobs.
15:37:33 <funfunctor> Peaker: I mean to get types across.. Int16 -> Word16
15:37:43 <ReinH> And ofc some of us are not "gents"
15:37:59 <Peaker> funfunctor: fromIntegral (that assumes the Int16 is sanely using 2s complement)
15:38:10 <Welkin> haha
15:38:16 <Kareesh> ok sorry
15:38:38 <funfunctor> Peaker: ok that's what I am doing so riddle me this.. why am I getting some padding at the beginning..
15:38:45 <funfunctor> Peaker: 1sec.. i'll paste
15:39:12 <lpaste> funfunctor pasted “No title” at http://lpaste.net/124443
15:39:42 <funfunctor> Peaker: see the extra two bytes
15:40:02 <Peaker> funfunctor: what's the code doing
15:40:24 <ReinH> @where ops
15:40:24 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
15:40:52 <lpaste> funfunctor pasted “No title” at http://lpaste.net/124444
15:40:55 <ReinH> Kareesh has been spamming this job add in at least #node.js and #haskell that I know of. They have already been kicked from #node.js, so I find it very unlikely that they are "sorry" at all.
15:40:59 <funfunctor> Peaker: ^
15:41:16 --- mode: ChanServ set +o glguy
15:41:16 --- mode: glguy set +b $a:Kareesh
15:41:16 --- kick: Kareesh was kicked by glguy (Kareesh)
15:41:16 --- mode: glguy set -o glguy
15:41:27 <ReinH> *ad
15:41:51 <Peaker> funfunctor: that's because the Binary instance of list is not similar to your instance
15:41:52 <quchen> If at least he had advertised a Haskell-related job.
15:42:40 <funfunctor> Peaker: how do you mean?
15:42:52 <Peaker> funfunctor: oh, you're not asking relatively to the commented out one
15:43:10 <funfunctor> Peaker: ignore the commented out stuff
15:43:18 <lexi-lambda> Alright, noob here. Can I ask a question?
15:43:23 <Cale> absolutely!
15:43:34 <Peaker> funfunctor: btw, use pattern matching on the tuple instead of fst,snd there
15:43:45 <mmachenry> lexi-lambda: Yes but in general don't bother asking to ask. IRC rule #1 :)
15:43:48 <lexi-lambda> Yesterday I asked a question about how to do some function composition, and mniip gave me this neat solution:
15:43:58 <funfunctor> Peaker: does the same thing right.. not my major concern right now
15:43:59 <lexi-lambda> getCompose (liftA2 (-) (Compose max) (Compose min))
15:44:06 <mniip> hi
15:44:10 <lexi-lambda> mmachenry: It was mostly just me preparing to ask. :P
15:44:18 <lexi-lambda> So I looked at the docs for Compose
15:44:24 <Welkin> George RR Martin said the same thing
15:44:36 <Cale> uh, where did that solution come from?
15:44:44 <Welkin> fan: "can I ask a question?" GRRM: "You just did."
15:44:50 <Peaker> funfunctor: mySignalFormat = mapM_ putPair where putPair (x, y) = putInt16le x >> putInt16le y
15:45:05 <lexi-lambda> I get that Compose has a single data constructor, Compose
15:45:14 <Peaker> or with lenses: traverseOf_ (traversed . both) putInt16le
15:45:19 <lexi-lambda> And I get that Compose is an instance of various typeclasses
15:45:21 <Cale> lexi-lambda: Where is that Compose defined?
15:45:28 <lexi-lambda> Cale: http://hackage.haskell.org/package/transformers-0.4.3.0/docs/Data-Functor-Compose.html#v:Compose
15:45:37 <Cale> oh, I see
15:45:38 <Cale> okay
15:45:54 <lexi-lambda> That page just also lists a `getCompose` value
15:45:58 <Cale> So, you're working with two applicative functors at once here, I guess
15:46:08 <lexi-lambda> and I have no idea what that even means and what it's for
15:46:18 <Cale> What was the original question?
15:46:28 <Peaker> funfunctor: how did you generate the csv one?
15:46:29 <Cale> Ah, getCompose is the field extractor
15:46:34 <Cale> for that single field
15:46:51 <Cale> So,  getCompose :: Compose f g a -> f (g a)
15:47:00 <lexi-lambda> Ooh, I see.
15:47:08 <lexi-lambda> That makes sense, I'm silly
15:47:31 <funfunctor> Peaker: thats from some big C program called bladerf-cli
15:47:33 <Cale> The haddock makes it a little unclear by removing the declaration and turning it into HTML formatting
15:47:46 <Cale> newtype Compose f g a = Compose { getCompose :: f (g a) } -- this is the actual definition of the type, using record syntax
15:48:08 <lexi-lambda> I see, thank you.
15:49:26 <lexi-lambda> I guess I'm just unsure about why Compose is necessary at all here.
15:49:36 <Cale> What was the original question you had yesterday? This strikes me as a somewhat fancy solution, and if the applicative functors you're using are really just the one for functions, then a simple lambda would do nicely.
15:49:37 <lexi-lambda> Why couldn't I just use (liftA2 (-) max min)?
15:49:46 <Cale> You can do that
15:49:52 <Cale> oh
15:49:57 <Cale> I see, yeah, you can't :)
15:50:06 <lexi-lambda> Cale: It's mostly just a silly exercise. I wanted to simplify `\a b -> f a b - g a b`
15:50:12 <Cale> The reason is that max and min both take two arguments
15:50:25 <Cale> liftA2 (-) (max 0) (min 0) say
15:50:28 <lexi-lambda> And by "simplify" I likely mean do something unnecessarily complicated. :P
15:50:40 <jle`> \x -> liftA2 (-) (max x) (min x)
15:50:47 <exio4> looks something like would do it liftA2 (liftA2 (-)) 
15:50:50 <Cale> yeah, that would work
15:50:57 <exio4> but I'd just use the lambda 
15:51:03 <Cale> yeah, you could also liftA2 twice
15:51:04 <jle`> :t (liftA2 . liftA2) (-)
15:51:05 <lambdabot> (Applicative f1, Applicative f, Num c) => f (f1 c) -> f (f1 c) -> f (f1 c)
15:51:21 <Cale> > (liftA2 . liftA2) (-) max min
15:51:22 <lambdabot>  <Integer -> Integer -> Integer>
15:51:26 <Cale> :t (liftA2 . liftA2) (-) max min
15:51:26 <lexi-lambda> I think I need to figure out how liftA2 actually works.
15:51:26 <lambdabot> (Ord a, Num a) => a -> a -> a
15:51:29 <lpaste> funfunctor revised “No title”: “No title” at http://lpaste.net/124444
15:51:38 <funfunctor> Peaker: ^ just so we are on the same page
15:51:48 <Trollinator> is liftA2 f x y the same as f <$> x <*> y?
15:51:50 <jle`> lexi-lambda: for the function instance, it feeds the result to both functions and then combines the results with the combining function
15:51:55 <Cale> lexi-lambda: yeah, so in the function case,  liftA2 f g h = \x -> f (g x) (h x)
15:52:02 <Cale> Trollinator: yes
15:52:13 <jle`> > liftA2 (++) reverse (take 3) "hello world"
15:52:14 <lambdabot>  "dlrow ollehhel"
15:52:15 <Lokathor> Well, I no longer work on a haskell websockets server
15:52:19 <Trollinator> I see. 
15:52:33 <jle`> it applies reverse and take 3 to "hello world", and then (++)'s teh result
15:52:33 <Cale> lexi-lambda: What do you already know about functors and such?
15:52:48 <lexi-lambda> Cale: I know the basics of both functors and applicative functors.
15:53:09 <Cale> lexi-lambda: We're really just using one instance of Applicative here (plus the instance for Compose, when we use that)
15:53:14 <lexi-lambda> I mean, I understand all the things that you're saying
15:53:16 <jle`> i think this is a case of understanding the individual instance being more important than seeing the general pattern
15:53:20 <lexi-lambda> I just have no idea how I'd come up with this on my own :P
15:53:56 <jle`> i'm not sure if you would come up with it on your own, it's just a commonly used combinator for functions
15:53:57 <Cale> Actually, I think it might even be easier to understand the function *monad* first, and then work backward to Applicative
15:53:59 <jle`> like zipWith for lists
15:54:02 <Cale> At least, that's how I think of it
15:54:09 <jle`> i don't know, the function monad is funky
15:54:18 <jle`> the applicative instance is just parallel application
15:54:31 <funfunctor> Peaker: actually the code works now for its intended purpose
15:54:35 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
15:54:37 <lambdabot>  ("hello","olleh","HELLO")
15:54:39 <funfunctor> not sure why the difference is there still
15:54:41 <jle`> takes functions and forks an input through all of them
15:54:55 <jle`> > sequenceA [reverse, take 3, drop 3, map toUpper] "hello world"
15:54:56 <lexi-lambda> What does the function monad do in general terms? I think I grok monads fairly well, but I'm not familiar with most of the individual instances.
15:54:56 <lambdabot>  Not in scope: ‘sequenceA’
15:54:56 <lambdabot>  Perhaps you meant one of these:
15:54:56 <lambdabot>    ‘T.sequenceA’ (imported from Data.Traversable),
15:55:03 <jle`> > T.sequenceA [reverse, take 3, drop 3, map toUpper] "hello world"
15:55:05 <lambdabot>  ["dlrow olleh","hel","lo world","HELLO WORLD"]
15:55:10 <Cale> So, in this monad, "running" a function means applying it to the argument to which the overall function has been applied
15:55:16 <jle`> see, it forks "hello world" to reverse, take 3, drop 3, and map toUpper
15:55:28 <jle`> runs them in parallel, and combines the result in a list
15:55:33 <JagaJaga_> I have data Foo = A | B. Is there a way to filter all A from [Foo]?
15:55:51 <Cale> [A | A <- xs]
15:56:01 <jle`> JagaJaga_: [ x | x@A <- xs ]
15:56:04 <jle`> oh
15:56:06 <jle`> cale's is much better lo.
15:56:09 <jle`> lol.
15:56:09 <Peaker> funfunctor: I see now what's going on
15:56:14 <Peaker> funfunctor: your pairs are in reverse order
15:56:23 <Peaker> funfunctor: and you have a small difference in the LSB/how things are rounded
15:56:26 <JagaJaga_> And if data Foo = A Int | B String?
15:56:34 <arkeet> [ x | x@A{} <- xs ]
15:56:38 <SrPx> > data Box a = Box Int deriving Functor; main = print $ fmap (* 7) (Box 1) 
15:56:39 <lambdabot>  <hint>:1:1: parse error on input ‘data’
15:56:41 <SrPx> why?
15:56:44 <SrPx> woops
15:56:44 <arkeet> or (A _) instead of A{}
15:56:46 <funfunctor> Peaker: do you mean the (x,y) pair?
15:56:48 <SrPx> well, you get it :(
15:56:50 <JagaJaga_> arkeet: Thank you!
15:56:50 <Peaker> funfunctor: yes
15:56:53 <JagaJaga_> So awesome
15:56:59 <Cale> JagaJaga_: and if you just want the Ints, you can write [x | A x <- xs]
15:57:02 <jle`> mhm this is one of the best uses for list comprehensions i think
15:57:19 <HeladoDeBrownie> SrPx, that function gets discarded, because your constructor doesn't rely on the type parameter at all.
15:57:27 <HeladoDeBrownie> s/that function/(* 7)
15:57:59 <HeladoDeBrownie> SrPx, fmap maps over the last type parameter. since it doesn't get used, fmap has no work to do
15:58:15 <Cale> lexi-lambda: Sorry, I missed your question there
15:58:20 <funfunctor> Peaker: ah thanks! yes I see it now too.. endian confusing shit
15:58:33 <HeladoDeBrownie> SrPx, perhaps you wanted: data Box a = Box a
15:58:44 <Cale> lexi-lambda: But I guess you asked it at around the same time I was kind of answering it
15:59:01 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello" -- if you stare at this, it will become clear what the function monad does
15:59:02 <lambdabot>  ("hello","olleh","HELLO")
15:59:09 <SrPx> HeladoDeBrownie: yes
15:59:18 <funfunctor> Peaker: thats because I am generating the sequence in reverse right because appending to the front of a list is O(1)
15:59:27 <Cale> So, specifically, we have  return v x = v
15:59:28 <lexi-lambda> Cale: I will stare at it :p
15:59:50 <lexi-lambda> actually, yes
15:59:53 <Cale> and  (f >>= g) x = let v = f x in (g v) x
15:59:54 <lexi-lambda> that seems very straightforward
15:59:55 <funfunctor> Peaker: hopefully I am doing that right in regards to O-time?
16:00:06 <Cale> = g (f x) x
16:01:25 <Cale> lexi-lambda: Yeah, so once you understand that, well, liftA2 is the same as liftM2, which means  liftM2 f x y = do { u <- x; v <- y; return (f u v) }
16:01:29 <Peaker> funfunctor: no need to do that no
16:02:05 <Peaker> funfunctor: you can just do: genstream = map z [0..]
16:02:19 <Cale> So, in the function case, where x and y are then functions, and f is a function of their results, we apply x and y to the parameter (because that's what it means to "run" them), and then return f applied to the results
16:02:23 <Peaker> funfunctor: and then   take nSamples genstream  before serializing it
16:02:33 <Cale> lexi-lambda: clear?
16:03:05 <lexi-lambda> Cale: I think so
16:03:14 <lexi-lambda> I'll have to play with it a little bit
16:03:24 <Cale> > liftM2 (++) id reverse "hello"
16:03:26 <lambdabot>  "helloolleh"
16:03:41 <Cale> liftM2 f g h x = f (g x) (h x)
16:03:42 <lpaste> Peaker annotated “No title” with “No title (annotation)” at http://lpaste.net/124444#a124447
16:03:55 <Cale> and that's the same as the liftA2 you were looking at as well
16:04:09 <Peaker> funfunctor: the reversing of the tuple is either you doing z backwards, or the other program. it's not related to the reversal
16:04:10 <arkeet> liftM2 :: (a -> b -> c) -> (r -> a) -> (r -> b) -> (r -> c)
16:05:59 <funfunctor> Peaker: Ah your right I am, cos is x-component, good spot
16:08:07 <funfunctor> Peaker: ok so I think the difference now is just down to how many decimal places the calculation is happening at
16:10:52 <funfunctor> Peaker: *wonderful* I can broadcast that signal though the radio hw, recover it and plot it using Octave successfully
16:11:27 <Peaker> funfunctor: \o/
16:12:13 <funfunctor> Peaker: its pretty cool, generating signals form mathematical functions in Haskell, controlling a radio from haskell and pushing and pulling that data though said radio all from ghci
16:12:58 <Peaker> Haskell killed the radio star
16:15:04 <funfunctor> something exciting about seeing pure maths connect to real world things
16:16:11 <JagaJaga_> Hmmmm! As I said I have data Foo a = A a | B a. Did [(a, b) | A a <- list, B b <- list] and I get all (a,b) pair I can get. But how to unite 1st a with 1st b? Like zip?
16:16:36 <funfunctor> Peaker: do you have Octave installed? I could show you something cool
16:16:45 <Peaker> jaffachief: take 1 from that list comp?
16:16:50 <Peaker> JagaJaga_: ^^
16:16:53 <Cale> JagaJaga_: perhaps zip [a | A a <- xs] [b | B b <- xs]
16:17:07 <Peaker> oh, you want the rest too
16:17:11 <JagaJaga_> Cale: I'm so stupid :D Thank you!
16:17:16 <arkeet> > [ (a,b) | A a <- xs | B b <- xs ]
16:17:17 <lambdabot>  Not in scope: ‘xs’
16:17:18 <lambdabot>  Perhaps you meant one of these:
16:17:18 <lambdabot>    ‘x’ (imported from Debug.SimpleReflect),
16:17:21 <arkeet> I think this requires an extension.
16:17:25 <arkeet> I don't know why I put >
16:17:32 <Cale> Yeah, parallel list comprehensions
16:17:34 <Peaker> funfunctor: no, thanks, a bit busy :)
16:17:54 <funfunctor> :)
16:19:22 <JagaJaga_> Cale: hm, isn't there a way to genereate this lists in o(n), because here I'm doing it twice 
16:19:37 <Cale> That is o(n)
16:20:21 <JagaJaga_> Cale: why? We are generating 1st list and after that second one..
16:20:27 <JagaJaga_> LAZINESS
16:20:32 <Cale> o(n) and o(2n) are the same set of functions
16:20:51 <JagaJaga_> Cale: >_> I have to sleep >_>
16:21:53 <shachaf> It looks like O(n), not o(n). :-)
16:22:22 <Cale> Yeah, also it's more useful to consider O(n) rather than o(n)
16:22:26 <Cale> usually
16:22:55 <Cale> Oh, yeah, it's not o(n)
16:23:37 <Cale> I thought o(n) meant something slightly different
16:23:44 <shachaf> It's a bizarre family of notation, o/O/Θ/etc.
16:24:02 <Cale> yeah, not particularly well designed, and it gets abused which makes it even worse
16:24:08 <shachaf> I imagine there could be something more regular to replace it.
16:26:48 <arkeet> shachaf: perhaps, but first you need to tell me what you mean by regular.
16:27:39 <hpc> expressable by finite state automata
16:27:40 * hpc ducks
16:35:39 <cfoch> hello
16:35:58 <cfoch> how can I know what version of Cabal was used to generate the setup-config file ?
16:38:34 <int-e> cfoch: look at the first line of the file?
16:40:01 <int-e> oh, fun. some of the setup-config files I have are text files, some are binary.
16:40:54 <cfoch> ah yes
16:41:08 <cfoch> it is a binary, though
16:42:49 <lightandlight> I want to construct a parser using parsec given a set of tokens
16:43:04 <lightandlight> DOes anyone have any ideas?
16:43:39 <lightandlight> I'm thinking parsec might not be the right tool and I should use a pre-built parser generator library instead
16:45:57 <mpickering> parsec can do that just fine, what are you having trouble with?
16:47:08 <lightandlight> My idea is to tokenize a string, then based on those tokens parse another string
16:47:16 <Cale> http://hackage.haskell.org/package/parsec-3.1.8/docs/Text-Parsec-Prim.html -- see token/tokenPrim here
16:47:34 <cfoch> the setup-config "structure" has changed between different Cabal versions right?
16:47:49 <lightandlight> I've already created a tokenizer, but I don't know how to construct a new parser given a set of tokens
16:47:59 <Cale> lightandlight: see my link :)
16:48:14 <Cale> http://hackage.haskell.org/package/parsec-3.1.8/docs/Text-Parsec-Prim.html#v:token -- more specifically this
16:49:32 <ttt_fff> why is the behavior in postgressql-simple, on error, to be like "THROW ALL THE EXCEPTIONS" instead of just return a Either ?
16:49:33 <int-e> cfoch: So the binary format starts with a  word 5, followed by "Cabal", followed by a word n describing a list length (probably 4), followed by n words that make up the version... http://sprunge.us/VIPP ... I don't know whether there's a built-in way in cabal-install or Cabal.
16:49:49 <ttt_fff> for example, if I do something like query_ conn "create table (AASDF)" ... I get an exception instead of an Either A B
16:51:23 <Cale> ttt_fff: Probably because a lot of DB applications arrange to only do stuff which is almost guaranteed to succeed, so pattern matching on an Either every time would be seen as inconvenient.
16:51:42 <ttt_fff> Cale: I see
16:51:51 <ttt_fff> Cale: that makes sense, dbs, "almost guaranteed to succeed"
16:52:31 <glguy> ttt_fff: For table creates I believe you want execute or execute_, not query_
16:52:51 <randir> ttt_fff: also, you can wrap it in a try block from Control.Exception to make it return an either
16:53:23 <ttt_fff> glguy: Execute an INSERT, UPDATE, or other SQL query that is not expected to return results.  Returns the number of rows affected.  Throws FormatError if the query could not be formatted correctly, or a SqlError exception if the backend returns an error.
16:53:27 <ttt_fff> glguy: docs agrees with you
16:53:35 <randir> but you should really only be executing statements that are basically guaranteed to succeed, with pre-formed queries. 
16:54:14 <randir> after all, you don't want to be creating strings or having input queries anyhow, because of the security risk.
16:55:04 <ttt_fff> randir: how do I say something like "drop this table if it exists; no op otherwise" ?
16:55:09 <ttt_fff> randir: is there a way to phrase taht in SQL ?
16:55:43 <ttt_fff> oh, DROP TABLE IF EXISTS [tablename] ; // postgresql
16:56:34 <cfoch> int-e: the thing is I am reading this file with getPersistBuildConfig. It works when I run this command by hand from GHCI. *BUT* when I call a program (diagrams-haddock) that calls to this function, IDK why it does cannot read the file. I don't know if the version of getPersistBuildConfig it is using is an "old function" trying to read old-"setup-config" files. How can I know what version of this function (the library) it is using when it calls this function?
16:57:08 <randir> ttt_fff: :)
17:03:03 <SleepyPikachu> I was surprised I couldn't find a parsec inbuilt for parsing decimal numbers - am I looking wrong?
17:05:16 <indiagreen> SleepyPikachu: I think there's no decimal parser in parsec, but a) it's definitely in some library on Hackage (forgot, which), and b) in many cases people only need naturals, and so “read <$> many1 digit” is enough for them
17:06:55 <loki__> EvanR: I read a lot of hoogle/writeups and changed the code to: http://lpaste.net/124452 As far as I understand the IO Monad is bond to the function L.take and then the IO Monad is extracted into content. But now the error states that 'L.putStrLn content' wants an IO String? Can you show me a working example of my snippet? Maybe I will get it then.
17:08:33 <loki__> EvanR: Every variation I try with fmap (wich sounds more sane now to me than using bind) resulted in tons of errors.
17:15:36 <SleepyPikachu> indiagreen: Thanks, I guess I'll just parse by hand
17:16:41 * hackagebot haskell-neo4j-client 0.3.0.12 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.3.0.12 (asilvestre)
17:21:32 <SleepyPikachu> indiagreen: Is the normal strategy to use haskell's inbuilt read?
17:21:41 * hackagebot tidal 0.4.29.1 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.29.1 (AlexMcLean)
17:30:35 <loki__> Maybe someone else can have a look on the code? 
17:30:44 <HeladoDeBrownie> loki__, i'm guessing you wanted fmap (L.take 500) (simpleHttp url)
17:31:19 <HeladoDeBrownie> either that or use L.take on content once that's bound
17:31:33 <HeladoDeBrownie> loki__, including an error message might also help
17:32:06 <EvanR> loki__: did you ever figure out why your types were wrong?
17:32:12 <ezyang> Is there a way to get GHC to print out a "explicit whitespace layout-ified" version of an input hs file? 
17:32:13 <loki__> Ouch that hurts. But thank you very much
17:36:35 <loki__> EvanR: yes i have read up all about functors, aplicatives and Monads. The fmap solution is the only one that makes sense. But without the brackets you get the weirdest error messages. I still do net get how to see (in hoogle) if a function returns a Monad or a functor or a plain variable?
17:37:03 <EvanR> loki__: i was just talking about the types for =<<
17:37:13 <EvanR> :t (=<<)
17:37:14 <lambdabot> Monad m => (a -> m b) -> m a -> m b
17:37:46 <EvanR> your function wasnt of the form (a -> m b), not even taking considering monads yet
17:37:54 <EvanR> s/taking//
17:41:21 <loki__> HelandoDeBrownie: I thought I'd loose the laziness when writing 'content <- simpleHttp url' in the do monad?
17:41:48 <EvanR> loki__: as far as when something is a Monad or Functor, you have to look at its list of instances. But a clue is that Monad and Functor types have to have kind * -> *, that is they have to be something like f a
17:42:12 <EvanR> Maybe, [], IO, etc
17:42:30 <HeladoDeBrownie> loki__, using <- syntax does not need to evaluate something. only when it's needed by something that gets forced will it be evaluated
17:42:45 <HeladoDeBrownie> (usually)
17:43:01 <HeladoDeBrownie> loki__, are you familiar with how do expressions desugar?
17:43:44 <HeladoDeBrownie> essentially, do { x <- a ; f x } is the same as a >>= \x -> f x
17:44:02 <paxcoder> o.O
17:44:18 <lifter> or a >>= f
17:45:00 <bramgg> Anyone want to try out a Haskell learning/practicing tool I'm working on to learn Haskell myself? (hope this is appropriate here)
17:45:41 <paxcoder> bramgg, does it have monads?
17:46:18 <bramgg> paxcoder: erm, ya? :/
17:46:33 <paxcoder> i am open for links
17:47:00 <bramgg> paxcoder: It's like CodingBat, but with wiki.haskell.org's H-99 problems http://99h.bram.gg/ (temporary domain)
17:47:08 <bramgg> let me know what you think! :)
17:47:43 <paxcoder> HeladoDeBrownie, lifter but it doesn't do that
17:47:49 <bramgg> brutal honesty is best btw
17:47:57 <HeladoDeBrownie> paxcoder, what?
17:49:50 <HeladoDeBrownie> bramgg, seems neat, although i don't know if i like it encouraging writing of partial functions.
17:50:21 <HeladoDeBrownie> ... oh, did you just use an existing problem set for this?
17:50:24 <HeladoDeBrownie> hrm
17:50:34 <bramgg> Sorry dc'd, didn't get anything said for the couple minutes
17:50:44 <bramgg> HeladoDeBrownie: yeah https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems
17:50:46 <EvanR> i like it
17:51:00 <paxcoder> bramgg, i'll give you a full report later.
17:51:04 <loki__> HeladoDeBrownie: I took some lectures on haskell but am obviously very rusted. Back to the books. Thanks for the good and quick help!
17:51:07 <loki__> bye
17:51:11 <bramgg> cheers, thanks all
17:51:18 <EvanR> bramgg: the first question asking to write a partial function isnt great, but this is cool
17:52:17 <HeladoDeBrownie> first, second, and third :P
17:52:32 <paxcoder> HeladoDeBrownie, lifter. Sorry, misread
17:54:20 <HeladoDeBrownie> bramgg, this is a neat tool, makes it more convenient to tackle this problem set. if the problem set itself has problems, well, maybe fixing that is another issue, since you just took an existing one
17:54:27 <EvanR> is palinDrome error Not in scope: ‘myReverse’ ;)
17:54:41 <bramgg> EvanR: the idea was to make it like an interactive 99-H (link above), so I've been getting the problems from there. I also don't trust myself to write the problems as I'm a noob to both functional programming and Haskell. But if anyone's interested in working on the problems, code's here https://github.com/bramgg/99haskell
17:55:05 <lifter> bramgg: consider posting to /r/haskell
17:55:12 <lifter> is good
17:55:13 <bramgg> lifter: will do once it's done, thanks
17:55:26 <EvanR> yeah problems
17:55:29 <EvanR> problem sets
17:55:33 <EvanR> need more
17:55:34 <bramgg> This is a temporary domain BTW, and I've literally just turned it on within SSH, so don't share it anywhere
17:55:58 <EvanR> this is irc
17:56:01 <HeladoDeBrownie> bramgg, yeah, i was just thinking, evals like this are kind of hard to secure
17:56:13 <EvanR> you showed 1500 people already
17:56:19 <HeladoDeBrownie> bramgg, if nothing else there's the brute force solution of running it in a vm
17:56:29 <lexi-lambda> Alright, so here's what's confusing me about functors and applicative functors: I have no idea what the different instances of them have to do with each other. How would I know to use fmap with IO if I didn't happen to know what its behavior is already?
17:56:56 <lexi-lambda> I feel like I'm failing to see any consistent "bigger picture" between all the Functor instances in general.
17:56:57 <EvanR> lexi-lambda: functor behavior is very easy to predict
17:57:01 <lexi-lambda> They seem kinda disparate to me.
17:57:06 <HeladoDeBrownie> lexi-lambda, often, you do have to know how a given instance works to use it.
17:57:25 <bramgg> HeladoDeBrownie: code's run in Docker, of course there's much to be done security wise
17:57:39 <lexi-lambda> HeladoDeBrownie: If that's true, then what's the point of unifying all those behaviors in the same typeclass?
17:57:51 <lifter> lexi-lambda: functor's fmap is like mapping, or transforming from one type to another
17:57:53 <HeladoDeBrownie> lexi-lambda, so you don't have to reimplement all the operations for each one
17:58:12 <EvanR> lexi-lambda: after looking at a few examples of Functor, then you can go look at the laws for Functor and get a more formal reason it works
17:58:30 <lexi-lambda> Okay, that sort of makes sense.
17:58:30 <EvanR> but not all type classes have these laws
17:58:55 <HeladoDeBrownie> lexi-lambda, they behave "alike enough" (including following the laws, almost always) that we can generalize over them. that's essentially the idea behind many typeclasses
17:59:12 <HeladoDeBrownie> (laws are not enforceable by the compiler, that's why they're laws and not in the types)
17:59:22 <EvanR> you can see why youd want a type class for addition, + sign is used to add several different types
17:59:23 <lexi-lambda> Right, I understand that.
17:59:36 <EvanR> you dont want to have to remember the + symbol for each type
17:59:42 <lifter> lexi-lambda: if functor wasn't already defined for you, you'd probably find yourself wanting to define something like it soon enough
17:59:54 <HeladoDeBrownie> i think the essential reason behind the introduction of typeclasses was ad hoc polymorphism, but without the ad hoc :P
18:00:16 <lexi-lambda> Are the only functor laws that `fmap id` is the identity and that `fmap (p . q)` is `(fmap p) . (fmap q)`?
18:00:20 <EvanR> never really got why that was called ad hoc, seems a little disparaging from the get go ;)
18:00:40 <shachaf> Yes. Well, the type is also a law of sorts.
18:00:59 <lexi-lambda> HeladoDeBrownie: I totally get ad-hoc polymorphism, I just usually thought of it as a way to unify different implementations under a common interface. :)
18:01:12 <HeladoDeBrownie> lexi-lambda, in a way, that's what this is
18:01:30 <Maxdamantus> It also kind of lets you avoid rank-2 types.
18:01:38 <lexi-lambda> Yeah, I sort of see that, I just don't see how related the different instances are just yet.
18:02:04 <Maxdamantus> in some cases.
18:02:10 <lifter> lexi-lambda: for one thing, all functors are types of kind * -> *
18:02:18 <HeladoDeBrownie> they're related insofar as they have implementations of all the relevant operations and they follow the laws; this lets you write general operations over them, which are often extremely reuseable
18:02:28 <lifter> so functor is a common way to work w/ such kinded types
18:02:56 <lexi-lambda> I think Functor makes plenty of sense, tbh, but I'm having a little more trouble understanding applicative functors.
18:03:18 <shachaf> You can think of it this way: Functor gives you lift1 :: (a -> b) -> F a -> F b
18:03:30 <shachaf> Applicative adds lift0 :: a -> F a and lift2 :: (a -> b -> c) -> F a -> F b -> F c
18:04:29 <lifter> lexi-lambda: do u understand applicative style
18:05:11 <lexi-lambda> Not really, no.
18:05:40 <zq> ls
18:06:01 <HeladoDeBrownie> zq, secret-documents launch-missiles.sh
18:06:14 <lifter> lexi-lambda: this might help you http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
18:06:15 <EvanR> > fmap (+1) [1,2,3]
18:06:16 <lambdabot>  [2,3,4]
18:06:26 <shachaf> That article is pretty misleading. :-(
18:06:35 <EvanR> > (+) <$> [1,2,3] <*> [6,5,4]
18:06:37 <lambdabot>  [7,6,5,8,7,6,9,8,7]
18:06:52 <zq> while [ 1 ];do sh launch-missiles.sh; done
18:06:57 <arkeet> > liftA2 (+) [1,2,3] [6,5,4]
18:06:59 <lambdabot>  [7,6,5,8,7,6,9,8,7]
18:07:00 <EvanR> lexi-lambda: try examples
18:07:09 <lifter> shachaf: Seems like every time I point someone to a resource that helped me someone here criticizes it
18:07:34 <lifter> well, your mileage may vary
18:07:35 <pacak> > (++) <$> [":", ";"] <*> ["-)", "-|", "-("]
18:07:36 <lambdabot>  [":-)",":-|",":-(",";-)",";-|",";-("]
18:08:16 <ProofTechnique> I'm trying to figure out what ;-| would mean.
18:08:20 <HeladoDeBrownie> zq, sh: 0: Can't open launch-missiles.sh (ad infinitum) (what, did you think someone was just gonna leave that in plain view? :P)
18:08:22 <arkeet> ;-|
18:08:27 <lifter> lexi-lambda: do you know what is meant by "kind * -> *"
18:08:42 <EvanR> ;-|
18:08:42 <lexi-lambda> lifter: Nope, I don't really know what kinds are. :p
18:08:53 <lifter> well it just means a type that has a type parameter
18:09:04 <zq> HeladoDeBrownie: i concede (:
18:09:04 <lifter> for example "Maybe a" where a is a type parameter
18:09:09 <arkeet> 1 minute kind tutorial.
18:09:17 <arkeet> concrete types (anything that has a value) have kind *
18:09:29 <arkeet> like Int, String, [(Maybe Int,Char)], etc
18:09:39 <lexi-lambda> Oh, I see, that's reasonable.
18:09:41 <ProofTechnique> @kind Int
18:09:41 <lambdabot> *
18:09:47 <arkeet> some types take other types as arguments
18:09:49 <arkeet> e.g. Maybe
18:09:52 <lexi-lambda> Yeah, I get it.
18:09:52 <ProofTechnique> @kind Maybe
18:09:53 <lambdabot> * -> *
18:10:02 <arkeet> it takes a type of kind *, and spits out a type of kind *
18:10:03 <ProofTechnique> @kind Either
18:10:04 <lambdabot> * -> * -> *
18:10:07 <arkeet> e.g. Int becomes Maybe Int
18:10:11 <arkeet> so Maybe has kind * -> *
18:10:12 <arkeet> etc
18:10:13 <pacak> @kind (,,,,,,,,,,)
18:10:13 <lambdabot> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> *
18:10:20 <lifter> lexi-lambda: So any type that is a functor MUST be kind * -> *
18:10:23 <EvanR> Maybe is also called a type constructor
18:11:04 <lifter> lexi-lambda: Functor and Applicative are classes that help us work with types of kind * -> * that obey certain laws
18:11:34 <lifter> > let test = 10 in test
18:11:36 <lambdabot>  10
18:11:38 <lifter> ok
18:11:54 <EvanR> test failed
18:11:56 <pacak> >let 2 + 2 = 5 in 2 + 2
18:12:01 <lifter> so this is an example of the so-called "applicative style":
18:12:05 <pacak> > let 2 + 2 = 5 in 2 + 2
18:12:07 <lambdabot>  5
18:12:29 <lifter> > (*) <$> Just 10 <$> Just 5
18:12:30 <lambdabot>  Couldn't match expected type ‘a0 -> b’
18:12:30 <lambdabot>              with actual type ‘Data.Maybe.Maybe (a1 -> a1)’
18:12:38 <arkeet> > (*) <$> Just 10 <*> Just 5
18:12:40 <EvanR> wurble
18:12:40 <lambdabot>  Just 50
18:12:54 <lifter> ?
18:12:58 <lifter> wat did I do wrong
18:13:02 <arkeet> > (*) <$> [1,2,3] <*> [11,12,13]
18:13:04 <lambdabot>  [11,12,13,22,24,26,33,36,39]
18:13:06 <ProofTechnique> You used fmap twice
18:13:11 <lifter> oh typo
18:13:12 <lifter> haha
18:13:16 <lexi-lambda> > liftA2 (*) (Just 10) (Just 5)
18:13:17 <lambdabot>  Just 50
18:13:27 <arkeet> I personally prefer liftA2.
18:13:31 <Hijiri> are type level number literals and type level (+) called Nat Constructors
18:13:36 <arkeet> and think it should be part of the Applicative class really.
18:13:38 <EvanR> <*> is the Applicative function application ;)
18:13:46 <lexi-lambda> Why use liftA2 vs <$> and <*> ?
18:13:55 <EvanR> like =<< is for Monad
18:14:03 <arkeet> personal preference I guess.
18:14:03 <Hijiri> "Banana" as a Symbol Constructor
18:14:04 <lifter> lexi-lambda: you can use either one
18:14:06 * Maxdamantus doesn't like the fuzzy use of the term "type" :(
18:14:13 <HeladoDeBrownie> more succinct, although less general; (<$>) and (<*>) are useable at larger numbers of arguments than liftA* are
18:14:23 <arkeet> Maxdamantus: wait until you start using dependent types!
18:14:30 <HeladoDeBrownie> (because there's only so many liftA*; even though you can define more)
18:14:39 <lexi-lambda> Okay, so now I understand how these are used, though I only sort of understand how they actually work.
18:14:43 <arkeet> yeah, I rarely use liftA3 and higher.
18:14:51 <Maxdamantus> At least in languages with dependent types the things you're talking about are likely to be just functions.
18:15:03 <EvanR> Hijiri: ive seen 4, Nothing, and 'c' called "value constructors"
18:15:14 <Hijiri> EvanR: I mean type level 4
18:15:26 <shachaf> Speaking of liftA3 and higher, what do you do about the fact that f <$> x <*> y <*> z is left-associated rather than right-associated?
18:15:41 <Maxdamantus> in Idris, Monad is a function of type (Type -> Type) -> Type
18:15:43 <EvanR> in a dependently typed language i would hope 4 is just a value at any level
18:15:49 <shachaf> Of course it's associative, but it can have a performance difference, and I don't know a good way to write it so it's right-associated.
18:16:05 <Hijiri> EvanR: Would you call Maybe a value constructor in a dependently typed language?
18:16:07 <lifter> woop
18:16:18 <EvanR> Hijiri: that would be silly since it returns a type
18:16:37 <EvanR> which is a value but not a non-type
18:16:42 <EvanR> so nevermind
18:16:52 <arkeet> > (\ a b c -> a+b+c) <$> ("a",1) <*> ("b",2) <*> ("c",3)
18:16:53 <lambdabot>  ("abc",6)
18:17:14 <EvanR> my timer for how long it would be until someone got mad about "type constructor" just went off
18:17:37 <arkeet> why not just call it a constructor?
18:17:42 <Hijiri> I just want to be able to name different kinds of constructor and be silly
18:17:55 <shachaf> > (\a b c -> a+b+c) <$> (N 'a',1) <*> (N 'b',2) <*> (N 'c',3)
18:17:55 <Maxdamantus> because Just is also a constructor.
18:17:56 <lambdabot>  ((N 'a' ◇ N 'b') ◇ N 'c',6)
18:18:04 <arkeet> where's N from?
18:18:11 <EvanR> i think it helps to think of values and types as separate things
18:18:14 <shachaf> https://hackage.haskell.org/package/nonfree
18:18:18 <EvanR> even if they are first class
18:18:19 <shachaf> But I just defined it in lambdabot.
18:18:30 <arkeet> oh.
18:18:56 <Maxdamantus> I think it'd be best to qualify things with what sort they are.
18:19:11 <Maxdamantus> so a "type constructor" is a type-level function
18:19:24 <Hijiri> doesn't have to be a function
18:19:27 <ProofTechnique> Wait, how does that bit with the pairs work?
18:19:35 <EvanR> non-functions are called constructors too
18:19:46 <arkeet> ProofTechnique: instance Monoid m => Applicative ((,) m)
18:19:49 <shachaf> () is a type constructor, just like () is a data constructor.
18:19:49 <Maxdamantus> So Int is a constructor?
18:19:56 <Hijiri> yes
18:20:01 <Hijiri> in the same way Nothing is a constructor
18:20:03 <shachaf> But terminology isn't too important.
18:20:04 <Maxdamantus> What about Maybe Int?
18:20:09 <ProofTechnique> arkeet: I thought that might be it, but I've never actually looked at the instance. Guess I'll have to have a look
18:20:11 <shachaf> Maybe Int is not a constructor.
18:20:18 <arkeet> ProofTechnique: exercise: implement it.
18:20:18 <ab9rf> Maybe and Int are constructors.  Maybe Int is an expression.
18:20:21 <Maxdamantus> What about StateT Int?
18:20:28 <EvanR> nice
18:20:29 <shachaf> Also not a constructor in the usual sense.
18:20:33 <arkeet> that's a type error.
18:20:36 <arkeet> oh wait.
18:20:37 <lifter> +1
18:20:48 <arkeet> I always get the argument order mixed up for those.
18:20:48 <shachaf> Anyway, it's easy to right-associate with monoids, because you can just write (a <> (b <> c)).
18:21:05 <shachaf> But it's a problem with Applicative, which is annoying.
18:21:06 <Maxdamantus> This seems like another weirdly used term.
18:21:16 <Maxdamantus> like how `Maybe` is a "type"
18:21:32 <shachaf> An example of the problem is documented in https://hackage.haskell.org/package/nonfree-0.1.0.0/docs/src/Data-Monoid-Nonfree.html
18:21:33 <Hijiri> well, you don't call Just 5 a constructor
18:21:39 <dmwit> Maxdamantus: Perhaps it is you who is weird. ;-)
18:21:45 <arkeet> maybe we can just call it a type-level term.
18:22:07 <EvanR> Maxdamantus: thats why i brought up the type constructor thing, because Maybe being a type of its own is weird
18:22:18 <ab9rf> what's weird about it?
18:22:24 <Maxdamantus> It breaks intuition.
18:22:30 <ab9rf> it does?
18:22:32 <EvanR> its a function between types
18:22:40 <Maxdamantus> Someone who hasn't seen these terms before can't call `Maybe` a "type".
18:22:58 <Maxdamantus> Because it's not something a value/expression could conceptually be typed as.
18:23:04 <Hijiri> what if I bribed them to do it
18:23:07 <Maxdamantus> foo :: Maybe; foo = foo
18:23:13 <dmwit> Somebody who doesn't know the vocabulary certainly can't use the vocabulary correctly with very high probability.
18:23:15 <Maxdamantus> > let foo :: Maybe; foo = foo in foo
18:23:17 <lambdabot>  Expecting one more argument to ‘Data.Maybe.Maybe’
18:23:17 <lambdabot>  Expected a type, but ‘Data.Maybe.Maybe’ has kind ‘* -> *’
18:23:21 <shachaf> ski calls things of kind * "inhabitable types"
18:23:23 <arkeet> Maxdamantus: I would argue that "foo :: Maybe" is a kind error.
18:23:31 <HeladoDeBrownie> shachaf, would having (Applicative f) => f a -> f b -> f (a, b) help the associativity problem?
18:23:32 <Maxdamantus> GHC actually uses the terms correctly.
18:23:40 <Maxdamantus> GHC says `Maybe` is not a "type"
18:23:47 <ab9rf> there's a name for "StateT Int" but i can't remember what it is
18:24:02 <ProofTechnique> arkeet: I'm picturing (mempty, x) and (x <> y, f z), based on those results
18:24:19 <arkeet> ProofTechnique: what are x, x, y, and z?
18:24:35 <arkeet> I think you have the right idea though.
18:24:42 <arkeet> also, f.
18:24:46 <shachaf> HeladoDeBrownie: I'm wondering about the best way to write these things in practice. <$>/<*> is very convenient notation but it has inconvenient associativity.
18:25:11 <HeladoDeBrownie> shachaf, Applicative syntax that gets compiled away to something efficient?
18:25:16 <ab9rf> shachaf: i've noticed that
18:25:24 <HeladoDeBrownie> though i feel like "throw more syntax at it" isn't a very scaleable solution
18:25:35 <Maxdamantus> arkeet: it is a kind error, because `Maybe` isn't a type, as GHC quite plainly states.
18:26:17 <shachaf> > let times = liftA2 (,); superLiftA3 f fx fy fz = fmap (\(x,(y,z)) -> f x y z) (times fx (times fy fz)) in superLiftA3 (\a b c -> a+b+c) (N 'a',1) (N 'b',2) (N 'c',3)
18:26:18 <HeladoDeBrownie> (although sometimes "throw more syntax" at it is better than co-opting existing syntax, like ScopedTypeVariables does)
18:26:19 <lambdabot>  (N 'a' ◇ (N 'b' ◇ N 'c'),6)
18:26:39 <EvanR> Maxdamantus: in some context, the * are "the types" and everything else isnt
18:26:55 <Maxdamantus> EvanR: how do you tell which context you're in?
18:27:00 <EvanR> but then other kinds are sometimes called types
18:27:26 <EvanR> Maxdamantus: im not sure, it seems like they are half compatible and people usually dont notice they are different contexts ;)
18:27:27 <dmwit> Maxdamantus: What are you proposing?
18:27:35 <dmwit> Perhaps let's call "Maybe" a "type expression".
18:28:04 <EvanR> Maybe is definitely a term
18:28:13 <EvanR> and a type constructor
18:28:15 <Maxdamantus> A type-level thing.
18:28:28 <dmwit> I'd be okay with "type-level term" as well. Though "type term" sounds a bit strange to my ear.
18:28:38 <Maxdamantus> > let foo :: Maybe Maybe; foo = foo in foo
18:28:40 <lambdabot>  Expecting one more argument to ‘Data.Maybe.Maybe’
18:28:40 <lambdabot>  The first argument of ‘Data.Maybe.Maybe’ should have kind ‘*’,
18:28:40 <lambdabot>    but ‘Data.Maybe.Maybe’ has kind ‘* -> *’
18:29:04 <HeladoDeBrownie> i much prefer "type" versus "concrete type", since it makes value :: type :: kind make sense.
18:29:12 <dmwit> That message cleverly avoids naming the syntactic class to which Maybe belongs. =)
18:29:20 <Maxdamantus> Indeed.
18:29:46 <jhickner> in haskell is there a way to capture the output of a shell command with pipes? System.Process doesn't seem to have any helpers for that
18:29:48 <EvanR> value :: type :: kind :: sort is kind of weird though
18:30:24 <EvanR> jhickner: are you sure
18:30:42 <Maxdamantus> Hm. Is kind a sort, or is a kind a sort?
18:30:59 <HeladoDeBrownie> a kind is of a sort.
18:31:23 <jhickner> there's readProcess and readProcessWithExitCode, but they both take only a command with args, not something like "ps aux | grep foo"
18:31:33 <ab9rf> jhickner: there's no OS-independent way to do that
18:31:36 <Maxdamantus> Okay, that should've been what I meant as my second thingf.
18:31:49 <dmwit> Maxdamantus: The Report says, in part, "If t1 is a type of kind k1 -> k2 and ...", so it seems to think "type" is a pretty good shorthand for "type expression".
18:32:10 <EvanR> jhickner: you can create a process using a shell command
18:32:14 <HeladoDeBrownie> jhickner, the pipe syntax is from a shell; you can probably execute the shell with that string as an argument.
18:32:27 <EvanR> jhickner: shell :: String -> CreateProcess
18:32:53 <dmwit> jhickner: http://stackoverflow.com/q/28869164/791604
18:33:29 <shachaf> > let superLiftA3 f fx fy fz = liftA2 (\x k -> k (f x)) fx (liftA2 (\y z -> \k -> k y z) fy fz) in superLiftA3 (\a b c -> a+b+c) (N 'a',1) (N 'b',2) (N 'c',3)
18:33:31 <lambdabot>  (N 'a' ◇ (N 'b' ◇ N 'c'),6)
18:33:43 <jhickner> something like: createProcess (shell "ps aux | grep foo")
18:33:45 <shachaf> This is looking a lot like glguy's old approach.
18:34:02 <HeladoDeBrownie> shachaf, what have you wrought
18:34:15 <jhickner> and then read stdout?
18:34:29 <EvanR> jhickner: you might have to tell it to create a pipe for stdout and read that
18:34:53 <jhickner> ok, great, thank you. I'll give that a shot
18:35:00 <ProofTechnique> arkeet: pure x = (mempty, x), so x is whatever you like. (x, f) <*> (y, z) = (x <> y, f z), where f is some function a -> b, z is a value of type a, x and y are some monoidal values.
18:35:02 <ProofTechnique> Am I there?
18:35:07 <dmwit> jhickner: Oh, I understand your question now. You can run an actual shell and pass it that command; or you can manage the pipe yourself (and run two processes).
18:35:30 <shachaf> Any ideas for making that nicer?
18:35:33 <shachaf> ProofTechnique: You are there.
18:35:48 <ProofTechnique> Yay!
18:36:18 <dmwit> jhickner: e.g. bash -c 'ps aux | grep foo'
18:36:23 <arkeet> shachaf: I have some idea for the associativity thing, but it involves continuations.
18:36:44 <EvanR> jhickner: not sure what the default strategy is for the stdio of the new process, might be "inherit" which is probably not what you want
18:36:46 <arkeet> or something along those lines.
18:36:52 <shachaf> arkeet: What I'm doing is pretty much continuations.
18:37:00 <arkeet> yeah.
18:37:15 <jhickner> ?
18:37:23 <EvanR> ?
18:37:35 <jhickner> oh then I could use readProcess?
18:37:40 <dmwit> jhickner: I guess you could use readProcess. Or you could use the strategy suggested in the linked SO post.
18:37:47 <EvanR> no because that doesnt take a shell command
18:38:02 <EvanR> oh, bash -c
18:38:41 <chrisdotcode> @src map
18:38:41 <lambdabot> map _ []     = []
18:38:41 <lambdabot> map f (x:xs) = f x : map f xs
18:38:52 <dmwit> jhickner: Anyway, pgrep is better than ps+grep.
18:38:55 <jhickner> testing bash -c with readProcess
18:38:58 <dmwit> jhickner: ;-)
18:39:39 <dmwit> jhickner: e.g. compare "ps aux | grep aux" and "pgrep aux"
18:40:15 <shachaf> > let superLiftA4 f fx fy fz fw = liftA2 (\x k -> k (f x)) fx . liftA2 (\y k k' -> k (k' y)) fy . liftA2 (\z w k -> k z w) fz $ fw in superLiftA4 (\a b c d -> a+b+c+d) (N 'a',1) (N 'b',2) (N 'c',3) (N 'd',4)
18:40:16 <lambdabot>  (N 'a' ◇ (N 'b' ◇ (N 'c' ◇ N 'd')),10)
18:40:44 <shachaf> See, easily generalized.
18:41:00 <arkeet> now make it work as a bunch of infix operators.
18:41:04 <arkeet> pair of.
18:41:19 <jhickner> readProcess works with bash -c. that's a little easier to work with than the method on the SO post
18:41:43 <shachaf> I do like that fx/fy/fz/fw appear right-to-left there.
18:42:05 <shachaf> Er, left-to-right.
18:42:07 <dmwit> jhickner: Seems like a good way to create a code injection vulnerability, though.
18:42:08 <shachaf> The direction you want.
18:42:42 <dmwit> jhickner: Managing the pipes yourself (...and therefore not calling out to bash at all...) avoids that mess.
18:42:55 <EvanR> jhickner: a function which just does what you want sounds like it would be useful to other people
18:43:15 <dmwit> Oh, there's also all those Haskell-as-a-shell libraries.
18:43:20 <dmwit> Dunno why they didn't occur to me before.
18:43:35 <EvanR> shellExec :: String -> IO String
18:43:37 <dmwit> ?hackage turtle is getting some hype recently
18:43:37 <lambdabot> http://hackage.haskell.org/package/turtle is getting some hype recently
18:45:03 <dmwit> jhickner: Why do you keep PMing me?
18:45:30 <jhickner> sorry dmwit, my mistake
18:52:14 <miner-49er> to what extent can haskell be used instead of bash or ksh?
18:53:24 <pacak> miner-49er: https://hackage.haskell.org/package/turtle 
18:53:27 <platz> there's also haskell-awk (a.k.a hawk)
18:53:55 <platz> or for the truly minimal put this in your .bashrc: function hmap { ghc -e "interact ($*)";  }
18:53:59 <kadoban> If I want to parse HTML for purposes of pretty-printing (or ugly-compressed-printing) it, what packages should I look at to do that?
18:56:28 <ProofTechnique> kadoban: I used HXT with some success a few years ago.
18:56:55 <ProofTechnique> Fancier folk might prefer HandsomeSoup, though
18:56:59 <ProofTechnique> ?hackage HXT
18:56:59 <lambdabot> http://hackage.haskell.org/package/HXT
18:57:04 <ProofTechnique> ?hackage HandsomeSoup
18:57:04 <lambdabot> http://hackage.haskell.org/package/HandsomeSoup
18:57:18 <ProofTechnique> Uh.
18:57:20 <ProofTechnique> ?hxt
18:57:20 <lambdabot> Maybe you meant: what thx let
18:57:25 <ProofTechnique> ?hackage hxt
18:57:25 <lambdabot> http://hackage.haskell.org/package/hxt
18:57:28 <ProofTechnique> I'm bad at stuff
18:57:37 <kadoban> Thanks, I'll look at those. hxt isn't just xml? I thought it was
18:58:26 <miner-49er> if I get latest ghc and then use hackage to install, is that as good as the haskell platform?
18:58:27 <ProofTechnique> There's an HTML parser in there
18:58:34 <kadoban> Ah, cool
18:58:38 <miner-49er> I am not sure I can get the haskell platform here on freebsd 10
18:58:40 <ProofTechnique> miner-49er: Some would say better
18:58:42 <HeladoDeBrownie> miner-49er, basically
18:59:41 <HeladoDeBrownie> miner-49er, does your os come with a cabal package in its repo? you can grab cabal from there then use it to upgrade
19:00:45 <miner-49er> yeah I think so
19:09:12 <EvanR> ah, exitSuccess doesnt work from a thread ;)
19:09:22 <EvanR> besides the main thread
19:12:45 <SrPx> Do you guys think it is risky to use Haskell in production for a startup? Certain parts of our front are going to be refactored and I've been thinking in react.js + flow... maybe pure javascript... or being a little extreme and going haskell + ghcjs or just elm... 
19:13:19 <SrPx> I'm sure the quality of the code and productivity will increase on the haskell route, but I'm afraid we're not going to be able to hire anyone to maintain it
19:13:20 <SrPx> :(
19:13:33 <EvanR> i have the same feelings about pure javascript
19:13:43 <pingu> SrPx: I don't think it's risky if you have a team who have experience
19:14:01 <EvanR> finding the right people is the biggest problem with anything
19:14:08 <pingu> If you are trialing a new technology you have no experience with then obviously it's risky. that's got nothing to do with the language of choice, though ;)
19:14:33 <pingu> I'd look at purescript/typescript also
19:15:21 <SrPx> just for curiosity, what is, today, the considered best way to use FP to create web apps? I love Elm but it lacks the entire haskell ecosystem... same for purescript :(
19:15:56 <SrPx> and ghcjs afaik doesn't have a solid/high level dom frp library yet
19:16:05 <pingu> I'm not sure. At our company we're building as much logic as possible into our APIs with servant
19:16:10 <pingu> and auto-generating clients from that.
19:16:13 <SrPx> let me see
19:16:22 <pingu> such that web apps are just UI stuff and plumbing auto-generated code
19:16:56 <pingu> This is violating the whole "don't break the web" thing, though.
19:17:02 <pingu> in that you *need* JS to function.
19:17:12 <tomktomk> @pl uncurry (uncurry TLS.tlsConfig listenOn) tlsCertAndKey
19:17:12 <lambdabot> uncurry (uncurry TLS.tlsConfig listenOn) tlsCertAndKey
19:17:44 <EvanR> when that was a thing, webapps werent
19:17:48 <tomktomk> @pointful uncurry (uncurry TLS.tlsConfig listenOn) tlsCertAndKey
19:17:49 <lambdabot> uncurry (uncurry TLS.tlsConfig listenOn) tlsCertAndKey
19:17:54 <ab9rf> haha
19:17:54 <tomktomk> hmm
19:18:08 <ab9rf> the web's been broken for years
19:18:27 <ab9rf> i shot the sheriff
19:19:23 <pingu> yeah, I personally think dropping the whole "web app" paradigm is a reasonable excuse to properly break the web
19:19:55 <pingu> Still yet to see how accessible we can make such things.
19:24:12 <SrPx> hmm
19:24:42 <SrPx> "don't break the web" thing? 
19:25:23 <EvanR> SrPx: i take it, make sure no matter what that your app can still function like a cgi script from 1994 that takes form submissions
19:25:52 <ProofTechnique> Also, make sure people can see your content from a screen reader or a JS-less browser
19:26:00 * SrPx whats
19:26:18 <SrPx> no guys, but really
19:26:31 <drewbert> How do I convert a do { val <- getVal; doSomething val } to a single statement in the do?
19:26:54 <HeladoDeBrownie> pingu, seems like just another drop in the bucket to me. several sites, even just for viewing static content, require javascript.
19:27:06 <EvanR> drewbert: do { getVal >>= doSomething }
19:27:20 <SrPx> I just finished reading about servant... I'm curious in what you are using
19:27:27 <ProofTechnique> Or just getVal >>= doSomething
19:27:35 <ProofTechnique> Oh, in the do
19:27:37 <ProofTechnique> Nevermind
19:27:46 <EvanR> IN THE DO
19:27:49 <arkeet> doSomething =<< getVal
19:27:59 <drewbert> EvanR: That did it.  These statements make me uncomfortable because they read left-to-right and the majority of haskell reads right-to-left
19:28:04 <HeladoDeBrownie> EvanR, no need to make a big todo over it
19:28:07 <ProofTechnique> EvanR: The IN THE DEW campaign did not go well
19:28:17 <EvanR> drewbert: indeed you can write it normally using =<<
19:28:20 <HeladoDeBrownie> drewbert, there's a function for that! doSomething =<< getVal
19:28:32 <pingu> SrPx: PM if you want more details?
19:28:34 <HeladoDeBrownie> oh arkeet already said it
19:28:53 <pingu> Not because it's secret but because it's a little off-topic perhaps.
19:28:55 <drewbert> EvanR: I am fully satisfied.  Thanks!
19:29:03 <EvanR> when your question is answered in iambic pentameter
19:29:14 <drewbert> Also thank you ProofTechnique and HeladoDeBrownie.
19:29:19 <HeladoDeBrownie> EvanR, who answered in iambic pentameter?
19:29:42 <EvanR> your mother's uncle
19:29:48 <HeladoDeBrownie> um. okay.
19:31:17 <delimax> EvanR: questions often posed with vigor surely?
19:31:33 <EvanR> uhg
19:31:38 <drewbert> Also arkeet I see now.
19:35:46 <HeladoDeBrownie> delimax, those weren't iambs :P
19:50:01 <lexi-lambda> oookay, I think functors vs applicatives just clicked ;)
19:50:29 <lexi-lambda> applicatives are just functors generalize to have wrapped inputs AND outputs :)
19:50:34 <lexi-lambda> *generalized
19:51:00 <HeladoDeBrownie> lexi-lambda, it's the other way around: every applicative is a functor, but not vice versa
19:51:15 <lexi-lambda> HeladoDeBrownie: I know, that's not really what I meant
19:51:19 <tnks> yeah, applicatives are specialized.
19:51:34 <HeladoDeBrownie> okay
19:53:29 <tnks> although. . . after bending my mind. . . I know what you're trying to say now.
19:53:52 <lexi-lambda> It's really just the fmap vs pure + <*> thing
19:53:53 <tnks> @type fmap
19:53:54 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:54:02 <tnks> @type ap
19:54:03 <lambdabot> Monad m => m (a -> b) -> m a -> m b
19:54:18 <johnw> :t fmap ($)
19:54:19 <lambdabot> Functor f => f (a -> b) -> f (a -> b)
19:54:26 <johnw> applicatives can distribute (->) over f
19:54:41 <johnw> (or f over (->), I always forget what the order is for the operation)
19:55:46 <jmcarthur> lexi-lambda: functor gives you map (it calls fmap). applicative gives you map2 (it calls liftA2). (applicative also gives you pure, but i think it is a bit less important)
19:55:50 <tnks> yeah, I guess the comparison is really <$> versus <*>
19:56:07 <lexi-lambda> that's sort of what I mean
19:56:10 <jmcarthur> :t fmap
19:56:11 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:56:13 <jmcarthur> :t liftA2
19:56:14 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
19:56:20 <lexi-lambda> my model is clearly not exactly watertight :p
19:56:20 <HeladoDeBrownie> an alternative way to think about Applicative is that, besides fmap and pure, it gives you (Applicative f) => f a -> f b -> f (a, b)
19:57:44 <tnks> lexi-lambda: I think one thing that's nice in Haskell is that you can follow the types.
19:57:52 <jmcarthur> fmap :: Functor f => (a -> b) -> (f a -> f b); unit :: Applicative f :: f (); product :: Applicative f => (f a, f b) -> f (a, b)
19:58:00 <tnks> if things don't completely "click"
19:58:15 <jmcarthur> or perhaps it would be easier to understand unit as  () -> f ()
20:07:26 <Zer000> guys whats the difference between quickcheck and quickcheck2?
20:08:20 <EvanR> -1
20:09:24 <Hijiri> -quickcheck
20:11:14 <Lutin`> Zer000: A lot
20:12:21 <Lutin`> Actually I think it was mostly just fixing the modules up
20:13:13 <noobie> how do i handle a closerequest within a yesod websockets handler?
20:13:17 <Lutin`> also it added shrink
20:13:49 <noobie> [Error#yesod-core] Exception from Warp: CloseRequest 1001 :
20:18:50 <halvorg> Any thoughts on a best GUI library for haskell?
20:18:57 <carter> halvorg: depends on target platform
20:19:06 <halvorg> the list at https://wiki.haskell.org/Applications_and_libraries/GUI_libraries is full of long dead projects
20:19:08 <carter> and use case
20:19:15 <carter> halvorg: whats your goal
20:19:23 <halvorg> make something simple that works on linux
20:19:38 <EvanR> theres three penny
20:19:39 <carter> halvorg: ok, threepenny gui
20:19:47 <carter> is the simplest and most portablest
20:19:54 <halvorg> great, thanks.
20:19:57 <carter> theres also qt and gtk stuff
20:20:06 <noobie> i have actually given up on haskell for ui (apologies). I am using haxe as a client to haskell web server..speaking of i need to handle the close request
20:21:49 * hackagebot ascii-progress 0.2.1.1 - A simple progress bar for the console.  http://hackage.haskell.org/package/ascii-progress-0.2.1.1 (yamadapc)
20:23:08 <lpaste> lightandlight pasted “Parser Generator Problem” at http://lpaste.net/124461
20:23:43 <lightandlight> Am I trying to approach this the wrong way? (see paste)
20:24:25 <lpaste> lightandlight revised “Parser Generator Problem”: “No title” at http://lpaste.net/124461
20:26:26 <lpaste> lightandlight revised “Parser Generator Problem”: “revision” at http://lpaste.net/124461
20:26:44 <Zer000> Thanks Lutin`, so I guess I'll stick to QC2
20:28:11 <Javran> why Double is an instance of Enum? I don't think it makes sense to say the successor of 1.2 is some other floating number...
20:28:20 <Javran> > succ (1.5 :: Double)
20:28:22 <lambdabot>  2.5
20:28:40 <EvanR> no one knows
20:28:46 <lexi-lambda> that does seem odd
20:29:23 <lightandlight> Paste has glitched
20:29:30 <EvanR> there does exist the least double greater than 1.5, but its weird and useless
20:30:36 <carter> Javran: hysterical regions
20:30:38 <carter> :)
20:30:52 <carter> per se, succ is just +1
20:32:09 <hodapp> carter: you get mad props for writing "per se" instead of "perse", "per say", or "persay".
20:32:09 <EvanR> and fromEnum is floor
20:32:21 <Hijiri> purse ay
20:32:26 <arkeet> shachaf: I figured it out.
20:32:37 <arkeet> >>> run $ i (\x y z -> x+y+z) <$.> j (N 1,1) <*.> j (N 2,2) <*.> j (N 3,3)
20:32:38 <carter> hodapp: .... hows that props worthy?
20:32:38 <arkeet> (N 1 <> (N 2 <> N 3),6)
20:35:20 <EvanR> fromEnum is truncate
20:35:26 <Jello_Raptor> huh
20:35:31 <lpaste> arkeet pasted “hi shachaf” at http://lpaste.net/124464
20:35:32 <Jello_Raptor> are normal functions monads? 
20:35:36 <EvanR> yes
20:35:57 <johnw> well, not exactly
20:36:09 <johnw> for any a, "(->) a" is an instance of Monad
20:36:11 <Jello_Raptor> with 'return' == 'id', and '>>=' == '.' 
20:36:21 <Axman6> no
20:36:32 <Axman6> well, return = id yes
20:36:35 <arkeet> no
20:36:36 <johnw> but a particular "a -> b" is not itself a monad, so functions per se are not monads
20:36:39 <Hijiri> return = const
20:36:43 <Axman6> oh right
20:36:44 <Chobbes> Jello_Raptor: doesn't follow monad laws.
20:36:45 <Axman6> >_<
20:36:48 <EvanR> more mad props
20:36:52 <Hijiri> those types aren't right
20:36:58 <Jello_Raptor> johnw: ahh
20:37:07 <Hijiri> . is the type of fmap
20:37:09 <Hijiri> I mean definition
20:37:16 <arkeet> (->) r is a Monad because you can make return :: a -> (r -> a) and (>>=) :: (r -> a) -> (a -> r -> b) -> (r -> b) that satisfy the monad laws.
20:37:32 <tnks> I'm reading Stephen's writeup slowly and got to his discussion of Monad Transformers. . . not sure how this works:  "Using " (http://www.stephendiehl.com/what/#newtype-deriving)
20:37:49 <Axman6> return :: c -> a -> c, >>= :: (a -> b) -> (b -> a -> c) -> (a -> c)
20:37:54 <tnks> sorry, "Using newtype deriving with the mtl library typeclasses we can produce flattened transformer types that don't require explicit lifting in the transform stack."
20:38:34 <tnks> not sure how newtype + generalized deriving leads to not having to compose lift's and return's
20:39:28 <carter> tnks: you can get composit transformers that inhabit all the classes you want
20:39:32 <carter> without sadness
20:40:15 <tnks> carter: I'm guessing this has to do with some fanciness in the mtl implementation?
20:40:27 <tnks> just not sure what the mechanism is.
20:40:29 <carter> tnks: have you ever used generalized newtype deriving before?
20:40:34 <carter> it has nothing to do with MTL
20:40:55 <carter> everything to do with {-# LANGUAGE GeneralizedNewtypeDeriving #-}
20:40:59 <carter> and then you can do
20:41:18 <johnw> well... where MonadState is concerned it has a bit to do with the mtl
20:41:22 <dfeuer> HI CARTER.
20:41:31 <carter> eg newtype RandomT g m a = RT (StateT g m a) deriving (MonadState)
20:41:33 <carter> dfeuer: sup
20:41:39 <carter> dfeuer: things going good?
20:41:40 <johnw> otherwise, without the mtl, you have a newtype over just StateT, and then GeneralizedNewtypeDeriving will not safe you from having to use lift to call "get"
20:41:51 <dfeuer> carter, I finally, FINALLY, got the Data.Sequence <*> and *> into presentable condition!
20:41:57 <carter> ohh?
20:42:00 <dfeuer> They're actually something like readable now!
20:42:05 <tnks> johnw: this is along the lines of what I was thinking.
20:42:05 <carter> OOO
20:42:10 <dfeuer> https://github.com/haskell/containers/pull/141
20:42:12 <tnks> but I need to look at more code.
20:42:20 <carter> johnw: hows that different from whai said?
20:42:22 <johnw> tnks: so, you have newtype Foo = Foo (StateT...) deriving MonadState
20:42:23 <tnks> thought I'd ask here first to avoid weeds.
20:42:31 <johnw> and now boom, you can just use "get" in your Foo
20:42:43 <johnw> carter: you said it had nothing to do with the mtl
20:42:48 <carter> :)
20:42:58 <johnw> but we need these abstracting classes like MonadState, for GeneralizedNewtypeDeriving to give us "flattened stacks"
20:43:03 <carter> it has to do with dervig an mtl class
20:43:03 <Zer000> hey I've defined a data structure and an insert method for it (insert :: Int -> Bucket -> Bucket). I want to (for testing) insert an [Int] into Bucket, so I need a function with the type [Int] -> Bucket -> Bucket. How can I do this?
20:43:08 <johnw> right
20:43:25 <tnks> okay, it's making more sense now.
20:43:34 <tnks> let me see if I can stew in it.
20:43:43 <dfeuer> No more partial functions! No more impossible errors! Close to 20% speedup on some tests!
20:43:46 <delimax> HeladoDeBrownie: rly?
20:44:01 <HeladoDeBrownie> delimax, what?
20:44:09 <carter> dfeuer: woah
20:44:10 <delimax> HeladoDeBrownie: i thought they were :/
20:44:18 <HeladoDeBrownie> delimax, you thought what was what?
20:44:26 <delimax> HeladoDeBrownie: iambs
20:44:32 <carter> dfeuer:  props
20:44:36 <carter> thats ... seriously good work
20:44:40 <HeladoDeBrownie> delimax, oh. an iamb consists of two syllables, the first unstressed and the second stressed.
20:44:41 <dfeuer> carter, the speedup is not going to be practically significant, I promise, but I'm very happy it's finally clean.
20:44:53 <dfeuer> :-)
20:44:58 <carter> dfeuer: what was the insight, in retrospect?
20:45:01 <tnks> carter: johnw: thanks, I think it sank in.
20:45:10 <hxn1248> Zer000: how about a fold?
20:45:22 <Essence> I'm not a big adept of Haskell yet, but I'm trying to learn some... could someone give me a hint about how acid-state relates to database? does it replace a database in some way?
20:45:37 <Essence> databases* in general
20:45:40 <delimax> HeladoDeBrownie: ah. i was thinking it was ten syllable phrases with alternating stress in the phrase, irrespective of individual words
20:45:41 <dfeuer> carter, I was stitching the pieces together a bit wrong. I was ... stretching out pieces that I didn't need to.
20:45:47 <tnks> carter: johnw: but I'm curious. . . why do I need the newtype at all?
20:45:51 <carter> Essence: not quite, think of acide state are more like a transatction log
20:45:55 <carter> tnks: naming things 
20:45:58 <tnks> why can't I just use the raw type?
20:46:01 <HeladoDeBrownie> delimax, you're not wrong, but it also has the additional restriction i just mentioned.
20:46:08 <carter> tnks: newtype lets you name things and give them new instances
20:46:20 <johnw> tnks: to differentiate
20:46:21 <dfeuer> newtype lets you hide things too :-)
20:46:21 <delimax> HeladoDeBrownie: stopped reading at 'not wrong' lelele
20:46:28 <delimax> jokes
20:46:31 <johnw> if you don't need to differentiate, and you can, use a type synonym
20:46:33 <HeladoDeBrownie> um, all right.
20:46:38 <tnks> johnw: okay, but this composed lifting isn't dependent on that, right?
20:46:48 <johnw> but type synonyms get finicky about partially applied type variables
20:46:56 <carter> dfeuer: i need to crash soon, but it looks clearner
20:47:01 <dfeuer> :-)
20:47:02 <delimax> HeladoDeBrownie: jokes! yea that's all fine then. i shall re-retreat.
20:47:06 <johnw> well, you don't need lifting with a type synonym at all
20:47:08 <HeladoDeBrownie> delimax, have fun
20:47:09 <dfeuer> Good night, carter.
20:47:23 <johnw> i mean, it doesn't add any lifting
20:47:28 <Essence> carter: right... just to be sure, could you give me some example of usage?
20:47:36 <EvanR> Essence: its an in-memory database, it lets you update a single value transactionally
20:47:37 <carter> of what?
20:48:01 <tnks> johnw: k. . . I should probably play in a REPL, but I'm trying to avoid the setup to play. . . 
20:48:17 <johnw> yes, in this case playing will be quite illustrative
20:48:18 <EvanR> Essence: one example of that value is an ixset, an indexed set
20:48:20 <Essence> of a use case for acid-state in which a database wouldn't fit well
20:49:13 <carter> tnks: you can define types in repl
20:49:15 <EvanR> Essence: for example if your gui programs state were in the acid state, you wouldnt need config files, save states, or a database to run it
20:50:21 <tnks> carter: yeah, I'm doing that now.
20:51:04 <EvanR> Essence: acidstate is faster to access and doesnt require an rdbms running somewhere
20:51:55 <Zer000> hxn1248 yes! I looked that up and it will work
20:52:15 <Zer000> now I need to figure out how to get the number of things in a Data.Map
20:52:42 <Zer000> ah I got that too it's "size"
20:52:43 <Zer000> woot
20:52:52 <Essence> humm got it... I heard about it when reading Happstack, but I still couldn't find a good usage example on a webserver like this one
20:53:37 <Essence> and in their page, it looks like it would be a substitute for a RDBMS, this is why I got confused
20:53:54 <EvanR> probably not
20:56:40 <EvanR> id put maintenance and tooling that a postgres server provides first
21:00:13 <tabaker> I'm trying to install libffi via cabal. cabal install libffi. Simple enough. 
21:00:17 <tabaker> setup-Simple-Cabal-1.22.0.0-x86_64-osx-ghc-7.8.3: The pkg-config package 'libffi' is required but it could not be found.
21:00:32 <tabaker> but just before that it says it's Configuring libffi-0.1...
21:00:34 <EvanR> install libffi using your package managaer
21:00:39 <chirpsalot> brew install libffi
21:00:56 <tabaker> EvanR: it says it's already installed. 
21:01:05 <chirpsalot> tabaker: http://brew.sh/
21:01:11 <chirpsalot> tabaker: brew does?
21:01:18 <chirpsalot> brew link libffi?
21:01:29 <tabaker> chirpsalot: ya
21:01:38 <tabaker> $ brew install libffi
21:01:39 <tabaker>  Warning: libffi-3.0.13 already installed
21:01:49 <Hijiri> tabaker: I had some issues with pkg-config packages because my PKG_CONFIG_PATH didn't include it
21:02:14 <Hijiri> this was on debian though, for some reason my 64 bit pkg-config dir was not in there
21:02:32 <ProofTechnique> tabaker: Make sure $PKG_CONFIG_PATH contains /usr/local/lib/pkgconfig
21:03:05 <tabaker> ProofTechnique: Ah, that might very well be it. Right now, I don't believe I have that vbl set.
21:03:30 <ProofTechnique> Oh, nope
21:03:33 <ProofTechnique> Fails for me, too
21:03:54 <ProofTechnique> Forcing the brew link should work, or specifying the path to the library manually
21:04:02 <ProofTechnique> It's probably due to being keg-only
21:04:20 <drewbert> Does haskell have any proof-of-work libraries for web development?
21:06:07 <tabaker> ProofTechnique: Any idea what that cryptic-but-omenous warning "Warning: libffi is keg-only and must be linked with --force Note that doing so can interfere with building software." portends?
21:07:33 <ProofTechnique> It could interfere with future builds that depend on the system libffi.
21:07:54 <zilinc_> Why is a typeclass with no methods useful in Haskell?
21:08:07 <ProofTechnique> tabaker: I have a better solution, though
21:08:14 <Axman6> sometimes it can be used for making shorted constraints
21:08:29 <ProofTechnique> tabaker: Add /usr/local/Cellar/libffi/3.0.13/lib/pkgconfig to your PKG_CONFIG_PATH
21:08:31 * tabaker is all ears
21:08:33 <ProofTechnique> Or whatever version
21:08:38 <ProofTechnique> Then it installs fine.
21:08:38 <Axman6> class (Typeable a, Binary a) => Serialisable a where
21:08:53 <tabaker> ProofTechnique: Oh, I like that.
21:09:01 <tabaker> Okay, lemme go take that for a spin.
21:09:15 <ProofTechnique> I think it technically has the same risk of messing with future builds, but it's way easier to reverse than forcing a brew link
21:09:16 <HeladoDeBrownie> zilinc_, conceivably, you can use it to ensure that a function may never be used. i can't think of any direct applications though.
21:10:02 <HeladoDeBrownie> zilinc_, other than what Axman6 said, which implies it has constraints even if no methods
21:10:33 <zilinc_> Axman6: I agree, but in terms of semantics, are there anything significant?
21:14:10 <zilinc_> HeladoDeBrownie: I didn't quite get your first point.. could you elaborate more how a function cannot be used?
21:14:22 <HeladoDeBrownie> zilinc_, if it has a constraint that is impossible to fulfill
21:14:57 <HeladoDeBrownie> e.g., if you don't export the class, don't define any instances, and require an instance
21:15:02 <HeladoDeBrownie> kind of convoluted really
21:15:09 <HeladoDeBrownie> there are better ways to get impossible constraints
21:15:18 <zilinc_> HeladoDeBrownie, oh I see what you mean
21:15:25 <arkeet> (Int ~ Bool) => ...
21:15:54 <zilinc_> HeladoDeBrownie: but then that type class does have methods
21:16:13 <HeladoDeBrownie> zilinc_, it may or may not have them, it would be irrelevant for that use
21:17:40 <zilinc_> yes. the reason I asked is because I saw many type classes that add more laws (i.e. properties), but no more methods
21:18:05 <HeladoDeBrownie> oh, i see
21:18:17 <HeladoDeBrownie> in that case you're probably talking about what Axman6 mentioned
21:18:34 <HeladoDeBrownie> a class with constraints but not methods of its own
21:18:40 <zilinc_> I don't quite search for it but I guess there's work that checks the properties, say using theorem provers
21:18:53 <HeladoDeBrownie> well, not really
21:18:58 <HeladoDeBrownie> those tend to be verified by hand if at all
21:20:25 <tnks> anyone know why when I do "nix-shell -p haskellPackages.mtl --command ghci" I don't see Control.Monad.Reader?
21:21:14 <tnks> I see it when I do a normal cabal sandbox.
21:21:28 <tnks> so this is probably a bit on the Nix side.
21:21:36 <tnks> but I thought I'd ask here first.
21:26:53 * hackagebot farmhash 0.1.0.2 - Fast hash functions.  http://hackage.haskell.org/package/farmhash-0.1.0.2 (abhinav)
21:36:24 <tnks> johnw: so after dicking around with nix-shell, I just punted and got a sandbox.
21:37:07 <tnks> so I proved to myself that the newtype and generalized deriving doesn't seem to have much to do with mtl giving me nice classes to avoid composed lifts.
21:37:16 <tabaker> ProofTechnique: Seems to be working, btw. Thanks for the help, all. 
21:37:25 <ProofTechnique> Awesome!
21:37:26 <tnks> I can just use the raw monad stack, it seems.
21:37:27 <randir> How can I filter out NaN values from a list of Floats?
21:37:42 <tnks> johnw: but were you saying earlier that this might affect inference or something?
21:38:07 <tnks> just trying to rack up all the proper arguments for a new type wrapping.
21:38:57 <kaidelong> > filter (\x -> (x==x)) [(0/0),(0/0),5,6,4]
21:38:58 <randir> ah, nvm, found isNaN
21:38:58 <lambdabot>  [5.0,6.0,4.0]
21:39:17 <kaidelong> @src isNaN
21:39:17 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
21:39:30 <johnw> no, I said nothing about inference
21:39:41 <ProofTechnique> @hoogle isNaN
21:39:43 <lambdabot> Prelude isNaN :: RealFloat a => a -> Bool
21:39:48 <johnw> I just meant that you can get the fact that your Foo is a MonadState "for free" with GeneralizedNewtypeDeriving
21:40:04 <kaidelong> I guess isNaN might be a bit better then
21:40:14 <ProofTechnique> > filter (not . isNaN) [0 / 0, 2, 4, 5]
21:40:14 <kaidelong> if it's overloadable at least
21:40:15 <lambdabot>  [2.0,4.0,5.0]
21:40:28 <tnks> johnw: sorry, I was referring to "but type synonyms get finicky about partially applied type variables"
21:40:35 <johnw> ah
21:40:37 <tnks> maybe not inference.
21:40:49 <johnw> so, you have a type synonym Foo m a = Foo (StateT () m a)
21:40:57 <johnw> you can't then have ReaderT r (Foo m) a
21:41:00 <johnw> it'll complain
21:41:15 <johnw> sorry, the type synonym shouldn't have Foo on the right side of teh =
21:41:27 <kaidelong> is there any library for interpreting java script in a haskell application?
21:41:57 <Axman6> system "node foo.js"
21:41:58 <Axman6> >_>
21:42:19 <tnks> johnw: but you can do Foo = StateT (), right
21:42:24 <tnks> to get around that problem?
21:42:45 <kaidelong> Axman6: this would be for working with XAML files
21:42:52 <kaidelong> with embedded javascript
21:42:56 <Axman6> ew :(
21:42:59 <johnw> tnks: yes, in that case it should work fine
21:43:10 <kaidelong> so it'd need some kind of DOM support too
21:43:13 <tnks> okay, then I think I understand the issue to some approximation.
21:45:24 <kaidelong> doesn't look like it
21:45:56 <tnks> johnw: I think S11001001 had a good discussion of this in https://gitorious.org/nt-in-haskell/answers/source/46d13e404cad08e2a8bff26c1506968cf31d9ff5:src/NT/C.hs#L61-103
21:46:01 <tnks> I need to review that.
21:58:46 <funfunctor> Do folks recommend conduit as a good method to handle data streaming?
21:59:10 <johnw> funfunctor: or pipes
21:59:18 <ProofTechnique> Or machines
21:59:26 <funfunctor> pipes? i'll look that up now
21:59:26 <johnw> or simple-conduit
21:59:51 * HeladoDeBrownie uses and enjoys pipes such that they have not sought alternatives
22:00:07 <johnw> learning pipes is a good investment
22:00:07 <HeladoDeBrownie> though depends on the problem obviously
22:00:15 <Axman6> I found that pipes wasn't able to do what I wanted with it and gave up on using it
22:00:31 <Axman6> or, if it is able to do it, it's certainly not non-trivial
22:01:07 <HeladoDeBrownie> so, it's trivial?
22:01:10 <HeladoDeBrownie> :P
22:01:18 <funfunctor> my requirements are the following scenario: radio is pouring in data as a bytestring, the data is broken up into bursts that have typed structure attached to them such as timestamps and so on.. then I need them organized into a priority queue of these 'radio vectors'
22:01:24 <Axman6> uh, yes, it's certainly non-trivial
22:01:54 * hackagebot cabal-db 0.1.12 - query tools for the local cabal database  http://hackage.haskell.org/package/cabal-db-0.1.12 (VincentHanquez)
22:05:52 <funfunctor> johnw: what are the major pro/cons for pipes vs. conduit
22:06:28 <mmachenry> funfunctor: http://www.haskellcast.com/episode/006-gabriel-gonzalez-and-michael-snoyman-on-pipes-and-conduit/
22:06:41 <funfunctor> mmachenry: thx!
22:06:55 * hackagebot ghc-core-html 0.1.2 - Core to HTML display  http://hackage.haskell.org/package/ghc-core-html-0.1.2 (VincentHanquez)
22:07:25 <johnw> funfunctor: I think that pipes hew more closely to the spirit and strength of Haskell types
22:07:42 <johnw> while conduit sacrificing some of those for "convenience" and "intuitiveness of user interface"
22:07:59 <funfunctor> johnw: while skimming that was my feeling
22:08:02 <johnw> pipes makes you learn more, but I believe that in doing so, you understand your problem more, which is part of the Haskell Way in my opinion
22:08:10 <johnw> note that I know conduit a LOT better than I know pipes
22:08:15 <johnw> but I now much prefer pipes
22:08:20 <funfunctor> thx
22:09:19 <HeladoDeBrownie> Axman6, i was playing off of a typo you made, i wasn't disagreeing that you ran into trouble with it
22:09:34 <Axman6> I know =)
22:09:39 <HeladoDeBrownie> okay, just checking
22:10:16 <funfunctor> johnw: listening to the two of them, I am excited by pipes authors view point
22:10:49 <mmachenry> funfunctor: I have been using conduit for a tcp-server and it works great
22:11:01 <Axman6> pipes has some pretty serious limitations imo
22:11:04 <lexi-lambda> http://stackoverflow.com/q/28978857/465378
22:11:08 <funfunctor> I'm sure they both work well
22:11:12 <johnw> Axman6: namely?
22:11:20 <johnw> the two libraries are very nearly equivalent
22:11:40 <Axman6> if you need to output some data once your input is exhausted, it's afaict not possible with pipes in a clean way
22:11:55 <johnw> conduit just bakes in some core stuff -- specifically, "left overs" -- for the sake of convenience
22:12:10 <johnw> Axman6: ah, you mean detection of upstream termination
22:12:15 <Axman6> yes
22:12:29 <johnw> you solve that in pipes with a function that takes a pipe, rather than just composing it with a sink
22:12:29 <Axman6> which is vital when you need to output an HMAC at the end of a stream of data =)
22:12:43 <johnw> that way, your function can drain the pipe until its end, and then produce more data
22:12:49 <arkeet> lexi-lambda: ghci takes "pure A" to have type IO T, and when ghci sees something of that type, it'll run the IO action.
22:12:57 <arkeet> if the result type has a Show instance, it'll show the result, otherwise it won't.
22:13:09 <lexi-lambda> arkeet: Why?
22:13:19 <johnw> also, this way that type specifically states that the lifetime of your output is not directly tied to the lifetime of your input, which I like
22:13:21 <arkeet> why on which part?
22:13:24 <johnw> in conduit, that relationship is masked
22:13:34 <lexi-lambda> Why does it take it as having type IO?
22:13:38 <Axman6> johnw: It feels to me that say encrypting some data should be a Pipe ByteString ByteString
22:13:52 <johnw> Axman6: and maybe it shouldn't be
22:14:01 <arkeet> good question.
22:14:02 <Axman6> why not?
22:14:12 <johnw> I'm just saying, just because it seems like it should have that type, doesn't mean it should
22:14:35 <johnw> if, after exhaustion of the input, there is still work to be done, then you don't purely have a stream of ByteString -> ByteString
22:14:41 <johnw> you have a stream of ByteString -> ByteString, plus some extra work
22:15:40 <arkeet> lexi-lambda: well, the easy answer is that it was programmed to.
22:16:04 <lexi-lambda> arkeet: I was hoping for something of a rationale for such programming. ;p
22:16:09 <arkeet> :p
22:17:58 <johnw> which is the difference between Pipe ByteString ByteString (), and Producer ByteString () -> Producer ByteString ()
22:20:32 <funfunctor> this shits complicated.. going to need to buckle down on this one to get some examples working :/
22:21:02 <Axman6> do you have an example of how one would build such a thing? I couldn't see how to extract values one by one from a producer, and then produce more output once it's finished
22:21:20 <johnw> Axman6: sure, one sec
22:23:34 <johnw> Axman6: note ,this is absolutely NOT how you would want to implement this:
22:23:35 <johnw> https://gist.github.com/56e4700c0d180a9b942c
22:23:39 <johnw> but it's just an existence proof of the concept
22:23:51 <johnw> it basically throws out every single advantage of using pipes
22:24:00 <johnw> but I wanted to show how a producer could produce from another producer
22:24:24 <Axman6> heh, yes, that is less than ideal =)
22:24:28 <johnw> ah, this is better:
22:24:33 <johnw> axman6 = flip for yield
22:24:33 <johnw> :)
22:24:39 <johnw> and preserves all pipe advantages
22:24:45 <johnw> now of course, that is just equal to a Pipe
22:24:56 <johnw> but now you can add more yields after the for is done executing
22:25:19 <Axman6> I need to do something with the output and update some state (fold over the produced values basically)
22:25:35 <johnw> you mean, the output you had produced?
22:25:57 <Axman6> the output of the producer argument (src in this case)
22:26:12 <Axman6> my use case was to encrypt the data using a specific format
22:26:24 <johnw> well, you could: runWriterT $ for src $ \x -> tell [x] >> lift (yield x)
22:26:34 <johnw> that would "gather up" the data from src as you were downstreaming it
22:26:42 <johnw> now, this is better done with the foldl library
22:26:49 <johnw> which allows you to do two things at once efficiently
22:26:56 * hackagebot record 0.2.2 - First class records implemented with quasi-quotation  http://hackage.haskell.org/package/record-0.2.2 (NikitaVolkov)
22:27:01 <johnw> i.e., both generate the encrypted data, while computing a final value based on the input stream
22:27:09 <Axman6> no, just folding over the data with something of type (roucghly) ctx -> ByteString -> (ctx, ByteString)
22:27:14 <johnw> yep
22:27:21 <johnw> foldl is designed for that, and designed to work with pipes in just that way
22:28:05 <gfixler> is there a list of the most prolific Haskell library writers?
22:28:15 <gfixler> I'm guessing kmett is at the top
22:28:19 <gfixler> but who else?
22:28:25 <Axman6> yes, but it's edwardk in the top 10 positions
22:28:29 <gfixler> hehe
22:28:57 <edwardk> snoyman is next on the list
22:29:03 <edwardk> below that i couldn't tell you
22:29:28 <johnw> Axman6: i.e., axman6 src = foldM (processor) (initialize) (finalize) src
22:29:44 <edwardk> johnw: the unnecessary parens, they burn!
22:29:46 <Axman6> that's exactly what I want...
22:29:49 <johnw> where the processor can submit chunks downstream with yield
22:29:50 <johnw> edwardk: haha
22:30:04 <arkeet> not enough parens!
22:30:08 <Axman6> where does that foldM come from?
22:30:17 <johnw> pipes-extras
22:30:26 <Axman6> @hackage pipes-extras
22:30:26 <lambdabot> http://hackage.haskell.org/package/pipes-extras
22:30:28 <funfunctor> johnw: for loop construct?! http://hackage.haskell.org/package/pipes-4.1.4/docs/Pipes.html#v:for
22:30:44 <johnw> the thing is, in all the type I used conduit, it never let me to thinking about streams like this
22:30:55 <johnw> it was always more about solving whatever problem, not elevating my thought
22:30:59 <joneshf-laptop> I'd expect the hackage data to be available somewhere
22:31:00 <johnw> better types are always better for thought
22:31:08 <joneshf-laptop> so you could evaluate things like that
22:31:18 <johnw> edwardk is the prince of that notion
22:31:29 <joneshf-laptop> wait, does hackage have an api?
22:31:35 <joneshf-laptop> public like
22:32:11 <joneshf-laptop> so it odes: https://hackage.haskell.org/api
22:32:30 <funfunctor> johnw: isn't the for-loop construct the canonical ideal of imperativeness
22:32:44 <johnw> funfunctor: maybe the one you're thinking of :)
22:32:51 <Axman6> funfunctor: this is quite different to your usual for loop
22:32:53 <johnw> in some libraries, for = flip fold
22:33:04 <Axman6> it's possibly closer to a for-in loop, but different
22:33:10 <johnw> i.e., you put the iteration function in final position, rather than first position
22:33:32 <funfunctor> I don't really understand but i'll just keep reading
22:33:50 <funfunctor> page is a blurr to me at the moment until my mind finds some patterns
22:34:29 <johnw> don't think of "for" as "imperative" for now
22:35:14 <johnw> because most imperative loops can be made pure just by using State
22:35:29 <gfixler> edwardk: I haven't even heard of snoyman - how odd
22:35:30 <Axman6> "for each input, do this thing which produces output"
22:35:40 <Axman6> gfixler: never heard of yesod?
22:35:45 <johnw> snoyman has several libraries, but all in a fairly specific category -- writing webapps
22:35:46 <gfixler> that I've heard of
22:36:03 <gfixler> ah, well I don't do web stuff, but still - snoyman needs a better PR person
22:36:40 <Axman6> johnw: looks like foldM is exactly what I want. I'm pleased because last time I asked I was told what I wanted wan't possible
22:37:09 <johnw> :)
22:37:23 <johnw> trying to do as a Pipe is truly impossible
22:37:25 <funfunctor> snoyman is on my G+, he does some interesting work on yesod
22:37:39 <johnw> but allowing for a first-order solution (i.e., a function taking producers), opens up your expressiveness by another dimension
22:37:58 <funfunctor> but yes he tends to solve very particular problems. I prefer more general packages
22:38:55 <johnw> ok, this is a very rough sketch, but I just grepped all packages on Hackage for the word "author", including all versions
22:39:01 <johnw> top two are snoyman and kmett, in that order
22:39:31 <johnw> next five are: Brendan Hay, Vincent Hanquez, Kazu Yakamoto, Bryan O'Sullivan, Henning Thielemann
22:40:24 <gfixler> johnw: wait, snoyman has *more* than ~180 libraries?
22:40:27 <shachaf> These statistics aren't very meaningful.
22:40:37 <johnw> there are 3040 lines containing the word "author" and "snoyman"
22:40:49 <Axman6> johnw: I assume that the decryption side would also be similar; it needs to parse some header data, the decrypt all the stuff in the middle and output it, and finally verify the HMAC (and probably return something stating whether the HMAC matches)
22:40:58 <johnw> that includes co-authorship too
22:41:17 <gfixler> johnw: that's unbelievable
22:41:21 <Axman6> I would've thought that encrypt and decrypt would be... dual of each other?
22:41:53 <ttt_fff> philosophically, how does postgres-simple and hsql differ?
22:41:58 <shachaf> Verify MAC after decrypting? Sounds suspicious.
22:42:18 <johnw> shachaf: suggest another metric, and I'll try it
22:42:22 <shachaf> Not that I see any context for that.
22:42:23 <Axman6> it's the hmac od the unencrypted data IIRC
22:42:28 <gfixler> johnw: I'm more inclined to believe he wrote one library, with an surreptitiouslyInsertAuthor function
22:42:45 <shachaf> MAC-then-encrypt is rarely the right thing to do.
22:43:05 <Axman6> this is decryption
22:43:16 <shachaf> Yes.
22:43:18 <Axman6> the file format is header
22:43:34 <shachaf> I don't have context so I don't know what you're implementing.
22:43:39 <Axman6> bleh, header | encrypted data | HMAC of unencrypted data iirx
22:43:41 <Axman6> c*
22:43:42 <funfunctor> lol, why do puppies make such funny sounds while they sleep..
22:44:22 <shachaf> What is this format?
22:45:05 <Axman6> something called RNCryptor: https://github.com/RNCryptor/RNCryptor-Spec/blob/master/draft-RNCryptor-Spec-v4.0.md
22:45:42 <Axman6> there's already a working Haskell library, which implementes an io-streams interface, so I thought I'd try my hand at making a pipes version
22:46:18 <Axman6> although the haskell library is for v3
22:46:30 <Axman6> https://github.com/RNCryptor/RNCryptor-Spec/blob/master/RNCryptor-Spec-v3.md
22:46:41 <shachaf> https://github.com/RNCryptor/RNCryptor-Spec/blob/master/draft-RNCryptor-Spec-v4.0.md#general-encryption-function suggests that the MAC is of the ciphertext.
22:47:02 <Axman6> oh, potentially, it's been a while since I read it
22:47:33 <funfunctor> what is RNCryptor?
22:47:57 <glguy_> hmac = HMAC(SHA512, hmacKey, header || ciphertext, 256 bits)
22:48:34 <Axman6> right. well for me it's mostly unimportant, as long as the library implements it correctly
22:48:57 <shachaf> I'm not quite sure what's going on here. Why this format?
22:49:32 <Axman6> for fun, it seemed simple
22:49:45 <Axman6> I'm not planning to release this unless it would be useful for someone
22:50:16 <johnw> ok, here are different numbers: https://gist.github.com/25bb0ebd6304a0a0d02c
22:50:26 <johnw> now each author is given credit only once for a package, not for every version
22:50:30 <johnw> but co-authorship is still considered
22:51:05 <johnw> mostly the same  name, but the order changes, and Don Stewart and Chris Done appear
22:51:23 <funfunctor> Haskell's monadic syntax is a language of emoticons
22:51:44 <pacak> funfunctor: Have you ever used lisp? )))))))))
22:51:56 * hackagebot record 0.3.0 - First class records implemented with quasi-quotation  http://hackage.haskell.org/package/record-0.3.0 (NikitaVolkov)
22:52:10 <shachaf> Is this Haskell code even checking the MAC?
22:52:21 <haasn> Is there a sister function to “truncate” that gives me the stuff behind the decimal rather than the stuff before it?
22:52:52 <shachaf> The best reason not to release broken cryptography code is that it *would* be useful for someone.
22:52:53 <funfunctor> pacak: I have a long time ago yes
22:53:02 <johnw> shachaf: lol :)
22:53:07 <funfunctor> :t (>=<)
22:53:08 <lambdabot>     Not in scope: ‘>=<’
22:53:08 <lambdabot>     Perhaps you meant one of these:
22:53:08 <lambdabot>       ‘>=’ (imported from Data.Ord),
22:53:24 <shachaf> haasn: There's porperFraction.
22:53:27 <shachaf> properFraction
22:53:46 <haasn> Oh, I thought that would give me an integer fraction or something. Thanks, that's what I needed
22:53:57 <pacak> :t (╯°□°)╯︵ ┻━┻
22:53:58 <lambdabot> lexical error at character '\65077'
22:54:02 <funfunctor> shachaf: everyone thinks they can do crypto right, and we all know how that turns out in the end..
22:54:20 <funfunctor> pacak: #agda2 :)
22:54:25 <Axman6> shachaf: yeah it doesn't look like it does, I had assumed that happened in the finaliser in the pipe, but I guess not
22:54:29 <johnw> the person I trust to do crypto right is the person who thinks he's never gotten right
22:54:32 <delimax> funfunctor: ya u just XOR all the bits with 0xee rite?
22:54:50 <pacak> delimax: Twice, just to be sure.
22:54:54 <delimax> lol
22:55:21 <shachaf> So almost certainly don't trust the Haskell code, and probably don't trust the format unless you have a reason to?
22:55:29 <funfunctor> johnw: thing is with crypto, you could have a mathematically perfect implementation and that is still not nearly enough.
22:55:45 <johnw> I wouldn't mind starting out with mathematically perfect though
22:56:11 <funfunctor> johnw: recommend looking into Cryptol if you have not already
22:56:20 <johnw> I have, it's very cool stuff
22:56:27 <HeladoDeBrownie> we should just leave all secrets in plain sight where no one will find them
22:56:38 <Axman6> shachaf: yeah there appears to be plenty of other issues with the code too. 
22:56:51 <funfunctor> johnw: :) i've made a codegen for llvm for it
22:57:26 <johnw> very nice!
22:57:35 <johnw> what is your name?
22:57:59 <johnw> (if you want to say)
23:00:16 <shachaf> "consistent-time equality checking"?
23:00:56 <Axman6> let (rest, _) = B.splitAt (B.length lastBlock - 32) lastBlock --strip the hmac
23:01:00 <Axman6> pretty great comment
23:01:39 <Axman6> well at least the README says it doesn't validate the HMAC
23:02:07 <SrPx> Not sure if this is a good place to ask it, but how does "flux" relate to FRP? I've been hearing a lot about it lately, but I *can't* grasp the problem they are solving. For example, FB's "count" issue is not an MVC issue... it is an issue that you had two states for a value that derives from another... instead of a single state and a pure function.
23:02:16 <SrPx> So if anyone has already passed through this...
23:04:22 <joneshf-laptop> SrPx, I'm glad I'm not the only one that doesn't get it.
23:05:15 <SrPx> Right? I'm feeling really stupid right now. I've watched the video and read a wall of text and I'm like: "okay so... wtf is flux".
23:07:13 <SrPx> I was just trying to figure if it solves a real problem or is just another fancy "ammend js" thingy, but that is hard when you don't understand what it does lol
23:07:50 <joneshf-laptop> SrPx, I think you have to be more entrenched in js to really understand it
23:08:17 * SrPx shrugs
23:09:30 <joneshf-laptop> SrPx, when you come to terms with it, please message me, here or twitter or whatever
23:10:37 <dmj`> jle`: ping
23:10:50 <SrPx> joneshf-laptop: okay =) if ever
23:13:34 <luite> SrPx: it appears more centralized (dispatcher) than frp
23:14:15 <luite> but i haven't used it
23:18:09 <lpaste> nocturne777 pasted “Monoids” at http://lpaste.net/124468
23:19:17 <nocturne777> I don't understand how the following works given the definition of Tree data type as an instance of Foldable:  Foldable.foldl (+) 0 testTree 
23:19:33 <nocturne777> (+) is not a function that creates a monoid
23:19:37 <nocturne777> that's what confuses me 
23:21:38 <SrPx> and please, if anybody here has worked with flux before... any comment about it from a haskeller's perspective will be a light right now
23:21:50 <nocturne777> I wish jle` was around :)
23:22:11 <dmj`> you and me both nocturne777
23:24:51 <SrPx> why?
23:26:17 <dmj`> it's just a better place when jle` is around
23:26:56 <shachaf> nocturne777: Why are you expecting a monoid to be involved?
23:27:32 <shachaf> :t Data.Foldable.foldl
23:27:33 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
23:27:42 <nocturne777> shachaf: because of `mappend`
23:28:08 <shachaf> For foldMap, sure, but why for foldl?
23:28:46 <nocturne777> shachaf: foldr is implemented in terms of foldMap here
23:29:00 <shachaf> foldl and foldr and everything is implemented in terms of foldMap.
23:29:04 <nocturne777> so, foldr must be using foldMap in its implementation
23:29:43 <shachaf> Yes.
23:29:50 <shachaf> So your question is how foldr is implemented?
23:29:56 <shachaf> (You said foldl before, but either works.)
23:30:17 <nocturne777> that's why I was curious how foldMap could make foldr work given that foldMap relies on mappend
23:30:57 <nocturne777> yes, that's the question
23:31:15 <joneshf-laptop> nocturne777, you just have to supply a suitable `Monoid` to `foldMap` in the implementation of `foldr`
23:31:26 <dmj`> shachaf: what is your favorite Prelude function
23:31:28 <shachaf> OK. A good way to answer a question like that would be to look at the source. Another good way is to treat it as an exercise.
23:31:40 <joneshf-laptop> nocturne777, ^
23:31:46 <joneshf-laptop> the exercise bit is instructive
23:32:23 <shachaf> But if you don't want either of those ways I can say more about it.
23:36:51 <dmj`> Why wasn't Semigroup made a superclass on Monoid with the CTF changes? Or was it?
23:36:57 <arkeet> because semigroup isn't in base.
23:37:07 <dmj`> arkeet: why isn't semigroup in base
23:37:18 <arkeet> now that's a good question.
23:38:00 <arkeet> but it would break a lot of stuff.
23:38:12 <dmj`> how difficult would it be to define an indentical implementation of semigroup and mark the package as deprecated? Like how blaze-builder is being folded into bytestring
23:38:18 <dmj`> identical*
23:38:26 <dmj`> inside of base
23:38:26 <bitemyapp> forcing a semigroup superclass churns a lot of code.
23:38:45 <bitemyapp> for relatively little benefit (fewer people use semigroups than applicative, semigroup doesn't get bootstrapped by magma generally)
23:38:59 <dmj`> bitemyapp: so does the AMP proposal, but if we're going that direction why not go all the way
23:39:10 <bitemyapp> I just got done explaining why the situations are not comparable.
23:39:27 <bitemyapp> and then you redrew the comparison without responding to anything I said
23:39:33 <arkeet> edwardk probably has a few words to say.
23:39:58 <arkeet> if he's awake.
23:40:07 <bitemyapp> I'd rather, if we had a free reset, have a semigroup superclass but it's not nearly as high value as AMP.
23:40:13 <glguy_> > text "lambdabot, I need you to say glguy; in glguy *glguy differentglguy glguycircumstances"
23:40:14 <lambdabot>  lambdabot, I need you to say glguy; in glguy *glguy differentglguy glguycirc...
23:40:14 <dmj`> bitemyapp: if few people use it, it will churn less code
23:40:24 <arkeet> lots of people use Monoid.
23:40:29 <bitemyapp> but I can't even get people to embrace the use of NonEmpty where appropriate.
23:40:51 <arkeet> everyone that defines a Monoid instance would also have to supply a Semigroup instance.
23:40:51 <SrPx> joneshf-laptop: I guess I kinda get the point on flux now if you are interested ... pm
23:41:18 <bitemyapp> dmj`: there would be something like a revolt if Prelude churned all the Monoid instances in existence.
23:41:23 <arkeet> now if we had some sort of mechanism like implicitly defined default superclass instances.
23:41:31 <arkeet> then it would be a bit less painful.
23:41:33 <glguy_> bitemyapp: I added name highlighting in chat so that nicks in messages get the same color as they get when that person talks
23:41:36 <bitemyapp> dmj`: semigroup doesn't have the penetration or acceptance that Applicative has.
23:41:37 <dmj`> arkeet: now that's interesting
23:41:40 <arkeet> but we don't.
23:41:48 <SrPx> I find it amazing that one paragraph explaining "why" actually made me understand "how it works" much better than 500 paragraphs explaining "how it works"
23:42:01 <hurrburrhurr> glguy: yay tab complete
23:42:12 <bitemyapp> SrPx: which paragraph?
23:42:25 <glguy_> When bitemyapp and hurrburrhurr and glguy_ and glguy show up they should have the right colors
23:42:28 <bitemyapp> arkeet: that would be nifty but I think people would still grumpy.
23:42:30 <bitemyapp> grumble
23:42:30 <johnw> having semigroup in base isn't all that much different than just import Data.Semigroup from the semigroups package; there are that many types which I think to myself, "Oh, I wish they exported a Semigroup instance"
23:42:37 <johnw> s/are/aren't
23:42:58 <johnw> i mean, the number of semigroups I interact with that aren't also monoids is pretty small
23:43:32 <hurrburrhurr> glguy: magenta when you said that.
23:44:10 <SrPx> bitemyapp: "stores have no setters and there are no controllers that are orchestrating changes in them.  No one can touch the stores. They are read-only.  Stores are not updated by controllers, or by other stores, or by any other entity.  They update themselves, when they choose to do so, in response to new information. This is where the beauty of Flux really lies."
23:45:40 <bitemyapp> SrPx: wait is this a javascript thing?
23:47:07 <SrPx> bitemyapp: yea, I asked earlier if anyone here who worked with Flux knew if it had any parallel with FP, since most of what I read pointed it was all about functional reactive programming
23:47:31 <bitemyapp> oh, nuts.
23:48:43 <SrPx> I'm still trying to draw a conclusion on its usefulness as a Haskell thing, though. Seems like indeed it solves a non-existent problem for most of us.
23:49:16 <hurrburrhurr> hard to say. Frontend Haskell is still a very new thing.
23:49:47 <dmj`> I compiled lens with ghcjs, it was like 5MB of javascript
23:49:49 <hurrburrhurr> Most people are either trying to mate ReactJS to Haskell, reuse an existing FRP library, or create a new one with web in mind.
23:49:49 <joneshf-laptop> is it even a thing?
23:50:05 <joneshf-laptop> SrPx, yeah i'm interested
23:50:05 <hurrburrhurr> JonasH__: Given GHCJS and Haste, yes.
23:50:09 <hurrburrhurr> joneshf-laptop: ^^
23:50:17 <joneshf-laptop> SrPx, was that the paragraph?
23:51:38 <SrPx> I'll quote here in case anyone is curious, but I'm afraid to being offtopic... please call me out if I am... http://www.quora.com/What-is-it-like-to-use-Flux-front-end-application-architecture-made-by-Facebook-in-production Bill's answer here did it for me.
23:51:52 <dmj`> I'd take mithril.js over react.js, http://lhorie.github.io/mithril/, faster virtual dom, less code, simpler, html templating has the combinator approach
23:52:36 <SrPx> tl;dr, as I see now, the great magic of Flux is that there is only one place allowed to have state - it is called "Store". also, that state can't be modified by anything else on the app - only a store can change its own state. It does so based on global magic flying values called "actions" that it reads and reacts to
23:53:13 <SrPx> this way, the state is restrained and you get pretty much purity on everything else... 
23:53:44 <joneshf-laptop> so it s a non-problem in haskell or what?
23:54:07 <joneshf-laptop> i think it's too late for me to grok this
23:54:09 <SrPx> if this interpretation is correct, this is why I suspect the whole thing is irrelevant for Haskell, since it annihilates state already
23:54:28 <sgronblo> Guys, I'm getting this error when using Parsec No instance for (Stream s1 m2 Char) arising from a use of ‘string’
23:54:32 <SrPx> but I'm just grasping the issue... so I might be terribly wrong
23:54:58 <dmj`> sgronblo: can you paste your code?
23:55:19 <squiggles> glguy_++
23:55:28 <sgronblo> There is talk about a potential instance in Text.Parsec.String but that is already imported...
23:58:22 <sgronblo> dmj`: where oneUnderTop = string [low, top] >> return $ 9 * base
23:58:29 <sgronblo> this is the offending line
