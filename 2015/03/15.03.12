00:09:33 <ProofTechnique> It should if the source file has changed.
00:15:16 <RustyShackleford> i just want to make sure i'm interpeting this correctly
00:15:19 <RustyShackleford> import Another.Important.Module (printf, (<|>), )
00:15:42 <RustyShackleford> that would import ONLY those only, correct?
00:15:52 <dmj``> yes
00:16:03 <dmj``> you must remove the last comma
00:17:15 <RustyShackleford> thank you. The doc i'm reading doesn't explicitly say that
00:17:23 <RustyShackleford> they more imply it. I wasn't sure
00:17:41 <dmj``> what doc are you reading?
00:17:42 <nkar> RustyShackleford: you can always try in ghci
00:17:50 <nkar> RustyShackleford: and see whether an identifier is in scope
00:18:02 <nkar> RustyShackleford: same syntax
00:18:44 <syk0mantis> is it fair to ask lambda calculus questions here?
00:19:22 <Hijiri> I would think so
00:21:20 <syk0mantis> in the wikipedia article for lambda calc, can someone explain the third bullet point in the "caputre-avoiding substitutions" section please
00:21:35 <syk0mantis> sorry i mean the fourth bullet point
00:21:46 <syk0mantis> https://en.wikipedia.org/wiki/Lambda_calculus#Capture-avoiding_substitutions
00:21:50 <dmj``> http://stackoverflow.com/questions/11239262/what-is-meant-by-capture-avoiding-substitutions
00:23:17 <shachaf> syk0mantis: It means that the (λx. ...) "overrides" (shadows) any other meaning that x might have on the outside.
00:23:58 <syk0mantis> shachaf: i don't quite follow
00:24:16 <syk0mantis> shachaf: my understanding is that we replace x with r
00:24:27 <shachaf> Yes, but the lambda makes a different x.
00:24:30 <shachaf> > let x = "unused" in (\x -> x + x) 5
00:24:31 <lambdabot>  10
00:24:51 <shachaf> x is the string "unused" in that expression. But inside the lambda, x is an unrelated variable that happens to have the same name.
00:25:39 <syk0mantis> hmmmmm
00:25:41 <shachaf> So x isn't free in (\x -> ...)
00:25:51 <shachaf> (\x -> x) has no free variables.
00:25:55 * hackagebot yesod-bin 1.4.5 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.5 (MichaelSnoyman)
00:25:59 <syk0mantis> oh shit
00:26:17 <syk0mantis> hmmmm
00:26:34 <xnil> in exporting a data type from a module, say i'm exporting Maybe, i might do `module MyModule (Maybe(..)) where ...'
00:27:04 <xnil> now say i have a data type implemented as `type AST = [String]', would i do `AST(..)' or `AST'?
00:27:05 <syk0mantis> so since x is already bound, it can't be subsituted with r?
00:28:04 <dmj``> xnil: its' just a type synonym, so you can only export the type.
00:28:08 <xnil> as in, `module MyModule (AST(..)) where ...' or `module MyModule (AST) where ...'
00:28:15 <xnil> dmj``: ah, so the latter then
00:28:18 <dmj``> yes
00:28:23 <shachaf> What happened when you tried it?
00:28:24 <xnil> that's what i figured. thanks.
00:28:37 <dmj``> xnil: ghc should warn you that (..) makes no sense
00:28:40 <xnil> shachaf: i can't try it without considerable effort
00:28:49 <xnil> ahem, i can try using (..)
00:29:24 <xnil> i couldn't try to see whether just doing `AST' would have broken anything though, without expending considerable effort
00:29:32 <xnil> thanks though 4rizzle
00:29:47 <dmj``> it doesn't break anything, it gives you a warning
00:29:50 <shachaf> Considerable effort? You don't have access to GHC?
00:30:06 <shachaf> Ah.
00:30:16 <shachaf> Well, if you want to know, you can always read the Report: https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1000005.2
01:09:04 <haskell671> :)
01:09:33 <haskell671> is somebody there?
01:10:59 <haskell671> can someone please explain the meaning of the following code?
01:11:00 <haskell671> f m@(x':xs') n = ((a * n) + ((1 - a) * x')):m
01:12:04 <pyrtsa> Matches the first argument with the list (x':xs'), and m holds the whole list, x' the head and xs' the tail.
01:13:00 <pyrtsa> haskell671: ^
01:13:04 <haskell671> pyrtsa: I am sorry, did not follow you 
01:13:34 <pyrtsa> That was the explanation to the syntax "m@(x':xs')". Was there something else you didn't get?
01:14:17 <haskell671> yeah, what topic in haskell could I read up to understand it better?
01:14:42 <haskell671> also what is the meaning of :m?
01:15:22 <pyrtsa> (:) is the list construction operator. Adds the element of the left to the list of the right.
01:15:29 <pyrtsa> For patterns, read e.g. https://www.haskell.org/tutorial/patterns.html
01:16:38 <haskell671> pyrtsa: sure. thank you :)
01:21:29 <sinelaw> Can anyone recommend a pure equivalence class package? The data is Int
01:21:50 <sinelaw> the ones I found on hackage are STT/IO-based
01:27:02 <sinelaw> this one looks like it can do it: https://hackage.haskell.org/package/disjoint-set-0.2/docs/Data-IntDisjointSet.html
01:33:09 <RustyShackleford> python has a feature where you could do something like:
01:33:25 <RustyShackleford> "name: {}".format("John")
01:33:43 <RustyShackleford> is there such a thing for haskell?
01:33:48 <aawe> RustyShackleford: fprint
01:34:02 <sinelaw> https://hackage.haskell.org/package/base-4.7.0.2/docs/Text-Printf.html
01:34:06 <sinelaw> RustyShackleford, ^
01:36:01 <RustyShackleford> sinelaw: perfect. I cant tell, is that part of the standard libraries?
01:36:07 <RustyShackleford> or will I have to install something?
01:36:50 <sinelaw> stndard, it's in base
01:39:45 <dpwright> I'm interfacing with a C library using the FFI, and I want to load something into a bytestring.  The API expects me to allocate the string, and pass it to be filled.
01:40:05 <dpwright> I've done that initially by using malloc, filling the string, then loading it into a bytestring and freeing it
01:40:23 <iszak> So I have a project which needs one of Haskell's bins, I am using cabal to install it, but it would be nice to /sandbox/ it for that one specific project, is this possible?
01:41:04 <dpwright> is there a better way?
01:41:39 <sinelaw> iszak, cabal sandbox? http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
01:41:59 <iszak> sinelaw: yeah so that's why I use the forward slashes, but it's not in the stable version of cabal?
01:42:06 <sinelaw> iszak, it is.
01:42:10 <sinelaw> that blog post is old
01:42:26 <iszak> sinelaw: I did cabal update cabal-update and it didn't recognise cabal sandbox
01:42:41 <sinelaw> iszak, cabal --version
01:43:03 <iszak> two seconds, it's on my other laptop
01:43:49 <dpwright> I know ahead of time how big the string is going to be, so essentially I want to create and initialise a bytestring of a set length, passing the buffer into a C function to be filled
01:44:17 <iszak> sinelaw: 1.16.0 
01:44:25 <sinelaw> iszak, that's old
01:44:33 <iszak> but I did cabal update cabal-update
01:44:37 <sinelaw> cabal install cabal-install
01:44:48 <iszak> okay
01:44:57 <iszak> oh update != install
01:45:40 <iszak> sinelaw: now what?
01:45:51 <sinelaw> cabal version again to be sure
01:45:55 <sinelaw> --version
01:46:01 <iszak> same version
01:46:18 <sinelaw> hmm. did "cabal install cabal-install" work?
01:46:25 <iszak> yes oh I think it's because ~/.cabal/bin is not my $PATH
01:46:37 <dpwright> I guess `unsafeUseAsCString` is the answer, for a given definition of "a better way"
01:46:38 <sinelaw> k
01:47:02 <sinelaw> dpwright, try again later it's a bit quiet now
01:48:06 <dpwright> sinelaw: OK, thanks
01:48:30 <iszak> sinelaw: wonderful now I'm on 1.22.1.1 :)
01:48:38 <iszak> although it would have been nice to update the global cabal
01:48:44 <iszak> would sudo have fixed that
01:49:07 <sinelaw> not recommended
01:49:21 <sinelaw> and I'm not sure what sudo would do here. probably update the root user's ~/.cabal
01:49:31 <iszak> yeah that's what I thought, wonderful, thanks so much
01:49:41 <sinelaw> np
01:51:03 <steffen`> What kind of a syntax is this, where you allow a string between the import statement and the module name? where can I read up on it?
01:51:28 <steffen`> like 'import "mtl" Control.Monad.Sate"
01:52:44 <divVerent> Fun with NaN: http://codepad.org/6m36JUEq
01:52:55 <divVerent> is there even a correct behavior specified somewhere?
01:52:59 <iszak> sinelaw: do I have to setup a package and all that as well with sandboxes?
01:53:02 <divVerent> or did I just discover nasal demons?
01:53:40 <divVerent> (noticed, my ghci, compare nan _ and compare _ nan is always GT, even compare nan nan is; on codepad, they all compare as EQ)
01:54:00 <Haskellfant> divVerent: according to ieee754 NaN ≠ NaN
01:54:08 <Haskellfant> (not sure if haskell respects that)
01:54:15 <Haskellfant> but it looks like it does
01:54:23 <divVerent> yes
01:54:25 <divVerent> the thing is
01:54:31 <divVerent> IEEE doesn't specify what compare should do
01:54:37 <divVerent> as it only considers < > <= >= == !=
01:54:51 <sinelaw> iszak, once you do 'cabal sandbox init', you work as if starting in a clean setup
01:54:56 <divVerent> and apparently, different Haskell runtimes implement compare different for this case
01:55:03 <sinelaw> iszak, usually I start by doing 'cabal install --only-dependencies'
01:55:27 <divVerent> essentially, you can't have a compare that supports nan AND is consistent with the IEEE-specified relational operators
01:56:06 <divVerent> I just wonder whether a correct Haskell implementation should rather have compare nan _ == undefined
01:56:19 <divVerent> given none of the Ordering results is consistent
01:57:35 <steffen`>  What kind of a syntax is this, where you allow a string between the
01:57:35 <steffen`>            import statement and the module name? where can I read up on it?
01:57:35 <steffen`>            like 'import "mtl" Control.Monad.Sate"
01:57:44 <steffen`> ups^^ :)
02:00:29 <levi> steffen`: GHC's package-qualified imports
02:01:47 <levi> steffen`: https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/syntax-extns.html#package-imports
02:01:53 <steffen`> levi: Thank you :)
02:08:29 <bartavelle> is there a way to "forkOS" and get the primary thread ? 
02:08:39 <iszak> sinelaw: do I have to setup a package and all that as well with sandboxes?
02:09:29 <sinelaw> iszak, not sure what you mean. do you only want the binaries of some package or are you building your own package as well?
02:10:12 <levi> iszak: You do have to create a .cabal file to use cabal sandboxes, yes.
02:10:49 <levi> But it doesn't have to be a very detailed one.
02:11:25 <iszak> sinelaw: some bins
02:12:03 <sinelaw> then just 'cabal install whatever'
02:12:11 <sinelaw> iszak, ^
02:12:24 <iszak> sinelaw: which will install it to .cabal/bin/?
02:12:53 <levi> Not if you're in a sandboxed directory.
02:13:00 <iszak> oh great
02:13:01 <sinelaw> it will install it inside the sandbox, in .cabal-sandbox
02:13:12 <iszak> should I commit cabal-sandbox?
02:13:23 <sinelaw> commit?
02:13:34 <iszak> to VCS
02:13:47 <levi> Not the whole sandbox directory, certainly.
02:13:55 <iszak> just the .sandbox-config-etc file
02:14:38 <sinelaw> iszak, I wouldn't - what if you want to use whatever it is without a sandbox? you can commit a helper script to set up the sandbox 
02:14:46 <levi> I wouldn't unless it's got stuff in it that can't be reproduced from the normal cabal file.
02:14:52 <sinelaw> or you can create a .cabal file with appropriate dependencies
02:14:58 <sinelaw> and commit that instead
02:15:39 <sinelaw> iszak, also consider if the config file format changes, etc.
02:15:44 <iszak> okay, sorry I'm new to haskell/cabal, only using it to install shellcheck
02:15:46 <sinelaw> .cabal file is what I'd commit
02:15:59 <sinelaw> no worries :)
02:23:06 <iszak> sinelaw: so this is basically for CI, I have a project that needs shellcheck, I want the CI to just install what the project perscribes but in a sandbox so if we update it later, it doesn't conflict
02:23:51 <sinelaw> iszak, I'd create a shell script and commit that
02:24:13 <sinelaw> script = cabal sandbox init; cabal install shellcheck
02:24:18 <iszak> ah good idea
02:24:26 <sinelaw> (actuallly && instead of ;, but whatever)
02:25:45 <iszak> sinelaw: but then I can't lock the version in the project? does cabal install use the cabal.config?
02:28:45 <sinelaw> iszak, then use a .cabal file
02:29:01 <sinelaw> or
02:29:20 <sinelaw> cabal install foo-1.0
02:29:32 <sinelaw> iszak, or whatever version constraint you want
02:30:37 <sinelaw> iszak, I guess a cabal file is overkill for what you're doing, so cabal install with a version spec sounds good
02:32:00 <levi> You can cabal freeze to lock package versions.
02:37:53 <iszak> sinelaw: sorry stand up, I have in my cabal.config "constraints: shellcheck == 0.3.5"
02:38:10 <iszak> then I imagine I can just run cabal install?
02:45:41 <mniip> if I represent a 'class Foo a b | a -> b' with 'Foo a b => a -> b'
02:45:49 <mniip> how can I do the reverse
02:46:39 <mniip> for example what would I represent 'class Bar (a :: x -> y -> Constraint) b | a -> b' with?
02:48:11 <mniip> 'Bar a b, a c d => (c -> d) -> b' doesn't deduce very well
02:57:39 <merijn> mniip: Any solution is likely to include substantial amounts of pain and ugliness
02:57:49 <merijn> mniip: Oh, actually
02:57:56 <mniip> well
02:58:01 <merijn> mniip: Why not "class Foo a b => Bar b a"?
02:58:04 <mniip> I bet the ugliness is comparable to what I already have
02:58:16 <mniip> merijn, Foo isn't the only thing you can plug there
02:58:39 <mniip> also what
03:06:07 <dropp> join #emacs
03:06:12 <dropp> oops
03:06:16 <dropp> hey hey
03:07:00 <mniip> merijn, what do you mean by that
03:08:43 <merijn> What do I mean by what?
03:10:34 <mniip> that class makes no sense
03:13:43 <merijn> To me your class as described doesn't have any context to judge whether it makes sense or not, so I don't see what makes no sense about my suggestion?
03:39:21 <mniip> merijn, say I have 'class Foo a b | a -> b' and foo :: Foo a b => a -> b
03:39:59 <mniip> next I have 'class Bar (a :: x -> y -> Constraint) b | a -> b'
03:40:29 <mniip> what type should bar have so that bar foo :: Bar Foo a => a
03:40:57 <merijn> That makes no sense to me whatsoever
03:41:04 * hackagebot feldspar-signal 0.0.0.1 - Signal Processing extension for Feldspar  http://hackage.haskell.org/package/feldspar-signal-0.0.0.1 (mararon)
03:44:06 <mniip> class Bar (a :: x -> y -> Constraint) b | a -> b
03:44:07 <mniip> forall X. forall x. x :: X a b => a -> b: bar x :: Bar X a => a
03:44:08 <mniip> bar :: ?
03:44:50 <rola> what's | do
03:45:00 <mniip> -XFunctionalDependencies
03:46:22 <merijn> I don't understand what "bar x :: Bar X a => a" means
03:46:43 <mniip> function bar applied to value x
03:46:51 <merijn> What's the type of bar?
03:46:59 <mniip> that's the question I'm asking
03:47:41 <merijn> mniip: I don't see how anyone can answer that?
03:47:52 <mniip> ...
03:48:03 <merijn> Everything after that class definition does not parse as valid haskell
03:48:15 <mniip> yeah because it's not haskell
03:48:28 <mniip> it's just that I lack the forall symbol on my keyboard at the moment
03:48:54 <merijn> mniip: Right, so you're asking the type of an undefined function 'bar' defined in an expression that is not valid haskell?
03:49:05 <mniip> it's not defined D:
03:49:07 <merijn> s/defined in/used in
03:49:25 <mniip> you said you don't understand my explanation
03:49:25 <merijn> mniip: I don't understand what your question is supposed to be
03:49:35 <mniip> I switched from english to math language
03:50:07 <mniip> ok
03:50:12 <merijn> You seem to want a constraint that's based on another types constraint without applying it to any variables?
03:50:23 <mniip> imagine you use fundeps to imitate type-level functions
03:50:24 <merijn> Which I'm pretty sure is not possible
03:50:37 <mniip> class X a b | a -> b
03:50:39 <merijn> mniip: Why not just use type level functions?
03:50:49 <mniip> is a constraint that "takes" a type and "returns" a type
03:50:54 <merijn> If you want to use fundeps for this, my recommendation would be to learn prolog first
03:51:01 <mniip> I am familiar with prolog
03:51:06 <merijn> As type level programming with fundeps is basically prolog with crappy syntax
03:51:24 <mniip> I am aware
03:52:43 <merijn> In short: There's probably only a few hundred people that are good enough at this to tell you whether what you want is possible and if so how
03:53:10 <mniip> ok
04:06:17 <Jello_Raptor> anyone around? I'd like to pick people's brains on a design question. 
04:07:43 <Jello_Raptor> I've been contemplating making a make-like EDSL for haskell (for non-haskell projects, mainly LaTeX and embedded systems work) 
04:07:47 <Jello_Raptor> s/for/in/ 
04:11:06 * hackagebot cabal-helper 0.1.0.0 - Simple interface to Cabal's configuration state used by ghc-mod  http://hackage.haskell.org/package/cabal-helper-0.1.0.0 (DanielG)
04:13:09 <Jello_Raptor> I want to include a feature (like in tup) where all the commands use a FUSE filesystem to ensure dependencies are always regenerated, have some nice metaprogramming properties (like some of my rake files which examine C or Java code to automatically infer dependencies), and where I can run the thing as a deamon that will automatically regerate files when their dependancies have changed. (like, rake guard)  
04:17:20 <Jello_Raptor> I want it to be an EDSL so that I don't have to reinvent much of the wheel (typechecking / composability / etc) and so that one can compile a "makefile" into a standalone executable that doesn't require a full haskell stack to run
04:17:39 <aleator_> Jello_Raptor: Extend shake? It is already rather nice for that purpose.
04:19:07 <Jello_Raptor> aleator: cool, i didn't know this existed 
04:21:06 * hackagebot cabal-helper 0.1.0.1 - Simple interface to Cabal's configuration state used by ghc-mod  http://hackage.haskell.org/package/cabal-helper-0.1.0.1 (DanielG)
04:36:07 * hackagebot cabal-helper 0.2.0.0 - Simple interface to Cabal's configuration state used by ghc-mod  http://hackage.haskell.org/package/cabal-helper-0.2.0.0 (DanielG)
04:36:23 <merijn> Jello_Raptor: Also, I remember someone here (Peaker?) working on something like that
04:39:24 <aleator_> Suppose I have a library component that makes use of 'other-files' field in cabal (such as ekg-package). How am I supposed to distribute the resulting program? By shipping out the whole cabal sandbox? 
04:41:14 <Jello_Raptor> merijn: hmm, that's good to know i guess, i'll ask them. 
04:43:14 <Jello_Raptor> oh, while it's on my mind: is there some way to add compile time checks to a system? like the aforementioned build system having a check against multiple non-composable rules defined against the same file? 
04:43:38 <merijn> I don't know enough about shake, tbh
04:44:00 <merijn> Jello_Raptor: But depending on how much effort you're willing to put in the answer is "yes"
04:44:14 <merijn> Jello_Raptor: With Template Haskell you can run arbitrary verification code at compile time, so...
04:44:45 <aleator_> Jello_Raptor: Shake doesn't do that out-of-the-box. It would seem like a nice exercise to make a typed build system (like servant is a typed rest api)
04:44:59 <Jello_Raptor> merijn: good to know. I expect I'd be able to find a tutorial if i google around? 
04:46:30 <Jello_Raptor> aleator: yeah, I want some typing properties, though I still hve to work out the semantics to differentiate between builds that need to happen in a separate temp directory, and builds that need to happen in the normal filesystem. 
04:47:13 <merijn> Jello_Raptor: There's several TH tutorials around of varying quality and depth
04:47:26 <merijn> Jello_Raptor: But some googling should turn up something useful
04:47:47 <Jello_Raptor> aleator: err, by that i mean "yes Id like that, but there's a stack of issues around the type semantics i want/that'd actually be useful that I want to work out first" 
04:47:58 <Jello_Raptor> merijn: cool, I'll do that then 
05:04:01 <mrkkrp> Hello, profiling shows me that ~93% of time is spent on one line: `xs = zipWith (g . f) as [0..]' where `as' is calculated on previous line (takes 3.7 %), 0.5% is spent in `g', and 0.1% in `f'. My question: how is this possible?
05:06:18 <merijn> g and f might be really cheap and/or you never look at their results?
05:06:26 <merijn> How do you use xs?
05:06:50 <mrkkrp> xs is part of structure that is saved in file at the end
05:07:17 <merijn> What do f and g do?
05:07:43 <mrkkrp> it's not simple to explain without lots of details...
05:08:07 <mrkkrp> simply put, f takes some part of infinite list of integers
05:08:22 <mrkkrp> g builds from it some data structure
05:09:00 <mrkkrp> I've put {-# SCC "blah" #-} things into these functions and they are quite fast, it seems
05:09:38 <mrkkrp> perhaps `f' is cause of problem
05:10:20 <merijn> How long is as?
05:10:53 <mrkkrp> in my test it consists of one element :)
05:11:06 <merijn> ah...that is odd
05:11:15 <mrkkrp> I need to put more 'labels' into `f'
05:11:29 <mrkkrp> it's traverses infinite list
05:12:18 <mrkkrp> `n = maybe (length xs) length $ find ((>= t) . sum) (inits xs)' -- from `f'
05:12:25 <merijn> ick
05:12:29 <mrkkrp> I think the problem must be here
05:12:32 <merijn> length is slow
05:12:50 <mrkkrp> yeah, I didn't think about efficiency when I wrote this
05:13:01 <mrkkrp> let's test it..
05:13:07 <merijn> mrkkrp: Yeah, that function is pretty damn slow, I think
05:13:49 <merijn> It basically returns the first prefix of xs whose sum is greater than t, yeah?
05:13:54 <mrkkrp> yeah
05:14:23 <merijn> I think you're better of manually coding that, I expect it'll be much faster
05:14:47 <merijn> Wait, you only care how long the first prefix bigger than t is?
05:14:54 <mrkkrp> merijn: thanks, I think the main problem is solved now: I've found cause of inefficiency :)
05:15:01 <mrkkrp> yes
05:15:30 <mrkkrp> I could traverse it more efficiently, I know
05:15:42 <mrkkrp> It's not difficult, I can handle it, thanks!
05:15:48 <merijn> ok, good luck :)
05:16:08 * hackagebot objective 1.0.2 - Extensible objects  http://hackage.haskell.org/package/objective-1.0.2 (FumiakiKinoshita)
05:16:10 * hackagebot eternal 0.1.0 - everything breaking the Fairbairn threshold  http://hackage.haskell.org/package/eternal-0.1.0 (Heather)
05:18:49 <kgadek_> hi. I'm interested why TYB is not seeing any more updates? Why is that while it seems superior to uniplate/geniplate/SYB? // http://hackage.haskell.org/package/TYB
05:49:41 <halvorg> Hey, am I right in understanding that Scotty does not support named query parameters?
05:50:11 <halvorg> eg. /?param1=v1&param2=v2
05:50:29 <clrnd> halvorg, those are in the GET request
05:50:40 <halvorg> what do you mean?
05:50:51 <tdammers> example.org/foo?bar=baz
05:51:02 <tdammers> foo is in the PATH, bar is in the GET parameters
05:51:27 <tdammers> scotty does some magic for PATH, but GET is pretty much just provided as-is
05:52:23 <clrnd> in any case, Scotty.param looks for the key in the capture, POST data and GET params
05:52:28 <halvorg> I'm not sure I understand. Do I need to specify the route: get "foo/:params" and unpack it myself?
05:52:57 <tdammers> not really, no
05:53:04 <tdammers> in your route, you can match on parts of the path
05:53:14 <tdammers> scotty maps those to request parameters
05:53:31 <tdammers> so if you say foo/:param, then foo/bar will populate "param" with "bar"
05:54:12 <tdammers> but for things in GET, i.e., the stuff after the ?, you don't need any explicit matching in the route
05:54:20 <halvorg> ah
05:54:49 <halvorg> So I fetch the WAI Request and find em through that?
05:56:45 <tdammers> halvorg: no. http://hackage.haskell.org/package/scotty-0.9.1/docs/Web-Scotty.html#g:4
05:57:10 <tdammers> the "param" function does all the heavy lifting for you
05:57:33 <tdammers> if a bound path component of the given name exist, you'll get that, otherwise the query param (i.e., GET value)
05:57:52 <halvorg> I see, thanks for the help!
05:57:59 <tdammers> actually, it's captures, then POST, then GET
05:58:28 <tdammers> but if you need more control, you can indeed go through the WAI request
05:59:08 <merijn> kgadek_: Simple answer: Probably because the original authors are no longer getting paid to work on it
06:16:00 <Profpatsch> @pl \x y -> putStrLn $ show x ++ show y
06:16:00 <lambdabot> (putStrLn .) . (. show) . (++) . show
06:17:19 <Profpatsch> (a -> b) -> (c -> b) -> a -> c -> b would be quite something.
06:18:13 <merijn> Profpatsch: Needs at least a monoid constraint on b
06:22:24 <Profpatsch> merijn: Of course, right.
06:22:42 <Profpatsch> (++) <-> (<>)
06:24:41 <crispweed> hi
06:24:59 <crispweed> how come:
06:25:24 <crispweed> Prelude> let f arr = (map show) arr
06:25:47 <crispweed> Prelude> :t f f :: Show a => [a] -> [String]
06:26:00 <crispweed> but
06:26:28 <crispweed> Prelude> let f2 = map show
06:26:36 <crispweed> Prelude> :t f2
06:26:43 <crispweed> f2 :: [()] -> [String]
06:26:51 <crispweed> and then:
06:27:00 <clrnd> :t map show
06:27:01 <lambdabot> Show a => [a] -> [String]
06:27:22 <crispweed> Prelude> f [1,2,4]
06:27:27 <aawe> crispweed: https://wiki.haskell.org/Monomorphism_restriction
06:27:41 <crispweed> ["1","2","4"]
06:28:10 <crispweed> ok, cheers!
06:28:49 <merijn> Actually that's not true
06:28:59 <merijn> Especially since the monomorphism restriction is no longer on in ghci
06:29:04 <merijn> The problem is extended defaulting
06:29:52 <merijn> (Unless you have an old ghci)
06:30:12 <crispweed> GHCi, version 7.6.3
06:30:44 <crispweed> yeah, just read: The restriction is turned on by default in compiled modules, and turned off by default at the GHCi prompt (since GHC 7.8.1)
06:33:47 <crispweed> and then, it's fixed by: Prelude> :set -XNoMonomorphismRestriction by the looks of things..
06:36:08 <aawe> crispweed: you can add that to your .ghci
06:36:25 <crispweed> ok, thanks, will do
06:49:14 <remdezx> Hello! Is there a general way to convert `Foo a` to `Foo b` using (a -> b) function? Can I do it using uniplate or some other library?
06:49:39 <EvanR> fmap :: Functor f => (a -> b) -> f a -> f b
06:49:42 <EvanR> f = Foo
06:49:51 <tdammers> ^ that
06:50:14 <merijn> Assuming Foo is a Functor, of course
06:50:43 <remdezx> unfortunately Foo is not a functor...
06:50:43 <tdammers> if (a -> b) -> (Foo a -> Foo b) is defined, then Foo is a functor :D
06:50:49 <EvanR> s/uniplate/functor deriving/
06:51:03 <merijn> tdammers: Not true
06:51:17 <tdammers> merijn: case matters?
06:51:32 <EvanR> remdezx: you might be able to implement it for your type
06:51:36 <merijn> If "f :: (a -> b) -> (Foo a -> Foo b)" is defined AND "f id == id" THEN it's a functor
06:51:43 <Freundlich> Functor has to fulfill certain laws.
06:51:43 <tdammers> oh right
06:51:44 <remdezx> it is laready a functor but on other parameter
06:51:46 <tdammers> oops
06:51:57 <remdezx> this Foo is much complicated Type with much more arguments
06:52:09 <EvanR> there newtyping
06:53:15 <remdezx> Foo use also other types, which have `a` argument, do I need to newtype all, and make them functors? There is no easier way?
06:57:46 <Cale> remdezx: In general it might even be impossible to do
06:58:06 <Cale> remdezx: For example, consider  data Foo a = F (a -> Bool)
06:59:19 <remdezx> Cale: I see... thanks for explaining that!
06:59:57 <Cale> Of course, where it is possible to do, it's probably good to implement those fmap-like functions
07:00:22 <EvanR> i have a question about contrafunctor. i have a type Foo a b, and Foo a is a functor. and i think "Foo _ b" is a contrafunctor, but is there a way to define this instance like that?
07:00:32 <Cale> (even if you can't write a proper instance of Functor for any more than one of them)
07:00:57 <EvanR> i guess i need a newtype
07:01:02 <Cale> yeah, you need a newtype
07:01:10 <Cale> Or you write an instance of Profunctor
07:01:18 <EvanR> oh...
07:01:44 <meretrix> I have one thread that is receiving many events (~10K per second). In another thread, I want to batch up all of the events received in the last second and write them out to a socket once per second.  What's a good data structure for this "cache"?
07:04:23 <Cale> meretrix: Hmmm...
07:05:08 <mroman> dupChan?
07:05:29 <Cale> meretrix: Would a simple Chan do? Perhaps Chan (UTCTime, a) ?
07:05:46 <f-a> has anyone here have hoogle installed locally?
07:06:05 <f-a> I would like to make a simple search like "[a] -> a", but the results aren't matching
07:06:31 <tomjaguarpaw> bitraten: Not yet
07:06:33 <meretrix> Yeah, I guess that's all I need.
07:06:44 <f-a> like, ./hoogle search "[Int] -> String" finds a throng of sigs, including Prelude (^^) :: (Fractional a, Integral b) => a -> b -> a
07:14:10 <jfent> Does anyone use vim with syntastic and hdevtools? Got an issue I can't figure out
07:16:29 <merijn> jfent: Yes and the latest hackage version of hdevtools doesn't work with 7.8 and/or sandboxes
07:17:12 <jfent> merijn: Would that explain why I get 'not an editor command' when I try to run :HdevtoolsType?
07:17:28 <merijn> jfent: Ah, that's probably a different issue
07:18:02 <merijn> jfent: Namely, there's syntastic (an error highlighter that can use hdevtools), hdevtools (the haskell program) and hdevtools-vim (the vim plugin for hdevtools)
07:18:06 <merijn> That command is from the latter
07:18:18 <merijn> So if you only have the program and syntastic that's not going to work
07:18:24 <jfent> merijn: Ahh, so I should install hdevtools-vim
07:18:52 <merijn> jfent: Incidentally, I cloned the hdevtools repo and merged some outstanding pull requests making it work with sandbox support here: https://github.com/merijn/hdevtools
07:19:03 <bitraten> tomjaguarpaw: Okay, would really like to see it. It's the only thing keeping me at postgresql-simple
07:19:27 <merijn> Although that repo is not really maintained beyond "hey, hdevtools broke for me", so don't rely on it too much :p
07:19:53 <jfent> merijn: haha fair enough
07:19:56 * merijn can't wait for ghci-ng to be more usable
07:23:58 <quchen2> merijn: What's that?
07:23:59 <akegalj_> can anybody help me unerstand why "sum . elems . runSTUArray $ do ..." complains with http://lpaste.net/5277016228269916160  while "sum . elems $ runSTUArray $ do" works just fine?
07:24:11 <jfent> merijn: Would you happen to also know what plugin defines the GHC_BrowseAll andGHC_ShowType commands?
07:24:17 <ASau> Hi!
07:24:21 <quchen2> akegalj_: Infix "$" has special magic in it
07:24:36 <quchen2> akegalj_: It's a problen with ST being a rank-2 type
07:24:45 <akegalj_> quchen2: oh, ok then
07:24:48 <akegalj_> thnx
07:25:00 <ASau> Is there some (more or less common) name for monadic sequencing, only the one that returns 2-tuples instead of lists?
07:26:14 * hackagebot syntactic 1.15 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-1.15 (AndersPersson)
07:26:47 <quchen2> :t \(a,b) -> liftA2 (,) a b -- ASau, like this?
07:26:48 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
07:28:35 <ASau> quchen2: \(ma, mb) = ma >>= (\va -> mb >>= (\vb -> return (va, vb)))
07:28:48 <ASau> (Hopefully, I got Haskell syntax correct.)
07:28:54 <quchen2> That's equivalent to what I wrote.
07:29:30 <ASau> Alright, is there a name for it?
07:29:41 <quchen2> liftA2 :-P
07:29:42 <Ferdirand> Hello #haskell, is it possible to write an operation that does something like (MonadTrans t, Monad m) => (m a -> m b) -> t m a -> t m b ?
07:30:21 <ASau> Thus, there isn't.
07:30:23 <ASau> Alright.
07:30:56 <quchen2> ASau: It's part of an alternative definition for Applicative, sometimes named (**).
07:31:14 * hackagebot force-layout 0.3.0.10 - Simple force-directed layout  http://hackage.haskell.org/package/force-layout-0.3.0.10 (BrentYorgey)
07:31:39 <ASau> quchen2: is there some reference to look at them?
07:31:57 <quchen2> ASau: Typeclassopedia mentions that construction, I think
07:32:08 <quchen2> You have (**) :: f a -> f b -> f (a,b), and unit :: f ()
07:32:26 <quchen2> And you can express pure/<*> in terms of those, and vice versa
07:32:57 <mniip> Ferdirand, sounds an awful lot like fmap to me
07:33:54 <Ferdirand> mniip: well I agree yes
07:34:04 <merijn> quchen2: ghci-ng is Chris Done's project to extend ghci with the required commands (type query, compilation, location jumping, etc.) to replace ghc-mod/hdevtools
07:34:19 <Ferdirand> but monad transformers aren't functors, they have the wrong kind, right ?
07:34:36 <mniip> oh
07:34:37 <mniip> right
07:34:57 <mniip> fmap would be (m a -> m b) -> t (m a) -> t (m b)
07:35:09 <merijn> quchen2: The advantage being that, being build into ghci it can ship with ghc and doesn't rely on linking with cabal (like ghc-mod/hdevtools) you can simply use it from cabal repl to get sandbox aware versions of those commands without depending on cabal, resolving this "doesn't work with my current ghc" issue you can run into
07:35:15 <govind_> Hi, a haskell beginner here.
07:35:30 <merijn> Ferdirand: You probably want the mmorph library
07:35:42 <merijn> @hackage mmorph
07:35:42 <lambdabot> http://hackage.haskell.org/package/mmorph
07:35:47 <govind_> How do I add a dependency to a local package in cabal? 
07:37:00 <quchen2> merijn: Oh, it's like a GHCi that's easier to interface from outside programs.
07:37:09 <merijn> quchen2: Right
07:37:16 <Ferdirand> merijn: thanks. I'm trying to define my first real-serious-custom monad, and these issues are puzzling
07:37:22 <merijn> Ferdirand: Actually, what you have isn't quite a monad morphism, I guess
07:37:42 <exio4> @type \f g -> (lift.f.) =<< g -- something like would do it, wouldn't it?
07:37:42 <lambdabot>     The operator ‘.’ [infixr 9] of a section
07:37:42 <lambdabot>         must have lower precedence than that of the operand,
07:37:42 <lambdabot>           namely ‘.’ [infixr 9]
07:37:48 <quchen2> mmorph is more about mapping over the functor/monad part, unfortunately.
07:37:50 <exio4> @type \f g -> (lift.f) =<< g -- something like would do it, wouldn't it?
07:37:51 <lambdabot> (MonadTrans t, Monad (t m), Monad m) => (a -> m b) -> t m a -> t m b
07:38:22 <merijn> exio4: Wrong type
07:38:33 <merijn> That's "a -> m b" not "m a -> m b"
07:38:42 <quchen2> Now all we need is Monad m => m a -> a and we're done! Should be easy.
07:38:47 <quchen2> :-|
07:38:53 <exio4> yeah, just saw, *adds a return in shame* :P 
07:38:54 <barrucadu> govind_: The same way you add a dependency to a remtoe package. If you're also using sandboxes you can tell it where to find the dependency with `cabal sandbox add-source`
07:39:19 <merijn> Well, I guess you could do
07:39:29 <exio4> @type \f g -> (lift.f.return) =<< g 
07:39:30 <lambdabot> (MonadTrans t, Monad (t m), Monad m1, Monad m) => (m1 a -> m b) -> t m a -> t m b
07:39:38 <merijn> Yeah, that
07:40:11 * Ferdirand 's head explodes
07:40:14 <Ferdirand> okay well
07:40:33 <Ferdirand> i tried writing that for some time and couldn't figure out how to tie the type knots
07:40:41 <govind_> @barrucadu: Oh, Thanks! 
07:40:41 <lambdabot> Unknown command, try @list
07:40:45 <merijn> Ferdirand: >>= to get 'a' out of 't m a', return to push it back in, 'f' to apply your function, 'lift' to return the result to 't m b'
07:41:06 <merijn> push it back into 'm a', I mean
07:41:15 <Ferdirand> right, but how comes return has the right type here
07:41:55 <Ferdirand> my intuition says this would require t to be a monad
07:41:58 <Ferdirand> obviously it is wrong
07:42:08 <Ferdirand> well thanks a lot
07:42:18 <merijn> It requires 't m' to be a monad
07:42:18 <Ferdirand> i'll check that on paper
07:42:28 <merijn> Ferdirand: See the second constraint mentioned by lambdabot
07:42:36 <merijn> Ferdirand: "Monad (t m)"
07:42:46 <Ferdirand> but
07:42:57 <Ferdirand> what's the specific type of the return in that s
07:43:07 <Ferdirand> oooh right =<< g
07:43:07 <merijn> "a -> m a"
07:43:14 <merijn> Ferdirand: Exactly :)
07:43:34 <Ferdirand> aaah nasty
07:43:46 <merijn> Why's that nasty?
07:43:53 <Ferdirand> well now i'm wondering if my monad breaks the monad laws
07:43:57 <merijn> (I mean, the implementation isn't very pretty)
07:44:15 <merijn> Ferdirand: None of that code violates the monad laws
07:44:19 <Ferdirand> right
07:44:25 <Ferdirand> but if the result is not what i want
07:44:32 <Ferdirand> maybe it's because my monad isn't truly one
07:44:36 <merijn> However, if you're "m a" is supposed to be run multiple times it may not be what you want
07:45:15 <merijn> Ferdirand: Well, suppose you want "m a" to be "getLine :: IO String", but in this case we have "FooT IO String" then it is slightly different
07:45:53 <merijn> Because the lift.f.return basically performs getLine ones and gives the result to 'f', so if 'f' executes the IO String multiple times it gets the same one value every time
07:47:06 <tenniscp25> Does Monad have anything like Applicative has Alternative?
07:47:17 <merijn> tenniscp25: MonadZero and MonadPlus
07:47:51 <tenniscp25> Thanks
07:47:55 <merijn> MonadZero has mzero :: MonadZero m => m a and MonadPlus has "mplus :: MonadPlus m => m a -> m a -> m a"
07:48:17 <ASau> quchen2: is there some short explanation why Applicative is better than Monad, when and why?
07:48:18 <jfent> merijn: Would you happen to also know what plugin defines the GHC_BrowseAll and GHC_ShowType commands?
07:48:18 <merijn> Witht he obvious laws "mzero `mplus` x = x" "x `mplus` mzero = x"
07:48:26 <merijn> jfent: No idea, sorry
07:48:40 <quchen2> ASau: All Monads are (morally) also Applicative.
07:48:45 <merijn> ASau: Applicative is more general, i.e. more things are Applicative than are Monad
07:49:09 <merijn> And some operations can be implemented more efficiently using Applicatives than Monad (google ApplicativeDo for examples)
07:49:12 <quchen2> ASau: The hierarchy is Functor => Applicative => Monad, and this will actually be implemented in GHC 7.10.
07:49:23 <quchen2> Right now we have Functor => Applicative  ...  and Monad alone.
07:50:19 <quchen2> ASau: In other words, whenever you could use Applicative, you probably should. The exception is if you want to use "do" notation, then you have no choice but to take Monad.
07:52:02 <ASau> This means that you cannot build bind in Applicative.
07:52:13 <ASau> I wonder how they introduce parsing combinators then.
07:53:05 <quchen2> You only need bind in parsers if you want to react differently depending on past parsed elements.
07:53:30 <quchen2> Parsing a string and an int and putting the results in a tuple doesn't require inspecting how the int or the string look like, so you can use Applicative.
07:53:42 <enthropy> :t (<|>)
07:53:42 <lambdabot> Alternative f => f a -> f a -> f a
07:53:47 <quchen2> liftA2 (,) parseInt parseString :: Parser (Int, String)
07:54:05 <tdammers> Foobar <$> stringParser <*> intParser -- very nice
07:54:43 <ASau> How is it expressed in canonical words?
07:54:53 <ASau> Do you mean that I cannot have inherited attributes?
07:55:14 <ASau> Or what?..
07:55:20 <merijn> ASau: With applicatives you cannot have branching dependent on previous results
07:55:43 <ski> (inherited attributes as in attribute grammars ?)
07:55:48 <ASau> Yes.
07:56:30 <merijn> ASau: Look at "(>>=) :: Monad m => m a -> (a -> m b) -> m b", now imagine my function "\x -> if even x then foo else bar" <- here which "m b" gets executed (foo or bar) depends on 'x', i.e. the result of the "m a" operation
07:56:34 <ski> i suppose you'd just go `Parser (Inherited -> Synthesized)' .. or do it as a separate pass on the parse tree
07:57:17 <merijn> If we look at "(<*>) :: Applicative f => f (a -> b) -> f a -> f b" <- here there is no guarantee that my function 'f' will get applied to 'a'
07:57:49 <merijn> ASau: Or rather the "side-effects/actions" of the result 'f b' cannot depend on the result of inspecting 'a'
07:58:07 <merijn> Since the function is merely 'a -> b' it has no influence on which side-effects happen
07:58:24 <merijn> Whereas in "a -> m b" the function DOES have influence on which side-effects happen
07:59:25 <merijn> This is what we mean by Applicative's not being able to inspect previous results. You can inspect them, but they cannot influence which future side-effects will run.
07:59:50 <merijn> This is what makes Monad "more powerful" than Applicative
08:01:39 <ASau> Alright, this sounds more like context sensitivity now.
08:02:31 <ASau> Alright.
08:02:32 <ASau> Thank you!
08:02:42 * ASau withdraws to reading.
08:22:19 <frerich> Hi! I am (well: I think I am) well aware of what it means for Haskell to be pure and lazy. However, I recently saw http://www.seas.upenn.edu/~cis194/spring13/lectures/08-IO.html (a supposedly very nice introduction to IO with Haskell) which starts with 'Remember that Haskell is lazy and therefore pure.'. I don't see any causality between non-strictness and purity at all, or is there? Or maybe I'm misreading 'therefore'?
08:22:30 <frerich> I thought 'therefore' means something like 'and that's why'
08:24:31 <geekosaur> I would call that very badly phrased (the page, that is); I understand "therefore" roughly the same way you do
08:24:45 <geekosaur> laziness does not ensure purity; it does help *enable* it
08:25:01 <merijn> Well
08:25:23 <merijn> If you read the history of haskell one of the main reasons there was no compromising the purity of Haskell was lazy evaluation
08:25:36 <merijn> Mixing laziness + side-effects leads to completely confusing program behaviour
08:25:39 <geekosaur> yes, that agrees with what I just said
08:25:57 <merijn> Therefore, one of the driving motivations for making haskell pure was the decision to make haskell lazy
08:26:48 <merijn> frerich: But yeah, that sentence is badly motivated there
08:26:49 <juanpablo_> I'm developing a Snap app and I have an environment variable that should be read at app startup and fail if it's not there. However, it's only getting evaluated much later because of laziness I think. How can I force evaluation?
08:27:13 <clrnd> juanpablo_, lookup `seq`
08:27:21 <merijn> That's the wrong answer to the wrong problem
08:27:30 <merijn> It cannot be evaluated later due to laziness
08:27:32 <Cale> Yeah, that can't be the case
08:27:38 <Cale> IO actions are executed in order
08:27:41 <merijn> Because reading an environment variable is an IO action
08:27:43 <clrnd> oh yeah, it's IO
08:27:47 <merijn> and IO evaluation is not lazy
08:27:53 <Cale> Evaluation has nothing to do with the order in which IO actions are executed
08:28:04 <merijn> s/IO evaluation/IO execution
08:28:04 <Cale> and so in particular, neither does lazy evaluation
08:28:05 <merijn> Anyway
08:28:25 <merijn> There's two options: 1) you're using unsafePerformIO or 2) something else is going wrong
08:28:32 <merijn> In case of 1
08:28:39 <merijn> @quote is.not.a.bug
08:28:39 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
08:28:40 <juanpablo_> Oh then it might be because I'm doing it during snaplet initialization and not app initialization
08:28:59 <juanpablo_> Not using unsafePerformIO
08:29:15 <merijn> juanpablo_: Right, then there's most likely some other problem hidden somewhere
08:29:36 <juanpablo_> I think Snaplets aren't initialized at app startup or something like that
08:29:46 <merijn> snaplet vs app initialization sounds like a likely candidate (tbh, I don't know snap)
08:30:34 <juanpaucar> i'm using snap and i don't know where a function is being imported from and hayoo or hoogle can't find it
08:30:38 <juanpablo_> I'm going to put the env lookup in main instead. That was I'm sure it will evaluate at startup
08:31:35 <merijn> juanpablo_: FYI, if you go to hackage/local docs for snap there should be an "index" link in the top right
08:31:47 <merijn> juanpablo_: That has an alphabetical list of all exported functions/types/etc.
08:36:27 <clrnd> two juans with snap problems, oh my
08:38:06 <bitonic> edwardk: I have a parser defined only with combinators from `parsers`, and I have an input for which it fails with parsec but works with trifecta.  are such differences considered bugs, or is it to be expected?
08:38:33 <bitonic> (and by the way, I think trifecta is "right")
08:49:24 <ahammel> There's no way to redirect the output of Debug.trace to stdout, is there?
08:49:48 <EvanR> you can redirect stderr to stdout
08:49:56 <tdammers> why would you do that, though?
08:50:11 <tdammers> Debug.trace is basically a debugging hack
08:50:52 <ahammel> tdaammers: because I wan't to reserve stderr for logging statements
08:51:02 <ahammel> and the existing code base has a bunch of trace in it
08:51:11 <ahammel> (which is not my fault)
08:51:19 <EvanR> debug trace isnt for logging
08:51:38 <ahammel> EvanR: indeed
08:51:43 <mauke^> just remove all traces
08:51:51 <EvanR> refactor mercilessly
08:52:15 <juanpablo_> clrnd: both juans have fixed their respective issues now :)
08:52:17 <ahammel> mauke^: yes, much better idea
08:52:42 <juanpablo_> and yeah, problem wasn't laziness. Just initializing in the wrong place
08:53:27 <juanpablo_> Does anyone know what happened to Neil Mitchell's catch? That's something I'd really like to use
08:56:22 <merijn> juanpablo_: What is it?
08:56:51 <juanpablo_> merijn: catch? AFAIK it checks for partial functions in your code
08:57:13 <merijn> juanpablo_: -Wall should already warn you about those
08:57:34 <juanpablo_> merijn: but not uses of fromJust, fromRight, head, etc
08:57:37 <juanpablo_> and other partial functions
09:08:58 <ocharles_> Has anyone here used the webdriver library?
09:09:34 <ocharles_> I must be doing something wrong, because I can't seem to get `waitUntil (findElem (ByCss ".btn-default"))` to actually retry :(
09:11:50 <enthropy> > f x :: Expr
09:11:51 <lambdabot>  f x
09:11:54 <enthropy> what library defines those?
09:12:07 <edwardk> bitonic: parsec has a few places where its semantics are buggy. =(
09:12:17 <f-a> Parsec, enthropy 
09:12:21 <ocharles_> enthropy: simple-reflection, I think
09:12:38 <enthropy> ocharles_: thanks!
09:12:57 <bitonic> edwardk: do you have examples?  so that maybe I can recognize my problem
09:12:59 <ocharles_> http://hackage.haskell.org/package/simple-reflect even
09:13:05 <enthropy> f-a: I can't find them in parsec
09:13:21 <edwardk> bitonic: not off hand, i remember fixing a couple of cases when working on trifecta though
09:13:52 <edwardk> https://github.com/ekmett/trifecta/issues/28  talks about one difference
09:13:52 <bitonic> edwardk: OK.  but what you're saying is that if a parser written with `parsers` is misbehaving with parsec only, it's probably not my fault :P
09:14:01 <edwardk> quite probably
09:14:14 <edwardk> it'd love a filed issue on the topic though, to make it easier to tell what is going on
09:14:27 <edwardk> and to see if we want to change the semantics of the parsers parsec instance to make it work better
09:14:55 <bitonic> edwardk: yeah I'll probably investigate more anyway, I'd like to know why parsec is not working
09:15:03 <bitonic> the parser is quite big though -- C99 expressions
09:15:12 <bitonic> so it might take a while... sigh.
09:15:15 <f-a> edwardk: my bad , it is a module name (Text.Parsec.Expr0
09:15:21 <f-a> *)
09:15:49 <bernalex> edwardk: watched type classes against the world & Stop Treading Water today. a bit sick, so doing "research" instead of hacking atm.
09:16:17 <JoshieAS> what's the best way to access a data field from a custom data type that is not made in record syntax?
09:16:28 <bernalex> edwardk: the former talk was rather inspiring. you keep driving home the point for me, that the dumber the data the better. :-]
09:16:47 <bergmark> JoshieAS: pattern matching is your only option
09:17:01 <edwardk> bernalex: =)
09:17:07 <bergmark> but you can of course make functions to access it
09:18:15 <JoshieAS> so if I have datatype Dookie | NotDookie Thing Thing1 Thing2
09:18:25 <JoshieAS> and I want to get Thing1
09:18:37 <ski> pattern matching ?
09:18:41 <bitonic> edwardk: BTW, thanks a lot for `parsers` -- it's very useful
09:18:43 <bernalex> edwardk: btw if you [or anyone else in this chan for that matter] at any point would have a couple of minutes, it would be terribly useful if you could look over the slides for my talk at the Norwegian haskell users group! it's about functor/applicative/monad/foldable/traversable. (the previous talk was typeclasses.)
09:19:24 <f-a> bernalex: to review them?
09:20:01 <bernalex> f-a: "review" is a bit strong. comments are always useful. :-]
09:20:31 <ski> bernalex : .. apropos `Foldable', did you see <http://comonad.com/reader/2015/free-monoids-in-haskell/> ?
09:20:54 <bernalex> ski: could you repost w/o <>s so that my client understands that it's an URL? :-]
09:21:13 <f-a> bernalex: yeah I mean, I am not at all expert to use an euphemism, but I will gladly comment if you share  a link
09:22:01 <bernalex> f-a: let me export a pdf of the latest version & I'll give you a link :-]
09:22:25 <f-a> okie!
09:22:25 <ski> bernalex : i'd say your client is broken :)
09:22:36 <bernalex> ski: I'd agree. :-]
09:22:55 <bernalex> f-a: https://secure.plaimi.net/~alexander/tmp/pres.pdf
09:22:58 <edwardk> bernalex: sure. kinda busy at this exact moment, but shoot me an email and i'll take a look
09:23:11 <bernalex> edwardk: the link is ^ -- do you want it on an email still?
09:23:56 <edwardk> bernalex: you might want to start with the Semigroup/Monoid material before upgrading to Applicative and Monad and the like
09:24:24 <edwardk> that way you can talk through polymorphism on * with a few examples before getting to * -> *
09:24:25 <bernalex> edwardk: that's true I guess
09:24:33 <mattshirt> Hello, there. I'm just getting started with Haskell I'm from a python background. I wanted to know how you would describe functional programming to a layman.
09:25:23 <bernalex> edwardk: I only threw them in mid-way through authoring the presentation when I suddenly remembered that Foldable needs Monoid. but, of course, it makes sense to do what you propose.
09:25:53 <bernalex> mattshirt: I wouldn't. they don't know programming.
09:26:07 <edwardk> anyways that is the main suggestion i have offhand without getting bogged down into individual slides
09:26:18 <bernalex> edwardk: ta!
09:30:32 <platz> mattshirt: define layman
09:31:38 <ski> mattshirt : i suppose you could say something like : programming with (immutable) values and expressions, reasoning "mathematically" about them (iow by "equational reasoning", "replacing equals for equals"). commonly passing functions as arguments ("callbacks") and returning them as results ("closures","objects")
09:32:27 <voidzero> kind of like proof-based programming
09:32:31 <voidzero> if that's the correct term
09:32:39 <ski> voidzero : which ?
09:32:44 <voidzero> Haskell. 
09:33:33 <voidzero> Usually, what helps me to get people to say "ah.." is, with Haskell, you get compile errors, where with many imperative languages, those errors will only show up at runtime.
09:34:02 <bernalex> "functional programming" is not any more useful terminology than "rock music". rock bands are in and of themselves very different. a reggae band can play rock music, and some rock bands have more things in common with some reggae bands than with other rock bands. etc.
09:34:04 <ski> well, it's far easier to do proofs about programs that doesn't use mutation .. but i'm not sure i would characterize Haskell in general as being about "proof-based programming" -- emphasizing (more) being able to reason (informally or formally) about programs, yes ..
09:34:09 <EvanR> in my experience people hate compile time errors
09:34:12 <voidzero> try to do ( 12 + "34foobar" ) in Perl, Python, Haskell. Haskell's compiler will reject it.
09:34:43 <bernalex> voidzero: that's just strong typing. python will reject that too.
09:34:46 <ski> voidzero : yes, but some functional programming languages (Scheme,Erlang) have no static type system
09:34:52 <voidzero> I'm a layman for life, but that's one of the things I'd want to know about Haskell.
09:34:57 <zomg> voidzero: python's will reject it too, actually
09:35:20 <voidzero> Perl will give you 46 :P
09:35:42 * ski thinks voidzero was here talking about when the checking takes place (at compile-time or run-time), not about whether it gets done at all
09:35:51 <voidzero> yes
09:36:01 <zomg> yeah, python would complain but only at runtime
09:36:12 <voidzero> I'd much rather have my compiler reject my code
09:36:14 <zomg> which is certainly a point in favor of Haskell
09:36:21 <bernalex> I don't think static weak typing is all that much cooler than dynamic weak typing.
09:36:27 <voidzero> but EvanR's experience trumps my gut instinct. :)
09:37:09 <EvanR> ...
09:37:34 <bernalex> static typing is the by far most effective (considering how cheap it is) formal verification method we have, really.
09:37:35 <EvanR> optimistic outlook trumps armchair quarterbacking
09:37:36 <voidzero> EvanR, I mean, I'm just an unemployed autodidact, so my opinions aren't that solid most of the time.
09:38:12 <ski> bernalex : will you explain "term level" ?
09:38:22 <ab9rf> EvanR: but outlook is rarely optomistic, have you actually used it? :)
09:38:24 <bernalex> ski: yes
09:38:30 <voidzero> But I thought it was worth mentioning the compile-time rejection versus run-time rejection.
09:38:49 <ab9rf> runtime type errors are mostly useless
09:39:07 <bernalex> ski: I tend to talk a lot, and only have bullets as vague guidelines. some like this, some dislike it, heh.
09:39:12 <voidzero> I mean with other (imperative) languages.
09:39:18 <ab9rf> true, they bar some misoperation errors that lead to incorrect rsults, but it still results in code that fails.
09:39:33 <ab9rf> better to catch those at compile time so that defective code doesn't et deployed in thef rist place
09:39:40 <zomg> Having to deal with a codebase which was built kinda shoddily and where we've had tons of bugs, in the clientside level (javascript..), on the backend (javascript..) and in the database (mongodb..)
09:39:48 <zomg> really makes you appreciate haskell... and doing a proper job
09:39:49 <zomg> :P
09:39:50 <ski> bernalex : i'd say that `*' describes/classifies the "concrete types", iow the types that are capable of having values (as opposed to e.g. `Either :: * -> * -> *' and `[] :: * -> *' .. you can't have a "list of" value, it must be a list of *something*) -- but that's just me
09:39:53 <ab9rf> zomg: heh
09:40:18 <zomg> I like working with JS, but it takes some discipline to do a good job with it.. and ideally, TDD
09:40:21 <bernalex> ski: that was pretty much what I was going to *say*, yes. :-]
09:40:45 <zomg> many of those bugs were caused by implicit type conversions
09:40:47 <ab9rf> "list of anything" means you can't assign a meaningful type to head
09:40:58 <zomg> even in the database we have something like numbers stored as strings.. which then cause bugs
09:41:04 <ab9rf> zomg: i *hate* implicit type conversions, regardless of the language they're in
09:41:07 <ski> bernalex : sometimes we say that the polymorphism that we get in Haskell with type classes is (type class) constrained polymorphism, and that this is a way to get the most useful aspects of "ad-hoc polymorphism"
09:41:31 <bernalex> ski: yes I don't say that typeclasses are ad-hoc polymorphism, but rather that it "solves" it.
09:41:35 <ab9rf> zomg: the worst i've seen for this is PHP but just about every language i've used has implicit type conversion behaviors that are irritating and counterintuitive
09:41:52 <zomg> ab9rf: yeah, I try to make sure all the data is converted at the "edges" of sorts. Eg. if you read input, that's an "edge" and the code there MUST make sure the data it passes along is correct
09:42:07 <bernalex> ski: typeclasses are more than merely ad-hoc polymorphism. not sure how much I want to cover that aspect though. I'll make a note of your feedback & think more about it.
09:42:37 <ab9rf> zomg: pushing input validation and assertion checks to the boundary allows for purer code internally
09:42:44 <ski> bernalex : opposed to that, one could say that types classified by kinds of the shape `... -> ...' are "incomplete", in the sense that you need to supply some more information, to get a concrete/complete type. like "either a string or a list of pairs of strings and integers"
09:42:51 <ski> bernalex : *nod*
09:43:25 <bernalex> ski: hm. that's an interesting way of putting it. noting that too in my TODO doc.
09:43:26 <zomg> ab9rf: Yeah that's pretty much the idea. In a sense, it's pretty much like having IO functions :) Ideally the code that doesn't directly deal with the outside should not need to concern itself with the data being in the expected format when they get called
09:43:30 <ab9rf> zomg: you reject errors sooner, have more clearly defined API contracts, and having a purer core code body increases the ability of the compiler and runtime to optimize
09:43:33 <ski> bernalex : mostly i just wanted to mention the term "(type class) constrained polymorphism", in case you hadn't heard it before :)
09:44:23 <bernalex> ski: yeah, I have. I think it's on wikipedia even. I'm just not sure how much I want to mention it in the lecture.
09:44:26 <ski> bernalex : people familiar with arrays in C,C++,Java,C# should understand the difference between "array of" and "array of integers"
09:44:37 <ski> bernalex : *nod*
09:45:05 <bernalex> ski: yeah that's a way of putting it I could consider. no clue what the background of these people are... I think mostly java? so that's probably a useful example.
09:45:39 <bernalex> ski: not going to bite into the whole "typeclasses are not like classes but they're a bit like interfaces" pie though I think.
09:45:42 <ski> i'm not sure i like the "* -> * polymorphism" title -- how do you pronounce that ?
09:45:49 <ski> bernalex : *nod*
09:45:56 <bernalex> ski: I usually say 'star arrow star'
09:46:06 <ab9rf> bernalex: i think most java and C++ programmers will try to use typeclasses to impement classes and then get stuck when it doesn't work
09:46:30 <hodapp> ab9rf: plot twist: when they use real classes in C++ and Java, it doesn't really work either
09:46:34 <bernalex> ab9rf: I think we will prevent this with the example code we have, and the exercises we have made. :-]
09:46:45 <ab9rf> hodapp: yes, but they don't admit that :)
09:46:55 <ab9rf> bernalex: good luck with that
09:47:17 <bernalex> ab9rf: thanks :p
09:47:28 <bernalex> ab9rf: I'll let you know if I fail and end up having to talk about interfaces. ;)
09:48:02 <ab9rf> bernalex: it's especially hard when you're dealing with people who are trying to use a broken understanding of Java/C++ classes to understand typeclasses :)
09:48:12 <ski> bernalex : one example could be `type Tree ref a = ref (TreeNode ref a); data TreeNode ref a = Empty | Node (Tree ref a) a (Tree ref a)' (or just single-linked lists, if you want it simpler)
09:48:32 <ab9rf> a lot of java & C++ programmers have seriously defective ideas of how to do OO programming
09:48:42 <bernalex> ski: that's in our exercises -- writing a rose tree and implementing a bunch of instances. :-]
09:49:43 <ski> bernalex : `Tree IORef a' being a tree whose (subtree) links are indirected through mutable reference cells. while `Tree Maybe a' would be a tree where some subtrees may be missing (perhaps you're constructing it in a structural editor, and you're not done with some parts yet)
09:50:07 <bernalex> ski: I've carefully completely avoided IO haha
09:50:19 <ski> ok
09:50:24 <bernalex> ski: but that's an interesting example
09:50:47 <f-a> bernalex: http://ariis.it/link/t/berna.txt
09:51:01 <bernalex> ski: yeah I really really really want to avoid the "IO monad" and other misconceptions, so I just pretend IO doesn't exist... I also don't mention any cat theory, even if I enjoy it myself. I just treat everything as APIs.
09:51:07 <bernalex> f-a: ta!
09:51:10 <ski> bernalex : if you fix the `a', you could use `Int's for the `ref (Tree ref)'s, indirecting through an `IntMap'
09:51:30 <bernalex> f-a: the font is Comic Neue, a public domain & improved Comic Sans. I helped finance it. :-]
09:51:58 <f-a> \o/ bernalex 
09:52:11 <bernalex> f-a: hm. I agree I should mention the f <$> a <*> pattern. good call.
09:52:24 <bernalex> f-a: side-by-side do is another good idea.
09:52:34 <f-a> with its own wikipedia page
09:52:49 <f-a> bernalex: don't tell anyone, but I don't use the do notation :P
09:53:20 <bernalex> f-a: have you written backend web code in database monad burritos? :-P
09:53:26 <bernalex> f-a: thanks a lot for the feedback!
09:53:30 <bernalex> ski: and you too of course! :-D
09:53:38 <f-a> pleasure to read the presentation
09:54:01 <bernalex> f-a: I hope it will end up more useful than most "monad tutorials". ;)
09:54:14 <ski> bernalex : i'd probably say "effectful computations" rather than "effective computations"
09:54:26 <bernalex> ski: effectful isn't really actually very much a word, I believe
09:54:36 <jophish> Does Gabriel Gonzalez hang out here ever?
09:54:54 <bernalex> ski: I have seen it used though. if it's so popular to the point of "effective" confusing people, maybe I should change it.
09:55:00 <f-a> bernalex: whom will this presentation be aimed to?
09:55:52 <bernalex> f-a: mostly newbies. the previous presentation was typeclasses (ADTs before that). so they've been through I think 5 introductive talks already. I *think* I am hitting the correct level of presumed competence here.
09:56:21 <bernalex> (hmmm 4 not 5, and the very first one was more a "what is haskell" than "how do you haskell", so 3 real haskell presentations)
09:56:41 <f-a> I feel the level is correct
09:56:42 <bernalex> f-a: I think most are professional programmers though. java guys mostly.
09:56:52 <JoshieAS> man, I'm having trouble abstracting this in my mind...
09:57:15 <EvanR> what is haskell really
09:57:20 <JoshieAS> I'm doing homework for the cis194 course, and we have to take a custom datatype: data Message Tree = Leaf | Node MessageTree LogMessage MessageTree
09:57:36 <exio4> EvanR: it just is
09:58:07 <JoshieAS> I'm writing a function, insert, that inserts a LogMessage based on a numeric field, and I'm not understanding how I would "insert" it
09:58:32 <Cale> JoshieAS: You're constructing a new tree out of the additional LogMessage and the old tree.
09:58:59 <ski> bernalex : for monads, in the "may be composed sequentially" point, i might emphasize that what to do next may depend on the previous result
09:59:11 <Cale> JoshieAS: Which exercise is this?
09:59:26 <JoshieAS> Exercise 2 in Homework 2
09:59:38 <bernalex> ski: good point. I don't think I'll put it in the slide, but I'll make a note to at least mention it.
09:59:45 * ski nods
10:01:46 <Cale> JoshieAS: Okay, so there are a bunch of approaches to this which will work, but if you're confused about what to do, a good place to start is just to pattern match on the values that your function is receiving and see if you can work out what it ought to produce in each case.
10:02:08 <JoshieAS> k, I'll start from there, thanks!
10:03:30 <Cale> So, probably the most interesting cases will be   insert (LogMessage msgType timeStamp msg) Leaf, and insert (LogMessage msgType timeStamp msg) (Node l msg' r)
10:04:01 <Cale> actually, you may want to pattern match that msg' as it's of type LogMessage as well
10:04:23 <Cale> (also, I'm sorry, it's a bit confusingly named, because msg is just a String)
10:05:29 <Cale> You can probably assume that the LogMessage at the root of the tree will never be constructed with Unknown
10:07:10 --- mode: ChanServ set -q *!*@62.117.223.208.dyn.user.ono.com
10:07:51 <JoshieAS> oh, that's a good point
10:07:57 --- mode: ChanServ set -q *!*@gateway/web/freenode/ip.93.175.7.133
10:08:07 --- mode: ChanServ set -q *!*@ip68-98-120-6.ph.ph.cox.net
10:08:13 --- mode: ChanServ set -q *!*@41.220.68.10
10:08:25 --- mode: ChanServ set -q *!*@gateway/web/freenode/ip.89.215.196.162
10:08:37 --- mode: ChanServ set -q *!*@31.Red-95-124-172.staticIP.rima-tde.net
10:08:44 --- mode: ChanServ set -q *!*@70-35-57-218.static.wiline.com
10:08:50 --- mode: ChanServ set -q *!*@90.218.87.227
10:09:37 <ski> bernalex : in the `Applicative []' and `Monad Maybe' instances, i'd remove the redundant brackets wrapping the patterns, out of principle :)
10:09:56 <ski> > [z*(z+1) | x <- [4],y <- [2],let z = x+y]  -- .. and `let' works just fine in list^Wmonad comprehensions
10:09:58 <lambdabot>  [42]
10:10:06 <JoshieAS> Cale: Thanks for the boost!
10:10:47 <poucet> :t <=<
10:10:48 <lambdabot> parse error on input ‘<=<’
10:10:54 <poucet> :t (<=<)
10:10:54 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
10:10:57 <ski> bernalex : also, in `fs <*> xs = fmap f xs ++ fs <*> xs' you need brackets around the latter call. btw, i'd probably say `fs <*> xs = (f <$> xs) ++ (fs <*> xs)' here
10:11:08 <poucet> :t (=<<)
10:11:09 <lambdabot> Monad m => (a -> m b) -> m a -> m b
10:11:19 <poucet> :t maybe
10:11:19 <lambdabot> b -> (a -> b) -> Maybe a -> b
10:11:29 <bernalex> ski: removing brackets noted
10:11:34 <rom1504> poucet: very_sad_smiley
10:11:37 <rom1504> that's the type
10:11:40 <poucet> :D
10:12:29 <bernalex> ski: shortened the monad comprehension to use let right of the | too.
10:13:08 <bernalex> ski: brackets around fs <*> xs? hmm
10:13:29 <ski> bernalex : oh, already in the `instance Applicative []'
10:14:02 <bernalex> ski: it's even more broken on the slide you mean, because I forgot the f hehe
10:14:12 <ski> bernalex : `++' has higher precedence than `<$>' and `<*>'
10:14:16 <bernalex> ski: are you sure?
10:14:31 * ski just checked
10:14:48 <glguy> 13infixr 045 07++; 13infixl 044 07<$> 07<*>
10:15:01 <bernalex> ski: I'm confused because the code I have there does what I expect it to
10:15:02 <ski> s/ /,/
10:15:34 <bernalex> ski: also then the ()s are not redundant in that case
10:15:45 <bernalex> ski: oh! I figured it out
10:15:49 <ski> @type \f fs xs -> fmap f xs ++ fs <*> xs
10:15:50 <lambdabot> (a -> a -> b) -> [a -> b] -> [a] -> [b]
10:15:50 <ski> @type \f fs xs -> fmap f xs ++ (fs <*> xs)
10:15:50 <lambdabot> (a1 -> a) -> [a1 -> a] -> [a1] -> [a]
10:16:05 <bernalex> ski: I was being silly. when I define it on my own, of course <*> will get fixity 9...
10:16:39 <ski> bernalex : they are redundant in `(f:fs) <*> xs' and `(Just x) >>= f'
10:16:58 <ski> not in `(f <$> xs) ++ (fs <*> xs)'
10:17:34 <bernalex> ski: right, the reason they weren't redundant was, again, because I defined it in ghci and so it got the same fixity as :
10:17:59 <bernalex> ski: thanks for being more thorough than me ;)
10:19:12 <vrs> I'm trying to coax some data out of a data type: http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Layout-Groups.html#t:Groups - it's exported as Groups and not Groups(..), can I still pattern match stuff out of it or am I under some fundamental misunderstanding?
10:19:57 <ski> bernalex : for semigroups, i might perhaps add that since we expect to be able to combine a (non-empty) list of stuff with the binary operation, we require that it is associative, so it doesn't matter how we bracket (could possibly do in parallel, e.g.)
10:19:57 <enthropy> vrs: no you aren't supposed to be able to pattern match it
10:20:06 <ski> s/list/sequence/, perhaps
10:20:42 <vrs> enthropy: damn. it maintains its own window stack and I wanted to get at that for logging purposes
10:20:46 <enthropy> which might be an oversight because you could parseTheThingYouWant . show
10:20:47 <ski> bernalex : under this view, monoids is just an extension that also allows empty lists/sequences to be handled sensibly
10:20:58 <bernalex> ski: I was thinking to mention that it needs be associative
10:21:41 <ski> bernalex : if you explain in terms of combining an (ordered) sequence of things, then it being associative just means that it doesn't matter how you insert the brackets
10:21:43 <bernalex> ski: which means e.g. that natural numbers under division does not form a monoid.
10:22:03 <EvanR> or even an "operation"
10:22:28 <ski> bernalex : .. or subtraction, since `7 - (4 - 3)' is not `(7 - 4) - 3'
10:22:51 <bernalex> yes, I understand this. I just did not explicitly put it in the presentation. :)
10:23:35 <ski> i know. i'm just attempting to mention some points which you may or may not have thought of, and which you may or may not want to mention. or perhaps mention if someone asks for more clarification
10:23:49 <bernalex> ski: yes, I'm grateful!
10:24:37 <ski> bernalex : `min' and `max' are useful examples of semigroups that can't be extended to monoids in many common cases
10:25:35 <bernalex> ski: hm. I think I have seen this exact example somewhere. typeclassopedia maybe?
10:26:18 <ski> dunno (i've only looked very briefly at that)
10:26:31 <poucet> Anyone have a recommendation on which priority queue package is best supported?
10:26:47 * ski isn't that happy with "Foldable is for things which may be folded over."
10:27:38 <bernalex> ski: well that's what it literally is. I think it's a bad abstraction though.
10:28:08 <EvanR> seems kind of like a typeclass for things which can be thinged, or a -> bed
10:28:28 <exio4> http://lpaste.net/124787 is there anything missing in this "implementation" of list comprehesions?  
10:28:31 <ski> (there's two different senses of "fold" here. `Foldable' is basically about the "fold over a sequence of elements" sense. "catamorphism" is about the other sense. they happen to coincide for `foldr' for lists)
10:29:06 <exio4> (starts in the line 95~)
10:29:18 <bernalex> yes I mean that. I haven't mentioned catamorphisms in here yet... not sure I want to. I'll add a links slide to somewhere that does though.
10:33:07 <ski> > [(x,y) | x <- [0 .. 3],y <- [0 .. x]]  -- exio4
10:33:08 <lambdabot>  [(0,0),(1,0),(1,1),(2,0),(2,1),(2,2),(3,0),(3,1),(3,2),(3,3)]
10:34:24 <ski> bernalex : why `foldr _ e' but `foldr f z' ?
10:34:26 <exio4> I see, thanks ski! 
10:34:30 <arkeet> > [(x,y) | x <- [0..], y <- [0..x]]
10:34:31 <lambdabot>  [(0,0),(1,0),(1,1),(2,0),(2,1),(2,2),(3,0),(3,1),(3,2),(3,3),(4,0),(4,1),(4,...
10:34:57 <bernalex> ski: oh. I don't really care about variable names. :p I should be consistent though. thanks.
10:35:19 <bernalex> ski: using 'z' everywhere now.
10:36:10 <ski> bernalex : anyway, here the aforementioned dolio post is relevant
10:36:43 <bernalex> ski: is that the comonad reader thing you linked that wasn't a link so I would have to mark it line by line (it's four lines in my tiny buffer)? :-P
10:37:10 <ski> bernalex : yea :)
10:38:01 <bernalex> ski: pulled it up in a tab. will look at it later today. ta!
10:38:49 <arkeet> what post?
10:39:34 <ski> <ski> bernalex : .. apropos `Foldable', did you see <http://comonad.com/reader/2015/free-monoids-in-haskell/> ?
10:39:35 <arkeet> :t (return .)
10:39:36 <lambdabot> Monad m => (a -> b) -> a -> m b
10:39:41 <arkeet> ah
10:39:48 <arkeet> :t (=<<) . (return .)
10:39:48 <lambdabot> Monad m => (a -> b) -> m a -> m b
10:39:59 <ski> bernalex : short version : "`Foldable' is for things you can write `toList' for" is almost, but not quite right, because of ..[non-strictness].. -- better is "`Foldable' is for things you can write `toFreeMonoid'/`foldMap' for"
10:40:11 <ski> @type foldMap
10:40:12 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
10:40:38 <ski>   toFreeMonoid :: Foldable t => t a -> (forall m. Monoid m => (a -> m) -> m)
10:40:58 <ski>   toFreeMonoid = flip foldMap
10:41:23 <maurer> @pl (a -> b) -> (b -> b -> c) -> (a, a) -> c
10:41:23 <lambdabot> (line 1, column 6):
10:41:23 <lambdabot> unexpected '>'
10:41:23 <lambdabot> expecting operator
10:41:37 <maurer> Oh, nvm, forgot @pl can't take types
10:42:34 <bennofs> @djinn (a -> b) -> (b -> b -> c) -> (a, a) -> c
10:42:35 <lambdabot> f a b (c, _) = b (a c) (a c)
10:42:57 <geekosaur> @. pl djinn (a -> b) -> (b -> b -> c) -> (a, a) -> c
10:42:57 <lambdabot> f = flip flip snd . (ap .) . flip flip fst . (((.) . (const .)) .) . (flip =<< (ap .) . flip (.))
10:43:05 <geekosaur> ... nemmind :p
10:43:18 <bernalex> :t f = flip flip snd . (ap .) . flip flip fst . (((.) . (const .)) .) . (flip =<< (ap .) . flip (.)) 
10:43:19 <lambdabot> parse error on input ‘=’
10:43:26 <bernalex> :t flip flip snd . (ap .) . flip flip fst . (((.) . (const .)) .) . (flip =<< (ap .) . flip (.)) 
10:43:26 <lambdabot> (a -> b2) -> (b2 -> b2 -> b1) -> (a, b) -> b1
10:43:29 <bernalex> problem solved
10:43:30 <bernalex> uh
10:43:33 <ski> @type \f (><) -> uncurry ((><) `on` f)  -- maurer ?
10:43:33 <lambdabot> (b -> b1) -> (b1 -> b1 -> c) -> (b, b) -> c
10:43:58 <hexagoxel> :exf (a -> b) -> (b -> b -> c) -> (a, a) -> c
10:43:58 <exferenceBot> \ b c d -> let ((,) f g) = d in c (b g) (b f)
10:43:58 <exferenceBot> \ b c d -> let ((,) f g) = d in c (b f) (b g)
10:44:25 <ski> bernalex : "Your pick between `foldMap' and `foldr'."
10:45:12 <ReinH> ski: :)
10:45:28 <bernalex> ski: you mean to comment something about that?
10:45:41 <ski> bernalex : the wording sounds strange to me
10:46:18 <ReinH> (note that djinn is ignoring the second a in the pair)
10:46:40 <bernalex> ski: are you an English native speaker? it's fine to me.
10:46:50 <ski> i'm not
10:47:14 <ski> (i'd want something like either "You (can) pick between `foldMap' and `foldr'." or "Your pick is between `foldMap' and `foldr'.")
10:47:59 <bernalex> ski: those are very awkward to me. :-]
10:48:19 <bernalex> to be sure, mine is a colloquialism, I'll grant you as much.
10:51:46 <ski> bernalex : if you think it's ok, ok. just mentioning it because it sounded strange to me
10:51:59 <bernalex> ski: appreciate it. :-]
10:58:29 <maurer> ski: Data.Function.on was what I'm looking for
10:59:36 <ski> bernalex : i would probably mention `traverse' as an alternative to implementing `sequenceA'
11:00:08 <bernalex> ski: oh, right!
11:01:03 <ski> bernalex : ".. that lets commute two functors" probably needs elaboration (as you're obviously aware of, and sounds a bit vague. the gist is basically "a traversable collection of computations can be turned into a computation yielding the corresponding collection of computation results"
11:01:31 <ski> with "computation" understood in the sense of `Applicative' and `Monad'
11:02:55 <ski> perhaps you could say "A `Foldable' `Functor' that lets us collect the results in a new collection." or "A `Foldable' `Functor' that lets us move the collection inside the computation." or something
11:05:48 <krokodil> Hi! I'm trying to install SDL in Cabal. running `cabal install sdl` fails with an error: Module ‘Data.Typeable’ does not export ‘Typeable(typeOf)’
11:06:01 <krokodil> I use sandboxed environment. GHC 7.8.4
11:06:25 <bergmark> krokodil: it may not have been updated for 7.8
11:07:10 <ski> bernalex : hm .. especially since you go on to implement `traverse' instead of `sequenceA' :)
11:07:19 <krokodil> bergmark: should I file a bug report?
11:07:50 <bernalex> ski: yes. :p I made the same mistake in mentioning foldMap, and then showing how to implement it using foldr instead of foldmap. ;)
11:08:22 <bergmark> krokodil: yeah
11:08:41 <ski> bernalex : well, but in the version of the slides i saw, you said ".. between `foldMap' and `foldr'." :)
11:09:01 <bernalex> ski: yeah -- originally it just said foldMap. :-]
11:09:18 * ski was starting to suspect that, now
11:10:02 <ski> bernalex : perhaps it seems slightly confusing to use `traverse' (not `mapM') but `sequence' (not `sequenceA') in the examples
11:10:09 <ski> no big matter, though
11:10:24 <ski> (btw, i like that you used `traverse' infix)
11:10:40 <ski> (otoh, i'd not use `$' there :)
11:11:06 <bernalex> yeah I'm not sure. I think my Traversable examples are a bit lacking presently.
11:12:51 <ski> bernalex : possibly because your `Monad' and `Applicative' examples haven't been that varied to give a wider feeling for what a "computation" may be here
11:13:18 <bernalex> yeah I aim to cover that more in the exercises
11:13:58 <ANewbie> Hi! I would like to make a type synonym which will carry its constraint with it. Something like: type SVector a = Storable a => Vector a, where if define f :: SVector a -> Int, it will in fact be f :: Storable a => Vector a -> Int.  Any ideas?
11:14:13 <ski> bernalex : exercises after ? or inbetween ?
11:14:25 <bernalex> ski: likely after
11:14:35 <bernalex> ski: I appreciate it might be a lot to take in though
11:14:47 * ski nods
11:14:50 <bernalex> ski: exercises will have a fair deal of comments/documentation & recapping.
11:16:50 <randir> how can I use the Network.URI to combine a site root with a relative URI?
11:17:29 <ski> ANewbie : morally you either want `type SVector a = Storable a *> Vector a' or want `Storable a' as a presupposition on `Vector a' (the difference is that `g :: Blah a -> SVector a' would be `g :: Blah a -> (Storable a *> Vector a)' with the former, but `g :: Storable a => Blah a -> Vector a' with the latter -- these are different) -- in any case, there's no direct way to do any of those in current Haskell (including commonly implemented extensions)
11:17:47 <ski> (er, cut off near ".. -- in any case, there's no direct way to do any of those in current Haskell (including commonly implemented extensions)")
11:19:04 <ski> bernalex : one somewhat fun example is an expression monad
11:19:20 <bernalex> ski: I don't believe I'm familiar with that
11:19:46 <ANewbie> ski: :) I tried RankNTypes and I think that what it gave me was something akin to the first case, but it would not use the constraint, so when trying to call VS.length on the parameter, the compiler gave me an error about unsatisfied Storable constraint
11:20:09 <ski> bernalex : consider a simple expression AST `data Expr var = Var var | Int Integer | Add (Expr var) (Expr var) | Neg (Expr var)'. `Expr' is a monad
11:20:21 <lpaste> glguy pasted “carrying constraints” at http://lpaste.net/124788
11:21:00 <ski> bernalex : `do var <- expr; newExpr var' will substitute each `Var var' in `expr' by `newExpr var'
11:21:01 <glguy> ANewbie: That's a way to get what I think you're asking for ^
11:21:52 <ski> bernalex : this is like a nondeterminism monad, like `Maybe' or `[]', except there's more "structure" to the nondeterminism (the expression tree "surrounding" the bare variable "leaves")
11:22:00 <ANewbie> glguy: thanks, I was aware of the ability to use a data decalaration, but that means that I cannot use already existings funcs (im my case Vector.Storable )
11:22:29 <bernalex> ski: do you mean an example Monad simply? you said it's a fun example, but not what it examplifies. :p
11:22:47 <ski> ANewbie : no, with `type SVector a = Storable a => Vector a', `f :: SVector a -> Int' would become `f :: (Storable a => Vector a) -> Int' which is not the same as `f :: Storable a => Vector a -> Int' (quite the opposite ..)
11:23:57 <ski> bernalex : an example monad, which is a kind of "nondeterminism" monad (like `[]')
11:24:13 <bernalex> ski: yeah, I see. it makes it more obvious.
11:24:50 <ANewbie> ski: AFAIK, isn't this identical to type SVector a = (forall a. Storable a) => Vector a? I already tried this with RankNTypes, and it didn't work. I do not quite understand why though. Any docs relevant?
11:24:58 <ski> ANewbie : no
11:25:34 <ANewbie> ski: Ah, my bad then
11:25:55 <ANewbie> I just assumed that it was the same.
11:26:01 <ski> ANewbie : `f :: Storable a => Vector a -> Int' (which would be equivalent to `f :: (Storable a *> Vector a) -> Int', were it actual allowed Haskell syntax) expects the caller to provide the `Storable' instance for `a'
11:27:05 <ski> ANewbie : `f :: (Storable a => Vector a) -> Int' would expect the caller to provide an argument that works for any `Storable' instance, and the callee (i.e. `f' itself) promises to provide the `Storable' instance (assuming it wants to use the argument at all)
11:27:35 <ski> ANewbie : `type SVector a = (forall a. Storable a) => Vector a' is the same as `type SVector a = (forall b. Storable b) => Vector a' .. you can see how this is also different
11:27:52 <ANewbie> Ah, now it get it. This would be like Scala's implicit arguments, where the caller can control the used implementation used?
11:28:23 <ski> well .. it's a bit related to that, yes
11:28:47 <ski> except there can be at most one instance for a type class, associated with a given type, for the whole program
11:28:56 <ANewbie> ski: Yes, you get shadowing of b over a when using the same name, but using different names makes this clearer.
11:29:16 <ski> you can't use one `Ord' instance for a type in one part of the program, and another `Ord' instance for the same type in another part of the program
11:29:58 <ANewbie> ski: yes, in Haskell it doen't make much sense in having the ability to use different implementations due to the typeclass restriction you mention.
11:30:35 <ski> ANewbie : as for your original question, as things stand, i think you simply have to write the `Storable' constraint explicitly (perhaps hiding it as a superclass of some other type class, or inside a constraint synonym)
11:30:54 <EvanR> in haskell you can use different implementations by providing different functions of the same type, or different records of functions of the same type
11:31:21 <ski> ANewbie : there are implicit parameters in GHC, where you can provide different values for the same type in different contexts ..
11:31:39 <ANewbie> EvanR: Hasn't tekmo described this in a blog post?
11:31:42 <ski> EvanR : .. or making `newtype'(s) with new instances
11:32:07 <ski> (of course `data' would also work, but traditionally `newtype' is used here)
11:33:44 <ANewbie> ski: the problem there is that a lot of the libraries provide functions which do not consume typeclasses
11:34:56 <ANewbie> ski: yes, I think I will resign to just write the constraint everywhere it is needed. I might use -XCPP to just macro it it :)
11:47:10 <ANewbie2> bernalex: Would mind telling me what "type classes against the world" which you said you had watched is? I did a search and came up short.
11:47:44 <bernalex> ANewbie2: it's on youtube. just edwardk talking about typeclasses at a boston haskell users group.
11:48:33 <edwardk> ANewbie2, bernalex: https://www.youtube.com/watch?v=hIZxTQP1ifo
11:50:05 <ANewbie2> bernalex: and edwardk: Ah you had slightly changed the title and weirdly enough a google search didn't yield results. Thanks!
11:50:28 <dfeuer> Hi, edwardk.
11:50:33 <edwardk> heya dfeuer 
11:51:04 <edwardk> dfeuer: i had a toy problem that could have leveraged your particular talents the other day, but now i can't remember what it was
11:51:22 <dfeuer> :-/
11:52:03 <dfeuer> edwardk, I finally cleaned up my horrifying Data.Sequence.<*> code the other day!
11:52:05 <bernalex> edwardk: you know how you in yr talk said to have half a dozen problems & half a dozen solutions? you should probably have added to not walk into yr trap of having 1K problems & 1K solutions. ;)
11:53:01 <edwardk> bernalex: later in the talk i talk about how i figured if holding a dozen problems was great then holding 400 would be awesome, which is how i motivate all the cognitive science techniques for the rest of the talk =)
11:53:31 <bernalex> edwardk: I know, hehe
11:56:34 <vin-ivar> hullo
11:56:42 <vin-ivar> question about the cis194 homework
11:57:31 <platz> there was a post about rmonad recently and type families to propagate constraints
11:57:50 <vin-ivar> wait, i'll ask on #haskell-beginners 
11:59:25 <nerium> Can someone explain to me why a ++ (b ++ c) would be faster then (a ++ b) ++ c when applying "head"?
12:00:47 <nerium> Is it b/c (a ++ b) has to be evaluated before head is applied?
12:02:06 <ANewbie2> edwardk: I remember seeing on of your comments on some blog post about using ConstraintKinds to change/generalize the definitions of Functor, Applicative, etc. IIRC, you said the it would break code that is polymorphic over monads. Can you point to somewhere where this is explained?
12:02:12 <S11001001> nerium: let's say you fully run down the spine of a list
12:02:31 <ANewbie2> s/son/one/
12:02:39 <S11001001> nerium: if you created that list with a ++ b, what gets copied, assuming a and b have been already realized?
12:03:45 <nerium> S11001001: I'm not sure I understad what you mean
12:04:13 <cfoch> hello. 
12:04:17 <S11001001> nerium: well, you have a list that isn't a or b
12:04:29 <S11001001> nerium: you didn't get it by mutating either a or b, because that's not allowed
12:04:35 <S11001001> nerium: so you must have copied *something*.
12:04:42 <cfoch> is there a way to have some sort of collection of different and *variable* data types ?
12:05:05 <cfoch> A list of variable size.
12:05:44 <Welkin> data MyType = Type1 | Type 2 | Type 3
12:06:01 <S11001001> cfoch: http://failex.blogspot.com/2012/03/with-type-system-whether-you-can-write.html
12:06:03 <Welkin> type MyList = [MyType]
12:07:25 <ANewbie2> cfoch: Could you use Data.Dynamic to wrap the data types?
12:09:45 <cfoch> without knowing the data type this sort of collection is going to contain
12:10:04 <cfoch> ANewbie2: Data.Dynamic could help me?
12:10:11 <arkeet> what do you want to do ith the collection?
12:10:14 <arkeet> with
12:10:19 <ReinH>  cfoch HList is a thing, but you really ought to consider why you need this
12:10:28 <ReinH> heterogenous lists are difficult to work with
12:10:46 <arkeet> or rather
12:10:51 <arkeet> why do you want such a collection?
12:11:12 <Welkin> ReinH: heterogenous lists/arrays are common in python/ruby/js, unfortunately
12:11:22 <cfoch> because I want to write a function which receives a list of "data types" -> a list of "function" -> and returns a rendered diagram
12:12:15 <ReinH> The problem isn't putting things into a heterogenous list, it's doing stuff with then once they're in there
12:12:18 <ReinH> *them
12:12:38 <Welkin> yes
12:12:40 <ReinH> Where are these data types coming from?
12:12:45 <Welkin> you are effectively ignoring the type system in that case
12:15:19 <arkeet> "data types" and "function" seems pretty vague.
12:15:49 <ski> cfoch : are the list of data items related in any way to the corresponding list of functions ?
12:16:00 <ReinH> ski: If it's a heterogenous list, they can't be :D
12:16:09 <cfoch> for example you have
12:16:12 <ReinH> unless the list of functions is a list of id functions
12:16:57 <cfoch> [String, Num, Integer, Num, Ord, Bool] -> [(+), fromInteger, concat, (>)]
12:17:03 <cfoch> then...
12:17:32 <EvanR> its like a kids breakfast cereal
12:17:41 <ReinH> cfoch: Tell us about *your* actual application
12:17:45 <cfoch> Let's draw a graph which shows all the functions that given a "TypeA" (in one of its parameter)  returns a "TypeB" 
12:18:05 <ReinH> I don't understand
12:18:07 <RustyShackleford> I'm doing some bit level tricks. Ideally i'd have an unsigned integer so that the sign bit doesn't mess me up
12:18:13 <EvanR> and your mother insists you eat the "all Bools" cereal which is horribly boring and gross
12:18:33 <ReinH> cfoch: What are *your* actual data types and functions?
12:18:36 <EvanR> but the lists with all kinds of fun types rots your brain
12:18:38 <napping> cfoch: sounds like Typeable might actully be what you have in mind
12:18:49 <napping> The question is what values to use to represent a Haskell type
12:19:15 <ReinH> RustyShackleford: Data.Word?
12:19:16 <cfoch> *all* the data types in the PackageDb (I think this is the name that contains all the packages)
12:19:26 <arkeet> Typeable sucks for polymorphic types.
12:19:37 <ReinH> cfoch: what are you actually doing? Be specific.
12:19:48 <napping> so something like [TypeRep] -> [TypeRep] -> ...
12:19:55 <napping> ReinH: seems clear enough to me
12:20:00 <cfoch> let me draw a diagram
12:20:10 <cfoch> it will take some minutes... wait
12:20:27 <ReinH> napping: I am impressed by your mind reading skills
12:20:59 <napping> Given some code, and a list of types and functions you are interested in, make a pretty diagram of which functions take or return arguments from among those types
12:21:16 <napping> no "mind" about the reading
12:21:31 <arkeet> ok, then don't give it functions. give it some representation of the functions.
12:21:33 <arkeet> and of the types.
12:21:38 <ski> ReinH : not if we know nothing more, right (but perhaps cfoch knows more)
12:21:51 <ReinH> I've made a lot more errors assuming I understand a question when I don't than the other way around
12:21:54 <napping> I agree with arkeet's advice, and have to go
12:22:32 <napping> probably whatever library you are using to analyze the code will already have the right data types
12:32:24 <RustyShackleford> ReinH: so the word types are unsigned?
12:32:34 <RustyShackleford> do they behave like integers otherwise?
12:32:59 <ReinH> RustyShackleford: yes
12:33:10 <ReinH> Well, they behave like unsigned integers
12:33:18 <ReinH> of a particular size
12:34:14 <drewbert> Man, it's amazing how a lift in the right spot will simplify everything else.
12:37:11 <phaazon> :t lmap fst
12:37:12 <lambdabot> Profunctor p => p b c -> p (b, b1) c
12:37:14 <phaazon> hm
12:37:21 <phaazon> that’s what I was looking for
12:37:31 <phaazon> :t arr fst
12:37:31 <lambdabot> Arrow a => a (c, b) c
12:38:03 <phaazon> :t first' fst
12:38:03 <lambdabot>     Not in scope: ‘first'’
12:38:03 <lambdabot>     Perhaps you meant one of these:
12:38:03 <lambdabot>       ‘first’ (imported from Control.Arrow),
12:38:13 <phaazon> :t Data.Profunctor.first' fst
12:38:14 <lambdabot> ((a, b), c) -> (a, c)
12:39:29 * ski lifts drewbert to higher levels
12:40:28 <phaazon> :q
12:42:16 <ReinH> phaazon: If you're using lambdabot to explore something, please use a private messages
12:42:23 <ReinH> s/a //
12:45:20 <cfoch> Ok, folks
12:45:26 <cfoch> http://i.imgur.com/PADEd2a.png
12:45:46 <cfoch> there's the diagram
12:55:12 <RustyShackleford> is there a way to print an integer in hex?
12:55:47 <arkeet> :t showHex
12:55:48 <lambdabot> (Show a, Integral a) => a -> ShowS
12:56:00 <arkeet> > showHex 12345 ""
12:56:02 <lambdabot>  "3039"
12:56:10 <bennofs> :i showHex
12:56:15 <bennofs> @index showHex
12:56:15 <lambdabot> Numeric
12:56:26 <clrnd> that's bloody specific
12:56:38 <RustyShackleford> arkeet: thank you
12:56:38 <arkeet> it is
12:56:41 <arkeet> it's from the Numeric module
12:56:42 <arkeet> in base
12:57:14 <bennofs> clrnd: that's the output when it works :)
12:57:17 <bennofs> @index view
12:57:18 <lambdabot> bzzt
12:57:32 <arkeet> @index over
12:57:32 <lambdabot> bzzt
12:57:33 <bennofs> That's when it doesn't ... :)
12:57:36 <EvanR> :t showIntAtBase
12:57:37 <arkeet> oh.
12:57:37 <lambdabot> (Show a, Integral a) => a -> (Int -> Char) -> a -> ShowS
12:58:27 <clrnd> bennofs, jaja :D
12:59:04 <ttt_fff> is there anything like aeson, but also works with haste-compiler? (aeson seems to require template haskell, which haste does not support)
13:00:01 <cfoch> clrnd: spanish?
13:03:35 <clrnd> clauswitt_, sí
13:03:39 <clrnd> cfoch, ^
13:04:00 <clrnd> oh the 'jaja' gave me up, funny
13:06:27 * hackagebot EstProgress 0.2.0.0 - Methods for estimating the progress of functions  http://hackage.haskell.org/package/EstProgress-0.2.0.0 (JamesCandy)
13:11:27 * hackagebot satchmo 2.9.4 - SAT encoding monad  http://hackage.haskell.org/package/satchmo-2.9.4 (JohannesWaldmann)
13:14:41 <ReinH> ttt_fff: Aeson doesn't *require* it, it uses it to make it easier to write instances.
13:16:01 <ttt_fff> ReinH: well, I do lik the derive (Generic) ==> everything elese auto works
13:16:05 <ttt_fff> and I'm not interested in hacking Aeson to rip out templat ehaskell.
13:16:14 <ttt_fff> nor am I interested in porting TH to Haste.
13:16:32 <ReinH> ttt_fff: Sure, just letting you know that you can use it, you just can't use some of its capabilities
13:16:49 <ttt_fff> ReinH: which capabilties in particular?
13:16:59 <ReinH> ttt_fff: The ones that require template haskell ;)
13:17:05 <ttt_fff> The whole point I want from Aeson is arbitrary haskell with derive Generic ==> boom ==> auto seiralize/deserialite from json
13:17:09 <ttt_fff> ReinH: and hwihc ones are those?
13:18:10 <RustyShackleford> ReinH: so i'm confused why I can't use showHex in ghci
13:18:15 <RustyShackleford> let x = 2
13:18:22 <RustyShackleford> showHex x
13:18:32 <RustyShackleford> er, Numeric.showHex x actually
13:18:54 <ski> RustyShackleford : did you forgot to pass the second argument (a continuation string) ?
13:19:29 <RustyShackleford> i guess. I'm not sure what the second argument is supposed to be
13:19:54 <ski> the string you want to append the show output onto
13:20:33 <RustyShackleford> so then I just want the empty string I suppose
13:20:42 <arkeet> yes
13:20:46 <Luke> i have a Maybe stuff and I want to fmap a lens view (^.) over it but because of the associativity of ^. i cant
13:20:50 <Luke> is there a way to handle that with lenses?
13:20:57 <arkeet> the second argument is only there for performance reasons.
13:21:02 <RustyShackleford> i don't see why you pass a string to that function
13:21:07 <ski> > (shows 255 . showString " (decimal) in hexadecimal is " . showHex 255) ""  -- RustyShackleford
13:21:08 <lambdabot>  "255 (decimal) in hexadecimal is ff"
13:21:19 <RustyShackleford> where is the string in this function signature?
13:21:21 <RustyShackleford> showHex :: (Integral a, Show a) => a -> ShowS
13:21:23 <Luke> basically I want (^. stuff ^. lens1) <$> (Just 5)
13:21:24 <arkeet> Luke: what do you mean, you can't?
13:21:31 <ski>   type ShowS = String -> String
13:21:31 <Luke> but that doesn't compile
13:21:34 <arkeet> why do you have two ^.
13:21:40 <Cale> type ShowS = String -> String
13:21:45 <Luke> because I have two lenses
13:21:53 <glguy> Luke: do you mean    view (lens1 . stuff) <$> Just 5  ?
13:22:00 <Luke> yeah
13:22:01 <Luke> thanks
13:22:09 <arkeet> or (^. lens1 . stuff)
13:22:12 <Cale> RustyShackleford: The reason for this is that xs ++ ys (necessarily) takes O(length xs) time to compute, but function composition is constant time
13:22:12 <arkeet> or whatever
13:22:16 <Luke> no
13:22:16 <Luke> arkeet: that doesn't compile
13:22:23 <RustyShackleford> so showHex takes only one argument, and returns a ShowS. The second argument is passed to ShowS?
13:22:24 <arkeet> note the . not ^.
13:22:28 <arkeet> it should work
13:22:32 <ReinH> RustyShackleford: And repeated uses of (++) incur the cost of traversing the left hand side repeatedly
13:22:51 <arkeet> a -> ShowS  =  a -> String -> String
13:22:52 <Luke> arkeet: oh you're right it does
13:23:02 <RustyShackleford> okay one more question. Iive noticed that I can import Numeric in a file
13:23:08 <RustyShackleford> and I can just call showHex
13:23:19 <RustyShackleford> in the interpreter, I have to call Numeric.showHex
13:23:21 <Luke> I guess I don't understand when to use (^.) and when to use (.)
13:23:33 <Cale> RustyShackleford: So, if you'd otherwise be building up a long string by concatenating many strings together, it can be much more efficient to compose functions which add elements to the beginning instead.
13:23:34 <arkeet> Luke: . is for composing lenses (and functions in general).
13:23:36 <arkeet> ^. is view
13:23:48 <Cale> RustyShackleford: You can import Numeric in ghci as well
13:23:52 <Luke> it was working with multiple views though
13:24:07 <RustyShackleford> well I did. Seems like I need the fully qualified name in the interpreter though
13:24:12 <arkeet> well, view l (view m x) is the same as view (m . l) x
13:24:15 <RustyShackleford> but not necessarily in a .hs file
13:24:22 <Cale> ghci> import Numeric
13:24:22 <Cale> ghci> showHex 4389 ""
13:24:22 <Cale> "1125"
13:24:24 <Cale> Seems not
13:24:27 <arkeet> with operators, that
13:24:29 <arkeet> is
13:24:36 <arkeet> x ^. m ^. l = x ^. m . l
13:24:38 <arkeet> but
13:24:44 <Luke> which is preferred then?
13:24:52 <arkeet> the difference is 
13:24:53 <Luke> a lot of ed's examples have chained (^.)
13:24:57 <arkeet> left is (x ^. m) ^. l
13:25:00 <arkeet> right is x ^. (m . l)
13:25:05 <arkeet> the latter is preferred.
13:25:06 <Luke> ah
13:25:15 <glguy> Luke: It's a style choice. If you like all the operators use operators
13:25:37 <RustyShackleford> Cale: nevermind. Idk what I was doing wrong
13:25:42 <glguy> but composition is prefered over multiple calls to view
13:26:12 <arkeet> Luke: it's like the difference between f $ g $ x and f . g $ x
13:26:19 <arkeet> f $ (g $ x) = (f . g) $ x
13:26:25 <Luke> right i got you now
13:26:29 <Luke> I changed my code and it worked
13:26:31 <Luke> thanks
13:32:23 <edwardk> Luke: ^. should only be used to 'start the chain'
13:32:28 <edwardk> after that (.)'s compose lenses
13:32:30 <Luke> gotcha
13:32:36 <edwardk> foo^.bar.baz  = foo^.(bar.baz)
13:32:45 <edwardk> and function composition will compose lenses that way
13:32:58 <edwardk> you can use foo^.bar^.baz  but that is (foo^.bar)^.baz
13:33:10 <Luke> edwardk: I had misread some of the (.) in http://lens.github.io/tutorial.html to be (^.)
13:33:11 <edwardk> (^.foo.bar)  is a legal section, (^.foo^.bar) is not
13:33:16 <Luke> so it was my mistake really
13:33:18 <Luke> right
13:33:19 <edwardk> np
13:33:21 <Luke> that was my issue
13:33:25 <edwardk> just figured i'd elaborate =)
13:33:34 <Luke> yeah thanks I appreciate it
13:36:04 <ski> edwardk : .. imho, it's a bit silly that e.g. `(3 + 2 *)' isn't a valid section (equal to `\x -> 3 + 2 * x' and to `(3 +) . (2 *)')
13:36:38 <napping> isn't it?
13:36:41 <arkeet> no
13:36:41 <napping> :t (3 + 2 *)
13:36:42 <lambdabot>     The operator ‘*’ [infixl 7] of a section
13:36:42 <lambdabot>         must have lower precedence than that of the operand,
13:36:42 <lambdabot>           namely ‘+’ [infixl 6]
13:37:05 <napping> ah, it's just the other way around that works
13:38:10 <napping> ski: I kind of expect ((3 + 2) *) from that
13:38:27 <arkeet> the fact that different people expect different things suggests that it shouldn't be allowed.
13:39:03 <ski> napping : why ?
13:39:22 <ski> arkeet : or that expectations should be fixed ;)
13:39:32 <napping> The section itself is the top level of the syntax here ( )
13:39:46 <napping> and the operator looks like it's stuck into that
13:39:54 <napping> (3 + 2) is the only valid subexpression
13:40:09 <napping> your (3 + (2 * ??)) is some kind of context thingy
13:41:08 <napping> Has anyone here used Shake with dependencies read out of a file?
13:41:40 <ski> i think it's useful to think of an operator section as a (bracket-wrapped) expression, with an initial or final (or both) subexpression missing
13:41:45 <napping> I'm trying to set things up so it gets the goals by reading a file, but also let those files include other files, without losing the parallelism
13:42:05 <raek> is there a shorter version of "x `seq` x"?
13:42:11 <ski> raek : `x'
13:42:12 <arkeet> yes
13:42:12 <arkeet> "x"
13:43:41 <ttt_fff> how do I convert Binary -> Text ?
13:43:41 <raek> but that won't reduce x to WHNF, right?
13:43:56 <shachaf> It will when you force it.
13:44:00 <shachaf> Same as x `seq` x
13:44:06 <EvanR> if x is evaluated, then its evaluatd
13:44:09 <Cale> raek: In any case where the expression x `seq` x was getting evaluated, x was already going to be evaluated.
13:44:20 <raek> ah, I see... :-)
13:44:40 <arkeet> ttt_fff: kind error
13:44:43 <arkeet> what do you mean by Binary?
13:44:46 <Cale> Also note that x `seq` y `seq` z = y `seq` x `seq` z
13:44:55 <ttt_fff> arkeet: I mean Data.Binary
13:45:01 <arkeet> yes
13:45:03 <arkeet> Binary is a class
13:45:04 <ttt_fff> hmm, oh, Binary is a Class
13:45:07 <ttt_fff> I'm an idiot
13:45:13 <ttt_fff> let me see what Binary converts objects to
13:45:29 <arkeet> it's for serializing stuff to ByteStrings.
13:45:42 <arkeet> lazy ones.
13:45:58 <arkeet> and unserializing.
13:46:06 <raek> Oh. Turns out Data.Conduit.List.fold is strict.
13:46:27 <arkeet> foldr is strict.
13:46:33 <ttt_fff> arkeet: while you're here, what is Blob? I'm reading https://hackage.haskell.org/package/haste-compiler-0.4/docs/src/Haste-Binary.html
13:46:36 <raek> I was afraid that it would build up lots of nested thunks, but clearly it will not.
13:46:49 <ttt_fff> basically I'm using Haste, but I don't like their "auto serialiation" stuff as I need to store stuff in a postgresql
13:47:37 <arkeet> looks similar to Data.Binary.
13:47:48 <arkeet> hm.
13:48:32 <arkeet> except with BlobData instead of ByteString
13:50:51 <EvanR> totally should have named ByteString BlobDatas
13:51:06 <arkeet> well in haskell land BlobData *is* ByteString.
13:51:14 <arkeet> in js land it's some js value I guess.
13:51:27 <EvanR> js has bytestring nows
13:51:47 <arkeet> I don't know anything about haste.
13:51:48 <arkeet> or js.
14:00:22 <ttt_fff> in haskell, how does 'Bytestring' and 'Text' differ ?
14:01:09 <napping> Bytestring is bytes, Text holds unicode
14:02:03 <cfoch> people
14:02:06 <cfoch> how can I import
14:02:07 <cfoch> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc/Module.html
14:02:07 <cfoch> ?
14:02:36 <orzo> what's the modern way to load haskell plugins into a compiled haskell program?
14:02:50 <napping> "import Module"?
14:02:58 <orzo> well, no, its compiled
14:03:05 <napping> not you
14:03:18 <napping> cfoch: you need to tell something you want to use the ghc package, but then you can just import it
14:03:20 <cfoch> napping: import Module does not work
14:03:26 <napping> what's the error?
14:03:34 <cfoch>   Could not find module ‘Module’
14:03:34 <cfoch>     It is a member of the hidden package ‘ghc-7.8.4’.
14:03:49 <napping> right, so add ghc to your cabal file, or add a -package ghc flag
14:03:53 <orzo> you just need to add ghc to the list of package dependencies
14:04:30 <orzo> or don't use cabal to build, if its a simple program, you can use ghc directly and it might be what you want
14:04:46 <cfoch> I could do it thanks
14:05:03 <napping> the "-package ghc" flag is if you're using ghc directly or testing in ghci
14:05:52 <int-e> you can also run  ghc-pkg expose ghc  but it's generally a bad idea because of the package's flat namespace.
14:06:05 <orzo> i remember back in the day, there was a package hs-plugins or something like that.  Is that still best practice for plugins?
14:06:09 <int-e> (ghc-pkg hide ghc  will undo that operation)
14:06:27 <int-e> oh and you need write access to the global package database for this to work anyway
14:08:30 <nitrix> Hi
14:08:32 <nitrix> untilSuccess :: (a -> Maybe b) -> [a] -> Maybe b
14:08:53 <nitrix> I there a way I could replace this by an existing combination of prelude functions or do I need my own ultility function?
14:10:01 <geekosaur> @index catMaybes
14:10:01 <lambdabot> Data.Maybe
14:10:06 <geekosaur> :t catMaybes
14:10:07 <lambdabot> [Maybe a] -> [a]
14:10:16 <geekosaur> mm, not quite
14:10:21 <nitrix> geekosaur: I do not have a list of maybes though.
14:10:28 <S11001001> nitrix: msum, map
14:10:34 <EvanR> :t find
14:10:34 <lambdabot> (a -> Bool) -> [a] -> Maybe a
14:10:41 <EvanR> :t isJust
14:10:42 <lambdabot> Maybe a -> Bool
14:10:54 <geekosaur> :t head . mapMaybe
14:10:55 <lambdabot>     Couldn't match type ‘[a] -> [b]’ with ‘[c]’
14:10:55 <lambdabot>     Expected type: (a -> Maybe b) -> [c]
14:10:55 <lambdabot>       Actual type: (a -> Maybe b) -> [a] -> [b]
14:10:55 <nitrix> It's a combination of catMaybes and map I think
14:11:07 <geekosaur> whoops
14:11:10 <S11001001> @ty \f -> msum . map f
14:11:11 <lambdabot> MonadPlus m => (a1 -> m a) -> [a1] -> m a
14:11:24 <nitrix> Where Maybe would be a MonadPlus ?
14:11:24 <S11001001> nitrix: m = Maybe
14:11:47 <nitrix> Interesting.
14:11:53 <nitrix> :t msum
14:11:54 <lambdabot> MonadPlus m => [m a] -> m a
14:12:06 <nitrix> I guess I need to look at MonadPlus.
14:12:17 <geekosaur> nitrix: you do if you map your a -> Maybe b over a list of a
14:12:17 <nitrix> S11001001: Appreciated.
14:12:22 <S11001001> nitrix: np
14:12:32 <nitrix> :)
14:12:45 <int-e> :t mconcat . map ?f
14:12:46 <lambdabot> (Monoid c, ?f::a -> c) => [a] -> c
14:13:18 <S11001001> int-e: Monoid (Maybe e) lifts the e semigroup (encoded as Monoid)
14:13:56 <int-e> S11001001: right. I was just checking, should've done that a bit earlier.
14:20:21 <jfourk> hello
14:21:36 <prsteele> hello
14:21:58 <jfourk> has anyone read "Programming in Haskell" by Graham Hutton ?
14:22:12 <jfourk> I need a little bit of help in chapter 8 :) 
14:22:48 <glguy> jfokkan: There are probably a bunch of people who can help who aren't looking at chapter 8, too
14:23:28 <jfourk> well, first of all thanks :)
14:23:37 <jfourk> the chapter builds some parsers 
14:23:53 <jfourk> and defines an operator >>=
14:24:09 <jfourk> then it describes a so called "do-notation"
14:24:30 <jfourk> but when I type the code in GHCi, there are lots of errors
14:24:42 <jfourk> I searched a bit on the internet, and in the book's site
14:24:55 <jfourk> and the author has made available a source file that uses "monads" 
14:25:16 <glguy> If you want help with some code you've written you can paste it on http://lpaste.net/new/haskell
14:25:34 <glguy> then we can see it and try to figure out what's going wrong
14:25:38 <jfourk> Oh OK, i ll paste it immediately
14:26:40 <lpaste> jfourk pasted “error with do notation” at http://lpaste.net/124802
14:27:39 <jfourk> now, in the book, "ret" is writtern "return", but this gives another error with Prelude.return 
14:27:57 <ReinH> I believe you need the rebindable syntax extension
14:28:03 <ReinH> So that you can use the (>>=) in scope for do notation
14:28:24 <hpc> or make it an instance of Monad
14:28:31 <hpc> it appears to be correct for it
14:28:33 <ReinH> Or that.
14:28:49 <ReinH> move ret and >
14:28:51 <ReinH> er
14:29:02 <ReinH> move ret and >>= into an instance Monad Parser where clause and rename ret to return
14:29:16 <jfourk> the file that the author has on its site makes it an instance of Monad
14:29:23 <jfourk> but has not talked about monads yet
14:29:39 <ReinH> Ah. You should do that then.
14:29:52 <ReinH> Monad is just a typeclass for types with definitions of return and >>=
14:30:00 <shachaf> jfourk: Yes, the code in that book won't run as-is.
14:30:04 <hpc> instance Monad Parser where return = your definition of ret; (>>=) = your definition of (>>=)
14:30:21 <hpc> then toss the existing ret and (>>=)
14:30:41 * bergmark >>='s
14:30:54 <jfourk> thank you for your help
14:30:57 <raek> wow. driving an attoparsec tokenizer using conduit turned out to be a one-liner... :D
14:31:08 <hpc> you'll learn what it means shortly, i would assume
14:31:17 <hpc> or already know from previous stuff on type classes
14:31:31 * hackagebot preprocess-haskell 0.0.1.0 - Preprocess Haskell Repositories.  http://hackage.haskell.org/package/preprocess-haskell-0.0.1.0 (bsummer4)
14:31:38 <jfourk> in the book type classes are even later than monads I think
14:32:55 <hpc> neat
14:32:59 <hpc> anyway, let it be magic for now
14:33:06 <jfourk> thanks :)
14:33:13 <hpc> but keep it in the back of your mind, to revisit later so it makes sense
14:34:23 <phaazon> @hoogle mconcatMap
14:34:24 <lambdabot> No results found
14:34:26 <phaazon> :(
14:34:39 <EvanR> :t foldMap
14:34:40 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
14:35:37 <phaazon> > foldMap (\x -> if x < 10 then Just (show x) else Nothing) [1..9]
14:35:39 <lambdabot>  Just "123456789"
14:35:43 <phaazon> > foldMap (\x -> if x < 10 then Just (show x) else Nothing) [1..10]
14:35:44 <lambdabot>  Just "123456789"
14:35:50 <phaazon> great
14:35:53 <phaazon> thanks EvanR :)
14:36:05 <phaazon> the name is pretty weird though
14:36:11 <EvanR> i just realized what that was, i was looking for mconcat map yesterday
14:36:33 <phaazon> I used monoïdal concatMap more often than the list specialization one
14:36:38 <phaazon> s/used/use
14:37:11 <phaazon> I guess it’s Foldable
14:37:13 <phaazon> @index foldMap
14:37:13 <lambdabot> bzzt
14:37:17 <phaazon> dammit
14:37:21 <phaazon> @hoogle foldMap
14:37:23 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
14:37:23 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
14:37:23 <lambdabot> Data.IntMap.Strict foldMapWithKey :: Monoid m => (Key -> a -> m) -> IntMap a -> m
14:37:27 <EvanR> yes its Foldables main thing
14:39:23 <ttt_fff> is there someway for me to write code as [1, 2, 3, 4, 5] >-> f1 >-> f2 ... instead of writing: map f2 $ map f1 $ [1, 2, 3, 4, 5] --- the LHS seems "natural flow" and the RHS seems "backward flow"
14:40:07 <EvanR> (map f2 . map f1 . ...) [1,2,3,4,5]
14:40:31 <jophish> Ugh, why isn't Integral a => [b] -> a -> Maybe b in the prelude
14:40:32 <ttt_fff> yeah, that's backward flow
14:40:36 <ttt_fff> I don't think f2, f1, lst
14:40:41 <EvanR> function application for some reason happens on the left side
14:40:44 <EvanR> f x
14:40:44 <ttt_fff> I think ... here's my lsit of numbers, I want to transform them with f1, then I want to transform them with f2
14:41:00 <ttt_fff> right ; but I want to think in terms of "how does the data flow" ?
14:41:02 <EvanR> and function composition reflects this in g o f
14:41:16 <ttt_fff> yes, but is there no way for me to express ideas in terms of data flow?
14:41:20 <EvanR> the data flows left, into the function
14:41:33 <ttt_fff> yeah, but I read left -> right, not right -> left
14:41:34 <Nik05> ttt_fff but we use that all the time f a is also "backwards"
14:41:36 <ttt_fff> do you read right -> left ?
14:41:51 <ttt_fff> I read from left to right, from top to bottom
14:42:03 <EvanR> what youre calling data flow is a backwards notion relative to your reading from left to right, but if i indeed reversed it all, youd also need to read right to left! ;)
14:42:14 <ttt_fff> map h $ map g $ map f $ actual data .... . forces me to read "right to left"
14:42:20 <EvanR> dont use $, use .
14:42:44 <ttt_fff> that would be map (h . g . f) actual data ....
14:43:04 <EvanR> if you wanted everything from left to right youd also need myArgument (f . g . h) like oop chaining
14:43:14 <EvanR> also called postfix
14:43:23 <EvanR> now *thats* backwards ;)
14:43:31 <EvanR> "reverse polish"
14:44:10 * EvanR urges ttt_fff to reconsider the idea that data flows from left to right
14:44:22 <EvanR> or top to bottom, or whatever
14:44:52 <ttt_fff> well, I read things left to right, top to bottom
14:44:59 <Nik05> haskell is a little inconsistent with this though, >== is left to right
14:45:30 <exio4> @type (>>>) 
14:45:31 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
14:45:45 <exio4> there, "left to right" composition 
14:45:48 <EvanR> ttt_fff: me too, thats why i usually write the end of my function first, the follow the rest of the definitions backwards down the where clauses
14:46:05 <EvanR> i bet people think thats weird too
14:46:19 <ttt_fff> EvanR: like f g h, where f = ... g = ... h = ... ?
14:46:29 <ttt_fff> hmm, I tend to always use let, never where
14:46:38 <EvanR> foo where foo = bar x y z, x = ..., y = .., z = ...
14:46:41 <ttt_fff> i thikn thats an issue of top down vs bottom up
14:46:43 <merijn> ttt_fff: Ick
14:46:51 <merijn> ttt_fff: Let looks so ugly :(
14:47:00 <ttt_fff> TIL: #haskell hates my coding style
14:47:03 <ttt_fff> lol
14:47:10 <merijn> ttt_fff: Do you use braces and tabs too? :p
14:47:18 <EvanR> ttt_fff: well no completely. there are reversed versions of all the operators
14:47:20 <ttt_fff> next you're going to tell me that instead of do { ... ; .... ; ... ; } I should use white space indenting
14:47:29 <EvanR> oh gross
14:47:44 <merijn> You'd fit right in with SPJ :p
14:47:52 <Nik05> but there is also =<< :)
14:47:54 <merijn> Just make sure to put the ; at the start of a line
14:48:02 <merijn> >>= and =<< are both ugly
14:48:08 <merijn> >=> master-race!
14:48:11 <quchen> BOOO merijn 
14:48:20 <merijn> Kleisli fish is judging you all
14:48:21 <exio4> (=<<) is cute, liar! 
14:48:23 <Nik05> merijn not <=< ?
14:48:26 <sinelaw> fishes
14:48:31 <JoshieAS> is there a Haskell conference?
14:48:48 <merijn> JoshieAS: Plenty, assuming you don't mean "haskell only"
14:49:03 <JoshieAS> if I could only go to one, which should I shoot for?
14:49:07 <merijn> "ICFP: where Haskell counts as a mainstream language!"
14:49:10 <S11001001> JoshieAS: where are you?
14:49:12 <sinelaw> JoshieAS, there are haskell meetups around the world, and a Haskell Symposium conference adjunct to the function programming one
14:49:15 <ReinH> merijn: Hey now :p
14:49:16 <JoshieAS> Portland, Oregon
14:49:22 <ReinH> JoshieAS: Oh, me too.
14:49:24 <merijn> JoshieAS: Go to OPLSS
14:49:26 <sinelaw> *functional
14:49:39 <ReinH> Or ICFP/CUFP, which is in Vancouver BC
14:49:43 <JoshieAS> sweet, what 'hood you live in?
14:49:48 <merijn> JoshieAS: Oregon Programming Languages Summer School at UO, I had a great two weeks there last year
14:49:58 <ReinH> JoshieAS: Well technically I live in Washington, but just over the river.
14:50:13 <merijn> Also, one of the best PL summer schools around
14:50:16 <JoshieAS> oh cool, Vancouv?
14:50:22 <phaazon> hm, is there a way to pattern match with variable?
14:50:23 <JoshieAS> merijn: I'll check it out
14:50:31 <phaazon> like
14:50:44 <phaazon> foo k e = case e of { KeyPressed k -> … }
14:50:49 <merijn> If I could sucker my supervisor into paying for it I'd go to OPLSS every year >.>
14:51:06 <merijn> phaazon: No
14:51:25 <phaazon> foo k e = case e of { KeyPressed k' | k == k' -> … }
14:51:26 <phaazon> I guess then
15:01:32 * hackagebot preprocess-haskell 0.0.1.1 - Preprocess Haskell Repositories.  http://hackage.haskell.org/package/preprocess-haskell-0.0.1.1 (bsummer4)
15:04:03 <jophish> on that topic, why isn't listToMaybe called head
15:04:45 <EvanR> the partial head is a convenient hack for quick code golfing, having to muck with a maybe when Nothing is impossible can be annoying
15:05:09 <EvanR> like you might end up using fromJust instead :S
15:05:34 <JoshieAS> Rein do you ever go to the PDXFunc meetups?
15:06:21 <jophish> EvanR: that's a good point and it's obviously too late to change it now, but it's a shame that that wasn't called justHead or unsafeHead or something
15:07:21 <EvanR> jophish: or coolHead ;)
15:07:38 <EvanR> cool kids use to feel cool
15:07:50 <jophish> while I'm being all hotHeaded here. Why on earth does !! take a *signed* integer
15:07:52 <sinelaw> or just "dead"
15:08:12 <EvanR> same situation Int is more convenient as a common agreed integer type
15:08:21 <EvanR> so you dont have to much with a Word conversion every other line of code
15:08:35 <EvanR> (of course Integer might be a better common integer type)
15:09:04 <jophish> I wonder if numeric prelude sorts this out
15:09:24 <EvanR> restricting to unsigned kind of doesnt buy you that much
15:09:39 <int-e> > map (init . tails) . tail . inits $ [1,2,3]
15:09:41 <lambdabot>  [[[1]],[[1,2],[2]],[[1,2,3],[2,3],[3]]]
15:09:49 <EvanR> if you accidentally had a negative Int, and converted, you suddenly have a huge valid (probably wrong) value rather than an error
15:10:18 <EvanR> > fromIntegral (-3) :: Word
15:10:20 <lambdabot>  18446744073709551613
15:10:29 <jophish> EvanR: that's an excellent point
15:11:32 * hackagebot llvm-general 3.3.13.4 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.13.4 (BenjaminScarlet)
15:11:55 <int-e> > head $ filter (\x -> x `mod` 2 == 0 && x `mod` 3 == 0 && x `mod` 5 == 0) [1 :: Integer ..] -- and how about this safe use of 'head'...
15:11:56 <lambdabot>  30
15:12:25 <int-e> (filtering an infinite list can never result in [])
15:13:07 <jophish> a more succinct example might have been:
15:13:12 <athan> how are constraint solvers used in functional programming? Can they be a utility, or more for implementation? How easy is it to implement a (SAT) constraint solver in a purely functional language?
15:13:13 <jophish> > head [0]
15:13:14 <lambdabot>  0
15:13:15 <EvanR> jophish: supposedly you can fix all of this with dependent types ;)
15:13:31 <jophish> EvanR: yeah, I've yet to do more than dip my toes into Idris
15:13:31 <ReinH> head is useful when you want to maintain your own "is this list empty?" invariants
15:13:49 <ReinH> I prefer to let the type system maintain invariants that the type system is capable of maintaining
15:13:53 <jophish> ReinH: in an ideal world those invariants would be encoded in the type :)
15:13:56 <sinelaw> oy, Set isn't Traversable
15:14:03 <athan> jophish: Software Foundations book is incredible btw
15:14:09 <ReinH> jophish: And indeed they can be.
15:14:13 <athan> and "advanced topics in types and programming languages" is also super awesome
15:14:57 <sinelaw> Is there a mapM for Data.Set?
15:14:59 <jophish> athan: I'll take a look, thanks!
15:16:00 <EvanR> sinelaw: theres toList ;)
15:16:20 <sinelaw> true
15:16:28 <jophish> would a RULE filter (const False) as = [] be sensible?
15:16:33 * hackagebot th-expand-syns 0.3.0.6 - Expands type synonyms in Template Haskell ASTs  http://hackage.haskell.org/package/th-expand-syns-0.3.0.6 (DanielSchuessler)
15:17:18 <int-e> sinelaw: I think you have to rebuild the tree anyway, so a dedicated mapM won't buy you much.
15:17:35 <sinelaw> int-e, furthermore the effect order would be undefined, no?
15:18:16 <int-e> sinelaw: right... that doesn't sound very useful
15:18:25 <sinelaw> toList it is
15:19:04 <sinelaw> but now I just have Set.toList . Set.fromList
15:19:30 <sinelaw> is there something better for that? Just want to eliminate duplicates according to  Ord
15:19:56 <sinelaw> nub?
15:20:07 <int-e> sinelaw: that's pretty good unless you want some additional laziness...
15:20:25 <int-e> nub is expensive for lists with many distrinct elements
15:20:34 <jophish> http://neilmitchell.blogspot.co.uk/2015/02/nub-considered-harmful.html
15:21:51 <sinelaw> jophish, thanks!
15:22:03 <jophish> sinelaw: your welcome!
15:22:08 <jophish> you're*
15:22:09 <jophish> ahh
15:22:35 <octalsrc> is there a non-syntactic-sugar way of saying [a], like (Data.List.List a) or something?
15:22:40 <sinelaw> actually I can do better than that nubOrd thing
15:23:03 <octalsrc> I want to make [a] a part of a typeclass without enabling FlexibleInstances
15:23:15 <octalsrc> s/part/instance/
15:23:18 <sinelaw> because my type is Int, using radix sort as edwardk was mentioning the other day
15:23:33 <jophish> octalsrc: [] a
15:24:47 <octalsrc> jophish: hmm, it still says that isn't a "distinct type variable"
15:24:47 <sinelaw> @faq does haskell answer all of ttt_fff 's questions?
15:24:48 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
15:24:58 <octalsrc> when I do "([] Char)" specifically
15:25:16 <ttt_fff> sinelaw: haskell or #haskell ?
15:25:22 <ttt_fff> one's a language, the other is a group of people
15:25:31 <shachaf> octalsrc: Yes, instance Foo [Char] isn't a valid Haskell 2010 instance.
15:26:24 <octalsrc> oh, so any "Data a" type requires FlexibleInstances?
15:26:33 * hackagebot llvm-general 3.4.4.4 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.4.4.4 (BenjaminScarlet)
15:31:57 <S11001001> octalsrc: no, just when you supply a value for a
15:32:26 <S11001001> octalsrc: for example, instance Monoid a => Monoid (Maybe a) is legit
15:33:04 <arkeet> it's a shame that instance sucks.
15:33:07 <octalsrc> huh
15:33:25 <benzrf> arkeet: what sucks about it
15:34:11 <arkeet> it ought to be Semigroup a => Monoid (Maybe a), where mempty = Nothing 
15:34:32 <S11001001> arkeet: maybe someday
15:34:32 <pragprogger> I'm having a hard time picking between OCaml and Haskell. I've tried both, still really hard. I haven't dove deep in either of them, just small projects, nothing like what I have at work. Any advice on picking one?
15:35:11 <arkeet> pick haskell. (I might be biased though.)
15:35:11 <S11001001> pragprogger: keep trying until they're easier; then you'll have a good idea of pros and cons
15:36:33 <Big_G> What is your favorite exampled of a monad
15:37:21 <sinelaw> pragprogger, IMHO, Haskell has the advantage of encouraging better and more useful abstractions (e.g. Functor/Applicative/Traversable etc.), while ocaml may be better at some other software engineering aspects (better module system, easier to reason about performance)
15:37:48 <sinelaw> pragprogger, the question is more what you're trying to achieve
15:37:54 <sinelaw> why are you interested in these
15:38:01 <jophish> is it idiomatic to rely on fail?
15:38:05 <pragprogger> sinelaw: on the contrary, some OCamlers suggested that OCaml discourages the kind of type-laziness that he claims Haskellers have given in to abusing in Haskell to make really awful types
15:38:06 <ski> jophish : "would a RULE filter (const False) as = [] be sensible?" -- i think not
15:38:15 <pragprogger> sinelaw: But I didn't fully understand him.
15:38:16 <ski> jophish : "rely on fail" meaning ?
15:38:19 <arkeet> jophish: I would discourage using fail at all.
15:38:22 <pragprogger> sinelaw: I'm writing a large-ish web app.
15:38:36 <jophish> rely on the functionality of the fail function in Monad
15:38:39 <sinelaw> jophish, banish it completely?
15:38:50 <sinelaw> fail is a huge hack
15:38:56 <jophish> I'm under the impression that it's a bit of a wart
15:38:57 <sinelaw> fail is a huge fail
15:39:08 <jophish> but it would be so convenient here
15:39:12 <arkeet> what for?
15:39:21 <S11001001> Big_G: Co (Cofree Maybe)
15:39:22 <ski> `fail' could be a member of `MonadFail'
15:39:26 <jophish> ski: out of interest, why? (regarding the filter rule)
15:39:37 <sinelaw> pragprogger, i'm not sure what that means
15:39:44 <ski> jophish : because that's not just an optimization. it changes behaviour
15:39:57 <pragprogger> sinelaw: just a web app with lots of sub-components that talks to a database and spits out html/css/js
15:40:04 <arkeet> > filter (const False) [1..]
15:40:08 <lambdabot>  mueval-core: Time limit exceeded
15:40:09 <sinelaw> pragprogger, I haven't written a big web app in haskell or ocaml
15:40:27 <jophish> arkeet: I have a table of type [[a]], and I'd like to extract some things fitting [[foo], bar:bars]
15:40:32 <sinelaw> pragprogger, but haskell does have two active communities, yesod and snap
15:40:38 <jophish> just pattern matching with that is very succinct
15:40:42 <sinelaw> (and many other libraries)
15:40:45 <pragprogger> sinelaw: what do you write in Haskell?
15:41:01 <sinelaw> pragprogger, a type inference engine, and at work a build system
15:41:34 <sinelaw> pragprogger, I'm not sure what the ocaml person told you about types in haskell, it sounds weird
15:42:04 <pragprogger> me neither
15:42:04 <sinelaw> pragprogger, http://yesodweb.com/
15:42:14 <jophish> under what circumstances would one depend on that never terminating? Shouldn't a clever enough compiler be able to determine that 'filter (const False)' will never yeild any values
15:42:19 <pragprogger> I think he meant abusing monads and functors to make general APIs that shouldn't use them?
15:42:40 <mpickering> jophish: How is the data in that format? sounds like you maybe want a custom datatype rather than using lists?
15:42:56 <jophish> mpickering: this is for the function extracting things from the table into that data type :)
15:42:59 <arkeet> > filter (const False) undefined
15:43:00 <lambdabot>  *Exception: Prelude.undefined
15:43:05 <jophish> mpickering: I'm parsing some htlp using tagsoup
15:43:06 <arkeet> jophish: it changes strictness.
15:43:16 <jophish> html*
15:43:22 <sinelaw> pragprogger, sounds like a weak argument. if someone did that, it's just an example of abusing feature X in language Y. Haskell doesn't encourage it
15:43:30 <jophish> arkeet: ah, of course :)
15:43:47 <ski> .. perhaps one could sometimes argue that Haskell community encourages "overworked" types .. but "type-laziness" sounds more like some dynamically typed languages, to me
15:44:02 <pragprogger> sinelaw: ah ok
15:44:25 <sinelaw> pragprogger, take a look at yesod, or alternatively at snap, and decide for yourself
15:44:30 <arkeet> or happstack
15:44:44 <sinelaw> or whatever, just make sure the thing is maintained and active
15:44:53 <ski> jophish : "Shouldn't a clever enough compiler be able to determine that 'filter (const False)' will never yeild any values" -- that would be an invalid improvement
15:45:38 <ski> pragprogger : anyway, both languages are interesting
15:46:08 <sinelaw> pragprogger, as a haskell user my main/only problem is unpredictable runtime behavior 
15:46:13 <jophish> I guess I'm looking for the neatest way of going from [[a]] to Maybe (some type T a a [a]), where the elements are arranged [[x], y:zs]
15:46:30 <pragprogger> sinelaw: you mean performance bottlenecks/surprises?
15:46:30 <arkeet> case?
15:46:46 <sinelaw> pragprogger, not unpredictable, just I personally don't understand it fully
15:47:13 <pragprogger> oh
15:47:15 <sinelaw> pragprogger, mostly memory usage
15:47:19 <arkeet> predicting performance of haskell code is more difficult, but not impossible.
15:47:22 <pragprogger> sinelaw: ah right
15:47:35 <pragprogger> arkeet, sinelaw: I have that same problem in Clojure though.
15:47:44 <Denommus> pragprogger: what are you looking for in a language?
15:47:54 <sinelaw> pragprogger, I think ocaml is supposed to be more straightforward in that respect, but I don't really know.
15:48:03 <S11001001> jophish: myfun [[x], y:zs] = Just (x, y, zs); myfun _ = Nothing
15:48:14 <Denommus> pragprogger: OCaml makes some things "easier" by not being pure. If you want mutability you can just use a reference and there you have it
15:48:37 <jophish> S11001001: I've just typed that out! It clicked as soon as I posted to the channel, how could I have overlooked it :) Thanks!
15:48:58 <Denommus> pragprogger: Haskell is pure, and lazy, which may make some things easier, though
15:49:04 <sinelaw> pragprogger, also, as a "functional" language, ocaml has a huge wart in not having a useful syntax for function composition (due to the value restriction)
15:49:08 <pragprogger> Denommus: I'm not sure. Just something to make writing a web app less error prone.
15:49:15 <pragprogger> sinelaw: oooh good point
15:49:27 <pragprogger> I have noticed Haskell code looks more like Clojure than OCaml code.
15:49:32 <sinelaw> pragprogger, which in my opinion makes it pseudo-functional
15:49:38 <Denommus> pragprogger: the biggest OCaml framework has a very, very singular approach on that
15:49:45 <ski> sinelaw : .. only matters for polymorphic code, though
15:49:59 <sinelaw> ski, which is only general code, who needs it?
15:50:10 <pragprogger> Denommus: which?
15:50:17 <sinelaw> generic/reusable/whatever
15:50:46 <ski> sinelaw : of course commonly much code is polymorphic (depending). just saying that for monomorphic stuff, there's no problem
15:50:53 <sinelaw> ski, true
15:50:59 <Denommus> pragprogger: you write the entirety of your application in OCaml, marking some parts that will run in the client or both the client and server (by default the code runs only on the server)
15:51:24 <pragprogger> Denommus: oh right js_of_ocaml
15:51:25 <pragprogger> thanks
15:51:26 <Denommus> pragprogger: and the framework will handle compiling OCaml to either native code on the server side or JavaScript on the client side
15:51:34 <pragprogger> Thanks everyone for your very helpful feedback.
15:51:40 <pragprogger> I think I've made my decision.
15:51:46 <Denommus> pragprogger: Haskell does have a Haskell-to-JavaScript compiler
15:51:51 * ski hopes the decision is to learn both
15:52:01 <sinelaw> node.js!
15:52:05 <Denommus> pragprogger: but you can't use the same approach as OCaml yet
15:52:23 <Denommus> (actually, it has two: Haste and GHCJS)
15:52:26 <pragprogger> ski: There's no use becoming proficient at both when one will do.
15:52:58 <Denommus> pragprogger: well, the two are similar on the surface, but very different when you use them a lot
15:53:05 <Denommus> pragprogger: I really recommend knowing both :-)
15:53:40 <pragprogger> Oh wait one more question.
15:54:00 <pragprogger> I saw || defined in Haskell in terms of infinite lazy recursion. Is that kind of super-confusing thing common in Haskell?
15:54:10 <randir> I need to check if a string is a case-insensitive infix of another string.
15:54:17 <Denommus> pragprogger: yes
15:54:30 <Denommus> pragprogger: you get used to it
15:54:42 <randir> Is there a good way to do this, without simply flattening both strings to lowercase?
15:54:45 <stelleg> edwardk: enjoyed your learning to learn talk, thanks for that
15:54:49 <S11001001> pragprogger: it's not confusing; recursive functions are "infinite lazy recursion", when it comes down to it.
15:54:58 <pragprogger> My concern is, well, I'm not always at my sharpest, and some days I just can't comprehend very clever code very well, so I usually write very simple code.
15:55:06 <S11001001> pragprogger: OK I'm being facetious.  It is confusing when you first encounter it.  But it's really not, in the long run.
15:55:17 <sinelaw> pragprogger, source?
15:55:39 <pragprogger> sinelaw: hm?
15:55:45 <sinelaw> for what you saw? 
15:55:46 <pragprogger> "source code" yes
15:55:48 <pragprogger> oh
15:55:50 <pragprogger> Let me see...
15:55:57 <mauke> wait, how can you define || recursively?
15:56:03 <sinelaw>  that's what I'm wondering
15:56:10 <pragprogger> I may be misremembering it, and I'm not sure I'll ever remember the source.
15:56:14 <pragprogger> It was one of the basic operators though.
15:56:20 <pragprogger> Maybe && or something.
15:56:27 <randir> pragprogger: sometimes simply code is better than clever code. The nice thing about haskell is that a lot of things can be expressed simply/elegantly, even if it's tough to learn first.
15:56:29 <mauke> the standard definition is: True || _ = True; _ || x = x
15:56:30 <pragprogger> It was demonstrating the advantage of lazy evaluation.
15:56:33 <Denommus> pragprogger: out of coincidence, another user is asking the same in #ocaml
15:56:45 <mauke> it's lazy, sure
15:57:02 <randir> I think what it's talking about probably is short-circuit evaluation, but it's not recursive.
15:57:22 <nkar> why does cabal fail to include *.hs files used by the testsuite?  the directory layout is as follows: tests/Test.hs, tests/Test/*.hs  the ones matching the wildcard are not included.  will it be right to add them to extra-source-files in the .cabal file?
15:57:26 <JohnnyL> what is?
15:57:32 <randir> in a strict evaluation language, you have to explicitly make something like || to be short-circut
15:57:48 <randir> meaning that True || True will only evaluate the first operand
15:57:55 <randir> but False || True will evaluate both
15:58:13 <randir> in Haskell, || and && both short-circuit by merit of the language being lazy. 
15:58:43 <shachaf> i,i True || _ = True; _ || False = False; x || y = y || x
15:58:59 <randir> oh but guys, any nice way to check if a string is a case-insensitive infix of another string?
15:59:04 <randir> Or ByteString in this case
15:59:49 <mauke> how do you define case for a ByteString?
15:59:50 <mniip> randir, you'd rather say 'True || ⊥ = True' 'False || ⊥ = ⊥'
15:59:54 <randir> I could char-by-char go through and say "if a == b or (switchCase b) then True else False" for each element, but seems hackish
16:00:01 <sinelaw> randir, 
16:00:01 <sinelaw> @hoogle ByteString -> ByteString -> Bool
16:00:01 <lambdabot> Data.ByteString isInfixOf :: ByteString -> ByteString -> Bool
16:00:01 <lambdabot> Data.ByteString.Char8 isInfixOf :: ByteString -> ByteString -> Bool
16:00:01 <lambdabot> Data.ByteString isPrefixOf :: ByteString -> ByteString -> Bool
16:00:14 <sinelaw> oh case insensitive 
16:00:16 <mniip> @hoogle uncons
16:00:16 <lambdabot> Data.ByteString.Char8 uncons :: ByteString -> Maybe (Char, ByteString)
16:00:16 <lambdabot> Data.ByteString.Lazy.Char8 uncons :: ByteString -> Maybe (Char, ByteString)
16:00:16 <lambdabot> Data.ByteString uncons :: ByteString -> Maybe (Word8, ByteString)
16:00:16 <mauke> randir: if X then True else False better written as X
16:00:17 <sinelaw> :/
16:00:21 <randir> mauke: true, in this case it's an encoded string so I just unpack it
16:00:34 <mauke> randir: huh?
16:00:39 <JoshieAS> Cale: I'm having trouble figuring out my Leaf case on that homework
16:01:11 <randir> I mean it's a ByteString data-type but it encodes UTF8 I believe, so I can make it into a String type. 
16:01:35 <mauke> hmm, so unicode rules apply probably
16:01:40 <mauke> this is nontrivial
16:02:34 <randir> At this point I'm only really caring about alphabetic substrings, along with a few chars like space, hypen, and apostrophe 
16:02:45 <Cale> JoshieAS: okay
16:02:47 <mauke> yes, that's where the trouble is
16:02:48 <randir> Overall case-insensitive unicode would be rather untrivial 
16:02:52 <mauke> non-alphabetic chars don't have case
16:03:10 <Cale> JoshieAS: So, if the tree is empty, and you insert something into it, which tree should the result be?
16:03:32 <JoshieAS> (Node (Leaf) LogMessage (Leaf))
16:03:41 <Zohan> Where Phantom?
16:03:42 <Cale> right (schematically at least)
16:03:48 <JoshieAS> that part I get
16:03:56 <JoshieAS> but let's say I get to the "end" of a tree
16:03:59 <Cale> The "LogMessage" there ought to be the actual value you're inserting
16:04:00 <randir> I could turn A into a regex
16:04:15 <mauke> there's some stuff in http://hackage.haskell.org/package/text-icu-0.7.0.1/docs/Data-Text-ICU.html
16:04:20 <JoshieAS> let's say I do this:
16:04:23 <randir> where each alphabetic char allows for it's upper or lower case, with certain non-alphabetics being hardcoded
16:04:43 <JoshieAS> insert LogMessage (Node (Leaf) LogMessage' tree2)
16:05:04 <JoshieAS> if my timeStamp from LogMessage is less than my timestamp for LogMessage'
16:05:19 <JoshieAS> what would my resulting Node be?
16:05:45 <JoshieAS> How would I reference the new tree greater than?
16:05:58 <Cale> be careful here, LogMessage/LogMessage' aren't valid names for a variable, since they start with an uppercase letter -- they'd have to be data constructors.
16:06:05 <jophish> On the topic of partial functions. Why isn't read typed Read a => String -> Maybe a
16:06:14 <Cale> Which case is this you're worried about?
16:06:16 <JoshieAS> aye aye, I'm substituting them for my LogMessage values
16:06:31 <JoshieAS> in my code I am pattern matching the log messages
16:06:54 <Cale> You shouldn't have to worry about which particular left and right subtrees are there -- you're just going to insert into one of them recursively
16:06:54 <mauke> jophish: for your convenience
16:07:06 <JoshieAS> hrm, I'm still confused
16:07:09 <randir> mauke: yeah, "CaseInsensitive" in Data-Text-ICU looks like it might work
16:07:10 <Cale> If it's a Leaf, then you end up inserting into a Leaf
16:07:15 <Cale> which is fine
16:07:51 <JoshieAS> I understand what to do if my initial timestamp is greater than the node's
16:08:06 <JoshieAS> I run insert on the same LogMessage but with the second tree as my input now
16:08:57 <JoshieAS> so you're saying if the initial timestamp is lesser, I should just return (Node (Leaf) logMessage (Leaf))?
16:09:04 <randir> jophish: That is a good question
16:09:23 <randir> Why  *isn't* read of type Read a => String -> Maybe a ?
16:09:34 <JoshieAS> oh shit I think I get it now
16:09:35 <jophish> randir: mauke has an answer
16:09:42 <mauke> not a very good one
16:09:48 <mauke> I think Read is misdesigned
16:10:22 <mniip> randir, for easy use
16:10:35 <mniip> if you want to fine-tune it there are other functions in that typeclass
16:10:53 <randir> Hmm
16:10:59 <mniip> :t reads
16:11:00 <lambdabot> Read a => ReadS a
16:11:01 <jophish> mauke: yeah, that was the same answer I got for head
16:11:15 <mniip> hmm not that one
16:11:16 <Cale> JoshieAS: I'm saying that you shouldn't care about whether the subtrees on the left and right are leaves or not. You're going to recursively insert into one or the other depending
16:11:27 <Cale> JoshieAS: but in any case, it shouldn't matter
16:11:34 <mauke> head is less clear because it can be replaced by (\(x:_) -> x)
16:11:47 <JoshieAS> ah, I gotcha now
16:11:48 <mauke> defining read is a bit more tricky
16:11:55 <Zohan> Who want to look Silky Smooth?
16:12:05 <randir> also head has a really easy, efficent way to check if it will not fail
16:12:05 <mniip> ah right
16:12:07 <mniip> that one
16:12:11 <randir> simply see if the list is non-empty
16:12:13 <mniip> given type ReadS a = String -> [(a, String)] 
16:12:21 <randir> whereas read you have to parse to tell if you can parse it, basically.
16:12:36 <mauke> you just use reads
16:12:45 <mauke> or readMaybe, as defined in some library somewhere
16:12:50 <hexagoxel> nkar: paste the cabal file?
16:12:52 <randir> yeah
16:12:58 <shachaf> readMaybe is defined in Text.Read
16:15:48 <JoshieAS> Cale: can you look over my final code?
16:15:54 <nkar> hexagoxel: that's what I ended up doing: https://github.com/nkaretnikov/titlecase/blob/master/titlecase.cabal  seems to work, no warnings on cabal check either.
16:17:02 <Cale> JoshieAS: sure
16:19:58 <hexagoxel> nkar: seems you can add stuff to other-modules in the test-suite
16:19:58 <JoshieAS> okay, I shot you a message with it
16:22:41 <nkar> hexagoxel: hm, let me try that...
16:22:42 <hexagoxel> nkar: you can look at Cabal itself (they must know what they are doing :); they have some stuff used _by_ the tests in extra-source-files, but the test-suite-relevant stuff in other-modules.
16:22:43 <hexagoxel> https://github.com/haskell/cabal/blob/master/Cabal/Cabal.cabal
16:23:00 <nkar> hexagoxel: I've looked at lens :)
16:26:35 * hackagebot control-monad-exception 0.11.2 - Explicitly typed, checked exceptions with stack traces  http://hackage.haskell.org/package/control-monad-exception-0.11.2 (PepeIborra)
16:27:28 <nitrix> Hi, I'd like to write a function untilSuccess :: (a -> Maybe b) -> [a] -> Maybe b
16:27:47 <arkeet> :t catMaybes
16:27:48 <lambdabot> [Maybe a] -> [a]
16:27:48 <nitrix> Someone suggested:   msum . map f    it works, except, I was wrong.
16:28:05 <arkeet> hm, that might do it.
16:28:08 <arkeet> what's wrong with it?
16:28:10 <nitrix> It's actually an IO, and it doesn't work with MonadPlus anymore.
16:28:15 <arkeet> oh.
16:28:18 <nitrix> fetchFirstAvailable :: [Resource] -> IO (Maybe RawBlock)
16:28:26 <nitrix> Is the actual function I'm trying to implement
16:28:32 <arkeet> what's Resource?
16:28:42 <arkeet> what is success?
16:29:13 <nitrix> A record data structure, it's a description of some id at a given server endpoint.
16:29:32 <nitrix> And success is determined by being able to download that resource from the endpoint
16:29:49 <arkeet> so you have some Resource -> IO (Maybe RawBlock) lying around?
16:30:01 <nitrix> resourceFetch :: Resource -> IO (Maybe RawBlock)
16:30:03 <nitrix> Correct
16:30:11 <arkeet> what does the MonadPlus instance for MaybeT look like?
16:30:23 <nitrix> I didn't even know it had one o:
16:30:28 <nitrix> Let me see.
16:30:31 <arkeet> I think it does.
16:31:02 <arkeet> yeah it does.
16:31:10 <arkeet> and it'll do what you want.
16:31:36 <nitrix> arkeet: Mind sharing the link, I'm just recently getting into monad transformers.
16:31:44 <arkeet> https://hackage.haskell.org/package/transformers-0.4.0.0/docs/Control-Monad-Trans-Maybe.html
16:31:54 <arkeet> basically, MaybeT IO a = IO (Maybe a)
16:31:57 <arkeet> (in a newtype)
16:32:40 <arkeet> so wrap your resourceFetch results in MaybeT, msum those, and runMaybeT the whole thing.
16:35:05 <nitrix> arkeet: If you wouldn't mind, I understand functors, applicatives and monads, but what is the advantage of this monad transformer over IO (Maybe a)  ?
16:35:33 <arkeet> we're only using MaybeT for its MonadPlus instance.
16:35:40 <arkeet> :t msum
16:35:41 <lambdabot> MonadPlus m => [m a] -> m a
16:35:59 <arkeet> you could write your own [IO (Maybe a)] -> IO (Maybe a) and use that too.
16:36:04 <nitrix> It doesn't show up on hackage though. Maybe that's where my confusion comes from.
16:36:08 <arkeet> it's in transformers package
16:36:31 <arkeet> in Control.Monad.Trans.Maybe
16:37:43 <nitrix> Ah, sorry, it was a typo on my part I think. 4th instance:  Monad m => MonadPlus (MaybeT m)
16:38:19 <nitrix> There we go, interesting. After couple weeks, things are starting to glue themselves tohether :)
16:39:00 <SrPx> Is there a standard function that does this? `splitEvery 3 [1..15] == [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15]]
16:39:44 <arkeet> chunksOf, from Data.List.Split
16:39:49 <arkeet> > chunksOf 3 [1..10]
16:39:50 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
16:39:58 <SrPx> Thanks!
16:42:39 <xpilot> hello
16:42:57 <sinelaw> xpilot, hello
16:43:24 <xpilot> question about the vinyl package: what is the updated way to use fields?
16:44:00 <xpilot> the documentation at http://www.jonmsterling.com/posts/2013-04-06-vinyl-modern-records-for-haskell.html appears to be out of date
16:44:10 <xpilot> as Vinyl no longer has a Data.Vinyl.Field module
16:44:49 <sinelaw> xpilot, hello
16:44:58 <sinelaw> wrong window. :P
16:45:33 <xpilot> sinelaw, hello :)
16:47:51 <xpilot> in particular I can't seem to find the triple colon (:::) operator that appears in the tutorial anywhere
16:53:48 <Big_G> If I wanted some invariany to be true about a value, would I want to use a monad?
16:54:38 <Cale> Big_G: not enough information
16:56:01 <Big_G> Cale, I don't have a specific example but let's say I want to make sure an Int is greater than 5. Would it be best to use a GT5 Int monad?
16:56:08 <Cale> no
16:56:19 <Cale> also, that's not likely to even be the right kind of thing to be a monad
16:56:28 <Cale> A monad has to be a type constructor
16:56:59 <Cale> and it has to allow an arbitrary type to be its type argument
16:57:01 <Big_G> So what is the best way to acheive that goal beyond making sure it is gt5 at every point?
16:57:28 <napping> Usually you make a new type and control the constructors
16:57:34 <Cale> Maybe have a module where you define a newtype GT5 = MkGT5 Int
16:57:41 <napping> newtype GT5 = GT5 Int, don't export the GT5 constructor
16:58:11 <Cale> and then define functions for constructing GT5 values that enforce the invariant, and don't export MkGT5 from the module
16:58:32 <napping> a Monad has to let you "return" any value you like
16:58:51 <Cale> :t return
16:58:52 <lambdabot> Monad m => a -> m a
16:59:04 <napping> If GT5 was your monad it wouldn't be the result value as in GT5 Int that it's controlling
16:59:07 <Cale> The implementation of return can't tell what type a is
16:59:15 <Cale> it has to work uniformly for all types
16:59:17 <napping> (you could equally well have return "Hi" :: GT5 String)
16:59:31 <Big_G> napping, True but can't you have two possible values like maybe and have some error handling on the lt5 case?
16:59:39 <napping> What you might do is make it some kind of state monad that holds a value and doesn't let you get at it directly
17:00:21 <napping> like maybe you'd have incValue :: GT5 () and decValue :: GT5 Bool as commands in the monad, and never even let the client get at the value directly
17:00:47 <napping> that's generally a lot less nice that just making a type that always enforces the invariant
17:01:37 * hackagebot satchmo 2.9.5 - SAT encoding monad  http://hackage.haskell.org/package/satchmo-2.9.5 (JohannesWaldmann)
17:04:02 <nkar> hexagoxel: yes, it works, thanks
17:04:37 <nitrix> Can I lift a "IO ()" to a "MaybeT IO ()" in a "do" block ?
17:04:50 <arkeet> :t lift
17:04:51 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
17:05:12 <arkeet> :t liftIO
17:05:13 <lambdabot> MonadIO m => IO a -> m a
17:05:15 <nitrix> How come it didn't work... oh damn, the import.
17:05:17 <xnil> woah, the ST monad is really cool
17:05:18 <arkeet> either of those will do it.
17:05:30 <xnil> what's the difference in ST and State?
17:05:35 <arkeet> a lot.
17:05:50 <simon> xnil, ST is optimizable.
17:05:59 <arkeet> they don't have much in common.
17:06:00 <xnil> simon: in what sense?
17:06:13 <xnil> arkeet: i'll look into State more in-depth and go through some exercises.
17:06:38 <arkeet> State you can write yourself (and you may already have).
17:06:39 <arkeet> ST is magic.
17:06:43 <nitrix> arkeet: Is it idiomatic to have lot of `MaybeT IO a` in your code and lifting (there's actually only 1 case) ? 
17:07:12 <nitrix> arkeet: Or should I fallback to IO (Maybe a) in the other cases where I don't need the extra functionality?
17:07:43 <arkeet> nitrix: depends.
17:07:55 <nitrix> The wrapping of do blocks and running gets tiresome, but I can see them being useful in the long run.
17:08:25 <arkeet> I would use MaybeT just in places where the behaviour it provides is useful.
17:08:48 <simon> xnil, read ch. 4 of http://ncatlab.org/nlab/files/WadlerMonads.pdf
17:08:49 <arkeet> like if I want early exiting or whatever.
17:09:39 <simon> xnil, ST will let you write code that is equivalent to updating a variable imperatively. as in, that's what it actually does, but only through static guarantee.
17:09:59 <nitrix> arkeet: So as early as possible, I should runMaybeT the computation to end up with my normal IO (Maybe a) ?
17:10:30 <nitrix> arkeet: Just like you usually try to eliminatet IO as early as possible?
17:10:52 <simon> xnil, whereas State is some very neat syntax for recursive functions that can also sometimes be optimized.
17:11:04 <arkeet> nitrix: where you end the MaybeT stuff affects your program's behaviour though.
17:11:59 <ReinH> How much of that stuff actually involves IO though? I think it would be better to use Maybe more and IO less.
17:14:48 <nitrix> ReinH: Mhm, it's the goal. I have like three layers: IO, MaybeT IO, Maybe
17:15:35 <nitrix> It's just the crossing between both is when most of the computation thing happens and my original case,   msum . map   seems like a perfect use case for MaybeT :)
17:25:26 <freshman> i have a random network.socket.bytestring.lazy question. is this the correct place to ask it?
17:25:47 <arkeet> yes
17:26:38 <freshman> ok - i am implementing a protocol with length-prefixed messages
17:26:43 <freshman> (over tcp)
17:27:14 <freshman> is this module the best way to do that sort of thing (because normal recv doesn't always recieve enough bytes)
17:28:21 <freshman> my current idea is using StateT ByteString with splitAt
17:31:32 <anonymous_> pl \x -> x + x
17:31:46 <arkeet> join (+)
17:31:49 <napping> You need @pl
17:32:10 <dmj`> freshman: are you familiar with attoparsec?
17:32:12 <acowley> freshman: What do you want to use splitAt for?
17:32:25 <xnil> @pl \x -> x + x
17:32:25 <lambdabot> join (+)
17:32:36 <freshman> yes - i'm currently using it for parsing what i am trying to recv
17:32:42 <xnil> > join (+) 5
17:32:43 <lambdabot>  10
17:32:50 <xnil> @src join
17:32:50 <lambdabot> join x = x >>= id
17:32:59 <xnil> @src id
17:32:59 <lambdabot> id x = x
17:35:06 <freshman> ah. is the usual apporach to this sort of problem parsing the entire stream (into a list of results that can be dealt with lazily)?
17:36:33 <Cale> I think splitting the stream, provided you can do it easily, and then parsing the individual parts (provided you can also do *that* easily) is not a bad approach.
17:37:00 <acowley> I still don't understand the need for the explicit splitting
17:37:15 <acowley> recv gives you up to the number of bytes requested
17:37:45 <acowley> So you want to wrap that in something that loops and deals with dropped connections
17:37:47 <semigroup> Hi, does anyone know how to prevent ghc from passing -undef to gcc?
17:38:14 <semigroup> I need some of the missing macros :(
17:38:16 <Cale> Well, okay, you could use an incremental parser, and in any case, you'd be parsing just one structure with your attoparsec parser or whatever.
17:38:31 <Cale> (rather than attempting to parse the entire stream with many)
17:38:42 <acowley> Right
17:38:48 <freshman> may general approach at this point has been to recv the length prefix (in this case 4 bytes), and then recv that many more, but now it is clear that this is just wrong
17:39:08 <acowley> That's not at all clear to me
17:39:28 <acowley> I think lazy IO with a network connection is just begging for terrible error messages
17:39:52 <Cale> Well, yeah, that's a good point, using lazy I/O with network stuff has a lot of problem
17:39:53 <Cale> s
17:40:08 <Cale> not the least of which is that sockets tend to be a very limited resource
17:40:09 <joeyh> heh, I just got an error message from ghc that included the entire last sentence of Joyce's Ulysses
17:40:09 <freshman> oh - the problem that i've run into is that the lengths of the second sorts of recvs don't always match the length prefix
17:40:43 <acowley> freshman: You mean you don't get back as many bytes as you asked for?
17:40:50 <funfunctor> hi
17:41:22 <freshman> yes that seems to be what is happening (but I am pretty new to this stuff)
17:41:28 <arkeet> that is normal.
17:41:41 <Cale> freshman: But yeah, check out the incremental parsing which attoparsec can do -- it doesn't matter how many bytes you shove in, if it's not yet enough to parse a complete record, then it'll tell you, and you can continue attempting to supply data as more comes in.
17:41:45 <acowley> freshman: That's why I suggested you wrap recv in a loop that does the error handling
17:42:04 <Cale> freshman: and if the input string spills over into the next record, it gives you the unused portion back
17:42:08 <freshman> ah - i think that my problem is using eitherResult from parsec, which throws out partials
17:42:16 <acowley> freshman: That way, if you know you need X bytes, but only got X - 4 and the connection drops, you can spit out an error value and decide what to do
17:42:34 <funfunctor> folks around who are well versed in Pipes?
17:42:51 <freshman> often, when i ask for 150 bytes (which was the lenfth prefix), i get those 150 bytes in 2 chunks
17:43:04 <acowley> freshman: That's totally normal
17:43:07 <joeyh> granted, it often feels that way when ghc is complaining at me, but this time, it was the actual liternal "... his heart was going like mad and yes I said yes I will Yes." :)
17:43:08 <HeladoDeBrownie> funfunctor, i don't know what "well versed" is, but depending on the question i might know the answer.
17:43:28 <freshman> alright - i'll start making use of partial results. thank you very much for your help
17:43:28 <Cale> joeyh: which error?
17:43:41 <lpaste> funfunctor pasted “No title” at http://lpaste.net/124808
17:43:59 <joeyh> I'd paste it, but it ran out of my scrollback
17:44:21 <freshman> have a good night, all.
17:44:36 <funfunctor> HeladoDeBrownie: i'm winding up with empty output from my pipeline. I think radioInterfaceSource is at fault.. its breaking the pipe with no more output when it should be looping as input comes in
17:44:38 <nshepperd> you could write a Stream instance for your socket type
17:45:37 <HeladoDeBrownie> funfunctor, it looks like you only yield once then exit
17:45:58 <funfunctor> HeladoDeBrownie: how do I, umm "fix that" ?
17:46:03 <arkeet> make it loop.
17:46:08 <HeladoDeBrownie> funfunctor, forever, perhaps
17:46:11 <HeladoDeBrownie> @type forever
17:46:12 <lambdabot> Monad m => m a -> m b
17:46:13 <arkeet> like how you made radioInterfaceSink loop.
17:46:16 <HeladoDeBrownie> or that, yeah
17:46:16 <arkeet> or with forever.
17:46:21 <HeladoDeBrownie> either one
17:46:28 <funfunctor> ok thx
17:46:43 <funfunctor> sorry, just very new to this.. feeling uneasy
17:46:47 <Cale> > fix error
17:46:49 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
17:47:01 <HeladoDeBrownie> no need to apologize, you got the answer you needed
17:47:24 <Adeon> I find exceptionception amusing
17:47:44 <Adeon> new forms of evil
17:47:52 <Adeon> throw an exception where showing the exception throws an exception
17:47:52 <arkeet> > fix fail
17:47:53 <lambdabot>  ""
17:48:27 <arkeet> hm, what monad is it defaulting to
17:48:36 <Cale> Adeon: and not just any exception, but the very same one
17:48:40 <arkeet> > return ()
17:48:41 <lambdabot>  No instance for (GHC.Show.Show (m0 ()))
17:48:41 <lambdabot>    arising from a use of ‘M17432752654519947576071.show_M17432752654519947576...
17:48:41 <lambdabot>  The type variable ‘m0’ is ambiguous
17:48:46 <arkeet> :t fail
17:48:47 <lambdabot> Monad m => String -> m a
17:48:52 <mniip> fail :: Monad m => [Char] -> m a
17:48:52 <arkeet> > return "hi"
17:48:54 <lambdabot>  No instance for (GHC.Show.Show (m0 [GHC.Types.Char]))
17:48:54 <lambdabot>    arising from a use of ‘M70153253471302224406089.show_M70153253471302224406...
17:48:54 <lambdabot>  The type variable ‘m0’ is ambiguous
17:48:55 <HeladoDeBrownie> arkeet, it's not. fail's type there only fits one
17:48:59 <mniip> m a ~ [] Char
17:49:04 <arkeet> oh you're right.
17:49:05 <arkeet> haha
17:50:23 <alexclark> on this section of learn you a haskell
17:50:24 <alexclark> http://learnyouahaskell.com/functors-applicative-functors-and-monoids#the-newtype-keyword
17:50:51 <alexclark> is there a typo in this line? newtype Pair b a = Pair { getPair :: (a,b) }
17:51:06 <Cale> > fix (map succ . show)
17:51:07 <lambdabot>  "#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]]^^__``aabbccdd...
17:51:07 <HeladoDeBrownie> looks fine to me
17:51:13 <HeladoDeBrownie> alexclark, what do you think the typo is?
17:51:27 <alexclark> im confused by the order switching of a and b in the example in the book
17:51:40 * hackagebot propellor 2.2.1 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-2.2.1 (JoeyHess)
17:51:46 <EvanR> alexclark: that might be on purpose
17:51:49 <HeladoDeBrownie> alexclark, they meant it that way, judging from the later output. so, it might just be the example is confusing.
17:52:01 <arkeet> alexclark: the whole point is that it switches the order.
17:52:04 <Cale> alexclark: The only point of defining that type was to swap the order of type parameters to (,)
17:52:15 <HeladoDeBrownie> oh, i see. i hadn't read the context
17:52:24 <arkeet> "But it seems like there's no way to do something like that with (a,b) so that the type parameter a ends up being the one that changes when we use fmap. To get around this, we can newtype our tuple in such a way that the second type parameter represents the type of the first component in the tuple"
17:53:08 <shelf> where should I look for IPC? I have a process I'd like to turn into a simple daemon and don't really want to roll something manually with sockets
17:53:19 <alexclark> oh arkeet missed that
17:53:55 <EvanR> shelf: use stdio ?
17:54:30 <shachaf> arkeet: i,i or use lens
17:54:37 <nitrix> Is it possible to write this more cleanly?   fetchFirstAvailable = msum . map (MaybeT . resourceFetch)
17:54:58 <arkeet> looks pretty clean to me.
17:54:58 <nitrix> It looks a little dubious, I'd prefer not to make resourceFetch a MaybeT IO a.
17:55:12 <arkeet> unwrap it at the end with runMaybeT
17:55:27 <arkeet> runMaybeT . msum . map (MaybeT . resourceFetch)
17:56:04 <funfunctor> HeladoDeBrownie: and would http://lpaste.net/124809 correctly send and recv data from files? anything look off there?
17:56:19 <alexclark> man haskell is hard haha
17:56:40 * hackagebot titlecase 0.1.0.0 - Convert English words to title case  http://hackage.haskell.org/package/titlecase-0.1.0.0 (NikitaKaretnikov)
17:57:02 <EvanR> alexclark: a lot of programming languages and computer stuff in general can be hard
17:57:17 <EvanR> if you get used to haskell, you may realize how hard ;)
17:57:25 <alexclark> EvanR: truth
17:57:41 <alexclark> EvanR: you mean it gets worse once you learn haskell?!?
17:57:50 <EvanR> everything you once knew gets worse
17:59:15 <shelf> I'll figure something out with unix sockets I guess
17:59:37 <EvanR> shelf: im liking pipes and stdio
17:59:47 <shelf> could you elaborate a little
18:00:01 <alexclark> is there a good way to grok functors, because im thinking this book is not going to be enough
18:00:02 <EvanR> each program has standard input, standard output, and standard error
18:00:07 <Cale> shelf: perhaps http://hackage.haskell.org/package/ipcvar would be useful to you?
18:00:18 <HeladoDeBrownie> funfunctor, i don't notice problems there, but that doesn't say much. you might be better off trying to run it and see.
18:00:24 <shelf> yeah, that's the closest I came across cale
18:00:25 <EvanR> they are just like sockets only you dont have to set them up
18:00:42 <joeyh> infiniteSteamOfConciousness :: Joyce -> StdGen -> [String]
18:00:48 <shelf> alright, got enough ideas to proceed probably :) thank
18:00:53 <funfunctor> HeladoDeBrownie: I did run it ofcourse, it just gets stuck recv nothing
18:00:59 * joeyh happily runs infiniteSteamOfConciousness ulysses g  .. and hugs haskell
18:01:28 <Cale> shelf: Depending what your use case is, you might also want to use bindings to zeromq or communicate using JSON with Aeson, or ... any number of other things
18:01:38 <HeladoDeBrownie> funfunctor, are you saying it blocks?
18:01:52 <EvanR> alexclark: several people have criticized lyah so it might just mean you need to find a different guide
18:02:22 <nitrix> arkeet: It's strange to wrap and run the MaybeT just to use msum ._.
18:02:28 <EvanR> alexclark: theres this one
18:02:32 <EvanR> @where cis194
18:02:32 <lambdabot> I know nothing about cis194.
18:02:37 <funfunctor> HeladoDeBrownie: well hmm idk if its easier for me to post the code, its a bit convoluted at the moment
18:02:41 <nitrix> arkeet: But at the same time, maybe it's the only way not to carry MaybeT's around.
18:02:41 <EvanR> http://www.seas.upenn.edu/~cis194/
18:03:19 <HeladoDeBrownie> funfunctor, since it's a logic error and not a type error, it might be one of your best recourses involves Debug.Trace.
18:03:22 <arkeet> nitrix: I wouldn't use MaybeT outside of that if you aren't using any MaybeT features.
18:03:40 <alexclark> EvanR: interesting - ill check it out.  thanks!
18:04:07 <Cale> shelf: There's the binary package which defines a bunch of reasonable binary encodings/decodings for many types, and gives you tools to write more
18:04:28 <EvanR> alexclark: but Functor is one of the simplest type classes. it basically generalizes this function map :: (a -> b) -> [a] -> [b] to other types besides list
18:04:29 <Cale> (which the IPCVar thing uses)
18:04:53 <shelf> i'll check out ipcvar, johnw is very clever
18:05:29 <arkeet> @where+ cis194 http://www.seas.upenn.edu/~cis194
18:05:29 <lambdabot> Okay.
18:05:46 <funfunctor> HeladoDeBrownie: I tried littering putStrLn's around seeing how I go down the action call stack
18:05:50 <funfunctor> It seems legit
18:05:57 <shelf> for context, I have a service that has to run as root, and right now I have a little repl for simple commands. it should probably be done via IPC, but can only allow access to root
18:06:10 <Cale> arkeet: It's worth noting that most people seem to be using Brent Yorgey's version of the course specifically http://www.seas.upenn.edu/~cis194/fall14/spring13/index.html
18:06:11 <alexclark> EvanR: I get that it implements fmap which just lets you use normal functions on uncertain data types, but even saying that, i dont realllllly get it
18:06:17 <shelf> so sockets are probably out
18:06:24 <HeladoDeBrownie> funfunctor, i suggested Debug.Trace because it lets you print debug non-IO stuff too
18:06:29 <EvanR> alexclark: im not sure thats the best explanation
18:06:43 <arkeet> @where+ cis194 http://www.seas.upenn.edu/~cis194/fall14/spring13/index.html
18:06:43 <lambdabot> Nice!
18:06:56 <alexclark> EvanR: hahaha yeah, still not quite up to the describing task
18:06:57 <mpickering> anyone know what causes "Prelude.chr: bad argument: 3946966" ?
18:07:20 <arkeet> yes, you gave it something too big.
18:07:24 <EvanR> > 3946966 > (maxBound :: Char)
18:07:25 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Char)
18:07:25 <lambdabot>    arising from the literal ‘3946966’
18:07:32 <arkeet> > 0x10ffff
18:07:33 <funfunctor> HeladoDeBrownie: its all IO
18:07:33 <lambdabot>  1114111
18:07:54 <EvanR> alexclark: do you get map?
18:08:00 <arkeet> > ord maxBound
18:08:02 <lambdabot>  1114111
18:08:22 <alexclark> yeah, its one of my favorite methods in ruby
18:08:26 <EvanR> good
18:08:41 <EvanR> they should shouldnt be surprised how this works
18:08:51 <EvanR> > fmap (+1) (Just 9)
18:08:53 <lambdabot>  Just 10
18:09:09 <EvanR> kjkasdf "then you should not be ..."
18:09:32 <funfunctor> HeladoDeBrownie: await should block until it has data right?
18:10:05 <shelf> mm named fifo + binary or cereal seems like the way to go
18:10:05 <alexclark> EvanR: yep, totally makes sense
18:10:10 <shelf> thanks friends
18:10:15 <EvanR> thats all there is to it
18:10:42 <EvanR> shelf: weird out for "EOF" on the named pipe
18:10:46 <EvanR> ... watch out
18:10:58 <shelf> will do
18:11:03 <EvanR> wtf is wrong with my typing
18:11:39 <acowley> I'm sure shelf was already planning on weirding out upon receipt of EOF
18:12:02 <shelf> does not take much to make me weird out
18:14:02 <funfunctor> HeladoDeBrownie: will that input <- lift $ BS.readFile "foo" ; (yield (input, 0)) >-> (radioInterfaceSink rd)  indeed yield all of the file
18:16:51 <EvanR> after enough juggling of fmaps, (fmap . fmap), fmap f <$>, and other shenanigans, im i going to have to stop worrying and learn to love lens
18:21:19 <HeladoDeBrownie> funfunctor, yes, await blocks waiting for input
18:22:25 <funfunctor> HeladoDeBrownie: I put a putStrLn show bs after the await in radioInterfaceSink and I don't see the file content being printed
18:22:46 <funfunctor> I think input <- lift $ BS.readFile "foo" ; (yield (input, 0)) >-> (radioInterfaceSink rd)  something is wrong here?
18:22:52 <HeladoDeBrownie> funfunctor, make sure the appropriate thing is yielding i guess? sorry, i might not be very helpful right now because i'm pretty distracted
18:23:36 <HeladoDeBrownie> i find it kind of suspicious though that you're doing a single yield there
18:23:41 <funfunctor> how does one check the BS.readFile is yield'ing?
18:23:54 <HeladoDeBrownie> put a print after the readFile maybe
18:24:13 <funfunctor> well I definitely know the file is being read in
18:24:27 <arkeet> so what is the question?
18:24:53 <funfunctor> does the file end up at the other end of the pipe here (yield (input, 0)) >-> 
18:25:25 <HeladoDeBrownie> the next await that the part after the >-> does will result in the single element, (input, 0), whatever input was
18:26:08 <funfunctor> HeladoDeBrownie: how can I get the LHS of the pipe shove down the whole file?
18:26:23 <HeladoDeBrownie> that's what it looks like it's doing, all at once
18:26:34 <arkeet> it's yielding the entire contents of the file.
18:26:37 <arkeet> at once.
18:27:04 <funfunctor> alight then why is it not printing on the other side of the pipe?
18:27:45 <HeladoDeBrownie> if that pipes computation gets run, the other side ought to be able to await exactly one element, then halt the next time it awaits, iirc
18:27:53 <funfunctor> I put a putStrLn show bs after line 17 here http://lpaste.net/124808#line17
18:28:21 <HeladoDeBrownie> and? does it output?
18:28:28 <funfunctor> not at all
18:28:39 <alexclark> if you make a type with record syntax, which only one attribute, does that default construction to just apply the value passed as that attribute?
18:28:54 <alexclark> *with only one
18:29:37 <HeladoDeBrownie> alexclark, if data Foo = Bar { myInt :: Int }, then Bar 20 :: Foo
18:29:41 <HeladoDeBrownie> alexclark, does that answer your question?
18:30:07 <funfunctor> HeladoDeBrownie: it does not even seem radioInterfaceSink is entered into
18:30:19 <HeladoDeBrownie> funfunctor, did you runEffect on the composed-together proxy?
18:30:23 <funfunctor> because a putStrLn before anything does not print
18:30:47 <funfunctor> HeladoDeBrownie: yea ofcourse, it would not type-check otherwise
18:30:51 <alexclark> HeladoDeBrownie: think so
18:31:21 <arkeet> alexclark: if it has multiple fields, then it's similar, you just have one argument for each field.
18:31:43 <alexclark> ohhh ok, so you can construct two ways
18:32:00 <EvanR> you also pattern match two ways
18:32:05 <alexclark> just with all the arguments, or with Bar {myInt = 20}
18:32:23 <alexclark> freakin awesome
18:32:26 <HeladoDeBrownie> alexclark, yeah
18:33:03 <HeladoDeBrownie> funfunctor, can you show enough of the code to debug it? simplify if necessary
18:33:06 <EvanR> turn on warnings to make sure you remember to define all the fields
18:34:43 <funfunctor> HeladoDeBrownie: I just pushed all of it https://github.com/victoredwardocallaghan/hbts/commit/a33fd0ceca29741f3bf5182c3c626f653f2fce41
18:34:47 <alexclark> helllllll yeah, i get it now.  So with the learn you a haskell example they were defining a partially applied Pair as a functor, hence the reversal!
18:35:47 <EvanR> > fmap pred ('x', 11)
18:35:49 <lambdabot>  ('x',10)
18:35:53 <funfunctor> HeladoDeBrownie: search for lift $ putStrLn "WOOOOT" on the page
18:36:05 <funfunctor> HeladoDeBrownie: not hitting there
18:37:06 <EvanR> alexclark: yeah, its instructive to consider why (,) cant be a Functor, only (e,) can
18:37:24 <alexclark> EvanR: but if i did > fmap pred Pair(11, 'x')
18:37:28 <pacak> :k (,)
18:37:28 <lambdabot> * -> * -> *
18:37:34 <pacak> :k (Int,)
18:37:34 <lambdabot> parse error on input ‘)’
18:37:35 <ReinH> alexclark: Same thing for Either
18:37:35 <alexclark> I'd get Pair(10, 'x')
18:37:50 <pacak> :k (,) Int
18:37:51 <lambdabot> * -> *
18:37:53 <EvanR> fmap pred (Pair 11 'x')
18:38:21 <ReinH> alexclark: parens are not used for function application in Haskell
18:38:26 <ReinH> and arguments are not separated by commas
18:38:46 <alexclark> but Pair takes a tuple
18:38:59 <EvanR> uhg
18:39:15 <EvanR> fmap pred (Pair (11,'x')), thats annoying
18:39:33 <alexclark> sorry, i realize im referencing something that not everyone following along with which is no fun
18:40:10 <EvanR> so arguments are sepated by commas when the function is taking a tuple argument ;)
18:40:36 <arkeet> no
18:40:42 <EvanR> jk
18:40:46 <arkeet> :p
18:40:52 <arkeet> the argument itself contains commas.
18:41:09 <verement> > (,) 11 ‘x’
18:41:10 <lambdabot>  <hint>:1:8: lexical error at character '\8216'
18:41:16 <alexclark> sweetttt thanks #haskell!
18:41:21 <ReinH> Pair(11,'x') is a rather unfortunate way to spell Pair (11, 'x')
18:41:40 <ReinH> Or, you could just use data Pair a b = Pair a b
18:41:42 * hackagebot bimap 0.3.0 - Bidirectional mapping between two key types  http://hackage.haskell.org/package/bimap-0.3.0 (joel_williamson)
18:41:43 <arkeet> verement: don't use "smart" quotes.
18:42:01 <arkeet> ReinH: no, the point is it's some LYAH example.
18:42:10 <arkeet> a newtype for reversing the type arguments of (,)
18:42:10 <funfunctor> HeladoDeBrownie: idk if this is somehow related? http://hackage.haskell.org/package/pipes-bytestring-2.1.1/docs/Pipes-ByteString.html
18:42:10 <ReinH> arkeet: :(
18:42:11 <verement> arkeet: yeah, stupid autosubstitute
18:42:13 <HeladoDeBrownie> funfunctor, something seems weird to me about that but i'm not quite sure what. what if you read the file inside of the producer, instead of in a computation that gets >>='d with it?
18:42:28 <EvanR> newtype Pair a b = Pair { unpair :: (b,a) }
18:42:37 <HeladoDeBrownie> i really don't know if that'd make a difference but it's the thing about it that seems weird
18:42:38 <ReinH> Well, that's rather annoying.
18:42:43 <arkeet> it's an example.
18:42:46 <HeladoDeBrownie> i've never tried >>=ing together multiple Proxys.
18:42:49 <ReinH> An annoying example :p
18:42:52 <arkeet> :p
18:42:54 <alexclark> ReinH: haha, sorry
18:42:57 <HeladoDeBrownie> afair
18:43:07 <HeladoDeBrownie> actually wait, i totally have. just not quite like that
18:43:10 <EvanR> ReinH: dont you want to fmap the other side sometimes!
18:43:14 <alexclark> ReinH: you were helpful though.  Use spaces like a normal human being...
18:43:21 <ReinH> EvanR: Yes, but I wouldn't call it Pair for starters.
18:43:28 <verement> > (,) 11 'x'
18:43:29 <lambdabot>  (11,'x')
18:43:40 <ReinH> EvanR: and also bifunctor exists, even if it isn't used much
18:43:44 <HeladoDeBrownie> funfunctor, so, i don't know if i'll be of much help to you here
18:44:02 <ski>   fmap pred Pair {unpair = (11,'x')}  -- better :)
18:44:08 <funfunctor> HeladoDeBrownie: ok thx, whats your best shot in the dark though?
18:44:13 <ReinH> data Pair a b = Pair a b; data OpPair a b = OpPair b a <- would be less confusing
18:44:19 <HeladoDeBrownie> funfunctor, the thing i just said
18:44:19 <funfunctor> mine is something to do with lazyness
18:44:32 <funfunctor> HeladoDeBrownie: I didn't understand that sorry
18:44:49 <funfunctor> well I sort of did, just not enough to try anything
18:44:56 <HeladoDeBrownie> computationThatReadsThenYield >-> radioInterfaceSink rd
18:45:05 <arkeet> @let newtype Pair b a = Pair { getPair :: (a,b) }
18:45:07 <lambdabot>  Defined.
18:45:09 <HeladoDeBrownie> rather than reading, then composing that with an effect that yields, etc.
18:45:14 <arkeet> > fmap pred (Pair (11,'x'))
18:45:15 <lambdabot>  Could not deduce (GHC.Base.Functor (L.Pair GHC.Types.Char))
18:45:15 <lambdabot>    arising from a use of ‘GHC.Base.fmap’
18:45:15 <lambdabot>  from the context (GHC.Num.Num b, GHC.Enum.Enum b)
18:45:20 <arkeet> oh.
18:45:27 <arkeet> @let deriving instance Functor (Pair a)
18:45:28 <lambdabot>  Defined.
18:45:29 <arkeet> oh.
18:45:31 <arkeet> > fmap pred (Pair (11,'x'))
18:45:32 <lambdabot>  No instance for (GHC.Show.Show (L.Pair GHC.Types.Char b0))
18:45:32 <lambdabot>    arising from a use of ‘M84181314504734115087056.show_M84181314504734115087...
18:45:32 <lambdabot>  The type variable ‘b0’ is ambiguous
18:45:38 <arkeet> :(
18:45:50 <arkeet> @let deriving instance (Show a,Show b) => Show (Pair a b)
18:45:51 <lambdabot>  Defined.
18:45:52 <arkeet> > fmap pred (Pair (11,'x'))
18:45:53 <lambdabot>  Pair {getPair = (10,'x')}
18:46:20 <funfunctor> HeladoDeBrownie: ah ok got it
18:46:33 <funfunctor> and I think your right
18:46:42 <funfunctor> this is a interesting artifact
18:46:56 <HeladoDeBrownie> i really don't know if that's the answer, but it's worth a try anyway
18:47:10 <HeladoDeBrownie> beyond that, good luck. i actually should be getting gone soon
18:49:55 <funfunctor> thx again
18:54:56 <Zer000> is there any way to write "(bmin + bmax) `quot` 2" without having 2 be an Int? bmin and bmax so far only have to be any Ord and I would rather keep it more general than Int
18:55:18 <arkeet> 2 isn't an Int.
18:55:26 <nshepperd> :t quot
18:55:26 <lambdabot> Integral a => a -> a -> a
18:55:29 <arkeet> :t 2
18:55:29 <lambdabot> Num a => a
18:56:14 <Cale> If you want to do addition, you need more structure than Ord, and same goes for integer division. Integral is the most general you'll get there.
18:56:31 <Axman6> Zer000: bmin and bmax also need to be Num if you're using (+)
18:56:41 <Zer000> so which is it Num or Integral?
18:56:44 <Zer000> or both?
18:56:50 <ski> `Integral'
18:56:51 <Axman6> All Integrals are Numas
18:56:52 <Cale> Integral is a subclass of Num
18:56:54 <Zer000> oooh
18:56:56 <Axman6> s/as/s
18:57:04 <Zer000> thanks!
18:59:01 <timothyh> named pipes not working out so well
19:00:02 <timothyh> bet it's EOF
19:00:10 <EvanR> weird out
19:01:28 <EvanR> for named pipe an EOF is probably something you want to catch then continue reading
19:01:54 <EvanR> catch react if appropriate continue
19:02:29 <timothyh> actually I was being silly and using System.IO readline rather than the stuff from posix 
19:02:40 <EvanR> hGetLine should work
19:03:24 <EvanR> assuming the user isnt malicious enough to enter in an unlimited line
19:03:50 <timothyh> with hGetLine it's terminating immediately, I need it to block
19:04:01 <EvanR> it blocks until it gets a line
19:04:09 <Axman6> you may also want to use openBinaryFile if changes of encoding might be an issue
19:04:43 <applyconcat> What is your preferred method of working around the record syntax name collision problem?
19:05:01 <EvanR> ignore it
19:05:20 <Cale> Yeah, just ignore it, add some little tag to make the names different.
19:05:24 <applyconcat> Does it rarely cause you problem?
19:05:33 <Cale> Yeah, very rarely
19:05:36 <applyconcat> Thanks for input.
19:05:55 <applyconcat> I find that my system is already designed with IO in mind, so porting to Haskell should be a synch.
19:06:14 <applyconcat> *cinch
19:06:26 <timothyh> doesn't block, halts immediately due to EOF
19:06:28 <Cale> applyconcat: Think of the field names as names of functions for extracting the fields, and it will make more sense why they ought to be named differently (and how you ought to name them)
19:06:47 <EvanR> timothyh: right, EOF is an exception. you need to catch that, its not a normal value that gets returned
19:06:52 <applyconcat> Cale: isn't that technically exactly how it's implemented?
19:06:54 <Cale> yes
19:07:07 <Cale> You really do get such functions
19:07:26 * ski prefers the way e.g. SML clearly distinguishes between the field names, and the field accessor functions
19:08:07 <EvanR> timothyh: you dont want it to block when EOF occurs, youd block for eternity
19:08:11 <ski> (if `foo' is the field name, then `#foo' is the field accessor function)
19:08:34 <applyconcat> ski: why do you prefer that?
19:08:52 <applyconcat> ski: it seems to simplify things to have the field names literally just be functions that access that field
19:09:01 <timothyh> eh, don't I? I'm waiting for something to write to the pipe...
19:09:16 <EvanR> timothyh: you will never get anything until the EOF is taken care of
19:09:17 <applyconcat> ski: thus everything is either a value or a function which is really just a non-terminal value
19:09:22 <timothyh> oh
19:09:35 <timothyh> I am probably muddled up conceptually, I'll thrash around a bit more
19:11:57 <ski> applyconcat : because imnsho it's confusing to have `foo :: Int' in one context, but then have `foo :: Blah -> Int' in another context
19:12:23 <applyconcat> ski: and in Haskell they are different?
19:12:28 <nitrix> Does things like MaybeT / runMaybeT actually add an additional runtime cost or it's solely to make the type system happy?
19:13:03 <ski> writing `MkBlah { foo = foo otherBlah + 1 , ... }' looks confusing. on the left of `=', `foo' has one type, on the right it another type
19:14:01 <ski> nitrix : the data constructor for a `newtype' is typically implemented as an O(0) operation
19:14:39 <applyconcat> ski: oh I see your point
19:16:02 <applyconcat> Thanks, I am encouraged to try writing something in Haskell.
19:16:19 <ski> applyconcat : something like `MkBlah { #foo = otherBlah #foo + 1 , ... }' would be acceptable, i think
19:16:54 <EvanR> applyconcat: you might not need as many records as you think
19:16:56 <timothyh> huh. so I had the pipe opened with ReadMode, and opening it ReadWriteMode gave the blocking behaviour I wanted
19:16:57 <ski> (it being understood that this means roughly `let this #foo = otherBlah #foo + 1; ... in this')
19:17:34 <EvanR> timothyh: >_> it blocks in read mode too, unless you crash from an uncaught eof
19:17:57 <timothyh> it certainly didn't block
19:18:05 <EvanR> ._.
19:18:12 * EvanR creates a named pipe
19:18:44 <applyconcat> ski: #foo is a valid identifier in Haskell?
19:19:03 <applyconcat> EvanR: I imagine I usually need them for representing models (Person, Car, etc)
19:19:13 <EvanR> applyconcat: maybe
19:19:33 <applyconcat> Any recommendations for a first Haskell project for someone familiar with FP and basic Haskell?
19:22:43 <ski> @type let #foo = () in #foo
19:22:43 <lambdabot> parse error on input ‘#’
19:22:54 <ski> applyconcat : not even with `MagicHash' ..
19:23:21 <applyconcat> oh ok
19:24:42 <EvanR> timothyh: yep... looks like openFile doesnt behave as expected on a fifo that has no writers
19:24:57 <EvanR> opening the file should block until theres a writer
19:25:06 <EvanR> theres this openFileBlocking :: FilePath -> IOMode -> IO Handle
19:25:20 <applyconcat> Is there a decent terminal UI library for Haskell? I'd like to make a small spreadsheet program with a usable UI.
19:25:31 <timothyh> applyconcat vty is ok. also vty-ui
19:25:49 <applyconcat> Thanks I'll try those again.
19:25:57 <applyconcat> But I couldn't get a simple hello-world working with them last time.
19:26:17 <EvanR> i used Text.PrettyPrint.Boxes to layout tables of text
19:26:21 <timothyh> EvanR I don't mind keeping it open as a writer, think much could go wrong there?
19:26:32 <EvanR> timothyh: yeah dont do that
19:27:50 <timothyh> welp. sockets it is.
19:28:11 <EvanR> ...
19:28:46 <applyconcat> Is it very common in Haskell to model side-effects as a sequence of operation descriptions which will be applied in order, the result of each being passed to the next, with appropriate operation metadata (error strings, success value(s), etc), and have a top-level function responsible for executing them in a very standardized way?
19:28:59 <EvanR> timothyh: the above replacement for openFile blocks until a writer shows up, essentially like accept would on a socket
19:29:35 <EvanR> which is how it would work in C
19:29:48 <timothyh> oh, missed that comment
19:29:58 <timothyh> thank, i'll take a look
19:30:06 <ReinH> applyconcat: I think you just described one use of monads.
19:30:22 <EvanR> at some point you will get a real EOF, in which case you can repeat the process
19:30:59 <ReinH> main can be seen as such a function*, for instance
19:31:07 <ReinH> * main isn't really a function, it's a value of type IO ()
19:31:30 <ReinH> (Ok, I think it can be of any IO type)
19:32:12 <applyconcat> ReinH: is it common to define the actual IO operation long with the other functions that build the operation description, but without the monad context, and just "lift" it into the monad context at the time you "run" the opertion?
19:32:45 <EvanR> "actual IO operation" ?
19:32:46 <applyconcat> I'm thinking of a database lib with two functions: buildOperation and runOperation
19:33:11 <applyconcat> where buildOperation would be "pure" and so would runOperation but runOperation would require a "database" thing instead of IO or something?
19:33:27 <EvanR> you cant manipulate raw IO operations, and also cant give the directive to run IO commands, its all done behind the scenes for you
19:34:24 <EvanR> applyconcat: main :: IO (), main is an IO command. the code you write for main is the "building"
19:34:39 <EvanR> then something runs it
19:35:03 <applyconcat> EvanR: right but i mean when defining the function that knows how to "run database operations"
19:35:21 <applyconcat> would it have to be impure ie, IO?
19:35:42 <EvanR> a command intended to interact with an external database will have to use IO
19:35:58 <EvanR> for example a socket send or recv
19:36:13 <applyconcat> oh ok so it cant just be "lifted" into IO context?
19:36:32 <applyconcat> im apparently confusing myself :)
19:36:44 <EvanR> you can wrap such interactions in other types in ways to help keep the usage straight
19:38:54 <applyconcat> is that common?
19:38:58 <EvanR> yeah
19:39:04 <applyconcat> ok thanks
19:39:11 <EvanR> its also common to just use IO directly
19:44:16 <applyconcat> i thought that was discouraged
19:44:35 <EvanR> using IO is discouraged?
19:44:45 <applyconcat> i thought
19:45:03 <EvanR> i think using IO for your entire program throughout is a bad idea
19:45:05 <pacak> EvanR: Some people can fortran in any languages.
19:45:12 <exio4> it's discouraged to abuse IO
19:45:18 <funfunctor> EvanR: yea don't touch the real world, IO is evil.. ;)
19:45:19 <exio4> using IO is perfectly fine
19:45:35 <EvanR> use IO for Input/Output of your program and maybe some other things which dont have a better place yet
19:45:47 <funfunctor> man having some real life IO issues here getting the radio hardware to be wrapped up in Pipes
19:47:47 <EvanR> put that in your pipes
19:48:14 <funfunctor> shits really hard to get right..
19:48:55 <EvanR> ffi stuff isnt easy
20:08:04 <ttt_fff> does haste (the compiler) have a good json => arbitrary object conversion tool?
20:27:08 <spaceships> i want to use some of the convenient superficial things from lens, without adding the dependencies, or all the typeclasses - are there any recommended alternatives?
20:27:51 <Cale> http://hackage.haskell.org/package/lens-family-core perhaps?
20:28:39 <funfunctor> My pipes work !!! I am a real Haskell man now
20:28:57 <EvanR> Haskellman man man ...
20:29:21 <funfunctor> what are these Lens things I keep hearing over and over again?
20:29:42 <funfunctor> just something to break the ice on the idea behind them will do
20:29:45 <spaceships> Cale: thanks, checking it out
20:30:23 <Cale> funfunctor: They're a way of referring to a part of an immutable data structure and performing operations such as extracting or replacing it
20:30:29 <EvanR> lenses, prisms, optics oh my
20:30:38 <Cale> (replacing it to obtain a new structure)
20:30:56 <arkeet> and they're *composable*
20:31:15 <funfunctor> Cale: great thanks, some kind of fancy morphism restriction'ism
20:31:29 <arkeet> a lens is basically a getter/setter pair
20:31:57 <arkeet> > view _1 ('a','b')
20:31:58 <lambdabot>  'a'
20:32:03 <arkeet> > set _1 'e' ('a','b')
20:32:04 <lambdabot>  ('e','b')
20:32:21 <Cale> Yeah, the earliest lens libraries defined a datatype like  data Lens a b = L { view :: a -> b ; set :: b -> a -> a }
20:32:31 <funfunctor> btw, check out these fancy curves https://github.com/victoredwardocallaghan/HaskellDSP
20:32:44 <arkeet> but you can compose them like so:
20:32:56 <arkeet> > view (_1._2) ((1,2),'b')
20:32:57 <lambdabot>  2
20:33:03 <arkeet> > set (_1._2) 4 ((1,2),'b')
20:33:05 <lambdabot>  ((1,4),'b')
20:33:15 <glguy> Lenses package has things like mapM on lists but for things other than lists. That turns out to be a really useful pattern and the library makes use of it in a bunch of ways
20:33:41 <arkeet> yeah there turn out to be all sorts of generalizations
20:34:31 <arkeet> > over _1 (+1) (3,5)
20:34:32 <lambdabot>  (4,5)
20:34:36 <arkeet> > over traverse (+1) [1,2,3]
20:34:37 <lambdabot>  [2,3,4]
20:34:49 <arkeet> so you can look at multiple targets.
20:35:04 <arkeet> idk
20:35:13 <arkeet> it's fun
20:50:25 <spaceships> Cale: lens-family-core is perfect. its only dependencies are base, containers and transformers
20:58:43 <JoshieAS> in a guard, what does '<-' represent?
20:58:50 <JoshieAS> | x <- y
20:59:06 <JoshieAS> | z <- y
20:59:19 <Hafydd> What is an example of a program that uses that?
20:59:24 <Cale> JoshieAS: Those are pattern guards
21:00:02 <Cale> x would be a pattern, and if the expression y matches, the variables in x are bound and the guard succeeds
21:00:11 <JoshieAS> I see
21:01:24 <Cale> (But where are you seeing this? It's not the most common language extension to see in the wild, but it tends to be really great when you need it.)
21:01:31 <JoshieAS> so if y is a String, x is an Int, and z is a String then the subsequent = for z will catch
21:01:39 <JoshieAS> I was looking at someone else's code and they did..
21:01:46 <JoshieAS> x <- y
21:01:53 <Cale> In which context?
21:01:58 <JoshieAS> sorry, | x <- y
21:02:02 <JoshieAS> = blah blah
21:02:05 <arkeet> pattern guards
21:02:10 <JoshieAS> so that the pipe and equals were lined up
21:02:16 <Cale> yeah okay
21:02:29 <Cale> Um
21:02:38 <Cale> No, x here must be a *pattern*
21:02:43 <JoshieAS> | x <- y
21:02:45 <JoshieAS> = blah blah
21:02:47 <JoshieAS> just like that
21:02:56 <Cale> It wasn't with just x and y though, was it?
21:03:09 <Cale> There would have been an actual pattern there, most likely
21:03:19 <JoshieAS> aye, I was just abstracting
21:03:30 <JoshieAS> but the syntax threw me off, I wasn't used to seeing guards like that
21:03:35 <JoshieAS> normally I just do pipes and equal signs
21:03:50 <JoshieAS> and have only seen <- in list comprehensions
21:04:08 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/Haskell/guards.html
21:04:23 <JoshieAS> yeah, I saw that
21:04:25 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#pattern-guards -- or from the GHC manual
21:04:33 <JoshieAS> didn't see that, oooo
21:05:38 <AshyIsMe> well damn, upgraded to ghc 7.8 and now lambdatwit refuses to build
21:05:57 <JoshieAS> so in | Just val1 <- lookup env var 1, if lookup env var 1 matches Just val1, the guard succeeds?
21:06:05 <Cale> right
21:06:15 <JoshieAS> shiiiiiieeeet, okay, now things are clear
21:07:20 <Cale> JoshieAS: and you can see there an example where they have multiple pattern guards separated by commas, and the later ones can use variables bound by the previous ones
21:07:33 <Cale> If any of the matches fails, it falls through to the next case
21:07:49 <JoshieAS> elegant, I like that style
21:29:47 <ttt_fff> is https://ghcformacosx.github.io/ trustworthy, or is this some randomass spyware + virus infested bloat pretending to be haskell ?
21:30:48 <bob_twinkles> why not use the haskell platform?
21:30:58 <bob_twinkles> there's an OSX release and it comes with useful things
21:31:12 <dmj`> ttt_fff: why not just get the latest ghc binary from ghc's site?
21:31:24 <dmj`> https://www.haskell.org/ghc/download
21:31:26 <ttt_fff> bob_twinkles: I need cabal install 1.22
21:31:54 <ttt_fff> dmj`: hmm, cai N get 7.10 via that ?
21:32:09 <gyaretto> Might anyone know how I can correctly do `for file in tests/ do cabal run < $file` ?
21:32:11 <ttt_fff> i probably can not, as latest is 7.8.4
21:32:21 <gyaretto> in bash.
21:32:27 <dmj`> ttt_fff: can you get ghc 7.10 via other means besides cloning from source?
21:32:29 <bob_twinkles> IIRC there's a way to get higher versions of cabal to download lower versions of cabal-install
21:32:41 <dmj`> ttt_fff: it hasn't been officially released unless I'm mistaken
21:32:59 <ttt_fff> dmj`: where is osx in https://www.haskell.org/ghc/download_ghc_7_8_4 ?
21:33:07 <dmj`> yea can download the latest cabal-install prebuilt for your architecture: https://www.haskell.org/cabal/download.html
21:34:10 <dmj`> ttt_fff: just use 7.8.3, is there a specific feature in 7.8.4 that you'd like to try that isn't in 7.8.3?
21:34:18 <ttt_fff> argh
21:34:20 <ttt_fff> I want ghcjs
21:34:24 <ttt_fff> which needs cabal-1.22
21:34:24 <ReinH> ttt_fff: ghcformacosx is fine, it's open source so you can look at it if you want
21:34:41 <ReinH> I've used it before
21:34:43 <ttt_fff> but cabal 1.22 scares me, as I only use stackage lts
21:34:56 <ReinH> there's nothing wrong with cabal 1.22 either
21:35:02 <ttt_fff> in trusting trust, can someone verify that ReinH is not the author of ghcformacosx? :-)
21:35:03 <dmj`> ttt_fff: ghcjs is an entirely different compiler
21:35:15 <EvanR> you can trust me
21:35:18 <EvanR> i swear
21:35:24 <ttt_fff> dmj`: yeah, but it's easier to install if you have cabal 1.22 .. . otherwise you have to build a separate js-cabal
21:35:32 <Hafydd> lol WoT
21:35:37 <ttt_fff> EvanR is like a self signed SSL certificate
21:35:41 <dmj`> ttt_fff: I use have 7.8.3 and 1.22 on osx, and I use ghcjs on the side
21:36:01 <ttt_fff> dmj`: how did you isntall ghcjs? did you have to build a separate cabal ?
21:36:13 <dmj`> ttt_fff: I followed the instructions on their github page
21:36:25 <dmj`> https://github.com/ghcjs/ghcjs
21:37:14 <dmj`> ttt_fff: It takes a long time to install
21:37:31 <ttt_fff> dmj`: i once had to install ubuntu inside of virtualbox just to build ghcjs
21:37:42 <ttt_fff> it takes forver to install, but I cna't get aeson to work with haste-compiler
21:37:50 <dmj`> ttt_fff: me too, those days are over though, they've really simplified things
21:38:17 <dmj`> ttt_fff: you only have to install it once
21:38:30 <dmj`> jle`: ping
21:40:19 <ttt_fff> dmj`: man in the middle intercepted pong
21:40:56 <EvanR> pong announcer "i dont think thats within regulation!"
21:41:29 <dmj`> jle` and I ESP one another
22:01:51 * hackagebot Redmine 0.0.3 - Library to access Redmine's REST services  http://hackage.haskell.org/package/Redmine-0.0.3 (cstpierre)
22:03:14 <dpwright> I have a question regarding haskell's FFI, specifically malloc and alloca and related functions
22:04:07 <dpwright> the functions are named after the equivalent C functions, and the names make sense because one allocates memory until it's explicitly freed and the other allocated memory until it "goes out of scope"
22:05:51 <dpwright> my question is, is that where the equivalence ends?  In C, I can expect that alloca will allocate the memory on the stack, which will be cheap and local to the current stack frame, whereas malloc will allocate on the heap, which is a bit slower and I can't make many guarantees about where in memory the allocation will be
22:06:09 <dpwright> in haskell, though, heap allocations are cheap ("incrementing a pointer", right?)
22:06:19 <dpwright> so does that distinction no longer exist?
22:06:48 <dpwright> are there any considerations I should make when choosing between the functions other than the scope I want the memory to exist in?
22:08:11 <bob_twinkles> I assume you've seen https://www.haskell.org/platform/doc/2014.2.0.0/ghc/users_guide/ffi-ghc.html ?
22:09:29 <dpwright> bob_twinkles: Ah, actually I haven't --- or, I think I might have once, but I'd forgotten about it.  I was looking at the documentation for the Foreign namespace on hackage.  This looks like a useful page to read -- thanks
22:09:54 <bob_twinkles> dpwright: google is my friend =P. glad to help
22:15:52 <dpwright> bob_twinkles: Yep, that page answers my question perfectly -- the answer is, as with C, alloca is cheaper than malloc and should be favoured where possible.  Thank you.
22:16:40 <bob_twinkles> no problem
22:17:02 <dpwright> another corollary which as far as I can tell isn't mentioned on that page, which is maybe interesting but not something I desperately need to know right now, is whether using alloca for reasonably large allocations is "less bad" than it would be in C, because in C that might blow the stack but presumably in haskell that's not a concern
22:17:39 <bob_twinkles> well, the page does say that it's backed by a haskell data structure so maybe it's fine?
22:17:52 <bob_twinkles> I'm not super familier with haskell's internal FFI though
22:18:04 <bob_twinkles> I suppose it's a simple-ish thing to test
22:18:25 <dpwright> yeah
22:18:40 <dpwright> I'll probably leave it for now because the thing I'm allocating right now is actually very small, so it doesn't matter
22:18:51 <dpwright> interesting thing to think about for the future though
22:46:03 <funfunctor> how do I read this? (lift . runStateT) :: MonadTrans t => StateT s m a -> t ((->) s) (m (a, s))
22:46:19 <funfunctor> I don't understand ((->) s)
22:46:43 <ski> `Foo -> Bar' is sugar for `(->) Foo Bar'
22:47:19 <ski> (which really means `((->) Foo) Bar' because `(->)', just like e.g. `Either', is curried)
22:47:24 <ski> @kind Maybe
22:47:25 <lambdabot> * -> *
22:47:27 <ski> @kind Either
22:47:27 <lambdabot> * -> * -> *
22:47:39 <ski> where that really means `* -> (* -> *)'
22:47:51 <pavonia> @kind (->)
22:47:52 <lambdabot> * -> * -> *
22:48:03 <ski> just like `(&&) :: Bool -> Bool -> Bool' really means `(&&) :: Bool -> (Bool -> Bool)'
22:48:29 <ski> so, in `t ((->) s) (m (a, s))', a partially applied `(->)' is passed to `t'
22:49:44 <ski> funfunctor : however, i'm not sure how useful `lift . runStateT' would be ..
22:51:56 <funfunctor> ski: thx
22:52:09 <funfunctor> yes its not useful, I am deep down in a maze of types
22:52:18 <funfunctor> just trying to find my way
22:52:27 <ski> what are you trying to do ?
22:56:10 <funfunctor> ski: I'm trying to work out type class dynamic dispatch
22:56:20 <funfunctor> ski: which means mtl/transformers
22:56:31 * ski couldn't have guessed :)
22:56:52 <ski> anything more concrete ?
22:56:59 <funfunctor> ski: mixed in with Pipe's types start to get complicated fast
22:57:06 <Maxdamantus> Types are all static in Haskell, no need for dynamic dispatch.
22:57:26 <Maxdamantus> unless it's part of modelling something at a different level.
22:57:46 <funfunctor> ski: well https://github.com/victoredwardocallaghan/hBTS
22:57:48 * ski suspects funfunctor meant more or less "calling a callback" by "dynamic dispatch"
22:58:27 <funfunctor> ski: just running out of battery on my laptop, I need to pop home and then i'll be back online in 5-6min
22:58:31 <ttt_fff> how do I build cabal packages taht are only available locally
22:58:40 <ttt_fff> i.e. I want to have a priate repo for packages I build
22:58:48 <funfunctor> brb
23:01:14 <rola> are there any style enforcers (a la perl's perl::critic) to make code more readable for other people
23:01:18 <fro_ozen> i think you just have to add --user to the runghc Setuh.hs configure
23:01:21 <fro_ozen> @ttt_fff
23:01:21 <lambdabot> Unknown command, try @list
23:01:42 <rola> beyond -Wall and hlint
23:01:58 <ttt_fff> does ghc have any nice tools to serailize data structures to text (besides aeson) ?
23:02:49 <dpwright> I am working with an API (the FFI API, in fact), which makes quite a lot of use of a sort of "callbacky" style.  i.e., "with", from Foreign.Marshal.Utils has the type "Storable a => a -> (Ptr a -> IO b) -> IO b"
23:03:27 <dpwright> I find myself using it like this quite a bit: "with foo $ \fooPtr -> with bar $ \barPtr -> doSomething foo bar"
23:03:50 <dpwright> I think it'd be nice to be able to write that more like this: "doSomething <$> with foo <*> with bar"
23:04:04 <jle`> is there any way for me to see what version of certain packages that my project in my sandbox are using.  have the ones in .cabal-sandbox/...-packages.conf.d/ but it doesn't seem to include "built-in" packages like containers
23:04:11 <dpwright> is there an applicative/monad which will help me here? 
23:04:21 <dpwright> perhaps the continuation monad?
23:04:35 <dpwright> or is there something more obvious I'm missing?
23:06:53 <dpwright> ...I don't think Cont is right, actually
23:06:56 <fro_ozen> wouldnt just doing doSomething (with foo) (with bar) work?
23:07:47 <fro_ozen> nah it wouldn't
23:07:48 <dpwright> the type of "with foo" is "(Ptr a -> IO b) -> IO b"
23:08:09 <jle`> dpwright: not sure if this will help, but (a -> ContT r m a) is a wrapper over (a -> (b -> m r) -> m r), so your arrow there would be `a -> ContT b IO (Ptr a)`
23:08:10 <dpwright> whereas doSomething is expecting a Ptr a
23:10:14 <dpwright> jle`: Not sure what you mean by my arrow.  Arrow as in, Control.Arrow?
23:10:32 <jle`> `with`
23:10:43 <jle`> with :: a -> ContT b IO (Ptr a)
23:10:54 <dpwright> oh I see....
23:11:03 <jle`> ContT is just a newtype wrapper
23:11:18 <jle`> @unmtl ContT b IO (Ptr a)
23:11:18 <lambdabot> ((Ptr a) -> IO b) -> IO b
23:11:38 <jle`> so maybe play around with (>>=)'s type signture for the unwrapped functions...maybe you might see a pattern
23:11:50 <jle`> someone here might have worked more with this than me though and can see if this pattern is doomed/good heh.
23:12:10 <dpwright> :-)
23:12:14 <dpwright> ok, thanks, well I'll have a fiddle
23:13:02 <jle`> (>>=) :: ((a -> IO r) -> IO r) -> (a -> ((b -> IO r) -> IO r) -> (b -> IO r) -> IO r
23:13:13 <jle`> hm.
23:14:28 <jle`> with foo >>= (\fooPtr -> with bar >>= \barPtr -> doSomething fooPtr barPtr) might work
23:14:36 <kaidelong> those mismatched pareeens
23:14:44 <jle`> :)
23:14:59 <jle`> do { fooPtr <- with foo; barPtr <- withBar; doSomething fooPtr barPtr }
23:15:08 <jle`> it's that last line that i am not 100% confident on heh
23:15:32 <jle`> oh, you might just need `liftIO`
23:15:39 <jle`> do { fooPtr <- with foo; barPtr <- withBar; liftIO (doSomething fooPtr barPtr) }
23:16:04 <jle`> ...does this really work...
23:16:20 <jle`> oh, you need to use `ContT (with foo)`, for the newtype wrapper
23:16:28 <jle`> so Haskell knows that you want the ConttT monad instance
23:16:28 <dpwright> right
23:16:53 <dpwright> I just tried "doSomething <$> ContT (with foo) <*> ContT (with bar)"
23:17:06 <jle`> does it work? :D
23:17:27 <jle`> hm it shouldn't
23:17:42 <dpwright> not quite
23:17:47 <jle`> does the do block work?
23:18:01 <jle`> the do block isn't something that can be made applicative
23:18:32 <shachaf> Except when it can.
23:18:42 <jle`> i'm talking about the specific do block above
23:18:57 <shachaf> That can be made partly Applicative.
23:19:05 <dpwright> yeah, sorry, one sec, rewriting it with do now
23:19:17 <jle`> huh interesting
23:19:22 <shachaf> join (doSomething <$> with foo <*> withBar) or something.
23:19:27 <shachaf> Probably it doesn't matter in IO.
23:19:37 <jle`> ah well yeah :)
23:19:41 <jle`> ty
23:19:55 <dpwright> I actually get similar errors with both the do and the applicative atm
23:20:10 <dpwright> I think it's just some dumb thing
23:20:23 <ttt_fff> I need to store a bytestring as a text; are bytestrings just texts? or are there some bytestrings that can not be read as a splain text?
23:20:50 <dpwright> it's expecting (() -> IO r0) -> IO r0 at the moment for some reason
23:21:13 <dpwright> not sure where the () is creeping in
23:21:37 <dpwright> not sure where the () is creeping in
23:21:39 <dpwright> oops
23:21:45 <dpwright> ah, probably want a liftIO in there
23:21:59 <dpwright> oh look, you already had that -- I missed it ;-)
23:22:02 <erikd> ttt_fff: you want functions from Data.Text.Encoding
23:22:20 <Azel> ttt_fff: Bytestring are binary data, so while they're quite a few encodings were a given bytestring is a valid text, they're not texts
23:22:25 <kaidelong> () -> b can be turned into a -> b
23:22:26 <pacak> ttt_fff: ByteStrings are usually raw binary data, there can be anything in there. Text are usually utf8 encoded
23:22:26 <erikd> eg decodeUtf8 or decodeUtf8With
23:22:38 <kaidelong> so you could just fix the type and see what happens
23:22:49 <kaidelong> @ty (const () .)
23:22:51 <lambdabot> (a -> b) -> a -> ()
23:23:02 <kaidelong> err
23:23:10 <kaidelong> @ty (. const ())
23:23:11 <lambdabot> (() -> c) -> a -> c
23:24:03 <kaidelong> oh wait the contravariance
23:24:26 <kaidelong> it wants a () -> IO r0, you can give an a -> IO r0 but not any specialized a, nevermind, I got that wrong
23:24:31 <ttt_fff> so I'm looking at https://hackage.haskell.org/package/cereal-0.4.1.1/docs/Data-Serialize-Put.html
23:24:36 <ttt_fff> but I need to serialize to Text, not to ByteSTring
23:25:41 <pavonia> ttt_fff: What are you trying to do?
23:26:07 <ttt_fff> I need to communicate web server <-> javascript
23:26:08 <Azel> ttt_fff: What are you serializing? Because cereal being binary serialisation, it won't serialise to textual data.
23:26:12 <ttt_fff> and serialize data so I can send it over xmlhttp
23:26:29 <ttt_fff> pavonia , Azel: I tried aeson ... which works, except Aeson does not compile with haste-compiler
23:26:30 <dpwright> I needed to use evalContT, not runContT
23:27:06 <funfunctor> ski:  back
23:27:28 <funfunctor> ski: can you see how much IORef's are in RadioDevice, its very stateful. So my concept is this http://lpaste.net/124810
23:28:35 <Azel> Then you'd need to serialise in JSON (with the json library for example) or in XML.
23:30:13 <Azel> Or at worst, you could convert to base64 the result of the binary serialisation...what does the other side of ths communication expects? 
23:37:15 <Axman6> thunderrd: what do you mean by "does not compile with haste-compiler"?
23:37:50 <Axman6> uh, ttt_fff even
23:37:54 <Axman6> sorrt thunderrd 
23:38:05 <ttt_fff> what?
23:38:11 * Axman6 is at work too late on a friday to be typing obviously
23:38:11 <ttt_fff> I can't get aeson to compile with haste-compiler
23:38:21 <Axman6> how come?
23:38:39 <ttt_fff> Axman6: "haste-inst install aeson" <-- this is the command right?
23:38:48 <ttt_fff> Axman6: I can re-run it and send you the paste of the error
23:39:00 <Axman6> oh, I have no idea. I didn't know what haste-compiler was
23:39:15 <Axman6> I thought it was another library and they had compile conflicts
23:39:43 <glguy> Aeson package works fine be without template haskell if you remove that module if that's still the problem
23:39:58 <glguy> TH has nothing to do with Generics
23:39:59 <ski> funfunctor : hm, ok
23:40:00 <Javran> > let f x | y <- x + 1 = y in f 10
23:40:01 <lambdabot>  11
23:40:10 <ttt_fff> glguy: https://gist.github.com/anonymous/78131b3f5f61bfadc40a is the error
23:40:22 <ttt_fff> it surprises me it's this hard
23:40:34 <ttt_fff> i feel like it should be just 20-30 lines of GHC.Generics
23:40:46 <glguy> Just remove the template haskell dependency and module and try again
23:42:40 <funfunctor> ski: its hard to get it all working
23:43:36 <funfunctor> but I think using a type class of actions + StateT is the right way to go over a record given the amount of stateness?
23:44:31 <dpwright> ok, the following works and is applicative too: "evalContT . join $ doSomething <$> ContT (with foo) <*> ContT (with bar)"
23:44:54 <dpwright> thanks jle`, shachaf!
23:46:20 <jle`> woo hoo!
23:47:10 <shachaf> Uh oh. I wasn't actually recommending that syntax.
23:47:15 <dpwright> haha
23:47:18 <shachaf> I think do notation is probably clearer.
23:47:41 <dpwright> I might just "let magically = evalContT . join" for maximum mystery
23:47:54 <dpwright> shachaf: I think you're right
23:48:00 <ttt_fff> https://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson.html <-- in Aeson, why does decode/encode involve ByteString ... and not Text ?
23:48:02 <dpwright> But I had to try!
23:48:08 <ttt_fff> isn't json supposed to be Text rather than binary bytestrings ?
23:52:26 <ski> dpwright : did you already try `(\fooPtr barPtr -> lift (doSomething fooPtr barPtr)) <$> ContT (with foo) <*> ContT (with bar)' ?
23:57:04 <dpwright> ski: I hadn't... I just tried it though, and that didn't work as is
23:57:37 <ski> hm .. oh, i see
23:59:10 <ski> dpwright : ok, i see i have nothing to add over what's already been said. sorry for disturbing you
23:59:27 <dpwright> ski: That's ok!  It was worth a shot :-)
