00:01:18 <kadoban> Hmm, I feel like I should be able to find it, but can't seem to: anyone know where the documentation for ~/.cabal/config is, what the possible settings mean and what they are?
00:02:01 <dgorbik_> randir, http://lpaste.net/129730
00:02:46 <dgorbik_> status is of Status type from Network.HTTP.Types (https://hackage.haskell.org/package/http-types-0.3.0/docs/Network-HTTP-Types.html)
00:02:54 <dgorbik_> body is a ByteString
00:03:07 <randir> Thanks! You're a lifesaver. 
00:04:25 <randir> Haskell has totally ruined me for other IRC channels. You guys are just too helpful. :-)
00:05:07 <dgorbik_> randir, I just checked it typechecks, hope it works :)
00:05:35 <spindas> kadoban: All I could find was the source - https://github.com/haskell/cabal/blob/fdae633cc97100831d35b3963eedbfc91e94d169/cabal-install/Distribution/Client/Setup.hs#L1302
00:05:45 <spindas> kadoban: also, http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
00:06:19 <spindas> the source has a line of documentation for each flag, though it'd be nice to have it written up on the wiki
00:07:25 <spindas> kadoban: oh, there are more options here, too: https://github.com/haskell/cabal/blob/1aee4142c92487a8e89e52cad77fc9336b5e6ff4/Cabal/Distribution/Simple/Setup.hs#L401
00:07:39 <randir> dgorbik_ email and pass are of type String, not BS
00:07:41 <kadoban> Interesting, thanks. Yeah, it seems like it should be /somewhere/, kinda bizarre it's not
00:07:44 <randir> what's the best way to convert it?
00:08:30 * hackagebot semver 0.3.3.1 - Representation, manipulation, and de/serialisation of Semantic Versions.  http://hackage.haskell.org/package/semver-0.3.3.1 (BrendanHay)
00:08:30 * hackagebot text-manipulate 0.1.3.1 - Case conversion, word boundary manipulation, and textual subjugation.  http://hackage.haskell.org/package/text-manipulate-0.1.3.1 (BrendanHay)
00:08:37 <dgorbik_> randir, you need to add: `import qualified Data.ByteString.Lazy.Char8 as BL`
00:08:45 <dgorbik_> then you can use BL.pack on the string to get a bytestring
00:08:49 <randir> sould I use lazy or not?
00:08:56 <randir> should*
00:08:57 <dgorbik_> and BL.unpack to go back
00:09:01 <dgorbik_> yeah, it's lazy
00:09:13 <dgorbik_> http-client uses lazy bytestrings
00:09:29 <randir> thanks
00:10:53 <randir> the non-lazy bytestring library has "isInfixOf" which the lazy one doesn't seem to have? It's a function I need.
00:11:06 <randir> I guess I could just unpack the BS into a string
00:11:11 <randir> nvm
00:11:15 <randir> sorry, tired :P
00:11:32 <dgorbik_> randir, do you need that for a response?
00:11:47 <randir> yeah
00:11:55 <randir> I'm checking if a String is found in a response
00:12:09 <randir> was going to convert the string, and see if it's in the LB response
00:12:16 <randir> but I'll jsut convert the response to string
00:12:50 <randir> it's not the bottleneck of my program
00:13:37 <dgorbik_> randir, I just realized you can get rid of that lambda in "withManager" to make it shorter: http://lpaste.net/129733
00:13:41 <dgorbik_> and less scary probably
00:14:29 <randir> Lamdba's aren't scary ^_^ but thanks
00:15:07 <dgorbik_> randir, they just use this pattern for resource finalization 
00:23:26 * hackagebot effect-handlers 0.1.0.5 - A library for writing extensible algebraic effects and handlers. Similar to extensible-effects but with deep handlers.  http://hackage.haskell.org/package/effect-handlers-0.1.0.5 (edofic)
00:26:14 <randir> dgorbik_ it doesn't seem to be returning data for me
00:26:30 <dgorbik_> what's the status?
00:27:53 <randir> nvm, figured out the issue
00:28:02 <randir> had a parse error that wasn't getting reported
00:28:26 * hackagebot koofr-client 1.0.0.3 - Client to Koofr API  http://hackage.haskell.org/package/koofr-client-1.0.0.3 (edofic)
00:29:03 <randir> there we go!
00:29:14 <randir> works an order of magnitude faster than my other one was :)
00:29:17 <randir> thanks a lot
00:30:59 <dgorbik_> randir, awesome! I wonder how it compares to curl
00:31:17 <dgorbik_> why was wget so slow?
00:31:25 <randir> I was using threading
00:31:29 <randir> so calling wget from multiple threads
00:31:51 <randir> I think it had a backend server that didn't have much load, that was acting as a mediator between Haskell and the OS
00:32:17 <randir> your request that you gave me is FAST. It's sent over 600 queries the past minute :)
00:32:36 <dgorbik_> randir, hm, it seems like it was is just forking to run a 'wget'
00:32:41 <dgorbik_> so that's of course very inefficient
00:32:46 <randir> yeah
00:32:51 <dgorbik_> curl would use FFI bindings
00:32:57 <dgorbik_> so probably as fast as http-client stuff
00:33:30 <dgorbik_> randir, are you performing these for the same URL?
00:33:37 <randir> yep
00:33:58 <randir> which means that I'm doing something inefficient, right? opening and closing a connection needlessly?
00:35:18 <dgorbik_> randir, yes
00:35:27 <dgorbik_> you need to sequence requests inside of withManager
00:35:54 <randir> hmm
00:36:01 <randir> that's difficult, as I'm using tons of threads
00:36:41 <dgorbik_> hah, are you brute-forcing something? :)
00:37:30 <dgorbik_> randir, it's okay to use a ton of threads, but you can have a request manager per thread
00:37:45 <randir> yeah, heard of Hydra?
00:37:56 <randir> and the threads are short-lived, doing only one-request each
00:38:10 <dgorbik_> the point of having multiple threads is to establish several connections simultaneously, but each one of those can perform several in a row
00:38:56 <dgorbik_> I don't think Haskell is the right tool for this
00:39:46 <randir> Why not? Haskell seems to wrok well for it so far.
00:40:26 <dgorbik_> randir, I don't know where the bottleneck is though
00:40:31 <f-a> here I read http://community.haskell.org/~ndm/cmdargs/ "it supports program with multiple modes". But what does "multiple mode" that mean?
00:40:40 <dgorbik_> depends on whether it's IO or actually threading code
00:41:09 <kadoban> f-a: Probably like, 'cabal install', 'cabal build', 'cabal run', etc.
00:41:43 <randir> dgorbik_: I'm using forkIO currently
00:42:12 <f-a> ohh thanks kadoban
00:42:14 <dgorbik_> randir, compared to say implementation in C
00:42:20 <dgorbik_> threads are not going to be as lightweight 
00:42:28 <lf94> Could someone please explain why this line is at the top of so many haskell programs? LANGUAGE OverloadedStrings
00:42:41 <dgorbik_> lf94, in short because Prelude's String suck
00:42:56 <frerich> I'm tinkering with a little IRC bot which basically watches the chat messages and - in case it detects something interesting - utters some things. It works well, but I'm somewhat dissatisfied with the program design, which is basically a bunch of callbacks. Is there a way to write an IRC bot such that I can model the incoming messages as a (potentially infinite) list of messages, and I fold the list to produce a (usually much smaller) list of responses?
00:42:59 <randir> dgorbik_: Okay, that's fair. Still, this is more of a quick-and-dirty program than something professional
00:43:00 <lf94> dgorbik_, huh, ok
00:43:02 <dgorbik_> so people use something more efficient like Text or ByteStrings
00:43:10 <frerich> A bit like hwo lazy IO works, except for the ugly parts?
00:43:27 <dgorbik_> randir, C pthreads are not as lightweight as haskell's
00:43:28 <Saizan> randir, dgorbik_: ghc's threads are pretty lightweight, they are not OS threads
00:43:29 * frerich wonders what the whole 'conduit/pipes/whatever' business is about
00:44:19 <dgorbik_> frerich, that's lazy IO implementation. Watch this https://skillsmatter.com/skillscasts/4230-lazy-io-and-alternatives-in-haskell
00:44:59 <randir> dgorbik_ as it's working now, it's actually working extremely fast for what I need
00:46:00 <dgorbik_> frerich, bytestrings use memory more efficiently for storage, but laziness is achieved by using pipes/conduits.  (I think)
00:47:23 <dgorbik_> randir, you could try experimenting with some GHC options from here: https://wiki.haskell.org/Concurrency
00:47:34 <dgorbik_> it might speed up things a little bit too
00:48:26 <randir> yep. although the bottleneck is network, not actual processing 
00:51:09 <randir> ohh, I'm having a bit of an issue now
00:51:24 <randir> it seems like it's actually not having the same usage as the wget call I was doing
00:51:54 <dgorbik_> what do you mean?
00:52:42 <randir> I'm entering an e-mail/password pair that I know works
00:52:51 <randir> but it's not giving the success page
00:54:00 <randir> I'm not sure why
00:54:45 <dgorbik_> randir, maybe request body is malformed?
00:55:54 <randir> email and pwd are the params
00:56:04 <randir> so your example seems like it should work
00:59:16 <randir> it could be that the page I go to gives me a 302
00:59:27 <randir> and I want to get text from what it redirects to 
00:59:42 <randir> altough actually just knowing where it redirects to would work even
01:00:37 <dgorbik_> randir, yeah, you might need to perform an additional request that wget is doing automatically for you
01:00:41 <dgorbik_> I am going to sleep, have fun!
01:01:01 <randir> Hmm.. any idea how?
01:01:05 <randir> ah okay, sleep well. :)
01:01:09 <randir> Thanks for all the help.
01:02:26 <dgorbik_> randir, hmm, you will need to parse statusMessage
01:02:33 <dgorbik_> statusMessage status
01:02:49 <dgorbik_> https://hackage.haskell.org/package/http-types-0.7.1/docs/Network-HTTP-Types-Status.html
01:03:11 <randir> it just says "response status OK"
01:03:18 <randir> and status code 200
01:03:22 <randir> for both failure and success
01:03:28 * hackagebot OpenGLRaw 2.4.1.0 - A raw binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGLRaw-2.4.1.0 (SvenPanne)
01:03:49 <frerich> Weee, new GHC.
01:04:14 <dgorbik_> randir, what gives you 302 then?
01:05:03 <randir> The site itself
01:05:07 <randir> like, looking in wireshark
01:05:20 <randir> the request I'm issuing is hitting a 302
03:05:34 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org | Learn, Teach, or Get Out of the Way!'
03:05:34 --- topic: set by shapr!~shapr@84.200.228.78 on [Tue Mar 17 12:32:20 2015]
03:05:34 --- names: list (clog jacquerie breadmonster juanpablo__ kosorith verement revath earthy ceii ft Paks ashnur stef204 netj arw bazqux bibaijin2014 tim_heap lritter turtil SoupEvil larion kvelicka cYmen__ solatis tv blicero jinblack ktosiek _pakchoi_ops jespada michaelneale greg` worldsayshi cfoch TK_ bru` edsko acidjnk zipper whaletechno greeny djapo Haswell ep0 edon Sebastien-L psy_ nschoe cleamoon dario` yoshuawuyts1 mountaingoat vandenoever yfeldbl__ marr ilyanok terlar)
03:05:34 --- names: list (aloksingh ciwolsey jaza___ bernalex irrequietus joelhe mac10688 jdnavarro m0rphism mattyw dan_s jutaro simukis_ agocorona Asa9t1 raichoo Ayey_ perspectival Alekko PragCypher JonathanGrahl nh2 msgodf cyphase RGamma jaen jakutis lsix neptunepink ckw sprang Tene ByronJohnson Enigmagic mjboa slomo orbital darkf_ __main__ sivteck caumeslasal lambdabot ribi hamid zzmiy duke_leto Talryn rodlogic_ magicman kunalb_ DrAwesom_ arenz apolune blerud Iskarlar f|`-`|f)
03:05:34 --- names: list (quchen2 free_beard nshepperd oscar_toro xificurC ketil desophos eazar001 ProofTechnique argiopeweb__ Beetny danvet daniel-s_ acetoline zcourts gfixler sinkensabe gsingh93 fifosine ulfdoz hackagebot gnimmelf kolmodin_ x90 _ashbreeze_ sopvop pacak shintah marcus-aurelius bjz_ ThomasLocke mjo Bhavya qubitnerd virce pt1 noelm_ erikd fumieval CMCDragonkai orion Mon_Ouie sunwukong ecthiender MK_FG nilg nik_89 krakrjak djbeau path[l] lolisa sakiriou1 xacktm otto_s_)
03:05:34 --- names: list (shafox kcj Guest33555 timothyh jordanl liyang byaruhaf lifenoodles DanToml roboghost xahry_ fnordbert louis`` solvip Hijiri thunderrd thebnq Moggle perrier sledges1 cdidd_ mauke kp666 infinity0 vili bb010g eisbehr geek seangrove tgeeky PyroPeter hamishmack tranma Guest96212 dented42 itsmonktastic Lis fraq4415 jedws_ conal sh1ken zxq9 echo-area cinro ev_ fujimura tinyblak_ Ralith co-arbelos Gurkenglas favonia Sonderblade Zekka WraithM stbuehler chrisdotcode)
03:05:34 --- names: list (]OLI[ dysinger c_wraith gdoteof_ falafel hexagoxel exferenceBot lspitzner solrize dgpratt predator117 dodgems apaku cleamoon__ Rotaerk amosr mrhania_ M-ou-se jefus spindas sebleblanc PatrickRobotham MasterPiece chirpsalot Chobbes fibbel nisstyre banister sunnavy adzuci Nik05 tessier greenbagels amf Nervkind atn34 DerisiveLogic ollef ndrei lykkin johtso_ shutdown_-h_now etandel mschwanzer sm jml dgorbik_ Stratege optocoupler Betal Bane^ Natch tomboy64 mceier)
03:05:34 --- names: list (shesek atomi octalsrc Nadrieril Jaak aarvar mirsal _ixti_ gdoteof skeet70 rofer renekooi paf31_away dolio rsynnest moghedrin amiri_ derekv xxx theorb oats bmuk kaffepanna rj-code eevar Nimatek Shapeshifter plutoniix maraoz_ plhk bvad andjjj23 thomassgn Azel s00pcan butyoudonot Adios fengshaun tlevine TRManderson pyon ellinokon zq l3dx noddy theanalyst tongcx DenSchub karshan defanor qz quaestor uber eamelink AntiSpamMeta hive-mind kini jrib tjbp devi deavid)
03:05:34 --- names: list (cpa_ pharaun thomie paz__ heaumer solarus PHO dawik deni mortberg gargawel rabisg kloeri relrod ZsoL froztbyte tstc spacebug JamesJRH Phillemann claudiyoh lf94 stomp koomi igniting ad ndeine pdxleif swen rieper nitrix Guest90609 padre_angolano bolmar adimit xenocons natte guibou javawizard ilmig eyem_ fyolnish sorind KitC gpampara lolocaust ivan\ BlakeRain foolie Phlogistique harski tomjaguarpaw ido pingu sternenseemann xiaolin pranz1 jaspervdj kav ChristianS)
03:05:34 --- names: list (rseymour vladan cmn acomar mokus shachaf smtudor flxx siddhu Factionwars theorbtwo heath kakos ctag Eagle_Erwin fionnan cjay petercommand BMeph cdk_ aristid crazydiamond noctux ubuntor thoradam kvitebjorn boris`` `bps bjorkintosh jstolarek int-e mantovani2 mathu Internet13 Baughn lseppala amiller_ syk0mantis demolithion thorkilnaur_ ion TheMoonMaster meteo martintrojer micrypt avocado _flow_ cursork Elsi beauby Tehnix qr42 numberten enomies_ pm5 uwap Licenser)
03:05:34 --- names: list (cryon sellout usr Paprikachu exio4 frawgie lpsmith jrslepak vermeille bergmark Shagane jameseb Reiser ibid Laney Zanzare jnoah Excureo comboy_ tromp_ dxld_ _5kg ggVGc joehh1 kriwil dowski_ lytchi Tesseraction_b esssing larcb ortmage maurer machineslearn hpc luz1e kvieta- d3lxa pygospa jarvi_ thoughtpolice spwhitt hyPiRion monsieurp DANtheBE- ski maskd bjornars1 pieter_ knyppeldynan zxtx_ lattenwa1 mpereira_ whiteline supki SwashBuckla ljhms brennie_ banjiewen)
03:05:34 --- names: list (fikusz_ runde_ lamilami andrewsw_ yusukesuzuki_ gtklocker tomku|two mgaare_ mendez_ anders^^_ ninegrid_ aleator_2 Juka_ saurik_ iulian_ Zemyla_ taksuyu_ aleator_1 haroldwu_ a_ Yawgmoth mikemac sdx23 ch3mical Erstarrung nulpunkt burp_ drmegahe1tz wagle ousado marens vi d-q-d Drezil_ proq yeltzooo9 Guest23539 Watcher7_ rul Quashie__ liverb cchalmers snhmib xeno_ doppioslash _ether_ Swizec zaroth__ masse antoniy Jellydog joneshf-laptop Xe tpsinnem fractalcat)
03:05:34 --- names: list (armyriad KorriX zeiris Yaniel Laquendi Xnuk augur TDJACR C4Cypher laudiacay Ankhers lurker6 Suedish joeyh martingale ozataman CADD guampa whitesn scott arnoblalam dreixel_ shouya GGMethos ThePhoeron Guest21 Fr4n Iceland_jack unknownloner c74d RageD jerbome_ zomg hanDerPeder Rembane sohum buMPnet XMunkki Voldenet bergey _zxq9_ anastas albel727 prophile rike RayNbow`TU xnyhps derillium elementalest_ frogpunc agumonkey rola ValicekB Sigyn haBuu_ phaazon ikke)
03:05:34 --- names: list (Sgeo_ kqr kalloc em LordDeath aloiscochard dsturnbull_ zariuq aawe benzrf tumdedum kmicu robbert xpika boothead sivoais frontendloader zilinc_ adlan lhdc ruukasu waxjar jessicah glguy dino- renzhi gienah dgonyeo statusbot moodmosaic jtanguy mt ReinH klarrt Guest37295 gsnewmar` bind TallerGhostWalt_ shmookey1 Boney lispy iross_ simon ryu_s_test vmesons mimi_vx suhorngM_ BillyIII keaml kidnapped_robot bydo Darkflux akurilin dstanek dibblego albertid blenny Tril)
03:05:34 --- names: list (poucet mrd rdema Haskellfant sebastard myst asjo dgvncsz0` Xack sokoll FreeFull phaskell wrengr_away aaronlevin monochrom mitchty SegFaultAX gnomnain` thetallguy chishiki flaiw hiratara horlicks_ gnusosa raek Plasmastar MrWoohoo reactormonk LeaChim jonesinator hattusili_III Sornaensis [swift] jokester phuu ronbrz obiwahn gseitz milessabin newsham pharpend evilthomas balaji sabalaba Orwell84 so jaffachief platz GaveUp kaictl LnL asm89 iElectric ormaaj mlen)
03:05:34 --- names: list (bshelden gbiv dan64 _rgn yarou jdiez zso tnks negatratoron qzzx jackhill cynick Or1 kipras`away monty abh ilias vikraman ephess agatam Ptival plsk inuoppai jlewis hsyl20 rivarun aristid_ avn unsymbol benbangert malllle stelleg CaptainLex prkc dabradley Freundlich arjen-jonathan Cathy koala_man kofno oberstein jud pii4 Spockz Cerise dp_wiz gniourf drone| eL_Bart0 Guest82577 namuromus mietek xintron kolmodin liamgoodacre zorzar lokydor isenmann eyenx pavlicek)
03:05:34 --- names: list (stass drbean Vorpal jacksoow lnr m1dnight_ fergusnoble peddie bitraten OlegYch0 kjanosz dkua ParahSailin gratimax tzaeru fr33domlover sagittarian|3 cjheath Maxdamantus mniip Jonno_FTW hvr msgctl petantik sLite pleiosaur andbroby ElderFain Geekingfrog liste Willis ttuegel AshyIsMe Frank89RM_ Kruppe Fylwind naudiz ryanakca carter_cloud jkarni sunfun nikola twopoint718 alynn ixian nakal duga u_ jix rslima ssn__ _1126 Lutin` Wamanuz u-ou Khisanth fling Church- Ke)
03:05:34 --- names: list (psacrifice somenick irishsultan stasku nbouscal Heero sclv k4r1m biscarch _klm FofG tazjin cloudhead_ JonasH__ NemesisD emmanueloga lacrosse__ hguux__ leifw sephiap idnar shelling__ bgyss trig-ger zero7 bcavalier nkpart julienXX yrashk Xorlev _ikke_ tristero DigitalKiwi ghorn Soft da-x Polarina miklcct saep yac ackthet loz-- mrphy dewdrop ps-auxw flux zhulikas vpm electrogeek besenwesen ab9rf ForNeVeR Axman6 mecalopolis sw1nn tdammers krgn buoto zyla niko)
03:05:34 --- names: list (etabot hefner Brando753 fiola byorgey mmaruseacph2 mpw geekosaur jmcarthur agrif BrianHV obcode Draggor japesinator ErichKeane Klumben mikeizbicki wolf_mozart cjwelborn alphonse23_ wjm ehamberg noteventime gws Eiam bananagram hongminhee frerich dsantiago Gothmog_ jophish capisce bob_twinkles condy Svedrin divVerent brezel hisdke Fuuzetsu Rastus_Vernon tsani dgorbik gmcintire nemesit|znc mpickering _br_ nilscox jle` sajith dmwit notdan fryguybob myst|work)
03:05:34 --- names: list (aleator__ goldfire lassulus mephx suls McManiaC otulp davl dschoepe grohne nwf sbauer322 bjobjo colah slasktask RustyShackleford ahihi valdyn kennyp dropdrive HylianSavior meretrix bennyklotz Nivim doctorinserenity yukonjack rs0 dixie_ benwf rossberg_ CruddyBucket mach kgadek comma8 dustinm tolt kaol julmac OutlawStar wto Belgarion0 troch helgar clauswitt tg lyddonb fredsir dh senseibaka karls tswett nyuszika7h Intensity td123 PotatoGim phadej sujeet xandaros)
03:05:34 --- names: list (imalsogreg Philonous wayne apo fugyk saiam levi Vbitz dpn` cschneid Bigcheese lahwran oherrala Th0mas Igloo huonw HugoDaniel Zariel oneb NikolaiToryzin orzo fiddlerwoaroof Dykam mami sys9mm Profpatsch honza ezrios janne kosmikus Plastefuchs darkowlzz|afk bartavelle seliopou mak` paperManu brackets jmct mjrosenb statusfa1led kazawore_ acharm_ dabukalam s4msung_ zeroskil1or jedavis ephemeron gbarboza zph seanparsons dlackty__ Raynos otherchas_ andreypopp)
03:05:34 --- names: list (S11001001 jabbslad_ hellschreiber bcarrell moy kalz milli rbocquet keko-2 Spaceghost liff pikhq acfoltzer sudog teeteewhy Ferdirand ircbrowse integral Forkk Walther staffehn_ Cale zerokarmaleft cross ninzine Desoxy voidzero ironChicken Guest37394 xplat kohelet zymurgy kwantam felixsch Ornedan aaronweiss74 pnielsen pfoetchen Fubar^ pwestlund_away alanz DustyDin1o killtheliterate alem0lars suvash brisbin lachenmayer ClaudiusMaximus RevJohnnyHealey michaelpj)
03:05:34 --- names: list (davean betawaffle Doji majoh rray cscorley irclogger_com Cr8 R0b0t1 pmade myme cbaines chris2 Twey sgronblo metaf5 troydm sea-gull tomprince mikeplus64 spion jlouis ahf edk cowtown Hugglesworth callumacrae isomorphismes arkeet Vq joehillen carter scopedTV averell mikel joshc otterdam drewdavis cjh` dilinger wting taruti friden Dodek ninedotnine IbnFirnas lieven `0660 Starfire mrowe_away gandr tromp trevorriles jlyndon coeus andreass idoru flori David)
03:05:34 --- names: list (Jello_Raptor linduxed mozmoney Kneiva yukko nuser Tiktalik Fuco Preyer jrp6 eikke ThreeOfEight dlowe Clint fmapE kshannon schlumpi ernst ww adnap adamse drdo Hafydd KeelOfSteel edwtjo tekacs jorj marienz FireFly tridactyla xaimus SLi kloplop321 zyoung Draconx Ipsum cow-orker SHODAN inr_ hpd az diginet darthdeus tuv robotbrain Liskni_si primepie tippenein alang CosmicRa` neena Pucilowski bcoppens haasn srhb greymalkin solirc ij Adeon Saizan bsummer4 bonobo_)
03:05:34 --- names: list (johnw Taneb ChongLi bdawn _di zalami Razz wtw Floyd_ biio Boreeas blast_hardcheese emlow niluje zebr dxtr xaxes` mrkishi aaron__ mindos_cloud____ mrb_bk lyxia benonsoftware alevy wizonesolutions mmmpork incomprehensibly joefiorini_ pii zrl ggherdov mbrcknl si14 korpse_ CARAM__ codehero OliverJAsh neektza MMuse_______ joefiori___ jonrh bkolera Tritlo chriswk tarcwynne lohkey fuziontech jroesch raid SuperTux88 tych0 lpaste stvc Guest99579 cin Blkt rom1504 fold)
03:05:34 --- names: list (davesilva dmilith pi8029 fall` kevin1024 udevd osfameron ggreg Nickeeh Jaxan lambdahands poikon jfokkan nmashton MiracleBlue cstrahan_ ocharles_ konne_ andrew__n AlainODea divyanshu n1ftyn8 cojy_ avdi joedevivo kjnilsson mankyKitty shennyg skarn Harbinger bafbomb__ dju agam hodapp wenzowski maw dlundy astocko mattp_ theDon luite ziman kess brent80_plow arrdem Ring0` tomaw fall_ annulus brolin_empey Ulrar hegge oconnore angryzor owa mero Deewiant gdsx dunj3)
03:05:34 --- names: list (Ezku gds Atlanis heyj_ca lvh elij brixen mitu spaceships Edox Mandus KaneTW WSergio Chousuke opqdonut elgot pyrtsa canta barrucadu CindyLinz heikkih hrnz WarzoneCommand iota_ asabil blindscreen btc___ vikram_ @ChanServ edran_ sweenzor arch_ Dtgr dstockwell seabre lfp__ alekst_ bthom palatin sleepynate NeatBasis joefiorini absence shiona aupo nesqi JPohlmann joeytwiddle tero- hiredman Athas znutar efm lenstr cosban- conehead posco edwardk etrepum akahn mno2)
03:05:34 --- names: list (c9sould__ bigs puzza007 kirjs______ joefiorini__ ricardo82 caasihuang arnihermann zpconn__________ hbar alpounet l3france kragniz bbee cods s_e f_x_ aseidl jokra aidecoe klugez bitemyapp eyck shapr jcurbo kemitchell vodkaInferno howard Artpicre jayne jludwig Nanar amontez seagreen sagelywizard d-snp geal DanZimm devJunk noplamodo mechairo` dredozubov eagleflo Eliel c-rog_ rtl_)
03:17:23 <cYmen__> I assume you get this question 15 times a day but I'm trying to compile the tempfile.hs example from http://book.realworldhaskell.org/read/io.html and it fails because it cannot derive the exception type because the catch function is a lambda that ignores the exception parameter.
03:17:44 <cYmen__> That's not a question of course, the question is, how do I fix it?
03:18:02 <cYmen__> The offending line is probably: tempdir <- catch (getTemporaryDirectory) (\_ -> return ".")
03:18:23 <jle`> you have to give it the type of the exception you want to catch somehow
03:18:34 <jle`> one way is by using ScopedTypeVariables
03:18:48 <jle`> and having (\(_ :: TypeOfExceptionYouWant) -> ... )
03:19:27 <jle`> or ((\_ -> ...) :: TypeOfExceptionYouWant -> IO String), I guess
03:20:22 <cYmen__> How do I enable scopedtypedvariables and what are the implications?
03:20:44 <jle`> {-# LANGUAGE ScopedTypeVariables #-} at the top of the file
03:20:57 <jle`> you can read about it in the ghc user manual, but it's more or less a "harmless" extension
03:21:18 <jle`> among other things it allows you to reference type variables of your main functions inside helper functions
03:21:30 <jle`> so if you've ever done something like foo :: a -> b -> ...; foo = ... where bar = ...
03:21:38 <jle`> then bar can now access `a`, `b`, etc.
03:21:45 <cYmen__> Is there a canonical way to look up which exception a function might throw? Because I just want all of them in this case...
03:21:55 <jle`> in this case we are just using it to be able to annotate a lambda input
03:22:13 <jle`> if you want to catch all of them --- which isn't too recommended in real world code --- you can use SomeException
03:22:35 <jle`> Exception in GHC have a sort of subtyping thing going on
03:23:35 <cYmen__> hm....now how do I find out what to import for that? :)
03:23:41 <jle`> simon marlow's book "parallel and concurrent programming in haskell" (available online) has a great chapter all about GHC's modern exception system
03:23:48 <jle`> @hoogle SomeException
03:23:49 <lambdabot> Control.Exception.Base SomeException :: e -> SomeException
03:23:49 <lambdabot> Control.Exception SomeException :: e -> SomeException
03:23:49 <lambdabot> Control.Exception.Base data SomeException
03:24:02 <bartavelle> So it seems I can't embed ruby 1.9 because it won't play nice with the GHC runtime. Except ubuntu LTS uses 1.9. This is a PITA, and the only way I can see that would salvage this situation would be to build another version of the ruby interpreter in the building process of the hruby package. Would anyone accept such a wasteful hack ?
03:24:36 <cYmen__> jle`: thank you!
03:24:44 <jle`> np!
03:24:52 <bartavelle> (without mentions of the technical difficulties, such as distributing the package in the first place, as it will be huge)
03:24:54 <jle`> i do recommend checking out that chapter in the book
03:25:05 <cYmen__> I shall remeember https://www.haskell.org/hoogle/
03:25:32 <cYmen__> jle`: I might look at it but I am only in chapter 7 of real world haskell and I don't want run of reading something else already :)
03:25:50 <jle`> http://chimera.labs.oreilly.com/books/1230000000929/ch08.html#sec_exceptions
03:26:14 <lolisa> hello， are there anyone good at equality proving? (JMeq maybe) https://github.com/lolisa/Category_Theory/blob/master/Category_Theory.v How can I prove this? I am stuck, or do I need to restructure automorphism and isomorphism a bit?
03:26:21 <jle`> cYmen__: ah. well, just be aware that RWH is commonly considered to have a lot of out-of-date aspects
03:28:22 <cYmen__> jle`: Is there a more up-to-date alternative?
03:28:35 <jle`> @where learnhaskell
03:28:35 <lambdabot> https://github.com/bitemyapp/learnhaskell
03:29:31 <jle`> LYAH is also commonly recommended, but it has some slight issues too...it is only *slightly* out of date
03:29:45 <jle`> but in a way that you only get tripped up maybe once or twice from it
03:30:25 <dan_w> OK, random question. Is there a reason why there isn't a typeclass for monad transformer mapping. For, mapReaderT, mapWriterT... ?
03:30:57 <jle`> there is
03:31:04 <jle`> just not in transformers
03:31:12 <dan_w> excellent, where?
03:31:17 <jle`> oh wait, i misread
03:31:28 <nshepperd> isn't that just fmap?
03:31:29 <jle`> hm, i think it's much more general than that
03:32:07 <jle`> i am tempted to say that it is MFunctor, from mmorph
03:32:08 <dan_w> No, fmap would give me, MonadTrans t => (m a -> m b) -> t m a -> t m b
03:32:19 <dan_w> I want: MonadTrans t => (n a -> m b) -> t n a -> t m b
03:32:23 <jle`> but hoist is slightly different
03:32:41 <jle`> MFunctor provides something slightly different
03:32:44 <nshepperd> oh, right
03:33:10 <jle`> it gives you (forall a. m a -> n a) -> t m b -> t n b
03:33:30 <jle`> which means you have to use a (m a -> n a) that "doesn't touch the `a`"
03:33:45 <dan_w> That won't work for me
03:33:47 <jle`> ie, listToMaybe, maybeToList, (return . runIdentity)
03:34:14 <jle`> ah, well
03:35:09 <dan_w> ok, thanks
03:37:22 <jle`> btw, in modern haskell, typeclasses aren't really used to give you "more polymorphic things", necessarily.  they typically are used for things where it would make sense to program generically/polymorphically, by providing disciplined laws, etc. ... laws that are useful for reasoning with polymorphic code
03:38:05 <jle`> in this particular case there might not be enough benefit from typeclasses in this sense (usefulness for polymorphic reasoning), or it might not even be possible to imbue any higher reasoning
03:38:23 <jle`> that might be an answer to your original quesiton, "is there a reason why", dan_w 
03:38:40 * hackagebot hruby 0.2.9 - Embed a Ruby intepreter in your Haskell program !  http://hackage.haskell.org/package/hruby-0.2.9 (SimonMarechal)
03:39:20 <jle`> using typeclasses just for ad-hoc overloading (without unifying laws) has fallen out of fashion as leading to unmaintainable/unreasonable/overly complex code
03:39:29 <dan_w> The reason I'm asking is because I'm trying to find a slightly better way of abstracting over particular transformer stacks.
03:39:58 <jle`> if you want, you can ask your "bigger" question, and we might be able to help you out there :)
03:40:10 <jle`> (by we i mean other people though, because i'm heading to bed)
03:40:21 <dan_w> ok, I appreciate it
03:43:41 * hackagebot stackage-curator 0.7.0.2 - Tools for curating Stackage bundles  http://hackage.haskell.org/package/stackage-curator-0.7.0.2 (MichaelSnoyman)
03:45:00 <aj__> hello guys
03:45:26 <aj__> I have just started learning Haskell 
03:45:47 <aj__> Started with Learn You a Haskell For Great Good
03:45:53 <aj__> enjoying it
03:46:12 <jerbome_> aj__, nice, I've finished to read it just yesterday
03:46:40 <aj__> Which book would you pick up next?
03:46:49 <dan_w> Real World Haskell
03:46:54 <jerbome_> I heard good about RWH
03:47:13 <jerbome_> but there's a lot of overlapping between the two, so I got bored
03:47:35 <jerbome_> and the exercise are somewhat harder than I expected
03:48:05 <aj__> I use Java and Python at office and sometimes it gets difficult to switch off my haskell mode
03:48:27 <jerbome_> i'm having fun with https://www.fpcomplete.com/user/DanBurton/20-intermediate-exercises right now
03:48:39 <aj__> Thanks for the link :)
03:48:59 <aj__> Aftereffects of learning Haskell is I am forgetting maths now
03:49:14 <aj__> and feel like doing maths the Haskell way :)
03:49:22 <jerbome_> most of them are just renaming from known typeclass like Functor, etc... But it's surprisingly harder when you have to rewrite everything from scratch
03:49:59 <jerbome_> If you thing you understood Monads, jump to the Misty typeclass related exercises
03:50:16 <aj__> I am still in Modules chapter
03:50:24 <jerbome_> Misty is just like Monad, except defined in term of =<< instead of >>=
03:50:27 <aj__> taking my time to finish LYAH
03:50:33 <jerbome_> oh yeah, you have time then =)
03:51:42 <aj__> Which is the most difficult concept to grasp in Haskell ?
03:52:31 <aj__> I just looked at the prime sieve example on haskell.org site and was amazed when I finally understood it
03:54:50 <dan_w> The most difficult concept? I don't think that has a well defined answer. Continuations in Haskell are pretty mind-bending.
03:55:27 <jerbome_> aj__, wow you understood the sieve already ?
03:56:22 <jameseb> Continuations are fairly confusing, many people seem to struggle with Monads though but Monads aren't really that hard
03:56:42 <jerbome_> jameseb, I think I understoof monad 3 times already
03:57:02 <jerbome_> I think I need 4 or 5 times more to understand them for real
03:57:14 <jameseb> jerbome_: well, there are different levels of understanding
03:58:10 <aj__> The basic concept to understand here is if an integer n has no factor in the list [2..n-1] then it is a prime
03:58:51 <jerbome_> aj__, that's the sieve, but the haskell implementations are quite hard to grasp
03:58:59 <aj__> so the head of the list [x | x <- xs, x `mod` p /= 0] is always a prime
03:59:44 <aj__> Yes, so the line "where sieve (p:xs) =            p : sieve [x | x <- xs, x `mod` p /= 0]" does just that
04:00:20 <aj__> keep filtering the list by cancelling out all factors of a number we know to be a prime
04:00:21 <jerbome_> aj__, oh yeah, but's that the "naive" implementation, it takes forever to get a good number of primes this way
04:00:42 <jerbome_> I tried the 2nd problem in SPOJ with this implementation, it failed
04:01:11 <aj__> Right but I like this example. It demonstrates lazy evaluation, recursion, type inference
04:01:34 <jameseb> jerbome_: yes, there's a note on the website that says it's not necessarily the best implementation but it's just meant to show a lot of features of Haskell
04:01:50 <jerbome_> indeed, and these 3 concepts were my first "hell yeah, I might like this language"
04:01:52 <aj__> Though it's a contrived example and not efficient but illustrates concepts
04:02:08 <aj__> Same with me =)
04:02:24 <jerbome_> aj__, you gonna like functors and monad then :)
04:02:31 <aj__> I like Haskell's brevity. I think the designers were misers
04:03:07 <aj__> Their motto seems to be "use as few characters as possible" :D
04:03:21 <ion> APL
04:03:47 <aj__> jerbome_ Yet to get there =) but very excited since I started LYAH and I am glad I did
04:03:51 <ion> The Haskell syntax is more about minimizing syntactic noise than minimizing the number of characters.
04:04:11 <aj__> APL is cryptic at best
04:04:12 <jerbome_> aj__, one thing I really like also is the fact that you can guess what a function will do by just looking at its signature
04:05:12 <jerbome_> and reciprocally, if you need a function that transform something into something else, there's a high chance it already exists and you can find it by looking the signature you want in hoogle
04:05:14 <aj__> jerbome_ Right but initially I was confused by the function signature. I still get confused though
04:06:01 <aj__> I still need to get a good grasp over currying 
04:06:14 <jerbome_> before I get hit by the experts, I know "transform" is not an appropriate word
04:07:21 <aj__> jerdome_ I also like how haskell feels like maths
04:09:35 <jerbome_> aj__, yeah, you can "factor" of simplify functions thanks for that and currying
04:10:46 <jerbome_> @pf doStuff f x = map f x
04:10:46 <lambdabot> Maybe you meant: pl bf
04:10:58 <jerbome_> @pl doStuff f x = map f x
04:10:58 <lambdabot> doStuff = map
04:11:09 <aj__> jerbome_ do you have prior experience with functional programming?
04:11:12 <jerbome_> lame example but
04:11:26 <jerbome_> aj__, nope. I tried scala, but stopped very fast
04:12:15 <cfoch> Hi o/
04:12:43 <cfoch> how can I use the config file in order to do a "cabal install" using other version of GHC ?
04:13:13 <aj__> What a coincidence! I tried learning Scala too at Coursera =)
04:13:16 <jerbome_> aj__, what about you ?
04:15:19 <aj__> Finished Functional Programming Principles in Scala by Martin Odersky
04:15:50 <aj__> but I like Haskell better though =) found Scala too complicated
04:16:37 <jerbome_> do you know what do you want to do with haskell ?
04:18:56 <aj__> jerbome_ Not sure. Heard it from a colleague at office. So gave it a try.
04:19:59 <aj__> jerbome_ what about you?
04:20:35 <jerbome_> aj__, dunno either... That's probably going to be  a problem if I want to keep on trying haskell
04:21:03 <absence> i'm learning scala at work after a few years of haskell, and agree that scala is quite complicated
04:22:04 <vandenoever> can i rename or delete/unlink a file for which i just have the System.IO.Handle?
04:22:31 <aj__> absence, I empathize with you
04:22:59 <jerbome_> absence, you're already lucky to be able to do scala at work ;) I'm stuck with Java
04:23:15 <jerbome_> and not even Java 8
04:23:18 <aj__> jerbome_ Yea, we need a purpose to fully understand the language so it can be put to some use. 
04:23:31 <ion> vandenoever: GHC.IO.Handle.Handle seems to have a FilePath member.
04:24:04 <absence> jerbome_: to be honest i find scala more of an object oriented than functional language. but it's a more comfortable oo language than java for sure ;)
04:24:16 <aj__> Me too stuck with Java at work
04:24:30 <aj__> yet to start learning Java 8
04:24:39 <vandenoever> ion: i have the file path, but i thought closing the handle and delete file from path may have race issues
04:29:47 <Geekingfrog> Why is there "duplicated" packages like: Text.Parsec.Char and Text.ParserCombinators.Parsec.Char ? They look awfully similar
04:32:41 <aj__> Nice talking to you jebome_ . See you later =)
04:33:00 <absence> aj__: just jump into it :) i occationally find myself needing some small utility that i used to quickly hack together in a dirty mix of c and c++ because it was easy and familiar. forced myself into using haskell for such utils instead
04:33:16 <lolisa>  How can I prove that all isomorphism on the same arrow is unique? Do I need to add more axiom to Category to prove this?
04:35:34 <cfoch> Geekingfrog: do they do the same?
04:36:04 <Geekingfrog> as far as I know yes
04:42:10 <ion> vandenoever: Operating systems may not even keep track of what actual on-disk directory entry you opened in the first place, and there may not be a unique one for the file you have open.
04:43:45 <ion> vandenoever: You could use a directory that is in your control and use the openat, unlinkat syscalls.
04:53:42 <merijn> The good thing about GHC is the amazing feature list in new releases, the bad thing is that I always find myself wanting features that are 1 release away >.>
04:53:46 * hackagebot caramia 0.7.2.1 - High-level OpenGL bindings  http://hackage.haskell.org/package/caramia-0.7.2.1 (Adeon)
04:54:57 <Adeon> why can't all my favorite packages support 7.10 on the day of release
04:55:24 <merijn> Adeon: Because open source programmers don't get paid enough to ensure that? ;)
04:55:44 <Adeon> I should ask all my money back
04:56:05 <unknownloner> ^ make em pay back every cent
04:56:49 <Adeon> time 1.4/1.5 + deepseq seems to be a sore point for the dependencies I have
04:59:17 <merijn> Adeon: There's a "ignore upperbound" flag for cabal
04:59:26 <merijn> Although, obviously that may backfire and break horribly :)
05:00:56 <hvr> merijn: actually it's partly the package authors to blame (but its their decision of course) to not care much about .1 GHC releases
05:00:57 <Adeon> it's not a proper ghc release if everything is not on fire
05:01:27 <hvr> merijn: you often see filed PRs against packages weeks before the actual release
05:01:33 <merijn> hvr: Sure, but my point is that you shouldn't expect high-responsiveness from people maintaining code in their spare time
05:01:44 <hvr> merijn: which would provide support for the soon to be relased GHC, but package authors not reacting
05:03:34 <hvr> merijn: otoh... the hopeless-ness of day-one package support for new major GHC releases reminds me of something...
05:05:07 <lamefun> Can I compile and run Haskell progams from another Haskell program? Like I can run Lua scripts from C++?
05:05:41 <Adeon> you can
05:06:00 <Adeon> there's GHC API which you can use to dynamically compile and load code if that's what you want
05:06:01 <lamefun> While sandboxing them?
05:06:46 <merijn> Look at mueval
05:07:33 <lamefun> wow
05:07:35 <lamefun> excellent!
05:26:43 <lamefun> Excellent... Haskell is still a toy... https://github.com/haskell/cabal/issues/936
05:26:52 <lamefun> Is there a way to securely install libraries?
05:29:11 <Clint> lamefun: apt-get install libghc-lowercaselibraryname-dev
05:30:22 <lamefun> yum install ghc-SDL2 --> No package ghc-SDL2 available.
05:30:54 <lamefun> Is there any other fast static language that can be sandboxed and which is not a toy?
05:33:03 <jokester> how do you define sandbox
05:33:49 * hackagebot profiteur 0.2.0.0 - Treemap visualiser for GHC prof files  http://hackage.haskell.org/package/profiteur-0.2.0.0 (JasperVanDerJeugt)
05:33:51 <lamefun> Something like browser <--> JavaScript interpreter relationship, core language only includes safe constructs and browser provides sandboxing interface
05:34:30 <merijn> lamefun: No useful languages can ever be sandboxed like that unless you sandbox your entire OS, which isn't currently possible
05:34:33 <merijn> So, no
05:35:12 <merijn> Well, Java attempts to do that in the VM, so that's the only thing you'll find
05:35:26 <merijn> clojure isn't static and scala isn't fast
05:35:51 <merijn> Maybe .NET, so like F# or something, you need something running on a language VM
05:36:47 <mniip> merijn, I tend to disagree
05:36:52 <lamefun> merijn: Mozilla has Asm.js, it's mangles subset of JavaScript that encodes a C-like program with static types, and they say it's in range of 2x - 1.5x native performance.
05:36:54 <nshepperd> pypy has --sandbox, but I doubt you want that
05:37:11 <merijn> mniip: On which part?
05:37:14 <mniip> lua has pretty good sandboxes, and handles being in a ptrace jail pretty well
05:37:27 <merijn> lamefun: I would not call C statically typed
05:37:37 <mniip> oh
05:37:37 <Cale> lamefun: If you care that much, you should be auditing all your packages by hand. Package signing would only make sure that the packages you're getting are the ones that someone uploaded, but essentially anyone can upload packages to Hackage, so you have to know who to trust.
05:37:40 <merijn> lamefun: Also, given the success of JS sandboxing I hesitate to call it sandboxed too
05:37:41 <mniip> you need static typing
05:37:45 <nshepperd> or you could write your programs in Safe Haskell
05:37:56 <merijn> mniip: The request was sandboxed+static types :)
05:38:07 <mniip> TCC in ptrace jail?
05:38:10 <merijn> Cale++
05:38:10 <lamefun> nshepperd: I know, but Haskell itself is a toy.
05:38:28 <nshepperd> so you say...
05:38:36 <merijn> Cale: Not to mention that it's not like you can just install C/C++ libraries without inspecting the source >.>
05:38:42 <merijn> lamefun: Please refrain from trolling
05:38:51 <Cale> lamefun: If Haskell is a toy, then so is essentially every other programming language ever.
05:39:24 <lamefun> nshepperd: once https://github.com/haskell/cabal/issues/936 is fixed it will stop being a toy, but now it's a toy.
05:39:28 <Cale> (I actually think it's a pretty good toy, tbh, but I mean that in a totally non-derogatory way)
05:40:00 <Cale> lamefun: Let's suppose that tomorrow, that issue got fixed. What problem are you having that this would solve?
05:40:12 <Cale> lamefun: Do you know who among the Haskell community is trustworthy?
05:40:18 <lamefun> "Package signing would only make sure that the packages you're getting are the ones that someone uploaded" - at least I don't have to trust the mirror, or every computer between me and the mirror.
05:40:50 <merijn> Cale: I'm trustworthy :)
05:41:11 <merijn> lamefun: Unless the mirror happens to give you the wrong signature...
05:41:31 <merijn> lamefun: Since you have no way to get the signature out-of-band, currently...
05:42:03 <Cale> Right, how would you know that the signatures you're getting are appropriate? You'd need to have communicated with the authors of the packages separately.
05:42:16 <nshepperd> if you're simultaneously that paranoid and that lazy, you can only install packages off github
05:42:24 <nshepperd> since github uses https
05:42:30 <lamefun> merijn: they should be signed by root signature owned by Haskell admins, and public key to it should be in distro's cabal package I install from yum install cabal
05:42:33 <merijn> Or you need to switch to cert based signing, in which case you now need to trust the CA
05:42:35 <arbelos> Is cabal an intrinsic part of Haskell? It is the language "ecosystem" I suppose
05:42:52 <nshepperd> assuming you can somehow trust the "source" link on hackage to be accurate
05:42:58 <merijn> lamefun: And why do the haskell admins decide what gets signed? You expect them to inspect the source of every revision ever?
05:43:03 <Cale> arbelos: Yeah, it's not really part of Haskell, it's just something that a lot of Haskell users use.
05:43:30 <merijn> arbelos: cabal is mostly ecosystem, but it's not even tied to hackage, you can run your own secure mirror and make cabal use that if you want
05:43:50 * hackagebot uulib 0.9.17 - Haskell Utrecht Tools Library  http://hackage.haskell.org/package/uulib-0.9.17 (PhilippHausmann)
05:43:56 <merijn> lamefun: There's no manpower to inspect every version like that, so the admins would just blindly sign tarballs my developers
05:44:00 <lamefun> merijn: automatically, and everything that's uploaded via hackage interface?
05:44:16 <merijn> lamefun: Right, but then you still have to manually verify the contents to be secure
05:44:27 <merijn> lamefun: So you're back to where you are now: Manually verifying the source
05:44:31 <lamefun> merijn: but at least I will know it's what the author uploaded
05:44:48 <merijn> lahwran: Unless the authors password got compromised or his machine or...
05:45:18 <Cale> lamefun: That doesn't solve any problems though. Anyone can upload malicious code as a new package that would get signed and then you would download and execute. The fact that the signature would match the one from some other server doesn't say anything about whether the code is malicious.
05:45:38 <Cale> It just tells you that the code came from the same author as originally uploaded the package.
05:45:47 <lamefun> merijn: did you read all  your OS code?
05:45:56 <merijn> I agree that HTTPS for hackage would best, because that would avoid an actual security issue (i.e. man in the middle)
05:46:10 <merijn> lamefun: No, but I'm not verifying my hackage sources either, so make of that what you will :p
05:46:44 <merijn> But beyond adding HTTPS I don't see much value in signing packages automatically
05:46:48 <Cale> Like, I'm all for increasing the security of Hackage here and there, but I don't see it as a critical issue that needs to be solved immediately or else the world will end.
05:47:05 <lamefun> merijn: with singing, I only have to trust author and Hackage admins, without it I also have to trust mirror and every computer between me and the mirror.
05:47:24 <merijn> lamefun: If we add HTTPS you'd be just as well off
05:48:02 <merijn> Cale: Well, I can see how lack of HTTPS is an issue if you don't trust your uplink providers (which would be sensible in a bunch of countries, including, probably, the US)
05:48:09 <Cale> Let's be real here, you probably already end up trusting computers in between you and other servers on a regular basis.
05:48:22 <Cale> Unless you *always* *only* use HTTPS.
05:48:40 <lamefun> merijn: yes, but downloads are slower due to encryption, HTTPS is signing+encryption, and packages are public and not secret, so HTTPS is just a waste.
05:49:20 <Cale> The download speed hit is going to be trivial when you're downloading a handful of kilobytes of source code
05:49:38 <lamefun> ok
05:49:51 <merijn> lamefun: Without HTTPS how do you stop a man-in-the-middle from replacing your signed+trusted package with a signed+malicious package?
05:50:13 <lamefun> "Let's be real here, you probably already end up trusting computers in between you and other servers on a regular basis." - It's not a problem for normal informational websites, but I'd rather want HTTPS when downloading code that'll be executed unrestricted on my computer.
05:50:15 <merijn> If anyone can sign packages by uploading I can trivially upload and sign a malicious package and inject that instead of your package from trusted author X
05:50:35 <nshepperd> after people trolling for a long time in just this manner, archlinux implemented package signing. i don't feel much safer now really
05:50:58 <lamefun> merijn: by checking signature against hackage root signature?
05:51:10 <merijn> lamefun: My malicious package WILL be signed by the hackage root
05:51:22 <merijn> lamefun: Since I uploaded it to hackage and get it signed
05:51:34 <merijn> I'm just tricking you into downloading the wrong package as a man-in-the-middle
05:51:54 <merijn> So, signing without HTTPS is worthless and with HTTPS signing doesn't really help, so we should just implement https
05:52:03 <hvr> merijn: I just posted a response to the withering-platform thread based on you what your reminded me of :)
05:52:19 <hvr> -you -r
05:52:24 <nshepperd> I would assume that this signature would include information like the name of the package and the user account that uploaded it
05:52:37 <lamefun> file-name will be signed too, and hackage won't let you upload a file-name that was already uploaded by my trusted author, then cabal will notice that it downloaded a different package and abort
05:52:48 <nshepperd> but I agree anyway, HTTPS should be the default for all internet traffic
05:52:58 <merijn> nshepperd: Right, but since I'm injecting both signature and package how would you notice?
05:53:07 <merijn> nshepperd: Unless you get the signature out of band
05:53:09 <osa1> what is the difference between QuosiQuotes extension and TemplateHaskell?
05:53:39 <merijn> osa1: Quasiquote are a convenient way to pass strings to a "String -> Q a" template haskell function
05:54:15 <lamefun> merijn: uhm, if you inject bad package with good signature, the signature won't match the package?
05:54:41 <osa1> merijn: but TemplateHaskell subsumes QuasiQuotes, right?
05:55:09 <merijn> lamefun: I'm saying: You try to download package X with signature X, I uploaded malicious package Y with signature Y. I, as man-in-the-middle trick you into downloading Y when cabal tries to download X. How do you detect what's going wrong?
05:55:17 <dpn`> for someone so dedicated to security you seem to be having trouble with something quite fundamental
05:55:20 <merijn> Since you're also downloading my valid signature Y
05:55:31 <nshepperd> merijn: The hypothetical automatic signing bot running on hackage would presumably sign certificates of the form {file name, upload date, file MAC} rather than the package itself
05:55:37 <merijn> osa1: Anything quasiquotes can do, TH can do, yes
05:56:06 <phaazon> hey, the OpenCL wrapper is not up to date, right?
05:56:21 <merijn> nshepperd: Right, but how does that help when I trick you into validating the wrong signature? (i.e. the one for my malicious package)
05:56:23 <phaazon> is there a way to know whether it supports OpenCL 2?
05:56:36 <phaazon> I guess it won't support 2.1
05:56:37 <merijn> nshepperd: Since I can intercept both package and signature download?
05:56:52 <merijn> phaazon: Does any manufacturer even support OpenCL 2 yet?
05:56:59 <merijn> phaazon: They didn't when I looked last year
05:57:16 <merijn> My recommendation, by any nVidia card and use CUDA >.>
05:57:18 <merijn> *buy
05:57:31 <lamefun> merijn: my trusted author already uploaded package X, hackage won't allow you upload your bad package with the name X, and you'll have to upload it with name Y. Hackage should be designed so that when someone uploads a package under a name X, from now on only he or she can get valid signatures for packages with name X.
05:57:53 <nshepperd> merijn: you could certainly supply a signed certificate {"Y", MAC(Y)}, but then the client would notice that "Y" ≠ "X", and that this is not X
05:58:02 <merijn> lamefun: I'm not uploading package X, I'm man-in-the-middling your download since you don't use HTTPS
05:58:11 <dpn`> you're downloading package  Y because MITM
05:58:23 <dpn`> >_<
05:58:38 <dpn`> or you're dealing with an idiot who can't pull off a decent MITM
05:58:42 <dpn`> :P
05:59:10 <nshepperd> merijn: you can't supply a certificate {"X", MAC(Y)} because mythical hackagebot will refuse to give a signature for such a thing
05:59:11 <phaazon> merijn: as Vulkan gets released, we'll need a way to generate OpenCL 2.1 compilant LLVM code
05:59:45 <osa1> does anyone know what does new DWARF support give us? how do I use it?
05:59:51 <lamefun> merijn: if you haven't uploaded anything at all, you can't provide ANY valid signature, because Hackage private key is owned by Hackage admins.
05:59:52 <dpn`> nshepperd, in an MITM you would not ever touch package X
06:00:00 <dpn`> only Y for both signature and package contents
06:00:04 <merijn> osa1: DWARF is a format for debugging symbols, allowing you to get, i.e. source locations from stacktraces
06:00:18 <merijn> osa1: It's what you use in, for example, gdb to get source info for C/C++ code
06:00:31 <ij> Is forkIO rather like a coroutine rather than procedure that directly instantiates a new thread? — 1 forkIO != 1 new thread?
06:00:41 <ij> too much rather... anyway
06:00:49 <duke_leto> lamfun, so your client needs to know a list of trustworthy keys?
06:00:55 <merijn> osa1: So, we should, once DWARF support improves be able to get stack traces/source locations from exceptions :)
06:01:09 <merijn> ij: forkIO is a lightweight thread
06:01:20 <merijn> ij: GHC multiplexes N lightweight threads onto M OS threads
06:01:34 <merijn> ij: Where N can be hundreds of thousands/millions
06:01:37 <osa1> merijn: OK but those stack traces will be GHC RTS traces, right? not Haskell stack traces(e.g. not cost-center stacks)
06:01:47 <merijn> osa1: tbh, I don't know
06:01:50 <osa1> I asked this question many times
06:01:53 <osa1> never got any answers
06:01:58 <osa1> it seems like nobody really knows
06:02:02 <ij> How does that differ from a coroutine?
06:02:03 <merijn> osa1: Try asking in #ghc or on ghc-devs mailing list
06:02:15 <merijn> ij: Depends on your definition of a coroutine
06:02:22 <lamefun> merijn: Hackage admins have private key, cabal user has public key. Every package that's successfully uploaded to Hackage is signed by that key. By checking the signature, user can know that the package is from Hackage. To replace the package, you have to either hack Hackage and get their private key or hack the package author and get their Hackage password. No MITM is possible.
06:02:35 <merijn> ij: coroutines are (usually) cooperative, GHC threads are preemptive (mostly...)
06:02:58 <merijn> lamefun: How'd you get the public key?
06:03:03 <nshepperd> dpn`: a signature is useless unless it provides evidence that the package is actually X. so, such a certificate must necessarily contain the string "X" somewhere in its data
06:03:07 <lamefun> merijn: yum install cabal
06:03:17 <Adeon> you can get an operating system thread with forkOS, it has the same type signature as forkIO
06:03:21 <Adeon> but you usually don't want to
06:03:21 <merijn> lamefun: I don't know what the hell yum is or why I should trust it
06:03:22 <ij> merijn, Thus if all coroutines want to run forever, ONLY n will ever run and none others?
06:03:29 <ij> ptfu
06:03:29 <merijn> Adeon: forkOS doesn't give you an OS thread
06:03:30 <lamefun> merijn: Fedora package manager.
06:03:32 <ij> I mean 
06:03:44 <Adeon> merijn: in GHC, it does
06:03:44 <ij> if all forkIO "threads" want to run forever..
06:03:57 <merijn> ij: No, preemptive means they get unscheduled like OS threads
06:04:00 <merijn> Adeon: No
06:04:14 <Adeon> it's in the source, you can check it
06:04:15 <merijn> Adeon: forkOS guarantees that your thread will ALWAYS run on the SAME OS thread
06:04:17 <Adeon> forkOS calls pthread_create
06:04:20 <ij> merijn, not sure what that means.
06:04:21 <Adeon> it's an implementation detail
06:04:25 <merijn> Adeon: It doesn't guarantee it will
06:05:13 <merijn> ij: In preemptive scheduling a thread gets N time frames to run before being unscheduled to let another thread run
06:05:34 <merijn> ij: In cooperative scheduling (like most coroutines) a thread is ONLY unscheduled when it explicitly yields/stops
06:05:59 <dpn`> nshepperd, It's late here, so I could be brainfarting, but I think you're right
06:06:00 <merijn> ij: Thus you can basically think of "forkIO" as OS threads, but without being expensive
06:06:06 <cfoch> what is the better hackage to *plot* charts on HaskelL?
06:06:20 <lamefun> merijn: Fedora is a big known distro, they have HTTPS SHA256SUM download, they also plan/have reproducible package builds. Debian has reproducible builds too and it's a big distro too.
06:06:27 <cfoch> GNUPlot, Chart, or other maybe?
06:07:15 <ij> merijn, Where have you encountered the coroutines you've described? I'ven't dealt with concurrency much.
06:08:12 <lamefun> merijn: the point is, package signing, HTTPS, sandboxing lets you reduce the number of people you have to trust and that's always a good thing.
06:08:21 <merijn> ij: GNU coroutine library and most traditional coroutine literature
06:08:42 <merijn> ij: goroutines from go, despite the name, aren't actually related to coroutines at all, for example :)
06:08:48 <ij> Oh!
06:08:55 <lamefun> merijn: ask yourself this: why do most Linux distros have signed packages? Surely you can simply just trust that hey haven't been tampered with by mirrors!
06:09:01 <ij> That's where the confusion comes from. I was abotu to say i've been exposed to them.
06:09:10 <merijn> ij: forkIO is pretty much like erlang processes/goroutines
06:09:19 <merijn> ij: forkIO may actually be even cheaper than those two
06:10:30 <ij> Nice! I can't wait to use them. 
06:10:38 <jacksnipe> possibly dumb question: can I use forkIO to do non IO work? That seems valuable
06:11:15 <ij> There was a way to parallelize it without IO — pseq or something.
06:11:25 <merijn> jacksnipe: Sure, but if you have parallelism without IO, there's even better ways
06:11:30 <merijn> jacksnipe: like pseq and strategies
06:11:31 <jacksnipe> ah okay, thanks guys
06:11:34 <lamefun> merijn: if a package is popular it's probable that some other people have looked into it. I can use the reputation of the package among other developers, its popularity as a rough measure of the risk. Without package signatures, I can't do that because I don't know at all what I'm downloading.
06:11:55 * ij goes to look how to get channels.
06:12:04 <merijn> ij: Control.Concurrent.Chan :p
06:13:04 <ij> Dank je!
06:18:53 * hackagebot bound-gen 0.1.0.0 - Unwrap Scope's with globally fresh values  http://hackage.haskell.org/package/bound-gen-0.1.0.0 (jozefg)
06:19:06 <ij> About terminology: parallel -> concurrent or concurrent -> parallel?
06:19:16 <ij> -> implies
06:20:11 <merijn> neither
06:20:25 <merijn> Concurrency is about semantics, i.e. things happening in a undefined order
06:20:44 <merijn> You can fake the semantics sequantially (by, for example, time sharing a single core CPU)
06:20:58 <zipper> Oh man I totally missed a discussion on forkIO
06:21:02 <merijn> parallelism is about implementation (executing tasks "in parallel")
06:21:09 <ij> Ok then. Channels generally don't have an isEmpty operation, since it's not very trustworthy in a concurrent environment?
06:21:17 <merijn> ij: Right
06:21:23 <ij> zipper, I can paste it for you.
06:21:28 <merijn> ij: But, see Control.Concurrent.STM.TChan
06:21:34 <zipper> ij: Please do
06:21:38 <merijn> ij: For transactional channels that DO support isEmpty
06:22:09 <merijn> Since STM guarantees all blocks to be atomic, therefore you can usefully use isEmpty without races
06:23:53 * hackagebot bound-gen 0.1.0.1 - Unwrap Scope's with globally fresh values  http://hackage.haskell.org/package/bound-gen-0.1.0.1 (jozefg)
06:27:45 <merijn> ij: Also, relevant term for the lack of isEmpty is TOCTOU races (time of check, time of use)
06:30:33 <bennofs> In data A = A { field1 :: Int, field2 :: ... }, how do you call "field1" correctly? record selectors?
06:30:47 <merijn> record selectors or fields, yeah
06:36:41 <hvr> heh... now even Phoronix reports about GHC: http://www.phoronix.com/scan.php?page=news_item&px=GHC-7.10.1-Released
06:55:31 <gregnwosu> whats the migration path for ghc 7.10
07:00:00 <hvr> gregnwosu: https://ghc.haskell.org/trac/ghc/wiki/Migration/7.10
07:00:20 <gregnwosu> thanks
07:00:35 <absence> there's no mechanism like join for two different monads in general right? specific functions like catMaybes are required?
07:00:49 <ij> :t join
07:00:50 <lambdabot> Monad m => m (m a) -> m a
07:01:07 <ij> Or are those the same monads... Hmm, not sure.
07:01:17 <absence> ij: they are
07:01:42 <gregnwosu> transformers inbed monads
07:02:12 <absence> hmm..
07:02:31 <absence> gregnwosu: you can't collapse a transformer stack though, can you?
07:02:37 <mniip> absence, you can probably come up with something for MonadPlus m => m (Maybe a) -> m a
07:02:39 <mniip> and a few other
07:02:42 <mniip> but not in general
07:02:57 <gregnwosu> collapse to what?
07:03:07 <gregnwosu> its a monad
07:03:25 <gregnwosu> there may be an isomorphism , you can fold and hoist
07:03:56 * hackagebot bound-gen 0.1.0.2 - Unwrap Scope's with globally fresh values  http://hackage.haskell.org/package/bound-gen-0.1.0.2 (jozefg)
07:04:32 <Baughn> https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/syntax-extns.html#traditional-record-syntax  <- "Traditional record syntax --"
07:04:35 <Baughn> I think I missed something.
07:04:42 <Baughn> Is there another type of record syntax?
07:04:50 <gregnwosu> lol
07:05:13 <gregnwosu> Baughn: i guess you can just declare a datatype with arguments
07:05:30 <Baughn> Sure, but I'd be surprised if it's talking about that.
07:06:05 <gregnwosu> Baughn: I think also it may be talking about tradition as in across languages
07:06:21 <gregnwosu> i believe erlang has a similar syntax for records
07:07:00 <gregnwosu> k ttfn
07:07:36 <cfoch> Hello. Could somebody please give me an opinion about my proposal? 
07:07:40 <cfoch> http://cfoch-dev.tumblr.com/post/114754745097/analyzing-stock-market-in-haskell
07:07:50 <mauke^> https://github.com/ghc/ghc/blob/eb3661f2b9f8472f3714774126ebe1183484dd85/compiler/parser/RdrHsSyn.hs#L732
07:07:53 <mauke^> well then
07:09:23 <Baughn> mauke^: This tells me very little. It's an extension that lets you turn off part of the language, with no real replacement?
07:09:47 <Baughn> I might guess it's for 7.12, but.. oh, there's probably a discussion somewhere.
07:09:49 <Baughn> I'll go look.
07:11:28 <Baughn> Looks like that's right, unless something happened since it was added in 7.2. There is no non-traditional syntax yet.
07:12:03 <nshepperd> :t (>>= maybe mzero return)
07:12:04 <lambdabot> MonadPlus m => m (Maybe b) -> m b
07:15:35 <safinaskar> how to fully evaluate some function f? (in any context or in IO monad, e. g. in main) i want to fully evaluate f because f may throw exception (i. e. "error") and i want to ensure that f evaluated successfully without throwing exception
07:15:44 <safinaskar> i tried some ways and they didn't helped
07:15:59 <mauke^> f `seq` ...
07:16:18 <Baughn> safinaskar: NFData / rnf. However, I'd recommend making your pure functions total instead, and returning the error as part of the type.
07:16:27 <safinaskar> for example, how to "evaluate" expression "Just (error "a")" and see this error? and throw return value?
07:16:43 <safinaskar> > do { Just (error "") `seq` return (); } :: IO ()
07:16:45 <lambdabot>  <IO ()>
07:17:08 <mauke^> that's not a function
07:17:20 <safinaskar> > Just (error "") `seq` ()
07:17:21 <lambdabot>  ()
07:17:41 <safinaskar> > do { return (Just (error "") `seq` ()); } :: IO ()
07:17:42 <lambdabot>  <IO ()>
07:17:56 <safinaskar> do { Control.Exception.evaluate $ Just $ error ""; return (); } :: IO ()
07:18:03 <safinaskar> > do { Control.Exception.evaluate $ Just $ error ""; return (); } :: IO ()
07:18:04 <lambdabot>  <IO ()>
07:18:12 <safinaskar> i did all this ways and none of them helped
07:18:32 <mauke^> my answer was for functions
07:18:51 <safinaskar> mauke^: "seq" doesn't work.      "Just (error "") `seq` ()" happily successfully evaluates without throwing exception
07:19:10 <mauke^> <mauke^> that's not a function
07:19:21 <mauke^> <mauke^> my answer was for functions
07:19:26 <safinaskar> Baughn: okey, thanks, i will consider NFData
07:19:46 <Baughn> safinaskar: Don't do that until you understand what's going on
07:20:36 <Baughn> safinaskar: seq is usually the correct answer. rnf is a sledgehammer, and costly to run; it'll traverse the entire data structure.
07:20:59 <Baughn> safinaskar: ...well, except when the correct answer is "Return an error as a value instead of bottom.")
07:21:04 <safinaskar> mauke^: not a function? okey, let's assume i have function "f _ = Just (error "")" and i want to "evaluate" "f 0"
07:21:14 <mauke^> safinaskar: f 0 is not a function
07:21:57 <safinaskar> mauke^: when i say "evaluate a function", of course, i mean "function with its arguments", i. e. "function applied to its argument". strictly speaking i mean "expression", not function
07:21:58 <Baughn> safinaskar: f is a function, f 0 is a value, possibly a thunk.. do you know about thunks?
07:22:24 <mauke^> safinaskar: so by "function" you mean "not a function"
07:22:47 <mauke^> > (undefined :: Int -> String) `seq` ()
07:22:49 <lambdabot>  *Exception: Prelude.undefined
07:23:10 <Baughn> > error "foo" `seq` ()
07:23:10 <mauke^> seq is sufficient for functions because they have no nested structure
07:23:12 <lambdabot>  *Exception: foo
07:23:21 <Baughn> > Just (error "foo") `seq` ()
07:23:23 <lambdabot>  ()
07:23:45 <dfeuer> Func you!
07:24:05 <safinaskar> mauke^: what is trunk?
07:24:07 <safinaskar> dfeuer: :)
07:24:16 <safinaskar> mauke^: *thunk
07:24:20 <Baughn> safinaskar: https://wiki.haskell.org/Thunk
07:24:34 <Baughn> safinaskar: This covers what you need to know before you can usefully use seq/rnf and their kin.
07:24:40 <mauke^> thunk is the past tense of think at 3 in the morning
07:25:10 <dfeuer> mauke++
07:25:42 <nkar`> cfoch: I think there will be quote a few proposals, so in order to get selected you need to pick a project that'd be widely used by the community.  I also suggest to post your proposal to the haskell-cafe mailing list (or the gsoc-related list if there's one), so you could get more feedback
07:26:09 * Baughn wonders if anyone has proposed a Stubby implementation
07:26:26 <Fizzixnerd> has the problem with ghc-mod being built on ghc 7.10 with cabal 1.22 been fixed behind the scenes?  I can't find one on the web
07:26:29 <Baughn> ...'scuse me, gRPC
07:26:41 <nkar`> cfoch: also search for "gwern google summer of code" for a nice write up, which should give you some hints
07:27:11 <nkar`> cfoch: finally, this is just my opinion, I'm not in charge of selecting people or something
07:28:01 <jerbome_> :t runCont
07:28:02 <lambdabot> Cont r a -> (a -> r) -> r
07:28:35 <merijn> Fizzixnerd: There's an alternative in progress
07:28:57 * hackagebot mime-mail 0.4.8.2 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.4.8.2 (MichaelSnoyman)
07:29:09 <poi__> :t use
07:29:10 <lambdabot> MonadState s m => Getting a s a -> m a
07:29:22 <merijn> Fizzixnerd: Chris Done is working on ghci-ng, which extends ghci with all the typing/tagging/etc. functionality of of ghc-mod/hdevtools and will give us the ability to use ghci for those things, which ensures it works with different ghc versions and supports sandboxes
07:29:45 <Fizzixnerd> merijn: is it usable at the moment?
07:30:35 <merijn> Fizzixnerd: I don't know how well it's supported by editor plugins atm, but it's usable
07:30:47 <merijn> Fizzixnerd: See https://github.com/chrisdone/ghci-ng
07:32:31 <Fizzixnerd> merijn: thanks for the info
07:34:51 <voidzero> mauke^, when my thinking changed to thunking last night, that was when i realised i should get some rest :)
07:35:31 <Baughn> voidzero: Wait for it. One of these days you'll start dreaming about lazily-evaluated worlds.
07:36:10 <voidzero> LOL no shortage of Haskell in my dreams.. today I woke up with Lefts and Rights everywhere
07:37:13 <voidzero> I'll just consider it progress while learning the language :)
07:37:18 <jerbome_> please, go ahead, I'm curious at what would be haskell jokes
07:37:27 <cYmen__> What is the meaning of $ in haskell, it seems to pop up in weird places. :p
07:37:40 <jerbome_> cYmen__, it's function application
07:37:50 <voidzero> cYmen__, you can try ':info ($)' on the ghci prompt
07:37:55 <Iceland_jack>  
07:37:55 <Iceland_jack> @src ($)
07:37:56 <lambdabot> f $ x = f x
07:37:56 <jerbome_> f $ a = f a
07:38:10 <ion> f $ b = f b
07:38:20 <Baughn> cYmen__: As a rule of thumb, $ means "left paranthesis".
07:38:23 <jerbome_> cYmen__, looks useless right ? ;)
07:38:34 <cYmen__> So uh...
07:38:36 <ion> baughn: foo <> bar $ baz
07:38:41 <Baughn> cYmen__: Automatically closed at the rightmost possible point. This isn't /correct/, but it'll work for a while.
07:38:55 <Baughn> ion: Yes, finding counterexamples is easy.
07:39:12 <cYmen__> I hate it already. :p
07:39:46 <barrucadu> cYmen__: `foo $ bar baz bat` vs `foo (bar baz bat)`
07:39:49 <barrucadu> It's a style thing
07:40:03 <barrucadu> But sometimes it's useful in its own right
07:40:26 <Iceland_jack> cYmen__: It's (basically) just a way to avoid parentheses, it's quite alright to prefer the parens
07:40:26 <barrucadu> > map ($5) [(+1), (*2), id]
07:40:27 <lambdabot>  [6,10,5]
07:40:52 <Iceland_jack> There are some other cases like barrucadu mentioned, but they're less common
07:41:11 <Baughn> > map ($ 3) [(1 +), (2 *)]
07:41:13 <lambdabot>  [4,6]
07:41:33 <saep> > map (\f -> f 5) [(+1), (*2), id] -- and you can use lambdas ;)
07:41:35 <lambdabot>  [6,10,5]
07:41:37 <Iceland_jack> > [ f 5 | f <- [(+1), (*2), id] ]
07:41:39 <lambdabot>  [6,10,5]
07:41:47 <Iceland_jack> Or list comprehensions, the world is your oyster :)
07:42:43 <jerbome_> can list comprehension syntax be used for other monads ?
07:42:55 <Iceland_jack> Ys
07:42:56 <Iceland_jack> *Yes
07:42:57 <cYmen__> I'm surprised map ($5) puts the function as the first argument....
07:43:02 <Iceland_jack> Via MonadComprehensions
07:43:07 <merijn> cYmen__: Why?
07:43:14 <jerbome_> :i MonadComprehensions
07:43:15 <merijn> cYmen__: ($5) is section notation
07:43:16 <Baughn> cYmen__: It's the same as (/ 2)
07:43:23 <Rotaerk> > [(+1), (*2), id] <*> [5]
07:43:25 <Iceland_jack> cYmen__: Keep in mind that
07:43:25 <lambdabot>  [6,10,5]
07:43:25 <Iceland_jack>     ($ 5)
07:43:25 <Iceland_jack> is the same as
07:43:25 <Iceland_jack>     (\x -> x $ 5)
07:43:26 <Baughn> > (/ 2) 4
07:43:28 <lambdabot>  2.0
07:43:39 <Iceland_jack> And (\x -> x $ 5) is the same as (\x -> x 5)
07:43:39 <cYmen__> Apparently I don't know section notation
07:43:59 <Iceland_jack> That's a nice place to start
07:44:04 <Baughn> cYmen__: For any binary operator, you can neglect to provide one parameter (like above), and you'll get a one-parameter function.
07:44:10 <Baughn> @type (/ 2)
07:44:11 <lambdabot> Fractional a => a -> a
07:44:17 <mauke^> ... if you wrap the whole thing in parens
07:44:19 <merijn> cYmen__: Any operator is expanded (roughly, this is not entirely accurate) as "(*2)" -> "\x -> x * 2" and "(2*)" -> "\x -> 2*x"
07:44:26 <mauke^> you can't just write 2 +
07:44:28 <mauke^> it has to be (2 +)
07:44:30 <merijn> Also
07:44:37 <merijn> This is not restricted to binary operators
07:44:42 <jerbome_> > ((\) 2) 4
07:44:43 <lambdabot>  <hint>:1:4: parse error on input ‘)’
07:45:01 <cYmen__> merijn: How would it look for a ternary? Can I only set first and second?
07:45:06 <jerbome_> > (\) 2 4
07:45:08 <lambdabot>  <hint>:1:3: parse error on input ‘)’
07:45:13 <jerbome_> > ((/) 2) 4
07:45:15 <lambdabot>  0.5
07:45:40 <Baughn> A binary operator could in any case return a function, in which case it's not really binary
07:45:40 <merijn> let (\\) x y z = x - y + z in (\\10) 20 5
07:45:45 <merijn> > let (\\) x y z = x - y + z in (\\10) 20 5
07:45:45 <c_wraith> Polarina: (sorry, was asleep).  Now that I've slept all night, I see that those parameters are actually fine, since Window and Renderer are type aliases for Ptr types.  Sorry for the confusion.
07:45:46 <lambdabot>  15
07:45:58 <merijn> cYmen__: You can only set first and second, yeah
07:50:29 <cYmen__> Alright...
07:50:47 <cYmen__> Thanks!
07:51:18 <Polarina> c_wraith, no problem. :)
07:52:35 <nitrix> Hi, how does one parses   line ::= <char> <number> '=' {<resource> ','} [<resource>] with parsec?
07:53:28 <indiagreen> <char> would be “anyChar”
07:53:30 <nitrix> The combinators make sense, sepBy, many, etc, but how to have multiple combinations togheter?
07:53:35 <indiagreen> ah
07:53:47 <indiagreen> you can use applicative or monad interface
07:54:02 <nitrix> So, <*> ?
07:54:06 <nitrix> Let me see.
07:54:12 <indiagreen> with monad, you just do: “do {c <- anyChar; n <- number; ...; return (c,n,...)}”
07:54:40 <indiagreen> with applicative, you do (for instance, if your want to get back a record): “Line <$> anyChar <*> number <*> ...”
07:55:07 <indiagreen> or, if you want a tuple, use “(,,,,)” instead of “Line” (with as many commas as you need)
07:57:04 <nitrix> Is there a difference between Parsec's <|> and the prelude <|> ?
07:57:11 <merijn> no
07:57:15 <indiagreen> yes
07:57:19 <indiagreen> fixity
07:57:22 <indiagreen> other than that, no
07:57:29 <merijn> oh? Different fixity?
07:57:33 * indiagreen sighs
07:57:34 <indiagreen> yes
07:57:42 <merijn> nitrix: Parsec was written before <|> was in Prelude :)
07:58:18 <indiagreen> if not for it, I'd already be making pull requests to replace it with a reexport
07:58:59 * hackagebot uhc-light 1.1.8.10 - Part of UHC packaged as cabal/hackage installable library  http://hackage.haskell.org/package/uhc-light-1.1.8.10 (AtzeDijkstra)
07:59:15 <nshepperd> infixr 1 vs infixl 3
07:59:20 <nshepperd> how inconvenient
07:59:38 <indiagreen> it's sad how every parsing library reinvents Alternative
07:59:48 <indiagreen> “many”, “optional”, “<|>”, etc.
08:00:07 <merijn> indiagreen: to be fair, as mentioned, alternative didn't exist at the time parsec was written
08:00:22 <indiagreen> yep, I know, but still sad
08:00:36 <merijn> attoparsec doesn't :)
08:01:43 * indiagreen looks
08:01:48 <indiagreen> okay, that's nice
08:02:03 <indiagreen> don't know why I thought it did, too
08:02:44 <nitrix> http://lpaste.net/129746
08:02:45 <nitrix> Oh god.
08:02:49 <nitrix> What have I done.
08:03:31 <indiagreen> the 1st “<*>” everywhere should be “<$>”
08:03:50 <nitrix> Oh
08:04:09 <nshepperd> I see that attoparsec defines their own 'many1 = some' though
08:04:44 <nshepperd> which is but a small crime I guess
08:04:56 <nitrix> I'm having a lot of `ambiguous` errors. Probably because of my anyToken ?
08:05:28 <nitrix> This is where Haskell gets confusing. The types are huge.
08:06:18 <merijn> nitrix: Solution, add an explicit type for your parser
08:06:33 <merijn> nshepperd: attoparsec strives to be almost drop-in replacement for parsec
08:10:15 <nitrix> merijn: http://lpaste.net/129746
08:11:09 <nitrix> merijn: It seems it's complaining from me using a Data.Text, I would expect that, but instead, it says type variables s1,m1 and ambiguous, wth.
08:11:18 <merijn> nitrix: That's not your parser
08:11:22 <merijn> That's your function
08:11:41 <merijn> nitrix: Parsec parsers are polymorphic and can handle String, Text, and a bunch more with local state, etc.
08:11:54 <merijn> It can't figure out which thing you're using
08:12:39 <merijn> Annotate with the Parser type from, for example, Text.Parsec.Text (if you're using Text)
08:15:37 <nitrix> I'm giving up.
08:15:49 <nitrix> I rarely say that, but this is too much.
08:16:14 <nitrix> The types are getting too ridiculous, I feel like working with some stupid Java.
08:16:22 <merijn> Wut
08:16:37 <merijn> You can just use the Parser type synonyms and the relevant module
08:16:53 <merijn> Like I said, Text.Parsec.Text.Parser if you're using Text
08:17:23 <beaky> hello
08:17:25 <merijn> Then you just write "Parser Int" or whatever as type for your parsers
08:17:26 <beaky> how do i debug infinite loops
08:18:01 <safinaskar> Baughn: "rnf" requires me to write "deriving NFData" to every my datatype. is there the same, but working for any datatype? maybe some very internal/unsafe ghc's function with "#"s?
08:18:25 <beaky> i have this code and its causing my program to never terminate when i use it :( http://lpaste.net/129749
08:20:00 <jameseb> beaky: what sort of lists are you running that on?
08:20:25 <geekosaur> that code itself is not beorken (althogh it is somewhat questionable based on use). show a full example where it fails?
08:20:26 <beaky> lists of Data.Scientific numbers
08:21:13 <geekosaur> *broken
08:23:53 <beaky> http://lpaste.net/129750
08:24:38 <cchalmers> beaky: Scientific calculates the exact representation, so 1/3 will never terminate for example
08:25:31 <beaky> oh 
08:29:02 * hackagebot kure 2.16.10 - Combinators for Strategic Programming  http://hackage.haskell.org/package/kure-2.16.10 (NeilSculthorpe)
08:29:30 <enthropy> safinaskar: th-reify-many might be helpful
08:29:55 <ozgura> so you know how the binary release of ghc (for linux) comes as two separate downloads: one for GMP 4.x and one for GMP 5.x onwards
08:29:56 <ozgura> like in https://www.haskell.org/ghc/download_ghc_7_8_4#x86_64linux
08:30:23 <ozgura> I'd like to write a script which downloads & installs the appropriate one for a system
08:30:26 <jerbome_> in a lot of online docs, I see State defined as newtype State s a. However when I do :i State in ghci , I have type State s = StateT s Identity. Why is it different ?
08:30:31 <jerbome_> :i State
08:30:36 <ozgura> how would I go about telling which one is required?
08:30:43 <ozgura> did anyone need this before?
08:30:45 <merijn> jerbome_: Because it means it plays nicer with existing code
08:31:38 <geekosaur> jerbome_, mtl1 used the former, mtl2 uses the latter which is in some ways more flexible and means less code duplication between State and StateT.
08:31:42 <merijn> jerbome_: It means everything only ever has to be defined for StateT and it'll work for both State and StateT, also with packages like mmorph it means you can easily generalise existing State code to some more complex transformer stack
08:31:52 <geekosaur> ozgura, how you do that depends on what kind of system you're on
08:32:13 <geekosaur> you need to inspect your system package manager(s) to see which gmp is available
08:32:23 <jerbome_> I see
08:32:24 <jerbome_> thanks
08:32:38 <ozgura> geekosaur: I thought you could look into the LD_LIBRARY_PATH or something to tell
08:32:50 <geekosaur> only if it's already installed
08:32:55 <geekosaur> which the runtime part might be
08:33:01 <geekosaur> *might*
08:33:01 <Baughn> safinaskar: No, and using rnf is usually the wrong decision.
08:33:20 <ozgura> so this is not as easy as I thought it was going to be
08:33:20 <Baughn> safinaskar: There are three common ways to handle errors in Haskell.
08:33:31 <ozgura> oh well
08:33:35 <geekosaur> gmp is not something that is automatically available everywhere
08:34:05 <Baughn> safinaskar: 1, exceptions. These should only be used in the IO monad, where they can be caught; you can throw from pure code, but then you never really know when the exception will end up being thrown, so start out only doing it in IO code. (And, preferably, stick to that.)
08:34:14 <ozgura> I want to check if it is available, and if so which version
08:34:25 <Baughn> safinaskar: 2, explicit error values. A common pattern is to return "Either String a" instead of "a".
08:35:00 <Baughn> safinaskar: 3, implicit error values via monads or similar. There are even exception monads. These guarantee appropriate ordering, even in pure code, so you don't get surprises.
08:35:43 <voidzero> related to that, is there something i should know now that my case expressions are slowly progressing to the right of my screen?
08:36:03 <Baughn> safinaskar: #4, calling error/using undefined, should as a rule of thumb only be done if you don't /care/ when or whether the error is seen at all, and you definitely shouldn't try to catch them.
08:36:09 <enthropy> indent less
08:36:13 <Baughn> safinaskar: I.e. only if it's okay to crash.
08:36:43 <Baughn> voidzero: case (a, b) of
08:36:44 <voidzero> i have some functions and if they return Left, the caller returns Left, else continue with the Right value
08:36:54 <Baughn> voidzero: Maybe monad, error monads, etc.
08:36:59 <merijn> That's just the Either monad...
08:37:12 <Baughn> Or the Either String monad, yeah. :)
08:37:20 <merijn> "(>>=) :: Either e a -> (a -> Either e b) -> Either e b"
08:38:34 <voidzero> ah darn. *grabs his Real World Haskell copy, again*
08:39:08 <Baughn> > do { a <- Right 42; b <- Left "err"; return a }
08:39:10 <lambdabot>  Left "err"
08:39:16 <Baughn> voidzero: ^ Like so
08:39:40 <Baughn> safinaskar: ^- You too
08:40:31 <Baughn> voidzero: It's a very simple monad. Implementing it on your own would be a good exercise, but using it is easy.
08:40:48 <voidzero> Yeah I've been using the Either monad
08:43:00 <dncr> If f :: Int -> Int involves a constant calculation, like f x = x + sum [1..9^6], is it common to make a new top-level crazyConst :: Int so that computation isn't repeated as f is called for new x's?
08:43:29 <voidzero> I'm playing with Text.Toml. In my program the configuration file is mandatory. So now I'm looking at different ways of how to check whether mandatory settings have been set. If they haven't, then display which ones, and exit.
08:43:31 <voidzero> https://github.com/cies/htoml
08:43:42 <Baughn> dncr: No, only if profiling shows that to be necessary.
08:43:46 <voidzero> Baughn, so for that I'm using Either, now.
08:43:55 <voidzero> and Maybe.
08:43:55 <Baughn> dncr: I'd suspect your particular example would be caught by compile-time constant folding.
08:45:34 <dncr> Baughn: Is that really a good approach if you want your code to not be at the whim of different optimization schemes in different compiler versions?
08:46:00 <voidzero> Got it to work yesterday, but I was wondering whether "case someStep in Left a -> return (Left a) ; Right a -> do ..." is the right way.
08:46:27 <voidzero> s/is the right way/is an acceptable way/, :)
08:46:59 <voidzero> because I need to issue many of these checks before the program is allowed to run.
08:49:58 <voidzero> I decided on a staged approach - stage 1 is the setup stage where stage 1a checks the config, stage 1b makes a connection, stage 1c sends greeting strings. If all of this goes without a failure, move to stage 2, the "running" stage.
08:50:01 <voidzero> that was my idea.
08:51:08 <Baughn> dncr: I wouldn't want to depend on optimisation for anything big, or asymptotic changes, but the expression you gave is pretty cheap.
08:51:14 <voidzero> I'm writing a client, could be for IRC, XMPP, some other protocol. It doesn't matter much I guess. I just enjoy to create stuff that interacts via requests / responses.
08:51:57 <Baughn> voidzero: The 'right' approach is to use a config file parser that understands these things. One might exist.
08:52:13 <JordiGH> So...
08:52:15 <JordiGH> https://ro-che.info/ccc/
08:52:17 <JordiGH> This is a Haskell comic.
08:52:22 <JordiGH> About security and robustness.
08:52:23 <Baughn> voidzero: Then just use a giant glob of 'and' clauses to an if statement
08:52:31 <JordiGH> If you click the "next" button, you get a Haskell exception.
08:52:33 <JordiGH> lol?
08:52:36 <voidzero> Baughn, oh, Toml's fine. It's much like an ini file..
08:53:13 <voidzero> JordiGH, I saw that too. :)
08:53:19 <ChristianS> voidzero: toml is a nice format, i agree. but last time i checked there wasn't a proper haskell parser?
08:53:29 <JordiGH> voidzero: Maybe it's intentional.
08:53:29 <voidzero> JordiGH, I think it means you got to the last comic.
08:53:46 <voidzero> ChristianS, I think there is - https://github.com/cies/htoml
08:53:51 <voidzero> or is that not what you mean
08:53:53 <glguy> Speaking of yet another configuration file syntax: https://github.com/glguy/config-value
08:54:04 * hackagebot filtrable 0.1.0.1 - Class of filtrable containers  http://hackage.haskell.org/package/filtrable-0.1.0.1 (MatthewFarkasDyck)
08:54:13 <Baughn> voidzero: Or, in general, I'd want to abstract it. Don't write out code for each config entry; write a description of what you want, and code to iterate over it.
08:55:17 <ChristianS> voidzero: ah, that one doesn't look bad, indeed
08:57:37 <JordiGH> So, Haskell exceptions are pretty weird. What are we gaining by having bugs that can crash our program with an obscure error message instead of just bugs that segfault?
08:57:52 <Baughn> JordiGH: The error message.
08:57:53 <voidzero> Baughn, cool, that's what I got working yesterday in fact. After reading the config file I get a value of (Text, Maybe Node), and I wrote a function which takes that and returns (String , Either (Maybe String) String)
08:57:59 <Baughn> JordiGH: And stack traces. Those are nice.
08:58:06 <indiagreen> and we can catch exceptions, too
08:58:07 <merijn> JordiGH: Nothing, I'm working on a prototype for checked exceptions in a haskell-like language
08:58:27 <glguy> JordiGH: Bugs that result in memory access violations are often exploitable beyond simply ending execution
08:58:29 <JordiGH> Baughn: The user doesn't care if it says "segmentation fault" or "Haskeller gobbledygook". It's not like you can't get a stack trace from a segfault either.
08:58:32 <Adeon> you can also use exceptions for non-errors
08:58:40 <voidzero> it's a pair with a key, and either an error with maybe a reason, or a result.
08:58:41 <merijn> Although I'm not sure if that will ever go into GHC, because it's pretty incompatible with the Haskell2010
08:58:46 <Baughn> JordiGH: As it turns out, having features that help with development helps with development.
08:58:53 <merijn> JordiGH: The safety is: You aren't guaranteed to get a segfault
08:59:05 <merijn> JordiGH: If memory errors were guaranteed to segfault there'd be no problem
08:59:13 <merijn> Segfaults are a BEST case scenario
08:59:27 <JordiGH> glguy: Most of the segfaults I see are about dereferncing null pointers. Of course there are buffer overflows too.
08:59:36 <merijn> The bigger problem is memory errors silently corrupting your memory and leading to impossible to trace errors later
08:59:46 <merijn> Which isn't possible in haskell
09:00:26 <merijn> But yes, the presence of unchecked exceptions and lack of checked exceptions is a big ward, IMO
09:02:48 <JordiGH> merijn: Are you propsing to have checked exceptions via exception specifiers like Java?
09:03:03 <merijn> Yes, but inferred, so you don't have to write them
09:03:19 <JordiGH> But you could write them, right?
09:03:40 <merijn> Yes. My idea is to have a separate inferrable signature tracking exceptions (which means you can keep them out of the functional type)
09:04:54 <merijn> So you'd have "(/) :: Double -> Double -> Double" and "(/) :: S -> U -> (S u U u DivZero)", i.e. the result of / can throw any exception thrown by the first argument, and any from the second argument, AND division by zero
09:05:16 <JordiGH> Haha, are you using "u" for unions?
09:05:26 <merijn> I can't unicode
09:05:43 <JordiGH> Isn't S and U always implicit?
09:05:55 <merijn> Yes
09:05:57 <voidzero> heh, so far I've been trying to work without OverloadedStrings, just to make ghc complain, which makes me pay attention to the types. Is OverloadedStrings mostly for convenience, and when should I definitely *not* use that pragma?
09:06:17 <merijn> voidzero: Mostly convenience, anything you can do with it you can do explicitly
09:06:40 <merijn> voidzero: i.e. 'Data.Text.pack "foo"' instead of writing "foo" with OverloadedStrings enabled
09:07:19 <safinaskar> ||| {-# LANGUAGE DeriveGeneric #-}
09:07:27 <safinaskar> ||| data R = R { a :: Maybe Int, b :: Maybe Int } deriving (GHC.Generics.Generic)
09:07:34 <safinaskar> ||| instance Control.DeepSeq.NFData R
09:07:41 <safinaskar> ||| main = Control.Exception.evaluate $ Control.DeepSeq.rnf $ R { a = Just undefined, b = Just 2 }
09:08:02 <safinaskar> hi. i have this code. and it prints nothing. i expected this code to print error
09:08:15 <safinaskar> i think this is a bug, am i right?
09:08:40 <voidzero> merijn, ok, good to know, I'll just start using it to cut down on my T.pack/unpack usage ;)
09:08:43 <safinaskar> Baughn: this question is to you, too
09:08:51 <geekosaur> @paste next time, please
09:08:52 <lambdabot> Haskell pastebin: http://lpaste.net/
09:09:02 <safinaskar> my system is debian jessie 8 gnu/linux
09:09:04 <merijn> voidzero: Basically we have "class IsString a where fromString :: String -> a"
09:09:20 <safinaskar> ghc 7.6.3
09:09:22 <merijn> voidzero: OverloadedStrings turns any string literal in an implicit "fromString "literal""
09:09:48 <merijn> voidzero: However, if the IsString instance is partial and/or evil, like for example ByteString, this may bite you in the ass
09:10:38 <merijn> Which is why said ByteString instance is in ByteString.Char8 and not normally visible. And why using Char8 makes baby jesus murder kittens (https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad)
09:12:55 <voidzero> can't have murdered kittens.. I'll go give that a read. 
09:13:11 <geekosaur> safinaskar, I think you need to rnf the evaluate, not just inside the evaluate. main throws away its parameter and evaluate only goes to whnf (which for a function basically means it determines that a call to rnf will happen)
09:13:28 <geekosaur> er, main throws away the thing you return
09:13:48 <geekosaur> actually no, since rnf doesn't evaluate through a function
09:13:57 <geekosaur> rnf is really only meaningful for data
09:14:22 <geekosaur> -- |This instance is for convenience and consistency with 'seq'.
09:14:22 <geekosaur> This assumes that WHNF is equivalent to NF for functions.
09:14:23 <geekosaur> instance NFData (a -> b)
09:14:36 <geekosaur> whoops, intended to compress that second line onto the first...
09:17:55 <cchalmers> safinaskar: it looks like a bug in the derived instance, if you write it yourself it gets the undefined
09:18:01 <safinaskar> Baughn: i already understand that "rnf" is not haskell way. now i just write some proof-of-concept program (i. e. my proof assistant), some day i maybe will rewrite it clean (probably using "Either")
09:19:06 * hackagebot generics-sop 0.1.1.2 - Generic Programming using True Sums of Products  http://hackage.haskell.org/package/generics-sop-0.1.1.2 (AndresLoeh)
09:19:16 <kaiyin> where does ghci store history?
09:19:51 <safinaskar> Baughn: you said #4 method of dealing with errors is different from 1? so, this means exception is not the same as "error"? so what is exception then? how to throw/raise exception?
09:20:27 <geekosaur> kaiyin, on unixlikes ~/.ghc/ghci_history
09:21:21 <merijn> :t throwIO
09:21:23 <lambdabot> Exception e => e -> IO a
09:21:43 <mauke^> :t catch
09:21:44 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
09:22:12 <EvanR> :t try
09:22:13 <lambdabot> Exception e => IO a -> IO (Either e a)
09:23:47 <kaiyin> geekosaur: cool
09:24:00 <voidzero> :t handle
09:24:01 <lambdabot> Exception e => (e -> IO a) -> IO a -> IO a
09:24:15 <mauke^> :t catchIOError
09:24:16 <lambdabot>     Not in scope: ‘catchIOError’
09:24:16 <lambdabot>     Perhaps you meant ‘catchError’ (imported from Control.Monad.Error)
09:24:42 <voidzero> :t handle (const (return []))
09:24:44 <lambdabot>     No instance for (Exception e0) arising from a use of ‘handle’
09:24:44 <lambdabot>     The type variable ‘e0’ is ambiguous
09:24:44 <lambdabot>     Note: there are several potential instances:
09:24:46 <EvanR> unsafeCatchMissles
09:25:25 <voidzero> :)
09:27:16 <voidzero> in the book, the type for (handle (const (return []))) is IO [a] -> IO [a]
09:27:27 <voidzero> http://book.realworldhaskell.org/read/efficient-file-processing-regular-expressions-and-file-name-matching.html
09:27:56 <safinaskar> geekosaur: DeepSeq docs shows "evaluate $ force $ someFunction" as right way to fully evaluate something. and even this doesn't work. so, I think this is a bug
09:28:07 <EvanR> if you had something like IO [a] -> IO [a] then you cant use it until picking what a is
09:28:08 <cchalmers> safinaskar: but it looks like it's fixed in the latest version of deepseq
09:28:23 <kaiyin> I am trying to follow some hmatrix examples and got this: https://gist.github.com/kindlychung/4904cbccfada6341c683
09:29:01 <geekosaur> safinaskar, it can be, but that assumes something actually uses the result of evaluate...
09:29:08 <mauke^> voidzero: that's the old handle
09:30:20 <ChristianS> what's a good/popular library for regular expressions in haskell?
09:30:32 <mauke^> voidzero: available in flipped form as http://hackage.haskell.org/package/base-4.8.0.0/docs/System-IO-Error.html#v:catchIOError
09:30:41 <EvanR> ChristianS: using parsec instead
09:31:04 <safinaskar> cchalmers: yes, when i write instance myself, all is ok
09:31:20 <mauris> is there a type for "total" maps? (or total functions A -> B where A is finite, i guess?)
09:31:46 <merijn> mauris: You could use an Ix instance for keys and use Array?
09:31:57 <ChristianS> EvanR: hmm, i want to do some regex-based search and replace in texts. i think sticking with regexes would be the easiest approach.
09:31:58 <merijn> mauris: Other than that, not really afaik
09:32:20 <cchalmers> safinaskar: if you use the old version of deepseq it has a default implementation of rnf a = a `seq` () which is wrong for your case
09:32:31 <cchalmers> you need deepseq >=1.4
09:32:56 <kadoban> mauris: That's just :: A -> B    . I don't think haskell's type system can encode total/partial, except via like Maybe obviously.
09:34:04 <voidzero> mauke^, noted, thanks, this will come in useful
09:34:08 <EvanR> mauris: the idea is that all functions are total
09:34:09 <safinaskar> geekosaur: docs show example: main = do { ...; evaluate $ force $ ...; ... }. so just "evaluate $ force $ ..." without using result (in IO monad!) is ok
09:34:17 <EvanR> whether or not A is finite
09:34:30 <EvanR> i meant to say, the ideal
09:34:47 <safinaskar> mauris: about total maps: maybe Data.Map.Map?
09:35:10 <EvanR> safinaskar: lookup returns a Maybe
09:35:31 <merijn> Yes, but it also has ! which doesn't return maybe
09:35:55 <merijn> > fromList [(1,'a')] ! 1
09:35:56 <lambdabot>  Not in scope: ‘fromList’
09:35:56 <lambdabot>  Perhaps you meant one of these:
09:35:56 <lambdabot>    ‘IM.fromList’ (imported from Data.IntMap),
09:35:58 <merijn> eh
09:36:06 <mauris> i guess you could "fool" whatever type i could come up with for my situation by putting a bottom value in
09:36:08 <merijn> > M.fromList [(1,'a')] M.! 1
09:36:09 <EvanR> for finite key set an Array might make the most sense
09:36:09 <lambdabot>  'a'
09:36:41 <merijn> If you update Map might be more efficient than Array
09:37:16 <davean> buf16
09:37:17 <EvanR> if you think of it as just functions, then you can "update" it by wrapping in another function ;)
09:37:22 <EvanR> with a patch
09:37:23 <mauris> i'm implementing deterministic finite automata, if it helps
09:37:45 <mauris> and i'm thinking about how to encode the transition function δ : Q × Σ → Q
09:38:05 <merijn> mauris: If you're SURE it's total, there's nothing wrong with Map and !
09:38:16 <EvanR> just use a Map
09:38:23 <mauris> i guess my main options are   (State, Symbol) -> State   and Map (State, Symbol) State
09:38:30 <mauris> and i'm never really sure when to use which!
09:38:42 <EvanR> you cant display or manipulate the function version
09:38:46 <EvanR> very easily
09:39:10 <hodapp> "clkStream, clk1Stream :: Stream Bool"
09:39:15 <hodapp> that's valid syntax?
09:39:17 <hodapp> WHAT
09:39:25 <EvanR> yes
09:39:32 <hodapp> first time I have seen that.
09:39:32 <jerbome_> W00t ! I've just made my first http request in haskell
09:40:16 <mauke^> hodapp: also works in records
09:40:33 <hodapp> mauke^: NOW you tell me!
09:40:57 <mauke^> I thought everyone knew!
09:41:05 <voidzero> even I saw it before
09:41:20 <voidzero> I had the same reaction the first time I saw it though :P
09:41:23 <hodapp> what other secrets in Haskell don't I know about?!
09:42:07 <mauke^> you can import many modules into the same alias
09:42:27 <mauke^> import qualified Data.List as Foo; import qualified System.IO as Foo
09:42:29 <hyuke> I'm new to Haskell and am trying to write a function that takes the difference of a list. For example, [2, 5, 7] would turn into [3, 2] (e.g., x[n] - x[n-1] in imperative languages). I wrote a function with guards that looks very ugly and I know there must be some more elegant way to do it in one or two lines
09:42:46 <mauke^> Foo.print (Foo.length "")
09:42:47 <kaiyin> could anyone help with this?
09:42:49 <kaiyin> http://stackoverflow.com/questions/29305816/hmatrix-eigenvalues-differ-from-r
09:43:19 <mauris> hyuke: try to use "zip" to get [(5, 2), (7, 5)]
09:43:35 <mauke^> > (zipWith (-) <*> tail) [2, 5, 7]
09:43:37 <lambdabot>  [-3,-2]
09:43:41 <mauke^> > (zipWith subtract <*> tail) [2, 5, 7]
09:43:42 <lambdabot>  [3,2]
09:44:09 <hyuke> wow, thanks mauke^. That's beautiful :)
09:44:25 <mauke^> divine powers
09:44:34 <mauke^> @quote zip`
09:44:34 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
09:44:49 <mauke^> `ap` replaced by <*> because it's shorter
09:45:55 <safinaskar> i have debian. how to upgrade my version of "deepseq" package? i installed debian "cabal-install" package, then typed "cabal update" and "cabal install deepseq". is all done? or i now have two deepseqs on my system and all is bad now?
09:46:30 <mauris> it's seriously annoying how google indexes very old hackage docs all the time :/
09:46:41 <voidzero> yeah
09:46:43 <hyuke> mauke^: what is the <*> operator? 
09:47:00 <mauris> googling "haskell data map" gets you the containers-0.4.0.0 docs
09:47:02 <EvanR> applicative function application ;)
09:47:14 <mauke^> hyuke: in this case, the S combinator
09:47:16 <mauris> hyuke: here:  (f <*> g) x  =  f x (g x)
09:47:21 <mauke^> \f g x -> f x (g x)
09:47:52 <Rotaerk> hmm I need to analyze that... don't really intuitively grasp <*> tail
09:47:58 <mauris> i sorta mentally read it "(f) itself with its (g)"
09:48:07 <Rotaerk> go (f) yourself
09:48:26 <mauris> > ((+) <*> (*2)) 10
09:48:27 <Rotaerk> or (g), whichever
09:48:27 <lambdabot>  30
09:48:40 <mauris> ^ "add itself to its double"
09:49:03 <Rotaerk> hmm
09:49:17 <mauke^> add n to (x)
09:49:40 <voidzero> fmap <*> fmap <*> fmap <*> firstmap <$> somelist
09:49:52 <Rotaerk> makes sense, thanks
09:50:50 <mauke^> '\f g x -> f (g x) x' is another operator
09:51:05 <mauke^> (=<<)
09:51:25 <mauris> huh
09:51:30 <mauke^> '\f g h x -> f (g x) (h x)' is liftA2
09:51:50 <mauris> > (zipWith (-) =<< tail) [0,1,3,6,10,15]
09:51:52 <lambdabot>  [1,2,3,4,5]
09:52:00 <mauke^> '\f g x y -> f (g x) (g y)' is on
09:52:42 * EvanR gets the bird combinators guide out
09:53:10 <Rotaerk> lol
09:54:08 * hackagebot fay 0.23.1.2 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.23.1.2 (AdamBergmark)
09:54:29 <mauke^> > (f2 =<< g1) x
09:54:31 <lambdabot>  f2 (g1 x) x
09:54:45 <mauke^> > liftA2 f2 g1 h1 x
09:54:46 <lambdabot>  f2 (g1 x) (h1 x)
09:54:47 <scott> mauke^: huh, so the only difference between (<*>) and (=<<) for ((->) r) is which argument gets the 'g' applied to it?
09:54:54 <mauris> hm. i forget how the whole situation with constraints on data types works
09:54:54 <mauke^> scott: yes
09:55:09 <merijn> mauris: It doesn't and was removed for that reason
09:55:10 <mauke^> > on f2 g1 x y
09:55:11 <lambdabot>  f2 (g1 x) (g1 y)
09:55:41 <EvanR> > f <$> g
09:55:42 <lambdabot>  Could not deduce (Debug.SimpleReflect.Expr.FromExpr (f a0))
09:55:42 <lambdabot>    arising from the ambiguity check for ‘e_1’
09:55:42 <lambdabot>  from the context (Debug.SimpleReflect.Expr.FromExpr (f a),
09:55:46 <voidzero> what's "on" ?
09:55:52 <merijn> voidzero: Just a function
09:55:53 <merijn> :t on
09:55:54 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
09:56:00 <merijn> voidzero: Type should be pretty self-explanatoy
09:56:20 <voidzero> not yet, maybe someday :P
09:56:29 <mauke^> > ((++) `on` show) 2 3
09:56:31 <lambdabot>  "23"
09:56:46 <merijn> voidzero: Given a function "b -> b -> c" and a function "a -> b" return a function "a -> a -> c"
09:56:57 <scott> it's useful in tandem with things like 'compare'
09:57:02 <scott> :t compare `on` fst
09:57:02 <mauris> merijn: so i put the constraints on functions that require them instead, right?
09:57:03 <lambdabot> Ord b => (b, b1) -> (b, b1) -> Ordering
09:57:13 <mauris> the same way Data.Map's functions have "Ord k" everywhere?
09:57:16 <merijn> voidzero: basically, apply the second argument to both inputs before calling first function
09:57:19 <merijn> mauris: Yes
09:57:27 <mauke^> :t compare `on` length
09:57:28 <lambdabot> [a] -> [a] -> Ordering
09:57:36 <merijn> mauris: Even if you put a constraint on the datatype you would STILL have to put the constraint on every function
09:57:55 <merijn> mauris: Putting a constraint on the data doesn't let you skip the constraint on functions
09:58:10 <merijn> mauris: Which is one reason why Haskell2010 removed them
09:58:22 <mauris> that makes sense, thanks!
09:59:05 <jtanguy> i'd add that (compare `on`) == (comparing)
09:59:09 * hackagebot fay-builder 0.2.0.4 - Compile Fay code on cabal install, and ad-hoc recompile during development  http://hackage.haskell.org/package/fay-builder-0.2.0.4 (AdamBergmark)
09:59:15 <EvanR> @pl \f g h x -> f (h x) (g x)
09:59:15 <lambdabot> flip . liftM2
09:59:19 <voidzero> merijn, ah yes, I see it now
09:59:33 <EvanR> @pl \f g h x -> f (g x) (h x)
09:59:33 <lambdabot> liftM2
10:00:01 <EvanR> liftA2++
10:00:34 <S11001001> @remember companion_cube [d3] would need d3pendant types
10:00:34 <lambdabot> Good to know.
10:02:33 <EvanR> @pl \f g h x y -> f (g x) (h y)
10:02:33 <lambdabot> ((flip . ((.) .)) .) . (.)
10:02:40 <EvanR> yus
10:02:55 <EvanR> cosmic dust
10:08:47 <sellers> haskellers who vim, any suggestions for syntax highlighting / indentation scripts?  The default vim ones seem underwhelming to me
10:09:09 * hackagebot config-value 0.1 - Simple, layout-based value language similar to YAML or JSON  http://hackage.haskell.org/package/config-value-0.1 (EricMertens)
10:09:40 <mauke^> I use the default
10:15:22 <voidzero> I am currently playing with this one
10:15:24 <voidzero> https://github.com/begriffs/haskell-vim-now.git
10:16:00 <voidzero> but I had to disable vim-haskellConcealPlus, unfortunately my font Terminus does not seem to play well with it.
10:16:24 <voidzero> And I'm still a bit meh about the tab completion.
10:16:27 <safinaskar> how to make Map instanse of NFData (or Generic)?
10:17:08 <EvanR> (NFData k, NFData a) => NFData (Map k a)
10:17:09 <voidzero> (eh.. the indentation, I mean.)
10:17:18 <EvanR> safinaskar: it already is, it seems
10:17:48 <safinaskar> EvanR: i tried this code, it gives errors
10:17:49 <sellers> voidzero: that looks interesting.  I'll check it out.  Thanks!
10:18:12 <EvanR> what code ?
10:18:33 <safinaskar> EvanR: (NFData k, NFData a) => NFData (Map k a)
10:18:41 <voidzero> sellers, sure thing. Be sure to backup your vim stuff, or try it on a new account first
10:18:42 <EvanR> you dont need to write that code
10:19:03 <EvanR> i found that in NFData's haddock
10:19:10 * hackagebot rest-gen 0.17.0.2 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.17.0.2 (AdamBergmark)
10:19:43 <safinaskar> EvanR: when i write "data X = Data.Map.Map ... ... (deriving NFData)", this code gives me errors and says that Map is not NFData
10:20:00 <safinaskar> (i just upgraded to deepseq 1.4)
10:20:10 <EvanR> that data declaration looks wrong
10:20:39 <EvanR> do you want a type synonym of Map, or a new type that wraps a Map ?
10:20:48 <safinaskar> EvanR: i mean actual types instead of "..." of course. and some constructor name before Map of course
10:21:15 <EvanR> data X = X (Map A B) ?
10:21:27 <safinaskar> EvanR: yes
10:21:33 <EvanR> ensure that A and B are NFData too
10:21:37 <mauke^> what are A and B?
10:22:55 <safinaskar> EvanR: mauke^: actual definition is: data ExprCtx = ExprCtx { ectxSimpleTypes :: Data.Set.Set String, ectxConsts :: Data.Map.Map String Type, ectxTypeVars :: Data.Set.Set String, ectxVars :: Data.Map.Map String RawType } deriving (GHC.Generics.Generic)
10:23:15 <EvanR> whats RawType
10:23:19 <safinaskar> and all mentioned types already are Generic and NFData, except for Set and Map theyself, i think
10:23:21 <EvanR> and Type
10:23:26 <safinaskar> EvanR: it is another my datatypes
10:23:36 <safinaskar> EvanR: and they are Generic and NFData
10:23:45 <safinaskar> *themself
10:24:10 * hackagebot cartel 0.14.2.6 - Specify Cabal files in Haskell  http://hackage.haskell.org/package/cartel-0.14.2.6 (OmariNorman)
10:24:14 <EvanR> themself isnt a word ;)
10:24:50 <voidzero> its a singulaplural.
10:25:00 <EvanR> safinaskar: lpaste the code
10:25:08 <voidzero> or no, a pluralusingler. 
10:25:31 <safinaskar> *themselves
10:25:40 * voidzero winks.
10:25:43 <quchen> You can fold over the Map using (deep)seq to force all values to NF.
10:25:54 <quchen> foldMap (`deepseq` ()) -- like that.
10:26:15 <quchen> Well, you'll have to force the result of this, and then you'll have all map values in NF.
10:26:27 <EvanR> theys are trying to derive NFData
10:29:15 <quchen> Map is already NFData.
10:29:34 <safinaskar> EvanR: simplified code: http://paste.debian.net/163547/
10:29:40 <EvanR> for the type data X = X (Map A B)
10:30:24 <EvanR> simplified code :(
10:30:39 <safinaskar> EvanR: :)
10:30:41 <mauke^> *reduced test case
10:30:49 <safinaskar> yeah :)
10:32:24 <EvanR> unknown
10:32:52 <bennofs> when haddock reports coverage /= 100%, how do I find out what is missing?
10:33:52 <safinaskar> so, why the code doesn't compile?
10:34:38 <EvanR> it does compile
10:35:10 <safinaskar> EvanR: so, you can compile it? what is your compiler version? and deepseq?
10:35:20 <EvanR> 7.8.3
10:36:17 <EvanR> bennofs: tricky things i found out it wants via trial and error, a blurb at the very top of the module
10:36:20 <kaiyin> Is there an straight-forward way to translate this R code into haskell? https://gist.github.com/kindlychung/91931f3cf397dc9d271e
10:36:43 <int-e> safinaskar: ghc-7.6.3 is a bit dated, and containers only added an NFData instance for map in version 0.5 .
10:36:51 <int-e> s/map/Map/
10:37:06 <bennofs> EvanR: that was it, thanks
10:37:31 <bennofs> Also, how do I esacpe {-# LANG ... #-} in haddock code blocks?
10:39:10 <Hijiri> should I install new ghc
10:39:54 <int-e> safinaskar: err, actually, 0.5.0.0, which is what you have. So this is a case where the 0.5.0.0 on hackage differs from that bundled with ghc-7.6.3. Wonderful.
10:39:56 <Hijiri> or should I wait until packages raise their bound on base
10:42:51 <int-e> safinaskar: Sorry, I'm confusing myself here. The packages are actually identical, as they should be.
10:43:50 <safinaskar> well, this is debian jessie. i. e. not-released-version yet. and it is already outdated. this is very bad :(
10:43:53 <safinaskar> facepalm
10:44:37 <exio4> safinaskar: my "workaround" around this was to update the container for ghc to debian sid, and install 7.8 from experimental 
10:45:16 <spindas> safinaskar, it's out-of-date because they freeze package versions as they tighten things up for the next release
10:45:27 <int-e> safinaskar: the real problem is that you have two versions of deepseq installed. the container package provides an NFData instance for the 1.3 version of deepseq, which doesn't work for the 1.4.1.1 version.
10:46:32 <ReinH> safinaskar: This is standard operating procedure for debian
10:46:55 <ReinH> And most distro package managers
10:47:27 <jerbome_> should I be afraid of cabal: The following packages are likely to be broken by the reinstalls ?
10:48:09 <jerbome_> I'm trying to install http-client, and the  packages likely to be broken are HTTP & hsdev 
10:48:25 <ReinH> jerbome_: You should probably use a sandbox.
10:48:26 <clrnd> jerbome_, use sandboxes
10:48:37 <Hijiri> I use debian and I just install the binary package from ghc site
10:48:41 <clrnd> or halcyon, that looks promising
10:49:06 <jerbome_> ReinH, clrnd , so that means I cannot use http client from ghci for example ?
10:49:20 <spindas> jerbome_, you can use "cabal repl" inside a sandbox
10:49:29 <Hijiri> the the "distro agnostic"one
10:49:32 <spindas> which fires up GHCi inside the cabal environment
10:49:47 <jerbome_> spindas, thanks
10:50:20 <clrnd> Hijiri, there is a ppa that has the almost-latest GHC
10:50:36 <Hijiri> aren't ppas designed for use with ubuntu?
10:50:53 <Hijiri> I've used a couple before, but I have a good way to not do it in this case
10:51:08 <clrnd> Hijiri, oh
10:51:44 <spindas> Well, a lot of ppas work with debian as well, if dependency versions line up
10:51:58 <Hijiri> I can avoid it for ghc
10:52:00 <clrnd> Hijiri, well you asked if you "should" use a new ghc, which is totally up to you
10:52:10 <spindas> you need to edit the sources.list.d file and change the distro name to match a Ubuntu version 
10:52:19 <spindas> as it automatically fills in the debian version
10:56:29 <safinaskar> int-e: how to remove one of this deepseqs?
10:57:41 <safinaskar> int-e: and now to upgrade to deepseq 1.4 the right way without keeping 2 packages?
10:59:46 <aupiff> hi all, question about Data.Vector.Mutable -- when using an STVector, is every array element layed out in contiguous memory?
11:00:09 <c_wraith> aupiff: uh.  sort of.
11:00:25 <c_wraith> aupiff: it's more or less a contiguous array of STRefs
11:00:54 <c_wraith> aupiff: but there's indirection to the values, which is required by laziness
11:01:09 <c_wraith> aupiff: if you use an Unboxed STVector, though, that's no longer true
11:01:40 <c_wraith> aupiff: the Unboxed variants remove laziness in the values, and actually stuff them directly into contiguous memory
11:02:07 <c_wraith> aupiff: you'll notice the Unboxed variants have restrictions on what types they allow, because the types need to be unboxable.
11:02:19 <aupiff> c_wraith: I see, thanks! Is there an array-like datastructure implemented using hash tables?
11:02:47 <c_wraith> aupiff: There's some HAMT stuff in unordered-containers
11:03:20 <int-e> safinaskar: You cannot use the 'containers' that came with ghc together with deepseq-1.4; if you need the latter, you'll have to upgrade the former as well. I'm not sure where this chain of upgrading packages will stop.
11:03:55 <c_wraith> aupiff: HAMTs (Hash-Array mapped Trie) is an efficient data structure that was origininally developed in clojure for their persistent hash structures.  Turns out to work well in haskell, too.
11:04:24 <aupiff> c_wraith: oh cool, thanks. yes, I'm mainly asking because I was looking at those data structures in scala and clojure recently.
11:07:16 <EvanR> aupiff: well they are called vector, but thats the only similarity
11:09:04 <EvanR> so you were looking up "these" datastructures
11:09:06 <EvanR> were nt
11:09:13 * hackagebot xmonad-contrib 0.11.4 - Third party extensions for xmonad  http://hackage.haskell.org/package/xmonad-contrib-0.11.4 (AdamVogt)
11:09:15 * hackagebot xmonad 0.11.1 - A tiling window manager  http://hackage.haskell.org/package/xmonad-0.11.1 (AdamVogt)
11:14:13 * hackagebot multiarg 0.30.0.8 - Command lines for options that take multiple arguments  http://hackage.haskell.org/package/multiarg-0.30.0.8 (OmariNorman)
11:14:59 <halosghost> good (ugt) morning!
11:15:09 <besenwesen> greeting
11:15:11 <besenwesen> +s
11:15:19 <EvanR> sworvu
11:15:30 <halosghost> besenwesen: o/
11:16:11 <halosghost> so, I tried looking at the trac earlier and I didn't find any obvious answers (and it was so slow that I wasn't willing to look more closely)
11:16:29 <platz> is an HMAT a finger tree, or are those different things?
11:17:02 <halosghost> has there been any discussion around ghc supporting arbitrary-radix integer literals or arbitrary-precision floating point arithmetic through openfp (à la Int/Integer with gmp)?
11:20:11 <schell> is there any way to determine the dimensionality of a (from linear) V0 V1 V2 V3 V4?
11:20:24 <schell> like numDimensions :: f a -> Int?
11:21:28 <enthropy> halosghost: there's http://hackage.haskell.org/package/numbers-3000.2.0.1/docs/Data-Number-CReal.html if you don't care at all about speed
11:21:48 <EvanR> schell: what would you use that to do ;)
11:22:12 <joseph07> Quick question: I wanted to enumerate the cases where using a typeclass is preferable to using a Data declaration containing the necessary functions (explicit dictionary passing). So far I have 1. To maintain an invariant (like the Ord constraint for Set) 2. To interface with a library and 3. Some vague thought about reducing excessive boilerplate. What else?
11:22:32 <schell> i have a GADT that takes a list of [f a] and i need to separate the pieces 
11:23:04 <halosghost> enthropy: does that link to openfp?
11:23:04 <EvanR> schell: [f a] ? not every type has anything to do with Vs or linear
11:23:16 <enthropy> no I don't know what openfp is
11:23:19 <halosghost> enthropy: if it does, I didn't see any suggestion of that on hackage
11:23:21 <halosghost> enthropy: oh
11:23:36 <halosghost> enthropy: openfp is an arbitrary-precisoin library layered on top of gmp for floating-point arithmetic
11:23:49 <schell> EvanR yes that’s true - this f a is constrained by (R1 f, R2 f, RealFrac a)
11:23:57 <EvanR> halosghost: you can make bindings to it and expose a normal Floating instance for the type
11:24:07 <EvanR> no changes to ghc necessary
11:24:10 <schell> i thought i would pattern match but that gives me the old “Couldn't match type ‘f’ with ‘V2’ ‘f’ is a rigid type variable”
11:24:14 <halosghost> EvanR: sure, I can make a pcakge
11:24:18 <EvanR> schell: still no
11:24:20 <enthropy> schell: can you use length = getSum . foldMap (const (Sum 1))
11:24:21 <halosghost> s/pcakge/package/
11:24:21 <benaiah> apologies for a really basic question, but I'm trying to compile the first code block on this page: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/First_Steps, and it's giving me "Parse error: naked expression at top level" at the "main :: IO ()" line. Everything I can find seems to say that the syntax here is valid, though.
11:24:29 <halosghost> but I meant, including it in the prelude much like Integer is
11:24:45 <enthropy> halosghost, EvanR I think you'll have problems with linking in two gmps (which hmpfr seems to have)
11:24:46 <schell> enthropy: i’ll try :)
11:24:56 <EvanR> enthropy: that might technically work, but will not recover type safety after they are separated
11:25:40 <EvanR> schell: a typical issue you have is trying to put different types in the same list, then later you want to separate them but theres no easy way to do it. the typical solution is to not put them in the same list
11:25:57 <schell> enthropy: that does work :)
11:26:14 <schell> EvanR: yes, i’m seeing that now
11:26:21 <roboguy_> benaiah: do you have spaces before the lines?
11:26:30 <EvanR> schell: for example you can have 4 lists, one for each dimension
11:27:07 <benaiah> roboguy_: before the last two lines after the "main = do" line, but not before the one with the error
11:27:07 <schell> EvanR: yes, i’m going to have to have many more types
11:27:23 <EvanR> heh... good luck ;)
11:27:23 <quchen> benaiah: Paste your code please.
11:27:27 <quchen> ?where paste
11:27:27 <lambdabot> Haskell pastebin: http://lpaste.net/
11:28:02 <EvanR> schell: a common request is a way to make a container of "any type", and its an important lesson that this doesnt really make sense
11:28:08 <lpaste> benaiah pasted “Naked expression parse error” at http://lpaste.net/129760
11:28:33 <roboguy_> benaiah: the args needs spaces before it. Also, I'm not sure if the unicode arrow works
11:28:51 <ozataman> is there a way to get ghci to avoid re-compiling modules from scratch when loading a file via ":l"? i.e. during normal operation when you load module A and if A depends on B, but if B has already been compiled previously (with a .so/.o/.dylib/etc. file on disk), load it faster instead of going through all the motions.
11:28:54 <quchen> Avoid non-ASCII characters in source.
11:29:07 <EvanR> schell: if they all satisfy the same interface, then its a case where you can put a record representing the interface in the container instead
11:29:09 <schell> EvanR: right - my naive request would be to make a container of either V2s or V4s, and have each element in that container use the same constructor, which GADTs are not the answer to i see now 
11:29:14 * hackagebot hruby 0.3.0 - Embed a Ruby intepreter in your Haskell program !  http://hackage.haskell.org/package/hruby-0.3.0 (SimonMarechal)
11:29:16 * hackagebot quantfin 0.1.0.0 - Quant finance library in pure Haskell.  http://hackage.haskell.org/package/quantfin-0.1.0.0 (tdees)
11:29:24 <benaiah> roboguy_: oh, that arrow's not actually in source, that's just from pasting out of emacs, sorry
11:29:33 <besenwesen> unicode arrows do work
11:29:37 <schell> i’ll just have to split them out
11:29:45 <EvanR> schell: well you can certainly do that, have another data type which lets you distinguish dynamically, which isnt "any type"
11:30:17 <roboguy_> benaiah: adding a couple spaces before args should fix it. do-blocks should be indented
11:30:18 <EvanR> but sometimes this is not good because of increased runtime checking and sometimes you can get extra margin for bugs
11:30:20 <benaiah> roboguy_: adding spaces before "args" is still giving me the same error. GHC is saying the error is at (4,1)
11:30:45 <EvanR> schell: youll know when at some point youll have no choice but to put error "dynamic check failed!" where a total functions cases would go
11:30:53 <roboguy_> benaiah: I think the unicode :: symbol is tripping it up
11:31:07 <roboguy_> benaiah: I would suggest getting rid of all the unicode
11:31:13 <besenwesen> D:
11:31:29 <schell> EvanR: thanks - i think i’m prematurely…generalizing
11:31:49 <roboguy_> besenwesen: this particular unicode arrow gives a compile error for me. I think it thinks it should be an operator, rather than <-
11:32:05 <schell> EvanR: the second here is what i’ve been working with/towards http://lpaste.net/129751
11:32:23 <besenwesen> roboguy_, in the paste, the indenting seems wrong
11:32:34 <roboguy_> besenwesen: I know, with that fixed that also gives me an error
11:32:39 <besenwesen> the arrow itself is okay
11:32:57 <besenwesen> however, you need to enable unicode syntax. have you done that?
11:33:16 <roboguy_> besenwesen: oh
11:33:23 <besenwesen> otherwise, you can add the pragma {-# LANGUAGE UnicodeSyntax #-}
11:33:33 <roboguy_> right. I've never used unicode with Haskell
11:33:38 <benaiah> besenwesen: I didn't intend to enter unicode - that appears to be a result of the default haskell-mode behavior in emacs. I'm looking into how to turn that off to see if that's the problem
11:33:41 <besenwesen> it works great, you just need the pragma
11:33:46 <besenwesen> ah, i see
11:33:57 <besenwesen> whichever suits you best
11:34:15 * hackagebot git-annex 5.20150327 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20150327 (JoeyHess)
11:35:30 <voidzero> I have a list of three pairs, and data Foo = String String String that should contain the seconds of the three pairs
11:35:49 <voidzero> and I'm drawing blanks atm
11:36:22 <ReinH> voidzero: eh?
11:36:23 <benaiah> besenwesen: yeah, it was a result of the unicode symbols.
11:36:33 <benaiah> besenwesen, roboguy_: thanks
11:36:47 <ReinH> voidzero: so you actually want a data constructor String :: String -> String -> Foo ?
11:36:55 <joseph07> anyone know of a good resource for determining when to use a typeclass vs a value-level function dictionary?
11:37:02 <ReinH> That seems bad.
11:37:20 <voidzero> yeah. I need to reconsider how I want to do this.
11:37:47 <EvanR> joseph07: function dictionary / anything dictionary, since its not just functions in type classes
11:39:15 * hackagebot rainbow 0.22.0.2 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.22.0.2 (OmariNorman)
11:41:32 <joseph07> EvanR: Sorry that terminology might have been off. What I mean is that just about anything you CAN do with a typeclass, you could also do by passing implementations explicitly (instead of relying on the implicit type -> implementation lookup), so what are some rules of thumb for when a typeclass make sense
11:43:04 <safinaskar> i just removed all haskell-related stuff from my computer and installed binary release of haskell platform to /usr/local/haskell
11:43:12 <safinaskar> how to install packages to it?
11:43:23 <roboguy_> safinaskar: cabal install ...
11:43:24 <safinaskar> i tried "cabal install ..." but this command installs to ~
11:43:25 <joseph07> EvanR: For example, Set wouldn't work if you passed in an Ord-like compare function explicitly, because then you could do weird things like union two sets that have different ideas about how to compare elements
11:43:35 <safinaskar> and i want to install globally
11:43:55 <safinaskar> and to enable cabal to update real global packages including cabal itself
11:43:58 <joseph07> EvanR: So that's one case: to maintain invariants
11:44:09 <roboguy_> safinaskar: do you have a cabal sandbox set up in that directory?
11:44:37 <monochrom> safinaskar: see my http://www.vex.net/~trebla/haskell/sicp.xhtml#root . in fact, read the whole thing.
11:44:46 <safinaskar> roboguy_: what this means? and in what directory?
11:45:03 <roboguy_> safinaskar: oh, probably not then. in ~
11:48:42 <newsham> is there a haskell class that represents arbitrary mappings between an enum and some numeric type?  sort of like "Enum", but without the minbound and maxbound, and with a "v -> Maybe i" instead of a "v -> i" ?
11:48:51 <newsham> (and matching i->v)
11:49:34 <cfoch> is it currently possible to do something like
11:49:51 <cfoch> "hoogle Bar.Foo.bazBoo" 
11:49:51 <cfoch> ?
11:49:52 <Denommus> is there another auto-completion package besides ghc-mod?
11:50:04 <cfoch> in the command line to get the documentation of Bar.Foo.bazBoo
11:50:04 <cfoch> ?
11:50:38 <monochrom> newsham: I wonder if you accept Ix
11:51:25 <newsham> "The Ix class is used to map a contiguous subrange of values in a type onto integers."
11:51:28 <newsham> mine aretn contiguous
11:51:43 <monochrom> I see
11:51:46 <newsham> ie:   enum { foo=1, bar=2, baz=99, hungry=103 }
11:51:55 <cfoch> I was reading 
11:51:59 <hunteriam> How would you write a function to recognize the string {wtw | w, t in {a,b}*}
11:52:00 <cfoch> this link
11:52:07 <cfoch> https://github.com/haskell/cabal/issues/395
11:52:08 <hunteriam> this problem is blowing my mind
11:52:08 <newsham> I want (FOO|BAR|BAZ) -> Maybe Word8      for example
11:52:16 <newsham> statically defined of course
11:52:42 <newsham> oops,  (FOO|BAR|BAZ) -> Word8 and   Word8 -> Maybe (FOO|BAR|BAZ)
11:53:06 <hunteriam> Anyone know?
11:53:20 <newsham> i'm guessing i need to roll my own
11:53:45 <monochrom> hunteriam: I would write a helper function "split n s" that splits s into 3 parts: the first n chars, the middle chars, the last n chars.
11:53:45 <shachaf> I don't think there's anything like that as a class.
11:53:46 <enthropy> c2hs abuses Enum for that
11:54:09 <shachaf> That sort of "isomorphism that can fail in one direction" is a prism, by the way. Not that that helps you.
11:54:14 <joseph07> newsham: What do you need besides a function from your type to Int?
11:54:20 <monochrom> actually, forget the middle, I don't care. just get the n first chars and the last n chars.
11:54:22 <hunteriam> Monochrom and then try that with many different numbers up to half the length of the string and check for equivalency?
11:54:27 <monochrom> yes
11:54:46 <newsham> i need to get from integral type to enumerable and back
11:55:21 <joseph07> newsham: Oh so it's a function and its inversion
11:55:26 <hunteriam> Ok. I'm trying to figure out a TUring machine for it for this class I'm taking, and it seems not too fun
11:55:37 <hunteriam> Like I won't know the length either
11:55:43 <monochrom> translate a haskell program to a Turing machine :)
11:55:48 <hunteriam> Unless I have th machine figure that out first
11:55:52 <newsham> joseph: yup, and its partial in one direction
11:56:08 <joseph07> newsham: Gotcha
11:56:27 <newsham> i think i figured out what i want and how to write it.. i just gotta roll my own
11:56:44 <toors> @pl \n -> n == reverse n
11:56:44 <lambdabot> ap (==) reverse
11:56:56 <mgsloan> newsham: This probably isn't helpful, but you could consider just having a 'Word8' and using pattern synonyms.  This Word8 could be wrapped in a newtype.  After doing this, you would still in need of a prism / smart constructor type thing, but hey, might be helpful
11:57:02 <shachaf> Prism' Word8 YourType
11:57:32 <monochrom> oh, I know! the Turing machine just needs to accept.
11:57:42 <newsham> msgloan: i want pretty printing.
11:57:48 <newsham> i'm going with: data IntEnum v i = Value v | Undefined i
11:57:48 <newsham> class IntEnumerable where toIntEnum :: i -> IntEnum v i fromIntEnum :: IntEnum v i -> i
11:58:01 <newsham> I think that should keep me happy
11:58:22 <shachaf> That's an odd approach.
11:58:31 <mgsloan> Could still implement pretty printing atop that, but yeah, it's true you aren't going to get a Show instance for free
11:58:32 <shachaf> Just so you have an actual isomorphism with Int?
11:59:01 <newsham> i'm dealing with protocol definitions.  the enum data type is tied inherently to a representation.
11:59:21 <newsham> so I might have     IntEnum MsgType Word8
11:59:27 <safinaskar> i just installed new deepseq 1.4
11:59:43 <newsham> also i have a weird req that I have to capture "undefined" values
11:59:46 <safinaskar> please say again what package should i upgrade next to get Map working?
12:00:23 <mgsloan> newsham: Nice thing about using pattern synonyms for this is that you don't have to pay any runtime overhead, and get that "| Unrecognized Word8" constructor for free
12:01:02 <newsham> msgloan: can you point me to an example or ref?
12:01:36 <CorkExaminer> does anybody know if it is possible to reset the admin password of a private hackage server?
12:01:43 <mgsloan> newsham: Sure! https://ocharles.org.uk/blog/posts/2014-12-03-pattern-synonyms.html
12:02:07 <newsham> ty
12:02:13 * neuroserpens desugarizes everything because he has diabeetuz
12:02:17 <mgsloan> As mentioned there, ekmett uses it in gl / sdl, which is where I first saw this trick I think
12:02:21 <mgsloan> welcome!
12:02:30 <neuroserpens>  >>= -> >> for the win
12:04:11 <monochrom> desugaring is good for seeing the true nature of things
12:04:33 <neuroserpens> YES!
12:04:43 <newsham> msgloan: but what if you want printable enums?
12:05:00 <neuroserpens> The true taste of stuff without sugarrrr
12:05:12 <newsham> i would have to hand-roll something like "show" for the pattern values
12:05:12 <fengshaun> oooh ghc 7.10.1
12:05:19 <newsham> (or would I?)
12:05:20 <fengshaun> partial type signatures and applicative monads
12:06:54 <roboguy_> fengshaun: burning bridges too
12:07:08 <neuroserpens> o,o
12:07:46 <newsham> msgloan: that approach seems pretty cool for runtime costs, but for my case, i cant afford to spend lots of time handwriting conversion-to-string functions in ad hoc manner
12:07:57 <newsham> and my runtime cost is not that important 
12:08:05 <fengshaun> roboguy_: haven't read about that yet
12:08:23 <fengshaun> oh, that's just more generic functions
12:08:25 <fengshaun> nice
12:09:17 * hackagebot prednote 0.32.0.6 - Evaluate and display trees of predicates  http://hackage.haskell.org/package/prednote-0.32.0.6 (OmariNorman)
12:10:14 <roboguy_> fengshaun: yeah, so now the Prelude automatically exports stuff like mapM from Data.Traversable instead of the specialized mapM it used to use
12:10:33 <roboguy_> burning bridges is the most controversial change in this release, as far as I know
12:11:02 <roboguy_> there was a lot of discussion about whether it should be done or not (and how)
12:12:57 <fengshaun> I need to write something sizeable in haskell
12:13:06 <fengshaun> I can't think of anything, though :<
12:13:32 <fengshaun> also, I've forgotten almost everything I knew, so that makes it difficult
12:14:03 <toors> @pl \n -> n == reverse n
12:14:03 <lambdabot> ap (==) reverse
12:14:18 * hackagebot nonfree 0.1.0.1 - Free structures sans laws  http://hackage.haskell.org/package/nonfree-0.1.0.1 (ShachafBenKiki)
12:15:12 <roboguy_> nonfree huh
12:17:19 <shachaf> Hmm, so now there's no way to get an instance Typeable Typeable?
12:17:33 <safinaskar> int-e: thanks
12:18:25 <c_wraith> Anyone know about the Storable instance for Ptr a?  Is it safe to free (a value of type Ptr (Ptr a)) after using peek to extract the Ptr a?
12:19:04 <joe9> is there a pretty printing library similar to groom that is more mindful of the terminal size?
12:19:27 <c_wraith> I would think it should be, but I get nervous once I get into manually memory management, especially when I'm not 100% sure what's going on under the hood.
12:19:49 <shachaf> You mean because of strictness issues, or why?
12:20:12 <c_wraith> No, I'm just never 100% sure that peek creates something that no longer depends on the underlying memory
12:20:29 <shachaf> Oh, I see, it's because it's polykinded that I get an error.
12:21:14 <monochrom> are you saying you're receiving x :: Ptr (Ptr Int) and you are considering to free x?
12:21:17 <roboguy_> shachaf: for that to work, wouldn't it need to be both polykinded and not polykinded (so it can't work)?
12:21:23 <c_wraith> monochrom: yes
12:21:46 <c_wraith> monochrom: it's an out parameter in the underlying C call
12:21:52 <monochrom> then you can free x, if x was created by allocation
12:22:30 <c_wraith> Or start bundling things together into a decent mid-level wrapper and just use alloca. :)
12:22:55 <monochrom> more precisely, if x was created by the same allocator that gives you "free"
12:23:00 <c_wraith> yes
12:23:08 <c_wraith> Thank you
12:27:37 <Geekingfrog> help, I cannot find how to hoogle *>
12:27:57 <Geekingfrog> I'm getting some parse error when looking for this weird operator :/
12:28:23 <Rotaerk> Geekingfrog, wrap it in ()'s
12:28:26 <mgsloan> newsham: Just got back.  That's fair - if it was me, I'd probably use TH to generate the pattern synonyms and Show instances.  One issue with this approach is that in order to have exhaustiveness, you have to handle the "OtherConstructor" case all over the place.  If you want to have some point in the code where the type is known not to include this case, then you'll need an ADT
12:28:36 <Geekingfrog> Rotaerk, thanks
12:29:35 <newsham> yah, either way I'm going to have to do a lot of boilerplate.  i just tried out a test defn.. :(   i guess i might as well use the patterns.
12:29:42 <newsham> and I'm prob going to want TH
12:30:02 <newsham> TH can be such a pain sometimes
12:31:23 <mgsloan> newsham: It can, indeed..  Unfortunately, I don't see a Dec constructor for pattern synonyms
12:31:29 <toors> how does this work when app's first argument is m(a->b)? ap (==) reverse $ "foo"
12:31:43 <mgsloan> newsham: So, source based code generation?  Yuck!
12:32:03 <mgsloan> (that's what the gl package does, so not so unprecedented, at least)
12:32:14 <roboguy_> toors: m ~ a function type in this case
12:33:02 <roboguy_> toors: specifically, m ~ ((->) String) in this case
12:33:19 <toors> ahh
12:33:34 <roboguy_> toors: this uses the ((->) r) instance of Monad
12:33:42 <rola> aka reader
12:33:52 <toors> thank you that's very helpful
12:36:59 <newsham> what I would really like is a TH macro that let me define the newtype, the patterns and the Show instance all in one go...
12:38:15 <mgsloan> newsham: Yeah, that would be possible if TH supported that Dec...
12:39:14 <frerich> Does anybody here use https://ghcformacosx.github.io/ ? I wonder - can it be used to run multiple GHC versions in parallel?
12:39:35 <mgsloan> I hate it when TH doesn't support Decs.  Looks like at least now ghc 7.10's TH can output standalone deriving instances
12:39:38 <mgsloan> that's a nice improvement
12:40:04 <newsham> msgloan: btw, I threw together two examples, doing it both ways for "R | G | B":  http://www.thenewsh.com/~newsham/haskEnum/
12:40:16 <newsham> your approach seems like lowerer boilerplate too
12:40:37 <mgsloan> Yup! :D
12:41:07 <newsham> can TH even define patterns today?
12:41:18 <mgsloan> No, not even in 7.10
12:41:31 <mgsloan> Should probably be a trac ticket about that
12:42:03 <newsham> well it seems like this is all a hack.. a cleaner method would introduce a more general enum feature in the first place instead of faking it with newtypes and pattern matches
12:42:24 <newsham> i think i can wade through the boilerplate for now
12:42:28 <mgsloan> True.  It's neat that you can get so far without a more general enum feature
12:42:52 <mgsloan> If TH wasn't rough around the edges then you could make a rather nice enum DSL
12:43:01 <newsham> yah
12:44:21 <roboguy_> newsham: you could use... CPP metaprogramming (loud boos/hisses from audience)
12:44:22 <newsham> oh, hrm.. i just thought of another thing i wanted..  its handy to know, dynamically, when you have a value that is defined in the enum and when it is not
12:44:31 <newsham> robo: i could just write a program that spits out haskell
12:45:13 <newsham> good example -- when defining Arbitrary instances for unit testing, its nice to be able to generate the "defined" values more often than the "undefined" values.
12:45:27 <mgsloan> Yup, makes sense!
12:46:08 <newsham> i guess i can still do that with pattern synonyms if i introduce another "isDefined" type class.
12:48:58 <roboguy_> I wonder if you can use Boost CPP libraries with GHC or if they use any non-CPP syntax that would mess that up...
12:49:43 <geekosaur> ???
12:49:57 <geekosaur> for Boost, "CPP" means C++, not the C preprocessore
12:50:02 <mgsloan> http://www.boost.org/doc/libs/1_57_0/libs/preprocessor/doc/index.html
12:50:06 <mgsloan> Not all the time :D
12:50:16 <geekosaur> oh, dear
12:50:19 <roboguy_> geekosaur: it has C preprocessor metaprogramming in it
12:50:27 <roboguy_> so CPP means C preprocessor in this context
12:50:45 <roboguy_> I bet most of it would work
12:50:53 <roboguy_> maybe slightly edited
12:50:53 * geekosaur would be happier withotu especially given that interesting parts of cpp conflict with haskell (see: clang issues)
12:52:59 <geekosaur> don't really want to encourage cpp use, unless you want to ensure that works with hscpp or etc.
12:54:54 <roboguy_> geekosaur: oh, yeah I'm sure it would be a huge pain. Just idle curiosity inspired by the fact that there are still things template haskell can't do (like make pattern synonyms)
12:55:30 <safinaskar> what is point in creating electron magazine https://wiki.haskell.org/wikiupload/d/dd/TMR-Issue8.pdf ? why not just publish this articles somewhere in the internet? why to create this flashy pdf documents, this issues with fixed date and without ability to fix typos?
12:57:24 <safinaskar> you should know. you are #haskell, mentioned in the magazine
12:57:28 <roboguy_> safinaskar: you can't fix typos in a pdf?
12:57:39 <safinaskar> roboguy_: well, it is possible
12:57:54 <geekosaur> it can be painful; pdf is virtually write-only
12:58:05 <geekosaur> easier to fix in the original source and regenerate the pdf
12:58:08 <int-e> safinaskar: Stability is good for citing stuff. (TMR issue 8, page 42)
12:58:25 <safinaskar> roboguy_: i just don't understand why to create magazine. why not just publish articles somewhere? why this "issues" created?
12:58:37 <monochrom> I don't know the answers to your questions. despite I'm in #haskell.
12:58:40 <roboguy_> safinaskar: they are published right there though
12:58:53 <roboguy_> on the internet
12:59:18 <monochrom> I don't know the answers to the following question either. why don't you do it?
12:59:51 * geekosaur suspects that TMR aims to be more on the level of academic journals rather than blog posts. but does not know for certain
12:59:54 <int-e> safinaskar: also printing a PDF has much nicer results than printing a random collection of websites.
13:00:03 <xxx> What's the current best setup for using Haskell in vim?
13:00:22 <xxx> proper indent, autocomplete, esp
13:00:35 <roboguy_> safinaskar: you get to use nice formatting for math and diagrams too that will be uniform across all ways to view it
13:00:38 <monochrom> the power of the free market is that if you don't like other people's way, you can do things your way.
13:00:40 <safinaskar> roboguy_: why not just create some site (or some site section) and publish articles there? but without composing issues
13:00:54 <int-e> safinaskar: go ahead, do it.
13:01:03 <monochrom> instead of demanding other people to do things your way and you don't have to pay them.
13:01:11 <geekosaur> safinaskar, had you considered asking the TMR publisher instead of what amounts to a random IRC channel?
13:01:13 <monochrom> it's their articles. they publish how they please.
13:01:16 <roboguy_> safinaskar: there is a site here https://themonadreader.wordpress.com/
13:02:40 <safinaskar> geekosaur: irc answers immidiately
13:02:58 <safinaskar> okey, i understand. more or less
13:03:00 <roboguy_> not when they don't know the answer, haha
13:03:08 <geekosaur> of course, the cool kids "publish" on twitter and tumblr and think they have only just discovered this new notion of "long form" (cf. longform.org)
13:03:14 <geekosaur> but IRC does not have everyone on it
13:03:34 <monochrom> irc makes up answers immediately, I'll grant you that.
13:03:56 <timothyh> hackage down?
13:04:21 <geekosaur> seems up for me
13:04:30 <timothyh> dang must just be me
13:04:51 <timothyh> oh, working now but very slowly
13:05:15 <geekosaur> btw questions like that might better be directed to #haskell-infrastructure
13:05:32 <geekosaur> or check status.haskell.org (see /topic)
13:06:12 <srid> yo Haskellers - I'm curious if anyone uses .lhs (literate programming) by default for their projects. 
13:06:23 <srid> Not simple scripts, but pretty much most of the Haskell code in their apps
13:06:41 <srid> and if so, would you please point me to your repo.
13:08:43 <kaiyin> Could anyone help with this? http://stackoverflow.com/questions/29309296/f-z-z-n-in-r-and-haskell
13:08:46 <neuroserpens> Can anyone give me a simple example of how a lambda would fit into a list comprehension for a map behavior?
13:08:52 <neuroserpens> lol me first xD
13:09:39 <roboguy_> > map (\n -> n + 5) [2,3,4]
13:09:40 <lambdabot>  [7,8,9]
13:09:54 <neuroserpens> roboguy_: thanks a lot. I wasn't sure about the syntax
13:10:20 <neuroserpens> and kaiyin I think it would be best if you just wrote what you want with the code instead of making people understand code first
13:10:24 <neuroserpens> kaiyin: I could be wrong though
13:11:17 <kaiyin> neuroserpens: ok. 
13:11:26 <neuroserpens> kaiyin: I don't even know R syntax. I could try to help if you said " I need a code that does x, y, z".
13:11:27 <monochrom> it's best to show both code and explanation. since you're likely unclear in either.
13:11:40 <neuroserpens> Yea or what monochrom said.
13:12:10 <kaiyin> neuroserpens: I will edit the question.
13:17:18 * neuroserpens waits for it
13:17:53 <EvanR> uh does this make any sense http://lpaste.net/129762
13:18:19 <neuroserpens> EvanR is a god of haskell so I won't even look at it.
13:18:31 <EvanR> i beg to differ
13:18:37 <monochrom> does it type-check? if so, then it likely makes sense.
13:18:47 <EvanR> yeah 
13:19:14 <monochrom> if it's also total, then it very likely makes sense.
13:19:38 <EvanR> good point
13:20:01 <shachaf> Unfortunately there are many total things that type-check and don't make sense.
13:20:08 <neuroserpens> ^ Hahahahaha
13:20:13 <rola> it helps to be total and-- yeah ^^
13:20:14 <safinaskar> :)
13:20:48 <athan> EvanR: Wait, are l and rmap flipped?
13:21:11 <athan> looks legit though
13:21:11 <EvanR> rmap is like fmap right
13:21:35 <neuroserpens> roboguy_: Only now did I realize you didn't answer my question properly lmao.
13:21:35 <athan> I'm just going based on how it's layed out
13:21:42 <neuroserpens> roboguy_: I got carried away by the chat
13:21:58 <roboguy_> neuroserpens: what was the question?
13:22:02 <athan> if `A = p . q`, then wouldn't `lmap f A` be something like `(f . p) . q`?
13:22:20 <shachaf> I'll say that it doesn't make sense.
13:22:24 <athan> because it's "left" o_O?
13:22:26 <neuroserpens> roboguy_: What I want to know is if a lambda fits into the initial part of a list comprehension. Like [\lambda whatever x | x <- etc]
13:22:43 <EvanR> shachaf: why?
13:23:20 <shachaf> I would need some convincing to believe that Profunctor instance.
13:23:38 <EvanR> athan: or f . (p . q) ?
13:23:43 <roboguy_> neuroserpens: if you want a list of functions it does
13:23:49 <athan> EvanR: P
13:23:57 <athan> :p*
13:24:01 <neuroserpens> roboguy_: Oh it will return functions then.
13:24:05 <kaiyin> neuroserpens: question edited.
13:24:14 <roboguy_> neuroserpens: yeah, it will be a list of whatever is in that initial part
13:24:20 <kaiyin> http://stackoverflow.com/questions/29309296/f-z-z-n-in-r-and-haskell
13:24:21 <neuroserpens> roboguy_: So I have to write the function separately and then [f x | x <- whatever]
13:24:24 <roboguy_> and lambda expressions just represent normal values
13:24:27 <frerich> neuroserpens: If you want to apply the lambda immediately, you have to use parentheses. Like, [(\x -> x * 2) a | a <- [1..5]]
13:24:38 <roboguy_> neuroserpens: what are you trying to do?
13:24:39 <neuroserpens> frerich: Aaaaaah thanks!!!
13:24:46 <roboguy_> neuroserpens: you could use let instead
13:24:51 <neuroserpens> roboguy_: It's what freerich said xD
13:24:58 <roboguy_> neuroserpens: that's not let
13:25:07 <neuroserpens> kaiyin: Alright, I'll take a look and see if my minimal knowledge can handle it lol
13:25:20 <EvanR> shachaf: which law of profunctors are you concerned about
13:25:22 <roboguy_> neuroserpens: what about [a * 2 | a <- [1..5]]
13:25:31 <EvanR> or should i just go check
13:25:50 <neuroserpens> roboguy_: That works if the function is not complex. But it's the parentheses I want.
13:26:10 <mauris> if the function is complex, don't put it in a lambda IMO
13:26:28 <roboguy_> neuroserpens: but if you immediately apply a lambda, it's really the same as a much harder to read 'let': [n | a <- [1..5], let n = a * 10]
13:26:40 <neuroserpens> mauris: I know. You and roboguy_ should pay no mind to me though. I am a one liner addict. I'm just doing stuff for fun.
13:26:41 <ReinH> lambda just introduces an extra name for no gain, so it just adds complexity
13:26:43 <EvanR> having trouble finding the laws
13:26:48 * neuroserpens shows his one liner machinegun
13:26:58 <neuroserpens> ReinH: Good to know that though.
13:27:05 <roboguy_> neuroserpens: haha okay. But it should be shorter too! Maybe if you showed us what you're trying to do
13:27:22 <dolio> Profunctors are supposed to be covariant functors in the right parameter and contravariant functors in the left parameter.
13:27:38 <athan> Why doesn't every major haskell class, like Functor, Profunctor, Monad etc. have quickcheck tests ensuring their laws?
13:28:02 <monochrom> because their laws talk about uncomputable equality
13:29:25 <neuroserpens> kaiyin: I didn't even understand the description hahahahalmao. Sorry for being a nooblet.
13:29:32 <mauris> can quickcheck not compare "equality" of two "Eq b => a -> b" functions if it knows how to make up values for type a?
13:29:53 <kaiyin> neuroserpens: that's ok. thanks for trying.
13:30:49 <rola> athan, i asked about that regarding functor, and someone pointed out there's this approach  http://hackage.haskell.org/package/quickcheck-properties-0.1/docs/Test-QuickCheck-Property-Functor.html
13:31:17 <athan> monochrom: Ahh, thank you
13:31:41 <athan> rola: Oh, I forgot about that! Thank you!
13:31:44 <kaiyin> I am thinking, if library A depends on B_version1 and C depends on B_version2, what would cabal do?
13:32:14 <glguy> It'd install A against B_version1 and C against B_version2
13:32:23 <monochrom> cabal would bring in both B versions
13:32:35 <rola> i think in dependently typed langs, you can sort of build the laws into the defintions of functor and such
13:32:39 <monochrom> and then A and C would not work together
13:33:16 <athan> rola: Definitely
13:33:17 <monochrom> and then, under suitable circumstances, it would also build one more version of A against B_version2
13:33:32 <monochrom> then the second A would work well with C.
13:33:50 <monochrom> but now you have two A's and B's to confuse yourself. they also confuse cabal and ghc later.
13:34:21 <monochrom> read my http://www.vex.net/~trebla/haskell/sicp.xhtml#pigeon for more. in fact, read the whole thing.
13:34:54 <athan> I'm trying to toy with fundamental properties, like commutativity: Πx:T.Πy:T.Σ<>:T->T->T.  x <> y = y <> x
13:35:16 <athan> where `= : Term -> Term -> Prop` or something :S
13:35:22 <athan> rola ^ :)
13:38:38 <EvanR> doesnt really make sense
13:38:56 <EvanR> rmap id != id
13:40:06 <kaiyin> so, what do you do when you want to install some new packages and cabal warns that this will lead to reinstalling some other packages?
13:40:06 * hackagebot liquid-fixpoint 0.2.3.2 - Predicate Abstraction-based Horn-Clause/Implication Constraint Solver  http://hackage.haskell.org/package/liquid-fixpoint-0.2.3.2 (EricSeidel)
13:42:06 <monochrom> kaiyin: I wonder if you like list comprehension. z n f = [ [f i `rem` n == j | j <- [0 .. n-1]] | i <- [0 .. n-1] ]
13:42:21 <monochrom> this uses True and False rather than 1 and 0.
13:42:30 <monochrom> I hate 1 and 0.
13:43:11 <kaiyin> monochrom: why is that?
13:43:25 <kaiyin> True and False are such a visual burden.
13:44:26 <monochrom> because True and False already exist.
13:44:50 <kaiyin> ok
13:45:06 <monochrom> I agree about display. but display != data.
13:45:07 * hackagebot highlighting-kate 0.5.13 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.13 (JohnMacFarlane)
13:47:10 <kaiyin> monochrom: yeah.
13:48:37 <monochrom> for display, you should be using ◉ and ○. 1 and 2 are neither data nor display. they are a kludge.
13:48:47 <monochrom> err, s/2/0/
13:49:11 <kaiyin> that's cool.
13:51:22 <safinaskar> thanks all for help today!
13:51:27 <safinaskar> i love #haskell
13:51:28 <safinaskar> !!!!
13:51:29 <safinaskar> :)
13:51:30 <safinaskar> ^_^
13:51:46 <neuroserpens> safinaskar: lmao
13:52:07 <neuroserpens> I like happy people
13:52:52 <kaiyin> monochrom: which leads to the question: how do you make a [[Char]] from a [[Bool]] with True replaced by ◉ and False replaced by ○?
13:53:09 <kaiyin> what about [[[Bool]]]?
13:53:27 <arkeet> :t map
13:53:29 <lambdabot> (a -> b) -> [a] -> [b]
13:53:30 <arkeet> :t map . map
13:53:31 <lambdabot> (a -> b) -> [[a]] -> [[b]]
13:53:34 <arkeet> :t map . map . map
13:53:35 <lambdabot> (a -> b) -> [[[a]]] -> [[[b]]]
13:53:39 <neuroserpens> haha!
13:53:58 <monochrom> map (map (\x -> if x then '◉' else '○'))
13:54:10 <dmj`> :t fmap `fmap` fmap `fmap` fmap
13:54:11 <lambdabot> (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
13:54:15 <arkeet> :)
13:54:16 <monochrom> I guess you can do it in-place in z
13:55:06 <kaiyin> arkeet: yeah, I should have thought about that. :)
13:55:07 <neuroserpens> monochrom: Good one. I ended up reaching that answer in my train of thought.
13:55:15 * hackagebot quantfin 0.1.0.1 - Quant finance library in pure Haskell.  http://hackage.haskell.org/package/quantfin-0.1.0.1 (tdees)
13:55:18 <monochrom> > [ [if  (i*) `rem` 7 == j then '◉' else '○' | j <- [0 .. 7-1]] | i <- [0 .. 7-1] ]
13:55:20 <lambdabot>  No instance for (GHC.Real.Integral (a0 -> a0))
13:55:20 <lambdabot>    arising from a use of ‘GHC.Real.rem’No instance for (GHC.Classes.Eq (a0 ->...
13:55:20 <lambdabot>    arising from a use of ‘GHC.Classes.==’No instance for (GHC.Enum.Enum (a0 -...
13:55:32 <monochrom> oops, i*i
13:55:36 <monochrom> > [ [if  (i*i) `rem` 7 == j then '◉' else '○' | j <- [0 .. 7-1]] | i <- [0 .. 7-1] ]
13:55:38 <lambdabot>  ["\9673\9675\9675\9675\9675\9675\9675","\9675\9673\9675\9675\9675\9675\9675"...
13:55:50 <neuroserpens> o,o
13:55:51 <arkeet> > map text [ [if  (i*i) `rem` 7 == j then '◉' else '○' | j <- [0 .. 7-1]] | i <- [0 .. 7-1] ]
13:55:53 <lambdabot>  [◉○○○○○○,○◉○○○○○,○○○○◉○○,○○◉○○○○,○○◉○○○○,○○○○◉○○,○◉○○○○○]
13:56:01 <monochrom> yeah
13:56:12 <kadoban> Is there some way to do this that I'm missing?: I want to have a function that can handle any Integral or Float. It should convert everything to Float and then I'll do what the function does? Would I have to make my own lame typeclass?
13:56:21 <kaiyin> arkeet: how do you print a [[Char]] nicely like a matrix?
13:56:29 <hiptobecubic> What magic is this?
13:56:45 <kaiyin> assuming that each [Char] has the same length?
13:56:52 <RustyShackleford> i'm having trouble getting my test suite running
13:56:58 <erisco> kadoban what is the point? just write a function which accepts floats and the caller can convert
13:57:35 <RustyShackleford> so I have three files at the moment. I'm using HSpec.  src/Main.hs, test/Spec.hs, and test/MainSpec.hs
13:57:36 <monochrom> kadoban: the generalization of Integral and Float is Real
13:57:39 <RustyShackleford> Module imports form a cycle:
13:57:40 <RustyShackleford>          module `Main' (test/Spec.hs)
13:57:40 <RustyShackleford>         imports `MainSpec' (test/MainSpec.hs)
13:57:40 <RustyShackleford>   which imports `Main' (test/Spec.hs)
13:57:43 <monochrom> @type realToFrac
13:57:45 <lambdabot> (Real a, Fractional b) => a -> b
13:58:10 <monochrom> realToFrac is your goto converter for obtaining Float=b
13:58:25 <RustyShackleford> so I think Spec.hs is considered the Main module in my test suite
13:58:30 <monochrom> > realToFrac (45 :: Int) :: Float
13:58:31 <lambdabot>  45.0
13:58:34 <monochrom> works
13:58:40 <monochrom> > realToFrac (45 :: Float) :: Float
13:58:42 <lambdabot>  45.0
13:58:42 <int-e> I need to steal lambdabot for a bit.
13:58:43 <monochrom> too
13:58:59 <erisco> yeah but you just write your float function f, then you  f . realToFrac
13:59:14 <kadoban> Hmmm, okay that might work
13:59:24 <kadoban> Thanks
13:59:31 <ttt_fff> lately I've found programing in ahskel very annoying; with othe rlangauges, I can spend days setting up libraries, boilper plate, etc ... and fell productive; haskell instead is like "give me the type signature, $%&#*%&#"
13:59:32 <RustyShackleford> anyone? i'm lost
13:59:51 <RustyShackleford> if I rename Main.hs, then I can't build the executable because there is no main module
14:00:05 <monochrom> erisco: on odd numbered days, I point out these XY problems and not answer them. on even numbered days, I answer them literally and not point out the XY problem. today is an even numbered day :)
14:00:18 <RustyShackleford> other idea would be to move everything to another source file, and keep Main.hs very small
14:00:29 <arkeet> that sounds like a good idea.
14:00:31 <erisco> monochrom sounds familiar :)
14:00:49 <RustyShackleford> arkeet: directed towards me or?
14:00:51 <jellie> RustyShackleford: I might have an example that could help. Let me see if I can find it.
14:00:59 <arkeet> RustyShackleford: yeah
14:01:36 <RustyShackleford> seems like you should be able to test Main.hs, this has got to be a common task
14:02:01 <monochrom> erisco: the joy of even numbered days is watching people go down a rabbit hole and their productivity go down the drain :)
14:02:03 <jellie> RustyShackleford: Go down to adding tests http://howistart.org/posts/haskell/1 maybe that could help. It's  by a guy here called bitemyapp 
14:02:29 <mauris> today is an even numbered day?!
14:02:29 <monochrom> sometimes, you have to help people fail
14:02:40 <RustyShackleford> jellie: thanks I'll read it
14:03:02 <RustyShackleford> another question: so my project will just be an executable
14:03:03 <erisco> monochrom personally I enjoy wonderland. Also, I did not get around to starting that paper last night but hopefully I can tomorrow
14:03:15 <RustyShackleford> should I just use a flat project layout, or should I do it more like a library?
14:04:17 <arkeet> RustyShackleford: see how the thing jellie linked puts the bulk of the program in a library
14:04:30 <arkeet> then the executable and the test suite both just use that library
14:04:37 <erisco> mauris it is always an even numbered day somewhere
14:04:48 <mauris> i suppose
14:05:26 <RustyShackleford> arkeet: yeah i see that. So i'll migrate everything into other source files
14:05:48 <RustyShackleford> do I really want to create a library too? seems rather complicated
14:06:14 <RustyShackleford> so you build the library first. Then both the executable and the tests link with that library?
14:06:14 <erisco> monochrom I really do not know where the edges of human knowledge are, but I can tell it gets thinner around that topic ... how close to the edge is it by your estimate?
14:07:38 <monochrom> it is not thin. but we need more helpful theorem provers.
14:08:08 <erisco> monochrom what I mean by thin is fewer and fewer people understand the topic and thus there is less and less access to the information
14:09:52 <monochrom> I guess fewer people do research in this than in machine learning
14:10:04 <xxx> Is there any easy way to find out where operators such as <* >* <*> <$> etc are coming into scope? I'd like to look these up, but I obviously can't google them too easily, and a :t <$> in ghci won't work without it imported ...
14:10:23 <arkeet> xxx: hoogle
14:10:37 <erisco> which I do not understand!
14:10:42 <Rembane> xxx: And search on this in hoogle: (<*>)
14:10:45 <xxx> arkeet: danke! that's it :P
14:10:55 <RustyShackleford> jellie: thanks for the link. I think I should be able to figure this out now
14:10:59 <joseph07> Curiosity: why did cabal opt to create a new file format (.cabal) rather than rely on a haskell library to specify package parameters (like how clojure has leiningen projects written in clojure)
14:11:03 <monochrom> I guess that sentence contains less information than I want. I should be talking about the number of people interested, not just researching. but it's still true. fewer people are interested in this than in maching learning.
14:11:22 <jellie> RustyShackleford: :P It helped me a lot too. I had major issues with setting up testing too.
14:11:41 <jellie> RustyShackleford: I wish I could give you what I was working on but it isn't on github
14:11:47 <Caballer> Hi! I was wondering how people maintain multiple flavors of their build environments. E.g. : one with profiling enabled for both the prependencies and the cabal project being developed, one with full optimization (-O2) one, etc
14:11:57 <jellie> Such a shame when something cool is in a private repo
14:12:12 <erisco> I can only guess that experimental correctness is sufficient to placate programmers most of the time, and also the burden of proving correctness at all (who wants more work)
14:12:42 <roboguy_> xxx: :i <$> would work
14:13:19 <jellie> joseph07: I don't know about clojure but isn't cabal a haskell lib that provides a DSL of sorts that we use when writing our .cabal files?
14:13:49 <erisco> from my perspective you absolutely need to know the core of your practical application really does work ... stuff at the fringes you can fudge ... that is what my limited experience tells me *shrug*
14:13:56 <RustyShackleford> jellie: so it seems like I'll have src/Main.hs, src/ProjectName.hs, right?
14:14:05 <xxx> roboguy_: only if it's in my scope, which it isn't. I'm trying to find out where these thing are coming from when I skim haskell sources
14:14:16 <roboguy_> xxx: ahh, I missed that part
14:14:44 <RustyShackleford> jellie: now do where do you put additional source files? src/ProjectName/Additional.hs? or just in src/Additional.hs?
14:15:19 <jellie> RustyShackleford: Most of the time haskell people have their Main.hs being called their ProjectName.hs
14:15:21 <joseph07> jellie: yes, in a sense, but they could have used instead an embedded DSL that's actually haskell, rather than a made up dsl that can't e. g. be explored with ghci
14:16:22 <RustyShackleford> jellie: i had tried that. It seems like you need Main.hs too
14:16:39 <RustyShackleford> either that, or ProjectName.hs starts with "module Main"
14:16:53 <RustyShackleford> otherwise the compiler claims that I have no entry point
14:16:53 <jellie> RustyShackleford: You don't just edit the Main-is in your cabal file to read ProjectName.hs and not Main.hs
14:17:02 <erisco> monochrom does that resonate at all with you? I am interested in what your perspective is given that you already have a vested interest
14:17:14 <RustyShackleford> er, i'll try it again. But I'm pretty sure I couldn't get it to build
14:17:16 <jellie> RustyShackleford: Uh as long as you have your imports set right you can put them whenever you want. However, remember to specify your other modules in either exposed-modules or other-modules.
14:18:11 <jellie> RustyShackleford: The issue has to do with the module you specified as main-is: in your .cabal file.
14:18:16 <jellie> RustyShackleford: I hope I'm not confusing you.
14:19:14 <RustyShackleford> jellie: nope i'm following. I'm almost positive i changed that correctly. I'll try it again
14:19:44 <RustyShackleford> quick question: what restrictions are there on module names? can I use numbers in the module name?
14:19:57 <jellie> joseph07: Hmmm I guess so. But why would we want that? Where the .cabal file would be a .hs files with pure functions and what not?
14:20:21 <jellie> RustyShackleford: I really don't know. I've never tried using a number in a module name.
14:20:48 <dxld_> RustyShackleford: sure just not at the beginning iirc
14:21:25 <RustyShackleford> oh i see why sublime text was highlighting it in red
14:21:31 <RustyShackleford> it didn't like my captialization
14:22:03 <joseph07> jellie: That's right. Instead of a project.cabal file you'd have project.hs (like the Setup.hs that already exists) and the project structure would be written using haskell functions and data structures rather than a made up format that is later parsed into haskell data structures
14:24:02 <jellie> RustyShackleford: Have you tried emacs and hated it? ;D
14:24:13 <RustyShackleford> jellie: yep pretty much. 
14:24:17 <jellie> joseph07: I really like it as it is. It's simple.
14:24:24 <arkeet> joseph07: I can't picture it being as concise as cabal syntax
14:24:30 <joseph07> joseph07: The win would be one less language to learn (.cabal file has some wierd quirks) 
14:24:34 <RustyShackleford> i like vim clones
14:24:45 <RustyShackleford> vim keybindings with convenient gui features
14:24:45 <jellie> joseph07: Personally. I don't see the need for purity and such when specifying my configs and such.
14:24:55 <EvanR> what vim clone?
14:25:01 <arkeet> vi, of course ;)
14:25:05 <EvanR> >_>
14:25:09 <RustyShackleford> EvanR: sublime text
14:25:14 <RustyShackleford> or some IDE with a vim plugin
14:25:18 <EvanR> yeah vim keybindings do not a vim clone make
14:25:30 <RustyShackleford> EvanR: well you sorta get when I mean
14:25:33 <EvanR> i.e. firefox
14:25:43 <int-e> @hoogle a -> a
14:25:43 <lambdabot> Prelude id :: a -> a
14:25:43 <lambdabot> Data.Function id :: a -> a
14:25:44 <lambdabot> GHC.Exts breakpoint :: a -> a
14:25:49 <int-e> > [1..]
14:25:52 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:25:57 <int-e> @type 123
14:26:00 <RustyShackleford> jellie: btw my test suite works
14:26:03 <joseph07> jellie: it's not so much about purity as about simplicity. Having two languages to do one thing is considerably more complex. Additionally, if it were written in Haskell you'd also be able to abstract common setup across projects
14:26:04 <jellie> joseph07: I hardly ever actually look at my Setup.hs I don't even know what's there. Such a shame. I'm ignorant.
14:26:10 <int-e> no?
14:26:11 <jellie> RustyShackleford: \o/
14:26:13 <RustyShackleford> jellie: so do you build a library too?
14:26:24 <RustyShackleford> i have it working with an executable and a test suite
14:26:24 <jellie> RustyShackleford: You're the first person I've helped on irc.
14:26:39 <jellie> RustyShackleford: Uh yes I built a library. A small one.
14:27:02 <RustyShackleford> jellie: i might do that in the future. I'm excited to finally write some code again
14:27:59 <jellie> joseph07: Abstract common setup across projects? Like sharing a sandbox or what?
14:28:31 <jellie> RustyShackleford: Good luck. Why did you stop writing in the first place?
14:29:15 <RustyShackleford> jellie: trying to get a test suite set up
14:29:29 <RustyShackleford> trying to learn a language and all of it's associated tools taks a while sometimes
14:30:55 <tsahyt> does anyone have any library recommendations for raster image processing?
14:31:01 <jellie> RustyShackleford: Oh I get what you mean. I thought you meant that you'd stopped programming and started doing other things.
14:32:52 <enthropy> tsahyt: there are incomplete opencv bindings that might have what you want https://github.com/acowley/HOpenCV (is one)
14:35:01 <tsahyt> I was thinking about something more Haskell-y if that makes sense. I'm torn between using repa for performance or friday for simplicity.
14:36:48 <athan> tsahyt: accelerate looks nice, too
14:37:27 <joseph07> jellie: Not precisely like sharing a sandbox. If you imagine you're working at a company that writes their package descriptions with a particular structure, they could create a function that takes some parameters about the project and assembles it into a description that's uniform across all their projects
14:38:27 <joseph07> jellie: Just as an example. A perhaps more motivating example would be coordinating dependency versions across a suite of packages
14:38:46 <akurilin> question: have any of you guys figured out how to use MinLen comfortably? I'm trying to see if I can replace NonEmpty with it
14:39:00 <monochrom> erisco: I agree.
14:40:53 <jellie> joseph07: That's interesting. Sad thing is I can't really relate because I'm in school and I've never been in such situations.
14:49:16 <int-e> argl. -XUnicodeSyntax affects the :t output now.
14:50:27 * hackagebot blunt 0.0.14 - Point-free Haskell as a service.  http://hackage.haskell.org/package/blunt-0.0.14 (fozworth)
14:50:29 * hackagebot avers 0.0.3 - empty  http://hackage.haskell.org/package/avers-0.0.3 (wereHamster)
14:53:56 <int-e> :t 1
14:54:02 <lambdabot> Num a => a
14:54:10 <arkeet> > あ
14:54:16 <lambdabot>  Not in scope: ‘あ’
14:54:18 <arkeet> yay
14:54:34 <int-e> I've disabled UnicodeSyntax in :t for now ... will try to fix it properly later.
14:54:43 <mniip> @let あ=あ
14:54:50 <lambdabot>  Parse failed: Illegal character ''\12354''
14:54:59 <arkeet> huh.
14:55:11 <rola> あ
14:55:23 <int-e> anyway, lambdabot's on ghc-7.10.1 now; bugs are expected.
14:55:27 * hackagebot ghc-srcspan-plugin 0.2.1.0 - Generic GHC Plugin for annotating Haskell code with source  location data.  http://hackage.haskell.org/package/ghc-srcspan-plugin-0.2.1.0 (EricSeidel)
14:55:46 <rola> ハスケル！
14:56:08 <rola> you maintain lambdabot?
14:56:13 <mauke> > 𓅆
14:56:20 <lambdabot>  Not in scope: ‘𓅆’
14:56:35 <arkeet> @let ☃ = id
14:56:36 <joseph07> jellie: oh in that case you should consider learning a lisp while you can, and clojure is a decent choice. Between lisp and haskell you'll have two good points on the spectrum of flexiblity and structure
14:56:42 <lambdabot> Plugin `eval' failed with: Enum.toEnum{Word8}: tag (9731) is outside of bounds (0,255)
14:56:46 <arkeet> :(
14:57:19 <int-e> > let ☃ = id in ☃ 1
14:57:28 <lambdabot>  <hint>:1:1: parse error in let binding: missing required 'in'
14:57:34 <rola> joseph07, how about some sort of ML
14:57:40 <arkeet> huh.
14:57:54 <arkeet> > let あ = id in あ 1
14:58:00 <lambdabot>  1
14:58:02 <voidzero> > id ☺
14:58:09 <arkeet> > generalCategory '☃'
14:58:10 <lambdabot>  <hint>:1:5:
14:58:15 <arkeet> ?????
14:58:16 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
14:58:18 <lambdabot>  OtherSymbol
14:58:21 <arkeet> oh.
14:58:32 <int-e> > let 1 ☃ 1 = 1 in 1 ☃ 1
14:58:40 <lambdabot>  1
14:58:49 <voidzero> bit slow today, lambdabotje
14:58:58 <arkeet> it's not warmed up yet.
14:59:20 <voidzero> haha
14:59:21 <int-e> it ... was? ... still busy joining channels
14:59:38 <voidzero> ooh
14:59:54 <voidzero> right... I was hiding joins/parts/quits.
15:00:19 <voidzero> I thought you were standing up for it
15:01:02 <voidzero> leave lambdabot alone!1
15:01:07 <int-e> In any case at least it should be usable now.
15:01:23 <Cale> > boop
15:01:25 <lambdabot>      Not in scope: ‘boop’
15:01:25 <lambdabot>      Perhaps you meant one of these:
15:01:25 <lambdabot>        ‘loop’ (imported from Control.Arrow),
15:01:33 <voidzero> attabot
15:01:34 <Cale> okay, cool, that encoding thing is fixed :)
15:01:51 <RustyShackleford> jellie: nice i have my cabal file all figured out
15:02:10 <RustyShackleford> just wondering, is the library being recompiled each time, or just linked?
15:02:48 <arkeet> should just be linked.
15:02:57 <dogmeat> can someone please explain what is m, a, and b when I use show . length >>= printf "%s%s\n" $ "blah"? >>= has the signature m a -> (a -> m b) -> m b but I don't see the monad here
15:03:01 <arkeet> you can watch the build output.
15:03:22 <RustyShackleford> Preprocessing executable 'l4-engine' for l4-engine-0.1.0.0...
15:03:22 <RustyShackleford> [1 of 2] Compiling L4Engine         ( src/L4Engine.hs, dist/build/l4-engine/l4-engine-tmp/L4Engine.o )
15:03:24 <arkeet> printf :: String -> String -> Int -> IO ()
15:03:25 <RustyShackleford> [2 of 2] Compiling Main             ( src/Main.hs, dist/build/l4-engine/l4-engine-tmp/Main.o )
15:03:38 <RustyShackleford> sorta looks like it's being recompiled
15:03:43 <arkeet> er
15:03:48 <arkeet> String, not Int.
15:03:50 <arkeet> because of show
15:03:58 <arkeet> wait.
15:04:02 <neuroserpens> Now desugarize it!!!
15:04:02 <arkeet> stop.
15:04:09 <arkeet> :t show . length >>= printf "%s%s\n" $ "blah"
15:04:10 <lambdabot> PrintfType b => b
15:04:21 <neuroserpens> Now desugarize it again!
15:04:29 <arkeet> :t show . length
15:04:30 <lambdabot> Foldable t => t a -> String
15:04:42 <neuroserpens> And again! Until you are coding in Assembly
15:04:43 <neuroserpens> xD
15:04:47 <arkeet> so the monad is (t a ->)
15:04:57 <dogmeat> t a -> ?
15:05:03 <arkeet> (->) (t a)
15:05:19 <dogmeat> so a function that takes (t a)?
15:05:32 * hackagebot monad-classes 0.3 - more flexible mtl  http://hackage.haskell.org/package/monad-classes-0.3 (MatthewFarkasDyck)
15:05:33 <arkeet> have to look at the right side to see what exactly t a is.
15:05:43 <dogmeat> how about in this particular case?
15:05:48 <arkeet> :t (show . length >>= printf "%s%s\n" $ "blah") "foo"
15:05:49 <lambdabot> PrintfType t => t
15:05:52 <arkeet> bah
15:05:59 <arkeet> :t (show . length >>= printf "%s%s\n" $ "blah") "foo" :: String
15:06:00 <lambdabot> String
15:06:03 <arkeet> > (show . length >>= printf "%s%s\n" $ "blah") "foo" :: String
15:06:04 <lambdabot>  "4blah\n*Exception: printf: formatting string ended prematurely
15:06:11 <arkeet> heh.
15:06:20 <arkeet> wait.
15:06:22 <joseph07> :t PrintfType
15:06:24 <lambdabot> Not in scope: data constructor ‘PrintfType’
15:06:25 <arkeet> > show . length >>= printf "%s%s\n" $ "blah" :: String
15:06:26 <lambdabot>  "4blah\n"
15:06:36 <joseph07> :i Ord
15:06:55 <arkeet> ok, the whole thing is applied to "blah"
15:07:05 <arkeet> so it's (->) String
15:07:29 <int-e> :t length -- oh this is going to take a while to get used to
15:07:30 <lambdabot> Foldable t => t a -> Int
15:07:32 <dogmeat> so it's a function that takes in a string?
15:07:37 <arkeet> yeah.
15:07:50 <int-e> :t show . (length :: [a] -> Int) >>= ?f
15:07:51 <lambdabot> (?f::String -> [a] -> b) => [a] -> b
15:08:14 <arkeet> printf makes things a bit annoying because of the PrintfType magic.
15:08:24 <arkeet> :t show . length >>= (printf :: String -> String -> String) "%s%s\n"
15:08:25 <lambdabot>     Couldn't match expected type ‘[String]’
15:08:25 <lambdabot>                 with actual type ‘t0 a0 -> String’
15:08:25 <lambdabot>     In the first argument of ‘(>>=)’, namely ‘show . length’
15:08:33 <arkeet> uh.
15:08:39 <arkeet> :t show . length >>= (printf :: String -> String -> String -> String) "%s%s\n"
15:08:40 <lambdabot> [Char] -> String
15:08:50 <arkeet> :t show . length >>= (printf :: String -> String -> String -> IO ()) "%s%s\n"
15:08:51 <lambdabot> [Char] -> IO ()
15:08:57 <dogmeat> so what is a -> m b in printf "%s%s\n"?
15:09:03 <arkeet> that depends.
15:09:08 <arkeet> printf has a polymorphic return type.
15:09:40 <dogmeat> how is "blah" being applied to both show . length and printf "%s%s\n"?
15:09:42 <arkeet> it uses a bit of typeclass hackery to accept a variable number of arguments.
15:09:46 <arkeet> and result in either a String or IO ()
15:09:57 <arkeet> that's how >>= for the (->) r monad works.
15:10:13 <dogmeat> i can see how it's being used by show . length but not sure how it's used again in printf "%s%s\n" the 2nd %s
15:10:26 <int-e> dogmeat: it's the reader monad. there's an environment that is passed to every monad action; that's the argument that is being duplicated.
15:10:30 <arkeet> (f >>= k) a = k (f a) a
15:10:47 * hackagebot monad-classes 0.3.0.1 - more flexible mtl  http://hackage.haskell.org/package/monad-classes-0.3.0.1 (MatthewFarkasDyck)
15:10:49 * hackagebot text-show 0.7.0.1 - Efficient conversion of values into Text  http://hackage.haskell.org/package/text-show-0.7.0.1 (ryanglscott)
15:10:51 * hackagebot text-show-instances 0.3.0.1 - Additional instances for text-show  http://hackage.haskell.org/package/text-show-instances-0.3.0.1 (ryanglscott)
15:11:08 <arkeet> @src (->) Monad
15:11:08 <lambdabot> Source not found. Where did you learn to type?
15:11:12 <arkeet> @where src
15:11:12 <lambdabot> The fixed database for the `src' lambdabot command is at <http://code.haskell.org/lambdabot/State/source>
15:11:27 <voidzero> feisty
15:11:28 <arkeet> hm
15:11:30 <int-e> that's a lie.
15:11:38 <arkeet> @src (->) (>>=)
15:11:38 <lambdabot> f >>= k = \ r -> k (f r) r
15:12:03 <arkeet> so
15:12:16 <arkeet> (show . length >>= printf "%s%s\n") "blah"
15:12:27 <int-e> @where+ src  The fixed database for the `src' lambdabot command is at <https://github.com/lambdabot/lambdabot/blob/master/lambdabot/State/source>
15:12:27 <lambdabot> It is stored.
15:12:30 <arkeet> = printf "%s%s\n" ((show . length) "blah") "blah
15:12:31 <arkeet> "
15:12:32 <arkeet> by definition.
15:12:39 <arkeet> @where source
15:12:39 <lambdabot> The fixed database for the `src' lambdabot command is at <http://code.haskell.org/lambdabot/State/source>
15:12:53 <int-e> @where+ source  The fixed database for the `src' lambdabot command is at <https://github.com/lambdabot/lambdabot/blob/master/lambdabot/State/source>
15:12:53 <lambdabot> It is stored.
15:13:14 <int-e> nicely redundant URL, that
15:13:24 <dogmeat> i can understand printf "%s%s\n" (show . length $ "blah") "blah"
15:13:47 <arkeet> dogmeat: ok, now you just need to understand f >>= k = \ r -> k (f r) r
15:13:50 <dogmeat> but not sure how to make sense of >>= or <<= in that case as I can't find the monad
15:14:14 <int-e> (->) r  is a monad.
15:14:18 <arkeet> ok, well your thing is of the form f >>= k $ r
15:14:24 <arkeet> which means f >>= k is a function.
15:14:29 <arkeet> so it has type (r -> a) for some r and a.
15:14:34 <arkeet> so it uses the Monad instance for (->) r
15:15:00 <dogmeat> ah, f >>= k is a function, hmm, let me ponder on it
15:15:15 <dogmeat> right, otherwise it can't take "blah"
15:15:25 <arkeet> perhaps that was the crucial hint you needed, heh.
15:15:30 <dogmeat> but how is it duplicating "blah"
15:15:38 <arkeet> because of how (>>=) is defined for that Monad.
15:15:43 <RustyShackleford> so lets say I have a list like ["1", ... "64"]. I want to insert a "X" between every 8 elements
15:15:57 <arkeet> RustyShackleford: this question seems rather familiar.
15:16:06 <monochrom> j >>= f k
15:16:07 <arkeet> split it up into chunksOf 8, and then intercalate.
15:16:28 <joseph07> RustyShackleford, arkeet: I think I saw someone ask this on reddit a few months ago
15:16:29 <arkeet> that rhymes.
15:17:40 <joseph07> RustyShackleford: http://www.reddit.com/r/haskell/comments/2i4z1h/help_with_a_function_that_inserts_newlines_into/
15:17:53 <fro_ozen> is there a way to read only a part of a string and return the rest?
15:18:05 <RustyShackleford> one other thing I'm kinda stumped on. Lets say I have "XXXyXX" I wanna count the "X"'s and replace them with a number. i.e. "3y2"
15:18:06 <arkeet> fro_ozen: which part?
15:18:07 <dogmeat> arkeet: int-e: thank you, I found the instance Monad ((->) r)
15:18:15 <mauke> > reads "()the rest"
15:18:16 <dogmeat> let me read the source for that
15:18:17 <lambdabot>  [((),"the rest")]
15:18:37 <fro_ozen> thanks :)
15:18:38 <arkeet> :t reads
15:18:39 <lambdabot> Read a => ReadS a
15:18:48 <arkeet> > (reads :: ReadS Int) "123 the rest"
15:18:49 <lambdabot>  [(123," the rest")]
15:18:59 <arkeet> > (reads :: ReadS Int) "bad"
15:19:00 <lambdabot>  []
15:19:09 <EvanR> RustyShackleford: group them...
15:19:18 <EvanR> > group "XXXyXX"
15:19:19 <lambdabot>  ["XXX","y","XX"]
15:19:43 <arkeet> :t groupBy
15:19:44 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
15:20:10 <arkeet> > groupBy ((==) `on` (=='X')) "abXXXcdeXX"
15:20:12 <lambdabot>  ["ab","XXX","cde","XX"]
15:20:17 <joseph07> :t groupBy ((==) `on` id)
15:20:18 <lambdabot> Eq a => [a] -> [[a]]
15:20:34 <arkeet> :t (`on` id)
15:20:36 <lambdabot> (b -> b -> c) -> b -> b -> c
15:20:43 <voidzero> there's also takeWhile, splitAt, splitOn...
15:20:44 <arkeet> that looks like id to me.
15:21:04 <arkeet> and group = groupBy (==)
15:21:05 <voidzero> oh, takeWhile does not return the rest.
15:21:05 <joseph07> arkeet: but cooler
15:21:09 <arkeet> lol :)
15:21:16 <roboguy_> voidzero: there's span and break
15:21:16 <RustyShackleford> where can i see a list of functions that operate on lists
15:21:18 <roboguy_> :t span
15:21:19 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
15:21:29 <RustyShackleford> my problem is that I can't remember all the cool stuff haskell provides
15:21:30 <joseph07> RustyShackleford: you can :browse Data.List
15:21:32 <roboguy_> RustyShackleford: in Data.List
15:21:39 <voidzero> so for fro_ozen the answer is a definite "yes" :)
15:22:22 <voidzero> RustyShackleford, in ghci, start with :browse Data.List
15:22:45 <arkeet> I think the Data.List haddock is probably more readable.
15:22:54 <arkeet> than :browse output
15:23:09 <joseph07> arkeet: That's true, but it's slightly more available
15:23:14 <voidzero> Yeah I'm kinda new to that myself
15:23:19 <dogmeat> does anyone know which Git library for Haskell is the easiest to use?
15:23:20 <joseph07> arkeet: I also sometimes smash hard on that tab complete
15:23:28 <arkeet> lol
15:24:35 <dogmeat> “ h >>= f = \w -> f (h w) w ”
15:24:46 <dogmeat> arkeet: int-e: aha
15:24:52 <voidzero> for ghci I'd love to have two features. 1) Change the ':' command to a different character, I am typing on a dvorak layout, ':' is in the least comfortable place. And 2) get unique entries in .ghci_history.
15:25:13 <arkeet> unique entries would be nice.
15:25:33 <arkeet> and I assume you mean you want the ':' to be configurable.
15:25:37 <joseph07> voidzero: : isn't so bad on dvorak :::::::: Gives you pinky muscles
15:25:44 <voidzero> I have it in the zsh shell - unique history - very nice
15:25:48 <arkeet> yes
15:25:51 <geekosaur> the latter probably wants changes to haskeline, since haskeline is replacing readline where that is a tunable
15:26:05 <voidzero> joseph07, :)
15:26:13 <arkeet> : on dvorak is where Z is on qwerty?
15:26:15 <arkeet> doesn't seem that bad.
15:26:50 <joseph07> arkeet: that's right. I actually broke my left pinky though and it didn't heal right, and the people behind ghci are out to get me
15:26:51 <harski> it's SHIFT-Z on querty
15:26:58 <joseph07> arkeet: but I will prevail
15:27:02 <arkeet> I wrote Z, not z. :p
15:27:14 <harski> arkeet: True :)
15:27:26 <arkeet> joseph07: you use right shift?
15:27:31 <voidzero> after a few hours of ghci and :reload and so forth, yeah, I'd love to change it anyway :P
15:27:35 <joseph07> arkeet: all day
15:27:38 <athan> Is the Writer monad just a fold or something? The Monoid accumulator confuses me a bit
15:27:42 <arkeet> I don't think I ever use my pinky on z, always ring.
15:27:43 <voidzero> to ~ or " maybe
15:27:57 <c_wraith> athan: the Writer monad is just a pair.
15:27:59 <arkeet> I always use left shift though.
15:28:09 <arkeet> the right shift key on my keyboard is the least worn one, I think.
15:28:23 <EvanR> athan: join for the writer monad uses mappend
15:28:25 <athan> c_wraith: That's what I was thinking - State - Reader
15:28:30 <voidzero> I've trained myself to use the shift of the available hand, but for some reason, I don't do that with :
15:28:34 <athan> EvanR: Ahh, okay
15:28:36 <c_wraith> athan: those three happen to work exactly that way, yes
15:28:39 <voidzero> so I use both shifts
15:28:51 <arkeet> right shift is just so far away.
15:29:02 <joseph07> voidzero: as in, you press the left and right shifts simultaneously?
15:29:06 <hiptobecubic> arkeet, on what kind of keyboard?
15:29:07 <voidzero> LOL
15:29:09 <voidzero> no
15:29:20 <voidzero> if I want a capital I, I use the right shift
15:29:27 <voidzero> capital L, the left shift
15:29:28 <athan> perfect, thank you `fmap (c_wraith &&& EvanR) session`
15:29:29 <voidzero> and so on
15:29:36 <athan> (can you fmap arrows? :S)
15:29:46 <joseph07> voidzero: gotcha. I tried it and on my keyboard pressing both shifts doesn't work
15:29:48 <c_wraith> if the arrow is also a functor, sure!
15:29:50 <arkeet> :t fmap (?c_wraith &&& ?evanR)
15:29:51 <lambdabot> (Functor f, ?c_wraith::a -> c, ?evanR::a -> c') => f a -> f (c, c')
15:29:58 <EvanR> wurt
15:30:00 <joseph07> voidzero: with ':'
15:30:33 <athan> >:D!
15:30:59 * hackagebot binary-list 1.1.0.0 - Lists of length a power of two.  http://hackage.haskell.org/package/binary-list-1.1.0.0 (DanielDiaz)
15:31:23 <voidzero> joseph07, works fine here.. not sure why I'd ever want to use both shifts at the same time though :)
15:31:27 <voidzero> anyway
15:31:36 <voidzero> the older I get the more my joints start to hurt
15:32:06 <athan> voidzero: Glucosamine!
15:32:09 <athan> and MSM!
15:32:11 <voidzero> maybe someone in here has the ability to pitch my request for a remappable ':' in ghci..
15:32:52 <voidzero> hmm, we might even have glucosamine here.. what's the other stuff?
15:34:04 <voidzero> although it's also an inherited problem. My dad has fingers the size of kroketten.
15:34:14 <athan> http://en.wikipedia.org/wiki/Methylsulfonylmethane#Medical_and_dietary_use
15:34:20 <athan> :\
15:34:34 <Confusion> I'm using head $ dropWhile f (scanl mappend mempty listofMonoids) and it's the bottleneck of my code, probably because it is responsible for over half of all allocations in the program. Are there ways to speed something like that up?
15:34:49 <athan> I'm not sure if it will help, but it's helped my daily aches. (maybe we should move to #haskell-blah for this subject)
15:35:03 <voidzero> agreed
15:36:22 <voidzero> About ghci. I was thinking, maybe I could make a wrapper for ghci in zsh, that does these things - : remap and unique history
15:36:26 <voidzero> that'd be funny
15:37:48 <Confusion> So I'm combining monoids until some condition is met and I want to know the monoid that satisfied the condition
15:39:13 <Cale> Confusion: You mean that you're combining elements of some monoid
15:39:26 <Cale> The monoid is the type itself, not its elements.
15:40:00 <Cale> Confusion: Which monoid is it?
15:40:12 <Cale> Oh!
15:40:16 <Cale> I see what you're doing.
15:40:22 <Cale> Okay, write this function:
15:40:26 <Cale> strictList [] = []
15:40:45 <Cale> strictList (x:xs) = x `seq` (x : strictList xs)
15:40:56 <mauke> heh
15:41:06 <mauke> hello strictList, my old friend
15:41:20 <Cale> Oh, no wait, dropWhile is going to force things
15:41:25 <Cale> That's not the problem
15:41:47 <Cale> No, I'm back to needing to know which monoid it is that you're working with.
15:42:14 <Cale> Possibly the monoid elements are not being fully evaluated by the condition in f?
15:42:28 <Confusion> It's one of my own devising, but basically it's a record of two fields and combining them just does + on both fields
15:42:42 <Cale> Okay, and what's f?
15:43:17 <Cale> If you're only testing one of the parts of pairs, then the other one might be accumulating a rather large sum
15:43:23 <Confusion> \item -> field item < cutoff
15:43:27 <Cale> (as an unevaluated expression in memory)
15:43:29 <Cale> yeah
15:43:42 <Cale> So, if you're only examining one of the fields of the item, that's the issue
15:43:54 <Cale> Perhaps make the fields of your pair type strict
15:44:01 <Cale> by putting ! before them in the type declaration
15:44:52 <joseph07> Cale: could you add the strictness to f? Evaluate the other field and then test the field of interest
15:46:08 <Confusion> Cale: Thanks, that does improve things quite a bit, but it's still the bottleneck.
15:46:08 <joseph07> Cale: it's probably better in this case to make the fields strict, I'm just wondering if it's possible to make it work with a less sweeping change
15:47:10 <mauke> \item | otherfield item `seq` True -> ... ?
15:47:56 <joseph07> mauke: I was thinking something like \item -> otherfield item `seq` field item < cutoff
15:48:32 <joseph07> mauke: is the guard preferable?
15:49:07 <mauke> it can be added as a separate equation in named functions
15:49:31 <Confusion> BTW, isn't is common parlance to call elements of a monoid monoids as well, you like talk about strings and not necessarily 'elements of type String'? Or is that discouraged / frowned upon / just not idiomatic?
15:49:35 <mauke> joseph07: http://okmij.org/ftp/Haskell/#making-function-strict
15:50:14 <mauke> Confusion: but monoid is the class and the "elements" are types
15:52:16 <jellie> jle`: We aren't meant to interact with the value constructors for Auto, are we?
15:52:24 <joseph07> mauke: Cool thanks
15:52:54 <Confusion> mauke: Then I'll rephrase to: 'isn't it common parlance to call elements of an instance of Monoid, of which, in the current context, I'm mostly interested in the fact that implementations of mempty and mappend exist, monoids as well, just like ...' :)
15:53:27 <mauke> then I'll rephrase to: no
15:54:11 <joseph07> I'll rephrase to: Nothing, what's a monoid with you?
15:54:38 <joseph07> so does this mean I can't say strings are monoids?
15:54:46 <joseph07> I should say strings are instances of monoid?
15:54:57 <joseph07> Can I say strings form a monoid?
15:55:03 <mauke> no, [a] is an instance of Monoid
15:55:15 <voidzero> "list of a"?
15:55:24 <mauke> or you could say String is an instance of Monoid
15:55:30 <mauke> or String is a Monoid
15:56:33 <monochrom> "the collection of all strings (together with something else, actually) is a monoid" is a true statement. however, this refers to the entire collection of all strings, not an individual string.
15:56:34 <athan> joseph07: Possibly empty, ordered collections with union as <> and the empty collection as `mempty` form a monoid :)
15:56:44 <voidzero> So case does matter, mauke is that your point?
15:56:58 <Confusion> OK, it just seemed to me that saying a 'list of monoids' sounded sufficiently clear and shorter than 'list of elements of an instance of Monoid'
15:57:11 <joseph07> voidzero: Point is "blah" is not a monoid, but String is
15:57:19 <mauke> yeah, we informally talk about sets when it's really tuples of set + operations
15:57:41 <Cale> Confusion: No, elements of a monoid are not monoids. If you say M is a monoid, it implies that M is a type which is an instance of the Monoid type class.
15:57:47 <voidzero> ah ok. I follow.
15:57:52 <joseph07> mauke monochrom voidzero: under (++)
15:58:03 <monochrom> similarly, an individual string like "xyx" is a member of the set of all palindromes. the set of all palindromes, the whole set, is in P, the set of all languages decidable in polynomial time.
15:58:10 <Cale> Confusion: Similarly, if you sat that M is a monad, it implies that M is a type constructor which is an instance of the Monad type class.
15:58:34 <monochrom> but it would be a misconception to conclude that "xyx" is a P.
15:59:00 <monochrom> (which some of my students did, before they dropped the course. the course on NP-completeness etc)
15:59:10 <Cale> Confusion: e.g. Maybe is a monad, but Just 5 is not.
15:59:29 <athan> monochrom: Do you have slides? :D
15:59:33 <monochrom> no
15:59:52 <monochrom> also, I am just the TA, responsible for tutorials and grading.
15:59:56 <Cale> Confusion: It doesn't matter so much right now in Haskell land, because type level lists are not so common yet.
15:59:57 <athan> monochrom: What book should I read?
16:00:21 <Cale> Confusion: But once you get to dependently typed languages, or Haskell with enough extensions, you might very well have a proper list of monoids.
16:00:25 <athan> I trust your judgement over google's :\
16:00:48 <Cale> (i.e. a list at the type level, not a value)
16:00:56 <monochrom> I am hesitant in suggesting a book that will cost you much money, even if it's the textbook we use.
16:01:25 <Cale> (well, dependently typed languages blur the line between types and values, but that's another matter)
16:01:33 <athan> shoot
16:01:38 <monochrom> I am in fact not an expert in this field (my expertise is elsewhere), so I don't know many books and I haven't compared them
16:01:47 <Confusion> Cale: I understand. Is there a convenient shortcut for the question I originally had or is there no clear way to pose such a question without expanding into 'elements of an instance of Monoid'?
16:01:50 <athan> Cale: Have you looked at some of the pure type system grammars for \p, for instance? They look really strange
16:01:57 <roboguy_> monochrom: you taught a theory of computation class? I'm in one right now, hah
16:02:07 <Cale> Confusion: "elements of a monoid" is clear enough
16:02:17 <Confusion> ack
16:02:24 <athan> monochrom: Shoot, well thank you for not steering me down a rabbit hole :)
16:02:29 <Cale> Confusion: Did you solve your performance issue? I had to go to dinner there.
16:02:38 <monochrom> but the course lists two textbooks for students to choose one from. they are: Michael Sisper's book, or Moore & Mertens
16:02:39 <Cale> oh, I see
16:02:44 <Cale> It improved but not completely.
16:02:55 <athan> thank you monochrom :)
16:02:59 <Cale> Probably we'd have to look more carefully at what's going on
16:03:46 <Cale> joseph07: To answer your question, yes, we absolutely could do that instead.
16:04:33 <Confusion> Cale: Yeah, I simplified matters from the actual code, but the scanl is actually on a separate line, assigned to a variable, because if the dropWhile condition is never met and dropWhile drops everything, I actually want the last value from the scanl as the result
16:04:58 <Confusion> Cale: So that probably causes a problem
16:05:15 <Cale> Confusion: Oh, indeed.
16:05:28 <Cale> Confusion: Probably that means that the entire list is being held in memory.
16:06:29 <Cale> Confusion: It might be profitable to define a variant of head . dropWhile f which does what you want it to do directly.
16:06:43 <Cale> So that the head of the list can properly be garbage collected
16:07:14 <Cale> rather than holding a reference to the beginning of the list the whole time while you work out whether the dropWhile is empty or not
16:08:27 <Cale> This might even be an instance of dropWhile f' . tails
16:08:34 <Cale> something like...
16:09:11 <joe9> Is there any way to read some data serialized to a file using pprint or groom?
16:09:33 <joe9> I want to write to a file using some pretty print format but also want it to be read by haskell.
16:10:06 <joe9> I use "read" to read the file contents. But, "read" cannot parse pprint output.
16:10:19 <joe9> Any suggestions on the proper way to do this, please?
16:10:38 <athan> joe9: Is the serialization process custom, or from some library?
16:10:43 <athan> because usually they would have parsers, too
16:11:07 <athan> if not, you might have to write your own parser for your language (with {,atto}parsec and the like :\)
16:11:51 <Cale> > (\((x:_):_) -> x) . dropWhile (\xs -> case xs of [x] -> False; (x:_) -> x <= 10) . tails $ [1..10] -- this still fails if the list is empty, so we need to be careful
16:11:53 <lambdabot>  10
16:12:12 <Cale> Confusion: ^^ try something which looks like that
16:13:27 <joe9> athan: I used IPPrint
16:13:39 <Confusion> Cale: thanks, I'm going to try that
16:13:49 <mauris> can i get ghc to only typecheck my code without compiling?
16:14:00 <athan> joe9: Ahh, yeah no dice there :\
16:14:16 <joe9> athan: will read work with groom?
16:14:19 <athan> you might get away with it by doing an `unlines` or something similar before you try `read` ing
16:14:28 <athan> I also doubt it with that, too
16:14:37 <athan> the spaces are always strange to handle
16:15:11 <athan> but, if you can take away the newlines and needless spaces, and there's still a Read insance for your data, you should be able to `read` the cleaned string
16:15:22 <joe9> athan: unlines is a smart idea., Thanks.
16:15:24 <frerich> I’m trying to use a package ‚fastirc‘ which depends on ‚network-fancy‘; alas, ‚network-fancy‘ doesn’t build on OS X right now. I cloned the repository, fixed the issue and submitted a pull request - but it’s probably going to take some time until there’s a new network-fancy release (and then some more time until the dependency in ‚fastirc‘ is bumped). Is there a good way to temporarily make ‚fastirc‘ use my local, fixed, version of 
16:15:25 <frerich> ‚network-fancy‘ so that I’m not blocked?
16:15:33 <athan> joe9: Thanks :) good luck!
16:17:17 <glguy> frerich: If you're using a sandbox you can add that to your sandbox with cabal sandbox add-source
16:17:55 <glguy> frerich: Also if you're playing with IRC like the rest of us you might join #haskell-irc
16:20:48 <Cale> Confusion: We could also write it as a list comprehension given that head of dropWhile is the same as head of filter: head [x | (x:xs) <- tails [1..10], null xs || not (x <= 10)]
16:20:50 * mniip join
16:20:53 * mniip joins
16:29:16 <Confusion> Cale: that code was flawless, but it doesn't solve the memory use. It now reads (\((x:_):_) -> x) . dropWhile (\xs -> case xs of [x] -> False; (x:_) -> size x < cutoff) . tails $ accumulations where  accumulations = scanl mappend mempty items and the allocation of the accumulations is still the bottleneck
16:31:20 <Confusion> Performance is worse than the 'two phase' version, which checked the result of dropWhile for (not . null) and chose the head if there was one and 'last accumulations' otherwise  
16:34:37 <Cale> Confusion: hmm
16:34:43 <RustyShackleford> this one has me stumped. Lets say I have a string like "a  b   c". I want to count the number of spaces, and replace with the count i.e. "a2b3c"
16:34:54 <Cale> Confusion: You're trying to cut the time cost or the space cost?
16:35:19 <Cale> Confusion: Like, are you just trying to reduce the amount of memory allocated, or the amount of live memory?
16:35:54 <Cale> RustyShackleford: group might be a good start
16:36:05 <Cale> > group "a  b   c"
16:36:06 <lambdabot>  ["a","  ","b","   ","c"]
16:37:58 <Cale> > map (\xs@(x:_) -> if x == ' ' then show (length xs) else xs) . group $ "a  b   c"
16:37:59 <Confusion> Cale: the time cost. The time and allocation cost of the bottleneck are approximately the same, so I think all those memory allocations actually are the bottleneck
16:37:59 <lambdabot>  ["a","2","b","3","c"]
16:38:10 <Cale> > concatMap (\xs@(x:_) -> if x == ' ' then show (length xs) else xs) . group $ "a  b   c"
16:38:12 <lambdabot>  "a2b3c"
16:38:29 <RustyShackleford> Cale: well thats definitely a start. Let me mess around with it 
16:38:38 <mniip> hmm
16:38:42 <Cale> Confusion: okay, then yeah, my version will probably do more individual allocations
16:39:09 <Cale> Confusion: The best thing for it might just be to write the thing recursively
16:39:31 <Cale> Confusion: oh wait, before we go on
16:39:38 <Cale> Confusion: you *are* compiling with -O2, yes?
17:18:50 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org | Learn, Teach, or Get Out of the Way!'
17:18:50 --- topic: set by shapr!~shapr@84.200.228.78 on [Tue Mar 17 12:32:20 2015]
17:18:50 --- names: list (clog iasoon pfurla ajtulloch jfischoff dented42 lifter slashus2 doodlehaus predator217 homovitruvius inhortte andrus tommah reem kolmodin_ zcd moplove darkbolt Ipsum ronbrz dmj` DerisiveLogic Xeironis tromp thomas favonia Splike BlueRavenGT porglezomp fizbin dan_f waxjar athan jefus_ ProofTechnique EvanR Noldorin daniel-s_ bms1 Longlius meoblast001 marchelzo_ khisanth_ rcyr seangrove katsh nicolastarzia joe9 martinbmadsen armyriad caconym manuel__ dgpratt)
17:18:50 --- names: list (Jesin-phone solrize wlangstroth jedws dysinger djapo turtil blerud troydm Xe noelm_ RevBayes senoj project2501a s1n4 dnkndnts atn34 cleamoon__ frerich ElectricSolstice tgeeky ellipsis_ imsys tommd_ aupiff tcsavage innertracks lambdabot plutoniix rodlogic conal slogsdon Lokathor Nahra arianvp swgillespie shouya caumeslasal1 zcourts osa1 netj Kensan octalsrc catsup Swizec tim_heap proq vneutrino argiopetech johtso_ aarvar joseph07 cbm80 sm MuffinMan`)
17:18:50 --- names: list (A205B064 irrequietus sh1ken whaletechno Paradisee Beetny mac10688 theorb etandel arjanb gilligan_ f|`-`|f aartamonau ndrei whitesn yqt JagaJaga hendrikm ixti emanuelz mithsv dashed Betal xahry pacak cipher andrewsw mkster_ silver_ haskell588 CaptainLex ScRaMbLe doomlord_1 Oxyd Voldenet govg ericwa lebek natanjmai neuroserpens byorgey luzie ciwolsey Asa9t1 joaopizani yamadapc startling MrScout adek krakrjak_ _ashbreeze_ anttih bjorkintosh pyon zbrown)
17:18:50 --- names: list (jimstutt dfeuer donkeyKing1 s4msung hiptobecubic ics blicero_ xificurC mgsloan mads- oneeman dolio xinming totte hiredman psy_ PragCypher Ralith petermw louisjb louis` j201 SCHAAP137 oscar_toro jbalint benaiah ashnur fro_ozen gsingh93 pheaver skeet70 mauris uberwach DanielDiaz trism marr surfncode Qfwfq tommd schell josephle printer Hugehead StoneCypherAW rossm RGamma albel727 renekooi MrFlibble __zug__ mada _X_C_V_B_ Xnuk tinyblak ghostpl_ tsani larion)
17:18:50 --- names: list (Mon_Ouie Sorella mtncode zaquest bernalex ollef vin-ivar tumdedum jokester ssn__ enthropy pata zyla buoto s00pcan_ s00pcan thunderrd capisce jergason boj_ RegEchse tpsinnem Stratege_ Soft jacksnipe greeny ktosiek rgr melter Wamanuz ahihi freusque kav jhance lolisa yusukesuzuki acidjnk dario` kaiyin jml sdothum M-ou-se NightRa rui1 godel kosorith verement earthy ceii ft Paks arw SoupEvil tv blicero mountaingoat yfeldbl__ m0rphism cyphase jaen jakutis)
17:18:50 --- names: list (neptunepink ckw sprang Tene ByronJohnson Enigmagic orbital __main__ Talryn magicman DrAwesom_ eazar001 fifosine hackagebot shintah bjz_ mjo MK_FG nik_89 sakiriou1 otto_s_ qbit timothyh liyang byaruhaf lifenoodles DanToml roboghost fnordbert solvip Hijiri thebnq perrier cdidd mauke infinity0 vili eisbehr PyroPeter hamishmack tranma Guest96212 itsmonktastic fraq4415 zxq9 arbelos Sonderblade Zekka WraithM stbuehler ]OLI[ falafel dodgems apaku Rotaerk amosr)
17:18:50 --- names: list (spindas sebleblanc chirpsalot Chobbes nisstyre sunnavy adzuci Nik05 tessier greenbagels lykkin shutdown_-h_now dgorbik_ optocoupler Bane^ Natch tomboy64 mceier shesek atomi Nadrieril Jaak mirsal gdoteof rofer paf31 rsynnest moghedrin amiri_ derekv xxx oats bmuk kaffepanna rj-code eevar Nimatek Shapeshifter maraoz_ plhk bvad andjjj23 thomassgn Azel butyoudonot Adios fengshaun tlevine TRManderson ellinokon zq l3dx noddy theanalyst tongcx DenSchub karshan)
17:18:50 --- names: list (defanor qz quaestor uber eamelink AntiSpamMeta hive-mind kini jrib tjbp devi deavid cpa_ pharaun thomie paz__ heaumer solarus PHO dawik deni mortberg gargawel rabisg kloeri relrod ZsoL froztbyte tstc spacebug JamesJRH Phillemann claudiyoh lf94 stomp koomi igniting ad ndeine pdxleif swen rieper nitrix Guest90609 padre_angolano bolmar adimit xenocons natte guibou javawizard ilmig eyem_ fyolnish sorind KitC lolocaust ivan\ BlakeRain foolie Phlogistique harski)
17:18:50 --- names: list (tomjaguarpaw ido pingu sternenseemann xiaolin pranz1 jaspervdj ChristianS rseymour vladan cmn acomar mokus shachaf smtudor flxx siddhu Factionwars theorbtwo heath kakos ctag Eagle_Erwin fionnan cjay petercommand BMeph cdk_ aristid crazydiamond noctux ubuntor thoradam kvitebjorn boris`` `bps jstolarek int-e mantovani2 mathu Internet13 Baughn lseppala amiller_ syk0mantis demolithion thorkilnaur_ ion TheMoonMaster meteo martintrojer micrypt avocado _flow_)
17:18:50 --- names: list (Excureo cursork Elsi beauby Tehnix qr42 numberten enomies_ pm5 uwap Licenser cryon sellout usr Paprikachu exio4 frawgie lpsmith jrslepak vermeille bergmark Shagane jameseb Reiser ibid Laney Zanzare jnoah comboy_ tromp_ dxld_ _5kg ggVGc joehh1 kriwil dowski_ lytchi Tesseraction_b esssing larcb ortmage maurer machineslearn hpc kvieta- d3lxa pygospa jarvi_ thoughtpolice spwhitt hyPiRion monsieurp DANtheBEASTman ski maskd bjornars1 pieter_ knyppeldynan zxtx_)
17:18:50 --- names: list (lattenwa1 mpereira_ whiteline supki SwashBuckla ljhms brennie_ banjiewen fikusz_ runde_ lamilami gtklocker tomku|two mgaare mendez_ anders^^_ ninegrid_ aleator_2 Juka_ saurik_ iulian_ Zemyla_ taksuyu_ aleator_1 haroldwu_ Yawgmoth mikemac sdx23 ch3mical Erstarrung nulpunkt burp_ drmegahe1tz wagle ousado marens d-q-d Drezil yeltzooo9 Guest23539 Watcher7_ rul Quashie__ cchalmers snhmib doppioslash _ether_ zaroth__ masse antoniy^afk Jellydog joneshf-laptop)
17:18:50 --- names: list (fractalcat KorriX zeiris Yaniel Laquendi augur TDJACR C4Cypher laudiacay Ankhers lurker6 joeyh martingale ozataman CADD guampa scott arnoblalam dreixel_ GGMethos ThePhoeron Fr4n unknownloner RageD zomg hanDerPeder Rembane sohum buMPnet XMunkki _zxq9_ anastas prophile rike RayNbow`TU xnyhps derillium elementalest_ frogpunc agumonkey rola ValicekB Sigyn haBuu_ phaazon ikke Sgeo_ kalloc em LordDeath aloiscochard dsturnbull_ zariuq aawe benzrf kmicu robbert)
17:18:50 --- names: list (xpika boothead sivoais frontendloader zilinc_ adlan lhdc ruukasu jessicah glguy dino- renzhi gienah dgonyeo statusbot jtanguy mt ReinH klarrt Guest37295 gsnewmar` bind TallerGhostWalt_ shmookey1 Boney lispy iross_ simon mimi_vx suhorngM_ BillyIII keaml kidnapped_robot bydo Darkflux akurilin dstanek dibblego albertid blenny Tril poucet mrd rdema Haskellfant sebastard myst asjo dgvncsz0` Xack sokoll FreeFull phaskell wrengr_away aaronlevin monochrom mitchty)
17:18:50 --- names: list (SegFaultAX gnomnain` thetallguy chishiki flaiw hiratara horlicks_ gnusosa raek Plasmastar MrWoohoo reactormonk LeaChim jonesinator hattusili_III Sornaensis [swift] phuu obiwahn gseitz milessabin newsham pharpend balaji sabalaba Orwell84 so jaffachief platz GaveUp kaictl LnL asm89 iElectric ormaaj mlen bshelden gbiv dan64 _rgn yarou jdiez zso negatratoron tnks qzzx jackhill cynick Or1 kipras`away monty abh ilias vikraman ephess agatam Ptival plsk inuoppai)
17:18:50 --- names: list (jlewis hsyl20 rivarun aristid_ avn unsymbol benbangert malllle stelleg prkc dabradley Freundlich arjen-jonathan Cathy koala_man kofno oberstein jud pii4 Spockz Cerise dp_wiz gniourf drone| eL_Bart0 Guest82577 namuromus mietek xintron kolmodin zorzar lokydor eyenx pavlicek stass drbean Vorpal jacksoow lnr m1dnight_ fergusnoble peddie bitraten OlegYch0 kjanosz dkua ParahSailin gratimax tzaeru fr33domlover sagittarian|3 cjheath Maxdamantus mniip Jonno_FTW hvr)
17:18:50 --- names: list (msgctl petantik sLite pleiosaur andbroby ElderFain Geekingfrog liste Willis ttuegel AshyIsMe Frank89RM_ Kruppe Fylwind naudiz|offline ryanakca carter_cloud jkarni sunfun nikola twopoint718 alynn ixian nakal duga u_ jix rslima _1126 Lutin` u-ou fling Dixie-Flatline Ke psacrifice somenick irishsultan stasku nbouscal Heero sclv k4r1m biscarch _klm FofG tazjin cloudhead_ JonasH__ NemesisD emmanueloga lacrosse__ hguux__ leifw sephiap idnar shelling__ bgyss)
17:18:50 --- names: list (trig-ger zero7 bcavalier nkpart julienXX yrashk Xorlev _ikke_ tristero DigitalKiwi ghorn da-x Polarina miklcct saep yac ackthet loz-- mrphy dewdrop ps-auxw flux zhulikas vpm electrogeek besenwesen ab9rf ForNeVeR Axman6 mecalopolis sw1nn tdammers krgn niko etabot hefner Brando753 fiola mmaruseacph2 mpw geekosaur jmcarthur agrif BrianHV obcode Draggor japesinator ErichKeane Klumben mikeizbicki wolf_mozart cjwelborn alphonse23_ wjm ehamberg noteventime gws)
17:18:50 --- names: list (Eiam bananagram hongminhee dsantiago Gothmog_ jophish bob_twinkles condy Svedrin divVerent brezel hisdke Fuuzetsu Rastus_Vernon dgorbik gmcintire nemesit|znc mpickering _br_ nilscox jle` sajith dmwit notdan fryguybob myst|work aleator__ goldfire lassulus mephx suls McManiaC otulp davl dschoepe grohne nwf sbauer322 bjobjo colah slasktask RustyShackleford valdyn kennyp dropdrive HylianSavior meretrix bennyklotz Nivim doctorinserenity yukonjack rs0 dixie_)
17:18:50 --- names: list (benwf rossberg_ CruddyBucket mach kgadek comma8 dustinm tolt kaol julmac OutlawStar wto Belgarion0 troch helgar clauswitt tg lyddonb fredsir dh senseibaka karls tswett nyuszika7h Intensity td123 PotatoGim phadej sujeet xandaros imalsogreg Philonous wayne apo fugyk saiam levi Vbitz dpn` cschneid Bigcheese lahwran oherrala Th0mas Igloo huonw HugoDaniel Zariel oneb NikolaiToryzin orzo fiddlerwoaroof Dykam mami sys9mm Profpatsch honza ezrios janne kosmikus)
17:18:50 --- names: list (Plastefuchs darkowlzz|afk bartavelle seliopou mak` brackets jmct mjrosenb statusfa1led kazawore_ acharm_ dabukalam zeroskil1or jedavis ephemeron gbarboza zph seanparsons dlackty__ Raynos otherchas_ andreypopp S11001001 jabbslad_ hellschreiber bcarrell moy kalz milli rbocquet keko-2 Spaceghost liff pikhq acfoltzer sudog teeteewhy Ferdirand ircbrowse integral Forkk Walther staffehn_ Cale zerokarmaleft cross ninzine Desoxy voidzero ironChicken Guest37394)
17:18:50 --- names: list (xplat kohelet zymurgy kwantam felixsch Ornedan aaronweiss74 pfoetchen Fubar^ pwestlund_away alanz DustyDin1o killtheliterate alem0lars suvash_away brisbin lachenmayer RevJohnnyHealey michaelpj davean betawaffle Doji majoh rray cscorley irclogger_com Cr8 pmade myme cbaines chris2 Twey sgronblo metaf5 sea-gull tomprince mikeplus64 spion jlouis ahf edk cowtown Hugglesworth callumacrae isomorphismes arkeet Vq joehillen carter scopedTV averell mikel joshc)
17:18:50 --- names: list (otterdam drewdavis cjh` dilinger wting taruti friden Dodek ninedotnine IbnFirnas lieven `0660 Starfire mrowe_away gandr trevorriles jlyndon coeus andreass idoru flori David Jello_Raptor linduxed mozmoney Kneiva yukko nuser Tiktalik Fuco Preyer jrp6 eikke ThreeOfEight dlowe Clint fmapE kshannon schlumpi ernst ww adnap adamse drdo Hafydd KeelOfSteel edwtjo tekacs jorj marienz FireFly tridactyla xaimus SLi kloplop321 zyoung Draconx cow-orker SHODAN inr_ hpd)
17:18:50 --- names: list (az diginet darthdeus tuv robotbrain Liskni_si primepie tippenein alang CosmicRa` neena Pucilowski bcoppens haasn srhb greymalkin solirc ij Adeon Saizan bsummer4 bonobo_ johnw Taneb ChongLi bdawn _di zalami Razz wtw Floyd_ biio Boreeas blast_hardcheese niluje zebr dxtr xaxes` mrkishi aaron__ mindos_cloud____ mrb_bk lyxia benonsoftware alevy wizonesolutions mmmpork incomprehensibly joefiorini_ pii zrl ggherdov mbrcknl si14 korpse_ CARAM__ codehero OliverJAsh)
17:18:50 --- names: list (neektza MMuse_______ joefiori___ jonrh bkolera Tritlo chriswk tarcwynne lohkey fuziontech jroesch raid SuperTux88 tych0 lpaste stvc Guest99579 cin Blkt rom1504 fold davesilva dmilith pi8029 fall` kevin1024 udevd osfameron ggreg Nickeeh Jaxan lambdahands poikon jfokkan nmashton cstrahan_ ocharles_ konne_ andrew__n AlainODea divyanshu n1ftyn8 cojy_ avdi joedevivo kjnilsson mankyKitty shennyg skarn Harbinger bafbomb__ dju agam hodapp wenzowski maw dlundy)
17:18:50 --- names: list (astocko mattp_ theDon luite ziman kess brent80_plow arrdem Ring0` rtl_ c-rog_ Eliel eagleflo dredozubov mechairo` noplamodo devJunk DanZimm geal d-snp sagelywizard seagreen amontez Nanar jludwig jayne Artpicre howard vodkaInferno kemitchell jcurbo shapr eyck bitemyapp klugez aidecoe jokra aseidl f_x_ s_e cods bbee kragniz l3france alpounet hbar zpconn__________ arnihermann caasihuang ricardo82 joefiorini__ kirjs______ puzza007 bigs c9sould__ mno2 akahn)
17:18:50 --- names: list (etrepum edwardk posco conehead cosban- lenstr efm znutar Athas tero- joeytwiddle JPohlmann nesqi aupo shiona absence joefiorini NeatBasis sleepynate palatin bthom alekst_ lfp__ seabre dstockwell Dtgr arch_ sweenzor edran_ @ChanServ vikram_ btc___ blindscreen asabil iota_ WarzoneCommand hrnz heikkih CindyLinz barrucadu canta pyrtsa elgot opqdonut Chousuke WSergio KaneTW Mandus Edox spaceships mitu brixen elij lvh heyj_ca Atlanis gds Ezku dunj3 gdsx Deewiant)
17:18:50 --- names: list (tomaw fall_ annulus brolin_empey Ulrar hegge oconnore angryzor owa mero)
17:19:58 <madmax88> So I have a function, f x y = sqrt . fromRational $ x + y
17:20:13 <madmax88> and I want to apply that to values like (1/3) but I'm getting an error
17:20:41 <madmax88> it's obviously a type system problem. But, if I do something like sqrt $ fromRational (1/3) that's fine. Why is this happening?
17:21:04 <newsham> > sqrt (1 % 3)
17:21:06 <lambdabot>      No instance for (Integral a0)
17:21:06 <lambdabot>        arising from a use of ‘show_M52628953853746040589067’
17:21:06 <lambdabot>      The type variable ‘a0’ is ambiguous
17:21:40 * hackagebot haddock-library 1.2.0 - Library exposing some functionality of Haddock.  http://hackage.haskell.org/package/haddock-library-1.2.0 (MateuszKowalczyk)
17:21:42 * hackagebot haddock-api 2.16.0 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-api-2.16.0 (MateuszKowalczyk)
17:21:44 * hackagebot haddock 2.16.0 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.16.0 (MateuszKowalczyk)
17:21:46 * hackagebot arion 0.1.0.4 - Watcher and runner for Hspec  http://hackage.haskell.org/package/arion-0.1.0.4 (karun012)
17:21:48 * hackagebot monad-classes 0.3.1.0 - more flexible mtl  http://hackage.haskell.org/package/monad-classes-0.3.1.0 (MatthewFarkasDyck)
17:22:27 <madmax88> does anyone have an idea?
17:22:40 <ReinH> :t sqrt
17:22:41 <lambdabot> Floating a => a -> a
17:23:05 <ReinH> :t fromRational
17:23:06 <lambdabot> Fractional a => Rational -> a
17:24:11 <ReinH> madmax88: what error?
17:24:13 <newsham> > sqrt $ fromRational (1 % 3)
17:24:14 <lambdabot>  0.5773502691896257
17:24:21 <ReinH> madmax88: 1/3 isn't a rational number
17:24:26 <newsham> > fromRational (1%3)
17:24:27 <lambdabot>  0.3333333333333333
17:24:54 <ReinH> so you can't apply it to values like 1/3
17:25:06 <madmax88> ReinH: is it not? That's not very intuitive, considering that 1/3 is (mathematically) rational 
17:25:21 <ReinH> Sure it is
17:25:22 <ReinH> :t (/)
17:25:23 <lambdabot> Fractional a => a -> a -> a
17:25:31 <igniting> :t (1/3)
17:25:32 <lambdabot> Fractional a => a
17:25:32 <newsham> is for division, % is for making ratios
17:25:44 <newsham> > (1/3, 1%3)
17:25:45 <lambdabot>  (0.3333333333333333,1 % 3)
17:26:19 <ReinH> f applies to Rational numbers, not rational numbers
17:26:40 * hackagebot cql 3.0.2 - Cassandra CQL binary protocol.  http://hackage.haskell.org/package/cql-3.0.2 (ToralfWittner)
17:26:49 <dolio> > 1/3 :: Rational
17:26:50 <lambdabot>  1 % 3
17:26:51 <ReinH> rational numbers are a mathematical concept. Rational is data type.
17:27:01 <ReinH> dolio: oh yeah. Huh.
17:27:08 <ReinH> madmax88: what error are you getting?
17:27:10 <madmax88> So what can I do to take a fractional and make it a Floating for sqrt?
17:27:29 <ReinH> madmax88: if you don't want us to guess what the issue is, include the error message
17:27:31 <igniting> > sqrt (1/3)
17:27:33 <lambdabot>  0.5773502691896257
17:28:29 <madmax88> ReinH: I resolved the issue. Thanks for you help though :)
17:34:04 <ProofTechnique> How have I not heard of hsdev before?
17:36:41 * hackagebot GLUtil 0.8.6 - Miscellaneous OpenGL utilities.  http://hackage.haskell.org/package/GLUtil-0.8.6 (AnthonyCowley)
17:41:43 * hackagebot cabal-helper 0.3.0.0 - Simple interface to Cabal's configuration state used by ghc-mod  http://hackage.haskell.org/package/cabal-helper-0.3.0.0 (DanielG)
17:51:49 * hackagebot cql-io 0.13.2 - Cassandra CQL client.  http://hackage.haskell.org/package/cql-io-0.13.2 (ToralfWittner)
18:03:23 <schell> what is the extension to use a type variable in the body of a function?
18:03:35 <hpc> ScopedTypeVariables?
18:03:52 <hpc> it also makes you use forall everywhere to bring a variable into scope
18:04:26 <schell> thanks!
18:05:25 <hpc> i understand the ghc manpage is much better lately, you should give it a perusing
18:06:00 <schell> oh really? i never thought of doing that
18:06:50 * hackagebot jmacro-rpc-happstack 0.3.1 - Happstack backend for jmacro-rpc  http://hackage.haskell.org/package/jmacro-rpc-happstack-0.3.1 (GershomBazerman)
18:07:35 <hpc> schell: you might also like ghc-man-completion too, if you're using bash
18:07:53 <schell> mmm - i use fish
18:08:06 * schell is an oddball
18:08:10 <hpc> heh
18:08:19 <hpc> fish i think already does something similar?
18:08:20 <monochrom> "give a man a fish, and he will have a shell for a day"
18:08:31 <schell> monochrom: lol
18:08:41 <hpc> teach a man to phish and he will have shell for a lifetime
18:08:59 <schell> it does get some flag completion, but i don’t know the rules around it
18:09:15 <hpc> i think it uses the manpage
18:15:11 <mauris> can i make an anonymous element in a record declaration?
18:15:28 <mauris> something like     data OneTwo = OneTwo { one :: Int, _ :: String }
18:15:39 <shachaf> No.
18:16:51 * hackagebot primitive 0.6 - Primitive memory-related operations  http://hackage.haskell.org/package/primitive-0.6 (DanDoel)
18:22:36 <jle`> @tell jellie note quite; but most of the value constructors have normal smart-ish constructor aliases
18:22:37 <lambdabot> Consider it noted.
18:34:44 <sombras> hi
18:37:08 <caconym> sombras: hello!
18:42:17 <sombras> what is this haskell stuff about?
18:42:21 <sombras> a programming language?
18:42:43 <sombras> does it support http?
18:43:16 <porglezomp> It has a library for HTTP
18:44:10 <TallerGhostWalt_> Gonna do some static site generation.  Any interesting tools besides hakyll to check out?
18:46:28 <carter> TallerGhostWalt_: pandoc :)
18:46:44 <sombras> nice
18:46:48 <carter> TallerGhostWalt_: if you wanna something crazy, look at how the diagrams folks generate their  stuff
18:47:03 <carter> sombras: its also for high volume data processing for enterprise
18:47:15 <carter> and generating code for arduions, and generating opengl bindings
18:47:18 <carter> and video games
18:47:20 <carter> and web apps
18:47:32 <sombras> data processing is what i precissely do
18:47:46 <carter> tell us more
18:47:51 <TallerGhostWalt_> carter: I totally want to see!
18:48:02 <monochrom> I use Haskell to write tutorials.
18:48:10 <sombras> i have data processing botnet, so far coded in java
18:48:35 <sombras> but i am looking after improving computing power
18:48:56 <TallerGhostWalt_> daughter wants to build a web site gonna have her use a site gen 
18:49:17 <carter> TallerGhostWalt_: woo
18:49:29 <marchelzo_> Have her use Yesod
18:49:56 <monochrom> TallerGhostWalt_: there is "gitit" on hackage
18:50:26 <marchelzo_> oops, I missed the 'static site generation' bit above
18:50:35 <marchelzo_> ignore the yesod recommendation
18:51:17 <TallerGhostWalt_> monochrom: that looks super great!
18:51:24 <TallerGhostWalt_> monochrom: thanks!
18:51:39 <TallerGhostWalt_> carter: where do I find the diagrams stuff (for me though)
18:51:47 <carter> @google github diagrams
18:51:47 <lambdabot> https://github.com/diagrams
18:51:52 <TallerGhostWalt_> carter: I mean an explanation of what they are doing
18:51:57 <TallerGhostWalt_> on their site 
18:52:18 <sombras> @google botnet beaner
18:52:19 <lambdabot> http://www.hackforums.net/showthread.php?tid=4503991
18:52:25 <carter> https://github.com/diagrams/diagrams-doc
18:52:38 <carter> TallerGhostWalt_:  ask on #diagrams
18:52:55 <TallerGhostWalt_> carter: thx
19:06:54 * hackagebot config-value 0.1.1 - Simple, layout-based value language similar to YAML or JSON  http://hackage.haskell.org/package/config-value-0.1.1 (EricMertens)
19:23:36 <nuser> I wonder how many Haskellers were won over from using Xmonad.
19:26:56 * hackagebot wizards 1.0.2 - High level, generic library for interrogative user interfaces  http://hackage.haskell.org/package/wizards-1.0.2 (LiamOConnorDavis)
19:27:22 <mmmpork> TallerGhostWalt_ yay for working with your daughter to build a website!
19:33:39 <hodapp> "type StackTop a = Stream a" ...siiigh, what is this type synonym helping with?
19:34:08 <hodapp> they appear to write these type synonyms only for the sake of having the type signature have different names for what is the same type
19:34:21 <Fuuzetsu> you answered your own question
19:34:48 <hodapp> it seems to me that all it does is make the type signature more confusing, since all this is hidden from the outside
19:35:38 <c_wraith> hodapp: type String = [Char] ; type Filepath = String
19:35:47 <c_wraith> hodapp: base blesses the technique!
19:35:52 <Fuuzetsu> c_wraith: confusing!
19:36:46 <Fuuzetsu> also hm wasn't it FilePath
19:36:49 <Fuuzetsu> no, that doesn't look right
19:37:03 <Fuuzetsu> I think I had a dream last night where I made this mistake 
19:41:02 <TallerGhostWalt_> erikd: did arm64 make it for 7.10?
19:45:19 <hodapp> c_wraith: http://hackage.haskell.org/package/copilot-libraries-2.1.1/docs/Copilot-Library-Stacks.html is what I mean. It does not export PopSignal, PushSignal, PushStream, or StackTop.
19:46:18 <hodapp> c_wraith: what can you tell me about any of those types, without looking at the source code?
19:46:49 <c_wraith> hodapp: I didn't say it was a good design.  In fact, I think String and Filepath should be different types from each other and from [Char]
19:47:44 <nitrix> String and [Char] would be inconvenient, but I'm pedant enough that I'd probably enjoy it.
19:48:24 <c_wraith> I dunno.  I think the string hack in Show is evidence that String = [Char] causes as many problems as anything.
19:48:53 <nitrix> Whats the hack>
19:48:55 <nitrix> ?*
19:48:55 <lambdabot> Maybe you meant: v @ ? .
19:49:01 <c_wraith> it's showList
19:49:29 <hodapp> as far as I can tell, in the case I linked, they just made ad-hoc opaque type synonyms for the sake of just two functions
19:49:46 <nitrix> c_wraith: Lol, and how does showList work then?
19:49:56 <glguy> much better to not use type synonyms and to put haddock comments on the arguments
19:49:57 <nitrix> c_wraith: Chicken and eggs :/
19:49:58 <c_wraith> It exists solely to make it possible for the Show instance for String to be different from the Show instance for every other list while still obeying the Haskell 98 type class rules
19:49:59 <hodapp> and the only way to use them is to guess at the correct underlying types
19:50:18 <hodapp> glguy: has Haddock a specific way to note arguments?
19:50:26 <hodapp> glguy: I may just write proper docs and do a pull request
19:50:35 <c_wraith> It would have been much better to accept that String is not a list of anything, so as to not need the showList hack
19:50:56 <glguy> hodapp: Yes; http://hackage.haskell.org/package/config-value-0.1.1/docs/Config.html#v:parse
19:51:07 <glguy> See parse for the first example I can think of
19:51:34 <hodapp> glguy: ooh, thanks!
19:52:59 <shachaf> FilePath is a problem because file paths on e.g. Windows and Linux are incompatible.
19:53:09 <shachaf> (And both are incompatible with String.)
19:53:55 * Maxdamantus wonders how useful it actually is having String be a sequence of assumed unicode codepoints.
19:57:11 <Maxdamantus> operations like reverse still don't make any sense.
19:59:19 <Maxdamantus> > reverse "höylä"
19:59:20 <lambdabot>  "\776aly\246h"
19:59:47 <carter> is anyone else having trouble getting cabal update to ACTUALLY update right now?
20:00:11 <carter> ttuegel: how would i debug cabal update acting up?
20:00:46 <carter> cabal update -v3 right?
20:01:58 * hackagebot vector 0.10.12.3 - Efficient Arrays  http://hackage.haskell.org/package/vector-0.10.12.3 (DanDoel)
20:05:50 <__ryan> hello what does this error means? user error (Postgresql.withStmt': bad result status FatalError (("PGRES_FATAL_ERROR","ERROR:  syntax error at or near \"usa\"\nLINE 1: ..., \"news\".\"updated_on\" FROM news WHERE url LIKE '%'usa/indust...\n                                                             ^\n")))
20:07:02 <ttuegel> carter: https://github.com/haskell/cabal/issues/2499 ?
20:10:59 <om-foxy> I just installed ghc 7.10.1 and did `cabal update`.  When trying to run `cabal install cabal-install` I get lots of error messages about package databases and needing to `ghc init`.  I stuck at that point.
20:12:20 <derekv> if cabal warns me i probably should not upgrade "core libraries", which libraries are these?  just base?
20:21:04 <__ryan> hi how do i convert text to string?
20:22:27 <jle`> __ryan: `unpack`
20:22:45 <__ryan>  unpack Text?
20:22:53 <jle`> @hoogle Text -> String
20:22:53 <lambdabot> Data.Text.Internal.Lazy showStructure :: Text -> String
20:22:53 <lambdabot> Data.Text.Internal showText :: Text -> String
20:22:53 <lambdabot> Data.Text unpack :: Text -> String
20:22:55 <__ryan> jle`: unpack Text?
20:22:58 <jle`> ^ the third one
20:23:14 <__ryan>  Data.Text unpack :: Text -> String
20:23:34 <jle`> yes, the `unpack` function from the Data.Text module
20:24:22 <__ryan> it gives me this erro Couldn't match type [] with ‘HandlerT App IO’
20:24:22 <__ryan> Expected type: HandlerT App IO Char
20:24:22 <__ryan>   Actual type: String …
20:24:42 <__ryan> url <-  unpack newsUrl here's the code
20:24:58 <dmj`> what is the type of newUrl ?
20:25:08 <dmj`> s/newUrl/newsUrl
20:25:12 <__ryan> Text
20:25:22 <dmj`> <- is (>>=)
20:25:27 <dmj`> let url = unpack newsUrl
20:25:50 <__ryan> Thank you is works :)
20:26:15 <om-foxy> I did `ghc-pkg init /usr/local/ghc/packages` and then `ghc -package-db /usr/local/ghc/packages/package.cache` and I still get `hc: ghc no longer supports single-file style package databases (/usr/local/lib/ghc-7.10.1/packages/package.cache) use 'ghc-pkg init' to create the database with the correct format.`
20:28:42 <__ryan> hi another question - what does this mean? user error (Postgresql.withStmt': bad result status FatalError (("PGRES_FATAL_ERROR","ERROR:  syntax error at or near \"oregon\"\nLINE 1: ..., \"news\".\"updated_on\" FROM news WHERE url LIKE '%'oregon-the...\n                                                             ^\n")))
20:32:08 <dmj`> __ryan: it seems you have some sql that postgres doesn't like
20:33:40 <__ryan> dmj`: yes but how do i do that i have a rawSQL code SELECT * FROM news WHERE url LIKE '%?%'. Is this wrong?
20:38:02 <dmj`> __ryan: have you tried the query using the postgres cli  
20:38:36 <__ryan> dmj`: the selectList?
20:41:05 <dmj`> __ryan: try to isolate the problem, try running your sql query on postgres directly with psql
20:42:38 <__ryan> dmj`: it runs properly in my postgresql but in rawSql it's not
20:43:51 <derekv> what's this old-locale package... 
20:44:14 <glguy> What about it?
20:44:22 <derekv> giving me a "Couldn't match expected type" 
20:44:38 <derekv> I'm trying to update hakyll with cabal
20:44:50 <derekv> maybe i should just remove everything and reinstall fresh
20:44:56 <glguy> Time-1.5 stopped using old-locale for locales
20:46:00 <derekv> yea... maybe some dependencies are still using it, some aren't, and its blowing up.
20:46:01 <glguy> If you're trying to build a package that doesn't have proper upper bounds it might be using a version of time it isn't compatible with
20:46:39 <dmj`> __ryan: you should paste your code
20:46:44 <glguy> It's going to be a while before everyone has updated for the new GHC release
20:46:46 <dmj`> __ryan: using lpaste.net
20:47:41 <__ryan> dmj`: i used the Persistent Code :-) and it works
20:47:46 <derekv> mine error -> http://lpaste.net/129771
20:48:59 <glguy> https://github.com/glguy/irc-core/blob/master/src/Irc/Time.hs
20:49:30 <glguy> Derekv: that's what I did today to support new time-1.5
20:49:36 <derekv> i see
20:51:21 <jcabmin> What's the best way for an experienced programmer to learn haskell? Learn You a Haskell for Great Good?
20:51:30 <arkeet> @where learnhaskell
20:51:30 <lambdabot> https://github.com/bitemyapp/learnhaskell
20:52:06 <monochrom> see https://github.com/bitemyapp/learnhaskell for a good route to learn haskell
20:52:22 <monochrom> err, I'm being redundant!
20:53:33 <derekv> glguy, does this look wrong? https://github.com/dougransom/hakyll/blob/master/hakyll.cabal 
20:53:39 <jcabmin> Thank you arkeet and monochrom!
20:58:12 <arkeet> it's nice that we have a single document that we can point people to. :)
20:59:02 <glguy> derekv: It looks like the git version isn't the same as the cabal one
20:59:04 <glguy> err, hackage one
20:59:20 <derekv> yea, that could be
20:59:27 <glguy> But the code on hackage just appears to be wrong
20:59:40 <glguy> has a time < 1.6 constraint but uses System.Locale's defaultTimeLocale
20:59:47 <derekv> ahh 
21:00:10 <derekv> ok so, maybe it isn't my system?  I was pretty sure i just got my ghc packages all borked up
21:00:43 <derekv> i have several broken once according to ghc-pkg check
21:01:12 <glguy> It looked wrong for me when I did a cabal get hakyll
21:01:39 <glguy> Unless you're interested in finding bugs and fixing them specifically it might be a little too early to be switching to GHC 7.10
21:03:17 <derekv> I have version 7.8.3
21:03:34 <glguy> You're getting those errors with 7.8.3?
21:04:28 <derekv> yea, well basically I sat down and rand cabal install cabal-install
21:04:36 <glguy> If that's the case then just unregister time-1.5 and require your package to use time-1.4.2
21:05:14 <glguy> ghc-pkg unregister time-1.5
21:05:26 <glguy> then you should see that you only have one version installed with: ghc-pkg list time
21:05:44 <glguy> you can install things with cabal install --constraint=time\ installed   at that point
21:05:56 <derekv> oh i've got two versions
21:06:23 <derekv> ones under usr/local/Cellar, the other under my .ghc
21:06:40 <glguy> time is one of the package you don't want to upgrade because it comes with GHC. 
21:06:49 <derekv> ok =]
21:07:15 <derekv> heh, I was asking earlier ... cabal warned me against upgrading "core packages" but I had no luck figuring out what that meant
21:08:07 <derekv> ok now everything is broken 
21:08:23 <derekv> not a big deal i just need to figure out how to start over i think
21:08:32 <glguy> Did you force unregister it?
21:08:33 <derekv> maybe just blow away ~/.ghc ?
21:08:34 <derekv> yea
21:08:37 <glguy> oops
21:08:59 <lolisa> Guys, can you get on github? Chinese can't now, is it blocked by china gov or DDOSed?
21:09:06 <arkeet> github working fine here.
21:09:22 <lolisa> Thx.
21:09:40 <glguy> lolisa: There was a story about Biado or whatever that site is made a mistake and is DoS'ing github
21:09:58 <arkeet> baidu?
21:10:07 <glguy> sounds right
21:10:14 <lolisa> baidu.
21:10:38 <glguy> derekv: generally you shouldn't be force unregistering or force reinstalling things
21:10:54 <glguy> derekv: you'll need to unregister the things that depended on the thing you wanted to unregister
21:11:05 <lolisa> Well baidu has no business with github. The only having business in china with the ability to stop us from visting is the gov gfw.
21:11:05 <derekv> i can just reinstall everything
21:11:18 <glguy> For some reason there isn't a recursive unregister so I have a tool to help me with that: https://github.com/glguy/GhcPkgUtils
21:11:23 <derekv> its not like i was doing something important on this machine
21:11:28 <narendraj9> go #fp
21:11:43 <glguy> lolisa: Baidu added some kind of call to javascript on github that gets run in a loop
21:11:54 <jokester> I thought github was blocked in China since years ago
21:12:03 <lolisa> No, fine until today.
21:12:21 <glguy> lolisa: Just google for baidu and github , it happened today, you can read about it in the tech news
21:13:13 <lolisa> Maybe, but every programmer in china is blaming the gov for this act... BTW google is blocked long ago so baidu can win the search engine war and plant disgusting ads everywhere
21:15:08 <Javran> hmm
21:15:42 <jokester> poor guys
21:15:48 <derekv> mv ~/.ghc ~/.ghc_back 
21:21:09 <Javran> is there some extension to allow implementing instances "backwards", e.g. I know how to implement Ord, so we just do "a == b = compare a b == EQ" for Eq
21:21:47 <shachaf> No extension needed.
21:22:26 <shachaf> You can just write "instance Eq T where a == b = compare a b == EQ; instance ord T where ..."
21:23:33 <Javran> ah yes
21:25:54 <Javran> instances are always imported and there's no way to hide them right?
21:29:40 <arkeet> Javran: right.
21:30:29 <Javran> arkeet: I see, thanks
21:39:52 <erikd> TallerGhostWalt_: yes, i think it did, but i haven't tested it yet.
21:42:04 * hackagebot arithmoi 0.4.1.2 - Efficient basic number-theoretic functions.  Primes, powers, integer logarithms.  http://hackage.haskell.org/package/arithmoi-0.4.1.2 (CarterSchonwald)
21:45:41 <dmj`> glguy: ping
21:59:16 <solatis> hmmm i just upgraded to ghc 7.10.1 .. if i want to recompile *everything* i installed before, what would be the preferred way ?
21:59:40 <solatis> delete my .ghc and .cabal directories and install manually ?
22:00:46 <glguy> The package database for each version of GHC is separate, so you don't need to uninstall anything and you'll have to reinstall everything
22:01:01 <solatis> ah ok
22:01:14 <solatis> but does that also include dependencies?
22:01:37 <tgeeky> solatis: each package database has its own collection of deps
22:01:49 <solatis> hmm
22:02:14 <solatis> i upgraded to 7.10, but when i do a 'cabal install yesod-bin' right now, it only rebuilds yesod-bin, not its dependencies
22:02:50 <tgeeky> solatis: is that incorrect behavior? and which cabal are you using?
22:03:17 <solatis> well i'm not sure, i just want to rebuild everything agains the latest ghc
22:03:27 <solatis> 1.20
22:03:45 <tgeeky> solatis: i mean, what is the output of `which cabal` 
22:04:09 <solatis> i'm using the one that comes with minghc under windows
22:05:05 <solatis> i think im just going to empty my .ghc and .cabal directories and start from scratch, seems like the easiest way to know for sure
22:05:29 <tgeeky> solatis: that sounds like what i would do, but I hope that isn't what is necessary :o
22:07:06 * hackagebot aivika 4.0 - A multi-paradigm simulation library  http://hackage.haskell.org/package/aivika-4.0 (DavidSorokin)
22:08:36 <kadoban> solatis: You should really set up a cabal config, because some of the defaults aren't good … in which case, wiping out .cabal/ isn't good, since that's where your config lives.
22:09:55 <solatis> kadoban, i'm ahead of you :)
22:10:01 <kadoban> :)
22:10:22 <solatis> *always* enable library profiling on a dev machine :)
22:10:25 * niko-is-GAY 4IM GAY !! FUCK MY ASS NOW !!!
22:10:26 * niko-is-GAY 4IM GAY !! FUCK MY ASS NOW !!!
22:10:26 * niko-is-GAY 4IM GAY !! FUCK MY ASS NOW !!!
22:11:02 <tgeeky> lol, k-lined
22:30:55 <pharaun> :|
23:22:11 * hackagebot attoparsec 0.12.1.4 - Fast combinator parsing for bytestrings and text  http://hackage.haskell.org/package/attoparsec-0.12.1.4 (BryanOSullivan)
23:23:25 <f-a> I cabal install my packages with `documentation: True`
23:23:39 <f-a> some of the documentation doesn't end in ~/.cabal/share/doc/index.html
23:25:31 <Total_1mmersion> @djinn a -> a
23:25:31 <lambdabot> f a = a
23:25:37 <Total_1mmersion> @djinn IO ()
23:25:37 <lambdabot> Error: Undefined type IO
23:25:52 <f-a> sorry I got disconnected
23:26:10 <f-a> I was saying: I expect to find my documentation in the doc index, which is found at ~/.cabal/share/doc/index.html
23:26:32 <f-a> but I recently installed packaged (e.g. regex-tdfa) and I don't find the module there
23:28:02 <breadmonster> Hey guys.
23:28:08 <breadmonster> I had an idea for a GHC extension.
23:28:30 <breadmonster> Monad is a specialization of Applicative, for instance.
23:29:47 <EvanR> breadmonster: somebody came up with that one already
23:30:01 <breadmonster> so in the definition, can't we extend it to something like `class Applicative a => Monad a where ... implementing Applicative where ...`
23:30:18 <breadmonster> EvanR: To automatically instantiate more general classes?
23:30:27 <EvanR> oh
23:30:52 <breadmonster> Yeah, you could do this for a lot of types.
23:31:10 <breadmonster> Ord and Eq, Functor and Applicative and so on.
23:31:16 <EvanR> wouldnt the compiler have to know and understand the relevant laws of the super class
23:31:38 <breadmonster> EvanR: Yeah.
23:32:06 <breadmonster> Except the superclass is already defined.
23:32:09 <EvanR> well, theres already deriving support for Ord, Eq, Functor, Foldable, Traversable
23:32:23 <breadmonster> Yeah, but that's default behavior.
23:32:24 <EvanR> and some others
23:32:51 <EvanR> so programmable deriving
23:33:03 <breadmonster> EvanR: Yup.
23:33:24 <breadmonster> The other thing is that ideally GHC would have some knowledge about type hierarchies.
23:33:31 <breadmonster> Shit, I wish I had this idea before the GSoC deadline.
23:34:07 <dgorbik_> is (*) a b = a >>= \f -> b >>= x -> return (f x) ?
23:34:24 <breadmonster> EvanR: Do you think it can be done?
23:35:55 <jle`> dgorbik_: that's a definition for `ap`/(<*>) given in terms of Monad
23:36:06 <dgorbik_> same for fmap f = \a -> a >>= return f a
23:36:20 <dgorbik_> why can't Functor and Applicative be derived from just Monad definition?
23:36:27 <dgorbik_> (or can it?)
23:36:29 <dgorbik_> automatically
23:36:30 <jle`> not all Functors and Applicatives are Monads
23:36:53 <EvanR> there could be a default instance for superclasses
23:36:54 <jle`> also, sometimes you'll want to give a more performant definition
23:36:59 <EvanR> i think there was a proposal for that
23:37:50 <breadmonster> jle`: Sure, but if you don't, I don't see why not.
23:38:06 <breadmonster> Also, I'd expect ghc to be able to do some fusion on the definitions and all that.
23:38:27 <Total_1mmersion> breadmonster, https://wiki.haskell.org/Functor-Applicative-Monad_Proposal
23:38:31 <EvanR> breadmonster: https://ghc.haskell.org/trac/ghc/wiki/DefaultSuperclassInstances
23:39:24 <breadmonster> Total_1mmersion: Not talking about that.
23:39:36 <breadmonster> EvanR: Okay, yeah, that's pretty much what I wanted to do.
23:40:07 <dgorbik_> yeah, looks great
23:42:54 <breadmonster> EvanR: Can I hack on it?
23:43:18 <EvanR> i give you my blessing, like that means a damn
23:43:45 <EvanR> in 4 seconds i googling i couldnt find any discussion on the topic, like why it doesnt already exist
23:57:13 * hackagebot arion 0.1.0.5 - Watcher and runner for Hspec  http://hackage.haskell.org/package/arion-0.1.0.5 (karun012)
23:57:25 <safinaskar> breadmonster: "Monad is a specialization of Applicative, for instance" will be implemented in the next ghc version. www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
23:57:50 <breadmonster> safinaskar: I'm not talking about that.
