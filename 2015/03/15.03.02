00:34:10 <bobajett> to filter vowels I can write: filter (`elem` "aeiou") ["superman"] -- uea, how do I reverse the filter clause select non-vowels??
00:34:55 <EvanR> :t not
00:34:56 <lambdabot> Bool -> Bool
00:35:01 <tdammers> ^ that
00:35:11 <EvanR> :t not . (`elem` "aeiou")
00:35:12 <lambdabot> Char -> Bool
00:35:12 <tdammers> (not . (`elem` vowels))
00:35:13 <adamse> or notElem
00:35:30 <tdammers> caveat: this will also select characters that aren't letter at all
00:35:46 <tdammers> *letters
00:36:23 <tdammers> (and for ultimate readability, I'd factor out isVowel into a separate function)
00:36:38 <EvanR> :t isAlpha
00:36:39 <lambdabot> Char -> Bool
00:37:14 <tdammers> let vowels = "aeiou", isVowel = (`elem` vowel) in filter (not . isVowel) "superman"
00:37:16 <tdammers> > let vowels = "aeiou", isVowel = (`elem` vowel) in filter (not . isVowel) "superman"
00:37:18 <lambdabot>  <hint>:1:21: parse error on input ‘,’
00:37:43 <tdammers> > let vowels = "aeiou"; isVowel = (`elem` vowel) in filter (not . isVowel) "superman"
00:37:44 <lambdabot>  Not in scope: ‘vowel’
00:37:44 <lambdabot>  Perhaps you meant ‘vowels’ (line 1)
00:37:53 <tdammers> boy do I need more coffee
00:38:00 <tdammers> > let vowels = "aeiou"; isVowel = (`elem` vowels) in filter (not . isVowel) "superman"
00:38:01 <lambdabot>  "sprmn"
00:38:32 <bobajett> thanks guys! I was a bit confused about how to to compose not and `elem` in the filter clause.
00:40:32 <EvanR> how to compose not with something: not .
00:40:56 <EvanR> give or take parens
00:41:14 <nyuszika7h> bobajett: or use notElem
00:43:35 <bobajett> EvanR: thanks, my noobie issue was not knowing how arguments are processed in the (not . `elem` ["blah"]) pipeline
00:44:12 <EvanR> that wont work
00:44:25 <bobajett> as I found out :-)
01:02:26 <frerich> bobajett: There's even a shortcut: "notElem", i.e. you could use "filter (`notElem` vowels) "superman""
01:02:43 <frerich> Oh, and now I see that nyuszika7h wrote this already, oops.
01:13:31 <Arahael> Well, so after a while using literate haskell, I've gone back to 'regular' haskell.
01:13:59 <EvanR> wb
01:14:23 <Arahael> EvanR: Thank you.  I was lost, but didn't realise it.
01:15:16 <Arahael> I'm also feeling that "go" notation made it more difficult for me to learn how to use the monads and IO than it should have.
01:15:28 <Arahael> "do" notation, rather.
01:16:02 <Arahael> Because it implies doing something "within" that monad, when really, that whole sequence of steps could arguably involve several monads.
01:16:59 <EvanR> it could certainly involve different types
01:17:30 <EvanR> but in a chain of >>= all the `m's have to be the same
01:20:12 <Arahael> EvanR: I was getting a bit lost with trying to work out what that type should be, until I just stoped assuming that they were the same.
01:37:50 <nyuszika7h> frerich: don't worry, somebody said that even before me :P
01:40:17 * hackagebot template-haskell-util 0.1.1.0 - Some utilities for template Haskell.  http://hackage.haskell.org/package/template-haskell-util-0.1.1.0 (songzh)
01:44:14 <acetoline> anyone know how hakaru works?
01:45:17 * hackagebot http-client 0.4.7.2 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.7.2 (MichaelSnoyman)
01:54:06 <kqr> do you have to give evalState and friends an initial state, if the first thing they do is create their own sate?
01:54:17 <kqr> I guess the answer is yes now that I think about it... never mind!
01:55:20 <quchen2> evalState doesn't create its own type.
01:55:27 <quchen2> State, I mean.
02:02:21 <jle`> kqr: if you are talking about something like `put x >> blah`, then yes
02:02:32 <jle`> you could pass in `undefined` though ;)
02:03:13 <jle`> it's an awkward solution in the case where the first thing it does is make a state from scratch and ignores the input, and also you don't have a sensible "default"
02:03:22 <quchen2> IORefs and unsafePerformIO are cleaner in that case though. They show much more clearly that something awful is going on than a hidden "undefined".
02:03:54 <quchen2> In other words, don't do that :-P
02:03:57 <jle`> yeah it's definitely not a good thing to do
02:04:00 <jle`> heh heh
02:04:15 <aawe> kqr: The problem is, how would haskell know what a "default state" or "empty state" looks like? It could be done with monoid (mempty) though
02:04:33 <jle`> > runState (put 1 *> get) undefined
02:04:35 <lambdabot>  (1,1)
02:05:14 <jle`> honestly i sometimes there really isn't a much better solution if the only algorithm you had to make any sensible "initial state" was exactly the State algorithm itself
02:05:59 <jle`> so the meaningful thing here to do is to pull out the algorithm that calculuates the initial state "from scratch" as pure code
02:06:16 <jle`> i don't know of a case where that is not possible
02:07:21 <jle`> an (s -> (a, s)) that ignores the initial state is just an (a, s)
02:13:29 <quchen2> I don't think there is a case where this is not possible.
02:14:25 <jle`> maybe if you only get the algorithm to get the initial state as an opaque State s a
02:14:30 <jle`> er, State s ()
02:15:05 <quchen2> That's not an initial state.
02:15:19 <quchen2> It's a "state s" like "IO a" is an "a".
02:15:55 <quchen2> You get a recipe, and to cook it you have to put in ingredients or do (black) magic.
02:21:39 <kqr> yup, I arrived at pretty much the same conclusions you did
02:21:41 <kqr> thanks, though :)
02:22:50 <aawe> \s -> evalState s mempty :: Monoid s => State s a -> a
02:23:14 <jle`> quchen2: i mean, you get a library function that puts a value into the state, but ignores the initial state.  for some reason
02:23:29 <jle`> and you use it to chain from the rest, weirdLibraryFunction *> doMyNormalstuff
02:23:41 <jle`> just thinking of contrived reasons why it wouldn't be possible, heh
02:24:46 <quchen2> jle`: That's a stupid library. "State s ()" is "Endo s" is "s -> s", and a library that gives me an "s -> s" with the promise that there's a "const" in there somewhere is not something you do in Haskell.
02:26:23 <merijn> Semi off-topic
02:26:44 <merijn> I remember a paper titled roughly "How to trust a theorem prover" but I don't recall the exact title, so I can't find it
02:26:53 <merijn> Anyone know which one I'm talking about?
02:27:04 <Fylwind> is there some sort of equivalent of 'extra-source-files' for test-suite?
02:27:18 <Fylwind> (this about Cabal)
02:28:07 <Fylwind> hm, I guess it works at the root level but not for test-suite specifically
02:28:12 <merijn> Fylwind: Have you checked the cabal user guide? It should list all the files
02:28:31 <Fylwind> merijn: I know what it does, I was curious why it isn't allowed for test-suite
02:30:09 <merijn> I think it's only allowed at the top level anyway
02:30:46 <Fylwind> merijn: oh I misread the docs, thought it was available for executables
02:34:15 <Fylwind> ugh, why does cabal have to be so restrictive about wildcards in extra-source-files ...
02:35:24 <Fylwind> I want to include all the test-related files for the 'directory' package but it has all sorts of funny files like 'stdout-x86_64-unknown-openbsd'
02:35:37 <Fylwind> so now I have to write all of those in by hand
02:38:34 <bernalex> ocharles_: s/Explioting/Exploiting/ https://ocharles.org.uk/IdiomBrackets.html
02:39:26 <bernalex> ocharles_: s/:?/:/ as well.
02:41:22 <bernalex> ocharles_: worldCamera example is great fwiw.
02:42:18 <bernalex> ocharles_: also -- thanks for doing this work on idiom brackets. I'm not a huge fan of them, but I really appreciate someone doing the work to flesh them out in haskell. cheers!
02:50:20 * hackagebot bytestring-read 0.1.0 - fast ByteString to Double converting library  http://hackage.haskell.org/package/bytestring-read-0.1.0 (HirotomoMoriwaki)
02:58:21 <kqr> if I intend to apply a function to the first or second part of a tuple, would it make more sense to use Control.Arrow.first or Data.Bifunctor.first?
02:59:25 <quchen2> As long as you're monomorphic it doesn't really matter. I prefer Bifunctor because you're abstracting over the container, and not the function arrow.
03:00:31 <kqr> intuitively, I also like bifunctor better. I've also heard someone call Control.Arrow "a mistake", which makes me feel queasy to use it even though I know I've probably just misunderstood something
03:01:56 <merijn> kqr: Well, there's two reasons why Arrow is "a mistake"
03:02:06 <merijn> kqr: 1 it turns out to basically be Applicative + Category
03:02:43 <merijn> kqr: 2 the requirement of "arr :: Arrow a => (b -> c) -> a b c" to lift ANY function into an Arrow means it's hard to implement nice arrows that control effects
03:02:51 <merijn> Since anyone can lift arbitrary functions into them
03:06:38 <aawe> rusti: let f = (\x -> case x of "a" -> True; _ -> False) :: ByteString -> Bool -- I thought XOverloadedStrings would allow me to do this?
03:06:58 <aawe> oops wrong bot
03:07:19 <aawe> > let f = (\x -> case x of "a" -> True; _ -> False) :: ByteString -> Bool -- I thought XOverloadedStrings would allow me to do this?
03:07:21 <lambdabot>  not an expression: ‘let f = (\x -> case x of "a" -> True; _ -> False) :: Byt...
03:07:50 <aawe> oh well. Error is "No instance for (Data.String.IsString ByteString) arising from the literal "a" "
03:08:08 <basedsiren> i spilled coffee on my copy of LYAH, what should i do?
03:08:58 <tdammers> make more coffee
03:09:06 <mauke> aawe: that error means it does allow you to do this
03:09:14 <basedsiren> i dont drink coffee anymore
03:09:24 <mauke> aawe: otherwise it would be talking about String or [Char], not IsString instances
03:09:31 <basedsiren> last time i did i destroyed 10 books and a laptop
03:09:40 <mauke> aawe: also, you're probably missing an 'import'
03:09:55 <aawe> mauke: which import? I have Data.ByteString
03:10:06 <mauke> aawe: wherever the IsString ByteString instance is defined
03:10:12 <mauke> probably Data.ByteString.Char8
03:10:33 <aawe> mauke: ooooh. thanks
03:10:38 <mauke> > "" :: BS.ByteString
03:10:39 <lambdabot>  Couldn't match expected type ‘Data.ByteString.Internal.ByteString’
03:10:39 <lambdabot>              with actual type ‘[GHC.Types.Char]’
03:10:45 <mauke> ^ error without OverloadedStrings
03:38:06 <jle`> what's the normal difference list library?
03:39:01 <alpounet> @hackage dlist
03:39:01 <lambdabot> http://hackage.haskell.org/package/dlist
03:39:56 <jle`> that's the accepted one?
03:39:57 <jle`> thanks :)
03:40:21 <bergmark> it's the only one i've heard of at least :P
03:40:28 <jle`> is this type basically Endo, with some convenience functions?
03:40:41 <jle`> for converting two and from lists?
03:41:12 <jle`> using a monoid for a Writer and am just thinking about tell $ Endo (x:)
03:41:18 <alpounet> yeah, this is the "main" one
03:41:19 <alpounet> jle`: that's basically Endo [a] yeah
03:41:19 <alpounet> http://packdeps.haskellers.com/reverse/dlist <- reverse dependencies
03:41:27 <jle`> thanks :)
03:41:50 <jle`> maybe if all i'm ever doing is appending single elements then Endo is ok
03:42:18 <merijn> You can also just manually do the dlist
03:42:22 <alpounet> a dlist is so simple that you can roll your own impl quite easily
03:42:41 <merijn> > (1:) . (2:) . (3:) $ [] -- whoo
03:42:43 <lambdabot>  [1,2,3]
03:43:04 <jle`> just needed something that played well with Writer heh
03:43:10 <jle`> so i guess that's good enough :)
03:43:57 <jle`> > flip appEndo [] $ mconcat [Endo (1:), Endo (2:), Endo (3:)]
03:43:59 <lambdabot>  [1,2,3]
03:44:26 <jle`> still like that appEndo is one of the best names in base
03:44:30 <jle`> presto appEndo
03:44:52 <Iceland_jack> App /your/ endo
03:45:03 * Iceland_jack regrets saying that
03:45:09 <jle`> :'(
03:45:15 <Iceland_jack> :-)
03:46:06 <nodnormal> hi, i have a function which has do x <- [1..w], y <- [1..h] let point = mapTo x y; return $ f point. so i want to gather all the return values of f in a list but don't know how, what i did is apparantly not allowed
03:46:40 <dramforever> nodnormal: you are confusing do and list compherehensions
03:46:44 <dramforever> ouch, spelling...
03:46:53 <dramforever> comprehension
03:47:19 <nodnormal> dramforever: nm the , and ; those are just to show different statements
03:47:26 <nodnormal> if thats what you mean?
03:47:32 <dramforever> oh
03:47:36 <mauke> nodnormal: what's the type of f?
03:47:44 <dramforever> can you paste it to http://lpaste.net/new/haskell?
03:47:47 <dramforever> code + error
03:47:59 <dramforever> your code is basically context-less
03:48:07 <nodnormal> [Word8]
03:48:17 <nodnormal> dramforever: ill try
03:48:20 <mauke> nodnormal: and you want the whole thing to return [Word8]?
03:48:32 <nodnormal> [[Word8]]
03:48:46 <nodnormal> but yeah  maybe concat that
03:48:49 <mauke> ok, then the code is right
03:48:58 <nodnormal> hmm ill try and paste
03:49:22 <dramforever> nodnormal: there's a menu box on the right of the one with "Haskell" in it
03:49:37 <dramforever> select #haskell there (don't need to correct if you haven't)
03:50:03 <dramforever> then we'll be notified automagically
03:50:22 * hackagebot doctest 0.9.13 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.9.13 (SoenkeHahn)
03:50:53 <Grisha> hi everyone
03:51:14 <Grisha> is there anything to be thought of when using conditionals on lazy infinite lists?
03:51:27 <dramforever> what do you mean by conditionals?
03:51:47 <dramforever> of course, don't use the ones that traverse the whole list
03:51:52 <Grisha> seems that introducing an ``if'' condition in a function that is used to map an infinite lists leads to strange things
03:52:06 <Grisha> I go element by element
03:52:09 <lpaste> nodnormal pasted “list problem” at http://lpaste.net/121438
03:52:20 <nodnormal> there it is
03:52:27 <nodnormal> crap forgot errr
03:52:29 <nodnormal> error
03:52:30 <merijn> Grisha: Lpaste the code + the description of what's strange
03:52:55 <nodnormal> No instance for (GHC.Classes.Ord (Data.Complex.Complex GHC.Types.Double)) arising from a use of `Fractal.mandelSet'Possible fix: add an instance declaration for (GHC.Classes.Ord (Data.Complex.Complex GHC.Types.Double))In the first argument of `GHC.Base.return', namely `(Fractal.mandelSet point)'In a stmt of a 'do'
03:53:09 <dramforever> nodnormal: complex numbers can't be compared
03:53:28 <dramforever> that's how math works
03:53:43 <mauke> nodnormal: that file doesn't even contain "return"
03:53:46 <nodnormal> dramforever: hmm wait i just noticed its not all the code
03:53:47 <merijn> nodnormal: Complex numbers aren't orderable
03:54:01 <mauke> you basically pasted a screenshot
03:54:02 <dramforever> in line 43, I guess "it > 1000" is causing it
03:54:19 <dramforever> mauke: or is it a web ide with unicode stuff?
03:54:28 <mauke> it's vim
03:54:36 <dramforever> whoa
03:54:37 <mauke> with line numbers turned on
03:54:44 <merijn> nodnormal: Line 38 is the problem
03:55:02 <merijn> nodnormal: You specify "(Ord (Complex a)" as constraint, but that makes no sense, since no type satisfies that constraint
03:55:15 <lpaste> nodnormal pasted “list problem” at http://lpaste.net/121439
03:55:16 <merijn> Which, as dramforever points out you probably added to make line 43 typecheck
03:55:35 <mauke> nodnormal: dude, stop
03:55:39 <dramforever> what does it > 1000 do?
03:55:44 <nodnormal> merjin, ah, it was automatic type inserter
03:55:49 <dramforever> mauke: wait a sec
03:56:00 <dramforever> nodnormal: what editor are you using??
03:56:05 <nodnormal> dramforever: check how many iterations
03:56:12 <mauke> nodnormal: that still contains line numbers (except for some of them?), and an outline buffer
03:56:16 <nodnormal> dram vim with vim haskell now
03:56:26 <dramforever> okay get it
03:56:44 <merijn> dramforever: Actually, it's line 42
03:56:48 <mauke> this makes it impossible to actually run that code
03:56:55 <merijn> The abs of z
03:56:57 <mauke> or meaningfully copy/paste parts of it
03:57:01 <dramforever> exactly! yes!
03:57:08 <dramforever> nodnormal: here:
03:57:23 <dramforever> :t abs (2 :: Complex Double)
03:57:24 <lambdabot> Complex Double
03:57:24 <nodnormal> mauke, yes im aware, was just wondering about the list issue
03:57:32 <mauke> nodnormal: what list issue?
03:57:40 <dramforever> nodnormal: I think you did not read that error message
03:57:44 <dramforever> because it's scary
03:57:57 <nodnormal> mauke how to gather up all the return values in mandelSet in a  list
03:58:05 <mauke> nodnormal: that's not the issue
03:58:07 <nodnormal> dd
03:58:09 <jameseb> > map (\ x -> if even x then x `div` 2 else x) [1..] -- Grisha: is that what you mean by conditionals on infinite lists?
03:58:10 <lambdabot>  [1,1,3,2,5,3,7,4,9,5,11,6,13,7,15,8,17,9,19,10,21,11,23,12,25,13,27,14,29,15...
03:58:12 <mauke> I don't know why you think it is
03:58:18 <nodnormal> dramforever: i just didnt understand it
03:58:18 <merijn> dramforever: abs works, but he use >= after that
03:58:34 <mauke> it doesn't even mention lists
03:58:36 <dramforever> nodnormal: change abs to magnitude (iirc spelling)
03:58:40 <Grisha> jameseb, please wait a sec, I'm trying to make up a simplest model of my problem
03:58:47 <mauke> > abs (0.5 :+ 0.5)
03:58:48 <lambdabot>  0.7071067811865476 :+ 0.0
03:58:55 <mauke> oic
03:59:05 <dramforever> :t abs
03:59:06 <lambdabot> Num a => a -> a
03:59:30 <nodnormal> why can't you compare complex numbers? because of phase?
03:59:39 <mauke> nodnormal: how would you order them?
03:59:40 <nodnormal> like in polar form or something0
03:59:44 <dramforever> nodnormal: did you learn about it in math class?
03:59:46 <Grisha> nodnormal, how would you compare two points on a plane?
03:59:46 <nodnormal> mauke: right
04:00:10 <mauke> is i > -1?
04:00:13 <nodnormal> yes i get it now, just didnt think it through
04:00:57 <nodnormal> mauke i guess
04:00:59 <merijn> The problem is that Complex has multiple sensible orderings, so to avoid people making assumptions it's not an instance of Ord
04:01:00 <quchen2_> There are perfectly fine ways of comparing complex numbers if you regard them as a tuple of reals. This breaks certain laws when you want to do arithmetic with them though, so you can pick at most one of the alternatives.
04:01:04 <nodnormal> mauke: nm
04:01:09 <merijn> Unlike tuples, which just use lexical ordering
04:01:31 <dramforever> merijn: it doesn't have one as far as I can tell
04:02:24 <nodnormal> okay removed type info and it compiled
04:02:32 <nodnormal> thanks :)
04:03:08 <nodnormal> is my way of nesting loops "okay" or "haskellish"
04:03:16 <nodnormal> or are there better ways
04:03:55 <dramforever> I didn't see a nested loop. Where is it?
04:04:00 <frerich> nodnormal: If you find that removing type signatures makes code compile, it may well be that what you think your code does (i.e. what you expressed as type signatures) actually differs from what it does (i.e. the types deduced by the compiler). So maybe you should have another look.
04:04:17 <frerich> Unless of course you're in for the kicks.
04:04:27 <mauke> frerich: we're removing type constraints, not signatures
04:04:41 <dramforever> it can't
04:04:51 <dramforever> I mean, see that "abs z' >= 2"?
04:04:53 <frerich> mauke: Ah, sorry.
04:04:57 <nodnormal> freich, i know, but it was inserted automatically
04:05:07 <nodnormal> dramforever: i know, fixing it now
04:05:10 <dramforever> nodnormal: did you change abs to magnitude?
04:05:13 <dramforever> oh okatt
04:05:14 <dramforever> okay
04:05:30 <mauke> or at least I think we are
04:06:31 <nodnormal> mauke: i actually removed the signature :)
04:06:36 <nodnormal> ill put it back
04:06:37 <merijn> dramforever: There's certainly sensible orderings for Complex, but the fact that there are multiple means it's hard to decide which to add to Prelude, for the reason mentioned by quchen2_
04:07:14 <dramforever> merijn: oh okay
04:08:42 <nodnormal> can someone recommend some other good vim plugins alongside vim-haskell-now?
04:09:12 <nodnormal> oh, and i dont understand how to cooperate with ghci, does anyone know? or is this not the place to ask?
04:10:24 * hackagebot nlp-scores 0.7.0 - Scoring functions commonly used for evaluation in NLP and IR  http://hackage.haskell.org/package/nlp-scores-0.7.0 (GrzegorzChrupala)
04:10:40 <dramforever> nodnormal: 1. I don't know. 2. This is the place to ask
04:10:56 <mauke> I don't understand the question
04:11:20 <dramforever> mauke: haskell-mode of ghci
04:11:26 <dramforever> ouch messed it up
04:11:28 <nodnormal> mauke, when i press the key bindings to open tmux with a ghci and send code to it, it asks for the window name?
04:11:36 <nodnormal> or something stupid i don't know
04:11:43 <mauke> oh, no idea
04:11:48 <mauke> I don't use any haskell plugins
04:12:01 <dramforever> nodnormal: I open two windows, and use the :r command
04:12:09 <nodnormal> why not? formatting must be nice?
04:12:19 <mauke> what formatting?
04:12:23 <nodnormal> dramforever: thats what im doing now with byobu :)
04:12:31 <nodnormal> mauke: :)
04:12:36 <mauke> ?
04:12:48 <nodnormal> autoformat your code is nice
04:12:55 <mauke> doesn't work in haskell
04:13:15 <dramforever> nodnormal: you mean >= -> ≥ ?
04:13:19 <nodnormal> emacs does it better i think, but its pretty close
04:13:28 <mauke> indentation determines structure; you can't derive indentation from the structure of the code
04:13:36 <nodnormal> dramforever: that too, but i was thinking of indentation
04:13:52 <bergmark> i think you can use hindent to auto format
04:13:56 <int-index> Is there a way to make my own typeclass that works like Exception from Control.Exception? I.e. casting to a particular type
04:14:06 <mauke> you can't autoformat unformatted code
04:14:31 <bergmark> true :-)
04:14:35 <mauke> int-index: sure, Control.Exception is just a library
04:14:40 <dramforever> int-index: what's casting to a particular type?
04:15:05 <mauke> ok, throwIO is built into IO / the compiler, but the rest ...
04:15:08 <int-index> I have a GADT like that:
04:15:19 <int-index> data Production n where
04:15:21 <nodnormal> okay new problem, when i have gathered all the return values with return $ mandelSet point, how do i access that list and write it to a file?
04:15:22 <dramforever> int-index: wait nooo
04:15:24 * hackagebot kansas-lava-papilio 0.2.0 - Kansas Lava support files for the Papilio FPGA board  http://hackage.haskell.org/package/kansas-lava-papilio-0.2.0 (GergoErdi)
04:15:25 <dramforever> stop!
04:15:35 <int-index> Stopping.
04:15:39 <dramforever> int-index: http://lpaste.net/new/haskell
04:15:54 <int-index> right
04:17:02 <int-index> http://lpaste.net/1628110097756454912
04:17:26 <int-index> I need to pattern-match on Prod somehow to get Maybe (Production n) for a known type n
04:17:42 <dramforever> int-index: Data.Typeable from base
04:17:47 <mauke> :t cast
04:17:48 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
04:17:49 <dramforever> s/^/you might need/
04:18:33 <int-index> Oh, seems like what I need
04:18:37 <nodnormal> isn't data Something where wrong? shouldn't it be data Something = ?
04:18:50 <mauke> nodnormal: no, that's a GADT
04:19:13 <nodnormal> mauke, hmm where can i read about it?
04:19:24 <dramforever> nodnormal: how much haskell have you learnt?
04:19:54 <nodnormal> dramforever: that code i pasted is my second attempt
04:19:55 <mauke> nodnormal: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/data-type-extensions.html#gadt
04:20:36 <dramforever> nodnormal: it's pretty complexed to understand well, but not hard to get to use it
04:22:08 <nodnormal> yes, i think it's slowly coming together for me
04:22:40 <tdammers> > let foo = \"x" -> "bar" -- just stumbled upon this pattern...
04:22:42 <lambdabot>  not an expression: ‘let foo = \"x" -> "bar" -- just stumbled upon this patte...
04:23:00 <tdammers> > let foo = \"x" -> "bar" in foo "x"
04:23:01 <lambdabot>  "bar"
04:23:05 <tdammers> > let foo = \"x" -> "bar" in foo "boink"
04:23:07 <lambdabot>  "*Exception: <interactive>:3:11-23: Non-exhaustive patterns in lambda
04:23:19 <dramforever> tdammers: that's not really useful I guess. where did you see it?
04:23:28 <tdammers> dramforever: hastache example
04:23:35 <tdammers> https://github.com/lymar/hastache/blob/master/examples/listsByIndex.hs
04:23:41 <tdammers> line 25
04:24:03 <tdammers> trying to make sense of hastache atm
04:24:21 <tdammers> particularly, how to map my custom data structures onto MuTypes
04:25:22 * dramforever saw "Qin Shi Huang"
04:25:43 <tdammers> it's a bit wacky how hastache implements dictionaries and lists - they both seem to use the same data structure, a list of key -> value functions
04:27:02 <tdammers> but, anyway, I didn't realize you could use string literals as pattern matchers for lambdas
04:29:01 <merijn> dramforever: tbh, I think I'd use GADTSyntax to explain ADTs to beginners if I was teaching haskell
04:29:13 <merijn> I think they make the distinction of types and constructor names much more intuitive
04:29:51 <dramforever> merijn: but it complicated record syntax
04:30:19 <dramforever> at least GADT records are weird-looking to me
04:30:25 * hackagebot servant 0.2.2 - A family of combinators for defining webservices APIs  http://hackage.haskell.org/package/servant-0.2.2 (jkarni)
04:30:36 <merijn> records are overrated
04:31:01 <dramforever> of course
04:31:26 <Iceland_jack> Starting fresh (if GADTSyntax were enabled by default) I think teaching
04:31:26 <Iceland_jack>     data Bool where
04:31:26 <Iceland_jack>       True :: Bool ...
04:31:29 <Iceland_jack> first, then offering normal ADT syntax as a "shortcut" would be the way to go
04:31:43 <dramforever> as "the standard way"
04:31:58 <Iceland_jack> Too often have I seen people confused by the type of constructors
04:32:59 <EvanR> yeah GADT syntax is nice
04:33:20 <EvanR> it clears up things, and allows for more sophisticated constructor types
04:33:25 <mroman> Data.ByteString.UTF8 should have hGetChar :(
04:33:50 <merijn> Iceland_jack: Exactly :)
04:34:00 <merijn> mroman: There's a lens for that!
04:34:23 <dramforever> Oh, yes: Does anyone know those lens papers?
04:34:28 <dramforever> any
04:34:34 <EvanR> mroman: you can use normal System.IO hGetChar and encode the char as a bytestring
04:34:53 <merijn> dramforever: What sort of paper?
04:34:59 <EvanR> though it all seems a bit backwards at that point
04:35:18 <dramforever> like var larhooven's paper (if there's one)
04:35:25 * hackagebot haroonga-httpd 0.1.0.0 - Yet another Groonga http server.  http://hackage.haskell.org/package/haroonga-httpd-0.1.0.0 (cosmo0920)
04:35:27 * hackagebot servant-server 0.2.4 - A family of combinators for defining webservices APIs and serving them  http://hackage.haskell.org/package/servant-server-0.2.4 (jkarni)
04:35:36 <mroman> EvanR: but that's a bit inconvenient
04:35:45 <mroman> because that's encoding dependent then
04:35:53 <EvanR> mroman: why do you want tiny byte strings of utf8 characters?
04:36:03 <EvanR> what? you want utf8
04:36:15 <EvanR> hSetEncoding h utf8
04:36:18 <mroman> I want a hGetChar that waits until enough bytes for a utf8 character are there
04:36:24 <EvanR> thats what hGetChar does
04:36:34 <mroman> I know
04:36:37 <lpaste> int-index pasted “Engram” at http://lpaste.net/121441
04:36:48 <mroman> but that's not ByteString
04:36:51 <int-index> I'm getting a Typeable error
04:36:55 <EvanR> why is "encoding dependent" a problem then
04:36:58 <int-index> could someone take a look please?
04:37:05 <mroman> ByteString's hGet for example takes an int parameter
04:37:08 <mroman> which reads *bytes*
04:37:10 <mroman> not characters
04:37:12 <EvanR> right
04:37:19 <EvanR> its the wrong type for the job of reading characters
04:37:40 <mroman> i'd want hGetChar to return ByteString actually
04:37:53 <EvanR> but it would be named wrong..
04:38:06 <mroman> well :)
04:38:08 <EvanR> hGetChar :: Handle -> IO ByteString (?)
04:38:14 <mroman> yeah
04:38:14 <EvanR> hGetByte :: Handle -> IO Char (?)
04:38:21 <mroman> because hGet hndl 1
04:38:22 <dramforever> When was poly-kinded Typeable introduced into haskell?
04:38:35 <golly> hi. action (a :: IO a) seems to return (IO (Either String a)). how to get (Either String a) from a? (i received deduction error)
04:38:36 <mroman> if you use hGet you NEVER know if you can safely convert the ByteString to String
04:38:38 <merijn> dramforever: No, I meant "what were you hoping to learn from it"?
04:38:41 <dramforever> int-index is basically having this problem
04:38:55 <EvanR> mroman: neither can your hypthotical hGetChar
04:39:10 <mroman> hGet hndl 1 >>= return . B8.toString
04:39:11 <mroman> will fail
04:39:27 <EvanR> no it wont
04:39:31 <mroman> of course it will
04:39:37 <EvanR> > '\255'
04:39:39 <lambdabot>  '\255'
04:39:44 <mroman> unless you input an something in ascii range
04:39:48 <mroman> which is luckily compatible
04:39:49 <dramforever> IIUC
04:39:53 <EvanR> ascii+ range
04:39:58 <EvanR> 0 - 255
04:40:29 <EvanR> mroman: anyway, use hGet 1 in succession until you have a utf8 sequence or an error
04:40:44 <dramforever> merijn: ??
04:41:11 <int-index> I've found the error
04:41:21 <EvanR> i.e. reimplement System.IO
04:41:21 <dramforever> golly: ping, do you know about Either?
04:41:25 <int-index> Needed one more constraint in the definition of Prod
04:41:38 <int-index> Actually, makes sense.
04:43:37 <mroman> let t f a b = (f a, f b) in t (B.unpack . B8.fromString . B8.toString . B.pack) [199] [210]
04:43:40 <mroman> ([239,191,189],[239,191,189])
04:43:43 <mroman> see
04:43:45 <mroman> doesn't work really as *it should*
04:44:00 <mroman> EvanR: and how do I know that I consumed enough for it to safely use stuff in ByteString.UTF8?
04:44:07 <EvanR> whats is B8.fromString, you mean Char8 ?
04:44:17 <mroman> b8 is ByteString.UTF8
04:44:24 <mroman> and B is ByteString
04:44:34 <EvanR> use Text.Encoding
04:45:06 <EvanR> im still not sure why youre going about System.IO without using System.IO
04:45:19 <EvanR> especially if youre going to just decode the bytestring
04:45:21 <aawe> @def calc = flip flip
04:45:22 <lambdabot>  Defined.
04:45:25 <aawe> > calc 2 (+) 3
04:45:26 <lambdabot>  5
04:46:16 <aawe> such indirection
04:46:37 <mroman> because I think it's ugly to use hSetEncodign
04:46:40 <mroman> but that's probably just me
04:46:51 <EvanR> its probably set to utf8 by default
04:47:08 <EvanR> but thats exactly what that system is for, reading a single character at a time
04:47:40 <mroman> and I don't really like it failing with invalid byte sequence
04:48:01 <EvanR> you can catch the exception
04:48:30 <EvanR> if theres something youd like to do instead of crash
04:48:38 <mroman> technically speaking I'd want getChar :: [Word8] -> ([Word8],[Word8])
04:48:59 <mroman> where fst is a complete utf8 char
04:49:00 <EvanR> what are those lists for
04:49:04 <mroman> and snd is the remaining part
04:49:06 <mroman> i.e
04:49:20 <mroman> [65,65,66] -> ([65],[65,66])
04:49:22 <EvanR> so read the whole input into memory first?
04:49:32 <aawe> so fst is an unsafe Maybe Word8 ?
04:49:35 <EvanR> then implement a utf8 decoder, which theres already several
04:49:59 <mroman> or actually
04:50:06 <mroman> isValidUTF8 :: [Word8] -> Bool
04:50:09 <mroman> that should do the trick as well
04:50:11 <EvanR> all this already exists
04:50:25 <mroman> @hoogle [Word8] -> Bool
04:50:27 <lambdabot> Prelude null :: [a] -> Bool
04:50:27 <lambdabot> Data.List null :: [a] -> Bool
04:50:27 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
04:50:31 <mroman> @hoogle ByteString -> Bool
04:50:32 <lambdabot> Data.ByteString null :: ByteString -> Bool
04:50:32 <lambdabot> Data.ByteString.Char8 null :: ByteString -> Bool
04:50:32 <lambdabot> Data.ByteString.Lazy null :: ByteString -> Bool
04:51:22 <merijn> mroman: What are you ACTUALLY trying to do?
04:51:39 <mroman> like I said
04:51:55 <mroman> I want to know if I have enough Word8 in my ByteString so that it is valid utf8
04:52:16 <Yaniel> :h Word8
04:52:21 <merijn> And you plan to use this for what?
04:52:31 <EvanR> are you impementing unicode for fun or is there an actual goal
04:52:57 <Yaniel> hm it's been a while since I touched ghc or lambdabot it seems
04:53:00 <tdammers> "enough Word8 in my ByteString"?
04:53:08 <tdammers> I don't think that's how "valid utf-8" works
04:53:10 <merijn> Yaniel: What were you hoping to find?
04:53:20 <mroman> tdammers: sure it is
04:53:25 <tdammers> ?
04:53:26 <aawe> :info Word8
04:53:33 <mroman> utf8 has multi-byte chars
04:53:35 <tdammers> it's either valid utf-8, or it's not
04:53:39 <merijn> lambdabot doesn't have an info command
04:53:45 <Yaniel> ah
04:53:56 <EvanR> a sequence of 1 2 3 or 4 bytes can be valid, invalid, or incomplete
04:54:00 <tdammers> yes
04:54:05 <merijn> And the info for Word8 is not particularly helpful...
04:54:23 <tdammers> sure
04:54:30 <tdammers> but that's not a matter of quantity
04:54:45 <merijn> It's basically just a primitive unsigned byte
04:54:58 <mroman> if the first byte is a multi_byte 2 indicator
04:55:01 <EvanR> its not a matter of quantity
04:55:05 <mroman> and the buffer only has one byte in it
04:55:07 <mroman> it's incomplete
04:55:09 <aawe> @where BS.Word8
04:55:09 <lambdabot> I know nothing about bs.word8.
04:55:12 <EvanR> each of the four cases has a whole separate problem to solve
04:55:13 <mroman> or possibly invalid
04:55:16 <mroman> but at least it's not valid
04:55:28 <EvanR> mroman: a buffer with one byte might be invalid
04:55:43 <mroman> yeah
04:55:49 <mroman> 0xff is illegal afaik
04:56:05 <mroman> the utf8 package just replaces those with a replacement_character
04:56:05 <Yaniel> yes
04:56:17 <EvanR> if you want help you can use the functions in Data.Text.Encoding.Internal
04:57:14 <mroman> I could use those packages and check if c == '\xfffd'
04:57:20 <EvanR> er Data.Text.Internal.Encoding.Utf8
04:57:32 <mroman> but I don't know if \xfffd isn't actually a legal character otherwise
04:57:41 <EvanR> there are a lot of cases to check
04:57:41 <mroman> I hope isn't?
04:58:03 <mroman> https://hackage.haskell.org/package/utf8-string-1/docs/src/Codec-Binary-UTF8-String.html#decode
04:58:28 <EvanR> there are a lot of unicode packages
04:58:36 <EvanR> but Data.Text is the one you probably want for real life
04:58:49 <mroman> isUTF8Encoded :: String -> Bool might do the trick
04:58:57 <mroman> but that's not [Word8]
04:58:58 <mroman> so no
04:59:04 <EvanR> that type makes no sense
04:59:28 <mroman> what's this replacement_character?
04:59:35 <mroman> Is this an "illegal character"?
04:59:38 <EvanR> its a unicode character
04:59:53 <mroman> I could just copy decode and rewrite it
05:00:26 * hackagebot colada 0.8.3.0 - Colada implements incremental word class class induction  using online LDA  http://hackage.haskell.org/package/colada-0.8.3.0 (GrzegorzChrupala)
05:01:52 <mroman> EvanR: http://codepad.org/XKLuo8Yj
05:02:31 <mroman> I need exactly that
05:02:32 <EvanR> decode :: ByteString -> Either Problem Text
05:03:24 <mroman> hu?
05:03:29 <mroman> where's that from?
05:03:51 <EvanR> a library
05:04:02 <mroman> not Data.Text.Encoding
05:04:16 <EvanR> decodeUtf8' :: ByteString -> Either UnicodeException Text
05:04:31 <mroman> @hoogle decodeUtf8'
05:04:32 <lambdabot> Data.Text.Encoding decodeUtf8' :: ByteString -> Either UnicodeException Text
05:04:32 <lambdabot> Data.Text.Lazy.Encoding decodeUtf8' :: ByteString -> Either UnicodeException Text
05:04:38 <mroman> wtf
05:04:44 <mroman> ow
05:04:50 <mroman> my docs are out of date
05:05:07 <mroman> well that explains A LOT
05:05:25 <Yaniel> @rwh
05:05:25 <lambdabot> Maybe you meant: wn run rc
05:05:30 <EvanR> you can also use IO from Data.Text to read the data in incrementally like System.IO
05:05:37 <Yaniel> @where rwh
05:05:38 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
05:08:31 <biglama> hi guys
05:08:50 <aawe> hello
05:09:48 <biglama> can I read-write the same file with Bytestring.Lazy ?
05:10:12 <biglama> i.e, I read a file into a string, modify the string and want to write it to the initial file
05:10:25 <biglama> can laziness be an issue then ?
05:11:12 <Iceland_jack> biglama: Lazy IO, yes
05:11:25 <nshepperd> I would advise against using lazy io for that
05:11:32 <mroman> >> main-> (putstrln (show (utf8_p #(255)))
05:11:33 <mroman> << NIL
05:11:34 <mroman> aight
05:11:35 <mroman> works
05:12:14 <biglama> in my code, I used Bytestring.Lazy to read the string from the file and Syste.IO to write it back again
05:12:28 <biglama> it seems to work but I'm not sure it will always work !
05:15:27 * hackagebot colada 0.8.4.0 - Colada implements incremental word class class induction  using online LDA  http://hackage.haskell.org/package/colada-0.8.4.0 (GrzegorzChrupala)
05:15:31 <merijn> Lazy IO is falling out of favour, if you want to do streaming data processing your best bet is probably something like pipes/conduits
05:15:56 <merijn> Otherwise you probably wanna use strict IO and directly operate on a Handle with seek/tell/write, etc.
05:17:30 <biglama> okay, I don't need to do any streaming anyway
05:17:58 <biglama> are readFile and writeFile (from System.IO) strict ?
05:18:11 <nshepperd> am I the only one who thinks it's daft that there isn't a non-lazy hGetContents
05:18:26 <merijn> I'm pretty sure that exists
05:18:28 <nshepperd> biglama: readFile is lazy
05:18:45 <biglama> okay
05:18:50 <Adeon> I don't know if there is a strict one in base
05:18:52 <nshepperd> I don't think writing is ever lazy though
05:18:57 <Adeon> the bytestring and text packages implement a readFile that is strict
05:19:01 <merijn> nshepperd: http://hackage.haskell.org/package/bytestring-0.10.4.1/docs/Data-ByteString.html#v:hGetContents
05:19:06 <Adeon> bytestring also has hGet and stuff so you can read pieces
05:19:26 <merijn> Just use hGetContents from Data.ByteString instead of Data.ByteString.Lazy
05:19:37 <EvanR> readFile?
05:19:45 <nshepperd> ah right, ByteString.readFile is strict
05:20:03 <EvanR> wtf
05:20:15 <ChristianS> nshepperd: it's strict for strict ByteStrings, lazy for lazy ones
05:20:17 <EvanR> i thought readFile was strict
05:20:26 <biglama> so readFile is lazy but writeFile is not ? So I read, then write, is that an undefined state ?
05:20:27 * hackagebot reverse-geocoding 0.2 - Simple reverse geocoding using OpenStreeMap  http://hackage.haskell.org/package/reverse-geocoding-0.2 (jcristovao)
05:20:37 <tdammers> biglama: no
05:20:42 <tdammers> you read, which is lazy
05:20:50 <tdammers> and then you write, which forces the value you've just read
05:21:19 <biglama> okay, thanks !
05:21:19 <tdammers> unless you actually use the value you have "read", of course
05:21:40 <tdammers> "lazy" just means "don't read until you need it", not "never read it at all"
05:21:46 <nshepperd> well, it's obviously bad if the thing you're writing to is the same as you're reading from
05:21:51 <tdammers> yes
05:21:57 <mroman> @hoogle liftIO
05:21:58 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
05:21:58 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
05:21:58 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
05:22:00 <mroman> @src liftIO
05:22:00 <biglama> so I should use a temporpary file ?
05:22:00 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
05:22:24 <biglama> temporary*
05:23:52 <mroman> How did that work again?
05:23:59 <mroman> to lift stuff from IO into an outter monad
05:24:10 <nshepperd> bah, lazy readFile should be called unsafeReadFile
05:24:20 <nshepperd> or something
05:24:31 <_d0t> ohai. Is there any way to run ghci without readline?
05:24:32 <EvanR> unsafeInterleaveFileIO ;)
05:25:08 <aloiscochard> does anyone know (or could explain how I can work that out?) where cabal look for C header file by default? (my headers are in /usr/include/<libname> but I have to set that path explicitly in cabal config)
05:25:28 * hackagebot xhb-ewmh 0.1.3.1 - EWMH utilities for XHB  http://hackage.haskell.org/package/xhb-ewmh-0.1.3.1 (jrk)
05:25:34 <mroman> InputT IO () sounds like something transforming over IO?
05:26:40 <geekosaur> aloiscochard, /usr/include should be checked automatically, at least on unixlike platforms
05:26:43 <nshepperd> biglama: either use a temporary file, or the deepseq sledgehammer I guess
05:26:59 <biglama> nshepperd: okay, thanks
05:27:16 <geekosaur> if it's not finding it then your C compiler may be broken. can you pastebin -v3 output from cabal?
05:27:54 <nshepperd> safeReadFile = readFile >=> (\s -> deepseq s (return s))
05:28:12 <nshepperd> pseudo-safe
05:28:24 <mroman> InputT IO ()
05:28:57 <mroman> so I should be able to lift IO things into this
05:29:50 <mroman> No instance for (MonadIO (H.InputT IO)) arising from a use of ‘liftIO’
05:29:52 <mroman> :(
05:30:20 <nshepperd> mroman: I think liftIO is a member of MonadIO
05:30:23 <aloiscochard> geekosaur: here is the thing: http://pastie.org/9993592 thanks a lot for your help
05:30:28 * hackagebot servant-client 0.2.2 - automatical derivation of querying functions for servant webservices  http://hackage.haskell.org/package/servant-client-0.2.2 (jkarni)
05:30:53 <nshepperd> defined for each new monad transformer you invent, normally as liftIO = lift . liftIO
05:31:07 <mroman> InputT is from haskeline
05:31:13 <EvanR> or not implemented, as the case may be
05:31:16 <mroman> I'd like to do some I/O actions
05:31:23 <mroman> for CGI it works with liftIO :(
05:31:28 <mroman> as well as for StateT IO
05:31:30 <aloiscochard> geekosaur: (fwiw, I'm on archlinux, and the package come from the AUR)
05:31:30 <mroman> but InputT IO
05:31:33 <mroman> something seems off
05:31:59 <EvanR> either you missed something, they missed something, or theres a good reason you cant do IO in that transformer
05:32:07 <geekosaur> oh. it's not /usr/include it's /usr/include/grpc
05:32:10 <geekosaur> this is significant
05:32:37 <aloiscochard> oh, so I should do grpc/grpc.h I bet
05:32:41 * aloiscochard try
05:32:56 <aloiscochard> hooray!
05:33:01 <aloiscochard> thanks a lot geekosaur :)
05:33:05 <nshepperd> according to hackage docs there should be a MonadIO m => MonadIO (InputT m) instance?
05:33:08 <geekosaur> the whole point of subdirectories like that is to avoid collisions between different packages' include files; if the compiler or cabal automatically went unting in subdirectories then it could well find something from the wrong package
05:33:21 <aloiscochard> geekosaur: I see, it's a sort of poor man namespace
05:33:25 <geekosaur> (promiscuous build systems like cmake *do* do that, and yes they break in odd ways)
05:33:28 <geekosaur> yes, exactly
05:33:41 <mroman> InputT is MonadIO
05:34:21 <mroman> so I thought
05:35:22 <mroman> also stack overflow tells me that liftIO should work
05:35:22 <mroman> so
05:35:57 <mroman> hm
05:35:58 <mroman> weird
05:36:02 <mroman> reinstalling haskeline fixed it :)
05:36:12 <mroman> I guess my package versions are screwed up beyond repair
05:36:19 <aawe> mroman: ghc-pkg check
05:36:37 <mroman> All the requested packages are already installed:
05:36:37 <mroman> haskeline-0.7.1.3
05:36:41 <mroman> I had 0.7.1.3 installed
05:36:47 <mroman> and reinstall just installed 0.7.1.3 again
05:36:49 <mroman> but now it works
05:36:49 <nshepperd> whoa, InputT defined as a stack of 5 ReaderTs
05:36:51 <mroman> what the
05:37:22 <nshepperd> that seems a little mad
05:37:44 <EvanR> its a mad, mad, mad, mad, mad monad
05:37:56 <tdammers> MadnessT
05:37:57 <geekosaur> lens reasons >.>
05:38:36 <aawe> that's not gonna cut it. Your monad stack needs to be at least this high -------> |
05:39:19 <jtanguy> by looking at its MonadTrans instance, i'd say it's a bro-stack
05:40:42 <nshepperd> it certainly lifts
05:41:27 <mroman> >> double -> (bind #(0) #(T:x) (add S:x S:x)) main -> (double 5)
05:41:28 <mroman> << 10
05:41:29 <mroman> perfect
05:41:38 <mroman> now I can even history, copy/paste in the shell <3
05:45:29 * hackagebot al 0.1.0.3 - OpenAL 1.1 raw API.  http://hackage.haskell.org/package/al-0.1.0.3 (DimitriSabadie)
05:47:27 <aawe> what is the use practical use of Data.Void?
05:47:37 <aawe> (conduit depends on it)
05:48:05 <merijn> aawe: Indicate non-terminating operations
05:48:09 <merijn> Void has no constructors
05:48:24 <merijn> Therefore, the only possibly value of Void is bottom (i.e. infinite loop)
05:48:37 <merijn> Therefore "IO Void" must be an infinite looping IO action
05:48:47 <merijn> It never returns, because there's no way to return a Void
05:49:34 <aawe> merijn: that is very interesting, encoding non-termination as a type
05:49:41 <phaul> that's a bit confusing given Control.Monad.void
05:49:59 <exio4> and that things like forever _may_ terminate
05:50:02 <exio4> > forever []
05:50:03 <lambdabot>  []
05:53:53 <aawe> how can the definition of absurd pattern match on the nonexistent Void constructor? https://hackage.haskell.org/package/void-0.7/docs/src/Data-Void.html#absurd
05:55:32 <aawe> wait. nevermind
05:56:17 <phaazon> hm
05:59:36 <Testeree> hi, i am trying to install haskell-vim-now on my arch machine - it keep throwing this error - haskell-src-exts-1.16.0.1 failed during the configure step. The exception was: ExitFailure 1
05:59:49 <Testeree> anybody experienced this? is there any workaround?
06:00:47 <phaul> so Void is - if it's constructed - an infinite structure of (Void (Void (Void ... , can't you construct it by f :: Void Void ; f = Void f ?
06:01:20 <Hijiri> phaul: Void is either a newtype or has a strict field
06:01:28 <aawe> Testeree: try with more verbosity, i.e. cabal install -v haskell-vim-now
06:01:41 <jtanguy> Testeree: do you have alex and happy installed
06:01:45 <Hijiri> phaul: newtypes also are strict in the parameter, so that wouldn't help
06:01:45 <phaul> Hijiri: oh I see, thanks
06:03:14 <Testeree> jtanguy, no
06:03:32 <Testeree> aawe, i'll try that
06:03:45 <mauke> f = Void f is equivalent to fix Void
06:04:14 <mauke> if Void is a newtype, Void is operationally the identity
06:04:21 <mauke> ==> fix id
06:05:35 <nshepperd> with some 'recent' ghc extension, you can write 'data Void'. and actually give it no constructors
06:06:30 <Testeree> jtanguy, should i install it beforehand? aawe, i took the easy *insecure* way for installation (curl -o - https://raw.githubusercontent.com/begriffs/haskell-vim-now/master/install.sh | bash) , i'll do it manually now.
06:10:26 <aawe> Testeree: I'd say cabal is more automatic
06:17:10 <LostPlanet> I just found out that this book I had in my amazon wish list for a long time called "Learn you a Haskell for great good" is actually available for free to read online!
06:17:46 <LostPlanet> thanks!
06:17:53 <phaul> > fst (1, fix id)
06:17:54 <lambdabot>  1
06:18:06 <LostPlanet> the webpage says that the author BONUS is on here ,but i do not see them now. thanks again
06:18:12 <LostPlanet> looking forward to reading it
06:20:35 <mauke> I haven't seen BONUS in a while (a few years)
06:23:09 <LostPlanet> mauke: thanks for the update. maybe i'll buy a copy on amazon anyway in addition to reading it online
06:30:31 * hackagebot servant-docs 0.3.1 - generate API docs for your servant webservice  http://hackage.haskell.org/package/servant-docs-0.3.1 (jkarni)
06:34:36 <phaul> I'm realizing this "fst (1, fix id)" didn't demonstrate much as (,) is lazy..
06:34:59 <phaul> > [fix id, 1] !! 1
06:35:01 <lambdabot>  1
06:35:45 <mauke> (:) is lazy
06:36:14 <LostPlanet> >
06:36:20 <phaul> but this [fix Void, 1] !! 1 timed out for me
06:36:32 <phaul> (with Num end Show hacked on Void)
06:37:07 <exio4> phaul: because that "1" inside the list is the same as "fromInteger (1 :: Integer) :: Void"
06:37:21 <exio4> and we all know which values can be Void
06:37:27 <phaul> ah, got it
06:38:50 <nkar> is there a function behaving like bimap with the type similar to fmap (accepting one function)?
06:39:24 <quchen2_> left/right?
06:39:41 <quchen2_> join bimap?
06:41:12 <nkar> quchen2_: here's the usecase I have in mind: instead of writing (f x, f y), I want to write g f (x,y) and get the same result
06:41:52 <quchen2_> :t join bimap :: (a -> b) -> (a,a) -> (b,b)
06:41:52 <lambdabot> (a -> b) -> (a, a) -> (b, b)
06:42:17 <quchen2_> join f x = f x x, if that helps.
06:42:21 <mauke> :t both
06:42:22 <lambdabot> (Data.Bitraversable.Bitraversable r, Applicative f) => (a -> f b) -> r a a -> f (r b b)
06:42:52 <quchen2_> :t over both -- mauke
06:42:53 <lambdabot> Data.Bitraversable.Bitraversable r => (a -> b) -> r a a -> r b b
06:43:38 <mauke> :t [over both, join bimap, join (***)]
06:43:39 <lambdabot> [(b' -> c') -> (b', b') -> (c', c')]
06:44:44 <nkar> thanks
06:45:32 * hackagebot graceful 0.1.1.5 - Library to write graceful shutdown / upgrade service.  http://hackage.haskell.org/package/graceful-0.1.1.5 (NoriyukiOhkawa)
06:47:15 <mauke> :t [id, ($), ask, asks, fmap fix return]
06:47:16 <lambdabot> [(a -> a1) -> a -> a1]
06:48:42 <quchen2_> mauke: "local" also unifies with "id" :-)
06:49:07 <mauke> :t [id, ($), ask, asks, local, fmap fix pure]
06:49:08 <lambdabot> MonadReader (m a) m => [(m a -> m a) -> m a -> m a]
06:50:32 * hackagebot reverse-geocoding 0.2.1 - Simple reverse geocoding using OpenStreeMap  http://hackage.haskell.org/package/reverse-geocoding-0.2.1 (jcristovao)
06:55:54 <YaRly> How do I make a "list" of any length that has a mix of any type?
06:56:18 <mauke> you don't
06:56:18 <YaRly> ["a",2,"c"]
06:56:22 <mpickering> YaRly: The short answer is that you can't
06:56:30 <mauke> if you did, how would you use it?
06:56:32 <YaRly> there must be some kind of monad that allows this?
06:56:36 <EvanR> (Char, (Int, (Bool, ())))
06:56:45 <mauke> a monad?!
06:56:46 <mpickering> the longer answer is that if there is a specific thing you want to be able to do to each item then you might be able to
06:56:48 <EvanR> but first ask wtf youd do with something like that
06:56:59 <jtanguy> why would you want such a thing?
06:57:01 <YaRly> mauke: Each element would have an associated function for how to deal with the data
06:57:11 <EvanR> then make a list of functions instead
06:57:16 <mauke> YaRly: why not store the results of that function directly?
06:57:28 <mauke> > [show 'a', show 2, show 'c']
06:57:29 <lambdabot>  ["'a'","2","'c'"]
06:57:34 <YaRly> mauke: because each function can return any type,
06:57:41 <YaRly> so the result of the functions are any type :P
06:57:42 <phaazon> hm, I’m confused; what is “ccall” convention for?; what is “stdcall”?
06:57:44 <mauke> YaRly: that doesn't change anything
06:57:53 <phaazon> I thought stdcall was for Windows 32 bits
06:57:58 <EvanR> YaRly: back to where you started, what would you do with all those different types?
06:58:02 <mauke> YaRly: you're left with the original problem of a type Foo where you know nothing about the contents. how would you use it?
06:58:09 <phaazon> but I guess it’s a fail with MinGW32 on a Windows 64 bits
06:58:26 <YaRly> mauke: Well it kind of does. I have a list of functions I want to apply to a string to gather statistics about that string. The statistics can be of any type as long as they derive Show
06:58:45 <mauke> so they're equivalent to String
06:58:46 <YaRly> all those statistics will be saved in a new list
06:58:55 <mauke> [String
06:58:56 <EvanR> questions like this a very instructive on how anybody manages to operate in a dynamically type language, it reveals how you think of dynamic types, for better or worse
06:58:57 <mauke> ]
06:59:11 <YaRly> mauke: Yes, in theory, but I'd like to avoid having to convert things back and forth each time a statistic needs to be "changed"
06:59:22 <mauke> changed how?
06:59:25 <rpr> how do I catch all the exceptions in main to write the error message to the log file?
06:59:26 <mauke> you don't know what the type is
06:59:38 <EvanR> rpr: redirect stderr to a file
06:59:58 <mauke> rpr: `catch` \SomeException{} -> ...
07:00:53 <YaRly> mauke: Users will supply functions for how to add up two stats of their chosen type, so they can be changed. Say one stat is a word count and you want to change it, the "count" needs to be read/shown each time it's manipulated
07:01:21 <EvanR> YaRly: is this a configuration language for users to write their own statistics computations?
07:01:36 <mauke> o_O
07:01:39 <YaRly> EvanR: Hmm, sounds right
07:01:49 <EvanR> good, then think of it like that ;)
07:01:53 <Hijiri> by read/shown do you mean stringly-typed
07:02:36 <YaRly> EvanR: I've never thought about that before though...so what's the deal? Is there something that's already implemented that I can import?
07:02:40 <EvanR> now youre in the business of language design, and you have a non trivial task of making it a non-shitty experience for the user
07:02:59 <EvanR> part of that is making sure what they choose remotely makes sense, i.e. is well typed
07:06:01 <EvanR> ive noticed that vastly simplified, stronly typed languages end up being way easier for users, and provide saner avenues for a GUI to direct user options
07:06:14 <EvanR> rather than "text box put javascript"
07:06:19 <YaRly> EvanR: ok...hrm, I was thinking the stats could be stored as strings, users would provide a func to convert the raw data to string, a func to "+" two stats of their chosen type, and a func to convert the string that is stored to their chosen type during "+"
07:06:41 <EvanR> good start
07:07:23 <EvanR> + and string dont really make sense together, youre probably just thinking of storage implementation details
07:07:53 <EvanR> you have the data, and you have the statistics language, neither has to be inherently dealing with strongs
07:07:55 <YaRly> yes, I was using + as a symbol that meant "combining two stats"
07:07:56 <EvanR> strings
07:08:13 <EvanR> what are the ways of combining two stats
07:08:30 <YaRly> users will choose that themselves for each type of stat they provide
07:08:47 <EvanR> what are their choices
07:09:43 <YaRly> it's totally free, for instance if they make  a wordcount class, then their combine function on a and b will increment the words that exist in a with the values from b, and simply add the ones that are missing into a
07:10:10 <EvanR> are you sure that giving them java is the right way to do this
07:10:27 <YaRly> java?
07:10:33 * hackagebot al 0.1.1 - OpenAL 1.1 raw API.  http://hackage.haskell.org/package/al-0.1.1 (DimitriSabadie)
07:10:40 <funfunctor> EvanR: your up so late these days?
07:11:24 <Hijiri> who is in charge of ensuring the user calls functions of the right type on parameters of the right type?
07:11:34 <EvanR> starting from the assumption that we can write "totally free" object oriented code is probably making things more complicated than necessary
07:12:14 <EvanR> if you dont know how you might combine stats, things arent going to turn out well probably
07:12:35 <EvanR> giving somebody a normal programming language and letting them figure it out is probably going to miss some marks
07:14:46 <funfunctor> good god, whats with people like Ti and AMD writing their C code like its somekind of monster mix of Java and FORTRAN
07:15:34 <EvanR> the more messed up the code is, the faster it goes
07:16:22 <EvanR> to market
07:17:13 <rola> can't you sorta get a list that has a mix of types by doing something like this:
07:17:43 <rola> data Blah = S String | C Char | B Bool deriving (Show, Eq)
07:17:56 <rola> then [S "1", C '1', B True]
07:18:06 <Hijiri> yes, but I think yarly wants to not know the types in advance
07:18:31 <YaRly> I think it's kind of solved now guys, thanks ! :)
07:18:55 <EvanR> Blah becomes something like a dynamic type
07:19:28 <EvanR> many operations that youd define for components of Blah separately now dont make sense together
07:19:32 <funfunctor> atleast it has lots of comments
07:20:10 <EvanR> haskell has support for "mother of all dynamic types" Typeable
07:20:34 * hackagebot websnap 0.1.0.1 - Transforms URLs to PNGs  http://hackage.haskell.org/package/websnap-0.1.0.1 (jrb)
07:21:47 <kstt> Hi Gtk lovers. It seems that the listStore is deeply broken in gtk2hs, do you know something about that please ?
07:23:11 <kstt> http://lpaste.net/121444
07:25:34 * hackagebot strive 0.8.0 - A Haskell client for the Strava V3 API.  http://hackage.haskell.org/package/strive-0.8.0 (fozworth)
07:42:55 <AdrianNn> Hey guys, I've been looking over the reddit thread regarding GSOC proposal and I must say, it looks rather scary
07:43:08 <AdrianNn> as in, a lot to take in
07:43:21 <flux> which thread in particular?
07:43:36 <AdrianNn> http://www.reddit.com/r/haskell/comments/2wii6n/haskell_google_summer_of_code_proposal/
07:43:38 <AdrianNn> this one
07:44:00 <mpickering> AdrianNn: You might want to join #haskell-gsoc if you have any questions
07:44:03 <AdrianNn> and reading through the comments
07:44:19 <AdrianNn> good to know, @mpickering :)
07:45:13 <mpickering> of course you can also ask here but there people are more likely to know
07:45:28 <AdrianNn> yes, of course, that is a dedicated channel :)
07:54:30 <fread2282> can someone help me find a quote that "haskell is a secret weapon for writing compilers" (or something along those lines)?
07:57:55 <aloiscochard> "haskell is love"
07:58:37 <EvanR> time to haskell and chew bubble gum
08:00:32 <tdammers> EvanR: and I'm all out of bubble gum
08:01:56 <Grisha> hi again
08:03:11 <Grisha> I'm trying to figure out how to express an infinite list with elements depending on the previous ones, very much like fib = 1: 2: zipWith (*) (tail fib), but rather with the difference that the zipping is parameterized by another given list
08:03:21 <Grisha> it's going to be a poor man's markov model simulation
08:03:51 <aawe> where can I go to get a basic understanding of lattices in a type/haskell context?
08:04:53 <aawe> fread2282: I've heard "Haskell is a domain-specific language for writing compilers"
08:05:14 <grizt> http://matt.might.net/articles/partial-orders/ is this useful to you? It looks like it might be
08:05:55 <aawe> grizt: looks like it, thank you!
08:06:07 <fread2282> aawe: do you have a source? iirc one of the ghc authours said something like this
08:07:14 <aawe> fread2282: my teacher in a Compiler Construction course said it, I don't remember if he attributed it to a specific name
08:07:42 <aawe> it's said tounge-in-cheek
08:08:07 <grizt> aawe: np
08:17:07 <rola> fread2282, "Haskell has become a laboratory for exploring crazy type systems"?
08:19:43 <merijn> Not really, though, people are doing far crazier things than haskell :p
08:20:04 <EvanR> haskell is the gateway
08:20:18 <EvanR> abandon all hope
08:20:30 <erisco> I was thinking of a sample problem for a foldMap
08:20:59 <bjornars1> erisco: convert a list of strings to a list of words?
08:21:11 <coltfred> If I wanted to statically link a haskell application for deployment, but that haskell app uses `network-2.6.0.2` what's the "correct" way to do that? I like to keep my builds free of warnings, but in this scenario I don't know that I can avoid them? Should I suppress this particular class of error?
08:21:25 <erisco> sorry, a filterMap
08:21:34 <erisco> anyways, that part of it is not important
08:21:50 <erisco> I was thinking about summing prime factors and filtering on some relation to the number
08:22:02 <erisco> which got me thinking about that relationship
08:22:33 <erisco> for n > 4, the sum of prime factors of n is strictly less than n ? I think ?
08:22:52 <erisco> and if so, can we improve on that bound?
08:23:18 <sokld> Is there anything special about the fact that IO is an instance of Monad? Or is that just something that happens to be the case?
08:23:28 <erisco> I decided that the factor "1" would not be included in the sum, or otherwise treated as zero
08:24:05 <erisco> so sorry, forall n the sum of the prime factors, excluding 1, is less than or equal to n
08:24:10 <merijn> sokld: The latter
08:24:23 <EvanR> sokld: its an instance of several other type classes
08:24:27 <merijn> sokld: You could have IO without a monad typeclass, etc. and even still have do-notation
08:24:37 <sokld> ok merijn, thats what what i thought
08:24:47 <EvanR> some kind of weird like Alternative ;)
08:24:58 <erisco> and I think forall n > 4, iff the sum of its prime factors excluding 1 is equal to n then n is primie
08:25:00 <HeladoDeBrownie> sokld, IO was basically designed in such a way that it could fit Monad. while Monad generalizes over things, one of the motivating design factors was indeed a better i/o model. that said, there's not a particular deep connection between Monad and side effects
08:25:10 <HeladoDeBrownie> over many things*
08:25:26 <merijn> sokld: What many people also forget is that until Haskell 1.4 or so haskell didn't use monads/IO for IO, it's just that the current approach is massively more pleasant than the old one :p
08:25:41 <sokld> ah
08:25:50 <zomg> merijn: are there any examples of how it was done before that? Kind of curious
08:25:51 <erisco> who, wrong channel sorry :P
08:25:55 <erisco> I thought this was -blah
08:26:07 <merijn> zomg: Function from lazy list of inputs to lazy list of outputs
08:26:20 <merijn> zomg: Ask augustss when he's around :)
08:26:28 <zomg> thanks :)
08:26:34 <merijn> zomg: Since he implemented the first ever haskell compiler :
08:26:48 <zomg> nice
08:27:00 <sokld> I was thinking of implementing an audio codec in haskell, is that something worth doing or would developers still prefer a C/C++ library for performance or other reasons?
08:27:03 <tdammers> the RealWorld -> RealWorld model
08:27:05 <tdammers> ?
08:27:17 <tdammers> or was that never actually used?
08:27:33 <EvanR> ComplexWorld -> ComplexWorld
08:28:44 <EvanR> sokld: real time codec?
08:29:40 <sokld> EvanR: yeah, I was thinking about opus codec
08:33:34 <merijn> sokld: Depends, realtime or offline?
08:33:47 <merijn> For offline I think haskell should be fine
08:33:56 <merijn> For realtime, maybe, I dunno
08:34:10 <merijn> tdammers: The RealWorld model is how it's currently implemented under the hood
08:34:40 <tdammers> merijn: really? what about threads and stuff?
08:34:41 <EvanR> theres something called RealWorld but
08:34:41 <merijn> tdammers: Actually, the current implementation of both ST and IO are in terms of a primitive/unboxed version of State
08:34:44 <sokld> I guess ill try it, its realtime, worst case scenario I learn about optimizing Haskell code :)
08:34:59 <EvanR> sokld: good luck ;)
08:35:04 <merijn> sokld: You probably wanna look at conduits/pipes
08:35:11 <EvanR> sokld: its interesting because its not obvious that haskell will totally suck at this
08:35:37 <merijn> sokld: Those are aimed at streaming operations, I remember a blogpost of conduits for streaming analysis of trades with like nanosecond inner-loops
08:35:38 * hackagebot happstack-server 7.4.1 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.4.1 (JeremyShaw)
08:35:45 <EvanR> the other day cmccann implemented an FM synth
08:35:53 <merijn> sokld: But that's definitely in the "black magic" terrain of haskell programming :)
08:36:03 <xnull> :t elem
08:36:04 <lambdabot> Eq a => a -> [a] -> Bool
08:36:09 <merijn> or maybe microsecond, I forget
08:37:34 <merijn> sokld: See https://www.fpcomplete.com/blog/2014/08/iap-speeding-up-conduit
08:37:44 <merijn> tdammers: Threads can only interact via builtins anyway
08:37:53 <merijn> tdammers: i.e. MVar/etc. so that's no problem
08:38:06 <tdammers> hmm, interesting
08:38:33 <sokld> thanks merijn
08:40:03 <xnull> :t (:)
08:40:07 <lambdabot> a -> [a] -> [a]
08:40:14 <Cale> tdammers: The (State# RealWorld) tokens are just a hack, they're 0-byte-wide things that just serve to sequence effects by using dependencies between effectful functions. Older models of IO in Haskell looked like type Dialogue = [Response] -> [Request], where you had something along the lines of data Request = ReadFile FilePath | WriteFile FilePath String | ... and  data Response = Success | Str String | Bn Bin | Failu
08:40:14 <Cale> re IOError
08:40:41 <HeladoDeBrownie> Cale, you cut of at Failu
08:40:44 <HeladoDeBrownie> off*
08:40:48 <HeladoDeBrownie> oh never mind
08:40:53 <tdammers> HeladoDeBrownie: no, just line-wrapped
08:41:00 <tdammers> HeladoDeBrownie: some of us use proper IRC clients ;)
08:41:10 <Cale> tdammers: The idea being that a program would lazily consume a stream of Responses to the stream of Requests that it made.
08:41:16 <HeladoDeBrownie> tdammers, yeah realized right after. had read "re IOError" as "re: IOError" and thought i missed something :P
08:41:27 <rhaps0dy> So, one quick question
08:41:30 <tdammers> Cale: yes, I understand the idea...
08:41:38 <rhaps0dy> is there a Haskell package manager?
08:41:51 <HeladoDeBrownie> rhaps0dy, not exactly. there is cabal-install.
08:41:53 <rhaps0dy> like pip is for Python
08:42:03 <Cale> rhaps0dy: Sort of. There's cabal, which is a system for building and installing packages.
08:42:03 <rhaps0dy> HeladoDeBrownie: Yeah, but that's not strictly a package manager.
08:42:05 <Welkin> rhaps0dy: cabal is like pip
08:42:06 <rhaps0dy> and it doesn't work very well.
08:42:10 <Welkin> but it is not a package manager
08:42:10 <EvanR> ghc-pkg list
08:42:11 <rhaps0dy> for just installing packages.
08:42:16 <xnull> :t sum
08:42:17 <lambdabot> Num a => [a] -> a
08:42:18 <rhaps0dy> EvanR: yeah, I did that too
08:42:21 <rhaps0dy> :|
08:42:22 <HeladoDeBrownie> rhaps0dy, thus "not exactly" :)
08:42:27 <rhaps0dy> time to write one I guess.
08:42:30 <Cale> ghc-pkg will handle other aspects of package management
08:42:31 <rhaps0dy> It's quite annoying.
08:42:47 <EvanR> package management is a huge fallacy
08:42:50 <rhaps0dy> Cale: u-upgrading?
08:42:50 <Welkin> use ghc-pkg to remove/unregister packages
08:42:53 <Cale> Oh, cabal-install does upgrading
08:43:11 <rhaps0dy> Cale: https://stackoverflow.com/questions/6905163/whats-the-best-workaround-for-not-having-cabal-upgrade ;_;
08:43:24 <rhaps0dy> EvanR: a fallacy?
08:43:26 <Cale> Oh, you don't want a command to upgrade everything.
08:43:33 <EvanR> yeah
08:43:41 <StrangeLoop> Hi, assume I have functions f1, f2, f3, and I want to run them consecutively on a number, say 6. Is there any way to do that which is not as ugly as f1(f2(f3(6)))?
08:43:46 <StrangeLoop> I mean, is there a way to concatenate functions without using parens?
08:43:55 <Cale> Well, I guess you might :)
08:43:56 <xnull> :t fst
08:43:57 <lambdabot> (a, b) -> a
08:44:11 <Cale> StrangeLoop: That's what the (.) operator does
08:44:12 <EvanR> rhaps0dy: its kind of like oop, different people have different principle aspects they want to do with it, but use the same word as everyone else, whose thinking of something else
08:44:14 <moghedrin> StrangeLoop: f1 . f2 . f3 $ 6
08:44:15 <rhaps0dy> Cale: I don't want a command to upgrade everything?
08:44:15 <Cale> :t (.)
08:44:17 <lambdabot> (b -> c) -> (a -> b) -> a -> c
08:44:37 <Cale> StrangeLoop: and ($) is function application, but has really low precedence
08:44:38 <EvanR> rhaps0dy: in your case, you want to keep all packages at latest version
08:44:38 <rhaps0dy> EvanR: I see. Cabal does indeed manage dependencies.
08:44:59 <rhaps0dy> yeah, I would like to do that
08:45:04 <StrangeLoop> So how come "head(tail([1,2,3]))" returns [2] but " head . tail [1,2,3]" returs an error?
08:45:07 <EvanR> someone else would say i want it to auto remove packages it guesses i dont want when i remove one package
08:45:17 <Welkin> StrangeLoop: because you need a $
08:45:21 <HeladoDeBrownie> StrangeLoop, because head . tail is the composition of "head" with "tail [1, 2, 3]"
08:45:29 <HeladoDeBrownie> StrangeLoop, tail [1, 2, 3] is not a function
08:45:33 <EvanR> these have nothing to do with each other
08:45:34 <StrangeLoop> Ahhh, I guess I need to keep reading my book then
08:45:44 <EvanR> and some people dont want to do either one
08:45:47 <Cale> StrangeLoop: Function application binds more tightly than any infix operator
08:45:57 <rhaps0dy> ^
08:45:58 <moghedrin> StrangeLoop: ^
08:46:00 <merijn> You don't need a $ at all
08:46:08 <rhaps0dy> dang, Cale too fast
08:46:14 <merijn> "(f1 . f2 . f3) 6" <- this works just fine
08:46:40 <rhaps0dy> EvanR: At least it would be good to have the option to.
08:46:50 <rhaps0dy> Maybe it doesn't belong in  cabal-install though
08:46:56 <StrangeLoop> OK, I have no idea what the $ is yet, but I like merijn's answer. So in a sense, the . operator takes functions and returns their composition?
08:46:58 <xnull> :t [fst x | x <- zip [1..] (['a'..'z'] ++ ['A'..'Z']), snd x == 'j']
08:46:59 <lambdabot> (Num t, Enum t) => [t]
08:47:04 <Cale> StrangeLoop: yeah
08:47:07 <StrangeLoop> Cool
08:47:09 <StrangeLoop> thanks
08:47:10 <Cale> StrangeLoop: (f . g) x = f (g x)
08:47:16 <Cale> StrangeLoop: and  f $ x = f x
08:47:21 <Welkin> $ is a pair of ()
08:47:22 <rhaps0dy> StrangeLoop: $ is a function that just applies its second arg to its first
08:47:28 <EvanR> rhaps0dy: depending on how much work it takes to develope such a system (that works) and how much damage it doesnt when people hook it up to their return key so they dont even have to type the one command they think they need
08:47:31 <StrangeLoop> Ahh
08:47:37 <EvanR> it does*
08:47:38 <rhaps0dy> ($) f x = f x
08:47:43 <StrangeLoop> So you could say it's a piece of sugar?
08:47:55 <Welkin> $ is often used in place of parens
08:47:58 <Cale> StrangeLoop: The main thing about ($) is just that it's defined to have very low precedence (the lowest possible)
08:48:04 <rhaps0dy> EvanR: lol
08:48:06 <Welkin> to eliminate them
08:48:08 <Cale> Yeah, it's pretty much defined sugar
08:48:10 <HeladoDeBrownie> you could definite it yourself actually, but it does exist primarily to make some applications look nicer
08:48:10 <xnull> i feel like
08:48:15 <HeladoDeBrownie> define*
08:48:16 <xnull> ($) f x = (f) (x)
08:48:18 <StrangeLoop> OK cool, thanks
08:48:24 <xnull> well no
08:48:25 <xnull> sorry lol
08:48:30 <rhaps0dy> EvanR: I'll look at it, but I get the feeling the main work is already done: HackageDB
08:48:31 <merijn> :t (.)
08:48:32 <lambdabot> (b -> c) -> (a -> b) -> a -> c
08:48:33 <Cale> Similarly to how  otherwise = True  is defined in the Prelude just to make guards read nicely
08:48:37 <HeladoDeBrownie> xnull, that's true, it just has redundant parens
08:48:41 <xnull> HeladoDeBrownie: yeah
08:48:48 <xnull> i saw that after i pressed enter
08:48:53 <EvanR> rhaps0dy: thats just a big set of packages
08:48:58 <EvanR> there are others
08:49:00 <merijn> StrangeLoop: The type of . can also be written as "(.) :: (b -> c) -> (a -> b) -> (a -> c)"
08:49:04 <EvanR> its not a manager
08:49:08 <rhaps0dy> EvanR: and that's what seems to me like the biggest work, getting the packages done
08:49:16 <merijn> StrangeLoop: i.e. it takes two functions and returns a new function (hence the parenthesis like I wrote)
08:49:21 <xnull> :t sum [fst x | x <- zip [1..] (['a'..'z'] ++ ['A'..'Z']), snd x == 'j']
08:49:22 <lambdabot> (Num a, Enum a) => a
08:49:36 <EvanR> rhaps0dy: the cabal system makes it pretty easy to make a package
08:49:41 <rhaps0dy> Yeah.
08:49:53 <xnull> > sum [fst x | x <- zip [1..] (['a'..'z'] ++ ['A'..'Z']), snd x == 'j']
08:49:54 <lambdabot>  10
08:49:59 <Cale> xnull: Well, that's true, you can write ($) f x = (f) (x), but the parens on the right hand side are unnecessary :)
08:50:02 <StrangeLoop> merijn:Yup, it composes functions. I am trying to think about this like a mathematician
08:50:07 <xnull> Cale: yes i know
08:50:38 <merijn> StrangeLoop: As for the weird operators, haskell allows you to define your own operators, so it's just a matter of learning those in the standard libraries
08:50:44 <rhaps0dy> That's why I'm a bit surprised cabal-install isn't a "package manager"
08:50:58 <merijn> > let (☃) x y = x + y in 3 ☃ 5 -- whooo!
08:51:00 <lambdabot>  8
08:51:05 <Cale> > map head . group . sort $ "mississippi"
08:51:06 <lambdabot>  "imps"
08:51:11 <merijn> rhaps0dy: Because there's not enough people hacking on cabal! :)
08:51:16 <StrangeLoop> I guess it'll grow on me in time. Have been only doing Haskell for, like 45 minutes :D
08:51:31 <merijn> rhaps0dy: Like 80% of the work on cabal is done by like 2-3 people that have fulltime jobs :)
08:52:04 <sebastard> Can I filter inside a list comprehension by using pattern matching? ( Simple example filtering for singletons: [ x | [x] <- xs ] )
08:52:18 <merijn> sebastard: Yup
08:52:28 <Welkin> cabal = Common Architecture for Building Applications and Libraries
08:52:46 <merijn> > [ x | [x] <- [[1],[1,2],[3],[4,5]]]
08:52:47 <EvanR> build system basically
08:52:48 <lambdabot>  [1,3]
08:53:03 <sebastard> I don't understand how it works. Does it rely on the fail behaviour of the list monad?
08:53:23 <Cale> sebastard: The translation of the list comprehension syntax uses a case expression
08:53:27 <merijn> sebastard: list comprehension doesn't use the monad instance (although theoretically it could and it that case, yes)
08:53:34 <merijn> sebastard: See -XMonadComprehensions
08:53:50 <Cale> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11
08:53:58 <Cale> See the section there "Translation"
08:54:07 <merijn> It would work the same way in do-notation and then it DOES use the fail of lists
08:54:27 <Cale> [e | p <- l, Q] = let { ok p = [e | Q]; ok _ = [] } in concatMap ok l
08:54:29 <merijn> > do { [x] <- [[1],[1,2],[3],[4,5]]]; return x }
08:54:30 <lambdabot>  <hint>:1:34: parse error on input ‘]’
08:54:38 <merijn> > do { [x] <- [[1],[1,2],[3],[4,5]]; return x }
08:54:40 <lambdabot>  [1,3]
08:54:52 <Cale> where Q is a sequence of qualifiers, p is a pattern, l is a list, and e is an expression
08:55:33 <sebastard> ok, thanks, that's actually pretty clever and makes for very readable code :D
08:56:50 <rhaps0dy> merijn: oooh
08:56:53 <rhaps0dy> yo lack devs
08:56:56 <rhaps0dy> you*
08:57:14 <rhaps0dy> that's something I may be able to help with :)
08:57:25 <HeladoDeBrownie> sebastard, heheh, i usually think of those two descriptions as opposite
08:57:51 <rhaps0dy> it's not a promise though, and I may not be good enough. We'll see
08:58:06 <HeladoDeBrownie> (that's taking what you said slightly out of context, but i found it funny)
09:00:02 <sebastard> HeladoDeBrownie: yeah I think that Dijkstra would not be pleased by a statement like that, but I think that the syntactic sugar of list comprehensions actually makes the intent of the code more understandable :)
09:00:51 <HeladoDeBrownie> list comprehensions don't get used terribly much in haskell, but yeah, they can be handy
09:01:01 <Cale> I think they're slightly underused
09:01:11 <EvanR> i had a filtering situation the other day where that would have come in handy
09:01:29 <HeladoDeBrownie> when i think "filtering" i usually go for filter
09:01:44 <EvanR> yeah but the condition was "is this version of the sum type"
09:01:46 <merijn> rhaps0dy: Check out #hackage dcoutts is really helpful figuring out the cabal codebase and open to improvements
09:01:52 <EvanR> so i wrote a Bool function against just the constructor
09:01:56 <EvanR> but i didnt have to
09:02:11 <HeladoDeBrownie> EvanR, oh, because of pattern matching
09:02:23 <HeladoDeBrownie> yeah that sounds reasonable
09:02:57 <sebastard> Here I am reconstructing input from some output, but it's non-deterministic
09:03:08 <merijn> > let lefts xs = [x | Left x <- xs] in lefts [Left 1, Right 'c', Left 3, Right 'a']
09:03:10 <lambdabot>  [1,3]
09:03:21 <merijn> EvanR: It is indeed a great trick for that :)
09:03:52 <Cale> rhaps0dy: I was going to say, but I'm not sure I actually hit enter there... cabal-install did have an upgrade feature for a while, but for the most part people ended up getting into lots of trouble using it. Probably if cabal and GHC were better at dealing with multiple builds of the same package version, there would be less of a problem with having something like that.
09:04:29 * HeladoDeBrownie raises list comprehensions in their estimation of potentially good tools for a particular purpose
09:04:31 <Cale> rhaps0dy: An issue you have to contend with is that it doesn't just matter which package and version of everything you have, but which package versions each of those packages were built against.
09:04:46 <Cale> rhaps0dy: It's a bit unfortunate, but packages are not perfectly modular.
09:04:56 <merijn> HeladoDeBrownie: Well, as you saw you can do the same using the monad instance :)
09:05:11 <merijn> HeladoDeBrownie: Join my crusade to remove "fail" from Monad and into MonadZero/MonadPlus :)
09:05:24 <HeladoDeBrownie> merijn, yes but i try not to think about fail :P
09:05:30 <HeladoDeBrownie> yes, sign me up!
09:05:44 <Cale> I think fail should just go in its own class
09:06:24 <hodapp> as if I'd not had fail in enough classes already
09:06:50 <HeladoDeBrownie> hodapp, now it's gotta be in your haskell code too, reminding you, right?
09:07:01 <HeladoDeBrownie> well, not *in* your haskell code. but there. implicitly.
09:07:05 <HeladoDeBrownie> insidiously.
09:07:38 * hodapp sweeps up his silly pun and walks away
09:07:42 <merijn> Cale: What useful laws would that have?
09:08:16 <EvanR> what useful law does it have smushed into the Monad class
09:08:25 <Cale> merijn: none. It'd just be a way to specify the desugaring of do-notation in cases where pattern match failure was possible.
09:08:44 <EvanR> if anything its messing up the Monad classes laws
09:08:58 <Cale> Similarly to what the Enum class does (if you ignore succ and pred)
09:09:26 <merijn> EvanR: It doesn't
09:09:33 <HeladoDeBrownie> though i'm not sure how you're going to fix <- syntax so that you *don't* invoke that constraint by using it
09:09:42 <merijn> EvanR: That's why I mentioned my crusade to move it into MonadZero/MonadPlus
09:09:47 <merijn> EvanR: Because THEN it does
09:10:04 <EvanR> it does have useful laws or it does mess up monad laws
09:10:08 * ski agrees with `MonadFail'
09:10:09 <Cale> HeladoDeBrownie: It's already the case that non-failable patterns don't invoke fail
09:10:14 <merijn> EvanR: It does mess them up
09:10:21 <EvanR> oh good
09:10:22 <HeladoDeBrownie> Cale, oh, neat. it's just not specified in the report then?
09:10:36 <HeladoDeBrownie> Cale, wait wait maybe i misunderstood you
09:10:37 <Cale> HeladoDeBrownie: Which is actually a slight discrepancy vs. Haskell 98 (but not vs. 1.4) that's been in GHC forever.
09:10:57 <HeladoDeBrownie> Cale, can you say what you meant in slightly more detail and/or a different way?
09:11:34 <Cale> Okay, so in Haskell 1.4 (and in modern GHC) there's the notion of a failure-free pattern
09:11:44 <HeladoDeBrownie> aha
09:11:44 <Cale> All irrefutable patterns are failure free
09:11:56 <slomo_> are there any other config file libraries than Data.Configurator, ideally one that automatically checks at runtime if the file changes and gives notifications then. or would i have to build that myself around System.FSNotify? :)
09:12:06 <Cale> If C is the only constructor of its type then C p_1 ... p_n is failure free when each of the p_i is failure free
09:12:17 <Cale> and if p is failure free then so is v @ p
09:12:32 <HeladoDeBrownie> Cale, and desugaring of failure-free patterns isn't a case statement involving fail
09:12:36 <Cale> right
09:12:40 <HeladoDeBrownie> neat
09:12:44 <Cale> It just uses a lambda then
09:14:13 <Cale> This was actually really good, because you'd get notified in cases where you weren't using a MonadZero instance, and, say, a constructor gets added to a datatype that you were matching against in a do-block
09:15:12 <HeladoDeBrownie> was that one of the reasons for introducing that notion or just a happy accident?
09:15:44 <Cale> Well, in Haskell 1.4, fail didn't exist, and mzero was used
09:15:52 <HeladoDeBrownie> ah!
09:15:59 <HeladoDeBrownie> why did they change that?
09:16:06 <Cale> Haskell 98 fucked a lot of things up
09:16:21 <Cale> I think it all started with merging the MonadZero and MonadPlus classes
09:17:09 <Cale> the rationale for which iirc was that there weren't many instances of MonadZero which weren't also instances of MonadPlus
09:17:35 <Cale> and then once that was changed, oh hey, maybe we don't want all of MonadPlus just to let patterns fail
09:17:53 <HeladoDeBrownie> heh
09:18:29 <HeladoDeBrownie> i know it's easier to see that as a mistake from the perspective of now, but i'm guessing that not all of those connections were made back then
09:18:42 <Cale> (This was a bit before my time, but I went through all the mailing list archives)
09:18:48 <Cale> yeah
09:19:05 <Welkin> also, the naming of `return` and do-notation
09:19:06 <Cale> Oh, right
09:19:13 <Cale> There was a step before this one
09:19:18 <Cale> in the failure snowball
09:19:25 <Cale> The removal of monad comprehensions
09:20:01 <Cale> because someone didn't want their students to have to know about Monad and type classes to understand type errors involving list comprehensions
09:20:29 <Cale> Monad comprehensions used guard, which used mzero as well
09:20:55 <Cale> and it was their removal that caused people to get the idea that maybe MonadZero and MonadPlus could be merged
09:24:03 <fractalsea> My program exits with the output: “connect: unsupported operation (Can't assign requested address)”. I literally have no idea where this is coming from. I have  tracked it down to where my print statements stop appearing, but I think it might happen later on, but some prints aren’t being printed due to lazy evaluation. Does anyone know a way of tracking errors down like this?
09:25:24 <HeladoDeBrownie> fractalsea, i don't think "some prints aren’t being printed due to lazy evaluation" is a good explanation of why something might not be printed
09:25:30 <clrnd> fractalsea, something to do with sockets?
09:25:49 <HeladoDeBrownie> fractalsea, what are all the i/o operations you're doing?
09:26:02 <fractalsea> HeladoDeBrownie: OK well I don’t really know, I’m quite new to haskell
09:26:40 <HeladoDeBrownie> fractalsea, it might be best if you show the code and the error message if you want help with this particular error
09:26:53 <HeladoDeBrownie> learning to debug things yourself is important, but can be learned along the way as well
09:27:05 <HeladoDeBrownie> and often it does come down to asking someone else
09:27:07 <fractalsea> clrnd: Could very well be. I’m using Network.WebSockets.runClient, so it could be happening in there
09:27:16 <HeladoDeBrownie> ah, that sounds very likely
09:27:27 <HeladoDeBrownie> what platform are you on?
09:27:29 <clrnd> fractalsea, just a guess, windows?
09:27:33 <HeladoDeBrownie> that was my guess too
09:27:33 <fractalsea> mac
09:27:35 <HeladoDeBrownie> ah
09:27:39 <clrnd> damn :P
09:27:43 <fractalsea> It has worked in the past though
09:28:07 <fractalsea> I guess I just don’t really understand what the error is telling me
09:28:29 <clrnd> fractalsea, well the error is pretty vage, that's not a good error
09:28:31 <HeladoDeBrownie> fractalsea, at a guess, is this only happening shortly after you've run the program before?
09:28:45 <fractalsea> I am also making HTTP requests, and running two HTTP servers, so I thought it could be to do with that too
09:29:09 <fresheyeball1> does anyone have an example of bi-directional marshaling between C++ and Haskell?
09:29:33 <fresheyeball1> I see examples of Struct -> Algebraic
09:29:40 <HeladoDeBrownie> fractalsea, another guess i've made is it could have to do with binding a socket while the socket is still bound.
09:29:45 <fresheyeball1> but not Algebraic -> Struct
09:29:49 <fractalsea> HeladoDeBrownie: Well I have a print statement as the first line in the callback you give to runClient, which isn’t getting printed
09:30:22 <HeladoDeBrownie> fractalsea, that would likely be because runClient is not even getting to that point because of the error, but i can't really tell without seeing your code
09:30:24 <fractalsea> HeladoDeBrownie: hmmm Could be something like that. I’ll look into that
09:31:52 <fractalsea> HeladoDeBrownie: It will be really hard to show you a small example because there is a lot going on currently. I will try and double check it’s not binding multiple times, and will have a go at that if I’m still stuck
09:31:55 <fractalsea> thank you
09:33:20 <HeladoDeBrownie> hmm, although if it's a *client* you're running, that should be the case…
09:33:24 <HeladoDeBrownie> shouldn't*
09:33:37 <HeladoDeBrownie> though i'm not too familiar with web sockets in particular
09:34:30 <HeladoDeBrownie> i don't see any calls to bind or listen in the library code
09:34:32 <nodnormal> hi, im trying to write a ppm-file, and it has some magic numbers in ascii in the beginning and then raw data in binary so i have mixed ByteString.Lazy and ByteString.Lazy.Char8 but don't know if it its possibble to use the same filehandle and write to?
09:34:50 <mmachenry> I'm following this tutorial http://taylor.fausak.me/2014/03/04/haskeleton-a-haskell-project-skeleton/ and trying to get HPC to give me test coverage data but it's just not working. Anyone know why? This is my .cabal file. http://lpaste.net/121447
09:35:24 <mmachenry> I have done cabal install —enable-tests and then cabal test. It runs my test suit just fine but does not produce html or claim that it has done so.
09:35:35 <geekosaur> I think you can get that error if the host you're connecting to only supports IPv4 but it gets an IPv6 address for the host
09:35:44 <geekosaur> er, the host you're connecting *from*
09:36:09 <geekosaur> but this would arguably mean a library bug since it should probably catch this and retry with IPv4
09:36:18 <ChristianS> nodnormal: it's probably best to use ByteString.Lazy and then decode the first x bytes using ascii encoding (or whichever is appropriate)
09:38:08 <clrnd> mmachenry, your cabal file seems to lack the hpc test, isn't it?
09:38:14 <clrnd> doesn't it*
09:38:25 <nodnormal> ChristianS: i have both qualified i  renderToFile fil
09:38:28 <nodnormal> soryr
09:39:08 <nodnormal> i have both qualified imported as L and B i was thinking mixing L.hPut and then B.hPut with the same handle should be okay?
09:41:28 <HeladoDeBrownie> nodnormal, i don't think it's ever necessary to use the hPut from the Char8 module
09:42:00 <HeladoDeBrownie> they appear to be exactly the same in fact
09:42:07 <c_wraith> They should be identical..
09:42:38 <ChristianS> nodnormal: which means, yes you can mix them
09:42:48 <HeladoDeBrownie> (for that matter Char8 is of questionable use)
09:42:50 <c_wraith> nodnormal: mixing L.hPut and B.hPut works and won't explode, but..  may have race condition issues
09:43:08 <mmachenry> clrnd: I think I have -fhpc in there in test
09:43:24 <mmachenry> clrnd: ghc-options: -fhpc
09:43:40 <clrnd> mmachenry, yes bout you are missing the `test-suite hp` entry
09:43:44 <clrnd> hpc*
09:44:27 <mmachenry> clrnd: Oh is that what I should replace my test line with?
09:44:28 <c_wraith> nodnormal: yeah, L.hPut isn't atomic.  Each chunk is printed with its own call to the underlying hPut.  Concurrent access can result in interleaving "single" bytestrings due to that.
09:45:01 <breadmonster> Can someone help me with installing Yesod?
09:45:18 <breadmonster> Ubuntu won't recognize that yesod is installed, even after `cabal install yesod-bin`
09:45:28 <clrnd> mmachenry, no, just add it after hspec, the tutorial you linked it explains it:
09:45:29 <breadmonster> So none of the usual documentation works :(
09:45:30 <clrnd> "Just like the last one, we have to add it to the Cabal file."
09:45:47 <clrnd> breadmonster, are you on a sandbox?
09:46:09 <breadmonster> clrnd: Yes.
09:46:17 <breadmonster> Is there some special way to run it from inside a sandbox?
09:46:32 <c_wraith> breadmonster: try cabal exec
09:46:40 <clrnd> breadmonster, yes, cabal exec, but I think you still need to add the bin to your path
09:46:53 <nodnormal> c_wraith: but L.hPut and B.hPut is only two lines apart and in the same do block, still not good?
09:47:15 <c_wraith> nodnormal: ah.  that's serial, not concurrent.  You'll be fine unless threads get involved
09:47:47 <nodnormal> okay great
10:01:11 <besenwesen> huh, i built a library (sdl-ttf), and the build succeded, but when ghc loads that library later on it says it can’t because the library has undefined symbols
10:02:24 <besenwesen> an't load .so/.DLL for: …/.cabal-sandbox/lib/x86_64-linux-ghc-7.8.4/SDL-ttf-0.6.2/libHSSDL-ttf-0.6.2-ghc7.8.4.so (…/.cabal-sandbox/lib/x86_64-linux-ghc-7.8.4/SDL-ttf-0.6.2/libHSSDL-ttf-0.6.2-ghc7.8.4.so: undefined symbol: TTF_CloseFont)
10:02:29 <mmachenry> clrnd: I'm having a really hard time following this tutorial I guess.
10:02:54 <clrnd> mmachenry, did you find the lines you need to add to your .cabal?
10:03:08 <mmachenry> He said he changed the test-suit, then gave a new line of cabal, the rewrote the test-suite into a new file, then gave more cabal lines and I don't know which are additive.
10:03:21 <mmachenry> clrnd: Yeah I think so but it doesn't work.
10:03:39 <HeladoDeBrownie> besenwesen, do you have the appropriate c -dev library installed?
10:03:48 <HeladoDeBrownie> i think it might require that, anyway
10:03:49 <clrnd> mmachenry, lets see your cabal file now
10:04:19 <besenwesen> HeladoDeBrownie, you mean whether i have the complementary native SDL library installed?
10:04:28 <HeladoDeBrownie> besenwesen, yeah
10:04:28 <besenwesen> i do
10:04:45 <mmachenry> One sec.
10:05:36 <mmachenry> clrnd: For some reason it wants a bunch of new packages.
10:05:42 * hackagebot gravatar 0.7 - Look up gravatar image urls by email address  http://hackage.haskell.org/package/gravatar-0.7 (PatrickBrisbin)
10:05:49 <mmachenry> I can fix those errors easily but I can't understand why I should need to
10:06:06 <mmachenry> Want me to fix them and then paste or just give you the not working file?
10:06:14 <Big_G> When a closure is created, does it only grab the values it needs or all of them?
10:06:48 <clrnd> mmachenry, well the new test-suite needs new packages, right? build-depends: process, etc
10:07:06 <clrnd> it means its working :P
10:07:25 <clrnd> mmachenry, install the packages, and lets see what happens
10:07:32 <StrangeLoop> http://lpaste.net/121448 <--- Can anyone explain this error to me?
10:07:48 <mmachenry> clrnd: I'm about to cut and paste my entire dependency list for library into test-suite hpc
10:08:19 <mmachenry> Sound reasonable? It doesn't to me but doing so I think will advance past the errors I'm getting, likely in the wrong way.
10:08:21 <clrnd> mmachenry, wait, why?
10:08:33 <mmachenry> Because it says "I need hashtable"
10:08:41 <clrnd> mmachenry, you just need to install the dependencies in build-depends
10:08:45 <clrnd> install them with cabal install
10:08:45 <mmachenry> And I add hashtable to my test suite and then it says "I need marray"
10:08:55 <mmachenry> clrnd: I have installed them
10:09:06 <mmachenry> But now it's telling me that it needs them in the dependencies
10:09:08 <clrnd> mmachenry, mmm let me see the cabal file, I'm no cabal master anyway
10:09:32 <mmachenry> http://lpaste.net/121450
10:09:34 <geekosaur> StrangeLoop, I don't get that error here. did you indent with tabs?
10:09:44 <StrangeLoop> Yes, does that matter?
10:09:49 <mmachenry> That's the error clrnd, cabal coming right up
10:10:14 <geekosaur> StrangeLoop, yes, it matters to the extent that tabs may mean something different in your editor vs. the compiler
10:10:27 <geekosaur> (and the browser for that matter, when you paste your code)
10:10:37 <StrangeLoop> Isn't GHC whitespace agnostic or something?
10:11:21 <StrangeLoop> Anyway, I removed the indentations and get the same error
10:11:36 <geekosaur> otherwise I do not know since it works here
10:11:45 <mmachenry> clrnd: http://lpaste.net/121447 I added some of the libs
10:12:01 <StrangeLoop> Oh weird
10:12:03 <geekosaur> tabs are never "agnostic". mnobody ever agrees what a tab *is*
10:12:13 <phaul> StrangeLoop: even then your patterns would overlap as (b:ax) matches a single element list with ax == []
10:12:33 <StrangeLoop> Yeah, but a lot of compiles don't care about either
10:12:50 <geekosaur> a lot of languages don't use indentation as syntax
10:12:55 <geekosaur> python and haskell are two which do
10:13:01 <StrangeLoop> I didn't know haskell does
10:13:18 <StrangeLoop> I'm, like, five chapters into the book and it was never mentioned :/
10:13:21 <hodapp> so, take a look at: http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#deftypes.block
10:13:38 <hodapp> in this instance ('explicit structuring') does whitespace still matter?
10:13:42 <geekosaur> 5 chapters in and nothing about layout?
10:14:04 <hodapp> I have tried to get some sense of 'explicit structuring' in Haskell but I've only seen RWH make reference to it
10:14:16 <geekosaur> braces disable layout
10:14:25 <StrangeLoop> Nothing about indentation having a syntactic role. Maybe it was mentioned somewhere but it was definitely not discussed
10:14:32 <geekosaur> they also complicate things because for example a let inside a do will reintroduce layout, and if you
10:14:48 <geekosaur>  are using braces you will need extra ones around the let bindings
10:14:56 <phaul> StrangeLoop: ignore what I said, I see what you are doing
10:14:59 <Welkin> line up the first character of each line in the same block
10:15:05 <hodapp> geekosaur: any kind of citation on that? I'm not doubting you, I just would like to have something more explicit on it than RWH's blurb
10:15:25 <clrnd> mmachenry, but, you should only need to depend on your own library
10:15:39 <clrnd> build-depends: throttlecontroller, etc
10:15:50 <mmachenry> clrnd: I did and that doesn't seem to work.
10:16:00 <clrnd> mmachenry, what does it say?
10:16:22 <geekosaur> hodapp: https://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17800010.3 explains layout in terms of the braced constructs it translates to
10:16:29 <hodapp> geekosaur: thanks
10:17:26 <StrangeLoop> OK weird, according to the wikibook the amount of tabs doesn't matter as long as each scope is further in and homogeneous
10:17:48 <StrangeLoop> But when I use any number of tabs other than three I get error messages
10:17:54 <hodapp> I suppose that'd be easier to find if 'explicit structuring' were a standard term
10:17:59 <geekosaur> (note that GHC follows slightly different rules than the standard, for example slightly relaxed rules for do block indentation and the DoAndIfThenElse extension (which I think is on now by default?)
10:18:30 <StrangeLoop> I am waaaay to new to Haskell to need to worry about these nuances
10:18:59 <geekosaur> StrangeLoop, note that if the patterns on lines 4 and 5 are indented more than the pattern on line 3 then they are parsed as *continuations of the expression on line 3*
10:19:10 <geekosaur> not as patterns. then -> will indeed be an error
10:20:11 <StrangeLoop> How do you define "how much" the pattern on line 3 is indented?
10:20:32 <mmachenry> clrnd: It said the error I pasted.
10:20:41 <mmachenry> That it needs certain libraries in the depends list
10:20:43 * hackagebot MonadCompose 0.8.2.0 - Methods for composing monads.  http://hackage.haskell.org/package/MonadCompose-0.8.2.0 (JamesCandy)
10:21:34 <StrangeLoop> I also get an error for two tabs whereas I don't get one for three tabs. I'll write that off as a paranormal phenomenon and just keep marching on, I guess
10:22:15 <fizbin> StrangeLoop: The general haskell practice is to never use tabs (meaning tab characters) ever, and configure your editor to convert to spaces.
10:22:31 <StrangeLoop> OK, is there a convention as to haw many spaces?
10:22:54 <StrangeLoop> Like, the Pythonites are very pious about their two space tab
10:22:58 <clrnd> mmachenry, "hs-source-dirs: tests, src", shouldn't it just be "tests"?
10:23:26 <glguy> StrangeLoop: Make sure your editor knows that tabstops are 8 spaces
10:24:14 <kadoban> StrangeLoop: 2 or 4 spaces seem common
10:24:37 <mmachenry> In the tutorial he adds library.
10:25:43 * hackagebot diversity 0.4.0.0 - Return the diversity at each position for all sequences in a fasta file  http://hackage.haskell.org/package/diversity-0.4.0.0 (GregorySchwartz)
10:26:33 <Welkin> use haskell-mode for emacs
10:27:00 <StrangeLoop> Is there a name for the $ operator?
10:28:47 <Welkin> function application
10:29:10 <StrangeLoop> And is there something similar to $ for a function with two arguments? Is there a way to rewrite "(print.elem) 3 [1,2,3]"?
10:29:31 <Welkin> use it twice
10:29:52 <Welkin> every function is partially applied and takes one parameter
10:30:18 <StrangeLoop> So using $ on a function with several parameters should be thought of as a projection?
10:30:34 <Iceland_jack> > let (.:) = fmap.fmap in (print .: elem) 3 [1,2,3]
10:30:36 <lambdabot>  <IO ()>
10:31:06 <exio4> @type (print .) . elem
10:31:07 <lambdabot> Eq a => a -> [a] -> IO ()
10:31:16 <Iceland_jack> An uglier way of writing it is "(print .) . elem"
10:31:18 <Iceland_jack> @pl \x xs -> print (elem x xs)
10:31:18 <lambdabot> (print .) . elem
10:31:27 <exio4> you normally don't want that, though
10:31:28 <Iceland_jack> As exio4 already pointed out
10:32:45 <StrangeLoop> So what is the suggested way to apply a composition of a two variable function on a one variable function?
10:33:00 <StrangeLoop> such as print.elem
10:33:40 <exio4> StrangeLoop: \x xs -> print (elem x xs)
10:33:46 <Iceland_jack> StrangeLoop: My suggestion would be not to write it as a composition of functions
10:33:46 <Iceland_jack>  
10:34:13 <StrangeLoop> Iceland_jack: So what would you write it as?
10:34:24 <StrangeLoop> I am trying to adopt good habits here
10:34:42 <Iceland_jack> What exio4 wrote
10:35:20 <exio4> StrangeLoop: it depends on _which_ function is, where you are using, or whatever, a "mixed" example may be something like "\f -> fun1 . map f"  (in this case, it doesn't make that much sense)
10:35:47 <StrangeLoop> OK, thanks
10:35:54 <exio4> StrangeLoop: function composition is cool when it makes the code easier to read, not everywhere!
10:36:21 <StrangeLoop> I just don't understand what alternatives are there.
10:36:41 <exio4> @pl \f y h g x -> g <$> f (h x) <*> h (f y)
10:36:41 <lambdabot> ((flip ((.) . (<$>)) .) .) . ap ((.) . ap . ((flip . ((<*>) .)) .) . (.)) (flip id .)
10:37:09 <Iceland_jack> Using composition (point free) makes sense in the following case
10:37:09 <Iceland_jack>     print = putStrLn . show
10:37:09 <Iceland_jack> rather than
10:37:09 <Iceland_jack>     print x = putStrLn (show x)
10:37:11 <exio4> ^ a nice example of an evil point-free version :P
10:37:16 <StrangeLoop> The only reason I have to compose function, at this moment, is so that I could print the outputs of the simple functions I am actually writing. I guess it will become clearer when I actually get to that part
10:37:27 <Hijiri> @pl badtyped a = a a
10:37:27 <lambdabot> badtyped = join id
10:37:45 <Hijiri> :t join id
10:37:46 <lambdabot>     Occurs check: cannot construct the infinite type: a1 ~ a1 -> a
10:37:46 <lambdabot>     Expected type: a1 -> a1 -> a
10:37:46 <lambdabot>       Actual type: a1 -> a1
10:42:36 <ocharles_> bergmark: thanks!
10:42:56 <ocharles_> err
10:43:01 <ocharles_> bernalex: thanks!
10:45:30 <lpaste> nodnormal pasted “render is infinite loop” at http://lpaste.net/121455
10:46:35 <nodnormal> can someone please point me in the right direction
10:47:31 <SrPx> How do I search for a substring on a Text element?
10:47:42 <nodnormal> i've tried to debug with ghci, but i dont really know how... all i know is sometimes it gets a hit in the set and sometimes not, it's just loooping infinitely
10:49:28 <bergmark> ocharles_: yw!
10:49:32 <StrangeLoop> Wheee quicksort in 3 lines. As a former C/Java developer I can't tell you how happy this makes me
10:49:59 <hiptobecubic> StrangeLoop, you mean the not-real-quicksort quicksort?
10:50:13 <mauke> ("not real" because it's not in place)
10:50:21 <kadoban> StrangeLoop: It's probably not really a very good sort in practice though. People only use quicksort because it's in-place and the constants are…amazing. Neither is probably true of a haskell implementation like that.
10:50:22 <mauke> otherwise completely real
10:50:47 <StrangeLoop> I think the time complexity ought to be similar, up to allocation overhead
10:51:01 <StrangeLoop> But I see your point
10:51:20 <mmachenry> clrnd: I have copied the cabal file from the github repo of the tutorial author and I'm still getting stuff saying I need to have all the dependencies in my test suite :(
10:51:21 <kadoban> StrangeLoop: The asymptotic complexity is easy to get similar…but that doesn't mean much. The constants will be ridiculously bad in a naive implementation.
10:51:31 <hiptobecubic> mauke, I guess? Not that anyone cares because of what kadoban mentioned. As an side, it's actually a tree-sort in this case, though, isn't it?
10:51:37 <hiptobecubic> an aside*
10:51:46 <clrnd> mmachenry, hm, I honestly don't know what is going on, cabal version?
10:51:55 <exio4> kadoban: is it? (++) is O(n) on the first list
10:52:03 <mmachenry> cabal-install version 1.20.0.3
10:52:10 <mmachenry> Perhaps I should try to upgrade to 1.22
10:52:32 <clrnd> mmachenry, I don't know, sorry, if it's no big deal try it
10:52:47 <kadoban> exio4: I thought so? quicksort is O(n) on each recursion level anyway, so I don't think an extra O(n) hurts, unless I'm missing something.
10:53:01 <StrangeLoop> That shouldn't matter
10:53:06 <mauke> hiptobecubic: what's tree sort?
10:53:11 <StrangeLoop> At least not asymptotically
10:53:15 <mauke> and AFAIK the complexity is exactly the same
10:53:16 <kadoban> (the partition step is O(n), so I don't think it matters to the asymptotic complexity if you do another O(n) to combine)
10:53:31 <mauke> O(n log n) average, O(n^2) worst case
10:53:59 <hiptobecubic> mauke, http://stackoverflow.com/a/11357450/913893
10:54:13 <exio4> kadoban: hm, right
10:54:18 <hiptobecubic> assuming that's the implementation we're all talking about
10:54:36 <StrangeLoop> I made my own implementation, but how surprising can it get?
10:55:11 <StrangeLoop> http://lpaste.net/121456
10:55:30 <hiptobecubic> mauke, also http://www.reddit.com/r/programming/comments/2h0j2/real_quicksort_in_haskell/c2h196
10:56:01 <kadoban> StrangeLoop: You can use pattern matches directly in the function definition instead of in a 'case'. That'd look just a tad better.
10:56:01 <mauke> hiptobecubic: that seems to apply to the original quicksort as well
10:56:07 <mauke> an in-place deforested tree sort
10:56:12 <StrangeLoop> Yup, virtually identical
10:56:28 <StrangeLoop> kadoban:Using guards?
10:56:40 <StrangeLoop> (Never heard of a "tree sort")
10:56:56 <kadoban> StrangeLoop: No, just pattern matches, pretty much exactly what you have except without the 'case'
10:57:33 <StrangeLoop> OK, thanks
10:58:32 <dolio> I think the simpler statement is, "people don't use quicksort."
10:58:36 <hiptobecubic> mauke, it does seem that way, yes. Apparently, I don't know enough to distinguish between them, although conor and augustss apparently do.
10:58:37 <kadoban> StrangeLoop: http://lpaste.net/121456 <-- like that (untested)
10:59:49 <StrangeLoop> Couldn't line 3 just be "qs [_] = x"? Anyway, I thought the "case" syntax is tidier because you don't have to repeat the function name for every case
11:00:04 <kadoban> dolio: Well, variations on quicksort (to get rid of the worst case and sometimes improve common cases) used to be quite popular in some other language standard libraries
11:00:04 <mauke> no, then x would be undefined
11:00:12 <mauke> qs [x] = [x] would work, though
11:00:32 <StrangeLoop> Sorry, I meant gs [x] = [x]
11:00:36 <kadoban> You could also just skip that case, at a minor peformance penalty.
11:00:37 <StrangeLoop> *qs
11:00:45 * hackagebot debian 3.87 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.87 (DavidFox)
11:00:49 <kadoban> Oh wait, no you can't.
11:00:57 <dolio> Maybe C and C++ still use it.
11:00:58 <mauke> I, too, like to use case/of instead of repeating the function name
11:01:00 <StrangeLoop> That's another reason I like the case syntax better, I don't have to name the element in the case of a one element list
11:01:09 <dolio> I'm not sure what C actually has under the hood.
11:01:13 <dolio> Or, gcc.
11:01:20 <mauke> *glibc
11:01:20 <StrangeLoop> I don't like naming things I don't need to use
11:01:30 <dolio> Yeah.
11:01:36 <hiptobecubic> isn't timsort just quicksort with some help for the pathological cases?
11:01:44 <dolio> No, timsort is merge sort.
11:01:47 <nodnormal> http://lpaste.net/121455 can someone please point me in the right direction?
11:01:49 <kadoban> StrangeLoop: Hmm, that code has some pretty bad performance on….lists that have lots of repeated elements I think. Like [1, 1, 1, 1, 1, 1], etc.
11:01:56 <hiptobecubic> dolio, ah. ok.
11:02:01 <mauke> timsort is also broken, apparently :-)
11:02:13 <kadoban> StrangeLoop: Ehh, disregard that, it's obviously not tuned or anything, so it's a dumb complaint.
11:02:22 <dolio> The people that found the problem also fixed it.
11:02:26 <StrangeLoop> kadoban: Well, its not optimized at all. I'm practicing Haskell not sorting
11:03:36 <StrangeLoop> In practice my sorting algorithms goes a little something like "have gcc sort this for me"
11:03:39 <dukerutledge> Hey, does anyone know the current process for GHC bug submission?
11:03:44 <dukerutledge> Is it still Trac?
11:03:48 <dukerutledge> or Phabricator?
11:03:48 <bergmark> dukerutledge: yes
11:03:51 <dukerutledge> thanks
11:04:05 <kadoban> StrangeLoop: Heh, yeah.
11:04:05 <monochrom> I think it's still Trac
11:04:20 <StrangeLoop> I don't do practice anymore, I'm a theorist :P
11:04:24 <bergmark> i think they use phabricator for code reviews and such
11:04:31 <dolio> Yes.
11:04:35 <phaul> I watched a video on youtube or vimeo a while ago about uniplate. I think NeilM did the presentation. I can't find it, does anyone know the link? google is not giving me anything
11:05:00 <bergmark> phaul: the haskell exchange one?
11:05:06 <phaul> maybe
11:05:16 <bergmark> i think you need to register on that site to watch it now
11:05:28 <kadoban> StrangeLoop: In terms of naming things you're not going to use…in the case way, you just name it always so I'm not sure how that's better.
11:05:33 <phaul> bergmark: ah, ok. thanks
11:05:45 * hackagebot gravatar 0.7.1 - Generate Gravatar image URLs  http://hackage.haskell.org/package/gravatar-0.7.1 (PatrickBrisbin)
11:06:03 <StrangeLoop> I dunno, in "case x of [_] = x" I don't name anything
11:06:14 <StrangeLoop> *-> x
11:06:21 <dolio> I think glibc's STL in-place sort is also a quicksort derivative. The question is whether people bother using that for any reason other than it probably being a shorter name.
11:06:39 <StrangeLoop> I think it's a randomized quicksort3
11:06:52 <StrangeLoop> Or at least it was at some point
11:07:10 <dolio> I thought it was introsort, because that was specifically made for the C++ stl.
11:07:13 <dolio> But maybe it isn't.
11:07:33 <StrangeLoop> I am no authority on the subject :)
11:08:03 <dolio> Anyhow, introsort in vector-algorithms isn't faster than merge sort on anything, I think.
11:08:12 <kadoban> I think it used to be, but probably has gotten modified a bit by now. I know python's used to be timsort, which I think is…like introsort with some additions to take care of already-sorted-ranges or something.
11:08:41 <dolio> No, timsort is merge sort with fancy extra stuff.
11:08:51 <kadoban> Oh, crap right yeah it is…
11:08:55 <StrangeLoop> Is it generally true that I should think about a multivariate function as a single variable function which gets a variable and returns a projection?
11:08:56 <Welkin> timsort is a merge sort with an insertion sort at the last iteration
11:09:43 <hannes___> StrangeLoop: what is a multivariate function?
11:09:48 <dolio> Switching over to random quicksort makes some sense, maybe. That way you don't also have to have heapsort written.
11:09:55 <StrangeLoop> A function with several variables
11:10:05 <StrangeLoop> Like, I dunno, min
11:10:09 <dolio> Although maybe STL is required to have heaps anyway, so maybe it doesn't save anything.
11:10:36 <HeladoDeBrownie> StrangeLoop, every haskell function has precisely one input and one output. we may talk about a function "of multiple parameters" but it's usually a function with one parameter and returning another function.
11:10:38 <hannes___> StrangeLoop: well, in haskell a -> b -> c really parses as a -> (b -> c) so yes.
11:10:45 * hackagebot pretty-show 1.6.8.1 - Tools for working with derived `Show` instances and generic  inspection of values.  http://hackage.haskell.org/package/pretty-show-1.6.8.1 (IavorDiatchki)
11:10:48 <StrangeLoop> OK, cool
11:11:18 <StrangeLoop> So it's like Lambda ca.... OHhhhh! So that's why there are lambdas everywhere!
11:11:21 <HeladoDeBrownie> :D
11:11:45 <leohaskell> Hello mates
11:11:53 * StrangeLoop feels stupid
11:11:54 <hannes___> StrangeLoop: it's also why it's called haskell
11:12:09 <HeladoDeBrownie> StrangeLoop, what do you mean, that took brainpower to deduce on your own
11:12:14 <leohaskell> I saw that haskell.org is one of the mentoring organizations at GSoC
11:12:23 <ocharles_> urgh, sometimes I really wish Haskell had scoped imports :(
11:12:36 <grek> http://lurn.amlaz.ru/566422/2224440/
11:12:59 <StrangeLoop> Weird, I've never heard of this Haskell guy, and I consider myself very well read in mathematical logic
11:14:32 <HeladoDeBrownie> he also lends his name to the concept of currying
11:15:31 <StrangeLoop> Yup, makes sense
11:15:41 <StrangeLoop> Cool, I knew taking up Haskell would be beneficial!
11:15:46 * hackagebot debian 3.87.1 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.87.1 (DavidFox)
11:16:29 <ReinH> StrangeLoop: Curry is kind of a big deal.
11:16:36 <StrangeLoop> Seems so
11:17:01 <StrangeLoop> I mean, I know about Lambda calculus, and about Currying, so I am not completely oblivious to him or his work
11:17:07 <mauke> Schönfinkel!
11:17:16 <StrangeLoop> But I never knew about the connection, or that he was called Haskell
11:17:25 <hannes___> I was actually really surprised when I first found out it had nothing to do with indian food
11:17:51 <StrangeLoop> When I first heard of it I thought it morphed out of "carrying" like in "carry the two"
11:17:58 <HeladoDeBrownie> mauke, what was the name of that package again?
11:18:10 <mauke> HeladoDeBrownie: what package?
11:18:21 <HeladoDeBrownie> mauke, the one with the schönfinkel operation
11:18:30 <ReinH> HeladoDeBrownie: Uh. Control.Applicative? ;)
11:18:33 <mauke> StrangeLoop: heh. do you know the origins of "thunk"?
11:18:35 <leohaskell> (09:09:56 PM) leohaskell: Hello mates
11:18:36 <leohaskell> (09:10:24 PM) leohaskell: I saw that haskell.org is one of the mentoring organizations at GSoC
11:18:36 <leohaskell> So, do somebody knows whom should I turn to, if I want to participate?
11:18:41 <mauke> HeladoDeBrownie: never heard of it
11:18:52 <HeladoDeBrownie> maybe i'm confusing names.
11:18:56 <shachaf> leohaskell: See #haskell-gsoc
11:19:05 <HeladoDeBrownie> found it http://hackage.haskell.org/package/acme-schoenfinkel
11:19:19 <StrangeLoop> mauke: Nope
11:19:22 <leohaskell> shachaf: cheers :)
11:19:24 <hannes___> leohaskell: not here, I guess. I don't think there are that many people from haskell.org here
11:19:40 <ReinH> HeladoDeBrownie: Oh. That. )
11:19:46 <leohaskell> okay, thank you guys
11:20:07 <HeladoDeBrownie> ReinH, what were you thinking of? :P
11:20:19 <mauke> hahaha, "hässlich"
11:21:04 <HeladoDeBrownie> yeah, nice opposite to schön :P
11:21:22 <StrangeLoop> Do any of you use Haskell for mathematical programming?
11:21:23 <HeladoDeBrownie> and it's true, it makes them more hässlich :P
11:21:24 <mauke> StrangeLoop: http://zvon.org/comp/r/ref-Jargon_file.html#Terms~thunk last paragraph
11:21:26 <ReinH> HeladoDeBrownie: SK combinators
11:21:40 <StrangeLoop> Oh wow, the Jargon file
11:21:42 <ReinH> HeladoDeBrownie: e.g., (<*>) and pure for ((->) e) Applicative.
11:21:51 <HeladoDeBrownie> ReinH, ah yeah
11:21:57 <StrangeLoop> That takes me back to the days before I know how to code so I thought programming was uber 1337
11:22:03 <HeladoDeBrownie> i actually didn't know about the connection between that name and combinatory logic previously
11:22:32 <HeladoDeBrownie> although strictly speaking only S is in Control.Applictaive, afair
11:22:40 <ReinH> HeladoDeBrownie: pure is const
11:22:40 <HeladoDeBrownie> K and I are in Prelude (among other places?)
11:22:43 <ReinH> for ((->) e)
11:22:43 <HeladoDeBrownie> oh, right
11:23:05 <StrangeLoop> mauke: Lol
11:23:09 <ReinH> HeladoDeBrownie: (settings aside the fact that this is typed for a moment)
11:23:14 <ReinH> *setting
11:23:17 <HeladoDeBrownie> sure
11:23:21 <StrangeLoop> The sound of data hitting the stack, jeez
11:24:05 <nerium> Is there a better way to handle Maybe's wrapped in an IO in haskell?
11:24:10 <nerium> https://gist.github.com/oleander/f028f61b0288c08efd4d
11:24:43 <bergmark> nerium: MaybeT
11:24:52 <glguy> nerium: http://hackage.haskell.org/package/transformers-0.4.2.0/docs/Control-Monad-Trans-Maybe.html
11:25:54 <nerium> bergmark: Any example of how that can be used?
11:26:03 <nerium> The manual looks a bit daunting
11:27:14 <ReinH> nerium: http://en.wikibooks.org/wiki/Haskell/Monad_transformers#A_simple_monad_transformer:_MaybeT
11:28:54 <sebastianrkg> How can I pattern match on an existentially quantified parameter?
11:29:34 <ReinH> sebastianrkg: you can only pattern match on data constructors.
11:29:47 <nerium> ReinH: Thanks!
11:30:14 <hannes___> sebastianrkg: what kind of pattern would that much? If it's quantified you have no idea what your thing even is
11:30:42 <sebastianrkg> well I know that it can be one of several different things that follow the class contraint
11:30:45 <Iceland_jack> sebastianrkg: You can using PatternSynonyms and by judicious use of type classes, but in general you can't
11:31:01 <sebastianrkg> how can I unpack a existentially quantified parameter then?
11:31:17 <ReinH> sebastianrkg: You can't
11:31:20 <ReinH> There's nothing to unpack.
11:31:25 <sebastianrkg> If I have a complex type like Box {x= ..., y = ..., z = ...}
11:31:26 <clrnd> well, any idea how can I compile haskell-src-exts with only 1GB of RAM?
11:31:34 <sebastianrkg> and another similar Circle type
11:31:44 <hannes___> sebastianrkg: you throw away type information. You can't get stuff you have thrown away back
11:32:00 <sebastianrkg> and then some function is of type forall s (Shape s) => ...
11:32:02 <hannes___> sebastianrkg: that sounds like you really shouldn't be using existentially quantified types?
11:32:07 <HeladoDeBrownie> sebastianrkg, you can only use it as a Shape
11:32:13 <ReinH> sebastianrkg: I'm confused about what you mean by 'existential type' here. Can you show us some code?
11:32:19 <ReinH> Ah.
11:32:28 <hannes___> ReinH: I think he just means class constraint, huh.
11:32:43 <ReinH> sebastianrkg: That doesn't appear to be an existential, but it isn't a complete expression so I can't say for sure
11:33:23 <hannes___> sebastianrkg: If the number of things is fixed anyway, why not `data Shape = ShapeTypeA | ShapeTypeB ...` ?
11:33:45 <hodapp> clrnd: ...lots of swap?
11:33:48 <ReinH> sebastianrkg: Constrained polymorphism only allows you to use members of the typeclass.
11:34:10 <ReinH> There are no constructors available to pattern match on.
11:34:21 <sebastianrkg> I'm not the team member who is making the part of the program that has the only-class-contrained-and-not-typed parameter, unfortunately
11:34:25 <clrnd> hodapp, hahaha, yeah, damnnnnn
11:34:33 <hodapp> even that doesn't always work
11:34:48 <ReinH> sebastianrkg: I still don't think you have an existential at all.
11:34:53 <ReinH> Can you show us some code?
11:35:08 <sebastianrkg> I could try to anonymize some code for you guys, but it's really exactly the same as what I said above
11:35:14 <sebastianrkg> I have Boxes and Circles
11:35:25 <sebastianrkg> and a function has constrained a parameter to be a Shape
11:35:26 <ReinH> sebastianrkg: What is the actual type of the function in question?
11:35:36 <sebastianrkg> And I want to see what the Shape is
11:35:38 <ReinH> It matters where the forall is.
11:35:46 <hannes___> sebastianrkg: you can't
11:35:47 * hackagebot pgdl 7.6 - pgdownloader  http://hackage.haskell.org/package/pgdl-7.6 (sifmelcara)
11:35:52 <sebastianrkg> I think, looking now, that the forall is implicit
11:36:12 <sebastianrkg> just the normal like... way that Haskell expands out lowercases in type signatures
11:36:12 <ReinH> sebastianrkg: When you declde a function of type forall a. Shape a => ..., you are stating that you *cannot* know which instance of Shape it is
11:36:23 <ReinH> It is *for all a such that a is a member of the Shape typeclasS*
11:36:47 <sebastianrkg> ah. Okay. Well then I'm going to need to rethink many things, I guess! But that helps a lot, and actually makes a lot of sense
11:37:08 <ReinH> *declare
11:37:26 <sebastianrkg> thanks ReinH & hannes___ & HeladoDeBrownie & Iceland_jack
11:37:34 <ReinH> sebastianrkg: A sum type would be a better choice here, so perhaps you should take that back to the team member that made the decision
11:38:05 <ReinH> The only thing you can do with `a' in a function of type Shape a => ... is use the typeclass member functions on it
11:38:05 <hannes___> sebastianrkg: yep, sounds like he thought he could use type classes for OO-ness, but they don't work like that
11:39:01 <ReinH> And btw, implicit quantifications in Haskell are universal
11:39:08 <nerium> I feels like I'm misusing the MaybeT monad https://gist.github.com/oleander/7a899d8037de859adf82
11:39:12 <hannes___> ReinH: he's already gone :(
11:39:18 <ReinH> Oh. Oh well.
11:39:25 <HeladoDeBrownie> one way to think about typeclasses that may help is that classes are datatypes, instances are privileged values, and typeclass constraints are implicit parameters that get passed such a value if it can be found
11:39:26 <nerium> Shouldn't <- "unwrap" it?
11:39:38 <HeladoDeBrownie> (they're actually implemented like this from what i hear)
11:39:50 <ReinH> nerium: wrap doesn't go "from IO to Maybe"
11:39:55 <hannes___> nerium: runMaybeT
11:39:58 <ReinH> wrap goes from a to MaybeT IO a
11:40:14 <Cale> nerium: That's clearly a type error since main is required to be of type IO a for some a
11:40:21 <hannes___> nerium: main needs to be of type IO a, not MaybeT IO a
11:40:22 <Hijiri> wraps are a generalization of burritos
11:40:30 <ReinH> Or, in this case, from String -> MaybeT IO String, as you've specialized it
11:40:46 <Cale> nerium: So  wrap "ok" :: MaybeT IO String  which isn't of type  IO t  is not allowed to be executed there.
11:41:05 <ReinH> Hijiri: well done
11:42:06 --- mode: ChanServ set +o mauke
11:42:06 --- kick: ParmesanCaesar was kicked by mauke (you're banned)
11:42:32 <nerium> Cale: I trought that idea was that <- "unpacked" it to string and then return wrapped in into an IO
11:42:54 <HeladoDeBrownie> nerium, <- does not unpack, it merely gives a name to the result.
11:42:59 <Cale> nerium: Inside a do-block,  v <- x means  "execute the action x, and call its result v"
11:43:19 <Cale> If x :: m a, then v :: a, and the do-block as a whole then has type m t for possibly some other type t
11:43:20 <tdammers> v <- x on its own doesn't even mean anything
11:43:34 <tdammers> v <- x; foo v -- means x >>= foo
11:43:50 <tdammers> or maybe: x >>= \v -> foo v -- if you prefer
11:44:03 <Cale> x >>= foo means "execute the action x, getting some result v and then execute foo v"
11:44:06 --- mode: mauke set -o mauke
11:44:29 <tdammers> yes, except that it doesn't give a name to v
11:44:43 <nerium> v <- x in the case of Maybe would unbox it and pass it to the sec line, unless Nothing. Isn't that correct?
11:44:48 <Cale> You can understand (>>=) in terms of do-notation or you can understand do-notation in terms of (>>=), whatever works best for you.
11:45:14 <hannes___> nerium: the problem here is that your `x` is of type `MaybeT IO a` instead of `IO a`
11:45:17 <Cale> Effectively, yeah, if x = Just u, then v = u
11:45:29 <Cale> if x = Nothing, then the entire do-block is Nothing
11:45:53 <nerium> Cale: Exactly, that's what I want
11:46:10 <Cale> nerium: Your problem is that main :: IO ()
11:46:18 <Cale> nerium: Not Maybe ()
11:46:31 <Cale> and also not MaybeT IO ()
11:46:39 <nerium> True
11:47:40 <hannes___> nerium: you just need runMaybeT here - `runMaybeT :: MaybeT m a -> m (Maybe a)`
11:48:23 <hannes___> in your case, MaybeT IO String -> IO (Maybe String)
11:48:29 <nerium> aha
11:49:58 <nerium> :hannes___ Aha, not I get it
11:49:59 <nerium> thanks
11:51:55 <StrangeLoop> OK I have another one, http://lpaste.net/121459 <-- Why do I get a "non exhaustive" error here? How is line 4 not covering all cases?
11:52:05 <mmachenry> clrnd: I have new updates, with better results, but still not great. If you're not sick of me yet here's my new cabal file http://lpaste.net/121447
11:52:10 <StrangeLoop> Oh, a typo nevermind :/
11:52:32 <clrnd> mmachenry, if you are not sick of me, I'll look at it :P
11:52:34 <lpsmith> meh,  time to ditch Ubuntu Unity again.   I stayed with it a week this time,  instead of a day or two.
11:52:40 <Cale> lpsmith: haha
11:52:49 <lpsmith> oops,  wrong channel,  in any case :)
11:52:50 <mauke> > unwords ["Hello", "World"]
11:52:51 <lambdabot>  "Hello World"
11:52:53 <mmachenry> clrnd: I had to remove the modules from other-modules and remove the src directory in order to get the test suite to run without adding all the external deps.
11:53:12 <clrnd> mmachenry, this looks pretty clean :)
11:53:19 <mmachenry> clrnd: It does generate HTML from HPC for me now! Sweet. But the results are that I cover 0 out of 0 lines of my code, which is wrong, of course.
11:53:25 <ezrios> is it possible to have multiple concurrent sessions with acid-state?
11:53:40 <Cale> > unwords ["Hello", ""]
11:53:42 <lambdabot>  "Hello "
11:53:59 <mmachenry> clrnd: My hypothesis is that I need to add back the src modules so that HPC can "see" them. But then it will complain that the entire list of dependencies is not there.
11:54:10 <mauke> > (unwords . words . unwords) ["Hello", ""]
11:54:11 <lambdabot>  "Hello"
11:55:20 <clrnd> mmachenry, the tutorial says "We also have to add all the source and test files to other-modules so HPC can analyze them"
11:55:35 <clrnd> but doesn't specify to which entry
11:55:55 <mmachenry> clrnd: Yes which is why I had them in there to begin with. Also why that's my hypothesis
11:56:14 <mmachenry> clrnd: But I get build-dep issues that way. I'll change it back and show you the error.
11:56:28 <clrnd> mmachenry, and you added them to 'otehr-modules' of .. test-suite hpc, or library?
11:56:31 <clrnd> or executable
11:59:58 <mmachenry> clrnd: http://lpaste.net/121447
12:00:21 <mmachenry> clrnd: error is here : http://lpaste.net/121460 also thanks for all the help with this
12:01:36 <clrnd> mmachenry, no problem at all
12:01:55 <nerium> How would I go from MaybeT IO Val to IO Val ?
12:02:07 <nerium> use "Just"?
12:02:09 <mmachenry> clrnd: Well, I wouldn't say no problems. ;)
12:02:15 <glguy> nerium: runMaybeT
12:02:21 <Cale> do v <- runMaybeT x; case v of Just u -> ...; Nothing -> ...
12:02:23 <clrnd> mmachenry, https://github.com/tfausak/haskeleton/blob/master/package-name/package-name.cabal.template search for other-modules
12:02:28 <rhllor> does anyone know of a module that can find the shortest solution for a given rubik's cube written in haskell
12:02:34 <clrnd> it adds them to the "tests" test-suite
12:02:45 <Cale> runMaybeT :: MaybeT IO Val -> IO (Maybe Val)
12:02:46 <mmachenry> clrnd: Yes, I tried to copy that.
12:03:11 <nerium> glguy: Sorry, should be the other way around. IO Val -> MaybeT IO Val
12:03:19 <clrnd> mmachenry, yes I see in your paste ...
12:03:20 <Cale> nerium: liftIO
12:03:48 <rhllor> i didn't find anything on hoogle
12:03:49 <clrnd> mmachenry, sorry if it seems I don't look at your pastes, I'm kinda bussy
12:03:50 <Cale> liftIO :: (MonadIO m) => IO a -> m a
12:04:01 <Cale> In this case,  liftIO :: IO a -> MaybeT IO a
12:04:23 <nerium> Cale: That worked, thanks
12:06:37 <nerium> Cale: How about wrapping a "Nothing"?
12:06:37 <nerium> https://gist.github.com/oleander/f6bade9c2aebf5328bcc
12:06:42 <Welkin> rhllor: try hayoo
12:06:46 <nerium> using return Nothing didn't work
12:06:47 <Welkin> it searches many more packages
12:07:16 <Welkin> rhllor: also, you can just search hackage directly
12:09:44 <rhllor> Welkin: cool
12:09:47 <mmachenry> Does anyone know why this cabal file's test suite http://lpaste.net/121447 gives me this error message about missing build dependencies from my library? http://lpaste.net/121460
12:10:43 <nerium> Cale: fail worked
12:10:52 <Cale> nerium: You might also want mzero
12:11:06 <Cale> nerium: Or  MaybeT Nothing
12:11:08 <nerium> Cale: Aha, even better
12:11:08 <Cale> er
12:11:14 <Cale> MaybeT (return Nothing)  rather
12:11:32 <Welkin> fail shouldn't be used in your programs...
12:11:32 <Cale> (which is how mzero is defined for MaybeT m)
12:11:35 <aidecoe> does Posix define non-capturing group, i.e. „(?:)”?
12:11:53 <Cale> Yeah, I like to mostly just pretend that fail doesn't exist
12:12:05 <Cale> It really shouldn't be part of the Monad type class
12:12:08 <aidecoe> Text.Regex.Posix has some problem to parse my regex with (?:)
12:13:07 <Zemyla> Can I create multiline macros using the C pre-processor? If so, how? Ending the line with \ just makes it move everything to the same line.
12:13:42 <clrnd> mmachenry, one more try! from test-suite coverage, hs-source-dirs, remove `src` and all `other-modules`
12:14:44 <hexagoxel> mmachenry: because of this issue (?) https://github.com/haskell/cabal/issues/2032
12:15:02 <clrnd> mmachenry, and I just noticed, it doesn't say anywhere in the tutorial that you won't have to copy paste build-depends
12:16:03 <cite-reader> aidecoe: Posix does not define that feature.
12:16:09 <aidecoe> :-(
12:16:12 <aidecoe> that's sad
12:17:12 <geekosaur> that's a Perl extension. try one of the PCRE modules
12:18:44 <Cale> Every time someone mentions they're using Text.Regex, it makes me feel like maybe someone should just write a new regex library even if they'll never use it, just so that beginners who still want to use regexes don't have to suffer quite as much.
12:19:17 <cite-reader> I tried to use a regular expression library once. I bounced off the types and used attoparsec instead.
12:19:39 <clrnd> hodapp, I found a unixy easy way to add swap and it worked
12:19:41 <Cale> Then again, maybe Text.Regex is the perfect strawman argument for using a real parser combinator library instead
12:20:22 <raek> what about Text.Regex.Applicative?
12:20:28 <hodapp> clrnd: was it 'swapon'?
12:20:34 <geekosaur> I think that's the main reason it's left ugly, yeh
12:20:58 <clrnd> hodapp, dd if/dev/zero of=whatever; mkswap whatever; swapon whatever
12:21:08 <clrnd> I dunno why I thought it needed to be a partition
12:21:22 <hodapp> some versions complain at you if they're not
12:22:51 <Cale> raek: That's closer to a parser combinator library. I'm not entirely sure that it even restricts itself to regular languages -- you can probably define values of type RE s a which are recursive.
12:23:37 <Cale> (then again, I have no idea if such infinite expressions will even work)
12:24:11 <mmachenry> clrnd: Yeah it doesn't say that.
12:24:12 <aidecoe> Cale: what's so bad about Text.Regex?
12:24:16 <haasn> Who's the maintainer of lambdabot?
12:24:19 <mmachenry> clrnd: Perhaps I need to but that sucks.
12:24:29 <shachaf> haasn: int-e runs lambdabot.
12:24:35 <aidecoe> Cale: i've just started using it and it seems pretty ok
12:25:03 <haasn> int-e: It might be time to get rid of the “L.hs” bug in lambdabot once and for all. CC https://github.com/gwern/mueval/issues/2
12:25:08 <aidecoe> if Posix doesn't define something, well, that's another problem
12:25:35 <aidecoe> which usually can be workarounded with more ugly regex (-:
12:26:26 <Cale> aidecoe: It rather heavily abuses type classes to get more-perl-than-perl context sensitive meaning for its matching operator, which seems cool until you realise that with the trouble you need to go to in order to specify the type of result you want, you could have just used an alternate function for matching.
12:28:20 <int-e> haasn: I'm probably not going to touch mueval before the next ghc release.
12:29:52 <int-e> haasn: but it's good to know this, thanks
12:29:56 <aidecoe> Cale: i see. It seems cool, indeed. (-:
12:29:59 <toblerone> using aeson, is there any way to parse maybes? For instance "{ 'a': { 'foo': 1}, 'b': { 'bar': true }, 'c': { 'foo': 2}}" => Map String (Maybe Foo)
12:30:21 <ReinH> Haskell is the first language I've found where writing a parser is actually easier than using irregular expressions (not to mention more likely to be correct).
12:30:41 <Cale> The whole RegexContext class is pretty silly, imo.
12:31:48 <mmachenry> clrnd: Copying them all over does work. But sucks.
12:32:10 <clrnd> mmachenry, it must suck so hard
12:34:13 <mmachenry> Also the HTML generated still says 0/0 but the .log file looks reasonable.
12:35:14 <geekosaur> ReinH, I'd argue Icon did pretty well at that too
12:35:33 <hexagoxel> mmachenry, clrnd: express your opinion on https://github.com/haskell/cabal/issues/2032
12:35:54 <geekosaur> of course, Icon had an extensible parsing framework instead of regex built in...
12:37:05 <ttt_fff> is there a String -> Maybe Int function ?
12:37:13 <ttt_fff> where given a string, it tries to parse an integer, and returns Nothing if it fails?
12:37:36 <aidecoe> is there some directive to disable trace?
12:37:39 <clrnd> hexagoxel, isn't this for cabal repl? this is for cabal test
12:37:44 <ttt_fff> https://www.haskell.org/hoogle/?hoogle=String+-%3E+Maybe+Int <-- does not say much
12:37:55 <aidecoe> i have some Debug.Trace.trace calls and i'd like to disable them, but not remove them
12:38:13 <toblerone> ttt_fff: isn't there a readMaybe somewhere?
12:38:14 <ReinH> geekosaur: Well, I haven't used Icon :)
12:38:29 <toblerone> hmm
12:38:39 <toblerone> not showing up on hoogle
12:38:44 <geekosaur> ttt_fff: Text.Read.readMaybe
12:38:57 <ttt_fff> toblerone: https://www.haskell.org/hoogle/?hoogle=readMaybe no
12:39:22 <geekosaur> http://hayoo.fh-wedel.de/?query=readMaybe
12:39:22 <ttt_fff> geekosaur: I stand corrected
12:39:37 <toblerone> yeah, hayoo has it
12:39:43 <geekosaur> generally you should try the hoogle at fpcomplete instead of the one on haskell.org
12:39:44 <ttt_fff> this is the only instance in history where Yahoo > Google
12:39:56 <hannes___> ttt_fff: if that didn't exist, you could build something on top of reads
12:40:26 <toblerone> i find hayoo to much more useful than hoogle. I've always wondered why hoogle is more popular.
12:40:30 <kadoban> ttt_fff: Neither one is related to either google or yahoo, except punny names.
12:40:36 <hexagoxel> clrnd: hmm indeed, but the general problem and the proposed solution is the same, even if the symptoms are (for whatever reason that remains to be examined) different
12:40:44 <geekosaur> the haskell.org one is limited, and many of the things it does index require an explicit package specification
12:41:01 <geekosaur> toblerone, hoogle handles fuzzy types better, hayoo handles fuzzy names better
12:41:06 <toblerone> ah
12:41:06 <toblerone> ok
12:41:24 <toblerone> and hayoo indexes more packages, right/
12:41:24 <toblerone> ?>
12:41:24 <lambdabot> Maybe you meant: v @ ? .
12:42:06 <geekosaur> hayoo indexes all of Hackage. hoogle has problems indexing that much, but the instance on fpcomplete indexes all of the Platform and Stackage releases
12:42:38 <geekosaur> the one on haskell.org doesn't index anything but the stuff that comes with ghc, and much of that an only be accessed by explicitly telling it to look in a particular database
12:43:04 <toblerone> the new version of hoogle is hoping to fix this, right?
12:43:05 <geekosaur> so you're much better off using fpcomplete.com/hoogle
12:43:10 <hannes___> fpcomplete still doesn't have netwire :(
12:43:35 <geekosaur> they're working toward it, I'm not sure the upcoming version will handle all of hackage
12:43:55 <toblerone> whats the problem? Performance?
12:44:19 <geekosaur> I don't actually know
12:44:41 <geekosaur> I just know they don't index everything, the current hoogle can't handle it for whatever reason, and a future version is supposed to fix it
12:45:19 <average> f d p   = (f' p)
12:45:22 <average> what would this mean ?
12:45:42 <average> what's the  '  sign ? I'm trying to read some haskell code and don't know that
12:45:54 <hannes___> it seems strange to me that hoogle couldn't handle it; even putting all of hackage together it's still not _that_ much stuff to search through
12:45:59 <ibid> average: a part of the name of f'
12:46:01 <f|`-`|f> the prime is usually to say that an * -> *'
12:46:04 <kadoban> average: It's just part of the name.
12:46:05 <toblerone> the prime symbol (') can be the name of variable
12:46:10 <clrnd> average, it's just to distinguish a name from anotehr name, like in math
12:46:14 <geekosaur> average, you can use ' as any but the first character of a name
12:46:28 <hannes___> well, maybe if you also crawl all revisions of all packages
12:46:32 <average> f' is not defined anywhere
12:46:33 <geekosaur> > let hi'ho'hu = 5 in hi'ho
12:46:34 <lambdabot>  Not in scope: ‘hi'ho’
12:46:35 <geekosaur> oops
12:46:38 <geekosaur> > let hi'ho'hu = 5 in hi'ho'hu
12:46:39 <lambdabot>  5
12:46:59 <average> https://wiki.haskell.org/Euler_problems/171_to_180#Problem_172
12:47:05 <average> I was reading this ^^
12:47:17 <average> I don't understand this part (p172' p)
12:47:24 <average> what does the ' do there ? what is its purpose ?
12:47:34 <geekosaur> we just told you
12:47:50 <kadoban> average: That's like asking what the "p" in print does
12:47:53 <geekosaur> it's a character that can be part of a name
12:48:02 <clrnd> average, its because the p172' function is simillar to the p172 parent function
12:48:10 <thebnq> > let p172' = 3 in p172'
12:48:11 <lambdabot>  3
12:48:12 <clrnd> it's like python guys doing _function (kindof)
12:48:14 <geekosaur> like you could have p172_ as a name. you can have p172' as a name
12:48:52 <geekosaur> there are some very loose conventions for its use but not much consistency even there; it's just another character you can use in a name
12:49:53 <average> erm..
12:50:00 <average> I didn't understand anything
12:50:09 <average> which is why I am now going to continue googling
12:50:09 <toblerone> Is there any way to get aeson to parse something like this? data Foo = Foo { foo :: Bool }
12:50:11 <toblerone> decode "{'a': { 'foo' : true}, 'b' : {'bar': 1}}" :: Maybe (Map String (Maybe Foo))
12:50:15 <thebnq> average: p172 and p172' are two different names
12:50:31 <average> thebnq: yes, but that is not what I asked
12:50:40 <average> nevermind, I'll google it and understand it by myself
12:50:45 <geekosaur> oh, it doesn't help that our haskell code highlighting in the wiki is broken
12:50:49 <toblerone> average: are you asking what the function itself doesn?
12:50:51 * hackagebot haste-compiler 0.4.4.2 - Haskell To ECMAScript compiler  http://hackage.haskell.org/package/haste-compiler-0.4.4.2 (AntonEkblad)
12:50:55 <geekosaur> average, what are you not understanding?
12:51:03 <geekosaur> there is a where clause defining a new name p172'
12:51:05 <clrnd> someone show him a correctly highlighted example :B
12:51:07 <geekosaur> which is used in the code
12:51:15 <average> oh !!
12:51:16 <clrnd> average, check this out:
12:51:17 <average> thanks geekosaur
12:51:18 <geekosaur> p172' is not magic, it's just like p172_
12:51:19 <average> damn :(
12:51:23 <clrnd> that
12:51:26 <average> i'm so stupid
12:51:33 <average> ok, sorry
12:51:57 <toblerone> no need to apologize : )
12:52:04 <clrnd> > let p = p' 6 where p' = (7 +)
12:52:05 <lambdabot>  not an expression: ‘let p = p' 6 where p' = (7 +)’
12:52:07 <average> and then...
12:52:14 <Clint> toblerone: how is { 'foo' : true} supposed to parse to a Bool?
12:52:24 <clrnd> > let p' = (7 +) in let p = p' 6
12:52:25 <lambdabot>  <hint>:1:31:
12:52:25 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
12:52:34 <clrnd> > let p' = (7 +) in let p = p' 6 in p
12:52:35 <lambdabot>  13
12:52:38 <clrnd> ok nevermind
12:52:56 * clrnd never uses let
12:53:02 <toblerone> Clint: well I have the data type data Foo = Foo { foo :: Bool }  and "true" is the Bool type in JSON
12:54:02 <toblerone> so that should and does parse, my question though is if I can have a JSON object of mixed types, and parse only a certain type, returning Nothing for everything else
12:54:35 <geekosaur> I think it has to parse the whole thing anyway
12:55:11 <toblerone> Well I was thinking that for "decode "{'a': { 'foo' : true}, 'b' : {'bar': 1}}" :: Maybe (Map String (Maybe Foo))"
12:55:26 <toblerone> it would parse 'b', fail, and then return Nothing
13:04:50 <YaRly> is it possible to have test IO operations in Test.HUnit?
13:05:28 <YaRly> to test*
13:06:07 <kuznero> Hi All!
13:07:45 <voidzero> hi!
13:10:42 <HeladoDeBrownie> o/
13:34:07 <dmj`> if I have two different excutable sections in my cabal file, can I specify different compilers for each?
13:34:25 <dmj`> specifically ghc / ghcjs
13:35:53 <luite> dmj`: you can use the impl flags, if impl(ghcjs) buildable: false else buildable: true
13:36:46 <luite> dmj`: cabal only supports one configuration at a time, so you still have to build twice, but it will then build each of the executables with the correct compiler
13:37:38 <luite> dmj`: note that imp(ghc) is also true for ghcjs, since it's derived from ghc
13:40:09 <donny_nowitzki> hello
13:40:54 * hackagebot haste-compiler 0.4.4.3 - Haskell To ECMAScript compiler  http://hackage.haskell.org/package/haste-compiler-0.4.4.3 (AntonEkblad)
13:43:09 <darkroom> lets say I have a function loadLevels :: IO [Bitmap] how can I make sure I dont load the levels untill I need them? Because IO is strict
13:48:09 <luite> darkroom: that's a bit of a risky operation, you can use unsafeInterleaveIO for that, but make sure you know what you're getting into with lazy IO
13:49:24 <HeladoDeBrownie> loadLevels :: IO [IO Bitmap]
13:49:44 <darkroom> luite: Okay so I am using Yampa to develop a game and the problem is you cant monadically call IO actions inside the signal functions (without crazy modifications) so I need to load all the levels from the level files at startup.
13:50:00 <darkroom> HeladoDeBrownie: I cant run IO actions in Yampa
13:50:44 <darkroom> luite: would that be a safe use of unsafeInterleave?
13:50:45 <HeladoDeBrownie> darkroom, what's the relevant yampa type?
13:51:35 <HeladoDeBrownie> darkroom, actually could you go ahead and give the skeleton of your yampa program? might be able to spot something
13:51:57 <darkroom> HeladoDeBrownie: http://hackage.haskell.org/package/Yampa basically all the game logic is in one Signal function
13:52:08 <darkroom> HeladoDeBrownie: let me make the github public
13:52:17 <HeladoDeBrownie> darkroom, i saw the package already, but what type do you need to embed the actions in?
13:52:26 <HeladoDeBrownie> okay
13:52:39 <darkroom> HeladoDeBrownie: SF a b
13:54:02 <darkroom> HeladoDeBrownie: I dont have perms to unprivate it. My freind is the main author
13:54:13 <darkroom> HeladoDeBrownie: i will pastebin
13:56:00 <HeladoDeBrownie> darkroom, it looks like you can use part of its api to execute arbitrary IO based on input
13:56:01 <luite> darkroom: it might be considered safe if you're sure it never matters when (and in what order) the IO actions are executed, for example when you're reading them from read-only files
13:56:19 <HeladoDeBrownie> i don't quite get what much of it is *for* per se, but afaict you can do that
13:56:48 <HeladoDeBrownie> though it may just end up being simpler, and safe, to do unsafeInterleaveIO
13:57:18 <darkroom> HeladoDeBrownie: http://pastebin.com/V3UkAu7L basically I would need to pass in the levels from the game signal function
13:57:28 <darkroom> HeladoDeBrownie: what function is that?
13:57:53 <darkroom> luite: yep they just need to be read once I never touch them again
13:58:01 <HeladoDeBrownie> reactimate and reactInit seem to both allow it
13:58:14 <luite> darkroom: i'd still try to make sure that each of the levels is read strictly, otherwise partially demanding some level could leave file descriptors open, which would probably cause headaches at some pooint
13:59:30 <darkroom> HeladoDeBrownie: all the game logic has to happen in game which is pure
13:59:43 <darkroom> luite: Okay i will try for another solution seems horrid
13:59:59 <HeladoDeBrownie> actually it does kinda look like i misunderstood
13:59:59 <nerium> What I'm I doing wrong here? https://gist.github.com/oleander/d3d0f2ff0963f1acd6d1
14:00:48 <HeladoDeBrownie> nerium, wrap "hello" outputs a value of type MaybeT IO String, value1 will be of type String
14:01:17 <darkroom> HeladoDeBrownie: what do you think about having 100 bitmaps loaded at runtime? Would that be bad?
14:01:26 <HeladoDeBrownie> darkroom, yeah.
14:01:48 <nerium> HeladoDeBrownie: How would I get the Maybe type?
14:01:49 <HeladoDeBrownie> whatever you use to run your game should allow loading of resources on demand and not until then.
14:01:57 <HeladoDeBrownie> nerium, runMaybeT
14:01:59 <HeladoDeBrownie> @type runMaybeT
14:02:00 <lambdabot> Not in scope: ‘runMaybeT’
14:02:11 <HeladoDeBrownie> runMaybeT :: MaybeT IO String -> IO (Maybe String)
14:02:55 <nerium> HeladoDeBrownie: Then I'm getting "Couldn't match type ‘IO’ with ‘MaybeT IO’", do I need another <- ?
14:02:58 <HeladoDeBrownie> nerium, judging from your example i'm not sure it's worth it for you to be mucking with MaybeT, unless the objective is to learn it
14:03:06 <HeladoDeBrownie> nerium, no, you need run to be of a different type.
14:03:48 <nerium> HeladoDeBrownie: It's part of a bigger application
14:03:56 <nerium> HeladoDeBrownie: run?
14:04:05 <HeladoDeBrownie> run :: IO …
14:04:21 <HeladoDeBrownie> i'm assuming you just threw a runMaybeT around the expression on the right of the <-
14:04:47 <nerium> HeladoDeBrownie: I tried "run $ runMaybeT $ wrap "hello""
14:05:01 <HeladoDeBrownie> run is not a function there
14:05:08 <HeladoDeBrownie> though from its name it probably ought to be
14:05:23 <HeladoDeBrownie> i'm really not sure what your intent is
14:05:58 <nerium> HeladoDeBrownie: I just need to manually match on Nothing, which I can't figure out how to do
14:06:40 <HeladoDeBrownie> nerium, okay, from the code you pasted make these changes: run :: IO … where … is… well, any type whatsoever, based on your example. value1 <- runMaybeT (wrap "hello")
14:09:49 <laudiacay_mobile> Hello
14:10:00 <laudiacay_mobile> Well I'm just now starting from java
14:10:07 <laudiacay_mobile> And hi
14:10:21 <HeladoDeBrownie> hey! fair warning, you may experience some culture shock
14:10:43 <nerium> HeladoDeBrownie: Do I need to change the type of run?
14:10:50 <HeladoDeBrownie> nerium, yes, it needs to be of an IO type
14:11:04 <HeladoDeBrownie> nerium, because that's what runMaybeT outputs
14:11:21 <nerium> HeladoDeBrownie: "run :: MaybeT IO String" sin't enough?
14:11:40 <HeladoDeBrownie> nerium, it's the wrong type if you want to get the result of the MaybeT computation and case analyze it.
14:12:59 <nerium> HeladoDeBrownie: I was hoping to write a function that takes a MaybeT, inspects the result and returns another MaybeT, but it doesn't look like that's possible
14:13:02 <HeladoDeBrownie> nerium, i mean, you *could* run a MaybeT computation within another, but i'm not sure what the point is here.
14:13:15 <HeladoDeBrownie> nerium, if you say what you're after that may help
14:13:18 <HeladoDeBrownie> what's the bigger picture?
14:13:48 <nerium> HeladoDeBrownie: I'm writing a interpreter for c++
14:13:55 <nerium> HeladoDeBrownie: That's the big picture :)
14:14:02 <HeladoDeBrownie> slightly too big, but sure :)
14:14:23 <HeladoDeBrownie> what do you want run to do, basically?
14:14:26 <HeladoDeBrownie> how are you going to use it?
14:14:35 <laudiacay_mobile> HeladoDeBrownie: as in? :p
14:15:30 <HeladoDeBrownie> laudiacay_mobile, haskell and java are quite different languages. have you read any introductory materials yet, by the way?
14:15:39 <HeladoDeBrownie> if not try starting here https://github.com/bitemyapp/learnhaskell
14:15:56 <laudiacay_mobile> HeladoDeBrownie: got a book.
14:15:59 <HeladoDeBrownie> okay.
14:16:05 <Welkin> laudiacay_mobile: also, avoid trying to translate your knowledge of java into haskell -- it will just cause problems
14:16:51 <HeladoDeBrownie> laudiacay_mobile, sometimes even the same terms are used differently, like "class", "instance", "method", and "function".
14:18:42 <laudiacay_mobile> HeladoDeBrownie: well I'm scared now :P but not scared off
14:19:05 <laudiacay_mobile> Anyway just saying hi, I'll be back with bad code shortly :P
14:19:06 <HeladoDeBrownie> laudiacay_mobile, sorry, i guess i was ineffective at what i was trying to do: encourage you to start with a clean slate.
14:19:17 <HeladoDeBrownie> by no means did i want to scare you off.
14:19:20 <laudiacay_mobile> No no no thank you :D sorry
14:19:30 <laudiacay_mobile> Going to do that
14:19:34 <HeladoDeBrownie> okay, have fun!
14:20:12 <laudiacay_mobile> Thanks :)
14:24:02 <pchiusano> is there a version of getDirectoryContents that doesn't return '.' and '..'?
14:24:18 <pchiusano> or is there an easy way i can do the filtering myself?
14:24:32 <Welkin> that is equivalent to `ls -a`
14:24:39 <roboguy_> pchiusano: drop 2 should do it
14:24:45 <nerium> HeladoDeBrownie: Here is some code in the correct context https://gist.github.com/oleander/031c2f037f64dfc815e6#file-gistfile1-hs-L6
14:25:21 <nerium> The problem is one line 6 where I'm trying to inpack the result from the call to "exec" and call execStms again
14:25:27 <nerium> *unpack
14:25:39 <pchiusano> roboguy_: cool, thanks
14:26:19 <roboguy_> pchiusano: I *think* those are always at the start, anyway
14:36:32 <tnks> hey, so I'm a touch new to functional dependencies, but stumbled onto it in the definition of MonadReader:  class Monad m => MonadReader r m | m -> r
14:36:49 <tnks> can someone help me understand better why the functional dependency is needed?
14:38:19 <liyang> roboguy_: drop 2 would be bad for /
14:38:23 <HeladoDeBrownie> tnks, you may have Reader String Whatever, but the instance is unable to determine that r ~ String without that
14:38:25 <Welkin> tnks: https://wiki.haskell.org/Functional_dependencies
14:38:49 <HeladoDeBrownie> nerium, to do a case analysis on the output of exec, use runMaybeT
14:38:52 <geekosaur> tnks: any time you have a multi-parameter typeclass like that, you have something that type inference breaks on. the functional dependency re-enables type inference by telling the compiler that if it knows the type of m, then there is only one possible type for r (which it can then work out for itself)
14:38:54 <roboguy_> liyang: would it?
14:39:22 <tnks> geekosaur: cool, a coworker had a suspicion it was to help type inference.
14:39:43 <roboguy_> liyang: on my Mac at least, / still has . and ..
14:39:45 <HeladoDeBrownie> tnks, specifically it's to ensure the correct instance is found.
14:40:17 <liyang> roboguy_: So does mine… O_o
14:40:21 <geekosaur> roboguy_, liyang, it matters at least on FAT / FAT32, where / may not have them (sometimes synthetic ones exist)
14:40:41 <roboguy_> ah, hmm
14:40:58 <geekosaur> (mounting them on Unix will probably have synthetic ones. On Windows, a FAT drive root typically does not have them)
14:44:01 <nerium> HeladoDeBrownie: How about this one? https://gist.github.com/oleander/b16dac7e4816ea4e886b
14:44:31 <HeladoDeBrownie> nerium, huh?
14:44:38 <vapidness> Hello :) I have a trivial question. I trying to define ord for a type I created called MapEntry. data MapEntry a b = ME (a,b) deriving (Show, Eq).  I have something like this but can't quite work it out. instance Ord MapEntry a b where     ME (a1, _) `compare` ME (a2, _) = a1 `compare` a2
14:45:01 <HeladoDeBrownie> nerium, oh, you want to know how to implement that type?
14:45:08 <nerium> HeladoDeBrownie: Yes :)
14:45:08 <HeladoDeBrownie> nerium, fmap Just
14:45:13 <ezyang> Has anyone here used the 'indentation' package before?
14:45:37 <nerium> HeladoDeBrownie: Thanks!
14:50:40 <geekosaur> vapidness, at a guess: instance Ord a => MapEntry a b where ME (a1, _) `compare` ME (a2, _) = a1 `compare` a2
14:50:53 <geekosaur> er
14:51:07 <geekosaur> instance Ord a => Ord (MapEntry a b) where ME (a1, _) `compare` ME (a2, _) = a1 `compare` a2
14:51:31 <vapidness> geekosaur, Thank you. Yes you are right it needs to know that a is an ord first. Silly me.
14:52:10 <geekosaur> also the parentheses which I missed the first attempt
15:11:06 <dlfkgj> I want to request that people stop using metaphors in articles to explaing stuff
15:11:21 <dlfkgj> I'm trying to learn about monad transformers not sandwiches
15:11:39 <tulcod> "Monads are like a dildo factory, staffed by midgets" https://www.chrisstucchio.com/blog/2013/write_some_fucking_code.html
15:11:56 <xacktm> mmm burritos
15:11:57 <tulcod> (re: dlfkgj)
15:12:02 <zomg> lol
15:13:40 <kadoban> That's a much more concise (and dildoy) version of https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
15:13:43 <rhaps0dy> xacktm: you mean monads?
15:13:53 <rhaps0dy> I would eat a monad right now ;)
15:14:16 <atomiccc> i can't see the word monad without thinking the word gonad
15:14:38 <xacktm> lol
15:15:29 <L8D> has there ever been a monad tutorial that actually worked?
15:15:32 <xacktm> yea seems I got the wrong analogy :P
15:15:32 <aawe> I don't understand how people think monads are hard to get. What about applicative functors?
15:15:58 <gyaretto> Applicative functors are awesome.
15:16:30 <gyaretto> I'm about to learn about monads right now. I'll let you know if it's confusing.
15:16:59 <pacak> L8D: You need to write a monad tutorial as a final stage of monad understanding.
15:17:13 <roboguy_> aawe: You're saying that applicative functors are harder or that you should look at them first?
15:17:30 <aawe> roboguy_: harder to fully understand the implications off
15:18:20 <roboguy_> aawe: Hmm, but you can fully implement Applicative using Monad (when a Monad instance exists)...
15:18:37 <roboguy_> it's just a weaker version of Monad
15:18:55 <aawe> some composition can only be done with applicatives, not monads, though
15:19:12 <roboguy_> aawe: Like what?
15:19:42 <aawe> roboguy_: exactly, I have no intuition for when it's better to use applicatives
15:20:41 <roboguy_> :t ap
15:20:42 <lambdabot> Monad m => m (a -> b) -> m a -> m b
15:21:28 <roboguy_> aawe: I'm not sure how you can have a kind of composition that works with applicatives and not monads... ap is basically the same as <*>
15:21:42 <roboguy_> or, "be done by" I should say
15:22:27 <sillysquirt> how do you learn Haskell as your first programming language?
15:22:28 <roboguy_> I guess there are some implementations of Applicative instances where you can't define (<*>) as ap.
15:22:41 <Welkin> sillysquirt: easily
15:22:56 <Welkin> if you can understand math, you can learn haskell
15:23:01 <Welkin> basic algebra
15:23:09 <aawe> roboguy_: I feel stupid for not having a bunch of examples
15:23:15 <sillysquirt> Welkin, I understand basic algebra
15:23:17 <Welkin> more precisely, middle school algebra
15:23:35 <ReinH> Or if you can't understand math.
15:23:45 <ReinH> Although understanding it a bit will help.
15:23:48 <Welkin> f x = x * 5
15:23:51 <aawe> but I heard Simon Marlow talk about a library they made at facebook for data processing where they could not use monads for composition but only applicatives
15:23:52 <roboguy_> aawe: oh, you definitely shouldn't feel stupid! Looking back, I remember applicatives confusing me for a while
15:23:55 <aawe> on a haskell cast
15:23:56 <Welkin> that is a function that multiplies the parameter by 5
15:24:06 <Welkin> a function named "f"
15:24:23 <exio4> Welkin: if you learn Haskell, you can then learn basic algebra!
15:24:35 <sillysquirt> Welkin, I understand all that. How do I get started with exercises and challenges?
15:24:46 <roboguy_> aawe: Oh, Haxe. Yeah, the trick there was that the Monad version of <*> (aka ap) and the Applicative version did two different things, so they could pick how they wanted a certain computation to be performed
15:24:49 <roboguy_> if I remember right
15:24:49 <Welkin> I started with project euler problems
15:24:51 <sillysquirt> where's a book/
15:25:02 <Welkin> then moved on to writing a scheme interpreter
15:25:17 <roboguy_> aawe: I think it was a series vs parallel type thing
15:25:20 <roboguy_> *serial
15:25:24 <Welkin> https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
15:25:38 <Welkin> then an IRC bot, and a web app, then games, etc.
15:26:11 <Welkin> sillysquirt: start with learnhaskell
15:26:16 <Welkin> @where learnhaskell
15:26:16 <lambdabot> https://github.com/bitemyapp/learnhaskell
15:26:29 <Welkin> use the UPenn course
15:27:07 <aawe> roboguy_: ah, that explains it
15:27:15 <Welkin> sillysquirt: also, join #haskell-beginners for helo
15:27:16 <Welkin> help*
15:27:32 <nerium> HeladoDeBrownie: Thanks for your help. I just got the interpreter to pass all 400+ specs
15:27:57 <roboguy_> aawe: The nice thing about Applicative is that an action can't depend on the results of a previous action in the way that Monad can, which is what lets them do stuff like parallelize iirc
15:28:04 <HeladoDeBrownie> nerium, sweet
15:30:01 <ReinH> Welkin: Write Yourself a Scheme is very out of date though :(
15:31:27 <Welkin> ReinH: it is, but it is still useful
15:33:22 <aawe> roboguy_: but ap shouldn't be able to depend on m either - in m (a -> b) -> m a -> m b, the a -> b function cannot affect m
15:34:26 <roboguy_> aawe: well, ap is defined in terms of >>= in the standard library, it's not part of the Monad class. So you can't make a new definition for a specific instance
15:35:47 <dlfkgj> what is 'PLT'?
15:36:04 <Welkin> PLT Scheme?
15:36:37 <roboguy_> maybe Programming Language Theory? What's the context?
15:37:33 <aawe> Product Lattice Tensors
15:37:49 <aawe> advanced stufff
15:38:47 <dlfkgj> https://github.com/jsyeo/Learn-You-PLT-for-Greater-Good
15:38:54 <dlfkgj> i guess plt = programming language theory
15:39:12 <aawe> it fits
15:41:01 -ChanServ(ChanServ@services.)- glguy added ParmesanCaesar to the AKICK list.
15:41:01 --- mode: ChanServ set +b *!*@wn-campus-nat-129-97-124-126.dynamic.uwaterloo.ca
15:41:01 --- kick: ParmesanCaesar was kicked by ChanServ (User is banned from this channel)
15:46:27 -ChanServ(ChanServ@services.)- glguy restricted VERBOSE to chanops
15:58:58 * moplove inhales deeply
15:59:03 <moplove> it's so good to be back
16:00:40 <hiptobecubic> from?
16:02:39 <moplove> a sabbatical from IRC in generally, mostly
16:03:13 <gauthier_> getting a strange compile error  when cabal install ghc-mod: http://lpaste.net/5264172850125733888
16:03:14 <moplove> this is one of my favorite communities, though (#haskell I mean) and I've missed you all. I realized I should come back
16:03:36 <gauthier_> (using ghc 7.10)
16:05:02 <gauthier_> where can I check ghc-api package documentation to check if that still exist?
16:08:38 <Zemyla> :viewlog
16:08:43 <Zemyla> Wait.
16:11:01 * hackagebot midi-util 0.1.1 - Utility functions for processing MIDI files  http://hackage.haskell.org/package/midi-util-0.1.1 (mtolly)
16:13:16 <gauthier_> http://downloads.haskell.org/~ghc/7.10.1-rc2/docs/html/libraries/ghc-7.10.0.20150123/DynFlags.html#v:ExposePackage ExposePackageId not there anymore
16:26:02 * hackagebot bytestring-read 0.2.0 - fast ByteString to number converting library  http://hackage.haskell.org/package/bytestring-read-0.2.0 (HirotomoMoriwaki)
16:48:37 <Zemyla> Hmm. So every traversable monad produces a monad transformer.
16:57:56 <ReinH> Zemyla: how so?
16:59:16 <Zemyla> @let newtype TraversableT t m a = TraversableT { runTraversable :: m (t a) }
16:59:18 <lambdabot>  Defined.
17:01:09 <shachaf> "m [a]" doesn't even work for ListT, does it?
17:01:29 <Zemyla> @let instance (Monad m, Monad t, Traversable t) => Monad (TraversableT t m) where { return = TraversableT . return . return; (TraversableT m) >>= f = TraversableT $ liftM join $ m >>= (T.mapM (runTraversable . f)) }
17:01:29 <lambdabot>  .L.hs:188:10: Warning:
17:01:30 <lambdabot>      ‘TraversableT’ is an instance of Monad but not Applicative - this will b...
17:01:30 <lambdabot>  
17:03:57 <Zemyla> ReinH: f turns m from m (t a) to m (t (m (t b))). liftM sequence makes that into m (m (t (t a))), and then you just liftM join . join.
17:04:25 <ReinH> Um.
17:04:37 <ReinH> liftM doesn't sequence things. liftM is just fmap.
17:04:47 <ReinH> And what is `f'?
17:05:27 <ReinH> Ah. liftM sequence.
17:06:05 <ReinH> The types may match up, but you still need to show that it is law abiding.
17:07:27 <ReinH> And since sequence is a lossy operation, I wouldn't expect them to.
17:08:42 <shachaf> The monad laws don't hold.
17:08:51 <Zemyla> They don't?
17:09:10 <ReinH> : t T.sequenceA . T.sequenceA -- is not an isomorphism.
17:09:20 <ReinH> :t  T.sequenceA . T.sequenceA
17:09:21 <lambdabot> (Traversable f, Traversable t, Applicative f, Applicative t) => f (t a) -> f (t a)
17:10:02 <ReinH> or rather, sequenceA is not an identity morphism
17:10:19 <ReinH> Ugh. sequenceA is not an isomorphism, the composition is not an identity morphism.
17:10:31 <shachaf> They don't.
17:11:46 <Zemyla> Sigh. Well, the only traversable monads are Maybe, Either, [], and ((,) a), so I suppose this isn't a massive loss.
17:12:14 <shachaf> The usual ListT examples work for your instance too.
17:13:33 <Zemyla> Which monad laws are broken, though?
17:14:09 <shachaf> (>>) isn't associative.
17:15:01 <Zemyla> Is that all?
17:15:32 <shachaf> No.
17:17:02 <shachaf> My answers are short not to be unhelpful but because I don't know much more than what I'm saying.
17:17:32 <ReinH> Zemyla: You might instead try to prove that they *do* hold and see where you come up short.
17:17:37 <Zemyla> Hmm.
17:17:40 <dmwit> The wiki page on how to do ListT right may have more details.
17:17:57 <ReinH> Also various expositions of "the composition of monads is not a monad"
17:18:08 <shachaf> Here's an example (with foldr1 vs. foldl1): runWriter $ runTraversable $ foldl1 (>>) $ map (TraversableT . writer) [("ab",[1]),("cd",[2]),("ef",[3])]
17:18:29 <shachaf> I know that "(>>) isn't associative" isn't everything because if (>>) is broken then (>>=) must be broken too.
17:19:00 <shachaf> The wiki page dmwit mentioned does have more details.
17:19:30 <shachaf> But I don't think "ListT done right" will generalize to Traversable instances.
17:20:15 <ReinH> Zemyla: I believe you need at least some concept of the "regularity" of the shape of the inner monad, such that they can be transposed without loss of information.
17:22:08 <ReinH> I don't think you can do that without dependent types, though.
17:24:15 <HeladoDeBrownie> ReinH, what's so different about that from informally enforced typeclass laws?
17:24:23 <HeladoDeBrownie> i mean, why couldn't this be that?
17:25:03 <HeladoDeBrownie> hmm. i guess that's a property that's hard for a programmer to verify.
17:25:37 <ReinH> Generally speaking, when you say "x is an instance Monad" you intend that it is law abiding for all inhabitants of x.
17:25:43 <ReinH> *instance of
17:29:17 <dolio> I'm not totally sure what ReinH means, but if you want to extend the ListT solution to something more general, you need access to the structure of the recursive definition.
17:29:37 <dolio> Because the proper ListT threads the transformed monad through the recursive structure.
17:29:41 <ReinH> With TraversableT, I think you have a lot of things that you would *like* to be instances, but are only abiding for some inhabitants.
17:29:48 <dolio> And Traversable gives you no way to do that.
17:30:18 <ReinH> For example, [[a]] is only law abiding with sublists of the same size, iinm
17:30:49 <dolio> And MonadTrans is specified only for things that take all monads to other monads. Not some subset of monads.
17:32:10 <Zemyla> Hmm. Well, if I can figure out that it abides by the first two laws, the ones involving return, then I can just whack it with the Codensity monad to force associativity.
17:32:31 <shachaf> Obviously what you really want instead of ListT is data FMT m a = E | L a | M (m (FMT m a) (m (FMT m a)) quotiented appropriately.
17:32:46 <shachaf> I have no idea what that sentence really means.
17:33:37 <ReinH> hah
17:33:41 <ReinH> shachaf: It sounded good though.
17:33:49 <siddhu> Can someone explain this applicative law: u <*> pure y = pure ($ y) <*> u
17:33:52 <ReinH> Wait, which sentence?
17:34:13 <shachaf> The one before last.
17:34:27 <ReinH> shachaf: I'm not sure which one that is, given IRC.
17:35:19 <ReinH> siddhu: What about u y = ($ y) u
17:35:42 <shachaf> The thing I said before the thing I said. I don't know what "quotiented appropriately" means.
17:35:48 <siddhu> I haven't seen ($ y) before. Not sure what that's doing.
17:36:01 <ReinH> shachaf: Ah.
17:36:17 <Zemyla> shachaf: Basically, Codensity m a = forall r. ((a -> f r) -> f r), which is a monad. When it's lowered from Codensity back to normal, it'll apply all the binds it's been given in a specific order, forcing associativity.
17:36:30 <ReinH> siddhu: have you seen sections before? like (+ 1)?
17:36:52 <ReinH> Zemyla: shachaf is familiar with the codensity trick :)
17:36:57 <Zemyla> But ah well. It's not really a big loss, since all the monads one would use this with already have monad transformers.
17:37:02 <Cale> siddhu: The intuition behind it is that pure y ought to be a computation which has no effects and produces y as its result, so whether you execute u "first" obtaining a function which you then apply to the result of pure y, or you execute pure ($ y) first, and apply that to the result of u (which is a function), the result should be the same.
17:37:03 <siddhu> So, ($ y) is the same as (\x -> x $ y) ?
17:37:11 <Cale> yes
17:37:12 <shachaf> Zemyla: I know that Codensity is a monad, but what's the context here?
17:37:14 <ReinH> siddhu: yes
17:37:18 <Cale> That's an operator section
17:37:24 <shachaf> Zemyla: Oh, I see.
17:37:26 <ReinH> modulo whether eta expansion is "the same"
17:37:29 <ReinH> But basically yes
17:37:56 <ReinH> Sorry, that's unhelpful. Yes.
17:37:59 <dolio> In this case it's exactly the same, because that's what sectioning means.
17:38:05 <ReinH> dolio: also that.
17:38:30 <siddhu> That makes sense. Thanks!
17:38:34 <Cale> Yeah, it's the other sort of section where you might have to worry about eta expansion
17:39:05 <dolio> Do you, though?
17:39:14 <ReinH> I have made a huge mistake.
17:39:18 <Cale> i.e. whether (f $) means ($) f or (\x -> f $ x). I believe the standard says it's the former.
17:39:30 <shachaf> The standard says it's the latter.
17:39:35 <Cale> Oh, really?
17:39:35 <shachaf> GHC has an extension to turn it into the former.
17:39:41 <ReinH> o_O
17:40:55 <shachaf> Well, if you want to be nitpicky, GHC doesn't quite implement the standard at all.
17:41:10 <dolio> Yeah, it's wrong by default. :)
17:41:19 <Cale> > let (#) = (\x -> undefined) in (id #) `seq` ()
17:41:20 <lambdabot>  <hint>:1:7: parse error on input ‘)’
17:41:26 <shachaf> # is a bad choice of operator.
17:41:34 <Cale> > let (*) = (\x -> undefined) in (id *) `seq` ()
17:41:35 <lambdabot>  *Exception: Prelude.undefined
17:41:39 <Cale> Indeed
17:41:58 <Cale> (I think I have MagicHash turned on by default in ghci or something)
17:42:04 <gyaretto> What is id?
17:42:13 <shachaf> But there are two issues here, one about the value (eta-expansion behaves differently for _|_) and one about the type (is it required to be a function type).
17:42:13 <Cale> the identity function
17:42:33 <gyaretto> :t id
17:42:34 <lambdabot> a -> a
17:42:55 <shachaf> The identity function tells you the secret identity of a value. Unfortunately Haskell values are all very boring.
17:43:11 <gyaretto> Ohkay, good to know. Thanks.
17:43:22 <EvanR> what is identity really
17:43:35 <EvanR> identity tutorial i finally get identity
17:43:39 <Cale> lol
17:43:56 <Cale> gyaretto: i.e.  id x = x   in case that was unclear
17:44:29 <gyaretto> > id 9
17:44:31 <lambdabot>  9
17:44:34 <gyaretto> > id Just 9
17:44:36 <lambdabot>  Just 9
17:44:43 <gyaretto> Huh.
17:44:46 <EvanR> hehe
17:44:50 <Cale> > id id id id id 1
17:44:52 <lambdabot>  1
17:45:00 <Cale> > id id id id id id id id id id id id id id 1
17:45:01 <EvanR> > fix id 1
17:45:01 <siddhu> :t id id id
17:45:02 <lambdabot>  1
17:45:02 <lambdabot>  can't find file: L.hs
17:45:02 <lambdabot> a -> a
17:45:08 <ReinH> hah
17:45:23 <gyaretto> > (++) <$> id 5 <*> id 3
17:45:25 <lambdabot>  No instance for (GHC.Show.Show (f0 [a0]))
17:45:25 <lambdabot>    arising from a use of ‘M3121817287020734671291.show_M3121817287020734671291’
17:45:25 <lambdabot>  The type variables ‘f0’, ‘a0’ are ambiguous
17:45:30 <hyuke> Does anyone here know fo any good resources on solving PDEs in Haskell?
17:45:31 <gyaretto> Oh, whoops.
17:45:33 <Cale> iirc, you could at one point get ghc to use a lot of memory typechecking expressions of that form
17:45:43 <gyaretto> > (+) <$> id 5 <*> id 3
17:45:45 <Cale> I'm not sure if that's still true
17:45:45 <lambdabot>  No instance for (GHC.Show.Show (f0 b0))
17:45:45 <lambdabot>    arising from a use of ‘M87660669649044184121314.show_M87660669649044184121...
17:45:45 <lambdabot>  The type variables ‘f0’, ‘b0’ are ambiguous
17:46:03 <dolio> Wow, that's a great error message.
17:46:13 <gyaretto> Is id not a functor?
17:46:27 <EvanR> Identity is a functor
17:46:35 <Cale> dolio: Yeah, lambdabot's error messages have been extra terrible lately
17:46:53 <dolio> Is it randomizing the module names now?
17:47:19 <ReinH> gyaretto: id is a function, instance of Functor must be type constructors.
17:47:23 <ReinH> *instances
17:47:57 <Cale> Just to be confusing...
17:48:25 <Cale> > ((+) <$> id <*> id) 5
17:48:26 <lambdabot>  10
17:48:42 <gyaretto> ReinH: Oh, right.
17:48:53 <ReinH> Cale: hah
17:49:38 <timothyw> I’m failing to install the latest Haskell source on Ubuntu server 12.04: http://pastebin.com/NksSjSkg
17:49:41 <Cale> > ((++) <$> id <*> reverse) "amanaplanacanalpanama"
17:49:42 <lambdabot>  "amanaplanacanalpanamaamanaplanacanalpanama"
17:49:51 <ReinH> (Just to be confusing, id is the arrow mapping of the identity functor)
17:50:16 <timothyw> anything I’m missing?
17:50:18 <siddhu> :hyuke Paraiso is an EDSL for that purpose.
17:50:24 <timothyw> This SO question details it: http://stackoverflow.com/questions/28802845/error-installing-latest-haskell-source-on-ubuntu-server-12-04
17:51:36 <Cale> timothyw: Which version of GHC are you using to compile 7.8.4 with? Also, why not just use the generic linux binary 7.8.4 from the GHC website?
17:52:18 <hyuke> siddu: thanks :) I'll look into it
17:52:19 <Cale> https://www.haskell.org/ghc/download_ghc_7_8_4#x86linux -- i.e. one of these packages
17:52:30 <timothyw> On Ubuntu, I start with “sudo apt-get install ghc”, and try to install with that
17:52:40 <timothyw> Cale: ..
17:54:23 <Cale> timothyw: Unless you're going to be hacking on GHC, it's probably better not to compile it yourself.
17:54:48 <Cale> (though having a copy of the source code around is always potentially handy)
17:55:00 <timothyw> Cale: Fair enough - but I want the latest GHC , Cabal, etc on Ubuntu
17:55:28 <timothyw> Haskell Platform is way too old (at least on Ubuntu 12.04)
17:55:48 <Cale> Right, that's what I always do, completely ignore my distribution's packages for anything Haskell-related, install the generic linux binary GHC, and then grab the tarball for cabal-install off of Hackage.
17:56:28 <timothyw> Ahhh, I see. Lemme take a look.
17:56:44 <ReinH> Up until recently I would have suggested using a deb from deb.haskell.org :(
17:56:54 <Cale> (or if I already have a binary for cabal-install, I can just cabal install cabal-install to update it)
17:57:26 <timothyw> I see I see. Trying now.
17:59:04 <Cale> It's a bit fiddly, but it works. There are some changes you probably want to make to your .cabal/config sooner rather than later (turn on documentation and profiling builds), which one might wish were the defaults before the bootstrap script went and installed a bunch of things.
17:59:22 <randir> I'm trying to figure out error handling for the http-conduit library, but I don't have much experience with error handling in haskell
17:59:30 <timothyw> ok
18:00:12 <randir> How can I make it that simpleHttp "example.com" will return the text if everything goes well, but will simply return an empty list if it doesn't
18:00:23 <randir> or perhaps wrap it in a Maybe
18:01:58 <timothyw> The latest linux binary is still ghc-7.4.1: https://www.haskell.org/ghc/download_ghc_7_4_1#x86linux
18:02:15 <timothyw> Is there not a binary for 7.8.3?
18:02:26 <shachaf> You're looking at the page for 7.4.1
18:02:37 <shachaf> https://www.haskell.org/ghc/download links to a more recent release.
18:02:50 <Cale> I linked you to the page for the more recent GHC
18:03:02 <Cale> https://www.haskell.org/ghc/download_ghc_7_8_4#x86linux
18:03:16 <timothyw> A ha
18:03:51 <randir> Basically I'm looking for a way to catch all HttpException type errors. Any suggestions?
18:04:41 <Cale> randir: Use  Control.Exception.try  perhaps?
18:04:44 <Cale> :t try
18:04:45 <lambdabot> Exception e => IO a -> IO (Either e a)
18:05:18 <Cale> Or catch/handle
18:05:21 <Cale> :t catch
18:05:22 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
18:05:51 <dmwit> ?src try
18:05:51 <lambdabot> try a = catch (a >>= \ v -> return (Right v)) (\e -> return (Left e))
18:06:24 <randir> Cale: it looks like that's what I'm supposed to use, but I'm not sure how to syntactically make sure it captures all HttpExceptions
18:06:51 <dmwit> try a = catch (Right <$> a) (return . Left)
18:07:22 <Cale> randir: You just have to make sure you use it with the 'e' type being HttpException.
18:08:08 <Cale> You can do that by giving an explicit type signature, or by pattern matching on the result
18:08:09 <randir> Cale: Thanks
18:11:15 <timothyw> Sweet, that worked. Thanks all.
18:11:42 <Zemyla> shachaf: http://blog.sigfpe.com/2006/11/why-isnt-listt-monad.html That's pretty much the same thing I was looking at.
18:49:51 <semigroup> Does anyone know of a way to get c2hs or GHC to dump all #define'd preprocessor values?
18:56:14 <zipper> Anyone know something that helps export to excel or xls files from haskell?
18:57:23 <dmj`> zipper: pandoc might
19:01:08 * hackagebot stripe-haskell 0.1.3.0 - Stripe API for Haskell  http://hackage.haskell.org/package/stripe-haskell-0.1.3.0 (DavidJohnson)
19:02:21 <zipper> dmj`: Nope, sadly. Thanks though :)
19:04:08 <dmj`> stripe-haskell now supports bitcoin, for anyone who cares
19:05:43 <dmj`> zipper: any of these? http://hackage.haskell.org/packages/search?terms=excel
19:06:22 <zipper> dmj`: Thanks
19:07:27 <ned> zipper, pro-tip, excel can read in csv files too.
19:07:42 <ned> so you dont need to conform to the whole excel .xlsx format standard.
19:14:49 <zipper> ned: I don't know which is better for accounting things?
19:14:58 <zipper> Is it csv or xlsx?
19:15:19 <dmj`> zipper: what are 'accouting things'
19:15:23 <dmj`> accounting*
19:16:38 <ned> zipper, yeah you have to define your constraints better
19:22:39 <gcganley> could someone explain to me what a streaming library (like pipes or conduit) are. i just wanted a brief overview.
19:22:51 <gcganley> s/are/is/g
19:23:33 <c_wraith> gcganley: the main idea is that they allow interleaving of effects in a composable manner.
19:23:50 <c_wraith> gcganley: for instance, interleaving reading from one resource and writing to another.
19:26:08 <gcganley> c_wraith: im curious because im making a DHCP server (a plaything really) and looking around i found both conduit and pipes had network varients and was curious what they would be used for
19:27:24 <gcganley> c_wraith: another thing is i've never done any form of network programming
19:27:51 <c_wraith> gcganley: have you used lazy IO in Haskell?  They're easiest to explain as an alternative to that.
19:28:22 <gcganley> c_wraith: I've used the IO Monad
19:28:33 <gcganley> c_wraith: is that what we're talking abouit?
19:29:13 <c_wraith> gcganley: No, I'm talking about things like getContents and readFile
19:29:36 <gcganley> c_wraith: i understand it at a macro-level but i've never used it
19:30:52 <gcganley> :t readFile
19:30:53 <lambdabot> FilePath -> IO String
19:31:01 <gcganley> :t getContents
19:31:02 <lambdabot> IO String
19:31:23 <c_wraith> gcganley: The interesting thing about those operations is that they use so-called lazy IO
19:32:09 <gcganley> c_wraith: so the file im guessing is like a 'thunk' where the file isnt fully eval'd until needed?
19:32:15 <zipper> dmj`: ned: By accounting things I'm refeering to a payslip.
19:33:18 <c_wraith> gcganley: well, the String produced is actually magical. It secretly hides further IO operations
19:33:38 <exio4> gcganley: you basically have a "String" which is actually read on-demand, the problem with this "naive approach" is that you can get space leaks, never close the handle, and other magical and dirty things
19:33:47 <ned> zipper, youre asking for two separate things. 1: a good accounting solution, 2: a good way to export your (presumably post processed) data to excel.
19:33:53 <c_wraith> gcganley: you treat it as if it's pure, but it actually interleaves further reads when needed.
19:34:08 <ned> zipper, for the first thing, look at "ledger" and double-entry accounting. for the second, look at the xlsx packages linked, but again, excel can take comma separated files.
19:34:23 <gcganley> exio4, c_wraith: i thought the type-system was supposed to express that sorta thing :(
19:34:51 <exio4> gcganley: that's why we don't use them!
19:34:57 <c_wraith> gcganley: yeah, lazy IO is a hack.  Sometimes it's really convenient, but sometimes there are serious issues.
19:35:27 <gcganley> exio4, c_wraith: so we use strict IO? how do we do that in haskell?
19:35:34 <c_wraith> gcganley: anyway, pipes and conduits are libraries that attempt to make it easier to managing streaming IO like that explicitly, instead of with magic.
19:35:40 <zipper> ned: Well in html I am presenting the data in a table. That way I think it's easier for users to view it in a spreadsheet.
19:36:04 <gcganley> c_wraith: strict IO == streaming IO
19:36:07 <gcganley> ?
19:36:39 <c_wraith> gcganley: well, all "lazy" IO is done with an operation called unsafeInterleaveIO.  IO operations that aren't done in terms of unsafeInterleaveIO aren't lazy.
19:36:53 <ned> zipper, what are your other constraints? how is this going to fit into your workflow? do you have other people using your accounting? legacy data? is this just pulling data out from your Sage or Quickbooks or SAP financials, you munging together things, then generating an xls?
19:37:25 <gcganley> c_wraith: is that related to unsafePerformIO
19:37:28 <c_wraith> gcganley: no, streaming IO is when operations are deferred as much as possible - only performed when needed.  The idea is that instead of reading a 2GB file into memory, you only read as much as needed.
19:37:39 <c_wraith> gcganley: it's related, but not the same.
19:37:43 <c_wraith> :t unsafeInterleaveIO
19:37:44 <lambdabot> Not in scope: ‘unsafeInterleaveIO’
19:37:48 <zipper> ned: No legacy data. It's pulling data out of a postresDB from now
19:38:04 <gcganley> @type unsafeInterleaveIO
19:38:05 <lambdabot> Not in scope: ‘unsafeInterleaveIO’
19:38:14 <exio4> unsafeInterleaveIO :: IO a -> IO a
19:38:19 <zipper> ned: I have a web interface that I want to have an option to export to excel
19:38:29 <gcganley> :t forkIO
19:38:29 <lambdabot> Not in scope: ‘forkIO’
19:38:33 <ned> zipper, ok, well my first concern would be that financial data is easy to mess up. as easy to mess up as crypto. so id use a package to keep track of that off the bat.
19:38:35 <zipper> ned: However I'm not sure how this excel file will reach the client.
19:38:47 <ned> thats very easy.
19:38:52 <zipper> ned: Let me show you what I have,
19:39:16 <zipper> ned: https://github.com/urbanslug/payroll-web
19:39:46 <ned> zipper, just take any given haskell webserver (snap and warp are favorites), generate your comma separated file, then a new line per row, and upon request, generate an output stream with the proper header information.
19:40:07 <ned> i forget what it is, like octet-stream;text-csv or something maybe
19:40:18 <HeladoDeBrownie> is there any way in which using newtype over data leaks abstraction, all other things being equal?
19:40:19 <zipper> ned: I'm already using yesod
19:40:46 <ned> zipper, use one of the libs that the other guy linked to, change the data type of the output stream and you're done
19:41:05 <HeladoDeBrownie> i know there's a semantic difference relating to bottom but i don't know if it matters so much as far as the interface goes
19:41:23 <zipper> ned: hmmm I'll see if I can incorporate that.
19:41:45 <ned> zipper, if this is for work or for anything important, please please use a tried and true package.
19:41:53 <gcganley> c_wraith: is the choice between pipes and conduit a coin-flip or are there noticable differences?
19:41:55 <ned> finance is like crypto, seems simple, so easy to mess up your own impl
19:42:14 <ned> if its a pet project though, go for it
19:42:20 <c_wraith> HeladoDeBrownie: there is a semantic difference - pattern matching on a newtype constructor is a no-op.  Pattern matching on a data constructor forces evaluation
19:42:40 <HeladoDeBrownie> c_wraith, let's assume i don't expose the constructors.
19:43:45 <c_wraith> gcganley: conduit is probably a bit more straightforward - pipes is more elegant conceptually, but it is at a slightly more abstract level.
19:43:47 <exio4> HeladoDeBrownie: "semantic difference relating to bottom"? newtypes don't add new bottoms, which difference are you talking about?
19:43:56 <HeladoDeBrownie> exio4, that's exactly it.
19:44:14 <exio4> oh, over data as keyword
19:44:25 <exio4> sorry, back to my hole :P
19:44:29 <HeladoDeBrownie> ah, my wording was ambiguous. sorry.
19:44:46 <HeladoDeBrownie> "is there any way in which using a newtype declaration instead of using a data declaration leaks abstraction, all other things being equal?"
19:47:19 <gcganley> sometimes i want to go back to clojure because i always have thought that Lisp is the sexiest language but I'll miss out on so many haskell niceties
19:47:23 <Cale> HeladoDeBrownie: Given that you're not exposing the constructors, there shouldn't be any visible difference between data and newtype from outside the module.
19:47:33 <HeladoDeBrownie> Cale, okay, thanks!
19:50:58 <gcganley> is there a way in ghci when i enter an expression that doesnt eval to a value and is just a function is there a way to have it print a type sig instead of the big ugly "No Instance of Show ..."
19:51:11 <HeladoDeBrownie> on another, only marginally related question, what's the syntactically nicest way i can compose a bunch of monoids together? i tried mconcat with a list that spans multiple lines and comma-first, but i'd prefer less noise if possible.
19:51:12 <michaelt> :t even
19:51:12 <lambdabot> Integral a => a -> Bool
19:51:22 <michaelt> gcganley: like so ^^^
19:51:35 <Cale> gcganley: You can make an instance of Show for functions which relies on a Typeable instance, but that won't always work (in particular it won't work for polymorphic functions)
19:52:02 <gcganley> michael: i know about :t but i just want it to be able to type in "even" into the repl and it spit out the type sig
19:52:05 <michaelt> gcganley: oh you mean, when you accidentally do this
19:52:15 <gcganley> michaelt: yes
19:53:00 <gcganley> Cale: when the expression evaluates to a function i want it to print out the equivilant of putting :t in frount
19:53:18 <michaelt> gcganley: yes frequently one would prefer this to the 10 page error message you can get.  Just tell me the type please, I'll see immediately why it couldn't print
19:54:18 <Cale> GHCi probably could detect that condition easily enough.
19:54:32 <Cale> But without modifying GHCi, I don't think there's an easy way.
19:54:41 <michaelt> yes, as soon as you start thinking what you want, it becomes ever more complicated
19:55:31 <michaelt> instance Show (a -> b) where show f = "<<function>>"
19:55:46 <Cale> I think that would be a cool feature for someone to implement though
19:55:53 <gcganley> > span
19:55:54 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
19:55:54 <lambdabot>    arising from a use of ‘M15108454939269434643178.show_M15108454939269434643...
19:55:54 <lambdabot>  The type variable ‘a0’ is ambiguous
19:56:02 <gcganley> yeah sorta like that
19:56:06 <gcganley> i dont want that
19:56:18 <Cale> Yeah, that's worse than the usual error :P
19:56:38 <gcganley> Cale: is that a 'ghci' guy?
19:56:44 <michaelt> theres a bit of lambdabot in the middle there somewhere
19:56:44 <shachaf> What ghci should do is just show the type if there's no Show instance.
19:56:51 <gcganley> Cale: i know chris handles the ghci-ng project
19:57:07 <shachaf> There's no suitable Show instance, with Typeable or anything else, that shows the information in the type. And the error doesn't show the information in the type.
19:57:11 <gcganley> shachaf: thats exactly what everyone wants
19:57:13 <Cale> shachaf: Yeah, and if it's not an IO expression :)
19:57:26 <shachaf> Oh, so it is.
19:57:38 <shachaf> I just took the opportunity to jump into my usual complaint when I saw that Show instance.
19:58:05 <Cale> (or maybe it *should* show the type in the case of IO expressions, just so that there's an easy way to see that you're executing something, and not just evaluating it.)
19:58:30 <michaelt> > even :: Int -> Bool
19:58:31 <lambdabot>  <Int -> Bool>
19:58:42 <gcganley> Cale: maybe a special way of saying "hey, you just ran this and this is the type"
19:58:43 <Cale> I still find it a bit bizarre that it automatically turns x into x >>= print
19:58:44 <michaelt> Oh, swank.
19:58:55 <gcganley> > even
19:58:57 <lambdabot>  <Integer -> Bool>
19:59:01 <gcganley> what
19:59:04 <gcganley> what the hell
19:59:06 <Cale> (though I know you can turn that off)
19:59:07 <michaelt> it defaulted
19:59:09 <gcganley> whitchcraft
19:59:19 <Axman6> > const
19:59:21 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
19:59:21 <lambdabot>    arising from a use of ‘M52139164793820023293260.show_M52139164793820023293...
19:59:21 <lambdabot>  The type variable ‘b0’ is ambiguous
19:59:24 <gcganley> ah ok
19:59:30 <gcganley> much worse :(
19:59:39 <Cale> > const :: Integer -> String -> Integer
19:59:40 <lambdabot>  <Integer -> [Char] -> Integer>
19:59:47 <michaelt> > const :: Int -> Char -> Int
19:59:49 <lambdabot>  <Int -> Char -> Int>
19:59:59 <michaelt> oh
20:00:02 <gcganley> so it doesnt like polymorphism?
20:00:05 <ski> > not . id
20:00:07 <lambdabot>  <Bool -> Bool>
20:00:15 <gcganley> :t not
20:00:16 <lambdabot> Bool -> Bool
20:00:18 <Cale> right, because polytypes can't be instances of Typeable (or any type class)
20:01:05 <michaelt> :t even
20:01:06 <lambdabot> Integral a => a -> Bool
20:01:12 <c_wraith> Oleg does have a PolyTypeable class, but I don't understand it.  As with nearly everything Oleg does
20:01:45 <michaelt> gcganley: if your > even hadn't defaulted to Integer, there would evidently have been a similar mess with Typeable
20:02:53 <michaelt> gcganley: anyway, it looks like lambdabot pretty much has the feature you were thinking of
20:03:17 <shachaf> lambdabot doesn't.
20:03:38 <MagBo> Hey, beautiful people, here's my question — https://twitter.com/podmostom/status/572607481152733184
20:03:49 <michaelt> oh, who is writing <Integer -> Bool> ?
20:04:24 <ski> > even *** typeOf
20:04:26 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b'0)
20:04:26 <lambdabot>    arising from a use of ‘M58694006735369694463406.show_M58694006735369694463...
20:04:27 <lambdabot>  The type variable ‘b'0’ is ambiguous
20:04:31 <shachaf> lambdabot will tell you that a function has type Integer -> Bool. That's much less useful than telling you the type of something.
20:04:44 <nshepperd> it would be nice if it could also print out polymorphic types
20:05:15 <michaelt> oh, gcganley 's original question was about function types
20:06:01 <michaelt> and its true it defaulted.  gcganley was thinking of getting something more humane than a half page error
20:06:44 <michaelt> if I understood
20:07:09 <gcganley> michaelt: if its not a value i want to print its type
20:07:14 <gcganley> michaelt: thats what a iwant
20:07:34 <pacak> MagBo: Unicode? Yuck, don't do that.
20:08:05 <michaelt> you mean, if it isn't either a Show able value, or an IO action or a Doc or whatever, I guess
20:08:45 <MagBo> pacak: I don't want to use https://wiki.haskell.org/Unicode-symbols
20:09:09 <MagBo> I want my code to be represented using unicode symbols though
20:09:17 <MagBo> I can't believe nobody did that.
20:10:14 <Zemyla> :t \f -> map f . tails
20:10:15 <lambdabot> ([a] -> b) -> [a] -> [b]
20:10:28 <Zemyla> We should give a name to that transformation.
20:10:46 <Axman6> I've never seen anyone need that before
20:11:13 <Zemyla> Since concatMap is the transformation for the list monad, and this is a transformation for the similar list comonad, we should call it ncatMap.
20:11:34 <MagBo> Axman6: for symmetry, I guess?
20:11:36 <shachaf> List comonad?
20:11:37 <dolio> It's extend for a list semi-comonad.
20:12:02 <shachaf> Ah, comonad-without-extract.
20:12:36 <Jello_Raptor> Zemyla: is there somewhere I can go to understand what a comonad is?
20:12:44 <Jello_Raptor> I feel like I understand monads now
20:13:01 <Axman6> flip the arrows of Monad
20:13:03 <Axman6> >_>
20:13:07 <Jello_Raptor> (or at least 2 related ways to understand them)
20:13:08 <Zemyla> Well, then it's simple. A comonad is a coburrito.
20:13:11 <Jello_Raptor> but ... what
20:13:15 <Jello_Raptor> <_<
20:13:20 * Jello_Raptor glares at all of you 
20:13:25 <shachaf> We should institute a no-burrito-joke policy in here.
20:13:36 <Zemyla> Okay, I don't know what the best comonad tutorial is.
20:13:38 <shachaf> It's a tired joke. It may have been funny the first few times.
20:13:59 <c_wraith> comonad cotutorial.
20:14:02 <Jello_Raptor> Zemyla: does that work for co"overloading the ';' operator" ? :P
20:14:19 <Axman6> c_wraith: where I teach the tutorial about comonads?
20:15:10 <c_wraith> Axman6: it's a blank wiki page, I think
20:15:17 <michaelt> hm, if I ask ghci to do > putStrLn "" >> return 1 :: IO Int, it makes a blank line and ends up printing the Int in the usual way, as the return value, If I do > putStrLn "" >> return even :: IO (Int -> Bool) then it just prints the blank line
20:15:31 <michaelt> not too surprisingly.
20:16:07 <michaelt> It doesn't worry that it doesn't know how to print even in that case
20:16:12 <Cale> Yeah
20:16:44 <lpaste> mbuf pasted “parse error on input '='” at http://lpaste.net/121465
20:17:01 <synergy_> I'm really interested in haskell and will begin learning soon. Is lambda calculus beneficial to learning functional programming. Will learning lambda calculus increase my understanding of complex priniciples in functional programming?
20:17:24 <Axman6> mbuf: you can't use data as a variable name, it's a reserved word
20:17:25 <Cale> synergy_: Eventually, you might want to learn something about it.
20:17:30 <michaelt> Cale: I guess I had learned to expect this, but it seems to involve a special rule.
20:17:41 <Cale> synergy_: Well, eventually, it will just be pretty intuitive. :)
20:17:47 <Jello_Raptor> can you create a grouping typeclass, something like "class Addable w,Subable w, Multable w, Divable w => Num w " ?
20:17:53 <mbuf> Axman6, oops! thanks
20:17:57 <shachaf> It's difficult to learn Haskell without "learning lambda calculus", even if you don't do it on purpose.
20:18:04 <Jello_Raptor> where there are no additional functions defined?
20:18:08 <Axman6> mbuf: ghci acts like an IO do block, with some extras
20:19:01 <michaelt> synergy_: basically Haskell is a symbolism for writing terms in a lambda calculus
20:19:20 <Cale> Yeah, though there's a difference between knowing the basics of using lambda to define functions while programming, and actually understanding the formal rules of lambda calculi in detail.
20:20:11 <Cale> If you wanted to write a Haskell compiler, it would be pretty hard to do so without really knowing how some lambda calculi worked (probably at least System F)
20:20:39 <Cale> (or an interpreter for that matter)
20:21:17 <Axman6> so it's haed to experiment
20:21:19 <Axman6> whoops
20:21:26 <dolio> There's a fair bit more to Haskell than lambda calculus, of course.
20:21:43 <michaelt> Yes of course
20:22:41 <Cale> Well, the Core that GHC compiles programs to is sort of a particular lambda calculus, plus a bunch of ad-hoc nonsense thrown in for I/O and FFI :D
20:23:01 <dolio> And data.
20:24:05 <Cale> Well, I'm considering data declarations part of System FC
20:24:12 <Cale> but yeah
20:24:21 <dolio> System FC isn't just a lambda calculus, either.
20:24:23 <michaelt> Jello_Raptor: I think you'd have to use NoImplicitPrelude or RebindableSyntax or maybe both, and then start over
20:24:54 <Cale> I dunno, I guess that depends on what your definition of "a lambda calculus" is
20:26:36 <michaelt> Jello_Raptor: http://hackage.haskell.org/package/yap is a typical attempt.  To use it you need to hide most of Prelude and turn on RebindableSyntax .  ... If I understand your question.
20:26:38 <Jello_Raptor> michaelt: It was just an obvious example/use case, i don't intend to override Num. What does rebindablesyntax do?
20:27:37 <michaelt> In this case, I think it is needed to break the connection between numeric literals and Num and the associated types
20:28:01 <michaelt> sorry I mean the associated classes, e.g. Fractional or whatever for 0.33
20:29:14 <michaelt> As it is, as soon as the compiler sees a literal it thinks Num, and thus has an interpretation of + * etc. in mind, all in one package
20:29:48 <michaelt> Jello_Raptor: I think I'm putting this more or less right. So, you need RebindableSyntax to break that link, and maybe others
20:30:23 <augur_> is there an aeson channel?
20:30:28 <Jello_Raptor> michaelt: ahh, I think i see
20:30:37 <michaelt> RebindableSyntax permits a pile of other things, e.g. it interprets do notation with whatever meanings have been assigned to >>= and >> which might be anything
20:30:50 <michaelt> if 'Monad' is not in scope.
20:34:52 <Rotaerk> is there a bracket for MonadIO?
20:35:47 <Cale> Rotaerk: not in general, no
20:36:02 <Rotaerk> hmm k
20:36:22 <Cale> You can do it for specific MonadIO instances, but not for all of them.
20:36:55 <Rotaerk> oh, I see there's a MonadCatchIO
20:37:33 <michaelt> http://hackage.haskell.org/package/exceptions-0.8/docs/Control-Monad-Catch.html
20:37:39 <michaelt> Rotaerk: Oh you see it
20:37:58 <Rotaerk> yea just ran across; thanks though
20:39:24 <synergy_> I was looking at curry implementations and was wondering, what things can I do to make clean, but complex code when necessary? Not understanding the curry implementations very well, how could I both gain a better understanding of the code, and increase my ability to write things that perplex me now?
20:40:18 <Cale> synergy_: Implementations of the programming language named Curry?
20:40:59 <synergy_> Cale: No, sorry I was unclear. Implementations of the technique language independent
20:41:55 <Cale> I'm a little confused about what that means. Currying is just the process of taking a function which takes a pair argument and producing a function which takes the first part of the pair and produces another function.
20:41:58 <Cale> i.e.
20:42:00 <Cale> :t curry
20:42:01 <lambdabot> ((a, b) -> c) -> a -> b -> c
20:42:58 <Cale> That's the same as  ((a, b) -> c) -> (a -> (b -> c))
20:43:04 <synergy_> In a language like javascript, currying is not built-in. I was looking at people's implementations of making a function one that curries.
20:43:26 <Cale> @src curry
20:43:26 <lambdabot> curry f x y = f (x, y)
20:43:29 <synergy_> But I was really just using that as an example
20:43:43 <echo-area> Lazy pattern matching is not documented in Haskell 2010.  Where am I supposed to find it?
20:44:11 <Cale> echo-area: It's not?
20:44:34 <echo-area> I cannot find ~ or tilde in the doc
20:45:01 <Cale> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17 -- see the last branch there "(irrefutable pattern)"
20:45:19 <Zemyla> Shame you can't do list or stream fusion on a comonadic fold.
20:45:26 <Cale> The following section also talks about the semantics of it.
20:47:29 <Cale> synergy_: So in Javascript, I guess you could write something like   function curry(f) { return function (x) { return function (y) { return f(x,y) } } }
20:47:57 <Cale> .oO(that might need some semicolons...)
20:49:00 <Cale> So then you could write: curry(function (x,y) { return x + y })(4)(6)
20:49:10 <Cale> and it should evaluate to 10
20:49:23 <synergy_> Cale: This here is the universal implementation that confused me. I want to grow more able to write code like this and understand it better: http://jsbin.com/meceba/1/
20:49:55 <echo-area> Cale: Thank you, I was fooled by my pdf reader :-(
20:50:03 <jle`> var add = curry(function(x,y) { return x + y; }); var add5 = add(5);
20:50:06 <Cale> synergy_: that just gets me a blank page with a little thingy in the corner that says "edit in JSBin"
20:50:40 <synergy_> Yea just click that
20:50:41 <Axman6> mine's completely blank
20:50:57 <Axman6> oh, it appeared
20:51:14 <Cale> oh, I see
20:51:52 <Cale> Yeah, that's like some weird thing which tries to do it for any number of arguments
20:52:02 <Cale> Which I guess is reasonable
20:52:23 <Cale> I have a bit of a hard time believing that there isn't something a bit simpler you could do
20:53:13 <Cale> bad for trying to understand what currying is about though
20:54:19 <Cale> also, it's weird that it's taking an array of args
20:54:36 <Cale> Wait, what is this even doing?
21:15:39 <HeladoDeBrownie> is there a tool for detecting unused imports that's easier than manually searching for occurrences of imported names?
21:16:05 <HeladoDeBrownie> ("manually searching" meaning using the search function of a text editor or somesuch)
21:16:18 <glguy> GHC has warnings for unused imports. Is that what you mean?
21:16:27 <HeladoDeBrownie> that sounds like it'd be good. how do i enable that?
21:16:35 <AshyIsMe> syntastic in vim shows up those warnings directly in the editor
21:16:44 <AshyIsMe> there's a similar setup for emacs i thnik
21:16:55 <glguy> It's turned on by -Wall, and I don't know what the actual name of the flag is. I can look.
21:17:12 <glguy> Looks like: -fwarn-unused-imports
21:17:30 <HeladoDeBrownie> related, how do i pass a ghc option to cabal for use with cabal run?
21:17:53 <glguy> The way to do it with cabal configure is --ghc-options=
21:18:01 <HeladoDeBrownie> thanks!
21:24:43 <NemesisD> anyone know of a good idiom for :: Monad m => (a1 -> a2 -> m r) -> m a1 -> m a2 -> m r
21:26:04 <NemesisD> i know i could get it done with liftM2 and join
21:27:23 <NemesisD> looks like some parallel libraries call it bindM2
21:27:40 <Rotaerk> that's what I was thinking
21:31:18 <stolenValor> I'm stealing all the valor. Na Na Na Na boo boo
21:33:22 <stolenValor> I just figured out what I'm going to do. The next place that refuses to let me wear my wolf fursuit... I'm going to come in there wearing an army uniform.
21:33:42 <stolenValor> And I'm going to flip out on anyone who has a problem with it.
21:34:58 <stolenValor> I'm so ready to flip out on some sorry fuck.
21:35:43 <Cale> stolenValor: This channel is for discussion of the programming language Haskell.
21:35:47 --- mode: ChanServ set +o Cale
21:35:52 <stolenValor> Fuck haskell
21:35:57 --- mode: Cale set +b *!*@2600:1008:b065:6ad3:2544:e8e3:6fa8:91ca
21:35:58 --- kick: stolenValor was kicked by Cale (stolenValor)
21:36:01 --- mode: Cale set -o Cale
21:36:21 <Cale> synergy_: Are you still here?
21:36:54 <Cale> synergy_: I relearned enough Javascript to implement a generic (multiple args) curry which is much simpler than the one you've been looking at
21:37:56 <Cale> There may be something simpler still, but I don't exactly use Javascript all the time, so I don't know.
21:38:14 <Cale> function curryHelper(f,n,xs) { return (n == 0) ? f.apply(this,xs) : function (x) { return curryHelper(f,n-1,xs.concat([x]))} }
21:38:21 <Cale> function curry(f) { return curryHelper(f,f.length,[]) }
21:38:37 <Cale> So you can then write:
21:38:45 <Cale> curry(function (x,y,z) { return (x + y + z) })(2)(30)(400)
21:38:51 <Cale> and get the result 432
21:41:59 <jle`> NemesisD: i consider that particular situation a situation where do notation shines...one of the reasons why it was created in the first place :)
21:42:25 <jle`> i don't think you'll find anything more idiomatic than do notation there.  there's a time for monadic combinators and higher order functions, and there's a time for do notation
21:47:34 <NemesisD> i can make it pretty nice if applicative was a superclass of monad *grumble*
21:49:07 <xnull> :t read
21:49:08 <lambdabot> Read a => String -> a
21:49:17 <xnull> > read . show 5
21:49:19 <lambdabot>  Couldn't match type ‘[GHC.Types.Char]’ with ‘a -> GHC.Base.String’
21:49:19 <lambdabot>  Expected type: a -> GHC.Base.String
21:49:19 <lambdabot>    Actual type: GHC.Base.String
21:49:20 <xnull> > read . show $ 5
21:49:22 <lambdabot>  *Exception: Prelude.read: no parse
21:49:57 <xnull> > (read :: String -> Integer) . show $ 5
21:49:59 <lambdabot>  5
21:50:11 <jle`> NemesisD: how would you make it nice? :)
21:50:45 <NemesisD> jle`: bindM2 f ma mb = join (f <$> ma <*> mb
21:50:47 <NemesisD> )
21:51:39 <xnull> :t show
21:51:39 <lambdabot> Show a => a -> String
21:51:45 <xnull> :t map read . show
21:51:46 <lambdabot>     Couldn't match type ‘Char’ with ‘[Char]’
21:51:46 <lambdabot>     Expected type: a -> [String]
21:51:46 <lambdabot>       Actual type: a -> String
21:51:53 <xnull> ohhh duh
22:05:38 <xnull> :t zero
22:05:39 <lambdabot>     Not in scope: ‘zero’
22:05:39 <lambdabot>     Perhaps you meant ‘mzero’ (imported from Control.Monad.Writer)
22:05:43 <xnull> :t isZero
22:05:44 <lambdabot> Not in scope: ‘isZero’
22:05:47 <xnull> :t null
22:05:48 <lambdabot> [a] -> Bool
22:05:55 <xnull> :t empty
22:05:56 <lambdabot> Alternative f => f a
22:15:13 <xnull> :t mod
22:15:14 <lambdabot> Integral a => a -> a -> a
22:16:08 <xnull> :t odd
22:16:09 <lambdabot> Integral a => a -> Bool
22:16:12 <xnull> :t even
22:16:13 <lambdabot> Integral a => a -> Bool
22:31:01 <gyaretto> Is anyone else unable to get to haskell.org?
22:31:30 <HeladoDeBrownie> gyaretto, i get a notice from cloudflare saying it's down
22:31:37 <gyaretto> Yeah, I get the same.
22:31:48 <peddie> gyaretto: https://status.haskell.org/
22:31:49 <laudiacay_mobile> It's up
22:31:53 <peddie> I can load it just fine
22:31:59 <laudiacay_mobile> Just pinged
22:32:01 <HeladoDeBrownie> i just loaded it fine
22:32:51 <gyaretto> Now I can get to it.
22:32:52 <gyaretto> Weird.
22:33:19 <laudiacay_mobile> Deb is down
22:39:03 <jle`> sometimes i use head
22:39:21 <jle`> in situations where i can provide a proof but ghc can't
22:39:25 <jle`> it still makes me uncomfortable though
22:39:31 <laudiacay_mobile> jle`: like for the front of a list ? Why ?
22:40:06 <jle`> > map head (group "aaabbcddd")
22:40:07 <lambdabot>  "abcd"
22:40:19 <jle`> group never gives any empty lists in its output
22:40:19 <laudiacay_mobile> Wait what
22:40:24 <laudiacay_mobile> How did that work
22:40:30 <laudiacay_mobile> Sorry I'm on like day 1
22:40:33 <jle`> > group "aaabbcddd"
22:40:34 <lambdabot>  can't find file: L.hs
22:40:36 <jle`> > group "aaabbcddd"
22:40:38 <lambdabot>  ["aaa","bb","c","ddd"]
22:40:47 <jle`> group groups up elements into chunks of equal items
22:40:54 <jle`> and `map head` applies `head` to every item
22:41:18 <jle`> usually we don't like to use head because it can cause a runtime error...we like to use solutions where the compiler can guarantee that we don't have runtime errors
22:41:21 <laudiacay_mobile> So map
22:41:49 <laudiacay_mobile> And the error would be for empty list but
22:42:00 <laudiacay_mobile> Map means apply to everything in a list?
22:42:27 <jle`> yeah
22:42:30 <scott> map f [1,2,3] == [f 1, f 2, f 3]
22:42:49 <jle`> > map sqrt [1,4,9,16,7]
22:42:50 <lambdabot>  [1.0,2.0,3.0,4.0,2.6457513110645907]
22:43:10 <laudiacay_mobile> And it takes as argument a function and a list or a function of a list?
22:43:15 <jle`> :t map
22:43:16 <lambdabot> (a -> b) -> [a] -> [b]
22:43:29 <jle`> it takes a function from a to b, and a list of a's, and returns a list of b's
22:43:48 <laudiacay_mobile> Wait what
22:43:49 <laudiacay_mobile> Sorry
22:43:54 <jle`> > map even [1,2,3,4]
22:43:55 <lambdabot>  [False,True,False,True]
22:44:00 <laudiacay_mobile> Oh wow
22:44:14 <jle`> so say [1,2,3,4] is a list of Ints
22:44:25 <jle`> `even` can be a function from Int to Bool, Int -> Bool
22:44:29 <jle`> and the result is a list of Bools
22:44:31 <laudiacay_mobile> > map (even [1,2,3,4])
22:44:33 <lambdabot>  Couldn't match expected type ‘a -> b’
22:44:33 <lambdabot>              with actual type ‘GHC.Types.Bool’
22:44:38 <laudiacay_mobile> Ok
22:44:42 <scott> > (map even) [1,2,3,4]
22:44:43 <lambdabot>  [False,True,False,True]
22:44:53 <laudiacay_mobile> Is map even a function on its own
22:45:58 <augur_> yes, map is a function on its own
22:45:59 <augur_> :t map
22:46:01 <lambdabot> (a -> b) -> [a] -> [b]
22:46:25 <augur_> this type says that map is a function (thats what -> means) that takes an 'a -> b' and returns an
22:46:30 <laudiacay_mobile> scott: could you draw that out for me with like java-style parentheses around the argument in each thing ?
22:46:30 <augur_> an '[a] -> [b]'
22:46:40 <laudiacay_mobile> Ohhhhh
22:46:44 <laudiacay_mobile> OHHH
22:46:56 <laudiacay_mobile> Ok I get it OMG thank you!!
22:46:57 <augur_> so    map even   is now map applied to the even function
22:47:03 <augur_> and the result is itself a function:
22:47:04 <ezyang> Suppose I have a record with type 'K a', and I'd like to do a record creation with type 'K Int' using k { x = ... }. How can I monomorphize the "constructor"? If I surround it with ':: K Int' I get an error relating the full expression to 'K Int', whereas I want the specific binding which violated my type to be errored
22:47:05 <augur_> :t map even
22:47:06 <lambdabot> Integral a => [a] -> [Bool]
22:47:23 <laudiacay_mobile> Ooh thank you!!
22:48:10 <augur_> and of course you can now apply that function to a list of type '[a]' (where 'a' is any type so long as its an "Integral" type -- one that has integer-like properties, and thus can be even or not)
22:48:30 <augur_> hence:   map even [1,2,3,4]
22:48:39 <laudiacay_mobile> Or also to a function that returns a list?
22:48:43 <augur_> map is a function, applied to even, producing another function, which is applied to [1,2,3,4]
22:48:59 <laudiacay_mobile> Like map even tail [1,2,3,4]
22:49:04 <augur_> laudiacay_mobile: no
22:49:09 <laudiacay_mobile> Oh why not?
22:49:20 <scott> that would be written map even (tail [1,2,3,4])
22:49:22 <augur_> map even   requires precisely and only a list as its argument
22:49:53 <augur_> right, you COULD do   map even (tail [1,2,3,4])   because you first apply 'tail' to the list, producing another list as output
22:49:55 <laudiacay_mobile> So why does parentheses fix that
22:50:07 <augur_> laudiacay_mobile: do you know any Javascript?
22:50:22 <augur_> the analogous javascript would be
22:50:26 <laudiacay_mobile> augur_: im great at java and ok at python and wolfram
22:50:29 <laudiacay_mobile> :|
22:50:37 <augur_> map(even)(tail)([1,2,3,4])   vs   map(even)(tail([1,2,3,4]))
22:51:05 <augur_> in most C-like langs, application of a function f to an arg x is written f(x), but in haskell it's just written f x
22:51:09 <laudiacay_mobile> augur_: what do the parentheses do?
22:51:34 <laudiacay_mobile> Like
22:51:38 <augur_> parentheses do what they always do!
22:51:44 <laudiacay_mobile> Haha
22:51:45 <augur_> they disambiguate
22:52:08 <augur_> so as i said, in haskell, function application is written just as  f x  instead of  f(x)
22:52:15 <augur_> and it's left-associative
22:52:23 <augur_> so if i write   f x y   its like f(x)(y) in JS
22:52:40 <augur_> that is, apply f to x, and get back a function which is applied to y
22:52:45 <laudiacay_mobile> So wait why does map even (tail [1,2,3,4]) work when map even tail [1,2,3,4] does not?
22:52:57 <augur_> because    tail [1,2,3,4]   is a list!
22:53:00 <augur_> :t tail
22:53:02 <lambdabot> [a] -> [a]
22:53:05 <augur_> :t tail [1,2,3,4]
22:53:06 <lambdabot> Num a => [a]
22:53:08 <pavonia> "map even tail [...]" is map applied to three arguments, while in "map even (tail [...]) there are only two arguments
22:53:22 <scott> without parens it is read as  ((map even) tail) [1,2,3,4]
22:53:28 <laudiacay_mobile> pavonia: oh oh oh oh
22:53:31 <laudiacay_mobile> Ok
22:53:37 <laudiacay_mobile> That made sense
22:56:49 <laudiacay_mobile> jle`: what did you mean proof?
22:57:08 <jle`> laudiacay_mobile: usually we write haskell programs so that the compiler can assure that we have no runtime errors
22:57:25 <laudiacay_mobile> Oh yeah my friend told me about that
22:57:31 <laudiacay_mobile> How it was error free
22:57:47 <laudiacay_mobile> So do you just make all functions have a domain of all reals?
22:57:58 <jle`> well, we can always make the conscious decision to throw away compiler guaruntees
22:58:03 <jle`> but if we don't, we can usually rest safely
22:58:08 <jle`> laudiacay_mobile: not quite; we have more powerful tools than that
22:58:33 <jle`> for example, consider a function that returns double the head of a list if the list is not empty, or 0 if it is
22:58:40 <jle`> in another language you might write:
22:58:54 <jle`> foo xs = if null xs then 0 else head xs * 2
22:59:08 <jle`> `null xs` is True when xs is empty and False when it isn't
22:59:34 <laudiacay_mobile> Oh OK
22:59:41 <laudiacay_mobile> And in haskell?
23:00:00 <jle`> foo [] = 0; foo (x:xs) = x * 2
23:00:11 <jle`> using pattern matching
23:00:18 <laudiacay_mobile> Ok well that's over my head
23:00:30 <jle`> if you're following a lesson, pattern matching should come up very soon :)
23:01:03 <laudiacay_mobile> Is that like regex or do i have the stupids
23:01:06 <jle`> if the list is empty, it'll match on the first case, and return 0.  if the list is not empty, it'll match the second case, where the head will be called "x", and return the head * 2
23:01:11 <jle`> nah it's just unfamiliar
23:01:26 <augur_> pattern matching starting with numbers is best, i thin
23:01:27 <augur_> think
23:02:01 <jle`> but this was meant to illustrate a situation where GHC can assure coverage, hm.
23:02:11 <laudiacay_mobile> What does the x:xs mean
23:02:25 <augur_> laudiacay_mobile: dont worry about that, youll learn it soon enough if you're following a tutorial
23:02:38 <laudiacay_mobile> Ok :) thanks
23:02:41 <augur_> the general idea of pattern matching tho is just that you can define functions by exemplifying how they behave in different situations
23:02:47 <augur_> for instance here's one way to define a function
23:03:05 <augur_> isZero x = if x == 0 then True else False
23:03:16 <laudiacay_mobile> Oh oh that's like base cases in recursive functions but not
23:03:23 <augur_> well thats not pattern matching, right
23:03:25 <augur_> thats just a test
23:03:26 <augur_> OR:
23:03:31 <laudiacay_mobile> I'm grasping for straws
23:03:32 <augur_> or you could say what isZero does on each case
23:03:35 <augur_> isZero 0 = True
23:03:41 <augur_> isZero x = False
23:03:51 <augur_> in that order
23:04:00 <laudiacay_mobile> So like 2 different function definitions??
23:04:06 <augur_> almost!
23:04:18 <augur_> its two equations/clauses for one function
23:04:28 <augur_> so the whole collection of equations constitutes the definition
23:04:31 <laudiacay_mobile> Base cases first in priority order, then general stuff
23:04:37 <laudiacay_mobile> Oh I like that a lot
23:04:44 <augur_> it doesnt have to be base cases first, actually
23:04:51 <laudiacay_mobile> Like piecewise functions
23:05:02 <sgronblo> But they are matched in order
23:05:06 <augur_> the matcher tests in order, so the reason the order matters here is that x is a variable, so it matches anything
23:05:06 <laudiacay_mobile> augur_: well like exceptions to the general rule
23:05:16 <laudiacay_mobile> :D
23:05:16 <augur_> so if you want 0 to be special, you need to put it before the catchall x
23:05:20 <Cale> isZero x = if (x == 0) == otherwise then True == True else False && case True of True -> True; _ -> False
23:05:32 <augur_> Cale: you're awful
23:05:53 <laudiacay_mobile> Does that need to be enclosed in anything or is it just like 2 function definitions in a row but not
23:06:02 <laudiacay_mobile> And Cale I'm confused send help
23:06:17 <augur_> cale's just joking about how i wrote isZero using unnecessary if
23:06:19 <laudiacay_mobile> That looks like boolean hell
23:06:21 <Yaniel> it is kind of like overloading the function
23:06:28 <augur_> i could've just written   isZero x = x == 0
23:06:36 <augur_> but i wanted to make a point about matching :P
23:06:48 <laudiacay_mobile> augur_: and x==0 is a conditional thing
23:06:50 <laudiacay_mobile> Ok
23:06:52 <laudiacay_mobile> :)
23:07:07 <augur_> yeah its just a boolean. i mean, you'd never write what i wrote, it was just for pedagogical purposes
23:07:38 <augur_> but like, you could for instance define the not function like so:
23:07:40 <augur_> not True = False
23:07:42 <augur_> not False = True
23:07:50 <augur_> or you could swap those clauses
23:08:11 <augur_> there's no overlap in what matches them, so the order is irrelevant
23:08:18 <augur_> order only matters when clauses overlap in what can match them
23:09:04 <augur_> anyway, im off to bed. night
23:12:45 <laudiacay_mobile> Oh not is a function hahaha
23:12:50 <laudiacay_mobile> That's terrible
23:12:54 <laudiacay_mobile> I love it
23:15:29 <jle`> it's similar to how you'd define it in mathematics :)
23:15:33 <jle`> not(true) = false
23:15:35 <jle`> not(false) = true
23:16:13 <laudiacay_mobile> :d
23:17:25 <catsup> what?  why is it terrible?
23:19:33 <laudiacay_mobile> catsup: its just funny
23:20:31 <catsup> eh, but not is logically a function
23:21:03 <laudiacay_mobile> True just weird for a Java person haha
23:21:31 <catsup> i mean even in java...  it has special syntax but it's still in a deep sense a function
23:23:06 <laudiacay_mobile> Yeah just never thought of it that way, never really considered boolean algebra before
23:30:33 <sgronblo> Haskell is quite good at uprooting many of those accepted "truths" about programming.
23:31:23 * hackagebot monad-parallel-progressbar 0.1.0.0 - Parallel execution of monadic computations with a progress bar  http://hackage.haskell.org/package/monad-parallel-progressbar-0.1.0.0 (mnacamura)
23:31:27 <tzaeru> it is?
