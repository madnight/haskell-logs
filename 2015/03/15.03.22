00:14:00 <funfunctor> how can I fix these Num warnings because only (+) is defined here http://lpaste.net/128187
00:15:05 <shachaf> You didn't post the warning, so I don't know what the warning says. But you should probably do what it says.
00:17:22 <funfunctor> shachaf: well no, thats what I was saying, Num typeclass specifies (*) (abs) and so on.. but only (+) is defined here
00:17:47 <shachaf> Right. That's what the warning is telling you. It's useful information.
00:19:42 <funfunctor> shachaf: I know, I understand the warning fully but my question is how to deal with cases like this where only (+) is properly defined
00:20:05 <funfunctor> I could put abs = undefined to shut it up but that does not seem like the way to do things
00:20:36 <Hijiri> maybe it's not a good Num instance
00:20:40 <shachaf> That seems like a good way to be explicit about the fact that you want abs to be undefined.
00:20:46 <jle`> abs = error "what are you even trying to do?"
00:20:55 <Hijiri> abs = fix error
00:21:34 <funfunctor> Hijiri: perhaps you are right. Maybe I should write a function addTime :: Time -> Time -> Time
00:21:39 <jle`> a more descriptive error message would be fitting, but you might not really have a good num instance
00:22:04 <jle`> you can't relaly expect it to be have well under Num a => ... a ... functions anyway
00:22:05 <jle`> waht's the point?
00:22:08 <funfunctor> is it usual to write add functions explicitly in these cases
00:22:37 <jle`> it's the same thing as not hijacking `Show` to write pretty printers
00:22:59 <dgorbik_>  How do I make TLS throw an exception on timeout?
00:23:17 <jle`> displayData  :: MyData -> String, instead of writing a Show instance that isn't conventional/doesn't fit in with what show is supposed to represent
00:23:32 <dgorbik_> It looks like it never throws anything if I turn off wifi, it's really weird 
00:25:06 <funfunctor> jle`: good point
00:26:13 <jle`> what would be the point of a Num instance??
00:26:21 <jle`> *?
00:29:04 <funfunctor> jle`: idk I was just thinking in terms of restrictions, like if you could have some kind of typeclass restriction
00:29:48 <jle`> ah
01:42:47 <funfunctor> :t (.|.)
01:42:48 <lambdabot> Bits a => a -> a -> a
01:43:10 <funfunctor> > 0x10 .|. 0x13
01:43:12 <lambdabot>  19
01:43:20 <funfunctor> the willy operator :p
01:50:12 <funfunctor> @hoogle and
01:50:14 <lambdabot> Prelude and :: [Bool] -> Bool
01:50:14 <lambdabot> Data.List and :: [Bool] -> Bool
01:50:14 <lambdabot> Data.Foldable and :: Foldable t => t Bool -> Bool
01:50:32 <funfunctor> :t (.&.)
01:50:33 <lambdabot> Bits a => a -> a -> a
01:50:52 <funfunctor> :t (&)
01:50:54 <lambdabot> a -> (a -> b) -> b
01:52:19 <funfunctor> wait, silly question, how do you do a bitwise 'and' and get a true/false answer?
01:52:59 <funfunctor> @hoogle Bits a => a -> a -> Bool
01:53:01 <lambdabot> Data.Bits testBit :: Bits a => a -> Int -> Bool
01:53:01 <lambdabot> Prelude (<) :: Ord a => a -> a -> Bool
01:53:01 <lambdabot> Data.Ord (<) :: Ord a => a -> a -> Bool
01:53:34 <funfunctor> ah, if stmt it is :|
01:54:33 <gfixler> any . map testBit
01:56:23 <funfunctor> :t any
01:56:24 <lambdabot> (a -> Bool) -> [a] -> Bool
01:57:01 <funfunctor> ok awkward, i'll just stick to the if-stmt its clear
01:57:27 <gfixler> you have to use if with Bool anyway, no?
01:57:33 <gfixler> if a && b
01:57:46 <gfixler> I guess it depends on what you're doing
02:00:54 <funfunctor> :t (&&)
02:00:56 <lambdabot> Bool -> Bool -> Bool
02:04:08 <jle`> what do you want to return as flase and what as true?
02:28:31 <funfunctor> so suppose some action m can result in "went well" "went bad" states, usually in C we return essentially a Bool. In Haskell what is usual here? Somekind of MonadPlus usage here?
02:29:05 <opqdonut> if the action is monadic, you can just return a bool
02:29:06 <funfunctor> I can think of Either or Bool
02:29:11 <opqdonut> either is also typical
02:29:16 <funfunctor> ok
02:29:39 <opqdonut> once you start having lots of operations like this and error-handling gets complicated you might want to consider monad transformers or something like that
02:29:39 <funfunctor> because I was looking at this MonadPlus thing today and was wondering if this is a use case?
02:29:43 <opqdonut> but I'd just start with vanilla Either
02:30:07 <funfunctor> funny enough I know how to deal with lots of error states fine
02:30:21 <funfunctor> I was just curious about MonadPlus
02:30:26 <opqdonut> Either is also known as the Error monad
02:30:32 <opqdonut> which verily does have a MonadPlus instance
02:30:37 <opqdonut> ( https://hackage.haskell.org/package/mtl-1.1.0.2/docs/Control-Monad-Error.html )
02:31:08 <opqdonut> and yeah, MonadPlus is pretty much the "failure" abstraction
02:31:15 <jle`> i wrote something small on monadplus a few years ago, http://blog.jle.im/entries/series/+monadplus-success-failure-monads
02:31:22 <opqdonut> failures propagate, and you can use mplus to try many things and keep the first one that succeeds
02:31:52 <jle`> MonadPlus/Alternative are basically used to abstract over Maybe w/ Just/Nothing
02:32:25 <jle`> where "Just" is abstracted over by `return` or `pure`, and "Nothing" is abstracted over by `mzero` or `empty`
02:32:43 <jle`> and you get a monoidal operator action mplus/(<|>)
02:33:37 <jle`> with MonadPlus you have some laws too...binding over a failure should leave the failure unchanged, for instance
02:34:30 <jle`> Nothing >>= _ = Nothing...mzero >>= _ = mzero
02:34:58 <jle`> usually though we just like to use concerete types when we can, in practice
02:35:26 <jle`> besides you can write a MonadPlus m => Maybe a -> m a, so you really don't lose anything by just using Maybe
02:36:10 <jle`> oh, they're used a lot in parsing of course
02:37:59 <jle`> (parser1 <|> parser2 <|> parser3) sort of gives you a "choice" between parsers...but if all three of the parsers are failures, then chaining will do nothing.  (failingparser <|> failingparser <|> failingparser) >>= failingparser... ... roughly ....
02:38:21 <jle`> * == failingparser, roughly.  chaining from a failure propagates failure
02:44:19 <funfunctor> jle`: thx for explaining this so well !
02:54:42 <lf94> Is there a way to avoid using -> for do blocks?
02:54:46 <lf94> Can't I do like
02:54:57 <lf94> main = do { line1; line2; last line; }
02:55:12 <lf94> er
02:55:18 <lf94> actually nevermind what I just said
02:56:07 <lf94> having to type variable <- expression is just annoying I find
02:57:07 <TRManderson> >>= (\var -> (rest of thing))
02:57:15 <jle`> you can use (=<<) or (>>=)
02:57:38 <jle`> do x <- foo; y <- bar; ... is the same as do y <- bar =<< foo
02:57:40 <ChristianS> lf94: yes, instead of  { variable <- expression; funcall variable }  you can do  expression >>= funcall
02:58:16 <lf94> ChristianS, and if I have multiple expressions?
02:58:21 <lf94> I remember there being a way
02:58:25 <lf94> But it was too verbose
02:58:53 <ChristianS> lf94: then do notation with <- will probably be easier to use, though it's just syntactic sugar for >>=
02:59:20 <funfunctor> ChristianS: I thought do notation is actually syntactic sugar for >>=
02:59:29 <ChristianS> yes
02:59:40 <jle`> lf94: if you can give us a specific example, we might be able to try to help you
02:59:47 <funfunctor> you had it the wrong way around :)
03:00:06 <ChristianS> funfunctor: no i said the same thing as you
03:01:04 <funfunctor> ChristianS: oh my bad, didn't read the , properly
03:11:00 <Geekingfrog> I'd like to read a file line by line. Apparently I should use readFile and lines (from System.IO). How is lazy read different from streaming? I'd like to avoid loading the entire file in memory
03:12:12 <jle`> Geekingfrog: that actually only uses "Lazy IO" (different than normal haskell laziness), which only reads things in as much as you need them and lets them go when it decides you don't need it anymore.  so it's kind of supposed to be constant memory
03:12:35 <Geekingfrog> cool! thanks
03:12:36 <jle`> however there is a lot of unpredictability in the "lazy io" mechanics and people usually avoid using it for real work
03:12:42 <jle`> if you're just learning, then it should be fine
03:12:52 <jle`> for most simple applications it should consume and release in constant memory
03:12:53 <Geekingfrog> this is not real work I'm doing anyway so that'll do
03:13:09 <Geekingfrog> just curious, what stuff should I google the day I want to do "real work" ?
03:13:36 <jle`> a transducer library...the leading ones at the moment are "pipes" and "conduit"
03:13:49 <jle`> they give you real guaruntees about when things are loaded and when they are released
03:14:04 <jle`> explicit
03:14:28 <jle`> instead of the implicit way ghc's runtime system offers with lazy io like the ones in System.IO
03:15:57 <Geekingfrog> ok, thanks
03:16:10 <jle`> np!
03:44:12 * hackagebot auto 0.2.0.5 - Denotative, locally stateful programming DSL & platform  http://hackage.haskell.org/package/auto-0.2.0.5 (jle)
03:45:35 <Geekingfrog> I have a file which is almost a csv file, but some lines have a different format. Any recommended lib to parse that?
03:45:53 <Geekingfrog> I was thinking of cassava first but since my file is not perfect csv it won't work
03:52:03 <mpickering> preprocess and remove the lines which arn't in the right format and then parse it with cassava?
03:53:58 <Geekingfrog> ok, my input is simple enough so that should work. I'll try parsec another day then
03:54:12 * hackagebot opaleye 0.3.1.2 - An SQL-generating DSL targeting PostgreSQL  http://hackage.haskell.org/package/opaleye-0.3.1.2 (tomjaguarpaw)
03:54:14 * hackagebot pipes-zeromq4 0.2.0.0 - Pipes integration for ZeroMQ messaging  http://hackage.haskell.org/package/pipes-zeromq4-0.2.0.0 (peddie)
04:12:11 <bjobjo> does anyone have an example of runGetIncremental from Data.Binary.Get? I can't make heads or tails of the example in the documentation...
04:14:13 * hackagebot hydrogen-prelude 0.17 - Hydrogen Prelude  http://hackage.haskell.org/package/hydrogen-prelude-0.17 (JulianFleischer)
04:15:28 <mauke> what's unclear?
04:18:38 <bjobjo> good question... I don't think I get the concept to be honest, it would be nice to see some code that used it in practice, I am obviously too stupid to figure this out on my own ;)
04:19:03 <bjobjo> It doesn't help that I can't find BL.chunk so the example in the documentation doesn't compile for me
04:19:13 * hackagebot hydrogen-parsing 0.17 - Hydrogen Parsing Utilities  http://hackage.haskell.org/package/hydrogen-parsing-0.17 (JulianFleischer)
04:23:55 <mauke> http://hackage.haskell.org/package/bytestring-0.10.4.1/docs/src/Data-ByteString-Lazy-Internal.html#chunk
04:24:13 * hackagebot authenticate-oauth 1.5.1.1 - Library to authenticate with OAuth for Haskell web applications.  http://hackage.haskell.org/package/authenticate-oauth-1.5.1.1 (MichaelSnoyman)
04:24:15 * hackagebot hydrogen-syntax 0.17 - Hydrogen Syntax  http://hackage.haskell.org/package/hydrogen-syntax-0.17 (JulianFleischer)
04:24:26 <bjobjo> so that's where that was hiding :) thanks!
04:24:27 <mauke> concats a strict bytestring and a lazy bytestring
04:26:10 <nikola> I want to write a function that computes fibonacci sequence indefinitely and outputs current fibonnaci number when it recieves sigINT. I know how to compute fibonacci sequence and catch signals with installHandler, but how can I can catch signals inside function that computes fibonacci?
04:27:13 <mauke> oh, this example is kind of evil
04:27:33 <mauke> it peeks into the internal representation of lazy bytestrings to feed the decoder
04:29:09 <mauke> nikola: you can't
04:29:14 * hackagebot hydrogen-prelude-parsec 0.17 - Hydrogen Prelude /w Parsec  http://hackage.haskell.org/package/hydrogen-prelude-parsec-0.17 (JulianFleischer)
04:29:16 * hackagebot stackage-curator 0.7.0 - Tools for curating Stackage bundles  http://hackage.haskell.org/package/stackage-curator-0.7.0 (MichaelSnoyman)
04:30:10 <bjobjo> I see - the problem I am trying to solve is to parse 0..n instances of addresses in the get function in a Binary instance into a list of addresses
04:30:33 <bjobjo> I am struggling with the 0..n part :)
04:31:05 <mauke> what do you mean by 0..n?
04:31:21 <bjobjo> let me post some code to lpaste
04:32:01 <nikola> mauke: Is it possible to write some kind of impure function that might do that? 
04:34:41 <bjobjo> mauke: http://lpaste.net/128196
04:37:28 <mauke> bjobjo: so you want to consume all remaining input as a list of addresses?
04:37:29 <mauke> or what
04:37:48 <bjobjo> yes, using the Binary instance of the PeerAddress type if possible
04:39:28 <mauke> rest :: Get a -> Get [a]; rest g = do e <- isEmpty; if e then return [] else liftM2 (:) g (rest g)
04:40:07 <mauke> ... <*> rest get
04:40:32 <bjobjo> interesting! I'll try it out
04:40:34 <bjobjo> thanks :)
04:44:14 * hackagebot hydrogen-cli-args 0.17 - Hydrogen Command Line Arguments Parser  http://hackage.haskell.org/package/hydrogen-cli-args-0.17 (JulianFleischer)
04:55:14 <Haskellfant> I'm trying to use OverloadedLists instead of fromList, but it fails with a strange type error http://lpaste.net/128197 . I looked at the definition of Item for Set and it should be WLCModifier
04:56:38 <Haskellfant> if I use fromList it seems to work fine
04:57:38 <Haskellfant> that is fromList from Data.Set, fromList from GHC.Exts fails
05:00:18 <supki> Haskellfant: does your version of containers have the IsList Set instance?
05:01:04 <Haskellfant> supki: oh it doesn't, I was just looking on hackage
05:01:08 <Haskellfant> thx
05:10:50 <mrkkrp> Hello, suppose I need to generate alpha-numeric identifier (String), it must be at least one character long and cannot start with a number. Is there something predefined for this in QuickCheck or should I generate it manually? Characters may be non-Latin.
05:13:12 <ocharles_> mrkkrp: I would go with: liftA2 (:) (choose ('a', 'z')) arbitrary
05:13:33 <ocharles_> You can always give that a name, like alphaNumIdentifier :: Gen String
05:14:16 * hackagebot yesod-bin 1.4.5.1 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.5.1 (MichaelSnoyman)
05:14:38 <mrkkrp> I like this, but I would like to generate non-Latin characters too. Is there some generator to generate characters that are neither numbers or punctuation marks?..
05:15:29 <mrkkrp> Although I could start with Latin and Greek characters only...
05:16:01 <Cale> mrkkrp: arbitrary `suchThat` isLetter ?
05:16:16 <Cale> Or uh...
05:16:30 <mrkkrp> Cale, I should try this too.
05:16:33 <Cale> isAlphaNum
05:17:05 <Cale> isAlphaNum will select digits which are outside of ASCII range as well
05:17:10 <mrkkrp> `suchThat` is QuickCheck's built-in?
05:17:12 <Cale> but isDigit won't
05:17:22 <Cale> It's part of the Gen library, yeah
05:17:35 <mrkkrp> OK, thank you, guys!
05:19:16 * hackagebot stackage-types 1.0.0 - Shared data types between various Stackage packages  http://hackage.haskell.org/package/stackage-types-1.0.0 (MichaelSnoyman)
05:24:16 * hackagebot stackage-curator 0.7.0.1 - Tools for curating Stackage bundles  http://hackage.haskell.org/package/stackage-curator-0.7.0.1 (MichaelSnoyman)
05:25:24 <nkar`> is there a more concise way of writing this function? https://gist.github.com/nkaretnikov/f2264ba6089c213be449
05:27:11 <bennofs> In GHC haskell, is there a way to deduce Void from a constraint such as Int ~ Float ?
05:27:48 <int-e> nkar`: why does subseq return a list rather than a Bool?
05:30:38 <nkar`> int-e: because I want to translate it to coq: Inductive subseq {X : Type} : (list X) -> Prop := ...
05:31:09 <bennofs> Hmm, I'm matching a GADT, and I either get: inaccesible code (when adding a clause for the impossible match) or a warning about incomplete pattern matches. What is the correct way to handle this?
05:31:11 <nkar`> but I couldn't do it, so I started writing it in haskell
05:31:41 <Rembane> bennofs: I think Maybe is a quite good match.
05:31:51 <marisa__> Coq? Coq programmer here.
05:31:59 <marisa__> Can you repeat the question again?
05:32:02 <int-e> nkar`: that doesn't answer the question, I think
05:32:14 <nkar`> int-e: what do you mean?
05:32:44 <nkar`> marisa__: is there a more concise way of writing this function? https://gist.github.com/nkaretnikov/f2264ba6089c213be449
05:33:12 <pavonia> nkar`: Why did you add the "| xs == ys  = xs" case?
05:33:14 <marisa__> Sorry, can't open gist... gov banned gist in China. Mind if you put it on github repo?
05:33:19 <int-e> nkar`: It's still far more natural to write as a predicate.
05:33:19 <nkar`> marisa__: I'm having trouble expressing it in coq, so I started with haskell
05:33:32 <nkar`> int-e: it's an exercise from the software foundations book
05:33:53 <marisa__> Which page? I have the book.
05:34:08 <bennofs> @let data T a where A :: Int -> T Int; B :: String -> T String
05:34:09 <lambdabot>  .L.hs:158:1:
05:34:09 <lambdabot>      Multiple declarations of ‚ÄòT‚Äô
05:34:09 <lambdabot>      Declared at: .L.hs:154:1
05:34:16 <bennofs> @let data T a where A :: Int -> T Int; B :: String -> T String
05:34:18 <lambdabot>  Defined.
05:34:32 <ocharles_> Cale, mrkkrp: I personally wouldn't use 'suchThat' here - if you know the possible domain you want to choose from, I'd be up front about it
05:34:38 <nkar`> marisa__: I don't have the printed version. it's "Exercise: 4 stars, advanced (subsequence)" in the prop chapter
05:34:38 <ocharles_> you're just wasting cycles other wise
05:34:43 <bennofs> :t let f :: T Int -> Int; f (A i) = i in f
05:34:44 <lambdabot> T Int -> Int
05:34:52 <marisa__> OK. I'll go have a look.
05:35:08 <bennofs> in that example, the pattern match of f is exhaustive, but GHC doesn't seem to get that?
05:35:45 <marisa__> nkar`: subsequence, right?
05:35:46 <ocharles_> `suchThat` just keeps generating until a value satisfies a predicate - but if you know *all* values that satisfy the predicate, then you might as well just sample from that set
05:35:51 <nkar`> marisa__: yes
05:37:06 <nkar`> pavonia: good catch, I forgot to remove it
05:37:51 <scott> bennofs: it's working fine in that example. your problematic code must be different in some way
05:38:13 <marisa__> nkar` : sorry, skip that quesion when doing exercise... Can you show me when you proved it?
05:38:22 <Cale> ocharles_: Well, sure, but it might be annoying to go get all the appropriate ranges
05:38:51 <Cale> ocharles_: I suppose you could just filter the list of all Char values and it wouldn't be so bad :)
05:38:57 <ocharles_> right :)
05:39:04 <nkar`> marisa__: could you paraphrase?  I don't understand the question
05:39:08 <ocharles_> I think text-icu should have support for these character sets, too
05:39:23 <ocharles_> in general enumerating these sets is useful stuff that should be in a library anyway
05:40:02 <marisa__> nkar` :https://github.com/lolisa/COQ_code/blob/master/Software_Foundations/Prop.v here
05:40:37 <marisa__> ignore what I said starting with "sorry". I got it.
05:41:13 <nkar`> marisa__: if it's a solution, I don't want to see it yet.
05:41:37 <marisa__> OK... Don't go see it than. What kinds of hint do you want from me?
05:41:42 <int-e> nkar`: I expect that if you start from  subseq :: Eq a => [a] -> [a] -> Bool  you can essentially read off an inductive definition by dropping the cases that result in False.
05:42:32 <nshepperd> bennofs: yes, the exhaustiveness checker is not entirely correct wrt GADTs and things. there was a new paper solving it three weeks ago, so with any luck it will be fixed in a new version of ghc
05:42:33 <int-e> So I don't know why you want the return type to be [a], and I actually believe trying it that way is harmful.
05:42:41 <marisa__> int-e: yes, but decidability on equality isn't available for everything. You can't have equal dec on lambda expression, for example
05:43:49 <mrkkrp> QuickCheck: suppose I have some generator Gen a, how can I test it from REPL? I know about `generate', but how to generate list of `a' objects?
05:44:14 <rui> m0rphism: You around?
05:44:16 <int-e> marisa__: that's a different problem.
05:44:19 <marisa__> Also, doing prove on [a]->[a]->Prop is easier than [a]->[a]->Bool, as you cannot do induction or case analysis on the later one
05:44:39 <m0rphism> rui: yep :)
05:44:46 <marisa__> Yes, but we don't want subseq to not work on lambda expression...
05:44:47 <int-e> marisa__: instead of an equality test, there will be a case that says that if xs is a subsequence of ys then z:xs is a subsequence of z:ys.
05:44:48 <nkar`> int-e: hm, I tried that, but switched to [a] because the inductive definition of pal (see my other gist) works with list-like structures on the value level (even though the result is of type Prop)
05:45:07 <rui> m0rphism: Hey, whats up :).  Do you use nixOS?
05:45:25 <marisa__> nkar`: Inductive sub { T } : list T -> list T -> Prop :=
05:45:26 <marisa__> | sub_nil : sub [] []
05:45:26 <marisa__> | sub_skip : forall l r e, sub l r -> sub l (e :: r)
05:45:26 <marisa__> | sub_con : forall l r e, sub l r -> sub (e :: l) (e :: r).
05:45:28 <marisa__> try this
05:45:32 <m0rphism> rui: Yes, I switched a few weeks ago from Arch linux.
05:45:53 <nkar`> marisa__: thanks for the spoiler :\
05:45:58 <rui> m0rphism: Haha, nice. I switched yesterday after I screwed up my fedora beyond repair
05:46:24 <geekosaur> fedora's beyond repair anyway >.>
05:46:26 <marisa__> Sorry... I think you are asking for the inductive definition part QAQ
05:46:34 <int-e> marisa__: But I was trying to humor nkar`'s approach of writing a test in Haskell first as inspiration for an inductive definition, and then the Eq a => is necessary because we can only conveniently write predicates as functions returning Bools.
05:46:58 <m0rphism> rui: Yeah, that happend to me also quite a few times with various distribution ;)
05:47:01 <rui> geekosaur: Well, it was my first and only experience after Windows. In comparison, it felt quite near repair
05:47:06 <marisa__> OK, didn't see that.
05:47:35 <marisa__> It isn't much anyway... proving the rest take another 60 LOC... Good luck. (Sorry Sorry Sorry)
05:49:00 <rui> m0rphism: What drove you away from arch?
05:49:11 <rui> I never used it but I definately used its wiki a huge lot
05:49:17 * hackagebot lhs2html 0.999999 - Compile lhs in bird style to md, html, hs.  http://hackage.haskell.org/package/lhs2html-0.999999 (JulianFleischer)
05:49:38 <marisa__> nkar` : Oh fuc* I just caught a bug in my inductive definition... It isn't even correct ORz...
05:52:13 <marisa__> No I am actually right... The books definition on subsequence is a bit strange...
05:53:47 <int-e> marisa__: well, you can have   sub [] r  and  sub l r -> sub (e :: l) (r' ++ e :: r), with only two cases.
05:54:18 * hackagebot nicify-lib 1.0 - Pretty print the standard output of show for algebraic datatypes  http://hackage.haskell.org/package/nicify-lib-1.0 (JulianFleischer)
05:54:46 <m0rphism> rui: My switch wasn't really specific to arch. It was rather specific to NixOS ;) A week before I switched, I was already playing around with nix on arch and liked the unconventional way it's package management worked.
05:54:54 <m0rphism> Especially, that different packages can depend on different versions of the same dependency, because every package is installed in its own directory, and the active ones are symlinked to the scope you want.
05:55:01 <int-e> marisa__: and I guess cases can also overlap, so the base case can be  sub_empty :: sub [] r  instead of  sub_nil :: sub [] []  in your definition.
05:55:56 <m0rphism> Also that nixpkgs is very open to pull requests and community contributions and in contrast to the Arch User Repository (AUR) has a build-bot making binary packages.
05:55:57 <marisa__> Yes, case can overlap, but I think it is easier to prove if they doesn't. (I think this is quote from Coq Art)
05:57:08 <marisa__> Maybe more like matter of taste or it depends on situation...There Is more Than One Way
06:00:53 <m0rphism> rui: While I still appreciate those points, but I'm currently a bit less enthusiastic, because I think the distribution is not that mature yet.
06:00:57 <m0rphism> A lot of things are only documented by code and I experienced that for some software I want, it is not that trivial to craft nix-expressions to make them work with the isolated packages.
06:01:56 <m0rphism> Also the unstable channel has not been updated for 2 months, because of problems with the build-bot.
06:03:00 <rui> m0rphism: :/
06:03:15 <m0rphism> Or binary only programs which use paths like /bin/bash
06:03:27 <m0rphism> However, these problems seem to be not conceptual problems, and I think the architecture changes are a way in the right direction, even if they are not unix conform.
06:03:57 <rui> m0rphism: I hope it is active enough to work through the issues
06:07:28 <m0rphism> rui: Me, too. Because I really like the concepts :)
06:09:18 * hackagebot nicify 1.2 - Pretty print the standard output of default `Show` instances.  http://hackage.haskell.org/package/nicify-1.2 (JulianFleischer)
06:09:24 <Darwin226> Hey guys. Got a computability (I guess) question. If you have a language where each function only knows about the ones defined before it, but you allow higher order functions, is it possible to write an infinite recursion?
06:10:21 <Darwin226> I know fix let's you write recursion using higher order functions, but it still uses a recursive let binding for it's implementation
06:11:38 <Iceland_jack> Darwin226: You usually assume 'fix' as a primitive construct in that case
06:11:45 <Confusionist> Darwin226, that depends on whether you are allowed to reference the function currently being defined. If you're not, you need to define the Y-combinator or something similar, which may be the answer you are looking for?
06:11:54 <Cale> If either the language is untyped, or there's recursion at the type level, you can write fix as the Y combinator
06:11:56 <Iceland_jack> if you're working in a typed setting
06:12:36 <lpaste> Cale pasted ‚ÄúY combinator using type level recursion‚Äù at http://lpaste.net/128199
06:12:45 <Darwin226> I'm actually wondering how much I can allow while still making infinite recursion impossible
06:13:25 <Cale> Darwin226: Are you aware of languages like Coq and Agda?
06:13:43 <Darwin226> Cale: I'm aware of them
06:14:26 <marisa__> Darwin, Of course. Y combinator
06:15:30 <Cale> Darwin226: Those languages have the property that all programs terminate (unless the program has a coinductive type, in which case it's guaranteed to be productive instead)
06:16:54 <Cale> Darwin226: There's a structual recursion condition, which says that at least one argument to any function must be decreasing, in the sense that you're applying the function in that argument to some part of the structure that was matched
06:17:14 <Cale> (in the recursive application)
06:17:29 <Darwin226> Cale: Interesting. This was one of the ideas I was considering
06:18:24 <int-index> I'm thinking about creating SQL-queries using the formatting package. How bad is this idea?
06:18:44 <marisa__> Darwin, If you want to make a language non turing complete but able to do tons of things, an approach is allow only structural recursion. This is how Coq and other dependent type language solve their problem.
06:19:19 * hackagebot nicify-lib 1.0.1 - Pretty print the standard output of default `Show` instances.  http://hackage.haskell.org/package/nicify-lib-1.0.1 (JulianFleischer)
06:19:40 <int-index> marisa__: also corecursion and codata (Agda does that)
06:21:42 <marisa__> Yeah, forgot about that... Sorry.
06:21:45 <rui> m0rphism: I like the idea of having (most of) my configuration, software, and state, etc, in a few readable configuration files, and having profiles, etc.
06:22:06 <Darwin226> marisa__: Well, I try to work with what I know and can think of myself and expand that knowledge a bit with every project, but still keep it realistic. So I'd rather sacrifice a bit more of what the language can do if it simplifies the restrictions.
06:22:08 <rui> Hope it turns out fine
06:23:15 <marisa__> Daewin226, I don't get what you mean. What restriction?
06:23:27 <marisa__> Ooh I get it.
06:24:19 * hackagebot nicify 1.2.1 - Pretty print the standard output of default `Show` instances.  http://hackage.haskell.org/package/nicify-1.2.1 (JulianFleischer)
06:24:36 <marisa__> In that case, structural recursion alone is pretty good. Not hard to understand (if you have data as a function's decreasing argument, you can only recurse on the constructor's argument)
06:25:07 <marisa__> And non-decreasing argument cannot be recursed.
06:25:46 <marisa__> Another approach is bloop presented in GEB: allow only primitive recursive function. Can't write Ackerman function however.
06:26:09 <Darwin226> marisa__: I'll definitely look into that but it still seems pretty complex. The static checker needs to make sure it's decreasing.
06:27:07 <marisa__> Daewin226, need a few example?
06:27:09 <Darwin226> marisa__: Basically, I could start with a simple imperative language that just disallows jumping back and then keep adding feature that I feel are not to hard to make save
06:27:11 <Darwin226> safe*
06:27:14 <int-index> Darwin226: termination checking is hard. How about politely asking the usir not to write non-terminating functions?
06:27:24 <int-index> user*
06:27:54 <Darwin226> int-index: I'm a programmer. Not a social engineer :D
06:28:04 <marisa__> Or you can ask user to annotate their function as "non terminating" if your checker isn't sure.
06:28:18 <m0rphism> rui: Yep, me too. Also the purity in the sense of reproducing system state by configurations, rollback etc. There are also significant upsides to using it :)
06:28:26 <marisa__> This is how idris do it (don't know much about idris)
06:29:10 <int-index> marisa__: Agda too, it has {-# TERMINATING #-} pragma to assure the compiler that a function terminates (even if the checker thinks otherwise)
06:29:44 <Darwin226> I'm still trying to figure out how the y-combinator messes with my plans
06:30:20 <Darwin226> I mean "y = \f -> (\x -> f (out x x)) (In (\x -> f (out x x)))"... I feel like I need to increase my brains stack size to get it
06:30:31 <rui> m0rphism: I don't understand yet where the "system state" ends however. If one tweaks some stuff by hand, outside of the configuration.nix files, does it all get deleted in the next nixos-rebuild switch?
06:30:53 <rui> Or only some files, like /etc/fstab? Or what? I'll learn on the go :)
06:31:43 <marisa__> This is where being a Coq programmer become a bit lame... No such support in Coq. The closest you can do is require the user to input an additional nat and recurse on it. And extract it to haskell code and send in an infinite number (lazyness
06:33:09 <marisa__> Or do "admit" on "Function"...
06:33:10 <m0rphism> rui: I can't answer that formally, but from my experience that depends on whether nixos-rebuild has to touch that state. For example I recently changed how sudo behaves using the visudo command, which changes the sudo configuration file, and this change was reverted by nixos-rebuild, if I remember correctly.
06:34:20 <m0rphism> rui: we could also PM, I hope we are not annoying the "pure" haskellers here by talking about nix ^^
06:34:21 <rui> m0rphism: ...so in some cases one is limitted by how "tweakable" is some part of the system through nix
06:34:45 <rui> True. Sorry people
06:39:20 * hackagebot hydrogen-prelude 0.18 - Hydrogen Prelude  http://hackage.haskell.org/package/hydrogen-prelude-0.18 (JulianFleischer)
06:43:46 <sammex> Hello! I have a problem: I have hexagonal tiles and want to address them using X- and Y-coordinates. How can I find out adjacent tiles in an easy but efficient way, without many if-clauses?
06:45:49 <marisa__> abs(l.x-r.x)+abs(l.y-r.y)=1?
06:46:19 <Ke> marisa__: is that heaxagonal
06:46:26 <Ke> -a
06:46:30 <marisa__> sorry I miss that
06:48:33 <Ke> there is x+-1, y+-1 and (x,y)-+1 
06:50:48 <marisa__> What's the difference between arrow in Category theory and function? Newbie in cat...
06:52:18 <absence> marisa__: arrows are functions in some categories, but not all
06:52:19 <Ke> I guess x*y=-1 or abs(x)+abs(y)=1, where x and y are differences in coordinates
06:53:18 <marisa__> So I guess I can just assume them equal most of the time, until I get to the latter part?(start reading today)
06:53:28 <marisa__> * start started
06:54:07 <safinaskar> "do" allows "{}"-syntax
06:54:17 <safinaskar> what other constructs allow such syntax?
06:54:26 <barrucadu> Everything
06:54:36 <sammecs> i.e. case
06:54:40 <barrucadu> Whitespace syntax desugars to braces and semicolons
06:54:42 <safinaskar> "if"?
06:57:19 <m0rphism> safinaskar: everyhing which otherwise uses blocks of semantic white space. `if c then t else f` is already expressible as a one liner.
06:57:43 <sammecs> marisa__: I don't understand why x*y should be -1, can we make clear how coordinates are assigned to tiles?
06:57:50 <safinaskar> m0rphism: thanks
06:58:36 <m0rphism> safinaskar: You're welcome! :)
06:59:26 <nshepperd> sammecs: one way to address tiles is by putting them in staggered rows, like this http://pastebin.com/wu6hZ4Vh
07:01:17 <nshepperd> sammecs: in which case a tile's neighbors are those in the same row (x ¬± 2, y) or in an adjacent row either on the left or the right (x ¬± 1, y ¬± 1)
07:03:36 <sammecs> Ahh! OK thanks, nshepperd.
07:07:37 <marisa__> For now I want to emphasize that, unlike in the
07:07:37 <marisa__> previous section, the objects donít have to be sets and the arrows need not
07:07:37 <marisa__> be functions. can anyone give an example?
07:07:52 <Cale> marisa__: Sure...
07:08:56 <idnar> is there an existing function like Alternative f => (a -> Bool) -> a -> f a ?
07:09:01 <Cale> marisa__: Given a set S, a preorder <= on S is a binary relation which is reflexive, i.e. for every a in S, we have a <= a, and transitive, i.e. for every a, b, c in S, if we have a <= b and b <= c, then we have a <= c
07:09:25 <Cale> marisa__: Given any preordered set (S,<=), we can define a category which has the elements of S as its objects
07:09:40 <Cale> and a single arrow a -> b whenever a <= b
07:09:59 <marisa__> Wow. Never thought about that. Thx.
07:10:31 <marisa__> and id is just a <= a?
07:10:33 <Cale> Similarly, the objects of a category might be statements in a logic, and the arrows then might be derivations of one statement from another
07:10:38 <Cale> yep
07:11:09 <marisa__> than the arrows mean implication? Just like Curry Howard Corrspondance?
07:11:15 <Cale> yeah
07:11:17 <Cale> Well...
07:11:21 <Cale> Kind of :)
07:11:22 <marisa__> Thx.
07:11:49 <Cale> There's a subtle distinction between implication (within the logic) and derivability (as a statement *about* the logic)
07:11:59 <marisa__> |= ?
07:12:05 <Cale> |-
07:12:07 <Luke> Cale: you know neil mitchells handle on IRC?
07:12:15 <Cale> Luke: Pretty sure it'ndm
07:12:18 <Cale> it's*
07:12:19 <marisa__> OK, thx.
07:12:19 <Luke> oh right -yeah
07:12:20 <Luke> thanks
07:12:21 <Cale> ndm
07:12:27 <Luke> he's just never on =(
07:12:34 <alynn> idnar: it's a little like mfilter
07:12:37 <Cale> Yeah, haven't seen him around in a long time
07:12:37 <marisa__> |= is the weaker form?
07:12:41 <alynn> but that's MonadPlus rather than Alternative
07:13:28 <Cale> Well, these symbols kind of get used for lots of similar things, but |= is usually expressing something about an interpretation of the logic
07:13:40 <Luke> Cale: re: the shake target problem I was having yesterday. It seems to be fixed by not calling my shake folder .shake
07:13:47 <Luke> Cale: so you did help me fix that. Thanks
07:13:59 <Cale> That certain statements on the right of the |= hold under interpretation about the structure on the left of it
07:14:09 <Cale> |= is usually read "models" if that helps
07:14:19 <Cale> while |- is read "proves"
07:14:32 <marisa__> Thankyou. It's it called entailment or something similiar?
07:14:40 <Cale> yes, that's |-
07:14:55 <Cale> So, yeah, you get a category from entailment
07:15:16 <Cale> where there's a single arrow A -> B whenever A |- B
07:15:22 <Cale> but then there's a fancier category
07:15:40 <idnar> alynn: yeah
07:15:49 <idnar> alynn: it may be a slightly weird thing to want
07:15:50 <Cale> where there's an arrow A -> B for each proof of A |- B
07:16:08 <ph88> why am i getting this error?  http://lpaste.net/4606857869596295168
07:16:23 <Cale> and there's some notion of composition of proofs which involves gluing proof trees together
07:16:25 <rola> does |= correspond to semantics and |- to syntax?
07:16:32 <Cale> rola: yes
07:16:39 <idnar> alynn: in fact, I think I just want Monoid here instead, so that means I should foldMap instead of traverse
07:16:42 <Cale> At least, that's usually the idea
07:16:46 <marisa__> Proof theory?
07:16:53 <Cale> marisa__: yeah
07:17:16 <Cale> so... what else? There are a *lot* of examples of categories :)
07:17:35 <marisa__> :) It is enough. I am just curious
07:17:57 <Cale> Given a topological space X, we can define a category whose objects are the points of X, and whose arrows x -> y are the equivalence classes of paths from x to y in the space X
07:18:03 <Cale> up to homotopy
07:18:52 <Cale> If you're not familiar with homotopy, basically that means two paths are equivalent if we can continuously deform one into the other while keeping the ends of the path held fixed
07:19:18 * marisa__ back to reading. THX! (Actually I am not good at homotopy
07:19:29 <hexagoxel> ph88: [a,b] === (a:b:[]) /== (a:b)
07:19:31 <Cale> Oh, one other important example
07:19:38 <Cale> Given any monoid M
07:19:55 <marisa__> OK. BTW you know so much... Do you have an github account so I can follow you?
07:20:02 <Cale> (A monoid is a set M together with a multiplication M x M -> M which is associative and has an identity)
07:20:12 <Cale> I don't have a github account
07:20:25 <Cale> You can form a category with just a single object
07:20:37 <Cale> Say, we'll call it X
07:20:45 <Cale> and an arrow X -> X for each of the elements of M
07:21:04 <Cale> and then we define the composition of arrows to be multiplication according to the monoid
07:21:33 <ph88> hexagoxel: why are you talking about [a,b] ?? it's not in my code...
07:21:52 <Cale> So for example, perhaps there's an arrow X -> X for each real number, and then composition is defined as addition of real numbers.
07:22:27 <hexagoxel> ph88: but (a:b) is in your code. look at exact type of (:)
07:22:29 <scott> and the identity arrow is the identity of the monoid (e.g. zero for the real numbers)
07:22:34 <Cale> right
07:22:50 <Cale> and composition is associative then because multiplication is
07:23:08 <marisa__> Thx!
07:23:48 <Cale> ph88: Whenever you write x:y it means the list whose first element is x, and where the tail of the list (which is another list) is y
07:24:09 <Cale> > 1 : [2,3,4,5]
07:24:11 <lambdabot>  [1,2,3,4,5]
07:24:22 * hackagebot cartel 0.14.2.4 - Specify Cabal files in Haskell  http://hackage.haskell.org/package/cartel-0.14.2.4 (OmariNorman)
07:24:31 <ph88> ah ok
07:25:17 <marisa__> > -h
07:25:18 <lambdabot>  No instance for (GHC.Show.Show a0)
07:25:18 <lambdabot>    arising from a use of ‚ÄòM863682909218937507620164.show_M8636829092189375076...
07:25:18 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
07:25:25 <marisa__> > help
07:25:26 <lambdabot>  Not in scope: ‚Äòhelp‚Äô
07:25:41 <Cale> @help
07:25:41 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:25:45 <Cale> @list
07:25:45 <lambdabot> What module?  Try @listmodules for some ideas.
07:25:48 <Cale> @listmodules
07:25:48 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
07:26:00 <ph88> so this works ... but perhaps i can come up with a nicer syntax?   test (x:y:[]) = y:[x]    ... maybe [y,x] as result ?
07:26:15 <Cale> @list eval
07:26:15 <lambdabot> eval provides: run let define letlpaste undefine
07:26:42 <marisa__> @todo
07:26:42 <lambdabot> 0. SamB: A way to get multiple results from a google search
07:26:42 <lambdabot> 1. dons: improve formatting of @dict
07:26:42 <lambdabot> 2. dons: write Haskell Manifesto
07:26:42 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
07:26:42 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
07:26:44 <lambdabot> [42 @more lines]
07:26:50 <Cale> wooooow
07:26:55 <Cale> I wonder how old those are :D
07:27:28 <Cale> ph88: You can write f [a,b] = [b,a]; f xs = xs
07:27:36 <ph88> thanks
07:28:07 <Cale> ph88: The patterns are tried in order from top to bottom, and the first one to match wins.
07:28:34 <Cale> (you probably already knew this :)
07:28:53 <ph88> yes i knew this one
07:28:57 <ph88> what am i doing wrong here?  http://lpaste.net/7900996488824619008
07:30:23 <Cale> ph88: you made xs one of the elements of the list
07:30:37 <Cale> You meant to match (x : y : xs)
07:30:44 <Cale> not [x,y,xs]
07:30:57 <ph88> ooh
07:32:54 <Cale> I wonder where TheHunter is, I haven't seen that nick around in years and years
07:33:53 <marisa__> So the list is here for years and years...
07:34:23 <Cale> Yeah, I don't think anyone's really used that module in a long time
07:34:31 <ph88> what am i doing wrong here? http://lpaste.net/5568321929854582784
07:34:46 <ph88> this must be really annoying questions, but im just stuck every time :|
07:34:48 <Cale> Now you're matching against a triple
07:34:55 <Cale> and not a list
07:35:04 <Cale> (x:y:xs), not (x,y,xs)
07:35:09 <ph88> ok thanks Cale 
07:36:06 <ph88> i'm doing the cs194 spring 2013 course by myself (i'm not a student)
07:36:17 <Cale> cool :)
07:36:25 <Cale> Yeah, feel free to keep asking questions
07:36:54 <ph88> how can i do pattern matching in ghci ?  i'm used to put it on a new line in the editor
07:37:35 <Cale> you can write something like
07:37:36 <Cale> let (x:xs) = [1,2,3,4,5]
07:37:38 <rola> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/interactive-evaluation.html#ghci-multiline
07:37:48 <Cale> and then try evaluating x and xs
07:37:52 <ph88> yes sure .. but then what about the next pattern ...
07:38:04 <ph88> if i do another let .. i think the first pattern is gone
07:38:09 <Cale> oh, yeah, you can separate the lines of the function by semicolons
07:38:17 <ph88> oh with ;  ok good
07:38:23 <Cale> But really, if you're defining anything complicated, just put it in a file
07:38:55 <Cale> GHCi is really intended more for interactively trying out expressions, not for defining anything longer than about a line
07:39:18 <ph88> rola: the multiline mode seems good as well
07:53:25 <Elite6809> Hey, quick question about Monads - what's the relationship between monads and continuations? Speaking as someone not well versed in category theory.
07:53:40 <Elite6809> (but I've used CPS before)
07:56:26 <paolino> hello, anyone has an implementation of MealyT m a b arrow and category instances ? 
07:56:36 <Cale> Elite6809: http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
07:57:11 <bennofs> Is there a data type data T m = T (m ()) with instance Monoid where mappend = (>>) predefined somewhere already?
07:57:38 <bennofs> or maybe data T m a = T (m ()) with instance Applicative 
07:57:48 <Elite6809> Cale: thanks for the link! I'll have a read now :)
07:57:49 <Confusionist> A possible relationship is that you can create a Continuation datatype with appropriate functions that satisfies the Monad laws. http://blog.sigfpe.com/2008/12/mother-of-all-monads.html and http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.39.8039&rep=rep1&type=pdf may be helpful.
07:58:32 <Confusionist> (The latter via https://wiki.haskell.org/Research_papers/Functional_pearls)
08:02:06 <Elite6809> Confusionist: thanks
08:05:36 <paolino> Well, maybe my question is , is possible to write arrow and category instances for MealyT m a b ?
08:17:38 <safinaskar> what is difference between hackage packages "parsec" and "parsec3"?
08:18:19 <kaiyin> http://en.wikibooks.org/wiki/File:Not-a-cat.png why is this not a category?
08:19:07 <bernalex> it's not a cat at least
08:19:31 <scott> kaiyin: the composition forces f and h to be the same, so it's incorrect to draw two separate arrows for them
08:21:07 <kaiyin> scott: why would composition force them to be the same?
08:21:58 <safinaskar> kaiyin: bernalex: yes, this is really not a cat ^_^. good name for file
08:22:26 <kaiyin> safinaskar: care to explain why?
08:23:09 <safinaskar> kaiyin: i just said joke :) i said this is not a cat. and not a dog. and i don't know whatever this is category
08:23:27 <kaiyin> oh, missed your humor, :-)
08:23:33 <bernalex> "humor" ;)
08:24:03 <tzaeru> this is a dog.. *and* a cat.
08:24:25 * hackagebot multiarg 0.30.0.6 - Command lines for options that take multiple arguments  http://hackage.haskell.org/package/multiarg-0.30.0.6 (OmariNorman)
08:24:27 * hackagebot rainbow 0.22.0.0 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.22.0.0 (OmariNorman)
08:25:44 <scott> kaiyin: start with the associativity requirement: (f . g) . h = f . (g . h)
08:26:35 <scott> kaiyin: then observe that f . g = id_A and g . h = id_B, so id_A . h = f . id_B, which implies f = h
08:26:57 <safinaskar> so, what is difference between parsec and parsec3?
08:27:09 <whald> hi. i'm trying to come up with ffmpeg ffi bindings based on extensible-effects, and have a hard time understanding why in: http://lpaste.net/7925166898319196160 the type signature suggested by GHC is not equivalent to my hand-written signature
08:27:55 <whald> my signature gives: 
08:27:55 <whald>     Could not deduce (extensible-effects-1.9.0.1:Data.OpenUnion.Internal.OpenUnion2.MemberU
08:27:55 <whald>                         Lift (Lift IO) r)
08:27:55 <whald>       arising from a use of ‚Äòloop‚Äô
08:29:12 <whald> shouldn't the "OpenUnion2.MemberU ..." stuff be equivalent to "SetMember Lift (Lift IO)"
08:29:12 <geekosaur> version skew, I think?
08:29:53 <geekosaur> since it shows the full version on the type, you are matching MemberU-s from different versions of extensible-effects
08:30:02 <geekosaur> likely
08:30:35 <kaiyin> scott: thanks, I see.
08:31:39 <whald> geekosaur, i don't think so, how would i even pull in two different versions of the same package?
08:33:30 <scott> kaiyin: another way to think of it is that f and g must be inverse (since they must compose to the identity - there are no other arrow to choose from) and g and h must also be inverse, and inverses are unique, so f = h. at least, I *think* this is a valid way to think about it
08:34:12 <whald> geekosaur, i just ditched the sandbox and re-installed, same problem
08:34:18 <kaiyin> scott: yes, it totally makes sense.
08:38:14 <geekosaur> because there's one installed globally somehow, is one possibility
08:38:35 <geekosaur> although that package probably doesn't belong installed globally
08:39:25 * hackagebot prednote 0.32.0.4 - Evaluate and display trees of predicates  http://hackage.haskell.org/package/prednote-0.32.0.4 (OmariNorman)
08:40:31 <geekosaur> otherwise I think we don't have enough information. show full code and full error message
08:40:33 <geekosaur> @paste
08:40:33 <lambdabot> Haskell pastebin: http://lpaste.net/
08:41:01 <MikeJones35> Can someone confirm or deny that in this expression (\x -> (\y -> map (f x) lst))  x and y are bound variables and lst is a free variable?  I'm new to haskell and was reading about free vs bound variables
08:41:58 <scott> MikeJones35: that's right. map, lst, and f are free
08:43:00 <MikeJones35> Scott: is there a different between bound/free variables and bound/free variable identifiers?
08:43:16 <MikeJones35> And thank for answering the first question!
08:43:58 <paolino> can someone review my mealyT implementations please? http://lpaste.net/128200
08:43:59 <scott> I don't think there's a difference between variables and 'variable identifiers'
08:44:35 <paolino> s/implementations/instances
08:45:19 <whald> giving "loop" a type signature of "loop :: (SetMember Lift (Lift IO) r, Member (Yield AVFrame) r, Member (Exc IOError) r) => Y r AVPacket () -> Eff r ()" helped. the types get really funny with ext-eff. :-/
08:46:24 <MikeJones35> Okay thank you, the scoping article I was reading was confusing me.  I dont really understand the part on how closures can aid in static scoping?
08:49:26 * hackagebot rainbox 0.10.0.2 - Two-dimensional box pretty printing, with colors  http://hackage.haskell.org/package/rainbox-0.10.0.2 (OmariNorman)
08:51:45 <MikeJones35> scott: is g, a and b all bound variables in an expression like this too?  (g (\g -> (\a -> (\b -> (length (g b)))))) )
08:52:23 <scott> that expression uses two different variables called g
08:52:42 <scott> the first/outer one is free, but the other one is bound in the \g -> ... lambda
08:53:17 <scott> but yes, the g, a, and b bound by the lambdas are all bound variables there
08:55:15 <MikeJones35> Oh okay I didn't realize there were two variables called g. so the \g is bound and the g inside of length is free?
08:56:32 <scott> nope, the one inside length is bound and refers to the \g binding
08:57:07 <scott> the first g would be referring to some g in a higher scope we can't see here, since it's outside of the scope of the \g lambda
08:57:48 <scott> so in the context of that expression it's free
08:58:46 <MikeJones35> Ah okay thank you, I was getting confused with that example
08:59:44 <c_wraith> length is technically also free. :)
09:00:05 <scott> a simpler example might be to look at (\x -> x + 1). looking at it as a whole we'd say x is bound, and we can see where the binding is introduced (\x). but if we narrow our vision and look at (x + 1) in isolation, then we suddenly call x free instead, because we can't see the binding any more
09:00:31 <Luke> Cale: pm-ed you
09:01:19 <MikeJones35> Are all functions like map and length free? Or would it be bound if you were mapping a function somehow? If so can you give an example when it would be bound?
09:01:27 <c_wraith> Compilers have to distinguish between two classes of free variables - those whose values are known at compile time, and those whose values are closed over at run time.  But in lambda calculus sense, they're free.
09:01:44 <c_wraith> so things like map and length are often known at compile time.
09:01:50 <scott> MikeJones35: if you look at the program as a whole, everything included, everything will be bound
09:02:04 <scott> MikeJones35: but when you look at isolated expressions, some variables may be free
09:02:11 <MikeJones35> Interesting
09:02:33 <MikeJones35> Does that relate to static scoping?
09:03:00 <c_wraith> Static scoping is just how you resolve which value a syntactically free variable refers to
09:03:21 <c_wraith> in static scoping, you determine which value it is by inspection.
09:03:29 <c_wraith> In dynamic scoping, you have to check at runtime.
09:03:48 <scott> scope is introduced by bindings like \x -> ... - it tells you the extent of where you can refer to this particular x variable (namely, just in the ...)
09:03:59 <c_wraith> Like..  Haskell has an extension that allows dynamic scoping.
09:04:28 <c_wraith> > let x = ?free in (let ?free = 5 in x, let ?free = 10 in x)
09:04:30 <lambdabot>  (5,10)
09:04:48 <c_wraith> In that example, ?free is a free variable in the definition of x
09:05:05 <c_wraith> It is bound dynamically to whatever it's been defined to be in the expressions where it's used.
09:05:45 <int-index> Repeating my question due to lack of answers. I'm thinking about creating SQL-queries using the formatting package. How bad is this idea?
09:05:54 <MikeJones35> Do closures help with static scoping?
09:06:52 <scott> closures/lambdas use static scoping, like everything else in Haskell (other than the extension c_wraith just demonstrated). I don't know about "help with"
09:21:04 <Jefffrey_> Morning again
09:21:20 <ozataman> Is there an ordered Map implementation somewhere?
09:21:36 <geekosaur> ?
09:21:41 <geekosaur> Map *is* ordered
09:21:49 <geekosaur> (note Ord instance on key type)
09:21:56 <ozataman> Oh I'm sorry, I meant to say order preserving.
09:21:58 <hiptobecubic> i think he means by insertion ordered
09:21:58 <Jefffrey_> So, am I going insane or doesn't ByteString have a way to replace bytes in the string?
09:22:35 <hiptobecubic> Jefffrey_, bytestrings are immutable, yes.
09:22:45 <hiptobecubic> Just like basically everything else
09:22:56 <Jefffrey_> Erm, that has nothing to do with anything hiptobecubic
09:23:23 <hiptobecubic> Jefffrey_, well what are you looking for? A way to create a *new* bytestring with a different value?
09:23:31 <Jefffrey_> Yes
09:23:53 <hiptobecubic> So "replace bytes in the string" is a pretty inaccurate way to ask for that.
09:24:27 <hiptobecubic> take the part you want from the front, put new part after it, drop that much from the front, then concat it all
09:24:28 * hackagebot avers 0.0.1 - empty  http://hackage.haskell.org/package/avers-0.0.1 (wereHamster)
09:25:32 <Iceland_jack> I thought it was clear for what it's worth, when someone asks ‚Äúhow do you remove an element from a tree‚Äù in #haskell I read it as a shorthand for ‚Äúhow do I create a new tree like the old tree but with the element removed‚Äù
09:25:43 <Jefffrey_> Yeah
09:25:46 <hiptobecubic> Lens probably has a very clever magic operator for replacing some range of values in a traversable, but you'll have to hope someone who knows those incantations
09:25:54 <Jefffrey_> I have no idea what hiptobecubic is on about
09:26:00 <safinaskar> i have some function which returns nothing (i. e. "-> ()") but it may fail using "error". how to run it in "main"? i don't want this call to be optimized out due to lazy evaluation. i want this function to be really called. and if there is error, it should fail
09:26:48 <Jefffrey_> When you "transform" a value in Haskell, you are creating a copy of the old value with that transformation applied to it.
09:27:27 <hiptobecubic> Jefffrey_, Iceland_jack, I guess it's context. Enough people that don't know haskell ask about how to do mutability-related things from other languages that when someone asks a question like that (particularly in a frustrated sounding way) that's what I think of.
09:27:39 <hiptobecubic> Jefffrey_, anyway, my mistake. Carry on :)
09:27:42 <Iceland_jack> Fair enough
09:27:47 <Jefffrey_> Alright
09:28:25 <Jefffrey_> Anyway, turns out I don't need that anyway. I think. So, thanks everybody anyway. :)
09:28:31 <Jefffrey_> Bye
09:29:28 * hackagebot reexport-crypto-random 0.1.0.0 -   http://hackage.haskell.org/package/reexport-crypto-random-0.1.0.0 (JamesCandy)
09:30:07 <{AS}> Hi, does anyone know if it is possible to convert a function "m a -> m b" to a value "m (a -> b)" ?
09:30:25 <{AS}> given m is a Applicative/Monad
09:31:20 <hiptobecubic> Isn't there a tool for that? djinn maybe?
09:31:31 <exio4> {AS}: it is not, you could also break referential transparency if you could
09:32:00 <{AS}> exio4: why? :)
09:32:31 <safinaskar> please answer my question. it is easy. every familar with IO monad should know answer
09:33:15 <hiptobecubic> safinaskar, it's not clear why it wouldn't. Show some code please.
09:33:16 <Hijiri> safinaskar: If you want that level of control over program failure, your function should output something in IO in the firstplace
09:33:29 <hiptobecubic> ohhhhh (), not IO ()
09:34:28 * hackagebot avers 0.0.2 - empty  http://hackage.haskell.org/package/avers-0.0.2 (wereHamster)
09:35:42 <Hijiri> error is for things like bad cases, like dividing by zero or trying to remove something from an empty container. These are things where the caller is expected to have checked some precondition, and aren't supposed to error in the normal use of the function. error isn't for expected error cases
09:36:38 <Hijiri> even this use of error is discouraged now, people often opt to return a Maybe a or Either e a value instead
09:37:06 <exio4> {AS}: (magic :: (Monad m) => (m a -> m b) -> m (a -> b))  (do { ref <- newIORef 0; act <- magic (\f -> modifyIORef ref f >> readIORef ref)); ..}) act would have (similar) type to (Int -> Int) -> Int which would give you different outputs to the same input 
09:38:09 <{AS}> exio4: Ah, thanks
09:38:52 <safinaskar> okey, code
09:39:37 <safinaskar> f a b = if a / b == a / b then () else error "this will be thrown in case of division by zero (I hope)"
09:39:53 <safinaskar> main = ????? -- what should i write here to call "f 1 0", for example?
09:40:06 <{AS}> What I really wanted is perhaps just a more powerful buildExpression parser :)
09:40:13 <safinaskar> hiptobecubic: Hijiri: i showed the code
09:40:14 <scott> {AS}: or think about a concrete example: reverse :: [a] -> [a] converted to [a -> a], say. what list of functions could you return and how would it make any sense as a conversion?
09:40:44 <{AS}> scott: Yeah, you are right :) 
09:40:58 <exio4> scott: I haven't thought about that one, I'll steal that one!
09:41:01 <scott> and of course being generic over which Monad you're dealing with restricts you even more
09:42:15 <lpaste> paul99 pasted ‚ÄúMissing (or bad) header file: HsBase.h‚Äù at http://lpaste.net/128202
09:42:29 <safinaskar> Hijiri: i write checker for formal proof. it returns () if all is ok. and it throws an exception if something is bad (for example, proof is wrong). and i want to call this checker from main
09:42:51 <safinaskar> okey, i will say another way: how to convert "a" to "IO a"?
09:42:59 <exio4> return? evaluate? 
09:43:00 <safinaskar> or () to IO ()?
09:43:15 <{AS}> scott, exio4: Thanks again.
09:43:17 <paul99> hi, i'm running into problems trying to install Haste compiler on Ubuntu 14.04 
09:43:35 <paul99> See http://lpaste.net/128202
09:43:40 <{AS}> Actually I think in my case it wouldn't really be an issue if the receiving function allowed more powerful expressions
09:44:12 <paul99> I'm a Haskell newbie so I'm hoping someone can point me in right direction
09:44:14 <{AS}> Maybe I should write a feature request to the parsec people
09:44:29 * hackagebot csv-conduit 0.6.5 - A flexible, fast, conduit-based CSV parser library for Haskell.  http://hackage.haskell.org/package/csv-conduit-0.6.5 (OzgunAtaman)
09:44:29 <MikeJones35> I was reading an example that uses foldr to return the sum of all squares of a list. The example mentions this could be done without the map function. Does anyone know how to do this without the map function? sumSquares xs = foldr (+) 0 (map (\x->x*x) xs)
09:44:30 * hackagebot csv-conduit 0.6.6 - A flexible, fast, conduit-based CSV parser library for Haskell.  http://hackage.haskell.org/package/csv-conduit-0.6.6 (OzgunAtaman)
09:44:36 <scott> :t return
09:44:37 <lambdabot> Monad m => a -> m a
09:44:50 <scott> safinaskar: ^ specialized for IO, return :: a -> IO a
09:44:56 <exio4> maybe you want https://hackage.haskell.org/package/base-4.7.0.2/docs/Control-Exception.html#g:8 
09:45:00 <exio4> @type evaluate
09:45:00 <lambdabot> a -> IO a
09:45:39 <safinaskar> please put "safinaskar" in the beginning of message if you answer me
09:45:39 <scott> exio4: won't make much difference forcing the evaluation of ()
09:45:58 <exio4> scott: ah, right, () -> IO ()
09:49:54 <safinaskar> thanks
09:51:22 <MikeJones35> I was reading an example that uses foldr to return the sum of all squares of a list. The example mentions this could be done without the map function. Does anyone know how to do this without the map function? sumSquares xs = foldr (+) 0 (map (\x->x*x) xs)
09:52:07 <hiptobecubic> MikeJones35, make the folding function itself do the squaring
09:52:19 <exio4> MikeJones35: there's an identity (foldr f z (map g xs) == foldr (f . g) z xs)
09:52:37 <exio4> > foldr f z (map g [a,b,c]) :: [Expr]
09:52:39 <lambdabot>  Couldn't match expected type ‚Äò[Debug.SimpleReflect.Expr.Expr]‚Äô
09:52:39 <lambdabot>              with actual type ‚ÄòDebug.SimpleReflect.Expr.Expr‚Äô
09:52:45 <exio4> > foldr f z (map g [a,b,c]) :: Expr
09:52:46 <lambdabot>  No instance for (GHC.Show.Show a0)
09:52:46 <lambdabot>    arising from a use of ‚ÄòDebug.SimpleReflect.Vars.f‚Äô
09:52:46 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
09:52:48 <exio4> :(
09:52:51 <scott> in fact, all list functions can be written with just foldr (but it can get messy that way, sometimes :) )
09:53:25 <exio4> scott: implementing map with a foldr makes that identity somewhat obvious, too :P 
09:53:59 <hiptobecubic> > foldr ((+) . (^2)) 0 [1,2,3]
09:54:00 <lambdabot>  14
09:54:22 <scott> > foldr f z (map g [a,b,c] :: [Expr])
09:54:23 <lambdabot>  f (g a) (f (g b) (f (g c) z))
09:54:42 <scott> I don't know why the type ascription there makes it work... trial and error in PM found it :p
09:55:12 <exio4> > foldr (f . g) z ([a,b,c] :: [Expr]) :: Expr
09:55:13 <lambdabot>  No instance for (GHC.Show.Show b0)
09:55:13 <lambdabot>    arising from a use of ‚ÄòDebug.SimpleReflect.Vars.f‚Äô
09:55:13 <lambdabot>  The type variable ‚Äòb0‚Äô is ambiguous
09:55:26 * exio4 hides in shame :P
09:55:49 <hiptobecubic> the composition maybe?
09:55:56 <hiptobecubic> Who knows
09:56:42 <exio4> > foldr ((f :: Expr -> Expr -> Expr) . g) z ([a,b,c] :: [Expr]) :: Expr
09:56:45 <lambdabot>  f (g a) (f (g b) (f (g c) z))
09:58:39 <JoshieAS> is there a way to recursive in "reverese"
09:58:51 <JoshieAS> that is, if I have a list, [1,2,3,4] can I traverse it backwards?
09:59:03 <hiptobecubic> JoshieAS, sure, reverse it.
09:59:09 <JoshieAS> oh, duh
09:59:14 <JoshieAS> *palm to face*
09:59:18 <voidzero> haha
09:59:20 <hiptobecubic> JoshieAS, or if you just mean to apply a function that associates to the right, maybe use foldr?
09:59:36 <JoshieAS> I'm just trying to solve a problem where I have to make a special modification to only the first element in the list
09:59:48 <JoshieAS> so if I have [1,2,3,4] I want to be able to modify only 1
10:00:03 <JoshieAS> in this way
10:00:07 <JoshieAS> but reverse will probably work
10:00:13 <exio4> why would you to traverse it "backwards"?
10:00:17 <hiptobecubic> > let f g (x:xs) = g x:xs in f (+1) [1,2,3,4]
10:00:18 <lambdabot>  [2,2,3,4]
10:00:40 <Iceland_jack> there is also "Reverse" from Data.Functor.Reverse
10:01:00 <Luke> Cale: https://github.com/ndmitchell/shake/issues/218
10:01:10 <Iceland_jack> as well as 'reversed' from lens
10:02:09 <Iceland_jack> Reverse can reverse any Foldable or Traversable
10:02:39 <hiptobecubic> Oh clever. http://haddocks.fpcomplete.com/fp/7.8/20140916-162/transformers/src/Data-Functor-Reverse.html#Reverse
10:03:05 <Iceland_jack> 'mapM_ print (Reverse [1,2,3,4])' does what you'd expect
10:03:11 <JoshieAS> hehe
10:03:24 <JoshieAS> so basically, I want to ALWAYS capitalize the first word of a string
10:03:54 <hiptobecubic> JoshieAS, so in my example, g is "Data.Char.toUpper"
10:04:20 <hiptobecubic> > let f g (x:xs) = g x:xs in f toUpper "banana"
10:04:22 <lambdabot>  "Banana"
10:04:39 <JoshieAS> let f g (x:xs) = g x:xs in f
10:04:43 <JoshieAS> toUpper "banana shits"
10:04:46 <Iceland_jack> ...
10:04:50 <JoshieAS> oops
10:04:55 <hiptobecubic> oops indeed
10:05:08 <JoshieAS> > left f g (x:xs) = g x:xs in f
10:05:09 <lambdabot>  <hint>:1:17: parse error on input ‚Äò=‚Äô
10:05:19 <JoshieAS> god bless, I typed left
10:05:25 <JoshieAS> okay, I did it in my GHCI, I see now
10:05:47 <exio4> JoshieAS: that function is also missing a case, add the [] case
10:05:56 <hiptobecubic> JoshieAS, ^ yes
10:07:19 <JoshieAS> thank you greatly for your help
10:09:52 <porglezomp> Hello
10:10:03 <porglezomp> So I have a question about tools
10:10:13 <voidzero> so so so
10:10:26 <porglezomp> I'm running cabal-install, and it just seems to get slower and slower as it goes
10:10:40 <porglezomp> Looking at it, it appears to just use more and more memory as time goes on.
10:11:01 <porglezomp> Is it not doing any kind of garbage collection in between compiling modules?
10:11:21 <porglezomp> With a makefile build, it starts GHC seperately for each file so the memory usage stays low
10:11:35 <porglezomp> But here it just starts swapping and compilation slows to a crawl
10:12:30 <porglezomp> How can I reduce the memory usage?
10:13:28 <porglezomp> It's currently using 50% more meory than I have physical memory here
10:19:07 <porglezomp> Anyone?
10:24:23 <AleXoundOS> Does it happen for any package?
10:24:44 <porglezomp> I don't know
10:25:00 <porglezomp> I'm compiling cabal-install right now
10:25:16 <porglezomp> It is using 90% of my very limited memory
10:25:18 <AleXoundOS> Compiling or running?
10:25:21 <threestrikes> if you're using a "let" command to define a function is it impossible to use recursion?  
10:25:33 <threestrikes> in ghci sorry
10:25:35 <porglezomp> Compiling
10:25:50 <porglezomp> But it's compiling cabal-install inside cabal-install
10:25:53 <porglezomp> (upgrading)
10:26:36 <porglezomp> I don't see any command line flags to tell it to use less memory
10:27:19 <porglezomp> and I can't find any docs more thorough than cabal -h
10:29:07 <AleXoundOS> I'm not familiar with Haskell-tools and stuff as you. But I don't really get what are you doing exactly?
10:29:19 <hexagoxel> porglezomp: -j1
10:29:53 <porglezomp> hexagoxel where do I find better docs (and what does that flag do?)
10:31:11 <hexagoxel> it is listed in `cabal help install`
10:33:23 <hexagoxel> porglezomp: it tends to help with total memory usage to have only 1 compilation running at a time, instead of $ncpus
10:34:21 <porglezomp> hexagoxel: it doesn't appear here, my version might be too old (0.14)
10:34:31 * hackagebot pipes-cliff 0.4.0.0 - Streaming to and from subprocesses using Pipes  http://hackage.haskell.org/package/pipes-cliff-0.4.0.0 (OmariNorman)
10:34:33 <porglezomp> hexagoxel: Also, I think it's only trying to build one at a time anyway.
10:35:08 <porglezomp> although!
10:35:32 <porglezomp> I hadn't used `cabal help` before and this has some useful stuff
10:35:58 <porglezomp> let's try --ghc-option=H32M
10:37:09 <hexagoxel> 0.14? are you sure? i don't even know how old that must be..
10:37:28 <porglezomp> cabal-install 0.14, cabal 1.14
10:37:34 <porglezomp> Is what the -V says
10:37:44 <porglezomp> It's the one that came with GHC 7.4
10:38:07 <hexagoxel> debian?
10:38:11 <porglezomp> Yeah
10:38:21 <athan> o_O
10:38:40 <hexagoxel> question to other debian users: was there not more up-to-date versions in testing repository, or something?
10:39:19 <porglezomp> This is on the raspberry pi version.
10:39:27 <porglezomp> I've build ghc 7.8.4
10:39:31 <porglezomp> I just need to update cabal now
10:39:49 <porglezomp> That's also the reason I only have 1 GB of physical memory
10:41:13 <porglezomp> There has to be some way to tell it to garbage collect aggressively
10:41:38 <porglezomp> I'm willing to deal with the hit as long as I can stay within physical memory
10:47:54 <porglezomp> It can compile the smaller packages really easily, but the ones with 80 files get all clogged up because it seems to just accumulate more junk with each file
10:48:25 <porglezomp> Is there any reason that it has to compile all of the files in one invocation of the compiler?
10:49:32 * hackagebot HStringTemplate 0.8.2 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.8.2 (SterlingClover)
10:50:16 <monochrom> normally, even if it is given 80 files, it still does one at a time, and recycles memory
10:51:34 <porglezomp> I'm not sure what's going on then, but these multi-file ones just use more and more memory as compilation continues.
10:53:11 <monochrom> last time I ran out of memory on 80 files was not ghc using too much memory, but rather the standard linker using too much memory
10:54:21 <porglezomp> I think that happened back when I didn't have swap, but this is getting up there during the compiling stage, not linking yet.
10:54:42 <hexagoxel> compilation of cabal-install, or of dependencies?
10:54:51 <porglezomp> I'm not sure
10:55:01 <porglezomp> I'm doing dependencies right now
10:55:15 <porglezomp> They're getting up there but not swapping yet
10:56:32 <porglezomp> Also it's probably good to keep in mind that I have barely any memory here to begin with, so what's bad for me probably isn't bad on a decent computer
11:01:10 <porglezomp> Well, it seems to be working, even if it's slow
11:01:17 <porglezomp> I'll deal with it I guess
11:01:32 <porglezomp> Bye, thanks for the help!
11:02:18 <paolino> oh, surprise there is InstanceSigs
11:02:40 <safinaskar> is there "satisfyThisPattern"?
11:03:03 <safinaskar> i. e. some shortland for  "case a of ptr -> True, _ -> False"?
11:10:44 <Guest54386> Hi. I'm just beginning haskell
11:11:05 <Guest54386> I have a function that operates on lists and I want to convert that to Data.Vector
11:11:27 <Welkin> okay
11:11:32 <Welkin> take a look at the Vector API
11:11:34 <Welkin> and conert it over
11:11:41 <Welkin> convert*
11:11:48 <Guest54386> well.. i've been trying to do that...
11:11:54 <Guest54386> and I think I'm missing something
11:12:07 <Guest54386> multiSplit f (s:ss)
11:12:12 <Guest54386>       | f s == True = ([s], ss)
11:12:16 <Guest54386>       | otherwise = (s:ys, xs)
11:12:20 <Guest54386>                     where (ys, xs) = multiSplit f ss
11:12:41 <Guest54386> this is the list based code (as you can see)
11:13:10 <Guest54386> I cann't quite figure out how to do the pattern matching in the arguments to multiSplit
11:13:34 <Guest54386> so in: multiSplit f (s:ss)
11:14:07 <sternenseemann> afaik it is not possible to pattern match on vectors
11:14:46 <Guest54386> aah. okay :)
11:14:59 <Guest54386> that helps a lot. i've been trying to figure that out for a few hours now
11:15:36 <sternenseemann> you'll have to use it in the body
11:15:43 <sternenseemann> what am I writing
11:15:51 <sternenseemann> you'll have to use head and tail and so on
11:16:04 <Welkin> to pattern match on a Sequence, you have to use the ViewPatterns extension with viewl/viewr
11:16:51 <Welkin> is Vector a proper data structure for what you want to do?
11:17:01 <Welkin> it's important to choose the right one based on your needs
11:17:34 <Guest54386> I'm using Data.Csv to handle large csv data 
11:17:47 <Guest54386> so vector was both forced and looked like a good choice
11:18:25 <Guest54386> (forced because Data.csv decodes to vectors)
11:19:07 <Welkin> you can write your own CSV parser in less than 20 lines
11:19:16 <Welkin> so you can parse it however you want
11:21:46 <Guest54386> yeah i could have done that. just chickened out :)
11:21:47 <f|`-`|f> CSV?
11:22:16 <Welkin> comma seperated values
11:22:24 <f|`-`|f> ah
11:22:24 <Welkin> eparated*
11:22:28 <Welkin> separated*
11:22:45 <mauke> less than 20 lines? I doubt it
11:22:56 <f|`-`|f> the next question is what a view pattern is
11:22:59 <mauke> CSV is butts
11:23:11 <mauke> f|`-`|f: (func -> pattern)
11:25:03 <mauke> :t let isNeg (show -> '-' : _) = True; isNeg _ = False in isNeg
11:25:04 <lambdabot> Show a => a -> Bool
11:25:12 <mauke> > let isNeg (show -> '-' : _) = True; isNeg _ = False in isNeg (-pi)
11:25:14 <lambdabot>  True
11:25:16 <paolino> f|`-`|f, an extension of the syntax, where you can use functions on left side of the match
11:25:32 <Welkin> it is quite convenient
11:25:35 <jmcarthur> does anybody know of any work relating to using safe mutations (beyond mere thunks, which can only be updated once) for purely functional data structures in haskell (probably ghc specific)?
11:25:46 <Welkin> you can do it using case expressions, but it gets messy
11:25:59 <f|`-`|f> not sure how
11:27:34 <paolino> useful also when you don't export constructors, but you want to let pattern match on the values
11:41:19 <f|`-`|f> huh
11:46:36 <Guest54386> another question on vectors
11:46:56 <Guest54386> any way to construct a vector (without using fromList)
11:47:35 <Guest54386> for instance I would list to say (Vector $ V.head ss), where ss is a Vector
11:47:51 <HeladoDeBrownie> Guest54386, not sure which vector you mean, but likely an empty vector is provided
11:47:57 <HeladoDeBrownie> and possibly a unit one
11:48:04 <Guest54386> Data.Vector
11:48:32 <nerium> How do I tell cabal to include all my test files?
11:48:32 <HeladoDeBrownie> Data.Vector.singleton
11:48:40 <c_wraith> Guest54386: package names are far more useful than module names, in general.
11:48:51 <nerium> currently only one file in my test/ dir is being added
11:48:53 <HeladoDeBrownie> (assuming from vector package)
11:49:16 <Guest54386> c_wraith: thanks I'll bear that in mind
11:49:18 <HeladoDeBrownie> also "unit vector" was a confusing way to phrase what i said, i really meant singleton.
11:49:34 <Guest54386> HeladoDeBrownie: yeah I understand
11:49:35 * hackagebot rethinkdb 1.16.0.0 - A driver for RethinkDB 1.16  http://hackage.haskell.org/package/rethinkdb-1.16.0.0 (EtienneLaurin)
11:49:47 <c_wraith> Guest54386: also, there's an entire section of the docs about creating vectors:  https://hackage.haskell.org/package/vector-0.10.12.2/docs/Data-Vector.html#g:7
11:50:44 <c_wraith> Guest54386: take note of all the subsections, all the way down to concatenation
11:50:52 <Guest54386> yeah. I should have been paying more attention to that. (Until like an hour ago, I was fixated on doing similar things with Data.Vector as you can do with haskell lists)
11:51:00 <c_wraith> Guest54386: the vector package gives you a *lot* of ways to build new ones. :)
11:51:13 <Guest54386> (For instance pattern matching using [], (:) etc)
11:51:42 <nerium> Anyone?
11:51:48 <c_wraith> Guest54386: in general, you'd use a fold instead of pattern matching with vector.  foldr has the same power and efficiency in most cases.
11:54:00 <Guest54386> c_wraith: I was trying to implement a Prelude.lines like function for arbitrary conditions on vectors
11:54:35 * hackagebot Diff 0.3.1 - O(ND) diff algorithm in haskell.  http://hackage.haskell.org/package/Diff-0.3.1 (SterlingClover)
11:54:50 <c_wraith> Guest54386: I'd use break for that.
11:55:07 <c_wraith> Guest54386: https://hackage.haskell.org/package/vector-0.10.12.2/docs/Data-Vector.html#v:break
11:55:58 <Guest54386> Thanks. that's what I ended up doing eventually
12:00:29 <Phillemann> I want to send something over a unix socket and afterwards just receive. I thought about using conduit for that. There's runUnixSocket which gives me appSource and appSink. Can I simply yield "foo" $$ appSink and afterwards process appSource? Or is the socket already closed after the first $$?
12:00:30 <nerium> Anyone knows how to package a yesod application?
12:03:39 <meditans> hi, I'd like some directions on what libraries I should use to accomplish an idea:
12:04:48 <meditans> let's say a dataBase is a bunch of facts, in the prolog sense, but without the complete expression power of horn clauses
12:05:14 <meditans> something like relation(a,b,c) where a, b, c are primitive symbols
12:05:58 <meditans> i'd like to confront two such dataBases, using efficient algorithms
12:06:19 <meditans> think of a less powerful prolog, but with a good search algorithm for unification
12:07:25 <meditans> so, which library should I use? Control.Unification? Data.SBV? Any input is welcome :)
12:09:57 <meditans> I guess a more specific starting question could be: can I do fast symbol unification with Data.SBV?
12:11:23 <Guest819> Thomass-MacBook:credit thomasbao$ ghc Main.hs  [1 of 1] Compiling Main             ( Main.hs, Main.o )  Main.hs:30:22:     Couldn't match type ‚ÄòIO NameCards‚Äô with ‚ÄòTrie.Trie Integer‚Äô     Expected type: NameCards       Actual type: IO NameCards     In a stmt of a 'do' block:       nameCards <- (return :: NameCards -> IO NameCards) $ Trie.empty ::                      NameCards
12:11:52 <Guest819> type NameCards = Trie.Trie Integer
12:12:08 <mauke> nameCards <- return Trie.empty
12:12:16 <mauke> let nameCards = Trie.empty
12:12:56 <Guest819> @mauke what was I doing wrong?
12:12:56 <lambdabot> Unknown command, try @list
12:13:05 <Guest819> :mauke what was i doing wrong?
12:13:17 <mauke> adding wrong type annotations
12:13:36 <mauke> like saying return Trie.empty :: NameCards when it's actually :: IO NameCards
12:14:26 <Guest819> okay
12:14:38 <Guest819> thanks! I htink I need to review type annotations
12:19:36 * hackagebot cubicspline 0.1.1 - Natural cubic spline interpolation.  http://hackage.haskell.org/package/cubicspline-0.1.1 (GershomBazerman)
12:22:17 <jaseemabid> I hit some weird ghc/cabal bug. The code compiles just fine from emacs and I can run the code. `$ cabal test` fails with some illegible error. Reproduced on every attempt. Public build with all info here. https://travis-ci.org/jaseemabid/functorrent/builds/55397669 Can someone please tell me what is happening? 
12:23:17 <jaseemabid> Filed a bug here: https://ghc.haskell.org/trac/ghc/ticket/10151
12:25:40 <mpickering> You are probably missing a module from your cabal file
12:26:39 <jaseemabid> mpickering: `other-modules` section? I'm not sure what to put there.
12:26:54 <merijn> jaseemabid: All internal modules
12:27:14 <mpickering> I just counted and you have 7 modules but only 6 in the cabal file
12:27:43 <mpickering> so you should add Utils to the other-modules section
12:28:07 <jaseemabid> I have a utils, which I don't want to expose. That probably 
12:28:36 <merijn> jaseemabid: Yeah, unexposed modules should be in other-modules
12:29:06 <mpickering> jaseemabid: Before I looked at any of your links I suspected that would be your problem.. it's got me a few times before
12:29:06 <jaseemabid> merijn: Ah. Yes. that worked. A better error message would have helped :(
12:29:28 <jaseemabid> Turned out to be a bad one to debug. Thanks folks.
12:29:55 <merijn> jaseemabid: Yeah, the problem here is that the error isn't produced by ghc, but by your system's linker
12:30:07 <jaseemabid> The library section alone or should it be added to both executable and text sections?
12:30:15 <merijn> And the linker doesn't know anything about haskell, so it can't tell you anything useful
12:30:18 <jaseemabid> /s/text/test
12:30:59 <merijn> jaseemabid: Does the executable require internal modules or just the exposed ones?
12:31:15 <jaseemabid> Just exposed.
12:31:17 <merijn> jaseemabid: If just the exposed ones, you can just add "build-depends: lisper" to the executable
12:31:42 <merijn> That way it'll link against the installed library
12:32:07 <jaseemabid> lisper is a copy paste error. Its functorrent. Fixed that too :)
12:32:28 <merijn> You get the idea :)
12:32:34 <jaseemabid> Yep! 
12:33:57 <jaseemabid> All good. Toying with a torrent client in haskell. Good so far, except these issues.
12:34:58 <LostPlanet> ok, so i want to write a function which takes two two-tuples of integers as input and returns a list of integer two-tuples as its result
12:35:16 <LostPlanet> so i'm thining something like function :: (Num a) => (a, a) -> (a, a) -> [(a, a)]
12:37:03 <merijn> LostPlanet: Right, so what's the question? :)
12:37:33 <LostPlanet> ok, so in the function i need want to do something like truncate ((a + b) / 2) where a and b are integers
12:37:40 <LostPlanet> the result should always be an integer
12:37:44 <merijn> :t div
12:37:45 <lambdabot> Integral a => a -> a -> a
12:37:50 <merijn> > 5 `div` 2
12:37:51 <lambdabot>  2
12:38:10 <merijn> :t (/)
12:38:11 <lambdabot> Fractional a => a -> a -> a
12:38:33 <LostPlanet> right , so then it of course says i need to have Fractional which makes sense because i am diving
12:38:50 <merijn> div is division for Integrals as you can see :)
12:38:51 <xplat> anyone from NJ going to NYHUG this week?
12:38:53 <LostPlanet> but i dont want someone to be able to supply a non-whole integer to the function . like you can't give it 3.2 as input
12:39:27 <LostPlanet> merijn
12:39:32 <LostPlanet> merijn: oh yea
12:39:44 <LostPlanet> merijn: so you are saying dont use (/), use `div`
12:39:52 <merijn> right
12:40:13 <LostPlanet> ok, let me try that
12:40:53 <xplat> div divides groups of things into smaller groups.  / slashes them into fractions of things.
12:41:15 <merijn> > 3.2 `div` 5 -- type error
12:41:17 <lambdabot>  No instance for (GHC.Show.Show a0)
12:41:17 <lambdabot>    arising from a use of ‚ÄòM137337250305639614325119.show_M1373372503056396143...
12:41:17 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
12:41:37 <xplat> > 3.2 :: Int
12:41:38 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Types.Int)
12:41:38 <lambdabot>    arising from the literal ‚Äò3.2‚Äô
12:42:11 <LostPlanet> (truncate (3.2)):: Int
12:42:17 <xplat> > (3.2 :: Double) `div` 5
12:42:17 <jaseemabid> xplat: Since you mentioned, There is a BangaloreHUG as well. In case anyone is interested, please show up! 
12:42:18 <lambdabot>  No instance for (GHC.Real.Integral GHC.Types.Double)
12:42:18 <lambdabot>    arising from a use of ‚ÄòGHC.Real.div‚Äô
12:42:18 <LostPlanet> round about way i guess
12:44:37 * hackagebot cursedcsv 0.1.2 - Terminal tool for viewing tabular data  http://hackage.haskell.org/package/cursedcsv-0.1.2 (GershomBazerman)
12:47:02 <bramgg> Hi all, hopping in the shower soon, but wanted to let those that gave feedback earlier than 99 Haskell is live at http://www.99haskell.org. Thanks!
12:54:37 * hackagebot total 1.0.2 - Exhaustive pattern matching using lenses, traversals, and prisms  http://hackage.haskell.org/package/total-1.0.2 (GabrielGonzalez)
12:54:39 * hackagebot kmeans 0.1.3 - K-means clustering algorithm  http://hackage.haskell.org/package/kmeans-0.1.3 (GershomBazerman)
13:00:32 <Beardful> If i need to use all elements in a sequence, for example to print them. Should i map (\n -> print $ index seq n) [1..(size)], which would be silly, because then i could've used lists in the first place.
13:01:01 <Beardful> The right formulation for the question would be - is there a map for sequences?
13:02:44 <Beardful> Nevermind, found it.
13:04:38 * hackagebot HTF 0.12.2.4 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.12.2.4 (StefanWehr)
13:08:46 <quchen> "sequence (map f) list = traverse f list", which also works not only for lists, but for any Traversable.
13:09:14 <quchen> Woops, parenthesis wrong. sequence (map f list) is better.
13:10:09 <bitraten> johnw: How can I get a TreeT with all changed and untracked files in gitlib?
13:13:32 <Beardful> Can i convert from Integer to GLfloat ? And if so, then how.
13:18:16 <xplat> Beardful: fromInteger
13:20:07 <Beardful> xplat: Awesome, you're cool.
13:23:47 <merijn> quchen: That's also mapM :p
13:24:31 <quchen> merijn: I've never heard of such a function. ;-)
13:27:20 <paolino> is it possible to write Monad instance for MooreT m a b = MooreT b (a -> m (MooreT m a b)) ?
13:29:39 * hackagebot quickcheck-instances 0.3.11 - Common quickcheck instances  http://hackage.haskell.org/package/quickcheck-instances-0.3.11 (AntoineLatter)
13:30:15 <MikeJones35> Is filter the best way to combine two lists together without duplicates?  append xs ys = foldr (:) ys xs       this combines two lists but I was curious how to remove any duplicates out of xs before combining the two lists
13:30:46 <benzrf> paolino: yes
13:31:13 <benzrf> oh ,wait
13:31:22 <benzrf> hmm
13:31:25 <Welkin> MikeJones35: you can also convert the lists to Sets, combine them, then convert to a List
13:31:34 <paolino> I'm trying but it seems the b cannot escape the monad m
13:32:02 <benzrf> paolino: you definitely can for Maybe (m (MooreT m a b)) instead of just (m (MooreT m a b))
13:32:10 <MikeJones35> Welkin: how would that be done? I'm fairly new to Haskell.
13:32:23 <benzrf> or at least i think so
13:32:28 <MikeJones35> Would it be easier to use filter on what I had above?
13:32:41 <Hijiri> filter doesn't remove duplicates
13:32:53 * benzrf tries to remember if Stream is a monad
13:32:55 <Hijiri> you give it a predicate
13:32:59 <benzrf> diagonalization or something
13:33:12 <Hijiri> if you wanted to remove duplicates, you would have to change the predicate while you are going through the list
13:33:13 <benzrf> @let data Stream a = a:>Stream a
13:33:15 <Hijiri> which filter doesn't do
13:33:15 <lambdabot>  Defined.
13:33:29 <Hijiri> Data.List has nub, but that is O(n^2)
13:33:37 <Welkin> :t Data.Set.fromList
13:33:38 <lambdabot> Ord a => [a] -> S.Set a
13:33:42 <Welkin> :t Data.Set.toList
13:33:43 <lambdabot> S.Set a -> [a]
13:33:55 <Welkin> :t Data.Set.union
13:33:56 <lambdabot> Ord a => S.Set a -> S.Set a -> S.Set a
13:34:37 <Welkin> use those, MikeJones35 
13:34:47 <MikeJones35> Okay thank you
13:35:43 <paolino> MikeJones35, if you have Ord you use map head . group . sort
13:35:45 <ChristianS> MikeJones35: but that doesn't preserve order. there is ordNub, i can pastebin an implementation if you're interested.
13:35:52 <benzrf> fuck
13:36:01 <benzrf> im trying to visualize diagonalization and whether its associative
13:36:05 * benzrf squints his minds eye
13:36:10 <Welkin> the alternative would be to append the two lists, then apply `nub`
13:36:39 <paolino> nub if you don't have Ord
13:38:27 <TallerGhostWalt> anyone else having problems with hayoo?
13:38:28 <benzrf> yesssss it is
13:38:29 <benzrf> :D
13:38:39 <benzrf> score one for geometric visualization \o/
13:39:15 <ChristianS> TallerGhostWalt: what kind of problems? it seems to work for me.
13:39:21 <benzrf> paolino: i believe it's a monad yes
13:39:24 <benzrf> assuming m is a monad, i mean
13:39:37 <paolino> benzrf, I don't know this technique
13:39:43 <benzrf> @let data MooreT m a b = MooreT b (a -> m (MooreT m a b))
13:39:44 <TallerGhostWalt> ChristianS: really irrelevant results?
13:39:45 <lambdabot>  Defined.
13:39:54 <benzrf> paolino: ah i was just referring to mentally checking if Stream is a monad
13:39:59 <benzrf> data Stream a = a:>Stream a
13:40:19 <benzrf> paolino: then i can visualize Stream (Stream (Stream a)) as an infinitely extending cube
13:40:25 <benzrf> "cube" whatever
13:40:43 <benzrf> paolino: and imagine what join and fmap join look like to see whether join monad is associative
13:40:46 <ChristianS> TallerGhostWalt: can't say so
13:40:46 <benzrf> *join is
13:41:15 <benzrf> paolino: given that join is diagonalization
13:41:16 <TallerGhostWalt> ChristianS: searched for 'yit' from yesod-test get 6 results... nothing from yesod-test
13:42:00 <ChristianS> TallerGhostWalt: it doesn't seem to know yesod-test?
13:42:15 <benzrf> @let instance Functor m => Functor (MooreT m a) where fmap f (MooreT b c) = MooreT (f b) ((fmap . fmap) f c)
13:42:16 <lambdabot>  .L.hs:160:45:
13:42:16 <lambdabot>      Could not deduce (b ~ MooreT m a b)
13:42:16 <lambdabot>      from the context (Functor m)
13:42:19 <benzrf> erm
13:42:19 <TallerGhostWalt> ChristianS: I would like to make an introduction!
13:42:23 <benzrf> @let instance Functor m => Functor (MooreT m a) where fmap f (MooreT b c) = MooreT (f b) ((fmap . fmap . fmap) f c)
13:42:25 <lambdabot>  Defined.
13:42:33 <benzrf> paolino: fairly trivial Functor instance there
13:42:37 <TallerGhostWalt> hayoo , this is yesod-test ... yesod-test , hayoo!
13:42:37 <benzrf> assume you already figured it out?
13:43:01 <ChristianS> TallerGhostWalt: haha, i don't know if hayoo is listening
13:43:31 <TallerGhostWalt> AI, not eating the world fast enough I guess... thanks for verifying I am not crazy! google + hoogle it is today!
13:47:35 <benzrf> @let mooretReturn b = MooreT b (const (return (mooretReturn b)))
13:47:38 <lambdabot>  Defined.
13:48:05 <MikeJones35> Another question about combining lists. Could I use foldr, elem, and filter to combine two lists? so these two lists [1,2,3,4,5] [6,7,3,8] would equal [1,2,4,5,6,7,3,8]
13:48:33 <benzrf> MikeJones35: isnt that just (++)
13:49:08 <paolino> benzrf, I've lost connection on "cube" whatever
13:49:13 <benzrf> nvm
13:49:15 <MikeJones35> Sorry I didn't state everything like I did earlier. I am removing duplicates from the first list and preserving order
13:49:25 <benzrf> paolino: crap im stupid no you're right i think it's not a monad >_<
13:49:26 <Welkin> > [1..5] ++ [6..]
13:49:27 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:49:45 <ChristianS> MikeJones35: why from the first rather than the second?
13:49:54 <benzrf> paolino: however
13:49:57 <benzrf> @undef
13:49:57 <lambdabot> Undefined.
13:50:10 <benzrf> @let data MooreT m a b = MooreT (a -> m (b, MooreT m a b))
13:50:12 <lambdabot>  Defined.
13:50:15 <benzrf> i think *this* might be a monad
13:50:31 <behelit> hi guys! i'm struggling a bit with coercing [Char] to Text; i'm using the OverloadedStrings extension and all was fine until i had to use getLine.
13:50:34 <paolino> oh that is MealyT
13:50:38 <benzrf> ah
13:50:47 <Welkin> coercing?
13:50:52 <behelit> Welkin: converting
13:50:54 <Welkin> :t getLine
13:50:56 <lambdabot> IO String
13:51:07 <MikeJones35> ChristianS: because I have seen examples that remove it but only from the second list
13:51:13 <benzrf> :t Data.Text.getLine
13:51:14 <lambdabot> Not in scope: ‚ÄòData.Text.getLine‚Äô
13:51:16 <Welkin> :t Data.Text.getLine
13:51:17 <lambdabot> Not in scope: ‚ÄòData.Text.getLine‚Äô
13:51:20 <paolino> benzrf,  I've already got all those fancy instancies, arrow & c for it
13:51:24 <ChristianS> behelit: Text has it's own getLine
13:51:32 <behelit> ChristianS: ah, brilliant
13:51:37 <Welkin> :t Data.Text.IO.getLine
13:51:38 <lambdabot> IO Data.Text.Internal.Text
13:51:44 <Welkin> use that
13:51:51 <behelit> Welkin: thanks!
13:52:17 <ChristianS> MikeJones35: hmm, so you just want to make it needlessly complicated?
13:52:43 <paolino> benzrf, I saw Moore is a Monad, and was trying to guess it for MooreT
13:52:47 <Welkin> he is building a Rube Goldberg machine
13:53:03 <benzrf> oh wait fuck i misread the type >_<
13:53:05 <benzrf> @unlet
13:53:05 <lambdabot>  Define what?
13:53:08 <benzrf> @undef
13:53:08 <lambdabot> Undefined.
13:53:14 <benzrf> @let data MooreT m a b = MooreT b (a -> m (MooreT m a b))
13:53:16 <lambdabot>  Defined.
13:53:24 <benzrf> @let instance Functor m => Functor (MooreT m a) where fmap f (MooreT b c) = MooreT (f b) ((fmap . fmap . fmap) f c)
13:53:25 <lambdabot>  Defined.
13:53:30 <benzrf> paolino: let me see
13:53:36 <benzrf> return is easy
13:53:38 <MikeJones35> ChristianS: I'm trying to get a good grasp of the basics like map and foldr and was trying to figure out why all the examples only delete from the second. Is it too hard to delete from the first?
13:53:44 <benzrf> @let mooretReturn b = MooreT b (const (return (mooretReturn b)))
13:53:45 <lambdabot>  Defined.
13:53:50 <benzrf> paolino: are you familiar with monads via join
13:53:57 <paolino> mh
13:54:14 <benzrf> kk
13:54:16 <ChristianS> MikeJones35: it's certainly harder since otherwise you could just use ++ and then ordNub
13:54:16 <benzrf> so uh
13:54:20 <paolino> I use join but not for writing instances
13:54:36 <benzrf> MooreT m a (MooreT m a b)
13:54:41 <benzrf> -> MooreT m a b
13:54:43 <paolino> join . atomically is my friend
13:54:47 <benzrf> hah
13:54:58 <benzrf> so
13:55:24 <benzrf> mooretJoin (MooreT (MooreT b c) c') = MooreT ...
13:55:51 <paolino> return = pure
13:56:00 <paolino> I've had the applicative
13:56:02 <benzrf> i already defined return up there :U
13:56:05 <MikeJones35> Ah I got it, simple foldr with a if else using elem
13:56:06 <benzrf> ah
13:57:30 <quchen> MikeJones35: If performance is no concern, then that approach should work.
13:57:58 <quchen> MikeJones35: You have to traverse one of the lists for every element in the other list like this though, so it won't scale very well.
13:59:38 <Welkin> Data.Set.fromList is O(n log n)
13:59:46 <Welkin> union is O(m + n)
13:59:52 <Welkin> toList is O(n)
14:00:18 <Welkin> so that would have better performance than nub (O(n^2))
14:00:21 <quchen> Set.fromList is very fast O(n*log(n)) though.
14:00:27 <paolino> benzrf, mooretJoin (MooreT (MooreT b c) c') = MooreT b' l, the b' seems to have escaped the monad
14:00:35 <benzrf> huh?
14:00:40 <quchen> If your input list is already somewhat sorted you approach O(n).
14:01:41 <ChristianS> MikeJones35: or, another idea. concat lists, reverse result, apply ordnub, reverse again
14:01:57 <ChristianS> MikeJones35: for an ordnub implementation, see http://hackage.haskell.org/package/Cabal-1.22.2.0/docs/src/Distribution-Simple-Utils.html#ordNub
14:05:00 <mtottenh> Hi, I'm trying to use HXT to parse an XML file into a haskell data type. It's working but I can't seem to parse xml comments, does anyone know if it's possible to do so?
14:06:03 <Beardful> Still learning to use Data.Sequence. Is there a 'sequence' for Seq ?
14:06:54 <Beardful> I couldn't google that, because 'sequence for sequence haskell' didn't give anything useful.
14:07:06 <paolino> :t sequence
14:07:07 <lambdabot> Monad m => [m a] -> m [a]
14:07:15 <MikeJones35> ChristianS: Thanks. Can you help me with this example. let mapInside f lls = map f lls       when I call it is return mapInside (>5) [1,2,3,4,5,6,7,8]  ==  [False,False,False,False,False,True,True,True]    Is there a way to modify this to only return elements that are true?
14:08:02 <Beardful> paolino: Are you implying that 'sequence' also works on Sequences ?
14:08:07 <paolino> no
14:08:09 <Beardful> oh
14:08:29 <paolino> :t sequence_
14:08:30 <lambdabot> Monad m => [m a] -> m ()
14:08:36 <Welkin> MikeJones35: filter (== True)
14:08:53 <exio4> Welkin: I prefer "filter id"
14:08:54 <paolino> mh, there is something in Traversable
14:09:09 <Welkin> exio4: that works too
14:09:12 <Welkin> but is less explicit
14:09:16 <paolino> @src Traversable
14:09:16 <lambdabot> class (Functor t, Foldable t) => Traversable t where
14:09:16 <lambdabot>     traverse  :: Applicative f => (a -> f b) -> t a -> f (t b)
14:09:16 <lambdabot>     sequenceA :: Applicative f => t (f a) -> f (t a)
14:09:16 <lambdabot>     mapM      :: Monad m => (a -> m b) -> t a -> m (t b)
14:09:16 <lambdabot>     sequence  :: Monad m => t (m a) -> m (t a)
14:09:28 <exio4> if you want to be explicit there, you'd just use filter
14:09:53 <MikeJones35> @src map (>2) [1,2,3]
14:09:53 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:09:56 <exio4> (filter f xs) instead of (filter id (map f xs)) 
14:10:00 <paolino> @instances Seq
14:10:00 <lambdabot> Couldn't find class `Seq'. Try @instances-importing
14:10:10 <MikeJones35> > map (>2) [1,2,3]
14:10:11 <lambdabot>  [False,False,True]
14:10:12 <paolino> @instances Traversable
14:10:13 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
14:10:59 <MikeJones35> > filter true (map (>2) [1,2,3])
14:11:00 <lambdabot>  Not in scope: ‚Äòtrue‚Äô
14:11:18 <Beardful> > filter True (map (>2) [1,2,3]) 
14:11:19 <exio4> MikeJones35: you probably want
14:11:19 <lambdabot>  Couldn't match expected type ‚ÄòGHC.Types.Bool -> GHC.Types.Bool‚Äô
14:11:19 <lambdabot>              with actual type ‚ÄòGHC.Types.Bool‚Äô
14:11:26 <exio4> > filter (>2) [1,2,3]
14:11:28 <lambdabot>  [3]
14:11:38 <paolino> Beardful, Data.Traversable.sequence should do
14:12:22 <MikeJones35> Ah thank you!
14:14:41 * hackagebot monad-open 0.1.0.0 - Open recursion for when you need it  http://hackage.haskell.org/package/monad-open-0.1.0.0 (JonSterling)
14:15:02 <MikeJones35> exio4: Is it possible to map a list of functions to a number so thatsomething like  [(+1),(+2),(+3)] 1 would return [2,3,4]?
14:15:20 <behelit> http://lpaste.net/128209
14:15:24 <paolino> :t ($)
14:15:25 <lambdabot> (a -> b) -> a -> b
14:15:34 <paolino> :t map ($)
14:15:34 <lambdabot> [a -> b] -> [a -> b]
14:15:39 <behelit> can anyone please explain why that would give "No instance for (AsValue (Map String Value))" arising from a use of 'key'?
14:15:57 <paolino> :t map (flip ($))
14:15:58 <lambdabot> [a] -> [(a -> c) -> c]
14:16:21 <exio4> MikeJones35: you could do something like map ($ n) [(+1), (+2), (+3)] and it'd give you "[n+1, n+2, n+3]"
14:16:35 <behelit> that line worked just fine before i started returing values. and the type should match (_String turns Maybe Value to Maybe Text)
14:17:24 <monochrom> what is the type of "key"?
14:17:24 <Beardful> paolino: Yep, that did the job.
14:17:31 <exio4> MikeJones35: this ($ n) is just the same as (\f -> f $ n) ; which is just functional application 
14:17:40 <exio4> f $ x = f x 
14:18:03 <MikeJones35> exio4: would there be a way to define something like that if you didn't know how many elements were in the list?
14:18:58 <exio4> MikeJones35: what do you mean? I used [(+1), (+2), (+3)] as an example, it could have been something different with different length and it'd still work 
14:19:02 <mtottenh> Hi, does anyone know if HXT is able to parse xml comments, I'm using xunpickleDocument and I can't seem to figure out how to get the content of xml comments (i.e. <!-- ... --> )
14:19:14 <exio4> > map ($ 0) [(+1), (+2), (+3)] 
14:19:16 <lambdabot>  [1,2,3]
14:19:39 <exio4> > map ($ 0) [(+1), (+2), (+3), (+ 47)] 
14:19:41 <lambdabot>  [1,2,3,47]
14:21:34 <paolino> MikeJones35, you could try to write map function and fold and such and get a feeling of lists
14:22:21 <MikeJones35> For a function would you say  let testMap xs xy = map ($ xs) xy? I understand what you are showing me but now sure how to make it generic
14:22:38 <MikeJones35> not sure*
14:23:02 <behelit> A
14:23:24 <behelit> monochrom: https://hackage.haskell.org/package/aeson-lens-0.5.0.0/docs/Data-Aeson-Lens.html#v:key
14:23:29 <behelit> monochrom: Maybe Value?
14:26:13 <monochrom> ok, you said "_String :: Maybe Value -> Maybe Text". therefore in order for (key "url" . _String) to make sense, (key "url") has to have type Maybe Text -> Something
14:27:08 <monochrom> but it now looks like (key "url" :: p a (f b) -> ...) and there is no way Maybe Text can match the form (p a (f b)).
14:27:27 <monochrom> this does not explain the error you talk about, but this is going to be another error you must confront later.
14:28:15 <behelit> monochrom: yes, i get that error when i try to declare the type explicitly
14:30:05 <exio4> MikeJones35: what'd testMap do? any example of you would want to use it? 
14:31:26 <behelit> monochrom: "print $ r ^? responseBody . key "url" . _String" worked fine. now that I'm attempting to return the value I get the error.
14:32:44 <MikeJones35> I think you helped me understand that one.  Earlier I was asking about a filtering example and a solution was let filterInside f xs = filter f xs      so filterInside (>2) [1,2,3]  ==  [3]   but is there a way to do this without filter and use foldr?
14:32:45 <monochrom> well, I don't even see how the subexpression (key "url" . _String) can make sense, and I'm too lazy to.
14:33:24 <behelit> monochrom: it's just copy-pase off of the internet .. :) http://www.serpentine.com/wreq/tutorial.html
14:33:25 <monochrom> the only way it can make sense is if you lied about the type of _String
14:33:43 <elvinz> hi, I want to create a function with this signature: closestClass::[[Double], [Int]] -> [[Double], [Int]] -> [[Double], [Int]]
14:33:51 <behelit> monochrom: it was the type of "key" i looked up
14:33:59 <elvinz> however I get the error message Illegal type: '[[Double], [Int]]
14:33:59 <elvinz>   Perhaps you intended to use DataKinds
14:34:10 <behelit> monochrom: _String should be "Maybe Value -> Maybe Text"
14:34:17 <behelit> let me check
14:34:28 <elvinz> how can I declare a function that takes list of lists as input / output ?
14:35:15 <paolino> ([Double],[Int])
14:35:23 <paolino> is ok
14:35:38 <MikeJones35> > foldr (>5) [4,5,6] []
14:35:39 <lambdabot>  Couldn't match type ‚ÄòGHC.Types.Bool‚Äô with ‚Äò[t] -> [t]‚Äô
14:35:39 <lambdabot>  Expected type: a0 -> [t] -> [t]
14:35:39 <lambdabot>    Actual type: a0 -> GHC.Types.Bool
14:35:47 <exio4> elvinz: what would [[Double], [Int]] mean? 
14:36:02 <elvinz> ha ok
14:36:04 <behelit> monochrom: _String :: Prism' t Text .. ok, so that's hairy
14:36:04 <elvinz> got it
14:36:54 <MikeJones35> > foldr (map (>5) [4,5,6] ) [4,5,6] []
14:36:56 <lambdabot>  Couldn't match expected type ‚Äòa0 -> [t] -> [t]‚Äô
14:36:56 <lambdabot>              with actual type ‚Äò[GHC.Types.Bool]‚Äô
14:37:24 <elvinz> paolino, exio4 I kind of declared a list with fixed type, which is a tuple
14:37:28 <elvinz> thank you
14:37:37 <paolino> MikeJones35, you should start from the beginning, foldr require some mental work
14:38:32 <Welkin> > foldr f [1, 2, 3]
14:38:34 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
14:38:34 <lambdabot>    arising from a use of ‚ÄòM211576054949482551927130.show_M2115760549494825519...
14:38:34 <lambdabot>  The type variable ‚Äòt0‚Äô is ambiguous
14:38:41 <Welkin> > foldr f [1, 2, 3] :: Expr
14:38:42 <lambdabot>  Couldn't match expected type ‚ÄòDebug.SimpleReflect.Expr.Expr‚Äô
14:38:42 <lambdabot>              with actual type ‚Äò[a0] -> [t0]‚Äô
14:39:13 <Welkin> hm, I often forget how to show that
14:39:27 <Welkin> > foldr f [] [1, 2, 3]
14:39:28 <paolino> you miss the state
14:39:29 <lambdabot>  No instance for (GHC.Show.Show t0)
14:39:29 <lambdabot>    arising from a use of ‚ÄòM636863498673750934827163.show_M6368634986737509348...
14:39:29 <lambdabot>  The type variable ‚Äòt0‚Äô is ambiguous
14:39:34 <Welkin> > foldr f [] [1, 2, 3] :: Expr
14:39:35 <lambdabot>  Couldn't match expected type ‚ÄòDebug.SimpleReflect.Expr.Expr‚Äô
14:39:35 <lambdabot>              with actual type ‚Äò[t0]‚Äô
14:39:42 * hackagebot maximal-cliques 0.1.1 - Enumerate all maximal cliques of a graph.  http://hackage.haskell.org/package/maximal-cliques-0.1.1 (GershomBazerman)
14:39:44 * hackagebot uuid-types 1.0.0 - Type definitions for Universally Unique Identifiers  http://hackage.haskell.org/package/uuid-types-1.0.0 (AntoineLatter)
14:39:46 * hackagebot uuid 1.3.9 - For creating, comparing, parsing and printing Universally Unique Identifiers  http://hackage.haskell.org/package/uuid-1.3.9 (AntoineLatter)
14:39:58 <Welkin> > foldr f [] [g1, g2, g3] :: Expr
14:39:59 <lambdabot>  Not in scope: ‚Äòg1‚Äô
14:39:59 <lambdabot>  Perhaps you meant one of these:
14:39:59 <lambdabot>    ‚Äòg‚Äô (imported from Debug.SimpleReflect),
14:40:00 <quchen> > foldr f z [1,2,3]
14:40:01 <lambdabot>  f 1 (f 2 (f 3 z))
14:40:04 <Welkin> ah
14:41:05 <MikeJones35> > foldr (+1) [] [1,2,3]
14:41:07 <lambdabot>  No instance for (GHC.Show.Show t0)
14:41:07 <lambdabot>    arising from a use of ‚ÄòM386894653599543123027230.show_M3868946535995431230...
14:41:07 <lambdabot>  The type variable ‚Äòt0‚Äô is ambiguous
14:41:19 <Welkin> > foldl f z [1,2,3]
14:41:21 <lambdabot>  f (f (f z 1) 2) 3
14:41:25 <paolino> :t foldr
14:41:26 <lambdabot> (a -> b -> b) -> b -> [a] -> b
14:41:33 <Welkin> that is a simple place to begin to learn how the folds work
14:41:37 <monochrom> filter p = foldr (\x ys -> if p x then x:ys else ys) []
14:42:29 <paolino> > foldr (+) a [1,2,3]
14:42:30 <lambdabot>  1 + (2 + (3 + a))
14:42:32 <Welkin> MikeJones35: I suggest reading the source for these functions in Base
14:42:41 <Welkin> they have wonderful commentary and examples
14:42:54 <MikeJones35> Okay thank you!
14:44:01 <monochrom> "foldr (+) [] [1,2,3]" cannot make sense because you would be talking about "1 + 2 + 3 + []"
14:44:58 <MikeJones35> yeah, I was looking for something more like foldr (+1) [] [1,2,3]  to return [2,3,4]
14:45:12 <monochrom> then it is not simply (+1)
14:45:26 <paolino> that is map
14:45:28 <monochrom> foldr (\x ys -> (x+1) : ys) []
14:46:19 <zq> anyone here use saltine in production? why is it such a bad idea
14:46:48 <monochrom> did anyone say that it is a bad idea?
14:47:09 <monochrom> if so, why not ask them why they said it?
14:47:21 <zq> nah
14:47:28 <zq> the author has, though
14:47:40 <MikeJones35> thank you monochrom! it makes sense now
14:47:52 <monochrom> then ticket closed
14:47:57 <zq> "saltine is not fit for production" yada yada. i'm just curious why it's unfit. the source looks okay.
14:48:29 <monochrom> does the "yada yada" part explain why it's unfit?
14:48:44 <zq> if it did, i wouldn't be asking, eh? 'specially not in such an indirect manner
14:48:53 <boothead> didn't there use to be a function that let you construct a lens (particularly a Setter) from a function? I want something like Lens.to that also is a setter
14:49:08 <monochrom> have you asked the author to justify his/her claim?
14:49:12 <paolino> :t lens
14:49:13 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
14:49:19 <ElderFain> MikeJones35: map (+1) [1,2,3]
14:49:21 <zq> dunno, is tel around here?
14:49:38 <zq> TEL
14:49:42 * hackagebot text-show 0.7 - Efficient conversion of values into Text  http://hackage.haskell.org/package/text-show-0.7 (ryanglscott)
14:49:43 <zq> guess not
14:49:44 * hackagebot lazysplines 0.2 - Differential solving with lazy splines  http://hackage.haskell.org/package/lazysplines-0.2 (GershomBazerman)
14:50:27 <boothead> paolino, thanks I think that's it!
14:50:30 <boothead> :t lens'
14:50:30 <lambdabot>     Not in scope: ‚Äòlens'‚Äô
14:50:31 <lambdabot>     Perhaps you meant ‚Äòlens‚Äô (imported from Control.Lens)
14:51:00 <monochrom> the internet is full of opinion blogs without backing. if I got paid $10 to investigate each one, I would own all the world's money supply
14:51:05 <MikeJones35> Is there a simple way to concatenate only the first two elements of a list? (I was just reading how to concatenate two lists)
14:51:48 <paolino> :t splitAt
14:51:49 <lambdabot> Int -> [a] -> ([a], [a])
14:51:54 <boothead> :t prism'
14:51:55 <lambdabot> (Choice p, Applicative f) => (b -> s) -> (s -> Maybe a) -> p a (f b) -> p s (f s)
14:52:16 <monochrom> my conclusion is that I ignore a claim on the internet by default, and I only allow an exception when the claim already comes with sufficient evidence.
14:53:33 <paolino> MikeJones35, is that a list of lists ?
14:55:11 <MikeJones35> paolino: I was just wondering for a list ["first","second","third"] how would you write something to make a new list like ["first second","third"]   with a space between them
14:55:29 <MikeJones35> Or is that not possible?
14:55:32 <paolino> you can use splitAt 
14:55:44 <monochrom> f (x : y : rest) = (x ++ " " ++ y) : rest
14:55:54 <zipper> @hoogle [[a]] -> [a]
14:55:56 <lambdabot> Prelude concat :: [[a]] -> [a]
14:55:56 <lambdabot> Data.List concat :: [[a]] -> [a]
14:55:56 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
14:56:22 <monochrom> but what do you want to do if the list does not have enough items?
14:56:36 <hunteriam> I'm having a really tough time processing this sa answer http://stackoverflow.com/q/28690448/286871
14:56:42 <tongcx> hi guys, what does `data Shape f = Shape (f ())` mean?
14:56:51 <hunteriam> I feel like I understand monads, but this thing totally overwhelmed me
14:56:52 <tongcx> any example to illustrate that?
14:57:12 <MikeJones35> monochrom: ah didn't know you could do x:y:rest  I thought it was just x:rest. Thanks! And probably just return what ever is given if it contains only one element or is empty
14:57:27 <MikeJones35> So would that use pattern matching?
14:57:36 <paolino> 2 times
14:57:37 <glguy> Shape [(),()] 07:: Shape []; Shape (Just ()) 07:: Shape Maybe
14:57:47 <monochrom> a longer way to write "x:y:rest" is "x : (y : rest)" to show you how I'm nesting patterns
14:58:04 <monochrom> it is doing pattern matching
14:58:26 <hunteriam> http://stackoverflow.com/q/28690448/286871 can someone point me to a book or something so I can have a chance at understanding this
14:58:33 <hunteriam> Or maybe I just need some sleep
14:58:37 <monochrom> f too_short = too_short
14:58:45 <zipper> I'm looking for a function [[a]] -> [a]  that can do --> [['a','b'],['c','d']] to get ['a','c']
14:58:55 <zipper> Someone point me to onw
14:59:01 <zipper> *one
14:59:01 <paolino> MikeJones35, and (:) is the constructor
14:59:35 <paolino> :t map head
14:59:36 <lambdabot> [[b]] -> [b]
14:59:42 * hackagebot text-show-instances 0.3 - Additional instances for text-show  http://hackage.haskell.org/package/text-show-instances-0.3 (ryanglscott)
14:59:44 <monochrom> zipper: it seems to be "transpose" and "head"
14:59:50 <tongcx> glguy: is there some easy way to let Shape deriving (Show)?
15:00:01 <monochrom> oh nevermind, "map head" is better
15:00:21 <hunteriam> Man I was thinking of a fold solution
15:00:25 <hunteriam> I need sleep
15:00:39 <zipper> monochrom: head is dangerous
15:00:47 <hunteriam> :t foldr
15:00:47 <lambdabot> (a -> b -> b) -> b -> [a] -> b
15:00:56 <monochrom> you can use foldr to write map
15:00:57 <zipper> :t transpose
15:00:58 <lambdabot> [[a]] -> [[a]]
15:01:10 <zipper> monochrom: Me?
15:01:19 <monochrom> transpose gives you [['a', 'c'], ['b', 'd']]
15:02:15 <hunteriam> So.... Can someone point me to the background know,edge I need to understand this http://stackoverflow.com/q/28690448/286871
15:02:16 <monochrom> concat . map (take 1)
15:02:40 <paolino> > concat []
15:02:41 <lambdabot>  []
15:02:52 <hunteriam> :t map (take 1)
15:02:52 <paolino> mh
15:02:53 <lambdabot> [[a]] -> [[a]]
15:03:02 <glguy> tongcx: Not afaik
15:03:16 <tongcx> glguy: thanks
15:03:48 <paolino> > concat [[]]
15:03:49 <lambdabot>  []
15:04:08 <zq> why don't you just use a list comprehension?
15:04:08 <lpaste> glguy pasted ‚Äúderiving show for shape for tongcx‚Äù at http://lpaste.net/128211
15:04:19 <glguy> tongcx: That's the closest I know of
15:04:26 <hunteriam> > map (take 1) [[a,a+1] | a <- [1,3..10]]
15:04:27 <lambdabot>  [[1],[3],[5],[7],[9]]
15:04:57 <zq> list monad handles fail just fine without having to think of all your edge cases
15:05:15 <hunteriam> @zq example?
15:05:15 <lambdabot> Maybe you meant: wn v rc pl id faq do bf @ ? .
15:05:30 <hunteriam> Silly lambdabot
15:05:37 <ttt_fff> what is the haskell equiv of numpy?
15:05:52 <zq> > fail "oh noes" :: [Int]
15:05:55 <lambdabot>  []
15:06:00 <zq> > fail "oh noes" :: [Int]  -- hunteriam 
15:06:02 <lambdabot>  []
15:06:11 <hunteriam> I mean of how we'd use it to solve this problem
15:06:12 <ttt_fff> I need to do some image processing / deep learning / linear algebra in Haskell. What is Haskell's equiv for ipython / julia / matlab ?
15:06:20 <lpaste> glguy annotated ‚Äúderiving show for shape for tongcx‚Äù with ‚Äúderiving show for shape for tongcx using Show1‚Äù at http://lpaste.net/128211#a128212
15:06:39 <boothead> I'm just about to use prism', but I'm not exactly sure how to think of the first function (b -> s) if I'm building a very nested object how does lens know that I'm only looking at the b and to leave the rest of s alone?
15:06:43 <boothead> :t prism'
15:06:44 <lambdabot> (Choice p, Applicative f) => (b -> s) -> (s -> Maybe a) -> p a (f b) -> p s (f s)
15:07:22 <glguy> tongcx: The second of those is more "correct"
15:07:57 <hunteriam> ttt_fff: I personally don't know, sorry no answers
15:08:02 <zq> > let zipper's_function xs = [tip | (tip:_) <- xs] in zipper's_function ["ab", "cd"]
15:08:03 <lambdabot>  "ac"
15:08:05 <zq> hunteriam: ^
15:08:49 <zq> > let zipper's_function xs = [tip | (tip:_) <- xs] in zipper's_function ["ab", "cd", "", "ef"]
15:08:50 <lambdabot>  "ace"
15:08:53 <hunteriam> >let zipper's_function xs = [tip | (tip:_) <- xs] in zipper's_function ["ab", "cd",""]
15:09:05 <hunteriam> Oh nice
15:09:08 <Iceland_jack> v
15:09:09 <zq> yes head is dangerous, that's why fail is there
15:09:48 <hunteriam> So I guess list comprehensions desugar similarly to do notation?
15:09:54 <hunteriam> Zq ^^
15:10:05 <tongcx> glguy: thanks
15:10:31 <ttt_fff> http://hackage.haskell.org/package/accelerate-cuda-0.15.0.0/docs/Data-Array-Accelerate-CUDA.html is interesting
15:10:44 <ttt_fff> http://hackage.haskell.org/package/accelerate-cuda-0.15.0.0/docs/Data-Array-Accelerate-CUDA.html <-- however, not clear if it provides linear algebra routines
15:11:17 <zq> > let zipper's_other_function xs = do { (tip : _) <- xs; return xs; } in zipper's_other_function ["asfd", "", "123"]  -- hunteriam 
15:11:18 <lambdabot>  [["asfd","","123"],["asfd","","123"]]
15:11:26 <zq> oops
15:11:35 <zq> > let zipper's_other_function xs = do { (tip : _) <- xs; return tip; } in zipper's_other_function ["asfd", "", "123"]  -- hunteriam correction
15:11:37 <lambdabot>  "a1"
15:12:14 <zq> remember that guy from a few months back who raged about calling it the list monad? heh
15:13:17 <xplat> zq: dang right, it should be called the 'left square bracket right square bracket' monad
15:13:40 <Hijiri> ttt_fff: I think #numerical-haskell is a channel for a project that aims to provide that sort of functionality
15:13:46 <hunteriam> lol I wish I saw that
15:13:49 <Hijiri> you could ask there what's available
15:13:54 <zq> xplat: i believe that applies to every instance of monadplus, too
15:14:13 <quchen> zq: And fail is dangerous because it's in every Monad but shouldn't bt.
15:14:14 <quchen> be*
15:14:48 <merijn> zq: FYI, list comprehensions don't actually desugar into monad syntax like that
15:14:50 <zq> wait no, monadcomprehensions work on arbitrary monads
15:14:57 <merijn> They could, but don't right now
15:15:01 <xplat> before you can learn to succeed, you must learn how to fail
15:15:20 <xplat> merijn: i thought they do again if you enable the right LANGUAGE option?
15:15:20 <monochrom> zq's position can be justified by "[] is a MonadPlus", i.e., replace fail by mzero.
15:15:29 <zq> quchen: it's the list monad. we know what it does. i'm not advocating the use of fail in the general case, ofc not
15:15:31 <merijn> xplat: With MonadComprehensions they do, yes
15:15:39 <quchen> But not all MonadPlus have fail = const mzero, STM being the most prominent example.
15:16:12 <zq> xplat: ergo the left-square-bracket-right-square-bracket qualifier == id with LANGUAGE MonadComprehensions
15:16:32 <zq> quchen: dude. list monad. list monad. not all monads. just the list monad.
15:17:55 <xplat> dude, it's like, dude.  i mean, DUDE.  but, like, duuuuude.
15:17:55 <monochrom> I like to take an idea that has a good main point but just marred by a small technicality, fix that technicality to save the main point, and reach maximum agreement. rather that use that technicality to reach maximum disagreement.
15:18:51 <hunteriam> What is a monadplus and how's it different from a monoid
15:19:06 <monochrom> monoid is more general than monadplus
15:19:23 <edwardk> hunteriam: MonadPlus is on * -> *, not *, and it also carries laws relating it to Monad.
15:19:28 <monochrom> but that comes later. first, they don't even talk about the same kind
15:19:28 <hpc> "more general" meaning "admits more instances"
15:19:48 <hpc> the extra specificity of MonadPlus lets you do a few additional things with it
15:19:59 <edwardk> hunteriam: sadly there are at least 2-3 sets of such laws people like, and each monadplus implements a different set ;)
15:19:59 <xplat> monadplus is the sequel to monad.  monadzero is the prequel to monadplus.  monoid is the reboot of monadplus.
15:20:04 <t7> your mum is a plus size monad
15:20:21 <quchen> Also, Monoid comes with laws, whereas MonadPlus comes with fuzzy guidelines everyone can pick at will. :-C
15:20:22 <edwardk> xplat: not helpful =P
15:20:46 <xplat> edwardk: not helpful, but true!
15:20:57 <edwardk> quchen: well, MonadPlus at least has the associativity and unit laws
15:21:04 <alynn> quchen: I think everyone agrees on monoid laws for MonadPlus
15:21:10 <edwardk> quchen: its all the distributive and catch laws that catch everyone out
15:21:15 <hunteriam> Why do we keep monadplus?
15:21:17 <mildfate> Hi all, this is going to be a dumb question, but I'm just starting learning.  When I try to load http://pastebin.com/FPm2DHPL into ghci, it says parse error on input ‚Äòmodule‚Äô.  What simple thing am I doing wrong?
15:21:25 <edwardk> hunteriam: because it is very very useful
15:21:26 <quchen> edwardk: And the right zero as well
15:21:46 <hunteriam> But if it's useful, Shouldn't we agree on its rules?
15:21:49 <edwardk> yeah right zero is basically hosed =)
15:22:24 <quchen> Distributive/catch should just be removed from the class, all they cause is confusion and no safety at all.
15:22:28 <Axman6> mildfatethat's the whole file? nothing else is in the file? and the file is called Chapter3.hs?
15:22:35 <mildfate> yep
15:22:43 <mildfate> I don't understand wth is wrong with it
15:22:59 <pavonia> mildfate: How do you load the file?
15:23:09 <mildfate> :l Chapter3
15:23:18 <monochrom> what is the exact verbatim error message?
15:23:32 <monochrom> exact verbatim complete uncut unabridge
15:23:46 <edwardk> hunteriam: the problem is this, fixing the distributive/catch/right-zero laws means making it into 3-4 different classes, when almost nobody observes the problem with them fused today, breaks everything that has been written in haskell since what, 93 or so when they came along in the process, and then breaks the ability to pun between them for things like
15:23:46 <edwardk> making list of successes parsers downgrade to a 'first match' parser when you instantiate it with Maybe instead of [].
15:24:06 <mildfate> monochrom: k, I don't know what the problem was, I just rewrote the file and it works now
15:24:12 <mildfate> possible I had a messed up character?
15:24:13 <mildfate> idk
15:24:23 <edwardk> hunteriam: the fix isn't cheap, it costs everyone a lot, and benefits comparatively few
15:24:23 <monochrom> good, ticket closed
15:24:51 <edwardk> nd then you have to repeat it at the Alternative level, making even more classes
15:24:56 <matt_____> is there a way to make cabal ignore the 'global' package database when trying to satisfy constraints in a sandbox?
15:25:18 <monochrom> cannot ignore global practically. base is there.
15:25:52 <monochrom> but if you're just mixing up terminology and you mean "user", then the sandboxing mechanism already ignores user. always.
15:25:54 <geekosaur> midfate, using notepad on windows by any chance? some versions output a unicode byte order mark as the first character (which is kinda nonsensical with utf8, and confuses other programs)
15:26:03 <edwardk> so what we have instead is a MonadPlus that only states the laws that hold for the intersection of those cases
15:26:40 <edwardk> it is unsatisfying but at least it isn't 6-8 classes
15:26:41 <geekosaur> for a simple programming editor on windows I'd suggest http://notepad-plus-plus.org/
15:27:02 <monochrom> I use notepad-plus-plus, too
15:27:20 <monochrom> (when I'm on windows. but I'm on linux more often)
15:27:51 <monochrom> (crosstalk) what are the laws of notepad-plus-plus?
15:28:07 <geekosaur> "try not to suck" :p
15:28:54 <monochrom> I have a cunning plan. if you want to inflict more laws on MonadPlus, assign them to a new class called MonadPlusPlus
15:29:33 <monochrom> @quote monochrom debates
15:29:33 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
15:31:17 <merijn> monochrom: I thought all pointless debates could be settled by more uses of (.) ?
15:32:04 <merijn> Just use vim on windows :p
15:32:04 <monochrom> I disagree. but I will agree if you change it to (...).
15:32:57 <edwardk> hunteriam: note in all of those case the (a <|> b) <|> c = a <|> (b <|> c) law holds, as does empty <|> a and a <|> empty. (switching to Alternative notation from MonadPlus, its prettier) There is one law relating to empty that everyone satsfies for >>= as well, effectively enforced by parametricity, mzero >>= a = mzero. This holds for the MonadPlus case but
15:32:57 <edwardk> not mere Alternative, where it breaks down, it is only whether you have a right-distributive law (a <|> b) <*> c = (a <*> c) <|> (b <*> c)   or a catch law: pure x <|> a = pure x    or right zero: a >> mzero = mzero   that is in doubt
15:33:09 <monochrom> example. <A> monads are great! <B> no! <A> is too! <B> is not! <monochrom> ...
15:34:37 <mildfate> I have this definition in my file: floor x = until (`leq` x) (subtract 1) (-1)  I'm curious, is the only way to reference a function specify that when it's applied to put the parameter as the first argument (as opposed to the subsequent) *besides* referring to it within a section with backticks?
15:34:38 <edwardk> so to handle this correctly you need the base classes for Alternative and MonadPlus (we already saw MonadPlus gave us mzero >>= a = mzero), then the refinements for the distributive law, catch, and right zero for each level, plus a classes for the left zero for alternative to be pedantic, since there it isn't automatic.
15:35:00 <mildfate> is there any way besides*
15:35:02 <edwardk> all to fix a problem few notice
15:36:16 <edwardk> also note that for things like [] and Maybe there are two MonadPluses you could implement, so it also seems likely you'd want to implement them as separate combinators breaking code much further.
15:36:28 <merijn> mildfate: Maybe you're thinking of flip?
15:36:35 <merijn> :t flip
15:36:36 <lambdabot> (a -> b -> c) -> b -> a -> c
15:37:02 <mildfate> interesting
15:37:05 <merijn> (`elem` [1..10]) == flip elem [1..10]
15:37:30 <edwardk> i still love ski's variant on flip. it is oddly satisfying
15:37:35 <edwardk> :t (??)
15:37:36 <lambdabot> Functor f => f (a -> b) -> a -> f b
15:37:50 <merijn> edwardk: And totally not confusing to beginners ;)
15:37:55 <edwardk> yep
15:38:25 <mildfate> also, why can't I do something like ":i ((<= x) . fromInteger)"?  I want to find out this thing's type
15:38:37 <edwardk> mildfate:  :t
15:38:54 <merijn> :t (<= 3) . fromInteger
15:38:55 <lambdabot> Integer -> Bool
15:39:03 <quchen> Just view the problem in the domain of the function applicative -- should be on theproofistrivial.com
15:39:34 <mildfate> merijn: ok, thanks, just have to apply it
15:39:37 <monochrom> ":info" is for names, not expressions
15:39:45 * hackagebot tasty-golden 2.3 - Golden tests support for tasty  http://hackage.haskell.org/package/tasty-golden-2.3 (RomanCheplyaka)
15:39:47 * hackagebot jammittools 0.4.1 - Export sheet music and audio from Windows/Mac app Jammit  http://hackage.haskell.org/package/jammittools-0.4.1 (mtolly)
15:40:04 <monochrom> in fact, try this some day: ":info map + Monad"
15:43:13 <artemshitov> Is there a way to check if a given path is a directory on Windows?
15:44:49 <kaiyin> Why does this query on hoogle lead to an parseError? ¬†f¬†(a¬†->¬†b)¬†->¬†f¬†a¬†->¬†f¬†b¬†¬†
15:45:20 <merijn> kaiyin: Doesn't for me...
15:45:51 <kaiyin> Strange, it works now.
15:47:58 <benzrf> :t (??)
15:47:59 <lambdabot> Functor f => f (a -> b) -> a -> f b
15:48:03 <benzrf> o wait
15:48:24 <monochrom> artemshitov: I think System.Directory.doesDirectoryExist helps
15:49:52 <merijn> monochrom: Well, only kinda sorta
15:50:13 * merijn continues the campaign to ban doesXExist from filepath/directory
15:50:35 <monochrom> what is a better way?
15:50:49 <merijn> Just open/use and see if you get an exception
15:50:57 <merijn> doesXExist is a race condition waiting to happen
15:51:07 <monochrom> oh! that's better.
15:51:16 <mildfate> So I have this definition "lt x n = x < fromInteger n" which has type, "lt :: Float -> Integer -> Bool".  I'm confused what the role of "fromInteger" is.  Does it cast the integer n to type Float?  or does it cast it to type Num and x is cast to Num as well?
15:51:48 <merijn> mildfate: fromInteger converts an Integer to *a* Num type
15:51:51 <geekosaur> there is no type Num
15:51:53 <monochrom> unless the original task was really "just polling: does it exist? won't use it anyway" :)
15:51:56 <merijn> mildfate: Float happens to be an instance of Num
15:52:16 <pavonia> merijn: Why is it a race condition?
15:52:17 <merijn> geekosaur: "a type that's an instance of Num" >.> I'm lazy...
15:52:25 <merijn> pavonia: Someone could delete the directory after checking
15:52:35 <merijn> pavonia: Or create it after you decided it doesn't exist
15:52:38 <mildfate> merijin: So, since x is of type Float which is an instance of Num, the operation < can be performed on x and n?
15:52:43 <geekosaur> merijn, I was reacting to mildfate's "does it cast it to type Num"
15:53:02 <mildfate> oh, Num is an instance, right>
15:53:03 <mildfate> ?
15:53:08 <geekosaur> it's a class
15:53:12 <merijn> pavonia: See TOCTOU https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use
15:53:29 <merijn> mildfate: Num is a class, Float is an instance of that class
15:53:30 <geekosaur> you can't make a thing of "type" Num. you can make things of types which have Num instances
15:53:31 <merijn> :t fromInteger
15:53:32 <lambdabot> Num a => Integer -> a
15:53:50 <mildfate> hmm, I'm trying to hold all these different intersecting typeclasses, instances, classes, and types in my head that involve numbers but I'm getting lost in the weeds
15:53:53 <merijn> mildfate: fromInteger says it'll convert an Integer to *any* instance of Num that you want
15:54:01 <merijn> :t fromInteger
15:54:02 <lambdabot> Num a => Integer -> a
15:54:06 <merijn> :t fromInteger :: Integer -> Float
15:54:07 <lambdabot> Integer -> Float
15:54:11 <merijn> :t fromInteger :: Integer -> Word
15:54:12 <lambdabot> Integer -> Word
15:54:14 <merijn> etc
15:54:15 <monochrom> . o O ( <A> fruit flies like a banana  <B> but fruit is not a fly )
15:54:30 <merijn> monochrom: It took me like 10 years before I got that joke
15:54:35 <monochrom> :)
15:54:52 <mildfate> :t Word
15:54:53 <lambdabot> Keyword
15:54:59 <dolio> It took me a depressingly long time, too.
15:55:14 <mildfate> is word an instance of Num?
15:55:19 <mildfate> :i Word
15:55:32 <merijn> In my defense, I'm not a native speaker. On the other hand, I've been fluent since I was like 9, so I'm not sure that's a great defense :p
15:55:35 <merijn> mildfate: Yes
15:55:49 <merijn> mildfate: lambdabot doesn't support ":i"
15:56:06 <dolio> I'm going to blame it on the strange wording. I think I would always says, "fruit flies like bananas."
15:56:15 <dolio> But maybe I wouldn't have gotten it even then.
15:56:29 <dolio> Would always say, even.
15:56:42 <rui> m0rphism: Success with i3, thanks!
15:56:52 <mildfate> merijn: Wait, why is Integer not of type Num in its definition?
15:56:59 <m0rphism> rui: Yay, you're welcome :)
15:57:15 <quchen> mildfate: The Haskell Report has a diagram showing the entire number class hierarchy.
15:57:34 <mildfate> quchen: sounds usefull
15:57:37 <rui> :) plenty of things to tweak though but its a good start
15:57:46 <merijn> mildfate: Because it's called fromInteger, which means that, as the name implies, it only works on input values of type Integer :)
15:58:23 <monochrom> you can also ask ghci ":type fromInteger" to see its type
15:58:34 <monochrom> generally I don't recommend guessing types from names.
15:58:37 <mildfate> merijn: I guess it seems weird to me that I have to explicitly say, "hey, push this type, Integer, up a level to Num, even though you already know it's an instance of Num"
15:59:08 <monochrom> no, nothing is pushing Integer up to the Num level.
15:59:22 <mildfate> monochrom: fromInteger isn't doing that?
15:59:26 <geekosaur> mildfate, Num is not a level you can push things to
15:59:41 <monochrom> instead, fromInteger converts from Integer to another type.
15:59:44 <merijn> > fromInteger 5 :: Float
15:59:45 <lambdabot>  5.0
15:59:53 <rui> mildfate: fromInteger converts an integer to any other type that belongs to Num
15:59:54 <merijn> > fromInteger 5 :: Complex Double
15:59:54 <geekosaur> fromInteger is saying: I have an Integer. I need some other compatible type (the definition of "compatible" being: has a Num instance)
15:59:55 <lambdabot>  5.0 :+ 0.0
16:00:07 <geekosaur> in this case the other type is Float
16:00:13 <rui> Polymorphic, works as fromIntegerToDouble, fromIntegerToFloat, etc etc
16:00:25 <geekosaur> but it could be any type that expresses a Num instance
16:00:36 <merijn> rui: fromIntegerToComplexIntRatio ;)
16:00:39 <mildfate> geekosaur: Why is there only fromInteger declared in Num and not fromFloat as well?
16:00:57 <merijn> Because that's
16:00:57 <rui> merijn: tldr
16:00:59 <merijn> :t fromRational
16:01:01 <lambdabot> Fractional a => Rational -> a
16:01:05 <mildfate> wth
16:01:15 <geekosaur> because if you are going from Float to an integral type, there are at least 3 possible choices for what to do with the decimal part
16:01:20 <geekosaur> :t round
16:01:21 <xplat> merijn: i'd like to just ban the filesystem
16:01:21 <lambdabot> (RealFrac a, Integral b) => a -> b
16:01:26 <geekosaur> :t ceil
16:01:28 <lambdabot> Not in scope: ‚Äòceil‚Äô
16:01:31 <merijn> :t fromInteger 5 :: Complex (Ratio Int)
16:01:31 <geekosaur> :t ceiling
16:01:32 <lambdabot>     No instance for (RealFloat (Ratio Int))
16:01:32 <lambdabot>       arising from a use of ‚ÄòfromInteger‚Äô
16:01:32 <lambdabot>     In the expression: fromInteger 5 :: Complex (Ratio Int)
16:01:32 <lambdabot> (RealFrac a, Integral b) => a -> b
16:01:35 <merijn> aww
16:01:35 <geekosaur> :t floor
16:01:36 <lambdabot> (RealFrac a, Integral b) => a -> b
16:01:40 <xplat> merijn: the whole thing is a race condition waiting to happen
16:01:45 <merijn> xplat: True
16:01:46 <geekosaur> so you need to pick one appropriate for your use
16:02:03 <merijn> geekosaur: More than 3 :p
16:02:12 <geekosaur> I did say "at least 3"
16:02:30 <mildfate> geekosaur: Why can't I keep the decimal part? Why does it have to be rid of?
16:02:39 <geekosaur> where do you put it in an Integer?
16:02:45 <geekosaur> or worse, an Int
16:02:46 <dolio> xplat: Unfortunately that's a bit larger in scope than Haskell libraries.
16:02:48 <MP2E> Integer is an instance of Num, how would you keep the decimal part?
16:03:18 <mildfate> geekosaur: Ok, so the point is of the 4 instances of Num, Integer is the only one from which you can go to any other instance?
16:03:27 <geekosaur> :t fromIntegral
16:03:28 <lambdabot> (Num b, Integral a) => a -> b
16:03:35 <xplat> 18:53 < monochrom> . o O ( <A> fruit flies like a banana  <B> but fruit is not a fly ) <-- i still don't get this joke
16:03:38 <mildfate> wait, the fuuuu
16:04:20 <geekosaur> fromInteger is mostly there because it's used in the compiler implementation: a numeric literal is either an Integer or a Rational (= Ratio Integer), and has fromInteger or fromRational applied to it automatically so that it can be used anywhere a Num instance is needed
16:04:26 <monochrom> xplat, if I say "True is a Bool value", do you pick on me with "but Bool is a type, not a value"?
16:04:35 <geekosaur> in real code we tend to use fromIntegral instead of fromInteger
16:04:46 <monochrom> therefore, if I say "Integer is a Num type", do you pick on me with "but Num is not a type"?
16:05:01 * quchen gets neither the joke nor the explanations
16:05:17 <mildfate> geeksaur: Actually, what I said is true, right?  of the 4 instances of Num, Integer is the only one from which you can go to any other instance (Int, Float, and Double)?
16:05:26 <geekosaur> not exactly
16:05:31 <geekosaur> because Int is smaller than Integer
16:05:41 <mildfate> :t fromInteger Int
16:05:42 <lambdabot>     Not in scope: data constructor ‚ÄòInt‚Äô
16:05:42 <lambdabot>     Perhaps you meant one of these:
16:05:42 <lambdabot>       ‚ÄòIn‚Äô (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
16:05:43 <xplat> monochrom: no, i pick on you with "Integer is comfortably Num"
16:05:46 <geekosaur> (Integer is arbitrary sized, Int is a machine word)
16:05:54 <geekosaur> so in some sense Int is the more basic type
16:06:31 <monochrom> but I guess I also pick on English anyway
16:06:37 <xplat> mildfate: there are a lot more instances of Num than 4.  CReal, Complex Float, Rational, Complex Ratio Int, the ones in ad...
16:06:50 <monochrom> EBL = English as a Broken Language
16:06:56 <geekosaur> in fact you can see this in practice if you play with toEnum and fromEnum a bit
16:07:11 <geekosaur> they use Int as the basic type that any enumeration can be mapped to
16:07:18 <artemshitov> monochrom: merjin: Ok thanks
16:07:35 <geekosaur> (this gets moderately weird because the Float and Double instances do things that are not entirely sensible...)
16:07:41 <mildfate> xplat: Ah, ok, I'm just looking at what's listed in fig 6.1 https://www.haskell.org/onlinereport/basic.html
16:08:29 <geekosaur> (in fact, technically those instances should not exist, but being able to use a range on Float or Double is convenient. but Enum conflates ranges with enumerations, incorrectly)
16:08:48 <bazqux> Is there some function for mapping a function, f, over a list but rather than returning a list of [f x] instead returns a list of tuples, [(x, f x)]?
16:08:59 <mildfate> geekosaur: When you say "not exactly" what do you mean?
16:09:07 <mildfate> :t fromInteger :: Integer -> Int
16:09:08 <lambdabot> Integer -> Int
16:09:21 <merijn> bazqux: "zip xs (map f xs)"?
16:09:29 <geekosaur> [22 23:04] <geekosaur> (Integer is arbitrary sized, Int is a machine word)
16:09:29 <geekosaur> [22 23:05] <geekosaur> so in some sense Int is the more basic type
16:09:32 <merijn> or
16:09:40 <geekosaur> so you can lose data going from Integer to Int
16:09:49 <pavonia> :t map (id &&& f)
16:09:50 <lambdabot> (FromExpr c', Show c) => [c] -> [(c, c')]
16:09:50 <merijn> :t zipWith (id &&& even)
16:09:51 <lambdabot>     Couldn't match type ‚Äò(c1, Bool)‚Äô with ‚Äòb -> c‚Äô
16:09:51 <lambdabot>     Expected type: c1 -> b -> c
16:09:51 <lambdabot>       Actual type: c1 -> (c1, Bool)
16:09:52 <geekosaur> just as you do when going from Double to Int
16:09:57 <xplat> bazqux: map (\x -> (x, f x))
16:09:59 <merijn> eh, map, duh
16:10:24 <mildfate> geekosaur: Ok, I gotcha
16:10:28 <quchen> I was expecting Aztec gods to be invoked.
16:10:56 <xplat> quchen: no, that only happens when you need x from a different position
16:11:05 <merijn> @pl \xs f -> zip xs (map f xs)
16:11:06 <lambdabot> liftM2 (.) zip (flip map)
16:11:12 <merijn> Clearly :D
16:11:18 <merijn> @pl \f xs -> zip xs (map f xs)
16:11:18 <lambdabot> ap zip . map
16:11:56 <merijn> So, that's like 6 different, increasingly confusing solutions ;)
16:11:57 <geekosaur> > fromInteger 100000000000000000000000000 :: Int
16:11:59 <lambdabot>  -2537764290115403776
16:12:06 <mildfate> geekosaur: I'm still not convinced on why it's necessary to use fromInteger on an Integer when "(<) :: Ord a => a -> a -> Bool".  both, for example, Float and Integer are in Num, so can't Num go into "a"?
16:12:12 <geekosaur> ^ not all Integer-s fit in an Int
16:12:28 <xplat> TMTOWTDI, and #haskell will tell you all of them
16:12:28 <geekosaur> mildfate: they have to be the same a
16:12:37 <quchen> > (zip`ap`map f) [a, b, c] :: [(Expr, Expr)]
16:12:38 <lambdabot>  [(a,f a),(b,f b),(c,f c)]
16:12:38 <mildfate> geekosaur: They are, Num
16:12:41 <geekosaur> no
16:12:46 <bazqux> merijn: That'll do! Thanks.
16:12:47 <geekosaur> Num is not a type
16:13:15 <geekosaur> you have one Integer and one Float
16:13:32 <bazqux> xplat: Or that. Thanks to you too!
16:13:35 <xplat> quchen: Num is an attribute of a type.
16:13:42 <mildfate> geekosaur: Ok, I got it
16:13:49 <xplat> mildfate: that
16:13:58 <mildfate> geekosaur: Only types can be subtituted into type signatures
16:14:05 <quchen> xplat: ?
16:14:05 <mildfate> Num is a typeclass, not a type
16:14:21 <xplat> quchen: i meant to talk to mildfate 
16:14:29 <geekosaur> essentially, yes
16:14:54 <mildfate> Why are Floats and Integers data declarations and Rational a type?
16:15:08 <geekosaur> because Rational is an alias for Ratio Integer
16:15:15 <xplat> mildfate: 'values of a Num type' are like 'balls in red boxes'.  values of Int are like 'rubber balls'.
16:15:37 <napping> mildfate: Float and Integer are types
16:16:03 <napping> ah, you mean declared with "data" or with "type"
16:16:08 <mildfate> napping: yes
16:16:09 <xplat> mildfate: what you said about (<) is like saying 'how can two balls that are both in red boxes not be in the same box?'
16:17:11 <mildfate> xplat: Oooohhh, I like that.  So there are multiple red boxes, and any ball that's in any red box, presumably can have some operation performed on them like <
16:17:34 <xplat> mildfate: right.  but only if you have two balls in the *same* red box.
16:18:06 <mildfate> xplat: How does ghc know that in the context of lt x n = x < fromInteger n I want to place n in the Float box?
16:18:23 <napping> Without a type signature it wouldn't
16:18:27 <mildfate> Ah!
16:18:29 <napping> upi
16:18:29 <mildfate> For real?
16:18:39 <napping> you'll get a type like (Num a) => a -> Integer -> Bool
16:18:39 <mildfate> It can't be inferred?
16:18:47 <napping> :t \lt x n -> x < fromInteger n
16:18:48 <lambdabot> (Ord a, Num a) => t -> a -> Integer -> Bool
16:19:14 <mildfate> napping: Oh snap, okay, that helps a lot
16:19:17 <napping> It infers a more generaly type - for any particular type a that has instances Ord a and Num a, it works
16:19:32 <scott> :t \x n -> x < fromInteger n -- lt isn't a parameter
16:19:33 <lambdabot> (Ord a, Num a) => a -> Integer -> Bool
16:19:47 * hackagebot hsmisc 1.1 - A collection of miscellaneous modules  http://hackage.haskell.org/package/hsmisc-1.1 (DinoMorelli)
16:20:03 <mildfate> There's still one open question, why is Rational declared with the "type" keyword and Integer and Float with "data"?
16:20:14 <geekosaur> you missed my answer?
16:20:22 <geekosaur> Rational is short for Ratio Integer
16:20:35 <xplat> mildfate: because Rational is just a nickname for 'Ratio Integer', it's not really its own thing
16:21:18 <mildfate> xplat: Errr... what's meant by Ratio?
16:21:34 <napping> "data" vs "type" is a bit of a different question
16:21:51 <napping> Num isn't a type in the same sense as Float or Integer
16:22:04 <napping> but there's a few different ways you can get things that are types in the later sense
16:22:08 <xplat> mildfate: Ratio is something that was defined with 'data'
16:22:34 <xplat> :t 3 % 5
16:22:34 <lambdabot> Integral a => Ratio a
16:22:48 <xplat> :t (3 :: Int) % 5
16:22:49 <lambdabot> Ratio Int
16:23:00 <xplat> :t (3 % 5) :: Rational
16:23:01 <lambdabot> Rational
16:23:01 <napping> data makes a new algebraic data type from scratch, but you can also use type to give a short name to something assembled from other types, or newtype to make a type that's basically a wrapper from an existing type, but considered an independent tye
16:23:15 <mildfate> xplat: Whoah, what are the implications of all those different types?
16:23:44 <xplat> > 3 % 5 + 2 % 3 :: Rational
16:23:45 <lambdabot>  19 % 15
16:24:35 <xplat> mildfate: Ratio is really just a generic type, like []
16:24:41 <xplat> or Maybe
16:24:47 <napping> :t [1,2,3]
16:24:48 <lambdabot> Num t => [t]
16:24:53 <napping> :t [1::Int,2,3]
16:24:54 <lambdabot> [Int]
16:24:57 <mildfate> Ratio is different from Rational?
16:25:01 <napping> :t ['a','b','c'] :: String
16:25:02 <lambdabot> String
16:25:10 <napping> :t ['a','b','c']
16:25:11 <lambdabot> [Char]
16:25:22 <xplat> mildfate: Rational is specifically Ratio Integer.  it's exactly the same type
16:25:23 <napping> there's type String = [Char]
16:25:43 <xplat> > (3 % 5 :: Ratio Integer) + (2 % 3 :: Rational)
16:25:44 <lambdabot>  19 % 15
16:25:59 <mildfate> ahhhh okay, so what other Ratio "types" besides Integer are there?
16:26:06 <xplat> they're just different names for the same red box
16:26:06 <mildfate> could you have Ratio Float?
16:27:01 <mildfate> Rational is a type alias!
16:27:05 <xplat> mildfate: no, because Float is not Integral.  Int and Integer both are
16:27:22 <napping> You couldn't do much with Ratio Float
16:27:31 <mildfate> xplat: Ok, so you can have only, Ratio Int and Ratio Integer, unless you create another instance of Integral
16:27:59 <enthropy> Ratio Word8
16:28:08 <xplat> mildfate: (technically i think you can still have Ratio Float, but almost none of the operations will work)
16:28:47 <scott> the Ratio Float type can exist but (%) require Integral
16:28:49 <scott> :t (%)
16:28:50 <lambdabot> Integral a => a -> a -> Ratio a
16:29:16 <scott> (and the various arithmetic functions)
16:30:02 <napping> Without Integer you have to worry more about the denominator overflowing
16:30:42 <alynn> what are the laws for Integral?
16:30:51 <alynn> could a valid instance for Float exist?
16:33:43 <xplat> the report doesn't seem to explicitly specify any laws for Integral
16:34:48 <xnull> Integral is just a typeclass, is it not? 
16:34:57 <xnull> are typeclasses in the report? 
16:35:01 <xplat> yes
16:35:02 <xnull> specific ones, i mean
16:35:07 <xnull> oh, ok
16:35:13 <xplat> https://www.haskell.org/onlinereport/basic.html -- here
16:35:48 <xplat> of course that's 98, maybe 2010 added some laws
16:36:18 <alynn> http://hackage.haskell.org/package/base-4.7.0.2/docs/Prelude.html#t:Integral
16:36:29 <alynn> suggests a relationshpi between rem/quot and div/mod
16:36:40 <alynn> but no other laws
16:36:53 <Axman6> :t quotRem
16:36:54 <lambdabot> Integral a => a -> a -> (a, a)
16:36:56 <Axman6> :t divMod
16:36:57 <lambdabot> Integral a => a -> a -> (a, a)
16:37:14 <alynn> I mean, it looks like quotRem = divMod = \x y -> (x / y, 0) and toInteger with some kind of rounding would be valid
16:37:22 <alynn> then you'd be able to have Ratio Float :3
16:38:06 <xplat> i suspect there was meant to be a law 'fromInteger . toInteger = id'
16:38:34 <xplat> but nobody actually wrote it down
16:39:15 <alynn> xplat: that's broken by the Int instance though, no?
16:39:28 <alynn> or any of the instances which are just a finite subset of the integers
16:39:32 <dolio> No.
16:39:36 <xplat> alynn: no, Int breaks 'toInteger . fromInteger = id'
16:39:41 <alynn> oh, quite right
16:39:53 <alynn> hm
16:48:05 <mildfate> Is there a cleaner way to write something like "((`leq` x) . fromInteger)" or is this idiomatic?
16:49:38 <glguy> 07\y 07-> fromInteger y 07`leq` x
16:49:44 <barrucadu> I'd probably write it as \i -> fromInteger i `leq` x
16:49:48 * hackagebot fez-conf 1.0.2 - Simple functions for loading config files  http://hackage.haskell.org/package/fez-conf-1.0.2 (DinoMorelli)
16:56:54 <bazqux> Is it possible to rebind a 'variable'?
16:57:20 <bazqux> In a do block I mean.
16:57:30 <Stratege_> via <-, yes.
16:57:34 <barrucadu> Yes, just have another let
16:57:39 <xplat> bazqux: no.  you can bind a second variable with the same name though.
16:57:52 <Stratege_> because it desugars to lambdas you can just shadow the original name
16:58:06 <xplat> bazqux: it's not considered good style though
16:58:29 <bazqux> xplat: Yeah that's what I was trying to say, sorry.
16:59:31 <Iceland_jack> bazqux: The ‚Äòtraditional‚Äô version also exists in Haskell as mutable references (IORef, ...) but you almost never need it compared to languages like C
17:00:15 <monochrom> > do { x <- Just 1; x <- Just 2; return x }
17:00:17 <lambdabot>  Just 2
17:00:25 <monochrom> in fact, you can also:
17:00:31 <monochrom> > do { x <- Just 1; x <- Just (x+1); return x }
17:00:32 <lambdabot>  Just 2
17:01:03 <monochrom> but don't think "rebind". think "shadowing"
17:01:47 <monochrom> since you're really looking at: Just 1 >>= (\x -> Just (x+1) >>= (\x -> return x))
17:02:49 <bazqux> monochrom: Is there a nicer way of writing the second one to avoid the shadowing in the first place?
17:02:51 <monochrom> as for style, Oleg thinks it's good style, he does it all the time, and he opposes any attempt to take it away
17:03:19 <monochrom> yes, always use fresh variable names
17:03:36 <monochrom> Just 1 >>= (\x -> Just (x+1) >>= (\y -> return y))
17:04:17 <bazqux> Okay.
17:06:14 <bob_twinkles> b/ 2
17:07:00 <hpc> getting rid of shadowing in that case complicates do-notation anyway
17:07:30 <hpc> "do notation can be trivially translated in terms of (>>=), except that this really specific stuff about variable names"
17:08:14 <hpc> or you apply it everywhere, and now people can't write queries like \id -> query "select where blahblah and id=?" [id]
17:08:25 <hpc> or any number of things
17:08:35 <hpc> no rebinding (*)
17:08:37 <hpc> @src on
17:08:37 <lambdabot> (*) `on` f = \x y -> f x * f y
17:08:45 <bazqux> I think I was looking for a monadic compose. Is that all >>= is?
17:08:53 <hpc> bazqux: (>=>)
17:08:57 <hpc> :t (>=>)
17:08:58 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
17:09:58 <bazqux> hpc: Ah thanks.
17:10:35 <hpc> in any event, i agree with oleg about it being good style
17:10:42 <hpc> not to be used everywhere, but it has its place
17:11:11 <dpwright> I am just brushing off a blog post I've been writing about getting up and running with OpenGL using the gl package (https://hackage.haskell.org/package/gl)
17:11:31 <hpc> a lot like empty branches, to specifically call out that nothing is being done
17:12:03 <dpwright> I wanted to put in a (brief!) sentence or two about the differences between "gl" and "OpenGL"/"OpenGLRaw"
17:12:23 <gfixler> dpwright: I'm quite interested
17:12:38 <dpwright> ...but I don't know what they are :-P
17:12:46 <dpwright> I gather that "gl" is more complete, at least than "OpenGL"
17:13:02 <dpwright> and obviously it's lower-level and gives you basically direct access to the C API
17:13:15 <dpwright> but I was under the impression that that was the point in "OpenGLRaw" as well
17:13:43 <dpwright> so I am a little confused about the merits of gl vs OpenGLRaw, and vice versa
17:14:22 <dpwright> gfixler: I'll be looking for proof readers within the next couple of days if you'd like to help me out ;-)
17:15:42 <dpwright> is there anybody here who can enlighten me on the differences, and also whether they are reconcilable and might conceivably be merged into a single package some day or whether they are fundamentally different approches?
17:16:05 <gfixler> dpwright: sure :)
17:18:18 <xplat> dpwright: my mind just drifted along after your comment until i had a bit of a daydream about travelling to 1990.  "this is a supercomputer.  in my time we have many millions like it.  they are mainly used to draw fancy buttons, window borders and sliding menus that people barely notice once they get used to them."
17:19:48 <dpwright> xplat: ...I'm not sure I follow?
17:19:50 <barrucadu> This is my supercomputer. There are many like it, but this one is mine.
17:21:03 <dolio> dpwright: Someone got annoyed with aspects of opengl/openglraw, and made gl.
17:21:28 <xplat> dpwright: well, i started thinking about shader languages, then i thought about GPU computing and how GPUs are very much like supercomputers before the 'beowulf cluster' era hit ...
17:21:45 <monochrom> we use those millions of supercomputers for phone calls
17:22:26 <nocturne777> I have this data type: "newtype Prob a = Prob { getProb :: [(a,Rational)] } deriving (Show)"
17:22:27 <dpwright> dolio: Yeah, I've gathered that, and I've seen ekmett link to https://github.com/haskell-opengl/OpenGL/issues/64 and similar issues before
17:22:35 <levi> Is gl the new one that ekmett put together?
17:22:42 <xplat> yeah
17:22:46 <dolio> I don't know much about the packages, but from what I've heard, the annoyance was that opengl(raw) tries to abstract over certain things, but then doesn't allow you to violate the abstractions, but you can't do everything that opengl can do without violating their abstractions.
17:22:59 <dpwright> I'm interested to know which aspects specifically... aha
17:23:00 <xplat> gl is autogenerated from machine-readable API documentation
17:23:28 <dolio> And yes, gl is auto-generated, so it has more coverage of the actual spec.
17:23:31 <dpwright> so, op
17:23:33 <dpwright> oops
17:24:05 <nocturne777> how can I tell the compiler that type "a" is an instance of Eq given that adding type constraints to data types is bad
17:24:05 <dpwright> openglraw isn't actually *quite* as raw as gl
17:24:09 <nocturne777> ?
17:24:42 <Rotaerk> nocturne777, add it to the functions that use Probs
17:24:57 <Rotaerk> foo :: Eq a => Prob a -> ...
17:25:05 <levi> He had a big rant about his justification for doing gl, which was that the other packages tried to hide things so he couldn't access low-level calls that he needed to.
17:25:09 <dpwright> so there is a sort of difference in philosophy there -- absolute raw coverage of gl vs introducing some layer of abstraction
17:25:36 <dpwright> levi: Do you know where that rant took place?  I would be interested in reading it.
17:26:12 <levi> I'll look for it in a sec.
17:26:19 <dpwright> thanks :-)
17:27:32 <levi> My takeaway from it is that if you're going to write an abstraction, you should also provide lower level calls via an "Internals" module in case someone needs to extend or work around your abstraction.
17:28:10 <levi> https://www.reddit.com/r/haskell/comments/2uoton/edward_kmett_encapsulation_vs_code_reuse/
17:29:36 <jmcarthur> ... that humbling moment when you realize that the reason your code was so fast is not because of your awesome optimization skills but because you introduced a bug.
17:30:35 <dpwright> levi: Excellent, thanks -- will take a look at that
17:30:58 <dolio> jmcarthur: Getting the wrong answer is a time-honored optimization technique.
17:31:16 <Rotaerk> I think a lot of people who praise encapsulation miss the point of it
17:32:13 <monochrom> does encapsulation equal abstraction?
17:32:52 <Rotaerk> no
17:33:23 <Rotaerk> but encapsulation is one of the popular tenets of object oriented programming
17:33:27 <Rotaerk> and so it must be good!
17:34:07 <Rotaerk> if you're given an interface, and you need to implement it with an object, then that object encapsulates all the details behind the implementation, and the user of the interface need not know anything about them
17:34:41 <jmcarthur> Contrived encapsulation and conflation of it with abstraction is an unfortunately common thing which leads many people to believe that abstraction is rarely better than just another layer or level of indirection to understand.
17:36:13 <jmcarthur> I do think that there are cases when encapsulation without even a back door makes sense, but it's hard to get to that point. At minimum, the abstraction must have zero overhead and lose no power.
17:36:15 <Rotaerk> it's an entirely different scenario when you're defining your own API, as opposed to implementing a given interface... in that scenario you don't want to hide things from your public "interface"
17:38:09 <funfunctor> how does one usually write:   for (int tn = 0; tn < 8; tn++) for (int arfcn = 0; arfcn < mNumARFCNs; arfcn++) mFillerModulus[arfcn][tn] = 26; in more idiomatic Haskell?
17:38:43 <pingu> funfunctor: well, let's start with haskell for starters huh? ;)
17:38:48 <jmcarthur> funfunctor: hard to say without more context
17:39:23 <pingu> funfunctor: sounds like a fold, though.
17:39:24 <jmcarthur> funfunctor: must the result be an array? what will you use the array for?
17:39:28 <funfunctor> well map works for one dim
17:39:44 <funfunctor> oh the array is used later for a lookup
17:39:50 <jmcarthur> funfunctor: is a list of lists acceptable? note that for many purposes a lists are *not* idiomatic
17:39:57 <funfunctor> so its filling the arrays for later
17:40:01 <Cale> funfunctor: This reminds me of a Simon Marlow post... one sec :)
17:40:16 <Cale> (I will help you rewrite it, but this was funny...)
17:40:21 <jmcarthur> funfunctor: so you are definining a lookup table?
17:40:34 <jmcarthur> funfunctor: it will be initialized once and then never modified?
17:40:43 <Rotaerk> if it's all 26's that's pointless
17:40:57 <jmcarthur> *defining
17:41:11 <funfunctor> jmcarthur: i'm looking to translate the functionally into Haskell then probably rewrite it once my mind isn't stuck between C++/Haskell/whatever-is-this-code-doing..
17:41:23 <jmcarthur> funfunctor: but what *is* the functionality?
17:41:31 <funfunctor> 1sec
17:41:37 * funfunctor is reading also..
17:41:46 <funfunctor> seems read only
17:42:04 <jmcarthur> surely it's not merely initialized to 26 at every index though, right?
17:42:07 <monochrom> it is better to state and solve the problem afresh than translating some other code
17:42:50 <funfunctor> jmcarthur: it is, line 84 http://lpaste.net/128216#line84
17:43:05 <Cale> https://mail.haskell.org/pipermail/haskell-cafe/2004-March/005939.html
17:43:09 <Cale> There it is :D
17:43:45 <jmcarthur> funfunctor: it looks like the code modifies it elsewhere
17:43:55 <monochrom> interesting layout
17:44:08 <funfunctor> Cale: lol
17:44:15 <jmcarthur> funfunctor: this looks sufficiently different from idiomatic haskell style as to be something you *don't* want to port from
17:44:23 <monochrom> this is what you get when someone really knows the layout rules
17:44:24 <jmcarthur> funfunctor: at least if idiomatic style is your goal
17:44:42 <Cale> monochrom: I'm not even sure that I like that layout :)
17:44:53 <lpaste> mildfate revised ‚ÄúNo title‚Äù: ‚Äúwth is going on‚Äù at http://lpaste.net/2786483530769629184
17:45:05 <funfunctor> jmcarthur: yea, I was just going though my cycle of translate best I can, learn what I am doing along the way, throw it away and rewrite it my own way
17:45:07 <Cale> But yeah, some people like to not indent the bracket-style functions
17:45:15 <mildfate> thanks lpaste, soooo, what is going on in this?
17:45:36 <funfunctor> jmcarthur: its really just so I can get my head around it
17:45:41 <monochrom> Cale, this is basically analogous to tail-call optimization
17:45:46 <mildfate> http://lpaste.net/2786483530769629184, "if I run if fromInteger 100000003 `leq` 100000000.1 then (100000003,100000007) else (99999999,100000003)" it produces the right answer
17:45:49 <Cale> monochrom: haha
17:45:53 <mildfate> but if I call shrink, it doesn't!
17:47:38 <Cale> mildfate: Try fromInteger 100000003 `leq` (100000000.1 :: Float)
17:48:05 <mildfate> Cale: whaaaaatt
17:48:10 <mildfate> why is that True
17:48:14 <Cale> They're being rounded to the same thing
17:48:19 <Cale> because Float is small
17:48:21 <Cale> Use Double
17:48:42 <mildfate> is Float smaller than 100000000.1?
17:48:48 <dolio> Cale: It probably looks better there than indenting would.
17:48:48 <Cale> There's almost never a good reason to use Float unless you *really* know that you need the lack of precision. It's slower than Double.
17:49:02 <Cale> > fromInteger 100000003 :: Float
17:49:04 <lambdabot>  1.0e8
17:49:08 <dolio> You have to be really sure you don't want to do anything after the nested scope, though.
17:49:08 <EvanR> or if youre using opengl
17:49:08 <funfunctor> jmcarthur: looks like they are pasted around in a very stateful way (due to OO) perhaps some GADT is better here?
17:49:10 <Cale> > 100000000.1 :: Float
17:49:11 <lambdabot>  1.0e8
17:49:24 <Cale> > decodeFloat (100000000.1 :: Float)
17:49:25 <lambdabot>  (12500000,3)
17:49:34 <Cale> > decodeFloat (100000003 :: Float)
17:49:35 <lambdabot>  (12500000,3)
17:49:44 <Cale> See? Exactly the same
17:49:48 <Cale> > decodeFloat (100000003 :: Double)
17:49:50 <lambdabot>  (6710886601326592,-26)
17:49:51 <jmcarthur> funfunctor: i am not even attempting to understand this code :)
17:49:59 <Cale> > decodeFloat (100000000.1 :: Double)
17:50:01 <lambdabot>  (6710886406710886,-26)
17:50:05 <Cale> different
17:50:10 <jmcarthur> funfunctor: though i will say i don't see what GADTs have to do with statefulness
17:50:39 <funfunctor> jmcarthur: well thats kind of the reason I reduced down the for-for loop so I can get started on figuring the rest out myself..
17:51:02 <funfunctor> I don't really expect anyone to demangle C++ for me ;)
17:51:10 <mildfate> Cale: What is decodeFloat?
17:51:15 <jmcarthur> funfunctor: what kind of data structure do you want the result to be?
17:51:35 <Cale> mildfate: It shows the mantissa and exponent offset used to represent the floating point number.
17:51:40 <monochrom> Float is too small, really. Float was popular when memory was scarce, 80 years ago.
17:51:48 <mildfate> Cale: That's sweet
17:52:44 <EvanR> 32-bit float is a common audio sample format, raw audio takes up half the space
17:52:52 <EvanR> of double
17:53:09 <EvanR> the precision is not a problem for audio computations
17:53:30 <monochrom> I forgot the audio case, oops.
17:54:08 <funfunctor> jmcarthur: perhaps something like this? http://lpaste.net/128218
17:54:16 <Cale> Of course, you don't really lose anything using integer arithmetic to store audio samples, but it can be useful if you're processing the audio.
17:54:26 <EvanR> yeah, DSP
17:54:31 <jmcarthur> funfunctor: so a list if lists? sure
17:55:02 <funfunctor> jmcarthur: seems like a reasonable starting point right?
17:55:15 <jmcarthur> funfunctor:   replicate mNumARFCNs (replicate 8 26)
17:55:35 <funfunctor> :t replicate
17:55:36 <lambdabot> Int -> a -> [a]
17:55:43 <jmcarthur> > replicate 10 "foo"
17:55:44 <lambdabot>  ["foo","foo","foo","foo","foo","foo","foo","foo","foo","foo"]
17:55:52 <funfunctor> hehe, yep thanks
17:56:00 <exio4> funfunctor: what are you supposed to do with that array? 
17:56:54 <funfunctor> exio4: do lookups for different timeslots or something.. still trying to understand the code..
17:57:44 <dpwright> levi: Just watched the video -- thanks, that's exactly what I was looking for.
17:58:03 <Jervac> ./join clojure
18:06:14 <Greezler> is there a shorter way to assign a variable in ghci other than x <- return someData ?
18:06:39 <dolio> let x = someData
18:07:10 <Greezler> ah I forgot about the let
18:07:12 <Greezler> thanks
18:07:28 <tongcx> hi, can anyone explain the last example in http://stackoverflow.com/questions/21170493/when-are-higher-kinded-types-useful? The one with Alg, Fix
18:07:36 <monochrom> may or may not be really shorter :)
18:07:49 <tongcx> This example totally blowed my head
18:08:24 <dolio> monochrom: Pretty sure 'let =' is shorter than '<- return'.
18:08:30 <dolio> I actually thought about it first. :)
18:08:57 <monochrom> I now agree!
18:12:38 <johnw> bitraten: hi
18:14:13 <bitraten> johnw: hey :)
18:14:33 <johnw> bitraten: you can look at how git-monitor does it
18:14:52 <johnw> gitlib has no builtin notion of a "working tree", since it was created to interact with repositories
18:15:13 <johnw> so scanning and comparison of the working tree with a given Tree, for example, is something that must be written, and which git-monitor does
18:15:23 <johnw> such functionality should at some point make it into gitlib, but it wasn't pressing
18:15:53 <josephjnk> What‚Äôs the best framework for a web developer who‚Äôs new to Haskell, coming from node js? I‚Äôm trying to learn yesod, since it seems the most active and well-documented, but it feels pretty heavy and rails-like. I was hoping to find something more minimalist that just plugs my code into a performant webserver.
18:16:05 <bitraten> thanks!
18:17:37 <benzrf> josephjnk: scotty perhaps
18:17:39 <josephjnk> I should add that I‚Äôm more interested in the API development aspect than in building the frontend web app
18:18:06 <bitraten> josephjnk: have a look at servant
18:18:22 <Greezler> have you looked at the frameworks list on the haskell wiki?
18:18:40 <Greezler> https://wiki.haskell.org/Web/Frameworks - looks like happstack and snap are both lighter than yesod
18:18:45 <bitraten> https://haskell-servant.github.io/
18:19:25 <Greezler> actually looks like bitraten is right, servant specifically mentions being useful for making APIs
18:19:44 <josephjnk> benzrf Scotty looked good but I wasn‚Äôt seeing many beginner walkthroughs for it
18:19:59 <josephjnk> I looked at the list on the wiki but I was having trouble comparing them
18:20:32 <josephjnk> servant looks promising
18:20:35 <josephjnk> thanks!
18:22:44 <benzrf> np i guess
18:22:51 <benzrf> oh i see you werent thanking me :P
18:23:28 <josephjnk> It was meant as a thanks to all three of you :P
18:24:11 <josephjnk> I‚Äôm having a hard time making the jump from learn you a haskell to actual development, and I figured that finding a framework as similar as possible to what I‚Äôm used to might make it easier
18:24:25 <benzrf> l-learn you a haskell?
18:24:28 <benzrf> why did you go and read that
18:24:49 <Greezler> seems pretty heavily recommended
18:24:55 <josephjnk> other than it being the most recommended resource on every beginner site I found?
18:24:55 <Greezler> I'm a noob as well
18:24:58 <josephjnk> no real reason
18:25:07 <Greezler> do you recommend something else, benzrf ?
18:25:20 <benzrf> Greezler: https://github.com/bitemyapp/learnhaskell
18:25:29 <benzrf> lyah is pedagogically unsound ;)
18:25:53 <benzrf> the problem is that
18:26:27 <benzrf> 1. historically, most resources for learning haskell for 'normal programmers' belonged to a certain class of flawed things
18:26:32 <benzrf> 2. lyah is pretty good in this class
18:26:37 <benzrf> 3. lyah is seen as Best Choice
18:27:49 <Greezler> so what's the actual issue with LYAH?
18:28:26 <EvanR> whatever it is, it needs to be documented somewhere besides this irc channel
18:28:33 <cstrahan_> fwiw, i found LYAH to be a great introduction.
18:28:38 <EvanR> if not already
18:29:01 <reem_> my biggest gripe, personally, is the lack of exercises
18:29:08 <funfunctor> ok what about http://lpaste.net/128219 to kick off some dialog on how this sort of thing is better done
18:29:16 <reem_> it makes it very hard to actually learn vs. just reading and feeling like you understand
18:30:12 <cstrahan_> i found something about the writing style of Real World Haskell very quickly turned my brain off, despite the quality of the underlying content.
18:30:26 <Greezler> reem: I agree, that's a big problem.  I've been going along with the book open in one window and vim open in another and writing out each example I see, but even that isn't really exercising
18:31:36 <funfunctor> Greezler: I personally think the only way you really learn is to dream up a project that /you/ find exciting to keep you motivated. Because the key is focus which stems from motivation
18:31:57 <funfunctor> i.e. make something and get stuck lots
18:32:44 <Greezler> I agree, but the thing is that as someone who only has a tiny bit of Ocaml experience, I would find myself having to google every single line of haskell code before writing it
18:33:01 <lpaste> nocturne777 pasted ‚ÄúDefining functions in monad definition‚Äù at http://lpaste.net/128220
18:33:14 <funfunctor> Greezler: I think that is part of it. Hoogle may help you
18:33:25 <josephjnk> funfunctor: that‚Äôs how I‚Äôve normally learned new languages and frameworks, but it feels like there‚Äôs more of a barrier to entry for practical development in haskell than for other environments I‚Äôve worked in
18:33:45 <lpaste> nocturne777 revised ‚ÄúDefining functions in monad definition‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/128220
18:33:49 <josephjnk> node js makes my life shitty a lot of the time, but when I first tried it out I had a server running in 10 minutes
18:33:55 <funfunctor> Greezler: after a few days of googling every-line your only be googling every 5th line
18:34:40 <funfunctor> writing software today isn't about it working in 10min
18:34:47 <funfunctor> systems are getting too complex
18:35:07 <nocturne777> the compiler is complaining about the code because "a" type is not known and I am using 'compare' and '==
18:35:09 <dolio> If you already know OCaml, you can read the Gentle Introduction.
18:35:09 <nocturne777> '
18:35:16 <funfunctor> learning to deal with complexity is the core of being a good programmer imho
18:35:51 <josephjnk> writing isn‚Äôt about getting done fast and easy, that‚Äôs why I‚Äôm looking for a new environment
18:35:54 <nocturne777> how can get rid of these errors while still retaining a generic monad definition ?
18:36:25 <josephjnk> but for learning something new, it‚Äôs really beneficial to be able to get a minimal environment working and then play with and modify it immediately
18:37:03 <Greezler> I feel like some technologies feel like they are fighting against you, others feel like they are pushing you forward
18:37:15 <nocturne777> josephjnk: I was able to get the environment working very quickly
18:37:17 <Greezler> Python is the obvious example of the latter
18:37:25 <nocturne777> just install "Haskell Platform"
18:37:41 <nocturne777> And there are a lot of good books out there
18:38:26 <funfunctor> Greezler: blame nature. You have two choices, fight complexity to gain higher order or work with randomness somehow, possibly GA's
18:39:15 <nocturne777> Rotaerk: my purpose is to keep the definition of the monad as generic as possible
18:39:39 <nocturne777> generic for the first element of the tuple, that is
18:40:40 <Greezler> funfunctor: and so here I am slowly getting my feet wet with Haskell
18:40:55 <monochrom> nocturne777: the type of >>=, customized to Prob, is "Prob a -> (a -> Prob b) -> Prob b". however, if you use sorting, then you make it "Ord b => Prob a -> (a -> Prob b) -> Prob b", which is a different type.
18:42:00 <monochrom> the conclusion is either give up sorting and grouping, or give up instance Monad.
18:42:02 <funfunctor> Greezler: my advice is keep your eye on type-signatures, make it feel natural to read things like :: Ord a => a -> a -> Bool and so on
18:42:19 <funfunctor> @hoogle Ord a => a -> a -> Bool
18:42:21 <lambdabot> Prelude (<) :: Ord a => a -> a -> Bool
18:42:22 <lambdabot> Data.Ord (<) :: Ord a => a -> a -> Bool
18:42:22 <lambdabot> Prelude (<=) :: Ord a => a -> a -> Bool
18:43:20 <nocturne777> monochrom: I think doing the sorting and grouping outside of the Monad instance is a good idea
18:45:04 <monochrom> a happy consequence of "everyone is different": the same mechanism, e.g. static typing, fights some people at every inch but pushes some other people forward
18:45:12 <Greezler> That's what I've been trying to do, amongst other things.  To paraphrase something I read, every haskell program is like its own correctness proof
18:45:28 <Greezler> proof of correctness, rather
18:45:38 <EvanR> would be nice
18:45:41 <monochrom> I am one of those pushed forward (in the case of static typing). I also know some other people impeded.
18:46:08 <EvanR> Greezler: theres a lot of holes in haskells "logic" that are possible so you still need to be careful
18:46:11 <monochrom> my conclusion: good for me. of course I enjoy every competitive advantage.
18:46:29 <EvanR> let x = x in x
18:48:50 <nocturne777> monochrom: I actually do that sorting and grouping to reduce smth like "[(False,1 % 40),(False,9 % 40),(False,1 % 40),(False,9 % 40),   (False,1 % 40),(False,9 % 40),(False,1 % 40),(True,9 % 40)]" to "[[(False,  31 %40)], [True, 9%40]]"     
18:49:23 <monochrom> I agree that it is important to keep things efficient
18:49:47 <nocturne777> If I was not dealing with a tupple, I would have considered making the type instance of Monoid and use mappend in the definition
18:50:27 <Welkin> I had never thought much about type systems before haskell
18:51:02 <Welkin> I always felt quite lost in langugaes like python, which have one type (not really)
18:51:11 <nocturne777> I wanted to learn haskell because of scalaz. 
18:51:21 <nocturne777> now I do not want to go back to scala
18:51:37 <EvanR> python has classes, i think
18:51:43 <Welkin> after studying haskell, I felt like I had a much better set of tools for building software
18:51:53 <bob_twinkles> python does indeed have classes
18:51:57 <nocturne777> of course, I am still learning haskell
18:52:50 <nocturne777> some people say that multiparadigm programming may actually be error prone
18:53:12 <EvanR> programming is error prone
18:53:25 <gcganley> People are error prone
18:53:35 <nocturne777> "that's why haskell's purity on functional programming maybe a good thing" is what they say
18:53:44 <wagle> anyone know what happened to the google group "HoTT Amateurs"?
18:54:08 <geekosaur> "If builders built buildings the way programmers write programs, the first woodpecker to come along would destroy civilization."
18:54:20 <EvanR> nocturne777: well, you can do oop with haskell, in the sense of interfaces to software components
18:54:28 <ProofTechnique> wagle: Probably sold the group to spammers :)
18:54:36 <nocturne777> EvanR: yes, I am aware of it :)
18:54:57 <EvanR> so in that sense haskell isnt purely functional ;)
18:55:11 <EvanR> and that kind of program style might be good for some cases
18:55:20 <Welkin> the purity refers to mutations
18:55:21 <monochrom> dinosaurs went extinct because they didn't have static typing (famous last words)
18:55:21 <nocturne777> I mostly meant it in the sense that it does not let you mutate stuff
18:55:37 <gcganley> EvanR: its all in degrees, like agda and coq are waaay off the deep end of purity
18:55:39 <EvanR> Welkin: mutations isnt the only issue
18:55:48 <ProofTechnique> wagle: In seriousness, it was moved to https://groups.google.com/forum/#!forum/hott-cafe
18:56:04 <wagle> ah, thanks
18:56:25 <wagle> all i had was the old url, and google wasnt sayin
18:56:27 <EvanR> Welkin: really you want your expressions to be referentially transparent
18:56:55 <dibblego> nocturne777: as you have learned, scala is a hoax
18:57:16 <Welkin> oh, google groups uses javascript for rendering? wtf?
18:57:21 <gcganley> dibblego: how is scala a hoax?
18:57:30 <Welkin> hash bangs in URLs is a long-gone fad...
18:57:39 <dibblego> gcganley: this question regularly comes up in here, but it is off-topic. We are over in #scalaz perhaps?
18:58:21 <nocturne777> dibblego: my main impression of scala is that it's a quite poorly designed language 
18:58:48 <Welkin> "it's the best of everything! A language to please everyone, yet no one!"
18:59:06 <nocturne777> the language tries to copy stuff from other languages but things become unnecesarily complex.
18:59:12 <wagle> .1 of all people disagree
18:59:17 <wagle> oh wait
18:59:20 <wagle> nm
18:59:29 <dibblego> nocturne777: I recall we have probably discussed this already in #scalaz. Anyway, yes, your feelings are common, but be aware that it can cause all sorts of personal problems by speaking out. We are all over in #scalaz and we know what's up.
18:59:31 <gcganley> nocturne777: I've heard monad transformers suck in scala
19:00:03 <Welkin> personal problems?
19:00:05 <dibblego> gcganley: no more than any other thing, because the type-inference sucks, however, monads (just monads) suck, in that you always have to make one of a number of huge sacrifices
19:00:18 <Welkin> oh, that's right, programming languages are like religions
19:00:45 <dmj`> or religions are like programming languages
19:00:46 <dibblego> Welkin: there are a group of people who become irrational and hostile if you point out the superiority of haskell. This really is off-topic. It's fine in #scalaz, but not here. 
19:00:52 <Welkin> hm, it reminds me of the pythagoreans
19:01:05 <Welkin> and other mathematics cults
19:01:46 <Welkin> well, no one likes being toldthat their baby is ugly
19:02:21 <monochrom> I become irrational if you point out that I am the square root of 2.
19:03:11 <ProofTechnique> Transcend and get your well-deserved slice of the œÄ
19:04:14 <monochrom> to make me rational, put me in a Double.
19:04:39 <dibblego> you jest, but Ö anyway
19:04:49 <wagle> what would i look for to find out why haskell still dodesnt permit function definitions of the form "foo x x = ..."
19:04:54 * hackagebot lambdabot-core 5.0.1 - Lambdabot core functionality  http://hackage.haskell.org/package/lambdabot-core-5.0.1 (BertramFelgenhauer)
19:05:06 <dibblego> wagle: you mean naming two different variables with the same name (x)?
19:05:18 <enthropy> wagle: it does that for  instance Foo x x
19:05:33 <wagle> i mean the two values must match
19:06:04 <wagle> might be hard to determine whether the patterns for all the defs are total
19:06:28 <monochrom> wagle: I don't understand what kind of "why" you mean. but there are only two possibilities. one is answered by "see the Haskell 2010 Report". the other is answered by "look up linear patterns vs non-linear patterns"
19:07:09 <wagle> the keyword "linear patterns" probably is what I was looking for
19:07:40 <monochrom> actually there is a third possibility. it is answered by "I bribed the Haskell committee to ban this"
19:08:24 <wagle> haha..  it was banned in the original (?) haskell report, the justification was a little thin
19:09:39 <wagle> could be "which equality do you mean?"
19:09:54 <enthropy> wagle: well you can write "foo x x' | x == x' = ..." or "foo x ((==) x -> True) = ..."
19:09:54 * hackagebot lambdabot-haskell-plugins 5.0.1 - Lambdabot Haskell plugins  http://hackage.haskell.org/package/lambdabot-haskell-plugins-5.0.1 (BertramFelgenhauer)
19:09:57 * hackagebot lambdabot-irc-plugins 5.0.1 - IRC plugins for lambdabot.  http://hackage.haskell.org/package/lambdabot-irc-plugins-5.0.1 (BertramFelgenhauer)
19:09:58 * hackagebot lambdabot-misc-plugins 5.0.1 - Lambdabot miscellaneous plugins  http://hackage.haskell.org/package/lambdabot-misc-plugins-5.0.1 (BertramFelgenhauer)
19:10:01 * hackagebot lambdabot-novelty-plugins 5.0.1 - Novelty plugins for Lambdabot  http://hackage.haskell.org/package/lambdabot-novelty-plugins-5.0.1 (BertramFelgenhauer)
19:10:03 * hackagebot lambdabot-reference-plugins 5.0.1 - Lambdabot reference plugins.  http://hackage.haskell.org/package/lambdabot-reference-plugins-5.0.1 (BertramFelgenhauer)
19:10:13 <ProofTechnique> Wow
19:10:19 <enthropy> wagle: pattern matching with numeric literals uses (==)
19:11:12 <monochrom> what are novelty plugins? I hope they don't mean sex toys...
19:11:28 <Axman6> heh
19:11:39 <ProofTechnique> @quote monochrom
19:11:39 <lambdabot> monochrom says: Don't wrap your head around haskell. Immerse! Wrap haskell around your head.
19:11:47 <wagle> enthropy: yeah, the case thing is what i do..  i'm just designing YAPL and wanted the advanced pattern matching, and found myself wondering again why haskell still doesnt permit it
19:12:03 <ProofTechnique> @numberwang 15
19:12:03 <lambdabot> Unknown command, try @list
19:12:08 <ProofTechnique> Boo
19:12:24 <Axman6> that quote is excellent advice
19:12:52 <lpaste> nocturne777 revised ‚ÄúDefining functions in monad definition‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/128220
19:13:50 <nocturne777> I clicked private and it still pasted here
19:14:24 <dolio> I think private refers to whether it shows up on the list on lpaste.net.
19:14:30 <monochrom> probably because the initial version was public
19:14:47 <dolio> The announce is a separate dropdown.
19:15:05 * hackagebot lambdabot-social-plugins 5.0.1 - Social plugins for Lambdabot  http://hackage.haskell.org/package/lambdabot-social-plugins-5.0.1 (BertramFelgenhauer)
19:15:07 * hackagebot lambdabot-trusted 5.0.1 - Lambdabot trusted code.  http://hackage.haskell.org/package/lambdabot-trusted-5.0.1 (BertramFelgenhauer)
19:15:09 * hackagebot lambdabot 5.0.1 - Lambdabot is a development tool and advanced IRC bot  http://hackage.haskell.org/package/lambdabot-5.0.1 (BertramFelgenhauer)
19:15:11 * hackagebot record-gl 0.1.0.0 - Utilities for working with OpenGL's GLSL shading language and Nikita Volkov's "Record"s.  http://hackage.haskell.org/package/record-gl-0.1.0.0 (rabipelais)
19:20:40 <funfunctor> how can one manipulate one element in an list of lists but leave the rest alone? Something like [[Int]] -> Int -> [[Int]]
19:21:05 <HeladoDeBrownie> seems to me like a dropdown saying "unlisted" versus "listed" would be more consistent, and then a single "publish" button.
19:22:17 <pavonia> funfunctor: Which element?
19:22:46 <funfunctor> pavonia: oh good point, sorry, so [[Int]] -> Int -> Int -> [[Int] then
19:23:07 <wagle> foo lols e = map (remove e) lols  --- need the right names
19:23:29 <pavonia> funfunctor: It's still not clear what exactly that function should do
19:23:51 <HeladoDeBrownie> parametricity! do you speak it?
19:23:56 <alexclark> can someone help me convert seconds to UTCTime?
19:24:07 <alexclark> readTime defaultTimeLocale "%z" "1000000000z"
19:24:13 <funfunctor> pavonia: ok so, here on this line http://lpaste.net/128219#line40
19:24:28 <alexclark> this is what I'm trying now, but its not working because its obvious nonsense
19:25:17 <HeladoDeBrownie> alexclark, the question itself sounds ill-formed to me.
19:25:18 <alexclark> im really trying the figure out what is acceptible for the second argument
19:25:33 <alexclark> HeladoDeBrownie: fair.
19:25:46 <ProofTechnique> funfunctor: Radios?
19:26:01 <ProofTechnique> @hoogle readTime
19:26:04 <lambdabot> Data.Time.Format readTime :: ParseTime t => TimeLocale -> String -> String -> t
19:26:13 <ProofTechnique> @doc readTime
19:26:13 <lambdabot> readTime not available
19:26:46 <funfunctor> ProofTechnique: i'm working on a GSM stack in Haskell
19:27:01 <monochrom> funfunctor's function is better off typed as [[a]] -> Int -> Int -> a -> [[a]]. semantics: f xss i j x = (like xss but row i column j has x instead)
19:27:02 <funfunctor> ProofTechnique: replacing layer0 in openbts
19:27:48 <HeladoDeBrownie> monochrom, ah, replace an element in a matrix?
19:28:36 <EvanR> is there a way to format a float besides printf
19:28:43 <alexclark> ProofTechnique: in readTime, how can I find acceptable formats for the first String?
19:28:48 <funfunctor> monochrom: sorry what is happening there?
19:29:04 <pavonia> > let modifyNth n x' xs = let (p, q) = splitAt (n-1) xs in p ++ x' ++ tail q in modifyNth 3 'x' "abcdef"
19:29:05 <lambdabot>  Couldn't match expected type ‚Äò[GHC.Types.Char]‚Äô
19:29:05 <lambdabot>              with actual type ‚ÄòGHC.Types.Char‚Äô
19:29:16 <funfunctor> monochrom: the type-sig is actually setModulus :: PerTimeslot -> Int -> Int -> PerTimeslot
19:29:19 <ProofTechnique> alexclark: http://hackage.haskell.org/package/time-1.4.0.2/docs/Data-Time-Format.html#g:1
19:29:20 <monochrom> some people asked what you meant.
19:29:25 <pavonia> > let modifyNth n x' xs = let (p, q) = splitAt (n-1) xs in p ++ [x'] ++ tail q in modifyNth 3 'x' "abcdef"
19:29:26 <lambdabot>  "abxdef"
19:29:31 <ProofTechnique> Check the formatTime documentation for acceptable strings
19:29:45 <alexclark> no shit, thanks ProofTechnique!
19:29:53 <ProofTechnique> No problem
19:30:03 <ProofTechnique> For instance
19:30:16 <ProofTechnique> readTime defaultTimeLocale "%s" "140" :: UTCTime // 1970-01-01 00:02:20 UTC
19:30:39 <funfunctor> but yea, basically I want to replace a element in a matrix :: [[a]] yes
19:31:35 <pavonia> funfunctor: ^ There's a solution for a single list above
19:31:53 <funfunctor> pavonia: yep i'm just reading it and trying to understand it
19:32:50 <pavonia> > let modifyNth n x' xs = let (p, q) = splitAt (n-1) xs in p ++ [x'] ++ tail q in map (\i -> modifyNth i 'x' "abcdef") [0..7]
19:32:51 <lambdabot>  ["xbcdef","xbcdef","axcdef","abxdef","abcxef","abcdxf","abcdex","abcdefx*Exc...
19:33:27 <pavonia> Fails if n is out of range
19:34:58 <funfunctor> pavonia: yea I am just trying to see how it can work for [[a]]
19:35:59 <funfunctor> oh I guess I could compose it
19:36:28 <funfunctor> umm
19:37:10 <ProofTechnique> > let update m x (r,c) = take r m ++ [take c (m !! r) ++ [x] ++ drop (c + 1) (m !! r)] ++ drop (r + 1) m in update [[1, 2]] 3 (0, 1)
19:37:12 <lambdabot>  [[1,3]]
19:37:16 <ProofTechnique> Like that?
19:38:36 <funfunctor> ProofTechnique: (0,1) what is (r,c) here?
19:38:45 <ProofTechnique> (row, column)
19:38:52 <funfunctor> oh :p
19:40:52 <exio4> I would go with a  Map (Int,Int) a 
19:41:46 <funfunctor> ProofTechnique: its pretty close to what I need but it wont type-check in here http://lpaste.net/128219#line40
19:42:03 <ProofTechnique> Though Array also has (//), which does exactly this.
19:42:09 <funfunctor>     Couldn't match expected type `[[Integer]]' with actual type `PerTimeslot'
19:43:24 <ProofTechnique> funfunctor: What if you change pts to (fillerModulus pts)?
19:43:42 <funfunctor> oh woops!
19:44:30 <funfunctor> ProofTechnique: ok closer, one type error left     Couldn't match expected type `PerTimeslot' with actual type `[[Int]]'
19:45:05 <funfunctor> so now I need to have the record back with only one field updated
19:45:11 <ProofTechnique> Right!
19:45:52 <ProofTechnique> So that'll be pts {fillerModulus = update (fillerModulus pts) 26 (arfcn,timeslot)} or something like that.
19:45:58 <ProofTechnique> I forget what the right syntax is.
19:46:09 <funfunctor> yea I always forget it as well
19:46:23 <funfunctor> looks right though
19:46:51 <funfunctor> yep thats right, thx!
19:47:14 <funfunctor> do case stmt's in Haskell have fall-thoughs?
19:48:15 <dfeuer> Is the classic Fix type available from any common package? FPComplete Hoogle seems to find it only in the "regular" package, which I've never heard of.
19:49:17 <enthropy> funfunctor: case True of True -> print 'x'; _ -> print 'y' -- you're asking if this prints y?
19:49:48 <dfeuer> ARGH
19:49:51 <ProofTechnique> _ -> whatever always matches
19:50:31 <dfeuer> In fact, it's also defined in at least one other obscure package. And something equivalent called FixF appears in category-extras.
19:50:33 <funfunctor> enthropy: no, I mean something like switch (x) { case A: case B: f(); case C: g(); case D: case E: h(); }
19:50:51 <ProofTechnique> dfeuer: Control.Monad.Fix?
19:51:00 <funfunctor> enthropy: note how A and B fall though to f() and D and E fall though to h()
19:51:03 <dfeuer> ProofTechnique, I don't think it's there.
19:51:28 <funfunctor> _ -> is really the same thing as default or bottom
19:51:29 <dfeuer> ProofTechnique, nope, not there.
19:51:32 <ProofTechnique> Aww
19:52:07 <ProofTechnique> dfeuer: linear might have it
19:52:23 <dfeuer> There's a somewhat different version in Generics.Pointless.Functors
19:52:37 <ProofTechnique> Oh, wait, that's Monad.Compose
19:52:54 <dfeuer> ProofTechnique, that's hardly a sane place to pull such a thing from anyway, don't you think?
19:52:54 <ProofTechnique> http://hayoo.fh-wedel.de/?query=Fix
19:53:12 <dfeuer> Yet another copy in unification-fd.
19:53:27 <ProofTechnique> http://hackage.haskell.org/package/data-fix-0.0.1/docs/Data-Fix.html
19:53:38 <dfeuer> It seems like every bloody package rolls its own, and if you want to swap one for anether you need unsafeCoerce :-(
19:53:44 <dfeuer> *another
19:53:58 <enthropy> funfunctor: https://ghc.haskell.org/trac/ghc/ticket/3919 is not implemented
19:54:15 <ProofTechnique> Data.Fix looks pretty close
19:54:52 <dfeuer> Of course there's also Data.Functor.Foldable from recursion-schemes, that also makes its own.
19:55:18 <dfeuer> And yes, ProofTechnique, also data-fix.
19:55:40 <dfeuer> I think this all makes a good argument for putting this in a canonical place and getting everyone else to import from there.
19:56:19 <ProofTechnique> I find it unusual that they're incompatible
20:03:16 <dfeuer> ProofTechnique, I tried converting with coerce, but that doesn't seem to do it.
20:03:57 <dfeuer> (which doesn't really surprise me)
20:07:43 <funfunctor> enthropy: ta
20:09:22 <ronbrz> hey, does anyone know how to run the gloss examples? i ran "cabal install gloss-examples", and apparently should be able to run them from the command line, from my understanding. But that doesnt work. Do I need a cabal directory to my path or something? I'm running ubuntu 14.04
20:15:02 <ronbrz> heh, nevermind guys, i did just that and it worked, adding .cabal/bin
20:35:00 * hackagebot QuickCheck-GenT 0.1.4 - A GenT monad transformer for QuickCheck library.  http://hackage.haskell.org/package/QuickCheck-GenT-0.1.4 (NikitaVolkov)
20:40:00 * hackagebot comptrans 0.1.0.1 - Automatically converting ASTs into compositional data types  http://hackage.haskell.org/package/comptrans-0.1.0.1 (JamesKoppel)
20:45:00 * hackagebot comptrans 0.1.0.2 - Automatically converting ASTs into compositional data types  http://hackage.haskell.org/package/comptrans-0.1.0.2 (JamesKoppel)
20:45:02 * hackagebot comptrans 0.1.0.3 - Automatically converting ASTs into compositional data types  http://hackage.haskell.org/package/comptrans-0.1.0.3 (JamesKoppel)
20:45:04 * hackagebot comptrans 0.1.0.4 - Automatically converting ASTs into compositional data types  http://hackage.haskell.org/package/comptrans-0.1.0.4 (JamesKoppel)
20:58:58 <f|`-`|f> I wonder
20:59:32 <jle`> recursion-schemes sounds like a good home
20:59:34 <ProofTechnique> I sometimes do to
21:00:00 <ProofTechnique> *too
21:00:05 <jle`> Free is just Fix with a base case, so i wonder if it'd make sense for it to be in fix
21:00:32 <jle`> *it'd make sense for it to be on free
21:03:48 <Eiam_> Any feedback on why I'm seeing this? https://gist.github.com/anonymous/ae86250ef9d1c069badf 
21:06:16 <solatis> hmm am i correct that yesod-bin can be quite difficult to install globally?
21:06:34 <solatis> as in, i have no problems installing it in a sandbox, but it seems like global gives a lot of conflicts
21:06:42 <pavonia> Eiam_: Seems like you haven't installed the wreq package
21:07:02 <Eiam_> pavonia: fairly certain I have =( 
21:07:20 <Eiam_> but I can't seem to check cause cabal list is complaining about no sandbox but require sandbox is set
21:07:21 <dmj`> solatis: what would the difference be? Do you have a lot of other things installed globally?
21:07:30 <Eiam_> so im reading through all these github issues trying to figure that out
21:07:36 <solatis> dmj`: i suspect it might have something to do with the network package
21:07:38 <solatis> i am on windows
21:08:24 <solatis> and haskell-platform seems to be quite outdated :/
21:08:25 <Eiam_> cabal: 'require-sandbox' is set to True, but no sandbox is present.
21:08:30 <dmj`> solatis: network installs fine for me on windows
21:08:43 <dmj`> solatis: are you using mingw or cygwin?
21:08:56 <solatis> ehr, how do i find out?
21:09:05 <solatis> i installed haskell platform
21:09:05 <glguy> Eiam_: If you configured your cabal to require a sandbox you're going to need to use one
21:09:21 <glguy> If you installed wreq into a sandbox you'll need to use sandbox commands for your GHC to see it
21:09:41 <dmj`> solatis: Those are unix-emulating shells, you're probably not, haskell platform comes with an outdated version of mingw I believe
21:09:48 <solatis> yeah
21:10:00 <solatis> i heard there's an alternative to haskell-platform for windows users now, though/
21:10:01 * hackagebot compstrat 0.1.0.0 - Strategy combinators for compositional data types  http://hackage.haskell.org/package/compstrat-0.1.0.0 (JamesKoppel)
21:10:03 * hackagebot compstrat 0.1.0.1 - Strategy combinators for compositional data types  http://hackage.haskell.org/package/compstrat-0.1.0.1 (JamesKoppel)
21:10:10 <solatis> what was it called
21:10:12 <dmj`> solatis: why not use unix?
21:10:25 <solatis> dmj`: i am targeting windows users :/
21:10:48 <Eiam_> glguy: I didn't configure anything in particular. Guess I've just ended up here. I deleted my ~/.cabal and now things seem to be more on track.. updating cabal now... trying to force it to install wreq..
21:10:57 <dmj`> solatis: Isn't this a web app?
21:11:24 <solatis> dmj`: i am using a web app to get around having to deal with building a GUI
21:12:28 <solatis> anyway, guess i'll just install yesod-bin in my sandbox
21:12:31 <dmj`> solatis: That sounds good, are you going to host this site on the public internet?
21:12:39 <solatis> dmj`: no, 127.0.0.1
21:13:21 <solatis> anyway, it's the only way to make enduser-facing applications on windows for haskell somewhat doable :)
21:13:34 <solatis> i don't want to go down the rabbit hole of Qt / Gtk+ bindings for haskell
21:16:32 <solatis> anyway, i think i'm going to uninstall the haskell platform
21:16:40 <solatis> i understand it's quite unmaintained at the moment, eh?
21:17:14 <solatis> https://github.com/fpco/minghc seems like a better alternative
21:18:05 <platz_> hrm, i found how to makeLenses in ghci with a data decl inline, but is there a way to makeLenses for data imported from an existing lib?
21:18:45 <platz_> i get a error are.net/pt114/haskell-vs-f-vs-scala
21:18:53 <platz_> er, no
21:19:07 <platz_> "No instance for (Show DecsQ) arising from a use of ‚Äòprint‚Äô"
21:19:40 <glguy> You can just do: makeLenses ''AnyType
21:19:43 <glguy> doesn't have to be locally defined
21:20:02 * hackagebot HStringTemplate 0.8.3 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.8.3 (SterlingClover)
21:20:52 <glguy> 07$(stringE 07. show 07=<< makeLenses ''Rec)
21:21:07 <glguy> handy way to peek at stuff in Template Haskell
21:27:35 <pingu> glguy: That's very neat.
21:28:01 <pingu> I'd go as far as to say it deserves to be in the TH documentation
21:30:32 <platz_> http://lpaste.net/128248
21:32:51 <glguy> platz_: The first one because of the data declaration it seemed to know it was doing declarations
21:32:58 <glguy> but the second one thought it was in an expression context
21:33:05 <glguy> where you'd need an ExpQ not a DecsQ
21:33:14 <glguy> so it figured you just meant to print it as though you'd type 100
21:33:25 <solatis> hmmm is there a command to tell cabal to deinstall every package? 
21:33:35 <solatis> probably deleting $HOME/.ghc ?
21:34:55 <platz_> glguy: hah, so putting a "dummy" data decl before making the lenses works then
21:35:31 <glguy> so it seems (that's news to me, actually)
21:41:05 <rreno17> Hey everyone. I'm an undergrad math student who is just getting into the language. I wanted to drop by and say hi.
21:41:23 <ProofTechnique> Hi
21:42:01 <ProofTechnique> solatis: rm -rf ~/.ghc then rm -rf ~/.cabal should do it.
21:43:55 <ElderFain> can someone explain the reason that wreq wants to use &?  If most Haskell involves <applyto> <thing> and it reverse it to <thing> <applyto> that seems.. unnecessarily confusing?
21:44:23 <EvanR> yep
21:45:11 <ElderFain> was that a 'yes, its confusing' or for someone else?
21:46:40 <EvanR> yes its confusing
21:46:59 <EvanR> do you have to use &?
21:46:59 <ElderFain> okay.. is there some compelling reason they've done this? 
21:47:25 <ElderFain> the examples use it, but when they explain it, it seems superfluous and I'd prefer to not make code more confusing 
21:47:44 <ElderFain> but, as a newcomer, i hardly have a good vantage point to make good decisions
21:48:17 <glguy> You don't have to use it. Some people who love to use operators will use lens to simulate: object.field.field notation
21:48:43 <ElderFain> well, i like that particular notation
21:48:44 <glguy> object^.field.field and object&field.field .~ newvalue
21:48:49 <ElderFain> but I don't see what & has got to do iwht it
21:49:22 <glguy> object07^.field07.field and object07&field07.field 07.~ newvalue
21:49:24 <ElderFain> okay the first one is.. getting a field.field
21:49:30 <glguy> yeah
21:49:31 <ProofTechnique> Although the query params example is pretty convincing
21:49:33 <ElderFain> the second is.. setting a value on that field
21:49:40 <glguy> right
21:50:00 <ElderFain> hmm 
21:50:08 <ElderFain> trying to deconstruct that without the &
21:50:13 <ElderFain> lemme go read on .~ right quick
21:50:33 <glguy> If you don't like it you can write: 
21:50:36 <glguy> view (field07.field) object   and    set (field07.field) newvalue object
21:51:14 <ElderFain> oh, yeah i have this bookmarked to translate. https://github.com/ekmett/lens/wiki/Operators 
21:51:16 <EvanR> ElderFain: ah, thats lens stuff
21:51:19 <ElderFain> I don't like the ^. .~ 
21:51:25 <ElderFain> its very overly confusing
21:51:41 <EvanR> so its not an issue with the framework, just with lens style as a whole 
21:51:59 <ElderFain> glguy: I prefer your second example by far
21:52:06 <ElderFain> its much clearer for anyone reading it whats going on
21:52:20 <ElderFain> (even if they don't know haskell)
21:52:54 <kaidelong> are there any resources for calling Haskell code from C++ and exporting C++ objects from Haskell?
21:54:27 <ProofTechnique> Prayer and a good scotch?
21:54:56 <glguy> kaidelong: Generally you wrap the C++ stuff in a C interface and go via that
21:55:09 <kaidelong> glguy: that sounds like the other direction
21:55:28 <kaidelong> the less desirable one because then I'm doing my GUI work in Haskell
21:55:41 <kaidelong> although
21:56:07 <kaidelong> I guess you could push to a GUI process
21:56:51 <kaidelong> is there any OS independent way to do interprocess communication though?
21:57:26 <glguy> TCP is rather universal
21:57:51 <Ralith> UDP is probably easier to work with for strictly local IPC
21:58:06 <kaidelong> so the choices are basically
21:58:13 <kaidelong> "use web sockets" or "don't use haskell"
21:58:23 <Ralith> nobody said anything about web
21:58:29 <glguy> Haskell can export C functions you can call from C++
21:59:15 <kaidelong> mmmm, okay so so long as I'm not returning any heap-allocated stuff from Haskell then?
21:59:18 <kaidelong> although
21:59:30 <kaidelong> that would be a pretty sad restriction for what I want to use it for
22:00:03 * hackagebot jmacro 0.6.10 - QuasiQuotation library for programmatic generation of Javascript code.  http://hackage.haskell.org/package/jmacro-0.6.10 (GershomBazerman)
22:02:09 <ProofTechnique> Isn't this exactly what 0mq and the like are for?
22:02:41 <kaidelong> is that like MPI?
22:02:48 <kaidelong> that seems like overkill
22:03:17 <SrPx> Is there a normal form for the term ((Œªx. (x x x)) (Œªx y. ((x y) (x y)))))
22:04:01 <ProofTechnique> kaidelong: Cap'n Proto?
22:04:08 <ProofTechnique> I dunno. I'm just spitballing
22:04:59 <ProofTechnique> I always think of GUIs as message-y
22:08:32 <carter> SrPx: if you can give it a type,sure
22:08:33 <carter> that looks like a divergent term though
22:08:51 <SrPx> yep it looks like, but some metrics pointed it isn't.. I'm confused
22:09:02 <SrPx> it really looks like, though
22:09:08 <carter> SrPx: did you try running it?
22:09:09 <SrPx> I doubt you can give it a type
22:10:04 * hackagebot euler 0.8.2 - Mathematics utilities for Haskell  http://hackage.haskell.org/package/euler-0.8.2 (decomputed)
22:10:06 * hackagebot jmacro 0.6.11 - QuasiQuotation library for programmatic generation of Javascript code.  http://hackage.haskell.org/package/jmacro-0.6.11 (GershomBazerman)
22:10:13 <SrPx> carter: yep, it doesn't end. But it managed to get through my detector
22:10:28 <carter> SrPx: if you had  a total detector, i have a bridge to sell you
22:11:02 <SrPx> it has false positives obviously
22:11:45 <SrPx> but shouldn't let something like that skip, I'm cutting any term that performs deep enough beta reductions... seems like that term explodes without going deep
22:12:09 <SrPx> eh... I mean.
22:12:33 <carter> SrPx: clearly your code has a bug :)
22:13:09 <SrPx> are you sure? the last time it happened, turned out the term actually halted
22:24:11 <ElderFain> glguy: hmm. trying to apply this now... so with lenses & aeson, if your responses are always arrays with your results, like https://gist.github.com/anonymous/c15227fdce86731a87f2 , are you supposed to map over the responseBody before you can do something like '. key "assignee" . _String '
22:24:19 <Big_G> Is there a way to patter match to a list with only one element?
22:24:27 <Axman6> [x]
22:24:41 <ElderFain> or (x:[]) i think
22:24:44 <Axman6> or (x:[]) (which is the unsugared version of the above)
22:24:52 <ElderFain> aww yeah i knew something!
22:24:57 <Big_G> Axman6, I tried that but it didn't work
22:25:06 <Axman6> "didn't work"?
22:25:10 <ElderFain> Big_G: code? 
22:25:23 <Big_G> myLast :: [a] -> a
22:25:23 <Big_G> myLast x:[] = x
22:25:23 <Big_G> myLast x:xs = myLast xs
22:25:30 <Axman6> you need the brackets
22:25:34 <Axman6> (x:[])
22:25:36 <ElderFain> ( )
22:25:40 <Axman6> and (x:xs)
22:25:56 <glguy> ElderFain: That's not an Array, it's a JSON object
22:26:13 <Big_G> Axman6, How come I don't see them in most tutorials?
22:26:23 <ElderFain> glguy: fromList is a json object?
22:26:44 <Axman6> Big_G: I'd be surprised if you didn't because they're definitely necessary in that situation
22:26:50 <ElderFain> Big_G: tutorials may not be written correctly ? its required
22:27:11 <glguy> ElderFain: You decoded that JSON object as a Map String Value
22:27:12 <Axman6> what you're actually writing there is myList x : xs
22:27:38 <glguy> ElderFain: and the aeson package knows how to try and decode JSON as a Map String Value, it expects a JSON object
22:28:05 <Big_G> ElderFain, In every patter match that uses cons?
22:28:36 <Axman6> Big_G: do you have an example of a tutorial that doesn't use them?
22:28:50 <Big_G> Axman6, Not that I can think of. I just remember seeing some
22:29:36 <ElderFain> glguy: hmm. so this Map String Value is a.. standard thing? Its a Response constructor that requires 3 values to make it?
22:31:09 <glguy> Map is a standard type from the containers package
22:31:11 <dgorbik_> > let a:b:[] = [1,2,3]
22:31:13 <lambdabot>  not an expression: ‚Äòlet a:b:[] = [1,2,3]‚Äô
22:31:26 <dgorbik_> > a:b:[] = [1,2,3]
22:31:27 <lambdabot>  <hint>:1:8: parse error on input ‚Äò=‚Äô
22:31:37 <dgorbik_> grr, how do I make this work
22:31:47 <ElderFain> glguy: okay.. and 'fromtList' is a type of Map
22:31:51 <dgorbik_> Big_G, anyway, in this case you don't need parenthesis
22:32:00 <ProofTechnique> @let tailish x:xs = tail xs
22:32:00 <lambdabot>  Parse failed: Parse error in pattern: tailish
22:32:13 <dgorbik_> @let a:b:[] = [1,2,3]
22:32:15 <lambdabot>  Defined.
22:32:20 <dgorbik_> > a
22:32:21 <lambdabot>  Ambiguous occurrence ‚Äòa‚Äô
22:32:21 <lambdabot>  It could refer to either ‚ÄòL.a‚Äô, defined at L.hs:155:1
22:32:21 <lambdabot>                        or ‚ÄòDebug.SimpleReflect.Vars.a‚Äô,
22:32:28 <ProofTechnique> > L.a
22:32:30 <lambdabot>  *Exception: L.hs:155:1-24: Irrefutable pattern failed for pattern a : (b : [])
22:32:38 <glguy> ElderFain: "fromList" is a function that creates a Map and is defined in Data.Map
22:32:44 <dgorbik_> ah
22:32:49 <ProofTechnique> @let c:d:e:[] = [1,2,3]
22:32:51 <lambdabot>  Defined.
22:32:51 <dgorbik_> @let a:b:xs = [1,2,3]
22:32:52 <ElderFain> :t fromList
22:32:52 <ElderFain> fromList :: Ord k => [(k, a)] -> Map k a
22:32:52 <lambdabot>  .L.hs:157:1:
22:32:52 <lambdabot>      Multiple declarations of ‚Äòa‚Äô
22:32:52 <lambdabot>      Declared at: .L.hs:155:1
22:32:53 <lambdabot>     Not in scope: ‚ÄòfromList‚Äô
22:32:53 <lambdabot>     Perhaps you meant one of these:
22:32:55 <lambdabot>       ‚ÄòIM.fromList‚Äô (imported from Data.IntMap),
22:32:56 <dgorbik_> L.a
22:32:59 <glguy> ElderFain: "show" is supposed to produce Haskell source code, and Map's internals are hidden
22:33:01 <dgorbik_> > L.a
22:33:02 <lambdabot>  *Exception: L.hs:155:1-24: Irrefutable pattern failed for pattern a : (b : [])
22:33:09 <ProofTechnique> @unlet
22:33:10 <lambdabot>  Define what?
22:33:41 <ProofTechnique> dgorbik_: You can't redefine terms. There's supposed to be something to clear the definitions, but I don't remember.
22:33:49 <dgorbik_> L.c
22:33:50 <dgorbik_> > L.c
22:33:53 <lambdabot>  can't find file: L.hs
22:34:02 <dgorbik_> shouldn't your one work though
22:34:07 <dgorbik_> it uses different terms
22:34:44 <glguy> ?undefine
22:34:45 <lambdabot> Undefined.
22:34:59 <dgorbik_> Is it fine to use nested bracket? Or is there some other pattern I could use instead of nested bracket?
22:35:01 <ProofTechnique> That's it
22:35:28 <ProofTechnique> dgorbik_: What do you mean when you say bracket?
22:35:34 <ElderFain> glguy: okay so the response body has been turned into a "Response" type, which in this example is a function that returns a map, (fromList) and a list of values?  
22:35:37 <Axman6> > let a : ~(b : []) = [1,2,3] in a
22:35:39 <lambdabot>  1
22:35:41 <dgorbik_> ProofTechnique, exception handling bracket
22:35:45 <Axman6> > let a : (b : []) = [1,2,3] in a
22:35:46 <lambdabot>  *Exception: <interactive>:3:5-26: Irrefutable pattern failed for pattern a :...
22:36:08 <dgorbik_> wow, what's that `~` thing
22:36:15 <dgorbik_> never saw that before
22:36:20 <ProofTechnique> Lazy pattern
22:36:26 <glguy> ElderFain: The "Response ByteString" was turned into a "Response (Map String Value)" by (asJSON =<<)
22:36:30 <Axman6> a lazy pattern match
22:36:34 <ElderFain> glguy: I'm not exactly sure how I'm supposed to "get" at this data. I'd maybe ".each" through it in say Ruby, 
22:36:43 <dgorbik_> I've recently discovered `| (a:b:[]) <- [1,2,3] = True`
22:36:46 <dgorbik_> type of things
22:36:49 <ElderFain> glguy: right. so far so good.
22:36:51 <dgorbik_> pretty amazing and useful too
22:36:56 <dgorbik_> how is that called?
22:37:05 <Axman6> pattern guards
22:37:32 <dgorbik_> thanks!
22:42:28 <ElderFain> glguy: so how do you pull out something like the "email" or "assignee" in that example?  `r ^? responseBody . key "assignee" ` doesn't work, but it seems like it should
22:43:14 <ElderFain> and I assume its not working because the fromList needs to be.... opened up
22:43:16 <glguy> ElderFain: "key" works on Values. If you want to use it you'd need to change: type Resp = Response Value
22:43:26 <glguy> for a "Map" you need to use "ix" instead of "key"
22:44:02 <ElderFain> hrm
22:44:34 <Big_G> Why doesn't this work?
22:44:35 <Big_G> myReverse :: [a] -> [a]
22:44:35 <Big_G> myReverse [x] = [x]
22:44:35 <Big_G> myReverse (x:xs) = ((myReverse xs):x)
22:44:46 <ElderFain> I assume the Map is supposed to be there
22:44:47 <ion> @type (:)
22:44:47 <lambdabot> a -> [a] -> [a]
22:44:52 <ElderFain> changing the type doesn't seem like the right solution
22:44:58 <EvanR> :93
22:45:13 <ion> 0:[1,2] works, [0,1]:2 is a type error
22:45:42 <Axman6> (:) takes a thing, and a list of things and makes a list of things. you're trying to take a list of things and a thing;
22:46:14 <ElderFain> :t (++)
22:46:15 <lambdabot> [a] -> [a] -> [a]
22:46:24 <Axman6> (:) is just a data constructor. to do what you want you need to use an actual function such as (++)
22:46:40 <Axman6> though that implementation of reverse is very inefficient
22:47:13 <Big_G> What is more efficient?
22:47:24 <Axman6> Big_G: do you know about stacks?
22:47:31 <Big_G> Axman6, TYeah
22:47:38 <ElderFain> glguy: I guess im a bit lost about the Response constructor having the Map there then. what purpose is it serving, if to get the answer I want im supposed to just remove it ?
22:47:40 <Axman6> and how a list in haskell is basically a stack?
22:48:10 <Big_G> Axman6, I didn't know that
22:49:27 <Axman6> well, lists in haskell a singly linked lists, which is basically the same as a stack. so if you have a stack of plates and you want to make a re=veresed stack, how would you do that?
22:50:29 <glguy> ElderFain: I didn't say you had to remove it, it's just a choice. You can interpret the response as a Map String Value or a Value, it doesn't matter
22:50:45 <Big_G> Axman6, Take them all at once and flip
22:50:45 <glguy> ElderFain: If you elect to view it as a Map String Value then you index it with "ix" and not "key"
22:51:15 <Axman6> Big_G: nah, that sounds like hard work to me. why not just pop from one stack and push onto the other until the first one is empty?
22:51:32 <Big_G> Axman6, That is basically what I meant
22:51:54 <Big_G> Axman6, What would the code for that look like?
22:51:57 <Axman6> think of a pile of plates; to reverse the order, you'd take the first on, put it on the table, then take the next one and put it on top of the first, until the original stack is empty
22:52:25 <Axman6> Big_G: I'll get you started, but you're goin g to have to fill in the blanks =)
22:52:44 <ElderFain> glguy: when I change it to Response (value) I get nearly the same thing, Object (fromList ("assignee",Object (fromList [("email",String "me@example.com")])))
22:52:55 <Axman6> reverse xs = revHelper xs [] where revHelper :: [a] -> [a] -> [a]
22:53:23 <glguy> ElderFain: That's what I said would happen
22:53:47 <Axman6> the empty list there is the empty styack that you'll be putting elements onto
22:55:43 <ElderFain> glguy: I don't think our wave lengths are matching up here.. I still end up unable to actally "get" the value of the assignee for example,  r ^. responseBody . key "assignee"  doesn't work still
22:58:52 <ElderFain> basically the difference appears to be one is wrapped in Object, the other is not
23:00:28 <glguy> ElderFain: I don't know what you're doing wrong. Paste an example of a module that doesn't do what you expect
23:01:48 <Big_G> Axman6, Done
23:02:01 <Fylwind-> hrm, is there a reason why Vector is not Foldable?
23:02:19 <Big_G> Axman6, myReverse :: [a] -> [a]
23:02:20 <Big_G> myReverse [x] = [x]
23:02:20 <Big_G> myReverse (x:xs) = ((myReverse xs):x)
23:02:42 <glguy> Fylwind-: Did you check to see if it was: http://hackage.haskell.org/package/vector-0.10.12.2/docs/Data-Vector.html
23:02:44 <Big_G> Axman6, Wrong one. I can't seem to copy the new one
23:05:43 <Axman6> oh no D:
23:05:57 <Axman6> well feel free to write it on lpaste.org
23:06:03 <Axman6> @where lpaste
23:06:03 <lambdabot> http://lpaste.net/
23:06:07 <Axman6> oops, .net
23:06:30 <Big_G> Axman6, I did it in a putty session so I can't copy the text
23:06:45 <Big_G> Axman6, It's working either way. Thanks for the guidance
23:07:10 <ElderFain> glguy: https://gist.github.com/anonymous/8e19cb3f3299ca28e546  I am just trying to understand how I'm supposed to 'view' an attribute like the 'assignee' or the 'title' .  I am trying to apply what you are saying but its not making a lot of sense to me, r ^. responseBody . ix "assignee"   & so on
23:07:38 <Axman6> Big_G: do you understand why appending to the end of the list might not be a good idea when implementing reverse?"
23:07:53 <Big_G> No
23:08:04 <Big_G> To the end? 
23:08:09 <Axman6> ok, let's have a look, because it's important to understand
23:08:11 <Big_G> You'd be getting n**2
23:08:35 <Axman6> yep, exactly
23:08:49 <Big_G> Yeah, I get it. I forgot that it was appending to the end
23:16:41 <Big_G> Is there a way to specify that something is a list beyond x:xs?
23:17:33 <Fylwind-> glguy: I was referring to the Storable Vector
23:17:52 <Cale> Big_G: Give a type signature?
23:18:03 <Cale> Big_G: Or... I don't understand the question.
23:18:13 <Big_G> I meant when pattern matching for an input
23:18:35 <Big_G> I want a list as the input but I don't need it split into x and xs
23:18:51 <Cale> Then just use a variable for your pattern
23:18:59 <Cale> f xs = ...
23:19:38 <Big_G> Cale, You're right. I was trying to make it too complicated
23:20:45 <Cale> Note that you can also match against a nonempty list at the same time, like f xs@(y:ys)
23:21:04 <Cale> > let f xs@(y:ys) = (xs,y,ys) in f [1,2,3]
23:21:06 <lambdabot>  ([1,2,3],1,[2,3])
23:22:57 <ElderFain> glguy: was that what you were asking for when you said a module?
23:23:37 <glguy> No, I meant a module file that I could load that behavior that you didn't understand
23:23:45 <glguy> otherwise I have to guess what you're trying
23:23:50 <ElderFain> oh hrm
23:24:14 <ElderFain> its querying an internal service so i can't generate a module that would work since you'd have to be inside the firewall
23:27:44 <ElderFain> glguy: given that object (the fromList) how would I say... get every "object" in the list where the email address was "elderitch@example.com" ? 
23:28:07 <ElderFain> doing that would involve a filter , plus looking inside the resulting json object
23:28:56 <glguy> The fact that it still says fromList means you've left it as a Map . are you using Control.Lens.ix to look up in that map or still trying key?
23:29:39 <ElderFain> I dont know what control.lens.ix is, so lets go with "at this point, I'm literally doing nothing aside from questioning my life choices"
23:29:58 <glguy> I don't know the JSON schema your data uses. Reading more about the aeson package will help you here.
23:30:39 <glguy> Like I mention mentioned already you look up stuff in objects and maps differently; they are different types
23:31:10 <glguy> It would probably be better if you mostly forgot about lens at this point
23:31:23 <glguy> And just used normal functions like Map.lookup
23:32:31 <glguy> Because it's going to be frustrating to learn lens before learning the containers package or aeson
23:32:50 <ElderFain> okay.. it looks like https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/json is telling me to just define giant data types for all my responses 
23:33:17 <ElderFain> where as the wreq seems to just treat the response as a generic container
23:33:34 <ElderFain> (which is much more straight forward than manually declaring about 500 data types)
23:35:02 <glguy> Wreq just gives you the response as a byte string. What you do after that is up to you
23:35:36 <ElderFain> apparently I parse it as a Response (Map Value String)
23:42:53 <solatis> ok, yesod scares the crap out of me
23:43:18 <solatis> i don't understand how one person can do so much, michael is all over the place with everything
23:44:46 <ElderFain> k, guess i need to invest a few more months on these tutorials to make enough progress to read some nested json from a web service. bbl. 
23:45:09 <ElderFain> glguy: thanks for trying, heading to bed
