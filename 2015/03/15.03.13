00:00:24 <fro_ozen> dpwright: couldn't you just extract the pointer like this with foo \fooPtr -> return fooPtr?
00:00:57 <fro_ozen> and then just use it as a normal argument
00:01:11 <ski> fro_ozen : presumably it's only valid for the dynamic extent of that call to `with foo' ?
00:01:31 <fro_ozen> hm
00:02:43 <dpwright> That's right
00:02:52 <dpwright> actually it works out nicely using the monadic notation anyway
00:04:01 <apo> nomadic mutation
00:10:02 * hackagebot bimap 0.3.0 - Bidirectional mapping between two key types  http://hackage.haskell.org/package/bimap-0.3.0 (joel_williamson)
00:10:02 * hackagebot Redmine 0.0.3 - Library to access Redmine's REST services  http://hackage.haskell.org/package/Redmine-0.0.3 (cstpierre)
00:45:24 <jle`> dpwright: if anything i would say that this is one of the situatinos where do notation shines :)
00:47:03 <dpwright> jle`: Yeah... I was looking for applicative at first because I was translating from the C equivalent of "doSomething(&foo, &bar)" and it felt annoying to do "with foo $ \fooPtr -> with bar $ \barPtr -> doSomething foo bar"
00:47:28 <dpwright> it still feels a bit annoying, but it's certainly a lot more readable with monad notation
00:47:42 <dpwright> do notation*
00:59:58 * hackagebot learning-hmm 0.3.1.3 - Yet another library for hidden Markov models  http://hackage.haskell.org/package/learning-hmm-0.3.1.3 (mnacamura)
01:01:45 <jle`> man working with the Monad instance for dimension-parameterized matrices (as nested length-parameterized vectors) is a mind-turner i definitely never even imagined i would have to do
01:02:07 <jle`>  / wrestle with
01:02:20 <jle`> using do notation with fixed length vectors is fun
01:02:33 <jle`> but this is another level...literally >_>
01:03:48 <RustyShackleford> where can I find a good explaination of unit testing with haskell?
01:54:22 <shock_one> Hi. Why map hasn't become "map :: Traversable a => (b -> c) -> a b -> a c" as a part of burning bridges proposal?
01:55:16 <jle`> shock_one: isn't that a little specific?
01:55:27 <jle`> how about map :: Functor f => (a -> b) -> f a -> f b? :)
01:55:47 <jle`> all Traversable are Functor but not all Functor are Traversable
01:56:09 <shock_one> jle`: you're right. Anyway, why is it still map :: (a -> b) -> [a] -> [b]
01:56:45 <jle`> yeah wouldn't that be nice :'(
01:56:59 <jle`> i wonder if there was any discussion on this at all
01:57:03 <shock_one> There must be a reason.
01:57:07 <jle`> map did use to be Functor f => ...
01:57:18 <shock_one> They changed everything but map. https://ghc.haskell.org/trac/ghc/wiki/Prelude710
01:57:18 <jle`> but it was changed to be f ~ [] for pedagogy reasons long ago
01:57:45 <jle`> presumably either map completely slipped off the radar, or people reinforced the decision from long ago
01:58:23 <shock_one> Or there is a third explanation.
01:58:29 <jle`> map might be a unique case becasue it actually did *use* to be the generalized version
01:58:43 <jle`> yes, or a fourth :)
02:00:10 <shock_one> Maybe they decided fmap is good enough.
02:02:09 <fumieval> well the fact that `map` is specialized is a bit strange to me now
02:05:01 * hackagebot chesshs 0.2.1 - Simple library for validating chess moves and parsing PGN files  http://hackage.haskell.org/package/chesshs-0.2.1 (ArnoVanLumig)
02:05:30 <fumieval> mapM works for any traversable containers, then why not let map work?
02:05:41 <jle`> indeed, it's rather unfortunate
02:05:50 <jle`> map :: Functor t => (a -> b) -> t a -> t b
02:06:13 <jle`> mapM :: Monad m => Traversable t => (a -> m b) -> t a -> m (t b)
02:06:17 <jle`> it seems like a natural sort of progression
02:06:49 <jle`> map  ::            Functor t => (a -> b) -> t a -> t b
02:06:52 <jle`> mapM :: Monad m => Traversable t => (a -> m b) -> t a -> m (t b)
02:06:56 <jle`> esp. if you line them up
02:07:16 <shock_one> Actually, my mapM (7.10.1) has exactly the type you want. https://dl.dropboxusercontent.com/spa/dlqheu39w0arg9q/5klcmimg.png
02:08:19 <jle`> yeah, i'm talking about `map` changing to match `mapM`
02:08:43 <shock_one> So, why is there Traversable and not Functor in mapM?
02:09:05 <jle`> the t has to be Traversable
02:09:10 <jle`> Functor isn't powerful enough
02:09:47 <shock_one> Why?
02:09:50 <bitemyapp> shock_one: try it.
02:09:59 <jle`> yes, try writing it :)
02:10:07 <bitemyapp> shock_one: seriously, slap the type you want on mapM = undefined, and try to write it using only Monad and Functor.
02:10:50 <bitemyapp> taking a stab at things like this is really the best way to learn, IMO.
02:11:12 <bitemyapp> and when you get in a rut and don't know how to proceed, start looking at the list of methods in traversable and see if you can identify something that captures the "essence" of what you want to do, but cannot.
02:16:06 <shock_one> OK, we need to use sequence, which folds, which require Foldable. Functor isn't Foldable, Traversable is. Thank you for the lesson.
02:16:56 <jle`> shock_one: sequence actually requires Traversable
02:17:03 <jle`> Foldable isn't powerful enough
02:20:19 <shock_one> But if we had something which is both a Functor and a Foldable, it would be enough, right?
02:20:26 <jle`> not quite
02:20:54 <jle`> sequence lets you turn a t (m a) into an m (t a) while "preserving the structure" of the t
02:21:22 <jle`> for example, if I had an IntMap (m a), sequence would give you m (IntMap a), where each a lives at the address where the action used to produce it originally lived
02:21:48 <jle`> or an [m a] turns into an m [a], where each a lives at the spot in the list where the action used to produced it originally lived
02:22:06 <jle`> you lose your structure in `t` with Foldable
02:22:10 <jle`> Foldable's methods
02:22:23 <jle`> if you have an IntMap (m a), the best you can do with Foldable is get an `m ()`
02:22:36 <jle`> execute all of the actions in the map and return ()...the structure flies away
02:22:40 <jle`> like a candle in the wind
02:22:48 <jle`> if you have an [m a], the best you can do with Foldable is get an m ()
02:22:56 <jle`> again the entire structure of the list just flies away
02:23:35 <jle`> it lets you sequence/execute all of the actions, but you lose the structure of the original thing
02:23:40 <jle`> (this is sequence_)
02:23:56 <jle`> so if you wanted a t (m a) -> m (t a), you want to keep the structure of t...and you need Traversable
02:24:19 <shock_one> I see your point, but I have to reread it a couple of times to understand. JFYI, never saw a flying candle.
02:24:31 <jle`> it's quite a sight :)
02:25:13 <shock_one> Does it fly with the flame at the rear end, like a rocket?
02:25:36 <jle`> depends on atmospheric conditions
02:26:02 <jle`> sometimes it even spins like a boomerang
02:27:21 <vbogatyrev> ?scr Cont
02:27:21 <lambdabot> Maybe you meant: src rc arr
02:27:31 <vbogatyrev> ?src Cont
02:27:31 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
02:28:15 <bobsdad> anyone here work with javascript? I'm trying to stay sane while doing web stuff. I use coffeescript and underscore, any other tools you could recommend?
02:28:29 <bobsdad> haskell has spoiled me
02:29:13 <shock_one> bobsdad: TypeScript adds static type checking.
02:30:11 <jle`> flow from facebook adds haskell-like static typing and type inference
02:30:30 <bobsdad> typescript and flow, thanks I'll check it out!
02:30:36 <jle`> purescript is nice
02:30:48 <jle`> it's a language sort of like haskell but compiles to idiomatic javascript
02:30:53 <jle`> pure and type inference and stuff
02:31:38 <jle`> also there are the haskell-to-js compilers around too, fay (compiles a subset of haskell) and ghcjs (compiles all of ghc haskell and its IO runtime stuff)
02:31:49 <bitemyapp> bobsdad: there's also GHCJS.
02:32:05 <bitemyapp> bobsdad: which works with virtually all Haskell code. forkIO in JS is cool as hell :)
02:32:06 <jle`> i have worked with both fay and ghcjs to great benefit
02:32:35 <bitemyapp> "Learn you a GHCJS For Great Benefit!" I can see the book now.
02:32:41 <bobsdad> Are there any webdevs that actually use these? These all seem kind of obscure and not really production-ready.
02:33:03 <jle`> fpcomplete's entire front-end is in fay
02:33:15 <jle`> and it's a pretty intense web app
02:33:26 <bitemyapp> >pretty intense
02:33:29 <bitemyapp> yes lets go with that.
02:33:33 <jle`> it's basically a fully featured in-browser IDE
02:33:38 <bitemyapp> it's well made, but I would be vey intimidated by that sort of project.
02:33:46 <bitemyapp> a tonne of work had to be involved.
02:33:53 <bitemyapp> no wonder they need to use Haskell :)
02:34:00 <jle`> ha
02:34:19 <bobsdad> so this isn't something I should be telling my regular joe webdev friends about, I suppose lol
02:34:27 <jle`> hm, what do you mean?
02:34:56 <jle`> a fully featured industry-level IDE with enterprise support written in fay is sort of a "fay can do real world things in industry"
02:35:10 <bobsdad> most webdevs I know have barely even heard of functional programming, i don't see how I can share my code with them if I used one of these
02:35:30 <jle`> ah, well :)
02:35:54 <jle`> if you want to be able to write javascript with some benefits from haskell like type safety, flow seems like a promising option
02:36:08 <jle`> typescript is more like java/c++ type system than haskell type system
02:36:13 <shock_one> Actually, JS developers do full time functional programming.
02:36:41 <jle`> facebook has put in a lot of effort to make flow accessible and usable to javascript people
02:38:06 <bobsdad> @shock_one are you referring to how some ppl say JS is lisp in sheep's clothing?
02:38:06 <lambdabot> Unknown command, try @list
02:38:24 <bobsdad> shock_one: are you referring to how some ppl say JS is lisp in sheep's clothing?
02:38:58 <shock_one> God no! There are no macros. :) I'm referring to the fact that JS has HOFs.
02:39:26 <fractalsea> Is there a way of creating a function that takes some record, and returns a new record with an additional field?
02:40:00 <jle`> fractalsea: not quite, in normal haskell
02:40:18 <frerich2> fractalsea : That depends on how you represent a 'record'. If it's a tuple of things, you could of course define af unction like '(FirstName, LastName) -> (FirstName, LastName, FavoriteDish)'
02:40:23 <bobsdad> shock_one: that's true, that's always helpful! I cringe whenever I see loops though.
02:40:33 <jle`> well
02:40:53 <fractalsea> jle`: Are you implying it can be done in another way?
02:41:11 <jle`> that's like saying you can write a function that adds 1 to a number by writing f 2 = 3
02:41:18 <jle`> and you can't really "return types"
02:41:39 <jle`> you can possibly do some type-level hackery with typeclasses to sort of do something
02:41:55 <jle`> you can actually generate new types programmatically with Template Haskell
02:42:05 <fractalsea> frerich2: Ah I see, I’m not using tuples though, but I guess I could...
02:42:08 <jle`> but this probably isn't the solution to whatever problem you are thinking of :)
02:42:20 <jle`> can you tell us what you're trying to do?
02:42:23 <frerich> fractalsea : You could also have something like 'data Person = UnfamiliarPerson FirstName LastName | FamiliarPerson FirstName LastName FavoriteDish'.
02:42:24 <fractalsea> jle`: I see yeah, seems pretty crappy
02:42:24 <jle`> there's probably a much simpler solution
02:42:32 <jle`> sort of like an XY thing
02:43:02 <luite> bitemyapp: hmm, i'm not sure that's the level of seriousness i'd want to go for
02:43:32 <fractalsea> jle` I’m setting up an environment, each function takes the current environment and adds some field to it. Currently I’m using a single type to represent the environment, with a lot of Maybe values, I’d like to avoid that.
02:43:33 <bitemyapp> luite: needs more silliness?
02:43:36 <luite> but i should sit down and do some more ghcjs docs some time
02:43:49 <bitemyapp> luite: saves a lot of human-time.
02:44:05 <bitemyapp> luite: for every hour you spend writing, imagine how many hours it saves across all the people that will use it :)
02:44:17 <bitemyapp> luite: how have you been?
02:44:24 <fractalsea> frerich: hmm that’s a good idea
02:44:27 <bernalex> I'm having hairy errors with rigid type variables. anyone mind having a look? http://lpaste.net/940289411927506944 -- I have dumbed down a datatype, and getting some errors I'm not entirely sure how to proceed on solving.
02:44:28 <jle`> fractalsea: would a Map work?  where the keys are fields?
02:44:36 <luite> costs me my tie...
02:45:15 <fractalsea> jle`: I guess so, although that is essentially the same as what I have, where everything is a Maybe
02:45:39 <bernalex> the errors are that "'a1' /= 'a'", when they should ideally be, heh.
02:45:57 <jle`> what's wrong with Maybe values?
02:46:01 <jle`> Maybe is awesome :)
02:46:07 <luite> bitemyapp: stop typing so fast, it's clogging my gprs (1 bar) connectiong!
02:46:19 <bitemyapp> luite: sorry :(
02:47:04 <bernalex> bitemyapp: good $TIMEZONE_APPROPRIATE_GREETING. :-]
02:47:25 <bitemyapp> bernalex: howdy :)
02:47:34 <bitemyapp> it's 0444 here. My sleep is messed up.
02:47:45 <jle`> [freenode is requesting to use your location] [ ] allow [ ] deny
02:47:59 <luite> bitemyapp: i'm still in NZ, in manapouri
02:48:12 <bernalex> bitemyapp: I sleep roughly every other day these days. eat breakfast/supper around 2-4pm. I guess that qualifies as messed up too.
02:48:38 <fractalsea> jle`: My code is horrible because every time I need to read a value, I have to handle it not being there, even though it’s garunteed to be there.
02:48:52 <bernalex> I was awake ~100 hours last week. that was uhm interesting.
02:49:22 <bernalex> i.e. continuously from Thursday afternoon to Monday evening or something.
02:49:49 <jle`> fractalsea: if you just add them one at a time you can pass functions instead of field
02:49:51 <jle`> s
02:49:57 <jle`> er, the type
02:50:07 <luite> bitemyapp: anyway, ghcjs-base update stuff is nearing completion, but i'm not quite sure yet how to handle the type requirements around the FFI
02:50:10 <jle`> data Person = Person FirstName LastName Address
02:50:16 <nerium> I'm trying to experiment with type families, but got stuck. This is what I've so far, https://gist.github.com/oleander/59e417254fbdb078d0c1#file-gistfile1-hs-L27
02:50:19 <bernalex> nobody feel like dumbing down my datatypes this $TIMEZONE_APPROPRIATE_TIME_OF_DAY? :-]
02:50:23 <jle`> addFirstName :: FirstName -> (LastName -> Address -> Person)
02:50:24 <nerium> Why does it fail and how would I fix it+
02:50:40 <jle`> addLastName :: (LastName -> Address -> Person) -> LastName -> (Address -> Person)
02:50:45 <nerium> I've highlighted the line in question 
02:50:57 <bitemyapp> luite: makes sense @ FFI. What brought you to NZ?
02:51:02 <jle`> addAddress :: (Address -> Person) -> Address -> Person
02:51:14 <bitemyapp> bernalex: yeah you want more sleep, I think :)
02:51:44 <jle`> example implementations: addFirstName = Person; addLastName = ($); addAddress = ($)
02:52:02 <fractalsea> jle`: hmm interesting, I’ll have a think about that
02:52:08 <jle`> just pass in functions between your generating things
02:52:21 <fractalsea> jle`: Sounds like that might work well
02:52:21 <jle`> then you only know you have a "complete person" when you have a `Person`
02:52:36 <fractalsea> jle`: Thanks
02:52:37 <luite> bitemyapp: currently newtypes of JSRef work when the constructor is in scope, and many things in the updated ghcjs-base are newtypes rather than type synonyms for jsref, but i'm not sure if requiring the constructor to be in scope is all that great
02:52:44 <jle`> np!
02:53:01 <jle`> fwiw i've done this
02:53:28 <luite> bitemyapp: an airbus a380, most of the way at least
02:55:03 * hackagebot euler 0.7.0 - Mathematics utilities for Haskell  http://hackage.haskell.org/package/euler-0.7.0 (decomputed)
02:58:15 <bitemyapp> luite: yeah newtype vs. type syno is an interesting trade-off. I've been developing an appreciation of the type synonyms in `lens` and `lens-family-core` lately.
02:59:24 <ski> bernalex : `Op' is mostly useless
02:59:50 <bernalex> ski: how so? and, arguably, everything is "mostly useless" lol.
03:00:13 <bernalex> ski: you mean I could encode Bop/Uop/etc in OpDesc directly?
03:01:09 <ski> bernalex : say you're given an `Op', and after pattern-matching you know it's of the `C x' form. you know `x :: a', but you have no idea what the type `a' here is. you can't use `x' for anything. same goes for `Uop' and `Bop'
03:02:04 <bernalex> ski: for reference, here's how it is in the last public version: https://github.com/alexander-b/clac/blob/master/src-exec/clac.hs
03:02:14 <bernalex> so there's 'Bop :: (forall a. Floating a => a -> a -> a) -> Op' & similar
03:02:30 <bernalex> now I want to move the type encoding out of the datatype (dumb it down), and into wherever I use it.
03:02:45 <ski> bernalex : e.g., say you're given a list of type `[Op]', and you notice one element has the form `C x', and another has the form `Uop f'. now you can't say `f x', because while you know `x :: a0' (for some unknown `a0)' and you also know `f1 :: a1 -> a1' (for some unknown `a1') you have no way of knowing that `a0' is actually the same as `a1' -- they could well be different
03:03:29 <ski> bernalex : "you mean I could encode Bop/Uop/etc in OpDesc directly?" -- i don't know. since i don't know what you're trying to capture
03:03:57 <bernalex> ski: really what I want to do is not care at all about what type stuff is, and just infer everything. *except* when I need e.g. Floating for sin, or Fractional for (/).
03:04:06 <luite> bitemyapp: but more seriously, i wanted a break from all the haskell hacking in the same place at home, meet up with hamishmack again and thought i'd enjoy more of the backpacking+hacking in NZ that i did for a few weeks last summere here
03:04:12 <bernalex> ski: https://github.com/alexander-b/clac/blob/master/src-exec/clac.hs has all of the src -- it's quite short.
03:04:15 <ski> bernalex : hm, your `s' there may give some hint of what you want to do ..
03:05:27 <bernalex> ski: I'm not sure what you mean.
03:05:28 <luite> bitemyapp: the problem with type synonyms is that all safety and assumptions can be nullified by castRef :: JSRef a -> JSRef b
03:05:47 <bernalex> ski: my goal is to dumb down the data type and try to move all the type encodings into where they are actually used/needed.
03:06:26 <ski> bernalex : apparently your `s' operation seems to expect that the `C c',`Uop o',`Bop o' items on the first stack operate on values of the same kind that is kept on the second stack
03:06:39 <bernalex> ski: yeah
03:07:03 <ski> bernalex : for this, you'd need to make `a' a parameter of `Op' (and `OpDesc')
03:07:50 <luite> bitemyapp: but with newtypes it's other things that get annoying, like fromList :: [a] -> JSArray, what should a be? if all JSRef-like things were type synonyms, [JSRef a] -> JSArray would be acceptable, not so much with newtype
03:08:39 <ski> bernalex : hm, in your `clac.hs', you instead have `Bop :: (forall a. Floating a => a -> a -> a) -> Op',&c. .. which could also possibly work (it is different, though)
03:08:50 <bernalex> ski: that works well
03:08:55 <ski> hmm
03:09:01 <luite> bitemyapp: but the new coerce function may come in handy here, i'm going to try to keep it newtype
03:09:03 <bernalex> ski: but my entire goal is to get the encoding out of the data type
03:10:13 <ski> which encoding ?
03:10:22 <bernalex> ski: the types.
03:10:39 <bernalex> ski: i.e. I want the data types to be completely generic.
03:10:52 <luite> bitemyapp: but if i hit some roadblock i'll have to revert to type synonyms
03:10:57 <ski> i'm not sure what you mean by that
03:11:12 <bernalex> ski: I want to get rid of the constraints from the adt.
03:11:42 <ski> the `Floating a' constraint in `Bop :: (forall a. Floating a => a -> a -> a) -> Op' (e.g.) ?
03:11:54 <ski> or what ?
03:12:10 <bernalex> ski: in general I think e.g. 'data Stuff where MkStuff :: a -> Stuff' ius more useful than 'data Stuff where MkStuff :: Num a => a -> Stuff', and that the constraint should be where it is needed, in the functions etc where it's used.
03:12:18 <bernalex> ski: yeah 
03:12:22 <bitemyapp> luite: hrm, yes. Annoying.
03:13:34 <ski> bernalex : both of those two cases would be distinct from what you currently have at `clac.hs'
03:13:42 <luite> bitemyapp: i should try and go to sleep now though, thinking of doing a long hike (60km with quite a bit of vertical) tomorrow, so i need to get up early. will decide tomorrow morning depending on weather and how i feel :)
03:13:57 <bitemyapp> luite: hrm, yes. I should sleep as well. Cheers :)
03:14:42 <bernalex> ski: well, the goal, again, is to get rid of the constraints in the datatypes in clac.hs, and try to provide that type information where it is needed rather than in the adts themselves.
03:14:46 <ski> bernalex : `data Stuff where MkStuff :: a -> Stuff' would be completely useless (otoh, if you really meant `data Stuff a where MkStuff :: a -> Stuff a', then that's another thing)
03:14:52 <luite> if i do the hike, sunday will probably be a rest day, which means haskell :)
03:15:07 <bernalex> ski: oops yes
03:15:13 <ski> bernalex : i suppose here `data Stuff where MkStuff :: Num a => a -> Stuff' is equally useless, since `Num' doesn't provide a way to extract any concrete information
03:15:33 <bernalex> ski: yes my bad
03:16:18 <ski> bernalex : otoh, `data Stuff where MkStuff :: (forall a. Num a => a) -> Stuff' is (a little bit useful) -- you can at least use this to store numbers, and to extract them and compute with them, getting some output
03:16:39 <bernalex> ski: yes I see what I'm doing wrong in my code too. it's early in the morning, forgive me!
03:16:54 <ski> bernalex : so .. i'm still not sure what you want and what you don't want
03:17:16 <bernalex> ski: that's OK, you still made me figure out what I'm doing wrong. :p
03:18:46 <ski> bernalex : perhaps you want to store numbers and operations operating numbers, for a specific type of number, for each stack ? (that's the "parameterize `Op' and `OpDesc' by `a'" way)
03:19:29 <bernalex> ski: right now I simply want what I pasted but with a parametrised 'a'
03:19:54 <bernalex> ski: http://lpaste.net/940289411927506944
03:20:01 <bernalex> that's what I wanted atm. :)
03:21:00 <ski> bernalex : it can be good to be able to "see the flow of the type variables". in this case, i saw that the `a' used in `StackItem a' had nothing to do with each `a' used for each data constructor of `Op' (and this caused your errors)
03:22:02 <Haskellfant> can doctests be hooked into tasty? I can't find any examples
03:22:36 <ski> bernalex : what's `Neq' and `Ans' for ?
03:23:00 <bernalex> ski: 
03:23:01 <bernalex>      ,( Dop Neq                ",",     ",:\t\tstart a new equation"         )
03:23:03 <bernalex>      ,( Dop Ans                "ans",   "ans:\t\tuse the n-lth last answer"  )
03:23:44 <bernalex> ski: they are not dealt with by the solver presently, which is bad... and I should fix that... so yeah.
03:24:54 <ski> i was under the impression that this was some kind of concatative language interpreter ?
03:25:04 * hackagebot satchmo 2.9.6 - SAT encoding monad  http://hackage.haskell.org/package/satchmo-2.9.6 (JohannesWaldmann)
03:25:20 <bernalex> ski: haha it's an RPN calculator
03:26:03 <hseg> Anyone know where to ask pandoc questions?
03:26:12 <ski> can it "run computation backwards" to figure out the value of variable(s) in an equation ?
03:26:28 <ski> (or perhaps i should ask, is that the goal ?)
03:26:35 <bernalex> ski: I'm not sure what that means
03:26:36 <hseg> Specifically, pandoc isn't embedding a link to the MathJax script in my HTML files.
03:26:44 <bernalex> ski: it is a very very simple calculator
03:26:58 <bernalex> ski: used like 'clac 5 5 + 2 x pi /'
03:27:11 <bernalex> ski: or with the repl, which can give you verbose output like http://lpaste.net/7990862344416657408
03:27:17 <ski> well, you said "equation", which was why i wondered
03:27:44 <bernalex> ski: ah. no. merely like 'clac 5 5 + , 6 6 x , 7 7 -' etc.
03:38:43 <mpickering> hseg: What is your problem?
03:39:12 <hseg> As mentioned above, pandoc doesn't link to the mathjax script in the output HTML.
03:39:20 <hseg> So math doesn't render.
03:40:51 <ski> bernalex : ok
03:42:31 <bernalex> ski: do you know of a way I can get rid of Op, in 'data OpDesc a = Dop {op :: Op a, desc :: String}'?
03:43:08 <bernalex> ski: i.e. I want Bop & desc, or Uop & desc, or C & desc... etc.
03:43:28 <bernalex> the only reason Op exists atm is really just to allow OpDesc's Dop to add a desc to multiple Ops.
03:43:55 <bernalex> I don't even need record syntax for it anyway.
03:47:54 <ski> bernalex : "add a desc to multiple Ops" ?
03:48:38 <bernalex> ski: right so I want to be able to have a Bop wih a desc, or a Uop with a desc, or a C with a desc. which is why I have the Op data type and then make a data type that is any Op and a desc.
03:50:09 <ski> oh, i see you mean you wanted to factor the `desc' part out of all the separate cases of an `Op'
03:50:49 <bernalex> I think I mean what you think I mean. :)
03:52:54 <nshepperd> hseg: it should be expecting a HTMLMathMethod value at some point, which you set to (MathJax "url://where/mathjax/is/stored.js")
03:53:08 <nshepperd> to tell it to add that link
03:54:55 <hseg> nshepperd: I'm talking about the CLI interface, not the programming API.
04:06:44 <ski> bernalex : .. so i suppose you could move the `desc' into the `Sop' constructor. removing one indirection
04:07:07 <ski> bernalex : iow `Sop :: Op a -> String -> StackItem a'
04:10:06 * hackagebot dynobud 1.3.0.0 - your dynamic optimization buddy  http://hackage.haskell.org/package/dynobud-1.3.0.0 (GregHorn)
04:10:21 <jle`> i'm glad i have a dynamic optimization buddy
04:13:26 <hseg> Turns out I needed --standalone. Oops
04:14:35 <Flonk> Hello! Totally OT but I need some native english speaker. I like to think that my english isn't totally terrible but every once in a while you come across something that you just have no idea what it means.. We're trying to book a drum and bass artist for a small event, and in the form they supplied us we're supposed to fill in a field which is titled 'support bill'.
04:15:14 <bernalex> ski: just tried that on for size. it's workable.
04:15:25 <Flonk> Doors open, Doors close, Ticket price, Set start time, set length, *support bill*. ?
04:16:17 <bernalex> Flonk: hallo. this channel is for the haskell programming language. would you like to learn how to program using haskell?
04:16:30 <Flonk> bernalex: Dude I hang out in here 24/7 :P
04:16:49 <jle`> there's always #haskell-blah etc :)
04:17:10 <bernalex> Flonk: to answer your question, I would assume they mean supporting acts for the gig.
04:17:51 <ibid> or they're asking what you think of microsoft. could be.
04:18:06 <Flonk> bernalex: Ah, awesome! Sounds plausible.
04:18:33 <Flonk> ibid: Support Bill: YES
04:50:32 <boothead> Hi Nix folks, does anyone know what haskell-ng version of ghc is available prebuilt on hydra? I seem to be building the world again :-(
05:03:24 <mroman> getResponse from happstack doesn't support SSL does it?
05:07:22 <merijn> AFAIK all haskell frameworks use the same WAI interface, which is just an API for communicating with a front-end webserver. Therefore I suspect SSL support depends on the front-end server?
05:12:21 <mroman> merijn: getResponse serves as a http client
05:12:55 <mroman> http://www.happstack.com/docs/happstack-server-7.0.2/doc/html/happstack-server/Happstack-Server-Client.html
05:13:03 <mroman> it uses connectTo from Network behind the scenes
05:13:09 <mroman> so I strongly suspect it can't deal with https
05:13:25 <mroman> which means that getResponse even ignores the isSecure flag in the request
05:27:07 <brbblnch> Hey
05:30:13 <brbblnch> In lambda calculus. It seems from what I've read that in lambda calculus, eta reductions aren't really useful. Can anybody with more insight tell me how true that is ?
05:30:41 <merijn> brbblnch: Define "useful"
05:31:11 <brbblnch> merijn: I pretty much can't do that :)
05:31:14 <merijn> brbblnch: eta reduction doesn't change the semantics of a function, so in a sense they're not "useful" by definition
05:31:53 <brbblnch> merijn: but beta reductions /do/ change the semantics ?
05:32:27 <brbblnch> merijn: For instance, would the definitions of computability be any different ? are the main result any different ?
05:32:32 <merijn> Actually, I guess whether eta reduction preserves semantics depends on your evaluation strategy
05:32:59 <merijn> brbblnch: For evaluating lambda calculus beta reduction is the only reduction form you need
05:33:31 <brbblnch> merijn: what do you exactly mean by "evaluating" ?
05:34:30 <merijn> brbblnch: When you "compute" with the lambda calculus you usually do so by evaluating an expression, which usually means beta reducing to it's normal form
05:34:47 <brbblnch> merijn: context: I'm trying to get a grasp on lambda-calculs and stuff around that. And I'd like to understand a small basis subset of it at first. Thus if eta-reduction are not really necessary, I'd rather do without them first
05:35:19 <brbblnch> merijn: Well then your previous statement is kind of obvious, no?
05:35:21 <merijn> brbblnch: Lambda calculus only has like 3 pieces
05:36:18 <merijn> brbblnch: 1) Abstraction (binding a free variable in an expression with a lambda binding), 2) application (applying a lambda expression to an expression), and 3) beta reduction
05:37:19 <brbblnch> merijn: Are the equivalence classes defined by \beta-reduc the same as beta + eta reduc?
05:38:00 <ski> brbblnch : eta reductions are useful for refactoring and reasoning about programs
05:38:09 <merijn> So if I have the expression "x" (a single free variable) I can abstract it by adding a lambda binding "\x.x" I can apply the resulting lambda expression to another expression, say "y" and get "(\x.x) y" which beta reduces to "y"
05:38:13 <ski> computationally, it's the beta reductions that do the work
05:38:42 <ski>   fst (x,y) = x  -- beta reduction for pairs, there's a similar one for `snd'
05:38:52 <prsteele> straw poll: favorite command line option parser library?
05:38:54 <ski>   (fst p,snd p) = p  -- eta reduction for pairs
05:39:06 <merijn> brbblnch: Assuming a terminating evaluation order, then only beta reducing will have the same resulting normal form as interleaving beta and eta reductions
05:39:10 <merijn> prsteele: optparse-applicative
05:39:26 <prsteele> merijn: thanks!
05:39:37 <merijn> prsteele: Others have too much magic for my taste
05:39:48 <brbblnch> ski: yeah, so they are kind of the opposite of each other
05:40:18 <ski> brbblnch : "Are the equivalence classes defined by \beta-reduc the same as beta + eta reduc?" -- no, consider `\f. \x. f x' vs. `\f. f'
05:40:36 <brbblnch> merjn: by normal form, you mean beta normal form, not beta+eta normal form ?
05:40:40 <brbblnch> merijn*
05:41:12 <merijn> brbblnch: Unqualified normal form usually refers to beta normal form
05:44:53 <nerium> What's the type of (-> e) ?
05:44:57 <nerium> What does it do
05:44:58 <nerium> =
05:45:49 <merijn> nerium: That question doesn't parse
05:45:58 <merijn> nerium: What do you mean?
05:46:20 <nerium> I was asked to implement fmap for this type ((→) e).
05:46:52 <brbblnch> ski: Are you sure of the terms you gave me ?
05:47:11 <ski> assuming `e' is a complete type, iow it having kind `*', then `(->) e' has kind `* -> *' (it accepts one more concrete type before returning a concrete type (namely a function type))
05:47:19 <ski> brbblnch : which of them ?
05:47:37 <ski> e.g. let `e' be `Integer' in this example
05:47:44 <ski> @kind (->)
05:47:45 <lambdabot> * -> * -> *
05:47:48 <ski> @kind (->) Integer
05:47:49 <lambdabot> * -> *
05:47:52 <ski> @kind (->) Integer String
05:47:53 <lambdabot> *
05:48:10 <ski> `(->) Integer String' returns the type of functions from integers to strings
05:48:32 <brbblnch> ski: `\f. \x. f x' vs. `\f. f'       I can't find an equivalence between them…
05:48:56 <nerium> ski: Okay, thanks
05:49:23 <ski> nerium : i suggest you start with the type signature for `fmap', and then replace the functor type variable with `(->) e', and try to make sense of the resulting type signature, figuring out how to implement the `fmap' signature you get them
05:49:24 <merijn> nerium: Note that (-> e) (if had been valid haskell syntax) would've been the opposite if what you were asked to implement
05:49:48 <ski> brbblnch : they are not beta-equivalent. they are beta-eta-equivalent, however
05:49:54 <merijn> nerium: "(->) e" is equal to (e ->) in the same way that "(*) 2" is equivalent to "(2*)"
05:50:15 <nerium> okay
05:50:27 <nerium> I*m not sure I understand what it does tho
05:50:47 <ski> and `(->) e a' is then equivalent to `e -> a', like `(*) 2 7' is equivalent to `2 * 7'
05:50:49 <mpickering> @tell hseg Please make an issue on the issue tracker for us. 
05:50:49 <lambdabot> Consider it noted.
05:51:20 <nerium> aha, so it's a function from e to a
05:51:41 <nerium> What if we just say -> e, does that mean a function from w to any?
05:51:51 <nerium> *e to any
05:53:35 <ski> nerium : no, there is no "any"
05:54:13 <merijn> nerium: It's a partially applied type
05:54:31 <ski> nerium : note that the type `[Integer]' is actually syntactic sugar for `[] Integer' -- read this as (the type of) "lists of integers"
05:54:35 <nerium> merijn: ... which takes and e and return "any type" ?
05:55:07 <nerium> or does it take an "e" and waits for another arg?
05:55:11 <ski> nerium : however, the type `[]' would read as "lists of". it's incomplete. you have to provide the type it wants as an element type for it to be a complete/concrete type description
05:55:23 <brbblnch> ski: Are you sure you didn't swap \f \x and \x \f ?
05:55:31 <ski> nerium : the same is true for `(->) e' .. and for `Maybe' and for `Either e'
05:55:47 <ski> brbblnch : yep
05:56:33 <nerium> ski: Okay, I'll have to do some thinking 
05:56:38 <nerium> brb
05:57:15 <brbblnch> ski: but then you have \x ( \f f ) x =(beta) \x (f)[x/f] = \x x = \f f, no ?
05:58:13 <ski> brbblnch : by `\f. \x. f x' i understand `\f. (\x. (f x))'
05:59:28 <merijn> ski: I TAed a functional languages class and the prof insisted on using different bracketing from everyone else on the planet. So much confusion after people went to wikipedia >.>
05:59:50 <brbblnch> ski: Oh… finally I get it!
05:59:54 <ski> merijn : hehe. elaborate on the bracketing scheme ?
06:00:28 <brbblnch> ski, merijn: Thank you both for the explanations, very helpful!
06:02:34 <merijn> ski: () signified application, "\x.(f x)" to write what you and I would write "(\x.f x)" most confusingly "(\x.x y)" would correspond to "(\x.x) y"
06:03:34 <ski> merijn : ok. sometimes people use that convention for the quantifiers in logic
06:14:38 <mmaruseacph2> my prof used the \x.(f x) too at the start of the course
06:14:50 <mmaruseacph2> (when we were learning Scheme)
06:15:03 <mmaruseacph2> but switched to (\x.f x) when we moved to Haskell
06:15:52 <merijn> mmaruseacph2: To maximise confusion? :p
06:16:03 <mmaruseacph2> he said that it is to minimize it :)
06:16:21 <mmaruseacph2> since in Scheme you have (lambda (x) (f x)) it made sense to have \x.(f x)
06:17:16 <mmaruseacph2> while (\x.f x) is close to (\x -> f x) from Haskell
06:20:12 * hackagebot plailude 0.6.0 - plaimi's prelude  http://hackage.haskell.org/package/plailude-0.6.0 (alexander)
06:21:31 <yamadapc> Can we generate imports with TH?
06:23:22 <zipper> Which function should I use to force evaluation of `f x` in `return $ f x` ?
06:24:16 <Azel> $! rather than $
06:24:17 <ski> zipper : `evaluate', if you're in `IO'
06:24:34 <ski> otherwise, what Azel said
06:25:50 <ski> (of course one could also do `return $! f x' in `IO' .. but it doesn't mean quite the same as `evaluate (f x)')
06:26:04 <obiwahn> http://paste.debian.net/161082/
06:26:20 <obiwahn> what is wrong with my case construct
06:27:23 <zipper> :t evaluate
06:27:24 <lambdabot> a -> IO a
06:27:31 <zipper> :i evaluate
06:27:46 <ski> there is no `:i' in lambdabot
06:27:52 <zipper> ski: Which module exports evaluate?
06:27:58 <ski> @index evaluate
06:27:58 <lambdabot> Control.Exception, Test.QuickCheck, Debug.QuickCheck
06:27:58 <zipper> ski: It's out of scope for me.
06:28:03 <ski> the first one
06:28:26 <bergmark> obiwahn: that's a guard not a case, but i think you need to indent the `|'s futher than `out'
06:29:27 <obiwahn> still parse error on input `where'
06:29:58 <ski> obiwahn : instead of `==', you could match on a  ' '  pattern
06:30:59 <geekosaur> where isn't legal there, is it?
06:31:52 <ski> hm. point
06:32:59 <obiwahn> but why and how would i rewrite it?
06:33:50 <obiwahn> actually I did it with if else first but wanted to mactch end of line as well
06:35:09 <ski>   \c -> case c of
06:35:23 <ski>           ' ' -> " *foo* "
06:35:30 <ski>           _   -> [c]
06:35:36 <ski> obiwahn : perhaps that ?
06:36:16 <merijn> Needs more LambdaCase :p
06:36:53 <ski> that's the next step, yep :)
06:36:59 <merijn> <3 LambdaCase
06:38:31 <mniip> ooor
06:38:35 <mniip> you could write
06:38:42 <mniip> (($ " *foo* ") . if' . (' '==)) <*> pure $
06:38:52 <mniip> er
06:38:53 <mniip> (($ " *foo* ") . if' . (' '==)) <*> pure
06:39:58 <mniip> flip (if' . (' '==)) " *foo* " <*> pure
06:41:56 <randomclown> what's the best way to write a function f, such that f :: String -> String, and f "bb" "zzz" returns ["bb", "bc", "bd", ... , "bz", "ca", "cb", ..., "zz", "aaa", "aab" , ..., "zzy", "zzz"] ?
06:42:06 <randomclown> f :: String -> String -> [String]*
06:43:19 <randomclown> this is extremely easy in python
06:43:24 <randomclown> how do you do it in haskell
06:44:55 <mauke^> randomclown: f _ _ = ["bb", "bc", "bd" ...
06:45:52 <mniip> randomclown, how is "zz" -> "aaa" defined
06:45:58 <mniip> because otherwise it's pretty simple
06:46:10 <mniip> I mean with equal input string length
06:46:34 <randomclown> mniip: well think of it as rolling over
06:46:46 <randomclown> the character set is [a-z]
06:46:50 <mniip> rolling over at what point
06:46:52 <mniip> ah
06:46:52 <randomclown> and you're just counting up the next string
06:46:59 <mniip> a-z
06:47:06 <mauke^> randomclown: what does f "a" "A" do?
06:47:11 <EvanR> python has a built in base26 number system
06:47:12 <randomclown> mauke^: undefined
06:47:15 <randomclown> [a-z] only
06:47:27 <EvanR> so you have to do it with showIntAtBase 26
06:47:44 <mniip> nah
06:47:56 <mniip> can be implemented more elegantly I believe
06:48:10 <randomclown> EvanR: no this isn't a base 26 number system
06:48:12 <mauke^> EvanR: I don't think you can do it with showIntAtBase
06:48:13 <EvanR> how is that not elegant ;)
06:48:20 <mauke^> this is not how 0 works
06:48:30 <randomclown> EvanR: if you think it is, what is zero and what is one?
06:49:01 <EvanR> zero is "" and one is "a"
06:49:14 <mauke^> so 10 == 1?
06:49:37 <EvanR> zero is "a" and one is "b" ;)
06:49:42 <EvanR> shift everything one
06:49:47 <bernalex> how would you guys do the modulo of a Floating a, when wanting a Floating a back?
06:49:52 <EvanR> to get the starting points youll need to reverse it though
06:50:02 <randomclown> "aaa" parses as 000
06:50:03 <randomclown> lel
06:50:36 <randomclown> EvanR: I spent 3 hours trying to biject with natual numbers and failed miserably
06:50:37 <EvanR> no it would be 26^3-1
06:50:43 <EvanR> or +1
06:50:54 <mauke^> bernalex: foreign import "fmod"
06:50:59 <randomclown> but i'm shit so I'm happy to see something good
06:51:11 <randomclown> if you map it out
06:51:26 <mauke^> randomclown: how do you do it in python?
06:51:28 <bernalex> mauke^: hm.
06:51:55 <mniip> meanwhile '(sequence .) . zipWith enumFromTo' is a fancy function
06:52:02 <mniip> doesn't exactly do what is asked though
06:52:34 <EvanR> maybe a recursive use of unfoldr
06:52:36 <randomclown> mauke^: http://pastebin.com/zsLwBBhP
06:52:39 <randomclown> it runs
06:52:56 <mauke^> ok, this would be slightly easier in perl
06:53:05 <mauke^> "bb" .. "zzz"
06:54:05 <randomclown> mauke^: explain
06:54:53 <mauke^> perl -E 'say for $ARGV[0] .. $ARGV[1]' bb zzz
06:55:00 <mauke^> # literally the whole program
06:55:17 <randomclown> mauke^: haha epic
06:55:30 <mniip> in perl "abcz"++ is "abda"
06:55:49 <mniip> with similar semantics in ..
06:55:53 <mauke^> s/is/does/?
06:56:04 <mauke^> I mean, you're describing effects, not return values :-)
06:56:59 <randomclown> so any ideas on how a haskell version will work?
06:57:06 <randomclown> apart from using st with arrays and manually increment
06:57:07 <EvanR> ruby -e 'print ("bb".."zzz").to_a'
06:57:10 <randomclown> ala ppython solution
06:57:17 <mniip> mauke^, execState ("abcz" ++)
06:57:24 <mauke^> hah
06:57:51 <EvanR> randomclown: ... come on thats a little extreme
06:58:14 <EvanR> you can write a regular function to do it, but your question is really about golf
06:58:15 <mauke^> randomclown: I dunno. bijecting to naturals seems like the "right" solution but I don't know how to do it
06:58:33 <mauke^> on the other hand, I've never needed to do that
06:58:35 <randomclown> mauke^: I tried really hard and can't get over the zeros and 1s
06:58:46 <EvanR> i write something like this in clojure once in order to "letter" type variables
06:58:52 <mauke^> I mean, how often do you need to increment a string like that?
06:58:57 <randomclown> Oh actually
06:59:04 <randomclown> I have half of a solution for the objection
06:59:09 <randomclown> can you guys bring the other half
06:59:11 <frerich> randomclown : I'd try to define the infinite sequence ["a", .. "zzzzzzzzzzzzzzzz..."] and then use dropWhile/takeWhile
06:59:34 <mniip> frerich, inefficient
06:59:45 <breadmonster> Guys, emacs or vim?
06:59:51 <EvanR> randomclown: is this homework?
06:59:55 <mniip> ed is the default text editor
06:59:56 <mauke^> breadmonster: eclipse
07:00:01 <prsteele> emacs
07:00:09 <frerich> mniip : but effective
07:00:10 <randomclown> EvanR: I've been doing haskell homework for 4 years now apparently
07:00:16 <breadmonster> mauke^: Hmm, okay, interesting.
07:00:23 <EvanR> ok goodluck ;)
07:00:27 <bernalex> mauke^: I used mod' instead.
07:00:31 <randomclown> Don't have the other half of the bijection, I deleted it in a fit of rage
07:00:38 <mauke^> did I say eclipse? I meant libreoffice
07:01:12 <bernalex> breadmonster: I use vim. but both are fine for haskell development. pick the one you prefer.
07:01:24 <breadmonster> bernalex: I know neither, which is why I ask.
07:01:57 <bernalex> breadmonster: they are different. you should probably learn the basics of both & pick the one you like the most.
07:02:09 <mauke^> vim is less dumb out of the box and has the better undo system
07:02:26 <mauke^> and it has good documentation in case you want to change defaults
07:02:37 <prsteele> breadmonster: haskell-mode for Emacs is satisfactory. I doubt there is a wrong choice here if you're starting from scratch
07:02:45 <bernalex> breadmonster: if you want to talk about vim vs. emacs outside of specifically for haskell development, please go to #haskell-blah. I don't like flamewars. :-P
07:02:47 <breadmonster> prsteele: Fair enough.
07:02:48 <merijn> I recommend using the editor you already know
07:03:23 <bernalex> merijn: if they are learning Haskell at the same time, then sure, perhaps, but in general that's terrible advice.
07:03:30 <EvanR> > showIntAtBase 26 (\n -> chr (n + 0x61)) 0 ""
07:03:31 <lambdabot>  "a"
07:03:36 <EvanR> > showIntAtBase 26 (\n -> chr (n + 0x61)) 40 ""
07:03:38 <lambdabot>  "bo"
07:03:41 <EvanR> > showIntAtBase 26 (\n -> chr (n + 0x61)) 400 ""
07:03:43 <lambdabot>  "pk"
07:03:47 <breadmonster> :t unsafeCoerce
07:03:48 <lambdabot> Not in scope: ‘unsafeCoerce’
07:04:08 <randomclown> showIntAtBase 26 (\n -> chr (n + 0x61)) 25 ""
07:04:10 <randomclown> showIntAtBase 26 (\n -> chr (n + 0x61)) 26 ""
07:04:12 <randomclown> > showIntAtBase 26 (\n -> chr (n + 0x61)) 26 ""
07:04:14 <lambdabot>  "ba"
07:04:16 <mauke^> > map (\x -> showIntAtBase 26 (\n -> chr (n + 0x61)) x "") [25, 26, 27]
07:04:16 <randomclown> > showIntAtBase 26 (\n -> chr (n + 0x61)) 25 ""
07:04:17 <lambdabot>  can't find file: L.hs
07:04:17 <lambdabot>  ["z","ba","bb"]
07:04:21 <frerich> randomclown : I.e. one solution while be 'f start end = let l = concatMap (flip replicateM ['a'..'z']) [1..] in takeWhile (/= end) (dropWhile (/= start) l)
07:04:25 * EvanR looks for parseInt
07:04:25 <lpaste> mniip pasted “fancyEnumFromTo” at http://lpaste.net/124821
07:04:26 <mauke^> terrible
07:04:32 <mniip> randomclown, ^
07:04:34 <mauke^> EvanR: what happened to "aa"?
07:04:47 <EvanR> out to lunch
07:04:51 <ski> breadmonster : fwiw, `emacs -nw'
07:05:00 <kess> ewww -nw is the devil
07:05:11 <mauke^> is that like DISPLAY= emacs?
07:05:13 <mmachenry> Does anyone have any good documents with examples of how laziness helps increase code reuse? I'm thinking about infinite lists that can reuse map and filter without writing their own while loops. This is going to be for a class of non-haskell professionals. 
07:05:17 * ski grins
07:05:25 <randomclown> frerich: gish
07:05:34 <randomclown> gosh*, care to explain your work?
07:05:47 <ski> mauke^ : more like Screen ..
07:06:08 <mmachenry> All I have currently are some that I made up. I'd like a good document on the different ways laziness helps with reusability to draw from.
07:06:15 <mniip> > concatMap (flip replicateM ['a'..'d']) [1..] -- randomclown
07:06:16 <ski> mmachenry : i'm assuming you're already read the classic ?
07:06:17 <lambdabot>  ["a","b","c","d","aa","ab","ac","ad","ba","bb","bc","bd","ca","cb","cc","cd"...
07:06:17 <frerich> randomclown : It's just the Haskell version of what I wrote in English. ' concatMap (flip replicateM ['a'..'z']) [1..]' gets you an infinite sequence with all the possible strings (startng at 'a' and ending at 'zzzzzzzzz....')
07:07:17 <mmachenry> ski: Can you repeat slightly less cryptically? 
07:07:34 <ski> mmachenry : "Why Functional Programming Matters", by John Hughes
07:07:44 <randomclown> frerich: isn't that really slow if I ask for f "aaaaa" "aaaab"?
07:07:45 <mmachenry> ski: Oh yes I love that paper. 
07:08:19 <EvanR> randomclown: an efficient algorithm is going to require that you do arithmetic
07:08:21 <mniip> ski, oh, I thought "Programming - Why Haskell is Great"
07:08:22 <mmachenry> I'm going to see him speak at Erlang Factory in a couple of weeks. Woohoo
07:08:40 <ski> mmachenry : iirc, Cale was good at explaining how laziness can help with modularity. you could try to catch them
07:08:44 <frerich> randomclown: Try it :) It's okayish for me, maybe there's some deforestation possible.
07:09:11 <randomclown> frerich: well it's exponential runtime
07:09:12 <EvanR> randomclown: the range thing in python/perl/ruby is probably taking the start value and executing "successor" on each one which does carrying
07:09:17 <randomclown> base 26
07:09:43 <mniip> frerich, maybe some takewhile-sequence rule?
07:09:47 <mauke^> EvanR: http://pastebin.com/zsLwBBhP
07:09:48 <randomclown> EvanR: yeah exactly
07:09:58 <mniip> having one of those makes sense
07:10:40 <mniip> frerich, also I just tried and it's terribly slow
07:11:20 <randomclown> micro: I missed yours, how does yours work?
07:11:33 <EvanR> randomclown: as for built-in support for "excel" strings, no haskell does not have this
07:11:51 <randomclown> are you working on the reverse versions of the strings to avoid the O(n) penalty?
07:11:56 <randomclown> reversed*
07:12:16 <randomclown> looking good
07:12:22 <mniip> you mean mniip?
07:12:26 <randomclown> mniip: haha yes
07:12:35 <mniip> yes
07:12:50 <mniip> incrementing a string is much easier when it's LSB-first
07:13:34 <frerich> mniip: I suppose if you found that my version is slow, it's because you chose a very large starting point (say: f "aaaaaaaa" ... or so). One can mitigate this by chosing the start of the generated infinite sequence accordingly.
07:13:43 <EvanR> the string is not actually reversed, your terminal is reversed when you show the digits ;)
07:13:43 <frerich> mniip: I.e. instead of starting at 1, start at a larger value.
07:14:12 <mniip> then it's of very little difference from EvanR's idea
07:14:27 <EvanR> mauke^: whats that code? python source?
07:14:35 <mauke^> > let zz 0 = Nothing; zz x = Just (chr (ord 'a' + x' `mod` 26), x' `div` 26) where x' = x - 1 in map (reverse . unfoldr zz) [0 ..]
07:14:36 <lambdabot>  ["","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r",...
07:15:00 <mauke^> EvanR: the python version of this program
07:18:43 <hodapp> I'm pondering... Can one make Haskell transform something like a tree that refers to itself recursively, without simply applying the transform lazily every single time?
07:19:40 <hodapp> not sure if that's even a meaningful question.
07:19:46 <c_wraith> hodapp: so far as I know, only via observable sharing
07:19:54 <hodapp> c_wraith: what is 'observable sharing'?
07:20:19 <c_wraith> hodapp: if I understood you correctly, you mean that you want to apply a function to a cyclic data structure and have the result also be a cyclic data structure?
07:20:21 <hodapp> I suppose I could work with this by constructing a non-recursive tree, transforming it, and then generating a recursive version of it
07:20:43 <hodapp> c_wraith: something like that, yeah
07:21:37 <c_wraith> I forget what the package is, but it was based on http://foswiki.cs.uu.nl/foswiki/pub/Afp/CourseLiterature/Gill-09-TypeSafeReification.pdf
07:23:01 <bennofs> @hackage data-reify
07:23:01 <lambdabot> http://hackage.haskell.org/package/data-reify
07:23:39 <LostPlanet> so i am reading about haskell and I am wondering if a function signature is (RealFloat a) => a -> String why that can't just be written RealFloat -> String
07:23:56 <LostPlanet> like function :: RealFloat -> String
07:24:08 <LostPlanet> instead of function :: (RealFloat a) => a -> String
07:24:17 <LostPlanet> or maybe it can
07:24:45 <prsteele> LostPlanet: RealFloat is a typeclass
07:24:56 <kadoban> LostPlanet: Because RealFloat isn't a type, it's a typeclass. They have to be specified differently like that.
07:25:02 <LostPlanet> oh ok
07:25:16 <prsteele> Lostplanet: A Double is a concrete type that is an instance of RealFloat, among others
07:25:38 <LostPlanet> yea i was just thinking that before you said it. thanks.
07:26:19 <LostPlanet> is there online docs which would show things like what classes are RealFloat or , if i'm looking at docs for Double it says this class implements the RealFloat typeclass ?
07:26:40 <prsteele> LostPlanet: https://www.haskell.org/hoogle/
07:27:03 <prsteele> LostPlanet: if you search RealFloat there, it takes you to a page describing the typeclass, and also shows known instances
07:27:17 <vixlur> LostPlanet: :i RealFlot in ghci
07:27:42 <LostPlanet> thanks prsteele and vixlur
07:28:56 <mauke^> randomclown: https://www.fpcomplete.com/project/100831/zN4x4T6k4b
07:29:29 <mauke^> LostPlanet: Double is not a class, though. RealFloat is the class
07:30:18 <LostPlanet> mauke^: what is Double then ?
07:30:24 <mauke^> LostPlanet: a type
07:30:24 <bennofs> LostPlanet: a type
07:30:30 <mauke^> a stereo
07:30:49 <LostPlanet> ok
07:31:06 <prsteele> LostPlanet: e.g. data Double = ... | -0.0000000001 | 0 | 0.000000001 | ...
07:31:10 <hodapp> c_wraith: thanks, this looks like a familiar problem
07:31:12 <mauke^> heh
07:31:19 <eze> hi, anybody here familiar with bindings and FFI?
07:31:39 <prsteele> Lostplanet: whereas RealFloat is a set of functions that a type must implement to be a RealFloat
07:31:41 <mauke^> ﬃ
07:31:45 <hodapp> c_wraith: "cycles", there's the term I should have used
07:32:12 <mauke^> randomclown: btw, thanks for making me figure this out. it's been lingering in the back of my mind for years :-)
07:32:20 <Ibm-irc> -47- Someone here can help me with Unity 3d ?
07:32:32 <bennofs> Ibm-irc: wrong channel
07:32:37 <mauke^> Ibm-irc: you're in #haskell
07:33:21 <nerium> I'm trying to implement fmap for a custom data type, but Im getting an error
07:33:22 <nerium> https://gist.github.com/oleander/2612993dcc373efa76af
07:33:24 <nerium> Why is that?
07:34:03 <LostPlanet> prsteele: yea, kind of like an interface specification in some languages . that makes sense that a "typeclass" defines things that a type must implement to be in the typeclass
07:35:12 <kadoban> nerium: You can't do line 42. Notice how in the Either a instance of functor, the Left isn't modified? This is why.
07:35:48 <mauke^> nerium: because you're trying to use f (which is a function returning a 'b') where a value of type 'e' is expected and 'b' is not 'e'
07:36:00 <mniip> bennofs, mauke^, that looked like an amsg
07:36:12 <nerium> mauke^: aha
07:36:21 <nerium> So "f" can only be applied to one arg, not both
07:36:32 <nerium> Yes, that worked!
07:36:37 <nerium> mauke^: Thanks
07:36:46 <nerium> kadoban: Thanks
07:37:32 <eze> what is the best/simpler way to call scheme functions from haskell?
07:38:16 <kadoban> eze: Most languages have a C interface, I assume scheme does? That's probably the way to go. scheme <-> c <-> haskell
07:40:17 <eze> I see, so it is probable that I won't be able to jump over the C code
07:41:02 <EvanR> you cant break the C barrier
07:41:52 <eze> ok, then I will continue reading about FFI.
07:42:07 <eze> thank you both
07:44:50 <merijn> eze: You don't necessarily need to *write* C for that
07:45:32 <merijn> eze: When using the FFI you can have GHC export functions with the C calling convention (i.e. in compiled code they're indistuinguishable from what a C compiler would generate) the same applies to the C FFI of most schemes
07:45:50 <merijn> So you can just "lie" and tell GHC you're importing a C function which is just a foreign exported Scheme function
07:46:31 <merijn> LostPlanet: Note that typeclasses have some funny properties that are different from interfaces in, say, Java
07:46:44 <eze> I see, I am new with FFI.
07:47:46 <eze> I have the option of working with Python, C++ or Scheme (the language to call functions from)
07:48:28 <eze> and I am trying to understand which one would be more convenient/simpler to do
07:48:48 <merijn> eze: Basically, the problem is in the compiled machine code you need to know how/where to pass arguments to have the code understand it. Haskell and, say, C++ have very different ways of calling functions (for example, haskell not having a function call stack at all!)
07:48:52 <ccasin> Any HOOPL experts around?  Is there a clever way that I can get it to output the results of the analysis per node rather than per basic block?
07:49:30 <merijn> eze: The C FFI basically defines how *C* calls functions, and since both Haskell and C++ have a way to call C it becomes a sort of "common" dialect to ensure both sides are talking the same language when calling machine code
07:50:01 <merijn> It would be possible to build other FFIs, but that's usually a lot of work and if everyone already supports C, it's usually easier to go "via" the C FFI on both sides
07:53:16 <eze> I see, I understand the basic work needed to compile two languages. But this is the first time I work it in Haskell.
07:54:31 <merijn> eze: I just remembered, I have a minimal example of how to call haskell functions from C, which may or may not be helpful: https://gist.github.com/merijn/4a0fee2b3a5ef3476aa4
07:55:38 <merijn> If it's not helpful, then tough luck, because I'm leaving on vacation now ;)
07:56:00 <eze> merijn: Thanks, I am reading the Real World Haskell example
07:56:19 <eze> merjin: so this will be helpfull too
07:56:50 <eze> merijm: oop's, typo
07:57:26 <eze> merijn: and my typo again...
07:57:52 <eze> merijn: have a nice vacation
08:37:34 <EvanR> if i want a ReaderT over IO but dont want MonadIO, so i need to make a newtype wrapper or 
08:46:34 <rseymour> anyone here familiar with Tidal?
08:50:19 * hackagebot Kalman 0.1.0.0 - A slightly extended Kalman filter  http://hackage.haskell.org/package/Kalman-0.1.0.0 (DominicSteinitz)
08:51:03 <zipper> Strict version of map?
08:51:18 <mniip> zipper, strict in what
08:51:25 <EvanR> probably not a great idea
08:51:37 <zipper> mniip: Doesn'tkeep thunks. It evaluates stuff.
08:51:46 <EvanR> youre probably asking about deep seq
08:52:00 <mniip> that's not what strict means here
08:52:07 <mniip> and yes you're looking for deepseq
08:52:17 <zipper> :t deepseq
08:52:18 <lambdabot> Not in scope: ‘deepseq’
08:52:23 <EvanR> deepseq :: Magic
08:52:26 <mniip> @hoogle deepseq
08:52:28 <lambdabot> Control.DeepSeq deepseq :: NFData a => a -> b -> b
08:52:28 <lambdabot> package deepseq
08:52:28 <lambdabot> package deepseq-generics
08:53:07 <EvanR> zipper: the first thing to note is that map might not be keeping thunks anyway
08:53:32 <EvanR> before using deepseq you need to understand why and if it will hurt or help
08:54:19 <zipper> I want to map a function over a list.
08:54:31 <EvanR> what do you really want to do
08:54:31 <zipper> It typechecks but it doesn't seem to do the mapping.
08:55:46 <zipper> EvanR: ` _ <- return $ map save listOfStuff`
08:55:54 <EvanR> dont do that
08:55:59 <zipper> It doesn't seem to be doing the map
08:56:04 <zipper> What should I do?
08:56:09 <EvanR> map is a pure function it cant have side effects
08:56:18 <EvanR> what is the type of save?
08:56:39 <mniip> <zipper> It typechecks but it doesn't seem to do the mapping.
08:56:47 <mniip> hahahaha that's nothing to do with strictness....
08:56:48 <zipper> EvanR: `save :: Payslip -> Handler Payslip` Where Handler is a Monad
08:57:07 <EvanR> then what you ended up with was a [Handler Payslip]
08:57:13 <zipper> EvanR: So save is a `do...`
08:57:22 <EvanR> so one thing to do is use sequence
08:57:23 <mniip> you're looking for sequence
08:57:24 <EvanR> :t sequence
08:57:25 <lambdabot> Monad m => [m a] -> m [a]
08:57:25 <mniip> :t sequence
08:57:26 <lambdabot> Monad m => [m a] -> m [a]
08:57:29 <mniip> or mapM
08:57:31 <mniip> :t mapM
08:57:32 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
08:57:38 <EvanR> or forM
08:57:40 <EvanR> :t forM
08:57:41 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
08:58:08 <mniip> or (sequence .) . map
08:58:08 <EvanR> zipper: so you have a list of commands, but its not a command in of itself
08:58:14 <EvanR> does that make sense
08:58:15 <mniip> (not serious)
08:58:26 <zipper> mapM seems okay, let me try that
08:59:19 <zipper> mapM worked beautifully
08:59:44 <zipper> The thing is I have heard of mapM but somehow I couldn't remember to use it in this use case.
08:59:59 <zipper> How can I avoid such situations in future?
09:00:00 <EvanR> zipper: so the reason it typechecked but you didnt get what you wanted was the _ <- map save stuff
09:00:14 <EvanR> zipper: if you had writte just map save stuf you should have gotten a type error
09:00:30 <prsteele> :t save
09:00:31 <lambdabot> Not in scope: ‘save’
09:00:32 <zipper> EvanR: Thus I added a return
09:00:45 <zipper> prsteele: It's my function for saving to DB
09:00:47 <EvanR> zipper: so you write a useless command
09:00:52 <EvanR> wrote*
09:01:21 <mauke^> _ <- return ... is pointless
09:01:27 <zipper> EvanR: I still don't see why it didn't work. Because map can't return a list of Monads?
09:01:39 <mniip> it does return a list of monads
09:01:42 <mauke^> because 'return' builds an action that has no effects, only returns a value
09:01:47 <mniip> which is then 'return'ed into yet another monad
09:01:52 <mauke^> and '_ <-' ignores the return value and only does the effects
09:01:56 <mniip> and unpacked by <-
09:02:17 <mniip> so _ contains the list of actions, just what map returned
09:02:23 <mniip> but it's _, so it's discarded
09:03:14 <mniip> zipper, what you did is like
09:03:31 <mniip> "it doesn't typecheck... let me stick a (`const` ()) in the front"
09:03:52 <mniip> no wait, that would be (const ())
09:03:58 <prsteele> I think a good analogy would be \x -> head [x]
09:06:22 <mniip> prsteele, rather
09:06:32 <mniip> let _ = head [important stuff]
09:09:04 <mniip> ah well they quit
09:09:18 <EvanR> the payslips went through thats all that matters
09:10:17 <mniip> now I'm stuck wondering what would make them think strictness has anything to do with side effects
09:10:21 * hackagebot clash-prelude 0.7 - CAES Language for Synchronous Hardware - Prelude library  http://hackage.haskell.org/package/clash-prelude-0.7 (ChristiaanBaaij)
09:10:23 * hackagebot clash-vhdl 0.5 - CAES Language for Synchronous Hardware - As a Library  http://hackage.haskell.org/package/clash-vhdl-0.5 (ChristiaanBaaij)
09:10:25 * hackagebot clash-lib 0.5 - CAES Language for Synchronous Hardware - As a Library  http://hackage.haskell.org/package/clash-lib-0.5 (ChristiaanBaaij)
09:11:06 <zipper> EvanR: Sorry my laptop suddenly switched off.
09:11:10 <zipper> You were saying?
09:12:11 <EvanR> -_
09:12:47 <mniip> zipper, for the record, strictness/laziness is unobservable other than through computation delays (sometimes infinite delays)
09:13:08 <dfeuer> Hmm...  What's the usual way to deal with the fact that Maybe [a] is too strict? That is, if I have a computation foldMap f . fmap (map g) . (m::Maybe [a]), I'd like to be able to start folding before I know if the initial computation succeeds.
09:13:14 <dfeuer> What's the right way to restructure this?
09:13:15 <kadoban> zipper: http://lpaste.net/124865 <-- chat you missed.
09:13:51 <dfeuer> One (ugly?) way would be to pair a list with a Bool indicating whether it's valid or not...
09:13:52 <mauke^> there's logs in the topic
09:13:58 <zipper> mniip: I thought my using _ meant that maybe it just created a list of thunks
09:14:16 <dfeuer> But I'm guessing I'm not the first one to ask this question, and that there may be a cleaner answer off the shelf.
09:14:19 <mauke^> it didn't create anything
09:14:49 <mniip> zipper, thunks are internal to the compiler
09:15:03 <mniip> you can't tell a thunk from a non-thunk in haskell
09:15:16 <mniip> (other than compiler specific hacks of course)
09:15:21 * hackagebot clash-systemverilog 0.5 - CAES Language for Synchronous Hardware - As a Library  http://hackage.haskell.org/package/clash-systemverilog-0.5 (ChristiaanBaaij)
09:15:23 * hackagebot clash-ghc 0.5 - CAES Language for Synchronous Hardware  http://hackage.haskell.org/package/clash-ghc-0.5 (ChristiaanBaaij)
09:15:30 <EvanR> but making a function strict or not through various ways does have an observable effect
09:16:10 <mniip> EvanR, yeah, it might return more or fewer bottoms :P
09:16:32 <bergey> mniip: Some of the descriptions folks give of monadic IO sound a lot like the definition of a thunk.  Things like, "IO foo is an unevaluated action, which when evaluated will produce a foo."
09:16:43 <dfeuer> Er ... I suppose I can use [Maybe a]. Hmmm.
09:17:56 <bergey> I also see people writing functions of no arguments in JS, and sometimes I say "oh, that's a way to accomplish lazyness," and sometimes I say "that's a way to encode an IO action".  So I'm not surprised when people learning Haskell by analogy to other languages conflate these two.
09:17:59 <mniip> bergey, well that conflicts with the "pure" thunks
09:25:13 <ReinH> jle`: Earlier, you said that the best you can do with Foldable and a Monad m => [m a] is get a m ()
09:25:43 <ReinH> jle`: That's not true. You can sequence the m's and fold the a's to get a m b
09:25:46 <ReinH> :t foldr (>>)
09:25:47 <lambdabot> Monad m => m b -> [m a] -> m b
09:26:17 <ReinH> (This one folds the a's by ignoring them)
09:26:38 <shachaf> You don't mean Monad m => [m a] -- closer to Monad m *> [m a], maybe -- but we've talked about that before.
09:27:05 <ReinH> shachaf: Can I just say "[m a] for some Monad m"?
09:27:14 <shachaf> Sure.
09:27:19 <ReinH> Ok.
09:27:32 <ReinH> I'll try to do that then.
09:29:31 <zipper> mniip: EvanR Can laziness cause a thunk not to be evaluated throughout the lifetime of a program? I think yes so I think it would've been possible.
09:30:01 <akegalj> can i somehow add language pragma in ghci without reloading it with "ghci -X".
09:30:09 <geekosaur> :set or :seti
09:30:16 <EvanR> zipper: yes, if you never use it for anything
09:30:20 <geekosaur> zipper: main = print $ take 2 [1..]
09:30:22 * hackagebot syncthing-hs 0.1.0.0 - Haskell bindings for the Syncthing REST API  http://hackage.haskell.org/package/syncthing-hs-0.1.0.0 (JensThomas)
09:30:27 <EvanR> zipper: and thats what you did
09:30:43 <geekosaur> there will be an unevaluated thunk for [3..]
09:30:45 <nerium> I'm trying to set the correct type signature on a return function, but I can't get it to work
09:30:46 <nerium> https://gist.github.com/oleander/ccd69cd6e8838c64c940#file-gistfile1-hs-L9
09:30:52 <nerium> What I'm I missing?
09:31:05 <zipper> EvanR: I had tried `c <- return $ map ...` but it still didn't work.
09:31:32 <EvanR> you got a type error?
09:31:33 <akegalj> geekosaur: thank you
09:31:42 <zipper> EvanR: No
09:31:44 <EvanR> or you just ignored the c
09:31:56 <EvanR> c was your list of commands that you did not use
09:32:09 <zipper> EvanR: I believe the thunks went unevaluated. I didn't use the c
09:32:28 <EvanR> they werent evaluated, but thats orthogonal because evaluation doesnt execute commands in haskell
09:32:40 <mniip> zipper, effectful computations, like saving something (I presume to disk?) are a different beast than thunks and lazy evaluation
09:32:49 <zipper> EvanR: So making map strict would have worked then?
09:32:55 <EvanR> no it shouldnt hvae
09:33:09 <zipper> mniip: Yes I was saving to disk.
09:33:09 <EvanR> youd have evaluated the list contents then ignored the results again
09:33:37 <EvanR> you are confused about the difference between evaluation and execution
09:33:41 <mniip> ^
09:35:11 <zipper> SMH
09:35:23 <zipper> EvanR: Yeah what's the difference?
09:35:24 <EvanR> see here i evaluate getChar
09:35:27 <EvanR> > getChar
09:35:28 <ReinH> zipper: do { let xs = [1..]; print "Hello" } is a program that terminates
09:35:28 <lambdabot>  <IO Char>
09:35:29 <zipper> I think they're the same
09:35:33 <EvanR> but it didnt get a char
09:35:39 <EvanR> because you didnt execute it
09:36:06 <zipper> EvanR: Oh so it evaluated but it didn't execute i.e save to disk/db
09:36:07 <bergey> nerium: You mean that you get an error iff you uncomment line 8?
09:36:17 <nerium> bergey: Yes
09:36:18 <EvanR> if you had a program producing machine code, you wouldnt execute it to also run that code right then and there
09:36:43 <EvanR> would often be inconvenient
09:36:49 <EvanR> zipper: yes
09:37:01 <mniip> zipper, 'getChar' is an IO action, it is a value, evaluate it all you want. Only when you execute it, that is, use it somehow in the main IO action, then it reads a char
09:37:07 <zipper> I have seen a lot about forcing evaluation but nothing on forcing execution.
09:37:20 <mauke^> you can't force execution. just let it happen ~
09:37:31 <EvanR> dont use the force
09:37:44 <mauke^> feel and you'll be tanasinn
09:38:01 <bergey> The `Monad m =>` part means that this should work for any `m` that is a Monad.  But you only want it for the `m` mentioned in line 7.  `return :: a -> MaybeT m a` compiles.
09:38:08 <mniip> the most often used way to execute something is to include it in another IO action
09:38:12 <EvanR> zipper: the idea of "forcing" anything is supposed to clue you in that you are doing something wrong
09:38:13 <zipper> Confirmed: purity makes haskell confusing for people who aren't used to it.
09:38:19 <EvanR> or with consequences
09:38:21 <obiwahn> hey i have some string and transform it with some lambda. now i want to append something to the result of that lambda
09:38:28 <obiwahn> what do i have to do?
09:38:29 <bergey> The error message tries to explain this, saying: it should be
09:38:29 <bergey>       return :: forall a. a -> MaybeT m a
09:38:40 <mauke^> obiwahn: you use ++ to concatenate strings
09:39:06 <aawe> what's the purpose of the "forall a." qualifier there?
09:39:22 <divVerent> EvanR: the only use of forcing I ever had was in getting Debug.Trace to work in some cases... we need something better than printf debugging :) but I know we have, just can't use it in the code base I am using on
09:39:25 <geekosaur> none, just ghc being pedantic
09:39:28 <ReinH> aawe: it's just being explicit
09:39:31 <EvanR> zipper: the way this is setup up is convenient, where you have callbacks, lambda wrappers in impure lanugages, you can have normal first class actions like getChar. store them in lists, sort them, etc
09:39:34 <divVerent> e.g. traceM before a put in the state monad just won't work
09:39:42 <ReinH> the forall always exists for type variables
09:39:48 <aawe> ReinH: But I mean, can it ever be anything else?
09:39:48 <ReinH> it's usually just elided
09:40:09 <geekosaur> aawe: you can have internal forall-s, which gives you rank-N types
09:40:18 <ReinH> in that case, no
09:40:22 * hackagebot hapistrano 0.2.0.1 - A deployment library for Haskell applications  http://hackage.haskell.org/package/hapistrano-0.2.0.1 (jsl)
09:40:33 <nerium> bergey: Thanks!
09:40:46 <aawe> thanks for the explanations
09:40:53 <mniip> zipper, people don't like this analogy, but for a second think of IO actions as of functions that take a world as an argument, and return the new state of the world as the result
09:40:54 <ReinH> aawe: What it's being explicit about is that a is local but m comes from the outer scope
09:41:07 <mniip> when you evaluate an IO action, you get the function, when you execute the action, you call it
09:41:08 <EvanR> mniip: i dont like that analogy
09:41:58 <EvanR> if you give the piece of paper saying "attack at dawn" to your general for execution, what does this have to do with functions and "real world"
09:42:16 <ReinH> mniip: That doesn't make sense
09:42:20 <mniip> :|
09:42:40 <mniip> EvanR, the paper has moved!
09:43:06 <EvanR> still wondering
09:43:34 <EvanR> the paper changed hands, the command is executed, but the paper changed hands way before anything happened
09:43:44 <mniip> well yeah your analogy is pretty good
09:44:02 <ReinH> zipper: I think it's all a bit more simple than we're letting on. Only one IO action is ever execute when you run a program.
09:44:05 <mniip> if >>= is a way to duct-tape pieces of paper :P
09:44:05 <EvanR> so no functions on physics are going to help
09:44:09 <obiwahn> mauke^: ah cool:)
09:44:29 <EvanR> mniip: thats >>
09:44:34 <nerium> bergey: Hmm, same thing with >>=, shouldn't "Monad m => m a -> (a -> m b) -> m b" work?
09:44:43 <ReinH> zipper: That action is called "main". It is usually composed of a bunch of smaller IO actions like getChar and putStrLn "foo", and that composition uses the Monad interface (>>= and >>, etc).
09:45:50 <ReinH> (I'm using compose in the sense of "make a large thing from smaller things", not in the sense of (.))
09:46:06 <nerium> bergey: Solved it.   (>>=) :: MaybeT m a -> (a -> MaybeT m b) -> MaybeT m b
09:46:16 <mniip> well (.) does make a large function out of smaller ones
09:46:23 <ReinH> mniip: true
09:47:32 <bergey> nerium: Yep!
09:47:53 <zipper> Well I get monads and IO in terms of. Monadic computations. When run they give you a monad
09:48:24 <zipper> EvanR: mniip Like a recipe when followed gives you a dish, but the dish is not in the recipe.
09:48:28 <ReinH> "When run they give you a monad" I'm not sure what "run" or "a monad" means.
09:48:35 <mniip> "When run they give you a monad"
09:48:58 <EvanR> zipper: and using monads, you chain together programs to write the rest of the recipe with code
09:49:20 <EvanR> which can be (is) evaluated lazily as you go
09:49:21 <mniip> monads are but an API
09:49:43 <EvanR> which is how looping works
09:49:48 <mniip> to bind a wrapped value to a function returning another wrapped value
09:49:52 <EvanR> otherwise it would be an infinite recipe
09:58:37 <ocharles_> Quick poll: do people think there is value in adding doctest-like examples ot all functions in `base`?
09:59:00 <ocharles_> Even "obvious" stuff like: >>> head [1..10] == 1
09:59:40 <Clint> ocharles_: sure, why not?
09:59:42 <mniip> start with True == True
10:00:00 <ocharles_> Clint: I can't answer that question, that's why I'm here ;)
10:00:02 <kadoban> ocharles_: Off the top of my head, I would think not. By the time anyone is examining code in base, they probably know what a bunch of those do implicitly.
10:00:38 <ocharles_> kadoban: ok, let me rephrase it as Clint put it: is there any reason we wouldn't want that? E.g., would there be too much noise?
10:01:08 <ij> Can (flip $ fmap . fmap . const) be shortened?
10:01:39 <kadoban> Ehhh, I dunno. I guess it'd add some extra lines that wouldn't necessarily help anyone, but…the cost of having a couple of extra lines isn't very high either, so I dunno.
10:01:40 <Adeon> IMO as long as you don't put long examples in there should be okay
10:02:07 <Adeon> is there an example package that does something like this
10:02:27 <mniip> ij, fmap .const is (<$)
10:02:38 <ocharles_> Adeon: lens does it quite a bit
10:02:54 <Adeon> ah, right
10:03:00 <ocharles_> and yea, I'm thinking one line per function
10:03:07 <ocharles_> maybe two if it has wildly different behaviors on inputs
10:03:13 <mpickering> ocharles_: Maybe not all functions but I think that filepath does it well
10:03:34 <ocharles_> mpickering: ah yes, very nice
10:03:34 <ocharles_> thanks!
10:04:42 <mpickering> did the type of the package database change recently?
10:05:29 <ij> mpickering, Does (flip $ fmap . (<$)) look scarier?
10:05:52 <mpickering> :t flip $ fmap . (<$)
10:05:52 <lambdabot> (Functor f1, Functor f) => f (f1 b) -> a -> f (f1 a)
10:07:09 <ij> woups, I wanted to highlight mniip 
10:07:18 <mpickering> sure and yes it does look scarier
10:07:25 <mpickering> (imo)
10:08:02 <glguy_> ij: Are you doing an obfuscated Haskell competition?
10:08:52 <ij> Writing a command line script, I want this one thing to be pointful.
10:09:10 <mniip> @unpl flip $ fmap . fmap . const
10:09:10 <lambdabot> (\ b c -> fmap (fmap (\ _ -> c)) b)
10:09:30 <ij> getProcessExitCode >>= flip (fmap . fmap . const) makes a Handle into a Maybe Handle.
10:09:52 <ij> That way I'll be able to catMaybe them into processes that succeeded. Don't think it's very obfuscated. :>
10:10:02 <glguy_> ouch :)
10:12:12 <glguy_> If you're set on operators you'd be much better off with
10:12:13 <glguy_> 07\x 07-> (x 07<$) 07<$> getProcessExitCode x
10:12:51 <ij> Colors! Holy wow.
10:12:52 <bergey> mpickering: Package DB in sandboxes?  cabal-install-1.22 / GHC-7.10, I think.  See: https://github.com/haskell/cabal/issues/2301 https://github.com/haskell/cabal/issues/2320
10:13:32 <ij> glguy_, Myeah, -> makes it a lot worse. Yours looks better.
10:16:22 <kala> hi
10:16:42 <kala> Could someone please suggest a way to export haskell lists to a csv file?
10:17:18 <glguy_> There are some CSV libraries on Hackage.
10:17:26 <kadoban> kala: Isn't CSV for tables, not lists? How would the translation go?
10:17:28 <mpickering> bergey: close .. but the problem is that "cabal sandbox init" is creating a folder based package db but my global package db is the old flat version
10:17:40 <mpickering> so I've messed up something somewhere
10:17:49 <kala> Thanks people
10:17:51 <kala> :)
10:18:11 <kala> kadoban : it can be transformed into a csv
10:22:01 <dolio> All right. Glad we solved that problem
10:23:04 <ReinH> ocharles_: o/
10:27:07 <ocharles_> :)
10:28:12 <ij> Are «haskell-mode» just bindings for something CLIsh? Or is it elisp for processing haskell and I can't get it on vim just by piping things?
10:29:42 <xpilot> I'm getting a really strange error with a data contructor
10:30:08 <xpilot> I've created another name for it with a different fixity
10:30:17 <ReinH> ij: It's an emacs package written in elisp.
10:30:20 <xpilot> but the second one doesn't typecheck
10:30:29 <mniip> xpilot, more context?
10:30:30 <xpilot> while the first one does
10:30:44 <ReinH> xpilot: Show us the code and the error
10:30:47 <ReinH> @where lpaste
10:30:47 <lambdabot> http://lpaste.net/
10:32:21 <ij> ReinH, That sucks, thanks.
10:32:47 <ReinH> ij: You can get integration with ghc-mod or hdevtools in vim
10:32:57 <ReinH> and you can get syntax highlighting and some indentation
10:33:09 <dolio> Yeah, people have written lots of vim stuff.
10:33:16 <xpilot> here it is: http://lpaste.net/124951
10:33:17 <dolio> I tend to not use much, though.
10:33:35 <kaidelong> vim in haskell is okay
10:33:45 <kaidelong> err, haskell in vim
10:33:59 <kaidelong> you get linting, error checking, but no built in debugger although not sure emacs gives you that
10:34:21 <mniip> xpilot, what's the type of :&
10:34:23 <dolio> xpilot: Monomorphism restriction.
10:34:28 <clrnd> I used ghc-mod but then it broke, and whatever ... I don't need it (it's quite slow too, on startup)
10:34:38 <ij> Is cabal hell that thing where you get "force reinstalls?" whenever you want to install anything?
10:34:45 <xpilot> dolio: I suspect you're right
10:34:53 <kaidelong> if you {-#GHC-OPTS -f-defer-type-errors #-} you can bind a key to give you the type of a symbol at the cursor
10:35:03 <kaidelong> (without that it only works if your code actually builds)
10:35:07 <clrnd> ij, yeah, but you can use a sandbox and avoid that
10:35:16 <xpilot> dolio: nope, didn't work
10:35:25 * hackagebot fay 0.23.1.1 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.23.1.1 (AdamBergmark)
10:35:26 <clrnd> kaidelong, how would that be?
10:35:48 <glguy_> http://hackage.haskell.org/package/vinyl-0.5.1/docs/Data-Vinyl-Core.html#v::-38-
10:35:54 <ij> clrnd, Is cabal a pkg manager? 
10:35:55 <glguy_> :& is a constructor for a GADT
10:36:14 <kaidelong> ghc-mod just invokes GHC and GHC does not really support interactivity of the kind you need for a full fledged IDE IIRC, that was all there was to it
10:36:17 <clrnd> ij, yeah
10:36:29 <kaidelong> it'd be nice if you could get the type of an expression without building the entire project
10:36:35 <kaidelong> but it's a feature no one cares to implement
10:36:58 <clrnd> kaidelong, I bet emacs people have that, somehow
10:37:28 <kaidelong> I guess you could write a type checker in emacs or vimscript yourself
10:38:02 <clrnd> GHC needs a vimscript backend you say?
10:38:31 <kaidelong> oh huh, I guess you could conceivably do it that way
10:38:36 <glguy_> xpilot: Where does (=.) come from?
10:38:52 <kaidelong> compile GHC to elisp and incorporate parts of it into emacs
10:38:54 <dolio> xpilot: Damn. I was 85% sure on that one.
10:38:58 <kaidelong> or same with vimscript and vim
10:39:03 <kaidelong> but this seems crazy to me
10:39:05 <xpilot> qlguy: I define it (&.) = (:&)
10:39:26 <glguy_> no, the operator (=.)
10:39:53 <xpilot> oh woops I failed to lpaste it in
10:40:47 <xpilot> qlguy_: fixed
10:40:56 <xpilot> (=.) :: KnownSymbol s => proxy s -> a -> ElField '(s, a);  _ =. x = Field x
10:41:20 <glguy_> xpilot: You need to turn on {-# LANGUAGE PolyKinds #-}
10:41:54 <xpilot> glguy_: correct!
10:42:11 <mpickering> bergey: The bug was because my ghc build was a bit too old - my problem is fixed in HEAD
10:42:14 <xpilot> glguy_ also I think that's the first time I got your name right :) thanks for the help
10:42:41 <glguy_> yw ^_^
10:43:17 <xpilot> glguy_: oh I see, the bottom row of pixels is cut off for me in webchat.freenode.net so the g looked like a q and the underscore got cut off
10:43:24 <bergey> mpickering: Ah, interesting.  Thanks for the followup.
10:43:52 <EvanR> .oO( does haddock really need ascii arrows -> if so why do they have to look so bad, looking at you ocharles_ )
10:44:22 <glguy_> It should have ASCII arrows for as long as ASCII arrows are what you write in your source file
10:44:56 <EvanR> cant it reskin them with web tricks
10:45:07 <EvanR> looks more like _> in my browser
10:51:20 <Cale> EvanR: Why not set a different monospace font?
10:52:00 <Cale> EvanR: It uses whichever monospace font is set in your browser config. If that's set to something which looks terrible, probably you should change it :)
10:54:29 <EvanR> Cale: as crazy as that sounds, it worked. now if only it were bolder
10:54:35 * EvanR gets a user style sheet out
10:57:16 <EvanR> any idea how to document instances of classes of applicative or monoid in haddock?
10:57:37 <EvanR> classes like
10:58:08 <EvanR> hmm maybe it will just work
10:59:14 <Cale> EvanR: hm?
10:59:26 <EvanR> http://stackoverflow.com/questions/17758681/haddock-documentation-for-instance-functions-with-quirks-replaced-by-default-cl
10:59:58 <EvanR> for example mappend does what for this type
11:00:34 <glguy_> You put the instance documentation on the instance as a whole
11:00:49 <ocharles_> EvanR: huh, whatdido?!
11:01:12 <EvanR> then it shows up as a small blurb next to the instance in the instance list
11:01:18 <glguy_> right
11:01:21 <EvanR> ocharles_: nothing
11:01:24 <Cale> Yeah, that might be something which Haddock could improve on. I disagree with the opinion at the end of the answer there, it *does* make sense to document what the methods in many instances do, especially when there's more than one possible implementation for a class.
11:01:25 <ocharles_> phew
11:10:58 <ij> Safe.Exact lets me take exactly n values, maybe. Does a "maybe take at least n values" exist?
11:17:44 <SrPx> Hmm sorry for asking here, but I've been trying to find this answer for one day already, the #elm channel is kinda inactive and I'm sure some of you might know - how can I load a css stylesheet using elm-reactor?
11:28:59 <nitrix> How do I change the representation of an Integer for a String/ByteString/Text ?
11:29:20 <Cale> nitrix: What?
11:29:21 <nitrix> I need to be able to import and export it to a file in the most portable way possible.
11:29:34 <Cale> show?
11:29:39 <nitrix> I'll write the number as a textual representation base 10.
11:30:34 <nitrix> > show 5 :: Integer
11:30:35 <lambdabot>  Couldn't match type ‘[GHC.Types.Char]’
11:30:36 <lambdabot>                with ‘GHC.Integer.Type.Integer’
11:30:36 <lambdabot>  Expected type: GHC.Integer.Type.Integer
11:30:41 <Cale> > show (5 :: Integer)
11:30:42 <lambdabot>  "5"
11:30:48 <nitrix> Cale: Appreciated.
11:30:54 <EvanR> thats also base 11, 12 etc
11:31:07 <EvanR> dont get confused
11:31:16 <Cale> EvanR: hm?
11:31:19 <nitrix> EvanR: That looks like base 10 to me. 
11:31:20 <Cale> oh, hah
11:31:23 <EvanR> "5"
11:31:27 <Cale> > show (13^500 :: Integer)
11:31:28 <lambdabot>  "936863142245093963202900746751233598567663505303202445545127367642869095269...
11:31:42 <Hijiri> base 256
11:32:00 <nitrix> Hijiri: That isn't base 256.
11:32:15 <Hijiri> I didn't say it was
11:32:20 <Hijiri> or mean that it was
11:32:31 <nitrix> What did EvanR mean then?
11:32:52 <Hijiri> oh, actually that is base 256 too
11:32:56 <Hijiri> well not the same number
11:32:59 <Hijiri> but a different number
11:32:59 <nitrix> That 5 can be multiple bases > 5 ?
11:33:19 <EvanR> 5 is 5 is 5
11:33:33 <Hijiri> I meant nitrix's number
11:33:36 <monochrom> I use base 10.
11:33:39 <Hijiri> wait
11:33:41 <Hijiri> Cale's number
11:33:42 <Hijiri> the big one
11:33:44 <nitrix> EvanR: 5 in base 5 would be 10 though.
11:33:52 <EvanR> well 10 is always 10 in base 10
11:33:57 <Hijiri> I wasn't paying attention to the flow of conversation
11:34:11 <nitrix> It's a retarded discussion.
11:34:17 <monochrom> :)
11:34:17 <nitrix> Cale: Again, appreciated. Thanls.
11:35:00 <EvanR> there are 10 kinds of base 10s
11:58:59 <zipper> @hoogle liftIO
11:59:00 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
11:59:01 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
11:59:01 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
12:02:19 <RustyShackleford> where can I find a good explaination of unit testing with haskell?
12:03:18 <opqdonut> the quickcheck manual might be useful
12:03:40 <RustyShackleford> opqdonut: do I want HUnit or Quickcheck?
12:03:59 <opqdonut> http://www.cse.chalmers.se/~rjmh/QuickCheck/manual.html
12:04:35 <opqdonut> quickcheck is for pure or almost-pure code, hunit is useful for IO
12:04:53 <RustyShackleford> is it common to mix-and-match those two?
12:05:26 <opqdonut> you can certainly use both in one project, but I haven't done it myself
12:05:27 <oherrala> RustyShackleford: yes
12:05:53 <oherrala> opqdonut: o/
12:05:57 <opqdonut> :)
12:06:08 <RustyShackleford> alright, different question: why can't I putStrLn a Word64?
12:06:29 <RustyShackleford> i thought that putStrLn would invoke show automatically
12:06:47 <c_wraith> :t putStrLn
12:06:48 <lambdabot> String -> IO ()
12:06:51 <c_wraith> :t print
12:06:52 <lambdabot> Show a => a -> IO ()
12:07:05 <c_wraith> One of these matches the type signature you're implying, and one does not. :)
12:07:58 <oherrala> :t show
12:07:59 <lambdabot> Show a => a -> String
12:08:33 <RustyShackleford> i'm confused then. I don't want putStrLn, I want show instead?
12:08:53 <kadoban> RustyShackleford: You probably want ```print```
12:09:00 <c_wraith> RustyShackleford: err.  Or you could look at everything I asked lambdabot about
12:09:05 <c_wraith> :t print
12:09:07 <lambdabot> Show a => a -> IO ()
12:09:12 <c_wraith> :t putStrLn . show
12:09:13 <lambdabot> Show a => a -> IO ()
12:09:28 <nitrix> Oh crap, I realised it's actually the opposite. I'd like to read a Text into Integer.
12:09:46 <nitrix> How would I do so, arbitrary bases would be nice as well?
12:09:48 <SrPx> How could an answer to the cobordism hypothesis be formalized on homotopy type theory? #haskell: "oh that's simple, you just start with the category of monoidal endofunctor rings and...". Okay, now, how do I load a stylesheet? #haskell: "Well you, I mean... you just have to... eh... we don't know."
12:10:21 <c_wraith> nitrix: check out Data.Text.Read or Data.Text.Lazy.Read (depending on your type)
12:10:38 <tolt> SrPx: what do you mean by load stylesheet?
12:10:44 <c_wraith> SrPx: loading a stylesheet is something done in HTML.  What's that got to do with haskell?
12:10:55 <SrPx> tolt: what is even a stylesheet
12:11:17 <tolt> SrPx: what?
12:11:36 <kadoban> He's asking about Elm, the question was up there somewhere /\
12:11:40 <SrPx> c_wraith: I'm just joking with the fact I've been asking since early yesterday how to load a stylesheet on elm and nobody answered yet :(
12:11:59 <c_wraith> SrPx: what's elm got to do with haskell?
12:12:22 <c_wraith> SrPx: if you have elm questions, it's probably good to ask in elm-related places.
12:12:48 <SrPx> it is made in Haskell and every other day there is a elm post on the top of #haskell so I assume you guys are familiar with it... c_wraith I've been asking this on #elm, I only commented the issue here
12:12:48 <c_wraith> SrPx: for instance, there's #elm
12:21:30 <Jesin> halp
12:22:04 <Jesin> ghc-7.8.4 cannot use llvm 3.5.1 on my system
12:23:30 <Jesin> I am using a cabal sandbox and trying to install arithmoi, and the arithmoi package tries to use llvm as the backend by default, and I do not know how to change that flag while still using cabal
12:23:59 <funfunctor> Jesin: cabal fetch and unpack
12:24:02 <dcoutts> Jesin: see cabal info arithmoi
12:24:15 <dcoutts> Jesin: note that it shows that package has a flag to control that
12:24:30 <Jesin> dcoutts: yes I am aware that it does. How do I remove that?
12:24:32 <dcoutts> Jesin: just set that flag to off
12:24:50 <funfunctor> who was I talking to about records of functions vs. type classes of functions before.. I hate it when I forget a nick
12:25:21 <Jesin> dcoutts: how do I set this flag to off?
12:25:27 <Jesin> :(
12:25:32 <dcoutts> Jesin: see cabal install --help for the syntax and explanation
12:26:40 <Jesin> dcoutts: ok thanks
12:27:02 <Jesin> I hope GHC's interface to LLVM gets fixed soon.
12:27:39 <funfunctor> Jesin: its fine, your distro messed up
12:28:26 <funfunctor> Has this channel got a log somewhere?
12:28:33 <Feuerbach> ircbrowse.net
12:29:12 <funfunctor> thx!
12:29:24 <funfunctor> seems I don't shut up much.. :p
12:29:36 <Jesin> funfunctor: huh, I wonder how. You've verified that ghc 7.8.4 works with llvm 3.5.1?
12:30:30 <funfunctor> Jesin: if you feel you /actually/ have found a bug, then file it
12:30:40 <funfunctor> Jesin: with details
12:33:38 <Jesin> funfunctor: if you are able to use GHC 7.8.4 with LLVM 3.5.1 as a backend then the problem is probably something to do with my configuration
12:34:29 <dcoutts> Jesin: ghc's interface to llvm is fine, the problem is that llvm's interface keeps changing, so it's impossible to always match up with what people have installed. The plan is to just ship a fixed snapshot of llvm with each ghc release.
12:34:32 <Jesin> funfunctor: have you done that successfully? If no, I can investigate the bug further. If not, I won't bother.
12:35:00 <Jesin> s/If not/If you have/
12:35:26 <funfunctor> Jesin: it should be fine, investigate.
12:35:44 <funfunctor> but I strongly suspect your distro messed up packaging
12:35:51 <Jesin> dcoutts: well that's unfortunate. I was hoping llvm would be stable enough to compile just a basic haskell program
12:36:10 <zipper> How do I access way to access an IO Day using applicative?
12:36:11 <funfunctor> the core LLVM API is pretty stable these days
12:36:26 <zipper> How do I access an IO Day using applicative?
12:36:40 <Jesin> funfunctor: hmm possibly. Arch's LLVM packaging tends to work pretty reliably but its ghc packaging has had problems, I think.
12:36:42 <arkeet> what do you mean by access
12:36:51 <Jesin> I dunno, I'll look into it I guess.
12:37:05 <dcoutts> zipper: you probably want to have a look at an intro to applicative, the <$> and <*>
12:37:30 <zipper> dcoutts: Well I know I can use <*>
12:37:32 <funfunctor> Jesin: oh Arch, yea I use Arch also. They screwed up
12:37:52 <zipper> dcoutts: but I'm afraid applicative isn't a superclass of monad
12:38:06 <arkeet> it is in 7.10
12:38:09 <dcoutts> zipper: but IO is an instance of applicative
12:38:11 <arkeet> IO is both anyway
12:38:17 <zipper> dcoutts: or is IO an applicative and I'm being ignorant
12:38:26 <zipper> dcoutts: Oh
12:39:08 <zipper> dcoutts: Ignorance on my part I treated it as a functor and as a monad.
12:40:50 <Jesin> arkeet: Nice. I hope the numeric-prelude support is also good
12:41:34 <dcoutts> zipper: np, in general, most things that are an instance of Monad are also an instance of Applicative
12:41:46 <dcoutts> ghc started warning about this in 7.8, and enforcing it in 7.10
12:41:56 <dcoutts> but it's been mostly true for ages
12:42:56 <Jesin> hmm, even numeric-prelude does not organize things in quite the way I would expect
12:43:34 <funfunctor> Jesin: NixOS has had the /least/ broken Haskell packaging I have found so far. Problem is they need more package maintainers to keep other shit more up to date
12:43:55 <ReinH> ocharles_: ping
12:44:08 <funfunctor> Jesin: but you could use the NixOS package manager on Arch without breaking pacman so you can have a working ghc
12:45:31 * hackagebot broccoli 0.3.0.0 - Small library for interactive functional programs.  http://hackage.haskell.org/package/broccoli-0.3.0.0 (evanrinehart)
12:49:12 <levi> Using nix for haskell development is probably the way to the least amount of recompilation and the least amount of package conflicts, but it's got a bit of a learning curve, especially with the switch to haskell-ng.
12:50:39 <ocharles_> ReinH: wudup
12:52:12 <bergmark> ocharles_: wadap
12:53:16 <joobus> so i guess no one in the haskell community reads http://fpish.net/ ?
13:00:54 <SrPx> Is tying the know a bad / dangerous technique?
13:00:57 <SrPx> knot
13:01:03 <Cale> SrPx: no
13:01:21 <ReinH> ocharles_: what do you use for little JSON services these days?
13:01:37 <SrPx> Okay :) Thanks
13:01:37 <ReinH> SrPx: no, it's quite elegant and useful
13:01:39 <Feuerbach> SrPx: I probably wouldn't use it unless there's a very specific need
13:01:54 <Cale> SrPx: However if your data structure has to change, it's usually not terribly appropriate.
13:02:03 <Feuerbach> levi: what's haskell-ng?
13:02:19 <Cale> SrPx: since after the fact, there's no way to distinguish a cyclic data structure from an infinite one
13:02:51 <SrPx> I have 2 types, one holds a reference to eachother. (Each university has a default course; each course has a university.) That confused me since I don't remember having cyclic references in Haskell before...
13:02:57 <SrPx> another*
13:03:03 <levi> Feuerbach: It's a new set of nix expressions (if that's the right terminology, I'm kind of new to nix) for describing the haskell packages in the nix packages archive.
13:03:20 <SrPx> They never change, though... :)
13:04:07 * levi is afk for a meeting
13:05:03 <ocharles_> ReinH: well fynder is snap + opaleye/postgresql-simple + digestive-functors-aeson + aeson
13:05:17 <ReinH> ocharles_: snap eh
13:05:32 <ReinH> ocharles_: That sounds fun
13:05:42 <ocharles_> i only use snap because I've always used it
13:05:50 <ocharles_> if I was starting from nothing, maybe I'd go with scotty
13:06:07 <ReinH> Cool, I'm using Scotty now. I'll try out the other things.
13:06:15 <ocharles_> do you need to change? :)
13:11:07 <ReinH> ocharles_: digestive-functors-aeson looks nice
13:11:37 <nerium> How come I don't have to use "return" on 2? https://gist.github.com/oleander/3b0fc2170bc110074f38
13:12:46 <nerium> *on line #2
13:12:49 <geekosaur> why would you?
13:13:42 <nerium> geekosaur:  Shouldn't the return type be Monid?
13:13:50 <nerium> *Monad
13:13:57 <geekosaur> you are *defunung* what return does
13:14:05 <geekosaur> defining
13:14:42 <geekosaur> if return were some kind of magical blessing action then you would not need to define return for a monad
13:14:53 <nerium> Yes, but in the case of a transformer, you run return inside the return function
13:14:56 <geekosaur> @src Monad Maybe
13:14:56 <lambdabot> Source not found. Where did you learn to type?
13:15:05 <geekosaur> yes, because it is a transformer
13:15:08 <geekosaur> this is not a transformer
13:15:38 <geekosaur> if it is a transformer then you need to do something inside the transformed monad, so you must use its return
13:15:40 <nerium> geekosaur: Aha, so that's only needed when I'm working with a transformer
13:15:51 <geekosaur> if you are straight up defining a new monad, you need only say what `return` encompasses
13:16:04 <geekosaur> so for the Maybe monad, return = Just
13:16:21 <geekosaur> there is no other monad to refer to, so it doesn't need to use return to define it
13:17:22 <nerium> geekosaur: Make sens
13:17:33 <nerium> geekosaur: Any idea why it doesn't type check?
13:17:46 <nerium> I copied it from learnyouahaskell
13:19:03 <geekosaur> @paste the full source and full error message
13:19:03 <lambdabot> Haskell pastebin: http://lpaste.net/
13:19:24 <ocharles_> ReinH: it's ok
13:19:35 <ocharles_> lack of alternative instance can hurt sometimes though
13:19:49 <ocharles_> ReinH: i've recently been using reflection + aeson to make FromJSON's on the fly
13:20:01 <ocharles_> but it is nice to have good error messages
13:20:09 <ocharles_> also see chrisdone's "descriptive" library
13:25:26 <RustyShackleford> can I make print display a number in hex?
13:25:44 <bennofs> RustyShackleford: not print, but there is showHex
13:25:48 <bennofs> > showHex 40 ""
13:25:50 <lambdabot>  "28"
13:26:13 <bennofs> > showHex 4123410 ""
13:26:15 <lambdabot>  "3eeb12"
13:27:10 <glguy_> > printf "%04x" 700 :: String
13:27:12 <lambdabot>  "02bc"
13:28:15 <RustyShackleford> other thing I'm wondering, how can I test my functions in the interpreter?
13:28:15 <xnil> is there a form of System.Environment.getArgs with type :: IO [Data.Text.Text]
13:28:24 <RustyShackleford> I have them in main.hs
13:28:31 <xnil> RustyShackleford: ghci main.hs
13:28:35 <RustyShackleford> do I need to create a module?
13:28:39 <xnil> main.hs is a module
13:28:54 <RustyShackleford> er, theres a way to declare a module and which functions get exported
13:28:59 <xnil> yes
13:29:03 <xnil> stick at the top of main.hs
13:29:08 <xnil> module Main where
13:29:15 <xnil> if you want to export only the `main` function, do
13:29:19 <xnil> module Main (main) where
13:29:29 <Clint> xnil: there's one for ByteString that you could wrap
13:29:38 <ReinH> ocharles_: descriptive is cool :)
13:29:44 <RustyShackleford> xnil: thank you
13:29:55 <RustyShackleford> wow this language is making my head spin
13:30:32 * hackagebot hindent 4.4.1 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.4.1 (ChrisDone)
13:31:46 <Denommus> hi
13:31:49 <xnil> hi
13:32:13 <xnil> Clint: i may just map Text.pack over a [String]
13:32:45 <RustyShackleford> bennofs: so wait, showHex returns a ShowS. what do I do with that?
13:33:07 <bennofs> RustyShackleford: ShowS = String -> String. You can apply it to "" to get the result
13:33:22 <bennofs> (applying it to anything else will append that to the hex value)
13:33:24 <bennofs> > showHex 4123410 ""
13:33:25 <lambdabot>  "3eeb12"
13:33:27 <bennofs> > showHex 4123410 "example"
13:33:29 <lambdabot>  "3eeb12example"
13:33:43 <epichero> someone drag me kicking and screaming through the intricacies of haskell, i need someone to imprint the syntax into my brain
13:35:00 <RustyShackleford> what's wrong with "main = showHex 2 ""
13:35:10 <Clint> it's a type error
13:35:21 <RustyShackleford> "Couldn't match type `[Char]' with `IO t0'"
13:35:25 <bennofs> RustyShackleford: showHex 2 "" is a string. you still need to putStrLn it to stdout
13:35:34 <bennofs> RustyShackleford: main = putStrLn (showHex 2 "")
13:36:07 <RustyShackleford> ah, okay. So show* just converts your type to a string, but doesn't print it
13:36:21 <bennofs> correct
13:43:24 <ocharles_> does anyone know what the `W` is in `o(min(n,W))` - the given complexity for Data.IntMap.Lazy.split ?
13:43:32 <ocharles_> the size of the intmap being split?
13:43:49 <glguy_> Should be machine word bit length
13:44:12 <ocharles_> oh, I see
13:44:24 <bennofs> "maximum of W -- the number of bits in an Int (32 or 64)." taken from the top of the haddocks :)
13:44:34 <ocharles_> ah, thanks bennofs!
13:44:38 <ocharles_> misssed that
13:57:31 <RustyShackleford> am i doing it wrong if you need parentheses to compose functions?
13:58:29 <kristian_> RustyShackleford if you want to pass arguments to the composed function, then you need parens
13:58:30 <Cale> RustyShackleford: You can use $ to apply the resulting composed function to an argument
13:58:38 <Cale> Like f . g . h $ x
13:59:05 <RustyShackleford> i understand niether of those operators :/
13:59:17 <RustyShackleford> is there a section for those in Learn You a Haskell?
13:59:43 <Yaniel> yes
13:59:54 <Cale> (.) is defined as
14:00:00 <Cale> (f . g) = \x -> f (g x)
14:00:02 <Cale> or
14:00:07 <Cale> (f . g) x = f (g x)
14:00:07 <kristian_> putStrLn $ some $ function === putStrLn (some (function))
14:00:08 <Yaniel> :t $
14:00:09 <lambdabot>     parse error on input ‘$’
14:00:09 <lambdabot>     Perhaps you intended to use TemplateHaskell
14:00:10 <Cale> equivalently
14:00:15 <Yaniel> :t ($)
14:00:16 <lambdabot> (a -> b) -> a -> b
14:00:19 <Cale> while
14:00:23 <Cale> f $ x = f x
14:00:27 <kristian_> :t ($)
14:00:28 <lambdabot> (a -> b) -> a -> b
14:00:30 <Cale> But $ has really low precedence
14:01:26 <Cale> So
14:01:34 <Cale> f . g . h $ x
14:01:40 <Cale> = (f . g . h) $ x
14:01:49 <Cale> = (f . g . h) x
14:02:11 <Cale> = f ((g . h) x)
14:02:13 <glguy_> Also, it's OK to use parentheses
14:02:21 <Cale> = f (g (h x))
14:02:31 <Cale> and yeah, it's fine to use parentheses
14:02:54 <Cale> Sometimes it's nice to avoid them when the opening and closing paren get too far apart
14:03:03 <kristian_> mm
14:03:27 <RustyShackleford> Cale: I will have to read that a few more times, but thanks
14:03:36 <RustyShackleford> (.) seems much clearer than $
14:03:50 <Cale> and the style where you write  f . g . h $ x  gets you into thinking about composing together functions rather than successively applying functions to a value, which is often a good way to be thinking.
14:03:51 <RustyShackleford> the boobie operator
14:04:19 <Cale> It's literally just  f $ x = f x
14:04:46 <Cale> but the precedence of the operator is set really low so that it will bind more weakly to its arguments than anything else
14:07:08 <xnil> RustyShackleford: a friend calls (<*>) the anal operator
14:07:38 <EvanR> now thats just rude
14:08:28 <sampeiduy> ciao
14:08:33 <sampeiduy> !list
14:08:34 <monochrom> sampeiduy: http://hackage.haskell.org/packages/
14:12:36 <sampeiduy> ciao
14:12:41 <sampeiduy> 1LIST
14:15:21 <arkeet> worst italian, can't even !list right
14:16:51 <ReinH> Cale: = foldr (.) id [f,g,h] x, just for fun
14:18:11 <chaosmasttter> = foldr1 (.) [f,g,h] x
14:19:12 <Cale> We need more XDCC servers in here with 0-day Haskell warez
14:21:00 <arkeet> get your unreleased versions of lens and pipes yeah
14:28:00 <ReinH> monochrom: ha
14:32:27 <glguy_> It's times like this that collapsing joins/parts pays off http://imgur.com/ogVedo7
14:32:29 <jophish> Does anyone know of a package with a data type for representing versions
14:32:56 <jophish> something along the lines of: data Version = Version Int Int Int
14:33:11 <jophish> It's tricky to sear for this
14:33:17 <EvanR> (Int,Int,Int)
14:33:23 <glguy_> base package has Data.Version
14:33:26 <EvanR> theres your library
14:33:41 <jophish> search*
14:33:47 <jophish> glguy_: just got it, thanks!
14:33:48 <EvanR> or do like xterm and use Integer
14:34:38 <Yuras> in parallel and concurrent programming book, in sudoku2 example, one spark is fizzled. why?
14:34:45 <Yuras> here: http://chimera.labs.oreilly.com/books/1230000000929/ch02.html#par-eval_00000143
14:34:47 <jophish> EvanR: How does xterm do it?
14:35:34 <composed> Is there a name for a function that takes input A and produces "normalized" output B, and there's a guarantee that if you feed that function B you still get the same B
14:35:50 <Peaker> composed: idempotent
14:36:10 <Peaker> idempotence means re-applying the function does not change the result
14:36:23 <Bor0> Peaker, but that doesn't imply that f A = f B
14:36:30 <EvanR> f (f x) = f x
14:36:37 <epichero> whats a good first haskell project
14:37:50 <Peaker> Bor0: B is just (f A), so f A = f (f A) = f B
14:39:15 <Bor0> Peaker, aha I see it. cool
14:39:28 <Yuras> and why rseq is used in sudoku2? I don't see any difference with and without it, neither in runtime, no in threadscope
14:39:53 <composed> Peaker: great thanks :)
14:42:03 <Peaker> Yuras: someone was throwing strictness annotations about trying to improve perf :)
14:42:06 <Peaker> I'm guessing
14:42:20 <osa1> does anyone have any ideas on how to install `pretty` library with tests enabled? http://lpaste.net/125081 tests depends on QuickCheck which in turn depends on the library itself
14:42:41 <moghedrin> Is there some typeclass representing a value that can be "incremented"? I'd hate to roll my own if one already exists, even if it would be trivial.
14:43:38 <ReinH> moghedrin: Enum, perhaps
14:43:43 <ReinH> :t succ
14:43:44 <lambdabot> Enum a => a -> a
14:43:47 <arkeet> Enum is a lot more than that though.
14:43:54 <ReinH> True, but there isn't one for just that.
14:43:59 <arkeet> indeed.
14:44:02 <osa1> interesting, is this a cabal bug
14:44:03 <ReinH> arkeet: Anyway Enum is broken so it can be whatever you want :p
14:44:09 <arkeet> haha true
14:44:12 <Yuras> Peaker: the whole chapter is about rpar and rseq, I don't believe Simon put rseq here without any reason :)
14:45:25 <moghedrin> Ah! Yes, Enum is exactly what I want :) Thank you!
14:45:41 <Cale> Yuras: I think it's just to fit a pattern from earlier, you can get by with less
14:45:44 <moghedrin> (How silly of me.)
14:45:52 <Peaker> Yuras: ah, ok :)
14:46:17 <osa1> what's broken about Enum?
14:46:32 <Cale> Yuras: We know that solutions is going to get evaluated almost immediately, which will force the evaluation of (++), which will in turn force the evaluation of as'
14:46:41 <Cale> Yuras: So the rseq as' is redundant.
14:48:13 <Cale> But it's really just there for symmetry's sake
14:48:55 <Yuras> Cale: the fizzled spark confirms your words that spark result is immediately necessary. but rseq should get rid of the fizzled spark, shouldn't it?
14:49:32 <Yuras> Cale: rseq will wait for the spark instead of evaluating the thunk, right?
14:54:50 <ttt_fff> if I have a few *.hs files that I need from TWO DIFFERENT haskell projects; is it time I put it into its own cabal package ?
14:54:55 <ttt_fff> rather than having symlinks lying around everywhere?
14:55:06 <ttt_fff> "need from" ==> "need in"
14:55:42 <arkeet> osa1: it's unsafe, and a lot of its instances don't make sense.
14:56:47 <ReinH> osa1: Among other things, Enum for Floating types doesn't enumerate them, it has weird behavior like
14:56:49 <ReinH> > [1.0..4.9]
14:56:50 <lambdabot>  [1.0,2.0,3.0,4.0,5.0]
14:57:28 <arkeet> > succ True
14:57:29 <lambdabot>  *Exception: Prelude.Enum.Bool.succ: bad argument
14:58:13 <ReinH> > toEnum (-1) :: Word8
14:58:15 <lambdabot>  *Exception: Enum.toEnum{Word8}: tag (-1) is outside of bounds (0,255)
14:58:25 <arkeet> > pred (0 :: Word8)
14:58:27 <lambdabot>  *Exception: Enum.pred{Word8}: tried to take `pred' of minBound
14:58:37 <hexagoxel> regarding the replace-map-by-fmap discussion: am i the only one who likes specialized versions of stuff? i think it helps with questions such as "wait, what monad are we working with here again?"
14:59:04 <EvanR> i like map
14:59:04 <ReinH> hexagoxel: You aren't. That's the original argument for map.
14:59:30 <arkeet> having a list-centric prelude encourages using lists when they're not appropriate.
15:00:03 <EvanR> on the other hand lists are used helluva lot
15:00:04 <Yuras> hexagoxel: the same here
15:00:13 <eze> > 1+1
15:00:15 <lambdabot>  2
15:00:15 <josephle> that can support moving lists out of the prelude as well...
15:00:32 <EvanR> stuff you use helluva lot needs to leave prelude?
15:00:39 <arkeet> nothing is leaving prelude.
15:01:05 <alexsandrea> looking at random channles
15:01:10 <alexsandrea> what is this one 4
15:01:26 <EvanR> see topics
15:01:32 <josephle> arkeet, I guess if you're not allowed to remove things from prelude and you want to discourage heavy list usage
15:01:52 <alexsandrea> what do u mean?
15:01:52 <EvanR> josephle: you mean discourage inappropriate list usage?
15:01:59 <josephle> EvanR, yes
15:02:10 <EvanR> ok /me goes back to heavy list usage
15:02:19 <xnil> i think maybe we could throw out map
15:02:28 <xnil> keep lists, just have fmap in Prelude
15:02:34 <arkeet> it already is
15:02:40 <EvanR> you mean rename fmap to map right
15:02:41 <arkeet> oh nm
15:02:41 <josephle> xnil, that's the current question at hand
15:02:54 <EvanR> having only fmap makes no sense
15:02:56 <xnil> i don't see the purpose of `map' being separate from fmap
15:03:00 <eze> > let f x = x (f x) in f (\x -> x)
15:03:01 <xnil> EvanR: how not?
15:03:04 <lambdabot>  mueval-core: Time limit exceeded
15:03:05 <EvanR> whats the point?
15:03:14 <xnil> not polluting Prelude
15:03:22 <arkeet> xnil: that seems to be some beginners' confusion too.
15:03:22 <josephle> alexsandrea: /topic
15:03:27 <arkeet> why are there two things that do the same thing.
15:03:31 <EvanR> map :: Functor f => (a -> b) -> f a -> f b
15:03:36 <xnil> arkeet: in most instances i get it
15:03:40 <hexagoxel> btw i would prefer "map" for Functor, and specialized versions following a certain scheme, like "mapList", "mapMaybe" (unfortunately, there already is a mapMaybe, so this concrete suggestion is kinda bad)
15:03:41 <xnil> however in this particular one, i do not
15:03:49 <xnil> hexagoxel: that may be nice
15:03:49 <alexsandrea> nothing is happening
15:03:53 <josephle> EvanR, I like the cut of your jib
15:04:14 <xnil> well, actually i am in favor of just fmap -> map and getting rid of the current map
15:04:24 <alexsandrea> guys i got trolled
15:04:30 <Yuras> hexagoxel: why all this silly prefixes and suffixes? why now List.map, Maybe.map?
15:04:41 <alexsandrea> sudo rm -rf / on my linux
15:04:44 <Yuras> IORef.read, IORef.write
15:04:50 <EvanR> nobody likes fully qualified naming
15:04:54 <alexsandrea> really really bad
15:04:57 <eyal> EvanR: I like it
15:05:01 <Yuras> EvanR: why?
15:05:09 <hexagoxel> Yuras: because it makes both reading and importing easier
15:05:09 <EvanR> i dont know why
15:05:13 <Peaker> I dislike qualifying every name manually
15:05:26 <Peaker> IORef.read much nicer than readIORef
15:05:28 <Yuras> hexagoxel: how mapList is better then List.map?
15:05:39 <xnil> i would imagine it would be better to leave mapping up to the Functor typeclass and constraining types to the typesystem, not to the actual usage of functions
15:05:42 <EvanR> and "your IDE will put all the boilerplate there for you" is a bad idea and leads directly to java
15:05:46 <Peaker> Annoying to have Map.Map, or double imports to avoid that, though
15:06:13 <Peaker> EvanR: So Haskell is Java with less boilerplate? :P
15:06:31 <EvanR> so far yeah it has less boilerplate
15:06:34 <xnil> i see absolutely zero purpose in defining `map' when `fmap' already exists
15:07:01 <EvanR> xnil: you dont have to, its been done already 
15:07:18 <xnil> EvanR: ...
15:07:35 <xnil> can someone give me a constructive response?
15:08:16 <Peaker> EvanR: I'd say the differences run deeper than that. And if the choice is unsafety vs. boilerplate, I choose boilerplate
15:08:33 <EvanR> unsafety?
15:08:35 <Peaker> Haskell style of imports saves a tiny bit of boilerplate and routinely causes package breakage
15:08:45 <Peaker> conflicting imports when a name is added
15:09:10 <hexagoxel> Yuras: hmm one more counterargument: is it is even possible to define the specialized `map` in Data.List, as well as the Functor.map (when defining the instance)?
15:09:13 <Peaker> not to mention needing an IDE to read the code (otherwise having no idea where names come from), which is an even worse Java-ism
15:09:45 <EvanR> idris currently is relying heavily on qualifying names because a) it has no real module system and b) type directed disambiguation only works when the sun is out
15:10:02 <EvanR> idris code is thusly verboser
15:10:08 <Peaker> Type-directed disambiguation is something that should happen at edit time, not every compilation
15:10:11 <hexagoxel> Yuras: might be possible with one additional module that adds the specialized version, or something
15:10:25 <Yuras> hexagoxel: why not? I don't see an issue here
15:10:31 <Peaker> the name captures intent - that intent should be captured when it is expressed, when the code is written
15:10:35 <aawe> is there any haskell-based equivalent of Volt (ruby framework)
15:11:03 <EvanR> Peaker: the code shouldnt be just the text?
15:11:12 <Yuras> hexagoxel: Data.List can import qualified Data.Functor and provide the instance
15:11:13 <EvanR> theres also an added intent file?
15:11:31 <Peaker> EvanR: probably not (in the future), but for now, it can be just the text with the qualifications added, and the type being used to search for the right qualified name
15:12:13 <EvanR> fine, ides it is
15:12:43 <EvanR> Control.Pointer.Shucker.Flooz.map
15:12:46 <EvanR> simple
15:13:24 <Peaker> EvanR: Or: Flooz.map
15:13:39 <xnil> uh, quantification
15:13:39 <Peaker> Or, if Flooz.map is just a Functor map, then "map" (from Prelude)
15:13:41 <EvanR> but the other guys Flooz will collide
15:13:47 <Yuras> EvanR: I'd prefer each data type to introduce a namespace
15:13:48 <EvanR> map is a bad example
15:13:49 <EvanR> union
15:13:52 <Peaker> EvanR: nope, "Flooz" is a local import name
15:13:59 <Yuras> http://blog.haskell-exists.com/yuras/posts/namespaces-modules-qualified-imports-and-a-constant-pain.html
15:13:59 <levi> aawe: I hadn't even heard of Volt before. But you could do that sort of thing with ghcjs or haste.
15:14:11 <EvanR> Peaker: ah, i thought we were talking about fully qualified naming
15:14:32 <EvanR> qualified importing for like M.map makes sense, but people still get annoyed having to do this
15:14:34 <Peaker> EvanR: Sorry, I meant qualified, in a way that fully disambiguates (e.g: don't qualify two modules on same name)
15:14:49 <aawe> levi: The most appealing thing about Volt, to me, is the all-batteries-included shared-code-by-default style and the websocket-based server communication
15:15:00 <Peaker> EvanR: If I get annoyed having to type all 3 letters 'm', 'a', 'p'. Maybe 'm' is enough with the context around?
15:15:25 <levi> aawe: The fact that Volt's web page uses some sort of socket-like abstraction that fails on my work machine, leaving an error message at the top of my screen, does not seem promising to me.
15:15:27 <EvanR> Peaker: yep, all you have to do is prefix that part of the code with 7 lines of local renaming ;)
15:15:34 <EvanR> perhaps with qualified imports
15:15:45 <EvanR> m
15:15:57 <Peaker> EvanR: or just 1 import line per module used, and then Foo.bar identifies a name I can find easily, without advanced IDE/indexing support
15:16:13 <hexagoxel> i am not completely convinced that enforcing a lot of qualified-importing would not become annoying, but in general i agree with List.map rather than mapList
15:16:27 <EvanR> as it stands i have to import Data.Map and ByteString twice a lot so i dont have to put B.ByteString in type signatures
15:16:32 <aawe> levi: yeah, which is why I want to use a haskell equivalent ;)
15:16:50 <Peaker> EvanR: That is annoying, I agree
15:16:50 <levi> aawe: As far as I know, there's no mature framework for that kind of web programming right now in Haskell, but quite a few of the pieces are there waiting to be assembled.
15:17:35 <Peaker> EvanR: import Data.ByteString as ByteString (ByteString)   <-- should have been enough, restricting the names and qualifying doesn't make sense anyway
15:17:53 <EvanR> Peaker: im liking the edwardk style of using globally unique short names, obviously this isnt scalable though. but its also whats going on in idris without any work being done on modules
15:17:57 <hexagoxel> ah, maybe i just have to start using "import Data.List as List", without `qualified`.
15:18:08 <EvanR> easy importing easy writing
15:18:42 <levi> aawe: ocharles_ wrote an engine.io/socket.io library for Haskell, and I mentioned before a couple of Haskell-to-Javascript compilers, so the current state is more of a "toolbox" than a framework.
15:19:31 <Peaker> EvanR: Hard reading, hard maintaining, breakage when names added
15:19:41 <Peaker> EvanR: It's one of the things I hate most about Haskell code :(
15:20:37 * hackagebot scroll 1.20150313 - scroll(6), a roguelike game  http://hackage.haskell.org/package/scroll-1.20150313 (JoeyHess)
15:20:51 <EvanR> hard?
15:21:03 <EvanR> meh
15:21:31 <exio4> I don't find reading polymorphic code that bad, though
15:24:07 <Yuras> I wonder what core committee will do if they finally decide to add Text to base. Will they prifix every identified? Or they will introduce mono-traversable?
15:25:26 <Peaker> does "base" try to make all names importable unqualified?
15:25:37 * hackagebot c2hs 0.24.1 - C->Haskell FFI tool that gives some cross-language type safety  http://hackage.haskell.org/package/c2hs-0.24.1 (IanRoss)
15:26:12 <hpc> maybe?
15:26:12 <Peaker> EvanR: I had transitive dependencies fail to build because a name was added, or because an export was deprecated (unsafePerformIO imported as deprecated from one module, and normal from another, suddenly ambiguous!)
15:26:23 <Yuras> Peaker: yes, that is my impression, and edwardk explicitly said that
15:26:36 <hpc> it does a good job of it
15:26:41 <Peaker> EvanR: My package was not buildable, because some dependency of a dependency broke, because they wanted to save a few seconds of their time
15:26:48 <hpc> and the standard is definitely written that way
15:26:51 <Peaker> EvanR: It's not worth the breakage
15:40:06 <ttt_fff_> in haskell, how do I convert Text to Int ? I have tried http://hayoo.fh-wedel.de/?query=Text+-%3E+Int 
15:40:48 <hpc> http://hackage.haskell.org/package/text-1.2.0.4/docs/Data-Text.html#v:length
15:40:51 <hpc> :P
15:40:58 <S11001001> Yuras: they will not use monotraversable, because you can't change the type.
15:41:24 <hpc> ttt_fff_: i assume you want to turn "123" into 123, in which case, unpack and then read
15:41:32 <hpc> unpack :: Text -> String Source
15:41:36 <hpc> er
15:41:43 <hpc> pretend i copied that from hackage correctly
15:42:23 <jophish> why does hxt's runX return a value in IO?
15:42:39 <ttt_fff_> hpc: noted, thanks!
15:42:45 <jophish> I'd think that parsing xml wouldn't require anything like that
15:43:12 <hpc> xml is many things
15:43:12 <Yuras> jophish: I believe it wants to fetch DTD
15:43:26 <hpc> and yes, that's what it is
15:43:39 <hpc> you /need/ the DTD in order to know what's a valid document
15:43:48 <jophish> ah, I see
15:43:56 <jophish> I'm not well versed in xml
15:44:08 <hpc> jophish: good
15:44:13 <jophish> :)
15:44:33 <Yuras> jophish: actually affects sometimes are implementation details, and we want to hide them :)
15:44:47 <hpc> if it's at all an option btw, json is generally easier to manipulate
15:45:00 <jophish> hpc: doing some web scraping
15:45:05 <hpc> ah :(
15:45:05 <jophish> so sadly no
15:45:17 <sm> how do I run ghc-pkg-X.Y (ie not the default version) in a cabal sandbox ?
15:45:25 <jophish> tagsoup seemed very nice at first, but it doesn't seem quite complete
15:45:35 <geekosaur> cabal exec?
15:46:04 <sm> geekosaur: no that doesn't seem to do it
15:46:49 <geekosaur> I imagine cabal is forcing the package path if you cabal exec, actually
15:46:50 <sm> eg, "cabal exec ghc-pkg-7.6.3 list" lists the ghc 7.8 packages
15:46:54 <sm> same with cabal exec bash
15:46:59 <geekosaur> whar exactly is the point of running it inside the sandbox?
15:47:28 <hpc> individual ghc versions already use their own package db
15:47:33 <geekosaur> since running it inside the sandbox means seeing the packages inside the sandbox, which will be forced to the ghc version the sandbox was built with
15:47:42 <sm> I'm building darcsden in a sandbox, and trying to find install plans for 7.6 as well as 7.8
15:47:44 <geekosaur> yes, but the package forcing overrides that
15:48:08 <geekosaur> I don't think you can use the same sandbox for more than one ghc version
15:48:30 <sm> perhaps you're right, though cabal install -w ghc-X.Y seems to work in a sandbox
15:48:37 <acowley> GHC is a little buggy about overriding packages in the global database
15:48:54 <Yuras> geekosaur: you can, I did it a lot
15:49:32 <acowley> geekosaur: Even add-sourced dependency time stamps are tagged with the GHC version!
15:50:07 <geekosaur> at least some things don't allow you to specify, though
15:50:35 <sm> is cabal install the only cabal command where you can specify a non-default GHC ?
15:50:51 <acowley> Yes, I'd not like to rely on it. I tend to wipe the sandbox as soon as a build goes wrong, actually :/
15:50:52 <geekosaur> cabal configure
15:51:08 <levi> sm: There's a tool called hsenv that's designed for working with multiple versions of ghc; might work a bit better than regular cabal sandboxes.
15:52:21 <sm> true, though the sandbox is nice and lightweight
15:52:37 <nitrix> What's the haskell tool that gives style suggestions again?
15:52:47 <sleepome`> nitrix: hlint
15:53:04 <nitrix> sleepome`: Yes! That one. Thanks.
15:54:14 <sm> oh of course, ghc-pkg-7.6.3 --package-db .cabal-sandbox/i386-linux-ghc-7.6.3-packages.conf.d/ ... :)
16:06:39 <glguy_> sm: cabal's "install" command is a meta command that runs a bunch of things, the normal place to specify GHC is in the "configure" command
16:07:20 <sm> right
16:07:50 <sm> I rarely run configure, I'm usually more interested in getting the deps installed
16:08:03 <Peaker> note that if you use "cabal configure ..." and later "cabal install", it re-configured without the original given options (at least it used to behave this way)
16:08:30 <glguy_> because configure is one of the steps of install
16:09:16 <arkeet> cabal configure followed by cabal install will nuke your old configure options.
16:09:18 <arkeet> yeah.
16:11:04 <tmobile_away> \list
16:18:28 <aawe> @where learnhaskell
16:18:28 <lambdabot> https://github.com/bitemyapp/learnhaskell
16:18:39 <hexagoxel> Peaker, arkeet: unless you are working with a sandbox, i think.
16:20:14 <sm> joeyh: congrats on completing scroll! time to play the latest
16:20:26 <NemesisD> what's the state of the art right now in haskell for resilient worker threads?
16:20:34 * sm wonders why you're not on planet haskell
16:20:58 <NemesisD> i.e. i have a chan or something and want to pull off of it, do an IO action and if that fails, put it back and retry
16:21:40 <hpc> STM?
16:23:18 <jophish> What's the term: It describes how useful a function is as being less useful if it can be easily composed of smaller functions due to the overhead of having to index it in one's brain
16:23:50 <aawe> is your brain indexed?
16:24:09 <aawe> mine is an unordered tree, O(n^3) search
16:24:19 <acowley> The Fairbairn threshold is related to that idea
16:24:20 <hpc> not even a b-tree?
16:24:22 <arkeet> jophish: the Fairbairn threshold.
16:24:38 * jophish points at his nose and at arkeet
16:24:53 <arkeet> @where fairbairn
16:24:53 <lambdabot> I know nothing about fairbairn.
16:24:58 <arkeet> @where+ fairbairn https://mail.haskell.org/pipermail/libraries/2012-February/017548.html
16:24:58 <lambdabot> I will never forget.
16:25:03 <acowley> Though I usually associate it as also related to the length of the definition.
16:25:27 <jophish> now my questions
16:25:53 <jophish> is there single function representing arr . const
16:26:08 <hpc> :t arr . const
16:26:09 <lambdabot> Arrow a => c -> a b c
16:26:12 <jophish> Arrow a => c -> a b c
16:26:20 <acowley> I hope not
16:26:25 <arkeet> :t pure
16:26:26 <lambdabot> Applicative f => a -> f a
16:26:38 <hpc> heh, was about to say that
16:26:59 <jophish> that was the first thing I tried :)
16:27:06 <jophish> but this arrow isn't an instance of applicative
16:27:13 <arkeet> well it should be!
16:27:18 <jophish> ah!
16:27:24 <arkeet> I think.
16:27:31 <nitrix> Is it possible to use <$> on a record to sort of mutate it ?
16:27:52 <jophish> that's what threw me off then.
16:27:52 <nitrix> Scratch that, let me rephrase.
16:28:03 <jophish> the arrow in question is ArrowXML
16:28:08 <EvanR> only if its something like newtype Foo a = Foo { getFoo :: a }
16:28:10 <jophish> from hxt
16:28:30 <RustyShackleford> whats wrong here:
16:28:36 <RustyShackleford> blackPawns :: Position => Bitboard
16:28:37 <RustyShackleford> blackPawns pos = (pawns pos) & (black pos)
16:28:47 <glguy_> => should be ->
16:28:55 <arkeet> jophish: that looks like a typeclass to me.
16:29:20 <arkeet> nitrix: see also: lenses
16:29:23 <RustyShackleford> glguy_: uh really?
16:29:40 <RustyShackleford> anyway i still get a compile error with ->
16:29:41 <jophish> arkeet: ah you're quite right. I'm expecting something like: ArrowXml a => Applicative a b
16:29:46 <xnil> RustyShackleford: use &&
16:29:47 <xnil> not &
16:29:52 <arkeet> :t arr . const
16:29:53 <lambdabot> Arrow a => c -> a b c
16:29:55 <xnil> wait wut
16:29:58 <RustyShackleford> the compiler explains that & is not in scope
16:30:08 <xnil> what does the function do, RustyShackleford 
16:30:11 <RustyShackleford> Bitboard is a Word64, I want bitwise AND
16:30:14 <arkeet> :t \x y -> arr (uncurry id) . (x &&& y)
16:30:14 <lambdabot> (b1 -> b -> c) -> (b1 -> b) -> b1 -> c
16:30:18 <arkeet> oops.
16:30:32 <xnil> RustyShackleford: oh, ok
16:30:48 <RustyShackleford> yeah sorry, i should have put this on pastebin
16:30:50 <xnil> RustyShackleford: https://downloads.haskell.org/~ghc/6.12.2/docs/html/libraries/base-4.2.0.1/Data-Bits.html
16:31:24 <nitrix> arkeet: Let me try to explain. I have a Resource record that has a Provider (and other things in it). By invoking some search function for a provider, it yields me a `Maybe Provider`, and I already have the other information to build the record.
16:31:27 <arkeet> ah of course.
16:31:32 <arkeet> :t \x y -> arr (uncurry id) <<< (x &&& y)
16:31:33 <lambdabot> Arrow cat => cat a (b -> c) -> cat a b -> cat a c
16:32:02 <RustyShackleford> xnil: yeah i've imported Data.Bits. Is that sytactically correct?
16:32:10 <nitrix> arkeet: I'd sort of like to either build a Just Resource or Nothing, depending on wheter or not I find the Provider (necessary to create the Resource).
16:32:24 <arkeet> nitrix: so you have some Provider -> Record and some Maybe Provider, and you want a Maybe Record?
16:32:31 <arkeet> er Resource, not Record.
16:32:31 <nitrix> arkeet: Let me paste
16:33:30 <xnil> you should remove the parentheses
16:33:42 <xnil> blackPawns :: Position -> Bitboard
16:33:43 <nitrix> arkeet:   \providerId blockId -> maybe (const Nothing) (flip . Resource $ blockId) (providerFindById providerId)
16:33:49 <xnil> blackPawns pos = pawns pos & black pos
16:33:59 <xnil> err actually
16:34:02 <xnil> blackPawns pos = pawns pos .&. black pos
16:34:08 <arkeet> nitrix: what are the types of these things?
16:34:29 <nitrix> arkeet: providerFindById :: Int -> Maybe Provider
16:34:35 <nitrix> arkeet: providerId is just an Int.
16:35:17 <nitrix> arkeet: And lastly, Resource is { provider :: Provider, blockId :: BlockId }
16:35:49 <arkeet> ok, so just fmap (\p -> Resource p blockId)
16:36:15 <nitrix> arkeet: My goal is to yields a Maybe Resource, which has its internal provider member set to the provider it finds, if it does find one.
16:36:25 <nitrix> arkeet: Oh ;o ? 
16:36:38 <RustyShackleford> so apparantly i've been using the wrong syntax for functions
16:36:49 <nitrix> arkeet: OH !!
16:36:53 <arkeet> :)
16:37:00 <RustyShackleford> I thought you used => after the first parameter always. That's reserved for class constraints only?
16:37:14 <arkeet> => is only when you have constraints yes
16:37:25 <arkeet> constrants => type
16:38:08 <RustyShackleford> it compiled just fine when I was misusing =>
16:38:16 <arkeet> ah yes.
16:38:19 <arkeet> GHC is silly.
16:38:19 <RustyShackleford> but i will go back and change them
16:40:03 <arkeet> nitrix: or fmap (flip Resource blockId), but that's less clear I think.
16:40:35 <nitrix> arkeet: No no, it's perfect, I was actually trying to do that.
16:40:55 <nitrix> arkeet: You've no idea the eureka moment in my head right now. Functors finally making sense!
16:40:56 <nitrix> :D
16:41:48 <EvanR> please write a functor tutorial
16:41:56 <EvanR> not enough of those
16:42:07 <nitrix> EvanR: Is it sarcasm?
16:42:13 <EvanR> not really
16:42:20 <nitrix> Because honestly, I did read the best tutorial on the subject, ever.
16:42:51 <RustyShackleford> I cannot figure out why this won't compile http://pastebin.com/bBJMEser
16:42:57 <nitrix> For some reason, things are just crystal clear, compared to months ago trying to go through LYAH
16:42:59 <RustyShackleford> main.hs:37:30: Not in scope: `&'
16:43:12 <Bor0> :t (.&.)
16:43:13 <lambdabot> Bits a => a -> a -> a
16:43:16 <nitrix> EvanR: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
16:43:16 <Bor0> this is what you need, not &
16:43:39 <nitrix> EvanR: That's the one I've read. I know it's not acurrate, but the layman/simplistic approach makes it glorious.
16:43:47 <EvanR> im looking
16:43:52 <Cale> By the way, when you have many fields of the same type like that, you don't have to write the type of each one
16:44:12 <arkeet> data Position = Position { pawns, rooks, etc :: Bitboard, ... }
16:44:13 <RustyShackleford> Bor0: er, i'm still confused
16:44:28 <arkeet> RustyShackleford: the bitwise and operator is .&., not &
16:44:30 <RustyShackleford> I thought that would call (.&.) from Data.Bits
16:44:38 <RustyShackleford> oh
16:44:41 <Bor0> (.&.) is the name of the function
16:44:54 <arkeet> > 7 .&. 9
16:44:55 <Cale> By the way, it might be more convenient to use UArray (Int,Int) Bool instead of Word64
16:44:55 <lambdabot>  1
16:44:59 <RustyShackleford> I thought those periods were like, placeholders for the arguments
16:45:05 <Cale> UArrays of Bool values are bit-packed
16:45:08 <arkeet> nope. :)
16:45:21 <EvanR> nitrix: nice
16:45:27 <EvanR> "Just what is a Functor, really?"
16:45:29 <EvanR> im satisfied
16:45:29 <Cale> But of course, that depends on what operations you need.
16:46:00 <EvanR> nitrix: for you next task, rewrite that tutorial so it makes sense ;)
16:46:11 <boothead> I'm sure I've seen this before: Could not deduce (Contravariant Identity) arising from a use of to but I can't remember what the issue was. Can anyone give me a clue?
16:46:24 <RustyShackleford> Cale: well theres quite a bit of material online that uses 64 bit integers, bit shifts, and etc.
16:46:26 <jophish> hmm, it's odd that hxt doesn't use Text
16:46:28 <Bor0> > let (.-) x y = x + y in 1 .- 2 -- RustyShackleford, can use a lot of special characters for function names
16:46:30 <lambdabot>  3
16:46:34 <Cale> boothead: Identity is not a contravariant functor
16:46:52 <RustyShackleford> Cale: i'll look into it though
16:47:22 <nitrix> EvanR: What do you mean? It's honestly very good if you've had a little exposure (and failed) to Haskell. From a complete beginner approach, it might not be suitable, but for me, it was the Eureka moment.
16:48:26 <EvanR> nitrix: it seems to skip some prerequisite ideas about "just what is an algebraic data type anyway"
16:48:26 <arkeet> maybe you want some Array (Int,Int) Piece, where Piece is a pair of colour and piece type (each being an enum)
16:48:31 <aawe> nitrix: haha I imagine someone reading "How to learn about Monads: 1. Get a PhD in computer science.", going off to get a phd, returning 5 years later and reading "2. Throw it away because you don’t need it for this section!"
16:48:42 <MP2E|Work> hahah
16:48:50 <EvanR> nitrix: its using the word context in places where "container" is usually used, to weirdly try to be more right
16:49:02 <boothead> Cale, I was wondering why it was coming up in this form of lens:  s & myLens .~ b   -- myLens is like:                 lens1 . to (compose . functions) . _Just . lens2
16:49:07 <EvanR> and on the picture of a container
16:49:29 <akfp> I have some data of the form data Foo a = Foo a (Maybe a), and it is a monoid.  I want something like Eq, but where the Maybe is short-circuited, so that if mzero for Foo Int is (Foo 0 Nothing), then when "comparing" to (Foo 0 (Just 0)) it is "equal" because Maybe short circuits.   What is this thing called?
16:49:33 <arkeet> boothead: I believe that's a type error. :p
16:49:35 <glguy_> boothead: You can't "set" through a Getter. "to" makes a Getter
16:49:41 <arkeet> yeah.
16:50:11 <nitrix> EvanR: I think the point is that the container is contextual. People might not be used to sum types and wouldn't understand why the heck this container is either a Just a or Nothing
16:50:26 <aawe> akfp: is it equal or do you want it to be equal?
16:50:34 <f-a> http://git.joeyh.name/?p=scroll.git;a=commit;h=db3835eb46adb338b4a8847c3e55e4e003b67220 <-- commit title of the week
16:50:41 <EvanR> nitrix: but isnt Just whatever easier to understand as a container? and Nothing isnt even a container or a context
16:51:02 <EvanR> unless everything is a context
16:51:02 <Cale> hm?
16:51:02 <nitrix> EvanR: I agree with you. It's far from perfect.
16:51:08 <arkeet> in what sense is IO a container? 
16:51:10 <arkeet> or Cont r
16:51:11 <akfp> aawe: when asking the question it became a bit clearer.  I probably want almostEqual a b = (a mplus b) == a or something like that.
16:51:21 <Cale> arkeet: In a very very general sense :D
16:51:23 <arkeet> :p
16:51:24 <nitrix> EvanR: It's still, in my opinion, a step closer to being good material.
16:51:37 <boothead> ah... damn! Anything else I can do here?
16:51:48 <EvanR> IO theyre not containers, its not a good justification to put a container on the screen and call it a context
16:51:51 <arkeet> boothead: that depends on what you're actually trying to do.
16:52:29 <EvanR> IO isnt even a context
16:52:32 <EvanR> i say
16:53:28 <nitrix> There's still something valuable in explaining something wrong the first time to help you have a coherent overall mental picture.
16:53:31 <raek> what does "INHERENT_USE" mean in biographical profiling (-hb)?
16:53:37 <hpc> IO is IO
16:53:37 <Cale> EvanR: Well, you could think of an action of type (IO t) like a funny sort of box with a button on it that you can push to cause the box to do something effectful, and finally emit a value of type t.
16:53:50 <hpc> it's a weird miracle thing that the compiler has to provide
16:53:50 <Cale> Maybe a different value of type t each time
16:53:54 <arkeet> it might emit a value of type t.
16:53:59 <hpc> it has no formal model
16:54:00 <EvanR> nitrix: that makes sense, but ive seen a lot of people go directly to tutorials like that after not getting it, then stopping right there because they still dont get it, and never come back
16:54:01 <arkeet> it might blow up the earth.
16:54:12 <hpc> and coincidentally has some convenient apis
16:54:20 <Cale> arkeet: Well, sure, it might spend forever doing what it does.
16:54:46 <Cale> and yeah, it might throw an exception as well :)
16:55:06 <EvanR> Cale: that is funny
16:55:20 <EvanR> thats a wide gap to jump over to make IO a container lol
16:55:22 <boothead> arkeet, what I want to do here is set the thing that the lens is pointing to all I have in these types is normal accessors (XMonad Stack)
16:55:51 <nitrix> EvanR: Then you add the details and rafine them. For me it was very convenient, especially that it addresses my two questions along the way: a <$> b where a and b are functions is actually just composition. That lists are functors and fmap = map for them. 
16:56:12 <EvanR> the unix command ls is a little box with "ls" painted on it, with a button that spits out listings
16:56:24 <nitrix> EvanR: Also >>= half >>= half >>= half chaining is one of the best explanation I've seen of Monads that doesn't talk about IOs.
16:56:25 <Cale> yep
16:56:27 <Cale> hehe
16:56:31 <Cale> EvanR: You can think of the Functor and Monad operations as being sort of a weak definition of what it means to be a container.
16:56:33 <arkeet> @where /bin/ls
16:56:33 <lambdabot> I know nothing about /bin/ls.
16:56:36 * EvanR puts stuff in that box with unsafePerformIO or something
16:56:37 <arkeet> where's that quote.
16:57:06 <Cale> @quote /bin/ls
16:57:06 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
16:57:11 <nitrix> What was the recent proposal. Making X applicative?
16:57:34 <EvanR> making Monad require Applicative
16:57:41 <nitrix> Oh.
16:58:00 <arkeet> Arrow should require Applicative too.
16:58:02 <nitrix> Isn't technically Monad building on top of Applicative, in terms of functionality?
16:58:09 <EvanR> not yet its not
16:58:24 <arkeet> and Profunctor.
16:58:26 <nitrix> It mimicks the same capabilities, but it's not officially using an Applicative, is that it?
16:58:27 <scott> nitrix: yes, you can always make an Applicative from a Monad
16:58:54 <scott> so future versions will require Monads to be Applicatives in the first place
16:58:56 <glguy_> Arrow has the wrong kind to require Applicative, no?
16:58:56 <arkeet> :t return
16:58:57 <lambdabot> Monad m => a -> m a
16:58:58 <arkeet> :t ap
16:58:59 <lambdabot> Monad m => m (a -> b) -> m a -> m b
16:59:03 <arkeet> glguy_: a partially applied Arrow.
16:59:20 <EvanR> nitrix: its not required to use this or that, but with the new proposal you cant do something like have a Monad that isn't Applicative
16:59:23 <glguy_> in the class definition?
16:59:33 <arkeet> glguy_: wishful thinking.
16:59:37 <glguy_> ok :)
16:59:41 <arkeet> class (forall b. Applicative a b) => Arrow a where...
16:59:48 <arkeet> (oh and category)
16:59:53 <nitrix> EvanR: I like the idea (despite not very being knowledgeable about these things). Is it realistic to see it happens?
17:00:02 <nitrix> I know Haskell changes a lot (which I quite enjoy tbh)
17:00:25 <EvanR> nitrix: supposed to be in the next release, which means the next release may block ;)
17:01:25 <arkeet> Applicative + Strong (profunctor) + Category should be enough to make Arrow, right?
17:02:11 <want-secrets> anyone here use haskell for websites?
17:02:46 <levi> want-secrets: Yes, though just hobby websites.
17:04:27 <want-secrets> Why not for profit?
17:04:41 <Cale> want-secrets: The web application backend at skedge.me uses Snap (a Haskell web framework), I worked on that for some time a while ago.
17:04:44 <want-secrets> Are there any free blog  or forum websites in haskell?
17:05:17 <Cale> yes... at various stages of readiness
17:05:37 <acowley> I didn't know you worked with skedge.me, Cale!
17:05:44 <Cale> yep
17:06:01 <kadoban> want-secrets: Yeah, I use haskell for websites, professionally. I use hakyll.
17:06:13 <xnil> kadoban: i'm jealous of your life
17:06:15 <Cale> If you're looking for something vaguely Wordpress like, you might be interested in clckwrks
17:06:20 <acowley> Cale: are you in NYC?
17:06:20 <nitrix> want-secrets: From what I've seen, Snap has extremely good performances and I'm sure maintaining a codebase in Haskell would bring many benefits.
17:06:31 <Cale> acowley: Nope, Brantford, Ontario
17:06:43 <arkeet> I didn't know you were in canada.
17:06:49 <arkeet> maybe I did once and then forgot.
17:06:52 <acowley> Ah, so kind of a commute to go to the NY events
17:06:56 <Cale> haha
17:06:59 <Cale> Yeah
17:07:10 <kadoban> xnil: Well, don't get too jealous, I'm just a freelancer and I can never find enough work, sigh.
17:08:03 <xnil> kadoban: so am i
17:08:11 <xnil> without a college education, nonetheless
17:08:18 <hodapp> want-secrets: haskellembedded.github.io uses Hakyll, albeit that's just static content.
17:08:38 <kadoban> But yeah, I realized that none of the clients really cared what I was coding in, so I figured I might as well use what I actually wanted to, heh.
17:09:00 <arkeet> actually, I guess even Applicative isn't needed.
17:09:01 <xnil> why Hakyll was never named Hekyll is beyond my comprehension
17:09:04 <arkeet> so Category + Strong = Arrow.
17:09:26 <want-secrets> lol
17:09:31 <nitrix> what is a Strong?
17:09:40 <arkeet> from profunctors
17:09:45 <want-secrets> I am after dynamic content
17:09:48 <nitrix> ... ;-;
17:09:54 <hodapp> xnil: good question.
17:10:05 <hodapp> xnil: too close to Jekyll maybe.
17:10:06 <jophish> arkeet: hxt provides constA
17:10:08 <jophish> :t constA
17:10:09 <lambdabot>     Not in scope: ‘constA’
17:10:09 <lambdabot>     Perhaps you meant one of these:
17:10:09 <lambdabot>       ‘const’ (imported from Data.Function),
17:10:13 <akfp> is there a name for a semigroup where you can check whether  x <> x == x holds?  I'm thinking of that operation as an alternative to mempty
17:10:21 <jophish> ArrowList a => c -> a b c
17:10:46 <arkeet> akfp: in what sense is it an alternative
17:10:48 <arkeet> ?
17:10:50 <Cale> akfp: You mean that x <> x = x for all x?
17:11:02 <EvanR> x <> e = x, e <> x = x
17:11:02 <arkeet> and yeah, I'm not exactly sure what you mean. what is x?
17:11:14 <arkeet> "idempotente semigroup"
17:11:17 <arkeet> -e
17:11:18 <arkeet> idempotent.
17:11:34 <Cale> http://en.wikipedia.org/wiki/Band_(mathematics)
17:11:34 <arkeet> if that's forall x.
17:12:03 <akfp> arkeet:  for data Foo = Foo Int (Maybe Int), mempty = Foo 0 (Just 0).  But (Foo 0 Nothing) <> (Foo 0 Nothing) = (Foo 0 Nothing) but it is not mempty.  There are multiple "mempty" values for Foo.
17:12:22 <arkeet> akfp: well, Maybe's monoid instance sucks.
17:12:33 <arkeet> and monoids are allowed to have lots of idempotent elements.
17:12:36 <Cale> Wait, why does it suck?
17:12:55 <arkeet> well, maybe not the instance itself, it's a fine monoid.
17:13:02 <akfp> arkeet: what do you mean, lots of idempotent elements.
17:13:13 <arkeet> but the instance for Maybe a forgets the mempty from a
17:13:24 <arkeet> akfp: x is idempotent means x <> x = x
17:13:33 <glguy_> The objection I know about is that it requires Monoid and not Semigroup
17:13:39 <arkeet> yeah.
17:14:02 <arkeet> unfortunately not much can be done about that.
17:14:47 <Rotaerk> :t (<>)
17:14:48 <lambdabot> Monoid m => m -> m -> m
17:14:49 <akfp> arkeet:  This is a very concrete problem I have.  I have some json with optional fields.  If I define an aggregation, then for some set of rows, the optional field will exist, but for other sets, none of the rows will have the optional field.  So  x <> x == x seems to "work" as a way to figure out if the aggregate is "mempty", while I can't define an mempty element.
17:15:54 <arkeet> the problem is not clear to me.
17:29:51 <want-secrets> I'm tired of using old tools and crappy not well though out garbage other goons slapped together.
17:29:58 <want-secrets> I wana build pure asskikn software.
17:30:01 <want-secrets> with less fuss
17:30:41 <tzaeru> good luck, then!
17:32:03 <EvanR> want-secrets: yet youre on the web?
17:32:35 * EvanR imagines HTTP being designed by a bunch of goons
17:33:05 <h-core> so is there a list somewhere that explains all the different types haskell comes up with?
17:33:18 <f-a> h-core: comes up with?
17:33:18 <h-core> for example haskelly just said     Couldn't match expected type [Integer]
17:33:18 <h-core>                 with actual type [a0] -> [a0]
17:33:32 <f-a> h-core: [Integer] <-- list if Integers
17:33:34 <h-core> and i dont understand [a0] -> [a0]
17:33:36 <EvanR> expected a List but got a function
17:33:45 <f-a> [a0] -> [a0] function from list of a to list of a
17:33:51 <EvanR> probably forgot one of the arguments
17:33:53 <h-core> why is it a0 and not a?
17:33:58 <f-a> you are probably missing a $ or missing an argument
17:34:03 <f-a> h-core: it's the same
17:35:09 <h-core> you're right i was missing an argument
17:35:10 <h-core> and it is?
17:35:35 <h-core> i thought [a0] might refer to a list of any numbers or similar
17:35:51 <xandaros> n #haskell-blah
17:35:57 <f-a> xD
17:36:01 <f-a> /joi
17:36:03 <xandaros> sry
17:36:07 <f-a> ; no prob
17:36:32 <f-a> h-core: no not really
17:37:17 <h-core> hrmm ok, then is there a list somewhere of common haskell errors and their common solutions?
17:38:13 <f-a> h-core: not that I know, but I am going to write that article!
17:38:36 <h-core> lol good because no part of that error message told me i might be missing an argument
17:39:16 <f-a> think about it h-core 
17:39:29 <f-a> ghc expected a list
17:39:32 <f-a> but got a function
17:39:46 <EvanR> h-core: are you sure?
17:39:47 <h-core> yeah i get it now
17:39:55 <h-core> that does make sense
17:39:56 <f-a> @type filter
17:39:57 <lambdabot> (a -> Bool) -> [a] -> [a]
17:40:01 <f-a> @type filter odd
17:40:02 <lambdabot> Integral a => [a] -> [a]
17:40:05 <f-a> ^-- function
17:40:09 <f-a> @type filter odd [1..10]
17:40:10 <lambdabot> Integral a => [a]
17:40:13 <f-a> ^-- list
17:40:43 * hackagebot json 0.9.1 - Support for serialising Haskell to and from JSON  http://hackage.haskell.org/package/json-0.9.1 (IavorDiatchki)
17:41:02 <h-core> doesn't make sense the first time though, which is why i came to you helpful folks :)
17:41:12 <f-a> h-core: here ghc warns me
17:41:19 <f-a> Probable cause: ‘filter’ is applied to too few arguments 
17:42:15 <arkeet> show us your code.
17:42:18 <h-core> yeah i've seen that befor
17:42:23 <h-core> arkeet, sure
17:42:31 <h-core> fibs2 :: [Integer]
17:42:31 <h-core> fibs2 = 0 : 1 : (sum $ drop (subtract 2 (length fibs2)) fibs2)
17:42:58 <h-core> funny thing is i already solved fibonacci equations before but now cis194 asked me to do it so i decided to try again
17:43:03 <h-core> and it's just not working again
17:43:14 <arkeet> (sum $ ...) is not a list.
17:43:28 <h-core> wouldn't drop return a list?
17:43:34 <arkeet> you're summing the result of drop.
17:43:46 <h-core> but i have a feeling it's infinite and doesn't return
17:43:59 <arkeet> fibs2 = 0 : 1 : sum (drop (subtract 2 (length fibs2)) fibs2)
17:44:06 <arkeet> is what you wrote, except without the $
17:44:20 <arkeet> sum does not add two lists to form a new list.
17:44:28 <arkeet> it adds the elements of a list to form a single number.
17:44:54 <arkeet> also, I guess you want fibs2 to be an infinite list.
17:44:58 <h-core> yeah wouldn't my code just get me 1 list? drop is only going to give me one list of the last 2 elements no?
17:45:03 <arkeet> well, length fibs2 won't produce a value.
17:45:24 <arkeet> because it's an infinite list.
17:45:39 <h-core> cause it'll keep going and length will be getting lists that contain lists of lists....
17:46:03 <arkeet> no, it's not a list of lists. it's a list of Integers, as your type annotation says.
17:47:03 <arkeet> I think I know at least partially what you were thinking when writing this.
17:47:10 <h-core> ohh yeah and cons will cons the lists right? like fibs = 0 : fibs is going to first return 0 : 0 : fibs
17:47:10 <arkeet> well, fibs2 is the same list on both sides of the =
17:47:28 <arkeet> fibs2 on the right is not "however much of fibs2 we computed so far".
17:47:31 <arkeet> it's the whole thing.
17:48:44 <h-core> yeah and the whole thing is infinite so i cant length it
17:48:55 <arkeet> yeah.
17:49:01 <arkeet> even aside from the type error.
17:50:27 <arkeet> now it's possible to, say
17:50:29 <arkeet> iterate
17:50:38 <arkeet> starting with [0,1],
17:50:49 <arkeet> take the sum of the last two elements, and stick it onto the end.
17:50:50 <arkeet> and iterate.
17:51:06 <arkeet> but that's very slow (accessing the end of a list is linear time)
17:51:17 <arkeet> (and you'd be copying the entire list at each step)
17:51:35 <h-core> so i can flip it around and take from the front of the list?
17:51:36 <arkeet> I'm guessing that's what you're trying to do.
17:51:54 <arkeet> you could, but then at some point you have to stop and flip it back.
17:52:00 <arkeet> so that won't get you an infinite list of fibs.
17:52:06 <arkeet> (you can't reverse an infinite list.)
17:53:24 <erisco> class Isomorphism f g where to :: f -> g; from :: g -> f;   with laws   to . from = id;  from . to = id         is this sensible?
17:53:28 <nitrix> arkeet: That'll appear to come out of nowhere, but I just want to thank for being so active recently.
17:53:36 <acowley> I can reverse an infinite list of ones
17:53:44 <acowley> It's a great party trick
17:53:46 <arkeet> haha
17:53:51 <h-core> acowley, can you do it for 2s?
17:53:55 <acowley> No, just ones
17:53:58 <arkeet> but what if I gave you an infinite list that's mostly ones, but has a 2 at the end?
17:54:07 <hodapp> blargh, Data.Colour, you make me sad
17:54:16 <acowley> Unless I've had too much to drink, then sometimes a 2 gets into the list and everyone laughs at me
17:54:17 <h-core> cause of the british spelling?
17:54:36 <acowley> I usually feel like I make Data.Colour sad
17:54:44 <h-core> acowley, https://www.youtube.com/watch?v=aAwJlD-m_hE
17:54:45 <nitrix> arkeet: I'm trying to speed up my learning by paying attention to the channel and you're incredibly useful. I usually either see very technical answers or too vague, and it seems you're able to gage and be on the same page with everyone, it's refreshing.
17:54:46 <hodapp> h-core: no, because it's seemingly damn near impossible to go from RGB back to Colour
17:54:47 <h-core> relevant to you
17:55:31 <arkeet> nitrix: cool. :)
17:55:31 <nitrix> arkeet: I'll definitively spend more time here, Haskell's communauty is great; and I haven't felt so accomplished writing 10 lines of code in so long.
17:55:34 <arkeet> haha
17:55:35 <nitrix> arkeet: :)
17:55:46 <acowley> h-core: That's what I was referencing!
17:55:46 <hodapp> everything goes Colour -> RGB
17:55:58 <h-core> lol
17:56:32 <nitrix> </feels>
17:56:45 <hodapp> perhaps I just need to not use HSV/HSL for anything
17:56:48 <acowley> I say, "I thought I saw a 2" fairly often, and people always think I'm serious
17:57:19 <arkeet> h-core: there are a couple of efficient ways to make the infinite list of fibs.
17:57:23 <acowley> hodapp: This is why I feel like I make Colour sad: I always want to do things it doesn't want me to do. 
17:57:42 <arkeet> maybe the easier one to understand is to have some auxiliary function
17:58:05 <arkeet> that takes a pair of numbers, and gives the fibonacci sequence starting from those two numbers.
17:58:24 <h-core> arkeet, i've seen a couple i just wanted to do my own in one line
17:58:24 <arkeet> and notice that every tail of the fibonacci sequence has that form.
17:58:42 <arkeet> :)
17:59:44 <kadoban> After you get that, figure out how to compute the nth fib number without calculating every n-1 before it.
17:59:56 <pavonia> hodapp: There are several functions for converting to Colour in Data.Colour.SRGB
18:01:16 <dunpeal> I'm only slightly familiar with Haskell, but I'm already wondering: how do you write a fairly large and complex application without classes?
18:01:59 <acowley> dunpeal: Functions. Lots of functions.
18:02:25 <acowley> dunpeal: It's worth breaking down what classes are doing for you
18:02:27 <arkeet> think about what classes do.
18:02:40 <arkeet> a class is a struct with a bunch of functions on it.
18:02:43 <dunpeal> they organize methods together.
18:02:47 <dunpeal> yup.
18:02:51 <hodapp> acowley: I'm considering that Data.Colour is doing the correct thing here with regard to colorspaces, and that I'm in the wrong. But I'm not sure.
18:03:00 <arkeet> just separate them.
18:03:07 <arkeet> so you have data, and functions.
18:03:16 <acowley> hodapp: I'm pretty sure Data.Colour is right. I've come to terms with it and accept that I'm a bad person.
18:03:32 <dunpeal> acowley, arkeet: the problem is, how do I get all the functions operating on object of type Foo?
18:03:44 <kadoban> dunpeal: There's other ways to do encapsulation and such. Modules are a nice level-of-encapsulation. Turns out classes aren't that necessary.
18:03:46 <dunpeal> in say Java, I just look at the class body in the class file.
18:03:46 <arkeet> you don't.
18:04:01 <arkeet> well, you look for all the functions
18:04:02 <acowley> dunpeal: On a *particular* object? You pass it as an argument, or capture that in a Reader.
18:04:05 <arkeet> that have Foo involved in their type.
18:04:18 <arkeet> and you can always write more.
18:04:25 <dunpeal> arkeet: sounds a bit difficult.
18:04:35 <dunpeal> so for example, suppose I need to refactor Foo.
18:04:38 <kadoban> dunpeal: For example, look at the docs for Data.Map. That's most of the functions you need to find to work with it.
18:04:48 <hodapp> pavonia: So, what gets me RGB a -> Colour a?
18:04:58 <dunpeal> I need to find and adapt all functions that act on it
18:05:22 <acowley> hodapp: Use something like sRGB
18:05:34 <pavonia> hodapp: There's nothing from RGB directly but for the individual channels
18:05:56 <acowley> rgbToColor (RGB r g b) = sRGB r g b
18:06:10 <acowley> Except I misspelled colour
18:06:33 <dunpeal> kadoban: is there something like a static analyzer which can locate for me all functions that may accept Foo as an argument?
18:06:52 <arkeet> replace Foo with something else, and then the compiler will complain anytime something looks for the old Foo.
18:07:37 <arkeet> or you can search.
18:07:39 <kadoban> dunpeal: Well, there's hoogle. Or there's arkeet's solution. Because of polymorphism there can be a lot of functions that can accept Foo without really caring what it is, but I don't think those should have to change usually unless you change things that you shouldn't change.
18:07:43 <dunpeal> that's probably a good idea.
18:07:47 <hodapp> acowley: oh, thanks, I did not realize that you can pattern-match over it like that
18:08:31 <arkeet> maybe you also had another question in mind: "how do you write ... without object orientation?"
18:08:31 <acowley> hodapp: The library really encourages you to work with Colour values rather than munge around in the individual channels.
18:08:54 <arkeet> that is a different question, because now we have to deal with inheritance and polymorphism.
18:09:19 <nitrix> https://github.com/nitrix/udfs/blob/lean/src/Inode.hs#L27
18:09:27 <nitrix> Is this idiomatic to have a function inside another?
18:09:40 <EvanR> hell yes
18:09:43 <hodapp> acowley: that's why I said that perhaps my use of HSV/HSL is the real problem, since they only convert to and from RGB.
18:09:44 <nitrix> I'm talking about the convertToResource helper.
18:09:56 <hodapp> acowley: everything up until touching HSV/HSL was fine.
18:10:08 <EvanR> if it would be generally useful outside the function you can move it out, otherwise dont bother
18:10:30 <dunpeal> kadoban: OK, thanks!
18:11:04 <nitrix> EvanR: Sweet. What about all those wheres, does that look funky? It's a huge function doing parsing, so I tried to separate all the different steps (mostly applying map)
18:11:39 <EvanR> nitrix: i only see two where
18:11:52 <nitrix> EvanR: I mean all the definitions in the first where
18:12:17 <EvanR> nitrix: i use a lot of definitions in a where a lot, but now that i look at it, using a where in a do is not that idiomatic
18:12:49 <EvanR> nitrix: in this case you probably want to move your "pure" function out just so its not in a do
18:12:50 <arkeet> the where is not really inside the do though.
18:12:54 <EvanR> its not
18:12:56 <arkeet> where blocks attach to declarations.
18:12:57 <EvanR> but its gross
18:13:01 <nitrix> EvanR: Yes, I was going to say that.
18:13:04 <hodapp> Interestingly, there is also a somewhat well-known paper about how to write without classes, but it is specifically about how to do it using prototype-based OO.
18:13:39 <nitrix> I'll move the different concerns (handling IO and parsing the block obtained through IO)
18:13:58 <nitrix> I just didn't know at the time that it'd grow like this, plus it's mixing pure with unpure... which is meh.
18:14:06 <nitrix> EvanR: Thanks, we're on the same page then :)
18:14:20 <nitrix> Haskell, I might finally learn you! AH!
18:14:26 <dunpeal> arkeet: not really, I'm just not sure how I would rewrite, for instance, my current project in Haskell
18:14:28 * nitrix victory dances
18:14:43 <hodapp> here we go:  "Organizing Programs Without Classes" (Ungar, Chambers, Chang, Hölzle)
18:14:51 <arkeet> yeah, haskell projects tend to be structured somewhat differently.
18:16:12 <nitrix> One last thing...
18:16:15 <nitrix> parseEntry entry = (parseInodeInfo . head $ entry, parseEventualResources . head . tail $ entry)
18:16:25 <nitrix> Can that be sort of ETA reduced for "entry" ?
18:16:38 <EvanR> ETA?
18:16:46 <EvanR> eta
18:16:48 <EvanR> ?
18:16:51 <nitrix> mhm
18:17:04 <nitrix> Is this a thing possible within tuples/
18:17:17 <EvanR> you can do (a,b) where
18:17:46 <EvanR> or (a x, b x) where
18:17:49 <nitrix> And then have both a and b eta reduced?
18:18:00 <arkeet> as I said, where blocks attach to declarations.
18:18:02 <arkeet> not expressions.
18:18:15 * EvanR cant be arsed to write out all the code and leaves
18:18:21 <arkeet> :p
18:18:32 <barrucadu> nitrix: You could use &&& from Control.Arrow
18:18:42 <barrucadu> But whether that's more readable is questionable
18:18:49 <arkeet> what is the question?
18:19:01 <arkeet> ah.
18:19:03 <arkeet> yeah.
18:19:10 <arkeet> (parseInodeInfo . head &&& parseEventualResources . head . tail) entry
18:19:15 <arkeet> &&& from Control.Arrow
18:19:22 <nitrix> arkeet: parseEntry entry = (parseInodeInfo . head $ entry, parseEventualResources . head . tail $ entry)
18:19:44 <nitrix> arkeet: Trying to eta reduce it, just because I find entry repetitive, but if that's fine the way it is, then whatever.
18:20:01 <EvanR> its really not that repetitive
18:20:10 <arkeet> I think it's clear enough as it is.
18:20:39 <EvanR> but to get rid of $ and parentheses, you can use a where to define the f and g that is being applied to entry
18:20:57 <EvanR> and then parseEntry entry = (f entry, g entry) where
18:21:43 <arkeet> maybe you should use a combinator parser.
18:21:49 <arkeet> er
18:21:55 <arkeet> whatever you call it.
18:22:47 <EvanR> put a bird on it
18:23:24 <nitrix> parseEntry e = (f e, g e) where ...
18:23:36 <nitrix> And that's as far as it gets, I don't know if I like it better :/
18:23:43 <EvanR>   f = a . b
18:23:51 <EvanR>   g = c . h . i
18:24:30 <EvanR> equational reasoning biatch
18:24:46 <nitrix> EvanR: Mhm, it's what I have. It's still not good, ideally I'd remove the e altogher, but that's a type error.
18:24:50 <arkeet> nitrix: have you seen stuff like parsec
18:25:05 <EvanR> nitrix: well at that point youd do = f &&& g
18:25:06 <nitrix> arkeet: No, I'm afraid that's probably way too advanced for me.
18:25:17 <arkeet> nah
18:25:21 <arkeet> it's not that complicated.
18:25:32 <EvanR> nitrix: pointfree isnt always the most readable though
18:25:51 <nitrix> :t &&&
18:25:52 <lambdabot> parse error on input ‘&&&’
18:25:55 <nitrix> :t (&&&)
18:25:55 <EvanR> :t (&&&)
18:25:56 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
18:25:56 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
18:26:06 <nitrix> Oh! fancy!
18:26:19 <EvanR> (b -> c) -> (b -> c') -> (b -> (c,c'))
18:26:19 <arkeet> well, you're parsing.
18:26:39 * nitrix jubilates
18:26:44 <nitrix> It works, that's brilliant.
18:26:52 <arkeet> so maybe you might want to look at a parser library.
18:27:02 <nitrix> arkeet: I think you're right :/
18:27:18 <EvanR> nitrix: or since youre on the road to nothing but combinators, https://hackage.haskell.org/package/data-aviary-0.2.3/docs/Data-Aviary-Birds.html
18:27:19 <epichero> for the mac people here, what irc client do you use?
18:27:40 <arkeet> :t runParser
18:27:41 <lambdabot> Not in scope: ‘runParser’
18:27:46 <arkeet> hm.
18:28:11 <arkeet> @let import Text.Parsec
18:28:14 <lambdabot>  Defined.
18:28:46 <Rotaerk> EvanR, .. wat
18:28:51 <Rotaerk> heh
18:28:58 <nitrix> EvanR: Bookmarked.
18:29:34 <EvanR> actually theres a new version
18:29:49 <EvanR> with "useful" combinators removed to emphasize not a utility library
18:30:02 <nitrix> EvanR: I'm a huge believer of combinators. I had a thing for concatenative languages before learning haskell
18:30:27 <nitrix> I'll be careful, I understand it can lead me into weird places.
18:31:47 <napping> Is there something like Lens's (id <+= n) without pulling in all of lens?
18:32:00 <arkeet> :t (<+=)
18:32:01 <lambdabot> (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
18:32:25 <arkeet> :t modify
18:32:26 <lambdabot> MonadState s m => (s -> s) -> m ()
18:32:40 <napping> the passthrough is the diference - it's modify (+n) >> get
18:32:47 <arkeet> yeah.
18:32:49 <arkeet> :t state
18:32:49 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
18:33:09 <arkeet> :t state (join (,) . (+ 5))
18:33:10 <lambdabot> (MonadState a m, Num a) => m a
18:35:14 <arkeet> :t \f -> state (join (,) . f)
18:35:15 <lambdabot> MonadState s m => (s -> s) -> m s
18:35:41 <arkeet> I think that's the closest you'll get.
18:45:55 <mmaruseacph2> how can I specifiy in a cabal file that I want to install another package using a specific flag?
18:46:14 <mmaruseacph2> I want to install diagrams with cairo flag set up for my project
18:46:40 <mmaruseacph2> sorry if this is not the proper channel for that (if there's another channel dedicated to cabal questions)
18:47:06 <edwardk> @let napping l n = l $ \x -> let y = x + n in (y, y)
18:47:08 <lambdabot>  Defined.
18:47:12 <edwardk> :t napping
18:47:13 <lambdabot> Num t1 => ((t1 -> (t1, t1)) -> t) -> t1 -> t
18:47:51 <arkeet> :t napping state
18:47:52 <lambdabot> (MonadState t1 m, Num t1) => t1 -> m t1
18:48:10 <edwardk> > napping both 4 (1,2)
18:48:11 <lambdabot>  No instance for (GHC.Show.Show t10)
18:48:11 <lambdabot>    arising from a use of ‘M163934679896685059728648.show_M1639346798966850597...
18:48:11 <lambdabot>  The type variable ‘t10’ is ambiguous
18:48:17 <edwardk> oh, oops, forgot something
18:48:34 <edwardk> > napping _2 4 (1,2)
18:48:36 <lambdabot>  (6,(1,6))
18:48:44 <edwardk> you wanted the new value
18:48:59 <edwardk> that picks the functor to be (,) a
18:50:06 <edwardk> oh you wanted <+= rather than <+~
18:50:32 <mek42> in napping, that is a number one before the first variable n and not a letter ell, correct?
18:50:41 <arkeet> that's the letter l
18:50:56 <arkeet> there are two arguments.
18:51:49 <arkeet> l is for lens
18:52:36 <arkeet> :t \l f -> l $ join (,) . f
18:52:36 <lambdabot> ((a -> (b, b)) -> t) -> (a -> b) -> t
18:52:39 <acowley> mmaruseacph2: You can't
18:52:55 <edwardk> :t let napping l n = state $ l $ \s -> let t = s + n in (t, t) in napping _2 3
18:52:56 <lambdabot> (MonadState s m, Field2 s s a a, Num a) => m a
18:53:06 <edwardk> ^- that gives a <+= equivalent
18:53:07 <napping> I like <+= just fine, I just wonder if there's something outside of lens equivalent to (id <+=)
18:53:08 <arkeet> :t (<%~)
18:53:09 <lambdabot> Profunctor p => Optical p q ((,) b) s t a b -> p a b -> q s (b, t)
18:53:18 <edwardk> napping: what i just typechecked
18:53:29 <mmaruseacph2> acowley: thanks
18:53:31 <napping> uh, what's the _2?
18:53:40 <arkeet> it's a lens.
18:53:43 <edwardk> napping l n = state $ l $ \s -> let t = s + n in (t, t) -- is the combinator
18:53:50 <acowley> mmaruseacph2: Flags are not a good feature, unfortunately. They make some sense when used with executables, but for libraries you run into exactly the problem you've hit.
18:53:58 <edwardk> it takes a lens 'l' and a number 'n' to add to it
18:54:08 <edwardk> if you don't want to take a lens, its a _lot_ easier
18:54:35 <arkeet> :t _2 <+= ?n
18:54:36 <lambdabot> (MonadState s m, Field2 s s a a, ?n::a, Num a) => m a
18:54:37 <edwardk> @let bump n = state $ \s -> let s' = s + n in (s', s')
18:54:39 <lambdabot>  Defined.
18:54:41 <edwardk> :t bump
18:54:42 <lambdabot> (MonadState a m, Num a) => a -> m a
18:55:03 <edwardk> bump 5 increased the value of the current state by 5 and give back the new value
18:55:33 <edwardk> er increases
18:55:44 <mek42> Should I be able to understand that napping function after going through "Learn you a Haskell for great good"?
18:56:26 <mek42> (I have just decided to study Haskell)
18:56:36 <napping> yeah, it's not too hard to define. I was wondering if it existed somewhere
18:56:59 <arkeet> I think "id <+= 5" is worth pulling in lens for. ;)
18:57:24 <edwardk> napping: nope
18:57:52 <arkeet> but I wouldn't mind some modify' that does that.
18:57:58 <arkeet> in mtl
18:58:00 <mmaruseacph2> acowley: thanks. I solved it by copying the dependencies of that flag into my cabal
18:58:15 <mmaruseacph2> luckily those won't change in the future (or not by much anyway)
18:59:19 <arkeet> modify' f = do { s <- get; let s' = f s; put s'; return s }
18:59:20 <arkeet> and that's that.
19:10:55 <rui3> @2+2
19:10:56 <lambdabot> Unknown command, try @list
19:11:05 <rui3> :t 9
19:11:06 <lambdabot> Num a => a
19:12:48 <eze> > :t 9
19:12:49 <lambdabot>  <hint>:1:1: parse error on input ‘:’
19:19:10 <nitrix> What is the most complicated type one can construct?
19:19:13 <nitrix> a b c ?
19:20:12 <nitrix> I understand you can go crazy with   Some (Very Long (Name (Like This))) or whatever, but that's technically just "Some a".
19:20:38 <nitrix> So what's the most extreme, a b c? What would be the Kind for this?
19:21:05 <hiptobecubic> nitrix, types can be infinitely long
19:21:17 <EvanR> unless you have the occurs check
19:21:46 <HeladoDeBrownie> hiptobecubic, that surprises me, can you give an example of how to form an infinitely long type?
19:22:33 <HeladoDeBrownie> oh, you meant arbitrarily long, i guess
19:22:35 <dcoutts> HeladoDeBrownie: I think hiptobecubic just means there's no real bound
19:22:47 <dcoutts> right, arbitrarily large
19:22:57 <nSLAVE> is this the channel for hadoop?
19:23:02 <Hafydd> That's rather distinct from "infinite"!
19:23:07 <EvanR> 7.10 should have support for infinite variable names
19:23:27 <hiptobecubic> hmm
19:27:07 <eze> any posible gsoc mentor here?
19:27:56 <Cale> :k RWST
19:27:57 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
19:28:46 <Cale> Anyone seen a 3rd order type constructor in the wild?
19:29:49 <ttt_fff> when using GHC.Generics, instead of defining (a :*: b) ... is there a way to get _ALL ARGS_ are a list, ?
19:30:04 <ttt_fff> when serializng stuff, it's easier if I get ehe entire list rather than defining a binary op
19:30:48 * hackagebot reflex 0.0.1 - Higher-order Functional Reactive Programming  http://hackage.haskell.org/package/reflex-0.0.1 (RyanTrinkle)
19:32:18 <Cale> @let newtype AppList t a = AL (t [] a)
19:32:20 <lambdabot>  Defined.
19:32:23 <Cale> :k AppList
19:32:24 <lambdabot> ((* -> *) -> k -> *) -> k -> *
19:32:57 <jmcarthur> Cale: what do you mean by third order?
19:33:12 <jmcarthur> oh i see
19:33:15 <jmcarthur> nevermind
19:33:26 <nksdiu> Hi, I'm reading 'category theory' by adowey and I hit something that is either incorrect or I dont understand: https://drive.google.com/file/d/0ByQnYyFRh1O6Vk9TdHdDQlBMQXM/view?pli=1
19:33:43 <nksdiu> the last paragraph where is mentions h and the composition 'p1 of h'
19:34:10 <nksdiu> doesnt the codomain of h have to be the same as the domain of p1?
19:34:35 <nksdiu> did the author mean 'inverse of h' ?
19:35:20 <ttt_fff> class Generic a where   -- Encode the representation of a user datatype   type Rep a :: * -> *
19:35:25 <want-secrets> so haskell has the concurrency thing like handled
19:35:30 <ttt_fff> what does "type Rep a :: * -> *" mean ?
19:35:32 <want-secrets> my haskell program with run on all 8 cpu
19:35:39 <want-secrets> with just a ghc switch?
19:35:41 <Cale> nksdiu: yes
19:35:52 <EvanR> want-secrets: yeah, if you really want it to
19:35:57 <Cale> nksdiu: Or just define h to go in the other direction, since it's an isomorphism anyway
19:36:03 <EvanR> want-secrets: 1 might work better ;)
19:36:10 <nksdiu> ah ok Cale, I have another similar question 1 sec
19:36:14 <jmcarthur> want-secrets: well, it has the ability to do so, though you still have to take some responsibility to make it work out well
19:37:11 <EvanR> want-secrets: youre thinking of parallelization
19:37:38 <jmcarthur> to be fair, the threaded runtime is pretty great even if you don't really care for computation parallelism
19:39:00 <jmcarthur> frankly i don't really understand why it isn't the default
19:39:26 <jmcarthur> not the be confused with +RTS -N, that is
19:39:29 <jmcarthur> *not to be
19:39:58 <EvanR> -threaded is awesome
19:40:09 <EvanR> not -threaded is still pretty awesome
19:40:10 <nksdiu> Cale: actually I forget what I wanted to ask :(
19:40:28 <jmcarthur> sure, but why not -threaded by default? :\
19:40:35 <EvanR> shrug
19:40:55 <want-secrets> well
19:41:06 <nitrix> (a b c) -> (a b c') -> a b (c, c')
19:41:10 <want-secrets> how does one learn to write liek high performance web apps?
19:41:18 <want-secrets> I thought concurrency was they key
19:41:26 <EvanR> identify where the bottlenecks are in webapps
19:41:29 <EvanR> fix those
19:41:31 <EvanR> repeat
19:41:43 <want-secrets> concurrency is bteere than parallaelism according to something I saw reagrading rob pike and golang
19:41:49 <want-secrets> maybe Im misinformed
19:42:16 <nitrix> Is c' just supposed to be a `d` or the tick brings another semantic?
19:42:20 <jmcarthur> concurrency isn't an optimization. it's an abstraction.
19:42:24 <hpc> they're totally different things
19:42:27 <jmcarthur> parallelism is an optimization.
19:42:34 <want-secrets> http://concur.rspace.googlecode.com/hg/talk/concur.html#landing-slide
19:42:41 <jmcarthur> threads conflate them, for better or worse.
19:43:21 <want-secrets> what about csp stm and actor?
19:44:00 <jmcarthur> concurrency is better in the sense that it is a tool for making your program easier to understand. parallelism is "merely" an optimization, sometimes requiring you to make your code harder to understand.
19:44:18 <c_wraith> stm and actors are concurrency models
19:44:22 <jmcarthur> but i think "better" is really hard to say...
19:44:29 <nshepperd> nitrix: yes, c' is just a label like d
19:44:43 <nitrix> nshepperd: So they just mean image?
19:44:46 <jmcarthur> they are just different things for different goals that happen to be conflated when threads are involved
19:44:54 <nitrix> nshepperd: *prime ?
19:45:18 <c_wraith> nitrix: c' looks like the kind of prefix the bindings-dsl library puts at the start of things.
19:45:20 <nshepperd> nitrix: the ' doesn't mean anything specific, it's just a convention
19:45:32 <jmcarthur> threads are a concurrency model, and so are actors. stm is usually presented as just a part of the thread model.
19:45:36 <nshepperd> nitrix: in this case, "second thing similar to c"
19:45:39 <nitrix> nshepperd: noted, thanks.
19:46:10 <nshepperd> similar in the sense that both c and c' are "outputs"
19:46:48 <nksdiu> is there something like the diagrams library but supporting animations (in any language)
19:47:59 <want-secrets> hmmm
19:58:26 <jle`> doesn't diagrams support animations? or am i going crazy
19:59:09 <EvanR> it does though its more experimental
19:59:28 <funfunctor> hi
19:59:29 <EvanR> i looked into animated diagrams, one way is to output frames of an animation with diagrams
19:59:41 <EvanR> another way which might be more practical is to use "html5" svg javascript
20:00:00 <funfunctor> What is the difference between the vector and array package? vector /seems/ better but I need to do a lot of DSP stuff and the dsp package seems to use array instead
20:00:11 <EvanR> thats weird
20:01:30 <funfunctor> EvanR: weird as in, it should be using vector?
20:02:01 <EvanR> just wouldnt expect that
20:04:04 <ReinH> EvanR: diagrams + FRP (Conal-style) = animations, surely this exists
20:04:17 <ReinH> i.e. a function Time -> Diagram is an animation
20:04:18 <jle`> funfunctor: i think vector just has a nicer api
20:04:31 <EvanR> ReinH: that makes sense, which frp library?
20:04:43 <ReinH> EvanR: I don't know, none of the FRP libraries are FRP libraries.
20:04:47 <EvanR> haha
20:04:49 <jle`> lol
20:04:54 <EvanR> so "for some value of exists"
20:05:01 <ReinH> It was more hopeful than anything
20:05:04 <funfunctor> jle`: looks more flexible yes
20:05:09 <jle`> this sounds like something that netwire might be able to be good at. i should work on implementing something like it
20:05:23 <jle`> funfunctor: i think i used to believe that vector is just a high level wrapper over array
20:05:53 <funfunctor> jle`: oh did you write the DSP package?
20:05:59 <jle`> no i didn't
20:06:02 <funfunctor> oh ok
20:06:07 <jle`> what dps package?
20:06:09 <jle`> *dsp
20:06:29 <jle`> i'm writing a package that can someowhat be used for realtime dsp...
20:06:34 <jle`> realtime as on causual
20:06:35 <ReinH> jle`: I expect you can do without the trappings of an FRP library for something as simple as constructing a function Time -> Diagram :)
20:06:37 <EvanR> ReinH: for animated diagrams, you dont even need frp, just old school "functional animation"
20:06:40 <jle`> i should probably pick a better name
20:06:53 <ReinH> EvanR: You just need a function Time -> Diagram, which *is* FRP as applied here.
20:07:03 <jle`> ReinH: yeah, FRP libraries really are an abstraction over ways to manipuate (Time -> Diagram)s
20:07:05 <jle`> manipulate
20:07:09 <jle`> and create new ones from simple primitives
20:07:13 <EvanR> on the other hand people have come to expect to hover over the pie slices and get percentages ;)
20:07:33 <ReinH> jle`: well, they're an abstraction over lots of things at this point, many of which do not involve continuous time or continuous space
20:07:37 <cfoch> hello
20:07:48 <jle`> i'm talking about this theoretical library that would implement frp heh
20:08:46 <ReinH> jle`: You might look at some of Conal's old stuff
20:09:31 <jle`> it really shouldn't be too hard to implement a non-interactive skeleton of frp combinators for simple animated diagrams though
20:09:40 <ReinH> It should not.
20:09:43 <ReinH> You should do that.
20:09:50 <EvanR> i agree
20:09:56 <ReinH> Godspeed.
20:09:56 <jle`> a lot of it is really already handled by the monoid instance of (->)
20:10:09 <jle`> (<>) :: (Time -> Diagram) -> (Time -> Diagram) -> (Time -> Diagram)
20:10:15 <jle`> it overlays the two animations together :O
20:10:19 <ReinH> :)
20:10:34 <jle`> takes two animations and returns a new animation with the two original ones overlayed
20:10:35 <jle`> neat
20:10:37 <jle`> thank you monoids
20:10:41 <ReinH> yep
20:10:53 <ReinH> And thank you typeclass morphisms
20:10:58 <ReinH> for ensuring that meaning is preserved
20:11:17 <jle`> well now yet another thing to spend time and tinker with ><
20:11:18 * EvanR scrolls up and adds that monoid instance to his frp library
20:11:28 <jle`> you should, it's pretty useful
20:11:32 <ReinH> heh :)
20:11:47 <jle`> i implemented a chat bot as an Auto...so you can actually create several chatbots and merge them together with mconcat
20:12:04 <jle`> mainBot = mconcat [chatbot1, chatbot2, chatbot3, chatbot4]
20:12:31 <jle`> it's like super cute
20:12:47 <sm> nice
20:13:08 <jle`> and you get it for free from the monoid instance of Auto
20:16:27 <ReinH> jle`: Auto looks cool!
20:16:29 <rvxi> hi
20:16:33 <ReinH> rvxi: hi
20:16:36 <jle`> thanks :)
20:16:43 <jle`> hi rvxi !
20:16:50 <rvxi> hi jle
20:17:04 <jle`> i think i'm just going to implement some more "wow-factor" demos before beginning promotion/publication
20:17:18 <jle`> i wrote a todo app with a command line interface and i'll be straightforward to port it to ghcjs so that might be one
20:17:39 <jle`> also i'm not entirely sure when i am going to publish to hackage...
20:17:43 <jle`> should i make tests first?
20:17:49 <jle`> do people usually write tests before they publish to hackage?
20:18:25 <ReinH> jle`: nah, yolo away
20:18:54 <ReinH> (Sometimes people even write tests before they write code!)
20:19:18 <jle`> i wonder if people ever drive development that way
20:19:39 <jle`> sounds kinda funky
20:19:53 <EvanR> hardware works that way
20:20:48 <EvanR> smoking video cards etc over and over again doesnt go over well with management
20:20:56 <ttt_fff> wtf does "newtype Tagged (s :: * -> *) b = Tagged { unTagged :: b} " mean? in particular, what does the (s :: * -> *) mean ?
20:21:09 <ttt_fff> wtf does "newtype Tagged (s :: * -> *) b = Tagged { unTagged :: b} " mean? in particular, what does the (s :: * -> *) mean ? ... why does it even exist when it is not used on the RHS ?
20:21:29 <xnil> jle`: that's literally test-driven development (TDD)
20:21:33 <xnil> a very common practice
20:21:37 <funfunctor> EvanR: what about smoking crack? Because that is what AMD's firmware team does with AGESA
20:21:40 <ReinH> xnil: thatsthejoke.jpg
20:21:40 <EvanR> TDD is dead, long live TDD
20:21:51 <EvanR> funfunctor: hahahaha
20:21:59 <xnil> ReinH: thatsthejoke.avi
20:22:03 <xnil> i was playing along
20:22:40 <pacak> ttt_fff: That's a kind signature, means s must be something of kind * -> * - taking one param to make a datatype, something like Maybe.
20:22:48 <dan1> can someone give me a help with gtk2hs? http://pastebin.com/csWrL1Lq
20:22:52 <ttt_fff> pacak: why is this useful?
20:22:54 <ReinH> ttt_fff: It's known as a phantom type https://wiki.haskell.org/Phantom_type
20:23:08 <dan1> I'm trying to make a simple desktop popup, but I cannot make it be focusable
20:23:27 <dan1> not sure if this is a problem with XMonad (my current WM) or my code...
20:23:48 <xnil> dan1: did you write haskell you are unsure of the validity of
20:23:55 <xnil> oops wow
20:23:58 <xnil> wrong channel
20:23:59 <ReinH> ttt_fff: The higher-kinded phantom is a bit unusual though. Where do you see it?
20:24:15 <ttt_fff> ReinH: Haste.Binary serialization routines
20:25:00 <ReinH> Ahahaha, I just found out that the haste package is a type of hpaste http://hackage.haskell.org/package/haste
20:25:04 <ReinH> *typo
20:25:13 <pacak> ttt_fff: Then your answer lies within depths of that library.
20:25:40 <ttt_fff> ReinH: I'm referring to haste-compiler
20:25:50 <ttt_fff> pacak: yeah, I found that line while reading the source of haste-compiler
20:25:54 <ReinH> I know. It's just funny that haste is misnamed.
20:26:13 <dan1> xnil: yes, I'm still learning Haskell, and I'm trying to make a gmrun clone
20:27:38 <ttt_fff> what is this shit, is it almost like halfway to dependent types?
20:27:54 <ReinH> ttt_fff: The link I gave gives an example usage of phantom types that is similar to what the Haste library is doing
20:28:06 <ReinH> No dependent types here.
20:29:05 <ttt_fff> ReinH: hmm, let me print + read it then
20:29:28 <ReinH> Specifically the "The use of a type system to guarantee well-formedness." section
20:29:49 <ttt_fff> some how they're using this to count the # of constructors a data type has
20:31:14 <EvanR> went looking for other instances of ((->) a), and found Monoid m => Comonad ((->) m)
20:31:21 * EvanR continues
20:31:28 <edwardk> its a useful instance
20:31:49 <EvanR> what does it do
20:32:07 <edwardk> I started calling it the "traced" comonad a few years back
20:32:19 <edwardk> you can extract from such a function by passing mempty as the argument.
20:32:35 <edwardk> duplicate :: Monoid m => (m -> a) -> m -> m -> a
20:32:48 <edwardk> splits a function into a function of two arguments that mappends the arguments
20:33:04 <EvanR> wow
20:33:35 <edwardk> if you're familiar with the store comonad, with the store comonad lets you 'know where you are' in many senses. you have a state 's' and a function (s -> a) that lets you take any absolute position (state) and get an 'a'
20:33:47 <edwardk> with the traced comonad you can only make 'relative' moves with the monoid
20:34:04 <edwardk> the state gives you a sense of absolute position in Store, but only relative position in (->) m
20:34:35 <EvanR> store lets you update too right
20:34:48 <edwardk> sure, but it does so by redefining the function
20:35:21 <edwardk> the store comonad has actions like (Store s a -> b) as its cokleisli arrows. then we extend them
20:35:28 <edwardk> duplicate (Store f s) = Store (Store f) s
20:35:55 <edwardk> we can even build a strange middle ground between Store and the traced comonad.
20:36:45 <edwardk> if you define a notion of right monoid actions, say:
20:36:49 <edwardk> class Monoid m => RightMonoidAction m s where act :: s -> m -> s
20:37:00 <edwardk> we can build a monad and a comonad that uses that rather than 'full state updates'
20:37:07 <edwardk> newtype UpdateT e s m a = UpdateT { runUpdateT :: s -> m (e, a) }
20:37:19 <edwardk> instance (Monad m, RightMonoidAction e s) => Monad (UpdateT e s m)
20:37:26 <edwardk> that is a fun project to build
20:37:42 <edwardk> and similarly data CoupdateT e s w a = CoupdateT (w (e -> a)) s    gives us a comonad
20:38:05 <ttt_fff> does 1 (the interger) satisfy the type * -> * ?
20:38:49 <edwardk> act is a 'right monoid action' which defines the action of a monoid on a set, in this case 's' -- such that act s mempty = s; act (act s m) n = mappend m n
20:39:07 <ttt_fff> :t :*:
20:39:08 <lambdabot> parse error on input ‘:*:’
20:39:12 <ttt_fff> :t (:*:)
20:39:13 <lambdabot> Not in scope: data constructor ‘:*:’
20:39:21 <ttt_fff> :t Ghc.GENERICS.:*:
20:39:21 <edwardk> * -> * is a kind, not a type.
20:39:22 <lambdabot> parse error on input ‘Ghc.GENERICS.:*:’
20:39:30 <ttt_fff> edwardk: what is 'kind' ?
20:39:37 <ttt_fff> I think it does not mean nice in this context
20:39:43 <edwardk> kinds are "the types of types"
20:40:12 <edwardk> Maybe has kind * -> *, Int has kind *
20:40:19 <edwardk> Maybe Int has kind *
20:40:57 <ttt_fff> why is it that for "a :: * -> *", "b :: * -> *", we have (a :+: b) :: * -> * ?
20:41:08 <glguy> :t (GHC.Generics.:*:)
20:41:09 <lambdabot> f p -> g p -> (GHC.Generics.:*:) f g p
20:41:36 <edwardk> because GHC generics isn't as polykinded as it could be?
20:42:07 <edwardk> ttt_fff: anyways that exists because (:+:) is defined in GHC.Generics that way
20:42:22 <glguy> I bet that poly kinds aren't what are confusing ttt_fff
20:42:26 <edwardk> data (:+:) f g a = L1 (f a) | R2 (g a)
20:42:36 <edwardk> glguy: my reply was a bit snarky in that regard i admit ;)
20:43:03 * EvanR puts all that in his "edwardk file"
20:43:37 <edwardk> EvanR: https://github.com/ekmett/update/blob/master/src/Control/Monad/Update.hs <- runnable code you can play with. i may finish packaging it some time
20:44:19 <edwardk> it is worth building the non-transformer versions directly to learn from
20:44:47 <EvanR> getting late switching coffee shops
20:45:00 <ReinH> EvanR: Careful, that file grows without bound.
20:45:44 <edwardk> EvanR: http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=B5415A02F7DD5AD7665B59E390E70BCD?doi=10.1.1.358.1211&rep=rep1&type=pdf <- is the much shorter denser version of what i just shared, which is in my "Tarmo file" ;)
20:46:18 <ReinH> Nice.
21:05:39 <edwardk> anyways the reason i started playing with that was i was curious about coalgebras of the update comonad, which gives a notion of lens... then as usual i found that whatever i was interested in, tarmo had written a paper about it
21:05:46 <edwardk> http://homepages.inf.ed.ac.uk/s1225336/papers/types14.pdf
21:05:50 <edwardk> ^- i lose the race again =)
21:06:22 <FreeFull> edwardk: Maybe you'll find something for which there isn't a paper, eventually
21:06:40 <edwardk> FreeFull: it happens occasionally, then i give a talk and move on =)
21:08:02 <zq> how does ghc know how return is defined when all i defined was instance Functor
21:08:10 <zq> is 7.8.4 psychic now
21:08:21 <EvanR> that paper is less than half a page long
21:08:36 <FreeFull> Say, a lens which returns a new lens, pointing at somewhere else, along with the modified data structure
21:08:47 <FreeFull> Refocusing lens
21:09:10 <c_wraith> zq: does it really know, or does it generate an erroring function?
21:10:00 <edwardk> EvanR: it says all it needs to say on the topic. =)
21:14:03 <EvanR> yep i vaguely see how this is related
21:14:31 <EvanR> in so far as theres a bunch of monoids, monads and comonads flying around ;)
21:14:44 <zq> c_wraith: it really knows
21:14:58 <EvanR> i havent internalized coalgebras yet
21:15:10 <c_wraith> zq: I think there's a piece of the puzzle I'm missing.
21:15:17 <zq> c_wraith: i mean i've used return
21:15:31 <zq> but nowhere have i defined instance Monad
21:16:18 <zq> oh wait
21:16:26 <zq> never mind!
21:16:29 <michaelt> zq: is it giving a type like Monad MyTypeConstructor => ... 
21:18:20 <zq> michaelt: nah. it's that i've defined my * -> * functor as a function that returns Either String a
21:18:33 <zq> michaelt: so the return actually calls return specialized to either
21:18:34 <zq> silly me
21:18:44 <michaelt> Oh I see.
21:20:01 <neuroserpens> Is it me or are some pages outdated in the haskell wiki?
21:20:33 <michaelt> Is it me or are some pages actually up to date on the haskell wiki?
21:20:45 <neuroserpens> lol
21:21:17 <zq> mathematics is timeless
21:21:42 <exio4> haskell isn't mathematics, though
21:21:53 <neuroserpens> The page on ARM says it could become available on  GHC 7.8
21:22:09 <neuroserpens> We have 7.8.4-1
21:22:17 <neuroserpens> Does it currently work on  ARM?
21:35:20 <ReinH> neuroserpens: I believe the answer is a decisive "Maybe?"
21:36:17 <ReinH> neuroserpens: Actually, iirc GHC works on ARM but GHCi does not for Reasons.
21:36:50 <ReinH> I think the official images actually have pretty old versions of GHC
21:42:15 <htebalaka> is appendFile safe to use in a concurrent context? i'm guessing no from looking at the source, but if anyone knows for certain?
21:48:15 <ReinH> hexagoxel: a Handle is protected by an MVar, so you shouldn't see corruption. You certainly could see interleaving.
21:48:36 <ReinH> Then again, the handle isn't being reused by appendFile, so maybe not
21:48:52 <ReinH> er, htebalaka ^
21:49:11 <ReinH> Yeah. Handles should be thread-safe, but multiple appendFiles will use separate Handles.
21:49:23 <EvanR> see no corruption, hear no corruption, speak no corruption
21:50:30 <htebalaka> ReinH: thanks
21:50:46 <ReinH> As a first step, I'd suggest reusing a Handle. As a second step, I'd suggest using a channel of some kind that is designed to be used concurrently.
21:51:39 <htebalaka> i've already got some existing stuff implemented to handle concurrent locking in another context, so it should be straightforward to re-use
21:52:00 <ReinH> Batching writes from the channel will usually be more performant than waiting on a lock anyway.
21:55:55 * hackagebot yst 0.5 - Builds a static website from templates and data in YAML or  CSV files.  http://hackage.haskell.org/package/yst-0.5 (JohnMacFarlane)
22:20:56 * hackagebot yst 0.5.0.1 - Builds a static website from templates and data in YAML or  CSV files.  http://hackage.haskell.org/package/yst-0.5.0.1 (JohnMacFarlane)
22:27:26 <Big_G> Are there any Haskell media (podcasts, videos, etc) you like?
22:42:47 <Arahael> *sigh*, it's a bad day. Accidentally deleted Main.hs :)
22:43:01 <Arahael> (It's in git, so all fine, but not a good start)
22:44:50 <aytch> If it makes you feel any better, I can't seem to figure out fizzbuzz using GHCI
22:45:46 <Arahael> aytch: Why, that _does_ make me feel better. :)
22:47:03 <aytch> a coworker got me doing functional programming with Powershell, and it improved my code so much I'm trying to learn me a Haskell
22:47:35 <dmj`> > forM_ [1..10] $ \x -> do { when (x `mod` 3 == 0) (putStrLn "fizz") } 
22:47:37 <lambdabot>  <IO ()>
22:47:44 <aytch> functionally-styled, I should say
22:47:51 <Arahael> aytch: Functional programming with Powershell? You mean using F#?
22:48:09 <aytch> Possibly. I'm a systems admin, not a programmer.
22:48:28 <Arahael> aytch: What scripting do you usually do?
22:48:40 <Xe> aytch: I'm so sorry
22:48:47 <aytch> Powershell & Ruby. Systems automation & Chef, largely.
22:49:36 <dmj`> I have a question, as of base 4.7 readMVar has changed, it's documented that readMVar = takeMVar mvar >>= \a -> putMVar mvar a >> return a, is no longer the definition. takeMVar causes all threads to block. Does the new definition no longer block on readMVar when the MVar isn't empty?
22:51:03 <Arahael> aytch: Ugh, I always dislike scripting on windows, but if I had to pick a language, it'd probably be python (due to it's pretty good subprocess module)
22:51:38 <aytch> Powershell is actually pretty good, especially when you're working with Windows-specific systems
22:51:50 <aytch> though that does depend on what you're doing
22:52:30 <Arahael> aytch: I find it increasonly hard to justify such highly platform-specific technologies.
22:53:13 <Arahael> Especially since one has to typically install PS anyway, though some already do (but an older version)
22:53:18 <kaidelong> Arahael: can you name a good solution for cross platform shell scripting?
22:53:31 <Arahael> kaidelong: I personally like python. :)
22:53:36 <kaidelong> Arahael: PowerShell comes with windows by default at least in version 8
22:53:44 <kaidelong> yeah but Python is infamously clunky on windows
22:54:10 <kadoban> You generally can't do a lot that really qualifies as "shell scripting" that's cross-platform, unless cross-platform means POSIX.
22:54:12 <pikhq> Kinda the C library's fault, but yeah.
22:54:13 <kadoban> At least IMO.
22:54:22 <kaidelong> the only real working solution I know of is Perl but only if you're willing to pay for active perl
22:54:25 <Arahael> kaidelong: At least it tends to work better.  Ruby's nice and concise, but it doesn't abstract as much - and there is so much _wierd_ stuff on winodws.
22:54:38 <aytch> http://pastebin.com/kxFcVzPb <- this is a good example of why I like Powershell for managing Windows-specific stuff
22:54:43 <Arahael> kaidelong: Eg, did you know that a process may, or may not, have a return code? 
22:55:07 <pikhq> (I'm still confused about why everyone likes keeping around the polite fiction that Windows' legacy charset junk is worth even keeping around)
22:55:18 <kaidelong> mmm I thought that was just that the MSVC allows you to omit the return code, and gives 0 as your return code implicitly
22:55:29 <Arahael> pikhq: Which 'legacy' one?
22:55:31 <pikhq> kaidelong: That's C++ and C99 rules.
22:55:38 <pikhq> Arahael: Anything that's not Unicode.
22:55:57 <pikhq> i.e. what most people stick in char strings on Windows.
22:55:59 <neuroserpens> Are we talking about Python? The only thing that still makes me LOVE Python is Blender.
22:56:08 <neuroserpens> It's an ABSURDLY powerful tool.
22:56:23 <kadoban> pikhq: That's not really windows-specific. It's just outdated programming and programmers that haven't been bitten by it yet.
22:56:49 <pikhq> kadoban: Yes, but Windows is the only one that makes getting away from it difficult.
22:56:56 <Arahael> pikhq: Windows is, in most practical cases, almost unicode (UTF-16)
22:57:12 <kadoban> pikhq: Really? How does it do that?
22:57:13 <neuroserpens> What? Are we talking about faildows now?
22:57:13 <pikhq> Because the platform as a whole does UTF-16 in wchar_t and random legacy charset in char strings.
22:57:15 * neuroserpens is lost
22:57:31 <pikhq> Which means that you only get it right if you're writing Windows-specific code.
22:57:36 <pikhq> (with attention to detail)
22:57:38 <Arahael> pikhq: You do have the option of avoiding the ansi api.
22:57:41 <neuroserpens> Someone fill me in
22:57:43 <neuroserpens> Plz
22:57:56 <pikhq> Arahael: But not with portable C.
22:58:05 <aytch> neuroserpens: I'm trying to learn Haskell because Powershell's functional programming features got me interested.
22:58:11 <pikhq> Arahael: int main(int argc, char **argv) congrats you're in legacy charset land.
22:58:25 <pikhq> *That's* the bit that makes it hard.
22:58:28 <Arahael> pikhq: Even then, you can still use the unicode API.
22:58:33 <pikhq> No.
22:58:36 <neuroserpens> aytch: Argh!
22:58:41 <aytch> I'm sorry
22:58:44 * neuroserpens faints at the sight of the word powershell
22:58:47 <kadoban> aytch: Sounds like a good idea. Do you have learning materials yet? The https://github.com/bitemyapp/learnhaskell page has a good suggestion or two, specifically the CIS194 course is pretty nice.
22:58:50 <pikhq> The "Unicode API" on Windows is Windows-only stuff.
22:59:12 <pikhq> When they could just have the C library deal in UTF-8 and stuff that isn't specific to Windows would also get Unicode.
22:59:13 <kadoban> neuroserpens: Be nice… 1/2 the reason I like this room is people don't get all cultish about their programming languages here usually.
22:59:16 <aytch> thanks, kadoban!
22:59:31 <Arahael> pikhq: You can change the locale on windows, but the default locale is ansi.
22:59:34 <neuroserpens> kadoban: Lmao I am nice.
22:59:40 <pikhq> You can't change the locale to UTF-8.
22:59:43 <neuroserpens> I am just pretending I fainted.
22:59:47 <pikhq> (of course, anything that is willing to write in Windows-specific code has, frankly, no excuse to not do UTF-16)
23:00:08 <neuroserpens> >:C
23:00:20 <kaidelong> what's wrong with UTF-16 anyway
23:00:34 <pikhq> kaidelong: It's inferior to UTF-8 for most uses.
23:00:45 <pikhq> That pretty well sums it up though.
23:00:47 <kadoban> It's kinda goofy, but nothing really AFAIK.
23:00:49 <kaidelong> mm, how though?
23:01:09 <Arahael> kaidelong: Surrogates were added as very much an afterthought.
23:01:14 <pikhq> Yep.
23:01:21 <kadoban> Well, if what you're mostly doing fits in ASCII, UTF-8 is much more efficient, that's the main difference I believe.
23:01:49 <kaidelong> does this have anything to do with Windows general dominance in chinese consumer markets?
23:01:51 <pikhq> If not for surrogates (if it were UCS-2 still) then it'd merely have the issue that it's not compatible with things that do character processing on 8 bit bytes.
23:02:11 <kadoban> kaidelong: It may. Is that really true? Is their share there bigger than elsewhere?
23:02:18 <hodapp> from the C standpoint, it's still variable-width, but now it requires conversions anytime you do network I/O or most of the time you do file I/O
23:02:29 <kaidelong> at least as far as tablet computers and phones are concerned, yes
23:02:48 <kaidelong> but I just figured out a better explanation
23:02:56 <kadoban> Interesting. Yeah that could have something to do with it. I think UTF-16 should be better, comparatively in the usual asian languages.
23:02:58 <kaidelong> they have working handwriting recognition for traditional chinese
23:03:07 <kaidelong> not sure any of their competitors has this
23:03:27 <pikhq> The big thing with UTF-8 is, it's the only way to reasonably do *simultaneously* standard/idiomatic C and handle Unicode.
23:03:45 <kaidelong> doing C/ASM on windows is a bit of a pain
23:04:02 <kaidelong> but it seems the reason for this is because you're supposed to be doing C++ or .NET instead
23:04:19 <kaidelong> both of those are reasonably cross platform, C++ more so
23:04:31 <pikhq> (it also is the only thing that *fits* in the common model of "8 bit ASCII-esque charsets" that's used elsewhere, largely because of C, so that's a plus)
23:04:35 <Arahael> C++ is /also/ a bit of a pain.  .NET's nice as it provides a good facade over the pain that is windows dev.
23:04:35 <kadoban> pikhq: If you just use normal C stuff on UTF-8 strings,that's…not going to work well except for the most simple things. I'm kind of dubious about that claim.
23:04:43 <rpr> curious in what windows-specific way is using C more of a pain than C++?
23:04:50 <pikhq> kadoban: It does work just fine.
23:05:02 <pikhq> kadoban: This is the way UTF-8 works on Linux.
23:05:04 <Arahael> rpr: Microsoft's C compiler is limited to, at best, C89.
23:05:07 <kaidelong> curious: well the fact that there are dozens of different types of strings on windows does not help
23:05:11 <pikhq> Most things just are UTF-8-ignorant, and it all Just Works.
23:05:46 <kadoban> pikhq: You can't even count characters in utf-8 without knowing what they mean…you can't split them up into groups. You can…what output them unchanged I guess?
23:05:56 <Arahael> kaidelong: What's a character?
23:06:24 <kaidelong> Arahael: the preference on windows was, IIRC, something called WCHAR_T, which is just UTF-16
23:06:29 <pikhq> But why are you counting characters? Are you wanting to know the number of bytes? Are you wanting to know the number of cells they take up? Are you wanting to know how many graphemes it maps to?
23:06:37 <kadoban> pikhq: Most of it happens to work because…the user doesn't happen to speak anything but english, heh.
23:06:38 <Arahael> kaidelong: Don't confuse UCS-2 with UTF-16.
23:06:40 <kaidelong> but you might be dealing with all other kinds of character data types writing C in practice
23:06:49 <kadoban> pikhq: So it's more, it accidentally works unless you use non-latin.
23:06:55 <pikhq> kadoban: Nope.
23:07:08 <kaidelong> like I had to do distributed programming for C on a mix of windows and linux machines and this was something of a pain to deal with
23:07:09 <pikhq> kadoban: You seem to misunderstand what the useful operations on strings *are*.
23:07:45 <pikhq> One tends to split strings on specific characters, seek for specific strings, print them out, and maybe print them out knowing the number of terminal cells they map to.
23:08:16 <pikhq> And the latter is the only one that's even all that tricky.
23:08:33 <kadoban> pikhq: Okay, how do you split strings on specific characters without caring that it's UTF-8 instead of ASCII?
23:08:45 <pikhq> kadoban: You *just do it*.
23:08:55 <aytch> kaidelong: I write Ruby/Chef for Linux/Windows/Mac, and it is a huge pain. So many escaped characters.
23:09:09 <pikhq> kadoban: If I split a string on commas, then the substrings between those commas are valid UTF-8.
23:09:12 <pikhq> Period.
23:09:17 <pikhq> (iff the string was valid, of course)
23:09:36 <Arahael> kaidelong: UTF-8 was designed so that any character that looks like ASCII is ASCII.
23:09:38 <kadoban> pikhq: No…you don't. If you "just do it" without caring that it's UTF-8, you're doing it 100% wrong, and it's accidentally working because you didn't get input that broke it.
23:09:48 <pikhq> ... But there is no input that can break it.
23:09:55 <pikhq> By design of UTF-8.
23:10:13 <Arahael> kaidelong: And here, we mean ASCII, not extended-ascii or whatever windows devs like to call it.
23:10:18 <kadoban> pikhq: That's absolutely incorrect. Stick around a bit and I'll show you.
23:10:34 <Arahael> kaidelong: Sorry - I meant kadoban . :)
23:11:16 <pikhq> kadoban: Name to me a string where you split on commas that is incorrect if you split on 0x2C instead.
23:12:02 <Arahael> kadoban: I'm also interested. :)
23:12:53 <kadoban> Working it out, it'll be a few…assuming I'm right, which I think I am, heh.
23:13:22 <aytch> This is a fun example of UTF-8 weirdness: http://www.rubyinside.com/the-split-is-not-enough-whitespace-shenigans-for-rubyists-5980.html
23:14:57 <pikhq> aytch: More Unicode weirdness. That'd happen just the same in any transformation format. :)
23:15:23 <Arahael> aytch: 160 isn't ASCII, in any case. :)
23:15:33 <kadoban> Oh…shit. I guess I'm wrong, sorry. I thought second/third/fourth bytes in multi-byte groups could have high-bit 0. Looks like that isn't true…
23:15:39 <pikhq> kadoban: Yep.
23:15:58 <pikhq> kadoban: Specifically because otherwise it'd break a lot of assumptions C code makes. :)
23:16:09 <aytch> I'm not going to lie - while I can comprehend the conversation, it is largely being filed away in my "I'll be glad I read this, someday." category.
23:16:25 <kadoban> Heh, yeah I guess they were more careful than I thought :)
23:16:40 <pikhq> Certainly without that property all my claims would be nonsense. :D
23:16:44 <Arahael> kadoban: Indeed. :)
23:16:50 <kadoban> I thought the relationship was just that valid-ASCII was valid UTF-8 and not much more.
23:17:02 <Arahael> kadoban: But one really nasty quirk is that unicode normalisation isn't standardised. :(
23:17:33 <kadoban> Ah yes, that fun :-/
23:17:47 <Arahael> kadoban: So when you normalize those codepoints, you'llh ave a different result depending on the unicode implementation you use.
23:19:55 <kadoban> That's one of those things that if I ever run into, I think I'll just take a long weekend and hope it goes away on its own.
23:56:28 <wz1000> By when is backpack going to be included with GHC?
