00:48:50 <lpaste> funfunctor pasted “No title” at http://lpaste.net/126286
00:48:55 <funfunctor> Hi
00:49:19 <funfunctor> I'm looking for general advice here on how to proceed with this REPL via UDP socket idea
00:50:00 <funfunctor> like how to best tokenize the commands and validate them?
01:26:23 * hackagebot STMonadTrans 0.3.3 - A monad transformer version of the ST monad  http://hackage.haskell.org/package/STMonadTrans-0.3.3 (JosefSvenningsson)
01:29:04 <TRManderson> :t seq
01:29:05 <lambdabot> a -> b -> b
01:44:21 <funfunctor> folks around?
01:45:51 <tdammers> yes
01:49:12 <funfunctor> tdammers: much experience with Parsec?
01:49:12 <aawe> around and about
01:49:21 <tdammers> funfunctor:  a bit
01:49:39 <aawe> funfunctor: I think many people here have experience with it, try just throwing out the problem/question and see if people bite
01:50:44 <funfunctor> I just need a simple parse of "cmd value" pair where cmd is specified by a data MyCommand = Foo | Bar | .. deriving (..)
01:51:09 <funfunctor> Lets fix value as Int type for ease
01:52:09 <aawe> what do you have right now?
01:52:57 <funfunctor> aawe: not much, I spent all afternoon trying to figure out UDP sockets in haskell
01:53:54 <funfunctor> aawe: I know Applicative is useful somewhere here in the parsing chain
01:54:45 <tdammers> funfunctor: can you parse a command and a value individually?
01:55:27 <tdammers> (i.e., do you have a Parsec s u m MyCommand?)
01:55:35 <tdammers> (and a Parsec s u m Integer)
01:55:48 <funfunctor> tdammers: no, i'm not sure how given a type how to get a string input into that type
01:56:10 <tdammers> which one? Integer, or MyCommand?
01:56:28 <AshyIsMe> woo i got osxmonad working 
01:56:42 <funfunctor> tdammers: well I have data ARFCNCommand = ARFCNCommandRequest | Int deriving (Show)
01:57:15 <tdammers> uhm... so Int is a constructor that doesn't take an argument?
01:57:15 <funfunctor> data ARFCNCommandRequest = PowerOn
01:57:16 <funfunctor>                          | PowerOff
01:57:16 <funfunctor> ..
01:57:50 <funfunctor> tdammers: no, idk at the moment.. I have no working code, just trying to figure out the concept
01:58:12 <funfunctor> I know Int is the kind
01:58:31 <tdammers> I think you mean data ARFCNCommand = ARFCNCommandRequest ARFCNCommandRequest | Int Int deriving (Show)
01:58:54 <AshyIsMe> somewhat anyway...
01:59:00 <aawe> AshyIsMe: how well does it integrate with osx?
01:59:33 <funfunctor> tdammers: sure
01:59:34 <tdammers> or maybe you want a product type, not a sum type?
02:00:12 <funfunctor> tdammers: actually this does not matter.. the part I am stuck on is how to get from a string input into a typed value
02:00:24 <tdammers> ah, ok
02:00:30 <tdammers> well, two choices, really
02:00:44 <funfunctor> give me the best one <g>
02:00:59 <tdammers> the first one is to parse things into a string as long as you keep seeing "well-formed" tokens
02:01:12 <AshyIsMe> aawe: by "working" i mean i got it to resize windows and handle some keypresses, i barely know the hotkeys yet though so totally not smooth at all 
02:01:20 <AshyIsMe> also, my debugging methodology is pretty terrible
02:01:26 <tdammers> e.g., you could just keep parsing "word characters" until you find one that's not a word character
02:01:41 <tdammers> and then pattern-match (with a case or sth) that string into a typed value
02:01:46 <tdammers> something like:
02:01:55 <AshyIsMe> is there a better way to trace an unfamiliar haskell codebase than sprinkling these everywhere?    XM.io $ hPutStrLn stderr "AA DEBUG: tile"
02:02:14 <funfunctor> tdammers: ok so how to parse data ARFCNCommandRequest = PowerOn | PowerOff | ... deriving (Show)
02:02:18 <tdammers> do { str <- manyOne wordCharacter; case str of { "foo" -> Foo; _ -> fail "not a valid token" } }
02:02:33 <aawe> AshyIsMe: there are the trace functions
02:02:40 <tdammers> the other options is to write separate parsers for each possible value
02:02:45 <tdammers> and combine them with <|>
02:03:06 <tdammers> probably need to throw in some backtracking, and the order has to be right if there are potential overlaps
02:03:15 <funfunctor> tdammers: but show gives me a string for each one of my valid commands
02:03:55 <tdammers> but, anyway: foo = string "foo" >> return Foo; bar = string "bar" >> return Bar; ...; then: foo <|> bar <|> ...
02:03:58 <AshyIsMe> aawe: those are basically the same though, is there a way to autogenerate a stacktrace through the profiling features or something?
02:04:05 <tdammers> afk, meeting time...
02:04:11 <tdammers> but hope you can figure things out from here
02:04:23 <funfunctor> I already knew that part :<
02:04:45 <tdammers> oh, you could also just read a string then and feed that to read
02:04:53 <tdammers> (gotta derive Read, obviously)
02:05:22 <funfunctor> tdammers: yea but then I have the value at the end..
02:05:57 <funfunctor> I need to tokenize on the space and also ensure that a valid command was given
02:06:30 <tdammers> or you could derive Enum and Bounded and use those to enumerate the possible values, then map a generic parser over that list and fold with <|>
02:06:40 <tdammers> the space is a matter of notFollowedBy space
02:07:04 <tdammers> invalid command, can be done by validating after the fact, failing, and backtracking with try, worst case
02:07:13 <funfunctor> what are Enum and Bounded got to do with anything?
02:07:31 <tdammers> you can use them to enumerate all the possible values, is all
02:08:29 <funfunctor> I have no idea
02:08:42 <funfunctor> "generic parser" what generic parser
02:12:28 <AshyIsMe> aawe: so far xmonad fights against osx if i use cmd-tab to swap app focus
02:12:53 <AshyIsMe> aawe: the next time around the mainloop it sets focus back to whichever app it thinks was in focus last
02:13:11 <aawe> AshyIsMe: I'll just have to keep using ubuntu then :P I can't live without my xmonad
02:15:27 <AshyIsMe> aawe: im just glad i got it actually manipulating windows for now
02:15:40 <AshyIsMe> still a fair bit of work to get it smoothly integrated with osx
02:15:48 <AshyIsMe> the original dev seems to have abandoned the project
02:16:44 <aawe> Do you think it's possible to get full integration?
02:24:19 <AshyIsMe> depends what you mean by that i guess
02:24:52 <AshyIsMe> it might end up "good enough" at least for single monitor usage
02:27:12 <TRManderson> is IO a functor?
02:28:24 <lieven> TRManderson: yes
02:28:48 <TRManderson> thanks
02:41:40 <Fylwind> it'd be nice if we could define an infix operator with higher precedence than function application
02:48:22 <frerich> Fylwind : I may be spoiled by function application having the highes preference, but something lik '1 + succ 2' not resulting in '1 + (succ 2)' would be really surprising.
02:48:58 <Fylwind> well it would be an extension of course :P
02:49:07 <Fylwind> but I think it has its uses for things like lenses
02:49:44 <RaceCondition> has anyone used Haste or Fay or equivalent with Sencha/ExtJS?  or would it be just as easy/difficult as with any other non-Haskell JS lib?
03:01:27 * hackagebot hmatrix 0.16.1.5 - Numeric Linear Algebra  http://hackage.haskell.org/package/hmatrix-0.16.1.5 (AlbertoRuiz)
03:01:29 * hackagebot hmatrix-glpk 0.4.1.0 - Linear Programming based on GLPK  http://hackage.haskell.org/package/hmatrix-glpk-0.4.1.0 (AlbertoRuiz)
03:06:58 <aawe> RaceCondition: Like any other js lib, you need to define the FFI. Unlike more popular js libs, you may have to do it yourself. Give it a try
03:10:07 <RaceCondition> aawe: ok, thanks;  so there's nothing that exists for ExtJS/Sencha
03:10:25 <RaceCondition> actually I might even not want Sencha... just wanted something cross-platform for mobile
03:11:28 * hackagebot auto 0.2.0.3 - Denotative, locally stateful programming DSL & platform  http://hackage.haskell.org/package/auto-0.2.0.3 (jle)
03:12:00 <aawe> RaceCondition: HTML&CSS are cross-platform out-of-the-box
03:12:33 <RaceCondition> aawe: I meant write-once run-anywhere-with-native-look-and-feel
03:13:46 <aawe> I have no idea how to do that
03:14:01 <f|`-`|f> I know you can run haskell on android
03:16:05 <tdammers> compile-once-run-anywhere on mobile isn't going to happen perfectly for quite a while
03:17:15 <aawe> I think xamarin works quite well in that area, but it's not #haskell
03:17:40 * f|`-`|f shrugs
03:17:50 <f|`-`|f> if only you could cabal on mobile :^)
03:18:38 <afwlehmann> "the cabal sandbox app" (tm)
03:19:23 <f|`-`|f> And then suddenly xmonad gets ported to mobile
03:19:48 <f|`-`|f> because extensibility
03:21:08 <aawe> easy
03:21:20 <aawe> just put XMonad into the AndroidT monad transformer
03:22:08 <afwlehmann> classic example of IO
03:22:30 <jle`> you mean the AndroidT xmonad transformer, right?
03:23:40 <afwlehmann> i guess IO /literally/ has to be in there
03:23:46 <afwlehmann> wrt the talking
03:36:29 * hackagebot eigen 2.0.0 - Eigen C++ library (linear algebra: matrices, vectors, numerical solvers).  http://hackage.haskell.org/package/eigen-2.0.0 (OlegSidorkin)
03:44:31 <bezirg> hi, i have a monadic function f :: (a -> b -> c -> m d) and a bunch of monadic actions x :: m a , y ::  m b, z:: m c  . How can I feed to f such that (f x y z :: m d) with point-free style?
03:45:19 <bezirg> I don't want to do (x >>= \ x_ -> y >>= \ y_ -> z >>= \ z_ -> f x_ y_ z)
03:45:46 <f|`-`|f> f x y z = .......
03:45:52 <f|`-`|f> :) ?
03:46:25 <bezirg> f :: MonadIO m => Int -> Int -> Int -> m Int
03:53:48 <fizruk> :t liftM3
03:53:49 <lambdabot> Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
03:54:32 <fizruk> bezirg: liftM3 f x y z
03:55:25 <bezirg> fizruk: y u r right, but the number of arguments most of the times varies. I am generating code.
03:56:06 <fizruk> bezirg: you can do smth like  f `liftM` x `ap` y `ap` z
03:56:20 <fizruk> which is just monadic equivalent to f <$> x <*> y <*> z
03:56:55 <fizruk> so when generating code, if you need extra argument w just add <*> w
03:57:26 <fizruk> or else, use a family of liftM functions: liftM, liftM2, liftM3, etc.
03:59:07 <fizruk> > (\x y z -> Just (x + y * z)) `liftM` Just 1 `ap` Just 2 `ap` Just 3
03:59:09 <lambdabot>  Just (Just 7)
03:59:18 <igniting> fizruk: type of f is (a -> b -> c -> m d) and not (a -> b -> c -> d), so liftM3 f x y z won't work
03:59:29 <bezirg> igniting: yes
03:59:40 <bezirg> i just tried in ghci, does not work
03:59:44 <lyxia> do a join at the end
03:59:49 <fizruk> you can join
03:59:58 <bezirg> lyxia, fizruk: hmmm yes
04:00:47 <fizruk> > join $ (\x y z -> Just (x + y * z)) `liftM` Just 1 `ap` Just 2 `ap` Just 3
04:00:48 <lambdabot>  Just 7
04:01:52 <bezirg> yes it worked! I will go with: join (f <$> x <*> y <*> z)
04:01:56 <bezirg> ty
04:04:13 <jle`> bezirg: in real code, do notation is probably the most readable :)
04:05:54 <bezirg> jle`: u r right on this, I just don't want to mess with generating hygienic variables to bind (through >>=). Do u think I can avoid that with do-notation?
04:06:30 * hackagebot b9 0.3.0 - A tool and library for building virtual machine images.  http://hackage.haskell.org/package/b9-0.3.0 (SvenHeyll)
04:06:32 <jle`> ah hm. probably not, if that's really what you want
04:06:34 <jle`> :)
04:06:37 <bezirg> :D
04:15:54 <bernalex> apparently I'm tired
04:16:15 <bernalex> oh wait. I remembered how to do it myself. thank you brain.
04:17:28 <fizruk> bezirg: jle`: it's simple: do { join (f <$> x <*> y <*> z) }  :)
04:18:36 <jle`> ;)
04:21:47 <poucet> Is there some generalization of monoid that supports multiple results? "a -> a -> [a]"?
04:23:27 <fizruk> poucet: what instances to you have in mind?
04:23:33 <fizruk> s/to/do/
04:25:14 <poucet> Imagine a type Freq a b p c
04:25:24 <poucet> Which says, between a and b, at frequency p we have something with cost 'c'
04:25:29 <poucet> a&b are times
04:25:53 <poucet> e.g. between 10 am and 2pm, every 15 minutes we have a train that takes 5 minutes to next stop
04:26:33 <poucet> http://ad-publications.informatik.uni-freiburg.de/GIS_frequencysearch_BS_2014 for context
04:27:39 <poucet> Combining two of those may result in multiple results if the frequencies are not the same
04:28:08 <aawe> I'd make a specific function first and then see if I can see any obvious generalizations
04:29:45 <fizruk> poucet: this Freq looks similar to Event from FRP, except Event is not bounded afaik
04:30:16 <fizruk> poucet: perhaps instead of "monoid generalization" you can just tweak Freq implementation
04:30:58 <poucet> yep
04:31:26 <fizruk> poucet: e.g. instead of storing frequency you might be able to store a list of exact points in time when each event occurs
04:31:31 * hackagebot b9 0.3.1 - A tool and library for building virtual machine images.  http://hackage.haskell.org/package/b9-0.3.1 (SvenHeyll)
04:32:13 <poucet> fizruk: That's antithethical to the idea
04:33:13 <fizruk> poucet: you might have a compact representation for cases when events are actually periodic
04:35:59 <jophish> How can I install an executable target defined in a .cabal file
04:36:21 <jophish> cabal install doesn't seem to be doing it (It's installing two other executables)
04:41:32 * hackagebot eigen 2.0.1 - Eigen C++ library (linear algebra: matrices, vectors, numerical solvers).  http://hackage.haskell.org/package/eigen-2.0.1 (OlegSidorkin)
04:44:15 <lpaste> mrkkrp pasted “One problem with lifting” at http://lpaste.net/126468
04:44:49 <mrkkrp> Could someone help me with this http://lpaste.net/126468 ?
04:45:31 <fizruk> poucet: reading through the paper. did you original question came from 3.1.1 Edge Relaxation ?
04:47:30 <fizruk> mrkkrp: you can do (TopT (lift (lift f1)))
04:48:39 <mniip> "there are things in mathematics that are too big to be sets. A classic example is a collection of all sets, which cannot be a set itself, because it would lead to a paradox."
04:48:41 <mniip> huh
04:48:50 <mniip> what's wrong with a set of all sets
04:49:34 <mniip> I've heard of the russell's paradox, but that talks about all sets that don't contain themselves
04:50:06 <fizruk> mniip: a set of all sets contains that set, I guess :)
04:50:14 <quchen2> mniip: It's one of the classical errors in naive set theory. The short version is that you can't simply declare something to be a set just because "it feels like one".
04:50:58 <mniip> then what can be declared a set
04:51:14 <quchen2> Axiomatic set theory tells you what sets are.
04:51:32 <quchen2> There is also a nice simple post to show you the contradiction in "the set of all sets". Hold on.
04:51:35 <mniip> in my interpretations sets are but functions telling whether some element is in the list or not
04:51:35 <ski> mniip : there is a set of all sets in the New Foundations set theory
04:51:44 <quchen2> http://math.stackexchange.com/a/171
04:51:53 <mniip> er
04:51:59 <mniip> in my interpretation sets are but functions telling whether some element is in the set or not
04:52:42 <ski> mniip : <https://en.wikipedia.org/wiki/New_Foundations#Admissibility_of_useful_large_sets>
04:53:31 <ski> mniip : `newtype Set = Comprehend (Set -> Bool)' ?
04:55:12 <mniip> that is an impossible type yes
04:55:47 <aawe> infinite
04:56:14 <mniip> if however we declare something like 'type Set = Dynamic -> Bool'
04:56:30 <mniip> such that sets can contain different /types/ of elements
04:56:54 <mrkkrp> fizruk: it doesn't feel right.. maybe I'm doing something wrong... or `lift' is supposed to always lift from the very bottom? Then I need 'custom lift' to lift from `MyT' ? Is it normal at all?
05:00:19 <ski> mniip : fwiw, i don't think it makes much sense to try to collect things of different types in the same set
05:02:31 <fractalsea> Can the computations on either side of >> be performed in arbitrary orders?
05:02:46 <fractalsea> If so is there a ways to enforce that they happen in sequence?
05:03:16 <ski> when `ma >> mb' is executed, `ma' is executed before `mb'
05:03:24 <fractalsea> hmm, OK thanks
05:03:56 <ski> (however, for some monads, "before" has little meaning)
05:04:19 <fractalsea> I’m just getting network traffic that according to wireshark looks like it’s being interleaved (i.e. ma traffic happening after a reuqest is sent in mb)
05:04:38 <fractalsea> It’s just IO
05:05:00 <mniip> ski, what monads for example?
05:05:05 <ski> > (undefined >> (^ 2)) 3  -- e.g. here, `undefined' is "executed before" `(^ 2)' -- as you can see, that doesn't mean much in the environment monad
05:05:07 <lambdabot>  9
05:06:33 <ski> fractalsea : maybe concurrency races ?
05:08:51 <fractalsea> ski: I don’t know. I don’t think so because >> is being done in IO, so even if there was any concurrency in m a for example, it should have been join with the main thread before the >> right?
05:10:20 <ski> i don't follow
05:10:34 <ski> `IO' allows multiple concurrent threads of execution
05:11:26 <ski> in `forkIO ma >> mb', `ma' is *not* guarenteed to be executed before `mb' (but `forkIO ma' obviously is)
05:11:49 <tdammers> IO is much like an imperative language that way :P
05:12:28 <Fylwind> anyone familiar with MonadResource? I'm using the twitter-conduit API, and I'm a bit confused how I should catch errors that are thrown in the monad
05:12:45 <Fylwind> it's an instance of MonadThrow, but not MonadCatch
05:18:19 <aawe> Fylwind: could you link to the MonadThrow instance?
05:20:08 <Fylwind> aawe: https://hackage.haskell.org/package/catch-fd-0.2.0.2/docs/Control-Monad-Catch.html
05:20:27 <Fylwind> now that I look at it I don't think MonadCatch is related 
05:20:51 <Fylwind> but the point is, how do I "catch" exceptions that occur within a ResourceT?
05:22:10 <obiwahn> Hi, how do i add and operator + for Int String? If in a way that the order of types does not matter. just applying something like: \x y -> [x | _ <- [1..y]]
05:22:23 <obiwahn> s/and/an/
05:22:59 <fizruk> mrkkrp: yes, lift is supposed to lift from very bottom of a monad stack. most common monad transformers (like StateT, ReaderT, WriterT, ContT, etc.) workaround this by introducing type classes (like MonadState, MonadReader, etc.) so that you wouldn't have to use lift (or to know where in the stack StateT is located)
05:23:04 <mniip> obiwahn, you can't
05:23:11 <mniip> + can only take values of the same type
05:23:19 <Iceland_jack> obiwahn: The type of (+) is
05:23:19 <Iceland_jack>     (+) :: Num a => a -> a -> a
05:23:26 <Iceland_jack> All the a's must be the same type
05:24:18 <Iceland_jack> This is a good thing™ :) even though it may not always feel like it
05:24:23 <ski> > let (+) = \x y -> [x | _ <- [1..y]] in "a" + 3
05:24:24 <lambdabot>  ["a","a","a"]
05:24:28 <obiwahn> si there no way to overload for some type(class)?
05:24:53 <mniip> typeclasses /are/ means of overloading
05:24:54 <ski> type classes are meant for disciplined overloading
05:25:05 <Iceland_jack> obiwahn: You can make
05:25:05 <Iceland_jack>     class Add a b where
05:25:05 <Iceland_jack>       type AddTy a b
05:25:05 <Iceland_jack>       add :: a -> b -> AddTy a b
05:25:06 <mniip> you can shadow the + operator within your context like ski did
05:25:26 <mniip> import Prelude hiding ((+))
05:25:32 <mniip> but then you have no +
05:25:39 <aawe> Fylwind: have you tried normal IO catching?
05:25:44 <mniip> can't you just use 'replicate' like normal people do
05:25:46 <fizruk> mrkkrp: thus you can probably just change the type of f1 to smth like (MonadState MySt (t m), Monad (t m), MonadTrans t) => t m Int
05:26:02 <fizruk> mrkkrp: so that it would fit both MyT and TopT
05:26:04 <Iceland_jack> obiwahn: http://www.cse.chalmers.se/edu/year/2013/course/DIT260/lectures/lecture7/Add.hs.html example of usage, look at the type of the example at the bottom
05:26:19 <Fylwind> aawe: that's my plan B
05:27:13 <obiwahn> thank you!
05:27:25 <fizruk> mrkkrp: note that perhaps you wouldn't need Monad (t m) and MonadTrans t constraints. that would depend on the actual implementation of f1
05:29:46 <obiwahn> has haskell build in multi-methods?
05:30:35 <quchen2> What's a multi method?
05:30:53 <obiwahn> http://en.wikipedia.org/wiki/Multiple_dispatch
05:31:23 <obiwahn> ah:)
05:31:34 <obiwahn> contained already the answer:P
05:31:47 <lpaste> SleepyPikachu pasted “concurrent-extra” at http://lpaste.net/126511
05:32:05 <SleepyPikachu> I'm trying to sleep in a Haste IO computation, Control.Concurrent.Thread.Delay.delay requires the package concurrent-extra but this fails to install when I use haste-inst install concurrent-extra See: http://lpaste.net/126511 for output
05:32:59 <obiwahn> What is the latest official standard? 
05:35:43 <ChristianS> obiwahn: multi dispatch makes no sense for haskell since it's not OO
05:36:02 <ChristianS> obiwahn: haskell standard is haskell 2010, it that's what you mean
05:37:47 <obiwahn> are multi-parameter type classes part of haskell 2010?
05:38:13 <obiwahn> is there something like http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf for haskell
05:38:54 <mauke^> no, we don't do drafts, C++, or ISO/ANSI
05:39:25 <mauke^> https://www.haskell.org/onlinereport/haskell2010/
05:39:26 <obiwahn> how do i know is something is officially supported?
05:39:44 <mniip> "officially"
05:40:01 <mniip> you mean whether something fits the haskell2010 standard?
05:40:33 <obiwahn> yes
05:40:57 <obiwahn> probably i have just to care about ghc anyways:)
05:41:02 <Iceland_jack> obiwahn: yup :)
05:41:33 <mauke^> https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-760004.3.1
05:41:43 <mauke^> topdecl → class [scontext =>] tycls tyvar [where cdecls] 
05:41:49 <mauke^> only a single tyvar allowed
05:42:48 <ChristianS> but there is a LANGUAGE pragma for multiple tyvars
05:43:06 <obiwahn> To enable them, use the
05:43:08 <obiwahn> {-# LANGUAGE MultiParamTypeClasses #-}
05:43:10 <obiwahn> pragma.  :P
05:43:24 <ChristianS> obiwahn: yes. LANGUAGE pragmas are commonly used to go beyond standard haskell.
05:44:01 <mauke^> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-class-extensions.html#idp23802656
05:44:19 <grc> sure
05:44:24 <frerich> obiwahn: Seeing that you seem to come from an C++/OOP background, I'd very much recommend not looking for equivalents of some OOP features (lik multimethods) in Haskell because you might end up suffering a lot from writing C++ code in Haskell.
05:44:38 * grc apologises - wrong window
05:47:42 <ggVGc> when I use hPrint to write some strings to a file, it adds double quotes around them. How can I print them raw?
05:48:23 <Iceland_jack> ggVGc: hPutStr
05:48:45 <ggVGc> thanks
05:59:30 <rabisg> hello. Can anyone help me understand this? https://gist.github.com/rabisg/93a391c58a3cfb4d7db7
06:01:34 <ggVGc> how can I make the value of selected be evaluated before the line containing dmenu? https://gist.github.com/758d8a17094d8a05dad4
06:02:20 <bergmark> rabisg:  (Show a, Read a) => Serializable a  means "given Show a and Read a we have Serializable a" it does not mean "Serializable a implies Show a and Read a"
06:02:43 <obiwahn> frerich: multi dispatch is not really a strength of most oop languages:P
06:03:55 <rabisg> bergmark: but Im not using show. why should adding an instance declaration trigger this check? without the instance declaration both work fine
06:05:32 <bergmark> rabisg: i misread, sorry, i think you need ScopedTypeVariables
06:09:11 <rui3> Num doesn't imply Ord?
06:09:19 <c_wraith> rui3: not anymore
06:09:36 <c_wraith> rui3: I mean, what's a good Ord instance for complex numbers?
06:09:52 <c_wraith> rui3: or matrices?
06:10:31 <rui3> c_wraith: None. So I guess the part where I was confused about was in what is a Num. I wouldn't have assumed matrices and complexes were there. Good to know
06:11:50 <rui3> I guess I expected Floating to be Ord
06:14:37 <mauke^> well, you can + complex numbers, so they have to be in Num
06:14:55 <mauke^> > (0 :+ 1) + 4
06:14:57 <lambdabot>  4.0 :+ 1.0
06:15:13 <mauke^> > ((0 :+ 1) + 4) / 2
06:15:15 <lambdabot>  2.0 :+ 0.5
06:15:25 <rui3> mauke^: I am not arguing the point nor I am surprised to be wrong. I am too new at this to trust my instincts
06:15:33 <mauke^> > sqrt (((0 :+ 1) + 4) / 2)
06:15:34 <lambdabot>  1.425053124063947 :+ 0.17543205637629383
06:15:49 <tdammers> IMO Num is too large :x
06:16:07 <mauke^> Num used to require Eq/Show
06:16:36 * hackagebot streaming-histogram 0.1.0.0 -   http://hackage.haskell.org/package/streaming-histogram-0.1.0.0 (teh)
06:22:27 <ggVGc> how can I force evaluation of a function?
06:22:35 <ggVGc> ehh, statement I guess
06:26:31 <mauke^> depends on what you mean by that
06:26:56 <mitu> you probably mean "execution" rather than evaluation
06:27:01 <ggVGc> mauke^: I am trying to write some stuff for xmonad, https://gist.github.com/7b8459cf0cf8108cfff2
06:27:02 <c_wraith> ggVGc: You can tie evaluation to evaluation of another expression.  Or you can force evaluation of an expression in IO.
06:27:10 <ggVGc> mauke^: but dmenu launches before urxvt
06:27:11 <ggVGc> in that snippet
06:27:14 <ggVGc> and I donät know why
06:27:34 <ggVGc> I am very new to haskell, and don't fully understand the syntax and semantics yet
06:27:56 <c_wraith> ggVGc: I don't think that has anything to do with haskell
06:28:01 <ggVGc> hm, okay
06:28:18 <c_wraith> ggVGc: That appears to just be that starting urxvt doesn't block
06:28:48 <c_wraith> ggVGc: it just runs in a new process
06:30:07 <ggVGc> c_wraith: yeah, I just realised that
06:30:09 <ggVGc> thanks
06:30:16 <ggVGc> wonder how to solve it :(
06:30:58 <mauke^> why are you starting urxvt at all?
06:32:05 <ski> ggVGc : instead of `sequence $ map (fmap show . getName) $ stackFunc', you can use `mapM (fmap show . getName) stackFunc'
06:32:50 <ggVGc> mauke^: I want to run fzf, which needs to run in a terminal. Can I do it in some other way?
06:33:15 <ggVGc> ski: thanks
06:33:22 <ski> (and `M.fromList (zip names stackFunc)' instead of `M.fromList $ zip names $ stackFunc')
06:33:28 <ggVGc> doesn't help with my current problem, but thanks for the education :(
06:33:29 <ggVGc> :)
06:41:12 <AshyIsMe> i think readProcess is what ggVGc wants: http://hackage.haskell.org/package/process-1.2.2.0/docs/System-Process.html#v:readProcess
06:41:21 <obiwahn> Iceland_jack: :) i like the the lecture - so cool!
06:44:50 <poucet> How do I make type-combinators? E.g. I say "class Foo t a where foo :: (t a) -> (t a) -> [(t a, a)]
06:45:11 <_dropp`> hey hey
06:45:12 <poucet> and now I want instance (Foo t a) => Foo ([] . t) a
06:45:28 <poucet> What's the right syntax of a list of 't' abstracted from the element type
06:50:06 <gyaretto> Morning.
06:53:53 <bartavelle> poucet : I am not sure I understand what you mean, so I'll try to guess : Foo t a => Foo [t] a ?
06:54:19 <poucet> bartavelle: t is of kind * -> *
06:54:27 <bartavelle> oh
06:54:40 <poucet> I need a way to specify a kind * ->* 
06:54:43 <poucet> that is the composition of 2
06:54:53 <poucet> so that ThatNewThing a === [t a]
06:54:53 <c_wraith> poucet: You can't do that without a newtype
06:55:11 <c_wraith> poucet: and if you're going to use a newtype, you might as well use one designed for exactly that purpose
06:55:19 <poucet> oic :|
06:55:29 <poucet> ok ty
06:55:36 <c_wraith> poucet: the transformers package has Data.Functor.Compose
06:55:43 <c_wraith> poucet: which is for exactly that
07:03:17 <Hi-Angel> Hello, I am curious, suppose I wrote in ghci «data Test = Test{ myfunc::(Int->Int) }», next I create an instance: «let test = Test{ myfunc = \x -> 3}». How would I call the «myfunc» function of the «test»?
07:03:44 <breadmonster> Hi-Angel: (myfunc test) x
07:03:47 <ski> Hi-Angel : `myfunc test 4'
07:03:54 <Hi-Angel> Thank you!
07:04:27 <ski> Hi-Angel : btw, `myfunc::(Int->Int)' there can be simplified to `myfunc :: Int -> Int'
07:04:33 <breadmonster> > data Func = Func { func :: Int -> Int };  
07:04:35 <lambdabot>  <hint>:1:1: parse error on input ‘data’
07:04:55 <Hi-Angel> :D
07:05:10 <breadmonster> ski: Don't you have to wrap the first bit in paresn?
07:05:56 <ski> breadmonster : you don't have to wrap the type in brackets, no
07:06:08 <ski> @let data Func = Func { func :: Int -> Int }
07:06:10 <lambdabot>  Defined.
07:06:35 <ski> @let test = Test {myfunc = \x -> 3}
07:06:36 <lambdabot>  .L.hs:164:8: Not in scope: data constructor ‘Test’
07:06:36 <lambdabot>  
07:06:36 <lambdabot>  .L.hs:164:13: ‘myfunc’ is not a (visible) constructor field name
07:06:44 <ski> er, right
07:06:50 <ski> @let test = Func {myfunc = \x -> 3}
07:06:51 <lambdabot>  .L.hs:164:13:
07:06:51 <lambdabot>      ‘myfunc’ is not a (visible) field of constructor ‘Func’
07:06:57 <ski> > /me sighs
07:06:58 <lambdabot>  <hint>:1:1: parse error on input ‘/’
07:07:01 <breadmonster> let f = Func (\x -> x + 3) in func f 4 
07:07:05 <breadmonster> >let f = Func (\x -> x + 3) in func f 4 
07:07:06 <ski> (try it yourself :)
07:07:17 <breadmonster> > let f = Func (\x -> x + 3) in func f 4 
07:07:19 <lambdabot>  7
07:07:33 <breadmonster> ski: You win.
07:07:40 <ski> (apparently breadmonster's version wasn't quite the same as Hi-Angel's original one)
07:09:08 <breadmonster> ski: Can I PM?
07:11:18 <ski> breadmonster : if you please
07:19:47 <rui3> Opening ghci in a folder F and running :l SomeDir/Stuff.hs imports some symbols. However, a test.hs in folder F, with import SomeDir.Stuff, and then :l test.hs fails because those symbols are not in scope of test.hs
07:21:21 <rui3> Does a simple explanation come to mind? I thought doing :l SomeDir/Stuff.hs in ghci should be equivalent to import SomeDir.Stuff from a file.hs and then :l file.hs. Not true?
07:22:42 <ClaudiusMaximus> rui3: did you compile test.hs before?  ghci loads .o if it can, which means fewer symbols are available
07:23:45 <ClaudiusMaximus> rui3: if it says (intepreted) then it didn't load the .o, i think you can force interpreted with :l * test.hs, not 100% sure on the syntax
07:24:04 <aawe> :t Func
07:24:05 <lambdabot> (Int -> Int) -> Func
07:24:16 <rui3> ClaudiusMaximus: I didn't compile it
07:24:16 <aawe> @src Func
07:24:16 <lambdabot> Source not found. stty: unknown mode: doofus
07:24:48 <rui3> ClaudiusMaximus: it says (interpreted)
07:24:49 <ski> aawe : defined above
07:24:58 <canisMajoris> Hi, I know the question is not considered with Haskell, but I couldn't find an exact answer on google, I wonder how pi number calculating in haskell, an unsigned int variable is 32 bit so the value can be maximum 2^32 ? could you give me an idea ?
07:25:21 <rui3> ClaudiusMaximus: but I didn't know one could precompile the .o so that it was loaded compiled. Does it make a big speed difference?
07:25:33 <aawe> canisMajoris: what is your question?
07:26:29 <canisMajoris> aawe: calculation of pi ? if I start to calculation how it will be represent by computer ?
07:26:42 <mauke^> > pi :: CReal
07:26:43 <canisMajoris> it overflow of maximum int value.
07:26:44 <lambdabot>  3.1415926535897932384626433832795028841972
07:26:44 * hackagebot groundhog 0.7.0.3 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-0.7.0.3 (BorisLykah)
07:26:57 <aawe> canisMajoris: the integer representation of pi is 3
07:27:28 <canisMajoris> oh sure I did think in with a wrong base type.
07:27:52 <arw_> and haskell int is arbitrarily long, it doesn't wrap.
07:27:56 <arw_> > 2 ^ 64 + 1
07:27:56 <canisMajoris> so with the float is it possible to calculate ?
07:27:57 <lambdabot>  18446744073709551617
07:28:10 <arw_> sorry, 'Int'.
07:28:40 <mauke^> > maxBound :: Int
07:28:41 <lambdabot>  9223372036854775807
07:28:44 <arw_> aeh, Int is the one that wraps, Integer doesn't
07:28:45 <fizruk> > 2 ^ 62 + 1 :: Int
07:28:46 <lambdabot>  can't find file: L.hs
07:28:59 <clrnd> canisMajoris, I guess you can think of decimals as a list of numbers too
07:29:24 <fizbin> > toRational pi
07:29:25 <lambdabot>  884279719003555 % 281474976710656
07:29:29 <clrnd> lol
07:30:03 <canisMajoris> clrnd: thank you.
07:30:18 <canisMajoris> I will research it
07:31:54 <ClaudiusMaximus> hayoo broken? gives no results for me, even with Prelude stuff
07:32:46 <hexagoxel> ClaudiusMaximus: can reproduce
07:33:00 <ChristianS> ClaudiusMaximus: yup, seems broken
07:33:19 <aawe> who peed on hayoo
07:33:24 <aawe> come forward
07:35:06 <meretrix> I'm pretty sure that a thread that uses a C library is crashing, but the exception is not being raised properly, so no errors are printed and the other threads keep running.  How would I debug something like this?
07:36:30 <ClaudiusMaximus> ugh.  all the audio libs i've looked at so far aren't what i want :(  they do things like  play :: Context -> [Sample] -> IO () ; play ctx ss = ... length ss ...
07:36:45 * hackagebot snap 0.14.0.1 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.14.0.1 (DougBeardsley)
07:37:15 <Freundlich> ClaudiusMaximus: What do you want? I didn't find it obvious what a good audio lib should need.
07:37:36 <obiwahn> i think i saw some online haskell interpreter that showed the evaluation steps taken - does anyone happen to know the name?
07:37:41 <ClaudiusMaximus> Freundlich: something that doesn't call length on a list, for starters
07:38:19 <Freundlich> Ah, I see.
07:38:31 <ClaudiusMaximus> Freundlich: it will likely force the whole list into memory, when it could be streamed into an array in some other way
07:39:16 <fizbin> Lazy streaming is hard.
07:40:19 <c_wraith> ClaudiusMaximus: Honestly, it should be something like Data.Vector.Storable.Vector Sample
07:40:39 <c_wraith> ClaudiusMaximus: so that it doesn't force a copy of the data
07:42:10 <ClaudiusMaximus> c_wraith: but then have to chunk it manually.  i know it is possible to do, just wish i didn't have to...
07:42:47 <c_wraith> ClaudiusMaximus: if your input source is mp3, it's already in chunks of 1152 samples at a time. :)
07:43:02 <ClaudiusMaximus> c_wraith: my input source is haskell code
07:43:13 <c_wraith> Though that's a very small chunk at 44.1kHz
07:43:43 <ClaudiusMaximus> currently i'm just writing text files and converting to wav then ogg later
07:43:51 <ClaudiusMaximus> but i'd like it realtime
07:44:04 <c_wraith> You could look at what things like Tidal are doing
07:44:20 <c_wraith> There's actually a decent scene for live-coding music in haskell
07:44:41 <ClaudiusMaximus> writing all the data to text files is barely realtime (last time i profiled it the Double -> String took ages)
07:44:48 <ClaudiusMaximus> http://mathr.co.uk/interstellar-interference/demos/ here's some output, anyway
07:44:55 <ClaudiusMaximus> visualized with gnuplot
07:45:33 <ClaudiusMaximus> c_wraith: last i checked (ages ago) Tidal used SuperCollider3 for sample playback
07:45:45 <c_wraith> it appears to use http://hackage.haskell.org/package/hosc now
07:46:11 <waern> ls
07:46:20 <c_wraith> waern: I think you got the wrong window. :)
07:46:30 <waern> yep =)
07:48:20 <kala> Hi
07:48:59 <kala> could someone help me with this? [[1,2,3],[1,2,3]] -> ["1,2,3","1,2,3"]
07:49:33 <kala> could someone help me with this? [[1,2,3],[1,2,3]] -> ["1,2,3","1,2,3"]
07:49:50 <Iceland_jack> kala: Do you know how you would go from [1,2,3] -> "1,2,3"?
07:50:04 <kala> show?
07:50:24 <bernalex> kala: yes. & do you know how you would go from [[]] to []?
07:50:33 <kala> concat?
07:50:57 <Iceland_jack> 'show [1,2,3]' gives you '[1,2,3]' which is not what you want
07:51:04 <kala> yup
07:51:19 <Iceland_jack> But you can map show:
07:51:19 <Iceland_jack> > map show [1,2,3]
07:51:21 <lambdabot>  ["1","2","3"]
07:51:36 <Iceland_jack> Then you need to get from
07:51:36 <Iceland_jack>     ["1", "2", "3"] -> "1,2,3"
07:51:43 <kala> yes
07:52:07 <Iceland_jack> You can use "intercalate" to do that
07:52:17 <Iceland_jack> > intercalate "," (map show [1,2,3])
07:52:18 <lambdabot>  "1,2,3"
07:52:19 <bernalex> you can do this in a bunch of ways really. :)
07:52:20 <tero-> how's the freelancer market for Haskell programmers? Is it easy to find someone to do the job at around 80 EUR/h? 
07:52:34 <kala> Sure, Thanks Iceland Jack and bernalex 
07:52:36 <kala> :)
07:52:37 <Iceland_jack> True
07:52:50 <tdammers> tero-: I have no idea, but I'd expect things to be extremely dire
07:52:53 <bernalex> tero-: send me an email and I might do it for you if it's interesting?
07:53:11 <tdammers> tero-: oh wait, nm, you are *looking* for people
07:53:22 <bernalex> kala: Iceland_jack: here's what I immediately thought I would do
07:53:30 <bernalex> > show <$> join [[1,2,3],[1,2,3]]
07:53:32 <lambdabot>  ["1","2","3","1","2","3"]
07:53:43 * frerich wonders whether [[1,2,3],[1,2,3]] -> ["1,2,3","1,2,3"] is part of some popular exercise, wasn't there somebody recently who asked the exact same question?
07:53:54 <bernalex> one way to do it with concatmap that's a bit silly but also a bit neat:
07:53:56 <bernalex> > concatMap (map show) [[1,2,3],[1,2,3]]
07:53:58 <lambdabot>  ["1","2","3","1","2","3"]
07:54:20 <bernalex> there are pretty much hundreds of ways of doing it :-]
07:55:04 <tero-> bernalex: for the moment no need, but I'm thinking to get a "real job" at some point and put this lonely but well-paying legacy maintenance hell behind 
07:55:20 <bernalex> tero-: disregard my pm then :-]
07:55:22 <hyPiRion> > [[1,2,3],[1,2,3]] >>= map show
07:55:24 <lambdabot>  ["1","2","3","1","2","3"]
07:55:37 <bernalex> hyPiRion: yes that's what I wrote :-P
07:56:08 <hyPiRion> heh
07:56:11 <tero-> bernalex: ok :)
07:59:18 <tero-> a slight concern is that it's not only Haskell. it's Python, c++, SQL, JavaScript and ActionScript 
07:59:35 <obiwahn> I can not find that online interpreter that shows intermediate evaluation steps:(
08:00:17 <bernalex> obiwahn: do you mean http://chrisuehlinger.com/LambdaBubblePop/ ?
08:01:04 <bernalex> obiwahn: or do you mean something more sophisticated? IDK of any really sophisticated online interpreter that does that off the top of my head.
08:02:03 <obiwahn> https://github.com/bmillwood/stepeval - i think this is it
08:02:44 <ProofTechnique> ocharles_: Around?
08:05:36 <m0rphism> obiwahn: oh, didn't knew about that one. Thanks :)
08:09:28 <ocharles_> ProofTechnique: what can I do for you?
08:10:44 <ProofTechnique> I've been working on some things on Clay and I wondered if you had any thoughts on an issue you added in 2013. :)
08:10:58 <ProofTechnique> https://github.com/sebastiaanvisser/clay/issues/53
08:11:46 * hackagebot waitra 0.0.3.0 - A very simple Wai router  http://hackage.haskell.org/package/waitra-0.0.3.0 (phadej)
08:11:50 <nitrix> Hi, I've written my own parser for a file format and realised that it can get very tedious. It currently works, except I suspect it'd break on the slightliest non-conformance to the format in dramatic manner.
08:12:33 <nitrix> I've heard of parsec, I want to learn it, but can someone who used it at least guarantee me that the error handling is flexible enough? e.g. parse into lines, and then, if the line cannot be parsed further, just drop that line and continue?
08:12:52 <nitrix> Each line is an entry and if an entry is bogus, I'd rather skip it than fail entirely.
08:15:37 <clrnd> nitrix, yes parsec can do that idiomatically
08:16:53 <ocharles_> ProofTechnique: oh thanks for the reminder, I meant to reply to that
08:17:07 <ProofTechnique> :)
08:17:48 <ocharles_> thanks, replied
08:20:10 <japesinator> what's the fastest way to get the last two characters of a bytestring?
08:21:17 <tdammers> characters or bytes?
08:22:06 <japesinator> I would like to check if the bytestring ends in '.0'
08:22:18 <japesinator> so whichever is more efficient for that purpose
08:22:52 <int-e> :t B.isSuffixOf
08:22:52 <lambdabot>     Not in scope: ‘B.isSuffixOf’
08:22:52 <lambdabot>     Perhaps you meant one of these:
08:22:52 <lambdabot>       ‘BS.isSuffixOf’ (imported from Data.ByteString),
08:22:56 <int-e> :t BS.isSuffixOf
08:22:57 <lambdabot> BSC.ByteString -> BSC.ByteString -> Bool
08:23:28 <japesinator> thanks!
08:27:03 <nitrix> clrnd: That's reassuring, thanks.
08:29:20 <kala> guys
08:30:27 <EvanR> what is a way to make a "synchronous call" to another thread, you send a message and block until the worker is done?
08:31:11 <kala>  [[1,2,3],[1,2,3]] -> ["1,2,3","1,2,3"]
08:31:37 <kala> I have trying for long
08:31:40 <kala> Please help
08:31:43 <kala>  [[1,2,3],[1,2,3]] -> ["1,2,3","1,2,3"]
08:32:04 <dolio> EvanR: Chans?
08:32:23 <EvanR> how would that work
08:32:40 <dolio> Depends.
08:32:57 <dolio> But you could put a response mvar in the thing you send in the chan.
08:33:00 <dolio> For instance.
08:33:05 <EvanR> ah
08:33:10 <EvanR> brilliant 
08:33:12 <dolio> Kind of like csp.
08:33:29 <EvanR> so creating MVars willy nilly like this is ok?
08:33:31 <ski> kala : what have you tried ?
08:33:42 <kala> ski, map show and concap map
08:33:42 <tdammers> I wouldn't call that "willy nilly"
08:33:50 <EvanR> once for each call
08:33:54 <Iceland_jack> kala: What about the solution I gave you earlier?
08:34:12 <kala> Iceland_Jack : I tried those onle
08:34:12 <ski> kala : can you get from `[1,2,3]' to `["1","2","3"]' ?
08:34:20 <kala> not quite getting past 
08:34:23 <EvanR> i guess it can be reused per pair
08:34:50 <kala> Ski: map show
08:34:53 <Iceland_jack> I showed you how to get from [1,2,3] -> "1,2,3"
08:34:53 <Iceland_jack> <Iceland_jack> > intercalate "," (map show [1,2,3])
08:34:53 <Iceland_jack> <lambdabot>  "1,2,3"
08:35:12 <ski> kala : and from that to `["1,2,3"]' ?
08:35:24 <Iceland_jack> The rest should be straight forward
08:36:55 <kala> ski : I dont know
08:37:20 <ski> Iceland_jack gave a suggestion. have you tried it ?
08:37:33 <kala> Ski I did
08:37:51 <ski> did you understand it ?
08:38:45 <kala> ski : Yup I did
08:39:11 <mrkkrp> How to put relatively long multi-line string into Haskell source?
08:39:32 <Iceland_jack> kala: Do you understand what the final step needed is?
08:39:50 <kala> no iceland
08:39:54 <tdammers> mrkkrp: I like file-embed
08:40:10 <Iceland_jack> Using my solution you can go from [1,2,3]           -> "1,2,3"
08:40:10 <Iceland_jack> Your goal is to get from          [[1,2,3],[1,2,3]] -> ["1,2,3","1,2,3"]
08:40:16 <dmj`> mrkkrp: you could do unlines [ "line1", "line2" ]
08:40:16 <tdammers> put the string in a separate source file and embed it with quasiquotes
08:40:16 <dmj`>  
08:40:34 <dmj`> str = "multi\
08:40:34 <dmj`>         \line"
08:40:41 <ski> kala : do you know list comprehensions ?
08:40:51 <mrkkrp> dmj`, yes, this is what I use now
08:41:16 <kala> ski :Yes I do
08:41:48 <ski> kala : can you use a list comprehension here to effect what Iceland_jack indicated ?
08:42:55 <dolio> EvanR: I'm not sure how heavyweight mvars are. But it's probably fine.
08:43:45 <EvanR> dolio: i can use just one, like the vessel at the bank flying up and down the pneumatic tubes
08:44:23 <kala> ski: I do not understand in it still :/
08:44:27 <dolio> If you're limiting yourself to one at a time, you probably don't even need a chan, just two mvars.
08:44:43 <dolio> Maybe three.
08:44:44 <ski> kala : which/what do you not understand ?
08:44:47 <EvanR> you do need a chan on the receiving side
08:44:59 <EvanR> if its going to service multiple clients
08:45:22 <EvanR> maybe not
08:45:22 <kala> List comprhensios over intercalate "," (map show [1,2,3])
08:45:41 <dolio> Well, presumably the clients have to block for an opportunity to submit, too, because you don't want people listening for other people's responses by mistake.
08:46:01 <EvanR> unless each client has their own mvar
08:46:06 <Iceland_jack> kala: You should review some Haskell basics, have you looked at Learn You a Haskell
08:46:06 <Iceland_jack> @where lyah
08:46:06 <lambdabot> http://www.learnyouahaskell.com/
08:46:26 <ski> kala : let's try something simpler. you start with `"abc"', and you want `"cba"'. how can you do that ?
08:46:42 <EvanR> but i guess theres no point in having the chan build up if everyone is waiting anyway
08:46:47 <dolio> Oh, yes. If there's one mvar per submitter, you need a chan. I thought you meant one at all.
08:47:16 <dolio> I wouldn't be surprised if thinking about this is premature optimization, though.
08:47:27 <dolio> Unless you're really doing a lot of these communications.
08:47:41 <EvanR> well assuming i want a synchro call, then i just want it to work
08:47:54 <EvanR> and be simple 
08:47:54 <kala> ski reverse abc
08:48:06 <ski> > reverse "abc"  -- yes
08:48:07 <lambdabot>  "cba"
08:48:19 <EvanR> so one MVar to submit, one MVar to hold the response
08:48:30 <EvanR> (to be allowed to submit)
08:48:42 <ski> kala : then, now you get a list of strings, `["abc","defg"]' -- how to get `["cba","gfed"]' ?
08:48:51 <kala> map reverse
08:49:27 <ski> > map reverse ["abc","defg"]  -- yes, this is one way
08:49:28 <lambdabot>  ["cba","gfed"]
08:49:46 <juanpaucar> is hayoo working for someone?
08:49:47 <ski> > [reverse s | s <- ["abc","defg"]]  -- using a list comprehension is another way
08:49:48 <lambdabot>  ["cba","gfed"]
08:50:43 <ski> kala : now, you know how you can get from `[1,2,3]' to `"1,2,3"' -- can you now use either of the above two methods to get from `[[1,2,3],[1,2,3]]' to `["1,2,3","1,2,3"]' ?
08:50:44 <EvanR> three mvars
08:54:10 <mniip> <ski> > map reverse ["abc","defg"]  -- yes, this is one way
08:54:16 <mniip> > foldr ((:) . foldl (flip (:)) []) [] ["abc", "defg"]
08:54:17 <lambdabot>  ["cba","gfed"]
08:54:36 <EvanR> dolio: http://lpaste.net/126707
09:01:58 <mmachenry> I use STM a lot and I really like the orElse combinator. I have noticed recently that Maybe also has a straight-forward and very convenient meaning for orElse. I thought to myself, he this should be a type class that's a subclass of Monad. 
09:02:18 <johnw> it's called Alternative
09:02:20 <mmachenry> Turns out there *is* an orElse for Maybe in Scrap Your Boiler Plate
09:02:22 <johnw> <|>
09:02:28 <mmachenry> Oh!
09:02:46 <mmachenry> I hadn't found that yet. johnw, isn't that from Applicative? 
09:02:58 <johnw> yes
09:03:34 <mmachenry> That's interesting. So orElse from SYB is <|> for Maybe.
09:04:06 <mmachenry> and … wait is STM applicative it must be so shouldn't "orElse = (<|>)"
09:05:05 <johnw> STM has an Alternative instance
09:05:44 <dolio> EvanR: Looks good to me.
09:06:09 <EvanR> haskell rox
09:07:09 <dolio> I was considering that maybe you don't need the extra lock, but you probably do.
09:07:58 <dolio> It'd probably work most of the time without it, but it'd be a race.
09:08:10 <EvanR> heh
09:08:11 <EvanR> no thanks
09:08:55 <mmachenry> johnw: Wait, (<|>) is declared in Applicative but the definition for Maybe defines (<*>). http://hackage.haskell.org/package/base-4.7.0.2/docs/src/Control-Applicative.html#%3C%7C%3E
09:08:57 <dolio> Oh, wait, no, you really need it.
09:09:05 <EvanR> how would it fail
09:09:38 <dolio> One guy submits, the worker reads and starts working, then a second guy submits, and they both block on the output.
09:09:58 <EvanR> yeah
09:10:05 <EvanR> busted
09:10:09 <dolio> After that further submissions block, but two is enough.
09:11:42 <pdkl> Greetings... I have a list of elements , that I want to reduce ? to a single item wrapped around a div
09:12:01 <pdkl> i applogize, this is in javascript, and there is no #ramdajs channel.
09:13:46 <mmachenry> johnw: Oh no wait, I get it now. Thanks! :)
09:15:29 <japesinator> I'm having a really strange problem
09:15:30 <japesinator> https://gist.github.com/japesinator/ea7a52299654b1579ed2
09:15:38 <japesinator> cabal thinks I've installed criterion
09:15:48 <japesinator> but I can't import it, and it isn't in ghc-pkg list
09:15:53 <japesinator> am I doing something wrong?
09:16:25 <hexagoxel> japesinator: are you using a sandbox?
09:17:33 <japesinator> I am
09:17:34 <sm> morning all
09:17:46 <sm> a System.Console.GetOpt question: can anyone see why test-framework's --hide-successes flag clears its --threads flag, from https://github.com/haskell/test-framework/blob/master/core/Test/Framework/Runners/Console.hs#L42-106 ? 
09:17:54 <japesinator> should I delete it?
09:19:09 <hexagoxel> japesinator: then use `cabal sandbox hc-pkg -- list` instead of `ghc-pkg list`
09:19:49 <cfoch> hello
09:20:17 <hexagoxel> (ghc-pkg does not know about the sandbox; that is why cabal sandbox hc-pkg is necessary)
09:20:21 <japesinator> hexagoxel: oh that has it!
09:20:27 <japesinator> how do I import it to my program?
09:22:21 <kadoban> japesinator: As usual, and then build it with cabal. If you want to use runhakell or friends, they need to be run through cabal as well.
09:22:57 <japesinator> so I need to set up a cabal package?
09:23:54 <geekosaur> no
09:23:56 <hexagoxel> japesinator: nope; `cabal repl` or `cabal exec -- runhaskell` will work without a package
09:24:45 <japesinator> oh OK
09:24:49 <japesinator> thanks!
09:31:04 <osa1> is anyone here using pipes-parse package? any ideas what's produced when a parser is failed?
09:34:33 <rui3> Does ghci work with cabal sandboxes?
09:34:43 <hiptobecubic> rui3, "cabal repl"
09:34:48 <hiptobecubic> i think
09:35:48 <rui3> hiptobecubic: Thanks! Seems to work!
09:36:50 * hackagebot cless 0.1.0.0 - Colorized LESS  http://hackage.haskell.org/package/cless-0.1.0.0 (HideyukiTanaka)
09:47:20 <nerium> I*m trying to add a type family constraint to my "toggle" function, but I'm not sure how to continue.
09:47:21 <nerium> https://gist.github.com/oleander/114b5e33dfd2fa2752fe
09:47:22 <nerium> Any idea?
09:47:35 <Luke> I'm testing some code in a StateT monad with Hunit. Is it normal to use a Writer [TestCases] (StateT) to gather up the test cases to run?
09:47:44 <Luke> or am I missing something? 
09:56:42 <sm> ohhh, at last I see my bone headed mistake. ++ has higher precedence than if..then..else
10:10:30 <rui3> Any reason why is Rational is not a Fractional?
10:12:24 <geekosaur> it is here?
10:12:51 <Iceland_jack> rui3: there is an instance 'Integral a => Fractional (Ratio a)'
10:12:53 <geekosaur> the trick is that Rational is a type synonym; the instances are attached to the actual type Ratio a
10:13:06 <geekosaur> (for Rational, a is Integer)
10:13:19 <Iceland_jack> ghci> :t undefined ∷ Fractional Rational ⇒ a
10:13:19 <Iceland_jack> undefined ∷ Fractional Rational ⇒ a :: a
10:16:52 <rui3> Humm
10:17:05 <BurningCa007> hola haskell hombres
10:17:35 <Iceland_jack> Hey BurningCa007 :)
10:21:12 <rui3> geekosaur: Iceland_jack: thanks. I got quite confused by the fact that some instances of Rational appeared on :info Fractional so I thought they were all
10:21:27 <rui3> BurningCa007: aloha Haskell señor
10:21:37 <geekosaur> you often need to import more stuff to see all instances
10:21:46 <geekosaur> I imported Data.Ratio to get a more complete list
10:22:00 <Baurin> hi
10:24:50 <calvinx> how can I use quickCheck in a haskell file? This doesn’t run. http://lpaste.net/126709
10:25:23 <calvinx> I am aware of `$(quickCheckAll)` but I am trying to figure out how to use quickCheck.
10:27:27 <mrcactu5> hello having difficulty installing iHaskell - trouble with profunctors, semigroupoid etc
10:27:27 <clrnd> BurningCa007, hola chabon
10:36:53 * hackagebot b9 0.4.0 - A tool and library for building virtual machine images.  http://hackage.haskell.org/package/b9-0.4.0 (SvenHeyll)
10:36:58 <Baurin> are there an equivalent of: "time ./A +RTS -N2" in Windows?
10:38:39 <Baurin> to test the speed improvement with several proccessors?
10:39:50 <rui3> Is there a built in "flip (.)" operator?
10:39:52 <ReinH> I wouldn't suggest using time on linux either.
10:40:02 <ReinH> I would suggest using criterion, a Haskell benchmarking library.
10:40:19 <ReinH> rui3: Control.Category has one. There isn't one in the Prelude.
10:40:33 <rui3> ReinH: Thanks
10:41:53 * hackagebot cmark 0.2 - Fast, accurate CommonMark (Markdown) parser and renderer  http://hackage.haskell.org/package/cmark-0.2 (JohnMacFarlane)
10:42:56 <Baurin> ReinH, ok
10:51:51 <gyaretto> How do I go about using hindent with vim? The hindent repo is unclear.
10:56:28 <ReinH> gyaretto: I'm not sure if there's any integration yet for vim
10:57:21 <ReinH> Ah, there's https://github.com/chrisdone/hindent/blob/master/vim/hindent.vim
10:57:41 <ReinH> Anyway, you can just pipe a visual selection through :!hindent<CR>
10:57:53 <glguy_> rui3: You can use the :info! command to see a more complete instance list
10:59:18 <ReinH> I wonder if that vim file is necessary or if you couldn't just ``set formatprg=hindent''
10:59:44 <gyaretto> ReinH: Yeam, I'm unsure what to do with that file. I normally use Pathogen to install plugins as submodules.
11:00:13 <ReinH> gyaretto: the file would go in .vim/plugins
11:00:26 <gyaretto> Just the file?
11:00:29 <ReinH> Yes.
11:00:39 <gyaretto> Ohkay. Thanks! :)
11:00:56 <ReinH> You could also copy https://github.com/chrisdone/hindent/blob/master/vim/hindent.vim#L6-L22 into your .vimrc
11:00:58 <ReinH> Sure.
11:01:26 <ReinH> Well, formatprg would be global, so not an ideal solution
11:02:26 <gyaretto> ReinH: Well, it would only make any difference while editing Haskell files, right?
11:02:39 <gyaretto> autocmd Filetype Haskell
11:02:48 <ReinH> The solution in the file is fine.
11:02:55 <ReinH> I was talking about an alternative using formatprg
11:03:16 <gyaretto> Oh, ohkay.
11:04:23 <gyaretto> ReinH: The first four lines aren't necessary?
11:04:44 <ReinH> gyaretto: Not in your vimrc, they prevent the plugin from being reloaded unnecessarily
11:05:11 <gyaretto> Gotcha. Thanks!
11:07:25 <zugz> there's a huge amount of haskell integration for vim - see https://github.com/begriffs/haskell-vim-now and the various projects it uses
11:11:32 <sternenseemann> ReinH: you're asking for haskell vim integration?
11:11:44 <sternenseemann> ReinH: I can recommend https://github.com/raichoo/haskell-vim which contains better syntax files
11:11:54 * hackagebot matrices 0.3.2 - native matrix based on vector  http://hackage.haskell.org/package/matrices-0.3.2 (kaizhang)
11:12:17 <ReinH> sternenseemann: I'm not.
11:12:33 <sternenseemann> ReinH: Then I have misread the backlog
11:21:55 * hackagebot monoidal-containers 0.1.1.0 - Containers with monoidal accumulation  http://hackage.haskell.org/package/monoidal-containers-0.1.1.0 (BenGamari)
11:21:57 * hackagebot monoidal-containers 0.1.2.0 - Containers with monoidal accumulation  http://hackage.haskell.org/package/monoidal-containers-0.1.2.0 (BenGamari)
11:23:53 <bobfang> hi
11:24:01 <sternenseemann> hello
11:24:05 <bobfang> so I have a quick question
11:24:13 <bobfang> I have some code like this:
11:24:18 <bobfang>   renderInlines :: [Inline] -> IO ()
11:24:19 <bobfang>   renderInlines is = case is of
11:24:19 <bobfang>     (i:iss) -> renderInline i >> renderInlines iss
11:24:20 <bobfang>     [] -> return ()
11:24:45 <Denommus> anyone using hsqml for anything?
11:24:50 <bobfang> its like mapping the renderInline function over a list of Inline
11:25:06 <bobfang> I am wondering if there is a built-in map function for this kind of task
11:25:07 <Denommus> I wish to know if it's possible to call JavaScript code from Haskell, instead of the other way around
11:25:14 <Cale> renderInlines = mapM_ renderInline
11:25:15 <mauke> mapM_ renderInline
11:25:21 <bobfang> cool thanks 
11:25:33 <Cale> mapM_ f xs = sequence_ (map f xs)
11:25:43 <Cale> :t sequence
11:25:44 <lambdabot> Monad m => [m a] -> m [a]
11:25:45 <Cale> :t sequence_
11:25:46 <lambdabot> Monad m => [m a] -> m ()
11:26:30 <sternenseemann> Denommus: ghcjs has got a js ffi afaik
11:26:49 <sternenseemann> Denommus: but the question is if it is stable enough
11:27:07 <Denommus> sternenseemann: QML has its own JavaScript runtime, GHCJS won't do it
11:27:43 <sternenseemann> Denommus: oh, I see
11:27:48 <sternenseemann> idk
11:27:56 <bennofs> Denommus: I used hsqml to write a GUI for viewing "replays" from the game I'm writing an AI for
11:27:57 <ReinH> bobfang: In the absence of mapM_, you might notice that your function fits the foldr pattern of "what do you do with the empty list, what do you do with x cons xs?" and write renderInlines = foldr (>>) (return ())
11:28:33 <Denommus> bennofs: I'm wondering if I can use QML just as a GUI DSL. I don't want any of its scripting or state features
11:28:34 <bobfang> yeah I tried use foldr but didn't get it working
11:28:43 <ReinH> Oh, no, it would be foldr ((>>) . renderInline) (return ())
11:28:45 <Denommus> bennofs: I want to treat everything with FRP instead
11:29:26 <ReinH> bobfang: sequence_ = foldr (>>) . renderInline) (return ())
11:30:03 <bennofs> Denommus: I think the way to do that would be to expose your data as a model (using propertySigRO or propertySigRW) and then define your GUI in terms of the data in the model
11:30:10 <ReinH> bobfang: mapM_ f = sequence_ . map f, but foldr f z . map g = foldr (f . g) z, so mapM_ f = foldr ((>>) . f) (return ())
11:30:28 <bennofs> Denommus: That way, you don't need to do anything special, the GUI will update automatically whenever your data changes
11:30:29 <bobfang> cool thanks :)
11:30:43 <bennofs> Denommus: (you need to fire the events from the Haskell code when you change something though)
11:30:48 <Denommus> bennofs: that seems a great approach
11:30:49 <ReinH> bobfang: woops, I meant renderInlines =, not sequence_ =. sequence_ = foldr (>>) (return ())
11:31:34 <ReinH> bennofs: hsqml eh
11:31:55 <bennofs> Denommus: for example, in my game, I expose a board model: it contains the state of each of the board fields (the board is made up of hexagonal fields)
11:31:55 * hackagebot cmark 0.2.0.1 - Fast, accurate CommonMark (Markdown) parser and renderer  http://hackage.haskell.org/package/cmark-0.2.0.1 (JohnMacFarlane)
11:32:28 <bennofs> Denommus: I also have a turn property, which is RW. Whenever the turn property is changed, the board property is updated to reflect the state of the game at the new turn
11:32:57 <bennofs> Denommus: so all I do in QML is registering an event handler for pressing space which only contains the code: turn += 1. 
11:33:10 <bennofs> The rest of the logic is handled by the haskell code
11:35:01 <bennofs> Denommus: I'm currently trying to write a nicer library for this to make it work with reactive-banana. In that case, you would get an Event for each qml property (input) and you can also "sink" events to QML properties
11:35:16 <bobfang> btw I am trying to build up a terminal-based markdown viewer as an exercise for learning haskell, it is open sourced here: https://github.com/dorafmon/mdcat if you guys can give me some advice I would be grateful
11:35:24 <bennofs> Still trying to find a nice interface for that though :D
11:35:45 <Denommus> bennofs: cool
11:36:22 <Denommus> bennofs: but wouldn't properties be behaviors?
11:36:55 <bennofs> Denommus: well, you should be able to observe when properties change IMO. You can convert it to behaviour using stepper if you want though#
11:37:07 <Denommus> bennofs: ah, right
12:06:57 * hackagebot snaplet-postgresql-simple 0.6.0.1 - postgresql-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-postgresql-simple-0.6.0.1 (DougBeardsley)
12:06:59 * hackagebot psqueues 0.2.0.1 - Pure priority search queues  http://hackage.haskell.org/package/psqueues-0.2.0.1 (JasperVanDerJeugt)
12:19:30 <hehehe> [[1,2,3],[1,2,3]] -> ["1,2,3","1,2,3"] could someone please help me with this?
12:20:53 <hehehe> [[1,2,3],[1,2,3]] -> ["1,2,3","1,2,3"] could someone please help me with this?
12:21:31 <unknownloner> asking twice so quickly doesnt really help
12:21:50 <hehehe> unknowloner: haha
12:22:17 <dmj`> > concatMap show [[1,2,3],[1,2,3]]
12:22:17 <ReinH> hehehe: that wasn't a joke.
12:22:18 <lambdabot>  "[1,2,3][1,2,3]"
12:22:22 <arkeet> @let f = const ["1,2,3","1,2,3"] in f [[1,2,3],[1,2,3]]
12:22:22 <lambdabot>  Parse failed: Parse error: in
12:22:24 <arkeet> > let f = const ["1,2,3","1,2,3"] in f [[1,2,3],[1,2,3]]
12:22:26 <lambdabot>  ["1,2,3","1,2,3"]
12:22:26 <Iceland_jack> hehehe: Welcome back :)
12:22:30 <arkeet> done!
12:22:47 <unknownloner> > map (intercalate "," . map show) [[1,2,3],[1,2,3]]
12:22:48 <lambdabot>  ["1,2,3","1,2,3"]
12:22:51 <hehehe> Icelan_Jack : Bro! Please help its 1 am here
12:22:58 <hehehe> I gotta sleep afer fixing this :/
12:23:16 <Iceland_jack> hehehe: unknownloner gave you the answer
12:23:49 <mauke> oh, another one?
12:23:51 <mauke> which class is this?
12:23:55 <unknownloner> haha
12:24:24 <kadoban> Any why do they all ask twice?
12:24:42 <Iceland_jack> hah
12:24:59 <unknownloner> always the exact same wording
12:25:10 <unknownloner> as if itll make us understand better
12:25:25 * Iceland_jack double clicks icon
12:25:27 * Iceland_jack double clicks icon again
12:25:34 <kadoban> Ya, that too. Is it just the same person over and over, hoping they'll get a better answer?
12:25:36 <arkeet> not sure what was wrong with my answer.
12:25:50 <Iceland_jack> arkeet: It passes all the unit tests
12:25:51 <hehehe> Iceland Jack, arkeet, Unknownloner Thanks guys :)
12:26:26 <unknownloner> arkeet passes tests, push to prod
12:27:40 <arkeet> :)
12:28:32 <dhinojosa> How do I put some thing that is not essential in a do notation?
12:28:38 <dhinojosa> I hope I am phrasing that right
12:28:41 <int-e> unknownloner: it's hard to keep that up when you know the same question has already been asked 4 hours earlier with plenty of attention.
12:28:52 <dhinojosa> let a = .... works fine
12:29:44 <tnks> silly question. . . in ghci, when I have too many modules loaded, the prompt gets a bit weighty. . . how do you manage that generally?
12:29:48 <int-e> why would you put anything nonessential in your code?
12:29:56 <Iceland_jack> tnks: :set prompt "> "
12:30:00 <rui3> glguy_: Great tip! Thanks
12:30:04 <arkeet> dhinojosa: do you have an example?
12:30:26 <arkeet> it's not clear what you mean.
12:31:01 <dhinojosa> arkeet, yeah trying hard to explain
12:31:03 <tnks> Iceland_jack: what about multiline?
12:31:18 <arkeet> tnks: you can use :{ and :} to start/end multiline input.
12:31:33 <arkeet> oh.
12:31:33 <Iceland_jack> tnks: Do you mean how you enter multiple lines in GHCi? I usually just write it with braces and semicolons
12:31:37 <dhinojosa> I am experimenting with newtype
12:31:38 <arkeet> yeah, there's no way to change the prompt for that.
12:31:41 <tnks> ah, prompt2, maybe.
12:31:44 <Iceland_jack> prompt2 works
12:31:46 <arkeet> unless they added that.
12:32:13 <arkeet> neat.
12:32:17 <dhinojosa> arkeet: Let me make a gist...standby
12:32:26 <f|`-`|f> So is there a way to unload portions of the program at times
12:34:15 <dhinojosa> arkeet: https://gist.github.com/dhinojosa/1f3c84cd49445446ba48
12:35:13 <dhinojosa> arkeet: I want a way to verify that either line 40 or 41 will crash because it isn't lazy
12:36:41 <dhinojosa> arkeet: I know >> does that sort of thing, but don't know how >> translates using do-notation
12:36:58 <mauke> do { X; ... } == X >> do { ... }
12:36:58 * hackagebot cmark 0.2.0.2 - Fast, accurate CommonMark (Markdown) parser and renderer  http://hackage.haskell.org/package/cmark-0.2.0.2 (JohnMacFarlane)
12:37:07 <Iceland_jack> dhinojosa:
12:37:07 <Iceland_jack>     x >> y = do x; y
12:39:07 <dhinojosa> Iceland_jack: trying
12:39:37 <Iceland_jack> dhinojosa: You can run the following in GHCi
12:39:38 <Iceland_jack>     ghci> print 1 >> print 2
12:39:50 <Iceland_jack> will give the same result as
12:39:50 <Iceland_jack>     ghci> do print 1; print 2
12:40:08 <dhinojosa> Iceland_jack: and if the print stmts are multiline?
12:41:23 <Iceland_jack> You can do the same thing :) or start using an editor
12:41:23 <Iceland_jack>     ghci> do (print 1 >> print 2); (print 3 >> print 4)
12:42:14 <Iceland_jack> dhinojosa: If you want multiline editing you can enable it with :set +m
12:42:14 <Iceland_jack>     ghci> :set +m
12:42:14 <Iceland_jack>     ghci> do print 1
12:42:17 <Iceland_jack>     ghci|    print 2
12:42:24 <dhinojosa> Iceland_jack: ah, that's it
12:42:29 <mrkkrp> Is there any examples of parsec that use Data.Text instead of String? This answer on SO http://stackoverflow.com/questions/4064532/using-parsec-with-data-text/9228290#9228290 says that it's possible, but I'm having trouble migrating from String to Data.Text.
12:42:29 <mrkkrp>  
12:42:31 <dhinojosa> thanks Iceland_jack 
12:42:51 <Iceland_jack> But you'll need to press an extra newline
12:43:29 <Iceland_jack> dhinojosa: and it must be aligned, I sometimes mix :set +m with { braces; semicolons; } for that reason
12:43:30 <dhinojosa> Iceland_jack: ah. right
12:44:21 <Iceland_jack>     ghci> do {
12:44:21 <Iceland_jack>     ghci| print 1; print
12:44:21 <Iceland_jack>     ghci|     15
12:44:21 <Iceland_jack>     ghci| }
12:44:50 <Iceland_jack> Same with ‘let’
12:45:38 <Iceland_jack> to avoid having to indent function clauses proper
12:53:25 <hexagoxel> dhinojosa: i do not think >>= is strict in the way you expect there.
12:55:14 <stelleg> anyone know if its possible to get ghc to realize KnownNat n => KnownNat (n + 1)?
12:57:50 <rui3> I'd like to export long lists of numbers to some file, to read in another program. What's a format with a simple library to do so? So far I've only found CSV
12:58:33 <EvanR> just a list of numbers can be done with one number per line
12:59:05 <mauke> (putStr . unlines . map show) nums
12:59:27 <EvanR> which is a degenerate form of csv
12:59:32 <rui3> Hehe, yes
12:59:47 <rui3> I was hoping for some binary format, but I am sure text will do
12:59:56 <mauke> text format is best format
12:59:57 <rui3> Thanks
13:02:42 <nerium> I'm  trying to get this to work, but it's failing for some reason, why?
13:02:43 <nerium> https://gist.github.com/oleander/f816aa5d62d6428842ff
13:03:34 <mauke> your line numbers are all wrong
13:03:56 <nerium> maaku: Sorry
13:03:59 <nerium> I'll fix it
13:04:15 <nerium> maaku: It should 21 and 22
13:04:21 <nerium> *It should be
13:04:25 <maaku> nerium: mauke not maaku
13:04:26 <mauke> what happens if you put an explicit type annotation on n?
13:04:32 <mauke> er, kind annotation
13:05:02 <nerium> maaku: Got an example :) ?
13:08:38 <nerium> maaku: Any idea?
13:08:49 <maaku> nerium: mauke not maaku
13:08:58 <maaku> you're highlighting the wrong person
13:09:30 <kaidelong> ping ManateeLazycat
13:10:09 <kaidelong> any gtk2hs devs in here right now?
13:10:12 <nerium> mauke: Any idea how to do it?
13:10:16 <nerium> maaku: Sorry
13:10:38 <kaidelong> gtk2hs-buildtools appears to need alex but does not depend on it
13:11:05 <kaidelong> and happy
13:11:07 <arkeet> ping dmwit
13:20:39 <Ornedan> Is it safe to emulate connect timeout on Network's connectTo with something like async or timeout?
13:21:32 <Ornedan> Since there's no way in Network to actually set the socket timeout options
13:22:00 * hackagebot executable-hash 0.1.1.1 - Provides the SHA1 hash of the program executable  http://hackage.haskell.org/package/executable-hash-0.1.1.1 (MichaelSloan)
13:22:02 * hackagebot hplayground 0.1.2.5 - monadic, reactive Formlets running in the Web browser  http://hackage.haskell.org/package/hplayground-0.1.2.5 (AlbertoCorona)
13:22:17 <glguy_> It's safe to kill a connectTo, it's properly bracketed for exceptions. As for setting socket options you can use the Network.Socket module and the Socket is exposed there
13:22:33 <glguy_> using Network.Socket is generally the recommended interface to the network package
13:24:50 <Ornedan> glguy_: I know. But the setters only work for int-typed options
13:25:45 <Ornedan> SO_RCVTIMEO and SO_SNDTIMEO are set with a more complex struct, for which there's nothing in Network
13:25:56 <glguy_> If you need them you can use the FFI to get to them
13:35:24 <alanz> I see RC3 is out http://downloads.haskell.org/~ghc/7.10.1-rc3/
13:42:39 <Luke> I'm trying to use trace from some pure code but nothing is printing. Are there any compiler flags I should have or not have set?
13:42:54 <EvanR> you have to make sure the expression you wrapped gets evaluated
13:43:02 <EvanR> you cant put trace just anywhere
13:43:30 <Luke> yeah at least it looks like it's being evaluated
13:44:18 <Luke> anythign else?
13:44:45 <EvanR> how do you know
13:45:15 <Cale> If it were being evaluated, then you'd see the trace, unless you're redirecting output or something.
13:45:17 <Luke> the value I'm wrapping is being printed from a unit test
13:45:23 <Cale> hmm
13:45:29 <Luke> HUnit is runnign it
13:45:53 <Cale> Well, if it's actually printing it, then yeah, it's almost surely being evaluated.
13:46:00 <Luke> actually hold on... I thought HUnit was returning the result but it's returning Nothing. so that is in fact the issue
13:46:05 <Luke> thanks guys
13:50:08 <Baurin> bye
14:01:37 <gyaretto> What is the syntax for adding to "other-modules in the .cabal file? Just a comma separated list?
14:02:24 <gyaretto> "other-modules"*
14:03:21 <hexagoxel> gyaretto: have a look at Cabal's cabal file: https://github.com/haskell/cabal/blob/master/Cabal/Cabal.cabal
14:04:52 <jophish> What's the term for identifiers in haskell which start with an uppercase letter? "NonTerms" ?
14:06:27 <SrPx> Is there any standard function that combines putStr and readLn? 
14:06:32 <SrPx> actually... wait
14:06:34 <sclv> jophish: it depends
14:06:42 <sclv> on the value level its a constructor
14:06:59 <jophish> sclv: I'm writing a function to go from some text with perhaps spaces to SomethingLikeThis
14:07:01 <sclv> on the type level its a type, etc
14:07:09 <jophish> in the context of writing haskell declarations
14:07:25 <jophish> I guess I should call it toUpperCamelCase or something
14:07:59 <sclv> StrongCaps is used too I've seen
14:08:11 <ianjneu> so... I can't seem to get cabal build to accept -rtsopts. How do I do that?
14:08:12 <sclv> UpperCamel is pretty descriptive tho
14:08:44 <sclv> ianjneu: what do you mean? you can't pass them to built executables, or you can't pass them to cabal, or ?
14:09:00 <jophish> thanks sclv!
14:09:45 <ianjneu> sclv: I'm not entirely sure what I have to do. I'm trying to increase my stack size, and no matter what I give my executable for +RTS -Ksize, it dies with the same stack usage.
14:10:16 <sclv> right, you need to build your executable with rtsopts
14:10:24 <sclv> i think
14:10:33 <ianjneu> sclv: I have ghc-options: -rtsopts in my cabal file.
14:11:41 <sclv> weird.
14:12:03 <sclv> what version ghc too? i seem to recall we gave unlimited stack by default in the latest ghcs tho i don't remember for sure
14:12:39 <hexagoxel> ianjneu: how do you call the executable?
14:12:48 <ianjneu> sclv: I just held down 0 for a lot longer. Appears to be running with more stack. Sorry for the noise.
14:13:28 <sclv> hah, np
14:14:23 <ianjneu> yup. That took all my memory and swap, then died. Cool. Hmmm...
14:16:53 <dhinojosa> Iceland_jack: Got it
14:17:01 <dhinojosa> What I wanted was evaluate
14:17:04 <dhinojosa> not print
14:17:21 <dhinojosa> print was cool if I wanted to print an IO to the console
14:17:28 <dhinojosa> I just wanted something evaluated
14:17:29 <dhinojosa> ;)
14:19:44 <clrnd> it'd be super cool if you could send a signal to cabal and it'd print how many packages it has yet to install
14:19:47 <clrnd> just saying
14:21:59 <funfunctor> Hackage needs a package warning collector that reports off to package maintains about problems. Maybe something from the NixOS crew could be used
14:22:02 * hackagebot rtorrent-rpc 0.2.2.0 - A library for communicating with RTorrent over its XML-RPC interface.  http://hackage.haskell.org/package/rtorrent-rpc-0.2.2.0 (KaiLindholm)
14:22:59 <bennofs> funfunctor: nixos maintainers should already open issues for build problems they encounter
14:24:02 <bennofs> funfunctor: also, packages in stackage are regulary tested to build
14:25:44 <funfunctor> bennofs: well I mean I cringe whenever I see hackage packages build with warnings.. Feels like compiling another GNU C project :p
14:27:13 <Athas> Is there a convenient simple Haskell style checker?  hlint is good, but I'm looking for even more superficial things (trailing whitespace etc).
14:28:38 <unknownloner> most editors I've used have had settings to highlight / warn about trailint whitespace specifically
14:28:53 <Athas> Yes, but I want to do this in the test suite.
14:29:09 <unknownloner> I dont know of any haskell specific checkers that include that
14:29:25 <Athas> Well, what about any generic ones, then?  I know Git has a built-in one.
14:29:36 <funfunctor> Athas: Use the Regexp package
14:30:51 <funfunctor> e.g. match :: String -> [Int]
14:30:51 <funfunctor> match = fmap read . concat . catMaybes . fmap (matchRegex pattern) . lines  where pattern = mkRegex "^ *([0-9]*)% "
14:31:09 <Athas> If I have to write the regex myself I can just use grep.
14:31:25 <Athas> I just wanted a premade tool if it existed, but I can hack this up myself if there is no such thing.
14:31:30 <funfunctor> Athas: yea but you wanted it part of your test-suite no?
14:31:52 <funfunctor> This way some random shell script wont break under your feet
14:31:54 <Athas> Yeah, which is just a shell script running various things.
14:32:57 <funfunctor> Athas: well I have a bunch of small Haskell programs under test-suite/ that check for things
14:33:09 <funfunctor> Such as Haddock coverage like the above
14:33:24 <dhinojosa> So, I assumed that if, do, while, let are all part of the language is there an official list that shows the syntax keyword list?
14:33:53 <dhinojosa> sorry take out while
14:33:56 <Athas> funfunctor: oh, can I see them?
14:34:04 <dhinojosa> don't know why I put that in there
14:34:16 <ReinH> dhinojosa: The Haskell report lists them somewhere
14:34:31 <funfunctor> Athas: https://github.com/victoredwardocallaghan/hlibBladeRF/tree/master/test-suite
14:34:45 <funfunctor> not very exciting ones, if you have improvements let me know Athas
14:35:14 <ReinH> dhinojosa: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003
14:35:22 <dhinojosa> ReinH: Got this https://wiki.haskell.org/Keywords
14:35:33 <dhinojosa> ReinH: Oohh, let me check out that one
14:35:55 <ReinH> The wiki page seems good
14:37:09 <dhinojosa> ReinH: Pretty amazing that as part of a language that was developed since 1990, there are only 55 keywords
14:37:33 <dhinojosa> ReinH: everything else is either function or a composition thereof
14:37:39 <ReinH> dhinojosa: The wiki page is being a bit liberal with the term "keyword"
14:37:54 <ReinH> Usually, ' and " wouldn't be classified as keywords.
14:38:11 <funfunctor> bbl
14:38:53 <S11001001> dhinojosa: https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-180002.4
14:39:16 <benzrf> ay
14:39:40 <ReinH> S11001001: That's a better page, yeah
14:39:44 <benzrf> is there some sort of library for synchronizing state across multiple instances of a program, possibly on different computers
14:39:46 <S11001001> ReinH: :)
14:39:55 <benzrf> such that one of them can update it on all of them
14:39:57 <bernalex> wat?
14:40:01 <bernalex> uh wrong buffer
14:40:17 <ReinH> benzrf: There are protocols for that like Raft.
14:40:52 <ReinH> I think there's a package with a Raft implementation
14:41:22 <benzrf> hmm
14:51:43 <hiptobecubic> benzrf, you should also think really hard about whether or not you can achieve what you want without doing that
14:52:45 <ReinH> hiptobecubic: +1
14:53:01 <ReinH> One thing people use for synchronizing state across multiple instances is "a database".
14:53:04 <platz> "withManager" from Network.HTTP.Client from "http-client" returns a lazy bytestring, which is essentially a stream, right?  Contrasting/comparing this with io-streams/http-streams, I'm wondering what http-streams provides over http-client
14:53:38 <ReinH> hiptobecubic: The first rule of building distributed systems is "Don't."
14:53:49 <platz> is it basically resource finalization guarantees, or is there something else about the streaming behavior that is different?
14:54:04 <hpc> the second rule of buildind distributed systems is to use someone else's
14:54:15 <ReinH> hpc: yep
14:54:22 <EvanR> dont talk about building distributed systems
14:54:33 <hiptobecubic> EvanR has found rule 3 :)
14:54:43 <ReinH> ha
14:54:50 <hpc> no, rule 3 is ???
14:54:54 <hpc> rule 4 is profit
14:55:19 <hiptobecubic> rule 4 is "do not offer a service level agreement to your customers if you can help it"
14:55:28 <platz> <    platz> "withManager" from Network.HTTP.Client from "http-client" returns a lazy bytestring, which is essentially
14:55:30 <ReinH> ha
14:55:32 <platz>             a stream, right?  Contrasting/comparing this with io-streams/http-streams, I'm wondering what http-streams
14:55:34 <platz>             provides over http-client
14:55:37 <platz> <    ReinH> hiptobecubic: The first rule of building distributed systems is "Don't."
14:55:40 <platz> <    platz> is it basically resource finalization guarantees, or is there something else about the streaming behavior
14:55:43 <platz>             that is different?
14:55:46 <platz> oops sorry
14:58:21 <hiptobecubic> benzrf, in all seriousness, though, you should try very hard not to design anything that has to care about being distributed
14:58:36 <ReinH> hiptobecubic: I was being completely serious.
14:59:05 <hiptobecubic> ReinH, *I* know that. I'm just making sure benzrf understands the gravity of the situation!
14:59:36 <ReinH> hiptobecubic: :)
15:03:24 <jophish> I'd like to create a data type: data Dim = 1D | 2D | 3D. What do people prefer: data Dim = OneD | TwoD | ThreeD; data Dim = D1 | D2 | D3; data Dim = Dim1D | Dim2D | Dim3D; ?
15:03:27 <jophish> Or something else
15:04:12 <EvanR> by itself that might not be a great type to begin with
15:04:57 <ReinH> I would prefer type-level nats, I think.
15:05:11 <ReinH> Well, maybe not in Haskell.
15:05:12 <jophish> I thought people might suggest that :) 
15:06:01 <jophish> for a bit more context, I'm machine translating the Spir-V spec into Haskell: here's the relevant part: https://www.khronos.org/registry/spir-v/specs/1.0/SPIRV.html#_a_id_dim_a_dim
15:08:01 <ReinH> So not type level nats
15:08:11 <jophish> yeah, I don't think it's too appropriate here
15:08:34 <S11001001> jophish: eh, D3
15:08:58 <koala_man> is 1D even valid?
15:09:17 <jophish> koala_man: nope, that's why I'm looking for an alternative
15:09:18 <kadoban> No, hence his asking which alternative is best.
15:09:44 <mniip> may I suggest peano naturals?
15:09:46 <koala_man> do I have to start parsing the english between haskell code now too? gah
15:09:50 <mniip> 3 isn't too large for peano
15:10:09 <S11001001> jophish: is there a call to add a phantom and gadtify here?
15:11:13 <ReinH> mniip: not really appropriate here.
15:11:23 <jophish> S11001001: Seems a little more than I need
15:11:31 <ReinH> mniip: there are other constructors that don't follow the pattern
15:11:42 <ReinH> (that were elided in order to confuse us, surely ;)
15:12:13 <jophish> ReinH is correct
15:15:21 <benzrf> hmmmm
15:15:33 <benzrf> ok raft is not the kind of thing i meant
15:15:39 <benzrf> to be precise, im thinking about multiplayer games
15:16:09 <benzrf> the recurring problem with multiplayer games is synchronizing some kind of shared state between each player and also probably updating personal state for individuals
15:16:28 <benzrf> and there doesnt really need to be a consensus; the server is right. the end.
15:24:12 <boj> benzrf: you probably want to read these articles http://gafferongames.com/networking-for-game-programmers/
15:24:21 <ReinH> boj: +1, great articles.
15:24:30 <hiptobecubic> oh this looks nice
15:26:05 <benzrf> noooo
15:26:09 <benzrf> this stuff is low level ;-;
15:26:35 <benzrf> i just want some kind of decent solution for simple stuff , not even realtime
15:26:57 <EvanR> tcp stream socket from Network
15:27:10 <benzrf> hrf
15:27:19 <akronix> hey there!!
15:27:26 <benzrf> akronix: hello
15:27:36 <akronix> you guys know how can i contact ekmett??
15:27:49 <akronix> it's for a GSoC proposal
15:27:55 <bobfang> hi this might not be a haskell related question
15:28:16 <benzrf> bobfang: ok
15:28:23 <bobfang> but when you are writing a console based application, how can you know the width of the console?
15:28:26 <benzrf> edwardk: akronix wants a word
15:28:31 <S11001001> akronix: say something about lens
15:28:36 <benzrf> bobfang: you could check the COLUMNS env var
15:28:39 <bobfang> like how many characters fill one line
15:28:49 <bobfang> is there any haskell api for that?
15:28:56 <benzrf> @hoogle environ
15:28:56 <lambdabot> System.Environment module System.Environment
15:28:56 <lambdabot> GHC.Environment module GHC.Environment
15:28:56 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Environments module Graphics.Rendering.OpenGL.GL.Texturing.Environments
15:29:02 <EvanR> stupid terminal tricks
15:29:05 <benzrf> System.Environment probably
15:29:45 <S11001001> akronix: I kid, sort of.  benzrf has already taken care of it
15:30:38 <akronix> ....shall I contact benzrf then?
15:30:52 <benzrf> akronix: S11001001 means when i said 06:25:15       benzrf │ edwardk: akronix wants a word
15:39:12 <Baurin> hi
15:40:35 <bobfang> hi I tried lookupEnv "COLUMNS" I got nothing
15:40:53 <bobfang> and if I do echo $COLUMNS
15:40:55 <bobfang> in terminal
15:40:57 <bobfang> I got 90
15:41:10 <bobfang> Am I doing something wrong?
15:41:25 <koala_man> bobfang: COLUMNS is normally not exported
15:41:40 <bobfang> so should I do some trick?
15:41:44 <ReinH> bobfang: You can use the terminfo database.
15:41:45 <Axman6> I'd be surprised if COLUMNS is part of the environment, it's probably something the shell evaluates
15:41:51 <geekosaur> tput cols
15:42:05 <geekosaur> and $COLUMNS is a bash-ism, which it does because it has readline built in
15:42:08 <ReinH> What geekosaur said, or if you're using a curses lib there might be library support.
15:47:05 * hackagebot vector-space 0.10 - Vector & affine spaces, linear maps, and derivatives  http://hackage.haskell.org/package/vector-space-0.10 (ConalElliott)
15:50:05 <bobfang> hi I have found the function termColumns :: Capability Int
15:50:16 <bobfang> but it gives back Capability Int
15:50:20 <bobfang> not plain int
15:50:27 <bobfang> can I get plain int from it?
15:50:34 <bobfang> I know I shouldn't
15:51:09 <EvanR> where is that from?
15:51:24 <glguy_> getCapability 07:: Terminal 07-> Capability a 07-> Maybe a
15:51:26 <bobfang> https://hackage.haskell.org/package/terminfo-0.4.0.0/docs/System-Console-Terminfo-Cursor.html
15:51:44 <glguy_> bobfang: Look in http://hackage.haskell.org/package/terminfo-0.4.0.0/docs/System-Console-Terminfo-Base.html
15:56:16 <bobfang> hi one more question
15:56:20 <bobfang> setupTerm :: String -> IO Terminal
15:56:34 <bobfang> what should I pass to this function to get current terminal window?
15:56:36 <bobfang> thanks :)
15:56:41 <bobfang> I am a bit confused
15:57:56 <koala_man> bobfang: the terminal type. if you want it to read from $TERM, there's apparently a setupTermFromEnv
15:59:27 <bobfang> cool thanks :)
16:04:20 <RustyShackleford> I'm attempting to write a chess engine. I'm working on the board/representation. Currently, i'm trying to write a function that will tell you what kind of piece is at a square
16:04:39 <RustyShackleford> uh, maybe I should paste some code
16:05:04 <RustyShackleford> but I'm wondering if you would represent pieces as a color and a piece type, i.e. Black and Pawn
16:05:13 <RustyShackleford> or combine them, i.e. BlackPawn
16:05:23 <EvanR> board ! (2,3)
16:06:40 <EvanR> i think id try Piece = Black Man | White Man first
16:06:47 <RustyShackleford> here is some code: 
16:07:05 <RustyShackleford> http://pastebin.com/z9Kh9xB8
16:08:21 <gyaretto> If I'm writing a compiler, would it be do-able to generate the CST while parsing, or should I parse and then build the CST?
16:08:26 <gyaretto> in Haskell
16:08:38 <RustyShackleford> EvanR: is 12 guards in a function outrageous?
16:08:49 <gyaretto> Sorry if this question isn't relevant.
16:09:07 <EvanR> RustyShackleford: for what?
16:09:16 <mpickering> gyaretto: what is the CST?
16:09:21 <Peaker> gyaretto: if you write it as a pure function, laziness can make it generate the CST while parsing, operationally, even if it looks like it is generating it "after" parsing
16:10:17 <gyaretto> mpickering: Concrete syntax tree.
16:10:40 <gyaretto> Peaker: What do you mean? I'm sort of new to Haskell.
16:11:06 <mpickering> What is the second option you are describing?
16:11:14 <mpickering> how would you parse and then build it?
16:11:28 <RustyShackleford> EvanR: uh, it would make more sense if you check the code I pasted
16:11:33 <EvanR> i did
16:11:45 <EvanR> i see 7 guards
16:11:57 <RustyShackleford> but there would be 13 types of Pieces. WhitePawn, WhiteKnight, ... NotOccupied
16:12:00 <gyaretto> mpickering: I'd probably create a second module for building the CST and use the same list of tokens that I passed to the hparser.
16:12:08 <gyaretto> s/hparser/parser/
16:12:24 <EvanR> RustyShackleford: i suggest Array (Int,Int) (Maybe Piece) where Piece = Black Man | White Man, and there are 5 kinds of Men
16:12:33 <Peaker> gyaretto: if you have a pipeline like:   generateAsm . toLowLevel . optimizeHighLevel . parse    it seems like things happen at full stages
16:12:50 <mpickering> so you can do it two ways depending how complicated your language is, if it's simple then you can build the AST as you go
16:12:51 <Peaker> gyaretto: but laziness *might* make the pipeline run a bit of each step
16:13:02 <EvanR> RustyShackleford: er, 6
16:13:13 <mpickering> but if it's complicated then you could tokenize and then parse as you suggest
16:13:16 <mpickering> it's up to you
16:13:32 <EvanR> RustyShackleford: also your game state seems to be missing the right to castle
16:13:51 <RustyShackleford> EvanR: work in progress haha. Also en passant and a few other things
16:14:05 <EvanR> ah yeah
16:14:07 <RustyShackleford> the probelm with an array is that searching for moves can become quite complicated
16:14:19 <gyaretto> Ohkay, thanks mpickering, Peaker! :)
16:14:28 <RustyShackleford> there are some cool tricks if used bitmasks. I suppose that is also complicated though
16:14:35 <EvanR> RustyShackleford: yeah it might not be the best for everything, but at least it can serve as a sane intermediary maybe
16:14:46 <EvanR> the bitmasks are way more complicated
16:14:57 <EvanR> but i expect you want performance boost of some sort
16:15:06 <RustyShackleford> it's what most of the good engines use
16:15:27 <EvanR> personally id start with a "more fun" data structure that is easy to grok
16:15:33 <nickerSLAVEgg> yellow
16:15:34 <EvanR> then worry about performance
16:15:39 <nickerSLAVEgg> cheers mates
16:19:05 <ttt_fff> about how much faster is ghcjs than haste? waht are the main disadvantages of using haste right now?
16:19:15 <ttt_fff> err, what are the most disadvantages of using ghcjs?
16:19:20 <nickerSLAVEgg> klank
16:20:51 <Baurin> bye
16:22:45 <RustyShackleford> EvanR: premature optimization is my style
16:23:38 <EvanR> searching for moves could be a comonadic operation :0
16:24:48 <EvanR> (Board a, Square) is a comonad, a = Maybe Piece for these purposes
16:45:39 <bobfang> hi what's the recommended way to have a global variable?
16:45:45 <bobfang> using a state monad
16:45:46 <bobfang> ?
16:45:46 <_di> tvar?
16:45:49 <moghedrin> bobfang: To not to.
16:45:56 <ReinH> EvanR: (Square -> Maybe Piece, Square) :)
16:46:11 <ReinH> type Board = Square -> Maybe Piece is the denotation :)
16:46:22 <ReinH> (can also be a Map, etc)
16:46:41 <EvanR> yeah
16:46:59 <EvanR> was assuming Board was implemented with an array
16:47:08 <ReinH> Store comonad, as you say
16:47:22 <EvanR> riht
16:50:27 <bobfang> let me rephrase my question a bit, I am using  setSGR from the console.ansi package to write coloured string to terminal, in some cases I have to use setSGR [SetColor Foreground Dull Red] to first write red text, and then use setSGR [SetColor Foreground Dull Green] to write green text, after that I need to switch back to red but the only thing the API provides is setSGR [Reset] which resets to white text, how would you tackle 
16:50:27 <bobfang> this?
16:50:52 <bobfang> from what I see, I need a global stack
16:52:53 <_di> digestive-functors check function has check :: Monad m => v	-> (a -> Bool)	-> Form v m a -> Form v m a
16:52:56 <_di> oops :) 
16:53:20 <_di> so why all examples are check "Can't be empty" (not . null) (string Nothing)
16:53:39 <_di> why resulting form is already specified? 
16:54:11 <_di> shouldnt I feed applicative functors something like Form(raw) -> Form(cleaned)
16:54:22 <_di> https://github.com/ocharles/digestive-functors-aeson/blob/master/test/Tests.hs#L24-L29
16:55:42 <jophish> oh darn! The SpirV spec contains the "Volatile", "NoControl" and "Uniform" enumerations more than once for different types! What am I to do! I suppose I could either [prefix every constructor with it's type (eww), modify just those six constructors (eww makes it hard to search), put each enumeration in a separate module]
16:56:07 <moghedrin> bobfang: I think I would use the State monad, then a simple list as the stack, but that's just me.
16:57:18 <jophish> It seems horrible to put everything in its own module, that's 25 different modules
16:57:27 <moghedrin> bobfang: Although using the state monad feels like overkill for it.
17:01:34 <jophish> edwardk: Could I get your wisdom on this, please? I'd like to do what gl does for punned identifiers but it doesn't really work here because the values (and other properties) for these enumerants are not the same, for example Uniform :: Decoration has value 25 while Uniform :: StorageClass has value 2.
17:04:48 <ReinH> jophish: Yeah, maybe it's horrible, but it seems like the least horrible option.
17:06:01 <jophish> It would be such a pain if one had to have 25 import lines for a compiler, although I'll have to see if one needs to import everything, or if I could make a sensible module reexporting the most common ones
17:07:25 <bobfang> Is there any example on state monad?
17:07:47 <hpc> :t runState
17:07:48 <lambdabot> State s a -> s -> (a, s)
17:08:26 <hpc> > runState (do {x <- get; put 5; y <- get; put 10; return (x + y)}) 8
17:08:28 <lambdabot>  (13,10)
17:09:00 <jophish> There's another option, which (perhaps) makes prefixing the constructors less horrible. Have a class HasUniformEnum a where uniform :: a; instance HasUniformEnum StorageClass where uniform = StorageClassUniform; instance HasUniformEnum Decoration where uniform = DecorationUniform
17:09:08 <hpc> bobfang: stepping through that should introduce everything you need to know in a digestable format
17:09:40 <funfunctor> Hi
17:21:39 <pragrammer> hi
17:22:07 <ski> lo
17:23:00 <pragrammer> i wrote my first haskell program
17:23:05 <pragrammer> would love some feedback
17:23:19 <hpc> @hpaste
17:23:19 <lambdabot> Haskell pastebin: http://lpaste.net/
17:25:07 <pragrammer> the one thing im still missing to make it cleaner is a form of concat like [[a]] -> a -> [a]
17:25:12 <pragrammer> does such as that exist?
17:25:21 <hpc> @hoogle [[a]] -> a -> [a]
17:25:23 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
17:25:23 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
17:25:23 <lambdabot> Data.Graph.Inductive.Internal.RootPath getPath :: Node -> RTree -> Path
17:25:29 <pragrammer> oh right interperse!
17:25:31 <pragrammer> thanks
17:25:49 <hpc> i can never remember the names of those functions
17:25:56 <hpc> repeat and cycle get me constantly too
17:27:02 <pragrammer> is intersperse new?
17:27:04 <pragrammer> its saying not in scope
17:27:12 <hpc> import Data.List
17:27:15 <pragrammer> but its in Data.List which afait was in Prelude
17:27:16 <pragrammer> oh
17:27:26 <hpc> Prelude is a bunch of selective re-exports
17:27:40 <hpc> although theoretically you can import all of base unqualified and get away with it
17:29:33 <pragrammer> ok here goes
17:29:33 <pragrammer> http://lpaste.net/693660870688899072
17:30:09 <pragrammer> the goal is to de-columnize the comment string, and print it like "%d \t %s \n"...
17:30:19 <pragrammer> servere criticism welcome
17:30:49 <funfunctor> any folks around who happen to know some C++ and Haskell/or/Math. I am trying to break down some C++ code that implements Viterbi stuff into the actual Math to rewrite in Haskell. However the C++ code is full of state which makes the maths hard to follow
17:31:19 <arkeet> @where sneaky
17:31:19 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
17:31:53 <hpc> wait, does that work?
17:31:59 <pragrammer> hpc: my program? yes
17:32:10 <hpc> that is one hell of an application for CPP
17:32:27 <pragrammer> i couldnt think of any other way to do it so conveniently
17:32:35 <funfunctor> pragrammer: maybe you want to use parsec
17:32:54 <pragrammer> that sounds very advance
17:32:58 <pragrammer> im a beginner still!
17:33:12 <pragrammer> would love criticism on my haskell skill it currently is
17:33:27 <funfunctor> pragrammer: we all are but it looks more complicated the way you did it then using parsec
17:33:38 <pragrammer> oh
17:33:44 <pragrammer> ok maybe.
17:34:10 <funfunctor> pragrammer: I mean, take a look at the API and decide for yourself
17:34:26 <hpc> maybe comment the code to give a general idea of what manipulations you are making on the string and how to follow it from start to finish
17:34:27 <arkeet> :t intersperse
17:34:28 <lambdabot> a -> [a] -> [a]
17:34:34 <arkeet> :t intercalate
17:34:34 <lambdabot> [a] -> [[a]] -> [a]
17:34:37 <funfunctor> pragrammer: if its binary data and you need speed, see attoparsec also
17:34:50 <hpc> and yeah, parsec can be anything from very simple to very complicated and powerful
17:35:04 <arkeet> > intercalate "\t" ["asdf","ghjk"]
17:35:05 <lambdabot>  "asdf\tghjk"
17:35:14 <hpc> http://hackage.haskell.org/package/ghc-man-completion -- here's something fairly simple and super-hacky that i wrote
17:35:17 <funfunctor> I always forget what the hell I am doing with parsec
17:35:21 <hpc> it parses the ghc manfile and outputs a bash completion file
17:35:46 <hpc> might be good to learn from
17:35:53 <hpc> also TIL people are actually downloading it!
17:36:06 <ProofTechnique> funfunctor: More types! :D
17:36:08 <pragrammer> arkeet: that saved me from the map foldl ++, thanks :)
17:36:29 <arkeet> concat is preferable over foldl1 (++) anyway
17:36:42 <hpc> hopefully more will in the future, with newer versions of ghc being better about the manpage being thorough
17:36:42 <funfunctor> ProofTechnique: ?
17:36:46 <arkeet> (and a right fold is preferable over a left fold)
17:37:17 <arkeet> (since foldl (++) will repeatedly append to the end of the list, which is slow)
17:37:20 <pragrammer> ah
17:37:27 <hpc> anyway, i like the style of writing a simple "parser" as a few string transformations plus a data table
17:37:32 <pragrammer> does it show that im a clojure programmer? lol
17:37:38 <pragrammer> my style is very clojure-ish
17:37:46 <arkeet> I don't know clojure.
17:37:46 <hpc> as long as it's clear how start gets to finish
17:37:59 <ProofTechnique> funfunctor: Whenever I get lost in Parsec, I'm usually not being granular enough with my types. With more types, my components usually get smaller and more composable.
17:38:02 <arkeet> you could avoid using CPP by searching for start/end markers.
17:38:03 <funfunctor> So this is the C++ code I am trying to work out the math behind http://lpaste.net/126958 what is the intent here? Syndrome decoding or what?
17:38:04 <ProofTechnique> But I'm also terrible, so v0v
17:38:10 <hpc> the use of (&) might give it away if i knew more of the idioms
17:38:31 <hpc> it reads as very start-to-finish, typical of string processing in many languages
17:38:33 <pragrammer> arkeet: thats less flexible to change
17:38:35 <funfunctor> ProofTechnique: oh right, I was wondering what you were refering to
17:38:48 <arkeet> well, just saying.
17:38:49 <pragrammer> oooh i see
17:38:55 <enthropy> hpc: I think every package gets some downloads from people that mirror hackage (but for sure ghc-man-completion is has more than that number)
17:38:59 <pragrammer> i can do dropUntil "BEGIN" and then takeUntil "END"
17:39:01 <pragrammer> nice
17:39:04 <arkeet> yeah.
17:39:08 <hpc> ah, maybe
17:39:32 <hpc> it really is so amazing to have a bash completion file for ghc though
17:39:43 <hpc> -X<tab><tab> and a list of extensions
17:40:11 <nickerSLAVEgg> i can't believe actual people are still lurking on irc
17:40:16 * enthropy does that withing ghci :set -X<tab>
17:40:20 <nickerSLAVEgg> they must be old
17:40:44 <hpc> heh, that too
17:41:53 <hpc> it also gets stuff like -fasm, and --main-is
17:42:08 <ProofTechnique> hpc: fish does it for me :D
17:42:25 <hpc> fish is cool
17:42:54 <ProofTechnique> I'm a fan :)
17:43:30 <pragrammer> fixed http://lpaste.net/693660870688899072
17:44:17 <hpc> oh, now i see what it's doing
17:46:20 <funfunctor> pragrammer: maybe your looking for http://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Char.html ?
17:47:32 <arkeet> I would personally factor the parsing and output.
17:47:42 <arkeet> and also take everything out of main, heh.
17:47:59 <arkeet> so maybe end up with something like
17:48:05 <arkeet> parse :: String -> [(String,String)]
17:48:08 <arkeet> or [(Int,String)] I dunno.
17:48:15 <arkeet> and then 
17:48:19 <arkeet> format :: [(String,String)] -> String
17:48:23 <pragrammer> funfunctor: why do you sy that
17:48:29 <pragrammer> arkeet: ah nice
17:48:44 <arkeet> so then main = putStr =<< fmap (format . parse) readFile "con.hs" or whatever.
17:48:51 <arkeet> oops missing parentheses.
17:49:36 <funfunctor> pragrammer: ord :: Char -> Int and chr :: Int -> Char
17:50:30 <pragrammer> funfunctor: oh yeah that'd be cool too
17:50:35 <pragrammer> easier too
17:51:02 <arkeet> depends on what you want to do.
17:51:16 <Maxdamantus> @src ord
17:51:16 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
17:51:22 <arkeet> I don't see where to fit chr/ord into parsing/formatting this table.
17:51:25 <funfunctor> pragrammer: I don't suppose you know C++ well?
17:51:41 <funfunctor> Math and OOP really don't go well together at all
17:51:43 <indiagreen> Maxdamantus: ord = fromEnum
17:51:48 <Maxdamantus> I know.
17:51:58 <arkeet> I would hope fromEnum = ord instead.
17:52:27 <Maxdamantus> What difference would it make?
17:52:34 <funfunctor> arkeet: why? its the Enum typeclass
17:53:01 <ReinH> arkeet: is that also: putStr . format . parse =<< readFile "con.hs"
17:53:05 <indiagreen> arkeet: okay, you're probably right, since we also have “ord (C# c#) = I# (ord# c#)”
17:53:08 <indiagreen> sorry
17:53:12 <arkeet> ReinH: of course, yes.
17:53:18 <Maxdamantus> ord (C# c#) = I# (ord# c#)
17:54:00 <pragrammer> What's a fantastic way of going from [1,2,3] to [[1,1], [2,2], [3,3]] ? maybe map $ replicate 2 ?
17:54:16 <arkeet> map (replicate 2) sounds good to me.
17:54:17 <ReinH> map (replicate 2)
17:54:17 <shachaf> map (replicate 2) is pretty fantastic.
17:54:31 <ReinH> I think there is some consensus here.
17:54:35 <funfunctor> arkeet: the Char kind is made a instance of the Enum typeclass so that fromEnum can extract the ASCII value
17:55:16 <Maxdamantus> > ord '∀'
17:55:17 <lambdabot>  8704
17:55:32 <pragrammer> Is (map $ replicate 2 $ map snd to Data.Char.chr somehow) the best way to go from [65,66,67] to [(65,'A'),(66,'B'),(67,'C')] ?
17:55:42 <arkeet> > [1,2,3] <* replicate 2 ()
17:55:43 <lambdabot>  [1,1,2,2,3,3]
17:55:45 <arkeet> oh.
17:55:47 <pragrammer> Or should I just forgoe replicate 2?
17:55:47 <arkeet> yeah ok.
17:55:51 <funfunctor> > chr 8704
17:55:52 <lambdabot>  '\8704'
17:55:55 <shachaf> No, it has too many dollar signs.
17:56:01 <pacak> pragrammer: const [[1,1], [2,2], [3,3]] -- fantastic way to go from anything to [[1,1], [2,2], [3,3]]!
17:56:11 <pragrammer> pacak: fair
17:56:13 <funfunctor> Maxdamantus: I think that is unicode, hence wont work
17:56:14 <shachaf> And [x,x] is a very different thing from (x,x)
17:56:26 <shachaf> Try: map (\x -> (x,chr x))
17:56:44 <arkeet> I was about to write that out too.
17:56:56 <Maxdamantus> funfunctor: it does work.
17:56:59 <arkeet> or map (id &&& chr) if you like that sort of thing.
17:57:08 <arkeet> but the lambda version is clearer I think.
17:57:13 <funfunctor> > isAscii '∀'
17:57:14 <lambdabot>  False
17:57:21 <shachaf> Or [(x,chr x) | x <- xs]. Many options, but none of them involve replicate.
17:57:27 <pavonia> :t (&&&)
17:57:28 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
17:57:55 <arkeet> :t (&&&) `asAppliedTo` (undefined :: b -> c)
17:57:56 <lambdabot> (b -> c) -> (b -> c') -> b -> (c, c')
17:58:04 <funfunctor> Oh I didn't know Char was that many bits wide
17:58:15 <arkeet> Char holds any Unicode character.
17:58:21 <arkeet> from 0 to 0x10ffff
17:58:22 <funfunctor> > (chr . ord) '∀'
17:58:23 <lambdabot>  '\8704'
17:58:23 <Axman6> > map (id &&& chr) [66,67,68]
17:58:25 <lambdabot>  [(66,'B'),(67,'C'),(68,'D')]
17:58:44 <shachaf> Some values of type Char aren't even Unicode code points.
17:59:35 <funfunctor> Axman6: hehe neat what about [1..255] :)
17:59:49 <Axman6> > map (id &&& chr) [1..255]
17:59:51 <lambdabot>  [(1,'\SOH'),(2,'\STX'),(3,'\ETX'),(4,'\EOT'),(5,'\ENQ'),(6,'\ACK'),(7,'\a'),...
18:00:01 <Axman6> why would that be a problem?
18:00:17 <funfunctor> Axman6: its not, I am just saying its cool/neat :)
18:00:37 <ProofTechnique> > (chr . ord) '💩
18:00:38 <lambdabot>  <hint>:1:14: parse error on input ‘💩’
18:00:40 <funfunctor> Didn't know lambdabot was going to truncate though
18:00:45 <ProofTechnique> > (chr . ord) '💩'
18:00:46 <lambdabot>  '\128169'
18:00:48 <ProofTechnique> There we go
18:00:50 <arkeet> > map (id &&& chr) [8704..]
18:00:51 <lambdabot>  [(8704,'\8704'),(8705,'\8705'),(8706,'\8706'),(8707,'\8707'),(8708,'\8708'),...
18:00:53 <arkeet> oh.
18:01:08 <jophish> ReinH: I think I'll go with multiple modules, and also have a NearlyEverything module, which exports all the non-offending enumerations. Everything commented nicely too to make sure people know
18:01:10 <arkeet> > map (id &&& (:[]) . chr) [8704..]
18:01:12 <lambdabot>  [(8704,"\8704"),(8705,"\8705"),(8706,"\8706"),(8707,"\8707"),(8708,"\8708"),...
18:01:14 <arkeet> duh.
18:01:17 <funfunctor> lambdabot: is gonna get hot.. <g>
18:01:20 <Axman6> > map (id &&& (text . return . chr)) [1..255]
18:01:21 <lambdabot>  [(1,),(2,),(3,),(4,),(5,),(6,),(7,),(8,),(9,    ),(10,
18:01:22 <lambdabot>  ),(11,),(12,),(13,),(14,),(15,),(16,),(17,),(18,),(19,),(20,),(21,),(22,)...
18:01:26 <Axman6> >_>
18:01:31 <arkeet> > map (id &&& text . pure . chr) [8704..]
18:01:32 <lambdabot>  [(8704,∀),(8705,∁),(8706,∂),(8707,∃),(8708,∄),(8709,∅),(8710,∆),(8711,∇),(87...
18:01:43 <arkeet> you read my mind.
18:01:49 <Axman6> heh
18:02:08 <Axman6> probably not the best idea to start the beginning of the sequence though
18:02:24 <funfunctor> pragrammer: ^ hope all that is enlightening ;)
18:02:31 <pragrammer> kind of? lol
18:02:32 <ProofTechnique> > map (text . pure . char) [128150..]
18:02:33 <lambdabot>  Couldn't match type ‘Text.PrettyPrint.HughesPJ.Doc’
18:02:33 <lambdabot>                with ‘GHC.Types.Char’
18:02:33 <lambdabot>  Expected type: GHC.Types.Char -> GHC.Types.Char
18:02:44 <pragrammer> i keep thinking maybe zip will make this cleaner
18:02:58 <ProofTechnique> > map (id &&& (text . pure . char)) [128150..]
18:02:59 <lambdabot>  Couldn't match type ‘Text.PrettyPrint.HughesPJ.Doc’
18:02:59 <lambdabot>                with ‘GHC.Types.Char’
18:02:59 <lambdabot>  Expected type: GHC.Types.Char -> GHC.Types.Char
18:03:02 <ProofTechnique> Aww
18:03:19 <ProofTechnique> > map (id &&& (text . pure . chr)) [128150..]
18:03:21 <lambdabot>  [(128150,💖),(128151,💗),(128152,💘),(128153,💙),(128154,💚),(128155,💛),(128156,💜...
18:03:23 <ProofTechnique> Oh, duh. I can't spell
18:03:37 <ProofTechnique> That is the most loving code in all of Haskell
18:04:43 <pragrammer> im trying to do the most magnificent way of printing %d \t %s \n for every printable char %s and its ascii code %d
18:04:52 <funfunctor> Does syndrome have a particular but general mathematical meaning I should be aware of
18:04:52 <pragrammer> so far i have some ugly stuff
18:04:56 <jophish> or better yet, exporting the offenders as patternsynonyms
18:05:28 <funfunctor> ProofTechnique: brings love to the channel this fine afternoon
18:05:34 <arkeet> > map (ord &&& id) . filter isPrint $ [minBound..maxBound]
18:05:35 <lambdabot>  [(32,' '),(33,'!'),(34,'"'),(35,'#'),(36,'$'),(37,'%'),(38,'&'),(39,'\''),(4...
18:06:50 <jophish> funfunctor: I can't find it in the dictionary http://www.amathsdictionaryforkids.com/dictionary.html
18:07:24 <funfunctor> alright.. time to fornicate with lambdabot in private..
18:07:40 <jophish> although neither is Category...
18:07:59 <funfunctor> jophish: the url does say "for kids"
18:08:26 <jophish> When I have kids you can be damn sure they'll know what a category is
18:09:36 <Maxdamantus> am at hs dic..
18:11:27 <funfunctor> jophish: well same. But 'most people' struggle with factorising 21 after 50 years on this planet they can't get it into their think heads
18:12:16 <funfunctor> I only know what a error syndrome is.. which is the bit in error
18:20:25 <ProofTechnique> funfunctor: http://math.ucdenver.edu/~wcherowi/courses/m7823/decoding.pdf
18:20:42 <ProofTechnique> That has a definition in it.
18:20:51 <ProofTechnique> I don't think it's a general term.
18:21:12 <funfunctor> ProofTechnique: thx but I know all this math already
18:21:28 <funfunctor> the issue is working out what this C++ code is trying to express??
18:21:28 <ProofTechnique> Well, there appears to be no more to it. How sad.
18:22:01 <funfunctor> they say syndrome http://lpaste.net/126958 but do they mean the same thing or?
18:22:29 <funfunctor> I can't untangle the maths from all the OOP stateness rubbish..
18:22:58 <arkeet> it's referring to the syndrome polynomial.
18:22:59 <arkeet> or something.
18:24:07 <arkeet> it shouldn't be that hard to disentangle the state.
18:24:15 <arkeet> the only member that's mutated is mMask.
18:25:41 <funfunctor> arkeet: isn't mState also mutated
18:25:51 <arkeet> I meant mState, not mMask.
18:26:01 <arkeet> sorry.
18:26:21 <funfunctor> arkeet: but what is the overall picture here?
18:26:42 <arkeet> mState is the state of the shift register.
18:27:00 <arkeet> have you read about LFSRs?
18:27:06 <funfunctor> what is a syndrome polynomial in regards to a shift register?
18:27:14 <funfunctor> arkeet: well I know what a LFSR is
18:27:26 <funfunctor> I know what a syndrome is interms of Hamming codes
18:28:17 <arkeet> I guess maybe it's not that then.
18:28:36 <arkeet> or maybe it is.
18:29:18 <funfunctor> just trying to fit it all together?
18:29:51 <leviathaan> is haskell a dog?
18:30:49 <Cale> leviathaan: It's a functional programming language
18:31:01 <leviathaan> roof
18:31:23 <funfunctor> its a work horse
18:31:42 <funfunctor> arkeet: its probably means a Galois LFSR
18:31:49 <leviathaan> Cale u must be fun at parties
18:32:28 <Cale> leviathaan: This chat is a more serious one. If you want to have silly discussions with Haskell people, you should go to #haskell-blah
18:34:48 <leviathaan> wow thanks
18:35:36 <leviathaan> is there a channel for black people as well?
18:41:21 <dibblego> leviathaan: #haskell-blah is just where we take those discussions. There is no problem having discussions like that, but we try to keep it out of #haskell, so that others can stay focussed on their goals, relating to haskell specifically.
18:42:12 * hackagebot test-sandbox-compose 0.1.2 - Lightweight development enviroments using test-sandbox  http://hackage.haskell.org/package/test-sandbox-compose-0.1.2 (junjihashimoto)
19:09:23 <gamegoblin> If I have four word8s in a list, how can I conver them into a 32 bit float?
19:13:40 <EvanR> gamegoblin: first pack them into a Word32 (carefully) and use realToFrac
19:13:55 <dhinojosa> So which is the actually lazy one: newtype or data?
19:14:47 <enthropy> gamegoblin, EvanR that second step might be unsafeCoerce, depending on what's actually supposed to happen
19:14:59 <arkeet> dhinojosa: https://wiki.haskell.org/Newtype
19:15:04 <EvanR> dont do unsafeCoerce
19:15:10 <EvanR> that wont even work
19:15:29 <enthropy> well how else do you do "interpret these 32 bits as a float"?
19:15:44 <EvanR> i now realize my way is wrong
19:15:47 <arkeet> (it won't work on x86 because floats live in different registers)
19:16:09 <EvanR> theres a utility function that somehow does this, i just used it
19:16:38 <arkeet> https://hackage.haskell.org/package/data-binary-ieee754-0.4.4/docs/Data-Binary-IEEE754.html
19:16:39 <enthropy> Binary doesn't necessarily write out 32 bits for a Float or Int32
19:16:42 <arkeet> look at wordToFloat
19:16:45 <crobbins> dhinojosa: basically, newtype is a way of wrapping an existing type, which the compiler will use for type checking but unwrap when compiling
19:17:10 <arkeet> which internally does it by using Storable stuff.
19:17:15 <arkeet> write a word to a pointer and read a float from it.
19:17:58 <EvanR> ive always avoided encoding floats as binary
19:18:09 <dhinojosa> crobbins: Got that part, I am just trying out this supposed lazyness trick with undefined
19:18:26 <EvanR> base16 text works
19:18:44 <Ralith> lol
19:18:51 <dhinojosa> crobbins: Seems I am getting conflicting info and whether or not I make the call in a method or not
19:19:06 <dhinojosa> Can I import in this haskell bot?
19:19:39 <crobbins> dhinojosa: not sure if you can import, but you should be able to use qualified syntax i believe
19:19:39 <dhinojosa> > newtype Butt Int
19:19:40 <lambdabot>  <hint>:1:1: parse error on input ‘newtype’
19:19:48 <dhinojosa> haha
19:19:53 <EvanR> its "bottom" in haskell
19:19:53 <crobbins> @newtype Butt Int
19:19:54 <lambdabot> Unknown command, try @list
19:20:24 <dhinojosa> haha
19:20:25 <crobbins> dhinojosa: you can probably pm lambdabot to see the commands
19:20:42 <dhinojosa> haha
19:20:52 <dhinojosa> @list
19:20:58 <dhinojosa> > @list
19:21:01 <dhinojosa> ugh
19:21:04 <arkeet> do it in pm
19:21:30 <dhinojosa> arkeet: It's 9PM here
19:21:39 * Clint claps.
19:21:42 <arkeet> :(
19:21:56 <EvanR> do YOU know where your newtypes are?
19:22:14 <dhinojosa> ok ok
19:22:29 <dhinojosa> haha
19:22:32 <dhinojosa> still laughing 
19:22:34 <dhinojosa> but seriously
19:22:57 <dhinojosa> > newtype Butt = Butt Int
19:23:08 <arkeet> lambdabot is not ghci.
19:23:18 <EvanR> Butt seriously
19:23:35 <dhinojosa> EvanR is teh awesome
19:23:53 <shachaf> dhinojosa: Please stop.
19:24:46 <dhinojosa> I did: newtype Butt = Butt Int
19:25:01 <dhinojosa> and ghci said  No instance for (Show Butt) arising from a use of `print'
19:25:14 <arkeet> you need to derive Show.
19:25:15 <dhinojosa> I assume I can use deriving
19:25:18 <EvanR> newtypes dont automatically have the instances
19:25:27 <EvanR> which is kind of the point
19:25:55 <dhinojosa> So when I do....Butt undefined
19:25:59 <dhinojosa> it errors
19:26:09 <arkeet> yes, newtype constructors are strict.
19:26:13 <dhinojosa> ok
19:26:36 <enthropy> arkeet: thanks for pointing out data-binary-ieee754 it gets rid of an inappropriate (but working) unsafeCoerce I've been using (in Rlang-QQ)
19:27:07 <dhinojosa> So LYAHFGG says...This fact means that not only is newtype faster, it's also lazier.
19:27:17 <arkeet> I wonder if it's worth writing some sort of coercion for Storables.
19:27:32 <arkeet> or maybe that already exists.
19:27:41 <enthropy> so I think that "Int64 and Double are stored in different registers" doesn't seem to matter
19:27:45 <dhinojosa> So would I venture to say that LYAHFGG is wrong when it comes to newtype, considering it is strict?
19:28:07 <EvanR> enthropy: they can be, or they could be in memory
19:28:07 <arkeet> dhinojosa: what part of it is wrong?
19:28:20 <EvanR> so it could work
19:28:41 <EvanR> it might mess up in the unboxed case
19:28:41 <dhinojosa> You just said yes, newtype constructors are strict.
19:28:53 <dhinojosa> but the book says they are lazier
19:29:00 <crobbins> dhinojosa: maybe you should give an example of what you are trying to do
19:29:02 <arkeet> what exactly does it say?
19:29:06 <arkeet> link
19:29:10 <dhinojosa> I just did
19:29:29 <crobbins> arkeet: dhinojosa said: So LYAHFGG says...This fact means that not only is newtype faster, it's also lazier.
19:29:33 <enthropy> > case undefined of All _ -> () -- means All is "lazy" in some sense
19:29:53 <dhinojosa> arkeet crobbins http://learnyouahaskell.com/functors-applicative-functors-and-monoids#the-newtype-keyword
19:30:02 <arkeet> strict and lazy aren't exactly antonyms.
19:30:17 <arkeet> strict just means bottom in -> bottom out
19:30:28 <hacker> newtypes are exactly the same as the type they are wrapped, and case undefined of _ -> () is known to be the same as just const () 
19:30:44 <hacker> because case (in this case) isn't forcing evaluation
19:30:45 <EvanR> newtype is lazier?
19:31:03 <hacker> s/wrapped/wrapping, too :P
19:31:13 <arkeet> pattern matching on newtype constructors is lazier.
19:32:15 * hackagebot vaultaire-common 2.9.1 - Common types and instances for Vaultaire  http://hackage.haskell.org/package/vaultaire-common-2.9.1 (fractalcat)
19:37:15 <ski> EvanR : `newtype' constructors are strict
19:37:17 <dpwright> I am building an FFI-heavy library on Windows (LibClang)
19:37:56 <dpwright> I have had to make a few changes to make it Windows-friendly, but I am running into an issue post-configure now
19:38:15 <EvanR> ski: right
19:38:30 <dpwright> frustratingly, I did actually succeed in doing this about a month ago, but now it seems not to be working... this is a newer version of LibClang though
19:39:14 <dpwright> Anyway the latest problem is that something -- I think cabal or something on the haskell side -- is using gcc to try and compile a C file that has been generated in the temporary directory
19:40:02 <dpwright> I would like to inspect this C file so that I can try compiling it myself, independent of the build system, but because it's temporary the C file disappears immediately when the build fails
19:40:23 <dpwright> is there any way I can tell cabal / ghc / gcc / the build not to clear up these temporary files so that I can look at them?
19:40:58 <dpwright> or perhaps tell windows to allow creation of files in that directory, but not deletion?  I am no windows expert
19:41:59 <bobfang> hi
19:42:01 <dhinojosa> hmm
19:42:02 <bobfang> a quick question
19:42:11 <dhinojosa> arkeet: So just pattern matching is lazier
19:42:15 <bobfang> can do notation be passed around as function arguments?
19:42:26 <EvanR> yes
19:42:42 <bobfang> is there any example
19:42:43 <bobfang> ?
19:42:45 <bobfang> thanks :)
19:42:53 <EvanR> forM_ [0 .. n-1] $ \i -> do
19:42:57 <EvanR>   ...
19:43:41 <sclv> dpwright: which files in particular do you mean?
19:43:54 <EvanR> well thats an example of a lambda
19:44:02 <EvanR> when foo $ do
19:44:03 <EvanR>   ...
19:44:19 <dpwright> sclv "C:\\Users\\build\\AppData\\Local\\Temp\\4184.c" on the last run
19:44:31 <dpwright> that number changes each run
19:44:39 <sclv> weird
19:46:16 <sclv> oh wait i bet its hsc2hs doing it
19:46:28 <dpwright> ah -- yeah, that sounds plausible
19:46:43 <dhinojosa> So safe to say that data type construction is lazy, but pattern matching is strict, whereas newtype type construction is strict, but pattern matching is lazy?
19:47:11 <dpwright> oh wait
19:47:29 <dpwright> actually, I think that file was a red herring
19:47:36 <dpwright> looks like it's just a path problem with make
19:52:16 * hackagebot ceilometer-common 0.2.2 - Common Haskell types and encoding for ceilometer  http://hackage.haskell.org/package/ceilometer-common-0.2.2 (fractalcat)
19:53:40 <Denommus`> does anyone know how Haskell and OCaml compare in terms of web dev ecosystem?
19:57:02 <Stefanja> Hello :-)
19:57:32 <Denommus`> hi
20:04:14 <AfC> I'm trying to build a local copy of the haddocks to put behind a webserver. I've passed haddock-options: --source-base=http://haskell/ via the cabal.config file, but it's still generating file:/// URLs for stuff in base.
20:04:23 <AfC> Anyone have a suggestion how to nudge that?
20:12:52 <sgwizdak> Denommus`: ocaml -- not much, haskell -- there's yesod and a few other frameworks
20:14:28 <Denommus`> sgwizdak: well, OCaml has Eliom
20:14:48 <Denommus`> sgwizdak: but I'm more curious regarding satellite libraries, like database and authentication
20:17:15 <sgwizdak> Denommus`: compared to something like play, both are going to be light in terms of high quality libraries. Haven't messed too much with any of the ocaml stuff -- however there are some sites actively using it. 
20:17:17 * hackagebot mdcat 0.1.0.0 - Markdown viewer in your terminal  http://hackage.haskell.org/package/mdcat-0.1.0.0 (bobfang1992)
20:17:38 <sgwizdak> err, rather, there are sites actively using yesod
20:23:32 <nitrix> Ah
20:23:44 <nitrix> I was wondering how come everyone was talking about Haskell all of a sudden.
20:23:49 <Denommus`> uh
20:24:00 <nitrix> I switched channels xD
20:24:01 <Denommus`> I'm having problems linking yesod-bin
20:24:07 <nitrix> Denommus`: Oh hey :D
20:24:29 <Denommus`> /usr/bin/ld: /usr/lib/ghc-7.8.4/ghc-7.8.4/libHSghc-7.8.4.a(HsDecls.o): unrecognized relocation (0xd8) in section `.text'
20:24:32 <Denommus`> nitrix: hello
20:24:54 <nitrix> Denommus`: That's the most recent yesod?
20:25:21 <Denommus`> 1.4.5
20:25:46 <Denommus`> maybe it's because of happy and alex
20:27:51 <cfoch> hello
20:28:00 <Denommus`> it's not because of happy and alex
20:28:03 <nitrix> Denommus`: Trying to replicate, one sec.
20:28:08 <Denommus`> goddamnit, what's happening?
20:28:10 <cfoch> has somebody used this function "getNamesInScope"?
20:28:23 <nitrix> cfoch: That's a very poorly worded question.
20:28:26 <cfoch> do you have an exa,ple?
20:28:32 <cfoch> example
20:29:00 <cfoch> I would like to have a working example of that function
20:29:39 <nitrix> cfoch: I do. You want to explain what you're trying to do, what your problem is and what you tried.
20:30:35 <Cale> Denommus`: There's Yesod, Happstack, and Snap as far as fairly well-fleshed-out Haskell web frameworks go. There's also Scotty which is suitable for more lightweight applications. I have no idea how this compares to how things are in OCaml, I'm not really familiar with any of the web stuff there.
20:30:42 <cfoch> I am looking for a function that shows me all the available functions and data types
20:30:51 <cfoch> nitrix: is that function for that?
20:30:56 <cfoch> or maybe I am wrong
20:31:06 <Denommus`> Cale: I am aware of the frameworks, I'm more worried about the satellite libraries, like database and authentication
20:31:36 <Denommus`> cfoch: on an interactive session? Just press TAB
20:31:57 <hacker> Denommus`: I have to say database libraries in Haskell are really nice to work with!
20:32:07 <cfoch> I want a function... I want to get the names of functions as strings
20:32:09 <hacker> Denommus`: at least HaskellDB is
20:32:33 <cfoch> and to get the data type of each parameter
20:32:59 <cfoch> as string (or whatever i can convert to a string)
20:33:34 <Denommus`> cfoch: are you trying to do some runtime metaprogramming shenanigan?
20:33:34 <Denommus`> cfoch: if so, Haskell is not really suited for that
20:33:34 <Denommus`> cfoch: anyway, getNamesInScope returns a monadic action
20:33:52 <Denommus`> cfoch: so you must use it with a bind or using the "do" syntax. Are you aware how to use monads?
20:35:56 <cfoch> yes, what's metaprogramming shenanigan'
20:35:58 <cfoch> ?
20:36:51 <Denommus`> cfoch: it's a slang for doing something really weird
20:37:03 <Denommus`> nitrix: anything?
20:37:03 <cfoch> so... how does Haddock converts the name of each function to a string
20:37:11 <cfoch> ?
20:37:12 <nitrix> Denommus`: Still building for me.
20:37:38 <nitrix> cfoch: You want to import GHC and compile with  $ ghc -package ghc-7.8.4 test.hs
20:37:41 <cfoch> Haddock not only put the names of functions to strings, also its types, and set links
20:37:42 <Denommus`> cfoch: I have no idea how Haddock works, sorry
20:37:46 <nitrix> cfoch: It's a hidden package.
20:41:17 <nitrix> Denommus`: No issues for me.
20:41:24 <nitrix> Denommus`: On a sandbox fresh install.
20:41:31 <nitrix> Denommus`: Same versions.
20:41:37 <cfoch> nitrix: hidden  package? 
20:41:58 <Rotaerk> hmm do you guys create functions locally in your projects that are essentially extensions to a module, without actually modifying that module?
20:42:06 <Cale> cfoch: Are you looking to process Haskell source code?
20:42:12 <Denommus`> nitrix: let me see
20:42:20 <Cale> cfoch: You might be looking for the haskell-src-exts package
20:42:26 <Rotaerk> I've started having a "Local" namespace containing things like "Local.Data.ByteString"
20:42:45 <HeladoDeBrownie> Rotaerk, what sort of things do you find missing?
20:42:50 <nitrix> Rotaerk: If they are extensions, then by definition, they don't belong to the module :P
20:42:54 <Cale> cfoch: Which contains a parser for Haskell modules that will give you the module as a big datastructure that you can go digging through.
20:43:04 <cfoch> Cale: I think that's what I need to do. I want to make a graph of names of data  types and names of functions, to relate functions and parameters
20:43:15 <Rotaerk> nitrix, they *could* be in the module, but I don't know if they actually belong there or not
20:43:19 <Cale> Then yeah, you need to start with source code.
20:43:26 <nitrix> Rotaerk: There's always the possibility for the module to introduce new typeclasses, so that others can implement more instances.
20:43:31 <Cale> There's no way to get hold of such things once the code is compiled.
20:44:09 <nitrix> Rotaerk: e.g. You're probably familiar with the Show typeclass.
20:44:16 <Rotaerk> yep
20:45:39 <dpwright> any minghc for windows users in here?  I'm pretty sure the problem I was having with LibClang earlier is down to my running the build outside of msys, but if I try and launch the msys packaged with minghc I get "System cannot find file 'C:\Program'"
20:45:47 <cfoch> Cale: when you mentioned " you need to start with source code", source code of Haskell extensions?
20:45:53 <Rotaerk> HeladoDeBrownie, well, Local.Foreign.Ptr contains intToPtr = plusPtr nullPtr; simple example
20:46:03 <dpwright> the same symptoms as this report (which I have just commented on): https://github.com/fpco/minghc/issues/30
20:46:06 <Rotaerk> hmm...
20:46:29 <dpwright> anybody got any idea?
20:46:51 <cfoch> ah...
20:47:11 <Rotaerk> basically anything I wish existed in the module, but doesn't
20:47:36 <Cale> cfoch: I mean, the source code for whatever it is that you're trying to analyse. Names don't exist in the compiled machine code.
20:47:49 <Cale> cfoch: Neither do types.
20:48:25 <Rotaerk> loopIO :: IO Bool -> IO () is in my Local.Prelude
20:48:31 <cfoch> Cale: so for example if I have a package/libraryA, I could get some information about its modules (using the parser). But for example, if this code is using the data type [Char]. Can I "parse" this data type "[Char]" ?
20:48:35 <Rotaerk> well... probably should be elsewhere
20:49:41 <Cale> cfoch: The parser will parse all the types. It won't tell you how datatypes are defined unless they're declared in the modules that you parsed.
20:49:50 <Rotaerk> HeladoDeBrownie, oh, there's also a bracketEitherT in my Local.Control.Monad.Trans.Either
20:50:20 <Rotaerk> which is similar to bracket but it accounts for lefts rather than exceptions
21:04:00 <tnks> is there any notable reason to prefer EitherT to ExceptT or vice versa?
21:04:13 <tnks> I understand the problems with ErrorT, I think.
21:04:38 <HeladoDeBrownie> tnks, which EitherT are you talking about?
21:04:38 <tnks> I guess EitherT was implemented before ExceptT, which is only in a later version mtl.
21:05:28 <tnks> HeladoDeBrownie: in Gabriel's "error" packge.
21:06:36 <HeladoDeBrownie> tnks, it looks like errors it has a few more relevant operations packaged with it
21:06:39 <HeladoDeBrownie> s/it //
21:07:13 <shachaf> EitherT comes from the package "either"
21:07:35 <HeladoDeBrownie> shachaf, tnks already said the package they meant, which wasn't that one
21:07:50 <shachaf> The package they meant depends on the package "either".
21:08:05 <tnks> shachaf: yeah, I see that now, it's a reexport.
21:08:51 <HeladoDeBrownie> ah.
21:09:21 <HeladoDeBrownie> gah, i sent that message right after but my connection dropped -_-
21:10:01 <tnks> so no real reason to mess with ExceptT?
21:10:18 <tnks> unless some library forces it on you?
21:15:45 <Stefanja> What is the best way to get started in Haskell?
21:16:15 <alexclark> would someone be up for explaining a lyah example to me?
21:16:57 <alexclark> Stefanja: I've been reading learn you a haskell and its been great.  Theres been a couple things that stumped me so far (like now haha), but i think im getting it.
21:17:11 <alexclark> Stefanja: http://learnyouahaskell.com/
21:17:17 <HeladoDeBrownie> @where learnhaskell
21:17:17 <lambdabot> https://github.com/bitemyapp/learnhaskell
21:17:26 <HeladoDeBrownie> ^ that is a pretty good resource
21:17:43 <Azel> alexclark: Go ahead, someone might be able to answer.
21:17:53 <alexclark> I've also done a few exercises on exercism.io which i always push
21:18:00 <tnks> Stefanja: yeah, your mileage may vary with LYAH. . . some people find it lop-sided.
21:18:05 <shachaf> I liked Hutton's book, _Programming in Haskell_.
21:18:16 <alexclark> OK, the part with the monad implementation on Writer
21:18:26 <alexclark> especially with tell
21:19:18 <alexclark> so first we have this https://gist.github.com/alexclarkofficial/ea583e12dbd562c0e77e
21:19:38 <alexclark> which returns (15,["Got number: 3","Got number: 5"])
21:19:55 <Stefanja> Thanks alexclark
21:20:55 <alexclark> my understanding is a and b are both equal to tuples with just there strings in the list, i.e. b = (5, ["Got number: 5"])
21:21:12 <shachaf> a and b are Ints.
21:21:22 <tnks> also, I missed the link in bitemyapp's guide. . . it might be there.
21:21:26 <shachaf> That's why you can multiply them.
21:21:29 <tnks> but I like this writeup:  http://www.stephendiehl.com/what/#cont
21:21:36 <tnks> drop the anchor
21:21:59 <tnks> it's /not/ a great way to learn Haskell.
21:22:01 <alexclark> shachaf: so the parts thats confusing me, is where is the logger on this?
21:22:12 <tnks> but it's a nice hit list of concepts.
21:22:41 <shachaf> I don't know. What sort of answer are you expecting?
21:23:16 <shachaf> Maybe start by simplifying: do { x <- logNumber 4; return (x*x) } -- same confusion?
21:24:02 <alexclark> shachaf: yeah
21:24:25 <alexclark> shachaf: the confusion i think is because isnt logNumber returning a Writer?
21:24:55 <arkeet> logNumber 4 = Writer (4, ["Got number: 4"])
21:24:55 <shachaf> Yes. If you wrote "let x = logNumber 4 in ...", then x's type would be Writer [String] Int
21:24:59 <arkeet> but when you write x <- logNumber 4
21:25:10 <arkeet> that is something else
21:25:15 <alexclark> arkeet: it kind of unwraps it
21:25:28 <alexclark> i get that
21:25:47 <shachaf> "unwraps" it is a pretty unhelpful thing to say for most monads.
21:26:00 <alexclark> shachaf: haha fair enough
21:26:29 <shachaf> Writer is a special exception where it does make sense (so I think Writer isn't great for building intuition about monads in general, but oh well).
21:26:57 <shachaf> Maybe it would be simpler to desugar it a bit: logNumber 4 >>= (\x -> return (x*x))
21:27:22 <alexclark> im being tripped up by the idea that you have a :: Int and b :: Int and you can multiply them, put the result in a minimum context and that minimum context has this other data about them
21:27:48 <arkeet> in what sense does one "have" a and b?
21:28:23 <alexclark> arkeet: i dont even know anymore
21:28:40 <shachaf> How do you feel about this example?
21:28:52 <shachaf> > do { x <- [1,2,3]; return (x*x) }
21:28:53 <lambdabot>  [1,4,9]
21:29:16 <shachaf> Hmm, maybe that's not particularly helpful if you were just worrying about Writer.
21:29:32 <alexclark> shachaf: i think im getting somewhere
21:29:56 <alexclark> i reread Writers definition of >>=
21:31:07 <alexclark> so i see that it kind of defers its monadic behavior until the function is called
21:31:43 <alexclark> ok, so now here's the real kicker
21:31:48 <shachaf> I don't know what it means to defer monadic behavior.
21:32:32 <alexclark> it kind of takes note of what a and b is and worries about concating the list when it performs a*b
21:33:07 <shachaf> I think it's much less magical than you think.
21:33:50 <alexclark> shachaf: probably, hard to explain something that im still processing
21:34:06 <alexclark> ok so when I throw the tell in there https://gist.github.com/alexclarkofficial/ea583e12dbd562c0e77e
21:35:20 <alexclark> and the return is still (a*b), how does that get included in the final result?
21:35:45 <arkeet> because of how >> for Writer works.
21:36:40 <arkeet> like
21:36:41 <alexclark> arkeet: yeah, im kinda thinking it might make more sense if i see that definition
21:36:48 <arkeet> yes.
21:37:19 <shachaf> The definition is a >> b = a >>= (\_ -> b)
21:37:41 <arkeet> maybe it would help to ignore binding values for the moment, and just think about what >> does.
21:38:01 <arkeet> Writer (x,a) >> Writer (y,b) = Writer (y, a `mappend` b)
21:40:35 <alexclark> is >> implicit in do notation?
21:40:49 <bob_twinkles> other way around
21:41:02 <bob_twinkles> >> and >>= are what do notation uses "behind the scenese"
21:41:33 <arkeet> @undo do { x <- foo; bar; return (x*x) }
21:41:33 <lambdabot> foo >>= \ x -> bar >> return (x * x)
21:44:26 <dhinojosa> arkeet: you mentioned something about pm earlier, the one I had fun with. ha
21:45:17 <dhinojosa> arkeet: What is pm? other than post meridium
21:45:25 <arkeet> as in private message.
21:45:27 <arkeet> as in /msg lambdabot 
21:48:26 <alexclark> arkeet: holy shit i think ive got it
21:49:37 <alexclark> so a line that just have something of the monad type just gets >> into the chained functions?
21:50:32 <alexclark> which would normally not do anything unless its nothing(then it would be nothings all the way down), but since this is writer it appends itself
21:50:40 <arkeet> do { x; ... } = x >> ...
21:50:48 <arkeet> do { a <- x; ... } = x >>= (\a -> ...)
21:50:55 <arkeet> do { x } = x
21:51:07 <arkeet> oops, there should be some do on the right side.
21:51:18 <arkeet> do { a <- x; ... } = x >>= (\a -> do {...})
21:51:20 <arkeet> etc
21:51:36 <alexclark> got it
21:51:38 <alexclark> thanks!
21:52:11 <alexclark> any tips on getting better at reading lambdas?
21:52:24 <arkeet> I dunno.
21:52:27 <arkeet> \ is lambda.
21:52:55 <alexclark> yeah, they can just be kind of a mind hurdle
21:56:25 <alexclark> i think the biggest thing is to stop reading do notation as a block of imperative code
21:57:10 <erisco> annoying that specific package versions can be required
21:57:19 <arkeet> alexclark: that is a big thing yes
21:57:30 <erisco> with also the constraint that only one version can be installed? oO
21:58:01 <pacak> alexclark: main = do { print "totally" ; print "not" ; print "imperative" ; exit 1 }
22:07:20 * hackagebot hermit 0.7.0.0 - Haskell Equational Reasoning Model-to-Implementation Tunnel  http://hackage.haskell.org/package/hermit-0.7.0.0 (AndrewFarmer)
22:07:42 <erisco> I do not understand cabal sandboxes
22:07:51 <erisco> can they help me install two packages which have conflicting dependencies?
22:08:15 <arkeet> sometimes I edit a package's dependencies.
22:08:38 <MP2E> my recommendation is to make a clean, non conflicting base outside of the sandbox, and install the two conflicting packages in seperate cabal sandboxes
22:08:47 <erisco> that isn't the same as making the package work with the dependencies arkeet oO
22:09:35 <erisco> MP2E I do not really understand sandboxes though
22:09:54 <erisco> when ghc tries to find modules where does it look? do sandboxes have an effect on that?
22:10:22 <arkeet> sandboxes modify ghc's search path.
22:10:44 <MP2E> yeah, sandboxes encapsulate the whole environment in the folder you assign to the sandbox, so if you use ghc directly you can't see the libraries in your sandboxes unless you first cd into one of the sandboxes and then use 'cabal exec'
22:10:56 <MP2E> and then ghc will see the libraries in that sandbox
22:11:00 <MP2E> cabal will find everything as usual, though
22:11:06 <erisco> okay...
22:11:08 <MP2E> (provided you're in the sandbox :P)
22:11:13 <erisco> so how do I use two sandboxes at once?
22:11:20 <arkeet> you don't.
22:11:29 <erisco> well I need both packages but they conflict
22:11:34 <arkeet> which packages?
22:12:00 <erisco> I don't know how to tell exactly, I installed ghc-mod and now I am trying to install attoparsec
22:12:16 <arkeet> ok, and what goes wrong?
22:12:22 <erisco> this is what cabal tells me http://lpaste.net/126961
22:16:21 <arkeet> btw
22:16:30 <arkeet> having two versions of a package installed at the same time
22:16:33 <arkeet> is asking for trouble
22:16:41 <erisco> I don't
22:16:46 <arkeet> indeed
22:17:06 <erisco> I guess I can do the force-reinstall and pray
22:17:09 <arkeet> I wonder why it wants to reinstall scientific
22:17:18 <arkeet> perhaps, make sure to ghc-pkg check afterwards
22:17:18 <erisco> because hashtable ?
22:17:29 <erisco> how do I use it to check? and check what?
22:17:37 <arkeet> run "ghc-pkg check"
22:18:22 <arkeet> why does it want to update hashable.
22:18:26 <arkeet> it is a mystery.
22:30:39 <RustyShackleford> here's some code i'm working on: http://pastebin.com/yAFY7Wq2. I'm trying to write the prettyShow method at the bottom. I'm also interested in any comments about the code i've written, and maybe a better name for this function. I'm a haskell noob
22:30:56 <erisco> arkeet ghc-pkg says scientific is not installed, but cabal says it is oO
22:31:05 <RustyShackleford> what i'm trying to do is print the chessboard sorta like this: http://pastebin.com/vMb3K7Y5
22:33:58 <RustyShackleford> anyway, I have no idea how to construct a string with 64 parameters in it
22:34:21 <shourya> Hello.
22:42:14 <erikd> RustyShackleford: can you give an short example?
22:42:51 <arkeet> maybe you want an array.
22:44:20 <erisco> okay, I hate cabal
22:44:46 <erisco> you can have two package versions installed but it will insist it has to "upgrade" a package version
22:45:30 <arkeet> like I said.
22:45:35 <RustyShackleford> erikd: lets say we have a list like ["1", "2", "3", ...]
22:45:35 <arkeet> you're just asking for trouble if you do.
22:45:42 <erisco> I didn't even mean to
22:45:45 <erisco> cabal just did it
22:45:58 <RustyShackleford> and we want to create a string with the elements of that list
22:46:02 <erisco> now after trying to repair damage I have made it worse
22:46:12 <erisco> and I can't seem to install much without "breaking" a dozen packages
22:46:13 <RustyShackleford> "first: 1, second: 2, third: 3"
22:46:56 <arkeet> erisco: welcome to cabal hell :-)
22:47:02 <erisco> noooooooooooo
22:47:31 <erisco> I thought I was doing okay stuff because now ghc-pkg check doesn't complain
22:47:38 <erisco> but cabal is super unhappy
22:48:03 <arkeet> https://wiki.haskell.org/Cabal/Survival
22:48:40 <arkeet> hm, where is the thing I'm looking for
22:50:40 <erikd> RustyShackleford: you need to generate a list of ["first", "second", "third"] and then the zip or zipWith function along with Data.List.intercalate should get you the rest of the way.
22:52:06 <erisco> arkeet thanks I will see if I can muddle through this
22:52:23 <RustyShackleford> erikd: maybe it's better to describe exactly what I want. look at this: http://pastebin.com/vMb3K7Y5
22:52:27 <erisco> I certainly do not understand what the problem is
22:52:46 <erisco> with regards to multiple versions
22:53:33 <RustyShackleford> erikd: i have a representation of a chessboard, and a function that returns " r " for a black rook, " B " for a white knight
22:53:50 <arkeet> erisco: say you have two versions of some package A installed.
22:53:52 <arkeet> say, A-1 and A-2
22:53:56 <arkeet> no wait.
22:53:59 <arkeet> start with just A-1.
22:54:47 <arkeet> and you install some B that depends on A.
22:54:54 <arkeet> so it links to A-1.
22:55:05 <arkeet> now you install some other package C, that needs version A-2.
22:55:12 <arkeet> now you have two versions of A installed.
22:55:14 <erikd> > intercalate "+" $ replicate 8 "----"
22:55:15 <lambdabot>  "----+----+----+----+----+----+----+----"
22:55:20 <arkeet> now what if you want to install somethign that depends on both B and C.
22:55:26 <arkeet> well you're screwed.
22:55:35 <arkeet> or something.
22:55:41 <erikd> > '+' : intercalate "+" (replicate 8 "----")) ++ "+"
22:55:42 <lambdabot>  <hint>:1:43: parse error on input ‘)’
22:55:51 <erikd> > '+' : intercalate "+" (replicate 8 "----") ++ "+"
22:55:52 <lambdabot>  "+----+----+----+----+----+----+----+----+"
22:56:02 <erisco> arkeet why am I screwed?
22:56:09 <arkeet> I dunno.
22:56:12 <erikd> RustyShackleford: does that help?
22:56:13 <arkeet> just don't get into that situation
22:56:16 <erisco> okay lol
22:56:30 <erisco> well I need ghc-mod for my editor to work
22:56:37 <erisco> and I need attoparsec to actually build what I need
22:56:59 <RustyShackleford> erikd: well sort of
22:57:05 <erisco> can ghc-mod be in a separate sandbox? I don't know, maybe
22:57:19 <arkeet> isn't ghc-mod an executable?
22:57:24 <erisco> yes
22:57:24 <RustyShackleford> this seems impossible without thinking of loops
22:57:28 <arkeet> I've never used it.
22:57:38 <arkeet> RustyShackleford: think with folds.
22:57:53 <erisco> it is only relevant if you're writing IDE extensions afaik, unless you have some other reason to do analysis on Haskell programs
22:57:53 <arkeet> and maps.
22:57:58 <arkeet> and stuff.
22:58:05 <erikd> RustyShackleford: discard all notion of loops and it becomes easier :-)
22:58:18 <erisco> so anyways, I just unregistered a dozen things
22:58:26 <erisco> and I am trying to install stylish-haskell again
22:58:30 <erikd> RustyShackleford: think of lists of data and operations on those lists
22:58:32 <erisco> no idea where that will get me but whatever
22:59:06 <erisco> I am worried about ghc-mod because it interacts with cabal I think
22:59:20 <erisco> and I fear if it is in a separate sandbox it won't pick up on the libraries I am using
23:01:38 <erisco> unfortunately it takes a long time to compile things so experimentation is expensive
23:02:10 <RustyShackleford> is there something where I can pass a list and a function
23:02:39 <Axman6> what do you mean?
23:02:43 <RustyShackleford> and get a list of the return values for the function with each of those parameters
23:02:54 <erisco> RustyShackleford try map
23:03:19 <arkeet> :t map
23:03:20 <lambdabot> (a -> b) -> [a] -> [b]
23:03:29 <erisco> :t try
23:03:30 <lambdabot> Exception e => IO a -> IO (Either e a)
23:03:35 <erisco> don't literally try map
23:06:54 <arkeet> :t map.map
23:06:55 <lambdabot> (a -> b) -> [[a]] -> [[b]]
23:06:58 <arkeet> :t map map
23:06:58 <lambdabot> [a -> b] -> [[a] -> [b]]
23:07:20 <arkeet> :t map map map
23:07:20 <lambdabot>     Couldn't match expected type ‘[a -> b]’
23:07:20 <lambdabot>                 with actual type ‘(a0 -> b0) -> [a0] -> [b0]’
23:07:20 <lambdabot>     Probable cause: ‘map’ is applied to too few arguments
23:07:23 <arkeet> indeed.
23:08:36 <erisco> need's more f's
23:08:53 <arkeet> :t fmap fmap fmap fmap fmap fmap
23:08:54 <lambdabot> (Functor f1, Functor f) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
23:09:19 <erisco> works best in odd numbers :)
23:09:26 <erisco> :t fmap fmap fmap fmap fmap
23:09:26 <lambdabot> Functor f => (a1 -> b) -> (a -> a1) -> f a -> f b
23:09:41 <erisco> :t fmap fmap fmap fmap fmap fmap fmap
23:09:41 <lambdabot> (Functor f2, Functor f1, Functor f) => f (a -> b) -> f (f1 (f2 a) -> f1 (f2 b))
23:13:01 <Axman6> anyone had any experience with using a web framework to produce a service which returns images created using the chart library? not sure where to start - I think Yesod is probably a bit heavey weight for this simple service
23:16:32 <erikd> Axman6: there's two kinds of frameworks; heavyweight where eveything is mostly done for you already and lightwieght where you have to build just about everything :-)
23:17:17 <Axman6> yeah, I'm just trying to figure out how I'd generate images and make them available vis a specific url
23:17:20 <Axman6> via*
23:17:32 <Axman6> haven't thought about it too deeply yet
23:19:16 <erisco> arkeet I don't know what happened but I appear to have everything installed now
23:19:24 <erikd> Axman6: different url means different image i presume
23:19:54 <erikd> Axman6: be back online in ~ 30 min
23:20:00 <breadmonster> I don't get this, but Fedora uses sudo a lot.
23:20:03 <breadmonster> A lot more than Ubuntu at least.
23:21:36 <maxc01> hello, anyone know how to implement this, 
23:21:36 <maxc01> f (x:xs) = 
23:21:36 <maxc01>   if x
23:21:36 <maxc01>     then x : f xs -- map
23:21:37 <maxc01>     else -- the final result is NULL and break
23:21:37 <maxc01> I want to use just one pass
23:22:03 <breadmonster> maxc01: What are you trying to do?
23:22:08 <breadmonster> You'll get a bunch of type errors.
23:22:16 <breadmonster> Unless this is a list of bool.
23:22:19 <breadmonster> *bools
23:22:44 <Axman6> you'll get a list of all the True's at the beginning of the list
23:23:33 <breadmonster> maxc01: If you want to do what Axman6 said then f = takeWhile (\x -> x) 
23:23:43 <maxc01> I am sorry, I will write it again because i was lazy last time
23:23:44 <breadmonster> :t takeWhile id
23:23:44 <lambdabot> [Bool] -> [Bool]
23:23:44 <Axman6> takeWhile id
23:23:51 <breadmonster> Yeah.
23:23:54 <erisco> f xxs = case xxs of x:xs -> if x then x : f xs else []; [] -> []
23:24:01 <erisco> there's my guess
23:24:09 <Axman6> yes, you need to be more clear about what inputs and outputs you're expecting
23:24:36 <glguy> I think maxc01 wants to their the whole thing away on failure. Like mapM on Maybe
23:24:53 <breadmonster> :t case xxs of x:xs -> if x then x : f xs else []; [] -> []
23:24:53 <maxc01> f g (x:xs) = 
23:24:53 <maxc01>     if g x
23:24:53 <maxc01>       then x : f g xs
23:24:53 <maxc01>       else -- the final result is NULL and break
23:24:53 <maxc01>     
23:24:54 <lambdabot> Not in scope: ‘xxs’
23:24:54 <lambdabot>     Ambiguous occurrence ‘f’
23:24:54 <lambdabot>     It could refer to either ‘L.f’,
23:25:11 <glguy> Don't paste like that, use a paste bin
23:25:15 <breadmonster> maxc01: What are you trying to do?
23:25:28 <maxc01> Yes, glguy is right
23:25:32 <breadmonster> maxc01: I can't fix your code if I don't know what it's supposed to be doing?
23:25:58 <Axman6> looks like `takeWhile g` to me
23:26:18 <Axman6> > takeWhile even [2,4,6,8,1,3,5,7]
23:26:20 <lambdabot>  [2,4,6,8]
23:26:26 <Axman6> > takeWhile even [1,2,4,6,8,1,3,5,7]
23:26:27 <lambdabot>  []
23:26:31 <glguy> \g -> mapM (\x -> x <$ guard ( g x))
23:26:45 <breadmonster> maxc01: You want to basically make one pass through the list to see if all elements pass some test?
23:26:53 <maxc01> Yes
23:26:53 <glguy> That sort of thing is what maxc01 is asking for
23:27:03 <breadmonster> Ah okay.
23:27:05 <breadmonster> Now I got it.
23:27:33 <glguy> If you want to know all elements satisfy the predicate you don't need to rebuild the list
23:27:50 <glguy> :t all
23:27:51 <lambdabot> (a -> Bool) -> [a] -> Bool
23:28:09 <maxc01> Oh, thank you, glguy and guys
23:28:37 <maxc01> but I don't know all elements satify the predicate
23:29:05 <glguy> That's why you test with all
23:29:06 <maxc01> there may be one or more elements do not satify the predicate
23:29:30 <glguy> > all even [1,2,3]
23:29:31 <lambdabot>  False
23:29:32 <maxc01> but if I do this, I have to use two pass
23:30:29 <glguy> Then you want the mapM thing on Maybe. Maybe someone else can demo it. I'm in my phone
23:31:01 <maxc01> thanks, I will try to work out myself first
23:32:41 <arkeet> :t mapM
23:32:42 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
23:34:22 <arkeet> :t mapM (\x -> if x then Just x else Nothing)
23:34:22 <lambdabot> [Bool] -> Maybe [Bool]
23:34:47 <arkeet> :t \p -> mapM (\x -> if p x then Just x else Nothing)
23:34:48 <lambdabot> (b -> Bool) -> [b] -> Maybe [b]
23:39:27 <fifosine> hey, sorry for the dumb question, how do I import PreludeList?
23:39:50 <Axman6> what is PreludeList and where is it from?
23:40:10 <fifosine> https://www.haskell.org/onlinereport/standard-prelude.html
23:40:11 <indiagreen> fifosine: were you reading Haskell Report?
23:40:14 <indiagreen> right
23:40:18 <indiagreen> it doesn't exist
23:40:26 <fifosine> oh :(
23:40:34 <fifosine> I guess I'm confused
23:40:38 <indiagreen> I mean, all functions from it are just in Prelude
23:40:47 <indiagreen> Prelude is split into 3 parts in the report
23:40:51 <indiagreen> for convenience
23:41:00 <indiagreen> but implementations aren't required to follow this
23:41:36 <dinnu93_> fifosine: It is the normal list
23:42:06 <fifosine> ok
23:42:08 <dinnu93_> that you get with prelude
23:49:00 <TheLambda> hello guys I'm a newbie in Haskell. Can you recommend me some books, webs, etc to learning this beauty language? 
23:49:24 <dinnu93_> TheLambda: Did you google first ?
23:49:28 <indiagreen> @where learn
23:49:28 <lambdabot> https://github.com/bitemyapp/learnhaskell | http://www.seas.upenn.edu/%7Ecis194/spring13/index.html | https://github.com/NICTA/course/
23:49:46 <indiagreen> TheLambda: the 1st link is a very comprehensive guide to guides
23:50:16 <indiagreen> as well as tools and stuff
23:50:21 <indiagreen> and everything
23:50:50 <dinnu93_> TheLambda: Go to the online book " learn you a haskell for greater good " and start reading it
23:51:22 <dinnu93_> here is the link http://learnyouahaskell.com/chapters
23:57:21 * hackagebot llvm-pretty 0.3.1.0 - A pretty printing library inspired by the llvm binding.  http://hackage.haskell.org/package/llvm-pretty-0.3.1.0 (TrevorElliott)
23:57:47 <Heather> I need help with recent process version, https://github.com/haskell/process/pull/21
