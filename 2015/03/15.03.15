00:10:16 * hackagebot context-free-grammar 0.0.1 - Basic algorithms on context-free grammars  http://hackage.haskell.org/package/context-free-grammar-0.0.1 (nedervold)
00:10:16 * hackagebot eigen 1.2.2 - Eigen C++ library (linear algebra: matrices, vectors, numerical solvers).  http://hackage.haskell.org/package/eigen-1.2.2 (OlegSidorkin)
00:12:20 <solatis> hey all, i'm looking into making a 'safe' replacement for attoparsec's string parser
00:12:30 <solatis> attoparsec's string parser is basically implemented as this:
00:12:44 <solatis> takeWhile s.length (== s)
00:13:14 <solatis> as in, if you have a parser string "wombat" <|> string "foo", the branch "foo" will never be reached because it is blocking on "wombat", requesting 6 bytes
00:13:57 <solatis> now, i'm breaking my head over whether there is an elegant way to rewrite this string parser into a "safe" string parser, that consumes & compares char-bye-char instead of the string as a while
00:13:59 <solatis> *whole
00:17:38 <bob_twinkles> solatis: check out try, I think that's what you're looking for
00:17:47 <solatis> let me see
00:18:17 <bob_twinkles> basically "run this parser, if it doesn't match pretend nothing has happened" i.e. no input consumed, no errors generated etc.
00:18:39 <solatis> that is only when it fails though
00:18:46 <solatis> what happens in the case of a partial?
00:19:19 <solatis> (which is what the case i mentioned above returns)
00:19:36 <bob_twinkles> the string parser will only consume input if it matches
00:19:53 <solatis> Atto.parse (string "wombat" <|> string "foo") "foo" -> returns a Partial
00:20:25 <solatis> because it never leaves the branch of string "wombat"
00:21:28 <bob_twinkles> Atto.parse (try (string "wombat") <|> string "foo") should work assuming my understanding of parsec isn't fundamentally flawed
00:22:08 <solatis> this is attoparsec
00:22:12 <solatis> not parsec
00:22:14 <glguy> In attoparsec: Note: The behaviour of this parser is different to that of the similarly-named parser in Parsec, as this one is all-or-nothing. To illustrate the difference, the following parser will fail under Parsec given an input of "for":
00:22:45 <glguy> http://hackage.haskell.org/package/attoparsec-0.12.1.3/docs/Data-Attoparsec-Text.html#g:11
00:23:15 <solatis> bob_twinkles, your solution doesn't work
00:23:20 <solatis> since the parser does not fail
00:23:27 <solatis> look at the implementation of string:
00:23:54 <bob_twinkles> ah, I see. didn't RTFM close enough and I'm used to Parsec sorry
00:24:03 <solatis> https://github.com/bos/attoparsec/blob/master/Data/Attoparsec/ByteString/Internal.hs#L173
00:24:12 <solatis> string s = takeWith (B.length s) (==s)
00:24:26 <solatis> in other words: it "blocks" on consuming 6 bytes
00:24:39 <solatis> even though i have provided 3 bytes that 100% match the other branch
00:25:18 <solatis> rewriting the parser as (string "foo" <|> string "wombat") works, but can be called an suboptimal solution at best
00:25:33 <solatis> i am looking to write a 'safe' string parser alternative
00:26:14 <arkeet> isn't try a no-op in attoparsec?
00:26:21 <solatis> yes
00:26:31 <solatis> try is a no-op, since attoparsec always backtracks
00:29:37 <solatis> anyway, i'm not sure how to approach a proper solution for this
00:29:55 <solatis> i guess you could argue to only write LL(1) parsers
00:33:29 <solatis> grmbl.. i remember someone posting an elegant solution to this one time in here
00:33:35 <solatis> are there any public logs of #haskell?
00:33:52 <solatis> ah, /me rtft (title)
00:35:11 * hackagebot eigen 1.2.3 - Eigen C++ library (linear algebra: matrices, vectors, numerical solvers).  http://hackage.haskell.org/package/eigen-1.2.3 (OlegSidorkin)
00:39:04 <solatis> found it!
00:39:07 <solatis> string' = mapM (Atto.satisfy . (==)) . BS.unpack
00:39:16 <solatis> credits go to Cale 
00:39:28 <f|`-`|f> ???
00:40:24 <solatis> what?
00:40:37 <solatis> Cale, ping
00:41:18 <Hijiri> does unpack handle unicode?
00:41:37 <solatis> this is for a bytestring parser, of course
00:42:11 <solatis> you can probably do the same for Text.unpack
00:55:13 * hackagebot record 0.3.1 - First class records implemented with quasi-quotation  http://hackage.haskell.org/package/record-0.3.1 (NikitaVolkov)
01:06:30 <m-r-r> Hello
01:07:31 <wavewave> m-r-r: hello.
01:16:29 <Slothrop> Is an order isomorphism always surjective
01:25:14 * hackagebot cassava 0.4.2.2 - A CSV parsing and encoding library  http://hackage.haskell.org/package/cassava-0.4.2.2 (JohanTibell)
01:40:15 * hackagebot eigen 1.2.4 - Eigen C++ library (linear algebra: matrices, vectors, numerical solvers).  http://hackage.haskell.org/package/eigen-1.2.4 (OlegSidorkin)
01:41:49 <Haskellfant> Hi, I have a projects that consists of a minimal executable, a library (to extract any reusable parts) and two test suites. For the tasty-hspec testsuite I just added the library to the build-depends and it finds everything. However I run doctests on a file in the executable and there it doesn't find the library even though I have added it to the build-depends. What do I need to change to make doctests find
01:41:50 <Haskellfant> the lib?
01:50:15 * hackagebot network-attoparsec 0.12.2 - Utility functions for running a parser against a socket  http://hackage.haskell.org/package/network-attoparsec-0.12.2 (solatis)
02:17:26 <aawe> :t fix
02:17:27 <lambdabot> (a -> a) -> a
02:17:32 <aawe> > fix bug
02:17:33 <lambdabot>  "no"
02:17:41 <aawe> :(
02:18:26 <Qfwfq> :t fix (const "bug")
02:18:27 <lambdabot> [Char]
02:19:29 <mauke> fix == unconst
02:19:47 <mauke> fix . const == id
02:19:55 <mauke> const == return
02:19:58 <mauke> (.) == fmap
02:20:04 <mauke> fmap fix return == id
02:20:48 <whitesn> hello, are there any way to call function iteratively like this ( print x where x = 1 to 25 )
02:21:23 <mauke> mapM_ print [1 .. 25]
02:21:31 <mauke> assuming you want a single IO action, not a list of actions
02:22:30 <mauke> also available in flipped form: forM_ [1 .. 25] $ \i -> do print i
02:22:48 <whitesn> i want to call a function, let's say, foo (0,y) where y = 0 to 25
02:23:19 <whitesn> so it will call foo (0,0), foo (0,1).. foo (0,25)
02:24:41 <Qfwfq> mauke: I intended to make a pun.
02:25:09 <whitesn> and what I'm trying to figure out is to do function with 2 arguments
02:25:19 <mauke> that function only has one argument
02:25:27 <mauke> (all functions have exactly one argument)
02:25:36 <mauke> map (\y -> foo (0,y)) [0 .. 25]
02:25:51 <mauke> > let foo = show in map (\y -> foo (0,y)) [0 .. 25]
02:25:53 <lambdabot>  ["(0,0)","(0,1)","(0,2)","(0,3)","(0,4)","(0,5)","(0,6)","(0,7)","(0,8)","(0...
02:26:33 <whitesn> and what I'm trying to figure out is to do function with 2 arguments
02:26:40 <whitesn> oops sorry
02:29:14 <m0rphism> whitesn: Haskell uses curried functions by default. This means that
02:29:14 <m0rphism>   add :: Int -> Int -> Int
02:29:15 <m0rphism>   add x y = x + y
02:29:15 <m0rphism> is actually the same as
02:29:15 <m0rphism>   add :: Int -> (Int -> Int)
02:29:15 <m0rphism>   add = \x -> (\y -> x + y)
02:29:15 <m0rphism> so if you call (add 1 2) it is actually ((add 1) 2), where (add 1) returns a function which takes another argument and adds 1 to it.
02:30:58 <whitesn> hmm
02:31:45 <m0rphism> an alternative is to pass tuple, i.e:
02:31:45 <m0rphism>   add' :: (Int, Int) -> Int
02:31:45 <m0rphism>   add' (x,y) = x + y
02:31:45 <m0rphism> here you pass a single argument which is a pair of integers. Using curry and uncurry function one can transform between the two forms, i.e. (uncurry add) is add' and (curry add') is uncurry.
02:33:01 <m0rphism> but people usually prefer to use use the first version, as you can partially apply it, i.e. I can define another function which adds 2 to its argument as:
02:33:01 <m0rphism>   add2 :: Int -> Int
02:33:01 <m0rphism>   add2 x = add 2 x
02:33:01 <m0rphism> or simply:
02:33:01 <m0rphism>   add2 = add 2
02:35:15 <m0rphism> If you need further clarification, feel free to ask :)
02:35:18 * hackagebot gl 0.7.3 - Complete OpenGL raw bindings  http://hackage.haskell.org/package/gl-0.7.3 (Polarina)
02:35:21 <aawe> > do x <- [1,2,3]; y <- ['a', 'b', 'c']; return (x,y)
02:35:22 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
02:35:54 <aawe> whitesn: ^ something like this?
02:37:18 <aawe> > [(x,y) | x <- [1,2,3], y <- ['a', 'b', 'c']]
02:37:19 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
02:37:51 <aawe> replace (x, y) with (f x y) or  (f (x,y))
02:38:00 <whitesn> hmm basically i have a function that takes 2 args (tuples), foo (1,b) (2,d)
02:38:10 <whitesn> sorry i mean foo (1,b) (2,b)
02:38:21 <whitesn> then i want b from 1..20
02:39:12 <mauke> > let foo = show in map (\b -> foo (1,b) (2,b)) [1 .. 20]
02:39:13 <lambdabot>  Couldn't match expected type ‘(t1, t2) -> b’
02:39:13 <lambdabot>              with actual type ‘[GHC.Types.Char]’
02:39:13 <lambdabot>  Relevant bindings include b :: t2 (bound at <interactive>:1:25)
02:39:26 <mauke> > let foo x y = show (x, y) in map (\b -> foo (1,b) (2,b)) [1 .. 20]
02:39:27 <lambdabot>  ["((1,1),(2,1))","((1,2),(2,2))","((1,3),(2,3))","((1,4),(2,4))","((1,5),(2,...
02:39:34 <aawe> > let f = print in sequence $ [f (x,y) | x <- [1,2], y <- [1..5]]
02:39:36 <lambdabot>  <IO [()]>
02:39:49 <mauke> sequence_
02:40:33 <whitesn> i got error seems not related to the map
02:40:35 <whitesn>  Couldn't match type ‘[Char]’ with ‘Char’
02:40:37 <whitesn>  Expected type: Char
02:40:39 <whitesn>    Actual type: PostScript
02:43:55 <whitesn> oh because map function returned a list of characteres, i just want to call the function from the map
02:45:19 * hackagebot conduit-extra 1.1.7.1 - Batteries included conduit: adapters for common libraries.  http://hackage.haskell.org/package/conduit-extra-1.1.7.1 (MichaelSnoyman)
02:55:19 * hackagebot eigen 1.2.5 - Eigen C++ library (linear algebra: matrices, vectors, numerical solvers).  http://hackage.haskell.org/package/eigen-1.2.5 (OlegSidorkin)
03:04:51 <miniBill> @djinn (Monad m) => (Maybe a) -> (a -> m b) -> m (Maybe b)
03:04:51 <lambdabot> -- f cannot be realized.
03:04:57 <miniBill> Why cannot it be realized?
03:05:13 <rui3> @pl "f x = x"
03:05:13 <lambdabot> "f x = x"
03:05:18 <rui3> @pl x
03:05:18 <lambdabot> x
03:05:28 <FireFly> Try without the quotes
03:05:28 <jle`> miniBill: djinn doesn't know about Monad in a useful way
03:05:46 <miniBill> jle`: oic. do you know how could I realize it?
03:05:55 <jle`> it's forM
03:05:58 <jle`> from Data.Traversable
03:06:03 <rui3> @pl \x -> x
03:06:03 <lambdabot> id
03:06:12 <jle`> :t  T.forM `asAppliedTo` Nothing
03:06:13 <lambdabot> Monad m => Maybe a -> (a -> m b) -> m (Maybe b)
03:06:23 <miniBill> looks familiar :D
03:06:32 <miniBill> jle`: thank you very much
03:06:36 <jle`> :t forM
03:06:36 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
03:06:40 <rui3> @pl \k xs -> replicate k p ++ xs
03:06:40 <lambdabot> (++) . flip replicate p
03:06:44 <jle`> it's just the normal forM but Maybe instead of [] :)
03:06:46 <mauke> f a b = case a of Nothing -> return Nothing; Just c -> b c >>= \d -> return (Just d)
03:06:47 <miniBill> I knew there had to be a clean way to write it
03:06:51 <jle`> in a month or two it will now be the normal forM
03:06:55 <mauke> ... is what djinn would say if it could
03:06:56 <jle`> *it will then
03:06:57 <miniBill> jle`: oh...
03:07:09 <jle`> yeah, this generalized forM is moving into Prelude 
03:07:14 <miniBill> mauke: which is what I have, but it doesn't look nice
03:07:26 <miniBill> jle`: so they decided to go ahead with the proposal?
03:07:42 <jle`> mhm
03:08:09 <mauke> :t maybe (return Nothing) (liftM Just)
03:08:10 <lambdabot> Monad m => Maybe (m a) -> m (Maybe a)
03:08:18 <TRManderson> :t liftA2
03:08:19 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
03:09:13 <jle`> :t \m f -> maybe (pure Nothing) (fmap Just) $ fmap f m
03:09:13 <lambdabot> Applicative f => Maybe a1 -> (a1 -> f a) -> f (Maybe a)
03:09:22 <jle`> oh beat me to it
03:09:39 <jle`> i'm not sure why people just hop into #haskell to query lambdabot
03:09:57 <jle`> it's been a trend these days
03:12:43 <TRManderson> eh, it was alt + -> away rather than starting up ghci
03:12:49 <int-e> @type traverse
03:12:50 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
03:20:34 <int-e> Will we eventually get rid of forM / mapM now that AMP is a reality?
03:21:59 <int-e> (I guess not because it would break a lot of programs without much benefit, but it's a bit annoying to have so many aliases for traverse)
03:42:40 <edwardk> int-e: to get there we need a bit more. we just now are getting to where we could remove mapM from the Traversable class in ~7.14. the stack is now unbounded, so the weird mapM example that was so damning isn't so much any more. so we could deprecate redefinition of mapM and sequence (and even sequenceA) in 7.12, and then remove them from the class making
03:42:40 <edwardk> them top level definitions in 7.14, and possibly even deprecate the redundant ones in 7.16 or something
03:42:50 <edwardk> but that last step is somewhat unlikely
03:43:12 <edwardk> but all those intermediate steps would have to happen to make removal of forM/mapM an option
03:44:06 <shachaf> The mapM example should be documented somewhere.
03:44:10 <edwardk> and forM is flipped mapM, we have `for` for flipped traverse, but `for` isn't exported by Prelude or Control.Monad
03:44:30 <edwardk> agreed
03:45:05 <edwardk> once you put all those factors together it bodes not well for you getting rid of those redundant names any time soon
03:46:20 <edwardk> same with 'removing return'. even if we decide in 7.12 or 7.14 to deprecate redefinition of return, so that in a later release we could remove return from the class, it'd be a long move from there to removing 'return' from _all haskell code written_.
03:46:24 <edwardk> same with removing forM or mapM
03:46:37 <edwardk> annoying or not you have to weigh 'an extra name' against touching all haskell code ever
03:46:53 <edwardk> and in a way that prevents working backwards compatibly
03:47:42 <edwardk> so it probably just won't happen until compilers before 7.10 or 7.12 or 7.14 or whenever the enabling changes are finished are just a distant memory
03:47:50 <edwardk> e.g. the way folks think of GHC 6.x today
03:49:41 <int-e> edwardk: I think the burden of updating code for such common functions outweighs the need to learn another couple of aliases here. I really don't expect mapM or forM to ever be removed.
03:50:12 <edwardk> int-e: me neither. just figured i'd give a sense of the scope such an undertaking would actually have
03:50:13 <int-e> (In Haskell, and with the standard base library)
03:50:21 <mleduc> does anybody has a  paper or examples about how to deal with shared resources (e.g. databases connections) on pipelined treatment (using pipes library for example) ? I'm am not happy with the way things are going on my currents developments.
03:51:04 <edwardk> i do think we may eventually remove them from the Traversable class and make them mere top level exports, that would let us downgrade their requirements to mere Applicative constraints.
03:52:01 <edwardk> same with after a sufficient delay deprecating the direct redefinition of 'return' and (>>) in Monad so that in the end we could weaken the requirements for each to Applicative. This would be a nice step towards making ApplicativeDo require _much_ less magic.
03:52:36 <edwardk> i don't anticipate either happening soon, however.
03:52:37 <shachaf> I think big pointless changes like eliminating return can wait until we have a mechanism to make changes like that backwards compatible.
03:52:54 <edwardk> shachaf: well, we keep hoping for that mechanism. we keep not getting it
03:52:59 <shachaf> That's fine.
03:53:02 <edwardk> i've been waiting for one since i joined the community
03:53:06 <shachaf> No hurry to eliminate return. :-)
03:53:40 <edwardk> not in a hurry to eliminate it. just saying that it could move to a top level definition in terms of pure if we had deprecated redefinitions. i'd personally leave the name
03:54:28 <edwardk> whether that is a change the community would embrace is entirely an open question, and i anticipate the move wouldn't be popular
03:54:45 <edwardk> so i'm not hopeful that without a concerted PR effort and a solid plan that it'd be a good idea
03:54:52 <edwardk> and we don't have either right now
03:55:01 <edwardk> but i can envision a world where we could do that thing
03:55:27 <edwardk> and it is one in which ApplicativeDo would be measurably easier to understand
03:56:04 <shachaf> Hmm, *> and ApplicativeDo isn't something I thought about. do { _ <- a; _ <- b; c } means join (liftA2 (const (const c)) a b)
03:56:07 <edwardk> but i think doing something similar to Traversable to mapM/forM would be a much better test.
03:56:34 <shachaf> Well, OK, the ApplicativeDo transformation would handle it automatically.
03:56:40 <shachaf> No join necessary.
03:56:49 <shachaf> OK, I need to go to sleep.
03:56:53 <edwardk> because far fewer Traversable instances define a manual mapM/sequence than Monad's define return ;)
03:57:41 <edwardk> that would let us develop an intuition for how bad people find removing members from a class after a deprecation cycle when there is an existing default definition in place.
03:59:06 <rui3> in the ghc errors, often the type parameters get switched from "a" or "b" to "a0", "b1" etc
03:59:11 <edwardk> So if I had to pick how I'd prefer to proceed, it'd probably be to see about deprecating definitions of Traversable's mapM and sequence in 7.12, and moving them outright to the top level in terms of traverse and sequenceA in the class in 7.14 or so, and seeing how people react to a more general mapM, before we consider doing _anything_ else.
03:59:28 <rui3> Should I think of those as different types or just an internal renaming?
03:59:47 <edwardk> rui3: ghc tries to keep a name similar to the one given when it has to rename them internally to avoid other names that conflict.
03:59:52 <shachaf> If there's an a0, it's probably because it conflicted with an existing a.
04:00:15 <rui3> Humm
04:01:11 <edwardk> rui3: they are 'different types' caused by different instantiations of a given type schema in different places.
04:01:53 <edwardk> a2 and a3 will have nothing to do with each other except the fact that the bits of code where those two different types came from probably both liked the name 'a' for the type variables.
04:02:23 <rui3> Ok, great, thanks a lot edwardk and shachaf. Now I have to think how this fits with my errors. Wish me luck
04:06:32 <edwardk> :t (const, const)
04:06:33 <lambdabot> (a -> b -> a, a1 -> b1 -> a1)
04:06:41 <edwardk> each of those is a different type variable
04:06:43 <edwardk> but
04:06:44 <edwardk> :t const
04:06:45 <lambdabot> a -> b -> a
04:06:54 <edwardk> they wanted to be 'a's and b's respectively
04:06:55 <rui3> edwardk great example snippet
04:07:22 <edwardk> :t const flip
04:07:23 <lambdabot> b -> (a -> b1 -> c) -> b1 -> a -> c
04:07:33 <edwardk> there both flip and const have 'b's in the type, but they are unrelated
04:07:34 <edwardk> :t flip
04:07:34 <lambdabot> (a -> b -> c) -> b -> a -> c
04:07:58 <edwardk> it could make up any name it wants, but we assign semantic meaning to out variable names, we like f's and m's for functors and monads, etc.
04:08:01 <rui3> :t const . flip . id . (.) const
04:08:03 <lambdabot> (a -> c) -> b -> b1 -> a -> c
04:08:13 <rui3> Oh, I wanted a longer type
04:08:27 <adamse> :t flip const
04:08:28 <lambdabot> b -> c -> c
04:08:41 <edwardk> :t (const, flip, const flip)
04:08:42 <lambdabot> (a -> b -> a, (a1 -> b1 -> c) -> b1 -> a1 -> c, b2 -> (a2 -> b3 -> c1) -> b3 -> a2 -> c1)
04:08:46 <rui3> edwardk: do you think it is good practice then to use unmeaningful letters for types always, such as a and b?
04:09:22 <edwardk> rui3: my rule of thumb is that i set the length of my names based on how long they will be in scope. if they are just for visual pattern matching within a type signature? i err on the side of short names
04:09:47 <edwardk> otherwise i complicate the only purpose they really have, which is ensuring that two types are the same if they are the same name
04:10:12 <edwardk> otherwise i risk foo :: antidisestablishmentarianism -> b -> antidisestablshmentarianism
04:10:18 <edwardk> where i made a typo, but don't know
04:10:37 <edwardk> the whole purpose of that identifier is to aid me in visually pairing it up with the result type
04:10:44 <edwardk> and making it longer actively got in the way
04:10:56 <rui3> edwardk: That makes sense in htat code is more readable. However, based on my current suffering with type errors, there's also the issue of interpreting those
04:11:28 <edwardk> i tend to fix my code by putting _'s in and looking at what i have to fill the holes
04:11:37 <edwardk> this works best when you have very very polymorphic types
04:11:44 <rui3> edwardk: I saw that that requires some more up to date version of ghc
04:11:54 <rui3> than what Fedora currently gives me with yum
04:11:56 <edwardk> rui3: good reason to upgrade ;)
04:12:10 <rui3> I could update manually but if it is really worth it :)
04:12:48 <edwardk> you can fake this on older GHCs, but its not as useful, because the type errors don't tell you what is in scope to fill the hole
04:13:05 <edwardk> you can use {-# LANGUAGE ImplicitParams #-}
04:13:10 <edwardk> and use ?x    as the hole
04:13:24 <edwardk> and get a type error when it warns that it needs a value ?x :: ... with some type
04:13:34 <edwardk> er doesn't warn, gives an error
04:13:57 <edwardk> and if you know local names in scope you can pass them as args to ?x to get their types to try to figure out what to fill the hole with, etc.
04:14:47 <edwardk> foo bar baz = quux (?x y bar baz) where y = 12 + baz -- gives an error that lets me help figure out the type that should replace (?x y bar baz)
04:14:56 <edwardk> er the term that should replace it
04:15:54 <edwardk> with 7.8+ when you use _foo and _foo isn't a variable in scope, you get the error as above, but you also get all the variables bound in local scope and their types
04:17:09 <edwardk> https://www.irccloud.com/pastebin/RufbDxSp/example
04:18:40 <rui3> edwardk this all seems very useful
04:27:30 <m0rphism> rui3: This might also be an opportunity to try out the nix package manager, which can coexist nicely with distribution specific package managers. By default the installation script creates a /nix folder in root where all the packages reside, and adds a line to the .bash_profile to include installed packages into $PATH. In contrast to regular unix package managers, nix installs each package in /nix/store/somehash-packagename/{bin,
04:27:41 <m0rphism> this got a bit longer than intended ^.^'
04:31:08 <rui3> m0rphism: and what's the advantage?
04:31:32 <rui3> m0rphism: it has better repos that one can't get with yum for example?
04:33:07 <m0rphism> rui3: I've I understood you correctly, your initial problem was that the yum ghc version was too old.
04:34:56 <m0rphism> rui3: I'm not that familiar with yum, so I can't give you a comparison, I can only list features I found noteworthy :)
04:35:59 <phaazon> http://www.reddit.com/r/haskell/comments/2z45k8/getting_into_netwire/
04:36:03 <phaazon> let me know what you think ;)
04:38:22 <rui3> m0rphism I'll try it, it's free :)
04:38:54 <arw_> phaazon: "and is barely impossible to test against" <- s/barely/almost/, but i'm not a native speaker so i might be wrong
04:39:21 <phaazon> yeah, almost is better I guess
04:39:24 <phaazon> thanks!
04:39:25 <m0rphism> rui3: Have fun :) It has a bit of a learning curve, since it features it's own lazy functional language for package description, but at least for me it was totally worth the effort.
04:39:26 <phaazon> \o
04:39:35 <Yaniel> barely == almost not
04:42:49 <m0rphism> rui3: but you don't have to actually write much in it necessarily. there's a tool called cabal2nix which translates cabal files into package manager format, so most of the times it suffices to go into the folder of your haskell project's .cabal file, run cabal2nix on it and then run nix-shell, which installs all dependencies and drops you into a shell where these dependencies are available, so you can simply use "cabal build" or 
04:45:26 * hackagebot hfoil 0.2.0.1 - Hess-Smith panel code for inviscid 2-d airfoil analysis  http://hackage.haskell.org/package/hfoil-0.2.0.1 (GregHorn)
05:10:26 * hackagebot log-domain 0.10 - Log-domain arithmetic  http://hackage.haskell.org/package/log-domain-0.10 (EdwardKmett)
05:35:51 <m0rphism> rui3: I hope I wasn't too pushy with my enthusiasm for nix ;) It is of course overkill if all you are looking for is an up-to-date ghc and you are not interested (at the moment) in the other features it provides for Haskell development. It is just so easy to get carried away, if one has just found something one finds awesome, and wants to tell the world about it ;) I should probably focus more on the immediate problems people are
05:39:22 <rui3> m0rphism: Installed ghc with nix
05:39:25 <rui3> Thanks
05:39:51 <m0rphism> rui3: Yay, you're welcome :)
05:41:39 <Ornedan> Are there examples somewhere of getting monad-logger to log to both file and stderr?
05:42:54 <rui3> m0rphism, however, it doesn't seem to have an updated firefox. How do you usually use it? Just search in the unstable channel and install if it is there?
05:44:49 <m0rphism> rui3: yep, I mostly use the nixpkgs-unstable channel. Usually this channel is quite up-to-date, but since 40 days the buildbot hydra has problems, and hence there is no update :/ this should be a temporary problem, however
05:45:16 <rui3> m0rphism: great then
05:47:30 <m0rphism> rui3: The repository is actually a github-repo with all the package-descriptions, so if one really wants to have a version more recent than available on the channels, the repository can be used directly. But then there are no prebuilt binaries, so nix will build the packages itself.
05:48:17 <adam_hardkey_shi> Hey, someone has a good book or tutorial to go deep in haskell understanding and possibly mastery? I have an intermediate level in haskell, I think (I wrote basic applications, using IO monad, Netwire, SDL and OpenGL) and I have a very good mathematical background, so no problem if the stuff is loaded in maths.
05:48:26 <m0rphism> rui3: A nix-channel is basically a snapshot of this github-repo + a cache in which the built packages are stored for various architectures.
05:49:49 <m0rphism> rui3: The idea is, that nixpkgs-unstable get's available after the buildbot has finished making binaries and running some tests on the head of the nixpkgs repository. This should normally (without buildbot problems) take no longer than 2 days, afaik.
05:51:44 <rui3> m0rphism: Am I too off when I say this?: a nix-env -qa something searches for something in a local cache, that gets updated when you do nix-channel update (?)
05:53:13 <m0rphism> rui3: It searches in a remote cache, which i think is the reason why it is so slow ^^
05:54:00 <Narfinger> hiho, is there a good tutorial for reading binary file formats and parsing them with haskell? the documentatin for the binary package does not help me enough
05:54:09 <m0rphism> rui3: you can either cache the results to a local file, or use nox, which is a wrapper for installing and searching nix
05:54:35 <m0rphism> rui3: nox does the caching automatically
05:54:41 <bennofs> rui3, m0rphism: it searches locally. It's slow because it needs to evaluate all of nixpkgs (the definitions of all packages), and nixpkgs can contain arbitrary code in the Nix programming language
05:55:10 <m0rphism> bennofs: Ah, I see. Thanks for the clarification :)
05:55:13 <bennofs> also, nixpkgs consists of many small files. So loading all of nixpkgs from disk can take some time the first time. When it's in cache, it's much faster IME
05:55:29 * hackagebot log-domain 0.10.0.1 - Log-domain arithmetic  http://hackage.haskell.org/package/log-domain-0.10.0.1 (EdwardKmett)
06:02:24 <adam_hardkey_shi> Anyone for my question?
06:02:51 <exio4> adam_hardkey_shi: you may have better luck just asking it
06:03:14 <adam_hardkey_shi> Hey, someone has a good book or tutorial to go deep in haskell understanding and possibly mastery? I have an intermediate level in haskell, I think (I wrote basic applications, using IO monad, Netwire, SDL and OpenGL) and I have a very good mathematical background, so no problem if the stuff is loaded in maths.
06:03:17 <m0rphism> exio4: he did, scroll up ;)
06:03:34 <bennofs> adam_hardkey_shi: not sure if it's possible to ever master haskell :)
06:03:59 <adam_hardkey_shi> bennofs: come as close as possible, then. ^^
06:04:51 <exio4> m0rphism: oh, well, I just logged back and didn't see it :P 
06:05:02 <quchen> adam_hardkey_shi: Well, find something interesting and keep thinking about it. You can comfortably let Haskell nerdsnipe you for years. Example: go understand holey monoids.
06:05:18 <quchen> ?hackage HoleyMonoid
06:05:18 <lambdabot> http://hackage.haskell.org/package/HoleyMonoid
06:06:08 <quchen> I'm currently on a long journey to *understand* monads. I'd say it's a long-term goal.
06:06:28 <quchen> You can start working on GHC, which is more of an operational approach to "mastering" Haskell.
06:06:43 <m0rphism> adam_hardkey_shi: I haven't seen a single book trying to capture commonly used advanced techniques (allthough I haven't searched explicitly for it). There are a lot of papers covering individual advanced techniques, however.
06:07:10 <quchen> It also depends a lot on what you consider "advanced". Some people say monad transfomers are advanced, others say they're beginner stuff.
06:07:13 <rui3> Say class C a b where f :: a
06:07:26 <rui3> and then I use f somewhere
06:07:32 <adam_hardkey_shi> quchen m0rphism : thanks
06:07:40 <adam_hardkey_shi> :D
06:07:51 <rui3> How do I tell the compiler which instance of f to use?
06:08:59 <quchen> adam_hardkey_shi: r/haskell often has interesting posts about advanced concepts. The "Comonad Reader" has blog posts that poke into the mathematical side of cutting edge discoveries in Haskell. Tekmo's ("Haskell for all") also often mentions pretty interesting concepts, but with a strong emphasis on general practicability.
06:09:21 <exio4> you could either use a functional dependency | a -> b, or you could use something like (f :: (C a b) => a) 
06:09:34 <adam_hardkey_shi> Oh, I know the Comonad Reader. Very good stuff. :)
06:09:54 <adam_hardkey_shi> I'll like at the reddit and Haskell for All
06:10:18 <quchen> This one is also excellent: http://bartoszmilewski.com/
06:10:38 <quchen> And hanging around on IRC will teach you a lot of things by accident too :-)
06:10:41 <rui3> exio4 the class has other stuff that depend on both a and b, I don't want to forbid C Int Float and C Int Double to both exist for example
06:10:41 <bennofs> rui3: I think that code will not compile (with the class). Afaik, GHC requires each type variable of the class to appear somewhere in the methods of the class
06:10:49 <bennofs> @let class T a b where f :: a
06:10:51 <lambdabot>  Defined.
06:10:52 <rui3> I'll try your second alternative
06:10:53 <bennofs> :o
06:11:00 <rui3> bennofs: it exists in other stuff :P
06:11:14 <bennofs> @let instance T Int () where f = 3
06:11:15 <lambdabot>  Defined.
06:11:25 <bennofs> @let instance T Int Bool where f = 4
06:11:26 <lambdabot>  Defined.
06:11:42 <bennofs> > f :: C Int Bool => Int
06:11:43 <lambdabot>  Not in scope: type constructor or class ‘C’Ambiguous occurrence ‘f’
06:11:43 <lambdabot>  It could refer to either ‘L.f’, defined at L.hs:155:9
06:11:43 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.f’,
06:11:52 <bennofs> > L.f :: C Int Bool => Int
06:11:53 <lambdabot>  Not in scope: type constructor or class ‘C’
06:12:12 <bennofs> > L.f :: T Int Bool => Int
06:12:14 <lambdabot>  Could not deduce (L.T GHC.Types.Int b0) arising from a use of ‘L.f’
06:12:14 <lambdabot>  from the context (L.T GHC.Types.Int GHC.Types.Bool)
06:12:14 <lambdabot>    bound by an expression type signature:
06:12:15 <exio4> > L.f :: (x ~ Int, C x Bool) => x 
06:12:16 <lambdabot>  Not in scope: type constructor or class ‘C’
06:12:20 <exio4> > L.f :: (x ~ Int, T x Bool) => x 
06:12:21 <lambdabot>  Could not deduce (L.T GHC.Types.Int b0) arising from a use of ‘L.f’
06:12:21 <lambdabot>  from the context (x ~ GHC.Types.Int, L.T x GHC.Types.Bool)
06:12:21 <lambdabot>    bound by an expression type signature:
06:12:28 <adam_hardkey_shi> quchen: Wow, cool, blog posts about category theory. I'm reading a book about it, quite fascinating.
06:12:31 <exio4> grrrrrr, let's go the REPL and get it working 
06:12:48 <quchen> adam_hardkey_shi: Yes, that series in particular is amazing.
06:12:58 <quchen> adam_hardkey_shi: I think the first post is titled "the essence of composition".
06:13:37 <adam_hardkey_shi> quchen thanks a lot for all this information !
06:13:52 <bkaes> quchen: It is. Here's the TOC: http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
06:14:56 <quchen> You're welcome.
06:14:59 <bennofs> adam_hardkey_shi: http://blog.sigfpe.com/ might also be interesting
06:15:57 <adam_hardkey_shi> bennofs: I know this one, it introduced me to comonad. ^^
06:18:08 <rui3> exio4 what's the ~?
06:18:37 <mniip> rui3, equals
06:19:24 <exio4> rui3: type equality
06:19:43 <rui3> Oh, so x ~ Int => x is equivalent to Int
06:20:03 <rui3> ?
06:21:18 <quchen> :t let f :: (x ~ Int) => x -> x; f x = x in f -- rui3 
06:21:19 <lambdabot> Int -> Int
06:21:38 <JagaJaga> If I define my own Show instance, will haskell be able to create Read with using deriving?
06:21:41 <m0rphism> exio4: I haven't used type constraints before. Am i correct, that in the above case you are using it, because the type class constraint `T x Bool` requires `x` to be a variable, so `T Int Bool => ...` would not work?
06:21:44 <quchen> JagaJaga: No.
06:21:58 <JagaJaga> quchen: thank you.
06:22:07 <exio4> m0rphism: pretty much, didn't work as expected though :P  
06:22:15 <m0rphism> exio4: I see, thanks :)
06:22:21 <quchen> JagaJaga: Read is a simple class that gives you a parser. Show is something that "dumps data to String". The two can, but don't have to be, inverses of each other.
06:22:53 <quchen> JagaJaga: A bit of meta-advice concerning Show/Read: https://github.com/quchen/articles/blob/master/fbut.md#show-is-not-for-prettyprinting
06:23:20 <JagaJaga> quchen: thank you, gonna read :)
06:23:30 <exio4> I am thinking adding dummy Proxy parameters in the implementations would be an easy way to do this 
06:26:14 <m0rphism> rui3: About your previous question regarding `nix-env -qa` working on a local cache and `nix-channel --update` updating this cache: you are correct. Missed the last part of your question when I previously read it ;)
06:51:35 <co-arbelos> Ok if you guys think this discussion is off-topic I can move it to #blah but I usually get good advice here so ... I am using another "functional" language for a project which means non-purity is involved..
06:52:04 <co-arbelos> and I find it a bit confusing having a choice between mutable data structures and a set of operations on these, and the more pure API for their immutable counterparts
06:53:28 <nh2> co-arbelos: what's confusing about it? You mean you don't know which one you should pick?
06:53:57 <co-arbelos> nh2: right, like arrays vs. pure lists for instance
06:54:27 <co-arbelos> obviously mutable data has its place even in haskell, but
06:55:10 <co-arbelos> but when i look at the code, it looks more like OOP than a functional program
06:55:38 <co-arbelos> and maybe that's not a problem, from an operational perspective
06:56:21 <EvanR> its possible to do reasonable oop in haskell, which probably doesnt mean anything like java
06:56:44 <EvanR> thanks to the concurreny system
06:56:52 <EvanR> concurrency
06:57:39 <co-arbelos> yes but oop in haskell is a different thing..
06:58:08 <nh2> probably depends a bit on what your goals are and how cheap the language makes the functional API. E.g. if you are programming something in a concurrent setting, the pure API might save you headaches coming from concurrent reads/writes. If not, you might be better off using the mutable API simply because it's fast. Especially if you can contain the side effects, like you could in ST in Haskell
06:59:58 <nitrix> Just verifying my terminology: `5` is a value. `Just 5` is a value. `Just` is a value constructor. `Maybe a` is a type. `Maybe` is a type constructor.
07:00:00 <nitrix> Maybe has the kind `* -> *`.
07:00:16 <nh2> nitrix: right
07:00:19 <EvanR> sounds good to me
07:00:20 <nitrix> `class Functor (f :: * -> *) where` would allow f to be substitued by my type constructor Maybe, provided it implements the where clauses, which is fmap for functors.
07:01:14 <nitrix> fmap :: (a -> b) -> f a -> f b,   becomes   fmap :: (a -> b) -> Maybe a -> Maybe b
07:01:15 <nitrix> Brilliant :)
07:01:21 <quchen> I've got a testsuite for C code I'm including with my package. Is there a way I can make `cabal test` run that suite? It has no Haskell code at all, in particular no main function. I'd have to compile the suite with a C compiler and simply run the result.
07:03:32 <nh2> quchen: I don't think it can do that, in particular I don't think `cabal build` will build you C executables. Easiest might be to just write a Haskell executable for that test suite that shells out to build your C tests and run them
07:03:34 <nitrix> What is an example of a `* -> * -> *` ?
07:03:48 <quchen> nitrix: Either
07:03:51 <quchen> :k Either
07:03:52 <lambdabot> * -> * -> *
07:04:06 <nitrix> quchen: Takes twos types, build a new concrete type?
07:04:15 <quchen> nitrix: Exactly. (,) is another example.
07:04:36 <nitrix> :t (,)
07:04:36 <lambdabot> a -> b -> (a, b)
07:04:40 <quchen> nh2: That would be a suitable workaround, yes.
07:04:41 <quchen> :k (,)
07:04:42 <lambdabot> * -> * -> *
07:04:55 <nitrix> quchen: Oh, (,) as in tuples.
07:05:05 <nitrix> Makes sense.
07:05:18 <nitrix> quchen: Very appreciated
07:05:24 <EvanR> concrete type is a little wird
07:05:33 <EvanR> Maybe a is a concrete type?
07:05:51 <bernalex> EvanR: a concrete type is a *
07:05:51 <quchen> "Concrete type" = "has kind *" usually.
07:05:59 <EvanR> interesting
07:06:05 <co-arbelos> the other day i was wondering about how stuff like Maybe a fit into Hask
07:06:05 <rui3> m0rphism: thanks
07:06:06 <quchen> In other words, concrete types are the types that can have values.
07:06:22 <quchen> co-arbelos: Maybe Int is an object in Hask.
07:06:25 <bernalex> EvanR: so yeah Maybe Int is a concrete type. Maybe is otoh a type constructor, *->*, it needs a * to become a *.
07:06:35 <EvanR> i know Maybe Int is
07:06:38 <quchen> Or, in general, Maybe a is an object in Hask for any object a.
07:06:40 <EvanR> but "Maybe a"
07:06:55 <bernalex> EvanR: depends on a
07:07:02 <co-arbelos> quchen: so a is like a variable?
07:07:09 <EvanR> forall a . Maybe a, i guess this is like a function
07:07:11 <co-arbelos> you pick a
07:07:15 <bernalex> EvanR: a is just a variable. Maybe a could be nonsense for all I know.
07:07:19 <nitrix> Yeah, `a` is a type variable there.
07:07:52 <co-arbelos> but it can't be nonsense.. then "Nothing" would be nonsense as well
07:07:57 <quchen> EvanR: forall a. Maybe a is better known as ().
07:08:04 <bernalex> FireFly: I guess 'forall a . Maybe a' is ().
07:08:09 <nitrix> As long as its a variable, then you wouldn't have a concrete type I think.
07:08:10 <bernalex> uhm EvanR ^
07:08:17 <nitrix> EvanR: Maybe a isn't complete, Maybe Int is complete?
07:08:18 <bernalex> and anyway quchen was before me
07:08:30 <co-arbelos> nitrix: but what about Nothing?
07:08:40 <bernalex> co-arbelos: Nothing is a value not a type
07:08:47 <EvanR> i dont know complete, i was talking about concrete in the presence of a type variable but nevermind
07:09:15 <nitrix> co-arbelos: Nothing is a value, so talking about type completeness for it doesn't make sense.
07:09:40 <quchen> Nothing is more of an arrow in Hask. Or better, "const Nothing" is an arrow.
07:10:20 <co-arbelos> ok.. very weird
07:10:50 <bernalex> 'traverse (const Nothing)' is supposedly a useful idiom... anyway... off to play world of darkness. :-]
07:11:25 <quchen> The objects of Hask are types, the arrows are (generalized) values.
07:12:06 <EvanR> const Nothing is a polymorphic function, thats a single arrow?
07:12:39 <EvanR> again with the type variables
07:13:04 <quchen> EvanR: There are many "const Nothing" arrows in Hask, each one of them is a concrete implementation of "a -> Maybe b" for any a and b.
07:13:30 <EvanR> ok so its not precise to say const Nothing is /an/ arrow
07:13:33 <quchen> There is one "const Nothing" arrow from Int to Maybe String, one from (a->b) to Maybe (XmlHttpRequest a), …
07:14:02 <co-arbelos> so isn't that a bit inconsistent, since :t Nothing tells me that there would be a type called Maybe a.. which indicates the existence of such object in Haske
07:14:11 <co-arbelos> Hask
07:14:31 <EvanR> you can think of Maybe a being a family of types
07:14:49 <EvanR> not to be confused with type families
07:16:39 <co-arbelos> what if Nothing would be Maybe a with the uninhabited type replaced for a
07:17:12 <EvanR> that works
07:17:19 <EvanR> Maybe adds an element to any type, even Void
07:17:42 <co-arbelos> so the family analogy holds as well
07:17:42 <quchen> There is an arrow from Void to Maybe Void.
07:18:32 <quchen> (We're talking about PrettyHask where there are no bottoms here, of course. Bottom destroys everything.)
07:23:19 <EvanR> whats a good priority queue data structure?
07:23:43 <opqdonut> finger trees are nice
07:24:04 <opqdonut> see also http://stackoverflow.com/questions/6976559/comparison-of-priority-queue-implementations-in-haskell
07:24:07 <EvanR> so Data.Sequence
07:24:21 <nh2> EvanR: https://medium.com/@bttr/announcing-psqueues-8a0fe9fe939
07:25:16 <EvanR> opqdonut: wow
07:26:58 <EvanR> i like the comment "just plain Map which has a minView function"
07:27:58 <nh2> I believe that `psqueues` is the most recent one, and it contains performance comparisons with some of the other ones
07:29:27 <opqdonut> EvanR: yeah, a map is totally useable as a priority queue. you can replace it once you've profiled that it's a bottleneck
07:29:57 <EvanR> doing it
07:33:47 <dami0> hi guys. i'm trying to make a recursive function to reverse a list, but i'm not sure of the syntax, i tried (myReverse xs) ++ x, but it doesn't really work
07:34:11 <jmcarthur> what does "doesn't really work" mean?
07:34:12 <opqdonut> dami0: "++ [x]" is what you want
07:34:16 <jmcarthur> ah
07:34:20 <dami0> i get erros about infinite types
07:34:24 <jmcarthur> doesn't type check is what you meant
07:34:43 <opqdonut> dami0: ++ takes two lists, so you need to turn x into a list
07:34:45 <jmcarthur> :t (++)
07:34:46 <lambdabot> [a] -> [a] -> [a]
07:34:54 <dami0> it does get checked, the outcome isn't favourable :P
07:35:04 <dami0> opqdonut: thanks. 
07:35:34 * hackagebot ehs 0.7.0 - Embedded haskell template using quasiquotes.  http://hackage.haskell.org/package/ehs-0.7.0 (minpou)
07:35:37 <dami0> opqdonut: just for reference, is it possible to return the list using : instead of ++?
07:36:01 <opqdonut> dami0: not in this exact case, (:) is for prepending elements
07:36:16 <opqdonut> dami0: but it is possible to write reverse using only (:)
07:36:24 <dami0> opqdonut: ah, that is very good to keep in mind
07:36:30 <jmcarthur> dami0: if you keep an explicit accumulator you can
07:36:43 <opqdonut> jmcarthur: don't spoil it!
07:36:45 <opqdonut> :)
07:37:05 <jmcarthur> opqdonut: well i felt like what you were saying was actively misleading
07:37:14 <dami0> i think explicit accumulators are going to come in handy for the next question
07:37:16 <jmcarthur> oh i actually misread what you said
07:37:19 <jmcarthur> sorry
07:37:34 <opqdonut> dami0: working on some tutorial?
07:37:36 <jmcarthur> i read "it is [not] possible to write"
07:37:47 <dami0> https://wiki.haskell.org/99_questions/
07:38:03 <dami0> since i wasn't quite as impressed with learn you a haskell's questions/tutorials
07:38:20 <opqdonut> dami0: you might enjoy https://github.com/opqdonut/haskell-exercises
07:38:43 <dami0> on an unrelated note, how am i supposed to pronounce that?
07:39:03 <opqdonut> pronounce what?
07:39:28 <dami0> opqdonut
07:39:56 <opqdonut> oh, I don't even know myself, but I guess it might be "o.p.q. donut"
07:40:12 <EvanR> haha
07:40:22 <opqdonut> it's kind of a textual thing only :)
07:40:46 <EvanR> dr. andonuts
07:41:39 <Yaniel> oh hey opq
07:41:43 <opqdonut> hiya
07:43:43 <Yaniel> neat, I need to try those exercises
07:43:53 <rui3> "a type ty is ambiguious if and only if ((undefined :: ty) :: ty) would fail to typecheck"
07:43:56 <rui3> This language is weird
07:44:09 <Yaniel> my problem with haskell atm is I have nothing to write with it
07:44:20 <EvanR> try a video game
07:45:07 <Yaniel> I don't know enough for that
07:45:09 <opqdonut> I've written a bunch of small cgi applications in haskell for real world needs
07:45:15 <EvanR> rui3: how much fail could a typecheck check if a typecheck could fail to check
07:45:19 <Yaniel> and am working on one in c anyway
07:46:10 <EvanR> Yaniel: chicken and egg is annoying, you have to try to do things you dont know how to do in order to really learn to do them
07:46:33 <EvanR> good luck with C ;)
07:46:47 <SleepyPikachu> Does anyone have a good article on making your monad applicative?
07:50:08 <opqdonut> SleepyPikachu: every monad is an applicative functor
07:50:34 <opqdonut> SleepyPikachu: pure = return, <*> = ap
08:20:36 <avk> hello people, has someone ever used a hackage library to haskell data into a csv?
08:24:23 <ChristianS> avk: i don't understand your question
08:24:58 <avk> sorry
08:25:08 <avk> how do i export from haskell into a csv?
08:25:24 <EvanR> theres a package for that
08:25:40 <EvanR> Text.CSV
08:26:01 <avk> evan: I am not finding use cases of those packages and since i am new to haskell it is becoming impossible for me to use them!
08:26:19 <adamse> avk: I've used http://hackage.haskell.org/package/cassava
08:26:25 <jophish> How do people feel about sub 100% haddock coverage? I find it hard to sleep at night with that warning, but how helpful would a comment be on something like "type Author = Text"
08:26:37 <ChristianS> avk: yes, i've heard good things about cassava as well
08:26:56 <jmcarthur> jophish: i don't lose any sleep over it
08:27:16 <jmcarthur> jophish: i think it's more important that the documentation be thorough than that it have 100% coverage according to haddock
08:27:25 <jmcarthur> those are slightly different things :)
08:27:42 <jophish> I agree completely.
08:27:43 <avk> evan and chistian: could you please share a link of an example for these, it would be a great help!
08:27:45 <avk> :)
08:27:56 <jmcarthur> ideally the documentation is good both as an introduction and as a reference
08:28:07 <adamse> avk: the docs for cassava has examples, it is very simple to use http://hackage.haskell.org/package/cassava-0.4.2.2/docs/Data-Csv.html
08:28:12 <jmcarthur> and you should think about it from both points of view
08:28:23 <EvanR> resist the urge to make all percentages 100 that you see
08:28:34 <jmcarthur> also, if it's something you expect haskell beginners might want to use, you might have to make special considerations for them
08:29:15 <avk> adamse : thanks man
08:29:24 <avk> Thank you chirstian and evan :)
08:29:26 <jmcarthur> but no user of your documentation will ever know what that number is :)
08:30:06 <jophish> jmcarthur: Thanks for the wisdom!
08:35:57 <oiuh> @pl \x -> x - 1
08:35:57 <lambdabot> subtract 1
08:36:08 <oiuh> @pl \x -> x + 1
08:36:08 <lambdabot> (1 +)
08:39:18 <hop> Hello all, I am looking for a way to open a file from vim using only the filename. In C, I am using ctags appending files in the tag list and then using :ta bla.c to open it wherever it is in the hierarchy. Tag generators in haskell do not support it. What do you use for this task?
08:43:02 <hop> Basically, how do you browse a Haskell code base in vim? I am going to add file tags in hasktags but I am wondering what you guys are using.
08:48:27 <creichert> I really like codex which can generate hasktags for an entire cabal project. meaning, you can jump to a library definition
08:50:12 <hop> creichert: it seems to use hasktags. I think I am going to add file tags and propose a patch for hasktags
08:50:37 * hackagebot euler 0.8.0 - Mathematics utilities for Haskell  http://hackage.haskell.org/package/euler-0.8.0 (decomputed)
08:51:21 <creichert> cool, yeah I use hasktags as the tagger (which is awesome)
09:24:11 <mek42> why hasn't Google sued over Hoogle?
09:25:24 <phadej> why would they?
09:26:54 <mek42> they sued over chmoogle
09:27:13 <rui3> mek42: but that's different
09:27:27 <mek42> is it just because hoogle is not a domain name?
09:27:28 <rui3> That's all I am going to say about the subject
09:28:37 <int-e> also, chmoogle was a commerical enterprise, and they tried to register a trademark
09:29:32 <mek42> ah, ok, the trademark bit, that sort of makes sense i guess - thanks, didn't know that bit as I was just a chemist with less interest in IP law back then
09:48:58 <cfoch> hello, carter, are you cartazio ?
09:52:11 <quchen> cfoch: Carter Schonwald is his name.
09:52:26 <quchen> (At least that's what IRC says.)
10:10:05 <Yuras> hello, could anyone point me to authoritative reading about side effect tracking in type system?
10:13:21 <jmcarthur> Yuras: you mean you want to learn about IO? or are you looking for some more general survey of typed effects in a more language agnostic way?
10:13:35 <jophish> what's the most idiomatic way to get the head of a list (disregarding the partial function 'head'). At the moment I'm using '^? ix 0' from lens
10:13:55 <jmcarthur> jophish: i'd say it is highly context dependent
10:14:23 <cfoch> carter: https://github.com/haskell/cabal/pull/2436#discussion_r25695097
10:14:31 <Yuras> jmcarthur: I mean managing side effects via type system
10:14:40 <jmcarthur> Yuras: so the latter?
10:14:47 <Yuras> e.g. limiting what side effects are allowed
10:15:08 <jmcarthur> Yuras: is this a haskell question or a PL theory question?
10:15:17 <jophish> jmcarthur: I suppose you're right
10:15:41 * hackagebot stomp-queue 0.2.0 - Stompl Client Library  http://hackage.haskell.org/package/stomp-queue-0.2.0 (TobiasSchoofs)
10:16:19 <Yuras> jmcarthur: well, I'm interested in haskell-specific description, but more general theoretical description would be useful too
10:18:21 <bennofs> :t (^? _head)  -- if you already use lens
10:18:22 <lambdabot> Cons s s a a => s -> Maybe a
10:18:30 <jmcarthur> Yuras: haskell's way of controlling side effects is to make them first class values rather than something that just "happens" implicitly upon evaluation. we usually call these values "IO actions", and they will have types that look like "IO String" or "IO Int". the type parameter tells you what kind of result to expect when the effect is executed.
10:18:46 <bennofs> :t listToMaybe -- if you like minimal dependencies (in base)
10:18:47 <lambdabot> [a] -> Maybe a
10:18:55 <jmcarthur> Yuras: is this the kind of information you are looking for? still just trying to get an idea of what you know or don't know, what you want and don't want.
10:19:29 <bennofs> :t Safe.headMay -- from safe package, which is a bit smaller than lens as a dependency
10:19:30 <lambdabot> [a] -> Maybe a
10:19:48 <Yuras> jmcarthur: I'm working haskell dev, I want to improve my understanding of high level design in haskell
10:20:51 <Yuras> jmcarthur: in particular, how I should manage side effects, when I should make then explicit in types, and when I should not
10:20:54 <jmcarthur> oh, so you are looking for haskell idioms and tricks for managing effects, not some PL theory sort of thing or a mere intro to IO?
10:20:57 <jmcarthur> i see
10:21:45 <jmcarthur> i think this is a pretty common question, and i am not aware of a great resource to point you to
10:23:33 <jmcarthur> good general advice is that it's better to isolate your effects to as little code as possible. usually this means you have a thin IO shell and a bunch of non-IO code forming the core of your program.
10:23:48 <jmcarthur> some programs have thicker IO shells of course
10:24:22 <jmcarthur> but the view of a program as an IO shell around a non-IO core is typically helpful
10:24:51 <jmcarthur> another way to think of it is that your business logic is separated from your side effects
10:26:02 <jmcarthur> from an MVC point of view, IO is mostly limited to the View part
10:26:21 <jmcarthur> sometimes IO is used in the other parts, but in a limited way
10:26:34 <FreeFull> You can say Haskell has first-class IO
10:26:55 <FreeFull> You can manipulate IO actions just like everything else
10:27:12 <Yuras> jmcarthur: well, that doesn't work in my experience. Too often effects are implementation details and I feel that I should encapsulate them
10:27:32 <jmcarthur> FreeFull: It always confuses me when people say that Haskell isn't useful because it brushes effects aside. If anything, it brings them to the forefront.
10:29:00 <jmcarthur> Yuras: I think it comes down to rethinking that point of view and restructuring to fit the one I just described.
10:29:21 <EvanR> you can also have many thin IO shells communicating
10:30:21 <cognub> How long did it take you guys to be able to write usable programs when you were learning Haskell? I've gone through a programming couse at university level (with very little prior programming experience) and now I feel like I hardly understand how to use haskell. I am aware that you need a certain way of thinking and that it is mostly a matter of experience but I'm getting frustrated and it would be nice to have an estimation for how l
10:30:31 <Yuras> EvanR: that is much close to reality IMO
10:30:33 <jmcarthur> Yes. That is a reasonable way to tackle some of these cases where it seems like you need IO in the M or C parts of MVC.
10:30:53 <Yuras> *closer
10:31:19 <jmcarthur> cognub: We could give you anecdotal evidence, I but I feel like no matter what we say there is a risk of it being more frustrating if you are already frustrated.
10:32:45 <osfameron> cognub: if it helps: "Learning Haskell is easy. I've personally done it 5 times." from Larry Wall...
10:32:53 <jmcarthur> cognub: Practice makes perfect. It took me a couple months of solid spare-time practice to feel like I could write anything I wanted. I was already an experienced dev in other languages. Haskell clicked especially well for me, perhaps better than it does for most people who are first learning it. I don't think this is very helpful information.
10:33:09 <FreeFull> Prolog is trickier than Haskell
10:34:31 <c_wraith> Haskell was easily the hardest time I've ever had learning a language - but that's because it was the first language I learned that was different from everything else in an important way.  (And that way was the type system - immutability and recursion were no trouble for me)
10:34:40 <geekosaur> likewise, it took me a couple months to start doing useful things with Haskell --- but I am very much NOT normal in this regard, both in terms of experience and ... well, my brain works in strange ways
10:35:39 * glguy was born with a silver Haskell spoon in his mouth
10:35:44 <f|`-`|f> There's another MVC like model that's a bit more interoperable because it keeps everything agnostic
10:35:49 <quchen> Learning Haskell consists of 3 major phases. 1: fighting the type system, 2. getting along with it, 3. using it to do great things. Phase 1 is awkward, but curiosity keeps people overcoming it.
10:35:51 <f|`-`|f> MVA?
10:35:56 <geekosaur> one thhing from my eperience that may be helpful, though: I started out with xmonad, where I already knew most of what was going on because I have a good understanding of X11. likewise, if you start with something you know well outside of Haskell, it can make it easier to learn how to do it in Haskell
10:36:14 <EvanR> 4. not being able to function without it
10:36:16 <hop> creichert: I just proposed a patch for hasktags. I looked at Codex. It just looks awesome. Thanks for it. I was not aware of it!
10:36:17 <f|`-`|f> My issue is that I simply have no idea what to do, the type system isn't a tough fight, but similarly foreign
10:36:25 <exio4> EvanR: I'd say that happens in 2. 
10:36:33 <geekosaur> (sadly this probably doesn't work for things like web frameworks where the levels of abstraction complicate things in different ways)
10:36:37 <FreeFull> EvanR: Somehow I abandoned Haskell at some point
10:36:37 <EvanR> ah
10:36:47 <cognub> osfameron: that was pretty funny, though I'm not thinking about the time untill I "master" haskell, I understand that is a pretty unreasonable thing to ask, I was thinking about getting good enough to make something useable.
10:37:49 <quchen> cognub: It took me half a year of unfocused on-and-off learning to be able to write useful programs, and another six months until I declared it my main language. But that's just my personal story. It's really hard to measure how much time I invtested at any point in time.
10:38:02 <FreeFull> Right now, my main language is Rust
10:38:36 <geekosaur> also I do not claim to have mastered Haskell. I'm not sure anyone can; it grows and expands quickly :)
10:38:36 <FreeFull> At one point back when I was still using Haskell, I forgot how to even write imperative programs
10:38:43 <quchen> cognub: You can probably become pretty decent in a matter of 1-2 months when you're in the right environment (such as a team that can help you all the time, and you have a specified goal to work for)
10:39:39 <quchen> FWIW learning Haskell took me as long as learning PHP using that metric, except that PHP still sucked after a year.
10:41:43 <f|`-`|f> That's php
10:42:41 <cognub> jmcarthur & geekosaur: That is nice to hear, I am one of the few people in our course that felt like I understood what I was writing and reading right away but I also feel like I didn't know at all what to expect. It's not like learning a new language where you can usually see howw long other people take to become fluent-
10:43:36 <mek42> I don't get why people talk about struggling with type system - is this because I learned to program in pascal and C?
10:44:22 <f|`-`|f> probs
10:44:48 <mek42> Figuring out how to do certain things purely functional, yes, that can be mentally challenging.  But I'm used to everything needing an explicit type.
10:44:56 <exio4> mek42: the type system forces you to be explicit in more than one thing, that other languages either leave implicit, or would error at runtime 
10:44:58 <c_wraith> mek42: No.  It means that approximately zero mainstream languages have nothing like higher-kinded types
10:45:06 <c_wraith> err, *something* like
10:45:07 <exio4> and that, too :P
10:45:31 <c_wraith> mek42: Understanding how higher-kinded types fit together is necessary for following a ton of haskell abstraction
10:45:36 <mek42> Oh, ok, well, just starting to learn, so maybe I'll get the struggle later.
10:45:45 <quchen> mek42: PHP will happily eat most nonsense you hand it, and you'll see your program misbehaves somehow. You search your bug, you find out that you messed up, you fix your bug. GHC will be quite different: it will refuse to do anything because something's wrong. You may think you didn't make a mistake, but the compiler just says "no". You have to find the error and fix it. In the PHP case, you are confronted with your own mistake. I
10:45:45 <quchen> n the GHC case, you're confronted with the compiler (and then your mistake).
10:45:59 <quchen> The first impression is that a valid program can't be run in Haskell.
10:46:01 <Ferdirand> well, if you grok c++ templates...
10:46:59 <mek42> oh, I've never done PHP
10:46:59 <mniip> TIL what point-free actually means
10:47:05 <mniip> etymologically
10:47:08 <jmcarthur> i think a lot of people aren't used to type systems with such composable type expressions.
10:47:36 <cognub> Quechen: Thank you, I have a goal to work for (though it is a very broad goal, we have an AI course during the next half of the semester) and people who I can ask, I don't think that time will be enough for me but it's good to see how other people have fared before.
10:48:22 <jmcarthur> think of what a dependently typed language's type system looks like to a haskeller and you might approximate what haskell's type system looks like to a developer used to more mainstream languages.
10:48:39 <jmcarthur> or, rather, not what the type systems look like but what it's like to use them
10:49:00 <fr33domlover> johnw, hello
10:49:29 <c_wraith> jmcarthur: I like how dependent types look.  I just don't like writing all the proofs to use them. :)
10:49:54 <phaul> I still remember this http://ircbrowse.net/browse/haskell?id=15287171&timestamp=1362768829#t1362768829
10:50:01 <jmcarthur> c_wraith: exactly. haskell requires developers to understand their types more than they are used to.
10:51:23 <geekosaur> there's also a certain amount of logic thinking involved in figuring out type unification; it's not so different from unification in Prolog
10:51:24 <c_wraith> I've always thought in terms of types, even when doing non-programming stuff, long before I learned Haskell.  The trick when learning haskell was learning to abstract across types with kinds other than *.  That took some time.
10:51:30 <osfameron> caring about types really changes your programming style when you return to your previous languages
10:51:45 <geekosaur> so if you've worked with Prolog then you have a leg up on figuring out how types interact
11:11:57 <rui3> Any quick way in ghci to check how some type synonym is being interpreted?
11:12:49 <EvanR> :info Foo
11:15:44 * hackagebot eternal 0.1.1 - everything breaking the Fairbairn threshold  http://hackage.haskell.org/package/eternal-0.1.1 (Heather)
11:16:21 <Rembane> Oo
11:16:22 <shachaf> That depends on what that means.
11:20:44 * hackagebot feed-crawl 0.1.0.0 - Feed crawling utilities  http://hackage.haskell.org/package/feed-crawl-0.1.0.0 (DanielChoi)
11:26:44 <tmobile> \quit
11:26:50 <pacer> I'm taking my first steps with Haskell and I have a really dumb question. 
11:27:01 <Cale> pacer: Go for it :)
11:27:09 <pacer> Starting with type defs, I see arrows everywhere. 
11:27:30 <pacer> Reading the wiki, I see stuff about them being monoids, etc etc
11:27:40 <pacer> But how should I read them? What are they doing?
11:28:07 <Cale> pacer: Are you talking about the -> in types like  length :: [a] -> Int  ?
11:28:08 <silver> by arrows you mean ->?
11:28:14 <Cale> pacer: A -> B means the type of functions which accept an argument of type A, and produce a result of type B
11:28:17 <pacer> Exactly
11:28:48 <Cale> pacer: -> is defined to associate to the right, so when you see  A -> B -> C  it means  A -> (B -> C)
11:29:12 <Cale> similarly, when you write function applications like  f x y  they associate to the left, so that's  (f x) y
11:29:21 <breadmonster> Cale: Is there a good tutorial on Data.Arrow?
11:29:40 <Cale> breadmonster: Do you mean Control.Arrow?
11:29:47 <jophish> bennofs: Thanks, I'll see which looks nicest!
11:30:04 <breadmonster> Cale: Yup :P
11:30:45 * hackagebot texmath 0.8.0.2 - Conversion between formats used to represent mathematics.  http://hackage.haskell.org/package/texmath-0.8.0.2 (JohnMacFarlane)
11:31:12 <Cale> breadmonster: Maybe one of Hughes' papers?
11:32:01 <Cale> breadmonster: like http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf
11:32:14 <Cale> pacer: anyway, does that explanation of the function type help at all?
11:32:25 <Cale> pacer: I could probably say more :)
11:32:25 <pacer> Cale, I think so. 
11:33:05 <Cale> So, the functions in Haskell which look like they take multiple arguments are really functions that take one argument, and produce another function to take the next, and so on.
11:33:13 <pacer> I need to play with it, get my hands dirty. 
11:33:22 <pacer> Oh that's an interesting fact. 
11:33:26 <EvanR> also, thats what they look like
11:33:30 <EvanR> A -> B -> C -> D ;)
11:33:30 <Cale> which is why you'll see things like A -> B -> C -> D  for the type of a function which takes three arguments of types A, B, and C, to produce a result of type D
11:33:47 <Cale> That means A -> (B -> (C -> D))
11:34:26 <Cale> and so if f :: A -> B -> C -> D, and you write f x y z, function application associates to the left to help preserve the illusion, so that means ((f x) y) z
11:34:47 <Cale> f x :: B -> C -> D
11:34:51 <Cale> f x y :: C -> D
11:34:55 <Cale> f x y z :: D
11:35:06 <Cale> (supposing that x :: A, y :: B, and z :: C)
11:36:09 <pacer> Oh, that makes the left associativity make sense. 
11:36:18 <pacer> I see! I think. 
11:36:20 <Cale> > let { add :: Int -> Int -> Int; add x y = x + y;  addOne :: Int -> Int; addOne = add 1 } in addOne 10
11:36:21 <lambdabot>  11
11:38:45 <pacer> So Cale, is this what makes partial application of a func work?
11:39:03 <Cale> Yeah
11:39:57 <pacer> Thanks for your time, that's really cool and helpful. 
11:40:08 <Cale> > words "here are some words"
11:40:09 <lambdabot>  ["here","are","some","words"]
11:40:15 <Cale> > reverse (words "here are some words")
11:40:16 <lambdabot>  ["words","some","are","here"]
11:40:31 <Cale> > map reverse (words "here are some words")
11:40:32 <lambdabot>  ["ereh","era","emos","sdrow"]
11:41:46 <Cale> > map (map reverse) [words "here's one list of words", words "here is another"]
11:41:47 <lambdabot>  [["s'ereh","eno","tsil","fo","sdrow"],["ereh","si","rehtona"]]
11:42:51 <Cale> It tends to be very convenient when working with higher order functions to be able to apply a function to fewer than the maximum number of arguments in order to obtain another function.
11:42:57 <breadmonster> Cale: Can I use the arrow from Unicode instead of -> in function declarations?
11:43:09 <Cale> breadmonster: If you turn on UnicodeSyntax
11:43:56 <breadmonster> How do you do that?
11:44:06 <breadmonster> {-# XUnicodeSyntax #-}?
11:44:17 <Cale> {-# LANGUAGE UnicodeSyntax #-}
11:44:52 <breadmonster> What about turning on OverloadedStrings/
11:44:54 <breadmonster> ?
11:45:01 <Cale> similar
11:45:06 <cwr> Has anyone built soegtk recently?  It blows up when building glib with an "unrecognised option" error, though it used to build a year or so ago.
11:45:14 <Cale> You can separate them by commas in the same LANGUAGE pragma
11:45:43 <Cale> cwr: Which option is unrecognised?
11:46:48 <cwr> Cale: --sysconfdir=/opt/cabal/etc
11:49:05 <Cale> Uh... that's a weird message
11:49:18 <Cale> Do you have stale intermediate files hanging around?
11:49:41 <cwr> Cale: I doubt it - where would I look?
11:50:31 <mniip> why did they name the category Hask so?
11:50:36 <mniip> shouldn't it be called *?
11:50:53 <cwr> Cale: the full error is: Linking dist/setup-wrapper/setup ... unrecognized option `--sysconfdir=/opt/cabal/etc'
11:51:01 <Cale> mniip: * would be a pretty unhelpful name in a general context
11:51:26 <Cale> mniip: and it's common to name categories with abbreviated versions of the structures that inhabit them
11:51:38 <Cale> e.g. the category of groups is often called Grp
11:51:46 <breadmonster> Cale: Do you have a PhD or something?
11:51:50 <Cale> and the category of topological spaces is called Top
11:52:01 <Cale> breadmonster: No, just a BMath in pure mathematics from Waterloo
11:52:09 <breadmonster> Cale: That's pretty cool.
11:52:30 <Cale> cwr: hmm
12:03:16 <rui3> Each module declares its own extensions, right?
12:03:36 <rui3> You are not automatically using some language extension because you are importing a module that does, right?
12:03:44 <HeladoDeBrownie> rui3, that's right.
12:03:59 <HeladoDeBrownie> although extensions can also be enabled "globally" for a project
12:04:15 <rui3> HeladoDeBrownie: Great, thanks
12:04:19 <HeladoDeBrownie> (in cabal)
12:08:56 <mniip> Cale, why sum types, I like the name "coproduct" more :(
12:09:38 <Cale> coproduct and sum are pretty much interchangeable terms
12:09:48 <mniip> I was just nitpicking
12:10:35 <EvanR> sum is shorter
12:10:46 <HeladoDeBrownie> let's just compromise by calling them coproduct and cosum
12:11:00 <EvanR> not everything needs to be uncoswapped
12:11:04 <mniip> copromise
12:11:31 <shachaf> Some kinds of types are the kinds of types / That sums are all about; / And some kinds of types are the kinds of types / We all can do without.
12:11:35 <Cale> In a cocategory, do the arrows have co-domains and co-codomains?
12:11:53 <Cale> (coarrows)
12:12:05 <nh2> what's a good way to keep a value alive / from being GCd? I have a `ref :: IORef` in scope with a `mkWeakIORef` finalizer attached, and I want it to NOT be garbage collected before I run `() <- receiveDone :: IO ()`
12:15:20 <jmcarthur> Cale: it makes sense if the "co"s cancel out at least
12:15:39 <Adeon> nh2: I've used a function that `seq`s the IORef and a NOINLINE pragma for good measure on it which seems to work
12:16:06 <Cale> It's actually the wrong way around, the "object like things" have "arrow like things" associated to them by the cosource and cotarget maps
12:16:08 <Adeon> touchIORef :: IORef a -> IO ()   touchIORef !_ = return ()    {-# NOINLINE touchIORef #-}
12:16:12 <jmcarthur> nh2: ghc has a touch primitive somewhere. it might even be available for weak pointers
12:16:27 <jmcarthur> it's not what Adeon just did
12:16:39 <mniip> Cale, coobjects nnect coarrows together
12:16:59 <mniip> there's also a mposition for any two coobjects
12:17:19 <nh2> Adeon: good idea, but I'm a bit worried that dead code elimination / the simplifier will optimize that out, independent from inlining
12:17:28 <shachaf> Cale: class Uncategory p where { unid :: p x x -> p b a; uncompose :: (p y e -> p b a) -> (p e x -> p b a) -> p y x -> p b a } is clearly the true dual of Category.
12:17:55 <Adeon> I can only say that it has not failed for me but yeah obviously it's a hack
12:17:56 <jmcarthur> nh2: well, there's this: http://hackage.haskell.org/package/primitive-0.5.4.0/docs/Control-Monad-Primitive.html#v:touch
12:18:10 <jmcarthur> nh2: it wraps GHC's touch# primitive
12:18:15 <shachaf> (Expressing it as p b a -> Either (p b x) (p x a) doesn't work, though. Maybe that's more useful nonconstructively, or in another context.)
12:18:18 <nh2> jmcarthur: excellent
12:18:29 <nh2> Adeon, jmcarthur: Thanks you two!
12:19:01 <rui3> I just installed a newer version of GHC with nix package manager, and I have both old (yum version) and new (nix) now
12:19:35 <rui3> The packages I had installed aren't seen by the new one
12:20:04 <Cale> You have some sets C_0 and C_1, and functions s,t: C_0 -> C_1, and then epsilon: C_1 -> C_0 such that epsilon . s = id, and epsilon . t = id (i.e. the coidentity), and then  Delta : C_1 -> C_1 +_{C_0} C_1, the co-composition
12:20:05 <jmcarthur> rui3: yeah they will have to built and registered with the new one
12:20:05 <horny-sama> http://www.fpaste.org/198262/64468901/ for this function x `mod` 2 == 0, x `mod` 3 == 0 the comma means or?
12:20:06 <shachaf> Cale: (This is like comparison in http://ncatlab.org/nlab/show/apartness+relation )
12:20:18 <EvanR> is there a type or class for invertible functions
12:20:34 <nh2> rui3: I'd recommend against enabling extensions globally for a cabal project in a cabal file, it breaks external programs like haskell-source-exts based tools
12:20:44 <jmcarthur> horny-sama: more like and
12:21:02 <rui3> nh2: only sandboxes, downloading all dependencies for every project?
12:21:04 <horny-sama> jmcarthur: that's what I thought too
12:21:05 <jmcarthur> > [ x | x <- [1..], x `mod` 2 == 0, x `mod` 3 == 0]
12:21:07 <lambdabot>  [6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96,102,108,114,120,126,132,138,...
12:21:16 <horny-sama> okay
12:21:17 <horny-sama> got it
12:21:23 <nh2> rui3: was that message meant for me?
12:21:37 <mniip> horny-sama, hey!
12:21:43 <paxcoder> horny-sama, here's the #haskell channel
12:22:05 <mniip> horny-sama, boolean predicates in list comprehensions behave just like 'guard'
12:22:11 <horny-sama> still because we are in a haskell channel we can't assume people in here are familiar with haskell
12:22:12 <horny-sama> :P
12:22:16 <rui3> nh2: yes. If you didn't understand it may mean the question was stupid. Do you suggest using a cabal sandbox for every project? and does that imply downloading every dependency for every sandbox?
12:22:23 <mniip> every next predicate filters what is left by the previous
12:22:27 <mniip> if that makes sense
12:22:52 <nh2> rui3: ah, I thought it was related to me saying that I recommend against enabling language extensions in cabal files?
12:22:57 <paxcoder> horny-sama, so what the guy's saying is that you can treat it as an and
12:22:58 <paxcoder> not an if
12:23:00 <paxcoder> *or
12:23:08 <horny-sama> ok
12:23:11 <paxcoder> *as an and, not an or
12:23:41 <mniip> > do { x <- [1..]; guard $ x `mod` 2 == 0; guard $ x `mod` 3 == 0; return x }
12:23:42 <lambdabot>  [6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96,102,108,114,120,126,132,138,...
12:23:46 <rui3> nh2: ah, I had misread you and thought of "language extensions" as packages
12:23:50 <rui3> Sorry
12:25:11 <Ralith> Are tryhaskell/lyah still the recommended places for a complete beginner to start?
12:25:12 <paxcoder> horny-sama, mniip, that's cool btw. being locked into monads isn't, though i understand what it's for
12:25:51 <mniip> paxcoder, who locked you into monads
12:26:03 <jmcarthur> monads are not for being locked into :)
12:26:16 <nh2> rui3: no worries. To answer your question: cabal does cache downloads across sandboxes (in the ~/.cabal directory), so if two sandboxes need the same package, you'll only download it once. But it will compile them once for each sandbox, and the compiled files will be stored in the sandbox, taking disk space (that can be a few hundred megabytes of object files, depending on how many dependencies you have). I personally don
12:26:20 <monochrom> tryhaskell is fun, but see https://github.com/bitemyapp/learnhaskell for what to read and do
12:27:00 <paxcoder> Ralith, This is the next step http://dev.stephendiehl.com/hask/ (I'd put a winking smiley here, but I'm not joking)
12:27:25 <monochrom> lyah was fun, but it is too long for a whirlwind tour, and too shallow and vague for a non-whirlwind-tour
12:27:27 <paxcoder> mniip, all sideeffecting functions
12:27:29 <Cale> Ralith: A lot of people seem to be enjoying Brent Yorgey's CIS 194 course
12:27:42 <Cale> http://www.seas.upenn.edu/~cis194/fall14/spring13/index.html
12:28:29 <horny-sama> http://www.fpaste.org/198264/64474471/ <--- I don't understand how the function prototype is (Ord a) => a->a->a->Bool instead of we cannot determine the type of this function
12:29:17 <Cale> horny-sama: That's what type classes let you do :)
12:29:37 <jmcarthur> horny-sama: so the type of (<=) is Ord a => a -> a -> Bool. type inference will determine that the type of that function will be a -> a -> a -> Bool, then Ord the constraint will be added on because a is known to be constrained by Ord.
12:29:41 <horny-sama> Cale: I get the last part where it should be bool
12:29:47 <horny-sama> but the rest is like ...
12:29:48 <Cale> horny-sama: Type classes allow you to define polymorphic functions simply by using type class polymorphic functions
12:30:14 <monochrom> it has determined to the point "the type needs to be an instance of Ord". and really, there is no further requirement, even by my opinion
12:30:16 <paxcoder> horny-sama, what test are you solving?
12:30:23 <m0rphism> rui3: how are you installing your dependencies? I assume either cabal or cabal-dev?
12:30:24 <horny-sama> paxcoder: mock exam
12:30:27 <horny-sama> I have the answer
12:30:30 <Cale> This says that for any type a, if a is an instance of Ord (i.e. it's a type which supports (<=) comparison on its elements among other operations), then func may have type a -> a -> a -> Bool
12:30:30 <horny-sama> just not sure why
12:30:43 <horny-sama> Cale, jmcarthur why not eq instead of ord
12:30:46 <Ralith> Cale: thanks
12:30:52 <paxcoder> horny-sama, is it public?
12:30:54 <rui3> m0rphism: well, I haven't installed any since nix, but yes, cabal
12:30:56 <Cale> horny-sama: Because we used (<=) and not just (==)
12:30:56 <horny-sama> what does ord and eq mean anyway
12:30:57 <monochrom> ok, exam study time is too late for learning the why.
12:31:03 <jmcarthur> horny-sama: because Eq only gives you (==) and (/=), not (<=)
12:31:08 <Ralith> remind me, is RWH appropriate for a complete novice?
12:31:14 <rui3> m0rphism: Any tips on how should I do it now? How to tell cabal what ghc to get it for?
12:31:20 <jmcarthur> horny-sama: Eq is for equivalence relations. Ord is for ordering relations.
12:31:28 <paxcoder> monochrom, you don't know that. horny-sama may be a math major. or have an iq of 180
12:31:30 <Cale> Ralith: It's supposed to be, I'm not sure if it is.
12:31:35 <Ralith> kk
12:31:51 <jmcarthur> monochrom: it's what i always did
12:31:52 <horny-sama> I know what -> means but not <=
12:31:58 <horny-sama> paxcoder: I am just a sucker in disneyland
12:32:25 <paxcoder> horny-sama, i did not get that reference. Are you being taken for a ride somehow?
12:32:31 <jmcarthur> horny-sama: (<=) is just the "less than or equal" operator
12:32:31 <Hijiri> <= is less than or equal
12:32:34 <jmcarthur> like in C or whatever else
12:32:40 <horny-sama> ok
12:35:17 <horny-sama> http://www.fpaste.org/198265/64478971/ <--- I thought high order function means a function that makes in a function as input therefore the answer should be all of the above but i was wrong anyone want to enlighten me
12:35:53 <HeladoDeBrownie> horny-sama, write out their types
12:35:57 <monochrom> where is the complete exam on the web?
12:36:09 <horny-sama> paxcoder: it is a reference from the movie sowrdfish
12:36:29 <m0rphism> rui3: this might have to do with the default nix ghc version being a wrapper around ghc. It is intended to be used by installing the hackage libraries also via nix instead of cabal.
12:36:32 <monochrom> f2 doesn't use any argument as functions
12:36:39 <paxcoder> anyweh cya
12:36:59 <HeladoDeBrownie> horny-sama, that said, i'd say "higher-order function" is less of a useful term in haskell since there are so many of them; in other languages i've heard it used to mean "a function with a function as input *or* output"
12:37:12 <m0rphism> rui3: When you run `nix-env -q` how is the ghc package named?
12:37:26 <horny-sama> any haskell comrade here?
12:37:32 <HeladoDeBrownie> horny-sama, anyway, there's exactly one of those with a function as an input
12:38:07 <horny-sama> HeladoDeBrownie: I can't really talk
12:38:14 <horny-sama> the answer says it should be a 
12:38:17 <horny-sama> and I was like wtf
12:38:33 <HeladoDeBrownie> horny-sama, … you can't talk? then why are you asking this?
12:38:56 <horny-sama> HeladoDeBrownie: typo
12:39:22 <horny-sama> I don't really tell tell what the answer should be but according to the answer sheet the answer is a
12:39:28 <horny-sama> I don't really tell what the answer should be but according to the answer sheet the answer is a
12:39:37 <arkeet> for each of those functions:
12:39:38 <HeladoDeBrownie> horny-sama, do you know how to deduce the type of something?
12:39:42 <arkeet> which arguments are functions?
12:39:46 <mmachenry> I'm having trouble adapting to Applicative parsers from the land of Lex and Yacc. I'm going through Write Yourself a Scheme and I've gotten to the point where the exercises having me adding numbers like "#x10" for hexadecimal. This is failing because the "#t" parser eats up the "#". http://lpaste.net/125883
12:40:00 <mmachenry> The tutorial hasn't taught "try" yet but I think I'm supposed to do that anyway.
12:40:06 <horny-sama> HeladoDeBrownie: with 40% successful rate
12:40:07 <horny-sama> :P
12:40:16 <SleepyPikachu> I have a function (String -> IO ()) and the type of my function is some other monad () how do I run the IO computation and then return ()?
12:40:41 <monochrom> mmachenry: yes, I would consider "try", too. but it is not the only way.
12:40:45 <mmachenry> I'm not totally sure where to add the try to make this work.
12:40:58 <HeladoDeBrownie> horny-sama, tell me what you think the type of a should be
12:41:05 <kadoban> SleepyPikachu: What do you mean that the type of your function is a monad, exactly?
12:41:17 <HeladoDeBrownie> horny-sama, feel free to think aloud
12:41:29 <SleepyPikachu> kadoban: Sorry, I'm not familiar with the terminology.
12:41:29 <mmachenry> monochrom: I could potentially left-refactor my entire parser I guess but that seems strange that the tutorial would lead me down that path only to make me left refactor in an exercise, right?
12:41:37 <jmcarthur> horny-sama: can you identify which arguments are functions? try doing that
12:41:50 <horny-sama> HeladoDeBrownie: a->a->a->a?
12:41:59 <HeladoDeBrownie> horny-sama, why's that?
12:42:13 <horny-sama> jmcarthur: I can't identify the arguments that are functions
12:42:25 <HeladoDeBrownie> horny-sama, one way to identify what ought to be a function: only functions can be applied
12:42:27 <jmcarthur> oh sorry, i don't mean to make you do something while HeladoDeBrownie is having you do this differently
12:42:35 <HeladoDeBrownie> jmcarthur, i think that's a good idea actually
12:42:43 <JagaJaga> Have a function that accepts IOException. Where I can get them or smth like that? :/
12:42:55 <kadoban> SleepyPikachu: Maybe just specify more, especially with the actual types you're talking about.
12:43:13 <horny-sama> the function type should be a->b->c->then I am lost
12:43:28 <HeladoDeBrownie> horny-sama, by what means did you come up with that type?
12:43:42 <jmcarthur> horny-sama: why do you believe the answer is all of the above if you cannot identify which arguments are functions?
12:44:13 <horny-sama> jmcarthur: coz the answer none of the above is available
12:44:16 <jmcarthur> horny-sama: we are trying to get you to think for systematically and carefully
12:44:22 <SleepyPikachu> kadoban: Just working on an lpaste to illustrate my question
12:44:24 <horny-sama> none of the above is my answer
12:44:25 <horny-sama> :P
12:44:27 <jmcarthur> oh
12:44:34 <lpaste> SleepyPikachu pasted “No title” at http://lpaste.net/125884
12:44:43 <mmachenry> monochrom: I thought putting "try" around "parseAtom" figuring that would cause it to not suck up my "#" but it doesn't work.
12:44:45 <HeladoDeBrownie> horny-sama, you said before "all of the above"
12:44:56 <mmachenry> Removing parseAtom from that expression makes it work though.
12:45:13 <jmcarthur> horny-sama: okay, let's look at the choices one at a time.   f1 x y z = x y + x z.  the arguments are x, y, and z. which ones appear to be used as though they are functions?
12:45:19 <horny-sama> HeladoDeBrownie: I said all of the above knowing that none of the above is incorrect coz it is not an option offer
12:45:46 <monochrom> mmachenry: to tell you the truth, I would have one single parser that does all literals. (it calls many little helper parsers, but that's an implementation detail.) it is the only parser that cares about and eats "#". after eating "#", of course it has to do some conditional branching based on "x" vs "t" etc. but the point is I don't have two alternatives competing for "#"
12:45:46 <horny-sama> jmcarthur: x?
12:45:46 <HeladoDeBrownie> horny-sama, can you identify any where there is definitely not a function as input?
12:45:50 <horny-sama> coz it is reused?
12:45:57 <horny-sama> HeladoDeBrownie: no
12:46:00 <JagaJaga> Looking in Control.Exception.Base, but there is no constructors for IOException...
12:46:02 <jmcarthur> horny-sama: not because it is reused, though x is the correct argument
12:46:24 <benjamin__> hey folks, was wondering if you guys could give me some naming advice
12:46:27 <horny-sama> jmcarthur: then how can you tell it is a function
12:46:27 <HeladoDeBrownie> horny-sama, what did i say that you can do with functions and nothing else?
12:46:33 <jmcarthur> horny-sama: it's because it is being *applied*. it occurs on the left side of an application (that is, whitespace)
12:46:41 <benjamin__> Here's my function which I can't think of a good name for:
12:46:43 <kadoban> SleepyPikachu: Unless I'm confused, I don't think that function you're trying to write is possible. It would have to be in an IO context.
12:46:45 <jmcarthur> horny-sama: for example, (x y) is x applied to y
12:46:48 <benjamin__> qUnfold :: (a -> (b, [a])) -> Queue a -> [b]
12:47:02 <horny-sama> so it is read x    y + x   z
12:47:04 <benjamin__> qUnfold f = unfoldr (fmap g . qpop) where g (x, q2) = fmap (foldr qpush q2) (f x)
12:47:06 <horny-sama> not xy+xz?
12:47:18 <HeladoDeBrownie> horny-sama, ((x y) + (x z))
12:47:23 <jmcarthur> horny-sama: it is read   "(x applied to y) plus (x applied to z)"
12:47:32 <monochrom> JagaJaga: at this stage, you probably should read my exception tutorial http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml
12:47:49 <horny-sama> I thought it meant x times y
12:47:56 <JagaJaga> monochrom: ty, gonna read.
12:47:56 <HeladoDeBrownie> jmcarthur, i'll let you take over, i'm mostly repeating what you're saying now
12:48:03 <arkeet> times is *
12:48:04 <jmcarthur> HeladoDeBrownie: oh, i was going to go soon
12:48:09 <SleepyPikachu> kadoban: Ok
12:48:09 <HeladoDeBrownie> jmcarthur, all right then
12:48:11 <benjamin__> so qUnfold unfolds a list by repeatedly popping an item off a queue
12:48:17 <jmcarthur> HeladoDeBrownie: so i'll hop out instead
12:48:23 <HeladoDeBrownie> jmcarthur, okay. have fun
12:48:37 <horny-sama> okay so it is not like math xy means x times y
12:48:38 <horny-sama> okay
12:48:40 <benjamin__> and then using f to get some more items to push onto the queue
12:48:49 <benjamin__> and you're finished unfolding when the queue is empty
12:48:57 <HeladoDeBrownie> horny-sama, right, putting an expression next to another with space in between is function application in haskell.
12:49:13 <benjamin__> What do you think is a good name for such a function? i called it qUnfold but i don't think it really is an unfold
12:49:22 <horny-sama> HeladoDeBrownie: got it
12:49:27 <benjamin__> that name would suggest to me that it returns a queue
12:49:28 <horny-sama> I need a better class
12:49:32 <horny-sama> *glass
12:49:39 <horny-sama> can't see the space
12:49:40 <horny-sama> :P
12:49:58 <HeladoDeBrownie> horny-sama, so, now that you know that, in which of those functions is an argument applied to something?
12:50:09 <horny-sama> HeladoDeBrownie: a
12:50:15 <HeladoDeBrownie> horny-sama, just a? are there any others?
12:50:39 <horny-sama> HeladoDeBrownie: no
12:50:43 <HeladoDeBrownie> horny-sama, correct.
12:50:45 <horny-sama> since the rest is multiplication 
12:51:01 <horny-sama> time to grab icecream now
12:51:01 <horny-sama> :P
12:51:05 <HeladoDeBrownie> have fun
12:51:14 <SleepyPikachu> kadoban: Is there an IO transformer?
12:51:53 <Cale> SleepyPikachu: no
12:52:14 <derekv2> what would you think I meant if I said I wanted to build a "gateway api" ... i'm struggling with the terminology here
12:52:22 <benjamin__> lpaste of the function i can't come up with a name for: http://lpaste.net/125885
12:53:07 <monochrom> derekv2: every API is a gateway. therefore, you simply mean "API".
12:53:12 <derekv2> ? -- or put another way, what would you call a server that primarily forwarded/transformed/coordinated calls and responses from multiple backend APIs for the client 
12:53:46 <HeladoDeBrownie> derekv2, a proxy server?
12:53:50 <shachaf> benjamin__: Well, I don't know what Queue is, but it looks like some sort of unfold.
12:53:54 <benjamin__> @derekv2 a Facade?
12:53:54 <lambdabot> Unknown command, try @list
12:53:55 <monochrom> receptionist
12:54:05 <Cale> derekv2: What context?
12:54:23 <benjamin__> shachaf an unfold suggests to me that it would return a queue
12:54:52 <benjamin__> i'm not entirely happy with qUnfold as a name because it doesn't return a queue
12:54:54 <derekv2> HeladoDeBrownie: benjamin__  technically I'd go for either one of those names but it's no good trying to google for them, I get totally other stuff
12:55:25 <HeladoDeBrownie> derekv2, "proxy server" is a fairly common term; if what you're talking about doesn't fit what you found searching the web, it likely isn't what you're talking about.
12:55:26 <monochrom> it folds a queue and unfolds a list
12:55:27 <shachaf> Oh, maybe I misread it a bit.
12:55:48 <benjamin__> monochrom Yes, almost
12:55:54 <benjamin__> but i think it's not exactly a fold of a queue
12:56:05 <shachaf> It does what monochrom said. The "(a -> (b, [a])) -> [b]" part is like an odd list unfold.
12:56:06 <monochrom> but no one speaks of "popping and pushing" for a queue. that's for a stack.
12:56:14 <benjamin__> it's more like it uses the queue to manage the state of the unfolding of the list
12:56:44 <derekv2> Cale: I'm just implementing a simple proxy type of server, it's going to manage signon and proxy calls out to a couple of legacy server's apis and do some transformation on them... which must be a fairly common type of app I was hoping there was some magic search term I was missing
12:57:37 <monochrom> this is the problem with meaningful names. you get contradictory meanings.
12:57:42 <benjamin__> monochrom I've seen 'pop' and 'push' used for heaps and FIFOs as well as stacks
12:57:45 <derekv2> HeladoDeBrownie: yea I think it _is_ a proxy server, but searching for proxy server will mostly get me stuff like squid, apache, nginx etc, like "dumb" proxies or reverse proxies
12:58:41 <benjamin__> monochrom i agree! no kidding that naming things is "the hardest thing in computer science"
12:58:44 <monochrom> technically, I have seen, too. but the point is do you have strict, independent, critical judgment, or do you just believe everyone on the internet
13:00:15 <benjamin__> umm... neither?
13:00:33 <mniip> I guess, after all, even with hacks I can't write a function that does (a -> IO b) -> IO (a -> b)
13:00:35 <benjamin__> i'm more interested in coming up with a better name for qUnfold
13:00:55 <monochrom> fold_queue_unfold_list
13:01:12 <benjamin__> that's not bad :)
13:01:20 <dolio> Yes it is.
13:01:28 <mniip> fqul
13:01:33 <EvanR> is there a word for bijective endomorphism
13:01:43 <monochrom> automorphism
13:01:45 <shachaf> What does qUnfold do? Do you have an example?
13:01:57 <mmachenry> monochrom: Do you know why this "try" in the commented out section of my alternative doesn't make it fix the issue but commenting it out does? http://lpaste.net/125883
13:02:18 <benjamin__> shachaf I'm using it in a graph library
13:02:35 <benjamin__> the queue controls the order in which nodes are visited in a graph traversal
13:02:43 <mmachenry> I would think that if parser "a" sucks up characters that parser "b" needs then try a <|> b should fix the issue but it doesn't for me. Commenting out parser "a" however does.
13:03:14 <benjamin__> You pop a node off the queue and dump all of its neighbours back in
13:03:27 <geekosaur> mmachenry, except that parseAtom consumes anything followed by # and returns an Atom if it's not #t or #f
13:03:32 <benjamin__> if the queue is a LIFO you will do a breadth first traversal
13:03:34 <geekosaur> er, anything following #
13:03:48 <benjamin__> if it's a priority queue you will do a dijkstra traversal
13:03:52 <benjamin__> etc
13:04:08 <geekosaur> so it always succeeds, but gives you an Atom. you probably want to try the radix first and only if it fails try the atom
13:04:15 <mmachenry> geekosaur: Oh… rereading. 
13:04:19 <monochrom> general_graph_walk
13:04:19 <benjamin__> Sorry, if it's a FIFO you will do breadth first
13:04:35 <mniip> oh wait
13:04:37 <geekosaur> line 42
13:04:40 <mniip> if you demand the result
13:04:42 <benjamin__> monochrom that's what it's used for, but not what it does
13:04:46 <mniip> it's not that useless after all
13:05:12 <benjamin__> what it does is use a queue to process items in order
13:05:24 <benjamin__> makes no claim as to what the items are
13:05:45 <geekosaur> basicaly, try is only useful if the parser can fail. parseAtom can only fail by not parsing a #
13:06:14 <mmachenry> Yes, I see what's going on now, thanks! I think I need for parseAtom to not match #x10 or having parseNumber go before it.
13:06:18 <shachaf> benjamin__: I asked for an example of what it does, not what it's used for. :-)
13:06:19 <geekosaur> yes
13:06:27 <geekosaur> I would do the latter
13:06:31 <monochrom> assisted_unfold
13:06:37 <geekosaur> if the parse as a radix number fails then try it as an atom
13:06:40 <mniip> guys I wrote a thing
13:06:46 <benjamin__> shachaf i'll update my lpaste, give me a minute
13:06:47 <lpaste> mniip pasted “a thing” at http://lpaste.net/125888
13:07:16 <derekv2> ahh, you know I could probably just say "middleware" and get better results
13:07:18 <shachaf> As list unfolds go it looks a bit odd that it doesn't use Maybe.
13:15:50 * hackagebot touched 0.1.0.3 - Library (and cli) to execute a procedure on file change.  http://hackage.haskell.org/package/touched-0.1.0.3 (crough)
13:15:52 * hackagebot hledger-lib 0.24.1 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.24.1 (SimonMichael)
13:20:50 * hackagebot hledger 0.24.1 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.24.1 (SimonMichael)
13:21:41 <sinelaw> I have a tree structure that grows "downwards". what's the purely functional approach for what would otherwise be a pointer to a branch node that incrementally includes more and more tree beneath it as it grows?
13:22:33 <BMeph> sinelaw: Breadth-first search. ;)
13:23:16 <BMeph> sinelaw: I.e., How will the data be used, instead of how the HW is controlled to produce the data.
13:23:59 <cfoch> o/
13:24:01 <sinelaw> BMeph, I start by knowing what the root (of this subtree) should be. then I learn about children of the node, later I learn about what those children's children should be
13:24:02 <sinelaw> etc.
13:24:12 <cfoch> can somebody tell me why do I get this error
13:24:12 <cfoch> http://fpaste.org/198274/14264505/
13:24:12 <cfoch> when I run "sthg <- GHC.getContext" as
13:24:12 <cfoch> https://github.com/ghc/ghc/blob/0cc0cc8688ddb53db65a73d7d562e9564cfad22b/ghc/InteractiveUI.hs#L1684
13:24:12 <cfoch>  ?
13:25:09 <mniip> cfoch, this should happen in a GHCMonad
13:25:13 <mniip> and not in an IO
13:26:18 <mniip> try imports <- GHC.runGhc (Just libdir) GHC.getContext
13:27:50 <sinelaw> BMeph, that's my use case
13:28:18 <sinelaw> BMeph, eventually (when computation completes) i want to start at the subtree root and traverse to the leaves
13:29:06 <horny-sama> what does Integral means in haskell?
13:29:16 <sinelaw> horny-sama, arbitrary size integer
13:29:18 <sinelaw> oops
13:29:20 <sinelaw> that's Integer
13:29:33 <sinelaw> horny-sama, it means the typeclass of whole (not fractional) numbers
13:29:36 <hexagoxel> are there rules regarding publishing new cabal package version vs new x-version? should proper new version always be preferred?
13:29:45 <monochrom> a type class that includes integer-like types
13:29:50 <Iceland_jack> horny-sama: Types such as Int, Word, Integer, Int8, ..
13:30:42 <Iceland_jack> horny-sama: When you have a function such as 'div :: Integral a => a -> a -> a' it can be specialised to
13:30:43 <Iceland_jack> @ty div :: Int -> Int -> Int
13:30:43 <lambdabot> Int -> Int -> Int
13:30:44 <horny-sama> sinelaw: I mean would not I just write the function take's signature as take' :: (Integer a) => a -[b]->[b] instead of take' :: (Integral a) => a -[b]->[b] 
13:30:45 <Iceland_jack> @ty div :: Integer -> Integer -> Integer
13:30:46 <lambdabot> Integer -> Integer -> Integer
13:30:55 <bergmark> hexagoxel: there aren't any rules, one issue i've run across with revisions is that cabal didn't realize there were newer bounds because the package was already installed. might have been fixed though
13:31:07 <sinelaw> horny-sama, Integer isn't a type class
13:31:09 <sinelaw> Integral is
13:31:33 <bergmark> hexagoxel: also, if you need to constrain bounds, a new version is a bad option since the old version will still be wrong
13:31:40 <horny-sama> sinelaw: will Int a -> [b]->[b] works too?
13:31:54 <sinelaw> horny-sama, Int doesn't take a type parameter
13:32:04 <horny-sama> okay got it
13:32:05 <sinelaw> horny-sama, http://learnyouahaskell.com/types-and-typeclasses
13:32:34 <sinelaw> horny-sama, Int, Word, Integer, etc. are all specific types of numbers 
13:32:52 <sinelaw> horny-sama, whereas Integral is a type class that they all "implement"
13:33:44 <sinelaw> horny-sama, there are other types of numbers that don't implement Integral because they represent fractions or floating points
13:33:58 <sinelaw> "implement"
13:34:14 <sinelaw> should be really "instances of"
13:36:00 <horny-sama> In conclusion, after 3 ish months of haskell studying I still does not know jackshit about it
13:36:14 <sinelaw> horny-sama, did you read a book or good tutorial?
13:36:47 <horny-sama> sinelaw: read learn your haskell
13:37:02 <monochrom> Learn You a Haskell is not enough
13:37:07 <horny-sama> so i could consider it to be a ok book
13:37:09 <sinelaw> horny-sama, ok, writing some code helps
13:37:16 <horny-sama> sinelaw: I did
13:37:34 <horny-sama> https://github.com/mr-fool/haskell
13:37:44 <monochrom> that's right, unfortunately it's so long it does not look like a whirlwind tour, but it is also so shallow it can only be a whirlwind tour
13:38:37 <monochrom> then again, it is still good enough to know "type", "type class", and "instances"
13:38:50 <sinelaw> right
13:39:02 <sinelaw> horny-sama, do you remember the difference between "type" and "type class"?
13:39:16 <sinelaw> (they are not the same thing at all)
13:39:38 <horny-sama> sinelaw: type class is a collection of type?
13:40:20 <sinelaw> horny-sama, not exactly
13:40:33 <sinelaw> horny-sama, a type class is an interface that a type can satisfy
13:40:50 <horny-sama> ok
13:41:11 <horny-sama> gosh I guess I will need to study up on prolog so I can pass the final
13:41:22 <horny-sama> my final is comprised of haskell, java reflection and prolog
13:41:27 <monochrom> the meaning of "type class" will not be summarizable by a few words. (unless you use the very two words "type class".)
13:41:41 <sinelaw> monochrom, there are useful analogies. interface is one
13:42:01 <horny-sama> I know how to use interface in java but not describe it
13:42:01 <horny-sama> :P
13:42:10 <sinelaw> horny-sama, the Eq type class is an interface that allows comparing two elements
13:42:16 <sinelaw> @src Eq
13:42:16 <lambdabot> class Eq a where
13:42:16 <lambdabot>     (==), (/=) :: a -> a -> Bool
13:42:28 <monochrom> I used to use java reflection for testing student code en mass
13:42:30 <horny-sama> sinelaw: is type class = interface?
13:42:41 <sinelaw> horny-sama, not exactly, but close enough
13:42:56 <sinelaw> any type can be an instance of the Eq type class, if you define how itimplements the "==" function
13:43:40 <sinelaw> i.e. for your specific type "a" you define a function == that takes two "a"s and returns a Bool, then it can be an instance of Eq
13:43:57 <sinelaw> horny-sama, see definition printed above by lambdabot 
13:44:09 <monochrom> this is because the homework had requirements like "don't do I/O", "don't use such-and-such from the standard library". so I use java reflection's provision of "when you write your own class loader, you can ban or allow dependencies as you see fit".
13:44:13 <sinelaw> (there is also the /= or "not equal" function
13:44:22 <horny-sama> ok
13:44:49 <sinelaw> horny-sama, so Int, for example, is just a type - not a type class
13:45:06 <horny-sama> ok
13:45:06 <jle`> is there a "canonical" type level nat data/kind ?
13:45:16 <monochrom> and of course, as a consequence, student code is also run in a fairly sandbox-like context that cannot harm my main tester :)
13:45:24 <sinelaw> horny-sama,  given two Int values, can you expect tobe able to compare them to see if they're equal?
13:45:49 <horny-sama> sinelaw: yes, I think so
13:46:17 <monochrom> jle`: does recent GHC provide one? I don't really know, I am uninterested in the whole endeavour, so I only recall rumours.
13:46:27 <sinelaw> horny-sama, because two Int values, are just two numbers (in some range) and you should be able to tell if they are equal, right?
13:46:40 <jle`> i didn't look at 7.10 but i looked through 7.8 i think and i wasn't sure if could find anything
13:46:47 <horny-sama> sinelaw: yes
13:46:54 <jle`> it seems a little silly that there wouldn't be though...every library would have to provide their own
13:47:01 <sinelaw> horny-sama, so we expect the type Int to be an instance of Eq
13:47:45 <sinelaw> Eq is the type class, Int is a type
13:47:57 <barrucadu> jle`: There's GHC.TypeLits, in base
13:48:18 <monochrom> jle`: in the GHC user's guide, look for "Type-Level Literals". (you will find a pun in the section number :) )
13:48:20 <ianjneu> I'm having an awful time trying to get profiling to work. The guides DDG has pointed me to are either wrong, out of date, or expect more context than I have. Any tips?
13:48:38 <jle`> i thought those were just parsing literals in types
13:48:45 * horny-sama takes note on sinelaw's wisdom and name the notebook my haskell struggle
13:48:45 <horny-sama> :P
13:49:13 <jle`> not really interested in type level num literals as much as a nat kind
13:49:15 <sinelaw> horny-sama, :) ok, so Integral is another type class, like Eq
13:49:17 <sinelaw> @src Integral
13:49:17 <jle`> but i'll look again :)
13:49:18 <lambdabot> class (Real a, Enum a) => Integral a where
13:49:18 <lambdabot>     quot, rem, div, mod :: a -> a -> a
13:49:18 <lambdabot>     quotRem, divMod :: a -> a -> (a,a)
13:49:18 <lambdabot>     toInteger       :: a -> Integer
13:49:36 <monochrom> ok, let me quote a few sentences to rekindle your interest.
13:49:47 <sinelaw> horny-sama, the first line says that for any type to be an instance of Integral at all, it must first be an instance of Real and Enum
13:49:52 <monochrom> "Numeric literals are of kind Nat"
13:50:06 <monochrom> "Computing With Type-Level Naturals"
13:50:09 <sinelaw> horny-sama, the next three lines list the functions that a type must implement to be an instance of Integral: quot, rm, etc.
13:50:14 <horny-sama> @src Enum
13:50:14 <lambdabot> class  Enum a   where
13:50:14 <lambdabot>     succ                     :: a -> a
13:50:14 <lambdabot>     pred                     :: a -> a
13:50:14 <lambdabot>     toEnum                   :: Int -> a
13:50:14 <lambdabot>     fromEnum                 :: a -> Int
13:50:16 <lambdabot> [3 @more lines]
13:50:25 <jle`> :P
13:50:39 <monochrom> "GHC 7.8 can evaluate arithmetic expressions involving type-level natural numbers" "natVal (Proxy :: Proxy (2 + 3))"
13:50:42 <cwr> Does anyone know a fix (at a guess a config file edit) for the Cabal error: Linking dist/setup-wrapper/setup ... unrecognized option `--sysconfdir=/opt/cabal/etc'
13:50:59 <MaxGabriel> is anyone interested in code reviewing this attoparsec code? It works, but I haven’t used attoparsec much before so I don’t know if the code could be better. https://gist.github.com/MaxGabriel/f3f9027bb88b67868fdc
13:50:59 <monochrom> "lg :: Proxy base -> Proxy (base ^ pow) -> Proxy pow"
13:51:09 <jle`> oh
13:51:11 <jle`> it is there
13:51:14 <jle`> i wonder why i didn't see it before
13:51:15 <horny-sama> afkkkkkkkkk
13:51:23 <sinelaw> horny-sama, so that's what Integral means in Haskell. :)
13:51:38 <horny-sama> got it
13:51:53 <monochrom> so presumably you can have a type "(a + 1) -> Whee" too
13:52:03 <jle`> wait no...i was looking for something like data Nat = Zero | Succ Nat
13:52:22 <monochrom> yeah but that's subsumed by the ability to write "(a + 1) -> Whee"
13:52:35 <jle`> hm
13:52:41 <monochrom> or maybe "Proxy a -> Proxy (a + 1)"
13:52:43 <jle`> that's scary
13:53:24 <monochrom> what they say about "you asked for type-level succ. we give you type-level primitive recursive functions"
13:53:44 <JagaJaga> Perhaps I have to check existence of lots of folders (like if exist folder1 then if exist folder2 etc). What's the best way to do this actions? Maybe some monads?
13:54:00 <jle`> my use case was, a length-parameterzed Vector Vec :: Nat -> * -> *, instance Applicative (Vec Z) where... instance (Applicaive (Vec n)) => Applicative (Vec S n) where ...
13:54:00 <sinelaw> so what's the "haskell way" of building a tree root-to-leaf? seems like building the entire pure tree from root every time is not efficient
13:54:37 <jle`> JagaJaga: you want to check if they all exist
13:54:42 <jle`> as a yes-or-no?
13:54:58 <monochrom> I should learn this stuff! plenty of April-1st material possible!
13:55:14 <jle`> :P
13:55:16 <jle`> time is coming up
13:55:25 <monochrom> "a function that insists on a vector of mersenne-prime length"...
13:55:27 <exio4> monochrom: the compiler is a bit dumber with type level naturals, I heard, and in my type-hackery-for-fun, found them harder to work with, needing overlapping instances and even more type hackery when working with them 
13:55:54 <JagaJaga> jle`: well, I need to check existence of not all of them (there can be "routes" based on existence)
13:56:02 <monochrom> ok, but that will bode extremely well for April 1st stuff :)
13:56:18 <jle`> JagaJaga: you might be able to use allM
13:56:20 <jle`> http://hackage.haskell.org/package/monad-loops-0.4.2.1/docs/Control-Monad-Loops.html
13:56:26 <monochrom> "much overlapping instances. so primitive recursive."
13:57:04 <JagaJaga> jle`: oh! Really nice. Ty
13:57:08 <jle`> np!
13:57:20 <monochrom> a wise person once said, "you could factorize numbers in C++ at compile time". now GHC wields that ability, too.
13:58:05 <barrucadu> It's a bit sad that given a KnownNat n constraint, GHC can't infer KnownNat (n+1)
13:58:27 <monochrom> first I need to download GHC 7.10
13:58:48 <barrucadu> Hmm, maybe 7.10 can do it, I'm only playing with 7.8 here
13:59:28 <monochrom> very likely. 7.10 got significant improvements in this area
13:59:37 <monochrom> at least worths a try
14:00:40 <monochrom> wait, 7.10 is still RCing?
14:02:19 <mpickering> yes
14:02:26 <mpickering> RC3 was meant to be on friday
14:03:21 <monochrom> what a black friday it was :)
14:05:53 * hackagebot pandoc-types 1.12.4.2 - Types for representing a structured document  http://hackage.haskell.org/package/pandoc-types-1.12.4.2 (JohnMacFarlane)
14:08:15 <Athas> Does anyone know of a good guide to setting up Jenkins for compiling Haskell projects?
14:08:33 <Athas> Right now it seems like I have to maintain a Haskell (and worse: cabal) setup for the jenkins users.
14:10:50 <MaxGabriel> This isn’t an actual answer @Athas, but just speaking from personal experience with Jenkins, Travis CI and Circle CI, I’d do anything I could to use a hosted CI service like travis
14:13:38 <Athas> Hm, maybe I will take another look at Travis.
14:15:01 <MaxGabriel> Travis works really well for Haskell; most all the open source haskell projects use it
14:16:01 <Athas> Guess I should play well with the community, even if I'm not building a library.
14:24:47 <Athas> Maxdamantus: won't the build time limits become a problem, given how slow GHC can be?
14:25:05 <Athas> Well, I suppose that if existing Haskell projects can deal, so can I...
14:26:15 <MaxGabriel> time limits won’t be an issue, no. I think you get up to 1 hour on travis or something
14:28:16 <Athas> Oh, I thought it was much less.  Yeah, that's fine.
14:35:00 <sternenseemann> that whole cabal2nix stuff is strange
14:35:22 <sternenseemann> haven't yet figured out how to nix-build that
14:35:37 <sternenseemann> and nix-shell --pure behaves strangely…
14:44:38 <m0rphism> sternenseemann: There was recently a discussion on this on #nixos
14:45:47 <sternenseemann> m0rphism: maybe I should search their logs
14:46:06 <m0rphism> sternenseemann: There are two workarounds currently. The easiest is to copy shell.nix to build.nix and remove the `.env` at the end of its content, then run nix-build build.nix.
14:46:27 <m0rphism> Otherwise you are trying to build the environment instead of the package itself
14:46:52 <sternenseemann> nix-build shell.nix basically creates a specific nix-shell, yeah
14:47:55 <RageD> Does haskell have any libraries for multiplexing IO? I have two things I want to monitor for data (i.e. a Chan and a WebSocket) and I simply want to respond when one is ready. I can think of an implementation where I fork two threads to monitor (i.e. use the respective blocking read calls) and use a Chan or similar to push events to a controller thread, but I am wondering if there is a cleaner way
14:49:53 <jmcarthur> RageD: you can get something like this really conveniently with the async library
14:52:06 <sternenseemann> m0rphism: is there still a way to generate the shell.nix file?
14:52:18 <sternenseemann> m0rphism: I just copied it from somewhere™
14:52:50 <mniip> "functions that tightly fill their codomains are called surjective or onto."
14:53:02 <hacker> total functions!
14:53:07 <m0rphism> sternenseemann: oh, yes there is. But you need cabal2nix version 2.0 which is the one from haskellngPackages.
14:53:13 <mniip> meaning that every value of the codomain is returned for some argument?
14:53:37 <Cale> Yeah, a function f: A -> B is surjective if for each b in B, there is some a in A such that f(a) = b
14:54:21 <m0rphism> sternenseemann: you can then run `cabal2nix --shell ./. > shell.nix` from the directory where your .cabal file resides.
14:54:46 <RageD> jmcarthur: Thanks, I'll check it out
14:55:09 <Cale> (This is not the same thing as a total function.)
14:55:38 <shachaf> It's a sort of dual of a total function.
14:55:49 <shachaf> Hmm, maybe not.
14:55:56 <siddhu> I find diagrams helpful in understanding when functions are surjective http://www.mathsisfun.com/sets/images/function-mapping.gif
14:56:25 <hacker> ah, right
14:56:39 <siddhu> Isn't a total function just a function? And a non-total function a relation?
14:56:40 <mniip> shachaf, cototal
14:56:43 <sternenseemann> m0rphism: how do I get haskellngPackages
14:57:01 <sternenseemann> m0rphism: it seems like they were not present on my nix installation
14:57:02 <mniip> yeah non-total functions are exclusive to programming
14:57:16 <mniip> by mathematical definition all functions are total
14:57:36 <shachaf> I guess injective/total are sort-of duals in this sense.
14:58:06 <siddhu> a total function could be neither injective nor surjective. it's totally possible
14:58:12 <m0rphism> sternenseemann: haskellngPackages is currently unofficial, so it is not searched when invoking `nix-env -qa`.
14:58:19 <hacker> yeah, I read the phrase in the wrong order
14:58:20 <shachaf> Yes. I'm not even talking about functions.
14:59:15 <sternenseemann> m0rphism: i see. Thanks!
14:59:22 <m0rphism> sternenseemann: but you can install from it using the package attributes, i.e. "nix-env -iA nixos.pkgs.haskellngPackages.cabal2nix"
14:59:44 <sternenseemann> yes, that's what I'm doing :)
14:59:50 <m0rphism> sternenseemann: afaik it also features complete hackage using exactly the same names as in hackage
15:00:27 <m0rphism> sternenseemann: another thing which is good to know, is that there are also no binaries built for it in the default caches.
15:00:28 <shachaf> No, it's total/surjective.
15:00:36 <shachaf> Sigh.
15:01:04 <m0rphism> sternenseemann: so if you do not want to rebuild everything once on your machine, you can add extra binary cache urls.
15:01:09 <ianjneu> okay I'm asking again: how do I turn on profiling? Stack overflow's answers don't work. I keep getting that ghc can't find Prelude's profiling library.
15:01:27 <m0rphism> sternenseemann: are you using nixos or only the package manager?
15:01:37 <sternenseemann> m0rphism: currently only the package manager
15:01:58 <sternenseemann> m0rphism: when I've got some spare time again I might replace my ArchLinux
15:02:13 <sternenseemann> m0rphism: oh, this will be fun compiling :D
15:02:30 <m0rphism> sternenseemann: then you can change the binary-caches part in your nix.conf files to:
15:02:30 <m0rphism> binary-caches = https://cache.nixos.org/ http://hydra.nixos.org/ http://hydra.cryp.to/
15:02:32 <siddhu> shachaf: I'm totally lost. What do you mean by dual of total?
15:02:43 <shachaf> siddhu: I'm talking about relations, not functions.
15:02:52 <m0rphism> sternenseemann: I think this files is either in /etc/nix/nix.conf or somewhere in /nix/
15:03:38 <m0rphism> sternenseemann: I've also been using arch for quite some time, switched to nixos about two weeks ago :)
15:03:49 <shachaf> For any relation you have an inverse relation, and there are four obvious properties you can describe.
15:04:57 <siddhu> Hmm. I wasn't aware of total relations.
15:05:17 <m0rphism> sternenseemann: So far I am quite happy, but there are still some edges. You probably will have to dive quite a bit into the nix world to customize everything to your need ;) I recommend starting with a virtual machine, because of the declarative nature of nixos, it is quite easy to migrate to a real machine.
15:05:32 <shachaf> Well, every relation has an inverse, and these are the same as injective/surjective for the inverse relation.
15:06:02 <sternenseemann> m0rphism: good point
15:06:20 <sternenseemann> m0rphism: ah friend of mine got a spare identical laptop to setup his new machine :D
15:06:36 <m0rphism> sternenseemann: :3
15:06:50 <siddhu> there are inverse relations, relations, and inverses. I wonder how mathematicians don't get confused.
15:07:34 <sternenseemann> m0rphism: at our local hackerspace basically half of the people is thinking about using nix(os) because one of the nix devs lives here and has convinced basically everybody :D
15:08:22 <sternenseemann> m0rphism: do I have to do anything to refresh the cache?
15:08:23 <lpaste> Doh pasted “99probs” at http://lpaste.net/125892
15:08:36 <m0rphism> sternenseemann: lovely :) didn't know one of the devs was living in Germany, where are you located if that's not a too personal question?
15:08:59 <sternenseemann> m0rphism: that's fine. I live there, yes
15:09:34 <m0rphism> sternenseemann: I'm also from Germany, hence I've recognized your name ;)
15:09:43 <sternenseemann> m0rphism: I see :D
15:10:40 <m0rphism> m0rphism: if you were talking about the binary caches, then you don't have to do anything
15:11:19 <m0rphism> sternenseemann: next time you install something using nix-env or nix-shell it will search those caches additionally
15:11:54 <sternenseemann> m0rphism: strange
15:12:02 <sternenseemann> cat /etc/nix/nix.conf
15:12:03 <sternenseemann> binary-caches = https://cache.nixos.org/ http://hydra.nixos.org/ http://hydra.cryp.to/
15:12:16 <sternenseemann> still compiling :(
15:12:22 <m0rphism> is this the only contents?
15:12:24 <EvanR> so, im experiencing an STM action executed with atomically not being retried, despite the fact that it is reading a tvar that i am polling in another thread to verify that it is changing
15:12:29 <sternenseemann> m0rphism: yes
15:12:33 <bennofs> sternenseemann: hydra is having problems atm
15:12:41 <EvanR> it does retry once, and is never tried :(
15:12:43 <bennofs> sternenseemann: 80k build queue, no builds running
15:12:59 <bennofs> sternenseemann: last nixos unstable update was ~20 days ago I think
15:13:08 <EvanR> retried*
15:13:09 <lpaste> Doh revised “99probs”: “99probs” at http://lpaste.net/125892
15:13:13 <sternenseemann> bennofs: strange
15:13:22 <m0rphism> sternenseemann: have you created it yourself? maybe your nix.conf is located somewhere else? I'm using nixos so I'm not sure how it behaves in different context.
15:13:26 <bennofs> sternenseemann: btw, you might like #nixos for nix questions :)
15:13:41 <m0rphism> bennofs: sternenseemann: oh, if the caches are down as well, that makes sense of course ;)
15:14:17 <bennofs> m0rphism: the caches are up, but only if you don't build from nixpkgs master but instead use only the unstable channel (which is quite some time behind master currently)
15:14:42 <m0rphism> I see.
15:15:00 <bennofs> But I think the crypt.to cache, which is the only cache which builds all haskellng packages, tracks master so you cannot get all haskellng packages this way
15:15:13 <ianjneu> signal boosting: how does one get profiling working?
15:15:49 <sternenseemann> bennofs: yeah, that came to my mind like 10 secs after asking :)
15:16:38 <m0rphism> bennofs: ahh this explains why some stuff still had to be built manually even I've added the caches and they were used for most hackage stuff.
15:16:43 <Doh_> Hello! I am trying to go through https://wiki.haskell.org/99_questions/11_to_20. In my code http://lpaste.net/125892 on row 23 I get the error Occurs check: cannot construct the infinite type: a0 = [a0] for replicate n x. What could I be doing wrong here?
15:17:48 <Doh_> Not 23, 27
15:18:35 <sternenseemann> Doh_: the problem seems to be that lists in haskell are homogenous
15:18:36 <Iceland_jack> Doh_: You're mapping this over a list [ListItem a], try adding a type signature to 'decoderHelper' first
15:18:54 <sternenseemann> [[2], 2] is not possible
15:19:04 <Iceland_jack> Its type should be (haven't tested)
15:19:04 <Iceland_jack>     decoderHelper :: ListItem a -> a
15:19:12 <sternenseemann> because the type is either [[Int]] or [Int]
15:19:23 <Iceland_jack> 'replicate' does not fit there
15:19:42 <sternenseemann> Iceland_jack's point is surely useful here
15:20:06 <sternenseemann> Doh_: you probably want to process the list recursively by yourself
15:20:12 <jmct> Is there a good guide for porting code to work with ghc 7.10?
15:20:43 <Iceland_jack> Doh_: Look into 'concatMap f xs = concat (map f xs)'
15:20:53 <Iceland_jack> and turn 'decoderHelper (Single x) = [x]'
15:21:18 <Iceland_jack> > concatMap (\x → [x, x]) "hello"
15:21:19 <lambdabot>  "hheelllloo"
15:22:39 <Iceland_jack> So it would go from:
15:22:39 <Iceland_jack>       decodeModified [Single 'a', Multiple (3, 'b'), Single 'u']
15:22:39 <Iceland_jack>     = concatMap decoderHelper [Single 'a', Multiple (3, 'b'), Single 'u']
15:22:42 <Iceland_jack>     = concat [['a'], ['b', 'b', 'b'], ['u']]
15:22:45 <Iceland_jack>     = "abbbu"
15:24:06 <ttt_fff> i'm thikning something like 2 chars or less
15:24:09 <ttt_fff> is there a word like 'noop', but even shorter" ?
15:24:20 <ttt_fff> by noop, i'm meaning no-op
15:25:06 <Iceland_jack> Doh_:
15:25:06 <Iceland_jack>     concatMap :: (ListItem a -> [a]) -> [ListItem a] -> [a]
15:25:11 <glguy> Shorter than no-op? nop.
15:25:14 <jle`> nope
15:25:20 <Iceland_jack> no
15:25:23 <rori> Let's say you have a module X which has 3 functions you want to expose as the injterface and 7 helper functions. For testing reasons you might want to test the helpers as well. but if you don't export them then they are hidden from the test program. can you solve this in a neat way?
15:25:52 <Iceland_jack> rori: Create a .Internal module
15:25:55 <HeladoDeBrownie> ttt_fff, id is a pretty common word for no-op ;)
15:26:07 <ttt_fff> HeladoDeBrownie: I like that.
15:26:07 <Doh_> Thanks! Iceland_jack, I did just that, I used concatMap in an earlier exercise but didn't think of it here. I've written it in and it works.
15:26:19 <dhinojosa> So after functors, applicatives, monoids, and monads...what is the next thing I should learn about?
15:26:57 <rori> Iceland_jack, is that a real construct of the language or is it a , how to say, naming habit? meaning it is not reallly hidden but merely tells user it is not to be used directly?
15:27:22 <HeladoDeBrownie> rori, "convention" is the word you want, and it is indeed that.
15:27:41 <Iceland_jack> rori: Convention, yes. This question talks about it http://stackoverflow.com/questions/9190638/how-why-and-when-to-use-the-internal-modules-pattern
15:28:44 <rori> ty
15:28:45 <Iceland_jack> rori: http://stackoverflow.com/questions/14379185/function-privacy-and-unit-testing-haskell thie question discusses it + testing
15:29:36 <Iceland_jack> There is also an answer there that deals with how to manage it usnig 'cabal' rori 
15:34:24 <EvanR> scratch that, stupid bugs in my code
15:35:06 <EvanR> what a waste of time.. *puts everything back together again*
15:35:29 <mjrosenb> > [x | (3,x) <- zip [1..] "Hello World"]
15:35:31 <lambdabot>  "l"
15:35:37 <mjrosenb> awww, hell yeah
15:35:56 <mjrosenb> the list monad handles pattern match failures exactly how I want it to.
15:36:02 <Iceland_jack> :)
15:36:21 <mjrosenb> for some reason, I thought it didn't.
15:36:44 <Iceland_jack> 'catMaybes :: [Maybe a] -> [a]' makes use of that in a nice way
15:36:44 <Iceland_jack> @src catMaybes
15:36:44 <lambdabot> catMaybes ls = [x | Just x <- ls]
15:37:54 * mjrosenb can think of many snippets of mine that would have been simpler with this
15:38:07 <mjrosenb> although, I think some of them weren't the list monad :-/
15:38:13 <Iceland_jack> You can do something similar with 'left :: [Either a b] -> [a]' and 'right :: [Either a b] -> [b]'
15:38:30 <Iceland_jack> mjrosenb: It's not specific to the list monad
15:38:34 <Iceland_jack> > [ lft | Left lft <- [Left 'a', Right True, Left 'z', Right False] ]
15:38:35 <lambdabot>  "az"
15:38:42 <Iceland_jack> > [ rgt | Right rgt <- [Left 'a', Right True, Left 'z', Right False] ]
15:38:43 <lambdabot>  [True,False]
15:39:48 <mjrosenb> Iceland_jack: both of those sure look like they're still in the list monad.
15:40:14 <Iceland_jack> Yes, those were examples of what I was talking about earlier
15:42:05 <Iceland_jack>     ghci> :set -XMonadComprehensions
15:42:05 <Iceland_jack>     ghci> [ 42 | 'a' ← Just 'a' ] -- returns: Just 42
15:42:05 <Iceland_jack>     ghci> [ 42 | 'b' ← Just 'a' ] -- returns: Nothing
15:42:30 * mjrosenb has Either String a, and want a pattern match failure to produce Left blah
15:42:50 <mjrosenb> Iceland_jack: is it only in comprehensions, or does it work in any monad?
15:43:21 <c_wraith> mjrosenb: depends on the implementation of fail for the particular monad
15:43:21 <Iceland_jack> It works in any Monad (sadly) :) it uses the method 'fail :: String -> m a' for some Monad m
15:43:25 <carter> quchen: you mentioned my name?
15:43:31 <shachaf> It can't work for Either.
15:43:36 <c_wraith> mjrosenb: fail in Either results in a call to error, not a Left
15:43:58 <shachaf> Well, it can't work for Either e for unknown e.
15:43:59 <quchen> carter: Someone wondered what your full name was, I just told him what your IRC info said.
15:44:00 <mjrosenb> so I'd need to write my own either that has a different fail.
15:44:08 <sternenseemann> m0rphism: okay, I was able to make it work as wanted, ty!
15:45:00 <m0rphism> sternenseemann: yay, you're welcome :)
15:46:14 <sternenseemann> \o/
15:50:22 <jle`> dhinojosa: just start coding :)d
15:50:28 <jle`> learn things as they come up
15:51:04 <sternenseemann> jle`: +1
15:51:23 <marcoy> 30 /set weechat.look.prefix_error "⚠"
15:54:11 <mjrosenb> ugh, broken deps in cabal
15:54:16 <mjrosenb> anyone know how to fix them?
15:54:40 <sternenseemann> mjrosenb: cabal sandbox init
15:54:49 <bkc39> which package?
15:54:52 <sternenseemann> mjrosenb: cabal install --only-dependencies
15:55:16 <mjrosenb> https://gist.github.com/ca9060a4b595a6a819c7
15:56:14 <sternenseemann> mjrosenb: are you using nix?
16:01:24 <barrucadu> I'm playing around with GADTs and type literals (may as well dive into the depe end, eh?) and am having difficulty with some dependently typed vectors: http://lpaste.net/125897
16:02:21 <shachaf> Those aren't dependently typed (Haskell doesn't have dependent types).
16:03:15 <Bynbo7> I have a feeling you need something like: data Vec (n :: Nat) a where
16:04:05 <shachaf> That kind is inferred from the constructors.
16:04:38 <shachaf> The trouble seems to be that (+1) isn't injective.
16:05:34 <shachaf> Or rather that GHC can't figure out that it is.
16:05:39 <shachaf> I haven't used GHC's fancy Nat kinds, only simple handwritten Nats.
16:06:30 <hacker> :r
16:06:33 <hacker> er, sorry :P
16:06:45 <johnw> fr33domlover: hello
16:07:47 <barrucadu> Any way I can massage GHC into believing that +1 is injective?
16:08:10 <nocturne777> there's one thing here(http://goo.gl/qBapf) that I do not understand about the state monad: if we do push 3 >> pop >> ... "a" becomes "()" and "()" is fed into pop
16:08:42 <nocturne777> pop does not take any input
16:08:48 <nocturne777> how does that code compile ?
16:08:54 <shachaf> I'd like to know the answer.
16:08:55 <geekosaur> :t >>
16:08:57 <lambdabot> parse error on input ‘>>’
16:08:57 <geekosaur> er
16:09:01 <geekosaur> :t (>>)
16:09:02 <lambdabot> Monad m => m a -> m b -> m b
16:09:05 <shachaf> You could always make your own Nats with data Nat = Z | S Nat.
16:09:17 <geekosaur> which is to say, (>>) takes an argument and ignores it
16:09:22 <fr33domlover> johnw, hello. I've been looking for ways to use Git in Haskell without forking into a process, and instead using something more elegant. But it seems the documentation of gitlib isn't exactly all organized and in sync with the current API, and I found only 1 package that uses it (which you wrote too). Can I rely on gitlib in an application (e.g. git hosting platform)? Also is the gitlib-hit backend usable?
16:09:45 <nocturne777> pop simly returns a State(\xs -> ((), a:xs)
16:09:58 <fr33domlover> I'm a haskell beginner so I suppose it's generally more difficult for me
16:10:07 <geekosaur> in fact the default implementation of (>>) is: m >> f = m >>= \_ -> f
16:10:25 <Axman6> nocturne777: >> doesn't pass anything, >>= does
16:10:26 <johnw> fr33domlover: you can rely on it, and updating the documentation is rather high on my list.  I can help you get the current code working, see me in #gitlib
16:10:31 <Axman6> :t (>>)
16:10:32 <lambdabot> Monad m => m a -> m b -> m b
16:10:33 <Axman6> @src (>>)
16:10:34 <lambdabot> m >> k = m >>= \_ -> k
16:11:13 <fr33domlover> johnw, thanks
16:14:46 <nocturne777> geekosaur: I know about >> and I also took that into account. but what if "f" was "push" which takes one parameter
16:17:02 <pavonia> nocturne777: That would be a type error
16:17:49 <nocturne777> pavonia: this works: runState (push 3 >> push 21 ) [51]
16:18:41 <nocturne777> (a, xs) gets returned by push 3  
16:18:47 <nocturne777> where a is ()
16:19:07 <nocturne777> "a" gets fed into "f" where f is push
16:19:18 <EvanR> nocturne777: >> ignores the result
16:19:28 <pavonia> Where does () come from here?
16:19:44 <pavonia> Ah, I see
16:19:58 <glguy> nocturne777: push 3 :: State Stack (), it's not a function
16:21:26 <geekosaur> you gave it the parameter
16:22:49 <geekosaur> nocturne777, so the thing that is passed as f in that (m >> f) is (push 3). you gave it the parameter it wanted, and it is not given the extra one from m
16:22:50 <nocturne777> ok, now I see
16:23:07 <nocturne777> I sometimes fail to see 
16:24:33 <ianjneu> profiling question: I finally managed to get it to build. I can't get a report until my program terminates... or did I do it wrong? I need partial information for an interrupted execution.
16:25:28 <geekosaur> you don't get a report until it terminates
16:26:13 <ianjneu> geekosaur: I can't run in a continuation that has a finalizer?
16:26:46 <geekosaur> it's written out when the runtime shuts down, as I understand it
16:27:29 <mniip> just forcefully terminate the runtime when you need it, then
16:27:47 <EvanR> mniip: how do you do that?
16:28:12 <mniip> exitSucess?
16:28:29 <EvanR> as long as you can do that from the main thread it works
16:28:37 <ianjneu> C-c is too forceful.
16:28:42 <EvanR> might be inconvenient
16:29:55 <Jello_Raptor> :( I'm writing drivers in C, and I really miss currying and lambdas 
16:30:14 <carter> Jello_Raptor: for what hardware architecture?
16:30:16 <EvanR> thats all? ;)
16:30:54 <ianjneu> EvanR: probably function application.
16:31:17 <EvanR> ianjneu: what question is that an answer to
16:32:30 <ianjneu> EvanR: "that's all?" to currying and lambdas.
16:33:32 <EvanR> ianjneu: C has function calls, i was thinking gc, repls, types...
16:34:43 <ianjneu> EvanR: it has procedure calls. With the addition of lambda, you need a more general call form.
16:36:53 <Jello_Raptor> carter: arm
16:37:10 <carter> Jello_Raptor: write a mini compiler using llvm-general
16:37:13 <carter> @hackage lllvm-general
16:37:14 <lambdabot> http://hackage.haskell.org/package/lllvm-general
16:37:16 <carter> or maybe rust?
16:37:16 <carter> idk
16:37:22 <carter> @hackage llvm-general
16:37:22 <lambdabot> http://hackage.haskell.org/package/llvm-general
16:37:54 <Jello_Raptor> carter: no <_< that would take longer than my deadline. 
16:39:40 <cfoch> what is the IIModule?
16:44:35 <cfoch> it appears in ghc
16:46:24 <ReinH> cfoch: where?
16:46:52 <mniip> cfoch, I think questions about ghc-api are more likely to be answered in #ghc
16:47:50 <cfoch> ReinH: https://github.com/ghc/ghc/blob/master/ghc/InteractiveUI.hs#L1688
16:56:36 <mpickering> I have a function f :: AP () -> AP () and I'm trying to abstract away the AP using a free monad. What should the type of the constructor in the functor be? 
16:57:22 <mpickering> if I had f :: Int -> AP () then it would simply be F :: Int -> next -> MyFreeFunctor next
16:57:26 <mpickering> but I'm not sure in this example
16:57:37 <SrPx> what is a clean combinator for "comb f g h = f (g x) (h x)" ?
16:58:06 <mpickering> that's the function applicative instance
16:58:07 <hacker> liftA2? 
16:58:13 <hacker> f <$> g <*> h 
16:58:27 <arkeet> SrPx: comb = liftA2
16:58:39 <arkeet> assuming you meant
16:58:41 <arkeet> comb f g h x
16:58:53 <hacker> @type (\f g h -> f <$> g <*> h) :: (a -> b -> c) -> (x -> a) -> (x -> b) -> (x -> c)
16:58:54 <lambdabot> (a -> b -> c) -> (x -> a) -> (x -> b) -> x -> c
16:59:13 <hacker> @type (\f g h x -> f (g x) (h x)) :: (a -> b -> c) -> (x -> a) -> (x -> b) -> (x -> c)
16:59:14 <lambdabot> (a -> b -> c) -> (x -> a) -> (x -> b) -> x -> c
16:59:16 <SrPx> yep... how I remember that, though? I've used it once or another but ... I just don't feel why it works
16:59:25 <SrPx> that is, what is the logic of the function applicative instance
16:59:30 <arkeet> :t liftA2
16:59:31 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
16:59:36 <arkeet> now let f = (x ->)
17:00:12 <hacker> SrPx: an analogy? parallel function application? :P
17:02:29 <arkeet> you can think of a function x -> a as
17:02:35 <arkeet> a bunch of a's, one for each x
17:02:48 <arkeet> so you have a function a -> b -> c
17:02:54 <arkeet> and a bunch of a's and a bunch of b's
17:03:04 <arkeet> one for every x
17:03:11 <arkeet> idk
17:03:21 <EvanR> x doesnt appear in a -> b -> c
17:03:25 <monochrom> you're saying it right.
17:04:12 <arkeet> you can basically think of liftA2 as zipWith
17:04:15 <arkeet> :t zipWith
17:04:16 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
17:04:21 <monochrom> the table for (x->c) can be built by: for each x, look up a from the x->a table, look up b from the x->b table, then ask a->b->c for c.
17:04:34 <monochrom> precisely why there is no x in a->b->c. you don't need it.
17:04:58 <EvanR> oh the two functions are taken together
17:05:00 <arkeet> you have a bunch of a's and a bunch of b's, indexed by x, and you zip them together with a->b->c
17:05:07 <arkeet> then you get a bunch of c's indexed by x.
17:06:54 <SrPx> hmmm....
17:07:29 <SrPx> I think of applicatives as a function that lets me apply a boxed value to a boxed value
17:07:35 <SrPx> I just kinda fail to see what a function type is boxing
17:07:44 <SrPx> so maybe that analogy isn't great on this case ^_^
17:08:00 <arkeet> what's a box
17:09:08 <Rotaerk> SrPx, the function is "boxing" its return value
17:09:23 <Rotaerk> err no
17:10:10 <arkeet> :t liftA2 :: (a -> b -> c) -> (x -> a) -> (x -> b) -> (x -> c)
17:10:11 <lambdabot> (a -> b -> c) -> (x -> a) -> (x -> b) -> x -> c
17:10:17 <hacker> I don't like those analogies 
17:10:43 <SrPx> hacker: they're not ideal but how else am I going to remember that f <$> g <*> x does what it does?
17:11:35 <monochrom> I remember what <$> does and what <*> does
17:11:44 <SrPx> of course, the type checks. I understand why this work. and I could figure it out by looking at <*>'s definition and thinking for a few seconds. but I don't see myself needing to do what it does and just think: oh, f<$>g<*>h . (Of course if I use it a lot then I will but...)
17:11:51 <arkeet> I always translate that in my head to liftA2.
17:12:20 <monochrom> consequently, I not only deduce what f<$>g<*>x does, but also what h<$>i<*>j<*>k does, and also m<*>n<*>p<*>q<*>r
17:12:39 <SrPx> anyway
17:13:32 <Hijiri> liftA2 id (liftA2 h i j) k
17:13:41 <SrPx> I guess I have a good mental analogy now :)~
17:15:02 <arkeet> :t liftA2 (,)
17:15:03 <lambdabot> Applicative f => f a -> f b -> f (a, b)
17:15:12 <arkeet> :t zip
17:15:13 <lambdabot> [a] -> [b] -> [(a, b)]
17:15:37 <SrPx> if I consider a function to be a box with something unknown (the argument it will receive), then (liftA2 f g h) makes total sense in that it applies the binary function to whatever "g" and "h" will receive :~
17:15:43 <SrPx> might sound stupid but yea
17:16:02 <Hijiri> function as a box of every possible output for an e
17:16:11 <arkeet> not a bad analogy.
17:16:15 <SrPx> makes sense.
17:17:17 <SrPx> hope I remember that, it really made my code look better (I think): splitInNChunks n k = (,) <$> chunksOf k . take (n*k) <*> drop (n*k)
17:17:30 <SrPx> the name needs to improve, though :)
17:18:01 <arkeet> performance could be a little better too.
17:18:13 <hacker> isn't there a function that does "take x" y "drop x" at the same time?
17:18:23 <SrPx> split actually does it...
17:18:28 <arkeet> :t splitAt
17:18:28 <lambdabot> Int -> [a] -> ([a], [a])
17:18:42 <SrPx> but I find its api weird since I have to pattern match... let me see if I can get it shorter
17:18:55 <arkeet> > splitAt 5 [1..20]
17:18:56 <lambdabot>  ([1,2,3,4,5],[6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])
17:19:05 <SrPx> anyway, what's with the performance, it is linear afaik
17:19:23 <hacker> that way that code would be just first splitInChunks n k = first (chunksOf k) . splitAt (n*k)
17:19:24 <arkeet> yes, but you traverse the list multiple times.
17:19:36 <FreeFull> Anything with lists will be likely O(n) or worse
17:19:47 <SrPx> yep twice
17:20:05 <SrPx> eh, three times actually :)
17:20:07 <Rotaerk> not head !
17:20:21 <hacker> @type first
17:20:22 <SrPx> I wonder if GHC doesn't magically optimize that kind of thing, though?
17:20:22 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
17:22:35 <SrPx> hacker: that definition doesn't work though, what are you trying to do?
17:22:42 <arkeet> :t \n k -> runState $ replicateM n (state (splitAt k))
17:22:43 <lambdabot> Int -> Int -> [a] -> ([[a]], [a])
17:23:07 <arkeet> > (\n k -> runState $ replicateM n (state (splitAt k))) 3 2 [1..20]
17:23:09 <lambdabot>  ([[1,2],[3,4],[5,6]],[7,8,9,10,11,12,13,14,15,16,17,18,19,20])
17:23:36 <SrPx> neat
17:25:11 <hacker> > (\n k -> first (chunksOf k) . splitAt (n*k)) 3 2 [1..20]
17:25:12 <lambdabot>  ([[1,2],[3,4],[5,6]],[7,8,9,10,11,12,13,14,15,16,17,18,19,20])
17:25:25 <hacker> hm? isn't it working? 
17:25:35 <arkeet> looks fine to me.
17:26:38 <neuroserpens> After going through several boring and impractical books, looking for haskell cheatsheets was the answer to all my problems. I feel like I'm finally getting the hang of it.
17:26:55 <arkeet> doesn't that still traverse the first n*k of the list twice still
17:27:27 <arkeet> > (\n k -> runState $ replicateM n (state (splitAt k))) 3 2 [1..5]
17:27:28 <lambdabot>  ([[1,2],[3,4],[5]],[])
17:27:31 <arkeet> > (\n k -> runState $ replicateM n (state (splitAt k))) 3 2 [1..3]
17:27:32 <lambdabot>  ([[1,2],[3],[]],[])
17:27:36 <arkeet> hm. it's slightly different.
17:27:41 <arkeet> > (\n k -> first (chunksOf k) . splitAt (n*k)) 3 2 [1..3]
17:27:42 <lambdabot>  ([[1,2],[3]],[])
17:28:25 <hacker> arkeet: I just made the change from drop & take -> splitAt 
17:28:36 <arkeet> sure.
17:29:01 <arkeet> > (\n k -> runState $ fmap (takeWhile (not . null)) $ replicateM n (state (splitAt k))) 3 2 [1..3]
17:29:02 <lambdabot>  ([[1,2],[3]],[])
17:29:27 <arkeet> eh I guess that's still not quite the best.
17:31:02 * hackagebot pinboard 0.1 - Access to the Pinboard API  http://hackage.haskell.org/package/pinboard-0.1 (jonschoning)
17:32:34 <SrPx> hackagebot: wait, what is first there?
17:32:41 <SrPx> > :t first
17:32:42 <lambdabot>  <hint>:1:1: parse error on input ‘:’
17:32:48 <SrPx> woops. :(
17:33:09 <hacker> @type first
17:33:10 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
17:33:19 <hacker> first f (x,y) = (f x, y)
17:36:31 <rui3> m0rphism: Sorry for the delay. ghc-7.8.4
17:44:05 <SrPx> well guys
17:44:10 <SrPx> I was curious enough to try this
17:44:59 <thisisdarshan> hello
17:45:10 <SrPx> http://lpaste.net/125925 I'm not sure how I interpret it, though. seems like GHC optimized it so it isn't doing any actual work :(
17:45:39 <SrPx> maybe the list was too small
17:50:11 <SrPx> well seems like every definition is indeed equivalent in performance. but that doesn't make sense to me. can anyone disprove it?
17:59:31 <SrPx> well nvm managed to benchmark with `time` and `deepseq` :( arkeet a winner is you. using state is 30% faster than splitAt
18:01:40 <SrPx> I'm not sure how it works, though
18:05:34 <SrPx> nvm, I get it :) brilliant 
18:12:26 <RageD> Anyone know of a channel that will block on reads and can be duped? BoundedChan is almost what I want but I can't dup it
18:15:31 <pingu> RageD: unagi-chan does this, I think.
18:17:55 <pingu> RageD: from the sounds of things you'd need to be careful with unbounded memory growth, though.
18:22:01 <RageD> pingu: Yeah, I'm just writing a prototype for something, so this will be one of those cases where I make a comment saying something like this is bad, but it won't be used in prod... then they'll ship the prototype :) lol
18:24:07 <Axman6> RageD: what's wrong with a normal Chan? they can be duplicated
18:24:52 <RageD> Axman6: I want readChan to block if the chan is empty
18:24:54 <Axman6> or a TChan, which would allow you to make them have bounded size too
18:25:03 <Axman6> that's what readChan does afaik
18:25:10 <Axman6> @hoolge readChan
18:25:12 <lambdabot> Control.Concurrent.Chan readChan :: Chan a -> IO a
18:25:19 <EvanR> hoolge?
18:25:23 <Axman6> yes >_>
18:25:31 <EvanR> nice
18:26:05 <Axman6> RageD: with that type, it almost definitely has to block; it can't return an a until there is an a to return
18:26:58 <Axman6> Chans are basically a linked list of MVars
18:27:00 <RageD> let me double check. I felt like it was throwing an exception earlier, but maybe not. i was tackling a different problem at the time
18:27:15 <EvanR> readChan can throw an exception
18:27:23 <EvanR> but thats a good thing
18:30:52 <octatoan> hey everyone
18:31:18 <RageD> hm, not seeing an exception anymore :)
18:31:38 <octatoan> So I've decided on a little "long-term" Haskell project. I'm going to make a Vim-ish text editor.
18:31:44 <octatoan> What do I need to know?
18:31:53 <octatoan> (I've finished LYAH)
18:32:03 <Axman6> octatoan: zippers and text editors go hand in hand very nicely
18:32:39 <octatoan> I'm more worried/interested in the interface. curses and all.
18:32:47 <Axman6> you might want to have a look at Yi, a haskell text editor that already exists (or not, if you want to do it all from scratch =)
18:33:03 <octatoan> Oh yes, right.
18:33:16 <octatoan> Won't it be fiendishly complicated?
18:33:31 <Axman6> probably, but all text editors are
18:34:17 <octatoan> Do you know of any toy implementations?
18:34:28 <octatoan> Like there used to be a Rust one I saw on HN
18:36:07 <StoneToad> you could try porting the rust one?
18:36:13 <StoneToad> you might also try searching hackage
19:28:06 <Rotaerk> given a "StateT s IO a", in general, if an exception is thrown within, is there a way to capture what the state was just before the throw
19:28:58 <hacker> isn't do { old_state <- get ; ... } enough? 
19:29:30 <glguy> Rotaerk: no
19:30:01 <glguy> Rotaerk: If you wanted the state to survive exceptions you'd need things oriented like so: ExceptT e (State s) a
19:30:14 <glguy> (which obviously wouldn't work out with IO)
19:30:21 <Rotaerk> k
19:30:54 <glguy> You could do something clever with the way you implemented liftIO in a custom state-like monad supporting IO
19:30:59 <cfoch> hi
19:31:02 <glguy> but not using generic StateT
19:31:03 <cfoch> is this manual old?
19:31:04 <cfoch> https://wiki.haskell.org/GHC/As_a_library
19:31:12 <Rotaerk> http://lpaste.net/21906046901551104  <- my "AtomicT" transformer
19:31:30 <Rotaerk> I realized that it doesn't apply the rollbacks if an exception is thrown
19:31:43 <rabipelais> Hi people, I have a problem with the error "The type variable is ambiguous" (without "context"). What I want to do is get the string value of a type level literal, and I have this:
19:31:51 <Rotaerk> so I was trying to find a way to do that, but... looks like I might have to replace my usage of StateT with something else
19:31:55 <rabipelais> bar :: (KnownSymbol n) => Foo (n :: Symbol) v -> String;   bar _ = symbolVal (Proxy :: Proxy n)
19:32:12 <cfoch> forget it
19:33:02 <Axman6> rabipelais: looks like you need ScopedTypeVariables
19:33:08 <hacker> rabipelais: you'd need to use ScopedTypeVariables to let that "new" n be the same as the one in the type signature
19:33:09 <shachaf> rabipelais: The n in the definition isn't related to the n in the type signature.
19:33:17 <funfunctor> hi
19:33:18 <rabipelais> But I get the error "Could not deduce (KnownSymbol n0) ... from context (KnownSymbol n)...n0 is ambiguous" so I assume that it isn's binding the n on the right with the n on the left?
19:33:26 <shachaf> Turn on ScopedTypeVariables and put "forall n." as the beginning of the signature.
19:33:36 <Rotaerk> I think I woke up the channel
19:33:39 * Rotaerk is proud.
19:33:39 <funfunctor> Anyone with much experience in the network package?
19:33:48 <Axman6> rabipelais: the n in the type signature is a different n to the n in the Proxy type
19:34:00 <Axman6> unless you have ScopedTypeVariables
19:35:50 <EvanR> this is awesome
19:36:30 <EvanR> obviously if you accumulate increments of 0.1 or 0.01 in a Double, youll accumulate drift, in a particular direction
19:36:46 <EvanR> so i changed it to be n * 0.1 where n is an incrementing counter
19:36:58 <EvanR> now it drifts, but oscillates around the right number
19:37:28 <funfunctor> why is send :: Socket -> String -> IO Int  String and noy ByteString?
19:37:54 <glguy> funfunctor: There's a ByteString module in the package, also
19:38:24 <funfunctor> glguy: are we talking about network here?
19:38:40 <glguy> yeah
19:39:08 <funfunctor> glguy: which interface should I be using Network.Socket or Network.BSD ?
19:39:36 <glguy> They are different
19:39:45 <glguy> But generally you'll use Network.Socket
19:39:57 <glguy> and send recv from Network.Socket.ByteString
19:40:19 <rabipelais> Axman6: ScopedTypeVariables doesn't seem to help. I thought that it somehow didn't work because I was doing it in ghci, but I tried it in its own file and that's the error
19:40:32 <shachaf> rabipelais: 19:30 <shachaf> Turn on ScopedTypeVariables and put "forall n." as the beginning of the signature.
19:40:33 <EvanR> watching the lowest bits of floats do their thing is so weird
19:40:59 <glguy> and also 'v'
19:41:24 <hacker> rabipelais: did you add "forall n." to the type signature?
19:41:51 <shachaf> Yes, v would be good too.
19:42:05 <shachaf> This can also be accomplished without ScopedTypeVariables, by the way. But it's more awkward.
19:42:14 <funfunctor> EvanR: strange attactors?
19:43:12 <rabipelais> shachaf: oh, I hadn't seen your comment. Using forall n a worked. Why does one need that?
19:43:29 <rabipelais> I meant forall n v
19:43:40 <shachaf> To indicate to GHC that the type variable should be scoped.
19:44:15 <shachaf> Scoped type variables break compatibility with Haskell 2010.
19:45:24 <rabipelais> Oh, I see. Thank you very much. Is it possible to do without scoped type variable
19:45:27 <rabipelais> ?
19:45:36 <glguy> [02:39] shachaf: This can also be accomplished without ScopedTypeVariables, by the way. But it's more awkward. 
19:47:16 <rabipelais> Thanks, I found a link on the wiki to a mailing list thread. It is indeed more awkward.
19:47:34 <sm> evening all
19:47:41 <glguy> asTypeOf 07:: a 07-> a 07-> a; asTypeOf x _ 07= x
19:47:48 <glguy> You do tricks like this to link types of arguments
19:48:56 <EvanR> im wrong, its damn exact, not oscillating, was looking at the wrong code
19:49:07 <sm> dash (osx) and dash-haskell seem great. How do you make dash-haskell generate docs for a package in the global cabal user db ? It complains about missing haddocks despite installing with --enable-documentation
19:49:58 <rabipelais> glguy: how would that work with phantom types?
19:50:39 <rabipelais> for example in my snippet above the data type would be "data Foo (n :: Symbol) v = Foo v"
19:51:46 <glguy> fooProxy 07:: Foo n v 07-> Proxy n; fooProxy _ 07= Proxy
19:52:47 <sm> hmm, but the html documentation directory reported by ghc-pkg describe PKG does not exist
19:55:29 <rabipelais> I see, thanks
19:56:29 <shachaf> Remember Oleg's trick at http://okmij.org/ftp/Haskell/partial-signatures.lhs ?
19:58:54 <rabipelais> That's actually pretty clever
20:00:16 <monochrom> interesting
20:05:12 <carter> thats a cute trick
20:10:54 <sm> why would cabal install --reinstall --force --enable-documentation optparse-applicative, with documentation: True and most of the haddock options True in ~/.cabal/config, still not be generating documentation ?
20:19:09 <sm> this would explain why ghc-pkg check is always complaining about missing haddocks
20:22:01 <carter> sm: which haddock is in scope
20:22:04 <carter> what ghc version
20:22:47 <sm> carter: ghc-7.8.4, haddock-2.14.2, cabal-1.22 (or 1.20)
20:22:53 <carter> what OS?
20:22:55 <carter> what installer?
20:24:11 <sm> osx, ghc was installed via brew or ghc binary or emacsformacosx (sorry I forget :)
20:24:55 <carter> sm: .... never use brew for installing ghc
20:25:05 <carter> sm: use either the official bin dist
20:25:12 <carter> or ghc for os x by etrepum 
20:25:26 <carter> while brew seems to have gotten better, i'm still distrustful for now
20:26:29 <sm> the brew ghc is not linked, so I think this was the official binary
20:26:36 <sm> binaries
20:27:08 <sm> anyway, this does not excuse cabal from it's bad behaviour
20:27:37 * sm gives cabal a pep talk
20:27:48 <carter> lacking more info, i'm gonna asume you've got a bad install :)
20:28:09 <carter> do you ahve a up to date haddock in your path
20:28:12 <carter> or too old a haddock
20:28:27 <sm> 2.14.2, which seems not too old
20:28:44 <sm> and there's not sign of a haddock error or even a haddock invocation in the -v output
20:29:59 <carter> i'm on 2.15
20:30:38 <carter> might i suggest doing: cabal install cabal-install ; cabal install happy alex ; cabal install haddock ; rm -rf ~/.ghc/  ; cabal install cabal, 
20:30:50 <carter> then allyour pkgs and docs should build fine
20:31:06 <carter> thats my "make sure i'm in the right universe of versions of tools"
20:31:19 <carter> roughly
20:31:33 <sm> yeah.. I feel pretty clean and up to date, but I'll keep that in reserve
20:31:54 <carter> sm: whats your ~/.cabal/config look like?
20:32:31 <sm> I'm currently using a brand new one, cabal user-config diff shows nothing
20:32:43 <carter> ok
20:33:16 <lpaste> funfunctor pasted “No title” at http://lpaste.net/126069
20:33:20 <sm> my usual one has documentation: True, executables: True, html: True etc.
20:33:33 <funfunctor> what is the issue with this network UDP example?
20:34:00 <Slay> hey, Im new to functional programming. should I use recursion for pretty much everything Ive used loops before?
20:34:07 <funfunctor> It just throws the exception Client.hs: getAddrInfo: does not exist (Name or service not known)
20:34:45 <funfunctor> Slay: sometimes, also check out fold
20:34:54 <funfunctor> :t fold1r
20:34:55 <lambdabot>     Not in scope: ‘fold1r’
20:34:55 <lambdabot>     Perhaps you meant one of these:
20:34:55 <lambdabot>       ‘foldr’ (imported from Data.List),
20:34:57 <carter> sm: ... doyou really want haddocks built for the test suites and executables of every proram?
20:35:18 <sm> maybe not, I'm just trying to make something happen
20:35:21 <funfunctor> :t foldr1
20:35:21 <lambdabot> (a -> a -> a) -> [a] -> a
20:35:35 <sm> this has certainly worked here in the past
20:35:52 <carter> sm: i suggest trying newer haddock
20:35:59 <carter> what does cabal --version say?
20:36:21 <sm> 1.22.0.0
20:36:44 <Slay> funfunctor: hm, fold wont work for what I want to do atm. any chance you could help me out a little with syntax?
20:36:47 <carter> ....  i know it has 2 lines
20:37:18 <funfunctor> Slay: well since I don't know what your doing and you asked a very general question thats all the input I can give you really
20:37:20 <sm> same result with the latest haddock
20:37:30 <monochrom> Slay: you can use lists and Data.List functions in place of obvious loops.
20:38:32 <sm> I guess it's karma for overworking, I must placate the gods
20:38:33 <glguy> Funfunctor I'll help you with that network paste in about 15 minutes if you don't get someone else first
20:38:47 <funfunctor> glguy: thx
20:40:46 <sm> if I cabal install inside the optparse-applicative source, it installs the docs alright
20:41:07 <nocturne777> I see arguments on the net that sometimes an algorithm maybe be better implemented in an imperative language due to the purity of Haskell.  is there any truth in such claims ?
20:41:44 <funfunctor> nocturne777: do you mean problem domain or algorithm
20:41:58 <nocturne777> funfunctor: algorithm
20:42:02 <funfunctor> nocturne777: then no
20:42:46 <sm> psh, now it's working
20:43:08 <funfunctor> nocturne777: thats like claiming mathematics is "too pure" to express algorithms in
20:43:17 <Slay> ok, so what I want to do is I have 2 vars (x and y in two lists). I need to increase/decrease the values of one of theese arrays(by 1) to get it matching with the other array. 
20:43:17 <carter> sm: .... are you using a sandbox?
20:43:27 <Slay> can someone help me with the syntax? http://lpaste.net/1931456628486307840
20:44:38 <funfunctor> Slay: ok first of all you are missing something deeper than syntax
20:44:45 <sm> carter: no, I've not been inside a sandbox
20:44:53 <funfunctor> Slay: you are mixing non-pure and pure operations together
20:44:58 <funfunctor> :t putStrLn
20:44:58 <lambdabot> String -> IO ()
20:45:01 <carter> sm: when you type "which ghc" what do you get?
20:45:06 <sm> 7.8.4
20:45:11 <nocturne777> funfunctor: laziness I think plays a crucial role in writing algorithms efficiently in Haskell, I think
20:45:14 <funfunctor> Slay: putStrLn is a *action* not a function.
20:45:28 <carter> sm: .... you're not typing what i suggested
20:45:31 <carter> :)
20:45:45 <nocturne777> :t printStrLn
20:45:45 <lambdabot>     Not in scope: ‘printStrLn’
20:45:46 <lambdabot>     Perhaps you meant one of these:
20:45:46 <lambdabot>       ‘putStrLn’ (imported from Prelude),
20:45:48 <Slay> I'll look that up.
20:45:55 <sm> oh.. /usr/local/bin/ghc
20:46:00 <nocturne777> :t getLine
20:46:01 <lambdabot> IO String
20:46:03 <funfunctor> nocturne777: functional really has little to do with laziness.
20:46:23 <carter> nocturne777: IO stuff is hiddent from lambdabot 
20:47:49 <nocturne777> funfunctor: when implementing a red-black tree,  to re-balance the tree one can easily modify the structure in the imperative language, how would one go about in haskell? I am not asking for an implementation
20:48:00 <nocturne777> just a brief explanation is sufficient
20:48:25 <funfunctor> Slay: also (>) is polymorphic which means as long as list is an instance of Ord (which it is) you can just compare lists directly
20:48:35 <funfunctor> :t (>)
20:48:36 <lambdabot> Ord a => a -> a -> Bool
20:49:51 <funfunctor> nocturne777: you try do encapsulate the structural propositions into the type rather than imperatively /describe/ the fashion in which you to do things to gain structure.
20:50:11 <carter> nocturne777: you rebuild the spine down to the part youre rebalancing
20:50:12 <ttt_fff> is discrete FRP easier to impelemnt than continuous FRP ?
20:50:23 <carter> ttt_fff: what does continuous mean :)
20:50:41 <ttt_fff> ttt_fff: continuous means, behavior is somethign like Time -> BLAH, then you sample the Time at discrete points
20:50:43 <monochrom> probably "discrete time" and "continuous time"
20:50:49 <ttt_fff> discrete means = your events are things like mouse clicks / key presses
20:50:50 <Slay> funfunctor: in this case, I have 4 vars which Im trying to group into 2 lists just for readability. not sure if what Im doing is correct at all
20:50:53 <ttt_fff> monochrom++
20:51:08 <glguy> funfunctor: First issue is that you don't use "connect" with UDP
20:51:18 <carter> what does continuous time mean :)
20:51:24 <shachaf> In a discrete world, everything is continuous.
20:51:25 <glguy> funfunctor: and you'd want a "Datagram" socket
20:51:32 <carter> shachaf: :)
20:51:42 <funfunctor> Slay: 
20:51:42 <monochrom> oh haha
20:51:49 <funfunctor> > map (+1) [1,2,3]
20:51:50 <lambdabot>  [2,3,4]
20:51:56 <ttt_fff> because the union of arbitary open sets = open ?
20:52:18 <monochrom> over a discrete topology, every function is a continuous function
20:52:27 <Slay> yup, Ive done the haskell.org tutorial. I like map a lot :)
20:52:38 <funfunctor> Slay: | a < b = map (+1) a
20:52:43 <shachaf> Every function from a discrete space is continuous, in particular.
20:52:57 <funfunctor> glguy: ok thx
20:53:11 <shachaf> Because continuity is about which information you can observe. And in a discrete space everything is observable.
20:53:24 <Slay> funfunctor: that makes sense
20:53:47 <funfunctor> :t otherwise
20:53:48 <lambdabot> Bool
20:53:52 <funfunctor> Slay ^
20:55:33 <sm> I'm really confused. Sometimes it builds the haddocks, sometimes not. When it does build them, sometimes it says "updating documentation index", sometimes not
20:56:09 <sm> I'd better step away. Thanks for your help carter
20:56:44 <funfunctor> glguy: http://lpaste.net/126090 still trying to get this to work
20:57:15 <lpaste> glguy annotated “No title” with “fixes for funfunctor” at http://lpaste.net/126069#a126091
20:57:25 <funfunctor> glguy: basically I am trying to make a REPL behind a UDP control socket
20:57:58 <glguy> funfunctor: check out that paste annotation
20:58:14 <funfunctor> thx
21:00:41 <funfunctor> glguy: and I guess I messed up the server in places too
21:00:49 <funfunctor> I can't send messages to the client
21:01:11 <carter> sm: we'll try again some other time
21:02:00 --- mode: ChanServ set +o glguy
21:02:01 --- mode: glguy set -bbbb *!*@176.96.167.187 *!*@202-180-112-138.callplus.net.nz *!*@112.145.28.107 *!~nend@89.254.149.213
21:02:01 --- mode: glguy set -bbbb *!~dfgdfgdf@71-12-251-87.dhcp.slid.la.charter.com *!~ffdgdfg@93.93.199.220 *!~dfgdfgdsf@pta27-1-88-178-25-84.fbx.proxad.net *!*dffdfdf@*.143.broadband15.iol.cz
21:02:01 --- mode: glguy set -bbbb *!*@180.96.16.69 *!*@178.32.172.65 *!~ircap@155.Red-2-138-166.dynamicIP.rima-tde.net *!*@c-98-213-119-60.hsd1.il.comcast.net
21:04:04 --- mode: glguy set -bbbb *!*@nat-35.kuz.sibset.net *!*@77.Red-2-138-167.dynamicIP.rima-tde.net *!*tumaru@*.Red-81-37-44.dynamicIP.rima-tde.net *!*@dhcp-225-161.eastdorm.uic.edu
21:04:05 --- mode: glguy set -bbb *!*@*.Red-2-138-161.dynamicIP.rima-tde.net *!*ircap@*.Red-79-147-187.dynamicIP.rima-tde.net *!*@546AAAD8.cm-12-3c.dynamic.ziggo.nl
21:04:54 <glguy> funfunctor: paste the other half of the code too, if you want
21:05:13 <funfunctor> glguy: I did, hold on i'll seperate it out
21:05:41 <carter> sm: we'll try again some other itme :)
21:05:45 <lpaste> funfunctor pasted “No title” at http://lpaste.net/126099
21:05:54 <funfunctor> glguy: ^
21:06:31 <glguy> funfunctor: That's using Stream sockets again. You said you wanted UDP earlier, but are you sure you don't want TCP?
21:06:48 <funfunctor> glguy: I want UDP yes, i'm just very confused..
21:07:15 <glguy> OK, UDP doesn't use: connect, listen, or accept
21:08:03 <EvanR> @hoogle [Maybe a] -> Maybe a
21:08:05 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
21:08:05 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
21:08:05 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
21:08:22 <glguy> the server will need to bind to a specific/known port, but the client doesn't need to do that. A dynamic address will do
21:08:36 <geekosaur> udp can use connect, it lets you use send/recv instead of sendto/recvfrom. there is no listen/bind/accept
21:09:03 <glguy> UDP *can* use bind, jsut not with listen/accept
21:09:18 --- mode: glguy set -o glguy
21:09:35 <glguy> but yes, you can use connect to set the remtoe address to avoid sendTo
21:09:46 <EvanR> hoogle actually gave me the right answer
21:10:05 <geekosaur> note that using connect on your main socket is a bad idea since you're only going to be able to talk to one client from that point on. only do it if you respond to a query from a client by creating a new socket and telling the client to continue on that socket (as tftp does). this may be more complex
21:14:20 <ttt_fff> how the fuck do I learn how to impelment frp ?
21:14:25 <ttt_fff> this seems ahrder to learn than monads
21:14:38 <EvanR> haha
21:14:54 <EvanR> ttt_fff: start trying
21:15:15 <EvanR> monads <---------------------------> frp
21:15:16 <ttt_fff> EvanR: do you teach your kids how to swim by flying them out in a helicopter and throwing them into the middle of the ocean?
21:15:54 <EvanR> try looking at existing implementations
21:16:11 <EvanR> perhaps old versions which might be simpler
21:16:39 <naudiz> Haskel documentations be like: read the library's source 
21:17:05 <EvanR> "how to implement frp" is probably not a documentation issue
21:17:16 <ttt_fff> naudiz: I think it's like (1) read the type signature, (2) try shit, (3) read source
21:17:39 <carter> implementing an FRP is really tricky
21:18:38 <lpaste> funfunctor revised “No title”: “No title” at http://lpaste.net/126099
21:18:55 <funfunctor> glguy: ^ alright, still a little stuck
21:19:19 <naudiz> EvanR: but it's comparable I guess since the solution of the problem is quite similar
21:20:58 <naudiz> ttt_fff: sometimes it's already hard to understand (1) (especially if you don't understand monad transformers very well)
21:21:22 <ttt_fff> well
21:21:26 <ttt_fff> I just want discrete-time frp
21:21:28 <ttt_fff> fuck continuous time
21:21:46 <EvanR> wheres conal when you need him
21:22:16 <jle`> discrete time frp is not frp but it is also useful
21:22:36 <ttt_fff> jle`: I just want discrete time frp
21:22:46 <ttt_fff> where can I read up on impementing this easier discrete-time-frp ?
21:22:48 <EvanR> plenty of libraries exist for that
21:22:54 <jle`> that's like saying you want vector art but without vectors, just pixels
21:23:59 <jle`> ttt_fff: if you know what you want, then start describing your ideal interface, and we can go from there.  different domains call for different api's/interfaces
21:24:08 <carter> what do you want to SAY
21:24:15 <carter> i'll let jle`  guide
21:24:17 <carter> night all
21:24:24 <ttt_fff> jle`: so I'm plyaing with haste-compiler, and frp looks really nice
21:24:43 <ttt_fff> jle`: for some reason, I like the idea of frp-like events more than I like fb react
21:25:33 <ttt_fff> http://research.microsoft.com/apps/pubs/default.aspx?id=69665 , I think, is what I want
21:25:45 <ttt_fff> if only someone, say jle`, wrote it as a haste-compiler library, so I could try it out :-)
21:26:48 <jle`> i have a library now that is basically event stream manipulation if you want to try it out
21:27:08 <ttt_fff> jle`: sure
21:27:31 <jle`> it takes many of the denotative and declarative aspects of FRP implementations and high-level approach and applies it to discrete event domains
21:28:35 <jle`> might not be exactly what you are looking for, but https://github.com/mstksg/auto :)
21:29:48 <nocturne777> is Monad going to have the "Applicative" class constraint as of GHC 7.10 ?
21:31:21 <jle`> yes
21:32:24 <phadej> you can check the current definition at: https://github.com/ghc/ghc/blob/14b78eb7390dcf78c104501f4c24ac013a70a766/libraries/base/GHC/Base.hs#L457
22:01:14 * hackagebot broccoli 0.4.0.0 - Small library for interactive functional programs.  http://hackage.haskell.org/package/broccoli-0.4.0.0 (evanrinehart)
22:21:15 * hackagebot auto 0.2.0.2 - Denotative, locally stateful programming DSL & platform  http://hackage.haskell.org/package/auto-0.2.0.2 (jle)
22:21:17 * hackagebot broccoli 0.4.1.0 - Small library for interactive functional programs.  http://hackage.haskell.org/package/broccoli-0.4.1.0 (evanrinehart)
22:46:16 * hackagebot cmark 0.1.0.0 - Haskell bindings to libcmark, CommonMark parser and renderer  http://hackage.haskell.org/package/cmark-0.1.0.0 (JohnMacFarlane)
23:06:50 <shorugoru_> test
23:16:17 * hackagebot hashable 1.2.3.2 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.2.3.2 (JohanTibell)
23:19:35 <f|`-`|f> jesus
23:21:17 <bitemyapp> does he know Haskell?
23:26:18 * hackagebot cmark 0.1.0.1 - Haskell bindings to libcmark, CommonMark parser and renderer  http://hackage.haskell.org/package/cmark-0.1.0.1 (JohnMacFarlane)
23:29:40 <shorugoru> Test
23:31:18 * hackagebot vty 5.2.8 - A simple terminal UI library  http://hackage.haskell.org/package/vty-5.2.8 (CoreyOConnor)
23:31:20 * hackagebot envparse 0.2.0 - Parse environment variables  http://hackage.haskell.org/package/envparse-0.2.0 (MatveyAksenov)
23:32:29 <shorugoru> test
23:33:19 <shorugoru> test
23:33:26 <shorugoru_> test
23:34:47 <shachaf> shorugoru_: Please use another IRC channel to test.
23:35:12 <shorugoru> test
23:35:15 <shachaf> shorugoru: Please use another IRC channel to test.
23:35:38 <shorugoru> sorry!
23:39:49 <Rotaerk> http://lpaste.net/1033891515404910592
23:40:06 <Rotaerk> am I overabstracting here, or might bracketT actually be useful beyond these two cases...
