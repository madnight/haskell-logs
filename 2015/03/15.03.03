00:07:58 <quchen2> tzaeru: "OOP is necessary for something" for example.
00:08:59 <EvanR> confirmed uprooted
00:09:10 * hackagebot stripe-haskell 0.1.3.0 - Stripe API for Haskell  http://hackage.haskell.org/package/stripe-haskell-0.1.3.0 (DavidJohnson)
00:09:10 * hackagebot monad-parallel-progressbar 0.1.0.0 - Parallel execution of monadic computations with a progress bar  http://hackage.haskell.org/package/monad-parallel-progressbar-0.1.0.0 (mnacamura)
00:10:18 <EvanR> the future is now: we have progress bars
00:10:35 <quchen2> Parallel ones!
00:12:50 <tzaeru> quchen2, well, I don't really know haskell enough to have much of an opinion on OOP and how Haskell would like to solve the actual issues for which OOP was developed.
00:13:16 <EvanR> the actual issue was GUI programming
00:13:34 <EvanR> today not usually considered the main use case for oop
00:14:11 <tzaeru> I mainly work with graphics and games and the topics relevant to that (+ some server programming now and then). to me, haskell hasn't exactly yet given any great insights to anything, but then, I don't know it well yet.
00:14:11 <f|`-`|f> What the hell is Stripe Haskell
00:14:18 <tzaeru> it seems very good to have for a certain domain of problems though
00:14:29 <f|`-`|f> Also, the best progress bars are the torrent ones
00:14:31 <tzaeru> like simulation or math stuff and so on
00:14:38 <tzaeru> but I just don't really work much in those domains
00:14:55 * f|`-`|f shrugs
00:15:04 <f|`-`|f> ever look at manatee and xmonad?
00:15:06 <EvanR> im working on a GUI program, i cant wait to use insight
00:15:08 <f|`-`|f> It can do some crazy things
00:15:23 <EvanR> because all toolkits are horrible
00:15:35 <f|`-`|f> I don't know how to use an IDE
00:15:44 <tdammers> haskell shines at DSLs, both embedded and standalone
00:16:10 <tdammers> so much that applying a DSL approach to problems that are typically solved in some other way sometimes proves a better solution, even
00:16:51 <f|`-`|f> Like with the group that made a more efficient wide fast carry for fpga's
00:16:54 <f|`-`|f> in 2014
00:17:08 <f|`-`|f> ... it used less circuits, or something
00:17:30 <EvanR> number of circuits, is like that like of lines of code ;)
00:17:37 <EvanR> number of
00:18:35 <f|`-`|f> well in this case, the less circuits the more you can use for other purposes, since fpga's are comparable to tetris
00:18:42 <f|`-`|f> and sudoku
00:19:00 <EvanR> ah right, units
00:19:05 <EvanR> logic units
00:19:25 <f|`-`|f> which is why they have significant performance hits compared to other, less arbitrary or fluid systems
00:20:18 <f|`-`|f> I'm not sure why someone would need to go to the bleeding edge of an fpga, and exploit its reprogrammability, but I guess some people really need that
00:20:35 <f|`-`|f> I hear of multiplexed data, and evaluation, but hardware?
00:20:55 <EvanR> hardware is necessarily running in parallel
00:21:56 <f|`-`|f> Think of it like the always-online tech that some group made, where it had line-to-line parity with its programs, and you could remove whatever components you wanted
00:22:26 <f|`-`|f> Except, instead of removing them, you are reformatingthem for other specialised uses
00:22:29 <f|`-`|f> For some reason
00:23:29 <EvanR> reformat your brain
00:23:40 <f|`-`|f> The point really isn't to hypothesis about arbitrary use cases for FPGA's, the research group used two DSL's based in Haskell to do that fancy optimisation problem
00:23:49 <tzaeru> need to one day sit down and learn haskell for more than a few minutes >_>
00:24:06 * hackagebot euler 0.3.3 - Mathematics utilities for Haskell  http://hackage.haskell.org/package/euler-0.3.3 (decomputed)
00:24:31 <f|`-`|f> It really seems like the issue with haskell is that there are not enough user groups funposting about it
00:24:50 <f|`-`|f> This is the internet, it's an infinite-sum scenario
00:24:54 <tdammers> not enough hipsters
00:24:58 <f|`-`|f> No
00:25:03 <tdammers> "Monads are so 2010"
00:25:07 <f|`-`|f> Look to gaming to see why that's dumb
00:25:13 <EvanR> avoid success at all costs
00:25:14 <tdammers> yeah, ofc
00:25:15 <f|`-`|f> then rock
00:25:17 <f|`-`|f> metal
00:25:18 <EvanR> thats pretty hipster
00:25:26 <f|`-`|f> contemporary, cartoons, comics
00:25:26 <tzaeru> but what goes to OOP -- well, when used without certain ludicriousities (like rigid encapsulation and weird multiple inheritance and too long inheritance chains), I still hardly claimed to know of a better way to handle the issue of having multiple instances of same data in a manner where some parts of the data and functionality handling that data, is different. most games are a great practical example of such a case.
00:26:02 <f|`-`|f> movies, and pretty much anything that anyone made ever
00:26:11 <tdammers> tzaeru: OOP can be done in Haskell, and it can even end up more elegant than in an "OOP Language"
00:26:12 <tzaeru> f|`-`|f, I really would haphazard a guess that one big issue with haskell is really the lack of context for non-mathy programmers :P
00:26:15 <Lokathor> you mean polymorphic behaviour tzaeru ?
00:26:15 <tzaeru> also
00:26:30 <tzaeru> no offense, really, but sometimes the community around haskell feels a bit.. mmmhm.. "over-confident"?
00:26:32 <EvanR> tzaeru: there are broad topics, a lot is implied by "functional programming"
00:26:51 <tdammers> tzaeru: can you blame them?
00:27:08 <f|`-`|f> a lot of the things have their touch from, or simply are, because of the impetus to make a functional programming language
00:27:11 <tdammers> and frankly, the same goes for Ruby, Python, JavaScript/node.js, PHP, ...
00:27:12 <Lokathor> tzaeru, it depends on who you talk to. When I ask haskell questions i often get "i dunno man i don't run windows maybe it'll work" :P
00:27:16 <tzaeru> tdammers, I don't blame anyone. I merely state that there are actual issues behind why haskell isn't THE thing.
00:27:20 <f|`-`|f> also, the confidence comes from being mathematics researchers
00:27:26 <tzaeru> and the only issue isn't "well not enough people make funny posts to reddit about it"
00:27:35 <tdammers> tzaeru: yes, but haskell is not to blame for them
00:27:48 <f|`-`|f> You really can't force these kinds of things
00:27:53 <f|`-`|f> Like mainstream media does
00:27:58 <f|`-`|f> Well, tries to
00:27:59 <EvanR> tzaeru: thats a good reason to study haskell, youll have a lot of smart people to help you. you cant improve yourself without finding the next higher level to climb to
00:28:12 <tdammers> "avoid success at all cost" also involves refusing to optimize for the shallow end of the learning curve at the expense of the upper end
00:28:25 <tzaeru> EvanR, well, next time I see a tutorial that goes "all other languages are inferior" in one form or the other, I'll go postal <.<
00:28:28 <tzaeru> >.>
00:28:29 <EvanR> if you restrict yourself to java for your whole life you will master... java
00:28:33 <tdammers> Haskell is one of the languages that exceptionally smart people gravitate towards
00:28:36 <f|`-`|f> (I haven't really been asking too many experts, because I would prattle on about tangential things, and bleed them dry with questions)
00:28:42 <f|`-`|f> EvanR  R
00:28:48 <f|`-`|f> That is a fate worse than death
00:28:55 <Lokathor> I'd say that a lot of haskell's struggle lies in the fact that it's often presented poorly. specifically, it's not often presented as a thing you can use to make video games
00:29:00 <bernalex> tdammers: which is funny since haskell is so exceptionally suited for stupid people. :D
00:29:10 <f|`-`|f> ...
00:29:10 <EvanR> tzaeru: you have a link to one of these blog posts? im not doubting you i just want to see one
00:29:13 <tdammers> bernalex: suited; yes. attractive; no.
00:29:26 <tzaeru> tdammers, well, things like that kinda rub at least me the wrong way, and I would presume that I am not the only person :P
00:29:28 * f|`-`|f is not smart, nor stupid
00:29:33 <f|`-`|f> Am I ZEN?
00:29:36 <frerich> tzaeru: People who write tutorials about doing stuff in some lesser known (may I say 'niche'?) language are often somewhat passionate (or opinionated) about languages in general which is why they didn't go for something like Java in the first place.
00:29:39 <tzaeru> if you say "this language attracts exceptionally smart people", you imply that people working on other languages are likely to be less smart.
00:29:48 <tzaeru> so, in a way, you just implied that people NOT using haskell are stupid.
00:29:56 <tzaeru> that's like.. thanks, I guess?
00:30:03 <tdammers> tzaeru: that's not what I meant at all.
00:30:08 <f|`-`|f> it's not really disparaging, tzaeru
00:30:18 <f|`-`|f> It could imply that only smart people can learn haskell
00:30:25 <f|`-`|f> ie, it's obtuse
00:30:30 <tdammers> not even that
00:30:31 <tzaeru> it could, yeah.
00:30:35 <EvanR> tzaeru: haskell is only the beginning, theres a whole universe of other ideas out there. PHP javascript python and friends have just been feeding off each other for decades
00:30:43 <tzaeru> but what I am sure of that many people will understand phrases like that as somewhat degratory.
00:30:48 <tzaeru> no matter what a person -actually- meant.
00:30:57 <EvanR> its a huge distraction to progress
00:30:57 <tzaeru> what we actually mean is anyway the less important thing..
00:31:05 <f|`-`|f> Then stop complaining about perceived slights, and see for yourself
00:31:08 <bernalex> tzaeru: if you try really hard to become offended, you will be. so what.
00:31:15 <f|`-`|f> ^
00:31:23 <tzaeru> bernalex, that wasn't the point at all.
00:31:30 <f|`-`|f> Well it's what you mean
00:31:33 <f|`-`|f> :^)
00:31:45 <tzaeru> the point was that I am willing to bet on that the community of haskell is an obstacle to people getting into haskell :P
00:31:58 <tzaeru> so
00:32:07 <f|`-`|f> I think I'm a larger issue than the community at large
00:32:13 <tzaeru> signing the lack of interest to haskell as "not enough funny reddit posts" is just arrogancy from my view.
00:32:13 <MP2E> The tu[Ctorials do come off a bit strong at first, but it takes a hard sell to sell an academic language... And if you disagree after learning the language I'd be surprised :P
00:32:25 <MP2E> It's pretty amazing
00:32:25 <silver> tzaeru, how do you like C community?
00:32:25 <quchen2> I too think tdammer's statement did not reflect very well on the Haskell community.
00:32:26 <EvanR> tzaeru: they were joking
00:32:28 <f|`-`|f> I just want to find more blogs that talk about more interesting topics
00:32:33 <echo-area> tzaeru: That's not true to me, this channel is very friendly to new comers
00:33:12 <f|`-`|f> Because parsers seem neat, I still have no idea what they are for
00:33:19 <f|`-`|f> Same with topic analysis
00:33:26 <tzaeru> well, c'mon. the "where to get started" haskell wiki page links to tutorials that basically say that "other languages suck". I don't see that kind of stuff very often in like python tutorials.
00:33:37 <f|`-`|f> And this nonsense about making GUI's
00:33:44 <EvanR> is it important to worry about people who will read asenine blogger 92, "be offput", and blame a programming language that they dont know for it?
00:33:47 <f|`-`|f> and apparently, how everyone's being doing it the lazy way
00:33:49 <bernalex> tzaeru: maybe because python sucks
00:33:49 <tzaeru> to techonologically bent people, humility feels like a better selling-point than over-confidence.
00:34:15 <Fylwind> anyone seen an error like this? "cannot satisfy -package -db"
00:34:15 <tzaeru> bernalex, right.
00:34:18 <EvanR> @where learn haskell
00:34:18 <lambdabot> https://github.com/bitemyapp/learnhaskell | http://www.seas.upenn.edu/%7Ecis194/spring13/index.html | https://github.com/NICTA/course/
00:34:23 <EvanR> tzaeru: check that page out
00:34:25 <f|`-`|f> I haven't seen that "any languages" suck on the where to get started, tzaeru
00:34:53 <tdammers> all I meant is that exceptionally smart people seem to like Haskell
00:34:53 <tzaeru> seems the haskell wiki is down, would have hard time to check again
00:34:59 <tzaeru> but I do feel that I've already pointed a few of them out here earlier <.<
00:35:12 <f|`-`|f> you haven't
00:35:13 <tdammers> if you're not using Haskell, this could mean that you are not exceptionally smart, or that Haskell doesn't appeal to you for some other reason
00:35:23 <tzaeru> tdammers, that people who like haskell seem to be exceptionally smart?
00:35:27 <tdammers> no
00:35:37 <MP2E> I started learning Haskell a little over 1 year ago, and I don't remember being offput by any of the comments on the wiki or the front page
00:35:37 <tdammers> *some* people who like haskell seem to be exceptionally smart
00:35:40 <MP2E> I was encouraged, in fact
00:35:43 <tdammers> let me put it this way
00:35:59 <MP2E> I came to Haskell because I had a bunch of pet projects in C and I kept hitting random segfaults, and I was fed up with it
00:36:02 <f|`-`|f> <<if you're not using Haskell, this could mean that you are not exceptionally smart>>, what kind of fucking leap is that in logic?
00:36:06 <tdammers> on #haskell, I feel like I'm the dumbest 10% of the population
00:36:13 <tdammers> on ##php, I'm among the smartest 10%
00:36:14 <f|`-`|f> No I'm dumber
00:36:16 <tzaeru> tdammers, well, to me, "some people who like haskell seem to be exceptionally smart" sounds actually quite bit better than "some people who are exceptionally smart like haskell" :P the latter suggests that it's a quality of smartness itself to like haskell.
00:36:17 <frerich> MP2E: That surely means that you are not smart enough to use C!
00:36:20 <tzaeru> at least, suggests to me.
00:36:47 <f|`-`|f> pretty pedantic distinction, tzaeru
00:36:49 <EvanR> i started learning haskell several years ago and i havent seen very many derogatory comments at all
00:36:49 <tdammers> tzaeru: it's a completely value-neutral "some" there. Feel free to reverse it :D
00:36:52 <MP2E> frerich: I do feel that way. I've used it for over 8 years and it still feels like a miracle when something is bug free. It's a tedious grind
00:37:07 <EvanR> maybe one or two blogs, but then again i dont read many blogs
00:37:12 <frerich> MP2E: :-)
00:37:21 <bernalex> tzaeru: what are you trying to achieve here really? I suggest you go learn haskell instead. :-]
00:37:31 <MP2E> I can write C but with Haskell around.... I mean... It's a no brainer :P
00:37:51 <tdammers> C takes a lot of discipline
00:37:56 <tzaeru> bernalex, I guess I don't try to achieve much. I just feel that it's a bit counter-productive to ascribe the lack of popularity purely to reasons that are not strictly in the hands of the community and involved people.
00:38:23 <tdammers> tzaeru: lack of popularity is, at least in part, a choice
00:38:46 <bernalex> tzaeru: the lack of popularity is well-understood and accepted in the haskell commmunity. I don't know what reasons you are whinging about; I haven't followed this buffer long enough. :)
00:38:51 <tdammers> tzaeru: again, part of the appeal of haskell is that the community refuses to dumb things down at the expense of power users
00:39:19 <tdammers> or, put more value-neutrally, the community refuses to sacrifice correctness for a shallower learning curve
00:39:38 * EvanR chooses not to be offended by language features and programming concepts he doesnt understand
00:39:42 <tzaeru> bernalex, the thing mostly started from the suggestion that haskell's lack of use was mostly due to reasons of no enough interesting/funny/catchy posts about it on the intterwebs. which, I am sure, may have been more or less an off-hand joke.
00:39:45 <EvanR> and theres still a lot
00:39:58 <bernalex> tzaeru: that would have been a joke, yes.
00:40:21 <tdammers> one consequence of this is that the first steps are harder, because the language doesn't play pretend to pick you up in your ill-defined (and at least partially wrong) assumptions and intuitions
00:40:23 <bernalex> that is a symptom not a cause of not being popular.
00:40:54 <bernalex> tdammers: unless you are reading a monad tutorial about burritos :(
00:41:06 <tdammers> another consequence, however, is that are hardly any wrong design decisions to work around later in the process
00:41:13 <tdammers> bernalex: burritos are not part of the Report
00:41:26 <tdammers> bernalex: there's a difference between designing a language wrong, and explaining it wrong
00:41:27 <bernalex> tdammers: people don't learn haskell via the report.
00:41:39 <bernalex> tdammers: yes, I am referring to the latter, which is still a problem.
00:41:59 <tdammers> bernalex: absolutely, but it would be worse if the language actually included a Burrito keyword
00:42:13 <acetoline> it's not that people working on other languages are less smart
00:42:27 <acetoline> it's that they just have less experience and have thought less deeply about language design
00:42:58 <EvanR> thats the same sentiment you get from clojure and nobody is calling them out on it
00:43:10 <EvanR> not that they should, but haskell gets flak instead
00:43:11 <bernalex> acetoline: yeah. I frequently hear things like "restricting IO is stupid. I'm smart enough to do that by dicipline only!"
00:43:16 <acetoline> of course there are languages other than haskell that are being developed by smart and experienced people
00:43:34 <acetoline> but those don't include php or javascript
00:43:43 <Lokathor> bernalex, well understood in the "i'm aware it's not popular" sense, yes. in terms of knowing what to do to become more popular, not so much
00:44:00 <frerich> acetoline: OTOH, I think it's safe to claim that Haskell is the way it is *because* previously people using other languages have a lot of experience and thought deeply about language design (the whole "standing on the shoulders of giants" thing).
00:44:12 <sgronblo> I always envisioned Clojure programmers thinking "I dont wanna learn monads, so impurity is much more practical to me"
00:44:14 <acetoline> frerich, absolutely
00:44:27 <bernalex> Lokathor: sure we know about that. and have historically done things to go in that direction. cabal, hackage & the platform being big examples.
00:44:48 <acetoline> frerich, I definitely haven't given as much thought to language design as Hindley or Milner or Peyton-Jones
00:44:51 <EvanR> sgronblo: monads in clojure give you as sense that it is incredibly pointless
00:44:52 <Lokathor> bernalex, cabal is... hmmm, not sure about that one
00:45:04 <acetoline> but I can still tell that THEY have
00:45:08 <tdammers> matter of personal preference, also
00:45:33 <frerich> acetoline: I'm even way beyond, say, Larry Wall or Guido van Rossum.
00:45:42 <tdammers> e.g., fast cycles of change-reload-check have been shown to be a major factor in programmer productivity
00:45:48 <acetoline> frerich: way beyond?
00:45:50 <tzaeru> bleh, I guess I'm still too interested in this to actually part the channel <.<
00:46:02 <frerich> acetoline: Err, way behind. In terms of experience and consideration given to language design.
00:46:11 <tdammers> haskell is lacking a bit in this regard
00:46:19 <EvanR> tdammers: is it?
00:46:20 <tdammers> I don't mind, because the benefits outweigh this
00:46:22 <tdammers> EvanR: yes
00:46:24 <Cale> tzaeru: Why ever part the channel? :D
00:46:26 <acetoline> frerich: you have to consider the constraints of the time
00:46:39 <Lokathor> i dont' think haskell is particularly lacking in turnaround time
00:46:49 <tdammers> EvanR: with PHP, I change a line of code, hit "reload" in the browser, and immediately see the results
00:46:49 <Lokathor> it depends on the scale of your project more than anything else
00:46:53 <acetoline> frerich: when python was designed, MINIcomputers struggled with functional programs, and forget about doing proper functional stuff on a microcomputer
00:47:07 <acetoline> plus ghc didn't really exist
00:47:17 <EvanR> tdammers: ok but try to quick reload a php module and check liek you would in ghci
00:47:24 <EvanR> with :reload
00:47:26 <acetoline> for the time, I maintain that languages like perl and python were good design choices
00:47:34 <tdammers> EvanR: sure, there are other things that are faster
00:47:47 <tdammers> ghci :reload is faster than writing another unit test
00:47:50 <acetoline> sgronblo: well, the lisp culture is somewhat different; they like dynamic typing and interpretation and scripting
00:48:21 <acetoline> dynamicity is great when you're generating a lot of code at runtime
00:48:22 <EvanR> tdammers: the building the entire application then navigating a GUI to the feature in question, then using said feature from the beginning of the UI sequence... thats slow regardless. and kind of terrifying when the bug is on the function level
00:49:40 <EvanR> haskell web apps i guess have a significant constant factor reload
00:49:50 <tdammers> EvanR: it really depends what you're working on. When you're building a web application, and you forgot to add a '<br/>' in one of your templates, having to do a recompile can be really annoying
00:50:08 <sgronblo> i think dynamic language programmers probaby reason by the same logic as many religious people do. my religion must be correct because i belong to it.
00:50:22 <EvanR> yeah so concentrating specifically on web apps (not even static sites) PHP has one out of 100 things better off than haskell ;)
00:50:33 <tdammers> what I tend to do is that I have a configuration option somewhere that determines whether templates and static assets are served dynamically (i.e. reparsed and recompiled all the time) or statically
00:50:55 <tdammers> and again, bottom line is still strongly in favor of haskell for me
00:50:58 <EvanR> seems kind of like grasping though
00:51:08 <tdammers> it is a real concern for me
00:51:18 <tdammers> and I can see how people aren't willing to give it up
00:51:20 <tdammers> is all
00:51:24 <xandaros> EvanR: at least snap can reload templates on the fly in  development mode
00:51:37 <tdammers> (fwiw, I am currently in the process of rage-quitting PHP)
00:51:40 <acetoline> anyway I have a question about generating types
00:51:48 <tzaeru> sgronblo, ......no.
00:51:52 <acetoline> I know that the 'primitive' for construction a function type (->) is the lambda
00:51:56 <sgronblo> tzaeru: no?
00:51:58 <EvanR> tdammers: right but trying to consider your concern, i cant get past how easily it is to ghci check a module, and how hard it is in anything else ;)
00:52:08 <tdammers> yeah
00:52:08 <acetoline> and the 'primitive' for constructing recursive types is recursive function application
00:52:21 <acetoline> what's the primitive for construction sum types?
00:52:24 <tdammers> well, in all fairness, ipython is about on par with ghci as far as interaction goes
00:52:44 <EvanR> i havent really used python3
00:53:06 <EvanR> python2 contributed to my current level of insanity though
00:53:10 <tdammers> hehe
00:53:14 <sgronblo> tzaeru: im open to the possibility that you have made your choice differently but ive read through quite a few misguided hacker news and reddit comments and blog posts about the topic.
00:53:17 <tdammers> well, the language itself isn't really great
00:53:26 <tdammers> except maybe for quick explorative coding
00:53:33 <silver> he left some time ago
00:53:35 <echo-area> EvanR: Where does the insanity come from?
00:53:45 <silver> oh he's back
00:54:04 * EvanR likes exploitative coding
00:54:06 <frerich> acetoline: I'm not quite sure what you mean by 'primitive' (the 'lambda is the primitive for constructing function types' makes me feel a bit uneasy), but I guess 'data' is not an acceptable response.
00:54:29 <acetoline> frerich: of course not, I'm talking about types-from-terms
00:54:52 <acetoline> I guess this is more a question about type theory than haskell
00:55:17 <Cale> acetoline: The data constructors of the given sum type are how you construct values of a sum type
00:55:17 <merijn> acetoline: The primitive for sum types is...sum types
00:55:21 <EvanR> echo-area: python? trying to apply folklore intensive notions of OOP in a language desribe as OOP that really cant express folklore or its own oop
00:55:40 <merijn> acetoline: You might be in the market for TaPL
00:55:43 <merijn> @where tapl
00:55:43 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
00:55:46 <acetoline> Cale: what I mean is, the lambda gives you a term which has the type a->b
00:56:03 <Cale> acetoline: e.g. Left and Right are the primitive means of constructing values of type Either a b
00:56:24 <Cale> Just as lambda is the primitive means of constructing values of type a -> b
00:56:31 <merijn> acetoline: ADTs basically let you introduce new primitives, the constructors being the primitives for making their values
00:57:08 <acetoline> I thought constructors generated product types
00:57:15 <tdammers> EvanR: interesting... my gripes with python are a lot more practical
00:57:16 <acetoline> not sum types
00:57:20 <merijn> acetoline: Both
00:57:30 <merijn> acetoline: ADTs can do sum types, product types and both
00:57:32 <tdammers> EvanR: particularly how it's just a tiny bit too simple in many ways
00:57:45 <acetoline> can you give an example of a constructor that generates a sum type?
00:57:47 <merijn> acetoline: "Either a b" is a sum type, "(a,b)" is a product type
00:57:51 <Cale> acetoline: I gave you two
00:57:53 <tdammers> and that makes Python programming unnecessarily complex
00:57:57 <acetoline> aha, I think I got it
00:57:59 <merijn> "data Either a b = Left a | Right b"
00:58:05 <Cale> Left and Right are the constructors of the sum type Either a b
00:58:09 <merijn> acetoline: Because it's either 'a' or 'b'
00:58:15 <acetoline> but you still need the primitive 'Either'
00:58:15 <tdammers> acetoline: the concepts are easier to grasp if you think of a type as the set of its possible values
00:58:23 <acetoline> Cale: yeah I didn't read that carefully enough
00:58:27 <Cale> acetoline: That's at the type level...
00:58:41 <Cale> acetoline: You still need (->) at the type level to construct function types
00:58:54 <tdammers> acetoline: Bool has 2 possible values. (Bool, Bool) has 2 * 2 possible values. Either Bool Bool has 2 + 2 possible values.
00:59:08 <merijn> acetoline: Right, which is why I mentioned that ADT add new primitive types to your language
00:59:12 <EvanR> take the set version of types with a grain of salt though
00:59:24 <acetoline> Cale: so Either is just a symbol, like ->
00:59:26 <tdammers> ofc
00:59:31 <merijn> acetoline: Yup
00:59:35 <acetoline> neat
00:59:48 <tdammers> they are not sets in the sense that you can perform arbitrary set operations on them
01:00:01 <acetoline> tdammers: I don't think you're following this discussions
01:00:03 <merijn> acetoline: Anyway, I linked TaPL earlier, it covers a lot of the basics of types and programming languages (how surprising, given it's title ;))
01:00:04 <acetoline> discussion*
01:00:44 <EvanR> tdammers: but also you cant say the number of elements of A -> Bool is A^2
01:00:48 <EvanR> i mean 2^A
01:00:57 <merijn> acetoline: It's a neat book, it starts with simply-typed lambda calculus and then introduces various extensions, like additional types, etc. and show how to typecheck them and prove your type system sane
01:01:20 <acetoline> yeah I read a bit about stlc and system f
01:01:25 <acetoline> thanks, looks interesting
01:01:50 <tdammers> EvanR: no, that's true
01:02:11 <frerich> merijn: Sounds interesting, do you think it would be useful to somebody who didn't actually get to enjoy multiple years of university education :-}
01:02:12 <EvanR> it doesnt work for some recursive types
01:02:44 <tzaeru> sgronblo, well, I'm not sure who are "dynamic language programmers", but I haven't really seen programmers I know of, who work a lot on dynamic languages, be particularly religious over dynamic languages :P
01:02:46 <merijn> frerich: Yes, if you understand basic/intermediate haskell you probably have a sufficiently basic understanding to follow what's going on
01:02:48 <tdammers> EvanR: no, but anyway, it does explain why the names make sense
01:02:49 <EvanR> unless maybe you are only talking about computable functions
01:02:57 <EvanR> tdammers: which names?
01:03:06 <merijn> frerich: Although you might need to do more exercises to get a feel for doing things in lambda calculus
01:03:23 <merijn> frerich: Bonus, it comes with implementations of type checkers/inferers for all discussed type systems too :)
01:03:25 <tzaeru> if I was still in uni, I'd totally go 'n take the haskell course we had <.<
01:03:30 <EvanR> tzaeru: ah well, they are pretty vocal on blogs, the same kind of blogs youre complaining about ;)
01:03:31 <tzaeru> I suck in learning completely new things without proper context.
01:03:49 <tzaeru> but usually a human teacher can create an appropriate context.
01:03:57 <merijn> frerich: (They're written in ocaml, but they only use a sufficiently basic subset of ocaml that it should be readable to any beginner haskeller without even reading an ocaml intro)
01:04:09 <EvanR> tzaeru: its a good idea to learn to learn stuff without a teacher, most teachers suck
01:04:22 <tzaeru> EvanR, eh, I've learned most that I know without an actual teacher.
01:04:24 <xandaros> tzaeru: was an obligatory module at my uni and in glad it was
01:04:26 <Cale> tzaeru: These lectures might be useful to you http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html
01:04:47 <tdammers> EvanR: "sum type" / "product type"
01:04:51 <EvanR> ah
01:04:51 <Cale> tzaeru: Also, feel free to ask any questions about the language that you might have. Beginner questions are always welcome.
01:05:06 * frerich happily acknowledges that tzaeru gets to enjoy the friendlyness of the Haskell community. :-)
01:05:09 <acetoline> Yeah I ask beginner questions all the time
01:05:42 <tzaeru> I actually ended up quitting uni due to having programmer as a hobby since being a wee kid, and we had poor chances at the uni to write off courses with exams or stuff without participating all the content of the course :/
01:06:03 <tzaeru> *programmed
01:06:23 <acetoline> sounds a bit arrogant :p
01:06:39 <tzaeru> sounds like someone who's lazy and with poor discipline.
01:06:41 <tzaeru> that's me, by the by
01:07:45 <tzaeru> of course there was good stuff too, but all the mandatory "aaand now we'll do a tic-tac-toe in java"-like courses just were hugely uninspiring.
01:07:45 <acetoline> hey I sat through our uni Pascal course
01:07:54 <tdammers> examing out of courses isn't arrogant IMO
01:08:49 <EvanR> tzaeru: youre right that sounds awful
01:09:11 <tzaeru> I requested that option a few times and was responded with "that's generally not customary". which really meant "noup. nevah"
01:09:30 <EvanR> "no we want you to pay us for what we want to sell you"
01:10:12 <tzaeru> I think that recently many universities here have felt a requirement to accomplish things with more structure and with higher streamlining. it's a shame.
01:10:27 <tzaeru> but that's what happens when state support is lowered and unis are required to get private sponsor money, heh :P
01:10:28 <ibid> our introductory programming teachers have this notion that people who have programmed before are the hardest to teach, because they have usually learned stuff all wrong
01:10:41 <ibid> but they still allow examinng out
01:10:51 <ibid> (well, with a project and an exam)
01:10:52 <tdammers> can't really blame them
01:11:11 <tdammers> I bet enough freshmen actually do have a background of having learned everything wrong
01:11:12 <tzaeru> I guess that could be a valid point in certain contextes, but I can't really say that the quality of teaching was top-notch either. average CS department of a pretty average uni.
01:11:20 <EvanR> should have taken "how to learn on your own 1001"
01:11:20 <acetoline> ibid: well, in all fairness I was a programming tutor, and that's often right
01:11:25 <xandaros> When they heard that I had previous experience they warned me not to fall behind. Until we got to haskell they couldn't teach me a thing...
01:11:27 <acetoline> ibid: especially the ones that learned php
01:11:49 <ibid> acetoline: yes, i know it's right. i've taught programming myself :)
01:11:52 <sgronblo> tzaeru: I always see static types are bad because "java is verbose", "I never make type errors", "types slow me down" and stuff like that
01:11:54 <tdammers> PHP is kind of a special case
01:12:06 <acetoline> php seems especially common among the young
01:12:07 <ibid> PHP is today's BASIC in that sense
01:12:11 <acetoline> that and javascript
01:12:35 <tdammers> no, I mean because PHP has some weird characteristics that make things unfeasible that would otherwise be the right approach
01:12:42 <merijn> I would like to nominate the discussion of not-haskell for #-blah :)
01:13:10 <tdammers> merijn: word.
01:13:24 <tzaeru> sgronblo, mh ya, I guess there are fanbois like that for pretty much all the things if one goes to reddit or blogosphere or so
01:13:54 <merijn> That way I can restrict my procrastination to at least haskell related procrastination :p
01:15:11 <earthy> ;)
01:15:53 <tzaeru> mmm. okay. seems my firefox has.. lost all its bookmarks? wtf
01:15:58 <earthy> geez. I've not done haskell in anger for way too long.
01:16:06 <tzaeru> ..there went my collection of haskell-related docs >_>
01:16:08 <tzaeru> <_<
01:16:18 <earthy> GHC 7.0 was like the new hotness last I checked. :)
01:16:28 <EvanR> @where learnhaskell
01:16:28 <lambdabot> https://github.com/bitemyapp/learnhaskell
01:16:41 <codygman> I'm trying to match `Act IV` with this parsec parser, but it's skipping the given string... what am I misunderstanding?: parseTest (string "Act" *> space *> many1 (choice [char 'I', char 'V'])) "Act IV: blah"
01:17:38 <aawe> codygman: what does that give you?
01:18:31 <codygman> aawe: Just `IV`, the part after `Act`
01:18:58 <aawe> codygman: *> throws away the result on the left side
01:19:17 <codygman> aawe: I guess I should figure out what exactly *> is ;)
01:19:30 <aawe> codygman: in the mean time, use <*>
01:19:36 <xandaros> aawe: Doesn't that make *> the same as >> in that context?
01:19:46 <aawe> :t (>>)
01:19:47 <lambdabot> Monad m => m a -> m b -> m b
01:20:06 <xandaros> :t (*>)
01:20:07 <lambdabot> Applicative f => f a -> f b -> f b
01:20:11 <xandaros> ah
01:23:29 <merijn> earthy: Wait a few more weeks and you can use 7.10 :p
01:23:32 <codygman> aawe: "string "Act" isn't a `f (a -> b)`
01:24:02 <aawe> codygman: ah... One sec
01:24:36 <codygman> :t (>>)
01:24:37 <lambdabot> Monad m => m a -> m b -> m b
01:24:47 <codygman> whoops, thought I was in my repl
01:27:36 <jle`> codygman: you might have some luck with `sequence` (or sequenceA)
01:27:38 <jle`> :t sequence
01:27:39 <lambdabot> Monad m => [m a] -> m [a]
01:27:44 <jle`> [Parser a] -> Parser [a]
01:27:44 <codygman> I'm sure matching an entire string in Parsec is simple and I'm just tired
01:27:53 <codygman> jle`: Oh, I'll try it
01:28:06 <jle`> sequence turns a list of parser into a parser of lists...runs every parser after the other and returns the results as a list
01:28:20 <earthy> merijn: yeah. :)
01:28:35 <earthy> then again, this Haskell Platform 2014.2.0.0 is weirding me out
01:29:04 <jle`> is there any point to do the laziness thing on \~(x,y) -> ...
01:29:07 <earthy> cabal install cabal-install installs 1.22.1.1, then reverts to 1.22.0.1, then keeps saying there's a newer cabal-install... to be installed with cabal install cabal-install
01:29:23 <jle`> is it so that it doesn't crash on the tuple being bottom
01:29:37 <jle`> > (\(x,y) -> 6) undefined
01:29:39 <lambdabot>  *Exception: Prelude.undefined
01:29:41 <jle`> oh
01:29:44 <jle`> ...huh.
01:29:49 <jle`> > (\~(x,y) -> 6) undefined
01:29:50 <lambdabot>  <hint>:1:10: parse error on input ‘->’
01:30:07 <quchen2> > (\ ~(x,y) -> 6) undefined
01:30:09 <lambdabot>  6
01:30:10 <jle`> oh yeah, (,) has lazy fields
01:30:25 <codygman> jle`: I'm not sure how sequenceA would help me match the "Act" string in: parseTest (string "Act" *> space *> many1 letter) "Act IV: blah"
01:30:26 <jle`> (,) is indeed a constructor it has to verify
01:30:43 <jle`> codygman: sequence [string "Act", space, many1 letter]
01:30:58 <jle`> you'd probably have to change `space` to have the right type
01:31:24 <merijn> earthy: Is your cabal binary dir in your path?
01:31:36 <merijn> earthy: That's usually the cause of that
01:31:44 <jle`> is there any time where the \ ~(x, y) -> ... behavior is *not* wanted?
01:31:48 <earthy> *ah*! duh.
01:32:17 <merijn> earthy: This is why you should version control your environment :p
01:32:29 <earthy> merijn: yeah, run nix on top of os x
01:32:55 <earthy> no thanks ;)
01:33:04 <merijn> earthy: I just have all my dotfiles in Mercurial version control and clone/push/pull from all machines I work on :p
01:33:20 <merijn> + setup scripts to initial the relevant cabal/ghc/whatever config files :p
01:33:31 <earthy> (I've been rebuilding on purpose... I did that fully modular thing in version control once, but no longer)
01:38:21 <bloot> Can GHC(i) tell me *where* it ran out of memory?
01:38:39 <bloot> I must have somehow introduced some leak or infinite loop
01:38:47 <bloot> because I register a regression.
01:39:53 <merijn> bloot: Easiest way is to use profiling, Real World Haskell has a chapter on how to do memory profiling (chapter 20 or so, I believe?)
01:42:10 <aawe> bloot: http://www.stephendiehl.com/what/#debugger
01:42:40 <merijn> aawe: That's not so useful for detecting memory leaks, though
01:43:02 <bloot> I think I screwed up a pattern matching so something is looping rather than matching against something
01:43:08 <aawe> merijn: If the program runs out of memory and crashes it might be useful
01:44:05 <aawe> bloot: also, how are you running your code?
01:44:45 <bloot> :trace ....
01:45:03 <bloot> but unlike runghc in ghci it doesn't seem to run out of memory
01:45:12 <bloot> it does with runghc though
01:45:23 <bloot> in ghci it just loops like forever on end
01:45:41 <tdammers> ghci does some voodoo that may cause different evaluation order
01:47:25 <bloot> if I do
01:47:31 <bloot> :set -fbreak-on-exception
01:47:33 <bloot> :trace ...
01:47:39 <bloot> it will immediately break due to an exception
01:47:56 <bloot> but without -fbreak-on-exception there doesn't even seem to happen an exception o_O
01:48:05 <bloot> also I have no idea where that exception would come from
01:48:19 <bloot> Stopped at <exception thrown>
01:48:20 <bloot> _exception :: e = _
01:48:27 <bloot> what's that supposed to mean anyway?
01:48:43 <aawe> "You know what you did!"
01:48:57 <aawe> that is a frustrating message
01:49:40 <bloot> hm
01:49:44 <bloot> there's an exception in io
01:50:48 <bloot> uhm...
01:50:49 <bloot> what :(
01:52:04 <bloot> _exception :: e = SomeException BlockedIndefinitelyOnMVar
01:52:05 <bloot> ah
01:52:07 <bloot> that's much better
01:52:28 <bloot> I don't use MVars as far as I know but ok...?
01:53:22 <aawe> bloot: do you have any code to show? You could try to construct a minimal test case that has this problem (with as little code as possible)
01:54:51 <bloot> does catch use MVars?
01:55:12 <tzaeru> damn. I wanted to try & learn haskell by making simple image modifications, but the example code I got for it that is for JuicyPixels is already a bit beyond. ^^
01:55:20 <bloot> oops
01:55:22 <bloot> lol
01:56:04 <bergmark> tzaeru: start smaller then :-)
01:56:20 <bloot> aawe: yes I do
01:56:49 <tzaeru> bergmark, meh. sounds dull..
01:56:54 <bergmark> :-(
01:56:54 <bloot> io stuff = io $ catch (stuff) (\(e :: SomeException) -> return (show e))
01:57:17 <tzaeru> though I guess that might be mandatory, or then find someone to hold my hand for a few hours >.>
01:57:19 <aawe> tzaeru: If you want to tackle it still, you could demonstrate what you have and ask questions about this code
01:58:29 <aawe> bloot: that's an infinite loop
01:58:50 <aawe> catch (catch (catch (....
02:02:09 <tzaeru> aawe, would need to set haskell on my work comp, tho I've conflicting libraries ofc -.^
02:02:56 <aawe> tzaeru: that's not my strong department. What does `ghc-pkg check` tell you?
02:03:06 <tzaeru> ah, um, I've the paths removed atm. second
02:08:10 <bloot> aawe: Yes.
02:08:25 <bloot> But due to some weird lazy circumstances it didn't occur until recent changes
02:08:32 <kaiyin> https://gist.github.com/kindlychung/1eeeea25899e60c16ba4 This snippet from Real World Haskell fails to compile, why?
02:09:24 <merijn> kaiyin: "fails to compile" <- what happens? what error do you get?
02:09:38 <kaiyin> merijn: gist updated.
02:10:11 <phaazon> hey, may someone explain me what calling convention I should use on Windows6?
02:10:14 <phaazon> Windows*
02:10:21 <phaazon> I have a Windows 64 bit
02:10:25 <phaazon> and I use MinGW
02:10:34 <tzaeru> welp. seems my work laptop has gotten really crashy.
02:11:06 <merijn> kaiyin: Did you type it by hand or copy it?
02:11:16 <aawe> kaiyin: last line should be niceDrop n (_:xs) = ...
02:11:26 <merijn> kaiyin: I suspect you meant line 3 to be "niceDrop n (_:xs)"
02:11:53 <kaiyin> oh, my bad.
02:11:56 <tzaeru> aawe, what I'm mostly trying to figure my head around is most parts of this: https://github.com/Twinside/Juicy.Pixels/blob/master/skeletons/jpeg-basic.hs ^^
02:11:57 <merijn> kaiyin: aawe and my version is pattern matching on the head of a list and ignoring the first item
02:12:20 <kaiyin> yes, thanks.
02:12:22 <merijn> kaiyin: Your example is matching a list with a single list inside and then continuing with the tail inside the inner list (which indeed doesn't type check!)
02:12:44 <merijn> kaiyin: "[1,2,3]" is sugar for "1:(2:(3:[])))"
02:13:13 <merijn> kaiyin: So "[_:xs]" is sugar for "(_:xs):[]", so a list in a list
02:13:27 <frerich> kaiyin: Sometimes it's convenient to check the online version of RWH to see whether you did a typo. For instance, your particular example is also shown at http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#x_H6
02:13:55 <EvanR> > 3:[]
02:13:55 <frerich> That gets you something you can copy & paste, if in doubt.
02:13:58 <lambdabot>  [3]
02:14:11 * hackagebot xml-to-json-fast 1.0.1 - Fast, light converter of xml to json capable of handling huge xml files  http://hackage.haskell.org/package/xml-to-json-fast-1.0.1 (NoamLewis)
02:14:15 <merijn> kaiyin: So if your outer list was "[[Int]]" your inner list is "[Int]" and since you're recursively calling "niceDrop" on the inner "[Int]" and then it complains "[Int] doesn't have a list inside to recurse on!"
02:14:41 <merijn> frerich: I think typing by hand is good exercise
02:14:43 <aawe> tzaeru: Well, the first thing I notice is the Codec.Picture import - we need to investigate what this offers and how it's used. I searched hackage and found the documentation: http://hackage.haskell.org/package/JuicyPixels-3.2.2/docs/Codec-Picture.html
02:14:48 <merijn> It crystallises differences like this :)
02:15:08 <kaiyin> wow, interesting.
02:15:09 <merijn> Now kaiyin learned something useful about pattern matching instead of just reading and misunderstanding :)
02:15:20 <frerich> merijn: Of course, but what I meant is that it lets you verify that the issue is indeed with your typing and not with a faulty example in the book.
02:15:23 <kaiyin> that's true.
02:15:29 <aawe> tzaeru: It's a good idea to look up types you see as you read docs by clicking them - clicking Image leads here: http://hackage.haskell.org/package/JuicyPixels-3.2.2/docs/Codec-Picture.html#t:Image
02:18:15 <tzaeru> aawe, yea -- and I presume that a syntax like "Image PixelRGB8" basically translates to "type Image, constructed with a constructor that accepts the type of PixelRGB8"?
02:18:26 <tzaeru> or.. not?
02:19:32 <bloot> neat
02:19:32 <aawe> tzaeru: "Image PixelRGB8" could be read as "An Image with RGB8 pixels" or more generally "An Image parameterized on the PixelRGB8 type"
02:19:45 <bloot> My LISP with exceptions totally works now \o/
02:20:16 <bloot> what actually happens with catch (forkIO $ error "err") (\e -> ..)?
02:20:26 <aawe> tzaeru: "Image PixelRGB8" is a type
02:21:21 <aawe> bloot: the child will die, not throw an exception, afaik
02:21:35 <tzaeru> aawe, it's formed from "base type" (or somesuch concept) of Image and with a type PixelRGB8 inside Image?
02:21:40 <tzaeru> ..or am I still getting that all wrong? :P
02:21:58 <bloot> aawe: good
02:22:01 <bloot> I just tested that :D
02:22:06 <bloot> child dies
02:22:20 <bloot> can you install an exception handler into a thread?
02:22:23 <bloot> like uhm..
02:22:25 <aawe> bloot: error evaluates to bottom, not an exception
02:22:36 <bloot> oh weill
02:22:50 <merijn> bloot: error is hard to catch
02:23:00 <bloot> I can do forkIO $ (catch f (\e -> notifyObservers))
02:23:01 <merijn> bloot: Also, take a look at forkFinally
02:23:04 <bloot> something like that should work?
02:23:25 <merijn> bloot: The problem is that error throws it's exception lazily, so it can "leak" out of the scope of your catch
02:23:34 <aawe> tzaeru: [Int] is "A list of Int", and in the same way, Image PixelRGB8 is "An image of PixelRGB8"
02:23:39 <merijn> bloot: You should always use throwIO when possible
02:24:03 <merijn> bloot: throwIO will prevent the exception from leaking
02:24:12 <tzaeru> aawe, ok. that makes sense. so it also means that as any operator that can be made on lists can be made on list of ints, any operator made on image can be made on image pixelrgb8
02:24:48 <tzaeru> or any function that cane take lists, can take lists of ints and.. same for image/pixelrgb8
02:25:19 <tzaeru> (I know this might seem like a bit of a backwards way of learning anything, but for me having a framework to try things in is important for motivation :P )
02:27:38 <aawe> tzaeru: Basically, yes. But there are some constraints on this - you cannot do Image Int, because there is probably a constraint on PixelBaseComponent such that a needs to be an instance of Pixel (I think)
02:27:57 <aawe> but this is not necessarry to fully understand yet
02:29:20 <tdammers> aawe: those constraints are typically added to the function itself, not the "container" type
02:29:21 <aawe> The reason Image is parameterized on a pixel type is that it's needed if we want to do type safe pixel manipulation - a tags along and forces you to work with that specific type when you push och get pixels
02:29:33 <aawe> tdammers: good point, thanks
02:29:54 <tdammers> e.g., you could make a Map Foo bar, where Foo doesn't implement Ord
02:30:06 <tdammers> but you couldn't add any values to it, because the insert function required ORd
02:30:08 <tdammers> *Ord
02:30:39 <tdammers> similarly, you can probably construct an Image Int, but unless Int implements Pixel, you cannot perform any operations on it that require access to actual pixels
02:34:12 * hackagebot al 0.1.1.1 - OpenAL 1.1 raw API.  http://hackage.haskell.org/package/al-0.1.1.1 (DimitriSabadie)
02:34:47 <aawe> wait... are exceptions bottom?
02:35:53 <aawe> I am not sure how to feel about that
02:36:27 <kaidelong> aawe: you mean in Haskell?
02:36:45 <aawe> kaidelong: yes, in #haskell ;)
02:36:53 <kaidelong> you're not supposed to be able to observe them in pure code, so they behave effectively the same
02:37:19 <kaidelong> when you get into IO it becomes possible to distinguish different "kinds of bottoms" and operate on them
02:37:34 <kaidelong> incidentally one exception the runtime can throw at you is loopException
02:37:35 <bloot> hm. so terminateProcess sends SIGTERM
02:37:50 <kaidelong> which is when it detects an infinite loop
02:37:54 <bloot> does terminateProcess flush all handles to the process?
02:38:07 <bloot> or hm. I could do that manually anyway
02:38:36 <aawe> bloot: flush which handles? Do you have pipes open between the processes?
02:38:40 <bloot> aawe: yes
02:39:01 <aawe> bloot: the terminating process will have its handles cleaned up by the OS
02:39:28 <bloot> yes. but let's say I just written something to stdin of the remote process
02:39:35 <bloot> I call hFlush and terminateProcess
02:39:54 <bloot> that doesn't guarantee me that the remote process had enough time to handle my new data on stdin before going to die, right?
02:40:10 <aawe> bloot: question is if the other process will have time to process the data before it's terminated
02:40:27 <bloot> so I should probably close the stdin handle
02:40:40 <bloot> and the remote process should then receive EOF and terminate on its own
02:40:45 <aawe> which, I wildly guess, depends on you OS and you CPU
02:40:55 <aawe> bloot: yeah, that'd a good idea
02:41:23 <bloot> Can I close the stdout handle of a remote process?
02:41:40 <bloot> (created by createProcess and CreatePipe)
02:42:27 <aawe> bloot: you can close your side, but I'm guessing you want to read it til you get EOF
02:43:18 <aawe> bloot: is the process a fork or a separate exec?
02:43:32 <bloot> createProcess (shell ...
02:43:47 <bloot> I don't know what this does under the hood
02:45:22 <bloot> aawe: stdin can't be EOF on my side?
02:45:29 <phaazon> hm, when I compile my lib (that links against a static C lib, it works great, but when I use it within an application, it crashes at startup… any idea?
02:45:33 <bloot> i.e. a write-only socket doesn't have an EOF state?
02:45:51 <kaiyin> > "what" ++ " is this"
02:45:53 <lambdabot>  "what is this"
02:46:10 <aawe> > [1,2,3] ++ [4]
02:46:12 <lambdabot>  [1,2,3,4]
02:46:15 <kaiyin> > "ab" ++ ['c']
02:46:17 <lambdabot>  "abc"
02:46:26 <phaazon> > [1..10] <> pure 3
02:46:27 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,3]
02:50:56 <kaiyin> what is wrong with this function definition? https://gist.github.com/kindlychung/59607d852d6fcebd8bd8
02:51:00 <merijn> aawe: For details on the semantics of exceptions, read "A Semantics for Imprecise Exceptions" :)
02:51:33 <merijn> kaiyin: The second pattern matches a singleton list and returns the element inside
02:51:41 <tzaeru> aawe, sorry, had to do an urgnet work thing >_>
02:51:49 <tzaeru> aawe, but thanks for the help.. it's already gotten me a bit furhter :P
02:52:07 <merijn> kaiyin: Since "String = [Char]" the 'x' in the pattern [x] must be Char (since it's just short for "(x:[])")
02:52:11 <tzaeru> I'm planning on using a very simplsitic image modification skeleton to learn things from mapping functions to everything else.
02:52:22 <tzaeru> and try to always figure a way to "visualize" the thing to the image I'm modifying
02:52:25 <merijn> kaiyin: So when you return 'x' you're returning a Char, but your function claims to return a String!
02:52:30 <tzaeru> more work things ->
02:52:48 <merijn> :t intersperse
02:52:50 <lambdabot> a -> [a] -> [a]
02:52:57 <steffen> Im using the Blaze library for Html, now I have a [Html] and I want to chain all these html elements AFTER each other which I would do by folding them with bind! is there a function that folds '>>' over a List of monadic values?
02:53:12 <merijn> kaiyin: Same thing on the last line
02:53:18 <tdammers> it's almost suspicious how easy it is to implement a threaded program in haskell :x
02:53:22 <aawe> merijn: thank you, looks interesting
02:53:29 <merijn> kaiyin: You're using 'x' and ++ together while 'x' is a Char and ++ only works on lists
02:53:46 <phaazon> none for my static library issue? :(
02:54:01 <merijn> steffen: sequence?
02:54:03 <merijn> :t sequence
02:54:04 <lambdabot> Monad m => [m a] -> m [a]
02:54:14 <kaiyin> merijn: The second parameter is [String], so x must be a string.
02:54:39 <merijn> kaiyin: oh, my bad! You're right!
02:55:04 <merijn> kaiyin: I glossed over that, but than the problem is your use of intersperse :)
02:55:25 <merijn> 'xs :: [String]' -> "xs :: [[Char]]"
02:55:31 <merijn> :t intersperse
02:55:32 <kaiyin> oh, jeez, I dropped a 1.
02:55:32 <lambdabot> a -> [a] -> [a]
02:55:37 <merijn> kaiyin: :)
02:55:41 <steffen> merijn: Thanks :)
02:59:01 <xandaros> I'm always amazed at how many functions already exist in the standard libraries. Just found asum in Data.Traversable. The name is a bit weird, though
02:59:48 <aawe> xandaros: yeah, it's asum ;)
03:00:10 <xandaros> ALso, it's Foldable... derp
03:00:16 <bloot> fd:12: hIsReadable: illegal operation (handle is closed)
03:00:17 <bloot> :(
03:00:29 <bloot> why doesn't it just return False then
03:00:35 <bloot> if it's closed it's not really readable anymore :D
03:01:39 <quchen2> xandaros: asum = applicative sum, because <|> behaves a lot like a sum in certain ways. It's the Alternative version of MonadPlus' msum.
03:02:04 <aawe> quchen2: also pun
03:02:17 <quchen2> I don't think that went into the name.
03:02:18 <xandaros> quchen2: tbh, I have a hard time getting around the name of "MonadPlus", as well :P
03:02:21 <aawe> :(
03:02:40 <aawe> xandaros: wait til you learn about MonadPremium
03:05:06 <xandaros> I just get the feeling that if I use asum instead of "foldl (<|>) empty", I won't understand what that means when I look back at it in the distant future. (On the other hand, I probably got used to it by then)
03:05:16 <Cale> xandaros: Well, this doesn't happen for all instances, but at least for lists, you have  mplus xs ys >>= f = mplus (xs >>= f) (ys >>= f), which looks a little bit like (a + b) * c = (a * c) + (b * c)
03:05:29 <Cale> also, for parsers
03:05:42 <xandaros> I'm actually using it in a parser :P
03:05:42 <Cale> Maybe fails that law
03:06:48 <phaazon> http://stackoverflow.com/questions/28829976/ffi-and-static-libraries-used-in-application
03:06:52 <phaazon> if you guys have any idea…
03:06:59 <phaazon> I’m a bit desperate right now :D
03:07:26 <Cale> With respect to parsing, mplus also corresponds to the + of Kleene algebras http://en.wikipedia.org/wiki/Kleene_algebra
03:08:47 <Cale> phaazon: When you say it "crashes at startup" -- do you mean it just silently exits?
03:08:49 <xandaros> Cale: That's a good point, didn't think of that
03:09:37 <phaazon> Cale: yes
03:10:09 <Cale> phaazon: That's bizarre. Maybe strace will tell you something?
03:10:56 <Cale> phaazon: Does the program do much printing to the terminal near the start of its main?
03:11:02 <Yuras> phaazon: works in repl but crashes compiled? are you using thread local storage?
03:11:18 <phaazon> thread local storage? I don’t know what that is
03:12:20 <Cale> phaazon: What happens when you compile with -threaded?
03:12:55 <Cale> (one difference when using ghci is that ghci is built with the threaded runtime)
03:13:25 <Cale> I'm grasping at straws here since I have no real details about anything
03:14:02 <phaazon> still the same
03:14:18 <phaazon> Cale: isn’t there a way to make the RTS verbose?
03:14:34 <phaazon> so that I know what’s happening
03:16:16 <Cale> You could try getting it to print garbage collection stats or something
03:16:34 <Cale> ./program +RTS -T
03:16:45 <Cale> or -B for sounding the bell at the start of each GC
03:17:04 <Cale> er, you might also need -S to see the stats
03:17:18 <phaazon> holy
03:17:24 <phaazon> I don’t even have a single stat
03:17:28 <phaazon> it directly fails
03:17:45 <Cale> Try strace
03:17:53 <Cale> strace ./program
03:17:59 <phaazon> I don’t have strace in MinGW :(
03:18:12 <phaazon> I’ll download it
03:43:43 <phaazon> Cale: return code is 9
03:45:41 <Cale> phaazon: Exit code 9 usually means out of memory
03:45:59 <phaazon> duh
03:46:25 <xandaros> What do `some` and `many` in Control.Applicative actually do? I tried feeding them Maybes and Lists, but they just end in a loop
03:46:51 <merijn> xandaros: They're mostly only useful for Alternative types that have a notion of "failing"
03:46:55 <merijn> xandaros: i.e. parsers
03:46:56 <Cale> xandaros: They're more useful with parsers
03:47:34 <merijn> xandaros: There they are "parse at least 1, followed by any number until failure" and "parse at least 0, followed by any number until failure"
03:48:07 <merijn> but since "some [1]" never "fails" (it always returns a list) it results in an infinite loop
03:48:44 <xandaros> ahhh, that makes sense. I think
03:49:52 <xandaros> What exactly does "fail" mean?
03:50:01 <merijn> xandaros: For example, take "optparse-applicative" where you use "many someparser" to parse any number of arguments matching someparser
03:50:17 <merijn> xandaros: Well, either a parser succeeds in parsing whatever it does, or it fails
03:50:21 <kqr> if I want a simple sum type with two options, is it best to use Either or invent my own?
03:50:42 <xandaros> merijn: I know how it works with parsers, just trying to figure out the bigger picture
03:51:02 <merijn> xandaros: There is no real "general" notion of failing that I'm referring too
03:51:36 <merijn> kqr: Depends, the Either has the bonus of being able to use all the existing instances
03:51:39 <xandaros> merijn: Well, looks like `many empty` returns an empty list, so I guess `empty` is a failure
03:52:06 <merijn> kqr: You could newtype Either, GeneralizedNewtypeDerive all classes and then when you want to later replace it with a custom type that becomes easy
03:52:07 <frerich> kqr: I think 'Either' has some conventional semantic (it's used for values which might be errors and you'd like to transport some error information). If that's what you want, then 'Either' is a good fit.
03:52:20 <merijn> frerich: Either is not solely for errors at all
03:52:27 <merijn> That's the convention for the Monad instance, sure
03:52:34 <merijn> But I use Either for generic sums too
03:52:42 <frerich> merijn: Nobody claimed that it's solely for errors.
03:52:42 <merijn> xandaros: Right
03:52:46 <kqr> frerich, neither option is an error case here, which is why I doubt myself
03:53:08 <merijn> xandaros: Alternative is in many ways analogous to MonadPlus (maybe the same?)
03:53:32 <xandaros> merijn: And the only way for it to make sense is if the type it is working on is stateful, right?
03:54:16 <frerich> kqr: In that case *I* would probably go for a custom type, like 'data Player = CPU Int | Human String'
03:54:16 * hackagebot al 0.1.1.2 - OpenAL 1.1 raw API.  http://hackage.haskell.org/package/al-0.1.1.2 (DimitriSabadie)
03:55:55 <zipper> WHat do you know. You can't use [_] as a type hole
04:02:05 <bloot> I should learn gloss :)
04:09:06 <EvanR> whats the idiomatic way to "whip up" a free monoid over a type X
04:09:28 <EvanR> to avoid wrapping everything in []
04:17:06 <kaiyin> What is wrong with this function? http://hastebin.com/ripitovaxo.coffee ghci says indentaion incorrect of mismatched brackets
04:17:09 <bloot> 0,0 is in the middle in gloss?
04:17:40 <EvanR> i guess newtype XS = XS [X]
04:19:21 <bloot> aw. right. its -1.0..1.0
04:21:17 <mauke> kaiyin: what's the error message?
04:22:12 <kaiyin> mauke: parse error (possibly incorrect indentation or mismatched brackets)
04:22:24 <Cale> EvanR: I don't understand, why isn't [X] appropriate?
04:22:25 <mauke> kaiyin: what's the full error message?
04:22:50 <kaiyin> mauke: that's all.
04:23:06 <mauke> wanna bet?
04:23:17 <Cale> That is not the complete error message. The complete error message will include a line number.
04:24:03 <mauke> my guess is 15
04:24:10 <kaiyin> mauke: Cale: ok, I have updated the code in the link.
04:24:11 <Cale> ah, yes
04:24:22 <Cale> yeah, you need to put the newline before the _
04:24:28 <Cale> and hang the guards off of that
04:24:38 <Cale> The guards must start in a deeper column than that _
04:24:39 <EvanR> Cale: hmm. well putting a single thing at the end
04:24:46 <EvanR> is inefficient
04:24:57 <mauke> kaiyin: what's different?
04:25:05 <EvanR> so the alternative is Endo X
04:25:25 <kaiyin> mauke: the same link: http://hastebin.com/cadepalone.coffee
04:25:35 <Cale> EvanR: I guess. Do you do a lot of that?
04:25:46 <mauke> kaiyin: that's a different link
04:25:51 <mauke> it also doesn't work
04:26:06 <rpr> are there any runtime interpeters in haskell? given "foo" string how could I get the value of a top-level variable foo?
04:26:07 <EvanR> Cale: either that or concat
04:26:12 <kaiyin> mauke: oh, I edited the file and thought the link wouldn't change, my bad.
04:26:14 <EvanR> ++
04:26:22 <mauke> huh, works if I remove "coffee"
04:26:37 <rpr> I need something like eval
04:26:39 <mauke> kaiyin: that paste doesn't have 122 lines
04:26:50 <bloot> rpr: mueval
04:26:52 <Cale> EvanR: Yeah, if you find yourself concatenating a lot of lists, I suppose using Endo [a] is appropriate
04:27:00 <Cale> EvanR: Newtyping won't do much though.
04:27:09 <kaiyin> mauke: anyways, I have moved the _ to the next line and it seems to compile ok.
04:27:15 <EvanR> Cale: got it
04:27:39 <bloot> @hoogle mueval
04:27:41 <lambdabot> package mueval
04:27:49 <kaiyin> mauke: here is the complete file: http://hastebin.com/iziraduvif.coffee
04:27:59 <Cale> EvanR: I thought maybe you were worried about the efficiency of using WriterT to write a list, but usually that's actually fine.
04:28:23 <EvanR> i wasnt planning on using WriterT
04:28:26 <EvanR> but well see
04:28:27 <Cale> (the list appends get associated the same way as the binds, and usually binds associate heavily to the right)
04:28:55 <rpr> mueval looks like just the thing I need
04:28:56 <zipper> Hey what types are used as keys by Persistent?
04:29:03 <zipper> DB keys
04:29:04 <EvanR> i heard there was an issue with Writer a while back
04:29:13 <EvanR> something about blowing laziness
04:29:25 <Cale> I don't recall that
04:29:33 <Cale> Might've missed it
04:30:01 <rpr> it might be too powerful for what I need though? "standalone version of Lambdabot's famous evaluation functionality"
04:30:08 <mauke> kaiyin: and now we can immediately see that the error was in or before "| newY < 0  -> ToRight" :-)
04:30:36 <kaiyin> indeed.
04:31:16 <EvanR> http://stackoverflow.com/questions/7720929/space-leaks-and-writers-and-sums-oh-my
04:31:20 <mauke> this is why people should post the actual, complete error message, as well as the actual, complete source file
04:31:23 <EvanR> dunno if thats the same issue
04:31:48 <shachaf> mauke: Innovative.
04:31:50 <EvanR> the issue in that case is it was too lazy
04:32:25 <mauke> the other day we had someone in #perl: "my code doesn't work, I don't understand why, here's the link. oh, and btw, I removed the irrelevant parts"
04:32:47 <kaiyin> What is the command for execute the next line in ghci debugger?
04:32:50 <mauke> (predictable response: if you don't know what the bug is, how do you know what's irrelevant?)
04:36:51 <EvanR> does mconcat [a,b,c,d] perform worse than a <> b <> c <> d
04:36:56 <EvanR> since theres a list
04:37:09 <merijn> EvanR: Yes, no, maybe, it depends
04:37:11 <unpredictable> hello
04:37:34 <EvanR> hmm was trying to shorten my code, but i know <> is more idiomatic
04:38:57 <rpr> is there a less heavy way of evaluating a string to the top-level's variable value than using mueval?
04:39:25 <rpr> which seems to be a full blown haskell interpreter
04:39:48 <EvanR> screw it, let the optimizer sort em out ;)
04:40:12 <merijn> rpr: How would you do that without a full haskell interpreter/compiler?
04:40:34 <msl09> Why do some packages do not install their dependencies when I use cabal?
04:40:41 <rpr> merijn, I don't know.. but I don't need to evluate arbitrary haskell code, just top-level variables
04:40:46 <mauke> msl09: example?
04:40:59 <mauke> rpr: ... that is arbitrary haskell code
04:41:02 <msl09> mostly packages that require programs such as c2hs
04:41:29 <rpr> mauke no it isn't. it is a small subset of valid haskell code
04:41:35 <mauke> rpr: how so?
04:41:48 <mauke> every haskell program is effectively a single top-level variable: Main.main
04:41:55 <pavonia> rpr: Is your list of variables static?
04:41:55 <msl09> for instance ncurses requires c2hs that requires language-c alex an happy
04:42:01 <rpr> mauke, that is not relevant
04:42:03 <rpr> pavonia yes
04:42:08 <mauke> rpr: why not?
04:42:25 <rpr> rpr I have over a thousand top-level variables in a single module
04:42:32 <rpr> ^^ that was for pvonia
04:43:13 <pavonia> Oh, my idea was to write a big case expression, but ... well
04:43:15 <EvanR> you can read them in from a file or use TH
04:43:28 <rpr> mauke because I don't have to (among many other things) call functions, execute IO actions, I just need to fetch a value from a variable. that is a subset of the things you can do in haskell
04:43:36 <EvanR> to put them in a Map or case expression
04:43:52 <mauke> rpr: why don't you have to call functions?
04:43:57 <EvanR> rpr: but you want to look it up by a string, implying there is some computation to do this
04:44:08 <EvanR> at runtime
04:44:22 <rpr> EvanR what do you mean?
04:44:36 <mauke> rpr: let's say I define 'foo = 1/2 + sqrt 1.25'. now you have to call sqrt and (+) to get the value of foo
04:45:10 <EvanR> rpr: you cant go from a string to a value with no computation (unless the value happens to be that string you already have)
04:45:13 <rpr> mauke I don't need that either. all my variables evaluate to a number
04:45:13 <aawe> and (/)
04:45:28 <mauke> foo also evaluates to a number
04:45:47 <mauke> what is the actual problem you're trying to solve?
04:45:55 <rpr> it performs computations. my variables are just plain numbers
04:46:28 <rpr> eval "variableName" -> variableName
04:46:41 <mauke> no, what are you trying to achieve?
04:46:46 <EvanR> case x of "variableName1" -> number1; "variableName2" -> number2 ...
04:46:49 <mauke> eval "foo" is just an attempted solution
04:46:56 <rpr> EvanR I have over a thousand variables
04:47:03 <EvanR> you can generate the source code
04:47:15 <mauke> so write a thousand-line case expression :-)
04:47:17 <EvanR> from the actual source of numbers
04:47:18 <mauke> or use a Map
04:47:22 <silver> or use a map
04:47:33 <rpr> well.. I'd rather not do that every time I add another variable.. unless it is done automatically? with TEmplateHasakell?
04:47:41 <mauke> what is this for?
04:47:43 <EvanR> yeah, automatically
04:47:48 <aawe> varFor "number_of_ducks" = 3; varFor "number_of_problems" = 99; etc
04:47:52 <mauke> why do you even have a thousand variables?
04:48:09 * tdammers thinks that 4 variables is too much already
04:49:13 <rpr> I am accessing some C library, these variables are C #defines. and I want to use the names in a config files that is parsed at runtime
04:49:14 <EvanR> rpr: storing important mutable data in a source file is probably a bad idea anyway, compute the source file from the database
04:49:19 * hackagebot ireal 0.2 - Real numbers and intervals with relatively efficient exact arithmetic.  http://hackage.haskell.org/package/ireal-0.2 (sydow)
04:49:41 <EvanR> rpr: why didnt you say so! just load the config file at runtime ;)
04:49:48 <EvanR> into a Map
04:50:06 <EvanR> "i dont want to pass the Map around everywhere" then dont, just pass it to the thing that needs it
04:50:28 <mauke> EvanR: isn't that the wrong way round?
04:50:32 <rpr> say that I have this in a config file:  name=C_DEFINE; arg = 10;  I have to call a C function with C_DEFINE and 1 arguments
04:50:44 <rpr> s/1/10/
04:50:50 <EvanR> mauke: loading environment data into a Reader or something during runtime?
04:51:12 <mauke> EvanR: loading the config file into a map when the structure to look up from is not part of the config file
04:51:20 <rpr> EvanR I am doing that. but I need to go from "C_DEFINE" to C_DEFINE somehow
04:52:01 <EvanR> rpr: fromList [("C_DEFINE", 10)]
04:52:17 <EvanR> i do not understand mauke
04:52:26 <rpr> do you suggest that I parse C header file manually? that is not a trivial task
04:52:41 <aawe> trivial in haskell
04:52:48 <mauke> rpr: how are you getting the defines now?
04:52:50 <EvanR> you can also compile the C header into haskell, or use C parsers in haskell
04:52:53 <rpr> with all the #ifdefs and what not?
04:53:10 <aawe> ah, did not consider ifdefs.
04:53:46 <EvanR> rpr: yeah im suggesting you do something like that, if you havent already
04:53:54 <rpr> I am using hsc2hs
04:54:23 <mauke> what does your .hsc file look like?
04:54:25 <EvanR> why are you looking up the constants with strings
04:54:35 <EvanR> just wondering
04:54:46 <EvanR> you cant do it in C either
04:54:52 <rpr> I want to access them in a user-supplied config file
04:55:15 <EvanR> i feel like somebody came in here with this exact problem
04:55:33 <rpr> mauke: #num C_DEFINE
04:55:44 <mauke> rpr: so you already have a huge list of them?
04:55:57 <rpr> yes
04:55:58 <mauke> presumably something like c_define = #num C_DEFINE
04:56:28 <mauke> that's trivial to change to ("C_DEFINE", #{num C_DEFINE}) -- or whatever the hsc syntax is
04:56:38 <mauke> and from that you can build a runtime queryable map
04:56:50 <rpr> I just have #num C_DEFINE
04:56:56 <mauke> oh?
04:56:57 <tdammers> rpr: what I do with config files is I write a data structure that represents my configuration, implement a Default instance for it, derive ToJSON and FromJSON, and then put my configuration in a YAML file
04:57:01 * mauke checks manual
04:57:10 <EvanR> either way thats all you need
04:57:14 <rpr> I don't think .hsc accepts haskell code, it has its own rules
04:57:18 <tdammers> I have a little mini-library that can merge JSON values, and I use that to merge the actual configuration with the default configuration
04:57:46 <mauke> rpr: I don't see #num in there
04:57:59 <mauke> there's #const and #num
04:58:00 <mauke> er
04:58:02 <mauke> #enum
04:58:20 <mauke> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/hsc2hs.html
04:58:24 <rpr> don't know where you're looking but I am using #num
04:59:32 <mauke> I don't know what you're using but it's probably not hsc2hs
05:00:23 <rpr> oh, you're right
05:00:35 <rpr> it has been a while since i accessed C libraries
05:00:59 <rpr> I am using bindings-DSL
05:01:11 <hexagoxel> msl09: because open issue https://github.com/haskell/cabal/issues/220
05:01:57 <mauke> ooh
05:05:33 <msl09> oh thanks hexagoxel
05:07:04 <lf94> Is it normal for your Haskell code to say stack overflow when you are simply printing an array?
05:07:32 <tdammers> if it's a large array, and you're using a lazy fold, could be
05:08:00 <EvanR> array or list?
05:08:30 <mauke> rpr: #let kvnum m = "(\"%s\", %lu)", #m, (unsigned long)m
05:08:48 <lf94> EvanR, tdammers: http://lpaste.net/1109461452093128704
05:08:59 <mauke> rpr: foo = M.fromList [ #{kvnum C_DEFINE} ]
05:09:05 <mauke> rpr: does that work?
05:10:05 <mauke> lf94: Prelude.show is a red flag
05:10:06 <kaiyin> how do you guys go about debugging your code?
05:10:36 <tdammers> kaiyin: various techniques, why
05:10:52 <mauke> lf94: did you only add "Prelude." because it wouldn't compile?
05:11:05 <tdammers> ideally, I try to avoid bugs by using the type system and tests to make sure everything does what I think it should do
05:11:27 <kaiyin> I am using the ghci debugger,  and find it a bit awkward.
05:11:36 <lf94> mauke: Yeah.
05:11:41 <EvanR> i havent had much success with ghci debugger
05:11:53 <tdammers> other techniques include playing with things in ghci, writing more tests, making my types more rigid, and, occasionally, trace logging
05:12:00 <tdammers> I've pretty much completely abandoned step debugging
05:12:02 <mauke> lf94: that's because your Show instance is empty and you defined a new global 'show' function
05:12:05 <mauke> lf94: (lack of indentation)
05:12:57 <rpr> mauke I was way, let me try
05:13:23 <kaiyin> tdammers: how would you trace log the distAB variable here: http://hastebin.com/awokunekok.coffee , for example?
05:13:27 <lf94> mauke: heh
05:13:28 <lf94> worked
05:13:29 <lf94> B)
05:13:33 <lf94> mauke: thank you!
05:14:22 <tdammers> kaiyin: not
05:14:40 <tdammers> kaiyin: I'd write a quickcheck test, and/or some unit tests, and/or manually verify it in ghci
05:15:25 <aloiscochard> kaiyin: there is some stuff in `Debug.Trace`, but I use them only as last ressort
05:15:32 <aloiscochard> usually writing better test is what I do
05:16:06 <kaiyin> tdammers: I did some simple tests, results are not good, and I would like to know what these variable are in the process.
05:16:22 <aloiscochard> kaiyin: Debug.Trace.traceShowId
05:17:53 <rpr> mauke I am getting this error: '   parse error on input `-- *100
05:18:18 <kaiyin> aloiscochard: like this? http://hastebin.com/cagurucino.coffee
05:18:20 <mauke> whoa
05:18:46 <mauke> rpr: sorry, I can't explain that and I don't have haskell here to test it
05:19:06 <aloiscochard> rpr: you should first do `import Debug.Trace` at the top
05:19:19 <aloiscochard> rpr: then you can use the function `traceShowId` in your code
05:19:48 <aloiscochard> rpr: also you seems to use haskell like an imperative language, and just throw line of code in the middle
05:19:50 <aloiscochard> that won't work
05:20:21 <aloiscochard> sorry
05:20:32 <aloiscochard> for the spamm rpr, I was trying to write to mauke :-(
05:20:38 <aloiscochard> to kaiyin
05:20:39 <aloiscochard> damn it
05:20:41 * aloiscochard hide
05:20:56 <rpr> ha no problem. you had me confused there
05:21:23 <frerich> Heh, the 'case () of _' thing is new to me. Like a multi-way if.
05:21:43 <kaiyin> aloiscochard: what is right way to use traceShowId then?
05:21:45 <opqdonut> aka a cond from lisp-world
05:22:18 <aloiscochard> kaiyin: it's a function that take a value and return that value, just like `id`
05:22:29 <aloiscochard> kaiyin: so let say you have a piece of code `foo $ bar 32`
05:22:57 <aloiscochard> kaiyin: you can trace the result of the function bar by doing: `foo $ (traceShowId $ bar 32)` for example
05:23:05 <EvanR> Cale: i might end up using your Writer suggestion
05:23:32 <aloiscochard> kaiyin: (I said it's a fun that take a value and just return it, but obviously... it print that value using `Show` in between :) )
05:24:34 <Cale> EvanR: Oh, that wasn't really a suggestion
05:24:47 <Cale> EvanR: It was just something to note
05:25:39 <Cale> Personally, if I have a lot of lists to concatenate, I'll often use functions directly.
05:26:25 <EvanR> when using MonadWriter w m constraint for a particular w, are you supposed to enable an extension of do MonadWriter X m =>
05:27:00 <Cale> It should say
05:27:09 <Cale> I think FlexibleContexts
05:27:43 <EvanR> probably overboard, ill probably use simpler types
05:34:37 <kaiyin> aloiscochard: that's very helpful. I have figured out where my function went wrong. thanks!
05:35:01 <aloiscochard> kaiyin: glad to hear that helped :-)
05:41:00 <kqr> how would I strip a particular element from the beginning and end of a list? in this case, my list contains several empty strings, and I want to remove them if they are in the beginning or end of a string
05:41:22 <kqr> I know how to do it, but it's a really long way around – I'm half expecting some library function that does that
05:44:05 <kqr> the beginning is simple (just dropWhile) but the end is tougher
05:44:18 <kqr> probably not very efficient either
05:44:33 <kqr> maybe I should try to circumvent the problem in this case
05:44:39 <merijn> kqr: "reverse . dropWhile isSpace . reverse . dropWhile isSpace"
05:44:55 <aloiscochard> > strip "    aaoeuaoeu      "
05:44:57 <lambdabot>  Not in scope: ‘strip’
05:45:01 <kqr> merijn, that sounds terribly inefficient
05:45:04 <Cale> Lists are not a very good data structure for that operation.
05:45:08 <kqr> yeah
05:45:15 <tdammers> :t dropWhileEnd
05:45:16 <lambdabot> (a -> Bool) -> [a] -> [a]
05:45:18 <aloiscochard> oh strip is on Text
05:45:20 <kqr> I'm thinking maybe I can drop earlier in the process
05:45:40 <tdammers> it's still O(n)
05:45:42 <merijn> kqr: Anything else is likely to be even less efficient
05:45:51 <kqr> when I'm still dealing with Texts and not [CustomType Text]
05:45:56 <kqr> merijn, that is true
05:46:00 <merijn> kqr: My answer isn't even as bad as it naively seems :)
05:46:04 <tdammers> with a data structure that support O(1) snoc, it'll be more efficient
05:46:13 <kqr> merijn, nah I'm sure laziness saves the day a bit, but still
05:47:22 <Cale> Laziness doesn't save much of anything there, it's just that depending on how long your strings are, you might just be optimising something which doesn't actually take much time.
05:49:08 <kqr> I don't know yet how long the sequences will be
05:49:31 <phaazon> do we have a filewatcher library?
05:49:39 <phaazon> there’s nothing in System.Directory
05:50:36 <EvanR> yes theres fsnotify
05:50:50 * tdammers starts pondering
05:51:23 <EvanR> but who watches the file watcher?
05:53:28 <kqr> is there a way to fail a parser if it returns an empty string?
05:53:32 <pavonia> EvanR: There's sentry for this
05:53:39 <kqr> (it might have parsed crap which got filtered out)
05:54:00 <EvanR> when null (fail "crap")
05:54:14 <EvanR> when (null crap) (fail "crap")
05:55:21 <kqr> ah! I should have known. thank you :)
05:58:44 <phaazon> EvanR: fsnotify
05:58:46 <phaazon> ok, thanks
06:24:03 <gregnwosu> greetings .... anyone know much about the flavour of haskell used at Standard Chartered
06:24:24 * hackagebot HMap 1.2.2 - Fast heterogeneous maps and unconstrained typeable like functionality.  http://hackage.haskell.org/package/HMap-1.2.2 (AtzeVanDerPloeg)
06:24:56 <akegalj_> gregnwosu: its strict, i know that much
06:25:06 <dcoutts> it's only strict by default
06:25:20 <dcoutts> there's explicit laziness in there too
06:26:16 <dcoutts> gregnwosu: are you trying to find out anything specific?
06:26:22 <dcoutts> they've given a number of talks
06:26:59 <EvanR> strict haskell ?!
06:29:54 <c_wraith> One of the things they've mentioned is that they're not actually sure strict-by-default is a win.  It was an experiment, though
06:30:01 <akegalj_> dcoutts: can you point me on these talks?
06:31:10 <dcoutts> akegalj_: I don't have references to hand but there's an old one at CUFP a few years ago and there's a more recent one too I think, search for the language name
06:31:18 <kqr> why is the strict-vs-lazy-by-default question so hard? they are such fundamentally different things that I'd assume it would be easy to tell which is best
06:31:24 <kqr> or maybe that's what makes it hard
06:31:41 <dcoutts> mu is probably closest to a full on experiment as you can get
06:31:47 <c_wraith> kqr: the problem is that both are wrong approximately 50% of the time.
06:32:03 <c_wraith> kqr: so you have to choose the default with the better failure mode
06:32:16 <dcoutts> kqr: and if you listen to Neil or Lennart, they're equivocal on the issue
06:32:41 <gregnwosu> hmmmm, i just wanted to know whether it would be a good idea to work for SC or whether it would be harmful to the Haskell I know (and love) already
06:32:46 <c_wraith> kqr: and doing that requires a huge understanding of a ton of issues, including things like programmer experience and psychology which are nearly impossible to quantify
06:32:54 <merijn> gregnwosu: Your best bet would be to ask augustss when he's in her
06:33:14 <dcoutts> c_wraith: that's what makes the mu example so interesting, it is large with a large non-expert userbase
06:33:21 <hodapp> mu example?
06:33:21 <merijn> gregnwosu: SC has about 1 million lines of GHC haskell and 1.5 million of Mu
06:33:28 <merijn> gregnwosu: So I wouldn't worry too much :)
06:33:44 <merijn> gregnwosu: (At least, those where the rough numbers I heard from Lennart at IFL'13)
06:34:09 <dcoutts> gregnwosu: the only problem with working for SC is that we'll never see you ever again :-)
06:34:09 <c_wraith> dcoutts: my question is how much code is written that includes rewriting functions that aren't lazy enough.  That's ridiculous to try to quantify.
06:34:17 <dcoutts> no code escapes the black hole
06:34:29 <dcoutts> (not strictly true, but mostly)
06:34:37 <merijn> dcoutts: Didn't shake escape/get reimplemented by Neil?
06:34:54 <merijn> Maybe he can help Lennart fight the lawyers to open source Mu :p
06:35:05 <dcoutts> merijn: yes, one of the few examples. Reimplemented I think.
06:35:31 <dcoutts> or perhaps I'm misremembering, Max started reimplementing it iirc, and then finally ndm was able to get it approved
06:35:35 <dcoutts> or something like that
06:35:37 <cfoch> hello
06:35:40 <dcoutts> but it's a huge effort
06:35:50 <cfoch> has someone installed ghc7.8 in Fedora 20 ?
06:36:04 * dcoutts uses 7.8 in F20
06:36:23 <dcoutts> and 7.6, 7.4, 7.0, 6.12, 6.10, 6.8, 6.6, 6.4
06:36:30 <merijn> Last I heard the main reason Mu isn't open source is that bank lawyers are really paranoid and worried about someone using it then suing them
06:37:14 <cfoch> dcoutts: how?
06:37:32 <dcoutts> cfoch: downloaded the tarball, unpacked, installed
06:38:00 <cfoch> but how did you do to have multiple versions? this is not with cabal :S or yes?
06:38:12 <dcoutts> they're all in /usr/local
06:38:23 <silver> what's Mu?
06:38:34 <dcoutts> cfoch: the default layout for ghc installs is multi-version
06:38:45 <akegalj_> silver: mu is haskell-like compiler from standart charterd
06:38:46 <dcoutts> silver: SC's Haskell-a-like
06:39:07 <dcoutts> silver: mainly for integrating with their existing systems/runtime
06:39:14 <cfoch> and how do you switch between versions?
06:39:26 <dcoutts> cfoch: I don't they're all available on the path at once
06:39:42 <dcoutts> cfoch: but the unversioned symlink points to one of them
06:39:57 <dcoutts> again, this is just the standard way the ghc ./configure; make; make install  works
06:40:36 <dcoutts> for ghc in ghc-7.6.3 ghc-7.8.4 ghc-7.10.xxxx; do cabal configure -w $ghc; ... ; done
06:40:53 <merijn> cfoch: GHC uses a per-version database so there's not a lot to do
06:41:00 <dcoutts> super-easy to test packages with half a dozen versions
06:41:03 <merijn> cfoch: Cabal just uses whichever ghc is first in your path
06:41:12 <hexagoxel> cfoch: another option is to use --with-compiler -w option of cabal configure/install
06:41:24 <merijn> So I just have several parallel installations to different directories and change my path to put whicever one I want first
06:41:25 <hexagoxel> ah, dcoutts just mentioned it
06:41:29 <dcoutts> cabal configure -w $ghc
06:41:31 <dcoutts> right ^^
06:41:53 <dcoutts> I have all of them in /usr/local/bin
06:41:59 <dcoutts> which is also the default
06:43:07 <gregnwosu> dcoutts: why do you think you wont see me again if I work for SC?
06:47:34 <gregnwosu> i was really inspired by the "haskell in the large" slides, its exactly what i want to focus on
06:49:38 <gregnwosu> the algebra of programs expressions, i didnt think it was possible to Fix recursion with a strict language
06:53:28 <akegalj_> gregnwosu: can you point out to slides? i cant find them (expired link)
06:58:10 <meretrix> Is there any way to define instances within a type class definition?
06:58:14 <meretrix> Something like this: http://lpaste.net/121493
06:59:03 <merijn> meretrix: No, because that makes no sense
06:59:09 <merijn> meretrix: Instances are always global
06:59:12 <kaiyin> I am trying to implement Graham scan in haskell: https://gist.github.com/kindlychung/9db363a4cf6c2f6e1596 I need to sort all points by their angle formed with the lowest point.
06:59:24 <dcoutts> gregnwosu: I'm half joking. It's just what's happened to lots of other people who work there. They work hard and don't have any spare time anymore. Neil is one partial exception (out of dozens).
06:59:46 <meretrix> Ok, I guess I'll need to use template haskell then.
06:59:57 <merijn> meretrix: How would that help?
07:00:01 <c_wraith> meretrix: what are you actually trying to do?
07:00:04 <merijn> meretrix: TH won't make it local...
07:00:12 <kaiyin> The problem is, when these are equal, I don't know how to put the point with smaller x-coord first.
07:00:14 <meretrix> I just want to be able to automatically make any type of MyClass an instance of a bunch of other classes.
07:00:35 <merijn> meretrix: That sounds like it creates a nightmare of OverlappingInstances
07:00:39 <frerich> Anybody here who has some experience with writing web applications in Haskell? I'm using Scotty + Shakespeare (for templating) and need to serve a couple of static files. I wonder whether I should maybe convert them to Hamlet templates to benefit from the compile-time checking, or whether that's maybe overkill and I'd just stay with external .html files.
07:00:48 <meretrix> That may be true.
07:01:22 <creichert> frerich: http://hackage.haskell.org/package/wai-middleware-static
07:01:42 <creichert> if you're not going to edit it much, or have other static files, that middleware will work
07:02:20 <frerich> creichert: Ah, that's neat - so far, I was hand-wiring the routes myself :-}
07:04:26 <creichert> no problem
07:04:38 <LostPlanet> i thought i found a bug where "take 10 (cycle [0])" gave me a list of 10 zeros , but cycle 0 10 didn't work
07:04:54 <LostPlanet> i mean "replicate 0 10" didn't work
07:05:00 <LostPlanet> but actually i should have typed "replicate 10 0"
07:06:05 <LostPlanet> i'm not sure i'm clear yet on why "take 10 (cycle [0])" works but i can't just do take 10 cycle [0] without the parens
07:06:26 <c_wraith> LostPlanet: that's because of how function calls work.
07:06:29 <LostPlanet> i thought function call had higest priority
07:06:37 <LostPlanet> maybe its a left to right ordering thing
07:06:42 <c_wraith> LostPlanet: (((take 10) cycle) [0])
07:06:55 <LostPlanet> ahh
07:07:01 <c_wraith> That's how it's associated if you don't specify something else
07:07:13 <c_wraith> and cycle isn't a list
07:07:18 <LostPlanet> makes sense
07:10:45 <akegalj_> dcoutts: do you know is that the case (about not having life in SC) in jane street too? (if you have info)
07:13:38 <merijn> You can have a life
07:13:53 <merijn> But it's only allowed to involve taking pictures of sunsets :)
07:14:03 <akegalj_> merijn: :P thanks
07:14:05 <gregnwosu> thats good, as i would quite like one
07:14:18 <EvanR> you can live a Double life
07:14:22 <EvanR> or a Half life
07:15:07 <frerich> OTOH, you could also try to find a way to use your powers for good. ;-)
07:16:00 <EvanR> FMAP LIFE
07:16:13 <EvanR> k that doesnt work so good
07:17:56 <kaiyin> Do huskell programmers find nested guards disgusting? https://gist.github.com/kindlychung/9db363a4cf6c2f6e1596
07:18:08 <gregnwosu> EvanR: would really like to use powers for good, there are just so few people using haskell
07:18:19 <EvanR> Bool is gross
07:19:49 <gregnwosu> i find nested guards pretty unecessary, just create another function
07:20:10 <xnull> gregnwosu: write Hackage2 and maybe some folks would actually use the language...
07:20:28 <c_wraith> we're already on hackage 2
07:20:40 <gregnwosu> xnull: ok but who will pay my bills?
07:21:08 <gregnwosu> hackage doesnt need haskell code it needs CSS
07:21:18 <EvanR> gregnwosu: gotta find funding, everybody on earth does this
07:21:20 <sivteck> lets levy haskell tax!
07:21:35 <gregnwosu> ill pay mine lazily
07:21:48 <tdammers> what exactly is wrong with hackage?
07:22:04 <EvanR> write a proposal then contact big wigs and explain what the money will do
07:22:04 <xnull> c_wraith: where, when
07:22:05 <xnull> how
07:22:16 <tdammers> hackage 1 had some quirks and performance issues, but the current version works well enough IMO
07:22:18 <xnull> tdammers: lack of moderation
07:22:33 <EvanR> if you think its worth it, maybe somebody with money agrees
07:22:34 <tdammers> xnull: social problem though :D
07:22:47 <xnull> set it up so there's an approval system
07:22:53 <xnull> have some standards, boom
07:22:55 <EvanR> gross
07:23:07 <EvanR> beaucracy city
07:23:13 <xnull> suddenly people don't think haskell is worthless academic trash that you can't use in the Real World(TM)
07:23:15 <merijn> xnull: There are plans for a voting/approval system for hackage
07:23:15 <c_wraith> xnull: so..  you want stackage.  it already exists
07:23:28 <zomg> Moderation is a double edged sword though.. Easy contribution -> more likely for people to participate, and thusly use Haskell
07:23:29 <EvanR> academic trash
07:23:30 <xnull> does stackage work with cabal?
07:23:40 <c_wraith> xnull: of course.  It'd be worthless if it didn't
07:23:43 <xnull> zomg: i think my point weighs much heavier
07:23:51 <xnull> c_wraith: awesome
07:23:55 <xnull> i'll check it out
07:24:03 <merijn> You can setup custom hackage servers to and point cabal at those...
07:24:03 <zomg> xnull: so why not just have a fairly "free/relaxed" package system, and a curation system on top?
07:24:09 <merijn> So I don't see the problem
07:24:15 <xnull> zomg: whatever cuts down on the crap
07:24:24 <unknownloner> even gem/npm dont have approval systems right? and they're used quite a bit
07:24:36 <zomg> A good package system is important to make things easy to install etc., and if it's too limiting for contributors, then packages won't be sent there so much which cuts down the usage
07:24:46 <zomg> unknownloner: yeah npm at least is you just register an account and that's it, publish whatever
07:24:57 <xnull> i would also argue that a /good/ package system would let me remove packages >.>
07:25:07 <EvanR> here we go
07:25:10 <EvanR> again
07:25:33 <hodapp> wait, Haskell is worthless academic trash?
07:25:37 <hodapp> why did no one here tell me this?
07:25:37 <xnull> no hodapp
07:25:41 <unknownloner> apparently
07:25:44 <hodapp> EvanR: YOU LIED TO ME
07:25:45 <zomg> lol
07:25:49 <xnull> the statement i made was clearly facetious
07:25:54 <merijn> xnull: Why? That would potentially break any number of internal/unreleased cabal packages depending on whichever package you remove
07:26:03 <merijn> Not to mention released cabal packages
07:26:12 <tenniscp25> Sorry, noob question. Why does aeson's .: operator return Parser a? Wouldn't it be easier if it just returns a?
07:26:15 <zomg> Anyways, talking about npm, it does have a lot of useless packages in it, but on the other hand, it makes it super simple to install anything and publish your packages
07:26:23 <zomg> which is great for adoption I think
07:26:26 <xnull> merijn: why can't it work like any other package manager?
07:26:33 <EvanR> tenniscp25: the Parser type handles parse errors for you
07:26:42 <zomg> if you need to find a good package, google tends to return the good ones first :)
07:26:58 <EvanR> tenniscp25: in javascript, the "easier" way leads to invalid data propagating through the program until maybe it crashes
07:26:59 <merijn> xnull: Because no one has the time to hack on cabal
07:27:12 <kqr> kaiyin, since it's obvious what the function does, I don't actually mind
07:27:15 <xnull> and why not?
07:27:17 <merijn> xnull: Cabal is being developed/maintained by like 2-3 people who have fulltime jobs that are "not hacking cabal"
07:27:22 <tenniscp25> (allow me to think a bit ..)
07:27:27 <kqr> kaiyin, I think they become a problem only when they obscure the meaning of the code
07:27:35 <xnull> merijn: why's that the case?
07:27:36 <merijn> xnull: Because everyone who complains about cabal doesn't bother to help out hacking/improving it
07:27:39 <EvanR> "omg i cant auto remove packages"
07:27:43 <xnull> aha
07:27:46 <xnull> nice response time
07:27:57 <merijn> xnull: Why are you here complaining instead of in #hackage to hack on it?
07:28:26 <xnull> because i wasn't aware #hackage existed
07:28:32 <merijn> I mean, there's tons of features I'd LIKE cabal to have, but since I don't have the time to help add them it hardly feels fair to blame Duncan for not adding them in his spare time instead of having a life
07:28:37 <kaiyin> xnull: see here https://mail.haskell.org/pipermail/haskell/2007-December/020019.html
07:29:09 <kaiyin> Some people seem to totally despise guards.
07:29:37 <xnull> i'm just saying, haskell is a pretty big thing; i believe it deserves more recognition than it gets and the only way to do that is to improve the tools, advertise, and make more stuff with it
07:29:37 <gregnwosu> wasnt there some plans for doing awesome "backpacky" things with hackage
07:29:47 <gregnwosu> or was it cabal
07:30:02 <EvanR> kaiyin: i depsite most bool tests more complex than "x < N"
07:30:08 <EvanR> despise
07:30:11 <kqr> EvanR, why?
07:30:27 <EvanR> because they are hard for me to verify just by reading
07:30:27 <Clint> xnull: i use debian. it has a package manager that works.
07:30:36 <tenniscp25> EvanR: Thank you. I think I get it.
07:30:37 <gregnwosu> also there was a presentation from london haskell on how to help hack cabal recently , is the video online, i do have a little time on my hands at the moment
07:30:50 <hodapp> xnull: Do you think this conclusion is something that people miss?
07:30:58 <xnull> hodapp: at times
07:31:02 <hodapp> xnull: I don't.
07:31:02 <xnull> not usually
07:31:21 <kaiyin> Tooling, tooling, tooling... If only haskell has something similar to IntelliJ for java.
07:31:31 <EvanR> haskell doesnt need to go out of its way to accumulate tons of programmers at all costs
07:31:42 <EvanR> kaiyin: there happens to be an intellij plugin...
07:31:47 <gregnwosu> kaiyin: theres haskforce for intellij
07:31:59 <gregnwosu> although its refactoring leaves a lot to be desired
07:32:03 <xnull> EvanR: i just want to use it at work on a team
07:32:06 <EvanR> haskell can concentrate on improving and experimenting the language
07:32:07 <xnull> :^)
07:32:13 <xnull> and not work for IMVU
07:32:17 <EvanR> people who really care and are up to it can help if they want
07:32:29 <gregnwosu> i have seen an ide written in haskell for haskell i cant remember the name , i think it was pretty good
07:32:31 <hodapp> xnull: I highly encourage you to work on improving the tools, advertising, and making stuff with Haskell.
07:32:34 <xnull> gregnwosu: yi
07:32:37 <tenniscp25> leksah?
07:32:42 <hodapp> I've just not really needed an IDE for Haskell, I guess
07:32:44 <merijn> xnull: The simple trade-off is: I and many other people think the haskell tooling is good enough that I'd *rather* work on something more fun/paying better than improving the tooling given my limited amount of free time
07:32:54 <hodapp> the main things I've needed an IDE for are "real-world" languages that are sucktastic
07:33:40 <gregnwosu> hodapp: emacs? i know its a tough learning curve but very rewarding , unfortunately there isnt anything out there that does refactoring using ghc 7.8.x .
07:33:46 <xnull> for haskell one needs a shell, a basic editor, and something to browse hoogle with
07:33:48 <merijn> xnull: So unless someone collects money to employ me or someone else to improve the tools
07:33:49 <hodapp> gregnwosu: Emacs is what I use but I don't really consider it an IDE
07:33:54 <hodapp> xnull: Great! Go write it.
07:34:01 <hodapp> xnull: Or, go fund it.
07:34:06 <xnull> it's already been written
07:34:19 <EvanR> IDE = your editor and ghci
07:34:22 <gregnwosu> hodapp: perhaps you havent configured it well enough, i get code completiton and a repl out of it
07:34:26 <xnull> it's called urxvt, vim, and firefox
07:34:27 * hackagebot HMap 1.2.3 - Fast heterogeneous maps and unconstrained typeable like functionality.  http://hackage.haskell.org/package/HMap-1.2.3 (AtzeVanDerPloeg)
07:34:36 <hodapp> gregnwosu: I never said I *wanted* an IDE.
07:34:57 <gregnwosu> ah. sorry .
07:35:04 <hodapp> gregnwosu: Emacs has been suiting me just fine.
07:35:24 <hodapp> last time I worked with IDEs full-time, I wanted to punt kittens.
07:35:32 <gregnwosu> yes im just annoyed that HaRe doesnt work with ghc 7.8
07:35:42 <aloiscochard> so, I'm in the quest of writing a C binding for haskell
07:35:44 <tdammers> last time I worked with IDE's full-time, I was still on windows
07:35:48 <aloiscochard> but I'm facing a function like this: grpc_event *grpc_completion_queue_next(grpc_completion_queue *cq, gpr_timespec deadline);
07:35:50 <hodapp> tdammers: same.
07:35:57 <aloiscochard> where `gpr_timespec` in a struct
07:36:00 <hodapp> tdammers: and Visual Studio 2010
07:36:02 <gregnwosu> i dont want to manually refactor, i believe that computers should be made to work wherever they can do so reliably
07:36:03 <aloiscochard> and I don't see how I can handle that
07:36:19 <creichert> but refactoring haskell is just so fun :)
07:36:20 <xnull> last time i worked with IDEs full time i was on CP/M
07:36:27 <aloiscochard> it seems like the commonly accepted solution is to create manually wrapper function that use a pointer instead of the struct directly
07:36:36 <aloiscochard> if someone have some tips on that, ty
07:36:57 <EvanR> xnull: its funny you were saying "more people wont like haskell until theres a package manager" and then "who needs an IDE"
07:36:59 <gregnwosu> creichert: do i detect sarcasm?
07:37:10 <creichert> i'm very serious, actually :)
07:37:24 <EvanR> i.e. two things people often demand
07:37:28 <gregnwosu> anyone worked at Barclays? how does the culture compare to SC
07:37:31 <hodapp> the refactoring I've done so far has not been a huge endeavor
07:37:31 <xnull> EvanR: there are IDEs
07:37:34 <EvanR> both unnecessary
07:37:47 <xnull> i'm happy with hackage
07:37:52 <xnull> i'm happy with vim+ghci
07:38:02 <xnull> i'm not happy with the stigma surrounding haskell
07:38:14 <EvanR> i didnt get that before
07:38:20 <EvanR> now what are you referring to
07:38:23 <creichert> stigma?
07:38:39 <xnull> "suddenly people don't think haskell is worthless academic trash that you can't use in the Real World(TM)"
07:38:40 <tdammers> hodapp: ya, same here... no wait, VS 2008 IIRC
07:38:42 <zomg> yeah, what stigma? :)
07:38:45 <gregnwosu> xnull: hlint is great too, really good suggestions
07:39:02 <zomg> most people I've talked to about haskell definitely didn't think it was "academic trash and can't use in real world"
07:39:03 <kqr> creichert, I also like refactoring haskell!
07:39:12 <xnull> zomg: my experience has been entirely to the contrary
07:39:12 <kqr> creichert, maybe it's just a personality type that lends itself to symbolic manipulation
07:39:18 * frerich learned a lot of nice Haskell tricks after actually using hlint routinely by integrating it into vim
07:39:18 <zomg> they were mostly weirded out by the syntax, how people talk about scary words like monads, and such
07:39:26 <gregnwosu> stigma= "haskell is for navel gazing brainiacs"
07:39:30 <zomg> honestly it's the lingo that seems to put most people off
07:39:33 <xnull> ^
07:39:34 <hodapp> The people I've met who had that opinion about Haskell had the same opinion of pretty much every other language except for C++, Java, and PHP.
07:39:35 * hackagebot shake-pack 0.1.0 - Shake File Pack Actions  http://hackage.haskell.org/package/shake-pack-0.1.0 (LukeHoersten)
07:39:37 * hackagebot shake-minify 0.1.1 - Shake Minify Rules  http://hackage.haskell.org/package/shake-minify-0.1.1 (LukeHoersten)
07:39:37 <creichert> I just ignore that stuff and keep writing haskell code :)
07:39:44 <xnull> a large part of it is indeed
07:40:01 <zomg> when you talk to them about it in a language they understand they seem to be more interested
07:40:14 <xnull> mhm
07:40:33 <xnull> i just wonder why it takes talking to them personally to alleviate the intimidation
07:40:38 <hodapp> someone should write a tutorial that explains monads in a way normal programmers can understand
07:40:42 <EvanR> haskell is for brainiacs
07:40:49 <kqr> hodapp, that's a good suggestion, I might try that
07:40:50 <xnull> hodapp: heh
07:40:54 <EvanR> that sounds like something a new generation of "brogrammers" came up with
07:40:59 <xnull> hasn't that already been done hundreds of times
07:41:01 <zomg> xnull: because most of the time when someone writes about haskell, it's not written in a way that's easy to understand
07:41:07 <hodapp> xnull: thatsthejoke.jpg
07:41:08 <zomg> but that's a problem with most technical articles you see
07:41:14 <zomg> even if it's not about haskell
07:41:16 <xnull> hodapp: justchecking.webm
07:41:26 <c_wraith> my sales pitch for haskell is that in haskell, the easiest thing to do and best-practices tend to be the same thing
07:41:41 <xnull> c_wraith: that's the same for Python
07:41:48 <EvanR> xnull: lol wut
07:41:50 <creichert> heh
07:41:53 <zomg> Easiest pitch for haskell in js-land tends to be "this would have never happened in haskell" when you fix some bugs or whatever :)
07:41:56 <c_wraith> xnull: Err.  Immutable data is a best practice. :)
07:41:56 <xnull> read The Zen of Python
07:42:04 <xnull> aha, yeah
07:42:10 <c_wraith> xnull: and immutable data is nearly impossible in python :)
07:42:12 <EvanR> theres a zen of python ? :\
07:42:21 <hodapp> EvanR: get yourself to a Python interpreter and run 'import this'
07:42:26 <EvanR> python and motorcycle maintenance
07:42:30 <frerich> When introducing fellow programmers to Haskell I often compare it with writing love letters: it's certainly possible in German but you gotta be very careful not to make it sound like a declaration of war. It's much easier in French, in fact - you almost get love letters for free. Different languages just let you express some things better than others. :)
07:42:43 <EvanR> get thyself to a pythonery
07:42:57 <EvanR> hodapp: oh...
07:43:03 <EvanR> i remember this
07:43:11 <hodapp> xnull: I've read The Zen of Python probably around 50 or 60 times by now. That I don't exactly agree is not because I've not read it.
07:43:40 <kqr> frerich, that is so prejudiced haha
07:43:42 <hodapp> xnull: it has good principles in it, for sure.
07:43:47 <EvanR> if the implementation is easy to explain, it may be a good idea
07:43:53 <EvanR> k lisp
07:43:55 <hodapp> xnull: whether Python executes them is another matter
07:43:55 <xnull> maybe i'm not thinking of the zen of python, but rather a commentary i read on it once
07:43:57 <kaiyin> frerich: I feel the urge to quote what you just said on facebook.
07:44:35 * hackagebot derive-topdown 0.0.0.1 - This library will help you generate Haskell empty Generic instances and deriving type instances from the top automatically to the bottom for composited data types.  http://hackage.haskell.org/package/derive-topdown-0.0.0.1 (songzh)
07:44:43 <xnull> in any case, i agree that haskell accomplishes that goal better
07:44:43 <tdammers> Python doesn't even agree with the Zen Of Python
07:44:52 <tdammers> (and we're back in -blah territory)
07:44:55 <hodapp> tdammers: import zen?
07:44:56 <xnull> mfw lambda syntax
07:45:02 <c_wraith> tdammers: just a minor disagreement between theory and reality
07:45:31 <xnull> python could be done a lot better than it has been, imho
07:45:56 <xnull> now that i've made a controversial blanket statement, i'm going to get out of bed and go make coffee
07:45:58 <EvanR> c2 wiki is accumulating a lot more haskell
07:46:08 <EvanR> speaking of zen of python
07:46:11 <hodapp> xnull: that's not a controversial blanket statement, it's basically a truism for anyone who is not a zealot
07:46:19 <xnull> oh
07:46:21 <hodapp> I like c2 wiki
07:46:25 <xnull> ^
07:46:40 <EvanR> c2 wiki hurts my brain after a while
07:46:56 <xnull> how is c2 wiki maintained
07:47:01 <EvanR> for a while it seemed to know nothing about haskell stuff
07:47:19 <tdammers> c_wraith: that's theoretically impossible
07:47:27 <tdammers> hodapp: import this
07:48:18 <Big_G> Do list comprehensions in languages like Python lacking something compared to a language like Haskell?
07:48:33 <xnull> Big_G: prettiness
07:48:35 <EvanR> type safety
07:49:21 <kqr> -X MonadComprehensions
07:49:29 <geekosaur> ghc's list comprehensions also have some extensions available (parallel list comprehensions. monad comprehensions, SQL-like extensions)
07:49:36 * hackagebot OpenGL 2.11.1.0 - A binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGL-2.11.1.0 (SvenPanne)
07:50:15 <Big_G> Is there a way to have a recursive list comprehension?
07:50:39 <kqr> kinda? let rec = 1 : [x | x <- rec]
07:50:39 <SlowBait> Hi, I'm trying to create a type from an Array size, so that the functions I'm declaring can work only between Arrays of the same size.
07:50:41 <kqr> or something
07:50:59 <EvanR> let fibs = 0 : 1 : [ a + b | (a, b) <- zip fibs (tail fibs)] in fibs
07:51:01 <Big_G> kqr, I'm not sure if that is what I want
07:51:29 <EvanR> uses the list being constructed in the list comprehension
07:51:40 <Big_G> For example, I have a list of nested lists but I don't know how far they go down. I want to operate on the primitives in those  lists but I don't know how deep to go
07:51:42 <kaiyin> what is the extension name for haskell module files?
07:51:50 <SlowBait> My biggest problem is to make Array an instance of Monoid, because the mempty function should change for each size, and each size should be an instance
07:51:55 <kqr> Big_G, that sounds like a type problem more than a list comprehension problem
07:52:13 <kqr> Big_G, the type usually tells you how deeply nested the list is
07:52:23 <EvanR> SlowBait: you need to do some dependent type tricks
07:52:33 <EvanR> SlowBait: and indexed type
07:52:35 <EvanR> an*
07:52:57 <Big_G> kqr, I know that but I'm saying I can't hardcode how far to go down into the list. I just have to say go down until you see a primitive
07:53:01 <Big_G> i.e. a non-list
07:53:04 <frerich> Big_G: In some cases Haskell list comprehensions are closer to Pythons generator expressions (think infinite sequences).
07:53:30 <EvanR> Big_G: maybe dont use list comprehensions (or lists) for that
07:53:30 <kqr> Big_G, but if your type is, say, [[[[a]]]] then you know you need to go four levels down?
07:53:46 <Big_G> EvanR, What should I use then?
07:53:55 <EvanR> a tree, a Data.Data, something
07:54:24 <cfoch> hello
07:54:29 <funfunctor> EvanR: hi
07:54:32 <cfoch> I am having problems to build ghc 7.8
07:54:36 <cfoch> http://dpaste.com/1FFY2ZZ
07:54:46 <phaazon> http://stackoverflow.com/questions/28829976/ffi-and-static-libraries-used-in-application
07:54:50 <phaazon> I edited my issue
07:54:55 <cfoch> I need deepseq >=1.2 && <1.4
07:54:58 <phaazon> that’s a weird issue…
07:55:03 <cfoch> but it seems I have it already installed
07:55:41 <xnull> is there a good beginner's resource on dependent types?
07:55:42 <EvanR> cfoch: ive encountered stuff like this
07:55:56 <EvanR> xnull: theres a tutorial for coq
07:56:22 <cfoch> what can I do?
07:56:33 <xnull> EvanR: something perhaps like for Idris
07:56:56 <lpaste> funfunctor pasted “No title” at http://lpaste.net/121500
07:56:57 <phaazon> hey
07:57:02 <EvanR> xnull: idris has a tutorial, epigram has a guide
07:57:05 <phaazon> is there a place where I can find all the returned code by the RTS?
07:57:25 <fread2282> what paper should I cite for curry-howard?
07:57:45 <EvanR> cfoch: uninstall the 0.4.0.0
07:57:52 <funfunctor> i'm looking for advice on binding these C functions in particular because they require a pre-allocated buffer that can change in size
07:58:29 <cfoch> EvanR:  0.4.0.0 ? or do you mean I should uninstall deepseq 1.4.0.0 ?
07:58:35 <EvanR> funfunctor: Ptr a
07:58:43 <EvanR> cfoch: 1.4.0.0
07:58:56 <funfunctor> EvanR: ok, a pointer to some type a, go on..
07:59:08 <kaiyin> haskforce does not have a repl, sadly.
07:59:17 <EvanR> funfunctor: thats how you pass "a buffer" to C, or get one back
08:00:00 <funfunctor> EvanR: but what about the C's API expectation of having malloc called before?
08:00:25 <EvanR> funfunctor: well, you get a Ptr from malloc
08:00:29 <EvanR> or alloca, or whatever
08:00:37 <funfunctor> the size depends on a couple of things, the number of samples but also the format
08:01:00 <EvanR> youre not likely to be able to add a bunch of type safety directly to the binding
08:01:13 <funfunctor> I see
08:01:14 <EvanR> you just need to get the c function so you can wrap it with something else
08:02:13 <cfoch> EvanR: I did
08:02:14 <cfoch> ghc-pkg unregister deepseq-1.4.0.0 --force
08:02:19 <EvanR> why force?
08:02:20 <cfoch> and it doesn't work
08:02:28 <EvanR> cfoch: whats the error now
08:02:29 <funfunctor> well I would do #ccall bladerf_sync_rx , Ptr (<bladerf>) -> Ptr a -> CUInt -> Ptr (<bladerf_metadata>) -> CUInt -> IO (CInt)   currently
08:02:54 <cfoch> EvanR: the same error
08:03:10 <EvanR> funfunctor: you can make empty data types for placehoders (<bladerf>) so you dont get the pointers mixed up
08:03:27 <EvanR> cfoch: ... the error is "default version 1.4.0.0" ?
08:03:36 <cfoch> well... yes
08:03:36 <EvanR> exceptional
08:03:44 <funfunctor> EvanR: I use (<bladerf>) everywhere else in the binding for all the other functions that work
08:03:46 <cfoch> I still have this version
08:03:51 <EvanR> try removing deepseq without force
08:04:06 <EvanR> funfunctor: i didnt know that was valid syntax
08:04:20 <funfunctor> EvanR: struct bladerf; is defined in the C header so thats where that comes from.
08:04:29 <EvanR> oh its bindings DSL
08:04:35 <funfunctor> EvanR: its from bindingDSL
08:04:36 <funfunctor> yes
08:04:56 <EvanR> alright well nice binding declaration
08:05:01 <funfunctor> Ptr a is essentially void * right
08:05:14 <EvanR> sort of
08:05:38 <EvanR> it forces haskell programmer to use cast to get it to go anywhere
08:06:08 <EvanR> void* goes anywhere
08:06:27 <cfoch> EvanR: http://dpaste.com/2WADB50
08:06:51 <funfunctor> EvanR: my main issue is how to wrap these C functions up nicely, i.e. what should be the type-signature I aim for should be?
08:06:51 <EvanR> cfoch: what is ghc-pkg list | grep deepseq
08:07:00 <cfoch> how can I change the default version ?
08:07:08 <Big_G> There is obviously a lot of bias but would you recommend building a machine learning library in Haskell?
08:07:11 <cfoch>     deepseq-1.3.0.1
08:07:12 <cfoch>     deepseq-1.3.0.2
08:07:13 <EvanR> funfunctor: i have no idea what that function does
08:07:25 <cfoch> EvanR: ^
08:07:32 <EvanR> cfoch: i dont know if thats the problem
08:07:49 <phaazon> http://lpaste.net/8641330300967714816
08:07:51 <phaazon> wtf :(
08:08:43 <EvanR> funfunctor: instead of passing mutable buffers around, in haskell you want to pass immutable values around instead
08:08:53 <funfunctor> EvanR: they are the data paths to and from the radio, thats why I left the comments in
08:08:53 <EvanR> like Data.ByteString
08:09:05 <funfunctor> EvanR: yea exactly
08:09:37 * hackagebot gravatar 0.8.0 - Generate Gravatar image URLs  http://hackage.haskell.org/package/gravatar-0.8.0 (PatrickBrisbin)
08:09:59 <EvanR> dang i was hoping that was a package to generate gravatar images ;)
08:10:38 <toothbrush0> Hello #haskell
08:10:47 <funfunctor> hello
08:11:10 * tdammers is still looking for a package to resize images that doesn't rely on thread-unsafe FFI bindings
08:11:13 <toothbrush0> Does anybody have experience getting cabal to build UU attribute grammar files? i.e. compile .ag -> .hs before doing the rest?
08:11:18 <funfunctor> EvanR: yea so I allocate a buffer, pass it to the C function, peek it and somehow that ends up in a ByteString
08:11:31 <EvanR> td123: repa something?
08:11:38 <EvanR> tdammers:
08:11:53 <EvanR> funfunctor: look at Foreign.Marshal
08:12:11 <tdammers> repa?
08:12:43 <EvanR> matrix stuff dunno
08:12:50 <tdammers> ah hum not quite
08:13:12 <tdammers> basically I want imagemagick implemented as a pure haskell lib
08:13:22 <EvanR> that would be boss
08:13:57 <EvanR> funfunctor: peekArray :: Storable a => Int -> Ptr a -> IO [a]
08:14:00 <EvanR> a = Word8
08:14:09 <tdammers> I'd be fine with an FFI wrapper, too, if it were thread safe
08:14:39 <tdammers> can always resort to subprocesses, of course, but oh the runtime dependencies
08:15:17 <EvanR> tdammers: juicy pixels + comonad fu
08:15:24 <funfunctor> EvanR: thx i'm just trying to figure it now..
08:15:32 <EvanR> ah that doesnt resize
08:15:42 <tdammers> EvanR: I got this far myself :D
08:16:05 <tdammers> idk, if someone were to somehow glue repa and juicy together, that could almost work
08:16:33 <EvanR> convert an Image to a Repa, perform the resize, convert back
08:16:55 <EvanR> i have no idea if Repa can do that
08:17:18 <tdammers> me neither lol
08:17:46 <tdammers> also, I wouldn't be surprised if going through an imagemagick subprocess would turn out faster
08:18:48 <EvanR> upload an image to opengl and use a shader post-processor, then glReadPixels ;)
08:19:44 <govind_> Hi, A haskell beginner here.
08:20:16 <govind_> I am having trouble managing package bounds in my cabal file.
08:20:32 <tdammers> everyone does :D
08:21:30 <govind_> My doubt is how do I make sure that the dependencies needed by one package, fall in the same bound as the dependencies need by some other package?
08:21:47 <mauke> that's more a question than a doubt
08:22:37 <govind_> Yes, I suppose. Forgive my semantics.
08:24:39 <mauke> (well, saying "doubt" instead of "question" makes you sound indian. it's like saying "kindly" instead of "please")
08:24:55 <voidzero> but ok
08:25:04 <gregnwosu> has anyone figured out how to make snippet suggestions part of ordinary code completion?
08:25:04 <voidzero> back to the question at hand. :)
08:25:20 <gregnwosu> ...using something like autocomplete or company mode/
08:25:38 <govind_> For example, if a package I'm using depends on a library, say "lib > 1.0" and another one depends on "lib < 0.9", how can I install both these libraries?
08:25:59 <voidzero> i do that stuff in sandboxes, govind_
08:26:53 <govind_> Yes, but what if my project depends on the two conflicting packages? I don't think sandboxes would help in that case?
08:27:28 <voidzero> it depends on two versions, both installed?
08:27:55 <bennofs> govind_: you cannot use them in the same project, that is correct
08:28:02 <cfoch> EvanR: some idea?
08:28:24 <cfoch> i have installed  1.3.0.1, 1.3.0.2 according cabal
08:28:46 <cfoch> and ghc-pkg
08:29:44 <bloot> gloss font rendering is meh...
08:29:58 <govind_> I don't think it would be good idea to change the cabal files of the packages myself, just to get them to install?
08:30:09 <silver> it depends
08:30:18 <silver> it might work sometimes
08:33:20 <govind_> Hmm, okay.. But that would only be advisable in exceptional cases, if I'm not mistaken, right?
08:33:21 <EvanR> cfoch: first, dont --force uninstall anything
08:33:35 <EvanR> cfoch: next, cabal install deepseq
08:34:12 <cfoch> done... it installs the 1.4.0.0
08:36:21 <silver> govind_, well, if it fixes the problem then it is advisable, dependencies could be set too strictly and <0.9 package works without modifications with >lib-1.0
08:37:28 <silver> you could also search for alternative packages wich doesn't depend on old lib
08:38:03 <EvanR> cfoch: do cabal setup, then cabal build
08:40:24 <dami0> aw, i wanted to ask bonus if i could get a signed copy :(
08:49:39 * hackagebot web-routing 0.6.0 - simple routing library  http://hackage.haskell.org/package/web-routing-0.6.0 (HirotomoMoriwaki)
08:49:55 <athan> What's a good way to format stdout text? Just 80 cols?
08:50:02 <cfoch> EvanR: cabal setup ?
08:51:46 <athan> wait a tic, chrisdone's got some magic formatting lib
08:51:54 <Iceland_jack> @hackage formatting
08:51:54 <lambdabot> http://hackage.haskell.org/package/formatting
08:52:00 <Iceland_jack> it's very good
08:52:09 <funfunctor> is there a clean way to marshal one data into another.. data Foo = Foo { bad_name :: Int } into data Bar = Bar { nice :: Int } ?
08:52:54 <funfunctor> just making a type alias    type Bar = Foo does not make for cleaned up getters/putters
08:55:14 <Zemyla> Hmm. Does a Nonempty whose duplicate function produces the powerset of itself be a valid comonad?
08:57:47 <athan> Iceland_jack: I actually fibbed - I'm looking for something that "nicely" prints out to the terminal. Would this be a job for ncurses? Or could I just get away with the 80 column limit?
08:58:23 <athan> funfunctor: Why not make a `fromBar` or `barToFoo`?
08:58:44 <merijn> athan: There are several pretty printing libraries that include linewrapping at fixed widths
08:59:30 <athan> merijn: Ahh thank you. Do you have a favorite?
08:59:44 <funfunctor> athan: I /could/ but I was wondering if there was some kind of instance type alias foo I could do..
08:59:54 <merijn> No, never really used any of them, but I think there's an entire pretty printing category on Hackage
09:00:37 <athan> Better get my scuba gear
09:00:41 <athan> thanks merijn
09:01:12 <athan> funfunctor: The most I could see is a typeclass to overload the types during usage...
09:01:20 <athan> are you trying to make a consistent api over both types?
09:01:44 <athan> You might be able to get away with a data family or something :s
09:01:53 <athan> it's hard to guess without seeing what use cases you need
09:02:12 <funfunctor> athan: I have some horrible type names due to C FFI bindings
09:03:17 <lpaste> funfunctor pasted “No title” at http://lpaste.net/121503
09:03:19 <athan> funfunctor: Oooh, that doesn't sound nice. Can I see some code?
09:03:23 <athan> mindreader!
09:03:51 <funfunctor> athan: ^ ;)
09:04:20 <kaiyin> What is the best vim autocomplete plugin for haskell?
09:04:26 <athan> so BladeRFMetadata is a sub-record of the origional?
09:05:13 <lpaste> S11001001 pasted “clean way to marshal ... -> funfunctor” at http://lpaste.net/121504
09:05:21 <athan> kaiyin: There's a sweet post by benoffs I'm pretty sure, one sec
09:05:58 <athan> I'm bad with names :( kaiyin: https://github.com/begriffs/haskell-vim-now
09:06:15 <S11001001> funfunctor: ^^^
09:06:35 * funfunctor looks up Data.Coerce
09:06:41 <funfunctor> thx
09:07:34 <funfunctor> I don't even know whats happening there..
09:07:46 <funfunctor> how can this be safe in general?
09:08:00 <S11001001> funfunctor: coerce isn't actually doing anything
09:08:19 <funfunctor> oh?
09:08:49 <S11001001> funfunctor: if your data types aren't the same shape you'll get a type error when you try this.  Try adding another Int to one of the data types
09:09:11 <S11001001> funfunctor: so you'll recognize the sort of error that you get when you make a mistake
09:09:14 <funfunctor> fascinating !
09:09:32 <funfunctor> so in technical terms what is happening here
09:09:34 <funfunctor> :t to
09:09:35 <S11001001> funfunctor: the actual marshalling is being done by 'from' and 'to'.  all 'coerce' does is change a phantom type variable (which of course is *nothing* at runtime)
09:09:35 <lambdabot> (Contravariant f, Conjoined p, Functor f) => (s -> a) -> p a (f a) -> p s (f s)
09:09:48 <S11001001> funfunctor: that's a different to
09:09:58 <Zemyla> funfunctor: Do you know what a newtype is?
09:10:00 <funfunctor> :t from
09:10:01 <lambdabot> (Profunctor p, Functor f) => AnIso s t a b -> p t (f s) -> p b (f a)
09:10:28 <funfunctor> Zemyla: in what way?
09:10:32 <S11001001> funfunctor: https://webcache.googleusercontent.com/search?q=cache:KoceOs8j5P4J:https://ocharles.org.uk/blog/posts/2014-12-16-derive-generic.html+&cd=1&hl=en&ct=clnk&gl=us
09:11:51 <sgronblo> So if I want to fmap something to a IO [a], is this a case for monad transformers or something?
09:12:23 <kaiyin> athan: looks nice. how do you send text to a ghci session?
09:12:31 <merijn> sgronblo: What do you mean "fmap something to a IO [a]"?
09:12:38 <merijn> sgronblo: What's your input type and what's your output type?
09:12:59 <athan> kaiyin: I actually stopped using it because I'm not very good with vim. Not sure :\
09:13:19 <kaiyin> ok, thanks all the same.
09:13:25 <merijn> kaiyin: tbh, I just have tmux to split screen my terminal and just ":load" the file I'm editing into ghci
09:13:33 <merijn> kaiyin: And then use ":r" to reload after changes
09:13:54 <merijn> I'm pretty sure people have set up more elaborate things, but they don't seem worth the hassle of setting up
09:14:06 <coltfred> S11001001: That's really neat!
09:14:27 <sgronblo> merijn: hmm, seems like hlint managed to help me out a bit
09:14:35 <kaiyin> cool
09:14:48 <yac> I've got instance Default ConfigServer where one field is work_dir and I'd like to set it's default to getTemporaryDirectory >>= return . (</> "myapp")
09:14:53 <funfunctor> S11001001: thx !
09:15:06 <yac> but that's on IO a
09:15:20 <yac> how can I solve this?
09:15:39 <funfunctor> S11001001: btw, what happens in the case where some fields have slightly different types. i.e. the C binded data has WordXY and the Haskell native has Int
09:15:53 <yac> I think I'm gonna have to declare the work_dir as Maybe FilePath and fill the default in with some accessor function
09:15:57 <merijn> funfunctor: You need to mashall them
09:16:10 <S11001001> funfunctor: I bet it fails, but try and see.
09:16:13 <merijn> funfunctor: Haskell has builtin types for fixed with numerics
09:16:40 <funfunctor> merijn: you mean manually instead of using this coercible tricky
09:16:46 <merijn> funfunctor: Data.Word has Word8, Word16, Word32 and Word64 (and Data.Int has Int8, Int16, Int32 and Int64)
09:17:00 <funfunctor> oh hmm
09:17:22 <merijn> And then Foreign.C.Types has CInt CUInt, etc. which are the same as the corresponding C types int, unsigned int, etc.
09:17:23 <funfunctor> is Data.Word compat with Foreign ?
09:18:11 <funfunctor> I think Foreign.C.Types brings in WordXY also though?
09:18:13 <merijn> funfunctor: Data.Word gets auto-marshalled to the appropriate width C type, but if you need C interoperability then Foreign.C.Types is better, because that's guaranteed to be the same
09:18:18 <merijn> Probably
09:18:44 <merijn> A lot of them are newtypes around Word8, etc.
09:18:52 <funfunctor> I see ok
09:19:15 <cfoch> guys, what is cabal-setup ?
09:19:20 <funfunctor> sorry for all the questions, I just see room here for strange things to happen and hours of debugging wondering what happened...
09:19:30 <merijn> funfunctor: One example on why to use CInt:
09:19:34 <cfoch> or "cabal setup"
09:19:53 <funfunctor> merijn: sure, but I want my binding to have no C'ness to it on the user API
09:19:54 <cfoch> EvanR told me to execute the command "cabal setup"
09:20:13 <funfunctor> so I am just trying to tuck it under the rug..
09:20:25 <merijn> funfunctor: I hit a runtime system bug on OSX where Int was converted to a C int, but no one realised the following: My 64bit OSX C compiler had 32bit int, but my 64bit GHC used 64bit Int >.>
09:20:36 <merijn> funfunctor: fromIntegral + overflow checks
09:20:50 <merijn> > 2 :: CInt
09:20:51 <lambdabot>  Not in scope: type constructor or class ‘CInt’
09:20:51 <lambdabot>  Perhaps you meant one of these:
09:20:51 <lambdabot>    ‘Int’ (imported from Data.Int),
09:20:55 <merijn> oh, not imported
09:21:20 <merijn> funfunctor: Anyway, CInt, etc. are instance of Bounded and Num, so you can use fromIntegral to check
09:21:38 <merijn> This is tricky business, though
09:22:15 <merijn> Last time I dealt with this, my bugfix introduced an opposite bug and my fix-fix introduced the original bug again and only now is it actually fixed (all of this despite at least 4 people checking and signing off on both fixes!)
09:22:16 <funfunctor> merijn: I have fromIntegral in a few places to marshal one into the other should I be scared?
09:22:38 <merijn> See my last sentence and read it as "yes" ;)
09:22:57 <funfunctor> eeek! tricky stuff
09:23:09 <funfunctor> how can I know?
09:23:24 <funfunctor> what do you mean by overflow checks?
09:23:42 <merijn> funfunctor: Well, consider this: What if CInt is 32bit
09:23:47 <merijn> > maxBound :: Int32
09:23:49 <lambdabot>  2147483647
09:23:53 <merijn> vs
09:23:56 <merijn> > maxBound :: Int
09:23:58 <lambdabot>  9223372036854775807
09:24:11 <merijn> funfunctor: What do you do when your input Int is bigger than the max of CInt?
09:24:20 <merijn> fromIntegral will silently overflow
09:24:27 <athan> Is there a common introductory text for equational reasoning and proofs with programs?
09:24:30 <merijn> > 9223372036854775807 :: Int32
09:24:32 <lambdabot>  -1
09:24:33 <merijn> athan: Yes
09:24:38 <merijn> @where sf
09:24:38 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages", "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof
09:24:38 <lambdabot> assistant."
09:24:57 <merijn> athan: Free book + Coq exercises on proving properties :)
09:24:59 <athan> perfect :) Thank you merijn, hopefully I'll have it finished soon
09:25:09 <mmachenry> I am running this program copied from Haskell project skeleton for Haddock coverage. https://github.com/tfausak/haskeleton/blob/master/package-name/test-suite/Haddock.hs.template
09:25:12 <athan> I'm on Ch. 22 of TaPL!
09:25:13 <mada> thanks merijn
09:25:23 <mmachenry> I get an exception that cabal "haddock" exited with a 1
09:25:25 <merijn> funfunctor: So you need to 1) check that you don't overflow when converting and 2) decide how to handle when things do overflow
09:25:49 <merijn> funfunctor: See the changes in Event/Poll.hsc here https://phabricator.haskell.org/D407 for one way to handle them
09:25:59 <funfunctor> merijn: isn't this a bug in fromIntegral ??
09:25:59 <mmachenry> But when I run it it works fine on the command line. How do I debug this? The exit code when I run cabal haddock is 0 on the cmdline. But not readProcess in that github program
09:26:05 <infandum> I'm having issues profiling time: I have an executable that is slow. In the *.cabal file, I have a library and an executable. I installed in a sandbox with cabal install -p --enable-library-profiling --enable-executable-profiling. When I use +RTS -p, I usually see a nice list of functions and how long they take. However, when I do it here they all say 0 and MAIN is 95%. What is happening? All other functions
09:26:07 <infandum> have 0% which is weird and I can't see any part of MAIN which is using 95%
09:26:49 <funfunctor> merijn: does Haskell have asserts?
09:27:45 <funfunctor> merijn: thx for all the info !
09:27:56 <merijn> funfunctor: "is this a bug in fromIntegral" well, yes and no
09:28:06 <wayne> funfunctor: http://hackage.haskell.org/package/base-4.7.0.2/docs/Control-Exception-Base.html#v:assert
09:28:08 <merijn> It's not a bug in that it's documented that fromIntegral silently overflows
09:28:14 <merijn> It is a bug in the sense that it sucks :p
09:28:25 <silver> feature then!
09:29:10 <funfunctor> wayne: thx! merijn: would a assert be reasonable to use in a C binding do you think?
09:29:12 <merijn> infandum: 10 dollars on "forgot to insert profiling points" when building :)
09:29:26 <merijn> funfunctor: Sure, if you think the user minds crashing on failure
09:29:41 * hackagebot hunt-searchengine 0.3.0.1 - A search and indexing engine.  http://hackage.haskell.org/package/hunt-searchengine-0.3.0.1 (alexbiehl)
09:29:44 <merijn> funfunctor: Alternatively (like in my timeout example) you can have the haskell side loop until the entire timeout has passed
09:29:57 <infandum> merijn: You know what...I bet it's because it's one function called main haha, let me check
09:30:12 <funfunctor> merijn: I think its better than bricked hw or bugs not being fixed. crashes tend to force people to actually fix the fault
09:30:14 <merijn> infandum: Add "  GHC-Prof-Options:     -auto-all -caf-all -rtsopts" to your cabal file
09:30:36 <merijn> funfunctor: I meant: "If you can work around it in the haskell side of your library, you should"
09:30:52 <merijn> infandum: That will insert profiling points at every function
09:30:54 <funfunctor> merijn: well these functions (actually they are actions) tell the hw to write ints to registers and so on.. so better to not overflow
09:30:59 <brbblnch> Hi
09:31:15 <merijn> funfunctor: Then I think your API should use the appropriate fixed width type
09:31:22 <merijn> funfunctor: i.e. if you have 32bit registers, use Int32
09:31:31 <merijn> (or Word32)
09:31:37 <funfunctor> merijn: ok
09:32:10 <merijn> funfunctor: Those are basically int32_t and uint32_t, so for things like registers where you *know* the width those are your best bet
09:32:15 <infandum> merijn: Is there a faster way to insert profiling points? I have a large let clause, can it detect those somehow?
09:32:19 <funfunctor> I was thinking Word32 was form Foreign.C.Type and thats why I was not using Word32
09:32:19 <brbblnch> [ISo, afaik, the Curry-Howard correspondence uses the fact that a proof for the statement $A \land B$ is a pair $(a, b)$ of proofs for $A$ and $B$ respectively. [Girard] directly creates the primitive for an ordered pair in lambda calculus (the basis constructions are therefore [application, abstraction, "pairing", "projection"]).I get that in non-typed lambda calculus you can easily create an ordered pair from the classical primi
09:32:42 <funfunctor> its my own confusion
09:32:44 <merijn> infandum: What do you mean "faster"? Those argument only go into the cabal file of your library
09:33:03 <infandum> merijn: Or can I manually insert these "profiling points"?
09:33:03 <brbblnch> …yped lambda calculus ? [I asked on ##math first, but maybe this chan is more correct ?]
09:33:04 <funfunctor> whats the diff between Word32 and Int32 ?
09:33:37 <merijn> funfunctor: signed vs unsigned
09:33:47 <funfunctor> ok good, got that far then :D
09:33:48 <infandum> merijn: Ah, you already answered it with caf, let me check
09:33:48 <funfunctor> lol
09:34:04 <funfunctor> alright I think I understand it all better now
09:34:08 <mauke> brbblnch: was that a question?
09:34:17 <merijn> brbblnch: I'm not sure I actually get what your question is?
09:35:19 <funfunctor> IRC needs a question counter, I wonder how many questions have been asked in total for its history?
09:35:22 <brbblnch> mauke, merijn: Do you have to put "ordered pair" as a primitive of typed lambda calculus to have the curry-howard correspondance (or to get it cleanly) ?
09:35:44 <Xe> funfunctor: why? grep is fine? :P
09:36:17 <infandum> merijn: -caf-all did not do anything--do I need to invoke it after +RTS somehow?
09:36:46 <merijn> infandum: Hmm, I'm not that experienced with profiling, have you consulted the RWH chapter on profiling?
09:37:13 <merijn> brbblnch: hmm, interesting, I'm not sure?
09:37:15 <infandum> merijn: I'm pretty used to profiling, I just never saw everything in main before
09:38:36 <brbblnch> merijn: In untyped, I understand that creating an ordered pair is easy. But in typed, you can only play with types of the form $X -> Y$, but $A \times B$ seems to be crucial for the correspondence to work
09:39:54 <funfunctor> lol
09:40:50 <kaiyin> "haskell-vim-now: In less than ten minutes your Vim will transform into a beautiful Haskell paradise. " After half an hour it's still compiling.
09:42:48 <infandum> merijn: AH! GOT IT!
09:43:01 <infandum> merijn: It was the SCC pragma which can give precise points
09:43:10 <merijn> kaiyin: tbh, the only things I use is syntastic + hdevtools, the hdevtools on hackage doesn't work with 7.8, I think, but I have a fork on my github that does
09:43:28 <merijn> kaiyin: https://github.com/merijn/hdevtools
09:44:04 <merijn> I hope the work on ghci-ng merges into GHC soon so we can ditch hdevtools/ghc-mod all together and get good sandbox support too
09:45:38 <hseg> Hi. I've been wondering - is there any *safe* way of working with open type families that are not associated with typeclasses?
09:47:21 <Zemyla> Hmm, I was trying to figure out how to make the powerset function operate sensibly on infinite lists, but then i realized it can't.
09:47:50 <Zemyla> Fucking Cantor.
09:49:04 <infandum> This leads me to my next question: Does anyone know a fast way to calculate the binary coefficient? I mean, a very fast way?
09:49:33 <SlowBait> Hi, I'm trying to make Array an instance of monoid. The idea is to represent the homomorphisms of [0, n] with an Array with bounds (0, n). I'm stuck trying to define mempty, since it depends on the size of the array
09:49:44 <infandum> This one: https://hackage.haskell.org/package/math-functions-0.1.5.2/docs/Numeric-SpecFunctions.html is very fast, but it returns "NaN" a lot with big numbers
09:49:45 <merijn> hseg: What would be unsafe about them?
09:50:01 <brbblnch> merijn: Do you know where I could find an answer to my question?
09:50:03 <merijn> infandum: You sound like a candidate for #numerical-haskell :)
09:50:14 <infandum> merijn: That exists!?
09:50:15 <merijn> brbblnch: Here, but at a time the math people are awake ;)
09:50:26 <merijn> infandum: Yes, I think they have a mailing list too
09:50:40 <SlowBait> How can I tag the Array Int Int type with it's size?
09:51:01 <merijn> SlowBait: It's already tagged with it's size
09:51:11 <merijn> SlowBait: Or did you mean at the type level?
09:51:17 <brbblnch> merijn: Ok, I'll spam the chan then! thanks
09:51:50 <SlowBait> merijn: yes, at the type level, so that I can declare an instance of monoid of Array Int Int for each size
09:52:00 <infandum> merijn: Cool, thanks for the heads up!
09:53:55 <merijn> SlowBait: That'll be painful to do, probably you need a newtype + DataKinds around array and reflect that value back in your monoid instance
09:54:12 <Zemyla> infandum: http://blog.plover.com/math/choose-2.html
09:54:32 <hseg> merijn: Given that instances can be added post facto, how do you consume a value of type F a for a family F?
09:54:34 <mbuf> how do I represent "\l" as a string in Haskell? it tells me it is a  lexical error in string/character literal at character 'l'
09:54:43 <mauke> "\\l"
09:55:47 <Welkin> a literal '\' must be escaped
09:55:53 <Welkin> "\\"
09:56:32 <SlowBait_> Sorry, lost my connection, yes, at the type level
09:57:36 <Zemyla> @let choose n k = case () of { _ | n <= 0 -> 1; _ | k <= 0 -> 0; _ | k > n - k -> choose n (n - k); _ -> choose (n-1) (k-1) * n `div` k }
09:57:37 <lambdabot>  .L.hs:194:26:
09:57:38 <lambdabot>      Ambiguous occurrence ‘choose’
09:57:38 <lambdabot>      It could refer to either ‘L.choose’, defined at .L.hs:190:1
09:58:06 <Zemyla> @let binomial n k = case () of { _ | n <= 0 -> 1; _ | k <= 0 -> 0; _ | k > n - k -> binomial n (n - k); _ -> binomial (n-1) (k-1) * n `div` k }
09:58:09 <lambdabot>  Defined.
09:58:18 <Zemyla> > binomial 5n3
09:58:20 <lambdabot>  Not in scope: ‘n3’
09:58:20 <lambdabot>  Perhaps you meant one of these:
09:58:20 <lambdabot>    ‘n’ (imported from Debug.SimpleReflect),
09:58:22 <Zemyla> > binomial 5 3
09:58:23 <lambdabot>  0
09:58:36 <merijn> hseg: That doesn't have anything to do with associated typeclasses and/or safety though, that's a matter of "how do I know what type "F a" is?" and that depends on what sort of code you're writing
09:58:52 <merijn> hseg: Usually you'd use GADTs which give you some handle on what's going on
09:58:54 <Zemyla> Hmm. I had a bug in there. :V
09:58:57 <SlowBait_> merijn: Sorry, lost my connection, yes, at the type level
09:59:07 <clrnd> is there like a competition for long GHC error messages?
09:59:14 <mbuf> Welkin, when it is used as a command \l to list databases to postgresql-simple, it returns an error that syntax error at or near \"\\\""
09:59:18 <merijn> hseg: Although, tbh I have much more usecases for closed type families
09:59:32 <hseg> merijn: Ah. Sorry for the overexcited phrasing then.
09:59:58 <hseg> merijn: How would GADTs help? By closing over equalities?
10:03:57 <ralu> is there online doc available for packages on hackage?
10:04:14 <bergmark> ralu: yes, on hackage
10:04:34 <ralu> i cant find example
10:04:45 <bergmark> http://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson.html
10:04:54 <ralu> thanx
10:05:03 <geekosaur> the list of modules has clickable links to module API docs
10:05:40 <geekosaur> some packages won't have API docs because they don't build (usually need C lib dependencies or Windows platform specific) and docs weren't uploaded by maintainer
10:05:56 <merijn> hseg: I use an open type family with GADTs here for statically checked variadic function application: https://github.com/merijn/SNet2.0/blob/master/SNet/Task.hs#L73-L79
10:06:45 <merijn> hseg: Pattern is basically a heterogeneous list with GADT encoding, so the type family computes a function type that consumes every value in the HList
10:07:03 <merijn> hseg: Now, how you obtain a function of the right type, is of course up to you
10:08:37 <hseg> merijn: A) That type family is effectively closed, as you have enumerated all the types of that kind. B) How *do* you obtain a function of the right type?
10:09:02 <jtanguy> mbuf: what are you trying to do ?
10:12:12 <lpaste> mbuf pasted “Show databases” at http://lpaste.net/121508
10:12:21 <mbuf> jtanguy, ^
10:13:08 <merijn> hseg: It type checks as long as the function and pattern you pass to apply match
10:13:58 <merijn> hseg: The type family merely computes a type, it doesn't care how you get a value of the right type. As long as it can verify what you're doing is valid at every step it's fine
10:14:30 <hseg> merijn: Ah. OK. Why don't you use a closed family there?
10:14:59 <jtanguy> \l type commands are useful for tools like psql
10:15:18 <jtanguy> you might want to use system tables, like in your example
10:15:28 <merijn> hseg: They didn't exist when I wrote it
10:15:47 <merijn> You're right that this one would be nicer closed
10:16:16 <hseg> merijn: OK. Know of any use of open type families which can't easily be ported to closed families?
10:17:03 <merijn> hseg: I think those mostly end up in cases similar to associated types
10:17:26 <hseg> merijn: Then why do we still have open families?
10:17:36 <jtanguy> mbuf: depending on what you want to do, you could take a look at https://github.com/begriffs/postgrest
10:18:10 <merijn> hseg: Because you can't port the associated types uses to closed families?
10:19:13 <hseg> merijn: OK. Rephrasing my question - why do we still have open families in non-associated type contexts?
10:19:16 <mbuf> jtanguy, thanks!
10:20:02 <merijn> hseg: Because that's how they're implemented in the underlying representation
10:20:18 <merijn> hseg: "associated types" are really just syntactic sugar for typeclass + open type family
10:20:36 <hseg> merijn: Ah.
10:22:05 <hseg> merijn: OK. Another probably horrible idea I had was to allow lexically scoped typeclass instances. But I hear this breaks all sorts of stuff and makes unicorns cry?
10:22:31 <merijn> Yes
10:22:51 <merijn> Because you lose the single instances property
10:23:12 <merijn> Which is so nice edwardk spent an 1.5 hours explaining why it's great and Scala's approach sucks on video :p
10:23:19 <hseg> Link?
10:24:23 <Iceland_jack> link: https://www.youtube.com/watch?v=hIZxTQP1ifo
10:24:43 * hackagebot satchmo 2.9.2 - SAT encoding monad  http://hackage.haskell.org/package/satchmo-2.9.2 (JohannesWaldmann)
10:31:06 <funfunctor> any idea what the go is here? Could not find module `Data.Coerce'
10:32:20 <merijn> funfunctor: Which version of GHC?
10:32:42 <funfunctor> merijn: The Glorious Glasgow Haskell Compilation System, version 7.6.3
10:33:06 <msl09> I'm trying to compile the follwing function: http://pastebin.com/AXmTzzDH
10:33:08 <merijn> It's new in 7.8 :)
10:33:09 <merijn> afaik
10:33:10 <funfunctor> don't tell me.. need 7.8
10:33:27 <funfunctor> god dam distros having old packages
10:33:35 <funfunctor> old /= stable ffs
10:33:43 <merijn> funfunctor: Why not just install GHCs binary package?
10:33:49 <msl09> but ghc tells me that a is a rigid bound variable
10:34:20 <funfunctor> merijn: how do you mean?
10:34:20 <msl09> sorry, rigid variable
10:34:33 <ralu> old == not broken
10:34:36 <glguy> msl09: You should include the error message when you paste code for help
10:34:42 <msl09> ok
10:35:10 <glguy> msl09: newColorID ultimately returns a Curses ColorID
10:35:27 <merijn> funfunctor: The GHC site has binary distributions packaged of the latest version
10:35:31 <glguy> msl09: So     getColor :: Color -> Curses ColorID
10:35:54 <Zemyla> cmccann, question for you, if you're here.
10:36:06 <glguy> msl09: When you write "getColor :: Color -> Curses a" you're saying that getColor should be able to return any type its caller might want
10:36:50 <msl09> shit
10:38:47 <msl09> ohhhhh
10:38:51 <msl09> thanks
10:39:00 <funfunctor> shitty fedora
10:39:14 * funfunctor misses arch and nixos installs
10:42:06 <jndlfg> Ho many mathematical monographs must be studied in order to learn  Haskell? Are the mastery of physics, linguistics, and philosophy also required?
10:42:30 <opqdonut> none and no :)
10:42:48 <xnull> ^
10:43:02 <opqdonut> you can start with one of the tutorials, like http://learnyouahaskell.com/chapters
10:43:28 <xnull> jndlfg: some basic math like function application and composition
10:43:31 <xnull> that's about it
10:44:05 <jndlfg> hmm
10:44:07 <mmachenry> Could anyone tell me why this simple program is crashing with the error I pasted? http://lpaste.net/121512
10:44:11 <opqdonut> xnull: both are concepts understandable with a progrmaming background
10:44:16 <xnull> opqdonut: yep
10:45:03 <xnull> mmachenry: did you build cabal from source
10:45:04 <jndlfg> I was pointed to this book: http://www.amazon.ca/Homological-Algebra-Semimodules-Semicontramodules-Semi-infinite/dp/3034604351#reader_3034604351 and to be honest I currently only know 2 of the six words in the title - namely 'of' and 'and'..
10:45:46 <xnull> oh wait nvm
10:45:54 <mmachenry> Xnull No I didn't.
10:46:08 <xnull> sorry i was misguided there for a second
10:46:16 <mmachenry> But I do get an annoying persistent "you need to run configure" even though I have run "cabal configure" many times
10:49:44 <jndlfg> what are the best supported databases for haskell?
10:50:48 <mmachenry> jndlfg: I liked the Postgres support *way* better than the Oracle support I have now.
10:51:33 <jndlfg> mmachenry: what about nosql databases?
10:52:08 <mmachenry> jndlfg: I don't know, really.
10:52:11 <pavonia> Like acid-state?
10:52:23 <lseppala> jndlfg: there's a couple Cassandra libraries (using Thrift)
10:52:47 <merijn> pavonia: acid-state is not competing with nosql databases
10:52:59 <merijn> acid-state is "persistent heap objects"
10:53:32 <jndlfg> I only have experience with mongodb and redis nosql currently, are those well supported?
10:53:46 <jndlfg> I've also heard of riak and rethinkdb
10:54:32 <lseppala> jndlfg: redis is great (hedis library), though I wouldn't call it a database...
10:55:06 <jndlfg> why not lseppala ?
10:55:07 <lseppala> haven't used mongodb, but it's fairly easy to support since everything is serialized to JSON. Several supporting haskell libraries
10:55:16 <Yuras> jndlfg: I have medium size app where I use mongo and redis. I find haskell clients almost OK
10:55:36 <hexagoxel> mmachenry: have you tried a `cabal clean` at some point?
10:55:48 <mmachenry> hexagoxel: No I can do that
10:55:55 <hexagoxel> mmachenry: try `cabal exec -- runhaskell utils/testHaddock.hs`
10:56:18 <mmachenry> hexagoxel: Same error
10:56:18 <Yuras> jndlfg: though bson package needs more love IMO
10:56:20 <lseppala> jndlfg: It's more accurate to call it a key-value store, thought I guess if you say a database is a "database is an organized collection of data" like wikipedia does, sure, it counts
10:56:26 <geekosaur> ob https://twitter.com/edd/status/400190499585544192/photo/1 (nosql)
10:57:15 <jndlfg> geekosaur: are people against nosql now?
10:57:49 <geekosaur> people who care about being able to bring the site back, care about it actually scaling rationally, care about reliability, yes
10:57:51 <mmachenry> hexagoxel: cabal clean didn't change anything, including not getting rid of the reconfigure issue
10:57:58 <geekosaur> "nosql" promised a lot of things it never delivered
10:57:59 <brbblnch> In simply typed lambda-calculus, is the ordered pair (x,y) = λc.xy typable? because if x and y don't have the same type it's problematic, no?
10:58:03 <merijn> Have people ever been in favour of nosql?
10:58:25 <geekosaur> and by the time you make something like mongodb reliable, it's slower than postgresql
10:58:32 <unknownloner> here we go again
10:58:36 <jndlfg> oh
10:58:41 <unknownloner> the great tired nosql vs sql debate
10:59:29 <jndlfg> so postgresql is overall the best db to use with haskell?
10:59:34 <jndlfg> best sql db?
11:00:04 <unknownloner> "best" depends on use case
11:00:05 <lseppala> probably has the best support, sure. Though we have to use SQL Server at work, and it's fine
11:00:33 <jndlfg> you can use haskell but you have to use sql server?
11:00:43 <lseppala> yup
11:00:53 <jndlfg> lol that seems strange
11:00:55 <sh1ken> that's weird lol
11:01:33 <lseppala> Data warehouse. Not something we control, shared across the company
11:01:56 <ProofTechnique> For most interesting stuff I've seen (data modeling and whatnot), Postgres seems to have the best support and tooling, and sane types. I think SQL Server has a lot of the same stuff (except for windowing, maybe?) but has the misfortune of costing money. :D
11:02:44 <lseppala> and misfortune of having to use fragile C libraries (freetds)...
11:03:57 <Zemyla> Aaargh, fuck. These is *almost but not quite* a MonadPlus.
11:04:14 <ProofTechnique> And then there's MySQL, which seems to have been actively designed to fail like a submarine: fast, silent, and with a risk of nuclear fallout
11:05:04 <sh1ken> I would quote on that, ProofTechnique.
11:05:25 <sh1ken> quote you*
11:05:32 <ProofTechnique> Please do. Hahaha.
11:06:02 <hexagoxel> mmachenry: what happens when you you make _your program_ run `cabal configure`?
11:07:29 <hexagoxel> mmachenry: and does the same thing happen when you run `cabal haddock` by hand?
11:07:45 <mmachenry> hexagoxel: Just says you configured… Good job
11:08:01 <mmachenry> When I run cabal haddock it says it made a whole much files
11:08:31 <hexagoxel> mmachenry: so the program executes a different cabal or something?
11:08:54 <hexagoxel> have you recently upgraded cabal?
11:10:22 <Yuras> mmachenry: https://github.com/haskell/cabal/issues/2438
11:29:47 * hackagebot diversity 0.4.0.1 - Return the diversity at each position for all sequences in a fasta file  http://hackage.haskell.org/package/diversity-0.4.0.1 (GregorySchwartz)
11:30:56 <funfunctor> folks around at this time?
11:31:39 <bitemyapp> nop
11:31:40 <cite-reader> There's lurking going on.
11:32:18 <funfunctor> hehe, I'm pretty confused with my C binding on the data paths
11:32:29 <mniip> why is cycle [] an error
11:32:37 <bitemyapp> mniip: what would it cycle?
11:33:00 <mniip> by all logic should be some form of ⊥
11:33:03 <cite-reader> An infinite list of bottoms, maybe, but that doesn't seem very useful.
11:33:06 <mniip> like 'repeat ⊥'
11:33:07 <funfunctor> the C API expects arbitrary structured (and hence sized) buffers to be passed as a pointer
11:33:39 <funfunctor> I know ByteString is probably best to have as the flow path but I am not 100% sure
11:33:39 <exio4> mniip: cycle [] being "undefined" means it is bottom
11:33:50 <mniip> I'd rather it be 'repeat undefined'
11:34:06 <mniip> because then cycle always returns a :
11:34:46 <funfunctor> is bytestring a member of some kind of class of type?
11:35:40 <mniip> funfunctor, IsString?
11:36:09 <funfunctor> I'm thinking something like bladeRfWrite :: IDK a => DeviceHandle -> a -> .. -> IO ()
11:36:38 <funfunctor> and take a pointer by using malloc :: IO a
11:37:06 <funfunctor> really not sure at all..
11:38:05 <ReinH> mniip: Why would cycle [] and cycle [⊥] give the same result?
11:39:43 <hexagoxel> ReinH: because of cycle [⊥,⊥,⊥], cycle [⊥,⊥], cycle [⊥]     .. (yes, i am aware this is a bad joke)
11:39:47 * hackagebot retry 0.6 - Retry combinators for monadic actions that may fail  http://hackage.haskell.org/package/retry-0.6 (OzgunAtaman)
11:40:57 <ReinH> hexagoxel: So because cycle [1,1,1] = cycle [1,1] = cycle [1], you expect cycle [] = [1,1,1...]? ;)
11:41:10 <hexagoxel> exactly!
11:41:12 <funfunctor> what would be the equiv way to handle the binding of void write(void *samples, int num_samples); in Haskell?
11:41:42 <funfunctor> just looking for good type-signatures here and how to deal with the memory allocation
11:42:13 <funfunctor> note here we know nothing about the structure of the samples buffer type
11:43:38 <opqdonut> funfunctor: you wouldn't have a function like that in haskell, normally
11:43:51 <opqdonut> funfunctor: however some options are "write :: CPtr -> Int -> IO ()"
11:44:32 <opqdonut> or perhaps Ptr a instead of CPtr actually
11:44:41 <opqdonut> c.f. "hPutBuf :: Handle -> Ptr a -> Int -> IO ()" from System.IO
11:44:50 <funfunctor> opqdonut: yuck no, I am looking how to make this a high level API
11:45:00 <funfunctor> and hide away all this pointer stuff in the binding
11:45:07 <opqdonut> right
11:45:22 <opqdonut> so I'd just take a list [Sample]
11:45:25 <funfunctor> maybe conduit or something
11:45:36 <opqdonut> it all depends on everything
11:45:51 <opqdonut> perhaps a ByteString
11:45:54 <opqdonut> perhaps Text
11:46:17 <mniip> ok maybe you're correct
11:46:22 <funfunctor> the data could be anything is pure binary
11:46:33 <funfunctor> so bytestring is what naturally comes to mind
11:46:33 <mniip> I can't figure out an implementation where [] isn't a special case
11:46:34 <opqdonut> ByteString is the usual representation for binary buffers
11:46:38 <opqdonut> yeah
11:47:37 <funfunctor> opqdonut: but the C api expects for a buffer to be pre-allocated so how do I get from a bytestring passed into a action to a pointer to it of type void *
11:47:47 <funfunctor> with the right amount of memory allocated
11:48:20 <funfunctor> malloc IO ByteString does not really make sense to me..
11:48:41 <opqdonut> the simplest answer is to allocate a separate buffer and copy to/from the ByteString
11:48:41 <funfunctor> because the bytestring could be any length
11:49:10 <funfunctor> yea but then, given a bytestring how do we know what buffer size to allocate?
11:49:28 <opqdonut> length :: ByteString -> Int
11:49:32 <opqdonut> how about that?
11:49:39 <funfunctor> suppose I have write :: ByteString -> IO ()
11:50:05 <mniip> @let recycle z = let (x:xs) = z ++ recycle z in x:xs
11:50:07 <lambdabot>  Defined.
11:50:07 <funfunctor> ok so, p <- (mallocBytes . length) bs
11:50:10 <mniip> ReinH
11:50:11 <funfunctor> or something?
11:50:26 <opqdonut> funfunctor: see also the CString functions in https://hackage.haskell.org/package/bytestring-0.9.2.1/docs/Data-ByteString.html btw
11:50:34 <exio4> > recycle []
11:50:39 <lambdabot>  mueval-core: Time limit exceeded
11:50:57 <funfunctor> opqdonut: ok but this is not your typical textual buffer you would normally see
11:50:57 <exio4> bottom again, fix ([] ++)
11:51:07 <funfunctor> the buffer could be structs inside structs
11:51:55 <opqdonut> funfunctor: CStringLen is (Ptr CChar, Int), i.e. a c-type buffer, i.e. what your write function wants
11:52:25 <opqdonut> funfunctor: useAsCStringLen is probably exactly what you're implementing
11:52:28 <funfunctor> opqdonut: except it does not want that
11:52:34 <funfunctor> no its not
11:52:38 <funfunctor> this is what I am saying
11:52:40 <opqdonut> a pointer and a length?
11:52:45 <opqdonut> that's what your write takes
11:52:50 <funfunctor> no length, just pointer
11:52:58 <mniip> exio4, no
11:53:10 <mniip> it actually is repeat undefined
11:53:11 <funfunctor> opqdonut: I never said length, see my type signatures
11:53:30 <exio4> > repeat [error ".."]
11:53:32 <lambdabot>  [[*Exception: ..
11:53:32 <opqdonut> well effectively you are passing in a length
11:53:37 <exio4> > repeat (error "..")
11:53:38 <lambdabot>  [*Exception: ..
11:53:43 <funfunctor> opqdonut: the C API assumes you have correctly allocated the memory before calling it, it just wants a pointer to it
11:53:44 <opqdonut> otherwise you would access past the end of the buffer
11:53:45 <exio4> it is not mniip
11:53:45 <cite-reader> That's true, it's a pointer and then _number of samples_, which sounds like a memory corruption error waiting to happen.
11:53:54 <exio4> mniip: bottoms are all equal, anyway
11:53:55 <opqdonut> funfunctor: but anyways, you can always ignore the second component of the CStringLen :)
11:53:59 <mniip> what
11:54:00 <mniip> no
11:54:41 <mniip> > case recycle [] of _:_ -> "yay"
11:54:43 <lambdabot>  "yay"
11:54:51 <mniip> see it has : in the root
11:54:52 <opqdonut> funfunctor: so does write(buf,n) write to buf? then you don't pass in a ByteString, you pass one out
11:54:58 <opqdonut> funfunctor: since ByteStrings are immutable
11:55:06 <funfunctor> opqdonut: write does *not* take a n
11:55:09 <funfunctor> I keep saying this
11:55:17 <opqdonut> ok let me rephrase
11:55:28 <opqdonut> funfunctor: so does write(buf,...) write to buf? then you don't pass in a ByteString, you pass one out
11:55:31 <opqdonut> :)
11:55:46 <mniip> > "hello" ++ (fix id)
11:55:50 <lambdabot>  mueval-core: Time limit exceeded
11:56:02 <mniip> exio4, see, it just prints that, which is why [ wasn't printed
11:56:04 <funfunctor> write wants a *pre*-allocated buffer's pointer opqdonut
11:56:17 <opqdonut> funfunctor: yes, I know
11:56:25 <funfunctor> we know *nothing* else, not its structure, not its length, nothing
11:56:33 <mniip> recycle [] -> repeat (fix id)
11:56:52 <opqdonut> funfunctor: so how does the user know how to allocate it? or is it allocated by some other function in the library?
11:56:59 <NemesisD> has anyone experienced ghci holding file descriptors open? i've tried runing performGC but that doesn't seem to help
11:57:04 <funfunctor> we would like to obtain a higher level API than, give me a memory address
11:57:07 <mniip> wait what
11:57:13 <mniip> oh snap
11:57:18 <funfunctor> opqdonut: the user knows because the buffer is *completely* user defined
11:57:22 <opqdonut> funfunctor: also, is the buffer read, written or both? that affects the API
11:57:33 <funfunctor> opqdonut: read and written
11:57:33 <mniip> it actually is only ⊥:⊥
11:57:40 <exio4> mniip: are you sure? it doesn't seem to be equal past the first cons
11:58:18 <exio4> (the tail of repeat bottom is repeat bottom, while cycle's tail is just bottom)
11:58:30 <opqdonut> funfunctor: so what goes in the buffer how does it get filled? does the user write arbitrary binary data to it or is it just passed around functions in the library?
11:58:31 <mniip> which is what I just said
11:58:50 <mniip> @undefine
11:58:50 <lambdabot> Undefined.
11:58:52 <opqdonut> funfunctor: I can give better suggestions than ByteString or Ptr if I have some context
11:59:26 <funfunctor> opqdonut: the user defines struct, string, whatever and malloc's memory, then passes a pointer to the library.
11:59:54 <funfunctor> its a pretty weird API
12:00:09 <opqdonut> what does the library do with the pointer?
12:00:31 <opqdonut> does this library have docs online somewhere?
12:00:36 <funfunctor> writes to hw (actually transmits it on a radio)
12:00:42 <mniip> @let recycle z = let reconsider ~(x:xs) = x:reconsider xs in reconsider (cycle z)
12:00:44 <lambdabot>  Defined.
12:00:49 <mniip> take that
12:00:52 * funfunctor opqdonut i'm looking now..
12:01:15 <opqdonut> funfunctor: so then I think "ByteString -> IO ()" is the right thing, it's just like writing data to a file
12:01:21 <funfunctor> opqdonut: this is out the header http://lpaste.net/121500
12:01:24 <mniip> generally reconsider is a very useful function
12:01:30 <mniip> turns a bottom into a list of bottoms
12:01:36 <funfunctor> opqdonut: in theory yes
12:02:43 <opqdonut> funfunctor: you can alwas wrap the ByteString function with additional layers, but I'd start with the ByteString
12:03:28 <opqdonut> (and num_samples definitely looks like a length argument to me, it might not be the length in bytes, but it tells the function how much to read from behind the pointer)
12:03:50 <funfunctor> opqdonut: ofcourse, the issue is given :: ByteString -> IO () how do we know what size memory to malloc before we call the C FFI ?
12:04:13 <funfunctor> just p <- (malloc . length) bs ?
12:04:19 <opqdonut> if you want to fit all the data in the bytestring, the length of the bytestring
12:04:25 <funfunctor> sorry, mallocBytes even
12:04:26 <opqdonut> then just copy the data from the bytestring into the buffer
12:05:02 <opqdonut> (both of which useAsCStringLen does for you)
12:06:39 <funfunctor> foo :: ByteString -> IO ()
12:06:39 <funfunctor> foo bs = do    p <- (malloc . length) bs; poke p bs; c_func p;
12:06:45 <funfunctor> something like that opqdonut?
12:06:57 <funfunctor> god damm, mallocBytes I mean
12:07:32 <opqdonut> funfunctor: yeah, something like that
12:07:59 <funfunctor> opqdonut: alright thx, so what am I know understanding about the CString stuff?
12:08:20 <opqdonut> (except poke is not the right function)
12:09:12 <opqdonut> (no wait it is)
12:09:30 <funfunctor> opqdonut: its storage class so yes it is
12:09:33 <opqdonut> yeah
12:09:53 <funfunctor> opqdonut: CString's are null terminated so would screw things up
12:10:10 <opqdonut> the equivalent using useAsCStringLen would be: foo bs = useAsCStringLen bs (\(ptr, _len) -> c_func ptr)
12:10:16 <opqdonut> funfunctor: CStringLen isn't
12:10:23 <opqdonut> see https://hackage.haskell.org/package/base-4.5.0.0/docs/Foreign-C-String.html#t:CStringLen
12:10:49 <opqdonut> but your solution is pretty simple too
12:11:20 <funfunctor> opqdonut: ok so can you give me a example of useAsCStringLen's usage?
12:11:56 <mniip> > iterate ((0:) . join (zipWith3 (((+) .) . (*)) [1..] . tail . cycle)) [0, 1]
12:11:58 <Zemyla> Hmm. Why is Stream m a not a monad? I mean, seriously>
12:11:58 <lambdabot>  [[0,1],[0,1,1],[0,1,3,1],[0,1,7,6,1],[0,1,15,25,10,1],[0,1,31,90,65,15,1],[0...
12:12:03 <opqdonut> I did above, foo bs = useAsCStringLen bs (\(ptr, _len) -> c_func ptr)
12:12:03 <mniip> woo stirling numbers of second kind
12:12:08 <opqdonut> funfunctor: ^
12:12:48 <funfunctor> opqdonut: it also takes O(n), isn't my solution cheaper
12:12:57 <funfunctor> ah sorry I missed that
12:13:49 <funfunctor> oh that O(n) comes from length, never mind
12:14:13 <isomorphismes> Is there a way to alias functions in Haskell? like let `in`=`elem`
12:14:18 <opqdonut> yep, it comes from copying the data
12:14:25 <opqdonut> anyway, I'm off to bed now, good luck ->
12:14:46 <funfunctor> opqdonut: thx again
12:23:57 <ttt_fff> using ghc.generics, how do I get the name of a data constructor?
12:26:08 <funfunctor> how does one "usually" serialise some given data structure into a bytestring? Binary instance?
12:27:08 <ttt_fff> ghc.generics
12:27:11 <ttt_fff> does it auto magicaly for yo
12:29:04 <funfunctor> thx
12:40:21 <megamac> @help
12:40:21 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:40:35 <megamac> @help list
12:40:36 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
12:41:03 <megamac> :t map
12:41:04 <lambdabot> (a -> b) -> [a] -> [b]
12:41:29 <megamac> >22+23
12:41:40 <f|`-`|f> you need the space
12:41:43 <f|`-`|f> > "the"
12:41:44 <lambdabot>  "the"
12:42:21 <megamac> > 1+1
12:42:23 <lambdabot>  2
12:42:30 <megamac> thanks
12:42:38 <JoshieAS> what API does the lambdabot use to evaluate haskell expressions?
12:43:09 <tdammers> mueval
12:43:12 <ReinH> Zemyla: What is Stream?
12:43:16 <tdammers> http://hackage.haskell.org/package/mueval
12:43:26 <tdammers> also:
12:43:28 <tdammers> http://hackage.haskell.org/package/lambdabot
12:44:05 <JoshieAS> tdammers: many thankees
12:44:23 <tdammers> np
12:45:02 <Zemyla> From Data.Vector.
12:51:22 <ReinH> Zemyla: how would you make it one?
12:51:42 <JagaJaga> What's the best way to numerate lines from Writer monad with the [String] log?
12:51:57 <ReinH> JagaJaga: zip [1..], perhaps
12:52:10 <JagaJaga> ReinH: shame on me :D
12:52:27 <ReinH> No need :)
12:54:51 * hackagebot system-canonicalpath 0.3.2.0 - Abstract data type for canonical paths with some utilities  http://hackage.haskell.org/package/system-canonicalpath-0.3.2.0 (d12frosted)
12:56:04 <Zemyla> ReinH: return = singleton, (>>=) = flip concatMap, and since streams are semantically lists, the monad laws are satisfied.
12:56:39 <ReinH> You waved your hands a bit there at the end
12:57:51 <ReinH> I suspect that the issue may have something to do with the Size hint
12:57:53 <JagaJaga> ReinH: but if I have Writer String a, is there a way to numerate lines via `tell`? Or I need State monad?
12:58:36 <ReinH> JagaJaga: Isn't it sufficient to recover a numbering later using zip?
12:58:56 <kadoban> JagaJaga: What do you mean exactly? You could use a different log type that implicitly has a numbering, but yeah…I'm not sure why you would.
12:59:20 <ReinH> You can at any time you use the [String] add a numbering with zip [1..]
12:59:36 <ReinH> This numbering will be consistent since writer appends
12:59:57 <ReinH> So I'm not sure why you would need to do something different
13:00:14 <JagaJaga> well, let me ask another way. I need to write logs, but in that logs I need to write some information based on previous lines of log. The only solution to do it is State, isn't it?
13:00:14 <gyaretto> > [1, 2] >>= \n -> ['a', 'b'] >>= \ch -> return (n, ch)
13:00:16 <lambdabot>  [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
13:00:19 <hannes___> or data Log = Log { numbering :: Sum Int, messages :: [String] }, though that doesn't seem to be any easier than what ReinH says
13:00:23 <gyaretto> ^ why does that work?
13:00:55 <hannes___> gyaretto: specifically, what part of it do you find confusing?
13:00:56 <JagaJaga> gyaretto: monads >_>. List monad
13:01:20 <gyaretto> >[1, 2] >>= \n -> ['a', 'b']
13:01:25 <gyaretto> Oops.
13:01:31 <gyaretto> > [1, 2] >>= \n -> ['a', 'b']
13:01:32 <lambdabot>  "abab"
13:01:43 <gyaretto> ^ That's all that's being passed to the second >>=
13:01:54 <ReinH> gyaretto: no, n is still in scope
13:01:54 <mauke> no
13:02:00 <hannes___> gyaretto: the second still has the n
13:02:15 <mauke> gyaretto: lambdas extend as far to the right as possible
13:02:17 <gyaretto> Oh, it's because n is still in scope?
13:02:17 <Zemyla> ReinH: return a gives a stream of [Yield a, Done]. return a >>= f gives a stream of [Skip, (f a) without Done, Skip, Done].
13:02:19 <sinelaw> > [1,2] >>= \n -> n
13:02:21 <lambdabot>  No instance for (GHC.Show.Show b0)
13:02:21 <lambdabot>    arising from a use of ‘M70367774629607742818973.show_M70367774629607742818...
13:02:21 <lambdabot>  The type variable ‘b0’ is ambiguous
13:02:29 <ReinH> Zemyla: you need to show that sizes are preserved, I think.
13:02:44 <mauke> > [1, 2] >>= (\n -> ['a', 'b'] >>= (\ch -> return (n, ch)))
13:02:46 <lambdabot>  [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
13:02:53 <sinelaw> oops, I meant
13:02:53 <sinelaw> > [1,2] >>= \n -> return n
13:02:55 <lambdabot>  [1,2]
13:03:00 <ReinH> Zemyla: lists don't have a concept of "size", so there is not a direct denotational equivalence
13:03:17 <ReinH> so you can't just hand wave and say "Streams are lists so the monad laws are obviously satisfied"
13:03:35 <ReinH> You need to prove it
13:03:41 <gyaretto> Thanks.
13:04:04 <Zemyla> Well, concatMap f s has a size of Unknown.
13:04:14 <ReinH> gyaretto: Consider the do notation version: do { n <- [1,2]; c <- "ab"; return (n,c) }
13:04:55 <Zemyla> That's because it can't evaluate anything in the stream until it actually gets there.
13:04:56 <ReinH> Which says "take n from [1,2] and c from ['a', 'b'] and return all pairs of n and c"
13:05:06 <gyaretto> ReinH: Oh! That makes more sense. Thanks!
13:06:25 <ReinH> gyaretto: Now consider the list comprehension version, which says the same thing:
13:06:27 <ReinH> > [(n,c) | n <- [1,2], c <- "ab"]
13:06:28 <lambdabot>  [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
13:07:32 <hannes___> > let x :: Int; x = 3 + _otherInt in x
13:07:33 <lambdabot>  Found hole ‘_otherInt’ with type: GHC.Types.Int
13:07:33 <lambdabot>  Relevant bindings include
13:07:33 <lambdabot>    x :: GHC.Types.Int (bound at <interactive>:1:15)
13:08:06 <Zemyla> The question is, does removal of size hints actually change the semantics of a stream, or is it just a hint for optimization?
13:08:55 <ReinH> Zemyla: What it does is change the value.
13:09:04 <ReinH> monad laws are not up to "semantics"
13:09:16 <ReinH> Unless you can define that precisely and convince people to use it
13:09:43 <ReinH> The diagrams monoid is one example of that, where a reasonable notion of extensional equality is given for trees that may be of different shapes.
13:10:54 <hannes___> ReinH: The question would be if the difference is actually observable somehow, I think. If there is no observable difference, the objects are equivalent anyway
13:11:09 <RyanGlScott> I have a Cabal question: when you run cabal build, it puts compiled object files in a directory like "dist/build/<module-name>".
13:11:18 <RyanGlScott> Is there a Cabal function for retrieving that directory?
13:12:15 <RyanGlScott> As I don't think Paths_<package-name> gives you that information.
13:12:52 <ReinH> hannes___: Well, Stream exports its constructor, so a difference is observable.
13:13:01 <hannes___> ReinH: fair enough
13:13:16 <hannes___> I thought you were talking about something else
13:21:05 <Zemyla> ReinH: We define stream equality by saying two streams are equal if forall c n. (foldr c n s1) == (foldr c n s2).
13:21:43 <ReinH> Zemyla: That seems reasonable. Of course this is a non-standard way to satisfy the monad laws, but there is precedent.
13:22:02 <Zemyla> And since foldr c n s = foldr c n (foldr (:) [] s), we only need to prove they produce equal lists.
13:22:14 <ReinH> Yep. You need to show a list homomorphism.
13:22:18 <ReinH> It seems reasonable.
13:22:50 <ReinH> It isn't the standard way to interpret "satisfies the laws", but it's been done before, like the diagrams monoid I mentioned.
13:23:11 <ReinH> Zemyla: have you seen the diagrams monoid functional pearl?
13:24:01 <mmachenry> I think I've gotten cabal into a very confused state. I'm trying to upgrade cabal. It's complaining about a lack of profiling libraries.
13:25:42 <mmachenry> Is it reasonable to remove my ~/.cabal and start over? Will there be anything else I need to clean?
13:25:53 <Zemyla> So foldr c n (Stream f s) = case (f s) of { Yield x s' -> c x (foldr c n (Stream f s')); Skip s' -> foldr c n (Stream f s'); Done -> n }
13:26:32 <mniip> reading about hnn, what's with the tanh stuff
13:27:08 <Zemyla> So this means that Skip values in a stream can be disregarded when it comes to the stream's value.
13:27:47 <geekosaur> mmachenry, ~/.cabal loses your cabal config but keeps registered packages. perhaps you wanted to remove ~/.ghc instead
13:28:09 <mmachenry> geekosaur: Thanks. Perhaps both?
13:28:20 <Zemyla> Now, the first monad law: (return a) >>= f = f a.
13:28:35 <geekosaur> straight up removing ~/.cabal/config is not necessarily a good idea
13:28:36 <mmachenry> geekosaur: And then I might need to remove my sandbox in my project as well.
13:30:27 <Zemyla> return a produces the stream [Yield a, Done]. concatMap receives the a and produces a Skip as it switches streams. The Skip is discarded by the stream consumer.
13:31:12 <Zemyla> It then produces every item in (f a) except the Done. It instead produces another Skip.
13:32:02 <Zemyla> And then, when it receives the Done from (return a), it produces a Done.
13:32:54 <Zemyla> The two skips are ignored, so foldr (:) [] ((return a) >>= f) = foldr (:) [] (f a). Monad law 1 satisfied.
13:36:56 <Zemyla> m >>= return produces a stream that iterates over every value in m. For each (Yield a) m produces, (return a) produces [Yield a, Done], and (m >>= return) produces [Skip, Yield a, Skip] which is isomorphic to [Yield a]. Each Skip elicits a Skip and nothing else, and Done produces Done.
13:37:36 <Zemyla> Therefore, (m >>= return) == m. Two laws down.
13:38:29 <fionnan> Anyone here have any thoughts on the IHaskell notebook?
13:39:53 * hackagebot pretty-show 1.6.8.2 - Tools for working with derived `Show` instances and generic  inspection of values.  http://hackage.haskell.org/package/pretty-show-1.6.8.2 (IavorDiatchki)
13:40:05 <cmccann> Zemyla: what were you wanting to ask me about?
13:40:57 <Zemyla> cmccann: I was about to ask why Those wasn't a MonadPlus, but then I realized that mplus mzero x /= x for any value of mzero.
13:41:06 <Zemyla> *These
13:41:20 <Zemyla> If These had a value Neither, it would be.
13:41:43 <cmccann> yeah
13:42:01 <cmccann> but not having a "Neither" value is half the reason for the package to exist
13:42:08 <cmccann> since that'd be much easier to encode with standard data types
13:43:14 <Zemyla> Actually, (Monoid m, Eq m) lets you test a "This e" value against mempty.
13:44:33 <Zemyla> mplus (This e) (That a) = if e == mempty then That a else Those e a.
13:45:07 <visar> hello
13:46:15 <visar> I'm having a little trouble installing Haskell on ubuntu, I've typed in "sudo apt-get install haskell-platform" but it's got an error message about dependencies. Do I need to install anything before getting the haskell platform?
13:46:33 <Zemyla> Anyways, ReinH, the last one is (m >>= f) >>= g == m >>= (\x -> f x >>= g).
13:47:01 <cmccann> Zemyla: there's lots of things you could do but none of them seem Obviously Right to me
13:47:11 <tdammers> visar: apt-get should sort out dependencies for you
13:47:35 <visar> tdammers: Should I copy and paste the error message?
13:47:45 <tdammers> idk, not running ubuntu myself
13:48:00 <tdammers> have you tried an update && full-upgrade?
13:49:03 <mmachenry> How in the world is this possible? Cabal seems to be defying the bash which command. http://lpaste.net/121523
13:49:09 <visar> No, how do I do that?
13:49:34 <tdammers> visar: apt-get update && apt-get upgrade
13:49:44 <S11001001> mmachenry: which != how bash looks up commands.  Try hash -r
13:49:52 <tdammers> this is probably totally not a haskell thing, just basic ubuntu/apt stuff
13:50:07 <visar> Yea, I'm sure it is
13:50:08 <mmachenry> tdammers: You're probably right.
13:50:39 <hexagoxel> mmachenry: use `type` next time
13:50:48 --- mode: ChanServ set +b *!*@wn-campus-nat-129-97-124-8.dynamic.uwaterloo.ca
13:50:48 --- kick: ParmesanCaesar was kicked by ChanServ (User is banned from this channel)
13:51:42 --- mode: ChanServ set +o glguy
13:52:00 --- mode: glguy set -bo *!*@wn-campus-nat-129-97-124-126.dynamic.uwaterloo.ca glguy
13:53:24 <visar> tdammers: It's still not working (complaining about me not being root - I did sudo). I'll leave it for another time. Thanks for your help
13:54:05 <t4nk210> sudo -sH #root
13:54:33 <Zemyla> Anyways, (m >>= f) produces, for every value of a in m, every value in (f a) in the order the as were produced. Then >>= g produces, for every b in (f a), all the values in g(b).
13:55:17 <DGh0p2> man what a mess this is LO
13:55:18 <DGh0p2> wow
13:55:30 <DGh0p2> the start of a #shitblizzard
13:55:39 <DGh0p2> someone would get alot of fame hacking this LOL
13:56:42 <mauke> DGh0p2: wrong channel
13:56:54 <DGh0p2> LOL but lurking through names in the list NOPE
13:57:15 <mauke> DGh0p2: wrong channel
13:57:23 <DGh0p2> shore
13:57:30 <dgpratt> oy
13:57:33 <bnjdlf> Monad, Arrow, Applicative seem like abstractions over composition of actions where you can customize the composition of actions per type - does that sound right?
13:57:48 <DGh0p2> theres alot of people in here
13:57:49 <DGh0p2> lol
13:57:53 --- mode: ChanServ set +o mauke
13:57:53 --- kick: DGh0p2 was kicked by mauke (wrong channel)
13:59:53 --- mode: mauke set -o mauke
14:00:13 <bnjdlf> Monads dont seem like a feature of haskell as a language (other than do notation), but rather a feature of the library - would there be any issues with implementing monads in another language?
14:00:54 <dgpratt> bnjdlf, higher kinded types and typeclasses are awfully useful in defining such things
14:01:01 <mauke> bnjdlf: lack of return type based overloading
14:01:29 <bnjdlf> mauke: does java have that?
14:01:37 <mauke> no
14:01:46 <dgpratt> the concept of Monads exists in C#/.Net but it's not really 'defined' anywhere due to limitations of the type system
14:01:48 <bnjdlf> well, actually you dont need to overload the return type i think
14:02:03 <Zemyla> m >>= (\x -> (f x) >>= g) produces each value a, and then feeds it to f. (f a) produces each value b in the same order, and once again, feeds it to g, which produces each value in (g b) in the exact same order.
14:02:30 <bnjdlf> all you have to do is make sure the second param return type is the same as bind return type
14:02:40 <bnjdlf> which can be done in C++ templates and Java
14:03:08 <Saizan> ?type return
14:03:09 <lambdabot> Monad m => a -> m a
14:03:33 <Saizan> bnjdlf: picking the right monad instance there requires dispatch on the return type
14:03:35 <mauke> :t sequence
14:03:36 <lambdabot> Monad m => [m a] -> m [a]
14:03:52 <bnjdlf> Saizan: pretty sure thats possible with c++ templates though right?
14:03:53 <Zemyla> So (m >>= f) >>= g == m >>= (\x -> (f x) >>= g). That is all the monad laws satisfied.
14:04:59 <bnjdlf> and C++11 has higher order functions
14:05:04 <dgpratt> bnjdlf, I don't know, but I kinda doubt it -- I know someone who did it with macros
14:05:46 <dgpratt> are higher-kinded types representable with C++ templates?
14:06:20 <bnjdlf> sort of...
14:06:50 <dgpratt> http://stackoverflow.com/questions/2565097/higher-kinded-types-with-c
14:06:52 <bnjdlf> by higher kinded you mean * -> * and * -> * -> * ?
14:06:58 <dgpratt> yes
14:07:04 <bnjdlf> yeah, even java has that
14:07:14 <bnjdlf> via parametric polymorphism?
14:07:18 <bnjdlf> right?
14:07:29 <dgpratt> bnjdlf, but are they directly representable? in the case of Java, I much doubt it
14:07:33 <S11001001> bnjdlf: no
14:08:03 <Saizan> bnjdlf: you don't get "type variables" of higher-kind in java, iirc
14:08:03 <KaneTW> java doesn't have that
14:08:19 <rasen> How can I implement generic imap (map with index)? I see I can use Traversable if use state monad that will store index. Is there easier way?
14:08:33 <Zemyla> On a side note, ReinH, Stream is also a MonadPlus, with mzero = empty and mplus = (++).
14:08:53 <bnjdlf> oh right Saizan
14:09:10 <bnjdlf> though,,, you do
14:09:12 <kadoban> rasen: ```zip [1..]```  first?
14:09:12 <ReinH> Zemyla: I think you mean a Monoid.
14:09:21 <Zemyla> It's both,
14:09:28 <rasen> kadoban: won't work for non-lists
14:10:27 <phaazon> god, ghc is so fast on 7.8.4
14:10:28 <bnjdlf> im gona try implementing monads with java
14:10:41 <ReinH> Zemyla: ah, yep. At least, up to this notion of semantic equivalence.
14:10:53 <phaazon> compiling my library on O2 took ~20s on 7.8.3, it’s 3s on 7.8.4
14:11:43 <dolio> There was some significant bug fixed.
14:11:49 <dolio> It might be that.
14:12:06 <dolio> Does your code have types with lots of constructors?
14:13:38 <phaazon> dolio: not that much actually
14:14:14 <funfunctor> has someone got some concrete examples of serialising some data Foo = Foo { bla :: Int, da :: Float } to a ByteString?
14:14:59 <funfunctor> maybe all this generic stuff is newer than The Glorious Glasgow Haskell Compilation System, version 7.6.3
14:53:55 <lpaste> tippenein pasted “how to simplify this sequence” at http://lpaste.net/121526
15:03:03 <zipper> ReinH: Podcast update?
15:04:19 <ReinH> zipper: Hey, none yet. I have been experiencing a critical free time failure lately.
15:05:04 <zipper> ReinH: LOL it's all good.
15:06:37 <ReinH> zipper: :)
15:23:12 <Jeyt> hi, trrying to run the threepenny-gui examples; getting     ‘jsStatic’ is not a (visible) constructor field name, on the DrumMachine example.
15:24:32 <bergmark> Jeyt: sounds like something you should report on their bug tracker
15:25:40 <Jeyt> I started to, but thought I'd ask here first. May be some simple error, like some js library dependency.  But, yeah, I can log an issue.
15:43:38 <alanoth> I installed IHaskell, but it doesn't give me any input cells. Can anyone help?
15:43:51 <alanoth> Look here for a screenshot: http://picpaste.com/Screenshot_from_2015-03-04_05_05_32-2lE40pLi.png
15:53:21 <c74d> Would I be correct to think that Parsec comes with GHC?
15:54:57 <pavonia> It comes with the Haskell Platform, IIRC
15:55:11 <pavonia> But not with GHC, no
16:05:43 <c74d> Oh, Attoparsec comes with GHC.
16:06:38 <c74d> Is Attoparsec significantly limited compared to Parsec?
16:13:26 <mjrosenb> I have a large do statement, and I'd like to know the type of an expression buried deep in its bowels, is this possible
16:13:29 <mjrosenb> ?
16:13:45 <pavonia> c74d: Where do you see attoparsec being part of the GHC bundle?
16:14:04 <mmachenry> mjrosenb: Yes. Use a type ascription.
16:14:28 <mjrosenb> mmachenry: can you give an example, or a link talking about this?
16:14:30 <levi> c74d: Parsec tends to have nicer error messages and can be used as a monad transformer, but they have a similar set of core combinators.
16:14:31 <mmachenry> mjrosenb: do { x; y; z; mysteriousThing :: Int }
16:14:58 <mjrosenb> and let the error message tell me what the type is?
16:15:06 <mmachenry> Either mysteriousThing is an Int, or can be unified to an Int, or GHC will complain and say I can't unify the real type with Int
16:15:15 <mmachenry> That's one simple trick.
16:15:32 <mmachenry> Also you might consider breaking this up because a really large anything in code is bad.
16:15:39 <mmachenry> But for now that trick ought to work.
16:15:43 <mjrosenb> mmachenry: well, this code isn't mine
16:15:51 <mjrosenb> it is an example
16:15:57 <mjrosenb> but sans type annotations.
16:16:03 <mmachenry> Ah, well then yeah, prod at it with type ascription.
16:16:48 <c74d> pavonia: I have Attoparsec, and the only Haskell packages I have installed are GHC and Scotty, and I assume it's not part of Scotty.
16:16:52 <c74d> levi, thanks.
16:19:16 <Hijiri> aeson is a dependency of scotty
16:19:23 <Hijiri> attoparsec is a dep of aeson
16:20:00 * hackagebot descriptive 0.9.3 - Self-describing consumers/parsers; forms, cmd-line args, JSON, etc.  http://hackage.haskell.org/package/descriptive-0.9.3 (ChrisDone)
16:20:26 <nkar> anyone has experience with upsert form persistent?
16:20:38 <nkar> how do I create a value of the Update type?
16:20:45 <c74d> Oh, I guess `nix-env -q` only lists packages I've explicitly installed.
16:22:00 <c74d> Would it be particularly difficult to parse a format with significant indentation with (Atto)Parsec? (I've not used a Haskell parser library before.)
16:22:37 <pavonia> nkar: Update isn't a type but a constructor of Upsert, no?
16:23:41 <Hijiri> is there an example of a concrete monomorphic type where a Typeable instance can't be derived?
16:26:46 <c_wraith> Hijiri: not since the changes to Typeable for GHC 7.8
16:27:14 <c_wraith> Hijiri: for the earlier (non-polykinded implemtnation) of Typeable, yes - things were ambiguous when dealing with really complex kinds.
16:27:48 <Hijiri> I guess the "Kind-polymorphic Typeable instance for type application" case takes care of that?
16:37:03 <enthropy> Hijiri: "concrete monomorphic type" excludes things like Nat and Symbol?
16:37:15 <nkar> pavonia: http://haddocks.fpcomplete.com/fp/7.8/20140916-162/persistent/src/Database-Persist-Class-PersistUnique.html#upsert
16:37:47 <hjulle> So, is a category some kind of generalization of the concept of functions?
16:38:51 <Hijiri> enthropy: yes
16:39:35 <enthropy> ok well in 7.8 you can't    typeOf (Proxy :: Proxy "foo")
16:40:16 <pavonia> nkar: The constructors are defined here http://haddocks.fpcomplete.com/fp/7.8/20140916-162/persistent/Database-Persist-Types.html#t:Update
16:40:32 <serendependy> hjulle, As I understand it, a morphism is a generalization of a function, an object is a generalization of a set, and a category is type of combination of objects with morphism
16:40:47 <serendependy> *morphisms
16:41:38 <shachaf> Does "X is a generalization of Y" mean the same as "Y is a special case of X"?
16:41:58 <hjulle> shachaf, I guess so.
16:42:27 <serendependy> shachaf, Context would help I think
16:42:44 <benzrf> serendependy: sort of
16:43:06 <benzrf> serendependy: in the same sense that an element of a group is a generalization of a number and a group is a generalization of the set of numbers
16:43:09 <benzrf> :)
16:43:56 <serendependy> benzrf, I was as precise as I could be without exceeding my knowledge of the subject xD
16:44:09 <hjulle> Where are haskell types in the hiarchy of objects and sets? And is "Hask" the cathegory of haskell types with haskell functions?
16:45:25 <ReinH> hjulle: I'm not sure what the hierarchy of objects and sets is. Yes.
16:45:55 <ReinH> hjulle: https://wiki.haskell.org/Hask
16:46:13 <bernalex> I'm tired. someone help me convert this to a comprehension: do {x <- Just 4; y <- Just 2; let z = x+y; return (z*(z+1))}
16:46:22 <bernalex> I can't remember how to do the let z = x+y part in a comprehension.
16:46:49 <hjulle> It's let in that case too.
16:46:55 <exio4> let z = x+y
16:47:11 <enthropy> > [ (a,b) | a <- [1.. ], let b = a ]
16:47:12 <lambdabot>  [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11),(12,1...
16:47:12 <bernalex> ahh
16:47:14 <bernalex> of course
16:47:31 <bernalex> or just
16:47:33 <bernalex> > [let z = x+y in z*(z+1) | x <- Just 4, y <- Just 2]
16:47:35 <lambdabot>  Couldn't match expected type ‘[t]’
16:47:35 <lambdabot>              with actual type ‘Data.Maybe.Maybe a0’Couldn't match expected ty...
16:47:35 <lambdabot>              with actual type ‘Data.Maybe.Maybe a1’
16:47:46 <exio4> monad comprehesion isn't enabled in lambdabot
16:47:56 <bernalex> yeah I just remembered/figured... but thanks!
16:48:24 <exio4> bernalex: let in right side means you can use in guards too
16:49:13 <hjulle> Can you enable them in lambdabot?
16:49:27 <exio4> > [ (x,y) | x <- [1..], let y = x ^ 3 - x ^ 2, y > x ]
16:49:28 <lambdabot>  [(2,4),(3,18),(4,48),(5,100),(6,180),(7,294),(8,448),(9,648),(10,900),(11,12...
16:52:14 <hjulle> What I'm missing the most in list comprehensions is some good way to integrate takeWhile in them. As soon as you need some stopping condition, it will become a mess and not look like a list comprehension any more.
16:52:59 <shachaf> Not everything has to be a list comprehension.
16:53:35 <c_wraith> I almost never use list comprehensions
16:53:43 <hjulle> No, but the rest of the problem looks really nice as a list comprehensions, so I would like to use them
16:55:32 <Rotaerk> I tend to forget list comprehensions exist, in practice
16:56:52 <hjulle> > [ (x,y) | x <- [1..], let y = x ^ 3 - x ^ 2, y > x , y < 10*x ]
16:56:55 <lambdabot>  mueval-core: Time limit exceeded
16:58:38 <hjulle> > takeWhile (\(x,y) -> y < 10*x ) [ (x,y) | x <- [1..], let y = x ^ 3 - x ^ 2  ]
16:58:39 <lambdabot>  [(1,0),(2,4),(3,18)]
16:59:23 <hjulle> Or even worse:
17:00:11 <hjulle>  > [ (x,y) | x <- takeWhile (\x -> let y = x ^ 3 - x ^ 2   in y < 10*x ) [1..], let y = x ^ 3 - x ^ 2  ]
17:00:41 <hjulle> > [ (x,y) | x <- takeWhile (\x -> let y = x ^ 3 - x ^ 2   in y < 10*x ) [1..], let y = x ^ 3 - x ^ 2  ]
17:00:42 <lambdabot>  [(1,0),(2,4),(3,18)]
17:14:21 <bernalex> hmmm how would you guys write
17:14:25 <bernalex> fs <*> xs= [f x | g ← fs, x ← xs]
17:14:37 <benzrf> looks OK to me
17:14:38 <bernalex> as simply as possible without monad comprehensions or do-notation?
17:14:39 <benzrf> just s/g/f
17:14:47 <bernalex> benzrf: oops yes
17:15:02 <bernalex> benzrf: but I want to write it without a comprehension. on this slide I haven't gotten to comprehensions yet. :p
17:15:09 <benzrf> uuuhhh
17:15:16 <benzrf> how about
17:15:45 <bernalex> it's Functor -> Applicative -> Monad, and then do-notation & comprehensions are under Monad, hah. so I'd like to write this without introducing new concepts somehow.
17:15:58 <benzrf> fs <*> xs = map (flip map xs) fs
17:16:04 <bernalex> I guess I can... yeah exactly
17:16:05 <benzrf> :t \fs xs = map (flip map xs) fs
17:16:11 <benzrf> oh hell
17:16:44 <pacak> Why not use <*> as is?
17:17:04 <bernalex> pacak: uh because I'm explaining the Applicative [] instance?
17:17:31 <pacak> One more monad tutorial, yay.
17:17:39 <bernalex> pacak: this is on a slide for explaining Applicative Functor.
17:17:45 <ReinH> Applicative tutorial
17:17:54 <xnull> you can define operators like that?
17:18:03 <ReinH> Applicatives are like burritos in a subtly different way than Monads are like burritos
17:18:05 <ReinH> xnull: sure
17:18:11 <xnull> a + b = blah?
17:18:14 <xnull> waow
17:18:15 <bernalex> ReinH: I'd like to think my slides are a bit better than that.
17:18:19 <geekosaur> so if a monad is a burrito, is an applicative like a tamale?
17:18:23 <pacak> > let 1 + 1 = 3 in 1 + 1
17:18:25 <lambdabot>  3
17:18:25 <avocado> enchilada
17:18:25 <ReinH> bernalex: Oh that wasn't about your slides
17:18:37 <pacak> Even lambdabot knows that 1 + 1 = 3
17:18:38 <avocado> geekosaur: or maybe an empanada
17:18:40 <wayne> xnull: they're called infix operators
17:18:47 <xnull> wayne: i thought it was done like
17:18:52 <xnull> (+) a b = blah
17:18:56 <geekosaur> they can be
17:18:57 <bernalex> but yeah anyone know of a concise-ish neat way to write <*> for lists without comprehensions or do-notation?
17:19:03 <geekosaur> there's no difference between prefix and infix
17:19:04 <wayne> sure, the parens make it okay
17:19:06 <pacak> xnull: It's the same.
17:19:10 <bernalex> I guess I can write it out verbosely
17:19:13 <xnull> woah
17:19:21 <benzrf> bernalex: fs <*> xs = map (flip map xs) fs
17:19:29 <xnull> pacak: that 1 + 1 = 3 thing is really neat (i know it's simple pattern matching but still)
17:19:32 <geekosaur> and you can write either kind in either way (word characters wrapped in `` for infix or symbol characters wrapped in () for prefix)
17:19:45 <benzrf> er fuck wait...
17:19:46 <ReinH> bernalex: I suppose you don't want ap fs xs
17:19:52 <bernalex> ReinH: hehe, correct ;)
17:19:58 <benzrf> that'd be concatMap i think
17:20:00 <benzrf> ayy lmao
17:20:09 <benzrf> mfw i write out ap
17:20:19 <benzrf> bernalex: if concatMap is ok...
17:20:21 <benzrf> ;)
17:20:32 <geekosaur> > let a `plus` b = a + b in plus 5 2 -- or even do this
17:20:33 <lambdabot>  7
17:20:37 <ReinH> bernalex: just do some equational reasoning on the definition of ap specialized to [] ;)
17:20:44 <bernalex> benzrf: that's not the same.
17:20:45 <ReinH> fnid a simple version
17:20:52 <benzrf> aaah ?
17:21:09 <bernalex> @let lulz fs xs = map (flip map xs) f
17:21:11 <lambdabot>  Defined.
17:21:19 <bernalex> > lulz [(+1),(+2)] [1,2]
17:21:21 <lambdabot>  Could not deduce (Debug.SimpleReflect.Expr.FromExpr [a0 -> b])
17:21:21 <lambdabot>    arising from the ambiguity check for ‘e_11212’
17:21:21 <lambdabot>  from the context (Debug.SimpleReflect.Expr.FromExpr [a -> b],
17:21:34 <bernalex> err
17:21:44 <bernalex> @let lulz fs xs = map (flip map xs) fs
17:21:45 <lambdabot>  .L.hs:153:1: Warning:
17:21:45 <lambdabot>      Pattern match(es) are overlapped
17:21:45 <lambdabot>      In an equation for ‘lulz’: lulz fs xs = ...
17:21:51 <bernalex> @unlet
17:21:51 <lambdabot>  Define what?
17:21:55 <bernalex> @unlet lulz
17:21:55 <lambdabot>  Parse failed: TemplateHaskell is not enabled
17:21:57 <bernalex> god
17:22:00 <bernalex> I suck at lambdabot
17:22:02 <c_wraith> @undefine
17:22:02 <lambdabot> Undefined.
17:22:06 <bernalex> @let lulz fs xs = map (flip map xs) fs
17:22:07 <lambdabot>  Defined.
17:22:10 <bernalex> > lulz [(+1),(+2)] [1,2]
17:22:12 <lambdabot>  [[2,3],[3,4]]
17:22:13 <bernalex> > ap [(+1),(+2)] [1,2]
17:22:16 <lambdabot>  [2,3,3,4]
17:22:18 <bernalex> benzrf: ^
17:22:22 <bernalex> c_wraith: thanks
17:22:33 <benzrf> bernalex: yes hence concatMap
17:22:42 <benzrf> it is just ap
17:22:46 <benzrf> :v?
17:22:56 <ReinH> bernalex: I've got it.
17:23:00 <ReinH> @. pl undo \fs xs -> do { f <- fs; x <- xs; return (f x) }
17:23:00 <lambdabot> (. ((. (return .)) . (>>=))) . (>>=)
17:23:02 <ReinH> You're welcome.
17:23:08 <benzrf> how nice, ReinH
17:23:10 <bernalex> ReinH: I said without monads.
17:23:20 <c_wraith> >>= is just flip concatMap
17:23:20 <benzrf> just replace concatMap and (:[])
17:23:20 <ReinH> replace (>>=) with (flip concatMap)
17:23:22 <benzrf> ^.^
17:23:27 <ReinH> and return with (:[])
17:23:29 <bernalex> I suppose
17:23:45 <ttt_fff> in the context of https://www.haskell.org/platform/doc/2014.2.0.0/ghc/users_guide/generic-programming.html .. how do I use conName and datatypeName ?
17:23:49 <ReinH> @undo \fs xs -> do { f <- fs; x <- xs; return (f x) } -- or do it to this
17:23:50 <lambdabot> \ fs xs -> fs >>= \ f -> xs >>= \ x -> return (f x)
17:23:57 <ttt_fff> I can't figure out when I can use either function
17:24:11 <bernalex> "thanks"
17:24:27 <ReinH> bernalex: I think you can simplify from there, get rid of the flips, and come up with something reasonable
17:24:35 <tempname11_> wow, that point-free transformation above is crazy
17:25:07 <ReinH> ReinH: I'm just too lazy/busy to attempt it
17:25:15 <pacak> ttt_fff: You might want to use those for custom serialization, hash calculation or similar stuff.
17:25:15 <geekosaur> "@pl" is more a source of humor than a useful tool :p
17:25:28 <ttt_fff> pacak: ah< i want to use it
17:25:34 <ttt_fff> pacak: I just can't figure out how to use them
17:25:37 <tempname11_> geekosaur: how do I use it?
17:25:37 <ttt_fff> pacak : I am printing out data structures to svg nodes
17:25:42 <pacak> ttt_fff: http://hackage.haskell.org/package/beamable-0.1.1.1/docs/src/Data-Beamable-Internal.html
17:25:48 <ttt_fff> pacak : but I cna't figure outhow to ptring out the datatype / constructor name
17:26:19 <pacak> ttt_fff: This example uses both
17:26:26 <ttt_fff> pacak : nice; thanks!
17:27:18 <geekosaur> tempname11_, what, @pl? you give it an expression phrased as a lambda; it will try to rewrite it without the lambda's parameter bindings
17:27:57 <tempname11_> what does the "undo" mean, though?
17:28:03 <geekosaur> you might experiment in a /query to lambdabot
17:28:18 <tempname11_> good idea, thanks
17:28:20 <geekosaur> undo is another bot command that translates do notation to bind operations
17:28:49 <geekosaur> ReinH used composition (yes, lambdabot can compose its own commands together) to feed the result of @undo to @pl
17:29:06 <ttt_fff> pacak: wtf does instance (GBeamable a, Datatype d, Constructor c) => GBeamable (M1 D d (M1 C c a)) where  .... mean ?
17:29:12 <tempname11_> cool
17:30:40 <bernalex> ReinH: f fs xs = concatMap (\ f -> concatMap (\ i -> (f i) : []) xs) fs -- lol
17:30:42 <glguy> M1 is the type of GHC.Generics metadata. type D1 = M1 D, and D1 is the type of datatype metadata, type C1 = M1 C, and C1 is the type of data constructor metadata
17:31:12 <pacak> ttt_fff: If there's a datatype with one constructor it will be represented as a bunch of metadata around a single field.
17:31:26 <glguy> Datatype is a class for looking up that metadata about a type constructor and Constructor is a class for looking up metadata on a data constructor
17:31:35 <pacak> ttt_fff: GBeamable a means that this single field also must be Beamable.
17:31:47 <ttt_fff> pacak: so I'm getting an error of the form "Could not deduce (Datatype d0) arising from use of datatypeName from the context (G_SVgTree a) bound by the instance declaration at ....
17:31:53 <ttt_fff> yeah
17:32:02 <ttt_fff> I'm most confused about the typelcass restriction stuff
17:32:03 <pacak> Datatype d / Constructor c is not required, but helps understanding
17:32:07 <ttt_fff> I just have: instance (G_SvgTree a) => G_SvgTree (M1 i c a) where
17:32:11 <ttt_fff> let me paste my entire code
17:32:20 <bernalex> ReinH: or with better (slightly) better names, f fs xs = concatMap (\f -> concatMap (\x -> (f x) : []) xs) fs
17:33:13 <ttt_fff> https://gist.github.com/anonymous/6a848a02d1ffb7386697 is what I have
17:33:17 <ttt_fff> and ghc is not liking my use of datatypeName
17:33:24 <pacak> bernalex: If you use that for tutorial - make it simple without high level magic. Plain old recursion.
17:33:28 <ttt_fff> (on line 17)
17:33:45 <bernalex> pacak: that's what I'm leaning towards, yes. I can't see a much nicer way to write it than what I gave above.
17:34:16 <pacak> ttt_fff: And the error message?
17:34:27 <pacak> Full one
17:34:32 <ReinH> bernalex: That looks about right
17:34:44 <ttt_fff> pacak: https://gist.github.com/anonymous/1dbb3a4d61a112ce6f03
17:34:48 <glguy> _gSvgTree m@(M1 x) = svg_label (_Text $ datatypeName m) $ _gSvgTree x -- you want something like that + a Datatype constraint on 'c'
17:34:50 <bernalex> ReinH: yes but not too nice for beginners. so I think I'll write it verbosely with multiple equations.
17:34:51 <ttt_fff> pacak: I'm disappointed you can't read my screen through irc
17:35:02 <glguy> and then you'll need another instance for the C and S cases, since that's specific to M1 D
17:35:08 <ReinH> bernalex: If only there were some way to separate that sort of computation out into a series of steps
17:35:27 <ttt_fff> glguy: holy shit, that compiled
17:35:28 <ReinH> bernalex: ;)
17:35:39 <bernalex> ReinH: yes, but functor->applicative->monad is the way I'm trying out for explaining it. and that's the way the abstractions are in ghc today.
17:36:09 <ReinH> bernalex: I'm just being flippant, sorry
17:36:19 <bernalex> ReinH: yes I see.
17:36:33 <bernalex> ReinH: the Applicative instance for [] in GHC is (<*>) = ap fwiw.
17:36:46 <ReinH> bernalex: Yes, I did mention that :)
17:37:26 <ReinH> The above is what ap translates to in do notation
17:37:28 <bernalex> I don't feel like introducing ap and liftM2 id at this point in the talk. :)
17:37:40 <lpaste> glguy pasted “for ttt_fff” at http://lpaste.net/121531
17:37:52 <ReinH> I elided liftM2 by the cunning use of replacing liftM2 id f x with return (f x) :)
17:40:09 <shachaf> Cunning indeed, since those can't even type-check for the same f and x.
17:40:21 <ttt_fff> glgluy, pacak: it compiled, it run, it did not throw an excep[tion, and I thikn I'm starting to understand what's goign on here now; thanks!
17:40:37 <pacak> Btw, is there any better ways to go from Word to Int where (-1) is 0xFFF... other than unsafeCoerce?
17:41:02 <shachaf> fromIntegral?
17:41:19 <pacak> ttt_fff: Awesome. Don't forget to write a tutorial on that, current documentation is not very good.
17:41:42 <ttt_fff> pacak: I refuse to deprive other haskellers the character building experience.
17:41:49 <ttt_fff> that would be rather selfish of me
17:42:31 <pacak> shachaf: Magic.
17:45:28 <ReinH> shachaf: liftM2 id fs xs, woops
17:45:57 <ReinH> And, in fact, with \fs xs -> do { f <- fs; x <- xs; return (f x) }
17:46:37 <bernalex> how horrible would this be: g (f:fs) xss@(x:xs) = f x : g [f] xs ++ g fs xss -- ?
17:48:05 <bernalex> it looks right-ish to a sick me that's been awake for far too long...
17:48:33 <bernalex> oh wait nope
17:49:29 <bernalex> that won't even typecheck as Applicative
17:49:30 <btcNeverSleeps> I just "discovered" what liftM2 does by needing it in a toy example I'm writing and hoogling' its type signature but I've got a question...
17:50:02 <btcNeverSleeps> I realized I needed something like fmap, but with "more arguments", so I did ":t fmap"
17:50:05 <btcNeverSleeps> :t fmap
17:50:06 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:50:29 <btcNeverSleeps> So I thought, oh, ok, I need:    Functor f => (a -> b -> c) -> f a -> f b -> f c    let's hoogle that
17:50:37 <btcNeverSleeps> and I find liftM2
17:50:39 <btcNeverSleeps> :t liftM2
17:50:40 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
17:50:51 <geekosaur> :t liftA2
17:50:52 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
17:51:59 <btcNeverSleeps> wait... After finding liftM2, I realize there's liftM too.  And liftM seems liks fmap.  And things are a bit confusing now :-/
17:52:19 <geekosaur> @where typeclassopedia
17:52:19 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
17:52:25 <geekosaur> ^ read that
17:52:26 <pacak> btcNeverSleeps: liftM - for monads, fmap for Applicative.
17:52:45 <btcNeverSleeps> pacak: but I fmap over Maybe's all the time
17:52:58 <ReinH> btcNeverSleeps: fmap is to Functor as liftM is to Monad
17:53:03 <bernalex> hm. anyone have an idea to improve my g to actually uh work?
17:53:15 <ReinH> and liftA is to Applicative
17:53:18 <shachaf> fmap, liftA, and liftM all do the same thing.
17:53:22 <btcNeverSleeps> and Maybe is both a functor and a monad?
17:53:23 <geekosaur> the short version is that we have a chain of things that add more abilities (but also restrictions) as you go. Functor, Applicative, Monad is the core. for historical reasons liftM is not fmap even though it should be
17:53:28 <geekosaur> (this is being fixed soon)
17:53:34 <pacak> > let 1 + 1 = 3 in  (+1) `liftM` (Just 1)
17:53:36 <lambdabot>  Just 3
17:53:48 <ReinH> btcNeverSleeps: yes
17:53:54 <btcNeverSleeps> oh I see
17:53:55 <bernalex> I mean for stuff like 'pure (+) `g` [1,2] `g` pure 10' or '[(+10), (+20)] `g` [2,5]' it will work fine. but it fails for e.g. '(+) <$> [10, 20] `g` [2,5]'. =(
17:53:56 <geekosaur> all Monads are Applicatives, all Applicatives are Functors
17:54:06 <bernalex> (because could not deduce bleurgh bleurgh baww)
17:54:33 <pacak> geekosaur: They will be in ghc 7.10
17:54:38 <geekosaur> (the historical baggage is that (a) Applicative is fairly recent (b) Monad should have but did not require Functor, so had to make its own custom fmap (liftM)
17:54:48 <bernalex> oh wait!
17:54:49 <geekosaur> yes, "(this is being fixed soon)"
17:54:53 <bernalex> that's just fixity!
17:54:59 <bernalex> maybe my g is actually usable. hmmm.
17:55:05 * hackagebot derive-topdown 0.0.0.2 - This library will help you generate Haskell empty Generic instances and deriving type instances from the top automatically to the bottom for composited data types.  http://hackage.haskell.org/package/derive-topdown-0.0.0.2 (songzh)
18:00:10 <tomberek_> can a QuasiQuoter get access to what typeclass constraints might be on a declaration?
18:00:18 <enthropy> anybody know of some TH to generate TFs +instances for every FD in a class?
18:00:29 <enthropy> tomberek_: no they're run before type checking
18:00:48 <tomberek_> enthropy, dang, thanks
18:01:37 <tomberek_> and no, i don't know of TH to generate TFs
18:02:05 <enthropy> typed TH might be a way (if you can possibly generate your code with just [|| $$( ) ||] things)
18:02:48 <btcNeverSleeps> How comes I can write:   liftM2 MyFn xxx yyy instead of:  liftM2 (\a b -> MyFn a b) xxx yyy   ?  (I can right?)
18:03:02 <tomberek_> i'm not familiar with typed TH,
18:03:03 <enthropy> tomberek_: merijn was was looking into that a while ago
18:03:37 <enthropy> https://mail.haskell.org/pipermail/ghc-devs/2015-February/008259.html
18:06:15 <tomberek_> is typed TH in current 7.8.4?
18:06:15 <bob_twinkles> btcNeverSleeps: because function application is at the same precedence as function application, so what you're really writting is (((liftM2 MyFn) xxx) yyy)
18:06:47 <bob_twinkles> because left associativity
18:07:18 <btcNeverSleeps> bob_twinkles: that is very interesting.  I'll need to get used to it.  I'm used to name arguments to anonymous functions (in Clojure).
18:09:50 <enthropy> tomberek_: yeah
18:10:41 <tomberek_> enthropy, i've not messed with it yet,   i will say that comment #8 sounds great: https://ghc.haskell.org/trac/ghc/blog/Template%20Haskell%20Proposal#comment-8
18:11:22 <tomberek_> hsExp and simpl look very convenient
18:15:54 <btcNeverSleeps> :t liftM2 (+) (elemIndex 'a' "abc")
18:15:55 <lambdabot> Maybe Int -> Maybe Int
18:16:07 <btcNeverSleeps> ah
18:16:24 <btcNeverSleeps> on my repl it says: liftM2 (+) (elemIndex 'a' "abc") :: Maybe Int -> Maybe Int
18:16:49 <btcNeverSleeps> and my question was: is it because of non-strictness that it doesn't say: liftM2 (+) 0 :: Maybe Int -> Maybe Int
18:19:07 <HEGX64> btcNeverSleeps: Yes
18:20:24 <tomberek_> enthropy: i take it that there are no quasiquoters in Typed TH?
18:20:53 <enthropy> nope
18:24:43 <tomberek_> enthropy:  ah,, i think i see the problem with what I am trying.....  Template Haskell quotation doesn't support proc notation,,,, one of the reasons I had to make a quasiquoter to desugar proc notation.... but if I've done that, can i feed the desugarred version into [|| x ||] ?
18:25:31 <ozataman> Is it possible to specify multi-package OR conditions in cabal's build-depends area?
18:26:23 <ozataman> I want to say (lens >= 4 && < 4.4) || (lens >= 4.4, lens-aeson)
18:26:39 <enthropy> tomberek_: your desugaring gets you Exp... I think you aren't supposed to be able to have a unsafeTC :: Exp -> TExp a
18:26:41 <tomberek_> ozataman: i'm not sure, though I can imagine that throws cabal dependency tracking for a loop
18:26:56 <enthropy> ozataman: yes with a flag
18:27:20 <ozataman> I was hoping to avoid using a flag and have the solver figure it out automatically
18:28:05 <tomberek_> enthropy::  i just tried something like this:    h = [myQuoter|  proc n >- arr (+1) -< n+2 |]   and then g = [|| $$(h) ||]  it seems to work other than a missing constraint
18:28:25 <btcNeverSleeps> In     fmap (\a -> (toEnum a :: Char)) (Just 65)      can I get rid of the argument named a? I don't know how to specify that the enum is Char without the named parameter
18:28:59 <geekosaur> :t Data.Char.chr
18:29:00 <lambdabot> Int -> Char
18:29:20 <johnw> fmap (toEnum :: Int -> Char)
18:31:05 <serycjon> Hi, I am pretty new to haskell, but I know some functional programming from scheme and clojure...
18:31:19 <wayne> hi serycjon, welcome!
18:31:21 <btcNeverSleeps> serycjon: same here ; )
18:31:51 <serycjon> Do you know about some good projects for beginners?
18:33:11 <serycjon> Something fun on which I could learn to love Haskell
18:34:11 <serycjon> Especially I want to meet things that you cant do/are insanely hard to do in other languages
18:34:52 <serycjon> Any clues?
18:35:05 <tomberek_> serycjon: anything exploring laziness might be a good start
18:35:49 <btcNeverSleeps> :t toEnum
18:35:50 <lambdabot> Enum a => Int -> a
18:36:37 <pacak> Did anybody suggested lens already?
18:36:56 <serycjon> tomberek_: thanks! I know laziness from clojure, but I will surely look at haskell in this aspect
18:37:08 <serycjon> What is lens?
18:39:15 <pacak> A package that allows doing lots of strange stuff. Shows how flexible in unusual ways haskell can be.
18:39:45 <HeladoDeBrownie> i think lens is a bit… much for an initial learning exercise
18:39:53 <HeladoDeBrownie> it puts together tons of concepts that would be best explored individually first
18:40:46 <pacak> HeladoDeBrownie: I think it puts together all known concepts and adds a ton of it's own on top...
18:41:07 <HeladoDeBrownie> serycjon, have you seen 99 haskell problems or project euler?
18:41:40 <Zemyla> The easiest way to understand Lens is to read lens 0,1.0.
18:41:59 <serycjon> Yeah, I am reading lens docs now and it definitely is too much :-) :-)
18:42:19 <shachaf> Zemyla: I don't think that's true. A lot of the interesting parts of lens weren't around back then.
18:42:20 <pacak> Zemyla: Them forget everything about it and read version 0.1.1, then go to 0.1.2...
18:43:14 <Zemyla> Well, it shows why it uses forall functors.
18:43:49 <serycjon> I know proj. Euler but didnt know 99 problems. Will give it a try... that should occupy me for few years :-)
18:44:30 <pacak> serycjon: Read source of modules in base
18:45:54 <serycjon> That sounds like a good way to learn too. Thanks
18:46:15 <serycjon> See you later. Bye!
18:53:34 <tomberek_> enthropy::  hahah!  it is possible to use a quasiquotation inside of [|| ||]
18:56:52 <gyaretto> I'm having a bit of a weird issue. I'm using syntastic in vim and it uses ghc-mod for Haskell checking. Whenever I save a file in my project, I get "syntastic: error: checker haskell/ghc_mod returned abnormal status 1"
19:01:15 <ReinH> gyaretto: try calling ghc-mod directly from a terminal
19:01:19 <gyaretto> I initialized this project with cabal, but if I copy my src/ directory to a test directory outside of my project, I can save without error.
19:01:21 <ReinH> You might get an actual error message.
19:01:47 <gyaretto> /Users/Garrett/repos/doompiler/dist/setup-config: hGetContents: invalid argument (invalid byte sequence)
19:01:53 <gyaretto> doompiler is my project directory.
19:02:19 <pacak> gyaretto: Any unicode symbols in cabal file?
19:03:11 <gyaretto> pacak: I don't think so, but how do I know  for sure?
19:03:27 <gyaretto> I can gist it.
19:06:12 <pacak> gyaretto: Something like cat blah.cabal | od -tx1 | grep " f"
19:07:01 <gyaretto> pacak: Nothing.
19:12:44 <btcNeverSleeps> gyaretto: invalid byte sequence?  Ain't that the "binary file" thinggy?  Incompability between Cabal 1.22 and ghc-mod.
19:13:41 <btcNeverSleeps> Basically Cabal moved to a binary file format for whatever file and ghc-mod doesn't support it yet.  Got bit by this really badly with Emacs.  Took me a long time to find out / solve : )
19:14:06 <gyaretto> Hm. So, is there anything I can do to resolve it?
19:17:30 <btcNeverSleeps> gyaretto: you probably can use a slightly older cabal in a sandbox.  Note that AFAIK you must create a new project using the older cabal and not just switch to an older cabal while keeping the project files created with cabal 1.22.  Btw which cabal version are you running?
19:18:21 <gyaretto> 1.22
19:19:30 <btcNeverSleeps> gyaretto: in my Emacs case, I dumped ghc-mod and I'm very happy with flycheck + ghci-ng (it's ghci but enhanced with a few cool features).  But I know I managed to get rid of the "hGetContents: invalid byte sequence" while I was still using ghc-mod, using a cabal sandbox and constraints on the cabal version etc.
19:20:44 <gyaretto> Oh, I found a solution.
19:20:49 <gyaretto> let g:syntastic_haskell_ghc_mod_exec = 'ghc-mod.sh'
19:21:29 <btcNeverSleeps> gyaretto: ^ ^
19:21:45 <gyaretto> btcNeverSleeps: Thank you for your help! I will keep your advice in mind should I run into any related issues in the future. :)
19:48:47 <solatis> haha i have been toying around with F# the past few days and discussing in ##fsharp
19:48:56 <solatis> i suddenly feel smart
19:49:02 <solatis> and as if I actually understand things
19:49:46 <mac10688> I'm not sure if I'm learning haskell to be a better programmer or just feel smart that I can understand functional programming
19:50:34 <solatis> yeah well haskell forces you to learn some concepts
19:50:39 <solatis> you cannot "fake it until you make it"
19:50:59 <mac10688> can I "Do it until I can"?
19:51:25 <solatis> of course, which is what most people here do
19:51:34 <solatis> i bet there are no more than 3 people in this room who can, however :)
19:53:20 <mac10688> did I just play someone at vectorhtml5?
20:10:52 <dgorbik> Hi! I am trying to make an exersise from here: http://en.wikibooks.org/wiki/Haskell/Category_theory asking why a given example can't be a category. I got to: h . idA = idB . h = f . id A = idB . f I suppose this is a contradiction, but why?
20:17:35 <dmj`> dgorbik: why do you suppose it is a contradiction?
20:18:33 <dgorbik> dmj`: not sure, I just suspect that they want me to show that f = g, but I am failing to prove that if f . g = h . g then f = h
20:19:37 <dgorbik> well, I guess I could start by saying that f /= h then proving they are actualy same arrows
20:19:59 <dgorbik> then in the exersise it would lead to f = g, which is impossible, because there are two distinct arrows on the diagram
20:34:42 <dolio> They can't possibly expect you to show that f = g, because those have different types.
20:36:25 <dolio> However, the point of that diagram is that f and h are supposed to be distinct.
20:36:36 <dolio> So if you can prove that f = h, that is the point.
20:37:19 <dolio> dgorbik: ^
20:37:40 <Jessi> Hello
20:38:45 <augur> hackage is giving me bad gateways :(
20:38:58 <Jessi> I'm following Real World haskell tutorial GUI chapter. However, I'm getting the following error:
20:39:07 <Jessi>  No instance for (gtk-0.12.5.7:Graphics.UI.Gtk.Types.WidgetClass  Window)
20:39:14 <Jessi> can anyone help please
20:39:16 <Jessi> :)
20:39:32 <shachaf> Sounds like you have multiple versions of gtk installed.
20:40:24 <Jessi> shachaf, thanks, how can I know that? sorry for silly question? I'm a newbie
20:40:45 <shachaf> ghc-pkg list gtk or something.
20:40:46 <augur> who's responsible for Hackage?
20:40:49 <augur> anyone know?
20:41:05 <augur> oh now its 503ing, thats better
20:41:57 <Jessi> shachaf, you are write I've got two versions: gtk-0.12.5.7    and gtk-0.13.0.3
20:42:25 <Jessi> I meat right :)
20:43:12 <Jessi> oh god, How can I fix it please?
20:47:43 <megamac> > pl \x y -> x + 1
20:47:44 <lambdabot>  <hint>:1:4: parse error on input ‘\’
20:48:19 <megamac> > pl \v1 v2 -> sum (zipWith (*) v1 v2)
20:48:20 <lambdabot>  <hint>:1:4: parse error on input ‘\’
20:48:34 <megamac> > unpl ((f .) .) . g
20:48:36 <lambdabot>  Not in scope: ‘unpl’
20:48:54 <bernalex> megamac: are you trying to use @pl?
20:49:02 <megamac> > print $ "length [1,2,3] " ++ show (length [1,2,3])
20:49:03 <lambdabot>  <IO ()>
20:49:15 <megamac> > pl print $ "length [1,2,3] " ++ show (length [1,2,3])
20:49:16 <lambdabot>  Not in scope: ‘pl’
20:49:16 <lambdabot>  Perhaps you meant one of these:
20:49:16 <lambdabot>    ‘pi’ (imported from Prelude),
20:49:28 <bernalex> megamac: what are you doing? there is no function named pl.
20:49:43 <megamac> > pl \print $ "length [1,2,3] " ++ show (length [1,2,3])
20:49:44 <lambdabot>  <hint>:1:4: parse error on input ‘\’
20:50:23 <megamac> > pl \ x -> x * x
20:50:24 <lambdabot>  <hint>:1:4: parse error on input ‘\’
20:50:32 <megamac> > pl \x -> x * x
20:50:32 <bob_twinkles> megamac: it's @pl
20:50:33 <lambdabot>  <hint>:1:4: parse error on input ‘\’
20:50:37 <bob_twinkles> megamac: not > pl
20:50:51 <bernalex> the things you are writing are completely nonsense. would you like some help? if not, please use '/query lambdabot' so as to not spam the channel.
20:52:16 <megamac> sorry, not my intention
20:53:08 <bernalex> that's OK. but it would be useful if you informed us what you are trying to do, so we could help you. :) it appears you are trying to use the @pl command, which is separate to the interpreter. you use '@pl [stuff]' rather than '> [stuff]'.
20:53:45 <shachaf> It's best to experiment with lambdabot in /msg rather than in the channel.
20:54:07 <shachaf> If you have a question about lambdabot, it's better to ask it than to wait for someone to correct you.
20:54:11 <Jessi> shachaf, please help
20:54:50 <shachaf> Huh?
20:55:38 <Jessi> I've unregistered both gtk versions. but now I can't install the one that glade requires which is the gtk-0.12.5.7
20:56:04 <shachaf> If you have a question, you should ask the channel, not me.
20:56:08 <shachaf> I don't know anything about gtk.
20:56:20 <pacak> Jessi: Register one back?
20:57:17 <pacak> Jessi: Are those in user install or global ones?
20:58:20 <Jessi> pacak: Im not sure.
21:01:10 <Jessi> pacak: when I register it says: Reading package info from "gtk-0.12.5.7" ... ghc-pkg: gtk-0.12.5.7: openFile: does not exist (No such file or directory)
21:02:17 <pacak> Jessi: try moving ~/.ghc and ~/.cabal somewhere else and installing it again
21:07:51 <Jessi> pacak: thank I'll try that :)
21:49:20 <Zemyla> Huh, I think I found a new Monad.
21:51:11 <Zemyla> Wait. No, I think it's just the Free Monad on Identity with a little extra external baggage.
21:54:00 <Zemyla> It;s basically the dual of the Nonempty Comonad, found using edwardk's comonad-to-monad transformation.
21:54:31 <johnw> what is the type?
21:56:03 <Zemyla> data CoNonEmpty a = First a | Rest (CoNonEmpty a)
21:56:46 <dmj`> anyone use the haskell swagger api in here?
21:56:47 <shachaf> As codata, that's the Partial monad.
21:56:56 <dmj`> just have a few questions
21:57:09 <Zemyla> return = First; (First a) >>= f = f a; (Rest m) >>= f = fmap Rest (m >>= f)
22:01:20 <johnw> Zemyla: I don't quite follow the "fmap Rest" there.  That means Rest (First a) becomes First (Rest b)?
22:02:00 <johnw> or rather, <whatever f returns> (Rest b)
22:02:18 <johnw> I should just try it out, n/m
22:02:25 <Zemyla> Actually, wait.
22:02:43 <Zemyla> It would just be Rest (m >>= f).
22:02:51 <Zemyla> *should just
22:04:30 <Zemyla> And there is an adjunction (a -> b -> r) -> Nonempty a -> CoNonEmpty b -> r.
22:04:44 <shachaf> An adjunction?
22:05:13 <Zemyla> Wait, is that am adjunction?
22:05:57 <shachaf> I don't know. An adjunction is between two functors.
22:07:30 <johnw> I believe an adjunction would be expressed as an isomorphism like: NonEmpty a -> b  ≅  a -> CoNonEmpty b
22:09:32 <Zemyla> @hoogle (a -> b -> r) -> f a -> g b -> r
22:09:34 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
22:09:34 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
22:09:34 <lambdabot> Data.Foldable foldl :: Foldable t => (a -> b -> a) -> a -> t b -> a
22:10:33 <johnw> Zemyla: that function type is awfully close to the Day convolution
22:10:40 <johnw> forall b c . Day (f b) (g c) (b -> c -> a)	
22:11:50 <johnw> or rather, Day holds the arguments to your function
22:15:14 <ReinH> johnw: o/
22:15:21 <johnw> heya ReinH!
22:17:54 <Zemyla> Hey ReinH. Do you know what combinator I'm thinking of?
22:20:14 <ReinH> Zemyla: what is CoNonEmpty?
22:20:55 <Zemyla> data CoNonEmpty a = First a | Rest (CoNonEmpty a)
22:21:35 <shachaf> I don't think it's a dual of NonEmpty in any meaningful sense.
22:22:08 <shachaf> But it's pretty standard (though as codata, not as a free monad).
22:22:20 <Zemyla> It's the monad you get by applying edwardk's transformation here http://comonad.com/reader/2011/monads-from-comonads/ to the NonEmpty monad.
22:22:35 <Zemyla> *NonEmpty comonad.
22:22:54 <ReinH> Zemyla: NonEmpty being what?
22:23:30 <Zemyla> newtype NonEmpty a = NonEmpty (a, [a])
22:24:24 <ReinH> ok, so like the one from semigroup
22:25:00 <Zemyla> Yeah, basically.
22:25:36 <shachaf> Why is it what you get from forall r. NonEmpty (a -> r) -> r?
22:26:27 <ReinH> shachaf: Is ed's transformation just a cps transformation?
22:26:50 <shachaf> Isn't it ddarius's transformation? Or someone's, I don't know.
22:27:36 <ReinH> shachaf: I'm not sure. I thought you were referring to Zemyla's reference to "edwardk's transformation" above.
22:27:39 <ReinH> So many references.
22:27:43 <Zemyla> forall r. NonEmpty (a -> r) -> r becomes (a -> r, [a -> r]) -> r, which becomes (a -> r) -> [a -> r] -> r.
22:28:11 <shachaf> Anyway, I don't understand the question, so I can't say.
22:29:44 <shachaf> It seems to me that a function :: forall r. NonEmpty (a -> r) -> r has some value :: a, which it can apply to one of the functions you give it.
22:29:59 <shachaf> But its choice for which function to use can depend on the length of the list you give it.
22:30:30 <shachaf> I said that backwards. It can apply one of the functions you give it to that value.
22:31:31 <napping> It could also have several values of type a, and decide which to use based on the length of the list
22:31:52 <shachaf> Yes, also true.
22:32:01 <shachaf> But at any rate it's more complicated than (Nat,a)
22:32:33 <napping> Closer to Nat -> a, though there's also the choice of a function
22:33:15 <hjulle> How do people handle unwrapping 'Maybe's? I just keep ending up with a 'case' clause, because using 'maybe' feels too unreadable most of the time.
22:33:36 <shachaf> case is good. maybe can be good. Sometimes fromMaybe if that's all you need.
22:34:44 <hjulle> When is maybe an improvement from case
22:34:45 <Zemyla> So this is actually just Writer (Sum Nat) a.
22:35:02 <shachaf> No.
22:48:24 <Zemyla> Wel, this seems more like the dual of Stream than that of NonEmpty.
22:49:05 <Zemyla> And actually, this is Free Identity. Stream is Cofree Identity.
22:49:09 <shachaf> I don't think "Co" gives you the dual of things in any usual sense.
22:49:26 <shachaf> What's Free Identity?
22:50:33 <Zemyla> Co
22:51:10 <Zemyla> shachaf: Co Store = State, Co Env = Reader, Co Traced = Writer.
22:51:20 <shachaf> Those are all true.
22:51:40 <napping> How or where is Co defined?
22:51:53 <Zemyla> And edwardk shows that if w = f g, then Co w = g f.
22:51:56 <shachaf> newtype No w a = Co { runCo :: forall r. w (a -> r) -> r }
22:52:26 <shachaf> By "f g" you mean "f . g"?
22:52:42 <Zemyla> Yeah.
22:52:55 <shachaf> Do you mean adjoint functors in particular or any composition?
22:54:20 <OpenJoke5> ciao a tutti  <-=[C]ityHunter ScRipT =->
22:54:22 <OpenJoke5> Ciaoo :)) -*-*-*-*-*-*->
22:54:28 <OpenJoke5> !list
22:54:28 <monochrom> OpenJoke5: http://lpaste.net/browse
22:54:46 <EvanR> !list
22:55:03 <EvanR> k monochrom isnt a bot
22:55:13 <gfixler> is it silly to instance Random to ease choosing game pieces from a list?
22:55:25 <EvanR> no but Arbitrary
22:56:33 <ReinH> gfixler: seems fine
22:56:39 <Zemyla> Well, there is an Adjunction Identity Identity, and there is (Adjunction f g) => Adjunction (Free f) (Cofree g),
22:56:56 <shachaf> The only endofunctor adjunction in Haskell is (e,) -| (e->)
22:58:11 <Zemyla> Well, since Cofree Identity = ((->) (Sum Nat)), then Free Identity = ((,) (Sum Nat)).
23:25:25 * hackagebot yackage 0.7.0.7 - Personal Hackage replacement for testing new packages.  http://hackage.haskell.org/package/yackage-0.7.0.7 (MichaelSnoyman)
23:30:26 * hackagebot apiary 1.4.0 - Simple and type safe web framework that generate web API documentation.  http://hackage.haskell.org/package/apiary-1.4.0 (HirotomoMoriwaki)
23:30:28 * hackagebot apiary-logger 1.4.0 - fast-logger support for apiary web framework.  http://hackage.haskell.org/package/apiary-logger-1.4.0 (HirotomoMoriwaki)
23:30:30 * hackagebot apiary-persistent 1.4.0 - persistent support for apiary web framework.  http://hackage.haskell.org/package/apiary-persistent-1.4.0 (HirotomoMoriwaki)
23:30:32 * hackagebot apiary-websockets 1.4.0 - websockets support for apiary web framework.  http://hackage.haskell.org/package/apiary-websockets-1.4.0 (HirotomoMoriwaki)
23:30:34 * hackagebot apiary-cookie 1.4.0 - Cookie support for apiary web framework.  http://hackage.haskell.org/package/apiary-cookie-1.4.0 (HirotomoMoriwaki)
23:31:44 <EvanR> so many frameworks
23:32:04 <EvanR> killer apps as far as the eye can see
23:35:36 * hackagebot apiary-session 1.4.0 - session support for apiary web framework.  http://hackage.haskell.org/package/apiary-session-1.4.0 (HirotomoMoriwaki)
23:35:38 * hackagebot apiary-clientsession 1.4.0 - clientsession support for apiary web framework.  http://hackage.haskell.org/package/apiary-clientsession-1.4.0 (HirotomoMoriwaki)
23:35:40 * hackagebot apiary-authenticate 1.4.0 - authenticate support for apiary web framework.  http://hackage.haskell.org/package/apiary-authenticate-1.4.0 (HirotomoMoriwaki)
23:35:42 * hackagebot apiary-eventsource 1.4.0 - eventsource support for apiary web framework.  http://hackage.haskell.org/package/apiary-eventsource-1.4.0 (HirotomoMoriwaki)
23:35:44 * hackagebot apiary-purescript 1.4.0 - purescript compiler for apiary web framework.  http://hackage.haskell.org/package/apiary-purescript-1.4.0 (HirotomoMoriwaki)
23:40:46 * hackagebot apiary-mongoDB 1.4.0 - mongoDB support for apiary web framework.  http://hackage.haskell.org/package/apiary-mongoDB-1.4.0 (HirotomoMoriwaki)
23:40:48 * hackagebot apiary-memcached 1.4.0 - memcached client for apiary web framework.  http://hackage.haskell.org/package/apiary-memcached-1.4.0 (HirotomoMoriwaki)
23:40:50 * hackagebot apiary-helics 1.4.0 - helics support for apiary web framework.  http://hackage.haskell.org/package/apiary-helics-1.4.0 (HirotomoMoriwaki)
23:50:34 <Hijiri> swarm of killer apps
