00:00:28 <johnw> i had my first-ever legitimate use of unsafeCoerce tonight
00:00:41 <ReinH> :D
00:00:55 <ReinH> Only legitimate use I've seen is in reification
00:00:58 <johnw> Hoopl hides the fact that a Label is a newtyped Int, and I needed that Int (which was available in earlier versions)
00:01:05 <ReinH> ah
00:01:15 <johnw> so I paired unsafeCoerce with a very strict bounds checked in the .cabal file
00:01:27 <ReinH> well, that's just because the library violates Kmettian reusabiilty standards ;)
00:04:26 <ReinH> Wow, Conor's new paper is great
00:05:07 <ReinH> Regarding partiality, "Programmers are free to maintain that such dishonesty is essential to their capacity to earn a living"
00:08:04 <ReinH> johnw: ^
00:09:01 <ReinH> johnw: this actually seems like it might be relevant to something I've been working on too. Awesome.
00:15:26 <johnw> What is it that you've been working on?
00:19:27 <ReinH> johnw: a semantics for configuration management
00:20:34 <ReinH> well, not really configuration management, for distributed control of distributed systems
00:20:55 <Avnerium> Is the book Real World Haskell still good for learning Haskell? I heard it is outdated.
00:21:22 <ReinH> Avnerium: it's in need of an update
00:21:54 <shiona> for 7.10 or what?
00:22:02 <kadoban> It's still good. I don't know if it's a very good first intro to haskell at least.
00:22:07 <ReinH> it's a few years out of date
00:22:13 <kadoban> No, it was a bit outdated long before 7.10
00:22:27 <shiona> oh, ok
00:22:59 <Avnerium> Thanks
00:24:22 <kadoban> Avnerium: I like this recommendation for learning haskell, by the way: https://github.com/bitemyapp/learnhaskell#how-should-i-learn-haskell
00:27:17 <Avnerium> OK, I'll check this. Thanks!
00:37:46 <unb3k44n7> I successfully installed GHC. :) But now I have to figure out what I should do with it. Heh.
00:38:47 <Polarina> unb3k44n7, make a program that tells you how much it loves you.
00:39:10 <unb3k44n7> Auh man. What a genius idea!
00:39:43 <unb3k44n7> It has to be AI enough to be the least superficial as possible, however.
00:40:20 <unb3k44n7> Which means it would have to exceed 98 percent of all social traits of the modern human. 
00:40:31 <unb3k44n7> What a feat that would be.
00:40:50 <EunChe> The program 'happy' version
00:40:50 <EunChe> >=1.17 is required but it could not be found.
00:41:00 <EunChe> I have a problem: when I try to run "cabal install haskell-src-exts" , the message like this "
00:41:20 <EunChe> and the install fails, what is the reason and solution for that?
00:41:35 <Polarina> EunChe, can you install happy?
00:41:44 <f|`-`|f> wait, ReinH 
00:41:57 <kadoban> EunChe: cabal install happy    <-- do that first. cabal can't do it automatically because it's an executable and cabal only understands dependencies that are libraries, IIUC.
00:42:03 <f|`-`|f> A fuel system that restricts the issue of halting in Turing Complete systems?
00:42:04 <EunChe> which happy, cabal list happy and the topmost?
00:42:18 <EunChe> ok, thanks for reply. i'll try it now!
00:42:21 <f|`-`|f> ReinH  that's literally the Cryptofuel system for ethereum!
00:42:42 <f|`-`|f> (But it's more granular, with gas costs per function call, and line step)
00:43:45 <f|`-`|f> Other than that, I guess look out for things like DIFC (which is useful for decnetralised/distributed permissions/privileges)
00:43:49 <f|`-`|f> And
00:44:04 <f|`-`|f> This https://docs.google.com/document/d/1bRGmuTZFLLnFWrgFzV-Sy96lWgkYWdP9ywk21SAbIEM/mobilebasic?pli=1#ftnt_ref1
00:46:13 <f|`-`|f> If I recall, within Blockchain tech, there is interest in non-POW based consensus generation (either by POS, Federation, Delegated POS)
00:49:00 <f|`-`|f> As far as anything goes "a distributed multi-write system" is what I recall what the use case for a blockchain is
00:49:13 <f|`-`|f> or is it multi read
00:51:53 <f|`-`|f> Regardless, things to look out for is the Ethereum Uncle System, the Scalablity Blog Series on the Ethereum Blog (hyper cubes, polish spaces...), Thelonius (At least the part where the chains are self-defined, and a client can operate on any such chain)
00:53:19 <unb3k44n7> The `div`infix throws me off. I'm used to seeing div being used in coding a website. Why doesn't haskell just use / to divide. 
00:53:58 <unb3k44n7> Also, I read this:  if we wanted to get the successor of the product of numbers 9 and 10, we couldn't write succ 9 * 10 because that would get the successor of 9, which would then be multiplied by 10. So 100. We'd have to write succ (9 * 10) to get 91.  
00:54:07 <unb3k44n7> How does that equal 91?!
00:56:07 <EunChe> thank you Polarina and kadoban, your advices solved my problem.
00:56:08 <f|`-`|f> function application has the highest priority
00:56:12 <f|`-`|f> so
00:56:27 <f|`-`|f> succ 9 * 10 actually looks like (succ 9) * 10
00:56:54 <f|`-`|f> succ (9 * 10) looks like succ a where a = (9 * 10)
00:57:16 <f|`-`|f> so to get `a`, you need to evaluate 9*10, unb3k44n7 
00:58:17 <f|`-`|f> > (*10) (succ 9)
00:58:19 <lambdabot>  100
00:58:51 <unb3k44n7> But where is the 91 coming from in any direction of any of this?
00:59:08 <f|`-`|f> because 9*10 evaluates first
00:59:29 <unb3k44n7> ... sigh. i don't get it. 
00:59:37 <f|`-`|f> Hum
00:59:39 <johnw> > succ (9 * 10)
00:59:40 <lambdabot>  91
00:59:49 <johnw> > succ 9 * 10
00:59:51 <lambdabot>  100
00:59:53 <unb3k44n7> 9 times 10 is 100?
01:00:02 <f|`-`|f> how about this
01:00:03 <johnw> succ is the same as +1, more or less
01:00:07 <unb3k44n7> It's 100. So .... what is 91 all about?
01:00:11 <f|`-`|f> > succ 9 + 1
01:00:12 <lambdabot>  11
01:00:25 <f|`-`|f> > 1 + succ 9
01:00:27 <lambdabot>  11
01:00:39 <johnw> unb3k44n7: function application, i.e., succ 9, binds more tightly than operators do
01:00:49 <johnw> so it's first succ 9, which is 10, then * 10, which is 10 *10
01:00:51 <f|`-`|f> think of it like orders of operation
01:00:58 <EunChe> :t succ
01:00:59 <lambdabot> Enum a => a -> a
01:01:24 <f|`-`|f> it's Parentheses then Function Application, then ...
01:01:50 <unb3k44n7> so... 9 + a succ of 1 is 91.... 
01:02:22 <unb3k44n7> But it's showing the 9 and 10 being multiplied?
01:02:49 <f|`-`|f> > succ 9 * 10 == (succ 9) * 10
01:02:51 <lambdabot>  True
01:03:02 <unb3k44n7> WAIT! I get it!.
01:03:29 <f|`-`|f> > 1 + 9 * 10 == 1 + (9 * 10)
01:03:30 <lambdabot>  True
01:04:07 <f|`-`|f> The fact that orders of operation still applies makes me somewhat happy
01:04:22 <f|`-`|f> At least, up until (>>=)
01:04:25 <unb3k44n7> Is lambdabot actually a bot?
01:04:34 <f|`-`|f> yes
01:04:48 <f|`-`|f> lambdabot  also responds to pm's
01:04:55 <unb3k44n7> Why hasn't anyone booted 'it' yet?
01:05:09 <f|`-`|f> It's haskell robot
01:05:17 <f|`-`|f> That helps with figuring things out
01:05:22 <f|`-`|f> or examples
01:05:23 <unb3k44n7> Oh.
01:05:33 <f|`-`|f> it is also written in haskell
01:05:38 <unb3k44n7> ....weird.
01:05:57 <f|`-`|f> haskell.org is all haskell
01:06:26 <f|`-`|f> the irc browsing site that does data analytics for these haskell-related channels are written in haskell
01:06:38 <f|`-`|f> so is the the public log archive
01:07:22 <f|`-`|f> I've really come to accept that I can find haskell in the wild
01:07:50 <f|`-`|f> @help
01:07:50 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:08:14 <f|`-`|f> anyways, two things to know right off the bat
01:08:28 <f|`-`|f> `> [code here]` makes the bot run the code
01:08:49 <f|`-`|f> `:t [code here]` makes the bot tell you what type the code is
01:09:06 <f|`-`|f> :t map
01:09:07 <lambdabot> (a -> b) -> [a] -> [b]
01:09:22 <f|`-`|f> > map (+1) [1..10]
01:09:25 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
01:09:29 <unb3k44n7> ..."it" is narrating you. Lol.
01:10:17 <f|`-`|f> generally, the channels don't like being spammed with lambdabot commands
01:10:21 <f|`-`|f> So take it up in pm's
01:11:27 <f|`-`|f> The one thing I can honestly say is that you shout become quick friends with the :t command
01:11:44 <unb3k44n7> It's OK. I don't think I want to talk to lambdabot. I didn't know it was a bot until now. I just thought it was an overenthusiastic OCD person trying to learn Haskell...
01:12:28 <f|`-`|f> > concat . repeat $ "the "
01:12:30 <lambdabot>  "the the the the the the the the the the the the the the the the the the the...
01:14:05 <f|`-`|f> I dunno
01:14:17 <f|`-`|f> lambdabot has a neat fleece coat
01:14:25 <f|`-`|f> and gently baa's
01:14:41 <unb3k44n7> And pleated pants?
01:15:50 <f|`-`|f> Do sheep wear pants?
01:16:19 <unb3k44n7> Do pants wear sheep?
01:16:33 <f|`-`|f> wells pants don't operate
01:16:42 <f|`-`|f> So I'd rather tac insert with a sheep
01:16:51 <f|`-`|f> even if it is going commando
01:16:54 <unb3k44n7> They do if there's legs in them.
01:17:10 <f|`-`|f> pants are for big people
01:18:53 <f|`-`|f> does about 2k lines of code constitute a physically manifest sheep, let alone person?
01:18:56 <f|`-`|f> I rest my case
01:21:37 <f|`-`|f> also there si a channel #haskell-beginners that speialises in more "beginner" topics, unb3k44n7 
01:21:57 <f|`-`|f> the only distinction I find is that there is more talk about things I can understand there more than here
01:22:04 <unb3k44n7> I like this channel. 
01:22:21 <f|`-`|f> well hell
01:22:28 <johnw> and a #haskell-blah for topics not related to Haskell
01:22:33 <johnw> or only tangentially related
01:23:01 <johnw> well, maybe just not related at all
01:23:02 <Geraldus_> Hi friends!
01:23:40 <unb3k44n7> johnw, I get the hint, friend. :)
01:23:47 <johnw> :)
01:24:35 <unb3k44n7> It's all f|'s fault this time with the going off topic. I swear. :)
01:24:54 <f|`-`|f> this is the dead time
01:25:01 <f|`-`|f> and, does that really matter
01:25:12 <f|`-`|f> haskell-blah is the burrito lunch van
01:25:13 <johnw> it does
01:25:21 <kadoban> Anyone have a hint or link to resource about implementing longest common subsequence with Θ(min(m, n)) space /and/ being able to recreate the actual LCS, not just its length? I don't quite see how to do that, and don't see a resource that goes into it when I search.
01:29:01 <Geraldus_> I have somee issue, which persists only in my virtual environment. When I try to read text file with `System.IO.hGetContents` it results in "invalid byte sequence" error. The issue does not occur if I use `openBinaryFile` rather than `openFile`. But on host machine this file opens correctly. The real problem is that I'm not able to switch from `openFile` to `openBinaryFile` in
01:29:01 <Geraldus_> real code, because read operation is hidden itself inside `quoteFile` function.
01:30:24 <Geraldus_> I suppose I need to make some configuration on my virtaul environment, but I can't figure out which ones. 
01:32:20 <f|`-`|f> this is also the dead hour, unb3k44n7 
01:33:30 <unb3k44n7> Should still be conscious of the ideation to stay on topic in respect to Haskell and the nature of the room at which is operates. 
01:34:21 <unb3k44n7> it*
01:34:33 <rohan__> how good is haskell for competitive programming ?
01:35:03 <zomg> I would imagine that depends on what exactly is the goal of said competition
01:35:44 <johnw>  the dead hour in one person's timezone is not the dead hour for everyone
01:36:04 <johnw> off-topic chatter can inhibit questions, so we keep the policy at all times
01:39:03 * hackagebot linearscan 0.5.1.0 - Linear scan register allocator, formally verified in Coq  http://hackage.haskell.org/package/linearscan-0.5.1.0 (JohnWiegley)
01:39:05 * hackagebot linearscan-hoopl 0.5.1.0 - Makes it easy to use the linearscan register allocator with Hoopl  http://hackage.haskell.org/package/linearscan-hoopl-0.5.1.0 (JohnWiegley)
01:41:40 <indiagreen> kadoban: do you mean “in Haskell”? because just the algorithm is present in Wikipedia (Hirschberg's algorithm)
01:42:07 <unb3k44n7> rohan: after only learning what haskell was a few days ago, I've since read that It's not as fast as C++, but that the speed difference is so miniscule that It's really a non issue. I also read that in the slight lack of speed in comparison to C++, Haskell makes up for having less coding errors/bugs and crashes and since It's a more clean and precise language. That also reduces the time spent 
01:42:07 <unb3k44n7> maintining your code and fixing it. 
01:42:22 <unb3k44n7> See. I learned some stuff. Hrmph...
01:42:30 <unb3k44n7> :)
01:43:23 <johnw> unb3k44n7: in C++, performance is a primary concern, and so it's a primary benefit; in Haskell the meaning of your program is the primary concern, so a program that does what you meant is its primary benefit
01:43:35 <johnw> it's also fortunate that it can create fast code, and the compiler is always improving
01:43:53 <johnw> C++ has had a lot longer, and a LOT more money, to get to where it is
01:44:24 <unb3k44n7> ^ And that, too. :)
01:45:04 <kadoban> indiagreen: Hmm, I'll look at that. I think I saw a reference to it, but it didn't sound from the description like it let me find LCS.
01:51:38 <unb3k44n7> Unfortunately I need to sign off of here so I can visit my other site (since IRC doesn't allow VPN's, which I use on my other site -shakes fist). Goodnight all :)
01:53:56 <unb3k44n7> GL with your Haskelling. 
01:53:58 <unb3k44n7> !
01:54:42 <Pastaf> g'night.
02:04:05 * hackagebot memory 0.3 - memory and related abtraction stuff  http://hackage.haskell.org/package/memory-0.3 (VincentHanquez)
02:18:09 <Geraldus_> Hey friend! If someone have a time, please have a look at http://stackoverflow.com/questions/30421845/haskell-quotefile-fails-on-text-file-with-invalid-byte-sequence-on-unicode-ch
02:22:19 <fayong_> Hi everyone, Is there a library function in Data.Map for knowing how many keys are in the map?
02:22:55 <pavonia> fayong_: size?
02:24:25 <fayong_> ah ok thank you
02:26:19 <Wizek> Good Morning!
02:27:16 <muzzle> Hi, can anyone tell me why this code for parsing a binary data format is slow and hogs crazy amounts of memory ? http://lpaste.net/133247
02:27:41 <muzzle> It uses all the memory on my machine (4GB) for processing a 47MB file
02:27:54 <muzzle> and doesn't terminate after five minutes
02:30:28 <muzzle> what's causing me trouble is the replicateM method in Data.Vector
02:30:40 <muzzle> but I don't get why
02:31:14 <pavonia> What is Get?
02:34:01 <pavonia> muzzle: Are you trying to build a 47MB sized Integer value?
02:36:08 <pavonia> Hhm, never mind
02:38:00 <muzzle> pavonia: no, it's a file that can contain different types of integral values (Word8, Int8, Int16 or Int32), the getContent action gets one of these, depending on a type flag at the start of the file
03:18:23 <staffehn> What does getContent do?
03:18:43 <neo__> from which package?
03:18:44 <staffehn> wait, the param
03:18:50 <staffehn> nevermind
03:21:05 <Guest97607> Hello I am new to irc and this is my first Time on #haskell
03:21:14 <neo__> welcome!
03:22:00 <Guest97607> Thank you very much I have a few questions if you would like to answer them would be of great help
03:24:08 * hackagebot BNFC 2.8 - A compiler front-end generator.  http://hackage.haskell.org/package/BNFC-2.8 (GregoireDetrez)
03:24:38 <staffehn> ..go ahead, i guess
03:26:13 <staffehn> oh, thats what quit msgs are good for :/
03:26:36 <neo__> yep :P
03:29:08 * hackagebot pseudo-boolean 0.1.0.0 - Reading\/Writing OPB\/WBO files used in pseudo boolean competition  http://hackage.haskell.org/package/pseudo-boolean-0.1.0.0 (MasahiroSakai)
03:29:34 <etheral> Sorry guys having a bit of trouble connecting so i changed my username 
03:30:05 <Wizek> What options are there if I want to reuse certain functions that I have written? Is my only option to publish them to Hackage? Or can cabal support installing from other sources, e.g. github git url?
03:30:27 <etheral> So if anyone would like to answer a few questions I would be very grateful 
03:30:36 <Haskellfant> etheral: just ask your questions :)
03:30:44 <Haskellfant> Wizek: you can just install from any directory you want
03:31:01 <Haskellfant> I don't think passing a github url is supported but you can clone the repo and then point cabal to that directory
03:32:31 <etheral> Okk haha welll I'm doing a level 2college course in IT and I'm really interested in programming but I just can't seem to find the right language to start with 
03:36:24 <etheral> Sorry keep disconnecting. For some reason
03:36:37 <vandenoever> etheral: if you've never done any programming before, haskell is an interesting choice
03:36:55 <vandenoever> etheral: but it's quite different from c, c++, java, javascript etc
03:37:30 <neo__> It depends what you want to do really. If you just want a job, unfortunately I wouldn't recommend Haskell (as a first). but if you're generally interested in programming and creating a beautiful product - heck yeah, go for Haskell.
03:37:46 <etheral> Okk great :) is it a language that's best learnt from someone or learnt by yourself?
03:38:05 <vandenoever> neo__: there are quite some jobs in haskell and i'm sure it's going up atm
03:38:19 <vandenoever> etheral: depends on how you learn best
03:38:37 <vandenoever> etheral: if you pick up 'learn you a haskell for great good' you'll have a lot of fun
03:39:14 <etheral> I learn everything from the internet if I'm interested in something I see in the internet such as quantum physics I am like a sponge 
03:39:16 <neo__> vandenoever: true, but a tiny fraction of what you would find for some mainstream language, and I've heard they usually want experienced developers, so it might be hard. its certainly possible though
03:40:02 <etheral> If I do persue a language it wont be my last
03:40:05 <vandenoever> etheral: if you like quantum physics, you'll like haskell
03:40:45 <etheral> Love quanum physics with a passion haha
03:40:46 <vandenoever> etheral: there's two big families of programming languages: imperative and functional
03:41:04 <neo__> I suggest first reading LYAH and then for something more complete, Real World Haskell. I'm still reading Real World Haskell. it's not as well written but it covers much more than LYAH.
03:41:07 <vandenoever> imperative is the mainstream, functional is the cool kid
03:41:17 <etheral> Functional I'm guessing like JavaScript and c#?
03:41:27 <vandenoever> if you define cool as for mathematicians, scientists and computer scientists
03:41:42 <vandenoever> etheral: yes
03:42:07 <vandenoever> in the functional family there is also elm and ocaml
03:42:09 <etheral> Ahh haha well I see programming of any form an art form in itself 
03:42:24 <vandenoever> elm is 'haskelll for the web' with programming in the browser (elm-lang.org)
03:42:51 <u-ou> i thought js and c# are more imperative
03:42:59 <neo__> Yep ^
03:43:20 <vandenoever> oh right, sorry misread, yes javascript and c# are firmly imperative
03:43:25 * vandenoever just woke up
03:43:50 <staffehn> c# is like java, there is f# though, which is supposed to be functional iirc
03:43:56 <kadoban> etheral: I would recommend https://github.com/bitemyapp/learnhaskell#how-should-i-learn-haskell as a good suggestion for how to learn Haskell.
03:44:11 <vandenoever> when i learned haskell after 20 years of imperative, i wondered what i'd been doing all this time
03:44:14 <ChristianS> javascript allows a somewhat functional style, it depends on the programmer
03:44:24 <kadoban> I learned originally with RWH and some LYAH, but it took /forever/. I don't think they're the best available ways to learn themselves anymore.
03:44:58 <u-ou> ChristianS: yeah, some 'imperative' languages are like that
03:45:01 <etheral> Haha kadoban I will give your link a try and have a good read while I have time
03:45:13 <vandenoever> kadoban: i'm interested, do you have a suggestion for a more modern tutorial? lyah is 2011
03:45:20 <u-ou> the line is sorta blurry, but not completely
03:45:45 <neo__> Well I've seen this book pop up
03:45:45 <neo__> http://www.amazon.com/Thinking-Functionally-Haskell-Richard-Bird-ebook/dp/B00O0RKGTO/ref=sr_1_2?ie=UTF8&qid=1432464314&sr=8-2&keywords=haskell
03:45:54 <u-ou> real world haskell looks nice
03:45:56 <vandenoever> i dont think the line is blurry, if you say javascript is functional you can call any lang with lambdas functional
03:45:56 <kadoban> vandenoever: The above link. I don't think it's important that it's more modern than LYAH, I think it's just better than LYAH. LYAH doesn't have exercises and there's other issues with it as well.
03:46:23 <u-ou> yeah i guess :]
03:46:29 <kadoban> "functional" isn't a black and white thing. It's at least a continuum, there's probably many dimensions to it.
03:46:40 <neo__> Has anybody looked into Thinking Functionally with Haskell? what do you think of it?
03:46:41 <etheral> Guys you have answered my question in more than one way so I am very grateful for this information i got what i expected when a friend told me about this channel so thanks alot guys
03:46:50 <kadoban> Many things that are functional languages are … not much like haskell at all.
03:47:08 <vandenoever> kadoban: "The only reason you shouldn't start with cis194 is if you are not a programmer or are an inexperienced one."
03:47:33 <kadoban> vandenoever: Read the next sentence :)
03:48:06 <vandenoever> kadoban: ah :-)
03:58:14 <Wizek> Anyone has any idea why [line 18](https://github.com/Wizek/libs.hs/blob/master/Musings.hs#L18) executes instead of saying something along the lines of "Couldn't match expected type ‘a3 -> s0’ with actual type ‘Int’"?
03:58:36 <Wizek> Shouldn't that pattern match fail?
03:59:03 <socketman> kingofthesouth in here?
03:59:05 <Wizek> varArgs 1 clearly returns `One` and not `Two`, no?
03:59:56 <staffehn> Wizek: partial application
04:00:37 <staffehn> wait..
04:00:47 <Wizek> well staffehn I would only expect that to be the case if that line read `print $ let Two fn = varArgs 2 in fn 3`
04:01:01 <kadoban> > let (x:xs) = [] in "fooooo"  -- Wizek
04:01:03 <lambdabot>  "fooooo"
04:01:14 <staffehn> Wizek: yea, this the "wait..."
04:01:17 <staffehn> *thus
04:01:38 <kadoban> Wizek: It doesn't have any reason to actually care about the pattern match, as far as I see.
04:02:43 <Wizek> kadoban: But fn is defined within the pattern match, it cannot come from anywhere else can it?
04:03:08 <Wizek> I read it as follows: get me a fn but only if it can come from within a `Two`
04:03:21 <kadoban> Oh, sorry yeah I dunno in that case.
04:03:43 <staffehn> It doesnt execute it
04:03:46 <staffehn> thats it
04:04:29 <staffehn> Wizek: The pattern match would simply fail, but fn 3 doesn't get executed because your show instance is lazy in its argument
04:04:51 <Wizek> hmm
04:05:12 <staffehn> http://lpaste.net/133249
04:05:14 <staffehn> this fails
04:09:26 <Wizek> staffehn: But then how come if I remove the show instance declaration if fails with an unexpected error message instead of telling me that the pattern match fails?
04:10:41 <Wizek> http://lpaste.net/133250
04:11:22 <Wizek> wait
04:12:45 <Wizek> there whas a slight errror in the paste, but even when correcting it the result is the same
04:13:53 <Wizek> Is this still a lazyness issue?
04:15:03 <staffehn> Wizek: was afk, gonna take a look now
04:16:17 <Wizek> okay
04:16:43 <staffehn> Wizek: The "print $ let Two fn = varArgs 1 in fn 3" part kind of doesn't know about the definition of varArgs, so it pattern matches against Two fn and then thinks it gets a (Int -> Int -> Int), this the type/instance error.
04:17:03 <staffehn> Wizek. Also pattern match fails are run-time-errors!
04:17:09 <Wizek> hmm
04:17:20 <Wizek> yeah, it begins to make sense now
04:17:20 <staffehn> Wizek: And type errors are compile-time-errors.
04:17:38 <staffehn> SoTry: "print $ let Two fn = undefined in fn 3"
04:17:42 <Wizek> Isn't there a way to make pattern match checks at compile time somehow?
04:18:17 <Wizek> I heard it is possible to check wheter they are exhaustive at compile time at least...
04:18:35 <staffehn> Wizek: no, really almost all the things you do in haskell if they are not primitive things, then they are pattern matches
04:18:55 <staffehn> yea, but exhaustive means covering all the cases
04:19:09 <staffehn> With a let ... pattern match you always only cover 1 case
04:21:59 <staffehn> This also fails: http://lpaste.net/133252
04:22:05 <d-snp> hi, if I run: `trace "Some trace" $ someFun`, does the trace get executed before someFun is evaluated?
04:22:24 <staffehn> Wizek: ... again: at runtime
04:24:45 <staffehn> Wizek: This does not fail though: http://lpaste.net/133250.. there you see the difference between let and case regarding lazyness.
04:26:30 <Wizek> staffehn: very interesting! Thanks, I think I understand now
04:27:38 <staffehn> And finally compare this http://lpaste.net/133254 with this http://lpaste.net/133252. The first one is equivalent to the "let" version.. (the ~ means "lazy patternmatching", a really interesting thing/concept)
04:28:30 <Marce> hey
04:39:17 <ion> s/lazy/irrefutable/
04:42:54 <d-snp> is there a way to trace without the second argument being evaluated? before the trace is done?
04:43:12 <d-snp> I want to trace something before an exception is thrown, but I dont think its working
04:43:19 <d-snp> either that or I'm looking at it wrong
04:44:35 <staffehn> d-snp: I think that wouldn't make sense
04:45:27 <staffehn> d-snp: hmm maybe it would..
04:47:12 <staffehn> d-snp: isn't that what already happens? http://lpaste.net/133255
04:54:13 <noodles1> is there a built in function for concatenating a list of Int's to a String?
04:54:50 <staffehn> how should they be separated?
04:55:25 <Marce> i dont think so, but its easy to do noodles1, map show over the list of Ints and concat to string
04:55:34 <noodles1> as an list of Ints. "The list of ints is [1,2,3
04:55:37 <noodles1> \"
04:55:43 <Marce> oh
04:55:46 <staffehn> yea just use show
04:55:54 <staffehn> > show [1,2,3]
04:55:57 <lambdabot>  "[1,2,3]"
04:56:00 <Marce> show then, yup
04:56:24 <fishburne> I am trying to add logging to a function using a monad. But I cannot add a class constraint show in the instance declaration. Here is the code https://bpaste.net/show/ea9c9b525b1d
04:56:33 <noodles1> that was easy, thank you
04:56:51 <fishburne> How can I fix this?
04:59:24 <fishburne529> I am trying to add logging to a function using a monad. But I cannot add a class constraint show in the instance declaration. Here is the code https://bpaste.net/show/ea9c9b525b1d
04:59:30 <fishburne529> How can I fix this?
04:59:32 <staffehn> fishbourne: This is sadly impossible, just the way that Set is not a monad
05:00:25 <staffehn> There are ways to do it when Monad is defined differently by using clever Tricks and the help of language extensions.
05:02:17 <fishburne529> staffehn, Ok. 
05:06:31 <d-snp> hmm thanks staffehn that makes sense
05:06:36 <d-snp> then I dont know whats going wrong :(
05:08:01 <d-snp> I guess I need a proper backtrace somehow
05:08:59 <noodles1> Is there an a easy way to check enviroment variables, like interpreter / OS ?
05:12:39 <staffehn> noodles1: http://hackage.haskell.org/package/base-4.8.0.0/docs/System-Environment.html#v:getEnv
05:26:54 <noodles1> thanks again staffehn 
05:27:04 <neo__> I'm planning to write a small web library/framework. It's for HTTP(s - maybe) servers. should I build directly on top of Network.Socket - and implement HTTP or whatever's needed myself, or something else?
05:27:40 <neo__> I can invest some time into implementing HTTP, but it's one of these things that sounds fine but puts you into a living nightmare then I'd rather now
05:27:49 <neo__> not*
05:28:12 <vandenoever> neo__: how about starting with warp?
05:29:47 <neo__> vandenoever: looks good, might use that actually. 
05:35:30 <pacak> http://uncyclopedia.wikia.com/wiki/Haskell
05:35:36 <currywurst> hi , haskell interpreters do 0xa + 2 = 12 but should be 0xc.  same with octal numbers and how about 0b1 + 0b1? ? also: floatingpoint repr. -> error could BCD use 
05:37:06 <barrucadu> currywurst: I don't see a problem there. 12 is 0xC.
05:37:40 <barrucadu> :t showHex
05:37:42 <lambdabot> (Integral a, Show a) => a -> ShowS
05:37:54 <barrucadu> showHex (0xa + 2) ""
05:37:58 <barrucadu> > showHex (0xa + 2) ""
05:38:01 <lambdabot>  "c"
05:39:28 <barrucadu> There's also Text.Printf.printf which can show ints as hex values
05:39:30 <currywurst> you may alao do it with printf-features, but thats workaround and should not be
05:39:51 <barrucadu> So an int should remember whether it came from a hex literal or not?
05:40:00 <barrucadu> An int is an int, regardless of whether it's 12 or 0xc
05:40:55 <staffehn> > (("0b"++) . showIntAtBase 2 intToDigit) 42
05:40:58 <lambdabot>      Couldn't match type ‘String -> String’ with ‘[Char]’
05:40:58 <lambdabot>      Expected type: Integer -> [Char]
05:40:58 <lambdabot>        Actual type: Integer -> ShowS
05:41:22 <staffehn> > (("0b"++) . ($ "") . showIntAtBase 2 intToDigit) 42
05:41:25 <lambdabot>  "0b101010"
05:41:44 <currywurst> my calculator can do this , a little base n x function will do but thats  workaround, should be internal
05:42:30 <currywurst> and...bit calculation? 
05:42:38 <staffehn> currywurst: You can make your own datatype with special show instances
05:44:14 * hackagebot darkplaces-rcon-util 0.1.1 - Darplaces rcon utility  http://hackage.haskell.org/package/darkplaces-rcon-util-0.1.1 (slava)
05:45:26 <ion> currywurst: Should all numbers in the programming language additionally store the base to be used if they happen to be stringified? What should operations do when two numeric parameters have a different base? Should that be disallowed? You used base-16 and base-10 in your expression. Why should the former be picked for the output but not the latter?
05:48:31 <currywurst> a is base 16 2  is base 16 to
05:48:56 <currywurst> no problem with asm registers
05:49:34 <currywurst> base chanchings should be transparent
05:49:47 <ion> a and 2 are also base-36.
05:49:51 <Maxdamantus> it sounds like you're trying to make them opaque.
05:49:53 <staffehn> The base is ALWAYS 2.
05:50:12 <Marce> exactly, transparent and explicit
05:50:13 <currywurst> 2 is poly :)
05:50:15 <staffehn> Programming languages only use base 2.
05:50:31 <staffehn> Everything else would be terribly inefficient..
05:50:35 <staffehn> on a computer
05:50:48 <barrucadu> currywurst: What should be the output of printing 0xA + 0b1 ?
05:51:20 <int-e> staffehn: not all programming languages aim to be efficient, https://esolangs.org/wiki/TriINTERCAL
05:51:24 <currywurst> just b
05:51:54 <barrucadu> Why hex and not binary?
05:52:07 <staffehn> int-e: Yea, programming languages as in "actual programming languages" and not "esoteric programming languages" :D, I like esolangs.org btw..
05:52:58 <ion> currywurst: How about 0b1 + 0xA?
05:53:08 <currywurst> its just b
05:53:15 <currywurst> or 1011
05:53:20 <int-e> I wonder whether I'll see a practical ternary computer in my lifetime. (balanced base 3 looks like a really neat idea)
05:54:01 <staffehn> Whats the problem? Look:
05:54:08 <staffehn> > 0xA + 1 == 0xB
05:54:10 <lambdabot>  True
05:54:13 <staffehn> see?
05:54:41 <staffehn> The thing is that, when you write nothing, the interpreter uses the show Method:
05:54:46 <staffehn> > show 0xA
05:54:48 <lambdabot>  "10"
05:54:59 <staffehn> *function, not method..
05:55:21 <mauke> @src show
05:55:21 <lambdabot> show x = shows x ""
05:55:21 <staffehn> And that show function is defined for Integers, that it uses base 10.
05:55:40 <ion> Well, it *is* a method of the Show type class.
05:56:31 <staffehn> ion: True, but I had OO terminoligy in my head for some reason..
05:56:50 <staffehn> *terminology
05:57:39 <litb> hello my friends
05:58:42 <Ainieco> @src shows
05:58:42 <lambdabot> Source not found. Wrong!  You cheating scum!
05:59:25 <litb> lol
05:59:32 <ion> currywurst: You are free to implement a calculator program that keeps track of a show base for expressions, but it would be unreasonable for standard numbers to do that in a generic-purpose programming language.
06:02:05 <staffehn> also, for a calculater it would sometimes even make sense to have real different bases. For example base-10 floating point numbers.
06:02:38 <Phillemann> Cany anyone help me read this cabal dependency error: http://lpaste.net/133256
06:02:42 <currywurst> the point is, numbers and bases and memorynavigating etc could be very confusing and so an internal calculatorbehave (also with BCD simulation) will be helpful
06:02:45 <Phillemann> I'm using stackage lts-2.9
06:04:18 <phaazon> hey, what program do you use to generate ctags in Haskell?
06:04:21 <phaazon> hasktags?
06:04:27 <phaazon> I’ve been told ghc-mod could do that as well
06:04:41 <phaazon> it’d be neat that cabal could do that as well
06:10:12 <phaazon> hm, using hasktags
06:10:14 <phaazon> sounds good
06:10:27 <phaazon> I should include a call to hasktags after each configure
06:10:33 <phaazon> or each build, I guess
06:10:40 <phaazon> or a vim macro
06:11:24 <currywurst> to do an extra program or an extra function or an extra import (printf) for standardbases should not be - the same with lowleveactions like or,xor - there is a very good java prg: calc
06:11:33 <currywurst> from Roar Lauritzen#
06:18:10 <babu> I am using putWord16be x, works fine. Now I want to do putWord16be for all the x in [x], something like map putWord16be [x]. How can I do this?
06:19:40 <mauke> mapM_
06:19:46 <mauke> @src mapM_
06:19:47 <lambdabot> mapM_ f as = sequence_ (map f as)
06:21:58 <babu> mauke, thanks.
06:30:57 <muzzle> Hi, can anyone tell me why this code for parsing a binary data format is slow and hogs crazy amounts of memory ? http://lpaste.net/133247
06:30:58 <muzzle> It uses all the memory on my machine (4GB) for processing a 47MB file
06:30:58 <muzzle> and doesn't terminate after five minutes
06:41:59 <ClaudiusMaximus> muzzle: not enough code to see what might be causing any issue.  but try running with +RTS -h  to get a basic heap profile that should show what types are taking memory, might help to narrow it down (use hp2ps to get a summary graph)
06:42:46 <ClaudiusMaximus> muzzle: maybe it's an endian issue (eg, you expect the file to have 0x0010 items, but you're trying to get 0x1000 items)
06:45:27 <LAC1213> are there haskell bindings for llvm 3.6 ? I can only find some for 3.4
06:49:45 <muzzle> ClaudiusMaximus: This is the whole module http://lpaste.net/133257
06:49:52 <int-e> muzzle: I'm not convinced that V.replicateM works well in the Get monad (which supports backtracking...)
06:51:33 <muzzle> the problem is also, that i can't really profile it if it doesn't terminate
06:51:35 <muzzle> (ever)
06:52:04 <int-e> muzzle: can you confirm that the nEntries value is big (more than 100k, say)?
06:52:23 <ClaudiusMaximus> muzzle: heap profile output is written incrementally
06:52:23 <muzzle> the thing is, that i can get it to work if i do it via a tail recursive function where i read each value and force it's evaluation with seq and write it into an accumulator - list
06:56:02 <nshepperd> I didn't think Get has backtracking?
06:58:27 <nshepperd> I had the same problem, I patched over it by deepseq'ing the result after running the Get on my input
07:00:31 <nshepperd> possibly you could try something like 'forceM = (>>= (\x -> deepseq x (return x)) :: m a -> m a' and then 'V.replicateM n (forceM sub)' will force all the results as it goes
07:01:24 <ClaudiusMaximus> muzzle: Data.Vector is boxed, maybe that is causing a thunk leak;  http://hackage.haskell.org/package/vector-binary-instances-0.2.1.0/docs/src/Data-Vector-Binary.html#getGeneric internally uses unsafePerformIO with a mutable vector...
07:08:12 <muzzle> is there a strict haskell implementation ?
07:10:03 <Cale> muzzle: No, because Haskell's semantics are non-strict.
07:10:56 <int-e> muzzle: how about http://lpaste.net/133258
07:11:01 <Cale> You can play around with evaluation order a lot, but straightforward innermost-first evaluation won't work.
07:11:30 <int-e> (it still needs twice as much memory than strictly required, but I'm not sure how to get around that)
07:11:32 <Cale> (Many Haskell programs won't terminate)
07:12:51 <athan> wtf...? http://lpaste.net/133259
07:13:23 <athan> meh
07:14:03 <Cale> athan: Is it possible that there were .hi files hanging around in those directories from a previous version of GHC?
07:14:14 <athan> Cale: nope!
07:14:26 <athan> (this is a pretty new system)
07:14:39 <athan> I _just_ successfully installed it a few minutes earlier, too
07:14:52 <Cale> odd
07:14:56 <athan> (I just removed some imports & dependencies)
07:18:28 <nshepperd> serves you right for reinstalling things
07:19:20 * hackagebot base-orphans 0.3.2 - Backwards-compatible orphan instances for base  http://hackage.haskell.org/package/base-orphans-0.3.2 (ryanglscott)
07:21:16 <sdx23> lemmih: hi there
07:23:30 <sdx23> lemmih: should we turn to pm for acid-state / gsoc stuff?
07:24:20 * hackagebot pandoc-crossref 0.1.1.0 - Pandoc filter for cross-references  http://hackage.haskell.org/package/pandoc-crossref-0.1.1.0 (lierdakil)
07:24:55 <athan> nshepperd: ._.
07:26:38 <muzzle> int-e: are there any general rules to get stuff to run without space leaks ? I just cant seem to get anything to run with even halfway acceptable performance in haskell
07:28:22 <athan> muzzle: It all depends on how you write your expressions. Can I see what you're trying to make?
07:28:31 <athan> (are you doing project euler problems, also?)
07:29:17 <muzzle> athan: at the moment a simple parser for a binary data format http://lpaste.net/133257
07:29:40 <joehh> sdx23: I suspect just ask your question
07:29:49 <muzzle> athan: I can implement all features that I want, performance is just horrible
07:31:17 <muzzle> int-e: btw this is the fastest thing, that I could come up with: http://lpaste.net/133260
07:31:50 <muzzle> int-e: still takes twenty seconds for 47MB and several hundred megabytes though
07:32:46 * athan bites his tongue
07:32:59 <athan> muzzle: I really suggest profiling :\
07:33:27 <athan> criterion, threadscope, call centres, etc
07:33:33 <muzzle> well it just tells me that it allocates about 1.8GB of []
07:33:41 <muzzle> whyever it would do that
07:33:49 <muzzle> and that's for the more efficient version
07:33:59 <athan> o_o
07:34:16 <nshepperd> -hc tells you where
07:35:42 <muzzle> nshepperd: i already ran it, but it's all allocated in this: http://lpaste.net/133260
07:36:10 <muzzle> nshepperd: which doesn't really help me
07:37:38 <litb> is there a way to enlist all the memoizations that the interpreter currently has mapped?
07:37:57 <litb> like getting a list of  "foo bar -> 42, foo baz -> 11" 
07:38:27 <nshepperd> maybe try 'V.replicateM nEntries ((fromIntegral <$> getContent) >>= (return $!))'
07:39:25 <mauke> litb: that's easy. no memoization is done.
07:40:05 <litb> mauke, i thought that GHC stores the result to later retrieve it faster
07:40:12 <mauke> nope
07:40:17 <litb> oh that'S bad
07:40:21 <mauke> no, that's good
07:40:24 <litb> why is that
07:40:39 <mauke> because that's basically a memory leak
07:40:45 <litb> i thought that'S the whole point of being stateless
07:40:51 <nshepperd> knowing what to memoize is a Hard Problem
07:40:54 <mauke> "let's store all arguments and results forever!"
07:41:11 <litb> i see. but it could have a fixed-size pool of items it maps
07:41:29 <litb> why not have a LRU cache
07:41:34 <mauke> second problem: how do you build an efficient map for arbitrary types?
07:41:48 <sdx23> joehh: it's not a general haskell question but rather desgin / concept related. guess i'll just wait, he'll show up eventually :)
07:42:35 <litb> mauke, hm
07:43:20 <mauke> also, yeah. you're assuming that such a cache would make programs faster
07:43:56 <nshepperd> really I feel like Get should be strict in its results, since being strict in the state means that returning anything lazily is pretty much pointless anyway
07:44:16 <litb> why wouldn't it. when compiling the expression, the compiler would have a threshould of the time complexity of the evaluation starting by which it uses the map
07:44:54 <mauke> heh
07:45:10 <nshepperd> for most cases with pretty straightforward decoding anyway
07:50:47 <haskell856> @pl \f g x y -> f (x ++ g x) (g y)
07:50:47 <lambdabot> join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
07:51:18 <haskell856> @pl \f xs = map
07:51:18 <lambdabot> (line 1, column 7):
07:51:18 <lambdabot> unexpected "="
07:51:18 <lambdabot> expecting pattern or "->"
07:51:27 <haskell856> @pl countColors xs = map (\p -> length $ filter (==p) xs) colors
07:51:27 <lambdabot> countColors = flip map colors . (length .) . flip (filter . (==))
07:53:40 <haskell856> @pl exactMatches xs xy = length . filter (\(x, y) -> x == y) $ zip xs xy
07:53:40 <lambdabot> exactMatches = ((length . filter (uncurry (==))) .) . zip
07:53:41 <litb> @pl could aswell return a perl string and keep its semantics
07:53:41 <lambdabot> could aswell return a perl string and keep its semantics
07:54:10 <maerwald> haskell856: all of those are horrible, I hope you don't actually use them
07:54:40 <haskell856> well, i just started with haskell and working through cis194
07:55:05 <haskell856> so yeah, enlighten me please :)
07:55:09 <maerwald> haskell856: pointfree is not generally better than pointful, except when it is better
07:55:32 <haskell856> just curious to see how it would transform the solutions i came up with
07:56:31 <haskell856> i see..
07:57:49 <AshyIsMe> hmm, so im trying to profile my code but keep getting the "-p requires the program is built with -prof"
07:58:01 <maerwald> haskell856: e.g.: addTwo x = x + 2 <- this would be ugly imo and takes slightly more time to read than... addTwo = (+2)
07:58:06 <AshyIsMe> ive added ghc-options: -prof  to my project.cabal file
07:58:17 <AshyIsMe> and done a: cabal clean && cabal build
07:58:28 <maerwald> haskell856: but when your pointfree code takes more time to understand, don't do it
07:59:09 <haskell856> yeah, sure, still wrapping my head around it
07:59:25 <rewbert> Small questions. Lets say i got a number, something like 1.587767, and i want to round that off to 1.6, how would i do that?
07:59:38 <AshyIsMe> oh i got it working, nm
07:59:41 <rewbert> I know how ceiling and floor works, but ceiling returns 2 intead of 1.6, for obvious reasons.
07:59:56 <haskell856> thanks btw :)
08:00:19 <sdx23> rewbert: multiply by 10, round, divide?
08:00:31 <rewbert> Oh that's genius. Thanks!
08:02:02 <int-e> nshepperd: It seems that for monads other than IO or ST, Vector.replicateM actually collects values in an intermediate list... forcing the final vector isn't going to help much, while chunking (which I suggested earlier) is fairly effective.
08:03:24 <haskell856> @pl countColor p = length $ filter (==p) xs
08:03:24 <lambdabot> countColor = length . flip filter xs . (==)
08:05:24 <nshepperd> int-e: forcing the values as they get created should work for that, shouldn't it?
08:05:55 <nshepperd> replicate M (thing >>= forceThing)
08:06:10 <nshepperd> I guess that still leaves potentially a very long list
08:06:40 <nshepperd> of evaluated things
08:08:57 <int-e> nshepperd: yeah it does.
08:11:15 <Phillemann> Cany anyone help me read this cabal dependency error: http://lpaste.net/133256 - I'm using stackage-lts-2.9. It seems like classy-prelude depends on an old version of text, which attoparsec isn't compatible with?
08:11:55 <maerwald> rewbert: you can even write a general function for that like: roundN :: Double -> Int -> Double
08:15:37 <maerwald> @let roundN x n = let fac = 10 ^ (fromIntegral n) in flip (/) fac . fromIntegral . round . (x *) $ fac
08:15:39 <lambdabot>  .L.hs:206:1: Warning:
08:15:39 <lambdabot>      Pattern match(es) are overlapped
08:15:39 <lambdabot>      In an equation for ‘roundN’: roundN x n = ...
08:15:59 <maerwald> :t roundN
08:16:01 <lambdabot> (Integral a, RealFrac r) => r -> a -> r
08:16:09 <maerwald> > roundN 1.3923 2
08:16:12 <lambdabot>  1.39
08:16:43 <maerwald> > roundN 1.3923 0
08:16:47 <lambdabot>  1.0
08:19:27 <sdx23> > roundN 314.15 -1
08:19:30 <lambdabot>      No instance for (Typeable a0)
08:19:30 <lambdabot>        arising from a use of ‘show_M149584725263174618530631’
08:19:30 <lambdabot>      In the expression:
08:19:52 <sdx23> > roundN 314.15 (-1)
08:19:54 <lambdabot>  *Exception: Negative exponent
08:20:07 <sdx23> ah, good :)
08:20:16 <nshepperd> hmmm, even after running deepseq the memory usage seems to depend on the method used
08:20:53 <nshepperd> I don't think this should happen?
08:21:15 <maerwald> sdx23: rounding to a negative number does not make sense... it would mean to increase the amount of information out of nowhere
08:22:36 <zed_> hi : ) i'm new to haskell and need some help with a pi simulation i've adapted ... would someone lend me a helping hand ?
08:22:39 <nshepperd> ('after' in that I've run 'deepseqM x = deepseq x (return ())' earlier in the flow of IO execution, which should ensure evaluation)
08:23:05 <magneticDuck> zed_: that's what this channel is pretty much
08:23:13 <magneticDuck> start asking your question / posting your code
08:23:45 <zed_> magneticDuck: yeah you are right : )
08:23:46 <zed_> anyway
08:23:56 <zed_> so the code is : http://paste.ofcode.org/cVSY7scRHj83uCDy3g6PJ5
08:24:23 * hackagebot yesod-raml 0.1.0 - RAML style route definitions for Yesod  http://hackage.haskell.org/package/yesod-raml-0.1.0 (junjihashimoto)
08:24:54 <zed_> and the error is : https://gist.github.com/anonymous/447373cce5a24d886c77
08:25:37 <zed_> i think that i am mis-using replicateM and that it is the problem, but i am not sure how to fix it
08:26:18 <magneticDuck> @type replicateM
08:26:19 <lambdabot> Monad m => Int -> m a -> m [a]
08:26:30 <magneticDuck> unitBox is not a monad
08:27:11 <magneticDuck> zed_: there are.. several problems there
08:27:35 <magneticDuck> for one, you're expecting "unitDouble", which is a pure value of type (Double, Double), to have different values when you call it different times
08:27:56 <magneticDuck> and a pure value in haskell is, well, pure
08:28:28 <magneticDuck> you're right to bring replicateM into the problem, but you're forgetting to use the IO monad =P
08:29:18 <zed_> ok so where should I start ?
08:29:44 <magneticDuck> first, try to just make unitBox work
08:30:14 <magneticDuck> comment out everything else, and try to make unitBox into something that, when you call it from ghci, gives different values at different times
08:30:28 <magneticDuck> you're going to need to change that type signature
08:31:32 <zed_> do I need to make it into a monad for that ?
08:31:40 <sdx23> maerwald: not necessarily, if you think of it as "leave intakt n digits after the point".
08:32:23 <magneticDuck> :t randomRIO
08:32:25 <lambdabot> Random a => (a, a) -> IO a
08:32:39 <magneticDuck> > (randomRIO (1, 10)) :: Int
08:32:41 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘IO Integer’
08:32:41 <lambdabot>      In the expression: (randomRIO (1, 10)) :: Int
08:32:51 <magneticDuck> > (randomRIO (1, 10)) :: Integer
08:32:53 <lambdabot>      Couldn't match expected type ‘Integer’
08:32:53 <lambdabot>                  with actual type ‘IO Integer’
08:32:53 <lambdabot>      In the expression: (randomRIO (1, 10)) :: Integer
08:33:01 <magneticDuck> > (randomRIO (1, 10)) :: IO Integer
08:33:02 <maerwald> sdx23: how can you leave (-1) digits intakt?
08:33:03 <lambdabot>  <IO Integer>
08:38:31 <rewbert> Thanks for your help with rounding off decimals, it works perfectly now :-)
08:50:56 <zed_> @magneticDuck : so I googled a bit and was able to re-write unitbox such that it gives me new values every time
08:50:56 <lambdabot> Unknown command, try @list
08:51:08 <zed_> magneticDuck: so I googled a bit and was able to re-write unitbox such that it gives me new values every time
08:51:28 <suppi> lol
08:58:39 <magneticDuck> zed_: IO (Double, Double) ?
08:58:52 <zed_> yes
08:59:52 <rewbert> Hm
08:59:57 <magneticDuck> so now you can use replicateM to get a IO [(Double, Double)]
09:00:13 <magneticDuck> make a pure function of type [(Double, Double)] -> <whatever you want>
09:00:25 <magneticDuck> and use "fmap" to map it onto the IO [(Double, Double)]
09:02:53 <sdm> if I wanted to pretend that haskell was a strict language, and had an algorithm in mind that did not require laziness, what could go wrong if I used only strict data types and annotated all functions that I use to be strict in their arguments?
09:03:11 <init> it'd be strict 
09:03:22 <sdm> i ask only theoretically to know if I understand the concept well...I do not intend to use this in practice
09:04:38 <sdm> but will there be any performance penalty?
09:04:44 <sdm> or any other complications that may arise?
09:04:57 <zed_> magneticDuck: will try it out. thanks
09:05:21 <sdm> remember that my algorithm does not use any laziness
09:05:41 <sdm> so is the only drawback to this some ugliness in the code owing to annotations and perhaps doing things more than necessary?
09:06:22 <sdm> will anything break?
09:08:58 <Guest87232> @unmtl ReaderT e Identity a
09:08:58 <lambdabot> e -> a
09:09:16 <koomi> sdm: there is nothing inherently bad about implementing a strict algorithm in haskell
09:09:31 <init> sdm: it's pretty much just that, uglyness :P 
09:09:46 <zed_> magneticDuck: ok silly question: what's the difference between (Double, Double) and [(Double, Double)] ?
09:10:00 <Rotaerk> zed_, the second is a list
09:10:04 <Rotaerk> of the former
09:10:08 <Guest87232> @unmtl ReaderT e (ErrorT String (Identity)) a
09:10:08 <lambdabot> e -> (ErrorT String (Identity)) a
09:10:14 <init> (Double,Double) means you have _one_ tuple of doubles
09:10:26 <zed_> ohh i see
09:10:26 <zed_> thanks
09:10:38 <init> [(Double,Double)] means you have `n` tuples of doubles 
09:10:47 <init> n can be zero, you may not have any tuple at all 
09:10:50 <creichert> sdm: do you understand normal form and weak head normal form? Sometimes there's a bit more to it than just using ! or seq
09:11:01 <Guest87232> @unmtl ReaderT e (ErrorT String (StateT Integer Identity)) a
09:11:01 <lambdabot> e -> (ErrorT String (StateT Integer Identity)) a
09:11:29 <Phillemann> With attoparsec only having a single numeric parser "scientific", what's the recommended way to parse, say, integers and return a proper error if that fails? I'm not very familiar with attoparsec's error reporting mechanisms.
09:13:39 <rewbert> a function counting the max height in a Red black tree, i defined that ias
09:14:06 <rewbert> maxheight Nil (empty tre) = 0; maxheight (Node _ _ left right) = 1 + max (maxheight left) (maxheight right)
09:14:19 <rewbert> is the complexity of such a function O(n) worst case?
09:14:27 <monochrom> yes
09:14:34 <rewbert> Thanks :-)
09:14:38 <monochrom> all cases, too
09:14:39 <koomi> sdm: in fact johan tibell is working on a pragma to make a module strict-by-default in order to lessen the uglyness
09:14:53 <rewbert> Yea i figured it'd check each node once
09:15:26 <hexhaxtron> RIP John Nash
09:15:36 <zed_> Pi_Estimation_Area_dim.hs:6:9:
09:15:36 <zed_>     Couldn't match type ‘IO b0’ with ‘Double’
09:15:40 <zed_> so i am getting the following error : " 
09:15:52 <zed_> with the code : http://paste.ofcode.org/EfiiWqhbnaRER4bsmFsbZY
09:16:22 <zed_> when i try out replicateM in GHCI, everything works... so i am not sure what to do
09:20:18 <monochrom> ghci adds convenience features, therefore deviates from real haskell.
09:20:32 <monochrom> when ghci disagrees with ghc, ghci is wrong. remember that.
09:20:40 <geekosaur> zed_, why areyou using do in a non-monadic function?
09:20:52 <geekosaur> Double has no monadic instances
09:21:06 <zed_> thanks monochrom
09:21:23 <monochrom> geekosaur, it's because it requires unitbox, which is randomIO
09:21:34 <monochrom> the type should be Int -> IO Double
09:21:50 <zed_> geekosaur, also i have no idea what i'm doing ;) so i have no clever answer to that question, sadly
09:22:13 <monochrom> there will be alignment errors down the road
09:27:53 <zed_> thanks monochrom ! it works !
09:36:58 <ew0>  hey, does someone know a pastie for graphs ? like you paste graph in a .dot format and you can share it to eternity?
09:43:14 <joneshf-laptop> ew0, if you find one, let me know
09:43:40 <ew0> I've looked up last year
09:43:46 <ew0> now I'm looking for it again and no hits
09:44:00 <ew0> its tempting to write one, as it is something so simple
09:46:23 <ew0> well, I tweeted to pastie.org the suggestion
09:46:24 <ew0> xD
09:49:38 <indiagreen> ew0, joneshf-laptop: is this the one? http://g.jk.gs/
09:51:20 <ew0> ow yeah
09:51:27 <ew0> indiagreen, thanks!
09:51:57 <joneshf-laptop> indiagreen, nice!
09:52:11 <indiagreen> for future reference: googled “graphviz pastebin”, first link
09:52:27 <indiagreen> (disguised as a blog post)
09:54:41 <ew0> >_<'
09:55:11 <ew0> been crawling trough "google pastie"
10:04:49 <Guest28655> I have a probably very silly issue, but I'm not sure how to debug it. I'm trying to run the demos from the Frames library, but when attempting to run it I get the error "Could not find module 'Diagrams'". I have Diagrams installed both in a local sandbox and globally, so what could be causing this?
10:06:24 <akfp> Does fpcomplete publish stackage build artifacts?
10:07:42 <geekosaur> Guest28655, "diagrams" itself is a metapackage. do you have any backends installed? those actually provide the "Diagrams" module
10:08:54 <fayong> I have a linking problem when trying to compile a basic program with the euterpea library
10:08:55 <geekosaur> (by default it installs diagrams-svg, you can use flags to tell it to install one of the others)
10:09:15 <Guest28655> geekosaur: thanks. I think I have diagrams-svg installed, but can't see a way to check what's installed in a sandbox
10:09:19 <fayong> I posted a description of my problem on stackoverflow a while ago
10:09:19 <geekosaur> also I note that the DIagrams module itself does not exist, it is just namespace
10:09:29 * hackagebot orgmode-parse 0.1.1.1 - A collection of Attoparsec combinators for parsing org-mode  flavored documents.  http://hackage.haskell.org/package/orgmode-parse-0.1.1.1 (ParnellSpringmeyer)
10:09:30 <geekosaur> cabal sandbox hc-pkg list
10:09:31 <fayong> there: http://stackoverflow.com/questions/29995857/haskell-ghc-linking-error-when-trying-to-compile-a-program-using-ghc-and-euterp
10:10:05 <fayong> but didn't get any feedback
10:10:32 <fayong> does anyone know what could cause this?
10:11:09 <Guest28655> Thanks, diagrams-svg is installed. The error occurs at "import Diagrams".
10:11:24 <geekosaur> [24 13:08:57]  <geekosaur>	 also I note that the DIagrams module itself does not exist, it is just namespace
10:12:18 <Guest28655> Ok, I'm new to Haskell. Does "import X" always have to refer to a module, rather than just bringing a namespace into scope?
10:12:51 <geekosaur> "import Diagrams" does not mean "import everything under Diagrams", no
10:13:07 <zed_> is it me or does randomRIO only produces integers ?
10:13:24 <Guest28655> Ah, actually "import Diagrams (dims2D, width, height)" is the offending line.
10:13:31 <Guest28655> Ok thanks
10:13:46 <geekosaur> there is a quasiconvention of a top level package that re-exports some or all of the modules underneath, it is not built into the language 
10:14:00 <geekosaur> and wouldn't work here anyway because the names could come from any of the backends
10:14:12 <hiptobecubic> Data.Function.fix just doesn't speak to me
10:14:27 <hiptobecubic> I'm looking at this really neat looking thing http://stackoverflow.com/questions/3208258/memoization-in-haskell
10:15:01 <hiptobecubic> specifically this definition...
10:15:20 <hiptobecubic> > let f :: (Int -> Int) -> Int -> Int; f mf 0 = 0; f mf n = max n (mf (quot n 2) + mf (quot n 3) + mf (quot n 4)) in fix f 123
10:15:22 <lambdabot>  144
10:15:30 <geekosaur> zed_, it definitely does not only produce Integer, or "integer" whatever you meant by that
10:15:41 <Guest28655> Thanks geekosaur. I guess I'll just search through the Diagrams package to find a module that exports the functions this import line mentions
10:15:53 <hiptobecubic> and so we feed f back into f, where it's bound as 'mf' i guess
10:16:04 <geekosaur> I tried hayoo but apparently none of the backend modules builds on the buildbots >.>
10:16:14 <zed_> i meant an integer as opposed to a real number
10:16:33 <hiptobecubic> ah, but since that f doesn't know anything more than the original f, we don't gain anything
10:16:42 <zed_> cause when i ask ghci to evaluate randomRIO(0,1), it only gives me 0's and 1's
10:17:03 <geekosaur> that's because of defaulting
10:17:17 <geekosaur> absent any other information, 0 and 1 there get typed as Integer
10:17:26 <geekosaur> try randomRIO (0::Double, 1)
10:17:42 <zed_> thanks : )
10:17:56 <geekosaur> 0.0 might also work
10:18:08 <zed_> so do I have to specify that I want a Double or not, when I am using it in a program ?
10:18:15 <zed_> or in a function, or well not in ghci
10:18:22 <geekosaur> depends on context
10:18:26 <init> the type may be infered from the context
10:18:33 <geekosaur> if it can be inferred as Double then it will be used at Double
10:18:45 <joneshf-laptop> zed_, are you doing monte carlo sampling?
10:18:58 <zed_> joneshf-laptop: yes
10:20:33 <joneshf-laptop> so as a point of design, wouldn't it make sense to use quickcheck for that?
10:20:49 <joneshf-laptop> not necessarily the testing bits
10:21:03 <joneshf-laptop> but the `Arbitrary` part
10:21:52 <joneshf-laptop> and this question isn't for zed_ specifically
10:21:56 <Geraldus_> Hi friends! Having encoding issue with GHC 7.8.4 on Debian when reading file data: http://stackoverflow.com/questions/30421845/haskell-quotefile-fails-on-text-file-with-invalid-byte-sequence-on-unicode-ch
10:22:41 <geekosaur> Geraldus_, check your locale
10:22:54 <geekosaur> if it is not a UTF8 locale then ghc will be expecting ISO8859-1
10:23:34 <Geraldus_> geekosaur: I've set it to en_US.UTF-8. 
10:23:35 <geekosaur> alternately your file may be ISO8859-1 for some reason and the UTF8 decoder would choke. in fact I think that;s more likely; the other would add characters
10:24:07 <geekosaur> LANG=C od -c test-file.md
10:24:22 <Geraldus_> geekosaur: let me check
10:24:29 * hackagebot exherbo-cabal 0.1.0.0 - Exheres generator for cabal packages  http://hackage.haskell.org/package/exherbo-cabal-0.1.0.0 (NikolayOrlyuk)
10:24:50 <geekosaur> if it is UTF8 then the sequence for that character would be C2 AB
10:25:00 <geekosaur> if it is ISO8859 then it would simply be AB
10:26:34 <geekosaur> if sopmething else is there... well, tell us what it is and maybe we can figure out what encoding the file really is :)
10:27:59 <zed_> joneshf-laptop: i guess so, but i had not heard of it before you mentionned : ) i'm really beginning with haskell
10:28:11 <Geraldus_> geekosaur: I see 302 253 sequence for «
10:28:38 <geekosaur> that sounds like C2 AB
10:28:51 <geekosaur> and rereading your SO question, that makes sense if setting locale fixes it
10:29:13 <geekosaur> I would still verify the locale in the Docker container, because it sure sounds like it's not a UTF8 locale
10:29:19 <geekosaur> since forcing it to UTF8 fixes it
10:29:55 <Geraldus_> geekosaur: locale -a inside docker container shows me: C, C.UTF-8, POSIX en_US.utf8
10:29:59 <geekosaur> complicated by the fact that this is compile time and ghc itself follows slightly different rules
10:30:10 <geekosaur> um
10:30:38 <geekosaur> "locale -a" shows *available* locales
10:30:49 <geekosaur> just "locale"
10:31:31 <Geraldus_> geekosaur: oh thank you man, there are POSIX everywhere. So what is the correct way to set up locale on Debian? 
10:31:54 <joneshf-laptop> zed_, well it seems liek it to me because it'd simplify some of your program, but also make it clearer what's happening
10:32:14 <geekosaur> export LANG with any of the locales named in that locale -a output
10:32:17 <Geraldus_> geekosaur: I've followed Debian wiki: echo "en_US.UTF-8 UTF-8 >> /etc/locale.gen && locale-gen" 
10:32:18 <joneshf-laptop> unitbox = choose (0, 1)
10:32:22 <geekosaur> e.g. export LANG=C.UTF-8
10:32:25 <joneshf-laptop> zed_, `unitbox = choose (0, 1)`
10:32:46 <geekosaur> did you reboot after that?
10:32:57 <joneshf-laptop> zed_, `xs <- generate $ vectorOf n unitbox`
10:33:04 <mauke> Geraldus_: do you have a /etc/default/locale?
10:33:09 <geekosaur> your environment still does not have a locale, and running that command does not update the environment in running programs (and cannot)
10:33:12 <Geraldus_> mauke: let me check
10:33:44 <Geraldus_> mauke: yep, it is empty (there is only comment that is autogenerated file)
10:33:55 <joneshf-laptop> zed_, or you could use a different `Monad` with `Test.QuickCheck.Monadic`
10:34:17 <Geraldus_> geekosaur: I've set up locale in Docker file, so I'm not sure about reboot (:
10:34:21 <mauke> Geraldus_: apparently "dpkg-reconfigure locales" is how you do stuff
10:34:47 <zed_> joneshf-laptop: thanks for the suggestion, i'll look into it
10:35:01 <Geraldus_> mauke: I want not to depend on interactive config, because this is docker image, so I need some manual configuration
10:35:24 <Geraldus_> geekosaur: so I need to set env var LANG, right? 
10:35:29 <joneshf-laptop> zed_, but importantly, you don't have to roll your own stuff for everything
10:35:34 <geekosaur> [24 13:32:00]  <geekosaur>	 e.g. export LANG=C.UTF-8
10:36:07 <Geraldus_> yeah, I saw, ok, let me try!
10:36:08 <geekosaur> (I do not know if that will actually have the right collation, unfortunately. might need to use en_US.UTF-8 with the locales present on there)
10:36:24 <geekosaur> (or try to install more locales if you want e.g. a French locale)
10:36:38 <joneshf-laptop> zed_, and you get some interesting things like `frequency`and `listOf` for free
10:36:47 <geekosaur> the C and POSIX locales tend to be minimal
10:37:02 <joneshf-laptop> > generate $ vectorOf 3 $ choose (0, 1)
10:37:04 <lambdabot>  <IO [Integer]>
10:37:08 <joneshf-laptop> beh
10:37:50 <mauke> Geraldus_: looks like /etc/default/locale is supposed to contain something like LANG=en_US.UTF-8
10:38:48 <mauke> ah, and 'update-locale LANG=en_US.UTF-8' does that for you
10:39:54 <Geraldus_> mauke: cool, thanks!
10:42:20 <Geraldus_> geekosaur: I've tried `export LANG=en_US.UTF-8 ghci` and now `hGetContents` works fine! I need to rebuild docker image to make sure this will also fix compile-time read.
10:44:39 <Geraldus_> geekosaur, mauke: thank you pals!
11:09:31 * hackagebot mvc 1.0.5 - Model-view-controller  http://hackage.haskell.org/package/mvc-1.0.5 (GabrielGonzalez)
11:17:43 <newsham> haskell functions form the reader monad, and the "opposite" functions form a contravariant functor, right?   do Arrows also (in general) form similar functors and contravariant functors?
11:18:15 <newsham> (meant to also mention that reader == functor)
11:22:21 <staffehn> memoization
11:22:36 <staffehn> ah, no, meant to type in the search box
11:22:47 <monochrom> :)
11:25:53 <f|`-`|f> what?
11:25:53 <rotcetorptekcop> well, what is <> called?
11:25:57 <f|`-`|f> mappend
11:26:07 <mauke> wee-ooh
11:26:16 <f|`-`|f> Well
11:26:50 <f|`-`|f> Depends on what typeclass it is from. From Monoid, it's a Binary and Associative Function, I think
11:27:11 <f|`-`|f> Semigroup, it's a bit looser
11:28:09 <init> f|`-`|f: with a semigroup it's still binary and associativE
11:28:17 <f|`-`|f> o
11:28:28 <init> a monoid is a semigroup + identity element
11:28:33 <f|`-`|f> Yeah
11:30:22 <f|`-`|f> I suppose that's why AccumFailure is Semigroup
11:32:04 <newsham> do arrows form functors and contravariant functors?
11:33:21 <johnw> newsham: due to Haskell type system, that can be one or the other, but not both without a newtype wrapper
11:34:59 <newsham> you mean a wrapper like   OpArrow a c b =   OpArrow { unArrow :: Arrow a b c} ?
11:35:05 <johnw> yep
11:35:11 <tempname11_> is there a generic way to zip a nested list, and a flat list, preserving the structure of the former? i.e. something like "pseudoZipWith :: (a -> b -> c) -> [[a]] -> [b] -> [[c]]"
11:35:33 <newsham> so all arrows form a functor (a la the "reader" functor)?
11:36:00 <johnw> newsham: well, I guess not
11:36:07 <johnw> let me check
11:37:06 <johnw> because you could have an arrow a -> f b, where f is not a functor, but the Arrow instance still knows how to compose it -- even though it *could* be a Functor in that case
11:37:37 <newsham> tempname11_: how about   pseudoZip f xs ys = map (zipWith f ys) xs    ?
11:37:49 <johnw> also, arrows don't need to be functions, although Haskell Arrow is more restrictive due to 'arr'
11:39:23 <newsham> tempname11_: keep in mind that zipWith doesnt always preserve the shape
11:40:09 <newsham> johnw: i'm not sure i follow what you're saying..  it sounds like you're saying "no", though.
11:40:14 <tempname11_> newsham: unfortunately, not what I need. Let me show a simplistic example
11:40:22 <johnw> i'm saying that the answer depends on whether you mean functor or Functor
11:40:39 <newsham> instance Functor, I guess.
11:40:44 <johnw> then no
11:41:53 <newsham> kleisli arrows and functions both will be though, right?  any examples off the top of yur head of arrows that wouldnt be?
11:42:04 <johnw> Kleisli certainly will
11:42:08 <johnw> and functions, yes
11:42:18 <tempname11_> pseudoZip (,) [[1], [2,3]] ['a', 'b', 'c'] == [[(1,'a')], [(2, 'b'), (3, 'c')]]
11:42:24 <tempname11_> this is what I need
11:42:42 <newsham> temp: yah, you should be able to write such a thing
11:42:56 <staffehn> @let pseudoZipWith = \f a b -> zipWith (zipWith f) a $ splitPlaces (map length a) b
11:42:57 <lambdabot>  .L.hs:181:1:
11:42:57 <lambdabot>      Multiple declarations of ‘pseudoZipWith’
11:42:57 <lambdabot>      Declared at: .L.hs:179:1
11:43:09 <staffehn> @let pseudoZipWithStaffehn = \f a b -> zipWith (zipWith f) a $ splitPlaces (map length a) b
11:43:11 <lambdabot>  Defined.
11:43:23 <staffehn> > pseudoZipWithStaffehn (,) [[1], [2,3]] ['a', 'b', 'c'] == [[(1,'a')], [(2, 'b'), (3, 'c')]]
11:43:25 <lambdabot>  True
11:43:45 <tempname11_> staffehn: nice. now I need to decipher it :)
11:43:46 <newsham> is there a zip over tranversables?
11:44:10 <staffehn> @pl (\f a b -> zipWith (zipWith f) a $ splitPlaces (map length a) b)
11:44:11 <lambdabot> (`ap` (splitPlaces . map length)) . ((.) .) . zipWith . zipWith
11:44:24 <staffehn> haha
11:44:55 <newsham> > let f a b = splitPlaces (map length a) b in f [[1],[2,3]] "abc"
11:44:57 <lambdabot>  ["a","bc"]
11:45:36 <newsham> ?hoogle splitPlaces
11:45:37 <lambdabot> No results found
11:46:12 <Myrl-chan> @pl (\x y z -> z y x)
11:46:12 <lambdabot> flip (flip . flip id)
11:46:13 <staffehn> lol
11:46:19 <staffehn> https://hackage.haskell.org/package/split-0.1.1/docs/Data-List-Split.html
11:46:22 <newsham> i should prob use the split package some day :)
11:47:02 <staffehn> Newer Version... https://hackage.haskell.org/package/split-0.2.2/docs/Data-List-Split.html#v:splitPlaces
11:48:07 <newsham> > splitPlaces [1,2,3,4,5] "testing"
11:48:10 <lambdabot>  ["t","es","tin","g"]
11:49:16 <Hafydd> > splitPlaces [2,1] "abc"
11:49:18 <lambdabot>  ["ab","c"]
11:49:33 * hackagebot stm-conduit 2.6.1 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-2.6.1 (ClarkGaebel)
11:49:54 <mauke> > splitPlaces [1..] ['a' ..]
11:49:56 <lambdabot>  ["a","bc","def","ghij","klmno","pqrstu","vwxyz{|","}~\DEL\128\129\130\131\13...
11:50:19 <newsham> i just wanted to see what happens if it exhausts input
11:51:23 <staffehn> > > pseudoZipWithStaffehn (,) [[1..]] ['a'..]
11:51:25 <lambdabot>  <hint>:1:1: parse error on input ‘>’
11:51:29 <staffehn> > pseudoZipWithStaffehn (,) [[1..]] ['a'..]
11:51:34 <lambdabot>  mueval: ExitFailure 1
11:51:58 <staffehn> yeah, it doesn't like infinite lists in the list of lists
11:52:26 <staffehn> possibly fixable with lazy naturals...
11:53:02 <newsham> or you could just define the zip with recursion without using "length"
11:56:01 <staffehn> you can always define things yourself.. thats not the point ;P
11:58:34 <unknownloner> Is there somewhere I can read about where someone might use conduit vs pipes
11:58:58 <unknownloner> like why you might choose one over the other
11:59:56 <vandenoever> unknownloner: or even streams okmij.org/ftp/Streams.html
12:00:18 <newsham> staffehn: but sometimes its actually simpler :)
12:00:47 <Haskellfant> unknownloner: there is a haskell cast episode with  michael snoyman (conduit) and gabriel gonzales (pipes)
12:01:00 <Haskellfant> http://www.haskellcast.com/episode/006-gabriel-gonzalez-and-michael-snoyman-on-pipes-and-conduit/
12:01:08 <newsham> http://pastebin.com/Z597MRbf
12:02:52 <newsham> works fine on infinite inputs
12:03:33 <johnw> unknownloner: conduit is if you want convenience, pretty much; pipes is if you want more descriptive types and the better correctness guarantees that comes with them
12:05:09 <johnw> unknownloner: I'm a user of both of them, if you have specific questions
12:05:48 <newsham> is there a generic way to do this kind of zip over arbitrary structured data?
12:05:56 <newsham> like functors or traversables or something?
12:07:46 <staffehn> newsham, what should it do when the lengths are different?
12:07:54 <ion> > let alongside f x = f x <$> shift; shift = do { x:xs <- get; x <$ put xs } in evalState ((traverse . traverse) (alongside (,)) ["hello", "foo", "42"]) [0..]. -- or evalStateT for Maybe if the layer list may be too short *and* the former list is finite
12:07:56 <lambdabot>  <hint>:1:252:
12:07:56 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
12:08:14 <newsham> staffehn: hmm.. shape changing... 
12:08:25 <newsham> i guess you could always "error" if you exhaust the list
12:08:26 <ion> > let alongside f x = f x <$> shift; shift = do { x:xs <- get; x <$ put xs } in evalState ((traverse . traverse) (alongside (,)) ["hello", "foo", "42"]) [0..]
12:08:28 <lambdabot>  [[('h',0),('e',1),('l',2),('l',3),('o',4)],[('f',5),('o',6),('o',7)],[('4',8...
12:08:33 <staffehn> newsham, shape changing is not very generic
12:08:57 <newsham> if you forbid shape changing though, should be able to pair up a sequence with any traversable data, no?
12:09:08 <staffehn> newsham, with an error that should be possible on traversible.. let me try something out..
12:09:11 <newsham> just error on exhaustion (or require the sequence to be infinite)
12:09:48 <ion> s/layer/latter/
12:10:56 <newsham> and since you can convert any traversable into a sequence, you could then zip together different shaped traversables... 
12:10:59 <newsham> hrmmm
12:11:48 <newsham> (as long as the one you kept the shape of was "shorter" than the other one)
12:16:14 <ion> Does anyone know of an Android on-screen keyboard that makes typing Haskell code especially convenient? This is doable but a bit of a pain with the standard ones.
12:17:47 <staffehn> newsham: http://lpaste.net/133268
12:18:58 <indiagreen> ion: HackerKeyboard, perhaps
12:19:01 <fvgvxmpv1> does somebody have a parser for bool expressions such as this one: a or (b and not c) handy?
12:19:06 <fvgvxmpv1> In attoparsec
12:19:16 <indiagreen> * Hacker's Keyboard
12:19:52 <staffehn> newsham, wait, there's a bug..
12:20:27 <staffehn> newsham: oh, no bug, but [[a]] has a different traversable instance..
12:20:29 <vandenoever> Haskellfant: nice cast, thanks for the link
12:20:56 <Haskellfant> vandenoever: I can recommend listening to all the old episodes :)
12:21:58 <andorp> Hi, I need some help with Network.Curl and PUT, could someone help me? 
12:22:12 <Haskellfant> andorp: just ask your question :)
12:23:21 <andorp> when I do PUT the curl send an "Expect: 100 continue" header, I would like to remove that somehow from the PUT request
12:24:13 <ion> indiagreen: Thanks, but its symbol key pages are more or less similar to the ones in the Google keyboard. I was hoping for something with a special page of keys for often-used keywords or something like that.
12:24:47 <staffehn> newsham: here you go, http://lpaste.net/133268
12:25:24 <newsham> very cool.  yah, i ran it over list, listlist and tree :)
12:25:33 <tempname11_> staffehn: or we could use mapAccumLOf from lens :)
12:26:00 <newsham> how come this zip isnt predefined in traversable? :)
12:26:50 <andorp> but when I do a manual curl expect header is not present in the PUT request
12:27:47 <tempname11_> also, instead of an 'error' I'd prefer a Maybe in the type. going to try and write that now
12:27:53 <staffehn> tempname11_, prabably true, but I don't know Lens really well, and in this case GHC could generate our Traverseable instance for us :)
12:28:28 <nocturne777> let's say we have something like this: newtype Query a = Query (ReaderT Window X a)
12:28:46 <nocturne777> is it a good practice to not export value constructor in this case?
12:29:01 <Cale> nocturne777: Generally.
12:29:15 <nocturne777> to not expose the fact that we are dealing with ReaderT
12:29:16 <newsham> you can always use this to zip with things that are too short:  makeInfinite [] = repeat Nothing; makeInfinite (x:xs) = Just x : makeInfinite xs   
12:29:45 <Cale> nocturne777: Right, instead you'd rather expose enough things that nobody has to care how your Query monad is actually defined.
12:30:02 <newsham> (or even use "cycle")
12:31:55 <ion> > ["hello", "foo", "42"] & partsOf (traverse . traverse) %~ zip [0..]
12:31:57 <lambdabot>      Couldn't match type ‘(Integer, Char)’ with ‘Char’
12:31:57 <lambdabot>      Expected type: [Char] -> [Char]
12:31:57 <lambdabot>        Actual type: [Char] -> [(Integer, Char)]
12:32:57 <ion> > ["hello", "foo", "42"] & unsafePartsOf (traverse . traverse) %~ zip [0..]
12:32:59 <lambdabot>  [[(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')],[(5,'f'),(6,'o'),(7,'o')],[(8,'4'...
12:34:53 <Vektorweg1> hmm. i wanted to initialize a new cabal package on windows and it failed asking for git. is cabal depending on git or is this just a bad joke? 
12:35:09 <tempname11_> ion: that's amazing... except the 'unsafe' part :))
12:39:45 <ion> tempname11: It's unsafe wrt. the behavior if the [0..] is too short.
12:46:01 <staffehn> newsham, tempname11_: one can even generalize further: http://lpaste.net/133270
12:46:37 <staffehn> then pseudoZipWith2 would also work as :: (a -> b -> c) -> [[a]] -> [b] -> [[c]]
12:47:22 <f|`-`|f> what is going on
12:47:57 <tekemperor> Can haskell be uses as a server-side language from apache and talk to an MSSQL database?
12:50:25 <refefer> tekemperor: 'from apache'
12:50:34 <refefer> do you mean to integrate with an apache server?
12:51:21 <ion> tekemperor: A quick search seems to indicate MSSQL connectivity is possible. The nicest way to run pretty much any service in any language is to have your program serve HTTP and have Apache or equivalent proxy requests to it.
12:52:36 <tekemperor> refefer: probably.
12:52:44 <tekemperor> ion: thanks.
12:53:55 <tekemperor> I know very little about ruby and haskell, I wrote a couple quick scripts in the for college, but that was a while ago.  I'm wondering if either is a significantly better choice than php which I already used for previous projects.
12:54:32 <tekemperor> ion: if I do that, does that mean I could switch to enginx without any significant effort?
12:55:45 <ion> tekemperor: Yes
12:56:04 <ion> At least as far as the Haskell service is concerned
12:56:40 <tekemperor> Cool, thansk.
12:57:12 <maerwald> tekemperor: haskell is a "general purpose" high level language so pretty much any question starting with "can haskell be used for..." will be answered with yes
12:57:43 <maerwald> whether there are already libraries for a specific use case is a different thing
12:57:55 <andorp> I found the problem and the solution: http://sourceforge.net/p/curl/bugs/1349/ and ... ((CurlPost True):(CurlPostFields [payload]):(CurlCustomRequest "PUT") ... the ugly hack for it :D
13:00:09 <ion> tekemperor: Ruby is not as bad as PHP in bad design decisions but it is still a dynamically typed language, so you lack certain statically checked guarantees about your code. In the grand space of programming languages, Ruby is much closer to PHP than Haskell. Knowing PHP, learning Ruby will be much easier for you than learning Haskell. Making the effort will be rewarding though.
13:01:18 <hectortrope> hello guys can Rust language replace haskell??
13:02:35 <voidzero> mu
13:02:39 <maerwald> hectortrope: I find it hard to follow that thought, it's like asking if bananas could replace apples
13:03:26 <voidzero> When the Zen monk Joshu [= Chao-Chou] was asked whether a dog had a Buddha nature he said "Mu," meaning that if he answered either way he was answering incorrectly. The Buddha nature cannot be captured by a yes or no question.
13:03:48 <voidzero> also
13:03:50 <voidzero> https://en.wikipedia.org/wiki/Mu_(negative)
13:04:49 <zed_> Hi everyone : ) So I rewrote a pi simulation in Haskell ( from C ) and it compiles, except it doesn't give me pi as a result, nor something "close enough" to it... I am try to check if it is because my code isn't doing what I think it is doing. Could someone please look over it ?
13:04:56 <zed_> link : http://paste.ofcode.org/7AR537LFhrpBwtFbRpcqqa
13:04:59 <ion> tekemperor: Take refactoring for example. When you change a data structure in your code, anything using that data structure will not compile until it has been updated to match. With a dynamically typed language you will only receive those errors at runtime *if* you happen to execute all the relevant code paths. You better hope your tests do.
13:06:45 <alexv19> Can this be done simpler? 
13:06:48 <alexv19> f :: Maybe a -> (a -> IO b) -> IO (Maybe b)
13:06:51 <alexv19> f x g = runMaybeT (liftIO . g =<< hoistMaybe x)
13:07:04 <f|`-`|f> what is Rust?
13:07:31 <init> f x f = maybe (return Nothing) f x 
13:07:44 <init> @type \x f -> maybe (return Nothing) f x 
13:07:46 <lambdabot> Monad m => Maybe a -> (a -> m (Maybe a1)) -> m (Maybe a1)
13:08:34 <f|`-`|f> question is, does it have the same effect
13:08:44 <ij> Can I use nix to govern packages while on arch?
13:08:49 <maerwald> f|`-`|f: one of those "multi-paradigm" languages that mix everything together and make every aspect worse
13:09:01 <ion> @type traverse `asTypeIn` \f -> f (a -> IO b) (undefined :: Maybe a)
13:09:02 <lambdabot> Pattern syntax in expression context: a -> IO b
13:09:21 <f|`-`|f> how does haskell ot do that?
13:09:22 <ion> @type traverse `asTypeIn` \f -> f (undefined :: a -> IO b) (undefined :: Maybe a)
13:09:23 <lambdabot> (a -> IO b) -> Maybe a -> IO (Maybe b)
13:10:54 <f|`-`|f> s/ot/not/
13:10:54 <rotcetorptekcop> f|`-`|f meant: how does haskell not do that?
13:12:31 <maerwald> I have no idea what this is about
13:14:21 <f|`-`|f> how does haskell not make each aspect worse
13:14:50 <maerwald> mu
13:15:34 <alexv19> ion: Thanks!
13:18:54 <tempname11_> zed_: are you trying some kind of a monte carlo method? can you show the reference code that is actually working?
13:19:17 <zed_> tempname11_: well thanks but I just found my mistake and it is working
13:19:44 <ion> zed: Out of curiosity, what was the mistake?
13:20:17 <zed_> I do not need to negate, it's in the theory of how you do the simulation, not in Haskell
13:20:47 <zed_> I mean, the mistake is a theoretical one, not a Haskell one : )
13:22:10 <tempname11_> zed_: I guess you negated twice because of 'map (1-)' ?
13:22:29 <zed_> tempname11_: Exactly. 
13:30:31 <rhaps0dy> don't be so quick to throw out Rust just yet
13:30:40 <rhaps0dy> I haven't tried it, but what would you use if you need to manage memory?
13:31:14 <rhaps0dy> right now C++ is about the only option
13:31:44 <alynn> C
13:32:09 <alynn> http://www.poppyfields.net/filks/00259.html
13:32:41 <rhaps0dy> lol
13:33:41 <rhaps0dy> nice song, but I appreciate object-orientation
13:34:08 <alynn> C has structs!
13:34:16 <rhaps0dy> Right.
13:34:19 <rhaps0dy> That also counts :)
13:34:21 <alynn> I've spent too long around hardware people, they really believe this stuff :(
13:34:30 <Geraldus_> geekosaur: hey! I've finally rebuilt docker image! And locale set to UTF-8 resolves issue with quasi-quoter
13:34:35 <rhaps0dy> that C is the end all be all?
13:34:39 <rhaps0dy> I used to believe that too
13:34:40 <alynn> yup
13:34:49 <rhaps0dy> but I got better
13:35:23 <alynn> did you follow the 12-step programme?
13:35:29 <rhaps0dy> huh?
13:35:31 <rhaps0dy> What's that?
13:35:34 <Geraldus_> mauke: hey. I've added `update-locale …` to my Dockerfile. Now I see correct contents of /etc/default/locale, however `locale` command itslef still shows me POSIX everywhere. 
13:36:08 <alynn> the usual route for recovering from C as prescribed by C Programmers Anonymous
13:36:23 <rhaps0dy> alynn, please do link
13:36:33 <rhaps0dy> that sounds fun
13:36:59 <geekosaur> C ctinks :p
13:37:20 <alynn> C is great, it's so clean and simpSegmentation fault
13:37:45 <geekosaur> (it was a great improvement over Microsoft microcomputer BASIC, but what isn't?)
13:38:06 <rhaps0dy> lmao
13:38:25 <alynn> geekosaur: fascist dictatorships
13:39:03 <FreeFull> But, why not Pascal
13:39:49 <maerwald> alynn: IF you get a segfault, then you are kind of lucky
13:39:53 <ion> Why not Zoidberg?
13:40:07 <maerwald> you could just read random memory junk and move on without noticing :P
13:41:14 <maerwald> or try to wrap your head around those 3000 valgrind errors gtk+ is causing
13:42:36 <monochrom> the beauty of C pointer errors is that they corrupt the heap so the segfault you get is from malloc or free 10 minutes later
13:42:47 <alynn> my favourite C debugging was code along the lines of if (foo == null) { ..do stuff.. } else { printf("%s\n", foo); }
13:42:51 <alynn> which was printing null
13:43:07 <monochrom> at which point all the world's coredump and gdb will not be useful
13:43:21 <rhaps0dy> Look what I found near "Write in C"
13:43:22 <rhaps0dy> https://www.youtube.com/watch?v=Mk3qkQROb_k
13:43:40 <alynn> turned out the compiler had decided that the last function call in "do stuff" could never return
13:43:44 <alynn> and had deleted the jump to after the if
13:43:54 <alynn> then the last function call did return and it fell through
13:43:57 <rhaps0dy> lol 
13:44:25 <alynn> I code in haskell and python now
13:44:27 <alynn> I don't miss C
13:44:57 <rhaps0dy> good riddance
13:44:58 <alexv19> Can I define a lens for an existentional type? This doesn't seem to work:
13:45:08 <alexv19> data A where     A :: forall a. Storable a => VS.Vector a -> Int -> A
13:45:11 <alexv19> xs :: forall a. Storable a => Lens' A (VS.Vector a)
13:45:14 <alexv19> xs f (A v i) = fmap (\x -> A x i) (f v)
13:45:42 <johnw> how would you ever use that vector anyway?
13:45:54 <johnw> oh, hmm
13:45:56 <tempname11_> can I use 'where' inside a 'let' inside do notation? I can't seem to, and it drive me nuts :/
13:46:08 <alexv19> take it lenght for instance
13:46:53 <monochrom> tempname11_: I can. with correct indentation.
13:47:39 <tempname11_> monochrom: can you paste some code? I think I've tried all possbilities of indentation
13:48:08 <FreeFull> alynn: Why did it decide the last function couldn't return?
13:48:22 <Guest87232> @unmtl WriterT String (StateT s Identity) a
13:48:22 <lambdabot> (StateT s Identity) (a, String)
13:48:46 <alynn> FreeFull: compiler bug
13:48:48 <arkeet> > let x = y where y = 5 in x -- tempname11_
13:48:50 <lambdabot>  5
13:49:16 <alynn> FreeFull: the function in question did have some dark inline asm magic, in clang's defence
13:49:56 <Guest87232> @unmtl Reader e (ErrorT err (StateT s Identity)) a
13:49:56 <lambdabot> Plugin `unmtl' failed with: `e -> (ErrorT err (StateT s Identity))' is not a type function.
13:50:14 <Guest87232> @unmtl ReaderT e (ErrorT err (StateT s Identity)) a
13:50:14 <lambdabot> e -> (ErrorT err (StateT s Identity)) a
13:50:16 <tempname11_> arkeet: thanks, but I mentioned 'inside do notation'
13:50:19 <lpaste> monochrom pasted “do-let-where example” at http://lpaste.net/133271
13:50:26 <tempname11_> I know it's just sugar, but...
13:50:26 <zed_> if you had to generate a number from a binomial distribution, which package would you use and why ?
13:50:31 <monochrom> tempname11_: like that
13:50:38 <arkeet> oh
13:50:42 <arkeet> same thing
13:50:44 <arkeet> without the in
13:50:52 <FreeFull> alynn: Ah
13:51:09 <arkeet> tempname11_: important thing is that 'where' is indented further than 'x'
13:51:10 <FreeFull> alynn: Compiler bugs are the second worst. Hardware bugs are the worst
13:51:14 <tempname11_> monochrom: thanks, trying it in my code...
13:51:23 <FreeFull> Because you assume the compiler and hardware will work, and that if something breaks, it's your code's fault
13:51:41 <arkeet> otherwise it thinks 'where' is the start of a new declaration
13:52:27 <alynn> FreeFull: I did see a rather good blog post a few years ago from someone who was debugging a crash in... some common CLI tool
13:52:29 <tempname11_> arkeet: further than 'abcdefg' would mean, further than 'a', or further than 'g' ?
13:52:32 <alynn> I think it was either ls or curl
13:52:40 <monochrom> further than 'a'
13:52:42 <FreeFull> alynn: I think I've seen that blog post too
13:52:47 <alynn> eventually tracked it down to a bit being flipped in the FS cache by a cosmic ray
13:53:07 <monochrom> for example if 'w' is under 'b' it is ok
13:53:12 <tempname11_> monochrom: weird. I am doing that. maybe I'm missing something. let me double-check
13:53:21 <arkeet> tabs?
13:53:22 <rotcetorptekcop> tabs are really something that should have died in the 20th century
13:53:26 <monochrom> then the cause is elsewhere
13:53:39 <arkeet> tabs?
13:53:40 <FreeFull> alynn: Yep, and the solution was flushing the fs cache
13:53:40 <rotcetorptekcop> tabs are really something that should have died in the 20th century
13:53:43 <arkeet> lol
13:54:19 <mauke> rotcetorptekcop: huh?
13:54:25 <arkeet> bot
13:54:37 <mauke> rotcetorptekcop: status
13:54:38 <rotcetorptekcop> Since Fri May 22 22:53:29 2015, there have been 2405 modifications, 53 questions, 0 dunnos, 0 morons and 7 commands.  I have been awake for 1d 22h 47s this session, and currently reference 2456 factoids.  I'm using about 178292 kB of memory. With 0 active forks. Process time user/system 1969.49/20.47 child 0/0
13:54:42 <mauke> ah, an infobot
13:54:45 --- mode: ChanServ set +o mauke
13:54:46 --- kick: rotcetorptekcop was kicked by mauke (rotcetorptekcop)
13:54:55 --- mode: mauke set +b $a:pocketprotector
13:54:56 * monochrom supports the ban
13:55:02 <Guest87232> @unmtl ReaderT [String] (ErrorT String (StateT Int Identity)) String
13:55:02 <lambdabot> [String] -> (ErrorT String (StateT Int Identity)) String
13:56:59 --- mode: mauke set -o mauke
13:58:52 <tempname11_> monochrom: yep, all good!
13:58:55 --- mode: ChanServ set +o monochrom
13:58:58 --- mode: monochrom set -o monochrom
13:59:39 <tempname11_> arkeet: thanks as well
14:08:23 <alynn> so a quick question since mtl was mentioned
14:09:00 <alynn> can anyone think of similarly good examples to type Parser = StateT String Maybe for building useful structures out of mtl stacks that aren't immediately obvious?
14:09:15 <alynn> for use as examples when talking about the applications of monad transformers
14:10:02 <c_wraith> alynn: http://blog.jle.im/entry/unique-sample-drawing-searches-with-list-and-statet
14:12:22 <alynn> c_wraith: that's neat
14:12:27 <c_wraith> I thought so
14:13:16 <c_wraith> alynn: In fact, I thought it was so neat, I wrote a follow-up.  https://www.fpcomplete.com/user/chowells79/even-more-money  :)  (I still need to figure out part 2 of that)
14:14:40 <ReinH> jle`: nice one
14:15:54 <vandenoever> i guess lens is the xpath of haskell
14:16:27 <c_wraith> vandenoever: pretty much.
14:16:54 <c_wraith> vandenoever: especially when you take into account multilevel traversals like deep from Control.Lens.Plated
14:17:17 <ReinH> That and much more
14:17:38 <vandenoever> i was wondering if haskell could be a type-safe xslt
14:17:50 <alynn> hxt is arguably the xpath of haskell :P
14:17:57 <ReinH> c_wraith: it seems like Cale's select function or some other similar comonadic approach could be useful there
14:18:00 <vandenoever> which would require generating haskell from xsd/dtd/rng
14:18:24 <c_wraith> ReinH: the select function is a part of both my code and Justin Le's.  (It's a pretty obvious function for a bunch of use cases)
14:18:35 <ReinH> c_wraith: Oh I guess I should finish the articles :)
14:18:46 <ReinH> :t select
14:18:48 <lambdabot> Not in scope: ‘select’
14:18:55 <ReinH> @let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
14:18:57 <lambdabot>  Defined.
14:19:30 <alynn> :t select
14:19:31 <lambdabot> [t] -> [(t, [t])]
14:19:38 <c_wraith> :t StateT select
14:19:39 <lambdabot> StateT [a] [] a
14:19:45 <f|`-`|f> what
14:19:50 <ReinH> @unmtl StateT [a] [] a
14:19:50 <lambdabot> [a] -> [] (a, [a])
14:19:52 <ReinH> :)
14:19:55 <f|`-`|f> ??????
14:20:31 <geekosaur> same type
14:20:51 <f|`-`|f> @help @unmtl
14:20:51 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:20:52 <alynn> StateT [a] [] is also a monad for parsers on strings of a
14:20:59 <f|`-`|f> @help unmtl
14:20:59 <lambdabot> unroll mtl monads
14:21:05 <f|`-`|f> mtl
14:21:14 <Cale> Monad transformer library
14:21:19 <ReinH> Cale: hi :)
14:21:19 <f|`-`|f> o
14:21:23 <Cale> hi
14:21:32 <alynn> except giving you all parses where it's ambiguous
14:21:34 <geekosaur> most of the monads defined in mtl are wrappers for simpler types
14:21:46 <f|`-`|f> o
14:21:59 <geekosaur> State is a tuple, Writer is a monoid, Reader is function application
14:22:19 <Cale> StateT over [] is one application of StateT I won't actually complain about :)
14:22:31 <geekosaur> and @unmtl shows you what it "desugars" to
14:22:32 <ReinH> :)
14:22:33 <alynn> I wonder how StateT select could be interpreted in parsing
14:23:05 <c_wraith> StateT is the constructor of the StateT type
14:23:32 <f|`-`|f> I'm still stuck on State.hs in NICTA
14:23:38 <c_wraith> So it's just function application
14:23:49 <f|`-`|f> So more or less
14:23:52 <Cale> alynn: Well, usually parsers obey the convention that they only eat from the beginning of the input.
14:24:07 <f|`-`|f> Do not care about the (a,s), just care about the a? cal
14:24:10 <f|`-`|f> Cale  
14:24:27 <Cale> Wait, what is the question?
14:25:10 <alynn> Cale: aye
14:25:12 <f|`-`|f> I don't know how to deal with State Monad in Nicta, other than not giving a toss about (<$>) f ((State s) a)
14:25:45 <f|`-`|f> just apply it to a?, and if I'm passed an f a = \s -> (f a, s), don't care?
14:26:07 <Cale> That expression looks very ill-typed. I don't know what stuff nicta refers to.
14:26:27 <f|`-`|f> NICTA is more or less define the patterns yourself, eg (<$>) for a few functors
14:26:42 <f|`-`|f> the State section is defining the Typeclasses seen before for State s
14:26:48 <Cale> The State data constructor has type (s -> (a,s)) -> State s a
14:27:21 <Cale> So you apply it to a function (usually in the places where you're likely to be applying it directly, you want this function to be a lambda)
14:27:22 <f|`-`|f> But it only gives the type signature for runState
14:27:47 <Cale> The type of State is implied by the newtype declaration.
14:29:19 <Cale> If I knew what you were trying to write, I might be able to give more detailed help.
14:29:39 * hackagebot feed 0.3.9.5 - Interfacing with RSS (v 0.9x, 2.x, 1.0) + Atom feeds.  http://hackage.haskell.org/package/feed-0.3.9.5 (AdamBergmark)
14:29:45 <ReinH> runState is the field accessor for the State newtype, so ofc it has that type
14:30:11 * f|`-`|f shrugs
14:30:48 <ReinH> Well, runState has the opposite type: State s a -> a -> (a, s), since it unwraps the newtype
14:30:54 <ReinH> :t runState
14:30:55 <lambdabot> State s a -> s -> (a, s)
14:31:01 <vandenoever> is there  a way to write more compact adts? e.g. data A = A Int\n data B = B String \n; data C = A | B     ?
14:31:18 <geekosaur> that looks wrong to me
14:31:19 <ReinH> vandenoever: you can't write that anyway
14:31:23 <ReinH> well, you can
14:31:32 <f|`-`|f> :t State
14:31:33 <vandenoever> but it wont compile :-P
14:31:33 <lambdabot>     Not in scope: data constructor ‘State’
14:31:33 <lambdabot>     Perhaps you meant one of these:
14:31:33 <lambdabot>       ‘StateT’ (imported from Control.Monad.State),
14:31:36 <Cale> vandenoever: A and B are already used
14:31:37 <f|`-`|f> ech
14:31:46 <ReinH> No, you can't, since you're trying to reuse A and B
14:32:10 <ReinH> You need, e.g., data C = CA A | CB B
14:32:20 <vandenoever> ReinH: yeah, that's what i'm doing
14:32:25 <Cale> vandenoever: that declaration of C is a valid declaration, but it defines a type which is similar to Bool, in that it has two nullary data constructors
14:32:49 <ReinH> It's valid, but can't exist in the same namespace as types A and B
14:33:03 <Cale> right
14:33:19 <vandenoever> the issue i'm having is that i try to make haskell representation of some xml schema
14:33:33 <ReinH> vandenoever: Abandon the idea of writing C the way you suggest :)
14:33:39 <Cale> You can't reuse the same name for a data constructor for multiple types in the same module, and if you put them in separate modules, you'll be forced to qualify your names, which is kind of annoying :)
14:33:41 <ReinH> It's not possible
14:33:56 <ReinH> Cale: I think the idea is for C to embed types A and B
14:33:59 <f|`-`|f> hmmm
14:34:01 <ReinH> and Haskell can't do that
14:34:19 <vandenoever> e.g. <c><a/><b/><a/></c> would have some type 'data C = C [Cchild] \n data Child = C_A A | C_B B'
14:34:19 <Cale> Well, it *can* do that, you just have to write what you wrote :)
14:34:32 <ReinH> Cale: well, fsvo "embed", it can't, but yes
14:34:49 <vandenoever> which is an extra type and extra layer wrapping i'd like to avoid
14:34:59 <ReinH> vandenoever: so don't write data A or data B
14:35:05 <vandenoever> maybe Cchoice is a better name than Cchild
14:35:19 <vandenoever> ReinH: they are complex elements in their own right
14:35:23 <staffehn> Can anybody help me get rid of this "Functional dependencies conflict": https://bpaste.net/show/85b7ffbd1512
14:35:25 <geekosaur> there are some xml dtd compilers on hackage, aren't there?
14:35:31 <ReinH> You can put complex elements in a sum type
14:35:49 <vandenoever> geekosaur: there's XsdToHaskell which uses the verbose approach
14:35:50 <ReinH> data Foo = Foo A B C | Bar D E F, whatever
14:36:17 <Cale> There needs to be a data constructor saying which of A and B you have, because types don't exist at runtime. If GHC went ahead and allowed you just to use a value of type A or a value of type B as a value of type C, you'd get segfaults and nonsense like that, because you'd have no way to tell whether the thing you were about to extract data from was actually of type A or of type B.
14:36:40 <ReinH> "UndecidableInstances" o_O
14:37:08 <vandenoever> Cale: yes, the pattern maching would need to have access to the type somehow
14:37:13 <ReinH> When GHC tells you that you need UndecidableInstances, it's really telling you to question the life choices that brought you to there. ;)
14:37:24 <vandenoever> ReinH: :-)
14:38:07 <Cale> staffehn: Those instances overlap when a = t1 t2a
14:38:31 <Cale> Well, they disagree about which type t should be
14:38:49 <vandenoever> i guess i'm too used to the overloading in c++
14:39:02 <Cale> Do you see what I mean?
14:39:29 <staffehn> Cale: yea, but is it possible to exclude that case?
14:40:13 <Cale> Not easily, with these instances...
14:40:19 <Cale> But what are you trying to do here?
14:41:27 <Cale> Perhaps you'd rather avoid type classes altogether in this case
14:41:34 <staffehn> I actually forgot the most important class constraint... doesn't change the problem: https://bpaste.net/show/a005eacd9ded
14:41:34 <staffehn> like that.
14:41:48 <Cale> Usually if you find yourself wanting to write instances which are this polymorphic, the correct thing is not to have a type class at all.
14:42:12 <Cale> Instances of type classes should be matching on specific type constructors
14:43:01 <Cale> Here, you're sort of picking a specific type constructor as a "result" of the functional dependency, but the type arguments to the instance are not otherwise very constrained.
14:44:25 <staffehn> The goal is that ta is a Stack of Traversables, like (q (r (s (t a)))), where q,r,s,t are Traversable instances..
14:44:46 <jibi> hi, I'm try to model a chessboard in Haskell, and I came up with two (working) solutions, but I don't know what is the best/advised/pragmatic
14:44:57 <jibi> http://sprunge.us/cDUj?hs http://sprunge.us/FiFC?hs and these are the two solutions
14:45:13 <ReinH> jibi: it depends very much on what you are doing with the chessboard
14:46:39 <staffehn> Cale: Then if you know some type a, you should get a coercion from (q(r(s(t a)))) to (Stack q (Stack r (Stack s (Stack t Identity)))) a
14:46:39 <osa1_> does anyone know any library/base module that exports this: (a -> a') -> (b -> b') -> Either a b -> Either a' b' ?
14:46:39 <jibi> ReinH, at the moment I don't know what it'll become
14:46:39 <jibi> I'm just playing with haskell
14:46:39 <ReinH> jibi: The second is better than the first
14:46:39 <f|`-`|f> Alright that was my most major issue, Cale , "What the hell is State"
14:46:39 <ReinH> but position is not an intrinsic property of pieces
14:46:39 <jibi> with the second solution I can store pieces specific information
14:46:39 <ReinH> and treating it as such will not work very well
14:46:44 <jibi> oh, ok
14:46:47 <ReinH> with this representation it is easy to say "what position is a black kind on?", but that's not a question you ever ask
14:46:51 <staffehn> Cale: if you wouldn't have a, but (s (t a)) for example, you should get a funciton from (q (r (s (t a)))) to (Stack q (Stack r Identity)) (s (t a))
14:46:59 <ReinH> it's hard to say "what piece is on e4?", and that's the question you ask all the time
14:47:00 <jibi> and so it is color then
14:47:04 <f|`-`|f> Since Nicta gives "State { runState :: s -> (a,s)}"
14:47:10 <ReinH> data Piece = Piece Kind Color
14:47:18 <ReinH> is basically what I used
14:47:30 <ReinH> and you can have, e.g., Map (Row, Col) Piece
14:47:35 <ReinH> which works reasonably well
14:47:46 <ReinH> until you need more performance and you turn to, e.g., bitboards
14:48:03 <ReinH> er, Map Point Piece
14:48:43 <staffehn> Cale: I'll probably try type Families next then..
14:48:43 <ReinH> jibi: so I'd say use data Piece = Piece Kind Color and use a map of pieces to represent the board as a reasonable first approximation
14:48:54 <Cale> staffehn: Maybe just try data
14:49:05 <muzzle> hi, what does it mean, when in the heap profile it says e.g. 1GB of [] has been allocated ? That just the _:_ data constructors take up 1GB of heapspace ?
14:49:06 <jibi> ReinH, ok, so you're advising the first solution
14:49:13 <ReinH> jibi: No, I don't think so
14:49:13 <Cale> staffehn: Here, I'll write what I mean.
14:49:27 <ReinH> Not the one that is data Piece = King Color | Queen Color | ...
14:49:49 <jibi> the one with data Piece = Piece { kind :: }
14:49:52 <ReinH> jibi: here's what I used https://github.com/haskelllive/haskelllive/blob/master/Chess.hs#L41-L43
14:50:25 <jibi> ok
14:52:34 <lpaste> Cale pasted “good ol' functional programming instead of classes?” at http://lpaste.net/133274
14:53:54 <Cale> I still don't really understand what the point of this stuff is, but this version actually works...
14:54:21 <Cale> I also don't really understand what it has to do with stacks.
14:54:35 <Cale> I would call what you called Stack "Compose" or "Composite"
14:55:16 <staffehn> cale: I thought about the naming for like 1 second, sure Compose would be better
14:55:25 <ReinH> Cale: needs more rank-2 types...
14:55:41 <muzzle> Are there any good resources on performance when it comes to monads ?
14:55:42 <Cale> Does it?
14:55:55 <ReinH> newtype Stack s t = Stack (forall a. s (t a)) ?
14:56:07 <Cale> uhhh
14:56:15 <Cale> Well, that would be quite different
14:56:24 <ReinH> Yes, but I don't understand this version
14:56:38 <Cale> Did you understand staffehn's?
14:56:57 <ReinH> I mean, I understand it as written, but I don't understand the need for it
14:57:06 <Cale> (because I didn't really understand staffehn's, I just translated his code, getting rid of the instances, and replacing them with values)
14:57:19 <staffehn> I'm also still trying to read through Cales version..
14:57:23 <ReinH> Also there's always Data.Functor.Compose
14:57:31 <f|`-`|f> god damn
14:57:41 <ReinH> Cale: anyway, is the composition of two traversables a traversable?
14:57:50 <staffehn> Yes
14:57:53 <c_wraith> Compose has a third type parameter.  I'm not sure what that version of stack is supposed to do with the quantificationn there.
14:57:53 <ReinH> I suppose so
14:57:59 <Cale> I don't know
14:58:01 <staffehn> It can even derive it :)
14:58:12 <Cale> Well, it derives something...
14:58:16 <f|`-`|f> So a tree with lists as elements?
14:58:34 <ReinH> c_wraith: yeah, me neither now that I think about it. :/
14:58:34 <Cale> I haven't used DeriveTraversable enough to know whether it always gives you a law-abiding instance
14:58:56 <f|`-`|f> So Stack/Compose does what
14:59:00 <Cale> (I would hope it does)
14:59:13 <asthasr> Cale: Hi! a month or so ago I was talking about modeling a tree of questions and how to do that in a type safe way... was distracted, didn't get back around to it until tonight
14:59:19 <staffehn> Cale: I tested the derived instance, it seems to work.
14:59:21 <asthasr> thought I'd share my non-typesafe notation for it
14:59:50 <akfp> where can I put the cabal.config file to make it global for all projects?  in ~/.cabal/config maybe?
14:59:56 <asthasr> Cale: http://hastebin.com/kanoxeweko.clj
15:00:23 <Cale> staffehn: Well, it'll give you some implementation of the methods, and I'd hope that implementation actually satisfies the laws for a Traversable instance.
15:00:29 <ReinH> akfp: ~/.cabal/config should already exist, but be aware that it has a subtly different syntax
15:00:41 <ReinH> from project-local ones
15:00:43 <Cale> staffehn: But this stuff is new, and I don't really know how it works :)
15:01:40 <ReinH> I can't think of any counterexamples, but that does not constitute a proof
15:03:08 <Cale> staffehn: Anyway, do you understand the very mechanical translation I did to your program? I suppose I ought to have left the order of arguments to TStack the same as the order you had with your class, but I couldn't help myself moving the higher kinded argument first.
15:03:14 <ReinH> Cale: btw, why is m (n a) -> n (m a) for monads m, n called distributive rather than commutative?
15:03:21 <akfp> ReinH: can I use the fpcomplete cabal.config constraints file in ~/.cabal/config?
15:04:21 <ReinH> akfp: probably not, because one of the differences is that cabal.config uses `Constraints:' while ~/.cabal/config uses `Constraint:'. This bit me before too.
15:04:22 <staffehn> Cale, I don't think that your Solution is very useful, because it was all about having the typeclass. I will definitly try a TypeFamilies alternative. They are sometimes kind of a lot more intuitive anyways.
15:04:56 <staffehn> But I think I kind of get what you did..
15:05:06 <Cale> ReinH: because of how it acts in some motivating examples
15:05:20 <ReinH> Cale: hmm
15:05:24 <Cale> ReinH: I think https://www.youtube.com/watch?v=mw4IhOLhDwY explains one such example
15:05:36 <ReinH> Cale: Ah! Thanks.
15:05:49 <ReinH> Always enjoy excuses to watch the catsters
15:06:01 <srhb>  /open
15:06:03 <srhb> Woops
15:06:35 <ReinH> Cale: btw I am hopeful that they will do some more videos on, e.g., kan extensions.
15:07:29 <mniip> I think I figured out why parsec is so unintuitive: it provides a layer over pegs that allows for error recovery and other fancy stuff
15:07:43 <ReinH> parsec is unintuitive?
15:07:45 <Cale> Parsec is unintuitive?
15:07:48 <Cale> lol
15:08:04 <mniip> what would be nice, although, is to have a subset of parsec that represents pegs
15:08:18 <mniip> ReinH, I find it very unintuitive
15:08:20 <srhb> pegs?
15:08:22 <Cale> The main unintuitive thing about parsec I think isn't the class of grammars that it admits
15:08:29 <mniip> srhb, parser expression grammars
15:08:30 <srhb> Ah
15:08:48 <Cale> It's just the behaviour surrounding failure and consumption which requires the use of try in some instances.
15:08:54 <monochrom> I have seen pegs. it was ok. but not particularly intuitive.
15:09:06 <ReinH> Cale: I like the parsers where try = id
15:09:27 <ReinH> Also http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
15:09:49 <Cale> Like, ReadP is more intuitive to use for the most part (the only thing which kind of annoys me is that it makes you use readP_to_S to run the parsers)
15:09:49 <monochrom> it follows that: a person who finds pegs intuitive is not going to find anything else intuitive.
15:10:31 <indiagreen> not really a Haskell question, but still: if my library is under GPLv3, can it be used by a program under GPLv2?
15:11:17 <Cale> BSD license everything just to avoid having to ask yourself questions like that :D
15:12:57 <indiagreen> I don't like GPL at all but I'm also kinda leaning to the side of it being necessary evil
15:13:05 <indiagreen> * a necessary evil
15:14:35 <michaelt> it might be a necessary evil for things written in C, or something. In Haskell it's irreligious ... ;)
15:15:11 <Cale> There are few enough Haskell applications which are distributed in binary form anyway, that you have to worry about getting their source code released.
15:16:16 <mniip> monochrom, well haskell is about orthogonality, right?
15:16:26 <Cale> Most industrial Haskell code isn't released to end users in any way, so the GPL isn't going to do anything extra apart from get in the way of other open source Haskell users.
15:17:17 <Cale> This might change in the future of course, but worrying about it right now seems a bit odd.
15:17:21 <d-snp> yeah, ironically GPL is best suited as a license to protect core business code
15:17:47 <mniip> PEGs are the most unrestricted way to parse stuff
15:18:01 <d-snp> any utility functions or functionality thats non-core to your business should just be MIT to have maximum community impact
15:19:53 <ReinH> I suppose intuitive is in the eye of the intuitor.
15:20:11 <Cale> I'm not sure I agree with "most unrestricted"
15:20:30 <monochrom> except they have gone from mere subjective "intuitive" to strong objective "unrestricted"
15:20:42 <monochrom> at which point I decided there is no point spending more time
15:20:44 <Cale> Are PEGs Turing complete?
15:20:49 <mniip> well, I don't think I know a correct word for this
15:21:58 <monochrom> I understand the emotion though. once upon a time, I worshipped Turbo Pascal and thought "everything else is a compromise"
15:22:12 <monochrom> then I worshipped Turbo C and thought "everything else is a compromise"
15:22:28 <monochrom> then I worshipped Lisp and thought "everything else is a compromise"
15:22:46 <monochrom> then I worshipped Perl and thought "everything else is a compromise"
15:22:54 <EvanR> ultimately, everything but haskell is a compromise
15:22:59 <EvanR> joking
15:23:08 <Cale> Everything including Haskell is a compromise :D
15:23:12 <ion> Everything but Blub is a compromise
15:23:17 <ion> Blub is the best.
15:23:25 <monochrom> then finally I learned SML, and saw a pattern, and woke up to "no, I'm growing out of worshipping anything from now on"
15:23:39 <mniip> I don't worship pegs
15:23:47 <mniip> I worship simple behavior
15:24:01 <EvanR> ill stop worshipping when theres some identifiable practical weakness
15:24:09 <ReinH> Cale: Well, "unrestricted" has a technical meaning here as well
15:24:10 <Cale> mniip: Try ReadP... its error messages are perhaps not as pretty
15:24:14 <monochrom> PEG is not simple. PEG is only simple for those things PEG is simple for.
15:24:28 <Cale> mniip: But perhaps you'll like its behaviour a little better
15:24:35 <johnw> ReinH: in Conor's paper, I found it odd that he defines container types as General, but never once mentions container types
15:24:57 <ion> StateT [input] [] output is the best parser.
15:24:58 <mniip> Cale, hmm
15:25:10 <ReinH> johnw: hmm
15:25:12 <mniip> continuation-style peg with a few optimizations?
15:25:14 <johnw> the paper felt a lot more like review than anything else I'd seen, although the notion of capturing recursion computation using a model that is later evaluation, while not new, is interesting in this context
15:25:38 <johnw> i.e., of using Free over a container to build the model and monad morphisms as the evaluators
15:26:05 <Cale> I don't know much about PEGs. I would just call ReadP a parser combinator library. It has a symmetric choice operator (+++) which is nice.
15:26:12 <johnw> his General is pretty much just what I came up with for my FreeF: https://github.com/jwiegley/coq-haskell/blob/master/research/Pipes.v#L46
15:26:20 <ReinH> :)
15:26:36 <Cale> It also has <++ which is left-biased like Parsec's <|>
15:26:38 <johnw> which is to say, I found it somewhere :)
15:26:48 <mniip> Cale, imagine 'type Peg s a = [s] -> [([s], a)]'
15:27:13 <Cale> How does that type have anything to do with the description of parsing expression grammars on Wikipedia?
15:27:20 <Cale> That's a much much more general type for parsers
15:27:23 <monochrom> the function space [s] -> [([s], a)] is much larger than PEG
15:27:58 <Cale> (In particular, it inherits Haskell's Turing completeness)
15:28:01 <mniip> you can implement all PEG combinator in that and more
15:28:27 <Cale> mniip: Which combinator do you think Parsec is missing?
15:28:36 <mniip> it isn
15:28:45 <Cale> Okay
15:28:56 <mniip> it isn't missing any combinators, it is missing intuitive behavior
15:29:02 <lpaste> staffehn pasted “solved it.. kinda..” at http://lpaste.net/133275
15:29:05 <Cale> What intuitive behaviour?
15:29:15 <EvanR> parsec is intuitive, i understood it as a baby
15:29:28 <staffehn> Cale: Using IncoherentInstances I created something that works..
15:29:37 <Cale> staffehn: lol
15:29:42 <EvanR> but like swimming i forgot it all 
15:30:00 <ReinH> staffehn: for some value of "works"
15:30:06 <ReinH> Like, right up until you try to use it
15:30:23 <init> is there anyting that can't be done using IncoherentInstances, TypeFamilies, DataKinds, UndecidableInstances?
15:30:39 <ReinH> Plenty of things
15:30:45 <mniip> hm
15:30:45 <geekosaur> "make sense"
15:30:51 <geekosaur> :p
15:31:17 <ReinH> Just because you can doesn't mean you should
15:31:33 <Cale> I kind of think that IncoherentInstances maybe shouldn't exist. If you get that far along the chain of evil relaxations to the rules about instances, you probably should have stopped using type classes a while back.
15:31:36 <mniip> ReinH, consuming/unconsuming is what's bothering me
15:32:41 <ReinH> Indeed. As I said, When GHC tells you to enable undecidable and incoherent instances, it is really trying to tell you to reconsider your typechoices.
15:32:48 <ReinH> I meant life choices, but that works too
15:32:52 <Cale> mniip: Well, yeah, that's one thing which is nicer about ReadP's semantics. However, it's also what makes Parsec way more efficient than ReadP.
15:33:32 <c_wraith> ReinH: nah, Undecidable is safe and easy.  It's Overlapping or Incoherent that are bad
15:34:10 <monochrom> Undecidable is the recursively-enumerable kind of safe
15:34:29 <Cale> mniip: The thing is, if you allow for consuming input to commit to a choice, it means you get to discard the rest of the parser right away, as well as the beginning of the input, because you know you're not backtracking at that point.
15:34:35 <c_wraith> You run into Undecidable all over the place when doing interesting things (like Fix) or using MPTCs
15:34:50 <ReinH> c_wraith: Woops, yeah, I meant overlapping.
15:34:52 <Cale> mniip: So it fundamentally improves performance of the parser in a way which is hard to get otherwise.
15:34:58 <mniip> Cale, this is where noBacktrack combinator comes in!
15:35:26 <Cale> mniip: Well, if you have that, your parsers will just be *mostly* slow :)
15:35:34 <c_wraith> :t Fix
15:35:35 <staffehn> ReinH, it didn't even tell me to use IncoherentInstances, it just said, that there were overlapping instances..
15:35:36 <lambdabot>     Not in scope: data constructor ‘Fix’
15:35:36 <lambdabot>     Perhaps you meant one of these:
15:35:36 <lambdabot>       variable ‘ix’ (imported from Control.Lens),
15:35:42 <Cale> (or highly annotated with noBacktracks everywhere)
15:36:09 <Cale> Or often it's the space usage which you worry about more.
15:36:11 <mniip> I've came up with an idea recently
15:36:19 <monochrom> OverlappingInstances is safe to me because it still guards against incoherence.
15:36:23 <mniip> which was actually the reason I realised why is parsec so, uh, "weird"
15:37:09 <mniip> what if we allow choosing the way possible results are managed
15:37:15 * geekosaur tends to think of Overlapping as SemiIncoherent
15:37:21 <mniip> Monad m => [s] -> m ([s], a)
15:37:35 <c_wraith> monochrom: overlapping still lets an additional instance being in scope changing the result of instance selection on otherwise-unchanged code
15:37:41 <Cale> mniip: Congratulations, you just invented StateT
15:37:50 <mniip> oh
15:38:14 <mniip> [01:24:08] <ion> StateT [input] [] output is the best parser.
15:38:16 <mniip> I see now
15:38:36 <ion> (Disclaimer: it was a lie.)
15:39:09 <mniip> damn even the sequencing semantics are correct
15:39:46 <ion> (Specifically, it has arbitrary backtracking and no error reporting.)
15:40:17 <mniip> ion, well, for two examples, you can have full backtracking with [], and no backtracking with Maybe
15:41:15 <mniip> error reporting - well yeah, errors are usually hard to manage with intuitivity in mind
15:43:27 <mhitza> with the BGP in 7.10 Prelude, does anyone have an example of what CPP pragmas I could use to define includes for versions before 7.10 and after?
15:45:33 <mniip> [01:34:53] <Cale> (or highly annotated with noBacktracks everywhere) -- you are correct, I tried implementing lua syntax as an example, it was heavily relying on that
15:45:56 <mniip> but that might be because lua is originally implemented in C and so the syntax is designed with no more than 1 token lookahead in mind
15:48:07 <ReinH> Well, C is implemented in C...
15:48:32 <mniip> C has similar lookahead rules, no?
15:48:49 <mniip> most real world languages have non-backtracking syntaxes
15:49:00 <ReinH> Um. C++ requires infinite lookahead.
15:49:09 <ReinH> And it's a pretty real world language
15:49:35 <mniip> oh?
15:49:43 <ReinH> C and C++ both allow the statement "x * y ;", which has two different parses
15:49:52 <mniip> oh right, nevermind me
15:49:54 <mniip> perl
15:50:55 <ion> I wonder if StateT [i] Logic a (from logict) would be useful for parsing? “ifte” might help with useful errors (given something in the type for error reporting) and “once” might help with efficiency by limiting backtracking.
15:52:15 <ion> mhitza: #if __GLASGOW_HASKELL__ >= 710
15:53:33 <mhitza> ion, thanks
15:56:00 <mhitza> ion, do you have a link where I can find all the predefined values (like __GLASGOW_HASKELL__ )? Or is that the only one I can rely on?
15:56:42 <ion> mhitza: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/options-phases.html#c-pre-processor
15:56:58 <ion> Cabal also defines macros.
15:59:35 <mhitza> ion, thank you once again. But I guess there is nothing generated as specific as if __BASE_PKG__ >= 49 :)
15:59:46 <ion> That’s where cabal can help.
16:00:26 <ion> #if MIN_VERSION_base(4,9,0)
16:01:53 <Fuuzetsu> death to CPP
16:02:17 <Fuuzetsu> @package base-compat
16:02:18 <lambdabot> http://hackage.haskell.org/package/base-compat
16:02:55 <ion> > (map unwords . sequence) [["death to", "long live"], ["CPP"]]
16:02:57 <lambdabot>  ["death to CPP","long live CPP"]
16:08:30 <GettingIntoIt> :t god
16:08:31 <lambdabot>     Not in scope: ‘god’
16:08:31 <lambdabot>     Perhaps you meant one of these:
16:08:31 <lambdabot>       ‘gcd’ (imported from Prelude), ‘mod’ (imported from Prelude)
16:08:45 <GettingIntoIt> damn
16:10:19 <Cale> Where is your gcd now?
16:11:17 <ion> G-D, the GREATEST ------ DIVISOR
16:12:28 <Haskel101> hi
16:13:14 <Zer000> I'm getting a "Not in scope: data constructor" and I don't know why. Can someone help? Here's a ghci session dump: http://lpaste.net/133276
16:13:30 <Haskel101> is it possible to make an add of a split that second argue is another split just using other functions and composition ? like add (1,(2,3))
16:14:18 <Haskel101> Word160 would be what ?
16:14:27 <ion> Zer000: You only imported the type. To import all the associated data constructors: import Data.Digest.SH1 (Word160 (..))
16:15:15 <Haskel101> ion: can u take a look at my doubt ?
16:15:48 <ion> Haskel101: I’m afraid I don’t understand what you are asking.
16:16:32 <Zer000> ion, oh thanks!
16:17:01 <staffehn> > uncurry (+) . second (uncurry (+)) $ (1,(2,3))
16:17:02 <lambdabot>  6
16:17:08 <Zer000> hooray it compiles now!
16:18:27 <Haskel101> oh nice
16:18:45 <Haskel101> staffehn: ty !
16:18:55 <staffehn> haskell101, "second" comes from Control.Arrow
16:19:37 <Haskel101> yeah i have defined p1 p2 to acess split, but i get your code
16:19:42 <Haskel101> i was almost there :p
16:19:53 <ion> > (\(a,(b,c)) -> a+b+c) (1,(2,3))
16:19:54 <lambdabot>  6
16:19:59 <ion> > (\a b c -> a+b+c) 1 2 3
16:20:02 <lambdabot>  6
16:20:35 <joneshf-laptop> has anyone taken the time to codify some design principles for haskell?
16:20:38 <joneshf-laptop> or fp in general?
16:20:51 <Haskel101> i had a second function to do that in my main one add2(t1,(t2,t3)) = t1+t2+t3 but i wanted to do it in 1 line
16:21:02 <indiagreen> joneshf-laptop: Tekmo is writing a whole book on the topic, I think
16:21:22 <ion> Haskel101: That is 1 line, isn’t it?
16:21:29 <staffehn> @pl \(a,(b,c)) -> a + (b + c)
16:21:29 <lambdabot> uncurry ((`ap` snd) . (. fst) . (. (+)) . (.) . (+))
16:21:43 <staffehn> @pl \(a,(b,c)) -> a + b + c
16:21:43 <lambdabot> uncurry ((`ap` snd) . (. fst) . ((+) .) . (+))
16:22:12 <mhitza> is `import Prelude hiding (traverse)` a bad idea? Since the code I'm updating has a defined `traverse` at the module level this is the simplest option instead of relying on CPP. GHC doesn't issue a warning, not even when I do something like `import Prelude hiding (pancakes)` so I guess I'm safe with older base packages, right?
16:23:05 <joneshf-laptop> indiagreen, oh?
16:23:18 <joneshf-laptop> indiagreen, any links?
16:24:00 <ion> mhitza: Since earlier versions of base also have traverse (although not in Prelude), the code defining a distinct thing named traverse might be considered confusing. Perhaps consider renaming it.
16:24:21 <ReinH> mhitza: It would be surprising to have a function named traverse that isn't Prelude.traverse
16:24:24 <indiagreen> joneshf-laptop: and there are some posts on nir blog, see e.g. http://www.haskellforall.com/2012/08/the-category-design-pattern.html or http://www.haskellforall.com/2012/09/the-functor-design-pattern.html or http://www.haskellforall.com/2014/07/equational-reasoning-at-scale.html
16:24:33 <para___> ls
16:24:34 <para___> oops
16:24:38 <ion> the unsafePerformIO design pattern
16:24:45 * hackagebot hjsonschema 0.6.0.0 - JSON Schema Draft 4 library  http://hackage.haskell.org/package/hjsonschema-0.6.0.0 (seagreen)
16:24:51 <mhitza> ion, I'll take that up with the package mantainer once I do a PR. I don't want to rewrite a large amount of the library, just enough that I can use it with ghc 7.10.1 :)
16:24:57 <Haskel101> ion: it his, but not when u have a function using that, and you defined a where to do that little function, while i could do it inside the main function
16:25:07 <mhitza> ReinH, my last comment was for you :)
16:25:13 <EponymicCycloid> I may be overthinking a problem I have. I want to have a way of serializing certain functions. Obviously I can't write a Serialize instance for e.g. `Int -> Float`, because I can't serialize arbitrary functions. However, I can obviously come up with a serialization format for certain functions that I write. I.e., I can easily write `ByteString -> Either Error (Int -> Float)`. Right now, the way I'm doing this is to have a 
16:25:14 <EponymicCycloid> typeclass, `Stored f a`, where `extract :: f -> a`. The idea is that I can write a `Serialize` instance for `f`, and using `extract`, I can get the proper type out of `f` .This is essentially a "wrapper class" so I don't have to write a Serialize instance for `Int -> Float`. Is there a better way to do this?
16:25:19 <MichaelBurge> If you have a common library of functionality, with multiple small executables on the side, what's a good way to phrase that in a .cabal file without having to relist all of the build-depends each time?
16:25:51 <MichaelBurge> I've putting putting pretty much everything in a single library project, and using 2-line executable entries that just defer to a main function in the library
16:26:29 <ion> EponymicCycloid: For what reason would you like to serialize functions?
16:26:30 <kadoban> MichaelBurge: Have the executables depend on the library itself, which is named the same as the project.
16:26:31 <joneshf-laptop> indiagreen, thansk, anything about the book?
16:26:51 <ReinH> mhitza: I'm not sure how it would behave.
16:26:58 <indiagreen> joneshf-laptop: the book so far has an empty repository and nothing else
16:27:00 <ReinH> mhitza: I guess try it with both ghc versions
16:27:12 <indiagreen> you can join us watchers
16:27:21 <EponymicCycloid> ion: Well, I want to serialize something that will be turned into a function later. Specifically, I'm storing scripts in an embedded scripting language
16:27:22 <ReinH> MichaelBurge: what kadoban said
16:27:32 <EponymicCycloid> Obviously I don't want to serialize *any* function
16:27:37 <indiagreen> joneshf-laptop: https://github.com/Gabriel439/haskell-in-the-large
16:27:41 <ReinH> indiagreen: Tekmo is writing a book? Cool.
16:27:44 <EponymicCycloid> I just want to express "This can be serialized, and also turned into a function"
16:28:18 <joneshf-laptop> indiagreen, thanks
16:28:38 <ReinH> EponymicCycloid: for "this can be serialized", make it an instance of Binary
16:28:43 <EponymicCycloid> Yes, of coruse
16:28:45 <EponymicCycloid> *course
16:28:51 <EponymicCycloid> the tricky part is the other half
16:29:02 <EponymicCycloid> And this may, in fact, be the wrong way to do it
16:29:22 <EponymicCycloid> (Although I'll probably use Serialize instead of Binary in this case)
16:29:45 <ReinH> EponymicCycloid: Use a newtype wrapper?
16:29:58 <ReinH> newtype StorableFunction ...
16:30:08 <ReinH> or Serializable, rather, since Storable means something else
16:30:21 <EponymicCycloid> ReinH: To wrap what? The function? There's no way for me to write (a -> b) -> ByteString
16:30:47 <EponymicCycloid> The most obvious way seems to implement Serialize f as well as `f -> (a -> b)`
16:31:00 <EponymicCycloid> Which is what I'm doing
16:31:09 <EponymicCycloid> which seems a bit complicated, as I have to use an extension to do it...
16:31:13 <ReinH> EponymicCycloid: to wrap whatever you are storing, then you can write eval :: SerializableFunction -> a - > b for whatever a, b
16:31:17 <EponymicCycloid> (Multi-param type calsses)
16:31:21 <EponymicCycloid> Yeah, that's what I'm doing
16:31:45 <ReinH> EponymicCycloid: seems fine
16:31:47 <EponymicCycloid> rather, I'm writing (Stored p a) => p -> a
16:31:56 <EponymicCycloid> Where a can be whatever
16:31:59 <EponymicCycloid> function, literal, etc
16:32:27 <Hijiri> how are you representing your scripts?
16:32:33 <EponymicCycloid> ADT
16:32:59 <Hijiri> is each component serializable
16:33:03 <EponymicCycloid> Yes
16:33:20 <EponymicCycloid> Provided I make that "Stored" type serializable
16:33:28 <EponymicCycloid> so if I have (Serialize f) and (f -> a), then yes
16:33:35 <EponymicCycloid> Which I do have, it's just a bit complicated
16:35:08 <ReinH> EponymicCycloid: you're implying the need for a lot of generality. Is that actually true? What use cases do you have for this structure?
16:35:42 <EponymicCycloid> ReinH: Saving certain kinds of procedures to disk
16:35:55 <ReinH> Well yes. Can you be more specific?
16:36:05 <EponymicCycloid> What more do you want?
16:36:09 <EponymicCycloid> Not sure how to clarify
16:36:41 <ReinH> EponymicCycloid: maybe what you really want is something like https://hackage.haskell.org/package/distributed-process-0.5.3/docs/Control-Distributed-Process-Closure.html
16:37:04 <ReinH> But if you don't need the full generality, there's probably something simpler you can use
16:37:05 <EponymicCycloid> Too powerful
16:37:08 <ReinH> Right
16:37:12 <EponymicCycloid> I'll know in advance the form of all stored scripts
16:37:20 <EponymicCycloid> That's why I can represent them as an ADT
16:37:27 <ReinH> Which is why I'm trying to figure out how small your problem space is
16:37:32 <EponymicCycloid> with occasional "plug-ins" represented by that "Stored" type we talked about
16:37:57 <EponymicCycloid> Thanks for the help; the more I think about it, the more reasonable this approach seems
16:39:17 <ReinH> EponymicCycloid: :)
16:53:54 <pflanze> Hi. I'm looking for various functions changing argument order, similar to `flip`. 
16:54:16 <pflanze> E.g. rot3left and rot3right
16:54:31 <pflanze> or whatever they should be called. Anyone found these in the wild?
16:54:46 * hackagebot hBDD-CUDD 0.0.3 - An FFI binding to the CUDD library  http://hackage.haskell.org/package/hBDD-CUDD-0.0.3 (PeterGammie)
16:54:48 * hackagebot hBDD 0.0.3 - An abstraction layer for BDD libraries  http://hackage.haskell.org/package/hBDD-0.0.3 (PeterGammie)
16:56:31 <bob_twinkles> you can do stuff like rot3right = (flip .) . flip
16:56:44 <bob_twinkles> :t (flip .) . flip
16:56:45 <lambdabot> (a1 -> a -> b -> c) -> a -> b -> a1 -> c
16:56:47 <Axman6> pflanze: I know someone at NICTA wrote a package called flip (not sure if released) which gave you every combination of arguments up to like 6. it's definitely not something you want though
16:56:55 <ReinH> pflanze: https://hackage.haskell.org/package/flippers-1.0.1/docs/Data-Function-Flippers.html
16:57:08 <ReinH> I think there's an acme package too
16:57:18 <ion> That’s not an ACME package? :-P
16:57:27 <ReinH> But you'll find code you wrote with these impossible to maintain, so...
16:58:46 <pacak> ACME version had all possible combinations to those flips.
16:58:57 <ReinH> I recall that it exists, but not the name
16:59:01 <ReinH> anyway it's a ridiculous package
16:59:07 <ReinH> which is probably why it's in ACME
16:59:46 * hackagebot hBDD-CMUBDD 0.0.3 - An FFI binding to CMU/Long's BDD library  http://hackage.haskell.org/package/hBDD-CMUBDD-0.0.3 (PeterGammie)
16:59:53 <ReinH> I would suggest either using things like (\f a b c -> f b c a) as needed or fixing the argument order
16:59:57 <pflanze> Data.Function.Flippers is oddly missing left rotation.
17:00:17 <ReinH> At least the lambda is easy to read
17:00:26 <pflanze> Ok.
17:00:27 <ion> pflanze: Just compose right rotations. ;-)
17:00:34 <f|`-`|f> So ReinH no interest in Blockchain tech for your interest in distributed control?
17:01:35 <pflanze> Hm, flip3 . rotate3 . flip3 
17:02:30 <ReinH> such symmetry group wow
17:02:47 <ReinH> f|`-`|f: I'm not quite sure how it relates
17:03:02 <f|`-`|f> oh
17:03:35 <f|`-`|f> At the very least, as a common/shared database for the system
17:04:46 * hackagebot file-collection 0.1.1.7 - Provide a uniform interface over file archives and directories  http://hackage.haskell.org/package/file-collection-0.1.1.7 (joel_williamson)
17:06:07 <chickendinner> reading the type of groupBy (:t groupBy)
17:06:10 <chickendinner> , :t groupBy
17:06:24 <chickendinner> (a -> a -> Bool) -> [a] -> [[a]] Prelude Data.Char Data.List Data.Function>
17:06:53 <chickendinner> i understand that it takes a list of type A and produces a list of list of types a
17:06:58 <chickendinner> but the first argument
17:07:11 <chickendinner> it takes a function that takes 2 values and produces a bool
17:07:16 <chickendinner> is this a comparison function
17:07:17 <chickendinner> such as ==
17:07:20 <chickendinner> am I reading this correct?
17:08:30 <ion> chickendinner: yes
17:09:06 <chickendinner> good, so moving to the `on` function - 
17:09:08 <chickendinner> , :t on
17:09:18 <chickendinner> on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
17:09:40 <chickendinner> this is defined as f `on` g = \x y -> f (g x) (g y)  
17:10:17 <chickendinner> well can
17:10:24 <chickendinner> someone give it to me in no infix form?
17:10:31 <chickendinner> is infix is f `on` g = \x y -> f (g x) (g y)  
17:10:34 <chickendinner> what about prefix ?
17:10:42 <init> on f g 
17:10:44 <ion> on f g = \x y -> f (g x) (g y)
17:10:52 <ion> on f g x y = f (g x) (g y)
17:11:06 <c_wraith> on = \f g x y -> f (g x) (g y)
17:11:22 <chickendinner> great, so the type mapping the variables
17:11:23 <chickendinner> on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
17:11:35 <chickendinner> b would be teh product of g
17:11:47 <chickendinner> and c the product of f ?
17:12:09 <chickendinner> so thinking of a list which i want to sort on
17:12:15 <chickendinner> a would be the elements in the list
17:12:19 <ion> The result value, yeah
17:12:27 <chickendinner> then b would be the result of applying g on a
17:12:31 <chickendinner> then c the result of f on g
17:13:30 <chickendinner> ion, is it correct to think of it like that?
17:13:39 <chickendinner> ion: is it correct to think of it like that?
17:13:46 <ion> chickendinner: Seems right. Seems right.
17:15:22 <chickendinner> ion: thanks, was just stumped by something. explaining it out has made me grok it :)
17:19:13 <ion> That often helps.
17:27:56 <Moggle> what's the most efficient way to handle the case where you need to append a bunch of Texts together over and over?
17:28:13 <Moggle> normally i'd do a difference list, but i'm not sure if that's how i should do it with texts
17:28:55 <heatsink> You can use Data.Sequence, which is list-like with efficient append
17:30:07 <Moggle> thanks, i will look into that
17:30:28 <ion> Moggle: Lazy Text is like a list of strict Text.
17:32:45 <c_wraith> a difference list is probably the fastest thing with Text, unless there are potential space leak issues.
17:34:02 <Moggle> c_wraith, with a difference list, i'd use Text.append, but that seems like it's going to be super inefficient
17:34:25 <Moggle> and Text.concat would require a list - which i could create via a difference list technique, i guess. should i do that?
17:34:27 <c_wraith> No, use a difference *list*.
17:34:30 <c_wraith> yeah
17:34:40 <ion> Which Text.append?
17:35:01 <ion> The lazy Text one should be like (++)
17:35:27 <ion> The difference list approach should apply.
17:35:50 <Moggle> ion: http://hackage.haskell.org/package/text-1.2.1.0/docs/Data-Text.html#v:append
17:36:19 <Moggle> it claims that it makes a new text - i assume this allocates more space
17:36:30 <Moggle> but the issue is i am then going to be appending this new text to something else with the naive approach i'm doing now
17:36:40 <Moggle> so it seems like this is going to allocate a bunch of unnecessary stuff
17:36:46 <crough> Use Lazy
17:36:46 <Moggle> i think making a difference list of texts
17:36:49 <ion> That's the strict Text.
17:36:54 <crough> Data.Text.Lazy is much much better
17:37:04 <Moggle> Unfortunately, this library is giving me the strict version
17:37:04 <crough> It creates a list of slices of text
17:37:11 <Moggle> I can convert from one to another I guess?
17:37:16 <crough> You can use toStrict at fromStrict when you need to cross the border
17:37:22 <ion> fromStrict
17:38:16 <ion> toStrict is O(characters), fromStrict is O(1)
17:38:22 <Moggle> so, Data.Text.Lazy.append will operate in a sane manner if I use it in a difference list like ("hello" `append`)?
17:38:44 <ion> It should.
17:38:52 <Moggle> great. thanks.
17:39:20 <Moggle> would this be much more efficient than creating a difference *list* with actual lists of texts, and then calling Text.append?
17:39:25 <Moggle> i am going to guess yes?
17:39:26 <Thrzsh> How can I write a list of integers to a binary file?
17:39:34 <crough> Thrzsh: Bytestring
17:39:50 <Moggle> er
17:39:52 <Moggle> Text.concat
17:39:54 <crough> Moggle: there’s also Data.Text.Lazy.Builder
17:40:08 <Moggle> Would you recommend any specific approach over any other, crough?
17:40:22 <ion> Moggle: I'd expect them to be equivalent.
17:40:53 <crough> For lazy text, they’re probably similar. For strict text, always use concat, not append.
17:40:56 <ion> Moggle: Builder.fromText might be nice here.
17:41:00 <lambdafan> given a [String], I would like to use TH to construct sum type "data Foo = ..." with each string being made into a value of sum type Foo. Could someone point me in the right directio? I'm overwhelmed by the info on TH out there.
17:41:09 <Thrzsh> crough: Could you give an example? I've tried Bytestring and it didn't make much sense to me.
17:41:50 <ion> Thrzsh: You can use binary to encode binary data.
17:41:57 <ion> @Hackage binary
17:41:57 <lambdabot> http://hackage.haskell.org/package/binary
17:42:11 <crough> Thrzsh: a byte string is a sequence of Word8 (uint8). Listen to ion though becasue he seems a whole hell of a lot more skilled than me
17:42:43 <crough> And binary is probably better than my naive stuff
17:43:02 <Thrzsh> Thank you, I'll try that
17:44:17 <Axman6> Moggle: if you're building up Text values, the Builder type(s?) are probably your besty bet for efficiency
17:45:26 <lambdafan> so, if I have ["Bar","Baz","Bin"] I'd like to use TH to make data Foo = Bar | Baz | Bin
17:45:28 <Moggle> Axman6: Thanks. What I am doing is traversing an XML tree recursively, grabbing texts from nodes where they are available and then combining them. Data.Text.Lazy.Builder things would still work best for this?
17:45:57 <crough> Moggle: Yes. That’s the best use of a builder.
17:46:06 <ion> Moggle: Probably.
17:46:16 <Moggle> Thanks. I'll use that, then.
17:50:05 <pacak> lambda: you'll need DataD and a bunch of ConT's for Bar/Baz/Bin
18:03:16 <sleblanc> :t peekCString
18:03:17 <lambdabot>     Not in scope: ‘peekCString’
18:03:17 <lambdabot>     Perhaps you meant ‘BSC.packCString’ (imported from Data.ByteString.Char8)
18:08:21 <athan> What would be a good way to parse text up to some string, or eof? `manyTill anyChar ((return () . string foo) <|> eof)` ?
18:09:24 <SparkySparkyBoom> hi
18:09:45 <Cale> hello
18:09:54 <SparkySparkyBoom> what's the usual way of trying to read a float from a bytestring?
18:10:03 <SparkySparkyBoom> i looked at the Get monad in the binary package
18:10:13 <SparkySparkyBoom> but it only supports word8
18:10:20 <SparkySparkyBoom> er
18:10:20 <init> is there any 'standard'/'good' library for sound processing?
18:10:22 <SparkySparkyBoom> words
18:10:38 <SparkySparkyBoom> i'd have to convert to float myself
18:10:45 <crough> read . Data.Text.unpack . Data.Text.Encoding.decodeUtf8
18:10:50 <Cale> SparkySparkyBoom: Encoded as text, or in some binary format?
18:10:55 <crough> That might work but there's probably a better way
18:10:57 <SparkySparkyBoom> binary format
18:11:14 <SparkySparkyBoom> 8 byte floats
18:12:37 <Cale> There are Binary instances for Float/Double, however, they probably don't produce exactly the encoding you want (unless you don't care and just want *some* encoding).
18:12:54 <Cale> http://hackage.haskell.org/package/data-binary-ieee754-0.4.4/docs/Data-Binary-IEEE754.html
18:12:59 <Cale> seems to have what you probably want
18:14:28 <SparkySparkyBoom> thanks a lot
18:18:18 <nshepperd_> huh, I always used word2Double from reinterpret-cast
18:19:03 <hiptobecubic> Is there a difference between "fix f = let x = f x in x" and "fix f = f (fix f)" ?
18:19:21 <dolio> hiptobecubic: The first one is more efficient in some cases.
18:19:29 <hiptobecubic> why?
18:19:41 <dolio> If f = (1:) it will build a circular list.
18:20:02 <dolio> So no matter how far you walk through it, it will take constant space.
18:20:12 <dolio> Even if it doesn't get garbage collected.
18:21:01 <hiptobecubic> ah
18:25:42 <fishburne> I am trying to log values passed to a function. I was told here that I cannot do this, https://bpaste.net/show/ea9c9b525b1d. So ended up doing this, https://bpaste.net/show/ea9c9b525b1d, which works. But I am not sure about it usefulness.
18:26:26 <darkroom> I am trying to update cabal and just ran this command "cabal install cabal cabal-install" but when i run "cabal -V" the verison number is the same
18:27:17 <fishburne> darkroom, are you on Linux?
18:27:38 <darkroom> fishburne: yes
18:28:39 <fishburne> darkroom, you might have to copy the executable file from ~/.cabal/bin to overwrite your current cabal executable in /usr/bin or /bin...
18:28:49 <crough> darkroom: is $HOME/.cabal/bin the first thing in your $PATH
18:29:09 <crough> Try: `export PATH=$HOME/.cabal/bin:$PATH`
18:29:40 <crough> then run cabal -V again :)
18:29:47 <darkroom> crough: it worked ;)
18:30:01 <darkroom> god #haskell is the best fucking IRC
18:30:05 <crough> Put that in your .bashrc or whatever rc file for the shell you're using :)
18:30:36 <crough> I'm at LambdaConf and some people were talking about it; figured I could try it today. People seem genuinely helpful :)
18:30:45 <bitemyapp> crough: hello!
18:30:59 <crough> Hello bytemyapp!
18:31:03 <darkroom> crough: I am jealous my parents wouldnt let me go :/
18:31:05 <bitemyapp> crough: have you had dinner yet? My friend and I are about to head out for dinner in Boulder.
18:31:14 <bitemyapp> we're right by UCB.
18:31:38 <crough> Yeah I could eat something small! Really late lunch but I'm 100% down! 
18:31:41 <fishburne> I am trying to log values passed to a function. I was told here that I cannot do this, https://bpaste.net/show/ea9c9b525b1d. So ended up doing this, https://bpaste.net/show/ea9c9b525b1d, which works. But I am not sure about it usefulness. Can someone please take a look at both and let me know if I am missing something?
18:32:33 <bitemyapp> crough: yeah we want something small/quick too.
18:32:37 <bitemyapp> crough: any ideas/suggestions?
18:32:50 <bitemyapp> We have a car and can drive, but don't want to go too far if possible, very early morning flight.
18:33:04 <darkroom> fishburne: I dont think your writer instance follows the monad laws
18:33:13 <darkroom> your return should have the empty list
18:33:21 <crough> bitemyapp: No idea... I'm from Phoenix. Sent you a PM with my number
18:33:51 <timothyh> I'm trying to traverse the Exp type from haskell-src-exts. e.g. i have an (Exp -> Exp) function to apply, but i'm not sure what typeclass would cover this kind of transform? it's almost fmap but wrong kind?
18:34:21 <fishburne> crough, is it important if I am only interested in logging values passed?
18:34:29 <timothyh> is there some derivable class that would let me map (a -> a) across some structure?
18:34:43 <crough> fishburne: Follow the monad laws yo.
18:34:57 <crough> You'll have problems with things like transformers if you don't.
18:35:19 <slurpymcdurpy> bitemyapp, You probably want to go to pearlstreet. [off topic] -- or the Hill has many "college food" places quick.  I like Rush Bowls and Boss Lady Pizza.
18:35:39 * slurpymcdurpy is now lyonsb
18:35:45 <darkroom> fishburne: your problem is double has an ambigous type
18:36:29 <darkroom> you need to make the type double :: (Show a, Num a) => a -> Writer a
18:36:54 <lyonsb> bitemyapp, I think Rush Bowls is closed at this time though.  Lyfe kitchen on Pearl Street has amazing healthy stuff. [still off topic -- I live here]
18:37:20 <fishburne> darkroom,  Are you refering to the first one? (sorry about the last message btw)
18:37:25 <bitemyapp> lyonsb: lyfe rings a bell for some reason.
18:37:32 <darkroom> fishburne: yes
18:37:56 <timothyh> ooooo let the record show that syb seems relevant
18:38:40 <darkroom> fishburne: look into Monad.Writer it has perfect writer instances
18:38:41 <lyonsb> bitemyapp, if you're near CU, then the Hill is "nearby/quick" -- there's also a mexican place on Baseline that does all their foodstuffs in house, they have this strange-sweet jalepeno sauce that tastes completely unique (and isn't spicy)
18:39:18 <lyonsb> bitemyapp, it's just east (away from mtns) from highway underpass.
18:39:35 <fishburne> darkroom, that type declaration still does not compile.
18:39:48 <crough> lyonsb: I think Indian food is happening :)
18:39:56 <darkroom> fishburne: whats your error now
18:40:01 <lyonsb> bitemyapp, I order from Tiffens pretty regularly myself.
18:40:16 <_m_ryan> hi everyone, how can i use a MVar in my App? i use this data App = App { cities :: newEmptyMVar }, but it said my newEmptyMVar is not in scope. by the way i use yesod.
18:40:21 <bitemyapp> lyonsb: I think we're going to do Indian, thank you for the suggestions :)
18:40:23 <lyonsb> crough, I mean.
18:40:25 <lyonsb> Sure.
18:40:27 <fishburne> darkroom, the same
18:40:44 <darkroom> fishburne: let me download your code and try it out
18:40:59 <torulv> Hey how can I hide an instance of a typeclass when importing? e.g I want to hide the Text instance of Binary from Data.Text
18:41:07 <fishburne> darkroom, sure. I ll wait.
18:42:10 <lyonsb> bitemyapp, crough, have fun, enjoy :)
18:42:33 <torulv> b
18:42:35 <torulv> b
18:42:51 <torulv> Sorry overly used to switching emacs buffers.
18:43:51 <Zer000> hey guys can I make a tuple type be an instance of a class?
18:44:06 <darkroom> fishburne: ah okay i figured it out haskells type system is telling you not to mess with the monad laws ;) okay so return has to have a polymorhphic type so it needs to be return :: (Monad m) => a -> m a no where in that type signature can you put a (Show a) constrait 
18:44:34 <fishburne> darkroom, Exactly
18:44:37 <darkroom> so a correct return would look like this return x = Writer "" x
18:44:40 <Zer000> I have something like (Word160, (Word32, Word16)) that I want to declare as an instance of this one Class.
18:44:55 <fishburne> darkroom, yes that will work. 
18:47:19 <fishburne> darkroom, So I made the second version. It apparently does not obey the Monad laws. But It works as I intended. But I don't think I will be able to use it with a 'do' notation.
18:48:00 <darkroom> fishburne: if you put in my return i believe your monad now follows the laws let me doulbe check :)
18:48:42 <fishburne> darkroom, I am taking about this version,https://bpaste.net/show/80616da53484
18:48:50 <darkroom> fishburne: your monad now follows the laws with my return so you can feel free to put it in monad transformers use do notation all the great things a monad implies
18:49:43 <fishburne> darkroom, But it does not log the passed value. I mean, if I make the return function as, return x = Writer "" x
18:50:32 <darkroom> yea so what you could do is overload the do syntatic sugar but that is a dangeous game. Why not instead of changing return do this return = Writer "" and make a new function showReturn :: (Show a) => a -> Writer a
18:50:43 <SparkySparkyBoom> thank you Cale
18:50:45 <SparkySparkyBoom> it worked
18:50:59 <darkroom> fishburne: showReturn x = Writer ("I got: " ++ show x) x
18:51:12 <darkroom> fishburne: then you can use your writer with do syntax
18:51:32 <Cale> SparkySparkyBoom: cool
18:52:20 <timothyh> ok just used SYB for the first time
18:52:24 <timothyh> holy heck that was cool
18:52:33 <darkroom> timothyh: whats SYB
18:52:45 <enthropy> @hackage syb
18:52:46 <lambdabot> http://hackage.haskell.org/package/syb
18:52:50 <timothyh> Scrap Your Boilerplate, provides a bunch of data-generic combinators
18:53:00 <timothyh> in my case I used 'everywhere' to apply a transformation to an AST
18:53:12 <timothyh> avoiding writing out a very very boring almost-functor :)
18:53:30 <torulv> Hey where can I  get where the Binary instance of Text is declared? I have looked under where the type Text is created but I can't find it.
18:53:42 <torulv> http://hackage.haskell.org/package/text-1.2.1.0/docs/Data-Text.html#t:Text
18:54:03 <c_wraith> related...  does lens TH automatically derive Plated instances?
18:54:35 <timothyh> torulv: did you maybe get it from the text-binary package?
18:54:57 <darkroom> timothyh: that was a large mass of things i have never seen what does gfold do?
18:55:08 <timothyh> no idea, never used it
18:55:31 <torulv> timothyh: I didn't know that package exists. Thanks
18:55:37 <timothyh> np
18:55:52 <Pamelloes> Is there any way to import a hidden constructor?
18:56:36 <enthropy> Pamelloes: you can make a template haskell Name for it
18:56:53 <Pamelloes> enthropy: How would that work?
18:57:17 <c_wraith> enthropy: wasn't that fixed in more recent versions of GHC?
18:58:28 <enthropy> c_wraith: "fixing" that would mean that TH generated code referring to things like ByteString would only work if you get the imports also correct
18:58:50 <enthropy> Pamelloes: the constructors for Name are exported: http://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH-Syntax.html#t:Name
18:59:00 <L8D> Is it possible to import from multiple versions of the same package?
18:59:32 <enthropy> so if you make a Name using that NameG, it can refer to a constructor that isn't exported
19:00:24 <zacts> hm.. I wonder if there are any efforts to implement any Haskell libraries for Machine Learning
19:00:37 <zacts> that will compare with the popular python libraries and frameworks
19:00:40 <fishburne> darkroom, still no joy, http://lpaste.net/133284
19:00:55 <Pamelloes> enthropy: Can you link me to a paper or give me some sample code? I'm missing how making a name would allow me to access a constructor that isn't exported...
19:01:20 <enthropy> c_wraith: maybe ghc-7.4 "fixed" it according to the import you need from https://hackage.haskell.org/package/vector-th-unbox-0.2.1.2/docs/Data-Vector-Unboxed-Deriving.html
19:01:52 <L8D> Does anyone know if it's possible and if so, how, to import from multiple versions of the same package?
19:02:28 <Pamelloes> L8D: I can't say definitively, but I'm pretty sure that wouldn't be possible.
19:02:33 <enthropy> L8D: I think it's not possible (and your question got through the first time)
19:02:38 <L8D> and additionally, it is possible to list multiple versions of the same package in your cabal file?
19:02:58 <L8D> Then I'm a bit confused as to how I should go about using this feature of rest-core:
19:03:01 <L8D> http://hackage.haskell.org/package/rest-core-0.36.0.1/docs/Rest-Api.html
19:03:03 <L8D> With versioning
19:04:16 <sleblanc> I need a few pointers on Haskell's Foreign interface (FFI)
19:04:59 <sleblanc> I am messing around with the PulseAudio library and I need to build a PropList object with runtime-allocated C strings, however my understanding of IO is still a bit fuzzy
19:05:01 <c_wraith> sleblanc: was that pun intentional?
19:05:04 <sleblanc> ;-)
19:05:54 <enthropy> Pamelloes: http://lpaste.net/133286
19:06:15 <sleblanc> So I wrapped the pa_proplist_new and the required pa_proplist_sets(proplist, char * key, char * value) functions. Where I am confused is how I should generate a proplist in a pleasant manner
19:06:42 <Pamelloes> enthropy: Interesting. Is there a way I could pattern match using this?
19:07:23 <enthropy> well instead of conE you could use conP
19:09:01 <enthropy> it's rather awkward to define a case expression (caseE), but it's doable
19:09:18 <Pamelloes> Hm.....
19:10:33 <Pamelloes> I think I'm going to look into alternative options. Unfortunately, I might not have any :/
19:10:33 <sleblanc> So, how can I make this code look better: https://bpaste.net/show/f22539b4bec6
19:11:53 <enthropy> Pamelloes: what's the problem? Now you just end up with a pattern guard instead of pattern matching when you need to handle that extra constructor
19:12:52 <Pamelloes> enthropy: There's no intrinsic problem, it's just that I'm not very good at TH
19:14:52 * hackagebot file-collection 0.1.1.8 - Provide a uniform interface over file archives and directories  http://hackage.haskell.org/package/file-collection-0.1.1.8 (joel_williamson)
19:18:24 <Pamelloes> enthropy: given the type data Attr a = Attr String (Maybe a), how would I rewrite a function myfunc (Attr name _) = ... using TH?
19:18:49 <enthropy> and Attr is not exported?
19:18:56 <Pamelloes> No
19:19:28 <edwardk> c_wraith: you can use tinplate from GHC.Generics.Lens or Data.Data.Lens to derive them automaticaly
19:19:41 <edwardk> er or template
19:19:42 <Pamelloes> (it's type is actually a good deal more complicated, but if I see how to do that much I should be able to figure out the rest on my own)
19:20:10 <Pamelloes> *its
19:20:35 <c_wraith> edwardk: is it worth making a default instance in terms of Data that you can get from -XDeriveAny ?
19:21:21 <edwardk> you mean this one? https://github.com/ekmett/lens/blob/master/src/Control/Lens/Plated.hs#L221
19:21:26 <edwardk> we've had it since day 1 =)
19:21:43 <c_wraith> good to know!
19:21:56 <c_wraith> So I don't even need the manual instance..  Just an instance declaration.
19:22:01 <c_wraith> woo, saving 1 line!
19:22:06 <edwardk> yep
19:23:12 <c_wraith> does HLint hate default type signatures?
19:23:19 <c_wraith> err, DefaultSignatures
19:23:41 <enthropy> Pamelloes: like http://lpaste.net/133287 so that myfunc x | Just name <- getName x = ..., and getName is defined like that getN
19:26:46 <Pamelloes> enthropy: Alright, I can see how that works. In my case, no constructor is exported, is there still a way to do case 'A.C of ....?
19:28:07 <enthropy> then probably go with the type name, and then you have to fix up the NameSpace to DataName from TcClsName
19:29:04 <enthropy> also interesting that pattern splices are supported http://lpaste.net/133289
19:29:55 <Pamelloes> Cool, that's a lot cleaner
19:39:53 * hackagebot file-collection 0.1.1.9 - Provide a uniform interface over file archives and directories  http://hackage.haskell.org/package/file-collection-0.1.1.9 (joel_williamson)
20:02:05 <{[]}grant> Is using Haskell as a tool to reteach myself Mathematics, Algebra on up, a decent approach? 
20:02:26 <MichaelGreeves> i find 4 year old girls sexually attractive
20:03:07 <heatsink> @ops
20:03:07 <lambdabot> Maybe you meant: pl oeis docs
20:03:12 <heatsink> @where ops
20:03:12 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
20:03:35 --- mode: ChanServ set +o dibblego
20:03:38 --- mode: dibblego set +b *!*b23e9505@*.178.62.149.5
20:03:42 --- kick: MichaelGreeves was kicked by dibblego (MichaelGreeves)
20:03:47 --- mode: dibblego set -o dibblego
20:05:12 <heatsink> grant: Haskell does use some parts of math, but it's limited as a mathematical tool
20:06:41 <heatsink> For example, Haskell doesn't provide a way to check whether two expressions with free variables are equal, which is something you're frequently interested in when doing mathematics
20:08:48 <{[]}grant> heatsink: Well, that would be relatively trivial to allocate to a 3rd party system? I mean, it doesn't have to be included into the standard distribution -- I guess is there something like Sagemath for Haskell, as Python has?
20:10:25 <{[]}grant> heatsink: Is there any clear advantage (as unbiased as possible), to learn Haskell just as a mathematical learning tool over say a Lisp (I've been looking at Racket for this).
20:11:28 <heatsink> An advantage is that Haskell functions have a denotational semantics
20:11:54 <heatsink> Which is to say, the semantics of a function is given as a mathematical function
20:12:21 <heatsink> while in most other langauges, the semantics is given as commands for an abstract computer to execute
20:14:03 <heatsink> I'm not really sure how you would go about learning math by means of a programming language.
20:14:34 <heatsink> Unless it's a proof assistant like Coq, which is designed for theorem proving.
20:14:53 <sleblanc> Or another language with maths in mind such as Mathematica
20:16:01 <johnw> heatsink: you asked for an op?
20:16:21 <dolio> You can _do_ a lot of math in Haskell. You just can't do the proofs _in_ Haskell.
20:16:40 <dolio> At least, not nicely.
20:16:45 <{[]}grant> heatsink: Basically as a means to generally apply/test problems. That can obviously apply to just about any Turing complete language -- but there are some nicities of a lang over another. 
20:16:54 <heatsink> johnw: Someone was trolling, an op came and kickbanned them.
20:17:01 <johnw> ok
20:17:22 <dolio> That goes for Lisp and Mathematica as well, though. Even Mathematica isn't a proof assistant.
20:17:39 <johnw> ACL2 is a restricted form of Common Lisp that you can do math proofs in
20:17:45 <{[]}grant> I mean, Racket and/or Lisps generally, don't have the self-deemed advantage of having a traditional mathematical-like syntax.
20:18:01 <johnw> although, it doesn't grant any insight into the structure of the proofs
20:18:56 <dolio> Is ACL2 an assistant like Coq? Or does it just search for proofs you tell it to? I forget.
20:19:01 <johnw> it does all the "work" for you: (defthm plus-assoc (implies (and (natp a) (natp b) (natp c)) (equal (+ (+ a b) c) (+ a (+ b c)))))
20:19:29 <johnw> it's like a proof assistant built around the "crush" tactic in many ways
20:19:52 <johnw> the activity you engage in is not so much writing proofs, as seeding the hints database correctly
20:20:10 <dolio> That's kind of like the proof analogue of saying an untyped language is a typed language with one type. :)
20:21:06 <heatsink> grant: I don't know enough about the way you want to use a language to recommend something.
20:24:00 <hiptobecubic> Is this a GHC bug? Adding what should be a redundant bang pattern causes this to go from linear to horrific time complexity. http://lpaste.net/133293
20:24:13 <hiptobecubic> As in don't test with anything larger than about 27
20:31:19 <bitemyapp> lyonsb: definitely did :)
20:31:32 <pavonia> hiptobecubic: What compiler version and how do you compile?
20:32:32 <hiptobecubic> ghc 7.10.1,  ghc -O fib.hs
20:32:42 <hiptobecubic> -O2 has the same behavior
20:32:52 <bitemyapp> crough: was great talking to you over curry tonight, thanks again for coming out!
20:33:01 <crough> Yeah, thanks for having me bitemyapp
20:35:44 <lpaste> echo-area pasted “Failure installing text-binary” at http://lpaste.net/133294
20:35:48 <hiptobecubic> pavonia, do you see the same? 
20:35:55 <echo-area> Does this also happen for you?
20:36:08 <echo-area> *to you
20:36:22 <Pamelloes> I have a function a -> Dynamic. Is there a way I can turn this into a function f a -> Dynamic?
20:36:31 <pavonia> hiptobecubic: I don't, but my compiler is very outdated
20:36:44 <dolio> hiptobecubic: In the core of your slowfib, b isn't being evaluated every iteration.
20:36:49 <dolio> I don't know why.
20:37:08 <dolio> It is in fastFib.
20:37:28 <hiptobecubic> dolio, that's interesting. I wouldn't expect to see this massive of a slow down though
20:37:32 <dolio> hiptobecubic: If you put a ! on the _, it will be fast.
20:38:15 <hiptobecubic> dolio, in the other case? weird
20:38:18 <dolio> That's really where it should go anyway. But this is pretty strange behavior.
20:41:20 <hiptobecubic> Why should it go in the case that explicitly ignores that variable? I'd think that '!_' is pretty much never what you want
20:42:12 <dolio> Because you want that argument to be strict.
20:42:25 <dolio> Right now it's strict if the third argument is non-zero.
20:43:33 <dolio> Just being strict is better from an optimization perspective, I think. Like, GHC might know to pass it already evaluated.
20:44:43 <lyonsb> bitemyapp, Sweet.
20:44:53 <dolio> Maybe some bug or weirdness of that reasoning is causing this.
20:45:14 <_m_ryan> hi is it possible to convert IO Text to String?
20:45:21 <_m_ryan> hi is it possible to convert IO String to String?
20:45:39 <dolio> hiptobecubic: Like, 'I know the function will evaluate a, so passing b as a means I don't need to evaluate b myself.' Which is how slowFib kind of works.
20:45:54 <timothyh> _m_ryan: fmap unpack
20:46:16 <timothyh> oh
20:46:23 <dolio> But I guess that means that b has a bunch of indirections. Or something along those lines. I'm not exactly clear what the slowdown is caused by.
20:47:07 <timothyh> _m_ryan: for a subexpression, yes, with do-notation's <- or (>>=). in general, only via unsafePerformIO, which you should not use
20:47:34 <dolio> hiptobecubic: It uses no memory, so whatever it's doing, it's not building a lot of thunks that don't get reduced.
20:47:49 <_m_ryan> timothyH: can you explain it in other way?
20:48:53 <timothyh> if you post your code in lpaste I can
20:48:54 <hiptobecubic> dolio, right
20:49:08 <hiptobecubic> dolio, honestly it behaves like the naive recursive fib implementation
20:49:18 <athan> For lambda calculus expression evaluation, do you need both beta reduction and eta equivalence?
20:49:26 <athan> (or is that also reduction :|)
20:51:17 <hiptobecubic> I need to sleep. Thanks for taking a look dolio 
20:51:23 <bitemyapp> athan: alpha equivalence?
20:51:35 <bitemyapp> athan: alpha/beta/eta is the usual tripod
20:51:42 <athan> bitemyapp: I thought that was just renaming - \x -> x & \y -> y
20:51:45 <athan> hmm
20:51:56 <bitemyapp> athan: yes, usually the word "conversion" is used with eta.
20:51:57 <dolio> hiptobecubic: It's actually much slower than naive fib, somehow...
20:52:07 <athan> bitemyapp: Ahh okay :)
20:52:23 <johnw> athan: https://classes.soe.ucsc.edu/cmps112/Spring03/readings/lambdacalculus/reductions.html
20:52:31 <_m_ryan> timothyH: i got it thank you by the way :)
20:52:35 <athan> thank you johnw
20:52:41 <timothyh> _m_ryan: glad to hear it
20:53:13 <bitemyapp> athan: I tend to think of alpha equivalence as descriptive of the semantics at play with how the bound variables work
20:53:24 <greymalkin> Any users of sodium here? I'm trying to wrap my head around a good way to create an exit condition (e.g. how to stop reading stdin when the user enters 'exit')
20:53:28 <dolio> hiptobecubic: It might be good to file a bug on this.
20:53:29 <bitemyapp> athan: eta as an auxiliary bit of descriptiveness, and as beta as doing the "real work"
20:53:46 <hiptobecubic> dolio, it will have to wait until tomorrow. I'm already falling asleep :)
20:53:49 <athan> bitemyapp: Hmm, okay
20:53:55 <dolio> Okay. Night.
20:53:59 <bitemyapp> athan: given alpha/beta and the limitations of the calculus, eta is sort of a given but doesn't need to be "built in" I think.
20:54:04 <hiptobecubic> night. Thanks again
20:54:10 <dolio> Actually, maybe it isn't slower than naive fib by much. But nevertheless.
20:54:51 <bitemyapp> athan: it helps if you remember that a lot of what mathematicians want is an unambiguous normalization right?
20:54:56 * hackagebot jose 0.3.41.2 - Javascript Object Signing and Encryption and JSON Web Token library  http://hackage.haskell.org/package/jose-0.3.41.2 (frasertweedale)
20:55:49 <athan> bitemyapp: Exactly, that's where I am almost at I thik
20:55:59 <athan> I've got beta reduction fine, that's just substitution
20:56:11 <athan> I've got eta now, but I'm not sure if that's "enough".
20:56:22 <athan> Idk :\ either way I'll be surprised haha
20:56:52 <dolio> Oh no, it is.
21:00:23 <bitemyapp> athan: I don't think it's complete unless you take eta axiomatically.
21:00:46 <bitemyapp> I need to sleep tho, sorry! 7am flight
21:01:40 <athan> dolio: Awesome :)
21:01:57 <athan> bitemyapp: night man :) thank you
21:02:10 <dolio> athan: I wasn't actually talking to you. :)
21:03:21 <athan> dolio: noooooo :(
21:03:44 <dolio> However, alpha/beta/eta is all you can do if you just have lambda calculus, I think.
21:05:52 <joneshf-laptop> is there some guide about design in haskell?
21:06:03 <joneshf-laptop> refactorings, guidlines, etc
21:06:06 <joneshf-laptop> code smells
21:06:09 <joneshf-laptop> that sort of thing
21:06:48 <haasn> there's a really good linting tool that will alert you about bad code design, it's called #haskell :p
21:13:26 <Big_G> haasn, Is there actually a tool like that? I would love to have something tell me how to code
21:13:39 <haasn> there's hlint but it can only get very basic stuff
21:15:27 <EunChe> could you recommend must-have cabal packages?
21:16:23 <slack1256> EunChe: ghc-mod
21:19:12 <joneshf-laptop> the HaRe paper looks to have some guidelines
21:22:05 <slack1256> They are people interested on reviving HaRe I've heard. A mail to -cafe can get things going.
21:23:13 <joneshf-laptop> jack
21:23:13 <joneshf-laptop> pot
21:23:14 <joneshf-laptop> http://www.cs.kent.ac.uk/projects/refactor-fp/
21:27:09 <carter> dolio: nearly done moving, i'll be catching up on PRs and stuff soon
21:27:21 <dolio> Okay.
23:32:51 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
23:32:51 --- topic: set by johnw!~johnw@c-98-214-120-98.hsd1.il.comcast.net on [Tue May 05 17:23:24 2015]
23:32:51 --- names: list (clog marek_varro Paradisee vili luyifan_ dmj` rnons1 southp kp666 tibbe johtso_ grizwako rossm silvycap]] [mad] path[l] blue_feint vlatkoB fishburne529 nonny_t jludwig bogdanp pheaver simg Bhavya cyborgIone djapo jonmorehouse irobevjodu tyfighter calvinx fujimura plutoniix Azel lritter virtualeyes andyo gfixler1 jack_rabbit crobbins zariuq hilquias aarvar michaelneale Palmik neuroserpens EvilPenguin ThatOtherPerson CurryWur_ grouzen [42]1 Welkin shadowcreator)
23:32:51 --- names: list (c_wraith cleamoon Shirakawasuna fuzzyhorns gsingh93 Swizec ddellacosta_ tmillc P1RATEZ kaictl L8D xacktm rwiggins otto_s_ don_g Pastaf beauby tranma mauke greenbagels tvh bb010g PyroPeter araujo EunChe bluesnow oscar_toro DuoSRX turtil eisbehr {[]}grant kadoban PragCypher m00nlight centrinia Denommus Jeanne-Kamikaze babu carlo_au Stratege____ dsantiago tombert1 darkf Goplat _m_ryan alexclark DerisiveLogic vmeson danielcompton Lokathor pavonia enthropy)
23:32:51 --- names: list (hattusili_III HoloIRCUser4 paulrd psy_ echo-area godel hive-mind darkbolt emanuelz iamd3 MitchW ElectricSolstice ev` bogdanteleaga pflanze bjz hexagoxel lspitzner exferenceBot predator117 Zekka djbeau pacak greymalkin SCHAAP137 Epichero fiddlerwoaroof enaqx jophish__ indiagreen ruukasu asthasr skeet70 joeyh banister felixsch Natch solatis A205B064 Khisanth semberal Or1 augur rcyr negatratoron cognominal SoupEvil theorbtwo amatsu ellipsis_ s00pcan rkazak mada)
23:32:51 --- names: list (peddie ellinokon fergusnoble ropav Encapsulation Sornaensis obadz grpala Coldblackice dan_f descender nocturne777 Pamelloes lili magneticDuck amiri Soft pavlicek dreixel BillyIII codesoup ksf tpsinnem irrummi Tesseraction xahry edwinvdgraaf vital Rutger` netj homovitruvius Ulrar catsup harski jmcarthur freusque Kneiva capisce keaml srcerer_ stoopkid hexhaxtron mimi_vx fractalcat Friendly_Nihilis ahihi Wamanuz tomaw Qfwfq bcoppens Gothmog_ gienah noodles1)
23:32:51 --- names: list (sushito jix teclo- Willis Josetalito MrWoohoo splint28 agumonkey Polarina renekooi Hijiri CADD whiteline lyonsb lnr junmin sabalaba sudog boxfire MultiPurposeHat dropdrive PlasmaStar zerokarmaleft rofer Fran__ Orwell84 _ikke_ levi Tordek sivoais sebastard _fritz_ Cale fredsir_ Moggle lf94_ osfameron kmicu phadej_ nuncanada aidanh scpike LnL lvh cjh` doctorin1 Boney jang2 dgorbik_ dmiles_afk knyppeldynan Hail_Spacecake cyphase kstuart inquirydog tinchos bergey)
23:32:51 --- names: list (henryhere mecalopolis tusj whaletechno arjanb favonia ClaudiusMaximus kyren abrar Nik05 Oxyd jordanl YellowOnion jonesinator DenSchub emma blast_hardcheese bens iambernie n1cky sagittarian gsnewmark mietek sokoll srhb Sonderblade miklcct chishiki besenwesen malthe milessabin cronject stiell sw1nn hackagebot Thra11 DrAwesomeClaws permagreen thetallguy Nimatek lrocksmashtime1 nak demilux hiratara jlamothe armyriad haknick joneshf-laptop pfurla dgorbik-)
23:32:51 --- names: list (bencryption Ralith zilinc CapitalSigma joedevivo alexlord jfokkan avdi CARAM__ tarcwynne ryantm lambdahands poikon cjheath akurilin Svedrin m4lvin eazar001 anders^^ ndreas davidstone donwilliam adarqui Rotaerk OutlawStar tuv _ashbreeze_ MoALTz Enigmagic mceier CMCDragonkai gfixler yrdz prsteele alevy sigfig Longlius zacts rien__ mmaruseacph2 melter rossberg condy Laquendi quaestor mak` ew0000 tekacs josephle thunderrd Zemyla samnmax DT-sama bsrk hvr ollef)
23:32:51 --- names: list (infinity0 tv asjo bernalex derekv maerwald aloiscochard elben bdamos` sorind julienXX zhost nwf naudiz Guest6655 newsham mrsolow sdx23 kandinski terlar Cerise vin-ivar zimbatm Guest834 z4zz weyanus Myrl-chan jarvi subleq__ fengshaun flaiw verement niklasb rui tromp__ HylianSavior fikusz ReinH bartavelle Belgarion0 WSergio noteventime f_x z16 tessier ThePhoeron solarus meretrix gniourf rubix DRMacIver thomassgn thorkilnaur_ Eiam jvd karlpinc martingale jml)
23:32:51 --- names: list (jrslepak jo__ prkc thoradam ronh- totte alang yac davl maskd Sorella jessicah denimuser honza BrianHV anastas anthezium bijumon ixian agrif wjm mikeizbicki stelleg sajith mirsal ilmig low-profile derillium ubuntor phaskell ahlias niko bjorkintosh seancorfield jud dju TDJACR Jellydog peterhil Nadrieril lachenmayer gpampara zeiris andjjj23 Dynetrekk tristero eevar kidnapped_robot bbee Voldenet hiberno RevJohnnyHealey oherrala zasimov cscorley luzie ernst)
23:32:51 --- names: list (eamelink tdammers Baughn FreeFull d-snp `micro vodkaInferno fionnan KitC spion tlevine Dodek supki shiona Freundlich jlind zyoung chirpsalot Chobbes PotatoGim xificurC ryanakca bsummer4 cstrahan nurupo steshaw ocharles_ clarktic ctag heurist rslima nominolo|work lohkey proycon xeno_ codyopel AndreyG AlainODea ortmage tmtwd jakutis haroldwu n1ftyn8 bkolera ehamberg hpd dcoutts bshelden cojy_ themagician hellschreiber thade MK_FG aristid KeelOfSteel lamilami)
23:32:51 --- names: list (ps-auxw kjnilsson AustinMatherne JZTech101 orion sleblanc hamishmack tismith namuromus burp ForNeVeR etandel_ adamse dgonyeo- dgonyeo cbaines seagreen creichert RayNbow`TU krgn fryguybob xelxebar xxpor saulzar Internet13 ValicekB rien lifenoodles marko mitchty Fylwind martinbmadsen Zanzare folsen RGamma linduxed andreypopp sabauma Artpicre wolf_mozart saurik hongminhee agatam Pucilowski shahn byorgey haBuu^ lambdabot maurer divVerent ghorn mendez falafel)
23:32:51 --- names: list (martintrojer nille mountaingoat obcode kakos sakirious aweinstock avn pikhq malllle robogoat saep kemitchell bergmark rjsalts fyolnish drmegahertz rieper_ Axman6 spindas tswett David int-e esssing xnyhps Intensity amiller mitu f|`-`|f Brando753 electrogeek kjanosz C4Cypher Guest14567 wagle dexterph tjbp ikke kini Draconx bjornars kfish padre_angolano chriswk phy1729 Cathy edofic incomprehensibly pgorla phuu Heero stasku idnar spdionis S11001001 Xorlev pdxleif)
23:32:51 --- names: list (hemite andreass liste monochrom TRManderson tomku blenny hpc aaronm04 horlicks zaquest mgomezch mikel td123 SegFaultAX joshc zalami jaffachief hsyl20 u-ou jophish rhaps0dy inr benonsoftware lassulus DANtheBEASTman stass dabradley dlundy ljhms tgeeky dibblego CaveJohnson spaceships ajf atomi max-m studentofstones sLite Draggor ibid coeus_ mhi^ dewdrop Erebe ScRaMbLe lacrosse__ lancetw yrashk Tritlo alekst_ zrl mrb_bk c9sould__ reem darkowlzz|afk killerpty)
23:32:51 --- names: list (Klumben chris2 cjwelborn ephemeron drewdavis Forkk Dykam waxjar grol cschneid carter jzl ij Vbitz huonw SLi mudphone zhulikas staffehn Bigcheese coyotebush mozzarella flxx cursork gnusosa sm xplat liyang Guest69973 nisstyre Hugglesworth Xe jmct xaxes` gws Twey `0660_ yarou ido dolio edwtjo cin tomjaguarpaw Tiktalik drone| reduceleft schlumpi Eagle_Erwin troydm mrd__ Xnuk_ brixen dawik Rastus_Vernon alynn SwashBuckla Walther dschoepe heaumer_ mgaare Taneb)
23:32:51 --- names: list (Ornedan_ kgadek tuturto itsmonktastic JamesJRH luite aupo lodvaer jkarni1 KorriX simonnn_ lyddonb jokra_ kav mrowe chuy ]OLI[ psacrifice somenick bydo anachron CosmicRay bsmt irishsultan reynir paf31_away jackhill nuttycom happy0 suvash_away _di dustinm notdan tromp_ cdidd certainty kwantam sdboyer joehillen benbangert sunnavy nekomune serutsubi Guest62337 cbm80 wtw taruti martinhath jaspervdj djh nyuszika7h _flow_ Hafydd larsen_ mjrosenb defanor marens)
23:32:51 --- names: list (stbuehler jcurbo runde hiredman Ankhers tomboy65 diginet lykkin janne kqr rseymour GGMethos dan64 zyla dmilith arkeet comboy greeny abh dp_wiz jameseb ndeine Desoxy_ yorick Jaak_ frontend1oader petercommand TheRealPygo eyem_ machines1earn eyck_ iross_ nopf sku1d cmn haasn kosmikus brezel perrier constantinexvi radens marmalodak albel727 jokester cross opqdonut adimit fold Th0mas rbocquet lsep irclogger_com pieter_ voidzero hator argoneus lokydor sea-gull)
23:32:51 --- names: list (comma8 WarzoneCommand ElderFain Elision tumdedum hbar Geekingfrog Athas killtheliterate mephx samertm brolin_empey unknownloner AntiSpamMeta EnergyCoffee ft geekosaur sweenzor oberstein earthy Vorpal helgar ChristianS kipras mt taksuyu kess sohum dougia otterdam kvalle heath rom1504 otulp mach statusfailed ChongLi ousado pingu thoughtpolice nesqi kvieta bananagram hodapp dxld xandaros rabisg kloeri uwap dilinger frawgie mtbottle Igloo saiam_ bob_twinkles)
23:32:51 --- names: list (ziman michaelpj_ Juka_ fugyk brennie goldfire1 DustyDin1o pi8031 larocca tg nik_89 dqd gridaphobe proq Crate_ technomad_ jtanguy posco xpika oconnore buoto przembot pharpend barrucadu jtobin Kruppe fnordbert liff vikram_ zpconn__________ swen shennyg theDon Tristan-Speccy flori_ mystor fuziontech aseidl valdyn integral sephiap fling jle` cow-orke1 SparkySparkyBoom gabiruh fvgvxmpv1 suls ParahSailin the-kenny johnw timothyh Sqt robotbrain otherchas_)
23:32:51 --- names: list (kirjs_______ dlackty___ etrepum nrw ninegrid ricardo82 Vq apo_ sinopeus conehead rdema benwf simon ttuegel phaazon d3lxa rewzn imalsogreg gdsx julmac LQYMGT yusukesuzuki dino- da-x deni thomas koomi so marienz ezrios MasseR solirc eagleflo ivan\ natte surtn Factionwars fall` pleiosaur koala_man lyxia zso__ bjobjo sys9mm Trubydoor nitrix LeaChim Floyd_ unsymbol spwhitt keko_ karls ggVGc samgd kaol noctux korpse_ Haskellfant SaidinWoT ion SHODAN bdha lemmih)
23:32:51 --- names: list (wrengr_away stomp Tene edk tridactyla Maxdamantus sclv NemesisD dkua mbrcknl arnihermann milli relrod si14 bigs jabbslad_ bcarrell jonrh mindos_cloud____ bcavalier cloudhead_ jroesch heyj tomphreek nem_z gibbers scopedTV dunj3 mero guampa etabot zq poucet_ sleepynate Laney zenzike corso lenstr Adeon arrdem flux mortberg biscarch doppioslash bgyss lpaste ackthet nakal pii metaf5 igniting klugez pm5 djanatyn arw skarn Saizan davesilva_ vladan foolie pranz)
23:32:51 --- names: list (froztbyte absence Ezku_ theorb_ gargawel_ stvc Phillemann optocoup1er zymurgy s4msung hc LordDeath Fubar^ Lutin` rj-code Reisen mankyKitty jnoah init mno2 Elsi cryon sellout- deavidsedice seabre kalz akahn moy zph owa lispy sgronblo tzaeru puzza007 Schrostfutz rola grohne therealklanni demolithion alanz MMuse_______ alphonse23_ nbouscal trig-ger dstockwell andrewsw wizonesolutions caasihuang pyrtsa duairc bitemyapp znutar shapr brackets hooptw ZsoL XMunkki)
23:32:51 --- names: list (eddsteel aatxe Liskni_si AWhetter dario` kaw_ hrnz kalloc avocado ajp kloplop321 thomie ephess karshan lpsmith TallerGhostWalt mokus_ SuperTux88 Preyer magicman sbrg kriwil enomies JPohlman1 averell e4x malglim adnap enojelly anoe Ring0` hegge hyPiRion edwardk abbe yminsky brent80_plow uber RageD ircbrowse brisbin raid codehero Blkt Guest90609 tolt jacksnipe devJunk fall_ sdressel wenzowski zero7 carter_cloud alpounet cowtown bolmar rtl dredozubov mechairo`)
23:32:51 --- names: list (noplamodo DanZimm geal sagelywizard amontez Nanar jayne ggreg niluje Clint betawaffle davean gbarboza sujeet yukonjack kennyp nikola AshyIsMe Ptival adlan yeltzooo9 gtklocker CindyLinz sbauer322 dicioccio numberten cYmen_ annulus FireFly Jello_Raptor pmade cynick GaveUp asm89 heikkih elgot Chousuke KaneTW Mandus xaimus mikeplus64 majoh Watcher7 ckw Heffalump callumacrae mikedanese Eldrad ggherdov Raynos xxx zxtx Rembane tazjin twopoint718 Ke Starfire _klm)
23:32:51 --- names: list (Paks eL_Bart0 rudi_s mlen plhk Dtgr mads- dowski_ zomg hanDerPeder monty Jonno_FTW JonasH__ emmanueloga shelling__ DigitalKiwi Fuuzetsu mpickering kungp rs0 senseibaka dpn` mami kazawore_ zeroskil1or seanparsons pfoetchen alem0lars jlouis ahf jlyndon jrp6 fmapE Razz Boreeas tych0 howard kragniz tero- arch_ edran_ @ChanServ Atlanis Deewiant eyenx lieven Spockz obiwahn tnks paperManu delimax dmead Bane^ _ether_ theanalyst ice799 canta M-ou-se mjo tomprince)
23:32:51 --- names: list (tsani gcollins seliopou Reyu Philonous benedikt Sagi lahwran mniip _6a68 acfoltzer vikraman Adios dzack bonobo_ TimWolla usr Paprikachu eivuokko shmookey1 aaron7 statusbot nemesit|znc runeks wayne __main__ spacebug maw Jaxan Nickeeh xintron drdo dh jlewis javawizard sw00pht japesinator c-rog_ IbnFirnas eikke qz joehh PHO cpa BlakeRain cjay ski joeytwiddle gratimax Uritomi2 gseitz myst|work juri_ rossimo pfeyz Tehnix neptunepink dabukalam glowcoil robbert)
23:32:51 --- names: list (isomorphismes petantik Tazca keix pharaun monsieurp Phlogistique ec\ cods Sigyn isocliff ByronJohnson friden platz lattenwa1 jstolarek lokodo Profpatsch klarrt Eliel sternenseemann mattp_ arianvp myme gbiv Plastefuchs R0b0t1 benzrf banjiewen crlane devi)
23:34:58 <fishburne529> johnw, Ok. I don't really understand. But I ll look that up.
23:45:03 * hackagebot topkata 0.2.4 - OpenGL Arcade Game  http://hackage.haskell.org/package/topkata-0.2.4 (ChristophBauer)
23:48:47 <mjrosenb> gah, is there a reason ghc doesn't bundle all old versions of base?
23:50:16 <kadoban> Isn't base actually part of each GHC version? I don't think it'd be as simple as bundling them all.
23:51:00 <enthropy> a few years ago (6.12 maybe) some ghcs had two bases
23:52:26 <mjrosenb> https://gist.github.com/4f91dad8038fcef280f1
23:52:29 <mjrosenb> gah...
23:53:22 <enthropy> but if you're changing classes, there doesn't seem to be a nice solution to expose a base-4.8 and a base-4.6 (say)
23:53:38 <mjrosenb> kadoban: even so it shouldn't be /that/ difficult to have the older versions available.
23:53:44 <mjrosenb> enthropy: changing classes?
23:54:16 <enthropy> mjrosenb: say Monad having or lacking an Applicative m =>
23:54:50 <enthropy> so do you have the base-4.6 that comes with ghc-7.10 include a different Monad class?
23:55:19 <enthropy> so you can't have code that uses both bases
23:56:20 <enthropy> or do you not-really-emulate that older base and export the same Monad class from both base packages?
23:56:28 <mjrosenb> sure, why not?
