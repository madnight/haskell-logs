00:07:40 * hackagebot path 0.0.1 - Path  http://hackage.haskell.org/package/path-0.0.1 (ChrisDone)
00:07:40 * hackagebot path 0.1.0 - Path  http://hackage.haskell.org/package/path-0.1.0 (ChrisDone)
00:11:54 <Fylwind> what do you guys think of this diagram for the numeric typeclasses? was thinking of adding it to the wiki for newcomers https://folv.es/GM9f38awP4EMD9in9bS-cw.png
00:17:35 * hackagebot aeson 0.8.1.0 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.8.1.0 (BryanOSullivan)
00:20:33 <mattby> Fylwind: it's quite complicated
00:21:22 <ellwyne> Fylwind: it looks pretty useful, i'm a newcomer
00:24:43 <Fylwind> mattby: yeah it is :( that was my main concern, not sure how it can be simplified further without losing the essentials
00:28:59 <Fylwind> slightly tweaked to make the conversions a little clearer (I think): https://folv.es/s1k8tlAcT6DH3a0J6kw-Uw.png
00:37:16 <ThibaudDauce> join #haskell-web
00:42:44 * hackagebot bitcoin-script 0.11.1 - Compilation, manipulation and decompilation of Bitcoin scripts  http://hackage.haskell.org/package/bitcoin-script-0.11.1 (solatis)
00:42:46 * hackagebot ide-backend 0.9.0.9 - An IDE backend library  http://hackage.haskell.org/package/ide-backend-0.9.0.9 (MichaelSnoyman)
00:43:56 <knite> I have a simple Tree structure and I'm writing insert(). my type signature is insert :: Tree a => a -> a, and as a stub, I have insert = id. this fails to compile with error: "Expected a constraint, but ‘Tree a’ has kind ‘*’". I
00:44:08 <knite> 'm having trouble Googling this, what on earth is type *?
00:44:47 <safinaskar> knite: "*" is kind
00:44:57 <safinaskar> knite: how you "Tree" is declared?
00:45:05 <safinaskar> knite: "data Tree a = ...", right?
00:45:05 <mattby> Fylwind: http://www2.informatik.uni-freiburg.de/~thiemann/haskell/haskell98-report-html/classes.gif is not that bad. It just has too much information and misses the conversion functions
00:45:26 <knite> safinaskar: with newlines removed to paste here: data Tree a = Leaf | Node Integer (Tree a) a (Tree a) deriving (Show, Eq)
00:46:07 <safinaskar> knite: okey, so "Tree a" is datatype and not constrant. so, you should write "insert :: Tree a -> Tree a" and not "insert :: Tree a => a -> a"
00:46:42 <knite> safinaskar: hm...I don't quite understand the difference? why is Tree a => ... wrong?
00:47:44 * hackagebot ide-backend-common 0.9.1.1 - Shared library used be ide-backend and ide-backend-server  http://hackage.haskell.org/package/ide-backend-common-0.9.1.1 (MichaelSnoyman)
00:47:44 <safinaskar> knite: "*" is a kind, you can read about kind here: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#kinds-and-some-type-foo (but currently our problem is not about kind)
00:47:54 <safinaskar> knite: in fact, the whole book is great :)
00:47:58 <knite> I have a Tree of a certain type of thing, I want to accept Trees of that type and output Trees of that Type. so Tree a => a -> a makes sense.
00:48:08 <MP2E> knite: => is used for typeclasses, Tree isn't a typeclass, Tree is a datatype parametrized on other types
00:48:09 <safinaskar> knite: and now i will say the difference, wait a minute
00:48:46 <knite> MP2E: I'm ~2 weeks into Haskell, that went over my head, could you rephrase?
00:48:58 <knite> (experienced Python dev)
00:49:34 <Cale> knite: You probably want  Tree a -> Tree a
00:50:06 <knite> Cale: right, I get that that is correct, I'm trying to understand why my intuition with Tree a => a -> a was incorrect.
00:50:07 <Cale> Tree a => a -> a   means "if a is some type which is an instance of the Tree type class, then this function takes a value of type a and produces a value of type a"
00:50:22 <Cale> Tree is just unlikely to be a type class, though it could be
00:50:44 <Cale> Type classes are not like OO classes, they're more closely related to what Java calls interfaces.
00:52:08 <safinaskar> knite: "Tree a" is a type. type is type of values :). so, we can say that 2 has type Int. but Eq, Ord etc are classes. they are something like type of types or collections of types. if we want to say that "f :: a -> a", but this "a" should have type class "Eq", we will write "f :: Eq a => a -> a"
00:52:29 <rasen> Does someone has an example of using TreeCtrl in wxHaskell? I just can't get how to populate it with items
00:53:34 <safinaskar> knite: your "Tree" is not a typeclass. i. e. you Tree is not like Eq. your Tree is something like function (it is type function) which takes one type and returns another type. so, Tree is type function of kind "* -> *"
00:54:16 <knite> safinaskar: oof. this seems like an important but tricky difference to grok.
00:55:09 <merijn> safinaskar: I actually don't think "type of types" is a good description for "type classes", because *kinds* are type of types...
00:55:31 <merijn> knite: Personally I think it's most helpful to think of type classes as constraints on types
00:55:59 <merijn> knite: i.e. "foo :: Eq a => a -> a" can be read as "IF 'a' is an instance of 'Eq' THEN 'foo :: a -> a' ELSE type error"
00:56:28 <merijn> oh, I should read more backlog before jumping in :p
00:57:16 <safinaskar> merijn: yes, you are right (about kinds)
00:57:26 <knite> merijn: that's no good, it takes me back to the begin. that's exactly what I want to say: if a is an instance of Tree, then foo :: a -> a else OOPS.
00:57:30 <knite> to the beginning*
00:58:32 <safinaskar> knite: type is some concrete, fully defined thing. type functions, i. e. entitiles of kind "* -> *" (like you Tree) is fully defined thing, too. but type classes are not fully defined things. they are really like java interfaces. they are just describe some properties of a type
00:58:42 <merijn> knite: The thing is that I just noticed safinaskar's comments and saw that Tree is not a type class
00:58:55 <merijn> knite: Type and type classes aren't the same thing
00:59:04 <arianvp> Could someone proof-read my blogpost? Just checking if I don't make any big mistakes: http://arianvp.me/writing-interpreters-and-compilers-an-introduction-to-folds-and-algebras/
00:59:10 <merijn> knite: Type classes are "meta-properties" of types
00:59:24 <merijn> knite: A type class tells you some information ABOUT a type
01:00:00 <merijn> knite: Can you link your original code? I joined after that
01:01:12 <safinaskar> knite: haskell is just have such syntax: if X is class, you can write "X a => a -> a". if it is type of kind * -> *, then you should write "X a -> X a"
01:01:40 <knite> merijn: I'm working through some introductory Haskell materials. I have data Tree a = Leaf | Node Integer (Tree a) a (Tree a) deriving (Show, Eq) and tried writing insert :: Tree a => a -> a, which you all are saying must instead be Tree a -> Tree a, and I'm struggling to understand why the latter is correct and the former is incorrect.
01:01:48 <Haskellfant> arianvp: looks good to me (nice blogpost btw), but I am no expert
01:01:52 <safinaskar> knite: and if X is class, then you cannot write "X a -> X a", because "X a" itself is not a type. "X a" is somewhat a sentence "a is X"
01:02:42 <safinaskar> knite: so, in short, if X is a class, then "X a" is not a type, this is just statement "a is X". if X is type of kind * -> *, then "X a" is a type
01:03:00 <merijn> knite: Ok, a couple notes
01:03:09 <knite> arianvp: article needs to be spell and grammar checked. for example, lets -> let's, arithmatic -> arithmetic.
01:03:22 <merijn> knite: Let's ignore the mistake of mixing typeclasses/types and focus on a more fundamental issue
01:03:57 <merijn> knite: Since in haskell all values are immutable, you can't "really" insert a value into a tree, that only thing you can do is return a new tree with the value inserted
01:04:21 <merijn> knite: From which we can conclude that the return type for your insert function should always be a "Tree a", no?
01:04:51 <merijn> knite: btw, have you programmed any languages other than haskell? 
01:05:11 <jle`> arianvp: i like it :) short and gets to the point
01:05:18 <safinaskar> arianvp: hi. i am started reading your blog
01:05:25 <safinaskar> arianvp: *your article
01:05:35 <safinaskar> arianvp: s/arithmatic/arithmetic/ :)
01:05:40 <knite> merijn: not quite. because I had understood Tree a => in a type signature to in effect be a substitution. so, Tree a => a -> a === Tree a -> Tree a but more legible.
01:06:17 <knite> merijn: yes, I mentioned above that I'm an experienced Python dev.
01:06:33 <safinaskar> arianvp: s/subtracted/substracted/
01:06:46 <safinaskar> arianvp: well, please check your article for typos first :)
01:07:00 <merijn> knite: No, => is not a substitution
01:07:10 <knite> merijn: apparently not. :-P
01:07:13 <merijn> knite: Like I said, "X a => a" is a meta-statement about the type 'a'
01:07:46 <merijn> knite: "Eq a => a" is saying "any type 'a' provided 'a' is an instance of the Eq type class"
01:08:00 <safinaskar> merijn: knite just said this: "data Tree a = Leaf | Node Integer (Tree a) a (Tree a) deriving (Show, Eq)"
01:08:25 <merijn> safinaskar: Yeah, I know, but I'm trying to find solid ground to explain from first :p
01:09:28 <merijn> knite: A type like "insert :: a -> Tree a -> Tree a" says insert takes an 'a' and a 'Tree a' and returns a 'Tree a'
01:10:24 <merijn> knite: But "foo :: Eq a => a -> Tree a -> Tree a" says that foo "takes an 'a' and a 'Tree a' and returns a 'Tree a' ONLY IF 'a' is an instance of 'Eq'", that is only if we know how to compare 'a' for equality
01:10:28 <arianvp> safinaskar: Thanks. will do. I'm dyslexic and non-native. So I tend to just oversee such typos
01:10:51 <jle`> arianvp: does whatever platform you are using to edit offer a spell check feature?
01:10:55 <merijn> knite: So constraints like "Eq a" restrict which types 'a' is allowed to be.
01:11:47 <merijn> knite: Actually, to make a python analogy you could think of it as statically checked typing. Where "Eq a" is equivalent to a python class implementing an __eq__ method (at least, I think __eq__ is what's used for ==, right?)
01:12:04 <merijn> s/statically checked/statically checked DUCK
01:13:15 <knite> so using similar language, what is the difference between "Tree a -> Tree a" and "Tree a => a -> a". the former seems to say "take a 'Tree a', produce a 'Tree a'", and the latter seems to say "if a is an instance of Tree a, produce an a". which sound the same in English, so I suppose I'm still not getting how they're different in Haskell? I'm feeling pretty frustrated, you (and safinaskar) are trying to help, but I'm just not get
01:13:16 <knite> it.
01:13:22 <merijn> knite: With python's ducktyping you would expect it a function like "def foo(x, y): if x == y: return 5; else: return 10" to work for any class that implements __eq__, right? In haskell the "Eq a" annotation just tells the compiler that at typechecking time
01:13:56 <merijn> knite: Typeclasses, despite the word class confusing OO programmers are completely and utterly different from datatypes
01:14:06 <knite> merijn: let's ditch the deriving portion, that's just icing on the cake. we could just as well say Foo a -> Foo a vs Foo a => a -> a.
01:14:53 <jle`> so Eq a => a -> a -> Bool means something like, this function is defined for types `a` where `a` has an (==) method defined
01:14:55 <merijn> knite: So the reason why you can't say "Tree a => a -> a" really boils down to "you can only have typeclasses left of the =>" and "Tree a is not a typeclass"
01:15:19 <jle`> Eq a -> Eq a -> Bool means something different, if you wrote it.  It'd mean that it takes "a data structure called Eq which is parameterized on a" and returns a Bool
01:15:19 <safinaskar> arianvp: very good picture about using apostrophe: http://theoatmeal.com/comics/apostrophe
01:15:26 <_fritz_> hmh, wow, implementing dijkstra's algorithm with the correct interpretation of the process is just simple
01:15:40 <jle`> there's a difference between "a data structure named Eq", and "something that has (==) defined on it"
01:16:01 <jle`> "Foo a" in the second case is a specific type...like Int, or Bool, or [String], or Char
01:16:13 <merijn> knite: I think the confusion is coming from you conflating the term typeclass with something more like python classes, since in python classes are how you define datatypes
01:16:26 <jle`> Eq a => ... means that, "wherever you see 'a' in the following part of the type signature, it means that a implements (==)"
01:16:59 <jle`> "instance" here also means something different than it does in python
01:17:16 <jle`> in Haskell, Int is an instance of Eq, because Int's have (==) defined on them
01:17:33 <jle`> so if your function is foo :: Eq a => a -> a -> Bool, then i can do `foo 10`
01:17:34 <safinaskar> knite: 1. "X a => a -> a" and 2. "X a -> X a" are different things. because in 1 "X a" is statement "a is X", i. e. "a belongs to class X" and in 2 "X a" itself is a type
01:17:46 <merijn> knite: Let's look at a simpler type for a bit (because I'm too lazy to type out all of Tree all the time) like "data Maybe a = Nothing | Just a"
01:17:46 <jle`> because 10 is an Int, and Ints are things that have (==) defined
01:18:07 <merijn> safinaskar: I would say "a is an instance of class X" over "belongs to"
01:18:35 <knite> merijn: okay, that actually helps. I get that data constructors are different than type constructors, even if I'm still internalizing that difference. so => constrains types, but I was trying to constrain a data constructor instead? so Node a => a -> a or Leaf a => a -> a would be valid, because Node and Leaf are types in my data definition, but Tree is...sort of a parent metaclass, and that's why I need Tree a -> Tree a?
01:18:53 <jle`> Node a doesn't constrain a to be a Node type
01:19:07 <jle`> Node a means that a "implements" the methods that the Node typeclass requires
01:19:40 <jle`> so MyClass a => a -> ..., it doesn't mean that a is of type MyClass.  it means that, somewhere, you have said, "any type that is an instance of MyClass must have some certain functions defined in it."
01:19:55 <jle`> so that means that you can use those defined functions on your `a`
01:20:00 <Fylwind> knite: "Tree a -> Tree a" means "give me concrete Tree of some type and I'll give you a concrete Tree of the same type", whereas "Tree a => a -> a" means "give me something that is Tree-like and I'll give the same kind of thing back"
01:20:19 <jle`> `foo :: Eq a => a -> a -> Bool`, means that `a` has to have (==) and (/=) defined on it.
01:20:33 <jle`> a can be *any* type that has (==) defined for it
01:20:33 <merijn> knite: Tree is not a "parent" or "metaclass", what "data Maybe a = Nothing | Just a" says is that there are 2 ways to construct a value of type "Maybe a" and those two ways are "Nothing :: Maybe a" (Nothing can be ANY type of Maybe a) and "Just :: a -> Maybe a" Just takes a value of type 'a' and produces a 'Maybe a'
01:20:49 <merijn> I think everyone is repeatedly typing the same thing which isn't really helping anyone
01:20:51 <jle`> `foo :: Tree a -> Tree a -> Tree a` only works on a specific type, the `Tree a` type
01:20:57 <Fylwind> knite: the confusion might be because you are using the identifier "Tree" to mean two different things: in the first example, "Tree" is a data type, in the second example, "Tree" is a contraint (type class)
01:20:57 <jle`> yeah, i'll just cut out :)
01:21:00 <safinaskar> knite: "Tree a => a -> a" is not saying "if a is an instance of Tree a". first of all, "a" is a type here and not a variable. then, it says "if type a is type of class Tree"
01:21:41 <liste> knite I learned typeclasses best by implementing (an explicit version of) them myself
01:21:52 <knite> this is like the opposite of most IRC channels, too many people trying to help instead of too few. give me a minute while I re-reread and see if it makes sense.
01:22:01 <merijn> I also think that the real problem here is not typeclasses, but a misunderstanding of data type definitions, so repeating typeclass explanations is not really helping
01:22:27 <liste> I like to think of typeclasses as implicitly passed records of functions
01:22:42 <Fylwind> Fylwind: data types are just like the same things you find in Python (int, list, etc) albeit more complex, constraints (type classes) are something entirely new: they make claims about what features a given type supports or not, so you can think of it as "duck typing made more rigorous" if you will
01:22:43 <merijn> liste: This isn't really helping the fundamental issue here, though
01:22:56 <Fylwind> I replied to myself, yay
01:23:14 <Fylwind> knite: that previous message was for you btw
01:23:44 <merijn> knite: Ok, let's ignore most of the backlog and try again from a more basic point without too much stereo explanations
01:24:11 <merijn> knite: Let's start with datatype definitions and start with a really basic one. "data Bool = True | False"
01:24:24 <knite> merijn: one sec, I'm going to rephrase and see how that goes over with you guys.
01:24:39 * knite wishes IRC had a "..." typing indicator.
01:24:45 <safinaskar> knite: Node a =>... etc of course will be invalid. "Node" and "Leaf" behave like a normal functions. you can type ":t Node" to ghci and see that they are functions
01:24:56 <safinaskar> knite: and they are not types
01:25:05 <merijn> knite: This is defining a new type "Bool" and says that there are two possible ways to construct a value of type "Bool", the constructor "True" and the constructor "False
01:25:37 <merijn> safinaskar: Right, but just saying "they're not types" doesn't make clear what the distinction is
01:27:43 <safinaskar> knite: Node and Leaf are functions. "Tree a" (for every concrete a) is type, just a normal type. "Tree" is type of kind "* -> *", i. e. this is a function, which takes type "a" and returns type "Tree a"
01:28:58 <safinaskar> knite: first, if you write "data Tree = Node Int | Leaf Tree Int Tree", then "Tree" is a type, and "Node" and "Leaf" are functions. and you can write "insert :: Tree -> Tree"
01:30:30 <knite> okay...let me try to state this in my own words and see if you guys object.
01:32:26 <_m_ryan> hi is anyone here knows about yesod. i would like to ask somehelp about my code: http://lpaste.net/132367
01:33:21 <merijn> _m_ryan: There's also #yesod, although I dunno how active it is
01:33:56 <_m_ryan> merijn: i also ask some help there. but still waiting for someone to help me..
01:34:50 <Cale> latestPrices :: Model [RawPrice]
01:34:50 <Cale> latestPrice = 
01:35:01 <Cale> You seem to be missing an s
01:35:15 <knite> okay, so https://wiki.haskell.org/OOP_vs_type_classes in section 2, "Type classes is a sort of templates" helps a bit also.
01:35:47 <Cale> That's a very weak comparison, but okay
01:36:33 <_m_ryan> Cale: ah i didn't notice. i will check it :)
01:36:41 <Cale> knite: So, I assume you've already learned about parametrically polymorphic functions, like  length :: [a] -> Int  which can operate on any type of list because it has no need to inspect the list elements
01:37:08 <Cale> Or even  map :: (a -> b) -> [a] -> [b]  which can transform one type of list to another by applying a function to all the elements, without having to look at those elements itself
01:37:47 <safinaskar> arianvp: "SUB -- similrary but subtracts" - write what from what exactly you substract
01:37:52 <Cale> knite: But what about, for instance, a function which sorts a list?
01:38:37 <Cale> knite: We might hope to be able to sort many different types of lists, but a function of type [a] -> [a] is not allowed to inspect the elements of the list it's given at all, and in particular, it has no means of comparing them with (<) and such
01:38:43 <safinaskar> arianvp: s/data ExprAlgebra  e= ExprAlgebra/data ExprAlgebra  = ExprAlgebra/
01:38:49 <_m_ryan> Cale: thank you, ther first error was now solve. but can you help me about the last error about the model?
01:39:05 <knite> Cale: go on, that's crystal clear so far...
01:39:06 <Cale> _m_ryan: That one I have no idea about. It means there's no type named Model which is in scope.
01:39:51 <Cale> knite: Okay, so in Haskell we have this system called type classes which allow us to restrict the set of types over which a type variable ranges
01:40:32 <Cale> We have, to give some examples...
01:40:34 <Cale> @src Eq
01:40:35 <lambdabot> class Eq a where
01:40:35 <lambdabot>     (==), (/=) :: a -> a -> Bool
01:40:35 <knite> Cale: so by saying Eq a => [a] -> [a], we're guaranteeting that comparison is possible?
01:40:44 <Cale> yeah, that's comparison for equality
01:40:50 <Cale> and of course, sort needs a little more
01:40:52 <Cale> @src Ord
01:40:52 <lambdabot> class (Eq a) => Ord a where
01:40:52 <lambdabot>     compare              :: a -> a -> Ordering
01:40:52 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
01:40:52 <lambdabot>     max, min             :: a -> a -> a
01:41:20 <Cale> These class declarations explain which operations need to be defined in order to make some type an instance of the class
01:41:47 <Cale> So if I define some new type MyType, then I can make it an instance of Eq by writing
01:41:52 <Cale> instance Eq MyType where
01:41:55 <Cale>   x == y = ...
01:42:11 <Cale> Where I go on to explain how to compare values of my new datatype for equality
01:43:34 <Cale> These sources that lambdabot provided are slightly truncated... the real definitions provide default implementations of (==) and (/=) in terms of each other, so that we only have to define one of the two
01:44:08 <Cale> and similarly with Ord, you only have to define compare or (<=)
01:44:33 <Cale> (you can see the real definition of Ord here: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc-prim-0.4.0.0/src/GHC-Classes.html#Ord )
01:44:39 <knite> yep, still with you. but elephant in the room is, what's the difference between [Ord a] -> [Ord a] "take a list of comparables, produce a list of comparables" vs Ord a => [a] -> [a] "a must be comparable, take a list of as and produce a list of as". those still *sound* the same, how can I distinguish between them?
01:45:07 <Cale> Okay, so the first one isn't valid. Type classes don't count as types themselves.
01:45:54 <Cale> But if they did, then [Ord] -> [Ord] would probably mean something like (Ord a, Ord b) => [a] -> [b]
01:47:32 <knite> okay, so I think that's the critical insight, that type constructors are not themselves types. but someone said it was incorrect or misleading to think of a type constructor as a metaclass?
01:47:43 <Cale> (or worse yet, that we wouldn't know that the elements of the list even had the same type, only that it was an instance of Ord, making the comparison operations useless, because we wouldn't know that any two elements of our list were of the same type to be able to compare them)
01:47:46 * hackagebot stackage-update 0.1.1.2 - Update your package index incrementally (requires git)  http://hackage.haskell.org/package/stackage-update-0.1.1.2 (MichaelSnoyman)
01:47:47 <safinaskar> knite: "elephant in the room", i like this phrase :)
01:47:55 <Cale> Type classes are not type constructors
01:48:34 <knite> okay, right. type constructors produce type classes which produces instances of that type.
01:48:40 <knite> correct?
01:48:41 <Cale> uhhhh
01:48:42 <Cale> no
01:48:46 <knite> which produce*
01:49:09 <Cale> Type constructors are essentially functions which take a type as a parameter, and produce a type.
01:50:22 <Cale> @let data BinTree a = Tip | Branch a (BinTree a) (BinTree a)
01:50:22 <merijn> knite: You cannot produce instances of typeclasses because there is always only one
01:50:23 <lambdabot>  Defined.
01:50:35 <merijn> knite: Note that typeclasses are NOT datatypes
01:50:36 <Cale> :t Branch 1 (Branch 2 Tip Tip) (Branch 3 Tip Tip)
01:50:37 <lambdabot> Num a => BinTree a
01:50:54 <knite> so data type == type constructor, or no?
01:50:59 <Cale> :t Branch "one" (Branch "two" Tip Tip) (Branch "three" Tip Tip)
01:51:00 <lambdabot> BinTree [Char]
01:51:24 <merijn> knite: A datat type consists of 1 type constructor for that type and any number of data/value constructors
01:51:32 <Cale> Here, I defined a type of binary trees which depends on the choice of type for the elements in the branch nodes of the tree
01:51:42 <Cale> BinTree is a type constructor, then
01:51:45 <merijn> knite: i.e. "data Maybe a = Nothing | Just a" has 1 type constructor (Maybe) and 2 value constructors (Nothing and Just)
01:52:17 <Cale> It accepts as an argument the type of elements of the tree, and produces the type of trees having that type of elements.
01:53:01 <Cale> One thing which may help to look at is the kinds of these things
01:53:03 <Cale> :k Integer
01:53:04 <lambdabot> *
01:53:20 <Cale> * is the kind of all ordinary types which may have values
01:53:29 <Cale> :k Maybe
01:53:30 <lambdabot> * -> *
01:53:49 <Cale> Here, Maybe has kind * -> * because it takes as an argument a type of kind *, and produces a type of kind *
01:53:53 <Cale> :k Maybe Integer
01:53:54 <lambdabot> *
01:53:55 <knite> how about this, which may piss off every language at once: a data type constructor is, in hand wavy way, a modal singleton constructor of the type constructors provided on the right hand side of the definition?
01:54:21 <Cale> I don't understand what you're trying to convey by that sentence :)
01:54:24 <safinaskar> knite: first, when you are declaring new datatype, you can just write "data X = ...", you don't need to write any "a"s left of "=". if you write "data X = ...", then you are creating new type (just a normal type) named X and simutuaesly this "X" is type constructor which takes zero arguments. then, you can write "data X a = ...". this means that now "X" is a type constructor, which takes one argument, 
01:54:30 <safinaskar> i. e. "a". and when you push this argument to this constructor, you will get normal type "X a". and all this things are not classes
01:55:13 <Cale> Recent extensions to GHC's type system let us ask about the kind of type classes
01:55:15 <knite> man, in any other channel people would have called me a troll by now. really just trying to find a formulation in my own words that y'all don't object to. :-)
01:55:20 <Cale> :k Ord
01:55:21 <lambdabot> * -> Constraint
01:55:47 <Cale> Here, Ord is a class which is parameterised over a type of kind *, and which produces something called a Constraint
01:56:01 <Cale> Constraint is the kind of thing which can occur to the left of the =>
01:56:22 <Cale> i.e. things which will generally constrain the type variables in the rest of the type
01:56:53 <safinaskar> knite: when i write "data X = ...", then X is a data type AND type constructor. when i write "data X a = ...", then X is type constructor and for every concrete a "X a" is a data type
01:57:19 <knite> safinaskar: boom, that helps a lot. very succint.
01:57:54 <merijn> safinaskar: Actually, it can also be a data type for variable a's
01:57:57 <merijn> :t Nothing
01:57:58 <lambdabot> Maybe a
01:58:00 <knite> noooooooo
01:58:21 <Cale> Also, be cautious about using the phrase "data type constructor", because there are things called "data constructors" and there are things called "type constructors", and they aren't the same thing :)
01:58:59 <Cale> Data constructors are the value-level things you'll see whose names start with an uppercase letter, or colon if they're infix, and they're the things which you're allowed to pattern match against.
01:59:20 <knite> so constraints (left hand side of =>) must be a data type not a type constructor, and any type definition (... -> ...) must consist of type constructors, not data constructors?
01:59:53 <Cale> Constraints are formed by applying type classes to type variables
01:59:58 <Cale> Like Ord a
02:00:03 <Cale> here, Ord is a type class
02:00:10 <Cale> not a type constructor or a data constructor
02:00:28 <Cale> sort :: Ord a => [a] -> [a]
02:00:50 <safinaskar> knite: there is no such term "data type constructor". i would say that "data type constructor" is same as "type constructor"
02:00:54 <Cale> The brackets surrounding the variable a to mean the type of lists of values of type a are a type constructor with special syntax
02:01:14 <liste> "Ord a =>" means "there must be an Ord instance for type a"
02:01:27 <Cale> And the (->) itself is also a type constructor, which constructs the type of functions between two types
02:02:28 <knite> so given data Foo a = Bar a | Baz a, Foo is a data constructor, Bar and Baz are type constructors, and Foo a is also a type constructor which happens to be modal in Bar and Baz?
02:02:35 <Cale> other way around
02:02:39 <Cale> Foo is a type constructor
02:02:40 <knite> which other way?
02:02:42 <knite> gotcha.
02:02:44 <Cale> Bar and Baz are data constructors
02:02:56 <Cale> I don't know what "modal" means
02:03:06 <Cale> Bar :: a -> Foo a
02:03:11 <Cale> Baz :: a -> Foo a
02:03:22 <Cale> are the types of the resulting data constructors
02:03:41 <merijn> knite: That's basically saying that "Bar True :: Foo Bool" <- i.e. Bar constructs values of type "Foo something" where the type variable depends on what you give Bar as an argument
02:03:43 <Cale> You can see that Bar and Baz, since they are data constructors, will only live on the left hand side of the ::
02:03:56 <Cale> and Foo, as a type constructor will only live on the right hand side of the ::
02:03:59 <safinaskar> Cale: wow, thanks for info about this ghc extension
02:04:07 <solatis> hmmm if i want to split a large bytestring of size S into a list of smaller bytestrings of size S' where S' < S, what function would I use?
02:04:12 <safinaskar> Cale: haskell become more and more mathematical
02:04:12 <merijn> Cale: I think that for didactic reasons the next report should explicitly allow GADTSyntax because I think it's way simpler for beginners too understand than normal syntax :\
02:04:20 <knite> hokay, that also helps. I think I had my terms inverted this whole time.
02:04:22 <Cale> merijn: I agree actually
02:04:37 <Cale> knite: Another notation for this same definition is:
02:04:41 <Cale> data Foo a where
02:04:45 <Cale>   Bar :: a -> Foo a
02:04:49 <Cale>   Baz :: a -> Foo a
02:05:11 <exio4> merijn: I normally enable GADTSyntax just for that
02:05:25 <safinaskar> Cale: kind "*" corresponds to "Type" in Coq (such proof assistant) and "Constraint" to Prop, so we can say coq-like "Ord : Type -> Prop"
02:05:33 <Cale> This syntax is enabled by an extension in GHC, so you'd have to write {-# LANGUAGE GADTSyntax #-} or {-# LANGUAGE GADTs #-} at the top of your file to use it.
02:05:51 <Cale> safinaskar: Kind of. Coq doesn't really have an equivalent to Constraint.
02:05:59 <merijn> exio4: I just use GADTs all the time, so I usually have that enabled anyway ;)
02:06:06 <merijn> GADTs are like violence
02:06:09 <safinaskar> Cale: also, this means haskell can be formalized as PTS (pure type system) with sorts "*", "Constraint" and maybe some more
02:06:14 <merijn> If they don't solve your problem, you're not using enough
02:06:42 <exio4> merijn: enabling RankNTypes and GADTs before even writing any line of code? \o/
02:06:44 <Cale> merijn: heh
02:07:03 <Rembane> merijn: So GADTs are the opposite of regular expressions? :D
02:07:04 <merijn> exio4: -XKitchenSink
02:07:05 <Cale> GADTs are nice, but finally tagless representations can be pretty cool too
02:07:23 <merijn> Rembane: :p
02:07:27 <Cale> Usually I find that I'll start out with a GADT, and switch to another representation later
02:07:34 <Cale> when designing a library
02:07:46 * hackagebot stackage-update 0.1.1.3 - Update your package index incrementally (requires git)  http://hackage.haskell.org/package/stackage-update-0.1.1.3 (MichaelSnoyman)
02:07:55 <Cale> It's nice to be able to just define all the expressions that you want to interpret in a way that lets you concretely experiment with them
02:08:03 <merijn> exio4: I managed to boil my "why DataKinds, GADTs and TypeFamilies rock" example down to a mere 24 line heterogeneous list + vararg apply function :p
02:08:18 <merijn> exio4: 6 of those lines being extension pragmas :p
02:08:49 <merijn> Cale: You're not using DataKinds with your GADTs then, I'm guessing?
02:08:55 <Cale> merijn: Not usually
02:08:59 <merijn> Cale: Because I don't think you can get rid of them then
02:09:09 <merijn> GADTs without DataKinds are much less fun :p
02:09:30 <Rembane> merijn: Do you have a link to that example? :)
02:09:31 <Cale> I don't usually try to make Haskell into a dependently typed language, because I've used real dependently typed languages now, and it's too frustrating.
02:09:45 <knite> arianvp: a couple of comments on your post: 1) discuss the :+: symbol. as a beginner, I'm assuming that you're basically creating a custom operator because + is already defined, so a simple note to that effect would be great. 2) another typo: similarary -> similarly (a spell checker will catch mistakes like this). 3) missing punctuation and capitalization in "but I head compilers[...]". 4) align comments in data Instr. 5) arrises
02:09:46 <knite> arises.
02:10:12 <merijn> Rembane: https://gist.github.com/merijn/dc00bc7cebd6df012c5e
02:10:17 <Rembane> merijn: \o/ Thanks!
02:10:36 <merijn> Rembane: I think you need 7.8 or later to use it
02:10:37 <solatis> hmm, ok, let me rephrase my problem
02:10:43 <Cale> knite: :+: and :-: are being defined as new infix data constructors there
02:10:59 <knite> Cale: right, I'm suggesting that that be stated explicitly.
02:11:10 <Rembane> merijn: Cool. Errrr.... what does it do? :D
02:11:25 <Cale> knite: Just like ordinary prefix data constructors are required to start with an uppercase letter, infix data constructors are distinguished by the fact that they start with a colon
02:11:29 <solatis> say i have a list of N items, like this: [0,1,2,3,4,5,6,7,8,9,10], and i want to split them into sublists with a max length = 3 like this: [[0,1,2],[3,4,5],[6,7,8],[9,10]]
02:11:41 <solatis> what is the idiomatic way to do this?
02:11:50 <merijn> Rembane: Try ":t Cons True (Cons 'c' (Cons [] Nil))" in ghci after loading it
02:11:51 <Cale> > iterate (drop 3) [0,1,2,3,4,5,6,7,8,9,10]
02:11:51 <solatis> i feel like this should be able to be achieved with a built-in function
02:11:52 <mdkxxx> hey all, whats the best way to get clear windows in gnome3.. by extention? if so whats the best one ?
02:11:52 <lambdabot>  [[0,1,2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[6,7,8,9,10],[9,10],[],[],[],[]...
02:11:57 <Rembane> merijn: Thanks!
02:12:06 <Cale> > takeWhile (not . null) . iterate (drop 3) $ [0,1,2,3,4,5,6,7,8,9,10]
02:12:08 <lambdabot>  [[0,1,2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[6,7,8,9,10],[9,10]]
02:12:13 <Cale> > map (take 3) . takeWhile (not . null) . iterate (drop 3) $ [0,1,2,3,4,5,6,7,8,9,10]
02:12:14 <lambdabot>  [[0,1,2],[3,4,5],[6,7,8],[9,10]]
02:12:18 <merijn> Rembane: Also try running "apply (,,) (Cons True (Cons 'c' (Cons [] Nil)))"
02:12:35 <solatis> Cale, awesome, i like how you explain the thinking process
02:12:48 <Cale> solatis: Or use the stuff in Data.List.Split
02:13:01 <Cale> http://hackage.haskell.org/package/split
02:13:17 <Cale> > chunksOf 3 [0..10]
02:13:18 <lambdabot>  [[0,1,2],[3,4,5],[6,7,8],[9,10]]
02:13:41 <Rembane> merijn: That's a beauty! :D
02:13:50 <solatis> thanks, chunksOf is likely what i want
02:15:08 <merijn> Rembane: Basically the type family "Fun" defines a type level function that recurses over a list of types and constructs a function type corresponding to that list
02:15:40 <safinaskar> knite: there should be constraint in the left of "=>". constraint is something which starts with class. for example, there is constraint "Eq a", "Eq" is a class. in type definition "... -> ..." there should be types. types are starting with type constructors (i. e. Maybe is type constructor and Maybe Int is a type, Int is both a type and type constructor)
02:15:48 <merijn> Rembane: So when using "apply" it applies "Fun" to the type level list in HList, which produces a function type and then it compares that function type against the function that you passed to apply
02:15:57 <Cale> knite: So are things basically straightened out for you? Some cool things about type classes...
02:16:00 <merijn> Rembane: Which will only match if you passed it the right function
02:16:25 <merijn> Rembane: For example, try "apply (,)" instead of (,,) and it won't typecheck
02:16:30 <Cale> knite: We can have type class polymorphic functions which are polymorphic only in the type of the result of the function:
02:16:32 <Cale> :t read
02:16:33 <lambdabot> Read a => String -> a
02:16:40 <merijn> "apply (,,,)" would typecheck, but return a function
02:16:56 <Cale> Here, which parser to use to read the String will depend on which type of value we need
02:16:57 <safinaskar> knite: if you write "data Foo a = Bar a | Baz a", then Foo is type constructor and Bar and Baz are type constructors
02:17:04 <safinaskar> knite: *if you write "data Foo a = Bar a | Baz a", then Foo is type constructor and Bar and Baz are data constructors
02:17:17 <Cale> safinaskar: We already cleared that up :)
02:17:28 <Cale> > read "35" :: Integer
02:17:30 <lambdabot>  35
02:17:33 <Cale> > read "35" :: Double
02:17:34 <lambdabot>  35.0
02:17:40 <Cale> > read "[1,2,3]" :: [Integer]
02:17:42 <lambdabot>  [1,2,3]
02:17:55 <Cale> > read "[(1,'c'),(2',3]" :: [Integer]
02:17:57 <Cale> oops
02:17:57 <lambdabot>  *Exception: Prelude.read: no parse
02:18:02 <Cale> haha, mashed the enter key :)
02:18:19 <Cale> > read "[(1,'c'),(2,'d'),(3,'f')]" :: [(Integer, Char)]
02:18:21 <lambdabot>  [(1,'c'),(2,'d'),(3,'f')]
02:18:25 <merijn> Rembane: i.e. "Fun [Int, Bool, Char] (Int, Bool, Char)" -> "Int -> Fun [Bool, Char] (Int, Bool, Char)" -> "Int -> Bool -> Fun [Char] (Int, Bool, Char)" -> "Int -> Bool -> Char -> Fun [] (Int, Bool, Char)" -> "Int -> Bool -> Char -> (Int, Bool, Char)", and then it typechecks as normal
02:18:31 <echo-area> > don't getLine
02:18:32 <lambdabot>  Not in scope: ‘don't’
02:18:40 <knite> yeah, thanks for all your help guys. I think I had the definitions of data and type constructors basically reversed, which made everything 1000% more confusing.
02:18:43 <echo-area> Hmm, it's cleared
02:19:04 <Cale> knite: cool, yeah.
02:19:08 <safinaskar> Cale: also, in proof assistants one can actually prove monadic laws for any given monad
02:19:18 <exio4> any given monad? 
02:19:18 <merijn> knite: Probably more than 1000% :p
02:19:21 <Cale> safinaskar: I know, I've done it for the mtl monads :)
02:19:58 <echo-area> safinaskar: Any pointer available?
02:20:08 <lpaste> Cale pasted “This was my very first Coq script” at http://lpaste.net/132370
02:24:45 <safinaskar> exio4: yes, for any given monad (i assume it already conforms to this laws and we just want to prove this formally)
02:25:47 <safinaskar> echo-area: websearch for "coq", then for "coq monad" :)
02:26:07 <echo-area> safinaskar: Thanks!
02:26:13 <knite> for that triplets question a few minutes ago, wouldn't foo xs = [take 3 xs] ++ foo (drop 3 xs) be simpler?
02:26:25 <knite> along with foo [] = [].
02:26:43 <safinaskar> echo-area: and see that lpaste
02:27:33 <echo-area> safinaskar: Have seen it, but couldn't understand.  Checking out Coq now :)
02:27:37 <merijn> knite: Are you okay with the last entry not always being 3 elements?
02:27:47 * hackagebot ghcjs-websockets 0.3.0.0 - GHCJS interface for the Javascript Websocket API  http://hackage.haskell.org/package/ghcjs-websockets-0.3.0.0 (jle)
02:28:02 <merijn> > take 3 [1,2]
02:28:04 <lambdabot>  [1,2]
02:28:42 <knite> merijn: foo (a:b:c:xs) = [[a, b, c]] ++ (foo xs) then?
02:28:57 <exio4> safinaskar: I was thinking about the halting problem
02:28:58 <Rembane> merijn: That's lovely!
02:29:00 <knite> either way, seems simpler than the response given earlier?
02:29:09 <exio4> knite: [a] ++ b is the same as a:b 
02:29:18 <safinaskar> echo-area: the point is: coq (and other proof assistants) can operate on logic sentences. so, you can take logic assumption "a is monad" and (using it) to formally prove that (for example) "IdentityT is monad, too". and this prove will be fully formal and will be checked by the system (including monad laws)
02:29:57 <knite> right, but I'm comparing to Cale's map (take 3) . takeWhile (not . null) . iterate (drop 3), which seems a lot more complex for the same result?
02:29:58 <merijn> knite: I wasn't saying it was wrong, I was just pointing out that a list whose number of elements are not divisible by 3 would come up short on the last entry
02:30:07 <merijn> knite: Whether that's a problem depends on you
02:30:39 <merijn> Rembane: I know! :D
02:31:12 <safinaskar> exio4: i will rephrase that "any given monad" sentence: if there is a proof of monadic laws (i. e. a proof in a head of a human), then this proof can be formalized in coq
02:31:12 <Cale> knite: It requires one fewer dependency though
02:31:36 <Cale> oh, sorry, missed the recursive implementation
02:31:39 <exio4> safinaskar: it doesn't matter if you language is total though
02:31:42 <Cale> yeah, for sure you can do that
02:31:47 <merijn> Rembane: Type families (especially closed ones) lets you write all sorts of types where one argument of a function depends on another in an indirect way, without losing static checking :)
02:32:09 <echo-area> safinaskar: Does it prove by deduction, like people doing it on paper?
02:32:31 <Cale> knite: I just tend to consider explicit recursion to be admitting defeat most of the time ;)
02:33:01 <knite> Cale: why? is recursion considered poor style in Haskell?
02:33:10 <merijn> knite: There's two schools of thought
02:33:23 <merijn> knite: One thinks you should use combinators like fold whereever possible
02:33:31 <safinaskar> exio4: of course, you cannot prove for every ending (i. e. finite in time) program that it is really ending (because of halting problem). i just say that if you already has proof of halting of this program, then you can formalize it in coq
02:33:43 <merijn> The other thinks "straightforward recursion is easy enough to write so go with what's readable"
02:34:03 <merijn> knite: As a beginner I would just stick with whichever style is most comfortable to write/read for now
02:34:16 <exio4> merijn: combinators are so nice when switching between data structures though :p 
02:34:20 <safinaskar> echo-area: yes, deductive proof. but programmer should write such proofs himself
02:34:24 <merijn> You'll most likely find your taste of what's readable shift dramatically as you get better at haskell
02:34:46 <knite> merijn: I'm a devops/infrastructure person. I'd rather know which school of thought is winning, and force myself to do it that way from the beginning. :-D
02:35:00 <merijn> knite: I don't see a winner in the near future
02:35:09 <Cale> knite: It's not exactly frowned upon, but if you understand something well enough to write it with higher order functions, it's generally nicer to write it that way
02:35:36 <gfixler> I'm just realizing that Haskell is distinct in that way
02:35:57 <merijn> knite: Before you know it, you'll be like
02:36:01 <merijn> @quote my.first.26
02:36:01 <lambdabot> alexbagel says: i find that my first 26 variables are always easy to name. after that it becomes a bit harder.
02:36:06 <gfixler> I'm like the cursor in a zipper, with code I can understand on one side, and gibberish on the other
02:36:15 <echo-area> safinaskar: Thanks :)  Reading Coq's tutorial
02:36:22 <favetelinguis> Does not explicit recursion break seperation of concern? That is why we go with combintors? I did not know there where a debate :)
02:36:24 <Cale> knite: It tends to be easier to write explicitly recursive functions without thinking too hard about what you're computing, whereas if you understand it better, you can break it up into a composite of these higher order pieces which act uniformly on your data structures.
02:36:36 <merijn> gfixler: Try reading "Clowns to the left, jokers to the right" (or whatever the title was)
02:36:42 <gfixler> I might not understand an algorithm, but I can pretty much always read Python
02:36:50 <Cale> knite: It's harder to screw up when you're using higher order functions
02:36:52 <gfixler> Haskell has a long ramp of readability to it
02:37:03 <merijn> gfixler: Try fixing anything in a python project you don't know...
02:37:07 <R0b0t1> s/ramp/cliff/
02:37:14 <knite> Cale: isn't the triplet question a great example of an instance where explicit recursion is much cleaner than a combinator based transformation?
02:37:24 <merijn> gfixler: I managed to patch pandoc, despite being orders of magnitude bigger than the largest python project I ever managed to patch
02:38:00 <gfixler> merijn: sounds like the start of an interesting study/discussion
02:38:06 <merijn> gfixler: So I would argue that haskell is far more readable than python
02:38:06 <safinaskar> merijn: good quote :)
02:38:10 <solatis> hmmm, lens 3.2 had a ++~ operator to append a list to a list https://hackage.haskell.org/package/lens-3.2/docs/Data-List-Lens.html
02:38:17 <solatis> i cannot find that ++~ operator in lens 4.x anymore
02:38:24 <solatis> anyone knows what it has been replaced with ?
02:38:33 <merijn> solatis: Did you look at the index to see if it moved?
02:38:48 <solatis> i tried, but cannot find anything useful
02:38:58 <indiagreen> solatis: you can use <>~
02:39:17 <merijn> solatis: <>~ ?
02:39:18 <merijn> Whoo
02:39:21 <gfixler> merijn: found it: http://strictlypositive.org/CJ.pdf
02:39:23 <tdammers> makes sense
02:39:37 <solatis> merijn, indiagreen, where did you find that?
02:39:39 <merijn> gfixler: I think that paper is about effectful zippers
02:39:46 <gfixler> I like how the second we brought up readability, people started talking about ++~ and <>~
02:39:49 <merijn> solatis: The index page and guessing based on ++ vs <> for monoid
02:40:01 <Cale> knite: Perhaps it's shorter, I'm not sure I'd admit that it's cleaner :)
02:40:06 <merijn> gfixler: But I'm not sure, because I'm not smart enough for that paper :p
02:40:06 <CurryWurst> hi all
02:40:16 <gfixler> merijn: oh great, then I'm out :)
02:40:20 <safinaskar> echo-area: exio4: also, using coq requires some math logic skills. for example, it would be good to know first order logic
02:40:21 <solatis> merijn, with "index page" you mean https://hackage.haskell.org/package/lens ?
02:40:30 <knite> Haskell is just much denser. it's like the difference between a paragraph explaning an equation vs the equation itself in a math paper. when you know what an integral symbol means, the symbol alone is much more expressive than a page worth of prose could be, but when you don't understand the symbol, a hand wavy paragraph is clearer.
02:40:31 <CurryWurst> is it a right place to ask some "dumb" questions?
02:40:32 <arianvp> knite: Good points.  the unaligned comments are a css problem. Will try to fix that. Thanks :)
02:40:37 <merijn> solatis: No, click on a module, then click on "index" on the top right
02:40:38 <exio4> solatis: I know :)
02:40:46 <safinaskar> CurryWurst: sure :)
02:40:47 <CurryWurst> i'm stuck with something and i need some help
02:40:48 <merijn> solatis: That has an alphabetical list of all functions/types in the package
02:40:52 <arianvp> CurryWurst: No such thing as "dumb" questions. :D
02:40:56 <solatis> :o
02:40:58 <indiagreen> solatis: this particular operator lives in Control.Lens.Setter
02:41:01 * solatis feels like an idiot now
02:41:09 <solatis> i had no idea this existed
02:41:21 <merijn> I'm slightly annoyed the index isn't listed from the front page
02:41:31 <merijn> Maybe I should see how hard that would be to patch in hackage...
02:41:39 <merijn> solatis: You live, you learn :p
02:41:43 <solatis> yeah
02:41:52 <solatis> they should make it more prominent
02:42:05 * solatis discovered he can manually delete & update documentation on hackage, too, yesterday
02:42:47 * hackagebot psqueues 0.2.0.2 - Pure priority search queues  http://hackage.haskell.org/package/psqueues-0.2.0.2 (JasperVanDerJeugt)
02:42:49 * hackagebot generic-aeson 0.2.0.5 - Derivation of Aeson instances using GHC generics.  http://hackage.haskell.org/package/generic-aeson-0.2.0.5 (AdamBergmark)
02:42:51 * hackagebot json-schema 0.7.3.5 - Types and type classes for defining JSON schemas.  http://hackage.haskell.org/package/json-schema-0.7.3.5 (AdamBergmark)
02:43:28 <CurryWurst> http://lpaste.net/132371 - is it possible to return Nothing in maxM function if there is a Nothing value in list without using if/case/Guards/or Pattern-Matching?
02:46:30 <gfixler> ah, I see some patterns
02:46:32 <gfixler> map (fst . randomR (1,6) . mkStdGen) [0..]
02:46:47 <gfixler> if you let that run for awhile, it will run through a ton of 6s, then 5s, then 4s, etc
02:46:49 <gfixler> then loop
02:46:56 <nwm> CurryWurst: try something like sequence lst >>= (\x -> max x) where lst :: [Maybe Int]
02:47:37 <gfixler> if you change the 6 to another int, you'll see it repeat sequences, e.g. with 7 it repeats 1,3,5,7,2,4,6 forever
02:47:47 * hackagebot aeson-utils 0.3.0.1 - Utilities for working with Aeson.  http://hackage.haskell.org/package/aeson-utils-0.3.0.1 (AdamBergmark)
02:47:49 * hackagebot attoparsec-expr 0.1.1.2 - Port of parsec's expression parser to attoparsec.  http://hackage.haskell.org/package/attoparsec-expr-0.1.1.2 (AdamBergmark)
02:47:51 * hackagebot websockets 0.9.4.0 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.9.4.0 (JasperVanDerJeugt)
02:48:07 <nwm> I suppose that would be (\x -> return $ max x)
02:48:21 <jle`> you mean `fmap max` ?
02:48:44 <jle`> er, in the context above,
02:48:46 <mattby> CurryWurst: https://hackage.haskell.org/package/base-4.8.0.0/docs/Prelude.html#v:sequence
02:49:33 <mattby> > sequence [Just 1, Just 2]
02:49:35 <lambdabot>  Just [1,2]
02:49:46 <mattby> > sequence [Just 1, Nothing]
02:49:48 <lambdabot>  Nothing
02:49:56 <nwm> > sequence [Just 1, Just 2] >>= (\x -> return $ max x)
02:49:58 <lambdabot>  Just <[Integer] -> [Integer]>
02:52:11 <nwm> ahhh maximum
02:52:49 <CurryWurst> thanks, I'll look at sequence
02:53:27 <mattby> > foldl1 max <$> sequence [Just 1, Just 2]
02:53:29 <lambdabot>  Just 2
02:53:35 <mattby> > foldl1 max <$> sequence [Just 1, Nothing]
02:53:36 <lambdabot>  Nothing
02:53:43 <jle`> gfixler: yeah, StdGen is notoriously *especially* bad for small seeds
02:54:04 <gfixler> jle`: well that's good to know
02:54:29 <jle`> it has a lot of issues in general, but most of them can be overlooked for everyday non-sec entropy fun
02:54:43 <mattby> CurryWurst: the final function is "fmap (foldl1 max) . sequence"
02:54:46 <gfixler> it sort of makes sense to me - create a giant, repeating field, then jump around pseudorandomly on it
02:55:29 <CurryWurst> mattby: Thanks!
02:55:37 <xenog> CurryWurst: fmap (foldl1 max) $ sequence [Just 1, Just 2, Just 3] => Just 3
02:55:51 <xenog> CurryWurst: fmap (foldl1 max) $ sequence [Just 1, Just 2, Just 3, Nothing] => Nothing
02:57:51 <xenog> CurryWurst: fmap maximum (sequence [Just 1, Just 2, Just 3]) ⇒ Just 3
02:58:07 <xenog> CurryWurst: Is that what you wanted to achieve?
02:58:20 <CurryWurst> yeah
02:59:26 <xenog> I see that you got an answer before I could post mine. Nevermind. ;)
03:00:22 <nwm> both work, but I would side with maximum over foldl max
03:00:48 <CurryWurst> will it be possible to achieve the same just using my applyM instead of sequence?
03:02:36 <xenog> CurryWurst: Your applyM is very much like functor fmap.
03:02:39 <CurryWurst> it looks like fmap actually :)
03:02:59 <nwm> :t sequence
03:03:00 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
03:03:03 <xenog> Applicative functor.
03:03:05 <nwm> :t fmap
03:03:06 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:05:19 <mattby_> CurryWurst: what's wrong with sequence?
03:06:02 <xenog> CurryWurst: This is a better definition for your applyM
03:06:12 <xenog> CurryWurst: applyM f ma mb = ma >>= \a -> mb >>= (return . f a)
03:06:40 <xenog> That is more generic, but assumes that the passed values have Monad instances.
03:07:25 <jle`> :t \f ma mb -> ma >>= \a -> mb >>= (return . f a)
03:07:26 <lambdabot> Monad m => (a -> a1 -> b) -> m a -> m a1 -> m b
03:07:31 <jle`> that looks like liftA2
03:07:33 <jle`> :t liftA2
03:07:35 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
03:07:48 * hackagebot hakyll 4.6.9.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.6.9.0 (JasperVanDerJeugt)
03:08:07 <xenog> That's right!
03:09:08 <CurryWurst> it's ok, it was just a suggestion from my professor to use applyM instead, but for me fmap + sequence is more elegant
03:09:19 <xenog> You could also say: applyM f a b = f <$> a <*> b
03:09:45 <xenog> As long as a and b have Applicative instances.
03:10:00 <jle`> if they are monads, then they do
03:10:01 <nwm> do all standard library monads have applicative instances?
03:10:06 <jle`> they are required to
03:10:11 <jle`> it's a compiler error if they don't :)
03:10:12 <nwm> jle: answered my question :P
03:10:34 <nwm> Wait, even for your own monads?
03:10:39 <jle`> yes
03:10:43 <jle`> provided you're on ghc 7.10+
03:10:46 <jle`> which you should be :D
03:10:52 <xenog>  jle`: that is really cool.
03:10:58 <nwm> ...no comment
03:11:01 <xenog> jle`: I did not know that. Very helpful.
03:11:22 <jle`> mhm. it also means you can use 'fmap' on any Monad instances, too
03:11:36 <jle`> there was a dark time when this wasn't possible
03:11:46 <nwm> isn't 7.10 pretty recent?
03:12:08 <P4Titan> Hello all, I have a question regarding flexible instances. I have the following: instance Monad m => Stream ParserSource m Char where, where the Sream is from Text.Parsec and ParserSource is a newtype on String. That gives me a flexible instance error, but I cannot see why.
03:12:09 <jle`> relatively, heh
03:12:15 <xenog> Yes, that is true. There was a time I could not do <$> on a monad because there was no Applicative instance. I could have created the instance myself, but that is beside the point.
03:12:42 <liste> nwm very recent: https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-7.10.1
03:13:03 <jle`> P4Titan: i think it's that you can't have a concrete type in your signature like ParserSource without Flexible Instances
03:13:05 <ronh-> <$> actually has a Functor constraint, not an Applicative constraint
03:13:30 <ronh-> <$> is just infix fmap. it is <*> that has applicative constraint
03:13:48 <xenog> True, well, missing functor instance then.
03:13:48 <P4Titan> What is a concrete type exactly as I have a self-created class with an instance on it: instance ParsableState ParserSource ParserDet where and there are no flexible instance errors
03:14:08 <nwm> what is the best way to install 7.10 over 7.8?
03:14:09 <xenog> (<*>) is the one that has an Applicative constraint.
03:14:12 <P4Titan> Of which ParserSource is a newtype on String and ParserDet is a newtype on Int
03:14:19 <jle`> nwm: what OS/system are you running?
03:14:22 <xenog> :t (<*>)
03:14:23 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:14:34 <nwm> Windows 7
03:15:26 <jle`> i think you can just install the binary from here https://www.haskell.org/ghc/download_ghc_7_10_1
03:15:32 <jle`> but i haven't tried it on windows
03:15:46 <nwm> Alright, I'll give it a try, thanks!
03:16:07 <jle`> good luck :o
03:17:47 <liste> P4Titan concrete type is a type as opposed to a type variable
03:17:51 <arkeet> nwm: you don't really install "over" old versions of ghc, they just live side by side
03:18:04 <arkeet> you can uninstall the old version if you like
03:18:15 <arkeet> ghc package dbs are separate between versions anyway
03:18:28 <jle`> i do regret using the word "concrete type" as it is pretty ambiguous and i've argued against it several times, so...i'm sorry v.v
03:18:36 <P4Titan> liste: Then why does my second instance, composed of concrete types, not be a flexible instance
03:22:22 <nwm> arkeet: ahh makes sense. Thanks!
03:22:48 <liste> P4Titan in haskell98 concrete types are not allowed in place of type variables in instance definitions
03:23:18 <P4Titan> Ok, but isn't instance ParsableState ParserSource ParserDet where a violation of that?
03:26:21 <liste> P4Titan no, because you have parameters of the multi-parameter type class, not variables of the types themselves
03:27:49 * hackagebot som 8.0.4 - Self-Organising Maps.  http://hackage.haskell.org/package/som-8.0.4 (AmyDeBuitleir)
03:27:51 * hackagebot parsers 0.12.2.1 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.12.2.1 (EdwardKmett)
03:27:56 <liste> if for example ParserSource was of kind * -> *, the definition instance ParsableState (ParserSource Foo) ParderDet would be illegal
03:28:21 <liste> and instance ParsableState (ParserSource a) ParserDet would be legal
03:32:04 <P4Titan> liste: please repeat that, you are saying that if I have a type with a variadic type arguemnt, I can not instantiate that etherial type with a concrete type
03:33:23 <liste> P4Titan you can't use the concrete type in *instance definitions* in haskell98
03:34:16 <liste> P4Titan but using the concrete type can be very useful, so I recommend using -XFlexibleInstances
03:35:00 <liste> and not worry about it too much (:
03:35:04 <P4Titan> I am sorry for asking again, but why is ParserSource not concrete while something like ParserFoo Foo where ParserFoo takes `a` is a concrete type
03:35:43 <liste> ParserSource is concrete
03:36:02 <P4Titan> So both are concrete then
03:36:19 <liste> yeah
03:36:35 <liste> both are kind "*"
03:37:04 <P4Titan> Then why do you say that instances cannot have concrete types w/o flexibility, but then state that instance ParsableState (ParserSource Foo) ParserDet would error but the other is legal
03:37:04 <liste> but only one of them is allowed in instance definitions in vanilla haskell
03:37:49 * hackagebot lens-aeson 1.0.0.4 - Law-abiding lenses for aeson  http://hackage.haskell.org/package/lens-aeson-1.0.0.4 (EdwardKmett)
03:38:59 <Hijiri> the thing you are making an instance for cannot be a type constructor applied to concrete arguments without FlexibleInstances
03:40:05 <liste> Hijiri pretty much nailed it
03:40:33 <Hijiri> also it can't be constrained by typeclasses
03:40:36 <Hijiri> the type argument
03:40:48 <P4Titan> Ok, now the imminent question (sorry for bothering you so much with these questions), why is instance Monad m => Stream ParserSource m Char where and application of a type contructor with concrete types
03:41:07 <Hijiri> P4Titan: ParserSource is defined with newtype and not type?
03:41:13 <P4Titan> newtype String
03:41:21 <Hijiri> then I have no idea
03:41:45 <Hijiri> you could try changing individual parts until it stops giving the message, and see what causes it
03:41:52 <P4Titan> could it be with the Monad m
03:41:59 <Hijiri> maybe
03:42:05 <liste> Stream is a type constructor ?
03:42:13 <Hijiri> Stream is a class
03:42:37 <P4Titan> I changed it to instance Monad m => Stream Int m Int where and it still errors, here is the definition of Stream: class (Monad m) => Stream s m t | s -> t where
03:43:32 <P4Titan> In the source file I got that from, there are instances of instance (Monad m) => Stream TextL.Text m Char where for example, and there is no flexible instances enabled, no unless they compile with compiler flags
03:44:44 <Hijiri> could you post the compiler error somewhere
03:44:48 <Hijiri> maybe it will help
03:45:30 <P4Titan>  
03:45:30 <P4Titan> parserTest.hs:129:21:
03:45:30 <P4Titan>     Illegal instance declaration for `Stream ParserSource m Char'
03:45:30 <P4Titan>       (All instance types must be of the form (T a1 ... an)
03:45:33 <P4Titan>        where a1 ... an are *distinct type variables*,
03:45:36 <P4Titan>        and each type variable appears at most once in the instance head.
03:45:40 <P4Titan>        Use -XFlexibleInstances if you want to disable this.)
03:45:42 <P4Titan>     In the instance declaration for `Stream ParserSource m Char'
03:45:55 <Hijiri> next time use a paste site like lpaste
03:46:05 <P4Titan> Will do
03:46:51 <Hijiri> it means one of your instance arguments is a type constructor applied to something that is not an unconstrained type variable
03:47:15 <P4Titan> I changed the Monad m to Identity and it is not a flexible instance
03:47:27 <P4Titan> Why is that now
03:47:39 <Hijiri> I don't know
03:49:22 <P4Titan> Could it be that Stream has the | s -> t, and when m variable, that makes it that there can be multiple different instances that make t
03:49:49 <Hijiri> no, the m doesn't matter here
03:49:56 <Hijiri> you just need the same t every time you have s
03:50:00 <P4Titan> Ok, that is what I thought
03:50:05 <P4Titan> yes
03:50:34 <Hijiri> I have to work on something so I have to go now, sorry
03:50:48 <P4Titan> No problem, thanks for your help
03:54:33 <pavonia> P4Titan: The file in parsec also requires that extension
03:54:56 <P4Titan> Where does it say/show?
03:55:14 <pavonia> It's enabled in the .cabal file for all files in the package
03:55:21 <P4Titan> Ohh
03:55:36 <P4Titan> So, what is/are a pitfall of using the flexible instance?
03:56:25 <Hijiri> it makes inference more difficult in some places
03:56:38 <Hijiri> so occasionally you might have to specify a type
03:56:44 <Hijiri> where you didn't have to before
03:57:05 <P4Titan> If you aren't busy, could you explain further?
03:57:33 <Hijiri> I don't know a whole lot about type inference
03:59:00 <Hijiri> you can also write instances that overlap
03:59:20 <P4Titan> Will that error, like instance [Char] vs [a]
03:59:21 <Hijiri> like instance A [Int] and instance A [a], for example
03:59:43 <Hijiri> it will fail to compile if you have a place where both instances could apply
04:00:02 <P4Titan> How does ones specify which instanceto use
04:00:10 <P4Titan> s/instanceto/instance to/
04:00:19 <Hijiri> usually you just want to avoid writing such bad instances
04:00:34 <P4Titan> Ok
04:00:56 <liste> isn't OverlappingInstances a different extension?
04:00:56 <Hijiri> you can use extensions like OverlappingInstances which will choose the more specific isntance
04:00:57 <pavonia> You could enable another extension "overlapping instances" which chooses the most specific matching instance
04:01:17 <P4Titan> Ok
04:02:13 <Hijiri> liste: FlexibleInstances makes it possible to write overlapping instances. OverlappingInstances lets you try to resolve an instance to use instead of just failing
04:02:51 <P4Titan> Thank you SO much for your aid. I just enabled the flexible instances, as it seemed safe, and continue
04:09:00 <liste> Hijiri thanks, good to know (:
04:12:16 <_m_ryan> hi how to split camelCase words?
04:12:31 <_m_ryan> eg. HelloWorld -> Hello World
04:12:50 * hackagebot monad-unlift 0.1.1.0 - Typeclasses for representing monad transformer unlifting  http://hackage.haskell.org/package/monad-unlift-0.1.1.0 (MichaelSnoyman)
04:13:29 <nwm> try combining span and isUpper
04:17:50 <indiagreen> > split (dropInitBlank (keepDelimsL (whenElt isUpper))) $ "HelloWorld"
04:17:51 <lambdabot>  ["Hello","World"]
04:18:46 <indiagreen> probably better to just code something manually with ‘span’ and friends in this case, tho
04:20:31 <indiagreen> _m_ryan: but if you don't care, then import Data.List.Split and write “splitCamel = split . dropInitBlank . keepDelimsL $ whenElt isUpper” and there you go
04:21:44 <_m_ryan> indiagreen: how do i combined it?
04:22:06 <_m_ryan> indiagreen: or it should return string by default.
04:22:16 <indiagreen> you mean, separate with spaces?
04:22:20 <liste> how about groupBy ((/=) `on` isUpper) ?
04:22:28 <_m_ryan> indiagreen: yes
04:22:54 <indiagreen> > groupBy ((/=) `on` isUpper) "HelloWorld"
04:22:56 <lambdabot>  ["Hello","World"]
04:23:19 <indiagreen> > groupBy ((/=) `on` isUpper) "helloWorld"
04:23:20 <lambdabot>  ["h","e","l","l","oW","o","r","l","d"]
04:24:00 <indiagreen> _m_ryan: if you know the 1st word is going to be uppercased too (so it's not strictly camelCasing), liste's solution is better
04:24:13 <indiagreen> to combine words into a string, just use ‘unwords’
04:24:34 <indiagreen> > unwords $ groupBy ((/=) `on` isUpper) "HelloWorld"
04:24:36 <lambdabot>  "Hello World"
04:24:58 <arianvp> safinaskar: ExprAlgebra must be parametrized over `e`. so that's not a typo
04:25:01 <_m_ryan> got it thank liste and indiagreen :-)
04:25:18 <arianvp> but I need a space between `e` and `=`
04:25:38 <deezn> jle` you around or did I miss you?
04:27:43 <Hijiri> you don't get any guarantees if you supply an argument that's not an equivalence relation to groupBy, though
05:22:52 * hackagebot hscolour 1.23 - Colourise Haskell code.  http://hackage.haskell.org/package/hscolour-1.23 (MalcolmWallace)
05:31:51 <Elite6809> @pl avg l = (foldl (+) l) / (length l)
05:31:51 <lambdabot> avg = ap ((/) . foldl (+)) length
05:32:37 <bernalex> anyone know a guide or have an idea on how Setup.hs works? what I want to achieve is just to run a command (UNIX) before building my program.
05:34:27 <merijn> bernalex: It just gets compiled and run
05:34:46 <merijn> bernalex: This example might help? https://github.com/merijn/SNet2.0/blob/master/Setup.hs
05:34:47 <liste> bernalex you need hooks for that
05:35:51 <bernalex> merijn: that *does* look relevant. thanks. I'll have a go.
05:37:45 <tar_> -prof tells me I spend 80% of my time in Set.union. is there a drop-in set for strings that uses hashing?
05:37:53 * hackagebot aeson-schema 0.3.0.5 - Haskell JSON schema validator and parser generator  http://hackage.haskell.org/package/aeson-schema-0.3.0.5 (TimBaumann)
05:38:37 <bernalex> merijn: I don't really understand what the c2hsc is meant to do here, would it be possible for you to make a minimum example from that code (seeing as it's your own)?
05:38:56 <bernalex> merijn: again, I just need 1. run a UNIX command. 2. build program as usual.
05:39:43 <juanpaucar> Hi all, is there some pragma to change the code depending on GHC version?
05:40:18 <indiagreen> juanpaucar: you can do it with CPP
05:41:01 <indiagreen> juanpaucar: http://edsko.net/2014/09/13/haskell-cpp-macros/
05:41:44 <juanpaucar> indiagreen: thanks a lot, i was looking for them.. but never really found something useful
05:41:53 <ion> @hoogle HashSet
05:41:54 <lambdabot> No results found
05:42:25 <indiagreen> juanpaucar: for instance, here's how to use one variant if GHC is >= 7.8, and another – if it's lesser: http://lpaste.net/132382
05:43:29 <Elite6809> @pl stdDev xs = let avg = sum xs / length xs in map (\x -> (x - avg)^2) xs
05:43:29 <lambdabot> stdDev = flip (map . flip flip 2 . ((^) .) . subtract) `ap` liftM2 (/) sum length
05:43:36 <ion> @hackage unordered-containers -- tar
05:43:36 <lambdabot> http://hackage.haskell.org/package/unordered-containers -- tar
05:43:50 <juanpaucar> indiagreen: thanks again, i'm testing it now, but i can't stop feeling it's more like  a hack when you have to use this
05:44:28 <indiagreen> juanpaucar: it is, in a way. You can do it with .cabal flags instead, however
05:44:35 <maerwald> why does [5..0] evaluate to an empty list instead of throwing an error or something?
05:44:46 <SwashBuckla> flip (map . flip flip 2 . ((^) ...
05:44:55 <bennofs> maerwald: [a..b] is desugared to enumFromTo a b
05:45:47 <bennofs> maerwald: it would be hard to do that in general. you can have stuff like [(a-c)..(d-e)] or arbitrary complex expressions where the behavior is intented like it is
05:46:11 <juanpaucar> indiagreen: time package doesn't use old-locale anymore since 1.5 :'(
05:46:12 <merijn> bernalex: The c2hsc bit is to have cabal check that c2hsc is installed
05:46:26 <bennofs> maerwald: also, Num can be overloaded such that [5..0] is [5,6,0] for example for a "cyclic" number structure
05:46:32 <merijn> bernalex: If you don't care about checking program presence you don't need it
05:46:50 <maerwald> bennofs: while we are at lists... (:) is a function, but [] not. Is [1, 2, 3] desugared or does the compile transform it directly into a list?
05:46:58 <bernalex> merijn: I see
05:47:22 <bennofs> maerwald: maybe GHC could generate a warning in some specific cases, like [(1::Int)..(5::Int)]
05:47:31 <indiagreen> juanpaucar: (also, there are alternative approaches discussed on haskell-cafe – look for “native -XCPP proposal” if you're interested – but it's only a discussion so far)
05:47:36 <merijn> maerwald: What do you think the difference is between desugaring and "transforming to a list"
05:47:59 <tar_> ion: missed these messages before. thanks!
05:48:03 <maerwald> merijn: I don't mean "desugar into C-- code", but desugar into haskell code
05:48:14 <bennofs> maerwald: I'm not sure how to answer that. (:) is the list data structure, so [1, 2, 3] is exactly the same as 1 : 2 : 3 : []
05:48:19 <indiagreen> @hackage time-locale-compat --juanpaucar
05:48:19 <lambdabot> http://hackage.haskell.org/package/time-locale-compat --juanpaucar
05:48:24 <bennofs> s/list data structure/list data constructor
05:48:28 <tar_> half-way through trying Data.HashSet
05:48:47 <tar_> from hashmap
05:48:49 <maerwald> bennofs: but does it actually desugar to that version?
05:49:09 <bennofs> maerwald: how could it work if it didn't desugar into it?
05:49:48 <juanpaucar> indiagreen: pal, you make me question myself about my googling skills XD... but thanks a lot
05:50:03 <indiagreen> juanpaucar: no, I just saw this package once before
05:50:07 <maerwald> bennofs: depends on the compiler, I can think of something
05:51:16 <ion> tar: hashmap is deprecated.
05:51:25 <bennofs> maerwald: I think as long as you can not observe the difference between 1 : 2 : 3 : [] and [1, 2, 3], the compiler is free to implement it however it wishes
05:52:20 <maerwald> bennofs: I just find it hard to explain what [] actually is... sure, I know what it is and I can check it's type. It feels like a global "constant" while [1, 2, 3] is actual syntax sugar
05:52:24 <juanpaucar> indiagreen: i'm so happy i don't have to use cpp hacks :)
05:53:26 <tar_> ion: oh bother, Google took me past the page that said that. -_- thanks.
05:54:41 <ion> maerwald: Sure, [] can be thought of as a global constant.
05:54:45 <frerich> maerwald: Section 3.7 in https://www.haskell.org/onlinereport/haskell2010/haskellch3.html shows that the list constructor is (:) and the empty list is []. Also, the identity '[e1, …, ek]	=	e1 : (e2 : ( … (ek : []))) ' is explicitely defined.
05:54:54 <bennofs> maerwald: you can think of lists as if they were defined like this: data List a = (:) a (List a) | []
05:55:24 <maerwald> bennofs: ah right, thinking of it as a constructor makes sense
05:57:53 * hackagebot cayley-client 0.1.3.0 - A Haskell client for the Cayley graph database  http://hackage.haskell.org/package/cayley-client-0.1.3.0 (MichelBoucey)
06:06:42 <merijn> maerwald: What does C-- have to do with anything?
06:08:19 <maerwald> merijn: no idea, I was just trying to point out that I mean desugaring on haskell-level... not what happens on the lower levels
06:10:02 <merijn> But yeah, [] and : are just normal constructors, with the only caveat that they're treated specially in the compiler because their syntax aren't legal constructor names according to the report
06:25:54 <yrlnry> @pf id
06:25:54 <lambdabot> Maybe you meant: pl bf
06:26:48 <maerwald> do we still not have natural number support in ghc? the type-level-natural-number package looks weird with those N15 types
06:27:49 <bennofs> maerwald: there is, but the type-level solver is not quite there yet. It works fine with a typechecker plugin (ghc-typelits-natnormalise) afaik though
06:31:29 <maerwald> bennofs: with liquidhaskell maybe or is that not a good approach?
06:31:47 <bennofs> liquidhaskell could work too, but I don't know anything about it
06:31:59 <maerwald> http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2013/01/01/refinement-types-101.lhs/ looks interesting
06:33:02 <maerwald> mh, it depends on template haskell
06:42:38 <bernalex> merijn: do I have to do something in particular to make Setup.hs compile?
06:42:55 * hackagebot gloss 1.9.4.1 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.9.4.1 (BenLippmeier)
06:42:57 * hackagebot gloss-algorithms 1.9.4.1 - Data structures and algorithms for working with 2D graphics.  http://hackage.haskell.org/package/gloss-algorithms-1.9.4.1 (BenLippmeier)
06:43:13 <bernalex> merijn: I basically removed your c2hsc, and do system "ls -a", in place of what you were doing there, and uh that's it.
06:43:40 <bernalex> merijn: should this be invoked by cabal build? do I need to do something more wrt cabal to make it work?
06:47:55 * hackagebot gloss-raster 1.9.4.1 - Parallel rendering of raster images.  http://hackage.haskell.org/package/gloss-raster-1.9.4.1 (BenLippmeier)
06:47:57 * hackagebot gloss-examples 1.9.4.1 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.9.4.1 (BenLippmeier)
06:50:24 <maerwald> bennofs: also interesting talk about liquid haskell (in case you like talks) https://www.youtube.com/watch?v=vYh27zz9530
06:50:31 <bennofs> neuroserpens: t
06:50:39 <bennofs> maerwald: nice, thanks
06:50:40 <neuroserpens> wat?!
06:50:58 <neuroserpens> I am innocent. I just logged in!!!
06:50:58 <bennofs> neuroserpens: sorry, mistyped name
06:51:02 <neuroserpens> Phew.
06:53:16 <maerwald> how precise is it in technical terms to call a constructor (which does not have any input arguments) a function?
06:54:06 <Iceland_jack> maerwald: It's not very precise or helpful
06:55:14 <Iceland_jack> Constant values are sometimes called 0-ary or nullary functions, especially in logic and universal algebra
06:55:59 <Iceland_jack> In Haskell you call things functions whose type is of the form (_ -> _), basically.
06:56:09 <maerwald> you mean the kind?
06:56:22 <Iceland_jack> No
06:56:39 <maerwald> oh right, In see
06:56:39 <bernalex> maerwald: a function is a mapping from a domain to a range.
06:56:41 <Iceland_jack> Were you talking about type constructors
06:56:53 <mauke]]> things whose kind is of the form (_ -> _) are called type constructors
06:57:04 <mauke]]> (call me Maybe)
06:57:23 <bernalex> maerwald: if there is no domain/range it isn't a function. so on term level it's just a term/value. a data constructor without arguments is just a term/value.
06:57:44 <maerwald> ok
06:58:55 <bernalex> given that merijn appears afk/gone, if anyone knows how I'm supposed to get my Setup.hs run/used that would be nice.
06:59:23 <merijn> bernalex: Did you change your cabal file build type to Custom?
06:59:43 <bernalex> merijn: no. thanks. :)
06:59:46 <merijn> mauke]]: I would say that types with kind * can also be constructors
07:00:02 <merijn> mauke]]: i.e. Bool is a type constructor in the same way that True or Nothing or data constructors
07:00:06 <bernalex> merijn: works great! thanks a lot.
07:00:16 <merijn> bernalex: RTFM ;)
07:00:28 <bernalex> merijn: → man cabal                                                                                                                                     alexander@hackintosh:/home/alexander 
07:00:30 <bernalex> No manual entry for cabal
07:00:56 <merijn> bernalex: https://www.haskell.org/cabal/users-guide/
07:01:35 <bernalex> merijn: I find that quite unwieldly... maybe I'm just stupid.
07:03:57 <bernalex> uh. is there no way of deciding what to name the file cabal sdist produces?
07:03:57 <merijn> Anyhoo, it works and the world is saved
07:04:15 <bernalex> merijn: yep. thanks again. :)
07:04:21 <merijn> It produces "packagename-version.tar.gz", doesn't it?
07:04:43 <bernalex> merijn: uh I'm confused how that relates to my question, but yes it does.
07:05:33 <merijn> There's no way to specify anything other than that, afaik
07:06:14 <lpaste> yrlnry pasted “Indentation error” at http://lpaste.net/132386
07:06:31 <bernalex> I guess I'll write a patch for cabal tomorrow.
07:06:46 <yrlnry> I've messed around with the indentation on this quite a lot but I can't get it to work except by deleting all the newlines.
07:06:57 <yrlnry> What am I not understanding?
07:07:28 <mauke]]> yrlnry: the basic rules of layout! :-)
07:07:53 <yrlnry> Could you please be more specific?
07:07:57 <mauke]]> some keywords (such as "where") trigger "layout" (whitespace sensitivity) if not followed by a { token
07:08:20 <mauke]]> the token after the keyword determines the base indentation of the following block
07:08:25 <yrlnry> Oh, I put the if expression indented under where.
07:08:39 <mauke]]> in your example the keyword is 'where' and the next token is 'show'
07:08:42 <yrlnry> Oh, it's because if wasn't indented farther in than show!
07:08:49 <mauke]]> exactly!
07:09:00 <yrlnry> Okay, that was silly.  Thanks.
07:09:15 <mauke]]> I like to always start a new line after where/of/do
07:10:05 <mauke]]> the location of the keyword itself doesn't matter (which is why "instance Foo Bar where" all in one line works)
07:10:31 <yrlnry> Is there a way to get ghci to describe the braces and semicolons it has inferred?
07:11:27 <mauke]]> good question
07:12:58 <merijn> yrlnry: I don't think so, but fortunately the rules are fairly simple and I strongly recommend reading https://en.wikibooks.org/wiki/Haskell/Indentation
07:13:00 <mauke]]> I don't know of such a feature but I haven't really missed it since understanding the "golden rule" of layout
07:13:19 <merijn> After reading that you should never be confused by how to indent again
07:13:59 <yrlnry> Thanks, will do.
07:14:11 <lolisa> Hello, can anyone briefly explain what is a bidirectional type checking? A feel bing search and wikipedia only made me more confused...
07:14:23 <yrlnry> I always listen to people named Merijn, they've never led me wrong.
07:15:04 <c_wraith> yrlnry: actually, there is
07:15:09 <c_wraith> yrlnry: -ddump-parsed
07:16:18 <yrlnry> c_wraith ghc 7.6.3 does not emit any braces or semicolons when I do that.
07:16:26 <c_wraith> huh.  7.8.4 does
07:16:29 <yrlnry> I did:  ghc -ddump-parsed kye2.hs
07:16:33 <yrlnry> Oh well.
07:16:45 <yrlnry> Thanks, I will try it if I upgrade.
07:20:45 <aawe> is it easy to BDD with yesod or other haskell web libraries/frameworks?
07:24:48 <lpaste> yrlnry pasted “Still puzzled about indentation” at http://lpaste.net/132388
07:25:36 <yrlnry> Oh, ignore that, the problem is with the preceding thing, which you can't see.
07:25:40 <kadoban> yrlnry: You usually have to look up from the parse error, when nothing is evident there.
07:25:51 <mauke]]> needs preceding cont... right
07:25:53 <yrlnry> Yeah.
07:26:12 <mauke]]> this is like forgetting the ';' in 'struct foo { ... };' in C
07:26:41 <dolio> -ddump-parsed doesn't print semi-colons even when you used them.
07:26:52 <lpaste> yrlnry pasted “Still puzzled about indentation” at http://lpaste.net/132389
07:27:02 <yrlnry> I'm still boggled.  What is wrong with this?
07:27:36 <mauke]]> yrlnry: missing )
07:27:43 <yrlnry> haha
07:27:44 <yrlnry> thanks!
07:27:44 <mauke]]> line 9
07:28:59 <mauke]]> after desugaring, the parser basically sees (\e -> ... $ Map.assocs m ; listToString ...
07:29:08 <mauke]]> and when it hits the ';', it just gives up
07:29:37 <yrlnry> I understand, thanks.
07:33:57 <ssqq> How to get all built-in function name?
07:34:20 <ion> :browse Prelude in ghci
07:37:01 <kadoban> Does scanl vs. scanr matter as much as the difference between the folds? I'm … not sure which one I should use. I have an infinite list of "differences", like: cycle [2,4], and I want to get [5, 7, 11, 13, 17, 19, etc.] out of it. Both scanr and scanl seem to fit … is one better/worse?
07:37:12 <maerwald> aawe: I found hsp to be a bit tedious, makes debugging harder
07:38:04 <ssqq> ion: thanks, how to change the workdir of WinGHCi
07:39:31 <kadoban> Hmm, answered my own question, scanr never seems to actually yield any values, so I guess that's out, lol.
07:40:13 <mauke]]> scanr doesn't work on infinite lists
07:40:49 <byorgey> @tell JoshieAS =D  any advice?
07:40:50 <lambdabot> Consider it noted.
07:40:56 <c_wraith> yes..  scanl is productive on infinite lists, scanr is not
07:40:58 <ion> ssqq: Perhaps change to the right directory before running ghci? You could also see if ghci has a command for that in :help or use the System.Directory function as the last resort.
07:41:13 <mauke]]> > scanr f z [a, b, c]
07:41:14 <lambdabot>  [f a (f b (f c z)),f b (f c z),f c z,z]
07:41:17 <mauke]]> > scanl f z [a, b, c]
07:41:18 <lambdabot>  [z,f z a,f (f z a) b,f (f (f z a) b) c]
07:41:24 <ssqq> :help
07:41:31 <c_wraith> looks like scanr *can* be productive, then
07:41:32 <kadoban> Ahh, right that makes sense.
07:41:45 <c_wraith> > scanr const 0 [1..]
07:41:46 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:41:53 <c_wraith> yeah, scanr *can* be productive
07:42:07 <mauke]]> but not in a useful way
07:44:29 <anks> can i assume that (!) array function is O(1) ?
07:45:04 <tromp> yes!
07:45:26 <michaelt_> for the regular Data.Array arrays, can that be right?
07:45:48 <maerwald> at least there is no info in the doc, afais
07:46:18 <indiagreen> I always assumed (!) was O(1) for both vector and array, and I would be rather surprised if this was not the case
07:46:27 <anks> It's what i often miss. I come from the world of efficiency to haskell ;]
07:47:11 <anks> Ok, it's not crucial this time so I'll assume it's O(1)
07:47:15 <anks> thanks!
07:48:03 <maerwald> anks: the language report which the package depends on just says "a programmer may reasonably expect rapid access to the components" :P
07:48:10 <maerwald> https://www.haskell.org/onlinereport/haskell2010/haskellch14.html
07:48:16 <anks> and (//) is linear wrt the number of updated elements, right?
07:48:18 <maerwald> so it is "rapid"
07:48:36 <tdammers> for some values of "rapid" :D
07:48:41 <maerwald> :o
07:48:41 <anks> gonna benchmark it one day ^^
07:48:55 <michaelt_> indiagreen: for vector and for unboxed arrays and so on, it would be as people expect, surely
07:49:28 <geekosaur> at one point there was talk of updating all the docs to include big-O (and explanations, including edge cases) by default. guess it never quite happened...
07:49:54 <anks> there are some "O-annotated" packages on hackage
07:50:05 <maerwald> geekosaur: that would be very useful, indeed
07:50:38 <mauke]]> anks: I'd expect // to be O(n + m) where n is the size of the array and m is the size of the update list
07:51:03 <michaelt_> anks: what kind of arrays are you using, what is in them?
07:51:09 <anks> that makes sense
07:51:33 <anks> integer indexed, and some integer tuples in them
07:51:39 <ssqq> When write variable name, type name, function name or define a operator name, whichi char-class could use?
07:51:56 <anks> mauke]]: that makes sense
07:53:04 <ssqq> `data Char = GHC.Types.C#`, char '#' could use as a type name
07:54:20 <mauke]]> ssqq: https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-180002.4
07:54:35 <mauke]]> # is normally invalid there
07:54:47 <mauke]]> but ghc has a language extension (MagicHash) that allows it
07:55:39 <michaelt_> anks why not use Data.Vector.Unboxed, it holds tuples 
08:01:39 <Dodecahedrus> hi, i need some help with the FFI
08:03:10 <Dodecahedrus> i need to use a C++ code from haskell, just a procedure that uses some objects as parameters
08:04:03 <Dodecahedrus> when the procedure finishes the result i want is in one of those objects but i only really need the data in the objects, i don't care for the methods
08:04:21 <Dodecahedrus> what would be the best way to make the FFI code?
08:04:46 <mauke]]> write a C wrapper function
08:04:49 <Freundlich> The FFI does not support C++, so you need to make a wrapper in C first.
08:04:50 <johnw> you'll need to export your functions from C++ using extern 'C"
08:05:48 <Dodecahedrus> do i need to transform the objects into structs?
08:06:06 <johnw> they should already be structs, in memory
08:06:16 <johnw> the "special" bits are at negative offsets to the member location
08:06:28 <johnw> s/member/memory
08:06:39 <Freundlich> It's probably better to use offsetof.
08:08:04 <mauke]]> offsetof is only valid for POD types
08:09:23 <Dodecahedrus> so just using the extern C, and treating it the same as a C function should work? Since the objects are the same as structs in memory i could think of the objects i need to pass to that function as structs as well?
08:31:41 <int-index> I found a GHC 7.10 bug and wrote up a minimal example to trigger it (GHC says: panic! the 'impossible' happened). Here's the gist: https://gist.github.com/int-index/bf5cd1a200257a53c0fc
08:32:30 <int-index> I don't like Trac, so if anyone can report it there, I'd appreciate the help.
08:32:58 * hackagebot pipes-attoparsec 0.5.1.2 - Attoparsec and Pipes integration.  http://hackage.haskell.org/package/pipes-attoparsec-0.5.1.2 (RenzoCarbonara)
08:33:52 <indiagreen> int-index: okay, I'll report it
08:34:11 <int-index> indiagreen: thanks
08:39:27 <ion> Seriously? :-P
08:47:59 * hackagebot pipes-aeson 0.4.1.3 - Encode and decode JSON streams using Aeson and Pipes.  http://hackage.haskell.org/package/pipes-aeson-0.4.1.3 (RenzoCarbonara)
08:58:30 <indiagreen> int-index: just in case, what's your OS and arch?
09:00:19 <warbo> Does anyone know the best way to turn a "Name" from the GHC API ( https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc/Name.html ) into a String? I'm getting "{abstract:Name}" which is rather unhelpful.
09:01:56 <int-index> indiagreen: Gentoo x86-64, and GHC installed using the Nix package manager.
09:02:33 <int-index> Can you reproduce the bug yourself?
09:02:42 <indiagreen> I'm still on 7.8
09:04:28 <int-index> here's my GHC --version output:
09:04:31 <int-index> The Glorious Glasgow Haskell Compilation System, version 7.10.1
09:05:52 <quchen> warbo: I'm pretty sure there is a way, let me see whether I can find it in some old commit
09:06:42 <Squarism> zip is positional combination of lists. is there a functional "named definition" of combining list elements by arbitrary functions and/or keys? 
09:07:59 * hackagebot irc-core 1.1 - An IRC client library and text client  http://hackage.haskell.org/package/irc-core-1.1 (EricMertens)
09:08:55 <quchen> warbo: Hmm, well I used a hack to get them. Using `nameOccName` you can get the `OccName` out of a `Name` and then prettyprint that (`ppr`).
09:09:12 <quchen> Not particularly pretty or stable, but might be a start.
09:09:52 <warbo> quchen: thanks, I'll give it a try (I'm currently doing "occNameString . nameOccName")
09:10:17 <RyanGlScott> Is there an algorithm for deriving a Contravariant instance (similar to -XDeriveFunctor)?
09:11:00 <quchen> warbo: Oh, that looks good.
09:11:14 <tejing> Squarism: depending on what you meant you either want zipWith or you should probably use something with better random access properties than lists
09:11:29 <warbo> quchen: actually, I think there's a couple of different approaches in this code :S
09:11:43 <quchen> warbo: My use case was precisely prettyprinting the name, so using `ppr` was the easiest way :-)
09:11:59 <warbo> quchen: I'm trying to print names and their ASTs, the names seem to work, but it's only in the ASTs that I get "{abstract:Name}"
09:13:00 * hackagebot git-annex 5.20150508.1 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20150508.1 (JoeyHess)
09:14:28 <warbo> quchen: ah, I think it's coming from a generic traversal, I'll try adding a special case
09:17:55 <jophish> What units of measurements library do the cool kids use now?
09:18:00 * hackagebot mangopay 1.11.1 - Bindings to the MangoPay API  http://hackage.haskell.org/package/mangopay-1.11.1 (FelipeLessa)
09:20:34 <Fuuzetsu> units
09:21:15 <glguy> RyanGlScott: Not that I know of. Additionally, GHC Generics can't help, either, due to the restrictions it places on types that can derive Generic1 instances
09:22:42 <RyanGlScott> glguy: Okay, a slightly related question: if you have a Compose-style type (e.g., Compose f g a = Compose (f (g a)))...
09:22:53 <RyanGlScott> glguy: Is there a preferred way to make a Contravariant instance for it?
09:23:10 <glguy> Like this one? (Functor f, Contravariant g) => Contravariant (Compose f g)
09:23:11 <RyanGlScott> There's at least two ways in the contravariant package: http://hackage.haskell.org/package/contravariant-1.3.1.1/docs/Data-Functor-Contravariant-Compose.html
09:23:31 <RyanGlScott> Right, but you could also do (Contravariant f, Functor g) => Contravariant (Compose f g)
09:23:40 <RyanGlScott> Does one have any advantages over the other?
09:23:59 <c_wraith> Each one only works in one case.
09:24:05 <glguy> I think that the advantage is that in some context only one will work for you
09:24:15 <glguy> and so you're able to pick between the two
09:24:15 <Korri> Hi! I'm writing a simple parser for the logical expressions and have a problem with the trifecta's expression parser
09:24:51 <RyanGlScott> Well, the reason I'm curious about this is because I'm interested in trying to derive Contravariant instances with TH, but the case of f (g a) had me stumped.
09:25:24 <RyanGlScott> The contravariant package uses a (Functor f, Contravariant g) instance context for Compose from transformers, so maybe that would be a reasonable default for that case.
09:25:43 <Korri> my reservedOp is defined as: spaces *> (choice . map symbol) op <* spaces
09:25:48 <RyanGlScott> Or, maybe this is a fool's errand. Dunno.
09:26:00 <Korri> so I can have more than one char for the operator
09:26:34 <Korri> and for some reason only the first defined operator works
09:26:43 <Korri> (first in the OperatorTable)
09:26:51 <glguy> RyanGlScott: I think it's a toss-up. I can't think of any reason to generically assume one would work over the other. You'll need a way to determine if f or g are contravariant or covariant (I don't know how you'd do that generically)
09:26:51 <Korri> any ideas what I may be doing wrong?
09:26:52 <phadej> RyanGlScott: you'd have to use different approaches for 'newtype A x a = [a -> x]' and 'newtype A x a = [a] -> x'
09:27:22 <CaptainSandwich> hey, is ghc on arm considered stable? I get a core dump from a program that runs without problems on a windows machine. says illegal hardware instruction...
09:27:32 <glguy> RyanGlScott: Perhaps you could parameterize your generator code with some flags about how to treat a particular type rather than guessing
09:28:54 <glguy> RyanGlScott: There are some functions in TH isClassInstance and classInstances that might be useful?
09:29:22 <c_wraith> CaptainSandwich: unfortunately, there are a *lot* of different versions of arm.  You should probably check https://ghc.haskell.org/trac/ghc/ to see if it's reported, and report it if not
09:29:34 <RyanGlScott> glguy: I'm not worried about existing Contravariant instances, just about how to "guess" what a Contravariant instance should be.
09:29:35 <glguy> I'm sure it won't be totally straightforward to use them for a parameterized type like this, but maybe there's hope
09:29:53 <RyanGlScott> glguy: e.g., if you could do newtype Compose f g a = Compose (f (g a)) deriving Contravariant
09:30:10 <glguy> Oh, for that you'll just have to guess and probably guess wrong half the time
09:30:36 <glguy> I'm thinking of the class where you're using TH to generate the type for concrete types rather than variables
09:30:37 <RyanGlScott> glguy: I do like your idea of making the instance context configurable, though. That could potentially mitigate this issue.
09:31:02 <RyanGlScott> Yeah, concrete types put a wrinkle in a lot of my TH code, unfortunately...
09:31:04 <CaptainSandwich> c_wraith: ty, maybe my arch ghc is a bit messed up, wrong llvm or something
09:31:08 <RyanGlScott> I'm still trying to solve that problem.
09:32:40 <c_wraith> CaptainSandwich: there's also the #ghc channel..  You're more likely to get the question noticed by people who know the system well there
09:32:55 <CaptainSandwich> c_wraith: good idea
09:33:16 <glguy> RyanGlScott: Also the functions I mentioned earlier were from an older version, the new ones are reifyInstances and isInstance
09:33:50 <RyanGlScott> glguy: The problem I've run into with reifyInstances is that it doesn't handle mutually recursive data types well.
09:34:06 <RyanGlScott> e.g., data One a = One (Two a) deriving Whatever; data Two a = Two (One a) deriving Whatever 
09:34:44 <RyanGlScott> I'm not exactly sure how GHC comes up with the instance contexts in that case.
09:35:08 <RyanGlScott> (And, more importantly, how to recreate it with TH.)
09:38:09 <RyanGlScott> glguy: Hm, unfortunately, I thought of another wrinkle in the ability to derive Contravariant mechanically.
09:38:33 <RyanGlScott> If you have something like newtype Triple f g h a = Triple (f (g (h a)), then I can think of four legal Contravariant instances.
09:39:00 <RyanGlScott> As long as you use contramap an odd number of times.
09:49:06 <maerwald> how are implicit parameters different from reflection?
09:52:01 <ChristianS> maerwald: i suppose that implicit parameters are compile-time, while reflection happens at runtime
09:52:06 <geekosaur> I think implicit parameters go with typeclass dictionaries in a hidden parameter
09:52:18 <maerwald> geekosaur: reflection as well afaik
09:52:34 <maerwald> or they call it phantom type
09:52:52 <geekosaur> reflection to me implies runtime lookups
09:53:07 <maerwald> geekosaur: I am talking about the package specifically
09:53:45 <KaneTW> /go 25
09:53:49 <KaneTW> oops
09:54:37 <c_wraith> the reflection package does vaguely evil stuff that's morally the same as not-vaguely-evil stuff, in which values are stuffed into an instance dictionary at runtime
09:55:22 <zq> data E a b; class C t where; instance Show t => C t where; instance (Show u, C v) => C (E u v) where
09:55:36 <zq> i can't see how the two instances overlap
09:55:49 <Twey> What's the haskell-interactive-mode equivalent to inf-haskell-mode's haskell-program-name?
09:56:07 <Twey> That is, I want to set the command to be executed when calling ghci
09:56:27 <maerwald> c_wraith: so it is just runtime vs compile time?
09:56:50 <bennofs> Twey: depends on haskell-process-type. with haskell-process-type set to 'ghci, it's haskell-process-path-ghci
09:58:12 <Twey> bennofs: Hm, I can only give a path, not a whole command?
09:58:25 <Twey> Basically I want to run ‘nix-shell --pure --command ghci’ in the current directory
09:58:38 <bennofs> Twey: make a wrapper shell script. at least that's what I do
09:58:47 <Twey> Mm, okay.  Thanks
09:59:04 <bennofs> Twey: that also allows you to check for the existence of shell.nix or default.nix before executing nix-shell, so you can spawn ghci otherwise
10:00:06 <Haskellfant> there is also haskell-process-wrapper-function
10:00:12 <Twey> Ooh
10:00:31 <Haskellfant> I think it actually has a nix example in the docstring
10:00:37 <bennofs> Haskellfant: oh nice, didn't know that. thanks
10:00:55 <Haskellfant> np
10:00:57 <Twey> Brilliant, thanks
10:01:09 <bennofs> I already have a dwim-ghci script for command line usage anyway though
10:01:09 <Twey> Now I just have to get out of the endless loop of ‘The Haskell process has died’ :þ
10:02:06 <Twey> Oh, I don't seem to have such a variable.  Maybe my version is too old
10:03:01 * hackagebot path 0.2.0 - Path  http://hackage.haskell.org/package/path-0.2.0 (ChrisDone)
10:03:26 <ion> Great description. :-)
10:04:01 <Twey> Haha
10:04:07 <Twey> ‘Does paths’
10:05:15 <zq> When matching, GHC takes no account of the context of the instance declaration (context1 etc). 
10:05:18 <zq> found it
10:05:20 <zq> thanks, guys
10:08:01 * hackagebot mosaico-lib 0.1.1.0 - Generacin interactiva de mosaicos  http://hackage.haskell.org/package/mosaico-lib-0.1.1.0 (mgomezch)
10:09:13 <ttt_fff> correct me if I'm wrong, but haskell's cloudhaskell is quite a few steps away from a full featured stack, say spark
10:09:16 <c_wraith> maerwald: yes. Normally class dictionaries are constructed at compile time.  The reflection package lets you construct them at run time.  There are a few other ways to do the same thing.
10:09:32 <c_wraith> ttt_fff: It's not full-featured yet.  It's working towards it.
10:10:07 <maerwald> c_wraith: I am reading olegs paper again and he claims that reflection works more nicely with the type system and supports concurrent sets of parameters better
10:10:18 <maerwald> than "implicit parameters"
10:10:31 <ttt_fff> c_wraith: so I'm looking at https://amplab.cs.berkeley.edu/software/ ... and I'm like fuck, cloudhaskell looks like a glorified "manage machies via ssh" + "auto serializtion" ... compared to things like having a storage + cluster manager + SQL impl
10:11:18 <c_wraith> maerwald: ultimately, both reflection and implicit parameters do the same job as ReaderT..  And ReaderT is way easier to reason about than either.
10:11:36 <maerwald> c_wraith: but unsuitable if you have to refactor a lot of code...
10:11:50 <c_wraith> So are reflection and implicit params
10:11:56 <poucet_> Do people ever desire a type-classed boolean?  "if' :: (Bool b) -> b -> a -> a -> a"
10:11:57 <c_wraith> Unless you leave off type signatures everywhere
10:12:03 <Twey> ttt_fff: I think Cloud Haskell is supposed to be more of an MPI
10:12:07 <Twey> poucet_: classy-prelude.  But no.
10:12:21 <maerwald> c_wraith: I cannot agree... I mostly only changed type signatures, not definitions... if I introduce another layer of monads, then that will not be possible
10:12:26 <poucet_> Twey: Why not?
10:12:49 <ronh-> what is (Bool b) -> b suppose to mean?
10:12:50 <ttt_fff> Twey: yeah, the amplab stuff looks alot like "program a cluster as if it's a singl emachine with a file system + sql query engine" ... and cloudhaskell is like "jsut let machiens communicate"
10:12:57 <poucet_> Sorry I meant
10:12:58 <maerwald> c_wraith: the initial use case was moving from a static configuration (hardcoded in .hs) to a dynamic configuration (read from file)
10:13:00 <c_wraith> ttt_fff: cloud haskell is building towards a feature set something like Erlang's OTP.  *That* is the goal.
10:13:02 <poucet_> (Bool b) => b -> a -> a -> a
10:13:13 <maerwald> without refactoring everything...
10:13:21 <Twey> poucet_: Because 1) you can express any such thing as a composition of an if and a function that converts it to a Boolean, which is more modular, and 2) it's often better to avoid Booleans anyway
10:13:33 <poucet_> Twey: Alright thanks
10:13:46 <Twey> poucet_: We do miss bool ∷ a → a → Bool → a though ☺
10:13:48 <ronh-> I do wish if was a function though
10:13:55 <c_wraith> Twey: we don't miss it in 7.10!
10:14:03 <Twey> c_wraith: What, it's standard now?  :-O
10:14:06 <c_wraith> yep
10:14:08 <Twey> \o/
10:14:13 <c_wraith> @where bool
10:14:14 <lambdabot> I know nothing about bool.
10:14:15 <poucet_> Twey: Data.Extra.Bools has that. I'm seeing some talk by Tim Williams
10:14:21 <c_wraith> :t bool
10:14:22 <lambdabot> a -> a -> Bool -> a
10:14:22 <poucet_> https://hackage.haskell.org/package/bool-extras-0.3.0/docs/Data-Bool-Extras.html
10:14:33 <c_wraith> poucet_: GHC 7.10 puts it in Data.Bool
10:14:43 <poucet_> good to know
10:15:20 <johnw> poucet_: great talk
10:15:32 <Twey> poucet_: Yeah, it's been in packages forever
10:15:37 <ttt_fff> jquery presents an interesting way to manipulate dom trees; in haskell, is there a way to do something similar for manipulating complicated data structures? (basically selecting / transforming things)
10:15:58 <Twey> poucet_: https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/ — see also
10:16:12 <c_wraith> ttt_fff: yes..  lenses
10:16:20 <poucet_> Twey: Will look after the talk
10:16:46 <muzzle> hi
10:16:47 <ttt_fff> c_wraith: hmm, lenses seems to require that I know "the path" to where something is located, whereas jquery lets me do idiotic things like "select all with attribute xyz," or "select with id foobar"
10:17:23 <muzzle> is there a way to get the current code location in template haskell ? i.e. if I am in a function f in Module M i would like to get a String "M.f"
10:17:38 <muzzle> for error messages
10:17:45 <c_wraith> ttt_fff: You can do that with stuff like the Plated lenses.  Not that I know the details..
10:17:46 <ajf> darn it
10:17:51 <ajf> I want to love Haste, I really do
10:18:01 * hackagebot diversity 0.6.2.0 - Return the diversity at each position for all sequences in a fasta file  http://hackage.haskell.org/package/diversity-0.6.2.0 (GregorySchwartz)
10:18:10 <ajf> but this is the second time I've been unable to build it due to broken code
10:18:24 <mauke> muzzle: http://hackage.haskell.org/package/pseudomacros-0.0.2/docs/PseudoMacros.html
10:18:29 <c_wraith> muzzle: you can get the current module easily enough, but the current function is tougher.
10:22:11 <Twey> You can build lenses arbitrarily deep into a data structure
10:22:41 <c_wraith> Twey: that doesn't help with something like "focus on all the children of this with a particular attributte"
10:22:53 <c_wraith> Fortunately, lens *does* have the tools for that.
10:23:01 <c_wraith> But I've never used them
10:24:10 <bennofs> > let t = Node (Left 3) [Node (Right (Just 4)) [], Node (Right Nothing) [Node (Right (Just 5)) [], Node (Left 0) []]] in t ^.. deep (root._Right._Just)
10:24:12 <lambdabot>  [4,5]
10:24:22 <Bor0> given data Expr = A Expr Expr | S Expr Expr | C Expr Expr | I Int deriving Show. how can I limit C to either another C or I, but not A or S? or should the functions manipulating this structure take care of this?
10:24:26 <bennofs> This finds all nodes who have the label 'Right (Just x)' and returns x
10:24:52 <bennofs> re c_wraith and ttt_fff 
10:24:53 <muzzle> what i want to do is something like: error $(currentLocation) "some thing went wrong here because of x"
10:24:55 <c_wraith> see?  bennofs does know how to use those tools!
10:25:00 <muzzle> would probably make for easier refactoring
10:25:42 <Fuuzetsu> Bor0: you need more types
10:26:01 <Bor0> Fuuzetsu, yeah, I was thinking of that. data Expr and data Concat (for C) and somehow combine those, something like that?
10:26:14 <mauke> Bor0: data CExpr = C CExpr CExpr | I Int; data Expr = A Expr Expr | S Expr Expr | C CExpr
10:26:26 <ReinH> Plated is very cool
10:26:38 <ttt_fff> bennofs: interesting; and I guess there's way to do 'in place' mod; or 'return a new ds with each selected node transformed by following function'
10:26:46 <Bor0> mauke, very cool! thanks. I was already handling this in my functions but now it seems it's time to refactor
10:27:13 <bennofs> > let t = Node (Left 3) [Node (Right (Just 4)) [], Node (Right Nothing) [Node (Right (Just 5)) [], Node (Left 0) []]] in toList (t & deep (root._Right._Just +~ 5)
10:27:14 <lambdabot>  <hint>:1:161:
10:27:14 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
10:27:44 <dale__> hey guys, pretty new to hs. Trying to grok how Parsec works. I've run :t Parsec.char and the type signature isn't immediately straightforward. "Stream s m Char => Char -> Parsec T s u m Char". The main confusion happens before the "=>" character. Could anyone explain this to me?
10:28:07 <c_wraith> dale__: in practice, for the moment, you can mostly ignore it.
10:28:33 <c_wraith> dale__: more specifically, it means "the types s and m are constrained so that there is an instance for Stream for the triple s, m, and Char"
10:28:50 <c_wraith> dale__: broadly, everything before the => is a constraint on the polymorphism of the types
10:28:52 <poucet_> @type cata
10:28:53 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
10:29:00 <mauke> what it means by that is "s must be a stream whose elements are Chars"
10:29:12 <c_wraith> dale__: but in the case of Parsec, it'll mostly just work out
10:29:18 <mauke> and the m is presumably a monad for extracting elements
10:29:39 <bennofs> ttt_fff: actually, here is a real example from a program that extracts data from a web page: toListOf $ deep (el "tr" . failing (hasClass "matchday") (hasClass "friendly_encounter")) ... el "td" ... el "a" . attr "href" . T.unpacked . to normalize . to Match
10:30:21 <bennofs> > let t = Node (Left 3) [Node (Right (Just 4)) [], Node (Right Nothing) [Node (Right (Just 5)) [], Node (Left 0) []]] in F.toList (t & deep (root._Right._Just) +~ 5)
10:30:22 <lambdabot>  [Left 3,Right (Just 9),Right Nothing,Right (Just 10),Left 0]
10:30:28 <bennofs> ttt_fff: ^^^ adding 5 to all matches
10:30:47 <bennofs> (I just flattened the tree at the end for better printing)
10:31:11 <ttt_fff> bennofs: this is pretty intense looking; but most of the 'complexity' is just the 'let t = .... ' part
10:31:14 <ttt_fff> this is oretty cool
10:31:16 <dale__> so c_wraith, I understand generally the point of =>. As other people have said it is to constraint types such that they must be instances of typeclasses. And if I understand you guys correctly, Stream s m Char => must mean that s and m are both instances of Stream
10:31:32 <dale__> but the "Char" is the confusing bit for me
10:31:32 <bennofs> ttt_fff: yeah, constructing trees by hand is not so nice :)
10:31:48 <kadoban> dale__: That's not really what that means.
10:31:49 <c_wraith> dale__: actually, Stream is a multiparameter type class.  It constrains 3 types at the same time
10:31:51 <bennofs> ttt_fff: you can also do stuff like "find all ints"
10:31:56 <dale__> oh. woops
10:32:01 <dale__> ok lemme read up on Streams
10:32:02 <dale__> thanks guys!
10:32:50 <bennofs> @let tree = Node (Left 3) [Node (Right (Just 4)) [], Node (Right Nothing) [Node (Right (Just 5)) [], Node (Left 0) []]]
10:32:51 <lambdabot>  Defined.
10:33:00 <dale__> oh right - this makes more sense. Thanks y'all
10:33:09 <bennofs> > F.toList (tree & template +~ (5 :: Integer))
10:33:10 <lambdabot>  [Left 8,Right (Just 9),Right Nothing,Right (Just 10),Left 5]
10:33:17 <kadoban> dale__: To save you some time … you can mostly ignore the details of the parsec types. Usually you don't care about the details. 1/2 the time I just leave out the type sigs
10:33:23 <bennofs> ^^^^ adding 5 to all Integers in the tree ttt_fff 
10:34:19 <ttt_fff> bennofs: will look more into this later, need to run off to proctor an exam right now
10:34:26 <dale__> thanks kadoban
10:34:33 <ttt_fff> bennofs: thanks for the minimal examples, the keywords I want are 'plated lens" ?
10:34:46 <bennofs> ttt_fff: yes, the module in lens is Control.Lens.Plated
10:34:57 <ttt_fff> bennofs: cool, thanks!
10:35:14 <bennofs> ttt_fff: might also want to look at xml-lens
10:35:25 <bennofs> (the package)
10:38:42 <dale__> apologies - I have one more Parsec related question. I've written parser combinators in other languages before - and I always create a "ParserFail" parser. I.e. one that always rejects the input. How is this done in Parsec? I'd like to do a test inside a parser's do stmnt definition, and upon failing the test, reject the parse (presumably by doing return FailParser)
10:39:25 <exio4> dale__: isn't that mzero? 
10:39:29 <exio4> @type mzero
10:39:30 <lambdabot> MonadPlus m => m a
10:40:15 <int-e> > runParser (fail "oops") ""
10:40:17 <lambdabot>  Not in scope: ‘runParser’
10:41:06 <int-e> @let import qualified Text.Parsec as Parsec
10:41:07 <lambdabot>  Defined.
10:41:11 <int-e> > Parsec.runParser (fail "oops") ""
10:41:12 <lambdabot>      No instance for (Typeable s0)
10:41:13 <lambdabot>        arising from a use of ‘show_M123115401625532108317932’
10:41:13 <lambdabot>      In the expression:
10:41:39 <int-e> > Parsec.runParser (fail "oops") "" :: (Either String (), "")
10:41:40 <lambdabot>      The second argument of a tuple should have kind ‘*’,
10:41:40 <lambdabot>        but ‘""’ has kind ‘GHC.TypeLits.Symbol’
10:41:40 <lambdabot>      In an expression type signature: (Either String (), "")
10:41:51 <int-e> meh.
10:42:37 <c_wraith> That's what happens when you put "" instead of String in the type. :P
10:42:47 <int-e> > Parsec.runParser (fail "oops") "" :: (Either String (), String)
10:42:48 <lambdabot>      Couldn't match expected type ‘(Either String (), String)’
10:42:48 <lambdabot>                  with actual type ‘Parsec.SourceName
10:42:48 <lambdabot>                                    -> s0 -> Either Parsec.ParseError a0’
10:43:34 <c_wraith> Just need two more args.  :P
10:44:07 <int-e> Oh, argh, what is Text.Parse?
10:44:48 <c_wraith> > Parsec.runParser (fail "oops") "" "" () :: (Either String (), String)
10:44:49 <lambdabot>  <no location info>: can't find file: L.hs
10:44:55 <c_wraith> > Parsec.runParser (fail "oops") "" "" () :: (Either String (), String)
10:44:57 <lambdabot>      Couldn't match expected type ‘(Either String (), String)’
10:44:57 <lambdabot>                  with actual type ‘Either Parsec.ParseError a0’
10:44:57 <lambdabot>      In the expression:
10:45:05 <c_wraith> hahaha
10:45:07 <c_wraith> I give up
10:45:07 <Bor0> mauke, how could I pattern match against CExpr within data Expr = A Expr Expr | B Expr Expr | CExpr?
10:45:07 <dale__> int-e and exio4, thanks for your assistance!
10:45:21 <int-e> > Parsec.runParser (fail "oops" >> return ()) () "" ""
10:45:23 <lambdabot>  Left (line 1, column 1):
10:45:23 <lambdabot>  oops
10:45:26 <Bor0> I could turn it to CE CExpr, but maybe there's a better way
10:45:26 <int-e> finally.
10:46:21 <benjamingr> Hey, I'm having a haskell issue and I'm wondering if you guys could help me again: I'm trying to make a circular structure
10:46:37 <int-e> :t Text.Parse.runParser
10:46:38 <lambdabot> Text.ParserCombinators.Poly.Parser.Parser t a -> [t] -> (Either String a, [t])
10:46:45 <int-e> c_wraith: that one confused me
10:46:53 <benjamingr> Let's say a graph (for simplicity), and I need to figure out how to represent semantics of circular structure
10:47:17 <benjamingr> Like a grap where a is connected to b and b is connected to c and c is connected to a. How can I "reference" the same node if they're all values?
10:47:18 <Denommus`> is there something like a StringBuffer for Haskell?
10:47:31 <c_wraith> benjamingr: will you be updating the structure, or will it be static once fully constructed?
10:47:35 <Denommus`> where I "print" some values and then I take a String out of it?
10:47:52 <Denommus`> I wouldn't mind if it was wrapped in IO
10:47:54 <benjamingr> c_wraith: I might update it, but I'll do so by returning a copy with the modified data.
10:48:25 <mmachenry> benjamingr: One easy way to do that is a list of nodes where each node has an id and a node it connects to. 
10:48:56 <hodapp> benjamingr: http://foswiki.cs.uu.nl/foswiki/pub/Afp/CourseLiterature/Gill-09-TypeSafeReification.pdf may be worth a read
10:49:03 <benjamingr> mmachenry: that's what I did, a list of nodes where the list index is the "id" of the node, but it felt dirty, the alternative of assigning actual numerical IDs to them sounded worse.
10:49:04 <mmachenry> [Node A [B], Node B [C], Node C [A]] … for extra points put that in a Map or something so it's quick to lookup by ID.
10:49:34 <benjamingr> hodapp: not sure why, but thanks, I'll look into that
10:49:36 <exio4> Denommus`: I don't know what you specifically want to do, but DList String + Writer seems to be somewhat close to what you want to do? 
10:49:50 <hodapp> benjamingr: you're describing a similar scenario
10:50:23 <benjamingr> Ok, you've all helped me again, both in approaches and in understanding there's no "magic" around this (keeping some form of identification for reference myself since it's all value semantics)
10:50:41 <hodapp> well... there's *some* magic, for certain methods :)
10:50:41 <geekosaur> or maybe the io-streams package
10:50:57 <geekosaur> (and probably pipes/conduit)
10:51:39 <maerwald> any1 good with liquidhaskell? cannot figure out why I get termination error for fak2, but not for fak3 http://lpaste.net/132400
10:52:35 <maerwald> the only difference is the type signature
10:53:05 <Denommus`> exio4: never used Writer, will check
10:53:20 <c_wraith> maerwald: It knows that it doesn't know everything about all instances of Num
10:53:21 <maerwald> I can only think of something like it assumes it doesn't know anything about how 'substract' is implemented for a given Num type
10:53:24 <maerwald> right
10:53:27 <maerwald> that's what I thought
10:54:07 <maerwald> c_wraith: but the error msg is still a bit confusing
10:54:31 <c_wraith> maerwald: liquid haskell is still at the level of a research project.  A lot of its error messages are confusing. :)
10:54:44 <maerwald> c_wraith: pff, ghc error messages are not confusing? :P
10:54:56 <c_wraith> ghc has 20 years more development time :)
10:55:07 <maerwald> and is still confusing me...
10:55:22 <kadoban> maerwald: Not really, once you understand the concepts the vast majority of them are quite clear IMO.
10:56:03 <exio4> they're clear as long as you don't mix DataKinds, GADTs, TypeFamilies, MPTC, fundeps, and RankNTypes 
10:56:09 <hodapp> I have yet to see a Haskell error that is 50 times the length of my program. In C++ that was... frequent.
10:56:45 <maerwald> kadoban: cannot agree after 1 year of digging into haskell. There are still lots of type error msgs that do not clearly show what went wrong, because the typechecker finds an error at a totally different spot than you expected
10:57:47 <geekosaur> relying on type inference everywhere is pretty much guaranteed to lead to that
10:57:48 <c_wraith> maerwald: that's just because it tries *so hard* to interpret things such that you are right, and reports the point where it finally gives up.
10:58:17 <geekosaur> it's a good idea to use top level signatures whenever you can. also acts as a good sanity check that you and the compiler agree what the binding is supposed to do
10:59:06 <kadoban> maerwald: That generally happens when I don't put enough type annotations … which GHC can't really do much about. If my types are a complete mess, I can't exactly blame it for taking the wrong guess at a fix.
10:59:18 <maerwald> c_wraith: can you think of a way to make liquidhaskell accept the function without resorting to Int type? I guess I have to add a guarantee somewhere that says "x - 1 can never be less than 0"
10:59:53 <c_wraith> maerwald: that's not enough.  It needs some structural guarantee that if you subtract 1 enough times, you will eventually end up at 0
11:00:05 <maerwald> mh
11:00:34 <c_wraith> maerwald: I don't know how to encode that guarantee in liquid haskell
11:02:24 <c_wraith> maerwald: you can cheat a bit, though. If you restrict the type to an instance of Integral, and constraints on what you get out of toInteger
11:03:20 <c_wraith> maerwald: but then you have to perform the computation in terms of Integer, which might be sacrificing some efficiency
11:04:31 <c_wraith> maerwald: at that point, you're really not getting any benefits over just defining it on Integer, though
11:05:13 <maerwald> c_wraith: well, I don't actually use that code, it's just for fun... but yes, I was also thinking about some way to do it via type classes
11:06:14 <c_wraith> maerwald: at the moment, that's the biggest weakness of liquid haskell I've seen..  It doesn't work nicely with type classes - because it would kind of be unsound if it just made assumptions about implementations.
11:06:50 <maerwald> c_wraith: it probably needs some way that you can shove those assumptions in directly
11:07:34 <maerwald> sure, you lose some "safety" then, but who implements a (-) that does random crazy things
11:08:08 * hackagebot cassava 0.4.2.4 - A CSV parsing and encoding library  http://hackage.haskell.org/package/cassava-0.4.2.4 (JohanTibell)
11:08:12 <enthropy> > 2 - 3 :: Nat
11:08:13 <lambdabot>  Not in scope: type constructor or class ‘Nat’
11:08:19 <enthropy> > 2 - 3 :: Natural
11:08:20 <lambdabot>  *Exception: Natural: (-)
11:08:27 <c_wraith> Maybe it's not random and crazy?  You can implement a lazy natural number type that allows infinity
11:08:50 <c_wraith> In that case, subtracting 1 repeatedly is not guaranteed to eventually reach 0
11:09:55 <Eduard_Munteanu> inf = 1 + inf
11:11:01 <ReinH> c_wraith: violating the peano axioms for fun and profit
11:11:18 <Eduard_Munteanu> (it's just that in Agda, more or less)
11:11:21 <Fuuzetsu> 0 - x = 0 -- fixed
11:13:04 <c_wraith> > 1/0
11:13:05 <lambdabot>  Infinity
11:13:07 <c_wraith> > 1/0 - 1
11:13:08 <lambdabot>  Infinity
11:13:11 <dale__> sweet. My parser is working great. Thanks again to everyone who helped me out! :D
11:13:16 <saml> does haskell have promise?
11:13:43 <c_wraith> saml: do you mean like what's in the async package?
11:13:51 <saml> yes
11:13:52 <kadoban> dale__: Nice :)
11:13:54 <saml> let me check async
11:14:11 <kadoban> I thought he meant like, will haskell be any good someday XD
11:14:21 <Eduard_Munteanu> Hah.
11:14:21 <saml> https://hackage.haskell.org/package/async? looks real old
11:14:34 <Eduard_Munteanu> saml, yes, and it's not old
11:14:50 <merijn> Why does it look old?
11:14:51 <c_wraith> That last release was december.  That's not old. :)
11:15:06 <Denommus`> uh
11:15:09 <saml> npm pushes new versions like every day
11:15:10 <Denommus`> where is toUpper defined now?
11:15:19 <saml> async is recommended package?
11:15:28 <saml> trying to compare node.js async vs. haskell
11:15:30 <joeyh> this may say something about npm.
11:15:32 <merijn> saml: Why would you push new versions everyday?!
11:15:40 <exio4> saml: it depends, what do you actually want to solve?
11:15:46 <maerwald> c_wraith: a liquidhaskell dev says that it assumes Integer when there is Num, so it looks almost like a bug
11:15:47 <kadoban> Denommus: Data.Char ?
11:15:49 <Eduard_Munteanu> saml, yes, it's a common dependency / library
11:15:55 <saml> trying to show node.js devs how superior haskell is
11:16:04 <simpson> saml: You will not convince them.
11:16:08 <Eduard_Munteanu> @hoogle toUpper
11:16:08 <lambdabot> Data.Char toUpper :: Char -> Char
11:16:08 <lambdabot> Data.Text.Internal.Fusion.Common toUpper :: Stream Char -> Stream Char
11:16:08 <lambdabot> Data.Text toUpper :: Text -> Text
11:16:09 <merijn> You can't
11:16:10 <c_wraith> saml: haskell packages don't need to update daily to work properly. :)
11:16:27 <saml> has there been attempts or blog posts?
11:16:36 <Denommus> kadoban: thanks
11:16:53 <saml> about comparing cooperative concurrency of node.js vs. preemptive of haskell or java or ..
11:17:16 <merijn> node.js doesn't have cooperative concurrency it has no concurrency
11:17:21 <merijn> It has callbacks and async IO
11:17:29 <merijn> You can't do multithreading in node.js
11:17:43 <exio4> I'd assume what you want is just green threads 
11:17:57 <simpson> merijn: Asynchronous I/O is a form of concurrency; one can have concurrent I/O with a multiplexer.
11:18:01 <michaelt_> saml: async is one of the best packages there is
11:18:03 <ReinH> Haskell's least concurrent runtime configuration is roughly equivalent to node.js's most concurrent runtime configuration
11:18:17 <saml> at my knowledge of haskell and in programming in general, i don't think i can persuade any javascript developers in anyway
11:19:05 <exio4> saml: what are you actually doing? 
11:19:22 <ReinH> (which is also node.js's only concurrency option)
11:19:33 <exio4> as-in, the specific problem
11:19:39 <saml> we're almost ready to switch to node.js/javascript 100%. i'm trying to make counter argument to the team
11:19:43 <ReinH> merijn: I think you're confusing concurrency with parallelism.
11:19:55 <simpson> saml: `[] == []`
11:20:02 <simpson> saml: If this does not convince them, then they are lost.
11:20:05 <ReinH> simpson: heh
11:20:08 <saml> >  [] == []
11:20:09 <Eduard_Munteanu> Headline: top Javascript developers commit mass suicide, realizing what a waste of time Node.JS was, after being set straight by an unnamed Haskell developer.
11:20:09 <lambdabot>  True
11:20:15 <xplat> saml: switch from what?
11:20:21 <saml> what that's false in javascript
11:20:39 <saml> from java
11:20:57 <simpson> JavaScript is not related to Java.
11:21:12 <michaelt_> oh [] == [] is 'false', hm
11:21:22 <maerwald> saml: one problem is that the "static" type system... as in: beginners barely get anything to compile. I guess you really need a lot of interest to overcome the initial shock.
11:21:24 <exio4> simpson: just checked, http://dpaste.com/1422Q8G 
11:21:27 <Eduard_Munteanu> Well, Java is a better-designed language, at least. :)
11:21:28 <simpson> JavaScript is like Self, but was rushed in its implementation and now enshrines some really bad rules.
11:21:41 <xplat> simpson: sure it is, they both have similar names and both run in a browser or a webserver or a mobile phone
11:21:47 <johnw> it's also hard to pry JS developers away from awesome debuggers like Firebug, into a realm where there are no stack traces and space leaks can be very difficult to track down
11:22:14 <ReinH> maerwald: I would suggest that if you can't get anything to typecheck, you probably can't get anything to run in a language without typechecking
11:22:27 <ReinH> you just won't know it's broken until (much) later
11:22:29 <maerwald> ReinH: javascript does something even if the code is broken :)
11:22:46 <ReinH> maerwald: yes, which is exactly the opposite of the behavior I want
11:22:48 <maerwald> ReinH: right, most software is like that :P
11:22:59 <xplat> ReinH: you can get it to run and produce a stack trace, which js developers already know how to read
11:23:15 <saml> johnw, it's very hard to profile a node.js app from my limited experience.  and most of our team just use console.log() to "debug"
11:23:17 <ReinH> Well, at least the first part is true
11:23:28 <michaelt_> false == 0 is 'true' in javascript, nice.
11:23:41 <johnw> saml: oh, well in that case
11:23:43 <ReinH> At least == is commutative... almost.
11:23:53 <saml> let me study async package
11:24:09 <johnw> saml: pay someone like me to come give an evangelizing presentation on why Haskell will it easier for them to wake up in the morning :)
11:24:23 <pharpend> I have the weirdest issue
11:24:24 <Eduard_Munteanu> And look in the mirror.
11:24:27 <ReinH> michaelt_: http://dorey.github.io/JavaScript-Equality-Table/unified/
11:24:35 <saml> johnw, have blog or something?
11:24:36 <xplat> johnw: as opposed to wake up in the middle of the night?
11:24:45 <johnw> saml: newartisans.com
11:24:51 <saml> thnks
11:24:54 <ReinH> Well, that table looks commutative
11:24:56 <johnw> xplat: that comes later
11:24:56 <dmj`> saml: we're using node as an api layer to munge together a bunch of different micros service apis, this way the mobile clients only have to query one service, no types means silent failing, and no amount of unit tests in node can account for every possible scenario. 
11:24:56 <maerwald> saml: the yesod homepage has a few good arguments you can probably steal
11:25:17 <pharpend> I have a file that compiles just fine if I compile it with 'ghc'. But, if I try to 'cabal install' the project, the compiling fails
11:25:18 <dmj`> saml: total functions are freedom 
11:25:38 <ReinH> Well, at least the standard says it should be comutative
11:25:40 <maerwald> dmj`: you use liquidhaskell to check for them? :D
11:25:41 <dmj`> pharpend: what is the error? Do you have a cabal file?
11:25:44 <johnw> saml: my last company did training as half its business, so I would be more than happy to come facilitate a transition toward Haskell
11:25:48 <pharpend> http://lpaste.net/132402
11:25:49 <barrucadu> pharpend: Are you importing something which isn't in your build-depends?
11:26:00 <barrucadu> huh
11:26:12 <pharpend> barrucadu: It's not a type error or an import error - it's an error with 'ld'
11:27:09 <c_wraith> pharpend: I feel like some previous thing got corrupted
11:27:34 <geekosaur> 7.10? could this be an instance of that reproducible builds/hashes thing?
11:27:51 <pharpend> c_wraith: I deleted my sandbox & reinstalled, same errror
11:27:53 <pharpend> error
11:27:57 <geekosaur> ...ohai freenode :/
11:27:59 <ReinH> pharpend: cabal clean and try again
11:29:26 <pharpend> ReinH: http://ix.io/iuC
11:31:27 <ReinH> Huh. Remove ./dist and try again.
11:33:07 <geekosaur> I feel like I've seen that and it's related to cabal's library vs. executable thing
11:34:13 <muzzle> is there an Array.array equivalent for Data.Vector ?
11:34:16 <ReinH> geekosaur: that usually shows up as a "wrong version" error
11:34:38 <ReinH> geekosaur: This is usually solved by successive attempts to remove everything cabal has created when building the package ;)
11:36:27 <wolftune> if I do cabal install -fdev and then later do cabal clean && cabal build, will I build with -fdev or no?
11:36:37 <geekosaur> it won't
11:36:40 <pharpend> wolftune: cabal configure -fdev I believe
11:37:43 <wolftune> geekosaur: so, does that mean I should assume cabal clean removes any flags from any "use flags from last time" sort of things?
11:38:16 <ReinH> @google cabal of cabal
11:38:17 <lambdabot> http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
11:38:19 <Zemyla> Sigh, I feel really bad and stupid Haskell-wise.
11:38:21 <bennofs> Is there a package for storing n to m bidirectional mappings in Haskell? i.e. I have N items of kind A and m items of kind B. Each object of kind A is related to zero or more objects of kind B and vice versa. I'd like O(1) time to query all items that I given item of either kind A or B is related wizh
11:38:28 <geekosaur> it removes the configuration information, along woth other generated files
11:38:32 <ReinH> wolftune: cabal install doesn't play well with cabal configure
11:38:38 <ReinH> wolftune: That link has a bit more info
11:38:49 <pharpend> bennofs: make 2 hashmaps?
11:38:52 <wolftune> thanks
11:39:01 <geekosaur> I think if you want to record flags, you can do something in cabal.sandbox.config
11:39:07 <Eduard_Munteanu> There's a bimap somewhere.
11:39:10 <ReinH> geekosaur: cabal.config
11:39:24 <pharpend> ReinH: I thought that was just for stackage =P
11:39:26 <Zemyla> I wrote an optimizing Brainfuck compiler, and one of the optimizations was causing Mandelbrot.bf to error out with an access before the start of the tape for some reason.
11:39:30 <Eduard_Munteanu> But the complexity is Map-like, IIRC.
11:39:36 <wolftune> geekosaur: ooh, cabal.sandbox.config?? I can have a config set only to the sandbox and not in my .cabal file?
11:40:13 <Zemyla> No clue why. In the end, I simply extended it backwards before 0, and the Brainfuck programs seem to work just fine.
11:40:22 <geekosaur> hm, right, that's not the right file for flag foo...
11:40:37 <geekosaur> it is cabal.config overrides, yes, flags aren't usually that though
11:40:39 <ReinH> bennofs: you shouldn't expect O(1) querying of a functional data structure
11:41:32 <bennofs> ReinH: right. I'm thinking of having something like vectors update, like update :: SomeMonad () -> SomeData A B -> SomeData A B that can efficiently modify the relations
11:41:55 <ReinH> bennofs: Are you sure you can't accpt O(log n)?
11:42:05 <ReinH> It's pretty darn close to O(1)
11:42:12 <bennofs> well, I guess I could try
11:42:19 <infandum> Using pipes, how do I append to a pipe? I just want to add an empty string to a pipe so it ends in a newline when written to a file.
11:42:31 <bennofs> ReinH: really I'm more interested in constant factors tbh
11:42:41 <bennofs> it's only about 12 elements for each of A and B max
11:42:55 <Zemyla> Am I a bad programmer for having to resort to such a clumsy kludge?
11:43:05 <michaelt_> infandum:  pipe >> yield ""  -- ?
11:43:24 <bennofs> but it is in the inner loop (scoring functions for evaluating game situations in a game AI) so efficiency is pretty important
11:43:28 <ReinH> michaelt_: probably
11:43:57 <michaelt_> infandum: of course that will make the return type be (), which may not be what the rest of the pipeline is
11:44:39 <Fuuzetsu> @pl f x = foo >> return x
11:44:39 <lambdabot> f = (foo >>) . return
11:45:02 <bennofs> x <$ foo ?
11:45:07 <Fuuzetsu> oh yeah, that's the one
11:45:38 <infandum> michaelt_: Oh. I figured it was something like that but was confused how it works with (P.fromHandle h >-> P.filter blah >-> P.map blah2 >-> P.toHandle h2). It seems like I can do ((all that) >> yield "") >-> P.toHandle h2
11:45:40 <ReinH> michaelt_: but then you can just tack on a >> return x if needed
11:46:07 <lpaste> Bor0 pasted “#5” at http://lpaste.net/132403
11:46:07 <Eduard_Munteanu> pipe *> yield ""   ?
11:46:11 <bennofs> geekosaur: relation seems to be more what I want, as each item can be related to multiple others
11:46:12 <Eduard_Munteanu> Er.
11:46:18 <Eduard_Munteanu> <*
11:46:24 <exio4> bennofs: which kind of operations will you be doing with those? 
11:46:32 <Bor0> do you guys have any recommendations to improve and make the code more elegant? http://lpaste.net/132403
11:46:47 <bennofs> exio4: mostly lookup which items are related to which items of the other kind
11:47:08 <michaelt_> infandum: right
11:47:27 <bennofs> exio4: right now I'm using two Vector [Int]'s, relating the items by their indices in the vector. Then I have aData :: Vector A and bData :: Vector B storing the actual item data
11:47:54 <infandum> Wait, so which is the most elegant solution easy to read wise?
11:48:13 <bennofs> Just thinking that this is pretty common and maybe there is already a nice libary?
11:48:14 <wolftune> ok, so, if I do cabal configure -fdev and later do cabal clean, will I need to rerun cabal configure?
11:48:33 <dcoutts> wolftune: yes, to preserve use cabal clean --save-config
11:48:57 <wolftune> dcoutts: ah thanks
11:49:10 <Eduard_Munteanu> bennofs, maybe   http://hackage.haskell.org/package/bimap-0.3.0/docs/Data-Bimap.html
11:49:14 <ReinH> bennofs: what makes this mapping bidirectional?
11:49:56 <bennofs> ReinH: ok concrete examples: I have penguins (player pieces) which can be on multiple "board areas". Each board area can have multiple penguins in it
11:50:43 <michaelt_> infandum: you wouldn't be able to attach (>> yield "") to the P.map or P.filter bits, since they are infinite pipes; they would be closed down before you got to the 'yield ""' part
11:50:53 <ReinH> bennofs: are the pieces identical?
11:51:04 <bennofs> I need to be able to both: query which board areas contain a given piece, and which pieces are contained by a given board area
11:51:19 <ReinH> as in, can you tell two penguins apart?
11:51:29 <bennofs> ReinH: they have different positions, and there are 4 penguins for player red and 4 penguins for player blue, but otherwise they are identical
11:51:34 <infandum> michaelt_: I mean, I would be appending "" after everything as it's being written to the file, right?
11:51:45 <ReinH> Ok, then I would just use  Vector Int of penguin counts indexed by board position
11:51:59 <ReinH> write a module to handle updating it in an atomic way and make it an abstract data type
11:52:24 <michaelt_> infandum: right, the way you did it is good. basically you are isolating a big producer with fromHandle h1 >-> map thus >-> filter so , a string producer.  then you are appending a "" to it
11:52:31 <roelof> helllo, Im trying to learn haskell by the CIS194 course and I noticed that I do not get a good grip about recursion. Is there a book or tutorial with exercises that I can follow ? 
11:52:34 <bennofs> ReinH: I need to know the positions of the penguins inside the area too
11:53:28 <kazagistar> is there some vector that uses Ix?
11:53:37 <ReinH> bennofs: how do you use that imformation?
11:53:43 <bennofs> but yes, basically what I have right now is penguinsForArea :: Vector [Int] and areasForPenguin :: Vector [Int] and then penguinInfo :: Vector PenguinInfo and areaInfo :: Vector Area and I'm careful to keep the two in sync
11:53:43 <Eduard_Munteanu> kazagistar, Array?
11:53:45 <kadoban> roelof: Other than the exercises in the cis194 course itself?
11:53:47 <infandum> michaelt_: Yeah, I just tried it and it works. It seems a little verbose though, as I need to group the prior in parentheses--is there a nice >> way so it "seems" like everything is pushed through then the rest is appended?
11:53:48 <michaelt_> roelof: I think the standard general haskell tutorial is http://learnyouahaskell.com/chapters but I don't know if it's better than your course material ...
11:53:55 <ReinH> bennofs: maybe a bimap if position <-> count then
11:53:58 <ReinH> s/if/of
11:54:00 <Fuuzetsu> IIRC no exercises in LYAH
11:54:11 <ReinH> but you don't need to store individual penguins, just information about their counts
11:54:22 <roelof> kadoban:  yes, other then the exercises of CIS194 
11:54:24 <geekosaur> cis194 is based on lyah, isn't it?
11:54:32 <Fuuzetsu> uh, don't think so?
11:54:39 <michaelt_> haha
11:54:44 <kadoban> geekosaur: No. It gives LYAH as suggested reading in parts, but that's about it.
11:54:56 <ReinH> bennofs: or do you just need to answer questions like "when board positions have a red penguin on them"?
11:55:04 <michaelt_> right no exercises, sorry I mentioned it roelof 
11:55:08 <kazagistar> roelof: if it is any consolation, recursion takes many programming students quite a bit of effort and practice to get a grip on
11:55:11 <ReinH> s/when/which
11:55:26 <roelof> Maybe a idea to solve the list problems of 99 haskell problems recursive ? 
11:55:39 <roelof> michaelt_:  no problem 
11:55:50 <Eduard_Munteanu> roelof, or implement Data.List functions yourself.
11:55:52 <kadoban> roelof: Those are kinda awful, IMO. They're a port from some language where they made more sense.
11:56:04 <bennofs> ReinH: I want to answer questions like: what are the positions of the penguins in this area? (an area consists of multiple positions, some of which might not have penguins on them)
11:56:05 <ReinH> michaelt_: I wouldn't call LYAH "the standard general haskell tutorial"
11:56:08 <ReinH> it's not very good
11:56:17 <roelof> kazagistar:  I know , that why I asked your experts on help 
11:56:22 <michaelt_> ReinH: which is better though?
11:56:24 <kazagistar> roelof: try looking at this, I think this might help get a good, practical grip on how recursion works in haskell http://chrisuehlinger.com/LambdaBubblePop/
11:56:42 <maerwald> I found LYAH it too verbose to read
11:56:50 <ReinH> michaelt_: Is a bad tutorial preferable to no tutorial? ;)
11:56:54 <kadoban> michaelt_: spring '13 cis194 is
11:57:01 <michaelt_> ReinH: point taken.
11:57:28 <ion> kazagistar: Heh, that’s a fun idea.
11:57:30 <ReinH> cis194 is good, NICTA is good
11:57:33 <ReinH> There are some good books
11:57:42 <ReinH> Bird's new book especially
11:58:14 <Eduard_Munteanu> Perhaps  https://en.wikibooks.org/wiki/Haskell/Recursion
11:58:37 <michaelt_> roelof why not define data Nat = Zero | Succ Nat deriving Show and implement instance Show Nat where show ... and instance Eq Nat where  ... , and then define plus :: Nat -> Nat -> Nat and  so on. 
11:58:41 <johnw> as someone who absolutely zero about functional programming, LYAH was a very comfortable introduction to it in the context of Haskell
11:58:48 <kazagistar> ion: for procedural languages, I recommend drawing the stack to get a "visual" for what is happening, but for functional, you can just play with how the expression is expanded, which I think that tool is really good for
11:58:58 <johnw> for a functional programmer who might know a bit of Haskell, I can see it as imposing unnecessary inertia
11:58:59 <michaelt_> roelof: woops, didn't mean to derive Show there but to implement it.
11:59:03 <ReinH> bennofs: I think Data.Vector.findIndexes might solve part of that problem
11:59:19 <ReinH> findIndexes (> 0)
11:59:47 <ReinH> er, findIndices
11:59:48 <roelof> Eduard_Munteanu:  Do you mean only these functions :  head, tail. last. iniit and last ? 
11:59:52 <ReinH> because I know what the plural of index is
12:00:20 <ReinH> johnw: I think it's too shallow, too hand wavey, and the lack of exercises is a real problem for actual retention
12:00:24 <bennofs> ReinH: hmm ok. I think I'll just stick with what I have now, since there doesn't seem to be a library that I can use
12:00:40 <Eduard_Munteanu> roelof, no, you can do (++), folds and what not
12:01:06 <johnw> ReinH: yeah, different strokes and all
12:01:12 <ReinH> johnw: sure
12:02:09 <CurryWurst> hi guys
12:02:14 <roelof> Eduard_Munteanu:  oke, first I have to find out what fold exactly does ? 
12:02:20 <kazagistar> ReinH: you might be right... I just read LYAH and tbrought my own programs to write for practice as I went along (including the 99 problems, a mini-language interpreter, etc)
12:02:26 <CurryWurst> i need a help with one function
12:03:06 <Eduard_Munteanu> roelof, oh, ok, start simpler then... do those you mentioned and perhaps (++) and reverse.
12:03:59 <roelof> oke, I will do these the next few days and hopefully I can then solve the problems of CIS194 myself 
12:04:08 <CurryWurst> http://lpaste.net/132371 <- to find a max of each of the inner lists without creating foldable instance
12:04:26 <roelof> I have problems to figure out what the base case is in difficult problems 
12:04:36 <davidturner_> Possibly OT question: why do certain authors to Haskell mailing lists follow their initial greeting with an asterisk? E.g. https://mail.haskell.org/pipermail/haskell-cafe/2015-May/119528.html
12:05:16 <geekosaur> it's a wildcard ("all")
12:05:26 <kadoban> davidturner_: It's probably something like … you know how people used to say   Hello <Person Name> or Hello Guys ? It's like Hello <whatever you want here>
12:05:28 <geekosaur> unix humor of a sort, I guess
12:05:43 <DanielDiaz> I want to show a big number of seconds in a human-friendly way (like "2 years, 4 months, 15 days, 2 hours"). I know how to do it myself, but I just want to know if there is any library that has already done this for me.
12:05:47 <DanielDiaz> thanks
12:06:19 <Fuuzetsu> kadoban: davidturner_: well, it's just ‘Hello all, …'
12:06:29 <roelof> Eduard_Munteanu:  have you any tips how to know what the base case is in difficult cases like towers of hanoi ? 
12:06:41 <CurryWurst> i got the idea to use the foldable instance for it, but it seems to be a little bit complicated
12:06:52 <ReinH> roelof: Are you in the mood for a good Haskell book?
12:07:15 <kadoban> roelof: The base case is just whatever you can solve trivially yourself. Like for sorted lists, a one-or-zero-element-list is already sorted, so yay basecase.
12:07:26 <davidturner_> geekosaur: kadoban: and there was me hoping it referred to some clever footnote somewhere! I'll read it as a glob from now on. Thanks
12:07:28 <ronh-> DanielDiaz a year and month aren't good units of duration because their duration depend on the date
12:08:16 <michaelt_> roelof: here's some exercises, fill in the 'undefined' bits
12:08:27 <DanielDiaz> ronh-: although I see your points, I don't need that accuracy. Plus, days aren't 24 hours long either.
12:09:02 <geekosaur> ob http://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time
12:09:19 <kazagistar> CurryWurst: break it up into subproblems... { weight :: Bundle -> Int } then { map (\x -> (weight x, x)) }, sort by the weights, and return the bundles
12:09:27 <ReinH> @hackage friendly-time -- DanielDiaz
12:09:28 <lambdabot> http://hackage.haskell.org/package/friendly-time -- DanielDiaz
12:10:29 <michaelt_> roelof: forgot to link my exercises http://lpaste.net/132409
12:10:38 <roelof> ReinH : IM always in the mood for a good book about Haskell 
12:11:22 <kazagistar> CurryWurst: Foldable has the wrong Kind, it wouldn't really work, unless you change the type of Bundle
12:11:28 <ReinH> roelof: http://www.amazon.com/Thinking-Functionally-Haskell-Richard-Bird/dp/1107452643 contains a whole chapter on induction
12:11:33 <ReinH> it's a wonderful haskell book
12:11:42 <roelof> michaelt_:  I think for a real beginner like me the exercises are not clear and too difficult 
12:12:42 <CurryWurst> kazagistar: I'm not allowed to change the type :(
12:13:11 <kazagistar> CurryWurst: then yeah, try to break it up into smaller tasks like I suggested
12:13:43 <DanielDiaz> ReinH: thanks. Although this is for showing a time in the past in the form "3 hours ago". I think I'll go with implementing it myself, it won't take long. Thanks!
12:14:00 <frerich> CurryWurst: You could also define a function 'toList :: Shipment -> [Float]' and then use the standard 'maximum' function on that (in case you don't want to go for a generic 'define a fold first' approach)
12:14:31 <ReinH> CurryWurst: why wouldn't you want to create a Foldable instance?
12:14:35 <roelof> ReinH:  I will take a good look at that book . Thanks for the tip 
12:14:45 <ReinH> CurryWurst: Your type is just a rose tree.
12:16:07 <CurryWurst> I thought there is a simpler way to do so
12:18:21 <maerwald> roelof: I found that implementing/reverse-engineering _imperative_ algorithms in haskell gives a better learning experience. Anyone can do fibonacci in haskell, what's the point. So take anything you already know and try it.
12:18:40 <michaelt_> > pure 0 :: Data.Tree.Tree Int
12:18:41 <ReinH> > maximumBy (comparing snd) . fmap (\t -> (t, sum t)) $ [Node 1 [], Node 3 [], Node 2 [Node 5 []]]
12:18:42 <lambdabot>  Node {rootLabel = 0, subForest = []}
12:18:42 <lambdabot>  <no location info>: can't find file: L.hs
12:18:56 <maerwald> roelof: but do it in idiomatic haskell, not in the IO monad :P
12:18:58 <ReinH> > maximumBy (comparing snd) . fmap (\t -> (t, sum t)) $ [Node 1 [], Node 3 [], Node 2 []]
12:18:59 <lambdabot>  (Node {rootLabel = 3, subForest = []},3)
12:20:18 <Denommus> hm, is there a prettier way to write join (foo <$> bar)?
12:20:40 <michaelt_> >>= 
12:21:08 <ReinH> foo =<< bar
12:21:57 <Denommus> ah, it was not working because I was missing parentheses
12:22:02 <maerwald> roelof: one thing I found exceptionally nice is the graham scan algorithm... look at the imperative pseudocode and think how to solve it in haskell
12:22:14 <maerwald> it's really just basic list operations
12:22:31 <maerwald> https://en.wikipedia.org/wiki/Graham_scan
12:23:14 <maerwald> and only 6-7 loc in haskell
12:24:07 <Fuuzetsu> well that pseudocode is not exactly optimised for space
12:25:00 <roelof> Everyone thanks . Enough to do the next few days / weeks 
12:25:22 <maerwald> Fuuzetsu: actually the pseudocode is very bad, there's a more specialized version around somewhere, but I only have it in some of my personal slides
12:25:30 <roelof> I hope your experts will check my code if I can make it work 
12:27:05 <ReinH> CurryWurst: you should write sumBundle :: Bundle -> Float
12:27:26 <ReinH> or totalWeight, or whatever
12:27:32 <maerwald> Fuuzetsu: they say it in the notes though...
12:28:26 <ReinH> maerwald: can I see those slides? :)
12:30:36 <CurryWurst> ReinH: sumBundle (Box x xs) = x + foldl (+) 0 (map sumBundle xs)
12:30:50 <roelof> Everyone a good evening. It's time to sleep for me .Again everyone thanks for the help 
12:30:54 <maerwald> ReinH: I am not sure if I am permitted to share them publicly, but anything can happen if I get a mail address
12:31:42 <ReinH> maerwald: pm
12:39:40 <indiagreen> maerwald: can I look at them too?
12:39:43 <johnw> ReinH: in my pre-Haskell days, an introductory book "with a whole chapter on induction" would have been exactly why I wouldn't have read it :)
12:40:12 <ReinH> johnw: :p
12:40:27 <ReinH> It's pretty well motivated
12:40:35 <ReinH> And it turns out induction is kind of important
12:40:39 <johnw> yeah, I get that now
12:40:51 <johnw> but mindsets can be SO different from what you and are I now familiar with
12:41:59 <haskell655> what's isomorphism?
12:42:03 <indiagreen> maerwald: or rather, I obviously can't 'cause you're not allowed to share them and everything, but can I pm you my email address too for no reason at all?
12:42:12 <maerwald> indiagreen: :o
12:43:54 <quchen> haskell655: The answer to that depends on the knowledge you already have. In a nutshell, an isomorphism allows you to convert back and forth between things for free (without losing information).
12:44:29 <quchen> haskell655: For example, there is an isomorphism between `Maybe ()` and `Bool`.
12:44:53 <haskell655> soo Just a is True and Nothing is False
12:44:54 <haskell655> ?
12:45:06 <aawe> Just () is True
12:45:18 <quchen> haskell655: Yes, that is one way to do it. Just<->False and Nothing<->True would be another isomorphism.
12:45:42 <haskell655> soo two things (data types) have to have the same number of elements?
12:45:48 <quchen> haskell655: One other common isomorphism is between (a,(b,c)) and ((a,b),c).
12:45:49 <haskell655> are they data types(?)
12:46:03 <arkeet> if two types are isomorphic then they have the same number of values yes
12:46:33 <arkeet> (there is some difference between Bool and Maybe () if you don't ignore bottom though...)
12:46:59 <quchen> (a,b) is isomorphic to (b,a). [a] is isomorphic to `data List a = Either a (a, List a)`, and so on.
12:47:08 <quchen> arkeet: psssst
12:47:21 <arkeet> sup
12:47:33 <quchen> Woops,   data List a = Either () (a, List a)
12:47:42 <arkeet> aka Maybe (a, List a)
12:47:44 <arkeet> :t unfoldr
12:47:45 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
12:48:05 <arkeet> :t unfoldr (preview _Cons)
12:48:06 <lambdabot> Cons s s a a => s -> [a]
12:48:10 <arkeet> heh.
12:48:19 <quchen> I'm sure that is helpful :-s
12:48:50 <haskell655> so for isomorphism
12:49:03 <haskell655> if a is isomorphic to b, then b is isomorphic to a?
12:49:07 <quchen> Yes.
12:49:40 <quchen> Sometimes you say "isomorphism from A to B" to stress that you mean the one direction, but an isomorphism always comes with a reverse direction as well.
12:49:54 <arkeet> "A is isomorphic to B" just means you have functions A -> B and B -> A that are inverses of each other. and these functions are called isomorphisms.
12:50:04 <haskell655> so you can go from a to b and then do some stuff in b and then come back to A?
12:51:05 <quchen> haskell655: Exactly. That's a very common use case: you have an A which is isomorphic to B, and B offers a lot of useful functionality that you'd like to apply to A. You convert to B, do your thing, and convert back to A.
12:51:33 <haskell655> mmm. reminds me of fourier transforms
12:51:42 <lvh> That's not a bad analogy :)
12:52:24 <quchen> haskell655: Isomorphisms are a much more general mathematical concept. The Fourier operator (that maps a function to another function) and its inverse are parts of an isomorphism between two function spaces.
12:52:25 <arkeet> sure, fourier transforms (defined appropriately) are indeed isomorphisms.
12:53:09 <quchen> haskell655: In a sense, you can view isomorphisms as a generalization of having an inverse to a certain operation.
12:53:37 <haskell655> cool cool. thanks guys. this was helpful
12:53:43 <bennofs> not just an inverse, but an inverse in both directions. You need f . g = id and g . f = id
12:54:32 <quchen> haskell655: The handwavy explanation of "convert back and forth" might confuse bijections and isomorphisms though, so be a little careful here. Isomorphism is a stronger requirement than a bijection.
12:54:51 <haskell655> ah. bijection is next to learn
12:54:54 <quchen> (Namely that it "preserves structure", which I don't know how to explain handwavy.)
12:55:21 <haskell655> bijection is one directional?
12:56:13 <quchen> No, it's also both ways. But when f is just a bijection, f(x)*f(y) = f(x*y) is not required to hold.
12:56:13 <arkeet> quchen: the difference is kind of hard to explain when there is not much structure to preserve.
12:56:20 <arkeet> whatever * is.
12:56:28 <Fuuzetsu> https://www.fpcomplete.com/blog/2015/05/secure-package-distribution woo
12:56:30 <Fuuzetsu> Twey: ^
12:57:15 <haskell655> i see. isomorphism holds that expression?
12:57:19 <rasen> With presence of Template Haskell is it safe to compile untrusted source files?
12:57:26 <quchen> haskell655: Defining what an isomorphism is is technical, but for practical purposes "allows conversion back and forth" is usually enough. You don't need to read a book in order to make use of it.
12:57:28 <haskell655> f(x)*f(y) = f(x*y) where * is any operator?
12:57:41 <quchen> rasen: No. TH allows execution of arbitrary IO.
12:58:20 <frerich> quchen: Oops, really? that sounds like a nice attack vector.
12:58:23 <Fuuzetsu> quchen: well, isomorphisms in Set are bijections aren't they…
12:58:45 <rasen> Is it safe if there is only one untrusted source file?
12:58:57 <quchen> haskell655: f(x) ∘ f(y) = f(x ∘' y), where  ∘ is a binary operator between elements of the space f maps to, and  ∘' a binary operator between elements of the space f maps from.
12:59:09 <ajf>     cvElem <- newElem "canvas" `with` [
12:59:11 <ajf>         attr "width" := width,
12:59:13 <ajf>         attr "height" := height
12:59:15 <ajf>     ]   
12:59:17 <ajf> where's the syntax error?
12:59:32 <quchen> rasen: Long story short, if you compile an arbitrary module that does TH it can do whatever it likes.
12:59:32 <rasen> indentation?
12:59:41 <ajf> rasen: how should it be indented?
12:59:47 <Fuuzetsu> the closing ] is too far to the left
12:59:47 <quchen> ajf: Please don't post your code here directly, we have a nifty pastebin!
12:59:50 <quchen> ?where paste
12:59:51 <lambdabot> Haskell pastebin: http://lpaste.net/
13:00:11 <rasen> ajf: indent all lines except first one lever more
13:00:19 <rasen> level*
13:00:25 <quchen> rasen: The function in question is runIO, http://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH-Syntax.html#v:runIO
13:00:36 <ajf> rasen: that just shifts the syntax error to the last line
13:00:49 <ajf> oh
13:00:57 <ajf> I may have another syntax error in the same program
13:01:03 <ajf> That's probably it.
13:01:06 <ajf> Thanks.
13:01:12 <rasen> quchen: Thanks
13:01:13 <quchen> Which is why you should paste the full source :-)
13:01:21 <ajf> yep, I did
13:01:36 <ajf> quchen: well, the problem is fixed now ^^
13:02:00 <quchen> rasen: Safe Haskell gives you some advice on whether a module is safe or not. Modules marked as "Safe Haskell: None" can potentially do unexpected side effects.
13:02:14 <quchen> rasen: TH for example is considered not "Safe".
13:02:23 <quchen> unsafePerformIO is not safe.
13:02:43 <quchen> cf. https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/safe-haskell.html
13:02:44 <johnw> quchen: it is, in fact, unsafe.
13:02:59 <quchen> johnw: acme-notsafeperformio
13:03:49 <quchen> johnw: Actually, it should be notNecessarilySafePerformIO ;-)
13:04:11 <johnw> knownToBeUnsafeishUnderLaboratoryConditionsPerformIO
13:04:47 <jophish> yo yo yo
13:05:08 <phaazon> omg
13:05:17 <phaazon> I’m writing my own PPFRP framework for my 3D engine
13:05:24 <phaazon> in order to compare with AFRP
13:05:27 <jophish> What's the neatest way to determine if any element in a V3 (from Linear) is NaN?
13:05:34 <phaazon> my switch implementation is so ridiculous 
13:05:37 <Hijiri> PPFRP?
13:05:47 <Hijiri> pseudopico frp
13:05:57 <michaelt_> ppfrp, why not...
13:05:57 <Hijiri> pretty powerful frp
13:06:01 <jophish> I feel there might be a nice lens for this, but my lens foo isn't strong enough
13:06:08 <phaazon> http://lpaste.net/7507443868078440448
13:06:15 <phaazon> push-pull frp
13:06:34 <Hijiri> oh, thanks
13:06:43 <conal> phaazon: with a precise spec?
13:07:22 <jophish> at the moment I'm doing (not . isNaN . norm)
13:07:29 <jophish> this is pretty horrible, but it's the least typing
13:07:42 <indiagreen> jophish: anyOf each isNan
13:08:01 <quchen> jophish: Wouldn't that map 0 to NaN?
13:08:02 <phaazon> conal: what do you mean a precise spec?
13:08:20 <jophish> quchen: the norm of a 0 vector is 0
13:08:32 <indiagreen> jophish or you can use ‘noneOf’ if you want to validate the vector instead
13:08:41 <conal> phaazon: a clear way of saying what it is that you're implementing.
13:08:46 <quchen> jophish: Oh, I was thinking of the direction. …
13:08:49 <jophish> indiagreen: super! thanks!
13:08:55 <conal> phaazon: independent of the implementation itself.
13:08:56 <jophish> quchen: np :)
13:08:57 <wolftune> someone pointed me to http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml earlier. WARNING: this seems *very* outdated. Should not be recommended I think, bad to give outdated advice even if some of it stands
13:09:12 <phaazon> conal: well, I’ve been studying netwire and AFRP for a while
13:09:13 <conal> phaazon: for instance, FRP from the start had a simple, precise denotation.
13:09:21 <phaazon> and I found that very… hm, I don’t know, not that good
13:09:40 <phaazon> I read your paper about push pull FRP
13:10:06 <conal> phaazon: good. that paper includes a precise denotation, independent of the push-pull part, which is operational.
13:10:07 <phaazon> and I wanted to make my own implementation of PPFRP without sticking to the denotational concepts
13:10:18 <conal> phaazon: oh. then not really FRP.
13:10:30 <phaazon> well
13:10:34 <conal> more an exploration of implementation ideas.
13:10:39 <phaazon> yeah
13:10:43 <phaazon> exactly
13:10:47 <conal> a how without a what.
13:10:48 <wolftune> ReinH: it was you with a Google cabal of cabal thing… note that http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml seems quite outdated and no longer relevant in many ways
13:11:00 <phaazon> my Event type is a stream of event from IO, basically
13:11:11 <phaazon> I wanted to be more generic, but for my purpose, it’s fine so far
13:11:35 <conal> phaazon: okay. have fun. but calling it "FRP" will spread more confusion.
13:11:48 <bennofs> wolftune: I do not see so much wrong stuff there from a first glance
13:11:57 <bennofs> wolftune: might also want to read sicp
13:11:59 <bennofs> @where sicp
13:11:59 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
13:12:08 <conal> phaazon: and of course, you won't be able to show (or even state) that the implementation is correct.
13:12:10 <bennofs> This still *is* relavant
13:12:18 <wolftune> bennofs: it's stuff that mostly talks about problems that I definitely do not see with my configuration with current cabal versions
13:12:19 <conal> phaazon: (in a non-trivial sense)
13:12:36 <bennofs> wolftune: is profiling or documentation enabled by default now?
13:12:53 <wolftune> bennofs: no, but it's not marked as False either
13:13:05 <bennofs> wolftune: yes, but this means that it's disabled
13:13:07 <phaazon> conal: I don’t plan to be exhaustive or whatever 
13:13:08 <wolftune> bennofs: and the stuff about defaulting to Haskell 98 doesn't seem present
13:13:11 <phaazon> as I said earlier
13:13:21 <phaazon> I’m still quite a newcomer in FRP
13:13:44 <phaazon> I found netwire cool at first, I wrote an implementation as well using automatons
13:13:53 <wolftune> bennofs: I'm not saying it is all wrong, I'm saying that resources need to be kept up to date. It's not great to tell people to follow some advice when some portion is relevant and others is not and not obvious to know
13:14:03 <conal> phaazon: a shame, though. IO is exactly the part of Haskell that has no denotation, just like other imperative languages. we can do much better.
13:14:06 <phaazon> but I found it very blocky (I’m not really fond of arrow notation
13:14:07 <phaazon> )
13:14:15 <bennofs> wolftune: ah yes, probably not the best resource anymore
13:14:38 <wolftune> I think it's potentially harmful to send people to resources that are half-true
13:14:44 <phaazon> conal: I don’t pretend being as skilled as you, for sure
13:14:55 <phaazon> I’m just some guy trying to understand and learn things
13:15:04 <phaazon> I wrote an article about my netwire experience
13:15:10 <phaazon> for other folks to get they feet wet
13:15:25 <wolftune> so, just sayin… we should update the article or something or not recommend it
13:15:34 <conal> phaazon: i'm not talking about skill but rather intent. see, e.g., http://conal.net/blog/posts/is-haskell-a-purely-functional-language
13:15:53 <bennofs> wolftune: yes, I agree with that. It's just difficult to find really up-to-date cabal articles, since there have been a lot of changes fairly recently (all the sandboxing stuff and features toward a more nix-like packaging approach)
13:16:28 <wolftune> bennofs: yup, hard to keep up to date, I know. cabal freeze etc. and more
13:16:35 <phaazon> conal: I don,t get your point
13:16:43 <phaazon> I’m building an FRP library
13:16:55 <phaazon> I do that to add denotation to reacting to events
13:17:02 <phaazon> if I haven’t that intent
13:17:03 <wolftune> bennofs: thanks ciao
13:17:08 <phaazon> I’d go for callbacks everywhere
13:18:00 <conal> phaazon: with a denotational spec for guidance, you can reason rigorously and practically based on a simple math model. and you know exactly what it means for an implementation to be correct. and by omitting the complexity of a particular implementation style, the spec allows a vast range of possible implementation styles.
13:19:18 <conal> phaazon: without a spec, code is "not even wrong". which is par for imperative languages (including Haskell+IO) but unnecessary with a denotative language (e.g., Haskell without IO). see https://github.com/conal/talk-2014-bayhac-denotational-design 
13:20:20 <conal> phaazon: i'm not meaning to push this perspective on you. just wanted you to have the opportunity if you care.
13:21:38 <phaazon> I find it difficult to guess the tone of your sentences
13:21:50 <phaazon> thank you for pointing all that out though
13:22:37 <frerich> conal: Alas, http://conal.net/talks/bayhac-2014.pdf (linked to from that page you just mentioned) is a 404.
13:23:02 <conal> phaazon: i understand. if you knew me, you'd guess that it was a friendly offer.
13:23:14 <conal> frerich: oops! thanks a bunch. will fix now.
13:23:28 <phaazon> I’m watching the video
13:23:32 <phaazon> you look friendly indeed :)
13:24:12 <conal> phaazon: :)
13:24:20 <phaazon> I just think that you’re a very talented mathematician / programmer with hindsight
13:24:24 <conal> frerich: fixed. thanks again! (http://conal.net/talks/)
13:24:42 <phaazon> while I’m just a young one
13:25:14 <phaazon> I also have a strange feeling about FRP
13:25:23 <phaazon> that’s why I want to “try things”
13:25:32 <phaazon> but your offer is pretty interesting
13:25:43 <phaazon> I’ve never tried to “prove” everything
13:25:47 <phaazon> the math way
13:25:53 <phaazon> I’m not even sure that’s a good idea
13:25:58 <phaazon> for gettin things done.
13:27:03 <cite-reader> 90% of my job would be easier if the people who wrote this code so much as _stated_ what they were trying to do.
13:27:04 <conal> phaazon: without a spec, i don't know how we know *what* we got done.
13:27:04 <Hijiri> it's definitely easier in haskell than most mainstream languages
13:27:26 <conal> Hijiri: assuming one doesn't use IO.
13:27:41 <frerich> phaazon: You can indeed get a whole lot of stuff done without actually thinking too much; for very small values of 'done'.
13:27:53 <conal> since IO is for putting things that we don't understand.
13:28:06 <Hijiri> haskell is upper-bounded by other languages that don't separate out IO
13:28:13 <mauke> having a spec just means you can now have bugs in the spec, too
13:28:16 <frerich> phaazon: There's certainly a break-even point.
13:28:18 <favetelinguis1> Is there anyway ghci will autoreload changed files? This seems to be a standard feature in many repls but i cant find it in ghci?
13:28:27 <Hijiri> or lower-bounded, or something-bounded
13:29:13 <phaazon> frerich: well
13:29:23 <phaazon> try to prove every piece of code of a video game
13:29:29 <phaazon> see you in 50 years.
13:29:49 <johnw> phaazon: funny you should bring this up
13:29:59 <phaazon> why is so?
13:30:09 <quchen> Meanwhile, johnw fetches his Github Repo of formally verified Mario.
13:30:09 <johnw> phaazon: since part of my job is finding ways of making "prove everything" a good idea for getting things done
13:30:22 <frerich> quchen: :-)
13:30:31 <johnw> 50 years is too long, give it 20
13:30:51 <enthropy> is there some way to "\xs ys -> take (min (length xs) (length ys)) $ zip (cycle xs) (cycle ys)" with vectors?
13:30:59 * enthropy means Data.Vector
13:30:59 <johnw> some of the CPUs in your machines are using FP units proven by mathematical theorem provers
13:31:19 <quchen> phaazon: Also, you shouldn't confuse correctness with "has no unexpected behaviour".
13:31:26 <conal> mauke: of course, it's important that the spec be *simple* as well as precise. 
13:31:42 <bwiklund> johnw can you elaborate? that sounds interesting
13:31:50 <johnw> bwiklund: which, the FP units part?
13:31:53 <bwiklund> yeah
13:32:08 <phaazon> quchen: you can still have bugs without IO
13:32:15 <phaazon> pure code can introduce bugs
13:32:18 <phaazon> and nasty ones
13:32:23 <johnw> bwiklund: ACL2 has been used quite a bit by AMD, and I know that Intel has proven similar things using Coq
13:32:39 <johnw> bwiklund: if you enjoy light reading: http://www.russinoff.com/papers/paris.ps
13:32:43 <phaazon> don’t try to convince me, you’d waste your time as I’m already convinced
13:32:49 <phaazon> I use IO the less as possible
13:32:54 <phaazon> and keep everyting pure
13:32:58 <phaazon> but FRP is special to me
13:33:00 <bwiklund> thanks reading up
13:33:17 <quchen> phaazon: That's what I meant to say
13:33:29 <conal> phaazon: yes, pure code can be complex enough to invite bugs. but it needn't be. in contrast, IO has *no* known denotation and is very unlikely ever to have one, let alone one simple enough to reason about dependably.
13:33:46 <phaazon> sure conal 
13:34:09 <phaazon> however, after reading reactive-banana’s documentation and some implementation
13:34:17 <phaazon> what I’m doing is basically very alike
13:34:32 <johnw> unless we limit ourselves to subsets of IO, and model all mutated resources as vectors in memory or some such
13:34:48 <phaazon> and by the way
13:34:51 <phaazon> IO is not wrong
13:35:14 <phaazon> until the day we have functional computers, we have to deal with states, context and mutation
13:35:38 <phaazon> (I mean in memory, right)
13:35:47 <quchen> phaazon: A computer that copies itself on every bit flip?
13:35:59 <phaazon> I don’t even know, yeah
13:36:08 <phaazon> I heard something about memristors
13:36:18 <bwiklund> what would a functional computer even resemble
13:36:19 <quchen> phaazon: Do you know how Lisp machines work? Could be the right direction.
13:36:30 <quchen> phaazon: Sure it mutates state, but that's an implementation detail.
13:36:35 <phaazon> quchen: nope
13:36:42 <phaazon> well
13:36:51 <phaazon> how do you make an OpenGL render on a Lisp machine?
13:36:52 * quchen isn't even sure whether Haskell is garbage collected
13:36:54 <phaazon> how do you handle a GPU?
13:36:55 <phaazon> the disk?
13:37:28 <phaazon> I LOVE mathematics and all that stuff, but we also have to deal with the real world
13:37:37 <arkeet> quchen: surely it's possible in principle to have a haskell implementation without GC.
13:37:55 <johnw> phaazon: that's like saying you love thought, but it's not quite so important in a world of physical objects and sensation
13:38:01 <quchen> arkeet: Indeed, the Report doesn't mention GC, except when dealing with the FFI.
13:38:18 <phaazon> that’s why I’m very sceptic when people say IO is wrong
13:38:46 <quchen> IO is wrong?
13:38:55 <johnw> I believe that math is the right way to think about programs; better compilers will handle more and more of the desired semantics as time goes on
13:38:56 <phaazon> a pure code could break into smithereens if an exception occurs
13:39:23 <phaazon> what would all the cood math laws become when such situation occurs?
13:39:27 <phaazon> cool*
13:39:45 <quchen> I've never heard of IO being wrong. It's hard to reason about, it's arguably impure, but I wouldn't say it's in the "right or wrong" category.
13:39:52 <sydneyhacker> phaazon: or someone chucks your computer out the window 
13:40:02 <phaazon> sydneyhacker: that’s a very good other example
13:40:05 <zyla> phaazon: actually, some people already built a "functional" processor: http://www.cs.york.ac.uk/fp/reduceron/
13:40:06 <phaazon> thank you very much :D
13:40:13 <phaazon> oh cool!
13:40:19 <nschoe> Hi, Anybody with experience with postgresql-simple and dates? I am using UTCTime to store dates in my DB (which is timestamp with timezone). But I'm building a site for a French company, so the guys are going to type in dates in French format : DD/MM/YY. ut then I get this error: http://lpaste.net/132414
13:40:21 <zyla> On a FPGA, but still
13:40:27 <phaazon> oh yeah, the Reduceron
13:40:51 <nschoe> How can I make it compatible, and/or parse it to English format (I'd prefer that).
13:41:13 <johnw> I'm not sure anymore what the objective of this discussion is.  Are you trying to convince us that we should love Haskell less or something?
13:41:44 <Fuuzetsu> nschoe: didn't we all learn the harm of using 2 digits for year about 15 years ago? ;)
13:42:04 <johnw> Fuuzetsu: yeah, but we have 85 years until it's a problem again!
13:42:21 <quchen> johnw: Modulo "Windows 10", which taught us that one digit is also not enough
13:42:25 <nschoe> Fuuzetsu, yes, certainly ^^
13:42:26 <Fuuzetsu> I can hear all those veteran Haskell contractors rubbing their hands already
13:42:42 <sydneyhacker> global warming is a bigger threat than the date format
13:43:30 <johnw> I want a trading card game where I can play my shiny gold Conal card and trump all non-math discussions of design
13:43:44 <quchen> johnw: You've activated my trap Oleg
13:43:45 <nschoe> Fuuzetsu, besides, I've just tried, the 2-digit year is not the problem. The DD/MM rather than MM/DD is.
13:44:35 <Fuuzetsu> yes, I know
13:44:43 <sydneyhacker> 2 digit hex years - more than twice as good
13:44:44 <Fuuzetsu> and the ‘English’ format is DD/MM you know
13:45:11 <Fuuzetsu> only those silly Americans use MM/DD; anyway how you deal with it depends on your application
13:45:24 <conal> i'm not saying that we shouldn't use IO. rather that whenever we do, it's a failure to understand/specify (and hence reason about) with the clarity that we do in the rest of haskell (the "denotative" or "genuinely functional" parts, as Peter Landin called them).
13:45:27 <lpsmith> nschoe, postgresql-simple assumes ISO style date formats
13:45:27 <Fuuzetsu> or maybe you could change the DB setting like the error suggests
13:45:28 <geekosaur> quchen, actually windows 9 taught us that :p
13:45:29 <arkeet> ISO date format please.
13:45:41 <ion> MM-DD is the logical most-significant-part first order, but don’t you dare put the year after that. :-P
13:45:46 <conal> if we don't admit this failure, we won't improve matters.
13:45:54 <arkeet> ion: indeed.
13:46:07 <nschoe> Fuuzetsu, well all my other dates are in English, I'm more comfortable this way. I'd prefer convert the input.
13:46:08 <lpsmith> nschoe, my suggestion would be to handle the translation in Haskell
13:46:28 <Fuuzetsu> then do that; can't really answer your question without seeing what code you use
13:46:38 <Fuuzetsu> instead of taking the date directly, convert first or something…
13:46:38 <sydneyhacker> At least no one is talking about UTC
13:46:44 <nschoe> Fuuzetsu, so... maybe convert the "string" that I receive to the MM/DD format before inserting into DB? That sounds... nto very Haskelliosh ? ^^
13:47:17 <Fuuzetsu> IIRC you can specify which date format you want to parse when going to UTCTime
13:47:18 <lpsmith> no,  convert the MM/DD format into UTCTime or ZonedTime,  then insert into the database
13:47:24 <nschoe> lpsmith, "handle the translation in Haskell", yes that's what I'd liek too. But I'd like to avoid manipulating the string. It sounds not clever.
13:47:34 <johnw> conal: said another way, when we use IO we're consciously employing a family of types whose denotation is "anything can happen, and could result in this value"
13:47:35 <lpsmith> Fetch a UTC or ZonedTime from the db,  then format it into the MM/DD format
13:48:09 <nschoe> lpsmith, ho sorry I may have staes this incorrectly: the string comes from a HTML input.
13:48:33 <Fuuzetsu> http://hackage.haskell.org/package/time-1.5.0.1/docs/Data-Time-Format.html#t:ParseTime
13:48:48 <Fuuzetsu> stuff in that module in general, just look around
13:48:49 <conal> Peter Landin coined the term "denotative" to replace the ill-defined "functional". He informally used "genuinely functional" as well. See http://conal.net/blog/posts/is-haskell-a-purely-functional-language#comment-626 for an excerpt and pointers.
13:48:54 <lpsmith> nschoe, the time library already has printing and parsing functions that can deal with many common formats.
13:49:13 <Twey> enthropy: ‘\xs ys → take (min (length xs) (length ys)) $ zip (cycle xs) (cycle ys)’ — the cycle does nothing because you stop before you would cycle anyway, so \xs ys → take (min (length xs) (length ys)) $ zip xs ys.  But zip already stops when it reaches the end of the shorter list, so your function is simply \xs ys → zip xs ys, or just ‘zip’.
13:49:23 <johnw> It's not just that it isn't right, it's not even wrong. :)
13:49:32 <nschoe> lpsmith, I'll take a look into that, then. Thanks.
13:49:38 <Twey> Fuuzetsu: Yay, package signing \o/  Does this mean Nix can stop doing it?
13:49:39 <enthropy> Twey: sorry I had max in mind instead of min
13:49:43 <conal> johnw: i guess so. plus the proviso that we have no spec even about the scope of the "anything" that could happen.
13:49:43 <Fuuzetsu> Twey: no
13:50:06 <conal> johnw: just like Fortran programs.
13:50:15 <Twey> enthropy: Ah
13:50:52 <lpsmith> Although,  being slightly subversive,  I try to use ISO style everywhere I can:  on checks,  when displaying dates to my customers,  etc.
13:51:08 <lpsmith> I haven't gotten any comments about it either.
13:51:11 <Twey> lpsmith: +1
13:51:19 <Twey> lpsmith: People sometimes ask me to confirm.
13:51:22 <geekosaur> I would expect nix to sign its own packages anyway
13:51:50 <lpsmith> Well,  I always use YYYY-MM-DD to make it somewhat obvious
13:52:38 <enthropy> Twey: I'm looking for something like http://cran.r-project.org/doc/manuals/r-release/R-intro.html#index-Recycling-rule
13:52:40 <Fuuzetsu> official nix Hydra only started signing recently
13:52:53 <ion> lpsmith: ditto
13:52:57 <arkeet> I usually write the month as a word.
13:53:12 <Twey> lpsmith: Yes, but they ask anyway.
13:53:20 <lpsmith> nschoe, although I do use postgresql to handle timezone conversions,  because Haskell can't do a very good job with that at the moment.   Do you know how timestamptz really works?
13:54:35 <lpsmith> nschoe, https://github.com/lpsmith/postgresql-simple/issues/69
13:54:41 <Twey> enthropy: I've got nothing other than writing it yourself with unfoldr on the longer list
13:54:54 <peacememories> hm, is it a good idea to try and cross-compile haskell programs for windows instead of building on windows directly?
13:54:56 <nschoe> lpsmith, I don't know much about it, only the format it takes.
13:55:24 <peacememories> it's a real pain getting all dependencies (especially non-hackage, like sdl etc.) installed and properly configured
13:55:29 <Hijiri> peacememories: I have found cross-compiling difficult
13:55:53 <Hijiri> actually I haven't tried, but I have heard it's har
13:55:55 <Hijiri> hard
13:56:34 <lpsmith> nschoe, yeah, timestamptz is almost universally misunderstood,  and as a result a lot of people don't use it for the wrong reasons.
13:57:01 <nschoe> lpsmith, really? I mean... I thought it was the type that gave the most precision, so I use it.
13:57:38 <Twey> enthropy: f xs ys | m < n = f ys xs | otherwise = generate m $ \i → (xs ! i, ys ! mod i n) where (m, n) = (length xs, length ys)
13:58:17 <lpsmith> no, they give the same precision.   timestamptz is a 64-bit signed integer of microseconds offset from 2000-01-01 00:00:00+00,   timestamp is a 64-bit signed integer of microseconds offset from 2000-01-01 00:00:00
13:58:50 <lpsmith> (with minBound as a sentinal value for -infinity and maxBound as a sentinal value for +infinity)
13:59:30 <Hafydd> It pains my eyes to read that misspelling of "sentinel."
13:59:39 <nschoe> lpsmith, yes but in your link it wa stated "(Honestly, there is rarely any legitimate reason to use without time zone.)"
13:59:49 <nschoe> Holly H***, actually *you* said that, in the link ^^
14:00:17 <ion> Hask?
14:00:24 <Fuuzetsu> holy hask
14:00:27 <lpsmith> Right,  since timestamptz is offset from 2000-01-01 00:00:00+00,  it specifies an unambiguous point in time.
14:00:41 <enthropy> Twey: the actual vector zipWith ends up calling something like http://hackage.haskell.org/package/vector-0.10.12.3/docs/src/Data-Vector-Fusion-Stream-Monadic.html#zipWithM which seems to go out of its way to not call length
14:01:20 <enthropy> Data.Vector.Generic.length as opposed to size :: Stream m a -> Size
14:01:28 <lpsmith> the connection's timezone setting is then used to convert textual time formats into local time,  with an offset,  so it's really giving you both UTCTime and a ZonedTime.
14:01:41 <nschoe> ok
14:02:03 <lpsmith> however,  timestamp is offset from 2000-01-01 00:00:00,  which really can be any offset.
14:02:16 <Twey> enthropy: length is cheap on Vectors (O(1))
14:02:40 <nschoe> I'm trying to use parseTimeM to convert from DD/MM/YY(YY) to MM/DD/YY(YY)
14:02:44 <lpsmith> So it can only be understood in a larger context.   Admittedly, the larger context is _most often_ UTCTime,  by the way people use it,  but semantically that's not really the way it works.
14:03:48 <nschoe> Why? How do they (we?) use it, then?
14:03:55 * geekosaur is reminded of stupid date math tricks on systems without gnu date by abusing $TZ
14:04:26 <lpsmith> Well, in postgresql,  you can convert a timestamp (without time zone) into the time package's LocalTime
14:04:33 <lpsmith> it's semantically identical.
14:04:39 <Twey> enthropy: Stream is different, though — it can be infinitely long
14:04:50 <lpsmith> err, in postgresql-simple,  I mean
14:05:11 <nschoe> lpsmith, ho yeah but my French-formatted time doesn't come from SQL, it comes from user-input HTML form and I'm tryign to put it in sql
14:06:14 <lpsmith> nschoe, my suggestion is to use parseTime to convert your date into UTCTime,  ZonedTime, or LocalTime.
14:06:40 <nschoe> lpsmith, yep, I'm working on it as we speak!
14:07:09 <nschoe> It just seems I can *never* remember the correct signification of the '%X' characters in date formating/parsing ^^
14:07:12 <lpsmith> LocalTime has the advantage that you can use postgresql to convert the time into UTC time,   which Haskell can't do very well.
14:07:25 <lpsmith> lol, I always have to look at the docs myself
14:08:35 <lpsmith> Although,  using LocalTime also means that you have to have to set the timezone variable appropriately on the connection,  because LocalTime is formatted without an offset,  thus postgresql will use the IANA timezone database to compute the offset appropriately.
14:09:01 <nschoe> lpsmith, damn...I did not think dates were so... complicated.
14:09:37 <Fuuzetsu> didn't you know one of the fundamental rules of being a programmer?
14:09:43 <Fuuzetsu> don't do anything to do with timezones
14:09:49 <ronh-> what is the difference between ZonedTime and LocalTime?
14:09:52 <Fuuzetsu> or dates in general
14:10:03 <lpsmith> Yeah,  somebody really needs to write a solid IANA timezone conversion routines for Haskell.  I've thought about doing it myself,  but haven't really needed to do so yet.
14:10:21 <lpsmith> Especially as I've been reasonably able to just use postgresql for that so far.
14:10:27 <Hijiri> timezones
14:10:38 <lpsmith> Hijiri, not timezones.  Offsets.
14:10:42 <nschoe> Fuuzetsu, why don't qwe have simple timestamp: offset from Jan,1,1970?
14:10:46 <Hijiri> there is a fighting game I play with a debuggy reporter tool that records game scores
14:10:50 <nschoe> That would make everything much simpler, wouldn't it?
14:10:52 <Hijiri> but it records local time as if it was global time
14:11:01 <lpsmith> ronh-, ZonedTime is a (LocalTime, Offset) pair
14:11:06 <Fuuzetsu> nschoe: Jan,1,1970 of what timezone?
14:11:12 <lpsmith> so it's basically a localtime *and* a UTCTime. 
14:11:13 <Hijiri> And then the tool the reports these scores to servers does some conversion hack to account for this
14:11:21 <Hijiri> but it doesn't take account of daylight savings
14:11:25 <Fuuzetsu> yep
14:11:35 <Hijiri> because it assumes some stuff I forgot
14:11:37 <nschoe> Fuuzetsu, well I don't know, Universal Something?
14:12:10 <Fuuzetsu> sounds like unix timestamp
14:12:18 <lpsmith> The difference between timezones and offsets is that a timezone accounts for changing offsets over time,  due to daylight savings time,  the fact that an area moved from one standard time to another,  etc.
14:12:46 <nschoe> Fuuzetsu, that is what I had in mind. What's wrong with UNIX timestamp?
14:12:52 <lpsmith> a timezone is a function from UTC time to offsets,  and also local time to offsets.
14:13:24 <Fuuzetsu> nschoe: people don't input unix timestamps as dates
14:13:54 <Fuuzetsu> nschoe: if you were asking your users to input number of seconds (or whatever unit) since the one well established time period ago then it might be good enough for you
14:14:32 <nschoe> Obviously you're right.
14:14:48 <Fuuzetsu> nschoe: https://www.youtube.com/watch?v=-5wpm-gesOY :)
14:15:36 <ronh-> lpsmith got it, thanks
14:16:07 <nschoe> Fuuzetsu, ho neat! Thanks.
14:18:14 * hackagebot ghcjs-websockets 0.3.0.1 - GHCJS interface for the Javascript Websocket API  http://hackage.haskell.org/package/ghcjs-websockets-0.3.0.1 (jle)
14:18:42 <luzie> a unix timestamp in tai instead of utc would be perfect
14:20:06 <Kaligule> @run [1..]
14:20:07 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:20:37 <Denommus> uh
14:21:50 <lpsmith> luzie, hush now ;-)
14:22:11 <luzie> :-)
14:22:28 <lpsmith> but yeah,  there's almost always more to learn about time if you care,  and almost always a few more complications.
14:22:55 <nschoe> Ergh I managed to parse "30/08/2015" but I can't manage to parse "30/08/15". I tried with "%0Y" and "%0y" but it doesn't work. What am I missing?
14:23:01 <lpsmith> postgresql ignores leap seconds, btw.
14:23:56 <lpsmith> nschoe, I'm not sure that the time package can handle that kind of variance directly.   You probably just want to try parsing it with the other format if the first format fails.
14:24:21 <lpsmith> I ended up writing my own parsers and pretty-printers for postgresql-simple for reasons. 
14:24:36 <nschoe> lpsmith, ah okay. Thanks. Too bad it doesn't look pro.
14:24:40 <nschoe> But okay, I'll do that.
14:25:21 <lpsmith> nschoe, correct time handling code often doesn't look pro.  ;-)
14:25:46 <luzie> why do computers use utc internally instead of tai anyway?
14:25:53 <nschoe> lpsmith, it should
14:25:54 <nschoe> 1
14:26:49 <lpsmith> luzie, I'd guess because historically,  computer programmers didn't know nearly enough about time.
14:26:52 <lpsmith> And people want UTC
14:27:10 <Trollinator> what's tai?
14:27:29 <lpsmith> Trollinator, International Atomic Time,   basically UTC without leap seconds.
14:27:48 <luzie> and endless pain followed
14:28:11 <Trollinator> so it diverges from UTC over time?
14:28:16 <lpsmith> yup
14:28:38 <lpsmith> I think the offset was something like what, 14 or 8 seconds on Jan 1, 1970
14:28:46 <c_wraith> But unlike UTC, it doesn't have multiple different seconds with the same label!
14:29:07 <Trollinator> wtf, UTC has that??
14:29:10 <c_wraith> yep!
14:29:11 <lpsmith> c_wraith, UTC doesn't have multiple seconds with the same label
14:29:20 <lpsmith> It's just some minutes have 61 seconds :)
14:29:27 <c_wraith> err, POSIX time does
14:29:51 <lpsmith> yeah
14:30:06 <Trollinator> I thought that problem only exists for daylight saving times. 
14:30:37 <lpsmith> Trollinator, that's local time,  and not just for DST,  but also for when a region adopted a different time standard
14:30:38 <cite-reader> Wouldn't that be nice?
14:31:09 <lpsmith> e.g. indianapolis moved from Central Time to Eastern Time in the 1940s,  and now some people want to move most of Indiana back to Eastern.
14:31:14 <lpsmith> err, back to Central.
14:31:43 <Trollinator> just do it like the Chinese, use one time zone all over the country. 
14:32:02 <ion> I wouldn’t mind one time zone over the planet.
14:32:15 <lpsmith> Problem is, that will never work,  because some areas of the state want to be on the same time as Chicago,  some want to be on the same time as Detroit,  some want the same time as Cincinatti,  others want the same time as Louisville,  etc.
14:32:15 <Clint> swatch internet time
14:32:19 <c_wraith> I don't see why the planet can't have a single time zone.  It'd make things way simpler.
14:32:20 <glguy> ion: Isn't that what swatch did?
14:32:50 <ion> glguy: One that people would actually use. I.e. a fantasy.
14:33:04 <Trollinator> travellers wouldn't like it. 
14:33:33 <SrPx> Is concat from Data.List O(N) on the total number of elements?
14:33:47 <ion> SrPx: Of the first list
14:33:54 <Trollinator> I mean, it is handy to be able to tell at a glance what part of the day a given time refers to. 
14:34:06 <luzie> only ever using a a single time zone internally and translating in user interfaces seems ok
14:34:08 <SrPx> That doesn't look right ion 
14:34:24 <Trollinator> luzie: isn't that what's done already most of the time? 
14:34:41 <luzie> yes
14:34:43 <lpsmith> luzie, that's the only sane thing to do,  and that single time zone should be UTC
14:34:57 <lpsmith> Unfortunately,  Haskell doesn't have proper timezone conversions.
14:35:00 <ion> SrPx: Sorry, my bad. I was somehow thinking of (++).
14:35:01 <geekosaur> SrPx, why not?
14:35:07 <lpsmith> Somebody should fix that.
14:35:28 <geekosaur> hm, wait, concat. all but the last list
14:35:32 <c_wraith> concat is O(length of all the lists but the last one)
14:35:35 <Trollinator> port YodaTime? 
14:35:39 <Trollinator> Err, JodaTime
14:35:39 <SrPx> O(N) on the element of the first list? So "concat [[1], [1..100000000], [1..1000], [1..9999999999]] is instant?
14:35:58 <SrPx> ah, rait enough, thanks :)
14:35:58 <SrPx> fair*
14:35:58 <geekosaur> no, I made the same mistake ion did, was thinking (++)
14:35:59 <c_wraith> eh, it might as well be
14:36:03 <c_wraith> concat is also lazy
14:36:04 <SrPx> okay!
14:36:27 <SrPx> Just making sure it is not O(N^2), like foldr (++) [] would be.
14:36:27 <c_wraith> So it adds a tiny constant overhead for accessing all the elements of the result list except the ones from the last list.
14:36:54 <glguy> foldr (++) [] wouldn't be quadratic
14:37:05 <c_wraith> concat is foldr (++) []
14:37:14 <c_wraith> foldl (++) [] is the bad one
14:37:30 <Pamelloes> Is there a way to have a list of the type []::MyClass a, such that the list can contain any object that conforms to MyClass?
14:37:42 <c_wraith> Pamelloes: not usefully.
14:37:43 <SrPx> Ah, you are right. I see it now, my bad!
14:38:02 <Pamelloes> c_wraith: fair enough
14:38:14 <Trollinator> existential types?
14:38:14 * hackagebot process-streaming 0.7.2.1 - Streaming interface to system processes.  http://hackage.haskell.org/package/process-streaming-0.7.2.1 (DanielDiazCarrete)
14:38:23 <c_wraith> Trollinator: which isn't very useful in practice
14:38:33 <Pamelloes> What are existential types?
14:38:38 <geekosaur> you can do it with an existential type. the problem is that MyClass is the only thing you know about the elements
14:38:56 <Pamelloes> Well, that's basically all I need to know.
14:39:00 <geekosaur> which usually means you can't do anything useful with them
14:39:09 <arkeet> please read https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
14:39:13 <tdammers> you don't need existential types for that
14:39:14 <geekosaur> and in most of the cases where that is true, you can rely on laziness instead
14:39:20 <tdammers> see the link arkeet posted
14:39:25 <c_wraith> And if you can do something useful with them, you might as well just do that useful thing before putting them in the list
14:40:28 <SrPx> No, wait. That can't be right. For example, "concat (repeat 1000 (repeat 10 1))". After the 999th concating, it would have something like (repeat 9990 1) ++ (repeat 10 1). That alone would need 10000 operations, and it is just the last concat. So how can "concat" itself be O(N)?
14:40:55 <c_wraith> SrPx: you're associating backwards
14:40:55 <arkeet> N is the total size of the lists.
14:40:57 <glguy> SrPx: No, it would be the other way around
14:41:02 <arkeet> oh and then there's that.
14:41:18 <arkeet> concat is a right fold.
14:41:50 <SrPx> Yes, but even so. When you concat the last (first) list to the rest, you are concating a small list to a very big one...
14:41:59 <glguy> which takes small time
14:42:19 <SrPx> Wait, I know what to do
14:43:18 <glguy> concat (repeat 1000 (repeat 10 1)) ==> concat (repeat 10 1 : repeat 999 (repeat 10 1)) ==> repeat 10 1 ++ concat (repeat 999 (repeat 10 1))
14:43:39 <Pamelloes> arkeet: Thanks, that was exactly what I was looking for.
14:48:15 * hackagebot persistent 2.1.4 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.1.4 (GregWeber)
14:48:37 <osa1_> does anyone know the latest version of cabal that I can use with ghc 7.8.4?
14:49:20 <kadoban> Isn't there a log_base_2 that works on Int or Integer somewhere?
14:51:25 <arw>    
14:52:30 <c_wraith> kadoban: isn't that basically the same as "what's the highest set bit"?
14:52:58 <kadoban> c_wraith: Yeah. That doesn't seem to be in anywhere I can find either.
14:53:16 <arkeet> :t countLeadingZeros
14:53:17 <lambdabot> FiniteBits b => b -> Int
14:53:36 <arkeet> see the doc for an implementation of logBase2 based on this
14:54:10 <arkeet> needs ghc 7.10
14:54:10 <kadoban> I guess that works for Int. That's fine for my use I guess. It's weird that there isn't one that works on Integer, isn't it though? It's … so easy to implement, seems like it'd exist somewhere.
14:54:30 <kadoban> Does it really? :-/
14:55:22 <Darwin226> Is there any way to get something like `[d| newtype $(mkName "SomeName") = SomeCons |]` to work in TH?
14:55:55 <Darwin226> It gives me the "Malformed head of type or class declaration: $(mkName "SomeName")" error
14:56:24 <c_wraith> oh, right..  Can't splice into data type names.  That is annoying.
14:56:42 <c_wraith> Darwin226: you can construct it out of TH data types by hand..  You just don't get the quote syntax
14:57:23 <Darwin226> c_wraith: Damn. Getting the quote syntax was just the thing I wanted :/
14:58:09 <c_wraith> Darwin226: yeah, splicing into that part of syntax isn't supported
14:58:24 <Darwin226> c_wraith: Ok. Thanks
14:58:25 <c_wraith> Sadly
15:00:54 <quxbam> why does the following rule don't work:
15:00:58 <quxbam> {-# RULES "nub/set" forall (a :: (Ord b) => [b]). nub a = S.toList (S.fromList a) #-}
15:01:53 <quxbam> if i use (a :: [Int]), it fires for nub [Int], but i want it to fire for all types which are instances of ord (and eq)
15:02:26 <c_wraith> quxbam: if you use it in a place where you don't have an Ord instance explicitly in scope, it won't search for one.
15:03:22 <quxbam> c_wraith: is it not possible to generalize it?
15:04:08 <kadoban> Out of curiosity, what does it mean for an instance to be explicitly in scope?
15:04:38 <johnw> the presence of an Ord a constraint in the type of the entity within whose scope youo are
15:04:52 <c_wraith> quxbam: it's more a matter of what's left after desugaring.  rewrite rules only run after desugaring, and all type inference is done before desugaring.
15:05:42 <quxbam> ahh, ok
15:05:43 <c_wraith> quxbam: and type classes are removed during type checking - replaced with either the values if the type is known, or with dictionary passing if the type isn't known.
15:05:53 <arkeet> does it not work if you just do forall (a :: [b])?
15:06:29 <quxbam> arkeet: no, the compiler complains that it can't deduce Ord a from Eq a
15:06:44 <arkeet> oh of course.
15:07:16 <quxbam> another question, how can i fire rewrite rules after desugering arrow syntax?
15:07:37 <quxbam> e.g. {-# RULES "kaboom" first = secont #-}
15:07:44 <quxbam> s/t/d
15:08:04 <c_wraith> well, that particular rule won't ever fire, because first and second don't have the same type. :)
15:08:43 <quxbam> it could be, that they've the same type
15:08:51 <c_wraith> I guess they could have the same type occasionally
15:09:57 <quxbam> but even when they've got the same type, it doesn't fire... any clues?
15:10:06 <c_wraith> yeah, first is a class function
15:10:31 <quxbam> whats a class function?
15:10:37 <c_wraith> @src Arrow
15:10:37 <lambdabot> class Arrow a where
15:10:37 <lambdabot>     arr, pure :: (b -> c) -> a b c
15:10:37 <lambdabot>     (>>>)     :: a b c -> a c d -> a b d
15:10:37 <lambdabot>     first     :: a b c -> a (b,d) (c,d)
15:10:37 <lambdabot>     second    :: a b c -> a (d,b) (d,c)
15:10:39 <lambdabot>     (***)     :: a b c -> a b' c' -> a (b,b') (c,c')
15:10:41 <lambdabot>     (&&&)     :: a b c -> a b c'  -> a b (c,c')
15:10:57 <fotanus> if I have data Person = Person { name::String, Age::Int } and type People = [Person] 
15:11:05 <c_wraith> If the Arrow type is known at compile time, the definition of first will probably be inlined at compile time
15:11:14 <fotanus> how can I lookup a person in People by the name?
15:11:22 <arkeet> :t find
15:11:23 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
15:11:37 <fotanus> if I had a simple [(string, int)] I could use the lookup function
15:11:38 <quxbam> so i would need a no inline pragma, hmm
15:11:45 <c_wraith> and if it's inlined, it won't ever match.
15:11:45 <arkeet> find :: (Person -> Bool) -> [Person] -> Maybe Person
15:11:53 <quxbam> but at the other hand, if i desugar myself, it gets fired
15:12:01 <fotanus> Thanks!
15:12:16 <arkeet> np 
15:14:44 <Falkyouall> how to bring this alive guys? 
15:14:44 <quxbam> c_wraith: anyway, thanks
15:14:52 <Falkyouall> data List a = Leer | Element a (List a) deriving Show
15:14:52 <Falkyouall> myLength Element (x:xs)  (List (y:ys)) = [x]:xs:(myLength Element([y]:ys) (List (Leer)))
15:14:58 <c_wraith> quxbam: Good luck sorting it out
15:15:39 <Fuuzetsu> Falkyouall: uh, what are you trying to do?
15:15:45 <Falkyouall> im kinda since 2 days ago on my quest i know im close... but... argh
15:16:11 <quxbam> oh, a last one, why does ghc complain about "orphan rule"? google didn't help
15:16:12 <Falkyouall> i try to merge a list rekursively with typesecurity
15:16:57 <c_wraith> quxbam: It's a warning that you're introducing potential problems by defining an instance for a data type in a different module than either the data declaration or the class declaration
15:17:13 <Hijiri> is orphan rule different from orphan instance
15:17:23 <Fuuzetsu> Falkyouall: what is the type of myLength that you aim to implement? Why is it call myLength if you're talking about a merge?
15:17:29 <c_wraith> Hijiri: no, the orphan rule is just how it's decided whether an instance is orphan or not
15:17:30 <Falkyouall> not merging but chaining together two or more lists
15:17:31 <Fuuzetsu> Why is it called*
15:17:32 <Hijiri> ok
15:17:48 <Falkyouall> sorry mylength is just a random name 
15:17:59 <Fuuzetsu> what is the type?
15:18:36 <quxbam> c_wraith: ok, can i say him in the source code that it doesn't need a warning?
15:18:38 <frerich> Falkyouall: '[x]:xs' cannot typecheck given that they are coming from '(x:xs)'; 'x' is a simple element and 'xs' is a list of elements.
15:18:40 <Falkyouall> not clear at this point, its all about gerneric that just one type of lists can be merged
15:19:01 <quxbam> i want to write a library, which provides rewrite rules to optimize common bottlenecks in well known functions
15:19:04 <quxbam> like nub
15:19:08 <Fuuzetsu> Falkyouall: write down the type first; the implementation you wrote is impossible because of what frerich pointed out
15:19:26 <arkeet> frerich: but [x]:xs:somethingelse can typecheck :-)
15:19:42 <Falkyouall> hmmmm
15:19:48 <c_wraith> quxbam: you can add a pragma something like {-# OPTIONS_GHC -fno-warn-orphans #-} to the top of the file
15:20:12 <c_wraith> quxbam: oh, and yeah, the GHC documentation says that rewrite rules can also be orphans.  That'd be what you're running into.
15:20:20 <frerich> arkeet: Err oops, for some reason I read that second colon as a semicolon
15:20:35 <quxbam> thank you very much!
15:21:09 <Falkyouall> ups i forgott a part
15:21:17 <Falkyouall> data List a = Leer | Element a (List a) deriving Show
15:21:17 <Falkyouall> myLength :: List a -> List a -> List a
15:21:17 <Falkyouall> myLength Element (x:xs)  (List (y:ys)) = [x]:xs:(myLength Element([y]:ys) (List (Leer)))
15:21:27 <Falkyouall> this is the code
15:21:42 <Fuuzetsu> your type signature doesn't match your patterns at all
15:21:43 <Falkyouall> isnt it done with line two?
15:21:47 <Falkyouall> :D
15:22:15 <Fuuzetsu> you have ‘List a’ but try to match as if it was ‘List [a]’, this suggests you are very confused about something.
15:22:18 <Fuuzetsu> What are you learning from?
15:22:22 <athan> Is there a way to _add_ a package to stackage?
15:22:34 <Fuuzetsu> athan: yes, you send a pull request to stackage repo that adds it
15:22:43 <athan> Thank you Fuuzetsu
15:22:50 <Falkyouall> learing from learnyouhaskell, but yes im still confused and a bloody beginner
15:23:17 <Fuuzetsu> Falkyouall: well, first of all you're defining your own list, you should have absolutely no [] or : of any kind in your function
15:23:47 <Fuuzetsu> I mean there's just a lot wrong with that function
15:23:49 <Falkyouall> got it
15:24:04 <Fuuzetsu> you should just delete it and try again
15:24:08 <Fuuzetsu> start with the type signature
15:24:13 <Fuuzetsu> and myLength x y = undefined
15:24:27 <Fuuzetsu> then go from there, making small changes, pattern matching first on x then on y and so on
15:24:30 <Falkyouall> i will 
15:24:34 <Falkyouall> thanks
15:25:04 <Falkyouall> but myLength :: List a -> List a -> List a was right?
15:25:25 <Fuuzetsu> if you're trying to concatenate two lists, sure
15:25:29 <Fuuzetsu> :t (++)
15:25:30 <lambdabot> [a] -> [a] -> [a]
15:26:41 <Darwin226> I have a TH function that derives some instances for some type. Now I want to make another function that, given a string, generates the type declaration and then calls the other function to derive the instances. I can't seem to do that because I get the "'MyType' not in scope at a reify"
15:26:49 <Darwin226> What can I do?
15:27:46 <Fuuzetsu> not an answer but did you consider GHC generics?
15:28:16 <Darwin226> Fuuzetsu: I did, but I opted for TH because I didn't really understand how to do what I want with generics
15:28:34 <Darwin226> Single letter cryptic names didn't really help the whole process
15:28:58 <Fuuzetsu> they aren't cryptic if you read the wiki page and/or linked paper
15:29:09 <ronh-> Falkyouall that signature doesnt look right for a length function
15:29:35 <Darwin226> Fuuzetsu: I didn't have to read a paper to understand how to operate TH, and from what I can tell generics are supposed to be simpler to implement.
15:29:41 <Falkyouall> its for concatenating two lists
15:29:43 <Fuuzetsu> ronh-: he's not writing a length function, confusingly enough
15:29:51 <Darwin226> This is my function btw: http://lpaste.net/132422
15:30:04 <Falkyouall> hahahah i know i know - i got it
15:30:25 <orion> I have created a couple data types which extend Exception from Control.Exception, but my exception handler doesn'
15:30:51 <orion> t seem to want to compile when its type signature is SomeException -> Result
15:31:39 <Fuuzetsu> orion: what's the error?
15:32:08 <orion> Couldn't match expected type ‘SomeException’ with actual type ‘RequestException’
15:32:32 <orion> data RequestException = ... deriving (Show, Typeable)
15:32:42 <orion> instance Exception RequestException
15:33:14 <juanpablo_> why doesn't ((->) r) have an instance of Contravariant? Does it make sense? Intuitively, something like "fmap = flip (.)" sounds good to me.
15:33:18 <juanpablo_> Does it make sense?
15:33:26 <orion> Should the type of my exception handler instead be (Exception e) => e -> Result ?
15:34:03 <Fuuzetsu> orion: you need to wrap your exception in SomeException
15:34:25 <Fuuzetsu> or use toException
15:34:53 <enthropy> Darwin226: if you didn't write deriveShared / can't change it, you might call it with another newtype and change the names in the generated code
15:35:14 <orion> Fuuzetsu: I do this on the throw?
15:35:18 <Darwin226> enthropy: I did write deriveShared. What's my other option?
15:35:47 <orion> Fuuzetsu: e.g. throw $ toException ValueConstructorFromRequestException ?
15:35:49 <enthropy> change deriveShared so that it doesn't need reify
15:35:54 <Fuuzetsu> you do it whenever you try to use your own exception with the handler
15:36:08 <Fuuzetsu> no, throw will do that already
15:36:33 <Fuuzetsu> if you want a more precise answer you'll need to post more code
15:36:52 <Darwin226> enthropy: Hmmm, I see. Unfortunately I do use it for other non-autogenerated types that I need information about. So I'm gonna need a specialized variant for this case it seems. Ok thanks
15:37:18 <Falkyouall> myLength (Element x y) = (Element x):(myLength (Element y (Leer)))  
15:37:28 <Falkyouall> sorry the name...is not the issue
15:37:36 <Falkyouall> :)
15:37:48 <Fuuzetsu> Falkyouall: your issue again is that you took to large steps
15:38:05 <Fuuzetsu> before you even write anything on right hand side of =, your left hand side is wrong
15:38:15 <Falkyouall> hmmmmm
15:38:32 <Fuuzetsu> as I said before, pattern match on x and y in small steps and typecheck each time you make a change
15:38:47 <Fuuzetsu> don't just type random stuff in and say it doesn't work in the end…
15:39:00 <indiagreen> juanpablo_: ((->) r) is a Functor, not Contravariant – an instance of contramap for ((->) r) would have to have the type of “(a -> b) -> (r -> b) -> r -> a”, which is impossible
15:39:09 <Fuuzetsu> and I think I already told you that you shouldn't have [] or : anywhere in your function
15:39:46 <Falkyouall> thanks again i will
15:39:59 <Falkyouall> btw i wont do it the next time
15:40:18 <Fuuzetsu> Falkyouall: before you even do anything on right hand side of =, figure out your pattern matches
15:40:30 <indiagreen> juanpablo_: (-> r) is Contravariant, but you can't write an instance for this in Haskell
15:40:30 <Fuuzetsu> just put ‘undefined :: List a’ on the right of =
15:41:12 <juanpablo_> indiagreen: oh thanks. I think I'm misunderstanding contravariant functors then. My intuition says that an instance for contravariant for ((->) r) would first apply a function to the input of the function. Like compose the function backwards with another function
15:41:12 <indiagreen> juanpablo_: or rather, you can if you wrap (->) in a newtype with flipped type parameters, and that's exactly what Op is: http://hackage.haskell.org/package/contravariant/docs/Data-Functor-Contravariant.html#v:Op
15:41:47 <juanpablo_> indiagreen: oh so Op is the instance I'm looking for?
15:42:01 <juanpablo_> I need to do some repl'ing to build up my intution
15:42:06 <indiagreen> juanpablo_: the thing about contravariance isn't applying it to the 1st or last parameter, it's that the function is reversed
15:42:18 <orion> Fuuzetsu: I don't think I quite understand what you mean when you say "you need to wrap your exception in SomeException". Here is my code: http://lpaste.net/124435570616172544
15:42:42 <indiagreen> juanpablo_: you are given “f :: a -> b” and you have *b* and you have to turn it into a
15:43:01 <indiagreen> if you can do it for a type variable, it means that it's in a contravariant position
15:43:01 <Fuuzetsu> orion: responseLBS is what?
15:43:02 <juanpablo_> Yeah, most functions are not invertible so it sound fair enough
15:43:31 <Fuuzetsu> orion: anyway let's ignore that, the type on exceptionStatus is just wrong
15:43:45 <Fuuzetsu> orion: you same you take SomeException but pattern match on RequestException
15:43:55 <Fuuzetsu> not sure how you expect it to work :)
15:44:01 <Fuuzetsu> you say you take*
15:44:20 <indiagreen> juanpablo_: Const is contravariant, for instance, because you can always get “Const x anything” and so you don't even need f to go from “Const x b” to “Const x a”
15:44:56 <orion> Fuuzetsu: I wrote it at 4 in the morning.
15:44:58 <Fuuzetsu> orion: to me it looks like you should change both exceptionHandler and exceptionStatus to take RequestException, not SomeException
15:44:59 <Hijiri> I was about to ask if the set of invertible functions is smaller than noninvertible functions, but that wouldn't work
15:45:08 <Fuuzetsu> orion: best time to write code
15:45:09 <Hijiri> is this what classes are for
15:45:17 <Hijiri> (I don't know much about classes)
15:45:30 <orion> Fuuzetsu: Ah, but what about when I want to handle both a RequestException and a ResponseException?
15:45:55 <Fuuzetsu> Either RequestException ResponseException ?
15:45:56 <Hijiri> I don't even remember what classes are classes of, classes of sets?
15:46:36 <orion> Fuuzetsu: But what if I also want to handle ten more types of exceptions which don't exist yet? :)
15:47:03 <Fuuzetsu> orion: you have a sum type which carries those
15:47:13 <Fuuzetsu> orion: I mean you can't exactly pattern match on stuff which doesn't exist yet either…
15:47:33 <orion> Fuuzetsu: I can't use underscore?
15:49:23 <TheKing> @dijnn a -> a
15:49:23 <lambdabot> f a = a
15:50:01 <goldwarior> hi
15:50:08 <Fuuzetsu> orion: you can but I feel like we're moving away from the initial goal… You have some exceptions and you want to handle them and you know what they arae at that point of time so you can enumerate them…
15:50:36 <TheKing> @pl \t -> a $ flip b t
15:50:36 <lambdabot> a . flip b
15:51:40 <vandenoever> suppose that i've two string inputs in a program, the inputs are equal, how can i make sure that they take up only one memory position?
15:52:28 <Fuuzetsu> vandenoever: if they are equal then why do you have two inputs? I don't understand the question.
15:52:40 <indiagreen> vandenoever: “share :: Eq a => a -> a -> Maybe a; share a b = if a == b then Just a else Nothing”
15:52:52 <vandenoever> Fuuzetsu: they are not always equal
15:53:26 <indiagreen> no, wait, a better one: “share :: Eq a => a -> a -> (a, a); share a b = if a == b then (a, a) else (a, b)”
15:53:36 <Fuuzetsu> I was just about to suggest the pair solution
15:53:51 <Fuuzetsu> I don't know if this is something you'd commonly worry about
15:54:01 <indiagreen> now you just write “let (x', y') = share x y” and don't use x and y from now on and they'll get garbage collected
15:54:35 <Fuuzetsu> then you do something with x' and y' and you might end up with two strings again ;)
15:54:52 <vandenoever> in a dom impl the qnames recur a lot, making sure, on parsing, they all point to the same value would speed up the impl and reduce mem usage
15:55:25 <Fuuzetsu> ah
15:55:36 <Fuuzetsu> well what indiagreen showed might work, I'd be interested to hear your results
15:55:44 <vandenoever> in a lang like e.g. c++ i'd use a pointer, that way i can be sure the value was already deduped
15:56:21 <vandenoever> in haskell, i would not know when to call the share function
15:56:43 <vandenoever> obviously looking up in a map of already loaded values is a cost
15:57:09 <Fuuzetsu> do you have the parser written already?
15:57:14 <Fuuzetsu> don't prematurely optimise
15:57:18 <vandenoever> i guess what i'm wondering if haskell automatically does dedup when Eq is invoked
15:57:45 <vandenoever> would be a cheap and logical optimization
15:57:47 <indiagreen> it doesn't
15:57:53 <Fuuzetsu> Eq is not a primitive
15:57:56 <Fuuzetsu> @src Eq
15:57:56 <lambdabot> class Eq a where
15:57:56 <lambdabot>     (==), (/=) :: a -> a -> Bool
15:58:07 <indiagreen> it would also be a wrong optimisation because if values are ==, it doesn't mean they are actually the same
15:58:39 <Fuuzetsu> you can check pointer equalities but that's nasty stuff and you shouldn't really be doing that
15:58:43 <vandenoever> true, is there no 'really bitwise equal' comparator?
15:59:37 <Fuuzetsu> there's reallyUnsafePtrEquality or something
15:59:50 <vandenoever> Fuuzetsu: i'm just brainstorming about advantages/disadvantages of different languages for a dom impl that maps efficiently to a js runtime
16:00:05 <vandenoever> Fuuzetsu: hehe, sounds ominous
16:00:13 <Fuuzetsu> vandenoever: well, I think in practice you'll find that GHC is pretty damn good at optimisation on its own
16:00:23 <Fuuzetsu> and you can help it quite a bit too after you wrote the program
16:00:42 <Fuuzetsu> but whether something happens or not and whether it helps is up to how you optimise and and benchmark it
16:01:04 <vandenoever> Fuuzetsu: yeah, i read about some amazing optimizations in RLH and on yesod blog
16:02:33 <vandenoever> but i dont see how haskell could optimize away duplicate strings that result from xml parsing
16:03:30 <Fuuzetsu> You might have to help it but as I say, whether it actually works and speeds up your program/reduces memory footprint has to be measured
16:03:40 <vandenoever> but it is indeed an optimization
16:04:08 <vandenoever> damn, why is haskell so attractive :-)
16:04:45 <Fuuzetsu> vandenoever: it may generating what indiagreen posted except with pointer equalities itself during compile time for all we know right now :)
16:04:59 <vandenoever> ah, here's a big downside: if i add a map to dedup strings, i do not know when the lifetime ends
16:05:34 <Fuuzetsu> it ends when GHC RTS decides it ends
16:05:55 <vandenoever> RTS? run time s... ?
16:06:08 <Fuuzetsu> runtime system
16:06:38 <paulrd> Is there a ByteString version of the RWH example ch04/SplitLines.hs that can handle "\r\n", "\n" and "\r"?  Thank you in advance for any replies.
16:06:42 <Fuuzetsu> anyway if you want to try this out, you could probably whip up a small program pretty easily
16:06:57 <Fuuzetsu> then dump out core and C-- and have a read, compare your dedup and the share, see what happens
16:07:22 <Fuuzetsu> paulrd: can you post a link?
16:07:34 <vandenoever> Fuuzetsu: true
16:07:38 <Fuuzetsu> paulrd: https://github.com/cyga/real-world-haskell/blob/master/ch04/SplitLines.hs ?
16:08:12 <paulrd> Fuuzetsu: yes, that's it - it works on String.
16:08:16 <Fuuzetsu> paulrd: http://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString-Char8.html#g:14
16:08:38 <Fuuzetsu> but I believe it only looks for '\n' and ignores '\r'
16:08:41 <paulrd> was wondering whether there was a ByteString version on Hackage somewhere ...
16:08:55 <indiagreen> vandenoever: the trouble with having a map is that it might end up to not be an optimisation if you spend a lot of time doing lookups. On the other hand, if you just do sharing whenever you compare 2 elements and they turn out to be equal, you would lose some sharing
16:09:19 <ChristianS> Fuuzetsu: there should be no '\r' in (byte)strings read in text mode, methinks
16:09:50 <Fuuzetsu> there should be no ByteStrings treated as text ;P
16:10:18 <ChristianS> Fuuzetsu: weeeel, if you use Char8...
16:10:31 <Fuuzetsu> ChristianS: then you're doing the morally wrong thing, damn you!
16:10:45 <vandenoever> indiagreen: indeed, i've dom design (js and c++ atm) that has the map with a ref count
16:10:58 <ChristianS> Fuuzetsu: indeed, but didn't you suggest it?
16:11:05 <vandenoever> in haskell i guess it would be some StringDedupMonad :-P
16:11:24 <Fuuzetsu> ChristianS: I did not suggest it, merely pointed out its existence
16:12:01 <ChristianS> Fuuzetsu: ok. incidentally Char8.lines should indeed work for latin1, utf-8, and various other charsets (especially not for utf-16 etc.)
16:12:22 <Fuuzetsu> right
16:12:30 <Fuuzetsu> if you want to do things on text, you should use a text package
16:12:55 <paulrd> I'm reading a file into a lazy ByteString in binary mode.  There is a short text header that determines whether the rest of the file is binary or text.
16:13:31 <ChristianS> Fuuzetsu: i agree, decoding text to Text first is usually the right thing
16:14:08 <SrPx> Hello. I'm using the following code to access a value that is inside a list that is inside a map that is inside an object. `getValue object = object ^?! at (object^.activeName) ^?! ix (object^.activeFrame)`. My question is: how can I turn it into a simple lens? `myValueLens = ...` ? So that I can say: "getObject = view myValueLens"
16:14:11 <Fuuzetsu> paulrd: you could happily decode it to Text (or String or whatever) and do your split
16:14:14 <Fuuzetsu> http://hackage.haskell.org/package/text-1.2.0.4/docs/Data-Text-Encoding.html#v:decodeUtf8
16:14:26 <Eduard_Munteanu> paulrd, arguably ByteString should always be binary. If you need to handle encodings, including "text mode", use Text.
16:14:26 <SrPx> (disregard that, moving to #haskell-lens ... I always forgot that channel)
16:14:43 <osa1_> cabal build is failing with ld error(not a FFI related thing), does anyone remember is this happening? I remember having this error before but I don't remember the solution.
16:15:01 <Fuuzetsu> osa1_: list your modules in the cabal file
16:15:31 <rui> Why is xmonad project dead? They considered it finished or it got dropped?
16:15:46 <paulrd> The text portion of the file is ascii - just want to handle newlines portably ...
16:15:48 <Fuuzetsu> rui: huh?? why do you call it dead?
16:15:49 <Denommus> there should be a waylandmonad
16:15:49 <vandenoever> so what's somewhat mindboggling to me is that haskell doesnt use references, it just uses values
16:16:03 <Fuuzetsu> rui: they are even baking up a release nowadays
16:16:07 <osa1_> right...
16:16:23 <Fuuzetsu> Denommus: there's a person you should speak to about that
16:16:30 <Fuuzetsu> let me check
16:16:39 <peddie> Denommus: I think there was a GSoC proposal about that
16:16:51 <Denommus> vandenoever: yeah, ML had explicit refcells, and Haskell is an indirect descendant
16:16:55 <paulrd> ... that is, would like a portable version of http://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString-Char8.html#g:14
16:16:59 <rui> Fuuzetsu: Really? Great. I thought it was deade because I just cloned the github repo and only found commits from 2012 and before
16:17:00 <Eduard_Munteanu> XMonad seems pretty deeply-tied to X.
16:17:11 <rui> Again, it might mean I don't move around well in the open source world
16:17:13 <indiagreen> vandenoever: I think what you need is “interned strings”
16:17:19 <indiagreen> @hackage intern
16:17:19 <lambdabot> http://hackage.haskell.org/package/intern
16:17:21 <Fuuzetsu> Denommus: IIRC this person https://hackage.haskell.org/user/AukeBooij was interested in doing something like waylandmonad
16:17:22 <ChristianS> paulrd: if its ascii, you can use Char8 without worries
16:17:32 <Denommus> vandenoever: but since everything is immutable, there isn't a need for refcells
16:17:43 <Denommus> vandenoever: at least, not exposed to the user
16:17:46 <indiagreen> well, or
16:17:50 <indiagreen> @hackage symbol
16:17:50 <lambdabot> http://hackage.haskell.org/package/symbol
16:17:53 <Denommus> Fuuzetsu: hm, "hayland". Cool
16:18:14 <Denommus> I'm very busy with NetwireOCaml, but I may contact him once I'm finished
16:18:36 <Denommus> it would be interesting if the window manager was based on FRP :-D
16:19:00 <luzie> rui: there is no official github repo, that's an old unmaintained fork
16:19:07 <rui> luzie: That explains
16:19:15 <paulrd> ChristianS: yes, I'm happy with Char8.  I would like to handle "\r\n", "\n", and "\n" though.
16:19:23 <Eduard_Munteanu> FRP is a great way to increase the bus factor of a project, I suppose.
16:19:29 <Fuuzetsu> indiagreen: I see intern is one of those Ed packages with 0 docs to them ;P
16:19:30 <rui> I was also caught by wiki stating the last stable release was 2 years 5 months ago
16:19:39 <peddie> Denommus: Fuuzetsu: https://mail.haskell.org/pipermail/xmonad/2015-April/014694.html
16:19:50 <vandenoever> Denommus: yep, which probably has led to some experimentation in the past with caching function calls or doing deduplication as optimizations
16:19:53 <indiagreen> Fuuzetsu: oh yes
16:19:54 <peddie> that's the specific proposal
16:20:00 <luzie> which is confusingly still at github.com/xmonad/xmonad, someone should do something about that
16:20:01 <Fuuzetsu> ah, it was public
16:20:21 <geekosaur> nobody was interested in mentoring it, mostly because there's nobody really qualified
16:20:26 <Denommus> Eduard_Munteanu: "bus factor"?
16:20:30 <Fuuzetsu> xmonad is developed in darcs
16:20:54 <geekosaur> rui, xmonad's core rarely changes
16:20:59 <Fuuzetsu> no kidding
16:21:07 <Fuuzetsu> IIRC it goes back to compat with 6.12
16:21:07 <Eduard_Munteanu> Denommus, the susceptibility to disastrous effects for a project in case a leading developer gets hit by a bus. :)
16:21:10 <peddie> geekosaur: nobody's qualified because the main architects don't develop it anymore?
16:21:10 <ChristianS> paulrd: i think that the IO methods in Char8 (such as getContents) should handle "\r" correctly so you don't have to worry about it. didn' try it though.
16:21:46 <geekosaur> this may be confused with lack of activity by people who are used to huge projects that need constant bug fixes. xmonad's core is small, well tested, and while there are bugs they are mostly of the architectural variety
16:22:16 <Denommus> Eduard_Munteanu: people should be more aware of FRP, it is one of the most intuitive and expressive ways of modelling time-varying values in a purely functional fashion
16:22:34 <indiagreen> vandenoever: you can see that it's actually pretty simply implemented: http://hackage.haskell.org/package/symbol-0.2.4/docs/src/Data-Symbol-Unsafe.html#Symbol
16:22:37 <hexagoxel> i do not understand why Data.Binary.Tagged.decodeTagged error's out over here. should it not simply return Nothing?
16:22:41 <geekosaur> peddie, does it make you happy to believe that?
16:23:00 <peddie> geekosaur: I have no idea why nobody's qualifed, I'm asking :)
16:23:04 <hexagoxel> or am i reading the docs wrong? does anybody have experience with tagged-binary?
16:23:12 <geekosaur> xmonad is tightly tied to x11; nobody involved with it has significant experience with waylabnd
16:23:35 <peddie> gotcha
16:23:38 <geekosaur> peddie: you do see in a hurry to claim it is dead
16:23:41 <geekosaur> *seem
16:23:55 <peddie> geekosaur: I haven't claimed it's dead, and I use it every day and hope it doesn't die
16:23:58 <vandenoever> indiagreen: with cache shared across threads even
16:24:36 <geekosaur> and to be quite honest, I am watching wayland make mistakes that Windows made pre-NT and X11 made pre-R4
16:24:48 <peddie> geekosaur: I just thought the people who originally architected it don't work on it much these days, and other people develop it now
16:25:54 <vandenoever> geekosaur: like what?
16:26:46 <paulrd> ChristianS: I:m reading the file into a Data.ByteString.Lazy with getContents.  (That's reading as a binary right?)  Later I determine from the ascii header whether the rest of the file is ascii text or binary.
16:28:41 <geekosaur> synchronous input queue intended so programs can edit the master event stream, which means that program can lock up the entire window system. moving various things from the server side to the client side "for flexibility" (X11 did that initially and then ended up defining ICCCM because the programs/toolkits all diverged in behavior). taking focus policy away from the user and giving it to the program (ICCCM again, but EWMH has brought this back
16:28:41 <geekosaur>  to some extent, much to the annoyance of anyone who's had the browser steal focus)
16:29:33 <geekosaur> I am told of others but have no direct experience or documentation so don't want to spread possibly incorrect information
16:29:44 <paulrd> If it turns out to be ascii text I'd like to split the remainder of the binary ByteString with the moral equivalent of lines that can handle newlines portably.
16:31:50 <geekosaur> sadly, I've had a Wayland dev insist to me the synchronous input queue is a non-issue because "those bugs don't happen any more". ignoring that the reason they don't happen is that neither X11 nor modern Windows has a synchronous event queue, so it *can't* happen.
16:31:56 <coin3d> hello hello. [ x*y | (x,y) <- [(2,3)] ]
16:32:08 <coin3d> why are parentheses around x,y needed?
16:32:16 <coin3d> is it because the items of the list are tuples?
16:32:23 <luzie> yes
16:32:24 <pacak> coin3d: Right.
16:32:39 <simpson> geekosaur: You're 100% correct. Such is life; nobody is interested in X12 and nobody wants to admit that X11 is actually pretty decent at its job.
16:32:40 <geekosaur> (I will grant that the ability to trigger it is somewhat more limited than it was back then, when any program which didn't process its input events choked the whole system)
16:32:47 <coin3d> great, thanks
16:33:21 <geekosaur> X11's actually pretty lousy. (not helped by the fact that xorg has broken a number of things and made some truly strange decisions)
16:34:19 <geekosaur> The Wayland model is potentially a considerable improvement. The implementation... needs to mature, shall we say
16:34:29 <geekosaur> (so technically it's not Wayland but Weston)
16:34:50 <simpson> I haven't seen a good competitor to X11 that preserves network transparency, and that particular feature is essential to many use cases.
16:35:11 <Fuuzetsu> X12? Is such a thing planned?
16:35:39 <geekosaur> but watching them ignore the past because "that doesn't happen any more" or etc. is painful, because they will have to, and indeed are, relearning the hard way
16:35:45 <geekosaur> not that I know of
16:35:50 <simpson> Fuuzetsu: Yes. Lemme find the page.
16:35:58 <geekosaur> huh
16:36:03 <geekosaur> I hope it's not the xorg folks
16:36:04 <vandenoever> geekosaur: what is the reason for the synchroneous queue?
16:36:08 <Fuuzetsu> hehe
16:36:09 <kazagistar> Wayland is the X12, for all practical purposes
16:36:12 <Denommus> simpson: IIRC, Wayland simply leaves that to other libraries to handle. A Wayland compositior doesn't know if the client is in another computer or not, it simply composes
16:36:22 <luzie> vnc is generally more efficient for anything using a modern toolkit
16:36:27 <Fuuzetsu> but I agree, we all bitch and moan about X but after some tears and sweat it eventually works to some extent
16:36:28 <kazagistar> a lot of the xorg people jumped ship to wayland
16:36:32 <simpson> Denommus: Yes, which is why Wayland makes such a big deal about being able to host X11.
16:36:54 <JoshieAS> quick syntax question
16:37:00 <JoshieAS> I can do fmap (show) [1,2,3,4]
16:37:00 <simpson> kazagistar: It's a nice dream, but not really. The recent ship-jumping has been because people have switched companies.
16:37:01 <vandenoever> if wayland brings about a nirvana with sandboxed applications, that'd be nice
16:37:07 <simpson> Fuuzetsu: http://www.x.org/wiki/Development/X12/
16:37:12 <JoshieAS> but how do I write out fmap (read) ["1","2","3","4"]?
16:37:13 <geekosaur> vandenoever, so that you can have program(s) that can inspect and/or edit the input queue. which strikes me as a security nightmare as well as a formerly fertile source of bugs
16:37:16 <JoshieAS> where do I put my :: Int?
16:37:28 <simpson> As ajax says, "We'll start work on X12 once we fix all the X11 bugs."
16:37:28 <srhb> JoshieAS: You could use :: [Int] for ease
16:37:31 <Fuuzetsu> > fmap read ["1","2","3","4"] :: [Int]
16:37:33 <lambdabot>  [1,2,3,4]
16:37:36 <JoshieAS> oh, right, thanks
16:37:51 <vandenoever> geekosaur: as an author of an unpriviliged keylogger for X11, i can say that the wayland model is more secure
16:37:58 <geekosaur> or (read :: String -> Int)
16:38:26 <vandenoever> geekosaur: at least in wayland it's clear who is listening
16:38:35 <geekosaur> I'm not claiming X11 is secure. but I worry about granting access to the master event stream
16:38:54 <geekosaur> and I know Wayland *has* a security model, which all by itself makes it more secure than X11 >.>
16:38:57 <vandenoever> geekosaur: that stream needs secure access indeed
16:39:54 <vandenoever> geekosaur: i'd like to plugin cortana/now/siri into it of course
16:39:55 <simpson> geekosaur: That's a little bit oranges-to-apples. Wayland's scope doesn't cover remote hosts. Also X11 has *pluggable* security, which changes the story. Things like XACE are real and practical.
16:40:08 <simpson> (Also you can always forbid an Xorg from loading things like Xtest.)
16:41:14 <Fuuzetsu> maybe we should go to -blah
16:41:45 <hpc> i bet you say that to all the ladies
16:42:28 <Fuuzetsu> hpc: I'm trying really hard to come with a witty remark but it's not happening.
16:50:50 <exm> Hey all, new to Haskell and wanted to try a quick proof of concept with wxHaskell (OS X 10.10.3, cabal 1.22.2.0, GHC 7.10.1), but after I `cabal sandbox init` and `cabal update`, trying `cabal install wx` fails with https://gist.github.com/millere/9bf2e9ff10ce596e5b51
16:51:18 <exm> Is there anything I can do to fix that? I see why it's failing, just not sure if I can ask for an older wxHaskell or anything like that, or how
16:51:26 <exm> Or if there's a better way
16:52:25 <dcoutts> exm: you might be able to get a better error message if you tell the solve to try harder
16:52:50 <dcoutts> --max-backjumps=-1 --constraint='time source'
16:52:54 <earldouglas> What's a good way to write a function whose input can only be one of certain constructors of a data type?
16:53:08 <exm> dcoutts: ty, running now
16:53:15 <earldouglas> e.g. data Foo = Bar | Baz     foo :: Bar -> Int
16:53:26 <Cale> earldouglas: You don't do this.
16:53:35 <earldouglas> I've figured that much out. :]
16:54:17 <Cale> earldouglas: In Haskell the distinction between types and values coincides pretty much identically with the distinction between compile time and run time.
16:54:24 <glguy> exm: The problem is that the "wxdirect" package hasn't been update since GHC 7.10.1 came out which uses a new version of the time package
16:54:26 <kirill``> exm: I wonder, what versions of time do you have? If it's only 1.5.0.1 then the problem I think is that wxdirect specifically requires a version <1.5, so it would make sense it would fail
16:54:30 <quxbam> is it possible to generate with TH rewrite rules?
16:54:53 <exm> kirill``: How can I check?
16:55:00 <Cale> There's no way in general of knowing statically that a value of type Foo is actually Bar and expressing this at the type level.
16:55:06 <kirill``> cabal info time
16:55:11 <exm> ty
16:55:12 <earldouglas> Cale: Ah ok, that makes sense
16:55:50 <quxbam> any idea?
16:56:02 <exm> kirill``: 1.5.0.1 is install, but a long list of others are available
16:56:02 <Cale> (you could encode a property like this with a dependent type system, but it would result in proof obligations when you went to use the function)
16:56:46 <kirill``> Not too sure, but would it work to cabal install time-1.4.2 and then try again? Don't have to delete time-1.5.0.1 I think.
16:56:47 <Cale> earldouglas: Typically, if the Bar constructor has some fields, you can make a datatype with corresponding fields, but only a single constructor, and use that instead.
16:57:10 <earldouglas> I could, but I would like to be able to consider it the same type of Foo *some* of the time.
16:57:46 <earldouglas> For the sake of clarity, I'm thinking about Tic Tac Toe as described in the NICTA course.
16:57:55 <exm> kirill``: That blows up with a different error. I'll probably be back on to debug more later, but I have to go for now
16:58:05 <earldouglas> So I have several ways to express a game, and onyl some of them should be playable.
16:58:05 <glguy> exm: You're going to probably have to switch back down to GHC 7.8.4 
16:58:41 <earldouglas> So it would be nice to be able to say a Game is New, Open, Won, Tied, and a PlayableGame is New, Open and an UnplayableGame is Won, Tied
16:58:58 <earldouglas> Normally I would think of this as three interfaces (in a JVM language)
16:59:09 <earldouglas> PlayableGame and UnplayableGame would both extend Game
16:59:38 <earldouglas> But this approach isn't working for me here.
17:01:06 <earldouglas> Should PlayableGame and UnplayableGame instead be classes?
17:02:37 <earldouglas> I still get stuck, e.g. data Game = New | Open GameData | Won GameData | Tied GameData ; instance Playable New where ...
17:02:40 <earldouglas> Because New isn't a type
17:02:47 <quxbam> is it not possible to have a template haskell function which creates (depending on it's argument) a rewrite rule which will be used for the program compilation?
17:02:48 <Cale> That's right, it's not
17:02:53 <knite> I read the following comment on HN: "Haskell has a problem in that people think about the basic libraries as deprecated, but won't deprecate them due to backward compatibility. Thus, people starting on it will get plenty of slow and unsafe constructs, while people used to it only look at the fast and safe ones.
17:02:54 <knite> There should be warnings all over the Prelude and basic libraries documentation."
17:03:00 <Cale> You could use a GADT
17:03:03 <knite> This sounds a bit concerning, which common things should I avoid using, as a Haskell beginner?
17:03:21 <dibblego> earldouglas: it is common to solve that problem using smart constructors, which is what you are describing
17:03:31 <geekosaur> I have a feeling they're talking about lazy I/O
17:03:37 --- mode: dibblego set -o dibblego
17:03:52 <quxbam> perhaps they're talking about head and nub
17:04:00 <Cale> and/or phantom type parameters if you'd rather avoid extensions
17:04:05 <Cale> Let me write something...
17:04:22 <geekosaur> in which case the problem is that the reliable stuff is harder to use. lazy I/O is dead simple and sufficient for simple programs
17:06:43 <earldouglas> dibblego: would you recommend in my example that Playable and Unplayable be their own data types, or classes?
17:06:51 <lpaste> Cale pasted “With fancy types” at http://lpaste.net/132423
17:06:55 <earldouglas> Or are both wrong?
17:07:02 <Cale> earldouglas: ^^ that's an approach you could take
17:07:13 <dibblego> earldouglas: that is pretty darn close to a lot of solutions I have seen
17:07:23 <Cale> You could do a similar thing with far less fancy types though, I can show that as well...
17:07:49 <earldouglas> Cale: interesting, thanks
17:07:53 <dibblego> Won and Tied could just be their own constructor, with one of data WhoWon = X | O | Draw
17:08:07 <dibblego> s/their own/the same
17:10:17 <lpaste> Cale annotated “With fancy types” with “With less fancy types” at http://lpaste.net/132423#a132424
17:10:58 <lpaste> Cale revised “With less fancy types”: “No title” at http://lpaste.net/132424
17:11:07 <Cale> (don't need the extensions then)
17:11:20 <earldouglas> Ah, that phantom type makes a bit more sense to me
17:11:46 <Cale> It amounts to the same thing as with the GADT
17:11:53 <earldouglas> Cold I use that to make a function that takes `Game Playable` as input?
17:11:54 <Cale> Only the GADT will let you pattern match :)
17:11:58 <Cale> yeah
17:12:19 <earldouglas> What's the distinction between GADT and DataKinds?
17:12:42 <earldouglas> DataKinds allows me to use kinds in a data type, right?
17:12:51 <earldouglas> e.g. data Game :: GameState -> * where
17:13:05 <Cale> DataKinds lets us use that GameState data type as a kind, so its constructors Playable and Unplayable become types (with no values) of kind GameState
17:14:56 <Cale> GADTs is what lets the constructors of the Game data type have differently specialised result types
17:15:41 <Cale> The fancy thing about GADTs is that when you pattern match against the constructors, the information about which type a was becomes available.
17:16:47 <newsham> what is lens-ese for "gets fieldname" ?
17:16:55 <newsham> ie. data access in state monad
17:17:02 <Cale> e.g. if you're writing a function  foo :: Game a -> ...  and you pattern match  foo x@(Open d) = ...  then on the right hand side, you know that x :: Game Playable
17:17:18 <Cale> Though in this case, I don't think that'll be too important for you
17:17:36 <earldouglas> Cale: awesome, that put me on the right track, I think
17:17:38 <earldouglas> Thanks a lot
17:17:50 <earldouglas> dibblego: thanks too
17:18:01 <dibblego> goodo
17:18:19 <Cale> newsham: gets (view l)
17:18:35 <Cale> ;)
17:18:42 <newsham> so no fancy operators?
17:18:57 <Cale> There are fancy operators, but I can't tell you what they are, because I avoid them.
17:19:19 <Cale> (In the interest of having my code be readable)
17:19:42 <newsham> seems "+=" and ".=" are pretty readable
17:19:45 <newsham> i cant vouch for the whole set
17:20:08 <osa1_> I can remove commas in exposed-modules field but can't remove them in build-depends.. why?
17:21:31 <Axman6> exposed modules have a pretty easy to separate syntax, where as librarties you depend on have a more complex syntax (version restrictions etc)
17:21:46 <Axman6> I don't know if that's actually the reason but it makes sense
17:22:04 <newsham> blah, lamdabot says "gets . view" is MonadState s m => Getting a s a -> m a  , but hoogle is useless because it doesnt know "Getting"
17:22:50 <geekosaur> hoogle can't index everything currently. if you specify package:lens I think it should work? (and if it has that indexed)
17:22:57 <geekosaur> try fpcomplet's hoogle maybe
17:23:05 <josephle> why not Hayoo?
17:23:16 <newsham> ahh, use = gets . view
17:23:18 <bitemyapp> josephle: not really type-structure aware like Hoogle.
17:23:29 <josephle> bitemyapp, ah that's good to know
17:24:20 <geekosaur> yes, at present hayoo handles fuzzy names better and hoogle handles fuzzy types better. both are working on their respective issues but for now that's a reasonable summary
17:37:13 <kirill``> How is realToFrac :: Double -> Float implemented? Does it go through Rational by any chance?
17:37:48 <Fuuzetsu> kirill``: why not peek in the source?
17:37:55 <dmj`> @src realToFrac
17:37:56 <lambdabot> realToFrac = fromRational . toRational
17:38:01 <Denommus> damn, I can't understand the (Wire s e m) instance of ArrowLoop in Netwire
17:38:03 <dmj`> kirill``: yes! it does
17:38:35 <arkeet> kirill``: but there are rewrite rules that can make it more efficient
17:38:48 <geekosaur> not absolutely certain, remember that (a) @src doesn't always tell the truth (b) yeh, RULES
17:39:04 <arkeet> I'm fairly sure there's one for Double -> Float
17:39:09 <geekosaur> not impossible that a rewrite rule exists to optimize that case
17:39:43 <indiagreen> to be honest, @src pretty much never tells the truth
17:39:49 <arkeet> or maybe not
17:40:15 <kirill``> So how do I check what it's doing? I'd like to get the usual (float)x behaviour from C.
17:40:22 <arkeet> realToFrac is the thing to use.
17:44:38 <kirill``> > 0/0 :: Double
17:44:39 <lambdabot>  NaN
17:44:48 <kirill``> > realToFrac (0/0 :: Double) :: Double
17:44:49 <lambdabot>  -Infinity
17:45:27 <kirill``> > realToFrac (-0 :: Double) :: CFloat
17:45:28 <lambdabot>      Not in scope: type constructor or class ‘CFloat’
17:45:28 <lambdabot>      Perhaps you meant ‘Float’ (imported from Prelude)
17:47:17 <arkeet> yep there's the rule
17:47:24 <arkeet> https://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-Float.html
17:47:30 <arkeet> "realToFrac/Double->Float"  realToFrac   = double2Float
17:48:40 <kirill``> > id (0/0 :: Double)
17:48:41 <lambdabot>  NaN
17:48:58 <kirill``> arkeet: So when can I be sure the rules are applied?
17:49:23 <kirill``> I don't feel  very comfortable when 0/0::Double and realToFrac(0/0::Double)::Double are different
17:49:25 <arkeet> use -O
17:49:31 <arkeet> rules don't fire without -O
17:49:41 <arkeet> lambdabot doesn't use -O
17:49:53 <kirill``> arkeet: So programs without -O use fromRational.toRational ?
17:50:07 <arkeet> yes
17:50:15 <newsham> algebra and Double are incompatible :)
17:50:17 <arkeet> try it yourself:
17:50:27 <arkeet> main = print (realToFrac (0/0))
17:50:34 <arkeet> compile that using ghc with and without -O
17:50:37 <arkeet> and see the difference
17:52:01 <kirill``> arkeet: Whoa. I'm kind of used IEEE arithmetic, tbh
17:53:58 <dmj`> Has anyone created a generalization over configurator and environment variables
17:54:05 <kirill``> Even Numeric.IEEE doesn't seem to expose double2Float
17:54:18 <arkeet> it's from GHC.Float
17:54:24 <dmj`> Meaning if a variable doesn't exist in your configurator config file it will attempt to look it up in the environment
17:54:44 <arkeet> dmj`: sounds like a potential security risk.
17:55:20 <dmj`> arkeet: why, environment variables for a specific user, not for su
17:55:47 <dmj`> arkeet: It would be like an Alternative
17:56:13 <arkeet> just saying that falling back to environment variables should be optional or something.
17:56:14 <TheKing> @pl \k -> c1 $ c2 . const . k
17:56:15 <lambdabot> c1 . ((c2 . const) .)
17:57:15 <dmj`> arkeet: when dealing with docker containers dev ops becomes env variable happy. My web server right now creates conn pools from settings in a configurator file, but if that file doesn't exist, that means it's in a docker container, so it should read it from the env
17:57:34 <dmj`> that means the web server is running in a container
17:57:56 <kirill``> So is there anything else I should do with floating point values? If I enable -O, I get the usual IEEE arithmetic, right?
17:58:21 <arkeet> kirill``: arithmetic is the same, it's just those RULES for realToFrac and fromIntegral and such 
17:58:58 <kirill``> arkeet: Sorry, I also meant conversions
17:59:06 <arkeet> yeah
17:59:11 <TheKing> @pl \k -> fc $ \kf -> c $ \kc -> k $ kf kc
17:59:11 <lambdabot> fc . (c .) . (.)
18:00:38 <TheKing> \a -> f ($a)
18:00:44 <TheKing> @pl \a -> f ($a)
18:00:45 <lambdabot> f . flip id
18:01:49 <mjrosenb> @hoogle functor f => f (a,b) -> (f a, f b)
18:01:49 <lambdabot> Did you mean: Functor f => f (a, b) -> (f a, f b)
18:01:49 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
18:01:49 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
18:03:00 <arkeet> :t both id
18:03:01 <lambdabot> (Applicative f, Data.Bitraversable.Bitraversable r) => r (f b) (f b) -> f (r b b)
18:03:10 <arkeet> oh that goes the wron gway.
18:03:26 <arkeet> :t fmap fst &&& fmap snd
18:03:27 <lambdabot> Functor f => f (b, b1) -> (f b, f b1)
18:03:32 <mjrosenb> so, in the tradition of map -> fmap, I propose funzip x = (fmap fst x, fmap snd x)
18:03:48 <arkeet> it's a tuple?
18:03:55 <mjrosenb> or s/,/&&&/
18:03:58 <arkeet> oh weh.
18:04:08 <arkeet> what's unzip?
18:04:12 <arkeet> oh there it is.
18:04:28 <arkeet> that prelude function I never use.
18:04:36 <mjrosenb> > unzip [(1,"a"), (2,"b)]
18:04:37 <lambdabot>  <hint>:1:24:
18:04:37 <lambdabot>      lexical error in string/character literal at end of input
18:04:44 <mjrosenb> > unzip [(1,"a"), (2,"b")]
18:04:45 <lambdabot>  ([1,2],["a","b"])
18:04:51 * mjrosenb uses it every once in a while.
18:08:19 <mjrosenb> gah, every project I work on ends up having a utils.hs or utils.c or utils.py with all of those little one line functions that should probably be in the standard library, but are left out to avoid slippery slopes
18:09:33 <mjrosenb> maybe I'll call the module Prelude2
18:10:37 <mjrosenb> hrmm, that feels like it is half of a name
18:10:44 <pavonia> I have the same problem and thought about making it a local package
18:10:47 <mjrosenb> Prelude2Lambda?
18:11:11 <japesinator> so probably dumb question
18:11:15 <japesinator> I have a list of numbers
18:11:35 <japesinator> and I want to generate a list of their differences
18:11:49 <mjrosenb> pavonia: I think my ideal solution would to be to have a local .prelude.hs, and you can run cabal bundle, which will extract the used functions from that, and make it into a proper file in the project.
18:11:51 <japesinator> like f [1,3,8,3] = [2,5,-5]
18:11:52 <arkeet> :t zipWith
18:11:53 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
18:11:55 <arkeet> :t tail
18:11:56 <lambdabot> [a] -> [a]
18:12:52 <mjrosenb> japesinator: there is the easy way, which arkeet is hinting at, and then you can try to use a fold...
18:12:58 <arkeet> no fold needed.
18:13:10 <mjrosenb> the fold is probably more complicated than it needs to be.
18:13:39 <arkeet> > zipWith (-) [b,c,d] [a,b,c,d]
18:13:40 <lambdabot>  [b - a,c - b,d - c]
18:14:14 <arkeet> actually drop 1 is better than tail.
18:14:31 <mjrosenb> arkeet: right, which is what you hinted at, and the one that is less complex.
18:16:05 <arkeet> now how would one do it with a fold...
18:16:18 <verement> > let f xs = zipWith subtract xs (tail xs) in f [1,3,8,3]
18:16:20 <lambdabot>  [2,5,-5]
18:17:17 <arkeet> bah, too complicated.
18:21:51 <mjrosenb> arkeet: step 1: cry
18:21:56 <mjrosenb> step 2:
18:22:00 <mjrosenb> > (\todiff -> init $ snd $ foldr (\c (p,l)-> (c,p-c:l)) (undefined,[]) todiff) [2,5,3,0]
18:22:01 <lambdabot>  [3,-2,-3]
18:22:01 <Fuuzetsu> you missed step 0
18:22:04 <Fuuzetsu> try not to cry
18:22:32 <mjrosenb> Fuuzetsu: but step 2 was not cry a lot.
18:22:51 <Fuuzetsu> it's step 3
18:23:12 <hodapp> hmmmm
18:23:32 <hodapp> read "Category Theory for Computing Science", or read the HoTT text?
18:26:30 <mjrosenb> hodapp: both
18:26:33 <mjrosenb> hodapp: in parallel!
18:27:00 <mjrosenb> open the pdfs side by side, then read one line from one, followed by one line from the other!
18:27:26 <Fuuzetsu> CTCS
18:27:29 <Fuuzetsu> concurrently
18:29:17 <mjrosenb> Is there a variant of zip that will return the letover elements?
18:29:44 <mjrosenb> @hoogle [a] -> [b] -> ([(a,b)], [a], [b])
18:29:45 <lambdabot> No results found
18:29:47 <arkeet> mjrosenb: look at Data.Align
18:29:48 <hodapp> mjrosenb: ....I'm not sure if you're joking or not @_@
18:29:51 <hodapp> Fuuzetsu: whaa?
18:30:17 <Fuuzetsu> hodapp: Category Theory for CS
18:30:33 <Fuuzetsu> but you could read both, it's not like you do it in one sitting
18:30:36 <Fuuzetsu> or 5 sittings, or 15…
18:31:01 <hodapp> I can tell from trying to grok HoTT that I need some better background in category theory and possibly in type theory.
18:31:19 <hodapp> Fuuzetsu: Is CTCS the common acronym for said textbook?
18:31:29 <Fuuzetsu> not that I know of
18:31:46 <hodapp> I should grab TAPL at some point...
18:31:50 <mjrosenb> hodapp: well generally, there is only one acronym for a phrase.
18:31:52 <Fuuzetsu> thought it would be obvious what I was refering to in that context but clearly not :)
18:32:23 <hodapp> mjrosenb: what I mean is, is it the most common shortened way to refer to the book.
18:33:16 <Fuuzetsu> I never heard or saw it referred to in shortened way beyond ‘authors' book’ 
18:33:34 <Fuuzetsu> *** Tantadruj (~null@…) has quit: Quit: null !== nil
18:33:37 <Fuuzetsu> what a quit message
18:35:21 <Fuuzetsu> hodapp: in fact Barr & Wells is how I commonly heard it referred to but only when it was clear from context that it their Toposes, Triples and Theories wasn't meant
18:36:42 <mjrosenb> physics and math books are commonly referred to solely by their authors.
18:36:56 <mjrosenb> CS run a whole gamut of their 'canonical' names
18:37:26 <Fuuzetsu> despite the title of the book, I wouldn't call it a CS one
18:38:28 <Fuuzetsu> though that's a personal opinion
18:38:29 <mjrosenb> e.g. the dragon book, the dinosaur book, toacp, hennessey+patterson
18:38:39 <mjrosenb> *taocp
18:39:07 <Fuuzetsu> don't forget all the ‘the <colour name> book’
18:39:48 <mjrosenb> SICP is also almost always referred to by its acronym
18:40:05 <mjrosenb> Fuuzetsu: I... don't know of those (bo color at lease)
18:40:07 <mjrosenb> oh wait
18:40:11 <mjrosenb> are these the opengl books?
18:40:18 <Fuuzetsu> yes, mostly
18:40:21 <mjrosenb> ok.
18:40:35 * mjrosenb doesn't have those, and uhhh
18:40:52 <Fuuzetsu> SICP is sometimes referred to as the purple book
18:41:04 <vpm> also as the wizard book
18:41:06 <mjrosenb> my brain replace "the <color name>" with green and blue, because of weezer
18:41:07 <Fuuzetsu> yep
18:41:21 <mjrosenb> and I am not aware of any green or blue books.
18:41:36 <Fuuzetsu> SICP usually looks blue to me ;P
18:42:07 <Fuuzetsu> mjrosenb: reserved for future use ;)
18:44:05 <mjrosenb> then again, weezer's latest colored album was the red album
18:45:35 <hodapp> I need to read/work through SICP
18:46:07 <hodapp> but I should really finish working through Software Foundations first probably
18:46:57 <eacameron> is there a system that will daily try to build my packages with the newest version of Stackage LTS/nightly and update constraints accordingly?
18:47:43 <calvinx> eacameron wow, that would be awesome. I would love to have that as well.
18:47:52 <Fuuzetsu> doesn't stackage build nightly?
18:48:14 <eacameron> Fuuzetsu: yeah
18:48:19 <eacameron> but my package doesn't
18:48:28 <Fuuzetsu> put your package on stackage
18:48:40 <calvinx> private projects?
18:48:48 <eacameron> calvinx: right
18:48:54 <Fuuzetsu> ah
18:48:58 <fresheyeball_> I have a question
18:49:02 <eacameron> also, my package would need constraints
18:49:04 <Fuuzetsu> you'd have to set something up yourself
18:49:08 <eacameron> but I don't want to care
18:49:13 <Fuuzetsu> like a Hydra box that pulls from stackage
18:49:13 <eacameron> I just want stackage to figure them out
18:49:25 <eacameron> hmm...Hydra
18:49:25 <calvinx> So Hydra can do something like this.
18:49:49 <Fuuzetsu> it can build stuff but if you care about constraints it's a bad choice, probably
18:49:51 <eacameron> calvinx: Fuuzetsu: tell me about this
18:50:10 <fresheyeball_> lets say you have 2 ADTs (Foo a :: * -> *) and (Bar a b :: * -> * -> *)
18:50:20 <calvinx> http://nixos.org/hydra/
18:50:22 <Fuuzetsu> I think hvr was doing something with install plans and stuff which checks what versions of GHC something builds with, it could probably be extended, you should poke him  
18:50:32 <Pamelloes> I remember reading somewhere about how you can write "_" in a type and GHC will fill it in automatically with the correct type when compiling. Does anyone know which extension this is?
18:50:32 <eacameron> Fuuzetsu: well it seems that a package maintainer really wants broadest working constraints possible
18:50:45 <fresheyeball_> is there a way to combine them into a new type that is either one or the other?
18:51:07 <fresheyeball_> I know this would work
18:51:18 <Fuuzetsu> fresheyeball_: only a type parametrised by both
18:51:34 <calvinx> http://hydra.nixos.org/build/21862762/download/2/manual.pdf
18:51:37 <fresheyeball_> type Baz = Either (Foo Int) (Bar Int String)
18:51:52 <fresheyeball_> but that seams ugly
18:51:55 <Fuuzetsu> calvinx: I really don't think Hydra would easily do what eacameron is after, at all
18:52:01 <fresheyeball_> and I wont be able to use it with typeclasses
18:52:23 <calvinx> O :(
18:53:46 <Fuuzetsu> fresheyeball_: well you want some kind of a sum type, be it Either or some custom-rolled one
18:56:54 <Pamelloes> Is there a way to update ghc via cabal?
18:56:58 <Fuuzetsu> no
18:57:11 <Fuuzetsu> updating GHC is a job of a package manager
18:57:21 <Pamelloes> mm
18:57:27 <Pamelloes> my package manager is at 7.8.3
18:57:40 <Pamelloes> Time to build from scratch!
18:57:57 <mjrosenb> Pamelloes: or get a better package manager!
18:57:58 <Fuuzetsu> a better idea may be to contribute a package for 7.10
18:58:04 <Fuuzetsu> mjrosenb: I was getting to that!
18:58:57 <Pamelloes> mjrosenb: I'm on OS X, so my options are kind of limited. Submitting a package for 7.10 would probably be the right thing to do. But I've never made a package before so....
18:59:21 <Fuuzetsu> nix works on OSX and 7.10.1 is the default nowadays
18:59:25 <dmj`> Pamelloes: https://ghcformacosx.github.io/
18:59:44 <mjrosenb> oh snap
18:59:50 <mjrosenb> I have two functors
19:00:24 <Pamelloes> Fuuzetsu: I don't quite know how to use Nix, and I don't really want to deal with it just yet :/
19:00:25 <Fuuzetsu> nice, functors are nice to have
19:00:34 <Fuuzetsu> Pamelloes: that's OK, just putting it out there
19:00:44 <mjrosenb> > fmap (fmap (+1)) [Maybe 3]
19:00:46 <lambdabot>      Not in scope: data constructor ‘Maybe’
19:00:46 <lambdabot>      Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
19:00:51 <mjrosenb> > fmap (fmap (+1)) [Just 3]
19:00:53 <Fuuzetsu> there is ##nix-darwin and #nixos if you want to give it a go one day
19:00:53 <lambdabot>  [Just 4]
19:01:12 <dmj`> Fuuzetsu: but if you're doing web dev... watch out for 7.10... https://ghc.haskell.org/trac/ghc/ticket/10380
19:01:18 <dmj`> socket blockage
19:01:19 <Fuuzetsu> mjrosenb: ah, at least it's not the good old fmap fmap fmap
19:01:42 <Fuuzetsu> dmj`: I don't do webdev, thought we established that ;P and I saw the ticket. I'm much, much more concerned about #4012 though
19:01:44 <mjrosenb> I'm guessing there isn't a standard notation for talking about 'this deals with two layers of functors'
19:02:30 <dmj`> Fuuzetsu: oh yea :)
19:02:40 <mjrosenb> Fuuzetsu: that number is much much lower than 10380.
19:03:22 <Fuuzetsu> > (fmap fmap fmap) (+1) [Just 3]
19:03:23 <lambdabot>  [Just 4]
19:03:24 <Fuuzetsu> mjrosenb: ^
19:03:44 <Fuuzetsu> mjrosenb: it's also much much more annoying than 10380
19:03:44 <dmj`> Fuuzetsu: woa, that's a bad one too
19:03:58 <Fuuzetsu> dmj`: it's really bad for the nix world
19:04:48 <Fuuzetsu> we like our binary caches but in presence of such non-determinism, you often end up with unexpected package IDs from GHC and stuff doesn't work 
19:04:48 <dmj`> Fuuzetsu: so much for purity 
19:05:01 <Fuuzetsu> dmj`: unsafeInterleaveIO putting in the work
19:05:07 <dmj`> Fuuzetsu: nix's purity is predicated on those hashes too right
19:05:25 <Fuuzetsu> dmj`: no, nix hashes are generated from inputs to the derivation
19:05:45 <Fuuzetsu> so we end up with the same nix hashes
19:05:58 <Fuuzetsu> but the contents of the actual package built can be different 
19:06:11 <dmj`> Fuuzetsu: but the inputs to the derivation are packages right
19:06:23 <Fuuzetsu> so if you have two different machines which each build packages and then you mix those packages and the IDs are not consistent, bad things happen
19:07:09 <Fuuzetsu> dmj`: no, it's things like source hash and hashes of the dependencies (not the hashes of the built packages but hashes of derivation)
19:07:54 <Fuuzetsu> you know the derivation hash before building anything
19:08:20 <Fuuzetsu> I mean, if you didn't then how could you ever fetch something from a binary cache, if you had to build it first then that'd be quite useless :)
19:11:19 * mjrosenb has chosen the name f2unzip
19:11:59 <Fuuzetsu> well
19:12:09 <Fuuzetsu> I think there was a package with nested fmap applications somewhere
19:12:13 <Fuuzetsu> but I always forget when this comes up
19:14:22 <mjrosenb> Fuuzetsu: only one?
19:18:05 <mjrosenb> so, haskell kind of has postfix operators, I'm not sure how I feel about this.
19:21:06 <mjrosenb> @hoogle a->(a->b)->b
19:21:06 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
19:21:06 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
19:21:06 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
19:21:45 <mjrosenb> no, for once I actually care about the order my arguments are in :-(
19:24:41 <c_wraith> > let (!) n | n == 0 = 1 | otherwise = n * ((n - 1)!) in (5!)  -- postfix operators!
19:24:42 <lambdabot>  120
19:27:15 * mjrosenb was thinking of {}
19:28:14 <Hijiri> I don't think {} is a haskell operator
19:28:45 <Hijiri> it is syntax for some things though
19:28:46 <mjrosenb> Hijiri: I said kind of.
19:28:56 <Hijiri> oh, sorry
19:29:06 <Hafydd> It is related to the semicolon operator.
19:29:15 <mjrosenb> right, but if x is an expression, then so is x {a=5}
19:29:16 <newsham> what are thoughts on conduits?  are conduits based on iteratee design?   "non goals: obey category laws, make core as simple as possible",  are these black eyes or good pragmatic choices?
19:29:20 <mjrosenb> and has the same type as x.
19:32:40 <mjrosenb>     Ambiguous occurrence ‘VSync’
19:32:44 <mjrosenb> GAH
19:32:45 <mjrosenb> NO
19:32:56 <mjrosenb> I wanted to avoid this BS.
19:33:05 <newsham> import qualified as BS
19:33:06 <mjrosenb> they are the same! they are all the same!
19:33:37 <mjrosenb> just look at both of them, verify they're the same, and just use whichever one you want!
19:34:55 <Pamelloes> Why do you have a type defined the same way in two locations?
19:35:16 <Pamelloes> Why not simply define it in one place and import it to the second location. Then it wouldn't be ambiguous.
19:35:28 <enthropy> mjrosenb: it could have a different type if we had data X a = X { a :: a } and x = X 'x'
19:35:32 <dmj`> any hakyll people in here
19:35:40 <mjrosenb> Pamelloes: because that would introduce a cyclic dependency
19:35:51 <mjrosenb> enthropy: they are all type aliases.
19:36:08 <Pamelloes> mjrosenb: You could always break it out into a third file and import it into the two existing locations
19:36:31 <mjrosenb> Pamelloes: I've just changed the exports for the second location to not export it.
19:36:41 <Pamelloes> That works two
19:36:43 <Pamelloes> *too
19:36:44 <Pamelloes> gah
19:37:02 * Pamelloes is ashamed at his grammar D:
19:37:32 <mjrosenb> is there already a function that will duplicate a value into a tuple?
19:37:57 <Pamelloes> mjrosenb: One of the arrow functions.
19:38:06 <Fuuzetsu> @hoogle a -> (a, a)
19:38:06 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
19:38:07 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
19:38:07 <lambdabot> Network.BufferType buf_splitAt :: BufferOp a -> Int -> a -> (a, a)
19:38:10 <Fuuzetsu> uh
19:38:15 <Pamelloes> maybe not
19:38:17 <Fuuzetsu> @pl f x = (x, x)
19:38:17 <lambdabot> f = join (,)
19:38:26 <newsham> mjrosenb: deplicate into tuple == run-length-encoding?
19:39:09 <mjrosenb> newsham: no, what Fuuzetsu said
19:39:16 <dmj`> > pure 1 :: Monoid m => (m,Int)
19:39:17 <lambdabot>  ((),1)
19:39:32 <mjrosenb> > let dup x = (x,x) in dup "hello"
19:39:33 <lambdabot>  ("hello","hello")
19:39:40 <dmj`> > (\x -> (x,x)) $ 5
19:39:41 <lambdabot>  (5,5)
19:39:53 <dmj`> @pl (\x -> (x,x))
19:39:53 <lambdabot> join (,)
19:40:01 <dmj`> that's hot
19:40:05 <dmj`> > join (,) 4
19:40:07 <lambdabot>  (4,4)
19:40:39 <newsham> what did fuuzetsu say?
19:41:08 <mjrosenb> newsham: 22:42 < Fuuzetsu> @pl f x = (x, x)
19:42:19 <newsham> > (id &&& id) x
19:42:21 <lambdabot>  (x,x)
19:42:36 <enthropy> mjrosenb: I'm not sure what involving type has to do with saying x has the same type as x { a = 5 },but for sure there are cases where both have the same type
19:42:54 <Pamelloes> newsham: that's what I was thingking of
19:43:06 <enthropy> newsham: there's some cruft in conduit (say =$ being exactly the same as =$=)
19:43:12 <mjrosenb> enthropy: how can updating a field change the type of something?
19:43:49 <mjrosenb> I guess if it is polymorphic, you can change the type by changing the type of a value in a field.
19:44:39 <enthropy> yes 'x :: X Char' and 'x { a = 5 } :: X Int'
19:44:56 <enthropy> is one possibility
19:46:31 <Pamelloes> Wait, you can do x { field = value} to create a new value equal to x except for field?
19:46:39 <c_wraith> Pamelloes: yep
19:46:51 <Pamelloes> oh my god. I've wasted so many keystrokes
19:46:51 <Pamelloes> D:
19:47:15 <dmj`> kadoban: ping
19:49:51 * mjrosenb now has Menu { ..., vis = vis, dis = dis, ... } where (vis, dis) = foo bar baz
19:50:11 <mjrosenb> and it would be cool if I could just have a postfix way to do that without needing to destructure
19:50:30 <mjrosenb> my current plan is Menu {...} & foo' bar baz
19:50:46 <dmj`> mjrosenb: you can use the RecordWildCards extension
19:51:00 <mjrosenb> dmj`: how does that work?
19:51:38 <dmj`> mjrosenb: at the top of your file add {-# LANGUAGE RecordWildCards #-}
19:52:28 <dmj`> mjrosenb: then you can write code like this: data Person = P { age :: Int, name :: String }; main :: IO (); main = let Person{..} = P 20 "Joe" in print (name, age)
19:52:49 <dmj`> mjrosenb: it binds the values to the field names
19:53:05 <dmj`> mjrosenb: some say this is obfuscation, some say its convenient, some just don't say
19:53:14 <mjrosenb> dmj`: I want to go the other way.
19:53:21 <dmj`> mjrosenb: you can
19:53:45 <dmj`> main = let name = "Joe"; age = 23; person = Person{..} in print person
19:55:12 <mjrosenb> dmj`: I guess with that I'd just save the vis = vis, dis = dis, but still need the explicit unpacking?
19:55:34 <goldfire> Quick question: Is there a way to check if haddock is running during compilation? I want to make a subtle change to some code only when I'm running haddock, not when compiling "for real".
19:55:38 <dmj`> mjrosenb: you don't need to unpack anymore, the values are bound to the field names
19:56:03 <dfeuer> goldfire, that sounds evil.
19:57:01 <goldfire> dfeuer: It's not. I want to mention a type in quotes in a haddock comment, and have haddock link to the type definition. But that type is not in scope, so haddock doesn't forge the link. So, I want the import statement done only in haddock mode.
19:57:21 <orion> Anyone have any info on how to solve this problem?: https://mail.haskell.org/pipermail/beginners/2015-May/015325.html
19:57:35 <dfeuer> goldfire, could you improve Haddock to allow that more generally?
19:57:50 <dfeuer> i.e., to allow links to non-imported entities?
19:57:58 <mjrosenb> dmj`: so foo :: Bool -> (Int, String), how do I set name and age with the return value of foo?
19:58:15 <goldfire> dfeuer: That doesn't work, I think — the names are ambiguous without the imports. 
19:58:36 <goldfire> Requiring the import to forge the link is fine... I just don't want warnings when compiling for real.
19:58:37 <dfeuer> goldfire, not if they're fully qualified, for some value of fully qualified.
19:58:38 <enthropy> goldfire: you can CPP (haddock defines some HADDOCK macro I think)
20:00:12 <goldfire> enthropy: thanks. That's what I was looking for. Will try.
20:00:51 <dmj`> orion: in general throwing exceptions to drive application flow is a bad idea, the reason throw isn't called is because that function is pure and IO drives evaluation, can your provide the greater context of the web handler you're using it in
20:01:09 <enthropy> goldfire: seems like you might run into https://github.com/haskell/cabal/issues/1237
20:01:25 <goldfire> enthropy: Well, the macro isn't HADDOCK, at least: #ifdef HADDOCK didn't do it, IIRC.
20:01:27 <orion> dmj`: This is the exceptional case when a malformed HTTP request is received.
20:01:43 <enthropy> yes it seems to be __HADDOCK__
20:01:56 <dmj`> orion: then I would return a 400 response code immediately, no need to throw an exception.
20:03:04 <dmj`> orion: if you use `finishWith` in snap or `halt` in wai, it will prematurely exit the handler, so you could do something like, when (headerNotFoudn request) $ finishWith 500 (encode errorBody)
20:03:19 <dmj`> s/500/400
20:03:36 <Fuuzetsu> dfeuer: there's a ticket about improving it
20:03:40 <Fuuzetsu> but I don't really want to allow it
20:03:48 <dfeuer> Why not?
20:03:52 <goldfire> enthropy: It does seem to be __HADDOCK__ from that ticket, but that's not working :(
20:03:53 <dmj`> mjrosenb: you can't since that's a tuple, the record wild cards extension only works on... records.
20:04:04 <dmj`> mjrosenb: if you had foo :: Bool -> Person, then you could
20:04:13 <dfeuer> Fuuzetsu, what's the problem with such?
20:04:14 <Fuuzetsu> PITA and it's just guess-work in the end…
20:04:27 <Fuuzetsu> but I don't know, it might be worthwhile
20:04:35 <Fuuzetsu> I haven't found the demand to be great enough yet
20:04:37 <dfeuer> Fuuzetsu, how is a fully qualified name guessy?
20:04:56 <goldfire> Ah. It's __HADDOCK_VERSION__
20:05:38 <goldfire> But I still get a warning during haddocking about a redundant import. :(
20:05:47 <goldfire> At least my link is there now.
20:05:59 <orion> dmj`: I can't seem to find any documentation for a halt function in the wai package.
20:06:03 <goldfire> I suppose I can disable the redundant-import check during haddocking.
20:06:05 <Fuuzetsu> dfeuer: case I was referring to was cross package
20:06:31 <mjrosenb> dmj`: right. I think I don't want foo to return a full record, since it is only supposed to calculate two fields of the whole record, so this extension isn't really looking useful?
20:06:34 <dfeuer> Fuuzetsu, right, so how about package:Module.binding?
20:09:07 <dmj`> mjrosenb: I don't understand enough of what you're trying to accomplish so it's difficult for me to say
20:09:11 <dmj`> orion: let me check
20:11:05 <mjrosenb> dmj`: I have a constructor, Widget, which has 10 fields, and a function that computes two fields, visibility and substantiality. I want a way to set these two fields by calling the function, preferably, without destructuring the return value of the function (the tuple returning function can be changed though)
20:11:36 <dmj`> mjrosenb: can you paste your code
20:11:48 <dmj`> mjrosenb: http://lpaste.net
20:15:02 <riaqn> hello, can anyone suggest some readings/books on pure type systems?
20:15:09 <mjrosenb> dmj`: my code is kind of large, and spread throughout a few modules, but I'll try.
20:16:18 <riaqn> and dependent types/curry-howard-isomorphism, etc.
20:16:57 <mjrosenb> dmj`:  https://gist.github.com/15344349eb352f7d3317
20:18:10 <mjrosenb> dmj`: and (vis, subst) is the tuple pattern that I'd prefer to have inline.
20:21:14 <dmj`> orion: well, even if there's not earlyTermination built in, you can still siwtch on it "bool handleNoHeader handleHeader (headerExists request)"
20:21:23 <dmj`> orion: for snap there is, it's finishWith
20:24:38 <dmj`> mjrosenb: RWC doesn't look like a good candidate for that snippet, since you're setting two fields directly
20:24:50 <orion> dmj`: That seems to suggest that I'm going to have a huge set of nested functions, one for every single check I need to make on the incoming data.
20:25:43 <dmj`> orion: are you using pure Wai?
20:25:59 <orion> dmj`: Yes.
20:26:18 <orion> Well, wai+warp.
20:28:52 <dmj`> orion: I'd wrap your application in an EitherT, and when that condition is met, call `left`
20:29:35 <dmj`> orion: then after the handler has run, set the response code based on the Either type, and the response Body based on the Either value
20:33:00 <orion> dmj`: When you say, "that condition", you mean *any* problem, correct?
20:33:30 <dmj`> orion: yea, it could be, DB problem, Request problem, sure
20:38:22 <orion> dmj`: When you say, "your application", do you mean the function which returns a Network.Wai.Application?
20:40:43 <dmj`> orion: yea, you should wrap each request in a monad stack, then when a new thread comes in run the stack
20:41:06 <orion> I see.
20:41:14 <orion> I never considered doing it that way.
20:42:39 <dmj`> orion: this way suppose you have an EitherT ApplicationErrorType (ReaderT (ApplicationConfiguration, Request) IO) a 
20:44:06 <Cale> I'd probably just use  ApplicationConfiguration -> Request -> IO (Either ApplicationErrorType a)
20:44:16 <dmj`> do { request <- snd <$> ask; if (headerDoesntExist request) then left BadHeaders else return200 } 
20:44:47 <orion> type Application = Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived
20:46:08 <orion> I don't think WAI wants it any other way.
20:46:35 <dmj`> orion: do you have database backends?
20:47:13 <orion> dmj`: No.
20:47:30 <dmj`> orion: well then yea, no need I suppose. 
20:47:36 <kadoban> dmj`: pong
20:47:45 <dmj`> orion: monad-control is a nice-to-have if you do
20:48:00 <orion> dmj`: However, I do need to publish a message to RabbitMQ, wait for a response, decode it, and formulate the HTTP response.
20:48:05 <dmj`> kadoban: hey ! have you used teasers in hakyll
20:48:14 <orion> There's a lot of things that can go wrong along the way.
20:48:17 <kadoban> dmj`: Oh, yeah I think I'm using them. Having trouble?
20:48:29 * hackagebot mockery 0.2.0 - Support functions for automated testing  http://hackage.haskell.org/package/mockery-0.2.0 (SimonHengel)
20:48:35 <dmj`> kadoban: yea :/
20:49:18 <kadoban> dmj`: Let me see if I can find what part(s) do that, haha.
20:49:49 <dmj`> k :)
20:49:59 <dmj`> kadoban: it's been copy paste for 2 hours w/ no luck
20:50:02 <dmj`> pasta*
20:51:17 <kadoban> dmj`: I don't see anything in the compilation that I'm doing differently, I think it's just in the content I do … hmm, let me lpaste stuff.
20:51:36 <dmj`> orion: I like using monad-control because you can fork threads while retaining the base context, so if you have connections pools in a reader, you can call 'fork' which puts you in a new thread which lets you get at the pools, whereas forkIO escapes you into IO, and you have to ref. the pools from a closure, or pass them in as a paremeter.
20:51:54 <dmj`> kadoban: I keep getting "[ERROR] Missing field $teaser$ in context for item posts/2015-05-20-" ...
20:53:06 <orion> dmj`: I see.
20:53:35 <kadoban> dmj`: So the first bit is my templates/blog.html   and then the second bit is an example blog post, so that's some_blog_post.markdown
20:53:41 <kadoban> dmj`: http://lpaste.net/3491933725908795392
20:53:48 <dmj`> orion: some say transformer stacks slow you down, I say the database is always the bottleneck :)
20:54:08 <orion> dmj`: My server looks something like this: http://www.yesodweb.com/book/json-web-service
20:54:58 <dmj`> kadoban: that's what I have ! can you show me your site.js where you make the teaser context
20:55:01 <dmj`> site.hs*
20:55:17 <kadoban> Yeah, sec.
20:56:57 <kadoban> dmj`: Annotated again. That last bit is probably the part you're missing, the postContext thing
20:56:59 <wepy> oi
20:57:24 <kadoban> dmj`: The top bits are obviously out of context, I cut off the top and such.
20:58:56 <dmj`> kadoban: let me try this out
20:59:02 <kadoban> dmj`: Oh, sub  defaultContext for 'myContext'
20:59:59 <orion> dmj`: Based on the URL I sent you, am I correct in saying that your recommendation is to add an extra function, say, "processRequest", whose type is Request -> EitherT ApplicationException IO Response ?
21:00:49 <dmj`> I think Cale's recommendation was a good one
21:00:53 <dmj`> ApplicationConfiguration -> Request -> IO (Either ApplicationErrorType a)
21:01:06 <dmj`> orion: if you don't have a db EitherT might be overkill
21:01:27 <orion> hmm, I see.
21:01:54 <dmj`> well, I mean, they're roughly equivalent, EitherT ErrorType IO a .. IO (Either ErrorType a)
21:02:28 <orion> I didn't realize that EitherT would add that much overhead.
21:03:26 <dmj`> orion: it probably won't, if you do use EitherT though, it will work nicely with other transformers from mtl, since mtl provides typeclasses that do a lot of heavy lifting for you, pun intended
21:03:30 * hackagebot opentheory-primitive 1.3 - Haskell primitives used by OpenTheory packages  http://hackage.haskell.org/package/opentheory-primitive-1.3 (JoeHurd)
21:03:52 <dmj`> orion: so if down the road you felt the need for some global pure state, you can plop in a ReaderT into your stack
21:04:12 <dfeuer> Does anyone know why Conor McBride calls himself "pigworker"?
21:04:58 <kadoban> Because "highlander" was taken, and there can be only one?
21:05:22 <orion> dmj`: So, Cale's suggestion was to create a function whose type is ApplicationConfiguration -> Request -> IO (Either ApplicationErrorType a) and call *that* from my "real" application function whose type is ... -> Application, right?
21:05:42 <orion> Where "Application" is Network.Wai.Application
21:06:28 <Cale> I dunno, I just saw a nonsense bunch of monad transformers and got rid of them :P
21:06:45 <dmj`> :) 
21:07:14 <dmj`> Cale: do you like functions with a lot of parameters
21:07:43 <Cale> There is a time and a place for monad transformers. Inside application code is not it. Ideally you don't want anyone to know that you're using monad transformers from outside of the module in which you write a library.
21:08:28 <Cale> and that library is going to expose enough stuff that you basically don't have to lift anything further
21:08:30 * hackagebot opentheory 1.195 - The standard theory library  http://hackage.haskell.org/package/opentheory-1.195 (JoeHurd)
21:08:32 * hackagebot opentheory-stream 1.42 - Infinite stream types  http://hackage.haskell.org/package/opentheory-stream-1.42 (JoeHurd)
21:08:34 * hackagebot opentheory-probability 1.46 - Probability  http://hackage.haskell.org/package/opentheory-probability-1.46 (JoeHurd)
21:08:36 * hackagebot opentheory-bits 1.63 - Natural number to bit-list conversions  http://hackage.haskell.org/package/opentheory-bits-1.63 (JoeHurd)
21:08:38 * hackagebot opentheory-divides 1.55 - The divides relation on natural numbers  http://hackage.haskell.org/package/opentheory-divides-1.55 (JoeHurd)
21:09:11 <Cale> dmj`: Functions with a lot of parameters might be a sign that you need a better data type which bundles some of them together in some logical fashion.
21:09:41 <Cale> ReaderT doesn't solve anything with regard to that. Having to liftIO everywhere is not better than passing a parameter around.
21:09:55 <dmj`> Cale: sure I can see that, I think he's created an application though, not a library. Suppose he does package up all his connection pools into a single data type, if he has web 50 handlers, passing that data type into each handler gets old
21:10:26 <Cale> I don't think it should be too bad
21:11:55 <dmj`> Cale: It really is though (at least for me), right now I have 112 tests, all of which have to pass the connection pool data type into as a parameter, there's so many you have to spread them out over many modules, the redundancy feels like code smell to me
21:12:05 <Pamelloes> Is it normal when compiling GHC to get to stage 1 within 10 minutes but then take hours to get to stage 2?
21:12:15 <thomaseding> I didnt see any on hackage (I may have missed it), but are there FRP libraries that are IO-less?
21:12:36 <Cale> thomaseding: Reflex
21:12:43 <Pamelloes> ^
21:13:01 <jle`> it depends on what sort of domain/application you're looking at, too
21:13:40 * hackagebot opentheory-byte 1.123 - Bytes  http://hackage.haskell.org/package/opentheory-byte-1.123 (JoeHurd)
21:13:42 * hackagebot opentheory-parser 1.155 - Stream parsers  http://hackage.haskell.org/package/opentheory-parser-1.155 (JoeHurd)
21:13:44 * hackagebot opentheory-unicode 1.137 - Unicode characters  http://hackage.haskell.org/package/opentheory-unicode-1.137 (JoeHurd)
21:13:46 * hackagebot opentheory-prime 1.79 - Prime natural numbers  http://hackage.haskell.org/package/opentheory-prime-1.79 (JoeHurd)
21:13:48 * hackagebot api-opentheory-unicode 1.0 - OpenTheory unicode character API  http://hackage.haskell.org/package/api-opentheory-unicode-1.0 (JoeHurd)
21:13:51 <thomaseding> I'm creating a game engine library for the hearthstone card game. I want to consider using frp for propogating effects to cards
21:14:25 <pharpend> Alright, HIndent is taking about 30 seconds to pretty-print my function. I'm thinking I should think about refactoring
21:18:02 <dmj`> kadoban: still no dice.. :/ http://lpaste.net/132430
21:18:50 * hackagebot decode-utf8 1.0 - Decode a UTF-8 byte stream on standard input  http://hackage.haskell.org/package/decode-utf8-1.0 (JoeHurd)
21:18:52 * hackagebot nth-prime 1.0 - Computing the nth prime  http://hackage.haskell.org/package/nth-prime-1.0 (JoeHurd)
21:18:54 * hackagebot hspec-contrib 0.2.2 - Contributed functionality for Hspec  http://hackage.haskell.org/package/hspec-contrib-0.2.2 (SimonHengel)
21:18:56 * hackagebot fen2s 1.0 - Converting a chess position from FEN notation to text  http://hackage.haskell.org/package/fen2s-1.0 (JoeHurd)
21:19:19 <orion> Cale: In general, how do you control walking indentation when you're using Either?
21:19:56 <dmj`> kadoban: I am making a snapshot of the content too
21:20:01 <johnw> you could use the Either monad in do-notation
21:20:38 <kadoban> dmj`: I can't imagine why it would matter, but … that do notation on the one context isn't actually doing anything.
21:20:49 <pharpend> orion: can you give an example
21:20:54 <kadoban> dmj`: Or maybe it is … neverminde
21:20:58 <Cale> It's possible to use Either as a monad, but usually things aren't so uniform. Usually if things get heavily nested, I just pull them out into new definitions.
21:21:19 <dmj`> kadoban: it probably isn't, it's redundant, I use do in hackier ways than that though
21:21:51 <kadoban> dmj`: Where's your compiler or whatever for posts?
21:21:51 <Cale> orion: Sometimes pattern guards are nice
21:22:37 <kadoban> dmj`: Note that I usually make the teaser bit optional … are you just forgetting to add <!--more--> to one of your posts maybe?
21:23:11 <dmj`> kadoban: I only have one post, and the <!--more--> is there
21:23:14 <orion> pharpend: I need to check a ton of conditions before I can return a response to the user. Each condition creates indentation.
21:23:25 <pharpend> orion: try HIndent
21:23:39 <pharpend> orion: https://github.com/chrisdone/hindent/
21:23:44 <dmj`> kadoban: not sure why the optional would change it
21:23:48 <dmj`> I'll try though
21:23:58 <pharpend> orion: not sure if that's what you mean
21:24:01 <Cale> pharpend: I think orion is complaining about the manner in which case expressions get nested, not how to prettyprint the code :)
21:24:06 <kadoban> dmj`: Shot in the dark, but try more boring text right before the teaser thing maybe. Well, optional would just make it not crash when you leave it out. It's better in general, but it won't fix it not working.
21:24:12 <orion> Cale: indeed
21:24:24 <kadoban> dmj`: Like throw in a normal paragraph before the <!--more--> maybe?
21:24:25 <Cale> orion: Try pattern guards maybe.
21:24:34 <kadoban> dmj`: Also, make sure you ./site clean and try?
21:25:45 <dmj`> kadoban: yea I run cabal clean && cabal build && dist/build/site/site clean && dist/build/site/site watch
21:27:08 <dmj`> kadoban: still nothing, this is killing me
21:27:16 <dmj`> kadoban: can I show you the full source
21:27:39 <kadoban> dmj`: Ya sure
21:34:58 <dmj`> kadoban: I msg'd you, I don't want others to see my poor hakyll skills
21:35:42 <dmj`> Welkin: can you join blah
21:35:54 <kadoban> Haha, sure
21:37:49 <kadoban> dmj`: Btw, <> is just a synonym for mappend. Using both looks weird XD
21:38:06 <dmj`> kadoban: yea, I like <> better, but hakyll uses old school infix mappend
21:38:08 <johnw> kadoban: unless you use Data.Semigroup :)
21:38:56 <kadoban> dmj`: It looks like in your archive.html you're using the posts, but aren't using a context with the teaser?
21:39:19 <dmj`> kadoban: hmmmmmmm
21:39:23 <kadoban> Or wait … that's the context for the other bit.
21:40:16 <kadoban> dmj`: Oh, yeah no I was right the first time. postCtx doesn't have the teaser, and you're using that in the listField bit.
21:41:46 <kadoban> dmj`: Also in the tagRules bit. I don't think that teaser thing there is doing the right thing. It should be in postCtx itself I believe probably.
21:42:07 <kadoban> dmj`: (Like line 28 … I don't think that's doing anything)
21:42:17 <kadoban> Granted, I don't use tags so I don't know exactly how that works, but …
21:46:34 <kadoban> dmj`: In general you should try to have as few different contexts as you can … so I wouldn't bother having separate ones for teasers and not, for instance. maybe you need a separate one for the tags, I dunno … but the other bits can be combined.
21:53:31 * hackagebot tagged-binary 0.2.0.0 - Provides tools for serializing data tagged with type  information.  http://hackage.haskell.org/package/tagged-binary-0.2.0.0 (jle)
21:58:35 * hackagebot BlogLiterately 0.7.1.10 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.7.1.10 (BrentYorgey)
22:00:10 <dmj`> kadoban: I added the teaser part
22:00:15 <dmj`> kadoban: to archive, but still not dice
22:00:17 <dmj`> no*
22:01:59 <kadoban> dmj`: The other one too?
22:02:21 <dmj`> kadoban: removing the teaser part from the tag context?
22:02:25 <dmj`> er, from the tag portion
22:02:48 <kadoban> dmj`: Both are missing it. The one has it in an incorrect place, but … isn't doing anything.
22:03:30 <kadoban> dmj`: It needs to be in the listField part. postCtx either needs to be changed to have the teaserField, or you need to manually add it there (postCtx <> teaserField …)
22:04:32 <dmj`> kadoban: Got it!
22:06:26 <kadoban> (The way it was, you were saying there was a teaser for the actual tag … page or whatever that is, not on each post.
22:08:04 <dmj`> kadoban: this is weird, I think the error was the I wasn't using the $if(tags)$, but was just using $tags$
22:08:20 <dmj`> kadoban: for archive.html, I don't even need a teaser context
22:08:31 <dmj`> kadoban: I think that's because archive is just calling out to post-list.html
22:08:36 * hackagebot ghcjs-websockets 0.3.0.2 - GHCJS interface for the Javascript Websocket API  http://hackage.haskell.org/package/ghcjs-websockets-0.3.0.2 (jle)
22:08:38 * hackagebot MonadRandom 0.4 - Random-number generation monad.  http://hackage.haskell.org/package/MonadRandom-0.4 (BrentYorgey)
22:09:31 <kadoban> dmj`: Hmm, well as long as it's working I guess.
22:10:47 <dmj`> kadoban: when I removed this line, it worked... it looks like you can't reference a context variable twice in the template
22:10:52 <dmj`> kadoban: https://github.com/dmjio/dmjio/blob/master/templates/post-list.html#L24
22:11:29 <dmj`> kadoban: the mysteries of static site generators continue
22:12:20 <dmj`> kadoban: thanks for all your help, huge
22:13:35 <kadoban> dmj`: That's … really weird. I know I use some /several/ times in some of my templates. Well, glad it's working, you're welcome.
22:15:30 <dmj`> kadoban: in my git status, that's the only change... it's strange
22:16:02 <dmj`> kadoban: maybe it's teaser specific
23:03:45 * hackagebot witherable 0.1.3 - Generalization of filter and catMaybes  http://hackage.haskell.org/package/witherable-0.1.3 (FumiakiKinoshita)
23:07:18 <lpaste> echo-area pasted “Typeclassopedia 3-3-1” at http://lpaste.net/132440
23:07:44 <echo-area> This is my answer to that question, but I don't feel good about this one.  What's your answer?  Thanks
23:09:53 <jle`> echo-area: it's a good answer :)
23:10:02 <jle`> fmap f _ = [] is another one people use
23:11:46 <echo-area> jle`: Ah okay, thank you :)
23:18:45 * hackagebot schedule-planner 0.1.0.0 - Find the ideal lesson layout  http://hackage.haskell.org/package/schedule-planner-0.1.0.0 (justus)
23:32:37 <Veyn> What's a lens and why is it useful?
23:33:04 <idnar> @pl 
23:33:04 <lambdabot> (line 1, column 1):
23:33:04 <lambdabot> unexpected end of input
23:33:04 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
23:33:05 <idnar> err
23:33:19 <idnar> @pl \a -> concatMap ($ a)
23:33:19 <lambdabot> (=<<) . flip id
23:34:06 <pacak> Veyn: First class accessors
23:34:34 <pacak> > over _1 (+1) (100, 200)
23:34:36 <lambdabot>  (101,200)
23:34:52 <pacak> :t _
23:34:53 <lambdabot>     Found hole ‘_’ with type: t
23:34:54 <lambdabot>     Where: ‘t’ is a rigid type variable bound by
23:34:54 <lambdabot>                the inferred type of it :: t at Top level
23:34:55 <pacak> :t _1
23:34:56 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
23:35:31 <idnar> @pl \a -> concatMap (map a)
23:35:31 <lambdabot> (=<<) . map
23:35:46 <idnar> @pl \a -> concatMap (`map` a)
23:35:46 <lambdabot> (=<<) . flip map
23:35:54 <idnar> :type \a -> concatMap (`map` a)
23:36:02 <idnar> :t \a -> concatMap (`map` a)
23:36:03 <lambdabot> Foldable t => [a] -> t (a -> b) -> [b]
23:36:18 <idnar> err, sorry for the noise
23:37:01 <aidanh> Anyone mind giving feedback on this implementation of split? http://sprunge.us/gDVX?hs
23:37:04 <idnar> the @pl version of that is kinda rubbish, is there a nicer way of writing that?
23:37:21 <Veyn> I keep hearing hoopla about the Lens library, I don't know where/why it's useful.
23:38:05 <arkeet> :t (=<<) . fmap
23:38:06 <lambdabot> Monad m => (a -> b) -> m (m a) -> m b
23:38:29 <liste> aidanh how about "split [] 5" ?
23:38:37 <pacak> aidanh: Recursive function, will eat stack
23:39:03 <dmj`> @src splitAt
23:39:03 <lambdabot> splitAt n xs = (take n xs, drop n xs)
23:39:03 <Veyn> munch munch munch
23:39:12 <arkeet> but @src lies
23:39:42 <dmj`> @def splitAt2 n xs = (take n xs, drop n xs)
23:39:44 <lambdabot>  Defined.
23:39:51 <dmj`> > splitAt2 5 [1..10]
23:39:52 <lambdabot>  ([1,2,3,4,5],[6,7,8,9,10])
23:41:24 <aidanh> liste: It seems the obvious correction there is to use Maybe
23:41:25 <dmj`> Veyn: lens is really nice if you have large data structures you need to traverse, like complex json objects. It's also nice if you have many nested records that need updating, since haskell's record updating facilities really break down once you start nesting 
23:41:47 <dmj`> Veyn: and probably for a million other reasons 
23:41:56 <idnar> :t (=<<) . flip fmap
23:41:57 <lambdabot> Monad m => m a -> m (a -> b) -> m b
23:42:21 <aidanh> pacak: So an implementation with foldl` would be better?
23:42:23 <idnar> oh, that's just flip (<*>) isn't it?
23:42:51 <pacak> aidanh: Tail recursive implementation
23:42:53 <idnar> > [x, y, z] <*> [f, g, h]
23:42:55 <lambdabot>      Couldn't match expected type ‘a0 -> b’ with actual type ‘Expr’
23:42:55 <lambdabot>      In the expression: x
23:42:55 <lambdabot>      In the first argument of ‘(<*>)’, namely ‘[x, y, z]’    Couldn't match e...
23:43:01 <arkeet> idnar: not quite
23:43:48 <arkeet> @unpl (=<<) . flip fmap
23:43:48 <lambdabot> (\ f i -> i >>= \ c -> fmap c f)
23:44:16 <arkeet> oh maybe it is, yeah.
23:44:23 <aidanh> pacak: Alright, I'll try that
23:44:29 <arkeet> no wait.
23:44:41 <arkeet> yeah it is.
23:44:55 <arkeet> just confuse because there's a difference between flip (<*>) and (<**>)
23:44:57 <arkeet> :t (<**>)
23:44:58 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
23:45:16 <idnar> > [10, 100] <**> [(+5), (*2)]
23:45:18 <lambdabot>  [15,20,105,200]
23:45:45 <idnar> > [(+5), (*2)] <*> [10, 100]
23:45:46 <lambdabot>  [15,105,20,200]
23:46:02 <arkeet> <**> still runs the actions left to right
23:46:21 <idnar> I see
23:46:33 <arkeet> so uh
23:46:38 <arkeet> flip (<*>) = filp (liftA2 ($))
23:46:44 <arkeet> (<**>) = liftA2 (flip ($))
23:46:49 <arkeet> if that helps any
23:47:17 <idnar> in this case, I think that difference doesn't matter for my purposes, but I think <*> reads better
23:48:57 <idnar> (the order of actions matters, but it doesn't matter which way they're interleaved)
23:50:32 <echo-area> :t over
23:50:33 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
23:58:35 <Veyn> :t (<$>)
23:58:36 <lambdabot> Functor f => (a -> b) -> f a -> f b
