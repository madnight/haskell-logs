00:01:32 <lcfrs> anyone know how i can delete bad versions of a package i maintain from hackage?
00:04:11 <jle`> lcfrs: you can mark them as deprecated so cabal will actively avoid downloading them
00:04:27 <jle`> and choose earlier or later versions if possible
00:07:07 <lcfrs> thanks jle`
00:07:40 * hackagebot sorted-list 0.1.2.1 - Type-enforced sorted lists and related functions.  http://hackage.haskell.org/package/sorted-list-0.1.2.1 (DanielDiaz)
00:07:40 * hackagebot pg-harness 0.2.0 - REST service and library for creating/consuming temporary PostgreSQL databases  http://hackage.haskell.org/package/pg-harness-0.2.0 (BardurArantsson)
00:08:08 <lcfrs> jle`: looking at the deprecation page, i'm not sure how to do this
00:17:43 <jle`> lcfrs: sorry, it's under "Preferrred versions"
00:17:55 <jle`> http://hackage.haskell.org/package/YOURPACKAGENAME/preferred/edit
00:20:16 <lcfrs> ah thanks
00:20:21 <lokathor> welp
00:20:23 <lokathor> i'm lost again
00:21:52 <lpaste> Lokathor pasted ‚Äúwork so far‚Äù at http://lpaste.net/132260
00:23:12 <lokathor> so I think I want... buildPool :: String -> Either String (State StdGen [DiceSymbol])
00:23:41 <lokathor> that's the EitherT stuff?
00:26:40 <jle`> lokathor: that's StateT StdGen (Either String) [DiceSymbol]
00:26:58 <jle`> if you really did want to thread your state through everything in the list
00:27:46 <lokathor> yes, serveral dice are part of a single roll, and then i want to be able to repeat that many times, so it needs to keep state that whole time
00:29:13 <jle`> lokathor: yeah.  so you'd do something like runStateT (traverse (StateT . buildPool) listOfStrings) initialState
00:29:40 <jle`> and that'd give you an Either String ([DiceSymbol], StdGen)
00:30:39 <jle`> the newtype wrapper StateT is sorta just line noise.  you should read it basically like runStateT (traverse buildBool listOfStrings) intialState
00:30:55 <lokathor> well, i have just 1 string, and i want to build up a State StdGen [DiceSymbol] if it parses, and then run that through the State like 1000 times or whatever and make a list of the results
00:31:27 <jle`> actaully i think GHC can recognize that it's just a newtype trick and you can write `runStateT (traverse (coerce buildPool) listOfStrings` if that makes it look nicer/easier to read
00:31:35 <jle`> ) initialState
00:34:20 <jle`> it's there to emphasize that you're basically doing `traverse buildPool listOfStrings`, but because of how haskell works you need to do some newtype wrapping/unwrapping v.v
00:36:18 <lokathor> i think it's too late to be doing this
00:36:24 <lokathor> i wrote down "buildPool input = undefined"
00:36:27 <lokathor> and hit a brick wall
00:38:41 <jle`> actually wait, i'm wrong, you can only do that if you get it in the form of a `String -> (StdGen -> Either String ([DiceSymbol], StdGen))`.  i think at this point though the logic is all on how you want to write it :)
00:39:19 <lokathor> yeah there seemed to be a type signature mismatch
00:39:54 <lokathor> after all this
00:40:05 <lokathor> it seems like Prelude.sequence is all i really want
00:40:15 <lokathor> and i just have to layer it a bit carefully
00:40:19 <lokathor> i'll do this tomorrow
00:41:26 <jle`> Prelude.sequence and traverse here are basically identical functions
00:41:33 <jle`> so just use whatever name is less scary for you :)
00:41:37 <jle`> er sorry
00:41:42 <jle`> sequence . map f
00:42:26 <lokathor> i think i need
00:42:58 <lokathor> case sequence . map f of Left e -> Left e ; Right genList -> sequence genList
00:43:00 <lokathor> or something similar
00:43:33 <jle`> go for it :)
00:44:21 <lokathor> to borrow a phrase, i will gladly pay myself tuesday for a nap today
00:45:45 <xacktm> Hi, I have an algorithm question.  I've constructed a [(k,v)] where the mapping from k -> v is onto, but not 1-to-1.  Now I want to invert the tuple to get a [(v,[k])] for a Map (with unique v as key), but I'm not sure how to do so.
00:47:29 <Cale> xacktm: Perhaps: Map.fromListWith (++) [(v,[k]) | (k,v) <- xs]
00:48:28 <xacktm> hmm let me look into that
00:49:33 <Cale> :t M.fromListWith (++) . map (\(k,v) -> (v,[k]))
00:49:34 <lambdabot> Ord k => [(a, k)] -> M.Map k [a]
00:51:24 <xacktm> ah I see what it's doing now: you're making a singleton list [k], and when the v keys collide, then the old value and new have (++) applied to them?
00:53:30 <xacktm> nevertheless, seems like what I want.  thanks
01:02:36 * hackagebot pg-harness-client 0.3.0 - Client library for pg-harness-server  http://hackage.haskell.org/package/pg-harness-client-0.3.0 (BardurArantsson)
01:02:38 * hackagebot pg-harness-server 0.3.0 - REST service for creating temporary PostgreSQL databases  http://hackage.haskell.org/package/pg-harness-server-0.3.0 (BardurArantsson)
01:03:44 <jle`> is it really bad if i used onException to just re-try a function
01:03:50 <jle`> foo = flip onException foo $ do ...
01:04:11 <jle`> i feel like something really bad can happen
01:07:36 * hackagebot pg-harness 0.2.1 - REST service and library for creating/consuming temporary PostgreSQL databases  http://hackage.haskell.org/package/pg-harness-0.2.1 (BardurArantsson)
01:07:38 <quchen> Feels like STM with IO interleaved
01:07:52 <quchen> Bad state? Retry! Fire the missiles!
01:08:30 <jle`> i think i'm going to go with catch/handle and only on SomeAsyncException
01:08:55 <jle`> but basically foo = handle (const foo :: SomeAsyncException -> IO ()) $ do ...
01:09:08 <jle`> that seems more reasonable right...?
01:09:08 <solatis> jle`, obviously that's heresy
01:09:30 <jle`> i don't see how this would cause trouble unless foo spawned a fork that somehow killed foo's thread
01:09:36 <jle`> using throwTo
01:09:49 <jle`> but foo doesn't spawn anything so i think i'm good....
01:10:13 <jle`> someone stop me before i commit
01:10:13 <solatis> in haskell people have the tendency to try to find a perfect solution
01:10:20 <solatis> instead of a solution that Just Works
01:10:28 <jle`> this looks perfect in my eyes :3
01:10:33 <solatis> haha
01:10:39 <solatis> in that case, you get my green light ;)
01:11:54 <solatis> jle`, http://hackage.haskell.org/package/enclosed-exceptions
01:12:04 <solatis> i'm sure you're familiar with that one ?
01:12:19 <jle`> i feel like i want the opposite
01:12:46 <solatis> you want to catch no exceptions and remain unresponsive to async exceptions ?
01:13:38 <jle`> hm maybe catch no exceptions and respond to async
01:13:45 <jle`> so basically exactly the behavior i have already
01:13:56 <jle`> maybe
01:15:03 <merijn> wut...
01:15:12 <merijn> Someone compiled pandoc to JS?! What a masochist
01:16:36 <Cale> merijn: Doesn't sound like it should be too hard
01:17:00 <Cale> There might be some difficulty involved, but GHCJS is a thing now :)
01:17:09 <Cale> I compiled diagrams to JS
01:17:24 <ryantrinkle> merijn: GHCJS is surprisingly comprehensive :P
01:17:45 <ryantrinkle> merijn: reflex, for example, relies heavily on weak references, which are fully supported
01:18:07 <merijn> Cale: I know ghcjs is a thing
01:18:28 <merijn> Cale: But pandoc is huge and I have memory issues compiling some of it's dependencies for native :p
01:18:47 <pavonia> How does file handling and graphics and such work with JS?
01:19:17 <ryantrinkle> pavonia: anything that calls out to C will only work if there's a shim for the C function
01:20:05 <ryantrinkle> https://github.com/ghcjs/shims/tree/master/src
01:20:07 <pavonia> I didn't even know you can call C from JS
01:20:42 <ryantrinkle> pavonia: well, you can't - but for many C symbols, luite has implemented equivalents in JS
01:20:43 <Cale> pavonia: You can't, but you can outright replace calls to C procedures with calls to equivalent Javascript
01:20:44 <merijn> pavonia: You can't, or you can if someone made an FFI for JS
01:21:53 <pavonia> ryantrinkle: Where in that files are the I/O functions?
01:22:09 <ryantrinkle> pavonia: i'm not actually sure
01:22:18 <ryantrinkle> i haven't directly interacted with the shims library
01:22:21 <ryantrinkle> just through haskell libs
01:22:37 * hackagebot pg-harness-client 0.3.1 - Client library for pg-harness-server  http://hackage.haskell.org/package/pg-harness-client-0.3.1 (BardurArantsson)
01:22:39 * hackagebot pg-harness-server 0.3.1 - REST service for creating temporary PostgreSQL databases  http://hackage.haskell.org/package/pg-harness-server-0.3.1 (BardurArantsson)
01:22:46 <ryantrinkle> things that are really direct Unix things won't work
01:22:55 <ryantrinkle> e.g. readFile, i believe, will just throw an exception
01:22:55 <jle`> you might not be able to compile all pandoc functionality
01:23:03 <jle`> but you can compile enough to be able to render markdown
01:23:08 <ryantrinkle> yeah
01:23:16 <jle`> the markdown rendering doesn't involve any IO
01:23:22 <jle`> ...i'd hope
01:24:31 <pavonia> Ah okay, so you don't comile a full program but only parts of it
01:25:30 <jle`> well, they're using pandoc as a library here
01:25:37 <jle`> there are lots of libraries you can compile in full :)
01:25:51 <jle`> the ones with IO would work if the IO is re-implemented in javascript
01:26:25 <nak> hello peeps ^.^
01:26:51 <jle`> sup nak :D
01:27:37 * hackagebot caramia 0.7.2.2 - High-level OpenGL bindings  http://hackage.haskell.org/package/caramia-0.7.2.2 (Adeon)
01:27:40 <pavonia> jle`: That's the part I don't understand, if you don't have IO primitives in the language, how could you implement these functions?
01:28:04 <jle`> pavonia: you could implement putStrLn as console.log(), for example
01:28:20 <jle`> ghcjs implements them, not you
01:28:40 <nak> is there a real easy way to reduce/sum this list of tuples [("a",2), ("a",2), ("b", 2), ("c", 2), ("a", 2)] to [("a",6), ("b",2), ("c",2)] ?
01:28:49 <jle`> but you can also use ffi calls to implement them yourself by hand, as well
01:29:12 <Cale> :t M.toList . M.fromListWith (+)
01:29:13 <lambdabot> (Num a, Ord k) => [(k, a)] -> [(k, a)]
01:29:29 <ryantrinkle> > M.toList $ M.fromListWith (+) [("a",2), ("a",2), ("b", 2), ("c", 2), ("a", 2)]
01:29:30 <lambdabot>  [("a",6),("b",2),("c",2)]
01:29:47 <ryantrinkle> nak: note that this will also sort it, if it isn't already sorted
01:30:09 <jle`> pavonia: remember that putStrLn lives in System.IO, so all ghcjs has to do is provide its own System.IO that implements the functions in javascripty wayas
01:30:15 <nak> Cale ryantrinkle  thanks ^.^
01:30:22 <ryantrinkle> no problem :)
01:30:26 <nak> you two must be right because you agreed with each other right away !
01:30:32 <vamsi> hi, i have an issue running cabal sandbox init. Is this the right place to ask my doubt ?
01:31:05 <jle`> vamsi: most likely.  but ask your question to find out for sure :)
01:31:32 <pavonia> jle`: But something like a readFile can't be done in JS, can it?
01:31:41 <vamsi> ok thanks. 
01:31:57 <latermuse> does haskell have any libraries that can compile down to javascript webgl?
01:32:02 <ryantrinkle> nak: haha, well, i'm sure there are other ways, but Data.Map is pretty great :)
01:32:28 <ryantrinkle> pavonia: if all the underlying C functions were reimplemented, in principle it could be done
01:32:30 <vamsi> I installed ghc by going through this link and expected 7.8.4 to be the active ghc version
01:32:40 <ryantrinkle> for instance, you could model a Handle as some kind of protocol on top of HTTP
01:32:52 <ryantrinkle> with seek, read, write, etc.
01:32:56 <vamsi> but later i figured put that /usr/bin/ghc is pointing to 7.6.3 version
01:33:00 <ryantrinkle> (maybe as HTTP methods! lol)
01:33:13 <jle`> pavonia: so basically, it's not a matter of ability, but a matter of imagination :)
01:33:39 <jle`> latermuse: yes, you can write apps that run webgl i believe
01:34:05 <jle`> using ghcjs and ghcjs-webgl and other ghcjs libraries
01:34:08 <vamsi> But 7.8.4 version is installed in /opt/ghc/7.8.4/bin/
01:34:10 <pavonia> I see :)
01:34:35 <vamsi> so i pointed my usr/bin/ghc to the latest version and ran cabel sandbox init
01:34:40 <rjsalts> qw
01:34:54 <jle`> maybe you mean wq
01:35:04 <vamsi> But i am getting this error " cabal: '/usr/bin/ghc' exited with an error: ghc: missing -B<dir> option"
01:35:06 <rjsalts> sorry, cat
01:35:31 <vamsi> i am stuck here and i am clueless what to do
01:35:46 <jle`> vamsi: does it work if you added /opt/ghc/7.8.4/bin to your $PATH before /usr/bin ?
01:35:59 <jle`> there are other binaries besides just `ghc` that cabal uses, i believe
01:36:46 <jle`> not sure if that's exactly what's causing your error though
01:36:47 <vamsi> let me try changing the PATH
01:37:32 <latermuse> jle`: nice, didnt know about ghs-webgl
01:37:45 <latermuse> ghcjs-webgl that is
01:43:35 <vamsi> @jle` changing the PATH as you suggested worked ! thanks dude
01:43:36 <lambdabot>  Parse failed: TemplateHaskell is not enabled
01:43:46 <jle`> yay! np
01:47:37 * hackagebot prettyFunctionComposing 1.0.1 - prettier function composition by (∞)  http://hackage.haskell.org/package/prettyFunctionComposing-1.0.1 (Nick_Rudnick)
01:48:52 <ion> Function composition by degree sign? And the package contains a .git :-D http://hackage.haskell.org/package/prettyFunctionComposing-1.0.1/src/
01:50:48 <Squarism> I have this code that here and there manipulates (in different ways) a non simple structure. I really want functions to return "the manipulation" instead of updating state. But rather than having wide return signatures i thought this could be like a IO monad. Where update ops are sent to a monad instead of returning them in each method. Good or bad?
01:52:45 <ion> Squarism: You might find this useful: https://www.fpcomplete.com/user/edwardk/heap-of-successes
02:12:08 <latermuse> lol: 
02:12:09 <latermuse> (¬∞) = (.)
02:33:16 <test1> list
02:38:19 <solatis> what's the recommended aproach in haskell if you encounter a condition that really should never happen (like an assertion)
02:38:22 <solatis> use error () ?
02:38:55 <solatis> there appear to be so friggin' many ways to report errors in haskell
02:39:39 <Cale> That's what error is for, yes.
02:40:21 <Cale> The exceptions produced by error are extremely fiddly to ever catch, so you shouldn't use it in cases which you expect to ever occur.
02:40:34 <solatis> ok, and Control.Exception.assert is for things you want to test during development but not in production ?
02:41:08 <solatis> yeah what i want is just for the process to die and return non-0
02:41:32 <Cale> Yeah
02:49:37 <jle`> yeah, i think asserts are actually no-ops when you compile with optimiztions
03:05:50 <turtil> Hey #haskell, has anyone done the upcase haskell tuts by Thoughtbot?
03:07:06 <turtil> im wondering if they are worth looking into as a (i would think, pretty senior developer) way to learn haskell
03:12:43 * hackagebot opml-conduit 0.2.0.0 - Streaming parser/renderer for the OPML 2.0 format.  http://hackage.haskell.org/package/opml-conduit-0.2.0.0 (koral)
03:15:21 <kaidelong> never heard of these guys
03:15:39 <kaidelong> looked at their webpage
03:15:46 <kaidelong> they only seem to cover fundamentals
03:16:11 <kaidelong> you'd basically be paying for yet another Haskell tutorial
03:16:48 <kaidelong> vs the cost of a pen and paper and working things out by hand, I'm not sure it's worth it
03:17:11 <kaidelong> @turtil
03:17:11 <lambdabot> Unknown command, try @list
03:17:12 <turtil> my opinion of Thoughtbot is quite high, so i would expect high quality get the basic stuff out of the way fast etc
03:17:40 <turtil> s/quality/quality, /g
03:18:33 <kaidelong> the monads course appears to be pretty much worthless IMO
03:19:01 <turtil> ok well that was one of the things i was kinda looking forward to
03:19:04 <kaidelong> the "Replace Redirects" exercise might have something to it but the rest doesn't look compelling
03:19:19 <kaidelong> of course it's your money
03:19:26 <turtil> Ok maybe just stick with LYAH then
03:19:48 <kaidelong> there is Real World Haskell and the gentle introduction, too
03:19:52 <kaidelong> it's all outdated though
03:19:58 <turtil> secretly i was hoping someone would be like, "its amazing, it helped fast track me to becoming productive"
03:20:02 <kaidelong> the courses on fpcomplete might be more modern
03:20:12 <turtil> Ya got them bookmarked
03:20:36 <kaidelong> okay well, perhaps you could try them and tell me if they work for you
03:21:00 <kaidelong> but most of this looks like stuff that is readily available elsewhere, for free
03:22:02 <turtil> Ok then, i will keep going the way im going and if i get bored one weekend, will report back here if i found it any good
03:23:13 <latermuse> Is it possible to use attoparsec to "find all instances of a string within a string" then return a list of results while discarding everything else?
03:23:14 <kaidelong> my best advice to approaching Haskell is to evaluate and typecheck things by hand to build a "mathematical intuition"
03:23:28 <SrPx> > pure Nothing
03:23:29 <lambdabot>      No instance for (Show (f0 (Maybe a0)))
03:23:29 <lambdabot>        arising from a use of ‚Äòshow_M46875042182321775404360‚Äô
03:23:29 <lambdabot>      The type variables ‚Äòf0‚Äô, ‚Äòa0‚Äô are ambiguous
03:23:42 <SrPx> ... on GHCI this becomes Nothing. WHy?
03:23:45 <latermuse> All my tests just seem to get the first instance, then drop the rest of the results
03:24:11 <latermuse> Maybe theres a way to scan a text until attoparsec makes a match?
03:24:32 <kirill`> SrPx: GHCi has different type defaulting rules
03:25:11 <benneh> does a function like this already exist, by another name? http://lpaste.net/132261
03:25:20 <benneh> it's like foldr, but the default value changes as you go through the list
03:25:22 <bergmark> latermuse: takeTill?
03:25:51 <kirill`> SrPx: 2.4.8 in https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/interactive-evaluation.html
03:26:16 <SrPx> Yes, but why "pure [1,2] == [1,2]"? Why "pure Nothing == Nothing"? It is not what the definition of pure leads us to expect.
03:26:36 <bennofs> > pure [1,2]
03:26:37 <lambdabot>      No instance for (Show (f0 [t0]))
03:26:38 <lambdabot>        arising from a use of ‚Äòshow_M46413128165495499934568‚Äô
03:26:38 <lambdabot>      The type variables ‚Äòf0‚Äô, ‚Äòt0‚Äô are ambiguous
03:26:39 <SrPx> Not about GHCI, works on haskell too
03:26:39 <latermuse> bermark: takeTill works with (Char -> Bool). I want to be able to do something like this: takeTill :: (Parser a -> Bool) -> Parser a
03:26:51 <bennofs> > pure Nothing :: Maybe (Maybe ())
03:26:52 <lambdabot>  Just Nothing
03:27:07 <bennofs> > pure [1,2] :: [[Int]]
03:27:08 <lambdabot>  [[1,2]]
03:27:20 <Cale> SrPx: I don't believe you :)
03:27:27 <kaidelong> Cale: I just tried it
03:27:29 <kaidelong> it works
03:27:31 <SrPx> > (pure [1,2]) :: (Applicative f, Num f) => f [t]
03:27:32 <kaidelong> I'm baffled too
03:27:32 <lambdabot>      Expecting one more argument to ‚Äòf‚Äô
03:27:32 <lambdabot>      The first argument of ‚ÄòNum‚Äô should have kind ‚Äò*‚Äô,
03:27:32 <lambdabot>        but ‚Äòf‚Äô has kind ‚Äò* -> *‚Äô
03:27:35 <bennofs> SrPx: in GHCi, pure Nothing will default to pure Nothing :: IO (Maybe ()) >>= print
03:27:50 <kaidelong> bennofs: GHC is typing it as "Maybe ()" for me
03:27:53 <bennofs> since GHCi is in the IO context and always shows the result if it is showable
03:28:00 <kaidelong> GHCi*
03:28:06 <SrPx> ah... okay. Makes sense
03:28:13 <kaidelong> oh
03:28:15 <Cale> ah, yeah
03:28:17 <kaidelong> now I understand
03:28:41 <bennofs> you can see it if you :set -ddump-simpl (quite verbose though)
03:28:49 <kaidelong> defaulting to IO, it becomes the bound value
03:30:12 <bennofs> Another way to observe this would be: :m + Debug.Trace Data.Typable   let traceRetType a = traceShow (typeOf a) a
03:30:25 <bennofs> and then: > traceRetType (pure Nothing) will print IO (Maybe ())
03:40:05 <lpaste> latermuse pasted ‚ÄúParsing woes‚Äù at http://lpaste.net/132262
03:40:21 <latermuse> Can someone help me with this parsing problem im having?
03:40:31 <latermuse> It works well in my mind, not sure why its not working in the script.
03:41:34 <pacak> latermuse: Any explosions? Did you created a rouge AI which now tries to conquer our planet?
03:42:06 <latermuse> pacak: No explosions have been noted.
03:42:15 <pacak> That's always nice at least :)
03:42:43 <pacak> Your program expects to see either "a" or "c" which works for the first character.
03:43:09 <pacak> But the next one is ' ' so parser fails and returns as much as it can parse.
03:43:20 <latermuse> pacak: Yes. Is there any way to consume the intermediate data until it finds another "a" or "c"?
03:43:34 <pacak> :t sepBy
03:43:35 <lambdabot> Eq a => [a] -> [a] -> [[a]]
03:43:39 <pacak> o_O
03:44:46 <pacak> p = parseTest <|> drop 1 *> p
03:44:50 <pacak> Something like that
03:45:09 <latermuse> and if the intermediate data is anything and any length?
03:45:22 <latermuse> "a a kjfhsdf a a" should return ["a","a","a","a"]
03:45:49 <latermuse> This is easily accomplished with regex, but I really want to try and get it to work with attoparsec
03:46:07 <pacak> parseTest -- parse one
03:46:07 <pacak> <|> -- or
03:46:07 <pacak> drop 1 -- drop one character
03:46:07 <pacak> *> p -- and try again
03:46:40 <latermuse> oh! neat. Ill try that
03:47:22 <pacak> Also you don't really need those returns
03:48:09 <latermuse> Ah yeah. I was using the return pattern in my full script. This is just a condensed version for lpaste
03:48:22 <latermuse> And didnt refactor them out
03:49:06 <latermuse> thanks for the help pacak. Ill use the <|> and *> operators to figure out how to do it :)
03:50:07 <rotten_bunny> hey people 
03:50:31 <pacak> Hey bunny!
03:51:23 <rotten_bunny> stumbled across haskell and would like to know more 
03:51:43 <latermuse> what do you want to know?
03:52:17 <pacak> rotten_bunny: There is a nice book at learnyouahaskell.com
03:52:36 <rotten_bunny> thanks
03:53:18 <rotten_bunny> sorry if i sound offish, but ya it happens when your car gets stolen from you in a corrupt and messed up country like mine 
03:53:47 <rotten_bunny> i am also busy setting up and tweaking my Kali Rig 
04:04:08 <latermuse> rotten_bunny: what is kali rig?
04:10:22 <Cale> rotten_bunny: http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html is also a pretty good course, from what I've heard
04:12:58 <ttt_fff> I am writing haskell code.
04:13:09 <ttt_fff> I find that when I hit around 4K lines of code, I can't push the code any futher
04:13:26 <ttt_fff> since haskell code = highly terse, and at the 4K LOC range, I am not smart enough to write more code productively
04:13:30 <ttt_fff> how do I break this barrier?
04:13:51 <merijn> ttt_fff: Isn't it just a problem with not enough modularity?
04:14:09 <ttt_fff> merijn: I don't know, it's like writing in haskell = start out sprinting, then at 4k I'm like running in quick sand
04:14:10 <pacak> ttt_fff: use longer lines. Longest one I saw was about 800-900 characters.
04:14:23 <merijn> pacak: >.>
04:14:24 <ttt_fff> merijn: I have lots of modules, separte *.hs files
04:14:31 <ttt_fff> merijn: and most files are <= 100 LOC
04:14:37 <merijn> ttt_fff: Lots of modules is not the same as modular :)
04:14:51 <ttt_fff> merijn: yeah, I agree, I'm doing something wrong
04:14:54 <ttt_fff> I'm just not sure what
04:15:12 <merijn> ttt_fff: I don't really understand the link between "not smart enough" after 4k LOC
04:15:14 <fr33domlover> hello! I'd like to generate UUIDs in a library, and the function is: nextRandom :: IO UUID. Does it mean everything using it "stuck" in the IO monad, and has to have all the types updated to be in IO?
04:15:22 <merijn> Why does it become more complex as the LOC increases?
04:15:30 <pacak> ttt_fff: The guy was from India and that line could be replaced with "deriving (Show)", or deriving (Show, Eq) if you want to remove next biggest line in his code (guess which one).
04:15:44 <ttt_fff> merijn: it so happens that with most (N = 5) haskell pojects I write, up until around 4K LOC I porogress very fast; then around 4K LOC, I slow down quite a bit
04:16:08 <merijn> fr33domlover: No, just make your library "foo :: UUID -> Foo" "fmap foo nextRandom :: IO Foo"?
04:16:30 <merijn> ttt_fff: Hard to give any actionable tips without knowing what slows you down/what confuses you
04:17:01 <ttt_fff> merijn: you could write a book on "design + implementation of large scale haskell projects"
04:17:10 <ttt_fff> merijn: you could write a book on "design + implementation of large scale haskell projects: merijn's modularity approach"
04:17:36 <fr33domlover> merijn, that's still remains in IO. but ok, I need to just write it, experiment and learn :p
04:17:37 <rotten_bunny> thank you Cale 
04:17:44 <barrucadu> fr33domlover: The UUID type is an instance of Random, so if you don't want users of your library to necessarily involve IO, you could pass in a RandomGen
04:17:46 <merijn> If I could teach my own understanding of modularity I'd be doing consulting for prices that'd let me visit the bahama's every weekend ;)
04:17:48 <barrucadu> https://hackage.haskell.org/package/random-1.1/docs/System-Random.html#t:Random
04:18:30 <ttt_fff> merijn: what is the most impressive haskell project you yourself have written?
04:18:38 <pacak> ttt_fff: Is any of those project available online?
04:19:15 <Cale> fr33domlover: foo wouldn't be in IO
04:19:40 <merijn> ttt_fff: I mostly write tiny tools/libraries for my own stuff, but I don't see how haskell woudld be more difficult than, say C++. Actually haskell would be much easier to keep modular than C++
04:19:52 <ttt_fff> pacak: unfortunately, no
04:21:22 <fr33domlover> Cale, I have a function creates a random identifier, and it supposed to encapsulate the fact it uses UUIDs for that
04:21:35 <fr33domlover> the RandomGen idea could help, I'm reading about it
04:21:49 <fr33domlover> (my first encounter with Random)
04:23:15 <cellopin> hi I have a No parameters for class `Human' error. Im not sure what I missed though. http://lpaste.net/132264
04:24:08 <mikeplus64> hm, what module should I get the Constraint kind from? GHC.Base? (that seems... overkill)
04:24:10 <jle`> cellopin: do you know what a typeclass is?
04:24:38 <jle`> instance Eq a where
04:24:46 <jle`>   (==) :: a -> a -> Bool
04:24:50 <Cale> uh, class
04:24:54 <jle`>   (/=) :: a -> a -> Bool
04:24:58 <Cale> not instance
04:24:59 <jle`> yeah, class, sorry v.v
04:25:11 <jle`> cellopin: what does the 'a' mean there?
04:25:21 <jle`> class Eq a where ....
04:25:36 <cellopin> any type?
04:26:06 <cellopin> Eq can have any type?
04:26:09 <kaidelong> typeclasses constrain types, so you want at least "class Human t"
04:26:30 <jle`> when you write instance Eq Bool where ..., it means that Bool is your Eq
04:26:33 <kaidelong> and you probably want talk to be t -> String otherwise it'll be hard to figure out which talk to use
04:26:42 <jle`> instance Eq String where ..., it means String is your Eq
04:27:16 <SrPx> I think there is something wrong with "ix"'s instance for Tree. Look at this: http://lpaste.net/132265
04:27:17 <kaidelong> so talk x = "garble"
04:27:23 <jle`> you probably want "class Human t where".  with a parameter
04:28:10 <kaidelong> I don't know if talk :: String is even a legal method
04:28:27 <SrPx> nevermind, moving that for Lens. Also, ixed*
04:28:43 <cellopin> okay.. I'm confused now as to what the 'parameter' is
04:29:00 <jle`> class Eq a where
04:29:04 <jle`>   (==) :: a -> a -> Bool
04:29:15 <jle`> it means, "if a is an instance of Eq, there is a function a -> a -> Bool"
04:29:29 <jle`> so, if String is an instance of Eq, it means that there is a function String -> String -> Bool
04:29:41 <jle`> if Int is an instance of Eq, it means that there is a function (==) :: Int -> Int -> Bool
04:29:55 <jle`> if Double is an instance of Eq, it means that there is a function (==) :: Double -> Double -> Bool
04:30:06 <jle`> the `a` is what you "plug into" the type signature of (==)
04:30:44 <jle`> it's the actual thing that is the instance
04:30:58 <cellopin> okay.. then I want to try Human Person.. so I'll declare something like "class Human a "right?
04:31:05 <jle`> yeah
04:31:14 <jle`> that means that your `a` is the instance of Human
04:32:32 <kaidelong> there's still the problem that "talk" as you defined it cannot really work
04:32:47 <cellopin> yeah.. I'm having that error
04:33:21 <cellopin>  The class method `talk' mentions none of the type variables of the class Human a
04:34:07 <jle`> yeah, if you ever write `talk`, how will it know which `talk` to use?
04:34:22 <jle`> should it use the `talk` from Human instance?  or `talk` from the Int instance?
04:34:58 <jle`> if you said something like `"hello" == "hello"`, Haskell knows that you want the Eq instance for String, because you're using (==) on two strings
04:35:22 <kaidelong> now there is something out there called Proxy for when this is really the sort of thing you want to do, which you could use to annotate String with a phantom type
04:35:31 <jle`> but if you just write `talk`, how would haskell know which "talk" to use?  the talk from the String instance?  the talk from the Human instance?  there really isn't a way to give a hint
04:36:07 <kaidelong> but usually when writing typeclasses you return something useful that involves the type in question, for example
04:36:22 <kaidelong> talk person = "My name is... " ++ name person
04:36:41 <cellopin> Okay.. I need another parameter then
04:37:24 <jle`> or, you need talk to take a parameter.  so maybe you can use talk :: a -> String
04:38:11 <jle`> that way when you say `talk myPerson`, haskell knows, "oh, you're using `talk` from the Person instance.  because you're giving it a Person"
04:39:50 <cellopin> Yeah.. I was thinking that this is quite like a subclass in an OOP language but that is just naive
04:41:00 <kaidelong> well, before getting to higher kinded type classes like Functor or Monad, they really are like OOP interfaces
04:41:30 <kaidelong> the terminology is different, but they largely work the same, in OOP you just always pass in the thing at the left side of the dot!
04:41:50 <kaidelong> so instead of "x.talk(y)" you need to write something like "talk x y"
04:42:23 <jle`> but, yeah, we actually don't really use "subclassing" patterns like this in haskell
04:42:38 <kaidelong> likewise if it would be "x.talk()" then it would become "talk x"
04:42:39 <l0p3n> http://ideone.com/jqRvhP Using a negative value to this example function gives me an error. Why?
04:42:41 <jle`> subclasses-through-typeclasses-instancing-things
04:43:22 <jle`> not saying it's not worth playing around with for learning, but maybe just be aware that we don't often use patterns like this :)
04:43:44 <jle`> l0p3n: how are you passing it inot he function?
04:43:46 <kaidelong> l0p3n: you have a mistake with the guard syntax, get rid of the second "absolute x"
04:43:55 <indiagreen> actually, it doesn't give an error for me
04:44:02 <l0p3n> jle`: absolute -1
04:44:06 <jle`> l0p3n: you'd need to do something like absolute (-1)
04:44:10 <jle`> absolute -1 is parsed as absolute - 1
04:44:17 <jle`> as in, "absolute minus 1"
04:44:22 <jle`> it's trying to subtract 1 from absolute
04:44:40 <cellopin> Thanks guys..
04:44:41 <indiagreen> kaidelong: it's not a mistake, just redundancy
04:45:02 <kaidelong> wouldn't it have different semantics?
04:45:12 <l0p3n> jle`: Thank you very much!
04:45:13 <kaidelong> first pattern match succeeds, the guards fail
04:45:17 <kaidelong> no fallthrough to the second
04:45:46 <jle`> i feel like there is fallthrough, cause there's fallthrough on case statements
04:45:47 <indiagreen> kaidelong: no, and that's actually pretty useful
04:46:15 <kaidelong> alright, that's good to know
04:46:16 <jle`> > case 10 of x | x > 100 -> "hello"; x | x < 100 -> "goodbye"
04:46:18 <lambdabot>  "goodbye"
04:46:43 <jle`> guards with case statements are super fun
04:56:00 <mikeplus64> is there a way to get the result of a type family in template haskell?
04:57:23 <mikeplus64> well... short of writing some type family interpreter for template haskell
04:58:46 <mikeplus64> nvm, it's not possible to do what i want exactly (i'd have to be putting names into scope from strings, ie, nastiness)
05:12:46 * hackagebot opml-conduit 0.2.0.1 - Streaming parser/renderer for the OPML 2.0 format.  http://hackage.haskell.org/package/opml-conduit-0.2.0.1 (koral)
05:29:21 <{AS}> Hi, Is there any reason why Haskell needs to recompile all modules, when only a function body changes?
05:30:07 <merijn> {AS}: GHC uses cross-module inlining for performance
05:30:17 <{AS}> merijn: Ah, thanks
05:30:26 <merijn> {AS}: So a function changing that is/might be inlined would force recompilation
05:31:05 <{AS}> Yeah, understandable (I guess this is different from traditional imperative languages, that do not do as much inlining)
05:31:32 <merijn> {AS}: Well, it's essentially trying to fake "whole-program optimisation" :)
05:31:39 <{AS}> :) 
05:35:21 <latermuse> Anybody have an idea about how I can get this to work? Ive been fiddling with it for a few hours now and nothing seems to be right: http://lpaste.net/132262
05:35:33 <maerwald> What's the easiest way to move from a static configuration model (as in: Settings.hs) to a dynamic configuration model where the config file is read during runtime. The code currently can access all the settings globally. That would go out of the window I guess.
05:36:48 <maerwald> And passing the settings as an argument through the whole program flow is also pretty nasty.
05:36:57 <coin3d> hi there. when I type ":t read" on the ghci console, I get: read :: Read a => String -> a
05:37:17 <coin3d> in the haskell book however, it returns: read :: (Read a) => String -> a  
05:37:22 <bennofs> latermuse: your string has spaces, yet I do not see any part of your code that skips whitespace
05:37:39 <coin3d> is there any special thing about the parentheses around the type class?
05:37:46 <coin3d> or is the haskell book just wrong?
05:37:51 <barrucadu> coin3d: That's the same. The parens are only necessary if you have multiple constraints
05:37:52 <bennofs> coin3d: it's equavilent
05:38:19 <bennofs> :t traverse
05:38:20 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
05:38:26 <bennofs> ^^^ multiple constraints
05:38:28 <coin3d> ahh ok
05:38:30 <coin3d> thanks.
05:38:31 <latermuse> bennofs: is there a way to have it skip any input that is not in the string list? ["a", "c"]
05:38:35 <coin3d> btw, these multiple constraints
05:38:39 <coin3d> are they packed into a tuple?
05:38:47 <coin3d> so do the parentheses actually refer to a tuple type?
05:39:28 <bennofs> coin3d: this is dependent on the haskell implementation of course. not sure how GHC implements them exactly, but in many cases, the constraints do not exist at run time anymore
05:40:02 <bennofs> It could be that GHC uses a tuple for the type-class-instance dictionary when it's not specialized at compile time
05:43:36 <amukiza> Helo, there. I need help coverting a this code to point free. and a litle commentary to help me understand point free composition would be much appreciated. http://pastebin.com/DMwdW0T1#
05:44:34 <latermuse>   putStrLn . head . concat . filter (\x->  length x == 1) . group . sort . words $ raw
05:45:08 <bennofs> @pl \raw -> putStrLn $ head $ concat $ filter (\x->  length x == 1)  $ group $ sort $ words raw
05:45:08 <lambdabot> putStrLn . head . join . filter ((1 ==) . length) . group . sort . words
05:47:09 <amukiza> lambdabot: , latermuse: bennofs: thanks a bunch.
05:48:58 <bennofs> amukiza: explaination: for all functions f and g, f . g = \x -> f (g x). If you substitute that equality in the above equation, you will after some iterations arrive at your original code. (You might also need that f $ g $ ... $ a = f (g (... (a)))
05:50:44 <amukiza> bennofs: Thanks alot.
05:53:33 <latermuse> I wonder how often lambdabot gets thanked.
05:53:39 <bennofs> @botsnack
05:53:39 <lambdabot> :)
05:53:53 <bennofs> @karma lambdabot
05:53:53 <lambdabot> lambdabot has a karma of 28
05:54:07 <latermuse> hehe
05:54:19 <bennofs> lambdabot++
05:54:21 <bennofs> @karma lambdabot
05:54:21 <lambdabot> lambdabot has a karma of 29
05:56:27 <davor___> Hi! I'm a beginner working my way through 99 haskell challenges. I have this type: 
05:56:28 <davor___> data Entry a = Single a | Multiple (Int,a) deriving (Eq, Show)
05:56:59 <davor___> How can I write a function that returns Entry as an output?
05:57:06 <davor___> I've tried this: encodeModified :: (Eq a, Show a, Num b, Entry c) => [(b,a)] -> [c]
05:57:53 <davor___> What I would like to say is that my Entry is of type *a* (where *a* was mentioned previously as Eq a, Show a
05:58:15 <bennofs> davor___: 'Entry a' is just a type, like any other type
05:58:34 <bennofs> davor___: so you can write: encodeModifed :: (Eq a, Show a, Num b) => [(b,a)] -> [Entry a]
05:58:47 <davor___> Ah!
05:58:58 <davor___> Many thanks :)
06:01:58 <amukiza> bennofs: haskell is beautiful :)
06:06:53 <moneyonnet> 4,1 Win 20.000-30.000 Euro Per year (1700-2500 Euro per month) With 1 H per day for 365 days. At start you will earn little money but with time your starting to learn much more at start you can win 0.5 euro per day first week and after a month you will earn 10-20 euro per day Its Verry simple just Make an account on my link and i will train you and i will be your guide as much you need Sign 
06:06:53 <moneyonnet> 4,1Up here And good Luck 9,1 -----> http://www.marketglory.com/strategygame/lolopoco
06:07:06 <butyoudonot> Oh, nice!
06:10:41 <hpc> @ops
06:10:41 <lambdabot> Maybe you meant: pl oeis docs
06:10:47 <hpc> @where ops
06:10:47 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
06:11:03 <ackthet> pls
06:11:45 --- mode: ChanServ set +o dibblego
06:11:48 --- mode: dibblego set +b *!*SafeMoney@*.residential.rdsnet.ro
06:11:53 --- kick: moneyonnet was kicked by dibblego (moneyonnet)
06:14:41 <maerwald> that's a load of money
06:15:17 <obb> sounds like a typical marketing career ;)
06:18:22 <SrPx> Hi, where is the function to apply a transformation matrix to a V3 on Linear?
06:23:02 --- mode: dibblego set -b *!*SafeMoney@*.residential.rdsnet.ro
06:23:12 --- mode: dibblego set -o dibblego
06:28:50 <bennofs> SrPx: !* from Linear.Matrix I'd guess
06:34:59 <SrPx> ty!
06:38:17 <WackyTom> Picture of my sexy teen girlfriend topless showing her great tits: http://imagetwist.com/kgryqdg68ygm/Annie.jpg
06:38:56 <bennofs> @where ops
06:38:56 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
06:39:10 <WackyTom> Picture of my sexy teen girlfriend topless showing her great tits: http://imagetwist.com/kgryqdg68ygm/Annie.jpg
06:41:28 --- mode: ChanServ set +o dibblego
06:42:53 * hackagebot unbound-generics 0.1.2.1 - Support for programming with names and binders using GHC Generics  http://hackage.haskell.org/package/unbound-generics-0.1.2.1 (AlekseyKliger)
07:01:59 <Wizek> Good Morning!
07:02:01 <Wizek> Has anyone encountared and/or knows how to solve an issue when I triy to open a .cabal package Leksah crashes immidiatelly?
07:06:36 <indiagreen> what's the right way to create ‚ÄúprintCounter :: IO ()‚Äù which would print an increased number each time it's called? I can only think of something with unsafePerformIO ‚Äì http://lpaste.net/132281 ‚Äì which I don't like
07:07:54 <Wizek> indiagreen: I'm pretty sure that should be possible wothout unsafe, let me try to write it
07:08:05 <bennofs> indiagreen: there is no way to do it without unsafePerformIO. You could however have createCounter :: IO (IO ())
07:10:22 <hiptobecubic> can't you just store the counter in a ref?
07:10:43 <pacak> (22:01:38) Wizek: Good Morning!
07:10:46 <hiptobecubic> MVar Int,  then printCounter is a closure over that?
07:10:48 <pacak> That's an unusual statement :)
07:11:28 <bennofs> hiptobecubic: but to create the MVar, you need to be in IO.
07:11:51 <hiptobecubic> bennofs, sure, but to run printCounter you need to be in IO anyway
07:12:12 <bennofs> hiptobecubic: yes, but you don't need to be in IO to obtain a reference to the printCounter function
07:13:01 <bennofs> hiptobecubic: consider foo :: IO () and bar :: IO (). Right now, they can both call printCounter and they will share one counter
07:13:15 <bennofs> hiptobecubic: if you add an MVar, you need to add an extra argument to both functions
07:13:34 <bennofs> hiptobecubic: if you do that, you can as well just use a ReaderT (IORef Int) or directly a StateT Int
07:14:14 <indiagreen> bennofs: okay, thanks, I guess I might as well use Data.Unique to be safer against GHC's optimisations
07:14:43 <indiagreen> (it's not really related to counting, but it'll do for me)
07:14:47 <hiptobecubic> bennofs, sure. But if you want to share state between foo and bar, you need to create them with references to that state somehow.
07:14:54 <bennofs> indiagreen: yes, but why do you need this? these things are going to bite you if you aren't very careful
07:15:34 <bennofs> btw, uniques where one major problem when parallising GHC iirc
07:15:56 <indiagreen> I need unique names; and I feel bad using ‚Äúrandom‚Äù because then things may overlap; and names have to be as short as possible
07:16:40 <bennofs> indiagreen: and is it not possible to pass an extra parameter UniqueSupply to all functions that require unique names? (or use a ReaderT?)
07:18:09 <jfeltz> can anyone upload a package candidate right now?
07:21:52 <indiagreen> bennofs: that's too messy for a small script that just does some tests (and I have ReaderT in the stack already, so it would either require combining unrelated things into one state, or creating a new monad transformer and adding all those mtl instances for it)
07:22:20 <bennofs> indiagreen: why unrelated? a unique name supply seems pretty related to me ...
07:22:39 <indiagreen> I mean, I already use ReaderT for something else
07:22:43 <bennofs> indiagreen: note that you can use 'local' to run a smaller ReaderT in a larger environment
07:22:46 <bennofs> :t local
07:22:47 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
07:22:54 <bennofs> oh, you can't :|
07:23:31 <bennofs> indiagreen: so your ReaderT is not a record? 
07:23:41 <indiagreen> it is
07:23:47 <Wizek> Anyone using/have used Leksah IDE here?
07:24:00 * bennofs would add another record field then
07:24:16 <indiagreen> it's slightly complicated
07:24:17 <indiagreen> a sec
07:24:53 <bennofs> :t magnify _1 :: Monad m => ReaderT a m r -> ReaderT (a,b) m r -- lens is really nice 
07:24:54 <lambdabot> Monad m => ReaderT a m r -> ReaderT (a, b) m r
07:25:28 <indiagreen> lens is really huge
07:25:38 <indiagreen> (I know about magnify/zoom)
07:25:42 <bennofs> I know, just in case you already use lens :))
07:25:46 <bennofs> oh ok
07:26:13 <saulzar> :t zoom
07:26:14 <lambdabot> Zoom m n s t => LensLike' (Control.Lens.Internal.Zoom.Zoomed m c) t s -> m c -> n c
07:26:26 <pacak> ghc with GHC.TypeLits is complaining that it can't deduce (n ~ n1) from ((n + 1) ~ (n1 + 1)) (whole error message is kind of long), any suggestions how to convince it from those two are the same?
07:26:39 <bennofs> :t zoom _1 :: Monad m => StateT s m r -> StateT (s,t) m r
07:26:40 <lambdabot> Monad m => StateT s m r -> StateT (s, t) m r
07:26:57 <indiagreen> saulzar: zoom :: Monad m => Lens' s t -> StateT t m a -> StateT s m a
07:26:59 <bennofs> (allows to run a StateT action on a smaller part of the state)
07:27:04 <indiagreen> (that's just a specialised version)
07:27:20 <saulzar> I see, magnify for reader zoom for state
07:31:37 <indiagreen> bennofs: okay, uh, I realised that I don't really care about optimising the design of a small script, so I won't bother with any pastes, but now I have another question ‚Äì am I right that creating a ‚ÄúUniqueT‚Äù transformer which would play nicely with -mtl and lifting magic- would require writing a dozen repetitive instances for other Monad* classes? Or can I somehow use the fact that UniqueT is just going to be newtyped
07:31:37 <indiagreen> StateT, and apply some GeneralizedNewtypeDeriving to it?
07:32:49 <bennofs> indiagreen: yes, you can derive all instances that StateT would have. You might need StandaloneDeriving for some Monad* instances though (I think MonadReader requires it)
07:33:33 <bennofs> so you can say: deriving instance MonadReader r m => MonadReader (UniqueT m). I'm not sure if GHC can currently figure out the context itself in this case
07:44:22 * hodapp attempts to figure out how he's never installed Haskell on his Mac yet
08:04:29 <_my> hi? anyone here?
08:06:23 <apoh> hi :)
08:06:29 <hodapp> hi
08:07:40 <_my> i was hoping for a recommendation... i learned haskell in the first semester in my CS uni course. i remember the basics but i forgot some "advanced" stuff and i was hoping to learn more. is there any website, book or something that you would recommend?
08:08:10 <apoh> I'm learning haskell just now but I'm reading through this book http://learnyouahaskell.com
08:09:26 <_my> yea, most recommendations online mention lyah, but i don't know if i'll go through half of the book repeating stuff i already know... but if i jump over chapters, i'm afraid i might lose something important
08:10:02 <hpc> there's definitely a progression to it
08:10:10 <hpc> but you can start reading at the first thing you don't recognize
08:10:19 <hpc> and it's pretty good about sticking to one concept at a time
08:13:11 <_my> if i jump over the first 6 or 7 chapters, do you think it will make any difference in the rest?
08:14:03 <apoh> as long as you are somewhat familiar with the content in those chapters I think it will be fine. Concepts from currying and recursion seem to be needed in later chapters
08:17:12 <apoh> I dunno it is cumulative in nature but I think you will notice when something is not clear as a result of skipping something early
08:17:35 <apoh> especially because a lot of it is presented by example rather than a long verbal explanation
08:20:46 <TimWolla> _my, apoh: It usually mentions when it refers to something one has learned earlier.
08:20:54 <TimWolla> Except when it's the total basics.
08:21:36 <ion> my: https://github.com/bitemyapp/learnhaskell/blob/master/README.md
08:23:47 <_my> i feel fairly confortable with recursion and stuff. Also the basics of category theory. im going to look into this. thank you all
08:26:00 <XexonixXexillion> Hi. Is there a way I can make it so that anything a CAF references doesn't get garbage collected?
08:26:32 <quchen> If it's referenced, it's not GC'd
08:26:37 <Wizek> cabal downloads source code and builds it, right? And if so, is this source code retained? Leksah is asking me to add some package sources, that's why I am looking for this
08:27:52 <XexonixXexillion> So, I have a CAF which is a large tree generated by a function. I reference the same node in the tree at two different times, and the function is evaluated once (well, the trace I added gets called twice)
08:28:08 <XexonixXexillion> *the function isn't evaluated once
08:28:24 <merijn> XexonixXexillion: Is the large tree polymorphic?
08:28:47 <merijn> Specifically, for example, Num a somewhere in there?
08:29:05 <bennofs> XexonixXexillion: can you show the code?
08:29:45 <XexonixXexillion> data BinTree a = Leaf a | Branch (BinTree a) (BinTree a), and the caf has type BinTree (BinTree (BinTree Int))
08:32:13 <lpaste> XexonixXexillion pasted ‚ÄúCAF problems‚Äù at http://lpaste.net/132285
08:33:17 <Husel> Hey, what's the correct syntax for where statements containing guards? http://pastebin.com/AAhX0fW8
08:34:09 <bennofs> XexonixXexillion: so you get two traces for the same path?
08:35:51 <XexonixXexillion> bennofs: yeah
08:36:27 <XexonixXexillion> or more specifically I get 26000 traces between the same 6 paths XD
08:36:44 <bennofs> XexonixXexillion: it's probably because bar and baz are evaluated multiple times. they all start with an empty path, so there will be multiple leaves in foo which have childs with the same path
08:45:24 <SrPx> If equational reasoning is so important to us, why did we allow the language to bring features that break it? For example, "a = f (cloneLens foo)" and "a = f b where b = cloneLens foo" isn't equivalent. One compiles, the other doesn't
08:45:52 <bennofs> :t cloneLens
08:45:53 <lambdabot> Functor f => ALens s t a b -> (a -> f b) -> s -> f t
08:46:13 <bennofs> SrPx: -XNoMonomorphismRestriction, and you're done! :)
08:46:26 <SrPx> someone told me that it is harmful?
08:46:57 <bennofs> SrPx: this should be balanced against another fact: in your example, b will be evaluated twice while one might expect it to be memoized
08:47:26 <bennofs> SrPx: or more, depending on how many times f uses b
08:48:00 <merijn> bennofs: Better solution is to just add a type signature...
08:48:07 <bennofs> merijn: right
08:49:46 <monochrom> I am of the opinion of turning off the restriction for beginners, especially since they first learn to get the right types and values (as opposed to getting fast)
08:50:17 <monochrom> and these days getting fast in this case may be done by the optimizer anyway
08:51:12 <SrPx> I don't understand where the line between performance and elegance is on Haskell... monomorphismrestriction looks like a serious loss of usability for some gain in performance... yet we have things like (^)...?
08:51:34 <bennofs> :t (^)
08:51:34 <lambdabot> (Integral b, Num a) => a -> b -> a
08:51:48 <SrPx> @src (^)
08:51:48 <lambdabot> x ^ 0            =  1
08:51:48 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
08:51:48 <lambdabot>   where f _ 0 y = y
08:51:48 <lambdabot>         f x n y = g x n
08:51:48 <lambdabot>           where g x n | even n    = g (x*x) (n `quot` 2)
08:51:50 <lambdabot>                       | otherwise = f x (n-1) (x*y)
08:51:52 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
08:52:16 <SrPx> That should be a machine op...
08:52:49 <bennofs> oh right, it's not inside the Num class so it has to use generic methods
08:53:24 <SrPx> Ah but can't it be specialized for num?
08:53:51 <bennofs> SrPx: you cannot write special code "if a type is an instance of a class", apart from adding it to the class itself
08:54:05 <SrPx> hmm...
08:54:18 <monochrom> SrPx, your question seems to reflect that you have made a wrong assumption: Haskell is designed by one single mind with one single goal.
08:55:28 <monochrom> in reality, Haskell is designed by many minds with multiple mildly conflicting goals. at the end, each person trades concessions with the others.
08:55:47 <monochrom> where was the line drawn? answer: it was drawn in the meeting room.
08:56:06 <SrPx> fair enough :)
08:57:26 <ion> SrPx: Whatever one's opinion about the monomorphism restriction is, it's more about semantics (things not looking like functions behaving like functions), any difference in performance is incidental.
09:00:01 <monochrom> ion: I don't understand. how do I *observe* that, for example, "x :: Num a => a; x = 4" behaves like functions?
09:00:21 <monochrom> especially, *observe* without *measuring* performance
09:00:49 <monochrom> and without reading generated code
09:01:18 <monochrom> or in short, like you said, observe with only semantics
09:01:54 <nshepperd> monomorphism restriction can make the difference between linear and exponential time though, which may be "semantics" depending on your mood
09:03:04 <SrPx> Anyway, "Unless you're writing some weird combinator libraries, or are in the habit of not writing type declarations, you're unlikely to come across it." from the monomorphism restriction argument
09:04:12 <SrPx> I think that should be rethought - all I tried to do is store a lens in a container, and then use the stored lens. TBH the fact I couldn't store a lens on a container is itself kinda wierd, even though edward tried explaining it to me...
09:04:29 <SrPx> But I wouldn't expect a newcomer to grasp it.
09:04:53 <byorgey> I wouldn't expect a newcomer to be storing lenses in containers either.
09:05:43 <SrPx> Well, you should - lens as an abstraction on the value level are easy to understand and apply. The only reason they're considered advanced is what's going on at the type level
09:05:51 <bennofs> byorgey: you don't need ALens just for storing lenses in a container. You need them as soon as you need to use a lens with two different operations and preserving type inference
09:05:54 <SrPx> And they are extremely useful...
09:06:02 <byorgey> SrPx: if you're complaining about the monomorphism restriction, you're mostly preaching to the choir.  Many people (myself included) recommend turning it off.
09:06:43 <SrPx> Well it is on, so I assumed the consensus was to keep it.
09:07:37 <monochrom> the only way I can think of: take maxBound for example. in different type contexts it is a different value. [True, maxBound] gives me True, ['x', maxBound] doesn't give me True, etc.
09:07:45 <athan> Hey guys, why isn't there a safe index (!!?) for Data.List?
09:07:54 <byorgey> SrPx: that is an unwarranted assumption.  Many things are the way they are simply because of inertia.
09:08:22 <byorgey> athan: space gremlins
09:08:34 <athan> byorgey: Hell yeah
09:08:47 <ion> I was thinking of something along the lines of nshepperd.
09:08:57 <SrPx> byorgey: fair enough - can I recommend a newcomer to just use it without fearing I'm giving a bad advice?
09:09:00 <Husel> How can I rewrite modEqualsZero n p = n `mod` p == 0  to only take the first argument? so modEqualsZero n = ...?
09:09:01 <monochrom> but one has to pretty anal to consider that function-like. I certainly don't expect maxBound to be a type-independent constant. quite the contrary. I only expect: wherever the type context is Bool, maxBound gives me the same Bool value again.
09:10:17 <ion> I kind of think of maxBound as a function from a type (which happens to be an implicit parameter) to a value.
09:10:44 <roconnor> modEqualsZero n = \p -> n `mod` p == 0
09:11:10 <Husel> Ah so simple haha, thank you :)
09:11:16 <Husel> Didn't think to use a lambda
09:11:28 <roconnor> @pl  \p -> n `mod` p == 0
09:11:28 <lambdabot> (0 ==) . (n `mod`)
09:11:40 <roconnor> modEqualsZero n = (0 ==) . (n `mod`)
09:11:57 <Husel> Ah nice!
09:12:28 <monochrom> ok, I think the best wording is neither semantics (which is always assumed to be denotational semantics in this circle) nor performance (which is usually assumed to be constant multipliers). the best wording is "it can change asymptotic time complexity"
09:12:41 <ion> monochrom: Fair enough.
09:13:08 <roconnor> @free maxBound
09:13:09 <lambdabot> Extra stuff at end of line in retrieved type "Bounded a => a"
09:13:26 <nshepperd> and space complexity too, I suppose
09:13:56 <nshepperd> I think it's valuable to keep the amount of stuff you need to keep track of with laziness and sharing small
09:14:27 <ReinH> roconnor: o/
09:15:02 <byorgey> SrPx: yes
09:15:11 <nshepperd> and that keeping let binds and things monomorphic by default helps achieve that, but ymmv I guess
09:15:27 <roconnor> ReinH: \o
09:16:15 <SrPx> okay, thanks :)
09:16:52 <SrPx> just a last bit, isn't the "I can't put a lens inside a container" thing something else (other than the mono~restriction) that also breaks equational reasoning? What is it called?
09:17:46 <nshepperd> if you're trying to create an 'f (Lens s t a b)' for some f that's impredicative types
09:17:50 <SrPx> actually not, it is more about a container with a lens not being typeable... nevermind
09:18:08 <SrPx> A better question might be, why it is not typeable? Could it be on other system?
09:18:56 <bennofs> SrPx: there is ReifiedLens iirc which is a newtype wrapper around lens and can be Typeable (don't know if it is)
09:20:00 <SrPx> if you mean ALens, that is what I'm using (I think)
09:20:23 <SrPx> which works fine and all - I'm just trying to understand the nature of the problem
09:23:01 <roconnor> There are two variants:  ALens is a universal lens instance and is Rank-1, and ReifiendLens which is a new type wrapper holding a polymorphic value, and is higher ranked.
09:23:34 <roconnor> ReifiendLens is lighter weight and supposedly can be used in containers.
09:25:57 <hodapp> Reifiend? should that be Reified?
09:41:42 <Freinn> hi guys, I have a problem, I want a function to replace \\n in a string to simply \n
09:44:41 <glguy> Refried*
09:45:57 <nshepperd> RefiendLens, the demonic data accessor
09:52:21 <edwardk> SrPx: f (forall x. .... )   requires impredicative types. if you expand the synonyms you run into that problem
09:52:36 <edwardk> srpx: [forall a. a] runs into just as many issues as the lens thing
10:04:08 <SrPx> but even with impredicative types you can't have lens inside a container, right? I'm rereading your explanation from yesterday, but I gtg now...
10:04:24 <edwardk> ImpredicativeTypes in haskell don't work basically
10:04:30 <edwardk> SPJ gave up on them
10:04:39 <edwardk> we just have vestiges of them from when he thought they could make it work
10:06:17 <amf> a) is it possible to do the applicative style over a list so i can do something different for each element (position matters) b) what is the syntax?
10:07:15 <amf> basically i have no idea what each "cell" looks like: MkMyData <$> ... <*> [ 1, 2, ... ]
10:11:06 <erisco> is there an IntMap for sizes other than Int? what if I wanted to use Int32 specifically?
10:11:34 <amf> erisco: like in Data.Word?
10:12:00 <erisco> what is in data.word?
10:12:22 <amf> unsigned integer types
10:12:33 <erisco> well yes, like those types
10:13:09 <erisco> the significance of having an Int32Map may be minimal because Int32 will widen to Int anyways
10:14:10 <erisco> and the extra storage is probably proportional to nlogn on vertices
10:18:15 <frerich> Actually, does anybody know a nice definition for a function 'f :: [a] -> a -> [a] -> [a]' which replaces all occurrences a sequence of elements with a single element, e.g. 'f [1,2,3] [9] [1,2,3,4,1,2,3]' yields '[9,4,9]'? I'm somewhat disappointed that the shortest solution I came up with uses a foldr :-/
10:18:34 <frerich> err, that should have been 'f [1,2,3] 9 [1,2,3,4,1,2,3]'.
10:19:07 <frerich> Hm, maybe I should have looked at Data.List.Split, too...
10:21:09 <jmcarthur> frerich: i do not understand what your function is supposed to do
10:21:17 <jmcarthur> oh
10:21:18 <erisco> I do :D
10:21:20 <jmcarthur> nevermind, i see it now
10:22:02 <erisco> you can do   [a] -> [a] -> [Maybe a]   and then replace the Nothing's with whatever you want
10:22:02 <jmcarthur> what is  f [1,2,1] 9 [1,2,1,2,1]   supposed to be?
10:22:08 <frerich> jmcarthur: It's inspired by Freinn's question earlier, who wanted to replace all occurences of "\\n" with just '\n'.
10:22:10 <erisco> the first part just identifies subsequences
10:22:25 <frerich> jmcarthur: [9,2,1]
10:22:49 <erisco> :t prefix
10:22:50 <lambdabot>     Not in scope: ‚Äòprefix‚Äô
10:22:51 <lambdabot>     Perhaps you meant one of these:
10:22:51 <lambdabot>       data constructor ‚ÄòPrefix‚Äô (imported from Data.Data),
10:23:12 <erisco> :t stripPrefix -- this could help
10:23:13 <lambdabot> Eq a => [a] -> [a] -> Maybe [a]
10:24:18 <frerich> I first went for something based on 'take 2 . tails' but that ended up being longer than I thought...
10:28:45 <osa1> I have ghc: 7.10 in my travis file but apparently travis parses it as 7.1. does anyone here use travis with ghc 7.10?
10:29:10 <osa1> I don't want to add ubuntu PPAs and install manually if there's a workaround
10:29:29 <erisco> frerich well I have a fairly simple definition but I presume you don't want explicit recursion
10:31:01 <erisco> frerich http://lpaste.net/132292
10:32:49 <ion> You could use ViewPatterns or PatternGuards quite nicely in that.
10:35:12 <ion> f xs r ys | Just ys' <- stripPrefix ... = ... | y':ys' <- ys  = ... | otherwise = []
10:36:22 <Javran> given two arrays of the exact same size, and I want to do pairwise binary operations on them (addition, subtraction..), does array or vector offer better supports / performance ?
10:38:02 <dmj`> Javran: do you mean two lists of the exact same size?
10:38:35 <Javran> dmj`: yeah
10:38:44 <dmj`> > zipWith (+) [1..10] [1..10]
10:38:46 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
10:39:12 <rom1504> Javran: what about just using lists ?
10:39:52 <Javran> there are big arrays, the performance does matter.
10:40:14 <lamefun> How can I make return in main :: IO ()  ; main = putStrLn (show (return 5)) to call eg. the return or maybe monad?
10:40:31 <ion> If both provide a zipWith, it probably doesn't matter which one you use.
10:40:48 <dmj`> Javran: vector is just array really, it's defined in terms of it
10:41:15 <monochrom> lamefun: you will have to add a type, (return 5 :: Maybe Integer)
10:41:27 <Javran> dmj`: I didn't know that before
10:41:28 <ion> lamefun: (return :: a -> Maybe a) 5 or return 5 :: Maybe Integer
10:41:37 <lamefun> thanks
10:41:44 <Javran> but what's the exact thing vector offers?
10:42:11 <ion> vector is defined in terms of array, huh? TIL
10:42:30 <monochrom> list is more efficient than array in one context. array is more efficient than list in another context.
10:42:40 <Javran> the binary operations I want to perform is just as simple as additions, so I get UArray will be fine
10:42:51 <dmj`> ion: TIL ?
10:42:52 <monochrom> actually, let me change that to vector
10:42:54 <Javran> get/guess
10:43:01 <monochrom> list is more efficient than vector in one context. vector is more efficient than list in another context.
10:43:03 <ion> vector doesn't seem to depend on array.
10:43:16 <ion> dmj: Today I Learned
10:43:30 <Javran> http://hackage.haskell.org/package/vector-0.10.12.3/docs/src/Data-Vector.html#Vector
10:43:57 <monochrom> list is more efficient when it is a lazy list, at every point of time O(1) items actually live in memory
10:43:59 <Javran> vector does have an Array in one of its fields
10:44:28 <monochrom> vector is more efficient when you deliberately want the whole thing to live in memory at once
10:45:26 <dmj`> ion: Data.Primitive.Array
10:45:27 <lokathor> jle`, it works!
10:45:43 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #5 is eternal wisdom
10:46:04 <Javran> I suspect there are chunk-wise adding / subtracting supports
10:46:06 <lpaste> Lokathor pasted ‚Äúsuccessful version‚Äù at http://lpaste.net/132294
10:46:35 <dmj`> ion: if you look at the defintion of Vector, you'll see 'Array', I just assumed it was from the Array package, my bad bro
10:57:17 <ion> lokathor: You're reimplementing MonadRandom, btw.
10:57:36 <lokathor> am i? I expect I might be
10:57:48 <lokathor> It's not complicated, it's just complicated at 2am when you really need to sleep
10:57:59 <mjrosenb> style question: is it reasonable to create a type alias that is intended to be used with a particular value only?
10:58:05 <Philippa> is there a de facto standard library for wrapping/abstracting over different types of reference and mutability monad? Well, should probably be applicative rather than monad
10:58:12 <Philippa> I ask because I haven't looked in a very long time
10:58:25 <Philippa> mjrosenb: if it helps readability, hell yes
10:58:34 <lokathor> I had been trying to use Traversable, but then that was giving me a different kind of 'sequence' that was getting in my way
10:58:46 <mjrosenb> e.g. in Reactive.Banana, I have an vsync :: Event t (),  is it reasonable to have type VSync = Event t (); vsync :: VSync?
10:59:33 <Philippa> if the type synonym is exposed, extremely reasonable
11:00:13 <mjrosenb> Philippa: do I expose it just by adding it to the export list of the module?
11:00:40 <Philippa> mjrosenb: I honestly can't remember :/
11:00:54 <Philippa> but tbh: if you'd use let if it were at term level, just do it?
11:01:45 <Philippa> I'm really looking forward to having the combination of type synonyms and type holes available
11:02:19 <Philippa> been wanting that for about a decade, though I was using different words because Agda 2 wasn't extant let alone Idris
11:02:59 <Philippa> ("not only am I going to use a short name for this complex type, I'm going to infer what it is by some set of defining uses" - so you can just build that complicated monad transformer stack with the run calls, say)
11:05:58 <dependencies-onl> Hi everybody, I'm trying to optimize my workflow with Haskell
11:06:27 <dependencies-onl> I was wondering if anyone could help me.
11:07:22 <Philippa> well, you'd have to start by telling people what your workflow looks like now and what you're trying to do?
11:07:34 <Philippa> In practice I'm still working like it's a decade ago though, so not me
11:07:56 <dependencies-onl> I like to avoid read code in Vim with HDevTools, and to isolate projects in sandboxes to avoid conflicts.
11:08:01 * hackagebot pandoc-citeproc 0.7.0.1 - Supports using pandoc with citeproc  http://hackage.haskell.org/package/pandoc-citeproc-0.7.0.1 (JohnMacFarlane)
11:08:33 <dependencies-onl> And to use Stackage as a default, and Hackage + stackage constraints as a fallback.
11:09:16 <Philippa> *nod* - sounds reasonable at a glance, but as I said I'm not best-placed to comment
11:09:21 <dependencies-onl> Now my issue is that HDevTools will only give good results on well-formed cabal project that actually builds.
11:09:25 <lokathor> that all sounds fine. Where do you feel the hangups are?
11:09:54 <lokathor> classic automation issue, "expects well formed input"
11:10:11 <dependencies-onl> This is inconvenient when I just want to git clone a lib and read it; I need to setup a whole sandbox for it just to get HDevTools to understand it.
11:11:32 <dependencies-onl> So before my questions devolve into HDevTools-specific support, I want to know how you people do that kind of things.
11:12:58 <dependencies-onl> Which boils down to reading code, and reliably get expression types and source package information in their editor/IDE.
11:17:08 <dependencies-onl> Some sort of way to cabal unpack the entire tree of dependencies of a project in a directory somewhere.
11:17:25 <sinelaw> how can multiple return statements be modeled in a pure function?
11:17:37 <sinelaw> (for denotational semantics)
11:18:31 <vadim__> hi all
11:19:25 <vadim__> Just have read some tutorials and examples and I am really afraid to learn haskell.
11:20:02 <lokathor> sinelaw, do you mean like a case statement?
11:20:19 <lokathor> vadim__, hey there I'm pretty new myself, what's giving you trouble?
11:21:19 <sinelaw> lokathor, looking at the semantics of an imperative language, where I'm mapping the meanings of imperative statements/expressions to pure functions
11:22:04 <vadim__> lokathor, fill like after that I could not use other languages anymore.
11:22:15 <sinelaw> lokathor, using continuations
11:22:33 <lokathor> i really have never caught on to what "semantics" means in the first place, but remember that in an pure language you can't have "if" statements without an "else", so imperative proceedures that do that can't quite be exactly translated
11:23:00 <hpc> semantics just means "meaning"
11:23:24 <lokathor> strange that i'd always forget the meaning of a synonym of meaning
11:23:36 <sinelaw> lokathor, denotational semantics. for example, [[ if expr then body ]] = \k env -> if [[ expr ]] env then [[ body ]] k
11:23:40 <lokathor> vadim__, I know the feeling :3
11:24:10 <alynn> just think of an imperative language as everything being in the kleisli category of IO
11:24:32 <sinelaw> lokathor, ... else k
11:25:00 <sinelaw> alynn, I don't know about kleisli categories
11:25:06 <sinelaw> (yet)
11:25:40 <alynn> sinelaw: you come across categories at all?
11:25:44 <sinelaw> yes
11:25:48 <alynn> k
11:26:01 <alynn> and have you come across Hask specifically?
11:26:27 <sinelaw> yes, but never spent the time fully understanding its definition; objects = types, morphisms = functions?
11:27:40 <lokathor> vadim__, Well if you have any questions just ask
11:28:02 * hackagebot xml-conduit 1.2.6 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.2.6 (MichaelSnoyman)
11:28:04 * hackagebot dash-haskell 1.0.0.5 - Command line tool to generate Dash docsets (IDE docs) from package haddock  http://hackage.haskell.org/package/dash-haskell-1.0.0.5 (johnfeltz)
11:28:18 <alynn> sinelaw: right
11:28:32 <alynn> so a kleisli category is a category formed from a monad
11:28:33 <mmachenry> I am interested in creating a very simple HTTP server that will need to parse the URL to fit my protocol and all state will be internal to the server. There is no static HTML or HTML of any kind. Does anyone have recommendations on a library to use for this? There are quite a few out there.
11:28:51 <alynn> so the kleisli category from IO has types as objects like in Hask, but the morphisms are functions of the form a -> IO b rather than a -> b
11:29:13 <alynn> with the identity given by return and composition by (<=<) rather than by id and (.)
11:29:19 <alynn> :t (<=<)
11:29:20 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
11:34:46 <ion> I love it when people have a sense of humor. https://www.mpi-sws.org/~rossberg/f-ing/
11:35:26 <lokathor> so if i've got two different [Int] and I want to make it impossible to confuse them and mix them up, i use 'newtype' instead of 'type'? But it runs at the same speed because GHC compiles it away at the end?
11:36:01 <Philippa> yep
11:40:17 <Feuerbach> lokathor: the bit about compiling away is only sort of true (you may need to use 'coerce'); but also remember about premature optimization
11:41:23 <quchen> If you have a load of possible newtype wrappers you want to write, consider using `Tagged` as well.
11:41:37 <quchen> That's not a newtype, but will save you a lot of boilerplate.
11:41:55 <Feuerbach> it *is* a newtype, isn't it
11:42:06 <lokathor> Well i've got a generator that makes lists, and some elements in the list cancel with each other, so the final result of all the generated lists should be tallied up via a function
11:42:16 <indiagreen> lokathor: newtype wrapping and unwrapping *is* free. The things that aren't free are e.g. converting from [[Int]] to [NewtypedListOfInts].
11:42:25 <lokathor> and i was just wondering if i could reprisent that in the type system easily or not
11:42:34 <quchen> Feuerbach: Woops, right. It is.
11:42:41 <quchen> Well then there you go. :-)
11:43:07 <ion> lokathor: Given newtype Foo a = Foo { unFoo :: a }, Foo and unFoo are free. OTOH, map Foo and map unFoo are not. You can replace them with coerce :: [a] -> [Foo a] and coerce :: [Foo a] -> [a] which are free again.
11:43:16 <indiagreen> ion+
11:43:26 <lokathor> hmmmm
11:43:30 <simon> ion, do you know if Rossberg's combination of generative and applicative functors have any of the same problems as Moscow ML's implementation of the two, as discussed in http://www.seas.upenn.edu/~sweirich/types/archive/1999-2003/msg01136.html ?
11:44:20 <ion> simon: I'm afraid I'm completely ignorant about that.
11:44:42 <simon> ion, interestingly, Derek Dreyer is both the author of the email I just linked to and co-author of the article with Rossberg. :)
11:44:44 <OutlawStar> can someone tell me how to take a value of type "Data.Aeson.Object" and read a property value from it with ".:" within GHCI? I have tried multiple ways with no success... Using ".:" gives me a  "fromJSON a => Parser a" instance, but from there i am stuck since I can't print that
11:45:20 <indiagreen> OutlawStar: Data.HashMap.Strict.lookup
11:45:28 <Philippa> simon: I'd hope not - it's been understood that generativity is an effect for a while
11:46:10 <indiagreen> OutlawStar: you can also do ‚Äúimport Data.HashMap.Strict ((!))‚Äù to get just the lookup operator which can then be used unqualified
11:46:54 <simon> Philippa, okay. do they get around that just by disallowing cross-module recursion, or is that unrelated?
11:48:03 <Philippa> I'm pretty sure that if you enforce generativity-as-effect, mutual recursion will "just pan out" - you'll be able to do it for applicative functors, but you'd need a seperate "genletrec"-like construct to generate a mutually-recursive collection of modules at once
11:48:13 <Philippa> (cf monadic recursion)
11:49:35 <OutlawStar> indiagreen: why am I using a hashmap to lookup the value in a "Data.Aeson.Object"
11:49:58 <lokathor> ah, but [NewTypeOfInt] isn't free you say?
11:50:01 <lokathor> bugger
11:50:13 <Philippa> simon: so I guess that's "related but only in a known-solvable way"?
11:50:15 <lokathor> I will have to just keep it separated myself I suppose
11:50:35 <indiagreen> OutlawStar: because Object is a type alias for HashMap Text Value
11:50:39 <Philippa> I should read the 1ML paper, anyway. Likely to be relevant to something I'm toying with building
11:50:55 <ion> lokathor: That is just a type. It Is not an operation which can be free or not.
11:51:01 <ReinH> Philippa: o/
11:51:08 <OutlawStar> indiagreen: ahhh just found that :)
11:51:57 <OutlawStar> indiagreen: thx alot that worked!
11:52:08 <Philippa> 'lo ReinH
11:54:15 <sinelaw> alynn, ok; I was thinking along those lines (without knowing it's a kleisli category...)
11:54:43 <lokathor> ion: wrapping and unwrapping it, i mean
11:55:05 <ion> lokathor: As i said, you can use coerce.
11:55:26 <lokathor> i'm not familiar with that
11:56:11 <adrian1> hey all, I'm having some troubles installing glfw from cabal
11:56:17 <lokathor> hmm
11:56:27 <ReinH> sinelaw: kleisli arrows are the arrows you apply using bind, (->) arrows are the arrows you apply using ($)
11:56:36 <lokathor> "with no runtime overhead" the docs say. This sounds spooky
11:56:45 <sinelaw> ReinH, oh
11:56:52 <adrian1> getting no instance for (Applicative (StateT ConfState IO)) when I try to install glfw, without any other packages installed
11:57:00 <ion> lokathor: Given newtype Foo a = Foo a, you have among other things coerce :: [a] -> [Foo a] and coerce :: [Foo a] -> [a].
11:57:19 <sinelaw> alynn, so the idea is that the meaning of a statement is a morphism in the kleisli category of IO?
11:58:50 <ion> lokathor: Since the runtime representation of a is the same as that of Foo a, the runtime representation of [a] must be the same as that of [Foo a]. coerce lets you cast between them type-safely.
11:58:59 <Hijiri> lokathor: It's pretty magical, it is basically a type-safe unsafeCoerce
11:59:36 <ReinH> it's basically a safe unsafeCoerce, also known as "coerce"
12:00:11 <ReinH> alternatively, unsafeCoerce is an unsafe "coerce" ;)
12:01:35 <ion> > coerce [0..5 :: Integer] :: [Sum Integer]
12:01:36 <lambdabot>      No instance for (Contravariant []) arising from a use of ‚Äòcoerce‚Äô
12:01:36 <lambdabot>      In the expression: coerce [0 .. 5 :: Integer] :: [Sum Integer]
12:01:50 <lokathor> that does sound pretty magical
12:01:55 <ion> Huh
12:02:08 <ion> @type coerce
12:02:09 <lambdabot> (Functor f, Contravariant f) => f a -> f b
12:02:22 <exio4> the wrong coerce :P 
12:02:24 <Hijiri> that's the lens coerce
12:02:33 <sinelaw> sound the alarm!
12:03:03 * hackagebot friday 0.2.1.2 - A functional image processing library for Haskell.  http://hackage.haskell.org/package/friday-0.2.1.2 (RaphaelJavaux)
12:03:05 <lokathor> :t Data.Coerce.coerce
12:03:06 <lambdabot> GHC.Types.Coercible a b => a -> b
12:03:30 <exio4> > Data.Coerce.coerce ([0..5] :: [Integer]) :: [Sum Integer]
12:03:31 <lambdabot>  Not in scope: ‚ÄòData.Coerce.coerce‚Äô
12:05:02 <Hijiri> @let import Data.Coerce
12:05:03 <lambdabot>  .L.hs:73:1:
12:05:03 <lambdabot>      Data.Coerce: Can't be safely imported!
12:05:03 <lambdabot>      The module itself isn't safe.
12:08:03 * hackagebot sorted-list 0.1.3.0 - Type-enforced sorted lists and related functions.  http://hackage.haskell.org/package/sorted-list-0.1.3.0 (DanielDiaz)
12:08:31 <ReinH> :D
12:08:36 <ReinH> oh the irony
12:09:42 <sinelaw> heh
12:11:43 * Philippa starts skimming the 1ML paper
12:11:53 <jonhou> @help
12:11:53 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:12:04 <Philippa> bloody hell, does their core language basically have you define literal activation records/modules?
12:12:08 <Philippa> his, rather
12:12:21 <jonhou> @list
12:12:21 <lambdabot> What module?  Try @listmodules for some ideas.
12:14:32 <jonhou> @t
12:14:32 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
12:14:39 <jonhou> @t fmap
12:14:39 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
12:14:58 <jonhou> :t fmap
12:14:59 <geekosaur> :t fmap
12:14:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:15:00 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:15:07 <jonhou> @type fmap
12:15:08 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:15:10 <geekosaur> (or @type)
12:15:14 <geekosaur> heh
12:20:34 <Philippa> okay, I'm going to have to read the whole 1ML paper because I think it just because most of the guts of a silly-but-fun project I have in mind as a stepping stone to something that's proper-research (that I'll never get done)
12:22:46 <ifesdjeen> is there any simpler way to write (fin <$>) <$> a ?..
12:23:20 <indiagreen> ifesdjeen: I'd just write ‚Äúfmap fin <$> a‚Äù
12:24:41 <ifesdjeen> indiagreen ah, true.. <$> is essentially same as fmap, I haven't thought of this form... but looks a bit simpler because of the binding 
12:24:42 <Javran> is there an existing attoparsec parser for parsing string literals (like those literals in Haskell)?
12:24:49 <ifesdjeen> indiagreen: thanks!
12:25:08 <exio4> Javran: string? 
12:25:58 <Javran> exio4: I meant string literals begin and end with '"' and might contains some escapings
12:26:24 <exio4> oh, I don't really know then
12:26:42 <Javran> I guess I can steal it from parsec but before doing so I want to know if someone has already did that
12:26:43 <cite-reader> I don't remember seeing anything out of the box.
12:33:03 <ion> ifesdjeen: Sometimes (fmap . fmap) f x is useful.
12:34:07 <ifesdjeen> ion hah, that's great one, too! thanks!
12:36:47 <lokathor> :t liftM (repliateM 10)
12:36:48 <lambdabot>     Not in scope: ‚ÄòrepliateM‚Äô
12:36:49 <lambdabot>     Perhaps you meant one of these:
12:36:49 <lambdabot>       ‚ÄòreplicateM‚Äô (imported from Control.Monad.Writer),
12:36:56 <lokathor> :t liftM (replicateM 10)
12:36:57 <lambdabot> (Monad m, Monad m1) => m (m1 a) -> m (m1 [a])
12:42:26 <athan> Is there something like a `<$$>` for `fmap . fmap`
12:42:28 <athan> ?
12:42:51 <hpc> it's typically called (.:)
12:44:04 <Haskellfant> I've only seen (.:) for (.).(.). obviously fmap . fmap is more general
12:44:15 <athan> hpc: From what I've found, that appends the function `f` after the n'th arity `g`
12:44:28 <athan> I'm looking for something that actually prepends it
12:44:59 <athan> so (d -> c) -> (a -> b -> c -> r) -> a -> b -> d -> r
12:45:08 <athan> would that be the contravariant equivalents of .::?
12:46:34 <bennofs> :t contramap.contramap
12:46:35 <lambdabot> (Contravariant f, Contravariant f1) => (a -> b) -> f (f1 a) -> f (f1 b)
12:48:25 <athan> bennofs: Maybe there could be something like (-.::) for contramap?
12:48:36 <athan> or some other fancy symbol?
12:49:32 <ReinH> I'm sure what we need most are even more operators
12:49:59 * bennofs suggests plumbers
12:50:03 <bennofs> @hackage plumbers
12:50:03 <lambdabot> http://hackage.haskell.org/package/plumbers
12:50:06 <ReinH> I'd actually prefer <$$> to .:
12:50:20 <bennofs> ReinH: I'd prefer that for reverse fmap
12:50:28 <bennofs> ReinH: just as <**> is reverse <*>
12:50:43 <ReinH> We already have <&> thanks to lens :p
12:50:51 <cite-reader> Data.ByteString.Builder calls contramap (>$<).
12:51:11 <bennofs> :t (>$<)
12:51:12 <lambdabot>     Not in scope: ‚Äò>$<‚Äô
12:51:13 <lambdabot>     Perhaps you meant one of these:
12:51:13 <lambdabot>       ‚Äò>$‚Äô (imported from Control.Lens),
12:51:18 <edwardk> :t (Data.Functor.Contravariant.>$<)
12:51:19 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
12:51:31 <edwardk> so does my contravariant package
12:51:38 <edwardk> but i usually stuck to 'contramap'
12:51:54 <cite-reader> edwardk: I just went with the first thing Hoogle spit out.
12:52:18 <lokathor> what... *is* a contravariant?
12:52:20 <exio4> bennofs: wow, that package is crazy
12:58:06 <lokathor> I have an IO (Either String [[Int]])
12:58:21 <lokathor> and i want to run map over that outer list
12:59:01 <lokathor> is it... liftM . liftM map
12:59:06 <monochrom> yes
12:59:08 <ion> lokathor: (fmap . fmap . fmap)
12:59:17 <bennofs> lokathor: (fmap.fmap.fmap) :: ([Int] -> b) -> IO (Either String [[Int]]) -> IO (Either String [b]) 
12:59:41 <lokathor> are liftM and fmap the same?
12:59:45 <lokathor> or only the same in some cases?
12:59:47 <monochrom> yes
12:59:53 <bennofs> lokathor: they are the same
13:00:01 <ion> They are the same, liftM is just implemented in terms of the Monad operations.
13:00:23 <lokathor> and... a monad is a monoid... so fmap also applies
13:00:24 <lokathor> right
13:00:26 <ion> (If you implement Monad for something, you can implement Functor as { fmap = liftM })
13:00:33 <cite-reader> Functor, not monoid.
13:00:37 <lokathor> er Functor
13:00:48 <lokathor> monoid is... appendable
13:00:57 <exio4> with identity 
13:02:01 <ion> A monad is also a monoid, but Haskell Monad does not imply Monoid.
13:02:56 <bennofs> ion: are you refering to the mappend = liftM2 mappend instance?
13:03:05 * hackagebot safe 0.3.9 - Library of safe (exception free) functions  http://hackage.haskell.org/package/safe-0.3.9 (NeilMitchell)
13:04:01 <byorgey> bennofs: I assume ion is referring to the classic "a monad is a monoid in a category of endofunctors"
13:04:13 <ion> bennofs: I‚Äôm referring to both ‚Äúa monad is just a monoid in the category of endofunctors‚Äù and the Kleisli monoid.
13:04:33 <lokathor> would haskell benefit it monad implied monoid in some future ghc version?
13:04:33 <bennofs> ion: Kleisli is not a monoid, but a category
13:04:46 <lokathor> or some future language standard
13:05:13 <ion> bennofs: You‚Äôre right, i wasn‚Äôt thinking it through.
13:05:21 <byorgey> lokathor: no, Haskell does not have a sufficiently general notion of Monoid for that to make sense
13:05:24 <bennofs> lokathor: do not get confused by this. the haskell 'Monoid' is not a 'Monoid' in the haskell-typeclass-sense. There are more generic definitions of monoids (not implemented in Haskell)
13:05:38 <bennofs> oops, the first 'Monoid' should be a 'Monad'
13:05:49 <ion> Although a Kleisli monoid also exists, it‚Äôs just more restrictive. :-P
13:06:00 <exio4> Endo generalized to any category 
13:06:25 * bennofs actually would like that sometimes
13:06:36 <bennofs> (generalized endo)
13:07:46 <byorgey> bennofs: http://hackage.haskell.org/package/monoid-extras-0.4.0.0/docs/Data-Monoid-Endomorphism.html
13:08:05 * hackagebot bencode 0.6.0.0 - Parser and printer for bencoded data.  http://hackage.haskell.org/package/bencode-0.6.0.0 (ChristopherReichert)
13:08:20 <bennofs> byorgey: thanks, that package is really useful
13:09:54 <joneshf-laptop> why isn't `Traversable` more popular/important/talked-about than `Functor`?
13:10:12 <ion> joneshf: By what measure?
13:10:14 <bennofs> joneshf-laptop: because Traversable requires Functor so you can understand it? :P
13:11:08 <joneshf-laptop> bennofs, heh, i guess that's a pretty succinct reason
13:12:03 <joneshf-laptop> but it just feels like `Traversable` should get more love than it does
13:12:12 <bennofs> hmm, does Functor and Foldable imply Traversable?
13:12:40 <bennofs> joneshf-laptop: I agree! And if you have traversable, the step to lenses is not that big ... 
13:14:11 <ReinH> bennofs: traversables are foldable are functors
13:14:25 <ReinH> oh I see what you mean
13:14:28 <zacts> what is the haskell off-topic channel?
13:14:34 <indiagreen> #haskell-blah
13:14:37 <zacts> k
13:14:49 <bennofs> ReinH: right, but it seems to me that Functor is "update", Foldable is "get", so Foldable + Functor should suffice to derive a Traversable instance?
13:15:20 <bennofs> maybe there is a condition between fmap and foldMap that you need for this
13:15:45 <bennofs> I guess data Repeat a = Repeat Int a where foldable folds the a the given number of times won't work for this
13:16:05 <ReinH>  bennofs fmap is traverse with Id, foldMap is traverse with Const
13:16:19 <ReinH> traverse is more general than both
13:17:20 <joneshf-laptop> I also feel like `traverse` is closer to imperative stuff than `fmap`
13:17:23 <joneshf-laptop> well `for` anyway
13:17:30 <bennofs> ReinH: yes, but doesn't traverse with Id + traverse with Const fully specify / characterise the traverse function? 
13:17:45 <joneshf-laptop> so it might be easier to grasp?
13:18:04 <joneshf-laptop> or rather, easier to translate algorithms from one to the other
13:18:08 <bennofs> ReinH: basically, Foldable is the 
13:18:29 <bennofs> ReinH: Foldable is the 'get' and Functor is the 'set' in lens terms. If I have 'get' and 'set', I can build a lens
13:18:34 <dmwit> Is there a standard function with type (Foldable t, Alternative f) => t a -> f a?
13:18:47 <bennofs> :t F.asum
13:18:48 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
13:18:51 <dmwit> (It's a one-liner to code up, but I'd prefer to use a standard name if it exists.)
13:18:54 <bennofs> close :)
13:19:03 <dmwit> yeah =)
13:19:06 <bennofs> :t F.asum . fmap pure
13:19:08 <lambdabot> (Functor t, Foldable t, Alternative f) => t a -> f a
13:20:15 <ion> @type foldr ((<|>) . pure) empty
13:20:16 <lambdabot> (Foldable t, Alternative f) => t a -> f a
13:21:17 <indiagreen> :t getAlt . foldMap pure
13:21:18 <lambdabot> (Foldable t, Alternative f) => t a -> f a
13:21:36 <bennofs> :t Alt
13:21:37 <lambdabot> forall (k :: BOX) (f :: k -> *) (a :: k). f a -> Alt f a
13:21:48 <dmwit> indiagreen: Oh, that's my favorite one so far.
13:21:49 <bennofs> that type. what?
13:22:01 <ion> bennofs: hehe
13:22:20 <bennofs> polykinded types ftw!
13:23:27 <indiagreen> dmwit: found it yesterday when thinking about this question from #haskell-lens: ‚ÄúAnybody knows the name of this pattern? http://lpaste.net/132244‚Äù
13:25:35 <athan> bennofs: I suppose you could also make targeting bind functions like >>>=, >>>>=, etc
13:25:59 <athan> also hpc^
13:26:13 <athan> (couldn't you?)
13:28:26 <indiagreen> bennofs: I think the reason you can't get Traversable from Functor and Foldable is that Foldable lets you deconstruct the structure and Functor lets you apply context-independent transformations to it, but to do what Traversable does you also need to reconstruct the structure
13:28:45 <indiagreen> see this answer: http://stackoverflow.com/a/21083521/615030
13:28:55 <Nux__> hi I've noticed some interesting behaviour
13:29:29 <Nux__> >minimum [0, 0/0, 1/0]
13:29:31 <Philippa> indiagreen: sounds about right - you need unfold as well as fold
13:29:37 <Nux__> > minimum [0, 0/0, 1/0]
13:29:39 <lambdabot>  Infinity
13:29:50 <ion> nux: IEEE floats are weird.
13:29:52 <dmwit> ?quote dmwit 754
13:29:52 <lambdabot> dmwit says: For basically all good properties P, IEEE 754 is not P.
13:29:57 <Philippa> and as Foldable is a list-fold not a catamorphism, you're SOL
13:30:04 <Philippa> can't even define the type class properly
13:30:15 <dmwit> > 0/0 < 1/0
13:30:17 <lambdabot>  False
13:30:20 <dmwit> > 1/0 < 0/0
13:30:21 <lambdabot>  False
13:30:31 <dmwit> Congratulations, (<) is not a thing you can use for sorting.
13:30:35 <indiagreen> > (minimum [0, 0/0, 1/0], minimum [0, 1/0, 0/0])
13:30:36 <lambdabot>  (Infinity,NaN)
13:30:38 <ion> > (compare (0/0) (1/0), compare (1/0) (0/0))
13:30:40 <lambdabot>  (GT,GT)
13:31:56 <Nux__> to make my code work, I'm now preventing NaN from occurring
13:32:54 <dmwit> Depending on your performance needs and how important rounding is, you might like Rational.
13:33:14 <bennofs> Philippa, indiagreen: you do not need full unfold, you just need a way to "replace" values. The problem with fmap is that it doesn't allow me to do a "targeted" replace: I cannot replace just the 4th value
13:33:21 <Nux__> I do like Rational
13:33:36 <Nux__> for what I'm doing, it's one of the better choices of Fractional
13:34:00 <Nux__> oh wait, it's not Fractional
13:34:06 <Nux__> that's surprising
13:34:28 <indiagreen> it is Fractional
13:34:33 <indiagreen> ‚ÄúIntegral a => Fractional (Ratio a)‚Äù
13:34:40 <Nux__> ah cool
13:34:43 <indiagreen> it's just that Rational = Ratio Integer
13:35:09 <Nux__> I just did :i Fractional, couldn't see an instance and stopped looking
13:35:32 <homovitruvius> suppose one wanted to present status info about a long running compiler as HTTP pages. Would an embedded snap server be the right solution? alternatives?
13:36:25 <Nux__> indiagreen, so can't I rely on :info telling me directly about all instances of a typeclass?
13:36:57 <ion> It won‚Äôt enumerate all aliases for instance types.
13:37:07 <indiagreen> Nux__: when I import Data.Ratio, :i gives me the instance for Ratio
13:37:08 <dmwit> homovitruvius: That seems reasonable.
13:37:26 <indiagreen> you still have to know that Rational = Ratio Integer, yep
13:38:30 <Nux__> ok
13:39:44 <Nux__> so I could have found out it was a type synonym (if I understand you correctly) looked at ":info GHC.Real.Ratio Integer", seen the "Integral Integer" part and noticed that this requires it to be Fractional?
13:41:41 <Nux__> Does that make sense?
13:41:59 <geekosaur> by :info Rational telling you that it's a type synonym for Ratio Integer, then going back and noticing the Ratio instance for Fractional
13:42:13 <ion> or looking at :i Ratio
13:42:19 <geekosaur> and maybe if you needed it :i Integer to note it's an instance of Integral
13:42:26 <Dynetrekk> hi, is it possible ot have multiple (if/elseif/else) blocks in one if statement?
13:42:35 <ion> MultiWayIf
13:42:47 <Dynetrekk> ion: ok
13:43:03 <Dynetrekk> ion: this? https://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/syntax-extns.html
13:43:16 <ion> yeah
13:43:20 <lokathor> i have successfully created a newtype and used it to make a new instance of a thing
13:43:20 <lokathor> yay
13:43:39 <Dynetrekk> ion: ghc only?
13:43:42 <Nux__> I'm interested, do you literally type ":i Ratio"? because for me that isn't enough and must write ":info GHC.Real.Ratio" instead
13:43:45 <lokathor> but i just used it to make my own Show instance, which probably isn't needed
13:44:04 <Nux__> :i Ratio
13:44:06 <Nux__> Top level: Not in scope: data constructor `Ratio'
13:44:11 <ion> Dynetrekk: Yeah. Or you could nest if expressions. Or use an alternative to ‚Äúif‚Äù such as guards.
13:45:02 <Dynetrekk> ion: guards could be it. just never used it before
13:45:04 <geekosaur> import Data.Ratio
13:45:11 <geekosaur> which was mentioned several minutes agoi
13:46:47 <ReinH> If you need a multiway if, it might be better to represent the choices using a sum type and then use pattern matching
13:46:57 <ReinH> avoids boolean blindness, adds more information to the type system
13:48:26 <Dynetrekk> ReinH: I want to switch based on whether x<y<z, y<x<z, z<y<x (i.e. which is smallest)
13:49:06 <ReinH> Can you give a little more information about what you do with them?
13:49:31 <Dynetrekk> ReinH: I've got 3 lists and want to track identical items. https://projecteuler.net/problem=45
13:49:53 <Dynetrekk> ReinH: so in an imperative langauge, I'd increment the counter of whichever list "head" is the smallest
13:50:28 <dmwit> Dynetrekk: http://hackage.haskell.org/package/data-ordlist
13:51:06 <Dynetrekk> dmwit: does a set make sense here? is it lazy to create a set?
13:51:40 <dmwit> This kind of set is very lazy, yes.
13:51:51 <dmwit> As lazy as lists. In fact, it *is* a list.
13:52:45 <Dynetrekk> dmwit: sounds great!
13:52:58 <Dynetrekk> dmwit: but now I need to download and isntall a module?
13:53:03 <Dynetrekk> dmwit: or is it in haskell platform_
13:53:05 <Dynetrekk> ?
13:53:11 * dmwit shrugs indifferently
13:53:20 <dmwit> It's not so hard to type "cabal install data-ordlist".
13:53:31 <Dynetrekk> dmwit: ok. I don't know cabal
13:54:33 <Nux__> If I want to prevent users of my module from using the default data constructor for one of my types (at the same time exporting my own specialized data constructors) do I have to forfeit allowing the same users to do pattern matching on that type?
13:57:13 <Smallish> hey is this a haskell beginner friendly channel?
13:57:16 <Dynetrekk> cabal update ran out of RAM. woppi do.
13:57:33 <cite-reader> Smallish: We try to be!
13:57:49 <rotten_bunny> hello 
13:57:58 <Nux__> hi
13:58:27 <Smallish> cite-reader: sweet, I'm a brand new programmer and I have lots of questions
13:58:57 <Nux__> dmwit, geekosaur, ion: any thoughts on the above?
13:59:45 <rotten_bunny> somehow my posts aren't showing 
14:00:32 <Dynetrekk> Smallish: in my attempts to learn programming, I've found the python and haskell communities the most helpful, as well as the most enjoyable languages
14:00:57 <quchen> Nux__: If you have access to the data constructor, you can match and construct, and you cannot avoid this in Haskell. Pattern synonyms, a recent GHC extension, might be worth having a look at in this context.
14:01:42 <Nux__> quchen, thanks I'll have a look
14:01:54 <quchen> Nux__: GHC docs on them: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#pattern-synonyms
14:02:36 <Smallish> dynetrekk: If I start with haskell will i be stunted in any way as far as programming goes?
14:03:02 <cite-reader> It's pretty unlikely.
14:03:04 <Dynetrekk> Smallish: I wouldn't worry. Just stay far away from Fortran or Cobol and you'll be good
14:03:18 <cite-reader> Even Fortran still has a place.
14:03:23 <ion> Nux: pattern Foo x <- RealFoo x where Foo x = yourSmartConstructor x or something like that.
14:03:31 <Dynetrekk> cite-reader: yes, and that place is far from a first language for a new programmer
14:03:39 <Dynetrekk> cite-reader: I do use it myself, much more so than haskell
14:03:44 <cite-reader> Okay, sure.
14:05:19 <Nux__> ion, I might be reading that wrong, but do you mean to say you can pattern match on smart constructors?
14:05:54 <ion> Nux: The where block specifies what to do when you try to use the pattern synonym as a function.
14:07:12 <quchen> Nux__: In ion's example, "Foo" will behave as if it was "RealFoo" when you use it for matching, and like "yourSmartConstructor" when using it as a (data constructor) function.
14:08:15 * hackagebot nested-routes 1.0 - Declarative, compositional Wai responses  http://hackage.haskell.org/package/nested-routes-1.0 (athanclark)
14:09:33 <athan> woo - lot simpler api
14:15:17 <Nux__> quchen, ion, I must not be following you. Can I get a working example?
14:16:07 <ion> @let pattern Head x <- x:_ where { Head x = [x] }
14:16:07 <lambdabot>  Parse failed: TemplateHaskell is not enabled
14:16:31 <Nux__> ok so I didn't realise 'pattern' was being used as actual syntax
14:16:36 <Nux__> that's my first confusion
14:17:02 <Nux__> does that exist as part of the extension you referred to quchen?
14:17:13 <ion> PatternSynonyms
14:17:34 <pharpend> How do I manually upload docs to Hackage?
14:17:52 <Nux__> I see
14:18:15 * hackagebot eventstore 0.7.1.0 - EventStore TCP Client  http://hackage.haskell.org/package/eventstore-0.7.1.0 (YorickLaupa)
14:18:17 * hackagebot editor-open 0.3.0.0 - Open the user's $EDITOR for text input.  http://hackage.haskell.org/package/editor-open-0.3.0.0 (pharpend)
14:18:26 <ReinH> pharpend: well, lens uses https://github.com/ekmett/lens/blob/master/scripts/hackage-docs.sh
14:18:39 <homovitruvius> dmwit: I'm now playing w/ warp that seems a bit more lightweight and in my case I won't have templates in external files so it seems adequate. One think I'd like to do is to serve ekg pages from the warp server without listening (and using) a second port. On the other hand, I'll have to serve static content as javascript and css and maybe a full snap server is not bad to have. So I'll play around with both options over the we
14:18:40 <homovitruvius> then toss a coin
14:19:03 <glguy> You can use the lens script without modification, too.
14:19:30 <ReinH> glguy: o/
14:19:37 <pharpend> thanks ReinH 
14:19:46 <pharpend> glguy: I saw you are the last to edit it
14:20:00 <glguy> Yeah, and first ;-)
14:20:01 <pharpend> glguy: It looks generic enough, I can just drop it into my repo's scripts/ dir?
14:20:28 <glguy> Doesn't bother me
14:20:38 <glguy> It probably won't change
14:21:16 <pharpend> Well, it's BSD-licensed, so I would assume it's okay to copy it... I was asking whether there was any lens-specific stuff in it, or if I can just plug & play
14:22:18 <pharpend> It doesn't look like it has lens specific stuff
14:22:21 <pharpend> but who knows
14:23:06 <glguy> If you use the BSD license to copy it you'd have to copy the license over, too. But you can just copy it. It's not lens specific
14:24:06 <pharpend> glguy: The BSD license allows sublicensing. My library is Apache, which also allows relicensing, so I'll just use the license in my repo
14:24:27 <glguy> You still have to preserve the notice with bsd
14:24:35 * pharpend goes to read the BSD license
14:25:42 <pharpend> glguy: http://ix.io/isx how about this
14:26:25 <pharpend> yep, you're right
14:26:31 <glguy> That's fine
14:26:57 <glguy> I don't particular care, I'm just speaking generally about using BSD license to do stuff
14:27:03 <pharpend> Thanks
14:27:17 <ReinH> glguy: did you all sign a copyright agreement that gives edwardk copyright? ;)
14:27:29 <pharpend> heh
14:27:39 <pharpend> ReinH: I don't think edwardk operates like the FSF
14:28:11 <ReinH> Well, it probably doesn't matter in any real way, but he does claim copyright and I was curious
14:28:22 <ReinH> I've been involved with open source projects that *do* require a CLA
14:28:29 <glguy> No
14:29:03 <pharpend> I tend to stay away from projects requiring a CLA. Those people IME tend to be way too concerned about project politics
14:29:05 <ReinH> I suppose "Copyright 2012-2015 Edward Kmett and hundreds of other people" doesn't have the same ring to it...
14:29:17 <ReinH> pharpend: well, sometimes they're concerned about the actual legal ramifications.
14:29:20 <ReinH> because they are businesses
14:29:26 <pharpend> ReinH: well, it's why we don't use BSD-4 anymore
14:29:36 <glguy> I want people to be able to use the code I write. I'm not interested in license games
14:29:44 <ReinH> glguy: me neither, I was just curious
14:30:01 <TrueMagnap> Ignoring all the bullshit about "every software engineer should be able to solve these arbitrary problems" and focusing on the problems itself, how would you guys solve problem 5 in this link (https://blog.svpino.com/2015/05/07/five-programming-problems-every-software-engineer-should-be-able-to-solve-in-less-than-1-hour) (without something eval-like)? I tried doing something with WriterT String [] Int,
14:30:07 <TrueMagnap>  but eventually gave up when I realized that the "nothing" function would have to look at the functions used before it
14:30:28 <pharpend> TrueMagnap: 404
14:30:38 <ReinH> TrueMagnap: Richard Bird solves the (+, *) version very elegantly in Pearls of Functional Algorithm Design
14:30:43 <ion> pharpend: Worksforme‚Ñ¢
14:30:52 <ReinH> It would also apply to the (+,-) version
14:31:03 * pharpend still uses the official RFC regex for his URL's, which copies the )
14:31:06 <glguy> It looks like #5 doesn't specify the use of ()s so it's a little simpler
14:31:38 <ReinH> glguy: It doesn't need to because + and - have the same precedence
14:31:49 <ReinH> (obviously)
14:31:57 <ion> Someone posted a Haskell solution to that a day or two ago here. I don‚Äôt remember who.
14:32:10 <ReinH> It's chapter 6 of Bird's book
14:32:15 <ReinH> which you should read anyway because it is amazing
14:32:25 <glguy> Reinh : 1-(2+3). 1-2+3
14:32:32 <Haskellfant> I still have that lying around but haven't yet managed to read it
14:32:46 <ReinH> glguy: sorry I am stupid
14:33:07 <ReinH> please forgive me
14:33:13 <pharpend> TrueMagnap: Start with the simplest pattern, "123456789", then check "1+23456789", "12+3456..." eliminate those that don't add up to 100
14:33:19 <glguy> Ha.ok
14:33:33 <ion> It was Artyom. http://lpaste.net/132240
14:34:02 <TrueMagnap> ReinH: does it work with the combining too? In the solution I made, "plus combine" ended up meaning 33 ((1+2)3) instead of 24 (1+23)
14:34:05 <pharpend> TrueMagnap: essentially, write some sort of function to list out all of the patterns, then use "filter (\x -> (read x) == 100)"
14:34:22 * pharpend can't remember if filter takes matches, or drops matches
14:34:30 <Iceland_jack> > filter even [0..]
14:34:31 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
14:34:32 <platz> this problem appears to have  additional constraints compared to the countdown problem
14:34:42 <platz> the source numbers cannot be re-ordered
14:35:36 <platz> actually maybe the countdown soln doesn't re-order them either, would have to check
14:36:17 <TrueMagnap> The combination is what I found to be the biggest issue. Adding, then combining, should be 1+23, but since I kept only the result, it turned into putting a 3 after (1+2) which is 33
14:37:11 <pharpend> TrueMagnap: that guy is being a dick by saying "every programmer should be able to solve these problems". It's something he's saying to make himself feel better because he can solve them, and he knows others probably can't
14:37:38 <pharpend> TrueMagnap: I've been programming for about 10 years, and I had to think about that last one for a second. 
14:38:19 <TrueMagnap> pharpend: I know, which is why I wrote that disclamer about ignoring the bullshit
14:38:59 <Nux__> quchen, ion, PatternSynonyms does seem to do what I'm after, but I'm wary of using extensions as I'm new to haskell and don't want to come to rely on them
14:39:40 <TrueMagnap> ion: That solution works, and is very elegant (IMO). I'll now set about trying to grok it ;-)
14:39:41 <pharpend> TrueMagnap: I'm not even sure my solution would work. If it did, it would be horribly inefficient
14:40:11 <Nux__> quchen, ion: where extensions are avoided, would it be typical to simply give the user access to the data constructors and warn them of their use?
14:40:32 <Iceland_jack> Nux__: You should not be wary of using extensions, you should try some extensions out at least once even if you don't intend to use them in the near future
14:40:47 <TrueMagnap> pharpend: I think that's what the solution ion posted does, it's at http://lpaste.net/132240 and by Artyom
14:41:04 <Iceland_jack> Pattern synonyms in it's simplest form is a very simple extension, as are many other extensions
14:41:18 <pharpend> Nux__: Extensions are great! I use OverloadedStrings and LambdaCase in pretty much all of my projects
14:41:29 <TrueMagnap> ReinH: thanks for the recommendation, I'll put it on my "to read" list
14:41:50 <Iceland_jack> Nux__: Many of them are simple syntactic changes
14:42:09 <pharpend> Nux__: They are only "bad practice" if you are super-concerned about portability, because GHC isn't the most portable compiler in the world
14:42:14 <exio4> you could end enabling RankNTypes and GADTs before writing any code though! :p
14:42:17 <pharpend> Nux__: MultiWayIf is also a godsend
14:42:28 <Iceland_jack>     ghci> 0b10
14:42:28 <Iceland_jack>     ... error ...
14:42:28 <Iceland_jack>     ghci> :set -XBinaryLiterals
14:42:28 <Iceland_jack>     ghci> 0b10
14:42:31 <P4Titan> Hello all, is there a way to take a Parsec parser and given a SourcePos, basically "fast-forward" the parser so that its state is at the source position
14:42:31 <Iceland_jack>     2
14:42:55 <Iceland_jack> Nux__: Look at that simple GHCi session excerpt, quite simple to understand what the extension BinaryLiterals does
14:44:06 <ion> Dynetrekk: I ended up writing a solver for the Euler problem for fun. Did you have success with it?
14:44:35 <TrueMagnap> ion: Which one?
14:44:38 <Nux__> Iceland_jack, pharpend: ok thanks. I guess I was put off by portability warnings. I'll be more experimentative and use what seems to help me then.
14:44:47 <ion> TrueMagnap: https://projecteuler.net/problem=45
14:45:20 <Philippa> P4Titan: yeah, you'd have to write code to eat it's way through the input stream until that sourcepos but you can set the current input stream
14:45:38 <Philippa> relevant functions're in the primitives module IIRC
14:45:56 <TrueMagnap> Nux__: Trust me, OverloadedStrings is an absolute godsend
14:45:59 <ion> Spoiler alert. Euler 45 https://gist.github.com/ion1/30b1215f03d7aa0d4cfa
14:46:51 <Iceland_jack> Nux__: A lot of exciting things are happening in the world of Haskell/GHC, if you exclusively code using the Haskell 2010 language report you miss out on some of the best parts of the language!
14:47:04 <P4Titan> Philippa: Is there a better way to do that?
14:47:12 <ion> over
14:47:14 <ion> whoops
14:47:20 <Iceland_jack> The reports evolve very slowly and the language evolves very rapidly :)
14:47:25 <P4Titan> Than to make out own eating function?
14:47:33 <Philippa> not that I'm aware of
14:48:47 <Philippa> it's even worse if you want to say "give me the parsing state I'd have if I parsed up until...", though there are ways to do it using ContT
14:53:16 * hackagebot pgdl 8.2 - simply download a video from webpage and play it.  http://hackage.haskell.org/package/pgdl-8.2 (sifmelcara)
15:07:46 <pharpend> Nux__: the only one to be weary of it TemplateHaskell, but even that is safe 80% of the time
15:21:31 <TrueMagnap> What is your preferred way of parsing HTML? I'll be extracting some information from a table on a site
15:22:25 <td123_> TrueMagnap: unless it's simple, avoid regex :)
15:22:59 <fread2281> what's the state of push-based frp (that is, is there an implementation more efficient than spawning a bunch of threads)?
15:23:12 <zacts> hehe, I used to try to parse HTML with Perl regex years ago
15:23:21 <zacts> I was naively ignorant about the matter
15:23:48 <athan> TrueMagnap: HXT :)
15:24:09 <athan> You'll have to learn arrows, but it's way worth it
15:24:24 <TrueMagnap> td123: https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags
15:24:37 <TrueMagnap> td123: I knew that ;)
15:24:55 <geekosaur> html is usually such a disaster that tagsoup is often the only thing that works...
15:25:27 <kadoban> Can anyone help me read this profiling output. I can't seem to figure out what it means. Does it mean that handleInput.tally is itself doing all of the allocation? I don't ‚Ä¶ understand how that could be. http://lpaste.net/7014635682698100736 is the code and the profile output, and https://www.hackerrank.com/challenges/superman-celebrates-diwali is the problem description and input format.
15:25:30 <TrueMagnap> athan: Thanks, I'll get on it. Is there something like "You could have invented Arrows"? I loved that monad tutorial
15:25:55 <athan> TrueMagnap: Yes, there's one blog post that really helped me, one sec
15:26:18 <geekosaur> kadoban, that often means that it's what's forcing lazy thunks
15:26:42 <athan> TrueMagnap: http://adit.io/posts/2012-03-10-building_a_concurrent_web_scraper_with_haskell.html
15:28:17 * hackagebot hjcase 0.2.0.0 - Jcase library for Haskell  http://hackage.haskell.org/package/hjcase-0.2.0.0 (seagreen)
15:28:45 <TrueMagnap> athan: Thank you so much. Looking forward to learning something new
15:28:53 <athan> TrueMagnap: np!!
15:29:48 <kadoban> geekosaur: Hmm. Is there a way to trick it into telling me ‚Ä¶ what thunks or something? I'm handling odd input in ‚Ä¶ not a very sane way and I don't really know how to do it better I suppose, heh.
15:30:32 <Nux__> > let xs = map fromRational (take 10 (0:0.1:(map (+ 0.1) (tail xs))))
15:30:34 <lambdabot>  <no location info>:
15:30:35 <lambdabot>      not an expression: ‚Äòlet xs = map fromRational (take 10 (0:0.1:(map (+ 0....
15:31:12 <TrueMagnap> geekosaur: I tried using TagSoup, but eventually gave up. I just couldn't get it structured the right way, not even with the tree functions. I actually had some (horribly ugly) code working, but then found out that the page I was testing on (saved from my browser) was slightly different from the one sent by the server, so when I got the download to work, my parser function broke
15:31:22 <Nux__> > fromRational 0.1
15:31:24 <lambdabot>  0.1
15:31:41 <TrueMagnap> > map fromRational (take 10 (0:0.1:(map (+ 0.1) (tail xs))))
15:31:42 <lambdabot>      Not in scope: ‚Äòxs‚Äô
15:31:42 <lambdabot>      Perhaps you meant one of these:
15:31:42 <lambdabot>        ‚Äòx‚Äô (imported from Debug.SimpleReflect),
15:31:57 <TrueMagnap> > let xs = map fromRational (take 10 (0:0.1:(map (+ 0.1) (tail xs)))) in xs
15:31:59 <lambdabot>  [0 % 1,1 % 10,1 % 5,3 % 10,2 % 5,1 % 2,3 % 5,7 % 10,4 % 5,9 % 10]
15:32:07 <Nux__> ah
15:32:23 <Nux__> of course
15:32:33 <geekosaur> TrueMagnap, those are the pages that often need tagsoup, yes. the problem is it's not really a tree
15:32:47 <geekosaur> html in the wild cannot be relied on to be tree structured. or sane
15:33:09 <geekosaur> your browser is "fixing" it to the extent it can, which is why it differs from the raw html
15:33:14 <Nux__> I'm unsure as to why the above is inferred to be [Rational] when I run from a source file
15:33:28 * pharpend is sad because hackagebot didn't announce his package
15:33:41 <Nux__> should it be (Fractional a) => [a]?
15:34:13 <indiagreen> pharpend: I can announce your package
15:34:20 <ion> Nux: Try {-# LANGUAGE NoMonomorphismRestriction #-}
15:34:28 <geekosaur> kadoban, I'm not really good at this, I just know laziness often leads to that. sometimes annotating with ($!) (apply-with-seq) or bang patterns can help break things apart
15:34:29 <pharpend> heh
15:34:49 <pharpend> indiagreen: Hackagebot isn't known as being fast, but it was like half an hour ago
15:34:52 <Nux__> ion, thanks
15:34:57 <kadoban> geekosaur: Okay thanks
15:34:58 <TrueMagnap> Nux: Rational a is Fractional, so it doesn't "change"
15:35:23 * indiagreen looks at the logs
15:35:31 <indiagreen> actually, http://ircbrowse.net/browse/haskell?id=20634573&timestamp=1431206275#t1431206275
15:35:50 <indiagreen> but let's announce it again
15:36:00 <indiagreen> ta-da-da-da-da, editor-open 0.3.0.0 - Open the user's $EDITOR for text input. http://hackage.haskell.org/package/editor-open-0.3.0.0 (pharpend)
15:36:03 <pharpend> indiagreen: oh wow, it was really fast
15:36:13 <pharpend> indiagreen: it usually takes 5 minutes or so
15:36:40 <pharpend> indiagreen: weechat usually tells me about hackagebot announces
15:36:49 <geekosaur> it polls every couple minutes (probably 5)
15:37:04 <geekosaur> if it happens to poll immediately after you uploaded it and it got into the index...
15:38:48 <Nux__> TrueMagnap, ion: My issue is that I want to use something like "let xs = map fromRational (take 10 (0:0.1:(map (+ 0.1) (tail xs)))) in xs" to produce a list of Floats rather than starting with floats and getting accumulation of error
15:40:01 <geekosaur> then you'll need something like   let xs :: Float; xs = ... in
15:40:54 <Nux__> > let xs :: [Float]; xs = map fromRational (take 10 (0:0.1:(map (+ 0.1) (tail xs)))) in xs
15:40:55 <lambdabot>      Couldn't match type ‚ÄòFloat‚Äô with ‚ÄòRatio Integer‚Äô
15:40:55 <lambdabot>      Expected type: [Rational]
15:40:55 <lambdabot>        Actual type: [Float]
15:41:13 <geekosaur> :t fromRational
15:41:14 <lambdabot> Fractional a => Rational -> a
15:41:33 <geekosaur> this seems wrong somehow
15:41:49 <ion> You‚Äôre applying fromRational to tail xs
15:41:54 <ion> (map fromRational)
15:42:40 <ion> > let xs :: [Float]; xs = map fromRational (iterate (+0.1) 0) in xs
15:42:41 <lambdabot>  [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8...
15:43:18 * hackagebot nested-routes 1.0.0.1 - Declarative, compositional Wai responses  http://hackage.haskell.org/package/nested-routes-1.0.0.1 (athanclark)
15:44:16 <athan> if you were making shorthand things, should <$$> = fmap . fmap or fmap . Compose?
15:44:28 <Nux__> I'm a little confused. So fromRational was applied to an element of xs, which in turn determined the elements of xs to be Rational?
15:44:52 <ion> Nux: Indeed
15:44:57 <Nux__> So it was effectively undoing it's own work?
15:45:14 <ion> I guess you could say so.
15:45:18 <TrueMagnap> Nux: Are you doing this in ghci?
15:45:29 <Nux__> yes
15:45:56 <TrueMagnap> Then keep it as a [Rational] and map fromRational "in situ"
15:46:21 <nd> hi everybody. can I use lambdabot to show me point free versions of multi-line functions?
15:46:36 <ion> nd: Combine the lines first.
15:46:56 <nd> you mean using ; ?
15:47:21 <ion> I‚Äôm not sure @pl even supports anything with ; (or the equivalent layout).
15:47:41 <athan> :t fmap . fmap
15:47:42 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:47:44 <nd> ion: I don't think I can combine them since I am pattern matching:
15:47:48 <athan> :t fmap . Compose
15:47:49 <lambdabot>     Not in scope: data constructor ‚ÄòCompose‚Äô
15:47:49 <lambdabot>     Perhaps you meant variable ‚Äòicompose‚Äô (imported from Control.Lens)
15:47:55 <dfeuer> What do you call something where you can exchange the type constructors?  Like ... if I have a representation of an expression in the Maybe monoid, I can convert that to Maybe an expression in the underlying semigroup.
15:47:59 <athan> :t fmap . (Data.Functor.Compose)
15:48:00 <lambdabot>     Not in scope: data constructor ‚ÄòData.Functor.Compose‚Äô
15:48:01 <TrueMagnap> Nux: "let xs = map fromRational (0:0.1:(map (+ 0.1) (tail xs))); map fromRational xs :: [Float]" works for me
15:48:03 <athan> mer
15:48:17 <dfeuer> athan, rem.
15:48:32 <ion> dfeuer: You‚Äôre not talking about natural transformations, are you?
15:48:37 <athan> dfeuer: Do you think stuff liek that would be handy?
15:48:39 <dfeuer> ion, I have no idea :-)
15:48:53 <athan> I want to have different composition ops for monads, too
15:48:59 <athan> er, more
15:49:30 <ion> athan: I would find (fmap . fmap), (fmap . fmap . fmap) useful more often than anything with Compose, FWIW.
15:49:45 <dfeuer> ion, I'm trying to come up with a "nice" way to reassociate expressions and collapse monoid neutrals so the process will be, to the extent possible, obviously correct.
15:49:50 <athan> ion: Same :)
15:49:59 <athan> I'm gonna see if I can add them to the composition package
15:50:06 <athan> also with contravariant stuff, too
15:50:32 <athan> I feel like I'm getting borderline close to lens, though
15:50:33 <athan> who knows
15:50:52 <dfeuer> ion, I've set up the reassociation stuff in terms of free magmas and free semigroups in a way that strikes me as *reasonably* okay, but I dunno how the algebra goes to take me to monoids....
15:51:05 * dfeuer is about to run to dinner.
15:51:06 <dfeuer> Like now.
15:51:09 <dfeuer> Laters.
15:51:18 <Nux__> TrueMagnap, yes and for me though the 'fromRational' in the let part is making xs [Rational] counterintuitively
15:51:36 <Nux__> it makes sense now I think about it
15:51:42 <athan> dfeuer: eat some for me!
15:51:42 <TrueMagnap> This is one of those humbling moments where #haskell just suddenly escalates into something way over my head. Free magmas? Semigroups? I am so lost
15:51:55 <dfeuer> TrueMagnap, free magma = binary leaf tree.
15:51:59 <TrueMagnap> Nux: Yeah, ghci doesn't always make sense that way
15:52:00 <ion> Nux: Type inference always ‚Äúflows‚Äù both ways.
15:52:03 <dfeuer> Trubydoor, free semigroup = non-empty list.
15:52:07 <dfeuer> er...
15:52:15 <glguy> TrueMagnap: Don't worry too much, you don't need any of that to be productive
15:52:15 <dfeuer> I meant TrueMagnap there.
15:53:02 <dfeuer> glguy, the fact that it *is* a free ____ is unimportant. The fact that it *has the properties of* a free ____ is useful.
15:53:46 <ion> TrueMagnap: Semigroup is just a set (or a Haskell type) along with an associative binary operation, such as (++) on lists or (+) or (*) on numbers.
15:54:25 <ion> TrueMagnap: Add an identity element (such as [], 0 and 1 respectively) and you have a monoid.
15:54:32 <TrueMagnap> dfeuer: Not that I don't appreciate the help, but, to use an analogy, if you've never heard of recursion, you won't figure out foldr from being told that recursion is a function calling itself
15:54:39 <TrueMagnap> ion: I was just about to ask that
15:54:45 <TrueMagnap> (the monoid thing)
15:55:48 <TrueMagnap> Finally I can pull out some jargon! So a MonadPlus is to a Monad as a Monoid is to a Semigroup?
15:56:50 <ion> MonadPlus is a class of monoids, the equivalent semigroup would be MonadPlus without mzero.
15:58:25 <Nux__> I think TrueMagnaps analogy was confounded by MonadPlus being a monoid
15:58:38 <fread2281> MonadPlus is to Monad as Monoid is to Monad
15:59:02 <athan> fread2281: I'm not sure about that
15:59:11 <athan> I feel like that would be Writer
15:59:26 <athan> er wait
15:59:31 <athan> no you're right ._.
16:00:05 <athan> wouldn't it rather be Monoid is to Elements?
16:01:26 <Nux__> I think TrueMagnap was speaking of the relation "has an identity but is otherwise"
16:02:53 <fread2281> (Monad f => Monoid (f a)) ~ MonadPlus f
16:02:56 <TrueMagnap> I was thinking in terms of added structure. You can get a MonadPlus from a Monad by defining mplus and mzero, and you can get a monoid from a semigroup by defining mzero
16:04:49 <fread2281> TrueMagnap, you can get a MonadPlus from a Monad by defining mplus and mzero, you can get a Monoid from anything by defining mplus and mzero
16:05:42 <Nux__> there's a bit of confusion going on here between maths usage and haskell usage methinks
16:07:05 <TrueMagnap> fread2281: I agree. I forgot that Monads don't come with mplus
16:07:31 <bananagram> fread2281, for Monoid you mean mempty and mappend
16:07:34 <TrueMagnap> Nux: I try to migitate that by using capital letters for types and typeclasses
16:07:40 <fread2281> bananagram, yes
16:08:13 <TrueMagnap> A rose by any other name...
16:08:18 * hackagebot composition 1.0.1.1 - Combinators for unorthodox function composition  http://hackage.haskell.org/package/composition-1.0.1.1 (DanBurton)
16:08:41 <geekosaur> they're not quite identical actually. mappend and mplus on Maybe do different things
16:10:28 <TrueMagnap> geekosaur: You're right. And they have differrent uses too. Sorry for mixing them up
16:13:38 <Fuuzetsu> > show (8 :: Word32)
16:13:40 <lambdabot>  "8"
16:13:50 <Fuuzetsu> is there a formatter somewhere that will spit out the binary representation?
16:14:21 <ion> > binary # 8
16:14:22 <lambdabot>  "1000"
16:14:32 <TrueMagnap> geekosaur: I guess that's what I get for always thinking about categories in terms of []
16:14:42 <Fuuzetsu> where is ‚Äòbinary‚Äô from?
16:15:05 <fread2281> :t binary
16:15:06 <lambdabot> (Integral a, Applicative f, Choice p) => p a (f a) -> p String (f String)
16:15:12 <Jermstew> anyone here really good with php and sql that'd be willing to help me with something
16:15:12 <fread2281> lens
16:15:13 <Fuuzetsu> looks like lens
16:15:16 <Jermstew> :)
16:15:47 <TrueMagnap> Numeric.Lens
16:16:13 <Fuuzetsu> yep, got it
16:16:40 <ion> > showIntAtBase 2 digitToInt 8 ""
16:16:41 <lambdabot>      Couldn't match type ‚ÄòInt‚Äô with ‚ÄòChar‚Äô
16:16:42 <lambdabot>      Expected type: Int -> Char
16:16:42 <lambdabot>        Actual type: Char -> Int
16:18:05 <ion> > showIntAtBase 2 intToDigit 8 ""
16:18:06 <lambdabot>  "1000"
16:18:53 <erisco> guys
16:19:00 <erisco> I figured out a great idea over on -blah
16:19:44 <ion> Fuuzetsu: If you don't want a lens dependency, that's base.
16:19:59 <erisco> instead of "unsafe" which is an unwieldly 6 characters, lets use "yolo" instead. i.e. yoloCoerce, yoloPerformIO, and so on
16:20:13 <abhillma2> Suppose I have a module with a bunch of imports like Data.Text, Data.Maybe, ... etc. -- but that I only use one or two functions from each import. I can write import Data.Maybe (isJust, isNothing). But in a large module, it can be time consuming to find the minimum functions from each import that must be included. One manual algorithm is to remove each import at a time, compile, and look at the reason w
16:20:19 <abhillma2> hy the compilation failed (i.e. a list of functions that must be imported). Is there a way to automate this process? Thanks in advance!
16:20:22 <erisco> it will attract the younger crowd!
16:20:53 <grpala> erisco: I don't think younger crowd that's attracted to such thing would do any good to this or any community whatsoever
16:21:06 <timothyh> hm. what's the best option for an arbitrary-size natural? right now I have a newtype over Integer :(
16:21:11 <Cale> abhillma2: I usually don't bother with that, because if you're using some operations from a module, it stands to reason that future code will very likely need more from the same.
16:21:58 <lpaste> Nils revised ‚ÄúBrainfuck in haskell‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/132309
16:22:14 <TrueMagnap> timothyh: I think that's the best option until we get dependent types. But I'm pretty new at Haskell, so I hope to be corrected
16:22:20 <lpaste> Nils revised ‚ÄúBrainfuck in haskell‚Äù: ‚ÄúBrainfuck in haskell‚Äù at http://lpaste.net/132309
16:22:35 <timothyh> i am kinda surprised that maybe GMP doesn't export such a thing
16:22:45 <TrueMagnap> Cale,abhillma2: I just always import everything qualified
16:22:53 <abhillma2> Cale: Fair enough
16:22:59 <abhillma2> TrueMagnap: Makes sense -- makes things easier to track down
16:23:08 <Cale> There are certain things I import qualified, but most things I don't.
16:23:21 <timothyh> and failing that, a newtype wrapper for unbounded nats seems like a Prelude candidate
16:23:27 <abhillma2> In general, is there any kind of "reflection" that would allow writing a program to do this kind of work?
16:23:29 <Cale> There are certain libraries which essentially must be imported qualified -- most of the container libraries for instance.
16:23:37 <SparkySparkyBoom> bitemyapp: i think hnofficehours is broken
16:23:41 <TrueMagnap> Cale,abhillma2: Except for operators of course
16:23:43 <abhillma2> * that could enable a program to do this sort of work
16:23:47 <Cale> Yeah, operators and types
16:24:03 <Cale> I *hate* writing qualified names in types for some reason, I can't really explain why :)
16:24:04 <TrueMagnap> Cale: actually, I like having my types qualified. Not sure why
16:24:08 <abhillma2> Cale: Interesting -- I'll look into that
16:24:37 <TrueMagnap> Cale: Guess it comes down to taste
16:25:07 <Cale> abhillma2: You might be able to use hint, or the GHC API directly
16:25:14 <abhillma2> Cale, TrueMagnap: It's kind of interesting how qualified/not qualified preferences differ between languages. Python programmers tend to avoid "from x import *" which is similar to what occurs when you write "import X" in Haskell, of course
16:25:23 <fread2281> so sodium says it's push-based, how do I call http://hackage.haskell.org/package/sodium-0.11.0.3/docs/FRP-Sodium.html#v:sync ?
16:26:22 <ion> timothyh: There's Numeric.Natural in base.
16:26:59 <Cale> abhillma2: Yeah, there are definite cultural differences there.
16:27:04 <timothyh> oh thank goodness
16:27:06 <timothyh> thanks ion 
16:27:27 <Cale> abhillma2: One thing which I think influences this is that in Haskell, it is very very common to have GHCi open while you're working on code
16:27:45 <timothyh> oh, brand new!
16:27:46 <Cale> abhillma2: and it helps when you're testing that your code works to have the whole modules open
16:28:19 <Cale> abhillma2: because you might need to construct new values of the types involved for testing in some way that your code itself doesn't need
16:28:42 <TrueMagnap> And that leads to importing whole modules
16:29:22 <TrueMagnap> Another thing I like about importing qualified is that you can write e.g. DL.permutations instead of Data.List.permutations
16:29:34 <Cale> Another thing is that it's just really unfortunate that the module paths are specified with '.'
16:29:58 <Cale> I honestly really hate that. It makes compositions harder to read than necessary
16:30:09 <hodapp> I tend to do either 'import qualified' or import Foo (bar1, bar2...)'.
16:30:09 <grpala> Cale: what would you use instead?
16:30:20 <TrueMagnap> Cale: don't you have spaces in your compositions?
16:30:21 <grpala> / ?
16:30:29 <Cale> TrueMagnap: yes, but even so
16:30:51 <Cale> grpala: Perhaps '|', though I'm not sure about that one either.
16:31:02 <Cale> It's true that there aren't many options
16:31:18 <TrueMagnap> True, it is a bit of noise. But I'm not sure what a better alternative would be. Most other characters are too "big"
16:31:25 <Cale> Data|List|permutations
16:31:28 <Cale> hmm
16:31:35 <ion> Was it ` that Perl lets you use? :-P
16:31:39 <TrueMagnap> It looks... ok
16:32:04 <TrueMagnap> Data'List'Permutations ?
16:32:22 <ion> Data`List`permutations
16:32:27 <grpala> Data~List~Permutations
16:32:41 <Cale> While we're at it, I think Data and Control should never have come into existence.
16:32:53 <grpala> why?
16:32:59 <Cale> It's like having *two* miscellaneous junk drawers.
16:33:00 <abhillma2> What is the status quo on using the FlexibleInstances/OverlappingInstances language extensions to implement the show type class for type synonyms? For example type Row = [Maybe Int] -- then a show type class instance on Row to pretty pretty Rows
16:33:01 <ion> Data‚ô°List‚ô°permutations
16:33:16 <fread2281> Data.Functor vs Control.Monad for example
16:33:21 <grpala> ion: my font (terminus) doesn't contain that symbol
16:33:25 <TrueMagnap> ion: I like my version better. Mainly because ` is a pain to type for me ;)
16:33:53 <ronh-> is it possible to upset update nested fields with record update syntax?
16:34:19 <ronh-> data Foo = Foo { bar :: Bar }   data Bar = Bar { x :: Int }.  given Foo object, how can I update "x"?
16:34:52 <Cale> foo { bar = bar foo { x = 6 } }
16:35:06 <Cale> If you have to do enough of that, eventually you'll reinvent lenses
16:35:09 <Fuuzetsu> gets nastier if updated depends on x‚Ä¶
16:35:14 <Fuuzetsu> update*
16:35:24 <enthropy> abhillma2: it's a problem in that somebody else might decide  type Indexes = [Maybe Int] can't also have a custom overlapping show instance in scope at the same time
16:36:23 <Cale> abhillma2: You can't implement classes separately for type synonyms
16:36:54 <ronh-> hoped for a nicer syntax.. but I think I'll manage with that for now.
16:37:27 <ion> TrueMagnap: Offtopic, but i love the US International (AltGr dead keys) layout. It lets you replace keyboard acrobatics for symbols with keyboard acrobatics for umlauts. I have found that to be a good compromise since i type a lot of symbols and a significant part of my typed human language is in English.
16:37:43 <Cale> ronh-: Yeah, lenses give you nicer ways to do that, like  set (bar . x) 6
16:38:03 <ronh-> Cale yeah I know.. but probably not worth using them if I only do it in one or two plces
16:38:07 <Cale> right
16:38:52 <Cale> ion: I bind my Caps Lock key to Compose.
16:39:04 <abhillma2> Cale: http://lpaste.net/7583146660990025728
16:39:12 <TrueMagnap> ion: What language keyboard do you have?
16:39:14 <abhillma2> Cale: Or perhaps I am not following
16:39:38 <ion> Cale: Me, right ctrl.
16:39:43 <abhillma2> Cale: Of course this is not possible in Haskell 98 without the language extensions
16:39:46 <TrueMagnap> Cale: Thanks for reminding me to do that, I'd been on passive lookout for a use for it
16:39:50 <ion> TrueMagnap: Finnish
16:40:05 <Cale> abhillma2: You don't have a separate instance for Row from the instance for [Maybe Int] though.
16:40:45 <TrueMagnap> ion: I'll look into that. I have a Danish keyboard
16:40:56 <ion> Cale: Or the <>|\ key between left shift and Z.
16:41:12 <abhillma2> Cale: OH! You mean when I go to do something like show ([Just 1]) then I get a runtime error?
16:41:27 <Cale> no...
16:41:42 <abhillma2> Cale: Can you try to explain another way?
16:41:50 <Cale> I mean what you've done is the same thing as writing   instance Show [Maybe Int] where ...
16:42:14 <Cale> The type synonym is essentially macro expanded in place
16:42:51 <ion> abhillma2: Show sounds like the wrong class for "pretty" output.
16:43:05 <Cale> and yeah, you should never ever do anything which looks like this
16:43:29 * hackagebot bert 1.2.2.4 - BERT implementation  http://hackage.haskell.org/package/bert-1.2.2.4 (RomanCheplyaka)
16:43:30 <Cale> I'm actually a little bit surprised that you're not getting a complaint that multiple instances apply, even though OverlappingInstances is on.
16:44:10 <Cale> I guess it is considered the most specific instance here.
16:44:54 <Cale> If you need OverlappingInstances, it's usually a good sign that you shouldn't be using type classes, or that you are Oleg.
16:45:06 <Pamelloes> I just ran "cabal install cabal-install" upgrading from 1.22.2.0 to 1.22.4.0. When I run cabal --version, it shows that the version has been updated, but that the Cabal Library is still on 1.22.2.0. Is this normal, or did I forget to do something?
16:45:53 <Cale> Pamelloes: Well, you might want to cabal install Cabal
16:46:04 <Cale> to update your Cabal library
16:46:28 <Cale> It just went ahead and built the newer cabal-install against the version of the Cabal library you had installed already
16:46:37 <Pamelloes> interesting
16:46:41 <Cale> Which is probably fine
16:47:07 <Pamelloes> I'm updating Cabal right now, should I re-install cabal-install afterwords?
16:47:13 <Cale> Probably.
16:47:48 <Pamelloes> Ok. Thanks for your help :)
16:48:20 <TrueMagnap> ion: I've decided I'm too used to the standard Danish keyboard and where the symbols are, and that I write √¶√∏√• too often to switch. But I'll be keeping right ctrl as compose :)
16:51:39 <abhillma2> ion, Cale: Supposing I have the type synonym and want to create a nice string for it -- do you recommend simply writing a function?
16:51:49 <Cale> yes
16:52:00 <Cale> Also, type synonyms aren't really "things"
16:52:12 <Cale> The type system doesn't actually see them.
16:52:41 <Cale> If you have  type Foo = Bar,  then Foo means the same thing to the type system as Bar, wherever it occurs
16:52:51 <abhillma2> Cale: Gotcha'. Could it also make sense to use a data delcaration and implement the Show type class for it? Or in general is this not such a good use case for a type declaration?
16:53:04 <Cale> You could do that.
16:53:12 <Cale> But the Show typeclass is not for prettyprinting
16:53:25 <ronh-> having some issues with record update syntax. http://lpaste.net/132317
16:53:47 <abhillma2> Cale: Ah... ok... Is there a better typeclass for prettyprinting? Do people just use functions for this sort of thing usually?
16:53:56 <Cale> It's for displaying a String representation of values, ideally as Haskell code
16:54:21 <Cale> There are some type classes in libraries which are designed for prettyprinting things.
16:54:22 <TrueMagnap> They're mainly a way for you to abstract away from the details of Bar. Say you have type Document = (String,[String]) (or whatever), you can later make type Document = Map String [String] with minimal fuss
16:54:26 <Cale> But nothing standard.
16:54:33 <abhillma2> Cale: Got it -- that makes sense. Because in general you might want want to be preserve something like "read $ show x"?
16:54:37 <Cale> yeah
16:54:39 <TrueMagnap> Exactly!
16:55:01 <abhillma2> TrueMagnap: Sweet! : )
16:55:07 <Cale> also, it's really convenient to be able to take a value which GHCi prints for you and use it in the next expression
16:55:09 <abhillma2> Cale: Got it, makes sense
16:56:29 <TrueMagnap> I once implemented a parser for Read because I had a prettyprinter for Show :O thankfully, I've come to my senses sice then
17:04:05 <Nux__> Can you give an example of a pretty printing typeclass?
17:04:37 <Nux__> and/or library
17:06:26 <Nux__> I'm asking Cale in particular: "There are some type classes in libraries which are designed for prettyprinting things."
17:08:08 <geekosaur> http://hackage.haskell.org/packages/#cat:Pretty Printer (um, I get that's not loadable with the space in it)
17:08:40 <geekosaur> but generally search for "pretty" on that page
17:12:25 <abhillma2> Cale: Any thoughts on this? http://lpaste.net/242642248947204096
17:12:49 <erisco> > putStrLn "hello" <> putStrLn "world"
17:12:50 <lambdabot>      No instance for (Monoid (IO ())) arising from a use of ‚Äò<>‚Äô
17:12:51 <lambdabot>      In the expression: putStrLn "hello" <> putStrLn "world"
17:12:56 <erisco> darn
17:13:06 <abhillma2> :t (<>)
17:13:07 <lambdabot> Monoid m => m -> m -> m
17:13:31 <erisco> ought to be definable I think
17:14:04 <erisco> associativity is not guaranteed I don't think but meh
17:14:41 <Fuuzetsu> what did you except for the result to be?
17:14:48 <Fuuzetsu> expect*
17:15:08 <Fuuzetsu> > putStrLn "hello" <|> putStrLn "world"
17:15:09 <lambdabot>  <IO ()>
17:15:20 <erisco> well that is a bit odd to answer
17:15:50 <erisco> the side effect of printing "hello" then "world", the return type IO (), and a value probably equivalent to return ()
17:16:11 <erisco> yeah but I don't have Alternative available
17:16:13 <Fuuzetsu> we have that already
17:16:15 <Fuuzetsu> it's >>
17:16:23 <erisco> only Monoid
17:16:26 <erisco> according to IntMap
17:16:33 <erisco> btw why do they not just expose the internals
17:16:46 <erisco> why must I contort everything through a menagerie of other functions
17:17:28 <geekosaur> fwiw xmonad defines the moral equivalent of that instance. it's not 100% mathmatically defensible, but if you dig into that you discover that IO is not a mathematical monad so feh
17:17:30 <Fuuzetsu> well, maybe you should tell us what your goal is instead
17:18:06 <ivanchuk> hi all
17:18:19 <erisco> geekosaur for Monoid you mean?
17:18:34 <ivanchuk> I've encountered a problem with pkg deps in cabal
17:18:51 <ivanchuk> is it possible to install another base version ?
17:18:55 <erisco> ivanchuk you and everyone else, what's up?
17:19:13 <erisco> another base version of what?
17:19:27 <geekosaur> erisco, yes. specifically we have a Monoid instance for a newtype of a monad transformer over IO
17:19:31 <Cale> abhillma2: That's definitely an option. I would only use a type class for that if I had a lot of types which needed prettyprinters.
17:19:34 <Fuuzetsu> I imagine he means *the* base
17:19:40 <geekosaur> base is wired into the compiler
17:19:42 <ivanchuk> I have installed the package version base-4.7.0.1
17:19:45 <ivanchuk> yes
17:19:49 <geekosaur> you replace it by installing a different ghc version
17:19:56 <ivanchuk> ah
17:20:06 <ivanchuk> :/
17:20:10 <erisco> there is a base package, what do you know
17:20:35 <TrueMagnap> It's on Hackage and everything
17:20:47 <geekosaur> it's on hackage mainly for the documentation
17:21:01 <TrueMagnap> I know, but it's still *there*
17:21:16 <TrueMagnap> **italic**?
17:21:26 <TrueMagnap> Nope, *bold*... too bad
17:21:37 <Fuuzetsu> depends on client and who you ask
17:22:04 <erisco> foldMapWithKey :: Monoid m => (Key -> a -> m) -> IntMap a -> m
17:22:15 <ivanchuk> thanks for your answers
17:22:58 <erisco> because I want to write out the keys to a vector
17:23:45 <erisco> so at least I can instance Monoid for IO ()
17:24:00 <erisco> presumably ST () as well
17:24:10 * geekosaur wonders if Foldable instance is usable...
17:24:30 <erisco> well there are a bunch of other functions which create a new IntMap, and I don't want that
17:24:31 <geekosaur> because you're kinda reaching for foldM
17:24:49 <erisco> :t foldM
17:24:50 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
17:25:00 <Fuuzetsu> why not use ‚Äòkeys‚Äô and write out the result?
17:25:05 <erisco> geekosaur yeah good point IntMap instances Foldable
17:25:16 <pete_> \leave
17:25:19 <dfeuer> Since there's a different mix of people here now: what do you call a function with a type that looks like  f (g x) -> g (f x), if there's any special name for that sort of thing?
17:25:32 <TrueMagnap> pete_: The other kind of slash
17:25:55 <erisco> Fuuzetsu because I don't know if I can trust GHC to elide making the list
17:27:01 <erisco> :t traverse -- dfeuer 
17:27:02 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
17:27:02 <Fuuzetsu> erisco: you dump out core and check
17:27:06 <erisco> no that isn't it
17:27:11 <erisco> which is it... hm
17:27:18 <erisco> Fuuzetsu can you read core? I can't
17:27:26 <Fuuzetsu> learn
17:27:31 <dfeuer> erisco, that's ... related.
17:27:58 <erisco> also, how do I know it will always happen and is not because of some special tempermental circumstance Fuuzetsu ?
17:28:03 <Fuuzetsu> :t sequenceA
17:28:04 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
17:28:09 <erisco> yeah there it is :)
17:28:35 <erisco> so the special name is "sequenceA"
17:28:49 <dfeuer> Fuuzetsu, yeah, the question is whether there's any sort of general term for functions whose types look like that in some reasonably general context....
17:30:16 <erisco> Fuuzetsu that is the real crux of it. Even if I can determine GHC is making the necessary optimisations, I have to then understand when those optimisations are made and whether it is reasonable to rely on
17:30:34 <erisco> which is all black magic at that point
17:30:52 <Fuuzetsu> you can help GHC with different annotations &c; it's not black magic, a whole ton of libraries rely on GHC optimisations
17:31:11 <erisco> yeah but here's another idea
17:31:17 <erisco> just don't make the list at all
17:31:50 <erisco> then unless the compiler is out to get you there definitely won't be any lists
17:31:52 <Fuuzetsu> well, no matter how hard you're going to try, you can't make non-orphan Monoid (IO ())
17:31:57 <dfeuer> erisco, list fusion is indeed somewhat temperamental, because the inliner is. However, if you have a piece that uses a list internally, and it fuses, you can NOINLINE that piece and then pretty much rely on that fusion really happening.
17:32:06 <erisco> Fuuzetsu what is a non-orphan monoid?
17:32:12 <Fuuzetsu> ‚Ä¶
17:32:15 <Fuuzetsu> non-orphan instance
17:32:26 <erisco> I do not know what that is
17:32:32 <dfeuer> Fuuzetsu, didn't tekmo request that instance, and wasn't it very well received?
17:32:38 <dfeuer> Was it not added?
17:32:40 <Fuuzetsu> dfeuer: probably
17:33:06 <Fuuzetsu> also re your earlier question, we have associators so maybe a commutator though those are in a different context themselves
17:33:32 <dfeuer> erisco, an orphan instance is an instance declared in a module that does not declare either 1. the class or 2. the type (or at least one, for MPTC) in the instance head.
17:33:44 <Fuuzetsu> I think ‚Äòsequence‚Äô is the best we can do
17:33:45 <abhillma2> Suppose I define a type synonym for Maybe Int, call it MyInt. I can directly call "fromJust (Just 1 :: MyInt)". Yet if I define a newtype, call it NewInt where we have "newtype NewInt = NewCell (Maybe Int)", I can write a method fromJust' to be able to get fromJust functionality like I did on MyInt -- i.e. "fromJust' (NewCell val) = fromJust val". Is there any other ways to execute fromJust on newtype M
17:33:49 <dfeuer> Fuuzetsu, associators and commutators?
17:33:51 <abhillma2> yInt?
17:33:56 <erisco> dfeuer oh, well that isn't my problem :)
17:34:02 <abhillma2> Here is an example: http://lpaste.net/7433201011860176896
17:35:01 <haasn> Fuuzetsu: with mempty = return mempty and mappend = liftM2 mappend ?
17:35:06 <Fuuzetsu> dfeuer: well, let's ignore what I said there; what I want to try to communicate is that I don't think there is a name for this shape in general, without any extra context 
17:35:16 <Fuuzetsu> haasn: don't remember
17:35:23 <geekosaur> abhillma2, fromJust is not implemented as a typeclass method so you can't make it work directly on MyInt
17:35:34 <geekosaur> (fromJust is also strongly discouraged)
17:35:37 <haasn> because that seems like it could work for all (Applicative f, Monoid a) => Monoid (f a)
17:35:56 <lokathor> if i have an IO (Either String [String])
17:35:56 <haasn> of which eg. Monoid ((->) a) is also a special case, incidentally
17:36:01 <lokathor> and i want to print the [String]
17:36:08 <abhillma2> geekosaur: Got it. Would  you recommend something like bind instead?
17:36:19 <dfeuer> Fuuzetsu, my specific task here is taking an "expression" full of elements of a semigroup augmented to form a monoid, and reducing it down to either the added neutral element or an expression in the semigroup.
17:36:31 <geekosaur> for comparison, we have MonadState that defines the actions on StateT (and the former State when it existed), so that can be derived for newtypes over State
17:36:42 <dfeuer> And trying to do that in a way that is as "obviously correct" as possible.
17:36:48 <abhillma2> geekosaur: Is there something like Maybe with a fromJust implemented as a type class? Or in general, should I be reaching for something else?
17:36:49 <geekosaur> but there is no general MonadMaybe that could be used with newtypes over Maybe
17:37:09 <geekosaur> you *may* want to use just type instead of newtype
17:37:22 <dfeuer> abhillma2, fromJust is usually a bad idea....
17:37:52 <erisco> yoloJust
17:37:57 <Fuuzetsu> dfeuer: I don't know but http://en.wikipedia.org/wiki/Commutator kind of sounds like it might be related after all :)
17:38:06 <dfeuer> Fuuzetsu, I'll check it out.
17:38:32 <geekosaur> fromJust is strongly discouraged because it can only throw an exception if the value it's handed is not (Just whatever)
17:38:51 <abhillma2> dfeuer: Is it bad in this case? http://lpaste.net/3582108393944383488
17:38:53 <geekosaur> there is fromMaybe that lets you provide a default if it's Nothing, or the maybe combinator for more complex cases
17:39:21 <haasn> And pattern matching for whenever you're not writing point-free code
17:39:23 <Fuuzetsu> abhillma2: yes it's bad lest someone removes the first case for some reason one day
17:39:42 <Fuuzetsu> abhillma2: and GHC can't warn you about a missing pattern match, you should just pattern match on cell instead
17:39:45 <dfeuer> abhillma2, it's bad because there's a much cleaner way to do it, just as easily.
17:39:48 <TrueMagnap> dfeuer: I think for "obviously correct" you'd want either that or https://en.wikipedia.org/wiki/Associator
17:39:53 <geekosaur> I would write that as showCell cell = show (fromMaybe " " cell)
17:39:57 <abhillma2> Fuuzetsu: Ok, in general I agree. Any suggestions as to how you would recommend re-writing it?
17:40:08 <dfeuer> TrueMagnap, I looked at both, and don't actually see how they relate :-/
17:40:09 <abhillma2> dfeuer: ^ Ditto
17:40:09 <Fuuzetsu> TrueMagnap: well associators do a different thing‚Ä¶
17:40:26 <TrueMagnap> I know, but I'm not sure which one it is you are looking for
17:40:41 <dfeuer> abhillma2, you could just pattern match on the cell in the second case, instead of using the cell variable there.
17:41:04 <dfeuer> Fuuzetsu, TrueMagnap, I don't understand what either has to do with; Wikipedia is full of crap.
17:41:07 <geekosaur> actually for what you have it's more like: maybe " " show cell
17:41:28 <geekosaur> showCell = maybe " " show
17:42:25 <abhillma2> geokosaur: So, all together, something like http://lpaste.net/5293270536296595456
17:42:56 <Fuuzetsu> yes that's one way to do it and this common pattern is abstracted in ‚Äòmaybe‚Äô function
17:42:58 <geekosaur> that is one way to do it, or the ways I suggested earlier
17:44:24 <abhillma2> geekosaur: Got it. So in general, fromMaybe is considered OK, but in general, people avoid fromJust, even if they write what appears to be an exhaustive pattern
17:44:43 <Fuuzetsu> your pattern was exhaustive, your function was not
17:45:21 <abhillma2> Fuuzetsu: Ah, got it. What aspect was non-exhaustive?
17:45:22 <dfeuer> There are some weird cases where it's actually necessary to use some partial function in order to implement a total function with sufficient laziness, but those are relatively rare.
17:45:30 <Fuuzetsu> @src fromJust
17:45:30 <lambdabot> fromJust Nothing  = undefined
17:45:30 <lambdabot> fromJust (Just x) = x
17:46:24 <dfeuer> abhillma2, strive to build your house from pieces, all of which are sound. If you build it out of pieces that are only sound when put together in just the right way, it is easy to make a mistake, especially in the future.
17:46:29 <abhillma2> Fuuzetsu: Not quite following. If the parameter to the function was Nothing it seems that it would have been caught -- http://lpaste.net/5293270536296595456 or http://lpaste.net/3582108393944383488
17:46:34 <geekosaur> the problem with writing an exhaustive pattern is that someone else can come along and change things later, and miss that they were relying on the pattern to make the function safe
17:46:52 <abhillma2> dfeuer: Okay, yes, I agree :-) I am just trying to be precise about criticism!
17:47:23 <abhillma2> geekosaur: Okay! Just trying to be precise : )
17:47:24 <geekosaur> think of it as defensive programming
17:47:57 <Fuuzetsu> I like GHC to do the defensive part for me in form of exhaustiveness checks
17:48:03 <abhillma2> geekosaur: Seems like an exhausting thing to always think about... test cases are also a nice barrier? ; ) But okay, yes, I understand. fromMaybe makes a lot of sense to me and I understand your criticism about fromJust!
17:48:24 <geekosaur> well, eventually it becomes habit to just not rely on partial functions
17:48:27 <abhillma2> Fuuzetsu: How to perform an exhaustiveness check with GHC?
17:48:50 <Fuuzetsu> abhillma2: it does so already with pattern matches which is why your initial attempt wasn't great
17:48:52 <geekosaur> ghc -Wall is a good start
17:48:56 <erisco> geekosaur haha, sure
17:49:06 <Fuuzetsu> because you used a catch-all pattern (just ‚Äòcell‚Äô) and then used a partial function on it
17:49:21 <Fuuzetsu> if you used explicit pattern matches and missed a case, you'd get a warning
17:49:22 <dfeuer> abhillma1, some time in the last couple months I spent many hours rewriting hundreds of lines of code (making it quite a bit longer in the process) in order to make sure all pattern matches were exhaustive and all functions total. Guess what? The end result was also much easier to understand, and ran just a bit faster.
17:49:27 <erisco> then you do anything at all with maps and you hate yourself
17:50:02 <erisco> where's your totality now?!?
17:50:11 <dfeuer> erisco, you talking about Data.Map/Data.IntMap?
17:50:19 <Fuuzetsu> dfeuer: heh, one time I had a nasty bug where impossible empty list pattern was being entered, so I moved to NonEmpty and the bug went away, don't even know where it was to this daya
17:50:22 <erisco> yeah, those qualify
17:50:28 <abhillma2> Alright, well I appreciate the feedback, thank you kindly
17:50:36 <Fuuzetsu> ``impossible''*
17:50:40 <alexv19> Does `(f <* g) <|> (h <* g)` equals `(f <|> h) <* g` ?
17:50:41 <geekosaur> I don't see that often. makes me wonder if you're not using them as intended / twisting them out of shape
17:50:59 <TrueMagnap> dfeuer: The more I think about it, the more I think associator is the right word. I don't know enough formal category theory to really argue why, but if you look under the headline "in monoidal categories" here http://ncatlab.org/nlab/show/associator, it looks like the kind of type (IIRC from the bananas, envelopes, lenses, and barbed wire paper) you are looking for
17:51:18 <dfeuer> Thanks, TrueMagnap 
17:51:21 <Fuuzetsu> erisco: why would using maps do away with totality?
17:51:34 <Fuuzetsu> there's a reason why lookup is in a Maybe
17:51:37 <erisco> Fuuzetsu because of lookups
17:51:44 <Fuuzetsu> :t lookup
17:51:44 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
17:51:53 <erisco> and what do you do with that Maybe value?
17:51:54 <geekosaur> :t M.lookup
17:51:55 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
17:52:10 <Fuuzetsu> depends if it's Nothing or not :)
17:52:15 <dfeuer> TrueMagnap, that looks really scary.
17:52:36 <erisco> Fuuzetsu how do you account for the Nothing case
17:52:54 <Fuuzetsu> erisco: depends what I'm doing?
17:53:14 <erisco> sure it depends, but what I'm saying is that there probably is not anything sensible to do if it is Nothing
17:53:28 <erisco> in fact your code is written such that it will never be Nothing (unless you have a bug)
17:53:41 <TrueMagnap> dfeuer: The paper? Or the page?
17:53:46 <Fuuzetsu> that's a lot of assumptions you're making about my code erisco 
17:53:53 <erisco> Fuuzetsu yup
17:53:56 <dfeuer> TrueMagnap, the page.
17:54:07 <Fuuzetsu> they are wrong
17:54:14 <erisco> so you know your lookup will never return Nothing, now what
17:54:23 <erisco> fromJust time
17:54:24 <Fuuzetsu> erisco: no, I don't know that
17:54:29 <Fuuzetsu> stop assuming stuff
17:54:31 <erisco> or  Nothing -> error "whoopsie"
17:54:33 <Fuuzetsu> this is getting really stupid
17:54:47 <erisco> Fuuzetsu I think you're missing the hypothetical part of this
17:55:03 <dfeuer> erisco, I think you're missing how Fuuzetsu would and wouldn't use a Map.
17:55:13 <Fuuzetsu> no, I'm not, all I'm seeing is you saying that in most general case you can't deal with a Nothing out of a lookup
17:55:14 <geekosaur> if I know the lookup will always be successful, I am probably using a Map where a record might be appropriate
17:55:28 <Fuuzetsu> well, frankly, in most general case you don't do anything, you just have the Nothing, ‚Äòlookup‚Äô is the most general case
17:55:39 <Fuuzetsu> in specialised cases you do whatever is sensible in that case
17:55:41 <Fuuzetsu> that's all
17:56:02 <pharaun> with lookups if its a none, then its probably a default value, or... or... lots of ways to handle it :)
17:56:09 <erisco> and it leads to partiality in some of those specialised cases
17:56:16 <erisco> all I'm saying
17:56:18 <Fuuzetsu> I don't think I have a Nothing -> error "not found in map" or whatever *anywhere* in any of my currentn programs
17:56:24 <Fuuzetsu> erisco: no, it does not
17:56:29 <erisco> also, look at things such as the paper on Map
17:56:37 <erisco> the paper uses partial functions to balance the tree
17:56:46 <erisco> I'd like to see that rewritten to not be partial
17:56:52 <Fuuzetsu> you're moving the goalposts
17:56:56 <erisco> um, no
17:56:59 <Fuuzetsu> um, yes
17:57:10 <erisco> same situation
17:57:25 <TrueMagnap> dfuer: IIRC (big disclaimer), the cross-in-circle is fmap-ish. It says that the associator is the function that transforms fmap f (fmap g x) into fmap g (fmap f x)
17:57:54 <erisco> you know P is true about some value (such as a Map, or a Tree, or whatever), and now you're going to make use of P and define a partial function
17:58:04 <erisco> which happens to be okay because P is true, but it is still a partial function
17:58:08 <TrueMagnap> dfeuer: This might very well all be wrong, but it's my best guess
17:58:26 <erisco> and if that hasn't come up for you frequently then you're luckier than I
17:58:31 * hackagebot fixed-list 0.1.6 - A fixed length list type  http://hackage.haskell.org/package/fixed-list-0.1.6 (JobVranish)
17:58:36 <Fuuzetsu> TrueMagnap: I don't understand why you try recommending associator which has the shape (f ‚àò g) ‚àò h ‚Üí f ‚àò (g ‚àò h) where dfeuer wants f ‚àò g ‚Üí g ‚àò h
17:59:47 <Fuuzetsu> and the ‚äó is functor C √ó C ‚Üí C
17:59:49 <TrueMagnap> Fuuzetsu: Dual explanations: A) I'm pretty bad at category theory but really want to help and B) Cunningham's law. Mainly A
18:00:11 <Fuuzetsu> didn't know about B)
18:00:40 <Fuuzetsu> erisco: or maybe I program in a way that doesn't put me on in a ‚Äòerror "oops I fucked up"‚Äô situation
18:00:41 <Cale> What was the original question?
18:00:58 <TrueMagnap> Cale: who's?
18:01:02 <Fuuzetsu> Cale: name for things of shape ‚Äòf (g x) ‚Üí g (f x)‚Äô
18:01:27 <Cale> I guess commutators?
18:01:36 <Fuuzetsu> that's what I suggested
18:02:40 <dfeuer> Fuuzetsu, yeah, but the link to Wikipedia confused the heck out of me :P
18:03:05 <dfeuer> I'll have to try to figure out what definition actually has something to do with it.
18:05:10 <Cale> dfeuer: http://en.wikipedia.org/wiki/Distributive_law_between_monads might also be relevant to you?
18:05:53 <dfeuer> Cale, I'll take a look; I don't know that there are any monads in the picture I'm painting, however. Might be a useful functor though.
18:06:56 <Cale> The idea there is that if you have a natural transformation TS -> ST, then you can make ST into a monad because in the case of defining join you have a way to go STST -> SSTT at which point you can use the join for S and for T to get down to ST
18:07:21 <erisco> is there a reason there is not some way to write executable proofs of Haskell programs -- some Haskell extension?
18:07:35 <Cale> erisco: Because Haskell is not a dependently typed language
18:07:43 <erisco> is that really necessary though?
18:07:47 <Cale> Pretty much.
18:07:49 <TrueMagnap> Yup
18:08:03 <erisco> people talk about DTs all the time, and I don't understand DTs, but I don't see why values need to be types and vice versa
18:08:05 <Cale> If it were dependently typed, we could write our proofs in Haskell.
18:08:25 <dfeuer> Cale, what's a natural transformation again? That monad bit ... yeah, that might actually be kind of cool.
18:08:31 * hackagebot yxdb-utils 0.1.0.0 - Utilities for reading and writing Alteryx .yxdb files  http://hackage.haskell.org/package/yxdb-utils-0.1.0.0 (MichaelBurge)
18:08:36 <erisco> if that part of it could be explained to me then maybe I'd understand
18:08:52 <Cale> erisco: Well, the proposition that some property holds of some value(s), should be a type constructor accepting those values as arguments
18:08:57 <erisco> as far as I can tell the specification & proof language doesn't need to be Haskell at all
18:09:01 <Cale> erisco: So that gets you to dependent types immediately.
18:09:04 <TrueMagnap> dfeuer: It transforms one functor into another
18:09:13 <erisco> Cale why should it be?
18:09:16 <dfeuer> Hmmmmmmmm......
18:09:20 <erisco> that statement is circular to me
18:09:25 <Cale> erisco: For example, the proposition that two values are equal is a type parameterised by those values.
18:09:34 <erisco> "if you choose to solve this with dependent types you need dependent types"
18:09:50 <orion> What IS a dependent type?
18:10:03 <timothyh> anyone familiar with dimensional? I'm trying to find a unit for fahrenheit, but not having much luck
18:10:06 <Cale> dfeuer: A natural transformation F -> G correpsonds roughly with a polymorphic function F a -> G a
18:10:25 <Cale> orion: A type parameterised by the values of another type.
18:10:34 <dfeuer> Cale, huh.... I assume there's a law or two?
18:10:57 <Cale> erisco: Well, okay, there are certainly other ways to write proofs of programs using completely separate systems.
18:10:59 <TrueMagnap> I found some here: https://en.wikipedia.org/wiki/Natural_transformation
18:11:09 <fread2281> you can write some proofs in haskell with Data.Type.Equality, but it's very limited
18:11:11 <erisco> Cale good, why not one of those then?
18:11:13 <Cale> erisco: But if you want the propositions to be types, and you want the proofs to be programs
18:11:15 <erisco> also, what are they?
18:11:30 <erisco> I don't need propositions to be Haskell types or proofs to be Haskell programs
18:11:33 <erisco> they don't need to intermingle
18:11:37 <erisco> why should they have to
18:11:47 <Cale> erisco: Why not? Because it's a whole lot of additional nonsense to add on.
18:11:57 <Cale> You have a whole separate language of proofs to develop
18:12:32 <Fuuzetsu> ugh, let's not talk about distributive law
18:12:41 * Fuuzetsu just handed in dissert about pseudo-distributive law the other day
18:12:45 <Fuuzetsu> still recovering
18:12:55 <Cale> The advantage of dependently typed languages is that it's not a separate language.
18:13:15 <Cale> You write the proofs in the same language as you write the programs.
18:13:25 <TrueMagnap> Fuuzetsu: Is this correct? If eta :: (Functor f, Functor g) => f a -> g a, then fmap x . eta == eta . fmap x
18:13:31 <erisco> Cale okay but, I feel like there is still some mixing that doesn't need to happen
18:13:32 <Cale> So there's only one typechecker and one compiler required.
18:13:36 <fread2281> erisco, because getting programs from proofs is very useful
18:13:54 <fread2281> most proof systems have a program extraction thing
18:13:58 <TrueMagnap> dfeuer: My concrete example of a natural transformation is maybeToList
18:14:01 <cellopin> What is usually the best practice if I want to create a Type Dog with a record field `name` and a Type Person with the same field `name`? It seems to create conflict with each other.
18:14:02 <Cale> and yeah, this has a lot of knock-on benefits in terms of using proofs to do computation directly
18:14:02 <TrueMagnap> :t maybeToList
18:14:03 <lambdabot> Maybe a -> [a]
18:14:16 <erisco> Cale put it this way... what if I just wrote Haskell program P to prove Haskell program A... P reads in A as source code or an AST or something
18:14:16 <Cale> cellopin: Name the fields differently
18:14:28 <erisco> Cale I don't get why there needs to be this super fancy type system to make this work
18:15:05 <ReinH> cellopin: or put them in separate modules and use the names qualified, which isn't really any different
18:15:10 <dfeuer> TrueMagnap, hrm.
18:15:15 <Fuuzetsu> TrueMagnap: if the functor laws are satisfied, it should be
18:15:17 <Cale> erisco: Well, okay, you can do that, but how do you become convinced that the output of this new program you just wrote actually implies anything about the behaviour of the program that it got as input?
18:15:35 <Cale> erisco: Especially as it's a one-off program that you just wrote...
18:15:35 <TrueMagnap> I kinda assumed that by (Functor f, Functor g) ;)
18:15:42 <dfeuer> erisco, it's also very hard to take apart a program "from the outside" and prove something about it.
18:15:42 <Fuuzetsu> or rather natural transformation laws
18:15:51 <Fuuzetsu> it's kind of in the definition
18:15:55 <Cale> erisco: You want some kind of system whose bugs eventually get identified and squashed.
18:16:08 <erisco> Cale there is a well tested and simple library of basic assumptions your proof program can make, and you use those
18:16:16 <ReinH> TrueMagnap: that is the law for arrows, yes
18:16:25 <fread2281> erisco, you only have to write the type/proof checker once
18:16:36 <erisco> if this is just the "who proves the prover" question then I don't see how it is an interesting one
18:16:40 <ReinH> s/arrows/morphisms as you wish
18:16:48 <erisco> i.e. how it is much different than trusting this fancy type system
18:16:50 <Cale> erisco: It's not just that
18:17:01 <fread2281> you can do fun things like sized lists
18:17:01 <Cale> erisco: Like, Agda occasionally runs into a bug
18:17:32 <cellopin> hmm... so we can't really overload names..
18:17:36 <Cale> erisco: But for every bug that it has had in the past, there are regression tests and such to try to prevent at least the same bugs from happening in the future
18:17:47 <cellopin> i mean fields..
18:17:56 <Fuuzetsu> Cale: ‚ä• was proved in presence of ext just the other day!
18:18:05 <Cale> heh
18:19:02 <Cale> erisco: If you're constantly writing new proof checkers for each program you want to write, you want some kind of assurance that the system you've implemented is sound and consistent (even if you can't prove it)
18:19:19 <Cale> Maybe there's some modular way to do it
18:19:25 <Cale> I'd encourage you to try
18:19:35 <fread2281> erisco, ultimately, it doesn't have to, but try agda, it's fun
18:19:49 <erisco> problem is Agda is I can't write practical software with it
18:19:50 <Cale> But at least to me, it doesn't sound by any means like something which is *easy*
18:20:09 <erisco> okay, it is hard, but
18:20:25 <dfeuer> Fuuzetsu, what's ext? Extensionality?
18:20:25 <erisco> what property do DTs have that make finding bugs easier
18:20:30 <Fuuzetsu> dfeuer: yes
18:21:03 <Fuuzetsu> rather than finding bugs, you end up with code that prevents certain bugs from existing all together
18:21:12 <erisco> lets see, I run P and it has a bug so produces a false positive. I run A and eventually I hit the bad case
18:21:20 <erisco> then I say "hey P lied to me" and I go fix the bug
18:21:23 <erisco> how is it any different
18:21:33 <Fuuzetsu> you would never have P with a bug
18:21:57 <erisco> I am talking wrt my suggestion of having Haskell program P read Haskell program A and prove something about it
18:22:21 <Fuuzetsu> oh
18:22:26 <Cale> erisco: Well, the problem comes down to "whose fault is it if my proof checker says that my program meets the specification when it doesn't?"
18:22:34 <Fuuzetsu> you only have to fix P, not every possible A you may write in the future
18:22:48 <erisco> Cale how is that a mystery? clearly P is at fault
18:22:55 <TrueMagnap> dfeuer: Did you ever find a name?
18:23:37 <dfeuer> TrueMagnap, Cale says commutator thing. He also had some other useful things to say....
18:24:00 <erisco> Cale I dunno, I don't even know what P would look like, but I suppose I'll get started on thinking about it
18:24:04 <ReinH> erisco: as opposed to the person who wrote P?
18:24:26 <dfeuer> I'm still not sure how I can use this natural transformation stuff, but I will probably need to, somehow.
18:24:45 <fread2281> erisco, have you seen liquidhaskell?
18:24:47 <erisco> ReinH P was recovered from a distance moon and has unknown origin. Could have been there since the big bang, who knows
18:24:57 <Fuuzetsu> dfeuer: why do you say you need to use nat transformations?
18:25:10 <erisco> fread2281 nope, I'll take a look
18:25:20 <Cale> erisco: If you're constantly reimplementing P for each A, then you have a lot of surface area for bugs
18:25:35 <Cale> erisco: and worse, you're the one to blame when there are bugs in P
18:25:42 <Cale> even though you really want to be concerned with A
18:26:00 <fread2281> erisco, dependent types also give you e.g. \x -> if x > 5 then true else 7
18:26:01 <erisco> Cale well, like I said, you'd have a library of basic assumptions that P can reuse
18:26:12 <erisco> Cale presumably you'd build up further libraries for common things
18:26:20 <Cale> Maybe
18:26:22 <TrueMagnap> Fuuzetsu: To define f (g x) -> g (f x). Isn't that a natural transformation? Namely, the distributive law?
18:26:27 <Cale> Try it and we'll see :P
18:26:32 <dfeuer> Fuuzetsu, to restate, I think I need to learn more of the stuff in this realm, so I can use it... In this case, I can use map and this free magma property to get me an arrow from the right object to the right object, but I still have to prove that it's the right arrow.
18:26:35 <erisco> Cale so like normal software the surface area can be reduced a bit, but another point to make
18:26:55 <dfeuer> er... actually, I still have to prove it's an arrow....
18:26:55 <Fuuzetsu> TrueMagnap: It is more than just the l : TS ‚Üí ST 
18:26:55 <erisco> is absolute perfection the most important thing or is having any tool at all important?
18:27:06 <Fuuzetsu> TrueMagnap: it's also the laws of the diagrams
18:27:15 <Cale> erisco: A key problem is that logics concerned with truth tend to be very fragile. One little flaw can lead to everything being both true and false.
18:27:24 <erisco> lets face reality for a moment
18:27:25 <Fuuzetsu> TrueMagnap: that is ‚Äòl‚Äô does not hold for all possible T and S
18:27:31 <ReinH> Conor McBride has a few Stackoverflow answers about commutative functors
18:27:31 <TrueMagnap> Oh!
18:27:33 <erisco> 99% of software is written with no proof whatsoever
18:27:43 <dfeuer> Thanks, ReinH.
18:27:50 <erisco> languages which are capable of proving themselves are not used by many and not many practical programs
18:28:01 <TrueMagnap> Thanks for being so patient with me though I apparently am consistently wrong
18:28:02 <erisco> so in terms of impact, absolute perfection is not going too far yet
18:28:12 <Cale> erisco: Well, types in general are a certain degree of proof
18:28:32 <erisco> Cale granted, and that helps more than nothing even if they don't capture all relevant properties, right?
18:28:39 <dfeuer> erisco, the landscape is ... changing. Things that were in the shadows for a few decades have reached a level of maturity to become practically relevant.
18:28:39 <Cale> For sure
18:28:42 <Fuuzetsu> TrueMagnap: also T and S there are functors of monads anyway, not just random functors from thin air
18:28:42 <erisco> people unit test just because it helps a bit, not because it is bulletproof
18:29:06 <ReinH> Fuuzetsu: e.g., http://stackoverflow.com/a/13100857/2225384
18:29:06 <dfeuer> Furthermore, the failures of non-verified systems have been getting more and more serious.
18:29:08 <TrueMagnap> Fuuzetsu: BTW, have you just memorized the unicode points, or do you have a list of the symbols?
18:29:11 <Cale> erisco: But again, I don't have to implement any part of GHC's type system for each program I write, unless you count simply defining new data types as part of that.
18:29:11 <ReinH> Fuuzetsu: you might find that answer interesting
18:29:14 <erisco> sooo, even if you had a proof tool prone to bugs, it is still better than nothing
18:29:22 <Fuuzetsu> TrueMagnap: I use agda input mode
18:29:31 <Fuuzetsu> so just type \o for ‚àò etc‚Ä¶
18:29:33 <Fuuzetsu> also compose key
18:29:41 <TrueMagnap> Cool!
18:29:50 <Cale> erisco: The key thing is to engineer it so that only the proof gets written by the programmer, and not the proof system itself.
18:30:32 <ReinH> I asked Conor to be on the haskell cast but he's too busy :(
18:30:33 <erisco> Cale so the proof system gets tucked into a single library. That'd be my goal anyways
18:30:34 <Fuuzetsu> ReinH: Why me? Did you get the right person?
18:30:37 <ReinH> or he doesn't like us and is being polite
18:30:43 <ReinH> Fuuzetsu: I thought you were talking about distributive functors
18:30:46 <erisco> but whatever, I'll give it some thought
18:30:57 <Cale> erisco: Yeah, it's a worthwhile sort of idea for an approach.
18:31:02 <Fuuzetsu> ReinH: not in particular, if anything it was about distributive law on monads
18:31:02 <erisco> also
18:31:10 <erisco> do you know this liquidhaskell thing Cale?
18:31:13 <Cale> yes
18:31:27 <erisco> how does it relate to what I am describing?
18:32:28 <Cale> Well, it's like an alternate type system for Haskell which you use by putting more refined types of things in comments, and it applies a solver to attempt to prove that they actually hold.
18:32:45 <ReinH> Fuuzetsu: ah ok :)
18:32:51 <ReinH> Fuuzetsu: well anyway it's still interesting :)
18:33:08 <kaidelong> is there any ambition to roll LiquidHaskell into GHC?
18:33:11 <kaidelong> like with Backpack
18:33:13 <Fuuzetsu> ReinH: no doubt but right now I'm a bit more concerened about my finals starting in 3 days
18:33:15 <timothyh> anyone know a good library for unit conversion? I have metres, km, miles, ¬∞C, ¬∞F, ¬∞K
18:33:20 <TrueMagnap> Fuuzetsu: So what dfeuer is looking for a name for is the natural transformation Œ∑: F‚àòG ‚Üí G‚àòF?
18:33:33 <ReinH> Fuuzetsu: well ok the :D
18:33:51 <TrueMagnap> (I am learning so much from this conversation. Thank you, and good luck with your finals!)
18:33:53 <dfeuer> TrueMagnap, maybe? I dunno....
18:33:56 <dfeuer> Sounds likely!
18:33:58 <Fuuzetsu> TrueMagnap: no, no need for natural transformtion bit at all
18:34:04 <dfeuer> Oh, okay.
18:34:08 <dfeuer> :P
18:34:11 <ReinH> @hackage units -- timothyh
18:34:11 <lambdabot> http://hackage.haskell.org/package/units -- timothyh
18:34:14 <TrueMagnap> Wait, not?
18:34:14 <Cale> kaidelong: I don't think so yet... It still only supports a modest subset of Haskell.
18:34:35 <lokathor> so, to compute how many elements in a list pass a predicate, on average, it's much faster to use a special fold than filtering and counting the length, right?
18:34:54 <fread2281> erisco, have of the use of dependent types is that you can put arbitrary (numbers is the common use, but e.g. sets are useful) at the type level. so you can have more descriptive types
18:34:56 <Cale> lokathor: I don't see why that would be the case.
18:34:59 <erisco> Cale I'll read the paper then
18:35:11 <Cale> lokathor: But maybe if the rewrite rules aren't firing...
18:35:28 <Fuuzetsu> TrueMagnap: natural transformations are a thing in category theory, at best that'd be a generalisation he could try to specialise but it doesn't sound like that's what he wants to do anyway 
18:35:29 <fread2281> like an AST that has the set of it's free variables in it's type
18:35:35 <erisco> if they're reading their own DSL + the Haskell program and spitting out "yay" or "nay" then it aint too much different than what I described (difference being in the details)
18:35:51 <erisco> it doesn't sound like DT or something too subversive
18:36:11 <Cale> lokathor: Also, the length function is probably faster than what you can write by hand without a bunch of effort, since iirc, it uses unboxed Ints.
18:36:16 <lokathor> Cale: ah, does GHC optimize it quite a bit? I would have figured that "(length (filter pred list)) / count" would have to traverse the first list for the filter and then traverse the filtered list to get the length
18:36:24 <fread2281> it's not as powerful as dependent types
18:36:29 <lokathor> ah, alright
18:36:52 <wepy> hi
18:36:58 <Cale> and yeah, GHC does a whole bunch of optimisation assuming you have optimisation turned on
18:37:19 <lokathor> perhaps i should stop using GHCI and build a command line interface for what i'm doing :P
18:37:31 <jmcarthur> lokathor: there is probably no intermediate list. it depends on how good of a day ghc is having
18:37:36 <dfeuer> Fuuzetsu, I don't know what I want to do, in particular. I have a general goal for this particular piece of code, and would like to accomplish that in as algebraically pretty a fashion as I can.
18:37:43 <wepy> how can i make a shared library with haskell?
18:37:49 <wepy> that i can call into with C maybe?
18:38:03 <wepy> or just another haskell program
18:38:06 <jmcarthur> i jest. ghc is normally fairly predictable. the strictness analyzer is the toughest part for me to wrap my head around (i never read up on how it works though)
18:38:18 <lokathor> well right now i'm computing a million element list, mapping over it, then filtering that for cases that pass
18:38:39 <Fuuzetsu> wepy: there's a wiki page on that just a search away
18:38:48 <ReinH> lokathor: filter is productive:
18:38:48 <Fuuzetsu> on calling from C at least
18:38:50 <Cale> lokathor: Note also that lazy evaluation will prevent that from using very much memory
18:38:51 <ReinH> > take 5 . filter even $ [1..]
18:38:53 <lambdabot>  [2,4,6,8,10]
18:39:04 <jmcarthur> lokathor: what cale said is true even without optimizations
18:39:10 <Cale> lokathor: But how much allocation gets done is a matter of how well GHC optimises.
18:39:16 <ReinH> So even without optimizations, it will only take one pass
18:39:23 <wepy> ok
18:39:24 <ReinH> optimizations might introduce deforestation
18:39:28 <lokathor> i am less concerned about memory and more concerned about time taken. I'd rather it run faster even if it takes more memory
18:39:35 <lokathor> i've got gobs of memory
18:39:48 <Fuuzetsu> dfeuer: but what is it that you aim to achieve in this general goal? Usually you have laws or some other requirements that go along with your structures and you haven't specified those. You need to say what you want your thing to do.
18:39:53 <timothyh> thanks ReinH , it seems Units is easier to work with than I first thought
18:39:54 <ReinH> length . filter p will only traverse the list once
18:39:58 <ReinH> timothyh: :)
18:40:04 <lokathor> if i use parMap instead of map and compile it with -threaded would that speed things up perhaps?
18:40:08 <ReinH> timothyh: there's another package as well but I forget the name
18:40:15 <ReinH> I think units is the most used
18:40:20 <Cale> lokathor: anyway, just remember to compile with -O or -O2 if you're concerned about performance, before drawing any sort of conclusions :)
18:40:23 <timothyh> I was really enjoying `dimensional'
18:40:30 <Fuuzetsu> -O2 > -O
18:40:35 <ReinH> Well
18:40:38 <ReinH> Let me rephrase.
18:40:38 <timothyh> but it has no implementation for Fahrenheit and would have been hasochism to produce a patch
18:40:42 <lokathor> i did figure on using -O2
18:40:43 <ReinH> length . filter p will traverse the list at mos tonce
18:40:48 <ReinH> it might not traverse the list at all
18:40:55 <ReinH> *at most once
18:41:00 <Cale> Uh, it's hard to count
18:41:00 <TrueMagnap> dfeuer: Can we see the code?
18:41:17 <Cale> What does it even mean to traverse a list n times?
18:41:19 <dfeuer> Fuuzetsu, well, I'm trying to figure out what the right sorts of laws are. I know exactly what transformation I want to perform; the question is how to make it apparent that said transformation is the right one.
18:41:33 <Cale> :)
18:41:44 <ReinH> Cale: Hmm.
18:41:56 <ReinH> I'm not sure how to say it more precisely
18:42:01 <Cale> Yeah
18:42:11 <TrueMagnap> I think in general that lies in the code, if I
18:42:25 <Fuuzetsu> dfeuer: well if I were in your position then I'd implement the specific case you're after and try to generalise from there
18:42:40 <Fuuzetsu> find properties that need to hold in general for the transformation to work
18:43:03 <bitemyapp> SparkySparkyBoom: hi
18:43:08 <wepy> you still need "main" when you make a dynamic library?
18:43:12 <bitemyapp> SparkySparkyBoom: do I know you from somewhere?
18:43:24 <Fuuzetsu> you don't need main in libraries
18:43:39 <dfeuer> Fuuzetsu, if I have an expression that looks like, say, ((a*Neutral)*b)*((Neutral*c)*d)  and I want to collapse all the neutrals and reassociate everything into a canonical form.
18:43:48 <Cale> ReinH: length . filter p in GHC will always end up forcing the evaluation of the entire input list, at least, unless some additional RULES pragma which is not in the standard library is added.
18:43:58 <dfeuer> So that I can compare two expressions and find them to be equivalent.
18:44:03 <ReinH> Cale: if it is forced at all
18:44:04 <dfeuer> That part is actually not hard.
18:44:14 <fread2281> is there any way to get Behavior t a -> Event t a in reactive-banana
18:44:18 <Cale> ReinH: yeah, this is assuming that the expression is evaluated
18:44:21 <timothyh> oh urgh there's no temperature hierarchy in units-defs either, I'll need to implement celsius and fahrenheit
18:44:25 <fread2281> (on changes, fire the event)
18:44:35 <dfeuer> The harder part is to make it clear that this process is the correct one to compare such expressions.
18:44:36 <ReinH> Cale: ok, that sounds like what I meant to say :)
18:44:37 <wepy> so.. ghc --make -dynamic X.hs bitched when i didn't have main
18:44:39 <Cale> fread2281: By design, there shouldn't be
18:44:46 <ReinH> wepy: You should use cabal
18:44:52 <fread2281> oh, I fount it
18:44:58 <Cale> fread2281: The whole point of Behaviours is that you can't tell when they change.
18:45:02 <wepy> maybe it's the --make.. without that it works
18:45:24 <Cale> fread2281: What did you find?
18:45:39 <fread2281> Cale, https://hackage.haskell.org/package/reactive-banana-0.8.1.2/docs/Reactive-Banana-Frameworks.html#v:changes
18:45:41 <dfeuer> Fuuzetsu, that is, to make sure that I don't *miss* any equivalences that I'm *supposed* to find.
18:45:50 <wepy> what's cabal, some package/module manager?
18:46:09 <ReinH> wepy: Yes.
18:46:17 <ReinH> It's the standard way to build haskell libraries and executables
18:46:22 <ReinH> and to manage package dependencies
18:46:38 <wepy> yuck :\
18:46:39 <Cale> fread2281: Ah, okay. I'd be careful with that :)
18:46:44 <ReinH> wepy: yuck?
18:46:54 <wepy> reminds me of cpan
18:47:05 <ReinH> wepy: Well, it's not great, but it does have the advantage of existing
18:47:11 <Cale> wepy: It's a whole lot nicer than Makefiles.
18:47:17 <wepy> i like Makefiles
18:47:23 <wepy> sorta.. sometimes :)
18:47:38 <wepy> dependency resolution is nice
18:47:50 <ReinH> wepy: cabal is the standard, there is also https://halcyon.sh/ but it is new and I'm not sure how extensively it is being used
18:47:58 <wepy> i'll try cabal later.. i wana get to know the ghc compiler more
18:48:03 <Fuuzetsu> dfeuer: I don't see how that fits in the original f (g x) -> g (f x) question so guess I can't help beyond there
18:48:08 <ReinH> wepy: I believe --make expects to build an executable
18:48:11 <Cale> You might also want to check out shake if you need something more customised in terms of your build system.
18:48:14 <ReinH> but I'm not sure, since I almost never use ghc directly
18:48:15 <Fuuzetsu> ReinH: or one could use nix which is an actual package manager instead
18:48:25 <ReinH> Fuuzetsu: indeed!
18:48:31 <TrueMagnap> dfeuer: The stars represent what?
18:48:39 <Cale> But Cabal is sufficient for almost everything except the most complicated programs.
18:49:01 <Fuuzetsu> I find it strange that ‚ÄòHalcyon is written in GNU bash‚Äô is seen as something to advertise ;P
18:49:21 <ReinH> Fuuzetsu: heh
18:49:24 <Cale> Note that Cabal isn't really a package manager, it's a package builder and installer.
18:49:25 <TrueMagnap> Hahaha
18:49:27 <ReinH> As opposed to the other kind of bash
18:49:46 <Cale> Or at least, cabal-install is that.
18:49:54 <dfeuer> Fuuzetsu, it comes in once I get to monoids.
18:49:55 <ReinH> Fuuzetsu: As someone who has written a lot of bash for building haskell packages, meh.
18:50:04 <Cale> Cabal itself is a library concerned with doing such things.
18:50:35 <dfeuer> Fuuzetsu, specifically, an expression either collapses all to neutral, or to a semigroup expression.
18:50:43 <dfeuer> (no neutrals)
18:50:49 <ReinH> Then again, cabal has some bugs I'd sorely like to see fixed, and halcyon seems to fix some of them
18:51:00 <TrueMagnap> dfeuer: Sorry if this is an extremely stupid question, but can't you just evaluate it?
18:51:04 <Cale> Which bugs?
18:51:31 <ReinH> Cale: Most recent one was running cabal test with a different Cabal version in scope than the one that the binary was build with
18:51:33 <ReinH> it fails
18:51:38 <ReinH> but cabal install, cabal build, and cabal configure do not
18:51:53 <dfeuer> TrueMagnap, I don't have any of the underlying values available to calculate it, so no.
18:52:02 <ReinH> So if your .cabal file constraints Cabal to a different version, you are hosed when you run cabal test
18:52:08 <ReinH> unless you cabal install cabal-install using that constraint
18:52:16 <Cale> heh
18:52:18 <ReinH> s/constraints/constrains
18:52:27 <Cale> That's interesting
18:52:46 <ReinH> Cale: So my job is building and releasing haskell packages, so I am quite familiar with cabal's... idiosyncrasies ;)
18:52:49 <TrueMagnap> dfeuer: Oooh! Right, so those were types in what you wrote before? I am still not sure what the stars represent
18:52:58 <ReinH> Well, among my jobs...
18:53:28 <dfeuer> TrueMagnap, a (semigroup) operation.
18:53:35 <wepy> ghc --make -dynamic -shared -fPIC X.hs -o libX.dylib... fails with "The IO action 'main' is not defined in module 'Main'"
18:53:40 <wepy> i tried without --make as well, same
18:53:52 <ReinH> Cale: Also if you write a library that is involved in building your package (e.g. that is used in Setup.hs), cabal will fail to install it the first time and then install it successfully when you retry
18:54:20 <ReinH> @hackage configuration-tools -- like this one
18:54:20 <lambdabot> http://hackage.haskell.org/package/configuration-tools -- like this one
18:54:26 <TrueMagnap> Which is commutative? I guess it'd have be
18:55:07 <ReinH> Cale: btw have you seen http://graphicallinearalgebra.net/ ? It introduces linear algebra via (string) diagram chasing
18:55:12 <ReinH> It's really nice
18:55:31 <Cale> ReinH: heh, I haven't
18:55:37 <TrueMagnap> Nooo, sorry, associative
18:55:46 <ReinH> Cale: I actually got a better intuition for comonads (as cocommutative comonoids) from it
18:55:52 <ReinH> er
18:55:55 <ReinH> not cocommutative
18:56:00 <ReinH> just comonoids
18:56:22 <ReinH> Also "cocommutative" sounds like it involves mutant coconuts
18:56:28 <dfeuer> TrueMagnap, just associative.
18:56:53 <TrueMagnap> Yeah, I changed that. Switched them around; had a brainfart
18:58:33 * hackagebot jammittools 0.4.1.1 - Export sheet music and audio from Windows/Mac app Jammit  http://hackage.haskell.org/package/jammittools-0.4.1.1 (mtolly)
18:58:43 <mietek> Fuuzetsu: truth in advertisement
18:59:07 <Fuuzetsu> oops I've been spotted
18:59:08 <mietek> Fuuzetsu: anyway, it‚Äôs not an advertisement; it‚Äôs a statement of fact. Some will appreciate that Halcyon can bootstrap a bare machine
18:59:14 <Fuuzetsu> yes
18:59:15 <mietek> Fuuzetsu: others will stay away
18:59:20 <wepy> i think ghc is broken on osx probably
18:59:43 <TrueMagnap> Over these last few hours, my self image has degraded to that of a rubber duck that talks back...
18:59:47 <ReinH> wepy: works for me
18:59:57 <korlm> I am learning Haskell (beginner) any ideas of project I could start that would be challenging with great learning outcomes? I am more interested in backend dev if that makes any difference? Thank you!!!
18:59:58 <mietek> Fuuzetsu: in the future, I‚Äôd like to keep just the bootstrapping part in bash, and move the rest to Haskell
19:00:10 <mietek> Fuuzetsu: not enough hours in the day to do that yet, though
19:00:20 <ReinH> korlm: it really depends on what your interests are. What sort of backend dev?
19:00:22 <Fuuzetsu> korlm: how beginner are you?
19:00:37 <Fuuzetsu> damn ReinH is trying to steal my slave^Wcontributor!
19:01:01 <ReinH> Fuuzetsu: :p
19:01:19 <ReinH> Fuuzetsu: unpaid labor is probably not the best way to introduce someone to haskell :p
19:01:33 <Fuuzetsu> works for companies with unpaid internships
19:01:34 <ReinH> Fuuzetsu: what project do you want contributors for?
19:01:40 <Fuuzetsu> any and all
19:01:42 <wepy> ReinH: I have a single line haskell file: foo n = n
19:01:43 <ReinH> Fuuzetsu: Yes, it works for the *companies*
19:01:58 <Fuuzetsu> registering #haskell ltd.
19:02:04 <ReinH> wepy: Well, you are trying to build an executable, so...
19:02:06 <wepy> and yet, ghc -dynamic -fPIC -c foo.hs can't compile a .o
19:02:13 <korlm> Fuuzetsu: I took a course about functional programming but it was in Racket. I started LYHFG and I have read it to the chapter on type classes.
19:02:20 <wepy> ReinH: i'm following the users_guide.pdf for GHC
19:02:34 <ReinH> wepy: (This could all be avoided if you would just use cabal)
19:02:42 <Fuuzetsu> korlm: well, what kind of stuff are you interested in? I think learning by doing is the best way myself.
19:02:49 <wepy> ghc -dynamic -fPIC -c foo.hs; ghc -dynamic -shared foo.o -o libfoo.dylib
19:02:52 <Fuuzetsu> (also the book in general is referred to as LYAH)
19:03:05 <wepy> i don't want to use cabal yet.. how can i debug a real problem if i can't use the compiler/linker ;)
19:03:19 <ReinH> korlm: what sort of backend dev interests you?
19:03:47 <ReinH> wepy: ok then
19:04:27 <korlm> ReinH: that's an excellent question, I don't really know what to answer. (I am very very very junior) 
19:04:48 <ReinH> korlm: Haskell is a general purpose language, so you should use it to do things that interest you
19:05:26 <ReinH> korlm: if you weren't using Haskell, what kind of programs would you want to write?
19:05:39 <korlm> ReinH: I like to make libraries for developers!
19:05:48 <korlm> Actually I love it
19:06:03 <Fuuzetsu> what kind of libraries?
19:06:20 <ReinH> Most libraries are libraries for developers...
19:06:32 <korlm> I've never done anything "big" but I like to abstract stuff so people can use those to build their own things
19:06:57 <korlm> Fuuzetsu: Something like request in Python for example
19:07:05 <korlm> ReinH: good point! :p
19:07:20 <Fuuzetsu> well, that's a lot better than ‚Äòlibraries‚Äô ;P
19:07:35 <ReinH> I suppose the other ones are libraries that no one uses...
19:07:44 <ReinH> korlm: what languages are you familiar with?
19:08:17 <korlm> ReinH: Python, Racket, C and Javascript
19:08:45 <ReinH> Maybe you could try rewriting a tool you have already written to Haskell
19:09:15 <ReinH> korlm: I can't suggest any particularly "haskelly" program ideas because it really is quite good at most things
19:09:43 <korlm> What do you use Haskell for? ReinH 
19:09:52 <Fuuzetsu> hopefully everything
19:09:55 <wepy> ReinH: needed "module Foobar where" at the top of the file
19:10:06 <wepy> ghc inserts a "module Main where" if the file doesn't have it
19:10:16 <ReinH> korlm: Well, my day job is mostly building/testing/deploying other people's Haskell programs
19:10:32 <ReinH> wepy: Ah!
19:10:40 <fread2281> how can I put a thread to sleep forever?
19:10:44 <wepy> the user guide doesn't mention it.. some github page did
19:10:54 <Fuuzetsu> fread2281: maxThreadDelay or whatever it was
19:10:59 <wepy> what does "module X where" mean?
19:11:05 <ReinH> fread2281: forever (threadDelay maxThreadDelay) or whatever
19:11:07 <SparkySparkyBoom> bitemyapp: i don't think so
19:11:10 <Fuuzetsu> fread2281: but there is a bug with that on OSX with 7.6 (or maybe 7.8) so beware
19:11:16 <SparkySparkyBoom> i occasionally ask questions in here
19:11:25 <SparkySparkyBoom> you might have helped me at some point
19:11:42 <ReinH> wepy: a module in Haskell is a namespace https://www.haskell.org/tutorial/modules.html
19:12:51 <wepy> ah ok
19:13:08 <ReinH> They are not like ML modules
19:13:16 <Fuuzetsu> korlm: I have a small program here that has a lot of room for fixing and expansion, on the surface it just does some OCR and calls external program but internally you'd learn about GUI, talking to webservices (for translation, might have to write a binding to some service first), concurrency, calling out external processes &c; Let me know if you' re interested 
19:13:50 <Fuuzetsu> it's out of your skill level right now for sure but I think that's good
19:14:09 <Fuuzetsu> I have some ideas for it but not the time :)
19:16:00 <wgosling> can you not have two record types that have a field with the same name?
19:16:02 <wepy> it's like python modules
19:16:04 <wepy> neat
19:16:08 <ReinH> wgosling: nope
19:16:16 <wgosling> Oh.
19:16:21 <Fuuzetsu> not in vanilla Haskell anyway‚Ä¶
19:16:24 <ReinH> Unless the names are qualified, so not the same name
19:16:32 <wgosling> Why not?
19:16:38 <ReinH> Because reasons
19:16:39 <MichaelBurge> wgosling: I usually prefix the record type on each field name. So 'data Foo = Foo { fooName :: Text }'
19:17:10 <ReinH> wgosling: not particularly good reasons
19:17:38 <wgosling> ReinH: that's what I assumed from "because reasons" :P
19:17:43 <korlm> ReinH: sounds interesting
19:17:45 <ReinH> wgosling: There is a plan to allow it, or at least a plan to consider allowing it https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields
19:18:05 <korlm> Fuuzetsu: I am a bit scared of not doing things the "Haskell way" and not taking advantage of the language
19:18:22 <korlm> I don't think people write Haskell the same way they write Python for example 
19:18:25 <ReinH> wgosling: We are currently bikeshedding on the implementation, I believe.
19:18:38 <dfeuer> TrueMagnap, Fuuzetsu, here's the code. Look at the stuff at the very bottom of Monoid to see what I'm asking about. The names are probably all horrible, and much else.
19:18:39 <Fuuzetsu> korlm: they don't but it's not something you can learn without writing code
19:18:50 <ReinH> wgosling: The reason is basically "we didn't think to do that" ;)
19:18:59 <wgosling> lol
19:19:16 <Fuuzetsu> dfeuer: link?
19:19:20 <ReinH> Or maybe, "we thought about it and decided not to because it was hard", I'm not really sure
19:19:37 <Fuuzetsu> ReinH: ORF is pretty much done IIRC
19:19:45 <Fuuzetsu> it was just not reviewed completely before 7.10
19:19:46 <ReinH> Fuuzetsu: thus "bikeshedding" ;)
19:19:55 <dfeuer> Fuuzetsu, oh, that: https://github.com/treeowl/Idris-basic-algebra
19:20:22 <dfeuer> ORF is scary.
19:20:35 * dfeuer is not really convinced of it yet :P
19:20:42 <wgosling> I'm trying to parse json here, and the first library from this list http://hackage.haskell.org/packages/#cat:JSON suggest just making a record type for each json object type and it will do some magic. doesn't seem feasibly since every object in the json has a "url" field... 
19:20:52 <Fuuzetsu> when is idris going to stop declaring war on unicode
19:21:01 * Fuuzetsu mutters
19:22:25 <dfeuer> Fuuzetsu, as soon as space cadet keyboards become commonplace. That's one of the few controversial decisions it's made that I agree with.
19:22:42 <Fuuzetsu> dfeuer: don't need a space cadet keyboard to type unicode in
19:22:46 <dfeuer> oh yes, and mobile device font sets can handle agda.
19:23:03 <Fuuzetsu> and lack of it results in such awesome identifiers like <++> or ~= rather than long-established notation
19:23:08 <ReinH> wgosling: If you aren't using aeson, you should stop what you are doing and use aeson.
19:23:16 <dfeuer> Because if I can't read things on my phone, they might as well not exist.
19:23:35 <dfeuer> Fuuzetsu, you will soon find much more serious problems with my code, I'm sure :)
19:23:45 <ReinH> Oh conveniently that is the first library in the list
19:23:48 <wgosling> ReinH: I am using aeson. It looks like there is a way to manually map things. I'll try that out.
19:24:05 <Fuuzetsu> dfeuer: unfortunately I don't have time to study it
19:24:11 <ReinH> wgosling: You want to use the FromJSON class
19:24:26 <dfeuer> Oh well.
19:24:40 <ReinH> wgosling: maybe this tutorial will be useful http://artyom.me/aeson
19:24:44 <dfeuer> Fuuzetsu, there's a diagram at the bottom of the Monoids module,
19:24:50 <Fuuzetsu> wgosling: you can pass an option to the deriver that can for example drop prefix from each field name
19:24:51 <dfeuer> that explains the situation.
19:25:39 <ReinH> wgosling: Yes, it can be very useful if there's a programmatic way to map the json keys to record field names, etc. See https://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson-TH.html
19:25:48 <Fuuzetsu> wgosling: https://github.com/zalora/myrapi/blob/master/src/Myracloud/Types.hs#L38
19:26:06 <Fuuzetsu> Generic > TH
19:26:58 <ReinH> Fuuzetsu: no, TH > Generic :)
19:27:08 <ReinH> "Deprecated: This module will be REMOVED in version 0.7.0.0. Please switch to GHC generics or Data.Aeson.TH instead. These alternatives are less buggy, faster, and more configurable."
19:27:17 <ReinH> :p
19:27:32 <Fuuzetsu> ReinH: I of course meant GHC generics
19:27:37 <dfeuer> ReinH, doesn't that depend on whether you're trying to minimize or maximize?
19:28:15 <ReinH> dfeuer: I'm not sure what you mean
19:28:17 <Fuuzetsu> I had a trawl through aeson's generics implementation just the other day in fact
19:28:24 <dfeuer> ReinH, I'm joking.
19:28:30 <ReinH> dfeuer: I'm sure it was hilarious :)
19:28:45 <dfeuer> ReinH, I just mean that the > can be read as "better" or "worse".
19:28:50 <wepy> there should be a generic hashell FFI lib..
19:28:52 <ReinH> dfeuer: I get it :)
19:29:08 <wepy> and like.. you'd initialize it with a list of pure haskell libraries to import.. and init args
19:29:37 <Fuuzetsu> ‚Äòhashell‚Äô sounds like a different project
19:30:12 <ReinH> Personally I don't put a lot of thought into calling Haskell from other languages. ;)
19:30:38 <wepy> ReinH: does it suck or something?
19:30:54 <wepy> i was just thinking.. for game development, most of it's nice to do in C or C++
19:31:02 <wepy> but maybe haskell would be nice to use for some other parts
19:31:08 <MP2E> I think the point is that it's so good that calling into it from another language isn't even a thought.
19:31:09 <Fuuzetsu> I would definitely not say it's ‚Äònice‚Äô to do in C or C++
19:31:10 <ReinH> No, I just don't feel the need to write in other languages when I could use Haskell
19:31:15 <wepy> although, i think the GC might ruin that.. might be worth a short
19:31:18 <wepy> shot
19:31:27 <wepy> hm
19:31:27 <Fuuzetsu> there is #haskell-game if you want to ponder that
19:31:28 <oconnore> at work I call haskell from Matlab :P
19:31:33 <ReinH> I would suggest that most of it isn't nice to do in C or C++
19:31:52 <oconnore> Matlab's FFI is hell
19:31:52 <ReinH> a small part of it might be nice, which is why I *do* care about FFI the other way
19:31:57 <wepy> but wouldn't haskell be good for.. AI parts?
19:32:04 <ReinH> And lots of other parts too
19:32:06 <Fuuzetsu> oconnore: are there parts of Matlab that aren't hell?
19:32:27 <MP2E> why wouldn't it be good for all the parts? I could see calling out to SDL2 for rendering and handling input/windows. But other than that.... Haskell can handle it all
19:32:36 <wepy> i can understand that, i hate c++ a lot :)
19:32:44 <oconnore> Fuuzetsu: sure, it's a reasonable interface into LAPACK/BLAS, and it solves a bunch of problems for you
19:32:44 <ReinH> MP2E: that's what I'm getting at ;)
19:32:57 <Fuuzetsu> I thought we had bindings to those
19:33:13 <Fuuzetsu> oh, or maybe that was a potential summer project‚Ä¶
19:33:20 <wepy> ReinH: i'm working with a few guys on a game project using Doom-3-BFG code..
19:33:26 <wepy> it's like.. a million lines of C++ ;)
19:33:34 <wepy> would be nice to slowly replace parts with haskell
19:33:41 <wepy> but FFI could help me do that in pieces
19:34:14 <wepy> although.. C++.. would almost have to make a C API between things first
19:34:26 <Fuuzetsu> aha
19:34:27 <Fuuzetsu> there it is
19:34:32 <Fuuzetsu> Abstract: HBLAS is an important submodule in Haskell Numerical. It helps matrix computation efficient, and it probably will have a greate impact on scientific computing in the future of Haskell. HBLAS now has some basic BLAS API bindings. I will provide the rest of the BLAS bindings and docs. And then work on the bindings with LAPACK.
19:34:34 <Fuuzetsu> accepted
19:36:22 <fread2281> how safe is sodium's executeAsyncIO?
19:38:01 <Voltz> Hello.
19:38:11 <ReinH> Voltz: hi
19:39:24 <zed_> Hi : ) Does anyone uses the GSL binding ?
19:39:29 <ReinH> wepy: theoretically you can `foreign export` functions from haskell
19:39:45 <Voltz> so... Probably the most common question ever asked about Haskell: What is, and how do Monads work?...
19:39:45 <peddie> zed_: I use hmatrix and hmatrix-gsl
19:40:11 <ReinH> wepy: e.g., http://stackoverflow.com/questions/3859340/calling-haskell-from-c-code
19:40:20 <oconnore> Fuuzetsu: I think for us, Haskell provides a solid base application layer, but is not optimal for say, designing a control algorithm
19:40:33 <fread2281> or, how could I loop on executeAsyncIO (after it finished, do it again)?
19:40:40 <oconnore> once I am confident the data is correct, I want to think about frequency response, not about types
19:40:51 <ReinH> Voltz: Monad is a type class that provides return and (>>=), instances work by implementing those methods.
19:40:51 <oconnore> so maybe Julia + haskell would be ideal, eventually
19:41:07 <ReinH> :t (>>=)
19:41:08 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:41:13 <ReinH> What that does depends on what m is
19:41:38 <ReinH> The only thing you know is that it has that type and is supposed to satisfy certain laws
19:43:04 <ReinH> Voltz: You might read various explanations that talk about "computation" and etc. These explanations are lies, but perhaps useful lies.
19:44:13 <Voltz> Could you cite a source? "talk about 'computation
19:44:25 <Voltz> is kind of vague
19:44:33 <ReinH> Voltz: many of these https://wiki.haskell.org/Monad_tutorials_timeline
19:44:44 <fread2281> Voltz, `m a` means that `m` can refer to `a` (store it, take it as an arg, etc)
19:45:01 <ReinH> The best possible source to learn how monads work would be Wadler's original paper on monads for functional programming, http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
19:45:20 <ReinH> It explains and motivates the use of monads while lying as little as possible
19:45:34 <fread2281> :t join
19:45:35 <lambdabot> Monad m => m (m a) -> m a
19:45:54 <fread2281> join is equivalent to (>>=) and perhaps easier to understand
19:46:17 <ReinH> Voltz: Honestly I would recommend ignoring everything else and reading that paper.
19:47:03 <ReinH> Wadler is a great writer
19:47:19 <Voltz> I have been trying to read,watch everything on monads, It just doesn't make sense how they work, replication of state and such.
19:47:45 <peddie> zed_: what's up?
19:47:52 <zed_> well
19:47:58 <ReinH> Voltz: try that paper
19:48:02 <Fuuzetsu> Voltz: in Haskell it's just an abstraction of a pattern
19:48:03 <ReinH> really, it's very good
19:48:20 <zed_> Voltz: do you have any math background ?
19:48:38 <dfeuer> ARGH.
19:48:49 <ReinH> Voltz: This is the part where we all try to explain monads to you at the same time in a way that is guaranteed to confuse you. :)
19:49:01 <zed_> peddie: so i am teaching myself Haskell by re-writing C code written in a scientific calculus class
19:49:11 <Voltz> I do enjoy learning about math, but I have no formal tutoring past calc1.
19:49:21 <peddie> zed_: cool
19:50:25 <zed_> peddie: And I am struggling on how to make a proper use of the gsl binding... and learning Haskell.. so if you or anyone else would be willing to read some pretty basic code and help me find why it's not working, I would be pretty happy - I know it's not something that eveyrone finds interesting so feel free to say no : )
19:50:45 <ReinH> zed_: if you put some code on lpaste and ask us questions about it, someone might be able to help
19:50:49 <ReinH> @where lpaste
19:50:49 <lambdabot> http://lpaste.net/
19:50:52 <rasen> Is it possible to get stack overflow in Haskell?
19:50:57 <ReinH> rasen: Yes.
19:51:27 <rasen> I'm trying to get one with examples from wiki, but they don't seem to overflow. Just eat all my memory
19:51:36 <fread2281> http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html is good, but the boxes don't necessarily store things
19:51:37 <ReinH> rasen: Recently GHC changed the default stack size
19:52:08 <MichaelBurge> Voltz: I recommend ignoring monads and just writing Haskell code. At some point, you'll come across a monad tutorial and recognize it as succinctly capturing a pattern in the code you've already written.
19:52:10 <peddie> zed_: yeah, try pasting the code along with the error you're getting or the result you expect alongside the result you get
19:52:17 <rasen> ReinH: Did that happen before 7.8.4?
19:52:26 <ReinH> rasen: Yep.
19:52:31 <zed_> thanks - will do in a minute
19:52:43 <rasen> Ok. Then it seems to be the answer
19:52:59 <Voltz> That confused me though, because wouldn't changing the context modify a state?
19:54:36 <ReinH> Voltz: this is a question about how return and (>>=) are defined for State, not about monads in general :)
19:56:47 <zed_> Voltz: ok, or else I might have you directed to traditional category theory things.
19:57:41 <Fuuzetsu> I suspect they would have know about monads if they knew category theory things already 
19:57:52 <lpaste> zed pasted ‚Äúpi_estimation_area‚Äù at http://lpaste.net/132322
19:58:08 <Voltz> I just think I need to read a lot more... I read a paper on category theory but didn't get very far, A lot of terminology that was completely alien to me.
19:58:35 <Fuuzetsu> you don't need to know category theory to be able to use and even make your own monads in Haskell
19:58:38 <lpaste> zed annotated ‚Äúpi_estimation_area‚Äù with ‚Äúpi_estimation_area (annotation)‚Äù at http://lpaste.net/132322#a132323
19:59:42 <zed_> Fuutzetsu: I know, but for some people (like me), it is easier to go through the formal things first and then to get hands-on than the other way around
20:00:04 <ReinH> Voltz: please don't go learn category theory if you want to understand monads...
20:00:11 <ReinH> It's not really relevant.
20:00:15 <zed_> exactly
20:00:27 <ReinH> If you want to learn category theory, that's fine. It's very interesting. But don't feel like it's a prerequisite.
20:01:33 <peddie> zed_: the immediate issue I see with the code you pasted is that most of those c'gsl_whatever functions are in IO
20:01:56 <peddie> so you can't do e.g. 'c'gsl_rng_set(r,time)' in a let clause
20:02:15 <peddie> you have to bind values to names in a let clause; maybe you wanted to use a do clause instead?
20:02:22 <zed_> peddie: FYI, i might know math, but i'm really new to coding and everything
20:02:35 <peddie> zed_: I think your life might be easier if you skip bindings-gsl and use the higher-level interfaces provided by the hmatrix-* packages
20:03:04 <ReinH> zed_: drawing out the string diagrams did help me understand monads better
20:03:06 <Cale> zed_: You really ought to configure your text editor to convert tabs to spaces for you automatically
20:03:21 <fread2281> does sodium have a channel?
20:03:30 <peddie> zed_: e.g. hmatrix-gsl-stats provides https://hackage.haskell.org/package/hmatrix-gsl-stats-0.2.1/docs/Numeric-GSL-Distribution-Continuous.html#t:TwoParamDist
20:03:37 <ReinH> Especially when it came time to understand how adjunctions fit in
20:04:42 <zed_> peddie: reading.
20:04:47 <zed_> peddie: Thanks : )
20:05:11 <peddie> zed_: the bindings-gsl package is very low-level and not very nice to program with, partly because everything is in IO
20:06:08 <zed_> peddie: i'm just afraid that not everything I will need will be available in other packages, although if I can generate uniforms i am mostly done
20:07:00 <zed_> peddie: do you know of any webpage that shows examples of the package https://hackage.haskell.org/package/hmatrix-gsl-stats-0.2.1/docs/Numeric-GSL-Distribution-Continuous.html#t:TwoParamDist ?
20:07:05 <peddie> zed_: I would see if you can find it first in the hmatrix-* packages (hmatrix, hmatrix-glpk, hmatrix-gsl, hmatrix-gsl-stats)
20:07:36 <zed_> Cale : good idea
20:07:40 <Sonderblade> is there a filter function in haskell with the predicate negated?
20:07:54 <ReinH> sure, \p -> filter (not . p)
20:08:05 <peddie> zed_: no, I don't know of any, but I suspect you'd do something like "random_2p Uniform <min> <max>" to get a random value from the uniform distribution
20:08:57 <Sonderblade> is there such a function defined?
20:09:54 <ReinH> Sonderblade: No, because it's easy to use not
20:10:35 <Cale> zed_: One thing you need to be aware of is that when you see a function f :: A -> IO B, the result of such a function is not a value of type B, rather it's a description of an action which could be carried out to produce a value of type B. So if you write something like let y = f x, then y :: IO B will be that resulting action, but not the value of type B you might be after.
20:12:19 <phy1729> I have a type  data Subgroup = Subgroup { group :: Group, matrix :: Data.Matrix.Matrix Int }   most functions only operate on the matrix bit and the group is never changed. This feels like a functor/monad and that there should be a clean way to only operate on the matrix, but Subgroup isn't a type constructor.
20:12:45 <ReinH> phy1729: Well, it is also the wrong kind
20:12:51 <ReinH> Oh, I think that's what you meant
20:12:55 <Cale> zed_: As such, you can't just pass the IO action along to a function which is expecting a value of type B, you have to execute it first, and pass its result. You can do this inside of another IO action, writing  v <- x  inside of a do-block will mean that v is the result of executing the IO action x. The do-block as a whole will then be an expression for an IO action having a possibly different type of result (whatever
20:12:55 <Cale>  type of result the last action in it has)
20:12:55 <phy1729> yeah
20:13:04 <benzrf> phy1729: perhaps you want lenses
20:13:05 <Fuuzetsu> phy1729: why does it feel like a functor/monad? it's not
20:13:10 <ReinH> phy1729: perhaps you want https://hackage.haskell.org/package/mono-traversable
20:13:34 <phy1729> Fuuzetsu: because I'm actng on a Matrix in the context of a group
20:14:09 <ReinH> phy1729: or you could use Subgroup a = Subgroup { ..., matrix ::: Matrix a }
20:14:16 <ReinH> s/:::/::
20:14:29 <Fuuzetsu> ReinH: cool package, seems I have some old code to revisit
20:14:39 <phy1729> ReinH: the problem is that the tye only makes sense for Integral a's
20:15:27 <Fuuzetsu> ReinH: that's still only let him pass a -> b whereas it sounds like he wants the whole matrix‚Ä¶
20:15:30 <Fuuzetsu> that'd*
20:15:37 <ReinH> phy1729: sometimes I use data Subgroup' a; type Subgroup = Subgroup' Int
20:16:39 <ReinH> Fuuzetsu: ah, that's true.
20:16:48 <phy1729> perhaps type Subgroup = Subgroup' Data.Matrix.Matrix Int
20:17:17 <ReinH> I don't think functor/monad is the right abstraction
20:17:22 <ReinH> what are you modeling?
20:17:45 <ReinH> (Anyway I don't think it makes a valid Monad instance no matter how you slice it)
20:17:59 <phy1729> Well I'm morphing Subgroups into other Subgroups
20:18:07 <phy1729> yeah functor would make more sense
20:18:18 <Fuuzetsu> the package ReinH linked is probably what you're after
20:18:29 <Fuuzetsu> it seems to me you want something that ‚Äòcan map over the thing inside‚Äô
20:19:05 <zed_> Cale: thanks for the explanation, it is helpful : )
20:19:13 <phy1729> more or less. I do a lot of   func (Subgroup group matrix) = Subgroup group $ stuff.on $ matrix
20:19:39 <Fuuzetsu> phy1729: easiest way is to just define onMatrix function
20:20:04 <Voltz> Well, Thanks for the paper. I'll be sure to read it thoroughly.
20:20:17 <Fuuzetsu> (Matrix Int -> Matrix Int) -> Subgroup -> Subgroup
20:20:43 <Fuuzetsu> the MonoFunctor in that package will work for this
20:20:50 <Fuuzetsu> then onMatrix = omap
20:20:59 <phy1729> Fuuzetsu: thanks I'll look into it
20:21:04 <TrueMagnap> Voltz: Something that really helped me understand monads was the article/post "You could've invented monads". I can find a link if you like, but I think it's the first result if you google that phrase
20:21:48 <benzrf> eugh
20:21:48 <Fuuzetsu> @google you could have invented monads
20:21:49 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
20:21:49 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Al...
20:22:16 <TrueMagnap> Cool feature!
20:22:16 <Fuuzetsu> nearly a decade old no less
20:22:29 <TrueMagnap> Still very useful
20:24:10 <ReinH> Yep, Dan's stuff is all very good
20:25:38 <ReinH> Also with lens it could be over matrix f
20:32:52 <fread2281> is there any way to get changes (fromChanges x y) to fire once with the initial value?
20:32:54 <fread2281> in reactive-banana
20:41:39 <kadoban> How does one do something like Int -> Word32, if I'm fine with anything at all happening if it's negative or too big?
20:43:36 * hackagebot CirruParser 0.0.1 - Cirru Parser in Haskell  http://hackage.haskell.org/package/CirruParser-0.0.1 (jiyinyiyong)
20:44:21 <solatis> kadoban, what do you mean "anything at all" ? undefined behaviour ?
20:44:27 <nshepperd> > fromIntegral (-5 :: Int) :: Word32
20:44:28 <lambdabot>  4294967291
20:45:09 <solatis> > fromIntegral (2^33 :: Integer) :: Word32
20:45:10 <lambdabot>  0
20:45:19 <kadoban> Oh, thanks. Yeah, I don't really care what happens, I'm sure of what range they'll be in.
20:45:46 <nshepperd> Word32 uses wrapping arithhmetic
20:46:27 <solatis> "wrapping" means overflow ?
20:46:47 <nshepperd> mod (2^32)
20:47:09 <zed_> peddie: yeah it worked, I am able to generate a uniform : ) thank you !
20:48:17 <peddie> zed_: no problem, glad to hear it
20:58:36 * hackagebot cirru-parser 0.0.2 - Cirru Parser in Haskell  http://hackage.haskell.org/package/cirru-parser-0.0.2 (jiyinyiyong)
21:12:47 <Pamelloes> Is anyone here familiar with the constraints package?
21:13:14 <greymalkin> Hm... so Aeson doesn't have Traversable for its Parser class?
21:13:37 * hackagebot termbox-bindings 0.1.0.4 - Bindings to the Termbox library  http://hackage.haskell.org/package/termbox-bindings-0.1.0.4 (lcfrs)
21:17:50 <zed_> so let's say that you wanted to write the pi simulation (aka the hello world of monte carlo simulation : ) ) with haskell... is there any examples on the web ? I found the patrick perry one using http://hackage.haskell.org/package/monte-carlo but maybe you know others...thanks
21:20:49 <peddie> zed_: I don't know whether that was addressed to me, but I don't know any good examples of monte carlo simulations off the top of my head
21:21:19 <zed_> peddie: well it was a broad question so yeah - thanks for answering
21:23:37 * hackagebot termbox-bindings 0.1.0.5 - Bindings to the Termbox library  http://hackage.haskell.org/package/termbox-bindings-0.1.0.5 (lcfrs)
21:29:45 <zed_> it's getting late here - thanks everyone and have a nice day/evening : )
21:29:48 <bb010g> How come the constraint `a ~ ()` is used in https://github.com/chrisdone/lucid/blob/16c4b09ee90e2e61fef0e1070c0c3ebaf6246da1/src/Lucid/Base.hs#L81 instead of replacing `a` with `()`?
21:31:25 <geekosaur> probably because doing it that way would make it part of instance selection instead of a constraint checked afterward
21:31:42 <geekosaur> which is a somewhat subtle interaction with type checking
21:33:37 * hackagebot base58string 0.10.0 - Fast and safe representation of a Base-58 string  http://hackage.haskell.org/package/base58string-0.10.0 (solatis)
21:40:55 <ReinH> Hmm, maybe termbox will finally kill ncurses dead...
21:40:59 <ReinH> I should check it out
21:49:04 <kaidelong> hasn't ncurses finally been ported to windows?
21:50:48 <kaidelong> only "sort of"
21:53:58 <kaidelong> not much about how portable termbox is but it was designed with portability in mind
21:54:07 <ReinH> geekosaur: My understanding is limited to "because a ~ () works but () doesn't for Reasons"
21:54:18 <ReinH> kaidelong: it seems pretty young, but I think the design is better.
21:54:50 <ReinH> geekosaur: But I did understand most of the words you used...
21:55:48 <kaidelong> termbox seems neat enough, it just would have been awful if everyone started moving to a new library the moment ncurses started working on windows
21:56:54 <ttt_fff> in haskell, is there anyway to write single page applications, besides using Haste/GHCJS ?
21:58:12 <dmj`> ttt_fff: maybe jmacro
21:58:30 <ttt_fff> is jmacro really oprogramming in haskell?
21:58:40 <ttt_fff> from everything I've looked at, jmacro looks like a javscript "assembler"
21:58:46 <ttt_fff> rather than an actual "code in HS" system
21:58:50 <jle`> ttt_fff: there's fay :)
21:58:57 <jle`> i think FPComplete IDE is written in fay
21:58:58 <ttt_fff> fay is not haskell
21:59:04 <ttt_fff> it lacks typeclasses
21:59:22 <ttt_fff> I don't get how people can build anythign without typeclasses
21:59:29 <jle`> you'd be surprised :)
21:59:40 <Fuuzetsu> probably manually pass records
22:00:01 <ttt_fff> Fuuzetsu: how do you use records to simulate typeclasses?
22:00:06 <fread2281> help! when I redirect stdout with reactive-banana, putStrLn doesn't work
22:00:10 <jle`> presumably, the same way GHC does :3
22:00:24 <ttt_fff> jle`: I have not read the ghc source. Please enlighten me.
22:00:38 <Fuuzetsu> turn typeclasses into records and instead of instances you have actual instantiated records
22:00:41 <jle`> Eq a => a -> a -> Bool becomes something like Eq a -> a -> a -> Bool
22:00:57 <jle`> where data Eq a = Eq (a -> a -> Bool) (a -> a -> Bool)
22:01:05 <jle`> a record with an (==) and a (/=)
22:01:12 <dmj`> jle`: you use hakyll for your blog?
22:01:20 <dmj`> jw
22:01:21 <jle`> no it's not static so i can't
22:01:24 <jle`> :/
22:01:27 <Fuuzetsu> it has the advantage of being able to have multiple instances for one datatype :)
22:01:50 <ttt_fff> jle` , Fuuzetsu: hey, that is pretty cute
22:02:22 <KaneTW> https://github.com/faylang/fay/wiki/Why-fay-does-not-currently-support-type-classes
22:02:29 <jle`> actaully you could even do something like data Eq a = Eq { (==) :: a -> a -> Bool, (/=) :: a -> a -> Bool }, and then do foo (Eq {..}) to get (==)/etc. in scope.  tekmo's blog talks about a technique like this
22:02:41 <jle`> haskellforall scrap your typeclasses etc.
22:02:55 <jle`> anyways this is actually implements typeclasses
22:03:01 <jle`> *this is how ghc actually
22:04:48 <fread2281> anyone have any idea what might be happening?
22:05:13 <dmj`> fread2281: can you share code on lpaste.net ?
22:05:14 <KaneTW> fread2281: give us some example code
22:05:30 <ttt_fff> jle`: is implementing typeclsses is so easy, why has fay not done it yet? :-)
22:05:59 <jle`> see KaneTW 's link
22:06:02 <Fuuzetsu> it tells you why on the link
22:06:26 <ttt_fff> hmm
22:06:33 <ttt_fff> so it sounds like it says: "We really want it; but it's complicated."
22:06:38 <ttt_fff> what type of answer is that? :-)
22:07:15 <KaneTW> it's "we don't run our own type checker and getting it from ghc involves using undocumented unstable APIs"
22:07:40 <fread2281> https://gist.github.com/anonymous/436fb1e7de7de2312e28 when I run it | cat - or it | tee tmp     no output but without that, output
22:08:03 <ttt_fff> hmm, is htere an easy way to hack ghc so it does *.hs -> *.fay for the typeclass conversion ?
22:08:39 * hackagebot bitcoin-types 0.9.2 - Provides consistent low-level types used commonly among Bitcoin implementations  http://hackage.haskell.org/package/bitcoin-types-0.9.2 (solatis)
22:09:27 <KaneTW> not an easy way
22:09:48 <ttt_fff> :-(
22:09:59 <Fuuzetsu> it's not the conversion, it's how to pick which instance to use
22:10:21 <Fuuzetsu> IMHO they should just use the GHC API and if it's undocumented or whatever, do some legwork in that area
22:11:56 <field50> Hi, I'm beginner using freenode.  What client do you use?
22:12:30 <ttt_fff> emacs
22:12:32 <ttt_fff> webchat
22:12:34 <jle`> weechat
22:12:37 <phy1729> weechat
22:12:40 <jle`> o/
22:12:44 <phy1729> \o
22:12:49 <Fuuzetsu> emacs
22:12:58 <MP2E> irssi
22:13:04 <fread2281> needed a hFlush stdout :/
22:13:17 <ttt_fff> so sad, no good way to do haskell / javascript
22:13:38 <ReinH> what's wrong with ghcjs?
22:13:39 <jle`> ttt_fff: between the ones you listed and the ones we did, we got at couple good ways
22:13:42 <ttt_fff> does either fay or haste support aeson ?
22:13:48 <Fuuzetsu> well, maybe there is one if you didn't start by excluding GHCJS/Haste from the getgo
22:14:00 <phy1729> field50: didn't realize the channel, you should ask these kinds of things in #freenode 
22:14:26 <field50> everyone: emacs, webchat, weechat, irssi,...  Thanks!
22:14:50 <jle`> "are there any ways to do this other than ___?"  "yes, ___". "sigh, no good ways to do this" :)
22:15:27 <field50> phy1729: OK, thank you. 
22:19:32 <fread2281> is there a formatting function for Rational as a percentage with some decimal points?
22:20:34 <dmj`> > printf "%.2f\n" pi
22:20:36 <lambdabot>      No instance for (Show a0)
22:20:36 <lambdabot>        arising from a use of ‚Äòshow_M301310212108523768924046‚Äô
22:20:36 <lambdabot>      The type variable ‚Äòa0‚Äô is ambiguous
22:21:04 <dmj`> @typ printf "%.2f\n" pi
22:21:05 <lambdabot> PrintfType t => t
22:21:10 <fread2281> > printf "%.2f\n" (pi :: Rational)
22:21:11 <liyang> fread2281: (printf "%.2f%%" . (*) 100) (inverse pi)
22:21:11 <lambdabot>      Could not deduce (PrintfArg (Ratio Integer))
22:21:11 <lambdabot>        arising from a use of ‚Äòprintf‚Äô
22:21:11 <lambdabot>      from the context (PrintfType t)
22:21:18 <liyang> > (printf "%.2f%%" . (*) 100) (inverse pi)
22:21:20 <lambdabot>      Not in scope: ‚Äòinverse‚Äô
22:21:20 <lambdabot>      Perhaps you meant one of these:
22:21:20 <lambdabot>        ‚Äòreverse‚Äô (imported from Data.List),
22:21:34 <liyang> > (printf "%.2f%%" . (*) 100) (recip pi)
22:21:36 <lambdabot>      No instance for (Show a0)
22:21:36 <lambdabot>        arising from a use of ‚Äòshow_M791052498868702889124096‚Äô
22:21:36 <lambdabot>      The type variable ‚Äòa0‚Äô is ambiguous
22:21:47 <liyang> > (printf "%.2f%%" . (*) 100) (recip pi :: Rational)
22:21:48 <lambdabot>      Could not deduce (PrintfArg (Ratio Integer))
22:21:48 <lambdabot>        arising from a use of ‚Äòprintf‚Äô
22:21:48 <lambdabot>      from the context (PrintfType c)
22:21:52 <Fuuzetsu> please, /query
22:21:55 <liyang> D:
22:22:08 <liyang> Fuuzetsu: sorry. Not enough coffee.
22:22:21 <Fuuzetsu> never enough
22:22:52 <liyang> I'm surprised there's no PrintfArg instance for Rational...
22:23:39 * hackagebot sdr 0.1.0.2 - A software defined radio library  http://hackage.haskell.org/package/sdr-0.1.0.2 (adamwalker)
22:25:32 <user> Would it be possible to implement "TODO" as a Template Haskell splice that knows the type of the unfinished hole it fills?
22:25:49 <user> I'm not finding methods that are local enough for that
22:26:16 <liyang> > printf "%.2f%%" . (*) (100 :: Double) $ realToFrac (123 % 456 :: Rational) :: String
22:26:18 <lambdabot>  "26.97%"
22:28:18 <Fuuzetsu> user: what exactly do you want? maybe -fdefer-typed-holes achieves what you're after?
22:28:47 <Fuuzetsu> or maybe just TODO = undefined
22:28:55 <Fuuzetsu> well, tODO = undefined :)
22:29:21 <user> What I'd like to do is be able to put TODOs around source code and then keep track of them at a top level
22:29:30 <user> like an external webapp
22:29:56 <user> and I'm trying to think of how I could have them maybe report their own existences, or have template haskell at the top level find them
22:30:46 <Fuuzetsu> so you have foo = 1 + TODO and TH would generate a top-level declaration foo_todo :: Num a => a or something?
22:30:50 <dmj`> user: why not use github issues?
22:31:04 <dmj`> or do you mean like create a TODO app
22:31:40 <user> Well, I'm pursuing the idea of having a code-centric issue tracker
22:31:56 <user> where your issues are automatically updated as you chage what needs to be done on the code level
22:32:08 <user> Fuuzetsu, yes, precisely
22:34:31 <nshepperd> _holes will be reported with their type when you attempt to compile
22:35:48 <nshepperd> it seems like there isn't api access to holes in ghc yet though
22:37:06 <sebastianrkg> hmm okay. I suppose I could see which modules use the package in which I would include this _TODO function and then parse their AST or something
22:37:11 <sebastianrkg> but that might take forever
22:37:44 <sebastianrkg> or I could make TODO use unsafe IO to report its existence or something nuts
22:39:13 <Fuuzetsu> that means you'd have to run that piece of code
22:39:25 <kaidelong> I have old code that is using ExceptT IO, which I was never happy with and wanted to change (I made a function that converts it to IO)
22:39:26 <Fuuzetsu> unless you mean report it at compile time with TH
22:39:35 <kaidelong> apparently there is a type class for monads with exceptions
22:39:35 <Fuuzetsu> which could work fine actually
22:39:39 <kaidelong> this would be superior
22:39:48 <kaidelong> but i don't know what to depend on and import
22:40:30 <Fuuzetsu> http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html maybe?
22:41:00 <kaidelong> thanks
22:42:02 <kaidelong> wait
22:42:16 <kaidelong> m must uniquely determine e
22:42:52 <kaidelong> that means I'm still not able to use IO because I have a custom error type for handling errors from the library I'm bound to
22:43:21 <Fuuzetsu> scroll down to ExceptT
22:43:55 <kaidelong> ExceptT is exactly what I'm trying to get rid of
22:44:15 <kaidelong> (it'd be nice if the user could just get plain IO but could get ExceptT if they want to handle the errors that way instead)
22:44:28 <Fuuzetsu> you are in favour of ExceptT provided by a library that also defines nice functions on it
22:45:51 <kaidelong> mmm well
22:45:53 <Fuuzetsu> you get plain IO, you lift it up with liftIO when you want ExceptT
22:46:17 <kaidelong> sure, how would this work though?
22:46:33 <kaidelong> I have
22:46:36 <kaidelong> (MonadIO m) => (WindowEventState -> WindowEventState) -> InputHandler -> ExceptT GLFWSessionError m ()
22:46:47 <kaidelong> I want the result to just be "m ()"
22:47:24 <kaidelong> with the error being thrown as an IO error if it is interpreted as IO ()
22:47:33 <kaidelong> what I am thinking I could do is export two modules
22:47:52 <kaidelong> one of them that exports the polymorphic version that doesn't work as IO, the other one that does
22:52:59 <Fuuzetsu> at best you can get MonadIO m => m (Either GLFWSessionError ()) and using the instance that can be IO (Either GLFWSessionError ()); it's up to you to turn that to ‚ÄòIO ()‚Äô such as with throwError, turning GLFWSessionError into IOException as required
22:54:59 <Fuuzetsu> but if you're doing that then I question your use of ExceptT in the first place
22:55:36 <kaidelong> I can't justify why I am not just using IO exceptions
22:57:15 <SparkySparkyBoom> has anyone tried out elm?
22:57:17 <Fuuzetsu> if you want just IO and its exceptions then use those 
22:57:22 <kaidelong> I could use liftIO . throw
22:57:35 <kaidelong> to stay polymorphic in IO
22:57:52 <kaidelong> I do need the MonadIO constraint so I am probably fine doing this
22:58:04 <Fuuzetsu> ExceptT is when you want your own custom errors or when you want to put extra error handling on top of an existing monad
22:58:31 <kaidelong> I only need the first
22:58:46 <kaidelong> that should be handled though because they're instances of Typeable and Exception
22:59:02 <kaidelong> although one of them is a sum type and I probably should be using the subtyping from the IO hierarchy instead
22:59:15 <Fuuzetsu> the way you do first is you keep your stuff as ExceptT and compose it
22:59:18 <kaidelong> well, I dunno how I'd set that up actually, so maybe not
22:59:26 <Fuuzetsu> and in the end you just runExceptT to run the whole thing
23:00:15 <kaidelong> runExceptT enters IO, though
23:00:31 <Fuuzetsu> yes, you run it in the end
23:00:35 <kaidelong> so perhaps I shouldn't be using ExceptT at all, IO already provides error handling
23:00:52 <Fuuzetsu> IO only provides error handling with IOException
23:01:01 <Fuuzetsu> you just said you wanted custom error type
23:01:29 <kaidelong> it's an instance of exception
23:01:35 <kaidelong> so I can use throwIO
23:01:48 <kaidelong> oh wait
23:01:56 <kaidelong> am I not supposed to do that?
23:02:45 <kaidelong> no I am, apparently this is the entire point of why extensible exceptions exist
23:03:03 <kaidelong> so yeah, I am using a custom error type, but I extended the IO exception system to support it
23:03:16 <kaidelong> these errors only ever happen when performing IO
23:03:21 <Fuuzetsu> yes, the disadvantage is that it makes the catching mechanaism implicit
23:03:25 <Fuuzetsu> mechanism*
23:03:29 <Fuuzetsu> it's not forced in type anywhere
23:03:53 <kaidelong> mmm well, like I said
23:03:54 <Fuuzetsu> you better never forget to `catch` it all everywhere
23:03:58 <kaidelong> I could export two versions of the module
23:04:02 <rasen> Fuuzetsu: actually, it's possible to do error handling with any exception
23:04:07 <rasen> Fuuzetsu: see http://hackage.haskell.org/package/base-4.8.0.0/docs/Control-Exception-Base.html#t:Exception
23:04:15 <kaidelong> one that uses IO exceptions and one that uses ExceptT
23:04:27 <kaidelong> with the IO exception one just being a handler
23:04:30 <Fuuzetsu> rasen: I know that, I quite literally have it open right now
23:04:33 <kaidelong> that throws stuff into IO
23:05:24 <Fuuzetsu> kaidelong: uh, sure, I guess; I don't see much point to it considering anyone who wants to use such a thing can just throw it themselves and know that they have to catch it
23:05:46 <Fuuzetsu> rather than use and and be surprised when something fails and they have to chase up docs or implementation
23:06:11 <Fuuzetsu> rather than use it*
23:06:13 <Fuuzetsu> I should go to bed
23:06:24 <kaidelong> well, it seems the problem here is
23:06:41 <kaidelong> Haskell makes you choose between checked exceptions and implicit propagation
23:06:52 <kaidelong> although technically
23:07:00 <kaidelong> other languages do the same thing in their own subtle way
23:07:08 <kaidelong> I guess here it is done using the type system
23:07:15 <kaidelong> well, you also have to match the constructor
23:07:37 <kaidelong> mmm
23:08:04 <Fuuzetsu> you just match the constructor to check if it's even an exception and which exception it is‚Ä¶
23:08:22 <Fuuzetsu> anyway there is no problem with Haskell making you choose anything, you either want explicit or implicit exceptions
23:08:36 <Fuuzetsu> if you want to mix and match then you throw and convert
23:09:13 <kaidelong> I'm ambivalent toward checked exceptions
23:09:20 <kaidelong> I'll ave to think about it
23:09:30 <kaidelong> putting in the effort to give both options to the user might be worth
23:10:01 <pharaun> i wish that there was a easy way to verify that i've caught all exception, with implict ones i can't
23:10:16 <kaidelong> SomeException
23:10:21 <Fuuzetsu> IMHO if you have a custom error type and you're clearly expecting the exceptions to be thrown as part of routine calls, it should be explicit‚Ä¶ any user that wants them impilict can just throw themselves
23:10:39 <kaidelong> I am not expecting these exceptions to be thrown routinely
23:10:56 <kaidelong> all of these are fatal errors that are either caused by a bug in the library or by a bug in the program calling it
23:11:12 <kaidelong> ("user error" in a sense)
23:11:22 <neuroserpens> o,o
23:11:58 <kaidelong> for example, if the input buffer is somehow closed while the program is still running, or something destroyed the GLFW session at the wrong time
23:12:32 <Bashmetim> Why is the type of mconcat "[a] -> a" instead of "Foldable t => t a -> a" ?
23:12:44 <Fuuzetsu> then maybe 2 modules may be worthwhile in this case though I would not get rid of ExceptT anyway in case the user does want to catch the exceptions and doesn't want to mess around with outdated docs to see what they have to catch
23:12:55 <Fuuzetsu> Bashmetim: because you're looking at old docs
23:13:13 <Fuuzetsu> oh, rather, you aren't
23:13:15 <kadoban> :t mconcat
23:13:16 <lambdabot> Monoid a => [a] -> a
23:13:43 <Bashmetim> Yeah, I get that with base 4.8, ghc 7.10
23:13:43 <Fuuzetsu> foldable uses Monoid
23:13:47 <Fuuzetsu> Foldable*
23:13:59 <Bashmetim> So?
23:14:08 <Fuuzetsu> mutual imports most likely
23:14:27 <Bashmetim> Is that something I should expect to change in the future?
23:14:38 <mjrosenb> haskell desugars all type aliases prior to doing any type checking, right?
23:14:45 <kadoban> Bashmetim: Anyway, not everything changed to the more general type. I'm not sure what rationale there was specifically for each one. There might be public reasoning about them somewhere.
23:15:19 <Fuuzetsu> Bashmetim: IIRC there's a version of what you want
23:15:21 <Fuuzetsu> sec
23:15:43 <Fuuzetsu> oh
23:15:44 <Fuuzetsu> :t fold
23:15:45 <Bashmetim> It's not like I have a pressing need, I was just reading up and thought it seemed out of place
23:15:45 <lambdabot> (Foldable t, Monoid m) => t m -> m
23:16:59 <Bashmetim> Fuuzetsu that should still be okay though, right?
23:17:14 <Fuuzetsu> what should
23:17:28 <Bashmetim> fold using the monoid typeclass
23:17:36 <Fuuzetsu> it is using it
23:17:39 <Fuuzetsu> fold is in Foldable
23:17:42 <jle`> mconcat is the part of the Monoid typeclass
23:18:03 <jle`> so it's a bit of a weird circular dependency
23:18:09 <Bashmetim> It is, it is...
23:18:17 <Fuuzetsu> well, no, it's not circular because Monoid doesn't use Foldable
23:18:27 <jle`> it would if mconcat was over all Foldable
23:18:36 <jle`> as Bashmetim was suggesting
23:18:37 <Fuuzetsu> but it's not and we have fold instead
23:18:42 <Bashmetim> It does if mconcat = foldr mappend mempty
23:18:45 <Fuuzetsu> which does use Monoid
23:18:50 <jle`> yeah, it 'would' be, i meant
23:19:10 <jle`> it wouldn't make too much sense for `mconcat` to become generalized
23:19:23 <Bashmetim> :info Foldable
23:19:35 <Bashmetim> Ah, your bot doesn't do that!
23:19:51 <Fuuzetsu> it does not because fold already exists and Foldable uses Monoid so you'd have a big problem if Monoid used the Foldable in return‚Ä¶
23:20:01 <jle`> yes, exactly.  that's what i meant :)
23:20:01 <Fuuzetsu> no :i in lambdabot, it'd be way too spammy
23:21:05 <Bashmetim> Well, the fold function uses Monoid, foldr and foldl don't
23:21:16 <jle`> foldMap uses monoid, and it's a part of Foldable
23:21:30 <jle`> but fold is a part of Foldable too
23:22:05 <Fuuzetsu> why would foldr/foldl have to use Monoid?
23:22:07 <Bashmetim> Okay, you're not talking about getting trapped in a loop at runtime, are you... The problem would be with the type system?
23:22:23 <Fuuzetsu> no, the problem would be runtime
23:22:54 <Bashmetim> They don't have to, which is why mconcat could still use foldr/foldl in a generic version of mconcat
23:23:05 <Fuuzetsu> Foldable would call out to the Monoid instance and that would call out to Foldable‚Ä¶ I mean maybe you could make it work if careful enough with your instance but you're asking for trouble for 0 benefit because what you want already exists
23:24:18 <Fuuzetsu> I don't understand why you're trying to generalise Monoid which is basically specialised Foldable
23:25:09 <Fuuzetsu> if there was no concern about breaking existing code, we could remove Monoid all together and set mconcat = fold
23:25:19 <Bashmetim> Well, Monoid is just an associative binary operation w/ an identity, mconcat is just sort of a tack-on to that concept
23:25:58 <Fuuzetsu> mconcat is only in the typeclass so you can override it with more efficient implementation though I don't see what it has to do with the original question
23:26:32 <Fuuzetsu> but maybe that's the question? ‚ÄòWhy is it in the typeclass if it could be more general outside of it?‚Äô?
23:27:30 <Bashmetim> I was only curious, I'm not really after anything in particular ¬Ø\_(„ÉÑ)_/¬Ø
23:28:15 <jle`> things would be so boring if base/haskell ecosystem popped out perfectly without any historical baggage
23:28:38 <Bashmetim> Definitely true
23:30:17 <Bashmetim> I noticed recently that a lot of old functions had been redefined to use Foldable/Traversable instead of just lists, I guess it seemed like mconcat got skipped somehow
23:31:53 <Fuuzetsu> well, it could be defined as just fold . toList
23:32:22 <Fuuzetsu> more hassle for the user
23:32:24 <Fuuzetsu> anyway I'm going to bed
23:32:52 <Fuuzetsu> and I realise I said something stupid above about Monoid being specialised Foldable, I meant mconcat being specialised fold
23:47:47 <jle`> huh, 7.10 and we still don't have a Monad instance for Monoid e => (,) e
23:47:58 <jle`> did this just slip through the cracks or something?
23:48:16 <usr> is there an OS built on haskell yet?
23:49:15 <neuroserpens> usr: lol
23:49:32 <Fuuzetsu> House was a nice project
23:49:41 <Fuuzetsu> I started reading the paper, it was nice but I didn't have time to finish
23:50:01 <dmj`> http://programatica.cs.pdx.edu/House/
23:54:15 <usr> neuroserpens: why don't you do it?
