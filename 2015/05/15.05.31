00:07:36 * hackagebot satchmo-toysat 0.2.1.0 - toysat driver as backend for satchmo  http://hackage.haskell.org/package/satchmo-toysat-0.2.1.0 (MasahiroSakai)
00:07:36 * hackagebot memory 0.6 - memory and related abtraction stuff  http://hackage.haskell.org/package/memory-0.6 (VincentHanquez)
00:08:08 <tmtwd> > foldr (-) 0 [1,2,3]
00:08:09 <lambdabot>  2
00:08:38 <tmtwd> what is the command that is like fold but it shows you all the steps
00:09:17 <betaveros> scan?
00:09:35 <tmtwd> >scanr (-) 0 [1,2,3]
00:09:39 <tmtwd> i think os
00:10:09 <betaveros> > scanr (-) 0 [1,2,3]
00:10:11 <lambdabot>  [2,-1,3,0]
00:10:24 <tmtwd> ah
00:24:01 <Sprog> If I wanted to import only certain lens features, why isn't it letting me do import Control.Lens (^., ?~)?
00:24:22 <Sprog> parse error 
00:24:42 <nrk--> ((^.), (?~))
00:24:43 <nrk--> ?
00:25:10 <ReinH> Yes.
00:25:43 <Sprog> Weird
00:25:49 <Sprog> okay, so since they're infix they need the extra parens?
00:26:22 <ReinH> Since they're operators, yes
00:26:57 <ReinH> It follows the same rule for treating operators as expressions, which is to wrap them in parens
00:27:58 <Sprog> hmm makes sense
00:28:02 <Sprog> thanks
00:52:10 <codygman> Hopefully I don't need full dependent typing for this, but I was wondering how I could express this smart constructor in the type system: http://lpaste.net/133625
00:57:33 * hackagebot language-puppet 1.1.3 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-1.1.3 (SimonMarechal)
01:13:50 <Pastaf> I'm trying to parse s-expressions into a tree, but I'm having much difficulty. I could do it if I had arbitrarily nested lists, but I don't, so it's more difficult. It seems every attempt I've made so far has been signifigantly off, so could I have some pointers? (I don't want to use Parsec or monads!)
01:15:10 <pacak> Pastaf: data Expr = List [Expr] | Elt String
01:15:33 <pacak> Pastaf: This way it can be nested. But monads are your friends, not your enemies.
01:15:39 <Pastaf> pacak: I have the tree datatype, I was more asking about how to actually parse it
01:15:53 <pacak> With parsec or attoparsec :)
01:16:03 <pavonia> or monads!
01:16:26 <pacak> pavonia: Those two are monads basically
01:16:28 <Pastaf> so, there's no good functional alternative and I should just to the imperitive version?
01:16:40 <pavonia> Sure, but there are other monads too
01:17:06 <pacak> Pastaf: There are good functional alternatives
01:17:15 <pavonia> Using monads doesn't mean it has to be imperative
01:18:03 <Pastaf> well, I guess if it can only be done well with monads, I might as well use parsec
01:18:11 <pacak> @hackage sexp
01:18:11 <lambdabot> http://hackage.haskell.org/package/sexp
01:19:00 <aphorisme> In which sense aren't monads functional? (Serious -- if you ignore the do-Notation, it seems to be pretty functional, or?)
01:19:45 <codygman> Pastaf: I don't see that anyone said it can only be done with monads. I'm fairly positive that you don't need monads to parse S-Expressions. Did you see the simple ADT that pacak posted above?
01:19:46 <Pastaf> aphorisme: I started with Haskell yesterday, and as far as I know monads are for imperitive programming, or individual IO actions.
01:20:09 <Pastaf> I never said I didn't think it could be done, it was more about EFFECTIVELY.
01:20:26 <pavonia> No, IO is only one instance/use-case of them
01:20:56 <Pastaf> based on the response "use monads/parsec", I assumed it was just the best way to go
01:22:12 <codygman> Pastaf: Hope my tone didn't come off as condescending or dismissive btw. I would probably use parsec (or attoparsec) if it was something serious or use a data type like pacak posted and make my own parser if it was for learning/fun.
01:22:37 <Pastaf> pacak: Language.Sexp.Parser looks like what I'm looking for
01:22:45 <Pastaf> I need to look a bit more though
01:23:22 <pacak> > [1..3]  >>= \ i -> [1..3] >>= \j -> guard (i < j) >>return (i, j)
01:23:24 <lambdabot>  [(1,2),(1,3),(2,3)]
01:23:36 <Pastaf> codygman: I was more hoping my "EFFECTIVELY" didn't come off as too aggressive, so no worries.
01:23:42 <pavonia> I'm wondering if it can be done with a simple fold
01:24:01 <Pastaf> I suppose I will still have to look into parsec, it just looked really ugly at first glance
01:24:12 <pacak> Pastaf: Buuuuut.... Monads!
01:24:48 <pavonia> Pastaf: You probably need to understand Functors and Applicatives first
01:26:47 <Pastaf> pavonia: Gotcha.
01:33:16 <field50> @unmtl StateT s IO a
01:33:16 <lambdabot> s -> IO (a, s)
01:33:28 <field50> great lambdabot!
01:33:56 <field50> @undo do { x <- getLine; print x }
01:33:57 <lambdabot> getLine >>= \ x -> print x
01:34:44 <arkeet> getLine >>= print
01:34:54 <arkeet> @pl getLine >>= \ x -> print x
01:34:54 <lambdabot> print =<< getLine
01:36:52 <jle`> this is one of the more useful libs on hackage
01:36:54 <jle`> http://hackage.haskell.org/package/acme-dont-1.1/docs/Acme-Dont.html
01:39:50 <frerich> jle`: Yet another beautiful demonstration of how Haskell fails at code reuse. Clearly, the definition shouldn't have been any more complex than 'not . do'. Furthermore, (don't . don't) is not equivalent to 'do'!
01:46:09 <arkeet> frerich: :-)
01:46:20 <arkeet> frerich: well
01:46:41 <arkeet> Not (Not x) is not equivalent to x anyway
01:46:44 <arkeet> so I wouldn't really expect that
01:47:10 <pavonia> @src Not
01:47:10 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
01:48:58 <pavonia> How is Not defined? That's hard to google
01:49:33 <arkeet> type Not x = x -> Void
01:49:51 <arkeet> or just "not" in intuitionistic logic
01:51:05 <frerich> to $ do or [not . to $ do x] !
02:48:53 <solatis> hmmm i uploaded this package yesterday, but documentation doesn't seem to be generated http://hackage.haskell.org/package/network-anonymous-tor
02:49:20 <solatis> i already requested a delete of all docs & rebuild a few hours ago, but still nothing happens
02:49:43 <solatis> what is the next step i should take ?
03:07:42 * hackagebot github-webhook-handler 0.0.1 - GitHub WebHook Handler  http://hackage.haskell.org/package/github-webhook-handler-0.0.1 (wereHamster)
03:07:44 * hackagebot github-webhook-handler-snap 0.0.1 - GitHub WebHook Handler implementation for Snap  http://hackage.haskell.org/package/github-webhook-handler-snap-0.0.1 (wereHamster)
03:26:03 <fishburne> what is the difference between an fmap and a lift
03:31:02 <Axman6> fishburne: Assuming you mean liftM (or liftA), they are the same, but for a long time Functor wasn't a superclass Applicative or Functor
03:35:10 <sydneyhacker> hi quick question all - how can i change the number of prop tests run by doctest? at the moment it runs just one for each test for me
03:35:35 <fishburne> Axman6, Applicative or Monad..right?
03:43:25 <ThuletheKing> How do you guys see the future of Haskell? I am thinking that since Scala is tightly integrated with Java and F# for C#, and I haven't really heard much of Haskell in embedded software - will it ever be used in the industry or will it be an academic language?
03:47:03 <DrPavelheer> Question, if anyone's out there
03:47:04 <sydneyhacker> anyone use doctest here?
03:47:06 <DrPavelheer> Nope
03:48:03 <sydneyhacker> ThuletheKing: I think there is a future but it is going to be niche. Hard to convince a JVM/CLR shop to go with a language that doesn't compile to their favourite VM
03:48:15 <DrPavelheer> Is it possible to go from an "IO a" monad to an "m (Right a)" monad within the "m (Either b a)" monad?
03:48:16 <srhb> DrPavelheer: Just ask. :)
03:48:19 <srhb> Ah
03:48:44 <DrPavelheer> m is a monadIO, by the way
03:49:09 <ThuletheKing> it is too bad... Any initiatives going on put haskell on the frontline?
03:49:24 <DrPavelheer> ThuletheKing: I just use it a lot
03:49:38 <srhb> ThuletheKing: We tend to avoid (success at all cost) but it's already used a lot in the industry.
03:49:39 <ThuletheKing> DrPavelheer: for what?
03:49:55 <sydneyhacker> For the front-end Haste/Fay/GHCJs
03:49:56 <DrPavelheer> ThuletheKing: Whatever I'm working on at the time
03:50:01 <sydneyhacker> Also there is Yesod etc.
03:50:04 <DrPavelheer> Normalize it, un-academize it
03:50:33 <srhb> Haskell is fine, it's the rest of the world that is the problem. :-)
03:51:03 <ThuletheKing> hehe
03:51:03 <DrPavelheer> It's the steep learning curve that's the issure
03:51:06 <DrPavelheer> issure
03:51:07 <DrPavelheer> issue
03:51:26 <sydneyhacker> @Dr sure is, teach your children Haskell while they are young!
03:51:26 <lambdabot> Maybe you meant: wn v url src rc pl id do bf arr @ ? .
03:51:33 <DrPavelheer> Also, the relatively small community
03:51:46 <ThuletheKing> DrPavelheer: what do you mean by un-academize it? How would you do that? What is the issue?
03:52:03 <DrPavelheer> Not enough people use it because they think it's useless in the real workd
03:52:10 <DrPavelheer> And also the learning curve thing
03:52:17 <DrPavelheer> It's not practical enough
03:52:18 <srhb> I think the issue is the "steep learning curve issue" -- claiming that it has a steep learning curve or is somehow harder to learn than other languages.
03:52:23 <srhb> It's all just bias.
03:52:28 <sydneyhacker> Maybe it is this 'no side effects' nonsense. There is even an XKCD cartoon about it
03:52:39 <ThuletheKing> what do you mean sydneyhacker?
03:52:53 <DrPavelheer> I mean, here I am, trying to turn an IO a into m Right a, with no idea how
03:52:58 <DrPavelheer> And I consider myself pretty good
03:53:05 <srhb> DrPavelheer: What the heck is a Right?
03:53:09 <DrPavelheer> But in other languages, that wouldn't be an issue
03:53:26 <DrPavelheer> Either. Of course
03:53:43 <DrPavelheer> My intention is to get the value to be Right, and that was on my mind
03:53:49 <srhb> DrPavelheer: Are you saying you have foo :: IO a, and you want IO (Either b a?)
03:53:51 <ThuletheKing> I have the same issue DrPavelheer, probably on a lower level but same
03:54:31 <pacak> Monad transformers, unsafePerformIO and designing your app in a way that you don't need to do IO inside Either.
03:54:51 <sydneyhacker> ThuletheKing: if one thinks Haskell has no side effects, then it sounds like an academic language where you do everything in REPL. But you can build anything in Haskell
03:54:52 <DrPavelheer> srhb: I have foo :: IO a, and I want m (Either b a), within the m monad
03:55:15 <srhb> DrPavelheer: I'm not entirely sure what you mean within the m monad
03:55:34 <srhb> DrPavelheer: The answer is fmap Right anyway.
03:55:36 <ThuletheKing> sydneyhacker: it recognize that, since I am fairly new at Haskell.
03:56:05 <DrPavelheer> http://lpaste.net/3545878343347863552
03:56:14 <DrPavelheer> Hmm
03:57:53 <srhb> DrPavelheer: Presumably this is your IO a: withResource pool (\pip -> access pip mode database action)
03:58:01 <srhb> So fmap Right onto that.
03:58:37 <srhb> DrPavelheer: What you are doing is applying Right to an IO a
03:58:52 <DrPavelheer> Got it. Thanks!
03:58:56 <srhb> That's Either b (IO a)
03:58:58 <srhb> ah, good.
03:59:14 <DrPavelheer> Forget the simple things...
03:59:19 <srhb> :)
04:15:23 <ThuletheKing> You guys have any good idea for a "hobby project" in Haskell? I have just started using the FFI and the IO monad. I haven't really created my own typeclasses yet. I have tried books with exercises, but it is mainly "solve this problem".. I need more of a small project
04:16:35 <cameronfr> ThuletheKing: some sort of algebraic solver might be interesting
04:17:04 <maerwald> ThuletheKing: ncurses based file manager
04:17:29 <maerwald> I don't think that would take too long with basic functionality
04:17:46 <ThuletheKing> could be interesting, thanks
04:18:35 <hexagoxel> :exf "MonadIO m => IO a -> m (Either x a)"
04:18:36 <exferenceBot> \ b -> liftIO (fmap pure b)
04:18:54 <hexagoxel> DrPavelheer: ^ fancy automation :)
04:21:32 <ion> It would be nice if there was a Haskell editor that tried to fill in holes automatically with exference.
04:24:18 <hexagoxel> oh, indeed, in wanted to try getting mote to work again (a vim plugin)
04:25:58 <ion> Is there any support for taking the information GHC provides about a typed hole (including things in scope) and using that for code inference?
04:32:14 <pacak> google monads:About 427,000 results;   google comonads: About 18,500 results
04:32:42 <hexagoxel> ion: no. but mote already extracts the information from ghc (and i think it even has some (basic, as i understand it) hole-filling support).
04:32:46 <ion> google google: About 4,460,000,000 results; google cogoogle: About 392,000 results
04:33:09 <ion> hexagoxel: cool
04:33:15 <silver> no love for co- things, only colove
04:33:19 <hexagoxel> ion: i was planning to add exference there, but i ran into some weird setup-problems last time i tried installing mote
04:34:08 <hexagoxel> but i really have not put much time into investigating yet :)
04:40:21 <Saizan> 2
04:45:04 <f|`-`|f_> google operad
04:45:37 <maerwald> google monad?
04:45:48 <nomeata> hvr: huh, just discovered http://matrix.hackage.haskell.org/. Has this been announced properly somewhere? Or is it for trustee consumption anyways?
05:11:08 <haskell537> I'm haaskell beginner. While coding more and mor of it, I now tend to write much more function thant before (in OOP. I use a kind of suffix prefix system. But now I end up with dozens of functions all starting with compute: computeDistanceBetweenPoints computeThis computeThat. My question is:
05:11:49 <Haskellfant> why not just call them "distanceBetweenPoints", "this", "that"
05:12:21 <haskell537> what common prefix do you use or know ? For example make could be mk prefix for data type constructor     mkThisField, mkThatField,  thre is also get and set. For compute I imagine something like calc. What are your variations, usage ?
05:13:17 <Saizan> yeah, i would just drop the compute part
05:13:23 <haskell537> @Haskellfant   because I am so used to consider functions as verb.... I knid of think I should do this preffixing
05:13:24 <lambdabot> Unknown command, try @list
05:13:54 <Haskellfant> it feels pretty useless to me
05:14:04 <Haskellfant> putting compute in front of the name doesn't provide any information
05:14:11 <haskell537> so there's two votes for dropping the preffix ;-)
05:15:21 <ion> I’d drop it, but feel free to do what feels best for you.
05:16:14 <zinfandel> haskell537: Try to think about this functions as of data not actions. If those functions take some argument, then just think about them as data that depends on some other data. E.g. `distance pointA pointB` instead of `computeDistance pointA pointB`
05:17:07 <zinfandel> If you `distance` type is `Point -> Point -> Scalar` then there is no need to specify that it is `distanceBetweenPoints` as that should be obvious from the type.
05:17:12 <zinfandel> s/you/your/
05:17:26 <ion> In “distance :: Point -> Point -> Number”, the “->” indicates “compute” and the two Point inputs more or less indicate “between points”.
05:17:48 * hackagebot pandoc 1.14.0.2 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.14.0.2 (JohnMacFarlane)
05:17:50 * hackagebot network-anonymous-tor 0.9.1 - Haskell API for Tor anonymous networking  http://hackage.haskell.org/package/network-anonymous-tor-0.9.1 (solatis)
05:23:57 <slater-_> what does ghc-mod provide that haskell-mode doesn't?
05:37:53 <haskell886> Hi
05:38:06 <haskell886> anyone here? i need some help with my code
05:38:56 <haskell886> http://lpaste.net/133631
05:39:11 <haskell886> getting some errors when i use OPTION WALL but when i erase it everything works good
05:39:35 <haskell886> http://lpaste.net/133632
05:39:46 <pacak> Errors or warnings?
05:40:04 <pacak> With -Wall it complains on everything
05:40:38 <haskell886> Defaulting the following constraint(s) to type `Integer'
05:40:47 <haskell886> so warnings
05:41:52 <pacak> for those you can add type signatures
05:42:00 <haskell886> how do you mean
05:42:04 <haskell886> can you give a example
05:42:49 * hackagebot ersatz-toysat 0.2.1.0 - toysat driver as backend for ersatz  http://hackage.haskell.org/package/ersatz-toysat-0.2.1.0 (MasahiroSakai)
05:49:00 <Axman6> haskell886: what lines are you getting warnings on?
05:49:43 <haskell886> 25:14, 26:30, 30:43
05:50:46 <Axman6> I don't understand, 26 is a blank line
05:51:03 <Axman6> 25 is an import
05:52:15 <haskell886> 25 is this  h' = (logBase (2) (fromIntegral((n+1))) - 1)
05:52:18 <haskell886> in Main.hs
05:52:45 <haskell886> http://lpaste.net/133631
05:52:50 * hackagebot Annotations 0.2.1 - Constructing, analyzing and destructing annotated trees  http://hackage.haskell.org/package/Annotations-0.2.1 (MartijnVanSteenbergen)
05:53:20 <Axman6> ... well you probably should share the file which has the problem, not the one that doesn't =)
05:54:19 <Axman6> wow, so many brackets, (logBase (2) (fromIntegral((n+1))) - 1) = logBase 2 (fromIntegral (n+1)) - 1
05:54:25 <Axman6> :t logBase
05:54:26 <lambdabot> Floating a => a -> a -> a
05:54:46 <pacak> haskell886: Add type signatures for everything inside let
05:55:25 <Axman6> so you haven't specified any types anywhere, so it's defaulting the types of all the numbers in your source code to Integer (for things which can be), and probably Double for anything which can't
05:56:51 <meoblast001> with vim's ghcmod, how can i find out what is causing a cannot guess type error?
05:56:56 <meoblast001> i'm getting that for everything
05:56:58 <haskell886> can you give a example?
05:57:35 <meoblast001> me?
05:57:36 <haskell886> and where should i put this?
05:57:44 <Axman6> h' :: Double
05:58:05 <ion> haskell886: Please pastebin the full error or warning message.
05:58:33 <haskell886> http://lpaste.net/133633
05:58:37 <haskell886> full warning message
06:00:08 <pacak> haskell886: add "ratio :: Double" before ratio =  ....
06:00:19 <haskell886> ok thanks
06:00:22 <pacak> And so on
06:00:22 <haskell886> will try it now
06:04:26 <haskell886> getting these 2 now..
06:04:26 <haskell886> http://lpaste.net/133634
06:05:06 <ThuletheKing> Any simple way to remove \args in main = getArgs >>= \args -> putStrLn $ replace ";" (head args) (last args)?
06:05:53 <pacak> replace fromIntegral next to logBase with realToFrac
06:06:30 <ClaudiusMaximus> @pl \x -> f (g x) (h x)
06:06:30 <lambdabot> liftM2 f g h
06:06:49 <ClaudiusMaximus> ThuletheKing: that, but it's not so readable
06:07:23 <haskell886> already tried
06:07:58 <ThuletheKing> ya, think i'll keep it :)
06:08:15 <ThuletheKing> just wanted to know if I had missed any obvious things
06:08:32 <ThuletheKing> thanks though
06:09:14 <haskell886> this is what i get now.. http://lpaste.net/133635
06:09:32 <haskell886> i declared h' :: Double
06:09:39 <haskell886> i mean as Integer
06:09:43 <haskell886> and ratio :: Double
06:09:59 <pacak> replace fromIntegral next to logBase with realToFrac
06:10:20 <ClaudiusMaximus> ThuletheKing: alternatively, main = do{  args <- getArgs ; .... }  with layout for {;}
06:10:40 <haskell886> then i get this pack 
06:10:41 <haskell886> http://lpaste.net/133636
06:11:02 <pacak>     In the expression: (logBase (2) (fromIntegral ((n + 1))) - 1)
06:11:06 <pacak> replace fromIntegral next to logBase with realToFrac
06:11:14 <haskell886> h' = (logBase (2) (realToFrac((n+1))) - 1)
06:11:29 <haskell886> i did. and I'm getting new warnings now
06:12:47 <haskell886> " No instance for (Floating Integer) arising from a use of `logBase'"
06:12:52 * hackagebot github-webhook-handler 0.0.2 - GitHub WebHook Handler  http://hackage.haskell.org/package/github-webhook-handler-0.0.2 (wereHamster)
06:14:12 <pacak> > (logBase 2 (realToFrac (n :: Int + 1))) - 1
06:14:13 <lambdabot>  Not in scope: type constructor or class ‘+’
06:14:20 <pacak> > (logBase 2 (realToFrac (n :: Int) + 1)) - 1
06:14:22 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘Expr’
06:14:22 <lambdabot>      In the first argument of ‘realToFrac’, namely ‘(n :: Int)’
06:14:22 <lambdabot>      In the first argument of ‘(+)’, namely ‘realToFrac (n :: Int)’
06:14:31 <hvr> nomeata: it's still in beta/alpha state, hence no official announcment yet
06:14:34 <pacak> > logBase 2 realToFrac (10 :: Int) + 1)) - 1
06:14:36 <lambdabot>  <hint>:1:37: parse error on input ‘)’
06:14:39 <pacak> > logBase 2 realToFrac (10 :: Int) + 1) - 1
06:14:40 <lambdabot>  <hint>:1:37: parse error on input ‘)’
06:14:41 <toryo> I want to look into the code generation capabilities of Haskell. Whre do i get started? Which libs are best? I'm talking about generating C code (for MCUs).
06:14:45 <pacak> > logBase 2 realToFrac (10 :: Int) + 1
06:14:46 <lambdabot>      No instance for (Show a0)
06:14:46 <lambdabot>        arising from a use of ‘show_M1051631744435076492357’
06:14:46 <lambdabot>      The type variable ‘a0’ is ambiguous
06:15:28 <haskell886> what does this mean now
06:15:30 <haskell886> " Illegal literal in type (use -XDataKinds to enable): 1"
06:15:31 <hvr> nomeata: there's one big rewrite (involving a reset of all existing buildreport data) I'm planning on before announcing
06:15:44 <pacak> > logBase 2 (realToFrac (10 :: Int))
06:15:45 <lambdabot>  3.3219280948873626
06:16:08 <pacak> haskell886: It's not something you want. This means you put number into a type signature
06:17:05 <haskell886> so i should change n to 10 :: int?
06:17:41 <pacak> No, you leave it as n. I only changed it to 10 so lambdabot can print something useful.
06:17:52 * hackagebot optparse-simple 0.0.3 - Simple interface to optparse-applicative  http://hackage.haskell.org/package/optparse-simple-0.0.3 (ChrisDone)
06:20:52 <haskell886> but why do i get this msg..
06:20:53 <haskell886>  Illegal literal in type (use -XDataKinds to enable): 1
06:21:04 <haskell886> at 28
06:21:40 <toryo> I want to look into the code generation capabilities of Haskell. Whre do i get started? Which libs are best? I'm talking about generating C code (for MCUs).
06:21:47 <pacak> You have 1 to the right of :: somewhere
06:22:04 <haskell886> its like thi
06:22:05 <haskell886> (logBase 2 (realToFrac (n :: Int + 1))) - 1
06:22:29 <Chousuke> Int + 1 is the problem :P
06:22:45 <pacak> I don't think you need ":: Int" part as long as n is already declared as Int
06:22:52 * hackagebot github-webhook-handler-snap 0.0.2 - GitHub WebHook Handler implementation for Snap  http://hackage.haskell.org/package/github-webhook-handler-snap-0.0.2 (wereHamster)
06:23:01 <pacak> Is there any [good] examples for Cofree Comonads in there? I know how to use it to get stuff like structure with some extra annotations (similar to using Fix), but how do I use Comonad instance itself and all those goodies in Control.Comonad.Cofree?
06:24:17 <haskell886> this is so stupiod
06:24:20 <haskell886> still doesn't work....
06:24:26 <haskell886> I'm getting same message 
06:24:26 <haskell886> http://lpaste.net/6567499423629180928
06:25:08 <Chousuke> you'll want (n :: Int) + 1
06:25:37 <toryo> Is this practically doable: Given a hardware abstraction layer for an MCU that has drivers for Wifi, Flash, Adc and a user that chooses what he needs, egenrate a mainloop in C that does what the user wants.
06:25:48 <haskell886> h' = (logBase 2 (realToFrac ((n :: Int)+ 1))) - 1
06:26:36 <haskell886> doesn't work with (n :: Int) + 1
06:28:32 <Chousuke> wjat'
06:28:42 <Chousuke> what's your entire function?
06:28:58 <haskell886> http://lpaste.net/133637
06:29:47 <nullvoid8> haskell886: because Integer doesn't have instances for any of those classes, as it shouldn't.
06:30:21 <haskell886> how can i fix it?
06:31:18 <nullvoid8> actually, I might be wrong
06:31:48 <Chousuke> logBase can't return an Integer
06:32:22 <haskell886> so h' should be Double?
06:33:00 <nullvoid8> depending on what it's for, you might want to apply floor or ceiling to it instead
06:33:20 <haskell886> I'm doing ceiling
06:33:24 <haskell886> putStrLn $ "Optimal height: " ++ show (ceiling h')
06:33:31 <Chousuke> that's in the  wrong place
06:33:38 <Chousuke> you've declared h' to be Integer
06:33:42 <haskell886> yea
06:33:44 <Chousuke> which it isn't.
06:33:49 <haskell886> should i declare it as Double then?
06:34:07 <Chousuke> look at the type signature for logBase and decide for yourself :)
06:34:46 <haskell886> ok so i declared it as float
06:34:54 <haskell886> but now I'm getting a new one.
06:35:16 <haskell886> http://lpaste.net/133638
06:35:22 <Chousuke> Yeah, float works too. hoogle is good for you: https://www.haskell.org/hoogle/?hoogle=logBase
06:36:20 <haskell886> Im getting this now " Defaulting the following constraint(s) to type `Integer'"... 
06:36:31 <haskell886> which means h' needs to be declared as Integer?..
06:36:41 <nullvoid8> it's just complaining that it had to guess the type of (ceiling h')
06:36:52 <haskell886> how can i remove this?
06:37:16 <Chousuke> declare the type of (ceiling h') explicitly
06:37:30 <haskell886> as a Integer? 
06:37:50 <nullvoid8> if that works for you, sure
06:37:53 * hackagebot stack-prism 0.1.4 - Stack prisms  http://hackage.haskell.org/package/stack-prism-0.1.4 (MartijnVanSteenbergen)
06:37:55 * hackagebot GroteTrap 0.5.1 - Parser and selection library for expression languages.  http://hackage.haskell.org/package/GroteTrap-0.5.1 (MartijnVanSteenbergen)
06:38:12 <Chousuke> haskell886: any type that implements Integral and Show (as those are the constraints) that you want to use.
06:39:23 <haskell886> so i can use
06:39:24 <haskell886> fromIntegral?
06:39:34 <Chousuke> it's telling you it's defaulting to Integer but it doesn't know if that's what you really want so you get a warning.
06:39:43 <haskell886> i want it to be Integer
06:40:10 <haskell886> but i also want to remove this warnin
06:40:16 <Chousuke> you should just be able to say (ceiling h') :: Integer
06:40:49 <haskell886> Thanks a lot both of you!
06:43:20 <Chousuke> haskell886: A good approach to fixing things like this is to make each step a separate function with explicit type signatures. The errors become clearer and it won't look quite so messy :)
06:58:01 <hodapp> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base/Data-Bits.html#v:bitSizeMaybe - if I implement something like this in an instance, will it still build on older GHC?
06:58:17 <hodapp> i.e. pre-4.7, and the docs note that the function is new on 4.7.0.0
07:00:30 <vik123> Hi all, I have a really simple question. I am trying to import Data.Maybe into a script and then load the script into ghci to play around with it. But I keep getting an error: 'Not in scope: data constructor `Maybe'. Failed, modules loaded: none'. My script begins with 'import Data.Maybe' and contains the body 'test = Maybe 4'. That is all of the code. I load it into GHCI using ':l script.hs' and GHCi says 'OK, modules loaded: Main'. Any ideas?
07:00:52 <bergmark> vik123: Maybe is a type, not a data constructor
07:01:01 <bergmark> vik123: The constructors of Maybe are Just and Nothing
07:01:12 <nullvoid8> hodapp: I just made up a class, tried to implement it with an extra method in the instance, gives "'bar' not a (visible) method of class 'Foo'"
07:01:43 <hodapp> nullvoid8: Ah, thanks for trying that. Perhaps I should be comparing with GHC version then.
07:02:54 * hackagebot memo-ptr 0.1.0.0 - Pointer equality memoization  http://hackage.haskell.org/package/memo-ptr-0.1.0.0 (edofic)
07:03:23 <vik123> bergmark: wow, that was such a rookie mistake on my part. Thanks!
07:09:21 <lpaste> LordBrain pasted “Unsafe overlapping instance” at http://lpaste.net/133639
07:09:45 <LordBrain> ^^ -- Any way to get this to work?
07:10:01 <LordBrain> see the remark at line 24 for the error
07:15:56 <LordBrain> Hey is anyone looking at that for me? Let me know... or else i think the room is dead and nobody saw
07:16:48 <LordBrain> The idea is to have a Test.Printf style log command
07:32:56 * hackagebot syb 0.5 - Scrap Your Boilerplate  http://hackage.haskell.org/package/syb-0.5 (JosePedroMagalhaes)
07:37:02 <yogle> can (any) parsing combinator library parse strict input in a lazy fashion, so that it does not evaluate expensive fields which do not change the outcome of the parse and are probably never read anyway?
07:49:19 <Cale> yogle: There are a couple of things which sort of get in the way of that. The main one is that usually the underlying representation of strings is such that it's not easy to just skip forward without evaluating intermediate parts of the String/ByteString/Text. The other is that the ability to skip sections is very dependent on the language itself -- you'll need markers in there saying how far away is the next bit you'r
07:49:19 <Cale> e interested in.
07:50:27 <Cale> yogle: But to a certain extent, it depends as well on what you mean by "evaluate" -- if you can break things down into an intermediate tree structure containing strings which you then parse further, maybe if the parsing of those individual strings is at all expensive, you can save time using laziness that way.
07:51:02 <yogle> Cale: if you take network packets as an example, there is maybe some type and length field, and the rest does not influnce the outcome of the parse
07:51:39 <yogle> Cale: the idea is to have neat data types that seem to contain all data for convenience, but only actually parse it if needed.
07:52:08 <nitrix> Is there a on-disk btree package that would you replace/implement the node management part? I want to build sort of a distributed b-tree.
07:52:12 <yogle> Cale: this could be an example where lazy evaluation provides a benefit over strict parsing
07:52:16 <nitrix> Writing my own sounds painful.
07:52:24 <Cale> Yeah, it can be useful to do a 2-stage parse in that case, where you parse to a simple list of packets, and then map over that list, a parser which parses each packet (and which will only really get used when you inspect the packets more closely)
07:54:01 <yogle> Cale: i was thinking about a parser that parses the necessary skeleton first and then the meat (err ... makes me hungry). but i guess the existing parser combinator libraries will only do 1-pass full parsing?
07:55:27 <Cale> yogle: Well, generally. They don't give you an additional notion of passes, but you can just do it by applying runParser again.
07:55:56 <Cale> yogle: You can even apply runParser inside the value which is being returned by the top level parser.
07:56:44 <yogle> Cale: i see. i am going to try this. thank you for your input, i think the problem has now become clearer to me.
07:57:57 * hackagebot websockets 0.9.5.0 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.9.5.0 (JasperVanDerJeugt)
07:57:59 * hackagebot websockets-snap 0.9.2.0 - Snap integration for the websockets library  http://hackage.haskell.org/package/websockets-snap-0.9.2.0 (JasperVanDerJeugt)
08:04:23 <rui3> I am trying stackage but still getting dependency problems. Perhaps I'm doing something wrong. Is there a need to empty the global and user ghc-pkg repos?
08:04:49 <geekosaur> user is easy (move ~/.ghc out of the way). you can't empty the global db
08:05:01 <geekosaur> and you must not because some things (notably base) MUST be in it
08:05:45 <rui3> geekosaur: oh
08:05:57 <geekosaur> you could use hsenv to install a private minimal ghc
08:07:37 <rui3> In cabal.config from stackage there's the line "transformers installed". I assume that means that it doesn't mind which version
08:07:58 * hackagebot syb 0.5.1 - Scrap Your Boilerplate  http://hackage.haskell.org/package/syb-0.5.1 (JosePedroMagalhaes)
08:08:15 <geekosaur> yes. also implies that it takes it from the global db (it's a dependency of base)
08:08:30 <rui3> Yet when I install the package, a dependency requires transformers 0.4.*
08:08:32 <geekosaur> well, of mtl but I think base ends up pulling that in
08:08:41 <rui3> and looking at my global db, I have 0.3
08:09:02 <rui3> Yes, mtl
08:09:15 <geekosaur> that suggests to me your installed ghc is too old
08:09:25 <rui3> geekosaur: Yeah, it is
08:10:12 <rui3> Its my laptop. In my PC I have a new one but I am getting weird issues with any library that requires some extra C library.
08:10:17 <geekosaur> in particular, you can't use stuff intended for ghc 7.10.1 with older versions because of the functor-applicative-monad and foldable-traversable changes
08:10:44 <rui3> I'll try to update ghc now, thanks
08:17:58 * hackagebot atom-basic 0.0.1.0 - Basic Atom feed construction  http://hackage.haskell.org/package/atom-basic-0.0.1.0 (cbaatz)
08:20:12 <nolraiVM> So I can't get glib to build. Which means I cant build Leksah. Is this even worth it or should I just give up and use vim?
08:21:26 <hamishmack> nolraiVM: What was the error?
08:22:42 <lpaste> nolraiVM pasted “glib errors” at http://lpaste.net/133642
08:23:33 <nolraiVM> Pasted them. http://lpaste.net/133642
08:23:56 <hamishmack> That is a very old glib it is trying to build
08:24:06 <hamishmack> did you run cabal update ?
08:25:26 <hamishmack> nolraiVM: Current version of glib is 0.13.1.0
08:25:58 <nolraiVM> Leskah was asking for that version I swear.
08:26:33 <nolraiVM> But maybe my system is just way out of date.
08:26:51 <nolraiVM> One problem wih using sandboxes. >.<
08:27:09 <hamishmack> what OS are you building on?
08:27:35 <nolraiVM> Linux Mint
08:27:59 * hackagebot atom-basic 0.0.1.1 - Basic Atom feed construction  http://hackage.haskell.org/package/atom-basic-0.0.1.1 (cbaatz)
08:28:20 <nolraiVM> Its a VM I have on a windows box.
08:29:18 <hamishmack> I have just been working on a Fedora 22 Vagrant file if you want to try that out
08:30:33 <hamishmack> Has Leksah, GHCJS and Wine
08:32:59 * hackagebot binary 0.7.5.0 - Binary serialisation for Haskell values using lazy ByteStrings  http://hackage.haskell.org/package/binary-0.7.5.0 (LennartKolmodin)
08:46:10 <samba1> multiPred x = or $ map ($ x) [(< 10), even]
08:46:23 <samba1> is there an idiomatic way to do that?
08:47:15 <joneshf-laptop> idiomatic?
08:47:18 <joneshf-laptop> :t any
08:47:19 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
08:47:30 <samba1> that's the other way
08:47:32 <joneshf-laptop> i dunno what's idiomatic
08:47:43 <samba1> any takes one predicate and multiple values
08:47:54 <samba1> mine has one value which is applied to multiple predicates
08:48:12 <geekosaur> functions are values in functional languages
08:49:08 <joneshf-laptop> > let multiPred x = any ($ x) [(< 10), even] in multiPred 3
08:49:10 <lambdabot>  True
08:49:15 <liste> monad-loops has a monadic version of samba1's multiPred
08:49:15 <joneshf-laptop> > let multiPred x = any ($ x) [(< 10), even] in multiPred 31
08:49:18 <lambdabot>  False
08:49:27 <liste> anyPM
08:49:38 <solirc> sydneyhacker: Doctest should use the QC default of 100 tests for each property
08:49:53 <solirc> sydneyhacker: I think it's not configurable
08:50:32 <joneshf-laptop> i mean, isn't `any p xs == or . map p . toList xs`?
08:53:00 * hackagebot ltext 0.0.0.4 - Higher-order file applicator  http://hackage.haskell.org/package/ltext-0.0.0.4 (athanclark)
08:56:48 <samgd> > :t \x -> any ($ x) [(< 10), even]
08:56:51 <lambdabot>  <hint>:1:1: parse error on input ‘:’
08:57:12 <samgd> > let foo x = any ($ x) [(< 10), even] in foo 5
08:57:15 <lambdabot>  True
08:57:31 <[k-> :t \x -> any ($ x) [(<) 10, even]
08:57:33 <lambdabot> Integral a => a -> Bool
08:58:02 <[k-> @pl multiPred x = or $ map ($ x) [(< 10), even]
08:58:02 <lambdabot> multiPred = or . flip map [(< 10), even] . flip id
08:58:21 <[k-> @help
08:58:21 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:58:30 <[k-> @list
08:58:30 <lambdabot> What module?  Try @listmodules for some ideas.
08:58:37 <[k-> ...
08:58:58 <joneshf-laptop> [k-, the cycle stops :)
09:00:06 <[k-> too lazy
09:11:19 <fvgvxmpv1> for some reason I don´t seem to be able to remove NixOS doesn´t want me to use vty-ui or even vty — short of using ncurses directly (which seems… uncomfortable) are there common alternatives for making a terminal user interface?
09:12:06 <timothyh> vty is nice and only requires normal ncurses libraries...
09:12:29 <timothyh> i think there's hscurses but that's going to need to be linked to ncurses also
09:14:37 <fvgvxmpv1> hscurses seems even less comfortable than ncurses
09:18:24 <timothyh> its much less nice than vty, since it is one less layer of abstraction
09:20:26 <fvgvxmpv1> timothyh; indeed — I guess what I was asking was: is there another library with approximately the same level of abstraction as, at least, vty, that is not vty?
09:20:48 <timothyh> if one existed, it'd almost certainly bind ncurses, leading to the same issue
09:22:10 <fvgvxmpv1> using ncurses works fine — I have no idea what part of vty causes the issue but for reasons of nix shenanigans vty and everything that uses vty is unusable to me at the moment
09:22:50 <jaen> I'm trying to learn something more than "implement a simple algorithm" in Haskell and I have a slightly philosophical question - as far as I understand you can implement `map`, `zip`, `filter` and whatnot in terms of `fold`, but you cannot implement `fold` in terms of `map`. I understand that `bind` operation of `List` monad is equivalent to `concatMap`, so that effectively means you can't fold the `List`
09:22:52 <jaen> monad, at least to my understanding. So how would you fold a `List` monad? Would you have to have a new `ReducibleList` monad with `bind` defined in terms of `fold`, or?
09:24:02 <c_wraith> jaen: Monad is a pattern that only supports composition.
09:24:15 <c_wraith> jaen: if you want to perform operations other than composition, you need more than just the Monad interface
09:24:24 <monochrom> I don't understand the question.  1. I can use fold to write bind.  2. "fold a List monad" = "fold a List". I know how to fold a list.
09:25:00 <srhb> monochrom: The question is whether a monad gives you enough operations to implement fold. Ie, is Monad ~ Foldable, which it isn't/
09:25:17 <srhb> At least to my understanding. :-)
09:25:23 <c_wraith> That was my understand as well
09:25:43 <naudiz> why am I always forgetting the syntax for language extensions? =_= was ist {-! LANGUAGE XYZ !-}?
09:25:50 <srhb> naudiz: {-# LA...
09:26:07 <naudiz> srhb: thanks
09:26:09 <c_wraith> {-# ... #-} is the marker for any sort of meta-information to the compiler.
09:26:50 <naudiz> I don't know why I keep forgetting it...
09:27:14 <magneticDuck> {-# is a waffle on an anchor naudiz 
09:27:16 <magneticDuck> now you'll never forget
09:27:30 <sm> nice! :)
09:27:43 <srhb> jaen: Note also that the list monad isn't some sort of generalization of lists, but an actual implementation of a Monad []. So you didn't lose any operations, you just generally can't fold in a way that would make your code generic over the list and (for example) Reader monad.
09:27:56 <naudiz> magneticDuck: how is that supposed to help me? :D
09:28:14 <srhb> naudiz: Pronounce it like anchorwaffle out loud every time you write it.
09:28:23 <srhb> That should work quite quickly. :P
09:28:32 <magneticDuck> naudiz: people can remember tangible values like words better than strings of symbols
09:28:37 <monochrom> did you know: xpath comments are like (: this is an xpath comment :)
09:28:47 <srhb> (:
09:28:57 <magneticDuck> if I type 10962, you've already forgotten it, but if I say horsebatterystaple, you'll recall it in a day
09:29:19 <magneticDuck> just think of that series of symbols for compiler metadata as an anchor waffle, is what we're saying
09:29:45 <naudiz> magneticDuck: thing is that I don't associate metadata with anchor waffles... yet
09:29:47 <monochrom> I remember tangible strings of symbols better than vague words
09:29:56 <ion> “What was the analogy again? A burrito on a tennis racket?”
09:30:06 <codygman> Is there a way to express the logic of mkAnswerVal in the type system here? http://lpaste.net/133625
09:30:23 <jaen> c_wraith, srhb: ok I think that answers my question - the monad definition is insufficient to support folding in and of itself. And looking at the typeclassopedia `Monad` and `Foldable` are totally disparate types, yes? So being a `Monad` has no bearing on being `Foldable` and vice versa, yes? So you can be none, either or both and membership in one doesn't imply membership in other.
09:30:37 <magneticDuck> ion: imagine how an anchor waffle tastes =P
09:30:37 <srhb> jaen: Correct.
09:30:41 <c_wraith> jaen: they are pretty much totally independent.
09:30:55 <c_wraith> jaen: about the only thing they have in common is that they are properties of types with kind * -> *
09:31:00 <magneticDuck> naudiz: well if you associated every two concepts as soon as anybody mentioned them together, you'd be screwed
09:31:22 <srhb> jaen: An easy way to remember this is to consider whether you could do a fold that would be generic over every monad m.
09:31:29 <magneticDuck> that's what we have different levels of memory for
09:31:33 <srhb> jaen: Which it would have to be to truly be a Monad method.
09:32:05 <naudiz> magneticDuck: I'm learning Japanese using the Heisig method, I know what you're talking about. I just don't know how to get from "metadata" to "anchor waffle"...
09:32:24 <jaen> Ok, thanks very much
09:32:52 <naudiz> magneticDuck: anchor waffle is just as random as sail pancake... 
09:32:52 <magneticDuck> naudiz: metadata is a little fluffy thing that you drop into a file
09:37:59 <srhb> naudiz: It's more about translating open brace-dash-hash to anchorwaffle, not metadata to anchorwaffle. :-)
09:38:25 <srhb> Though brace-dash-hash is actually not bad in itself.
09:38:42 <magneticDuck> srhb: surely you see how {-# is obviously an anchor waffle
09:38:48 <srhb> I do!
09:38:51 <magneticDuck> which is in turn a fluffy thing you drop into a file with a plunk
09:38:59 <srhb> Haha, OK, now I do see it. :P
09:38:59 <magneticDuck> so, issue solved, I've memorized it already
09:39:01 <magneticDuck> .next
09:45:37 <naudiz> magneticDuck: now you just made me hungry
09:46:11 <nak> so hungry
09:47:12 <mlamari> Was unused-toplevel-binding ever a warning in haskell? I whether via ghc -WAll and -fwarn-unused-binds it doesn't seem to warn on unused toplevel functions or vars, I could have swarn I used to see this wonder if I botched something on reinstall.
09:47:35 <mlamari> Hlint doesn't warn either
09:48:33 <hexagoxel> mlamari: list your exports
09:48:54 <mlamari> hexagonel : This is just dumb noob coding, I don't have any exports
09:49:09 <hexagoxel> then everything is exported, so everything is used
09:49:12 <hexagoxel> :p
09:49:19 <monochrom> that means you default to exporting everything under the sun
09:49:41 <Welkin> even your imports
09:49:51 <mzero> no, not your import
09:50:06 <mzero> this isn't python  :-P
09:50:13 <monochrom> they are not under the sun. they are under the moon.
09:50:15 <Welkin> ah yes
09:50:20 <Welkin> you must explicity export your imports
09:51:17 <Welkin> what do you think about using the same function name in two different modules for similar purposes, but where the definitions differ slightly?
09:51:23 <Welkin> they are internal and not exported from the module
09:51:45 <monochrom> I think it's fine
09:52:13 <monochrom> surely Bytestring and Text have a ton of common names for internal purposes. even for external purposes.
09:52:24 <Welkin> yes
09:52:30 <Welkin> I often run into those conflicts
09:52:36 <Welkin> even Text and List
09:52:45 <mlamari> Thanks all that was it I was not indicating exports. This was main so I need module Main (main)
09:53:06 * hackagebot ltext 0.0.0.5 - Higher-order file applicator  http://hackage.haskell.org/package/ltext-0.0.0.5 (athanclark)
09:53:08 <mlamari> That's why I remember it - had seen it in the past on libraries that had deliberate focussed exprots.
09:54:21 <Welkin> I import Text as T, ByteString.Lazy as LBS, and List as L
09:54:38 <Welkin> these seems to be comon cenventions that I picked up, since they made sense
09:54:44 <Welkin> wow
09:54:52 <Welkin> these seem to be common conventions*
09:56:30 <nshepperd> if the conflicting definitions at least have different types, then it's not usually possible to get them mixed up
09:56:57 <Welkin> the types are the same
09:57:11 <Welkin> they use the same type, but each is defined in a different module
09:57:23 <Welkin> the constructor parameters differ
09:57:25 <Welkin> that is all
09:58:02 <Welkin> oh, you were talking about exported conflicts
09:58:06 * hackagebot hoauth2 0.4.8 - hoauth2  http://hackage.haskell.org/package/hoauth2-0.4.8 (HaishengWu)
09:58:13 <Welkin> my functions are not exported
10:08:07 * hackagebot aeson-schema 0.3.0.6 - Haskell JSON schema validator and parser generator  http://hackage.haskell.org/package/aeson-schema-0.3.0.6 (TimBaumann)
10:11:20 <ReinH> Welkin: you have module Foo () where at the top of your file?
10:18:07 * hackagebot hdevtools 0.1.0.9 - Persistent GHC powered background server for FAST haskell development tools  http://hackage.haskell.org/package/hdevtools-0.1.0.9 (SchellScivally)
10:18:18 <Kudos2Me> Free SEO Tools Website Analyzer/Website Optimizer with PDF reports no sign up required visit https://www.criosphinx.net/seo
10:21:26 <naudiz> computing non-linear differential equations reminds me of https://www.xkcd.com/303/
10:23:17 <breadmonster> Hi everyone.
10:23:32 <breadmonster> Does anyone have any experience doing web programming in Haskell?
10:23:48 <naudiz> breadmonster: what do you want to know?
10:24:21 <breadmonster> naudiz: This isn't directly relevant, but https://api.stackexchange.com/docs for instance.
10:24:26 <breadmonster> Or any other API that sends JSON.
10:24:32 <breadmonster> ...how do I download that to my PC?
10:24:58 <Cale> Download what exactly?
10:25:22 <breadmonster> Cale: I think they're called http requests?
10:25:24 <naudiz> breadmonster: so you want to work with a REST-API, right?
10:25:38 <breadmonster> naudiz: I have no idea what that is. Total web n00b.
10:25:43 <breadmonster> Wanna start doing web programming.
10:25:53 <naudiz> breadmonster: are you experienced with Haskell?
10:26:20 <breadmonster> naudiz: Umm, not to like the point where I can implement my own libraries, but I know enough.
10:26:39 <Cale> breadmonster: You request certain URLs from the server, it sends you the information you asked for. It's more or less the same thing as actually browsing, except that the responses are generated by the server in a machine readable format.
10:27:06 <breadmonster> Cale: Yeah, except is there a library for this or something?
10:27:11 <breadmonster> Sorry, I probably sound like a retard.
10:27:15 <naudiz> breadmonster: then I'd suggest to have a look at yesod. it's not exactly light-weight but it teaches you what you need to know to work with REST-APIs and it's very easy to use. just read the book on their website
10:28:05 <breadmonster> naudiz: Umm does that also deal with the http protocol and all that?
10:28:16 <breadmonster> I'm not very well versed with anything remotely web related.
10:28:45 <naudiz> breadmonster: yesod basically allows you to implement any kind of server. I think that's a good point to start at.
10:29:13 <Cale> Maybe start with something simpler...
10:29:32 <naudiz> breadmonster: ususally yesod is used for web-servers so I'd suggest programming a website with yesod just to dive into the topic and learn the basics
10:29:41 <haasn> I like scotty
10:29:43 <Cale> The simplest library I can think of for requesting URIs is probably http://hackage.haskell.org/package/download
10:30:22 <Cale> You can use openURI with the URL you want to grab a response from the server as a String, and then parse that using something like aeson.
10:30:31 <haasn> If you're talking about making a JSON API (server-side), I would totally use scotty + aeson
10:30:55 <haasn> If you're talking about making a JSON API client-side, what Cale said might be relevant
10:31:06 <haasn> If you're just wondering how to use a JSON API yourself (without even touching code), use curl
10:31:26 <Cale> I mean, he linked to the documentation for stackexchange's public API
10:32:34 <breadmonster> haasn: Isn't curl a unix command line tool?
10:32:57 <Cale> breadmonster: yes, as well as a C library for which there exists a Haskell binding.
10:33:13 <haasn> (I was referring to the command line tool) yes
10:33:28 <breadmonster> haasn: No, I wanted to use it in code.
10:33:36 <breadmonster> I'm trying to get some web programming done.
10:33:43 <Cale> breadmonster: Well, which requests are you trying to make?
10:33:52 <breadmonster> Umm, I have no idea.
10:34:03 <haasn> I wonder if there exists some convenient and safe client-side abstraction for JSON APIs
10:34:03 <breadmonster> I just thought that I'd start at figuring out how this stuff works.
10:35:17 <naudiz> breadmonster: as I said, starting with yesod to learn how the whole REST thing works might be a good idea. It also comes with a JSON API
10:35:42 <haasn> (To the point where I just have something like operation :: Parameters -> T Response for some T)
10:35:54 <haasn> (and JSON-encoding is done internally)
10:35:59 <haasn> (plus error handling)
10:36:00 <Cale> breadmonster: It might be easiest to just use your web browser to start with, put some URIs into the address bar to see what you get back. Once you have some idea of what it is that you'd like to request, you can write a program to make those requests for you and do stuff with the responses.
10:38:06 <Cale> (or interactively fill in their forms and it'll make the URIs for you)
10:38:08 * hackagebot ltext 0.0.1 - Higher-order file applicator  http://hackage.haskell.org/package/ltext-0.0.1 (athanclark)
10:38:31 <Cale> (as well as format the response nicely for human inspection)
10:39:05 <breadmonster> Hmm, that's true.
10:39:16 <breadmonster> Cale: You're always full of good advice.
10:39:32 <breadmonster> naudiz: Will do, except I've had issues compiling Yesod before.
10:40:03 <naudiz> breadmonster: unfortunately it has lots of dependencies... always use a sandbox!
10:40:14 <Cale> I think yesod would be absolute overkill just for making some web API requests.
10:40:40 <breadmonster> naudiz: That's really interesting.
10:40:41 * haasn still prefers scotty+aeson
10:40:59 <joneshf-laptop> Cale, do you know of something like `download` that'll actually build?
10:41:06 <breadmonster> I'd like to speak to Michael Snoyman sometime.
10:41:11 <Cale> joneshf-laptop: Oh, does download not build?
10:41:16 <Cale> I guess it's been a while since I tried it.
10:41:36 <breadmonster> haasn: What's scotty for?
10:41:46 <breadmonster> aeson is bos's JSON parser iirc
10:42:04 <joneshf-laptop> Cale, the latest breaks on some call to `unsafePerformIO` on both 7.10 and 7.8
10:42:07 <joneshf-laptop> at least for me
10:42:22 <Cale> breadmonster: It's a lightweight web application server, the opposite of what you need to make requests from an API, so I don't really know why it's being suggested.
10:42:37 <Cale> (similarly with Yesod)
10:42:38 <breadmonster> Cale: Isn't Yesod also a web application server?
10:42:40 <Cale> yes
10:42:51 <breadmonster> Yeah, in hindsight I'd like to do the opposite.
10:43:00 <Cale> joneshf-laptop: ah, I see
10:43:13 <Cale> That's unfortunate... it would be easy enough to fix, I think
10:43:20 <Jarvis2> CuteStat 2.0 Site Worth Script NULLED Share & Rate direct link http://bit.ly/1EL693G
10:43:31 <Jarvis2> CuteStat 2.0 Site Worth Script NULLED Share & Rate direct link http://bit.ly/1EL693G
10:43:40 <Jarvis2> CuteStat 2.0 Site Worth Script NULLED Share & Rate direct link http://bit.ly/1EL693G
10:44:59 <Cale> It's an easy fix. The import of System.IO.Unsafe is just commented out for some reason
10:45:04 <joneshf-laptop> Cale, probably, no place to report bugs from hackage or on don's site.
10:45:16 --- mode: ChanServ set +o monochrom
10:45:31 --- mode: monochrom set +b *!*@host86-139-75-0.range86-139.btcentralplus.com
10:45:37 --- mode: monochrom set -o monochrom
10:46:09 <rui3> Trying to build ghc 7.10.1 on Fedora. When running make, it says 
10:46:12 <rui3> ghc-cabal: The following installed packages are broken because other packages
10:46:14 <rui3> they depend on are missing. These broken packages must be rebuilt before they
10:46:16 <rui3> can be used.
10:46:49 <breadmonster> rui3: What packages are these?
10:46:53 <Welkin> alex and happy?
10:46:58 <Welkin> perhaps
10:47:12 <rui3> package bin-package-db-0.0.0.0 is broken due to missing package
10:47:14 <rui3> base-4.7.0.2
10:47:14 <breadmonster> rui3: That's pretty strange, I built 7.10.1 the other week on Fedora.
10:47:18 <rui3> bytestring
10:47:26 <rui3> directory, and about 20 more
10:47:38 <breadmonster> are you using a sandbox?
10:47:50 <haasn> Cale: My suggestion was towards naudiz more than towards breadmonster
10:48:13 <Cale> breadmonster: GHC doesn't use Cabal as its build system, so sandboxes are irrelevant.
10:48:14 <rui3> breadmonster: Not using cabal. Just dowloaded the sources, yum installed the dependencies, ./configure, make
10:48:22 <Cale> haasn: ah
10:48:41 <Cale> rui3: Which version of GHC do you have installed?
10:48:57 <breadmonster> Cale: It sounds like he's having issues with his packages.
10:49:06 <rui3> but cabal 1.16.0.2 is yum installed with ghc 7.6.3
10:49:08 <rui3> Cale
10:49:20 <Cale> hmm
10:49:32 <Cale> I wonder if 7.6.3 is new enough to build 7.10.1
10:49:44 <breadmonster> Cale: It is. I've done that.
10:49:44 <Cale> But yeah, that does sound suspicious
10:49:53 <Cale> Try  ghc-pkg check
10:50:02 <Cale> and see if you get any errors
10:50:07 <breadmonster> rui3: Are those packages in your path?
10:50:11 <rui3> Cale: empty, nothing
10:51:31 <Cale> rui3: Is there any particular reason why you're not just using the generic linux binary package of GHC?
10:51:38 <rui3> Perhaps I should install haskell platform on Fedora?
10:51:58 <breadmonster> rui3: Don't.
10:52:06 <Cale> It seems like a waste of time to try to fix any package database issues of your existing GHC if you're planning on immediately replacing it
10:52:08 <rui3> Cale: No. I am just looking for any way to get something newer than 7.6 working here
10:52:08 <breadmonster> rui3: try using cabal to install bytestring?
10:52:14 <naudiz> haasn: I like to work with yesod since it's very intuitive even if I have to live with lots of dependencies and large executables
10:52:26 <Cale> rui3: Okay, then yeah, don't compile GHC yourself, it's a massive waste of time unless you're hacking on it.
10:52:54 <breadmonster> rui3: You can upgrade to 7.8 in the F22 package libraries.
10:52:56 <Cale> Get whichever is the appropriate binary package from here: https://www.haskell.org/ghc/download_ghc_7_10_1#x86linux
10:53:01 <breadmonster> Or 7.10.
10:53:02 <breadmonster> Don't recall.
10:53:22 <rui3> breadmonster: I'm on F21
10:53:25 <kadoban> rui3: The way to go is to install /just/ GHC and cabal, and do everything else in sandboxes, optionally with stackage. IMO of course.
10:53:26 <breadmonster> Cale: How does download work?
10:53:45 <naudiz> I agree with Cale. As a Gentoo user I know how it is to compile ghc. |D
10:54:11 <breadmonster> naudiz: Does it really take that long? It took me like seventeen minutes.
10:54:14 <voidzero> easy though
10:54:23 <Cale> breadmonster: Well, apparently the version on Hackage is presently broken, so it doesn't. But when it is working, it's quite simple, you just execute the IO action  openURI "http://www.google.com"  or whatever and it gets you the body of the response as a String.
10:54:24 <voidzero> and the haskell overlay is grreat!
10:54:55 <naudiz> breadmonster: what were you compiling? and what cpu do you have?
10:55:00 <breadmonster> Cale: Sure, but what happens underneath?
10:55:16 <Cale> I hold Gentoo users personally responsible for the eventual heat death of the universe.
10:55:38 <breadmonster> naudiz: I have the Haswell i7 on mobile. I was compiling GHC with all optimizations turned on.
10:55:41 <srhb> breadmonster: You compiled GHC in 17 minutes?
10:55:42 <naudiz> Cale: humanity deserves it
10:55:44 <srhb> o_O
10:56:05 <naudiz> breadmonster: number of cores? frequency?
10:56:06 <kadoban> naudiz: Humanity probably won't be around long enough to get punished by it though ;)
10:56:30 <sm> Cale: yes, also users of Travis/Jenkins/etc. 
10:56:36 <naudiz> kadoban: but portage will still run? :P
10:56:40 <breadmonster> naudiz: Umm, 2.9 GHz, 4 cores, 8 threads.
10:56:51 <srhb> That can't be right
10:57:00 <srhb> My specs are about the same, and compiling GHC takes around 4 hours or so.
10:57:01 <sm> don't even start about bitcoin... >:|
10:57:03 <kadoban> naudiz: Haha, maybe.
10:57:04 <monochrom> linux users seem to believe in the false dichotomy of "either from distro or build"
10:57:07 <naudiz> breadmonster: no way.
10:57:29 <breadmonster> Do you guys want me to time it for you or something?
10:57:46 <breadmonster> I just ran the usual ./configure; make && make install
10:57:47 <srhb> breadmonster: No need.
10:57:49 <Cale> 17 minutes doesn't seem all that unreasonable for a parallelised build of GHC
10:58:04 <srhb> Perhaps without optimization, but I still think it sounds implausible.
10:58:30 <Cale> I remember dons had some crazy machine where he did it in 9 minutes, and that was a few years back when he was still hanging around on IRC
10:58:34 <breadmonster> srhb: One second umm, does the default build leave optimization turned on?
10:59:12 <zed_> hi everyone : ) so i spent some time working an example of code but i am trying to figure out something simple, as usual. in ghci, what should I type in order to create an instance of Input that would allow me to use the ff1 function ? I am really new to haskell. thanks ! http://lpaste.net/133607
10:59:15 <Cale> (then again, it wasn't the same version of GHC)
10:59:43 <srhb> breadmonster: I don't recall. Anyway, consider yourself lucky I guess. :-)
10:59:46 <breadmonster> srhb: How do you compile? I use the regular flag.
10:59:51 <Cale> zed_: ff1 (Input 1 2 3) ?
10:59:55 <breadmonster> Without any modifications to the makefile.
11:00:14 <zed_> Cale: thanks !
11:00:56 <rui3> Cale: Dowloading the generic binary. In 10 minutes I'll know. However, in the description it says something about requiting libgmp.so.10 and Debian 7
11:01:04 <breadmonster> Cale: Can I use ? as an operator in GHC?
11:01:44 <rui3> I don't seem to have libgmp.so.10. Yum just told me its in gmp-6.0.0-9.fc21.i686 package which it refuses to install because of dependency crap
11:01:59 <srhb> > let x ? y = x ++ y in "4" ? "2"
11:01:59 <Cale> hmm
11:02:00 <geekosaur> > let a ? b = a + b in 1 ? 2
11:02:00 <lambdabot>  "42"
11:02:02 <lambdabot>  3
11:02:10 <Cale> rui3: heh, maybe you can build *that* instead.
11:03:08 <Cale> rui3: That's obnoxious that it's refusing to install it. What dependency crap could possibly get in the way there, I wonder.
11:03:26 <breadmonster> rui3: what's the output of `dnf install libgmp`?
11:03:30 <rui3> Cale: Multilib version problems found. This often means that the root
11:03:33 <rui3>        cause is something else and multilib version checking is just
11:03:34 <dreams> > let ? = a + b in 1 ? 2
11:03:35 <rui3>        pointing out that there is a problem
11:03:36 <lambdabot>  <hint>:1:1: parse error in let binding: missing required 'in'
11:03:47 <dreams> > let ? = + in 1 ? 2
11:03:49 <lambdabot>  <hint>:1:1: parse error in let binding: missing required 'in'
11:04:02 <rui3> breadmonster: No package libgmp available
11:04:13 <naudiz> breadmonster: one second, I'll check how long my last ghc build needed
11:04:15 <breadmonster> rui3: what's the output of `dnf install gmp`?
11:04:19 <Cale> > let a ? b = a + b in 1 ? 2 -- dreams
11:04:21 <lambdabot>  3
11:04:25 <geekosaur> > let (?) = (+) in 1 ? 2
11:04:27 <lambdabot>  3
11:04:29 <rui3> breadmonster: No package libgmp available
11:04:31 <dreams> ^ there
11:04:33 <rui3> Sorry
11:04:37 <geekosaur> if you're using an operatort as a function you need the parens
11:04:46 <rui3> breadmonster: Package gmp-1:6.0.0-9.fc21.x86_64 is already installed, skipping.
11:05:09 <rui3> breadmonster: I do have libgmp.so. Just not libgmp.so.10
11:05:20 <Cale> rui3: Which version do you have?
11:05:32 <dreams> geekosaur: Did you mean if you use a symbol?
11:05:42 <geekosaur> same thing
11:05:49 <rui3> Cale: How to know. It's not a symlink
11:06:04 <dreams>  > let b = (+) in 1 `b` 2
11:06:07 <dreams> > let b = (+) in 1 `b` 2
11:06:09 <lambdabot>  3
11:06:16 <dreams> geekosaur: no paren needed
11:06:17 <breadmonster> rui3: Why don't you try the #fedora channel?
11:06:41 <naudiz> rui3: or just install gentoo :)
11:06:43 <monochrom> you need something along the line of "libgmp-dev". that's an ubuntu name. I don't know its fedora name.
11:06:51 <Cale> rui3: Oh, in that case, maybe just make a symlink from that to libgmp.so.10 then
11:07:03 <geekosaur> gmp-devel, but libgmp.so.10 is a runtime name, libgmp.so is the devel name
11:07:38 <geekosaur> dreams, b is a normal function symbol, you need `` to use it infix. ? is an operator symbol, you need () to use it prefix
11:07:53 <monochrom> that's strange then. you're saying the present files are all backwards.
11:08:07 <geekosaur> (and using it by itself is the trivial case of prefix, not of infix)
11:08:24 <geekosaur> (otherwise names bound to values would be rather weird)
11:08:54 <dreams> geekosaur: I meant that only when you use non-alpha you need parenthesis (i.e. it doesn't have to do anything with function/primitive operator).
11:09:07 <geekosaur> what is primitive about operators?
11:09:21 <geekosaur> I described to you what the Report says, more or less
11:09:29 <Cale> rui3: On my (Linux Mint) system, libgmp.so.10.1.3 is the non-symlinked binary in /usr/lib/x86_64-linux-gnu and libgmp.so.10 and libgmp.so are symbolic links to it.
11:09:30 <rui3> naudiz: I've had enough of new distributions for this year with a 50% successfull NixOS, maybe in 2016
11:09:41 <breadmonster> Cale: I thought you ran Fedora.
11:09:45 <monochrom> "operators are primitive" is an old idea from archaic languages such as C and python.
11:09:46 <geekosaur> you're trying to apply an interpretation to it, one which holds in simple cases but not more complex ones
11:09:51 <Cale> breadmonster: why did you think that?
11:09:57 <breadmonster> rui3: Are you upgrading to F22?
11:10:10 <naudiz> rui3: 2016 will be the year of GNU/HURD
11:10:14 <breadmonster> Cale: I remember you being very helpful about some Fedora questions I had.
11:10:27 <breadmonster> naudiz: Did you find your compile logs?
11:10:29 <rui3> breadmonster: is it worth it? Upgraded to F21 a little while ago
11:10:33 <Cale> Did I give Fedora-specific answers to them/
11:10:34 <Cale> ?
11:10:36 <breadmonster> rui3: Yeah.
11:10:39 <breadmonster> Cale: Yup.
11:10:45 <Cale> Weird, doesn't sound like me
11:10:48 <naudiz> breadmonster: genlop is still running... wonder what takes it so long
11:10:53 <rui3> Cale: the .so here is in /usr/lib/openssl/engines
11:10:54 <geekosaur> there is no magic here; symbol characters form infix functions ("operators") and alphanumerics form prefix functions, there is no other distinction
11:11:16 <rui3> WAIT
11:11:19 <rui3> WAIT
11:11:19 <breadmonster> naudiz: What's genlop?
11:11:27 <breadmonster> rui3: ?
11:11:42 <rui3> Sorry, my bad
11:12:16 <dreams> geekosaur: what I meant is that, the rule of surrounding non-alphnumerics with parenthesis seems like a parsing restriction (we can't parse it if you don't surround with parenthesis).
11:12:17 <rui3> Found it. I had made a mistake with "find".
11:12:26 <rui3> libgmp.so.10 is here. Sorry
11:12:33 <Cale> rui3: in that case, cool :)
11:12:57 <Cale> rui3: It would have been pretty quick to complain at you in any case, I think.
11:13:03 <geekosaur> dreams, it's not simply a parsing restriction, unless you'd prefer to rip out most of the language's flexibility to enable a shorthand only useful for simple cases
11:13:21 <rui3> I wonder why yum whatprovides libgmp.so.10 just told me about that old incompatible package
11:13:25 <breadmonster> Cale: Umm, anyway, do you know how the download package is implemented internally?
11:13:40 <naudiz> breadmonster: a gentoo tool for reviewing merge times. It says 7.8.3 needed ~50min to compile with 4×2.5GHz...
11:14:00 <breadmonster> naudiz: I used 8 cores, not 4.
11:14:25 <zed_> i tried to input the actual binomialPDF and i am having mismatch errors... if you care to help, here's the code : http://lpaste.net/133647
11:14:28 <breadmonster> Or 9 threads. Don't recall.
11:15:24 <geekosaur> zed_, you should also include what you're trying and the full error message(s)
11:15:32 <naudiz> breadmonster: I compiled it with 5 threads
11:15:48 <Cale> breadmonster: I didn't, but I had a look and oddly enough it's a binding to some C library which it just includes wholesale.
11:15:51 <breadmonster> naudiz: I had 9, so that might explain.
11:15:55 <Cale> breadmonster: I'm not sure why
11:16:05 <breadmonster> How did srhb take four hours?
11:16:28 <geekosaur> some things do that just to avoid annoyances building on Windows
11:16:37 <zed_> Prelude Data.List> :l VaR_irc.hs 
11:16:37 <zed_> [1 of 1] Compiling Main             ( VaR_irc.hs, interpreted )
11:16:37 <zed_> VaR_irc.hs:22:38:
11:16:38 <zed_>     Couldn't match type ‘Int’ with ‘Double’
11:16:41 <zed_>     Expected type: (Double, Double, Double)
11:16:43 <zed_>                    -> Int -> (Double, Double, Double)
11:16:44 <zed_>       Actual type: (Double, Int, Int) -> Int -> (Double, Int, Int)
11:16:45 <geekosaur> @paste
11:16:45 <lambdabot> Haskell pastebin: http://lpaste.net/
11:16:46 <zed_>     In the first argument of ‘foldl'’, namely ‘loop’
11:16:47 <breadmonster> Cale: How else would you implement it?
11:16:49 <zed_>     In the first argument of ‘f’, namely
11:16:51 <zed_>       ‘(foldl' loop (0, 0, 0) [0 .. d1])’
11:16:51 <geekosaur> plase don't paste into the channel
11:16:52 <zed_> VaR_irc.hs:29:41:
11:16:54 <zed_>     Couldn't match expected type ‘Double’ with actual type ‘Int’
11:16:57 <zed_>     In the third argument of ‘binomialPDF’, namely ‘d1’
11:16:59 <zed_>     In the second argument of ‘(+)’, namely ‘binomialPDF j p1 d1’
11:16:59 <naudiz> breadmonster: not really... my server needs 16min with 8×3.4GHz and 9 threads
11:17:00 --- mode: ChanServ set +o geekosaur
11:17:01 <zed_> VaR_irc.hs:35:23:
11:17:02 <zed_>     Couldn't match expected type ‘Int’ with actual type ‘Double’
11:17:03 --- mode: ChanServ set +o mauke
11:17:03 --- mode: mauke set +q *!*@modemcable003.23-130-66.mc.videotron.ca
11:17:13 --- kick: zed_ was kicked by geekosaur (Your behavior is not conducive to the desired environment.)
11:17:26 --- mode: mauke set -q *!*@modemcable003.23-130-66.mc.videotron.ca
11:17:27 <rui3> Installinnnng
11:18:28 <zed_> sorry for this again.
11:18:36 <Cale> zed_: Use lpaste to paste stuff :)
11:18:41 <zed_> Cale: thanks : )
11:18:47 <geekosaur> pasting into the channel is a really bad idea
11:19:17 <geekosaur> in any case your error line numbers don't match the paste (appear to be off by one line)
11:19:23 <Cale> zed_: It may help if you give explicit type signatures to f and loop in the definition of ff1
11:19:47 <Cale> zed_: You'll probably get better error messages which make it clearer what's wrong
11:20:03 <Cale> Actually, no, one thing is pretty clear
11:20:09 <Cale> d1 is definitely a Double
11:20:13 --- mode: mauke set -o mauke
11:20:16 <zed_> Cale: it's what i wanted to do, I am unsure how to proceed... should i just define them separately ?
11:20:42 <cstrahan> i'd like to view the code generated vai `deriving Show`; how can I dump that intermediate representation for a given cabal project?
11:20:44 <Cale> Well, I mean, it definitely needs to be a Double, if it's going to be the third argument to binomialPDF
11:20:49 <zed_> Cale: well I want to have them have the types defined the way they are in the data Input
11:20:50 <cstrahan> s/vai/via
11:20:59 <Cale> But in Input you're saying it's an Int
11:21:04 <Cale> right
11:21:07 <srhb> cstrahan: --ddump-ds I think?
11:21:18 <srhb> cstrahan: Er no, -ddump-deriv
11:21:31 <cstrahan> srhb: cool - i'll give that a go. thanks!
11:21:33 <Cale> So you probably want to apply fromIntegral to convert the Int to a Double so that you can give it to binomialPDF
11:22:02 <zed_> Cale: you are correct. let me work on this and get back on it.
11:24:18 <rui3> Sigh, do I need the old ghc now to cabal install the new cabal-install?
11:24:20 <rui3> Haha
11:27:12 <Cale> rui3: If you still have your old cabal binary it should still work
11:30:54 <cstrahan> hrm...
11:30:57 <cstrahan> so I tried: cabal build --ghc-option=-ddump-simpl --ghc-option=-ddump-to-file
11:31:25 <cstrahan> and also tried putting those in the cabal file itself, but i'm not seeing any new files in my tree.
11:31:45 <naudiz> life is too short for 6GB RAM
11:32:46 <monochrom> cstrahan, have you looked somewhere under "dist", and even deeper?
11:32:49 <rui3> Cale: If only, right?
11:33:22 <Cale> rui3: does it not work, or you don't have the cabal-install binary?
11:34:26 <Cale> You can get the tarball of cabal-install from http://hackage.haskell.org/package/cabal-install and run the bootstrap.sh script from there if you don't have a cabal binary.
11:35:42 <rui3> Don't have the binary. But I am copying the binary from my laptop now
11:40:21 <mniip> what would be an architecturally good way to represent a string with inline formatting akin to IRC color codes?
11:40:40 <hexagoxel> grr i just should make ghc-7.8.4 my default again ..
11:40:40 <mniip> what I have in mind is [Either String ColorCode]
11:42:15 <hexagoxel> or do all of {happy, hoogle, pointful, pointfree, alex, aeson, hscolour, haddock, hlint, ghc-core} work with ghc-7.10 yet?
11:44:00 <cstrahan> monochrom: I think I just had to `rm -rf dist` first; it's there now under dist/build/src
11:54:05 <rui3> All working :)
11:54:52 <hartley7> Any way to get quickcheck to run tests on a property that takes two (arbitrary) parameters and returns a bool?
11:55:59 <rui3> When you cabal build something in a sandbox, its all statically linked? I can just copy the resulting binaries somewhere in the path and it all should work?
11:58:20 <c_wraith> hartley7: it should just work.
11:58:39 <c_wraith> @check let f x y = x == (y :: Int) in f
11:58:41 <lambdabot>  *** Failed! Falsifiable (after 3 tests and 2 shrinks):
11:58:41 <lambdabot>  2 -1
11:59:07 <c_wraith> hartley7: ^ It should just work.
11:59:09 <zed_> so I tried to rewrite f and loop in such a way as to have specify the type of their arguments but was unable to, since it then renders foldl unusable. any suggestion is welcome. code: http://lpaste.net/133647 error : http://lpaste.net/133652
12:00:30 <ClaudiusMaximus> so there's 'compensated' allowing stacking multiple floating point values together to get higher precision, is there anything out there already for extending exponent range?
12:02:42 <c_wraith> zed_: you almost certainly need a fromIntegral in there.
12:04:54 <byorgey> zed_: the problem is that e.g. loop takes an argument j and passes it to binomialPDF which expects an Int.
12:05:22 <mjrosenb> _ is a somewhat standard suffix for "ignore the actual value, and return (); is there something similar for ignoring errors?
12:05:26 <byorgey> but later the outputs of loop are divided using /  which expects floating-point numeric types.
12:05:50 <byorgey> zed_: you have to pay careful attention to which variables are Ints and which are Doubles.  To convert from Int to Double you can use fromIntegreal.
12:05:53 <byorgey> *fromIntegral.
12:06:14 <byorgey> mjrosenb: no
12:06:39 <zed_> thanks, i'm looking at ti : )
12:07:59 <joneshf-laptop> are there any typesafe graph libraries that aren't a pain to use?
12:11:40 <monochrom> is FGL good enough? or is your whole point "no, FGL is bad"? :)
12:13:11 <zed_> byorgey: i'm just not sure to understand where the problem is... i don't think that the problem is with j, cause the error says : Actual type: (Double, Double, Int) 
12:13:31 <zed_> it seems that the error is in the esff
12:13:37 <zed_> as an argument.
12:14:14 <zed_> vid
12:14:37 <Falkyouall> hey guys i have a problem with mapping a function on my own datatype list ...
12:14:41 <Falkyouall> data Waitinglist a = Queue [a]  deriving (Show) 
12:14:41 <Falkyouall> applyOnList :: (a -> b) -> Waitinglist a -> Waitinglist b
12:14:41 <Falkyouall> applyOnList xs = map (\f -> f x) Queue xs
12:14:52 <joneshf-laptop> monochrom, yeah fgl blows up on me sometimes
12:15:48 <Falkyouall> actually it is \f -> f xs
12:16:15 <joneshf-laptop> Falkyouall, what error message are you getting?
12:16:38 <Falkyouall> Couldn't match expected type ‘(a -> b) -> Warteschlange a -> Warteschlange b’
12:17:04 <monochrom> joneshf-laptop: "Data.Graph" is part of "containers" and comes with GHC. does it have enough stuff?
12:17:05 <Falkyouall> i thought that would work as with every datatype...
12:17:43 <joneshf-laptop> Falkyouall, if you paste the whole code and error on lpaste, we can help point you in the right direction
12:17:46 <joneshf-laptop> @where lpaste
12:17:46 <lambdabot> http://lpaste.net/
12:18:16 * hackagebot ltext 0.0.1.1 - Higher-order file applicator  http://hackage.haskell.org/package/ltext-0.0.1.1 (athanclark)
12:18:18 * hackagebot github-webhook-handler 0.0.3 - GitHub WebHook Handler  http://hackage.haskell.org/package/github-webhook-handler-0.0.3 (wereHamster)
12:18:28 <joneshf-laptop> monochrom, i don't think so. I need to have labeled edges, plus it's a PITA to use.
12:20:02 <Falkyouall> http://lpaste.net/133655 thats mit code
12:21:00 <mauke> wow, that looks confused
12:22:19 <Falkyouall> actually i am
12:22:21 <MitchellSalad> Falkyouall: what's the type of map, and what are you applying it to?
12:23:00 <athan> Hey everyone, is there a tool for building .deb files for haskell executables?
12:23:10 <athan> (or .rpm, etc.?)
12:23:16 * hackagebot github-webhook-handler-snap 0.0.3 - GitHub WebHook Handler implementation for Snap  http://hackage.haskell.org/package/github-webhook-handler-snap-0.0.3 (wereHamster)
12:23:20 <mauke> Falkyouall: how many arguments is fanwenden supposed to take?
12:23:21 <Falkyouall> type of map is map :: (a -> b) -> [a] -> [b] 
12:23:57 <MitchellSalad> correct
12:24:00 <Falkyouall> it gonna takes a Queue
12:24:11 <MitchellSalad> but a Queue is not a [], right?
12:24:37 <Falkyouall> on which i want to apply the map.. so its just a Qeueue (Warteschlange in german^^) and a function
12:25:15 <Falkyouall> thats righht, my empty queue is just Queue []
12:25:23 <MitchellSalad> if you apply "map f" to a Queue you're going to get a type error
12:25:36 <MitchellSalad> you probably want to apply "map f" to the list inside of the Queue
12:25:41 <Falkyouall> whats your adavice on that ?
12:25:45 <Falkyouall> ahh
12:25:54 <Falkyouall> gonna try this
12:26:11 <nolraiVM> Is there a way to make a queue that is efficieant and doesn't use chan internally?
12:27:58 <mjrosenb> nolraiVM: a pair of lists is pretty efficent.
12:29:51 <sccrstud92> anyone here?
12:30:18 <nolraiVM> Yes?
12:30:36 <Falkyouall> my new approach was 
12:30:39 <athan> mope
12:30:40 <Falkyouall> fanwenden :: (a -> b) -> Warteschlange a -> Warteschlange b
12:30:40 <Falkyouall> fanwenden f xs = map Queue(f xs)
12:30:46 <athan> mcnope*
12:31:45 <samgd> Falkyouall: http://lpaste.net/133657
12:32:30 <Falkyouall> thanks smagd !!
12:32:57 <Falkyouall> do i need the functor to work?
12:34:01 <samgd> fanwenden is defining map on your Queue 
12:34:11 <Falkyouall> didnt dive that deep into functors yet...
12:34:36 <samgd> which (as I understand it) is essentially the same as the Functor class
12:34:39 <monochrom> Functor is shallow
12:34:41 <Falkyouall> ahh so i defined a own mapping instance for my datatype???
12:34:51 <Falkyouall> is this what functor does??
12:35:06 <Falkyouall> mind = blooown
12:35:07 <samgd> @i Functor
12:35:07 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect irc-password v @ ? .
12:35:23 <indiagreen> samgd: lambdabot does no :i
12:35:27 <samgd> :-(
12:35:38 <monochrom> @id hello
12:35:39 <lambdabot>  hello
12:35:47 <indiagreen> class Functor (f :: * -> *) where
12:35:48 <indiagreen>   fmap :: (a -> b) -> f a -> f b
12:35:48 <indiagreen>   (GHC.Base.<$) :: a -> f b -> f a
12:35:48 <indiagreen>   	-- Defined in ‘GHC.Base’
12:35:48 <indiagreen> instance Functor Maybe -- Defined in ‘Data.Maybe’
12:35:49 <indiagreen> instance Functor (Either a) -- Defined in ‘Data.Either’
12:35:49 <indiagreen> instance Functor [] -- Defined in ‘GHC.Base’
12:35:49 <indiagreen> instance Functor IO -- Defined in ‘GHC.Base’
12:35:50 <indiagreen> instance Functor ((->) r) -- Defined in ‘GHC.Base’
12:35:50 <indiagreen> instance Functor ((,) a) -- Defined in ‘GHC.Base’
12:36:06 <indiagreen> hello I'm your :i for today
12:37:04 <danharaj> does anyone here use nix and also has a public binary cache server that builds profiling versions of haskell packages?
12:37:56 <Falkyouall> soo thats a yes i guess^^
12:38:08 <Falkyouall> got it
12:40:39 <zaquest> > EQ `mappend` LT `mappend` GT
12:40:41 <lambdabot>  LT
12:41:39 <marcushg> hi
12:42:02 <c_wraith> > mzero :: Ordering
12:42:03 <lambdabot>      Couldn't match expected type ‘Ordering’ with actual type ‘m0 a0’
12:42:04 <lambdabot>      In the expression: mzero :: Ordering
12:42:12 <c_wraith> > mempty :: Ordering
12:42:14 <lambdabot>  EQ
12:42:29 <liste> wtf
12:42:34 <liste> why is Ordering a Monoid?
12:42:58 <zaquest> cool ha :D
12:42:58 <c_wraith> Sometimes it's useful.
12:43:39 <monochrom> it is related to lexicographcal ordering
12:43:42 <marcushg> why not?
12:43:45 <zaquest> was writing sort by multiple fields and thought how could i do it in haskell in a nice way, and boom!
12:43:50 <marcushg> yeah thats one example
12:44:21 <liste> cool
12:44:30 <byorgey> zed_: the problem is not with any specific variable.  The problem is that you need to convert from Int to Double in one or more places.
12:45:06 <zed_> byorgey: thanks. I understand that, but... I don't understand how I am supposed to convert an argument from Int to Double
12:45:22 <byorgey> zed_: you can convert from Int to Double using the fromIntegral function
12:45:53 <byorgey> i.e. if you have  some variable foo :: Int  but you need to pass it to a function which expects a Double, you can write   someFunc (fromIntegral foo) ...
12:46:03 <byorgey> instead of  someFunc foo   which will not type check
12:47:22 <ion> > sortBy (comparing snd <> comparing (length . fst)) [("foo", 0), ("bar", 1), ("a", 1), ("quux", 1), "b", 0)]  -- liste
12:47:24 <lambdabot>  <hint>:1:106: parse error on input ‘)’
12:47:29 <ion> > sortBy (comparing snd <> comparing (length . fst)) [("foo", 0), ("bar", 1), ("a", 1), ("quux", 1), ("b", 0)]
12:47:31 <lambdabot>  [("b",0),("foo",0),("a",1),("bar",1),("quux",1)]
12:48:18 * hackagebot pandoc-types 1.12.4.4 - Types for representing a structured document  http://hackage.haskell.org/package/pandoc-types-1.12.4.4 (JohnMacFarlane)
12:49:26 <zed_> byorgey: here's an update. code: http://lpaste.net/133647 error code : http://lpaste.net/133652
12:49:58 <zed_> i just don't understand which variable is an Int in the following error code : ( Actual type: (Double, Double, Int) ) 
12:50:46 <ion> zed: map fromIntegral [0..d]
12:51:14 <ion> d is Int but you seem to be using it as a Double
12:54:02 <zed_> ion: but I want to use it as Double
12:54:13 <zed_> i mean, Int
12:54:25 <c_wraith> You want to use it as both
12:54:33 <c_wraith> But it's one or the other.
12:55:02 <monochrom> we understand that at some places you want to use d as Int, and some other places Double
12:55:23 <monochrom> so keep d as Int. but where you use it as Double, add fromIntegral
12:55:25 <zed_> the thing is, I am just unsure as to where exactly its type is declared
12:55:26 <marcushg>  @zed_: just curious - making everything strict in line 23 - wouldn't it also make it strict in the next case (l 32)
12:55:45 <ronh-> zed at line 6
12:55:50 <monochrom> d comes from your Input record. and your Input record makes it Int.
12:56:13 <zed_> marcushg: maybe - i did not write the whole thing, it was generously written for me as an answer to another question i had.... so it's hard for me to answer : )
12:56:41 <marcushg> ah ok, nevermind, was just curious
12:57:34 <zed_> ok so the thing is, from what i understand i would need to change something in line 21 in order to use it as a double there...
12:57:46 <zed_> but if i do so, i will then need to rewrite binomialPDF
12:57:53 <ronh-> loop is not the best name for a fold's accumlating function
12:58:50 <ion> The objectively best name is “go”. 
12:59:15 <monochrom> zed_, ion has kindly and focusedly suggested you to replace "[0..d]" by "map fromIntegral [0..d]". have you even tried?
12:59:56 <zed_> well i had not seen it, sorry !
13:00:28 <zed_> i just tried and it doesn't seem to work...
13:00:50 <monochrom> you will also need parentheses. (map fromIntegral [0..d])
13:01:13 <ion> (The code probably has other type errors but that specific one might be handled by that change.)
13:01:29 <zed_> but I mean, wouldn't technically be that equivalent to just making d a Double right from the beginning ?
13:01:55 <monochrom> do you want d to be Double throughout?
13:02:09 <zed_> no
13:02:15 <zed_> I want it to be an Int
13:02:55 <monochrom> then "I want d to be an Int" is in conflict with "make d a Double from the beginning"
13:03:06 <zed_> monochrom: exactly...
13:03:08 <monochrom> all type errors are contradictions
13:03:18 * hackagebot ktx 0.1 - A binding for libktx from Khronos  http://hackage.haskell.org/package/ktx-0.1 (Corngood)
13:03:27 <monochrom> all type errors not noticed by a mind are contradictions in that mind
13:04:02 <ion> zed: You do “j * binomialPDF d j p”, the type of “binomialPDF d j p” is Double and (*) :: Double -> Double -> Double. You’ll need a fromIntegral at least for the j.
13:04:48 <ion> zed: This also conflicts with the outer fromIntegral you have on that line.
13:04:59 <ion> The parameter to that one is a Double.
13:05:16 <zed_> so if I do a Int * Double, it becomes an Int or a Double ?
13:05:24 <ion> It becomes a type error
13:05:45 <zed_> nice to knowt
13:05:46 <zed_> thanks
13:05:54 <ion> @type (undefined :: Int) * (undefined :: Double)
13:05:56 <lambdabot>     Couldn't match expected type ‘Int’ with actual type ‘Double’
13:05:56 <lambdabot>     In the second argument of ‘(*)’, namely ‘(undefined :: Double)’
13:05:56 <lambdabot>     In the expression: (undefined :: Int) * (undefined :: Double)
13:06:14 <ion> @type (*)
13:06:16 <lambdabot> Num a => a -> a -> a
13:06:42 <ubitux> sorry to interrupt; just a beginner q.: is there any reason having multiple predicates in a comprehension list over a single "complex" condition (that is, using a bunch of &&)?
13:06:44 <ion> Whether you set a = Int or a = Double in the type, both parameters must have the same type.
13:06:58 <kristof> ubitux: Readability
13:07:24 <kristof> ubitux: There's an implicit and logical operator between all those tiny predicates.
13:08:13 <ubitux> kristof: ok, thanks
13:10:50 <athan> Would anyone like to build the ltext executable for me on windows, and send a PR to my github with the exectuable? Or would that be sketchy? ;)
13:11:19 <monochrom> they allow consecutive predicates because it is the simplest thing to do for a simple grammar and a simple parser.
13:11:42 <monochrom> if they banned consecutive predicates, that is more work for both teachers and compiler writers, not less.
13:12:19 <ion> athan: You can get a free Windows™ VM from http://modern.ie/
13:13:17 <zed_> ion: i tried to rewrite that line:          , esff + (fromIntegral j) * binomialPDF d j p) 
13:13:19 * hackagebot dash-haskell 1.1.0.0 - Convert package Haddock to Dash docsets (IDE docs)  http://hackage.haskell.org/package/dash-haskell-1.1.0.0 (johnfeltz)
13:13:33 <zed_> but now I get the following error :     No instance for (Integral Double) arising from a use of ‘loop’ 
13:15:35 <arkeet> fromIntegral is for converting Int-like types to other number types
13:15:36 <arkeet> but you gave it a Double
13:15:55 <arkeet> probably you just want to remove fromIntegral
13:17:06 <athan> Thank you ion!!
13:17:40 <zed_> arkeet: I don't understand what makes it a Double now...
13:19:01 <arkeet> zed_: it might help to give loop an explicit type annotation
13:19:05 <arkeet> but I can see things like
13:19:12 <arkeet> fromIntegral (sommeProba + binomialPDF d j p)
13:19:18 <arkeet> binomialPDF has Double result type
13:19:25 <arkeet> therefore so does the thing in parentheses
13:19:29 <arkeet> so fromIntegral can't be used
13:19:43 <zed_> arkeet: but how do I give an explici type annotation in a way that will still allow me to use foldl ?
13:19:59 <arkeet> what type do you think loop should have?
13:20:32 <arkeet> in particular, what are the types of sommeProba, vaRff, esff, and j
13:21:20 <zed_> Double, Double, Double, Int
13:21:24 <zed_> in that order
13:21:31 <arkeet> ok
13:21:41 <zed_> so loop should be (Double, Double, Double) Int 
13:21:47 <arkeet> loop :: (Double, Double, Double) -> Int -> something
13:21:59 <arkeet> where something better be (Double, Double, Double) for it to fit in foldl'
13:22:10 <arkeet> so give it that type annotation
13:22:13 <arkeet> and then see what type error you get
13:22:43 <arkeet> :t foldl'
13:22:44 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
13:23:06 <ion> The b = (Double, Double, Double) and a = Int in this case
13:23:12 <arkeet> right.
13:23:42 <zed_> so that means that I need to create a function named loop that is independent from the code, right ?
13:23:53 <arkeet> no
13:23:58 <arkeet> you can put type annotations inside where
13:24:32 <arkeet> just put it above the definition of loop
13:24:34 <arkeet> with the same indentation
13:25:00 <prinsen> What's the current status of TH and cross compilation?
13:26:06 <zed_> arkeet: thanks !
13:28:12 <adek> I have an iterator, where value :: iterator -> a. Now, I have a group_iterator which is passed inner iterator. value :: group_iterator -> [a]. I also have aggregate_iterator which is passed inner iterator. value :: aggregate_iterator -> a
13:28:42 <adek> Is there a way to enforce that aggregate_iterator is always passed an iterator which has been groped by at least once?
13:28:51 <adek> At a type system level
13:29:44 <kristof> No, but you could do it at the function level
13:30:23 <kristof> Or, you could change the types slightly, so that an iterator that hasn't been groped at all is a freshIterator
13:30:45 <kristof> iterator :: iterator | freshIterator
13:32:40 <adek> kristof: I imagine there is some way because there is a constant # of iterators and so we can distinguish some canonical description of the iterator. Worst case is a list and we just walk it to see if types are fine and given iterator can be passed some other one
13:33:07 <adek> Provided that there are no loops, which can't be unrolled during compile time
13:33:16 <kristof> adek: *shrug*
13:33:49 <adek> kristof: its more a trivia question than something I would do to be fast :)
13:36:40 <ion> adek: You could have something along the lines of data GroupedBy = NotGroupedBy | GroupedBy; data Iterator :: GroupedBy -> * -> * where { AnyIterator :: a -> Iterator g a; GroupedByIterator :: a -> Iterator 'GroupedBy a }
13:36:50 <ion> adek: LANGUAGE DataKinds, GADTs
13:38:06 <adek> ion: "where { AnyIterator :: a -> Iterator g a; GroupedByIterator :: a -> Iterator 'GroupedBy a }" - its GADT or DataKinds part?
13:38:57 <ion> Hm, actually, this might not be the right thing to do. You’d want to constrain the g in the type of the function.
13:39:37 <ion> adek: data … where … is a GADT, the type 'GroupedBy is from DataKinds.
13:39:50 <adek> ion: yeah, i sort of want to annotate a type of iterator if it has been grouped by or not and compile time disable all paths which could lead to wrong type construction.
13:41:39 <ion> data GroupedBy = NotGroupedBy | GroupedBy; data Iterator (g :: GroupedBy) a = Iterator a; foo :: Iterator g A -> B; bar :: Iterator 'GroupedBy A -> B
13:42:09 <ion> foo does not constrain the “grouped by” status, bar requires it to be GroupedBy
13:42:45 <adek> ion: let me parse it for a moment
13:44:02 <nak> How can Eq automatically generate instances for things like: 
13:44:05 <nak> data Cat = Cat { catAge :: Integer, catName :: [Char] } deriving (Eq, Ord, Show)
13:44:08 <adek> ion: so you add a phantom type to annotate whether Iterator was grouped by?
13:44:30 <nak> what does that (==) function look like for Cat 
13:44:37 <ion> adek: yeah
13:45:13 <nak> x == y = (catAge x) == (catAge y) && (catName x) == (catName y) 
13:45:14 <nak> ??
13:45:20 <sydneyhacker> nak: Integer has ==, [a] has ==, Char has ==
13:45:28 <Philonous> nak, Yes
13:45:54 <Philonous> At least it's equivalent to your function 
13:46:21 <ion> adek: Without DataKinds: data NotGroupedBy; data GroupedBy; data Iterator g a = Iterator a; foo :: Iterator g A -> B; bar :: Iterator GroupedBy A -> B. DataKinds makes it a bit nicer by making sure “g” is either 'NotGroupedBy or 'GroupedBy instead of any type in the universe.
13:46:21 <adek> ion: so now I need some sort of smart constructors which would add/remove groupby type if I want to start wrapping iterator one in another
13:46:47 <nak> sydneyhacker, Philonous, could we write our own type class as smart as Eq that would have the same behavior ?
13:46:54 <sydneyhacker> does anyone have experience with doctest? specifically running quickcheck properties with it?
13:47:24 <nolrai66> nak: Look at generics.
13:47:30 <Philonous> nak, -ddump-deriv if you want to look at the code that ghc actually generates 
13:47:45 <nak> Philonous ??
13:47:48 <nak> Philonous where do i run that
13:47:59 <Philonous> ghc -dump-deriv yourcode.hs 
13:48:13 <Philonous> If you're in ghc, :set -ddump-deriv 
13:48:21 <Philonous> in ghci
13:48:32 <adek> ion: wrapVanilla :: Iterator g A -> Iterator g A; groupBy :: Iterator g A -> Iterator GroupedBy A - would this work?
13:48:37 <Philonous> Sorry, typo: ghc -ddump-deriv yourcode.hs 
13:49:06 <nak> thans
13:49:07 <nak> thanks
13:49:26 <nak> Philonous how to unset a flag in ghci ?
13:50:07 <Philonous> nak, I'm not sure what you mean by your question. You can write the Eq instance by hand, sure. Most Eq instances just are very predictable and boring, so you can derive them. If you want something more fancy, i.e. == being another equivalence you have to implement it yourself
13:50:28 <Philonous> nak, You can,t at least not for -ddump-deriv, you have to restart ghci
13:50:57 <Philonous> another equivalence relation, I mean
13:51:10 <ion> adek: Probably
13:52:11 <nak> Philonous ok
13:52:19 <nak> Philonous the -ddump-deriv is very helpful
13:52:26 <nak> the output is very close to what i was expecting
13:53:10 <nak> will ghc warn me if i try `... deriving Eq` and it can't automatically generate the functions ?
13:53:29 <Philonous> nak, It will actually throw an error.
13:53:29 <ion> That will be an error.
13:53:35 <nak> ok cool
13:53:54 <nak> sorry again if any of this sounds stupid
13:54:03 <nak> i'm just a couple weeks in. learning typeclasses today ^.^
13:59:23 <dvindigo> http://lpaste.net/133665
13:59:49 <dvindigo> does this function already exist? or can it be more easily defined?
14:00:43 <indiagreen> dvindigo: I'm not sure, but it looks like you're reinventing MonadT
14:00:46 <indiagreen> * MaybeT
14:03:32 <dvindigo> indiagreen: I'll look into that. thanks
14:03:35 <SrPx> Is there any way to model graphs on Haskell in a way that allows me to write Lens?
14:04:17 <MitchellSalad> that's not really MaybeT
14:04:28 <MitchellSalad> MaybeT m a ~ m (Maybe a)
14:04:34 <MitchellSalad> not Maybe (m a)
14:05:02 <MitchellSalad> foo = fromMaybe (return Nothing), I think
14:05:29 <MitchellSalad> no, no it's not
14:06:03 <MitchellSalad> foo mt f = maybe f (return Nothing) mt
14:06:25 <indiagreen> different order, I think
14:06:27 <indiagreen> “maybe (return Nothing) f mt”
14:06:33 <MitchellSalad> yeah
14:06:34 <nolrai66> SrPx: wot?
14:07:36 <SrPx> nolrai66: It is easy enough to create lens for ADTs since they represent trees and there are no cycles.
14:07:46 <rui3> anyone used dash-haskell?
14:08:16 <nocturne777> does anyone use snap framework here ?
14:08:36 <rui3> First attempt: tried generating the docs for a cabal package and ended up with the docs for all dependencies but not for the package
14:08:49 <SrPx> I wonder if one could create lens for a graphical data structure, such as "cycle = 1 : 2 : cycle"
14:09:04 <merijn> nocturne777: Probably...you're better of just asking your question :)
14:09:40 <nocturne777> I do not understand how writeBS here actually compiles: http://snapframework.com/docs/tutorials/snap-api
14:09:48 <nocturne777> writeBS expects a ByteString
14:10:00 <nocturne777> what it is provided with with is String
14:10:06 <ion> nocturne777: LANGUAGE OverloadedStrings
14:10:32 <nolrai66> SrPx: Why would that be a problem?
14:10:40 <nocturne777> ion: you are right, it sits at the top of the file
14:10:45 <prinsen> What's the current status of TH and cross compilation?
14:10:52 <SrPx> actually, nevermind - I think I just have the answer to an old Reddit thread.
14:11:04 <merijn> prinsen: Not working and several experimental hacks around?
14:11:16 <adek> ion: but I guess I can't really enforce much this way if I get a string which I need to parse and construct iterator tree. Basically the idea is that my code at compile cannot lead to a situation where I would construct invalid iterator tree
14:11:19 <prinsen> merijn: No light in sight?
14:12:17 <prinsen> merijn: I want to release libraries (java/python) that uses haskell via FFI underneath, and want to release pre-built binaries. Might set up a VM farm
14:12:26 <dvindigo> MitchellSalad, indiagreen: thanks, that seems to work :)
14:13:31 <merijn> prinsen: luite had some ideas for ghcjs, but I dunno how tested and polished that is
14:14:05 <merijn> prinsen: If you wanna distirbute binaries building in a vm is almost certainly a less painful option than crosscompiling
14:14:10 <merijn> prinsen: Even if you don't use TH
14:15:39 <tgg125> when using Gloss, when I hit the ESC key, what happens to my program execution? it just closes the gloss window and goes to the next statement in main?
14:16:02 <tgg125> supposing I have main = do <gloss stuff> ; <some other stuff>
14:19:26 <prinsen> merijn: a second question. Is it possible/preferrable to create a completely static library (with GHC runtime statically linked with all its dependencies)?
14:21:53 <hexagoxel> rui3: did you `cabal haddock` ?
14:23:19 <joneshf-laptop> why doesn't `[(a, [a])] -> Tree a` exist?
14:23:21 <rui3> hexagoxel: No
14:23:23 <rui3> :)
14:23:36 <joneshf-laptop> Does anyone actually use containers
14:24:22 <mzero> uhm... is that a trick question?
14:24:46 <joneshf-laptop> just a frustrated question
14:24:48 <monochrom> I use containers all the time, e.g., Data.Set
14:25:11 <mzero> I use both containers and unordered-containers
14:25:13 <geekosaur> packdeps.haskellers.com shows 2814 dependents
14:25:20 <joneshf-laptop> i'm greatly frustrated with how featureless `Data.Graph` and `Data.Tree` are
14:25:32 <mzero> AH - those -
14:25:42 <mzero> yes, the orphan step-types in containers
14:26:04 <mzero> most people forget they are even in there
14:26:32 <zed_> i'm about to leave for now, but I wanted to thank everyone for their help with the code I am working on - it is really appreciated ! it is compiling, I still need to check if it does what I want it to do... ! thanks again !
14:26:46 <monochrom> the nature of volunteer work
14:29:06 <monochrom> in an alternate universe, tibbe works in a company that uses trees but never sets and maps. therefore, Data.Tree there is a rich and highly optimized library, while Data.Set and Data.Map stay unfinished and inefficient
14:29:23 <joneshf-laptop> yeah, i'm not suggesting that anyone is to blame
14:29:27 <osa1> is anyone maintaining haskell-src-exts?
14:30:07 <joneshf-laptop> just frustrated that i can go grab a zygohistoprepromorphism off the shelf, but working with trees makes me want to gouge my eyes out
14:30:46 <pharaun> joneshf-laptop: could probably improve the tree stuff then contribute upstream
14:30:51 <pharaun> most folks are super welcoming of patches
14:30:57 <pharaun> i have sent upstream a few
14:31:38 <pharaun> often what i do in projects is have a "util/patch" that adds in all of the stuff i would need from a lib
14:31:47 <pharaun> then after a while if its a good idea i'll take that and upstream it
14:32:46 <merijn> prinsen: Is it possible? Yes, linking in the GHC runtime with the rest requires a bit more effort, but still fairly easy
14:32:53 <archblob> oh, looking at it now, Data.Tree is really poor
14:34:11 <joneshf-laptop> pharaun, i will when i have time to find out what the contribution workflow is
14:34:13 <merijn> I think that's mostly because for most scenarios just defining a custom tree is easy enough that no one bothers with a library
14:34:15 <archblob> joneshf-laptop, can you give an example of what you would like in Data.Tree ?
14:35:05 <pharaun> joneshf-laptop: sure, fwiw the libs on github i've found the easiest to contribute, code up, then submit a merge reqeust
14:35:07 <hiptobecubic> When you see a really magical looking implementation of something, what approach do you typically use to try to figure out how the $#@% it could possibly work? I was working on counting the number of partitions of a natural number. I eventually got it by looking up the generalized pentagonal numbers and doing a pretty convoluted feeling fixed point memoization thing, but I'm looking at other people's
14:35:09 <hiptobecubic> solutions and I just don't know how one could possibly arrive at them: http://lpaste.net/133666
14:35:15 <pharaun> for the other libs, you can usually email them the patch
14:36:00 <joneshf-laptop> archblob, `[(a, [a])] -> Tree a` would be nice
14:36:26 <joneshf-laptop> archblob, some ways to create trees, insert values, delete, etc
14:36:47 <refefer> without the unfolding api?
14:37:32 <archblob> joneshf-laptop, the reason I ask is because I'll have some free time and if you have a clear idea of what you want I can help out and make it happen :)
14:37:36 <hiptobecubic> For contrast, this is what I eventually had: http://lpaste.net/133667
14:39:13 <hiptobecubic> And sure, I'm not a Haskell pro, but it's not like the other, way more beautiful looking solution does anything that isn't Haskell 98. I just don't know how someone would arrive at such a thing
14:39:27 <pharaun> hiptobecubic: often its an iterative process
14:39:30 <pharaun> i code a super specific solution
14:39:40 <pharaun> then i go, oh i probably can make this bit here more generic, tweak tweak
14:39:51 <pharaun> repeat till i arrive at something... i guess amaze
14:40:28 <hiptobecubic> pharaun, suppose this was code review and you were supposed to verify that http://lpaste.net/133666 should work correctly. How would you?
14:41:13 <pharaun> the partition bit? i would typically use quickcheck
14:41:14 <monochrom> code review is different from personal learning
14:41:20 <pharaun> and setup properties to assert
14:41:24 <sm> archblob, joneshf-laptop: https://github.com/simonmichael/hledger/blob/master/hledger-lib/Hledger/Utils.hs#L266 has a few ideas for tree helpers
14:41:34 <pharaun> but yeah sometime just gotta sit down and think it though
14:41:39 <pharaun> also what monochrom said
14:41:45 <monochrom> at code review, you get to tell the author "not enough comments", "where is your proof of correctness?"
14:42:32 <monochrom> you can totally reject a totally correct program on the slight pretext of "missing proof"
14:42:37 <hiptobecubic> monochrom, sure. Agreed. Bad example. Suppose you in charge of auditing this then. Or inherited it from some coder that quit
14:42:44 <pharaun> also i tend to take apart small bits of code
14:42:45 <hiptobecubic> you were*
14:42:49 <pharaun> test/play/iterate on it
14:42:55 <pharaun> then repeat till i understand the whole bit
14:42:59 <archblob> sm, that's a start
14:43:13 <pharaun> sm: nice!
14:43:23 <pharaun> that's the approach i usually take - util/etc then upstream it
14:43:31 <sm> thx!
14:44:09 <monochrom> for personal learning, I would buy and read "The Little Prover", and also learn a lot of math since this is about counting partitions, a pretty difficult topic in combinatorics
14:44:28 <monochrom> and I would still blame the author for not writing down the proof of correctness.
14:44:52 <mauke> hiptobecubic: just from looking at the code, I wonder if you can omit the n' in [1..n']
14:45:47 <hiptobecubic> mauke, you cannot.
14:45:52 <hiptobecubic> mauke, diverges
14:46:23 <osa1> does anyone know a package to convert wl-pprint Doc to pretty's Doc?
14:52:09 * sm notes that Data.Tree enhancements happen via the libraries list, https://github.com/haskell/containers/pull/140
14:52:55 <pharaun> ooh its on github sweet
14:53:02 <pharaun> those are super easy (imo) to contribute to
14:53:23 <pharaun> ahh mailing list?
14:53:40 <sm> yeah, this one you start on the list and later move to github
14:53:46 <pharaun> argh, i'm not a fan of mailing list myself
14:53:52 <archblob> libraries@haskell.org
14:54:27 <pharaun> at least it has detailed guidelines
14:54:29 <pharaun> guidelines are great
14:54:31 <joneshf-laptop> refefer, in addition to the unfolding stuff.
14:54:35 <sm> yup, once you find them
14:54:54 <joneshf-laptop> refefer, i can make most of this stuff work with the unfolding stuff, but i imagine it'd be helpful for others as well.
14:55:03 <pharaun> OH container is in core libs
14:55:08 <pharaun> ok that makes more sense
14:55:23 <archblob> it would be
14:55:35 <joneshf-laptop> archblob, nice
14:55:41 <joneshf-laptop> sm thanks
14:55:54 <thegladiator> clear
14:56:52 <joneshf-laptop> yeah, contributing through ml first then github is not TERRIBLE, but no time for that at the moment unfortunately :\
14:57:34 <naudiz> the word arch is way to close to the German word "Arsch" (meaning arse)... I misread it every time
14:59:24 <pharaun> hah
14:59:31 <pharaun> naudiz: you must like archlinux then :P
15:00:23 <archblob> joneshf-laptop, I have time and if you can take a little time and make a list of what you think is useful I and make it happen :-P
15:00:39 <mauke> naudiz: Architekt, archaisch, Arche
15:00:40 <refefer> geez, a simple install dependencies and my fresh project is now half a gb in size
15:01:00 <naudiz> pharaun: actually, I don't like it at all :D
15:01:12 <pharaun> hehe you don't notice it as much with c/other languages, base os usually got it
15:01:15 <pharaun> naudiz: hehe
15:02:01 <naudiz> mauke: the word "Arsch" comes into my mind way more often... this might tell some things about me, I guess
15:02:46 <mauke> Archimedes, Archäopteryx, Archilochos
15:06:22 <nolraiU> So whats a good way to get a minimal haskell install for using sandboxes?
15:06:52 <athan> ltext.github.io <- get it while it's hot!
15:09:48 <benzrf> athan: snazzy
15:12:28 <athan> benzrf: :)
15:12:43 <athan> needs hott sauce
15:12:53 <haskets> :i Ordering
15:13:40 <benzrf> athan: oooh i think i see how this works
15:13:51 <benzrf> nifty
15:15:10 <athan> :i Ord -- haskets
15:15:14 <athan> ?
15:15:18 <athan> benzrf: Thanks :)
15:15:24 <haskets> yeah that seems right
15:15:26 <haskets> :i Ord
15:15:30 <athan> @info Ord
15:15:30 <lambdabot> Ord
15:15:35 <haskets> @i Ord
15:15:35 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect irc-password v @ ? .
15:15:40 <benzrf> info is "corrected" to undo by lambdabot
15:15:44 <benzrf> @info do x <- y; z
15:15:44 <lambdabot> y >>= \ x -> z
15:15:56 <benzrf> athan: wait
15:15:59 <haskets> lol that's fine
15:16:05 <haskets> i just ghci'd it
15:16:12 <benzrf> does ltext have a lambda calc implementation in it or does it compile your templates to haskell
15:16:20 <benzrf> because the latter seems more useful to me :)
15:18:20 <athan> benzrf: It's got an implementation :\
15:18:27 * hackagebot ktx 0.2 - A binding for libktx from Khronos  http://hackage.haskell.org/package/ktx-0.2 (Corngood)
15:18:33 <benzrf> aw
15:18:34 <athan> But the parser is pretty standard! Just import LText.Parser.Document :)
15:18:41 <benzrf> b-but
15:18:46 <benzrf> i was thinking of doing things like
15:19:17 <benzrf> $ ltext "map foo (words \"this that other\")"
15:23:56 <athan> benzrf: hmm
15:24:21 <athan> benzrf: I don't want data types in my system, that's the only issue
15:24:40 <benzrf> why not?
15:24:52 <athan> I feel like I could make a typeclass to turn my syntax tree into a haskell function, though
15:24:59 <athan> benzrf: Well, because that would be way too hard lol
15:25:05 <athan> and beyond the use-case of this
15:25:25 <athan> plus, ghc already has all of that implemented :\
15:26:13 <benzrf> no, athan
15:26:17 <benzrf> i meant compile the templates to haskell
15:26:38 <athan> benzrf: Oh! Then yes, I'll implement that :)
15:26:38 <benzrf> generate a scope or whatever its called with functions compiled from the files
15:26:45 <benzrf> sweet :D
15:26:48 <benzrf> downside:
15:26:58 <benzrf> non-saturated applications will not be printable
15:27:07 <athan> I disagree
15:27:12 <benzrf> ?
15:27:22 <athan> check out the partial application section
15:27:37 <athan> there are some partially applied functions that won't be printable
15:27:45 <athan> (idk if this is what you were thinking of)
15:28:05 <athan> but, if <> or literals aren't in the top-level, strictly, then they won't be printable
15:28:17 <athan> for instance, if you use the `apply` file
15:28:26 <athan> try `(\f -> apply f) bar`
15:29:14 <athan> - literals then reside within a function application - or more put, a file's content still hasn't found it's way to the top-level, which you can't render
15:29:42 <athan> so there's some things you can do, but not everything :\
15:31:59 <athan> benzrf: Is that what you mean by saturated?
15:33:40 <matheus23> hi guys I've got a question about lazy evaluation in combination with threading
15:36:24 <matheus23> (/concurrency) What If I had one thread putting stuff into some kind of threadsafe storage (MVar, TVar, whatever) and another thread that reads, say, every second one of those values. Are every values stored inside the *Var's evaluated?
15:36:57 <benzrf> er, hold on
15:37:12 <geekosaur> if you put a thunk, a thunk will be read.
15:37:32 <matheus23> what is a thunk, what can I put instead of a thunk?
15:38:09 <geekosaur> an unevaluated expression
15:38:18 <benzrf> athan: im not sure
15:38:26 <benzrf> athan: by saturated i mean that the type is not a function type
15:38:34 <geekosaur> effectively, a closure that when forced will produce a value
15:39:09 <matheus23> geekosaur: ... so what If I put IO actions into the *Var's. When and how much of these will be executed?
15:39:38 <nolrai666> Never?
15:39:42 <geekosaur> when sequenced into an IO action that leads back to main, like any other IO action
15:40:00 <geekosaur> (and only when so sequenced; if you discard it, it won't ever do anything)
15:40:09 <matheus23> ok that is nice
15:41:25 <Cale> matheus23: It's important to understand the difference between evaluation (reducing expressions to values for the purposes of pattern matching), and execution (carrying out the instructions described by IO action values and causing their effects to occur)
15:42:04 <Cale> matheus23: These are two almost entirely separate things (apart from the fact that IO action expressions must be evaluated in order to execute)
15:42:38 <matheus23> my plan is strange, but... i think it's fine: I want a window with graphics responding to user events (Mouse, Keyboard, Ticks). These events might come more often than rendering is needed. But these Produce Cairo.Render () and store them somewhere, while on another thread they are going to be consumed at 60fps (if needed), maybe skipping some uneeded ones. And it'll only do much work for needed computations
15:42:45 <matheus23> that's my plan. Does that work?
15:43:29 * hackagebot xcffib 0.2.4 - A cffi-based python binding for X  http://hackage.haskell.org/package/xcffib-0.2.4 (TychoAndersen)
15:43:45 <matheus23> Cairo.Render is a MonadIO
15:44:40 <Cale> If you don't execute the rendering actions, then you don't pay for their execution, but you may or may not pay for the evaluation of which action they are, depending on the precise details of your program (there's a decent chance you won't pay for that either)
15:46:45 <matheus23> soo.. if for example, the Cairo.Render () action is dependent on the mouse position (+ some computation around it). And in the end I put this Cairo.Render () action into a *Var, but never execute it. What was executed in the first place? Nothing? the "computation around it"?
15:47:04 <Cale> Nothing.
15:47:11 <matheus23> I mean... The Cairo.Render () action, or, IO () actions generally "magically" story information
15:47:17 <Cale> hm?
15:48:10 <matheus23> For example: If I produce IO () actions, containing a putStrLn *text-that-is-computed*. Where is that text evaluated?
15:48:18 <Cale> Writing something to an MVar or an IORef also doesn't even cause evaluation, but it certainly doesn't cause execution of actions.
15:48:29 * hackagebot xcffib 0.3.0 - A cffi-based python binding for X  http://hackage.haskell.org/package/xcffib-0.3.0 (TychoAndersen)
15:48:50 <Cale> The expression for the text will be evaluated when the putStrLn action is executed.
15:49:04 <matheus23> oh btw. If I produce that IO () action in one thread, but _execute_ it in another, in which thread will the "text-that-is-computed" be computed?
15:49:18 <Cale> > putStrLn undefined `seq` ()
15:49:20 <lambdabot>  ()
15:49:43 <Cale> ^^ evaluating the result here doesn't cause the undefined to throw an exception
15:49:52 <Cale> (so we know it didn't get evaluated)
15:50:10 <matheus23> ok ... that'd mean that computation ment for the event thread would be computed in the rendering thread, which I dont want....
15:51:10 <matheus23> well... Thank you _very_ much for your help Cale :)
15:51:14 <Cale> no problem :)
15:51:31 <matheus23> you cleared some things up :) (thanks to geekosaur too :))
15:52:06 <geekosaur> that was what I was implying by the "put a thunk, get a thunk" --- it will be forced by the receiver, not the sender
15:57:23 <hiptobecubic> @src foldr
15:57:23 <lambdabot> foldr f z []     = z
15:57:23 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:00:26 <maerwald> @src foldl
16:00:26 <lambdabot> foldl f z []     = z
16:00:27 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:01:26 <naudiz> @src foldl'
16:01:26 <lambdabot> foldl' f a []     = a
16:01:26 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
16:01:34 <maerwald> fascinating
16:02:12 <hiptobecubic> maerwald, you can also /query lambdabot 
16:03:17 <maerwald> hiptobecubic: yes, I know
16:03:53 <monochrom> you can combine "evaluate" (Control.Exception) and "rnf" (Data.DeepSeq) to force evaluation in a thread.
16:04:41 <monochrom> "evaluate" because it's in IO and it happens here-and-now (therefore in the "current" thread)
16:04:57 <monochrom> "rnf" because it walks the whole string
16:17:09 <Gurkenglas> After these last few edits, I feel like I'm onto something here. What do you think on the viability of this way to rewrite the instance system to allow multiple instances per type? http://www.reddit.com/r/haskell/comments/37tp2c/what_i_found_inconvenient_in_haskell/crr9pyc
16:18:30 * hackagebot dash-haskell 1.1.0.1 - Convert package Haddock to Dash docsets (IDE docs)  http://hackage.haskell.org/package/dash-haskell-1.1.0.1 (johnfeltz)
16:18:56 <Imagine> I have a question -- 
16:19:05 <Imagine> In ghci, if I do let s = flip subtract
16:19:12 <Imagine> then do :t s, I get Integer -> Integer -> Integer
16:19:21 <Imagine> yet :t flip subtract is Num a => a -> a -> a
16:19:35 <arkeet> that is because of the monomorphism restriction
16:19:54 <arkeet> I believe that's disabled in recent versions of ghci 
16:20:05 <arkeet> you can disable it with :set -XNoMonomorphismRestrictoin
16:20:09 <arkeet> :set -XNoMonomorphismRestriction
16:20:16 <Imagine> what does it do?
16:20:22 <Imagine> (like what are its benefits/drawbacks?)
16:20:27 <arkeet> https://wiki.haskell.org/Monomorphism_restriction
16:20:33 <Imagine> ooh okay
16:32:58 <Imagine> Okay - design question - suppose I want to implement a graph of points in R^n (where I have points and and edges). - My initial reaction here would be to enumerate each point and then use Data.Graph, so I'd be storing a graph and then a Data.Map for going from keys to points? 
16:33:10 <Imagine> Is that the "right" or at least a "good" way to do it?
16:36:32 <rasen> Hey, guys! Is there a name for \x y f -> zipWith f x y ? 
16:38:06 <bitemyapp> Imagine: I've seen Map of vector, fgl, Data.Graph, mutable graphs.
16:38:27 <Imagine> Is Data.Graph not mutable?
16:39:14 <bitemyapp> Table a is an Array under the hood which is immutable.
16:39:28 <bitemyapp> there are mutable versions out there.
16:41:02 <Imagine> awesome thanks
16:41:04 <Imagine> I'll look into them
16:41:58 <bitemyapp> Imagine: protip: graphs are a bit awkward to express in the traditional manner in functional langs, we tend to like things that look like trees. In order to get sharing with a persistent representation, you end up making the graph look like...a tree.
16:42:06 <bitemyapp> Imagine: this'll work great in some cases, in others, not.
16:43:10 <Imagine> Hmmm 
16:43:14 <athan> bitemyapp: o/
16:43:31 <Imagine> is there a general guideline like when it would work well/when it won't?
16:43:36 <Imagine> or is it just "try it and see?"
16:43:40 <athan> Imagine: Think about it - where would you start from? With a tree, you always start from the root
16:44:07 <Imagine> right
16:44:13 <Imagine> gotcha
16:44:13 <Imagine> okay
16:44:21 <Imagine> so I think in my case it would work well
16:44:34 <Imagine> maybe I want a tree, not a graph, after all
16:44:43 <athan> :)
16:44:54 <athan> Imagine: Are you familiar with rose trees?
16:45:17 <Imagine> I don't think so
16:45:19 <Imagine> at least not by that name
16:45:37 <Imagine> I'm not familiar with most functional programming things
16:45:39 <athan> data RTree a = More a [RTree a]
16:46:16 <Imagine> What does that accomplish? (What is More?)
16:46:43 <athan> Imagine: So you can think of it this way - `More` is a node in the tree, with a (possibly empty) set of sub-nodes
16:46:54 <bitemyapp> athan: howdy
16:47:08 <athan> it models the syntax of XML, for one thing
16:47:20 <bitemyapp> Imagine: you've almost certainly used a Rose Tree outside of FP.
16:47:20 <athan> bitemyapp: I finally got it done v.v
16:47:28 <bitemyapp> Imagine: super common (like XML, as athan mentioned)
16:47:42 <bitemyapp> they probably just didn't *tell* you what you were looking at :)
16:47:53 <bitemyapp> athan: I saw that. Very pretty site design, did you do that?
16:47:54 <Imagine> Probably then yeah, I just haven't heard it referred to it as that
16:48:27 <athan> bitemyapp: yep :) semantic-ui is awesome
16:48:30 <Imagine> and hmm okay 
16:48:43 <bitemyapp> Imagine: you can just think, "n-ary tree" (0 or more) when you hear Rose Tree and you've got it.
16:49:11 <bitemyapp> athan: oh wow, I hadn't seen this before.
16:49:19 <bitemyapp> athan: I'm an old fogey, I still use foundation CSS :P
16:50:00 <athan> bitemyapp: psh, nuh uh you just gotta know the right tools :) That's what i used before I heard about it
16:50:05 <Imagine> oh okay yeah
16:50:08 <athan> bitemyapp: dude check out google material design
16:50:30 <athan> bitemyapp: and also polymer - a web implementation of it that's very performant - nearly native on android devices
16:50:32 <Imagine> Wait for Rose Tree is it a set n, or can it expand on the fly?
16:50:42 <bitemyapp> Imagine: it's literally a list.
16:50:46 <athan> Imagine: It can expand
16:50:49 <Imagine> oh
16:50:50 <Imagine> okay
16:50:50 <Imagine> yes
16:50:52 <bitemyapp> each layer is a list, so it can be whatever
16:50:59 <Imagine> that makes it easy
16:51:08 <bitemyapp> this means there's relatively little you can assume about the structure and balancing of the tree
16:51:12 <athan> More "a" [More "b" [], More "c"]  is something like "ab","ac"
16:51:17 <bitemyapp> but it's needed to express some things.
16:51:25 <athan> erm More "c" []
16:51:31 <bitemyapp> athan: jah types.
16:51:35 <Imagine> yep, like paths and such
16:51:47 <athan> ire mon ~.~
16:51:50 <Imagine> in which case rebalancing doesn't make much sense to begin with (if you're dealing with a path)
16:51:50 <bitemyapp> athan: oh right, I'd seen this posted when it first came out but didn't have a clear "take-away"
16:52:04 <bitemyapp> athan: zats vy vee haf a typechekurr.
16:52:05 <athan> bitemyapp: The spec is crazy detailed
16:52:22 <bitemyapp> athan: probably so their product teams stop putting out eyesores, haha
16:52:35 <athan> :x
16:52:46 <bitemyapp> oh pish, I'm not the first to say as much.
16:53:00 <athan> Imagine: You're right :)
16:53:17 <athan> bitemyapp: I... I can feel google staring at me p_p
16:53:18 <bitemyapp> Imagine: yeah it's about expressiveness rather than predictable allocation
17:01:42 <hiptobecubic> polymer is pretty sexy
17:01:48 <athan> right?!?!
17:01:53 <athan> totes bangin'
17:02:01 * athan should stop, but can't o_o
17:04:51 <Zemyla> is there any way to get LibFFI to work on Windows?
17:05:38 <bitemyapp> athan: can't stop; won't stop.
17:05:50 <bitemyapp> Zemyla: "any" leaves a pretty big opening
17:06:11 <athan> lol
17:06:18 <Zemyla> Okay, so let me be more specific.
17:06:58 <bitemyapp> "any" includes, "refashion the entire software ecosystem in your own image through the use of hierarchically directed sub-teams of crack programmers"
17:07:15 <bitemyapp> I, for one, welcome our ZemylaOS Overlords.
17:07:28 <athan> bitemyapp++
17:07:50 <Zemyla> Right. I don't have those. :V
17:08:00 <bitemyapp> Zemyla: SOON (tm)
17:09:25 <Zemyla> Anyways, I had to compile libffi myself, using the Haskell C compilers and bintools, and installed them in a folder. Let's say it was C:\Haskell.
17:09:56 <bitemyapp> Zemyla: this thingy? http://hackage.haskell.org/package/libffi
17:10:07 <bitemyapp> http://hackage.haskell.org/package/bindings-libffi or this one?
17:10:15 <Zemyla> bitemyapp: The first one.
17:10:34 <pacak> How about using proper OS?
17:10:49 <bitemyapp> pacak: do you get off on being unhelpful?
17:10:59 <bitemyapp> pacak: go brew up some chamomile tea and have a think in the corner.
17:11:19 <Zemyla> Well, the thing I installed was the C libffi library, to produce the include and .a and .dll files.
17:11:56 <bitemyapp> Zemyla: problem is, I don't know systems.
17:12:04 <Zemyla> I then cabal installed the libffi library, with extra-include-dirs set to c:\Haskell\include and extra-lib-dirs set to c:\Haskell\lib.
17:12:12 <bitemyapp> Zemyla: it's possible you'd have to ifdef it up to make it work intercompatibly with Windows/*nix
17:12:33 <bitemyapp> Zemyla: the hackage package is from 2009, you're probably starting from (close to) scratch.
17:12:52 <Zemyla> I get the error "GHCi runtime linker: fatal error: I found a duplicate definition for symbol ffi_prep_cif".
17:13:03 <bitemyapp> if you know libffi-the-C-library to work on Windows, it might (might) just be a matter of making bindings.
17:13:07 <bitemyapp> but I am not an expert on windows or C bindings.
17:13:20 <bitemyapp> be nice if there was a #haskell-windows
17:13:22 <Zemyla> Which makes me think that it's somehow conflicting with the libffi that's statically compiled into ghc.exe.
17:13:33 <subleq__> I'm trying to convert an untyped AST into a typed GADT but I can't figure out the type of the typecheck function. I've got it working where you use a different function for each type in the GADT: http://lpaste.net/133669, but I actually want something that works for all types, like UTerm -> Maybe (TTerm a)
17:15:56 <Zemyla> bitemyapp: Okay, it doesn't crash anymore. I had to have it loaded as a DLL.
17:16:14 <bitemyapp> Zemyla: oh good!
17:16:17 <bitemyapp> Zemyla: how do you do that, anyway?
17:19:01 <Zemyla> I had the DLL in the extra-lib-dir, named ffi.dll.
17:19:10 <Zemyla> I don't know if it works at all yet, but I'm hopeful to find out.
17:20:19 <bitemyapp> ahhh okay.
17:20:21 <bitemyapp> Zemyla: thanks
17:23:41 <manny-> why are some packages putting arbitrary upper-bound version limits for packages they depend on? versions that dont even exist yet
17:23:43 <athan> woo! #1 on reddit/r/haskell! :D
17:24:23 <geekosaur> because we've had too many instances of new-version-of-dependency-comes-out-and-entire-ecosystem-breaks
17:24:53 <c_wraith> manny-: depends.  Is it an upper bound based on the PVP, or an upper bound based on overconfidence?
17:24:54 <manny-> and is there a way for cabal to ignore those versions and try to build anyway?
17:25:03 <geekosaur> --allow-newer=thing
17:25:16 <Axman6> manny-: It's usually sensible to put an upper bound on the next major version, since that's when API changes should occur
17:25:21 <bitemyapp> manny-: semver'ish.
17:25:21 <athan> ion: modern.ie is only 32-bit Windows (tm) though :\
17:25:27 <bitemyapp> athan: congrats :)
17:25:31 <manny-> geekosaur: so "always breaks" is better than "sometimes breaks"?
17:25:38 <athan> bitemyapp: :) thanks
17:25:51 <geekosaur> manny-, you haven't lived through one of thenm
17:26:13 <geekosaur> particular-thing-breaks is better than EVERY FREAKING THING BREAKS
17:26:45 <geekosaur> yes, I know it's widely considered "correct" to think otherwise
17:27:03 <geekosaur> because they don;t have to do the support, so they don't have to care how much pain they cause
17:27:38 <geekosaur> and tossing in an allow-newer is simpler than what you have to do to block a breaking update that lots of things depend on
17:27:39 <athan> TO THE MOON! (of karma)
17:27:42 <manny-> I upgraded to 7.8.4 from 7.6 the other day, and some old package that has not been maintained in several years put such an ipper bound limit and now my code doesnt compile
17:28:05 <athan> lol
17:28:09 <manny-> can I make it compile?
17:28:12 <athan> manny-: Why not edit the package?
17:28:20 <athan> `cabal unpack foo`
17:28:33 <manny-> athan: that is the solution? really?
17:28:33 <athan> then sandbox that shiz* (tm)
17:28:43 <athan> manny-: We are people, after all
17:28:50 <athan> not perfect beings :p
17:28:53 <c_wraith> manny-: well, the --allow-newer thing has been mentioned A BUNCH OF TIMes
17:29:01 <KINGG> hey guys I have this great idea
17:29:28 <c_wraith> manny-: it's kind of unfair to complain about the state of the tooling while ignoring that the tools have exactly the option you want.
17:29:34 <geekosaur> let's put it this way: you would have been unable to compile ANYTHING with your 7.6 if we did it the way you want
17:29:45 <pharaun> I have a question about having more than 1x ghc installed
17:29:49 <geekosaur> because the ecosystem is chasing 7.10 right now
17:29:57 <athan> manny-: Then, after it works, you could send in a PR :)
17:30:14 <geekosaur> and that literally does break everything in your 7.6
17:30:21 <pharaun> is it possible to have a system-ghc to make my system-installed haskell stuff happy, then have a nix installed ghc with 7.8 or 7.10
17:30:29 <pharaun> and have it earlier in my PATH for my sandboxes
17:30:34 <geekosaur> because of the applicative-monad and foldable/traversable changes
17:30:41 <pharaun> is that sane or is there a better way to deal with having multiple GHC?
17:31:39 <geekosaur> (for that matter your 7.8 also wouldn't build much)
17:31:54 <c_wraith> actually, more stuff still builds on 7.8 than 7.10 right now
17:32:01 <manny-> "cabal install --allow-newer" still failed. first time I am upgrading ghc. first program I tried to build.. failed the second time 
17:32:06 <geekosaur> I think you can point a sandbox at a specific ghc
17:32:09 <manny-> this sucks
17:32:46 <c_wraith> manny-: if you're using unmaintained packages in *any* language, you shouldn't expect them to work when the surrounding environment changes significantly.
17:32:54 <pharaun> geekosaur: so the best solution for me would be to basically use nix to install the specific version of ghc that i want, then make sure not to include it in the path, then use sandbox to point my stuff toward *that* ghc ?
17:32:55 <c_wraith> manny-: the solution is to not use unmaintained packages.
17:33:10 <Axman6> GHCV 7.10 is a quite a large change from 7.8, it's not surprising things are breaking
17:33:21 <manny-> c_wraith: I can still compile C programs I wrote 15 years ago
17:33:30 <pharaun> isn't 7.10 also the one with AMP proposal implemented?
17:33:38 <Axman6> yes
17:33:45 * geekosaur suspects that the allow-newer just uncovered API changes that really did make the package incompatible
17:33:57 <KINGG> hey guys I was wondering if it's possible to compile codes to creates a voice interactive program that links patients to the next available doctors from different hospitals
17:34:02 <c_wraith> manny-: Not if you did anything interesting in it.
17:34:17 <manny-> I did and I can
17:34:22 <pharaun> geekosaur: anyway thanks, i'll look into the sandbox and see how the pointing at a specific ghc works.
17:34:43 <Axman6> KINGG: of course it's possible
17:34:48 <geekosaur> another alternative is hsenv but then you have to switch environments between sandboxes
17:34:58 <KINGG> to help those in remote areas who don't have easy access to health facilities 
17:35:25 <Axman6> in fact it's something the company I'm working for is working on
17:36:14 <c_wraith> manny-: I can't compile C programs from 5 years ago in general, unless I go hunting down old versions of their dependencies.  This isn't different from Haskell.
17:36:19 <manny-> here is the error.. doesnt even say why it is failing ad far as I can tell. http://lpaste.net/133671
17:36:43 <pharaun> geekosaur: hm, i did hear of hsenv, but eh, i mostly wanted 2 ghc, one userland ghc, and one system ghc, so i do't have to worry about system updates breaking my sandboxes, and correspeondingly i don't need to worry about being held back by what is installed in system.
17:36:55 <Axman6> manny-: are you using a sandbox?
17:37:09 <geekosaur> manny- is upgrading from 7.6 to 7.8
17:37:16 <manny-> Axman6: yes
17:37:28 <geekosaur> pharaun, hsenv may well be what you want
17:37:35 <Axman6> I've had this same issue, and can't remember how I solved it
17:38:07 <pharaun> geekosaur: well then, i'll look into that as well then, thanks :)
17:40:45 <Gurkenglas> After correcting a particularly embarassing and potentially confusing septuple typo, let me repost my attempt to guess at a way to get multple instances per type in haskell: http://www.reddit.com/r/haskell/comments/37tp2c/what_i_found_inconvenient_in_haskell/crr9pyc . Let me know if the reason y'all are not commenting here or there is unclarity.
17:41:13 <Gurkenglas> -if+whether
17:41:28 <manny-> 7.6.3 and 7.84 are only a year and half apart.. and this is normal and expected.. that old code cant be compiled?
17:41:44 <geekosaur> haskell evolves pretty quickly, yes
17:41:49 <manny-> how can anyone use haskell for anything serious, then
17:41:55 <geekosaur> problem is ghc is both a research and a production environment
17:42:43 <pharaun> manny-: by sticking on a version for a while, say slackage
17:42:51 <pharaun> then once in a while update
17:43:07 <pharaun> even production with other language has same issue, see python 2.* and python 3.* breakage
17:43:12 <bitemyapp> manny-: wfm.
17:43:21 <manny->  and once you update rewrite all your old code?
17:43:28 <bitemyapp> manny-: I have fewer issues with Haskell packaging than I did Python or Clojure packaging.
17:43:28 <pharaun> i don't
17:43:35 <bitemyapp> manny-: I don't rewrite "all my old code"
17:43:38 <pharaun> i often find that i just need to tweak/redo 1 or 2 small parts
17:43:44 <pharaun> to update some bit and done
17:43:50 <bitemyapp> 7.8 -> 7.10 was, "don't forget ya applicative". ez-pz.
17:44:15 <pharaun> ie i updated a bit of my older code from uh 7.2/7.0 era, to 7.6 i think then 7.8 and most of the time i only had to do minimal changes
17:48:03 <manny-> that is horrible if you are expected to change your existing code on every upgrade.. python did that when jumping to 3.xx and many people are still on 2.xx for that reason. 
17:48:56 <Axman6> because making progress is hard
17:49:44 <bitemyapp> manny-: and it yet moves
17:50:09 <pharaun> manny-: even 2.6 and 2.7 isn't free
17:50:23 <pharaun> my work is in the process of moving from 2.6 to 2.7 python and lots of things broke as well
17:52:31 <manny-> pharaun: what broke? isnt 2.7 backward compatible with 2.6?
17:52:36 <athan> Anyone here develop on windows? I'm getting a stdout error o_o
17:53:43 <athan> Do programs normally not output to the command prompt?
17:56:20 <enolan> athan, it depends on the program
17:56:35 <enolan> unix convention is often to be silent on success
18:01:04 <athan> enolan: I know that, but this is on windows - I've got a command-line utility that works fine on unix, but on windows (command-prompt) it throws an error
18:02:16 <athan> ugh this is wretched :x
18:02:23 <manny-> thanks everyone for nothing. I uninstalled 7.8.4, installed 7.6.3 back, and I will restrict my haskell usage for maintaining the programs I was stupid enough to write in it. not touching it for anything else serious
18:02:43 <pharaun> manny-: pickling, and several system libs
18:02:54 <pharaun> pickling changed between version
18:03:07 <pharaun> and couple of the systemlib had some additional args, which conflicted with existing proxies
18:03:10 <pharaun> etc
18:03:55 <manny-> pharaun: then the issue was caused by a library change, not changes in python?
18:04:05 <pharaun> pickle in python
18:04:15 <pharaun> *shrugs*
18:05:30 <jmcarthur> manny-: i imagine this is the kind of thing you were hoping for https://www.fpcomplete.com/blog/2015/01/announcing-lts-haskell-1-0
18:05:46 <pharaun> manny-: sounds like slackage maybe your best bet
18:05:57 <manny-> nobody can force library maintainers to care about backwards compatibility. but when language itself is a moving target..
18:06:54 <athan> manny-: Good luck :(
18:07:46 <jmcarthur> manny-: actually the language is not a moving target. it's just all the ghc extensions, etc.
18:08:01 <jmcarthur> manny-: just because ghc is the de facto standard
18:08:10 <nolrai666> So whats recomended way to get the newest ghc and cabal on a new linux machine?
18:08:14 <nshepperd> and the system libraries
18:08:18 <athan> nolrai666: Here one sec
18:08:24 <nshepperd> basically like python
18:08:34 <jmcarthur> pretty much
18:08:35 <athan> nolrai666: https://gist.github.com/yantonov/10083524
18:08:53 <jmcarthur> a new extension doesn't really break anything anyway. it's mainly library changes
18:09:01 <athan> (that's for ubuntu, but you can map the commands over to another ditro c:)
18:09:10 <jmcarthur> ghc has broken code before, but usually not in some major way
18:10:49 <athan> remember what Haskell is named after, manny-! A bad experience here isn't worth the prejudice :(
18:11:57 <athan> (also windows is gross :x)
18:14:38 <MitchellSalad> ivan\: are you ivanm?
18:20:37 <newsham> nice puzzle here: https://www.whitehouse.gov/blog/2015/05/17/hello-world
18:21:34 <newsham> let game alice bob coin1 coin2 = alice coin1 == coin2 || bob coin2 == coin1
18:21:51 <newsham> ?check game (const True) (const True)
18:21:54 <lambdabot>  *** Failed! Falsifiable (after 3 tests):
18:21:54 <lambdabot>  False False
18:22:56 <newsham> provide alice and bob that quickchecks
18:25:20 <manny-> just for the hell of it I have tried it again with stackage config. http-conduit failed to install this time. out of curiosity I removed it from dependency list. then gtk failed to install. I removed gtk, and was greeted with this horror: http://lpaste.net/133672
18:26:18 <slurpymcdurpy> So, you're saying it's provably unpossible?
18:26:39 <nshepperd> removing things from deps won't do anything useful in any language
18:26:58 * lyonsb was slurpymcdurpy
18:27:11 <manny-> I removed them to see what else will fail
18:28:00 <manny-> I lost hope that I will get it working in 7.8.4 about an hour ago
18:29:04 <manny-> anyway I am done venting my frustrations. g'night
18:29:06 <nshepperd> well, it looks like you have an old version of cabal installed for some reason
18:31:58 <c_wraith> newsham: Hmm.  It seems fortunate that the problem can be reduced to two cases with two guessers. :)
18:32:10 <pharaun> yeah seems like older version of cabal
18:39:14 <lyonsb> newsham, first thought was one guess heads, other guesses tails, but that fails 1/4 of the time too.
18:40:58 <c_wraith> lyonsb: try to reduce it to only 2 cases.
18:42:06 <newsham> if nothing else, you can always fall back on the limited number of (Bool -> Bool)'s
18:42:11 <newsham> and brute force it
18:42:22 <lyonsb> Uh, I wrote out a truth-table.
18:43:03 <newsham> namely: const True, const False, id, not
18:44:41 <newsham> ?check id (const True)
18:44:44 <lambdabot>  +++ OK, passed 100 tests.
18:44:48 <newsham> ?check game id (const True)
18:44:49 <newsham> oops :)
18:44:50 <lambdabot>  *** Failed! Falsifiable (after 2 tests):
18:44:50 <lambdabot>  False True
18:45:26 <MitchellSalad> ?check game id not
18:45:28 <lambdabot>  +++ OK, passed 100 tests.
18:45:34 <lyonsb> it's either True/True or True/False and Bob And Alice can each guess True / True or False / True.  (trouble is, at least, trouble I ran into - is that True / False /= False / True)
18:45:40 <c_wraith> MitchellSalad: I'm not lambdabot, but you're correct. :)
18:48:25 <lyonsb> I got it.
18:48:35 <lyonsb> They can win 100% of the time.
18:48:48 <newsham> 2 guessers cover the two cases and win
18:48:48 <lyonsb> Because they write down their guess AFTER their flip.
18:49:37 <lyonsb> One guesses opposite their result, the other guesses the same as their flip.
18:50:14 <newsham> ?check let same = id; diff = not in game same diff
18:50:15 <lambdabot>  +++ OK, passed 100 tests.
18:50:39 <c_wraith> well, it handles at least 100 of the 4 possible cases correctly
18:50:57 <c_wraith> Why does quickcheck test 100 cases when there are only 4 possible inputs? :P
18:51:00 <lyonsb> infinite testing . . .?
18:51:19 <newsham> perhaps we should take this to #agda ;-)
18:51:41 <c_wraith> is this the sort of thing smallcheck would do better?
18:52:03 <newsham> ?type all
18:52:05 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
18:52:13 <c_wraith> :t allOf
18:52:15 <lambdabot> Profunctor p => Accessing p All s a -> p a Bool -> s -> Bool
18:52:29 <subleq__> I'm trying to convert an untyped AST into a typed GADT but I can't figure out the type of the typecheck function. I've got it working where you use a different function for each type in the GADT: http://lpaste.net/133669, but I actually want something that works for all types, like UTerm -> Maybe (TTerm a)
18:52:58 <newsham> > and [game not id x y | x <- [False, True], y <- [False,True]]
18:53:00 <lambdabot>  True
18:53:06 <newsham> c_wraith: better?
18:53:10 <c_wraith> much. :)
18:53:50 <newsham> ?hoogle Enum a => [a]
18:53:51 <lambdabot> Prelude enumFrom :: Enum a => a -> [a]
18:53:52 <lambdabot> Prelude enumFromThen :: Enum a => a -> a -> [a]
18:53:52 <lambdabot> Prelude enumFromTo :: Enum a => a -> a -> [a]
18:54:29 <MitchellSalad> looking for [minBound..maxBound]?
18:54:32 <newsham> yah
18:54:40 <c_wraith> sadly, that's more typing than [False,True]
18:54:49 <enthropy> @hackage universe
18:54:49 <lambdabot> http://hackage.haskell.org/package/universe
18:54:54 <enthropy> > [False .. ]
18:54:56 <lambdabot>  [False,True]
18:54:57 <newsham> there's no std def for [minBound..maxBound] ?
18:55:46 <MitchellSalad> nope
19:00:37 <arkeet> clearly it should be [..]
19:03:27 <c_wraith> arkeet: that would be really cute, but it would require that syntax add Bounded constraints, not just Enum
19:03:36 <c_wraith> arkeet: and at the moment, it gets away with just Enum
19:06:10 <jle`> [..] would be nice, i use [minBound..maxBound] a lot
19:07:06 <pharaun> I could use a bit of help understanding a little bit of code here
19:07:10 <pharaun> http://lpaste.net/6197051321753796608
19:07:42 <pharaun> So i wrote this, and the main line that i am puzzled about (it makes the type line up/work) but it doesn't feel correct to me is - line 19 ">>= \(x:_) -> return x"
19:08:43 <pharaun> basically what i want to happen with "fwp" is that it takes each url, fetches the webpage, and return the content and execute the rest of the code block, then fetch the next url, which seems to be working (via "runWebFetchMonad" on line 18).
19:09:02 <c_wraith> pharaun: well, forM is going to have a calculation create a list of results.  That added bit just takes the head of the lsit
19:09:29 <c_wraith> phaazon: you could write it as head <$> ...
19:09:46 <c_wraith> err, pharaun 
19:09:48 <pharaun> c_wraith: sure, but i guess i'm unclear on what this would result
19:10:11 <pharaun> because i am returning the content via "runWebFetchMonad" as you can see at the bottom the "content1" "content2", content3 part
19:10:38 <pharaun> so it seems like a useless case of "head <$> ..."
19:10:49 <pharaun> so i'm trying to understand why i need to do that bit there.
19:11:28 <newsham> ?type every
19:11:29 <lambdabot> Not in scope: ‘every’
19:11:36 <newsham> ?let every = [minBound..maxBound]
19:11:38 <lambdabot>  Defined.
19:12:01 <newsham> > and [game not id x y | x<-every, y<-every]
19:12:03 <lambdabot>  True
19:12:10 <c_wraith> pharaun: well, one way or another, you have a list of results and want exactly one result.  There's a logical mismatch there.
19:12:23 <pharaun> c_wraith: yes
19:12:39 <pharaun> c_wraith: but it seems to be working, as you can see from the result at the end of the code - that's what is being output
19:12:46 <c_wraith> pharaun: I don't know what you're doing well enough to suggest an alternate approach
19:13:00 <lyonsb> I got it.
19:13:11 <pharaun> c_wraith: sorry, basically i am writing a webpage scrapper, and i'm attempting to convert it from an "natural" BFS style to a DFS style
19:13:37 <pharaun> c_wraith: since its natural to basically get a page, parse a list of url to fetch next and feed that back.
19:13:39 * hackagebot time-qq 0.0.0.2 - Quasi-quoter for UTCTime times  http://hackage.haskell.org/package/time-qq-0.0.0.2 (ChristianMarie)
19:13:40 <lyonsb> I actually got it all enumerated out.
19:13:58 <pharaun> this code is trying to make it take the first list of the url, keep going till it finishes that (depth first) then return and try the next url
19:14:51 <pharaun> and it works, i'm just trying to understand where the "head <$>" ends up, it seems like its doing that just to make the type happy but nothing is ingesting the result.
19:14:58 <newsham> i personally find DFS more "natural" than BFS
19:15:33 <lyonsb> newsham, I solved it.  I'm not going to post the result publicly, but I solved it :)
19:15:37 <newsham> (where i use recursion to hide the work queue implicitely on the stack)
19:15:39 <pharaun> newsham: http://lpaste.net/133674
19:15:45 <newsham> lyonsb: cool :)
19:16:48 <pharaun> newsham: well that's how i ended up styling the code see the DFS first, it seems a bit more work for the programmer, versus the bfs first style
19:17:20 <pharaun> and i was able to use the operational monad + cont to "rewrite" the 2nd style into executing like the first style but i'm trying to understand that one piece of code that i wrote XD
19:18:14 <newsham> fetchPages us = forM_ us fetchPage;  fetchPage u = do { pg <- fetchIt; fetchPages $ extractUrls pg }
19:18:31 <newsham> that will go depth first
19:18:45 <newsham> (and potentially loop if there are cycles and you dont do anything to prevent looping)
19:18:57 <pharaun> yeah the sites i'm scrapping are tree-like
19:19:12 <pharaun> but that's a good one, i should make sure to double check on the cycling thing.
19:19:58 <pharaun> well the operational approach work, i'll mull more on it.
19:20:14 <pharaun> newsham: i'll play with that suggestion and see
19:20:44 <c_wraith> pharaun: I think it's important to consider why you've got a list in the first place, if you're only using the first result from processing it.
19:21:09 <pharaun> c_wraith: i am using all of the results, as seen in the "content1" "content2" "content3" bit below
19:21:20 <pharaun> cuz of me re-executing the following up block with each url in the forM
19:21:28 <newsham> fetchPages us = forM us $ \u -> do { print u; pg <- fetchIt u; fetchPages $ extract Urls pg }
19:22:13 <pharaun> content1 == url1, content2 == url2, content3 == url3
19:22:30 <pharaun> and it *is* returning it and executing the rest of the code block in s3 from line 46 onward
19:22:47 <pharaun> would it be more helpful to have a full reproduction? i can toss one together in a sec.
19:23:07 <c_wraith> pharaun: but in the case starting on line 15, you pass in a list and only use the first entry of it
19:23:21 <pharaun> c_wraith: now see that's the part i don't understand
19:23:27 <c_wraith> pharaun: or at least, you only return the result of processing the first entry of it.  Side effects still happen.
19:23:35 <pharaun> oh
19:23:37 <pharaun> ooh
19:23:39 <pharaun> >_<
19:23:39 <pharaun> yes
19:23:56 <pharaun> i am side-effecting via the "fetchWebpage" then feeding it into the runWebFetchMonad to process it.
19:24:03 <pharaun> so in the end i don't need the actual result back.
19:24:22 <pharaun> but i have to put the "head" thing here to make the type-happy so i was wondering if there was any way i could get rid of it
19:25:14 <newsham> which "head" thing?  i didnt see one in your example paste
19:25:27 <pharaun> http://lpaste.net/6197051321753796608 <- line 19
19:25:34 <pharaun> that is equiv to "head <$>"
19:25:39 <c_wraith> newsham: line 19 is the same as prefixing that block with head <$>
19:26:06 <c_wraith> pharaun: if the return value is unused, you really should figure out how to indicate that in the type
19:26:13 <pharaun> c_wraith: i *want* the side-effect, but i don't care about the return.
19:26:14 <pharaun> and yeah
19:26:19 <pharaun> that's what i'm trying to understand
19:27:26 <pharaun> because from my understanding here - line 3 - "FetchWebpage :: [String] -> WebFetch String" i *NEED* that "WebFetch String" bit here to *return* the content back on line 41 and line 46, so that it can continue with that content in a side-effecting way via (runWebFetchMonad on k which is to my understanding a cont of the code after that point)
19:27:37 <c_wraith> pharaun: fascinatingly, you can never use the returned values other than for side effects anyway..
19:27:43 <pharaun> so if i turn that to a () to indicate that i don't care about the result.
19:27:57 <c_wraith> pharaun: oh, nevermind.  You can.
19:27:59 <pharaun> i can't side-effectingly return it into the cont-t code
19:28:38 <pharaun> one second
19:28:54 <Fylwind> has anyone got a clever way to specify the type of the exception in a 'try' or 'catch' ? one that doesn't use ScopedTypeVariables or requires specifying the whole Either type? :/
19:30:22 <c_wraith> pharaun: I think you can get away with ending that block with (>> return "")
19:30:34 <pharaun> c_wraith: newsham http://lpaste.net/133677 -  i have included the *full* reproduction that does this, you run it via - "runWebFetchMonad s3"
19:30:45 <pharaun> c_wraith: is there no way i can make it not needed, or am i just "stuck"
19:31:02 <pharaun> and am i right in my understanding as of why i'm stuck with having to do that
19:31:05 <c_wraith> pharaun: I think you can change the definition of WebFetch
19:31:19 <pharaun> how so?
19:31:59 <c_wraith> pharaun: If that action doesn't produce any relevant values, change the constructor's type to FetchWebpage :: [String] -> WebFetch ()
19:32:08 <pharaun> hm, ok let me try
19:33:48 <nshepperd> Fylwind: catch (\e -> let _ = e :: FooException in ...)?
19:34:31 <c_wraith> Fylwind: make the type inferred by using some operation in the handler that fixes the type? (pattern-match on its constructor, call a function that makes the type concrete, etc)
19:34:32 <pharaun> c_wraith: http://lpaste.net/133678 <- altered "FetchWebpage :: [String] -> WebFetch ()" and i ended up with that type error, because line 4 does not expect me to give it back the "content of the website i fetched" thus it fails there.
19:35:35 <pharaun> which from my understanding i *need* to to have it actually "side-effectingly" return a content on line - 73 and 78 - http://lpaste.net/133677 - so that the code can take that content and process it from that point on.
19:35:44 <Fylwind> nshepperd, c_wraith: right, but none of those seem elegant though :(
19:36:14 <Fylwind> I wish there was some shorthand syntax for (Proxy :: Proxy SomeType)
19:37:00 <c_wraith> pharaun: Alternatively, if you need the result at some point, change the constructor to return WebFetch [String] and actually return all the results.  This will require doing something cleverer in that handler, of course.
19:37:44 <c_wraith> pharaun: well, it'd mean make the handler look like concat <$> forM us ...
19:41:26 <pharaun> c_wraith: hmmm... but that's the thing. I only need the result one at a time in the s3 code and its injecting it side-effectingly in via cont in runWebFetchMonad,... oh
19:41:38 <pharaun> c_wraith: you just gave me an idea, ok i'm going to try that out and see, thanks.
19:52:58 <ajf> Question: if (.) is redundant given fmap, why does (.) exist?
19:53:05 <ajf> Ditto for map.
19:53:41 <Ralith> to make error messages less confusing to newcomers
19:53:44 <Ralith> or so I hear
19:54:01 <ajf> I wondered if it was that
19:54:07 <pacak> ajf: (.) is shorter than fmap?
19:54:21 <ajf> pacak: So? You could define (.) to be fmap
19:54:33 <pacak> :t fmap
19:54:34 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:54:35 <pacak> :t (.)
19:54:36 <lambdabot> (b -> c) -> (a -> b) -> a -> c
19:54:38 <ajf> then you could do (+2) . [1, 2, 3]
19:55:03 <ajf> (which I just did in ghci by redefining .)
19:55:08 <Zemyla> Hahaha! It works!
19:55:44 <pacak> Confusing error messages would be one reason...
19:55:47 <Zemyla> I have a function ffiGen :: FunPtr f -> f!
19:55:57 <ajf> pacak: I suppose
19:56:36 <ajf> not really a Haskell question, but are there any languages that do this? get rid of map and . in favour of just having fmap?
19:58:09 <Zemyla> ajf: (.) is different from fmap because:
19:58:17 <Zemyla> :t (Control.Category..)
19:58:19 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
19:59:24 <ajf> Zemyla: because boxing?
19:59:47 <Zemyla> Because (.) is an operator on two members of a category.
19:59:57 <Zemyla> :i Category
20:00:36 <ajf> Not in Prelude, though?
20:01:01 <Zemyla> No, which is strange and often causes problems.
20:01:17 <ajf> Interesting.
20:01:42 <nshepperd> if we would get rid of (.) at all, I would replace it with Category.(.) rather than fmap, I think
20:02:09 <Zemyla> Yeah, we'd replace it with Category.. and replace id with Category.id.
20:02:23 <ajf> Alright
20:02:35 <ajf> As is probably obvious, I am pretty new to all this
20:03:31 <newsham> why would you want to put id in Category?
20:04:01 <newsham> hmm.. i retract that question.
20:04:12 <Zemyla> Going to be a bit harder for me to define ffiWrap :: f -> FunPtr f, though.
20:04:37 <ajf> Huh. I can't believe typing `let foo = id foo` worked.
20:05:08 <nshepperd> 'let foo = foo' works too
20:05:11 <benzrf> ^
20:05:14 <ajf> Yeah
20:05:20 <nshepperd> in that it spins forever if you try to evaluate it
20:05:24 <benzrf> :t fix id
20:05:26 <lambdabot> a
20:05:32 <ajf> Same for foo = id foo
20:05:50 <Zemyla> There are some things where recursive definition works out fine, though.
20:05:53 <benzrf> 10:57:47        Zemyla │ ajf: (.) is different from fmap because:
20:06:04 <benzrf> Zemyla: actually, hom functor
20:06:17 <benzrf> that's how fmap-is-composition works
20:06:20 <benzrf> and it generalizes
20:06:36 <Zemyla> benzrf: So what should the type of fmap be?
20:09:09 <deckoff8> Hi. I'm trying to do the 99 haskell questions on https://wiki.haskell.org/99_questions/11_to_20, what's the polite behavior for asking?
20:09:30 <deckoff8> asking for help that is~
20:10:18 <nshepperd> class HomFunctor f where { type family Cat f :: * -> * -> * ; fmap :: Cat f a b -> f a -> f b } ?
20:11:43 <nshepperd> i suppose that allows you to handle category composition as well as ordinary functors
20:11:44 <pharaun> deckoff8: just ask :)
20:11:57 <nshepperd> at the cost of bleh
20:12:45 <deckoff8> cool. so I'm doing the replicate question. I can do replicate with dupli :: (Eq x) => [x] -> [x] dupli = foldr bleh [] 	where  		bleh x [] = x : [x] 		bleh x xs = [x,x] ++ xs
20:13:07 <deckoff8> replicate just takes [x] and n and does something similar but instead of twice do it n times
20:13:39 <deckoff8> i'm trying to do it similarly with foldr but I guess I'm having some problem with the foldr syntax
20:13:54 <deckoff8> if I define repli repli :: (Eq x) => [x] -> Int -> [x] repli x n =
20:14:06 <deckoff8> not sure how to get it to compile after...
20:18:12 <mathu> i have a function with three pattern-matched definitionss. there is one common function used in all three definitions that is used nowhere else in the module. what's the best way to define this function? i don't want to do three 'let... in...'s or '... where's
20:18:39 <mzero> ah yes
20:18:41 <mzero> do this
20:18:47 <mzero> foo = go
20:18:51 <mzero>   where
20:19:08 <mzero> then define go with the three pattern matched cases
20:19:18 <mzero> and the other things at the same level, within the go
20:19:25 <mzero> or 
20:19:32 <mzero> foo x = case x of ...     
20:19:52 <mathu> i don't see how that keeps me from defining this helper function for each pattern
20:19:52 <mzero> and put the patterns in the case --- and you can have a where clause after that
20:19:57 <mathu> oh well the case would
20:20:05 <mathu> oh and the where would too
20:20:27 <mzero> foo = go ; where ; helper = xxx ; go (First x) = ... helper ... ; go (Second x) = ... helper ...
20:20:42 <mzero> because go and helper are at the same level, under the where
20:20:48 <mzero> each definition of go can use helper
20:20:53 <mathu> yeah this makes sense
20:21:17 <dreams> mathu: you can do: fun x = case x of { three alternative} where localfun x = ... 
20:21:22 <mathu> and i'm starting to realize there isn't really Idiomatic Haskell, it's just up to me what's reasonable
20:24:34 <dreams> mathu: something like this (if its what you meant) http://lpaste.net/133680
20:24:42 <mathu> yeah i get it
20:24:49 <mathu> that's what i wanted
20:24:49 <kevin1024> Is there a nice way to convert a list of [1,2,3] to [[1],[1,2],[1,2,3]]?
20:24:51 <mathu> thank you!
20:25:05 <Myrl-chan> kevin1024: Hmmm...
20:25:10 <Myrl-chan> kevin1024: Perhaps you can use scanl1.
20:25:16 <kevin1024> I was thinking something with reduce..?
20:25:22 <kevin1024> er, fold
20:25:59 <DrPavelheer> :t heads
20:26:00 <mzero> :t inits
20:26:02 <lambdabot> [a] -> [[a]]
20:26:02 <lambdabot>     Not in scope: ‘heads’
20:26:02 <lambdabot>     Perhaps you meant one of these:
20:26:02 <lambdabot>       ‘reads’ (imported from Prelude), ‘head’ (imported from Data.List),
20:26:10 <DrPavelheer> inits, then
20:26:10 <mzero> er, heads, yeah. that's it --- heads
20:26:15 <DrPavelheer> no, it was inits
20:26:20 <mzero> d'oh!
20:26:22 <Myrl-chan> I don't have inits. :D
20:26:27 <Myrl-chan> > inits [1,2,3]
20:26:27 <mzero> it is in Data.List
20:26:28 <DrPavelheer> > inits [1,2,3]
20:26:32 <lambdabot>  <no location info>: can't find file: L.hs
20:26:32 <lambdabot>  [[],[1],[1,2],[1,2,3]]
20:26:38 <kevin1024> whoah, nice find!
20:26:38 <Myrl-chan> tail . inits ?
20:26:49 <mzero> all sublists!
20:26:50 <DrPavelheer> > reverse . tail . inits [1,2,3]
20:26:52 <lambdabot>      Couldn't match expected type ‘a -> [a1]’
20:26:52 <lambdabot>                  with actual type ‘[[Integer]]’
20:26:52 <lambdabot>      Possible cause: ‘inits’ is applied to too many arguments
20:26:59 <Myrl-chan> > tail . inits [1,2,3]
20:27:00 <lambdabot>      Couldn't match expected type ‘a -> [a1]’
20:27:00 <lambdabot>                  with actual type ‘[[Integer]]’
20:27:00 <lambdabot>      Possible cause: ‘inits’ is applied to too many arguments
20:27:04 <Myrl-chan> WAT
20:27:09 <Myrl-chan> > tail . inits $ [1,2,3]
20:27:10 <lambdabot>  [[1],[1,2],[1,2,3]]
20:27:14 <mzero> > tails . inits $ "noodles"
20:27:16 <lambdabot>  [["","n","no","noo","nood","noodl","noodle","noodles"],["n","no","noo","nood...
20:27:18 <DrPavelheer> > reverse . tail $ inits [1,2,3]
20:27:20 <lambdabot>  [[1,2,3],[1,2],[1]]
20:27:20 <Myrl-chan> NOOD
20:27:35 <DrPavelheer> oh wait, you didn't want it reversed
20:28:11 <DrPavelheer> > repeat "NOOD "
20:28:13 <lambdabot>  ["NOOD ","NOOD ","NOOD ","NOOD ","NOOD ","NOOD ","NOOD ","NOOD ","NOOD ","NO...
20:28:58 <joneshf-laptop> is there no `Arbitrary` instance for `Set`?
20:30:02 <Fylwind> for lifted IO exception handling what do people usually use besides MonadIOControl?
20:30:18 <Fylwind> * MonadBaseControl IO is what I meant
20:30:50 <Fylwind> It seems that MonadIO doesn't really fit in the  MonadBaseControl IO  scheme
20:36:42 <manny-> I like to admit when I am wrong, my migration to from 7.6.3 went much smoother than it initially seemed it will. my program depends on 22 packages, and if I count their dependencies a total of 110 packages needed to be installed for my program to build. 109 installed fine, the one that didn't was deepseq-th, which is deprecated, not updated since 2012, and was replaced by some other package
20:37:08 <manny-> I made a mistake of using --allow-newer globally instead of just for that one package (which didn't help anyway), and not using stackage right away
20:37:21 <geekosaur> template haskell stuff tends to break anyway as it relies on compiler internals
20:38:01 <manny-> my program also has around half a dozen thousand lines, and I only needed to change 10 or so lines to build it
20:38:25 <manny-> so it seems that I may have jumped the gun and that haskell is not as bad as I thought :P
20:39:02 <bitemyapp> manny-: :)
20:39:38 <bitemyapp> Fylwind: (MonadBase IO m) ?
20:39:44 <bitemyapp> Fylwind: https://wiki.haskell.org/New_monads/MonadBase
20:41:20 <Fylwind> bitemyapp: MonadBase belongs in the same family as MonadBaseControl though
20:42:07 <nitrix> How was haskell before monads were idiomatic?
20:42:11 <Fylwind> I'm curious what others are out there; I know there's also MonadCatch/Throw, which is apparently compatible with MonadIO
20:42:43 <bitemyapp> nitrix: monads were sorta handed down from on high (PL R&D by the Gofer and GHC devs), they didn't develop as an idiom.
20:42:52 <bitemyapp> nitrix: and to answer your question properly: awkward.
20:42:56 <Astrocoder> Is there a Haskell version of the timehack library? I see Java has a library now that let's you hack stuff back in time, like a time machine, does haskell have it?
20:43:08 <bitemyapp> IO was in terms of [Request] -> [Response] or continuation passing.
20:43:43 <bitemyapp> Astrocoder: timehack?
20:44:05 <bitemyapp> Astrocoder: you're not going to understand this: https://hackage.haskell.org/package/tardis-0.3.0.0/docs/Control-Monad-Tardis.html
20:44:26 <Astrocoder> Hahahaha
20:46:52 <nitrix> bitemyapp: I see. IO is essentially continuation passing, right? You're passing the World around, I think is what GHC calls it.
20:46:59 <nitrix> bitemyapp: Very interesting :)
20:47:50 <mathu> say i want to skip the first word in a string. how can i compare to methods of doing this? ( `unwords . tail . words` vs `tail $ dropWhile (/=' ')`)
20:47:51 <DrPavelheer> WHAT THE HELL IS THIS
20:48:13 <c_wraith> nitrix: GHC's IO implementation is actually (phantom) state-passing, not continuation-passing.
20:48:22 <c_wraith> nitrix: but neither is a useful way to think of IO.
20:48:45 <mathu> will i someday be able to craft execution plans in my head or will i have to write benchmarks to compare these two approaches?
20:48:58 <Astrocoder> As far as the timehack, look at the monitor: https://youtu.be/bS5P_LAqiVg?t=600
20:49:07 <bitemyapp> nitrix: what c_wraith said is quite right. It's best not to think about it and just treat it like a semantics-free thing you map/bind over.
20:49:22 <pharaun> DrPavelheer: ?
20:49:26 <c_wraith> mathu: the latter is going to be more efficient since neither tail nor dropWhile creates a new list
20:49:28 <nitrix> bitemyapp: c_wraith: I'm aware, I just suddently got curious about the history.
20:49:44 <c_wraith> mathu: whereas both unwords and words involve creating lots of new lists
20:50:08 <mathu> c_wraith: that's what i thought, but the words/unwords combo seemed more haskell-y :P
20:50:11 <bitemyapp> nitrix: http://haskell.cs.yale.edu/wp-content/uploads/2011/02/history.pdf http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf
20:50:28 <c_wraith> mathu: not to mention that words/unwords is actually a lossy operation. :)
20:50:34 <bitemyapp> nitrix: I emailed one of the original GHC authors about the history of IO and Monad, in addition to reading those. I'll have a chapter on IO in my book.
20:50:44 <mathu> is it? hm
20:50:47 <bitemyapp> mostly to demystify it so people can move on to something more interesting :P
20:50:51 <c_wraith> > unwords $ words "who   goes\nthere"
20:50:53 <lambdabot>  "who goes there"
20:50:59 <mathu> ohh
20:51:25 <mathu> good god firefox is leaking soooooo much m emory
20:51:30 <mathu> using 14gb, what the heck
20:51:35 <pharaun> Astrocoder: oh my that's hilarious
20:53:07 <bitemyapp> Astrocoder: oh good lord I didn't even notice that.
20:55:47 <Astrocoder> yeah a 766 mhz CPU running Java and hacking time...surely Haskell could do it more efficiently :D
20:57:10 <Astrocoder> 7.66*
20:57:34 <lpaste> ClaudiusMaximus pasted “exptended floating point (API design questions)” at http://lpaste.net/133681
20:58:04 <ClaudiusMaximus> questions in the paste..
21:10:58 <erikd> ClaudiusMaximus: Exptended ? speeling?
21:11:55 <ClaudiusMaximus> erikd: extended exPonent  (i figure calling it Extended would be a bit generic/vague/conflict with other things)
21:12:14 <erikd> so what about ExpExtended ?
21:12:40 <erikd> another two chars but so much more obvious
21:13:22 <ClaudiusMaximus> fair, should be a simple copy/paste
21:13:40 <ClaudiusMaximus> rather search/replace - bit late/early here...
21:14:47 <poincare101> I have a pretty rookie question about "let" statements. I have this code: http://pastie.org/10217013 and I'm getting this error: http://pastie.org/10217014 - what is going wrong? Can you not have multiple let statements?
21:15:55 <ClaudiusMaximus> poincare101: don't use tabs for alignment
21:16:04 <poincare101> ClaudiusMaximus: ah. damn it. thank you.
21:16:27 <erikd> poincare101: also use -Wall (which includes -fwarn-tabs for ghc > 7.10)
21:16:48 <poincare101> erikd: got it
21:16:48 <erikd> if you're using ghc < 7.10 you can still use -fwarn-tabs
21:17:13 <erikd> prevents embarrassment :-)
21:17:30 <R0b0t1> http://www.c-span.org/video/?326227-2/us-senate-debate-nsa-surveillance
21:17:32 * R0b0t1 ducks
21:17:59 <kristof> off-topic
21:18:04 <kristof> also, I saw that :P
21:18:18 <erikd> kristof: i suspect its actually a bot
21:18:46 <kristof> erikd: He's been idling in the channel for a while
21:18:50 <poincare101> If i have a a list [IO Variable], is there any way I can turn that into [Variable] inside a do block?
21:19:01 <kristof> poincare101: No
21:19:13 <poincare101> Or should I figure out a way to turn the [IO Variable] into IO [Variable]?
21:19:23 <mzero> :t sequence
21:19:25 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
21:19:26 <kristof> poincare101: sequence is what you're looking for
21:19:41 <mzero> poincare101: sequence is what you want
21:19:52 <mlamari> import Control.DeepSeq works; but import Control.DeepSeq.TH won't - aren't they in the same package? How can I get the latter working?
21:20:00 <kristof> poincare101: But anyway, the thing about monads is that it's easy to take a value and put it into a monadic context, but it doesn't necessarily make sense to take one out of one. IO is the same way
21:20:18 <erikd> poincare101: sometimes having [IO a] means you have a "let x = .." where you should have "x <- .."
21:20:20 <kristof> poincare101: The whole point of IO is to forbid users from using world-context values in pure contexts
21:20:25 <poincare101> kristof: right, that makes sense.
21:20:43 <poincare101> kristof: but I only need the [Variable] inside a do block to pass to a pure function
21:20:51 <mzero> then fine
21:20:53 <poincare101> so the return value of the function is still IO (something)
21:21:03 <mzero> stuf < - sequence list-of-IO-things
21:21:07 <kristof> ^
21:27:37 <OutlawStar> so i've been reading online the orphaned instances can be bad thing to use... If I want a plugin type model where you would only ever link against one implementation of that plugin, can I accomplish that without an orphaned instance?
21:27:55 <poincare101> is there a function that will let me apply an operation to a list at a specific index?
21:28:21 <mzero> poincare101: no, not really
21:28:29 <mzero> you can extract at a particular index:  !!
21:28:42 <mzero> but it isn't a total function (i.e.: if crashes if the list isn't long enough)
21:29:02 <mzero> is what you want a new list, but with the i-th element mutated some how?
21:29:18 <poincare101> mzero: right. I could do it with map and zip I guess
21:29:26 <mzero> yup
21:29:33 <mzero> I was just about to type an example of that in
21:31:08 <mzero> > let mutateN n f = zipWith (\i x -> if i == n then f x else x) [0..]  in  mutateN 3 (*10) [3,1,4,1,5,9,2,7]
21:31:11 <lambdabot>  [3,1,4,10,5,9,2,7]
21:31:17 <poincare101> mzero: http://pastie.org/10217027 <- does this work
21:31:30 <mlamari> Is there a way to mark record fields as strict in the manner that you can with other data types?
21:31:54 <mzero> poincare101: looks good to me, but also check out  zipWith   - as I used
21:32:01 <poincare101> mzero: got it, thank you
21:32:23 <mzero> b.t.w. - no need to parenthesize (snd x) in your code
21:32:44 <poincare101> mzero: won't it think that == is an argument to snd?
21:32:57 <mzero> mlamari:   data Foo = Foo { fooName :: !String, fooCount :: !Int }
21:33:26 <mzero> poincare101:  no, function application binds tightest of all - even tighter than the tightest of operators
21:33:40 <poincare101> mzero: ah got it.
21:34:13 <mlamari> mzero: Does that mean WHNF of the Foo will include stricting those? Or is another ! needed somewhere?
21:35:20 <mzero> Yes, it means that if you have an evaluated Foo, then you have a an evaluated fooName and fooCount -- but remember that you can still have an unevaluated Foo
21:35:59 <mlamari> mzero: Thanks - consider me    clueless + 1 now.    Or maybe that's  clueless `seq` (clueless + 1)
21:36:29 <nshepperd> it means a whnf Foo will include a whnf fooName and fooCount
21:36:33 <dedgrant> OutlawStar: The accepted way to do this is to design your APIs to be parametric over the the needed (plugin) types. It's a recognized deficiency in the modularity of Haskell packages. I think a lot of us are hoping that Backpack will eventually  address the issue in a simpler way with ML-like package interfaces.
21:38:39 <poincare101> Can I curry a function "f a b c" by removing the argument "a"?
21:39:27 <Rotaerk_> poincare101, g b c a = f a b c
21:39:28 <Rotaerk_> ?
21:39:53 <OutlawStar> dedgrant: Whats backpack?
21:40:20 <kristof> Personally, I think haskell should support named arguments but that would really mess with currying
21:40:52 <kristof> Or would it?
21:41:10 <OutlawStar> nvm, found paper on backpack
21:41:22 <poincare101> Rotaerk_: that seems a little annoying
21:41:26 <dedgrant> OutlawStar: k :)
21:42:29 <nshepperd> poincare101: what does that mean, removing the argument
21:42:49 <OutlawStar> dedgrant: do you know of any examples that show what you recommend (parametric)
21:42:53 <Rotaerk_> poincare101, anyway, f a b c is already curried; currying is not the same as flipping arguments around
21:43:46 <poincare101> nshepperd: so in general I would curry like so: "f a b", but what if I want to do the same with "f b c" (i.e. not specify a)?
21:44:31 <Rotaerk_> ah, that's called "partial application", not currying
21:44:39 <mzero> poincare101: you can't directly....   (\a -> f a b c)
21:44:47 <poincare101> Rotaerk_: oh sorry; that's what I meant
21:44:58 <poincare101> mzero: hmm, okay. thank you.
21:45:16 <Rotaerk_> yea what mzero said is one solution; another is to just define a new function in terms of f; another is to define a combinator
21:45:24 <mzero> if we are talking   (\a -> f a b)   you could do    flip f b
21:45:39 <Rotaerk_> flip f a b = f b a
21:46:01 <mzero> in theory, one could imagine a myriad of flip-like functions that permute arguments in all sorts of ways
21:46:01 <Rotaerk_> <something> f b c a = f a b c
21:46:12 <mzero> but if that's your thing - perhaps FORTH is a better language !
21:46:13 <Rotaerk_> however, I don't like using flip functions... I find that it makes the code harder to read
21:46:24 <nshepperd> using a lambda is much more readable
21:46:30 <mzero> well, joking aside, those sitautions occur rarely enough
21:46:43 <poincare101> I wish there was a more elegant way to do it
21:46:47 <mzero> that functions for them would just be confusing for your reader
21:46:53 <nshepperd> ordinarily when writing a function you try to put the less variable argunents first
21:46:56 <Rotaerk_> if I find that I use it often in multiple orderings, I would just make multiple named functions
21:47:03 <mzero> if you need to do a lot in a particular module, just write a one-line helper function
21:47:32 <Rotaerk_> insert (k, v) dictionary
21:47:36 <Rotaerk_> insertInto dictionary (k, v)
21:47:46 <Rotaerk_> etc
21:48:16 <mzero> poincare101: partially (pun aside) because of this, careful argument ordering is big consideration when designing a haskell module's API
21:49:50 <mzero> a common rule-of-thumb is to put the most-altered value last.   Set.insert :: v -> Set v -> Set v
21:51:23 <mlamari> Need a strategy - if you start with a list of (non_-NFData) things, and wish to repeatedly transform all the elements in that list by some function, is there a util function to force the list spine + each element  to WHNF?
21:52:05 <mlamari> I'm guessing that it could be done with recursion and bang-pattern; but can you    map f l   <-- and somehow make the result whnf for all content elements?
21:53:02 <dedgrant> OutlawStar: Usually type variables in function types, or in data types around which a package revolves (the Proxy type in pipes is one such example).
21:53:26 <mzero> mlamari: I'm confused - what does transforming them repeatedly have to do with WHNF?
21:53:54 <mlamari> mzero: so as to strictly rebuild the list over and over again without leaving a list of thunks.
21:54:12 <mlamari> mzero: Wider solution is probably busted anyway; but want to understand this local part of the problem anyway.
21:54:34 <mzero> sure...    make use of $!
21:55:14 <mzero> map (f $!)    
21:55:27 <mzero> will ensure you never have more than one level of thunk
21:56:40 <dedgrant> OutlawStar: Note that even if you're the user of a package there are sometimes ways to cheat. To get around orphaned class instances for example, it is common to create a newtype wrapper. I try to avoid creating APIs that are likely to make users of my libraries need to do this, but there is also a cognitive cost for having too many variables in your type parameters. (Mnemonics can help here as long as you're not constantly shifting 
21:56:40 <dedgrant> your APIs around on users.)
21:56:44 <CuteStat> we have the best obviously.
22:00:00 <poincare101> If I have an (Integer, Integer, Integer), how do I get the last element of it?
22:00:20 <pavonia> pattern matching
22:01:28 <ronh-> > view _3 (1,2,3)
22:01:29 <lambdabot>  3
22:01:40 <ronh-> > view _3 (1,2,3,4,5)
22:01:42 <lambdabot>  3
22:01:59 <mlamari> (Note - if you run this as-is it will probably blow out your ram) this still has a space-leak and I'm kind of lost:  https://gist.github.com/anonymous/6cbeac4b254c3b8f17ce  - would appreciate  help. Even though what I'm doing here is dumb I'd still like to understand the missing link. I *think* the break is in "advancedGameState" and its use, as advancing the 'actors' has no problem if I remove th
22:02:05 <mlamari> that list from the equation
22:03:15 <Zemyla> What the hell is this? http://hackage.haskell.org/package/wedding-announcement
22:03:31 <poincare101> pavonia: hmm... is there a standard function to turn a record into a tuple?
22:03:32 <Zemyla> Someone wrote a wedding announcement in Haskell, and uploaded it to hackage.
22:03:57 <pavonia> poincare101: No, because every record type is different
22:04:53 <Kneiva_> Zemyla: awesome :D
22:05:10 <Zemyla> And they updated it, but I can't find what the diff is.
22:05:22 <Zemyla> And there were 324 downloads.
22:06:05 <mzero> poincare101: if you were going to pattern match on the tuple - you might as well pattern match on the record
22:06:48 <poincare101> mzero: I was thinking I could turn my code to just use a type instead of a tuple but i have a list comprehension that would be a bit wordy to change
22:07:07 <crobbins> is there a name for a list that always has a head and last elem?  something like `MinLen2 a [a] a`
22:07:19 <mzero> remember - records needn't be used with the member names
22:07:37 <mzero> data Foo = Foo { fooName :: String, fooCount :: Int }      
22:07:41 <mzero> can be used with 
22:08:06 <mzero> [ Foo s n | s <- names, n <- [1..3] ]
22:08:28 <poincare101> mzero: so if I have a set of records constraintSet, and I have list comprehension : [(a, b, c) <- constraintSet], how would I change that if constraintSet changes to have records ConstraintEl a b c?
22:08:59 <mzero> [ ConstraintEl a b c <- constraintSet ]
22:09:35 <mzero> I'm not sure what you've got - is constraintSet some list of things, and you want to do something like:
22:10:00 <mzero> [ a + b - c | ConstraintEl a b c <- constraintSet ]
22:10:16 <mlamari> mzero:  FWIW, at least local to the problem, this is what I needed:   (force (map (const "" $!) finalList)) `seq` finalList      , to force to whnf each element. Just wondering if there's something special-case for lists or something for this situation.
22:10:17 <poincare101> mzero: yes that's basically what I want to do
22:10:20 <mzero> that takes each one "apart", and lets you work with the members
22:10:24 <mzero> you can slo do things like:
22:11:23 <mzero> [ e | e@(ConstratintEl a b c) <- constratintSet , a == b && c < x ]
22:11:45 <mzero> in otherwords, get inside each item, but still use the item as a whole without "rebuilding" it
22:14:43 <ClaudiusMaximus> mlamari: maybe something like   seqList [] = [] ; seqList (x : xs) = ((:) $! x) $! seqList xs  to WHNF each element and force the whole spine?  (haven't tested, not sure of fixity of $! so i added more ())
22:16:05 <ClaudiusMaximus> mlamari: but that does reconstruct the spine, probably there is a better way
22:17:46 <mlamari> ClaudiusMaximus: Thanks it did the job! Your example is closer to what the problem warrants than what I did, can probably just do a recursive thing that forces each element but without actually consing
22:17:47 * hackagebot dash-haskell 1.1.0.1 - Convert package Haddock to Dash docsets (IDE docs)  http://hackage.haskell.org/package/dash-haskell-1.1.0.1 (johnfeltz)
22:17:47 * hackagebot time-qq 0.0.0.2 - Quasi-quoter for UTCTime times  http://hackage.haskell.org/package/time-qq-0.0.0.2 (ChristianMarie)
