00:07:40 * hackagebot stackage-metadata 0.1.0.0 - Grab current metadata for all packages  http://hackage.haskell.org/package/stackage-metadata-0.1.0.0 (MichaelSnoyman)
00:07:40 * hackagebot base-compat 0.8.2 - A compatibility layer for base  http://hackage.haskell.org/package/base-compat-0.8.2 (ryanglscott)
00:44:51 <aawe> where do I find papers exploring good language design? Terseness vs verbosity, the merits of enforcing types at compile-time, measurements comparing different type systems
00:47:02 <calvinx> what’s the difference between [String] versus [Text], where Text is from Data.Text (Text) ?
00:47:40 <tdammers> String is a linked list of characters
00:47:44 <calvinx> If I have a data structure like this [“hello.txt”, “myfile.pdf”, “report.doc”],
00:47:54 <calvinx> should I be using [String] or [Text] ?
00:47:54 <Axman6> String is a list of Char, Text is an opaque type which represents (UTF-16 encoded) textual data
00:48:01 <tdammers> Text is something like a dynamic array of utf-16 encoded text
00:48:09 <calvinx> I see.
00:48:28 <Axman6> in general, you probably want to be using Text, if you can
00:48:30 <_m_ryan> hi, how to convert Text to Float with 2 decimal place? e.g "200" -> 200.00
00:48:35 <tdammers> String is Haskell's default string representation, but this is kind of an unfortunate choice, because it doesn't perform well
00:48:39 <aawe> calvinx: Text is often more performant than String, ByteString even more so
00:48:45 <Axman6> because it's muchfaster most of the time
00:48:55 <tdammers> ByteString doesn't even cover the same use case
00:48:59 <calvinx> Axman6: when I use [Text] for the data structure above as type signature, ghc-mod complains.
00:49:01 <tdammers> ByteString is not for text
00:49:05 <tdammers> ByteString is for blobs
00:49:06 <calvinx> And ghc won’t compile.
00:49:19 <tdammers> calvinx: string literals aren't polymorphic by default
00:49:23 <aawe> tdammers: blobs can contain text
00:49:24 <calvinx> ref [“hello.txt”, “myfile.pdf”, “report.doc”]
00:49:35 <Axman6> calvinx: you need to enable the OverloadedStrings extyension if you want to use "foo" to mean anything other than String
00:49:36 <tdammers> aawe: blobs can contain *encoded* text
00:49:42 <calvinx> AHHHHhhhhhhhh
00:49:43 <tdammers> aawe: not the same thing though
00:49:47 <calvinx> Thanks Axman6!
00:50:04 <calvinx> what a silly gotcha. Thanks.
00:50:05 <tdammers> aawe: and the assumption that text and encoded text are the same thing has caused way too much pain and suffering already
00:50:08 <Axman6> calvinx: {-# LANGUAGE OverloadedStrings #-} at the top if your file
00:50:26 <tdammers> C makes that assumption, PHP makes that assumption, and look how bad they are at handling unicode data
00:50:26 <aawe> tdammers: parsec only works on bytestrings and acts as if it's strings
00:50:41 <tdammers> aawe: wut?
00:50:56 <tdammers> Parsec works on anything that implements the appropriate typeclasses
00:51:00 <calvinx> The language extensions have been killing me
00:51:25 <calvinx> What’s a good tutorial to have a good understanding of all the common extensions I should know?
00:51:28 <tdammers> attoparsec works on bytestrings, but it doesn't pretend they're strings, it provides some atomic parsers that can parse utf-8
00:51:30 <aawe> I never got parsec to work unless I used bytestring last time I tried, perhaps I just failed spectacularly
00:51:49 <aawe> or perhaps it was attoparsec
00:51:55 <tdammers> aawe: have you read the source code? Or the documentation? Parsec works fine with String as your stream and Char as your token
00:52:06 <tdammers> attoparsec is built with byte strings in mind, yes
00:52:11 <tdammers> but it doesn't play pretend
00:52:16 <aawe> tdammers: put down your sword
00:52:23 <tdammers> ok ok
00:52:36 * hackagebot stackage-install 0.1.1.1 - Secure download of packages for cabal-install  http://hackage.haskell.org/package/stackage-install-0.1.1.1 (MichaelSnoyman)
00:53:29 <hary_> I want to get a partially applied type of Map( value part is applied with String, and key part is not applied), How I can do it in haskell?
00:53:55 <calvinx> thanks for the various pointers btw, appreciate the help tdammers, Axman6, aawe
00:54:04 <Axman6> no worries
00:54:06 <tdammers> calvinx: np
00:54:07 <mjrosenb> hary_: my guess would be type flip c a b = c b a
00:54:44 <Axman6> calvinx: the GHC documentation has a single page on all the language extensions - it's worth having a read (even if you don't understand a lot of it or why it's useful) just so you're familliar with them
00:55:39 <calvinx> ok, thanks for the clue. will do that. 
00:55:40 <mjrosenb> ok, I'm guessing it is /impossible/ to create something like StableName that isn't in IO
00:56:09 <Axman6> mjrosenb: wasn't there recent work on that? one sec
00:56:26 <byorgey> calvinx: I think you have to use a newtype.  newtype Map' a k = Map' (Map k a)
00:56:34 <byorgey> then you can use  Map' String
00:56:48 <_m_ryan> hi, how to convert Text to Float with 2 decimal place? e.g "200" -> 200.00
00:57:04 <Axman6> mjrosenb: look at static references in GHC
00:57:15 <AshyIsMe> so, how do i get a local copy of a hackage packages documentation easily?
00:57:19 <Axman6> _m_ryan: use Text.unpack and then read
00:57:28 <aawe> _m_ryan: floats do not have decimal places. do you mean you want to convert the string "200" to the string "200.00" ?
00:58:13 <Axman6> > read (unpack "200") :: Double
00:58:14 <lambdabot>      Not in scope: ‘unpack’
00:58:14 <lambdabot>      Perhaps you meant one of these:
00:58:14 <lambdabot>        ‘BS.unpack’ (imported from Data.ByteString),
00:58:19 <Axman6> > read (T.unpack "200") :: Double
00:58:20 <lambdabot>      Not in scope: ‘T.unpack’
00:58:21 <lambdabot>      Perhaps you meant ‘BS.unpack’ (imported from Data.ByteString)
00:58:23 <Axman6> :(
00:58:44 <_m_ryan> aawe: yes... 
00:59:13 <Axman6> _m_ryan: what is the type of the thing you want to end up with? Text? String? Double?
00:59:17 <mjrosenb> "24 days of GHC Extensions"
00:59:26 <mjrosenb> ooh, lah-lah
00:59:30 <aawe> Axman6: "200" -> "200.00"
01:00:14 <Axman6> I'd prefer to hear that from _m_ryan 
01:00:23 <aawe> he confirmed it above
01:00:37 <_m_ryan> Axman: just like aawe said, sorry for misunderstunding
01:01:29 <Axman6> _m_ryan: to get a good answer, you'll need to be more specific. what do you want to happen if your string is say "199.99"? is that something you need to worry about? can you just add ".00" to the end of your string?
01:02:08 <_m_ryan> Axman6: what if i had "200.5"?
01:02:27 <Axman6> exactly, that's my question to you. what do you want to happen if you have "200.5"
01:02:41 <Axman6> do you want that to be "200.50"?
01:03:34 <_m_ryan> Axman6: yes
01:03:44 <Axman6> ok then, now we can get somewhere
01:03:58 <_m_ryan> Axman6: sorry :-)
01:04:18 <Axman6> it's important to clearly specify your problem, because the answer to your original question is "stick ".00" on the end of it"
01:05:14 <mjrosenb> Axman6: that looks awesome!
01:05:37 <calvinx> With my first simple production web backend with Haskell/Yesod rolling out, I am convinced that Haskell is like a 100,000 piece jigsaw puzzle. With pieces of certain type only fitting with certain types and you have to know them all to piece them together. LOL.
01:05:45 <Axman6> so, now we can use functions like unpack from Data.Text to get a String, we can use read (or maybe better to use readMaybe) to parse the String into a Double, and then we can use printf from Text.Printf to format the string using something like: printf "%.2f"
01:06:18 <Axman6> calvinx: yep, but once you know what the pieces are, putting them together is often really easy =)
01:06:28 <calvinx> :D
01:08:41 <Axman6> _m_ryan: does that give you a good place to start?
01:09:00 <_m_ryan> Axman6: just like this? printf "%.2f\n" ( readMaybe ( unpack "200")  :: Double)
01:09:37 <Axman6> _m_ryan: almost, you have to handle the Maybe Double returned by readMaybe
01:10:42 <Axman6> so, we can do: maybe ("-1.00") (pack . printf "%.2f") . readMaybe . unpack $ "200"
01:11:04 <Axman6> :t maybe ("-1.00") (Data.Text.pack . printf "%.2f") . readMaybe . Data.Text.unpack
01:11:05 <lambdabot> Not in scope: ‘readMaybe’
01:11:08 <Axman6> :(
01:11:12 <Axman6> @hoogle readMaybe
01:11:13 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe :: (i -> r -> a) -> Split t i r -> SplitM t j i -> SplitM t j a
01:11:13 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe' :: (r -> a) -> Split t i r -> Split t j (Maybe i) -> Split t j (Maybe a)
01:11:31 <Axman6> @hoogle Read a => String -> Maybe a
01:11:32 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
01:11:32 <lambdabot> Network.CGI readCookie :: (Read a, MonadCGI m) => String -> m (Maybe a)
01:11:32 <lambdabot> Network.CGI readInput :: (Read a, MonadCGI m) => String -> m (Maybe a)
01:11:38 <Axman6> ah, maybeRead
01:11:49 <Axman6> :t maybe ("-1.00") (Data.Text.pack . printf "%.2f") . maybeRead . Data.Text.unpack
01:11:51 <lambdabot> Not in scope: ‘maybeRead’
01:11:58 <Axman6> >_<
01:12:12 <Axman6> ok, let me find out where that actually is
01:12:50 <Axman6> :t maybe ("-1.00") (Data.Text.pack . printf "%.2f") . Text.Read.readMaybe . Data.Text.unpack
01:12:51 <lambdabot>     Couldn't match type ‘Data.Text.Internal.Text’ with ‘[Char]’
01:12:52 <lambdabot>     Expected type: String -> [Char]
01:12:52 <lambdabot>       Actual type: String -> Data.Text.Internal.Text
01:13:14 <Axman6> bleh, anyway, hopefully you can fix it from there =)
01:14:09 <_m_ryan> Axman6: what does this erro mean? - No instance for (PrintfType Text) arising from a use of printf
01:14:53 <k0ral> is there a plan to integrate part of semigroups/semigroupoids into base ?
01:15:04 <Axman6> bleh, right, let me just write come actual code and show you
01:15:24 <_m_ryan> Axman6: i done.. :-) thank you :-)
01:15:57 <Axman6> does that mean you got it working? (there's a problem with my code that will mean it always fails)
01:21:50 <Axman6> _m_ryan: http://lpaste.net/132521 has all the things you need (IU wasn't going to write it for you but then did such a poor job helping I felt obligated =)
01:23:04 <_m_ryan> Axman6: why do you mean that it's always fail?
01:23:12 <Axman6> (there's probably a really elegant way to do it with lenses)
01:23:35 <Axman6> the readMaybe will default to using the () instance of Read
01:24:00 <Axman6> and "200" will never be parsed as the text representing ()
01:24:10 <Axman6> > read "()"
01:24:12 <lambdabot>  ()
01:24:16 <Axman6> > read "200"
01:24:18 <lambdabot>  *Exception: Prelude.read: no parse
01:25:22 <_m_ryan> Axman6: thank you :-)
01:27:56 <Phillemann> Is there a "canonical" library for doing regular expressions with Data.Text?
01:28:23 <merijn> Phillemann: Not really, because afaik the canonical thing is to not use regexes
01:28:32 <Phillemann> I see.
01:29:00 <merijn> Depending on what you wanna do you might want attoparsec to replace your regex with a parser
01:29:27 <Phillemann> Ok, and attoparsec is fine with Data.Text, got it.
01:29:31 <Axman6> for most haskellers, if the question includesreference to regexes, the answer is definitely "use parsers instead". parser combinators are just as powerful (and much more so) and maintainable
01:30:11 <merijn> I think the confusion is usually that writing a parser in other languages is a bitch :p
01:30:19 <merijn> So people avoid it at all costs, I would too :p
01:30:33 <merijn> Whereas parser combinators are pretty damn easy
01:30:48 <Axman6> so easy
01:30:50 <Axman6> and fun
01:31:05 <Axman6> and did I say maintainable
01:31:10 <Axman6> and often self documenting
01:31:38 <Phillemann> I also despise regular expressions, mind you. I'm just trying to avoid writing a shell script in bash and just copied my mentality and my toolkit to haskell. :D
01:32:04 <frerich> Regular expressions are just a highly concise domain specific language for expressing patterns to match in some data. What's the problem? :-)
01:32:09 <Axman6> this is Haskell, we can do better! =)
01:32:29 <merijn> Hah, you know you've been infected once you start writing your shell scripts in haskell (not that I don/t... :p)
01:32:57 <Phillemann> merijn: bash scripts have a very low point of getting unmaintainable and not powerful enough for what you want to do ;)
01:33:39 <calvinx> yea, I concur. bash is easy to get in; but you run into edge case problems very quickly.
01:35:21 <tdammers> Phillemann: which, I argue, is a good thing, because you'll hit the point earlier where it makes sense to turn your bash script into a something written in a real language
01:35:37 <roelof> Is this a good course (http://www.seas.upenn.edu/~cis194/) or can I better do a older one ? 
01:35:51 <tdammers> ofc, too many people refuse to acknowledge it when they are hitting that point
01:36:14 <Axman6> @where learnhaskell
01:36:14 <lambdabot> https://github.com/bitemyapp/learnhaskell
01:36:36 <Axman6> roelof: see the above link (it recommends that course)
01:37:06 <Phillemann> tdammers: I also have that problem. And it ends up with ridiculous bash magic instead of a rewrite in a more powerful language.
01:37:50 <bernalex> I used to write stuff in python if my bash crap went over 10 lines. now my threshold is more like 3 lines, and my solution haskell.
01:37:53 <roelof> Axman6:  i recommends a older one spring 2013. Im talking about spring 2015 
01:38:29 <Axman6> oh, no idea. you'd probably have to ask bitemyapp (or head over to #haskell-beginners)
01:40:04 <roelof> I will goto haskell- beginners. Thanks for the help 
01:40:33 <bernalex> roelof: everyone I know who have seen the new one recommend the old one instead.
01:42:28 <roelof> bernalex:  thanks , is there a particular reason for that ? 
01:42:59 <bernalex> roelof: IDR. I think there were some bugs with it, and it progressed too fast. I have not looked at it myself though.
01:46:00 <roelof> oke, I found the old one progressed very soon
01:47:51 <calvinx> just saw this one week old announcement https://www.fpcomplete.com/blog/2015/05/school-of-haskell-2  Super awesome!
01:50:04 <tdammers> Phillemann: well, you need to be a somewhat decent programmer, and confident enough that you can actually do it in language X, and that doing it in language X is going to be easier than another maintenance cycle on the bash abomination you have built so far
01:50:17 <tdammers> miss that moment, and you're stuck with the bash monster forever
01:53:15 <bernalex> who doesn't have a line like
01:53:16 <bernalex> for user in "${!users_keywords[@]}"; do body=''; for key in "${users_keywords[${user}]}"; do body+=$(grep -i "${key}" <(grep -Ff <(diff <(awk '{print $NF}'  "${dir}"/pposts) <(awk '{print $NF}' "${dir}"/posts) | grep '^<' | cut -c 3-) "${dir}"/pposts))$'\n'; done
01:53:25 <bernalex> in a random bash script somewhere
01:53:53 <merijn> tdammers: tbh I find bash somewhat easier if I need to do a lot of process/redirection manipulation
01:55:26 <jle`> i use bash a lot
01:55:36 <bernalex> I changed to zsh recently
01:55:37 <jle`> the other day i used bash to run a program and then re-launch it when it exits
01:55:43 <jle`>  /crashes
01:55:53 <jle`> i don't think that would ahve been too fun in haskell
01:56:16 <jle`> down with haskell
01:56:26 <bernalex> I have been toying with making a bunch of aliases so that I can use ghci as my shell
01:56:51 <bernalex> I should look more closely at hell
01:57:08 <jle`> how about hawk
01:57:10 <tdammers> merijn: absolutely. but most tasks require more than that, and you quickly end up in a situation where more verbose shell redirect syntax is acceptable because the rest is going to be more solid
01:57:18 <jle`> i guess it's a different purpose than hell
01:58:28 <bernalex> jle`: haven't even herad of hawk, actually.
01:58:38 <bernalex> heard
01:58:52 <jle`> it's actually not scripting, so it was a bit of an out-of-place suggestion
01:59:13 <jle`> but it's basically a haskell drop-in for things like grep and awk for text filtering and processing at the shell
01:59:22 <jle`> grep, awk, head, sort, etc.
02:04:02 <bernalex> jle`: sounds useful. I was planning on making something like that myself, actually. I have a package called coreutilhs where I wrote self-contained minimum implementations of some programs. but I got distracted before making grep & ls (I think those are the only two major ones missing). my idea was to continue writing those, and keep it around as-is, since it's mostly written as tutorial-like mini-programs.
02:04:04 <bernalex> but then I wanted to make a proper haskell coreutils-like package.
02:04:37 <decentdog> Hi, can someone maybe explain this SO comment about Alex/Happy to me? http://stackoverflow.com/questions/20315739/how-to-use-an-alex-monadic-lexer-with-happy#comment43736717_20923330 
02:04:44 <bernalex> jle`: and then, later on, write a sort of bash-like library for autoloading with ghci, so you could use ghci as your sh.
02:04:52 <Darwin226> Hey. I'm trying to use MultiParamTypeClasses to model inheritence trees. I want to express transitivity (Inherits a b, Inherits b c => Inherits a c), how can I do that?
02:05:04 <decentdog> How does one write a pattern to match EOF?
02:05:08 <ion> "Any website will be able to include editable and runnable Haskell code." This is pretty cool.
02:05:25 <Darwin226> Because it want's me to use undecidableinstances, I guess because that instance matches everything
02:05:38 <ion> decentdog: From a list? Match the empty list.
02:05:52 <ion> Oh, i missed your earlier line.
02:10:44 <ion> Darwin226: Perhaps this might be of use. http://hackage.haskell.org/package/constraints-0.4.1.3/docs/Data-Constraint.html
02:15:59 <Darwin226> ion: It might. It'll probably take a while before I can figure out what's goin on there, though...
02:29:57 <z16> Does anyone know where the x:xs convention comes from?
02:30:53 <merijn> z16: You mean the names?
02:31:07 <z16> Yeah, why not first:rest or something
02:31:10 <merijn> z16: One thing, multiple thingS, one lamp, multiple lampS, one x, multiple xS
02:31:21 <z16> I see
02:31:36 <merijn> That's why you also see "a:as", "b:bs", etc.
02:31:50 <luzie> http://stackoverflow.com/questions/6267735/what-is-the-history-of-the-variable-names-x-and-xs
02:31:51 <bennofs> or (x:xs):xss
02:31:57 <merijn> I believe ocaml uses "h::t" for head and tail, but it's just convention
02:32:57 <merijn> z16: Mostly it's because "first" and "rest" aren't a lot more informative than x/xs and are longer names. If there's a specific meaning I might name list entries differently, but the more abstract your code, the less of a sensible name you can give list entries
02:33:00 <z16> merijn: I actually saw x::xs in OCaml first, many years ago
02:33:23 <bennofs> first is also a bad name since it's already used in Control.Arrow for other things
02:33:29 <merijn> z16: The advantage of shorter variables in generic code is that it becomes easier to see the "shape" of the expression
02:33:39 <merijn> Although there's a rule of diminishing returns here, of course :p
02:34:51 <shock_one> Why do functional languages rely on singly-linked lists so heavily? Wouldn't it be nice to have the same language support for, say, dictionaries, arrays and trees. Also, do you know a functional language that treats those as first-class citizen? 
02:34:51 <bergmark> typechecking also makes variable names less important
02:35:54 <merijn> shock_one: The problem is that dictionaries rely on a sorting internally for lookups, so directly exposing the constructors is dangerous, since users may invalidate the internal invariants
02:35:55 <tdammers> shock_one: singly-linked lists have some nice properties that are particularly useful in combination with immutable state
02:36:27 <tdammers> for example, you can take a tail of a singly-linked list without making a copy and without modifying the original list
02:36:34 <merijn> shock_one: With recent GHC extensions like PatternSynonyms it's becoming possible to provide "read-only" constructors for things like Map which would make it easier to work with like lists
02:36:35 <tdammers> (as long as everything is immutable, that is)
02:36:54 <srenatus> hi there. say, for some reason, I'm building an app that re-uses some java cli program.  How would I distribute it? I suspect the usual cabal route is impossible, isn't it?
02:37:05 <tdammers> you can prepend ("cons") elements to a list without modifying the original list, too, and again you don't need any copying
02:37:42 <tdammers> and in Haskell, defaulting to laziness effectively turns our singly-linked list into a loop construct
02:38:08 <merijn> shock_one: Yeah, another reason why lists are popular is
02:38:13 <shock_one> tdammers, I understand the pros, but, for example, it's hard to take the last element, or to append two lists, or to fold from the right side.
02:38:20 <merijn> @quote Cale loops
02:38:21 <lambdabot> Cale says: You should think of lists as being like loops which are waiting to happen.
02:38:44 <shock_one> All of those are very useful operations.
02:38:50 <merijn> shock_one: appending two lists is easy, last is not, but neither is it with a linked list in other languages
02:38:59 <merijn> shock_one: Right, but maybe you're wanting Seq?
02:39:16 <merijn> shock_one: From Data.Sequence
02:39:25 <merijn> That has cheap append and cheap acces to head and tail
02:39:29 <shock_one> merijn: appending is easy in theory. In Haskell it's O(m).
02:39:50 <merijn> shock_one: It's not, or it might be, depending on what you do...
02:40:09 <merijn> It's not O(m) in any meaningful understanding of the word
02:40:18 <liste> srenatus you could embed the binary in your executable and extract it somewhere when running
02:40:33 <shock_one> m is the length of the left-hand-side list.
02:40:34 <liste> http://stackoverflow.com/questions/6402158/how-to-compile-a-resource-into-a-binary-in-haskell
02:40:52 <merijn> shock_one: You forget to account for laziness, take: "print . map (+1) $ [1..10] ++ [11..20]"
02:41:10 <merijn> shock_one: This would traverse the list twice in a strict language, but only traverses it once in haskell
02:41:29 <merijn> So you can amortise the append with the map, making the amortised complexity for ++ O(1)
02:41:50 <shock_one> merijn: in quick sort you need to append a lot. Does laziness help here?
02:42:23 <merijn> shock_one: I don't know the answer, but a more relevant remark is: quicksort is terrible for languages like haskell
02:42:46 <merijn> The main (only!) advantage of quicksort are: 1) cache friendliness and 2) constant memory use
02:43:03 <merijn> But since Haskell is immutable you can't sort in place, so you lose both 1 and 2 trying to implement quicksort!
02:43:33 <liste> srenatus or the data-files: attribute of .cabal file
02:43:49 <liste> https://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-data-files-from-package-code
02:43:55 <merijn> Mergesort is a MUCH better sort of a language like haskell, since the copies/extra memory it uses you need ANYWAY due to immutability, and mergesort has a much better worst case complexity than quicksort
02:43:56 <srenatus> liste: thanks for the pointers, perfect
02:45:48 <shock_one> merijn: can we return to invariants of dictionaries? I'm not sure I understand that message.
02:46:56 <merijn> shock_one: Maps are implemented using balanced trees (there's a hashmap library, but it's not the most common one because on average Map is more efficient)
02:47:22 <Roelof> I want to convert a number to a list like this 123 becomes [1.2.3] . A number of zero or lower makes a empty list.  Is there a way with pattern matching that I can check this ? 
02:47:31 <Roelof> or do I need to use a guard ? 
02:47:36 <shock_one> merijn: to summarize about lists: 1. They have useful for performance properties in immutable languages; 2. Laziness reduces complexity of appending.
02:47:47 <merijn> shock_one: So the lookup/insert/everything implementation rely on the elements in the Map having a "proper" ordering. If we exported the constructors any programmer could construct a Map with no sorting at all, breaking the "sorted invariant" that all the implementations rely on
02:48:28 <merijn> shock_one: I would say they have useful algorithmic properties in languages, the fact that immutability makes them more efficient than in other languages is more of a bonus
02:48:44 <shock_one> merijn: isn't that solvable to have a sortable restriction on the element type?
02:48:52 <shock_one> *by having.
02:48:56 <liste> Roelof you could check each digit separately but a guard is better
02:48:59 <merijn> shock_one: Not if the constructors are exposed
02:49:10 <liste> s/check/match/
02:50:15 <Roelof> Oke, so make a guard that the number <= 0 and one which checks if the number > 0 so there will be two "things"
02:50:28 <merijn> shock_one: "data Tree a = Leaf | Branch a (Tree a) (Tree a)", lets say we sort smallest elements left than we'd expect a tree with elements 1 2 3 to look like "Branch 2 (Branch 1 Leaf Leaf) (Branch 3 Leaf Leaf)" or "Branch 1 Leaf (Branch 2 Leaf (Branch 3 Leaf Leaf))" for example
02:50:55 <merijn> shock_one: But with the constructors exported I could write "Branch 3 Leaf (Branch 1 (Branch 2 Leaf Leaf) Leaf)"
02:51:08 <merijn> shock_one: And a sortable restriction on elements doesn't help you stop that
02:53:17 <shock_one> merijn: Thank you for the explanation, it's clear now. But it's definitely not a show-stopper. We could have a "wrapper" constructor representing the whole tree, for example.
02:54:15 <merijn> shock_one: Well, like I said the recent PatternSynonyms extension in GHC (since 7.8, I think?) allows you to create "read-only" constructors, would which let us expose constructors without giving the ability to construct faulty values
02:54:36 <mjrosenb> does GHC.StaticPtr not export StaticPtr?
02:54:38 <shock_one> It would be very useful to be able to pattern match like "a dictonary having a certain key with a certain value" using a convenient syntax.
02:54:45 <merijn> shock_one: I can highly recommend browsing throught the GHC manual's extension section, there's loads of new stuff to be found there :)
02:55:12 <merijn> shock_one: PatternSynonyms, ViewPatterns and PatternGuards may be of interest :)
02:55:32 <mjrosenb> merijn: aren't PatternGuards in haskell98?
02:55:34 <shock_one> merijn: I will. Is it a widespread practice to use the extensions in production?
02:55:47 <mjrosenb> or is there an extension that adds more functionality to them?
02:56:11 <merijn> mjrosenb: Oh, PatternGuards might be in haskell2010
02:56:14 <mjrosenb> shock_one: since there is effectively only one production haskell compiler, I suspect most people don't worry about portability.
02:56:27 <merijn> shock_one: Yes, lots of production code uses GHC extensions
02:56:36 <merijn> mjrosenb: There's at least 2 production haskell compilers
02:56:44 <kuribas`> merijn: Aren't PatternSynonyms read/write?
02:56:44 <merijn> However only one of them is currently publicly available :p
02:56:54 <merijn> kuribas`: You can create read only synonyms
02:56:57 <shock_one> kuribas`: what's the other one?
02:57:14 <mjrosenb> merijn: interesting, there is a closed source haskell compiler?
02:57:21 <merijn> shock_one: Standard Chartered Bank has an internal haskell compiler called Mu
02:57:35 <merijn> They supposedly have about 1.5 million lines of GHC haskell and 1 million lines of Mu haskell
02:58:32 <merijn> Then there's UHC, the Utrecht Haskell Compiler, which I think is the only other public compiler that comes somewhat close to being a GHC alternative
02:58:57 <mjrosenb> at one point or other, there was YHC?
02:59:03 <mjrosenb> and nhc
02:59:16 <merijn> Last I talked to the Utrecht people they're about to finish a big refactor that would make implementing most GHC extensions more feasible
02:59:26 <kuribas`> shock_one: For example with ViewPatterns you would do "let test (Just a <- lookup key dict) = doSmt; test _ = doSmtElse
02:59:28 <merijn> mjrosenb: Sure, and hugs, but I don't think any of those are really active
03:00:16 <merijn> mjrosenb: UHC still has active development, but they don't get paid (and those don't invest a lot into) to make it a "production" compiler
03:00:25 <mjrosenb> kuribas`: don't you need a pattern in there that isn't part of the view?
03:00:40 <mjrosenb> merijn: interesting, I haven't seen it available on any distros for a while.
03:00:51 <kuribas`> oh, right!
03:01:06 <kuribas`> let test (Just a <- lookup key) = doSmt; test _ = doSmtElse
03:01:29 <merijn> shock_one: Anyway, GHC takes a very conservative approach in that, by default it is (mostly) compliant with the Haskell Report 2010 (as opposed to, for example gcc, which enables gcc specific features by default)
03:01:55 <CurryWur_> hi guys!
03:01:58 <merijn> shock_one: The standardisation process is more "let's try things using extensions and if people can agree on which bits are useful we'll standardise them"
03:02:05 <CurryWur_> can anyone help me with one function
03:02:38 <merijn> shock_one: But standardisation only makes a lot of sense in the presence of multiple compilers and with GHC being the main one anyone cares about there's not a lot of incentive to update the report while everyone is happy to just write "GHC Haskell"
03:02:41 <CurryWur_> http://lpaste.net/132371
03:02:57 <CurryWur_> pngr1 - Random number generator
03:03:04 <CurryWur_> I didn't get what should I do
03:03:14 <shock_one> I'm sorry, I have to run. Hope to return soon.
03:03:37 <CurryWur_> find2Pow and prng are already implemented
03:03:45 <CurryWur_> but I don't know how to bring that all together
03:03:49 <mauke[1]> CurryWur_: find2Pow 1 should be 1
03:05:23 <mauke[1]> CurryWur_: "sort" makes no sense in that context
03:07:02 <Roelof> What is wrong on this part (++ [toDigits number `mod` 10]  ) of this code ; http://lpaste.net/132530
03:07:39 <mauke[1]> CurryWur_: was this written by a native english speaker?
03:07:45 <CurryWur_> no :)
03:07:49 <CurryWur_> sorry
03:08:14 <mauke[1]> damn, I was hoping for french or something but you have an .at hostmask
03:08:19 <CurryWur_> in was a translation from German and both German and English are not my native languages
03:08:20 <mjrosenb> Roelof: that is not getting parsed the way you wantit to
03:08:36 <mauke[1]> CurryWur_: ah! "aussortieren"?
03:08:36 <CurryWur_> so, I didn't got the whole idea :(
03:08:41 <mauke[1]> do you have the original text?
03:08:45 <CurryWur_> and stuck
03:08:47 <mjrosenb> Roelof: also, toDigits returns a list, there is no reason to 
03:08:51 <mjrosenb> Roelof: uhhh...
03:08:52 <Roelof> mjrosenb:  yes, but I do not see why not 
03:09:19 <mjrosenb> Roelof: toDigits number `mod` 10 gets parsed as (toDigits number) `mod` 10
03:09:22 <Roelof> nope , It must return one number in a list and the rest of the number ? 
03:09:35 <mjrosenb> Roelof: also, you should not be calling toDigits twice.
03:09:42 <mjrosenb> that is quite wrong.
03:10:09 <Roelof> mjrosenb:  I see it , stupid mistake 
03:10:36 <merijn> mauke[1]: Someone named "CurryWur" and your thought is "French"? >.>
03:11:22 <mauke[1]> merijn: I was going by the text of the exercise
03:14:07 <kuribas> Roelof: That would never work. You need to rethink your function.
03:15:07 <Roelof> I have figured it out but the reverse one : http://lpaste.net/132531
03:16:41 <ion> Associated pattern synonyms would be nice. data Foo a = Foo a where { pattern Bar ... }, data Foo a where { Foo :: a -> Foo a; pattern Bar ... }. They would be exported and imported along with the type, and users could import them selectively without LANGUAGE PatternSynonyms.
03:17:59 <kuribas> Roelof: use reverse :)
03:21:18 <Roelof> kuribas:  I did it this way : http://lpaste.net/132532
03:22:01 <kuribas> Roelof: That's log(n) on the number of digits.
03:22:12 <kuribas> O(n^2) I mean...
03:22:57 <kuribas> Roelof: If you don't like reverse, you could use an accumulator.
03:23:22 <Roelof> sorry : what does that mean. Im a beginner in programming and I do not understand the O(n^2) thing ?
03:24:03 <kuribas> Roelof: It means that appending to the list at every step is inefficient.
03:24:14 <mauke[1]> that means: as the size of the input (n) grows, your algorithm takes n^2 steps of work
03:24:26 <kuribas> Roelof: Since append needs to walk the whole list.
03:24:33 <Phillemann> http://lpaste.net/132533 - isn't there something like this already? Or is there a cooler way to write it? :D
03:25:11 <kuribas> Phillemann: fmap?
03:25:17 <mauke[1]> :t uncurry (fmap . (,))
03:25:18 <lambdabot> Functor f => (a1, f a) -> f (a1, a)
03:25:45 <Phillemann> Interesting...
03:25:50 <kuribas> :t fmap id
03:25:52 <lambdabot> Functor f => f b -> f b
03:26:04 <kuribas> fmap id (1, Maybe 2)
03:26:08 <kuribas> > fmap id (1, Maybe 2)
03:26:10 <lambdabot>      Not in scope: data constructor ‘Maybe’
03:26:10 <lambdabot>      Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
03:26:18 <kuribas> > fmap id (1, Just 2)
03:26:20 <lambdabot>  (1,Just 2)
03:26:26 <kuribas> > fmap id (1, Nothing)
03:26:27 <lambdabot>  (1,Nothing)
03:26:36 <calvinx> What does this warning from ghc-mod mean? — This binding for ‘text’ shadows the existing binding imported from ‘Text.Blaze’ at MyFile.hs (and originally defined in ‘Text.Blaze.Internal’)
03:26:37 <Roelof> what is then a better way , Only use : 
03:26:43 <Roelof> kuribas:  you only mean the revtoDigits 
03:26:51 <kuribas> Roelof: yes
03:27:12 <Roelof> kuribas:  so I better not use the ++ thing if I understand you 
03:27:27 <kuribas> Roelof: Not in this case.
03:27:58 <kuribas>  Roelof: Append is fine if you do it once, not if you do it every step.
03:28:49 <calvinx> Ok, figured it out. Just have to rename my variable name so it doesn
03:28:51 <calvinx> ‘’t collide
03:29:01 <ion> Right
03:29:48 <mjrosenb> gah, some of the sample code in https://ocharles.org.uk/blog/guest-posts/2014-12-23-static-pointers.html seems to not be working
03:29:50 <Roelof> kuribas:  ^^^
03:32:43 <ion> Phillemann: Incidentally, the primitive for Applicative could be (F a, F b) -> F (a, b) (in addition to a -> F a). This is exactly the power Applicative provides over Functor's (a, F b) -> F (a, b).
03:33:50 <kuribas> > fmap (set _2) . view _2 (1, Just 2)
03:33:51 <lambdabot>      Couldn't match type ‘a -> f b0’ with ‘Maybe a1’
03:33:51 <lambdabot>      arising from a functional dependency between:
03:33:51 <lambdabot>        constraint ‘Field2
03:33:59 <kuribas> > fmap (set _2) . view _2 $ (1, Just 2)
03:34:00 <lambdabot>      No instance for (Typeable t0)
03:34:00 <lambdabot>        arising from a use of ‘show_M746040167994084922010979’
03:34:00 <lambdabot>      In the expression:
03:35:15 <ion> (Well, the latter could not be the Functor primitive.)
03:35:40 <Roelof> does it work now ?
03:35:55 <Roelof> kuribas ; is this better : http://lpaste.net/132535
03:37:28 <Roelof> test 
03:39:29 <kuribas> Roelof: That's worse...
03:39:54 <Roelof> oke, can you help me to figure out a better way 
03:40:05 <Roelof> kuribas:  you said to use reverse 
03:40:24 <kuribas> Roelof: Yes, and I said not to use append (++)...
03:41:12 <Roelof> oke, what is a better way to not use append in this case ?  kuribas  
03:42:14 <kuribas> Roelof: What you had first using cons (:) was fine.  You just need to reverse the result.
03:42:25 <Roelof> pieter_:  finnaly a dutch person who is in the neighbourhood from me 
03:43:07 <Roelof> oke, so let the reverse as it is and make the other one reverse  ?
03:44:13 <kuribas> Roelof: yes
03:44:38 <Roelof> moment. I have to rethink how to reverse looked like 
03:47:59 <Roelof> kuribas:  now happy http://lpaste.net/132537
03:48:45 <mjrosenb> ahh, this is a syntactic extension.
03:48:53 <kuribas> Roelof: That looks much better!
03:49:22 <kuribas> :t fix
03:49:23 <lambdabot> (a -> a) -> a
03:49:33 <Roelof> oke, thanks for learning me these things, In the future I hope I will be a good haskell programmer 
03:50:33 <mjrosenb> Roelof: fwiw, you can also do something similar without reversing the list.
03:50:43 <kuribas> Roelof: Keep learning :)
03:50:58 <Roelof> mjrosenb:  can you give a tip how to do that 
03:51:28 <mjrosenb> Roelof: you'll want its type to be [Int]->Int->[Int]
03:51:29 <Roelof> I wonder : can this also be done with things like map ? 
03:52:14 <Roelof> mjrosenb:  no , the exercise of cis194 says the type is integer -> [Integer] 
03:52:19 <mjrosenb> Roelof: kind of?
03:52:58 <mjrosenb> Roelof: well, you have a helper function here, you'll just want a wrapper function to give it the right type.
03:53:29 <Roelof> mjrosenb:  sorry I do not understand which direction you want 
03:54:23 <mjrosenb> Roelof: so, in revToDigits, you have number `mod` 10 : revToDigits ...
03:54:53 <Roelof> mjrosenb:  yes 
03:55:00 <mjrosenb> which is bad, because you're adding the least significant digit to the start of the list, when you want to add it to the end.
03:55:35 <mjrosenb> then you call yourself on the higher digits, shifted down by one.
03:56:15 <mjrosenb> so if the top level called revToDigits 31415, and you are currently evaluating revToDigits 415
03:56:18 <Roelof> mjrosenb:  yes, but according to kuribas its better not to use ++  and I do not know another way to add to the end 
03:57:02 <mjrosenb> your return value will have (1:) and then (3:) applied to it.
03:57:23 <Roelof> yes, so far it's logical 
03:58:25 <mjrosenb> so, what if rather than letting the return value from this function have things added onto it, you just hung onto all of the things you wanted to add
03:58:35 <Roelof> and we want the 3 before the 1 so we can use : 
03:59:30 <Roelof> mjrosenb:  you mean the same way as append work 
03:59:38 <mjrosenb> Roelof: not quite
03:59:49 <Yuu-chan> Roelof: you can add to the front and finally reverse the whole list
04:00:27 <mjrosenb> so when we call toDigitsSpecial x 415, we want to explicitly pass in both 3 and 1, so it can modify the value itself.
04:00:39 <Roelof> oke, so the same as toDigits and on a empty list I reversed the list 
04:01:36 <Roelof> mjrosenb:  where does the x coming from 
04:02:51 <mjrosenb> Roelof: well, you'll need to pass it in (including when you call it recursively)
04:03:18 <mjrosenb> Roelof: so in this case, what would the base case look like?
04:03:34 <Roelof> mjrosenb:  or are you trying to teach me working with a accumenlator ? 
04:04:06 <Roelof> mjrosenb:  the base case is when the number is 0 . then the whole number is converted 
04:04:22 <Roelof> the base case does not change from what I use 
04:04:24 <mjrosenb> Roelof: that's the idea.
04:04:31 <mjrosenb> (the accumulator)
04:05:32 <Roelof> oke, so we make two functions one for a zero or less and one other function with a accumenlator to store the result 
04:05:38 <mjrosenb> oh, snap, I've been chopping off digits from the wrong end.
04:06:02 <Roelof> I will hit the books to learn more about accumenlators 
04:06:27 <mjrosenb> ok, so if in toDigitsAcc x 314 = .., x somehow or other contains 1 and 5, what will x contain when the recursion hits 0?
04:06:49 <Roelof> x is the accumenlator ? 
04:07:22 <Roelof> then it will contain the 1 and 5 like this [ 5,1]  
04:08:06 <mjrosenb> Roelof: it had those after we'd removed both 1 and 5 from the number, would it stil contain only 1 and 5 after we'd also removed 4, 1, and 3 from it?
04:09:14 <Roelof> nope, then it would contain [ 5,1,3,1,4] 
04:10:06 <mjrosenb> let's not concern ourselves with the order at the moment, but it will contain the numbers 1, 1, 3,4,5 in *some* order
04:10:18 <Roelof> correct 
04:10:30 <mjrosenb> so in the base case, would you return the empty list, or something else?
04:10:58 <Roelof> mjrosenb:  I would return the accumenlator  which you named x 
04:11:50 <mjrosenb> right!
04:12:07 <Roelof> Did I get a 6 out of 10 :) 
04:12:11 <mjrosenb> so, now what would the non-base case look like?
04:12:52 <Roelof> acc : revtoDigits number 'div' 10 
04:13:13 <mjrosenb> you'd want toDigitsAcc x number = ... toDigitsAcc ..., since we'll definitely be calling ourself recursively
04:14:16 <Roelof> mjrosenb:  toDigitsAcc x number = .x toDigitsAcc (number `div' 10) ?.
04:14:29 <Roelof> without the .  after the = 
04:14:55 <mjrosenb> let's say we're one step away from the base case, up at the top level, someone alled toDigitsAcc x 31415, and now we're evaluating toDigitsAcc x 3.
04:15:18 <mjrosenb> Roelof: keep in mind, toDigitsAcc takes a list of integers as its first argument
04:15:40 <mjrosenb> Roelof: also, what did we say x was going to be when we got to the base case?
04:16:08 <mjrosenb> you should probably make sure that it contains the same numbers that you said it would earlier.
04:16:39 <Roelof> In that case it would be [1,4,5] toDigitsAcc 0 
04:17:11 <Roelof> Now I get confused by all the numbers and functions 
04:17:58 <Roelof> but I think I see what you are trying to teach me. I will try to implement this today or tommorrow  and showed you 
04:18:17 <Roelof> now Its time for lunch. my head is spinning now 
04:18:38 <Roelof> mjrosenb:  but many thanks for learning me this 
04:18:48 <mjrosenb> Roelof: no problem
04:19:05 <mjrosenb> can ghc do any pointer equality optimizations?
04:19:37 <bennofs> mjrosenb: what do you mean by this? optimizing == to do a fast check for pointer equality?
04:19:46 <mjrosenb> bennofs: yes.
04:20:08 <bennofs> mjrosenb: there is a reallyUnsafePtrEq# primop that you can use to optimize your own Eq instances
04:20:26 <mjrosenb> like, I will have an == between two [Char]s, and 99.9% of the time, it will be the exact same value.
04:21:48 <mjrosenb> and of course, traversing a large list will be slow, and not give any useful information if they are the same list.
04:22:33 <fractalsea> If I have a sum type with 0 argument value constructors, how do I automatically generate a FromJSON intsance where JSON strings correspond to the constructor names?
04:22:37 <bennofs> mjrosenb: well, you need to write your own equality test function in this cases, using the reallyUnsafePtrEq# primop
04:22:56 <bennofs> mjrosenb: if you want to have more "stable" pointers (GC will relocate objects), you can also use StablePtr
04:23:29 <mjrosenb> hrmm, this is already kind of in IO, so I can use a StablePtr
04:26:23 <mjrosenb> :t reallyUnsafePtrEq#
04:26:24 <lambdabot> Not in scope: ‘reallyUnsafePtrEq#’
04:26:28 <mjrosenb> :-/
04:26:59 <liste> fractalsea something along the lines of instance ToJSON Foo where toJSON = genericToJSON defaultOptions { allNullaryToStringTag = True } (untested)
04:27:36 <Cale> mjrosenb: I'm pretty sure it's reallyUnsafePtrEquality# isn't it?
04:27:37 <comerijn> Of course that's not in scope
04:28:03 <liste> except from instead of to
04:28:37 <mjrosenb> :t reallyUnsafePtrEquality#
04:28:38 <lambdabot> Not in scope: ‘reallyUnsafePtrEquality#’
04:28:39 <mauke[1]> allNullaryToStringTag   = True is default already
04:29:30 <fractalsea> liste: Great, thanks I’ll give that a go
04:30:03 <liste> fractalsea see what mauke[1] said, maybe you don't even need to do that
04:30:28 <fractalsea> mauke[1], cool thanks
04:37:27 <coin3d> hello. what does the typeclass integral stand for? 
04:38:17 <mauke[1]> @src Integral
04:38:17 <lambdabot> class (Real a, Enum a) => Integral a where
04:38:17 <lambdabot>     quot, rem, div, mod :: a -> a -> a
04:38:17 <lambdabot>     quotRem, divMod :: a -> a -> (a,a)
04:38:17 <lambdabot>     toInteger       :: a -> Integer
04:38:20 <comerijn> For types that are integral values?
04:38:47 <mauke[1]> coin3d: it stands for integral
04:40:36 <nyuszika7h> why is the product of an empty list 1?
04:40:54 <mauke[1]> because product (x : xs) = x * product xs
04:41:01 <comerijn> nyuszika7h: Because 1 is the identity values for multiplication
04:41:06 <mauke[1]> thus product (42 : []) = 42 * product []
04:41:14 <nyuszika7h> oh, that makes sense
04:41:42 <mauke[1]> > 42 ^ 0
04:41:43 <lambdabot>  1
04:41:56 <mauke[1]> same thing, more or less
04:43:59 <aloiscochard> mietek: hi, are you around?
04:44:38 <coin3d> mauke[1]: argh, i should have looked for the translation for integral number, before asking :D
04:45:43 <mauke[1]> ganz genau
04:48:23 <aloiscochard> mikel: as halcyon is using a global sandbox, how is it possible to work on two different projects in parallel?
04:48:42 <aloiscochard> also I have to `ln -sf /app/sandbox/cabal.sandbox.config cabal.sandbox.config` in every project where I want to use halcyon
04:48:59 <aloiscochard> is there a neater way to get the right sandbox in the project folder?
04:52:46 <aloiscochard> (okay I have found that https://github.com/mietek/halcyon/issues/47 to answer some of my questions)
04:57:06 <ttt_fff> in haste, what is the behavior when the websocket (for auto serializing data) disconnects?
04:57:44 * hackagebot stackage-metadata 0.2.0.0 - Grab current metadata for all packages  http://hackage.haskell.org/package/stackage-metadata-0.2.0.0 (MichaelSnoyman)
04:57:45 <mjrosenb> bennofs: hey, you've done stuff with ReactiveBanana, do you know what trim and switch do?
04:58:49 <bennofs> mjrosenb:  http://apfelmus.nfshost.com/blog/2012/09/03-frp-dynamic-event-switching-0-7.html have you seen this already?
05:01:13 <mjrosenb> bennofs: ahh, no, I have not
05:01:21 * mjrosenb only tried to read the haskell docs
05:01:30 <mjrosenb> and that wansn't really enlightening
05:01:35 <mjrosenb> nor was the source.
05:02:21 <bennofs> mjrosenb: hmm? it's for dynamic event switching. trim is a function that converts an event so it can start at any time
05:03:59 <bennofs> mjrosenb: so if you have x <- trim $ accumE a0 ev, x  will only start accumulating events when it is "started"
05:04:10 <bennofs> mjrosenb: and event is started as soon as it's needed by switch
05:05:04 <bennofs> mjrosenb: switch can be used to switch to a different "pipeline" based on events. so it can be used to have dynamic event networks
05:05:50 <gcganley> what are we discussing?
05:06:04 <bennofs> gcganley: switchE / trimE from reactive-banana
05:06:43 <gcganley> bennofs: oh ok, ive never used FRP before but it looks super interesting
05:06:59 <mjrosenb> bennofs: ok, so trim just says "this won't be needed until later", and that is a function of the rest of the code, not an argument to trim.
05:09:08 <bennofs> mjrosenb: no, it affects the behavior. say for example that you have a timer event t :: Event t Int which occurs every 1 second with the current value of the timer. Then you can do switchE (x <$ filterE (== 3) t)
05:10:03 <bennofs> mjrosenb: now let x be defined as x <- trimE $ accumE 0 (succ <$ timer) 
05:11:32 <bennofs> mjrosenb: then the switch's first event occurrence will have the value 1 or 0 (not quite sure which one atm) but not 3 / 4
05:11:50 <bennofs> mjrosenb: because the event x will only start accumulating timer events when it is "switched in"
05:12:21 <bennofs> mjrosenb: this behavior is required, since otherwise reactive-banana would have to keep the history of all events
05:13:25 <mjrosenb> how is accumE 0 (succ <$ timer) different from trim $ accumE 0 (succ <$ timer)?
05:13:39 <bennofs> mjrosenb: for one, the type differs
05:13:48 <bennofs> mjrosenb: without the trim, it will not typecheck
05:14:06 <mjrosenb> gah, Moment
05:15:13 <bennofs> mjrosenb: the event x itself starts when the network is actuated. it will count timer events from the start
05:15:55 <bennofs> mjrosenb: 'trim' will now discard some of that history, and let the event only start after some time later when it's used by the switch
05:17:27 <bennofs> mjrosenb: also see http://apfelmus.nfshost.com/blog/2011/05/15-frp-dynamic-event-switching.html
05:18:12 <bennofs> mjrosenb: the trim/switch combination implements "Solution 1"
05:30:55 <coin3d> why is it better to do null [] instead [] == [] ?
05:31:20 <merijn> coin3d: The latter only works on list that are Eq instance
05:31:32 <gcganley> :t null
05:31:33 <lambdabot> Foldable t => t a -> Bool
05:31:34 <merijn> :t \x -> x == []
05:31:35 <gcganley> :t (==)
05:31:35 <lambdabot> Eq t => [t] -> Bool
05:31:36 <lambdabot> Eq a => a -> a -> Bool
05:32:11 <merijn> coin3d: So suppose you have a list of File handles (or something else that is not an Eq instance) then "x == []" won't typecheck
05:32:11 <ronh->  `\
05:32:44 <coin3d> merijn: ok, thanks
05:36:21 <indiagreen> how can I open a link in the default browser? (should work on Windows as well)
05:36:35 <indiagreen> code here doesn't look good at all: http://hackage.haskell.org/package/hledger-0.23.3/docs/src/Hledger-Cli-Utils.html#openBrowserOn
05:43:56 <Aleksejs> Hi, I have a problem with IRC bot. I used this tutorial https://wiki.haskell.org/Roll_your_own_IRC_bot/Source as a base, did a lot of modifications, and also I added utf8 encoding to IO handle. The problem is that bot crashes once someone sends scaron symbol http://www.webune.com/forums/scaron-html-code.html from XChat, that by default has latin/hybrid encoding. Any ideas how to fix it?
05:43:59 <fvgvxmpv1> maybe try xdg-open on unixoids and start (http://www.quora.com/What-is-the-equivalent-of-xdg-open-on-Windows) on windows?
05:45:41 <fvgvxmpv1> (indiagreen)
05:48:10 <indiagreen> fvgvxmpv1: thanks, going to try it
05:54:15 <indiagreen> fvgvxmpv1: okay, it works
06:10:25 <indiagreen> is OS X always going to be “darwin_HOST_OS” or are there other options?
06:12:11 <geekosaur> I don't expect Apple to replace the base OS any time soon
06:13:51 <fvgvxmpv1> indiagreen, maybe don´t switch based on os, but just try everything and see what sticks? ^.^
06:14:13 <indiagreen> sorry, wrong wording – I meant, are there other options now, not “will there be other options in the future”
06:14:53 <kadoban> ByteString says it has O(1) index (:: ByteString -> Int -> Word8) is there good constants on that, or? I'm wondering if I should convert something into an unboxed Array, or just use the ByteString? All I need is /lots/ of indexes into it.
06:16:02 <ChristianS> kadoban: ByteString's index method should be fine then
06:16:55 <geekosaur> strict ByteString is just a flat chunk of memory, indexing should be O(1) with the only relevant constant being the address of the ByteArray#
06:17:04 <fvgvxmpv1> wouldn´t you expect an unboxed list to have better constants (conversion should more than alleviate the advantage, though)
06:17:17 <kadoban> Alrighty, thanks guys
06:17:22 <geekosaur> Haskell lists are singly-linked lists, not arrays
06:18:09 <absence> if you split a list on some item and collect the pieces, then perform an operation on each piece, then merge them back together interspersed with the split item, that's kind of functor-ish. is there some library or pattern that works like this? i'm instantly thinking of lens :p
06:21:36 <indiagreen> absence: yeah, there's “worded” and “lined” that do what you want, but I'm not sure there's a general version
06:27:56 <Melvar> Out of curiosity: Is there a particular reason that Data.Char.isAlphaNum includes Marks even though neither isAlpha nor isNumber do, and is there a particular reason this is not documented in its haddock?
06:28:20 <absence> indiagreen: cool, i'll investigate those. thanks!
06:29:32 <michaelt_> > "hello world" & over worded (drop 2)
06:29:34 <lambdabot>  "llo rld"
06:30:51 <indiagreen> absence: see http://lpaste.net/132546
06:31:45 <hodapp> today, I shall try to figure out... generics.
06:31:46 <hodapp> again.
06:33:01 <michaelt_> indiagreen: swank, this "splitted"
06:34:10 * indiagreen should've just called it “g” or something
06:37:47 * hackagebot cabal-debian 4.27.2 - Create a Debianization for a Cabal package  http://hackage.haskell.org/package/cabal-debian-4.27.2 (DavidFox)
06:42:39 <c_wraith> yay space leaks.  I suppose I deserve this for calling them "no big deal when you know what you're doing".
06:44:42 <mietek> aloiscochard: I was not around; please join #haskell-deployment, where others may assist you, as well
06:44:50 <kadoban> c_wraith: Yeah, that was probably tempting fate :-/
06:45:21 <c_wraith> I know exactly *what* introduced this space leak, but I don't know *why*...  so I can't fix it while retaining the functionality
06:46:29 <int-e> Melvar: I don't see a reason, and the Haskell report doesn't mention anything about it. Perhaps raise it on ghc's Trac? FWIW, this behavior is unchanged since 2005, when the base library got its own unicode character class implementation.
06:48:57 <indiagreen> Melvar: say if you aren't interested in raising it on Trac, I would do it for you then
06:49:01 <mauke[1]> > filter isAlphaNum ['\0' ..]
06:49:03 <lambdabot>  "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\170\178\179\...
06:49:18 <int-e> (see https://github.com/ghc/packages-base/commit/1e076454862442966918e6b1b9095e43eab7c770 is the commit)
06:49:21 <Melvar> int-e: Okay, thank you. In the case at hand, the behavior happens to be convenient, and I am not against it in general, but I feel it should be documented in an obvious place.
06:49:58 <Melvar> > isAlphaNum '̈'
06:49:59 <lambdabot>  True
06:50:10 <Melvar> > generalCategory '̈'
06:50:12 <lambdabot>  NonSpacingMark
06:54:00 <Melvar> indiagreen: If you would, that would be nice. As Surprising Behavior; I wouldn’t immediately say it’s incorrect.
07:00:23 <indiagreen> Melvar: https://ghc.haskell.org/trac/ghc/ticket/10412
07:01:11 <indiagreen> (it says “bug”, but I didn't choose anything in “Type of failure” because we don't know whether it's a documentation bug or code bug)
07:02:30 <bananagram> :t generalCategory
07:02:31 <lambdabot> Char -> GeneralCategory
07:18:31 <benzrf> tfw i see 'category' and think of math
07:21:21 <Big_G> How often is Haskell used for CRUD apps? I have to imagine database stuff is a pain
07:21:36 <Clint> often
07:21:57 <c_wraith> database is no more of a pain than in any other language
07:22:11 <Big_G> c_wraith, Agreed but most others have tools like hibernate
07:22:34 <c_wraith> hibernate isn't a win as soon as you do anything more interesting than crud
07:22:50 <c_wraith> And as long as you're restricting yourself to exactly crud, then persistent is pretty good
07:23:07 <Big_G> c_wraith, Care to give an example?
07:23:10 <c_wraith> It's not like there aren't libraries for haskell
07:23:21 <Big_G> Are they as good as Hibernate?
07:24:07 <c_wraith> Given my low opinion of hibernate, I'm not one to give a fair answer there. :)
07:24:27 <Big_G> I really dislike it too but it can be nice not having to write SQL
07:25:11 <Clint> you don't have to write any sql with persistent
07:25:24 <c_wraith> woo!  flat memory profile!
07:25:36 <Big_G> Clint, I've never used persistent so I can't say
07:25:45 <Big_G> Is it as fast as any other DBMS?
07:25:57 <c_wraith> Still not sure why it leaked space, but a found an equivalent implementation that doesn't.
07:26:08 <c_wraith> *I* found, that is
07:26:20 <Clint> Big_G: it's as fast as the backend you use it with
07:26:30 <c_wraith> I suspect the problem was that I didn't understand exactly what hoist does
07:26:45 <Big_G> Clint, So it is as fast as my code allows?
07:27:20 <Clint> unless you want to do joins or something
07:27:47 <Big_G> at which point?
07:28:29 <aleator_> If a node.js webserver (express) prints exceptions to the console, is that considered to be a problem?
07:28:55 <aleator_> Argh. Wrong channel. sry
07:29:41 <frerich> aleator_: Based on my experience with Java, I'd consider it a sign that "It's still doing something"
07:30:09 <aleator_> frerich: :)
07:33:30 <maerwald> exception driven programming... it's not a problem
07:34:27 <aleator_> I'd think unhandled exception on the console would be a bug, but perhaps the culture is different there.
07:34:35 <Big_G> Is there a way of using persisten to access a databse without rewriting the table structure in Haskell
07:35:33 <aleator_> Big_G: I don't think so. Can you do that with hibernate?
07:37:04 <Big_G> aleator_, No but that also seems like a huge hinderance and asking for differences in the models
07:37:21 <Big_G> brb
07:55:06 <RaceCondition> type Foo = forall a. IsFoo (Bar a) => Bar a  -- is this even possible? or do I need to use a newtype instead?
07:55:46 <RaceCondition> s/newtype/data/
07:58:07 <c_wraith> Holy crap.  I have a relatively long-running computation..  A program that runs for about 14 seconds before printing one line of computed output.  time reports that 6 seconds of the runtime is syscalls.  Can I get the runtime to do fewer syscalls than that?
07:58:19 <srenatus> anyone played with dyre lately? can't seem to get it to work on windows
08:01:01 <srenatus> nvm all good with recent cabal-install
08:09:27 <maerwald> RaceCondition: I don't think it's clear what you want to do there
08:10:34 <RaceCondition> maerwald: I'm writing GHCJS FFI bindings for a JS library; I can construct a Surface with content :: String or content :: Node -- I'd like to express that without having to use a newtype/data
08:10:38 <c_wraith> RaceCondition: do you want an existential or a polymorphic value?
08:10:53 <RaceCondition> existential
08:10:59 <c_wraith> in that case you need data
08:12:14 <RaceCondition> consider http://lpaste.net/132549
08:13:00 <RaceCondition> ok, so the limitations in the type system make my current approach impossible?
08:13:42 <c_wraith> It looks like you're trying to reinvent the existential type class pattern which is very...  not-useful
08:13:53 * hodapp prepares for a familiar link
08:13:55 <c_wraith> You're better off just using an algebraic data type
08:14:14 <RaceCondition> c_wraith: re reinvent -- I'm not sure I follow
08:14:20 <c_wraith> hodapp: I don't actually like that article much, even though I agree that the pattern doesn't work
08:14:29 <hodapp> c_wraith: why don't you like it?
08:14:42 <RaceCondition> I'm just trying to be able to write Surface { sfContent = node } vs uSurface { sfContent = Content node }
08:14:46 <hodapp> (assuming we're talking about the same one)
08:15:20 <c_wraith> hodapp: I just feel like it's super-negative
08:16:49 <c_wraith> RaceCondition: Why not make the record type polymorphic and let inference handle getting the type right?
08:22:56 <RaceCondition> oh, you mean Surface a, where a is the type of the content? that seems to work perfectly!
08:23:14 <c_wraith> yeah, that's what I meant. :)
08:24:14 <rien> I need help doing AES128 CBC in Haskell
08:24:20 <rien> This is a strange signature: cbcEncrypt :: cipher -> IV cipher -> ByteString -> ByteString
08:24:31 <rien> is it not missing the plaintext to be encrypted?
08:24:54 <rien> I was expecting a encrypt :: cipher -> IV cipher -> Key -> Plaintext -> ByteString
08:25:25 <maerwald> is templatehaskell a reasonable use case for hiding instance creation behind a "function"? I have never used it
08:25:50 <rien> oh I think I got it
08:27:16 <merijn> maerwald: What do you mean by "hiding instance creation"?
08:28:52 <maerwald> merijn: I have a basic constraint solver and the way you use it is you create an instance which is basically just to provide the "input"... the function to solve it is already defined in the class
08:28:57 <maerwald> but it's weird for an API
08:29:15 <maerwald> so it would be cooler to hide that somehow
08:30:08 <merijn> maerwald: TH would just automate defining the instance at compile time, it wouldn't hide it
08:32:12 <maerwald> merijn: so I could define a TH function that takes the input and automatically makes an instance of that class in the correct form
08:35:29 <hodapp> hmm, does GHC.Generics offer me the ability to inspect a type itself without needing to define a dummy value, or should I just put up with making a dummy value?
08:35:30 <merijn> maerwald: Maybe...I don't know what your instances look like, alternatively you could use GHC generics to provide a generic instance that people could derive
08:35:53 <maerwald> I didn't know about GHC generics
08:45:17 <merijn> Can anyone explain the purpose of the Eq1, Ord1, etc. classes in prelude-extras?
08:47:19 <indiagreen> merijn: it seems that those are the same as in transformers
08:47:22 <indiagreen> http://hackage.haskell.org/package/transformers-0.4.3.0/docs/Data-Functor-Classes.html#t:Eq1
08:47:36 <indiagreen> and there's an explanation there
08:47:39 <nshepperd> I assume they are stand-ins for 'forall a. Eq a => Eq (f a)'
08:47:44 <nshepperd> sort of thing
08:48:17 <merijn> indiagreen: I don't seen an explanation there at al?
08:48:49 <indiagreen> at the beginning of the module: “These classes are needed to express the constraints on arguments of transformers in portable Haskell ...”
08:48:57 <nshepperd> since universally quantified contrainst don't really exist yet
08:49:26 <merijn> But you should be able to write "instance Eq (f a) => Eq (T f a)", I think?
08:52:00 <S11001001> merijn: you can't use that to compare 'f b's though even if you have Eq b
08:52:34 <indiagreen> merijn: I checked and it seems I need FlexibleContexts for that
08:53:30 <lpaste> Herogx pasted “syntax error” at http://lpaste.net/132554
08:53:51 <Herogx> Uh so, that there, what exactly is the problem with my indentation can anyone tell me?
08:54:07 <Herogx> and note the issue is popping up on line 8
08:54:59 <indiagreen> you need to indent guards
08:55:04 <joneshf-laptop> Herogx, the actual error would be nice to have, but try indenting the guards
08:55:54 <Herogx> That worked, thanks indiagreen my brain is off today
08:57:52 * hackagebot exact-pi 0.2.0.0 - Exact rational multiples of pi (and integer powers of pi)  http://hackage.haskell.org/package/exact-pi-0.2.0.0 (dmcclean)
08:57:54 * hackagebot wai-middleware-throttle 0.2.0.1 - WAI Middleware for Request Throttling  http://hackage.haskell.org/package/wai-middleware-throttle-0.2.0.1 (ChristopherReichert)
09:02:36 <ski> merijn : `instance Eq (f a) => Eq (T f a)' would mean something different from `instance (forall b. Eq (f b)) => Eq (T f a)'
09:02:39 <ski> (or even, `instance (forall b. Eq b => Eq (f b)) => Eq (T f a)', which is what would be expressed by the workaround `instance Eq1 f => Eq (T f a)' .. in practice, `instance (Eq1 f,Eq a) => Eq (T f a)' would probably be more common, corresponding to `instance ((forall b. Eq b => Eq (f b)),Eq a) => Eq (T f a)')
09:04:00 <ski> (which i suppose one could also phrase as `instance forall f. (forall a. Eq a => Eq (f a)) => (forall a. Eq a => Eq (T f a))' ..)
09:05:26 <indiagreen> (merijn: uh, sorry for trying to substitute googling for understanding things, I shouldn't have done that and I apologise)
09:05:32 <Zemyla> If NT is a newtype and I have a dictionary on NT a, I can safely unsafeCoerce that to a dictionary on a, right?
09:06:20 <ski> (.. if in `T f a', `f' is only applied to `a', then `instance Eq (f a) => Eq (T f a)' would suffice in place of the (in general) more powerful `instance ((forall b. Eq b => Eq (f b)),Eq a) => Eq (T f a)')
09:07:51 <SrPx> Is there any data structure with fast (O(1)?) insertion on any index, and O(1) indexing?
09:07:54 <nshepperd> 'instance Eq (f a) => Eq (T f a)' does seem better since it has a weaker precondition?
09:07:54 <merijn> Zemyla: Yes
09:07:56 <SrPx> (impure, possibly)
09:08:10 <merijn> Zemyla: But you may wanna look into GHC's new safe coerce stuff
09:08:20 <mauke[1]> SrPx: arrays?
09:08:39 <SrPx> arrays don't have O(1) insertion at random positions...
09:08:47 <merijn> SrPx: Mutable arrays do
09:08:53 <merijn> Well, as O(1) as you can get
09:09:27 <Zemyla> merijn: I can't safely coerce a dictionary, can I?
09:09:30 <SrPx> ... no, I mean insertion not rewriting... like, insert 3 77 [1..7] == [1,2,3,77,4,5,6,7]
09:10:10 <kadoban> amortized, which is usually good enough. SrPx did you try one of the variants of Map/Set and it's actually too slow? It's … pretty hard for O(1) vs O(lg n) to matter honestly.
09:11:06 <merijn> SrPx: Then your requirements are mututally exclusive
09:11:19 <merijn> SrPx: You can't have O(1) indexing and O(1) insertion
09:11:26 <SrPx> why
09:11:38 <merijn> Because those requirements are mutually exclusive
09:11:41 <mauke[1]> why
09:12:18 <SrPx> I'm happy with O(log(n)) on both, though. Just not O(N) middle insertion which I guess is what arrays give me
09:12:24 <mauke[1]> presumably because a single insert modifies the indices of all other elements
09:12:28 <merijn> mauke[1]: You need a direct mapping from an index to an address to have O(1) indexing, but this needs to be updateable upon insertion since all indices shift
09:12:29 <hodapp> okay, newtype M1 in GHC.Generics is described as "Meta-information (constructor names, etc.)" but I cannot seem to get to this information via pattern-matching and trying to call conName
09:12:42 <hodapp> they don't have a single practical example here of how to call conName, datatypeName, or selName
09:13:01 <mauke[1]> so this either moves O(n) elements around or makes indexing itself slower
09:13:58 <hodapp> their examples use the type "M1 i c a" for which it seems (I guess) that 'c' is the Constructor type
09:15:54 <JoshieAS> I know sometimes LYAH is a bit sloppy, but he really opened my mind up on Applicative functors
09:16:07 <SrPx> Hmm okay. I guess I had the wrong idea in mind. What I actually need is a map (Float → Value) which allows me to insert a keyVal, delete a keyVal quickly, and query for the first element with a key higher than a specific float.
09:16:24 <nshepperd> merijn: is this also true for amortized complexity?
09:16:44 <nshepperd> I'm trying to figure a proof but I'm too sleepy
09:16:51 <maerwald> JoshieAS: although not entirely correct I found this pretty nice too http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
09:16:59 <SrPx> I can't really use a Map Float Val because that doesn't allow me to ask "what is the first element with a key higher than 0.72"? Other than iterating through the map (O(n))...
09:17:17 <JoshieAS> maerwald: oooo, pictures!
09:17:20 <maerwald> :)
09:17:28 <ski> nshepperd : better for what ?
09:18:19 <mauke[1]> SrPx: http://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Map-Lazy.html#v:lookupGE
09:18:20 <nshepperd> SrPx: Maps have lookupGT
09:18:27 <dolio> ski: Better at not working.
09:18:29 <maerwald> JoshieAS: I like how he says "fmap is from the street" :D
09:18:41 <SrPx> :O
09:19:00 <nshepperd> ski: usable in more cases?
09:19:16 <JoshieAS> haha
09:19:21 <JoshieAS> this is really good, maerwald, thank you!
09:19:36 <JoshieAS> bokmarked
09:19:53 <ski> nshepperd : sure, if it works at all. if not, that's when stuff like `Eq1' can be useful
09:20:08 <SrPx> That's awesome, thank you. I'll use map. Just for the record, is there an equivalent of that, except mutable / on IO? It is for rendering stuff on the CPU so the performance matters
09:20:20 <maerwald> JoshieAS: although I remember that some pedantic haskeller told me that a few details are not correct... but it gives a very good idea
09:20:40 <JoshieAS> you know, learning is a messy process
09:20:47 <JoshieAS> we have to use imperfect analogies to understand vague concepts
09:21:07 <JoshieAS> a smart man can take a so-so analogy, get valuable understanding, and discard the slag
09:21:30 <SrPx> (I've looked on Hoogle but under the same name - lookupGT - I could only find pure structures)
09:21:40 <Twey> A stupid man too; it just takes longer to discard
09:21:50 <JoshieAS> Twey: good point :)
09:21:56 <Twey> (and they don't even have to be men!)
09:21:56 <nshepperd> I mean unless you use OverlappingInstances you can only have one 'instance Eq (T f a)' so you want to define with the weakest constraint that works and makes sense
09:22:04 <JoshieAS> sorry, person*!
09:22:21 <JoshieAS> echoed my pappy's tendency to say 'man'
09:22:25 <hodapp> http://lpaste.net/476244807212072960 - can anyone who has some familiarity with GHC.Generics take a look at this? Lines 29 & 30 are tripping me up; M1 represents a constructor and I have no sense of how to actually bridge this gap with the Constructor typeclass
09:22:48 <ski> nshepperd : sure. but depending on how `T f a' uses `f' and `a', `instance Eq (f a) => Eq (T f a)' might not be possible
09:22:52 * hackagebot diversity 0.6.2.1 - Return the diversity at each position for all sequences in a fasta file  http://hackage.haskell.org/package/diversity-0.6.2.1 (GregorySchwartz)
09:22:54 * hackagebot urlpath 1.1.0 - Painfully simple URL writing combinators  http://hackage.haskell.org/package/urlpath-1.1.0 (athanclark)
09:23:14 <nshepperd> but yeah, there certainly are cases when you might need Eq1
09:24:06 <hodapp> it tells me to put the typeclass constraint on 'gsizes' but I don't really see any way to do that without changing the meaning of the typeclass
09:24:27 <Twey> JoshieAS: I think this is inaccurate in the sense that there doesn't actually have to be a value ‘inside the box’ (e.g. with Reader or IO).  But the box is a useful analogy for many functors, and then you can use *those* as an analogy for the rest, probably.
09:24:36 <nshepperd> like, uh, the recursion that FingerTree does, that I forget the name of
09:24:40 <hodapp> what is supposed to be the instance of 'Constructor'?
09:24:51 <JoshieAS> Twey: Aye, Twey, we had this talk yesterday about "boxes", "computational contexts", and "producers"
09:24:55 <mauke[1]> nshepperd: polymorphic recursion?
09:25:07 <mauke[1]> nested types?
09:25:10 <JoshieAS> I'm starting to see how nuanced a proper analogy for Functors would have to be
09:25:16 <maerwald> Twey: why? How about an empty box?
09:25:44 <nshepperd> it was a word like 'nonstandard'
09:25:46 <Twey> maerwald: It's not that the value doesn't exist.  That's just Maybe, and that's fine.  It does… or will… but it's not actually there yet
09:25:53 <nshepperd> polymorphic recursion is close enough
09:25:55 <mauke[1]> with Reader, the "box" is actually a portal to another world
09:26:02 <hodapp> unless... InstanceSigs is necessary...?
09:26:21 <Twey> The value ‘inside’ Reader is the value you will eventually get when you give it a value to read
09:26:39 <Twey> For example
09:27:06 <ski> @quote /bin/ls
09:27:06 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
09:27:14 <JoshieAS> omg functions are functors too
09:27:19 <ski> no
09:27:35 <JoshieAS> ----^ said with revelation
09:27:35 <ski> functions are values. functors are things that exist at the type level
09:27:36 <Twey> maerwald: The important thing is that it's all about the API.  There may not be a value inside the box at that particular time, or possibly ever, but it exports an API that makes it look as if there is.
09:28:02 <maerwald> Twey: so there can be a time-machine inside the box, I'm fine with that :P
09:28:08 <JoshieAS> yeah but functions are instances of Functor
09:28:20 <ski> `(rho ->)' is a functor (for every type `rho'). a value of type `(rho ->) a' is a function
09:28:22 <Ankhers> Would someone please take a look at http://lpaste.net/132558 and let me know if what I am trying to do is actually a good way of handling unknown fields, and how to quick check it.
09:28:34 <maerwald> > join (+) 4
09:28:36 <lambdabot>  8
09:28:38 <ski> JoshieAS : no. functions are distinct from the *types* of functions
09:28:41 <maerwald> JoshieAS: that :D
09:28:58 <SrPx> Hmm... also... if Data.Map really has a lookupGT then it is in theory a valid priority queue? Not the fastest, but still, insert, delete and getMin at O(log(n))...
09:29:11 <JoshieAS> hmmm
09:30:20 <maerwald> JoshieAS: it's the same as
09:30:23 <maerwald> > join (\y -> (\x -> x + y)) 4
09:30:25 <lambdabot>  8
09:30:45 <Twey> maerwald: What about this one?  data Proxy a = Proxy; instance Functor Proxy where fmap _ Proxy = Proxy
09:30:49 <maerwald> unless I mixed up x and y
09:31:00 <JoshieAS> oooo, interesting
09:31:01 <JoshieAS> btw
09:31:05 <JoshieAS> maerwald: Pillars of Eternity?
09:31:09 <ski> JoshieAS : `ord' is a (value) function. it has type `Char -> Int', which can also be thought of as `(Char ->) Int' (or `(->) Char Int'). the `(Char ->)' (or `(->) Char') part of this type is a *type* function (not a value function), it maps types to types (in this case, it maps the type `Int' to the function type `Char -> Int'). this *type* function `(Char ->)' is a functor
09:31:13 <maerwald> JoshieAS: heh, got me
09:31:18 <JoshieAS> knew it looked familiar
09:31:29 <dolio> Using boxes as an analogy for functors only works in the sense every type you can define in Haskell can be imagined to be a 'box' if you weaken the definition enough.
09:31:35 <dolio> It doesn't make any sense in general.
09:31:36 <JoshieAS> ski: I see
09:32:10 <dolio> Or every vaguely covariant type.
09:32:17 <maerwald> Twey: ok ok
09:32:38 <maerwald> Twey: there is no box :P ...like there is no spoon?
09:32:58 <cite-reader> But if there is no spoon, how will I eat my ne-ohs? :(
09:33:08 * Clint shudders.
09:33:18 <maerwald> Twey: the question is... can you make the analogy more precise without messing it up too bad?
09:33:24 <Twey> maerwald: Nope
09:33:26 <nshepperd> ohh, irregular data types
09:33:35 <Twey> maerwald: The box analogy is fine for plenty of functors
09:33:50 <Twey> maerwald: And those functors are a good analogy for other functors :þ
09:34:00 <ski> JoshieAS : saying "functions are functors" is just as confused as saying (or implying) "`getLine' is a monad". monads are not values, you can't pass them around at run-time, e.g. .. a monad is also a type-level thing (with some associated value-level things, in Haskell associated through the means of type classes)
09:34:22 <JoshieAS> ski: I see, thank you for clarifying, that makes sense
09:34:27 <Twey> maerwald: But the box doesn't directly work for all functors (even in Haskell, unless you have a very strange idea of what a box can be)
09:34:58 <maerwald> ski: well, a lot of people say IO monad too... although IO is just a type that has a monad instance
09:35:08 <maerwald> I don't think that's a big problem though
09:35:29 <JoshieAS> Twey: the box analogy can be like training wheels -- you can't ride a bike properly with them on
09:35:29 <exio4> is there anything that could explain why ./app +RTS -N2 could end in a <<loop>> while ./app +RTS -N1 doesn't? 
09:35:48 <JoshieAS> but they kickstart your learning so that you can ride without them eventually
09:35:50 <dolio> Using the carrier of an algebra to refer to the algebra is pretty standard mathematical practice.
09:35:54 <maerwald> JoshieAS: so you are using an anology to describe an analogy :o
09:35:56 <exio4> the <<loop>> also goes away when I disable the eventlog and enable profiling 
09:35:57 <JoshieAS> damn right
09:35:59 <dolio> In cases where it's not ambiguous.
09:36:12 <ski> maerwald : i don't think "`IO' monad" is necessarily a problem. still, it's good to realize that there's one thing that is `IO', and then there's a separate fact that it has the property of being a monad
09:36:38 <JoshieAS> analogies are higher order
09:36:42 <JoshieAS> $$
09:37:08 <maerwald> Twey: how about we say those are portals then? They can lead you into a box or someplace else
09:37:23 <maerwald> this sounds almost like a description of some sort of drug
09:37:24 <ski> JoshieAS : as long as the people involved all understand the important distinctions, one can be allowed to be a bit sloppy with the language. if one doesn't quite understand it, then imho it's better to try to more exact
09:37:52 <JoshieAS> sure, learning should be exact when possible
09:37:54 <maerwald> functors are drugs, err
09:37:59 <maerwald> time to do something else :D
09:38:03 <JoshieAS> haha
09:38:15 <nshepperd> exio4: does the app actually work or does it just fail to detect the loop?
09:38:26 <exio4> nshepperd: it does work
09:39:21 <Twey> ski: data Instance ctx f where Instance ∷ ctx f ⇒ Instance ctx f; functionMonad ∷ Instance Monad ((→) ρ); functionMonad = Instance -- you're not the boss of me!
09:39:51 <Twey> maerwald: You're getting into burrito territory
09:39:59 <exio4> nshepperd: the only change I did, was changing a (concat (parMap rseq f xs)) to (withStrategy (parListChunk 8 rseq) (concatMap f xs))
09:40:18 <hodapp> I need to find myself some burrito territory for lunch...
09:40:44 <maerwald> Twey: the problem is I cannot relate to the burrito analogy probably because I have never had one
09:40:54 <Twey> Haha
09:41:13 <nshepperd> heh, in that case I have no idea. I wouldn't think that thread number should be observable in that way
09:41:33 <geekosaur> I thought that one wasn't intended to be relatable anyway, except as a mockery of bad monad tutorials...
09:41:41 <Twey> Yes, it's a joke.
09:42:01 <nshepperd> "A burrito is just a monad in the category of food, what's the problem?"
09:42:10 <Twey> JoshieAS: Yeah, probably.  You build intuition as a series of analogies, building on previous intuitions, so that's fine.  Once you understand the box-like functors, you can stop thinking of them as boxes and start thinking of them as functors, and then the generalization to other kinds of functors is easier.
09:42:11 <ski> Twey : .. i don't follow
09:42:38 <exio4> nshepperd: me neither, that's why I am a bit like "WTF?" :D
09:42:53 * hackagebot pandoc-citeproc 0.7.1 - Supports using pandoc with citeproc  http://hackage.haskell.org/package/pandoc-citeproc-0.7.1 (JohnMacFarlane)
09:43:02 <maerwald> Twey: I am currently thinking of a planescape wanderer who falls through random portals
09:43:11 <maerwald> and I am not sure if that is good
09:43:20 <Twey> ski: You said ‘monads are not values, you can't pass them around at runtime’ so I made a monad (instance) I could pass around at runtime.
09:43:31 <Twey> As a joke, mostly.
09:48:04 <Twey> Oh, could've written data Instance ctx f = ctx f ⇒ Instance
09:49:04 <aaronm04> I'm just curious about GHC -- why are there so many steps to get from haskell to LLVM/assembly? http://jozefg.bitbucket.org/posts/2014-10-28-stg.html
09:51:29 <lpaste> Exio4 pasted “weird behavior with multi-threaded program” at http://lpaste.net/132564
09:51:56 <exio4> I pasted the code with a few comments, could anyone try to reproduce it on different hardware/GHC versions? (I have 7.8.4) 
09:53:20 <exio4> (I know, I know, the code is extremely ugly, I just found this problem in one of the files with certain changes, was using the n-queens problem as a bit of a microbenchmark) :p 
09:59:45 <febuiles> Hello, noobie question: if I leave aside IO and other state-changing monads, can I consider the rest of functions to be compositionally idempotent (idempotent under composition (not sure if there's a term for that))?
10:00:24 <c_wraith> err.  what would "idempotent under composition" mean?
10:00:35 <michaelt_> exio4: yes, I get <<loop>> with -N2, but 73712 with -N1
10:01:07 <exio4> michaelt_: which GHC version? this is really weird
10:01:28 <michaelt_> exio4: The Glorious Glasgow Haskell Compilation System, version 7.10.1 on os x
10:01:44 <febuiles> c_wraith: f(g(x)) == g(f(x))
10:01:52 <kadoban> febuiles: Do you just mean "pure" ? I'm not really following.
10:02:04 <aweinstock> that's associativity, not idempotence (I think)
10:02:05 <c_wraith> febuiles: err.  most functions don't have that property, even if the types align
10:02:28 <c_wraith> febuiles: consider f = (+1) and g = (*2)
10:02:42 <febuiles> c_wraith: ty
10:02:43 <Hijiri> > ((*5) . (+3)) 23 == ((+3) . (*5)) 23
10:02:44 <aweinstock> idempotence would be something like (f . f) == f, which also isn't true in general
10:02:45 <lambdabot>  False
10:04:01 <febuiles> leaving aside the composition part, the functions mentioned above are idempotent, correct?
10:04:30 <febuiles> kadoban: not sure what pure exactly means yet
10:04:42 <Hijiri> > (+1) 0 == ((+1) . (+1)) 0
10:04:43 <johnw> febuiles: pure means that the output wholly depends on the input
10:04:43 <lambdabot>  False
10:04:55 <c_wraith> febuiles: for a function to be idempotent, f(x) == f(f(x)) must be true for all x
10:05:02 <c_wraith> febuiles: that's also not true for nearly all functions
10:05:19 <athan_> Is there interplay between monad transformers and comonads?
10:05:20 <febuiles> c_wraith: that's compositionally, you can have sequential idempotence (f(x);f(x))
10:05:26 <johnw> athan_: interplay?
10:05:40 <athan_> johnw: Yeah, like any laws
10:05:51 <k0ral> Hello
10:05:57 <febuiles> johnw: meaning that with the same input you always get the same result?
10:06:01 <johnw> febuiles: yes
10:06:14 <febuiles> ok, then I'm thinking about "pure" functions, yes :)
10:06:18 <johnw> febuiles: but by "result" I mean exactly the value returned from the function
10:06:20 <c_wraith> febuiles: no, that's just the standard definition of idempotence.  You really are talking about pure functions
10:06:27 <aweinstock> febuiles: so you're asking if "return (f x) >> return (f x) == return (f x)"?
10:06:53 <johnw> athan_: why would they interplay?
10:07:16 <k0ral> could someone help me understand how conduit's leftovers work ? I have difficulty figuring out whether they could be used to implement a conduit parser's backtracking
10:07:25 <febuiles> how can I ask the bot to describe what an operator like >> does?
10:07:29 <johnw> k0ral: imagine a buffer between producer and consumer
10:07:40 <johnw> the consumer is allowed to push whatever it wants onto this buffer
10:08:04 <febuiles> c_wraith: I see. I will start by learning about pure functions first then, thank you
10:09:19 <athan_> Are the only valid monads AND comonads isomorphic to Identity?
10:09:29 <athan_> johnw: Idk :|
10:09:38 <k0ral> johnw: on which side would such buffer be ?
10:09:47 <johnw> k0ral: it's not on either side
10:09:53 <mendozao> This is more of a functional question rather than specific to haskell, but I think it is still valid. Question is, how can you prove that a recursive function you write will end at some point (no infinite loop)
10:10:06 <johnw> conduits, internally, are a description (using an ADT) of a pattern of interaction between the two sides
10:10:08 <athan_> mendozao: induction
10:10:16 <johnw> one of these patterns is, "Oh hey, I've already got the value you want"
10:10:35 <mendozao> athan_: any example site?
10:10:39 <athan_> mendozao: See "Types and Programming Languages", by Benjamin C. Pierce :)
10:10:48 <johnw> the act of pushing a leftover wraps a layer of just this around the consumer, so that when the consumer next asks for a value, it will get that one
10:10:54 <mendozao> athan_: interesting, will check it out :) thanks!
10:11:04 <athan_> No prob!! It's basically the best thing ever
10:11:22 <johnw> in this way, you can see $$ as an interaction manager, mediating communication between the two sides
10:11:35 <mendozao> athan_: did you get a lot out of that book?
10:11:37 * hodapp mutters something about "M1 :: * -> * -> (* -> *) -> * -> *"
10:11:42 <johnw> he's the one who will see the Leftover constructor, and use it to feed the next value rather than passing control to the producer
10:12:05 <athan_> mendozao: Definitely
10:12:06 <k0ral> johnw: suppose I wrote some conduit parsers that I can combine like "parser1 <|> parser2"; if parser1 fails, is it possible to use leftovers to feed back the consumed input to parser2 ?
10:12:15 <athan_> mendozao: Probably the best FP book to read
10:12:23 <johnw> k0ral: absolutely
10:12:33 <johnw> k0ral: just push the leftover before signaling failure
10:12:38 <mendozao> athan_: better than little schemer or structure and interpretation of computer programs?
10:12:50 <athan_> mendozao: I think it's up there
10:12:56 <athan_> (I haven't finished SCIP :x)
10:13:16 <johnw> k0ral: pipes solves this by using what is _effectively_ a ListT structure to form the buffer, making the possibility of leftover explicit in the type
10:13:17 <mendozao> athan_: ill put this one on my list
10:13:18 <athan_> mendozao: Are you familiar with ML-style FP?
10:13:28 <mendozao> athan_: i'm not 
10:13:45 <athan_> mendozao: For sure. Introduction to Functional Programming by Bird & Walder might be a better choice actually
10:13:45 <hodapp> so, if M1 :: * -> * -> (* -> *) -> * -> *, and then I have something like: instance Foo (M1 S c a) does that assign 'c' and 'a' a kind based on M1's signature (thus c :: *, a :: (* -> *)), and define an instance over something of kind (* -> *)?
10:13:51 <athan_> it's less academic
10:13:53 <mendozao> im just getting started in FP
10:14:10 <athan_> mendozao: Definitely check out intro to FP by bird & walder, then
10:14:12 <athan_> also
10:14:18 <athan_> @learn mendozao
10:14:18 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
10:14:26 <athan_> ^ that's a good link :)
10:14:38 <k0ral> johnw: I'm glad that your answer is positive, but using your explanation, I don't get how it can work; there is no conduit fusion between parser1 and parser2 (like $$), so I wonder how leftovers are indeed forwarded from the first to the second
10:15:19 <k0ral> johnw: since you said that the logic is in the $$ operator, I would expect leftovers to be transmitted only to the subsequence consumer, not between parallel producers
10:15:32 <k0ral> johnw: s/subsequence/subsequent*
10:15:42 <johnw> k0ral: the union of parsers with <|> is a single consumer
10:15:42 <mendozao> athan_: thanks :)
10:15:56 <johnw> k0ral: what will happen is that you'll leave one half of that consumer, and enter the other half
10:15:58 <iankronquist> I have a question about formal verification using promela models. Where should I ask it?
10:16:01 <mendozao> leaning towards clojure over haskell though :X
10:16:15 <JoshieAS> mendozao: omg why
10:16:27 <Melvar> indiagreen: Thank you for opening the ticket. Sorry I didn’t reply again earlier; I had a little hardware failure.
10:16:34 <JoshieAS> mendozao: Clojure, more like BOREjure
10:16:40 <JoshieAS> heh jk, but what makes you lean?
10:16:50 <athan_> mendozao: np :)
10:17:13 <mendozao> JoshieAS: seems to be a nice choice for web development
10:17:15 <kadoban> mendozao: Haskell is much more the FP experience. Clojure I'd only do if you're /very/ tied to the JVM for some reason.
10:17:32 <k0ral> johnw: so if I understood correctly, this implies that a conduit could await its own leftovers ? (e.g. if I call "await" right after "leftover" in the same conduit)
10:17:45 <johnw> k0ral: exactly!
10:17:47 <JoshieAS> mendozao: http://www.yesodweb.com/
10:18:06 <johnw> k0ral: you could have an empty producer, then a conduit that leaves over 100 elements, and then proceeds to believe that the producer was producing 100 elements
10:18:11 <mendozao> JoshieAS: interesting
10:18:33 <JoshieAS> I'm with kadoban on this -- are you just partial to the JVM?
10:18:34 <johnw> k0ral: it's sort of an arbitrary buffer implies by $= or =$
10:18:40 <johnw> and $$
10:18:48 <kadoban> mendozao: Haskell actually seems to have several good options for webdev, in several different forms.
10:19:07 <merijn> mendozao: I would argue that haskell will teach you a lot more than Clojure, so unless you're tied to the JVM for business/existing library reasons I would pick haskell for the best return on investment
10:19:17 <k0ral> johnw: well, that will make my life a lot easier for what I intend to do: implementing the <|> operator
10:19:26 <athan_> What is the difference between these two? http://lpaste.net/132565
10:19:28 <mendozao> i do like how with just a few libraries, you can crank out a robust backend with clojure. no framework required
10:19:31 <k0ral> johnw: thank you for helping me understand this
10:19:40 <JoshieAS> mendozao: and you won't get a better support group than #haskell :)
10:19:42 <johnw> k0ral: sure thing
10:20:04 <mendozao> yes this channel has always been an amazing experience
10:20:07 <mendozao> very helpful folks
10:20:17 <johnw> I find the whole leftover mechanism unfortunate, because its semantics are entirely hidden from the type
10:20:23 <merijn> athan_: The latter overlaps with everything, the former does not
10:20:27 <k0ral> johnw: you wouldn't happen to know whether someone has already implemented such <|> somewhere ? because if that's as easy as it looks, I would expect a lot of people to have had the idea already
10:20:31 <johnw> pipes is slightly more difficult to learn as a result, but you know what things can do
10:20:47 <merijn> athan_: The former says "you can't be an instance of Foo without being an instance of Monad and Comonad"
10:20:49 <johnw> k0ral: that sounds like something that would be in conduit itself, actually
10:20:50 <k0ral> johnw: or maybe I'm fooling myself into believing this is easy...
10:21:07 <hodapp> bluuugh, this stuff with Generics is making me sad
10:21:09 <merijn> athan_: The latter says "All m that are Comonad and Monad instances are Foo instances"
10:21:17 <athan_> merijn: Ahh :) thank you!!
10:21:25 <mendozao> haskell would be tough to start a development project with if you needed to build out a team. I think clojure's learning curve is a lot nicer, with some great FP benefits
10:21:36 <merijn> athan_: Constraints on classes are basically "prerequisites/superclasses"
10:21:49 <merijn> athan_: Whereas constraints on instances are just that
10:22:27 <johnw> k0ral: the real problem is how you "transfer control" to the other side of <|>
10:22:33 <kadoban> mendozao: If only there were a place you could find ~1.5k haskell devs at a time to potentially team with ;)
10:22:53 <mendozao> kadoban: haha :)
10:22:55 <merijn> kadoban: Yeah, but #haskell people are hard to hire :p
10:23:03 <kadoban> merijn: Heh, are they?
10:23:04 <johnw> if you just push the leftover and return mzero, the whole consumer will end, since it's exists as a monad transformer above your Alternative
10:23:07 <c_wraith> I'm for hire.  Just give me decent wages. :)
10:23:20 <merijn> @quote SyntaxNinja work.for.you
10:23:20 <lambdabot> SyntaxNinja says: You'd be surprised how hard is to hire haskellers :( They're all like, "Yeah, I'll come work for you, and by 'come' I mean stay here and work remotely and by 'work for you' I mean I'll keep doing what I'm doing." ;)
10:23:22 <johnw> the problem is that ConduitM is not an Alternative
10:23:34 <kadoban> Lol
10:23:40 <exio4> Haskell is too close to mental masturbation 
10:23:55 <merijn> I'd be for hire, if I wasn't doing my phd :p
10:23:55 <johnw> you could hack it with exceptions and tryC, but I'm wondering if there's a better way...
10:23:59 <merijn> Actually
10:24:08 <kadoban> I'm always for hire, heh.
10:24:08 <k0ral> johnw: I was thinking about wrapping ConduitM into an EitherT
10:24:15 <merijn> I'm still for hire if you hire part-time and don't mind funding the extension to my phd ;)
10:24:17 <johnw> EitherT on top of ConduitM?
10:24:21 <johnw> wow, you don't like your life
10:24:47 <merijn> This sounds like a job for pipes? :p
10:25:00 <johnw> yeah, pipes gives you control over the leftover mechanism
10:25:02 <merijn> Although I missed the exact end goal
10:25:09 <johnw> merijn: he wants to write conduit-parse, basically
10:25:26 <merijn> pipes-parse, despite being initially confusing to me (actually, it's still a little confusing) works well
10:25:31 <johnw> k0ral: btw, have you looked at attoparsec-conduit?
10:25:37 <johnw> merijn: I agree completely
10:25:46 <johnw> initially it is more confusing, but once you understand it, the types are more valuable
10:25:58 <k0ral> I know of some module in conduit-extra that can turn a Parser into a Sink (or Conduit)
10:26:09 <johnw> k0ral: there you go, just use that
10:26:20 <johnw> that handles pushbacks at the parser level, not the conduit level
10:26:30 <lpaste> merijn pasted “Whoo! pipes-parse!” at http://lpaste.net/132567
10:26:39 <merijn> johnw: Look at that beautiful type :p
10:26:44 <johnw> cute
10:27:17 <merijn> I'm becoming good at line wrapping my types :p
10:27:41 <ski> hodapp : yes
10:27:58 * hackagebot markup 1.0.0 - Abstraction for markup languages  http://hackage.haskell.org/package/markup-1.0.0 (athanclark)
10:28:26 <Haskellfant> merijn: I just let hindent handle that for me :D
10:28:50 <merijn> I don't trust indent tools, they don't linewrap how I'd like >.<
10:29:03 <merijn> Also, I don't think hindent can handle my -XKitchenSink code
10:29:04 <johnw> i should just pay merijn to line wrap my code when I'm not looking
10:29:14 <kadoban> Hah
10:29:51 <johnw> it's the least rewarding thing while editing haskell, really; makes me miss Lisp
10:29:55 <Haskellfant> I don't trust them either, but I am lazy
10:30:06 <hodapp> I am running into something in which I am unable to take a function *out* of a typeclass, and implement it *not* as an instance, despite trying to give it an identical signature and constraints
10:30:26 <merijn> johnw: Hell, if you pay me I'll implement a better auto-indent for you ;)
10:30:31 <johnw> hodapp: example of attempt?
10:31:11 <hodapp> johnw: I'll put one together here
10:31:40 <k0ral> johnw: is that method (converting Parser into a Sink) as memory efficient as building a Consumer as a combination of smaller consumers (as I intended) ?
10:32:02 <johnw> k0ral: i can't think of a reason offhand why it wouldn't be
10:32:23 <k0ral> johnw: in other words, would a hypothetical "conduit-parse" package be completely redundant to conduit-extra ?
10:32:29 <k0ral> ok
10:32:38 <johnw> i bet the Parser version is faster, actulaly
10:32:59 <johnw> because it's based on function calls (State, effectively), whereas conduit uses that little interpreter in a tight loop
10:34:43 <k0ral> ok, thank you a lot for your insight
10:34:47 <k0ral> much appreciated
10:41:56 <lpsmith> Hmm, does anybody know of a decent templating system for email?
10:42:37 <lpsmith> suitable for email, that is?
10:44:29 <dmj`> lpsmith: If you're using amazon SES per chance I added way to send emails w/ blaze templating. https://github.com/dmjio/ses-html
10:46:59 <lpsmith> Hmm,  well,  I think I'd probably prefer the templates to exist as text files,  and I'm not sure what I need to do for non-html email fallback
10:47:18 <lpsmith> even so, thank you dmj` 
10:47:46 <lpsmith> as for amazon SES, that's a decision that hasn't yet been made.
10:48:28 <dmj`> lpsmith: of course! Also, I believe mightybyte has a similar solution, using heist templates.
10:49:52 <merijn> lpsmith: Proper mime mails should take care of that
10:50:08 <merijn> lpsmith: i.e. you can send email with both a MIME html and plaintext component
10:50:27 <merijn> And the email client will show the plaintext one instead of html when that's selected
10:51:08 <lpsmith> right,  but wouldn't I need a way to generate the plaintext as well from my template as well?
10:51:17 <hodapp> hmm, I am in the weird case here where I'm defining a function over an instance of kind (* -> *) of a typeclass, and I need to put a constraint on the first type of that kind... but I can't, because the typeclass never mentions it
10:51:45 <maerwald> wrt email, is there a proper MTA written in haskell? last time I checked there is only postmaster and it isn't really a functioning MTA
10:57:37 <bennofs> hodapp: do you have example code?
10:58:01 <roelof> Can someone give me a example how to first test if the length of a list is even or odd and based on that a pattern matching
10:58:11 <roelof> I cannot make it work 
10:58:38 <ReinH> :t even . length
10:58:39 <lambdabot> Foldable t => t a -> Bool
10:58:46 <ReinH> I'm not sure what you mean by "a pattern matching"
10:58:48 <lpsmith> maerwald, any reason you really want a Haskell MTA,  instead of using say,  postfix?
10:59:34 <maerwald> lpsmith: because I might work on a project that involves hacking an MTA (whichever doesn't matter)... I'd like to avoid postfix ;)
11:00:00 <maerwald> very old C code... uh
11:00:31 <lpsmith> maerwald, fair enough =)
11:00:50 <roelof> ReinH : I have now this : http://lpaste.net/132570 but get a error on the = part 
11:01:32 <lpsmith> I haven't looked at the postfix codebase,   but in my very limited experience,  it's been the easiest and most approachable MTA as far as getting something standard up and running is concerned.
11:01:33 <ReinH> well, that's not valid syntax
11:01:47 <ReinH> roelof: http://en.wikibooks.org/wiki/Haskell/Control_structures#case_expressions
11:01:48 <maerwald> roelof: isn't that O(n^2)? you call length for every element
11:02:14 <ReinH> why not just use if even (length xs) then foo else bar ?
11:02:37 <maerwald> I'd just use a helper argument in an inlined function
11:02:38 <ReinH> And yes
11:02:57 <ReinH> You could just use zipWith ($) xs (cycle [id, (*2)])
11:02:59 * hackagebot stackage-types 1.0.1.1 - Shared data types between various Stackage packages  http://hackage.haskell.org/package/stackage-types-1.0.1.1 (MichaelSnoyman)
11:02:59 <roelof> ReinH :  I saw that page . I think I need some sort of nested case I think 
11:03:01 <ReinH> to double every other
11:03:09 <ReinH> er
11:03:26 <ReinH> > zipWith ($) (cycle [id, (*2)]) [1..10]
11:03:27 <lambdabot>  [1,4,3,8,5,12,7,16,9,20]
11:03:38 <ReinH> you don't need the length
11:04:07 <roelof> I did not use a if then because there are two things that need to be checked a empty list and a non empty lit 
11:04:10 <roelof> list
11:04:58 <ReinH> That doesn't make sense. You need to handle the empty case whether you use an if or a case
11:05:05 <roelof> I need it because I need to multiply every second item from the right and that is different from even and odd list 
11:05:34 <ReinH> from the right?
11:05:49 <maerwald> roelof: in that case you can still get away with only one length call and a helper argument 
11:05:53 <roelof> yes, that is mentioned on the challenge that I try to solve 
11:05:58 <ReinH> You don't need a length call
11:06:00 <ReinH> you can use foldr
11:06:02 <maerwald> err right
11:06:49 <roelof> oke, I do follow the CIS194 course and on the first lessons there is no mentioned about folds 
11:06:59 <roelof> that is mentioned in a later lesson 
11:08:15 <maerwald> roelof: but you do know how to use e.g. "where"?
11:08:40 <maerwald> make a sub-function via "where" and give that a helper argument... then you can still have explicit recursion
11:08:44 <roelof> maerwald:  yes, that is mentioned 
11:09:20 <ReinH> > foldr (\x (xs,b) -> let x' = if b then x else x * 2 in (x':xs, not b)) ([], True) [1..10]
11:09:22 <lambdabot>  ([2,2,6,4,10,6,14,8,18,10],True)
11:09:26 <ReinH> And to show that it is from the right:
11:09:30 <ReinH> > foldr (\x (xs,b) -> let x' = if b then x else x * 2 in (x':xs, not b)) ([], True) [0..10]
11:09:31 <lambdabot>  ([0,2,2,6,4,10,6,14,8,18,10],False)
11:09:46 <maerwald> ReinH: I think he is supposed to solve it with explicit recursion
11:09:54 <ReinH> Welp.
11:10:31 <roelof> maerwald:  you mean a solution like this one :https://github.com/prakashk/cis-194/blob/master/wk01/01-cc-validator.hs
11:11:11 <maerwald> roelof: looks like it
11:11:12 <ReinH> which is also O(n^2)
11:11:28 <maerwald> unfortunately
11:11:31 <maerwald> because he calls last
11:11:35 <ReinH> yep
11:11:39 <maerwald> just reverse the list
11:11:41 <maerwald> :P
11:11:48 <ReinH> The foldr method is linear
11:11:50 <ReinH> as is reversing twice
11:12:08 <roelof> oke, then I have to figure out why and how he uses false and true 
11:12:18 <maerwald> ReinH: then again... I'd almost guess that ghc optimizes these last calls away, does it?
11:12:25 <ReinH> maerwald: doubtful, how could it?
11:12:32 <ReinH> and it isn't just the last, it's also the ++
11:12:37 <maerwald> mh, right
11:14:14 <johnw> fair cross product?
11:14:17 <johnw> > [ y | x <- [0..], y <- zip [0..x] [x, x-1..0] ]
11:14:19 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,...
11:14:45 <ReinH> johnw: nice
11:15:02 <ReinH> johnw: there's also https://hackage.haskell.org/package/control-monad-omega-0.2/docs/Control-Monad-Omega.html
11:15:59 <johnw> I wonder if that's what dolio was referring to
11:16:20 <roelof> so no well written answer for this problem :( 
11:16:21 <fvgvxmpv1> cantor diagonalization as a module, neat!
11:16:39 <ReinH> roelof: sure there are
11:17:07 <c_wraith> johnw: I bet it was
11:17:17 <ReinH> but since it's an exercise, we shouldn't be giving you the answer
11:17:24 <dolio> johnw: No.
11:17:46 <roelof> ReinH : I have googled and some of then using foldr which I do not understand or like the link it's not well written Haskell 
11:18:07 <ReinH> roelof: the goal of exercises isn't to google for a solution
11:18:09 <dolio> > [ (b, a - b) | a <- [0..], b <- [0..a] ]
11:18:11 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,...
11:18:28 <c_wraith> Ok, that's the same thing, but...  better.  :)
11:18:33 <ReinH> heh
11:18:35 <johnw> oh, subtraction...
11:18:36 <ReinH> nice
11:18:43 * johnw hits head
11:18:48 <dolio> :)
11:18:52 <roelof> ReinH : correct  , I look for a way to solve it not a complete answer 
11:19:02 <roelof> but im stuck at the moment 
11:19:19 <fvgvxmpv1> ReinH: the goal of an exercise is to undestand the material — whatever that may entail ;)
11:19:20 <c_wraith> now just throw in a filter on gcd = 1 and change the results to rationals instead of tuples..
11:19:45 <roelof> or I have to use a sort of helper function where I reverse a odd length list 
11:19:53 <ReinH> fvgvxmpv1: that's true, but so is what I said :p
11:19:53 <newsham> is there a standard library function to split a string (or lazy or strict bytestring) into chunks of size n?
11:20:03 <ReinH> @hackage split -- newsham
11:20:03 <lambdabot> http://hackage.haskell.org/package/split -- newsham
11:20:38 <roelof> some say I can be done with a case statement but then on the way I think I need a nested one 
11:21:05 <maerwald> roelof: yeah, don't try to solve everything within a single function... it's fine to have helper functions, but put them under a where clause, unless they are generic
11:21:16 <newsham> ty
11:22:23 <ReinH> roelof: at some level, everything is done with case statements
11:22:38 <newsham> chunksOf.   no L.ByteString impl around though
11:22:48 <newsham> i'll just use my own and borrow their name
11:23:18 <ReinH> newsham: if you're going to write it for bytestring, make sure you do so efficiently (not making a bunch of copies)
11:23:38 <newsham> i just recursed on L.splitAt
11:24:29 <maerwald> public void setId (long id) { this.id = id; } <- why is this so painful to read after you know haskell :/
11:26:07 <maerwald> only 30% of java code is relevant
11:26:07 <newsham> maerwald: seriously.  why cnat thy do    setId x struct = struct { thisId = x }    like haskellers do?
11:26:11 <maerwald> I can just skip the rest
11:27:22 <linman32> is it possible to reference a place in a list? i'm making a list-tree hybrid data structure and would like tree nodes to reference other places in the list
11:27:38 <merijn> linman32: Just copy the list?
11:28:03 <linman32> there must be a more efficient way, right?
11:28:04 <merijn> linman32: Remember that since everything is immutable "copying" is just a shallow-copy, i.e. just a pointer
11:28:15 <linman32> oh
11:28:50 <linman32> i noticed though, that when i appended an item to a list, the reference didn't seem to pick it up
11:28:55 <linman32> it seemed to be a deep copy
11:29:50 <linman32> i was testing with a list of list [[]]. copying the first list to the second, then appending new item to first list
11:29:58 <linman32> the second list didn't have the new copy
11:30:08 <merijn> linman32: There is no "appending"
11:30:12 <mauke> how did you append an item to the first list?
11:30:12 <merijn> Everything is immutable
11:30:37 <merijn> linman32: : creates a new list with an item in front
11:30:52 <linman32> hmm. maybe i did a bad job of testing
11:31:08 <linman32> [1,2,3] ++ [item]
11:31:22 <mauke> that doesn't append an item to [1,2,3]
11:31:29 <mauke> it creates a new list containing [1,2,3,item]
11:31:54 <mauke> similarly, x + 1 doesn't increment x
11:31:56 <roelof> I have now this : http://lpaste.net/132573 but I get a parse error on the length 
11:32:06 <JoshieAS> I have a weird question that isn't exactly Haskell related. Survey here -- how many of you guys do your extracurricular programming at home?
11:32:12 <mauke> roelof: missing |
11:32:29 <mauke> roelof: and the second condition can be replaced by '| otherwise'
11:32:32 <Hijiri> JoshieAS: as opposed to in a library or cafe or something like that?
11:32:36 <JoshieAS> yes
11:32:47 <maerwald> err, what? who programs in a cafe?
11:32:48 <mauke> roelof: and the first one by '| even (length list)'
11:32:56 <Hijiri> I do it at home somtimes, sometimes in my school's library
11:33:06 <Hijiri> the latter usually means I am procrastinating somthing
11:33:07 <maerwald> I need at least two monitors to program
11:33:07 <mauke> I do it at the office
11:33:09 <Hijiri> something
11:33:17 <maerwald> how would that work in a cafe :)
11:33:29 <srhb> maerwald: Split screen more.
11:33:44 <maerwald> srhb: split screen?
11:33:59 <srhb> maerwald: Surely you can fit 80 columns on one side of your single monitor. :)
11:34:24 <maerwald> srhb: firefox looks weird if it's split like that... can't read any documentation
11:34:33 <roelof> maerwald:  how can I rewrite this working solution to use a where  (http://lpaste.net/132574) ? 
11:34:44 <JoshieAS> I can't work at home, like, at all
11:34:56 <JoshieAS> I am hyper productive in a coffee shop but the 2.50 I have to spend every time adds up
11:34:58 <JoshieAS> (I'm cheap)_
11:35:34 <roelof> mauke : thanks , I think im to confused to see that sort of errors 
11:35:37 <maerwald> roelof: http://lpaste.net/132575
11:35:38 <JoshieAS> I live in a closet apartment right now. I think that if I had a dedicated office room, I could do it.
11:35:59 <maerwald> roelof: where is bound to the _pattern matching_ of a function... so it works across guards
11:36:19 <maerwald> unlike let
11:36:58 <maerwald> if you have multiple definitions of a function for different pattern matching... then where will only work on a particular pattern matching
11:37:24 <roelof> maerwald:  thanks, now I see it , I understand how it works . Thanks for the lessons and patience with me 
11:37:33 * ski would express it as saying that the variables bound in a `where'-clause is in scope in the guards of the defining equation the `where'-clause is attached to
11:38:12 <ski> (and the variables bound by the patterns in the definiendum of the defining equation are in scope in the `where'-clause (and in the guards))
11:38:20 <maerwald> ski: wat :D
11:39:03 <ski> maerwald : you can say `foo (x:xs) | bar xs = ... | otherwise = ... where bar ... = ..x..', e.g.
11:39:29 <maerwald> I'm aware of that, but your sentence confused me :/
11:39:50 <maerwald> but you are right, it's important to note that you can access those variables
11:40:38 <maerwald> roelof: he means that you can actually access the variable "list" from within the doubleEveryOther function!
11:40:46 <maerwald> err
11:40:50 <maerwald> I mean doubleEveryOther' function
11:41:32 <maerwald> it sometimes allows for simpler definitions
11:46:11 <joneshf-laptop> is there a way to attempt to evaluate some string though ghc or ghci from the terminal? 
11:46:22 <joneshf-laptop> like what you can do with python
11:46:32 <joneshf-laptop> aside from: `echo "foo" | ghci`
11:46:37 <roelof> oke, again everyone thanks for the lessons and patience with me 
11:47:50 <cite-reader> joneshf-laptop: runhaskell probably has an argument you can use.
11:48:46 <ion> joneshf: ghc -e 'blah'
11:49:12 <maerwald> roelof: but you are still reversing a lot... maybe you could just reverse the list initially and then do your thing and then reverse it another time at the end... so that will be two reverse which is still O(n)
11:49:39 * hodapp tries to figure out intuitively what it means to have a typeclass instance of a kind besides *.
11:49:46 <hodapp> brain hurts.
11:50:14 <joneshf-laptop> ion, thanks!
11:50:21 <joneshf-laptop> ion, also, how did you find that out?
11:50:51 <Ankhers> Would someone mind taking a look at http://lpaste.net/132558 and let me know if I am doing things correctly?
11:50:53 <JoshieAS> maerwald: "Here's a photo of `>>=`: *shows photo of plunger"
11:50:54 <ion> joneshf: I must have looked at the ghc parameters documentation at some point.
11:51:09 <mniip> hodapp, Functor is a container of some sort
11:51:20 <mniip> it needs an argument describing what type is contained
11:51:24 <mniip> hence kind * -> *
11:51:34 <joneshf-laptop> ion, oh, i see, the man page talks about it
11:51:40 <hodapp> That is not a burrito analogy!
11:52:12 <johnw> using the word "container" is unfortunately misleading
11:52:22 <johnw> does "Const c a" contain an 'a' in any way?
11:52:24 <mniip> "of some sort"
11:52:34 <JoshieAS> we just went over this like an hour ago
11:52:34 <joneshf-laptop> johnw, phantomly :)
11:52:40 <johnw> JoshieAS: OK
11:52:47 <indiagreen> Ankhers: if there are several possible choices and they all are known in advance, you should create a datatype with several constructors
11:52:54 <mniip> Functor is an effectful value
11:52:56 <mniip> sounds good?
11:53:02 <maerwald> JoshieAS: do you know those portals in the planescape? They can be anything... a dream, a thought, an object, an action. I am starting to think of functors as portals :P
11:53:10 <johnw> joneshf-laptop: I guess that's the functor used to imprison Zod then
11:53:19 <JoshieAS> maerwald: ooooo, very good
11:53:21 <indiagreen> Ankhers: generally, I don't really understand what you're trying to do, so if this API is public and you could give a link, it'd help
11:53:22 <newsham> functor is a type that is qualified by another type, that supports a mapping function
11:53:37 <exio4> maerwald: Functors aren't values 
11:53:39 <JoshieAS> Functor is a word that sounds perilously close to sphinctor
11:53:40 <mniip> newsham, true
11:53:48 <JoshieAS> sphincter*
11:53:55 <maerwald> exio4: huh, I didn't assume they are
11:53:56 <newsham> "a list of ..."  "optionally containing a ..."   "a program returning a ..." 
11:53:57 <hodapp> JoshieAS: bite my functor.
11:54:08 <JoshieAS> A Functor....says "what?"
11:54:10 <exio4> maerwald: that was for mniip, tab fail :p
11:54:11 <maerwald> exio4: we are just trying abstract analogies
11:54:34 <mniip> a functor is like a burrito
11:54:43 <hodapp> ...I need one right now?
11:54:53 <mniip> you can put different things inside, hence parametrised by the thing it containts
11:55:01 <hodapp> I like mine better.
11:55:26 <joneshf-laptop> johnw, :)
11:55:31 <merijn> mniip: Except functors that don't contain things...
11:55:45 <merijn> mniip: "Const a", "(r ->)", etc.
11:55:58 <newsham> IO
11:56:03 <merijn> newsham++
11:56:18 <merijn> STM and 'ST s' too
11:56:29 <merijn> Oh, how about promises
11:56:57 <newsham> its pretty easy to understand functor by starting with one example, showing how it supports a way of lifting functions,  looking at a diff example, showing how it also supports it, showing a 3rd example, showing the same, then unifyign them with a type class
11:57:09 <newsham> much more easily than trying to play burritos
11:58:00 <mniip> merijn, oh come on
11:58:09 <mniip> I was obviously mocking the "monads are like burritos"
11:58:27 <maerwald> mniip: I neither like burritos nor do I get the joke
11:58:48 <JoshieAS> first, we should come up with a spectrum to rate analogy efficacy
11:58:54 <quchen_> I never gor the burrito joke either, but I'm pretty good at bending the definition of "contains" to match monads.
11:58:54 <maerwald> :D
11:58:59 <mniip> https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
11:59:05 <JoshieAS> then, we tout the 'box' analogy but we provide the 'box' analogy with its appropriate analogy rating
11:59:23 <JoshieAS> the rating does not measure its usefulness so much as it measures its accuracy in encapsulating the idea
11:59:34 <JoshieAS> so we can say Functors are like Boxes (Analogy: 6)
11:59:42 <JoshieAS> Functors are like Burritos (Analogy: 10)
11:59:52 <johnw> a Functor f maps types 'a' to 'f a'; and functions with domain 'a', naturally respecting identity and composition.  I don't think a metaphor exists that can convey this abstraction at all instances
11:59:56 <JoshieAS> Functors are like sphincters (Analogy: 3)
12:00:07 <merijn> quchen_: I like my burrito joke better
12:00:10 <mniip> JoshieAS, how about cardinality of the set of things the analogy fails at?
12:00:16 <maerwald> JoshieAS: I would actually rather redefine the box that it becomes a metaphysical term that can be loaded with more content
12:00:19 <merijn> quchen_: "A comonad is like a burrito, it's hard to keep things inside" :D
12:00:22 <JoshieAS> That can be considered in our analogy rating algorithm
12:00:23 <mniip> so aleph-null for most things
12:00:24 <quchen_> merijn: :-D
12:00:38 <JoshieAS> Functors are like Planescape Portals (Analogy: 9)
12:00:40 <quchen_> merijn: You can stuff more stuff in, but things will keep falling out even!
12:01:16 <bennofs> merijn: making one is difficult, but you can always eat existing ones! :)
12:01:30 <JoshieAS> Functors are like Valve Portals (Analogy: See 'Functor Analogies')
12:02:24 <quchen_> merijn: I've got a "quchen explains how he thinks various instances work" article in my repo, but I fear the backlash when posting it.
12:02:28 <hodapp> But is (-> Burrito) a functor?
12:02:49 <maerwald> JoshieAS: any functor must obey the laws of the lady of pain?
12:03:00 * hackagebot listsafe 0.1.0.1 - Safe wrappers for partial list functions, supporting MonadThrow.  http://hackage.haskell.org/package/listsafe-0.1.0.1 (jtapolczai2)
12:03:03 <quchen_> hodapp: Yes, on Hask^op
12:03:14 <JoshieAS> A Functor must return its books on time
12:09:02 <maerwald> JoshieAS: the important term is "context"... and the "box" tries to model it... can we think of something that models the term context more abstractly?
12:09:39 <lpaste> newsham pasted “functor still not a burrito” at http://lpaste.net/132576
12:11:03 <JoshieAS> Hrm..
12:13:02 <maerwald> JoshieAS: space, time, ...
12:13:08 <maerwald> I think we really need a set of analogies
12:13:13 <JoshieAS> the box analogy is so natural, though
12:13:22 <JoshieAS> because we're trying to act upon a value in a context
12:13:24 <JoshieAS> NOT the context
12:13:45 <JoshieAS> and people get hung up on that in the beginning -- they want to try a change the context
12:13:51 <maerwald> but if you are within IO, you act within a WORLD
12:13:58 <JoshieAS> so an environment
12:13:59 <JoshieAS> a habitat..
12:14:04 <fvgvxmpv1> maerwald: attaching a post-it note?
12:14:07 <newsham> lets not harsh on the burritos.  a fine food much maligned by the cottage monad tutorial industry
12:14:22 <merijn> newsham: Did you see this years SIGBOVIK proceedings?
12:14:25 <JoshieAS> Not a fan of burritos myself; I'm more of a pupusa guy.
12:14:35 <newsham> i did not
12:14:43 <merijn> newsham: It features a category theoretic explanation of burritos :p
12:15:12 <merijn> "This paper presents a novel category theoretic understanding of burritos. This understanding is a"
12:15:15 <merijn> major step forward in the eventual goal of understanding the categorical structure of Fud¨ .
12:15:40 <newsham> http://sigbovik.org/2015/proceedings.pdf
12:15:47 <newsham> pg 62
12:16:09 <newsham> oh wait, it didnt have the full paper
12:16:27 <merijn> "a burrito is just a strong monad in the symmetric monoidal category of food; what's the big deal?" :)
12:17:22 <maerwald> I think food analogies are terrible
12:17:36 <JoshieAS> Food is mutable as fuck
12:17:48 <maerwald> e.g. if you talk to a japanese guy about food, you'll get something completely different than from an american
12:18:17 <maerwald> there is no "common sense" in food
12:18:41 <merijn> newsham: See also the "artisanal type checking" paper :D
12:19:02 <newsham> a monad is like injera
12:19:13 <geekosaur> burrito, potato...
12:19:16 <maerwald> I think there should be more research about practical analogies for category theoretical concepts.
12:19:16 <JoshieAS> mmm, injera
12:19:37 <merijn> maerwald: I don't think that's possible
12:19:38 <JoshieAS> maerwald: agreed, since we depend so heavily on good analogies to teach abstract concepts
12:19:44 <merijn> See the earlier blogpost
12:19:53 <merijn> I don't think we rely on analogies at all
12:19:59 <merijn> I think you just have to do the work
12:20:30 <newsham> instance Functor Perogi where fmap f = stuff . f . unstuff
12:21:29 <merijn> i.e. this one: https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
12:21:46 <maerwald> merijn: analogies are just a way to share structural knowledge via common associations. They are not strictly necessary, but they happen whenever you try to communicate ideas
12:21:47 <merijn> The way to understand functors is to implement a whole bunch of them and check the laws, same for applicative and monad
12:22:19 <ion> Food analogies are like Kopi Luwak coffee. They seem appealing but turn out crappy.
12:22:30 <merijn> ion: :D
12:22:37 <mmaruseacph2> ,remember ion
12:22:43 <Haskellfant> examples that you already know are way more useful than analogies
12:23:04 <merijn> @quote mmorrow analogy
12:23:04 <lambdabot> mmorrow says: a functor is like an analogy between two analogies
12:23:18 <mmaruseacph2> good one merijn 
12:23:38 <mjrosenb> will ghc ever promote an immutable update to a mutation if it proves the old object is dead?
12:23:46 <Haskellfant> so whate are the arrows in the analogy category?
12:24:00 <merijn> maerwald: Also, as someone semi-actively trying to study category theory, the understanding and applicability of category theory to practical haskell programming are way overrated
12:24:15 <maerwald> merijn: I agree
12:24:21 <merijn> In fact, I would qualify them as non-existent for beginner haskell programmers and utterly optional
12:24:45 <maerwald> merijn: I vaguely dived into it and it seems it's almost useless unless you want to do very abstract things like implement your own lens library
12:24:46 <merijn> Haskellfant: The arrows are analogies and the objects are analogies too
12:25:00 <merijn> Haskellfant: Since we just established they're endofunctors in the category of analogies
12:25:12 <edwardk> merijn: funny my experience is quite the opposite 
12:25:23 <merijn> edwardk: You're nowhere near a beginner :p
12:25:34 <newsham> category of non beginners
12:25:37 <maerwald> edwardk: why did I expect you to say this? :D
12:25:49 <edwardk> "applicability of category theory to practical haskell programming are way overrated" is what i'm referring to
12:25:52 <merijn> edwardk: Look, I see the value in CT. But I'm trying to dispel this "haskell is based on CT" and "CT is crucial for writing real world haskell"
12:25:55 <maerwald> exactly
12:26:01 <ion> newsham: Is edwardk an object or a morphism?
12:26:13 <Haskellfant> merijn: ah ok
12:26:25 <merijn> edwardk: Sure, it's very applicable, but not if you're just learning haskell, it distracts from the goal of learning haskell for no good reason
12:26:35 <merijn> And CT is probably easier to learn AFTER haskell
12:27:01 <edwardk> merijn: sure. for me, category theory is a source of a whole bunch of identities and laws and structures we can play with that have been tested and vetted for longer than anything we have in the world of computer science. it is a source of isomorphisms, of equivalent structures, where to the mathematician those are just the rules of the game, but to a
12:27:02 <edwardk> programmer just because two things are isomorphic doesn't mean they have the same performance characteristics
12:27:09 <newsham> ion: i'm not qualified to answer that
12:27:26 <merijn> maerwald: I would recommend basic algebra (monoids and stuff), type theory, and lambda calculus as WAY better time investments for better understanding
12:27:26 <rien> I have a quick and easy question (probably) about Haskell TH and loading from files. On line #3 here, is there a way to supply a filename? https://hackage.haskell.org/package/aeson-schema-0.3.0.5/docs/Data-Aeson-Schema.html
12:28:23 <edwardk> for me the reason i'm excited by haskell and the thing that makes me get up in the morning every day and write more code is that i can sit there and have a dialogue with the compiler and learn things that are fundamental pretty much constantly, and that when i run into something that doesn't perform right, category theory gives me a bunch of isomorphisms i
12:28:23 <edwardk> can use to hit the structure of my problem to turn it into something more tractable
12:28:23 <maerwald> edwardk: but you are not the regular programmer, you know :/
12:28:28 <edwardk> to push the asymptotics into the right place
12:28:29 <merijn> edwardk: Sure, but I'd hope you agree with my observation that basic algebra, type theory and lambda calculus offer a better ROI than CT for someone with the goal of writing haskell :)
12:28:53 <rien> edwardk: what CT resources did you go through to know what you know?
12:28:55 <merijn> edwardk: CT is a nice way to keep expanding knowledge and construct bigger/more composable things
12:29:08 <rien> edwardk: oh wait you're Edward Kmett? lol nevermind. You rock :)
12:29:12 <merijn> rien: I'm betting MacLane or Awodey, but both are rather...intimidating
12:29:34 <rien> merijn: that's some very academic stuff :P
12:29:37 <merijn> rien: Bartosz is writing a pretty accessible intro on his blog
12:29:41 <newsham> the first time ekmett picked up awodey, the text book ran away
12:29:50 <merijn> rien: http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
12:29:52 <Haskellfant> I found awodey way easier than maclane
12:30:00 <merijn> Haskellfant: AFAIK everyone thinks that
12:30:11 <indiagreen> rien: http://hackage.haskell.org/package/template-haskell-2.7.0.0/docs/Language-Haskell-TH-Quote.html#v:quoteFile
12:30:11 <rien> merijn: nice, I will have to check it out. thanks!
12:30:18 <edwardk> merijn: i think they are all 'portions of the elephant' that the 3 blind men are groping. types are propositions are objects in a category. category theory gives us 'monads', logic gives us modalities, same general class of thing, entirely different views of how to manipulate it, and focus. proofs are 'implementation agnostic' but we as computer scientists
12:30:18 <edwardk> often care very much about our 'proofs' of propositions
12:30:24 * ion seconds the recommendation for Bartosz’s article series.
12:30:36 <merijn> rien: There's also lectures from Awodey at OPLSS 2012 online, but I lost the link
12:30:44 <edwardk> i care about category theory because once i know what the parts _are_ category theory lets me talk about how they relate. logic lets me talk about what can exist. types let me talk about the propositions at all
12:30:49 <edwardk> but they are all part of a whole.
12:30:55 <Cale> Don't start with MacLane first unless you have at least a whole undergrad degree worth of mathematics under your belt. Even then...
12:31:12 <edwardk> cale++
12:31:16 <merijn> Cale: Hell, Awodey is intimidating with a degree in CS...
12:31:29 <mjrosenb> @hoogle (a,b,c) -> c
12:31:30 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
12:31:30 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
12:31:47 <ion> > (a,b,c) ^. _3
12:31:49 <lambdabot>  c
12:31:59 <merijn> rien: Bonus, Bartosz blog has examples in both C++ and Haskell
12:32:07 <Cale> :t (\(a,b,c) -> c)
12:32:08 <lambdabot> (t, t1, t2) -> t2
12:32:27 <edwardk> merijn: folks can argue until they are blue in the face about what path is the best path to learn all this stuff. I kind of learned it all in a jumbled mess, but i'd still argue that the topic itself has merit.
12:32:46 <merijn> edwardk: I'm not arguing that it doesn't :)
12:32:55 <newsham> need a royal road to category theory
12:32:58 <edwardk> for me every time i find a hard problem my solution is to go off into category theory and try to find the _harder_ version of the problem and solve that instead. it turns out to give me a better solution to the thing i started with =)
12:33:05 <merijn> I'm trying to provide some resistance to the "must learn CT for haskell" meme going around :p
12:33:09 <Cale> Oh yeah, Awodey's lectures are short and very fast, it would be interesting to know how they're received by beginners. I think they give a really good overview that you can hopefully take big picture ideas from even if you don't absorb all the details.
12:33:34 <merijn> Cale: I downloaded them, but they're mono so I need to recode before watching them on the bus
12:33:36 <edwardk> e.g. work with indexed or parameterized monads rather than monads when you are defining them. now you can't screw up the definitions. you have separate type variables for the input and output state. they don't match up if you get it wrong
12:33:57 <merijn> Cale: I've only gotten like 30 pages into his book, so I'm probably beginner enough to check how accessible they are :p
12:33:57 <edwardk> i just sat down to write a bunch of code for working with operads so i could make nice exact real arithmetic code.
12:34:04 <Cale> https://www.youtube.com/watch?v=ZKmodCApZwk (and you'll probably see the rest of the 4 parts in the related videos)
12:34:20 <edwardk> since the nat solver we have in ghc kinda sucks it turned out to be easier to give the full definition for multicategories than to work with natural numbers and build classic operads ;)
12:34:24 <merijn> Cale: Yeah, but I'm not streaming that on mobile :p
12:34:28 <Cale> ahaha
12:34:36 <merijn> Cale: And I do my CT in public transport on my phone :p
12:34:56 <ion> merijn: I stream things like that on my phone all the time.
12:35:00 <ski> @remember edwardk for me every time i find a hard problem my solution is to go off into category theory and try to find the _harder_ version of the problem and solve that instead. it turns out to give me a better solution to the thing i started with =)
12:35:01 <lambdabot> It is forever etched in my memory.
12:35:31 <mjrosenb> @hoogle [a] -> Maybe Int -> Maybe a
12:35:31 <lambdabot> Prelude (!!) :: [a] -> Int -> a
12:35:31 <lambdabot> Data.List (!!) :: [a] -> Int -> a
12:35:31 <lambdabot> Data.Text.Encoding.Error ignore :: OnError a b
12:35:58 <srhb> mjrosenb: What a weird type.
12:36:25 <merijn> ion: You must have a better data plan than me :p
12:36:59 <ion> Cale: I have tried to watch Awodey’s lectures a couple of times but i haven’t been able to grasp things at his pace. I feel i have been able to learn some of the basics a bit more easily from Bartosz’s articles. I have not read a book about CT. I should revisit the videos at a later point.
12:37:26 <Cale> ion: Definitely check out Awodey's book, it's a lot slower-paced than the lectures.
12:37:32 <mjrosenb> > let deref l x = x >>= (l!!) in deref [1,2,3] (Maybe 1)
12:37:33 <lambdabot>      Not in scope: data constructor ‘Maybe’
12:37:33 <lambdabot>      Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
12:37:42 <mjrosenb> > let deref l x = x >>= (l!!) in deref [1,2,3] (Just 1)
12:37:43 <lambdabot>      No instance for (Show b0)
12:37:43 <lambdabot>        arising from a use of ‘show_M350759089917532579520193’
12:37:43 <lambdabot>      The type variable ‘b0’ is ambiguous
12:37:59 <edwardk> but its all connected even there. now i have a free operad given a graded set of atomic multimorphisms, and it looks a lot like a free monad. i can build a polycategory out of lists of horizontally placed multimorphisms, then take the 'reflection without remorse' approach to make an efficient free operad. the end goal being that it lets me smash a bunch of
12:37:59 <edwardk> structures together in such a way that i have a monad with 'shape' separated from the 'data', and th data is flat in an array in a form that i can quickly start binding when i look at the monad associated with the operad. nice fast code, hell of a lot of theory to motivate it
12:38:01 <ion> Cale: Alright, i’ll keep that in mind.
12:38:02 * hackagebot gl 0.7.7 - Complete OpenGL raw bindings  http://hackage.haskell.org/package/gl-0.7.7 (Polarina)
12:38:16 <mjrosenb> > let deref l x =  (l!!) `fmap` in deref [1,2,3] (Just 1)
12:38:17 <lambdabot>  <hint>:1:31: parse error on input ‘in’
12:38:41 <edwardk> the end result is a more efficient probability monad, and a bunch of other related structures can pop out
12:38:43 <ion> edwardk: I recognize some of those words, such as “the”.
12:39:12 <edwardk> ion: the key here is 48 hours ago i was in much the same boat. =P
12:39:22 <ion> edwardk: heh
12:39:32 <mjrosenb> > let deref l x =  fmap (l!!) x in deref [1,2,3] (Just 1)
12:39:33 <lambdabot>  Just 2
12:39:47 <edwardk> now it all holds together, and gives me a way to understand all the crap xplat has been rambling on about cartesian monads and burroni t-spans and ways to model traversals
12:40:21 <ion> us : edwardk = edwardk : xplat?
12:40:21 <mjrosenb> @pl deref l x = fmap (l!!) x
12:40:21 <lambdabot> deref = fmap . (!!)
12:40:37 <edwardk> because the next harder problem up from multicategories are 't-multicategories' which is precisely what you need to explore the sort of proarrow equipment machinery that makes lens go, and simultaneously the same thing you need to talk about the rest of of the generalized traversable problem.
12:40:59 <edwardk> ultimately traversals are about smashing things into a shape that looks like a free monoid and using the structure of the free monoid to compose them
12:41:05 <edwardk> but you can do the same for other cartesian monads
12:41:12 <edwardk> so we could make 'different shaped' traversals
12:41:27 <edwardk> the 'affine traversal' stuff is effectively that for Maybe as a cartesian monad
12:41:36 <edwardk> or a 'relevant traversal' is effectively that for NonEmpty
12:42:25 <edwardk> so i care about this stuff because i know the answers for all the stuff i can't quite say in haskell is in there, just out of reach, measily transcoded and turned into something tangible
12:42:29 <edwardk> and i don't have to do much to do that
12:42:37 <edwardk> er easily transcoded
12:43:18 <ion> edwardk: Interesting, even though i’m getting your meaning as if through a very low-pass filter.
12:43:55 <edwardk> i used to care about category theory because it let me stop looking for another version of a thing. e.g. i could say that i found the initial or terminal version of a foo, and then know all the other variants anyone could come up with would factor through my solution. that was the motivation that carried me for a long time
12:44:42 <edwardk> e.g. it lets me say that 'every adjunction from Hask -> Hask looks like the hom-prod adjunction. it says ultimately that the Adjunction class in my adjunctions package _is boring_.
12:45:11 <edwardk> (,) e -| (->) e  -- is the only interesting adjunction from Hask to Hask. everything else is a variation on that theme
12:45:41 <ion> Three more articles to be written for Bartosz to reach adjunctions. :-P
12:46:15 <edwardk> you know how long i spent looking for exotic ones? or doing things like trying to find the dual of Cont r? etc. going a bit deeper makes it a lot easier to spot where you can rule out whole classes of things from consideration at all.
12:47:01 <edwardk> anyways, i'm rambling =) you don't _need_ to learn category theory to program haskell. it just gives you a whole lot of very very powerful tools that exist for good, simple reasons.
12:47:16 <edwardk> or if not simple reasons, fundamental ones =)
12:47:55 <Cale> edwardk: Even if you're allowed to define the functors exotically? (e.g. in a way which isn't computable or definable in the language)
12:48:10 <edwardk> and for the record i'm a terrible category theorist. i'm mostly a haskeller who can read some math. i try to transcode some stuff from nlab on a fairly regular basis and try to understand the beast i build here
12:48:39 <dolio> Cale: Those aren't functors. :)
12:48:40 <edwardk> I do a lot of things i can't write with haskell's "Functor" class, etc
12:48:49 <dolio> We're enriched in Haskell.
12:48:53 <edwardk> yeah
12:49:44 <Cale> dolio: That's a fair enough approach, I guess. I'm still interested in the other way :)
12:49:48 <edwardk> you can define limits naively in hask pretending its set and you get something where there is a corresponding constant functor, etc. but then you can't build products/coproducts using limits/colimits like you'd expect.
12:49:55 <edwardk> you get stuck
12:50:18 <edwardk> category theory 'enriched in hask' naively winds up too weak to derive a lot of classic results
12:51:11 <edwardk> that's why in github.com/ekmett/hask i have a pile of stuff for defining categories where you can be a little more introspective about objects, etc.
12:51:34 <Haskellfant> hm is the adjunction (,) e -| (->) e basically currying? I have never thought about adjunctions in haskell (and only very little about adjunctions in general)
12:51:40 <edwardk> all the semigroupoids code i have comes from the fact that haskell isn't good enough for me to define a product category out of the box.
12:51:46 <edwardk> Haskellfant: it is precisely that
12:51:53 <edwardk> curry/uncurry witness the adjunction
12:52:04 <Haskellfant> \o/ I actually understood something
12:52:10 <edwardk> though you want (,e) -| (->) e for that to keep it nice
12:52:20 <edwardk> (a,e) -> b   is isomorphic to   a -> (e -> b)
12:52:24 <edwardk> hence the (,e) abuse
12:52:36 <Haskellfant> yeah
12:52:40 <edwardk> you can of course smash a flip in there to get it using real haskell functors with a capital f
12:52:59 <edwardk> but that only works for categories with that symmetric product
12:53:42 <edwardk> Haskellfant: if you compose those two functors one way you get State, compose it the other you get Store
12:53:57 <edwardk> keep pushing on Store and you get lenses ;)
12:54:25 <Haskellfant> yeah in some boring lecture a month ago, I tried going to costate comonad coalgebras and it seemed logical at that point :)
12:54:30 <marchelzo_> Why does `decode "\"foo\"" :: Maybe Text` evaluate to Nothing with aeson?
12:55:25 <edwardk> marchelzo_: i believe there is some annoying restriction in the formal language of json where the top level thing must be an object or array
12:55:48 <dolio> Yes, a bare string is not valid json.
12:55:51 <marchelzo_> edwardk: ah, yes I believe you are right. I forgot.
12:58:15 <dmj`> marchelzo_: RFC4627 mandates object or array for json, which aeson was coded to, RFC 7159 (from google), which obsoletes 4627 allows values at the top level.
12:58:43 <marchelzo_> dmj`: Interesting
13:01:11 <newsham> web standardization :)
13:02:28 <hodapp> RAWR. I finally made GHC.Generics do something sensible. I think.
13:02:43 <bergmark> marchelzo_: you can use this package to parse any value at the top level http://hackage.haskell.org/package/aeson-utils
13:02:52 <ion> I love web standards. Especially HTML5 DRM.
13:03:23 <hodapp> I still wish I knew a way to make it work just over a type itself (or a Proxy) so that I don't have to define a dummy value of a record
13:03:54 <ion> Finally an alert("Copying intellectual property from this page disallowed"); that works.
13:04:09 <bergmark> hodapp: we do that here https://github.com/silkapp/json-schema/blob/master/src/Data/JSON/Schema/Generic.hs
13:04:22 <hodapp> bergmark: thanks! I will look
13:04:26 <dolio> Everyone should take edwardk with some salt, by the way. For instance, 'enriched in Hask is too weak' is not a very accurate way of stating the situation. :)
13:04:38 <edwardk> i'll confess that
13:04:42 <marchelzo_> bergmark: thanks
13:04:56 <hodapp> So I suppose the point is... that dolio is salty because of what edwardk writes?
13:04:58 <edwardk> dolio can give a much more accurate statement in terms of weighed limits
13:05:08 <juanpaucar> Hi all, has someone worked with hadoop and haskell, i found something but still im looking for more information or expriences
13:05:34 <dolio> Not just that. It has to do with exact quirks of using data kinds and whatnot, and exactly how those work.
13:05:58 <dolio> If you try to get 'traditional results' in different ways, you might meet with more success.
13:06:33 <edwardk> if only we had a good supply of isomorphisms to use to consider how to achieve those alternate statements
13:09:19 <rien> indiagreen: Thanks for the quoteFile link!!
13:09:22 <hodapp> bergmark: ...a Proxy is a Functor? Mind = blown.
13:10:31 <nvd> hodapp, I believe it's a Monad
13:11:19 <hodapp> nvd: SHUT UP
13:11:25 * hodapp runs away
13:11:25 <nvd> :P
13:11:49 <nvd> You can think of it as a list that's guaranteed to be empty
13:11:57 <quchen-mobile> What is "spineless"  about the STG? 
13:13:04 <merijn> quchen-mobile: It doesn't stand up for itself
13:13:17 <quchen-mobile> Badumtsh
13:15:00 <hodapp> "Couldn't match expected type ‘Proxy (M1 C c a b)’ with actual type ‘M1 t8 t9 Proxy (f4 b2)’" I don't know the answer but I'm pretty sure it involves fmap... or something.
13:16:02 <ion> Badumtsh is an object in the category of drum fills.
13:21:23 <ReinH> ion: what are the morphisms
13:22:23 <Zemyla> Is there a way to prove Typeable [a] => Typeable a?
13:22:25 <ReinH> quchen-mobile: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
13:22:45 <ReinH> quchen-mobile: I believe spineless refers to the lack of a spine of function application nodes
13:22:57 <bennofs> hodapp: wow, where did you get M1 t8 t9 Proxy from? that looks wrong to me
13:23:29 <ReinH> quchen-mobile: so the spine of the graph isn't on the stack
13:24:06 <hodapp> bennofs: a not-very-well-developed attempt at converting my code over to use proxies of FooRecord instead of values of type FooRecord
13:24:46 <hodapp> bennofs: I likely need to read bergmark's code a little closer 
13:25:04 <sinelaw> c2hs problem: pointer directive seems to ignore Storable sizeOf, and uses a different (wrong) size instead
13:25:20 <sinelaw> can I get {#pointer #} to use a specific size?
13:27:00 <sinelaw> I guess it's using Foreign.Storable.sizeof, which is giving a wrong value in this case
13:27:26 <arkeet> size of what?
13:27:56 <sinelaw> size of a C struct
13:29:03 <MasseR> Hah! Was playing around with datakinds and haskelldb
13:29:41 <MasseR> I can now say `type Person = Row "person" '[Column "id" PersonKey, Column "name" String, Column "age" Int]`
13:30:08 <MasseR> `person = toTable (Proxy :: Proxy Person)`
13:30:53 <MasseR> `name = toField (Column :: Column "name" String)`
13:31:24 <MasseR> do { t <- table person; restrict (t!name .==. constant "foo"); project (copyAll t) }
13:31:36 <yac> is there a name for haskell packages like ruby has gems?
13:31:46 <yac> I'm getting tired of repeating `haskell package`
13:31:54 <merijn> Just "package"?
13:32:04 <yac> merijn: that's context dependant
13:32:07 <yac> gem is a gem
13:32:28 <yac> I guess I should file a bug lol
13:33:38 <bennofs> so should we start calling haskell packages "hacks"? (from "hackage") :D
13:34:02 <ChristianS> yac: outside of the ruby world, people will not generally know that you mean a ruby package if you say "gem"
13:34:55 <yac> bennofs: that's too ambiguous/context dependant I'm afraid
13:35:54 <yac> ChristianS: seems like you mean "<Language X> programmer" people by "outside world", while I don't care about those. That's unrealistic requirement.
13:37:05 <yac> for me, the target audience (outside world) is "software engineers/developers" who I expect to know what a gem is even if they don't use ruby
13:37:58 <merijn> I wouldn't assume software engineers know that a gem is a ruby package
13:38:04 * hackagebot unlambda 0.1.4.1 - Unlambda interpreter  http://hackage.haskell.org/package/unlambda-0.1.4.1 (abbradar)
13:38:09 <dolio> Yeah, I think most probably wouldn't.
13:38:19 <dolio> I used to use ruby and I didn't know that off hand.
13:38:51 <merijn> And then there's people like me who don't use Ruby and are only aware of it as "python with a web framework"
13:40:17 <zipper> merijn: But python does have a web framework :)
13:40:38 <johnw> yeah, but it's more that Rails has Ruby, than Ruby has Rails
13:40:48 <josephle> some might even argue that Django is better than Rails :P
13:40:52 <zipper> Yousrite
13:43:04 * hackagebot data-map-multikey 0.0.1 - Data.Map with multiple, unique keys  http://hackage.haskell.org/package/data-map-multikey-0.0.1 (JasonHickner)
13:43:25 <fvgvxmpv1> I like to say "Satz", which is german for theorem
13:43:35 <ReinH> I suspect that the only people who will know what a "gem" is are people who have been exposed to Ruby packages
13:43:49 <ReinH> and that this is a strict subset of "software engineers/developers"
13:43:59 <quxbam> or who like diablo or have got a wife
13:44:35 <merijn> zipper: Of course it does, but to me python and ruby are basically interchangeable and I know people think rails is somehow amazing and that's the extent of my knowledge :p
13:44:54 <certainty> :)
13:45:16 <yac> josephle: other might argue pyramid or twisted is even better than django
13:46:49 <yac> ReinH: I think "software engineers" should be aware of what's going on in the software world even if they don't use those techs, as compared to "<language X> developers"
13:47:08 <quxbam> how can i feed  getArgs to a function which wants a FilePath?
13:47:27 <merijn> yac: The field is too broad to keep up with everything
13:47:33 <yac> quxbam: fx . head <$> getArgs 
13:47:56 <ReinH> yac: you might think that, and perhaps you are right, but that doesn't make it so
13:47:59 <quxbam> well, i thought so, but ghc complains
13:48:01 <yac> merijn: s/everything/basics
13:48:20 <Clint> quxbam: which FilePath?
13:48:26 <yac> quxbam: add/remove quotes until it compiles? :)
13:48:34 <yac> quxbam: s/quotes/parentheses
13:48:44 <ReinH> The name of packages in the Ruby ecosystem is an esoteric piece of knowledge that I would gladly remove from my brain and replace with something useful if I could
13:49:01 <merijn> yac: I wouldn't consider knowing the name of ruby packages the basics, I would consider it random trivia
13:49:25 <quxbam> Couldn't match type ?[Char]? with ?Filesystem.Path.FilePath?
13:49:25 <quxbam>     Expected type: IO [Filesystem.Path.FilePath]
13:49:25 <quxbam>       Actual type: IO [String]
13:49:25 <quxbam>     In the second argument of ?(<$>)?, namely ?getArgs?
13:49:28 <quxbam>     In a stmt of a 'do' block: X.readFile def . head <$> getArgs
13:49:32 <quxbam>  
13:49:36 <yac> ReinH: merijn mmkay, what MBTI types are you?
13:49:39 <ReinH> quxbam: don't multiple lines, use lpaste.net
13:49:44 <quxbam> sry
13:49:49 <yac> quxbam: oh, it's different FilePath. 
13:50:16 <ReinH> yac: MBTI is a bullshit, discredited system
13:50:23 <merijn> I don't even know what MBTI is...
13:50:30 <yac> quxbam: there is FilePath in base which is just a type FilePath = String, what you have is entirely different FilePath from another package .. look up the docs
13:50:30 <ReinH> merijn: meyers briggs
13:50:34 <merijn> oh
13:50:35 <merijn> Yeah
13:50:54 <quxbam> the docs says as well it's a string
13:51:03 <yac> ReinH: discredited? I know it's never been scientificaly proved but not about discrediting. It makes sense to me.
13:51:29 <yac> quxbam: you read the wrong docs
13:51:29 <merijn> Anyway, this is gone from way off-topic to "not even about programming"
13:51:31 <ReinH> That FilePath is not type FilePath = String, it's https://hackage.haskell.org/package/system-filepath-0.4.6/docs/src/Filesystem-Path-Internal.html#FilePath
13:53:26 <quxbam> oh, thank you
13:55:54 <ion> ReinH: The addition or removal of a drum hit at a given time.
13:56:08 <ReinH> ion: is it a groupoid?
13:57:33 <ion> ReinH: Sounds right.
14:02:07 <ion> Is this statement correct? Iff a groupoid has an initial object, it is the same as the terminal object.
14:02:56 <johnw> that would sort of have to be the case, since there is an arrow from the initial object to every other, and an arrow from every other to the terminal object, and these arrows are by definition reversible
14:03:25 <johnw> so there would be a isomorphism Initial <-> Final
14:03:46 <johnw> i don't know about "the same", but something something uniquely isomoporhic something
14:04:27 <quchen-mobile_> ReinH: thanks for the pointers! 
14:05:11 <hodapp> is there some term for this thing I'm doing, where I have "Proxy (foo a b c d)" and I'm magically turning it to 'Proxy b'?
14:05:58 <ion> johnw: Alright, thanks
14:06:26 <ion> @type contramap (const ()) . fmap (const ()) `asAppliedTo` Proxy
14:06:27 <lambdabot> Proxy b1 -> Proxy b
14:06:52 <johnw> the contramap/fmap trick is used by edwardk a lot
14:06:57 <NemesisD> i'm curious about something. does anyone know why dependency resolution is so much slower in cabal than in the package managers of other (generally slower) languages, e.g. ruby, python, etc. are they taking shortcuts that cabal isn't/can't?
14:07:07 <johnw> he calls it by a name that I just saw the other day...
14:07:34 <bergmark> NemesisD: some of the other ones don't even care about the declared version bounds
14:07:56 <johnw> ah, he calls it "phantom"
14:08:01 <NemesisD> bergmark: the one I have the most experience with, ruby does as far as i know
14:09:04 <johnw> hodapp: it's not too magical.  For example: foo :: Maybe String -> Maybe Int; foo Nothing = (Nothing :: Maybe Int)
14:09:06 <bergmark> NemesisD: it's also because haskell libs seem to have more dependencies, and it needs a build plan where a package doesn't occur several times with different versions
14:09:27 <ion> lens calls it coerce
14:09:28 <johnw> when you're just dealing with a phantom type only, it's freely exchangeable
14:09:47 <ion> coerce a = absurd <$> contramap absurd a
14:10:02 <glguy> Data.Functor.Contravariant.phantom :: (Functor f, Contravariant f) => f a -> f b
14:10:07 <Clint> ouch
14:10:11 <NemesisD> bergmark: maybe. i worked on a ruby codebase that had hundreds of dependencies and incrementally adding a dependency was usually quite quick. most time spent seemed to be in download/install. in haskell dependency resolution can take several *minutes*
14:10:26 <glguy> And you don't have to lean on Data.Void.Void for coerce, unit () will do 
14:11:08 <glguy> contramap (const ()) 07. fmap (const ())
14:11:58 <bergmark> NemesisD: http://en.wikipedia.org/wiki/Topological_sorting#Complexity
14:12:58 <faveteli2guis> test
14:13:27 <bergmark> NemesisD: but i'm assuming ruby doesn't check for a consistent set of dependencies then?
14:13:58 <bergmark> NemesisD: what happens if you try to glue together two libraries that use different versions of the same dependency?
14:14:18 <favetelinguis> faveteli2guis: whazup?
14:14:48 <ReinH> bergmark: but NC is in P
14:15:38 <ReinH> topsort can be done with DFS with an extra stack, so O(V+E)
14:16:03 <edwardk> ion: we renamed it from coerce to phantom recently, due to the addition of 'coerce' to base
14:16:06 <geekosaur> ruby has no conception of dependencies to speak of, the first one loaded wins and if something else wanted a different version then it will crash or produce incorrect results
14:16:22 <NemesisD> bergmark: really not sure. i assume there's some shortcut being taken or something
14:16:29 <ReinH> I'm not sure why cabal is slow at it, but I don't think it's due to computational complexity
14:16:30 <ion> edwardk: I still seem to have coerce in the lens master i just pulled.
14:17:03 <edwardk> we moved 'phantom' upstream into contravariant. we may not have switched lens over to it everywhere. we also use 'coerce' in lens in the prelude sense so be careful
14:17:07 <edwardk> er in the base sense
14:17:11 <ion> edwardk: aye
14:17:31 <ReinH> geekosaur: ruby doesn't, but bundler does
14:17:31 * johnw engages his lens caution mode
14:17:38 <edwardk> we eliminated all of the unsafeCoerces with 'coerce'
14:17:39 <ReinH> likewise, neither does Haskell, but cabal does
14:17:43 <edwardk> (the base one)
14:17:54 <bergmark> ReinH: euhm, that was probably not what i should have linked to :-h
14:18:01 <ReinH> bergmark: :)
14:18:32 <ion> cd lens && refactor --commit rename Control.Lens.Internal.Getter.coerce phantom && git push
14:18:48 <ReinH> bergmark: also who is this Nick dude and why does he have a complexity class named after him
14:19:03 <ReinH> ion: please provide me with this refactor tool
14:19:33 <bergmark> just finding the minimal set of imports for a module is NP iirc
14:20:08 <johnw> ion: what is the 'refactor' tool, is it just imaginary?
14:20:22 <ReinH> johnw: surely
14:20:36 <johnw> i wonder if HaRE could do it
14:20:46 <ReinH> I wonder if HaRE could... work
14:20:50 <ReinH> with modern ghc
14:21:13 <hodapp> bergmark: well, my method now works on a Proxy - mimicking the code you sent, but using the exact same structure as my old code that worked over values. But, I don't exactly get *why* it works.
14:21:27 <hodapp> bergmark: because if I look at 'from p' where p is a proxy, I see: M1 {unM1 = M1 {unM1 = U1}}
14:21:36 <hodapp> which would seem to be a very boring structure to do anything with
14:23:56 <bergmark> hodapp: isn't that just the proxy, not what's inside it?
14:24:06 <ion> johnw: Yeah, just imaginary. :-(
14:25:02 <hodapp> bergmark: given that it's just a Proxy and that I start everything off with (fmap from p), I guess I don't get how it's getting to what else is inside it
14:25:17 <hodapp> well... I guess I should look at 'fmap from p', not 'from p'
14:25:33 <bergmark> right :-)
14:25:54 <hodapp> indeed, :t fmap from p is something much more interesting
14:27:12 <Pamelloes> Is there a way to make an "anything except" type parameter? e.g. forall (a/=Int). a -> String meaning the function takes anything but an Int and returns a string
14:28:05 * hackagebot data-map-multikey 0.0.1.1 - Data.Map with multiple, unique keys  http://hackage.haskell.org/package/data-map-multikey-0.0.1.1 (JasonHickner)
14:28:07 * hackagebot opentheory-primitive 1.5 - Haskell primitives used by OpenTheory packages  http://hackage.haskell.org/package/opentheory-primitive-1.5 (JoeHurd)
14:28:09 * hackagebot semigroupoids 4.5 - Semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-4.5 (EdwardKmett)
14:28:11 * hackagebot data-map-multikey 0.0.1.2 - Data.Map with multiple, unique keys  http://hackage.haskell.org/package/data-map-multikey-0.0.1.2 (JasonHickner)
14:28:13 <opqdonut> Pamelloes: no, not really
14:28:20 <exio4> Pamelloes: you could do that with a type family
14:28:26 <geekosaur> and wanting that is somewhat dubious
14:28:33 <exio4> but, do you really want to do that?
14:28:34 <hodapp> yeah, that's a bit of a red flag
14:28:35 <johnw> another way of thinking about how 'coerce' works is that forall a. Proxy a has a single, common inhabitant (constructed by 'Proxy'), and coerce is a proof of that fact
14:29:05 <hodapp> :t coerce
14:29:06 <lambdabot> (Functor f, Contravariant f) => f a -> f b
14:29:38 <Pamelloes> I'm working with wxHaskell, so the types are all a bit dubious because they correspond to a c++ library.
14:29:49 <johnw> right, the only way that works is if the inhabitant of 'f a' is also a member of the type 'f b'
14:30:06 <SrPx> Is it safe to use "unsafePerformIO" to just read a value? (Why: I have a structure "data Foo = Foo { vec :: MVec.IOVector Val ... }" with accessors of type "get :: Foo → Key → IO Val". I want to access that data inside a pure function for rendering...)
14:30:07 <Pamelloes> exio4: How do type families work?
14:30:07 <ReinH> The contravariant constraint is what throws me off
14:30:10 <johnw> aRoseByAnyOtherName
14:30:35 <johnw> ReinH: it means the type variable can't appear in the constructor
14:30:39 <johnw> having both, that is
14:30:43 <ion> SrPx: no
14:30:50 <ReinH> johnw: ah, of course
14:31:11 <SrPx> Other than using "unsafePerformIO", the only other way would be creating another structure "PureFoo" and freezing "Foo", but then I'd have to reimplement every function and that'd take a lot of time...
14:31:18 <SrPx> any idea?
14:31:26 <ReinH> SrPx: don't use an IOVector?
14:31:52 <SrPx> Code was too slow with maps ... :(
14:33:05 * hackagebot opentheory 1.197 - The standard theory library  http://hackage.haskell.org/package/opentheory-1.197 (JoeHurd)
14:33:07 * hackagebot opentheory-stream 1.44 - Infinite stream types  http://hackage.haskell.org/package/opentheory-stream-1.44 (JoeHurd)
14:33:09 * hackagebot opentheory-probability 1.48 - Probability  http://hackage.haskell.org/package/opentheory-probability-1.48 (JoeHurd)
14:33:11 * hackagebot opentheory-bits 1.65 - Natural number to bit-list conversions  http://hackage.haskell.org/package/opentheory-bits-1.65 (JoeHurd)
14:33:13 * hackagebot opentheory-divides 1.57 - The divides relation on natural numbers  http://hackage.haskell.org/package/opentheory-divides-1.57 (JoeHurd)
14:33:28 <johnw> "The standard theory library"?
14:33:44 <ReinH> johnw: yeah, it's weird, some of the packages have only two or three exported functionw
14:33:52 <johnw> standarized by who, I wonder
14:34:04 <exio4> Pamelloes: I don't really think this is what you want, but they're basically type-level functions 
14:34:13 <ReinH> johnw: e.g., http://hackage.haskell.org/package/opentheory-stream-1.43/docs/OpenTheory-Stream.html is the only thing that package exports
14:34:21 <ReinH> johnw: JoeHurd, one surmises ;)
14:34:30 <johnw> weird
14:34:36 <ReinH> yep
14:34:42 <johnw> i would have enjoyed it as acme-opentheory
14:34:46 <ReinH> heh
14:35:33 <Cale> wow, very library
14:35:43 <Cale> such definitions
14:35:59 <t7> nice memes Cale 
14:36:02 <t7> dank 
14:36:02 <johnw> haha
14:36:06 <johnw> spot on, Cale
14:36:26 <johnw> perhaps the lack of operators puts this high in your estimation
14:37:25 <lpaste> Exio4 pasted “using type families for restricting types (still discouraged)” at http://lpaste.net/132581
14:37:35 <ellwyne> Hey guys. Would someone be able to give me an example of how <* and *> works? Having a hard time understanding it.
14:37:47 <arkeet> do you understand <*> ?
14:37:55 <ellwyne> arkeet: yeah.
14:38:06 <ellwyne> arkeet: infix of fmap, right?
14:38:10 <ReinH> johnw: I'm sure it's Cale's favorite library
14:38:10 <arkeet> no, that's <$>
14:38:11 <ellwyne> arkeet: oops, wrong one
14:38:15 * hackagebot opentheory-byte 1.125 - Bytes  http://hackage.haskell.org/package/opentheory-byte-1.125 (JoeHurd)
14:38:17 * hackagebot opentheory-parser 1.157 - Stream parsers  http://hackage.haskell.org/package/opentheory-parser-1.157 (JoeHurd)
14:38:19 * hackagebot opentheory-unicode 1.139 - Unicode characters  http://hackage.haskell.org/package/opentheory-unicode-1.139 (JoeHurd)
14:38:21 * hackagebot opentheory-prime 1.81 - Prime natural numbers  http://hackage.haskell.org/package/opentheory-prime-1.81 (JoeHurd)
14:38:23 * hackagebot api-opentheory-unicode 1.2 - OpenTheory unicode character API  http://hackage.haskell.org/package/api-opentheory-unicode-1.2 (JoeHurd)
14:38:24 <johnw> ooh, more
14:38:27 <arkeet> lol
14:38:30 <johnw> i love the version numbers
14:38:38 <ReinH> johnw: the glorious bytes API http://hackage.haskell.org/package/opentheory-byte-1.124/docs/OpenTheory-Byte.html
14:38:45 <ReinH> srsly what is this
14:38:51 <ion> :-D
14:38:55 <johnw> ahh
14:39:01 <johnw> this is stuff generated from http://www.gilith.com/research/opentheory/
14:39:31 <Cale> Yeah, without the proofs, it's pretty dumb.
14:39:45 <ReinH> johnw: apparently they're in Portland
14:39:56 <hodapp> oh of COURSE they're in Portland
14:40:03 <ReinH> hodapp: heyyyy
14:40:14 <hodapp> what?!
14:40:19 <ReinH> Well, technically I'm in Washington now
14:40:30 <ReinH> So as you were
14:40:44 <hodapp> I do want to check out Galois there sometime
14:40:59 <ion> ellwyne: Are you familiar with do notation? fa <* fb = do { a <- fa; _ <- fb; pure a }; fa *> fb = do { _ <- fa; b <- fb; pure b }
14:41:14 <simpson> I was considering applying to work at Galois, but I don't have a PhD. :c
14:41:27 <ReinH> heh
14:41:34 <ellwyne> ion: Not how it's implemented, but from LYAH I understand it glues together monad stuff I think?
14:41:38 <ReinH> Most of my coworkers have phds o_O
14:42:07 <ion> ellwyne: More or less.
14:42:16 <simpson> That wasn't a joke, BTW; their careers page says that they want people to have at least a Master's before applying, and preferably a PhD.
14:42:25 <simpson> So, uh, dropouts need not apply. :c
14:42:57 <Herogx> For a programming position? Why on earth would they value college time over experience?
14:43:13 <t7> simpson: dont galois do military contracts now
14:43:17 <cite-reader> Galois does a lot of formal methods.
14:43:20 <simpson> t7: I hear that, yes.
14:43:23 <t7> so requirement to sell your soul too
14:43:25 * hackagebot decode-utf8 1.2 - Decode a UTF-8 byte stream on standard input  http://hackage.haskell.org/package/decode-utf8-1.2 (JoeHurd)
14:43:27 * hackagebot nth-prime 1.2 - Computing the nth prime  http://hackage.haskell.org/package/nth-prime-1.2 (JoeHurd)
14:43:30 * hackagebot fen2s 1.2 - Converting a chess position from FEN notation to text  http://hackage.haskell.org/package/fen2s-1.2 (JoeHurd)
14:43:31 * hackagebot Saturnin 0.1.0 - Saturnin CI / Job System  http://hackage.haskell.org/package/Saturnin-0.1.0 (yac)
14:43:48 <t7> haskell programming means either military or working for the cunts who caused credit crunch 
14:44:02 <ellwyne> ion: So when I type (+) <$> Just 3 <* Just 5 <*> Just 12, is it first doing Just (+3), then discarding the Just 5, then doing Just (+3) <*> Just 12?
14:44:14 <Herogx> or yourself, t7
14:44:35 <arkeet> > (+) <$> Just 3 <* Just 5 <*> Just 12
14:44:37 <lambdabot>  Just 15
14:44:39 <t7> Herogx: my high horse is a company that writes software for the NHS :)
14:44:50 <t7> not in haskell unfortunately 
14:44:57 <ion> ellwyne: Correct. But the effect of value happens:
14:45:06 <ion> > (+) <$> Just 3 <* Nothing <*> Just 12
14:45:08 <lambdabot>  Nothing
14:46:59 <ReinH> Maybe might not be the best example
14:47:01 <ellwyne> ion: so in this case...what happens after Just (+3)?
14:47:16 <ReinH> > Just 3 <* Nothing
14:47:18 <lambdabot>  Nothing
14:47:33 <ReinH> There is no Just (+3)
14:47:46 <arkeet> well, (+) <$> Just 3 = Just (3+)
14:47:59 <ReinH> (+) <$> Just 3 <* Nothing <*> Just 12 is (+) <$> (Just 3 <* Nothing) <*> Just 12
14:48:15 <johnw> yeah, I think ReinH is right
14:48:26 <arkeet> no, those are all infixl 4
14:48:27 <johnw> the Nothing happens at the very beginning of the evaluation
14:48:38 <ion> ReinH: I’m pretty sure it’s parsed as (((+) <$> Just 3) <* Nothing) <*> Just 12
14:48:48 <arkeet> (((+) <$> Just 3) <* Nothing) <*> Just 12
14:48:54 <ellwyne> i guess i'm just confused because i don't understand the "sequencing", what happens after what
14:49:01 <johnw> no, arkeet is right
14:49:01 <arkeet> (Just (3+) <* Nothing) <*> Just 12
14:49:04 <johnw> all infixl 4
14:49:05 <arkeet> Nothing <*> Just 12
14:49:08 <ReinH> Ah, right
14:49:20 <ion> My favorite non-ACME ACME package used to be gutenberg-fibonaccis, but then someone mentioned http://hackage.haskell.org/package/air-2015.5.4/docs/Air-Light.html (pay attention to the type of (.))
14:49:22 <ReinH> everything is infixl 4, I didn't see <$>
14:49:37 <ReinH> ion: if by "favorite" you mean...
14:49:46 <arkeet> ion: lol
14:49:49 <johnw> ion: 'join' is cool too
14:49:56 <ReinH> Written by someone who really wants Haskell to look like Ruby
14:50:23 <ReinH> And, for that matter, ^ and -
14:50:33 <ReinH> (-) :: (a -> b) -> a -> b
14:50:35 <ReinH> what are you doing
14:50:36 <ReinH> stahp
14:51:07 <johnw> > is composition?  whoa
14:51:08 <lambdabot>      Not in scope: ‘is’
14:51:08 <lambdabot>      Perhaps you meant one of these:
14:51:08 <lambdabot>        ‘id’ (imported from Data.Function),
14:51:22 <ReinH> johnw: nice one :p
14:52:01 <ReinH> ion: that really is an amazing package
14:52:37 <ion> > is composition?  whoa
14:52:38 <lambdabot>  yes!
14:52:46 <ReinH> ion: :p
14:53:06 * hackagebot editor-open 0.4.0.0 - Open the user's $EDITOR for text input.  http://hackage.haskell.org/package/editor-open-0.4.0.0 (pharpend)
14:53:57 <johnw> 4 . (+1) > (+2) --> obvious!
14:54:04 <ReinH> > let { is = id; composition = id; (?) = id; woah = "yes!"}  in is composition? woah
14:54:06 <lambdabot>  "yes!"
14:54:23 <ReinH> ion: :p
14:54:24 <ion> https://github.com/nfjinjing/air-extra/blob/master/src/Air/Extra.hs#L42
14:54:43 <arkeet> @let { is = id; composition = id; (?) = id; woah = "yes!"}
14:54:44 <johnw> ohhh
14:54:44 <lambdabot>  Defined.
14:54:48 <johnw> I see it now
14:54:59 <johnw> he wants things like self.foo(10) to mean foo self 10
14:55:07 <ReinH> yep
14:55:10 <ReinH> isn't it amazing
14:55:29 <johnw> it's kind of awesome that Haskell is able to make this guy happy
14:55:32 <Denommus> self `foo` 10
14:55:38 <ion> Although it still means foo 10 self
14:55:41 <ReinH> Yeah, as long as I never have to touch that code
14:55:52 <johnw> ion: ah, right
14:55:55 <ReinH> or any code that uses that code
14:55:57 <johnw> much wow
14:56:07 <ReinH> Let's just say it wouldn't pass our style guide...
14:56:10 <Denommus> ewwwww
14:56:26 <Pamelloes> How does factoring out fmaps work?
14:56:40 <johnw> factoring them out?
14:56:40 <Cale> Pamelloes: in which case?
14:56:51 <geekosaur> and you thought perl's poetry mode was bad >.>
14:56:56 <ion> This naming is great. date        = fromGregorian; splash_date = toGregorian
14:57:13 <Pamelloes> I have the expression "fmap (fmap (fmap (f))) $ fmap (g) $ g".
14:57:37 <ReinH> fmap f . fmap g = fmap (f . g)
14:57:46 <johnw> ion: this is pretty awesome ion, thanks
14:57:46 <michaelt_> exio4: there seems to be something wrong with parListChunk, I guess you noticed... I reduced it a little, http://lpaste.net/132582
14:57:49 <ReinH> is a Functor law
14:58:08 <Cale> :t \f g -> fmap (fmap (fmap (f))) $ fmap (g) $ g
14:58:09 <lambdabot> (Functor f, Functor f1) => (a -> b) -> (f (f1 a) -> f (f1 a)) -> f (f1 a) -> f (f1 b)
14:58:27 <ReinH> @. pl type \f g -> fmap (fmap (fmap (f))) $ fmap (g) $ g
14:58:28 <lambdabot> (line 1, column 33):
14:58:28 <lambdabot> unexpected '>'
14:58:28 <lambdabot> expecting operator
14:58:33 <ReinH> @. djinn type \f g -> fmap (fmap (fmap (f))) $ fmap (g) $ g
14:58:34 <lambdabot> Error: Class not found: Functor
14:58:38 <ReinH> oh right, sorry everyone
14:58:46 <Cale> @pl \f g -> fmap (fmap (fmap (f))) $ fmap (g) $ g
14:58:46 <lambdabot> (. join fmap) . fmap . fmap . fmap
14:58:53 <ReinH> heh
14:58:55 <Cale> (don't actually do that)
14:59:01 <Pamelloes> hm
14:59:02 <hexagoxel> :exf "(Functor f, Functor f1) => (a -> b) -> (f (f1 a) -> f (f1 a)) -> f (f1 a) -> f (f1 b)"
14:59:03 <exferenceBot> \ b c d -> fmap (fmap b) (c d)
14:59:10 <Cale> I find it curious that there's fmap g being applied to g
14:59:16 <Cale> That's the same thing as g . g
14:59:25 <Pamelloes> Cale: g is sequence in this case
14:59:32 <ReinH> Pamelloes: what
14:59:40 <ReinH> fmap for functions is just (.)
14:59:48 <ReinH> if g is a function, you can just use (.)
15:00:28 <Cale> g has to be a function also, because we're applying fmap to it
15:00:56 <Cale> Pamelloes: It's also worth pointing out, I think, that you don't need parens around (f) and (g) there
15:01:30 <ReinH> Yep
15:01:34 <exio4> michaelt_: I filled/opened a ticket https://ghc.haskell.org/trac/ghc/ticket/10414 , also, nice one! 
15:01:53 <Pamelloes> Cale: True, that's a remnant from some testing I was doing in ghci
15:01:53 <Cale> Parentheses are for grouping expressions. Single variables don't need to be parenthesised ever.
15:02:10 <Pamelloes> I was testing where f = (+1), so it did need the parentheses
15:02:15 <Cale> ah
15:02:24 <ReinH> Cale: sometimes I like to imagine a world where 1-tuples exist...
15:03:17 <ion> (), Identity, (,), (,,), (,,,), ...
15:03:20 <michaelt_> oh I see exio4 I was trying to get rid of the ParList type , you simplified \worker'
15:03:27 <ReinH> ion: yep
15:03:31 <ReinH> but syntactically as well
15:03:36 <Pamelloes> f$g is the same as f.g, right?
15:03:39 <ion> > Identity 42 ^. _1
15:03:40 <Cale> no
15:03:40 <lambdabot>  42
15:03:43 <ion> whoa
15:03:45 <johnw> ReinH: you mean like type (a) = Identity a?
15:03:47 <Cale> f $ g is the same as f g
15:03:58 <Cale> f . g is (\x -> f (g x))
15:04:09 <ReinH> johnw: basically, yes
15:04:13 <johnw> Cale: not in air! ;)
15:04:19 <exio4> michaelt_: I didn't try to simplify it too much, I just cut things until the code looked small enough, maybe you could add it to the bug/ticket?
15:04:34 <ReinH> @src ($)
15:04:34 <lambdabot> f $ x = f x
15:04:38 <ReinH> @src (.)
15:04:38 <lambdabot> (f . g) x = f (g x)
15:04:43 <johnw> ReinH: that wouldn't be a syntactic nightmare at all
15:04:55 <ReinH> johnw: I didn't say they were happy thoughts...
15:05:02 <johnw> put it in air, ship it
15:05:09 <ion> :-D
15:05:10 <ReinH> I don't think I can :(
15:05:25 <arkeet> f $ x is like f x, but makes more money
15:05:26 <ReinH> or I certainly would
15:05:34 <johnw> arkeet: lol
15:05:42 <ReinH> f $! x is like f $ x, but more emphatic about its money making
15:05:46 <Cale> Pamelloes: However, $ is defined to associate to the right, which means that if you have an expression like  f $ g $ h $ x  you can always rewrite it as  f . g . h $ x
15:06:00 <arkeet> f . g $ x = (f . g) $ x
15:06:02 <Cale> You also probably ought to, because (.) is a genuinely associative operator
15:06:03 <ion> Cale: (sadly)
15:06:06 <arkeet> f $ g $ x =  f $ (g $ x)
15:06:11 <ion> Uh, re: the associativity of ($)
15:06:21 <Pamelloes> Cale: Thanks :)
15:06:27 <Cale> and yeah, it's pretty sad that ($) associates to the right, rather than to the left
15:06:34 <ReinH> why?
15:06:53 <arkeet> it should associate the way I want to associate it.
15:06:55 <Pamelloes> The whole point of ($) is that it associates to the right, isn't it?
15:07:05 <Pamelloes> So you can get rid of parentheses
15:07:07 <johnw> new monad for air: newtype 💩a = 💩 { get💩:: a }
15:07:08 <arkeet> the whole point of $ is that it associates lower than everything else
15:07:10 <Cale> Pamelloes: No, the whole point is pretty much that ($) has low precedence
15:07:33 <Cale> You can always avoid nesting it, as it stands
15:07:40 <Pamelloes> Oh right.
15:07:42 <Cale> (because of that thing with (.))
15:07:47 <ReinH> johnw: wait, is that an uppercase symbol?
15:07:52 <Luke> what's a good way to delete a list of keys from a map? is there a clean way to chain those together?
15:08:00 <johnw> if it's not, then of course it should be
15:08:10 <Cale> But if it associated to the left, you could replace expressions like f (g x) (h y) (k z) with f $ g x $ h y $ k z
15:08:17 <johnw> Luke: fold over it and delet ethem
15:08:24 <Luke> ty
15:08:30 <Luke> i heard you moved or are moving btw?
15:08:33 <arkeet> :t M.delete
15:08:34 <lambdabot> Ord k => k -> M.Map k a -> M.Map k a
15:08:37 <Luke> sad to hear that =(
15:08:40 <Cale> and $! having the same left-associativity would actually be reasonably usable with multiparameter functions
15:08:41 <johnw> yeah, moving end of June to Sacramento
15:08:52 <Luke> sad to see you go
15:08:52 <ReinH> Cale: Ah. I don't spend too much time pondering the deep philosophical questions of ($)...
15:08:56 <Pamelloes> Cale: Hm, that makes sense.
15:08:57 <johnw> i'll finally be able to attend Bayhac easily
15:09:01 <arkeet> :t \m -> foldl' M.delete m
15:09:02 <lambdabot>     Occurs check: cannot construct the infinite type: k ~ M.Map k a
15:09:02 <lambdabot>     Expected type: M.Map k a -> M.Map k a -> M.Map k a
15:09:02 <lambdabot>       Actual type: k -> M.Map k a -> M.Map k a
15:09:05 <ion> ReinH: https://gist.github.com/ion1/e22e4ee869dae11a3acf
15:09:05 <johnw> Luke: thanks man
15:09:06 <arkeet> :t \m -> foldl' (flip M.delete) m
15:09:07 <lambdabot> (Ord k, Foldable t) => M.Map k a -> t k -> M.Map k a
15:09:17 <Hijiri> on the earlier topic of packages, we could call haskell packages curries
15:09:17 <Cale> Currently if you want to $! just the second of three arguments, it's awkward and you need parens
15:09:18 <michaelochurch> Hi. I'm trying to debug what _I think_ is a Thunk leak. What's the best way to do that?
15:09:25 <ReinH> ion: right
15:09:29 <arkeet> I love curry.
15:09:34 <Cale> (f x $! y) z -- awful
15:09:35 <michaelochurch> This post: http://blog.ezyang.com/2011/05/anatomy-of-a-thunk-leak/ is 3 years out of date.
15:09:41 <johnw> :t foldl' (flip M.delete)
15:09:43 <lambdabot> (Ord k, Foldable t) => M.Map k a -> t k -> M.Map k a
15:09:48 <johnw> don't need the points (Aka, eta reduction)
15:09:50 <Pamelloes> Does (.) have lower or higher precedence than normal function application?
15:09:53 <arkeet> oh duh :)
15:09:57 <michaelochurch> It refers to an -hT RTS option that no longer exists.
15:09:59 <arkeet> Pamelloes: it has very high precedence.
15:10:08 <arkeet> but function application has higher precedence than all operators.
15:10:12 <Cale> Pamelloes: No infix operator has higher precedence than normal function application.
15:10:22 <johnw> infixl -1!
15:10:26 <geekosaur> function application is higher precedence than everything except record update syntax (foo {...})
15:10:38 <ReinH> and module deiimiting .
15:10:46 <ReinH> *delimiting
15:11:02 <arkeet> right, which is why I said operators.
15:11:04 <Pamelloes> So (f a.g b) would be the same as (f a).(g b), right?
15:11:09 <arkeet> yes
15:11:11 <Cale> right
15:11:15 <ReinH> arkeet: I wasn't correcting you ;)
15:11:22 <Pamelloes> I've been wasting so many parentheses :(
15:11:26 <ReinH> Pamelloes: indeed
15:11:39 <Cale> Pamelloes: Yeah, it's normal as a beginner :)
15:11:39 <ReinH> You only have a limited supply, you know
15:11:40 <ion> Pamelloes: Pro tip: run hlint against your code.
15:11:42 <ReinH> best to conserve them
15:11:49 <ReinH> for when you really need them
15:11:55 <ion> Pamelloes: But also feel free to use parentheses whenever it makes your code clearer for you.
15:12:01 <arkeet> sometimes you should ignore some suggestions from hlint though.
15:12:06 <Cale> There are actually still times where I will use parens where I don't need them
15:12:21 <ReinH> like redundant parens
15:12:37 <Cale> One particular thing is that sometimes I like to irrationally put parens around module qualified variables, just because.
15:12:45 <ReinH> heh
15:12:46 <arkeet> (<*>) f g x = (f x) (g x) looks nice.
15:13:01 <_m_ryan> his does haskell support "AND" and/or "OR" in if condition?
15:13:08 <ReinH> :t (&&)
15:13:09 <lambdabot> Bool -> Bool -> Bool
15:13:10 <arkeet> yes, use || and && operators
15:13:12 <ReinH> :y (||)
15:13:16 <ReinH> :t (||)
15:13:17 <lambdabot> Bool -> Bool -> Bool
15:13:24 <Cale> and if your next question is about XOR, then use (/=)
15:13:26 <exio4> Cale: hlint normally tells me 'Redundant bracket' :p 
15:13:39 <_m_ryan> arkeet: is that the answer in my question?
15:13:42 <arkeet> Cale: C doesn't even have boolean xor
15:13:43 <arkeet> _m_ryan: yes
15:13:49 <_m_ryan> arkeet: thank you
15:14:20 <ReinH> Haskell supports any expression of type Bool in an if condition.
15:14:38 <Freundlich> arkeet: != isn't a boolean xor?
15:14:42 <ReinH> (personally, I wish Haskell had an if function and not a special syntax)
15:14:49 <arkeet> Freundlich: no, for 1 and 2 are both true, but 1 != 2 is true.
15:14:50 <johnw> ReinH: yeah, me too
15:14:57 <johnw> ReinH: I'm always jealous of Agda in that respect
15:15:08 <arkeet> Freundlich: you have to do something like !x != !y
15:15:08 <Freundlich> 1 and 2 aren't bools.
15:15:11 <_m_ryan> arkeet: follow question - is it supported in Yesod? in their hamlet?
15:15:18 <arkeet> Freundlich: what's a bool in C?
15:15:29 <ion> ReinH: Half of that has happened. :-P http://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Bool.html#v:bool
15:15:34 <arkeet> _m_ryan: if the thing you're writing is a haskell expression yes.
15:15:37 <arkeet> (I don't know much about hamlet.)
15:15:47 <ReinH> ion: sure
15:15:49 <Freundlich> Doesn't C99 have bools?
15:16:00 <johnw> yeah, it has bools
15:16:16 <exio4> having types in such a weak environment isn't very useful though 
15:16:17 <johnw> did you know there's a C11?
15:16:39 <exio4> as idiomatic code exploits things like that
15:16:45 <arkeet> Freundlich: yes, but it has more than 2 values.
15:16:53 <ion> johnw: GHC is up to Cmm.
15:16:54 <arkeet> afik
15:16:56 <Luke> did I read somewhere that it's the case that Data.Maps with Int keys are just as fast as Data.IntMaps now?
15:16:57 <arkeet> afaik
15:17:12 <johnw> C11 was released at almost the same time as C++11
15:17:15 <Freundlich> arkeet: I'm not so sure about how bools are defined in C99, so you might have a point...
15:17:16 <ellwyne> Arrg sorry guys. Why doesn't ((+) <$> Just 3 <* Nothing) <*> Just 10 discard Nothing, which is the second argument?
15:17:24 <johnw> maybe the least heralded language release of all time
15:17:30 <arkeet> ellwyne: it doesn't discard Nothing.
15:17:46 <arkeet> it "runs" the Nothing action and discards any result.
15:18:06 <Pamelloes> I'm getting the type error "couldn't match 'forall w1.Window w1 -> ...' with 'Window w -> ...' ". Why don't those two match?
15:18:07 * hackagebot editor-open 0.4.0.1 - Open the user's $EDITOR for text input.  http://hackage.haskell.org/package/editor-open-0.4.0.1 (pharpend)
15:18:09 * hackagebot editor-open 0.4.0.2 - Open the user's $EDITOR for text input.  http://hackage.haskell.org/package/editor-open-0.4.0.2 (pharpend)
15:18:11 <jplatte> Hi! :)
15:18:11 <jplatte> I'm a Haskell noob and I'm reimplementing the logic of a game I created in Haskell to gain some experience.
15:18:11 <jplatte> Now I have stumbled upon a piece of code that hlint can't simplify anymore for me but it still feels kind of redundant.
15:18:11 <jplatte> Is this the right place to ask about this, for some kind of small code review?
15:18:29 <jplatte> The function I'm talking about: https://github.com/jplatte/cyvasse-hs/blob/master/Cyvasse/Match.hs#L21
15:18:31 <Cale> jplatte: sure
15:18:51 <_m_ryan> arkeet: thank you
15:19:05 <jplatte> I think it's understandable why it feels redundant, right?
15:19:15 <michaelochurch> Does anyone here know how to profile a (probable) thunk leak? 
15:19:29 <ion> ellwyne: “(<*) :: Maybe a -> Maybe b -> Maybe a”. It discards the “b”, if any, but the intended effect of why we have “Maybe” in there in the first place still applies.
15:19:42 <michaelochurch> The profiler says the leak is in the SYSTEM module and attributes it to type ARR_WORDS.
15:19:51 <michaelochurch> So I'm guessing that there is a thunk that allocates bytestrings?
15:19:59 <Cale> jplatte: Is it really more convenient to be storing each player's pieces in a separate map?
15:20:00 <ReinH> jplatte: That function looks reasonable, but I would probably include piece color in the piece data
15:20:08 <ReinH> and use a single map
15:20:11 <michaelochurch> err thunk leak that allocates bytestrings
15:20:23 <geekosaur> Pamelloes, show code, but in general a non-top-level forall-ed type can't match anything else
15:20:29 <ion> ellwyne: “getLine <* putStrLn "hello"” discards the result value from putStrLn "hello", but still prints hello after reading a line.
15:20:32 <geekosaur> (well, it's more complex than that)
15:20:38 <Cale> Of course, it's easy to define a local function here to eliminate *this* redundancy
15:20:53 <arkeet> jplatte: fmap (Piece Black) (M.lookup sq bPieces) <|> fmap (Piece White) (M.lookup sq bPieces)
15:20:56 <arkeet> or something
15:21:18 <ion> ellwyne: “(<*) :: IO a -> IO b -> IO a”; again, any “b” is discarded but the “IO” effect will occur.
15:21:20 <arkeet> don't bother testing for boolean membership and then using (!)
15:21:23 <jplatte> ReinH: You mean have PlayerData store a M.Map Square Piece as activePieces and [Piece] as inactivePieces?
15:21:25 <arkeet> (avoid boolean blindness)
15:21:30 <ellwyne> ion: Thanks. But in my example, Nothing shouldn't affect the previous action, right?
15:22:08 <ReinH> jplatte: I think so, and including color in the piece data
15:22:16 <ellwyne> ion: i.e. running Nothing changes (+) <$> Just 3 to Nothing?
15:22:33 <arkeet> Nothing <*> _ = Nothing
15:22:37 <arkeet> _ <*> Nothing = Nothing
15:22:42 <jplatte> ReinH: Yeah there is already a type Piece that is made of Color and PieceType
15:22:53 <Cale> jplatte: Of course, that may or may not be really inconvenient. There are cases where storing the pieces of each colour separately is useful.
15:23:05 <ellwyne> arkeet: oh, i see. so <* will apply the first to the second just as <*> does
15:23:07 <arkeet> probably Maybe shouldn't be your only example for getting intuition for Applicative
15:23:08 <ion> ellwyne: Running (<*) against the parameters ((+) <$> Just 3) and Nothing results in Nothing because of one of the parameters being a Nothing.
15:23:14 <Cale> (but it's something to think about)
15:23:18 <arkeet> @src (<*)
15:23:18 <lambdabot> (<*) = liftA2 const
15:23:20 <arkeet> oh.
15:23:27 <jplatte> ReinH: But I didn't want to store this in PlayerData, because that has the color for all the pieces (and I'm coming from C++ and am kind of obsessed with optimization :D)
15:23:43 <ion> Just a <* Just _ = Just a
15:23:47 <Cale> But yeah, the key here is to make use of operations for combining Maybe values and not to test membership *and then* do the lookup again for the value.
15:23:52 <ion> _      <* _      = Nothing
15:24:00 <ellwyne> ion: I see. Thanks!
15:24:20 <Cale> (see arkeet's code)
15:24:32 <Pamelloes> geekosaur: This is my code http://lpaste.net/132584
15:24:43 <jplatte> Storing the color for each single piece in the whole match seemed very inefficient, especially when that's inside the Match type which is probably gonna be reconstructed a lot with just slightly differing values
15:25:19 <arkeet> modifying a Map isn't that expensive.
15:25:20 <ReinH> jplatte: why?
15:25:26 <arkeet> (log time update)
15:25:41 <jplatte> ReinH: What do you mean, why I think that would be ineffective?
15:25:50 <ReinH> yes
15:26:35 <Cale> jplatte: You should generally assume that almost every intuition you have about efficiency of various operations will be wrong.
15:26:43 <jplatte> Well, because it makes the overall data that's gonna be stored in the map bigger (probably by a factor of 2)
15:27:14 <ReinH> Why would it be bigger by a factor of two?
15:27:21 <ReinH> maximally compressed, it's only bigger by a bit
15:27:24 <haskell667> Hi there, I'm using aeson to parse a json object like { "price": "$12,00" }. I'm trying to make a parser for the price value but am not sure how to mix in an attoparsec parser (which I think would need to be of type `Parser Text Double` rather than aeson's `Parser ByteString Double`). Any ides?
15:27:33 <ReinH> er, not maximally compressed, but most efficiently tored
15:27:36 <ReinH> *stored
15:27:39 <_m_ryan> arkeet: is this correct? if (8 == 9) && True?
15:28:04 <ReinH> haskell667: attoparsec can parse bytestrings
15:28:24 <ReinH> > (8 == 9) && True
15:28:26 <lambdabot>  False
15:28:28 <ReinH> _m_ryan: that's a boolean value
15:28:45 <geekosaur> Pamelloes, the problem there is that the type of "w" has the scope of the "type" declaration. Which means that if you use Component twice, they have completely unrelated "w"s
15:28:51 <geekosaur> btu you use them as if they are the same
15:28:54 <_m_ryan> ReinH: is it wrong?
15:28:55 <jplatte> ReinH: Because I store two enum values as value in the map (Piece = (Color, PieceType)), instead of just one (PieceType)
15:29:08 <ReinH> _m_ryan: I don't know what you mean. It's a valid expression with type Bool.
15:29:23 <Cale> jplatte: You store one pair instead of one PieceType
15:29:44 <_m_ryan> RienH: i was confirming to arkeet if my syntax is correct :-) thank you
15:29:50 <geekosaur> wxHaskell does this because the type of "w" *should* be hidden while constructing a layout; the only thing a Layout should know about the things it contains is what the Window typeclass reveals.
15:29:53 <Cale> jplatte: Of course the actual values in the map are all code pointers regardless, and will always be the same size.
15:30:03 <ReinH> > if (8 == 9) && True then 1 else 2
15:30:04 <lambdabot>  2
15:30:12 <geekosaur> but this means you cannot usefully use Component the way you are trying to
15:30:12 <haskell667> ReinH: So I would write a `Parser ByteString Double` and convert all my matches to `Word8`s? e.g. `word8 (fromInteger '$')` ?
15:30:42 <Cale> (the size of a code pointer on whatever platform you're building for)
15:30:56 <ion> The compiler is good at telling whether your syntax is wrong. (As for telling *how* it is wrong, that’s another issue.)
15:31:44 <Cale> jplatte: This is to allow for two things: 1) unevaluated expressions stored as values in the Map, and 2) polymorphism in general
15:31:55 <ReinH> Worrying about whether (Color, PieceType) takes up too much heap compared to PieceType seems like a great example of premature optimization
15:31:59 <Cale> (this doesn't just apply to Map structures)
15:32:15 <jplatte> Cale: I'm using Data.Map.Strict, doesn't that mean I generally don't store unevaluated expressions?
15:33:00 <Cale> jplatte: It means the operations will ensure the results are evaluated, but the form in which they're stored is effectively the same (though it will in general mean that more stuff gets garbage collected sooner)
15:33:26 <Cale> jplatte: Evaluated things are just pointers to shorter pieces of code which return the already-computed value immediately.
15:33:56 <arkeet> also note that things will only be evaluated to whnf
15:34:10 <ReinH> I'm not sure that the overhead for two maps is less than adding Color to Piece and using a single map
15:34:17 <ReinH> and I'm even less sure that it matters at all
15:34:30 <Cale> yes, that as well -- so if you store record structures, you're responsible for ensuring that the fields are evaluated, otherwise they might be unevaluated expressions too
15:34:34 <arkeet> it's more mental overhead :-)
15:35:00 <arkeet> to have two maps, I mean
15:35:06 <Cale> Really, performance-wise, I expect the two approaches to be very similar in general. Just do whatever makes the most sense logically.
15:35:24 <ReinH> I suspect that performance-wise, it doesn't matter at all
15:35:26 <Cale> If there are a lot of operations which really only care about one colour of pieces, then separate maps might be convenient.
15:35:38 <ReinH> and that it's insignificant in the face of actual slow or large things in your code
15:35:54 <ReinH> and that it shouldn't inform your decision at all
15:36:31 <jplatte> Cale: Okay, so will most of my actual data not be garbage collected when I create a new Match with one piece moved from activePieces to inactivePieces? (this is what would happen if I would put all this stuff to use in the end and have a person or bot play the game, right?)
15:36:33 <ReinH> I mean, if you're using String instead of Text somewhere, you've already lost the "it's too big" battle
15:37:24 <exio4> the easiest way? wrap the map(s) or single map in an abstract datatype, then profile, and see if performance matters at all
15:37:44 <ReinH> The easiest way is to just do whatever is best from a design perspective
15:37:50 <ReinH> and worry about performance when it matters
15:38:01 <exio4> I should have added an :P  
15:38:19 <hodapp> but how can I insist on making idiotic premature optimizations and calling them "common sense" if I follow that advice?
15:38:25 <hodapp> what are you trying to do, put people out of a job?
15:38:27 <ReinH> hodapp: It will be difficult for you
15:38:36 <ReinH> but I'm sure you will find a way to continue your incompetence
15:39:01 <hodapp> ReinH: You're just angry because my code is getting wrong answers much, much quicker.
15:39:14 <ReinH> hodapp: "if it doesn't have to work, it can meet any other requirement" :)
15:39:18 <Cale> jplatte: If you're deleting an entry from one Map and putting it in another, the thing you have to be cautious about is just whether the Maps themselves get evaluated in the process. It's possible to accumulate expressions for Map values that look like a chain of unevaluated inserts or deletes, if you don't actually force the evaluation of the Map itself.
15:39:39 <Cale> jplatte: This is the case whether your Map is the .Lazy or .Strict kind
15:39:48 <Welkin> when I first started programming, I wanted to write the best program on my first try, so I never got anywhere and ended up with broken solutions
15:39:51 <ReinH> If you cared that much about performance, you would probably be using bitboards already
15:40:15 <Welkin> now I develop in iterations, starting from the simplest solution
15:40:23 <Pamelloes> geekosaur: Thanks, that makes a lot of sense. I've fixed the issue by paramterizing Component with w and moving the forall to each function. It seems to be working great.
15:40:28 <ReinH> and we wouldn't be having this discussion, because you would already have sacrificed elegance of design for sheer performance
15:41:01 <geekosaur> Pamelloes, for the record, I ran into this early on myself and had to work it out on my own >.>
15:41:10 <geekosaur> with some coaching, iirc
15:41:24 <jplatte> Cale: Alright, I'm not understanding all of what you're telling me, but I think I definitely excpected too much of C++ value semantics to hold true here (for no apparent reason)...
15:41:30 <ReinH> What I see is that everywhere the question of piece color matters, it requires duplicate code
15:41:34 <Pamelloes> :)
15:41:41 <ReinH> This suggests that piece color is being kept in the wrong place
15:41:44 <ReinH> that's all
15:41:45 <geekosaur> forall has a tendency to not behave the way people naïvely expect
15:42:16 <Welkin> that reminds me of https://ro-che.info/ccc/25
15:42:18 <jplatte> I'll go with storing Pieces instead of PieceTypes, it will at least make the implementation of this one function and maybe some others shorter, though not really simpler
15:42:22 <Cale> jplatte: Yeah, literally all of your intuition is going to be wrong for a while, and it's best to get a reasonable handle on just using the language before worrying about what's actually efficient or not. Eventually you build up new intuition for it just through experience anyway.
15:42:35 <hodapp> geekosaur: It blew my mind a little when I found out in Coq that -> is simply a degenerate case of 'forall'.
15:42:52 <jplatte> ReinH, Cale: thanks for the advice
15:43:08 <jplatte> and arkeet: Thanks for that code snippet, let's see if I can get it to work ^^
15:43:09 <hodapp> where "Foo -> " basically means (forall _ : Foo)
15:43:27 <geekosaur> the forall is actually redundant in the `type` declaration because type variables that aren't parameters are automatically top-level forall-ed and won't match up outside it. depending on what you did in your function, that forall may also be redundant (the only time a top level forall is not redundant is with ScopedYTypeVariables, where it perversely *extends* the scope)
15:43:49 <Cale> jplatte: There are papers I can point you at if you really want to have a look though -- heh, the main one I like as a summary is actually a little out of date, but it's still mostly true.
15:44:00 <ion> hodapp: Neat. Makes sense.
15:44:08 <Cale> http://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
15:44:10 <jplatte> Cale: Papers about performance?
15:44:17 <hodapp> ion: It probably matters a lot more when dependent typing is involved, I suppose.
15:44:28 <Cale> jplatte: about the way in which evaluation is implemented by the compiler
15:44:35 <ReinH> geekosaur: where it means "no, seriously for all"? ;)
15:44:58 <exio4> jplatte: implementation details / operational semantics you would care about if you want to get your hands dirty :p
15:45:05 <hodapp> ion: The same book explained how the -> notation is not by coincidence the same as the symbol for 'implies'.
15:45:06 <NemesisD> has anyone experienced this? download the inclusive package list from stackage. cabal update uses all system memory and crashes
15:45:11 <Cale> jplatte: I don't actually think at such a low level myself most of the time when reasoning about performance, but a lot of the discussion there about possible implementations is good to know.
15:45:32 <jplatte> Cale: Yeah, I've read all of the three lazy eval articles on HackHands (https://hackhands.com/guide-lazy-evaluation-haskell/), I think I should rather get some more experience instead of reading more about it :)
15:45:36 <Cale> jplatte: For the most part when thinking about the performance behaviour of Haskell code, I just imagine that textual expressions are being rewritten step by step
15:46:08 <exio4> I found the easiest way to improve the performance of my code was to use the proper data structure
15:46:18 <arkeet> jplatte: have you read http://www.vex.net/~trebla/haskell/lazy.xhtml
15:46:25 <exio4> (I love calling something the easiest way, just because it sounds nicer :p)
15:46:30 <Cale> In some cases I have to actually visualise graph rewriting (or just realise that various parts of an expression are the same thing in memory)
15:46:40 <jplatte> arkeet: no
15:46:50 <ion> hodapp: I don’t suppose you know a link to information about the origin of the -> notation?
15:47:11 <yac> are exceptions usefull for anything or are they just a mistake?
15:47:35 <yac> I think I'd preferred always getting Either than exceptions
15:47:48 <Cale> But yeah, initially, just using reasonably appropriate data structures and turning on -O2 will go a long way. Everything beyond that, you really kind of should be profiling first before spending much time thinking about how fast something is going to be.
15:49:22 <jplatte> Cale: Yeah, I think I'll get over my obsession with optimization; I already got over my obsession with non-gc implementation of everything (if I understand it correctly by now, it just doesn't make sense with lazy eval) :)
15:49:34 <edwardk> glguy: slowly retconning a version ceiling for profunctors
15:51:10 <Cale> Yeah, well, there's something called region inference which might be made to work, but really the GC-based solutions seem to be doing quite well.
15:52:17 <jplatte> Ah yeah, I've read about that. But didn't it kind of clash with lazy eval?
15:52:27 <Cale> edwardk: I've been wondering if there might be some way that hackage itself could collect data on successful/unsuccessful builds and basically use everyone as a distributed computer for version bounds.
15:53:17 <Cale> jplatte: At least somewhat, definitely the implementation of it for strict evaluation would not work for lazy, but I don't actually know all that much about it.
15:53:42 <jplatte> Okay :)
15:54:49 <jplatte> whooo, new code typechecks
15:54:54 <jplatte> and is so much shorter :]
15:56:15 <jplatte> It's really awesome how I can be almost certain that typecheck == correct code. In C++ I had a compiler and a lot of compiler-time checks too, but somehow that didn't quite get me the same safety that the code is probably right.
15:58:47 <michaelt_> exio4: I put my little simplification on the trac fwiw https://ghc.haskell.org/trac/ghc/ticket/10414#comment:4
15:59:45 <Pamelloes> How does MonadIO work?
16:00:31 <Denommus> jplatte: have you experimented Rust yet?
16:00:42 <michaelt_> Pamelloes: that question might be taken in a number of ways
16:01:10 <jplatte> Denommus: I've read most of the finished parts of their tutorial, but not installed rustc yet or anything like that.
16:01:27 <pharpend> Pamelloes: It's a typeclass for monad transformers that build upon IO
16:01:29 <Pamelloes> To narrow it down more, then, is a MonadIO monad pure or impure and how does MonadIO compare to normal IO?
16:01:52 <pharpend> Pamelloes: do you know what monad transformers are?
16:02:23 <Pamelloes> pharpend: Sort of. I know how to use them, but I'm a little unsure as to how they actually work.
16:02:27 <jplatte> Denommus: It's really a cool language, the only thing I don't like about it so far is the boilerplate code needed to be able to conveniently initialize objects in different ways
16:02:55 <pharpend> Pamelloes: well every monad transformer has a function called "lift", 
16:02:56 <pharpend> :t lift
16:02:57 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
16:03:08 <jplatte> they have some kind of Factory pattern, or at least I think it corresponds to XFactory classes in other languages
16:03:12 <exio4> michaelt_: nice! I should talk with you the next time I need to reduce the LOCs of a file! :p
16:03:13 * hackagebot tidal 0.4.31 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.31 (AlexMcLean)
16:03:24 <pharpend> Pamelloes: if a monad is an instance of MonadIO, then there is a function
16:03:26 <pharpend> :t liftIO
16:03:27 <lambdabot> MonadIO m => IO a -> m a
16:04:17 <pharpend> Pamelloes: For instance, ResourceT -> to go from IO a -> ResourceT IO a, you can use lift.
16:04:47 <pharpend> Pamelloes: but if you have FooT (BarT (BazT IO)) a, lift only does like 1/4 of the work.
16:04:58 <michaelt_> exio4:  thanks !
16:05:21 <pharpend> Pamelloes: Usually there will be something like 
16:05:38 <pharpend> Pamelloes: MonadIO m => MonadIO (FooT m)
16:06:12 <pharpend> Pamelloes: in which case you can use liftIO, and it will figure out how many lifts are needed, and do the lifting
16:06:42 <jplatte> Cale, arkeet: I feel I have reduced the size of that function to good extent, without making it less readable :]
16:06:42 <jplatte> https://github.com/jplatte/cyvasse-hs/blob/master/Cyvasse/Match.hs#L22
16:07:01 <c_wraith> also, things can implement MonadIO that don't expose a transformer interface, so long as they wrap IO.
16:07:34 <Pamelloes> pharpend: Thanks, that makes a lot of sense. So basically MonadIO (in this context) is a utility function more than anything else.
16:07:39 <yac> Cale: woudln't that be pretty unsafe?
16:07:49 <Pamelloes> c_wraith: So how would that work?
16:08:00 <aminb> hello huys, are any haskell-mode users around willing to help me a bit with my problem with repl?
16:08:15 <aminb> *guys
16:08:20 <c_wraith> Pamelloes: newtype MyIO a = MyIO ...
16:08:32 <c_wraith> Pamelloes: it can't be a transformer, but it can still implement lifIO
16:10:49 <Pamelloes> c_wraith: so for instance newtype MyIO a = MyIO (ReaderT IO), MyIO could be a MonadIO. Or am I missing something?
16:11:28 <c_wraith> Pamelloes: well, you're missing an `a', but yeah, that's the idea.  MyIO doesn't have the right kind to be a transformer, but it can still be MonadIO
16:11:50 <Pamelloes> hm
16:12:16 <pdxleif> We have an infix symbol for map (<$>), how about one for traverse?
16:12:21 <c_wraith> Pamelloes: of course, in any case where that happens, you can choose to implement your type as a transformer..  It's just a matter of the interface
16:12:35 <Pamelloes> c_wraith: yep, makes sense
16:14:02 <Pamelloes> Shifting gears a little, if I have a series of function along the lines of (a -> IO b), can I somehow operate on the function outside of IO monad?
16:15:15 <Pamelloes> Basically, given a set of the aforementioned functions, I want to be able to make an AST representing calls to them in pure code and then execute it all at once in IO
16:15:58 <marchelzo_> If I have a bunch of (IO a), how can I evaluate them in parallel?
16:16:21 <pavonia> map forkIO
16:16:29 <hpc> evaluate or execute? :P
16:16:33 <marchelzo_> but forkIO takes IO ()
16:16:37 <pavonia> or mapM rather
16:16:52 <hpc> mapM_ forkIO . map (>> return ())
16:17:01 <hpc> :t mapM_ forkIO . map (>> return ())
16:17:02 <lambdabot> Not in scope: ‘forkIO’
16:17:06 <hpc> :(
16:17:12 <yac> parMapIO
16:17:18 <yac> @hoogle parMapIO
16:17:18 <lambdabot> No results found
16:17:22 <marchelzo_> @type parMapIO
16:17:23 <lambdabot> Not in scope: ‘parMapIO’
16:17:31 <yac> @hoogle parMapIO_
16:17:31 <lambdabot> No results found
16:17:56 <yac> @hayoo parMapIO
16:17:56 <lambdabot> Unknown command, try @list
16:18:10 <yac> oh well, http://hackage.haskell.org/package/spawn-0.3/docs/Control-Concurrent-Spawn.html#v:parMapIO
16:19:22 <marchelzo_> thanks
16:20:44 <pdxleif> marchelzo_: http://hackage.haskell.org/package/async-2.0.2/docs/Control-Concurrent-Async.html#v:mapConcurrently ?
16:21:18 <marchelzo_> same signature as parMapIO more or less
16:21:23 <marchelzo_> which should I use?
16:21:54 <pacak> I usually check which packet is more widely used.
16:22:35 <marchelzo_> @hoogle mapConcurrently
16:22:35 <lambdabot> No results found
16:23:03 <pacak> package
16:23:12 <pdxleif> Can use http://packdeps.haskellers.com/reverse/async to see what depends on a given hackage package
16:23:13 * hackagebot urlpath 2.0.0 - Painfully simple URL writing combinators  http://hackage.haskell.org/package/urlpath-2.0.0 (athanclark)
16:23:56 <pdxleif> Looks like spawn is used by 2, async by 145
16:24:02 <ion> marchelzo: I think one of the parallel actions raising an exception does not kill the others in spawn and does in async.
16:24:03 <smithw> Hi. I was trying to find out a simpler way to do this: "f ma mb = ma >>= \a -> mb >>= \_ -> return a", i.e., given two monads, save the value of first, execute them in order and get the saved value. Obviously, thats *not* what "flip (>>)" does. But apparently that's what (<*) does (since every monad is an applicative functor). Is that a coincidence by the implementation of the monad I tested or does that hold for all monads?
16:24:53 <ion> smithw: It holds for all. You can use <*
16:25:05 <smithw> ion, thanks a lot!
16:27:02 <athan_> Crap...
16:27:18 <athan_> I published something on hackage without doing enough tests, and now I realize it's wrong ._.
16:27:23 <athan_> I deserve the stick... :(
16:27:24 <ion> smithw: If i may nitpick, “IO”, “[]” (the type constructor) and “Maybe” are monads, “getLine”, “[0..5]” and “Just 42” are not. The latter can be called e.g. monadic values when emphasizing their type constructor happens to implement Monad.
16:30:00 <naudiz> How can I analyse the memory usage of my program and optimize it to use less memory?
16:30:18 <Clint> profiling
16:30:55 <smithw> ion, well, you're correct, of course. I'm sorry for the lack of formalism, I realize it's important in places that get archived for future searchers :/
16:33:53 <naudiz> I have a program that should handle data that's about 1~10MB big but the memory consumption explodes to multiple GB... and I'd really like to know where it could be optimized and how... unfortunately I have no idea how to tell haskell to "forget" data quickly or something like that
16:34:56 <pavonia> Can you paste the relevant parts of your code?
16:35:54 <naudiz> I can't, sorry... it's pretty big. I'd actually like to have some kind of guide on optimization if such a thing exists 
16:37:34 <P1RATEZ> see if its linear growth or expontential growth
16:37:47 <P1RATEZ> test input data sizes 1mb 2mb 3mb
16:38:05 <P1RATEZ> graph the ram sizes against input sizes
16:39:09 <P1RATEZ> look for outer function calls that depend on inner functions to be completed (excessive nesting)
16:39:17 <naudiz> P1RATEZ: the main problem is that the input data size already is O(n²), I'm calculating a quantumnmechanic 2D wave function 
16:39:26 <pacak> naudiz: Are you using lazy io?
16:40:17 <naudiz> pacak: the only io I'm using at the moment is plotting via gnuplot which should be lazy
16:41:56 <pavonia> naudiz: Maybe this is a start https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html
16:42:54 <pacak> naudiz: It could be that some parts of your data contain thunks that keeps a bunch of data from previous steps around.
16:43:13 <naudiz> I think I know what's the critical point of calculation, but I don't know if it's any use to paste it since it's depending on a lot of other code
16:43:14 * hackagebot urlpath 2.1.0 - Painfully simple URL writing combinators  http://hackage.haskell.org/package/urlpath-2.1.0 (athanclark)
16:44:45 <pacak> I have some code that helps to look for such thunks in arbitrary datatypes, maybe I should make it public...
16:46:44 <naudiz> here it is anyway: http://pastebin.com/sABmafzk it's calculating the kinetic energy step, the underlying datatype for Wave2D is Array (Int,Int). transpose applies swap to all indices
16:47:52 <indiagreen_> athan_: have you deprecated the faulty version?
16:48:16 <naudiz> pacak: I don't think the data from previous time steps is a big problem since the waves themselves aren't really that big (1~10MB, depending on the grid size)
16:48:26 <naudiz> pavonia: thanks, I'll have a look
16:48:49 <pacak> > foldl1 (+)  [1..1000000]
16:48:51 <lambdabot>  *Exception: stack overflow
16:48:54 <pacak> kaboom!
16:49:02 <pacak> And it's not exactly big either.
16:49:08 <pacak> > foldr1 (+)  [1..1000000]
16:49:09 <lambdabot>  *Exception: stack overflow
16:49:15 <pacak> > foldr1' (+)  [1..1000000]
16:49:16 <lambdabot>      Not in scope: ‘foldr1'’
16:49:16 <lambdabot>      Perhaps you meant one of these:
16:49:16 <lambdabot>        ‘BS.foldr1'’ (imported from Data.ByteString),
16:49:25 <pacak> > foldl' (+) 0 [1..1000000]
16:49:27 <lambdabot>  500000500000
16:50:17 <naudiz> I'm acually using: iterate timestep psi0, where timestep is the function providing the next timestep
16:50:51 <naudiz> also the memory usage doesn't really increase that much over time
16:52:29 <pacak> naudiz: Anyway, try enabling BangPatterns and adding ! all over the place.
16:57:50 <naudiz> pacak: how do I know where to add a !?
16:58:52 <pacak> naudiz: To every pattern match to make sure it's matched strictly
16:59:28 <pacak> > (\x -> ()) undefined
16:59:30 <lambdabot>  ()
16:59:33 <pacak> > (\!x -> ()) undefined
16:59:34 <lambdabot>  <hint>:1:6: parse error on input ‘->’
16:59:58 <pacak> Well... We want explosion around here anyway.
17:01:50 <naudiz> I don't really that many pattern matches. most of the code is assigning things after `where`
17:02:52 <c_wraith> be careful.  Too much strictness also causes performance problems.
17:05:27 <nshepperd> step 1 is probably to compile with -prof and run with +RTS -hc?
17:06:07 <michaelt_> > let check x = () in check undefined
17:06:08 <lambdabot>  ()
17:06:12 <michaelt_> > let check !x = () in check undefined
17:06:13 <c_wraith> First I'd just run with +RTS -h
17:06:14 <lambdabot>  *Exception: Prelude.undefined
17:06:22 <c_wraith> Don't need a profiling build for that
17:06:39 <c_wraith> and it at least gives you enough information to determine if the heap use is the problem
17:07:25 <michaelt_> naudiz: you can use a bang pattern if you define a function after "where" 
17:11:10 <naudiz> michaelt_: then it tells me the function isn'
17:11:14 <naudiz> michaelt_: then it tells me the function isn't defined
17:12:58 <naudiz> c_wraith: after running it with +RTS -h, where do I see the results?
17:13:19 <c_wraith> naudiz: it create a file named programname.hp
17:13:33 <c_wraith> naudiz: you can run hp2ps on that to convert it to a graph
17:14:36 <michaelt_> I just mean, you can write stuff like:  myfoldl op seed ls = go seed ls where go !acc [] = acc; go acc (x:xs) = go (op acc x) xs
17:16:07 <michaelt_> naudiz: the bang in "go !acc _" means that every time it comes around recursively to apply go, it has to have applied op and gotten somewhere
17:18:04 <naudiz> c_wraith: this is the output with one iteration http://abload.de/img/memjpod0.png
17:18:42 <Pamelloes> Is there a way to specify the kind of a parameter?
17:18:53 <c_wraith> naudiz: the profile is dominated by thunks.  That's an indication that it's definitely got issues
17:19:01 <michaelt_> Pamelloes: with KindSignatures 
17:19:02 <c_wraith> Pamelloes: enable -XKindSignatures
17:19:07 <Pamelloes> michaelt_: Ah, thanks
17:20:02 <c_wraith> naudiz: the trick is figuring out where 800 megs of thunks are coming from.
17:20:50 <oconnore> my fingers hurt from typing a bunch of exports, is there an easier way to do that?
17:20:56 <naudiz> I'm so overstrained right now :x
17:21:24 <naudiz> michaelt_: does this need some language extension to work?
17:21:51 <michaelt_> {-#LANGUAGE BangPatterns#-}
17:22:12 <naudiz> thank you
17:22:44 <michaelt_> naudiz: making strict fields on your data types is more pleasant anyway, and doesn't require an extension. 
17:23:17 <michaelt_> naudiz: like data Inty a = Inty !Int a
17:23:54 <oconnore> ah, the module keyword
17:24:39 <naudiz> michaelt_: how do I combine this with this syntax that I forgot the name of? data B = { getA :: A }
17:24:54 <johnw> data B = B { getB :: A }
17:24:57 <exio4> bang patterns isn't needed when using ! in a datatype declaration
17:25:00 <johnw> that's the normal pattern
17:25:04 <michaelt_> data B = B { getA :: !A }
17:25:19 <naudiz> johnw: that's that I wanted to write
17:25:23 <michaelt_> exio4: right that's what we were saying
17:25:53 <exio4> I should read the backlog before saying anything, duh
17:27:19 <michaelt_> naudiz: it's a little laborious, but I remember learning a lot from http://www.slideshare.net/tibbe/highperformance-haskell .  He's a little strictness-mad maybe ...
17:27:44 <johnw> strictness is also not always the solution for faster running code
17:28:08 <johnw> sometimes the answer is less strictness
17:28:16 <michaelt_> no way, indeed 
17:28:36 <naudiz> michaelt_: thanks, I'll have a look at it after running a few more tests with strict data types
17:29:24 <exio4> while talking about strict datatypes, is there any "standard" library for strict lists? 
17:30:33 <michaelt_> naudiz: it generally doesnt do so much good if you ! the recursive fields, but often is valuable for general fields like bah :: !a or things like humbug :: !Int 
17:31:09 <michaelt_> naudiz: or that's my simple-minded policy
17:31:51 <bananagram> if you have a data structure, can you store a lens that modifies itself in it? like a Lens' BotState Connection in the definition of BotState
17:31:58 <naudiz> well, it definitely takes longer with strict types
17:32:08 <johnw> bananagram: sure you can
17:32:14 <johnw> bananagram: just use ALens' instead of Lens
17:32:30 <bananagram> what's special about ALens'?
17:32:32 <johnw> a lens is just a function
17:32:39 <johnw> ALens is not rank-2, the way Lens is
17:32:48 <bananagram> oh, okay
17:32:50 <johnw> the documentation mentions it being the thing to use for storing in other types
17:32:57 <naudiz> but it doesn't do anything about the memory issue :/
17:33:09 <bananagram> I was having trouble making a lens an argument before
17:33:24 <bananagram> to a function I mean
17:33:56 <johnw> naudiz: when you have lots of thunks, it can mean that you're strict in one dimension, but too lazy in another
17:34:19 <johnw> like, if you make map (+1) [0..1000000] strict in the spine, you'll end up with 1000000 thunks
17:35:01 <johnw> otherwise, with other uses of laziness there's generally just a few thunks, whose evaluation might lead to new thunks, but they don't all need to sit on the heap together
17:35:10 <naudiz> johnw: I worked almost completely lazy before (except of using Data.Complex)
17:35:23 <johnw> k, can you paste your code?
17:36:13 <johnw> the graph you linked to implies the sudden creation of a very large data structure referencing many thunks, so that this data structure is being evaluated in the spine only at the very beginning, but then gradually evaluates its member thunks
17:36:32 <naudiz> pasting my code is problematic because there's a lot of it and it's hard to break down... but it's on github: https://github.com/KiNaudiz/bachelor/tree/master/CN
17:36:49 <johnw> naudiz: in the profile results, which method was the top allocator?
17:36:56 <johnw> did you compile the library with -fprof-auto?
17:37:59 <naudiz> no, I didn't. I compiled it with ghc main.hs -O2 -rtsopts, where main.hs just calls harmOsz2D from Test2D.hs
17:38:27 <johnw> ah
17:38:35 <johnw> bulid it all with -prof -fprof-auto if you can
17:38:58 <johnw> and it will indicate which call tree is pumping up your heap at the beginning
17:39:44 <pdxleif> Can you pattern match on a Data.HashMap.Strict?
17:40:00 <pdxleif> Err, I'm extracting some JSON - maybe I should just make a datatype.
17:40:10 <naudiz> does it make any difference wheather I plot it or print the results? printing would avoid having to install the prof-build of gnuplot
17:40:24 <johnw> yeah, i don't need to see the graph
17:40:32 <johnw> just the prof.out file, or whatever it's called
17:40:45 <ellwyne> Would anyone be able to help me understand why (Just (const 3)) <*> return 5 gives me Just 3, and not 3?
17:41:50 <naudiz> johnw: should I run it with +RTS -h again?
17:41:57 <johnw> +RTS -p
17:42:24 <ion> ellwyne: (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b
17:42:28 <naudiz> okay, wait a minute
17:43:48 <ellwyne> ion: i'm reading that (Just f) <*> x = fmap f x
17:44:25 <ellwyne> ion: so shouldn't (Just (const 3)) <*> return 5 give me fmap (const 3) (return 5)
17:45:02 <johnw> naudiz: where is 'dim' defined?
17:45:02 <pavonia> return 5 is Just 5 here
17:45:30 <ellwyne> pavonia: oh. i see.
17:45:33 <ellwyne> pavonia: thanks
17:45:40 <naudiz> johnw: which dim? there are multiple definitions
17:45:48 <johnw> Plot2D
17:46:00 <naudiz> johnw: http://pastebin.com/vLhK8euD
17:46:52 <naudiz> johnw: it's in ValueMatrix.hs
17:47:09 <naudiz> dim = snd . bounds . vmat
17:47:15 <johnw> and where is viewMap?
17:49:10 <johnw> naudiz: ok, I think I see the problem
17:49:11 <naudiz> johnw: that's part of gnuplot, but I commented out the plotting and added `print $ wset2DWaves waveT` to harmOsz2D before I executed it the last time. it doesn't make a difference in the memory usage (at least not a huge difference)
17:50:48 <johnw> if I'm right, it is a problem of being strict in spine and hanging a thunk on every element of that structure
17:50:53 <johnw> look at cn2D'
17:51:22 <sbrg> Didn't someone put up a semi-recent guide regarding using GHC as a library?
17:51:33 <johnw> the structure are the Wave2D, since being Arrays they are not lazily allocated
17:51:33 <sbrg> the documentation doesn't make it very easy
17:51:57 <johnw> and every element of these arrays you're making is a thunk, timestep
17:52:16 <naudiz> so what can I do about it?
17:52:19 <johnw> and every timestep call holds a reference to 'w'
17:52:24 <johnw> so, one of two things
17:52:39 <johnw> you can either not use arrays, and only compute the slots you need
17:53:00 <johnw> or, if you're always going to use the full NxM matrix that the arrays represent, don't store thunks in them
17:53:49 <naudiz> I am always going to use the full N×M matrix. how to I not store thunks?
17:53:59 <johnw> you want the results of both timestep and nts to be computed before cn2D' exits
17:55:02 <naudiz> sorry, I don't think I can follow :/
17:55:39 <johnw> https://github.com/KiNaudiz/bachelor/blob/master/CN/CN2D.hs
17:55:44 <johnw> line 49
17:56:06 <johnw> as it stands, it's just fine
17:56:39 <johnw> the real pain (I think) comes when you ask for the 'dim' of each wave
17:57:05 <johnw> at first the list is empty, because it's lazy
17:57:17 <johnw> each new element that you cause to be evaluate brings into being an array, filled with thunks
17:57:33 <johnw> you want the creation of those arrays to demand their contents, if in the end you're always going to want to see them
17:58:16 <johnw> so, creation of each Wave2D can be a lazy process, that's good; but making a Wave2D should fully compute all its values at once
17:58:26 <johnw> i mean, [Wave2D] is lazy
17:58:27 <nshepperd> aren't you already using unboxed arrays?
17:58:54 <naudiz> are you saying I should define timestep at the same "layer" as cn2D'?
17:59:21 <johnw> you want the result of evaluating timestep to handle you back a fully evaluated value
17:59:22 <naudiz> nshepperd: no, I'm using boxed arrays because UArray (Int,Int) isn't an instance of IArray
17:59:44 <exio4> I would have used Vector(s) :P 
18:00:54 <johnw> iterate tns wave0 will itself become a thunk.  When I force that thunk, I'll get a list element containing another thunk.  When I force *that* thunk, I want a fully formed Wave2D
18:01:04 <johnw> sorry if that doesn't make sense, I have to head home now and I can't work on this further
18:01:54 <naudiz> johnw: thank you for your help... I just don't understand how to force timestamp to give me a fully evaluated value
18:02:18 <johnw> you'll need a very judicious use of bang patterns and/or seq
18:03:02 <johnw> the way seq works is that you have x `seq` y, and it means that when y gets forced, x is forced.  If y depends on x, this gives you a way to avoid returning thunks inside y
18:03:27 <johnw> i know that hopelessly unclear, sorry
18:03:32 <johnw> I hope someone else here can take over
18:03:40 <naudiz> I'll try, thanks... this whole bang thing is pretty new to me :/
18:04:59 * mjrosenb is having some issues with Reactive.Banana
18:05:24 <nshepperd> in ValueMatrix.hs... is the import of Data.Array.Unboxed not correct?
18:05:33 <mjrosenb> it looks like I'm creating an event, handler pair with newEvent, but the new events are never getting fired.
18:05:46 <mjrosenb> and I'm like 99% sure I'm actually calling the handler.
18:06:28 <nshepperd> I assume not, because an unboxed array can't be a Functor
18:07:07 <naudiz> nshepperd: I planned on using UArray but it caused problems. I just changed it to be another import
18:07:14 <nshepperd> right
18:08:09 <nshepperd> well, the quick and dirty fix is to write 'timestep  w     = deepseq w (timestep' w w)'
18:08:43 <nshepperd> with an NFData instance for ValueMatrix
18:09:10 <nshepperd> that will tell you if the 'iterate timestep' thing is really to blame, at least
18:12:53 <naudiz> nshepperd: I'll give it a try, thanks
18:18:44 <mjrosenb> ok, it definitely looks like things that I register with fromAddHandler are never being triggered :-(
18:19:00 <naudiz> nshepperd: `instance NFData a => NFData (ValueMatrix a) where rnf = genericRnf` results in an error but should be right according to https://hackage.haskell.org/package/deepseq-generics-0.1.1.2/docs/Control-DeepSeq-Generics.html any quick idea what's wrong? 
18:19:15 * mjrosenb wonders if this is because I'm explicitly doing this from the main thread, and it doesn't like that.
18:20:03 <naudiz> "Could not deduce (Control.DeepSeq.Generics.GNFData  (GHC.Generics.Rep (ValueMatrix.ValueMatrix a))) arising from a use of ‘Control.DeepSeq.Generics.genericRnf’"
18:20:45 <nshepperd> hmm, I don't know much generics
18:20:55 <nshepperd> 'instance NFData a => NFData ValueMatrix a where rnf (VM arr) = rnf arr' should work though
18:21:00 <mjrosenb> ok, If I'm not on the main thread, and I have an IO a, can I ask the main thread to evaluate it, and have control return to me when it is done?
18:21:41 <nshepperd> er, NFData (ValueMatrix a) obvs
18:21:45 <naudiz> it does, thanks
18:23:33 <mjrosenb> FFFFFFF\
18:24:01 <mjrosenb> ok, the issue is that liftIOLater is in fact not late enough to start the render loop.
18:24:21 <naudiz> let's see if the memory consumption is lower now....
18:26:48 <marchelzo_> Is anyone here familiar with the websockets library?
18:27:02 <naudiz> nshepperd: it's much better now, but I guess depending on deepseq isn't very elegant, is it?
18:30:06 <marchelzo_> Is it possible to do non-blocking reads from a websocket? Or check if there is a pending message?
18:31:04 <geekosaur> usually you use threads
18:31:40 <mjrosenb> what has the world come to?
18:31:43 <erisco> marchelzo_ I have not worked with websockets, but because Haskell has application level threads those are typically used instead of, say, callbacks
18:31:46 <mjrosenb> I have an IORef (IO())
18:32:04 <marchelzo_> geekosaur: I am currently trying to use 'race' from async, but if the thread waiting for the websocket is killed, the server automatically closes the connection for some reason.
18:32:05 <erisco> i.e. you start a new application thread which blocks trying to read
18:33:35 <marchelzo_> erisco: that's what I'm doing, but I want to be able to stop waiting
18:34:10 <erisco> I think you can kill one thread from another, could be wrong about that
18:34:12 <naudiz> nshepperd: well, thank you for your help. I'll just depend on deepseq for now. At least it's just a bachelor thesis
18:34:40 <erisco> I would not be surprised if a library had threads with timeout
18:34:57 <nshepperd> naudiz: yeah, I think the received wisdom is to use strict data structures, then you can just use ordinary seq, or equivalently, 'timestep !w = ...'
18:35:33 <erisco> also whatever you are calling out to that blocks may be configurable to have a max wait time
18:35:38 <erisco> not that you'd want to rely on that, ideally
18:35:48 <nshepperd> but making 'ValueMatrix a' strict seems difficult when you're using unboxed arrays
18:36:09 <nshepperd> er, boxed arrays
18:37:29 <joneshf-laptop> can i derive an `Arbitrary` instance automatically?
18:37:30 <naudiz> it's good as long as it produces the desired data. It doesn't have to be a super elegant programm
18:37:31 <nshepperd> the nearest thing would be to export a smart constructor 'vm arr = deepseq arr (VM arr)' instead of the actual VM constructor
18:37:49 <joneshf-laptop> say I have `data Plus a b = L a | R b`
18:39:07 <joneshf-laptop> do i need to derive the big three, `Data`, `Generic` and `Typeable`?
18:40:57 <naudiz> from 3GB down to .7GB RAM usage... that actually really makes me happy :) now I can finally use bigger input data
18:41:58 <erisco> naudiz that way lies despair
18:42:21 <naudiz> there's still lots of thunk but for now it should be good enough
18:46:41 <michaelt_> naudiz: ValueMatrix should be a newtype , no?
18:47:21 <naudiz> michaelt_: does it make any difference?
18:47:56 <michaelt_> sure, it can.  
18:48:19 <naudiz> I'll look into that, thanks
18:48:31 <michaelt_> in theory the compiler's representation of newtype A a = A a , is the same as its representation of a 
18:48:38 <johnw> i kind of doubt it would, in this case
18:48:59 <johnw> naudiz: you should change your thesis to be about writing efficient programs in Haskell :)
18:49:47 <naudiz> johnw: I don't think that would work :D I'm studying physics
18:56:55 <michaelt_> naudiz: there are a lot of simple things that kind of add up it seems to me, e.g zipWith in the Vector  module goes to lists, zipWith them, then goes back to Vector (array)
18:59:08 <naudiz> michaelt_: I should have known this is a bad idea... some tasks were just easier to handle with lists and I was lazy...
18:59:27 <johnw> and somtimes lists are even faster ;)
18:59:40 <johnw> probably not in this case
18:59:45 <johnw> but it's almost always better to start there
18:59:46 <michaelt_> you could do the Vector module with Data.Vector.Unboxed, but that wont help with the 2d case
19:00:58 <naudiz> michaelt_: it might reduce some more thunk since the 2d case is just a bunch of 1d calculations
19:01:04 <michaelt_> v `dot` w   = L.sum $ elems $ vec $ Vector.zipWith (*) v w is making a few too many round trips...
19:01:42 <johnw> oh yeah, that's actually a fair bit less efficient than L.sum $ zipWith (*) v w
19:02:09 <johnw> i mean, L.sum $ zipWith (*) (fromList v) (fromList w)
19:02:29 <johnw> which should fuse away to just an iteration over the two vectors
19:02:41 <johnw> sorry, toList, not fromList
19:03:10 <johnw> in the code above, you have to allocate a temporary vector that I don't believe GHC will know to discard
19:03:34 <naudiz> I'm actually not sure if dot is actually used. it should just be there for completion
19:03:39 <naudiz> but I'll change it anyway
19:03:50 <ion> I just learned what strength means in CT from Burritos for the Hungry Mathematician.
19:05:34 <ion> But i have really hard time getting the laws unless i assume his composition operator is flipped.
19:08:19 * hackagebot stackage-setup 0.0.2 - An executable for downloading a Haskell setup  http://hackage.haskell.org/package/stackage-setup-0.0.2 (DanBurton)
19:11:03 <johnw> ion: have you seen http://statusfailed.com/blog/2013/01/26/haskells-strength-generalising-with-lenses.html?
19:11:21 <ion> johnw: I had not. Thanks.
19:18:19 * hackagebot Concurrential 0.5.0.0 - Mix concurrent and sequential computation  http://hackage.haskell.org/package/Concurrential-0.5.0.0 (alexvieth)
19:25:23 <michaelt_> naudiz: here's a sort of 2d matrix library that might have some ideas https://github.com/bos/statistics/blob/master/Statistics/Matrix/Types.hs https://github.com/bos/statistics/blob/master/Statistics/Matrix.hs He only has them storing Double because of his purposes
19:28:41 <naudiz> michaelt_: thank you, I'll have a look :)
19:33:19 * hackagebot stackage-sandbox 0.1.2 - Work with shared stackage sandboxes  http://hackage.haskell.org/package/stackage-sandbox-0.1.2 (DanBurton)
19:48:47 <marchelzo_> Does anybody know if it is possible to receive data from a websocket without blocking using the websockets package?
19:51:24 <ion> marchelzo: In what way is the blocking a problem for you?
19:53:31 <johnw> marchelzo_: you can block in a thread
19:54:00 <marchelzo_> johnw: But if I kill that thread, the TCP connection is closed, and I don't want that.
19:54:36 <KaneTW> why would you kill the thread
19:54:56 <marchelzo_> I am expecting a response within a certain number of seconds, otherwise I do something else.
19:57:37 <johnw> the thread can timeout it's call to receive, without closing the socket
19:58:16 <johnw> in other words, your question right now is making assumptions about how to solve the problem, so I doubt we can answer well
19:58:37 <marchelzo_> johnw: how do I make it timeout the call to receive?
19:58:44 <johnw> the function "timeout"
19:59:50 <marchelzo_> I'm currently doing 'race (threadDelay n) (receiveData connection)'. Will timeout have a different effect?
20:00:33 <johnw> it won't kill the thread :)
20:00:46 <johnw> eres <- timeout n $ receiveData connection
20:00:54 <marchelzo_> Is timeout in Control.Concurrent?
20:00:55 <johnw> case eres of Left _ -> ...; Right x -> ...
20:01:00 <johnw> yeah, I think so
20:01:12 <marchelzo_> So... what does it do to the thread exactly?
20:01:23 <johnw> it raises an async exception
20:01:34 <johnw> that timeout catches and handles
20:01:40 <ion> FWIW, the receive in websockets does seem to catch exceptions and set its state to closed.
20:01:47 <marchelzo_> I see. Thanks very much.
20:01:54 <johnw> ion: eww
20:02:04 <ion> Yes
20:02:10 <johnw> ok, I could be wrong then, I haven't used websockets much
20:02:34 <marchelzo_> ion: Wait, receive will catch the async exception and close the connection?
20:02:54 <ion> http://hackage.haskell.org/package/websockets-0.9.4.0/docs/src/Network-WebSockets-Connection.html#receive
20:04:59 <marchelzo_> Well then.
20:05:53 <ion> Perhaps bug the developer about it.
20:08:30 <marchelzo_> I submitted an issue
20:11:07 <Luke> how do I make a MonadTrans instance for "WriterT w (ExceptT e m) a"?
20:12:03 <johnw> GeneralizedNewtypeDeriving should do it, doesn't it?
20:12:07 <c_wraith> Luke: I would be shocked if there isn't already a MonadTrans instance for WriterT w
20:12:17 <Luke> tehre is
20:12:27 <Luke> johnw: no it doesnt
20:12:58 <Luke> johnw: cannot eta-reduce
20:15:06 <michaelt_> Luke: if I understand you, you will need to newtype it. 
20:15:22 <Luke> michaelt_: why is that?
20:16:38 <michaelt_> WriterT w (ExceptT e m) a :: *; WriterT w (ExceptT e m) :: * -> *; but what is the thing that is (* -> *) -> (* -> *) ?  newtype Luke e m a = Luke {runLuke :: WriterT w (ExceptT e m) a} deriving everything if you like
20:17:05 <michaelt_> Luke w e m a
20:17:17 <fuzzyhorns> is this right? http://kybernetikos.com/2012/07/10/design-pattern-wrapper-with-composable-actions/ are promises really monads?
20:17:31 <Luke> oh i'm sorry i'm already trying to newtype it
20:17:37 <fuzzyhorns> i dont see a proof of them obeying the monad laws
20:17:49 <fuzzyhorns> but it otherwise makes sense to me in an informal way
20:18:14 <c_wraith> fuzzyhorns: you can certainly make monadic promises..  But not all implementations will be monadic.
20:18:42 <fuzzyhorns> when they are monadic, what do they tend to be, do oyu think?
20:18:43 <Luke> michaelt_: I have a newtype and i'm trying to use GeneralizedNewtypeDeriving for deriving MonadTrans and it's not workign
20:18:57 <Luke> unable to do the eta-reduce
20:19:29 <michaelt_> oh, is that right it doesnt see how to do it.  It's trivial though :: lift = Luke . lift . lift , no?
20:19:46 <Luke> yeah
20:20:15 <michaelt_> I see, does the compiler say 'can't eta reduce' ?
20:20:38 <Luke> yes
20:22:32 <michaelt_> ah I see it now, nice.
20:23:18 <Luke> michaelt_: hand coding the lift does work as you suggested... not sure why it can't derive it though
20:24:41 <Luke> michaelt_: i'm not sure what the recommended best practice is here
20:25:44 <nitrix> Is there a term for operations in Haskell that are always "strict"? For example, mapM sorts of breaks the ideology of "lazy".
20:26:00 <c_wraith> Luke: you could try using StandaloneDeriving + GeneralizedNewtypeDeriving
20:26:13 <Luke> c_wraith: I tried that. couldn't get it to work for some reaosn
20:26:14 <c_wraith> Luke: being able to declare the instance standalone gives you a lot more control
20:26:30 <nitrix> I understand it is still lazy, but the function's job is to sequence things, therefore, you have to compute the whole thing. Is there a term to describe such property?
20:26:32 <Luke> its just "instance MonadTrans MyType" right?
20:26:39 <Luke> where "MyType" is the newtype wrapper
20:26:51 <nitrix> It isn't "technically" strict.
20:26:53 <c_wraith> Luke: possibly with all the constraints needed
20:26:58 <thomaseding> nitrix: Monadic sequencing?
20:27:02 <Luke> c_wraith: what do you mean?
20:28:00 <michaelt_> funny, 'deriving instance ...' gives the same error. 
20:28:16 <c_wraith> Luke: you might need to specify constraints necessary for the instance. "deriving instance Monoid w => MonadTrans (MyType w)" for instance
20:28:18 <Luke> c_wraith: I get "No explicit implementation for ‘lift’" warnings when doing StandaloneDeriving (and it says i don't need standalone deriving)
20:28:32 <nitrix> thomaseding: So Monadic sequencing isn't itself the problem. It's the strictness of the monad's >>= operator that determines the strictness of mapM ?
20:28:54 <michaelt_> instance Monoid w => MonadTrans (MyType w e) where lift = MyTypeWrapper . lift . lift
20:28:56 <thomaseding> nitrix: That's exactly what I mean
20:29:32 <Denommus> I'm sad 
20:29:37 <michaelt_> Luke: there's nothing to be said against defining lift by hand!
20:29:39 <Luke> michaelt_: that works without constraints
20:29:45 <Luke> michaelt_: but it's not automatic
20:30:03 <Luke> I'm not sure why standalone deriving doesn't work though
20:30:37 <Denommus> I realized that something like mfix in a strict language is too difficult 
20:30:48 <Azel> nitrix: Isn't mapM just map for [a]'s instance?
20:30:58 <michaelt_> without constraints, Luke ? I get     Could not deduce (Monoid w) arising from a use of ‘lift’    ... but maybe I'm understanding something else
20:31:23 <Luke> michaelt_: I used NewtypeGernairzedDeriving for Applicative and Functor to get that
20:31:24 <thomaseding> Luke: Is this related to the problem? https://ghc.haskell.org/trac/ghc/ticket/8740
20:31:50 <michaelt_> Luke: right, when it can make the inference, it can also figure out the constraints 
20:32:32 <nitrix> Denommus: Get lazier :3
20:32:38 <Luke> michaelt_: even with all the constraints moved to NewtypeDeriving I still can't get the MonadTrans StandaloneDeriving working
20:32:47 <Luke> thomaseding: doesn't look like it
20:33:08 <michaelt_> right, I can't get StandaloneDeriving to work either
20:33:48 <Luke> michaelt_: weird right?
20:33:51 <Denommus> nitrix: one of the reasons I'm doing my library is experimenting FRP in a strict language 
20:33:52 <Luke> i don't understand why it won't work
20:35:13 <michaelt_> I'm surprised too, but there is presumably some very obvious reason we're not seeing. If I define newtype L w m a = L {runL :: WriterT w (ExceptT w m) a}  deriving (Functor, Applicative, Monad) it works
20:35:33 <michaelt_> but there I don't feel like it's stupid not deriving the MonadTrans instance...
20:36:43 <nitrix> Denommus: mfix is infinitely recursive?
20:36:49 <Luke> michaelt_: what do you mean you don't feel like it's stupid not deriving MonadTrans?
20:37:40 <michaelt_> Luke: I meant in the case I just imagined, where the Writer monoid is also the ExceptT type
20:37:57 <Luke> i don't follow
20:38:07 <Luke> i have the exact type you mentioned
20:38:22 * hackagebot markup 1.1.0 - Abstraction for markup languages  http://hackage.haskell.org/package/markup-1.1.0 (athanclark)
20:38:24 * hackagebot nested-routes 2.0.0 - Declarative, compositional Wai responses  http://hackage.haskell.org/package/nested-routes-2.0.0 (athanclark)
20:38:54 <michaelt_> Luke: no, you distinguished w from e, I thought
20:39:17 <Luke> oh i'm sorry you're right. I didn't catch that 
20:40:07 <Denommus> nitrix: no
20:40:10 <michaelt_> the same definition of lift can be used for my goofy type. I was just mentioning it because it might give insight what the problem is...
20:40:16 <Denommus> nitrix: that's the thing 
20:41:22 <pomf> rms = sqrt . mean . map (^ 2)
20:41:23 <pomf>   where mean = liftA2 div sum length
20:41:25 <pomf> ^ dat correct?
20:43:09 <Luke> michaelt_: I think I have this problem w/ any monad transformer stack of 2 or more monads that I try to derive MonadTrans form
20:43:14 <nitrix> > let main = mfix (\x -> putStrLn "Test")
20:43:16 <lambdabot>  <no location info>:
20:43:16 <lambdabot>      not an expression: ‘let main = mfix (\x -> putStrLn "Test")’
20:44:38 <nitrix> :(
20:44:52 <pomf> Hai nitrix
20:45:05 <nitrix> I made lambdabot angry :(
20:46:14 <nitrix> pomf: You change your name too often!
20:46:46 <pomf> nitrix: Thank you. :)
20:47:09 <pomf> nitrix: I use pomf when I'm not on my computer,
20:47:31 <nitrix> pomf: Gotcha :P
20:50:13 <naudiz> pomf: what's the sticky stuff on you?
20:50:54 <pomf> naudiz: Hey, hey, let's play until I smell like salty coins and milk
20:52:21 <naudiz> pomf: there's just no way that thing will fit, endure it
21:08:23 * hackagebot nested-routes 2.0.1 - Declarative, compositional Wai responses  http://hackage.haskell.org/package/nested-routes-2.0.1 (athanclark)
21:33:47 <lpaste> fds pasted “public virtual void An(string thucAn)     {         Console.WriteLine("dong vat dang an " + thucAn);     }” at http://lpaste.net/3169756357746229248
21:33:56 <lpaste> fds pasted “public virtual void An(string thucAn)     {         Console.WriteLine("dong vat dang an " + thucAn);     }” at http://lpaste.net/132596
21:42:03 <srhb> wat...
21:42:18 <srhb> Thai Java on lpaste? <_<
21:43:24 * hackagebot pipes-vector 0.6.1 - Various proxies for streaming data into vectors  http://hackage.haskell.org/package/pipes-vector-0.6.1 (BenGamari)
21:43:26 * hackagebot newtype-generics 0.4.1 - A typeclass and set of functions for working with newtypes, with generics support.  http://hackage.haskell.org/package/newtype-generics-0.4.1 (jcristovao)
21:58:05 <TallerGhostWalt> trying to understand this: http://www.reddit.com/r/haskell/comments/35vc31/the_real_way_to_generate_a_list_of_primes_in/cr88t9i
21:58:32 <srhb> TallerGhostWalt: What about it?
21:58:57 <TallerGhostWalt> I haven't profiled it, I know mod is slower than rem.  but is it able to skip filtering the number list over and over ? 
21:59:07 <TallerGhostWalt> because of the way lists are formed ? 
21:59:17 <srhb> TallerGhostWalt: Yes, primes and primes' are only evaluated once.
21:59:20 <srhb> (yay laziness)
22:00:05 <TallerGhostWalt> very cool
22:01:34 <TallerGhostWalt> is there a way to step through this?
22:01:49 <srhb> TallerGhostWalt: By hand, yes. :)
22:02:55 <TallerGhostWalt> what I don't get is you end up with a lot of isPrime being applied to the tail of lists are those all the same list somehow at the end?
22:03:25 <srhb> TallerGhostWalt: isPrime is only applied once to each number in primes'
22:03:34 <srhb> Er
22:03:42 <srhb> Each number in [5,7..]
22:04:01 <TallerGhostWalt> right right 
22:04:05 <srhb> I'm not quite sure what you mean by the tail of lists.
22:04:06 <TallerGhostWalt> I see now 
22:04:20 <TallerGhostWalt> maybe ..
22:04:46 <srhb> Have you tried evaluating it manually up to, say, 5 primes?
22:04:46 <TallerGhostWalt> i am going to go work it by hand 
22:04:51 <srhb> Yeah :)
22:04:52 <TallerGhostWalt> yeah that is what I am about to do 
22:04:53 <TallerGhostWalt> thanks 
22:04:58 <srhb> Do ask if you get stuck.
22:05:02 <TallerGhostWalt> k thanks 
22:05:59 <srhb> (I have a feeling your actual question might be "why do primes prime" and to that the answer is either "because prime" or "hmm, I wonder if there's a number theorist here") :-)
22:06:23 <TallerGhostWalt> lol
22:06:46 <TallerGhostWalt> srhb: and the answer to that question will probably be yes there is 
22:06:54 <srhb> Probably, yes. :D
22:08:34 <CapitalSigma> i've installed Control.Lens in a sandbox and imported it. why am i getting "Parse error: naked expression at top level" when i try to "makeLenses ''Foo"?
22:08:51 <jle`> you might need to enable the TemplateHaskell extension
22:09:07 <jle`> i feel like the GHC error should be suggesting this....
22:09:26 <jle`> but it might be some edge case
22:09:30 <CapitalSigma> i've got {-# LANGUAGE TemplateHaskell #-} at the top
22:09:54 <naudiz> what is it with those lenses?
22:10:10 <jle`> try makeLens 'Foo
22:10:12 <CapitalSigma> ah, no, i forgot to put it before "module Foo where..."
22:10:16 <CapitalSigma> nevermind, thanks
22:10:25 <jle`> ah yeah
22:10:35 <srhb> naudiz: http://lens.github.io/tutorial.html
22:10:46 <srhb> naudiz: If you're interested. :)
22:11:28 <naudiz> srhb: I'm always interested in cool new stuff ;) thank you
22:12:48 <srhb> Hmm. Hackage appears to be ded.
22:13:21 <naudiz> srhb: unfortunately it dives directly into the usage... I'd be more interested in what they are exactly
22:15:01 <srhb> naudiz: http://lens.github.io/ -- the video there is quite good, and you can probably get away with just reading the slides also linked there :)
22:15:35 <naudiz> thanks :)
22:17:03 <srhb> Actually, the video appears to be broken there.
22:17:07 <srhb> https://www.youtube.com/watch?v=cefnmjtAolY
22:20:22 <naudiz> srhb: it worked for me 
22:20:36 <srhb> Oh. I guess my browser is bork then.
22:20:46 <TallerGhostWalt> srhb:didn't work for me either
22:21:03 <naudiz> browsers tend to be
22:23:49 <dmj`> hackage is down
22:24:21 <Axman6> #haskell-infrastructure would be a better place to notify
22:25:08 <jle`> yay it's back up
22:25:10 <relrod> dmj`: thanks, it's back, we had to do some reboots
22:25:29 <jle`> thank you hackage team
22:26:18 <sclv> for the info of all https://status.haskell.org/ lets you know what's up with infra, as the info line says
22:26:28 <sclv> in this case it notes we have to do some scheduled reboots for security patches
22:26:44 <TallerGhostWalt> sclv: I always forget about that 
22:26:49 <sclv> hackage takes a while to spin back up, unlike some other servers
22:27:18 <srhb> It also said all systems operational though.
22:28:44 <dmj`> acid-state went haywire again
22:29:26 <srhb> dmj`: ?
22:29:39 <dmj`> srhb: it was a joke, anything hackage related acid-state gets flack over
22:29:45 <srhb> Ah :P
22:33:46 <sclv> srhb: yes but it also said "server reboots, planned maintenance"
22:33:47 <sclv> :-P
22:34:12 <srhb> sclv: Right, my message was in response to you saying that. If I continue now, we'll get stuck. :-)
22:35:03 <sclv> <<loop>>
22:37:06 <TallerGhostWalt> srhb: I think you are right... my question ended up being, why do primes prime... That just sort of happened
22:37:15 <srhb> TallerGhostWalt: :D
22:37:52 <TallerGhostWalt> that is a really neat little use of short circuiting 
22:38:34 <srhb> I think the fair efficiency is quite impressive considering how simple it is.
22:39:29 <srhb> TallerGhostWalt: If you want to dive deeper, Melissa E O'Neills article is very accessible. It's linked in the related blog post.
22:42:05 <TallerGhostWalt> srhb: ooh I didn't catch that was a link I though O' Neill was the blog post author lol
22:42:10 <TallerGhostWalt> thanks for the heads up 
22:42:18 <srhb> :)
22:43:45 * hackagebot lambda-options 0.1.0.0 - A modern command-line parser for Haskell.  http://hackage.haskell.org/package/lambda-options-0.1.0.0 (ThomasEding)
22:44:07 <srhb> Ugh, I rewatched the introduction of the video and now I want (.) to be fmap.
22:44:29 <jle`> > let (.) = fmap in show . [1,2,3]
22:44:31 <lambdabot>  ["1","2","3"]
22:44:34 <jle`> idk
22:44:35 <srhb> I think I might need an exorcist.
22:45:17 <thomaseding> > performExorcism
22:45:19 <lambdabot>  Not in scope: ‘performExorcism’
22:45:59 <jle`> > unsafePerformExorcism
22:46:00 <lambdabot>  done
22:46:16 <srhb> Haha.
22:47:06 <pacak> >let 1 + 1 = 3 in 1 + 1
22:52:03 <thomaseding> > 1 + 1
22:52:04 <lambdabot>  2
22:52:16 <thomaseding> @let 1 + 1 = 3
22:52:17 <lambdabot>  .L.hs:145:13:
22:52:18 <lambdabot>      Ambiguous occurrence ‘+’
22:52:18 <lambdabot>      It could refer to either ‘L.+’, defined at .L.hs:150:3
22:52:29 <srhb> Please don't :P
22:52:46 <thomaseding> haha ok
22:53:06 <srhb> > let 1 + 1 = 3 in 1 + 1 -- is fine
22:53:08 <lambdabot>  3
23:03:45 * hackagebot path 0.3.0 - Path  http://hackage.haskell.org/package/path-0.3.0 (ChrisDone)
23:08:46 * hackagebot wai-middleware-crowd 0.1.1.0 - Middleware and utilities for using Atlassian Crowd authentication  http://hackage.haskell.org/package/wai-middleware-crowd-0.1.1.0 (MichaelSnoyman)
23:27:00 <luyifan> how to start haskell?
23:27:58 <luyifan> if you have no experience in function language
23:28:50 <Hijiri> try https://github.com/bitemyapp/learnhaskell
23:33:46 * hackagebot bitcoin-api-extra 0.9.1 - Higher level constructs on top of the bitcoin-api package  http://hackage.haskell.org/package/bitcoin-api-extra-0.9.1 (solatis)
23:43:47 * hackagebot tidal 0.4.32 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.32 (AlexMcLean)
