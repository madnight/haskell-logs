00:00:28 <ronh-> shield00 when you need to use let inside a lambda it may be cleaner to just turn it into a named function 
00:01:27 <Cale> dzack: One does need to take a bit of care in defining the composition of proofs so that the identity will really be an identity, and the composition will be associative though.
00:02:31 <Cale> dzack: and of course, this being #haskell, we'd be remiss not to mention that you can form a category whose objects are Haskell types, and whose arrows are the Haskell definable functions between those types.
00:02:59 <Cale> (or similarly for many other programming languages)
00:04:49 <Geraldus> hey folks! Is here OS X Yosemite users, especially on MacBook-Pro? 
00:06:09 <Axman6> yes. is this a haskell question?
00:23:04 <tmtwd> what  is the best emacs mode for haskell?
00:23:52 <Geraldus> tmtwd: haskell-mode
00:24:04 <Geraldus> tmtwd: https://github.com/haskell/haskell-mode
00:24:19 <Haskellfant> it's the only one afaik, so it has to be the best one :)
00:24:47 <Geraldus> tmtwd: Also, try interactive-haskell-mode (provided with haskell-mode, see wiki)
00:26:01 <Geraldus> in case of interactive-haskell-mode also consider installing GHCi-ng. https://github.com/chrisdone/ghci-ng
00:28:19 * hackagebot lambda-options 0.3.0.0 - A modern command-line parser for Haskell.  http://hackage.haskell.org/package/lambda-options-0.3.0.0 (ThomasEding)
00:30:13 <tmtwd> ok, I installed it
00:30:19 <tmtwd> how do I launch is
00:30:20 <tmtwd> ?
00:30:26 <tmtwd> M-x haskell mode?
00:31:11 <tmtwd> Or rather, get the repl
00:31:33 <tmtwd> I'm in haskell interactive projectile but I'm not getting a repl
00:52:53 <gfixler> what does one do when cabal install fails in a sandbox?
00:52:57 <gfixler> in this case, on vty-ui
00:53:04 <Axman6> how did it fail?
00:53:14 <gfixler> version conflicts with vty
00:53:19 <gfixler> I'm compiling again, I can share the errors at the end
00:54:31 <gfixler> it just needs another to finish building lens
00:54:35 <gfixler> another hour*
00:55:17 <gfixler> http://lpaste.net/132717
00:55:22 <gfixler> Axman6: ^
00:59:56 <tmtwd> alright well I have some kind of repl now
01:01:49 <Axman6> gfixler: looks like you need to update cabal
01:01:56 <Axman6> I think
01:02:51 <gfixler> oh
01:03:06 <gfixler> man, cabal needs updates more often than I need praise and reassurance
01:03:20 * hackagebot Zora 1.2.0 - Graphing library wrapper + assorted useful functions  http://hackage.haskell.org/package/Zora-1.2.0 (bgwines)
01:14:13 <jle`> do you think people would mind/there would be namespace issues if i named a library 'como'
01:14:20 <jle`> cause it's like a common word in spanish
01:14:30 <jle`> i always feel bad taking names
01:14:44 <jle`> what if somebody comes along with a library that is more suited for the name como :'(
01:14:52 <jle`> the struggle
01:20:30 <HEGX64> What does 'como' mean?
01:20:51 <jle`> in spanish it means "how"
01:20:58 <mniip> probably the inverese of 'mo'
01:21:16 <jle`> yes, "mo" is "cohow"
01:21:51 <jle`> my tagline for this project is "numerical analysis and algorithm platform in Haskell powered by comonads and cokleisli composition."
01:26:33 <gfixler> Axman6: still fails: http://lpaste.net/132717
01:26:41 <gfixler> but vty bumped up a dot
01:27:06 <gfixler> HEGX64: como can also mean "I eat" in Spanish.
01:27:32 <Axman6> gfixler: have you set cabal-version:       >=1.18 in your .cabal file?
01:27:41 <jle`> oh, that also does fit
01:28:06 <jle`> 'i eat' and 'how' can fit metaphorically into the design of my library
01:29:27 <gfixler> jle`: ¿como?
01:29:27 <mniip> como como
01:29:38 <gfixler> Axman6: just tried it; didn't work
01:29:54 <jle`> maybe i should call the library ¿como? with both question marks
01:29:56 <gfixler> Axman6: do I need to uninstall the last attempt, or force something?
01:30:01 <jle`> hackage and cabal allow that, right?
01:30:36 <jle`> yo como, nosotros comemos, ellen comonads
01:30:42 <Axman6> gfixler: what does cabal sandbox hc-pkg list | grep cabal say?
01:30:58 <mniip> cabal install $'\u00BF'como'?'
01:31:06 <gfixler> Axman6: /home/gfixler/code/haskell/vty/.cabal-sandbox/x86_64-linux-ghc-7.6.3-packages.conf.d:
01:31:20 <Axman6> :\
01:31:26 <Axman6> maybe grep Cabal?
01:31:42 <gfixler> Cabal-1.16.0
01:31:47 <gfixler> so cabal is old?
01:31:56 <Axman6> looks like it
01:31:59 <gfixler> hmmm
01:32:03 <gfixler> cabal install cabal?
01:32:13 <jle`> last time i used cabal 1.16, reagan was still president
01:32:15 <Axman6> sure
01:32:16 <gfixler> cabal install ¿como?
01:32:26 <Haskellfant> I don't think you can easily upgrade the Cabal library, afaik it's tied to the ghc version (pre 7.10)
01:32:40 <gfixler> Haskellfant: d'oh - I installed through the platform
01:32:48 <Axman6> (or, start from scratch with cabal sandbox delete; cabal sandbox init;  cabal install --only-dependencies)
01:33:09 <Axman6> that's quite an old cabal version
01:33:26 <gfixler> it's only .02 back
01:33:44 <Axman6> we're up to at least 1.22 no?
01:34:02 <gfixler> is there a repo I can point to through apt?
01:35:00 <jle`> yeah
01:35:04 <Axman6> now you're getting beyond my skills. sounds like you're using quite old packages (ghc 7.6 perhaps?)
01:35:12 <Haskellfant> it's linked here https://www.haskell.org/downloads/linux
01:35:52 <gfixler> Axman6: 7.6.3
01:35:53 <jle`> https://launchpad.net/~hvr/+archive/ubuntu/ghc
01:39:53 <gfixler> whoa
01:40:03 <gfixler> jle`: added that ppa and did an upgrade
01:40:06 <gfixler> now I'm v1.22
01:40:12 <jle`> hooray1
01:40:14 <jle`> !
01:43:20 <gfixler> (╯°□°）╯︵ ┻━┻)
01:44:24 <ryantrinkle> if i have two types, both of which are applications of closed type families, and which should always produce the same result
01:44:32 <Axman6> my experience working with ubuntu is that it's horrible for doing haskell stuff on
01:44:36 <ryantrinkle> how do i go about showing GHC that they in fact always produce the same result?
01:45:00 <pacak> @flip table
01:45:00 <lambdabot> stop telling me what to do
01:45:57 <jle`> ryantrinkle: from what i've gathered, it's not easy, i think...you might have to have a second type family that takes two types and returns if they produce the same result
01:46:01 <jle`> hm.
01:46:24 <ryantrinkle> jle`: hmm
01:46:32 <jle`> i guess depending on what situation you have, would `f a ~ f b` suffice?
01:46:45 <ryantrinkle> yeah, i could probably produce that
01:46:46 <jle`> the second type family solution is obviously one to avoid
01:46:54 <ryantrinkle> its' basically like
01:47:13 <ryantrinkle> f (g a) (g b) ~ g (f a b)
01:47:24 <gfixler> Axman6: yeah, even with cabal at 1.22, new sandbox, cabal-version set to >=1.18, I still get the errors :(
01:47:30 <gfixler> vty-ui is the package that wouldn't install
01:47:31 <jle`> i think GHC has problems proving injectiveness, but thigs like this might be handlable
01:47:37 <ryantrinkle> i know that it distributes like that, but i'm not sure how to convince GHC :P
01:47:42 <jle`> ah
01:48:11 <ryantrinkle> oh, i should just be able to open a refl in scope, eh?
01:48:32 <jle`> try it :3
01:48:37 <ryantrinkle> if i produce one with just the right types, maybe ghc will use it :P
01:49:23 <ryantrinkle> jle`: in that situation, would i say that f distributes over g, or that g distributes over f?
01:49:28 <ryantrinkle> i always forget that terminology
01:49:47 <jle`> hm that's like saying g (a `f` b) = g a `f` g b
01:49:56 <ryantrinkle> yeah
01:49:58 <jle`> i think g distributes over f
01:50:06 <jle`> cause you say multiplication distributes over addition
01:50:08 <jle`> ....right?
01:50:13 <ryantrinkle> ummm
01:50:22 <ryantrinkle> yes!
01:50:23 <mniip> distributive property of multiplication
01:50:24 <mniip> so yeah
01:50:26 <ryantrinkle> according to wikipedia
01:50:28 <ryantrinkle> cool; thanks :)
01:50:31 <jle`> yay words
01:53:17 <ryantrinkle> ok, now it wants me to use AllowAmbiguousTypes
01:53:27 <ryantrinkle> is there a consensus on whether that's evil or not?
01:53:54 <jle`> i feel like every time i've used AllowAmbiguousTypes, it only defers errors
01:54:01 <ryantrinkle> ah
01:54:23 <jle`> but your experience might be different...there might be legitimate reasons to use it...
01:55:20 <jle`> according to the docs are are some specific use cases
01:59:53 <tmtwd> it feels like haskell has a fully functional repl as compared to clojure
02:00:01 <tmtwd> is there anything it is missing?
02:00:09 <gfixler> the repl is pretty complete
02:00:25 <gfixler> : runs the last command
02:00:41 <gfixler> :set +s turns on timing/stats
02:00:54 <gfixler> :sprint lets you print out uneval'd things
02:01:15 <jle`> i still think there's some friction in the (p) part of repl
02:01:41 <gfixler> really?
02:01:48 <jle`> a lot of things that would be nice to see at least some partial output of to inspect/debug simply aren't available in the repl
02:02:01 <jle`> because they don't have legal Show instances.  but sometimes that constraint is a bit too strong to be useful
02:02:46 <gfixler> -XShowEverything
02:03:14 <jle`> heh.  yeah, just things that make sense not to have a `show` method, but would be very useful for repl play
02:03:19 <marchelzo_> Is there something like race from async, but doesn't kill the not-chosed thread?
02:03:25 <marchelzo_> Just ignores its result.
02:03:35 <marchelzo_> s/chosed/chosen/
02:04:01 <gfixler> silly question: what is cabal install --dependencies-only drawing from?
02:17:08 <lf94> ...are Monads just categories?
02:27:10 <reynir> No
02:47:06 <dzack> gfixler: ┬──┬◡ﾉ(° -°ﾉ)
03:01:16 <lpaste> Geraldus pasted “Persistent Key to Text” at http://lpaste.net/132720
03:02:24 <Geraldus> Hey friends! I'm migrating from old Yesod scaffold to new one, also I'm switching from MySQL to PostgreSQL. However, I'm facing this issue http://lpaste.net/132720, which looks odd for me. 
03:03:47 <Geraldus> The error message is new for me, I didn't see such messages earlier. Also, it seems there was no changes in functions
03:05:58 <Geraldus> entityIdToText = (\(Right x) -> x) . fromPersistValue . head . keyToValues
03:05:58 <Geraldus> Foundation.hs:302:64-74: Couldn't match type ‘MinLen (Succ nat0) mono0’ with ‘[PersistValue]’
03:06:17 <boyboy2> hi, i want to define instances: MonadTransControl MyContext, MonadBaseControl MyContext.(http://lpaste.net/132721) but it seems to be too difficult for me. would you help me to define these instances.
03:17:00 <Axman6> boyboy2: http://lpaste.net/132721 see my annotation, that seems to be the secret source for making MonadBaseControl work with newtype wrapped monad transformers
03:27:46 <tmtwd> last' = foldl1 (\_ x -> x)  
03:27:58 <tmtwd> is there a way to do this last function with a right fold?
03:29:26 <maerwald> tmtwd: the same way?
03:29:36 <usr> funny stuff maerwald 
03:29:42 <tmtwd> maerwald, yes?
03:29:53 <maerwald> > foldr1 (\_ x -> x) [ 4, 3, 5]
03:29:55 <lambdabot>  5
03:30:26 <tmtwd> > foldr1 (\ _ x -> x ) [ 32, 43, 1 ]
03:30:28 <lambdabot>  1
03:30:31 <tmtwd> huhu
03:30:35 <maerwald> :o
03:31:13 <maerwald> the just throw away the _ values from a different end
03:32:10 <tmtwd> I still haven't gotten the hang of folds
03:33:25 <usr> is haskell more like a high level language like python or more like a low level language like C
03:33:28 <usr> or something in between like java
03:33:34 <Haskellfant> definitely high level
03:33:45 <usr> ah kk
03:34:24 <Haskellfant> well if you compare java and python it sorta depends on what you think makes python a "higher" level language
03:34:31 <maerwald> tmtwd: folds are just implicit recursions... if you don't know exactly which one to use, write your function with explicit recursion first and then look at it afterwards if you can reduce it via a fold
03:34:53 <usr> Haskellfant: does haskell go directly into assembly?
03:35:10 <Axman6> nothing goes directly into assembly
03:35:18 <usr> C Axman6 
03:35:25 <Axman6> I disagree
03:35:30 <usr> ok
03:35:34 <Axman6> Haskell is a compiled language though
03:35:40 <Axman6> it can also be interpreted
03:35:55 <Axman6> (with JIT compilation IIRC)
03:36:06 <usr> is Haskell compiled to native machine code?
03:36:07 <Axman6> your uestion is mixing up several different ideas
03:36:10 <Axman6> yes
03:36:18 <usr> ok that's what i was asking
03:36:49 <Axman6> but it is also definitely a high level language
03:36:57 <maerwald> tmtwd: foldr f z [a,b,c] == a ‘f‘ (b ‘f‘ (c ‘f‘ z))
03:36:57 <usr> why Axman6 ?
03:37:06 <maerwald> foldl f z [a,b,c] == ((z ‘f‘ a) ‘f‘ b) ‘f‘ c
03:37:13 <tmtwd> huh
03:37:21 <maerwald> I think this was in the docs of prelude
03:37:24 <maerwald> but not anymore it seems
03:37:46 <tmtwd> z being the accumulator?
03:37:54 <Haskellfant> z being the initial value
03:38:03 <tmtwd> f is the functions?
03:38:05 <mauke> > foldl f z [a,b,c]
03:38:06 <lambdabot>  f (f (f z a) b) c
03:38:18 <mauke> > foldr f z [a,b,c]
03:38:19 <lambdabot>  f a (f b (f c z))
03:38:20 <maerwald> well yeah, that's without infix
03:38:31 <Axman6> > scanl f z [1,2,3] :: [Expr]
03:38:32 <lambdabot>  [z,f z 1,f (f z 1) 2,f (f (f z 1) 2) 3]
03:38:32 <tmtwd> huh
03:38:39 <usr> hm Axman6 ?
03:38:44 <Axman6> (shows the stages that foldl goes through)
03:39:09 <Axman6> usr: because it is not a low level language, you do not need to care about the hardware at all.
03:39:25 <usr> Axman6: does it have a garbage collector?
03:39:28 <Axman6> yes
03:39:44 <usr> oh i see
03:39:45 <usr> so it's a mix
03:39:50 <Axman6> no?
03:39:58 <usr> yes
03:40:01 <mauke> it's a mix of high level and high level
03:40:02 <Axman6> it's a compiled, high level language
03:40:03 <tmtwd> what is the scanl function?
03:40:19 <usr> what makes a language high level then Axman6 ?
03:40:21 <Axman6> scanl outputs all the steps that foldl has
03:40:35 <tmtwd> to make it seems like a VERY high level, functional language
03:40:42 <tmtwd> *me
03:40:58 <maerwald> tmtwd: for foldr you can think of z as the value that gets returned when the input list is empty, so it's the recursion stopper
03:41:26 <tmtwd> yes like the base case/initial value
03:41:26 <mauke> @where folds
03:41:26 <lambdabot> http://en.wikipedia.org/wiki/File:Fold-diagrams.svg
03:41:49 <Axman6> usr: a language which provides powerful (and composable) abstractions is, in my opinion a high level language. Haskell offers this, C does not
03:43:05 <tmtwd> well, haskell is similar to ocaml and ml, I find
03:43:21 <tmtwd> and haskell seems higher level than those languages
03:43:28 <jophish> I have something along the lines of: do f <- foo; case f of Nothing -> pure Nothing; Just a -> Just <$> bar a;
03:43:29 <tmtwd> ergo, haskell is very high level
03:43:35 <jophish> I can't help feeling that this is really clumsy
03:43:49 <jophish> Is there a nice solution to this, I suppose I could opt for MaybeT IO
03:43:58 <jophish> but a little one lines would be great
03:44:13 <jophish> The type of that is: IO Maybe a
03:44:25 <Axman6> :t traverse
03:44:26 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
03:44:56 <Axman6> :t traverse `asAppliedTo` (undefined :: a -> IO b)
03:44:57 <lambdabot> Traversable t => (a -> IO b) -> t a -> IO (t b)
03:45:26 <Axman6> I _think_ you want traverse jabesed 
03:46:07 <maerwald> tmtwd: did you write your own tree and implement a fold over it yet?
03:46:31 <tmtwd> I copied someones code out and did that
03:46:39 <tmtwd> but I did it in a rush 
03:46:48 <tmtwd> I will try it again
03:47:34 <tmtwd> data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)  
03:47:35 <tmtwd> like that?
03:48:24 <maerwald> for example, yes
03:49:41 <tmtwd> how else would you define it?
03:50:03 <mauke> data Tree a = Leaf a | Node (Tree a) (Tree a)
03:50:15 <mauke> data Tree a = Tree a [Tree a]
03:50:18 <jophish> oh of couse! tanks Axman6
03:50:20 <jophish> thanks*]
03:50:27 <RaceCondition> constraints on data are discouraged, but are constraints on type classes also?
03:50:30 <mauke> data Tree a b = Leaf a | Node b (Tree a b) (Tree a b)
03:50:34 <Axman6> data Tree b a = Leaf a | Node b (Tree b a) (Tree b a)
03:51:21 <reynir> 50 shades of trees
03:51:30 <mauke> data Tree a = Leaf | Node a (Tree (Tree a)) (Tree (Tree a))  -- I haven't thought this through at all
03:51:51 <tmtwd> um
03:51:54 <tmtwd> but don
03:52:02 <tmtwd> t they need an empty option?
03:52:02 <arbelos> In the Haddock docs it says that I can create headings using the syntax = heading, but it doesn't seem to work. Does anyone know?
03:52:04 <Axman6> that's sort of similar to how finger trees are defined
03:52:24 <tmtwd> and don't all those trees do the same thing?
03:52:28 <arbelos> "Headings inside of comment documentation are possible be preceding them with a number of =s."
03:52:36 <Axman6> jophish: no worries. does it work? if so, I'm glad I managed to see the pattern =)
03:52:37 <arbelos> but it comes out as a plain = when I try.
03:53:12 <jophish> Axman6: yeah, it was exacltly what I wanted. My face is so red that I didn't spot this myself. 
03:53:27 * hackagebot digestive-functors-snap 0.6.1.3 - Snap backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-snap-0.6.1.3 (JasperVanDerJeugt)
03:54:03 <maerwald> tmtwd: and then you need something like: foldTree :: (b -> a -> b -> b) -> b -> Tree a -> b
03:54:20 <tmtwd> right
03:54:25 <maerwald> you can also do it with "a" only for starters
03:54:31 <tmtwd> I think I have one of those kicking around
03:54:52 <tmtwd> "a" only for starters?
03:55:00 <maerwald> for (b -> a -> b -> b) the first b would be e.g. the left node, the a would be the value and the next b the right node
03:55:18 <maerwald> I mean (a -> a -> a -> a) would work too ofc
03:55:24 <maerwald> but is a little bit less cool
03:56:27 <maerwald> so if I get mixed up with the types, I do it for one type only first
03:57:25 <mauke> I do the opposite. that way the type checker can guide me
03:57:29 <maerwald> heh
03:57:46 <maerwald> if the error messages makes sense, that is
04:40:44 <jophish> I've written a little program which reads joystick input and writes it out to a serial port in a specific format. This is obviously something quite specific, Is it worth uploading to hackage?
04:41:11 <jophish> It's probably most useful as an example of reading joystick input using sdl2 and writing to a serial port using serialport
04:41:31 <hodapp> if it might be useful to someone else, at least make it a public blog post or something, perhaps
04:42:05 <tmtwd> jophish, you have a physical joystick?
04:42:23 <jophish> tmtwd:  I'm using two at the moment actually :D
04:42:34 <jophish> and simulating a third using a little arm chip 
04:43:08 <passy> Hey! Could someone give me a pointer what I need to look into if I want to make something like `formatEntryDatetime e = intercalate "-" $ (\x -> show $ x e.date) <$> [Date.year, Date.month, Date.dayOfMonth]` work? That list would be something like `(Functor f, Show s) => f (Date -> s)`. Do I need RankNTypes for that?
04:43:13 <tmtwd> for games and stuff?
04:43:16 <jophish> hodapp: that's a good idea. I should set up a blog first, I'm worried that I won't post enough though. I guess that's better than not posting at all
04:43:29 <jophish> tmtwd: yeah, kerbal space program
04:43:37 <jophish> One joystick for rotational movements, another for translation
04:44:26 <jophish> Both of these are piped to an arm chip with a host of switches and dials attached, it merges the inputs and pretends to be another joystick controlling the game
04:44:48 <tmtwd> jophish, I'd like to see some photos
04:44:58 <jophish> tmtwd: I'll upload one now :)
04:45:32 <hodapp> jophish: well, you can learn Hakyll while you're at it :P
04:47:38 <jophish> tmtwd: http://imgur.com/Z2a5YrG
04:47:58 <orion> 01:57:32 < jle`> you probably should do things in IO
04:48:03 <orion> 01:58:50 < jle`> haskell's IO exception system (which you are using if you use things like `handle`) really only makes sense if you're in IO
04:48:16 <jophish> a friend and I built it over a weekend. We're going to finish and fly with it next weekend
04:48:34 <jophish> Sadly we can't program the flight computer in Haskell
04:48:45 <tmtwd> uh, so you wrote all the drivers yourself?
04:48:59 <jophish> It's really nice programming it though, it's only *several* times more powerful than the apollo guidance computer
04:49:12 <tmtwd> jophish, how do you program the flight computer?
04:49:26 <orion> jle`: The only problem with being in IO is that in the real program, rpcTextResp makes a call to performCall, which evaluates to MyApp ByteString, not IO ByteString.
04:50:22 <jophish> tmtwd: we're using a Teensy board, the other chips in the picture are little i2c multiplexers for driving the 7 segment displays and the switches. We're writing the "drivers" for those ourselves, there's already a library written for emulating a HID joystick which we're using
04:50:32 <jophish> tmtwd: It's being written in C
04:50:36 <tmtwd> cool
04:50:48 <jophish> I like C a lot in many ways, it's so tiny!
04:51:21 <jophish> that reminds me, isn't there some C dsl in haskell?
04:52:54 <f|`-`|f> I'm curious what an edsl of another language would do
04:53:03 <hodapp> jophish: There is Ivory, but I'm not sure that's what you mean.
04:53:07 <f|`-`|f> construct the code in another language
04:53:17 <hodapp> f|`-`|f: Yes.
04:53:22 <jophish> https://mail.haskell.org/pipermail/haskell-cafe/2010-September/083922.html there are a few listed here
04:53:23 <hodapp> f|`-`|f: It's more useful than you might think at first glance.
04:53:23 <f|`-`|f> o
04:53:44 <f|`-`|f> the best I can think of is "Java, but with none of the java", hodapp 
04:54:00 <hodapp> f|`-`|f: Think more like, 'C, but with an actual metaprogramming system'
04:54:05 <safinaskar> f|`-`|f: this was haskell definition?
04:54:16 <f|`-`|f> ah
04:54:23 <f|`-`|f> there are probably more ins and outs to it
04:54:36 <f|`-`|f> but I suppose that's an implementation detail
04:54:40 <hodapp> ins and outs?
04:54:57 <safinaskar> f|`-`|f: good nickname. it looks like this: infix |`-`| 7; a = f |`-`| f
04:55:29 <f|`-`|f> I did it mostly because it looks cute when I do an action
04:55:33 * f|`-`|f lunges
04:55:38 <hodapp> jophish: The C language surely is tiny, but that tininess quickly goes away as soon as you try to achieve some real abstraction in it.
04:56:19 <jophish> hodapp: you're quite right. I can't comprehend how people write large applications using it
04:56:26 <nwm> I have a type like: data AorB = A | B
04:56:38 <hodapp> jophish: they implement entire object systems.
04:56:42 <nwm> What I am wondering is: is there a good way to describe a type that is either A or B or both?
04:56:46 <jophish> it's just crazy
04:56:57 <roniz> hello
04:57:19 <hodapp> jophish: but I'm using Ivory at my day job right now; it's not precisely a C DSL, but an EDSL you can generate C code with and get a good level of control over it with
04:57:40 <jophish> hodapp: I'll take a look! Thanks!
04:58:09 <jophish> google autocomplete: "Haskell Ivo[ry tower]"
04:58:28 <hodapp> Ivory and Tower are actually both associated Haskell libraries from Galois
04:59:08 <hodapp> there are also some ones like Atom, Copilot, and SBV that generate much more constrained forms
04:59:33 <f|`-`|f> o:
04:59:48 <roniz> I dont know haskell
04:59:51 <roniz> but I would like too
04:59:54 <roniz> :)
04:59:57 <jophish> hodapp: I wonder how much of the autopilot we could write in one of those
05:00:16 <jophish> @where lyah
05:00:17 <lambdabot> http://www.learnyouahaskell.com/
05:00:20 <jophish> roniz: ^
05:00:21 <f|`-`|f> #haskell-beginners look at the title, it has a link to a neat guide, the channel is for your learning convenience
05:00:32 <f|`-`|f> pls no, jophish 
05:00:43 <roniz> thanks
05:00:50 <f|`-`|f> it has no problem sets, jophish 
05:01:30 <safinaskar> i have a problem. there is some (speaking in terms of procedure languages) variables in my program. let's say a, b and c. i have a function f and i want this function to be able to read a and b and to modify c. also i have a function g and i want it to be able to modify all this variables. and i want g to be able to call f. how to do this some beautiful way? i can make declare g as State monad and f as
05:01:36 <safinaskar>  RWS monad. but then, when i want to call f from g i should manually convert that RWS to state using manual runRWS calls. how to do better?
05:01:56 <safinaskar> and such problem appear through all my program
05:02:31 <safinaskar> so, i have lots of "variables" and lots of functions and i want to give to this functions abilities to read one variables and to modify others
05:02:41 <jvee126> hello. i'm using Persistent in my project. and i wanna compose SqlPersistT with ReaderT, or use SqlPersistT (ReaderT String (NoLoggingT (ResourceT IO))). but runSqlPool needs MonadBaseControl (SqlPersistT (ReaderT String (NoLoggingT (ResourceT IO)))). it seems too complex to implement. how can i use Reader pattern in Persistent?
05:03:15 <jophish> f|`-`|f: It's a great introduction to the language. Are problem sets required to learn syntax and basic functions?
05:03:16 <supki> nwm: yes, data T a b = A a | B b | Both a b
05:03:33 <f|`-`|f> I see what you mean
05:07:06 <roniz> is Haskell compiled into binaries or interpreted?
05:07:59 <nwm> Okay, I think I can do something like data OneOrBoth a = One a | Both
05:08:33 <nwm> supki: I'm not sure I understand. I don't want to pass types into a and b, but constructors
05:08:57 <wei2912> nwm: One a | Both ab ?
05:09:02 <wei2912> err
05:09:05 <wei2912> nwm: One a | Both a b ?
05:09:10 <magneticDuck> nwm: Either a (a, b)
05:09:25 <f|`-`|f> cunning
05:09:28 <magneticDuck> or, if what you said wasn't a typo, simply 'Maybe a'
05:09:32 <wei2912> heh
05:09:33 <aawe> roniz: either. ghc compiles to machine code
05:09:37 <magneticDuck> er
05:09:42 <safinaskar> jophish: i understand how people write big apps using C. look at linux kernel, for example. there is some abstractions in it which are done using preprocessor
05:09:45 <magneticDuck> nwm: actually, (a, Maybe b)
05:09:46 <nwm> hmm, I could just use Maybe a and treat Nothing as both
05:09:56 <magneticDuck> is the best way to do it
05:10:00 <wei2912> how'd that work?
05:10:00 <nwm> but I don't know abotu that...
05:10:16 <magneticDuck> wei2912: what do you mean?
05:10:19 <f|`-`|f> ... how can Nothing be a product of two types?
05:10:25 <jophish> safinaskar: yeah, of course. How they stay sane like that is another matter :)
05:10:27 <f|`-`|f> It is a zero type
05:11:18 <nwm> it's not a product of two types, but a product of two constructors
05:11:23 <nwm> I doubt my terminology is correct there
05:11:28 <wei2912> magneticDuck: nvm, ignore me
05:11:30 <nwm> Anyway I don't think it's a very clear slotion.
05:11:33 <nwm> *solution
05:11:40 <nwm> I like (a, Maybe b)
05:12:07 <magneticDuck> yeah that's probably best
05:13:29 * hackagebot sequence 0.9.7 - A type class for sequences and various sequence data structures.  http://hackage.haskell.org/package/sequence-0.9.7 (AtzeVanDerPloeg)
05:13:47 <nwm> Then again I still don't think that's very nice. For example, something of the type (a, Maybe a) can have the same value for both a's
05:13:54 <nwm> and does that really represent both in that case?
05:14:10 <magneticDuck> what exactly are you trying to represent?
05:14:40 <nwm> Well to give a more concrete example
05:15:12 <f|`-`|f> Gunna shank someone if the quick fix is (Maybe a, Maybe b)
05:15:25 <nwm> hehe no I think I'll stay away from that one
05:15:33 <f|`-`|f> I would too
05:15:50 <nwm> I think that One a | Both will do what I want
05:15:53 <f|`-`|f> Since the left element will always exist from what little you said
05:16:00 <nwm> because then you can only have one constructor.
05:16:03 <safinaskar> how to convert "RWS a () b ret" to "RWS () () (a, b) ret"? and how to solve such tasks in general?
05:16:24 <safinaskar> (or to "State (a, b) ret")
05:16:28 * f|`-`|f shrugs
05:16:41 <f|`-`|f> alright then
05:17:10 <nwm> thanks for the help y'all.
05:17:14 <Saizan> safinaskar: use the runRWS and state functions
05:24:34 <jophish> hodapp: I'm going to try writing part of the autopilot in ivory. I'll call it "Dumbo"
05:25:44 <safinaskar> Saizan: yes, but how to do this beautifully?
05:39:07 <jophish> safinaskar: It's often really tricky to get stateful code beautiful in Haskell. Is there any way you could write your function without relying on mutable state?
05:40:24 <hpc> (haskell's dirty secret is that ST and IO make stateful code pretty damn nice if you use their ref types properly)
05:42:40 <saulzar_> I'm not sure I'd ever really describe STRef/IORef based code as "pretty damn nice"..
05:42:44 <safinaskar> jophish: well, yes, i can write functions with types like a -> (b, a), but this is not beautiful, too
05:43:16 <safinaskar> hpc: what is ref types here?
05:44:22 <hpc> STRef, IORef
05:45:28 <hpc> saulzar_: my philosophy of good code is if it looks like what it does
05:45:35 <hpc> saulzar_: and sometimes you just need to do something stateful
05:45:41 <nadirs> hpc: any examples in the form of code/articles/etc.?
05:46:12 <hpc> nadirs: it's pretty straightforward, just read the haddock and mess around with them a bit
05:46:37 <nadirs> hpc: I mean, use of them that you consider nice examples
05:46:43 <nadirs> *uses of them
05:47:58 <hpc> hmm, i thought i had an example ready to go, but that one's using MVars...
05:50:18 <saulzar_> hpc, I agree, but still - IORef code is what it is, but it looks like a noisy version of C to me
05:51:18 <nadirs> hpc: I have this article by jaspervdj, http://jaspervdj.be/posts/2012-04-12-st-io-dcpu-16.html
05:51:49 <nadirs> but wait, it's not using refs at all, sorry
05:53:09 <hpc> yeah, dunno why he's using ST at all at that point
05:53:44 <maerwald> explicit states are not particularly beautiful in haskell, even with ST and friends
05:56:51 <Flonk> I seem to use `group . sort` quite often, so group groups every equal item in the list, not only if they occur next to each other.
05:57:12 <Flonk> sort requires Ord though, is there maybe something in the standard lib that does exactly this but only needs Eq?
05:58:57 <jophish> hodapp: is there an ivory irc channel or something? I've some questions
05:59:12 <indiagreen> Flonk: I've never seen it, and it would be pretty inefficient
05:59:27 <indiagreen> Flonk: it's not hard to write by yourself, of course
06:00:11 <Flonk> indiagreen: Yeah, I'll probably end up doing that then!
06:00:17 <Flonk> Thanks :)
06:00:21 <Taneb> Flonk, nub?
06:00:31 <Taneb> :t group
06:00:34 <lambdabot> Eq a => [a] -> [[a]]
06:00:35 <Flonk> Taneb: nub removes duplicates though
06:00:39 <Taneb> Oh, I'm wrong, yeah
06:00:41 <Taneb> Sorry :/
06:01:59 <indiagreen> Flonk: http://lpaste.net/132727
06:02:26 <f|`-`|f> Flonk  
06:02:37 <f|`-`|f> are you doing that to remove repeating elements?
06:02:43 <Flonk> indiagreen: that's pretty smart
06:03:11 <Flonk> f|`-`|f: No, there's nub for that :)
06:03:24 <f|`-`|f> there's a faster one under Witherable, Flonk 
06:03:53 <quchen> nub is terrible, roll your own -- https://github.com/quchen/articles/blob/master/fbut.md#nub
06:04:43 <f|`-`|f> it professes to being exponentially faster, but
06:04:45 <Axman6> I thought ghc 7.10 was supposed to get a new version of nub needing Ord
06:04:47 <f|`-`|f> not sure how
06:06:35 <indiagreen> Axman6: I can't find it anywhere in base
06:08:06 <f|`-`|f> https://hackage.haskell.org/package/witherable-0.1.3/docs/src/Data-Witherable.html#ordNubOf
06:11:15 <f|`-`|f> Witherable being a young new typeclass taking the place as a generalised filter
06:11:16 <maerwald> quchen: a-op-is-not-x---a-op-x <- didn't know that one :/
06:11:20 <maerwald> that's unfortunate
06:11:43 <quchen> … in GHC at least
06:12:02 <maerwald> I'd call it a bug...
06:13:32 * hackagebot sequence 0.9.8 - A type class for sequences and various sequence data structures.  http://hackage.haskell.org/package/sequence-0.9.8 (AtzeVanDerPloeg)
06:16:49 <Gurkenglas> Does some library implement memoized functions, say Int -> Float, that require less than (log |Float|)^|Int| space in cases with low kolgomorov complexity by prioritizing those cases?
06:18:04 <Gurkenglas> (Or a subset of those cases that is not general enough to be smitten down by Halting-Problem-type stuff)
06:18:32 * hackagebot zlib 0.6.1.1 - Compression and decompression in the gzip and zlib formats  http://hackage.haskell.org/package/zlib-0.6.1.1 (DuncanCoutts)
06:18:34 * hackagebot zlib 0.6.0.2 - Compression and decompression in the gzip and zlib formats  http://hackage.haskell.org/package/zlib-0.6.0.2 (DuncanCoutts)
06:20:58 <Gurkenglas> Where "memoized" means that doing operations on them does most work only once, not for each calling of the result. For example, one might take the convolution of two such function or the antiderivative of one (and the library would ideally make sure that in some such cases, formulaic shortcuts are used to get the result).
06:25:56 <Gurkenglas> (A simple version of such a library might have its set of functions be line segment chains, and as combining operations allow addition and pointwise maximization)
06:36:38 <ion> “<maerwald> quchen: a-op-is-not-x---a-op-x <- didn't know that one :/” What does this even mean?
06:37:12 <maerwald> ion: https://github.com/quchen/articles/blob/master/fbut.md#a-op-is-not-x---a-op-x
06:37:29 <ion> Ah
06:37:31 <maerwald> strictness is different
06:38:04 <maerwald> I also find this part interesting https://github.com/quchen/articles/blob/master/fbut.md#f-x---is-not-f--x--- ...which makes me wonder how you would explain currying to a beginner without confusing him
06:38:31 <maerwald> from the haskell report it seems type inference is different
06:38:33 * hackagebot eventstore 0.7.2.1 - EventStore TCP Client  http://hackage.haskell.org/package/eventstore-0.7.2.1 (YorickLaupa)
06:38:39 <maerwald> for both versions
06:39:13 <narfinger> hiho, i have multiple times the same form of code in my program and i wonder if there is a shorter/better way to write it. here is the lpaste filterSupportedExtensions :: [FilePath] -> [FilePath]
06:39:18 <narfinger> filterSupportedExtensions = filter (\f -> elem (takeExtension f) extensions)oh sorry
06:39:26 <narfinger> http://lpaste.net/132729
06:39:28 <maerwald> quchen: the link should be in the topic :P
06:39:30 <narfinger> there is the lpaste
06:39:39 <narfinger> and i want a shorter way for the second function
06:42:27 <ion> filterSupportedExtensions <$> getDirectoryContents (dir series)
06:42:36 <narfinger> i tried to use liftM but that gives me a lot of problems
06:43:17 <narfinger> ok i will try that
06:43:32 <narfinger> can you explain why liftM and/or fmap is the wrong one?
06:44:50 <narfinger> oh ok it is fmap
06:45:03 <narfinger> so why not lifM? i thought io was a monad
06:46:04 <ion> (<$>) = fmap. It is equivalent to liftM.
06:46:36 <narfinger> oh ok
06:47:22 <ion> fmap can be implemented for more types than liftM.
06:47:35 <Cale> narfinger: fmap, (<$>) and liftM should pretty much always all be the same thing. However, liftM is defined in terms of the Monad operations, return and (>>=), so it can be used as an implementation of fmap if you've already defined those.
06:47:42 <Cale> :t liftM
06:47:43 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
06:47:45 <Cale> :t fmap
06:47:46 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:47:58 <Cale> :t (<$>)
06:47:58 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:48:05 <narfinger> mhhh ok thanks
07:08:13 <isomorphic> Do I need to do anything special after a peekArray to trigger garbage collection of a Ptr a? 
07:13:06 <Axman6> people who use unicode symbols in libraries on hackage should be shot. I can read "Lens' α β -> φ β -> φ (α -> α)" but it takes a lot longer than it needs to
07:14:34 <maerwald> Axman6: you take over all those libraries after you shot them? ;)
07:14:40 <jophish> Is haskell-src-exts wrong, or am I just crazy? it barfs on Bar 1000, but parses Bar1000 correctly https://gist.github.com/expipiplus1/3c2694b68b599ddbf27c
07:14:49 <jophish> both compile fine with ghc
07:16:22 <Axman6> maerwald: not the one I'm looking it, at looks far more complicated than it needs to be
07:16:30 <hexagoxel> jophish: did you actually enable the extension when parsing? i remember that the pragmas are not respected (by default at least), or smth
07:16:42 <jophish> hexagoxel: yeah, I've tried it with that enabled
07:16:46 <jophish> I'll file a bug
07:16:56 <jophish> I can't imagine why this happens though
07:17:34 <quchen> maerwald: Well, those are corner cases that you don't really have to be concerned about much as a beginner.
07:17:54 <wei2912> 22:12 < wei2912> i'm working on http://cryptopals.com/sets/1/challenges/3/ in haskell, and i wrote a function to encrypt a message  with a key, by repeating the key over and over again
07:17:55 <quchen> maerwald: When you're teaching someone about C you're also not mentioning cache locality.
07:18:00 <wei2912> 22:12 < wei2912> but my solution seems like a hack
07:18:03 <wei2912> and... wait a moment.
07:18:11 <wei2912> http://lpaste.net/132731
07:18:14 <wei2912> does anyone have ideas? :)
07:18:20 <quchen> maerwald: For all practical purposes, η reduction is a valid transformation, if you're a beginner.
07:19:16 <jophish> Axman6: I use unicode all time time. It's a shame combining characters are broken :)
07:20:02 <quchen> maerwald: And it's also a question of which semantics you're talking about. Inlining is orthogonal to denotation, for example, so this is an optimization technique related to η reduction.
07:20:22 <jophish> This is for some orbital mechanics code. It's much nicer to read 'μ' than 'mu' or 'gravitationalParameter' 
07:20:23 <quchen> Same thing goes for sharing via `where` blocks.
07:21:14 <safinaskar> hi. i am at https://downloads.haskell.org/~ghc/latest/docs/html/libraries/Control-Monad-Trans-RWS.html
07:21:15 <maerwald> makes sense
07:21:19 <JSharpe> Hello, I'm learning haskell and up to lists here http://learnyouahaskell.com/starting-out#an-intro-to-lists  I'm experimenting on the way and can some one tell my why this prints [[0,0,0,0], .. forever?    let b = [[1,1],[2,2]]    let b = [0,0] : b ++ [[3,3]] 
07:21:20 <safinaskar> i press "source" and see 404
07:21:29 <safinaskar> what to do? why i see this?
07:21:50 <quchen> safinaskar: Try looking at the source of an older package version, maybe the author forgot fixing them
07:21:50 <JSharpe> I expected [[0,0],[1,1],[2,2],[3,3]]
07:21:52 <jophish> JSharpe: the b in 'b ++' is the same one the result is being bound to
07:22:23 <jophish> it's like saying 'x = x + 1'.
07:23:01 <quchen> > let x = 1:x in x -- JSharpe, "=" does not mean assignment in Haskell, it *defines* a value. You cannot re-assign/update an already defined value.
07:23:02 <jophish> This evaluates to x = ((.(.. + 1) + 1) + 1)
07:23:03 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
07:23:34 <safinaskar> gabiruh: same for Data.Char
07:23:44 <safinaskar> gabiruh: so, this is not a problem local to a package
07:23:45 <maerwald> JSharpe: did you mean: let a = [[1,1],[2,2]]    let b = [0,0] : a ++ [[3,3]] ?
07:24:35 <maerwald> because that would do what you were expecting
07:26:24 <JSharpe> I'm still wrapping my head around with how Haskell, and functional programming works. I was expecting the = to reassign the value. I was just experimenting as I noticed doing the exampls on the website updated gave the output of adding values to a list, but never updating the origial data
07:27:39 <Axman6> = definition, not assignment in haskell. the value of variables never changes
07:27:56 <quchen> JSharpe: "=" is mathematical equality, whereas in most other languages, "=" is the instruction "assign the value of the right hand side to the variable on the left". When you write "x = 3; x = 4" in Haskell, that's equivalent to writing "3 = 4", and the compiler will complain.
07:29:08 <maerwald> unfortunately it's not prolog and it will not yield False ;)
07:29:12 <maerwald> so we still have ==
07:29:26 <JSharpe> ok, thanks everyone for helping me understand :) I'll carry on with the reading.
07:30:12 <monochrom> you should read my http://www.vex.net/~trebla/haskell/prerequisites.xhtml to manage your expectation
07:30:15 <Axman6> if you're used to other languages, it's a good idea to forget everything you know about them.
07:30:53 <quchen> monochrom: 404
07:31:02 <JSharpe> that's what I got the impression of when listening to programming throwdown podcast on Haskell
07:31:18 <monochrom> yeah, I added an s by mistake
07:31:23 <monochrom> http://www.vex.net/~trebla/haskell/prerequisite.xhtml
07:31:49 <maerwald> Axman6: I disagree... if you know prolog, then a lot of things you know about it help understand things
07:31:59 <JSharpe> thanks monochrom I'll give that a read before moving on
07:32:11 <Axman6> most people don't know prolog, so it's generally not terrible advice
07:32:12 <maerwald> the problem is rather if you come from a strict imperative background
07:34:05 <JSharpe> I'm coming from a background of C++/C#/Python, so yeah I'm from an imperative background
07:34:48 <JSharpe> I wanted to learn Haskell, then start reading SICP as that uses Haskell too 
07:35:01 <quchen> JSharpe: It will take some time until you see the connection. It comes naturally. Until then, try not to think too much in terms of what you already know.
07:35:06 <quchen> SICP uses Scheme, not Haskell.
07:36:14 <JSharpe> well I've really messed up then
07:36:23 <arbelos> I am writing a library. I have a data type with some data required for the various functions exposed by the module. We can call it a "context". The code looks something like the following paste: http://lpaste.net/132733
07:37:20 <arbelos> Is there a better approach here. I mean, maybe I am stuck in a OOP way of thinking, I am not sure
07:37:51 <monochrom> not all of OOP is bad
07:38:21 <arbelos> no of course,.. i didn't mean that
07:38:53 <arbelos> I am thinking this Context object is opaque and you call createContext to do some heavy initialization
07:39:02 <quchen> JSharpe: Scheme is a very simple language, and very well suited for a book like SICP. It's not nearly as good as a functional programming language as Haskell in my opinion though. SICP is an excellent book worth reading, but if your goal is learning FP then using Haskell is probably the better choice.
07:39:25 <monochrom> your code is similar to how System.IO uses Handle. therefore, your code cannot be worse than System.IO
07:40:07 <arbelos> ok, well. another option could be to wrap the whole thing in a reader-like thing but it feels unnecessary
07:40:58 <arbelos> another thing here is that a client application can provide its own interface by creating the context and then applying the first argument of encode, decode etc
07:41:43 <JSharpe> quchen, Haskell is still a language I wish to learn, as I want to broaden my knowledge and not be stuck to limited languages/programming paradigms
07:42:23 <JSharpe> I've always heard SICP is a great book, but never read it, and now I have some free time I want to use it productively
07:42:48 <arbelos> monochrom, so this is how I was thinking http://lpaste.net/132733
07:43:05 <arbelos> does that make sense?
07:43:14 <safinaskar> JSharpe: sicp is about lisp and not about haskell
07:43:17 <monochrom> yes, I think good Haskellers do this all the time
07:43:33 <safinaskar> JSharpe: you probably want to go to #lisp
07:43:43 <JSharpe> yeah I understand that now
07:43:55 <safinaskar> JSharpe: and yes, it is a good book, i have read it parially
07:44:28 <quchen> SICP is not about Lisp.
07:44:47 <quchen> It uses Scheme because it's a very good language to use for the example code snippets.
07:45:17 <quchen> It's easy to understand, and doesn't get in the way of teaching the main ideas portrayed in the book, namely … the structure and interpretation of computer programs.
07:45:50 <monochrom> scheme is semantically different from lisp despite syntactic similarity
07:46:40 <quchen> "Lisp" can mean so many things that I don't about that.
07:46:42 <monochrom> in this 21st century and year 2015 I still hear people saying "all languages just differ a bit by syntax". to be fair, they're second-year students.
07:47:24 <monochrom> the truth is, even between C and python there are huge semantic differences. for starters, C doesn't have GC semantics, python does.
07:48:17 <monochrom> the statement was true 50 years ago when your choices were Fortran and Cobol.
07:48:35 * hackagebot full-text-search 0.2.1.3 - In-memory full text search engine  http://hackage.haskell.org/package/full-text-search-0.2.1.3 (DuncanCoutts)
07:48:51 <quchen> When you're coming from a hobby tinkering background, then running the program might be the only semantics you're aware of. I thought similarly before Haskell threw me into a new world.
07:49:46 <quchen> Let's call it "running semantics", which is what the command line prints ;-)
07:51:05 <arbelos> which makes me think, how would it be with a programming paradigm where you distinguished between implementation and program specification. so you provide both machine implementation and a declarative description of the programming.. for the program to compile, these need to match
07:51:34 <monochrom> yes
07:52:31 <arbelos> so not only do types and terms have to match, but you need to specify what the program does and how it should be done for the compiler to be happy
07:52:48 <monochrom> that is my ideal
07:53:40 <monochrom> VDM, Z, and B do this.
07:54:01 <safinaskar> lots of pages give me 404, for example https://downloads.haskell.org/~ghc/latest/docs/html/libraries/src/Data-Bool.html
07:54:09 <safinaskar> where to report this?
07:54:13 <safinaskar> and how to see sources?
07:54:40 <quchen> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/Data-Bool.html
07:55:02 <quchen> Oh, the source links.
07:55:03 <quchen> Hmm.
07:55:55 <monochrom> if you have installed GHC, you likely have that page on your hard disk. it comes with GHC.
07:56:44 <monochrom> for example mine is file:///usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/ghc-prim-0.3.1.0/src/GHC-Types.html#Bool
07:57:16 <safinaskar> monochrom: thanks!
07:57:22 <safinaskar> but where to report that bug?
08:01:39 <hexagoxel> safinaskar: https://hackage.haskell.org/package/base-4.8.0.0/docs/src/Data-Bool.html
08:02:42 <hexagoxel> if you via hackage -> base -> Data.Bool -> Source
08:03:15 <hexagoxel> maybe ask in #haskell-infrastructure about reporting
08:04:07 <safinaskar> hexagoxel: thanks
08:11:51 <jvee126> :i test
08:13:45 <opqdonut> jvee126: did you mean @info?
08:13:53 <opqdonut> @info map
08:13:53 <lambdabot> map
08:14:04 <opqdonut> err
08:14:28 <opqdonut> @info Eq
08:14:29 <lambdabot> Eq
08:15:55 <opqdonut> nevermind
08:16:08 <quchen> There is no :i in Lambdabot.
08:16:25 <opqdonut> I could've sworn @info was ghci's :info
08:16:35 <opqdonut> but maybe that was some previous version
08:17:21 <nshepperd> I seem to recall that @info is redirected to @undo, for some reason
08:17:47 <nshepperd> @info do {a <- foo; bar a}
08:17:47 <lambdabot> foo >>= \ a -> bar a
08:17:58 <nshepperd> ah, yes
08:20:20 <jvee126> opqdonut: sorry, i've made a mistake.
08:23:37 <Rizy> @info
08:23:38 <lambdabot> Error: expected a Haskell expression or declaration
08:24:44 <Rizy> hi all..can i ask beginners question here?
08:25:59 <Axman6> absolutely
08:31:27 <suppi> i keep getting  'hGetContents: invalid argument (invalid byte sequence)' when running ghc-mod inside a cabal sandbox :(
08:31:54 <jvee126> i have a problem with my code. this code will parse some json into haskell data, and do some action according to result of parsing, but it doesn't works well. http://lpaste.net/132740
08:32:40 <jvee126> i want to use typeclass level abstruction because of extensibility. how can i fix this code?
08:34:51 <suppi> jvee126, this looks like only part of the code. also, what happens when you compile/run it?
08:35:07 <homovitruvius> jvee126: why dispose a?
08:35:33 <suppi> also, you probably have to tell parse what type you are trying to parse
08:42:47 <jvee126> suppi: real code and error is http://lpaste.net/132741. i want to define parse rule and dispose rule in each plugin file.
08:44:22 <ion> jvee126: You are not specifying the “a” anywhere.
08:45:14 <jvee126> ion: then, if input comes from the only one source and it can parse into some types, how can i handle it?
08:45:39 <suppi> parse sampleData is not of type Maybe a
08:45:45 <ion> jvee126: Try t :: Maybe SampleData
08:46:08 <Big_G> Anyone going to the Seattle Area Haskell Users Group?
08:48:37 * hackagebot pager 0.1.0.0 - Open up a pager, like 'less' or 'more'  http://hackage.haskell.org/package/pager-0.1.0.0 (pharpend)
08:49:54 <jvee126> ion, suppi: thanks for your advice. in case like http://lpaste.net/132745, i must parse one source into SampleData or SampleData2. how can i express it in haskell?
08:54:25 <Oded> Hi, I'm learning Haskell and I have a question. Is it possible to make a type(container) for types of some typeclass? For example list of objects of typeclass Eq or list of objects of typeclass Num.
08:55:32 <ion> jvee126: Try parsing it as SampleData and fall back to parsing as SampleData2. Left <$> parse json <|> Right <$> parse json :: Maybe (Either SampleData SampleData2) for instance.
08:56:03 <suppi> Oded, something like:     data (Ord k) => Map k v = ...  ?
08:56:11 <hodapp> Oded: Heterogeneous or not?
08:56:12 <homovitruvius> jvee126: I don't think you can that way, but the json library you're using mighe be able to deal with data JsonStruct = SampleData1 {...} | SamplaData2 {...}
08:56:58 <hodapp> Oded: if you actually need a heterogeneous list, and you cannot simply pre-process each value by the relevant typeclass function you want, this is possible, but usually not necessary
08:57:52 <ion> suppi: That extension is not useful and IIRC had been removed from GHC.
08:58:23 <suppi> ion, oh, has it? good to know
08:58:38 * hackagebot exceptional 0.1.4.2 - Essentially the Maybe type with error messages.  http://hackage.haskell.org/package/exceptional-0.1.4.2 (pharpend)
08:58:42 <hodapp> Oded: but, I'm not sure if you're looking for a 'container' here for holding multiple different types of items, or just a data type parametrized over only typeclass members
08:59:20 <jvee126> ion: it can't works in case we have only two datatypes, isn't it? at least, i could do like http://lpaste.net/132749 :-(
08:59:30 <ion> jvee126: homovitruvius’ idea is better, just make it a single sum type instead of separate SampleData and SampleData2.
09:01:46 <ion> Or you could keep SampleData and SampleData2 and create a sum type for holding one of them.
09:02:00 <ion> akin to Either
09:03:17 <muzzle> how can i acces files in the cabal-data dir in my code
09:03:24 <muzzle> there is no really good documentation for this feature
09:03:38 * hackagebot hspec-snap 0.3.2.7 - A library for testing with Hspec and the Snap Web Framework  http://hackage.haskell.org/package/hspec-snap-0.3.2.7 (DanielPatterson)
09:03:41 <jvee126> homovitruvius: thanks. though it can solve my problem, but it doesn't seem extensible(i want to separate each dispose action into some files.)
09:06:14 <jvee126> ion: i see. i'll use sum type. thank you :)
09:06:25 <homovitruvius> jvee126: you can still separate the individual disposes: a top-level one does a case j of jj@SampleData1 {...} -> dispose jj etc
09:09:32 <jvee126> homovitruvius: that's true. can i separate declaration of sum type?
09:10:02 <orion> Is anyone familiar with how to solve this problem?: https://mail.haskell.org/pipermail/web-devel/2015/002782.html
09:10:30 <jvee126> homovitruvius: it seems impossible. i can't separate implementions completely.
09:11:11 <homovitruvius> jvee126: the declaration has to be in one piece if I understand what you mean. You cannot incrementally extend a sum type
09:12:02 <Oded> suppi, yes something like that. the container can have different types in it, but all of them are instances of some typeclass
09:13:31 <Guest60286> giochi
09:13:32 <suppi> Oded, sounds like something like existential types (am i correct?), but what are you trying to achieve?
09:15:12 <P4Titan> Hello all, I want to compile a file with a specific version of a package. I made a sandbox and did cabal install <package>, but when I go to compile, it does not use the <package> that is in the sandbox.
09:15:42 <Guest60286> ciao
09:17:13 <safinaskar> what is difference between rank 2 and rank 3 polymorphism?
09:17:25 <Guest60286> list
09:17:28 <homovitruvius> why hlint suggests "end of " `Data.Monoid.mappend` show name instead of "end of " ++ show name? the first look terrible to me
09:18:04 <ion> Hah! I was totally expecting “!list” next.
09:18:15 <monochrom> rank 2 example: (forall r. r -> a) -> a
09:18:34 <monochrom> rank 3 example: ((forall r. r -> a) -> a) -> a
09:19:10 <monochrom> some wikipedia page about rank-n types has a formula
09:22:17 <P4Titan> When I have a sandbox, do I need to install all libraries used in a program or can I only isntall a select few and have the rest be looked up in the global libraries
09:23:57 <geekosaur> the global package db is always visible
09:24:14 <geekosaur> (and must be)
09:24:36 <Oded> suppy,I'm trying to achieve something like OOP polymorphism, so I can have a container of a lot of object that some I might now know and they all of the same typeclass so I can iterate them and use the typeclass's functions. Sort of interface in OOP PLs
09:25:23 <Rotaerk> Oded, an interface can be represented in haskell using a record of functions
09:25:30 <Rotaerk> and an object is just an instance of that record
09:25:41 <Rotaerk> you can then have a collection of multiple implementations of that interface
09:25:43 <jophish> Oded: take a look at this: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
09:26:01 <jophish> Rotaerk's solution is likely to be a bit nicer
09:26:59 <Oded> by "a record of functions" you mean instances of typeclass?
09:27:04 <monochrom> existential type is just moving the record to a different place
09:27:30 <monochrom> or rather, existential type with a type class is just moving the record to a different place
09:27:42 <monochrom> an object is a record. period.
09:27:44 <Rotaerk> Oded, no.  do you know what a record is?
09:27:58 <Oded> What a record is?
09:28:00 <monochrom> and a record is a tuple.
09:28:00 <P4Titan> geekosaur: I run cabal exec -- ghc -o parseTest parseTest.hs -Wall, that says that a Parsec lib cannot be found which is not true. Running w/o the cabal exec produces an error with the versions of packages.
09:28:05 <safinaskar> monochrom: why we need to distingush spesially between rank 2, rank 3 etc polymorphism? why not to say that we have just 2 versions of polymorphism: rank 1 and rank infinity?
09:28:06 <Rotaerk> Oded, http://en.wikibooks.org/wiki/Haskell/More_on_datatypes#Named_Fields_.28Record_Syntax.29
09:28:39 * hackagebot persistent-postgresql 2.1.5.3 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-2.1.5.3 (GregWeber)
09:29:09 <geekosaur> @paste code, full error, and `ghc-pkg list` output P4Titan 
09:29:09 <lambdabot> Haskell pastebin: http://lpaste.net/
09:29:16 <monochrom> safinaskar: sometimes it is useful to draw that line. sometimes not. sometimes you should not even single out rank-1. but IIRC rank-2 inference is computable but rank-3 and up not.
09:29:29 <Oded> oh, you mean records of some data type?
09:29:57 <geekosaur> the global db must be visible because base (Prelude and runtime) is there and can't be installed in a sandbox (it must match the compiler)
09:30:00 <Rotaerk> Oded, it's just a data type with named fields...
09:30:04 <Oded> yea
09:30:14 <Rotaerk> so just make each of the fields a function
09:30:19 <Rotaerk> and voila, you've got an interface
09:30:33 <safinaskar> monochrom: what rank is implemented in haskell?
09:30:54 <monochrom> an object is just a record. therefore, OOP becomes record-oriented programming, and doomed to miss out on sum types.
09:31:26 <Oded> How do I create container of elements , where every elemeny has some particular function?
09:31:33 <monochrom> Haskell 2010 is rank 1. GHC does arbitrary ranks by extension "RankNTypes"
09:31:37 <ion> safinaskar: 1 in Haskell, 2 with LANGUAGE Rank2Types, n with LANGUAGE RankNTypes.
09:31:39 <Oded> For exmaple list of types that I know every element has the function "show"
09:31:39 <jophish> Oded: why not make a container of functions?
09:31:52 <hodapp> An object is just a record? I thought an object was more of an entire RPC agent where its contents are supposed to be totally hidden, and you get things from it by asking it.
09:32:05 <monochrom> oh, you single out "show". then I have something for you.
09:32:09 <monochrom> @quote monochrom river
09:32:09 <lambdabot> monochrom says: You are to send a boolean, a character, and an integer across the river. The list for transporting across the river can hold 3 items, in fact any number of items you like, but they must all be of the same type. On the bright side, after crossing the river, the boolean, the character, and the integer need only be put on show. How
09:32:09 <lambdabot> many trips do you need? Solution: one trip, [show the_boolean, show the_character, show the_integer]
09:32:15 <geekosaur> ion: Rank2Types is the same as RankNTypes
09:32:30 <Rotaerk> Oded, what's an example of, say, a C# interface that you would like to encode in haskell?
09:32:32 <P4Titan> Here is my paste: http://lpaste.net/649915177080193024
09:32:35 <geekosaur> ghc treats them as synonyms. so no point in ever treating rank2 specially
09:32:57 <Rotaerk> Oded, oh, every elemant has method "show"...
09:33:14 <ion> geekosaur: Oh, ok.
09:33:27 <Rotaerk> Oded, in that case, what jophish said... a list of "show" functions would suffice
09:33:41 <Rotaerk> although in haskell "Show()" isn't a function so much as an IO ()
09:33:45 <Rotaerk> so it'd just be [IO ()]
09:33:59 <safinaskar> monochrom: good quote :)
09:33:59 <int-e> @poll-results should-lambdabot-be-more-polite
09:33:59 <lambdabot> Poll results for should-lambdabot-be-more-polite (Open): maybe=4, no=5, yes=4
09:34:17 <Rotaerk> I agree with the "no"
09:34:18 <geekosaur> P4Titan, you actually hav e all those duplicates in the global package db? :(
09:34:18 <safinaskar> int-e: how to make my choose?
09:34:20 <safinaskar> int-e: :)))
09:34:42 <P4Titan> What do you mean by "those"?
09:34:48 <int-e> /msg lambdaot @vote should-lambdabot-be-more-polite yes|no|maybe
09:35:16 <geekosaur> P4Titan, "Could not deduce (hashable-1.2.3.1:Data.Hashable.Class.Hashable" means it's trying to mix multiple versions of the "hashable" package. you have a mess.
09:35:38 <P4Titan> That is ture
09:35:43 <P4Titan> s/ture/true/
09:35:57 <hexagoxel> ghc-pkg will not show packages in sandbox..
09:36:08 <P4Titan> How to a fix my enbroiled libraries
09:36:12 <hexagoxel> i thought you are using sandbox, P4Titan ?
09:36:23 <Rotaerk> Oded, something you should note:  an interface containing an A->B function is equivalent to just having an A->B function... it just gives it a name
09:36:36 <P4Titan> Well I have a sandbox with hashable-1.2.3.1 installed, I think
09:36:49 <geekosaur> the problem is P4Titan is trying it both outside and inside the sandbox and getting different errors, and the hashable one is outside the sandbox
09:36:50 <Rotaerk> Oded, an interface containing two functions A->B and C->D is equivalent to a tuple (A->B, C->D)
09:36:52 <Rotaerk> etc
09:36:54 <Oded> Lets say I want to create a person datatype that has name and age. Now after a while coding my project, I want to add more information to the person type but I don't want to change what I have written. So I create new data type that I call EmailPerson where I have the same things as Person, but I add a string which is the person's email. Now, I want all the functions to accept the new EmailPerson, 
09:36:54 <Oded> so I create a class named IPerson where it has the methods - get-age, get-name. and I make the old and new datas to instances of that class and I change my functions to receive elements of the typeclass. But, my containers are holding elements of type Person and I want to be able to add the new data EmailPerson to the containers so that I can loop the container and print the name of every 
09:36:54 <Oded> person(using the get-name from the IPerson). How do I do that?
09:37:01 <safinaskar> int-e: ahaha, this poll is very funny. i love #haskell !
09:37:43 <geekosaur> you have both hashable-1.2.3.1 and hashable-1.2.3.2 installed. ghc picked the latter but is trying to use it with something linked against the former
09:37:51 <geekosaur> so it doesn't match
09:38:23 <P4Titan> I understand that, how to a straigten my mess of libraries?
09:38:38 <Rotaerk> Oded, GetAge being a function that just returns the age... in haskell would probably not need to be a function:  it'd just be a numeric expression
09:38:54 <safinaskar> please, everybody, take part in a poll! "/msg lambdabot @src ix" many many times and make your opinion about error messages of lambdabot. and then "/msg lambdabot @vote should-lambdabot-be-more-polite yes|no|maybe" (of course, you should choose "yes" or "no" or "maybe")!!
09:39:19 <Rotaerk> Oded, so:  data Person = Person { age :: Float, name :: String }
09:40:00 <geekosaur> P4Titan, in any case, as long as you have duplicate packages in global you're going to have problems
09:40:03 <Rotaerk> Oded, data EmailPerson = EmailPerson { person :: Person, emailAddress :: String }
09:40:07 <Oded> yea
09:40:21 <geekosaur> (I do hope you are not sorting that output; I can't tell because you aren't including the headers)
09:40:55 <Oded> then how do I create a list of persons that will be able to contain EmailPerson?
09:41:19 <ion> (person anEmailPerson) can be passed to anything expecting a Person.
09:41:23 <hexagoxel> safinaskar: you get one vote for each time lambdabot has offended you, right? :S
09:42:26 <safinaskar> hexagoxel: of course, no
09:42:39 <Oded> yea but next I want to add more fields so I create (to add identity number)  - data IdPerson = { person :: EmailPerson, identityNum :: Int }
09:43:14 <Rotaerk> Oded, let p = Person { age = 5; name = "Bob" }; ep = EmailPerson { person = Person { age = 6; name = "Joe" }, emailAddress = "joe@haskell.org" } in [p, person ep]
09:43:15 <Oded> so I have typeclass IPerson where getPerson :: a -> Person
09:43:49 <Rotaerk> Oded, so now, people can access the "person" aspect of both p and ep, via that list
09:44:01 <Rotaerk> s/people/the consumer/
09:44:26 <safinaskar> monochrom: as well as i understand type inference for rank 3 doesn't work. so, how haskell implements rank 3?
09:44:42 <Oded> Lets say I have global list of persons in the current project, I do I add all (with email, and etc or without) without lossing data?
09:45:00 <P4Titan> geekosaur: I am not sorting anything
09:45:18 <Rotaerk> Oded, you don't lose data; ep might exist elsewhere with that data
09:45:29 <Rotaerk> Oded, but that data doesn't need to be within that person-list, because it's irrelevant
09:46:05 <Rotaerk> irrelevant to the Person interface
09:46:07 <Oded> I dont want it to exist elsewhere with that data
09:46:14 <Rotaerk> Oded, why keep the data then?
09:46:21 <Rotaerk> you only need the name and age
09:46:24 <Oded> I want a list of all the persons in the current project
09:46:28 <geekosaur> P4Titan, it's usually difficult to get more than one version of a package in the global package database. Were you actively installing all those extra packages globally?
09:46:33 <Oded> mm
09:46:35 <Oded> I see
09:46:49 <Rotaerk> Oded, now, your example doesn't actually demonstrate the power of objects very well
09:47:01 <P4Titan> No, I did the following: `cabal list --simple-output --installed | awk '{print $1}' | uniq | xargs -I {} cabal install {} --reinstall`
09:47:22 <Rotaerk> Oded, a better question is... how does overriding work, how does private data work
09:48:03 <Oded> how does it work in haskell?
09:48:06 <Oded> overriding?
09:48:28 <Oded> Just using typeclass isnt it?
09:48:33 <geekosaur> P4Titan, that's ... bad.
09:48:38 <ion> Incidentally, makeClassy in lens can generate Person accessors for EmailPerson etc.
09:48:40 * hackagebot mongoDB 2.0.5 - Driver (client) for MongoDB, a free, scalable, fast, document  DBMS  http://hackage.haskell.org/package/mongoDB-2.0.5 (GregWeber)
09:48:53 <Rotaerk> Oded, typeclasses could be used to encode objects, but we can do it with simple data structures...
09:49:19 <Oded> I see
09:49:19 <P4Titan> geekosaur: Yeah ..... about that ....., Is there a way to expurgate everything and start over? Would that be the simplest way?
09:49:34 <geekosaur> I don't know how you installed ghc in the first place
09:49:43 <Rotaerk> Oded, if you think about it, an object consists of 1) a public interface, 2) a constructor, 3) an implementation of the public interface that potentially uses private data
09:49:52 <Rotaerk> so to create a complete object let's do all of that
09:50:00 <P4Titan> Through the apt-get
09:50:40 <Oded> how do you do number 3 in haskell?
09:51:31 <Rotaerk> Oded, 1) data Doorman = Doorman { greet :: IO (), invite :: IO () }
09:53:09 <Rotaerk> Oded, the thing about 2 & 3 is that they're interwoven.. the constructor is, itself, responsible for defining what the object is, and thus... the implementation of the interface
09:53:20 <Rotaerk> createDoormanFor :: String -> Doorman
09:54:32 <Rotaerk> Oded, createDoormanFor buildingName = DoorMan { greet = putStrLn $ "Welcome to " ++ buildingName ++ "!"; invite = putStrLn "Please come in!" }
09:54:59 <geekosaur> P4Titan, you need to remove ~/.ghc, then apt-get remove all the ghc/haskell packages, then remove /usr/lib/ghc to make sure the global package database is gone, then reinstall ghc
09:55:04 <Rotaerk> Oded, now, note, that the greet action is a closure on buildingName.  this makes it analogous to private data.
09:55:23 <P4Titan> Is that my only hope?
09:55:38 <Rotaerk> Oded, that's a constructor for Doorman objects, and it provides an implementation with private data
09:57:06 <Rotaerk> Oded, now, what about inheritance?  Inheritance generally implies: 1) a *potentially*, but not necessarily, extended interface, 2) a new implementation of at least pieces of the interface, 3) the constructor of the derived object is implemented in terms of the base constructor
09:57:15 <Oded> So the public init method is the one responsible of the initalization of the private data via the constructor and you use the data created by the init method(createDoorManFor) as generic one that has the records?
09:58:08 <Rotaerk> Oded, constructors aren't *really* methods; they're more like static functions for creating objects, which in-turn have methods
09:58:25 <Rotaerk> so you should think of them as altogether distinct from methods of the object
09:59:18 <Oded> and typeclass is just a method for function overloading?
09:59:32 <Rotaerk> Oded, essentially, all the "private" data is just local data that is *scoped within* the constructor
09:59:53 <Rotaerk> but which the functions returned have access to as closures
10:00:01 <Rotaerk> returned functions*
10:00:16 <Rotaerk> Oded, why are you bringing up typeclass? that's irrelevant here :P
10:00:16 <Oded> So it would be data Extended a b = { base :: a, extendsion :: b} for extending types?
10:01:06 <Rotaerk> yep, so:  data Bouncer = Bouncer { asDoorman :: DoorMan, reject :: IO () }
10:02:32 <monochrom> I think classes are brought up for the intuition "they are like interfaces".
10:02:47 <Oded> then I can pass asDoorman (Bouncer _) to some function accepting doorman only
10:03:03 <monochrom> FSVO "like" it is true. but not FSOV
10:04:11 <Oded> so to implement interface I can just create a record that is a function and then this will be my interface?
10:04:19 <Rotaerk> Oded, createBouncerFor buildingName = let d = createDoormanFor buildingName in Bouncer { asDoorman = d { invite = putStrLn "Come in, bitches!" }; reject = putStrLn "GTFO!" }
10:04:49 <Rotaerk> Oded, so there, I'm getting my base object, d, and then I'm *overriding* the implementation of "invite", and then providing an implementation of "reject"
10:05:08 <Oded> I see
10:05:15 <Oded> So its using functions as records
10:05:19 <Rotaerk> oh, something I didn't do was add *more* private data to the Bouncer implementation, but it should be apparent how to do that
10:05:33 <monochrom> safinaskar: whenever you ask for inference, GHC infers rank-1 only. but you can add rank-n type annotations, then GHC just has to check, not infer.
10:05:39 <Rotaerk> (just add another parameter to createBouncerFor)
10:06:06 <Oded> so in terms of OOP, the createBouncerFor is the real consturctor?
10:06:12 <Oded> constructor*
10:06:38 <monochrom> or smart constructor. or factory method.
10:06:40 <Rotaerk> createBouncerFor is analogous to the Bouncer class's constructor, and createDoormanFor is analogous to the Doorman class's constructor
10:06:54 <monochrom> why do you single out "real" constructors? even in OOP they don't.
10:07:28 <Oded> so you encode the private data in the function records?
10:07:29 <Rotaerk> you could make a new constructor (createDoorman2), and that's analogous to making a new class, say Doorman2, with its own implementation of IDoorman
10:07:42 <Rotaerk> Oded, I think you're misunderstanding what "record" means
10:07:56 <monochrom> even in OOP there are design patterns that say "don't tell the real constructor, just give a factory method".
10:07:58 <Rotaerk> record just refers to the syntax:  Foo { a = 5, b = 6 }
10:08:01 <Oded> the record "invite"
10:08:08 <Rotaerk> it's a syntax for constructing data structures
10:08:11 <Oded> you encode the private data/new one in that record
10:08:17 <Oded> yea, that one is just a function
10:08:20 <Rotaerk> "invite" isn't a record, it's more like a member
10:08:29 <Oded> okay
10:08:29 <Rotaerk> a member *of* the record
10:08:54 <Oded> so u encode the private data in the function members of the old data?
10:09:09 <Rotaerk> Oded, the private data is the data that is local to the constructor
10:09:13 <Rotaerk> in this case, buildingName
10:10:29 <Oded> making the "createBounderFor" method a constructor accepting private data and using it to redefine the "interface"(functions in the old data)
10:10:38 <Oded> okay
10:10:41 <Oded> So I think I understood
10:10:48 <Rotaerk> Oded, private data has three properties 1) it's initialized by the constructor, 2) it's accessible to the *methods* (e.g. invite, greet, reject), and 3) is not accessible to anything else outside the ctor
10:11:01 <Rotaerk> all of those are met in this case
10:11:15 <monochrom> you may like to read http://www.slideshare.net/ScottWlaschin/fp-patterns-buildstufflt
10:11:21 <Oded> just like in oop
10:11:23 <Oded> okay thanks
10:11:25 <monochrom> especially slide 13
10:12:21 <Rotaerk> Oded, you could also do this with typeclasses and existentially quantified types but ... this way is simpler IMO
10:12:28 <Rotaerk> maybe more flexible?
10:12:42 <Rotaerk> at the very least it only uses very basic mechanisms
10:14:06 <Oded> yea. and I never tried existentially quantified types so..
10:14:10 <Gurkenglas> What's the library for lists with holes?
10:14:21 <Gurkenglas> (the algebraic derivative of a list)
10:14:34 <monochrom> is that along the line of "zipper"?
10:17:10 <Gurkenglas> I... think? if we call it d[] for derivative of [], there'd be Int -> [a] -> d[a] for making a hole at the given index (maybe also returning the element there, or including it in the datatype), and d[a] -> [a] for removing the hole (maybe also taking the element to be put there as another argument)
10:17:54 <tomphreek> is it possible to pattern match <0 (negative numbers)?
10:18:06 <monochrom> no. use a guard.
10:18:07 <ion> foo n | n < 0 =
10:18:11 <tomphreek> thanks
10:18:12 <Gurkenglas> And probably also (([a] -> [d[a]]) or ([a] -> [(a, d[a])])) in O(n).
10:20:36 <Gurkenglas> (Which would be analogous to https://www.haskell.org/hoogle/?hoogle=tails )
10:39:10 <dmj`> has instance sigs been around for a while
10:47:24 <msd> Is there a way I can generate haskell code from C?
10:48:27 <kadoban> A C compiler that outputs Haskell? Heh, I guess you could, but … probably not super usefully ?
10:48:38 <dmj`> msd: why
10:48:42 <ion> printf ("main = putStrLn \"Hello world\"\n");
10:49:04 <msd> I have problem in writing a simple function in haskell
10:49:36 <monochrom> your strategy gives you two problems, rather than solves one problem
10:49:56 <msd> its a simple for loop, but one of the variable keep on changing,
10:50:16 <msd> so cant be done using map over list
10:50:27 <tempname11_> msd: post code please
10:50:52 <ion> Isn’t “one of the variables keeps on changing” exactly map over a list? :-P
10:51:08 <tempname11_> maybe it's a fold ;)
10:51:25 <monochrom> then don't use map over list. there are a dozen other list functions in the library. and there are infinitely many more you can write
10:51:27 <msd> May I post the link to algo and my approach towards the code?
10:51:28 <td123_> does anyone know of a haskell function that does the same thing as the "tr" unix command or http://ruby-doc.org/core-2.2.0/String.html#method-i-tr
10:51:39 <tempname11_> msd: sure, I'll take a look
10:52:22 <msd> tempname11_ : page 18 algorithm 1 http://www.cs.cmu.edu/~pavlo/static/papers/APavloThesis032006.pdf
10:52:25 <monochrom> ion, when a beginner says "a for-loop with a changing variable", it is likely two variables, because the beginner forgot to count the index variable for the for-loop
10:53:14 <monochrom> this is why it is best to write explicit while-loops so you see how many things are changing, really.
10:53:55 <msd> tempname11_ : my appraoch at https://github.com/prash471/TreeDrawing/blob/master/Layout/Radial2.hs
10:55:52 <tempname11_> msd: not sure what the problem is yet. is your code incomplete, and if yes, what part is missing / broken?
10:57:29 <worldsayshi> Is there something similar to readmvar that will wait until there is a new value in the mvar but not remove the existing one? Passing in a revision number would be ok. I guess I can forver look at the current value until changed but that it seems there should be a less ugly solution.
10:58:31 <msd> tempname11_ : The code is complete but not correct, the problem is given a tree we have to assign position coordinates to each Node. The for loop of algo is updating u at each iteration that I am unable to do
10:58:46 <monochrom> worldsayshi: would tvar be better?
10:59:33 <mjrosenb> so, I found an interesting use case for infallible patterns.
10:59:48 <monochrom> irrefutable? but great new name :)
10:59:53 <mjrosenb> err
10:59:57 <mjrosenb> yes.
11:00:00 <tempname11_> msd: it's a bit hard to make out the correspondence between the paper and the code, so please help me out and point out which function is broken
11:00:02 <monochrom> to a large extent they are synonyms :)
11:00:02 * mjrosenb is bad with names.
11:00:16 <worldsayshi> monochrom: I don’t see how tvar would be better in this regard when reading the docs…
11:00:27 <mjrosenb> anyhow, I've been using them in a case where they can theoretically fail.
11:00:45 <mjrosenb> just we never look at the bound variable in the case that the binding will fail.
11:00:47 <tempname11_> foo, I guess
11:01:08 <msd> tempname11_ : only two functions are important there, radialLayout which will asssign postions to each node, and the foo function which is the for loop of algorithm
11:01:36 <Zer000> DUDES! Why am I getting "Could not find module ‘Data.IP’"? Do I need to add something to my .cabal file to use it?
11:01:59 <merijn> Zer000: Well, what package is it from? Is that package installed and listed as a dependency?
11:02:01 <mjrosenb> Zer000: yes, you need to add that library as a dependency.
11:02:15 <mjrosenb> https://gist.github.com/60600c2b179f7d08a17f
11:02:27 <dmj`> td123_: ping
11:02:35 <monochrom> that's interesting, yeah
11:02:39 <dmj`> td123_: have you tried to write it yourself
11:03:07 <msd> tempname11_ : problem is I am mapping foo over list, which makes like applying same thing to all list elements, but as per algo the for loop is updating at each iteration. Sorry I am still beginner
11:03:15 <monochrom> queues are wacky :)
11:03:47 <Zer000> merijn, mjrosenb I'm talking about https://hackage.haskell.org/package/iproute-0.1/docs/Data-IP.html how do I get the name of the package?
11:04:15 <tempname11_> msd: ok, thinking...
11:04:16 <mjrosenb> monochrom: yeah.
11:04:18 <izekflev> lambdabot: @quote who.do.you.call
11:04:18 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
11:04:42 <mjrosenb> Zer000: /package/package_name-version/docs...
11:04:47 <tempname11_> (zipWith (foo alpha beta theta k) ts)
11:05:10 <tempname11_> this looks suspicious. did you really mean a partial function application here?
11:05:22 <tempname11_> or is it 'map' instead here?
11:05:39 <dmj`> td123_: you there?
11:05:39 <Zer000> mjrosenb, oooooh. ok thanks!
11:06:22 <dmj`> @def tr table xs = let f x = fromMaybe x (lookup x table) in map f xs
11:06:23 <lambdabot>  .L.hs:148:1: Warning:
11:06:23 <lambdabot>      Pattern match(es) are overlapped
11:06:23 <lambdabot>      In an equation for ‘tr’: tr table xs = ...
11:06:31 <dmj`> > "hello" & tr [('e','i'),('l','p')]
11:06:33 <lambdabot>  "hippo"
11:07:31 <msd> tempname11_ : sorry that should be map not zipwith, sorry..
11:07:37 <tempname11_> yeah, got it
11:07:54 <mjrosenb> dmj`: I am a bit confused about the warning that lambdabot gave there...
11:08:15 <dmj`> td123_: O(n*m) time though, where n is size of map, m size of input, use a hashmap for logarithmic
11:08:31 <dmj`> mjrosenb: I am too
11:08:51 <tempname11_> and the problem is that 'theta' is changing in the original loop, right?
11:09:03 <tempname11_> and it doesn't when you "map"
11:09:12 <msd> tempname11_ : yes..right
11:09:14 <mjrosenb> > return "hi" :: IO String
11:09:15 <lambdabot>  <IO [Char]>
11:09:37 <mjrosenb> > putStrLn "hi"
11:09:39 <lambdabot>  <IO ()>
11:09:40 <msd> yes
11:10:00 <mjrosenb> bah... 
11:10:25 <tempname11_> not to criticize, but if you formulated it that way in the beginning, life would be easier for me, so please describe the problem more precisely next time... but moving on :)
11:10:30 <mjrosenb> > unsafePerformio $ (return "Hi" :: IO String)
11:10:31 <lambdabot>  Not in scope: ‘unsafePerformio’
11:10:42 <mjrosenb> > unsafePerformIO $ (return "Hi" :: IO String)
11:10:43 <tempname11_> thinking....
11:10:44 <lambdabot>  Not in scope: ‘unsafePerformIO’
11:11:12 <td123_> dmj`: sorry, I was busy writing it myself :)
11:11:15 <msd> tempname11_ : sorry, its first time I am asking doubts here :)
11:11:30 <tempname11_> no problem at all :)
11:11:56 <td123_> dmj`: thanks for the suggestion
11:12:11 <td123_> dmj`: using a hashmap would probably be ideal
11:13:19 <mjrosenb> ok, does haskell have any way to emulate SML-style functors, or do I need to manually pass a context around everyplace?
11:13:27 <tempname11_> msd: so I see two solutions
11:13:58 <tempname11_> even three
11:14:18 <monochrom> mjrosenb: associated type families may emulate SML functors
11:14:27 <msd> tempname11_ : please suggest then 
11:14:43 <mjrosenb> err, for values, I don't care about types atm.
11:14:47 <tempname11_> the best option would probably be to ditch map and standard library functions over lists, and write the loop recursively manually
11:15:00 <tempname11_> this way you'll get a good understanding for what happens
11:15:09 <mjrosenb> I just want an entire module parameterized on a function of type Int -> Int (for example)
11:15:27 <msd> tempname11_ : ok, and other ?
11:15:32 <tempname11_> the second option is to use a fold, which basically is a generalization of some recursive algorithms.
11:15:35 <Welkin> types are the foundation of the language...
11:16:03 <tempname11_> the third option is to use the State monad, and carry theta as state. this way the code will be closest to the original paper
11:16:35 <tempname11_> but it might seem 'magical' and that will limit the understanding of the problem
11:17:11 <tempname11_> to be honest I'm not an expert, also a beginner, so if someone else can comment, please do
11:17:18 <tempname11_> but this is my opinion :)
11:17:22 <msd> tempname11_ : ok thanks, then I should try the first and third approach
11:17:24 <dmj`> td123_: you can make it look even more like the ruby imp if you zip the inputs
11:17:38 <dmj`> @def tr' zs js xs = let f x = fromMaybe x (lookup x (zip zs js)) in map f xs
11:17:39 <lambdabot>  Defined.
11:17:41 <tempname11_> msd: tell me how it goes :)
11:17:47 <dmj`> > "hello" & tr' "el" "ip"
11:17:49 <lambdabot>  "hippo"
11:18:12 <td123_> dmj`: nice :)
11:18:20 <monochrom> mjrosenb: then it sounds like passing around a record is the lowest-entry solution for now
11:18:38 <td123_> dmj`: this is helpful, thanks
11:18:52 <mjrosenb> monochrom: that's what I thought :-/
11:19:26 <suppi> help, i keep getting  'hGetContents: invalid argument (invalid byte sequence)' when running ghc-mod inside a cabal sandbox :(
11:19:38 <dmj`> td123_: then use a Map to make it more efficient
11:19:47 <dmj`> @def tr'' zs js xs = let f x = fromMaybe x (M.lookup x $ M.fromList (zip zs js)) in map f xs
11:19:48 <lambdabot>  .L.hs:151:1: Warning:
11:19:49 <lambdabot>      Pattern match(es) are overlapped
11:19:49 <lambdabot>      In an equation for ‘tr''’: tr'' zs js xs = ...
11:19:57 <dmj`> > "hello" & tr'' "el" "ip"
11:19:59 <lambdabot>  "hippo"
11:20:06 <msd> tempname11_ : any help on how to go with state monads?
11:21:05 <mjrosenb> suppi: what data is in the file?
11:21:34 <dmj`> msd: State s a -> (a -> State s b) -> State s b; so m >>= f = State $ \s -> let (a,s') = runState m in runState (f a) s'
11:21:40 <mjrosenb> msd: I'd personally recommend that you write the state monad once before you use it, so you're familiar with how it works.
11:21:45 <suppi> mjrosenb, it's a dist/setup-config
11:21:46 <mjrosenb> or that.
11:21:47 <suppi> file
11:21:59 <suppi> made by cabal i think?
11:22:09 <msd> ok thanks
11:22:40 <dmj`> msd: I recommend writing it out, and explicitly annotating the type of every variable / function
11:23:03 <dmj`> msd: then use it in practice to gain an intuition
11:23:12 <dmj`> > flip evalState 5 $ modify (+1)
11:23:13 <lambdabot>  ()
11:23:16 <suppi> mjrosenb, "Saved package config for Project-lang-0.0.1 written by Cabal-1.22.3.0 using ghc-7.8" 
11:23:26 <dmj`> > execState 5 $ modify (+1)
11:23:26 <suppi> bla bla bla, mix of symbols and text
11:23:27 <lambdabot>      Could not deduce (Num (State (m ()) a0))
11:23:28 <lambdabot>      from the context (Num s, Num (State (m ()) a), MonadState s m)
11:23:28 <lambdabot>        bound by the inferred type for ‘e_151’:
11:23:37 <dmj`> guess I need to write it out myself :)
11:23:41 <tempname11_> forgot flip :)
11:23:49 <dmj`> > flip execState 5 $ modify (+1)
11:23:51 <lambdabot>  6
11:23:55 <dmj`> tempname11_: thanks :)
11:25:43 <tempname11_> dmj`: the curious thing is I didn't understand what your advice to msd was... writing out (>>=) manually?
11:30:41 <dmj`> tempname11_: yea, you have to create an instance of Monad to use the State data type as a monad. Explicitly annotating the types helps you understand it in its entirety
11:34:55 <merijn> tempname11_: Filling in the undefineds here is a good exercise: https://gist.github.com/merijn/098106abd45c940dab09
11:35:01 <dmj`> tempname11_: like this, http://lpaste.net/132753
11:35:37 <tempname11_> yep, got it
11:36:06 <tempname11_> btw, I didn't know you could annotate type on the left-hand of =
11:36:20 <tempname11_> that's kinda cool
11:38:20 <merijn> Is there a safe fromIntegral anywhere?
11:40:07 <tempname11_> merijn: is it unsafe? I though it just wrapped around on huge values
11:40:20 <merijn> Right, which is unsaf
11:40:39 <tempname11_> I guess you mean an "a -> Maybe b"
11:40:53 <tempname11_> which is Nothing on overflow
11:41:01 <merijn> I spent 1 month and 3 different patches to fix a wraparound bug caused by that in the runtime last time, so I'm trying to avoid adding the same bugs to my own code :p
11:42:05 <JohnBovril> alright
11:42:28 <JohnBovril> just grappling with some really early stuff here
11:42:50 <JohnBovril> always amazed when it says 'excerise' and it feels way beyond me
11:43:12 <JohnBovril> didn't do too bad, just want some pointers to make this excerise work
11:43:21 <geekosaur> > (\x -> let x' = fromIntegral x :: Int;' r = fromIntegral x in if fromIntegral r == x' then Just r else Nothing) 1000000000000000000000000 :: Maybe Int
11:43:22 <lambdabot>  <hint>:1:39: Parse error in pattern: 'r
11:43:25 <tempname11_> merijn: just found this: http://hackage.haskell.org/package/int-cast-0.1.2.0/docs/Data-IntCast.html#v:intCastMaybe
11:43:29 <geekosaur> whoops
11:43:30 <monochrom> which exercise?
11:43:36 <JohnBovril> "Write a function lastButOne, that returns the element before the last."
11:43:42 <geekosaur> > (\x -> let x' = fromIntegral x' :: Int; r = fromIntegral x in if fromIntegral r == x' then Just r else Nothing) 1000000000000000000000000 :: Maybe Int
11:43:46 <lambdabot>  mueval-core: Time limit exceeded
11:43:53 <JohnBovril> so it was a little over my head
11:43:59 <JohnBovril> I tried out this line:
11:44:19 <JohnBovril> lastButOne x = head (drop (length x-2) x)
11:44:25 <merijn> geekosaur: That has a bottom
11:44:26 <JohnBovril> but it is limited to [Char] -> Char
11:44:36 <merijn> geekosaur: "x' = fromIntegral x'" <-
11:44:40 <geekosaur> I had several typoes in that
11:44:49 <geekosaur> the extra prime, which I thought was a misplaced one
11:44:51 <eacameron> I want to call a bunch of functions that all take the same first 2 arguments. is there a monad to capture that and curry out the first 2 args?
11:44:54 <geekosaur> for example
11:44:56 <JohnBovril> whereas the function should be [a] -> a
11:45:45 <geekosaur> > (\x -> let x' = fromIntegral x :: Integer; r = fromIntegral x in if fromIntegral r == x' then Just r else Nothing) 1000000000000000000000000 :: Maybe Int -- what I intended
11:45:46 <lambdabot>  Nothing
11:45:52 <merijn> JohnBovril: FYI, that's a pretty slow implementation, since length first has to traverse the entire list to compute the length and then again to compute the result
11:45:52 <tempname11_> eacameron: Reader ? but you need to uncurry the functions first
11:47:02 <merijn> JohnBovril: Think recursively, what is the result of the following cases: 1) lastButOne [], 2) lastButone [x], 3) lastButOne [x,y], and 4) lastButOne someList
11:47:25 <tempname11_> eacameron: and also it would be better if the arguments were last so you could partially apply the rest of the args
11:47:36 <JohnBovril> yeah I'm okay with that merijn... I understand that Haskell is all about efficiency but I'd go for comprehension at this point. I know what I've done persay, I would just like to be gently pointed towards methods of doing that same process but for :: [a] -> a rather than [char] to char
11:47:55 <JohnBovril> okay
11:48:29 <merijn> JohnBovril: It's not just efficiency, it's also that I think the solution I have in mind would be easier to implement, although it takes practice to spot it
11:48:42 <JohnBovril> yeah I imagine it would be easier too 
11:48:44 * hackagebot pager 0.1.1.0 - Open up a pager, like 'less' or 'more'  http://hackage.haskell.org/package/pager-0.1.1.0 (pharpend)
11:48:59 <JohnBovril> I'm not able to 'think' haskell yet
11:49:02 <JohnBovril> early days and all
11:49:02 <merijn> JohnBovril: Try writing out a pattern match for all four of them in that order and then fill them in :)
11:49:13 <JohnBovril> so
11:49:32 <JohnBovril> if I have a function that only has one argument do I still need to consider it possibly having two
11:49:41 <JohnBovril> like with lastButOne (x,y)
11:49:47 <JohnBovril> [x,y] even
11:50:01 <tempname11_> JohnBovril: that's still one argument
11:50:05 <unclechu> hi there. how i can get environment variable? there's any haskell module with monad?
11:50:08 <JohnBovril> [x,y
11:50:10 <SrPpx> Is there any way to create a type identical to another, except typechecking still differs them, and that doesn't need wrapping/unwrapping (such as newtype)
11:50:15 <merijn> JohnBovril: [x,y] is one argument, a list of two elements
11:50:19 <JohnBovril> right
11:50:28 <JohnBovril> that's the same as 4 then?
11:50:39 <JohnBovril> lastButOne someList
11:50:40 <merijn> JohnBovril: Alternatively written as "(x:(y:[]))"
11:50:46 <mniip> SrPpx, if it needs no wrapping, how will typechecking tell them apart
11:50:47 <JohnBovril> unless someList is a function
11:50:55 <SrPpx> dunno
11:51:05 <merijn> JohnBovril: No, a list of two elements is not the same as a list of arbitrary length
11:51:11 <JohnBovril> right
11:51:20 <JohnBovril> so
11:51:25 <merijn> unclechu: System.Environment
11:51:29 <JohnBovril> [x,y] /= [Char]
11:51:52 <unclechu> merijn, TY
11:52:02 <tempname11_> SrPpx: nope, the only way is to manually copy the definition and instances :)
11:52:05 <merijn> [Char] is a type, that is, a list of characters. Out of curiosity, are you defining things inside ghci?
11:52:08 <tempname11_> SrPx: why do you need this?
11:52:34 <JohnBovril> no, I'm writing then loading the module into ghci
11:52:44 <JohnBovril> :l something.hs
11:53:17 <SrPx> tempname11_: just an experiment to replace "Int"s all around by more meaningful types wuch as Weight, Radius etc and see if code improves or degrades
11:53:30 <merijn> Nevermind, my suspicion was dumb
11:53:36 <merijn> JohnBovril: Can you put the file on lpaste?
11:53:43 <JohnBovril> it's literally two lines :)
11:53:58 <tempname11_> SrPx: well, the newtype works pretty well for that, why don't you want to use it?
11:53:59 <JohnBovril> and one is the flawed :: declaration
11:54:10 <JohnBovril> lastButOne :: [a] -> a
11:54:10 <JohnBovril> lastButOne x = head (drop (length x-2) x)
11:54:23 <SrPx> nothing against it, just wondered if there is something more lightweight syntatically but alright tempname11_ 
11:54:37 <JohnBovril> I'll have another stab at it with your comments noted, thank you for the help Merijn
11:55:16 <merijn> JohnBovril: That really shouldn't end up as "[Char] -> Char", though, unless you're doing weird things in your file or ghci :)
11:55:19 <tempname11_> SrPx: you could make your newtype an instance for Num, so you could do 5 :: Weight
11:55:24 <tempname11_> for literals
11:55:53 <merijn> SrPx: You can't do it without newtype, no. But what's the problem with wrapping/unwrapping?
11:56:00 <JohnBovril> it seems to think it's [a] -> a now
11:56:00 <kristof> Does anyone else here think monad transformers impose unnecessary structure on related contexts? I'm just getting more and more enamored with the idea of that algebraic effect stuff, where effects are collected into a set, and not some structure
11:56:05 <pharaun> I thought that was discouraged to do extension of Num?
11:56:12 <tempname11_> kristof: yes!!!
11:56:14 <JohnBovril> as I've removed the type dec and done :t function
11:56:18 <JohnBovril> but
11:56:28 <JohnBovril> I don't think I can call a number
11:56:36 <JohnBovril> I'll give it a go later, gotta go now
11:56:40 <kristof> tempname11_: Who was that guy who made the demo of algebraic effects in Haskell? Famous for continuation research
11:56:45 <JohnBovril> thanks good sir
11:57:04 <tempname11_> kristof: no idea. but I saw something like that in Idris
11:57:11 <tempname11_> I think
11:57:13 <merijn> kristof: The only problem is that no one has made it fast yet
11:57:16 <mniip> SrPx, it makes no sense to have distinct types but no wrapping
11:57:18 <merijn> kristof: You're thinking of Oleg
11:57:26 <sinelaw> Is there an easy way to grep all of package sources on hackage?
11:57:35 <merijn> Kiskelyov or however you spell his last name
11:57:42 <tempname11_> sinelaw: Hayoo?
11:57:55 <mniip> because you could feed a weight into a function taking a radius
11:58:01 <geekosaur> Kiselyov
11:58:05 <mniip> because that's wrapRadius . unrwapWeight
11:58:08 <dmj`> merijn: Kiselyov
11:58:09 <merijn> sinelaw: Are you looking for a function where you don't know the module?
11:58:10 <sinelaw> tempname11_, isn't that by type etc.? I want grep
11:58:12 <Oded> What Haskell IDE do you use and which one do you recommend/
11:58:13 <Oded> ?
11:58:21 <sinelaw> merijn, no, i'm looking for a specific code pattern
11:58:23 <dmj`> Oded: haskell-mode emacs
11:58:25 <merijn> Oded: Vim and I'd say vimd/emacs
11:58:27 <tempname11_> oh, you mean literally
11:58:31 <sinelaw> tempname11_, yes
11:58:41 <tempname11_> sinelaw: in the sources?
11:58:55 <kristof> tempname11_: http://okmij.org/ftp/Haskell/extensible/ found it
11:58:56 <sinelaw> yip
11:59:45 <Oded> Well, I'm currently using vim, but it feels like I'm so newbie and don't have the right extensions so using it feels like a normal text editor
12:00:47 <merijn> Oded: I only use two extensions, tbh
12:00:53 <Oded1> Which ones?
12:01:05 <Oded1> Lol I disconnected(shity internet here :( )
12:01:13 <merijn> Oded: Syntastic for highlighting compile errors using hdevtools and the hdevtools extension to query the type of an expression
12:01:20 <tempname11_> Oded1: try https://github.com/begriffs/haskell-vim-now
12:01:26 <tempname11_> that's what I use
12:01:29 <merijn> But, tbh, I could probably live with just syntastic
12:01:39 <kristof> merijn: Bummer. Doesn't reaching into a buried level of a monad transformer also have a pretty substantial performance penalty because of all that pointer chasing?
12:02:01 <merijn> kristof: "it depends"
12:02:14 <merijn> kristof: You could always coyoneda the whole thing
12:02:32 <Oded1> And anyone tried to use tmux to get windows split for interpreter or there's an extension for vim for the interpreter
12:02:47 <kristof> merijn: Of course :) But specifically, does it mostly depend on whether static analysis can eliminate excessive dereference and inline certain things?
12:02:59 <muzzle> Hi, I want to parse a binary data format, that contains an array of either Word8, Int8, Int 16, Int32 or Float values. How can i make a datatype for such a format, so that i don't have to build a sum type with an alternative for each datatype ? Any ideas ?
12:03:01 <kristof> That's really my last question on the matter.
12:03:15 <pharaun> i mainly stick with syntax highlighting + ghci
12:03:44 <tempname11_> Oded1: the thing I linked has some limited interations with ghci inside tmux, but I haven't used it so can't tell if it's any good
12:03:44 * hackagebot stack 0.0.0 - The Haskell Tool Stack  http://hackage.haskell.org/package/stack-0.0.0 (DanBurton)
12:03:46 * hackagebot yi 0.12.0 - The Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-0.12.0 (DmitryIvanov)
12:03:52 <pharaun> for some reason, i keep on trying stuff like ghc-mod, etc to bring in type inferring into vim, etc and i never use em, just never pops into my mind :\
12:04:01 <kristof> muzzle: You used the word "or" in your description of the datatype, so I think you're stuck with sumtypes.
12:04:08 <pharaun> so i find vim+syntax+ghci to be an excellent combo
12:04:11 <merijn> Oded1: I just manually split my tmux windows and have ghci in one and vim in the other
12:04:16 <pharaun> ^++
12:04:18 <Oded1> Okay , I'll give it a try
12:04:27 <merijn> pharaun: You can just use typed holes to query types :p
12:04:43 <Oded1> any easy installation on windows?
12:04:47 <muzzle> kristof: it's just annoying that i have to write the same function for each alternative
12:04:47 <merijn> pharaun: I find the error highlighting by syntastic to be valuable, though
12:04:58 <muzzle> kristof: even though it's always basically the same
12:05:03 <pharaun> merijn: yah that's what i usually end up doing if i'm really deep into something on occasion i'll go oooh perfect time for typed holes
12:05:06 <kristof> muzzle: Paste?
12:05:19 <pharaun> merijn: never tried syntastic, i should give it a shoot
12:05:19 <merijn> Oded1: I don't know, tbh. I switched from windows to OSX/*nix when I started programming more
12:05:25 <pharaun> error highlighting seems valuable
12:05:38 <pharaun> and wouldn't require me to *remember* to do something/invoke a command
12:05:50 <merijn> pharaun: It's good, not just for haskell, also C/C++
12:06:26 <merijn> pharaun: The only downside is that it's not really possible to do things asynchronously in vim, so upon a safe it can block you for a few seconds if your files aren't in the disk cache
12:06:32 <pharaun> ahh
12:06:37 <pharaun> oof, good ol' vim
12:07:05 <merijn> pharaun: I'd recommend setting the syntastic config to pass -fno-code and -O0 to ghc
12:07:08 <maerwald> pharaun: afais emacs has better haskell support
12:07:18 <maerwald> syntastic cannot show error messages with proper linebreak
12:07:22 <merijn> pharaun: Because that makes ghc a lot faster at compiling and you only care about errors anyway
12:07:35 <merijn> maerwald: Yeah, but emacs is lacking a good editor :D
12:07:36 <muzzle> kristof: something like http://lpaste.net/132755
12:07:42 <maerwald> merijn: heh
12:07:43 <pharaun> maerwald: yah, i've experimented with emacs+evil but i'm too addicted to vim modalness/keybindings, its a on-going thing
12:07:46 <muzzle> but i haven't completely written it out yet
12:08:14 <pharaun> i like the bindings/etc of vim, but i don't like its guts, oh well, emacs seems to have nicer guts (easier to extend, etc) but in tradeoff, the editor man
12:08:33 <pharaun> merijn: that's a good pointer i'll try that out and see if i can get used to the delay
12:08:43 <merijn> pharaun: It's only occasionally for me
12:08:47 <kristof> muzzle: Can't you make Word8, Int8, Int16, etc. instances of a typeclass that does what you want?
12:08:48 <pharaun> ahh k
12:09:07 <pharaun> merijn: probably just on first save, i tend to save pretty often then try out expressions in ghci so should probably most of the time be in disk cache anyway
12:09:07 <merijn> i.e. the first time I save a file all the other modules also need to be compiled to typecheck and they're likely not in the diskcache
12:09:11 <pharaun> yeah
12:09:18 <pharaun> makes sense
12:09:31 <merijn> pharaun: Especially with hdevtools (or ghc-mod's server mode, not sure it uses that by default)
12:09:36 <merijn> Since those cache most of the results
12:10:00 <muzzle> kristof: probably, but somehow that feels messy :P
12:10:07 <ethercrow> you could do async syntastic-ish thingy in yi
12:10:09 <merijn> Actually, you probably couldn't
12:10:27 <pharaun> oh why not?
12:10:27 <kristof> muzzle: I don't know how else to express "I need to write one function that works on multiple datatypes, where the code for each data is essentially the same"
12:10:30 <merijn> Decoding data into an input dependent type is not really doable
12:10:37 <merijn> pharaun: That was meant for muzzle/kristof
12:10:44 <tempname11_> muzzle: why not "data IDXData a = IDXData (V.Vector Int) (V.Vector a)" ?
12:10:50 <pharaun> oh nvm :)
12:11:03 <merijn> tempname11_: Because then you don't know what the return type is when you call "myDeserialise"
12:11:19 <merijn> tempname11_: The result would depend on a runtime value, which is not something you can do in haskell's typesystem
12:11:33 <tempname11_> merijn: :t myDeserialise plz
12:11:52 <tempname11_> don't understand what you mean yet
12:12:15 <merijn> tempname11_: He was saying the contents of the array depend on the data he's deserialising
12:12:20 <muzzle> tempname11_: depending on the input it could either be IDXData Double or IDXData Int 
12:12:30 <merijn> So you'd have "ByteString -> IDXData ?"
12:12:31 <muzzle> tempname11_: but you cann't tell which at compiletime
12:12:38 <merijn> Where the question mark depends on the ByteString contents
12:12:58 <merijn> You could do that in, for example, Idris
12:13:03 <tempname11_> myDes :: a -> Either (IDX Double) (IDX Int) ??
12:13:22 <merijn> tempname11_: Right, but that means explicitly specifying all options again
12:13:27 <pharaun> couldn't this be a case for typeclass ?
12:13:33 <merijn> pharaun: Doesn't help
12:13:38 <muzzle> tempname11_: The problem is just that i have a fairly large number of options (~8)
12:13:41 <merijn> pharaun: Typeclasses still have to decide the type at compile time
12:13:51 <pharaun> oh right i missed the *runtime* bit ok
12:13:55 <merijn> muzzle: Alternatively you could take a RankN CPS approach, but that's not better
12:14:12 <merijn> I think I have some code doing that somewhere
12:14:30 <tempname11_> data Variant v = VariantDouble (v Double) | VariantInt (v Int) | ...   ??
12:14:41 <merijn> muzzle: https://github.com/merijn/SNet2.0/blob/master/SNet/Stream.hs#L25-L30
12:14:58 <tempname11_> and then -- myDes :: a -> Variant IDX ? 
12:15:26 <merijn> tempname11_: Hah, that's a neat idea, I hadn't considered that
12:22:31 <tempname11_> muzzle: what do you think?
12:28:08 <merijn> argh
12:28:30 <merijn> The huge inconsistency between which numeric type is being uses in the various FFI/ByteString APIs is a bitch
12:29:03 <merijn> ByteString does everything in Int, but GHC does everything with ByteCount which is CSize >.<
12:29:50 <merijn> And just adding fromIntegral everywhere will just introduce silent overflows in a billion places...
12:31:18 <monochrom> wait, do those overflows occur? because ByteString's length values are not going to exceed memory size...
12:31:39 <monochrom> err, I guess the lazy one could. but still...
12:32:08 <merijn> monochrom: Irrelevant, they might not occur now, but these conversions are slumbering bugs waiting to happen
12:32:16 <merijn> monochrom: And debugging them is a bitch
12:32:18 <tempname11_> merijn: maybe write explicit functions for casts which check for bounds and throw runtime errors?
12:32:19 <geekosaur> on a 64-bit platform fromIntegral between those should be the identity. I think a 32-bit platform would be the same, and the case most likely to be aproblem doesn''t work with ghc yet
12:32:29 <merijn> geekosaur: !
12:32:30 <tempname11_> better crash than overflow silently
12:33:02 <geekosaur> actually I think even that works because it's size, not pointer
12:33:10 <merijn> geekosaur: Actually, you're PROBABLY right about CSize and Int for GHC
12:33:37 <merijn> geekosaur: But, for example, Int and CInt are a big problem
12:33:40 <tempname11_> merijn: Int is signed
12:33:51 <tempname11_> CSize = Word64 is unsigned
12:33:59 <geekosaur> yes, signedness is a potential gotcha
12:33:59 <tempname11_> can't be identity
12:34:01 <merijn> tempname11_: I know, but I check for negative values
12:34:32 <geekosaur> I think negative values would fail in the same way if ByteString is using Int for a size
12:34:39 <tempname11_> hm, why does it say Word64 here? http://hackage.haskell.org/package/base-4.8.0.0/docs/Foreign-C-Types.html#t:CSize
12:34:45 <merijn> geekosaur: I'm just paranoid because I've had to debug FFI conversions in haskell before and it's a pain
12:34:45 <geekosaur> so that's effectively an existing bug
12:34:48 <tempname11_> doesn't it depend on the platform?
12:34:49 <merijn> tempname11_: It's platform dependend
12:35:03 <geekosaur> tempname11_, the problem is the docs are generated during compiling, so reflect the platform
12:35:55 <merijn> I'm pretty sure base and RTS still have a bunch of bugs slumbering until someone trips over them
12:36:04 <merijn> I should audit them sometime and see if I can fix more
12:36:32 <geekosaur> which also means that if you follow a source link for something that is platform dependent, you may get the linux implementation and have to dig elsewhere for win32 or (sometimes) os x
12:37:07 <tempname11_> geekosaur: good to know
12:37:57 <merijn> geekosaur: Well, one problem I have right now in my current code
12:38:01 <geekosaur> if you're lucky, they used cpp and the other implementation is next to it. if you're not, it may not have generated the doc for it at all and you'll have to grab the source yourself
12:38:24 <merijn> geekosaur: "fdWriteBuf" takes a length to write in ByteCount (CSize) and returns length written in ByteCount
12:38:33 <merijn> geekosaur: Which means I need to start reading mid-ptr later
12:38:46 <merijn> But "plusPtr :: Ptr a -> Int -> Ptr a"
12:39:09 <merijn> If my remaining offset would be bigger than maxBound "Int", you have a problem
12:39:31 <merijn> Now, in this case my maximum length is Int anyway, due to ByteString using Int
12:39:38 <geekosaur> sounds like the FFI needs to be rethought
12:39:38 <merijn> But there's a lot of hairiness like this everywhere
12:39:55 <merijn> geekosaur: I'm not even sure what the right type would be for plusPtr
12:40:22 <merijn> Oh, wait, there's minusPtr too
12:40:23 <geekosaur> but I will note that ANSI C is still sorting these problems out
12:40:37 <merijn> So I guess it should just be "CSize"
12:40:39 <geekosaur> C99 and C11 helped but there are still corner cases
12:41:22 <lpaste> merijn pasted “FFI” at http://lpaste.net/132758
12:41:28 <merijn> Any obvious issues there?
12:42:13 <geekosaur> EINTR
12:42:33 <geekosaur> unless throwErrnoIfMinus1 handles that already
12:43:03 <merijn> geekosaur: throwErrnoIfMinus1 looks at the return value, and raises whatever error if it's -1 (based on errno)
12:43:08 <geekosaur> ah, it doesn't but throwErrnoIfMinus1Retry does
12:43:18 <merijn> Oh, I might wanna use that
12:43:38 <tempname11_> merijn: what are you working on?
12:43:55 <merijn> tempname11_: I'm finally fixing and making cross-platform my Pty library
12:44:19 <tempname11_> any links so I can take a look?
12:44:37 <refefer> hmm, any ideas why hGetChar would throw an 'end of file' error?  I've confirmed the line before that stdin is still open
12:44:38 <tempname11_> just curious
12:44:42 <exio4> is there any library for parser combinators with somewhat nice (something other than 'error happened') error messages and incremental parsing? 
12:45:01 <merijn> tempname11_: https://hackage.haskell.org/package/posix-pty that one only compiles on OSX, though and is a bit anemic, since I got distracted working on other stuff
12:45:50 <merijn> tempname11_: The one I have locally builds on OSX, FreeBSD (and probably linux, but I didn't test that since I don't have a linux box with GHC easily accessible)
12:46:27 <tempname11_> merijn: what's the use case for a pty?
12:46:46 <geekosaur> refefer, control-d on unix / control-z on windows?
12:46:56 <tempname11_> never heard of such a thing yet :)
12:47:04 <geekosaur> also EOF is not the same thing as closed, on your end
12:47:16 <geekosaur> the other end was closed, you're just being notified of that
12:48:07 <merijn> tempname11_: pty is a pseudo-terminal, usually when you fork children you'll communicate via pipes, but what if you wanna interact with a program that expects to have a terminal? (i.e. vim, some ncurses interface, etc.)
12:48:26 <refefer> geekosaur: hmm, interesting.  how can I prompt for a char?
12:48:37 <refefer> I assumed getChar was the right way but I'm guessing I'm wrong
12:48:39 <tempname11_> merijn: so you can programmaticaly control that program?
12:49:24 <merijn> tempname11_: Basically, things like tmux, terminal emulators (like XTerm, etc.) all have their child-processes talking to a pseudo-terminal and they translate the input/output to/from the pseudo-terminal
12:49:37 <tempname11_> merijn: yeah, got it
12:49:42 <tempname11_> thanks for explanation
12:50:15 <merijn> But yeah, if you wanna programmatically control something terminal based like vim/nethack/whatever that's what you'd use
12:50:46 <geekosaur> refefer, getChar usually is the right way but you may need some setup first. like disabling line buffering on stdout so the prompt is shown first (otherwise it won't be output until you output a newline), turning on character-at-a-time mode on Unixlikes (note that ghci is always in that mode so it won't be obvious unless you compile).
12:51:15 <maerwald> merijn: now that I think about it... I wonder if there is a project like "vimacs"... I am too afraid to search for it
12:51:21 <hsk4> Is one of the benefits of Haskell that you can let the laziness give you "buffering" for free? That is, instead of reading the whole file into a string, then passing that whole thing into a function to get results, you can STILL ACT AS IF you were doing that through a function "boom :: String -> Results", but let Haskell's laziness do the buffering for you so you're not loading the whole damn thing into memory.
12:51:24 <hsk4> Am I right?
12:51:41 <hsk4> Whereas in other languages you'd have to write a function for small buffers
12:51:48 <hsk4> instead of a function for the whole string
12:51:54 <geekosaur> that's the theory behind
12:51:56 <geekosaur> :t interact
12:51:57 <lambdabot> (String -> String) -> IO ()
12:52:10 <geekosaur> and lazy I/O. but lazy I/O has its problems as well
12:52:12 <Lokathor> not that some IO is lazy and some is strict, you have to be sure you're using the right functions
12:52:20 <RGamma> Can someone explain to me what is wrong with: ((1/) . (-))? I my thinking that should take two Doubles, calculate the difference and then calculating the inverse. It also typechecks but I can't use it: ((1/) . (-)) 5.4 1.3
12:52:28 <RGamma> (gives No instance for (Fractional (a0 -> a0)) arising from a use of ‘it’...)
12:52:32 <jle`> hsk4: it's actually somewhat unrelated to haskell
12:52:34 <merijn> maerwald: neovim is trying to refactor vim into something hackable
12:52:47 <SrPx> How do I add a type annotation to a let function inside a do loop?
12:52:51 <hsk4> jle`: how'd you do it in something like c?
12:52:52 <Lokathor> note*
12:52:53 <geekosaur> :t (1/) . (-)
12:52:55 <lambdabot> (Fractional (a -> a), Num a) => a -> a -> a
12:52:57 <SrPx> inside a do statement *
12:52:59 <maerwald> merijn: but now emacs plugin API :P
12:52:59 <jle`> hsk4: laziness in haskell refers to *evaluation*, not in IO actions
12:53:01 <merijn> hsk4: Yes, you can do that, but it turns out that has some problems for production code
12:53:03 <maerwald> s/now/no/
12:53:31 <geekosaur> RGamma: the problem is that (-) consumes one value, producing a function
12:53:35 <geekosaur> not two values
12:53:36 <Lokathor> SrPx, you can put :: Type after a line like normal
12:53:36 <hsk4> hmm ok
12:53:47 <merijn> hsk4: The problem you get from that, for example, is that you can't close the filedescriptor until the entire file has been read or the lazy value garbage collected
12:53:48 <jle`> hsk4: IO actions can be performed lazily (only read things in files when we need it), but laziness in haskell itself refers to deferring evaluation, not IO
12:53:48 <tempname11_> RGamma: (.) composes two functions by treating them as having one argument
12:53:51 <Lokathor> eg, let a = foo (bar z) :: Maybe Int
12:54:03 <merijn> hsk4: There's some pretty nice streaming libraries that have been written to work around that, though
12:54:14 <merijn> pipes and conduits are the most famous two
12:54:31 <tempname11_> so it consumes one value like geekosaur said
12:54:33 <jle`> hsk4: actually IO is lazy by default so you get the sort of buffering thing you suggest by default...but as mentioned here, it actually ends up being a bad idea when you actually want to use it for real things
12:54:36 <SrPx> No, but I want to annotate the type of the function, "let a b = a + b :: Float → Float → Float" (I want that because Haskell isn't compiling because it can't determine "a" is a Float and it asks me to add a (Conjugate a) instance to the type)
12:54:41 <jle`> it was a cute idea though :)
12:55:06 <merijn> hsk4, jle`: It actually works very well for simple cases. Just not for more complex ones
12:55:07 <hsk4> jle`: ok so I do have to handle the buffering myself. So, instead of writing a boom function for the whole enchilada, I'd write a partialBoom function?
12:55:32 <tempname11_> :t (-) `on` (1/)
12:55:34 <lambdabot> Fractional c => c -> c -> c
12:55:34 <merijn> hsk4, jle`: i.e. implementing your own cat/less/etc. would work, but for a server/daemon not so much
12:55:46 <hsk4> and then repeatedly call partialBoom in a state monad?
12:55:54 <Lokathor> SrPx you should be able to do that too
12:55:57 <jle`> hsk4: you can write boom over a stream
12:56:00 <jle`> using pipes or conduit
12:56:10 <tempname11_> > (-) `on` (1/) $ 12 10
12:56:11 <lambdabot>      Precedence parsing error
12:56:12 <lambdabot>          cannot mix ‘on’ [infixl 0] and ‘$’ [infixr 0] in the same infix expr...
12:56:12 <geekosaur> SrPx: aside from the apparent typo there (let a b = a + b, really? a is both Num and function?), the type annotation there is on (a + b) so would just be Float
12:56:15 <RGamma> tempname11_, geekosaur: I see, thanks
12:56:17 <tempname11_> oops
12:56:24 <geekosaur> but that is sufficiert to infer the correct tyope
12:56:25 <merijn> hsk4: You probably wanna look at pipes/conduits where you can treat input as a stream of elements and process them in constant memory without doing your own buffering
12:56:31 <tempname11_> > ((-) `on` (1/)) 12 10
12:56:32 <lambdabot>  -1.6666666666666677e-2
12:56:36 <RGamma> tempname11_, geekosaur: My program is working now
12:56:38 <hsk4> ok, thanks
12:56:39 <SrPx> geekosaur: woops. f a b *
12:56:45 <tempname11_> hm, that's not right
12:56:53 <tempname11_> disregard that :)
12:57:00 <tempname11_> wrong order
12:57:01 <geekosaur> let f :: Float -> Float -> Float; f a b = ...
12:57:11 <geekosaur> or let f a b = a + b :: Float
12:57:41 <hsk4> merijn: what would be wrong with the readFile ByteString function? That's buffered.
12:57:41 <SrPx> Ah, that worked. Thank you :)
12:57:49 <SrPx>     let loop :: Float -> Float -> IO (); loop inc roll = do <lot of lines>
12:57:50 <geekosaur> the latter working because the scope of the type annotation is (a + b)
12:58:27 <merijn> hsk4: That works, but you don't have control over when the file descriptor gets closed
12:58:47 <hsk4> merijn: why do i need that..
12:58:50 <merijn> hsk4: Since file descriptors are a limited resource, this is a problem in server processes, since they might run out of file descriptors
12:58:55 <hsk4> ah ok
12:59:04 <merijn> hsk4: There's a hard kernel limit on the number of files a process can have open
12:59:18 <hsk4> merijn: so you'd rather read a chunk, close, read a chunk, close, etc.?
12:59:31 <hsk4> until EOF
13:00:03 <merijn> hsk4: No, that's wasteful. But the problem is that with readFile the descriptor doesn't get closed until you reach the end of the file
13:00:04 <jle`> no, i'd rather have an abstraction that handles that in a meaningful way :)
13:00:22 <RGamma> tempname11_, geekosaur: That `on` thing doesn't quite do what I want, but at least I know what the problem is now. I canfigure out the rest myself
13:00:33 <jle`> that doesn't make me manually d that, but rather abstracts over it in a way that gives guaruntees, the ability to reason with it, etc.
13:00:36 <jle`> instead of being invisible magic
13:00:37 <merijn> hsk4: Now consider 'BS.take 100 <$> readFile "foo"' <- this never hits end of file if "foo" is more than 100 bytes
13:00:50 <merijn> hsk4: And the file won't be closed until that internal BS gets GCed
13:00:55 <jle`> (ie, pipes/conduit)
13:01:00 <tempname11_> RGamma: yeah, 'on' is wrong. you actually need (.).(.), but this obfusctes code more than it helps
13:01:06 <merijn> If the GC takes a long time since the BS is in a long term cache, you'll never close it
13:01:16 <hsk4> oh
13:01:52 <geekosaur> yeh, lazy I/O is full of gotchas like that
13:01:54 <jmcarthur> :t 1 / (-)
13:01:55 <lambdabot> (Fractional (a -> a -> a), Num a) => a -> a -> a
13:01:58 <jmcarthur> meh
13:02:07 <geekosaur> and you never find out about read errors because they just manifest as end of string
13:02:08 <merijn> RGamma: Whenever you see anything like "No instance Floating/Num" with a function type after the Floating/Num, be very suspicious ;)
13:02:26 <merijn> Or "Fractional (a -> a -> a)" :p
13:02:34 <jle`> but the great thing is that we don't have to handle every minute aspect of IO manually...and you don't have to surrender to magic that's under the whim of compiler and unpredictable in your haskell code
13:02:37 <jmcarthur> lambdabot used to have NumInstances
13:02:51 <RGamma> I can also just write \x y -> 1 / (x-y)
13:02:52 <geekosaur> yes, and there's a reason it doesn't any more :)
13:02:56 <jle`> you can use abstractions that let you reason with IO within your code in a way that makes sense
13:03:04 <jmcarthur> yeah, somebody got confused
13:03:08 <jle`> and gives you guaruntees you can take advantage of and use
13:03:18 <tempname11_> RGamma: yes! most sensible decision :)
13:03:23 <jmcarthur> i like NumInstances though
13:03:56 <geekosaur> function instances for Num are a license for ghc to perform type inference that most people find bizarre and unexpected
13:03:58 <hsk4> What's the best pipes/conduit tutorial? LYAH didn't cover it
13:04:15 <hsk4> and maybe i shouldn't worry about it if all I have is at most a bunch of files?
13:04:19 <hsk4> like 20 files or so
13:04:19 <tempname11_> ugh, why would anyone need NumINstances?
13:04:29 <jmcarthur> function instances for any type class are that way, be we don't ban them all
13:04:29 <geekosaur> which is kinda bad when a newcomer to Haskell is trying to demonstrate a problem and gets something even more unexpected than usual
13:04:36 <jmcarthur> *but we
13:04:48 <jmcarthur> @instances Monad
13:04:50 <lambdabot> Alt f, ExceptT e m, First, Gen, IO, Identity, Last, Maybe, Proxy, ReaderT r m, Seq.Seq, StateT s m, Tree, WrappedMonad m, []
13:04:56 <jle`> the tutorial in the pipes documentation is pretty good :) also fpcomplete and snoyberg have great conduits introductions
13:05:09 <jmcarthur> huh, i thought the unwrapped reader instance was there by default
13:05:30 <jmcarthur> :t join (+)
13:05:31 <hsk4> jle`: this? https://hackage.haskell.org/package/pipes-4.1.5/docs/Pipes-Tutorial.html
13:05:32 <lambdabot> Num a => a -> a
13:05:38 <jmcarthur> well, it's there
13:05:55 <jle`> mhm :) gabriel tries really really really hard to make it as accessible as possible
13:06:06 <jle`> but if you're only doing a toy project lazy IO should be okay as long as you know why it's not
13:06:12 <jle`> :)
13:06:22 <tempname11_> jmcarthur: wow
13:06:31 <jle`> for any serious application i would be a bit more careful
13:06:44 <merijn> hsk4: Also, Tekmo is really helpful on the pipes mailing list if you are confused by anything in the tutorial
13:06:45 <Haskellfant> pipes probably has the best documentation that I've seen on hackage so far
13:07:05 <jle`> tekmo is the gold standard to which we compare our documentation to
13:07:05 <merijn> Last time he spend 1.5 hours explaining possible solutions to me on IRC when I had a problem with pipes-parse...
13:11:04 <quchen> He's not around here that much anymore though :-/
13:11:24 <quchen> But on the other hand I'll meet him in a month in person, so I'll just collect all questions and then nag him face to face ;-)
13:11:57 <Lokathor> codewars won't accept my answer because it runs too slow :/
13:13:46 * hackagebot lambda-options 0.4.0.0 - A modern command-line parser for Haskell.  http://hackage.haskell.org/package/lambda-options-0.4.0.0 (ThomasEding)
13:16:05 <lpaste> Lokathor pasted “Slow Code” at http://lpaste.net/132762
13:16:30 <Lokathor> well if anyone knows how to do math trick stuff to speed things up, i'm pretty bad at that and would apprectiate the help
13:17:08 <merijn> quchen: He's only around if he has his own questions
13:17:18 <merijn> quchen: And then he hangs around for a while to answer other people's
13:17:34 <merijn> But he's specifically joined here to give in person feedback over mailing list answers, so
13:17:57 <quchen> "tekmo@mail.com please join IRC I have a question"
13:19:42 <tempname11_> Lokathor: maybe use logarithm in line 11 instead of a div?
13:21:17 <tempname11_> actually if I'm not missing anything, that line is kind of unnecessary, because only one element of that list will ever be 'right'
13:21:37 <tempname11_> so you can just calculate pow
13:21:57 <Lokathor> can you?
13:23:13 <ajf> what's the equivalent of otherwise in a case expression?
13:23:23 <Lokathor> _
13:23:27 <ajf> hmm
13:23:33 <Lokathor> or a var if you want to keep the value
13:23:40 <SrPx> What is the most linguistic and performant way to generate all 2D vectors inside the square x = -2 .. 2, y = -2 .. 2 ? Do you use list comprehensions [V2 x y | x <- [-2..2], y <- [-2..2]], or the applicative `V2 <$> [0..2] <*> [0..2]` or what?
13:24:23 <jle`> i like the applicative way, or liftA2 V2 [0..2] [0..2]
13:24:33 <jle`> list comprehension seems unnecessarily verbose
13:24:44 <SrPx> But will GHC optimize?
13:24:49 <jle`> i'm not sure what you mean by 'linguistic'
13:24:56 <SrPx> Idiomatic*
13:24:59 <tempname11_> heh, when I started out I wrote "case of... otherwise -> ..." and it worked, but then I noticed the warning :)
13:24:59 <jle`> what sort of optimization are you expecting?
13:25:19 <RGamma> tempname11_: As a quick followup: Why is it possible to e.g. infer the type ((1-) . (+)) 1 1 :: (Num (a -> a), Num a) => a, but one can't actually evaluate that function? It seems that this kind of type mismatch should be caught earlier
13:25:57 <SrPx> I would like it to optimize (sum (map f (V2 <$> [-2..2] <*> [-2..2]))) to a tight loop :)
13:26:03 <SrPx> wanting too much?
13:26:58 <tempname11_> RGamma: you actually can if you make in instance of Num for functions. i.e. the package NumInstances does that. but that's nasty and best avoided
13:27:05 <jle`> i think that'd more or less be the same as sum (map f [V2 (-2) (-2), V2 (-2) (-1) ... ])
13:27:15 <jle`> which is subject to fusion
13:27:34 <geekosaur> RGamma, note that instances are global, so if you do that in a library, it can never be sure some future user of that library won't have such an instance in scope
13:27:44 <SrPx> You mean manually writing the positions will help the performance?
13:27:54 <jle`> no, i'm saying, obth of your methods are equivalent
13:27:57 <jle`> to whatever that would be
13:28:00 <SrPx> Ah alright
13:28:06 <SrPx> cool
13:28:11 <jle`> and that's subject to fusion
13:28:27 <tempname11_> SrPx: your best bet would be to look at the 'core' ghc actually generates
13:28:39 <tempname11_> you don't have to guess
13:28:52 <SrPx> Good idea tempname11_ , thanks
13:28:55 <geekosaur> and because you can't actually describe the intent of various typeclasses *in* Haskell, even with extensions, it can't know that (for example) there will never be a type that is both Fractional and Integral
13:29:03 <jle`> i would think that it keeps a strict accumulator and eats up V2's it sees as it generates them across the grid
13:29:10 <jle`> but yeah, check it out to see in case.
13:29:24 <jle`> also consider that it might not be a bottleneck, if you haven't benchmarked yet
13:29:47 <geekosaur> (I think you could define them that way in Agda though; it has a stronger type system,. but that strength comes with other costs.)
13:29:54 <lpaste> marmalodak pasted “zeromq4 haskell” at http://lpaste.net/132763
13:30:35 <marmalodak> ihaskell won't install for me, looking for some help
13:30:50 <marmalodak> zeromq4 seems to build just fine but ihaskell doesn't like it
13:31:03 <marmalodak> brand new to haskell, wanted to try it out on my python notebook set up
13:31:44 <tempname11_> Haskell could have a "forbid instance" declaration. i.e. "forbid instance Fractional a => Integral a" or "forbid instance Num (a -> b)"
13:31:52 <tempname11_> would be good for usabllity
13:31:54 <RGamma> geekosaur: Mhh, so it infers that in above expression there needs to be a Num instance for a -> a, but there isn't and ghc still doesn't complain at that stage. How is this case different from e.g. 1 + "bla" where there clearly is no instance for Num [Char] either (and it doesn't typecheck
13:31:58 <tempname11_> but that's just my musings
13:32:15 <geekosaur> marmalodak, you need to set PKG_CONFIG_PATH so pkg-config will see the .pc file installed in a nonstandard location
13:32:38 <geekosaur> /e2e/lib/zeromq4/lib/pkgconfig/libzmq.pc
13:32:50 <tempname11_> actually, what's the best way to propose that to ghc developers?
13:33:13 <marmalodak> geekosaur: you're saying that I need an environment variable like PKG_CONFIG_PATH=/e2e/lib/zeromq4/lib/okgconfig/libzmq.pc?
13:33:53 <geekosaur> more like PKG_CONFIG_PATH=/e2e/lib/zeromq4/lib/pkgconfig:/usr/share/lib/pkgconfig:/usr/lib/pkgconfig
13:33:58 <geekosaur> possibly other directories as well
13:34:14 <jle`> RGamma: the a -> a instancce requirement is saying that, "this function works for any a, where a -> a is a Num instance".  so 'there's no a -> a instance' isn't the problem
13:34:49 <jle`> RGamma: there might not be an a -> a instance, but there might be an Int -> Int instance, or a (String -> Double) -> (String -> Double) instance
13:35:05 <jle`> it's not looking for an "a -> a" instance
13:35:11 <geekosaur> RGamma, try that one with the OverloadedStrings extension enabled
13:35:17 <jle`> it's saying, "this will work for any `a`, as long as that a has a Num instance for a -> a"
13:35:38 <arbelos> If I register on FPComplete and use their IDE, can I make projects visible from "outside"? For someone to be able to view the code without registering. And is it free to use the IDE? Does anyone know?
13:36:13 <RGamma> geekosaur: "1 + "bla" :: (Data.String.IsString a, Num a) => a" Interesting
13:36:36 <geekosaur> yep. it can't check any more because string literals are now polymorphic
13:36:38 <jle`> when it does try to evaluate your function, it'll look for all instances in scope...which might be other instances than just the one in your program or library
13:37:17 <geekosaur> this is very powerful but also very confusing for newcomers
13:37:37 <geekosaur> but it allows you to write things that will work for types you never imagined while writing it
13:37:50 <tempname11_> what do you guys think of my "forbid instance" idea?
13:37:51 <geekosaur> as long as someone can create the appropriate instances
13:38:18 <geekosaur> tempname11_, there aren't many cases where you can unequivocally forbid an instance
13:38:42 <RGamma> Alright thanks guys, learned something useful today :)
13:39:38 <dmiles> i cant seem to remember when convert decription logic to horn clauses how i got rid of  box and diamond operators
13:39:46 <merijn> Hmmm
13:40:06 <merijn> Is there an lmap for tuples somewhere in base so that I don't have to add a dependency on bifunctors?
13:40:42 <radens> Let's say I have a function f _ = 1. Why do I need to preface it with let in ghci but I don't when just putting it in test.hs?
13:40:51 <jle`> merijn: do you mean `left` ?
13:40:56 <jle`> lmap is from profunctors
13:40:59 <dmwit> ?let isMountainOrValley = (2==) . length . group . ap (zipWith (<)) tail
13:40:59 <dmiles> shouuld i move box and dimand close to the litterals as poissible?
13:41:00 <lambdabot>  Defined.
13:41:16 <merijn> ah
13:41:20 <tempname11_> geekosaur: but those few cases where you can, would improve the readability of the type-check errors like those discussed above
13:41:23 <merijn> I mean "first" from Arrow :)
13:41:28 <jle`> er yeah, i meant first, heh
13:41:29 <dmwit> > map isMountainOrValley [[1,2,3,4,5,6,3,2,1], [4,3,2,1,1,2,3,4], [1,2,3], [1,2,3,2,1,2,3]]
13:41:31 <lambdabot>  [True,True,False,False]
13:41:48 <jle`> by the way, bifunctors is in base 4.8
13:41:56 <jle`> so you don't need to add a dependency if you're on 7.10+
13:42:20 <jle`> ^^ merijn 
13:42:25 <radens> ?f _ = 1
13:42:25 <lambdabot> Maybe you meant: faq farber flush foldoc forget fortune free freshname v bf @ ? .
13:42:32 <radens> ?let f _ = 1
13:42:33 <lambdabot>  Defined.
13:42:41 <radens> ?f
13:42:41 <lambdabot> Maybe you meant: faq farber flush foldoc forget fortune free freshname v bf @ ? .
13:43:03 <dmwit> > f 3
13:43:04 <lambdabot>      Ambiguous occurrence ‘f’
13:43:04 <lambdabot>      It could refer to either ‘L.f’, defined at L.hs:150:1
13:43:04 <lambdabot>                            or ‘Debug.SimpleReflect.f’,
13:43:09 <dmwit> > L.f 3
13:43:10 <lambdabot>  1
13:43:47 <dmwit> > Debug.SimpleReflect.f (var "hi radens")
13:43:47 * hackagebot parconc-examples 0.3.5 - Examples to accompany the book "Parallel and Concurrent Programming in Haskell"  http://hackage.haskell.org/package/parconc-examples-0.3.5 (SimonMarlow)
13:43:48 <lambdabot>      No instance for (Show a0)
13:43:49 <lambdabot>        arising from a use of ‘show_M81127027078467532276516’
13:43:49 <lambdabot>      The type variable ‘a0’ is ambiguous
13:43:58 <dmwit> oh well =P
13:44:42 <radens> dmwit: thanks. Why do I need to put let for lambdabot to work, but I don't need to in some test.hs file?
13:45:03 <jle`>  @let is a lambdabot command
13:45:09 <jle`> like @where, @tell
13:45:20 <jle`> @slap fish
13:45:20 <lambdabot> I don't perform such side effects on command!
13:45:51 <radens> Okay, why don't I need let in ghci then, jle` ?
13:46:32 <geekosaur> you need let in ghci
13:46:32 <jle`> i think you do need it to declare functions and values...
13:46:43 <geekosaur> top level in a program is different
13:46:58 <geekosaur> ghci is a desk calculator of sorts, not a source file being compiled
13:47:09 <radens> Sorry, I misspoke. How is top level in the program different? Is it just a different scope?
13:47:20 <geekosaur> you'd be somewhat annoyed if ghci forced you to import eveyrhting beforehand, for example
13:47:33 <radens> If so, how do I achieve that same scope in some program?
13:47:38 <marmalodak> geekosaur: this allowed me to make progress, but a different error occurred
13:47:49 <jle`> at the top level, a haskell file is just a bunch of declarations
13:48:00 <jle`> (top as in, under the 'module Blah where...')
13:48:16 <geekosaur> marmalodak, I am wondering if you are used to dynamic languages
13:48:37 <radens> Where else can I actually use let in a program?
13:48:48 * hackagebot lambda-options 0.4.0.1 - A modern command-line parser for Haskell.  http://hackage.haskell.org/package/lambda-options-0.4.0.1 (ThomasEding)
13:48:48 <lpaste> marmalodak pasted “src/IHaskell/Eval/Evaluate.hs:404:16:” at http://lpaste.net/132766
13:48:58 <geekosaur> whoops, wrong user
13:49:06 <geekosaur> radens, I am wondering if you are used to dynamic languages
13:49:14 <marmalodak> geekosaur: I have some experience with Python
13:49:20 <marmalodak> geekosaur: does that count?
13:49:24 <geekosaur> right, a dynamic language
13:49:37 <geekosaur> what I meant more was, have you worked with C / C++ / Java?
13:49:43 <radens> geekosaur: well yes, I use python quite a bit. I actually get how let works in, say, rust.
13:49:48 <marmalodak> not in years
13:49:54 <radens> I regularly work with C and Go.
13:50:13 <marmalodak> back in my prime, I thought of myself as a C guy, ansi x3j11 and pre ansi
13:50:17 <marmalodak> gosh, I'm old
13:50:28 <jle`> radens: one syntax consturct that uses 'let' is `let ... in ...`, which is expression syntax
13:50:30 <geekosaur> tell me about old :p
13:50:37 <orion> marmalodak: How old are you?
13:50:48 <jle`> (let x = 3 in x) is an expression...so you can use it anywhere you use any other expression
13:50:57 <marmalodak> orion: old enought to know better, young enough to do it again :-)
13:51:00 <jle`> expressions are things like "hello", 4, 5 + 4, map succ [1,2,3]
13:51:19 <marmalodak> orion: late 40s 
13:51:21 <ajf> Yo, Haskell wizards (and wizardesses, and neither) - what'd be a nicer way to format this function? http://stackoverflow.com/questions/30278850/raycaster-displays-phantom-perpendicular-wall-faces/30280588#30280588 (see the final code block, that's the code I have now and want to prettify)
13:51:25 <jle`> anywhere you could put '4', you can put 'let x = 4 in x'
13:51:34 <geekosaur> marmalodak, this looks like something is using http://hackage.haskell.org/package/filepath/docs/System-FilePath.html and trying to treat its FilePath as the standard FIlePath
13:51:44 <geekosaur> I don't know what is doing it so don't know how to fix it
13:52:02 <jle`> the 'let' keyword is also used in a not-directly-related syntax construct called 'do notation'
13:52:10 <marmalodak> geekosaur: I'm trying to follow this guide: https://github.com/gibiansky/IHaskell/tree/44ebe75c0c6c69c6a48bf73094c349c0fe1a0d88
13:52:25 <marmalodak> Is there anywhere else I should try to get help installing ihaskell?
13:52:56 <geekosaur> I think you'll have to ask on there. (I note that github says "build failing" so this is likely to be a known issue...)
13:53:49 <radens> jle`: so I can use let in my main function with do notation. 
13:54:19 <geekosaur> marmalodak, email andrew.gibiansky@gmail.com
13:54:36 <marmalodak> geekosaur:ok
13:54:41 <marmalodak> thanks for the help
13:55:05 <geekosaur> I presume he is in the process of reworking that and it's not going to typecheck until he's finished
13:55:12 <codesoup> is there any convention for naming intermediate calculations/states? i.e. right now i have foo x = res where { zipped = zip ...; mapped = map ...; foobared = f ...; res = ...}
13:55:13 <geekosaur> although nirmally you don;t commit in that state >.>
13:55:19 <radens> I guess my problem is a lot more general than this. When I sit down to read a haskell book they show me all these great things I can do in ghci. Well ghci is great for trying things out, but if I want to actually write code I need to know how to write code outside of ghci.
13:55:27 <ajf> Can you do conditional assignment to two variables based on the value of another variable, without repeating the condition or the body?
13:56:00 <Big_G> I have a question about if Haskell is a good option for prod in one of my programs. Is this the channel to ask questions?
13:56:11 <tempname11_> ajf: (a, b) = if c then ... else ...     ?
13:56:17 <quchen> ajf: Sure, let (a,b) = if p then (foo,bar) else (qux, arf)
13:56:27 <geekosaur> > let x = 5; y = 6 in let (a,b) = if x == y then (1,2) else (3,4) in a
13:56:28 <lambdabot>  3
13:56:31 <merijn> Big_G: You could ask here, but there's a high likely hood of getting yes as answer :p
13:56:36 <exio4> you can use a guard
13:56:37 <merijn> Ugh!
13:56:41 <merijn> exio4++
13:56:52 <exio4> > let (a,b) | True = (1,2) in (a,b) 
13:56:53 <lambdabot>  (1,2)
13:57:02 <ajf> Like, uh, let me explain it a bit better
13:57:04 <Big_G> merijn, I'd expect nothing less
13:57:04 <ajf> http://lpaste.net/7726596618761273344
13:57:04 <merijn> "let (a, b) | p = (foo, bar)\n| otherwise = (qux, arf)"
13:57:08 <ajf> This is what I have now
13:57:26 <ajf> Can I share that case expression (the arr ! newTile of Empty -> ...) bit?
13:57:33 <marmalodak> geekosaur: why did you ask me about dynamic languages?
13:57:40 <geekosaur> marmalodak, misaim
13:57:41 <ajf> I suppose I could make that into a function, but it doesn't really make sense as its own separate thing
13:58:02 <merijn> ajf: Use a where clause?
13:58:16 <merijn> ajf: In general I'd rewrite that using where clauses :p
13:58:30 <ajf> how would that work?
13:58:41 <Big_G> We're going with a service oriented architecture. We'll be creating mircoservies that will only be accessible through the REST APIs they put out. Current systems are written in C# and Java. It has to run on all likely systems (Windows, Mac, Linux, Docker, etc.) Is Haskell the right tool for the job?
13:58:50 <ajf> does the order the variables are defined not matter?
13:59:10 <geekosaur> not generally
13:59:15 <ajf> hmm
13:59:26 <geekosaur> this does mean you need to watch out not to accidentally introduce recursion
13:59:34 <Big_G> merijn, That clear enough?
13:59:47 <exio4> as long as you don't shadow variables, you'll be fine
13:59:51 <geekosaur> > let a = b; b = a in b -- boom
13:59:53 <exio4> (a,b) | even a = (b,a) 
13:59:55 <lambdabot>  mueval-core: Time limit exceeded
14:00:41 <tempname11_> ajf: is the problem that both sides of the outer 'case' are very similar? do you want to reduce them to one and avoid code duplication?
14:01:05 <ajf> tempname11_: I don't want to have to duplicate that inner case part
14:01:16 <radens> Okay, here is another question about scope in ghci. I type this: let x = 1; Then I type this: let x = 5; y = 6 in y Then I type this: x. Why is x 1, not 5?
14:01:17 <ajf> the case arr ! newTile bit
14:01:20 <ajf> since it's always the same
14:01:43 <ajf> and, if possible, it probably be better not to have case hitSide of twice
14:01:57 <lpaste> merijn annotated “No title” with “Whoo, refactoring!” at http://lpaste.net/7726596618761273344#a132767
14:02:06 <merijn> ajf: Take a look at that one?
14:02:39 <ajf> merijn: ooh
14:02:39 <merijn> Big_G: I say, writing concurrent servers, cross-platform haskell is always a good contender
14:02:46 <kuribas> Is there an efficient way to calculate this?  http://mathb.in/35974
14:02:55 <ajf> That repeats eastWest/otherwise a lot, but that's pretty good
14:03:17 <merijn> ajf: Yeah, you could try and do that different, but it'd likely be messier
14:03:24 <merijn> ajf: I prefer a little repetition over mess
14:03:29 <ajf> Sure
14:03:36 <ajf> I'm doing something similar, I think
14:03:38 <merijn> ajf: You could make it a tuple, but then all the definitions go on one line
14:03:39 <ajf> but with case clauses
14:03:44 <tempname11_> merijn: cool style. I'll use this in my code for sure!
14:03:47 <ajf> because eastWest/otherwise looks... wrong to me
14:04:15 <ajf> I think EastWest/NorthSouth is clearer
14:04:45 <merijn> ajf: Yeah, you could use PatternGuards, but I was too lazy to check whether those were Haskell2010 and what their syntax was :p
14:04:50 <monochrom> kuribas: at first sight, it looks related to linear regression. but I am half-blind-guessing.
14:05:09 <ajf> merijn: Nah, not patternguards, I mean = case hitSide of
14:05:11 <radens> Okay, here is another question about scope in ghci. I type this: let x = 1; Then I type this: let x = 5; y = 6 in y Then I type this: x. Why is x 1, not 5? geekosaur maybe you can answer my question?
14:05:23 <monochrom> perhaps it is not related to linear regression afterall because linear regression minimizes a square rather than a max
14:05:25 <merijn> ajf: Yeah, that'd work too
14:05:26 <tempname11_> ajf: just a moment...
14:05:40 <merijn> radens: You're defining a new x
14:05:55 <radens> well obviously. How do I know that though?
14:05:58 <noodles1> radens: people aren't answering because your question shows that you haven't bothered to read more than a few paragraphs about haskell
14:06:01 <monochrom> math is too hard!
14:06:19 <radens> noodles1: thank you for your help
14:06:25 <merijn> radens: That translates too (roughly) "let x = 1 in ...future lines go here..."
14:06:34 <kuribas> monochrom: yes, the least squares solution is pretty simple, but this one if it is solvable would be better.
14:06:37 <geekosaur> radens, because the let ... in is local
14:06:51 <kuribas> monochrom: Because it would minimize the error, rather than the sum of squares of the error.
14:07:01 <geekosaur> radens, the scope of the bindings before "in" is the expression after "in", and no more
14:07:03 <merijn> noodles1: So whenever you type "let x..." in ghci that introduces a new scope for the remaining session
14:07:07 <noodles1> radens: http://learnyouahaskell.com/
14:07:10 <merijn> geekosaur: Not in ghci
14:07:22 <ajf> merijn: how do I do the thing where you add another code block to the bottom of the paste with its own title?
14:07:29 <ajf> Like you did for "Whoo, refactoring!"
14:07:29 <monochrom> hmm, linear regression except that we use the 1-norm or the oo-norm (I forgot which), not the 2-norm
14:07:30 <merijn> geekosaur: He's saying that writing "let" multiple times results in you getting the last result
14:07:34 <merijn> ajf: Click annotate
14:07:39 <merijn> geekosaur: (in ghci)
14:07:57 <merijn> radens: The shortest answer is "ghci is a bit special and not like regular source files"
14:07:57 <ajf> Aha
14:07:58 <kuribas> monochrom: oo-norm I think
14:07:59 <ajf> http://lpaste.net/7726596618761273344
14:08:01 <ajf> This is what I did
14:08:03 <ajf> :)
14:08:33 <monochrom> where is copumpkin? he's supposed to show up now and say "oo nom nom"
14:08:38 <merijn> ajf: I prefer guards over if/then/else, but that's a style question
14:08:39 <radens> noodles1: I actually really don't like that book. It tells me how to run code in ghci for at least the first quarter of the book.
14:08:43 <marmalodak> fwiw, I filed this issue: https://github.com/gibiansky/IHaskell/issues/491
14:08:52 <ajf> merijn: oh, I should do that actually
14:08:58 <ajf> if/then/else isn't nice to read
14:09:08 <tempname11_> ajf: controversial, but even more succinct style: http://lpaste.net/7726596618761273344
14:09:09 <merijn> radens: This is a decent list of resources https://github.com/bitemyapp/learnhaskell
14:09:21 <radens> Thanks merijn 
14:10:15 <ajf> tempname11_: oh, that's brilliant :D
14:10:20 <Big_G> merijn, What about bringing other members of the team to it? Will there be any deployment issues? Will it be as easy as in a language like python?
14:10:56 <merijn> Big_G: I'd say there's probably a bit of a ramp to get started, but not substantially more so than many other languages
14:11:09 <ajf> tempname11_: Very succinct, and I might actually do something similar somewhere else in the code where I have a bunch of if/then/elses
14:11:15 <kuribas> I like version 3.
14:11:22 <tempname11_> ajf: could also factor out trailing sideDist and tile with a "$"
14:11:24 <merijn> Big_G: Facebook's current approach is to have a bunch of very skilled haskellers flesh out a framework that the beginner haskellers can then use and it seems to work well for them
14:11:42 <merijn> Big_G: Of course it depends on, how many programmers, how many know haskell, how interested are they in learning, etc.
14:11:44 <ajf> tempname11_: huh?
14:11:47 <Big_G> merijn, Keep in mind these are very corporate Java coders
14:11:57 <merijn> Big_G: Ah, see, that's a crucial detail :p
14:12:18 <tempname11_> newTile = choose (...) (...) $ tile
14:12:19 <merijn> Big_G: You could write something small and see how much issues they have with it?
14:12:19 <Big_G> merijn, Does Facebook do any Haskell beyond Haxl?
14:12:30 <tempname11_> oh, don't even need $
14:12:38 <merijn> Big_G: Haxl is expanding into more and more areas :)
14:12:41 <Big_G> merijn, That is the plan for the microservices. It seems like I'm the only one interested in learning
14:12:59 <Big_G> merijn, Very nice. I guess I'll have to start preparing a resume soon :)
14:13:00 <ajf> tempname11_: oh I see, yeah
14:13:01 <merijn> Big_G: bos' last post seems to imply almost all their spam detection and querying services have moved over to haskell
14:13:04 <ajf> The wonders of currying!
14:13:11 <ajf> Final version I'm going to use: http://lpaste.net/7726596618761273344#a3950442740549943296
14:13:16 <Big_G> Awesome!
14:13:27 <ajf> merijn will like that it has a guard
14:13:32 <merijn> \o/
14:13:37 <monochrom> Big_G: these two lectures may help your colleagues: http://www.slideshare.net/ScottWlaschin/fp-patterns-buildstufflt  https://docs.google.com/presentation/d/1a4GvI0dbL8sfAlnTUwVxhq4_j-QiDlz02_t0XZJXnzY/preview?sle=true&slide=id.p
14:14:08 <ajf> But that choose trick is brilliant, I think I'll use that to refactor the outer function, traceRay
14:14:20 <Big_G> monochrom, Thanks. I'll definitely look those over. They're all such experts at Java that they probably don't want to touch anything else
14:14:39 <zacts> is OOP even possible in idiomatic Haskell? (Or how does one interface with an OOP library in another language - if this even makes logical sense)
14:14:51 <merijn> Big_G: I'd say that haskell excels at: high performance concurrent servers and streaming data processing, so I'd say it's certainly a good fit for like microservices
14:14:52 <ajf> it repeats `if dirX < 0 then ... else ...` four times
14:15:36 <Big_G> merijn, Would you say it is the best in the market?
14:15:53 <monochrom> zacts: an object is a record. (don't worry about class.) OOP is record-oriented programming. record is pretty idiomatic haskell, until you realize...
14:16:00 <merijn> Big_G: Although, it might require a fair bit of experience to make that scale to very large codebases, because then you'd wanna use libraries like pipes/conduits which aren't VERY beginner friendly
14:16:13 <zacts> monochrom: oh neat cool
14:16:16 <monochrom> therefore record-oriented programming misses out on sum types. missing out on sum types is not idiomatic haskell.
14:16:19 <merijn> Big_G: The world's fastest software defined networking router is written in haskell, so... ;)
14:16:20 <zacts> is a record analogous to a C struct?
14:16:33 <monochrom> yes
14:16:37 <zacts> ok cool
14:16:39 <merijn> Big_G: See http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
14:16:41 <zacts> thanks
14:16:54 <zacts> (just a question of curiosity more than anything)
14:16:55 <Big_G> merijn, What kind of scale would that be needed for? We don't have a ton of traffice now but will in the future. 
14:16:59 <zacts> anyway, bbl
14:17:00 <merijn> Big_G: That describes the new GHC IO manager and has some nice benchmarking figures
14:17:16 <ajf> Oh yeah, why can't you do a * $ if ... then ... else ...
14:17:21 <ajf> er
14:17:23 <ajf> I mean
14:17:29 <ajf> a * $ somefunc b c
14:17:48 <tempname11_> a * somefunc b c ?
14:17:57 <ajf> Oh, that works?
14:18:06 <ajf> Function application binds tighter than * does?
14:18:12 <tempname11_> of course
14:18:16 <tempname11_> it's the tightest
14:18:16 <ajf> ...of course it does, I'm silly
14:18:27 <ajf> I do * dbl foo somewhere else in the code
14:18:49 * hackagebot elm-init 0.1.1.0 - Set up basic structure for an elm project  http://hackage.haskell.org/package/elm-init-0.1.1.0 (justus)
14:18:49 <Big_G> merijn, Now comes the hard question. What framework do I use?
14:18:52 <merijn> Big_G: It's not so much a scale as in traffic, but scale as in code maintainability. There's lots of very nicely composable/modular libraries for things like streaming, etc. but they assume you're fairly comfortable with "production haskell" abstractions like monad transformers, which can be a bit of a learning curve if you're completely new to haskell
14:19:26 <Big_G> I think the point of microservices is that we won't need those
14:19:45 <merijn> Big_G: I'm not big on the framework and web stuff, but some stuff to look into/keep in mind would be async (for async operations), wai (the webapp server) and pipes/conduit (for streaming data processing)
14:20:02 <tmtwd>   mapM putStrLn args 
14:20:11 <tmtwd> what is the mapM in that line of code?
14:20:19 <ajf> Hmm
14:20:33 <merijn> mapM :: Monad m => (a -> m b) -> [a] -> m [b]
14:20:37 <ajf> I did choose a b somewhere else, but it didn't look good. Poor tempname11_. Let's see how guards fare.
14:20:47 <tmtwd> ok
14:21:00 <dfeuer> mapM = traverse
14:21:06 <tmtwd> how do I access a list element by index?
14:21:15 <dfeuer> tmtwd, you do it slowly.
14:21:15 <tmtwd> ie args is a list
14:21:26 <dfeuer> There's a !! operator, but it's  partial.
14:21:29 <monochrom> list !! n
14:21:36 <tmtwd> I tried args[2] but that didn't work
14:21:59 <dfeuer> That's because args[2] means the *function* args applied to the *list* [2].
14:22:04 <dfeuer> Which is not what you have at all.
14:23:46 <dfeuer> tmtwd, I think it best to ask why you want that. Accessing lists in such a fashion is generally slow.
14:24:02 <dfeuer> If you need random access, there are other structures you can use.
14:24:20 <tmtwd> Change the program so it reads two arguments from the command line, and prints out a message using both of them
14:24:25 <Big_G> merijn, Any other channels I should check out for this kind of project?
14:24:30 <tmtwd> trying to do this exercise
14:25:17 <tempname11_> tmtwd: just pattern match the args... much better then doing (!!)
14:25:17 <ajf> Oh, now I see the use of bifunctor map
14:25:57 <tmtwd> how do I do that exactly?
14:26:02 <dfeuer> tmtwd, what tempname11_ said. That will also give you a good way to deal with errors like missing arguments.
14:26:35 <dfeuer> There are various ways.
14:26:49 <tempname11_> case args of [a b] -> frobnicate a b; _ -> error "please supply two arguments"
14:26:58 <tempname11_> [a, b]
14:27:00 <tempname11_> (type)
14:27:03 <tempname11_> (typo_
14:27:05 <tempname11_> typo)
14:27:06 <dfeuer> tempname11_, that's a bogus use of error!
14:27:09 <tempname11_> damn
14:27:26 <tempname11_> throwIO
14:27:31 <tempname11_> ?
14:27:42 <dfeuer> That's fine,
14:27:57 <dfeuer> or at the top level, just print an error message instead of frobnicating.
14:28:12 <JoshieAS> Man, I'm having trouble understanding hw10 in cis194
14:28:35 <JoshieAS> I don't even know where to begin trying to write a Functor instance for my Parser data type
14:29:09 <tempname11_> dfeuer: yep. good point. I think I'm just tired :)
14:29:51 <ajf> lpaste so slow :(
14:30:07 <ajf> is it written in Haskell? /ducks
14:30:49 <monochrom> yes, it is :)
14:31:32 <refefer> any ideas on how to capture keycodes like arrow keys using haskeline?
14:31:40 <andreasd> What tutorial did you use to get familiar with Haskell?
14:32:00 <tolt> ajf, I don't think the problem is the language choice. It seems like something is wrong with the server
14:32:07 <tempname11_> andreasd: learnyouahaskell.com
14:32:12 <ajf> tolt: yes, I realise
14:32:17 <tolt> oh. alright.
14:32:22 <tempname11_> most approachable and non-scary, even if lacking in some regards
14:32:22 <ajf> It was a self-deprecating joke :p
14:32:29 <zacts> https://github.com/bitemyapp/learnhaskell
14:32:35 <andreasd> tempname11: It's the one I use now.
14:32:35 <zacts> ^ isn't this also recommended for learning haskell?
14:33:05 <zacts> (as I'm following this path - as it's in /topic of #haskell-beginners)
14:33:45 <tmtwd> what is frobnicate?
14:33:49 * hackagebot elm-init 0.1.1.1 - Set up basic structure for an elm project  http://hackage.haskell.org/package/elm-init-0.1.1.1 (justus)
14:34:13 <Hijiri> zacts: I would recommend that one over LYAH
14:34:14 <tmtwd> what is mapM?
14:34:15 <tempname11_> tmtwd: placeholder to substitute your own code there :)
14:34:16 <ajf> is there a function like: tuplemap f (a, b) = (f a, f b) - like bimap, but using the same function twice?
14:34:27 <andreasd> What cool things have you done with Haskell?
14:34:28 <tempname11_> ajf: over both (Control.Lens)
14:34:29 <ajf> if there was, what would it be called, even if it doesn't exist
14:34:36 <zacts> Hijiri: oh cool
14:35:36 <andreasd> The only thing I know it is used for for is xMonad tiling windows manager. But I'm sure it's getting used for a ton of thing. I am just new to the whole purely functional programming world.
14:35:42 <Hijiri> there is pandoc
14:36:11 <ajf> tempname11_: how would I use it?
14:36:21 <tempname11_> over both f (a, b)
14:36:37 <ajf> Ah, neat
14:36:45 <ajf> Do I just need to import Control.Lens.Tuple?
14:36:49 <zacts> is there a good summary of really cool features of Haskell?
14:36:59 <zacts> I'm searching around for this
14:37:25 <ajf> step  = over both (choose -1 1) (dirX < 0, dirY < 0)
14:37:33 <ajf> I'm not sure if I should feel bad for that
14:37:47 <merijn> zacts: Laziness, purity, the ability to write very reusable/generic code in a modular way
14:37:51 <zacts> ok
14:38:04 <merijn> Oh, and types!
14:38:06 <tmtwd>   case args of [a b] -> putStr a
14:38:06 <tmtwd>                        putStr  b
14:38:09 <merijn> (that don't suck)
14:38:12 <andreasd> Hijiri: pandoc seems cool!
14:38:15 <tmtwd> i tried this, it didn't work exactly
14:38:36 <rasen_> tmtwd: forgot do?
14:38:45 <monochrom> zacts: http://www.slideshare.net/ScottWlaschin/fp-patterns-buildstufflt
14:38:47 <ajf>         negDir = over both (< 0) dir
14:38:49 <ajf>         step  = over both (choose -1 1) negDir
14:38:53 <ajf> This is great :D
14:38:55 <ion> tmtwd: [a b] is an invalid pattern, did you mean [a, b]? Make sure the putStrs are aligned and “do” is needed for that.
14:39:06 <tempname11_> ajf: what's choose here?
14:39:14 <ajf> tempname11_: if cond then a else b
14:39:16 <ion> ajf: That is parsed as (choose) - (1 1)
14:39:24 <ajf> ion: ah, right
14:39:36 <ion> ajf: Data.Bool.bool
14:40:27 <zacts> http://amtal.ca/2011/08/25/why-haskell-is-kinda-cool.html <-- this is I think what I was looking for
14:40:43 <zacts> monochrom: oh cool thanks
14:40:55 <tmtwd>   args <- getArgs
14:40:56 <tmtwd>   progName <- getProgName
14:40:56 <tmtwd>   case args of [a, b]  -> do  putStr a
14:40:56 <tmtwd>                               putStr  b
14:40:57 <tempname11_> ajf: the first argument to 'over both' is a function... your doesn't seem like it is
14:40:58 <tmtwd> like this?
14:41:02 <tempname11_> or maybe I'm missing something
14:41:08 <ajf> tempname11_: curried
14:41:17 <zacts> although, I'm initially skeptical of anything with the terms "design patterns" coming from knowing people who preached them with java
14:41:25 <zacts> but that was 'Java OOP Design Patterns"
14:41:27 <ajf> (choose (-1) 1) is \x -> choose (-1) 1 x
14:41:27 <zacts> '
14:41:37 <ion> tmtwd: Looks okay. You can use a pastebin to paste multi-line things in a nicer way.
14:41:45 <ajf> ion: thanks, I suspected there'd be a version of this already
14:42:03 <alynn> design patterns are libraries which your language isn't powerful enough to express
14:42:03 <dfeuer> JoshieAS, functor instances turn out to be pretty much "do the only thing you can".
14:42:35 <ajf> Oh no, Haste lacks Control.Lens :<
14:42:44 <JoshieAS> I was confused more until I looked at the type for runParser
14:42:51 <ajf> Oh
14:42:51 <JoshieAS> it takes a Parser and a String and returns a Maybe
14:42:55 <Lokathor> zacts, design patterns are specific to the abstraction layer being worked with
14:43:02 <ajf> No, it's just Control.Lens isn't a thing
14:43:12 <tempname11_> ajf: it's in the lens package
14:43:18 <JoshieAS> so I guess what an instance for Parser would do (functor) is allow you to change the input to the Parser?
14:43:18 <tempname11_> not in base
14:43:20 <tmtwd> yeah, for some reason this program won't load in repl: http://pastebin.com/zG856GRM
14:43:40 <ajf> tempname11_: Ah...
14:43:45 <dfeuer> ajf, I don't think Haste supports the lens package, but I think it probably supports ... lens-family, or whatever.
14:43:58 <JoshieAS> `char` is a Parser that takes a char and checks the next char given as input for a match
14:44:04 <ajf> In this case the thing I need is quite simple, I'll just rewrite it
14:44:07 <JoshieAS> if if matches, you get (Just (char, rest of string))
14:44:41 <JoshieAS> so if you have `char 'c'`, you can do (fmap (toUpper) (char 'c'))
14:44:51 <dfeuer> JoshieAS, fmap lets you change the *output* of your parser.
14:44:56 <ion> tmtwd: The reason is indicated in the error message. Without it, we may have hard time seeing the problem. In this case, it’s that putStrLn args !! 2 is parsed as (putStrLn args) !! (2).
14:45:23 <JoshieAS> runParser (fmap (toUpper) (char 'c')) "chitty"
14:45:26 <JoshieAS> should give me "Chitty"
14:45:29 <dfeuer> Yes.
14:45:40 <JoshieAS> oops, (Just ('C', "hitty"))
14:45:57 <maerwald> tmtwd: you asked about foldr and foldl today, didn't you?
14:46:40 <ajf> raycast.hs:6:19: Module ‘Data.Bool’ does not export ‘bool’
14:46:43 <ajf> ...huh?
14:47:04 <Lokathor> the name of the type is Bool, not bool
14:47:09 <Lokathor> if that's what you want
14:47:12 <dfeuer> JoshieAS, In 99% of cases, the Functor instance you need is actually the one GHC will derive for you if you ask it kindly.
14:47:14 <ajf> No, I want the function
14:47:24 <JoshieAS> how do I do that?
14:47:24 <dfeuer> Maybe more than 99%.
14:47:26 <ajf> Maybe it's a Haste oddity
14:47:28 <Lokathor> :t bool
14:47:29 <lambdabot> a -> a -> Bool -> a
14:47:34 <ajf> Yep
14:47:37 <Lokathor> @src bool
14:47:37 <lambdabot> Source not found. Maybe you made a typo?
14:47:39 <ajf> Haste lacks it :/
14:47:45 <ajf> GHC has it
14:48:00 <dfeuer> JoshieAS, well, you shouldn't do that till you've gotten some practice writing your own! But you can use {-# LANGUAGE DeriveFunctor #-} and then just deriving Functor.
14:48:06 <Lokathor> awh
14:48:28 <geekosaur> bool is also fairly recent even in ghc
14:48:40 <JoshieAS> okay, good, because I definitely want to learn
14:49:19 <dfeuer> The only times you might want a non-obvious Functor instance are ones where you have some sort of special support in your type for mapping things over it, which I know regex-applicative uses.
14:49:34 <JoshieAS> ah, I see
14:50:15 <jle`> ajf: what version of ghc do you have?
14:50:51 <ajf> jle`: 7.8.4
14:50:54 <ajf> Why do you ask?
14:51:08 <jle`> oh, you say that ghc has it, but haste doesn't
14:51:09 <jle`> nvm
14:51:13 <ajf> :)
14:51:27 <jle`> {-# LANGUAGE DeriveCatamorphisms #-}
14:51:51 <andreasd> What tutorial did you use to get familiar with Haskell?/quit
14:52:01 <jle`> that was interesting
14:52:25 <jle`> maybe they're planning on reading the logs?
14:56:18 <dfeuer> jle`, that's mildly humorous.
14:56:53 <dfeuer> jle`, however, it seems a close relative to Idris's %elim pragma.
14:59:26 <zacts> Lokathor: yes, perhaps my feelings are unwarranted
14:59:38 <zacts> and I don't have enough knowledge to fairly have them
14:59:48 <zacts> they are more of an initial skepticism I think
15:03:32 <JoshieAS> dfeuer: what exactly is 'pure' for in an Applicative?
15:03:42 <Lokathor> zacts, a number of the standard "design patterns" that C++ and Java might use don't apply to Haskell, but Haskell still has some patterns of sorts
15:03:50 * hackagebot hipbot 0.3 - A library for building HipChat Bots  http://hackage.haskell.org/package/hipbot-0.3 (purefn)
15:04:12 <vandenoever> i'm trying to implement a dom in haskell using 'class'
15:04:36 <vandenoever> a Node can be either an Element or a TextNode
15:04:49 <vandenoever> Node, Element and TextNode can all be classes
15:05:13 <vandenoever> but the impl of each Node, Element or TextNode can differ wildly
15:05:23 <merijn> JoshieAS: Inserting a value into the Applicative
15:05:39 <vandenoever> in c++, i'd use virtual members, how does that work in haskell?
15:06:03 <ajf> both (\(x, y) -> sqrt $ 1 + y / x) (dir, swap dir)
15:06:14 <merijn> vandenoever: Why not parameterise over node type?
15:06:19 <thomaseding> vanderoever: Use a Gadt with a constructor that has a type class constraint
15:06:28 <tempname11_> what is a good way to learn about catamorphisms? https://wiki.haskell.org/Catamorphisms makes my head explode
15:06:28 <Lokathor> vandenoever, it sounds like you want to use a typeclass that has the appropriate functions, and several instances
15:06:34 <merijn> thomaseding: That is almost certainly the wrong advice
15:07:03 <dfeuer> JoshieAS, there are some laws that tell you how it has to behave. But generally, if you think of an applicative as "producing" a value, using `pure` gives you one that produces a specific value (and does nothing else).
15:07:13 <vandenoever> thomaseding: i'm afraid i dont understand the gadt part, got a good starting point?
15:07:14 <merijn> In fact, this question sounds very much like the existential typeclass antipattern
15:07:20 <thomaseding> merijn: Isn't that equivalent to using a RankWhatever type>
15:07:32 <merijn> thomaseding: No, that's equivalent to ExistentialQuantification
15:07:40 <tempname11_> vandenoever: you can use an explicit vtable
15:07:46 <dfeuer> JoshieAS, so for a parser, pure x is a parser that produces x without consuming any input (or pushing any back, or anything).
15:07:57 <vandenoever> Lokathor: the issue i'm up against is that e.g. my Element class has a function 'children :: Element -> [Node]'
15:07:58 <tempname11_> don't go for the type madness
15:07:59 <JoshieAS> ah, so I can't do (+3) <*> [1,2,3,4]
15:08:05 <vandenoever> but Node is also a class
15:08:06 <JoshieAS> but I can do pure (+3) <*> [1,2,3,4]
15:08:11 <thomaseding> whoops, I mean that, not ranked types. 
15:08:32 <merijn> thomaseding: Yeah, but EQ is almost always not the approach you want
15:08:36 <dfeuer> Ezzackly, JoshieAS, but that's usually better replaced by fmap for clarity.
15:08:44 <dfeuer> Which is a law.
15:08:57 <dfeuer> pure f <*> xs = fmap f xs
15:09:02 <merijn> vandenoever: What's wrong with "data Node = Element {- args here -} | TextNode {- args here -}", etc.?
15:09:47 <vandenoever> merijn: i want Element and TextNode to be classes too
15:09:47 <Lokathor> vandenoever, keep in mind that you probably don't want your data to also hold the functions that work on itself like you do with OOP
15:10:15 <tempname11_> vandenoever: why use classes here? what merijn proposes is probably best
15:10:16 <merijn> vandenoever: What do you mean by classes? You mean typeclasses?
15:10:24 <vandenoever> Lokathor: right, i dont, and even in oop, they'd be in the vtable, not in the instances
15:10:30 <merijn> vandenoever: Typeclasses are a bad way to encode this sort of thing
15:11:01 <vandenoever> more concretely, i want to implement html, svg, some_other_xml
15:11:05 <merijn> Lokathor: If you wanna do OO haskell that's exactly what you'd do. Have a record of functions
15:11:13 <ajf> Who runs lpaste?
15:11:23 <dfeuer> JoshieAS, that wonky law that says   pure ($ x) <*> fs = fs <*> pure x   is best thought about using the [] Applicative, I think.
15:11:25 <Lokathor> merijn, but you usually dont' want to actually do that :P
15:11:29 <dfeuer> ajf, Chris Done, I believe.
15:11:35 <vandenoever> each has elements with child nodes, naively i could explicilty give them the same data structure
15:11:37 <merijn> Lokathor: Why not? It works really well
15:11:50 <vandenoever> but i dont want that, i want to give them an adaptor
15:12:02 <vandenoever> by putting them in a class for e.g. 'Element' or 'TextNode'
15:12:03 <merijn> Lokathor: Much better than the ExistentialQuantification/typeclass approach people usually use
15:12:45 <vandenoever> so i can have a tree with many different elements
15:12:46 <Lokathor> merijn, well possibly. I've yet to personally see an example where forcing OO into haskell helped out much. though this situation does approach that
15:12:59 <vandenoever> each element can have children of many different types
15:12:59 <ajf> dfeuer: I'm just wondering why it's having so much trouble. Hmm.
15:13:11 <merijn> vandenoever: You probably want to tackle it like "data Node = Node { foo :: a -> Bar; xyzzy :: String -> Int -> Bool }", etc. putting all the function types in a record
15:13:39 <tempname11_> and that's exactly an explicit vtable
15:13:58 <merijn> Lokathor: I use that approach to have a uniform way to interface with ZMQ sockets, have a single record type that provides "read", "write", etc. operations and then different socket types provide different instances
15:14:17 <vandenoever> merijn: tempname11_: does that work if i dont know the different types in advance?
15:14:26 <vandenoever> in c++, i could have an abstract class
15:14:31 <Lokathor> vandenoever, if each record type includes "children :: [Node]", then you can mix and match particular constructors of node within the list
15:14:53 <merijn> vandenoever: An abstract class is not a sensible notion in haskell
15:15:10 <merijn> vandenoever: You can parameterise the Node type over the argument types of functions
15:15:21 <vandenoever> merijn: haskell wants to know all possible types in advance?
15:15:41 <merijn> vandenoever: "data Node a = Node { foo :: a -> Bool; xyzzy :: [Node a] }" or something
15:16:13 <merijn> vandenoever: Haskell has no notion of subtyping, thus there is also no such thing as 'determining a type at runtime'
15:16:38 <merijn> vandenoever: There's various extensions that kinda/sorta change that statement, but it's a pretty accurate baseline
15:16:56 <vandenoever> merijn: ok, so that's a pretty big challenge then
15:17:18 <vandenoever> i was thinking of writing a dom interface and then use many different implementations of it
15:17:49 <merijn> vandenoever: If you can write down an explicit (optionally parameterised) DOM interface, then you can still do that
15:17:56 <vandenoever> and really mix them, so an array of [Node] could mean many different data types
15:18:13 <vandenoever> but at least they have the same functions, like Eq has
15:18:27 <Lokathor> a typeclass can handle that sort of thing, as long as you're aware of the differences between that and a C++ style object hierarchy
15:18:40 <merijn> Lokathor: It can't
15:18:52 <merijn> Because he can't have a list of multiple different node types in the same list
15:19:31 <merijn> Which, is one of the things he wants
15:19:46 <vandenoever> yes, a list with Node instances, but the implementations can vary
15:19:51 <Lokathor> ah
15:19:59 <Lokathor> well you can't do that sadly :/
15:21:03 <merijn> vandenoever: You might wanna have a look at how, for example, xml-conduit does things, but I don't think they bother with multiple possible DOM implementations
15:21:30 <merijn> vandenoever: That's based on https://hackage.haskell.org/package/xml-types-0.3.4/docs/Data-XML-Types.html
15:22:08 <vandenoever> merijn: really what i want is a space optimization, because of course i could share the data structure across Node implementations
15:22:41 <vandenoever> but e.g. returning the name of an element can differ across implementations
15:22:44 <merijn> That seems like it would safe a negligible amount of space
15:23:02 <vandenoever> for 'Element' i need a field for it, for SvgSvg it's a fixed value
15:23:36 <vandenoever> storage and access time could really improve though
15:24:05 <vandenoever> if i've an element with only one child with fixed qname, it's more efficient than a [Node] member
15:24:42 <merijn> vandenoever: How would storage improve?
15:25:26 <vandenoever> merijn: if i know there's only one child, i dont need a length( or 'next' when using linked list)
15:25:52 <vandenoever> also it would save on conversion functions
15:26:07 <vandenoever> since Node is very general and the actual type might be a string
15:26:16 <Lokathor> I don't think that a [Node] of size 1 is particularly larger than a Node on its own
15:26:24 <merijn> vandenoever: I think C++ has made you overthink generally irrelevant issues in terms of performance :)
15:26:35 <vandenoever> merijn: that's very possible indeed
15:26:41 <merijn> vandenoever: Especially if you're using String
15:26:44 <vandenoever> i have a loong c++ history
15:27:31 <merijn> vandenoever: Because, this might give you a heartattack as a C++ programmer, but String might be consuming as much as 24 bytes per character (this is also generally why you shouldn't use String for anything but trivial small piece of text)
15:27:54 <vandenoever> ok, so what's possible is that each Node has the same data contents but more specialized can have more data accessors
15:28:26 <Lokathor> how do you mean "more data accessors"?
15:28:30 <vandenoever> merijn: i'm working with ghcjs, so instead of string i use JSString :-)
15:28:57 <Aruro> did anyone compile ghc-mode on 7.8.4 ? i get error about ExplicitForall
15:29:06 <vandenoever> Lokathor: specialized helpers that rely on the fact that i know something about the element
15:29:10 <merijn> vandenoever: If you're compiling to JS your performance concerns are probably even more irrelevant ;)
15:29:30 <vandenoever> e.g. title :: HeadElement -> TitleElement
15:29:43 <vandenoever> merijn: or even more pertinent
15:30:20 <Aruro> merijn: why does string had this behaviour?
15:30:41 <vandenoever> i know how to make all of this fast and low impact in c++, but i really like how haskell simply forbids most stupidity
15:30:43 <merijn> Aruro: Because String is just [Char], i.e. a linked list of unicode characters
15:31:46 <tempname11_> I just thought about this long and hard and realized that what I meant by an "explicit vtable" was complete rubbish. Also, the best and most performant way to do this DOM thing looks to be the (quoting merijn) "data Node = Element {- args here -} | TextNode {- args here -}" way
15:31:58 <tempname11_> vandenoever: is there a reason you aren't considering that?
15:32:05 <quchen> merijn: … maybe a String section in the FBUT would be useful. I've said or seen it said maaany times in the last couple of months :-s
15:32:05 <Lokathor> vandenoever, i'm not sure i would generally make a type for HeadElement or TitleElement
15:32:58 <vandenoever> tempname11_: that's what i started from, but i cannot figure out how to have Node have 'children :: Node -> [Node]' where Node is a type class with mulptiple implementations
15:33:09 <merijn> quchen: So you're saying I should go on a rant so you can copy-paste is in there? ;)
15:33:14 <vandenoever> Lokathor: for working with type safe xml
15:33:21 <tempname11_> vandenoever: you don't need a typeclass for that
15:33:35 <tempname11_> data Node = OneChild Node | ManyChildren [Node]
15:33:51 * hackagebot profunctors 5.0.1 - Profunctors  http://hackage.haskell.org/package/profunctors-5.0.1 (EdwardKmett)
15:33:57 <merijn> Aruro: Compare with, for example, Text which is a densely packed array of unicode text. Text takes about 2 bytes per character with an overhead of like 10-20 bytes per several kilobyte blob
15:34:00 <quchen> merijn: I'll just start writing, but feel free to rant and I'll see what I can use of it :-)
15:34:04 <tempname11_> childrenOf node = case node of OneChild x -> [x]; ManyChildren xs -> xs
15:34:51 <ion> quchen: Perhaps with a visualization of a simple String data structure with annotations pointing out the memory consumption of each pointer etc.
15:34:52 <tempname11_> (explicit "case" for clarity)
15:35:23 <vandenoever> tempname11_: i want a tree where i dont know the node types in advance, i only know that they are different
15:35:46 <tempname11_> vandenoever: why don't you want to know them in advance?
15:36:35 <vandenoever> tempname11_: maybe i could, but my current thinking is that i dont
15:37:56 <Lokathor> you're trying to be type safe, but also not declare anything about the types of things
15:39:03 <tempname11_> vandenoever: the only reason not to know them in advance is extensibility *between different packages*
15:39:52 <vandenoever> tempname11_: right
15:39:58 <tempname11_> unless you really need to separate the interface and implementation into different packages, there's no good reason to "not know them in advance"
15:40:02 <vandenoever> Lokathor: well, i'm decaring what functions they implement
15:40:18 <tempname11_> vandenoever: do you need that kind of extensibility?
15:40:31 <vandenoever> tempname11_:  i see your point, i'm writing a lib that would deal with arbitrary xml schemas
15:40:37 <quchen> merijn: Hmm, what's the overhead of String again? Per character, you need (1 word for the Char pointer) + (1 word for the Cons cell) + (1 word for the rest-of-list-pointer), right?
15:40:46 <quchen> I feel like I'm forgetting something.
15:41:00 <vandenoever> tempname11_: so unless i come up with a code generation scheme that takes a list of schemas, i'd need a generic interface
15:41:18 <merijn> quchen: another word for the Char box
15:41:35 <merijn> quchen: "data Char = Char# Char#"
15:41:35 <quchen> Oh right, String is a list of boxed Chars, not raw ones
15:41:46 <merijn> Or whatever the definition is
15:42:00 <merijn> So that puts you at at least 4 machine words per char
15:42:49 <tempname11_> vandenoever: can you describe how your library will be used with "arbitrary schemas"?
15:43:30 <tempname11_> I mean in the resulting application
15:44:09 <refefer> hrmph, I can't figure out how to get arrow keys or backspace working in haskeline
15:44:38 <Lokathor> vandenoever, the general form of what you want might be something akin to: data XMLNode = Node { _getTags :: (Map String String), _getChildren :: [XMLNode] } | Content { _getContent :: Text }
15:44:59 <Lokathor> assuming I remember how XML works correctly >_<
15:45:06 <vandenoever> tempname11_: 1) load a generic dom, 2) parse it to a specific dom (efficient impl with generic interface) 3) transform 4) save using generic dom interface
15:45:19 <refefer> or enter for that matter
15:46:16 <tempname11_> vandenoever: and which of those steps will be done by your 'general library' ?
15:46:19 <Taneb> Ugh, lpaste seems to be down
15:46:36 <vandenoever> tempname11_: 1) and 4)
15:47:34 <vandenoever> Lokathor: looks interesting, i'll have to read a bit to understand that one exactly
15:47:42 <P4Titan> Hello all, I accidentally messed up my haskell libraries where I have multiple versions of many of the same packages. Is there a way I can fix this?
15:48:25 <ion> P4Titan: You could delete ~/.cabal and ~/.ghc, and use cabal sandboxes from now on.
15:48:48 <P4Titan> That does not sound eligant
15:49:21 <maerwald> why?
15:49:22 <Lokathor> vandenoever, the general idea here is that each value of XMLNode is either a Node, which can have some tags and also a list of children, or it can just be content, which is Text. So <b>example</b> would be: Node{_getTags=Map.empty, _getChildren=[Content "example"]}
15:49:25 <maerwald> that's what everyone does
15:49:53 <P4Titan> Really?
15:50:12 <maerwald> I cannot imagine doing things without sandboxes
15:50:14 <maerwald> that would be horrible
15:50:16 <P4Titan> You mean do cabal sandbox init and then cabal install ... the required packages
15:50:16 <Lokathor> P4Titan, ghc does a very large amount of inlining, so basically only one version of any particular package is allowed to exist within the build path when it does a compile, so people use sandboxes a lot
15:50:21 <maerwald> yes
15:50:27 <merijn> vandenoever: Did you look at the xml-types library I linked and how that does things?
15:50:57 <P4Titan> So should I expurgate .cabal and .ghc?
15:51:04 <vandenoever> merijn: i've used it but not looked at impl yet
15:51:14 * vandenoever loads
15:51:33 <tempname11_> vandenoever: so, what prevents you from (1) having the Haskell type "EncodedData -> GenericDOM" and (4) "GenericDOM" -> EncodedData", where GenericDOM and all of it's nodes are fully specified in advance?
15:52:40 <vandenoever> tempname11_: yes, it think that's the way to go
15:53:09 <Profpatsch> https://stackoverflow.com/questions/30281541/will-ghc-strip-out-unused-imports
15:53:13 <vandenoever> tempname11_: initially that sounds like being expensive but then, lazyness should help to keep mem cost down
15:53:43 <quchen> merijn: RFC https://github.com/quchen/articles/blob/master/fbut.md#string
15:54:02 <merijn> Profpatsch: If you have an explicit export list GHC will warn about unused local definitions and "useless" imports
15:54:25 <merijn> Profpatsch: Without an export list it will assume some other module might import that module and use those functions
15:54:49 <tempname11_> vandenoever: all right, cool :) you don't need the crazy extensibility then, I guess. Just a matter of framing the problem correctly
15:55:31 <maerwald> quchen: so would you rather advice to use the parser modules that utilize text instead of bytestring?
15:55:50 <merijn> quchen: I would add: 1) clarification of why String is useful (i.e. easy list manipulation using matching) and point out the relation with bytestring, i.e. "ByteString is binary, Text is unicode and String is misc small stuff"
15:55:55 <merijn> maerwald: Depends
15:55:59 <ion> maerwald: Depends on whether you’re parsing characters or bytes.
15:56:01 <merijn> maerwald: If it's textual data, then yes
15:56:04 <quchen> merijn: Good points.
15:56:13 <merijn> maerwald: If you're parsing binary data, than bytestring is fine
15:56:55 <merijn> maerwald: When you see ByteString ignore the tring part and focus on the bytes part ;)
15:57:44 <enthropy> quchen: readMaybe should probably say Text.Read.readMaybe
15:57:48 <ion> maerwald: Text : [Char] = ByteString : [Word8]
15:57:57 <merijn> maerwald: The proper default approach would be "read ByteString -> decode to Text -> parse text"
15:58:06 <quchen> enthropy: Heh, good catch :-D
15:58:31 <enthropy> or otherwise point out that you need to import it
15:58:35 <merijn> Unless you're parsing a binary format like, I dunno, JPG or whatever, in which case the right choice is obviously "read bytestring -> parse bytestring"
15:58:52 <P4Titan> What should I do with .cabal and .ghc if I want to start clear?
15:59:52 <tempname11_> rename them to .old.cabal and .old.ghc in case you want to revert :)
16:00:13 <P4Titan> Ok, but I can use cabal since .cabal/bin/cabal no longer exists
16:00:30 <ion> P4Titan: How did you install GHC and cabal-install originally?
16:00:38 <P4Titan> apt-get probably
16:00:49 <merijn> quchen: Maybe add bitemyapp's list as a link in your "How to learn" paragraph
16:00:54 <ion> P4Titan: In that case you should have cabal in /usr/bin.
16:01:43 <P4Titan> It seems that I installed cabal not using apt-get
16:02:20 <refefer> tips for lazy IO?  things not outputting when I want them to, etc.
16:02:32 <merijn> refefer: Doesn't sound like a laziness issue
16:02:37 <mniip> protip: don't
16:02:37 <merijn> refefer: Sounds like a buffering issue
16:02:45 <refefer> merijn: both are set to NoBuffering
16:02:48 <ajf> OK, refactoring time
16:02:53 <ajf> https://gist.github.com/TazeTSchnitzel/138d194a14a3f912d901
16:02:57 <ajf> Gone from from.hs to to1.hs
16:03:09 <Myrl-chan> Would I get banned for posting Haskell anthromorphism?
16:03:16 <ajf> but I want to deduplicate sideDist and have failed so far in my attempts
16:03:22 <ajf> it's slightly more complex than the others
16:04:07 <ajf> `both` is a function I made, it's like `over both`
16:04:10 <pavonia> refefer: Could you paste some code?
16:04:34 <maerwald> Data.Text doesn't support pattern matching?
16:05:00 <quchen> No, it does not.
16:05:02 <merijn> maerwald: "maybe"
16:05:10 <quchen> You can emulate it.
16:05:16 <quchen> But you cannot actually match against it.
16:05:25 <merijn> You can turn on OverloadedStrings and get equality matching
16:05:36 <merijn> And with PatternSynonyms we can go even further
16:05:37 <jle`> traditionally you can only pattern match structurally, against constructors
16:05:55 <jle`> and Text doesn't really have constructors you'd meaningfully want to pattern match against...at least in the way you're probably thinking
16:06:07 <quchen> merijn: Now that I think of it, you shouldn't be able to match against String for the same reasons, because Char isn't an ADT.
16:06:17 <merijn> jle`: Pah! Who needs traditions when you've got industrial strength extensions! :p
16:06:17 <quchen> Well, it's an ADT, but not the sum of characters.
16:06:40 <jle`> traditions are all we have
16:06:44 <merijn> Char is an ADT, it just contains a primitive type :)
16:06:53 <quchen> Hence my correction.
16:07:04 <merijn> And primitive types are special compiler voodoo, so they can do whatever the hell they want!
16:07:12 <ajf> ADT all the things
16:07:16 <ajf> although
16:07:32 <quchen> merijn: Quite the contrary! Primitive types are the only thing that is not special compiler vodoo.
16:07:34 <ajf> you could consider Char to just be data Char = 'a' | 'b' | ...
16:08:36 <merijn> quchen: Eh...yes they are?
16:09:01 <maerwald> jle`: there are ViewPatterns
16:09:11 <mniip> quchen, primitive as in primitives
16:09:14 <mniip> not as in simple
16:09:27 <merijn> maerwald: Checkout PatternSynonyms, they're like ViewPatterns on steroids
16:09:31 <maerwald> e.g. in the diagrams lib you can do: foo (coords -> x :& y :& z) = ...
16:09:39 <Pamelloes> Given data MyType a = MyType a, if I have an instance Eq (MyType a), then can I compare MyType Int == MyType String (or any other differing parameter types)?
16:09:46 <jle`> ViewPatterns also can only eventually structurally pattern match
16:10:03 <maerwald> I dislike libraries that force me to pack and unpack a lot
16:10:04 <jle`> Pamelloes: nope, check out the definition of (==)
16:10:10 <jle`> er, the type signtuare of (==)
16:10:16 <merijn> Pamelloes: Nope, because Eq compares values of the same type
16:10:16 <jle`> :t a
16:10:18 <lambdabot> Expr
16:10:19 <mniip> consider Int#, ByteArray#, or State# a 
16:10:20 <jle`> :t (==)
16:10:21 <lambdabot> Eq a => a -> a -> Bool
16:10:22 <merijn> :t eqAnything
16:10:23 <lambdabot> Not in scope: ‘eqAnything’
16:10:26 <merijn> Awww
16:10:40 <mniip> those are ghc primitive types
16:10:41 <merijn> @let eqAnything a b = cast a == Just b
16:10:42 <lambdabot>  Defined.
16:10:51 <merijn> > eqAnything True 'c'
16:10:53 <lambdabot>  False
16:10:57 <merijn> > eqAnything True True
16:10:59 <lambdabot>  True
16:11:03 <merijn> Whoo!
16:11:12 <Pamelloes> :t eqAnything
16:11:12 <jle`> Eq a => a -> a -> Bool means, "given two values of type `a`, get a Bool back...where a is an instance of Eq"
16:11:13 <lambdabot> (Eq b, Typeable a, Typeable b) => a -> b -> Bool
16:11:56 <tempname11_> ajf: don't see any good way to simplify the sideDist lines without introducing the concept of vectors and operations on them properly. if you want to go that way, have a look at package linear, maybe you'll find it useful.
16:12:19 <Pamelloes> Hm... merijn, is there a similar compareAnything?
16:12:31 <quchen> :t let map f z@((f -> _) : (map f -> _)) = z in map -- jle` ViewPatterns are pretty crazy as well ;-)
16:12:32 <lambdabot> (t -> t1) -> [t] -> [t]
16:12:39 <quchen> Heh, bug.
16:12:42 <merijn> Pamelloes: Not by default, but it's easy enough to define
16:13:31 <Pamelloes> merijn: How so? It makes logical sense to expand equality beyond similar types, since if type a /= type b, a /= b. But what would a < b mean if a and b are different types?
16:13:56 <merijn> Pamelloes: Ah, just have it return "Maybe Ordering"?
16:14:23 <Pamelloes> hmmm
16:15:04 <Pamelloes> Is there an implementation of map where the keys can be Eq instead of Ord?
16:15:49 <quchen> Pamelloes: HashMap when you have a mapping to Int
16:15:55 <merijn> "Eq a => [(a, b)]"
16:18:00 <Pamelloes> merijn: hm?
16:18:17 <merijn> A list of key and value tuples
16:18:26 <Pamelloes> Oh, I see.
16:18:29 <merijn> That's as efficient as you can get with only an Eq constraint
16:18:32 <merijn> :t lookup
16:18:33 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
16:18:39 <merijn> There's even functions for it in Prelude
16:18:46 <quchen> Hm, I guess I don't understand how ViewPatterns work. The z@ in my above code snippet does not seem to take them into account.
16:19:12 <quchen> > let map' _ [] = []; map' f ((f -> x) : (map' f -> xs)) = x:xs in map' (*10) [1..10] -- Works, but now I don't have a single character on the RHS.
16:19:14 <lambdabot>  [10,20,30,40,50,60,70,80,90,100]
16:19:16 <Pamelloes> I think I can probably make a HashMap. That's probably my best option at this point.
16:19:50 <dfeuer> Hrm... commutativity bites.
16:20:01 <merijn> quchen: ViewPatterns are just a syntactic variation of pattern guards
16:20:05 <hexagoxel> let me get this right: the phrase "package" is used for two related, but distinct concepts: ghc packages and cabal packages. correct?
16:20:12 <merijn> quchen: Where you can write the patternguard "inline" in the match
16:20:25 <merijn> hexagoxel: No
16:20:39 <merijn> hexagoxel: ghc deals only with libraries
16:20:51 <quchen> merijn: Ah, and the z@ isn't part of the ViewPattern so it's just structural matching on stuff, and then the ViewPatterns kick in in the guards afterwards
16:20:54 <merijn> hexagoxel: A package can contain 0 or 1 libraries and 0 or more executables
16:21:06 <hexagoxel> merijn: but `ghc-pkg` help talks about "packages". are those really cabal packages?
16:21:16 <quchen> I have never used pattern guards. :-s
16:21:20 <merijn> hexagoxel: Minus executables, yes
16:21:32 <exio4>  pattern guards is basically something like
16:21:40 <merijn> hexagoxel: cabal doesn't actually track packages at all, it just registers them with ghc and queries ghc for what's installed
16:21:53 <merijn> hexagoxel: Which is why cabal can't check whether executables are installed
16:21:56 <exio4> f x | Just w <- lookup x y = ... <- something like this, 
16:22:13 <exio4> basically, adding the posibility of pattern matching and binding (of variables) to guards
16:22:15 <quchen> merijn: Can I mix pattern guards and ordinary boolean guards?
16:22:18 <exio4> you can
16:22:20 <merijn> quchen: Yes
16:22:31 <merijn> exio4: I forget, are they Haskell2010?
16:22:38 <quchen> f x | Just w <- lookup x y, 2 > 3, foobar = ...?
16:22:41 <quchen> merijn: Yes
16:22:46 <quchen> That part I know ;-)
16:22:58 <exio4> merijn: they are
16:23:08 <merijn> quchen: A failed pattern match in a patternguard is treated like a "false" in a boolean guard would be
16:23:21 <exio4> so the next equation / guard is tried \o/ 
16:23:49 <quchen> merijn: I guess internally it's translated to a "matches p = True; matches _ = False" function then
16:24:23 <merijn> quchen: Possibly, I don't know exactly how guard desugar
16:24:45 <merijn> Anyway, bed time!
16:24:50 <exio4> good night merijn!
16:27:33 <P4Titan> I removed my .cabal and .ghc directories. Now when I import Data.HashSet, it cannot find it. Is there a library for these basic types that I need to install
16:27:46 <tempname11_> P4Titan: containers ?
16:27:51 <ion> @hoogle HashSet
16:27:52 <lambdabot> No results found
16:28:02 <ion> http://hoogle.haskell.org/?hoogle=HashSet
16:28:06 <tempname11_> http://hayoo.fh-wedel.de/?query=HashSet
16:29:19 <P4Titan> Ahhh, hoogle to the rescue. I should use it more often! Thanks guys
16:30:06 <tempname11_> hmm, http://hoogle.haskell.org/ is a new hoogle?
16:30:42 <tempname11_> I used https://www.haskell.org/hoogle/ all the time, and it didn't search on hackage
16:32:08 <hexagoxel> @tell merijn sorry about disconnecting there was not intentional. i will read the rest of your explanation from the logs; thanks.
16:32:08 <lambdabot> Consider it noted.
16:32:26 <geekosaur> the big yellow box at the top saying "alpha version, type search doesn't work!" would be a hint in that direction, yes
16:32:48 <tempname11_> yes, I really need to go to sleep. :)
16:32:55 <tempname11_> see you everyone
16:34:35 <hexagoxel> are there any chat logs from the last hour that actually work?
16:34:51 <hexagoxel> ircbrowse reports maintenance
16:35:14 <hexagoxel> tunes seems to have daily logs
16:37:11 <maerwald> hexagoxel: do you want me to lpaste it?
16:38:49 <hexagoxel> maerwald: thanks, not necessary. i can read the logs tomorrow.
16:50:13 <jle`> omg my first time using a comonad transformer
16:50:19 <jle`> these are really weird things
16:51:01 <maerwald> how does it feel?
16:51:09 <jle`> everything is really weird
16:51:19 <quchen> Bro, do you even lower?
16:51:38 <hexagoxel> ah, tunes.org _does_ have the logs from the last hour (i got confused by the different timezone / date)
16:51:44 <maerwald> quchen: I thought it is "do you even lift?"
16:51:47 <jle`> haha i didn't even realized that the comonadtrans version of lift was lower
16:51:59 <quchen> :-)
16:51:59 <jle`> *realize
16:52:00 <maerwald> oh
16:56:12 <hexagoxel> i still am not convinced that ghc package database actually contain cabal packages. the fields reported by `ghc-pkg describe` are overlapping to some degree, but they are definitely distinct from the corresponding cabal package
16:56:23 <hexagoxel> also, they are called ".conf" files, not ".cabal"
16:56:48 <c_wraith> why would the ghc package database hold cabal packages?
16:56:53 <c_wraith> It holds .o files and .hi files
16:58:00 <hexagoxel> <hexagoxel> merijn: but `ghc-pkg` help talks about "packages". are those really cabal packages?
16:58:00 <hexagoxel> <merijn> hexagoxel: Minus executables, yes
16:58:24 <c_wraith> they are the result of installing a package from cabal
16:58:36 <c_wraith> They are not a copy of the contents of the package as uploaded to hackage
16:58:51 <jle`> newtype RelaStore s = StoreT s (Traced (Sum s))
16:59:13 <hexagoxel> (my initial question was: "the phrase "package" is used for two related, but distinct concepts: ghc packages and cabal packages. correct?")
16:59:22 <hexagoxel> c_wraith: comments on that?
16:59:43 <c_wraith> They're both Cabal (note the capital letter) packages
16:59:57 <jle`> or should it be TracedT (Sum s) (Store s) ...? it's like learning about transformers all over again
17:00:06 <geekosaur> that's a source of confusion all by itself though
17:01:46 <hexagoxel> c_wraith: but if my package database actually contained Cabal packages, should i not be able to extract and, lets say, upload them again?
17:01:51 <c_wraith> hexagoxel: it's asking if the source code of a library and its compiled object files are the same thing.  Well, technically, no.  But they each represent the library in a way.
17:02:06 <hexagoxel> (and sorry about the cabal vs Cabal imprecision; i am well aware of cabal/Cabal/cabal-install)
17:02:25 <jle`> i have no idea what I'm doing
17:04:12 <hexagoxel> but Cabal packages != libraries. Cabal packages _may_ contain one library.
17:04:27 <hexagoxel> let me explain why i am asking
17:06:30 <hexagoxel> i wonder how to properly describe/use the phrase "package" in the context of explaining the basic usage of Cabal.
17:06:42 <arbelos> Is there a built-in function that does something like [1,2,3,4,5,6,7,8] -> ([1,3,5,7],[2,4,6,8])?
17:06:56 <ion> > partition odd [1..8]
17:06:58 <lambdabot>  ([1,3,5,7],[2,4,6,8])
17:07:30 <c_wraith> arbelos: if you're writing a merge sort, I suggest doing a bottom-up sort instead
17:07:32 <arbelos> ion, perfect. very ffast
17:07:33 <arbelos> fast
17:07:52 <arbelos> c_wraith. no merge sort here. Reading file input
17:08:04 <hexagoxel> and it did not seem right to go like "a package may contain a library, and when you install the library, it becomes a _package_ in the package db.
17:09:30 <arbelos> ok so i can't use odd in this case.. 
17:10:08 <arbelos> I should have said [a] -> ([a], [a]) 
17:10:20 <hexagoxel> c_wraith: thanks for your input
17:10:23 <arbelos> but I guess I can index the input 
17:10:52 <arbelos> zip [0..] input
17:11:15 <arbelos> and then use odd as a predicate on the first item
17:11:43 <ellwyne> Is there a way to invert filterM (f)? i.e. (not . f) for filter. Tried some applicative stuff but it didn't work
17:12:03 <exio4> ellwyne: fmap not . f? 
17:12:25 <tmtwd>  how do you enable indentation mode in emacs?
17:12:36 <tmtwd> in haskell mode
17:12:43 <tmtwd> somehow it got disabled
17:12:56 <ellwyne> exio4: works! 
17:13:41 <liam__> Hello everyone. I was playing around with warp on osx today and noticed something odd. If I compile the following code on osx and blast it with apache bench it stops responding after ~16000 requests. However, I tried the same thing on ubuntu with no problems. Has anybody here encountered similar behaviour before?
17:13:43 <liam__> > main = run 8080 (\req resp -> resp (responseBuilder status200 mempty mempty))
17:13:44 <lambdabot>  <hint>:1:6: parse error on input ‘=’
17:14:59 <exio4> arbelos: I would write a small recursive function here, f (x:y:rs) = let ~(xs, ys) = f rs in (x:xs , y : ys) ; f w = (w, [])
17:15:07 <gfixler> anyone else manage to install vty-ui?
17:15:26 <exio4> arbelos: mostly because I can't think of any simple combination of high order functions that does this thing :p
17:16:08 <arbelos> exio4: this reminds me, I have to properly understand this ~() syntax
17:17:08 <ion> arbelos: It just prevents the match from forcing the parameter in this case.
17:17:21 <exio4> although, isn't that ~ useless there?
17:17:47 <arbelos> wait, didn't you write that :)
17:17:50 <exio4> I think let pattern matches are "lazy" by default, aren't they?
17:17:59 <ion> exio4: yeah
17:18:17 <ion> > let Just a = Nothing in a
17:18:18 <lambdabot>  *Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern Just a
17:18:24 <ion> The GHC error message even reflects that.
17:18:46 <ellwyne> exio4: whats the difference between fmap not . f and fmap not f?
17:18:54 * hackagebot lambda-options 0.4.0.2 - A modern command-line parser for Haskell.  http://hackage.haskell.org/package/lambda-options-0.4.0.2 (ThomasEding)
17:19:11 <ion> ellwyne: fmap not . f = \x -> fmap not (f x)
17:19:12 <exio4> @type \f -> fmap not . f
17:19:13 <lambdabot> Functor f => (a -> f Bool) -> a -> f Bool
17:19:17 <exio4> @type \f -> fmap not f
17:19:18 <lambdabot> Functor f => f Bool -> f Bool
17:21:01 <ellwyne> Ah I see, thanks
17:21:51 <ion> arbelos: If you look at filter in <https://gist.github.com/ion1/0672eea6e88188682106>, select has the pattern “xs” and it’s important that it’s not forced. The functions on the following lines use a tuple to put more values into that parameter but it’s equally important that it’s not forced. Since the pattern “(a,b)” (as opposed to, say, “a”) would evaluate the tuple constructor, we’ll
17:21:53 <ion> add ~.
17:24:36 <liam__> For anyone interested in the Warp thing here is a minimal test case that causes the issue on my machine (http://pastebin.com/XBUkTR08), the output of ab (http://pastebin.com/xrGE40Wu) and the profiling output (http://pastebin.com/H3hwSPPz)
17:25:01 <arbelos> ion. thanks, i'll have to study this in detail
17:26:22 <geekosaur> I would wonder if you have any sockets left; I don't think OS X desktop is tuned for heavy web server use
17:28:05 <geekosaur> I am guessing you have a bunch of sockets in TIME_WAIT and none available to accept() more incoming requests
17:28:18 <geekosaur> when it fails
17:28:24 <liam__> That could certainly be the case if ab is holding onto sockets longer than I had dthough.
17:28:55 * hackagebot haskell-neo4j-client 0.3.1.0 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.3.1.0 (asilvestre)
17:29:36 <geekosaur> https://rolande.wordpress.com/2010/12/30/performance-tuning-the-network-stack-on-mac-osx-10-6/ <-- author has been updating this after the original publication so "10.6" is a bit of a misnomer
17:29:55 <geekosaur> also I am not talking about ab
17:30:01 <geekosaur> do you know what TIME_WAIT is?
17:30:22 <liam__> I'm afraid not.
17:30:34 <liam__> I'll have a google.
17:31:01 <geekosaur> when a TCP connection is closed, the socket sticks around for a period of time defined by the OS --- NOT the application --- to capture any packet retransmissions
17:31:13 <geekosaur> (uyes, I know those don't happen on loopback, but loopback still does it)
17:31:55 <geekosaur> and if you accept a lot of connections in a very short time, those TIME_WAIT sockets will eventually use up either all available ports or all available kernel socket structures or both
17:32:33 <geekosaur> see the URL I just pasted for tuning OS X to reduce that time and adjust other kernel networking parameters to work better for web servers
17:33:29 <liam__> Ahhh, seems like a very likely candidate given I hit the 16000 requests in less than a second.
17:33:43 <geekosaur> yep
17:33:55 * hackagebot haskell-neo4j-client 0.3.1.1 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.3.1.1 (asilvestre)
17:34:11 <geekosaur> Console might show messages from the kernel about dropping connections
17:35:40 <refefer> how should I interpret the 'productivy' percentage from `-s`
17:35:42 <refefer> ?
17:37:48 <liam__> @geekosaur, I do when I hit it with concurrent requests.
17:37:48 <lambdabot> Unknown command, try @list
17:44:23 <SrPx> Is there any shorter way to write "f x = case val of { A → ...; B → ... } where val = ..."?
17:47:16 <ajf> SrPx: Yes.
17:47:30 <ajf> f x = case ... of { A -> ...; B -> .... }
17:47:32 <liam__> Thanks for your help, Geekosaur. I'll keep digging.
17:47:58 <SrPx> ajf: :(
17:48:00 <ajf> SrPx: But it really depends on the specific code
17:48:11 <ajf> there might be a shorter way to do it you haven't thought of
17:48:33 <SrPx> I just wondered if there is any way to have A and B on guard-like patterns... "f x | A = ... | B = .. where val = ..." somehow
17:49:33 <geekosaur> where scopes over guards and equation groups. f A = ...; f B = ... where ...
17:49:50 <ajf> yes, you can use where on guards
17:50:21 <SrPx> yes, but notice teh value I want to match inside the guards isn't the function argument itself
17:50:57 <geekosaur> hm, mayne not over groups, sigh
17:51:17 <pavonia> Show us your real code, maybe there's a completely different way to do it
17:53:55 * hackagebot happstack-authenticate 2.1.4 - Happstack Authentication Library  http://hackage.haskell.org/package/happstack-authenticate-2.1.4 (JeremyShaw)
17:53:57 * hackagebot lambda-options 0.5.0.0 - A modern command-line parser for Haskell.  http://hackage.haskell.org/package/lambda-options-0.5.0.0 (ThomasEding)
17:56:09 <SrPx> geekosaur: lpaste is lagging... http://termbin.com/skkz
17:56:38 <SrPx> feel free to point bad stuff
17:58:37 <pavonia> :t maybe
17:58:38 <lambdabot> b -> (a -> b) -> Maybe a -> b
17:59:09 <SrPx> oh d'oh
17:59:21 <SrPx> I used that function a few times already, damn
18:00:46 <exio4> SrPx: that code looks nice enough?
18:00:59 <SrPx> don't think so :( it is horrible
18:01:02 <maerwald> SrPx: I usually do fI = fromIntegral because it looks just too tedious if you need it a lot
18:01:28 <kristof> I've never liked the ordering of the maybe function
18:01:37 <kristof> the default should come last
18:01:46 <SrPx> maerwald: that is something that *really* concerns me. More than it should. I never know what to do with fromIntegral. When I see a lot of it, I always assume I am doing something wrong.
18:01:55 <kristof> In fact, it should read like an if statement
18:02:00 <johnw> kristof: the current ordering lends itself will to partial applications
18:02:02 <SrPx> Like, usings Ints where I should use Floats, and so on.
18:02:02 <geekosaur> :t fromMaybe
18:02:04 <lambdabot> a -> Maybe a -> a
18:02:10 <simpson> kristof: It's not a default; `maybe` is an eliminator. It provides a case for every possibility.
18:02:12 <kristof> johnw: I can see that
18:02:17 <simpson> :t either -- another eliminator
18:02:18 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
18:02:19 <ion> kristof: Perhaps the if statement should read like Data.Bool.bool. :-P
18:02:24 <arbelos> If I do "map (something) [1..1000]" how can I make sure something is run for each number without printing out the result?
18:02:38 <maerwald> SrPx: well, or the API just sucks... happens both
18:02:46 <SrPx> arbelos: deepseq
18:02:47 <simpson> arbelos: What's `something`?
18:02:51 <exio4> arbelos: you mean evaluate the whole list? deepseq? 
18:02:58 <kristof> johnw: maybeWithDefault = maybe default?
18:03:03 <arbelos> deepseq.. ok
18:03:04 <SrPx> maerwald: what API?
18:03:10 <exio4> arbelos: if you really need that, I wouldn't use a list
18:03:24 <maerwald> SrPx: in case you use one :o
18:03:25 <SrPx> arbelos: for what is that, though?
18:03:28 <kristof> simpson: The documentation calls it a default
18:03:37 <SrPx> ahh 
18:03:44 <arbelos> exio4... i am just testing.. just ad-hoc benchmarking 
18:03:50 <exio4> arbelos: if you _want_ to make sure, use evaluate
18:04:00 <maerwald> SrPx: I found that I need quite some fromIntegral when using JuicyPixels for example
18:04:09 <maerwald> and only then
18:04:28 <arbelos> something is a fairly expensive computation .. no IO
18:04:43 <SrPx> For example, I have this function: cameraRay :: V3 Float -> V3 (V3 Float) -> Float -> Float -> V2 (V3 Float) -- (removing the type aliases)
18:04:45 <exio4> arbelos: er, I would evaluate from Control.Exception and force from deepseq will come handy, but I'd try to avoid adhoc benchmark
18:04:48 <ion> arbelos: You can use Data.SeepSeq to force the entire output structure.
18:05:59 <arbelos> exio4.. yes I know, I am just trying to decide if I need to rewrite everything using ByteString instead of String
18:06:10 <SrPx> ignoring the horrible name, it takes an AABB box (V3 Float), a camera (V3 (V3 Float)) and 2 positions (Floats). The first argument will always be an int, though, because it represents the size of a 3D array and you can't have fractional sizes
18:06:22 <SrPx> AABB*
18:06:38 <SrPx> so it would make sense to receive V3 Int instead of V3 Float ... 
18:06:53 <SrPx> but in order to do the calculations, I need to convert it to floats anyway...
18:07:14 <exio4> arbelos: well, what kind of operations are you doing? and what are you storing?
18:07:17 <SrPx> so I never know if the function itself should just receive a float and use it, or an integer because that makes sense and convert it
18:08:56 * hackagebot text-show-instances 0.4 - Additional instances for text-show  http://hackage.haskell.org/package/text-show-instances-0.4 (ryanglscott)
18:18:42 <Myrl-chan> I'm drawing a Haskell anthromorphism, would it be fine to post it here?
18:21:12 <lfairy> Myrl-chan: go for it
18:22:08 <maerwald> I am trying Leksah now, looks pretty cool
18:22:36 <SrPx> yes Myrl-chan 
18:22:43 <Myrl-chan> Okay. :D http://puu.sh/hQ1fi.png
18:23:06 <MP2E> haha I like it
18:23:16 <Myrl-chan> Thanks! I like the hairpin the most.
18:23:42 <SrPx> the hairpin is neat
18:23:52 <Myrl-chan> I'm making this for my friend's birthday as a gift.
18:23:59 <SrPx> I wish I could draw like that..
18:24:23 <maerwald> SrPx: then you would have to draw all the time
18:24:26 <lfairy> Myrl-chan: you should post it to /r/haskell :)
18:24:52 <Myrl-chan> lfairy: Will do. I also had another one, but it wasn't as well done as this.
18:25:08 <ajf> tempname11_: You seem to be right there's nowhere I can go with sideDist. I'll look at linear.
18:25:33 <Myrl-chan> SrPx: Yeah, what maerwald said. I just kept drawing, sometimes taking 3 month breaks.
18:26:38 <ajf> But I do have tile, deltaDist and step down to a single line each :)
18:27:21 <tempname11_> Myrl-chan: I can't help but notice that the clip actually "binds" the hair xD
18:27:35 <MP2E> :D
18:27:38 <Myrl-chan> tempname11_: :3
18:28:08 <lfairy> tempname11_: O:
18:28:54 <tempname11_> wow, both these emoticons are pretty confusing :)
18:33:19 <Myrl-chan> I'll post it once it's really done, with colors.
18:33:26 <Myrl-chan> I'll post it again once*
18:33:51 <ajf> Is there no function like (a -> b -> c) -> (a, b) -> c
18:33:51 <MP2E> excellent :D
18:33:53 <ajf> ?
18:33:58 <ajf> should I just make one?
18:34:01 <ajf> Hoogle finds nothing
18:34:07 <exio4> curry/uncurry
18:34:08 <Myrl-chan> ajf: I think there's a c
18:34:09 <exio4> @type curry
18:34:10 <lambdabot> ((a, b) -> c) -> a -> b -> c
18:34:11 <Myrl-chan> exio4: dammit.
18:34:12 <exio4> @type uncurry
18:34:13 <lambdabot> (a -> b -> c) -> (a, b) -> c
18:34:15 <ajf> Oh
18:34:21 <exio4> > uncurry (+) (1,2) 
18:34:22 <lambdabot>  3
18:34:23 <ajf> I thought curry didn't do that because I misread its signature
18:34:25 <ajf> I see
18:34:30 <ajf> great, thanks!
18:34:51 <Myrl-chan> @type (curry . uncurry)
18:34:52 <lambdabot> (a -> b -> c) -> a -> b -> c
18:35:00 <ajf> ah
18:35:13 <ajf> Hoogle presents it as (a -> b -> c) -> ((a, b) -> c)
18:35:18 <ajf> the extra brackets confused me
18:35:39 <Myrl-chan> exio4: Also, I drew a newer Haskell-chan.
18:35:48 <ajf> I searched for (a -> b -> c) -> (a, b) -> c
18:35:50 <Myrl-chan> ajf: In a way, that does make more sense though.
18:36:03 <ajf> Myrl-chan: ?
18:36:12 <Myrl-chan> ajf: Hoogle's type signature.
18:38:03 <ajf> Well, yes, it's because that's what it "returns"
18:38:29 <ajf> but currying is ingrained in my brain now
18:38:39 <ajf> :p
18:39:53 <Myrl-chan> ajf: Yeah. :P
18:39:54 <ion> a -> b -> c -> d -> e = a -> (b -> (c -> (d -> e)))
18:45:44 <ajf> deltaDist@(deltaDistX, deltaDistY) = both (swap dir, dir) $ sqrt . (1+) . (uncurry (/)) . (`both` sq)
18:45:52 <ajf> I am proud of this line
18:48:30 <SrPx> Is there any less verbose way to represent a REPA shape? (R.Z R.:. z R.:. y R.:. x) is bad.
18:50:36 <geekosaur> sounds like it really wants a quasiquoter
18:51:05 <SrPx> Maybe, is there one? I'm illiterate on TH. Let me check
18:54:16 <pavonia> :t both
18:54:17 <lambdabot> (Applicative f, Data.Bitraversable.Bitraversable r) => (a -> f b) -> r a a -> f (r b b)
18:56:21 <kaidelong> GHC binaries tend to be linked statically, right?
18:56:31 <Clint> that is the trend
18:56:39 <kaidelong> so if I want hermetic builds, I should be okay copying things out of dist straight into ~/.cabal/bin
18:58:48 <jmcarthur> SrPx: if you don't qualify it it's a bit nicer to read, at least.   (Z :. z :. y :. x)
18:59:17 <SrPx> but REPA has so many name clashes...
19:00:28 <jmcarthur> then only import those identifiers unqualified rather than everything
19:01:12 <SrPx> uhm
19:01:43 <jmcarthur> import qualified Data.Array.Repa as R; import Data.Array.Repa (Z, (:.))
19:02:08 <SrPx> Okay... my imports are growing a lot, though... I'm almost creating a "ImportStuff.hs" file that imports everything I usually use with non clashing names...
19:02:10 * SrPx shrugs
19:02:11 <SrPx> thanks
19:02:26 <jmcarthur> yeah, huge import lists is one of my bigger complaints about haskell in general
19:02:55 <jmcarthur> then again even in languages with nicer module systems i invariably end up with a lot of module-related boilerplate
19:03:24 <SrPx> you guys really need to hear me and create a wikipedia-like repository of independent functions instead of organizing stuff in modules
19:03:37 <exio4> anything non-trivial ends with 15+ imports 
19:03:52 <exio4> well, even trivial things!
19:04:35 <SrPx> I have: Data.List.Util where I define list functions that aren't on prelude. And Debug.Trace.util for traceSelf. and Data.Tree.Util. And Data.Vector.Util.
19:06:24 <SrPx> Because I can't just go and add stuff to Prelude. But that is stupid, my import lists grow even further...
19:06:34 <kaidelong> I get the feeling that type Not a = a -> Void could be rewritten as something akin to data Not a = forall b. a -> b
19:07:10 <SrPx> Ideally I'd just go to HaskellWiki.com, edit the function I need there right on the Prelude and the community removes it from Prelude if it doesn't like, whatever.
19:07:11 <kaidelong> you'd need it wrapped in a constructor of some type
19:07:26 <kaidelong> but would this basic approach work?
19:08:25 <geekosaur> wow, you think the current approach tot he Prelude is bad... edit wars over it?
19:08:27 <jmcarthur> kaidelong: considering Void can just be  forall a. a  i think what you are saying makes sense
19:08:50 <jmcarthur> kaidelong: because  forall b. a -> b  is the same as  a -> forall b. b
19:13:25 <Cale> SrPx: Yeah, back when I started programming in Haskell, imports were a lot less hassle. Hierarchical modules didn't exist yet, and people actively tried to avoid using names that were likely to be in scope from another module.
19:13:43 <Cale> SrPx: You could just  import Set  and not have to worry.
19:15:35 <geekosaur> there were also what, 5 libraries?
19:15:35 <HaskellStudent81> I'm working through Discrete Math Using a Computer, Chapter 4 induction. Working on proofs:
19:15:40 <HaskellStudent81> "Many of the justifications cite the definition of a function, along with the number of the equation in the definition; thus { (+ +) . 1 } means ‘this step is justified by the first equation in the definition of + +’. "
19:15:50 <Cale> geekosaur: Yeah, something like that, a few dozen :D
19:16:00 <HaskellStudent81> Is there somewhere where I can read the equations in functions such as ++ so I can see what they are talking about?
19:16:17 <HaskellStudent81> If it's in the book I haven't seen it 
19:16:28 <Cale> geekosaur: I still consider moving stuff into Data.* and Control.* a mistake
19:17:38 <Cale> HaskellStudent81: hmm, I think if they write something like that, then they ought to include the definition somewhere. If they're just explaining what the notation means in the first place, then it's not important what the definition really is, right?
19:17:43 <Cale> HaskellStudent81: In any case,
19:17:47 <Cale> [] ++ ys = ys
19:17:54 <Cale> (x:xs) ++ ys = x : (xs ++ ys)
19:19:13 <Cale> https://downloads.haskell.org/~ghc/5.02.3/docs/set/book-hslibs.html <-- the libraries when I started, hehe
19:19:31 <HaskellStudent81> Cale: Thanks, I'll keep looking. Haven't seen the actual definitions yet. Just trying to follow along so I can answer these questions about induction
19:20:23 <ion> Cale: heh
19:22:21 <Cale> HaskellStudent81: There's a definition of (++) on page 50 in this pdf that I found
19:22:25 <Cale> http://www.x.edu.uy/inet/Springer.pdf
19:24:01 <HaskellStudent81> Cale: You're a gentleman and a scholar. How did you find that so fast? I guess it would be too much to ask they would mention that in the chapter on recursion
19:24:41 <Cale> I hit Ctrl-F and typed ++ and then Ctrl-G until I found it.
19:25:13 <dreams> HaskellStudent81: Appendix B points you to haskell.org for the library.
19:25:34 <Cale> I knew the definition already though, so it was easier for me to spot visually :)
19:25:48 <HaskellStudent81> you guys are swell :)
19:31:34 <Cale> HaskellStudent81: It would really be more sensible of them to include the relevant definitions in-place before the proof ("Recall that ..."), but it'd probably make the book take too much additional paper to print or something.
19:31:59 <co-arbelos> > let 0 = 1
19:32:01 <lambdabot>  <no location info>: not an expression: ‘let 0 = 1’
19:32:36 <HaskellStudent81> dreams: I see the usage of the functions in the library, but not the definitions
19:32:43 <co-arbelos> > let 0 = 1 in 2
19:32:44 <lambdabot>  2
19:34:03 <dreams> HaskellStudent81: you can access their definition by clicking at "source".
19:34:24 <dreams> > let 0 = 1 in 0
19:34:25 <lambdabot>  0
19:34:36 <arbelos> > let f ~[] = True in f [1,2,3]
19:34:38 <lambdabot>  True
19:34:40 <arbelos> hmm
19:34:43 <ion> > (\ ~0 -> 2) 1
19:34:44 <lambdabot>  2
19:34:52 <arbelos> wat
19:35:16 <ion> That’s basically what’s happening.
19:35:23 <exio4> > let q@0 = 1 in q
19:35:25 <lambdabot>  *Exception: <interactive>:3:5-11: Irrefutable pattern failed for pattern q@0
19:35:29 <dreams> > let ~0 = 1 in 0
19:35:30 <lambdabot>  0
19:35:42 <ion> dreams: let bindings have an implicit ~ already.
19:35:54 <arbelos> ok so it is irrefutable
19:36:22 <dreams> ion: ah.
19:36:39 <arbelos> already
19:36:52 <arbelos> irrefutable already.. without the ~
19:36:53 <arbelos> or?
19:37:36 <HaskellStudent81> dreams: on Haskell.org? I'm not seeing it...
19:38:02 <ion> arbelos: let bindings are irrefutable even without ~
19:38:38 <arbelos> ion, I have to dig into Core to really grok these things in depth
19:38:44 <dreams> HaskellStudent81: https://www.haskell.org/hoogle/
19:38:48 <geekosaur> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-440003.12 "
19:38:54 <geekosaur> er, without the "
19:39:05 <arbelos> not all packages have sources on Hackage
19:40:09 <HaskellStudent81> dreams: oh the source button off to the right. didn't see that 
19:40:13 <HaskellStudent81> thanks
19:40:26 <jgcoded> Hello, I would like to generate combinations of objects using bit strings. What is the best way to represent and modify a bit string in Haskell? Thanks
19:41:03 <arbelos> bitwise operations?
19:41:15 <Cale> jgcoded: Well, there are lots of representations... If you use UArrays of Bool values, they will be packed bitwise.
19:41:41 <Cale> You could use ByteString and bitwise operations on Word8 values from Data.Bits
19:41:42 <arbelos> ah. ok that's different. I was thinking Data.Bits
19:41:58 <Cale> Yeah, Data.Bits provides a lot of the operations you'll likely want to use
19:42:14 <jgcoded> alright
19:43:11 <dreams> geekosaur: (e1, ... ,en) do the mean a tuple by that?
19:43:41 <Cale> If you need to do a lot of mutation, then either using something like an IntMap Bool (pure, a bit less efficient unless you need backtracking for some reason), or STUArray or IOUArray (real mutation) might be appropriate.
19:44:20 <geekosaur> dreams, loosely yes, although that was aimed more at arbelos asking about let patterns being irrefutable
19:44:27 <Cale> You could actually use IntSet values
19:44:42 <Cale> That's probably going to be quite nice in many cases
19:44:58 <dreams> geekosaur: sorry for getting out of context then.
19:45:31 <geekosaur> there's a caveat afterward about how the translation they show is not 100% exact
19:45:39 <arbelos> geekosaur, ah ok I missed that thanks.  This makes me think that let bindings and lambdas are very similar. or.. hmm
19:45:41 <Cale> (i.e. just record the set of positions of the 1 bits)
19:47:02 <geekosaur> lambdas are strict though
19:47:15 <Cale> jgcoded: That'll store them as immutable Patricia tries, and when you make modifications by inserting or removing bits, most of the tree structure will be shared.
19:47:34 <arbelos> but under strict semantics, they are identical to lambda abstractions, or?
19:47:42 <dreams> oh wow. You can go from "let (~p1, ... ,~pn) = (e1, ... ,en) in e0" to "case e1 of ~p -> e0" since you have 1 constructor (the tuple).
19:47:51 <jgcoded> Cale: yeah I just read about them on hackage. I'm still looking at the other things too
19:59:35 <jgcoded> How do I use an IntSet? I want to start off by just having a bit string of length n of all zeroes
20:00:35 <pavonia> I guess that's "empty"
20:04:52 <jgcoded> ah ok. So I used IntSet.singleton 8 to create my IntSet
20:05:21 <pacak> jgcoded: Which gave you IntSet with one element = 8.
20:06:02 <jgcoded> yeah
20:06:11 <pacak> Which is probably not what you want.
20:06:47 <jgcoded> no I need a function that will make my bitstring of length n
20:06:55 <unknownloner> What do you need to install to get haskell without using the haskell platform?
20:07:06 <pacak> unknownloner: ghc, cabal.
20:07:22 <pacak> jgcoded: You can have a look at IntMap Bool instead.
20:07:43 <pavonia> jgcoded: Don't think in terms of bitstrings here. An IntSet is just a set of Int values
20:08:05 <pacak> Or you can still use IntSet by querying for every bit if it's present or not.
20:08:07 <pavonia> If we are talking about Data.IntSet, that is
20:08:12 <pacak> :t singleton
20:08:13 <lambdabot>     Not in scope: ‘singleton’
20:08:13 <lambdabot>     Perhaps you meant one of these:
20:08:13 <lambdabot>       ‘BS.singleton’ (imported from Data.ByteString),
20:09:21 <KaneTW>  [/go 24
20:09:25 <KaneTW> oops
20:09:50 <pacak> > map (`elem` [2,4]) [0..7]
20:09:51 <lambdabot>  [False,False,True,False,True,False,False,False]
20:10:06 <pacak> Just with IntSet instead of `elem` [2,4]
20:14:20 <pacak> > map (testBit (12  :: Int)) [0..16]
20:14:22 <lambdabot>  [False,False,True,True,False,False,False,False,False,False,False,False,False...
20:15:08 <pacak> jgcoded: If 64 bits is enough for you you can use Int instead of IntSet
20:17:18 <jgcoded> pacak: yeah that could work for me for now
20:17:43 <pavonia> > setBit 0 128 :: Integer
20:17:45 <lambdabot>  340282366920938463463374607431768211456
20:19:09 <ion> > setBit 0 1000000000000000 * 0 :: Integer
20:19:11 <lambdabot>  0
20:19:13 <Welkin> :t setBit
20:19:14 <lambdabot> Bits a => a -> Int -> a
20:19:16 <ion> > setBit 0 1000000000000000 :: Integer
20:19:17 <lambdabot>  mueval-core: out of memory
20:19:48 <ion> > 0 * setBit 0 1000000000000000 :: Integer
20:19:49 <lambdabot>  mueval-core: out of memory
20:20:19 <Welkin> > setBit 0 1
20:20:20 <lambdabot>  2
20:20:26 <Welkin> > setBit 0 0
20:20:28 <lambdabot>  1
20:39:03 <abhillman> Hi! Supposing I want to create a new data type with "data" and I want the constructor to take a Data.Map.Strict for one of its fields -- is there a great way to do this? I'm having trouble figuring out how to do this/whether it is possible.
20:39:12 <abhillman> * Data.Map.Strict.Map
20:39:33 <geekosaur> there isn't really such a type
20:39:40 <ajf> Would that not be uh
20:39:43 <geekosaur> it's all Data.Map.Map; the *operations* are strict
20:39:52 <ajf> data Foobar = Map foo bar
20:39:53 <abhillman> geekosaur: Ah...
20:40:02 <ajf> *data Foobar = Foobar Map foo bar
20:40:32 <pacak> data Foobar = Foobar (Map foo bar) ...
20:40:40 <ajf> yeah
20:41:17 <abhillman> Thanks a ton
20:41:17 <pacak> data Foobar a b = Foobar (Map a b) ...
20:41:20 <geekosaur> so whether it's strict or not isn't part of the type, it's which module's functions you use to manipulate it. which is a little unfortunate if you were hoping for type safety in that regard
20:42:05 <abhillman> In general, is usage of Data.Map.Map considered fairly idiomatic in Haskell?
20:42:34 <pacak> abhillman: Sire
20:42:35 <pacak> sure
20:44:42 <abhillman> Is there a great code style guide for record syntax?
20:45:06 <abhillman> And syntax in general
20:45:56 <pacak> abhillman: Reading code from Prelude and base helps
21:00:26 <abhillman> Supposing I have a data type declared like "data X = X [String]" and I want to get the the length of the value that X holds. I could write some method like "xLength (X l) = length l" and use that. Is there a way to do this without writing a function?
21:02:15 <verement> :t length
21:02:17 <lambdabot> Foldable t => t a -> Int
21:02:32 <pacak> You can make your type into a Functor and use fmap length on it - resulting length will be still wrapped inside X
21:02:47 <pacak> You can make a custom Foldable instance
21:03:11 <pacak> abhillman: You can use lens
21:03:31 <c_wraith> That data type can't be a Functor or Foldable
21:03:35 <pacak> to write that function for you
21:03:49 <pacak> c_wraith: It can if you change it a bit
21:03:54 <MichaelBurge> If you use a newtype instead, I think this is safe: length $ (coerce x :: [ String ])
21:05:43 <c_wraith> in a simpler but equally not-an-improvement vein, you can just write (let (X l) in length l) as an expression!
21:06:15 <c_wraith> Err.  (let (X l) = foo in length l)
21:06:19 <abhillman> c_wraith: Nice, that is interesting
21:06:36 <c_wraith> You're best off just writing the function. :)
21:06:38 <pacak> data X = X { unX :: [String]}
21:06:44 <pacak> length' = length . unX
21:06:52 <abhillman> pacak: Nice, yea
21:07:17 <abhillman> I'm trying to write the Functor instance -- is it possible to do this with the data type declaration "data X = X [String]"
21:07:38 <HeladoDeBrownie> no, it has the wrong kind. it would need to have at least one type parameter
21:07:40 <pacak> abhillman: Nope, but if you change it to data X a = X a - you can
21:07:51 <HeladoDeBrownie> notice how in
21:07:53 <HeladoDeBrownie> @type fmap
21:07:54 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:07:55 <pacak> data X a = X { unX :: a }
21:08:00 <HeladoDeBrownie> f is applied to a type
21:08:07 <pacak> :k Maybe
21:08:08 <lambdabot> * -> *
21:08:11 <HeladoDeBrownie> substituting f for X, you obviously can't apply X to anything
21:09:19 <pacak> There's always unsafeCorce. Not sure how to use it nicely in this case, but I've managed to crash my ghci twice already :)
21:09:43 <johnw> unsafeCorce would only work with newtype, not data here
21:09:43 <HeladoDeBrownie> coerce is superior when possible
21:09:47 <MichaelBurge> pacak: I don't think you can. unsafeCoerce doesn't work with data types
21:10:02 <pacak> MichaelBurge: Sure it works
21:10:23 <johnw> we define works by not crashing your ghci twice
21:11:37 <pacak> Prelude Unsafe.Coerce> length $ unsafeCoerce  (Left ())
21:11:37 <pacak> 0
21:11:37 <pacak> Prelude Unsafe.Coerce> length $ unsafeCoerce  (Right $ Left ())
21:11:37 <pacak> 1
21:11:58 <MichaelBurge>  > (unsafeCoerce [ 5] ) :: IO Int
21:11:59 <abhillman> I wish I could write the functor instance for "data X = X [String]" -- is being able to do this a violation of the definition of functor?
21:12:16 <abhillman> * of a functor in general? More a Haskell98 thing? 
21:12:33 <johnw> why would that be a violation?
21:12:54 <pacak> abhillman: Functor is a structure preserving  container for data points and morphisms. You can't put any morphisms inside X [String]
21:13:27 <johnw> pacak: your example is kind of lucking out
21:13:36 <HeladoDeBrownie> abhillman, X is a concrete type (*). a type that has a Functor instance must be a (type-level) function from a concrete type to a concrete type (* -> *).
21:14:00 <HeladoDeBrownie> (those things i wrote in parens are called kinds)
21:14:25 <pacak> johnw: As long as fields are in about right place and constructors in right order it works fine.
21:14:31 <johnw> yeah
21:14:43 <johnw> why do you want to even do that though?
21:14:51 <pacak> Prelude > unsafeCoerce (Left ()) :: Maybe ()
21:14:51 <pacak> Nothing
21:14:52 <pacak> Prelude > unsafeCoerce (Right ()) :: Maybe ()
21:14:52 <pacak> Just ()
21:14:59 <KaneTW> are there different sorts/... in ghc or is the highest type level kinds
21:15:11 <abhillman> pacak: I am curious about the lens approach -- can you say more?
21:15:11 <HeladoDeBrownie> there's exactly one sort afaik
21:15:33 <pacak> johnw: Well... If you want to poke around inside some data structure and library author decided that it's not worth exposing.
21:15:41 <KaneTW> that's what i remember too
21:15:50 <johnw> pacak: ah
21:16:15 <johnw> pacak: I've actually had a case of that, but I still would avoid unsafeCoerce.  That's an implementation dependency that's extremely likely to change underneath me in a very hard to discover way
21:16:36 <jgcoded> woot!! I made my combinations generator! thanks guys!!!
21:17:20 <pacak> johnw: Sure. It's not like I'm using it all over the place, more like "if everything else fails..." but it's there and it works if used carefully enough.
21:17:22 <pacak> :t coerce
21:17:23 <lambdabot> (Functor f, Contravariant f) => f a -> f b
21:17:31 <HeladoDeBrownie> that's the wrong coerce
21:17:34 <mozzarella> guys
21:17:52 <mozzarella> "For instance, the length function has a type declaration of length :: [a] -03> Int instead of having a more general type of (Num b) =03> length :: [a] -03> b."
21:17:54 <pacak> HeladoDeBrownie: Less excitement.
21:18:09 <mozzarella> shouldn't the more general type use Integral instead of Num?
21:18:10 <pacak> And it was introduced recently
21:18:18 <pacak> :t genericLength
21:18:20 <lambdabot> Num i => [a] -> i
21:18:42 <pacak> mozzarella: How often do you have to work with linked lists longer than 2^64?
21:18:43 <HeladoDeBrownie> pacak, i believe this is the one https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Coerce.html
21:19:36 <pacak> abhillman: Well, first you need to define lens instance for your X then use it. It won't be much different to length . unX
21:19:49 <geekosaur> there is no particular reason it needs to be limited to Integral
21:19:54 <abhillman> pacak: Gotcha'
21:20:00 <mozzarella> pacak: Num includes real numbers, right? does it make sense to use a real number for a length?
21:20:26 <pacak> mozzarella: Can you show me a list with 3.141592 elements please?
21:21:04 <HeladoDeBrownie> mozzarella, the output of genericLength will always be integer-valued, but may be of a type including non-integers.
21:21:32 <newsham> > 1.0 / 8
21:21:33 <lambdabot>  0.125
21:21:35 <geekosaur> it may make sense to get the result as a Double, and there is no particular reason to stop you from adding 1.0 for each element instead of 1. that a list won't have 3.14159 elements does not mean you should only be allowed to use integral types there
21:21:42 <jgcoded> I would like to have my combinations generator code reviewed. If you have the time, then I would really really appreciate the feedback: http://lpaste.net/132773
21:21:44 <mozzarella> I just wonder why the author would write Num instead of Integral
21:21:50 <newsham> want a list of length 3.125?
21:22:03 <pacak> > 3 :: Double
21:22:04 <geekosaur> because there's less to implement
21:22:04 <lambdabot>  3.0
21:22:06 <mozzarella> HeladoDeBrownie: in which cases?
21:22:31 <pacak> Not every number can be represented as Double
21:22:44 <HeladoDeBrownie> mozzarella, when you specify that it should be by restricting its type.
21:22:52 <pacak> Floating point numbers are evil.
21:23:02 <HeladoDeBrownie> > genericLength [1, 2, 3] :: Double -- for example
21:23:04 <lambdabot>  3.0
21:23:07 <johnw> they only approximate evil poorly
21:23:11 <MP2E> haha
21:23:18 <abhillman> When I message lambdabot ":t length" it mentions the Foldable typeclass. Yet when I type ":t length" in GHCi, it returns "length :: [a] -> Int". Morover, Hackage mentions the same as GHCi. It seems like lambdabot is doing something clever -- length relies on foldl', which is an instance of the Foldable typeclass. Is there some resource like lambdabot that lists the Foldable typeclass?
21:23:43 <pacak> abhillman: You are using ancient version of ghc probably
21:23:53 <msd> Hi, please help. Given a tree like t1 = Node 'A' [Node 'B' [Node 'B' [],Node 'B' []],Node 'C'[]], How can I count the number of leaves.
21:24:21 <msd> t1 = Node 'A' [Node 'B' [Node 'C' [],Node 'D' []],Node 'E'[]]
21:24:33 <HeladoDeBrownie> msd, start by counting the leaves of the one-node tree. then define the count of leaves of larger trees in terms of that.
21:24:33 <geekosaur> abhillman, lambdabot is running ghc 7.10.1, and the current hackage docs were generated from that. the switch to Foldable was in that version. if you have an older ghci it won't know about it
21:24:48 <Axman6> msd: well, how do you know if a Node is a leaf?
21:24:49 <pacak> msd: By using catamorphism?
21:24:55 <pacak> :t cata
21:24:57 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
21:25:01 <Axman6> no...
21:25:12 <jgcoded> msd: I'd make a function that does pattern matching on an input tree
21:25:20 <HeladoDeBrownie> msd, pardon, i misread, although the details aren't far off
21:25:39 <newsham> if you have a leaf, return 1, if you have an internal node, return sum of left an dright?
21:25:40 <msd> Axman6 : The last Node with ) length list as subtree, like Node C, D and E in Node 'A' [Node 'B' [Node 'C' [],Node 'D' []],Node 'E'[]]
21:26:03 <msd> 0 length subtree
21:26:25 <newsham> ?let data Msd = Node Char [Msd]
21:26:27 <lambdabot>  Defined.
21:26:34 <newsham> ?let t1 = Node 'A' [Node 'B' [Node 'C' [],Node 'D' []],Node 'E'[]]
21:26:35 <lambdabot>  .L.hs:149:6:
21:26:35 <lambdabot>      Ambiguous occurrence ‘Node’
21:26:35 <lambdabot>      It could refer to either ‘L.Node’, defined at .L.hs:148:12
21:26:37 <msd> Yes, 
21:26:39 <Axman6> msd: ok, good. so we know what to do when we come across a leaf node. what do we do if we find a non leaf node?
21:26:48 <pacak> > (`div` 2) . length $ filter (== '\'') $ "Node 'A' [Node 'B' [Node 'B' [],Node 'B' []],Node 'C'[]]"
21:26:49 <msd> Its common tree data structure
21:26:50 <lambdabot>  5
21:26:56 <pacak> msd: 5 of them!
21:27:15 <geekosaur> abhillman, note that the generalization of lists to Foldable and/or Traversable breaks some things, so you may not want to rush to the new version right away
21:27:22 <Axman6> pacak: you're not helping
21:27:29 <msd> pacak : there are 3 leaves
21:27:49 <Axman6> in fact, you're actively being unhelpful
21:28:36 <msd> Axman6 : How to do?
21:29:00 <Axman6> msd: so, what do we do when we're trying to count the leaves present in a node which isn't a leaf? so node A in Node 'A' [Node 'B' [], Node 'C' []] 
21:29:45 <msd> Axman6 : No idea, i just want to take a count of leave nodes in my implementation
21:29:54 <Axman6> right, I
21:30:03 <Axman6> I'm trying to guide you to how you do that.
21:30:15 <msd> ok
21:30:46 <Axman6> let's start with the type, what's the type of the leaves function? leaves :: ?
21:30:58 <msd> Tree -> Int
21:31:02 <Axman6> good
21:31:38 <Axman6> ok, we can use pattern matching to decide whether a given tree is a leaf or not. so, for the leaf case: leaves ? = ?
21:31:56 <Axman6> (don't worry about the non-leaf case yet)
21:32:47 <newsham> > (t1, nlen t1)
21:32:48 <lambdabot>  (Node {rootLabel = 'A', subForest = [Node {rootLabel = 'B', subForest = [Nod...
21:32:57 <newsham> > nlen t1
21:32:59 <lambdabot>  5
21:34:05 <msd> Axman6 : leaves a [] = 1, leaves a ts = map leaves ts ???
21:34:09 <Axman6> msd: any idea? feel free to ask questions
21:34:13 <Axman6> oops =)
21:34:25 <Axman6> not quite
21:34:34 <msd> Axman6 : sorry I am very new here
21:35:12 <Axman6> so, the pattern for a Leaf is: (Node _ []), so we get: leaves (Node _ []) = 1. you were pretty clode
21:35:57 <msd> ok, then map over whole tree?
21:36:29 <Axman6> your next one is close, but not quite right. the map is good, we need to count how many leaves there are in the sub forrests, but we also need to add them together: leaves (Node a ts) = ? (map leaves ts)
21:37:05 <Axman6> (or leaves (Node _ ts) = ... because we don't care about the Char in the node, and it's good to make that explicit)
21:38:36 <msd> (1 + foo leaves (Node a ts)) map leaves ts
21:38:50 <msd> wherer foo is pattern matching function
21:39:02 <Axman6> not quite
21:39:19 <Axman6> so far we have:
21:39:24 <Axman6> leaves :: Tree -> Int
21:39:34 <Axman6> leaves (Node _ []) = 1
21:39:52 <Axman6> leaves (Node _ ts) = ? (map leaves ts)
21:39:59 <Axman6> need to fill in the ?
21:40:44 <msd> 1 + 
21:40:57 <Axman6> why 1 +?
21:41:03 <Axman6> :t map
21:41:04 <lambdabot> (a -> b) -> [a] -> [b]
21:42:01 <Axman6> what type does `map leaves ts` give us?
21:42:29 <msd> [Int]
21:42:48 <Axman6> yes! =)
21:42:58 <Axman6> and what do those Ints represent?
21:43:08 <msd> leaves of each trees in the list
21:43:13 <Axman6> yep!
21:43:21 <msd> so i add them all.. yeppe
21:43:28 <Axman6> yes! =D
21:43:32 <Axman6> :t sum
21:43:33 <lambdabot> (Num a, Foldable t) => t a -> a
21:43:37 <Axman6> bleh
21:43:40 <msd> oh.. thanks :) 
21:43:48 <Axman6> :t sum `asAppliedTo`[1::Int]
21:43:49 <lambdabot> [Int] -> Int
21:44:07 <Axman6> so, what's the full function?
21:44:52 <msd> I didn't get :t sum `asAppliedTo`[1::Int], I was trying to sum manually
21:45:33 <Axman6> the sum function has type [Int] -> Int (it's more general, but I was trying to show it has the type you need)
21:45:55 <msd> ok
21:46:21 <msd> so its sum (map leaves ts)
21:46:28 <Axman6> looks pretty good to me
21:46:39 <msd> Thanks a lot :)
21:46:44 <Axman6> if you haven't seen sum before, it would be worth trying to define it by yourself also
21:46:53 <msd> hmm.. ok
21:47:02 <Axman6> sum :: [Int] -> Int
21:47:39 <jgcoded> what do you guys do if you have some variable you want to pass around to functions but you don't want to add in an extra parameter to all your functions?
21:48:53 <Axman6> use Reader or State
21:49:05 <Axman6> (depending on whether it needs to change or not)
21:49:32 <jgcoded> nah it's just a base case variable that my recursive functions need to be aware of
21:50:30 <HeladoDeBrownie> jgcoded, definitions in where clauses can view the parameters of the parent function. recurse using some 'go' function defined in a where clause
21:51:02 <HeladoDeBrownie> f x = go 0 where go = somethingInTermsOfX
21:51:07 <HeladoDeBrownie> (with appropriate line breaks)
21:51:28 <jgcoded> ah let me try that
21:59:54 <jgcoded> HeladoDeBrownie: doing it that way made me realize my subfunctions didn't need to know about the base case, so that was pretty cool
22:03:13 <SrPx> Seems like `foldl1' max (zipWith min [t1,t3,t5] [t2,t4,t6])` has much worse performance than `max (max (min t1 t2) (min t3 t4)) (min t5 t6)`. Interesting, I expected GHC to inline that...
22:07:27 <c_wraith> ghc doesn't inline recursive things
22:09:46 <hiptobecubic> Is it just very difficult to do something like DFS efficiently? I have an implementation that works in the way I want, but it's really complicated looking. How would I fix this thing? http://lpaste.net/132779
22:10:24 <SrPx> c_wraith: I thought Data.List used non recursive streams... or something. Meh
22:19:04 * hackagebot lambda-options 0.5.1.0 - A modern command-line parser for Haskell.  http://hackage.haskell.org/package/lambda-options-0.5.1.0 (ThomasEding)
22:26:28 <johnw> ooh, it's Sunday, time for a new CLI options parser
22:27:21 <Axman6> i fucking hate cabal sometimes. I have something that compiles on one machine, but can't resolve deps on another, both in sandboxes. what's the bloody point of sandboxes then?
22:27:53 <johnw> same architectures?
22:28:09 <Axman6> yes, same OS, almost the same hardware even
22:28:26 <johnw> try rsync'ing the sandbox?
22:28:37 <Axman6> hmm, I could do that I guess
22:28:50 <Axman6> but I want to know why it's breaking
22:29:03 <johnw> yeah, I avoid cabal completely
22:29:04 * hackagebot up 0.1.0.3 - Command line tool to generate pathnames to facilitate moving upward in a file system.  http://hackage.haskell.org/package/up-0.1.0.3 (ThomasEding)
22:29:06 * hackagebot up 1.0.0.3 - Command line tool to generate pathnames to facilitate moving upward in a file system.  http://hackage.haskell.org/package/up-1.0.0.3 (ThomasEding)
22:30:34 <Axman6> If anyone knows how to deal with mtl/transformers being a complete mess, here's what cabal is saying to me: http://lpaste.net/132782
22:33:05 <nshepperd> check the global package database on both machines
22:34:04 * hackagebot json-rpc-client 0.1.3.0 - JSON-RPC 2.0 on the client side.  http://hackage.haskell.org/package/json-rpc-client-0.1.3.0 (grayjay)
22:34:11 <Axman6> isn't the point of a sandbox to ignore the global database?
22:34:55 <jle`> some packages are baked into ghc so can't be ignored
22:35:36 <Axman6> right, but I'm using the same GHC versions
22:35:41 <Axman6> s/s/
22:35:57 <hiptobecubic> I ended up writing the question up on codereview.stackexchange: http://codereview.stackexchange.com/questions/90954/detecting-cycles-in-a-graph-without-using-mutable-sets-of-nodes-haskell
22:36:06 <nshepperd> a sandbox ignores the *user* database
22:36:22 <Axman6> right, yes
22:37:14 <Axman6> checking the two global databases shows identical versions of everything
22:39:45 <nshepperd> you're using ghc 7.8?
22:40:33 <Axman6> yes
22:43:35 <jgcoded> alright so I have another question. Look at these two functions: getInputLinesAsStrings :: Int -> IO [String] and  getInputLinesAsInts :: Int -> IO [Int]. Assume both of these guys are implemented and they work just as they're named. How would I create a single function that can take in any type and return a list of that type?
22:44:04 <jgcoded> from user input
22:44:29 <jgcoded> and you're guaranteed that the user will only enter in one type of data
22:44:47 <jle`> jgcoded: you'd probably want something of type Read a => Int -> IO [a]
22:44:52 <jle`> but this won't work for String
22:45:17 <jgcoded> I'll replace it with [Char] then
22:45:20 <jle`> because the string '"hello"' will parse as a String
22:45:31 <jle`> but 'hello' won't parse as a Strong nor as a [Char]
22:45:46 <nshepperd> things that I could imagine would explain the difference are: different stuff in the global database, leftover junk in the sandbox from a previous failed build, different versions of cabal-install, older/newer hackage caches (thing touched by 'cabal update')
22:45:52 <jle`> your best bet would be to use getInputLinesAsStrings as itself, and offer it
22:45:58 <thomaseding> Just create your own Parse type that has parse :: String -> String = id
22:46:13 <thomaseding> And for other types, line them with read or something
22:46:22 <jle`> yeah, you can just use `fmap` on your getInputLinesAsStrings
22:46:25 <thomaseding> class, not type*
22:47:10 <jgcoded> alright I'll try both ways
22:48:14 <nshepperd> getInputLinesAs :: (String -> a) -> IO [a]
22:49:43 <nshepperd> eh, 'getInputLinesAs :: (String -> a) -> Int -> IO [a]' obv
22:50:32 <thomaseding> or : (String -> Maybe a) -> Iny -> IO [Maybe a]
22:51:05 <thomaseding> well, I guess that's just a special case... nvm
22:51:39 <jgcoded> nshepperd: that doesn't work when i define it as getInputLinesAs f n = fmap (map f) (replicateM n getLine)
22:52:17 <jle`> what do you mean by "doesn't work" ?
22:52:50 <jgcoded> it gives me an exception: Prelude.read: no parse
22:53:05 <jgcoded> if I provide the function read as input
22:53:39 <thomaseding> try that definition with: getInputLinesAs Text.Read.readMaybe
22:54:08 <jle`> you also have to specify what type you want at the end
22:54:10 <nshepperd> if you want to parse the line into an int or whatever, use getInputLinesAs read n
22:54:15 <jle`> otherwise it won't know what to read it as
22:54:45 <nshepperd> if you just want each line as a String, getInputLinesAs id n
22:55:28 <nshepperd> and yeah, need a type annotation with 'read', or else it will default to ()
22:56:26 <jgcoded> ah ok that type annotation with read solved it. Using the Text.Read.readMaybe just returned a list of Nothings
22:56:41 <jgcoded> this is a very nice snippet of code
22:57:12 <Axman6> ffs, I can't understand how cabal is rejecting exactly the versions of libraries that worked fine on my work machine. this is so messed up
22:59:05 * hackagebot hipbot 0.3.0.1 - A library for building HipChat Bots  http://hackage.haskell.org/package/hipbot-0.3.0.1 (purefn)
23:01:14 <Axman6> oh jesus, it's even worse than tht. if I move the sandbox on the system that's working and then try to run cabal install --only-dependencies again it also can't find a consistent set of packages. how the fuck did this ever work then >_<
23:13:32 <HeladoDeBrownie> Axman6, at the very least sandboxes fail to function if their absolute path changes
23:14:01 <HeladoDeBrownie> (i didn't see the rest of the conversation, just those two lines)
23:14:20 <jle`> is id the only forall a. a -> a ?
23:14:27 <johnw> up to ⊥
23:16:12 <jle`> hm
23:16:17 <Axman6> HeladoDeBrownie: nah I've checked out a clean repo not copied it
23:16:19 <jle`> ty
23:20:06 <thomaseding> jle`: I believe so
23:21:15 <jle`> i figured but for some reason i was hoping for another answer v.v
23:24:59 <cmicallef> \part
23:27:47 <johnw> jle`: why?
23:28:08 <jle`> the abstraction i was trying to build fell apart
23:28:24 <johnw> "given something I know absolutely nothing about, the only way I can give back to you another something of the same type is to give you back what you passed to me"
23:28:48 <jle`> but i wanted so badly to hope...
23:28:50 <jle`> ;_;
23:29:03 <johnw> i'm not sure you'd want a world that allowed other implementations, really :)
23:29:11 <jle`> indeed
23:29:48 <jle`> parametricity has thrown a wrench into a lot of things i have thought about over the past years.  but i guess in the end i'm happy at what it prevents me from doing...
23:31:36 <abhillman> Any general suggestions? This is my first attempt at a relatively more complex haskell program. https://gist.github.com/abhillman/4b2f9b3b6aec58ec7859
23:32:11 <abhillman> Lines are a bit too long so maybe some things need to get broken into separate functions
23:32:22 <johnw> i'd much rather seen a <return> after a "do"
23:32:34 <johnw> that would help readability here immensely
23:32:50 <johnw> or, if you prefer, then a <return> before the do
23:35:05 <jle`> abhillman: i think your do blocks are sort of unecessary
23:35:20 <jle`> you're not doing anything with monads
23:35:23 <lain1> You could "import Data.Map (Map)" so you don't have to qualify Data.Map.Map all the time
23:35:24 <jle`> why not just simple where bindings?
23:35:43 <jle`> normalCoinsTest = frorwardProbability ["heads","tails"] hmm
23:35:45 <jle`>   where
23:35:47 <jle`>     hmm = ....
23:36:18 <jle`> what you're doing is 'legal', but would be considered by most to be an abuse of syntax
23:36:26 <jle`> and makes things more confusing when someone is reading it, heh
23:36:37 <nshepperd> Axman6: did you try remaking the sandbox...
23:37:30 <abhillman> Nice, thanks for the comments
23:37:37 <abhillman> Makes sense about the do-block
23:37:54 <abhillman> Like the idea about the unqualified Map reference
23:38:35 <abhillman> I think it makes sense to remove the do block and use where bindings
23:38:57 <abhillman> Thanks!
23:39:13 <jle`> yeah, or at least let ... in ..., which is a bit less idiomatic than where, but at least is not an abuse of syntax, heh
23:39:41 <abhillman> What is the general feeling about long lines? Generally accepted in Haskell? Same general sentiment as any other language? Usually I try to remain under, though I know it's a bit of a personal preference
23:40:15 <jle`> i think it's good practice in general to avoid long lines
23:40:27 <dmj`> abhillman: some haskell style guides say ~70 lines I think
23:40:50 <dmj`> abhillman: this one says 80
23:40:54 <dmj`> https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
23:41:10 <dmj`> derp, 70 characters*
23:45:37 <Axman6> nshepperd: yes, several times. these errors are all happening with a clean sandbox
23:46:46 <abhillman> How does this look? https://gist.github.com/abhillman/4b2f9b3b6aec58ec7859
23:46:55 <abhillman> Incorporated some comments
23:48:18 <jle`> abhillman: you can do the same `do` thing for forwardProbability and forwardVariable
23:48:23 <jle`> all of your do blocks are unecessary, heh
23:48:41 <abhillman> Oh, they should be gone
23:48:47 <jle`> where block can be moved to column 2
23:48:48 <abhillman> Make sure to refresh browser cache maybe?
23:48:56 <jle`> oh i see
23:48:56 <abhillman> Not sure why you are seeing them
23:49:09 <jle`> it was cause the where blocks started so far to the right heh
23:49:22 <pacak> abhillman: You don't really need to write Data.Map.Map 
23:49:23 <jle`> eyes asusmed they were still in a do block
23:49:29 <abhillman> Yea, need to work on fixing the long lines
23:49:30 <abhillman> RIGHT
23:49:33 <abhillman> Data.Map.Map
23:49:57 <nshepperd> Axman6: maybe you used --allow-newer when you originally compiled on your work machine
23:50:01 <nshepperd> even if you didn't
23:50:19 <nshepperd> that might give you a different error, at least
23:50:26 <jle`> normalCoinsTest = forwardProbability ...
23:50:28 <jle`>   where
23:50:30 <jle`>     hmm = ...
23:50:32 <jle`> try that :)
23:50:53 <pacak> abhillman: On lines like 18 I usally break the line right after =, then put 8 spaces and start writing from there
23:51:24 <Axman6> nshepperd: I have been trying using that, I'll see if anything I've tried now makes it work with that
23:51:25 <abhillman> Fixed the Data.Map qualification thing https://gist.github.com/abhillman/4b2f9b3b6aec58ec7859
23:52:21 <pacak> abhillman: Next, I usually import Data.Map qualified as M and import Data.Map (Map) - this way you can use several different containers
23:53:21 <jle`> abhillman: i'd use guards instad of if/then/else for forwardVariable... forwardVariable time state sequence hmm | time = 0 = startProb
23:53:28 <jle`>    | otherwise = summatio ...
23:54:07 * hackagebot hipbot 0.3.0.2 - A library for building HipChat Bots  http://hackage.haskell.org/package/hipbot-0.3.0.2 (purefn)
23:54:21 <abhillman> jle`: I was thinking about that. But (and this is somehwat minor) each guard would require the symbol from the where clause
23:54:27 <jle`> also it makes me a bit uncomforable that you shadow a function from Prelude, but that's technically not wrong
23:54:32 <jle`> abhillman: that's fine for guards
23:55:30 <abhillman> jle`: Which function is shadowed?
23:55:35 <jle`> `sequence`
23:55:55 <jle`> i mean...it's technically not wrong and i'm sure a lot of people shadow prelude stuff all the time, heh
23:56:02 <jle`> it's not a big deal
23:56:11 <abhillman> Gotcha' -- nice eye
23:56:26 <pacak> abhillman: You are using list comprehensions as map which is not bad, but a bit unusual.
23:57:01 <abhillman> pacak: Interesting, true
23:59:20 <abhillman> Updated it
