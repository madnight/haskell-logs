00:00:15 <m_ryan> liste and dmj`: i derive from this blog: http://www.yesodweb.com/book/visitor-counter
00:01:15 <liste> m_ryan yeah, in that case the web server takes the handlers as input and runs as an IO action
00:05:16 <liste> so if you have Handlers, you need a web server (warp in that case) to run them
00:06:17 <m_ryan> liste & djm`: here is my code http://lpaste.net/132905
00:07:36 * hackagebot stackage-upload 0.1.0.5 - A more secure version of cabal upload which uses HTTPS  http://hackage.haskell.org/package/stackage-upload-0.1.0.5 (MichaelSnoyman)
00:07:36 * hackagebot atlassian-connect-core 0.6.0.0 - Atlassian Connect snaplet for the Snap Framework and helper code.  http://hackage.haskell.org/package/atlassian-connect-core-0.6.0.0 (RobertMassaioli)
00:11:12 <m_ryan> liste & dmj`: here is my code http://lpaste.net/132905
00:12:15 <liste> m_ryan that qrylatestAvgPrices is run on program startup?
00:12:15 <a21> im trying to write a ffi in haskell, where does cabal expect the header.h files to be?
00:12:21 <liste> then it should'nt be a Handler
00:12:25 <liste> Handler handles web requests
00:12:31 * hackagebot yesod-bin 1.4.9.2 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.9.2 (MichaelSnoyman)
00:12:52 <m_ryan> liste: what should be the type?
00:13:15 <m_ryan> liste: is it also an IO [RawLatestAvgPrices]?
00:14:10 <liste> m_ryan something like ConnectonPool -> Int -> IO [RawLatestAvgPrices]
00:16:18 <m_ryan> liste: but that function will be called by some Handler. Then what is ConnectionPool?
00:17:32 * hackagebot http-reverse-proxy 0.4.2 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.4.2 (MichaelSnoyman)
00:22:20 <m_ryan> liste: any suggestion?
00:23:07 <a21> anyone?
00:26:13 <liste> m_ryan I guess the best type for qrylatestAvgPrices would be something like SqlBackend -> Int -> IO [RawLatestAvgPrices]
00:27:14 <liste> because yesod-persistent's runDB lifts a YesodDB action to a Handler action
00:27:23 <m_ryan> liste: can you edit the paste, can understand very well sorry
00:27:32 * hackagebot memcache 0.1.0.0 - A memcached client library.  http://hackage.haskell.org/package/memcache-0.1.0.0 (DavidTerei)
00:27:53 <frerich> a21: After skimming https://www.haskell.org/cabal/users-guide/developing-packages.html I'd suspect that 'include-dirs' can be used to specify where cabal will search for C headers, and 'includes' gives the list of headers.
00:28:18 <frerich> a21: Never tried it myself, but I guess a guesstimate is better than no response at all.
00:28:25 <liste> YesodDB is just ReaderT (YesodPersistBackend ...) ...
00:28:35 <liste> and the YesodPersistBackend is in this case a SqlBackend
00:29:25 <liste> so you can runDB $ ask >>= qrylatestAvgPrices
00:29:49 <a21> frerich: thanks!
00:30:23 <liste> if qrylatestAvgPrices is SqlBackend -> Int -> IO [RawLatestAvgPrices]
00:30:58 <liste> actually Int -> SqlBackend -> IO [RawLatestAvgPrices]
00:32:26 <liste> actually runDB $ ask >>= \backend -> liftIO (qrylatestAvgPrices 5 backend)
00:34:03 <_m_ryan> liste: if that is the case, how will i call the qrylatestAvgPrices?
00:35:10 <liste> _m_ryan something like this (in Handler): prices <- runDB $ ask >>= \backend -> liftIO (qrylatestAvgPrices <number> backend)
00:35:44 <_m_ryan> liste: in my appMain :: IO () is it the same?
00:36:15 <liste> _m_ryan no
00:36:32 <_m_ryan> liste: how?
00:37:33 * hackagebot haskellscript 0.1.1 - Command line tool for running Haskell scripts with a hashbang.  http://hackage.haskell.org/package/haskellscript-0.1.1 (seanparsons)
00:38:24 <absence> can i define typeclass instances in a session with lambdabot?
00:38:48 <jle`> yes
00:39:18 <jle`>  @let instance ... where ....
00:39:22 <liste> _m_ryan you need withResource for that
00:39:59 <absence> jle`: thanks!
00:40:00 <liste> https://www.stackage.org/haddock/nightly-2015-05-19/resource-pool-0.2.3.2/Data-Pool.html#v:withResource
00:40:04 <jle`> np!
00:44:20 <_m_ryan> liste: what is the difference b/w ConnectionPool and SqlBackend?
00:44:39 <liste> _m_ryan depends on the version, in latest they're the same thingf
00:45:57 <liste> https://www.stackage.org/haddock/nightly-2015-05-19/persistent-2.1.5/Database-Persist-Sql.html#t:Connection
00:46:16 <liste> actually Connection = SqlBackend
00:46:25 <liste> ConnectionPool is Pool Connection
00:46:44 <liste> that is  Pool SqlBackend
00:46:56 <srenatus> hi there. in haskell-land, is it sufficient to add a LICENSE file and the corresponding keys to the cabal file, or do I still need to add the (say, Apache 2) preamble to every *.hs file?
00:47:12 <liste> so you can get a SqlBackend from Pool SqlBackend using withResource
00:47:33 * hackagebot haskellscript 0.1.2 - Command line tool for running Haskell scripts with a hashbang.  http://hackage.haskell.org/package/haskellscript-0.1.2 (seanparsons)
00:47:55 <liste> srenatus I guess it's dictated in the license, not the language community
00:48:11 <srenatus> liste: ah, ok. so I'll do what the license says. thanks
00:49:35 <_m_ryan> liste: i edited the paste. http://lpaste.net/132905
00:52:03 <liste> _m_ryan something like this: http://lpaste.net/132905
00:52:09 <liste> note the withREsource pool
00:52:44 <a21> frerich: now i get: cabal: Missing dependency on a foreign library:
00:54:43 <_m_ryan> liste: yes i see it. :) wrong place of pool another this is the second error. did you see it?
00:56:14 <_m_ryan> liste: you gave me this code earlier, prices <- runDB $ ask >>= \backend -> liftIO (qrylatestAvgPrices <number> backend), who is ask int his code?
00:56:15 <liste> yeah, qrylatestAvgPrices doesn't take the runDB function, it takes a SqlBackend
00:56:27 <liste> ask is ReaderT's method
00:56:47 <liste> it retrieves the SqlBackend
00:58:35 <liste> and you could use connPrepare instead of rawSql
00:58:52 <liste> and stmtExecute
00:59:00 <liste> or then you could runReader the rawSql
00:59:05 <liste> runReaderT*
00:59:41 <deezn> Guys can I ask about this syntax?
00:59:46 <a21> im trying to write a ffi in haskell, where does cabal expect the header.h files to be?im trying to write a ffi in haskell, where does cabal expect the header.h files to be?
01:00:14 <deezn> ->  http://lpaste.net/5069065770202300416
01:01:00 <liste> _m_ryan something like this http://lpaste.net/132905
01:02:09 <liste> deezn which part of that syntax?
01:05:30 <deezn> liste: ok.. the let.. to start I am still confused with that and where.. even after reading
01:06:45 <liste> let is just substitution
01:07:23 <deezn> i thoguth that was where?
01:07:53 <jle`> (let ... in ...) is an expression
01:07:58 <jle`> just like 5, or 3*4, or True
01:07:59 <liste> so the last line expands to (f v) `pseq` (treeMap f l) `pseq` (treeMap f r) `pseq` Branch (f v) (treeMap f l) (treeMap f r)
01:08:11 <jle`> where is different...where is a part of declaration syntax
01:08:26 <jle`> foo = ... where ..., defines/declares foo
01:09:01 <_m_ryan> liste: i have this error: Couldn't match type ‘HandlerT site0 IO [a0]’  with ‘ReaderT SqlBackend IO [RawLatestAvgPrices]’
01:09:04 <mauke[> > (let x = 20 in x + 1) * 2
01:09:05 <lambdabot>  42
01:09:43 <deezn> ok...
01:10:10 <mauke[> > (let { x = 20 } in x + 1) * 2
01:10:12 <lambdabot>  42
01:10:20 <deezn> ok so on to pseq and par.. 
01:10:21 <mauke[> > (let { x = y + y where { y = 10 } } in x + 1) * 2
01:10:23 <lambdabot>  42
01:10:34 <liste> deezn they're hints to parallelize the code
01:10:45 <liste> so it performs better
01:10:48 <deezn> yeah i understand that.. 
01:11:03 <deezn> but what is the difference between par and pseq
01:11:31 <mauke[> http://hackage.haskell.org/package/parallel-3.2.0.6/docs/Control-Parallel.html#v:par
01:11:57 <deezn> read it.. https://hackage.haskell.org/package/parallel-3.2.0.4/docs/Control-Parallel.html
01:13:28 <mauke[> 'par x y' evaluates to y (but may spawn a background thread to evaluate x (but throw the result away))
01:13:30 <liste> _m_ryan you need to move the runReaderT and add a liftIO somewhere
01:13:45 <mauke[> 'pseq x y' evaluates x first, then evaluates to y
01:17:03 <liste> _m_ryan follow the types (:
01:20:14 <_m_ryan> liste: it says that the expected type is ReaderT SqlBackend IO [RawLatestAvgPrices], but the function return HandlerT site0 IO [a0]
01:20:57 <_m_ryan> liste: question what does this code do? (flip runReaderT) backend?
01:21:31 <pacak> :t flip runReaderT
01:21:32 <lambdabot> r -> ReaderT r m a -> m a
01:22:13 <pacak> runs ReaderT monad with backend as reader parameter
01:22:39 <pacak> one layer
01:23:26 <liste> > undefined `par` ()
01:23:28 <lambdabot>      Not in scope: ‘par’
01:23:28 <lambdabot>      Perhaps you meant one of these:
01:23:28 <lambdabot>        ‘Sym.var’ (imported from Data.Number.Symbolic),
01:23:49 <liste> can I import par somehow to lambdabot?
01:26:19 <deezn> with the tree map.. 
01:26:29 <deezn> what is happening in the last line..?
01:27:25 <deezn> value is evaluated first.. then the left branch then the right branch.. but what about that last part?  Branch v' l' r'
01:27:34 <deezn> liste?
01:29:29 <deezn> mauke[?
01:30:03 <liste> deezn that's the result value of the function itself
01:30:41 <mauke[> @let import Control.Parallel (par, pseq)
01:30:42 <lambdabot>  .L.hs:62:1:
01:30:43 <lambdabot>      Control.Parallel: Can't be safely imported!
01:30:43 <lambdabot>      The module itself isn't safe.
01:30:51 * frerich wishes Haskell would be strict by default and explicitely mark non-strictness using a 'Lazy' type, much like Idris does.
01:31:20 <mauke[> frerich: then Haskell wouldn't exist
01:31:31 <mauke[> it was designed as a "standard" lazy functional language
01:32:16 <jle`> laziness helps me more times than it hurts me so i'm happy with the default as it is
01:33:21 <yac> Baby, don't hurt me
01:33:24 <yac> Don't hurt me no more
01:33:48 <liste> I guess (undefined `par` ()) is () and (undefined `pseq` ()) is undefined ?
01:34:16 <mauke[> yes
01:34:47 <mauke[> undefined `seq` () is also undefined
01:36:25 <mjoseph_> hi  ... I'm pretty new to Haskell, have a quick question ... is is possible to get hold of number of blocks for  file
01:36:34 <mjoseph_> the getFileStatus doesn't seem to give me that
01:38:15 <mauke[> yeah, blocks aren't posix
01:39:29 <mauke[> you may have to write something yourself
01:40:28 <mjoseph_> oh ok .... thanks for the quick reply
01:40:33 <jle`> you can consider it the "semantic definition of seq", actually...; seq is defined as seq _|_ x = _|_; sex _ x = x
01:41:04 <jle`> the last case is obviously a typo
01:41:18 <KaneTW> i like to imagine it isn't
01:52:37 * hackagebot keter 1.4.1 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.4.1 (MichaelSnoyman)
02:05:04 <ion> > (foldr par (error "z") . map (error . show)) [0..]
02:05:06 <lambdabot>      Not in scope: ‘par’
02:05:06 <lambdabot>      Perhaps you meant one of these:
02:05:06 <lambdabot>        ‘Sym.var’ (imported from Data.Number.Symbolic),
02:06:28 <ronh-> "As a consequence, _|_ is not the same as \x ->  _|_, since seq can be used to distinguish them" <- what does this mean? why would \x -> _|_ be the same as _|_?    https://www.haskell.org/onlinereport/basic.html
02:08:14 <liste> ronh- well, (a -> b) can be bottom
02:08:19 <liste> and so can a
02:08:39 <ronh-> oh, they talk about undefined :: (a -> b)?
02:08:47 <liste> I guess
02:09:20 <ronh-> > (undefined :: (a -> b)) `seq` 1
02:09:22 <lambdabot>  *Exception: Prelude.undefined
02:09:57 <liste> > (\_ -> undefined :: (a -> b)) `seq` 1
02:09:59 <lambdabot>  1
02:10:38 <_m_ryan> liste: can you help me out can figure what is the error.
02:10:45 <ronh-> I still don't get the implication that the two should be the same. (\_ -> 1) isn't the same as 1
02:12:05 <liste> ronh- without seq, how would you distinguish (\_ -> _|_) from _|_ ?
02:12:24 <ronh-> liste by looking at their types
02:12:37 <liste> ronh- what if both were a -> b
02:12:50 <ronh-> ah
02:13:20 <liste> _m_ryan, what does your code look like now?
02:14:21 <_m_ryan> liste: same as before i try to rearrange it. but it has more error so i return it to defualt.
02:14:52 <_m_ryan> liste: i also read about http://www.yesodweb.com/book/yesods-monads#yesods-monads_the_three_transformers, can't figure it out.
02:15:02 <liste> _m_ryan let's go inside out
02:15:10 <liste> you have runSql foo
02:15:34 <liste> that's type ReaderT SqlBackend IO ()
02:15:46 <liste> you need to turn it into an IO ()
02:16:02 <liste> you can use (flip runReaderT) backend for that
02:16:47 <liste> so (runReaderT backend) runSql foo is type IO ()
02:17:55 <ion> That looks like a type error
02:18:01 <liste> runDB*
02:18:03 <liste> sorry
02:18:15 <_m_ryan> liste: i get it i remove the runDB and it works :)
02:18:32 <liste> good (:
02:19:19 <_m_ryan> liste: why is it an error? and instead of yesod runDB, it uses runSql?
02:19:36 <liste> _m_ryan I meant rawSeql
02:19:40 <liste> rawSql*
02:20:21 <_m_ryan> liste: ah yeah, so the (flip runReaderT) backend, will represent the runDB for us?
02:20:37 <liste> _m_ryan yes
02:21:28 <liste> runDB is ReaderT SqlBackend Handler but we need ReaderT SqlBackend IO
02:21:46 <_m_ryan> liste: thank you very much for you time, hope you wont mind if i will ask question again. :)
02:21:52 <liste> of course not
02:29:19 <zipper> OMFG ReinH who knew that there were videos of you on the internet? Haskell cast has a video version
02:29:24 <zipper> LOL
02:37:25 <int-e> @users
02:37:29 <lambdabot> Maximum users seen in #haskell: 1486, currently: 1486 (100.0%), active: 1 (0.1%)
02:37:37 <int-e> @seen int-e
02:37:38 <f|`-`|f> lel
02:37:43 <lambdabot> You are in #haskell..
02:38:14 <jle`> int-e when lambdabot let people :t operators without parenthess
02:38:21 <jle`> *when did
02:38:24 <jle`> ?
02:38:51 <jle`> literally 1 active user in #haskell huh
02:39:14 <int-e> For anyone who cares, I've enabled the seen module in lambdabot; this is an experiment, I want to see whether it causes any troubles (beyond being slightly buggy)
02:39:34 <xelxebar_> :t *
02:39:41 <xelxebar_> @t *
02:39:42 <zipper> int-e: hmmm where is the source?
02:39:43 <lambdabot> Num a => a -> a -> a
02:39:49 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
02:39:59 <zipper> jle`: WOW uh I was looking for you.
02:40:18 <f|`-`|f> :t **
02:40:22 <f|`-`|f> :t ^
02:40:27 <zipper> jle` let me show you some code I have. It's really very fuzzy/foggy.
02:40:27 <lambdabot> Floating a => a -> a -> a
02:40:33 <lambdabot> (Integral b, Num a) => a -> b -> a
02:40:40 <int-e> jle`: Oh, that's an unintended side effect of making  :k Int :: *  work
02:41:06 <jle`> ah i see
02:41:30 <jle`> good job on @seen int-e 
02:41:32 <int-e> jle`: the workaround was to put parenthesis around the provided expression. I might back that out, since it also broke comments:  :t foo -- bar
02:41:46 <jle`> heh
02:41:52 <jle`> interesting that it was unintended
02:41:54 <int-e> jle`: I only re-enabled the module.
02:41:58 <jle`> :t foo -- bar
02:42:04 <lambdabot> (Functor m, Functor f) => ((a1 -> f (WriterT w m1 a2)) -> s -> WriterT a m s) -> (a1 -> f (m1 (a2, w))) -> StateT s m a
02:42:12 <int-e> oh?
02:42:14 <jle`> welp i did not expect that
02:42:19 <jle`> @undefine
02:42:20 <int-e> :t foo
02:42:26 <lambdabot> Undefined.
02:42:27 <jle`> too late, it's gone forever
02:42:28 <lambdabot>     Not in scope: ‘foo’
02:42:34 <lambdabot>     Perhaps you meant ‘T.for’ (imported from Data.Traversable)
02:42:36 <int-e> :t id -- something
02:42:38 <lambdabot> a -> a
02:42:44 <int-e> :k Int -- something else
02:42:45 <lambdabot> *
02:42:48 <jle`> hm
02:43:00 <int-e> Ok, I misremembered... odd.
02:43:12 <jle`> i thought it was intentional because people always did :t +
02:43:38 <jle`> it's nice to have seen again since preflex disappeared
02:44:07 <jle`> @seen preflex
02:44:07 <lambdabot> Last time I saw preflex was when I left ##english, ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-in-depth, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.
02:44:07 <lambdabot> dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosx, #macosxdev, #novalang, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling, #xmonad and #yi 6y 5m 19d 4h 57m 48s ago.
02:44:12 <zipper> jle`: Will you be in the channel for a while? I want to try fix it first.
02:44:19 <jle`> zipper: yeah, for a bit :)
02:44:19 <zipper> jle`: On my own.
02:44:22 <mauke[> :t `id`
02:44:24 <int-e> jle`: well, it's not an unambiguous win, since now people will ask why it works with lambdabot but not in ghci. So please don't rely on it :)
02:44:24 <lambdabot> parse error on input ‘)’
02:44:28 <jle`> preflex was last seen six years ago
02:44:40 <jle`> int-e: yeah, i was not *too* happy with the "fix"
02:44:47 <jle`> for that reason
02:44:53 <jle`> but i can live with it
02:45:02 <bernalex> int-e: on the bright side, most people misremember things as *working*, not as *being buggy*.
02:45:03 <jle`> mauke[: nice
02:45:20 <mauke[> :t 'x', 'y'
02:45:22 <lambdabot> (Char, Char)
02:45:32 <mauke[> :t 2) + (2
02:45:33 <lambdabot> Num a => a
02:45:40 <int-e> bah.
02:45:49 <jle`> :t 2)(
02:45:51 <lambdabot> Num (() -> t) => t
02:45:57 <bernalex> int-e: did you mean that things like ':t id -- comment' doesn't work in ghci? because it does
02:46:58 <bernalex> mauke['s hackery sure won't work in ghci though.
02:47:16 <divVerent> @seen copton
02:47:16 <lambdabot> I haven't seen copton.
02:48:23 <int-e> :t 2) + (2
02:48:32 <lambdabot> parse error on input ‘)’
02:49:18 <int-e> (I take half the blame. One should never, ever, explain how a magic trick works.)
02:50:05 <zipper> jle`: Hey you still around? https://gist.github.com/urbanslug/ab8e8f45b3d4f39bbf28
02:50:22 <zipper> jle`: That code might be overly out of context let me update it
02:50:45 <jle`> :t +
02:50:54 <lambdabot> parse error on input ‘+’
02:51:06 <jle`> well that was fun for a week
02:51:21 <jle`> :k Int :: *
02:51:28 <lambdabot> parse error on input ‘::’
02:51:35 <zipper> jle` Done
02:51:43 <zipper> jle`: https://gist.github.com/urbanslug/ab8e8f45b3d4f39bbf28
02:52:11 <zipper> jle`: Issue is with getNP
02:52:21 <int-e> jle`: after mauke's demonstration, that seems to be the lesser of two evils.
02:53:04 <jle`> zipper: let me take a look :)
02:54:01 <zipper> int-e: I was asking/wondering where your seen code is?
02:55:00 <int-e> zipper: https://github.com/lambdabot/lambdabot/tree/master/lambdabot-social-plugins/src/Lambdabot/Plugin/Social ... it's on hackage as well.
02:55:22 <int-e> and it's not my code.
02:55:27 <zipper> int-e: Thank you good sir.
02:55:31 <zipper> or madam
02:55:41 <jle`> zipper: what's wrong with getNP?
02:55:48 <zipper> Man these pronouns will get me killed someday.
02:56:16 <f|`-`|f> My pronouns are bun and bunself
02:56:42 <tdammers> shkle, anyone?
02:57:25 <zipper> jle`: Uh I've updated the gist with the error.
02:57:31 <tmtwd> is [1,2,3] a list in haskell?
02:57:42 <zipper> Couldn't match expected type ‘Auto a (Blip Nick) (Blip Message)’ with actual type ‘Nick -> IO Message’
02:57:47 <zipper> jle` ^
02:57:53 <jle`> zipper: ah yeah, there's a method in Control.Auto.Effects for that
02:58:02 <zipper> jle` I can't pattern match on a Blip :(
02:58:08 <zipper> I'm confused.
02:58:13 <jle`> it runs an effect every time a blip comes inbound
02:58:20 <jle`> incoming blips trigger an effect
02:58:30 <ocharles_> jle`: nice blog post :)
02:58:30 <zipper> jle`: Let me look for it.
02:58:33 <mauke[> tmtwd: yes
02:58:36 <jle`> zipper: it's arrMB
02:58:40 <mauke[> :k (Int :: *)
02:58:41 <jle`> from Control.Auto.Effects
02:58:41 <lambdabot> *
02:58:43 <zipper> jle`: What do you tink about the rest of the code?
02:58:53 <jle`> or rather arrMB (liftIO . getNP)
02:58:56 <jle`> ocharles_: thanks :)
02:59:25 <jle`> i actually have had it laying around for a while, decided to finally go ahead and clean it up
02:59:39 <jle`> it seems a lot of my posts come from noticing that i explain the same thing in irc several times
03:00:01 <tmtwd> is there a data List defined in the haskell prelude?
03:00:12 <jle`> tmtwd: yes, but it's not called List
03:00:13 <int-e> jle`: fwiw, that change was active for 6 weeks
03:00:20 <int-e> (the :t and :k one)
03:00:22 <mauke[> tmtwd: no, the type is called []
03:00:26 <jle`> i'm so observant :)
03:00:29 <luzie> beep boop blip blee
03:00:45 <echo-area> Could someone recommend a book for learning type theory?
03:01:08 <bernalex> echo-area: TAPL
03:01:12 <tmtwd> how do I do this with the default list type?
03:01:17 <tmtwd> 4 : Empty
03:01:17 <echo-area> bernalex: Thanks
03:01:29 <merijn> echo-area: I second TaPl
03:01:36 <jle`> tmtwd: [4], or 4:[]
03:01:42 <echo-area> merijn: Cool :)
03:01:43 <tmtwd> ah of course
03:01:47 <merijn> echo-area: Especially if you have plans/ambitions to implement your own language/type checker
03:01:50 <jle`> zipper: the rest looks good :)
03:02:19 <jle`> zipper: i usually like to just put in isNP <- emitJusts getRequest -< ..., but this way is fine too
03:02:20 <zipper> jle`: Heh that means a lot. I was reading up on arrows last night.
03:02:27 <mauke[> tmtwd: data [] a = [] | a : [] a  -- effectively
03:02:39 <echo-area> It is in my read list, but I have not reached there yet :)
03:02:40 <zipper> jle`: Why did you chose arrows compared to the more conventional things?
03:02:40 <tmtwd> thanks
03:02:49 <jle`> isNP might more meaningfully be called npBlip or something
03:02:57 <jle`> zipper: it's the easiest way to define recursive bindings
03:03:13 <zipper> jle` Thanks for these tips. Let me look at them.
03:03:43 <jle`> but these aren't actual code critiques, just naming convention haha.  it doesn't matter in the end
03:03:43 <zipper> jle`: BUt people who are young in haskell don't know arrows :( Oh well
03:03:45 <tmtwd> data MyList a = Empty | a :-: (MyList a) deriving (Show, Read, Eq, Ord)  
03:04:00 <tmtwd> how do I get it so that I can call foldl on MyList?
03:04:09 <jle`> yeah, arrow is a pretty rare abstraction
03:04:11 <tmtwd> does it have to derive something?
03:04:13 <zipper> jle`: No it's good. I like to have people who know more than me tell me what they think.
03:04:19 <jle`> it seems to only have a few good use cases
03:04:43 <mauke[> tmtwd: you can't
03:04:43 <tmtwd> or do I have to rewrite foldl
03:04:45 <tmtwd> ?
03:04:52 <mauke[> yeah, you'll have to write your own
03:05:07 <mauke[> is foldl a method nowadays?
03:05:08 <tmtwd> the old copy/paste method?
03:05:08 <mauke[> :t foldl
03:05:09 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
03:05:16 <jle`> yeah, defining recursive bindings in a clean way is probably the only thing keeping me with arrow
03:05:47 <mauke[> tmtwd: you can make it an instance of Foldable, but you'll still have to write the code for the methods
03:06:02 <jle`> but it's not even really Arrow that's useful, it's proc notation
03:06:30 <tmtwd> instance Foldable MyList where ...?
03:06:59 <jle`> most things that can be done with arrow methods are more cleanly done with Applicative...like (&&&) = liftA2 (,), and arr is mkFunc from the lib
03:07:09 <mauke[> http://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Foldable.html#t:Foldable
03:07:10 <jle`> oh wait no i tell people to use `arr`, nvm
03:07:10 <liste> tmtwd define either foldMap or foldr
03:07:16 <liste> in the instance
03:07:17 <zipper> jle`: It just sets a kinda high bar for entry
03:07:39 <jle`> hm. yeah, i think that might be a real thing
03:07:51 <jle`> but i have a proc notation tutorial in the tutorial that goes over all the relavent parts
03:07:51 <zipper> jle`: I want to try serialization with this next.
03:08:01 <jle`> :)
03:08:02 <zipper> I've read your code but it's a bit over my head.
03:08:11 <jle`> npBot doesn't actually have anything to serialize cause it has no state
03:08:21 <zipper> Ok not to create but to use. Like how to save a map of something for future use.
03:08:38 <esimp> Anyone have a reference for what the following type signature means:  type PixelBaseComponent a :: *
03:08:39 <mauke[> heh, foldl = foldl . foldr (:) []
03:08:52 <mauke[> esimp: that looks like an associated type (in a class)
03:08:57 <jle`> if you have an "Auto m a b", you can serialize it using "serializing (filePath)"
03:09:00 <zipper> jle`: I want to add state. I just started with it's simplest form. I want to save the last fm usernames with the associated nick in a map
03:09:02 <jle`> that gives you a new Auto m a b that self-serializes
03:09:04 <mauke[> esimp: ':: *' is a kind annotation
03:09:07 <jle`> so it's like...dead easy
03:09:08 <zipper> jle`: Any ideas?
03:09:19 <jle`> just take your normal Auto m a b, and apply serializing :: FilePath -> Auto m a b -> Auto m a b
03:09:21 <jle`> and it's self-serializing
03:09:38 <tmtwd> @src foldl
03:09:38 <lambdabot> foldl f z []     = z
03:09:38 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
03:09:40 <zipper> jle`: Oh yeah I get that. The issue is when to build up this map. When to check for it.
03:09:53 <esimp> mauke, ah, ok.  I'll start my googling about associated types and kind annotations.  Thanks
03:09:55 <jle`> ah, ok
03:09:58 <zipper> jle`: The free serialization really helps.
03:10:07 <jle`> the chatbot tutorial was a bit too advanced?
03:10:34 <zipper> jle`: Heh not so much but it wasn't as easy as I expected when I read it and went to write my own things.
03:10:43 <marekw2143> hello, why this code: http://haskellstub.com/79838325/ doesn't work?
03:10:47 <jle`> ah i see
03:10:51 <liste> tmtwd I guess that's the source for the old (pre 7.10) foldl
03:11:11 <tmtwd> I hope it will work :)
03:11:21 <tmtwd> is the new one better?
03:11:36 <zipper> jle`: Yeah I think I'll have to have a `@np set <lastfm-username>` for when one wants to set the username.
03:11:37 <liste> tmtwd old foldl is for lists only, the new one is for all Foldables
03:11:49 <liste> it's in Data.Foldable in ghc<7.10
03:11:55 <zipper> jle` Then accumulate it. Good idea?
03:11:57 <mauke[> but the list instance of Foldable still uses that code
03:12:14 <tmtwd> liste: it's a generic function?
03:12:15 <jle`> zipper: yeah, in that case, just have something that emits a blip every time someone tries to set, a Blip Username
03:12:23 <jle`> and then you can use accum etc.
03:12:29 <liste> tmtwd it's a method of Foldable
03:12:30 <liste> now
03:12:51 <tmtwd> oh I see
03:13:32 <tmtwd>     Not in scope: type constructor or class `Foldable'
03:13:38 <tmtwd> how do I fix that?
03:13:44 <jle`> import Data.Foldable
03:13:50 <zipper> jle`: Sometimes it feels as if I ask too many questions :)
03:13:50 <linkages> may be having a noob problem ... but dont know how to do it
03:13:52 <mauke[> marekw2143: 3 is polymorphic, so it doesn't know which number type you want, and none of them are instances of JSON anyway, so toJValue 3 is an error
03:14:01 <jle`> zipper: nah i actually get points every time someone asks me a question
03:14:02 <linkages> if i have a data type binary tree
03:14:05 <linkages> data (Ord a, Eq a) => Tree a = Nil | Node (Tree a) a (Tree a) 
03:14:05 <linkages> 	deriving Show
03:14:07 <jle`> so the more questions the better
03:14:19 <mauke[> linkages: (Ord a) implies (Eq a)
03:14:20 <zipper> jle`: You get points?
03:14:28 <mauke[> linkages: also, don't put class constraints on data types
03:14:35 <jle`> yes
03:14:38 <jle`> happiness points ^_______^
03:14:55 <linkages> thx but need still to finish my question mauke[ :)
03:15:16 <linkages> anyway didnt know it
03:15:19 <mauke[> should've typed faster
03:15:19 <linkages> ill correct
03:15:33 <zipper> jle`: hahaha nice
03:15:43 <linkages> how can i create a tree and insert data ? can u make an example?
03:15:52 <linkages> compiler keep giving error
03:15:52 <mauke[> also, IRC is full duplex: you can continue typing your question while other people talk :-)
03:16:03 <marekw2143> mauke[, but here: http://book.realworldhaskell.org/read/using-typeclasses.html there's definition of instance JSON a where ... 
03:16:08 <tmtwd> oh I have a name -clash between prelude and Data.Foldable?
03:16:22 <mauke[> linkages: Node (Node Nil 1) 2 (Node (Node Nil 3 Nil) 4 Nil)
03:16:22 <zipper> mauke[: Why did you feel the need to state that fact?
03:16:33 <zipper> mauke[: You have me LOL
03:16:44 <linkages> oh tthank you again mauke[ ... very helpfull
03:17:29 <mauke[> oops, forgot a Nil in the first subtree
03:17:47 <mauke[> marekw2143: http://book.realworldhaskell.org/read/using-typeclasses.html#id608052 - this bit is missing in your code
03:18:22 <f|`-`|f> niccta has a jsonvalues thinger
03:18:49 <marekw2143> mauke[, so, I have to definie instances of <JSON a> for concrete types substituted for <a> ? 
03:19:13 <tmtwd> nvm I got it
03:19:19 <mauke[> marekw2143: yes, that's how classes work
03:20:00 <f|`-`|f> nevermind
03:20:06 <f|`-`|f> nicta doesn't have a JSON a
03:20:12 <f|`-`|f> they have a JSON though
03:21:26 <marekw2143> f|`-`|f, nicta?
03:22:06 <tmtwd> what is a foldMap?
03:22:20 <marekw2143> > :t foldMap
03:22:24 <lambdabot>  <hint>:1:1: parse error on input ‘:’
03:22:35 <jle`> for a structure t, it's foldMap :: (a -> m) -> t a -> m
03:22:37 <luzie> heh
03:22:41 <jle`> so you can think of it as "mapping" the (a -> m) on all of the items
03:22:41 <marekw2143> :t foldMap
03:22:43 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
03:22:46 <jle`> and then collapsing it down into one big `m`
03:22:55 <jle`> for Monoid m
03:23:14 <tmtwd> so foldMaps are folds for graphs and such thins?
03:23:21 <f|`-`|f> :t foldMap
03:23:22 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
03:23:27 <tmtwd> and it gives you a monoid?
03:24:10 <luzie> > foldMap show [1,2,3]
03:24:12 <lambdabot>  "123"
03:24:47 <pacak> > getSum $ foldMap Sum [1..4]
03:24:48 <lambdabot>  10
03:25:42 <pacak> > getfirst $ foldMap (First . Just) [1..4]
03:25:45 <lambdabot>      Not in scope: ‘getfirst’
03:25:46 <lambdabot>      Perhaps you meant ‘getFirst’ (imported from Data.Monoid)
03:25:50 <pacak> > getFirst $ foldMap (First . Just) [1..4]
03:25:53 <lambdabot>  Just 1
03:26:57 <jle`> tmtwd: it maps every item into a value of Monoid m, and then squashes all of them together
03:27:02 <f|`-`|f> :t First
03:27:04 <lambdabot> Maybe a -> First a
03:27:11 <f|`-`|f> whet
03:27:19 <tmtwd> huh
03:27:29 <tmtwd> so it can be used for lists?
03:28:02 <luzie> lists implement foldable
03:31:15 <tmtwd> so you can call foldl, foldr and foldmap on lists and they all do different things?
03:31:33 <pacak> tmtwd: For any foldable. Maps for example
03:31:43 <tmtwd> right
03:33:00 <tmtwd> how is Map defined?
03:33:05 <tmtwd> @src Map
03:33:05 <lambdabot> Source not found. I am sorry.
03:34:12 <quchen2> tmtwd: Map is abstract, you can't see its constructors.
03:34:26 <tmtwd> :t Map
03:34:27 <lambdabot>     Not in scope: data constructor ‘Map’
03:34:27 <lambdabot>     Perhaps you meant one of these:
03:34:27 <lambdabot>       variable ‘map’ (imported from Data.List),
03:34:28 <quchen2> Internally, it's implemented as a binary tree.
03:34:34 <tmtwd> huh
03:34:59 <pacak> If you really want to get to Map's constructors - unsafeCoerce is your friend :)
03:37:04 <liste> :t M.Map
03:37:05 <lambdabot>     Not in scope: data constructor ‘M.Map’
03:37:05 <lambdabot>     Perhaps you meant variable ‘M.map’ (imported from Data.Map)
03:37:06 <merijn> pacak: That doesn't get you access
03:37:25 <merijn> liste: M.Map is a type, so querying it's type doesn't make sense
03:37:42 <liste> :k M.Map
03:37:43 <lambdabot> * -> * -> *
03:37:47 <pacak> merijn: It kind of does. You can create your own constructors and coerce between your version and Map's version.
03:38:16 <quchen2> You could write your own Map type that is identical to the hidden one in Data.Map and then coerce a proper Map to that type to look at it, but that's a terrible idea.
03:39:45 <marekw2143> mauke[, so this code:  <      instance (JSON a) => JSON [a] where
03:39:46 <marekw2143>        >   is also not compilable since it doesn't use concrete types ? 
03:41:21 <liste> > foldl (+) 0 (M.fromList [(1, 10.0), (2, 20.0), (3, 30.0)]) :: Double
03:41:23 <lambdabot>  60.0
03:43:10 <mjoseph_> hashObject :: [String] -> IO ()
03:43:10 <mjoseph_> hashObject files =  mapM hashOfFile files >>= (mapM_ print)
03:43:10 <mjoseph_> hashOfFile :: String -> IO String
03:43:12 <mjoseph_> hashOfFile _ = return "asdfadsf"
03:43:16 <mjoseph_> hi guys ... need help doing the following in a better way ... 
03:43:24 <mjoseph_> need the above done in a better way*
03:43:55 <quchen2> mapM_ (hashOfFile >=> print) files?
03:44:35 <mjoseph_> thanks that works
03:47:23 <ronh-> why did map survive 7.10's switch to more general functions?
03:48:05 <ronh-> also filter
03:48:39 <quchen2> You can't filter with Foldable/Traversable, and fmap is generalized map and has always been in the Prelude.
03:49:22 <ronh-> what contraints would be needed for a more general filter?
03:50:32 <quchen2> You'd need a new class that allows building up a structure. Foldable can collapse one, traversable can traverse, but none of them can return an altered version of arbitrary input.
03:50:35 <merijn> ronh-: Because map isn't part of Foldable/Traversable
03:50:36 <jle`> you can't really generalize filter with any of the typeclasses in base
03:50:48 <jle`> there's a new-ish typeclass where you can though
03:50:52 <jle`> @hackage witherable
03:50:53 <lambdabot> http://hackage.haskell.org/package/witherable
03:50:59 <merijn> Or you could use lens :p
03:51:03 <jle`> but it's not standard by any means
03:51:16 <jle`> are filters law-abiding traversals?
03:52:19 <marchelzo_> If I start a new thread with forkIO, and it throws an exception, can I catch it from the original thread? (the one which called forkIO)
03:52:21 <merijn> I'm not quite sure, but there's a more general way to filter, I think?
03:52:26 <quchen2> jle`: You can filter a Map with a Lens traversal?
03:52:37 <jle`> is that a question?
03:52:40 <jle`> heh
03:52:43 * hackagebot ghc-prof-flamegraph 0.1.1.0 - Generates data to be used with flamegraph.pl from .prof files.  http://hackage.haskell.org/package/ghc-prof-flamegraph-0.1.1.0 (FrancescoMazzoli)
03:52:44 <quchen2> Sure, you can always filter a Traversable by collapsing it to a list and then filtering that, but then you have a list.
03:52:46 <merijn> marchelzo_: Not automatically, but you can rethrow to the parent thread, ues
03:53:06 <merijn> marchelzo_: Although you should probably let the async library handle most of that stuff for you, as async exceptions are *hard*
03:53:11 <marchelzo_> merijn: would I need the parent's ThreadId?
03:53:12 <jle`> yeah heh, but that requires monomorphically knowing how to reconstruct from a list
03:53:27 <jle`> not really a 'generalized' deal
03:53:43 <merijn> marchelzo_: Yes
03:54:11 <merijn> marchelzo_: Basically, write a custom forkIO wrapper that obtains parent id and installs an exception handler that rethrows to parent when forking
03:54:18 <m_ryan> hi is it posible to creat an if only condition?
03:54:44 <marchelzo_> merijn: is that already written in async, or at least something which achieves the same effect?
03:55:10 <merijn> marchelzo_: Look at forkFinally
03:55:13 <indiagreen> m_ryan: if you're in a monad, you can use “when” to conditionally execute an action
03:55:14 <indiagreen> :t when
03:55:15 <lambdabot> Applicative f => Bool -> f () -> f ()
03:55:37 <indiagreen> m_ryan: you can't have an if-only condition in a function because then what would it return if the condition fails?
03:56:06 <marchelzo_> merijn: perfect, thanks very much.
03:56:10 <Guest2542> how do i generalise f g h a b = g (h a) (h b) to n arguments. basically how do i uncurry a list?
03:57:03 <m_ryan> indiagreen: you mean a case expression?
03:57:16 <merijn> Guest2542: The short answer is: You can't
03:57:24 <Guest2542> oh no!
03:57:41 <Guest2542> i thought it was some part id never seen but would exist...
03:57:47 <merijn> Guest2542: The long answer is, you could, but it requires more -XKitchenSink voodoo than I'm comfortable recommending to newcomers...
03:57:56 <Guest2542> im not new
03:58:16 <merijn> Guest2542: Does it have to be a regular list?
03:58:53 <Guest2542> its more about left asociative function composition i think....
03:59:38 <Guest2542> given a function of n arguments, apply another function to each of its arguments before passing them to the first function
04:01:38 <marchelzo_> merijn: so if I want to just rethrow, is (forkFinally throw) reasonable?
04:01:58 <Guest2542> so something like myFunction c@castingFunction functionOfNArguments arg1 arg2 ... argn = functionOfNArguments (c arg1) (c arg2) ... (c argn)
04:02:25 <quchen2> marchelzo_: When you want to catch exceptions thrown in forked threads, the async library would be better suited.
04:02:31 <merijn> marchelzo_: That would rethrow the "Either"
04:02:53 <merijn> marchelzo_: You'd need to check whether there was an exception (Left) or success (Right) and only rethrow the exception
04:02:54 <marchelzo_> ahh
04:03:01 <merijn> marchelzo_: Also, you need throwTo to throw to the parent
04:03:05 <marchelzo_> I didn't read the signature well enough >.<
04:03:36 <marchelzo_> ah, so when I run forkFinally f x, f is run on the new thread?
04:03:38 <merijn> Guest2542: I think that's doable, but more complicated than I have time to sketch out while procrastinating
04:03:51 <merijn> marchelzo_: Both f and x are run on the new thread
04:03:54 <marchelzo_> right
04:03:56 <marchelzo_> okay
04:04:12 <merijn> Hence why you need to "throwTo parentId myException"
04:04:15 <Guest2542> its really so hard? apply one function to all the arguments of another function?
04:04:32 <marchelzo_> yep. quchen2: which function in particular from async?
04:05:07 <quchen2> marchelzo_: "async" is analogous to "forkIO", and "wait"ing for a result rethrows the exception in the waiting thread if there is one.
04:05:33 <quchen2> forkIO is really just the basic user-facing forking primitive. Async is a thin wrapper around that which provides a lot of useful functionality.
04:05:36 <Guest2542> i would normally recurse on patern (:) matching off the head of a list, can i do something similar using (.)?
04:05:57 <marchelzo_> quchen2: so I would need to block on the parent thread as well
04:07:01 <merijn> Guest2542: . is not a constructor, so no
04:07:43 <Guest2542> map casts a function to a list of arguments constructed together using the list constructor (:), can I define a similar maping function to the left asociative function application chain of arguments constructed with (.)?
04:07:59 <Guest2542> its not a constructor i can recurse on?
04:08:34 <merijn> Guest2542: What do you mean "map casts"?
04:08:43 <merijn> There's no notion of casting in haskell
04:08:49 <Guest2542> um it applies a function to all the elements of the list 
04:08:57 <Guest2542> sorry
04:09:05 <quchen2> marchelzo_: There are other functions in async that manage re-throwing, such as `link`
04:09:06 <Guest2542> i was using cast to mean function application
04:09:12 <Guest2542> sz
04:09:28 <merijn> . doesn't "construct a chain of arguments", it's just another function and you can't pattern match on functions
04:09:42 <Guest2542> i was hoping sopmething like (f a b == (f a) b) could be used
04:09:44 <marchelzo_> quchen2: that's what I was looking for.
04:10:16 <Profpatsch> How do I parse a line of Text (until \n) with Parsec?
04:10:40 <Profpatsch> Without getting a list of Chars first and then packing them again?
04:10:54 <quchen2> marchelzo_: When you're dealing with concurrency I highly recommend reading async once from top to bototm
04:11:23 <Profpatsch> `many anyChar <* endOfLine` doesn’t look very efficient.
04:11:27 <Guest2542> so that i can just define the function for f a b and then generalise to f a1 a2 .. an with something like left asociative function composition
04:11:33 <marchelzo_> quchen2: I definitely will, thanks.
04:12:00 <merijn> Profpatsch: If you want efficiency don't use parsec
04:12:13 <merijn> Profpatsch: attoparsec is more efficient, but has worse errors
04:12:17 <Profpatsch> merijn: Yeah, I know.
04:13:11 <liste> Guest2542 so you mean variable arity?
04:13:12 <Profpatsch> But even with Parsec there ought to be a better way to do that.
04:13:27 <Profpatsch> Especially since it abstracts over text Streams.
04:13:41 <Guest2542> liste - perhaps i do
04:13:50 <Guest2542> i dont know about this
04:13:54 <liste> printf does variable arity with some type class hackery http://stackoverflow.com/questions/7828072/how-does-haskell-printf-work
04:13:55 <quchen2> merijn: A better suggestion would be not to use String.
04:14:01 <liste> but I would just use a list
04:14:08 <Guest2542> no its for a reason
04:14:09 <liste> and fold over it
04:14:20 <quchen2> Parsec is good enough for most tasks, but String is a bad bottleneck often enough.
04:14:39 <luzie> Guest2542: what are you really trying to do
04:14:55 <Profpatsch> quchen2: I’m using Text, but it looks like it always leads back to lists of Char.
04:15:02 <Guest2542> i wish to apply fromIntegral to all functions taking any number of integer arguments
04:15:17 <merijn> quchen2: Parsec doesn't have Text -> Text parsers
04:15:24 <merijn> quchen2: It only has Text -> Char -> Text
04:15:35 <Profpatsch> merijn: Ah, I see.
04:16:35 <quchen2> Oh. I stand corrected.
04:17:02 <Guest2542> sorry, i wish to apply fromIntegral to all arguments of functions taking any number of integer arguments
04:18:04 <Guest2542> nope, make that realToFrac, to make a library defined over float easy to use with another library defined for Double
04:18:12 <Guest2542> Float*
04:18:44 <liste>  Guest why not typeclasses like Num?
04:18:47 <liste> Guest2542*
04:19:10 <liste> or Floating
04:19:13 <Guest2542> myFunction :: (Float->Float ..... -> Float) -> (Double -> Double .... -> Double) 
04:19:30 <Guest2542> applies realToFrac to all arguments supplied to a function
04:19:31 <liste> myFunction :: Floating a => a -> a -> a -> ?
04:19:47 <liste> in the library itself I mean
04:20:01 <Guest2542> its someone elses library and its huge
04:20:14 <liste> maybe Template Haskell could help in that case
04:20:26 <Guest2542> i dont know about this
04:20:32 <luzie> what lib is it
04:20:46 <Guest2542> the one exposing quaternians
04:21:25 <Guest2542> Data.Vect.Float.Util.Quaternion
04:22:24 <Guest2542> anyway i thought it was a nice problem, i should be able to write this variable number of arguments thing since im doing the most simple opperation, amping a single function to all the arguments
04:22:44 <Guest2542> maping*
04:22:47 <chandru_in> When installing http-conduit-2.0.0.7 through cabal, I get an error stating "Could not find module `Network.HTTP.Client.Conduit'" What am I doing wrong?
04:23:06 <liste> the problem is that functions with different number of arguments have different types
04:23:44 <liste> chandru_in what command are you using to install?
04:24:17 <chandru_in> liste, I have "http-conduit == 2.0.0.7" in app.cabal and I run "cabal install"
04:24:23 <luzie> Guest2542: why not just work with floats? you'll lose precision anyway
04:24:33 <Guest2542> no!
04:24:37 <Guest2542> i like doubles
04:24:42 <Guest2542> lolololol
04:25:04 <chandru_in> liste, this is the relevent section of app.cabal http://pastie.org/private/lexoridvgafcp056ave5a
04:25:48 <Guest2542> ok, so really i can brute force it or take another route, but this way has presented me with the question im posing, which i like because it seems powerful.
04:26:16 <Guest2542> and i think its my lack of understanding that i can not generalise to functions of arbritrart numbers of arguments
04:26:23 <Guest2542> arbritrary*
04:26:30 <mauke[> chandru_in: ghc-pkg list http-conduit
04:28:01 <liste> chandru_in there's no Network.HTTP.Client.Conduit in that package, only Network.HTTP.Conduit, you're using an old API
04:28:21 <liste> the Client.Conduit is in an deprecated package (http-client-conduit)
04:28:55 <stobix> Someone said yesterday that the Reader monad was equivalent to the (->) notation (or so I understood it); Is this correct?
04:29:02 <mauke[> stobix: yes
04:29:09 <mauke[> Reader = (->)
04:29:10 <merijn> stobix: "(->) r", but yes
04:29:16 <Guest2542> foo :: (a -> b) -> (a -> a -> ... -> a) -> (b -> b -> ... -> b)
04:29:17 <mauke[> Reader r = (->) r
04:29:27 <Cale> Well, Reader itself is equivalent to (->)
04:29:34 <merijn> oh, right
04:29:38 <chandru_in> liste, I'm using only "Network.HTTP.Conduit" in my code not Client.Conduit
04:29:41 * stobix thinks. Hard.
04:30:09 <Cale> stobix: We have:  newtype Reader r a = Reader { runReader :: r -> a }
04:30:12 <chandru_in> mauke[, /var/lib/ghc/package.conf.d $HOME/.ghc/x86_64-linux-7.6.3/package.conf.d
04:30:45 <liste> chandru_in seems like that version (2.0.0.7) of the http-conduit package depends on http-client-conduit, which is empty
04:30:59 <liste> so there's a version constraint missing in 2.0.0.7
04:31:02 <liste> of http-conduit
04:31:07 <stobix> so (\x -> x) ⇒ (do; x <- ask; return x) ?
04:31:21 <Cale> yes
04:31:27 <liste> chandru_in try adding a http-client-conduit<0.3 constraint to your cabal file
04:31:42 <Guest2542> foo f g = foo f (\a-> g (f a))???????????????? 
04:31:57 <quchen2> :t [do { x <- ask; return x}, id]
04:31:58 <lambdabot> [b -> b]
04:32:25 <Cale> > (do x <- ask; return x) 5
04:32:27 <lambdabot>  5
04:32:28 <stobix> woah
04:32:34 <liste> :t let {foo f g = foo f (\a -> g (f a))} in foo
04:32:36 <lambdabot> (t2 -> t2) -> (t2 -> t1) -> t
04:32:46 <Cale> > runReader (do x <- ask; return x) 5 -- different instance, but same thing pretty much
04:32:47 <lambdabot>  5
04:33:16 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
04:33:17 <lambdabot>  ("hello","olleh","HELLO")
04:33:36 <quchen2> ask = id
04:33:37 <quchen2> asks = id
04:33:42 <Cale> As you can see, for the unwrapped case, id and ask are the same thing
04:33:42 <quchen2> local also unifies with id
04:33:49 <Guest2542> thanks liste, but i think anyway it would complain of creating infinite type?
04:34:39 <stobix> Heh. I like how Haskell still manages to totally mindfuck me.
04:36:10 <chandru_in> liste, thanks that worked
04:36:16 <stobix> does (<-) take any unary function as its second argument?
04:36:33 <liste> stobix <- is just syntactic sugar
04:36:53 <liste> a <- b is really b >>= \a ->
04:37:01 <Guest2542> :t let {foo f g = foo f (\a -> g (f a))}  in foo id (*)
04:37:02 <lambdabot> t
04:37:07 <ronh-> > liftA3 (,,) id reverse (map toUpper) "hello"
04:37:08 <lambdabot>  ("hello","olleh","HELLO")
04:37:26 <stobix> Heh. Is this where we do the Haskell equivalent of x[i] ≡ i[x] in C? ;)
04:37:36 <Guest2542> :t let {foo f g = foo f (\a -> g (f a))}  in foo id (\ a b c -> [])
04:37:38 <lambdabot> t
04:38:06 <zipper> jle`: You still around?
04:38:12 <ronh-> stobix no. do notation exists because it is usually nicer than a bunch of >>= chains + lambda
04:39:12 <Guest2542> let {foo f g = foo f (\a -> g (f a))}  in foo id (*) 2 2
04:39:16 <ronh-> @undo do line1 <- getLine; line2 <- getLine; return (line1 ++ line2)
04:39:16 <lambdabot> getLine >>= \ line1 -> getLine >>= \ line2 -> return (line1 ++ line2)
04:39:53 <Guest2542> let {foo f g = foo f (\a -> g (f a))}  in (foo id (*)) 2 2
04:40:21 * stobix laughs at the @undo command. :)
04:40:53 <arjen-jonathan> Hi all, question about type theory here: I'm looking for a functional type system somewhere in between System F and Hindley Milner. Stricter than System F such that types are unique (beta-eta equivalence is annoying when proving properties), but with syntax directed type checking.
04:40:56 <stobix> @type (>>=)
04:40:57 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:41:28 <arjen-jonathan> I thought that maybe HM with enough type annotations in Let expressions / lambda-abs might do the job, but I'm unsure...
04:41:54 <arjen-jonathan> I this a sensible quest or does such a system not exist?
04:43:23 <Guest2542> argh! so close, so it needs a base case. then i am to patern match on there only being one argument supplied!?
04:43:29 <jle`> zipper: on my phone, but can answer something quick :)
04:44:38 <Guest2542> is there a function that returns the number of arguments required by a supplied function?
04:44:48 <Guest2542> e.g. numArgs (*) = 2
04:44:54 <Guest2542> or even 3
04:45:07 <Guest2542> nono 2
04:45:08 <tdammers> Guest2542: short answer, no.
04:45:11 <quchen2> Functions take only one argument.
04:45:22 <jle`> Guest25: there are a couple of issues with such a function :)
04:45:24 <Guest2542> so how can i terminate this computation?
04:45:24 <ronh-> all functions take one argument, so: f _ = 1  ;)
04:45:27 <bernalex> Guest2542: numArgs = const 1
04:45:46 <Guest2542> let {foo f g = foo f (\a -> g (f a))}  in foo id (*) 2 2
04:45:46 <quchen2> bernalex: No, because const 1 1 = 1, but numArgs 1 should be 0 ;-)
04:45:48 <tdammers> a more meaningful question would be "does this function return a function"
04:45:57 <bernalex> quchen2: he said functions
04:46:14 <Guest2542> yes thats the terminating case tdammers exatly, i need that boolean function
04:46:21 <zipper> This has me quite confused I feel as if I am repeating myself too much. Also I don't see how to get something meaningful out of L25 https://gist.github.com/urbanslug/e20a715f837bf0975544
04:46:23 <tdammers> but there is no point checking that at runtime, because the type system doesn't allow for a situation where a function could return a function or a non-function depending on runtime circumstances
04:46:28 <bernalex> quchen2: so numArgs :: (a -> b) -> Int. :-]
04:46:32 <Guest2542> isFunc :: (!?) -> Bool
04:46:41 <zipper> jle` This has me quite confused I feel as if I am repeating myself too much. Also I don't see how to get something meaningful out of L25 https://gist.github.com/urbanslug/e20a715f837bf0975544
04:46:45 <tdammers> again, checking this at runtime is pointless
04:46:57 <tdammers> the only situation where this check would make sense is at the type level
04:47:04 <bernalex> I don't understand the usecase for checking this at runtime
04:47:07 <tdammers> and type checks do exactly this
04:47:14 <zipper> jle`: Your being in a hurry means I can't formulate a well structured question.
04:47:16 <jle`> that's like saying isInt :: Double -> Bool
04:47:22 <zipper> jle`: Sorry
04:47:32 <jle`> of course isInt is const False :)
04:47:36 <zipper> jle`: Me?
04:47:36 <jle`> the types guarantee it!
04:47:43 <tdammers> if you need a value that can be a function or not a function depending on runtime situation, you'll need to explicitly cater for both options, e.g. using a sum type
04:47:45 <jle`> zipper: sorry not you
04:47:52 <jle`> I'll look at it
04:47:54 <Guest2542> foo f g = foo f (\a -> g (f a))
04:48:01 <tdammers> data CouldBeFunction a b = Function (a -> b) | NotFunction b
04:48:04 <Guest2542> this needs a base case
04:48:07 <tdammers> then you can pattern match on it
04:48:29 <tdammers> what is foo supposed to do?
04:48:46 <tdammers> or let me rephrase that
04:48:47 <Guest2542> apply a function to all arguments of another function
04:48:49 <tdammers> what is foo's type?
04:49:15 <jle`> zipper: I'd use a blip stream to emit whoever someone wants to reg
04:49:15 <_d0t> ohai. How do I change my email on hackage?
04:49:23 <Guest2542> foo :: (a -> b) -> (a -> a -> ... -> a) -> (b -> b -> ... -> b)
04:49:39 <jle`> getReg :: Message -> Maybe Username
04:49:54 <jle`> and then emitJusts getReg
04:50:15 <zipper> jle`: My problem is consuming those blips.
04:50:17 <dibblego> CouldBeFunction ~ Cokleisli Maybe
04:50:19 <Guest2542> :t let {foo f g = foo f (\a -> g (f a))}  in foo 
04:50:20 <lambdabot> (t2 -> t2) -> (t2 -> t1) -> t
04:50:26 <jle`> then you can use scanB from Control.Auto.Blip, which is like accum but only accums when blips come in
04:50:32 <zipper> jle`: I can't pattern match them like (Blip nick)
04:50:35 <liste> is that type even inhabited?
04:50:56 <Guest2542> inhabited?
04:51:05 <zipper> jle`: What if I wanted to do something close to pattern matching a blip?
04:51:09 <jle`> yeah, you can only manipulate blip streams using the stream transformers in Control.Auto.Blip
04:51:13 <liste> Guest2542 inhabited means that there is a non-bottom value for that type
04:51:15 <tdammers> the issue is that you can't do ... in type signatures
04:51:21 <zipper> jle`: Oh I see.
04:51:21 <tdammers> because, again, haskell functions are unary
04:51:23 <Guest2542> um no its not
04:51:31 <Guest2542> thats the problem
04:51:43 <jle`> things like collapsing, generating, merging streams
04:51:53 <Guest2542> so i need to terminate by patern matching a function with 0 arguments
04:51:55 <jle`> in this case you're consuming a stream
04:52:01 <merijn> tdammers: Actually, you can, provided you throw sufficient number of extensions at the issue
04:52:07 <tdammers> merijn: well, sure
04:52:12 <merijn> tdammers: i.e. TypeFamilies can recurse over a function type like that
04:52:17 <tdammers> yes
04:52:22 <tdammers> you can pull the printf trick
04:52:32 <Guest2542> awesome
04:52:42 <tdammers> but, ugh
04:52:42 <jle`> Guest2542: the issue is that Haskell isn't meant to be able to express things like this in that way
04:52:46 * hackagebot observable-sharing 0.1.0.0 - Simple observable sharing  http://hackage.haskell.org/package/observable-sharing-0.1.0.0 (mararon)
04:52:58 <jle`> usually it means that you are looking for the wrong solution to your bigger problem
04:53:34 <tdammers> since the arguments are going to be of the same type anyway (because otherwise f doesn't unify), I'd probably resort to passing a list of arguments rather than using a fully curried function
04:53:46 <jle`> there are ways to do it using extensions and some hacky trickery, but usually when this happens there's a good chance you're fighting haskell instead of going along with it
04:54:08 <tdammers> i.e., foo :: (a -> b) -> ([b] -> c) -> ([a] -> c)
04:54:08 <chandru_in> I'm using mysql-simple and I see linking errors when trying to build a static binary with "ghc --make -static -rtsopts=all -optl-pthread -optl-static Main.hs". The error is like "undefined reference to `operator delete[](void*)'"
04:54:12 <jle`> there might be a much simpler way to express what you want
04:54:25 <jle`> that doesn't involve an impossible typw
04:54:29 <Guest2542> if i was using a list there would be no fun
04:54:44 <Guest2542> and i would first have to curry my whole library
04:54:46 <tdammers> there would be a functor though
04:54:54 <Guest2542> apply the functions, and uncurry again
04:55:11 <tdammers> also, are your functions all of type a -> a -> a -> a -> ... -> b?
04:55:20 <Guest2542> so then the function i need is the arbritrary length curry and uncurry functions, which would have to patern match on this non function
04:55:31 <tdammers> :t curry
04:55:32 <lambdabot> ((a, b) -> c) -> a -> b -> c
04:55:33 <jle`> zipper: yeah, the main tools for working with blip streams are all in that module, so look in there if you want to do something with one :)
04:55:42 <jle`> anyways I g2g so good luck!
04:55:47 <tdammers> note how curry uses tuples, not lists
04:55:56 <teclo-> it's called curryfication, or something 
04:56:16 <Guest2542> yes all the functions are over one class
04:56:20 <pacak> :t uncurry
04:56:21 <lambdabot> (a -> b -> c) -> (a, b) -> c
04:56:44 <Guest2542> but for a list
04:56:48 <Guest2542> not a pair
04:57:02 <Guest2542> *tuple
04:57:14 <chandru_in> Am I doing something wrong in the static linking. Do people statically link the mysql client in haskell usually?
04:57:48 <Guest2542> TypeFamilies?
04:58:29 <Guest2542> um nvm
04:58:32 <merijn> tdammers: No, the typefamilies trick is completely unrelated to the printf trick
04:59:10 <zipper> jle`: Thank you.
04:59:28 <nshepperd> Guest2542: fwiw it seems like you can do this with typeclasses, but all the solutions I've found require adding lots of type annotations at point of use
04:59:36 <nshepperd> which basically defeats the point
05:00:20 <Guest2542> bar :: (a -> a -> ... -> a -> b) -> [a] -> b
05:01:04 <Cale> chandru_in: What happens if you just use --make (and possibly -rtsopts=all)
05:01:06 <Cale> ?
05:01:06 <liste> Guest2542 if you need to make a Double wrapper for the Float library, I guess Template Haskell would be your best bet
05:01:09 <liste> https://github.com/leonidas/codeblog/blob/master/2011/2011-12-27-template-haskell.md
05:01:20 <Guest2542> thanks
05:01:30 <liste> it's pretty arcane though
05:01:36 <Guest2542> but really i am interested in this more general aproach with currying
05:01:47 <chandru_in> Cale, it works fine and creates a dynamic executable
05:02:29 <tdammers> merijn: yeah, I think I remember vaguely
05:02:35 <liste> Guest2542, variadic functions are pretty rare in Haskell and not usually that useful
05:02:53 <Guest2542> they seem omnipotent
05:02:55 <tdammers> merijn: but I also remember that once you go down that path, you're usually in for some rather painful compiler error reading
05:03:27 <Guest2542> if its so much a headache it will go on the shelf, but i need the power
05:03:47 <Guest2542> i cant see why haskell cant detect a non function...
05:03:52 <tdammers> it can
05:03:58 <tdammers> it just doesn't make sense to do it at runtime
05:04:12 <Guest2542> i cant live with this 
05:04:27 <ronh-> you can't use a function and non-function in the same place, it won't typecheck
05:04:27 <tdammers> haskell is not a dynamically-typed programming language
05:04:38 <Cale> :t printf
05:04:39 <lambdabot> PrintfType r => String -> r
05:04:47 <hodapp> I ran into some issues with variadic functions in that it ended up being easier to just generate definitions foo1... foo10 than to have mandatory (foo arg1 arg2.... :: ReturnType) to resolve the ambiguity because of where 'foo' was used
05:04:49 <Guest2542> no, all the types are presented at compilation time...
05:04:57 <Cale> In fact...
05:04:59 <Guest2542> i need to patern match
05:05:17 <tdammers> in that case, the simplest solution is to wrap your "possibly a function" thing in a dedicated type
05:05:29 <tdammers> then you can pattern match on the type's constructors
05:05:33 <Guest2542> hodapp this sounds interesting
05:06:01 <tdammers> you could of course do what hodapp said; might even use TH to generate those functions
05:06:23 <Myrl-chan> I don't think /r/haskell liked my drawing. :9
05:06:24 <Myrl-chan> ;-;
05:06:25 <lpaste> nshepperd pasted “Variadic Madness” at http://lpaste.net/132913
05:06:58 <Guest2542> but i can write f (a:b) and (f a) b so can i not make a constructor that works like left asociative bracketing?
05:07:20 <Cale> Guest2542: What do you mean?
05:08:01 <chandru_in> Cale, am I doing something wrong?
05:08:17 <Cale> chandru_in: I don't know. I've never had to pass options to the linker via GHC
05:09:22 <Guest2542> i can construct a list, so i can recures on it, but my function             let {foo f g = foo f (\a -> g (f a))}  in foo id (*)           dies without a base case, i cant pattern match the non function because i have no constructor to chain arguments together like a left associative bracket
05:09:34 <Guest2542> let {foo f g = foo f (\a -> g (f a))}  in foo id (*)     
05:09:43 <Cale> :t let {foo f g = foo f (\a -> g (f a))}  in foo id (*)
05:09:44 <lambdabot> t
05:10:01 <Guest2542> let {foo f g = foo f (\a -> g (f a))}  in foo id (*)    2 2
05:10:02 <Cale> This is an infinite loop for certain, just due to its type alone
05:10:09 <Guest2542> yes
05:10:12 <Guest2542> this is the problem
05:10:13 <Cale> :t let {foo f g = foo f (\a -> g (f a))}  in foo id (*)    2 2
05:10:14 <lambdabot> t
05:10:24 <Cale> yep, there are lots of ways to write infinite loops
05:10:30 <Guest2542> wow!
05:10:38 <Guest2542> so, lets write the base case!
05:10:46 <Cale> What base case?
05:11:03 <Cale> You've written something which can have any type whatsoever
05:11:09 <Cale> So it *must* be an infinite loop
05:11:18 <Guest2542> f has definate type though
05:11:39 <Guest2542> foos type depends on the type of f
05:11:54 <Guest2542> this should be determined at compilation as all the information is there
05:12:09 <Cale> Here, let me write you a simpler one
05:12:14 <Cale> :t let x = x in x
05:12:15 <lambdabot> t
05:12:37 <Guest2542> this dos not do what i want it to though
05:12:43 <Cale> Neither does what you wrote
05:12:47 <Guest2542> lol
05:12:50 <nshepperd> > ((\x y z -> x + y + z) <$> ($(1::Int)) <*> ($2) <*> ($3)) fromIntegral :: Double -- silliness
05:12:53 <lambdabot>  6.0
05:13:39 <Cale> Guest2542: What runtime behaviour do you expect? You have a value which may have any type whatsoever. So if I want it to be an Integer, it's got to be an Integer. If I want it to be a String, it had better be a String.
05:13:42 <Guest2542> wow nshepperd what are these crazy <*> things
05:14:08 <Cale> Guest2542: The only programs which can pull off such a trick are those which never finish computing a value.
05:14:30 <Cale> Guest2542: Because if the program actually produced an Integer, then we would know that it didn't compute a String after all.
05:14:55 <Cale> a defined Integer, that is
05:15:03 <Cale> and not _|_
05:15:20 <Cale> Guest2542: right?
05:15:40 <Cale> Guest2542: Note that in Haskell, types do not exist in any form at runtime.
05:16:18 <Guest2542> is so confusing
05:16:30 <Cale> Guest2542: The process of compilation erases types, so when a function takes an argument which is of any type, say, the only reason it can validly do so is because it doesn't actually care at all about the value of the thing it's given.
05:16:35 <Cale> It doesn't look at it.
05:16:36 <Guest2542> i want to apply a function to all arguments of a function
05:16:54 <Cale> Well, that's easy
05:16:56 <Cale> :t (.)
05:16:57 <lambdabot> (b -> c) -> (a -> b) -> a -> c
05:17:23 <Cale> Every function really only accepts one argument
05:17:39 <Cale> Every function has type A -> B for some types A and B
05:18:11 <Guest2542> foo f g a b = foo f (\a -> g (f a)) a b = foo f (g (f a)) b = foo  f (\b -> (g (f a)) (f b)) 
05:18:23 <Cale> Haskell doesn't have multiparameter functions, it only looks like it does.
05:18:48 <Cale> (and well, the compiler has some internal notion of specialised compiled versions of functions which take multiple arguments at once)
05:18:59 <luzie> :t let foo f g a b = foo f (\a -> g (f a)) a b = foo f (g (f a)) b = foo  f (\b -> (g (f a)) (f b)) in foo
05:19:00 <lambdabot> parse error on input ‘=’
05:19:04 <maerwald> at user-level you can think of multiparameter functions, though... it's just important to know that currying is behind that and that it allows partial application
05:19:12 <Cale> But conceptually, every function takes just one argument, and those which appear to take more are just producing other functions as their result.
05:19:19 <luzie> oops
05:19:25 <Guest2542> :t let foo f g a b == foo f (\a -> g (f a)) a b == foo f (g (f a)) b == foo  f (\b -> (g (f a)) (f b)) in foo
05:19:26 <lambdabot> parse error on input ‘in’
05:19:36 <Guest2542> no
05:20:12 <maerwald> sadly that's not possible ... you cannot just compare functions abstractly
05:20:13 <tdammers> Guest2542: if you want something to be able to "be" either a function or a non-function at runtime, you have to find or declare a type that can express this for you
05:20:32 <tdammers> Either (a -> a) a -- would work, for example
05:20:35 <Cale> Guest2542: Look at this though:
05:20:48 <Cale> > foldr (\x xs -> x : xs) [] [1,2,3,4,5]
05:20:50 <lambdabot>  [1,2,3,4,5]
05:21:06 <Cale> > foldr (\x xs k -> x + k : xs (k+1)) (const []) [1,2,3,4,5] 0
05:21:07 <lambdabot>  [1,3,5,7,9]
05:21:13 <Guest2542> i dont like your datatpye wrapper tdammers
05:21:19 <nshepperd> even from the perspective where functions have 'multiple parameters', applying something to 'all arguments' isn't well defined, because at which point the function is 'still accepting arguments' or has 'produced a result' may be up to the user
05:21:31 <tdammers> Guest2542: what do you not like about it?
05:21:32 <Guest2542> i dont believe i can use it in the way i mean
05:21:33 <Cale> > foldr (\x xs k l -> x + k * l : xs (k+1) (l+1)) (\k l -> []) [1,2,3,4,5] 0 1
05:21:34 <lambdabot>  [1,4,9,16,25]
05:21:42 <Cale> How many arguments does foldr take?
05:21:49 <zipper> Oh my my emacs haskell setup is getting slow.
05:21:51 <zipper> :(
05:22:03 <Cale> > foldr (\x xs k l m -> x + k * l * m : xs (k+1) (l+1) (m+1)) (\k l m -> []) [1,2,3,4,5] 0 1 2
05:22:05 <lambdabot>  [1,8,27,64,125]
05:22:30 <maerwald> nshepperd: right, a nice example is foldl in terms of foldr
05:22:36 <Guest2542> what the hell is going on thats fantastic
05:22:42 <Cale> :t foldr
05:22:43 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
05:22:56 <Cale> well, okay, let's skip the Foldable ugliness
05:23:06 <Cale> foldr :: (a -> b -> b) -> b -> [a] -> b
05:23:15 <Cale> So, the result type of foldr is polymorphic
05:23:17 <Guest2542> actually no you achieved nothing! your lambda expression is not general like mine is
05:23:28 <Cale> That is, we get to choose what type b is
05:23:36 <Guest2542> you have to write out one more piece for each new argument
05:23:45 <Cale> So we can choose b to be a function type
05:23:50 <Cale> If we want to
05:23:55 <Guest2542> hmmmm
05:24:14 <Cale> and it will be *as if* foldr takes another argument, but really that's not the case.
05:24:46 <Cale> foldr takes exactly one argument, of type (a -> b -> b), and it produces exactly one result, a function of type (b -> [a] -> b)
05:25:25 <Cale> an even simpler example, how many arguments does id take?
05:25:30 <Cale> > id
05:25:32 <lambdabot>      No instance for (Typeable a0)
05:25:32 <lambdabot>        arising from a use of ‘show_M156481939069985026825512’
05:25:32 <lambdabot>      In the expression:
05:25:35 <Cale> > id 0
05:25:37 <lambdabot>  0
05:25:40 <Cale> > id id 0
05:25:41 <lambdabot>  0
05:25:43 <Cale> > id id id 0
05:25:45 <lambdabot>  0
05:25:47 <Cale> > id id id id 0
05:25:49 <lambdabot>  0
05:26:04 <ronh-> Cale I take it you're not fond of the accepted Foldable/Traversable proposal? ;)
05:26:13 <Cale> ronh-: Just Foldable
05:26:21 <Denommus> is there a database library for Haskell with a monadic interface, like LINQ in C#?
05:26:44 <Cale> Traversable on its own is okay as far as I'm concerned
05:26:56 <Cale> It has reasonable laws and it's a well-defined thing
05:27:03 <ronh-> and Foldable?
05:27:05 <liste> Denommus esqueleto
05:27:12 <Guest2542> id be happy if i just knew how to do what im trying too...
05:27:14 <Cale> Foldable is just kind of a mess, and it seems impossible to write down meaningful laws for it
05:27:23 <Guest2542> im not convinced this must be done at runtime
05:27:35 <Cale> You can write down a bunch of laws, but you can't specify what foldMap is supposed to do.
05:27:45 <liste> Denommus and take a look at opaleye too, it has an Arrow interface
05:27:50 <Denommus> liste: cool, thanks
05:28:16 <Cale> Guest2542: Well, what program are you trying to get written? What input and output behaviour are you trying to achieve?
05:28:38 <Guest2542> apply a function to all arguments of another function
05:28:48 <Guest2542> restrict types only as much as nescacary
05:29:00 <Cale> Well, since every function has exactly one argument, that is easy.
05:29:08 <Guest2542> i.e. the functions must all be over only one type
05:29:11 <Cale> and it is accomplished by function composition
05:29:37 <Cale> There is really no such thing in Haskell as a function of two arguments.
05:29:55 <Cale> We just treat functions of one argument which produce other functions as if they are functions of two arguments.
05:29:58 <Guest2542> let foo f g  = foo f (\a -> g (f a))  in foo id (*) 2 2 2
05:30:09 <frerich> Guest2542: Do you mean something as in 'apply3 f g a b c = g (f a) (f b) (f c)' for funcitons with different numbers of arguments than 3?
05:30:12 <luzie> https://hackage.haskell.org/package/vect-0.4.7/docs/Data-Vect-Float-Util-Quaternion.html they want a wrapper for this that takes  doubles instead of floats because they like doubles
05:30:47 <Guest2542> yes frerich exactlly, for arbritrary number of arguments, but a fixed number, to be determined by ghc at compilation time
05:30:59 <Cale> Guest2542: Okay, here's a question for you. Suppose I define the function  foo = (\x -> (\y -> (\z -> x + y + z)))
05:31:15 <Cale> Guest2542: er, let's not reuse foo
05:31:21 <Cale> Maybe we'll call my function bar
05:31:28 <Cale> bar = (\x -> (\y -> (\z -> x + y + z)))
05:31:31 <Cale> okay?
05:31:35 <Cale> And your function is foo
05:31:41 <Guest2542> lol luzie, no it this application of realToFrac all over my code just motivated the question, i just want to learn how to recurse on function asociation
05:32:00 <luzie> don't do it
05:32:23 <Guest2542> i am going to do it
05:32:45 <Guest2542> bar x y z = x+y+z
05:32:51 <pacak> :t foldMap
05:32:52 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
05:33:00 <Cale> Guest2542: How many arguments does bar have?
05:33:17 <Guest2542> bar x y z takes no arguments
05:33:18 <Cale> (this is where I check whether you've been listening to me)
05:33:23 <Guest2542> bar takes 3
05:33:29 <Cale> bzzt
05:33:36 <Guest2542> 1
05:33:38 <Cale> yes
05:33:45 <Guest2542> bar x takes one
05:33:52 <Cale> yep
05:33:55 <Guest2542> and (bar x) y 1 also
05:34:02 <Cale> That's right
05:34:34 <Guest2542> so thats how i end up with foo f g = (\a -> g (f a))
05:34:54 <Cale> right, plain function composition
05:35:01 <Cale> (well, flipped in your case)
05:35:40 <Guest2542> sorry foo f g a b = foo f (\a -> g (f a)) 
05:36:01 <Cale> :t let foo f g a b = foo f (\a -> g (f a)) in foo
05:36:02 <lambdabot>     Occurs check: cannot construct the infinite type:
05:36:02 <lambdabot>       t7 ~ t5 -> t6 -> t7
05:36:02 <lambdabot>     Relevant bindings include
05:36:10 <Guest2542> foo f g  == foo f (\a -> g (f a)) 
05:36:10 <Cale> Doesn't typecheck.
05:36:25 <Guest2542> sorry the a and the b were from an example
05:36:36 <t7> lambdabot: wot u want?
05:36:36 <Guest2542> :t foo f g a b == foo f (\a -> g (f a)) 
05:36:37 <lambdabot>     Not in scope: ‘foo’
05:36:37 <lambdabot>     Perhaps you meant ‘T.for’ (imported from Data.Traversable)
05:36:37 <lambdabot>     Not in scope: ‘foo’
05:36:41 <Guest2542> :t foo f g a b = foo f (\a -> g (f a)) 
05:36:42 <lambdabot> parse error on input ‘=’
05:36:51 <Guest2542> :t let foo f g a b = foo f (\a -> g (f a))  in foo
05:36:52 <lambdabot>     Occurs check: cannot construct the infinite type:
05:36:52 <lambdabot>       t7 ~ t5 -> t6 -> t7
05:36:52 <lambdabot>     Relevant bindings include
05:36:57 <Denommus> I'm still confused about signals and events in Gtk2Hs. Which one should I use? Why is there a difference between them?
05:37:15 <t7> can we stop constructing types with t7 in them please guiz
05:37:23 <Guest2542> yeh sry
05:37:35 <Cale> heh
05:37:59 <luzie> :t let foo f g a = foo f (\a -> g (f a))  in foo
05:37:59 <Guest2542> sorry for that cale... we are on the same page?
05:38:00 <lambdabot>     Occurs check: cannot construct the infinite type: t5 ~ t4 -> t5
05:38:00 <lambdabot>     Relevant bindings include
05:38:00 <lambdabot>       a :: t4 (bound at <interactive>:1:13)
05:38:13 <luzie> sorry mistyped
05:38:14 <Cale> Guest2542: The point I'm trying to make is that what you're asking for doesn't make sense because Haskell has no notion of the number of arguments that a function accepts.
05:38:33 <maerwald> I think it could be achieved with template haskell or so
05:38:47 <Guest2542> :t let foo f g = foo f (\a -> g (f a))  in foo
05:38:48 <lambdabot> (t2 -> t2) -> (t2 -> t1) -> t
05:39:08 <suppi> Why does using +RTS -N4 makes this code 2x slower than +RTS -N1 ? does anyone have an idea? http://lpaste.net/164732701838934016
05:39:09 <Guest2542> riiiiiiiiiiiiiigh
05:39:13 <Guest2542> right*
05:39:54 <Guest2542> but everything i supply has a set type, im telling it how many arguments to expect!! im telling it the type in my definition of f
05:40:06 <stobix> For instances of MonadPlus, is join ≡ mplus?
05:40:21 <Cale> stobix: no, they don't even have the same type
05:40:24 <Cale> :t join
05:40:25 <merijn> stobix: Those types don't match at all
05:40:27 <lambdabot> Monad m => m (m a) -> m a
05:40:28 <merijn> :t mplus
05:40:31 <lambdabot> MonadPlus m => m a -> m a -> m a
05:40:40 <stobix> Haha
05:40:51 <stobix> Yeah. Wrong question, I guess.
05:40:52 <luzie> suppi: starting threads is probably more expensive than your code
05:41:08 <stobix> oh
05:41:09 <stobix> yeah
05:41:12 <stobix> s/mplus/msum
05:41:14 <Cale> Guest2542: Where are you telling it how many arguments to accept?
05:41:24 <Guest2542> in the type of f
05:41:32 <Guest2542> foo f g  = foo f (\a -> g (f a)) 
05:41:36 <Cale> Guest2542: The type of f is not an argument to foo
05:41:36 <stobix> Rather: "Can join always model msum for ModelPlus instances"
05:41:52 <Cale> Guest2542: Only f is an argument to foo.
05:41:52 <Guest2542> but the compiler can find out the type
05:42:06 <stobix> :t msum
05:42:07 <lambdabot> (Foldable t, MonadPlus m) => t (m a) -> m a
05:42:08 <hodapp> tdammers: I am not proud to admit that I am generating those functions right now with Python, not with Haskell >_>
05:42:27 <stobix> Hm?
05:42:30 <hodapp> if I learn some TH, it'll be for that.
05:42:33 <tdammers> hodapp: so you admit that python is more powerful than haskell, hah!
05:42:47 <stobix> That's not the msum definition from the hackage page I read.
05:42:48 <hodapp> tdammers: I admit that I know how to generate code easily in Python :P
05:42:51 <frerich> maerwald: TH functions only take a single argument, too. The only thing TH might help you with is to generate 'adapter' functions like 'apply3 f g x y z = g (f x) (f y) (f z)' given some function (because you can inspect the type at runtime)
05:42:56 <liste> stobix a `mplus` b `mplus` c == msum [a, b, c]
05:43:06 <maerwald> frerich: yes and that can help him
05:43:13 <liste> stobix maybe you mean mappend from Monoid?
05:43:24 <Cale> Guest2542: The compiler perhaps knows the type of the argument you supply to foo at compile time (it might actually not know the full type and be in the process of attempting to infer it, but we'll ignore that for now)
05:43:41 <Cale> Guest2542: But when foo is actually going to be doing its work, it's not compile time.
05:43:42 <Guest2542> foo :: (a->b) ->  (a -> a -> ...  -> a -> c) -> (b -> b -> ... -> b -> c)
05:43:44 <suppi> luzie, what if my computation is really almost nothing? something like `print $ sum [1..10000]` ?
05:43:54 <ronh-> ah, fond memories of python.. where mistyping a variable name results in a crash
05:43:57 <Cale> Guest2542: It's runtime, and the type of f is nowhere to be found.
05:44:20 <Cale> Guest2542: foo is provided with f itself, but not a representation for the type of f
05:44:25 <suppi> luzie, i can't see noticeable difference between -N1 and -N4 in this case
05:44:58 <Guest2542> how do i make it work?
05:45:09 <luzie> dunno then, not familiar with rts
05:45:17 <maxc01> @hoogle mconcat
05:45:17 <lambdabot> Data.Monoid mconcat :: Monoid a => [a] -> a
05:45:23 <Guest2542> without wrapping a function of 0 args into Either
05:45:23 <Cale> Guest2542: If foo had a representation for the type of f handy, perhaps it could do something different for different choices of f, but in Haskell, we don't have dependent types, so the type of later arguments to a function cannot really depend on the values of previous arguments.
05:45:54 <stobix> liste: I just read through https://hackage.haskell.org/package/base-4.2.0.2/docs/Control-Monad.html#5 and thought that "since [] is a monad, msum looks like a special case of join"
05:46:07 <hodapp> unless you want to do some GHC.TypeLits haxory.
05:46:13 <Cale> Guest2542: You could use a type class, with many instances which define what foo does at different types.
05:46:24 <suppi> luzie, thanks
05:46:34 <Guest2542> i cant only treat functions defined over one type? e.g. sumCurry :: Num a => a -> a -> a -> ... -> a -> a
05:47:04 <Cale> Guest2542: What is this ... notation?
05:47:14 <Guest2542> why am i not have sumCurry!!??
05:47:17 <Cale> That's not Haskell syntax.
05:47:36 <stobix> liste: I guess my question really is "if I feed join with a list, will the same happen as if I feed msum with the list?"
05:47:44 <Guest2542> but you understand the function required?
05:47:49 <Cale> Guest2542: Nope!
05:47:58 <Guest2542> to patern match the base case that is a 0 argument function
05:48:18 <Guest2542> i think foo should be called applyN
05:48:34 <Cale> Guest2542: First of all, I sort of get the idea that sumCurry is supposed to take some numeric arguments. So would you please tell me what type  sumCurry 1 2 3  has?
05:48:53 <divVerent> I think the understanding problem is that Haskell only really has 1-arg functions
05:49:07 <Cale> divVerent: Yeah, I think so as well.
05:49:07 <divVerent> so how is this "sumCurry" supposed to know when it's done and now has to return a value and not a function?
05:49:31 <Guest2542> (sumCurry (1::Int) 2 3 ) ::Int
05:49:32 <divVerent> technically what you could do is to invent a weird PartialSym type
05:49:41 <divVerent> that is instance of Num (and acts as the final sum)
05:49:53 <divVerent> and also is a function to add another item
05:49:55 <Cale> Guest2542: Okay, so sumCurry 1 2 3 4 is a type error then, right?
05:49:56 <divVerent> that MIGHT be possible somehow
05:50:09 <divVerent> but then, sumCurry 1 2 3 4 wouldn't REALLY be the same as 10
05:50:16 <Guest2542> ooooooh
05:50:20 <Guest2542> now i am see
05:50:21 <Cale> Guest2542: sumCurry 1 2 3 is an Int, which Int is it?
05:50:26 <Cale> Is it 6?
05:50:29 <Cale> If it's 6
05:50:34 <divVerent> then 6 4 is a problem
05:50:38 <Cale> Then  sumCurry 1 2 3 4  means  6 4
05:50:39 <Cale> right
05:50:41 <Guest2542> it is
05:50:50 <Guest2542> it is a very sad day
05:50:57 <Cale> So you're applying 6 :: Int as if it's a function, which makes no sense
05:50:59 <Guest2542> i am not having sumCurry
05:51:05 <divVerent> but what if sumCurry is an object "somehow" supporting ($) and being an instance of Num?
05:51:14 <divVerent> this could at the same time be x == 6 and x 4 == 10
05:51:26 <Cale> Sure, we could do that.
05:51:34 <divVerent> but it'd cause lots of other problems with type inference
05:51:38 <divVerent> so I'd not recommend going there
05:51:39 <Guest2542> aaaaaaaaaaaaah
05:52:08 <Guest2542> its left asociative bracketing, im never appling 4 to 6 im applying 4 to (sumCurry 1 2 3)
05:52:10 <Cale> @let data SumObject = SO { another :: Int -> SumObject; done :: Int }
05:52:10 <lambdabot>  Parse failed: Parse error: ;
05:52:14 <Cale> @let data SumObject = SO { another :: Int -> SumObject, done :: Int }
05:52:15 <lambdabot>  Defined.
05:52:23 <maerwald> use TH with nast apply2 apply3 apply4 etc functions or ask someone like Edward to solve it for you
05:52:30 <divVerent> Cale: yes, that will sure work :P
05:52:37 <frerich> Guest2542: Right, function application is left-associative
05:52:55 <Guest2542> at the left i find a function. otherwise functionOf4args 1 2 ( 3 4) -- omg no!! 
05:53:06 <maerwald> if there is some weird category theory solution, Edward should know
05:53:15 <Cale> @let sumCurry n = SO { another = \m -> sumCurry (n+m), done = n }
05:53:17 <lambdabot>  Defined.
05:53:31 <suppi> Why does using +RTS -N4 makes this code 2x slower than +RTS -N1 ? does anyone have an idea? http://lpaste.net/164732701838934016
05:53:45 <suppi> or does anyone know where can I ask about it?
05:53:46 <Cale> > done (sumCurry 0 `another` 1 `another` 2 `another` 3)
05:53:47 <lambdabot>  6
05:55:00 <Guest2542> :type SO
05:55:17 <Guest2542> :type another
05:55:28 <Guest2542> omg
05:55:48 <Guest2542> what is this trickery?
05:55:52 <Cale> :t SO
05:55:53 <lambdabot> (Int -> SumObject) -> Int -> SumObject
05:55:56 <Cale> :t another
05:55:57 <lambdabot> SumObject -> Int -> SumObject
05:56:00 <Cale> :t done
05:56:02 <lambdabot> SumObject -> Int
05:56:12 <Guest2542> oh, sorry
05:56:54 <pacak> suppi: No sparks, Parallel strategies are not working
05:57:01 <stobix> can lambdabot tell me where to find things, like SO above?
05:57:11 <Cale> stobix: I *just* defined that datatype
05:57:14 <suppi> pacak, yes, I know
05:57:16 <Cale> and the operations on it
05:57:18 <merijn> stobix: You mean like Hoogle?
05:57:19 <Cale> In the channel
05:57:19 <stobix> heh
05:57:24 <stobix> ah. @let
05:57:43 * stobix might have a slight need of sleep, and does all the dumb things.
05:57:55 <suppi> pacak, but how can I improve if the base speed drops 2x without me doing anything?
05:58:05 <ronh-> @src sumCurry
05:58:06 <lambdabot> Source not found. Sorry.
05:58:40 <Cale> ronh-: If you want the source, look up a bit. @src reads from a hand-curated text file
05:58:54 <ronh-> Cale I know. I wanted to see how smart @src was
05:59:11 <Cale> It is as dumb as you could imagine any implementation of it being
05:59:26 <pacak> suppi: well... Try to remove tracing - it might affect your code. ghc spends much more time doing GC - memory profiling might help.
06:00:35 <suppi> pacak, how do I do that?
06:01:02 <Guest2542> :t sumCurry
06:01:03 <lambdabot> Int -> SumObject
06:01:12 <suppi> pacak, or where can i find a tutorial or material about the subject?
06:01:19 <Guest2542> :t sum
06:01:20 <lambdabot> (Num a, Foldable t) => t a -> a
06:01:30 <pacak> suppi: https://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html - some info about profiling
06:01:41 <suppi> pacak, thanks
06:02:43 <exio4> suppi: ghc's profiller, threadscope, and runtime parameters are really nice when writing parallel code
06:02:46 <Guest2542> so the uncurryed list is not foldable?
06:03:03 <c_wraith> lists aren't functions
06:03:04 <Guest2542> i can itterativly apply curry to create first tuples then lists to make a foldable structure?
06:03:06 <exio4> @type sum :: [Int] -> Int
06:03:07 <lambdabot> [Int] -> Int
06:03:09 <c_wraith> only functions can be curried or not
06:03:30 <pacak> suppi:  https://donsbot.wordpress.com/2008/06/04/haskell-as-fast-as-c-working-at-a-high-altitude-for-low-level-performance/ [-]
06:04:06 <suppi> pacak, exio4, thank you
06:04:40 <Cale> Guest2542: hm?
06:05:04 <Guest2542> im trying to define applyN
06:05:06 <Cale> Guest2542: What do you mean by "the uncurryed list"?
06:05:09 <Cale> What's that?
06:05:22 <Guest2542> same as un uncuried tuple but a list
06:05:35 <Guest2542> (+) $ uncurry (1 2)
06:05:36 <Cale> What's an uncurried tuple?
06:05:39 <Guest2542> (+) $ uncurry (1, 2)
06:05:47 <Guest2542> ffs
06:05:49 <Cale> Oh, so you mean a type error?
06:05:54 <Cale> heh
06:05:59 <Cale> > (+) $ uncurry (1, 2)
06:06:01 <lambdabot>      Couldn't match expected type ‘a -> b -> c’
06:06:01 <lambdabot>                  with actual type ‘(Integer, Integer)’
06:06:01 <lambdabot>      In the first argument of ‘uncurry’, namely ‘(1, 2)’
06:06:12 <Cale> :t uncurry
06:06:13 <lambdabot> (a -> b -> c) -> (a, b) -> c
06:06:22 <Cale> uncurry takes a function as its argument
06:06:26 <Cale> and produces another function
06:06:49 <Guest2542> yeh ok, so same thing but for lists not tuples
06:06:57 <Cale> hm?
06:07:02 <Cale> What do you mean by that?
06:07:10 <Guest2542> :type uncurry
06:07:10 <Cale> What type does it have?
06:07:15 <Guest2542> :t uncurry
06:07:16 <lambdabot> (a -> b -> c) -> (a, b) -> c
06:07:23 <Cale> :t foldr
06:07:24 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
06:07:56 <Cale> foldr is to lists (ignore this Foldable t thing, just read t a as [a]), what uncurry is to tuples
06:08:32 <Cale> foldr f z xs replaces each occurrence of (:) in the construction of xs with f and the [] at the end (if any) with z
06:08:58 <Cale> Just as uncurry f p replaces the pair constructor (,) with f in the construction of p
06:09:10 <Guest2542> sorry got distracted for a sec, ill try and write the type
06:09:43 <Cale> Guest2542: If you write some nonsense involving dots... :)
06:09:56 <Guest2542> uncurryn :: (a -> a -> .. -> a -> b) -> [a] -> b
06:10:13 <exio4> Guest2542: again, that type doesn't make sense
06:10:13 <Cale> Again with the dots
06:10:29 <Guest2542> yeh sorry about the dots but if i knew how to write it i wouldnt be here
06:10:56 <exio4> Guest2542: if you want a "varidic function", we don't have those, what you want is a function working directly over the list
06:11:05 <exio4> probably, I don't know what you are actually solving
06:11:20 <tdammers> you can achieve compile-time variadicness using some typeclass hackery
06:11:47 <tdammers> basically what you do is you make your foo function a typeclass method, and then implement suitable instances for both the recursive and the base case
06:11:47 <Guest2542> no, curry and tuples is not fold and lists. there is nothing about function composition in fold. i want to supply a list of arguments to a function, not to fold a list
06:12:57 <ronh-> :t foldr (.)
06:12:58 <lambdabot> Foldable t => (a -> b) -> t (b -> b) -> a -> b
06:13:30 <Cale> Guest2542: We're all trying to make you realise that what you're asking for doesn't actually make any sense.
06:13:41 <Guest2542> it does make sense
06:13:47 <tdammers> not at runtime
06:13:52 <Guest2542> merg
06:14:39 <tdammers> if you want polymorphic behavior at runtime, then you need types that reflect the rules for said polymorphism
06:15:02 <tdammers> if you want something to be able to be either a scalar or a function at runtime, then you need a type that can contain either
06:15:13 <Guest2542> i cant just take the head of a list of inputs and supply it as the first argument to a function of many arguments, and ittertivly do this until i have consumed the whole list and just hope i gave it the right number of arguments?
06:15:32 <Cale> Guest2542: What type would your operation have?
06:15:36 <exio4> the problem is the type
06:15:39 <geekosaur> the type system doesn't do "just hope"
06:15:51 <tdammers> that's kind of the entire point
06:16:08 <Guest2542> it should throw an error if i supply it the wrong number, anyway it should be infered
06:16:20 <exio4> how? with the length? 
06:16:27 <tdammers> if you want it inferred, you need to design your types accordingly
06:16:31 <exio4> something that isn't known at runtime? 
06:16:44 <Cale> Guest2542: How is it supposed to know how many arguments is okay?
06:16:57 <Guest2542> im not really working with a list, im giving it a function of definate type, the concept of the list is not really correct here, its of set length
06:17:26 <bernalex> this smells like x/y problem
06:17:46 <Cale> Guest2542: So okay, which type does the function have?
06:17:46 <Guest2542> applyN f g = applyN (\a-> f (g a))
06:17:47 <luzie> it is :)
06:18:26 <lpaste> tdammers pasted “"variadic" higher-order function” at http://lpaste.net/132916
06:18:29 <bernalex> Guest2542: that's not possible
06:18:30 <Cale> Guest2542: If you can statically determine the type of the function rather than writing some nonsense involving dots, maybe we can figure out what your function is supposed to actually do
06:18:31 <Guest2542> atm the type has dots in because i dont know how to massage the syntax correctly, maybe there is a foldable type in there
06:18:37 <tdammers> this is the closest I can get to the dots thing
06:18:59 <tdammers> notice how it takes quite a bit of type forcing to resolve ambiguities...
06:19:24 <tdammers> the dots thing isn't just a syntax problem though
06:20:07 <Guest2542> tdammers this looks good
06:20:12 <tdammers> it's not
06:20:19 <Guest2542> because?
06:20:23 <bernalex> Guest2542: that looks like uh fix ((. (.)) . (.))
06:20:29 <bernalex> Guest2542: which is not possible with GHC.
06:20:39 <Guest2542> wow
06:20:55 <tdammers> because it's not idiomatic, and because it fucks up type inference
06:21:11 <bernalex> well mostly the latter. it's kind of just nonsense.
06:21:18 <tdammers> indeed
06:21:28 <tdammers> I've done this before and regretted it deeply
06:21:35 <bernalex> oh, I have too, of course
06:21:44 <bernalex> if I hadn't, how would I know how nonsenical it is?
06:21:48 <tdammers> haha
06:21:49 <tdammers> yeah
06:22:12 <Guest2542> its sensicle
06:22:12 <bernalex> *nonsensical
06:22:22 <tdammers> for starters, use plain print instead of printInt in my example to see how the type inference breaks when really it shouldn't
06:22:36 <luzie> I want a sensicle
06:22:54 <tdammers> a sense sickle
06:22:55 <bernalex> luzie: you can't have it, it's its sensicle!
06:22:56 <tdammers> hmm
06:23:07 <tdammers> sickle some sense into people, huh
06:23:47 <bernalex> Guest2542: try extending GHC's typechecker to allow that function, and you'll be enlightened.
06:23:54 <bernalex> Guest2542: also, what are you even trying to do, and why?
06:24:23 <bernalex> tdammers: your example is cute btw.
06:25:13 <Guest2542> applyn f g = applyn (\x->g (f x)), but with a base case
06:25:40 <Cale> Guest2542: We mean, what program were you trying to write when you decided you needed this applyn thing?
06:25:44 <divVerent> I've got an idea for a function that can take a function f :: a1 -> ... -> an -> b, and n values, and returns a value of type b
06:25:47 <divVerent> and it works in Haskell
06:25:50 <divVerent> Usage:
06:25:51 <Guest2542> nono not relevantt
06:26:02 <divVerent> func f 1 2 3 4 == f 1 2 3 4 ;)
06:26:05 <divVerent> func = id
06:26:20 <Guest2542> wow such humour
06:26:22 <bernalex> Guest2542: haha that's even worse. that's like fix '((. flip (.)) . (.))'. what are you *really* trying to do? what are you hoping to achieve using this function? what morphism are you after?
06:26:23 <Cale> Guest2542: It is relevant
06:26:27 <ocharles_> are any gtk2hs devs around?
06:26:45 <ocharles_> I'd like some advice on how to contribute to the project (I need the GtkGlArea widget)
06:26:51 <Guest2542> applyn f g = applyn f (\x->g (f x)) 
06:27:08 <Cale> Guest2542: All of these functions are infinite loops
06:27:10 <dcoutts> ocharles_: I did bind it in the past
06:27:29 <bernalex> Cale: no not that last one
06:27:38 <ocharles_> dcoutts: hi! is there any code generation stuff I should be aware of, or is it mostly a case of writing files?
06:27:42 <Cale> Well, even if we ignore the fact that they're type errors
06:27:45 <mniip> Guest2542, http://xyproblem.info/
06:27:45 <bernalex> Cale: no clue what it's supposed to do
06:27:49 <Guest2542> applyn realToFrac would be nice...
06:27:57 <Cale> Even in an untyped language, they would be infinite loops
06:28:11 <Guest2542> mniip dead link
06:28:13 <bernalex> Cale: the last thing they posted should be applyn :: (a -> a) -> (a -> b) -> c
06:28:14 <ocharles_> dcoutts: so far I just copied the code for GtkDrawingArea to GtkGlArea and was going to work on that (but I'm still convincing Nix to give me a working dev environment)
06:28:15 <dcoutts> ocharles_: I think I originally used the gtk2hs code gen as a basis, but it needs manual work
06:28:24 <mniip> Guest2542, works over here
06:28:25 <bernalex> Cale: and a legal function.
06:28:26 <tdammers> I believe the sanest way would be to just generate or manually write individual apply1, apply2, ... applyn functions for a sufficiently large n
06:28:29 <Cale> bernalex: yeah, okay
06:28:32 <ocharles_> ok, that sounds similar to what I'm doing then
06:28:41 <dcoutts> ocharles_: see if you can find the old implementation
06:28:46 <bernalex> Cale: not sure what the point of it is though
06:28:47 <hodapp> mniip: works here too
06:28:54 <tdammers> where "sufficiently large" probably equals 7
06:28:57 <dcoutts> ocharles_: it'll be in the darcs/git repo somewhere in the history, if it's not still around
06:28:59 <mniip> Guest2542, another explanation: http://mywiki.wooledge.org/XyProblem
06:29:00 <tdammers> (traditionally)
06:29:00 <frerich> Guest2542: Don't get too frustrated, it can be tough if you have some idea in mind which seemingly makes perfect sense and then you get bashed by an entire IRC room of people who've been thinking in Haskell-terms for years ;-)
06:29:00 <Cale> bernalex: Some of them are valid infinite loops in Haskell, others don't typecheck, but would be infinite loops in an untyped lambda calculus.
06:29:11 <ocharles_> dcoutts: what is the old version? was it rewritten or something?
06:29:18 <bernalex> Cale: yes it's an infinite loop at runtime, I assume.
06:29:27 <Cale> bernalex: He keeps writing functions which do nothing but apply themselves to new arguments
06:29:32 <dcoutts> ocharles_: a working binding of GtkGlArea
06:29:34 <Cale> I don't understand why.
06:29:37 <Guest2542> yeh i guess we wouldnt have zip7 if this syntax was sensicle
06:29:39 <dcoutts> ocharles_: from like 8 years ago
06:29:40 <ocharles_> oh, nice
06:29:40 <bernalex> Cale: I'm confused too.
06:29:41 <ocharles_> heh
06:29:46 <ocharles_> before it was an official widget, I guess
06:29:51 <dcoutts> ocharles_: I used it for undergrad practicals on Solaris sparc machines :-)
06:29:56 <ocharles_> :)
06:30:05 <Cale> Guest2542: All tuple types are completely separate and unrelated data types
06:30:17 <bernalex> Guest2542: "sensicle" is not a word, and if you need zip7 you probably have other problems with your life. haskell has ADTs and currying and stuff.
06:30:24 <dcoutts> ocharles_: at the time GtkGlArea (or was it GtkGlWidget) was an out-of-gtk-tree project
06:30:26 <Guest2542> @let applyn f g = applyn f (\x->g (f x))
06:30:27 <lambdabot>  Defined.
06:30:31 <ocharles_> yea, it's in gtk3 now
06:30:34 <dcoutts> ocharles_: I understand it's now in gtk proper
06:30:50 <bernalex> I can't imagine anyone ever using zip7, and then afterwards going "yep, this looks nice."
06:30:50 <Cale> Guest2542: You should also basically never have any need for anything much larger than a triple, and even triples are rare.
06:30:53 <dcoutts> ocharles_: anyway, probably useful to find the old binding at least for reference, since it did actually work
06:30:58 <ocharles_> yea, for sure
06:31:08 <ocharles_> thanks!
06:31:09 <Cale> Guest2542: It's usually pair or other custom datatype entirely.
06:31:09 <Guest2542> bernalex im trying to curryn
06:31:21 <bernalex> Guest2542: that doesn't make sense. all haskell functions are already curried.
06:31:28 <dcoutts> ocharles_: np
06:31:33 <Cale> Guest2542: Let's evaluate your definition of applyn applied to some arguments f and g
06:31:44 <bernalex> Guest2542: this isn't scala or whatever. we just don't need a curryN. it doesn't make any sense to have it.
06:32:06 <bernalex> Cale: let's not. we'd be here for quite some time.
06:33:22 <Cale> applyn f g -> applyn f (\x -> g (f x)) -> applyn f (\y -> (\x -> g (f x)) (f y)) -> applyn f (\z -> (\y -> (\x -> g (f x)) (f y)) (f z)) -> ... 
06:33:35 <Cale> Guest2542: This is never going to terminate
06:33:48 <Cale> Guest2542: right?
06:33:56 <Cale> Guest2542: How is it supposed to ever finish?
06:33:56 <Guest2542> applyn id (+) = applyn id (\a->f (id a)) = applyn id ((+) a) = (applyn id) (\b->((+) a) b) = (applyn id) (a+b) = a+b
06:34:04 <Cale> huh?
06:34:07 <Cale> no
06:34:09 <Guest2542> yes
06:34:17 <Guest2542> patern match me that base case
06:34:35 <Guest2542> as discussed we could use a datatype such as Either or SumObject to do so
06:35:04 <exio4> if you use SumObject, you are reimplementing fold
06:35:11 <Cale> applyn id (+) -> applyn id (\x -> (+) (id x)) -> applyn id (\y -> (\x -> (+) (id x)) (id y)) -> applyn id (\z -> (\y -> (\x -> (+) (id x)) (id y)) (id z)) -> ...
06:35:12 <Guest2542> oops the f should be a (+ in the above)
06:35:28 <Cale> You screwed up your function application somewhere
06:35:32 <Cale> This doesn't terminate at all
06:35:57 <mniip> applyn ... = applyn ...
06:36:07 <mniip> definition of the function itself implies nontermination
06:36:26 <Guest2542> why would it try to apply (+) to three arguments, it should have stopped
06:36:38 <Cale> Where is it doing that?
06:36:39 <merijn> Guest2542: How would it know when to?
06:36:45 <Guest2542> when it had consumed as many inputs as the type of (+) required
06:36:51 <Cale> It's only applying (+) to one argument
06:36:58 <Cale> specifically to (id x)
06:37:05 <Cale> never to two
06:37:11 <Guest2542> then goes on to apply it to (id x) (id y)
06:37:15 <Cale> It never applies the resulting function
06:37:16 <Cale> no
06:37:21 <Cale> That doesn't happen
06:37:21 <Guest2542> oh yeh
06:37:27 <Guest2542> that was lesson 21
06:37:28 <Guest2542> 1
06:37:30 <Guest2542> ok
06:37:31 <Guest2542> ok
06:37:33 <merijn> It applies the *result* of "(+)" applied to "id x"
06:37:36 <Guest2542> so how am i doing this?
06:37:41 <mniip> Guest2542, once again
06:37:42 <Cale> merijn: Actually, it doesn't do that
06:37:44 <merijn> Guest2542: You're not going to
06:37:45 <mniip> what are you trying to fo
06:37:47 <mniip> do
06:37:55 <Cale> Look at my sequence of reductions
06:38:04 <Cale> It's just building up a bunch of nested lambdas forever
06:38:19 <merijn> Cale: Oh, I only looked at the small expression he mentioned
06:38:29 <Guest2542> what was wrong with mine i applied ((+) a) b is ok?
06:38:50 <Cale> Guest2542: hm?
06:39:15 <luzie> they wanted to turn a library using Float into one using Double
06:39:43 <Guest2542> i would have a base case such as applyn f g | hasOneInput g = (\a-> g (f a))
06:40:05 <mniip> how do you know whether a function has one input
06:40:11 <Cale> Guest2542: hasOneInput is true of all functions
06:40:13 <mniip> does (+) have one input?
06:40:17 <Guest2542> (+) 1 has one input
06:40:23 <Cale> (+) has one input
06:40:24 <Guest2542> :t (+) 1
06:40:26 <lambdabot> Num a => a -> a
06:40:30 <mniip> (+) has one input too
06:40:35 <Guest2542> :t (+)
06:40:36 <lambdabot> Num a => a -> a -> a
06:40:40 <Cale> a -> (a -> a)
06:40:40 <Guest2542> see, two
06:40:44 <Cale> see, one
06:40:46 <mniip> see, 'a' is the input, a->a is output
06:40:47 <Guest2542> gad damnit
06:40:53 <Cale> It produces a function as its result
06:41:05 <frerich> Guest2542: Note that function application is left-associative, but the '->' in the type signatures is right-associative, i.e. you have 'a -> (a -> a)'.
06:41:11 * frerich should just shut up, somebody else is always faster :}
06:41:11 <luzie> :t (+) x
06:41:12 <lambdabot> Expr -> Expr
06:41:18 <Cale> Also, check this out...
06:41:21 <luzie> see?
06:41:37 <Guest2542> 1::Expr
06:41:55 <Cale> @let instance (Num b) => Num (a -> b) where { (f + g) x = f x + g x; fromInteger n x = fromInteger n }
06:41:56 <lambdabot>  .L.hs:145:10: Warning:
06:41:56 <lambdabot>      No explicit implementation for
06:41:56 <lambdabot>        ‘*’, ‘abs’, ‘signum’, and (either ‘negate’ or ‘-’)
06:42:08 <Cale> (the instance I gave is incomplete, but nonetheless...
06:42:09 <Cale> )
06:42:14 <Cale> (+) 1 2 3 4 5 6
06:42:16 <Cale> > (+) 1 2 3 4 5 6
06:42:17 <lambdabot>      Could not deduce (Num a0)
06:42:17 <lambdabot>      from the context (Num a,
06:42:17 <lambdabot>                        Num a4,
06:42:21 <mniip> Guest2542, also, how many, in your logic, does 'id' take
06:42:22 <Cale> > (+) 1 2 3 4 5 6 :: Integer
06:42:23 <lambdabot>      No instance for (Num (a0 -> a1 -> a2 -> a3 -> Integer))
06:42:23 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
06:42:23 <lambdabot>        arising from a use of ‘+’
06:42:26 <Cale> heh
06:42:45 <luzie> :^)
06:43:03 <mniip> :t id
06:43:04 <lambdabot> a -> a
06:43:05 <mniip> :t id `asTypeOf` ($)
06:43:06 <lambdabot> (a -> b) -> a -> b
06:43:07 <Guest2542> i dont want to add functions together!!
06:43:08 <Cale> oh, right
06:43:53 <Cale> My instance didn't take because lambdabot is picky about warnings
06:43:55 <Cale> tsk
06:44:03 <Guest2542> :set
06:44:27 <Guest2542> ill put it into ghci
06:44:34 <mniip> Guest2542, your request doesn't make sense
06:44:38 <Cale> @let instance (Num b) => Num (a -> b) where { (f + g) x = f x + g x; (f * g) x = f x * g x; abs f x = abs (f x); signum f x = signum (f x); negate f x = negate (f x); fromInteger n x = fromInteger n }
06:44:39 <mniip> all functions in haskell are unary
06:44:40 <lambdabot>  Defined.
06:44:46 <divVerent> BTW, just found:
06:44:49 <divVerent> https://wiki.haskell.org/Varargs
06:44:52 <divVerent> this looks relevant
06:44:53 <mniip> because they are all curried
06:44:58 <Cale> > (+) 1 2 3 4 5 6 :: Integer
06:44:59 <lambdabot>  3
06:45:07 <Cale> Tell me how many arguments (+) takes again?
06:45:20 <Guest2542> let instance is not ok
06:45:22 <Cale> Was it two?
06:45:22 <divVerent> essentially the trick here is that the destination type becomes an instance of a new typeclass
06:45:59 <Cale> Guest2542: I just added an instance of Num for functions, so that the 'a' in the type of (+) could be chosen to be a function type.
06:46:14 <Guest2542> but is now crazy!!!!11
06:46:19 <Cale> It's not crazy
06:46:44 <stobix> that's really cool
06:46:57 <Guest2542> hmm its fixing the problem?
06:47:01 <Cale> It's perfectly sensible to treat functions whose codomain is a sort of number as themselves a sort of number.
06:47:15 <Cale> > (sin + cos) 5
06:47:15 <mniip> Guest2542, the best you can do is to make a series of 'on'-like functions
06:47:16 <lambdabot>  -0.6752620891999122
06:47:25 <Cale> > sin 5 + cos 5
06:47:27 <lambdabot>  -0.6752620891999122
06:47:30 <mniip> :t on
06:47:31 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
06:47:36 <Guest2542> and this? http://okmij.org/ftp/Haskell/polyvariadic.html#polyvar-fn
06:47:53 <stobix> > (sin + cos) 5
06:47:54 <Guest2542> what is this 'on'-like?
06:47:55 <lambdabot>  -0.6752620891999122
06:48:01 <Guest2542> lol
06:48:06 <Cale> > (sin^2 + cos^2) 5
06:48:08 <lambdabot>  0.9999999999999999
06:48:14 <Guest2542> sin*sin pi
06:48:17 <stobix> oh, I love it
06:48:30 <Guest2542> (+) + (+)
06:48:39 <stobix> :t (+) + (+)
06:48:40 <lambdabot> Num a => a -> a -> a
06:48:44 <Guest2542> (+) + (+) 1 2
06:48:46 <mniip> > ((+) + (+)) 3 4
06:48:47 <lambdabot>  14
06:48:49 <mniip> fun
06:48:54 <luzie> cool
06:48:57 <Guest2542> you just broke haskell
06:49:01 <mniip> no he didn't
06:49:04 <Cale> Not at all, this is part of Haskell.
06:49:07 <Guest2542> its broken now
06:49:12 <mniip> no it isn't
06:49:21 <mniip> you can still do everything you've done before
06:49:24 <Guest2542> is it the relavent thing?
06:49:28 <Cale> I haven't broken type safety in any way
06:49:36 <Guest2542> now i can define applyn?
06:49:40 <mniip> you can't
06:49:46 <Cale> applyn still makes no sense at all
06:49:50 <mniip> not without extensions of some sort
06:49:58 <mniip> a typefamily maybe?
06:50:01 <Cale> Well, some of your attempts to define it made sense, but were just infinite loops
06:50:23 <Cale> Guest2542: You seemed to think that (+) took 2 arguments
06:50:37 <Guest2542> so how can the compiler determine the number of arguments but not dop my applyn?
06:50:42 <Guest2542> do*
06:50:43 <Cale> Guest2542: I wanted to show you that in fact, there is no meaningful number of arguments that it takes apart from 1.
06:50:49 <mniip> number of arguments is always 1
06:51:05 <frerich> Cale's instance makes me feel queasy. :-(
06:51:07 <Cale> It does not determine the number of arguments here
06:51:09 * mniip mumbles something about pap wrapper implementation details
06:51:29 <Big_G> Is it possible to have two methods with the same name but different signatures?
06:51:31 <Cale> Well, the typechecker kind of does, at some point
06:51:36 <Cale> But that's the type checker
06:51:57 <Guest2542> yeh ok so im not using that, im using a pluss that cannot be overridden and made crazy
06:52:01 <tdammers> Big_G: methods as in typeclass methods, or methods as in OOP methods?
06:52:20 <tdammers> also, depends on your definition of "signature"
06:52:26 <tdammers> you can have polymorphic signatures...
06:52:39 <Cale> (+) certainly isn't counting the number of arguments it is receiving. It gets a type class dictionary for Num supplied to it implicitly, along with exactly one argument, it unpacks one particular field of the type class dictionary (the one for (+)) and blindly applies it to the argument
06:52:44 <Guest2542> :t (\a b c -> [])
06:52:45 <lambdabot> r -> r1 -> r2 -> [t]
06:52:47 <frerich> Cale: I first thought your Num instance for a -> b was immoral and probably opens a black hole but by now I'm convinced it actually makes sense. Does it also adhere to the laws? Also, are there maybe other interesting classes which give unexpected benefits when defining instances for a -> b?
06:52:56 <Big_G> tdammers, Sorry. I meant functions
06:53:12 <Cale> frerich: yes, it's the ring of functions
06:53:33 <frerich> Cale: Can I bail out right away pointing out that I had no exposure to math education beyond high school? :-}
06:53:39 * frerich seems to recall 'ring' is some mathy thing
06:53:56 <Cale> frerich: You can generalise this to an arbitrary monad, sort of, but the general instances don't really work out without stupid overapping instances extensions.
06:53:57 <geekosaur> hang around this channel long enough and you will learn
06:54:07 <Guest2542> so as i am always returning a function having consumed one argument, then i can see when i cannot take an argument. e.g. ((+) 1 2) 3
06:54:13 <Big_G> Also, how much type-safer is Haskell to languages like Java? It seems like all the basic stuff you can do in Haskell like creating custom types can be done in those languages as well
06:54:21 <Cale> frerich: Or Applicative for that matter
06:54:22 <Guest2542> the function ((+) 1 2) is not returning a fucntion
06:54:26 <Guest2542> so it is my base case
06:54:49 <Cale> frerich: For any applicative functor F, it makes sense to define an instance (Num a) => Num (F a) where (+) = liftA2 (+), etc.
06:54:53 <SrPx> What exactly is Conjugate and why it keeps showing on my types?
06:54:57 <ronh-> who else read "ring of functions" in Cash's voice
06:55:00 <Guest2542> 1 . 1
06:55:06 <Hafydd> Hahahaqh.
06:55:14 <Hafydd> I fell down into a burning ring of functions.
06:55:24 <Cale> Guest2542: But sometimes it is
06:55:42 <merijn> Big_G: Well, there's several things
06:55:42 <Cale> Guest2542: (+) doesn't know whether its argument is a function even
06:55:50 <Cale> Guest2542: at runtime, this information is not present
06:56:07 <Guest2542> nono, i just want it to pass type check and compile
06:56:15 <merijn> Big_G: First of, haskell's type system is more powerful in that it can specify more things than Java's can. Secondly, it's less verbose, so doing things is easier/costs less typing
06:56:20 <Guest2542> im not doing anything crazy at runtime
06:56:29 <Cale> Guest2542: At compile time, we arrange for the concrete implementation of the Num operations to be passed in and (+) just extracts the appropriate definition of addition and blindly applies it
06:56:37 <merijn> Big_G: And then there's the fact that java doesn't track IO effects in the types
06:56:51 <Cale> Guest2542: The code being executed at runtime has no notion of types at all
06:56:53 <Big_G> merijn, Specify more how?
06:57:02 <Big_G> I will definitely agree on IO though
06:57:03 <Guest2542> yeh so im not using addition because i dont want any instance of Num... its confusing the thing im sure
06:57:05 <stobix> hm
06:57:34 <Cale> Guest2542: So it has no way of determining whether or not something is or is not a function.
06:57:40 <stobix> Cale: Could one define an Ord (a -> b) as well? To do esoteric stuff like (sin < cos) 3
06:57:56 <Cale> stobix: That's trickier to do in any coherent way
06:57:59 <merijn> Big_G: If you look at the sort of types some of the extensions let you write
06:58:01 <mniip> Guest2542, try a simpler function then
06:58:02 <mniip> id
06:58:03 <Guest2542> applyn f g = applyn f (\a -> g (f a))
06:58:15 <Cale> stobix: You can certainly define an instance, but it's not likely to be a total order
06:58:22 <Big_G> merijn, Any examples?
06:58:24 <merijn> Big_G: For example, take heterogeneous lists, I don't think those are easily doable in Java. Certainly not together with an "apply" function
06:58:36 <merijn> Big_G: https://gist.github.com/merijn/dc00bc7cebd6df012c5e
06:58:41 <Cale> stobix: and even so, most of the notions of ordering of general functions aren't computable
06:58:45 <Big_G> merijn, What is there difference between a hetero list and a regular list?
06:58:57 <frerich> Guest2542: Do you know the 'flip' function?
06:59:03 <merijn> Big_G: Regular list all items have the same type
06:59:20 <Guest2542> flip f a b == f b a
06:59:23 <merijn> Big_G: Heterogeneous lists (can) have items with different types
06:59:48 <frerich> Guest2542: Yep - you would agree that it doesn't change 'the number of arguments' which the given function takes, right? It just flips their order?
06:59:51 <Big_G> merijn, Why would I use a hetero list instead of a custom data structure then? How could I traver that list as an elemtn could have any type?
07:00:01 <Guest2542> i agree
07:00:17 <frerich> Guest2542: Another standard function is 'id', you know that one I guess?
07:00:24 <Cale> stobix: You could do something like instance (Ord a) => Ord (Bool -> a) where f <= g = f False <= g False || (f False == g False && f True <= g True)
07:00:26 <Guest2542> id a = a
07:00:44 <frerich> Guest2542: Right. Can you guess what the type of 'flip id' might be -- or whether it type-checks at all?
07:00:54 <Guest2542> :t flip id
07:00:56 <lambdabot> b -> (b -> c) -> c
07:00:56 <frerich> That was a pretty mind-bending (and eye-opening) example to me when I first saw it.
07:01:05 <Cale> stobix: Which would let you have things like Map (Bool -> String) String
07:01:10 <Guest2542> !?
07:01:18 <frerich> Guest2542: Notice how 'id' takes "just one argument" but 'flip id' suddenly "takes two" (in your terminology)
07:01:41 <merijn> Big_G: Look at the example code and the type for someList :)
07:01:43 <Guest2542> yes i am very confused, it now wants another function
07:01:45 <mniip> ohh, the old flip id trick
07:01:54 <Hafydd> flip lid
07:01:58 <merijn> Big_G: It's tracking the type of each element in type of the HList :)
07:02:08 <Cale> frerich: Good koan!
07:02:25 <frerich> Guest2542: This is a bit similiar to the 'a -> b' instance for Num and how '(+)' suddenly takes more arguments than two.
07:02:44 <Big_G> merijn, In that example, the only valid input is a list of size 3 with a bool, char, and int?
07:02:45 <Guest2542> (+) 1 2 3 4
07:02:53 <bernalex> :t flip ($) -- this is also cute
07:02:55 <lambdabot> a -> (a -> c) -> c
07:02:57 <merijn> Big_G: Right
07:03:03 <Guest2542> :t ($)
07:03:04 <ronh-> Big_G as far as type safety goes, there's no implicit null reference in haskell, which eliminates a whole class of potential runtime errors
07:03:05 <lambdabot> (a -> b) -> a -> b
07:03:09 <frerich> Guest2542: The id function is of type 'a -> a'. But that 'a' can be anything. In particular, it could be '(x -> y)'.
07:03:11 <Cale> Guest2542: Remember that for the bot to evaluate your expression, you have to prefix it with "> "
07:03:15 <Big_G> merijn, Why would I use that versus a regular data type?
07:03:15 <merijn> Big_G: If you would try "apply (+) someList" it would give a type error
07:03:20 <saulzar_> Nice trick :)
07:03:25 <merijn> Big_G: It depends
07:03:28 <Big_G> ronh-, I already know about Maybe
07:03:36 <Guest2542> >(+) 1 2 3 4
07:03:46 <Cale> The space is also necessary
07:03:50 <Guest2542> > (+) 1 2 3 4
07:03:52 <lambdabot>  3
07:04:03 <Cale> (this is to prevent the bot from responding to someone typing >:) or something
07:04:07 <Guest2542> :t (+)
07:04:08 <lambdabot> Num a => a -> a -> a
07:04:23 <mniip> Guest2542, id :: a -> a, now substitute a with x -> y
07:04:37 <Guest2542> :t (+) (\a b-> a+b)
07:04:39 <lambdabot> Num a => (a -> a -> a) -> a -> a -> a
07:04:42 <frerich> Guest2542: See? Just like 'id' seemingly just taking one argument, '(+)' seems to take just two. but what it actually does is to take two values of type 'a' and 'a' could be a function type itself.
07:04:56 <merijn> Big_G: One of the reasons I wrote (something) like this is that I had to apply an FFI function against the right number of arguments (computer somewhere else), and different FFI functions took different numbers of arguments. I wanted to statically check all of them got the right arguments, but didn't want to explicitly write the application for each of them
07:05:08 * frerich hopes Cale will correct him when he's totally off, because I never saw that 'Num (a -> b)' trick before...
07:05:16 <Cale> That's okay :)
07:05:18 <stobix> Cale: Why can't I do something analogous to what you did for instance Num (a -> b)? In other words, why does (f+g) x = f x + g x work, when (f > g) x = f x > g x doesn't?
07:05:23 <merijn> Big_G: If you can get away with a fixed data structure, then that's probably simpler and better. But you can't always do that
07:05:30 <exio4> I think that's just the applicative instance
07:05:30 <Big_G> merijn, Like when?
07:05:37 <Guest2542> you need to make an instance of ORD
07:05:40 <Guest2542> Ord*
07:05:43 <Cale> stobix: What's the type of (>)?
07:05:45 <Denommus> what's the name of that FRP library for GHCJS that provides a monadic API for composing the HTML DOM as a FRP behavior?
07:05:48 <Cale> :t (>)
07:05:49 <lambdabot> Ord a => a -> a -> Bool
07:05:59 <Cale> It produces a result of type Bool, not a function type.
07:06:00 <merijn> Big_G: When you want to write code that is generalised for functions of different number and types of input arguments
07:06:01 <Guest2542> he just has an instance of Num
07:06:13 <saulzar_> Denommus, reflex?
07:06:26 <merijn> Big_G: Oh, another neat trick is https://gist.github.com/merijn/6130082
07:06:28 <Cale> (well, heh, it really produces a function of type a -> Bool of course, but that's besides the point here)
07:06:50 <Denommus> saulzar_: that's the one! Thanks
07:07:07 <stobix> Cale: ah. So for that to work, I'd have to make a "Bool instance" for (a -> a) as well.
07:07:11 <mniip> well, it really produces a partial application closure, but that's
07:07:16 <Cale> stobix: So, in the instance for functions, you're obligated to define  (a -> b) -> (a -> b) -> Bool
07:07:18 <merijn> Big_G: A function that accepts "everything EXCEPT a specific type"
07:07:23 <saulzar_> Denommus, Been playing around with it for the last couple of weeks myself .. there's a channel around here #reflex-frp, too :)
07:07:25 <Guest2542> but why is haskell stopping me from applying one function to all the argumnts of another function?
07:07:43 <Cale> stobix: So your definition there won't typecheck, as Bool is not a function type, so that extra argument makes no sense
07:07:57 * hackagebot warp 3.0.13.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.13.1 (MichaelSnoyman)
07:08:03 <mniip> guest2542, because that's not typecheckable
07:08:04 <Cale> Guest2542: Because there is no notion of what "all the arguments" means
07:08:24 <Big_G> merijn, Didn't you just say that the HList you gave can only have three arguments?
07:08:30 <Denommus> saulzar_: I wanted to make a similar library on top of reactive-banana and Gtk2Hs
07:08:31 <stobix> Cale: Yeah. If bool were a class, I could make it work, I guess. "work" as in "passes inspection", but maybe not as in "makes sense".
07:08:32 <maerwald> Guest2542: are you still on that quest? :D
07:08:38 <merijn> Big_G: No, HList can take any number of types and arguments
07:08:45 <merijn> Big_G: It's only the example that has three
07:08:54 <ronh-> maerwald it has only been 4 hours (yes I checked)
07:09:06 <merijn> Big_G: You can load that files into ghci and play with it, creating your own lists and applying them to check
07:09:11 <ronh-> well, 3 hours and 15 minutes
07:09:12 <maerwald> he should ask the question on the mailing list maybe or so
07:09:28 <Big_G> merijn, Then how do I know how to parse it if it can be of any type? Also, is a FFI similar to a JSON response? I'm trying to find a good way to solve that issue
07:09:55 <saulzar_> Denommus, As far as I can see it can be adapted to work with any IO based gui toolkit, though probably writing the wrapper is most of the work..
07:09:59 <merijn> Big_G: For example, load it into ghci and try ":t Cons (Just ()) someList" and see what the type is :)
07:10:05 <Cale> Guest2542: Are you aware that whenever we write A -> B -> C in types, it really means A -> (B -> C)?
07:10:12 <Guest2542> applyn f g a | isFunction (g a) = applyn  g (f a) |otherwise = g (f a)
07:10:18 <Big_G> merijn, Don't have access to ghci at the moment
07:10:21 <Cale> Guest2542: and that when we write f x y, it really means (f x) y ?
07:10:24 <Guest2542> yes Cale we went over this
07:10:25 <Denommus> saulzar_: is it easier to wrap than reactive-banana?
07:10:43 <saulzar_> Denommus, Not sure - I haven't used reactive-banana much
07:10:54 <Guest2542> i am happy about this revelation but it is not fix problem
07:11:05 <merijn> Big_G: "someList :: HList [Bool, Char, Int]", so "Cons (Just ()) someList :: HList [Maybe (), Bool, Char, Int]"
07:11:10 <Cale> Guest2542: I'm not sure there is a problem to be fixed.
07:11:11 <Guest2542> but is explain why my attempt is broke
07:11:18 <mniip> Guest2542, is undefined a function
07:11:19 <Guest2542> there is certainly a problem
07:11:27 <Guest2542> applyn is broken
07:11:39 <merijn> Big_G: The difference between FFI and JSON is that the number of arguments of an FFI function is statically known at compile time. The value of a JSON response is not
07:11:44 <maerwald> Guest2542: might make more sense to ask this question on the haskell-cafe ML and if you are lucky Edward Kmett will answer. If there is a solution, it is NOT easy.
07:12:02 <merijn> Big_G: Although I'm not sure what you're problem with JSON responses is, so I can't really say if there some neat trick to do
07:12:04 <Big_G> merijn, Is there a way I can read in a JSON response then and hopefull extract a model?
07:12:06 <Guest2542> its easy, its just some currying and catching arguments and stuff
07:12:11 <Guest2542> cant i do it with do and get?
07:12:19 <Guest2542> no i dont want to get all moded
07:12:23 <Guest2542> monaded*
07:12:24 <merijn> Big_G: I've never had to interact with JSON, so I wouldn't be able to say :)
07:12:43 <maerwald> Guest2542: if it was easy... you wouldn't ask this question since more than 3 hours ;)
07:12:47 <Big_G> merijn, Let's say I issue a GET request for a customer. The server returns a Customer object but I don't know the model for a customer ahead of time
07:12:48 <SrPx_> Why won't this code compile? http://lpaste.net/132918 I don't understand it. It is like I can't use (.~) to change the type inside my structure, but I tested with 2 minimalistic types and it worked.
07:12:50 <Cale> Guest2542: Monads are not magic, and they don't let you do anything that you couldn't do without the concept of monads.
07:12:53 <Big_G> Anyone else can help if they know
07:12:57 * hackagebot unix-fcntl 0.0.0 - Comprehensive bindings to fcntl(2)  http://hackage.haskell.org/package/unix-fcntl-0.0.0 (MitsutoshiAoe)
07:13:13 <Guest2542> and worse, they are messy
07:13:21 <Cale> I strongly disagree
07:13:40 <maerwald> Cale: yep, I like to think of "Monads" just as design patterns... and so the use case may greatly differ
07:13:52 <aawe> You can't do monadic composition without monads
07:13:56 <Cale> Monad only exists to save us from writing the same functions over and over in various libraries which happen to define operations which have a certain shape to them
07:13:56 <aloiscochard> philosophical question of the day: which logic do you use to order the definition of your "inner" (in a where block) functions?
07:14:02 <lpaste> todd pasted “what.cpp” at http://lpaste.net/132920
07:14:20 <merijn> aloiscochard: topological sort of dependencies ;)
07:14:30 <unknownloner> can I install/use ghc on an rpi?
07:14:30 <maerwald> aloiscochard: importance
07:14:40 <Cale> aloiscochard: If you were explaining to someone what your program did, where would you begin?
07:14:44 <Guest2542> i cant check the type of my input?
07:14:55 <Cale> Guest2542: Not at runtime, no.
07:15:02 <aloiscochard> merijn: yeah me too, but in which order? less-dependency at top or bottom?
07:15:03 <Cale> Guest2542: Types are compile time only.
07:15:03 <albeit> Is there a primitive difference between declaring a datatype like "MyData {foo:Int, bar:Int}" and accessing via field name "foo myData", and declaring like "MyData Int Int" and accessing via pattern matching? Or does it reduce to the same primitive code?
07:15:11 <merijn> aloiscochard: Least dependencies at the top
07:15:12 <Guest2542> i cant make a function that aks for the number of arguments expected
07:15:13 <mniip> demand order
07:15:13 <Guest2542> ?
07:15:32 <Cale> Guest2542: As we've tried to explain to you, that isn't even a well-defined concept.
07:15:44 <aloiscochard> Cale: yeah, that's kind of what I do with dependency, because usually it's the way I would explain it as well
07:15:51 <geekosaur> albeit: it's the same
07:15:55 <yourname1> quit
07:16:04 <Guest2542> albeit, dont patern match, supply constructors and deconstructors so that you can more easily change your code later if you have to change the datatype constructor
07:16:09 <aloiscochard> merijn: cool thanks for your input
07:16:13 <geekosaur> only difference is automatic declaration of foo :: MyData -> Int etc.
07:16:23 <aloiscochard> I do the same but I was wondering if people would prefer reading in the opposite order
07:16:42 <Cale> Guest2542: The only meaningfully correct function of that sort would be   numberOfArguments :: (a -> b) -> Integer; numberOfArguments f = 1
07:16:50 <albeit> Guest2542: Aren't constructors and deconstructors just pattenr matching internally though?
07:16:53 <Guest2542> no you have not explained to me that it wont work, infact havnt you shown me it working!?
07:17:03 <albeit> geekosaur: Thanks
07:17:20 <Cale> Guest2542: What we showed you isn't what you asked for, as far as I can tell.
07:17:22 <bernalex> Guest2542: all functions in haskell take one argument and produce one result. by design. that's the only amount of arguments any haskell function will ever take.
07:17:25 <Guest2542> and this seems to tell me this varadic studff is fine; http://okmij.org/ftp/Haskell/polyvariadic.html#polyvar-fn
07:17:52 <Guest2542> yes, this is the only information i have recieved, functions take one argument
07:17:57 <Guest2542> to which i respond
07:17:58 <Guest2542> 1.1
07:17:59 <merijn> aloiscochard: Hell, you can pattern match on records too
07:18:03 <Guest2542> 1 . 1
07:18:09 <Cale> hm?
07:18:17 <mniip> that thing also only takes one argument
07:18:17 <mniip> but returns a typeclass-polymorphic result
07:18:20 <Guest2542> and then i can see if i can patern match on my non function
07:19:19 <Cale> Guest2542: Note that the function bb on the page you linked to was a function of type  (BuildList a r) => a -> r
07:19:21 <Guest2542> also it has been demonstraited using a datatype
07:19:25 <Cale> So indeed, it's a function of one argument
07:19:29 <Denommus> saulzar_: ok, I'll try it out
07:19:36 <Guest2542> so this "broken concept" cop out is frustraiting me
07:19:41 <Guest2542> its a matter of syntax
07:19:45 <mniip> no
07:19:54 <Cale> Guest2542: I'm still really not sure what you want.
07:19:56 <mniip> it's a matter of semantics
07:20:19 <mniip> haskell is all about semantics
07:20:23 <Cale> Guest2542: You should show us your original program, and we'll show you how we'd deal with the problem you were having
07:20:35 <Guest2542> applyn
07:20:39 <Guest2542> you know what i mean
07:20:47 <Guest2542> implement applyn
07:20:47 <Cale> Guest2542: No, I really don't.
07:20:57 <Guest2542> ok
07:20:58 <mniip> that's not the *original* problem you're dealing with
07:20:59 <Guest2542> sorry
07:21:07 <Guest2542> it really is the same problem
07:21:22 <mniip> what is the higher level task you're trying to accomplish
07:21:32 <Guest2542> i want to make applyn so i can cast arbritrary functions types using functions like frealToFrac
07:21:46 <mniip> see
07:21:47 <Guest2542> there are other solution to this problem which have been discussed
07:21:51 <mniip> that's different
07:22:08 <Guest2542> what is left unsolved is why i find it impossible to write the function applyn or curryn
07:22:46 <Guest2542> i wish to apply a function to all of the arguments of another function
07:23:00 <mniip> no such thing in haskell
07:23:04 <Cale> The reason you find it impossible is that you can't explain what type these functions ought to have so that people could even begin to comprehend what you're asking for, or even implement them in an untyped language so that we could see what they ought to do.
07:23:08 <mniip> only one argument remember
07:23:12 <maerwald> the problem is that he does not see that it's not an easy solvable problem... so I wouldn't go so far saying it is not possible, but if it is... then it probably involves some sort of nasty category theory stuff
07:23:23 <Guest2542> or, since they have at most one, apply the function to the argument of another function and to any other arguments supplied to it recursivly
07:23:23 <merijn> maerwald: Naah
07:23:36 <Guest2542> i need to identify the base case, the function with 0 arguments
07:23:36 <merijn> maerwald: Just -XKitchenSink a bunch of unsafety and really ugly hacks
07:23:39 <Cale> Other people seem to be guessing at what you want better than I can.
07:23:44 <mniip> "other arguments"
07:23:49 <mniip> there are none
07:23:56 <Cale> But from the examples you've provided, it's really unclear to me what it is you want these functions to be
07:24:25 <maerwald> merijn: ah ok... but the question remains whether it would be possible in a safe way. I cannot imagine how, but that does not mean much
07:25:03 <maerwald> but I don't think we will get a conclusion here
07:25:06 <Cale> Guest2542: There is no such thing as a function of 0 arguments in Haskell
07:25:12 <mniip> Cale, probably something that automatically derives a bifunctor for a given function type
07:25:12 <indiagreen> Guest2542: sorry, I'm late to the party. Can you make a paste with several examples of (roughly) what code you want to write and what output you're expecting? (or give a link if you already have made such a paste and I missed it)
07:25:17 <merijn> maerwald: Actually, more than that
07:25:20 <mniip> er, profunctor
07:25:22 <Cale> Guest2542: Every function has *exactly* one argument.
07:25:28 <Guest2542> (applyn fromIntegral) (^) 2 2
07:25:33 <merijn> maerwald: If we had a a GADT'ed list, that would be sufficient
07:25:43 <merijn> maerwald: But I don't think that as specified it is implementable at all
07:25:48 <merijn> maerwald: Since it lacks a stop condition
07:25:54 <Cale> Guest2542: what would that be equal to?
07:26:03 <Guest2542> 2.0^2.0
07:26:15 <indiagreen> Guest2542: do you mean something like applyn :: (a -> b) -> (a -> a -> ... -> res) -> (b -> b -> ... -> res)
07:26:21 <indiagreen> ouch
07:26:25 <Guest2542> ((applyn fromIntegral) (^) 2 2)::Double
07:26:34 <indiagreen> applyn :: (a -> b) -> (b -> b -> ... -> res) -> (a -> a -> ... -> res)
07:26:47 <Cale> indiagreen: What is that supposed to mean? :)
07:26:49 <Guest2542> yes indiagreen that is the exaty type i desire, but without the dots
07:26:55 <merijn> indiagreen: Except you can't write that, because there's no base case for your recursion
07:27:00 <indiagreen> Cale: Guest2542 wants a generalised “on”
07:27:00 <Cale> indiagreen: He used a similar notation, I don't think it makes any sense.
07:27:09 <Cale> What are the dots?
07:27:17 <mauke[> > let applyn = flip const in ((applyn fromIntegral) (^) 2 2)::Double
07:27:19 <lambdabot>  4.0
07:27:20 <Guest2542> it makes sense, [1..10]
07:27:22 <maerwald> merijn: interesting
07:27:30 <mauke[> Guest2542: that's just sugar for enumFromTo
07:27:49 <Lokathor> Cale, I assume the dots imply that the function magically works for more or less sub-arguments
07:28:05 <Guest2542> so is myne sugar for i cant write an arbritrary number of types in my type definition, so i wish for dots
07:28:05 <indiagreen> Cale: a polyvariadic function. Like “zipWithN :: (a -> b -> ... -> x) -> [a] -> [b] -> ... -> [x]”
07:28:14 <merijn> maerwald: If you had a GADT to recurse on you could basically use the exact same trick I used to implement "apply" in the earlier HList example I pasted here :)
07:28:18 <Guest2542> we haveZipwithN!?
07:28:23 <merijn> maerwald: i.e. https://gist.github.com/merijn/dc00bc7cebd6df012c5e
07:28:27 <Cale> That obviously isn't a valid type :)
07:28:31 <merijn> Guest2542: No, because that's also impossible
07:29:00 <Guest2542> so maybe i was confused and made hopeful by not understanding the limmits of what we can achive with variadic funtions
07:29:10 <indiagreen> Guest2542: we do, but it's a weird, weird piece of typehackery. It's fun to try to understand, but I would really recommend against using it in most cases you want it for
07:29:35 <Cale> Well, there is a general zipWithN that you can define, but it doesn't have that type.
07:29:38 <Guest2542> even if its clumsy, i can wrap that syntax once its fine, your claiming its broken, so why is this not what can be achieved with varyadic functions
07:29:52 <merijn> Guest2542: Haskell doesn't HAVE variadic functions
07:29:53 <c_wraith> The thing is, you *can't* just wrap it.
07:29:59 <c_wraith> It shows up everywhere in types.
07:30:01 <c_wraith> :t printf
07:30:02 <lambdabot> PrintfType r => String -> r
07:30:02 <Guest2542> hmmm
07:30:05 <c_wraith> See?
07:30:14 <Lokathor> Guest2542, what you'd do with a varidic function in say Java, you'd do with just using a list in Haskell.
07:30:23 <Guest2542> even just a useable zipN would be so niec
07:30:25 <Guest2542> nice
07:30:44 <Guest2542> i have never seen printf in haskell before
07:30:57 <Guest2542> it was discussed earlyer and this was lost on me
07:31:05 <merijn> Oooh! I should add a zip for HList to that example :D
07:31:14 <c_wraith> > printf "%s: %f" "hello" 34 :: String
07:31:17 <lambdabot>  "hello: *Exception: printf: bad formatting char 'f'
07:31:27 <c_wraith> Also, it's not very type-safe. :)
07:31:33 <c_wraith> > printf "%s: %d" "hello" 34 :: String
07:31:37 <lambdabot>  "hello: 34"
07:31:45 <Guest2542> anyway id rather have uncurryn for maping functions that work on lists to nested fucntion application
07:32:00 <Guest2542> ill write in my ghci dont worry
07:32:20 <Guest2542> not in scope printf...
07:32:27 <c_wraith> @index printf
07:32:27 <lambdabot> Text.Printf
07:32:28 <indiagreen> @index printf
07:32:28 <lambdabot> Text.Printf
07:32:32 <Guest2542> kk
07:33:20 <Guest2542> it incorperates read and is polyvariadic, nice
07:34:21 <Guest2542> earlyer we wrote sumCurry which wraps it up in a datatype and this was working perfectly right?
07:34:23 <c_wraith> It's also not type-safe, as my first use of it above shows..
07:34:42 <Guest2542> :t sumCurry
07:34:44 <lambdabot> Int -> SumObject
07:34:47 <Cale> Guest2542: That was based on a vague guess at what you were asking for
07:35:14 <Cale> None of the types involved there are in any way variadic
07:35:15 <Guest2542> ok its not finished i need like sumCurry 1 2 3 4 = 10
07:35:30 <Guest2542> and sumCurry 1 2 3 4 5 = 15
07:36:08 <Guest2542> i also want to define this as sumCurry = sum $ curryN 
07:36:26 <mauke[> is this still going on?
07:36:32 <Cale> If that definition works, it means  curryN  is a list.
07:36:33 <mauke[> Guest2542: I want a pony
07:36:50 <Cale> (also you can write it without the $)
07:36:59 <indiagreen> Guest2542: http://hackage.haskell.org/package/polyToMonoid-0.1/docs/Data-PolyToMonoid.html
07:37:03 <ronh-> mauke making the troll quit after 4 hours of undivided attention means we win
07:37:31 <Guest2542> you do that when haskell has curryN, applyN zipN e.t.c.
07:37:58 * hackagebot generic-xmlpickler 0.1.0.1 - Generic generation of HXT XmlPickler instances using GHC Generics.  http://hackage.haskell.org/package/generic-xmlpickler-0.1.0.1 (AdamBergmark)
07:38:31 <Cale> Guest2542: You can't write any of these programs or their type signatures, or coherent English language descriptions of what they do, so it's really hard to help you.
07:38:41 <SrPx> hey I managed to make it work. can someone check if this is acceptable? http://lpaste.net/132921
07:38:42 <Guest2542> curryN a manyMoreArgs | noMoreArgs manyMoreArgs = [] | otherwise = a:(curryN manyMoreArgs)
07:39:06 <Cale> Guest2542: I suggest you type that into a .hs file and try to compile it
07:39:13 <Guest2542> dude
07:39:40 <merijn> Hey, is there a "non-existent type"? i.e. a type I can return from a TypeFamily to force an error?
07:39:41 <Cale> What?
07:39:59 <Cale> merijn: uh, I don't think so
07:40:00 <mauke[> SrPx: I don't really like the undefined in there
07:40:01 <merijn> drat
07:40:13 <SrPx> mauke[: but how else can I do it? :(
07:40:14 <Guest2542> the reason i cant put in haskell syntax is i dont know it, im sure my description of the desired functionality is exhastive
07:40:19 <mauke[> merijn: maybe you can force the type checker into a loop :-)
07:40:21 <mauke[> _|_ ftw
07:40:23 <SrPx> if I pick a number or anything instead of undefined it won't compile
07:40:31 <mauke[> yeah, you can't
07:40:53 <Cale> Guest2542: From your implementations of applyN, my best guess at what you want is an infinite loop
07:41:00 <merijn> mauke[: Not without enabling a bunch of extra extensions, I can't
07:41:02 <mauke[> SrPx: you could parameterize defaultFoo, I guess
07:41:04 <SrPx> do you think it is better to have "foo" as an argument of defaultFoo, then? "defaultFoo a = Foo (Bar a) []". 
07:41:12 <Cale> Guest2542: Can you write this function in *any other programming language*?
07:41:14 <merijn> Oh, wait...
07:41:20 <Guest2542> curryN takes lots of arguments, and puts them in a list, as if interspersing them with (:)
07:41:38 <SrPx> te only problem is that it makes a little uglier initializing "foo" since every change is a lens except for that specific one
07:41:48 <mauke[> SrPx: yes, because in some sense it's a "required" argument whereas aList is "optional"
07:42:09 <SrPx> Uhmm fair enough
07:42:28 <Guest2542> curryN a =  (\b-> a:(curryN b) )
07:42:28 <merijn> So I added zip for HLists here https://gist.github.com/merijn/dc00bc7cebd6df012c5e
07:42:40 <Cale> @let curryN a =  (\b-> a:(curryN b) )
07:42:41 <lambdabot>  .L.hs:156:25:
07:42:41 <lambdabot>      Couldn't match expected type ‘[a]’ with actual type ‘a -> [a]’
07:42:41 <lambdabot>      Relevant bindings include
07:42:48 <merijn> But I can't figure out how to make the typechecker error out on "whoops" on line 45
07:43:28 <Cale> Guest2542: See, curryN b is the tail of a list there, so it ought to be a list, but curryN a is being defined as a lambda, which is not a list.
07:43:50 <Guest2542> curryN a b =   a:(curryN b) 
07:44:08 <Guest2542> ok its still a function not a list
07:44:12 <Guest2542> hmmmmmmmmmmmmmmmmm
07:44:25 <Guest2542> so what is the correct way to define curryN
07:44:32 <Guest2542> you understand what i want it to do?
07:44:41 <Cale> You're the one who is trying to explain to me which function you want
07:44:49 <Guest2542> like curry
07:44:53 <Guest2542> but on n
07:44:56 <ion> merijn: I wonder if Void ~ () would work?
07:45:01 <Guest2542> curry 1 2
07:45:06 <Cale> ?
07:45:07 <mauke[> Guest2542: there is no "correct way"; what you're asking doesn't make sense
07:45:07 <Guest2542> > curry 1 2
07:45:08 <lambdabot>      No instance for (Typeable b0)
07:45:09 <lambdabot>        arising from a use of ‘show_M267946217615037433528358’
07:45:09 <lambdabot>      In the expression:
07:45:20 <Guest2542> > uncurry 1 2
07:45:22 <lambdabot>      Could not deduce (Num (a0, b0)) arising from the literal ‘2’
07:45:22 <lambdabot>      from the context (Num c)
07:45:22 <lambdabot>        bound by the inferred type of it :: Num c => c at Top level
07:45:32 <Guest2542> oh ffs, sorry, it needs a function
07:45:34 <Guest2542> doh
07:45:44 <Guest2542> ok i see the problem, sorry again
07:45:47 <merijn> ion: That doesn't kindcheck, does it?
07:45:59 <merijn> ion: Zip has to return a type of kind [*]
07:47:06 <Guest2542> curryN::([a]->b) -> a -> a -> a-> ... -> a -> b
07:47:10 <Cale> Guest2542: There are lots of games you can play with type classes to define things which appear the same, but which are defined differently for different types.
07:47:36 <Cale> How many a's is that?
07:47:40 <Guest2542> n
07:47:45 <Cale> What's n?
07:48:01 <Guest2542> dosent matter, my function treats a list
07:48:05 <Cale> Am I allowed to pick n?
07:48:10 <Guest2542> you must
07:48:14 <Cale> hm?
07:48:22 <Cale> Okay, I pick n = 3
07:48:31 <Guest2542> so i can say curryN sum 1 2 3 4 5 
07:48:42 <Cale> No you can't.
07:48:45 <geekosaur> "1 2 3 4 5" is not a list
07:48:45 <Cale> I picked n = 3
07:48:47 <Guest2542> (curryN sum) 1 2 3 4 5 
07:48:52 <Guest2542> (curryN sum) 1 2 3 
07:48:58 <Guest2542> is also going to work
07:49:04 <Cale> So curryN :: ([a] -> b) -> a -> a -> a -> b, okay?
07:49:08 <Guest2542> no
07:49:13 <Guest2542> you are missing some dots
07:49:22 <Cale> dots are not valid Haskell syntax
07:49:26 <Lokathor> you can't ever do that in haskell. You can't have the "..." part in a haskell type signature
07:49:34 <merijn> This "conversation" has been going on for like 2 hours
07:49:39 <merijn> Can we decide to give up?
07:49:41 <Guest2542> so make it only just treat the head of the list and some as yet unsupplied arguments
07:49:49 <Cale> merijn: I still want to understand what it is that Guest2542 wants.
07:49:57 <merijn> Cale: What he wants isn't possible
07:50:04 <Guest2542> i want him to too, because im sure its gona be so cool
07:50:28 <Cale> Perhaps we should take this to another channel
07:50:33 <Cale> #haskell-overflow, say
07:50:34 <exio4> I will implement what Guest2542 wants and put in a library in the acme namespace, wish me luck! :p 
07:50:35 <Guest2542> its ok cale
07:50:39 <merijn> Cale: He wants "on" generalised to an unknown function type
07:50:44 <Guest2542> acme lol
07:50:55 <Guest2542> thanks, can we do this meijn?
07:50:56 <Cale> merijn: Yeah, that doesn't really make sense to me
07:50:58 <merijn> Cale: i.e. on that accepts both "a -> b", "a -> a -> b", "a -> a -> a -> b"
07:51:14 <Guest2542> yes
07:51:23 <Cale> Okay, so you can obviously do that by defining instances of a type class.
07:51:43 <merijn> Cale: Can you? how would you know you hit the base case?
07:51:44 <Guest2542> except i dont know what on is, but your general type thing is a good decription of what i wanted to do with the dots.
07:51:57 <mauke[> @src on
07:51:57 <lambdabot> (*) `on` f = \x y -> f x * f y
07:52:26 <merijn> ion: I think the only solution is to add a second type family that produces a constraint that requires the two lists be the same length
07:52:35 <Cale> merijn: Well, it'll probably require explicitly giving the type signature every dang time.
07:52:35 <lpaste> Lokathor pasted “Cale, pseudocode in another lang of what he seems to be after” at http://lpaste.net/132923
07:52:45 <Guest2542> on is specific to multiplication?
07:52:52 <geekosaur> no
07:53:06 <geekosaur> in a pattern (*) is just another name
07:53:25 <merijn> ion: Which is a bit unfortunate, because I hate silly duplication like that :\
07:53:55 <ion> merijn: ok
07:54:14 <Guest2542> on g f x y = g (f x) (f y)
07:54:39 <Cale> right
07:55:10 <merijn> ion: I actually asked to add an explicit "error" type before (for Constraint that time), but that got shot down as unnecessary, but I keep running into places where I want it (like here)
07:55:20 <Guest2542> onN g f xs = g (map f xs)
07:55:46 <Cale> @let onN g f xs = g (map f xs)
07:55:47 <lambdabot>  Defined.
07:55:50 <Cale> :t onN
07:55:51 <lambdabot> ([b] -> t) -> (a -> b) -> [a] -> t
07:56:00 <Cale> ^^ the first sensible program you've written all day
07:56:40 <ion> merijn: Perhaps you could ask for it again with those code examples.
07:57:48 <Guest2542> onN g f xs = g (unCurryN (map f)) a b c d ... n 
07:58:00 * hackagebot leveldb-haskell 0.6.3 - Haskell bindings to LevelDB  http://hackage.haskell.org/package/leveldb-haskell-0.6.3 (KimAltintop)
07:58:07 <Guest2542> maybe i mean curry sorry
07:58:12 <Guest2542> onN g f xs = g (curryN (map f)) a b c d ... n 
07:58:14 <Haskellfant> is there some combined filter & map for pipes? I want to got from Either a b to b by throwing away all lefts. ofc I could first filter and then use a fromRight, but that seems ugly
07:58:32 <Guest2542> its not ugly if it works and sleys the nay sayers
07:58:41 <merijn> Now with glorious show instance and the ability to zip: https://gist.github.com/merijn/dc00bc7cebd6df012c5e :D
07:58:58 <Guest2542> apply either curry itterate
07:59:38 <Cale> Haskellfant: You could use mapFoldable
08:00:19 <ion> merijn: Aren't Show instances supposed to put the parentheses around themselves, not their children? :-P
08:00:19 <Guest2542> cale, tell me you understand curryN?
08:00:41 <merijn> ion: I guess, I didn't know the "proper" showsPrec way to do it
08:01:10 <geekosaur> Guest2542, the question is not whether Cale understands it. the question is whether Haskell does
08:01:26 <geekosaur> Cale has been asking you the questions the typechecker will ask of you.
08:01:27 <Guest2542> im sure its possible
08:01:27 <Lokathor> Haskellfant, "rights"
08:01:32 <Haskellfant> Cale: ah not sure how I didn't see this, thanks
08:01:34 <Lokathor> :t Data.Either.rights
08:01:35 <lambdabot> [Either a b] -> [b]
08:01:47 <Guest2542> i understand his problems but not his solutions
08:01:56 <Guest2542> he complains of not knowing what i mean
08:02:09 <Cale> Prelude Data.Either Pipes.Prelude> :t mapFoldable (either (\x -> []) (\x -> [x]))
08:02:09 <Cale> mapFoldable (either (\x -> []) (\x -> [x]))
08:02:09 <Cale>   :: Monad m => Pipes.Core.Pipe (Either a b) b m r
08:02:18 <Guest2542> provoking me to think of the definition myself, while he is the expert and im growing exhausted
08:02:31 <geekosaur> you are still not understanding
08:02:39 <Cale> Guest2542: I really don't know precisely what you mean
08:02:44 <geekosaur> you apparently want magic. something should be doing the thinking for you.
08:02:58 <geekosaur> the typechecker will not do the thinking for you, you must do it
08:03:12 <geekosaur> Cale is essentially telling you what the typechecker requires
08:03:16 <Cale> Guest2542: There's some hazy notion that it has something to do with variadic functions, but the definitions are mostly unclear and your type signatures are unsyntactical.
08:03:17 <merijn> "rights = do { x <- await; case x of Left _ -> return (); Right val -> yield val; rights }"
08:03:26 <Guest2542> its a simple enough concept, you know curry works on tuples, now i want to make it work on lists, but i cant define a base case because i cant patern match non functions, so is fine we can patern match data types so why is it not possible, and incomprehensible!?
08:03:57 <Cale> Guest2542: I don't agree that it makes sense for curry to "work on lists"
08:03:59 <indiagreen> Guest2542: you've already been told that a) it's impossible to write as a simple function, the way you were trying to write it; b) it's possible to write with typeclasses – the same way printf is written – and it would *almost* work (it would fail if you apply it to an unknown number of arguments which are *themselves* functions)
08:04:01 <S11001001> Guest2542: You can't write variadic functions in haskell.  You can write one-argument functions in haskell.  That's it.
08:04:25 <indiagreen> Guest2542: do you want further elaboration on the point a), b), or both?
08:04:27 <Guest2542> i want cale to do the thinking for me geekosaur thats why we are human with awesome brain not dumb compiler
08:04:43 <Cale> Guest2542: curry and uncurry exhibit a natural isomorphism between the types ((a, b) -> c) and (a -> b -> c) for any choice of types a, b, and c
08:04:53 <geekosaur> it doesn;'t matter how much thinking Cale does for you if the typechecker doesn't accept the result
08:05:12 <Cale> What does it mean to just "replace" the pair with a list?
08:05:12 <geekosaur> also, "do my homework for me" never gopesd over well (regardless of whether this is actually homework or not)
08:05:15 <Cale> That doesn't make sense!
08:05:21 <Guest2542> thanks indiagreen
08:05:37 <Guest2542> b)
08:05:40 <ion> merijn: Something like showsPrec n (Cons x xs) = showParen (n > 10) $ showString "Cons " . showsPrec 11 x . showChar ' ' . showsPrec 11 xs
08:06:09 <indiagreen> Guest2542: are you sure that you understand why a) doesn't work? if you don't, you're probably not ready for b), because it's certainly not easier than a)
08:06:29 <Cale> Which type of functions is isomorphic to the type of functions out of a list type?
08:06:32 <Guest2542>  <Cale> Guest2542: curryN and uncurryN exhibit a natural isomorphism between the types ([a] -> b) and (a -> a -> ... -> a -> b) for any choice of types a, and b
08:06:40 <Cale> FALSE
08:06:47 <Guest2542> not natural?
08:07:01 <Cale> Those types are not isomorphic for any number of occurrences of a in the second type.
08:07:02 <Guest2542> but you Do know what i mean
08:07:17 <Cale> No matter which number you choose.
08:07:23 <Guest2542> if my function works on lists, it can take any number of argumnets
08:07:37 <Cale> No, it just takes one argument which happens to be a list
08:07:49 <merijn> I would once again like to raise the motion to move this discussion anywhere but #haskell
08:07:59 <Guest2542> the internals of which handle the variable possible number of members of the list
08:08:17 <Guest2542> i am being forbiden from transfering this to many nested arguments
08:08:30 <indiagreen> Guest2542: “a -> a -> ... -> a -> b” is not a type. It's a *collection* of types, including “a -> b”, “a -> a -> b”, etc. So, they're not isomorphic because the 1st thing is a type and the 2nd isn't
08:09:01 <Guest2542> im getting helped here man, just leave it for a while, ill go and cry soon if this dosent get solved
08:09:05 <Cale> MOREOVER, even if you were to define a type something like:  data SomeNumberOfArgs a b = Zero b | Succ (a -> SomeNumberOfArgs a b)
08:09:27 <Cale> then even then, the types [a] -> r and SomeNumberOfArgs a r are not isomorphic
08:10:46 <Cale> So I *really* don't know what you mean
08:11:10 <Guest2542> but i can apply any number of arguments to a function, it handles this by treating the first argument and the function together as one function and iterativly applying this opperation. this is sop alike to the use of cons in a recursive function definition, i would like a pattern matchable opperation that will allow me to determine a base case and stop expecting further arguments. 
08:11:31 <Lokathor> Guest2542, you do know that the reason there's so many arrows in a haskell function's type signature is that all haskell functions are actually 1 to 1, right?
08:11:33 <Cale> I don't understand what operation or base case could possibly apply here
08:11:41 <Cale> Lokathor: This is not true
08:11:51 <frerich> I hope I don't distract this discussion even further, but my understanding is that Guest2542 wants a Haskell version (if any) of the JavaScript function 'applyN' visible at https://jsfiddle.net/09f5y09h/ -- I hope I'm not pointing out the obvious.
08:11:52 <Cale> At least, not with the technical definition of 1-to-1
08:11:55 <Guest2542> yeh the 1-1 thing was covered, its cool
08:12:27 <Guest2542> frerich, it is obvious isnt it?
08:12:41 <Lokathor> right, sorry
08:13:09 <quchen> I guess variadic functions correspond to existential lists in Haskell, which isn't something very pretty for everyday use.
08:13:12 <Lokathor> there's no good term for "takes 1 arg and produces one value but there might be overlaps on either side"
08:13:17 <frerich> Guest2542: It's not quite obvious to me at least when wearing the Haskell hat, a language where something like 'iterate over all arguments at runtime' doesn't make any sense.
08:13:18 <Cale> I don't really understand Javascript well enough to understand what that function is doing, but it appears to have something to do with building an array, and using some low-level function application operation which applies a function to an array
08:13:21 <Lokathor> damn math!
08:13:23 <Cale> Haskell functions don't take arrays
08:13:34 <Cale> They only take one argument at a time
08:13:53 <indiagreen> frerich: it's actually pretty sad that Guest2542 is being trolled like this despite having explained what ne wants pretty clearly a number of times (admittedly ne doesn't know *well* what ne wants, but the right question is half the answer)
08:14:05 <frerich> Guest2542: Functions in Haskell are so fundamentally different from functions like in e.g. JavaScript that the idea of 'applying something to all arguments' makes very little sense.
08:14:34 <athan> Cale: Says you!
08:14:39 <Cale> Guest2542: If you want a function to take an array as an argument, then its type should express the fact that it takes an array as an argument
08:14:41 <athan> @hackage poly-arity
08:14:42 <lambdabot> http://hackage.haskell.org/package/poly-arity
08:15:15 <bitemyapp> usually people want polyarity because they don't know how to lift what they're doing out into a fold.
08:15:16 <Cale> athan: None of that really changes anything fundamentally
08:15:22 <athan> frerich: (this was a joke don't take me seriously :P)
08:15:32 <Guest2542> i do not wish to take an array as an argument, i wish to apply a function that works on an array to any number of argumnets. really i just want to map over arguments
08:15:51 <Cale> Guest2542: Unless that number is 1, you're going to be sad
08:15:53 <geekosaur> and you are not understanding why that does not work
08:16:02 <Guest2542> i think it should work
08:16:08 <geekosaur> what you think does not matter
08:16:08 <maerwald> then implement it :P
08:16:13 <athan> bitemyapp: Or they want to keep the folded componenets implicit in the types :x
08:16:33 <Cale> Guest2542: Yeah, at this point I think you really have to demonstrate what you mean with real code.
08:16:35 <Guest2542> i thought my approch was great, but i couldnt figure out about the base case
08:16:43 <geekosaur> this should have told you something
08:17:17 <Guest2542> applyN f g a = applyN f (g (f a))
08:17:20 <Cale> Guest2542: The Javascript code which frerich posted has no sensible analogue in Haskell because it made use of a primitive Javascript apply which uses the fact that all Javascript functions are really consuming arrays.
08:17:26 <maerwald> I really think there is not much more to say to this question
08:17:31 <Guest2542> there is one base case missing and thats all
08:17:35 <bitemyapp> athan: yeah, more or less.
08:17:45 <athan> Guest2542: No, the other way!
08:17:52 <Cale> Guest2542: This property is not true in Haskell, and so nothing truly analogous could exist.
08:18:04 <athan> apply2 f g a = ((apply2 f) g) a
08:18:04 <quchen> Guest2542: Your question of how to write "curryN" is a valid one, but this is something a strong type system makes very difficult. We can't prove to you that this functionality is not needed when using Haskell, so there is little desire to implement such a thing. What you *can* do in Haskell is taking a list as argument, i.e. a number of homogeneous values, or in the extended case, a list of existentials (in essence types that sha
08:18:04 <quchen> re a common property). I have never *needed* the latter though.
08:18:16 <athan> oh wait
08:18:17 <athan> my bad
08:18:26 <Cale> quchen: Is it really valid?
08:18:33 <Cale> I don't think it is even valid.
08:18:40 <zipper> jle`: Hey, you around?
08:18:46 <quchen> Cale: Sure, applyN is a very helpful function in many languages.
08:19:08 <athan> Something like a recursive curry?
08:19:09 <Cale> In particular, there is no type X for which there is an isomorphism between [a] -> r and a -> X
08:19:10 <quchen> I've used it to great extent in Mathematica, for example.
08:19:13 <athan> (over lists)
08:19:21 <Guest2542> omg are you serious, curryN would be the strongest higher order function i can think of
08:19:41 <Cale> So I don't understand what he could possibly mean by curryN
08:19:49 <athan> er actually derp
08:19:57 <athan> n-tuples not lists ><
08:19:58 <S11001001> Guest2542: if javascript application worked like haskell application, it would not be possible to write in javascript either.
08:20:09 <athan> where HList is just in-between
08:20:10 <quchen> Cale: curryN f [a,b,c] = f a b c  -- etc for different list lengths
08:20:43 <Cale> Plainly that doesn't typecheck, and I don't understand what type it could possibly have.
08:20:51 <S11001001> Guest2542: here is your equivalent challenge, in Javascript, which illustrates what you're trying to do in haskell.
08:20:56 <athan> quchen: This expects the list to be heterogeneous, or `f` to be homogeneous :s
08:20:56 <Cale> Or even how it could be implemented in a finite manner.
08:20:57 <maerwald> Cale: the point is that such a thing IS useful
08:20:58 <mauke[> that looks like uncurryN
08:21:15 <Guest2542> so because you think a function takes one argument you cant see what i mean when i say it puts ALL of the argumnets into a list like curry. but because we can treat the head of the function application nesting, in the same was as we define our function on lists using recursion on the tail, there seems an easy analogy
08:21:16 <Cale> maerwald: is it?
08:21:19 <quchen> athan, Cale: Sure, you're coming from the strong typing end. But that's a pretty narrow perspective.
08:21:23 <maerwald> Cale: yes
08:21:34 <mauke[> Guest2542: "seems" being the keyword
08:21:39 <athan> quchen: For me, it's a matter of equating two things
08:21:39 <Cale> quchen: How do we do it in an untyped setting?
08:21:41 <Guest2542> i said nothing about java
08:21:51 <athan> it's much easier to have a function that results in _one_ type
08:22:03 <mauke[> Guest2542: no one said anything about java
08:22:08 <athan> while `applyN` or `curryN` would _need_ some kind of heterogeneous result
08:22:09 <Cale> quchen: Could you write it in the untyped lambda calculus with lists Church encoded?
08:22:16 <quchen> I don't know.
08:22:18 <athan> some result that's depenent on the input type
08:22:24 <athan> quchen: I bet you could do it with dependent types
08:22:29 <frerich> Guest2542: For what it's worth, the same kind of curryN (or applyN) function is difficult (if not impossible) to define in e.g. C++. I think it's impossible for any language which strictly separates types and values, to a degree that no or very little type information is available at runtime.
08:22:32 <Cale> Like, everyone's pointing at this vague thing
08:22:35 <athan> (i did it in poly-arity_
08:22:36 <athan> )*
08:22:41 <S11001001> Guest2542: actually, you don't need this.  curryN doesn't work on variadic functions, in Javascript.
08:22:42 <quchen> I can write it in other languages. That makes it a valid question about this language.
08:22:50 <exio4> athan: merijn's code uses HLists for the parameters
08:22:52 <athan> Cale: Structure is for the weak! :)
08:23:02 <athan> exio4: Oh woop I didn't see
08:23:04 <quchen> I can also come here and ask how to mutate an Int variable. The answer is also "you can't", but that doesn't make it a non-meaningful question.
08:23:05 <Cale> and well, okay, properties like curryN f [a,b,c] = f a b c  are better than what Guest2542 has specified so far
08:23:12 <athan> exio4: That's what I did, too
08:23:20 <Cale> At least that's an equation we can hang on to
08:23:31 <athan> (except HList is <= base 4.6 so I made my own)
08:23:40 <indiagreen> quchen++
08:24:00 <Cale> But I'm not sure it actually makes sense in any language where functions aren't secretly taking finite lists as arguments
08:24:25 <quchen> Cale: Another example of a function that sometimes sounds useful is "chainAll", a la "chainAll [f,g,h] = f . g . h", where h :: a -> b, g :: b -> c, f :: c -> d.
08:24:27 <nuttycom> Being able to abstract over arity is the main reason that I'm interested in Idris. 
08:24:30 <exio4> Cale: was just thinking about that, lists can be infinite
08:24:31 <athan> Cale: _heterogeneous_ finite lists
08:24:40 <Guest2542> cainall looks good
08:24:48 <Guest2542> chainAll*
08:24:48 <Cale> athan: sure
08:24:49 <athan> it works in javascript because there's no demand for finite uniformity, in the type itself
08:25:19 <Lokathor> chainAll looks like it could never typecheck in haskell :P
08:25:30 <S11001001> Guest2542: that is to say, can you write a function in javascript, f, such that f(g)(a)(b) = g(a, b), f(g)(a)(b)(c) = g(a, b, c), and so on, for all functions g, and arguments a, b, and c?
08:25:33 <Cale> It can typecheck if you don't try to put the functions in a list
08:25:40 <Lokathor> well yes
08:25:58 <Lokathor> you could do it with tuples, but then it wouldn't be varidic
08:26:00 <quchen> Mathematica: #1[#2]& @@ {f, x} = f[x]. Uncurry, basically, except that all tuples are implemented as lists (which need not be homogeneous).
08:26:00 <athan> nuttycom: Wait, they give arity abstractions!? :o
08:26:19 <Guest2542> dont talk to me about java sorry my brain will melt
08:26:55 <Cale> quchen: Right but all functions are more or less defined to operate on lists in Mathematica, so it's not surprising there.
08:27:05 <nuttycom> athan: given that you can use lists in type-level programming, sure. For example, the typesafe printf examples abstract over arity quite nicely: https://www.youtube.com/watch?v=fVBck2Zngjo
08:27:21 <Cale> Well, sort of
08:27:28 <Cale> Mathematica's evaluation model is weird
08:27:32 <quchen> Cale: I'd say they're defined on badly specified arrays of certain shapes.
08:27:42 <athan> nuttycom: Ah! Yes, pi types are awesome :)
08:27:47 <Cale> right, that's a better way to put it, haha
08:27:48 <lpaste> chpatrick pasted “Baked-in Storable vectors Mark II” at http://lpaste.net/132924
08:28:05 <quchen> Mathematica is the most dynamic language I know, but that's also why I'd stay the hell away from using it as a programming language (as opposed to a CAS or for data analysis).
08:28:29 <quchen> Still, coming from Mathematica, I wondered about "how to write applyN in Haskell" too in the beginning.
08:28:44 <Guest2542> just talk about haskell!!
08:28:57 <S11001001> Guest2542: This is Javascript I'm talking about.  Many people are talking about that there is no way to type curryN, as a reason it can't be done in Haskell. I submit that you can't do it in Javascript, or Python, or whatever, either.  And, ironically, it is these languages' support for variadic functions that makes it impossible to write.
08:29:08 <athan> but I don't think there's a λ term you can lift into a Π
08:29:16 <Guest2542> im not convinced it cannot be done in haskell
08:29:18 <athan> (giving you poly arity inspection)
08:29:19 <frerich> quchen: In a similiar vein, I did (do?) consider it a sign of a weakness in the language that there is 'zipWith7' but no 'zipWithN'.
08:29:19 <Cale> @let data Thrist f a b where { Nil :: Thrist f a a; Cons :: f a b -> Thrist f b c -> Thrist f a c }
08:29:21 <lambdabot>  Defined.
08:29:29 <athan> nuttycom: ^
08:29:30 <Guest2542> the only comeling argument against it is that cale dosent know what type it is
08:29:36 <frerich> quchen: I understand why that is, it's just that I'm not terribly happy about it :-)
08:29:37 <Guest2542> compelling*
08:29:44 <quchen> frerich: zipN is transpose, map f . transpose is zipWithN :-þ
08:29:45 <mauke[> Guest2542: why do you keep bringing up java?
08:29:51 <geekosaur> once again: Cale is telling you what the typechecker says
08:29:58 <geekosaur> not what Cale thinks
08:30:14 <Cale> I think I'm expressing what I think
08:30:20 <Cale> Not just what the type checker things
08:30:22 <Cale> ks*
08:30:30 * frerich thinks this is getting deep now and fetches some red wine
08:30:44 <Guest2542> omg stop trolling me u guyz
08:30:57 <Cale> @let composeThrist :: Thrist (->) a b -> (a -> b); composeThrist Nil = id; composeThrist (Cons f xs) = composeThrist xs . f in composeThrist
08:30:57 <lambdabot>  Parse failed: Parse error: in
08:31:00 <frerich> Guest2542: Sorry, didn't mean to.
08:31:05 <Cale> @let composeThrist :: Thrist (->) a b -> (a -> b); composeThrist Nil = id; composeThrist (Cons f xs) = composeThrist xs . f
08:31:07 <lambdabot>  Defined.
08:31:14 <Guest2542> no it was mauke that time
08:31:27 <mauke[> Guest2542: I'm not trolling you. why are you talking about java?
08:31:30 <mauke[> when no one else is
08:31:31 <Cale> :t composeThrist (Cons length (Cons (+1) (Cons (*2) Nil)))
08:31:32 <lambdabot> Foldable t => t a -> Int
08:31:41 <Guest2542> im not talking about java im telling ppl not to!! ffs
08:31:50 <mauke[> Guest2542: yes, but no one is talking about java
08:31:52 <mauke[> (except you)
08:31:55 <Guest2542> im not!
08:31:58 <quchen> Stop it.
08:32:05 <quchen> Both, now, regardless of who started it, please.
08:32:12 <Cale> @undefine -- actually I hate that definition, let's flip it
08:32:12 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
08:32:18 <Cale> @undefine
08:32:18 <lambdabot> Undefined.
08:32:28 <mauke[> quchen: what is "it"?
08:32:39 <quchen> ಠ_ಠ 
08:32:45 <Cale> @let data Thrist f a b where { Nil :: Thrist f a a; Cons :: f b c -> Thrist f a b -> Thrist f a c }
08:32:46 <lambdabot>  Defined.
08:32:57 <Cale> @let composeThrist :: Thrist (->) a b -> (a -> b); composeThrist Nil = id; composeThrist (Cons f xs) = f . composeThrist xs
08:32:58 <lambdabot>  Defined.
08:33:02 <Cale> So much nicer
08:33:19 <Cale> Guest2542: Perhaps this will cheer you up?
08:34:58 <monochrom> I am a supporter of "explain to me like I don't know what you mean". it can be done, but most people are too proud to do it.
08:35:06 <Cale> > composeThrist (Cons (map head) (Cons group (Cons sort Nil))) "mississippi"
08:35:08 <lambdabot>  "imps"
08:35:28 <Guest2542> ...
08:35:31 <Guest2542> what is this?
08:35:58 <Cale> Guest2542: A way of representing lists of functions of composable types, and a function which will actually go about composing them together.
08:36:16 <quchen> monochrom: That won't work when all you have is a gut feeling of what you want. Some questions require a certain degree of empathy to answer well. Repeatedly asking for a formal specification, as seems to be have done here, is rarely helpful.
08:36:22 <Guest2542> but i can do that with foldLM_?
08:36:32 <Guest2542> foldlM_*
08:36:33 <Cale> huh?
08:36:35 <Cale> No
08:36:39 <Guest2542> like mapM_
08:36:55 <Cale> Why monadic?
08:36:57 <Guest2542> or foldl (.)
08:37:04 <Cale> :t foldr (.) id
08:37:05 <lambdabot> Foldable t => t (b -> b) -> b -> b
08:37:16 <Cale> Here the functions all must have the same type
08:37:19 <monochrom> quchen, when I don't know what you mean, you still do not have to give me a complete formal specification. you can start by giving me concrete examples aka test cases.
08:37:45 <quchen> monochrom: Would saying "like you can do in Javascript" do?
08:37:56 <quchen> (I don't know Javascript, but apparently that was the comparison.)
08:38:03 <mauke[> it wasn't
08:38:11 <Guest2542> guys
08:38:16 <monochrom> that depends on many factors
08:38:40 <Cale> A value of type Thrist (->) a b is a list of functions, the first of whose codomain is b, and the last of whose domain is a, and where the domain of each is the codomain of the next, so that you can compose them together. They may all have different types
08:39:12 <Guest2542> so maybe the problem with my earlyer aproach was the infinite type of having a result that could wait for another argument to be aplied. 
08:39:28 <monochrom> i.e., under some circumstances, that is enough. under some other, that is weaselling
08:40:03 <Guest2542> ah, becuase foldl works on a list
08:40:11 <Guest2542> same type
08:40:27 <Guest2542> yeh so you have another data structure like a liked list of variable types
08:40:30 <Guest2542> fine
08:40:38 <Guest2542> this is related?
08:40:45 <Cale> Well someone mentioned this function
08:40:58 <Guest2542> its a good function
08:40:58 <Cale> It was quchen
08:41:02 <Cale> He called it chainAll
08:41:09 <Guest2542> aha
08:41:12 <Guest2542> yes
08:41:17 <Cale> So I implemented chainAll, but not for lists exactly.
08:41:36 <Cale> For a type which was actually capable of recording functions of different types that could still be composed.
08:41:42 <Guest2542> still isnt getting over my problems with function composition not transfering to lists
08:42:11 <Cale> I still don't really understand how the *real* solution to your problem is not simply foldr
08:42:23 <Guest2542> its map really
08:42:29 <Cale> > foldr (+) 0 [1,2,3,4,5]
08:42:30 <lambdabot>  15
08:42:33 <Guest2542> but over nested arguments, not lists
08:42:38 <Cale> Look, I can add a bunch of numbers
08:42:42 <Cale> Why is this not good enough?
08:42:49 <Guest2542> so we want to convert between lists and nested arguments
08:42:59 <Cale> That, again, does not make sense for Haskell
08:43:03 <Guest2542> sumCurry 1 2 3 4 5 6 7 
08:43:29 <Cale> It only makes sense in which your primitive notion of function application involves a heterogeneous finite list of arguments
08:43:36 <Cale> in languages which*
08:43:43 <mauke[> repeating your assertions does not help with anything
08:43:56 <chpatrick> you can make that work though technically
08:44:11 <Guest2542> can you!?
08:44:26 <chpatrick> https://gist.github.com/chpatrick/e9cf011ca1a5e5976d05
08:44:30 <chpatrick> I don't think it's really nice though
08:44:37 <Cale> chpatrick: You can do a thing with type classes which will make that expression compile and compute the sum, provided that you specify a concrete type of result.
08:44:38 <Guest2542> i guess the only way cale will be convinced is with a counterexample, but i find it hard to make one for him
08:44:48 <Guest2542> i guess its more like unFoldr
08:45:40 <mauke[> ok, this puzzles me. why are you concentrating on convincing Cale?
08:46:31 <Guest2542> because he has probosed it to be imposible only because the naieve implementation creates infinite type
08:46:48 <Cale> what?
08:46:50 <Guest2542> if it is the case that no implementation could, then i will desist, but im not convinced
08:47:31 <mauke[> ok, assume you've managed to convinced Cale. what then?
08:48:24 <Guest2542> applyN f g a = (b-> applyN f (g (f a) b)
08:48:39 <Guest2542> then he realises how to implement it and tells me
08:48:43 <Cale> Guest2542: There are things you can do with type classes to simulate variadic functions of various sorts. The reason I'm not convinced that what you're trying to do makes any sense at all is that all your descriptions of what you want to do don't make sense to me. Some other people's descriptions of what they think you're trying to do kind of make some amount of sense (but largely decribe things which are not really ap
08:48:43 <Cale> propriate to do in Haskell)
08:48:44 <mauke[> hahahaha
08:49:17 <mauke[> Guest2542: this does not seem to be a constructive approach to me :-)
08:49:33 <Guest2542> yes im getting my lfe destroyed, thanks internet
08:49:38 <Guest2542> life*
08:50:29 <Guest2542> @let applyN f g a = b-> applyN f (g (f a)) b
08:50:29 <lambdabot>  Parse failed: Parse error: ->
08:50:36 <Guest2542> @let applyN f g a = \b -> applyN f (g (f a)) b
08:50:37 <lambdabot>  .L.hs:147:23:
08:50:37 <lambdabot>      Occurs check: cannot construct the infinite type: t ~ t3 -> t
08:50:37 <lambdabot>      Relevant bindings include
08:50:48 <Guest2542> outch my infinite type hurts
08:50:48 <Cale> Guest2542: anyway, good luck
08:51:45 <Guest2542> i thought maybe if i took the time to describe what i wanted to the guy who said it didnt make sense what i want, that all the stars would align and haskell would become clear, and instead he has just trolled me 
08:52:07 <Cale> Guest2542: The correct thing to do if you want a function in Haskell which takes an arbitrary number of arguments is to have that function instead take a list.
08:52:18 <Guest2542> wow
08:52:49 <Guest2542> and if i have a function defined on tuples i can use curry and uncurry to do the conversion...
08:52:55 <Cale> There are other approaches, but they are both complicated and dumb.
08:53:00 <lalalala> somebody here that can help me on a project in private ?
08:53:27 <barrucadu> lalalala: You'll probably get more rapid responses if you just ask your questions here
08:53:40 <Cale> Guest2542: Defined on pairs specifically, yes.
08:53:45 <Guest2542> why just because the list is not with the same number of elements each time, because my type signature must have set number of arguments, but then i cant even pattern match on this set number of argumnets apparently
08:54:59 <lalalala> barrucadu probably it's not certain
08:55:08 <Guest2542> your certain curryN is ill posed?
08:55:24 <geekosaur> that would be correct. because it's not a value "number of arguments", it is a type, and you can't pattern match to discriminate types, only constructors within a type
08:55:30 <Cale> There are stupid games you can play with type classes to "pattern match on the number of arguments" sort of, but they are flaky and will result in programs where you have to give explicit type annotations to way more things than you probably think you ought to.
08:55:47 <Guest2542> i cant wrap the type in a paterna matchable data structure?
08:55:50 <geekosaur> typeclasses provide a limited and rather sketchy way around that, but you can get yourself into much deeper trouble trying to abuse them that way
08:56:07 <lalalala> "somebody here that can help me on a project in private ?"
08:56:27 <Guest2542> i dont care if it "is a bit messy" there is a serious conceptual hole in a language i base my life on. jesus
08:56:56 <hodapp> Cale: that's what happened to me when I tried to make my super-nice variadic function to let me do "foo arg1 arg2 arg3..." instead of "foo2 arg1 arg2" inside some wonky monad.
08:56:56 <Cale> lalalala: That's suspiciously vague?
08:56:58 <ion> Guest2542: Why not just use lists?
08:57:12 <hodapp> Cale: 'foo' always required that I cast it, which ended up being uglier than simply counting my arguments.
08:57:13 <Cale> ^^ what ion said
08:57:38 <lalalala> Cale: suspiciously why ? irc it's safe, i'm just talking
08:57:45 <Guest2542> so apparently what im trying to do is like the heroin of haskell and no1 is going to help me down that slippery path, even thought you have the power yourself. im not naieve, i just want to know what the compiler cant tell me, can i get round this infinite type error?
08:58:03 * hackagebot monomorphic 0.0.3.3 - Library to convert polymorphic datatypes to/from its monomorphic represetation  http://hackage.haskell.org/package/monomorphic-0.0.3.3 (HiromiIshii)
08:58:06 <Cale> lalalala: heh, I'm somewhat joking, but it is probably too vague to interest anyone?
08:58:19 <hodapp> oh, yes, I had to basically do ((foo arg1 arg2 ...) :: FooMonad bar ())
08:58:21 <Cale> lalalala: Why don't you talk some about your project and what you need help with?
08:59:03 <lalalala> Cale: yeah a bit, but i prefere a negative answer as "I'm not an expertise in that area" that don't get an answer at all
08:59:08 <Saizan> Guest2542: learn about GADTs
08:59:13 <Guest2542> ion: because the functions i am translating are defined on many arguments instead of lists or tuples of arguments 
08:59:59 <Cale> lalalala: So long as it's a Haskell project, it's bound to be more relevant to the channel discussion than beating this evidently dead horse that we've been beating for a while here now :)
09:00:05 <monochrom> lalalala: I am not an expert in the area of pm.
09:00:11 <Guest2542> suppose some idiot went to the effort of defining some really useful function on lists, but manually unrolled the lists, i just want to translate it back to sanity
09:01:02 <nshepperd> Guest2542: foo' [a,b,c,d] = foo a b c d
09:01:24 <saulzar_> There's been an awful lot of patience for beating dead horses tonight..
09:01:35 <nshepperd> don't bother with polyvariadic functions, they exist but they do not compose well
09:02:05 <Guest2542> im so happy that when someone takes their entire day to succincly describe a problem whoes answer was uncear supposedly because the discription was inadiquate, that this is beating a dead horse. im so happy that instead of helping someone do something that may be possible, people simply discourage it because its difficult.
09:02:49 <mauke[> it's not difficult to do, it's just difficult to actually use the result
09:03:01 <mauke[> talking about classes to emulate variadic functions
09:03:11 <mauke[> hence pointless
09:03:12 <magneticDuck> Guest2542: I also am happy, but it's because I'm going down a water slide
09:03:15 <magneticDuck> wheeeeee
09:03:38 <Guest2542> no there is nothing pesimistic about it at all, its liberating and empowering, educational and informative. telling anyone its not worth doing is simply exhasperating
09:04:22 <Guest2542> if its not difficult to do why is everyone failing to implement it?
09:04:25 <brbblnch> Hi
09:04:26 <Saizan> Guest2542: see stuff like http://hackage.haskell.org/package/base-4.7.0.1/docs/Text-Printf.html
09:04:36 <Saizan> Guest2542: and https://gist.github.com/Saizan/444714
09:04:39 <Guest2542> and insisting instaead upon blaming me for something.
09:04:48 <mauke[> Guest2542: did you miss all the example links?
09:05:06 <Cale> Guest2542: I don't mean to be rude, but I've been trying to alternately explain to you why the things that I think you might be asking for don't really make sense, and trying to figure out what the heck you're talking about in the first place, given all these nonterminating programs and not-really-syntactically-correct type signatures
09:05:37 <Cale> Guest2542: and it's gotten to the point where I think you need to just try some more for yourself to understand the things I've said?
09:05:53 <magneticDuck> Guest2542: in light of trying to do something in haskell, "the better is the enemy of the good"
09:05:54 <Guest2542> Saizan: did you do it finally!? that looks really hopeful
09:06:08 <brbblnch> Is there a version of the Curry-Howard correspondence to, for instance, untyped lambda calculus, or other Turing-complete "systems" ?
09:06:14 <magneticDuck> and by "better" I mean "more needlessly complicated"
09:06:29 <Saizan> Guest2542: i just linked code that was already around, like other have done before as far as i can see in the log
09:06:34 <Guest2542> i understand what you hae said
09:06:36 <Guest2542> have
09:06:56 <Guest2542> but im not finding it so funny that you make me repeat myself. 
09:07:22 <Guest2542> it really cant be so hard to understand...
09:07:27 <magneticDuck> here on #haskell you get advice whether you want it or not I guess ^^
09:07:32 <dfeuer> guest2542, know ye that if thou art testing the patience of Cale, then thou must surely test the patience of any other.
09:07:39 <magneticDuck> yeah the type of thing you're talking about has puzzled me in the past
09:07:53 <magneticDuck> but after thinking about it a bit I realised I could be doing more truely productive things with my time
09:07:58 <hodapp> I'm not sure of the extent of 'making you repeat yourself'. This is an IRC channel, not a static collection of people who are all present and attentive at the same time. People come and go.
09:08:02 <monochrom> I don't always make the value judgment "should you do it?"
09:08:27 <monochrom> but I always make the value judgment "should I spend time explaining this? I'm not being paid afterall."
09:08:38 <Guest2542> i know in one aspect it is ill posed, i cant figure out the type, but thats what im on here to clear up, i cant use a language with a conceptual hole like that in it. and its my first language and iv written in it every day for 10 years. i want to know how to curry  a list 
09:08:38 <monochrom> I choose what questions I want to reply.
09:08:52 <Saizan> Guest2542: btw, googling "polyvariadic function haskell" gives you a lot of results
09:09:30 <ReinH> Guest2542: have you read https://wiki.haskell.org/Polyvariadic_functions ?
09:09:36 <magneticDuck> Guest2542: the best single example of the thing you want is the "printf" function
09:09:39 <magneticDuck> just look at the source
09:09:43 <Guest2542> google cant write my program for me
09:09:48 <Guest2542> yes i saw the examples
09:10:00 <dfeuer> When one considers writing a polyvariadic function in Haskell, one should always reconsider.
09:10:07 <dfeuer> The same goes for using one.
09:10:11 <chpatrick> guest2542: maybe you should write it then
09:10:12 <Cale> Guest2542: One more point: I don't believe that there exists any type constructor T such that T a b can take the place of all the occurrences of (a -> ... -> a -> b) in your types and have things be analogous in any way to curry/uncurry in terms of an isomorphism between ([a] -> r) and T a r
09:10:19 <Guest2542> when discouraging enthusiastic people one should always reconsider
09:10:40 <magneticDuck> Guest2542: enthusiam /= direction
09:10:52 <magneticDuck> it's great you want to learn stuff
09:10:53 <Cale> Well, that's not right, obviously [a] -> r itself works for T a r
09:10:58 <hodapp> Guest2542: Something tells me that when the question has been repeated this many times, the decision has not only been considered but reconsidered a dozen times now.
09:11:01 <ReinH> Guest2542: if you saw examples of variadic functions in Haskell then what is the specific problem you are having?
09:11:02 <mauke[> Guest2542: what do you mean, enthusiastic? you said your goal was to get Cale to write your code for you
09:11:03 <Guest2542> if you are wise enough to make these assertions, it would be helpful to comunicate that understanding and not just discourage the persuite of understanding
09:11:16 <dfeuer> Things like printf are more about showing off than actually programming effectively.
09:11:22 <Guest2542> my direction is to understand function composition sufficintly to implement curryN
09:11:31 <mauke[> see? there you go again
09:11:51 <mauke[> no desire to understand, just "I want to have this thing somehow"
09:12:01 <Guest2542> yes Cale: that is the problem, the infinite type
09:12:04 <Cale> Guest2542: I don't want to discourage your pursuit of understanding, however, I don't think I can really help you any further until you've thought more about what it is that you really want, and how to express that.
09:12:04 <chpatrick> Cale: what about HList ts -> b like in https://gist.github.com/chpatrick/e9cf011ca1a5e5976d05
09:12:04 <mauke[> if someone else writes it for you, all the better
09:12:27 <dfeuer> HList is probably the way to go, yes.
09:12:27 <monochrom> ok, I think I now have just cause to say the following about help vampires and what's worse, curiosity vampires.
09:12:38 <ReinH> Guest2542: That's like saying your goal is to understand swimming sufficiently to be able to build a house. You can't write a variadic function with composition alone.
09:12:45 <dfeuer> HList is at least *manageable*, crazy as it is.
09:13:00 <chpatrick> this isn't even oleg's hlist :)
09:13:11 <dfeuer> There's a different one?
09:13:13 <chpatrick> just basic GADT het list
09:13:16 <monochrom> you have heard of help vampires. they seek irc help so much so that it exhausts the people who help. but curiosity vampires are worse.
09:13:16 <Guest2542> i know exactly what i want and have expressed it suffiencly 
09:13:22 <magneticDuck> Guest2542: I'll make an allegory: A guy wants to get a way to protect his eyes from the sun, so he goes to the store and asks for a hat. He tells the salesperson he wants a hat that doesn't cover his head. The salesperson says maybe he should try out the sunglasses. The guy gets pissed that the salesperson can't just give him a hat.
09:13:31 <magneticDuck> this is.. similar to what's happening
09:13:33 <dfeuer> chpatrick, isn't that all Oleg's is?
09:13:44 <ReinH> Guest2542: ok, exactly what do you want?
09:13:45 <Cale> chpatrick: I'm not really sure how that corresponds in any way to anything that Guest2542 said.
09:13:49 <chpatrick> I though it had a ton of other machinery
09:14:06 <chpatrick> Cale: I was referring to this: "One more point: I don't believe that there exists any type constructor T such that T a b can take the place of all the occurrences of (a -> ... -> a -> b) in your types and have things be analogous in any way to curry/uncurry in terms of an isomorphism between ([a] -> r) and T a r"
09:14:10 <magneticDuck> ReinH: he wants a way of currning a list
09:14:16 <magneticDuck> currying*
09:14:39 <mauke[> currying functions? old hat. now we're currying lists!
09:14:42 <ReinH> Well, that's impossible.
09:14:44 <chpatrick> Cale: ah disregard that :)
09:14:49 <Cale> chpatrick: Your HList thing is for functions of a bunch of different types of arguments, with an explicit encoding of how many there are
09:14:53 <ReinH> We don't even need to talk about variadic functions
09:14:56 <ReinH> lists can be infinite
09:14:57 <monochrom> curiosity vampires seek irc help on their curiosity so much so that it exhausts the people who help. they are worse than help vampires because they think they have the moral high ground "I am just curious, I am enthusiastic, curious minds want to be taught". help vampires at least know they are making other people do their homework and so don't have that moral high ground.
09:14:57 <chpatrick> yep, got it
09:15:02 <ReinH> functions cannot have infinite args
09:15:05 <ReinH> end of discussion
09:15:13 <magneticDuck> ReinH: printf has done it, so how Guest2542 thinks he just has to understand function application enough to work it out for himself
09:15:21 <Guest2542> the guy buying the hat told the salesperson his wife didnt like sunglasses and that it wasnt a noption for him, the salesperson ignored this and became confused as to the exasperation of the sunshy party
09:15:21 <magneticDuck> and the reality is that printf is black magic and nobody may touch it
09:15:22 <ReinH> magneticDuck: I don't think printf accepts infinite args
09:15:34 <Cale> ReinH: Also, lists can be empty, and functions cannot have 0 args.
09:16:02 <ReinH> Guest2542: what you want is literally impossible. Does that bother you?
09:16:09 <ReinH> Or do you still want it?
09:16:24 <Guest2542> convince me its not possible
09:16:29 <mauke[> why?
09:16:29 <Cale> (yes, I know there's a sort of obvious interpretation of nullary functions, but it does seem to be a relevant point nonetheless given the things being discussed here)
09:16:30 <Guest2542> thats what iv been asking for
09:16:31 <geekosaur> well, you can touch it, but your pointy hat needs to be almost as tall as Oleg's
09:16:32 <ReinH> functions cannot have infinite arguments
09:16:37 <ReinH> lists can be infinite
09:16:39 <ReinH> QED
09:16:50 <Guest2542> i can lazy?
09:16:54 <Cale> Guest2542: [Integer] contains the following list:
09:16:59 <Cale> > let ones = 1 : ones in ones
09:17:01 <ReinH> Guest2542: no, you can't.
09:17:01 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:17:11 <ReinH> functions have finite types
09:17:22 <zipper> WHY IS IO SO HARD???
09:17:26 <nshepperd> i suspect everyone here should listen to wise monochrom
09:17:30 <zipper> I hate this *sobs*
09:17:32 <Cale> zipper: What problem are you having?
09:17:48 * dfeuer hugs zipper.
09:17:53 <bergmark> gs
09:17:54 <zipper> Cale: I honestly don't know https://gist.github.com/urbanslug/e20a715f837bf0975544
09:18:05 <haasn> monochrom: what are monoids?
09:18:06 <zipper> Cale: If you've played with the auto package.
09:18:16 <zipper> Cale: L28
09:18:24 <Guest2542> System.IO.Unsafe (unsafePerformIO :: IO a -> a)
09:18:48 <Cale> zipper: Okay, I have an answer to your question about why IO is so hard, but I don't think it's one you'll want to hear ;)
09:18:58 <Guest2542> i can always compose infinitly many functions
09:19:01 <zipper> Cale: Why is it so hard?
09:19:03 <Guest2542> thats my point
09:19:10 <ReinH> Guest2542: which has nothing to do with infinitely many args
09:19:13 <Guest2542> nested functions should compose as lists
09:19:26 <ReinH> "should"
09:19:36 <Guest2542> anyway, functions only have 1 or 0 arguments
09:19:44 <dfeuer> I should have wings. *sob*
09:19:46 <magneticDuck> Guest2542: but haskell's type system is not lazy like its data system is (hopefully what I'm saying is more or less right)
09:19:50 <zipper> It's not even funny how much cummulative time I have spent on IO issues.
09:19:51 <ReinH> Guest2542: functions do not have 0 arguments
09:19:51 <mauke[> Guest2542: no, they don't
09:19:53 <aweinstock> doesn't Text.Printf.printf allow arbitrarily many arguments by use of typeclass hacks?
09:20:05 <zipper> When you enter IO you're doomed.
09:20:13 <Guest2542> :t 1 . 1
09:20:14 <mauke[> aweinstock: yes, this has been mentioned
09:20:14 <lambdabot> (Num (b -> c), Num (a -> b)) => a -> c
09:20:28 <geekosaur> aweinstock, typeclass hacks that are not generally applicable
09:20:29 <Cale> zipper: You're not just using IO here
09:20:47 <Cale> zipper: You're apparently trying to use IO in the middle of some Arrow computation.
09:20:50 <zipper> Cale: I'm not even familiar with arrows. I read about them just last night.
09:21:02 <geekosaur> in particular, it has seen the format string and has a way to stop expecting parameters as a result. there is no such way in this question
09:21:03 <dfeuer> Skylar "skylar.k" Kergil has a song called something like "On Birds and Bodies" that might be relevant.
09:21:03 <Cale> I don't think IO belongs anywhere near arrows
09:21:07 <haasn> magneticDuck: haskell's type system is, per default, decidable - hence the distinction between ‘lazy’ and ‘strict’ makes no sense on the type system because any calculation the compiler would have to make will always terminate with a result
09:21:12 <zipper> Cale: How can I avoid that? It's an IRC bot.
09:21:21 <magneticDuck> haasn: yeah ofc
09:21:38 <Cale> In particular, the proc/do notation is really a bad abstraction the moment you start having non-local effects of any sort
09:21:54 <haasn> that said, it can get quite slow to decide in some circumstances because of strictness :(
09:22:28 <Guest2542> so i can fold along an infinite list, and i can compose an infinite list of functions, so why i cant use (.) like (:) and make my curryN function
09:22:50 <zipper> Cale: You didn't tell me what I wouldn't want to hear.
09:23:04 * hackagebot rest-client 0.5.0.3 - Utility library for use in generated API client libraries.  http://hackage.haskell.org/package/rest-client-0.5.0.3 (AdamBergmark)
09:23:06 * hackagebot rest-core 0.36 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.36 (AdamBergmark)
09:23:08 * hackagebot rest-gen 0.17.0.4 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.17.0.4 (AdamBergmark)
09:23:10 * hackagebot rest-happstack 0.2.10.8 - Rest driver for Happstack.  http://hackage.haskell.org/package/rest-happstack-0.2.10.8 (AdamBergmark)
09:23:11 <Cale> zipper: If you can find any way at all to do all the I/O outside of your arrow computation, that would be best. I have no familiarity with this Auto library, but to be honest, I don't know how much I'd want to use it just to write an IRC bot.
09:23:12 * hackagebot rest-snap 0.1.17.18 - Rest driver for Snap.  http://hackage.haskell.org/package/rest-snap-0.1.17.18 (AdamBergmark)
09:23:23 <saulzar_> zipper, There's something wrong with respond - you've put an IO type on it but it's not doing any IO...
09:23:25 <Cale> Is the goal of the IRC bot just to learn how this Auto library works?
09:23:25 <dolio> Cale: Is that because you can't tell what order things are going to go in necessarily?
09:23:42 <ReinH> Guest2542: because that function's type would be infinite
09:23:48 <Cale> dolio: right, it breaks the abstraction that your arrow computations consist of a bunch of boxes that are wired together
09:23:49 <ReinH> and that is not allowed
09:23:54 <Guest2542> evedently
09:23:57 <haasn> saulzar_: There's an IO lookup in getNP
09:24:13 <zipper> saulzar It's receiving something from IO
09:24:16 <saulzar_> Ah, right - so there is, using applicative
09:24:34 <Guest2542> {# language InfiniteTypesPlease #}
09:24:44 <haasn> Haskell can easily embed infinite types
09:24:44 <zipper> I use monads functors applicatives and now suddenly arrows.
09:24:56 <zipper> None of them make the issue any easier
09:25:02 <zipper> They just add complexity
09:25:08 <Guest2542> obvs
09:25:20 <chpatrick> zipper: I think that's kinda true for arrows but not the others
09:25:22 <mauke[> ocaml -rectypes
09:25:24 <Guest2542> haasn: do you think i can do this?
09:25:54 <saulzar_> If it helps, you're not the only one to find frp kind of hard to work with. I think it takes some getting used to
09:26:37 <ReinH> haasn: how?
09:26:40 <zipper> saulzar_: Oh my that's FRP? I heard it being spoken of in the haskell cast and understood nothing.
09:26:46 <haasn> Guest2542: If the question is solely whether or not ‘f’ can be defined such that ‘f g h x = g (h x)’ and ‘f g h x y z = g (h x) (h y) (h z)’, then my gut answer is “yes, with enough language extensions”
09:27:02 <ReinH> haasn: that is not the question
09:27:06 <saulzar_> zipper, Well, Autos is a kind of FRP - I think?
09:27:09 <zipper> Okay it said in the description of the library but I didn't know I was actually doing any FRP
09:27:34 <zipper> ReinH: Heh I found videos of you on youtube. :D
09:27:43 <ReinH> zipper: :D
09:27:46 <haasn> ReinH: A simple example is newtype Fix f = Fix (f (Fix f)) -- ‘Fix f’ is now an infinite type, like ‘f (f (f (f (f (f (f ...’
09:27:50 <Guest2542> not that its my most perssing quiry, but, rhetorically, if its possible, why am i recieving so much opposition?
09:28:08 <ReinH> haasn: Fix f is a *recursive* type.
09:28:14 * hackagebot rest-types 1.14 - Silk Rest Framework Types  http://hackage.haskell.org/package/rest-types-1.14 (AdamBergmark)
09:28:16 * hackagebot rest-wai 0.1.0.8 - Rest driver for WAI applications.  http://hackage.haskell.org/package/rest-wai-0.1.0.8 (AdamBergmark)
09:28:29 <ReinH> Guest2542: because what you actually want is impossible
09:28:41 <haasn> ReinH: yes, but it's an embedding in Haskell of the otherwise untypable infinite type “f (f (f (f (f ....”, no?
09:28:51 <ReinH> haasn: I guess.
09:28:58 <Guest2542> someone was talking about fix before, can i use it to make my curryN?
09:29:16 <ReinH> Guest2542: no.
09:29:17 <indiagreen> Guest2542: one reason is that you've been given examples of -code that does something close to what you want- many times and now it's unclear what the problem is and you seem to be disregarding those links
09:29:28 <chpatrick> you could probably turn a -> a -> a -> a -> b into Free ((->) a b
09:29:38 <haasn> ReinH: Same goes for classic combinators like ‘y’ that can't be typed in Haskell, you can embed them using tricks like newtype Lam = Lam (Lam -> Lam) -- or various other recursive types
09:29:47 <chpatrick> Free ((->) a) b
09:29:51 <Guest2542> thanks chpartick
09:29:53 <ReinH> If you want a function f :: ([a] -> b) -> (a -> a -> a -> ... -> b), it is simply impossible.
09:29:54 <haasn> Even though directly trying to define ‘y’ would lead to an infinite type error
09:30:08 <ReinH> That would be what currying a list would look like, and it is not possible.
09:30:15 <chpatrick> guest: but you can't do the reverse yeah
09:30:26 <Guest2542> yes yes yes
09:30:30 <chpatrick> guest: the list an be any size at runtime but the resulting function has to have fixed arity
09:30:37 <chpatrick> at compile time
09:30:48 <ReinH> chpatrick: It can't even handle the infinite case at all, so there's no point
09:31:04 <ReinH> This is really very simple: you can't construct an infinite type, so you can't curry an infinite lst.
09:31:21 <ReinH> So since you can't know if a list is infinite, you can't curry *any* lists
09:31:23 <chpatrick> you can't curry any list
09:31:29 <chpatrick> yeah
09:31:56 <ReinH> You can disbelieve me all you want, but I'm not interested in having this discussion any more. There's nothing more to be said.
09:32:16 <dfeuer> ReinH, can't the arity of the function determine the expected length of the list, just like in (ugh!) printf?
09:32:29 <ReinH> dfeuer: that's backwards
09:32:30 <dfeuer> Using some horrid OverlappingInstances?
09:32:33 <Cale> ReinH: The problem is it's not even clear what the heck that symbol (a -> a -> a -> ... -> b) means
09:32:37 <haasn> ReinH: I think you could make that ‘f’ work, with a slightly different type signature
09:32:47 <ReinH> Cale: Well, it's an impossible type. That's my point.
09:33:01 <Guest2542> and then the final point, why its not possible? it seems on ok concept to me, if i never ask it to compute infinite list, just use it on say functions of 3 or 4 arguments. so its that the number of argumnets is lost and can not be patern matched on. i cant say, make a data struction called N tuple or N list and have it cointain N elemnts and cast function of n arguments to this by demanding the type, because for some reason there is
09:33:12 <dfeuer> ReinH, backwards? Oh, because with printf, the known function is applied to an unknown number of arguments,
09:33:17 <dfeuer> whereas here you have an unknown function?
09:33:19 <haasn> I assume the goal here is to define ‘f’ such that f g = g []; f g x = g [x]; f g x y z = g [x,y,z]; ...
09:33:34 <ReinH> dfeuer: this is universally quantified, not existentially
09:33:35 <Cale> It reminds me of when people who don't understand decimal expansions ask about the real number 0.000...01 where there are infinitely many zeroes somehow
09:33:36 <Guest2542> yes
09:33:44 <ReinH> Cale: yes exactly
09:33:44 <haasn> The most problematic thing here is the fact that ‘b’ could be ‘a -> c’
09:33:54 <haasn> So you would run into some situations where you get an ambiguous type error
09:34:11 <Cale> ReinH: and even if there were infinitely many a's it still doesn't make sense!
09:34:19 <Guest2542> but if i only ask for the first n digits of an irational numer its fine
09:34:25 <ReinH> haasn: I think the *most* problematic thing is probably that it's impossible for the reason I mentioned
09:34:25 <Cale> ReinH: because the lists might not be infinite
09:34:45 <ReinH> Cale: well, variadic functions are possible
09:34:51 <haasn> ReinH: I don't follow
09:34:59 <ReinH> haasn: infinite lists.
09:35:01 <Cale> ReinH: Yeah, but it still doesn't really make sense?
09:35:03 <Cale> Like...
09:35:19 <Guest2542> are you guys deciding that your confused for the same reason i am?
09:35:21 <maerwald> looks like a case haskell cannot deal with
09:35:33 <dfeuer> Guest2542, can you change your nick to something easier to type?
09:35:34 <ReinH> maerwald: it is, but it's also a case nothing can deal with
09:35:41 <Cale> Okay, I can define a type like this:   data ManyArgs a b = Zero b | Succ (a -> ManyArgs a b)
09:35:54 <maerwald> ReinH: that's not true, we just had examples of other languages that can do what Guest2542 wants
09:35:55 <ReinH> A functino of type (a -> a -> a ... -> b) with an infinite number of a's and then a b doesn't even make *sense*.
09:36:00 <Cale> this is a type of functions of a variable number of arguments of type a
09:36:05 <Cale> But even with a type like this
09:36:07 <ReinH> maerwald: I don't believe you.
09:36:10 <maerwald> ok
09:36:11 <Cale> it doesn't make sense
09:36:20 <haasn> ReinH: But the function still works fine for all finite inputs, no? The infinite case would be nonsensical either way, because you can't type ‘curryN f a b c d e f' g h i j k ........’ with an infinite number of symbols in any source code program
09:36:27 <ReinH> haasn: Yes, but that's not sufficient
09:36:30 <haasn> I wouldn't think that's a requirement here
09:36:31 <ReinH> since you can't know if a list is infinite
09:36:38 <ReinH> of course it's a requirement
09:36:39 <ReinH> lists can be infinite
09:36:46 <dfeuer> Also, guest2542, it sort of sounds like you're confusing how variable numbers of arguments are (sort of) handled in Haskell with how they're handled in Lisp/Scheme, which have an entirely different notion of how functions work.
09:36:47 <ReinH> and you can't know that they are finite
09:36:49 <haasn> The function is not receiving a list
09:37:03 <haasn> It's receiving a fixed, finite number of parameters, constructing a fixed, finite list, and passing this off to a black box function
09:37:04 <ReinH> haasn: the proposed function is uncurrying a list
09:37:06 <haasn> How is any of this problematic?
09:37:37 <zipper> Cale: I updated the gist and now I have something easier to work with. Any ideas?
09:37:37 <Cale> Guest2542: We're all just agreeing with each other about how confused you seem to be
09:37:40 <haasn> curryN sum a b c would just be sum [a,b,c]
09:38:03 <zipper> Cale: From Auto IO String [Messages] -> Blip [Messages]
09:38:26 <zipper> @hoogle Auto IO String [Messages] -> Blip [Messages]
09:38:26 <lambdabot> Did you mean: Auto (IO a) String [Messages] -> Blip [Messages]
09:38:26 <lambdabot> No results found
09:38:28 <ReinH> haasn: that would be uncurryN
09:38:34 <ReinH> :t curry
09:38:35 <lambdabot> ((a, b) -> c) -> a -> b -> c
09:38:45 <geekosaur> Guest2542 would be less confused if they were willing to accept that their fundamental assumption is false, after being repeatedly shown why it is false and rejecting that because they prefer to believe it is true instead
09:38:45 <haasn> curry* takes (a,b,c) -> x into a -> b -> c -> x
09:38:56 <haasn> We're taking [a] -> x into a -> a-> a -> x
09:39:02 <Cale> maerwald: It's not really fair to take an example of a language where function application is primitively defined by passing an array, and the language provides you with a primitive apply, and compare it to the case we have in Haskell.
09:39:14 <ReinH> haasn: yes, which is the opposite of what you just said
09:39:20 <haasn> That is: we receive a black box [a] -> x function as input, and can construct any fixed, finite a -> a -> a -> x as output
09:39:33 <haasn> In other words: our new function receives a fixed, finite number of ‘a’ as input and passes it off to the original black box function
09:39:39 <haasn> It is exactly what I've said, and it's trivially possible in Haskell
09:39:41 <haasn> I have *written* this function before
09:39:46 <ReinH> haasn: Ah. I see.
09:39:49 <dfeuer> haasn, I wouldn't call it trivial.
09:40:00 <maerwald> Cale: it's not about fairness
09:40:04 <haasn> Ah, no, I've written the inverse before; f :: (a -> a -> a -> x) -> ([a] -> x)
09:40:07 <maerwald> it's about reality
09:40:08 <dfeuer> And I'm pretty sure it involves OverlappingInstances.
09:40:14 <haasn> No, I've not written that inverse either
09:40:26 <Cale> maerwald: Okay, I suppose "fair" isn't the right word
09:40:32 <dfeuer> And no, I don't remember which is what.
09:40:37 <Cale> maerwald: I mean, it's not really analogous
09:40:42 <haasn> Well, I have, but it was more like ([a] -> Maybe (x, [a])) to make it safe
09:40:44 <dfeuer> But it's all a horrifying mess.
09:40:48 <Guest2542> yeh, ok so i have a new type which is a finite list?
09:40:50 <Cale> maerwald: If you want to write that program in Haskell, you should just be taking a list argument
09:41:24 <ReinH> Guest2542: how can you restrict the type to only allow finite lists?
09:41:42 <Cale> You could use Array Int a
09:41:45 <dfeuer> HList has some magic stuff that lets you construct HLists in a polyvariadic fashion. I don't remember how it goes. Something like MagicFoo MagicBar whatever you want.
09:41:47 <albeit> To experienced Haskellers: Do you *always* avoid partial functions like !!,Map.!,head,init,tail,last,etc...?
09:41:59 <ReinH> Cale: Oh, so a tuple.
09:42:02 <ReinH> ;)
09:42:05 <Cale> albeit: Not *always*, but mostly.
09:42:09 <chpatrick> albeit: not if I know the precondition holds
09:42:13 <dfeuer> albeit, sometimes you can't.
09:42:22 <Cale> albeit: There are lots of cases where you know for sure that it's absolutely safe
09:42:27 <Guest2542> geekosaur thats not true and it will encourage a warped perception of my problem
09:42:37 <Guest2542> so my list is finite, whats the problem?
09:42:38 <albeit> Okay, thanks guys
09:42:44 <geekosaur> except you have repeatedly been shown that it is true
09:42:51 <geekosaur> you don't accept it
09:42:52 <Cale> albeit: and they're fine in those cases, so long as you're not also *testing* the structure to make sure beforehand, which is a good sign that you should just pattern match
09:42:59 <dfeuer> albeit, one reason is that Haskell's type system often isn't powerful enough to express the necessary invariants.
09:43:12 <Cale> > map head . group . sort $ "abracadabra"
09:43:13 <geekosaur> you've spent how many hours insisting that it is true and rejecting proofs that it is not
09:43:14 <lambdabot>  "abcdr"
09:43:20 <Cale> ^^ map head is safe there
09:43:24 <haskell730> Can someone take a look at this: http://lpaste.net/132928
09:43:34 <ReinH> albeit: On the other hand, we did spend a week tracking down a partiality bug in a library recently, so...
09:43:37 <Cale> because the lists in the list that group produces will always be nonempty
09:43:56 <ReinH> albeit: I am comfortable using partial funcitons only when I accept the proof burden that they are being used in a total way
09:44:00 <jonrus> Could an experienced Haskeller help a newbie with this? I'm trying to parse a Yaml file into Haskell ... object? Anyways the format of the Yaml file is making it a little tricky - https://gist.github.com/JonMidhir/7748bc4412887c2c09d8
09:44:06 <maerwald> albeit: you might be interested in liquidhaskell which extends the haskell type system with general constraints, but it's more of a research project currently
09:44:09 <luzie> wow Guest2542 is still here after 6 hours
09:44:34 <dfeuer> And still with that ridiculous nick.
09:44:36 <albeit> maerwald: Cool, I'll take a look
09:44:36 <Guest2542> i have not seen 1 proof that it is not possible
09:44:48 <Guest2542> infact i have seen numerous indications that it should be
09:45:05 <dolio> I think it's about time for this conversation to be over.
09:45:16 * dfeuer is falling asleep.
09:45:18 <darm> Hi guys, I'm searching for a showcase simple threading implementation that is done using some kind of CPS implementation. I can't seem to find it, but I know it is pretty popular, do you guys have a link or a reference?
09:45:23 <luzie> Guest2542, no one here knows how to do it
09:45:23 <monochrom> I'm going to take a drastic action.
09:45:25 <Guest2542> dolio: im so sorry this hasnt come to anything more than a flame war
09:45:29 <luzie> Guest2542, if you find out, please tell
09:45:31 --- mode: ChanServ set +o monochrom
09:45:32 <Cale> Guest2542: People have posted solutions to writing variadic stuff that sound like the sort of thing that you wanted
09:45:32 <indiagreen> jonrus: where is DBEnvConfig's “name” supposed to come from?
09:45:40 <geekosaur> you have not *accepted* any propof. and the things you think mean it is possible in fact were attempting to show you why various attempts to reach it must fail
09:45:50 --- mode: monochrom set +b *!*@gateway/web/freenode/ip.128.40.76.3
09:45:56 <Cale> Guest2542: But if you use them in real code... well, good luck to you, I don't want to maintain that code
09:45:57 --- kick: Guest2542 was kicked by monochrom (Guest2542)
09:46:02 <luzie> :(
09:46:03 --- mode: monochrom set -o monochrom
09:46:17 <jonrus> indiagreen: That's the tricky bit - the "name" should be the root of the Yaml. In that file 'development', could also be 'production' or others
09:46:19 <dfeuer> That was drastic.
09:46:26 <indiagreen> jonrus: ah
09:46:38 <Cale> zipper: hmmm
09:46:40 <geekosaur> not after 6 bloody hours it's not
09:46:41 <dolio> It appears that that was going on for like 3 hours.
09:46:43 <indiagreen> jonrus: a sec, I'll write a solution
09:46:45 <dolio> At least. 
09:46:47 <luzie> 6 hours
09:47:03 <dolio> Ah. I thought maybe it was another topic earlier.
09:47:04 <zipper> Cale: Oh I deleted that. :( I rewrote it differently. 
09:47:09 <zipper> Cale: Still failed.
09:47:13 <luzie> well, 5 hours and 45 minutes
09:47:13 <Cale> zipper: okay
09:47:14 <dolio> Anyhow.
09:47:27 <Cale> zipper: You might want to try just writing the IRC bot in a more direct style first
09:47:38 <zipper> Cale: What do you mean?
09:48:05 <Cale> I dunno, just plain boring Haskell IO code, rather than trying to use fancy libraries from the outset -- assuming your goal is just to get something which works
09:48:13 <jonrus> indiagreen: Thanks :) Been at it a while now. There will be multiple environments in the Yaml file, I've amended the pastie!
09:48:23 <Haskellfant> I am trying to play around with linear gradient decents, but I am having trouble figuring out the types of the 'ad' library that I'd like to use for differentiation. I think I understand that the error is caused by the forall quantifier which doesn't allow me to let the s escape, but I have no idea how to make it typecheck http://lpaste.net/132930
09:48:41 <zipper> Cale: Hmmmm I don't know any other way of building a bot.
09:49:34 <indiagreen> jonrus: if there are many environments it's even easier actually, you just parse your file into Map String DBConfig and it'll work automatically
09:49:35 <Cale> zipper: I mean, what problem is this auto library supposed to be solving for you? It sounds cool, but it's a heavy piece of machinery...
09:50:07 <albeit> Is it acceptable to use "error" in production code for things that should never happen? Or is it preferable to use exceptions or something else?
09:50:21 <zipper> Cale: The only bot building tutorial I found uses the Auto lib so I literally know no other way.
09:50:24 <Cale> albeit: Depends on the behaviour you want when it fails
09:50:44 <indiagreen> jonrus: and then you can turn Map String DBConfig into a list of pairs like [(String, DBConfig)] and then construct [DBEnvConfig] out of it
09:50:53 <Cale> albeit: Using error to throw an exception should only be done in cases where you don't expect anyone ever to catch that exception.
09:51:05 <Cale> (and you just want the program to die)
09:51:15 <Cale> zipper: ah, okay
09:51:17 <Cale> zipper: one sec
09:51:26 <indiagreen> jonrus: if this is unclear, I can comment on your paste
09:51:43 <Haskellfant> zipper: there is one in the haskell wiki https://wiki.haskell.org/Roll_your_own_IRC_bot
09:52:03 <jonrus> indiagreen: Actually having the map and selecting the one I need would be enough at this stage, I'll need to look into how I can do this as I'm a bit unsure 
09:52:05 <Stratege> does anyone here have experience with Haskell's opengl bindings? I'm struggling with preservingMatrix apparently not preserving the matrix as the documentation seems to suggest.
09:52:09 <Cale> Yeah, I was about to give the same link
09:52:17 <jonrus> indiagreen: But thanks for the help, you've got me out of a hole!
09:52:34 <Cale> The code there wins a pointless-use-of-monad-transformers award from me, but otherwise it's pretty straightforward.
09:52:56 <indiagreen> jonrus: there's *nothing* you have to do, you just write “let configs = Data.Yaml.decode ymlData :: Maybe (Map String DBConfig)” and that would give you a map
09:53:13 <zipper> Hmmm I'll take a look
09:53:19 <voidzero> zipper, look up 'Number Six' on github
09:53:20 <jonrus> indiagreen: Oh wow awesome
09:53:24 <voidzero> also an example of an irc bot
09:53:26 <voidzero> there are others too
09:53:27 <Cale> (maybe that's a little mean, it does kind of a good job of fleshing out a couple operations in its new Net monad)
09:53:39 <zipper> There's this side of me that can't just leave a problem halfway
09:53:40 <voidzero> i gotta run now though :)
09:54:32 <Cale> (but not really enough to justify not just using an additional function parameter instead, with clearer IO actions)
09:54:55 <voidzero> Cale, i'd love to see you take a stab at it
09:55:12 <Cale> voidzero: What? Writing an IRC bot?
09:55:42 <voidzero> yeah, or improving the page on the wiki.. or even just elaborating on what you said about it just now :)
09:55:57 <zipper> voidzero: OMFG Number Six is just...
09:56:01 <zipper> I can't even
09:56:05 <Cale> ah, well, type Net = ReaderT Bot IO
09:56:14 <zipper> voidzero: The only thing it doesn't do is wolfram alpha
09:56:20 <voidzero> haha yes
09:56:24 <Cale> This is isomorphic to  type Net a = Bot -> IO a
09:56:28 <jonrus> indiagreen: It's still coming up with Nothing for me :(
09:56:42 <zipper> voidzero: Did you make it?
09:56:44 <voidzero> darn, gotta chauffeur someone, back later
09:56:48 <Cale> So instead of having this Net type, you could just pass an argument of type Bot
09:56:53 <voidzero> i wish
09:56:55 <voidzero> but no
09:56:56 <indiagreen> jonrus: okay, a sec, I'll look at it
09:57:00 * voidzero &
09:57:23 <jonrus> indiagreen: thanks mate
09:57:46 <hodapp> it seems that what I need is now... Proxy (Rep a x) -> Rep a x. hmmmm.
09:59:58 <indiagreen> jonrus: it doesn't work because the “password” field is missing
10:00:41 <jonrus> indiagreen: Omg of course
10:00:49 <jonrus> facepalm
10:00:56 <indiagreen> jonrus: if you want it to be okay to be missing, you should change the type of “password” to “Maybe String”
10:01:48 <jonrus> indiangreen: You're a legend. Thanks!
10:02:49 <haasn> ReinH: ‘curryN’ in Haskell: https://0x0.st/_b.txt
10:03:04 <haasn> “curryN id 1 2 3 :: [Double]” => [1.0, 2.0, 3.0]
10:03:06 * hackagebot pipeclip 0.1.0.0 - Open your editor, pipe the output to the system clipboard  http://hackage.haskell.org/package/pipeclip-0.1.0.0 (pharpend)
10:03:08 * hackagebot data-reify 0.6.1 - Reify a recursive data structure into an explicit graph.  http://hackage.haskell.org/package/data-reify-0.6.1 (ryanglscott)
10:03:10 * hackagebot html-kure 0.2.1 - HTML rewrite engine, using KURE.  http://hackage.haskell.org/package/html-kure-0.2.1 (ryanglscott)
10:03:13 <haasn> ​“curryN sum 1 2 :: Double” => 3
10:03:16 <haasn> 3.0 even
10:04:18 <Sonarpulse> edwardk: So your nat's package used to contain a Whole typeclass, but that didn't make it into base?
10:05:40 <exio4> haasn: you don't need OverlappingInstances there
10:06:13 <haasn> exio4: you need it when instantiating
10:06:31 <haasn> Maybe some of the new GHC overlapping pragma stuff can help me here
10:06:45 <exio4> haasn: ? 
10:07:23 <haasn> exio4: Remove OverlappingInstances and load the file into GHCi; then evaluate “curryN id 1 :: [Double]” =>     Overlapping instances for CurryN a0 [a0] (a1 -> [Double])
10:08:05 <exio4> you can avoid using the equalities
10:08:06 * hackagebot hood 0.2.1 - Debugging by observing in place  http://hackage.haskell.org/package/hood-0.2.1 (ryanglscott)
10:08:08 * hackagebot editor-open 0.6.0.0 - Open the user's $VISUAL or $EDITOR for text input.  http://hackage.haskell.org/package/editor-open-0.6.0.0 (pharpend)
10:08:26 <exio4> instead of (c ~ a) => Class a b c, use Class a b a
10:10:35 <haasn> exio4: Then it complains about ambiguous types
10:10:41 <haasn> (In the same example)
10:11:07 <noodles1> I'm a bit confused about how I should go about solving a problem. I have a function 'comp
10:11:17 <exio4> er, right
10:11:34 <haasn> exio4: I could not figure out if there are any meaningful fundeps that help here, incidentally
10:12:10 <haasn> Intuitively ‘x’ should fix both ‘a’ and ‘b’, but it doesn't always do so - at least not for ‘a’ in the case that you apply it with no parameters
10:12:37 <michaelt> noodles1: ?
10:12:43 <haasn> Also, ‘a’ and ‘b’ should fix at least the *return* type of ‘x’ and the *parameter* type of ‘x’, maybe I can add more parameters to the MPTC in order to get more specific with my fundeps
10:13:00 <haasn> (But I would still require overlapping instances on ‘x’ itself)
10:13:06 * hackagebot pipeclip 0.1.0.1 - Open your editor, pipe the output to the system clipboard  http://hackage.haskell.org/package/pipeclip-0.1.0.1 (pharpend)
10:13:08 * hackagebot sized-types 0.5.1 - Sized types in Haskell using the GHC Nat kind.  http://hackage.haskell.org/package/sized-types-0.5.1 (ryanglscott)
10:13:10 * hackagebot marked-pretty 1.1.2.1 - Pretty-printing library, with scoping, based on pretty.  http://hackage.haskell.org/package/marked-pretty-1.1.2.1 (ryanglscott)
10:14:41 <noodles1> ' that has a tuple with a [Bool] element. After creating two [Bool] and joining them, I want to continue to put another [Bool] in between them until a condition is met. Like [First] [Last], another tuple with [First] [Middle] [Last], and middle continues to grow.. sorry for the poor explanation, here's an lpaste: http://lpaste.net/5971080035610656768
10:16:19 <Sonarpulse> anybody else know what happend to the Whole typeclass?
10:16:50 <exio4> hackagebot: I stand corrected :/
10:28:30 <michaelt> noodles1: is it the types that are the trouble?
10:32:16 <fvgvxmpv1> Sonarpulse, Integral?
10:32:25 <noodles1> michaelt: no, it's that I barely know any of haskell's constructs. The type I have is a tuple ([Bool], [Int], Int), (line, restrictions, length). I want to take the line and append another [Bool] I calculate from restrictions to it. Then continue to sandwich another [Bool] that's growing in the middle until a condition is met
10:33:26 <noodles1> for example, parent tuple: ([True, False], [2], 5) ; ([True, False, -True-, -True-, -False-], [], 2) ; ([True, False, *False*, -True-, -True-, -False-], [], 1) ; ([True, False, *False*, *False*, -True-, -True-, -False-], [], 0)
10:33:56 <SrPx> Is there any way to run a haskell program very fast? runhaskell takes 3 seconds here :(
10:34:04 <SrPx> as opposed to node.js which is instant, so...
10:34:10 <Denommus> SrPx: hm, compile it
10:34:17 <SrPx> compiling takes some time...
10:34:32 <SrPx> I want to modify the file, press a key on VIM and see the result asap
10:34:51 <Denommus> SrPx: try some inferior haskell process, then
10:34:58 <SrPx> what do you mean?
10:35:00 <geekosaur> SrPx, nobody has written an optimizer for ghc's bytecode backend.
10:35:15 <geekosaur> nobody seems to be particularly interested in doing so
10:35:39 <noodles1> where - represents a sublist calculated by one function, and * represents a sublist of False that grow until a condition is met. There'll be a way to save the first and last [Bool] suiblists and continue to sandwhich a growing sublist of False in.. I just need to figure out the syntax to do that
10:35:43 <SrPx> doesn't need to be runhaskell, anything that reads a haskell file and outputs the result fast is ok
10:36:05 <SrPx> I've been thinking in somehow piping ghci and vim but I'm not sure how to do this
10:36:13 <Denommus> SrPx: wait, doesn't vim support inferior processes?
10:36:21 <geekosaur> ghci is the same backend as runhaskell, won't be any faster
10:36:24 <SrPx> I don't know what that is, lmgt
10:36:28 <geekosaur> you make haskell code faster by compiling it
10:36:37 <SrPx> geekosaur: but somehow :r on ghci is much faster than runhaskell here
10:36:53 <enthropy> maybe most of the 3 seconds is to load many other things, and not to calculate the result
10:37:01 <SrPx> geekosaur: it is not the code that is slow, it is loading the deps...!
10:37:03 <geekosaur> llkely startup overhead, yes
10:37:10 <SrPx> the code can be a main = print 7 -- it will take 3 secs here
10:37:18 <SrPx> yep
10:37:46 <SrPx> there are 30 or so imports on that file. Maybe if I could somehow make runhaskell pre load them?
10:37:55 <SrPx> so when I run it again it loads just my file
10:38:54 <geekosaur> aside from remote-controlling ghci, you'd have to delve into ghc-api
10:39:09 <geekosaur> no, you can't make runhaskell preload them
10:39:26 <geekosaur> it's just not designed for that use case
10:39:28 <michaelt> SrPx: I guess you could have a running ghci and then use System.Process. It seems kind of horrible ...
10:39:38 <Denommus> this would all be a solved problem if he was just an Emacs user
10:39:42 <SrPx> michaelt: that sounds reasonable to me actually
10:39:53 <SrPx> I just don't know how to do it :( 
10:43:58 <michaelt> you want ghci to reload it every time the file is saved or something ?
10:46:22 <hodapp> hot damn, I am surprised at low little code it took to implement "Proxy a -> a" via GHC.Generics
10:46:39 <hodapp> it was basically just chaining "Proxy (Rep a x) -> Rep a x" with 'to'
10:46:47 <exio4> what'd that do? 
10:47:36 <hodapp> exio4: It let me create a constructor for my ugly type-family-ridden record type that did not require a ton of manual work
10:48:43 <hodapp> exio4: Constructing a value of this type is annoying and there was (prior to this) no generic way to do it, so all of my Generics code was oriented around operating on a Proxy rather than a value
10:49:54 <exio4> hodapp: I am thinking about getting any value out of a Proxy with a phantom type :p
10:50:36 <hodapp> exio4: I thought I just told you :P
10:51:18 <exio4> I haven't looked at generics, I think I'll write that on my tolearn list
10:51:57 <hodapp> exio4: I poked around a bit at Data.Data, and found it simpler (and likely more standard) than GHC.Generics, but not capable enough for what I needed
10:52:29 <hodapp> exio4: GHC.Generics I found a little more complicated, but after working with a couple examples, much more usable
11:00:25 <suppi> can someone help me with this behaviour?
11:00:39 <suppi> difference between: http://lpaste.net/2309692309228224512 and http://lpaste.net/6814146699515133952
11:01:17 <suppi> the first one behaves as planned, the second is almost the same as the first but I added line 31
11:01:20 <suppi> a trace 
11:02:02 <suppi> and now it doesn't trace 1, 2, 3
11:02:12 <suppi> nor the "spark:" thing
11:02:24 <suppi> what is happening?
11:08:51 <phaazon> hey
11:09:05 <phaazon> I’m witnessing a very weird behavior with http-conduit
11:09:11 <phaazon> if I run my program on my laptop
11:09:21 <phaazon> I can make my program go on youtube
11:09:30 <phaazon> and decode the body of a random page
11:09:39 <phaazon> if I put my application on my dedicated server at OVH
11:09:48 <phaazon> I get a « too many connections » error
11:09:50 <phaazon> why?
11:09:59 <c_wraith> rlimit?
11:12:38 <Zemyla> Hmm, why does Set.fmap convert the set to and from a list?
11:13:09 * hackagebot generic-xmlpickler 0.1.0.2 - Generic generation of HXT XmlPickler instances using GHC Generics.  http://hackage.haskell.org/package/generic-xmlpickler-0.1.0.2 (AdamBergmark)
11:13:43 <c_wraith> Zemyla: because you could pass it something like negate
11:14:05 <c_wraith> > let a = 1; b = 2 in (a < b, negate a < negate b)
11:14:07 <lambdabot>  (True,False)
11:14:07 <Zemyla> Yes, I know that it has to be resorted.
11:14:28 <Zemyla> But, for example:
11:14:30 <Zemyla> fmap f Tip = Tip
11:15:08 <Zemyla> fmap f (Bin x l r) = insert (f x) (union (fmap f l) (fmap f r)) 
11:15:47 <rien> I'm trying to install parseargs with cabal install but it fails without blaming another package: https://gist.github.com/canpeter/ef9eb6126bba316396b8
11:16:05 <Zemyla> fromList doesn't even use list fusion.
11:16:38 <Welkin> Zemyla: a Set has no order
11:17:02 <Zemyla> Welkin: Yes, but there are ways to sort a list using foldr.
11:17:03 <phaazon> 20:10 < c_wraith> rlimit?
11:17:07 <phaazon> what is that?
11:17:08 <Welkin> it's just a Map with a key of ()
11:17:19 <Welkin> er
11:17:23 <Welkin> with a value of ()
11:17:47 <c_wraith> phaazon: ultimately, "too many connections" is a policy decision by the kernel or your specific process.
11:17:55 <phaazon> oh
11:17:59 <c_wraith> phaazon: rlimit is a program that can lower those limits
11:18:06 <phaazon> I should be able to change that then
11:18:09 * hackagebot language-glsl 0.2.0 - GLSL abstract syntax tree, parser, and pretty-printer  http://hackage.haskell.org/package/language-glsl-0.2.0 (VoMinhThu)
11:18:22 <c_wraith> phaazon: well, that depends.  Maybe the program actually is leaking connections, in which case that's the issue.
11:18:44 <c_wraith> phaazon: but if it works on one machine and not another, I'd start by checking the connection limit
11:20:02 <phaazon> c_wraith: I’m trying to find a tool on a linux to change that
11:20:06 <phaazon> I don’t have rlimit installed
11:20:14 <phaazon> archlinux wiki says we should use pam
11:20:46 <c_wraith> phaazon: it's not certain to be the problem anyway.  Really you should be checking what the connection limit is, not just trying to raise it.
11:21:19 <c_wraith> phaazon: if it's anywhere near the default (1024ish, on most systems), it's unlikely to be the problem unless you're doing massively concurrent spidering.  Or leaking connections.
11:21:33 <phaazon> nah
11:21:42 <phaazon> I just run two simpleHttp sessions
11:21:47 <phaazon> one in http
11:21:51 <phaazon> the other one in https
11:21:54 <phaazon> nothing fancy
11:23:01 <jle`> @tell zipper you can always also just ask questions in #haskell-auto, and i also answer questions submitted through github issues :)
11:23:01 <lambdabot> Consider it noted.
11:23:33 <Zemyla> Also, a Map is a Set on (k, v) with a custom compare function cmp (a, _) (b, _) = compare a b.
11:26:17 <rien> can anyone help me figure out why cabal install parseargs-0.1.5.2 fails?
11:26:33 <Welkin> rien: paste your errors
11:26:37 <Welkin> @lpaste
11:26:37 <lambdabot> Haskell pastebin: http://lpaste.net/
11:26:46 <phaazon> c_wraith: http://lpaste.net/8609856479974916096
11:26:48 <rien>  https://gist.github.com/canpeter/ef9eb6126bba316396b8
11:26:52 <phaazon> that’s the error I got
11:27:07 <c_wraith> phaazon: *oh*.  That's not from your machine.
11:27:14 <phaazon> nope
11:27:16 <phaazon> but hm
11:27:19 <phaazon> something is a bit weird
11:27:23 <phaazon> http://https://
11:27:25 <phaazon> what the fuck is that.
11:27:43 <c_wraith> that's odd.  That's also what proxy requests look like sometimes.
11:27:57 <Welkin> rien: read the build log
11:28:04 <Welkin> you need more than the last 10 lines
11:28:17 <Welkin> you will be able to see what failed by working backward through the log
11:28:32 <Welkin> it will say "{some package name} failed to install"
11:30:07 <Welkin> rien: also, line 13 looks like it could be a problem
11:30:19 <rien> Welkin: I wish: https://gist.github.com/canpeter/95f4f4d344ff6edc118e
11:30:38 <Welkin> the last line looks like the problem
11:30:42 <Welkin> "unkown load command 10"
11:31:36 <rien> Welkin: I've no idea what that means :/
11:32:30 <rien> I think cabal is just misinterpreting some output from that /usr/bin/strip program. the program itself compiled and is useable
11:32:31 <Welkin> rien: neither do I
11:32:40 <Welkin> rien: it's your job to figure it out
11:32:41 <geekosaur> what version of OS X is that?
11:32:54 <rien> Welkin: how do I start given "unknown load command 10"?
11:33:02 <rien> besides asking here?
11:33:13 <geekosaur> what version of OS X is that?
11:33:27 <hexagoxel> rien: pepper more verbosity on the cabal install, see how it calls strip, then re-do it manually
11:33:41 <geekosaur> ...
11:34:55 <rien> geekosaur: 10.9.5 mavericks
11:35:06 <geekosaur> hm. what version of xcode?
11:35:09 <rien> 6.2
11:35:23 <rien> the lastest supported by 10.9.5
11:35:32 <Welkin> you are using xcode for haskell?
11:35:35 <ast__> whois
11:35:37 <geekosaur> I know of that error from strip on Snow Leopard (10.6) and its corresponding Xcode
11:35:47 <rien> Welkin: isn't that what they say to use?
11:35:49 <geekosaur> Welkin, xcode is the only way to get development tools
11:35:55 <hodapp> humm, I have "instance ToJSON_ f => ToJSON (Proxy (f b)) where toJSON p = toJSON_ p" and I feel like I could just somehow eliminate this wrapper... but this also looks like a lot of work for zero benefit
11:36:11 <geekosaur> the command line toolkit is part of xcode and versioned with it, although can be installed separately from the GUI
11:36:28 <Welkin> I just use emacs and the temrinal
11:36:30 <rien> geekosaur: I've installed both xcode and the CLT
11:36:33 <Welkin> terminal*
11:36:36 <geekosaur> and no compiler? no system libraries?
11:36:40 <rien> Welkin: lol ^
11:36:50 <Welkin> no, that all works
11:36:56 <Welkin> I installed the command line tools
11:36:57 <geekosaur> then you installed at least the CLT at some point
11:37:06 <geekosaur> yes. that is versioned with xcode
11:38:02 <geekosaur> it makes me wonder if you got an ld command from somewhere else though
11:39:03 <geekosaur> (very short version: it's tripping on the dyld information in the file)
11:40:14 <rien> hexagoxel: thanks for the suggestion - see anything suspicious? https://gist.github.com/canpeter/95f4f4d344ff6edc118e
11:40:30 <geekosaur> but load command 10 has been around for a while, so either the command line tools are ancient or ld created garbage somehow
11:43:19 <rien> I think just strip is failing
11:43:26 <rien> is there a way to tell cabal a package installed correctly?
11:43:38 <rien> the dylib is where I want it, that's all I care
11:43:57 <davama> hello everyone
11:50:22 <geekosaur> I'd say install it again but tell cabal --with-strip=/usr/bin/true
11:52:13 <rien> geekosaur++
11:52:43 <rien> geekosaur: *that's* what I was looking for. true is my best friend now. :) I didn't know of --with-strip either. thanks so much
11:52:46 <user1555> hi, quick question.. I'm just doing some Haskell exercises and I'm wondering why this function works when I define it the long way, but I get an error when I try to write it point free style
11:52:53 <ReinH> geekosaur: You can disable executable stripping with a command line option
11:53:03 <user1555> length' :: [a] -> Int
11:53:04 <user1555> length' xs = foldl (+) 0 $ map (\x -> 1) xs
11:53:10 <rien> ReinH: what is executable stripping even?
11:53:33 <ReinH> man strip :)
11:53:34 <geekosaur> the step that is failing
11:53:45 <geekosaur> it removes the symbol table
11:53:47 <ReinH> geekosaur: I said that rather than providing the option because I am looking it up...
11:53:48 <rien> ReinH: man has helped me 0 timesi n my life but thanks
11:53:58 <geekosaur> because a debugger like gdb is not particularly helpful with Haskell programs
11:53:58 <ReinH> rien: Well then you're doing it wrong
11:54:04 <geekosaur> it doesn't really understand them
11:54:07 <user1555> length' = foldl (+) 0 $ map (\x -> 1) -- doesn't compile
11:54:12 <rien> ReinH: blame the user not the tools?
11:54:58 <ReinH> rien: when other people are using the tools successfully, yes
11:55:12 <rien> for those curious, strip does nothing that is actually necessary to get cabal packages installed
11:55:26 <ReinH> I mean, the first sentence of man strip explains what it does, so
11:55:53 <geekosaur> ReinH, I think --disable-executable-stripping is about 10 characters longer than what I suggested :)
11:56:01 <ReinH> geekosaur: :p
11:56:06 <rien> ReinH: how does cabal install really "use" strip? it doesn't seem to need it as can be shown by replacing it with "true". so I don't agree with "when other people are *using* it successfully"
11:56:22 <ReinH> rien: It doesn't need it because stripping is optional
11:56:34 <ReinH> And I meant "using `man' successfully"
11:56:45 <ReinH> stripping is an optional step that reduces binary size
11:56:56 <rien> ReinH: how mad would you be if your packages didn't installs because something optional is being attempted without you being communicated about it?
11:57:45 <ReinH> rien: did you delete your gist?
11:58:06 <rien> ReinH: it's here now: https://gist.github.com/canpeter/95f4f4d344ff6edc118e
11:58:24 <ReinH> But it does communicate to you
11:58:31 <rien> are there any more optional things cabal does? I want to turn them off.
11:58:45 <ReinH> It tells you the error is from /usr/bin/strip
11:58:51 <ReinH> @google cabal user guide
11:58:52 <lambdabot> https://www.haskell.org/cabal/users-guide/
11:59:05 <rien> ReinH: if I coded that error I'd make it say: "if you don't care about stripping .... such and such"
11:59:21 <dcoutts> rien: you can disable executable stripping, it's one of the configure flags
11:59:52 <rien> dcoutts: yes now I know :) my question is what other optional things can I disable still unbeknownst to me?
12:00:03 <SrPx> Is there any way to, in a single line, call :r and a function on ghci?
12:00:03 <dcoutts> rien: have a look at configure --help
12:00:04 <ReinH> rien: But you wouldn't read it anyway, as you've already demonstrated
12:00:07 <ReinH> since you won't even read a man page
12:00:08 <SrPx> Need this for a vim macro
12:00:38 <rien> ReinH: I was never taught how to use man. It's not that I hate it. I read several man pages online where I can search better.
12:00:55 <rien> dcoutts: thanks
12:01:08 <ReinH> I suppose `man man' would not be a satisfactory answer to "how to use man" :)
12:01:17 <ReinH> read the manual manual
12:01:39 <rien> ReinH: just did man man, there are 0 examples
12:02:27 <ronh-> :t foldl (+) 0 . map (\x -> 1) 
12:02:27 <ReinH> Yes, but there is an entire document describing its use
12:02:28 <lambdabot> Num c => [a] -> c
12:03:13 <rien> ReinH: c'mon let's be real :) how can man compete with the internet when the internet has examples? are you telling me you'd rather read pages and pages of description than a few examples at first so you at least know where you are?
12:03:57 <bitemyapp> some manpages have examples in addition to manpage-style documentation.
12:03:59 <ReinH> rien: if you google for "man examples"... :p
12:04:24 <bitemyapp> synthesizing a correct example from manpage-style documentation can be difficult or easy depending on how many valid vs. invalid combinations of arguments there are.
12:04:25 <c_wraith> rien: I'd *much* rather have documentation that tells me what something does than examples that leave all the important parts out
12:04:26 <rien> bitemyapp: when I was writing a wrapper for PCRE the man pages for PCRE were particularly barren of examples
12:04:34 <rien> bitemyapp: I really lost my faith in this old stuff
12:04:39 <bitemyapp> faith?
12:04:55 <bitemyapp> manpages serve a fairly specific purpose. They're not trying to be Stack Overflow.
12:05:06 <ReinH> I guess reading a description of a command and its arguments and then figuring out how to call it is a lost skill.
12:05:11 <bitemyapp> manpages are the kind of thing you'd print out and read when first learning a new tool.
12:05:18 <bitemyapp> ReinH: not lost, just underappreciated.
12:05:32 <bitemyapp> synthesis is something you want to practice in multiple contexts tho
12:05:34 <ReinH> I mean, honestly, you need *examples* to use man? Really?
12:05:40 <rien> c_wraith: "important" -> I'd say important is runing accross someone that came up with a way to bypass this silly cabal install strip business, rather than knowing arcane theoretical details. usage comes first.
12:05:57 <ReinH> it's just `man $THING`
12:06:11 <ReinH> But this is a bit off topic now.
12:06:21 <rien> ReinH: plus you're exaggerating now :)
12:06:32 <c_wraith> rien: if you want a case study of what happens when all your developers program by googling for examples, take a look at PHP in the wild.
12:06:33 <rien> I never said I don't read man pages. I said I don't use man.
12:06:44 <geekosaur> ...
12:06:48 <ReinH> rien: no, it literally is "man thing"
12:07:00 <rien> ReinH: really:? what about the numbers I always see around man?
12:07:12 <bitemyapp> one problem with man's documentation is it doesn't explain the indexes
12:07:12 <ReinH> rien: If you read the man page for man, you'd know what they mean and why they are optional
12:07:24 <rien> c_wraith: this is about googling for package management help, not programming help
12:07:42 <gremble> When you are specifying function composition order like `show (length someList)` why can't you do `show . length someList` or `show $ length someList` arbitrarily deep?
12:07:55 <rien> ReinH: so it's not *literally* man thing then? :) there's an optional number. and so on.
12:08:03 <johnw> you can do show . length $ someList
12:08:03 <gremble> To my understanding those three functions would be equivalent
12:08:03 <ReinH> Yes, it literally is
12:08:37 <ReinH> For almost everything you need, it's literally `man thing'. And if you're using a different section, you probably know that.
12:08:42 <rien> ReinH: literally means to the letter. to the letter, people type thing(4) all the time online and never say how to access that page using man.
12:08:58 <exio4> man 4 thing
12:09:11 <ReinH> bitemyapp: some man pages for man have a section on the sections.
12:09:15 <ronh-> gremble `show . length someList' does not work because (.) expects two functions
12:09:16 <ReinH> OS X's doesn't, but OS X is awful
12:09:19 <ronh-> :t (.)
12:09:20 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:09:48 <rien> ReinH: what linux distro do you develop haskell in?
12:09:49 <ronh-> :t show . length
12:09:50 <lambdabot> Foldable t => t a -> String
12:09:52 <ReinH> rien: they don't say it because you can read it in... the manual.
12:10:01 <gremble> Oh alright. Thanks for clearing it up ronh- :)
12:10:02 <ReinH> rien: I use OS X.
12:10:18 <ReinH> bitemyapp: are you enjoying this? The section section in the man man?
12:10:26 <rien> ReinH: as a programmer I'm trying to save other people's time not give them errands like "hey I'm going to say thing(4) instead of 'man 4 thing' just so I give you an errand" :P
12:10:43 <rien> ReinH: lol I use "awful" OSX too
12:11:52 <ReinH> I prefer when people say x + y rather than defining the peano axioms and defining addition via induction every time. You have to learn the language you have to learn to be fluent.
12:11:54 <rien> ReinH: do you use the Haskell Platform? I've seen people recommend against it for "advanced usage" (read, fewer issues)
12:12:01 <ReinH> I don't.
12:12:26 <ReinH> Er, line editing failure. "You have to learn the language if you want to be fluent."
12:12:32 <rien> ReinH: Ok, that's a fair point. Honest question: where do I go to learn *all* about handling these package problems? not just cabal, package problems at all, when I'm compiling whatever on unix.
12:13:01 <ReinH> rien: Honestly, I understand your frustration. There's a lot of hidden knowledge. But it also isn't fair to say man pages useless...
12:13:03 <rien> ReinH: I saw experts here mentioning "ld" etc I have only a faint memory of what those do but don't know the book to read to learn that
12:13:07 <ReinH> *are useless
12:13:20 <ReinH> man ld :D
12:13:35 <bitemyapp> ReinH: my manpage manpage is boring, I'm on Mac OS X.
12:13:36 <ReinH> If explaining things well is a good skill for programmers, so is finding explanations for things.
12:13:37 <rien> ReinH: thank you. I know it's not useless. thanks for being patient and understanding. I don't mean to be rude to you :)
12:13:42 <ReinH> bitemyapp: indeed :)
12:13:58 <dcoutts> rien: you don't need to know about ld, but then I didn't think you'd need to know about strip.
12:14:01 <rien> ReinH: I can tell you I've always been good at learning things except for compiling stuff on unix lol
12:14:26 <ReinH> man ld: "The ld command combines several object files and libraries, resolves references, and produces an ouput file."
12:14:28 <rien> dcoutts: I think I *want* to know about ld and even deeper so that I have tools to deal with problems when they arise
12:14:38 <ReinH> Now, you might not know what "object files" are, for example, but at least now you have a new question to ask.
12:15:10 <ReinH> rien: likewise :)
12:15:17 <rien> ReinH: I understand all steps involved in compiling c files
12:15:17 <dcoutts> rien: ok, it's unnecessary to understand the Haskell layer, but you can certainly learn about the layer beneath which is the layer of C compiler, linkers, binutils etc.
12:15:25 <bitemyapp> I've been doing this for years, I still don't understand how linkers work.
12:15:26 <rien> ReinH: I just get really lost when make yells at me (or configure)
12:15:52 <bitemyapp> does anyone understand how linkers work? Does CompCert have a certified linker?
12:15:55 <ReinH> rien: The trick is to learn which parts you can safely ignore (about 90%) and which actually have something interesting :)
12:16:05 <ReinH> This is an acquired skill, and yes it isn't in the manual :)
12:16:21 <ReinH> bitemyapp: heh
12:16:34 <rien> ReinH: you nailed it. I gotta find those people and pick their brains.
12:16:37 <ReinH> bitemyapp: I learned a bit more about them when I went on my quest to make a fully static ghc binary recently.
12:16:55 <ReinH> rien: or compile a bunch of stuff and use your brain's built-in bayesian filter
12:16:59 <johnw> bitemyapp: when you lay out a function definition in object file, you put in holes where the addresses of the called functions will go, and a lookup table to say which named functions should be patched into which holes.  The linker links these definitions up together by filling in the hloes to produce an executable where every call instruction now has a specific address.  It only gets more complicated for shared libraries, because then
12:17:00 <johnw> it's an indirection through a table rather than a direct patch, but even then you're patching the function to point to the right place in the indirection table.
12:17:07 <rien> understanding how things work is easy, I want to learn *why* it *didn't*  ;) 
12:17:23 <bitemyapp> johnw: I knew that much, but I don't think I'd call that "understanding linkers"
12:17:31 <rien> ReinH: hmm that's a good idea for lack of better lerarning path.
12:17:33 <johnw> if you know that much, you can almost write a linker :)
12:17:43 <ReinH> rien: I suspect that's what most people do
12:17:58 <rien> bitemyapp: aren't linkers for old languages only?
12:18:05 <johnw> not at all
12:18:06 <ReinH> rien: yes, old languages like C :)
12:18:06 <bitemyapp> rien: is Haskell old?
12:18:16 <johnw> they are almost always needed for separate compilation, in one form or another
12:18:18 <ReinH> So fsvo "old", yes.
12:18:23 <rien> johnw: you mean it's like a page table?
12:18:25 <bitemyapp> early 90s / mid 80s
12:18:29 <bitemyapp> depending on how you count
12:18:34 <johnw> I'm not sure what a page table is
12:18:34 <rien> bitemyapp: it's compiled in an old langauge
12:18:39 <bitemyapp> I guess the cool kids compile to JS these days.
12:18:43 <bitemyapp> compiled in?
12:18:47 <ReinH> bitemyapp: which doesn't have linkers! :D :D
12:18:51 <rien> hahah
12:19:19 <bitemyapp> GHC is written in Haskell, RTS stuff is C, then some asm for the native codegen
12:19:19 <rien> johnw: virtual memory versus physical memory, the OS uses paging tables that are much like indirect references like you described
12:19:20 <ReinH> And btw it isn't the language, per se, that has a linker, but now I think I've crossed over the line of pedantry
12:19:22 <exio4> who needed linkers anyway
12:19:25 <bitemyapp> I'm not sure I'd call that being compiled in an old language.
12:19:37 <johnw> rien: oh, for the indirection tables, sure
12:19:45 <bitemyapp> rien: so you know how VM pages work but not manpages?
12:19:53 <ReinH> haha
12:19:55 <johnw> wow, caustic
12:20:01 <rien> johnw: yep that makes sense. your description is basically how paging files work
12:20:07 <bitemyapp> that may have sounded more caustic than I intended
12:20:12 <rien> bitemyapp: not VM pages these are real OS pages
12:20:16 <rien> lol
12:20:18 <bitemyapp> said with a smile, if that helps
12:20:24 <ReinH> johnw: knowing bitemyapp, I can imagine a non-caustic way he could have said that
12:20:26 <rien> bitemyapp: yes I caught it too late :)
12:20:46 <bitemyapp> well also the pages <---> pages thing made me smile
12:20:51 <ReinH> Usually when bitemyapp is caustic it's a lot more obvious...
12:20:59 <bitemyapp> ReinH: yep, lol.
12:21:18 <bitemyapp> ReinH: book's comin' out for early access soon.
12:21:19 <rien> good to know there's forgiveness to go around here then
12:21:24 <johnw> plenty of brand new languages use linkers
12:21:33 <rien> bitemyapp: you're writing a haskell book?
12:21:36 <ReinH> johnw: it really doesn't have anything to do with age, no.
12:21:38 <bitemyapp> rien: yep!
12:21:42 <ReinH> bitemyapp: yay!
12:21:42 <johnw> dynamic JIT compilation embeds its linking process
12:21:46 <bitemyapp> rien: http://haskellbook.com/
12:21:50 <ReinH> bitemyapp: when are you planning on asking me to TR it? :p
12:21:56 <bitemyapp> rien: my coauthor is somebody I taught Haskell - they'd never programmed before that.
12:21:57 <rien> bitemyapp: congrats first of all, can't wait to read it second of all
12:22:15 <johnw> any time that you produce machine code that has to be patched up later at call sites, you are effectively linking
12:22:18 <ReinH> bitemyapp: you know I really like that way. Eugenia Cheng wrote her higher-order categories book that way.
12:22:21 <bitemyapp> ReinH: probably when we hit something more technically interesting
12:22:25 <ReinH> And it's a good book.
12:22:27 <ReinH> bitemyapp: ok :)
12:22:33 <bitemyapp> ReinH: unless you want to review the chapter on the lambda calculus.
12:22:43 <ReinH> bitemyapp: heh, not really my thing :)
12:22:45 <bitemyapp> super simple, but we still could've made a mistake.
12:22:48 <bitemyapp> ReinH: yeah, figured :)
12:22:49 <ReinH> I prefer categories to lambdas :p
12:22:59 <ReinH> or categories of lambdas
12:23:09 <johnw> man category
12:23:11 <johnw> results not helpful
12:23:18 <rien> hahaha
12:23:26 <ReinH> man cat... not a cat.
12:23:34 <ReinH> disappointing.
12:23:44 <johnw> whiskers totally absent
12:23:48 <ReinH> Petition to add an ASCII art cat to the top of the cat manpage
12:23:55 <bitemyapp> ReinH: it's a book deisgned to get total beginners from zero to being able to write reasonably "real" Haskell code
12:24:06 <bitemyapp> ReinH: Monad transformers come up about 2/3s of the way in, if that gives you any idea.
12:24:06 <ReinH> bitemyapp: well, that's exactly what we're lacking, so
12:24:12 <bitemyapp> indeed ;_;
12:24:16 <bitemyapp> I will say this though
12:24:19 <ReinH> you better not screw it up :p
12:24:24 <bitemyapp> we are probably not going to write another beginner book after this
12:24:27 <ReinH> ha
12:24:33 <bitemyapp> unless this one has errata to be fixed or needs a new edition
12:24:39 <johnw> we'll just have the beginner book fallacy from then on
12:24:47 <bitemyapp> beginner book fallacy?
12:24:55 <johnw> n/m
12:25:02 <ReinH> bitemyapp: books like these only need new editions if they're textbooks and the author wants to exploit students :p
12:25:05 <rien> johnw: this is how I like to learn: http://195.144.20.131/VirtualMemoryUsage?action=AttachFile&do=get&target=MemoryUsage.png
12:25:10 <rien> ReinH: ^
12:25:26 <bitemyapp> ReinH: well, it's being written around 7.10
12:25:29 <johnw> rien: yeah, I like that too
12:25:30 <ReinH> I mean, a new edition in 5 years because the language has changed, maybe. Every year? o_O
12:25:30 <c_wraith> ReinH: except in the case of ghc haskell, where the language moves fast enough to leave texts very outdated sometimes.  look at what happened to RWH
12:25:37 <bitemyapp> ReinH: and I'm kinda persnickety about code examples "just working"
12:25:37 <johnw> a picture says 10^3 words
12:25:51 <ReinH> bitemyapp: see that's why I like living books, e.g. leanpub
12:25:54 <bitemyapp> ReinH: yeah what c_wraith said.
12:26:02 <bitemyapp> ReinH: it's living insofar as we're self-publishing
12:26:12 <bitemyapp> and can push out new versions of the ebook as we work.
12:26:14 <ReinH> c_wraith: I already gave that caveat :p
12:26:27 <bitemyapp> not working with leanpub though - we use LaTeX.
12:26:35 <ReinH> Yeah, that's the deal breaker with leanpub for me
12:26:47 <bitemyapp> ditto. I understand why it works the way it does
12:27:33 <c_wraith> bitemyapp: so will there be a repo for people to send contributions to whenever GHC changes break something?
12:27:35 <ReinH> Absolutely, it's great for people for whom markdown is a sufficient tool.
12:28:25 <bitemyapp> c_wraith: not initially.
12:28:39 <bitemyapp> c_wraith: we're considering open sourcing it later, but early on, no.
12:28:50 <bitemyapp> but part of the reason we went self-pub is so we'd have that option.
12:29:06 <c_wraith> bitemyapp: I was thinking you might do something like that, actually.  Open source it when you're tired of maintaining it manually.
12:29:12 * bitemyapp nods
12:29:19 <bitemyapp> well and PRs don't save that much labor with a book anyway
12:29:26 <bitemyapp> you have to edit and review everything regardless.
12:30:01 <bitemyapp> just being aware of problems is the valuable part. I'm figuring out how to setup a forum/mailing list for the early access people later tonight.
12:31:30 <bennofs> bitemyapp: just give people direct commit access :P http://felixge.de/2013/03/11/the-pull-request-hack.html 
12:37:24 <rien> bitemyapp: I'm sure you have more than your fair share of folks interested in helping with the book. I've helped review part of a Rails book before (Rails 3 in Action) so let me know if I can help.
12:38:56 <bitemyapp> rien: how much Haskell do you know?
12:39:56 <pchiusano> can any nix users explain this error I am seeing with my shell.nix file I'm trying to create for my project - https://gist.github.com/pchiusano/f52187f9bd5ff8ee028b
12:40:57 <rien> bitemyapp: I can explain and use monads, I understand monad stacks and the required lift order... it's hard to say in a room full of PhDs :P
12:41:23 <rien> bitemyapp: I'm approaching intermediate
12:42:17 <johnw> rien: that really depends on what their PhD is in
12:43:13 * hackagebot file-collection 0.1.0.0 - Provide a uniform interface over file archives and directories  http://hackage.haskell.org/package/file-collection-0.1.0.0 (joel_williamson)
12:43:36 <rien> fair enough. I'm comfortable with many concepts Haskell uses (haven't looked into arrows yet but saw some Yampa code and it looked not complicated) but I haven't coded that much in it yet.
12:43:36 <bitemyapp> rien: I'd have to think about it. We're not to that part yet.
12:44:00 <rien> bitemyapp: please, it's your book, no problem. :)
12:46:38 <ReinH> johnw: my "room" is full of maths PhDs... :)
12:46:51 <johnw> pchiusano: add --show-trace
12:47:08 <gremble> One day I hope to be a math PhD :P
12:47:30 <bennofs> pchiusano: you need to write cabal.mkDerivation (self: { ...  instead of cabal.mkDerivation { ...
12:47:44 <bennofs> and a closing paren ')' at the end too ofc
12:47:47 <johnw> good catch, bennofs
12:48:14 * hackagebot file-collection 0.1.0.1 - Provide a uniform interface over file archives and directories  http://hackage.haskell.org/package/file-collection-0.1.0.1 (joel_williamson)
12:48:34 <sinelaw> this is a first for me. linker error!
12:48:59 <sinelaw> why does this happen?
12:49:05 <sinelaw> dist/build/libHSinfernu-0.0.0.1-IIxoMFT7mG0C6xTwYjUxQy.a(String.o):(.data+0x2c8): undefined reference to `inferzuIIxoMFT7mG0C6xTwYjUxQy_InfernuziBuiltinsziUtil_number1_closure'
12:49:25 <bennofs> sinelaw: did you try cabal clean and then build again?
12:49:33 <sinelaw> bennofs, of course
12:49:42 <sinelaw> trying again...
12:49:59 <bennofs> sinelaw: are all you modules listed correct in exposed-modules, other-modules etc?
12:49:59 <pchiusano> bennofs: can you explain? also nix-shell now tells me error: expression does not evaluate to a derivation (or a set or list of those)
12:50:09 <sinelaw> bennofs, oh right
12:50:29 <pchiusano> i understand blah : … defines a function in nix
12:50:47 <sinelaw> bennofs, thanks, that was it
12:51:28 <bennofs> pchiusano: hmm, that "expression does not evelúate to a derivation" error is weird...
12:52:10 <pchiusano> bennofs: from the docs it sounds like nix-shell requires a derivation
12:52:42 <bennofs> pchiusano: yes, but normally, it also works for any function which takes a set where all set arguments have default values (such as { x ? defaultValue }: ...)
12:54:05 <pchiusano> bennofs: how will it know that the `self` param in `self : cabal.mkDerivation { … }` is a set?
12:54:22 <pchiusano> self is not even referenced anywhere in the body
12:54:31 <bennofs> pchiusano: oh, I didn't mean self: cabal.mkDerivation, but cabal.mkDerivation (self: ...) instead
12:54:42 <bennofs> pchiusano: cabal.mkDerivation expects a function as an argument
12:55:10 <linkages> os there a way to have this result ? Es i have ([1],[2]) i want to add ([2],[3]) to the tuple  and get ([1,2][2,3])
12:55:51 <kadoban> linkages: Typo in that last bit? Otherwise I'm not really sure what that means.
12:55:52 <bennofs> linkages: use mappend, from the Monoid instance for (a,b) and [a]
12:56:16 <bennofs> > ([1], [2]) `mappend` ([2], [3]) 
12:56:18 <lambdabot>  ([1,2],[2,3])
12:56:38 <linkages> a ok i think i got it .. thank you guys
12:56:45 <bennofs> > ([1], [2]) `mappend` ([2], [3]) 
12:56:47 <lambdabot>  ([1,2],[2,3])
12:57:01 <bennofs> > (a, b) `mappend` (c, d) -- <> is just `mappend`
12:57:02 <lambdabot>  (a <> c,b <> d)
12:57:07 <pchiusano> bennofs: ah okay that makes sense
12:57:13 <linkages> yes
12:57:19 <pchiusano> though now it is complaining it cannot find stdenv
12:57:33 <ReinH> This is a nice example of the fact that the product of two monoids is a monoid.
12:58:27 <bennofs> pchiusano: you could replace license with license = "";
12:58:47 <pchiusano> heh
12:59:13 <pchiusano> what is the proper way to import stdenv though, assuming i wanted to do that
13:00:25 <bennofs> pchiusano: (import <nixpkgs> {}).stdenv
13:01:14 <pchiusano> bennofs: could I also do { stdev ? (import <nixpkgs> {}).stdenv, haskellPackages ? (import <nixpkgs> {}).haskellPackages }: at the top
13:01:48 <bennofs> pchiusano: yes. You could even do: { pkgs ? (import <nixpkgs> {}), haskellPackages ? pkgs.haskellPackages } and then use pkgs.stdenv instead of stdenv
13:03:41 <pchiusano> bennofs: ah, so previous attributes are in scope for later ones, kinda odd but ok
13:03:55 <bennofs> pchiusano: I think it is recursive, order does not matter
13:04:08 <bennofs> (just like haskell's let expression)
13:05:34 <bennofs> hmm, need to go now. If you need further help, there is also the #nixos channel
13:05:46 <pchiusano> bennofs: thanks so much for your help!
13:11:07 <JagaJaga> How can I do smth like `case a of "a" | "b" -> foo`
13:11:11 <JagaJaga> ?
13:11:55 <bergmark> JagaJaga:  as in "a" or "b"?
13:12:04 <JagaJaga> bergmark: yes
13:12:07 <pchiusano> JagaJaga: case a of _ | a == "a" || a == "b" -> .. ?
13:12:30 <JagaJaga> pchiusano: oh, guards, nice! Thank you.
13:12:34 <bergmark> JagaJaga: or case a of "a" -> x \n "b" -> x \n where x = ...
13:13:10 <ion> bergmark: You can use ; when onelining.
13:13:20 <pchiusano> JagaJaga: you can also factor the body out into a function
13:13:34 <pchiusano> case a of "a" -> body p1 p2
13:13:35 <ion> case a of { "a" -> foo; "b" -> foo } where { ... }
13:13:57 <pchiusano> right, what ion said :)
13:14:20 <pchiusano> i think that is nicer than using guards
13:14:31 <ion> I was only pointing out the {;} syntax, bergmark pointed out that way of doing it.
13:14:46 <pchiusano> ah, right
13:15:07 <mizu_no_oto> pchiusano: going to Boston Haskell tomorrow?
13:15:15 <pchiusano> mizu_no_oto: definitely
13:15:28 <mizu_no_oto> See you there, then!
13:15:41 <JagaJaga> pchiusano: thanks once again :)
13:15:53 <pchiusano> mizu_no_oto: cool, you too
13:16:33 <pchiusano> sure
13:18:15 * hackagebot file-collection 0.1.0.2 - Provide a uniform interface over file archives and directories  http://hackage.haskell.org/package/file-collection-0.1.0.2 (joel_williamson)
13:23:15 * hackagebot byline 0.1.0.0 - Library for creating command-line interfaces (colors, menus, etc.)  http://hackage.haskell.org/package/byline-0.1.0.0 (PeterJones)
13:26:37 <quchen> jaspervdj: ping
13:28:16 * hackagebot file-collection 0.1.0.3 - Provide a uniform interface over file archives and directories  http://hackage.haskell.org/package/file-collection-0.1.0.3 (joel_williamson)
13:28:26 <anoe> Hello, howto iterate on a function with multiple parameters ?
13:28:44 <ttt_fff> (for learning, not production): how do I go from understanding algorithm W (hidlney-milner type inference) to adding in typeclasses ?
13:29:30 <quchen> anoe: You could just iterate a function that takes a tuple as an argument
13:29:53 <quchen> > take 10 $ iterate (\(x,y) -> (x+1, y*2)) (1,1)
13:29:55 <lambdabot>  [(1,1),(2,2),(3,4),(4,8),(5,16),(6,32),(7,64),(8,128),(9,256),(10,512)]
13:30:16 <anoe> quchen: ok thanks
13:31:51 <ReinH> :t iterate
13:31:52 <lambdabot> (a -> a) -> a -> [a]
13:32:20 <ReinH> Note that the function provided to iterate can't change the type, so you are restricted to functions that result in tuples as well
13:33:01 <anoe> ReinH: ok thx
13:34:01 <ReinH> (tuples of the same type as the one given, as well)
13:37:48 <Hijiri> > (0.1 + 0.1 + 0.1 , 0.1 + 0.1 + 0.1) :: (Float, Double)
13:37:49 <lambdabot>  (0.3,0.30000000000000004)
13:37:54 <Hijiri> Float is more accurate!
13:39:06 <ion> QED
13:39:46 <JagaJaga> Hijiri: ....
13:40:17 <gremble> Why does float fuck up?
13:40:33 <jophish> is Jake McArthur here?
13:41:37 <osa1> does anyone have any ideas about this error message: "cabal: Use of GHC's environment variable GHC_PACKAGE_PATH is incompatible with Cabal. Use the flag --package-db to specify a package database (it can be used multiple times)."
13:42:28 <kadoban> osa1: Sounds pretty self-explanatory?
13:42:35 <geekosaur> what it says. you have GHC_PACKAGE_PATH set already, but cabal uses it to tell ghc about the sandbox
13:42:47 <osa1> it's set by cabal...
13:42:48 <geekosaur> and tell ghc *not* to look in the user package db
13:43:32 <osa1> is cabal 1.22 incompatible with ghc 7.10? because this is done by cabal, I'm not setting that manually
13:43:43 <a[0]> is there a name for (flip (<$>))?
13:44:05 <dolio> a[0]: (<&>)
13:44:08 <dolio> In lens.
13:44:13 <kaiyin> https://gist.github.com/kindlychung/4745feeaec628cc8cda1 what does this cost function actually mean? 
13:44:27 <kaiyin> ah, sorry, wrong channel. 
13:44:43 <geekosaur> I was wondering why you were asking abotu clojure...
13:45:29 <JagaJaga> I have big log file. Via terminal I can do `cat | grep | sed` and achieve what I need. What's the best way of doing such thing in haskell?
13:46:01 <quchen> Syscall to cat | grep | sed
13:46:05 <kaiyin> hehe, blatant blasphemy. :-P
13:46:51 <soud> Hi, I'm trying to create a function that returns the response of a HTTP request as a String, but it raises the error 'No instance for (Control.Monad.IO.Class.MonadIO [])'. It works when I make its return type IO and print it inside the function instead of main. My code: https://bpaste.net/show/3b5b89744b4b
13:47:05 <JagaJaga> quchen: really good way? :)
13:47:30 <c_wraith> soud: somewhere along the way, you're trying to put a String on the right side of a <- in an IO block
13:47:37 <c_wraith> soud: you probably should be using a let instead
13:47:55 <soud> c_wraith: ah it doesn't like that
13:47:59 <soud> that's so ugly ;<
13:48:17 <quchen> JagaJaga: Using Pipes you could write an analogous program, given suitable regex (or matching) engines. But that would require much more work, since I don't think there is such a library already. I think it's fine to make calls to standard programs from withing Haskell to achieve certain goals. You can still use Haskell as the glue in your script, of course.
13:48:54 <Tuplanolla> There's Data.Text.IO for most of that, JagaJaga. The rest depends on what you do with sed.
13:50:20 <JagaJaga> Tuplanolla: emm, how can I use Data.Text.IO for that?
13:51:14 <Tuplanolla> First you readFile, then splitOn line breaks, filter some of them and finally parse each or such. All of that can be lazy.
13:51:40 <JagaJaga> Tuplanolla: that's what I need!
13:51:48 <geekosaur> wait, what? it's String -> String, it can't use simpleHttp
13:51:54 <geekosaur> String -> IO String, it could
13:52:12 <geekosaur> except you need to fmap L.unpack over it
13:53:03 <Tuplanolla> If the parsing is intricate, you can even use Text.Parsec, which is way beyond sed, JagaJaga.
13:53:36 <JagaJaga> Tuplanolla: no, Text is what I need.
13:56:36 <michaelt> soud: fmap L.unpack (simpleHttp url) 
13:57:30 <soud> geekosaur: michaelt: yup figured it out, thanks all
13:58:17 <michaelt> soud, you don't need all of Network.HTTP.Conduit for this 
13:58:35 <soud> michaelt: yeah I should probably only import simpleHttp
13:59:31 <michaelt> soud: I mean, you can use http-client, which is what http-conduit is using.  just a sec.
14:01:58 <michaelt> soud: like so, for what it's worth http://lpaste.net/132955
14:03:03 <soud> michaelt: ah I see, thanks
14:04:57 <soud> thats a ton faster too
14:05:05 <xj54y> Hello... 
14:05:31 <xj54y> Often when I google something, haskell pops up. Hopefully it's okay if I ask questions here.. 
14:05:55 <xj54y> (I don't know haskell, nor really care to do so at the moment, but it seems many who work on haskell may know the math(y) stuff)
14:06:40 <Tuplanolla> Haskell being particularly mathematical is a common misconception, xj54y.
14:06:53 <a[0]> dolio: I can't find <&>, where is documentation on this?
14:06:59 <michaelt> xj54y: I think we are constrained by our topic.
14:06:59 <a[0]> https://github.com/ekmett/lens/wiki/Operators doesn't have it
14:07:07 <xj54y> Tuplanolla, misconception of what, the google results I get back? I'd have to strongly disagree
14:07:14 <Hijiri> a[0]: https://hackage.haskell.org/package/lens-4.11/docs/Control-Lens-Lens.html#v:-60--38--62-
14:07:18 <michaelt> a[0]: Data.Functor, I think
14:07:25 <a[0]> ah
14:07:31 <Hijiri> didn't know it was in Data.Functor
14:07:32 <michaelt> woops, ignore me
14:07:41 <Hijiri> or maybe it isn't I don't know
14:07:46 <Denommus> xj54y: what do you mean by mathy? What do you want to know about?
14:08:31 <Denommus> xj54y: Haskell is not really much more mathematical than any other programming language, it's just that the language designers noticed some general abstractions over some types
14:08:37 <xj54y> Denommus, Generally, category theory.. right now, i'm not looking to know anything in particular, but I'm sure something will arise shortly
14:09:40 <arbelos> Is there a rule-of-thumb for how many arguments a function should take before it gets .. ridiculous?
14:09:46 <Denommus> xj54y: I wouldn't recommend you to learn Category Theory from Haskell. Haskell only has use limited versions of some of their abstractions (for instance, what Haskell calls functor is actually an endofunctor)
14:10:05 <Denommus> arbelos: every function takes only one parameter anyway :-D
14:10:31 <Tuplanolla> Haskell doesn't enforce properties like the monad laws either, xj54y.
14:10:37 <michaelt> xj54y: the types form a category, and functions between them are the arrows; what we usually call Functor is a functor from the type system to itself, though there are other conceptions around
14:10:37 <arbelos> Denommus, yes at the conceptual level
14:11:15 <Denommus> xj54y: I personally don't know much about category theory or type theory, even though I know Haskell
14:11:15 <xj54y> Denommus, I think i've miscommunicated. I'm working on other stuff and when I google something particularly related to the problems I'm working on, Haskell pops up with profound relevance 
14:11:28 <ReinH> xj54y: what are you working on?
14:11:33 <arbelos> Denommus, I was talking more in terms of program design and readability than from a purely theoretical perspective
14:11:55 <michaelt> > (1, succ 1, [1..10], fmap succ [1..10])
14:11:57 <lambdabot>  (1,2,[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10,11])
14:12:12 <Denommus> arbelos: I don't know, I don't think there's such a thing as too much parameters, because you could always curry
14:12:30 <Denommus> arbelos: but most real-world functions and up accepting at most 5 parameters, I guess
14:12:38 <Hijiri> I think like 15 configuration parameters would be too much
14:12:46 <Hijiri> then you would put them in a config type or something
14:12:55 <arbelos> ok, yeah I was thinking along those lines as well
14:13:00 <ReinH> Denommus: that almost seems to imply that there's such a thing as too many parameters
14:13:01 <arbelos> 5 is fair I would say
14:13:02 <xj54y> ReinH, topics in automatic proof theory, etc.. Nothing interesting
14:13:20 <arbelos> 15 is definitely too much
14:14:50 <xj54y> michaelt, I like that. Any specific books/papers I should read to know these concepts in and out? Could be very helpful :-)
14:14:59 <xj54y> Perhaps a motivational factor to play with haskell! :D
14:16:18 <michaelt> xj54y: it used to be that the go to tutorial was http://learnyouahaskell.com/chapters but people seem to be down on it lately ...
14:17:04 <xj54y> michaelt, eh, I mean the programming language theory, etc.. Not so much haskell itself (unless it contains them both? :o)
14:17:29 <Tuplanolla> I'd recommend Software Foundations, xj54y.
14:17:40 <arbelos> michaelt, why? because of lack of exercises or?
14:17:57 <michaelt> arbelos: dunno, just noticed people running it down.
14:18:42 <xj54y> Tuplanolla, Hehe... This book is opened already.. :-)
14:19:00 <a[0]> so it looks like >>> and <&> behave the same way for function arguments?
14:19:42 <kadoban> The most obvious lack in LYAH is exercises, for a full critique that sounds correct to me: http://bitemyapp.com/posts/2014-12-31-functional-education.html#learn-you-a-haskell
14:19:45 <Hijiri> a[0]: yes
14:19:48 <Hijiri> they are both flip (.)
14:19:56 <Hijiri> (or equivalent to)
14:20:22 <a[0]> right, but <&> is more general
14:20:26 <a[0]> > ((Just 2) <&> show)
14:20:28 <lambdabot>  Just "2"
14:20:29 <michaelt> bah all that coq in 'software foundations' 
14:20:53 <xj54y> michaelt, Coq is all kinds of fun. Highly recommended! :-D
14:21:06 <michaelt> “Using Coq is like doing brain surgery over the telephone.” – Peter Hancock
14:21:11 <xj54y> (mostly what I'm working with now)
14:21:41 <xj54y> Hmm, interesting.. It's helpful of course, probably cheaper too! :o
14:22:08 <schell> lyah is one of my favorites
14:22:20 <Hijiri> a[0]: I just meant in the context of functions
14:22:31 <a[0]> yep
14:22:42 <a[0]> is there stuff >>> can do that <&> can't?
14:22:58 <kadoban> :t (<&>)
14:23:00 <lambdabot> Functor f => f a -> (a -> b) -> f b
14:23:38 <kadoban> :t (>>>)
14:23:39 <michaelt> oh you want a 'reversed' composition a[0] 
14:23:39 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
14:23:43 <xj54y> The the context is functional symmetry and invertibility, how best would you describe a hereditary closure?
14:23:48 <xj54y> In the*
14:24:20 <a[0]> yes, but I'm interested that <&> works like fmap in that you can use it with Maybe as well. I don't know enough about Category and Functor to understand the differences beyond that >>> doesn't work for Maybe
14:24:49 <Hijiri> >>> can map things that aren't functions
14:25:00 <Hijiri> <&> can only map functions onto things
14:25:20 <exio4> isn't (<&>) just flip fmap, or are we talking about a different <&>? 
14:25:25 <Hijiri> it's flip fmap
14:26:19 <kuribas> Does cabal provide for conditional compilation based on installed dependencies?
14:30:16 <maerwald> kuribas: that is bad style, you should use flags
14:30:43 <kuribas> maerwald: That's true.  Does cabal allow for that?
14:31:05 <dcoutts> kuribas: yes, see the cabal user guide
14:31:13 <kuribas> ok, thanks, I will.
14:31:33 <a[0]> would it be accurate to say <&> is a special case of >>> ?
14:31:55 <dcoutts> kuribas: it's sort-of "conditional compilation based on installed dependencies" except carefully arranged so that the person building the package gets the final say, rather than the package author
14:32:13 <kadoban> a[0]: I don't think so. The only real connection they have that I see is that they're the same in the instance of Functor for functions and Category for functions
14:32:14 <dcoutts> kuribas: designed based on the experience of distro maintainers
14:33:17 <kuribas> I am a bit reluctant to include large dependencies in my package just for another small feature.
14:34:18 <arkeet> a[0]: they are both generalizations of the same thing (namely, function composition)
14:34:22 <arkeet> but they generalize in different ways
14:35:03 <Denommus> :t (<&>)
14:35:05 <lambdabot> Functor f => f a -> (a -> b) -> f b
14:35:11 <Denommus> :t (>>>)
14:35:12 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
14:35:33 <ReinH> I'm glad Category is higher kinded now
14:35:54 <Denommus> what... am I looking at?
14:35:56 <kadoban> There sure is a lot of stuff at the beginning of that that I don't understand what it means.
14:36:21 <ReinH> It's saying that the types a,b,c can be of higher kinds, as long as the kinds match
14:37:49 <Denommus> ReinH: so I can have (Monad m, Functor f, Category cat) => cat m f passed to (>>>)?
14:38:07 <Denommus> I wonder how that could be expressed with ML modules........
14:38:50 <arkeet> (>>>) :: Category cat => cat a b -> cat b c -> cat a c
14:38:52 <arkeet> that's the important part
14:39:04 <Denommus> arkeet: I am aware
14:39:12 <arkeet> k
14:40:54 <exio4> Denommus: you can also have things like https://hackage.haskell.org/package/constraints-0.4.1.3/docs/Data-Constraint.html
14:42:18 <Denommus> exio4: cool
14:42:58 <GLM> Hijiri: What is the purpose of flip?
14:43:20 <Hijiri> it switches the arguments of a function that you can apply to two or more arguments
14:43:23 <Hijiri> :t flip
14:43:25 <lambdabot> (a -> b -> c) -> b -> a -> c
14:43:29 <exio4> Denommus: I think you might like http://www.stephendiehl.com/posts/monads.html 
14:43:45 <Hijiri> > ((-) 5 1, flip (-) 5 1)
14:43:48 <lambdabot>  (4,-4)
14:44:01 <GLM> Hijiri: I understand what it does. It isn't clear why I'd want to do that
14:44:13 <Hijiri> it's useful when using higher order functions
14:44:15 <Denommus> GLM: sometimes you want to pass a functor to another function, right?
14:44:24 <Hijiri> for instance, if I want to subtract 2 from [1,2,76]
14:44:31 <GLM> Sure
14:44:34 <Hijiri> I can do map (flip (-) 2) [1,2,76]
14:44:34 <Denommus> GLM: and sometimes you want to apply an argument for a function before applying it
14:44:43 <Denommus> GLM: *before passing it
14:44:55 <Tuplanolla> One common use case is to flip elem.
14:44:56 <Denommus> GLM: and sometimes the argument you want to pass is not the first one
14:44:57 <Tuplanolla> :t elem
14:44:59 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
14:45:01 <GLM> Hijiri: Thanks. That makes more sense. Order dependent operations that you can't manually rearrange
14:45:25 <arkeet> often one writes (`f` x) instead of flip f x, though
14:45:29 <arkeet> where e.g. f is elem
14:45:44 <ion> > flip runState 42 $ do { modify (+1); get }
14:45:47 <lambdabot>  (43,43)
14:45:52 <arkeet> or subtract 2 instead of flip (-) 2
14:45:59 <GLM> Denommus: That still seems a bit contrived but I'll take it
14:46:15 <Denommus> GLM: you know how currying works in Haskell?
14:46:35 <GLM> Denommus: Yeah
14:47:00 <ion> > flip map [0..] {- imagine a simple list and a multi-line function here, represented by the (+1) -} (+1)
14:47:02 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:47:09 <napping> GLM: It's not that you often want flip, but that flip is a standard name if you want it
14:47:21 <napping> you could always just write (\x y -> f x y) instead of (flip f)
14:47:50 <napping> and yeah, you usually want it in the context of higher order functions, where the flipped version can be curried
14:48:33 <Denommus> napping: f y x
14:48:33 <Denommus> :t flip map [0..]
14:48:35 <lambdabot> (Enum a, Num a) => (a -> b) -> [b]
14:49:17 <napping> right, (\x y -> f y x)
14:49:27 <michaelt> > uncurry (flip (,)) (1,"hi")
14:49:29 <lambdabot>  ("hi",1)
14:49:33 <GLM> I think that makes more sense. It is just to be prettier than having massive functions on the wrong side
14:51:39 <GLM> > (flip (,)) (1,"hi")
14:51:41 <lambdabot>      No instance for (Typeable a0)
14:51:41 <lambdabot>        arising from a use of ‘show_M23116811358328400663282’
14:51:41 <lambdabot>      In the expression:
14:52:24 <ion> > flip (,) 1 "hi"
14:52:26 <lambdabot>  ("hi",1)
14:52:29 <dino-> an exercise that I had a lot of frustration over at first, and then later excitement with, was trying to work out why (flip id) has the type it does
14:53:22 <Lokathor> :t flip id
14:53:24 <lambdabot> b -> (b -> c) -> c
14:53:26 <GLM> ion: If those had the same output, what was the purpose of uncurry?
14:54:20 <Pamelloes> If I have a type data MyType m = forall a. (PolyType a -> m Type), is there a way to create a function MyType -> PolyType a -> m Type?
14:54:22 <ion> GLM: They had different input.
14:54:41 <Denommus> I also like flip undefined
14:54:44 <Denommus> :t flip undefined
14:54:46 <lambdabot> b -> a -> c
14:55:36 <joelteon> hi, in cabal's Setup.hs, how do I get the user-configured path to a program?
14:55:39 <kirill``> Is there a way to find out the current OS thread inside IO?
14:56:58 <dino-> joelteon: Do you mean where the configure step has set the directory for installing binaries when cabal install is invoked?
14:57:02 <napping> kirill``: that's not necessarily fixed.
14:57:28 <napping> I think GHC.Conc.threadCapability is close
14:57:28 <joelteon> dino-: well, when the configure step has set, say, --with-hpc or something like that
14:57:30 <kirill``> napping: Yeah, but it's for debugging a program that uses Qt, so all my code gets called from this opaque C++ framework
14:57:31 <joelteon> how do I get that
14:57:42 <napping> kirill``: Have you read the papers on that part of the runtime?
14:57:55 <napping> IIRC, those calls will end up in a bound thread
14:58:41 <kirill``> No, what papers? 
14:58:46 <tnks> 3₱
14:59:00 <dino-> joelteon: I see, I'm not sure how to get that programmatically
14:59:07 <napping> http://research.microsoft.com/apps/pubs/default.aspx?id=67424
14:59:09 <napping> that's one of them
14:59:23 <joelteon> haha
14:59:26 <joelteon> seriously
14:59:45 <napping> Your Haskell code doesn't even necessarily execute on the bound thread, but it makes sure to run native code in the right place
15:01:22 <kirill``> napping: I'm not sure what "the right place" means in the context of Qt, which I'm not too familiar with.
15:02:02 <napping> kirill``: A bound thread makes sure to run foreign calls on a particular OS thread
15:02:32 <napping> I think it executes the actual Haskell code on whatever thread is handy
15:04:53 <kirill``> I'm not sure I follow. When Haskell code is called from C++, are you saying it is/isn't guaranteed to be executed on that same thread? For me there's an OpenGL context bound in that thread, and I haven't had any OpenGL problems, so just assumed that it was executed on the same thread.
15:06:34 <napping> kirill``: it's a bit more subtle than that. If Haskell code is called from C++, and calls back out to C++, that's guaranteed to happen on the same thread
15:08:33 <napping> The actuall Haskell code might run elsewhere, depending on stuff
15:09:52 <kirill``> But then it knows to switch to the original thread when calling an OpenGL function?
15:10:01 <napping> Yeah
15:10:23 <napping> oh, being fixed to a capability isn't the same as bound thread anyway
15:10:48 <kirill``> So finding out OS thread inside IO isn't actually helpful
15:10:50 <joelteon> ok, how do I get the LocalBuildInfo in a hook?
15:11:06 <napping> The number of "capabilities" is maximum number of threads that can execute Haskell code at once
15:11:23 <napping> but there's some funny business about hanging onto threads that called into Haskell
15:11:33 <napping> and maybe the capabilities can use different OS threads as they go
15:11:56 <napping> kirill``: you should be able to find out if your Haskell thread is bound (which it will be), and maybe what thread it's bound to
15:12:09 <lilred> hi all, I´m trying to write a monad for managing a single resource, but I´m stuck on the return implementation
15:12:11 <napping> if nothing else, making a foreign call to C code that checks the thread will tell you what you want to know
15:13:05 <napping> ah, GHC.Prim.isCurrentThreadBound# may be interesting
15:13:36 <napping> oh, exposed as isCurrentThreadBound
15:14:45 <napping> Maybe I'm wrong about where it stuff runs, the Control.Concurrent documentation seems to suggest a bound thread will always run on that OS thread
15:15:24 <kirill``> Hm, it tells me it's bound, and the thread id of myThreadId is different every time it gets called.
15:15:36 <napping> sure
15:15:48 <napping> but try something like calling to pthread_self
15:15:59 <napping> The paper actually explains stuff decently
15:16:06 <napping> but basically you'll get a fresh Haskell thread
15:16:18 <napping> but all bound to the OS thread that called in
15:16:38 <Pamelloes> If I have a type data MyType a = forall b. MyType (b -> a), is there a where to take a "b" and a "MyType a" and get an "a"?
15:16:38 <napping> Leaving aside the bound thread stuff, you'll have about as many OS threads as you have capabilities
15:16:49 <napping> and Haskell threads are managed on top of that, so a ThreadId has little to do with OS threads
15:17:04 <arkeet> Pamelloes: nope
15:17:07 <napping> The GHC runtime keeps it's own run queue and stuff
15:17:34 <Pamelloes> arkeet: No way at all?
15:17:53 <napping> kirill``: and it's the capability object itself that has the Haskell stuff like owning bits of the heap
15:17:55 <arkeet> there's no way to know what type you stuck in the existential
15:18:04 <napping> so any OS thread can be running Haskell code, if it owns one of the capabilities
15:18:37 <napping> and when a foreign call into Haskell happens, the RTS hangs on to that OS thread, and remembers an association between that thread and the newly-created Haskell ThreadId
15:18:39 <arkeet> if you have a value of type MyType a, you know it contains some b -> a for *some* b
15:18:47 <arkeet> but you know nothing about b
15:18:53 <napping> and makes sure that at the very least foreign calls from your new Haskell thread are executed on the bound threads
15:19:10 <Pamelloes> arkeet: Is there a way to redefine MyType a so that I know it contains some b -> a for all b?
15:19:10 <arkeet> other than that it exists
15:19:18 <napping> I'm not sure if it actually runs your compiled Haskell code on that thread
15:19:27 <arkeet> that would be data MyType a = MyType (forall b. b -> a)
15:19:31 <napping> although I guess an unsafe foreign call probably requires that
15:19:56 <exio4> arkeet: no, that's not the right data type
15:20:00 <arkeet> but this is isn't terribly useful, since the only functions you can use for that are constant functions.
15:20:06 <exio4> you want data MyType a = forall b. MyType (b -> a)
15:20:07 <napping> kirill``: in short, make a foreign call out to pthread_self or equivalent, and you'll see what you need to see
15:20:28 <exio4> (this is also why I prefer GADT syntax when playing with existentials)
15:20:38 <arkeet> exio4: I know which is which.
15:20:47 <exio4> data MyType a where MyType :: (b -> a) -> MyType a 
15:21:01 <exio4> gr, nvm
15:21:16 <exio4> I read you wrong
15:21:57 <kirill``> napping: That makes sense, thank you for your help
15:21:58 <kirill``> I can see pthread_self being the same on every call
15:22:10 <arkeet> well I guess my point is that both are rather useless
15:22:25 <napping> searching turns up a Qt "currentThread" function
15:22:30 <napping> maybe that's covered in your binding?
15:22:47 <napping> It's all explained a lot more clearly in that paper
15:22:57 <napping> unfortunately, I forget if there are some more recent adjustments
15:23:07 <Hasker_> Hey all, I'm wondering what a good way to get really comfortable with monads is. I've read LYHFGG, and feel like I have a pretty good grasp, but still not fully there. Are there any papers or tutorials that could lead me in the right direction?
15:24:16 <napping> kirill``: the user's guide mentions this paper, specifically on OS threads and the FFI: http://research.microsoft.com/en-us/um/people/simonpj/Papers/conc-ffi/index.htm
15:24:21 <hasker_> join #snapframework	
15:24:33 <hasker_> \join #snapframework
15:24:51 <bsmt> it's /join
15:24:52 <dmj`> hasker_: be able to write all the monad instances for common datatypes from memory, then begin to use them in real code
15:25:25 <hasker_> Hahaha thanks. And awesome thanks dmj
15:27:30 <kirill``> napping: I'm using hsqml, which seems to only support calling into Haskell code, but pthread_self seems to work.
15:27:30 <kirill``> Thanks very much for explaining.
15:30:07 <schell> hasker_: dmj` is right - i learned the most about monads by looking at monad implementations
15:31:05 <hasker_> schell: Thanks :) I will do that now. I'm trying to build a web backend in haskell and a frontend using reactjs so I've still got a ways to go.
15:31:25 <schell> hasker_: sounds like a fun project :)
15:32:01 <hasker_> schell: It will be once I understand how a monad inside a monad inside a monad works...
15:32:31 <dmj`> hasker_: you mean, how to understand transformers?
15:32:37 <schell> hasker_: ahh - there’s a chapter in Real World Haskell about monad transformers that i thought was pretty good
15:33:05 <schell> monads and monad transformers are slightly different concepts though - you’ll have to read about transformers specifically
15:33:20 <merijn> Transformers are best understood by implementing them yourself
15:33:27 <Pamelloes> Given a parameter (m a), how do I do something in the context of this parameter's monad?
15:33:35 <merijn> Pamelloes: You don't
15:33:51 <merijn> Pamelloes: The only way to do something "in the context" is to know exactly what type it is
15:33:58 <merijn> Pamelloes: And then use functions for that type
15:34:29 <hasker_> Yeah transformers sound like what I'm trying
15:34:37 <merijn> hasker_: Good practice for transformers is to first implement State and then attempt to generalise to StateT
15:34:44 <Pamelloes> merijn: Hm, I guess that makes sense
15:34:51 <merijn> hasker_: I wrote down the homework, you just need to fill in the undefined's: https://gist.github.com/merijn/098106abd45c940dab09
15:35:12 <hasker_> awesome. I'm reading it now
15:35:54 <kern_chicken_pan> good morning all
15:36:10 <hasker_> Also, I'm sure this is a common confusion, but how does getStrLn work if it doesn't modify the world state
15:36:47 <hasker_> You input state and get back an IO monad, but how is this a function without side effects? It still confuses me
15:37:07 <napping> No side effects happen to give you the IO String
15:37:26 <maerwald> hasker_: type IO a = RealWord -> (RealWorld, a) 
15:37:29 <maerwald> something like that
15:37:32 <maerwald> not exactly but...
15:37:34 <merijn> maerwald: No, bad!
15:37:43 <merijn> RealWorld is a terrible analogy!
15:37:46 <exio4> who cares about the implementation of IO 
15:37:55 <exio4> it's an abstract type for a reason
15:37:56 <schell> what package is getStrLn in?
15:37:58 <dmj`> hasker_: anything in the I/O monad has the possibility of side effects. That means touching disk, reading from a socket, reading/writing to/from stdout,stderr. 
15:38:01 <napping> like, main = do let ignored = getStrLn >> getStrLn; putStrLn "Hello"
15:38:03 <jaspervdj> Quashie: pong
15:38:06 <jaspervdj> oops
15:38:06 <maerwald> merijn: I'm not sure how nitpicking on that helps
15:38:23 <merijn> hasker_: There's a few crucial insights
15:38:28 <joelteon> when hpc prints out "can not find Application in [...]", is it trying to find a mix/tix or a haskell source file?
15:38:29 <hasker_> Okay so it does have side effects potentially? Interesting
15:38:32 <dmj`> napping: in theory, but what if your function looked like f = putStrLn "foo" >> getLine, that type is still IO String, but it has a side effect
15:38:34 <merijn> hasker_: 1) "getLine :: IO String" is not a function
15:38:35 <napping> hasker_: if you wrote ignored `seq` (putStrLn "Hello") at the end, it wouldn't read the line
15:38:40 <maerwald> hasker_: no, there are no side effects
15:38:49 <napping> dmj`: What?
15:38:54 <napping> getStrLn has a side effect
15:39:06 <merijn> hasker_: Note that purity only says something about *functions*, i.e. a function is pure IFF it returns the same result for the same inputs
15:39:08 <napping> getLine, rather
15:39:10 <merijn> napping: No
15:39:17 <maerwald> hasker_: https://github.com/ghc/packages-ghc-prim/blob/ad9bf96815cb5a9bb4acc51c99eff20be3e50da3/GHC/Types.hs#L82
15:39:20 <merijn> napping: getLine has *effects* it doesn't have *side* effects
15:39:26 <napping> well, okay
15:39:31 <merijn> napping: getLine is just as pure as any other haskell value
15:39:32 <napping> but getLine has an effect
15:39:37 <arkeet> no
15:39:39 <arkeet> getLine *is* an effect
15:39:40 <arkeet> :-)
15:39:42 <napping> merijn: complain to dmj` 
15:39:53 <dmj`> napping: ?
15:40:07 <merijn> dmj`: You said side effect in your description of 'f'
15:40:08 <napping> dmj`: (putStrLn "Hi" >> getLine) and (getLine >> getLine) are equally pure
15:40:13 <hasker_> Weird okay
15:40:26 <dmj`> merijn: yes, putStrLn "foo" isn't a side effect?
15:40:37 <schell> arkeet: that’s a good distinction
15:40:47 <merijn> dmj`: No side-effects implies something is happening in a hidden/indirect way
15:40:50 <napping> dmj`: I mean putStrLn "foo" and getLine both have effects or whatever
15:40:58 <merijn> dmj`: putStrLn is an effect, since it explicitly does IO
15:41:27 <schell> merijn: wouldn’t putStrLn be a function that returns an effect, while putStrLn “foo” is an effect?
15:41:28 <merijn> hasker_: Insight number 2) you can think of IO as being a "program fragment" that when executed does something
15:41:29 <dmj`> merijn: in the example above of 'f' I provided, the putStrLn call is "hidden" since you can't tell the effect is happening from the type signature
15:41:34 <kadoban> napping: They have effects when executed. Not when they're evaluated.
15:41:35 <merijn> schell: Right
15:41:42 <Stratege> isn't the "main" effect of a function to return a value and everything else is a side effect?
15:41:46 <merijn> @quote /bin/ls
15:41:47 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
15:41:58 <merijn> hasker_: That quote is a nice analogy, I think
15:42:12 <Stratege> and the reason there's still no side effects in haskell is because of the whole thing kadoban mentioned.
15:42:15 <arkeet> IO actions are effects. you use >>= and whatnot to compose effects together, and eventually you have one big effect called main
15:42:19 <arkeet> that gets executed when your program is run
15:42:24 <hasker_> interesting okay makes sense
15:42:31 <merijn> hasker_: So "IO String" isn't "a string wrapped in IO" it's "a recipe to produce a String"
15:42:33 <napping> hasker_: something like x = printf doesn't have any side effects, even if printf("Hi") will print stuff
15:42:47 <napping> thinking now in C or Python or whatever
15:42:50 <merijn> hasker_: This explains how "putStrLn :: String -> IO ()" is a pure function
15:43:06 <merijn> hasker_: Because given the same input string, it will produce the same recipe for printing it
15:43:20 <merijn> hasker_: i.e. "putStrLn "foo"" returns a recipe for printing "foo"
15:43:35 <merijn> Same input, same output recipe == pure
15:44:00 <napping> It's just that Haskell organizes things so any impure code has a type mentioning IO, and there's no way to for an IO thing to be executed except by making it part of main
15:44:06 <merijn> hasker_: Now, of course just a recipe isn't very interesting, so we have an abstract interface to compose recipes
15:44:53 <merijn> hasker_: "IO a -> (a -> IO b) -> IO b", now this is generalised to be a monad, BUT this is not intrinsically relevant for IO. You could do IO without monads by simply having a "andThen" function with the same time
15:44:57 <merijn> s/time/type
15:45:28 <merijn> hasker_: Now there's one insight remaining, which is "can't we distinguish repeated execution of the same recipe returning different things"?
15:45:47 <Stratege> ^ you could even have a different type of chaining function for IO stuff, it doesn't need to be monadlike.
15:45:51 <merijn> hasker_: The answer is "no", because: There is no way to execute recipes in haskell
15:46:26 <joelteon> wow, wtf
15:46:30 <joelteon> i'm getting "bad line number" from hpc
15:46:35 <merijn> hasker_: Haskell is a pure language, whose evaluation can construct arbitrarily complex IO recipes, but you *cannot* execute those recipes *within* haskell, and therefore you cannot observe the difference between repeated execution in haskell
15:46:53 <joelteon> it's trying to cover a source file that uses hspec-discover
15:47:32 <hasker_> merijn: AHA, you can only distinguish between them OUTSIDE of the "haskell world"
15:47:43 <hasker_> merijn: This is fascinating. Thank you
15:47:53 <merijn> hasker_: Then you may wonder "well, how the hell does anything happen?" to which the answer is "haskell may not be able to execut IO recipes, but the (impurely implemented) runtime system *can*". This is why "main :: IO a" the main action is a single big IO recipe, constructed by pure haskell and executed by the runtime system
15:48:24 <merijn> In essence, you are writing a pure program producing an arbitrarily complex IO recipe that is to be run by the runtime system
15:48:48 <hasker_> Woah, that's an amazing explination
15:48:52 <hasker_> Thank you thank you thank you
15:49:20 <merijn> And now it's time for me to bow and head to bed :p
15:49:22 <hasker_> You're just writing the recipe, while the system (which isn't pure executes it). Is that a correct understanding?
15:49:34 <Stratege> which has some fun implications btw, see: http://blog.jle.im/entry/first-class-statements
15:49:36 <merijn> Pretty much
15:49:40 <hasker_> Sorry that sentence was weirdly phrased
15:50:45 <maerwald> hasker_: you might be interested in http://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps too, although it's fairly technical
15:51:13 <hasker_> maerwald: I don't mind technical. I love papers
15:51:22 <hasker_> Thanks for showing me
15:53:38 <dmj`> merijn: would you say 'f :: IO String; f = putStrLn "foo" >> getLine' is a 'side effecting' function?
15:54:04 <arkeet> it's not a function :-(
15:54:12 <merijn> dmj`: It would depend on how pedantic I'm trying to be about my vocabulary :)
15:54:39 <dmj`> merijn: :) 
15:54:42 <merijn> I try to be extremely pedantic with beginners to avoid confusion, with others my vocublary is sloppy like everyone else
15:55:04 <dmj`> arkeet: sure, yes, then 'f :: String -> IO String; f x = putStrLn x >> getLine'
15:55:06 <hasker_> merijn: you've been extremely helpful, and I greatly appreciate it
15:55:32 <grandpascorpion> Hi, suppose I have a newtype that I have set to be an instance of Integral and that my "newtype" allows for an optimized way to compute the gcd (from Prelude).  Suppose I had a library and exposed my version of gcd for my type.  Is there a way for my gcd to be called instead of the Prelude gcd? 
15:55:33 <merijn> Anyhoo, now it's really bed time!
15:55:34 <dmj`> merijn: heh, your vocabulary is anything but sloppy. 
15:55:39 <arkeet> dmj`: merijn was unhappy with the "side" in "side effect", since an IO action is nothing but an effect.
15:56:21 <merijn> dmj`: Just wait until I call "IO String" impure again or something because I'm too lazy to coin the correct word once and for all :p
15:57:30 <dmj`> merijn: I was hoping you had the definitive source on 'side effect', to keep me from being sloppy too :)
15:57:45 <grandpascorpion> Sorry, the first sentence was badly worded. (from Prelude) should read (also defined in Prelude)
15:58:59 <Stratege> grandpascorpion name collisions are resolved by either hiding one of the colliding functions or by prefixing them with the modul they are from :)
15:59:32 <Stratege> merijn how does unsafePerformIO fit into that model of evaluation vs execution btw?
16:02:24 <GLM> Has anyone make RESTful APIs in Haskell?
16:02:39 <maerwald> yesod?
16:02:40 <hasker_> Working on that now, but not to great success
16:02:52 <dmj`> GLM: yea
16:02:59 <grandpascorpion> Thanks Stratege.  Gotcha,like a qualified import.  I wouldn't want to hide a function because then I'd be presuming the library user wouldn't want to use gcd the standard way  
16:03:23 <GLM> dmj`: Any general approach? I seem to be changing my strategy pretty often at this point
16:03:40 <Stratege> grandpascorpion you can't actually hide it for the library user, they have to do that themselves.
16:04:08 <Stratege> (since Prelude is pulled in implicitly if not stated otherwise in the module)
16:04:10 <grandpascorpion> Ok, thanks.  Sorry still getting up to speed with Haskell
16:05:02 <dmj`> GLM: I use snap, but any haskell web framework will do. There's servant, yesod, happstack, scotty, spock, mflow, wai/warp, and probably more
16:05:35 <GLM> dmj`: That is a big part of the issue. I run into lots of problems that cause me to switch frameworks
16:06:55 <Pamelloes> Can I turn a function forall b. MyClass b -> a into SomeMonad a?
16:07:22 <dmj`> GLM: in general I recommend reading configs settings from disk w/ configurator, or from env. variables (System.Environment.lookupEnv), use thread pools. Use aeson for delivering json. Right now I'm going with an ExceptT AppErrorType (ReaderT AppConnPools m) a, that is an instance of MonadSnap 
16:08:26 <dmj`> GLM: routing is preferential, servant / yesod are very type safe.
16:08:31 <dmj`> GLM: what issues are you hitting
16:08:55 <GLM> Is there any reasons I should prefer one framework over another? I'll be doing a lot of json and routing with plenty of stuff in the header, payload, and URL
16:09:14 <GLM> GLM: Right now, I don't know how to set up paths beyond the default path
16:09:32 <dmj`> GLM: what framework are you using right now
16:09:49 <dmj`> GLM: what is your db backend too
16:10:21 <GLM> dmj`: Using Warp now and don't have a db
16:10:31 <GLM> Probably will use mongo or mysql at some point
16:11:37 <GLM> Also having issues with String to lazy bytestrings
16:13:58 <dmj`> GLM: I'd avoid String at all cost. It's a very inefficient type compared to ByteString, text. I'd also use Text for most things. 
16:14:25 <GLM> I tried using the ++ operator. Is that string only?
16:14:33 <dmj`> GLM: yes
16:14:34 <kadoban> :t (++)
16:14:35 <lambdabot> [a] -> [a] -> [a]
16:14:38 <dmj`> well
16:14:40 <dmj`> lists
16:14:41 <kadoban> String is [Char]
16:14:44 <dmj`> and Strings are lists
16:14:48 <dmj`> use (<>)
16:14:50 <dmj`> :t (<>)
16:14:52 <lambdabot> Monoid m => m -> m -> m
16:14:55 <dmj`> since ByteStrings and Text are monoids
16:15:43 <dmj`> GLM: I'd check out wai, (warp depends on it, so you already have it). https://hackage.haskell.org/package/wai-3.0.2.3/docs/Network-Wai.html
16:16:02 <dmj`> GLM: It provides functions for interacting w/ requests, writing responses
16:16:45 <Stratege> are strings really terrible enough that even for short ones they should be avoided?
16:17:10 <dmj`> GLM: wai/warp is kind of the piecemeal way to do things, a lot of other frameworks are created in terms of these two packages (scotty, airship, spock, servant, yesod)
16:17:20 <GLM> dmj`: I've been using it a bit but haven't found a solid guide for it
16:17:30 <kadoban> GLM: Note that ByteString and (String/Text) have very different meanings. ByteString is just what it says, a bunch of bytes without inherent meaning. If you use them like Strings, it's pretty easy to end up with really broken code in anything except ASCII, for example.
16:18:08 <HeladoDeBrownie> Stratege, String is incorrect for many uses regardless of length. it does not correctly represent all unicode text, but Text does. sometimes String is okay though.
16:18:14 <kadoban> Stratege: For toys and stuff with very little input/output it doesn't matter. Or many times the execution time isn't that important anyway. But String is quite slow compared to Text (and ByteString).
16:18:16 <HeladoDeBrownie> Text does afaik*
16:18:32 <GLM> dmj`: Why wouldn't I used something other than wai if most other build on top of it?
16:18:39 <Stratege> HeladoDeBrownie I was under the impression that a Char in Haskell is a proper Unicode code point? It isn't? oO
16:19:01 <kadoban> It's about an order of magnitude slower than Text, which is about an order of magnitude slower than ByteString, is my usual mental-model/guess.
16:19:47 <napping> Stratege: I think the problem is more with operations
16:20:00 <HeladoDeBrownie> Stratege, to my understanding that is correct. however, one can't always operate on single code points.
16:20:50 <HeladoDeBrownie> one commonly cited example: the proper capitalization of ß is SS, but toUpper :: Char -> Char, so map toUpper cannot properly represent this.
16:21:01 <arkeet> > toUpper 'ß'
16:21:02 <lambdabot>  '\223'
16:21:07 <arkeet> > text $ toUpper 'ß'
16:21:08 <dmj`> Stratege: for specifying a URL, no, but for I/O, yes
16:21:08 <lambdabot>      Couldn't match type ‘Char’ with ‘[Char]’
16:21:08 <lambdabot>      Expected type: String
16:21:08 <lambdabot>        Actual type: Char
16:21:10 <arkeet> > text $ [toUpper 'ß']
16:21:12 <lambdabot>  ß
16:21:13 <arkeet> heh.
16:21:51 <Stratege> lovely.
16:21:56 <dmj`> GLM: It's not necessary, but there might be some conveniences you'd appreciate, some frameworks like snap, servant, yesod have nice database integration, and packages that fit well in that area
16:22:18 <Stratege> strings and floats - things to avoid if possible. ^^
16:22:32 <GLM> I just want to create and hit rest endpoints right now
16:25:18 <dmj`> GLM: well then, Scotty is dead simple, and the example in the docs is enough to get going, https://hackage.haskell.org/package/scotty
16:26:04 <GLM> I saw that. It looks pretty nice but I'm not sure how well it will fufilly complex REST requests with complex headers/payloads and mulitple URL paramaters 
16:28:28 <dmj`> GLM: Do you plan on sending / receiving more complex data than JSON? Aeson will handle that well. It provides variable capture in urls, along with querystring parameter retrieval, and header modification. Basically, wai will let you do it all, same with Snap.Core 
16:29:00 <dmj`> er sorry, "Wai provides..."
16:30:54 <dmj`> GLM: I forgot about this one too, http://silkapp.github.io/rest/
16:30:59 <oconnore> How does -main-is work? And/or, how do I compile N>1 executables using .o files?
16:31:08 <dmj`> GLM: you're spoiled for choices really
16:31:10 <oconnore> I can only have one Main.o file
16:31:39 <dmj`> oconnore: you can put more than one executable section in your cabal file, cabal build will build both
16:32:26 <oconnore> dmj`: hmm, I'm not using cabal for builds, but maybe I can watch it do that and figure out what arguments ghc needs?
16:32:57 <dcoutts> oconnore: you can have many files that are Main modules
16:33:15 <dcoutts> oconnore: e.g. foo.hs can be a Main module, and will compile to foo.o
16:33:15 <oconnore> dcoutts: but they all become Main.o, and overwrite each other
16:33:34 <dcoutts> oconnore: no, that's just the point
16:33:42 <dcoutts> well, at least cabal build keeps them all separate
16:34:27 <dcoutts> $ ghc --make foo.hs
16:34:28 <dcoutts> [1 of 1] Compiling Main             ( foo.hs, foo.o )
16:34:28 <dcoutts> Linking foo ...
16:35:04 <dcoutts> oconnore: so ghc does the right thing automagically
16:37:13 <oconnore> dcoutts: ohhh, it's -outputdir that breaks this automagical-ness
16:37:33 <oconnore> if you do ghc --make -c -outputdir ./testing Foo.hs it spits out Main.o
16:37:42 <GLM> dmj`: Did you say anything after I left? The internet cut out
16:37:50 <dcoutts> oconnore: if you're doing anything complicated it's probably easier to use cabal build/repl
16:37:57 <dmj`> GLM: yea, I misspoke, if you're going to use wai, it looks like you'll need a router for it. 
16:38:05 <dmj`> GLM: http://hackage.haskell.org/package/wai-routing
16:38:08 <dmj`> is one example
16:38:11 <oconnore> dcoutts: I'm using Shake
16:38:14 <dcoutts> oconnore: --make and -c are mutually exclusive
16:38:30 <GLM> I'd prefer something other than that
16:38:45 <GLM> dmj`: Is there anything like annotations in Jersey or Flask for rest routes?
16:38:46 <dcoutts> oconnore: if you use -c you probably want to use -o explicitly too
16:39:02 <oconnore> dcoutts: If I don't use --make ghc can't find any files
16:39:25 <oconnore> with --make it spits out the right .o files
16:39:32 <oconnore> and compiles in the right order
16:39:36 <dcoutts> oconnore: then you don't need -c 
16:39:43 <dcoutts> the two are completely opposite things
16:39:48 <oconnore> dcoutts: huh? then it attempts to compile the full thing!
16:40:04 <dcoutts> one is the ghc compilation manager with dep tracking, the other is single shot mode
16:40:23 <dcoutts> presumably if you're using shake you want the single shot mode
16:40:23 <oconnore> dcoutts: how can I get --make like behavior but stop compilation after .o?
16:40:34 <dcoutts> oconnore: --no-link
16:40:44 <dcoutts> oconnore: or -c on it's own will not link
16:40:47 <oconnore> dcoutts: with just -c ghc is really dumb and can't even find files in the same directory
16:41:02 <dcoutts> oconnore: -i.
16:41:17 <oconnore> hmm, ok, i'll play around some more
16:41:21 <oconnore> perhaps --no-link will help
16:41:59 <dcoutts> oconnore: actually I think -no-link is a red herring here, -c is quite simple. It just builds the .o
16:42:11 <dcoutts> it's just like gcc foo.c -o foo.o
16:42:17 <dcoutts> erm
16:42:22 <dcoutts> gcc -c foo.c -o foo.o
16:42:31 <dcoutts> ghc -c foo.hs -o foo.o
16:43:07 <dcoutts> oconnore: and yes, in single shot mode the other modules have to have been built first, but then that's what shake is for :-)
16:44:05 <dmj`> GLM: If you're comfortable enough w/ haskell none should be too difficult to pick up. Being fluent w/ monad transformers helps a bit
16:44:34 <oconnore> dcoutts: but shake has no mechanism for defining file order
16:44:41 <dmj`> GLM: here's sample code from the REST API I'm writing http://lpaste.net/132958
16:44:42 <oconnore> do I really have to define the dependency order myself?
16:44:58 <oconnore> why can't ghc spit out .o files while solving order as with --make?
16:45:03 <dcoutts> oconnore: ok, if you're not using shake to do the dep tracking then yeah it's much easier to use --make
16:45:06 <GLM> dmj`: To give some context, I'm brand new to Haskell and trying to use this to convince our team to write more Haskell so the stakes are high
16:45:27 <GLM> dmj`: I come from the land of Java and Python where this is all pretty easy
16:45:39 <oconnore> dcoutts: but --make doesn't do what I want, because it seems impossible to prevent it from generating Main.o for a Main module
16:47:06 <dcoutts> oconnore: sorry, don't have a solution off the top of my head. I don't know why outputdir would change its behaviour like that
16:47:33 <dcoutts> cabal manages it by using separate dirs for each exe, and not sharing .o files between them
16:47:59 <dcoutts> (which it does for other reasons, because in general different components use different flags, environments etc)
16:48:01 <dmj`> GLM: Easier? Sure. correct? hardly, and definitely not refactorable. I come from OOP land too, the switch is worth it IMO.
16:48:26 <oconnore> dcoutts: hmm, yeah, I suppose I can just use multiple directories
16:49:14 <GLM> dmj`: I hope you're right but it might not be with the cluster fuck of code I'll have at the end
16:49:31 <dmj`> GLM: well bad haskell can be as deadly as good haskell
16:49:42 <GLM> Explain
16:50:33 <dmj`> GLM: if you use a lot of partial functions it's bad, but haskell's concurrency, readability, correctness, while not sacrificing expressivity or performance makes it worth it
16:51:30 <SwashBuckla> why does this happen? https://stackoverflow.com/questions/3543399/implement-reverse-in-haskell-that-runs-in-linear-time
16:51:43 <SwashBuckla> sum (reverse' [1,2..1000000]) -- never finishes 
16:51:47 <GLM> dmj`: Would you say bad Haskell code is bette than good Java in this case?
16:52:06 <oconnore> dcoutts: thank you
16:52:09 <SwashBuckla> I thought it might take a while, but not over 20 minutes (by which point I killed GHCi)
16:52:15 <rien> GLM: it's easier to refactor at least since you can just follow the types
16:52:41 <kern_chicken_pan> why would this occur after a import?
16:52:41 <kern_chicken_pan> Top level:
16:52:41 <kern_chicken_pan>     attempting to use module `Geography.Geocoding.Google' (./Geography/Geocoding/Google.hs) which is not loaded
16:52:47 <GLM> I suppose so. I have to admit I'm really intimidated at the momen
16:52:54 <dmj`> GLM: The co. I'm at uses microservices, our haskell service is leading the pack in terms of performance and correctness. Dev ops love it too since you only end up with one build artifact
16:53:35 <SwashBuckla> @pl reverse' (x:xs) = reverse' xs ++ [x]  
16:53:35 <lambdabot> reverse' = fix ((`ap` tail) . (. head) . (. return) . flip . ((++) .))
16:53:36 <GLM> dmj`: I think I need to talk to you more then. I'm trying to pave the way for microservices at my team and praying that Haskell is the right way
16:53:52 <dolio> SwashBuckla: Your reverse' is rebuilding the list a lot.
16:54:41 <dmj`> GLM: the God of computational trinitarianism is faithful to answer prayers everywhere
16:54:46 <dolio> Around 1,000,000 times.
16:55:17 <GLM> dmj`: Are you on during most work hours? I could definitely use a mentor like figure on the project
16:55:17 <dmj`> GLM: what learning resources are you giving your team?
16:55:40 <GLM> dmj`: What do you mean? I'm just doing RnD now
16:57:34 <dmj`> GLM: I meant what books are you using to learn
16:58:44 <dfeuer> edwardk, why does trifecta depend on lens?
16:58:57 <GLM> dmj`: None at the moment. Mainly random blog posts 
16:59:12 * dfeuer randomizes his blog posts.
17:03:45 <dmj`> GLM: ok, a lot of people like bitemyapp's guide to learning haskell (https://github.com/bitemyapp/learnhaskell). I'd like to emphasize the Typeclassopedia, Parallel and Concurrent Programming with Haskell (marlow's book). Those two resources are great. There really is no silver bullet to learning haskell, studying the types just takes time. 
17:05:13 <GLM> Anything else?
17:05:44 <dmj`> GLM: what editor do you use?
17:05:59 <GLM> Vim 
17:06:06 <dmj`> perfect
17:06:06 <dfeuer> Has anyone seen edwardk around lately, or has he vanished?
17:06:23 <dfeuer> (perhaps to reappear in robot form)
17:08:30 <dmj`> GLM: lastly, lazy I/O, watch out for it, not sure if those resources cover it. You want to use iteratees when doing I/O. It's a way to process data in near constant space and ensures deterministic resource handling (file descriptors get closed). (pipes, io-streams, conduits)
17:09:16 <GLM> Are iteratees a type
17:09:20 <GLM> ?
17:13:51 <Lokathor> i think he means a style of data processing
17:16:28 <GLM> I didn't know that was a thing. I'll look into it
17:18:34 <GLM> I have to go home now but it was nice talking to you all. I'll see you tomorrow
17:40:45 <Pamelloes> Is there a difference between m(forall a. MyType a) and forall a. m (MyType a)
17:41:00 <fragamus> http://clemens.endorphin.org/ILC07-Liskell-draft.pdf
17:41:19 <benzrf> Pamelloes: yes, very much
17:41:27 <benzrf> Pamelloes: er, is m fixed
17:41:38 <Pamelloes> What does that mean?
17:41:48 <arkeet> even if it is, there is very much a difference.
17:41:56 <benzrf> arkeet: yeah, i assumed it was
17:42:02 <benzrf> Pamelloes: do you mean 'forall m. <blah>'
17:42:09 <benzrf> Pamelloes: or do you mean, once an m is picked, <your question here>
17:42:18 <Pamelloes> Once an m is picked.
17:42:24 <Pamelloes> Does that mean m is fixed?
17:42:36 <exio4> forall a. Maybe a vs Maybe (forall a. a) 
17:42:44 <exio4> a concrete case 
17:43:11 <Pamelloes> exio4: What's the difference in this case?
17:48:29 * hackagebot syncthing-hs 0.3.0.0 - Haskell bindings for the Syncthing REST API  http://hackage.haskell.org/package/syncthing-hs-0.3.0.0 (JensThomas)
17:52:17 <kristof> I am the monad, koo-koo-kachoo
17:54:21 <Pamelloes> What are my options for a LIFO stack?
17:54:47 <arkeet> a list?
17:55:07 <Pamelloes> huh....
17:55:17 * Pamelloes feels stupid
17:55:21 <Denommus> Pamelloes: yeah, a list. Push is cons, pull is tail 
17:55:29 <ion> s/tail/uncons/
17:55:37 <Denommus> :t uncons
17:55:38 <arkeet> s/pull/pop/
17:55:38 <lambdabot>     Ambiguous occurrence ‘uncons’
17:55:38 <lambdabot>     It could refer to either ‘Control.Lens.uncons’,
17:55:38 <lambdabot>                              imported from ‘Control.Lens’ at /home/lambda/.lambdabot/State/L.hs:48:1-43
17:55:47 <Denommus> Uh
17:55:54 <arkeet> it doesn't exist.
17:55:58 <arkeet> well
17:55:59 <arkeet> it does.
17:56:13 <arkeet> oh it doesl.
17:56:17 <arkeet> :t Data.List.uncons
17:56:18 <lambdabot> [a] -> Maybe (a, [a])
17:56:35 <arkeet> > uncons [1,2,3]
17:56:36 <lambdabot>      Ambiguous occurrence ‘uncons’
17:56:37 <lambdabot>      It could refer to either ‘Control.Lens.uncons’,
17:56:37 <lambdabot>                               imported from ‘Control.Lens’ at L.hs:48:1-43
17:56:39 <arkeet> fff
17:56:43 <arkeet> > Data.List.uncons [1,2,3]
17:56:45 <lambdabot>  Just (1,[2,3])
17:56:50 <Denommus> Why not [a] -> (Maybe a, [a])? 
17:57:06 <Gurkenglas> Because there might not be a tail.
17:57:18 <exio4> what does (Nothing, [1]) mean there?
17:57:35 <Denommus> Hm. In Lisp, tail of nil is nil, hence my confusion 
17:58:04 <ion> It’s the inverse of the cons operation. What is cons such that you specify the tail but don’t specify a head?
17:58:24 <Denommus> Okay, I get it 
18:00:01 <exio4> Denommus: Racket, (cdr '()) => error 
18:00:40 <Denommus> exio4: try in SBCL
18:01:02 <_m_ryan> hi based on this code that (http://lpaste.net/132905) liste help me out, can anyone help me out with the error i have i paste also the error there.
18:01:55 <ion> That is just a part of the error message.
18:03:30 <_m_ryan> ion: are you pointing in my code?
18:03:37 <ion> Your paste, yeah
18:04:17 <_m_ryan> ion: but that's the only error message. it is not totally an error message but a warning message.
18:04:31 <kadoban> _m_ryan: It looks like usaPrices is of type [RawLatestAvgPrices]. So line 40 makes no sense, since that do block is of type Handler Html.   Handler isn't the same thing as IO.
18:04:40 <ion> The error message did not provide a location and a code snippet?
18:04:42 <kadoban> _m_ryan: Err? No it's an error message, why do you think it's a warning?
18:05:02 <kadoban> s/same thing as IO/same thing as []/
18:05:27 <_m_ryan> kadoban: so what should be the best thing to solve the error?
18:05:50 <_m_ryan> kadoban: my IDE says its a warning. but i consider it as an error.
18:06:00 <kadoban> _m_ryan: I dunno, I have no idea what this code is doing. If you're a haskell beginner, start with the basics?
18:06:14 <hasker_> What does it mean when a lens has makeLenses ''BlahLens from Control.Lens? What's the ''?
18:06:55 <arkeet> :t makeLenses
18:06:57 <geekosaur> fmap usaCachedPrices getYesod --- useCachedPrices is of type [RawLatestAvgPrices], which is not a function, why is it being applied via fmap?
18:06:57 <_m_ryan> ion: the error is pointing on the last code i paste.. usaPrices <- fmap usaCachedPrices getYesod
18:06:57 <lambdabot> Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Lib.DecsQ
18:06:57 <_m_ryan>  usaLatestAvgAmount <- usaPrices
18:07:15 <arkeet> '' takes a type name and makes a TH Name value from it.
18:07:21 <arkeet> so that TH functions can refer to your type.
18:07:49 <geekosaur> _m_ryan, why are you doing fmap usaCachedPrices?
18:07:58 <hasker_> Is '' a function?
18:08:03 <ion> It’s syntax.
18:08:03 <geekosaur> no
18:08:06 <hasker_> Oh okay
18:08:17 <kadoban> geekosaur: That's record syntax stuff. Doesn't that mean it's type `App -> [RawLatestAvgPrices]` ?
18:08:17 <ion> Specifically, TemplateHaskell syntax
18:08:41 <_m_ryan> geekosaur: i just arrive from this code http://www.yesodweb.com/book/visitor-counter
18:08:52 <hasker_> ion: got it thanks!
18:08:54 <_m_ryan> ion: yes
18:10:03 <zanta> Hello all
18:12:41 <_m_ryan> geekosaur: does my code wrong?
18:13:16 <geekosaur> I don't know yesod well enough, would have to trace through a bunch of stuff I don't know to have any idea of the types involved
18:13:20 <SrPx> Just letting you know that I solved today earlier problem in what I believe was an OK way. I used tmux to leave a GHCI session open and created a VIM macro that opens that session, reloads the code and calls main. That process is ~3 times faster than just running runhaskell.
18:14:04 <SrPx> This way I can quickly see the result of the evaluation of any symbol below the cursor on vim and that is nice
18:22:43 <Nihilumbra> What does one do in the haskells
18:23:14 <c_wraith> usually write programs, but sometimes just see if things typecheck for fun.
18:23:19 <Nihilumbra> Is there a definitive point to using haskell and would you recommend it
18:23:21 <pacak> Nihilumbra: monies.
18:23:23 <_m_ryan> geekosaur: thanks i will figure it out. :)
18:23:27 <pacak> Lots of monies.
18:23:32 <Nihilumbra> Money?
18:23:40 <pacak> Yes, them.
18:23:40 <Nihilumbra> Explain
18:23:48 <pacak> Finance :)
18:23:58 <Nihilumbra> Do you get green paper for using haskell?
18:24:25 <Nihilumbra> Is it a widely used language among government offices
18:24:57 <pacak> Hmm... Well... It's more like red plastic in this country, but yea...
18:25:02 <arkeet> I wonder if anyone literally makes money using haskell.
18:25:28 <Pamelloes> My impression is that governments don't use any programming languages invented post 1944
18:25:49 <Pamelloes> Basically, they stick to archaic forms of assembly
18:25:56 <pacak> arkeet: Literally makes? As in printing it?
18:25:59 <arkeet> yes
18:26:12 <arkeet> (legal or otherwise)
18:26:27 <pacak> bitcoin-like stuff might be...
18:26:31 <arkeet> heh.
18:29:08 <Nihilumbra> Why 
18:29:24 <Nihilumbra> I like to put all my monads on VHS 
18:29:49 <kern_chicken_pan> how should I understand this issue?  No instance for (Show ([Address] -> IO [Address]))
18:29:58 <kern_chicken_pan> Address is a instance of Show
18:30:03 <pacak> Nihilumbra: What stops you from doing so?
18:30:11 <acowley> kern_chicken_pan: You're trying to print a function.
18:30:22 <Nihilumbra> Nothing I still do it 
18:30:49 <kern_chicken_pan> acowley: I am? I thought I am trying to print the result of a IO action
18:31:03 <kern_chicken_pan> geoEncodeAddresses :: [Address] -> IO [Address]
18:31:04 <kern_chicken_pan> geoEncodeAddresses = mapM updateAddrWithLatLng
18:31:16 <kern_chicken_pan> where updateAddrWithLatLng :: Address -> IO Address
18:31:32 <kern_chicken_pan> updateAddrWithLatLng works, I tested it with a single element of the list
18:31:47 <acowley> kern_chicken_pan: That may be what you're trying to do, but ([Address] -> IO [Address]) is a function type.
18:32:14 <acowley> kern_chicken_pan: Can you show the immediate thing you're doing that leads to the error?
18:32:27 <acowley> kern_chicken_pan: Best guess is you need a .
18:34:00 <kern_chicken_pan> acowley: woops, you are right, I was just getting lost in my types for a second :p
18:34:03 <kern_chicken_pan> thanks
18:34:40 <acowley> kern_chicken_pan: It's a really common thing to trip over.
18:34:57 <acowley> kern_chicken_pan: Best thing to take away from it is that the error messages are usually right.
18:36:03 <kern_chicken_pan> hehe I know, just my mind was fuzzy for a moment.. got in early this morning :/
18:36:19 <Nihilumbra> Ye
18:36:49 <kern_chicken_pan> One other simple one, how do I rethrow this error type in the Left again?
18:36:49 <kern_chicken_pan> type GeocodeError = String
18:36:49 <kern_chicken_pan> geoEncode :: String -> IO (Either GeocodeError (Double, Double))
18:37:04 <kern_chicken_pan> Left e -> print e or something?
18:38:12 <acowley> Not sure I follow what you want. Perhaps "return (Left e)"
18:40:58 <lethjakman> I'm trying to remember the syntax of something I read so I can google it, what are those pattern array things?
18:41:08 <arkeet> what pattern array things?
18:41:09 <lethjakman> it was something to the effect of [2,4,6,8..]
18:41:21 <lethjakman> and I could grab the 4th element and it'd have 16
18:41:33 <arkeet> uh
18:41:36 <acowley> It would?!
18:41:43 <arkeet> > [2,4..]
18:41:44 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
18:42:00 <lethjakman> >[5,10..]
18:42:03 <lethjakman> uhh
18:42:07 <lethjakman> > [5,10..]
18:42:08 <lambdabot>  [5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,120...
18:42:10 <acowley> Is this like an OEIS TH library?
18:42:16 <lethjakman> what is this called?
18:42:21 <lethjakman> cause that's fricken sweet
18:42:56 <arkeet> the Report calls them "arithmetic sequences"
18:42:58 <arkeet> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-400003.10
18:43:09 <arkeet> I might also call it range syntax, at least in the case of [a..b]
18:43:24 <arkeet> or [a,b..c]
18:43:45 <lethjakman> does it only work with 2 elements?
18:43:58 <lethjakman> > [1, 3, 5..]
18:44:00 <arkeet> it only works in the 4 cases described in the report
18:44:00 <lambdabot>  <hint>:1:9: parse error on input ‘..’
18:44:11 <arkeet> [a..] or [a,b..] or [a..c] or [a,b..c]
18:44:17 <arkeet> because
18:44:17 <pacak> :t enumFromThenTo
18:44:19 <lambdabot> Enum a => a -> a -> a -> [a]
18:44:26 <arkeet> what should [1,2,10..] be? what comes after 10?
18:44:45 <acowley> 7
18:45:00 <arkeet> oh, I was thinking -42
18:46:16 <lethjakman> that's not quite as cool as I thought it was...but it's still cool
18:46:18 <lethjakman> thank you :)
18:48:54 <Pamelloes> I have a function with the type of ((forall a. MyType a) -> m ()). Can I pass a fixed MyType a as the first parameter for this function?
18:49:00 <Pamelloes> (And if so how?)
18:50:09 <SrPx> on GHCI, import Module doesn't load a file called Module.hs with "module Module where", on the same directory. Why?
18:50:35 <SrPx> It says: "Could not find module 'Module'"
18:50:53 <Pamelloes> SrPx: I think you might have to use +m (or some other letter) to do that
18:51:50 <SrPx> target ‘+m’ is not a module name or a source file hm
18:52:07 <acowley> I have a famously poor understanding of GHCi's import facilities, but what you can use there is ":m +Module"
18:52:10 <acowley> I think
18:52:22 <c_wraith> :m is for stuff in packages
18:52:26 <c_wraith> :l is for source
18:52:27 <SrPx> Still can't find. Weird.
18:52:33 <acowley> I know many possible ways of importing things, and I tend to run through them before finding one that works.
18:52:39 <c_wraith> and if it's not finding sources, make sure you have the right paths in the -i
18:52:42 <acowley> There you go
18:52:57 <Pamelloes> It takes a village...
18:52:58 <SrPx> c_wraith: but I want to load functions from Module.hs while actually loading (with :l) MyFile.hs, all in the same directory.
18:53:18 <c_wraith> SrPx: you can :load Module MyFile
18:53:43 <c_wraith> SrPx: and then you can do import Module
18:53:54 <c_wraith> the important part is that if it's source, you :load it first
18:53:59 <SrPx> I've tried that, but I get "Not in scope: 'my_symbol_defined_on_myfile'"
18:54:52 <SrPx> okay
18:55:01 <SrPx> got it, just invert it to :load MyFile Module and it works
18:55:02 <SrPx> thanks
18:59:13 <mauris> hi! am i correct in thinking that it's impossible to implement a monoid instance for "n x n matrices under multiplication", as this would require dependent types?
19:00:33 <arkeet> why would that require dependent types?
19:01:07 <pacak> mauris: Would it? You need identity element which is I  and associative <> which is multiplication
19:01:32 <geekosaur> presumably you need at least to have the n x n in the type
19:01:32 <arkeet> just encode the matrix size in the type
19:01:37 <arkeet> which is easy
19:01:37 <nshepperd> instance Monoid (Matrix n n)
19:01:57 <arkeet> I'd go for instance m ~ n => Monoid (Matrix m n) but whatever.
19:02:28 <arkeet> you could even make it a Category
19:02:40 <Pamelloes> How would Matrix m n encode size? Wouldn't m and n have to be types not numbers?
19:02:41 <mauris> are those type level naturals?
19:02:57 <arkeet> yes and yes
19:03:03 <nshepperd> huh, it could be a category
19:03:11 <Pamelloes> arkeet: So those exist?
19:03:13 <arkeet> yes
19:03:16 <nshepperd> GHC.TypeLits
19:03:19 <Pamelloes> huh
19:03:20 <arkeet> we have type level numbers
19:03:23 <mauris> i was looking at  https://hackage.haskell.org/package/matrix-0.2.1/docs/Data-Matrix.html
19:03:30 <mauris> is there some other matrix package that uses type level nats?
19:03:48 <arkeet> not aware of one.
19:03:58 <arkeet> wait.
19:04:14 <nshepperd> well, Data.Category isn't polykinded is it?
19:04:27 <arkeet> it is!
19:04:31 <arkeet> :k Category
19:04:32 <lambdabot> (k -> k -> *) -> Constraint
19:04:36 <nshepperd> :O
19:04:43 <nshepperd> wow
19:04:53 <lethjakman> do the letters used in a type signature have any meaning?
19:04:58 <lethjakman> k -> k?
19:05:03 <lethjakman> same type, but anything else?
19:05:09 <arkeet> that's a kind signature, but no.
19:05:27 <lethjakman> it does seem rather friendly...
19:05:29 <lethjakman> thank you 
19:05:47 <geekosaur> there are some loose conventions (f often means a functor, m a monad...) but no meaning to the compiler
19:05:55 <lethjakman> ahh
19:05:58 <lethjakman> that's good to know
19:06:08 <arkeet> you see k above for "kind"
19:06:12 <arkeet> (k is a kind, not a type)
19:06:19 <lethjakman> umm
19:06:28 <lethjakman> kind?
19:06:38 <geekosaur> [19 22:04:10]  <lambdabot>	 (k -> k -> *) -> Constraint
19:06:40 <arkeet> :k Int
19:06:41 <lambdabot> *
19:06:42 <arkeet> :k Maybe
19:06:43 <lambdabot> * -> *
19:06:44 <arkeet> :k Maybe Int
19:06:45 <lambdabot> *
19:06:48 <geekosaur> a kind os the type of a type, sort of
19:06:54 <Pamelloes> lethjakman: A kind is the "type" of a type
19:06:54 <SrPx> Is there any way to ask runhaskell to tell me the type of a specific symbol? That would be awesome for getting annotations automatically on vim
19:06:55 <geekosaur> *is the
19:07:20 <lethjakman> huh
19:07:23 <lethjakman> very interesting
19:07:24 <mauris> http://hackage.haskell.org/package/Vec this looks beautifully complicated
19:07:28 <arkeet> SrPx: isn't that sort of stuff what ghc-mod is for?
19:07:32 <mauris> it has "type-encoded lengths" but doesn't use GHC's thing
19:07:48 <SrPx> I don't know much about ghc-mod, remember having a bad experience (not sure what)... let me check again
19:08:09 <arkeet> SrPx: but you could use ghci for that too.
19:08:12 <enthropy> SrPx: even http://projects.haskell.org/haskellmode-vim/ does it with _t (or maybe it's _T)
19:08:13 <arkeet> I thought you were using ghci before.
19:08:36 <nshepperd> mauris: https://hackage.haskell.org/package/hmatrix-0.16.1.5/docs/Numeric-LinearAlgebra-Static.html
19:08:44 <SrPx> arkeet: yep but then it outputs " Prelude> :t aff aff :: Num a => a "
19:08:45 <Pamelloes> Is there a way to "unfix" a type? e.g. Turn MyType a into forall a. MyType a?
19:08:46 <SrPx> instead of just the type
19:09:08 <arkeet> SrPx: you can trim that :-)
19:09:11 <mauris> "type ℝ = Double" i'm sold
19:09:16 <arkeet> lambdabot does a similar thing
19:09:19 <SrPx> with vimscript? :P
19:09:21 <arkeet> it asks ghci for the type
19:09:34 <arkeet> I think
19:09:39 <SrPx> mauris: run
19:09:41 <nshepperd> that one uses unboxed vectors with a phantom type annotation, instead of GADTy lists
19:10:22 <nshepperd> which you probably want if you're doing heavy numerical matrix stuff
19:14:22 <kristof> #numerical-haskell is a relevant channel for this as well
19:27:27 <SrPx> I installed haskellmode, but calling "compiler ghc" as needed on vim displays this error: http://lpaste.net/132965
19:35:47 <Pamelloes> GHC told me it found a bug :O
19:36:56 <pacak> Pamelloes: Congratulations.
19:37:33 <ackthet> it's good at that
19:37:48 <ttt_fff> are there haskell bindings for any of: (1) torch, (2) numpy, (3) octave, (4) some open source scientific computing lib ?
19:37:57 <ttt_fff> I really like ahskell, but the lack of a scientific compting lib is killing me
19:38:26 <ackthet> ttt_fff: might join #numerical-haskell 
19:39:21 <ackthet> also might go into what features you're looking for
19:39:47 <ttt_fff> blazing fast matrix ops; support for existing numerical recipes; ease of implementing neural networks
19:39:56 <ttt_fff> basiclly, I want to just call functions for standard ops instead of implementing them myself
19:42:12 <timothyh> is it possible to change cabal datadir at runtime? perhaps with an environment variable/
19:43:50 <timothyh> e.g. set prefix on the fly
19:48:35 * hackagebot biophd 0.0.8 - Library for reading phd sequence files  http://hackage.haskell.org/package/biophd-0.0.8 (DanFornika)
19:49:56 <teurastaja> someone please tell me the difference between a monad and an applicative functor
19:50:27 <johnw> a monad supports this operation: m a -> (a -> m b) -> m b
19:50:27 <pacak> :t join
19:50:29 <lambdabot> Monad m => m (m a) -> m a
19:50:35 <johnw> or that one
19:50:50 <pacak> :t (>>=)
19:50:51 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:51:08 <pacak> You can't flatten multiple layers of Applicative
19:51:22 <kristof> :t (=>>)
19:51:23 <lambdabot>     Not in scope: ‘=>>’
19:51:23 <lambdabot>     Perhaps you meant one of these:
19:51:23 <lambdabot>       ‘>>’ (imported from Control.Monad.Writer),
19:51:45 <kristof> ...what's the symbol for extend again?
19:52:10 <kristof> :t (=>=)
19:52:11 <lambdabot>     Not in scope: ‘=>=’
19:52:11 <lambdabot>     Perhaps you meant one of these:
19:52:11 <lambdabot>       ‘>>=’ (imported from Control.Monad.Writer),
19:52:14 <johnw> it's =>>
19:52:18 <johnw> it's just not in scope to lambdabot
19:52:25 <kristof> Oh, needs an import
19:52:39 <kern_chicken_pan> Control.Applicative probably
19:52:46 <kristof> Control.Comonad
19:52:52 <kern_chicken_pan> oh ok
19:53:09 <teurastaja> so whats the difference?
19:53:21 <teurastaja> :t pure
19:53:22 <lambdabot> Applicative f => a -> f a
19:53:27 <teurastaja> :t return
19:53:28 <lambdabot> Monad m => a -> m a
19:53:31 <pacak> such much unknown stuff to lambda bot, very sad, not wow.
19:53:44 <kristof> teurastaja: Applicatives support <*>
19:53:46 <kristof> :t <*>
19:53:47 <lambdabot> parse error on input ‘<*>’
19:53:50 <johnw> teurastaja: no difference between pure and return
19:53:53 <teurastaja> :t >>=
19:53:55 <lambdabot> parse error on input ‘>>=’
19:53:55 <pacak> teurastaja: They are more or less the same.
19:54:05 <pacak> :t (<*>)
19:54:06 <teurastaja> :t (>>=)
19:54:07 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:54:07 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:54:44 <pavonia> :t (=<<)
19:54:45 <lambdabot> Monad m => (a -> m b) -> m a -> m b
19:55:16 <teurastaja> erhh.... what is (=<<) ?
19:55:22 <johnw> it's just flipped >>=
19:55:34 <kristof> teurastaja: Applicatives are for things you want to apply, stuck in an applicative functor. Just (*2) <*> Just 2 == Just 4
19:56:22 <kristof> teurastaja: So you applied the function in a Just context to something in a nother context. You can also think of <*> as being an operator which maps a function f(a -> b) to a function from f a to f b
19:56:27 <pacak> Sometimes Applicative syntax looks better - read <$> getString
19:57:36 <felixn> dist/setup-config: hGetContents: invalid argument (invalid byte sequence) <-- ghc-mod is really mad at me, I tried recompiling it too, on ghc v7.8.4, not sure what else to try
19:58:18 <teurastaja> it looks like the omposition law no?
19:58:24 <teurastaja> *composition
19:58:32 <kadoban> felixn: You have to use an older cabal version on GHC 7.8.4 with ghc-mod. I think 1.19 or 1.18 or something.
19:58:47 <kadoban> felixn: If you google for that error message the details should come up.
19:59:00 <felixn> kadoban: oh, I downgraded to 7.8.4 because someone on the internet said it doesn't work with the latest >_<
19:59:22 <felixn> kadoban: how do I just delete everything and start fresh? :D
19:59:48 <kadoban> felixn: I dunno, depends how you installed. Yeah  I dunno if ghc-mod works with GHC 7.10.1 yet
20:00:32 <teurastaja> @src (<$>)
20:00:32 <lambdabot> f <$> a = fmap f a
20:01:26 <teurastaja> so application is just an infix fmap?
20:01:43 <johnw> no
20:01:48 <kadoban> <$> isn't really called "application" it's just called fmap if anything.
20:01:54 <kadoban> At least I don't think it is.
20:02:01 <SrPx> What is the recommended way to store self references, lens or normal values? For example, I save: "data Foo = Foo { foo :: Map String [Bool] }". How should I store the address of the focused Int? Add 2 fields "focusedList :: String", "focusedBool :: Int", or a "focusedBool :: Lens Foo Bool"?
20:02:29 <SrPx> Lens are more convenient, I believe, but can't be shown/serialized/etc, so I don't know
20:02:33 <jle`> hmm...what is the focused Int?
20:02:43 <johnw> SrPx: a zipper?
20:03:00 <SrPx> jle`: focused skeleton, actually, in a list of skeletons that make an animation, in a map of animations
20:03:05 <teurastaja> SrPx STRefs?
20:03:16 <SrPx> uh
20:03:22 <johnw> sounds vaguely comonadic
20:03:44 <johnw> Foo (String, Map String (Int, [Bool])) would be two nested Store comonads
20:03:45 <jle`> i'm not sure where the int is coming from
20:03:46 <teurastaja> i dont know what a comonad is
20:03:58 <johnw> teurastaja: it may not even be helpful to know yet :)
20:04:05 <SrPx> jle`: just an example
20:04:26 <SrPx> Oooh
20:04:28 <SrPx> I mean focused Bool
20:04:30 <johnw> they have a connection to zipper: the concept of a data structure with a focus
20:04:41 <SrPx> data Foo = Foo { foo :: Map String [Skeleton] } on that case
20:04:55 <SrPx> forget focused Int. my bad
20:04:58 <jle`> ah okay
20:05:03 <jle`> this makes a little more sense
20:05:14 <jle`> so the skeleton is 'addressed' by a String and an Int?
20:05:23 <SrPx> yep
20:05:36 <SrPx> johnw: I assumed zippers were stripped down versions of lens
20:05:47 <johnw> no, they are derivatives of data structures :)
20:05:48 <SrPx> lens kinda do what zippers do already - no?
20:06:07 <johnw> not quite
20:06:08 <jle`> i haven't heard this interpretation before
20:06:11 <johnw> zippers let you move around
20:06:18 <jle`> do you have a reference somewhere...?
20:06:19 <SrPx> with lens I can navigate through a tree by composing "ix"s for example... and modify/read from that focus just like a zipper can
20:06:29 <johnw> jle`: to what?
20:06:41 <johnw> SrPx: zipper lets you adjust position relatively
20:06:49 <johnw> like, "move up 3 from wherever you last were"
20:06:51 <jle`> the idea that zippers are "stripped down lens"
20:07:05 <SrPx> I just assumed that from my limited knowledge
20:07:14 <johnw> a zipper has a bit more structure than a lens, but they have a connection
20:07:20 <johnw> there is a zippering facility in the lens library
20:07:41 <johnw> now, the Store Comonad is about having a data structure with a focus
20:07:51 <johnw> and there is also a connection between comonads and zippers
20:07:58 <SrPx> oh my
20:08:15 <johnw> let's take a list
20:08:28 <johnw> a Lens' [Skeletion] Int is just a function, it's not a list
20:08:42 <johnw> a zipper is a type, ([Skeleton], Skeleton, [Skeleton])
20:08:52 <johnw> where the Int is now implicit: it's the length of the first skeleton list
20:09:00 <johnw> a store  is a type, (Int, [Skeleton])
20:09:05 <johnw> allowing for relative addressing
20:09:10 <johnw> now, all three types are isomorphic!
20:09:25 <johnw> except you drop the indexing information if you go to [Skeleton]
20:09:32 <johnw> but a lens + an index lets you recover the other two
20:10:13 <johnw> hence https://hackage.haskell.org/package/lens-3.3/docs/Control-Lens-Zipper.html
20:10:28 <johnw> let's you provide the index, and then work in an environment where you can nudge the index
20:10:41 <jle`> ah i see.  one use of lenses is to encode zippers
20:10:57 <johnw> the reason to use a comonad is if you want to evolve your collection of skeleton in a way that depends on all the skeletons involved
20:11:27 <johnw> this is why "pixel dithering" is pretty much the textbook example of their use
20:13:27 <johnw> just as join :: m (m a) -> a is the essence of being a monad, duplicate :: w a -> w (w a) is the essence of being a comonad.  For a list of skeletons with a focus, it yields a focused list of focused lists, where the outer focus targets the same position as before, and every inner list focuses on the skeleton at its relative position in the outer list
20:13:41 <SrPx> (I was reading about comonads)
20:13:48 <SrPx> sorry, so.. hm
20:15:14 <johnw> I saw somebody use comonads to make a very clever implementation of the Game of Life
20:15:23 <johnw> other than that, I rarely ever encounter them
20:15:30 <SrPx> I guess I want to see that
20:15:41 <SrPx> but the game of life isn't really complicated 
20:15:46 <johnw> http://javran.github.io/posts/2014-04-13-comonad-and-conways-game-of-life.html
20:17:27 <Javran> johnw: xD
20:17:44 <johnw> Javran: you weren't at OPLSS 2014 were you?
20:18:06 <Javran> johnw: I wasn't
20:18:17 <johnw> then the person I'm thinking of was yet someone else :)
20:20:06 <Javran> johnw: it's a little embarassing part3 of that article haven't been done yet -- I realized I got something wrong on part2 and didn't have time to fix it.
20:20:58 <SrPx> okay read it all... I think I get the overall concept, looks very cool
20:21:44 <Javran> SrPx: thanks for reading that :)
20:22:10 <johnw> SrPx: that why I had that reaction when you mentioned animations and sets-with-focus :)
20:23:24 <SrPx> the second paragraph particularly is very insightful 
20:24:14 <Pamelloes> When I call cabal build, I get a bunch of undefined symbol errors from the linker. Any idea why this might happen?
20:25:47 <pavonia> Pamelloes: Could you paste the blog?
20:25:50 <pavonia> *log
20:26:41 <SrPx> ah, wait
20:26:56 <SrPx> a comonad is just a comonoid on the category of endofunctors
20:27:03 <SrPx> no drama
20:27:24 <Pamelloes> SrPx: Makes perfect sense.
20:27:30 <Pamelloes> What's a comonoid in this case?
20:27:31 <SrPx> right?
20:28:14 <Pamelloes> pacak: I fixed it ;) Turns out I was exporting all of my modules.
20:28:59 <Pamelloes> Oops, I meant pavonia. Sorry pacak :(
20:28:59 <jle`> i call comonoids things that you can pop and drop
20:29:23 <pacak> Fixing something is always a good news...
20:29:57 <SrPx> well, a monoid is kinda like an unit element and a way to combine two elements into one
20:30:17 <SrPx> so a comonoid should be like a way to destroy the unit element and duplicate one element into two
20:31:00 * SrPx returns to /r/shittyaskcomputerscience
20:31:05 <Pamelloes> hehehehe
20:31:28 <felixn> is it ok to use ghc v7.8.4 with cabal v1.22.3.0 (latest)?
20:31:47 <Pamelloes> SrPx: Though technically that's Category Theory not Computer Science
20:31:58 <SrPx> fair enough
20:32:16 <Pamelloes> Though in this case that was more haskell then category theory so I guess comp sci is ok
20:32:37 <johnw> SrPx: that's exactly what it does, at the functor level
20:32:46 <SrPx> unsufficiently unfair
20:32:57 <johnw> a comonad is two natural transformations: W :-> I, and W :-> W ⊗ W
20:33:46 <johnw> and since natural transformations in Haskell just become polymorphic functions over a variable, and the tensor involved here is composition, you get w a -> a and w -> w (w a)
20:34:07 <johnw> flip the arrows in both cases, you get monads
20:34:47 <SrPx> ..... wait, the whole "flip the arrows" thing actually means just flipping the arrows on the types?
20:34:53 <johnw> yep
20:34:58 <SrPx> ...
20:35:04 <johnw> W <-: I and W <-: W ⊗ W :)
20:35:10 <jle`> instead of join :: m (m a) -> m a
20:35:13 <SrPx> my brain
20:35:16 <jle`> you get duplicate :: w (w a) <- w a
20:35:22 <jle`> instead of return :: a -> m a
20:35:32 <SrPx> extract
20:35:33 <jle`> you get extract :: a <- w a
20:35:39 <SrPx> dude
20:35:45 <jle`> or extract :: w a -> a
20:35:58 <tristanp> Do you guys write Haskell in an IDE? I am trying to get into it and I use vim normally, but it is bumming me out trying to get indentation right; none of the plugins seem to do the trick.
20:36:08 <johnw> tristanp: I use Emacs
20:36:24 <jle`> i use vim
20:36:38 <tristanp> jle`: which haskell plugins if any do you use?
20:36:45 <jle`> oh gosh
20:36:47 <jle`> hm
20:36:57 <jle`> it's been so long since i've installed them
20:37:04 <tristanp> can just check .vim/bundle right
20:37:19 <SrPx> okay, but what would the list comonad do? take a list and create a list of lists with all combinations?
20:37:26 <johnw> list is not a comonad
20:37:32 <SrPx> :(
20:37:34 <johnw> NonEmpty a is a comonad
20:37:40 <johnw> remember, extract must be a total function
20:37:46 <johnw> that usual rules out most functors
20:37:56 <johnw> but yeah
20:38:04 <johnw> it takes a list and creates a list with all combinations
20:38:23 <jle`> SrPx: usually if you look at "extract", the definition of duplicate can be seen with respect to it
20:38:37 <jle`> because fmap extract . duplicate = id
20:39:08 <jle`> er sorry
20:39:12 <jle`> extract . duplicate = id
20:39:14 <jle`> oh they both = id
20:39:19 <johnw> another blog post: http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
20:39:19 <jle`> cause comonoid
20:39:50 <SrPx> that's the one I first read
20:39:59 <johnw> how about http://jaspervdj.be/posts/2014-11-27-comonads-image-processing.html
20:40:01 <jle`> tristanp: i use haskellmode-vim...neco-ghc
20:40:13 <jle`> i'm not sure which ons of my bindle folder involv ghc exactly
20:40:15 <jle`>  /haskell
20:40:56 <johnw> and how they relate to lenses: lenses are the coalgebras of the costate (also called "store") comonad
20:41:29 <SrPx> where do you even learn all that
20:41:30 <jle`> SrPx: "extract" from a non-empty list gives you the first item.  so think of a "duplicate" such that extract . duplicate = id
20:41:39 <johnw> https://patternsinfp.wordpress.com/2011/01/31/lenses-are-the-coalgebras-for-the-costate-comonad/
20:41:40 <johnw> ;)
20:41:45 <jle`> obviously the first item of the new list has to be the original list
20:41:56 <jle`> and now you also need fmap extract . duplicate = id
20:42:08 <jle`> which means that if you duplicate and then "head" every element, you get the original list back
20:42:24 <jle`> so that means that the head of the nth list has to be the nth item of the original list
20:43:18 <johnw> i can't find my favorite graphic for the duplicate operation
20:43:23 <SrPx> Is there something like a book with all that information or are you guys just figuring all thatout
20:43:27 <johnw> you take a 3x3 grid of numbers, with one of them red
20:43:37 * hackagebot liquid-fixpoint 0.3.0.0 - Predicate Abstraction-based Horn-Clause/Implication Constraint Solver  http://hackage.haskell.org/package/liquid-fixpoint-0.3.0.0 (EricSeidel)
20:43:54 <johnw> then you duplicate, and you have a 3x3 grid of 3x3 grids, with the whole grid in that position red.  And every sub-grid has an element from a different position in red
20:44:36 <SrPx> so, recursion
20:45:12 <johnw> it only does it "one step"
20:45:26 <johnw> the idea is that you have extend: w a  -> (w a -> b) -> w b
20:46:02 <johnw> which means that for a 3x3 grid of numbers, you get to generate a number for each position by taking the 3x3 grid with *that focus* into account
20:46:26 <johnw> letting you do stuff like examine the neighboring numbers, for example
20:52:14 <SrPx> johnw: ...
20:52:44 <SrPx> see, extend takes a grid, focuses on each cell, sends that to our function which will do something for that specific focus
20:52:57 <SrPx> if that is correct, what I don't get is what is the meaning of focus
20:53:07 <johnw> position in a non-empty list, for example
20:53:16 <johnw> that "extract" gives you the element at that position
20:53:21 <johnw> so that*
20:53:33 <johnw> btw, focus and extracting at a focus is really the store comonad
20:53:41 <johnw> it's not the only kind of comonad
20:54:02 <SrPx> I see
20:54:54 <SrPx> makes total sense, but I dont get it completely. is there any way I can visualize that? the original grid, say, [[1,2,3],[4,5,6],[7,8,9]], and what happens after using duplicate on it
20:55:06 <johnw> i am looking for the graphic....
20:55:39 <jle`> SrPx: instead of a grid, we can look at a 3-vec or a tuple and try duplicating that in the same way, just 1d
20:55:48 <SrPx> say the original grid was actually [[1,2],[3,4]], then duplicate would generate [[[1,2],[3,4]],[[1,2],[3,4]],[[1,2],[3,4]],[[1,2],[3,4]]] -- something like that, I see - not sure exactly how, though
20:55:59 <jle`> if you imagine data Focus3 a = F3 a a a Int
20:56:00 <SrPx> jle`: sure
20:56:05 <jle`> where Int is 0, 1, or 2
20:56:18 <SrPx> okay
20:56:28 <jle`> then if we had F3 'a' 'b' 'c' 1
20:56:55 <jle`> duplicate on that would be F3 (F3 'a' 'b' 'c' 0) (F3 'a' 'b' 'c' 1) (F3 'a' 'b' 'c' 2) 1
20:57:21 <jle`> all of the elements are now copies of the original item, but with their Int parameter being the index that they're at
20:58:21 <jle`> if we say that extract (F3 x y z 0) = x, (F3 x y z 1) = y, (F3 x y z 2) = z (it takes the item at the Int position)
20:58:35 <jle`> then if you 'extract' our duplicated thing, you get F3 'a' 'b' 'c' 1...which was the original
20:58:53 <jle`> and if you fmap extract, you also get F3 'a' 'b' 'c' 1...the original
20:59:23 <jle`> this is the comonoidalness of comonads
21:00:52 <madhadron> I like to hand wave it as the plumbing you need to chain functions from neighborhoods to points.
21:01:35 <jle`> it's really neat actually to manually extract and fmap extract and see that it all works out :O
21:01:38 <jle`> it's a magical feeling
21:01:51 <jle`> madhadron: do you think "comonoidalness of comonads" is anything less than hand waving? ;D
21:02:12 <madhadron> joe`, Well, I might have said comonadicity...
21:02:42 <dmj`> comonadesque
21:02:51 <madhadron> comonaditude?
21:02:58 <jle`> 'comonadicity of comonads' is a bit of a tautology
21:03:02 <jle`> heh
21:03:04 <dmj`> comonadish
21:03:25 <madhadron> Or, if we're being Deutschish, comonadisch
21:03:37 <SrPx> okay, my updated view is that something can be an instance of comonad when it can insert a copy of itself on each of its slots, except with an explicit indication of some of its slots as the focused one
21:03:47 <SrPx> I also perfectly see why extract and fmap extract give the same result here
21:03:53 <SrPx> so, hmm... let me digest this
21:04:04 <SrPx> why I needed that again?
21:04:07 <madhadron> SrPx, That's a little too specific still.
21:04:27 <madhadron> That particular comonad does that
21:05:08 <SrPx> > duplicate (1 :| [2..4])
21:05:10 <lambdabot>      Not in scope: ‘duplicate’
21:05:10 <lambdabot>      Perhaps you meant one of these:
21:05:10 <lambdabot>        ‘replicate’ (imported from Data.List),
21:05:20 <SrPx> lambdabot: =(
21:05:34 <jle`> @let import Control.Comonad
21:05:36 <lambdabot>  Defined.
21:05:43 <SrPx> > duplicate (1 :| [2..4])
21:05:45 <lambdabot>      Not in scope: data constructor ‘:|’
21:05:45 <lambdabot>      Perhaps you meant one of these:
21:05:45 <lambdabot>        ‘:+’ (imported from Data.Complex),
21:05:53 <SrPx> @let import Data.List.NonEmpty
21:05:54 <lambdabot>  Defined.
21:05:56 <SrPx> > duplicate (1 :| [2..4])
21:05:59 <lambdabot>  (1 :| [2,3,4]) :| [2 :| [3,4],3 :| [4],4 :| []]
21:06:27 <SrPx> trying to make sense of this
21:07:01 <SrPx> it kinda focuses on each possible head:tail ?
21:07:37 <jle`> it's the original list, but iterate tail
21:08:03 <jle`> duplicate [1,2,3,4] = [[1,2,3,4],[2,3,4],[3,4],[4]]
21:08:15 <jle`> > tails [1,2,3,4]
21:08:17 <lambdabot>      Ambiguous occurrence ‘tails’
21:08:17 <lambdabot>      It could refer to either ‘Data.List.tails’,
21:08:17 <lambdabot>                               imported from ‘Data.List’ at L.hs:93:1-16
21:08:23 <jle`> > Data.List.tails [1,2,3,4]
21:08:25 <lambdabot>  [[1,2,3,4],[2,3,4],[3,4],[4],[]]
21:08:39 <kadoban> Is 'findM' from NICTA a copy of something that exists, or is it made up? It's :: Monad m => (a -> m Bool) -> [a] -> m (Maybe a)  It finds the first element that matches, sequencing the monadic effects as it goes. I ask because I know most of the stuff in there is renamed stuff from Prelude or somewhere …
21:08:52 * SrPx shrugs
21:09:11 <jle`> SrPx: `tails` is just the list of all the tails
21:09:37 <dibblego> kadoban: findM is generally accepted as "a missing function that should be there"
21:09:40 <jle`> you can see that "extract" or "head" gets you the original list
21:09:50 <jle`> you can also see that "map head" gives you the original list as well
21:10:01 <jle`> if you ignore the last empty element which isn't a part of duplicate
21:10:03 <kadoban> dibblego: Ah okay, thanks :)
21:10:19 <jle`> in this case, the "index" represents where in he list you start
21:10:21 <SrPx> is it really too specific to say duplicate just creates a copy of a container with each slot of that container replaced by a copy of the original container with a focus on that specific part? :/
21:10:50 <SrPx> jle`: true
21:10:51 <c_wraith> SrPx: it's very vague..  in terms of what does "focus" mean, anyway?
21:11:00 <SrPx> that's what I'm trying to grasp
21:11:03 <c_wraith> SrPx: It's often a good explanation of what it does, yes
21:11:20 <SrPx> so the issue is with the word focus?
21:11:32 <c_wraith> SrPx: But it's just an analogy.  What duplicate *actually* does is precisely what the comonad laws require - no more, no less
21:11:53 <madhadron> SrPx, It assumes that the type is a container with slots to fill. May not be true.
21:12:23 <madhadron> But my immediate example is from topology, so may not be relevant.
21:12:36 <johnw> SrPx: I tried to mention before that "focus" is a feature of the store comonad
21:12:38 <johnw> not comonads in general
21:12:53 <johnw> but since they are one of the easiest to grasp, we used that for an example
21:13:00 <SrPx> I see
21:13:07 <c_wraith> johnw: still, it's a close thing for many comonads.  Cellular Automata, NonEmpty lists, etc
21:13:07 <SrPx> I fully get the example of the grid now
21:13:14 <SrPx> why one of them is fully red and all
21:14:06 <johnw> well, Env has no focus, nor Identity
21:14:16 <johnw> nor Traced
21:15:14 <johnw> Store, Env and Traced are basically costate, coreader and cowriter
21:15:46 <jle`> what is a little interesting to me is that you can get State, Reader, and Writer by manipulating Store, Env, and Traced
21:15:49 <jle`> but you can't go backwards
21:16:10 <jle`> but that might be a topic for another day
21:16:20 <johnw> haha
21:16:23 <SrPx> fair enough :)
21:16:33 <jle`> by interesting i mean baffling
21:16:48 <SrPx> I'll try to implement the automata thing as an exercise and will let the generalization for later
21:16:56 <johnw> that's a good approach
21:17:01 <madhadron> SrPx, This stuff tends to assimilate while you sleep
21:17:13 <madhadron> You wake up slightly less confused each morning
21:17:15 <johnw> "store" is what most articles on comonads are about on the Net anyway
21:17:23 <madhadron> Except when you make a breakthrough, and then you wake up baffled
21:29:37 <SrPx> there you go
21:29:41 <SrPx> ugly but works http://lpaste.net/132968
21:29:50 <SrPx> gotta sleep now, thanks you all :)
21:30:15 <SrPx> I hope tomorrow this will somehow magically help me solve my actual design problem
21:30:18 <SrPx> jk
21:35:01 * madhadron blinks and realizes he's been out of the community too long.
21:35:18 <madhadron> I seem to remember comonads being defined in terms of <<= and coreturn
21:36:26 <jle`> people still like to approach comonads that way too
21:36:49 <madhadron> It comforts me to just turn arrows around in my diagrams.
21:37:04 <jle`> the typeclass in the comonad does it that way
21:37:16 <jle`> it also adds cojoin
21:37:31 <jle`> so you can have options on which to implement...or implement all three for efficiency
21:37:42 <madhadron> Okay. Things have been spruced up a bit.
21:38:02 <jle`> the Comonad typeclas sstill defines it in terms of (<<=) and coreturn, but thy have different names now
21:38:18 <jle`> (<<=) is called extend and coreturn is called extract
21:38:26 <jle`> cojoin is called duplicate
21:38:59 <madhadron> So I inferred from the discussion above
21:39:22 <SrPx> btw in case there is something very wrong with my understand (as per the code) please let me know by message... also could I use the store comonad and avoid defining Automata as a comonad? dunno too many things
21:39:23 <SrPx> night
21:48:40 * hackagebot scalpel 0.2.0.1 - A high level web scraping library for Haskell.  http://hackage.haskell.org/package/scalpel-0.2.0.1 (fimad)
21:53:40 * hackagebot simple-sendfile 0.2.20 - Cross platform library for the sendfile system call  http://hackage.haskell.org/package/simple-sendfile-0.2.20 (KazuYamamoto)
22:11:20 <xelxebar> :t (*).(+1)
22:11:21 <lambdabot> Num a => a -> a -> a
22:11:36 <xelxebar> :t (+1).(*)
22:11:37 <lambdabot> (Num a, Num (a -> a)) => a -> a -> a
22:12:07 <xelxebar> The Num (a -> a) type constraint is because function application is left associative?
22:14:46 <johnw> I don't think so
22:14:55 <johnw> your composition will pass a function as the argument to +1
22:15:26 <xelxebar> Yeah, since (+1) :: Num a => a -> a
22:15:28 <xelxebar> :t (+1)
22:15:30 <lambdabot> Num a => a -> a
22:16:07 <xelxebar> so (*) "eats" one argument and passes of the rest of (a -> a) to (+1)
22:16:35 <xelxebar> I was really wondering how to get (*) to consume all the args and then compose the result with (+1)
22:16:36 <johnw> yep
22:16:53 <johnw> @pl \x y -> (+1 (* x y))
22:16:53 <lambdabot> (((+) . 1 . (*)) .)
22:17:16 <johnw> no es bonita
22:17:27 <xelxebar> eww
22:19:49 <jle`> i wrote a functor that i feel might be unlawful but it's useful
22:19:51 <xelxebar> thanks, johnw. Using the pointless utility there is exactly the kind of general find-the-answer-yourself solution I was looking for. Still getting used to all the tools and resources
22:19:55 <jle`> i am become death
22:20:12 <johnw> jle`: show me
22:20:40 <jle`> oh, it's not unlawful
22:20:52 <johnw> show show show!
22:20:54 <jle`> but the MonoFunctor instance is potentially unlawful
22:21:00 <jle`> it's not unlawful because it's derived haha
22:21:04 <jle`> in ghc we trust
22:21:21 <xelxebar> amen
22:21:32 <johnw> I am not being shown
22:21:57 <johnw> while waiting for a very slow theorem pover, I must be given suspect Functor instances to peruse
22:22:23 <jle`>    deriving (Functor)
22:22:30 <jle`> is the relevant thing to show ^_^
22:22:33 <madhadron> johnw, I'm going to remember that and refer to my colleagues as very slow theorem provers.
22:22:33 <johnw> :(
22:22:38 <johnw> hahaha
22:22:51 <jle`> but my MonoFunctor instance is unlawful i think
22:22:59 <johnw> show me the type and the instance!
22:23:15 <johnw> proving Functor laws is so fun
22:23:43 <xelxebar> madhadron: I'm giggling and now my lab mates are looking at me weird.
22:25:27 <madhadron> xelxebar, Welcome to my world.
22:25:43 <jle`> johnw: it's not going to be fun to prove, it's messy
22:25:58 <johnw> show!!!!!
22:30:56 <lpaste> jle` pasted “legal monofunctors?” at http://lpaste.net/132969
22:31:05 <jle`> here ya go johnw
22:31:57 <johnw> I see
22:32:00 <johnw> not functors :(
22:33:01 <johnw> monofunctors are not interesting at all
22:33:10 <johnw> since there is no type being changed by omap
22:33:44 <xelxebar> I'm subscribed to Haskell for All's RSS feed and have found the stuff about morte interesting. Anyone here use/familiar with/researching it?
22:33:55 <johnw> so while Foo  a = Foo (a -> a) is definitely not a functor, you could make a MonoFunctor with Element Int just by always returning 0, for example
22:34:24 <jle`> in my actual code there is a Functor instance for a modified version of VecFoc but it is GHC derived
22:34:42 <johnw> it would have to be modified, since that's not a Functor
22:35:18 <jle`> mhm
22:35:56 <jle`> you can also make Foo a a monofunctor with element a, right?
22:36:08 <johnw> sure, a monofunctor can do literally anything it wants
22:36:13 <jle`> if not then my Boundary instance is doomed
22:36:20 <johnw> it doesn't even have the lens laws to worry about
22:36:39 <johnw> a monofunctor is basically a Getter
22:36:58 <johnw> with a pre-chosen element type
22:39:18 <johnw> put another way: there isn't any type that can't be made a monofunctor :)
22:40:09 <jle`> but you can still implement one unlawfully :o
22:40:47 <johnw> how though?
22:41:21 <jle`> omap id might not be id
22:41:21 <johnw> ah, I see
22:41:31 <johnw> omap composition could fail for Set
22:41:34 <jle`> and composition etc
22:42:02 <_m_ryan> hi is it possible to get my connectionPool data inside the Handler?
22:42:48 <dmj`> _m_ryan: is your Handler an instance of MonadReader / MonadState?
22:42:51 <johnw> _m_ryan: that question is a bit context free...
22:44:59 <_m_ryan> dmj`: how do i know if it is MonadReader/MonadState.
22:47:14 <dmj`> _m_ryan: load up your module into ghci and type ':i Handler', or just paste your code on lpaste.net for us to see
22:50:32 <_m_ryan> johnw & dmj`:  here it is http://lpaste.net/132971
22:51:02 <johnw> ahh
22:51:05 <johnw> now I know what you mean
22:51:31 <johnw> you should be able to ask the handler for the app
22:52:06 <johnw> getYesod, I believe it is
22:52:15 <johnw> so:
22:52:20 <johnw> app <- getYesod
22:52:25 <johnw> ... connPool app ...
22:52:30 <_m_ryan> johnw: can you teach me, how?
22:57:46 <_m_ryan> johnw: there's an error No instance for (Monad ((,) [RawLatestAvgPrices]))
22:57:46 <_m_ryan>   arising from a do statement
22:58:14 <johnw> you're in the wrong monad at that point
23:00:16 <_m_ryan> johnw: i will update the paste
23:03:45 <_m_ryan> johnw: i update the paste : http://lpaste.net/132971
23:06:37 <johnw> well, first of all getYesod must be used in the Handler monad
23:06:43 <johnw> :t atomicModifyIORef
23:06:45 <lambdabot> Not in scope: ‘atomicModifyIORef’
23:07:11 <johnw> that takes a function that must return a tuple
23:07:17 <johnw> which is why you're seeing what you're seeing
23:15:29 <m_ryan> johnw: thank you it works :-)
23:17:05 <johnw> nice!
23:31:10 <m_ryan> johnw: question, i want to use 'when' before updating the, but it says = parse error on input do
23:34:20 <m_ryan> jonhw: here is my code  when (usa > 20) do ......
23:34:37 <johnw> you need when x $ do ...
23:42:00 <m_ryan> johnw: here is the paste http://lpaste.net/132971
23:42:38 <johnw> get rid of the very first do
23:43:29 <johnw> and change both \i -> do to just \i ->
23:45:07 <Guest58819> if you had to install ghc on a fresh computer would you install haskell platform (uses ghc 7.83) or ghc 7.10 .1 without haskell platform?
23:47:50 <m_ryan> johnw: error: Parse error in pattern: usa > 20, Possibly caused by a missing 'do'? 
23:48:08 <johnw> when (usa > 20) $ do ...
23:48:12 <johnw> should be fine
23:48:15 <johnw> but now is my bedtime
23:48:22 <johnw> good luck!
23:48:32 <m_ryan> johnw: thank you
23:52:05 <maxx_> or, to rephrase, do you think benefits of ghc 7.10.1 outweight benefits of haskell platform?
23:52:13 <maxx_> or vice versa
23:54:20 <pacak> maxx_: There's one nasty bug in ghc 7.10.1's event manager.
23:54:31 <maxx_> oh?
23:55:08 <pacak> It probably won't affect you unless you are doing lots of IO though.
23:55:31 <pacak> https://phabricator.haskell.org/D849
23:55:35 <maxx_> what qualifies as lots of IO
23:57:22 <maxx_> and is only linux affected? I am on windows
23:58:13 <pacak> Not sure, but on windows it might be easier to get HP.
23:59:43 <ruslan_t> A question about category theory, if i have a function like "f x = x + 1" and a bunch of other functions from Int to Int, should i think of think of these functions as morphisms and Int as the only object in the category? In a lot of places they say "morphisms transform/link objects" and as a programmer my mind goes to think of these objects as the
23:59:43 <ruslan_t>  parameters for functions i.e. 1,2,3 and not the whole Int space. Thank you
