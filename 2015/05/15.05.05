00:03:23 <athan> :S
00:04:33 <athan> cfoch: Does it say something like "member of hidden package..."?
00:06:06 <cfoch> athan: http://fpaste.org/218495/14308095/
00:07:39 * hackagebot vector-algorithms 0.7 - Efficient algorithms for vector arrays  http://hackage.haskell.org/package/vector-algorithms-0.7 (DanDoel)
00:07:39 * hackagebot http-media 0.6.2 - Processing HTTP Content-Type and Accept headers  http://hackage.haskell.org/package/http-media-0.6.2 (TimothyJones)
00:08:32 <athan> cfoch: Man you gotta use cabal
00:08:41 <athan> no more ghc compiling~
00:08:41 <athan> !
00:08:54 <athan> use `cabal init` to get your package started
00:08:56 <cfoch> ahhhh
00:09:05 <cfoch> i forgot it
00:09:18 <cfoch> thanks
00:09:20 <jle`> is there anything stopping us from writing, say, a Functor instance for data SetF a b = SetF (Set a) (a -> b) ...?  is that not a useful functor instance?
00:09:38 <jle`> then you could do something like getSet :: (Ord a, Ord b) => SetF a b -> b
00:10:31 <cfoch> athan: there is a way to use GHC pointing in someway to the sandbox. Do you remember what is the option/flag?
00:11:12 <athan> jle`: coyoneda? :S
00:11:34 <cfoch> -package-db
00:11:41 <athan> cfoch: Just be in the same directory as the sandbox, then `cabal install` :)
00:11:49 <athan> oop
00:12:06 <athan> yeah I don't know the ghc-relevant commands :\
00:19:18 <comprehension> am i correct in understanding that using $([| ... |]) in template haskell emits "(...)" rather than "..."?
00:34:48 <Cale> comprehension: Yes, I suppose that's a reasonable way to interpret the situation. It doesn't literally emit text which gets re-parsed though.
00:35:46 <Cale> comprehension: $(...) splices in the syntax tree constructed by the code inside it directly
00:45:57 <frerich> Hm, I'm a bit confused about how quasi quotation and template haskell related. Does anybody know why in https://github.com/frerich/random-derive/blob/master/src/System/Random/TH.hs I don't need the QuasiQuotes language extension? I thought that as soon as I do '[...| ... |]' I'd need it, but apparently that's not the case.
00:47:56 <Cale> frerich: You only need it for things of the form [...|...|] which are user-defined
00:48:13 <Cale> [d|...|] is a built-in part of Template Haskell
00:48:21 <frerich> Cale: Ooh... you mean, for a custom quoter (i.e. not 'd')? I see.
00:48:30 <frerich> I thought the syntax itself required a language extension.
01:12:35 * hackagebot sandi 0.3.4 - Data encoding library  http://hackage.haskell.org/package/sandi-0.3.4 (MagnusTherning)
01:16:37 <k0ral> when designing a library that defines new data types, does it make sense to export Arbitrary instances for those types, so that the user is saved the trouble ?
01:17:16 <arkeet> that would require a dependency on quickcheck
01:17:25 <arkeet> which isn't really worth it for most libraries
01:18:14 <k0ral> I didn't think a dependency on quickcheck was that bad, I was more worried about preventing users from overriding the Arbitrary instances
01:18:47 <k0ral> I mean, as a user, I know that I'm quite bothered by the necessity to redefine all arbitrary instances in each of my projects
01:19:15 <k0ral> so is there a way to mitigate that issue ?
01:20:39 <k0ral> I've considered exporting generators (Gen a) instead of Arbitrary instances, but then I can't use "arbitrary" and leverage the power of shrinking
01:22:24 <k0ral> arkeet: I can make quickcheck, and the Arbitrary instances, an opt-in feature using a cabal flag
01:29:32 <k0ral> maybe the right thing is to wrap with newtype, and export arbitrary instances for the wrappers
01:36:33 <ion> Users shouldn't need to have different Arbitrary instances. If they need something other than the obvious behavior, they can use forAllShrink instead of the provided instance.
01:42:09 <k0ral> ion: can quickCheck use custom Gen a for tests inputs ? if no, then I disagree with you :)
01:42:18 <joneshf-laptop> i think arbitrary instances should be more common
01:42:36 <joneshf-laptop> it doesn't make much sense to me that qc is relegated entirely to testing
01:44:31 <k0ral> joneshf-laptop: what do you mean exactly ?
01:45:23 <joneshf-laptop> for instance, monte carlo simulations could use qc instances to make for some much cleaner code than Greenspun-ing everything with `Random` or whatever.
01:45:31 <joneshf-laptop> but that's not really testing
02:05:16 <Esteth3> Hey folks. Im trying to ensure typesafety in a simple 6502 emulator im trying to build to get the hang of ST. My issue is that i have an instruction type with constructors for each instruction, some taking an AddressMode parameter, but id like to make sure that i can only construct instructions with valid AddressModes
02:05:38 <Esteth3> That is, some instructions are only valid for some AddressMode constructors
02:06:00 <Esteth3> Is it possible to make that explicit?
02:06:54 <Cale> Esteth3: That sounds like the sort of thing that a GADT might be useful for.
02:08:54 <Cale> Esteth3: (for AddressMode specifically)
02:09:00 <Esteth4> Cale: thanks, ill take a look. My super-novice understanding of GADTs was that they allow me to type each constructor independantly
02:09:04 <Cale> yeah
02:09:46 <Esteth4> But here type alone isnt enough, right? I want to be able to restrict which constructors, not just which types
02:10:30 <Esteth4> I guess i need to make my addressmodes different types under a single typeclass?
02:10:47 <Cale> Well, that wasn't what I had in mind
02:11:10 <Cale> It's hard to be explicit about what I mean without more information about your situation
02:11:53 <Cale> But for example, you could have some trivial datatype  data A
02:12:38 * hackagebot warp 3.0.13 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.13 (MichaelSnoyman)
02:12:51 <Cale> and then you'd have the constructors for the instructions that take an AddressMode argument which needs to be among the certain particular set of modes can take an  AddressMode A
02:12:59 <Cale> while others might be polymorphic
02:13:36 <Cale> and those constructors specifically will produce a result of type AddressMode A, while others might produce AddressMode B
02:13:45 <Cale> Does that make sense?
02:14:11 <Cale> I mean, the special AddressMode constructors which are permitted here
02:14:49 <Esteth4> I think so, thanks ☺ ill have a bash at it and see what i can do.
02:15:59 <lpaste> tomphreek pasted “Generate distinct numbers which can be expressed as a sum of 4 4th powers” at http://lpaste.net/132025
02:17:00 <tomphreek> I want to generate distinct numbers which can be expressed as a sum of [1..34] 4th powers. I can do a fixed number of 4th powers (e.g. 4); but when I try to generalise I really wanna use a for loop, but I can't.
02:19:00 <tomphreek> sum of distict 4th powers rather
02:20:44 <tomphreek> I guess I can take a powerset of [1..56] and restict it to certain length (34)...
02:22:12 <Cale> @let pick 0 xs = [[]]; pick n xs = do (p:xs') <- tails xs; ps <- pick (n-1) xs'; return (p:ps)
02:22:13 <lambdabot>  Defined.
02:22:22 <Cale> > pick 3 [1..5]
02:22:23 <lambdabot>  [[1,2,3],[1,2,4],[1,2,5],[1,3,4],[1,3,5],[1,4,5],[2,3,4],[2,3,5],[2,4,5],[3,...
02:25:16 <Cale> tomphreek: Note that iterating through the 2142582442263900 subsets of size 34 from [1..56] will take a very very long time.
02:25:59 <Cale> > pick 34 [1..56]
02:26:00 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
02:26:10 <Cale> heh
02:28:16 <tomphreek> Cale: yeah...
02:38:56 <ion> @hoogle forAllShrink
02:38:57 <lambdabot> Test.QuickCheck.Property forAllShrink :: (Show a, Testable prop) => Gen a -> (a -> [a]) -> (a -> prop) -> Property
02:38:57 <lambdabot> Test.QuickCheck forAllShrink :: (Show a, Testable prop) => Gen a -> (a -> [a]) -> (a -> prop) -> Property
02:39:00 <tomphreek> nope, that's too much iteration, just like expected
02:39:07 <ion> k0ral: See above.
02:40:35 <ysr> I learned the basics of haskell and I made couple of command line games with it. I want to do more but I am out of ideas. I checked out a tutorial about fetching and parsing web pages but it was inaccessable for me. Can anyone suggest a project that is appropriate for a beginner in haskell?
02:40:45 <tomphreek> I ll try recurrence all the number of numbers that are needed in the decomposition of 4th powers
02:41:38 <k0ral> ion: nice, but is that preferable to defining Arbitrary instances on a wrapper ?
02:45:16 <Cale> ysr: Maybe play around with gloss a bit?
02:45:30 <ysr> Cale what is gloss?
02:45:44 <Cale> http://hackage.haskell.org/package/gloss
02:46:28 <Cale> (go back one version to get docs, they haven't generated yet for the latest version it seems)
02:46:41 <Cale> http://gloss.ouroborus.net/
02:47:18 <Cale> It's basically a quick way to get some simple graphics on the screen
02:47:58 <ysr> ohh, it is nice to see some examples. Most packages don't have that :)
02:49:27 <ysr> I guess I need to cabal install gloss in order to use it?
02:49:29 <ion> k0ral: forAllShrink is great for ad-hoc custom generators, newtype wrappers with Arbitrary instances are good if you need a custom generator more often. I'd say it's best for the author of a data type to define the official Arbitrary instance directly on the type.
02:49:37 <Cale> ysr: Yeah, that's right
02:52:32 <ion> k0ral: Oh, i realize i thought one thing and wrote something else. I meant "users shouldn't need to have different Arbitrary instances *that often*"
02:55:38 <Sonderblade> so i have a generic function for traversing a graph, the user can supply tree functions/callbacks for mutating nodes, edges and for controlling the traversal direction
02:56:17 <Sonderblade> how would you in haskell design that nicely? 3 extra parameters for the 3 "custom" functions isn't so nice
03:00:44 <joneshf-laptop> sounds sort of zipperish
03:08:07 * hackagebot call-haskell-from-anything 0.1.0.2 - Python-to-Haskell function calls  http://hackage.haskell.org/package/call-haskell-from-anything-0.1.0.2 (NiklasHambuechen)
03:23:20 <tomphreek>  > floor (10^7-4)**(1/4)
03:23:30 <tomphreek> > floor (10^7-4)**(1/4)
03:23:31 <lambdabot>      No instance for (Show a0)
03:23:32 <lambdabot>        arising from a use of ‘show_M611174277331255596026153’
03:23:32 <lambdabot>      The type variable ‘a0’ is ambiguous
03:23:47 <joneshf-laptop> if i've got a bunhc of things i want to quickcheck but they've all got a typeclass context, can i give one type signature that'll concretify the type class?
03:24:50 <tomphreek> > floor (10^7-4)**(1/4) :: Int
03:24:51 <lambdabot>      No instance for (Floating Int) arising from a use of ‘**’
03:24:51 <lambdabot>      In the expression: floor (10 ^ 7 - 4) ** (1 / 4) :: Int    No instance f...
03:24:51 <lambdabot>      In the second argument of ‘(**)’, namely ‘(1 / 4)’
03:24:58 <joneshf-laptop> like if I had `prop_Assoc :: Num a => a -> a -> a -> Bool` and `prop_Commut :: Num a => a -> a -> Bool`, and i'm doing `main = quickCheck prop_Assoc >> quickCheck prop_Commut`
03:25:14 <joneshf-laptop> is there a way to specify that i wantto test with `Int` say?
03:27:52 <tomphreek> > floor ((4-0.0)**(1/4))
03:27:53 <lambdabot>  1
03:28:14 <ttt_fff> anyone here unhapy with life because no land combines best of erlang and haskell ?
03:29:01 <Adeon> cloud haskell is a thing on hackage right now
03:29:40 <Adeon> and GHC 7.10 introduced a staticpointers extension for it although the current version does not use it at the moment
03:29:58 <bernalex> ttt_fff: what do you consider the best of erlang, and what do you consider the best of haskell? people value different things.
03:30:16 <Adeon> haskell is getting some of those features but erlang VM has some features that won't easily transfer to GHC
03:30:27 <ttt_fff> type checking + monads + purity of haskell + ... otp + hot reloading + lots of micro threads of erlang + let it crash philosphy
03:30:30 <ollef> joneshf-laptop: you could specialise the properties by giving their types, e.g. 'quickCheck (prop_Commut :: Int -> Int -> Bool)'
03:30:30 <Adeon> per-actor heap, resource limits
03:31:10 <ollef> joneshf-laptop: I haven't tried this, but with partial type signatures (a new extension in ghc 7.10) you might get away with e.g. 'quickCheck (prop_Commut :: Int -> _)'
03:31:57 <opqdonut> joneshf-laptop: make the properties take an additional argument that locks the type
03:32:14 <opqdonut> joneshf-laptop: and then do "quickCheck (prop_Assoc (undefined :: Int))" or so
03:33:19 <k0ral> ion: it seems 'genericShrink' cannot be used with a wrapper, as it expects all sub-elements to be an instance of Arbitrary, so this is a downside of the wrapper approach
03:36:31 <ollef> joneshf-laptop: or something that reads better: 'let intFun :: (Int -> a) -> Int -> a; intFun = id in quickCheck (intFun prop_Commut)'
03:37:55 <opqdonut> that's a good suggestion
03:41:22 <joneshf-laptop> opqdonut, that's not bad, since I actually have it as a phantom type in my property, maye i can just pass that in
03:43:45 <joneshf-laptop> crap, i guess not since it's a kind, not a type
03:51:44 <jophish> Where's haskell at the moment regarding units of measure? What package are all the cool kids using?
03:54:00 <joneshf-laptop> oh, i thinki found a neat way
03:55:04 <joneshf-laptop> `quickCheckMono :: Testable prop => (Mono -> prop) -> IO (); quickCheckMono = quickCheck`
04:14:07 <shiona_> is Numeric.Probability.Distribution outdated or just broken?
04:17:53 <pavonia> shiona_: Broken in what way?
04:18:02 <shiona_> I cannot install it
04:19:07 <shiona_> http://lpaste.net/132028
04:19:58 <pavonia> Outdated then
04:20:30 <shiona_> ok
04:21:53 <marchelzo_> does anyone know where I can find spock examples that use sessions?
04:22:13 <zacts> so I'm trying to decide between learning haskell, and erlang. my goals are mainly for learning, I have no application domain.
04:34:39 <jmcarthur> zacts: so your question is just about which one is more interesting?
04:35:16 <zacts> hm... I guess I should think about what my goals are, more specifically
04:35:30 <zacts> I guess I do want to apply my knowledge to projects too
04:38:13 <jmcarthur> zacts: i think unless you have some very specific projects in mind, i would recommend haskell. it's a lot more general purpose.
04:38:36 <zacts> ah that totally answers my question
04:38:40 <jmcarthur> that is, erlang can be used for nearly everything haskell can, but it's a lot harder to get there
04:38:41 <zacts> I think I'll go with haskell then
04:38:51 <jmcarthur> eh, "a lot" is unfair of me
04:38:56 <zacts> I would prefer more general purpose, than specific domain areas
04:39:23 <jmcarthur> cool, glad i hit the nail
04:39:29 <zacts> thanks! :-)
04:53:14 * hackagebot step-function 0.1.1.0 - Step functions, staircase functions or piecewise constant functions  http://hackage.haskell.org/package/step-function-0.1.1.0 (petterb)
04:53:27 <k0ral> zacts: I don't know about erlang, but I can say that one good thing about haskell is that it is general purpose AND it makes it possible to build very elegant DSLs in many fields as well
04:57:18 * frerich_ reads Java code "if( dlg != null && dlg.getScenarioView() != null && dlg.getScenarioView().getProgressLabel() != null ... )" and longs for the Maybe monad.
04:57:49 <barrucadu> frerich: If you can use Guava, and massively refactor things, there's the Optional class
05:22:47 <Althar> Hello all
05:25:15 <tongcx> hi guys, dumb question: if I want to say somebody is working like crazy, should I say "he's working fully-loaded" or something?
05:28:22 <ttt_fff> is there anyway, from haskell, to get bindings via ffi to numpy / julia ?
05:33:15 * hackagebot postgresql-query 1.2.0 - Sql interpolating quasiquote plus some kind of primitive ORM  using it  http://hackage.haskell.org/package/postgresql-query-1.2.0 (AlekseyUymanov)
05:40:02 <fvgvxmpv1> Is there a standard solution to print a NominalDiffTime something like this: "7h20m13s"?
05:40:44 <solatis_> fvgvxmpv1, you mean like a 'time duration' ?
05:42:29 <fvgvxmpv1> solatis_, indeed — googling 'time duration haskell' found formatting, which seems to do exactly what I want, thanks
05:42:51 <solatis_> sometimes all you need is the correct name for a thing :)
05:43:14 <solatis_> i know from c++ that what you described is called a 'time duration' there :)
05:54:13 <ollef> is there a way to get ghci to only show the first error message if there are several?
06:00:31 <fvgvxmpv1> I was wrong — formatting can print a NominalDiffTime as "1.003h" but I don´t see how to let formatters interact in to produce the desired result
06:07:27 <Gurkenglas> What library do you recommend for the algebraic derivative of lists?
06:10:46 <benzrf> hhhmmmmm is there a specific term for a GADT whose constructors put a constant phantom type as one of the result type arguments
06:11:00 <benzrf> like 'CharConstructor :: PhantomGADT Char'
06:15:50 <lpaste> isomorphic pasted “One thread better than four... ” at http://lpaste.net/8389020114996953088
06:16:45 <isomorphic> ^ -- I've made a reduced testcase that reproduces some behaviour I'm seeing - does anybody know why adding more threads (and not more work) would cause no speedup / increased GC activity? 
06:18:17 * hackagebot hoopl 3.10.1.0 - A library to support dataflow analysis and optimization  http://hackage.haskell.org/package/hoopl-3.10.1.0 (AndreasVoellmy)
06:43:10 <Haskellfant> Hey, I'm binding to a c library, that takes a huge nested struct of callbacks. Currently I have just replicated that struct in haskell and writting a storable instance and that works just fine. Now those callbacks mostly get some uintptrs and for obvious reasons I would like to newtype those to make it more safe. However I can't directly change the type of the callbacks as I get uintptrs from the c library.
06:43:12 <Haskellfant> Now I could replicate that giant struct again and then write a function that takes the type with the normal safe haskell functions and then creates the wrappers so that the newtype stuff all works out and passes the correct functions as callbacks. But that seems pretty ugly as I am basically duplicating that giant data type. Any ideas for a nice solution to this?
06:44:58 <Haskellfant> just to give you an idea this is the current haskell type http://lpaste.net/132031
06:58:52 <Althar93> Has anyone got any recommendations for learning Haskell by practice?
06:59:13 <Althar93> I've read a few books now, done exercises and a few mini projects but I still feel like I don't quite "get it"
07:01:09 <Sonderblade> Althar93: learnyouahaskell
07:01:22 <Althar93> yeah, already read this fabulous book several times
07:01:37 <obb> projecteuler.com
07:01:42 <obb> or .net
07:01:43 <obb> dunno
07:01:59 <fvgvxmpv1> Dyre doesn´t seem to play well with aeson for me
07:01:59 <fvgvxmpv1> I get this error message when trying to have dyre recompile: http://lpaste.net/132032
07:01:59 <fvgvxmpv1> Which seems to me blatantly false — the aeson version referenced does have an instance of ToJSON UTCTime (according to hackage, at least)
07:01:59 <fvgvxmpv1> Any Suggestions?
07:01:59 <Althar93> I guess my problem is that I have been coding in C++ for over 10 years, and although I really love Haskell and functional programming, I can never sit down and do anything useful with it
07:02:43 <benzrf> Althar93: thats typical
07:02:46 <benzrf> Althar93: look at it this way
07:02:47 <fvgvxmpv1> Oh, the line it´s complaining about is something is this: $(deriveJSON defaultOptions ''TimeBlock)
07:02:52 <kadoban> project euler isn't very good for learning programming. It's mostly about number theory and math in general, but some of the early problems can be done via brute-force if you really want.
07:03:02 <benzrf> Althar93: when you first started programming, ever, how long did it take to feel like you knew what you were doing and how to use your language properly?
07:03:15 <obb> i don't know about your skill but if you feel ready you could browse through the active haskell projects in the haskell wiki and join one or two
07:03:23 <benzrf> kadoban: yeah
07:03:32 <kadoban> Althar93: https://github.com/bitemyapp/learnhaskell <-- I'd do the exercises for cis194, if you haven't already, go through NICTA, and then just … force yourself to use haskell for a project. You have to just do it or you'll never get past the stage you are now.
07:03:38 <Althar93> it has been a while, but because it was all I knew at the time, I pushed forwards and did things
07:03:41 <obb> project euler is fantastic with haskell
07:03:41 <benzrf> kadoban: it always bugs me when people suggest project euler as a good resource for learning about programming
07:03:58 <benzrf> that's not really the mental muscle it's flexing :-\
07:04:05 <Althar93> with Haskell I am having fun coding algorithm and appreciate the simplicity of it, but I can never justify working on a project nad using Haskell over C++ for the moment
07:04:21 <exio4> Althar93: I would also suggest NICTA
07:04:53 <Althar93> I guess I'm looking for a little pet project to get me going and break this subconscious stubborness I have that I can only do usefull things with C++
07:04:58 <obb> can never justify working on a project nad using Haskell over C++ for the moment << wtf
07:05:13 <benzrf> Althar93: one of the things about haskell is that, like
07:05:44 <benzrf> Althar93: there's a ton of abstractions that ou have to learn entirely separately from the core language
07:05:47 <benzrf> kind of like design patterns
07:05:57 <benzrf> if you want to be able to use libraries
07:05:59 <exio4> benzrf: you don't have to!
07:06:02 <rom1504> obb: and
07:06:17 <kuribas> One of the things I like about haskell, is that others people's code is more readable, compared to C++.
07:06:19 <benzrf> haskell libraries are far more often nearly paradigms than other languages' libraries are
07:06:39 <obb> rom1504, ?
07:06:55 <Althar93> makes sense
07:06:56 <exio4> benzrf: you can probably re-implement the square wheel a few times in your code until you get tired and force yourself to learn the abstractions :p 
07:06:59 <kuribas> Because I don't have to make a mental picture of all the side-effects and dependencies.
07:07:05 <benzrf> exio4: hehehe
07:07:09 <benzrf> kuribas: heck yes
07:07:35 <rom1504> obb: nad -> and. But maybe you did see that ?
07:07:49 <benzrf> i tried to edit some c++ a few weeks ago to alter a feature in a FOSS program
07:08:04 <benzrf> it took me ages to figure out how the ambient state worked ;-;
07:23:48 <obb> that wasn't the reason for my wtf rom1504 :D
07:26:06 <nurupo> why IO monad is sometimes called "the mother of all monads"?
07:27:30 <geekosaur> it's not? that epithet is sometimes applied to Cont
07:29:00 <geekosaur> http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
07:38:19 * hackagebot xml-conduit 1.2.5 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.2.5 (MichaelSnoyman)
07:38:22 * hackagebot agentx 0.1.0.5 - AgentX protocol for write SNMP subagents  http://hackage.haskell.org/package/agentx-0.1.0.5 (chemist)
07:46:08 <benedikt> benzrf: thats not a case of "c++ is icky", its a case of you working in a language you are not used to, and in a project that is unfamiliar to you. 
07:53:20 * hackagebot opml-conduit 0.1.0.0 - Streaming parser/renderer for the OPML 2.0 format.  http://hackage.haskell.org/package/opml-conduit-0.1.0.0 (koral)
07:54:17 <dfeuer> quchen, what was so wrong with your explanation of how the free theorem for map relates to the functor laws that you had to take it down?
07:55:16 <quchen> dfeuer: I wasn't sure anymore whether the premise was correct. I heard rumors that in order to derive the free theorem for fmap, one needs the data constructor to be Functor, which makes deriving the second Functor law from the first circular.
07:56:06 <quchen> Then, a year or so later, edwardk published his article on the same subject, but he probably knows what he's talking about.
07:57:52 <dfeuer> quchen, I think you should put it back up, and add your comments about concerns.
07:58:20 * hackagebot xml-conduit 1.2.5.1 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.2.5.1 (MichaelSnoyman)
07:59:00 <quchen> dfeuer: Hm, I guess I could do that too. Back then I didn't have time at all for this so taking it down was simply the path of least resistence.
07:59:35 <dfeuer> I went looking for it, because I remember it having existed, and it took me *loads* of digging to pull it out of github....
08:00:03 <quchen> Arr yeah sorry about that. Pretty bad practice there from my side.
08:01:35 <dfeuer> Apology accepted!
08:02:04 <dfeuer> quchen, you can make up for it by helping me implement verified lazy finger trees in Idris :-P
08:02:55 <quchen> dfeuer: Suggestion noted ;-)
08:04:16 <quchen> Writing Haskell is mostly a means to an end for me right now, namely maintaining mental health. I guess I could try Idris for that as well.
08:04:30 <dfeuer> Ha!
08:05:05 <quchen> On the other hand, I'd like to make some practical use of the STG paper I've been reading for a couple of days while on the bus to work first.
08:05:15 <dfeuer> :)
08:05:18 <quchen> And then do this other project and then this other other project. You see where this is going ;-)
08:11:25 <Zemyla> That was a weird dream.
08:11:54 <Zemyla> I dreamed that I trapped a magical monster first in a meteorite prison, then in an opaque monad.
08:12:07 <Fuuzetsu> seems like haskell-blah material :)
08:12:20 <Zemyla> There's a haskell-blah?
08:12:33 <Fuuzetsu> There is!
08:12:34 * geekosaur knows there's a lot of crossover between ##crawl and #haskell but a Zin monad seems a bit extreme even for that
08:13:09 <quchen> dfeuer: Here you go, https://github.com/quchen/articles/blob/master/second_functor_law.md
08:13:42 <Fuuzetsu> I can't not think of the ‘trapped in the IO monad’ lambdacat.
08:16:53 <dfeuer> Thanks, quchen!
08:17:42 <quchen> dfeuer: Patches welcome! (And knowledgeable remarks as well of course)
08:18:07 <dfeuer> quchen, I'll be happy to patch, but don't expect knowledge.
08:19:37 <fr33domlover> is it possible that the code compiles, but I get a parse error from haddock?
08:19:43 <quchen> You're in Idris land, so you must be knowledgeable.
08:19:48 <fr33domlover> is this invalid: http://pamrel.lu/5b8e5/
08:19:54 <Fuuzetsu> fr33domlover: it is possible
08:20:19 <quchen> Invalid Haddock comments can do that, yes
08:20:21 <Fuuzetsu> fr33domlover: you can't document separate fields of a constructor, you unfortunately either have to do it on the constructor itself or use a record
08:20:25 <Fuuzetsu> or patch GHC
08:20:49 <quchen> Fuuzetsu: Why GHC? Isn't this a Haddock shortcoming?
08:21:11 <Fuuzetsu> No, Haddock doesn't deal with actually extracting comments from source, it's all done by GHC
08:21:38 <Fuuzetsu> which is why if you want to allow comments somewhere new or don't want it to error out when comment is misplaced, you get to patch GHCp
08:22:48 <fr33domlover> Fuuzetsu, thanks
08:23:06 <fr33domlover> I'm not sure a beginner like can patch GHC in reasonable time :P
08:23:13 <fr33domlover> *like me
08:23:20 <Fuuzetsu> Have to start somewhere.
08:23:36 <Fuuzetsu> there are some patches that turn the error into warning already too, they just need finishing up
08:24:02 <nurupo> is there a way to turn GC off in GHC?
08:24:18 <Fuuzetsu> check the RTS options
08:24:35 <Fuuzetsu> I don't think you can completely turn it off but you can set it to GC much less frequently
08:24:41 <quchen> Fuuzetsu: Ah, so GHC's parser keeps some comments in the AST, and discards others?
08:24:48 <Fuuzetsu> quchen: right
08:24:51 <nurupo> carter: thanks!
08:24:53 <dfeuer> nurupo, if you do that, you will run out of memory in no time flat, unless you are doing something very unusual, and being very ccareful about it.
08:25:06 <elfeck> heyoh does someone know how to perform a "manual" persistent SQLite migration (e.g. column name change)?
08:25:09 <nurupo> dfeuer: yes, i know
08:25:10 <Fuuzetsu> quchen: it's ugly but if I think about trying to match up what comment goes to what identifier I get ill
08:25:13 <merijn> fr33domlover: Got start sometime! ;)
08:25:14 <quchen> Fuuzetsu: I guess an *A*ST should not need to keep comments, but for Haddock it would be nice to have the actual syntax tree
08:25:36 <merijn> fr33domlover: To be honest, hacking GHC is easier than it appears (depending on which part)
08:25:36 <dfeuer> Comments are very wild.
08:25:57 <quchen> --# syntax for pragmas would also be a pretty cool thing.
08:26:07 <quchen> And maybe an easier entry point.
08:26:17 <Fuuzetsu> no, stop
08:26:19 <Fuuzetsu> we want to remove that
08:26:27 <Fuuzetsu> it's already a thing
08:26:32 <dfeuer> ???
08:26:34 <quchen> It is?!
08:26:37 <indiagreen> what
08:26:38 <Fuuzetsu> god damn
08:26:40 <merijn> wut
08:26:41 <Fuuzetsu> I shouldn't have said anything
08:26:51 <quchen> Fuuzetsu: TOO LATE arming my lobby
08:27:13 <Fuuzetsu> https://ghc.haskell.org/trac/ghc/ticket/8226
08:27:24 <quchen> Fuuzetsu: But really, what's wrong with it? This is your chance to make me not use it, because otherwise I *will* switch all my pragmas to that style.
08:27:38 <Fuuzetsu> where obviously ‘I'll patch it out tomorrow’ means it's 20 months later and I still haven't
08:27:47 <Fuuzetsu> quchen: it's only Haddock pragmas
08:27:48 <merijn> Fuuzetsu: Whoo!
08:28:00 <merijn> Fuuzetsu: Sounds like my sort of patching ;)
08:28:06 <quchen> Fuuzetsu: Ohhh, no I meant GHC --# style pragmas.
08:28:13 <quchen> In Haddock alone I agree that it's nonsense.
08:28:14 <merijn> I think I promised Peaker a patch for bracket and I stil haven't >.>
08:28:19 <fr33domlover> merijn, I'll give it a try sometime then
08:28:29 <quchen> merijn: Patch for bracket?
08:28:39 <quchen> That issue where bracket can leak in certain circumstances?
08:28:46 <quchen> I vaguely remember a discussion about that.
08:29:03 <merijn> quchen: Masking the cleanup, yes
08:29:22 <merijn> fr33domlover: Lucky for you, I wrote a quick-start guide for that! ;)
08:29:25 <quchen> Isn't the cleanup masked already?
08:29:30 <merijn> fr33domlover: https://gist.github.com/merijn/c01405e6c5a78a1c4ccb
08:29:33 <merijn> quchen: No
08:30:07 <quchen> bracket is something like mask $ \restore -> do restore thing `onException` finalStuff >> finalStuff, isn't it?
08:30:19 <quchen> So only thing is unmasked
08:30:53 <merijn> quchen: No, because the handler runs outside of that masked when it's async'ed
08:31:02 <quchen> Fuuzetsu: "I'll hopefully send in patches removing these from the lexer/parser tomorrow" ;-P
08:31:13 <Fuuzetsu> “hopefully”!
08:31:23 <merijn> quchen: Oh, wait, yeah, I remember what the exact problem is
08:31:40 <quchen> merijn: I don't understand. To me it looks like everything is in mask.
08:31:42 <quchen> http://hackage.haskell.org/package/base-4.8.0.0/docs/src/Control-Exception-Base.html#bracket
08:31:46 <merijn> quchen: It's only masked, not uninterruptibleMasked, so MVar or other blocking operations can be interrupted
08:32:17 <quchen> merijn: Hm, I don't understand uninterruptibleMask enough to judge this issue.
08:32:39 <quchen> But you're saying that bracket should use mask first, and then uninterruptibleMask for the cleanup?
08:33:45 <quchen> The problem with bracket right now that I'm aware of is that the release action must not block, which seems related here.
08:34:33 <benzrf> benedikt: the point is that it was harder to figure out the workings of a new project because it was c++
08:34:33 <merijn> quchen: Right, blocking operations implicitly remove the mask
08:34:45 <benzrf> benedikt: i am fairly sure it would have been easier if it were haskell, regardless of my familiarity
08:35:11 <quchen> merijn: Ah, I understand. That's strange, almost feels like a side effect, where a subroutine can change the behaviour of its parent.
08:35:35 <merijn> quchen: Ostensibly it's too avoid deadlocks when operating on MVars, for example
08:36:03 <merijn> But the argument from Peaker and me was that while interrupting allocation is acceptable, the cleanup of something allocated should *never* be interrupted
08:36:37 <quchen> merijn: Well, arguably. Suppose the cleanup sends a message to a logging thread via a Chan …
08:37:04 <quchen> And someone is evil and blocks the chan, the logging can't be sent, the release action blocks, bracket blocks
08:37:13 <merijn> You can't block Chans
08:37:21 <quchen> Well then make it an MVar instead of a Chan
08:37:49 <quchen> And an evil logger thread. I don't know a good example, but I can imagine there are reasons for nuking the release action sometimes.
08:38:08 <quchen> But I also think your point is a good one.
08:39:29 <mjrosenb> does the documentation generated by haddock have an 'all in one page' view?
08:39:43 * mjrosenb finds it supremely annoying to navigate the per-module format.
08:40:04 <merijn> mjrosenb: I don't think so, but it generates an alphabetized index page
08:40:53 <nak> is there a way to search for existing functions?
08:40:55 <mjrosenb> right, but that is not useful for 'I wish to load all of the docs for this, then go into a coffee shop that doesn't have wifi'
08:40:59 <merijn> nak: Hoogle?
08:41:08 <mjrosenb> nak: hoogl, hayoo
08:41:10 <nak> merijn i should've been more specific lol
08:41:12 <mjrosenb> *hoogle
08:41:17 <nak> can i search by type signature ?
08:41:24 <merijn> mjrosenb: If you enable it in your cabal config it will install local docs for packages
08:41:25 <nak> e.g., String -> Integer
08:41:25 <quchen> nak: Yes.
08:41:27 <merijn> nak: Hoogle :p
08:41:30 <nak> awesome ok
08:41:35 <merijn> @hoogle Int -> a -> [a]
08:41:36 <lambdabot> Prelude replicate :: Int -> a -> [a]
08:41:36 <lambdabot> Data.List replicate :: Int -> a -> [a]
08:41:36 <lambdabot> Prelude drop :: Int -> [a] -> [a]
08:41:38 <mjrosenb> @hoogle (a -> b) -> [a] -> b
08:41:38 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
08:41:38 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
08:41:38 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
08:41:44 <Fuuzetsu> you can also download the tarball with the docs off Hackage IIRC
08:41:48 <Fuuzetsu> I forget the incantation though
08:42:03 <nak> @hoogle [a] -> Int
08:42:03 <lambdabot> Prelude length :: [a] -> Int
08:42:04 <lambdabot> Data.List length :: [a] -> Int
08:42:04 <lambdabot> Prelude head :: [a] -> a
08:42:21 <nak> hmm
08:42:43 <mjrosenb> merijn: it seems a bit silly to grab the whole tarball just to get the docs, but that works
08:42:43 <nak> ok so i just want to do "123" -> 123
08:42:47 <S11001001> mjrosenb: as merijn is alluding to, I think, the local haddock, as created you have set documentation: True in your cabal config, generates a total index of all installed packages.
08:42:50 <mjrosenb> stillkind of annoying to navigate
08:42:53 <mjrosenb> nak: read.
08:42:54 <Iceland_jack> > read "123" :: Int
08:42:55 <Fuuzetsu> nak: read or readMaybe
08:42:56 <lambdabot>  123
08:43:04 <nak> oo
08:43:07 <Fuuzetsu> @hoogle String -> Int
08:43:08 <lambdabot> Test.HUnit.Base Label :: String -> Node
08:43:08 <lambdabot> Test.QuickCheck.Test labelPercentage :: String -> State -> Int
08:43:08 <lambdabot> Prelude error :: [Char] -> a
08:43:15 <Fuuzetsu> didn't think so :)
08:43:15 <nak> > readMaybe "hello" :: Int
08:43:17 <lambdabot>  Not in scope: ‘readMaybe’
08:43:24 <Fuuzetsu> Text.Read IIRC
08:43:27 <Iceland_jack> nak: It's not in lambdabot but it's in Text.Read.readMaybe
08:43:27 <merijn> Yes
08:43:31 <nak> gotcha
08:43:33 <merijn> :t Text.Read.readMaybe
08:43:34 <lambdabot> Read a => String -> Maybe a
08:43:41 <mjrosenb> S11001001: oh, I assume that means that I need to re-install everything after I set that bit?
08:43:44 <merijn> It is in lambdabot, just not directly :p
08:43:53 <Iceland_jack> Well you can't use it afaik
08:43:53 <S11001001> mjrosenb: yeah, but it's worth it.
08:43:53 <dmj`> > Text.Read.readMaybe "123" :: Maybe Int
08:43:54 <nak> is there a reason `read` doesn't show up in the search for [a] -> Int ? 
08:43:54 <Iceland_jack> > Text.Read.readMaybe "hello" :: Maybe Int
08:43:55 <lambdabot>  Not in scope: ‘Text.Read.readMaybe’
08:43:55 <lambdabot>  Not in scope: ‘Text.Read.readMaybe’
08:44:12 <merijn> mjrosenb: Yeah, I think it's silly that it's off by default, first thing I do in cabal is enable documentation and profiling
08:44:15 <mjrosenb> S11001001: if I install a package only in a sanbox, do I get global docs for it?
08:44:25 <Fuuzetsu> nak: because that's not its type
08:44:30 <S11001001> mjrosenb: for one thing, you know that when you look at a doc, it's for the version of the package you actually have installed.  And when you follow a cross-reference by clicking on a symbol, you know it's taking you to the doc for the version you have installed.  
08:44:32 <merijn> nak: Because it has type "Read a => String -> a"
08:44:49 <dmj`> Iceland_jack: strange how :t works for Text.Read.readMaybe... but can't be used
08:45:05 <S11001001> mjrosenb: when you install in a sandbox it builds a sandbox-specific haddock area, inside the sandbox
08:45:08 * dmj` stares awkwardly at lambdabot 
08:45:12 <Iceland_jack> Qui lambdabot ferit lambdabot perit
08:45:26 <jophish> Ahh, it's such a pain sometimes not being able to start names with an uppercase letter
08:45:38 <Fuuzetsu> _Foo
08:45:43 <S11001001> mjrosenb: with docs for global packages and sandbox packages only
08:45:45 <Iceland_jack> jophish: It's possible with pattern synonyms now
08:45:49 <jophish> the sometimes being, translating some maths which uses m_1 m_2 and M
08:45:52 <indiagreen> nak: it does show up for “String -> Int”, but pretty low
08:45:54 <Iceland_jack> But it may not be a reasonable thing to do depending on your use
08:45:54 <S11001001> mjrosenb: thus reflecting what you actually have available in the sandbox
08:46:08 <mjrosenb> sweet.
08:46:24 <mjrosenb> now I just need to get browsing this in emacs to not be annoying.
08:46:51 <mjrosenb> ok, where is this config file, ~/.cabal/config?
08:47:08 <dgpratt> can lambdabot google?
08:47:19 <Iceland_jack> @google can lambdabot google?
08:47:20 <lambdabot> https://wiki.haskell.org/Lambdabot
08:47:31 <dgpratt> thanks, Iceland_jack
08:47:38 <S11001001> mjrosenb: yeah you should see documentation: commented out, just uncomment and set to True
08:48:58 <jophish> Iceland_jack: How can one do that with pattern synonyms for something like: (-246.1829972672843) (-119.26091814051667) 17.64060068966489
08:49:08 <jophish> err, something like longitudeOfPeriapsis = Ω + ω where Ω = longitudeOfAscendingNode; ω = argumentOfPeriapsis
08:49:36 <Iceland_jack> jophish: in that case it doesn't really make sense
08:50:02 <S11001001> mjrosenb: given sufficiently new cabal, it should then put doc/<platform>/ in your .cabal-sandbox, I usually open frames.html from that in the browser
08:50:13 <Iceland_jack> jophish: Possibly if Ω is a constant though 
08:50:29 <jophish> Iceland_jack: sadly not. I guess I settle for "lan"
08:50:37 <Iceland_jack> Then you can do
08:50:37 <Iceland_jack>     pattern Ω :: Int
08:50:37 <Iceland_jack>     pattern Ω = 1234
08:50:58 <Iceland_jack> which also lets you pattern match on Ω
08:51:47 <Iceland_jack> but I wouldn't advise doint something like that just to follow the maths notation 
08:51:57 <mjrosenb> hrmm, I'll have to write some sort of shell script to open this for me automatically
08:52:19 <mjrosenb> actually, I strongly suspect that haskell-mode can do this already.
08:52:23 <jophish> Iceland_jack: yeah, it would be a little peculiar
08:52:32 <Iceland_jack> *doing
08:54:05 <nak> ah ok thanks indiagreen merijn 
08:54:44 <mjrosenb> ok, re-building my entire sandbox on battery sounds like a good way to cut my hacking short.
08:55:18 * hodapp observes that he has 31 lines of imports.
08:55:19 <hodapp> hmmmm.
08:56:22 <srhb> hodapp: Time for a ProjName.Imports module? :P
08:56:54 <hodapp> perhaps, perhaps
08:57:14 <hodapp> most of my modules have pretty minimal imports, but 2 or 3 of them tie together a lot of other functionality
08:57:14 * bennofs has 32 in one file he just opened
08:57:38 <bennofs> ~10 imports is pretty normal for my code :=)
08:58:31 <Fuuzetsu> I consider anything less than 10 as a small module
08:58:40 <mjrosenb> bennofs: ou're familiar with Reactive.Banana, aren't you?
08:58:48 <bennofs> mjrosenb: a little bit
08:59:37 <bennofs> mjrosenb: I started writing a lib for using it with hsqml, but haven't finished that yet (I wanted to reimplement an app I wrote with the lib, but I didn't get to that)
09:00:52 <mjrosenb> wok, question to everyone, there is (<@>) :: Behavior t (a->b) -> Event t a -> Event t b
09:01:46 <mjrosenb> Is there any reason the similar looking foo :: Behavior t (a-> IO b) -> Event t a -> Event t b can't be written?
09:02:17 <Fuuzetsu> trying to escape IO are we ;)
09:02:46 <bennofs> mjrosenb: you can do that using Reactive.Banana.Frameworks.execute I believe. But the idea is probably that non-framework code should not do IO
09:03:23 * hackagebot smaoin 0.1.0.0 - Utilities for the Smaoin semantic information model.  http://hackage.haskell.org/package/smaoin-0.1.0.0 (akrasner)
09:03:25 * hackagebot clash-prelude 0.7.4 - CAES Language for Synchronous Hardware - Prelude library  http://hackage.haskell.org/package/clash-prelude-0.7.4 (ChristiaanBaaij)
09:05:14 <mjrosenb> bennofs: yeah, but this would be super-useful, I have some code that I'm calling reactimate on, which of course does IO, but there is a lot of data that is pretty expensive to create, which is only a function of some subset of the inputs
09:05:18 <iamarto> hi everyone 
09:05:49 <mjrosenb> and can be cached (or stored in an event/behavior)
09:06:03 <tulcod> mjrosenb: reactive-banana I think assumes that you are working in IO. for a more general example, look at the recent "reflex" library, which generalizes to any instance of of (MonadHold t (PushM t), MonadSample t (PullM t), Functor (Event t), Functor (Behavior t))
09:06:35 <mjrosenb> e.g. I am rendering something to a screen, and need a temp buffer the size of the widget, and it makes more sense to only generate this when the widget is resized
09:07:04 <mjrosenb> rather than allocating a temp buffer *every* time I go to render it.
09:07:13 <tulcod> mjrosenb: yes, it would make sense to make that into a behavior.
09:08:20 <iamarto> charName :: Char -> String
09:08:58 <mjrosenb> tulcod: but it looks like I'll have to write a lot of that behavior myself.
09:09:09 <iamarto> charName '[a-z]' = "Print a sentence "
09:09:27 <iamarto> its not working any help?
09:09:29 <tulcod> mjrosenb: what do you mean? given some change event it generates a buffer
09:09:34 <mjrosenb> bennofs: yeah, I was kind of hoping to avoid rolling my own.
09:09:41 <Fuuzetsu> iamarto: '[a-z]' is not a character
09:09:46 <mjrosenb> tulcod: generating the buffer is in IO.
09:09:49 <iamarto> sorry to interrupt I'm new to haskell
09:10:06 <Fuuzetsu> ‘charName c | c `elem` ['a' .. 'z'] = …’ might be more what you want
09:10:10 <mjrosenb> imalsogreg: THIS IS VERY SERIOUS BUSINESS!
09:10:38 <iamarto> Thanks Fuuzetsu
09:12:34 <iamarto> Awesome its working 
09:12:43 <tulcod> mjrosenb: while i'm unfamiliar with reactive-banana, reactimate indeed sounds like what you're looking for.
09:14:07 <mjrosenb> tulcod: right, I'd have to have an explicit IO, which triggers another event with the created buffer
09:14:19 <fread2281> :k (:)
09:14:20 <lambdabot> parse error on input ‘:’
09:14:27 <fread2281> ?
09:14:34 <tulcod> mjrosenb: I mean i guess the problem why this is cumbersome is that reactive-banana sort of assumes everything inside your network is pure, while the generated events might not be
09:14:42 <mjrosenb> I've avoided explicitly triggering events thusfar, and kind of want to continue doing so.
09:14:43 <fread2281> how can I use [] w/ DataKinds?
09:15:00 <Fuuzetsu> '[] IIRC
09:15:03 <Fuuzetsu> and ':
09:15:15 <Fuuzetsu> don't remember the details
09:15:25 <tulcod> fread2281: (:) is not a type constructor, so :k (:) doesn't make sense
09:15:30 <mjrosenb> since that will introduce additional delays, and possibly make simultaneous events not-simultaneous anymore.
09:15:55 <merijn> tulcod: * except when you enable the right extensions ;)
09:16:03 <mjrosenb> tulcod: does reflex have some way of purifying IO?
09:16:07 <merijn> You don't need quotes
09:16:17 <tulcod> merijn: doesn't that excuse apply to all answers in this channel? :P
09:16:18 <merijn> fread2281: Oh, I have an example for you
09:16:25 <ezyang> Supposing I have a construct K :: Int -> Int -> K, is there a way to use gunfold to fill in two /different/ values for the first Int and the second Int? 
09:16:33 <merijn> tulcod: Well, considering fread2281 mentioned DataKinds which is the exact relevant extension...
09:16:36 <fread2281> yep, quotes was what I needed
09:16:53 <tulcod> merijn: okay you are right :)
09:16:55 <merijn> fread2281: Heterogeneous list using type level list: https://gist.github.com/merijn/dc00bc7cebd6df012c5e
09:17:02 <fread2281> just haven't used it in a while
09:17:41 <tulcod> mjrosenb: let me look at some examples and see what I can tell you...
09:17:58 * mjrosenb guesses he could always use a mutable reference, and just have an Event t (IO b), which caches its value
09:18:08 <mjrosenb> then I need to write the caching, and get it correct.
09:25:26 <kaidelong> so once I have something build in the sandbox, can cabal be made to put the resulting binary in it's bin dir so it's on my path?
09:25:38 <srhb> kaidelong: No, you'll have to do that yourself
09:27:00 <kaidelong> also I don't have to worry about --force-reinstalls with a sandbox, right?
09:27:07 <kaidelong> if something does break, there's cabal sandbox delete
09:27:23 <tulcod> mjrosenb: bah, I can't spot a quick solution in reflex either, but tbh i'm not really familiar with that either
09:27:30 <srhb> kaidelong: Yep.
09:29:40 <mjrosenb> tulcod: not the end of the world.
09:30:09 <mjrosenb> tulcod: this guy? https://hackage.haskell.org/package/reflex
09:30:13 <tulcod> yes
09:30:20 <kaidelong> okay well
09:30:22 <mjrosenb> ok, I'll keep that in mind.
09:30:29 <kaidelong> it has occured to me, why not use makefiles?
09:30:42 <tulcod> mjrosenb: the only real documentation so far consists of the youtube videos https://www.youtube.com/watch?v=mYvkcskJbc4 and https://www.youtube.com/watch?v=3qfc9XFVo2c
09:30:43 <kaidelong> you have a clean (delete, reinitialize sandbox)
09:30:54 <mjrosenb> I didn't see that when I looked for FRP libraries a while back.
09:30:58 <tulcod> mjrosenb: (but it looks pretty exciting so check it out :P)
09:31:02 <kaidelong> you have a build (make a sandbox if it doesn't exist, build the dependencies to it, then build the program)
09:31:03 <tulcod> no it's pretty new
09:31:11 <tulcod> no, not "pretty" new. it *is* new.
09:31:15 <kaidelong> and you have an install (copy the stuff out of the local bin into one in the path)
09:31:49 <exfalso> hi i'm trying to heap profile a ghc executable. I linked with -rtsopts and compiled with profiling turned on. I start the process and as it is a server i need to SIGTERM it. I think this causes the profiling to not be printed. Any ideas on how to fix this? Is there maybe a way to "stream" the profile?
09:32:29 <tulcod> kaidelong: makefiles don't "have" a clean. makefiles are just a way to encode a number of scripts.
09:32:44 <tulcod> kaidelong: you're probably thinking of autoconf and friends, which are terrible and should be removed from this planet
09:33:15 <tulcod> kaidelong: also, cabal does much more than just run some compilers. so it's hard to compare, really
09:33:20 <kaidelong> tulcod: no, I'm definitely thinking of makefiles, even if they don't have a special notion of a clean, clean is a mnemonic for one of the names of the scripts in a makefile
09:33:34 <kaidelong> you'd be invoking cabal in the makefile
09:33:47 <tulcod> ah. well you're free to write your own makefiles for invoking cabal, if that's what you mean
09:34:10 <kaidelong> I'm not sure how autotools would interact with Haskell
09:34:12 <kaidelong> probably not well
09:35:58 <tulcod> mjrosenb: i have the feeling it is possible in reflex, see e.g. https://github.com/ryantrinkle/reflex-dom/blob/master/src/Reflex/Dom/Xhr.hs
09:36:15 <tulcod> mjrosenb: (in particular persomRequestAsync)
09:37:25 * mjrosenb looks
09:38:04 <tulcod> mjrosenb: the magic is in performEventAsync, https://github.com/ryantrinkle/reflex-dom/blob/master/src/Reflex/Dom/Class.hs
09:38:19 <tulcod> (I think)
09:38:30 * hackagebot clash-lib 0.5.3 - CAES Language for Synchronous Hardware - As a Library  http://hackage.haskell.org/package/clash-lib-0.5.3 (ChristiaanBaaij)
09:43:30 * hackagebot clash-systemverilog 0.5.3 - CAES Language for Synchronous Hardware - SystemVerilog backend  http://hackage.haskell.org/package/clash-systemverilog-0.5.3 (ChristiaanBaaij)
09:43:32 * hackagebot clash-ghc 0.5.5 - CAES Language for Synchronous Hardware  http://hackage.haskell.org/package/clash-ghc-0.5.5 (ChristiaanBaaij)
09:53:42 <bennofs> mjrosenb: you can do \b a -> execute (fmap (FrameworksMoment . liftIO) $ b <@> e) :: Frameworks t => Behavior t (a -> IO b) -> Event t a -> Moment (Event t b)
10:00:26 <tulcod> bennofs: nice
10:00:33 <tulcod> not pretty, but nice
10:01:10 <tulcod> bennofs: ("b <@> e" should be  "b <@> a" no?)
10:01:27 <bennofs> tulcod: oh right, forgot to rename the parameter (why did I name it a?!)
10:15:54 <dgpratt> there you go again, edwardk, turning my brain to mush
10:16:42 <dgpratt> so WP has this to say about 'Semigroup action': "In algebra and theoretical computer science, an action or act of a semigroup on a set is a rule which associates to each element of the semigroup a transformation of the set in such a way that the product of two elements of the semigroup (using the semigroup operation) is associated with the composite of the two corresponding transformations."
10:17:19 <dgpratt> now normally faced with such daunting and unfamilar language, I would just give up and move on
10:17:35 <dgpratt> but I'm feeling slightly more determined than usual
10:18:44 <dgpratt> so can anyone tell me, for example, should I read this as "an action or act of (a semigroup on a set)" or "(an action or act of a semigroup) on a set"?
10:19:31 <dgpratt> in other words, is "a semigroup on a set" a thing? if so, what does "on" mean in this context?
10:21:02 <shachaf> A semigroup acts on a set.
10:21:37 <schell> what’s the best type to represent the Reals? Double? Float?
10:21:41 <merijn> dgpratt: Ok, so you know what a set is, right? A "semigroup on a set" is the mathy way of saying "we have an associative operation and a set of elements it works on"
10:22:24 <shachaf> merijn: That is not the usage here.
10:22:44 <merijn> Ugh, I should've read the above quote before answering the smaller one :p
10:23:12 <shachaf> schell: Double isn't very much like the reals.
10:23:18 <dgpratt> crap, what merijn said almost made sense
10:23:36 <schell> shachaf: because of limited precision?
10:23:49 <merijn> schell: What do you plan to do with said reals?
10:23:54 <shachaf> schell: There's always CReal, which probably represents the reals better than any other type. But I doubt you want to use it in practice.
10:24:17 <dgpratt> considering the phrase "each element of the semigroup", it makes it sound like semigroup *is* a set
10:24:21 <schell> merijn: i’m playing around with continuous time FRP
10:24:39 <schell> shachaf: yeah - so far Double has worked, maybe Float is better though?
10:24:41 <merijn> dgpratt: A semigroup *is* a set, it's a set + an associative operation
10:24:51 <merijn> schell: Float is *less* precise than Double
10:25:32 <shachaf> Before understanding semigroup actions, you should understand semigroups.
10:25:32 <dgpratt> merijn, is this distinct from the set that this hypothetical semigroup is said to be "on"
10:25:43 <merijn> dgpratt: Baffles me :)
10:25:43 <schell> merijn: oh! i guess i thought the point of Float is that it could *float* around and offer better precision at a space cost
10:26:04 <schell> fundamental misunderstanding
10:26:04 <shachaf> dgpratt: I already said, the semigroup isn't "on" the set.
10:26:09 <merijn> schell: No, Float corresponds to standard float as in C
10:26:19 <merijn> schell: Double is "double-precision floating point"
10:26:37 <schell> merijn: thanks - then i guess double it is!
10:26:42 <tulcod> schell: the best way to represent the mathematical reals is as a subset of sequences of rational numbers. anything else depends on your application.
10:26:46 <dgpratt> shachaf, oh, I missed that
10:27:07 <tulcod> schell: if really you are just working with some clock input, then you may want to represent that by some really big integer
10:27:08 <dgpratt> so the correct interpretation is "(an action or act of a semigroup) on a set" ?
10:27:21 <shachaf> The semigroup acts on a set.
10:27:45 <schell> tulcod: thanks - i’ll play around with it a bit
10:27:54 <shachaf> First understand semigroups, and monoids and groups while you're at it. You should know the difference between all those things and sets.
10:28:04 <tulcod> dgpratt: i think mathematicians would say a semigroup *is* a set (namely of its semigroup elements), where the elements act on eachother using the semigroup action
10:28:07 <shachaf> Then maybe look up "group action" -- there's probably a lot more written about it.
10:28:31 <shachaf> A semigroup isn't a set unless you're a set theorist and think everything is a set.
10:28:40 <bdesham> Is there an "append" operator for Data.Text that works like ++ does for String?
10:28:48 <bdesham> (I.e. something more terse than "Text.append")
10:28:53 <merijn> bdesham: <> ?
10:28:56 <merijn> Text is a monoid
10:28:57 <tulcod> shachaf: well even in type theory they would define a semigroup as something with an underlying type (aka set)
10:28:59 <merijn> :t (<>)
10:29:00 <shachaf> bdesham: (Data.Monoid.<>)
10:29:00 <lambdabot> Monoid m => m -> m -> m
10:29:13 <shachaf> Sure, it has an underlying set. But it isn't a set.
10:29:22 <dgpratt> shachaf, but part of the structure of a semigroup is a set, correct? (I hope)
10:29:32 <tulcod> shachaf: :-/ ookay, it is a tuple of a set and an action
10:29:36 <tulcod> satisfying certain constraints
10:29:45 <shachaf> It's an abstract type.
10:30:02 <tulcod> shachaf: maybe in your perspective you are technically correct, but this is not helping dgpratt 
10:30:15 <bdesham> merijn shachaf: thanks
10:30:15 <shachaf> tulcod: "semigroup action" is not the multiplication operation of the semigroup.
10:30:27 <shachaf> tulcod: The elements don't "act on eachother".
10:30:58 <tulcod> shachaf: how do the elements not act on eachother by left (or right) semigroup multiplication?
10:31:27 <shachaf> You mean the action of a semigroup on its underlying set specifically?
10:31:42 <tulcod> dgpratt: another try: you specify a semigroup by specifying a collection of elements, and a binary function to combine those elements, satisfying certain constraints
10:32:15 <dgpratt> not in a very deep way, but I *think* I understand what a semigroup is
10:33:32 * hackagebot Yampa 0.9.7 - Library for programming hybrid systems.  http://hackage.haskell.org/package/Yampa-0.9.7 (IvanPerez)
10:33:34 * hackagebot yesod-transloadit 0.1.2.0 - Transloadit support for Yesod  http://hackage.haskell.org/package/yesod-transloadit-0.1.2.0 (boblong)
10:33:45 <dgpratt> at present, I'm just trying to confirm that in the description I started with, "set" always refers to the underlying set of the semigroup or something else
10:33:56 <shachaf> It refers to a different set.
10:34:07 <dgpratt> ok, that's helpful
10:34:54 <shachaf> You should read the "formal definition" part of the Wikipedia page you mentioned.
10:34:57 <shachaf> "Let S be a semigroup. Then a (left) semigroup action (or act) of S is a set X together with an operation"
10:34:59 <Iceland_jack> dgpratt: If you're asking about semigroup actions, make sure you understand semigroups first
10:35:36 <dgpratt> WP says "a semigroup is an algebraic structure consisting of a set together with an associative binary operation"
10:35:39 <Iceland_jack> Semigroups are simple but IRC is can make simple things hard
10:35:43 <Iceland_jack> -is
10:35:43 <dgpratt> that doesn't sound very complicated
10:36:21 <dgpratt> if that statement makes sense to me, do I understand semigroups well enough to understand semigroup actions?
10:36:33 <shachaf> Sure.
10:36:35 <Iceland_jack> Do you know examples of semigroups?
10:36:36 <dgpratt> ok
10:36:43 <dgpratt> Sum
10:36:45 <dgpratt> Product
10:36:57 <dgpratt> strings with concatentation
10:36:58 <tulcod> dgpratt: sum and product are the actions. what are the udnerlying sets?
10:37:02 <dgpratt> Int
10:37:15 <shachaf> tulcod: What?
10:37:15 <dgpratt> or Num a => a, I guess
10:37:15 <tulcod> dgpratt: can you have a different udnerlying set on the same action?
10:37:26 <tulcod> errr, not action
10:37:29 <tulcod> the, whatever, binary thing
10:37:50 <Iceland_jack> dgpratt: I'm writing a blog post about semigroup actions, if you're interested pay attention to r/haskell over the coming months
10:37:52 <tulcod> "semigroup law" says wikipedia
10:38:19 <tulcod> dgpratt: you picked Int as an underlying set making Sum into a "semigroup law". can you imagine a different underlying set?
10:38:32 * hackagebot BCMtools 0.1.1 - Big Contact Map Tools  http://hackage.haskell.org/package/BCMtools-0.1.1 (kaizhang)
10:38:59 <shachaf> sigh
10:39:12 <dgpratt> tulcod, not sure what you're getting at
10:39:21 <tulcod> dgpratt: okay, you say that (Int, Sum) is a semigroup, right?
10:39:36 <shachaf> No.
10:39:39 <dgpratt> with some operation
10:39:49 <dgpratt> oh, nvn
10:39:52 <dgpratt> *nvm
10:40:06 <shachaf> (Sum Int, (+) :: Int -> Int -> Int) is a semigroup, if that's the sort of definition of semigroup you're using.
10:40:24 <dgpratt> that makes sense
10:40:35 <tulcod> okay, can you pick something else than Int, still getting a semigroup?
10:40:56 <shachaf> (Sum Word, (+) :: Word -> Word -> Word) is another semigroup, which has a different underlying set and a different operation.
10:41:07 <shachaf> I have no idea what you're getting at if you're not trying to be confusing.
10:41:08 <dgpratt> well if the operation is +, then any instance of Num should work (at least in a Haskell context)
10:41:17 <tulcod> dgpratt: right
10:41:27 <shachaf> (+) :: Int -> Int -> Int and (+) :: Word -> Word -> Word aren't the same operation at all.
10:41:27 <dgpratt> any well-behaved instance of Num, anyways
10:41:34 <tulcod> exactly, was just gonna say that :)
10:41:54 <bennofs> I believe it makes sense from a mathematical POV: you can have different binary functions over natural numbers that form a semigroup (with natural numbers being the underlying set)
10:42:09 <dgpratt> shachaf, that gets to a question I was wondering about the identity of operations
10:42:20 <dgpratt> which I think you answered
10:42:25 <tulcod> shachaf: if you are blind to the fact that one is a restriction of the other then what you're doing is not avoiding sets, but just being a pita
10:42:28 <shachaf> bennofs: You can have different operations for the same underlying set, sure.
10:42:42 <shachaf> But you can't have different underlying sets for the same operation. The operation determines the set.
10:43:03 <bennofs> right. I noticed that, but somehow forgot when I wrote the comment :p
10:43:08 <shachaf> And asking "what other underlying sets can you have for the same binary operation" is just confusing things.
10:43:32 <tulcod> shachaf: okay, i agree that the comments you're making are fair, but this happens all the time in (semi)group theory
10:43:53 <shachaf> At any rate none of this is relevant for understanding "semigroup action".
10:43:55 <tulcod> so while i agree with your statements, this type of question I asked is very common
10:44:39 <tulcod> yes, formally they are not the same, but informally this is how people speak of them
10:44:44 <dgpratt> well thanks to all, I *think* I understand at least the structure of semigroup actions
10:45:00 <dgpratt> now I just need to figure out what it *means*
10:46:08 <dgpratt> shachaf, you were right, the formal definition was enlightening despite my first impression that it was intimidating
10:46:12 <tulcod> dgpratt: yeah, i don't think anyone has an intuition for these mathematical notions straight away, so don't feel bad or anything
10:46:21 <dgpratt> thanks tulcod
10:46:31 <fvgvxmpv1> I would like to use lenses on a record such as this: data Example = Example { field_ :: forall s. s -> Bool }
10:46:55 <shachaf> fvgvxmpv1: Doesn't work very well, unfortunately.
10:46:59 <fvgvxmpv1> deriveLenses and fromGetSet both seem too… restrictive
10:48:01 <fvgvxmpv1> so… define my actual lenses (StateT a m b -> m b) myself or write myself some custom template haskell?
10:48:27 <shachaf> Even defining the lenses yourself it won't work very well, if at all.
10:48:32 * hackagebot yesod-transloadit 0.1.3.0 - Transloadit support for Yesod  http://hackage.haskell.org/package/yesod-transloadit-0.1.3.0 (boblong)
10:49:55 <fvgvxmpv1> shachaf, because fetch and the like won´t work?
10:50:13 <shachaf> It depends on your implementations of lenses.
10:50:23 <shachaf> You can run into impredicativity or other issues.
10:50:42 <dgpratt> I think that WP article has a small error error: "transformation" links to http://en.wikipedia.org/wiki/Geometric_transformation when I think it should link to http://en.wikipedia.org/wiki/Transformation_%28function%29
10:51:27 <fvgvxmpv1> I intended to use lenses — It sounds like there is a fundamental issue I´m not seeing, that makes, what I want to do fundamentally… difficult?
10:55:38 <maerwald> any1 uses GhcModType in vim? It doesn't seem to show type constraints
10:58:32 * hackagebot Yampa 0.10.0 - Library for programming hybrid systems.  http://hackage.haskell.org/package/Yampa-0.10.0 (IvanPerez)
10:58:34 * hackagebot lambdaBase 0.0.2.0 -   http://hackage.haskell.org/package/lambdaBase-0.0.2.0 (faleidel)
10:59:06 <small-wolf> Is there a way to enforce at compile time that a particular expression doesn't throw an exception or throws only particular exceptions? (inb4 checked exceptions considered harmful)
10:59:27 <ronh> in what version of ghc can datas in the same module share field names?
11:00:04 <rhllor> what is the fastest way to get the factors of a number
11:00:22 <srhb> ronh: No version.
11:00:42 <tromp> number field sieve
11:00:49 <tulcod> rhllor: the best you can get is the fastest *known* way ;)
11:00:51 <ryantrinkle> ronh: the way i usually deal with that is to create a typeclass with lenses for the fields
11:01:02 <small-wolf> is this relevant? https://ghc.haskell.org/trac/ghc/wiki/Records/NameSpacing
11:01:22 <rhllor> tulcod: that would be best yes
11:02:35 <tulcod> rhllor: http://en.wikipedia.org/wiki/Integer_factorization#Current_state_of_the_art
11:02:47 <rhllor> thank you
11:05:14 <ronh> srhb hmm I see.. I thought that was implemented already, while a more comprehensive solution for the same problem is still a work in progress
11:05:38 <srhb> ronh: There are various solutions, like the records library, but none are _integrated_ in GHC yet
11:05:42 <srhb> For various reasons
11:05:43 <bennofs> small-wolf: you cannot guarrante 'error'-freeness, but control-monad-exception allows to track exceptions in the type
11:06:05 <ghorn> why is so much of this code marked INLINE? https://hackage.haskell.org/package/linear-1.18.0.1/docs/src/Linear-Vector.html#Additive
11:06:20 <srhb> ghorn: Speed!
11:06:21 <small-wolf> bennofs: errors and exceptions are totally separate mechanisms no?
11:06:44 <small-wolf> I thought an error was impossible to catch anyway (I might be mistaken)
11:07:03 <ghorn> srhb: is it a bad idea to inline all over the place?
11:07:13 <srhb> ghorn: Yes, often. It depends on what you're inlining
11:08:49 <Vektorweg1> whats better?
11:08:49 <Vektorweg1> this: runM :: MyMonad a -> IO (Either MyErr a) 
11:08:49 <Vektorweg1> that: runM :: MyMonad a -> ExceptT MyErr IO a
11:09:33 <bennofs> small-wolf: 'error' is implemented with exceptions, so not completly separate.
11:09:45 <small-wolf> hmm
11:10:03 <tulcod> Vektorweg1: those are equivalent in a mathematical sense, so just pick what fits the rest of your API best
11:10:06 <bennofs> ghorn: it's for specialization
11:10:21 <bennofs> ghorn: you really don't want these functions to be called indirectly via a typeclass directory
11:10:33 <bennofs> so inline will get rid of the typeclass directory
11:10:48 <Vektorweg1> tulcod: yes, but what fits best to the API? ;)
11:11:01 <Vektorweg1> or how to reason about it. 
11:11:15 <tulcod> Vektorweg1: does the rest of your code use ExceptT as well?
11:11:47 <tulcod> Vektorweg1: if this is the only occurrence of ExceptT, you could ask yourself if it is worth depending on another package just to be able to write ExceptT MyErr IO a
11:11:49 <Vektorweg1> tulcod: it would be. 
11:12:00 <Vektorweg1> okay.
11:12:05 <ghorn> bennofs: is it impossible to have specialization without fully inlining in this case?
11:12:17 <tulcod> Vektorweg1: if you may be able to use some of ExceptT's helper functions, go for that for sure
11:12:36 <tulcod> Vektorweg1: if it's just to have a uniform error handling scheme, then that's a valid reason to depend on transformers imo
11:12:59 <bennofs> ghorn: hmm, GHC sometimes specializes automatically. not sure, but the functions are probably also good to inline regardless of specialization (they are pretty small)
11:13:01 <Vektorweg1> tulcod: thank you. 
11:13:19 <bennofs> ghorn: GHC would 'probably' inline them by itself (not sure though)
11:16:26 <dolio> Specialization gets rid of type class dictionaries.
11:16:32 <dolio> You don't have to inline for that.
11:17:01 <dolio> But, you might still get faster code by inlining.
11:17:42 <bennofs> dolio: yes, but if you don't know which types your function will be used with (for example because you're writing a library), then you cannot add SPECIALIZE manually, and GHC does not always specialize, does it?
11:17:52 <hexagoxel> on http://www.stackage.org/older-releases, what do "exclusive" and "inclusive" mean?
11:18:11 <dolio> If you mark things INLINEABLE, it will specialized based on the use site.
11:18:19 <dolio> And won't necessarily inline them.
11:18:51 <bennofs> ok, thanks
11:23:33 * hackagebot Yampa 0.10.1 - Library for programming hybrid systems.  http://hackage.haskell.org/package/Yampa-0.10.1 (IvanPerez)
11:29:30 <Gal3rielol> why parallel in haskell need to care about evaluation strategies?
11:31:14 <fr33domlover> hello
11:31:31 <fr33domlover> is it reasonable to release a new minor version just for one little fix?
11:31:50 <fr33domlover> just making sure it's not too strange :P
11:33:42 <arkeet> fr33domlover: sure
11:33:59 <arkeet> keep in mind https://wiki.haskell.org/Package_versioning_policy
11:34:25 <fr33domlover> arkeet, that's exactly why it's a minor version :) that page is open in my browser
11:34:34 <hexagoxel> imo the more important thing is the frequency of releases
11:34:43 <arkeet> you could increment the 4th version component
11:34:58 <arkeet> if there is no interface change
11:35:04 <fr33domlover> in this case I'm adding API (an Eq instance I forgot)
11:35:05 <hexagoxel> once per week is fine, i guess..
11:35:12 <arkeet> ah, then bump the 3rd component.
11:35:18 <fr33domlover> so 0.1.0.0 -> 0.1.1.0
11:35:25 <arkeet> sure
11:35:34 <arkeet> or just 0.1.1
11:48:34 * hackagebot dynobud 1.4.0.0 - your dynamic optimization buddy  http://hackage.haskell.org/package/dynobud-1.4.0.0 (GregHorn)
11:48:36 * hackagebot smaoin 0.1.1.0 - Utilities for the Smaoin semantic information model.  http://hackage.haskell.org/package/smaoin-0.1.1.0 (akrasner)
11:49:08 <sinelaw> I always wanted a dynamic optimization buddy
11:50:32 <aaronm04> can anybody recommend a good way to get setup for Haskell development on OS X?
11:50:47 <merijn> aaronm04: What do you mean by "setup"?
11:51:15 <aaronm04> being able to compile with ghc, use the ghci repl, install cabal packages
11:51:27 <johnw> that's a huge question that would take hours to answer completely
11:51:30 <merijn> I just download either ghcformacosx or the platform
11:51:38 <merijn> ghcformacosx.github.io
11:51:41 <sinelaw> aaronm04, did you try the website instructions? https://www.haskell.org/downloads/osx
11:51:45 <johnw> I'd recommend using Google and get as far as you're able to on your own, and then ask more specific questions here
11:51:54 <aaronm04> ok, thanks and sorry
11:52:00 <johnw> no harm in asking
11:52:02 <sinelaw> no worries
11:52:05 <johnw> we just have limited time usually
11:52:16 <sinelaw> us the collective
11:52:31 <sinelaw> but yeah, specific questions are easier to answer
11:52:36 <jle`> a question was asked and answered in a helpful way. nobody should be apologizing for anything :)
11:54:40 <sm> seems a pretty simple question :)
11:57:55 <johnw> sm: platform or no, hackage or stackage, sandbox or no, Emacs or vim, 7.8 or 7.10, etc.
11:58:34 * hackagebot haskanoid 0.1.4 - A breakout game written in Yampa using SDL  http://hackage.haskell.org/package/haskanoid-0.1.4 (IvanPerez)
12:01:40 <fr33domlover> Q: I have some Darcs repos on my server, but there's no user access control because I use a plain single SSH user for pushing. I use Gitolite for Git, but there seems to be no Darcs equivalent. I found darcsden, but it uses its own SSH server (so I'd have to pick a new port, as 22 is taken).
12:01:49 <fr33domlover> is there a reason it uses its own SSH daemon?
12:01:56 --- mode: ChanServ set +o shapr
12:02:02 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org | https://news.ycombinator.com/item?id=9465999 | RIP Paul Hudak' by shapr
12:02:02 <fr33domlover> (unlike gitolite, which hooks into openssh)
12:02:09 --- mode: shapr set -o shapr
12:02:24 <infandum> Is it possible to have a P.nub in pipes without consuming the stream and keeping it flowing?
12:02:28 --- mode: ChanServ set +o johnw
12:03:04 <sm> fr33domlover: you don't have to use darcsden-ssh, if you figure out how to set up a restricted ssh daemon that allows push & pull
12:03:41 <sm> you also could move your standard ssh daemon to another port
12:04:16 <fr33domlover> sm, I would probably move the darcsden one, since I have git on 22 and several other things :P
12:04:27 <fr33domlover> I can hack gitolite to use a darcs shell I guess
12:04:43 <fr33domlover> but I'd end up making a darcs port of gitolite :)
12:05:40 <fr33domlover> at least it's good to know darcsden-ssh is optional
12:06:18 <sinelaw> is there an accepted name for the denotation function [[ ]] ?
12:06:42 <sinelaw> what would you call it if it had to be a normal (prefix) function?
12:07:49 <amf> whats the name of that cabal alternative that starts with a hy?
12:09:29 <sm> fr33domlover if you want to improve it, see you in #darcs maybe
12:09:51 <c_wraith> amf: are you thinking of halcyon?
12:10:09 <mietek> I hope not, as it’s not exactly an alternative to Cabal yet.
12:10:21 <mietek> Halcyon wraps around Cabal.
12:10:25 <amf> c_wraith: yep!
12:10:33 <mietek> amf, c_wraith: perhaps join #haskell-deployment?
12:10:35 <fr33domlover> sm, I have a side project for making a decentralized dev platform, so that motivates me to work on this kind of things
12:10:39 <amf> mietek: good to know. just wanted to learn about it. still sticking with cabal
12:10:43 <fr33domlover> whether it's darcsden or some derivative
12:11:06 <ronh> is there no way for module A to import module B and vice versa? I am getting cyclic import error
12:11:09 <sm> cool
12:11:10 <mietek> amf: probably https://robots.thoughtbot.com/building-haskell-projects-with-halcyon is better than my own tutorials
12:11:55 <ronh> circular import error*
12:13:26 <merijn> ronh: Use hs-boot files
12:13:26 <sinelaw> ronh, I usually regard that a sign of bad design - are you sure you need it?
12:13:30 <merijn> ronh: See the GHC manual
12:13:42 <merijn> sinelaw: I call BS, I find myself wanting recursive imports all the time
12:13:52 <sinelaw> merijn, example?
12:14:10 <merijn> It's a flaw that GHC can't handle them, since the report requires support for that
12:14:20 --- mode: johnw set -o johnw
12:14:22 <sinelaw> merijn, that's a different issue
12:15:05 <merijn> sinelaw: I have a library where I have an Authentication module, Connection module and Socket module, but since all their types refer to another I end up having all my datatypes in a single module, rather than in the module with the code corresponding to them
12:15:23 <merijn> In fact, nearly all datatypes in the entire library are in that single module to avoid cycles
12:15:55 <merijn> That's so much worse than having types in whatever module has code dealing with them
12:15:58 <sinelaw> merijn, I consider that better than cyclic dependencies - factor out the cyclic-dependent stuff into a seperate piece
12:16:29 <sinelaw> merijn, why are the types entangled?
12:16:49 <sinelaw> does a connection have authentication which has a connection?
12:17:22 <merijn> sinelaw: Because my connection is parameterised over the authentication type used by it
12:17:34 --- mode: ChanServ set +o geekosaur
12:17:38 <merijn> So the connection has to import the Auth module
12:17:53 <merijn> But the auth module has code that deals with connections, so needs to import connections
12:17:59 <merijn> And the socket module needs both
12:18:09 <sinelaw> merijn> sinelaw: Because my connection is parameterised over the authentication type used by it
12:18:17 <sinelaw> ^ not sure what exactly that means
12:18:30 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org | RIP Paul Hudak https://news.ycombinator.com/item?id=9465999' by geekosaur
12:18:41 <merijn> sinelaw: "data Connection (authMode :: AuthMode) = ..."
12:18:48 --- mode: geekosaur set -o geekosaur
12:19:21 <sinelaw> is that a type-level value?
12:19:34 <merijn> And the code in Authentication: "nullAuth :: SomeParams -> Connection NullAuth"
12:19:42 <merijn> sinelaw: DataKinds, yes
12:19:47 <sinelaw> ah
12:20:25 <merijn> The nice thing is that GHC checks and guarantees that code paths claiming to use a certain authentication are statically verified to only be able to take that code path
12:20:43 <merijn> i.e. password authentication going via nullAuth is a type error. I kinda like it :)
12:21:01 <dolio> The alternate answer is that your modules are too coupled.
12:21:11 <merijn> But as I said, I now have every single datatype in a single module now
12:21:12 <dolio> You put too much stuff in the one auth module.
12:21:16 <sinelaw> dolio, that's what I'm trying to say, but DataKinds are also interested
12:21:19 <sinelaw> *interesting :)
12:21:24 <merijn> dolio: How would you split it?
12:21:37 <dolio> Put AuthMode in its own file.
12:21:54 <dolio> Or something like that.
12:21:58 <dolio> Break it up more.
12:22:00 <sinelaw> and anything else from auth that is also required by connection
12:22:15 <merijn> dolio: But then it's still separate from the authentication code
12:22:36 <sinelaw> merijn, right but then you have the part that does stuff with connections vs. the part that describes connections
12:22:59 <sinelaw> (higher and lower" if you will, (lower being used by Connection itself)
12:23:05 <sinelaw> "
12:23:42 <merijn> Right, but then I have a bunch of files that only have like 10 lines worth of datatype declarations and I end up with like 10 modules
12:23:42 <sinelaw> (I'm sure there's a more eloquent way to say that)
12:23:52 <dolio> Good.
12:24:03 <sinelaw> merijn, I'd much rather have that than cyclic modules!
12:24:03 <dolio> We have lots of files like that in a project I work on.
12:24:44 <merijn> dolio: 10 more modules means having to come up with 10 more meaningful names for modules
12:24:53 <merijn> I already have enough difficulty with that as-is
12:25:17 <merijn> Not to mention I find it annoying to have to work with lots and lots of tiny files
12:30:59 <stephenmac7> Quick question: are there any alternatives to using monad transformers when you want the effects of multiple monads?
12:31:43 <srhb> stephenmac7: extensible effects
12:31:46 <jophish> Are there any elegant ways to handle floating point errors. Specifically I have a value I'm taking the square root of and it's about -2e16 so returns NaN. I'm happy to put an epsilon check in here and return zero for negative numbers near zero, but thought I'd check to see if there's some nifty thinking on #Haskell
12:31:50 <srhb> Manually unrolling 
12:31:56 <srhb> stephenmac7: Custom monads
12:32:32 <stephenmac7> srhb: Are those commonly used, or do they have other, more limiting drawbacks?
12:32:49 <srhb> stephenmac7: Custom monads are commonly used. Extensible effects I'm not sure of.
12:33:53 <stephenmac7> srhb: Custom monads are just what they sound like, right?
12:34:07 <srhb> stephenmac7: Yeah, you roll your own monad that is the combination of all the monads you need.
12:34:53 <stephenmac7> Yeah, exactly what it sounded like. I'll look into those. Extensible effects looks kind of cool, but I never got into co-routine style... even when programming precedurally
12:35:13 <srhb> stephenmac7: I've been meaning to look into them at some point. I only know of them by name so far, and I read part of the paper
12:35:44 <srhb> stephenmac7: https://ocharles.org.uk/blog/posts/2013-12-04-24-days-of-hackage-extensible-effects.html -- might interest you
12:36:03 <stephenmac7> Gotta love 24 days of hackage...
12:36:21 <dolio> The downside of extensible effects is that they're about equivalent to programming to the mtl classes, except they don't work as well. :)
12:36:31 <stephenmac7> ...though it seems like more than 24 things are on there.
12:36:56 <srhb> stephenmac7: Well it has been happening for a few decembers now :)
12:37:09 <dolio> And everyone doing comparisons between monad transformers and extensible effects conveniently forgets about the mtl classes.
12:37:16 <stephenmac7> Well then, that would make sense.
12:37:26 <srhb> dolio: Care to elaborate on that last point?
12:37:46 <stephenmac7> Doesn't mtl do some extra stuff to make using transformers nicer?
12:38:09 <stephenmac7> Using typeclasses to unroll them or something...
12:38:13 <dolio> Most comparisons tend to compare extensible effects to working directly with particular FooT (BarT (BazT ...)) stuff.
12:38:39 <joshc> window 24
12:38:46 <joshc> :\
12:40:26 <srhb> dolio: As opposed to what? MonadFoo => ... ?
12:40:31 <dolio> Yes.
12:40:34 <srhb> Ah.
12:40:59 <dolio> Then they complain they have to write several 'lift's all over and so on.
12:41:05 <srhb> Yeah, okay.
12:41:08 <srhb> That is an unfair comparison.
12:41:42 <dolio> The classes in mtl are the key to recovering pretty much all the functionality of extensible effects that people like.
12:42:09 <dolio> And they work better in that they're class based, and Haskell treats class contexts as unordered and subtyped and whatnot.
12:42:30 <dolio> Whereas it doesn't have good support for having an unordered, subtyped set of effects.
12:42:59 <dolio> So you get baroque type hackery for the latter.
12:43:20 <srhb> TIL 1990s is the baroque of FP
12:43:21 <srhb> :-)
12:43:35 <srhb> (I don't disagree)
12:45:06 <Saizan> dolio: but people will keep trying to cut down on MonadFoo instances
12:48:26 <srhb> Saizan: KindConstraints!
12:48:28 <srhb> :P
12:48:32 <srhb> Ok, that's cheating a bit...
12:48:35 <srhb> Er, ConstraintKinds
12:48:36 * hackagebot cabal-install 1.22.4.0 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.22.4.0 (ryant)
12:48:47 <Saizan> srhb: does that help?
12:49:00 <dolio> Saizan: You mean they don't want to write instances?
12:49:16 <Saizan> dolio: yeah
12:49:20 <srhb> Saizan: No, it just gets prettier because you can do type MyMonadBaz = (MonadFoo, MonadBar, ...)
12:49:26 <dolio> Yeah. i guess that's an issue.
12:49:27 <srhb> Of course it changes nothing.
12:51:56 <nuttycom> Hi all. Can anyone suggest a good way to create a Gen instance that behaves as an unfold - that is, the previous value generated can be used to influence the next (in generation of a list of values) ?
12:52:48 <Iceland_jack> nuttycom: Do you mean QuickCheck's Gen
12:52:59 <nuttycom> Iceland_jack: yes
12:53:35 <Iceland_jack> Can you describe your use case?
12:54:28 <nuttycom> Iceland_jack: Sure. I'm trying to generate a list of non-overlapping time intervals.
12:54:48 <Iceland_jack> QuickCheck already has 'infiniteList :: Arbitrary a => Gen [a]'
12:55:16 <nuttycom> The problem with infiniteList is the non-overlapping constraint.
12:55:39 <Iceland_jack> If you have
12:55:39 <Iceland_jack>     removeOverlapping :: [Interval] -> [Interval] 
12:55:51 <Iceland_jack> Would ... suffice
12:55:51 <Iceland_jack>     removeOverlapping <$> infiniteList
12:56:45 <Saizan> can you have a productive removeOverlapping?
12:57:39 <nuttycom> To do that I think you'd need the list to be ordered
12:57:56 <nuttycom> Producing such an ordered list was actually the reason for my question.
12:58:05 <Iceland_jack> nuttycom: newtype OrderedList a = Ordered [a]?
12:58:08 <imPure> When reifying a function in template Haskell I get a VarI with a Dec that's Nothing. Any idea why I can't get the Declaration?
12:58:37 <Iceland_jack> (and the corresponding combinator 'orderedList')
12:59:00 <hodapp> Data.Data, round 2: can I use Data.Data to transform instances of records generically?
12:59:34 <hodapp> maybe I'll have to read SPJ's 'Scrap Your Boilerplate' paper.
13:02:02 <Iceland_jack> nuttycom: Would you rather (simplified), say, generate an interval [a, b] and then say "the next interval I generate should start after 'b'"?
13:02:38 <Iceland_jack> and work recursively until you have sufficiently many intervals
13:02:49 <nuttycom> Iceland_jack: yes, that's exactly what I'd like to do. 
13:03:08 <Iceland_jack> You have several options, but you need to be aware of how they affect your distribution
13:03:33 <ronh> can I have a data type like this? (no a type variable in Foo) data Foo = { bar :: String -> a; baz :: a -> IO () }
13:03:55 <geekosaur> with a data constructor added
13:04:24 <geekosaur> hm, to have that `a` you'd need to make it existential but that limits what you can do with the type
13:04:25 <Iceland_jack> ronh: Yes,
13:04:25 <Iceland_jack>     data Foo where
13:04:25 <Iceland_jack>       MkFoo :: { bar :: String -> a,
13:04:25 <Iceland_jack>                  baz :: a -> IO      } -> Foo
13:04:35 <mishac> Hi guys, can anyone give some pointers on why instance Num a => Num (Stream a) where 
13:04:35 <mishac>  fromInteger a = streamRepeat (a) 
13:04:35 <mishac> this expression gives an errorr
13:04:41 <Iceland_jack> Where 'a' is existential
13:05:12 <merijn> mishac: 'a' is an Integer so that only produces "Stream Integer", not "Num a => Stream a"
13:05:14 <nuttycom> The function I'm attempting to test recovers a set of intervals from an unordered stream of events, so as a trivial test I want to be able to generate the desired output, then randomize to provide the input to my function.
13:05:17 <merijn> mishac: Try fromIntegral
13:05:28 <merijn> :t fromInteger
13:05:30 <lambdabot> Num a => Integer -> a
13:05:30 <Iceland_jack> nuttycom: You need to control the length of the list, for simplicity we can use "listOf" to control the size
13:05:53 <Iceland_jack> :t listOf :: Gen Int -> Gen [Int]
13:05:54 <lambdabot> Gen Int -> Gen [Int]
13:06:08 <merijn> Iceland_jack: I would just use normal record syntax for that, i.e. "data Foo = forall a . Foo { bar :: String -> a; baz :: a -> IO () }"
13:06:09 <mishac> so does it mean that fromInteger does not belong to typeclass
13:06:13 <dgpratt> from https://www.fpcomplete.com/user/edwardk/heap-of-successes, when he says "Sadly, the MPTC for RightMonoidAction is rather annoying to use in practice.", what is MPTC referring to?
13:06:13 <mishac> Num?
13:06:17 <merijn> mishac: It does
13:06:30 <ion> Iceland_jack: Huh, i hadn’t realized the GADT syntax supports record getters like that. Incidentally, that one results in “Cannot use record selector ‘bar’ as a function due to escaped type variables”
13:06:37 <ronh> Iceland_jack interesting thanks
13:06:40 <merijn> mishac: The point is that fromInteger is used to translate integral literals to the relevant instance and it does so via Integer
13:06:58 <merijn> mishac: The literal "1" translates to "fromInteger 1" where 1 is an Integer
13:07:08 <ion> merijn: So does that one.
13:07:13 <mishac> I see
13:07:22 <ion> “Probable fix: use pattern-matching syntax instead”
13:07:46 <Iceland_jack> nuttycom: Now you can treat the elements of the resulting list as the distances between the intervals, as a simplification of the solution
13:08:13 <mishac> if I understand you correctly, I cannot implement fromInteger to streams
13:08:22 <merijn> mishac: But your Stream instance claims to return a "Stream a" for any "Num a", so you need to first convert the Integer to the relevant Num type
13:08:26 <merijn> mishac: Sure you can
13:08:36 * hackagebot cabal-install 1.20.1.0 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.20.1.0 (ryant)
13:08:37 <merijn> mishac: "fromInteger a = streamRepeat (fromInteger a)"
13:08:48 <mishac> ohh
13:08:51 <mishac> thats what it is
13:08:52 <mishac> I see
13:08:57 <mishac> thank you
13:08:59 <Iceland_jack> nuttycom: So if 'listOf arbitrary' gives you [10,20,30] you just need to implement a simple function that generates an interval following some number
13:09:02 <nuttycom> Iceland_jack: okay, that's similar to the approach I've been taking, which is to generate a list, sort it, then take successive pairs. But, that tends to create 0-length intervals and so forth. Your approach makes sense.
13:09:16 <merijn> mishac: You just needed to explicitly convert the Integer to a "whatever" and repeat that :)
13:09:20 <mishac> trickly business these typeclasses
13:09:22 <Iceland_jack>     intervalFollowing :: Int -> Gen Interval
13:09:22 <Iceland_jack>     intervalFollowing n = ...
13:09:28 <mishac> yep, it makes sense now
13:09:54 <mishac> and it works, ty good sirs;
13:11:43 <greg`> getting this -> cabal: Cannot find the program 'ghc' at 'ghci-ng' 
13:11:58 <greg`> following chrisdones haskell setup github page
13:12:08 <greg`> has anyone come across this before?
13:18:37 * hackagebot cabal-install 1.18.1.0 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.18.1.0 (ryant)
13:23:37 * hackagebot smaoin 0.1.1.1 - Utilities for the Smaoin semantic information model.  http://hackage.haskell.org/package/smaoin-0.1.1.1 (akrasner)
13:25:58 <amindfv> how do i write type-level lists of lists? e.g. i can write ```Proxy :: Proxy '["test"]```, but not ```Proxy :: Proxy '['["test"]]```
13:27:55 <geekosaur> possibly '[["test"]] ?
13:28:37 * hackagebot razom-text-util 0.1.0.0 - Common text/parsing tools for Razom language packages.  http://hackage.haskell.org/package/razom-text-util-0.1.0.0 (akrasner)
13:29:01 <amindfv> geekosaur: ghci doesn't like it, but maybe that has something to do with Proxy
13:29:08 <amindfv> (it has a type error instead of parse error)
13:29:17 <hexagoxel> but a string is a list of chars.. :p
13:29:22 <amindfv> i've tried all the obvious combinations...
13:29:23 <hexagoxel> you need to `'[ '[True]]`
13:29:40 <hexagoxel> amindfv: ^
13:29:53 <amindfv> hexagoxel: ew, gross. but thanks haha
13:44:09 <eikke> anyone knows something about 'ambiguous types'?
13:45:18 <tulcod> i know about unintentional types...
13:50:39 <enthropy> eikke: it means you need more type signatures / FDs / TFs
13:53:12 <marchelzo_> Is there a channel on freenode for spock?
13:53:38 * hackagebot cabal-install 1.16.1.0 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.16.1.0 (ryant)
13:57:17 <ion> eikke: That question was appropriately ambiguous.
13:58:56 <albeit> @pl \(i,j) -> f (g i, g j)
13:58:56 <lambdabot> uncurry ((f .) . (. g) . (,) . g)
13:59:03 <Esteth> I have two datatypes, Instruction and AddressMode. Some Instruction constructors should take an AddressMode, but different Instruction constructors should be limited to particular AddressModes, is there a nice way to express this?
13:59:17 <Esteth> I was on earlier and someone suggested GADTs but I couldn't figure it out :(
13:59:17 <arkeet> albeit: f . (g *** g)
13:59:26 <albeit> arkeet: Great, was trying to figure out which arrow it was
14:00:06 <Iceland_jack> Also 'f . join bimap g'
14:00:18 <ion> Esteth: data Instruction a where { Foo :: Instruction a {- accepts any mode -}; Bar :: Instruction ThatMode } perhaps.
14:00:39 <imPure> Is there any way to get the declaration of functions by name in TemplateHaskell?
14:00:58 <benedikt> benzrf: and it is harder for a c++ programmer to figure out a haskell project (like it's harder for you to figure out a c++ project because you are not c++ programmer). It's not a property of the language, it's a question of your own familarity
14:01:48 <Esteth> ion: Some instructions need to be able to take either AddressMode ModeA or ModeC while others take ModeC and ModeD for example
14:02:26 <Esteth> I can write a smart constructor that validates the Instruction creation, but I'd prefer to do it with types if I can
14:03:38 * hackagebot stackage 0.7.3.0 - Dummy package forcing installation of other Stackage packages  http://hackage.haskell.org/package/stackage-0.7.3.0 (DanBurton)
14:03:41 <ion> Ok, i misunderstood. I thought the instructions would *have* an intrinsic address mode. Ignore the example i gave.
14:04:06 <ion> How about per-addressmode instruction variants as separate constructors?
14:04:41 <sinelaw> Is this transformation a valid way to disentangle recursion?  [[ let x = expr in y ]]  ==>  [[ let x = fix (\x -> expr) in y ]]
14:05:01 <sinelaw> idea being to shadow 'x' in 'expr' and apply fix 
14:05:29 <ion> Shadowing anything doesn’t sound nice.
14:05:49 <quchen> The Report talks about the semantics of recursive let bindings, if you're interested in the way Haskell does it.
14:06:07 <sinelaw> quchen, ok will look
14:06:25 <sinelaw> but I'm also interested in general, not haskell specific, if that's a valid transformation
14:06:54 <ion> How about renaming x within expr?
14:06:57 <quchen> section 3.12, "let expression"
14:07:03 <quchen> ...s
14:07:30 <sinelaw> ion, ok, but is there anything incorrect about shadowing?
14:07:40 <benzrf> that's not what i'm talking about,  benedikt
14:07:41 <glguy> sinelaw: You could have a problem with that translation with polymorphic recursion
14:08:18 <benzrf> benedikt: the point is that the c++ program's ambient state led to a more complicated and mutually dependent dependency graph for understanding the code
14:08:23 <quchen> Shadowing won't help you understand this sort of thing. Shadowing is a way to remove the ambiguity of having multiple variables with the same name in different scopes, that's it.
14:08:28 <quchen> It's not a way to structure your program.
14:08:51 <benedikt> benzrf: thats a very subjective statement and I assure you that a C++ developer would have something say about the structure of a Haskell project
14:08:58 <benzrf> if u say so
14:09:25 <sinelaw> hmm. the report has this: let p = e1  in  e0 	= 	let p = fix ( \ ~p -> e1) in e0
14:09:29 <Esteth> ion: That'd be possible, but It'd make parsing a pain, and maintenance of the list a pain. I think I'd prefer to just validate instead of enforce at that point
14:09:30 <sinelaw> looks oddly familiar
14:10:11 <dredozubov> what's the best practices for installing multiple GHC versions on OS X?
14:10:31 <quchen> sinelaw: The line above is also important, which in conclusion says that the rule you posted applies only if a variable in p appears free in e1
14:10:48 <quchen> (Well, no such variable can be seen as a degenerate case of that)
14:10:57 <quchen> BRB
14:11:08 <enthropy> imPure: sometimes reify gives you a Dec
14:12:22 <imPure> enthropy: I've been trying, but it won't. 
14:12:37 <imPure> enthropy: How do I get it to give me the Dec?
14:13:06 <glguy> sinelaw: " This translation does not preserve the static semantics because the use of case precludes a fully polymorphic typing of the bound variables."
14:13:09 <enthropy> well I think the one case where it will is if the identifier you're loading is interpreted
14:13:21 <lpaste> glguy pasted “for sinelaw” at http://lpaste.net/132054
14:13:35 <sinelaw> glguy, right. but what are they saying - is that translation simply wrong for haskell?
14:13:49 <sinelaw> I think I'm missing the point of static vs. dynamic translations
14:16:10 <imPure> enthropy: I still get nothing.
14:16:52 <glguy> sinelaw: I don't know what it's trying to say other than "You can think of the let bindings working kind of like this-ish"
14:17:19 <sinelaw> glguy, I guess so. I'm looking for a precise denotation, seems like recursive bindings are problematic
14:17:39 <sinelaw> glguy, though with monomorphic recursion it seems to work, no?
14:19:35 <glguy> Yeah, seems to work for that case
14:22:00 <Ouyang> I want to make a program that uses information from an api data base using CREST, is this something I can do with haskell? Im trying to find a project for myself
14:22:46 <Ouyang> ive been googling for a while now trying to find information on this in haskell, and there doesnt seem to be much out there.  Anyone have a good resource for me to read?
14:25:08 <imPure> What I'm trying to do is have a DSL where I use the same variables I use in Haskell.
14:27:50 <glguy> Ouyang: Any chance that you're targeting Eve Online? (Just happens to be the last API I was looking at which had a CREST API)
14:29:50 <Ouyang> glguy, exactly hahaha
14:30:17 <Ouyang> my corp needs something to do with srp and I said id look into it as a learning oppurtunity.  
14:31:31 <glguy> I don't know exactly what you have in mind, but is it something that the standard API can handle via the corporation killlog?
14:31:52 <glguy> (Guessing SRP is your ship replacement program)
14:31:58 <Ouyang> yeah.  I mean I just want to get a simple api request
14:32:36 <Ouyang> Kinda confused with my google searches. I just want to request info from the api
14:33:02 <glguy> This is the format for the character kill log, and the corp kill log replaces char with corp in the URL http://wiki.eve-id.net/APIv2_Char_KillLog_XML
14:33:09 <ion> What alliances do you guys belong to?
14:33:18 <glguy> You can use the standard HTTP library to pull this XML document down
14:33:45 <glguy> ignore the apiKey argument as documented there and use keyID= and vCode= for the new API
14:34:10 <glguy> the HTTP library's urlEncodeVars function will get your data into the right format for the arguments
14:34:28 <glguy> ion: I'm not. I play with people from work. We're small-time
14:35:29 <Ouyang> Im in Bovril
14:35:36 <glguy> Ouyang: The "xml" package on hackage is up to the challenge of picking apart the resulting XML file
14:35:38 <ion> I’m also in a small-time corp without an alliance. We’re friendly with CVA and AFK etc.
14:36:06 <hodapp> bluuurgh. Not sure if I should keep banging my head into a wall with Data.Data, or just go to Generics.
14:36:07 <Ouyang> i think my corp is in the top 5 by populace
14:36:27 <Ouyang> But ok thank you glguy 
14:36:30 <hodapp> what I needed yesterday was actually very easy with Data.Data but I didn't realize it was going to expand considerably.
14:43:39 * hackagebot reflex 0.2 - Higher-order Functional Reactive Programming  http://hackage.haskell.org/package/reflex-0.2 (RyanTrinkle)
14:43:41 * hackagebot cabal-install 0.14.1 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-0.14.1 (ryant)
14:45:07 <erisco> :k IntMap
14:45:08 <lambdabot>     Not in scope: type constructor or class ‘IntMap’
14:45:09 <lambdabot>     Perhaps you meant ‘IM.IntMap’ (imported from Data.IntMap)
14:45:15 <erisco> :k IM.IntMap
14:45:16 <lambdabot> * -> *
14:45:25 <erisco> :k (# , #)
14:45:26 <lambdabot> OpenKind -> OpenKind -> #
14:45:28 <shelf-> is there something like `msum` for Alternative?
14:45:43 <erisco> :k Vector
14:45:44 <lambdabot> Not in scope: type constructor or class ‘Vector’
14:45:51 <erisco> :t Int#
14:45:52 <lambdabot> Not in scope: data constructor ‘Int#’
14:45:53 <erisco> hm
14:46:06 <erisco> :t IM.IntMap (# a, b #)
14:46:07 <lambdabot> Not in scope: data constructor ‘IM.IntMap’
14:46:15 <merijn> erisco: That's not a sensible thing
14:46:17 <erisco> :k IM.IntMap (# a, b #)
14:46:18 <lambdabot> Not in scope: type variable ‘a’
14:46:18 <lambdabot> Not in scope: type variable ‘b’
14:46:26 <merijn> unboxed tuples aren't values and can't be stored in variables
14:46:35 <merijn> They can only be returned by functions and then consumed
14:46:52 <merijn> (unboxed tuples translate to results passed in registers)
14:47:05 <erisco> merijn okay
14:47:19 <ion> ryantrinkle: Nice. What’s new in 0.2? (There’s no changelog, it seems.)
14:47:26 <erisco> so I guess I will just use a strict 2-tuple then
14:47:34 <erisco> would be nice if there was convenient syntax for that
14:48:01 <ryantrinkle> ion: it's a very small change; only a version bump because I took out my own version of ref-tf and am now using that package
14:48:07 <glguy> timothyh: asum :: (Foldable t, Alternative f) => t (f a) -> f a
14:48:16 <ryantrinkle> other than that, a couple of under-the-hood changes a lot of new documentation
14:48:51 <ion> Nice, i’ll have to read the haddocks when they’re built.
14:49:06 <ryantrinkle> a lot of the docs are contributed by schell and cocreature on github
14:49:11 <ryantrinkle> yeah :)
14:49:15 <ryantrinkle> that's interesting, actually
14:49:38 <ryantrinkle> i uploaded as package candidate, and it built docs
14:49:41 <erisco> merijn what meta data does the box add?
14:49:44 <ryantrinkle> but then when i released, the docs disappeared
14:49:57 <merijn> erisco: Which box?
14:50:14 <schell> ryantrinkle: i have a shell scipt i use for uploading docs to hackage - would you like me to paste it?
14:50:16 <erisco> is it different for each type then?
14:50:29 <merijn> erisco: A "boxed X" is just "pointer to X" instead "X"
14:50:32 <joneshf-laptop> schell, i would
14:50:59 <merijn> erisco: Since pointers are uniform size it means that all values are equal size and polymorphic code is thus easy to generate
14:51:12 <ion> hackagedocs https://gist.github.com/Fuuzetsu/8276421
14:51:14 <ryantrinkle> schell: i've used something like that at some point..
14:51:15 <ryantrinkle> hmm
14:51:20 <lpaste> schell pasted “upload docs to hackage” at http://lpaste.net/132056
14:51:35 <ryantrinkle> schell: i don't think i'll start using something like that until i have a script that does the whole release automatically
14:51:55 <ryantrinkle> (which will hopefully be soon!)
14:52:14 <schell> well you can use this script as the second half!
14:52:16 <schell> http://pastebin.com/rjxs5ij2
14:52:22 <schell> ^ just in case lpaste was down
14:52:33 <merijn> erisco: So "(Int, Int)" is similar to "struct { int *x; int *y;}" whereas an "data Tuple = Tuple {-# UNPACK #-}!Int {-# UNPACK #-}!Int" would be unboxed, which would look like "struct { int x; int y; }"
14:52:39 <schell> that’s a modified version of somebody’s gist (somebody probably here)
14:52:44 <glguy> schell: That script looks like it would get the cross-package links wrong
14:52:55 <merijn> erisco: Unboxed tuples are kinda special/different from other unboxed values in that the tuple itself doesn't actually exist
14:53:03 <schell> glguy: it might - YMMV
14:53:18 <glguy> I use this one for uploading documentation https://github.com/ekmett/lens/blob/master/scripts/hackage-docs.sh
14:53:27 <merijn> erisco: It's basically just two values being returned (you can only return unboxed tuples, never store/pass them)
14:54:26 <erisco> merijn okay
14:54:53 <erisco> merijn but you can unbox the tuple elements with this {-# UNPACK #-} directive?
14:55:26 <erisco> so, in your analogy, you can store a  struct IntPair *  where  struct IntPair { int x; int y; }
14:55:53 <joneshf-laptop> schell, thanks!
14:56:12 <schell> joneshf-laptop: :) seems there are a few to choose from!
14:56:24 <merijn> erisco: No, like I said, unboxed tuples are weird
14:56:38 <erisco> well hang on here
14:56:43 <merijn> And unpack directives only work for 1) non-polymorphic values and 2) only in the datatype declaration
14:56:50 <merijn> erisco: Unboxed tuples means there is no tuple
14:56:51 <merijn> At all
14:56:52 <merijn> Ever
14:56:53 <erisco> unpacking the elements is not the same as unboxing the pair, right?
14:57:09 <merijn> Unboxed tuples are not a data structure
14:57:20 <erisco> I am not talking about unboxed tuples now
14:57:29 <merijn> ok
14:57:36 <erisco> I am talking about your data Tuple = Tuple {-# UNPACK #-}!Int {-# UNPACK #-}!Int
14:57:41 <erisco> is that an unboxed tuple?
14:58:01 <merijn> It's "a tuple of unboxed ints"
14:58:08 <imPure> I don't get it. How can the Dec portion of VarI not be implemented. There must be some other way to get the declaration...
14:58:11 <erisco> okay
14:58:30 <erisco> so I cannot store an unboxed tuple, but I can store a tuple of unboxed elements
14:58:41 <exio4> is the ! needed if you use {-# UNPACK #-}? 
14:58:53 <merijn> exio4: Yes, because you can't have lazy unboxed values
14:58:55 <exio4> I would have thought unpack implied strictness 
14:59:16 <shachaf> Unpack is an implementation detail, strictness is semantics.
14:59:23 <merijn> exio4: GHC wants you to be explicit
14:59:32 <exio4> I see 
15:00:06 <merijn> erisco: You can store an "unboxed tuple" in the sense that you can have an unboxed (a, b) "data Foo = Foo {-# UNPACK #-}!(a,b)"
15:00:07 <shachaf> If you think {-# UNPACK #-} without ! should be an error, that sounds reasonable.
15:00:17 <shachaf> It's probably at least a warning.
15:00:58 <erisco> merijn okay, but that is because when we use Foo we can store the Foo box
15:01:03 <merijn> erisco: Actually, let's use "data Foo = Foo {-# UNPACK #-}!(Int, Int)" for simplicity
15:01:05 <erisco> right?
15:01:29 <merijn> erisco: Which translates to "struct Foo { struct tuple { int *x; int *y; }; }"
15:01:50 <merijn> erisco: As opposed to "struct Foo { struct tuple *tup; };"
15:01:59 <erisco> merijn how do thunks fit into all of this
15:02:09 <erisco> that is part of why I thought there would be more than a pointer
15:02:13 <erisco> and also reference counting
15:02:24 <merijn> erisco: If it's a thunk than it's a pointer to code, instead of pointer to a value
15:02:35 <merijn> GHC tags the pointers to see which is which
15:02:59 <erisco> so the box also has a flag to indicate thunk or value
15:03:01 <erisco> ?
15:03:20 <merijn> erisco: The pointer itself is the box and it's tagged to indicate thunk vs value, so yes
15:03:48 <erisco> well if pointer = box then what do you call the pointer plus the rest of the meta data?
15:04:05 <merijn> Which metadata?
15:04:09 <ion> Does GHC have an optimization that results in data Nat = Z | S !Nat being stored as an integer perchance?
15:04:26 <erisco> the thunk/value flag for one, and probably a ref count for another
15:04:36 <merijn> erisco: GHC doesn't do ref counting
15:04:38 <erisco> both of which I presume are elided with UNPACK
15:04:44 <merijn> erisco: And the flag is just a bit in the pointer
15:04:55 <erisco> so it steals room in the pointer
15:05:09 <glguy> There's actually a pointer to an "info" struct that tells GHC what something in memory is
15:05:18 <merijn> Yes, since pointers are always word aligned you know they're always multiples of 4 or 8
15:05:19 <erisco> merijn if not ref counting then what does it use?
15:05:34 <merijn> So that gives you the lowest 2 bits as available tags, since you know they have to be zero
15:05:44 <merijn> erisco: Garbage collection
15:05:58 <glguy> GHC knows that an unboxed thing isn't a thunk because it knows its an unboxed thing thanks to information propagated by the type system
15:06:11 <erisco> and how does the GC decide when something should be collected merijn?
15:06:41 <merijn> erisco: It doesn't decide when things should be collected, it decides when things *shouldn't* be collected
15:06:51 <erisco> and how might it do that
15:07:07 <merijn> i.e. it looks at live values (things on the pattern stack) and copies all "live" values to a new memory area then throws away everything
15:07:16 <glguy> erisco: You might be interested in reading this: http://en.wikipedia.org/wiki/Mark-compact_algorithm
15:07:35 <merijn> glguy: GHC uses a generational scheme, though
15:07:56 <glguy> yeah, so it's a more complicated process
15:08:04 <glguy> but it uses mark/compact
15:08:21 <merijn> erisco: You have two memory sections, one active, one inactive. Copy everything that can be reached to the inactive section, then switch which section is active
15:08:30 <erisco> okay
15:08:42 <merijn> erisco: Things that aren't reachable aren't copied over and thus disappear after the copy is complete
15:08:46 * hackagebot json-rpc-client 0.1.2.0 - JSON-RPC 2.0 on the client side.  http://hackage.haskell.org/package/json-rpc-client-0.1.2.0 (grayjay)
15:09:06 <glguy> merijn: The wikipedia happens to mention "Compacting garbage collection is used by Microsoft's Common Language Runtime and by the Glasgow Haskell Compiler." (which I didn't notice before pasting that)
15:09:19 <glguy> GHC doesn't use a two-space compactor, though
15:09:39 <merijn> glguy: GHC does compact, but I would argue it doesn't really use mark as in "mark&sweep"
15:09:43 <erisco> some GCs use ref counting and then a more expensive mark and weep type of algo when ref counting appears to be failing
15:09:51 <erisco> i.e. cyclic references
15:10:17 <merijn> erisco: Incidentally, this approach is why GHC is so good at allocating GBs per second
15:10:29 <merijn> As long as only a handful of values survive it's very cheap to GC
15:10:48 <mauke> was "mark and weep" deliberate?
15:10:52 <merijn> 1 GB of garbage + 2 ints that are live only costs the time to copy 2 ints for collection
15:10:58 <erisco> mauke heh, no
15:10:59 <merijn> mauke: :D
15:12:28 <erisco> okay, so the box is the pointer and the pointer has a bit stolen from it for a thunk/value flag
15:12:35 <erisco> what is this info thing you're speaking of glguy?
15:12:46 <glguy> No, the tagging of pointers isn't that straight-forward
15:12:58 <erisco> explain please )
15:13:00 <erisco> :)
15:13:08 <merijn> glguy: It is, though. Otherwise it's not "pointer tagging"
15:13:17 <glguy> objects in the heap have an info pointer stored at a predictable place that points to a description of what type of thing is stored at that location
15:13:28 <glguy> Also, pointer tagging is used
15:13:34 <merijn> glguy: Right, but that's separate from the thunk vs value tagging
15:13:46 * hackagebot yesod-transloadit 0.2.0.0 - Transloadit support for Yesod  http://hackage.haskell.org/package/yesod-transloadit-0.2.0.0 (boblong)
15:14:17 <merijn> Anyway, at this point it might be more productive to read the runtime description and STG paper :p
15:14:54 <erisco> where is this info pointer stored? is this part of every value then?
15:15:12 <merijn> basically, in front of the data
15:15:20 <erisco> this info pointer is on the heap adjacent to the data I presume
15:15:27 <merijn> So if you'd have an Int# (unboxed machine word)
15:15:46 <merijn> Actually, maybe bad example
15:16:23 <merijn> Let's go with "data Foo = Foo Bool Int#" <- a (boxed) boolean and an unboxed int (hence Int# instead of Int)
15:16:28 <glguy> erisco: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects
15:16:45 <haasn> I want to run GHCi on my phone :(
15:17:39 <merijn> Actually, yes, read that wiki page so I can go sleep ;)
15:18:37 <erisco> thanks
15:19:16 <rom1504> haasn: open http://tryhaskell.org/ in your android browser
15:19:48 <erisco> so other than GC and allocators, there is quite a bit more control than I imagined over memory
15:20:39 <merijn> erisco: See also: http://research.microsoft.com/apps/pubs/default.aspx?id=67083 and http://ezyang.com/jfp-ghc-rts-draft.pdf for more gory low level GHC details
15:21:00 <merijn> And now it's bed time for me :)
15:21:02 <haasn> rom1504: I don't run Android, and that's not GHCi (can't make local definitions iirc)
15:22:10 <rom1504> well get a <your phone os> ssh client and connect on your server that has ghci
15:22:49 <haasn> I don't always have a working internet connection :(
15:23:00 <haasn> Incidentally, tryhaskell.org doesn't seem to work :(
15:23:23 <haasn> clearly we need to elevate ARM-Linux to a Tier 1 GHC platform
15:27:07 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org | RIP Paul Hudak https://news.ycombinator.com/item?id=9465999'
15:27:07 --- topic: set by geekosaur!allbery@dreamshell.ttuttle.net on [Tue May 05 12:18:08 2015]
15:27:38 <rom1504> clearly :p
15:41:48 <benzrf> gaaaaaaaaaaaaah
15:42:00 <benzrf> GLFW fails to install due to AMP
15:42:02 <benzrf> ;-;
15:47:11 <c_wraith> benzrf: is https://hackage.haskell.org/package/gl a decent substitute?
15:48:24 <benzrf> c_wraith: it was a transitive dependency
15:48:47 * hackagebot memcache 0.0.1 - A memcached client library.  http://hackage.haskell.org/package/memcache-0.0.1 (DavidTerei)
16:02:44 <rasen> Hello, guys! Is there a foldl with short circuiting. Basically, I want to iterate N times, but I may want to break on any iteration.
16:03:23 <erisco> uh that is annoying, ghci cannot handle unboxed tuples
16:03:43 <erisco> so workaround is conditional compilation blocks?
16:05:50 <slack1256> rasen: why dont you 'foldl' func 0 $ take N list'
16:06:10 <slack1256> > foldl' (+) 0 $ take 20 [1..]
16:06:11 <lambdabot>  210
16:06:32 <rasen> I don't know in advance if I should break on each given iteration
16:06:43 <rasen> That depends on accumulator value
16:07:16 <shachaf> An example, or a type, or something, might help.
16:07:20 <slack1256> so the lenght of the list depends on some internal value? maybe you need unfoldr
16:07:59 <rasen> the length of list is N. Basically, it's [n, n-1 .. 1]
16:09:22 <rasen> but there are chances I need break this iteration
16:09:45 <slack1256> > unfoldr (\a -> if a >= 10 then Nothing else Just (a, a + 1)) 0
16:09:46 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
16:09:52 <slack1256> something like that?
16:10:31 <rasen> Give me a sec
16:10:31 <slack1256> You create the list of a certain form with unfoldr and you proccess it later with the foldl'
16:10:59 <slack1256> On a side note, unfoldr doesn't fit well with Foldable right?
16:11:08 <rasen> I can't create list in advance
16:11:31 <rasen> I will now the actual needed length in the middle of computation
16:11:46 <slack1256> I am going to need a better explanation of what you need then :-(
16:12:21 <slack1256> I am thinking you are putting two separated problems on one.
16:14:05 <erisco> is there some magic to use boxed tuples in ghci but unboxed outside?
16:14:10 <erisco> with ghc that is
16:16:09 <rasen> I have something like this now: http://lpaste.net/132062 It's not ready, but it shows how it iterates
16:17:09 <rasen> Basically, when it can't normalize matrix, it breaks and returns what it has now.
16:18:08 <maerwald> rasen: I thought it's easy to short-circuit with foldr
16:18:08 <pranz> erisco: maybe there is a preprocessor conditional to check if running GHCI, but otherwise it seems improbable
16:18:35 <erisco> pranz well I presume there is
16:18:56 <erisco> and I could try and be clever and just swap out which alias is being used
16:18:56 <imPure> Wow, it really is impossible to get the declaration of a function using Template Haskell.
16:18:59 <slack1256> rasen: http://lpaste.net/132062
16:19:04 <erisco> problem is that I cannot have the fancy syntax then
16:19:29 <imPure> I've shaved this Yak raw.
16:19:40 <slack1256> opps missed an 'a'.
16:19:56 <maerwald> > foldr (\x y -> if x == 3 then x else x + y) 0 [1, 2, 3, 4]
16:19:58 <lambdabot>  6
16:20:19 <srhb> maerwald: You shouldn't foldr with a strict operator.
16:20:24 <slack1256> yep. But foldr only short-circuits on the first argument
16:20:34 <slack1256> he wants to conditionaly build a structure
16:20:38 <srhb> Ah.
16:27:18 <rasen> I've though about something like foldlM with Either a a
16:31:58 <slack1256> rasen: weren't the guard patterns what you needed?
16:32:42 <rasen> no)
16:33:35 <rasen> The code already works (that was ViewPatterns), but it uses explicit recursion
16:34:22 <slack1256> and that is bad because...
16:35:26 <rasen> I don't know) I think folds are usually better
16:36:06 <maerwald> depends, they can also obfuscate easily understandable explicit recursion
16:49:24 <hiptobecubic> yes
16:49:45 <hiptobecubic> I'm not a big fan of folds with enormous folding functions that make it really hard to figure out what on earth is supposed to be happening
17:04:08 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org | RIP Paul Hudak https://news.ycombinator.com/item?id=9465999'
17:04:08 --- topic: set by geekosaur!allbery@dreamshell.ttuttle.net on [Tue May 05 12:18:08 2015]
17:07:55 <kirill`> Does anybody have experience using GLFW-b (bindings to GLFW version 3)?
17:07:55 <kirill`> I'm trying to run the main loop in ghci, and it crashes.
17:07:55 <kirill`> I'm not sure if that's expected or I'm doing something wrong?
17:08:48 <kirill`> The crash is due to some NSInternalInconsistencyException, so I guess some internal logic goes wrong somewhere.
17:16:40 <rasen> It works fine if you compile it?
17:17:07 <kirill`> rasen: Yes, it only crashes if I run it with ":main" in ghci
17:17:53 <h-core> so something i found interesting with haskell is that if i use a lambda expression that has incomplete pattern matching i get a simple one line answer saying exactly that, but if i take the lambda, and make it an internal function with where i get a much more helpful and detailed error message that tells me the patterns that aren't matched, is there a reason it works like this? couldn't the lambda error tell me the same (although i might not b
17:17:54 <h-core> e able to address the issue as a lambda)?
17:18:38 <Iceland_jack> h-core: You can often fix that by making the pattern match lazy
17:18:48 <Iceland_jack>     do ...
17:18:48 <Iceland_jack>        ~(Just x) <- ...
17:18:48 <Iceland_jack>        ...
17:18:50 * hackagebot reflex-dom 0.1 - Glitch-free Functional Reactive Programming  http://hackage.haskell.org/package/reflex-dom-0.1 (RyanTrinkle)
17:19:14 <schell> kirill`: i think there’s a ticket for that already
17:19:14 <arkeet> Iceland_jack: fix what?
17:19:25 <h-core> Iceland_jack, does the ~ make it lazy?
17:19:28 <kadoban> h-core: You probably shouldn't be doing a lot of pattern matching with lambdas anyway, that sounds like a lot for a lambda to be doing in practice.
17:19:36 <arkeet> ~ makes a lazy pattern yes
17:19:49 <arkeet> \ ~(Just x) -> ...
17:20:02 <arkeet> I don't know what that has to do with the warning though.
17:20:06 <h-core> kadoban, totally but incomplete pattern matching can also help you realize things that are wrong, maybe you just need a simpler more general pattern in your lambda to begin with
17:20:08 <schell> kirill`: hmmm maybe not
17:20:33 <schell> kirill`: please submit an issue! :) https://github.com/bsl/GLFW-b/issues/
17:20:38 <h-core> i just find it peculiar that haskell can tell me what's wrong with the matching in a regular function but not a lambda
17:20:48 <kadoban> h-core: But aren't you saying it tells you anyway?
17:21:37 <h-core> kadoban, no the pattern matching error for a lambda looks like: ListOps.hs:34:18-40: Non-exhaustive patterns in lambda
17:21:49 <h-core> where as for a function it looks like: 
17:21:51 <h-core>     Pattern match(es) are non-exhaustive
17:21:52 <h-core>     In an equation for func: Patterns not matched: _ (_ : (_ : _))
17:22:13 <h-core> same exact function, just in one case it's defined as a function, and the other as a lambda
17:22:18 <arkeet> maybe beacuse it's kind of pointless to tell you which patterns aren't matched because there's no way to add more patterns
17:22:24 <rasen> Just curious, what that gives if you can't have multiple pattern matches in lambda anyway?
17:23:16 <kadoban> h-core: Yes, but … doesn't that tell you that it's wrong? And does it need to say more? If you're getting that it probably means you either typoed somehow or you should refactor it into a full function definition anyway …
17:23:21 <rasen> The only case I see is when single-constructor data type gets new constructor
17:23:38 --- mode: ChanServ set +o johnw
17:23:46 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org' by johnw
17:23:49 --- mode: johnw set -o johnw
17:24:43 <h-core> arkeet / rasen, i could do something like \(a:as) -> sum (a:as) and get incomplete pattern matching, this is a silly case but still the error could show me that i'm not matching [] and that may help me realize it should be \a -> sum a
17:25:25 <arkeet> I don't see how just saying that it's incomplete isn't enough to help you realize that.
17:25:36 <h-core> im just saying there's cases where you can be too specific, and maybe you need to be less so and if you can see which patterns you're missing it may help with tweaking the lambda without breaking it out into a full function
17:26:32 <arkeet> I'm not trying to argue that it's perfect as it is, just saying why I think it does that
17:27:10 <h-core> arkeet, well for someone who is relatively new it would be more helpful, or even if the error message suggested making it into its own function
17:27:39 <h-core> arkeet, yeah i totally understand, just wondering if there was a technical reason
17:27:44 <arkeet> > (\True -> ()) False
17:27:45 <lambdabot>  *Exception: <interactive>:3:2-12: Non-exhaustive patterns in lambda
17:27:55 <arkeet> > (\ ~True -> ()) False
17:27:56 <lambdabot>  ()
17:28:05 <arkeet> > (\ ~(Just a) -> a) Nothing
17:28:07 <lambdabot>  *Exception: <interactive>:3:2-17: Irrefutable pattern failed for pattern (Ju...
17:28:48 <glguy> h-core: You can turn on a warning for that: -fwarn-incomplete-uni-patterns
17:28:48 <arkeet> actually
17:29:01 <glguy> h-core: and you'll get a message like: In a lambda abstraction: Patterns not matched: []
17:29:22 <h-core> glguy, neat, wonder why that's not part of -Wall
17:29:39 <glguy> I imagine its not on by default because if you're writing a pattern in a lambda it actually means you only intend to match that pattern
17:29:52 <arkeet> the "non-exhaustive patterns in lambda" is a runtime exception, not a warning
17:29:53 <h-core> hrmm true
17:30:35 <arkeet> it doesn't produce any sort of warning
17:30:49 <glguy> You get the warning with the flag I mentioned
17:30:51 <arkeet> unless you turn that on
17:31:43 <arkeet> interesting that it's not part of -Wall though
17:32:04 <glguy> There are other warnings that aren't in Wall, it's not the only one
17:32:30 <petercommand> you can use something like lambda case to do full pattern matching though
17:32:35 <petercommand> in order to prevent this problem
17:32:41 <glguy> since people will turn on Wall and insist that everything that comes up has to be fixed one must be careful what actually gets added to it
17:34:46 <dmwit> Is there, like, a -Wall_but_i_sign_this_waiver_agreeing_that_these_are_warnings_and_not_errors that is actually all the warnings?
17:34:51 <kirill`> schell: https://github.com/bsl/GLFW-b/issues/53
17:35:16 <dmwit> -Wall is a funny name for something that does not include all warnings. =P
17:35:50 <schell> kirill`: thanks!
17:36:04 <glguy> dmwit: I hope not. It'd start appearing in cabal files all over the place!
17:36:29 * dmwit waltzes off to craft a dangerous blog post entitled "Here's what you should put in your cabal files to REALLY get all the warnings!"
17:36:46 * glguy brings down the local network
17:36:51 <rasen> dmwit: in gcc there is -Wall, which doesn't include all warnings either
17:37:01 <nolrai666> I want that blog post.
17:37:07 <dmwit> -Wall -fwarn-incomplete-uni-patterns -fwarn-all-whitespace -fwarn-weather-is-changing
17:37:25 <nolrai666> :P
17:37:28 <glguy> -fwarn-missed-operator-opportunity
17:37:35 <arkeet> ghc doc lists which warnings aren't enabled by -Wall
17:37:39 <dmwit> -fwarn-no-tabs
17:37:41 <arkeet> but -fwarn-incomplete-uni-patterns isn't in that list
17:38:02 <glguy> arkeet: Maybe the docs should be built with -fwarn-incomplete-Wall-list
17:38:51 <arkeet> heh
17:40:43 <glguy> I'm glad the guy that make the Out-of-memory process killer wasn't in charge of writing the fileystem layer
17:41:18 <dmwit> glguy: You probably didn't need that file, and plus it was the biggest one.
17:41:18 <bitemyapp> glguy: lmao
17:41:24 <Hafydd> Hahah.
17:42:38 <Hafydd> @remember glguy I'm glad the guy that make the Out-of-memory process killer wasn't in charge of writing the fileystem layer
17:42:38 <lambdabot> Done.
17:53:50 * hackagebot b9 0.5.2 - A tool and library for building virtual machine images.  http://hackage.haskell.org/package/b9-0.5.2 (SvenHeyll)
17:54:01 <dfeuer> Is the binary leaf tree over a type the free magma for that type?
17:54:26 <dfeuer> [assuming finiteness and totality?]
17:54:42 <schell> how can i check which thread i’m on in ghci? i had always assumed everything is running in the “main thread”
17:55:25 <shachaf> The same way you check anywhere else.
17:55:33 <shachaf> It's in Control.Concurrent.
17:55:45 <dmwit> dfeuer: Sounds right to me.
17:55:53 <dfeuer> Thanks, dmwit.
17:56:26 <dfeuer> And the NonEmpty is the free semigroup, and the list the free monoid....
17:56:39 <schell> shachaf: thanks, i’m guessing myThreadId? though i’m not sure i can tell which thread id would be the “main” one
17:57:10 <dmwit> schell: What does "main thread" mean to you?
17:58:35 <schell> dmwit: i’m trying to debug a problem in GLFW-b where creating a window in ghci causes some Objc code to fail an assertion, one that seemingly thinks the operation is not happening on “the main thread”
17:58:44 <schell> specifically it says “+[NSUndoManager(NSInternal) _endTopLevelGroupings] is only safe to invoke on the main thread.”
17:58:49 <dmwit> dfeuer: How about the free commutative monoid? =)
17:58:51 <schell> which doesn’t give me much info
17:58:53 <shachaf> The main thread is the thread where, when you throw it an exception, it has to catch it.
17:59:35 <dmwit> schell: You will probably like http://dmwit.com/gtk2hs which discusses threading and another GUI library that has thread-local state.
18:00:05 <arkeet> ghci with threaded stuff is kind of funny.
18:00:14 <dmwit> schell: My guess is that here "main thread" means "OS thread that started the GUI".
18:00:58 <erisco> if you do    sequence (fmap f [min..max])   this allocates a list merely to serve as a loop counter, correct?
18:01:01 <schell> that makes sense - i just don’t know where the switch happens if there is one
18:01:11 <schell> unless it’s a bug in glfw itself
18:01:11 <dfeuer> dmwit, ummmmm..... I have no idea what that looks like.
18:02:15 <dmwit> schell: I believe that ghci runs each line of your code in a fresh unbound thread. At the very least you should code inside ghci as if that were the case.
18:03:34 <schell> dmwit: thanks - turns out it’s a sandboxing issue
18:03:44 <dmwit> dfeuer: Tricky, huh? I'll give you a hint: the free commutative monoid is not algebraic. So you will need to use an abstract data type.
18:03:51 * hackagebot ipopt-hs 0.5.0.0 - haskell binding to ipopt and nlopt including automatic differentiation  http://hackage.haskell.org/package/ipopt-hs-0.5.0.0 (AdamVogt)
18:04:18 <dmwit> dfeuer: That is, you will need to enforce some invariants on how people are allowed to observe the data you've stored away.
18:04:23 <dfeuer> dmwit, this doesn't surprise me. Some sort of quotient, probably. But my knowledge of algebra, while expanding, is still rather limited.
18:04:29 <schell> dmwit: using -fno-ghci-sandbox fixes it
18:04:34 <arkeet> yes, it's a quotient of the free monoid
18:04:59 <dmwit> dfeuer: It is a very familiar data structure. I encourage you to figure out which one. =)
18:05:02 <dfeuer> Quotient by the transitive closure ofthe exchange?
18:05:14 <dfeuer> Which makes it much like a bag?
18:05:21 <dmwit> bingo =)
18:05:33 <dfeuer> *nod nod*
18:05:36 <dmwit> How about free commutative, idempotent monoid...?
18:05:45 <dfeuer> What's an idempotent monoid?
18:05:51 <arkeet> x^2 = x for all x
18:05:51 <dmwit> m * m = m
18:06:02 <dfeuer> Ummmmm....
18:06:14 <dfeuer> Thinking.
18:06:33 <dmj`> Is bluespec open source?
18:06:42 <dmj`> the haskell fpga/asic solution
18:07:39 <dfeuer> dmwit, wild guess : a set.
18:07:45 <dmwit> nailed it again =)
18:07:57 <dfeuer> But I don't understand that really. Just guessed.
18:08:05 <dmwit> Well, start with bags.
18:08:08 <dfeuer> Or mostly guessed.
18:08:17 <dmwit> From m * m = m, you actually get m^n = m^1, right?
18:08:27 <dfeuer> Bags commutativity -> don't care about the order.
18:08:31 <arkeet> for n > 0 yes
18:08:37 <dmwit> So now instead of a bag, which maps from generators to numbers, you have something that maps from generators to the singleton set {1}...
18:08:38 <dfeuer> Oh, I see, sort of.
18:08:40 <dmwit> looks like a set
18:08:42 <erisco> I am confused
18:08:51 * hackagebot HList 0.4.0.0 - Heterogeneous lists  http://hackage.haskell.org/package/HList-0.4.0.0 (AdamVogt)
18:08:51 <napping> I'm getting Could not deduce (Comonad (Cofree f)) from the context (Functor f)
18:08:52 <erisco> if http://hackage.haskell.org/package/vector-0.5/docs/Data-Vector-Unboxed.html#t:MVector  is unboxed vectors, what are unboxed mutable vectors?
18:09:02 <napping> I guess my package database is a bit screwed up?
18:09:59 <subleq__> I wrote a simple server program. Now I want to benchmark its performance. Where do I start?
18:10:09 <haasn> What's the shortest way to count the number of semicolons in a String?
18:10:19 <haasn> I came up with sum[1|';'<s]
18:10:22 <haasn> <-s] even
18:11:01 <dfeuer> dmwit, I'm attempting to write a nice clean monoid solver function in Idris. I wrote an ugly one already, but I think that thinking about it in terms of free magmas, semigroups, and monoids will let me do it properly.
18:11:17 <shachaf> haasn: As an expression with a free variable s?
18:11:28 <haasn> shachaf: Yes
18:11:37 <dmwit> dfeuer: I don't know what it means to "solve" a monoid. But, cool!
18:11:53 <haasn> shachaf: Even as a function, I think \s->sum[1|';'<-s] might be the smallest
18:12:07 <dfeuer> dmwit, in this context, it means to take two ASTs representing expressions in some monoid, and producing a proof that they are equivalent.
18:12:38 <haasn> length.filter(==';') just doesn't cut it
18:12:41 <dfeuer> (Assuming, of course, that they are. The type checker will complain in some horrible way if they're not.)
18:13:46 <dmwit> subleq__: You might like ekg, criterion. Or, if you want to use the server's API externally, I guess there are probably language-agnostic server benchmark tools.
18:13:51 * hackagebot Rlang-QQ 0.3.0.0 - quasiquoter for inline-R code  http://hackage.haskell.org/package/Rlang-QQ-0.3.0.0 (AdamVogt)
18:14:31 <haasn> lengthOf$each.only ';' is another variation, but alas longer
18:14:41 <haasn> (And also slightly cheating)
18:14:51 <dfeuer> dmwit, I started trying to implement finger trees, but ended up running into the need to produce proofs involving reassociations of, say, seven-term expressions. Not fun. Since Idris doesn't currently have a monoid solver, I figured I'd hack up something that would pretty much get the job done for me.
18:15:28 <napping> dfeuer: do you need commutativity?
18:15:50 <dfeuer> napping, nope. Hinze and Paterson's paper doesn't use it.
18:16:03 <dfeuer> What I *will* need, at some point,
18:16:04 <dmwit> dfeuer: I suppose you must assume that you have a decidable way to check equivalence in the underlying monoid. So why not just evaluate the AST and call out to the decidable equivalence?
18:16:08 <dfeuer> if I ever get there,
18:16:24 <dfeuer> is some more ringish stuff.
18:16:26 <dmwit> (I'm still not sure I understand the problem statement.)
18:16:43 <dfeuer> dmwit, no, I do not assume a decidable way to check equivalence.
18:16:45 <napping> For a simple non-commutative monoid, proof by reflection should work pretty well
18:16:51 <napping> are units a problem?
18:17:08 <dfeuer> napping, what is proof by reflection? I'm very ignorant.
18:17:12 <dfeuer> What is a unit?
18:17:34 <napping> oh, just getting started with proof and stuff in Idris then?
18:17:43 <dfeuer> dmwit, someone is working on a (currently experimental) "proper" ring solver for Idriis,
18:17:46 <dmwit> dfeuer: Then how could you hope to prove that, e.g., 2*15 and 10*3 are equivalent?
18:17:56 <dfeuer> and they use semidecidable equality when available.
18:17:58 <napping> dfeuer: how does this look: http://adam.chlipala.net/cpdt/html/Reflection.html
18:18:21 <napping> dmwit: I assume the goal is more like automatically proving that (x * (y * z)) = ((x * y) * z)
18:18:22 <dfeuer> dmwit, oh, I don't expect to do so with these tools.
18:18:51 * hackagebot b9 0.5.3 - A tool and library for building virtual machine images.  http://hackage.haskell.org/package/b9-0.5.3 (SvenHeyll)
18:19:02 <napping> I don't know anything about tactics in Idris, but the reflective part should be the same
18:19:09 <dfeuer> napping, looking. Yeah, I'm just getting started with this dependently typed stuff. It seems a lot easier to understand the basics in Idris than in Haskell, where the concepts are a little twisted.
18:19:29 <haasn> :t () :: (2*15) ~ (10*3) => ()
18:19:30 <lambdabot> ()
18:19:46 <napping> Hey, a section a little farther down is "A Monoid Expression Simplifier"
18:20:11 <dmwit> dfeuer: Okay. Seems like it shouldn't be hard to re-associate everything to the right on both terms and be done.
18:20:30 <arkeet> but what if the monoid has relations?
18:20:39 <dmwit> arkeet: Sounds like he's not interested in handling those.
18:20:53 <dfeuer> dmwit, I'm interested; I just have to start somewhere first.
18:21:21 <haasn> :t Proxy :: (2*15) ~ (10*x) => Proxy x -- man, GHC sure has come far
18:21:22 <lambdabot> Proxy 3
18:21:24 <dfeuer> arkeet, I assume you mean some extra simplifications that happen to be available?
18:21:52 <dmwit> Not all equations in monoid presentations can be read as simplifications.
18:22:26 <dfeuer> OK.
18:22:45 <arkeet> I mean relation in the sense of generators and relations.
18:22:51 <dfeuer> Oh, I get the drift. But what do these relations look like exactly?
18:23:02 <arkeet> any equation between elements of your monoid.
18:23:12 * dfeuer last looked at "relations" in this sense over a year ago, and didn't really understand them.
18:23:38 <dmwit> dfeuer: For example, 2*15 = 10*3 is a relation. =)
18:23:46 <dmwit> (Just to pick one out of thin air.)
18:24:17 <dfeuer> dmwit, I shouldn't need anything like that to implement finger trees, but ... how would it be handled in general?
18:24:36 <dmwit> I would expect it to be undecidable in general.
18:24:45 <arkeet> it is undecidable in general.
18:24:52 <dmwit> Which is why I asked about it in the first place.
18:25:07 <dfeuer> The main (horrible) complication I'm trying to deal with 
18:25:21 <dfeuer> is that the semigroup/monoid may only be so up to some arbitrary equivalence relation.
18:25:21 <dmwit> ("You must assume that you have a decidable way to check equivalence in the underlying monoid." <- here)
18:26:02 <dfeuer> Which equivalence relation may not be decidable. But if I have a decidable, or partially decidable, equivalence, how do I use it?
18:26:04 <napping> dfeuer: that's not hard to work around. If that chapter makes sense to you it should explain most of what you need
18:26:37 <napping> I think you have two different issues here
18:26:38 <dfeuer> napping, the syntax and terminology and such are quite unfamiliar.
18:26:42 <dfeuer> OK.
18:26:49 <napping> a decidable equality is needed at runtime for the lookup operations
18:26:58 <dfeuer> Lookup?
18:27:10 <napping> isn't that what a finger tree needs the equality or comparison for?
18:27:16 <napping> finding an entry based on the labels?
18:27:24 <dfeuer> Not really.
18:27:40 <dfeuer> Lookup is done using an arbitrary monotonic predicate.
18:27:45 <dfeuer> Which must be decidable.
18:27:51 <napping> Where does the decidable equality come in then?
18:28:14 <dfeuer> It doesn't, I don't think, in the finger tree context.
18:28:36 <napping> Huh
18:28:42 <dfeuer> But I imagine it's very useful in general, and I was curious how one might use it when one has it, for these purposes.
18:28:45 <napping> I guess it's not a problem then
18:28:46 <dmwit> dfeuer: Well, that's sort of why I'm confused. If you're willing to assume you have a decidable equivalence relation on the underlying monoid, why wouldn't you just call that decision procedure on the output of interpreting the monoid AST?
18:28:47 <dfeuer> Well, similar.
18:29:04 <dfeuer> dmwit, I don't assume that.
18:29:06 <napping> It's probably not going to help you prove anything about symbolic monoid expressions
18:29:21 <dmwit> dfeuer: 18:25 < dfeuer> Which equivalence relation may not be decidable. But if I have a decidable, or partially decidable, equivalence, how do I use it?
18:29:32 <dmwit> dfeuer: You assume it right there in your question!
18:29:36 <napping> The only little thing it might give you is justifying reasoning by excluded middle over whether two monoid values are euqual
18:29:59 <dfeuer> dmwit, I meant hypothetically. As in, if I want a more general way to produce equivalence proofs, that sounds useful, but I don't know how to use it.
18:30:07 <napping> For proving things, like that your tree operations properly preserve labling, you just need to know that associativity and other stuff in the monoid holds up to your relation
18:30:31 <napping> as in, axioms saying things like forall a b c, (a * (b * c)) ~= ((a * b) * c), for whatever equivalence ~= you are working under
18:30:33 <dmwit> dfeuer: And I think I'm telling you how to use it.
18:31:00 <napping> That's something you can have whether or not the equivalence is decidable
18:31:07 <dfeuer> dmwit, you're confusing me now!
18:31:50 <napping> dfeuer: well, the basic idea for monoids from that chapter is to define a datatype something like data MonoidAST a = Op (MonoidAST a) (MonoidAST a) | Leaf a
18:32:12 <napping> and something like eval :: (a -> a -> a) -> MonoidAST a -> a, that just fills in the operation
18:32:20 <dfeuer> napping, yeah, and I have something that does that already. But I think it's ugly, because it defines its own equivalence based on the underlying semigroup structure, which seems like overkill since it's only doing "syntactic" manipulation.
18:32:25 <napping> and a reassociation function
18:33:02 <dfeuer> napping, this is what I did already: https://gist.github.com/treeowl/afc7afeb1d099967991f
18:33:20 <dfeuer> Like I said, it does work, but it's just kind of ... yucky.
18:33:57 <dfeuer> Nothing stops the functions from accidentally using the underlying structure in a way that could damage completeness.
18:34:07 <napping> I don't know what all this stuff wityh Sem is, but csmWorks is the right kind of lemma
18:34:35 <napping> you're not going to have completeness anyway
18:34:46 <dfeuer> That is, I could, accidentally, turn the AST's zero into an injected underlying zero,
18:34:57 <napping> so?
18:34:59 <dfeuer> which would cause it to fail to prove two things equivalent that it very clearly should.
18:35:13 <napping> yeah?
18:35:26 <napping> You can write a tactic or reflective procedure that doesn't always worki
18:35:30 <dfeuer> Well, it's best to be as obviously correct as possible. Parametricity should help with that here.
18:35:35 <dfeuer> Sure!
18:35:55 <napping> splitting out the values might help
18:36:04 <dfeuer> But it should, when possible, be as clear as possible when it will work!
18:36:09 <dfeuer> Splitting out?
18:36:25 <napping> make your AST type take indices into an environment, rather than directly embedding values
18:36:45 <dfeuer> That sounds really complicated.
18:36:54 <napping> or use parametricity, yes. Either way the normalizer can't mess with the actual value
18:37:02 <dfeuer> The attractive thing about using dfree structures is parametricity kicks in.
18:37:18 <napping> Isn't your canonMS' already sufficiently polymorphic?
18:37:20 <dfeuer> Yeah, that's the idea.
18:37:26 <dfeuer> Nope.
18:37:44 <napping> I'd expect more of an AST
18:37:51 <dfeuer> o.O
18:37:57 <dfeuer> maybe I use bad terminology.
18:38:00 <napping> why doesn't MonBit or MonCanonS have a constructor for plus?
18:38:39 <dfeuer> napping, that stuff is all going to be reworked a bunch, but all that does is let you stick zeros into the semigroup structure.
18:38:40 <napping> In particualr, canonMS' shouldn't need that MyMonoid constraint
18:38:44 <napping> it's just reassociating stuff
18:38:52 <napping> It should be just reassociating stuff, at least
18:39:01 <dfeuer> Yeah, that's what I'm working on now. The problem is that the way I did it there,
18:39:14 <napping> Then only csmWorks needs the MyMonoid constraint, to get the axioms to prove that reassociation is actually valid
18:39:16 <dfeuer> equivalence was defined in terms of evaluation in the underlying structure,
18:39:22 <dfeuer> which forced the bad constraints.
18:39:34 <napping> that's what csmWorks will have to deal with anyway
18:39:34 <dfeuer> So .... I'm fixing it now.
18:39:49 <dfeuer> Or trying to, anyway.
18:39:52 <napping> Maybe just design your data structures a little bit differently so canonMS doesn't have enough context to do stuff
18:39:58 <napping> but it seems basically on the right tract
18:40:05 <dfeuer> Thanks.
18:40:08 <dfeuer> However!
18:40:20 <napping> Except I don't get what this Sem is at all, and I'd really expect the three-constructor type I wrote
18:40:54 <dfeuer> What dmwit was saying earlier about things like free commutative monoids (which I don't need today!) will not like that parametricity as much, I think.
18:40:57 <napping> Oh, the other thing splitting out an environment lets you do is compare ASTs for equality
18:41:02 <dfeuer> napping, Sem is the free magma.
18:41:15 <napping> like, you have (Op (El 1) (El 2)) in an environment [a,b,c]
18:41:34 <napping> and the AST part is then comparable without assuming any equality or anything over the lists
18:41:48 <dfeuer> But then you have to deal with all that environment structure...
18:41:51 <napping> Ah, if Sem is a free magma type I guess it's okay
18:42:08 <dfeuer> napping, well, I didn't realize that's what it was until later....
18:42:32 <napping> except I don't see canonMS actually doing much canonicallization. How does it reassociate things?
18:43:02 <dmwit> I would expect to write something with a type like (v : MonoidAST a) -> (v' : MonoidAST a, eval v =~ eval v') which produces a canonicalized AST and a proof that you haven't changed the evaluation behavior.
18:43:22 <dfeuer> napping, it doesn't. It converts an expression in some monoid to either "it's just zero" or an expression in the monoid considered as a semigroup.
18:43:24 <dmwit> This will be easy to write and easy to use.
18:43:39 <dmwit> No extra structures needed.
18:43:43 <napping> dmwit: for parametricity reasons it's a bit nicer to split it into a separate function and proof
18:44:16 <dfeuer> dmwit, yeah, but it seems nice to express "canonicalized" in a separate type.
18:44:17 <dmwit> "parametricity reasons"?
18:44:19 <napping> dfeuer: For automation proof, reassociating stuff is as important as zeros
18:44:32 <dfeuer> napping, that all happens in the semigroup side.
18:44:41 <dfeuer> Look lower on the page.
18:45:29 <napping> I don't see how this reassociates anything: canonS (SPlus xs ys) = canonS xs <++> canonS ys
18:45:40 <napping> but as long as it's taken care of somehow, you should have a reasonably usable solver
18:45:41 <dfeuer> The monoid side actually is a bit wrong.
18:45:57 <dfeuer> napping, that reassociates because it's adding free semigroups!
18:46:11 <napping> The other bit is getting Idris to turn an arbitrary monoid expression into an eval call on your AST
18:46:11 <dfeuer> The <++> has to actually append them.
18:46:17 <napping> Coq would use Ltac
18:47:12 <dfeuer> napping, that is way beyond my knowledge. But with the finger tree stuff, it's much easier to write a three or four line call to something like this, with an explicit AST, than to reassociate potentially long and nasty expressions by hand.
18:47:41 <napping> yeah, the Agda ring solver relied on providing an AST by hand as well
18:48:46 <napping> You shouldn't need much more than canonMS, csmWorks, and solveMonoid
18:49:23 <napping> at least that's all the reflective solver part should take
18:49:36 <Sonarpulse> So rust has a "libstd facade" where basically a heirarchy of libraries implement their standard library based on things whether things like allocation, unix-like os, are assumed to exist
18:49:36 <napping> If the rest is just defining your own monoid class or whatever that's fine, I don't know Idris
18:49:42 <dfeuer> solveMonoid is a bit broken though, because it doesn't actually call down to the semigroup solver.... Also, the interface for the monoid side is horrifying. I'll get it fixed.
18:49:50 <Sonarpulse> has anybody ever considered doing something similar for base?
18:50:20 <Sonarpulse> Seperating the pure, ghc-specific, and unix-specific parts while keeping the same interface?
18:50:21 <napping> Sonarpulse: not as far as I know, except that System.FilePath does get a different implementation for unix and windows
18:50:23 <dfeuer> napping, well, some of that is defining my own classes (based on what someone else did), and a lot of the rest is implementing supporting stuf for those functions.
18:50:48 <Sonarpulse> seems just like an elegant thing in general, and might have real benefits for stuff like HalVM
18:50:51 <napping> dfeuer: maybe you could get some idea how bit the code is in Coq
18:51:23 <napping> Even if you don't follow it. I'm not sure if it's oversized, but the basic design is about what I expect
18:51:35 <dfeuer> napping, I don't know Coq at all. I can fumble my way through reading some Agda, but that's about it.
18:52:09 <dfeuer> Anyway, I really must be going... I have things I *need* to do.
18:52:21 <dfeuer> And not nearly enough time to do them in.
18:52:26 <dfeuer> Thanks a lot!
18:52:33 <napping> Does recursion-schemes directly provide something like (Foldable t) => (Base t a -> a) -> t -> Cofree (Base t) a?
18:52:37 <napping> Bye
18:56:04 <infandum> What is the type signature (from https://hackage.haskell.org/package/pipes-text-0.0.0.16/docs/Pipes-Text-Tutorial.html) for: stripLines = Group.maps (>-> Text.stripStart) . view Text.lines
18:57:45 <dmwit> infandum: ...if only there were some automated tool that could work through all the details needed.
18:59:11 <infandum> dmwit: yeah yeah I just used ghci
18:59:28 <infandum> haha I didn't think cabal repl worked if the file wont compile, but it does
18:59:56 <napping> there may have been a bug about that a while ago
19:01:01 <jle`> hi everyone
19:01:26 <jle`> can we get a MonadPlus/Alternative instance for (->) r?
19:01:29 <jle`> thank you
19:02:19 <napping> how to define empty :: r -> a?
19:02:46 <simpson> jle`: Yeah, what'd you have in mind?
19:04:30 <napping> ReaderT propagates MonadPlus, at least
19:04:58 <napping> oh, and Alternative as well
19:05:26 <napping> Anybody know why compadata-automata hasn't updated?
19:07:04 <simpson> Well, ReaderT does it by pushing it down to the underlying instance.
19:07:17 <napping> I think that's the best you can do
19:07:33 <simpson> I think so too, but I'm not 100%.
19:07:45 <napping> Functions (-> r) might have some notion of choice depending on r, but that would be a contravariant functor
19:08:53 * hackagebot network-msg 0.5 - Recvmsg and sendmsg bindings.  http://hackage.haskell.org/package/network-msg-0.5 (sickmind)
19:12:22 <jle`> my original idea was a bit misguided
19:12:35 <jle`> i was actually thinking of 
19:13:42 <jle`> (->) r . m
19:14:11 <subleq__> dmwit: I do want to test the external interface. Would it make sense to write a client program that used criterion? Or is it crazy to use criterion to benchmark something running in another process
19:14:38 <napping> jle`: Ah, that's basically ReaderT r m
19:17:55 <erisco> working with MVector seems clumsy... why is there not so much as a fromList? http://hackage.haskell.org/package/vector-0.5/docs/Data-Vector-Unboxed-Mutable.html
19:19:19 <pacak>  erisco: MVector is also a Vector and there is fromList for that.
19:19:29 <erisco> and this  MVector (PrimState m)   part is confusing
19:19:37 <erisco> why does it have some monad type in it
19:19:47 <erisco> pacak it is? how does that work
19:20:04 <pacak> :t pure
19:20:05 <lambdabot> Applicative f => a -> f a
19:20:09 <pacak> :t (>>=)
19:20:10 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:20:30 <erisco> why are you giving me that
19:20:31 <pacak> > pure 4 >>= \x -> return (x + 1) :: Maybe Int
19:20:33 <lambdabot>  Just 5
19:20:45 <pacak> About the same way.
19:20:59 <erisco> back up a bit
19:21:27 <erisco> are you saying you can trivially convert from Vector to MVector?
19:21:38 <kidto> Hey all, how's it going? I'm trying to import Data.Word8, but I'm being told by ghc that it doesn't exist. Am I crazy?
19:21:53 <pacak> kidto: Yep. It's in Data.Word
19:22:01 <kidto> Data.Word.Word8?
19:22:11 <pacak> Right
19:22:29 <erisco> also, a bunch of things are called MVector it seems
19:22:37 <shachaf> The question is what you thought importing Data.Word8 would do.
19:22:51 <shachaf> Does some documentation need to be updated? Or were you trying to import the module from the package "word8"?
19:23:28 <kidto> I just need to have access to the type so that I can write a function randomBytes :: Int -> StdGen -> [Word8]
19:24:20 <kidto> I'm going through lyah and thought I would try creating a very large random file
19:24:41 <kidto> using Data.ByteString.Lazy's writeFile
19:24:55 <kidto> and compare it to Data.ByteString's writeFile
19:26:13 <pacak> kidto: Function you are trying to write is basically the same as \cnt -> take cnt . randoms
19:26:26 <pacak> kidto: And Word8 is defined in Data.Word
19:26:49 <erisco> why must it be so confusing :(
19:27:00 <kidto> I didn't think Word8 was in the Random typeclass is all
19:27:35 <pacak> kidto: instance is there
19:28:04 <kidto> https://hackage.haskell.org/package/word8-0.0.0/docs/Data-Word8.html pacak: I don't see it. Is this outdated?
19:28:48 <pacak> kidto: You probably want one from base
19:29:11 <pacak> http://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Word.html#t:Word8 
19:29:43 <erisco> :k Vector
19:29:44 <lambdabot> Not in scope: type constructor or class ‘Vector’
19:30:09 <kidto> pacal: woah..what is the difference between those two pages?
19:30:24 <kidto> pacak: woah..what is the difference between those two pages? What is a haskell library? haha
19:30:27 <erisco> grr
19:30:48 <kidto> pacak: that's besides the point. I'll look that up. I don't see Random under instances?
19:31:10 <pacak> kidto: Those instances are defined in random package
19:31:13 <kidto> > take 5 randoms :: [Word8]
19:31:14 <lambdabot>      Couldn't match expected type ‘[Word8]’
19:31:14 <lambdabot>                  with actual type ‘g0 -> [a0]’
19:31:14 <lambdabot>      Probable cause: ‘randoms’ is applied to too few arguments
19:31:24 <pacak> http://hackage.haskell.org/package/random-1.1/docs/System-Random.html#v:randoms 
19:31:33 <pacak> :t randoms
19:31:34 <lambdabot> (RandomGen g, Random a) => g -> [a]
19:31:47 <pacak> :t randoms (mkStdGen 1)
19:31:48 <lambdabot> Random a => [a]
19:31:52 <kidto> Oh. Is that how it gets documented? That's good to know
19:31:55 <pacak> :t randoms (mkStdGen 1) :: [Word8]
19:31:56 <lambdabot> [Word8]
19:32:06 <pacak> > take 100 $ randoms (mkStdGen 1) :: [Word8]
19:32:08 <lambdabot>  [167,246,17,47,74,75,10,11,12,168,21,217,154,227,168,21,190,102,72,110,174,5...
19:32:43 <kidto> then I can just pack that into a ByteString?
19:33:13 <pacak> kidto: Yep. Not very efficient but it should work.
19:33:44 <kidto> thanks, pacak
19:34:27 <erisco> pacak I cannot see any evidence that MVector is a Vector
19:35:01 <erisco> or that  (PrimMonad m) => MVector (PrimState m)   is a Vector even
19:35:36 <erisco> or any trivial way to convert from Vector to MVector
19:35:55 <erisco> other than allocate an MVector and copy the elements from the Vector one by one
19:36:06 <pacak> erisco: That page you pointed at talks about unboxed vectors
19:36:17 <pacak> class (Vector Vector a, MVector MVector a) => Unbox a 
19:36:25 <pacak> And there's this requirement
19:36:34 <erisco> and so?
19:36:50 <pacak> So if you use fromList it should probably work.
19:37:06 <erisco> it doesn't
19:37:55 <johnw> you have to copy a Vector into an MVector
19:38:00 <johnw> there's no way to make a Vector mutable
19:38:06 <johnw> from MVector to Vector, you freeze
19:39:51 <mjrosenb> nooooo... I don't think I can do this
19:39:58 <erisco> where is this freeze
19:40:00 <mjrosenb> at least not the way I want to
19:40:24 <erisco> yes I know you have to copy, but I figured there would be something much better than copying element by element
19:40:37 <erisco> I'd expect a memcpy kind of dealio
19:40:47 <johnw> for unboxed vectors it should do exactly that
19:40:57 <erisco> what is "it" ?
19:41:01 <johnw> boxed vectors are an array of pointers basically
19:41:04 <johnw> it = the vector library
19:41:11 <erisco> well show me where it does that
19:41:29 <erisco> I can't find it
19:41:51 <erisco> or this "freeze"
19:42:39 <erisco> found an unsafeFreeze here http://hackage.haskell.org/package/vector-0.5/docs/Data-Vector-Unboxed-Mutable.html
19:43:00 <erisco> ugh, another typeclass
19:43:48 <dmj`> :t Data.Vector.freeze
19:43:49 <lambdabot> Control.Monad.Primitive.PrimMonad m => Data.Vector.Mutable.MVector (Control.Monad.Primitive.PrimState m) a -> m (Data.Vector.Vector a)
19:43:58 <dmj`> :t Data.Vector.unfreeze
19:43:59 <lambdabot> Not in scope: ‘Data.Vector.unfreeze’
19:44:02 <kidto> hmmm.. pacak: if I try to Prelude.readFile that ByteString, ghc yells at me."copy.hs: big.txt: hGetContents: invalid argument (invalid byte sequence)" Do you know why it doesn't like ByteStrings?
19:44:10 <dmj`> :t Data.Vector.thaw
19:44:11 <lambdabot> Control.Monad.Primitive.PrimMonad m => Data.Vector.Vector a -> m (Data.Vector.Mutable.MVector (Control.Monad.Primitive.PrimState m) a)
19:44:19 <dmj`> unfreeze :)
19:45:07 * mjrosenb wants a function of type (a -> IO B) -> Event t a -> Event t b
19:45:20 <mjrosenb> or -> Event IO b
19:45:30 <erisco> dmj` okay but these are not in the unboxed modules
19:45:39 <erisco> this entire lib is difficult to grok oO
19:45:53 <mjrosenb> such that the actual IO performed by the first argument is only executed once per event
19:47:21 <erisco> oh, I guess 0.5 is really old
19:47:25 <johnw> mjrosenb: the IO has to propagate
19:47:32 <erisco> it'd be nice if Hackage redirected Google to the newer version
19:48:03 <nshepperd> erisco: Data.Vector.Generic.unsafeFreeze/Thaw
19:48:11 <dmj`> :t Data.Vector.Unboxed.freeze
19:48:12 <lambdabot> (Control.Monad.Primitive.PrimMonad m, Data.Vector.Unboxed.Base.Unbox a) => Data.Vector.Unboxed.Base.MVector (Control.Monad.Primitive.PrimState m) a -> m (Data.Vector.Unboxed.Base.Vector a)
19:48:18 <dmj`> :t Data.Vector.Unboxed.thaw
19:48:19 <lambdabot> (Control.Monad.Primitive.PrimMonad m, Data.Vector.Unboxed.Base.Unbox a) => Data.Vector.Unboxed.Base.Vector a -> m (Data.Vector.Unboxed.Base.MVector (Control.Monad.Primitive.PrimState m) a)
19:48:35 <mjrosenb> johnw: not really.  I'm like 90% sure that Event is doing IO under the hood.  If it is, then this should be possible.
19:48:41 <dmj`> erisco: latest bro
19:49:17 <johnw> mjrosenb: it should expose MonadIO then
19:49:20 <nshepperd> you can use unsafeFreeze/Thaw if you're sure the old vector isn't going to survive beyond that function call
19:49:21 <johnw> then your function is trivial
19:49:48 <johnw> and note, "if you're sure" means you're probably not sure
19:49:57 <erisco> dmj` this makes life a bit easier
19:50:02 <johnw> I can't tell you how many times unsafe* has bitten me because I didn't think of sharing possibilities
19:50:08 <johnw> in general, avoid it
19:50:16 <johnw> when you certain you know it's a good idea, avoid it more
19:50:46 <mjrosenb> it seems like Reactive.Banana likes translating IO a to Moment t a :-/
19:51:12 * mjrosenb would preffer this value be outside of any monads
19:51:28 <mjrosenb> but maybe that isn't possible?
19:53:21 <mjrosenb> OH!
19:53:46 <mjrosenb> I can *totally* move all of this to any monad I want, and it won't destroy all of my code!
19:53:53 <mjrosenb> ok, that makes this like 5% easier.
19:54:01 <mjrosenb> maaaaybe 6
19:57:21 <kidto> This may seem like a dumb question, but can Haskell do type inference for types that aren't directly visible?
19:57:40 <bitemyapp> "types that aren't directly visible" what does this mean?
19:58:28 <kidto> I might have answered my own question. I was thinking not visible/imported but used in a type declaration for a function or something
19:58:34 <kidto> but ghc would probably complain in that case?
19:58:51 <enthropy> inferred types can include names that aren't exported
19:58:54 * hackagebot Rlang-QQ 0.3.1.0 - quasiquoter for inline-R code  http://hackage.haskell.org/package/Rlang-QQ-0.3.1.0 (AdamVogt)
19:59:21 <enthropy> module Foo (a) where data A = A; a = A -- if you import Foo, you can't write a type signature for a' = a
19:59:33 <kidto> So my example is this: i have a let bigArray = take 1000000 $ randoms gen
20:00:15 <kidto> At this point haskell doesn't know about the type of bigArray, but then I do ByteString.writeFile "big.txt" (ByteString.pack bigArray)
20:00:41 <kidto> and now it knows that the type must be [Word8], but I haven't imported Word8
20:00:56 <kidto> is it because Word8 is hiding in ByteString somewhere?
20:01:32 <monochrom> no, it is because the Haskell report requires compilers to figure out types even when they are not imported.
20:02:11 <monochrom> the only requirement on you is "if you mention a name, then the name has to come from an import or from you"
20:03:25 <monochrom> "import" in Haskell is a name-space thing only. totally not a "bring in code" thing.
20:05:02 <kidto> ooo, I did not know that. So in this case, where is it learning about Word8 exactly? monochrom
20:06:14 <monochrom> the type of "pack" mentions Word8
20:06:15 <kadoban> kidto: ByteString. pack is [Word8] -> ByteString I believe
20:06:59 <monochrom> after full expansion, it means Data.Word8.
20:07:19 <kidto> That's pretty neat.
20:07:27 <monochrom> err, it means Data.Word.Word8, and from package "base"
20:08:55 <monochrom> Haskell is not the most automatic in this regard.
20:11:06 <monochrom> SML is even more automatic. without importing anything, you can name-drop a full name like "Array.fromList" at any point.
20:11:41 <monochrom> SML's "open" statement is only for relieving you from writing "Array." all the time. that is all.
20:12:02 <erisco> okay this is super confusing
20:12:21 <erisco> (ST s) is supposed to be a PrimMonad  (no idea what this PrimMonad business is about)
20:12:54 <erisco> so I have a function  (Unbox a, PrimMonad m, Ord a) => Vector a -> m (Vector a)     so I'd expect to be able to pick any   ST s  I want
20:12:58 <erisco> and indeed it seems I can
20:12:58 <enthropy> @hackage primitive
20:12:58 <lambdabot> http://hackage.haskell.org/package/primitive
20:13:21 <erisco> but runST requires  forall s. ST s    and I haven't a clue how to indicate that
20:13:33 <erisco> I try type annotating with the forall but I just get a syntax error
20:13:39 <erisco> I enable RankNTypes and still a syntax error
20:14:40 <monochrom> can you give a concrete name to your (Unbox a, PrimMonad m, Ord a) => Vector a -> m (Vector a)  so I can concretely mention it in concrete code?
20:14:51 <erisco> insertionSort
20:15:04 <erisco> I am trying to make it  (Ord a) => Vector a -> Vector a
20:15:21 <monochrom> are you saying that "runST (insertionSort <a vector here>)" is a type error?
20:15:28 <erisco> yes
20:15:55 <monochrom> where is "Unbox a" in " (Ord a) => Vector a -> Vector a"?
20:15:57 <erisco> no wait a second, it isn't
20:16:06 <erisco> wat =\
20:16:27 <erisco> why is   :t runST . insertionSort   a type error
20:16:47 <nshepperd> because . is rank-1
20:17:09 <erisco> okay well I guess I don't understand all the implications of this rank thing
20:18:46 <monochrom> in order for "runST . insertionSort" to make sense, you require (.) :: (forall s. ST s a -> a) -> (x -> forall s. ST s a) -> (x -> a)
20:18:55 <nshepperd> i believe that (b -> c) -> (a -> b) -> a -> c does not allow for 'b = forall s. ST s _'
20:19:25 <monochrom> right, that too. that aspect is "predicative type", i.e., not "impredicative type"
20:20:05 <monochrom> "impredicative type" is when you can plug a forall type into a type variable. another example is "Maybe (forall a. ...)"
20:20:20 <monochrom> GHC cannot do impredicative type
20:21:18 <monochrom> normally, this also implies that "runST $ insertionSort v" has the same problem. but practically, by unwashed mass demand, GHC special-cases $ to allow it.
20:22:02 <nshepperd> oh, actually, turns out (.) :: (forall s. ST s a -> a) -> (x -> forall s. ST s a) -> (x -> a) is valid
20:22:06 <monochrom> there may be a special interest pressure group petition you can sign to demand that (.) receives the same special status
20:22:07 <nshepperd> in this case
20:22:17 <nshepperd> but it can't be inferred
20:22:47 <monochrom> this is how tax laws are made by politicians
20:23:17 <ReinH> lol
20:23:43 <pharaun> nice one
20:25:47 <octopuscabbage> does anyone have a haskell project on github they'd like some help with? I can do bug fixes or documentation. I'm looking for a project now that school is winding down.
20:27:28 <ryantrinkle> octopuscabbage: could always use more hands on https://github.com/ryantrinkle/reflex-dom or other FRP-based frameworks :)
20:28:00 <octopuscabbage> ryantrinkle, I can certainly try, i'm not that knowledgable of frp or dom but there's an open issue i can look at
20:28:39 <ryantrinkle> not too many open issues right now, but we could definitely use more docs
20:29:19 <ryantrinkle> also, if there's an area that would be more interesting to you than DOM, there are some other projects getting started to apply FRP in other areas
20:29:41 <octopuscabbage> such as?
20:30:02 <ryantrinkle> one guy is working on a MIDI interface
20:30:20 <nshepperd> :t let (.^) = (\f g x -> f (g x)) :: ((forall s. ST s a) -> a) -> (x -> forall s. ST s a) -> (x -> a) in runST .^ return
20:30:21 <lambdabot> a -> a
20:30:39 <arkeet> :t runST . return
20:30:40 <nshepperd> ^^ unneccessarily verbose composition with runST
20:30:41 <lambdabot>     Couldn't match type ‘m0 a’ with ‘forall s. ST s c’
20:30:41 <lambdabot>     Expected type: m0 a -> c
20:30:41 <lambdabot>       Actual type: (forall s. ST s c) -> c
20:30:49 <ryantrinkle> i have a sample tiny framework at https://github.com/ryantrinkle/try-reflex/blob/master/examples/host.hs
20:31:00 <ryantrinkle> pretty much anything interactive can benefit from FRP, imho
20:32:15 <octopuscabbage> i'll take a look at it tomorrow after physics, thanks
20:32:32 <RenRenJuan> mmmm, octopuscabbage and frp kool-aid
20:32:58 <ryantrinkle> octopuscabbage: sounds good :) https://github.com/ryantrinkle/try-reflex will get you set up in about 5 minutes if you have a fast internet connection
20:33:19 <ryantrinkle> with GHCJS, all the necessary libraries, etc.
20:33:29 <ryantrinkle> RenRenJuan: i've got more if you'd like me to serve you some!
20:33:32 <ryantrinkle> haha
20:33:35 <octopuscabbage> ryantrinkle, I don't have ghcjs installes so that'll be a trick to do
20:33:47 <ryantrinkle> octopuscabbage: try-reflex installs ghcjs for you ;)
20:33:51 <RenRenJuan> can I have a side of s-expression snausages?
20:33:57 <ryantrinkle> it creates a nix sandbox with everything you need
20:34:04 <ryantrinkle> (including installing nix if you don't have it)
20:34:11 <ryantrinkle> if you don't like it afterwards, just rm -rf /nix
20:34:29 <ryantrinkle> RenRenJuan: for that, you'll have to ask someone else :P
20:34:31 <octopuscabbage> i'll have to look into it tomorrow
20:34:46 <ryantrinkle> cool :) let me know if you have any questions, or head over to #reflex-frp
20:34:51 <johnw> ryantrinkle: is there an option for using the current nixpkgs master, instead of cloning something else?
20:35:23 <ryantrinkle> johnw: i don't have an option for that, but it *might* work
20:35:28 <ryantrinkle> it was very close last i checked
20:35:40 <johnw> what's the attr I need to build, just reflex?
20:35:41 <ryantrinkle> if you just check out master in the 'nixpkgs' subfolder, it'll use that
20:35:56 <ryantrinkle> johnw: well, you probably want reflex-dom, which just went up on hackage about 3 hours ago
20:36:02 <johnw> haha
20:36:16 <ryantrinkle> but if you use try-reflex with your own nixpkgs, it'll just add reflex and reflex-dom locally
20:36:34 <ryantrinkle> you should use the develop branch of try-reflex, as it's closer to nixpkgs's master
20:36:58 <ryantrinkle> i'm hoping i can abandon my fork entirely, soon, but there have been a lot of little snags that have forced me to keep it
20:37:23 <ryantrinkle> johnw: what's the state of pure darwin wrt master these days?
20:37:35 <johnw> not sure, it's not being actitvely developed right now
20:37:45 <ryantrinkle> ah
20:37:49 <johnw> we ran into snags with frameworks, which has been dispiriting
20:37:49 <ryantrinkle> have folks given up on purity?
20:37:54 <johnw> no, not given up
20:38:01 <johnw> ask copumpkin in ##nix-darwin
20:38:04 <ryantrinkle> well, that's good to hear
20:38:19 <johnw> non-framework stuff will build with chroot even now
20:38:21 <ryantrinkle> right now my nixpkgs is an unholy merge of master from a couple months ago and pure-darwin
20:38:30 <johnw> ah
20:38:45 <ryantrinkle> without using pure-darwin, i couldn't get build hashes to be at all repeatable on macos
20:38:55 * hackagebot stackage-update 0.1.0.4 - Update your package index incrementally (requires git)  http://hackage.haskell.org/package/stackage-update-0.1.0.4 (MichaelSnoyman)
20:39:08 <ryantrinkle> which meant people were getting 4+ hour builds instead of couple-minute downloads
20:39:17 <johnw> yeah
20:41:47 <dmj`> ryantrinkle: had the same problem, and abandoned
20:42:08 <nocturne777> for monad transformers, do people generally use mtl or transformers? on the wiki it says if you care about portability, use transformers. As long as I stay on GHC, I should not have to worry about portability, right?
20:42:23 <ryantrinkle> dmj`: well, i can happily report that it works fairly reliably with copumpkin's pure-darwin port
20:42:38 <ryantrinkle> i do occasionally get issues where apple stops offering downloads
20:42:42 <ryantrinkle> so things that used to build don't anymore
20:42:52 <ryantrinkle> but at least hashes don't magically change out from under me
20:43:18 <dmj`> ryantrinkle: ah very nice, is this on his github?
20:44:42 <ryantrinkle> https://github.com/ryantrinkle/nixpkgs/commits/ghcjs-ng
20:44:50 <ryantrinkle> that's my latest verified working branch
20:44:59 <ryantrinkle> as you can see, it's not extremely new
20:45:32 <dmj`> haha :) only a few commits behind
20:45:40 <ryantrinkle> haha yeah
20:45:56 <ryantrinkle> unfortunately, the huge merge with copumpkin's work makes it basically impossible to track maste
20:45:56 <ryantrinkle> r
20:46:09 <ryantrinkle> i'm hoping his work makes it upstream eventually
20:46:39 <ryantrinkle> for try-reflex, i need to keep things stable, even if they're a little out of date
20:47:00 <ryantrinkle> the whole point of the package is to make things accessible for people who might not be familiar with nix or even all that familiar with haskell
20:47:10 <ryantrinkle> so end-user debugging isn't an option
20:48:50 <dmj`> yes, makes sense, seems osx will be an important platform here, I hope copumpkin's changes make it in too
20:49:19 <ryantrinkle> yeah, osx is very important to support
20:49:37 <ryantrinkle> i'd be interested in supporting windows, too, but it seems that nix is rather far from running in cygwin
20:52:40 <nshepperd> nocturne777: mtl is based on transformers now
20:53:33 <nshepperd> nocturne777: mtl provides MonadWhatever typeclasses while transformers defines the actual data types, i think
20:54:11 <nshepperd> so you can use both really
20:54:43 <nocturne777> nshepperd: hmm, I see. I also hear that mtl has more goodies 
20:54:45 <dmj`> ryantrinkle: yea, might be stretch, I'm sure it'd work w/ vanilla cabal though. Could make a virtualbox image for windows users
20:55:13 <ryantrinkle> dmj`: yeah, i've been thinking about the best way to approach it
20:55:18 <ryantrinkle> it would be great to provide native binaries and builds
20:55:23 <ryantrinkle> but it seems like a *lot* of work
20:56:15 <ryantrinkle> i originally switched to linux from windows because haskell support was better!
20:58:28 <dmj`> ryantrinkle: yea, similar story here, would be interesting to see nix on windows. 
20:59:38 <Guest25952> Hello, everyone. I'm a newbie to Haskell. I fee very confusing about the traverse defination: (traverse f = sequenceA . fmap f & sequenceA = traverse id). Could you tell me how to understand them? Thanks ahead!
21:00:17 <dmj`> Guest25952: http://stackoverflow.com/questions/7460809/can-someone-explain-the-traverse-function-in-haskell
21:00:42 <johnw> Guest25952: if you get what sequenceA does, traverse can be explained in terms of it
21:00:46 <johnw> I find it the easier function to grok
21:01:23 <slack1256> Guest25952: It's made that way that if you decide implement only sequenceA, then traverse is implemented on term of the other.
21:01:30 <slack1256> you can implement both if you want
21:01:58 <shachaf> traverse in terms of sequenceA depends on fmap
21:02:29 <johnw> well, true, if you don't fully grok Functor, then maybe it's not easier at all
21:04:11 <Guest25952> I don't know how to expend the definition step by step, will it be in infinite loop?
21:04:34 <Hijiri> Guest25952: those are default definitions, they will infinite loop unless one is defined manually
21:04:52 <Hijiri> When someone makes a Traversable instance, they have to implement either traverse or sequenceA (or both)
21:04:59 <Hijiri> that way you don't get that problem
21:05:22 <Hijiri> so either traverse or sequenceA gets replaced by the explicit definition
21:05:37 <arkeet> it's similar to the default definitions in the Eq class
21:05:50 <arkeet> (==) and (/=) are defined in terms of each other by defualt.
21:06:05 <Guest25952> Oh, so the default definition should not be used, and we need implement them by ourselves?
21:06:16 <arkeet> you need to implement at least one of them.
21:06:40 <arkeet> if you define traverse, sequenceA will use your definition of traverse.
21:06:43 <arkeet> by default.
21:07:07 <Guest25952> Thanks! I almost got mad about the default definition.
21:08:11 <arkeet> if you look at the docs it shows a "minimal complete definition"
21:08:14 <shachaf> arkeet: Remember when derived Traversable and Functor instances took quadratic time?
21:08:21 <arkeet> yes
21:08:22 <arkeet> somewhat
21:08:28 <arkeet> anyway
21:08:40 <arkeet> that tells you what you must define in an instance
21:08:45 <arkeet> in order for everything to work
21:08:55 <arkeet> https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Traversable.html#t:Traversable
21:09:08 <shachaf> Unfortunately it doesn't help if you use instance Functor F where fmap = fmapDefault
21:09:11 <arkeet> this one says traverse | sequenceA, which means you need to define either traverse or sequenceA.
21:09:16 <shachaf> No way to communicate that to the compiler.
21:09:22 <arkeet> heh.
21:09:39 <arkeet> you mean if you just define sequenceA.
21:10:07 <arkeet> he left. :(
21:13:57 * hackagebot Yampa 0.10.1.1 - Library for programming hybrid systems.  http://hackage.haskell.org/package/Yampa-0.10.1.1 (IvanPerez)
21:18:57 * hackagebot foldl 1.0.10 - Composable, streaming, and efficient left folds  http://hackage.haskell.org/package/foldl-1.0.10 (GabrielGonzalez)
21:23:57 * hackagebot stackage 0.7.3.1 - Dummy package forcing installation of other Stackage packages  http://hackage.haskell.org/package/stackage-0.7.3.1 (MichaelSnoyman)
21:31:17 <erisco> monochrom so... how do I actually work around this limitation?
21:31:31 <erisco> I don't know how I am supposed to actually use runST then
21:31:56 <erisco> my expression is   x >>= f   which is some PrimMonad
21:32:07 <erisco> if I  runST (x >>= f)  I get a type error
21:32:30 <erisco> some blah blah skolem variable things
21:37:53 <erisco> the complication of this is absurd
21:41:37 <erisco> innocent things somehow stop working
21:47:58 <erisco> okay with ScopedTypeVariables and some annotations it magically starts working again
21:48:18 <erisco> I don't know what is up with these forall things but I don't like it
21:49:19 <fosskers> hi there
21:49:25 <nshepperd> the key to using ST is 'runST $ do {...}'
21:50:53 <erisco> I chose specifically for the monad to be  forall s. ST s   and it seemed to become happy
21:51:15 <erisco> there must be weirdness about how variables get instantiated and so on
21:51:45 <fosskers> What's the canonical way to kill a process using haskell? I have only the PID available to me, and fiddling with c-types through `System.Posix.Process` looks messy. 
21:56:25 <Hijiri> there is always the option of doing a kill command
21:57:36 <jle`> fosskers: do you mean processes you launch in haskell using forkIO, or system processes?
21:57:51 <fosskers> a system process
21:58:15 <jle`> i would probably shell out
21:58:17 <fosskers> all i know is the pid
21:58:20 <jle`> maybe that's a bad idea
21:58:53 <_fritz_> fosskers: look at System.Posix.Signals
21:59:13 <fosskers> i suppose i could just do a raw call with Shelly
21:59:28 <fosskers> _fritz_, yeah i was
22:00:25 <fosskers> `signalProcess` looks nice, except that ProcessID is a c-type
22:01:35 <erisco> adding additional state to loops is really annoying =\
22:04:03 <solatis_> is my conclusion correct that it liftIO doesn't work within STM ?
22:05:08 <_fritz_> fosskers: signalProcess sigKILL . CPid . fromIntegral ?
22:05:41 <pavonia> solatis: If STM isn't an instance of MonadIO it won't work
22:06:08 <solatis> pavonia, yeah i understand. i figure they don't like IO operations within STM
22:06:18 <_fritz_> yes, that's actually not nice, but there is from my point of view no better way to kill a process 
22:07:21 <jle`> erisco: how do you mean?
22:08:07 <erisco> because you might start with something simple, but then you need some more state and now you have to upgrade to a Mealy machine
22:08:24 <erisco> but then you find that gets a bit klutzy so now you want to use the State monad
22:08:48 <erisco> and then you find there are some special cases when you don't need the state, so now you have two versions of your functions where the State is sometimes ()
22:08:56 <erisco> a common progression it seems
22:09:08 <jle`> hm, if you don't care about the state, why don't just leave it as State s a?
22:09:16 <fosskers> _fritz_, since im already using Shelly, I might as well use `run_ "kill" ["-15",pidAsText]`
22:09:18 <jle`> or just make it a (a -> b)
22:09:21 <jle`> why even need State?
22:09:47 <jle`> but yeah, "state monad doesn't scale" is a sort of big deal for larger applications that i sort of tried to tackle with my library
22:10:38 <jle`> but people have tried making things more disciplined
22:10:51 <jle`> for certain circumstances you can actually use lens to solve a lot of problems
22:11:43 <jle`> the idea is being able to use a `State s1 a` and a `State s2 a` in the same sequence/do block/bind one from the other
22:14:52 <jle`> or, if you have a function on `State s1 a`, then you can "upgrade it" for free to work on a bigger `States s2 a`
22:14:54 <browndawg> what
22:15:45 <haskill> Whats the difference between push and pull based streams?
22:25:42 <deezn> Guys.. in LYAH.. it states: “Make sure that you really understand the distinction between type constructors and value constructors.”
22:26:40 <deezn> Am I correct in saying for example.. for Data Vector a = Vector a a a 
22:27:22 <deezn> That evenything on the LHS of the = is the type constructor and on the RHS of the = is the value constructor ? I am confused.
22:27:30 * nurupo serves some tea, coffee and a cup of fresh System.IO.Unsafe.unsafePerformIO
22:27:56 <peddie> deezn: data Vector a = V3 a a a  -- Vector is a type constructor, V3 is a value constructor
22:28:09 <peddie> deezn: the warning is because a lot of times, like in your example, they have the same name ("Vector")
22:28:15 <shachaf> In data T a = V a, T is a type constructor and V is a value-level constructor.
22:28:23 <shachaf> They exist in different namespaces.
22:28:56 <deezn> ok .. yeah that was confusing the V = V etc 
22:30:19 <deezn> If I didnt have a paramaterised type would it still be called a value constructor? or just a data constructor?
22:30:31 <erisco> deezn on the RHS of the = are the value constructors (aka data constructors) but note that you can also see type constructors on the RHS too
22:30:31 <deezn> I am looking over explanations etc and it is a little confusing. 
22:31:00 <deezn> ?
22:31:05 <shachaf> "data" is on the value level, "type" is on the type level.
22:31:21 <erisco> well, for example   data Foo a = Foo (Maybe a)
22:31:22 <arkeet> GADT syntax makes things a bit more clear I think
22:31:47 <shachaf> I don't think worrying about this too much is worth it.
22:31:55 <arkeet> you'll get used to it
22:32:09 <shachaf> Nothing and Just are (value-level) constructors for Maybe, but that's not so important.
22:32:15 <erisco> data Foo {- type constructor -} a {- type parameter -} = Foo {- value constructor -} (Maybe {- type constructor -} a {- type variable -})
22:32:24 <deezn> getting confused now. 
22:32:32 <arkeet> Nothing :: Maybe a
22:32:34 <arkeet> Just :: a -> Maybe a
22:32:49 <deezn> I am trying to sort out my knowledge so I can do this lab on GADTs.. 
22:33:23 <nurupo> deezn: for example: data BinaryTree a = Leaf a | Node BinaryTree a BinaryTree
22:33:23 <nurupo> you can't use "BinaryTree" to construct a value, you have to use any of "Leaf" or "Node" to construct a value. and you can say that both "Leaf" and "Node" are both "BinaryTree" when refferring to types
22:33:39 <shachaf> That's a kind error. :-(
22:33:41 <erisco> well nighty night!
22:33:46 <shachaf> "constructor" isn't really a very useful concept, I think.
22:33:46 <deezn> About GADTs.. the whole goal is that you can create your own generic types and still have the compiler check their types and that they are type safe? Right?
22:33:59 * hackagebot CouchDB 1.2.2 - CouchDB interface  http://hackage.haskell.org/package/CouchDB-1.2.2 (GaneshSittampalam)
22:34:22 <deezn> thx nurupo
22:34:42 <erisco> shachaf where is the definition of Just? "it is a constructor"! oh, okay
22:34:57 <erisco> shachaf other than that I don't think there is much significance to the term
22:35:25 <shachaf> It's also a type error, for that matter.
22:36:05 <nurupo> deezn: i.e. it's as if BinaryTree was an interface in Java or an abstract class in C++. you can't instantiate it directly, you have to use something that implements/inherets from it. but you can use it as a common base type when reffering to whateverimplements/inherets it
22:36:41 <peddie> O_o
22:36:52 <erisco> deezn no, that is not the goal of GADTs, that is just part of polymorphism (generic types) and the type system (type safety)
22:37:38 <deezn> ok I am confused.
22:37:44 <nurupo> lol
22:37:46 <deezn> about GADTS
22:38:02 <erisco> well it doesn't sound like you grasp ADTs yet, so maybe start there
22:38:03 <deezn> nurupo.. all good on your front.. thanks for the help
22:38:52 <erisco> deezn do you know Java? I have slides about implementing ADTs in Java
22:39:22 <erisco> there are not many words on them because that is given verbally, but the pictures may help
22:39:50 <deezn> yeah go for it.. 
22:39:54 <deezn> that will help.
22:40:07 <deezn> Where do I find them erisco
22:40:18 <erisco> deezn at this secret link http://www.erisco.net/adt_talk_slides.odp
22:43:55 <deezn> ok off to a lecture.. back in 2 hours.. thanks erisco. I have a few questions. I will ask them later if you are still around. 
22:43:59 * hackagebot stackage-setup 0.0.0.1 - An executable for downloading a Haskell setup  http://hackage.haskell.org/package/stackage-setup-0.0.0.1 (DanBurton)
22:44:28 <erisco> deezn leave me a message with lambdabot    @tell erisco your message
23:04:49 <Guest93755> Hi guys, can someone point out what I am missing. I am having this type declaration and i am getting the following errror.
23:04:50 <Guest93755> http://pastebin.com/t94gb0hx
23:06:57 <pacak> Guest*: What is Cons/Stream?
23:07:59 <mauke> Guest93755: that doesn't contain x / x
23:08:27 <Guest93755> oh sorry . this is a type constructor for stream
23:08:35 <Guest93755> ie. Stream a = Cons a Stream a
23:09:25 <Guest93755> I think i know what was wrong
23:26:09 <Sonarpulse> Ahg, I found https://ghc.haskell.org/trac/ghc/wiki/SplitBase and was sad to find that monad's fail wrecks everything
23:44:01 * hackagebot nested-routes 0.3.2 - Declarative, compositional Wai responses  http://hackage.haskell.org/package/nested-routes-0.3.2 (athanclark)
