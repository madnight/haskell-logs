00:07:38 * hackagebot Tainted 0.1.0 - Tainted type, and associated operations  http://hackage.haskell.org/package/Tainted-0.1.0 (RossMeikleham)
00:07:38 * hackagebot nagios-check 0.3.0 - Package for writing monitoring plugins  http://hackage.haskell.org/package/nagios-check-0.3.0 (fractalcat)
00:27:33 * hackagebot Tainted 0.1.0.1 - Tainted type, and associated operations  http://hackage.haskell.org/package/Tainted-0.1.0.1 (RossMeikleham)
00:27:35 * hackagebot haskellscript 0.2.1 - Command line tool for running Haskell scripts with a hashbang.  http://hackage.haskell.org/package/haskellscript-0.2.1 (seanparsons)
00:32:33 * hackagebot TransformersStepByStep 0.1.1.0 - Tutorial on monad transformers.  http://hackage.haskell.org/package/TransformersStepByStep-0.1.1.0 (MartinGrabmueller)
00:37:33 <srenatus> hi there. I find a lot of duplication in my .cabal file, for specifying the exported libraries and the executable -- is this actually needed?
00:37:33 * hackagebot AlgorithmW 0.1.1.0 - Example implementation of Algorithm W for Hindley-Milner  type inference.  http://hackage.haskell.org/package/AlgorithmW-0.1.1.0 (MartinGrabmueller)
00:40:12 <kadoban> srenatus: What kind of duplication?
00:40:32 <srenatus> kadoban: the same dependencies, sorry, forgot to mention
00:41:43 <kadoban> srenatus: You can have all of the actual dependencies in the library, and then the executable can just depend on the library. Unless the execs actually directly use the dependency … then yeah you just have to duplicate it.
00:42:10 <srenatus> kadoban: oh. ok, my executable just uses the lib. thanks
00:42:34 * hackagebot meep 0.1.2.0 - A silly container  http://hackage.haskell.org/package/meep-0.1.2.0 (MatveyAksenov)
00:43:29 <kadoban> srenatus: Yep, just depend on the library then (uses the same name as the project)
00:43:48 <srenatus> kadoban: I had indeed forgotten to depend on the library at all. weird.
00:46:52 <srenatus> related, what's a good approach to find a set of dependencies that works?  I.e. whenever I include my doctest-based tests, search fails, "Dependency tree exhaustively searched."
01:00:46 <Walther> > let rmSq = filter (\z -> [1..(sqrt x)]^^2 == z) in rmSq [1..16]
01:00:47 <lambdabot>      No instance for (Fractional [Expr]) arising from a use of ‘^^’
01:00:47 <lambdabot>      In the first argument of ‘(==)’, namely ‘[1 .. (sqrt x)] ^^ 2’
01:00:48 <lambdabot>      In the expression: [1 .. (sqrt x)] ^^ 2 == z
01:01:33 <liste> wrong variable?
01:02:49 <Walther> > let rmSq = filter (\x -> [1..(sqrt x)]^^2 == z) in rmSq [1..16]
01:02:50 <lambdabot>      Couldn't match expected type ‘[t1]’ with actual type ‘Expr’
01:02:50 <lambdabot>      Relevant bindings include
01:02:51 <lambdabot>        x :: t1 (bound at <interactive>:1:21)
01:02:54 <Walther> > let rmSq = filter (\x -> [1..(sqrt x)]^^2 == x) in rmSq [1..16]
01:02:56 <lambdabot>      Occurs check: cannot construct the infinite type: t1 ~ [t1]
01:02:56 <lambdabot>      Relevant bindings include
01:02:56 <lambdabot>        x :: t1 (bound at <interactive>:1:21)
01:03:26 <Axman6> Walther: using ^^ on a list doesn't make sense
01:03:33 <Axman6> :t (^^)
01:03:34 <lambdabot> (Fractional a, Integral b) => a -> b -> a
01:07:54 <liste> Walther any and all may help
01:07:57 <liste> @src any
01:07:57 <lambdabot> any p = or . map p
01:07:59 <liste> @src all
01:07:59 <lambdabot> all p = and . map p
01:08:45 <Walther> let rmSq = filter (\x -> elem x $ map (^^) [1..(sqrt x)])
01:09:29 <Walther> > let rmSq = filter (\x -> elem x $ map (^^) [1..(sqrt x)]) in rmSq [1..16]
01:09:31 <lambdabot>      Occurs check: cannot construct the infinite type: a1 ~ b1 -> a1
01:09:31 <lambdabot>      Relevant bindings include
01:09:31 <lambdabot>        x :: b1 -> a1 (bound at <interactive>:1:21)
01:11:57 <liste> map (^^2) maybe?'
01:12:35 * hackagebot Tainted 0.1.0.2 - Tainted type, and associated operations  http://hackage.haskell.org/package/Tainted-0.1.0.2 (RossMeikleham)
01:13:16 <Walther> > let rmSq = filter (not . \x -> elem x $ map (^^2) [1..(sqrt x)]) in rmSq [1..16]
01:13:18 <lambdabot>  [2.0,3.0,5.0,6.0,7.0,8.0,10.0,11.0,12.0,13.0,14.0,15.0]
01:13:46 <Walther> why do I get floats back even if i'm just filtering stuff out and shouldn't be editing the values themselves o_O
01:13:59 <opqdonut> > [1..16] :: [Float]
01:13:59 <Walther> that looks like a bit like a side effect to me
01:14:00 <lambdabot>  [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0]
01:14:05 <opqdonut> no, it's type inference
01:14:09 <KaneTW> :t [1..16]
01:14:10 <lambdabot> (Enum t, Num t) => [t]
01:14:11 <opqdonut> :t (^^)
01:14:12 <lambdabot> (Fractional a, Integral b) => a -> b -> a
01:14:19 <opqdonut> :t (^)
01:14:20 <lambdabot> (Integral b, Num a) => a -> b -> a
01:14:29 <opqdonut> you want to use ^ for ints
01:14:30 <Walther> but shouldn't that affect only the checking, not the output after filtering original list?
01:14:35 <Walther> hm
01:14:41 <opqdonut> Walther: the original list is interpreted as a list of floats
01:14:52 <KaneTW> the original list is a list of Num a => a
01:14:57 <opqdonut> :t filter (not . \x -> elem x $ map (^^2) [1..(sqrt x)])
01:14:59 <lambdabot> (Enum a, Eq a, Floating a) => [a] -> [a]
01:15:06 <opqdonut> see? your function wants Floating
01:15:11 <Walther> hmm
01:15:16 <Walther> with a single ^2 I still get floats
01:15:30 <opqdonut> oh that's the sqrt
01:15:51 <opqdonut> :t sqrt
01:15:52 <lambdabot> Floating a => a -> a
01:15:56 <opqdonut> taking you into float land
01:17:14 <Walther> :t floor sqrt 3
01:17:14 <opqdonut> :t filter (not . \x -> elem x $ map (^2) [1 .. ceiling $ sqrt $ fromIntegral x])
01:17:15 <lambdabot>     Could not deduce (RealFrac (a0 -> a0))
01:17:15 <lambdabot>       arising from a use of ‘floor’
01:17:16 <lambdabot>     from the context (Integral (a -> t), Num a)
01:17:16 <lambdabot> Integral a => [a] -> [a]
01:17:43 <opqdonut> I often end up defining "isqrt :: Int -> Int; isqrt = ceiling . sqrt . fromIntegral" or so
01:18:18 <opqdonut> and obviously that's not accurate for big integers
01:18:37 <opqdonut> a recursive isqrt using div is more appropriate for that
01:19:22 <Walther> well, i could just go ugly and remove the sqrt optimization :D
01:19:52 <augur> this is off topic, but i figure some of you might be interested. might be fun to rework with haskell: http://languagengine.co/blog/sierpinski-triangles-in-bitwise-logic
01:19:52 <Walther> it's not necessary for the removal itself, just a handy optimization to not test for all squares that are already bigger than x itself
01:21:11 <ion> @check \(NonNegative x) -> last (takeWhile (\y -> y*y <= x) [0..]) == floor (sqrt (fromInteger x))
01:21:12 <lambdabot>  +++ OK, passed 100 tests.
01:22:24 <ion> @check \x -> takeWhile (\y -> y*y <= x) [0..] == [0..floor (sqrt (fromInteger x))]
01:22:26 <lambdabot>  +++ OK, passed 100 tests.
01:23:07 <opqdonut> hmm, might actually work for Ints since they fit in Doubles, and the sqrt defaults to Double
01:26:14 <ion> Not all Ints can be converted to Double losslessly on a 64-bit system.
01:30:03 <opqdonut> > let x = 3037000499 in fromIntegral x - sqrt (fromIntegral $ x^2)
01:30:04 <lambdabot>  0.0
01:30:11 <opqdonut> huh, I thought that was a counterexample
01:30:42 <srenatus> If anyone could have throw a glance at this failing cabal install, I'd be much obliged: https://travis-ci.org/srenatus/rivum
01:34:13 <ttt_fff> does 'extreme programming / agile' techniques work in haskell ?
01:35:01 <opqdonut> ttt_fff: if they work in other languages, there's nothing in haskell to stop them from working in haskell too
01:35:43 <Cale> such diplomacy
01:35:54 <hnfmr> i have a simple "let ... in"
01:36:02 <hnfmr> why do I keep getting "parse error on "in""
01:36:06 <bergmark> srenatus: if you have ghc as a dependency you need to use the versions of boot libraries that it ships with, e.g. directory and filepath
01:36:17 <ttt_fff> hnfmr: depends on what "..." is
01:36:25 <Cale> hnfmr: Perhaps paste your code at lpaste.net
01:36:31 <ttt_fff> no no
01:36:39 <ttt_fff> give show it to us one character at a time, as we reuest it
01:36:46 <ttt_fff> pasting it all would make it too easy for us to debug
01:36:55 <srenatus> bergmark: hmm ok. doctest has ghc as a dependency. Ah, an I depend on filepath. thanks. 
01:37:21 <srenatus> bergmark: so I'll just drop the version constraint? to make it work with different GHCs?
01:37:55 <bergmark> srenatus: assuming the different versions are still compatible with yours, yes
01:38:12 <srenatus> bergmark: testing will tell ;) thanks again
01:38:32 <bergmark> srenatus: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Libraries/VersionHistory
01:39:14 <srenatus> bergmark: ta
01:39:27 <lpaste> hnfmr pasted “Let in parse error” at http://lpaste.net/133418
01:39:35 <solirc> srenatus: Haven't read in detail what your issue is, but I recommend by now to only run doctest (the executable) on travis
01:39:49 <hnfmr> parse error on "in"
01:40:00 <srenatus> solirc: ok. why is that?
01:40:10 <hnfmr> and then if I use "where" at the end.........It seems I can't capture variables defined above "where"......
01:40:28 <solirc> srenatus: that way your package does not depend on doctest
01:40:36 <ion> hnfmr: let has different rules in a do block.
01:40:43 <ttt_fff> there's no 'in'
01:40:44 <hnfmr> oh.....
01:40:47 <ttt_fff> it's just "let .... "
01:40:55 <hnfmr> so in a do....just "let"....
01:41:00 <solirc> srenatus: and does not have the transitive dependency on GHC, hence you don't have e.g. that transformers issue
01:41:14 <opqdonut> (you can actually use let...in in a do-block too)
01:41:17 <Cale> hnfmr: The 'in' being at the same indentation level as the 'let' means that it's part of a new statement of the do-block, separate from the first
01:41:33 <srenatus> solirc: indeed. do you happen to have an example travis.yml for that approach? ;)
01:41:45 <solirc> srenatus: trying to find one
01:41:47 <Cale> hnfmr: Within a do-block, you don't really need the 'in', since there's a statement-form which consists of just the 'let' followed by a sequence of declarations
01:42:13 <Cale> do { let { <decls> } ; <stmts> } translates to  let { <decls> } in do { <stmts> }
01:42:32 <srenatus> solirc: thanks
01:42:34 <hnfmr> Cale: aghh...thanks for the clarification..
01:42:40 <niqbal> i have a question regarding creating an instance of ‘type’ 
01:42:45 <solirc> srenatus: https://github.com/hspec/hspec-wai/blob/master/.travis.yml
01:42:55 <niqbal> my declaration is: type Account =  (TVar Int)
01:42:57 <srenatus> I also wonder if using https://github.com/hvr/multi-ghc-travis is the better approach, since 7.10 is ghc/stable now
01:43:00 <srenatus> solirc: thank you
01:43:01 <niqbal> how would i create one account. 
01:43:04 <ttt_fff> opaleye is the shit
01:43:34 <solirc> srenatus: or a more clean one https://github.com/sol/interpolate/blob/master/.travis.yml#L6
01:43:58 <srenatus> solirc: thanks, great
01:44:50 <bergmark> srenatus: i've started to use mult-ghc-travis for a few packages, it's super nice
01:44:58 <ion> niqbal: Exactly the same way you create a TVar Int. This types are now synonymous.
01:45:10 <niqbal> ok. 
01:45:14 <niqbal> let me try, thanks!
01:45:32 <ion> Those
01:49:33 <niqbal> @ion when I create  :t (newTVar 3)
01:49:33 <lambdabot> Maybe you meant: yow wn run nixon join id do
01:49:33 <niqbal> (newTVar 3) :: Num a => STM (TVar a)
01:50:11 <niqbal> and my function which  has Account arg, give an error. As:- STM (TVar a) != (TVar a)
01:55:42 <bergmark> i've never used newTVar :-o only newTVarIO
01:56:44 <liste> @nixon
01:56:44 <lambdabot> I played by the rules of politics as I found them.
02:00:02 <ion> niqbal: Is there a specific reason you need Account type to have a TVar in it?
02:00:45 <niqbal> i am copying code from an software transactional memory chapter. :)
02:01:03 <niqbal> i have done some homework in haskell before but not used STM. 
02:04:46 <echo-area> niqbal: I envy you for Haskell homework
02:05:20 <niqbal> @echo-area i wish i could also use it for my work. That homework was for a programming languages course.
02:05:20 <lambdabot> Unknown command, try @list
02:05:33 <bergmark> stm really shows why haskell shines, it's the easiest to use, and the least likely to introduce bugs
02:06:31 <SparkySparkyBoom> i recently started using haskell for a project
02:06:49 <Saizan> niqbal: STM is a monad, if you have code like "do x <- newTVar 3; ... x ..." the x will be of type TVar Int
02:06:54 <SparkySparkyBoom> and i can't remember why i hated it in the first place
02:08:24 <bergmark> i always knew it was super cool but i didn't understand how to make software with it at first
02:08:29 <echo-area> SparkySparkyBoom: Are you still hating?
02:09:35 <liste> how do they manage STM in Clojure btw? Does it just break if there's I/O inside=
02:12:18 <jle`> extra strictness causing performance hits and memory leaks
02:12:20 <jle`> story of my life
02:12:39 * hackagebot base32string 0.9.1 - Fast and safe representation of a Base-32 string  http://hackage.haskell.org/package/base32string-0.9.1 (solatis)
02:12:40 <DerisiveLogic> Anyone here from NYC?
02:13:03 <zettablade> I'm from Seattle
02:13:12 <zettablade> :D
02:16:37 <ion> I'm in the same Local Group.
02:16:48 <SparkySparkyBoom> echo-area: not anymore
02:16:56 <SparkySparkyBoom> but i haven't done anything with state yet
02:17:02 <SparkySparkyBoom> other than IO
02:17:27 <SparkySparkyBoom> i think last time i ragequit because of stm
02:17:32 <SparkySparkyBoom> i went to clojure
02:17:39 <SparkySparkyBoom> and then ragequit clojure too
02:18:36 <b_jonas> dcoutts: can you tell the current url of the 2014 icfp contest webpage? the 2015 webpage follows the tradition to not link to previous years'.
02:21:28 <jle`> Data.Map/Data.IntMap actually makes for a nice sparse array representation....
02:21:33 <jle`> in terms of performance
02:21:35 <jle`> neat
02:22:40 * hackagebot hindent 4.5.2 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.5.2 (ChrisDone)
02:26:08 <niqbal> @liste there is some macro which can detect IO 
02:26:08 <lambdabot> No module "there is some macro which can detect IO " loaded
02:31:48 <indiagreen> niqbal: @ at the beginning of line is treated as a lambdabot command
02:32:06 <niqbal> ok. i was also wondering about it. 
02:32:41 * hackagebot hindent 4.5.3 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.5.3 (ChrisDone)
02:33:25 <liste> well that was a fast version bump
02:33:56 <liste> (=new release)'
02:34:08 <zettablade> Must be cranking out the code tonight.
02:47:42 * hackagebot spaceprobe 0.3.0 - Optimization over arbitrary search spaces  http://hackage.haskell.org/package/spaceprobe-0.3.0 (SeanBurton)
03:05:38 <Phillemann> I have a _really_ strange problem with type families: http://lpaste.net/133420 - maybe someone can help
03:10:00 <Phillemann> Oh wait, it solved itself by fixing a different error a little bit further in the code.
03:11:18 <pacak> Phillemann: Worked for me...
03:12:43 <Phillemann> pacak: Yeah, it was some sort of consequential error. But thanks for testing it. :)
03:23:12 <Pato> I'm trying to define a type of tree that is similar to a leaf tree, where the leaves are a pair, named "Tri". When i'm defining the constructor, can I just use the "Tri a" or do I need to explicity use the pair?
03:24:29 <fvgvxmpv1> I´m trying to have Aeson derive fromJSON and toJSON instances for a datatype I call (Object FilePath FilePath), which seems to me perfectly reasonable. I don´t know how to pass the name to deriveJSON from Data.Aeson.TH — something like ‘$(deriveJSON … ''(Object FilePath FilePath))’ seems to be syntactically invalid and Aeson doesn´t seem to like type-synonyms.
03:25:53 <srenatus> re: executable/library in .cabal, I think I got it wrong: https://github.com/srenatus/rivum/blob/travis/rivum.cabal#L40 -> https://travis-ci.org/srenatus/rivum/jobs/64221667
03:26:00 <fvgvxmpv1> I´m trying to have Aeson derive fromJSON and toJSON instances for a datatype I call (Object FilePath FilePath), which seems to me perfectly reasonable. I don´t know how to pass the name to deriveJSON from Data.Aeson.TH — something like ‘$(deriveJSON … ''(Object FilePath FilePath))’ seems to be syntactically invalid and Aeson doesn´t seem to like type-synonyms.
03:27:14 <fvgvxmpv1> I´m trying to have Aeson derive fromJSON and toJSON instances for a datatype I call (Object FilePath FilePath), which seems to me perfectly reasonable. I don´t know how to pass the name to deriveJSON from Data.Aeson.TH — something like ‘$(deriveJSON … ''(Object FilePath FilePath))’ seems to be syntactically invalid and Aeson doesn´t seem to like type-synonyms.
03:27:17 <pavonia> Pato: "Tri a" will only have one value, you either want "Tri (a, a)" or "Tri a a"
03:28:24 <fvgvxmpv1> (I´m sorry if i sent my "question" multiple times — my transport is having… issues)
03:28:40 <bergmark> fvgvxmpv1: relatedly, aeson doesn't allow arbitrary key types
03:29:00 <Pato> pavonia: the "Tri" is defined as type Tri = (Point, Side). Where Point = (Int, Int) and Side = Int
03:29:43 <fvgvxmpv1> bergmark, ‘Object’ is not related to a JSON object at all (Also, FilePath is just a synonym for String)
03:29:44 <Pato> pavonia: now I'm trying to build a tree where I have either a Tri or 3 subtrees, like so: data TLTree a = Tri | Forkt (TLTree a,(TLTree a,TLTree a)) deriving (Eq,Show)
03:30:36 <pavonia> Pato: Tri won't hold any values here
03:30:57 <pavonia> It's just a constructor that build a value of type TLTree a
03:31:07 <indiagreen> fvgvxmpv1: can't you use generics instead?
03:31:28 <pavonia> Pato: "Tri Tri" wil define a constructor Tri that holds a value of type Tri
03:31:43 <nshepperd> Pato: 'data TLTree = Leaf Tri | Forkt TLTree TLTree TLTree' is one option
03:31:55 <bergmark> fvgvxmpv1: oh right :-) but yeah i second indiagreen 
03:33:07 <Pato> pavonia: oh, I see. So lets say I want to test in a simple function like testeFunction :: TLTtree -> Int. If I pass a ((a,b),c) it should accept the type, right?
03:34:03 <pavonia> Pato: No, you need to pattern match agains the constructor too
03:34:04 <fvgvxmpv1> indiagreen, so… deriving Generics und writing an empty instance declaration somewhere?
03:34:29 <indiagreen> fvgvxmpv1: there's an example in the docs, or here: http://artyom.me/aeson#records-and-json-generics
03:34:46 <indiagreen> yep, basically that
03:35:19 <fvgvxmpv1> Thanks for the help
03:35:26 <pavonia> Pato: Note that "(a, b, c)" and "Fork (a, b, c)" do not have the same type
03:35:43 <Pato> pavonia: so Tri ((a,b),c) ?
03:36:11 <pavonia> With extra parentheses, yes
03:36:38 <pavonia> func (Fork (a, b, c))
03:37:23 <pavonia> Pato: Also note that ((a, b), c); (a, (b, c)) and (a, b, c) are all different types too
03:37:46 <Pato> pavonia: alright, thank you very much
03:38:03 <pavonia> In constructors we usually avoid extra tuples, so "Fork (a, b, c)" would become "Fork a b c"
03:39:22 <srenatus> ah, got it. http://stackoverflow.com/questions/6711151/how-to-avoid-recompiling-in-this-cabal-file/6711739
03:40:32 <Pato> pavonia: It's saying that "Tri" is not a constructor in scope. I have data TLTree = Tri Tri | ForktTLTree TLTree TLTree
03:41:11 <pavonia> Could you paste a full sample?
03:41:14 <pavonia> @lpaste
03:41:14 <lambdabot> Haskell pastebin: http://lpaste.net/
03:42:15 <IgneNature> Pavonia, could you advise on a way to print/show the data from "sortlist list" http://lpaste.net/3837821065891938304
03:43:36 <lpaste> Pato pasted “patoTri” at http://lpaste.net/133421
03:43:49 <Pato> pavonia: done
03:44:07 <pavonia> IgneNature: "print (sortList [...])"?
03:44:50 <pavonia> Pato: And what is the full error message?
03:45:01 <Pato> pavonia: cp1415t.lhs:843:11: Not in scope: data constructor ‘Tri’
03:45:24 <pavonia> Do you import that from another module?
03:45:47 <Pato> pavonia: no
03:46:14 <pavonia> "testeTLT :: TLTree a -> Int" -- that type is wrong because TLTree doesn't take a parameter, but that should be unrelated
03:46:43 <pavonia> Actually, I don't know why it's complaining about the missing constructor
03:47:45 * hackagebot grid 7.8.3 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-7.8.3 (AmyDeBuitleir)
03:48:09 <Pato> pavonia: well, damn : (
03:51:33 <pavonia> Pato: When you comment the test function, load the module in GHCi and ask it about ":type Tri", what does it tell you?
03:51:49 <Pato> pavonia: this is very strange, because I moved the code (removing the a in the type declare) and it works just fine. Just not in the module I'm working
03:52:20 <Pato> pavonia: in the separated module I just copied, :t reads "Tri :: Tri -> TLTree"
03:52:45 * hackagebot grid 7.8.4 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-7.8.4 (AmyDeBuitleir)
03:52:47 * hackagebot conduit-extra 1.1.9 - Batteries included conduit: adapters for common libraries.  http://hackage.haskell.org/package/conduit-extra-1.1.9 (MichaelSnoyman)
03:52:48 <pavonia> You probably have a typo or something in your other module
03:53:45 <makalu> didn't a future version of GHC allow switching the Integer library without recompiling GHC? Does anyone remember in what version this will be available?
03:54:09 <IgneNature> Pavonia thanks :) managed to get rid of error, stupid me :)
03:56:43 <Pato> pavonia: The module was provided by my professor. If i try to make :t Tri, it says not in scope
03:57:05 <Pato> pavonia: but, as I said, if I copy the code it works. Not sure why it compiles just fine but doesn't give me the type
03:57:46 * hackagebot warp-tls 3.0.4 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-3.0.4 (MichaelSnoyman)
03:57:48 * hackagebot basic-prelude 0.4.1 - An enhanced core prelude; a common foundation for alternate preludes.  http://hackage.haskell.org/package/basic-prelude-0.4.1 (MichaelSnoyman)
03:57:57 <pavonia> Pato: Could you copy the definition of that tree type here?
03:59:05 <zipper> I'm reading about the reader monad from LYAH and quite honestly I don't see how a partially applied function is a monad.
04:00:11 <liste> zipper why wouldn't it be?
04:00:15 <Pato> pavonia: yes. There is a interesting thing I discovered. The type is: data TLTree = Tri Tri | Nodo TLTree TLTree TLTree. However, it just compiles IF I have other definition for TLTree (in the same file): data TLTree a = L a| N (TLTree a,(TLTree a,TLTree a)) deriving (Eq,Show). Otherwise, gives "not in scope"
04:00:56 <liste> you can define >>= and return for ((->) a) that satisfy the laws
04:01:01 <liste> ergo, it's a monad
04:01:16 <Walther> :t >>=
04:01:17 <lambdabot> parse error on input ‘>>=’
04:01:31 <Walther> :t (>>=)
04:01:32 <zipper> liste: Explain to me how h >>= f = \w -> f (h w) w f
04:01:33 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:01:36 <zipper> Nooo
04:01:50 <pavonia> Pato: You can't have two different types with the same name in one module
04:02:00 <zipper> liste: How f :: a -> m b and h is m a
04:02:08 <zipper> m in this case is Reader
04:02:34 <zipper> liste: More like I am looking at the code but it's not really "clicking".
04:02:36 <Pato> pavonia: As I said, this was the module the professor provided, and it compiles with both definitions. It gives me an error if I comment the second one
04:02:37 <pavonia> Pato: Are you really sure your first definition isn't hidden in a comment or so?
04:02:46 * hackagebot som 8.0.5 - Self-Organising Maps.  http://hackage.haskell.org/package/som-8.0.5 (AmyDeBuitleir)
04:03:56 <pavonia> Pato: Are you allowed to paste your full file?
04:04:11 <liste> well, substitute ((->) env) for m
04:04:36 <Pato> pavonia: I can give tou the file, but it's in portuguese, so you might find it confusing
04:04:57 <Pato> pavonia: \begin{spec} data TLTree = Tri Tri | Nodo TLTree TLTree TLTree \end{spec}
04:05:03 <Pato> pavonia: \begin{code} data TLTree a = L a| N (TLTree a,(TLTree a,TLTree a)) deriving (Eq,Show) \end{code}
04:05:10 <liste> so >>= becomes ((->) env) a -> (a -> ((->) env) b)) -> ((->) env) b
04:05:11 <Pato> pavonia: those are both the definitions I have
04:05:29 <liste> that is (env -> a) (a -> (env -> b)) -> (env -> b)
04:05:34 <pavonia> Pato: Ah, spec isn't real source code in a .lhs, IIRC
04:05:45 <liste> (env -> a) -> (a -> (env -> b)) -> (env -> b)
04:05:58 <Pato> pavonia: the second definition is "hidden" from the generated pdf
04:06:06 <Pato> pavonia: only the one between the "spec" is shown
04:06:32 <zipper> liste: Can we please go to #haskell-overflow?
04:06:41 <zipper> liste: Too many things here
04:06:45 <pavonia> Pato: Yes, because the first is only used for printing, while the second is used for producing the Haskell module
04:06:48 <liste> ok
04:07:41 <Pato> pavonia: so what should I do?  ":t" doesn't even give me the type
04:08:37 <pavonia> If you want to use it in your module, replace "spec" by "code"
04:09:10 <pavonia> Or copy the definition in a new code-block
04:09:44 <Pato> pavonia: Alright, ty
04:10:15 <Pato> pavonia: But, if I want to use the second definition how can I pass the "Tri"
04:10:36 <pavonia> Pass?
04:11:19 <Pato> pavonia: like if I want to define a function that receives a "Tri"
04:11:49 <pavonia> Haskell will use the definition in the code-block. If that defines a constructor Tri, it will be in scope of the module; otherwise you can't use it
04:12:29 <pavonia> s/Haskell/the compilter/
04:12:36 <pavonia> *compiler :/
04:12:47 * hackagebot creatur 5.9.6 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.9.6 (AmyDeBuitleir)
04:17:10 <haskell528> Hi, I have a question about Abstract Syntax Trees
04:17:35 <haskell528> I am using Alex+Happy to build an AST for a C-like language
04:17:44 <Pato> pavonia: the thing is, even with the second definition, if I write ":t TLTree", it gives me not in scope. This is truly confusing
04:18:49 <haskell528> And after the parser outputs and AST I have to traverse the tree for the Symbol identification phase
04:19:05 <pavonia> Pato: :type will give you the type of a value, but TLTree already is a type
04:19:26 <pavonia> Pato: Try :indo TLTree
04:19:32 <pavonia> :info
04:20:40 <Pato> pavonia: gives me the second definition, but the second definition only has an "a" on the Tri, so I should be losing information
04:20:45 <haskell528> The problem is, I do not know which is the best option to store the information after this Symbol identification phase. I was thinking of tying each use of a variable to a definition, producing a cyclic AST, but then I do not know how to mutate the tree
04:21:22 <haskell528> And later on I need to store the address of each variable somewhere
04:21:36 <pavonia> Pato: Well, why do you give a different definition than the one already there?
04:21:48 <haskell528> Anyone has experience with this?
04:22:17 <bergmark> haskell528: e.g. haskell-names annotates the tree with name information, `Exp Scope Foo` instead of just `Exp Foo`
04:24:15 <steshaw> mauke: thanks for your suggestion earlier about my code. I'm taking a look at it
04:24:32 <Pato> pavonia: I can't seem to get that one working. I'm trying to write a simple constant function that returns me a 1 if I pass a TLTree and it's a "Tri", but it fails every time
04:24:51 <haskell528> bergmark: Thanks, I'll take a look into it
04:26:42 <pavonia> Pato: Oh well, I have to go now. Good luck!
04:27:48 * hackagebot smallcheck-lens 0.1 - SmallCheck lens laws  http://hackage.haskell.org/package/smallcheck-lens-0.1 (jdnavarro)
04:33:01 <steshaw> mauke: Thanks. I liked it. I ended up with https://github.com/steshaw/huttons-razor/blob/master/src/Main.hs
04:34:37 <steshaw> If anyone cares to code review the above, please message me. I'm afk, so please tag me.
04:36:58 <matheus23> when executing "ghc-mod" in the terminal (newest version installed via cabal install) I get the following error: "/usr/lib/ghc-7.8.4/settings: openFile: does not exist (No such file or directory)". what does that mean and how to fix it? :S
04:38:05 <ion> steshaw: Top level type signatures would be helpful for the human reading the code.
04:38:40 <maerwald> and maybe a note what the code is about
04:40:52 <hodapp> woo, back to trying to figure out how to trick haskell-mode into *actually* using the cabal sandbox I told it to use
04:41:08 <DerisiveLogic> Anyone from NYC here that wants to be study partners?
04:41:10 <hodapp> I'm not sure how my work machine has been doing this for months, and I'm totally incapable of making it work on a new project
04:42:19 <Myrl-chan> @pl (\(x:xs) -> all (==x ) xs)
04:42:19 <lambdabot> ap (all . (==) . head) tail
04:42:33 <Myrl-chan> Hmmm... I see.
04:42:48 <lf94> :t all
04:42:49 * hackagebot muesli 0.1.0.1 - A simple document-oriented database  http://hackage.haskell.org/package/muesli-0.1.0.1 (CalinArdelean)
04:42:50 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
04:42:58 <hodapp> maybe I should just hack up the source code to give me a command to make Emacs run exactly the command I want...
04:43:12 <Myrl-chan> > all . (==) <*> [1,2,3]
04:43:14 <lambdabot>      Couldn't match expected type ‘[Integer -> b]’
04:43:14 <lambdabot>                  with actual type ‘() -> t0 () -> Bool’
04:43:14 <lambdabot>      In the first argument of ‘(<*>)’, namely ‘all . (==)’
04:43:16 <Myrl-chan> Lol
04:43:44 <Raydiation> lets say ive got a filter and then a map over a list, is there a way to combine this so that you need only one iteration?
04:43:57 <Fernandos> hi
04:44:05 <liste> Raydiation you get that for free
04:44:23 <liste> that's what laziness is all about
04:44:24 <Raydiation> liste: internal optimization?
04:45:08 <Fernandos> how do I know what library to install when I see an import statement, there are multiple results in cabal (btw. cabal errors alll the time after compilation). Example: import Bio.Sequence.Fasta (readFasta) also what does that thing in parenthesis mean?
04:45:11 <init> Raydiation: list/stream fusion is how that optimization is called
04:45:24 <Rembane> Is it done automatically for Data.List-lists?
04:45:40 <liste> Rembane you mean [a] ?
04:45:54 <muzzle> hi, does anyone know how long it takes for hackage to build documentation ?
04:46:17 <bergmark> muzzle: it depends...
04:46:21 <bergmark> on a lot of things i imagine
04:46:32 <steshaw> ion: Yes, I agree. Though I'll perhaps leave that as an exercise for the student.
04:46:40 <Fernandos> muzzle: there is hoogle, hackage, haddock, cabal and stk. I know that the last two are there for packages, what are the first three there for?
04:46:45 <Rembane> liste: Yeah.
04:47:00 <Rembane> liste: I know that Data.Vector does it, but I'm not so sure about Data.List.
04:47:04 <Fernandos> sorry I'm bloody new =)
04:47:05 <muzzle> Fernandos: hoogle is a search engine for documentation
04:47:05 <Myrl-chan> (\xs@(x:_) -> all (== x) xs
04:47:09 <Myrl-chan> @pl (\xs@(x:_) -> all (== x) xs)
04:47:10 <lambdabot> (line 1, column 5):
04:47:10 <lambdabot> unexpected "@"
04:47:10 <lambdabot> expecting letter or digit, operator, pattern or "->"
04:47:11 <steshaw> ion: It is idiomatic Haskell thought to have top-level type signatures?
04:47:12 <Myrl-chan> Hmmm
04:47:13 <muzzle> Fernandos: hackage is a package database
04:47:22 <Myrl-chan> @pl (\(xs@(x:_)) -> all (== x) xs)
04:47:22 <lambdabot> (line 1, column 6):
04:47:22 <lambdabot> unexpected "@"
04:47:22 <lambdabot> expecting letter or digit, operator or ")"
04:47:27 <Fernandos> wait.. a package database?? what is that
04:47:31 <bergmark> steshaw: yes
04:47:32 <muzzle> Fernandos: the cool thing is that you can also search by type in hoogle
04:47:37 <Myrl-chan> wat
04:47:50 * hackagebot minst-idx 0.1.0.0 - Read and write data in the IDX format used in e.g. the MINST database.  http://hackage.haskell.org/package/minst-idx-0.1.0.0 (muzzle)
04:48:02 <steshaw> ion: another option would be to embed all the top-level functions (except for `main`) in a where/let
04:48:07 <muzzle> Fernandos: It's just a storage for haskell packages where everyone can download
04:48:09 <liste> isn't stream fusion about not creating unnecessary objects when iterating lists? I may be wrong
04:48:25 <Fernandos> muzzle: aha... isn't that supposed to be in cabal than?
04:48:26 <steshaw> bergmark: tah
04:48:27 <Fernandos> then^
04:48:39 <Rembane> liste: That too.
04:48:52 <muzzle> Fernandos: No, but cabal uses hackage to download binaries / dependencies
04:49:00 <Fernandos> ahh
04:49:17 <muzzle> Fernandos: It downloads from hackage
04:49:54 <Fernandos> muzzle: I would like to install "Bio.Sequence.Fasta" where to look for and howto install it? Can you help me with that? I'm on Archlinux
04:50:39 <muzzle> Fernandos: google Bio.Sequence.Fasta, then you find a hackage page
04:50:47 <liste> > map (+1) . filter (>0) $ [trace "1" 1, trace "2" 2, trace "3" 3, trace "-1" -1]
04:50:48 <lambdabot>  Not in scope: ‘trace’Not in scope: ‘trace’Not in scope: ‘trace’Not in scope:...
04:50:53 <muzzle> Fernandos: http://hackage.haskell.org/package/bio-0.5.3
04:51:04 <liste> can I trace somehow in lambdabot?
04:51:06 <maerwald> is there a good tutorial for continuation monad? https://www.fpcomplete.com/school/advanced-haskell/the-mother-of-all-monads this is not really good, imo
04:51:08 <muzzle> Fernandos: then just use cabal install bio
04:51:16 <liste> @let import Debug.Trace
04:51:17 <lambdabot>  .L.hs:121:1:
04:51:17 <lambdabot>      Debug.Trace: Can't be safely imported!
04:51:17 <lambdabot>      The module itself isn't safe.
04:51:33 <ion> steshaw: It is, GHC even warns you if you leave them out.
04:51:36 <Fernandos> muzzle: thank you! I was trying to install the wrong package and it failed =)
04:51:53 <Fernandos> muzzle: do you use stk?
04:51:59 <Denommus> what is lambdabot's command to make a pointfree function?
04:52:09 <muzzle> Fernandos: stk ?
04:52:19 <ion> Assuming -Wall which everyone ought to be using
04:52:33 <Rembane> Raydiation: One way to speed things up is to combine the function sent to map and the function sent to filter and use the combined function in filter, this should speed things up.
04:52:38 <liste> Denommus @pl
04:52:39 <steshaw> ion: Oh yeah, I've neglected to turn on -Wall
04:52:56 <Rembane> Raydiation: Profiling is also good, so you know if your change made things faster. :)
04:52:58 <liste> @pl \x y -> x + y
04:52:58 <lambdabot> (+)
04:52:58 <muzzle> Fernandos: Do you have cabal installed ?
04:53:13 <Denommus> liste: thanks
04:53:17 <Fernandos> yes cabal-install version 1.22.2.0
04:53:43 <maerwald> Denommus: if you can't figure out the pointfree version of something yourself, then don't use @pl either
04:54:30 <Raydiation> Rembane: yep, unfortunately not very deep in haskell yet :P
04:54:40 <Denommus> maerwald: it was actually something very stupid, and the pointfree version was clearer
04:54:51 <Fernandos> muzzle: cabal alsmost always ends up with "compilation failed". Very very dissappointing after hours of compilation
04:54:53 <Denommus> @pl (\(x:xs) -> all (==x) xs)
04:54:53 <lambdabot> ap (all . (==) . head) tail
04:54:57 <Raydiation> i just saw it some js lib example and asked here
04:55:02 <Raydiation> +in
04:55:04 <Fernandos> muzzle: stk seems to be "stackage" https://www.fpcomplete.com/blog/2015/05/secure-package-distribution
04:55:19 <muzzle> Fernandos: no, I use cabal sandboxes
04:55:39 <Rembane> Raydiation: No worries, you'll learn it eventually. :)
04:56:06 <Raydiation> yep, ive understood more than the last few times :P
04:56:08 <muzzle> Fernandos: If you are running into problems with cabal, I would take a look at http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
04:56:12 <Fernandos> muzzle when I do that, my editor (atom) doesn't know where ghc-mod is and I can't install ghc-mod because it fails :(
04:56:30 <Fernandos> so currently I compiled in the terminal by hand
04:56:31 <muzzle> Fernandos: Are you using ghc 7.10 ?
04:56:32 <Raydiation> its like learning oop and patterns all over again xD
04:56:35 <Fernandos> muzzle: yes
04:56:57 <muzzle> Fernandos: ghc-mod doesn't compile with ghc 7.10, and I don't know how long it will take to fix it
04:57:07 <Fernandos> I wish I could download 10GB and be happy, just like with texlive :P
04:57:27 <muzzle> :P
04:57:32 <maerwald> Denommus: you are saying that "ap (all . (==) . head) tail" is clearer than "(\(x:xs) -> all (==x) xs)"?
04:57:41 <Fernandos> ahh that's why!
04:57:52 <Denommus> maerwald: no, but all . (==) . head <*> tail is
04:58:03 <maerwald> I disagree
04:58:17 <Denommus> we can agree to disagree, then :-)
04:59:06 <liste> you can always check if something is iterated twice with the trace function
04:59:07 <Fernandos> muzzle: do I have to uninstall ghc 7.10 before I get 7.6 or is there another way?
04:59:12 <maerwald> using more functions to express something doesn't make it simpler
04:59:37 <muzzle> Fernandos: This ticket is probably relevant for you: https://github.com/kazu-yamamoto/ghc-mod/issues/437
04:59:38 <liste> If you import Debug.Trace and paste "map (+1) . filter (>0) $ [trace "1\n" $ 1, trace "2\n" $ 2, trace "-1\n" $ -1]" it shows the evaluation order
05:01:09 <liste> it may help to prefix the traced strings, though
05:02:07 <Denommus> maerwald: I just realized that (<*>) is actually acting on the applicative instance of ((->) r), so I guess you're right. It is confusing
05:02:20 <liste> so even if you define your own list type, map and filter, the list is iterated only once
05:02:58 <maerwald> Denommus: my favorite example is
05:02:58 <maerwald> > join (+) 4
05:03:00 <lambdabot>  8
05:03:05 <maerwald> once you know how it works, it's obvious
05:03:09 <maerwald> but there really is no reason to do that
05:03:31 <maerwald> because it uses more functions/instances under the hood than necessary
05:04:10 <maerwald> still looking for a good continuation monad tutorial
05:04:44 <maerwald> the output of this http://lpaste.net/133424 is really confusing, who can guess it right? :P
05:05:00 <liste> maerwald have you tried Tekmo's ?
05:05:06 <liste> http://www.haskellforall.com/2012/12/the-continuation-monad.html
05:05:50 <maerwald> although 'b' is not used in line 9 it still changes the result
05:13:02 <liste> I find CPS easy but Cont hard :/
05:15:19 <aloiscochard> how can I parse an hex string to ByteString?
05:15:39 <codygman> Can I easily go from `Either a b` to `Either a [b]`? I suppose just joining or appending a's?
05:16:09 <Cale> codygman: fmap (:[]) ?
05:16:58 <paintrainchuchu> hallo
05:17:02 <maerwald> liste: there's some weird recursion pattern going on I cannot really understand for non-obvious use cases
05:17:21 <paintrainchuchu> is there a nice way to do IPC between parent and child process other than with file descriptors like in C?
05:17:34 <codygman> aloiscochard: https://hackage.haskell.org/package/base16-bytestring maybe?
05:17:39 <codygman> Cale: I think that works
05:17:58 <aloiscochard> codygman: exactly that, ty!
05:18:56 <Cale> The implementation of that package looks ridiculous, but the performance benchmarks here seem good https://github.com/bos/base16-bytestring
05:19:22 <maerwald> liste: I've illustrated it here http://lpaste.net/133425
05:20:38 <aloiscochard> yeah the impl. looks funny indeed :)
05:22:33 <Cale> maerwald: That's... not really how you're expected to use the Cont monad if you want things to make good sense :)
05:23:12 <maerwald> Cale: yes, but the question is why it behaves that way
05:23:28 <Cale> Well, sure, we can calculate why
05:24:10 <liste> how does it look when converted to CPS?
05:29:27 <Cale> maerwald: Okay, well, x gets bound to 20, because that's the result of the rest of the computation following a, when a gets bound to 7
05:29:58 <paintrainchuchu> It appears that createPipe is not that terrible..
05:31:20 <Cale> (since executing  cont (\fred -> Just 20)  aborts the remainder of the computation and produces Just 20 as the result)
05:31:31 <Cale> maerwald: right so far?
05:31:51 <Cale> maerwald: and then we produce  Just (3 + x)  as the result of the computation
05:31:59 <Cale> so Just 23
05:32:10 <maerwald> I don't really get why x is bound to 20
05:32:19 <maerwald> if I rmove line 8 and 9 then x is bound to 7
05:33:29 <Cale> Okay, so fred 7 here is the computation which executes the rest of the computation following binding a to 7, i.e. resuming on the line b <- cont ...
05:33:43 <Cale> and has as its result whatever the result of that computation is
05:34:22 <maerwald> uuuuuh
05:35:21 <Cale> fred is bound to the remainder of the computation as a function of 'a'
05:35:59 <Cale> i.e. in this first cont,  fred = \a -> do { b <- cont (\fred -> Just 20) ; return $ a + 0 }
05:36:33 <Cale> (it's sort of confusing to use 'fred' as the name for the current continuation, but whatever)
05:37:44 <Cale> So, in order to determine the result of executing fred 7, we execute  do { b <- cont (\fred -> Just 20); return $ 7 + 0 }
05:38:23 <Cale> and so then we execute  cont (\fred -> Just 20)... here, fred is bound to \b -> do { return $ 7 + 0 }, but that doesn't matter, because we don't use it.
05:38:59 <maerwald> aha
05:39:08 <Cale> Instead, we produce Just 20 as a result, and that causes the execution of the whole of do { b <- cont (\fred -> Just 20); return $ 7 + 0 } to finish immediately with the result Just 20
05:39:46 <Cale> So fred 7 = Just 20
05:40:07 <Cale> and now we're using the Maybe monad instance in the expression: fred 7 >>= (\x -> Just (3 + x))
05:40:18 <maerwald> well yes, the rest is clear
05:41:47 <maerwald> could be used for obfuscation context
05:41:54 <maerwald> *contest
05:42:05 <Cale> Yeah, ContT is easy to create horrible messes with
05:42:10 <Cale> Or Cont for that matter
05:43:15 <lpaste> hnfmr pasted “Chain actions” at http://lpaste.net/133426
05:43:24 <hnfmr_> suppose i have a series of actions that returns some code, each of them depends on previous action to decide to continue or not.
05:43:59 <hnfmr_> what is the "monadic" way to chain these actions?
05:44:10 <[k-> Bind? >>=
05:44:15 <maerwald> Cale: it's particularly confusing to understand "fred 7", because it's type is "Maybe Int"... which doesn't really tell you that the continuation is hidden there
05:44:51 <Cale> maerwald: Right, but of course, that's what fred *is*
05:44:55 <maerwald> fred :D
05:45:19 <Cale> hnfmr_: You might consider inventing an operation for combining them like that
05:45:30 <ronh-> hnfmr do you have a bunch of actions or a single action and a bunch of functions that return an action?
05:45:33 <hnfmr_> or I convert these functions to return Maybe
05:45:36 <hnfmr_> and chain them
05:45:58 <hnfmr_> i have a bunch of related actions.. e.g. action2 depends on result of action1
05:46:11 <ronh-> nevermind, you pasted..
05:46:16 <Cale> hnfmr_: Does action2 depend on the result r1?
05:46:21 <Cale> oh
05:46:26 <Cale> you just answered my question :)
05:46:33 <Cale> Okay, so perhaps something like
05:46:53 <hnfmr_> if they all return Maybe, I guess I can bind them
05:47:21 <Cale> x |> f = do v <- x; if v == 0 then f v else error ...
05:48:01 <hnfmr_> what is this operator "|>"
05:48:05 <Cale> Made it up
05:48:08 <hnfmr_> oh
05:48:10 <hnfmr_> right..
05:48:28 <hnfmr_> thanks, it's a dumb question :)
05:49:36 <Cale> If you want the error to be different each time, you could use a three parameter function with whatever the error is supposed to be
05:50:49 <hnfmr_> yep
05:51:54 <Cale> maerwald: Something about Cont/ContT: you can think of callCC (\ret -> ...) as being like what is implicitly surrounding every procedure definition in most imperative languages, and in such languages "return x" will execute  ret x
05:52:32 <Cale> maerwald: Of course, it's a little different because we have full access to this function ret as a value, and can do all sorts of crazy things with it.
05:53:21 <Cale> getCC :: MonadCont m => m (m a)
05:53:21 <Cale> getCC = callCC (\c -> let x = c x in return x)
05:54:13 <Cale> do goBack <- getCC; liftIO (putStrLn "Hello again!"); goBack
05:54:22 <Cale> ^^ that will print "Hello again!" indefinitely :)
05:54:37 <maerwald> Cale: so because we discard fred in the b <- ... line, the return statement actually has zero effect
05:54:45 <maerwald> I can put anything in there, it doesn't matter
05:55:02 <Cale> maerwald: Yeah, the whole rest of the block never happens
05:55:09 <maerwald> that's crazy
05:56:05 <Cale> @let getCC :: MonadCont m => m (m a); getCC = callCC (\c -> let x = c x in return x)
05:56:07 <lambdabot>  Defined.
05:56:18 <Cale> @let getCC' :: MonadCont m => a -> m (a, a -> m b); getCC' x0 = callCC (\c -> let f x = c (x, f) in return (x0, f))
05:56:20 <lambdabot>  Defined.
05:57:56 <Cale> > runCont (do ((x,xs), next) <- getCC' (0,[]); if x > 10 then return xs else next (x+1,x:xs)) id
05:57:59 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0]
05:58:18 <Cale> ^^ goto-with-value in Haskell :)
05:59:46 <maerwald> the continuation monad feels like a drug experience
06:00:54 <Cale> > (`Control.Monad.State.evalState` (0,[])) . (`runContT` return) $ do next <- getCC; (x,xs) <- get; if x > 10 then return xs else do put (x+1,x:xs); next
06:00:57 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0]
06:01:16 <tdammers> typed scheme with haskell-like syntax!
06:01:21 <Cale> ^^ plain goto + using the State monad to keep track of the rest
06:02:05 <c_wraith> I like using fix to create labels
06:02:06 <Cale> I should bug int-e that too many State monads seem to be imported
06:02:29 <c_wraith> I can spaghetti-program in haskell with fix. <_<
06:02:42 <coin3d> hey there. in the lyah book, chapter "higher order functions", the author creates a function compareWithHundred and i totally don't get what he tries to explain with it - http://learnyouahaskell.com/higher-order-functions#curried-functions
06:02:53 <Cale> @tell int-e Please import at most one of Control.Monad.State and Control.Monad.State.Strict unqualified.
06:02:53 <lambdabot> Consider it noted.
06:02:54 * hackagebot minst-idx 0.1.1.0 - Read and write data in the IDX format used in e.g. the MINST database.  http://hackage.haskell.org/package/minst-idx-0.1.1.0 (muzzle)
06:03:03 <coin3d> what does that have to do with currying
06:03:35 <Cale> The following implementation uses the fact that compare is curried
06:03:43 <c_wraith> coin3d: there are two definitions of compareWithHundred
06:03:50 <maerwald> because of the eta reduction... he gives the function currying creates a name
06:04:00 <c_wraith> coin3d: the second one demonstrates eta reduction, which demonstrates currying
06:05:44 <coin3d> c_wraith: aahh, i guess now i got it
06:06:11 <rhaps0dy> Hi!
06:06:26 <c_wraith> coin3d: you're right that the first definition doesn't really take advantage of currying, if you gloss over the entirety of how haskell deals with "multi-argument" functions in the first place. :)
06:06:29 <rhaps0dy> Can I use record types to specify the different constructors of an algebraic data type?
06:06:36 <ronh-> > map (compare 100) [0,10..]
06:06:37 <rhaps0dy> o silly question, of course I can
06:06:38 <lambdabot>  [GT,GT,GT,GT,GT,GT,GT,GT,GT,GT,EQ,LT,LT,LT,LT,LT,LT,LT,LT,LT,LT,LT,LT,LT,LT,...
06:07:18 <maerwald> @quickCheck (\x -> compare 100 x == GT)
06:07:18 <lambdabot> Unknown command, try @list
06:07:26 <maerwald> @check (\x -> compare 100 x == GT)
06:07:26 <c_wraith> rhaps0dy: it has some potential issues..  The record accessors all become partial functions that error out if the wrong constructor is present.
06:07:28 <lambdabot>  +++ OK, passed 100 tests.
06:07:29 <maerwald> ouch
06:07:30 <maerwald> ;)
06:09:06 <maerwald> @check (\x -> compare 99 x == GT)
06:09:07 <lambdabot>  +++ OK, passed 100 tests.
06:13:03 <Cale> @check mapSize (*2) (\x -> compare 100 x == GT)
06:13:05 <lambdabot>  *** Failed! Falsifiable (after 58 tests and 3 shrinks):
06:13:05 <lambdabot>  110
06:15:45 <ronh-> can lambdabot increase the number of tests?
06:16:09 <maerwald> ronh-: configMaxTest is not in scope it says
06:18:34 <Raydiation> how  are default parameters implemented?
06:18:37 <Raydiation> if they are
06:18:41 <Raydiation> simply listing them?
06:19:17 <zq> :t mapSize
06:19:19 <lambdabot> STestable prop => (Int -> Int) -> prop -> Test.QuickCheck.Safe.SProperty
06:19:48 <Raydiation> e.g. the sort function
06:19:56 <Raydiation> is there a way to provide a custom odering function?
06:20:16 <Fernandos> How can I pass the return value of a function to the input value of another function?
06:20:20 <saulzar_> Raydiation, They don't play well with currying, there's sort and sortBy
06:20:22 <maerwald> Raydiation: defining an instance for Ord I guess
06:20:27 <saulzar_> :t sortBy
06:20:29 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
06:20:48 <Fernandos> this didn't work.: print $ nHottest 3 . kMers 7 b
06:20:49 <Raydiation> ty
06:21:16 <Fernandos> I tried to pass the the return value of kMers to the 2nd param of nHottest
06:21:31 <byorgey> Fernandos: what are the types of kMers and nHottest?
06:21:41 <byorgey> Fernandos: perhaps you want  nHottest 3 (kMers 7 b)
06:22:28 <Denommus> I'm trying to implement the State Monad, and I'm confused on the Applicative instance
06:22:35 <saulzar_> Raydiation, If you wanted lots of default parameters a common pattern is to use a record of default parameters & you modify one or two with Lens, but that's probably a bit further along
06:22:37 <Denommus> this is what I did: f <*> x = State $ \s -> let (f', s') = runState f s in let (x', s'') = runState x s' in (f' x', s'')
06:22:49 <Denommus> but I'm not sure if the order of runStates is right
06:23:08 <Fernandos> byorgey: yeah that worked! but I thought that "." means: pass my value to the leftmost function..
06:23:19 <Fernandos> like piping
06:23:36 <byorgey> Denommus: the order of runStates doesn't matter, what matters is the way s, s', s'' get threaded through
06:23:38 <Fernandos> $ is there to eliminate func()
06:24:11 <Fernandos> btw. ghc-mod works on 7.10 now thanks ot https://github.com/kazu-yamamoto/ghc-mod/issues/437#issuecomment-95988239
06:24:11 <Denommus> byorgey: I thought it did matter. Why doesn't it?
06:24:12 <byorgey> Denommus: your implementation looks good to me.  f runs in the initial state, and produces a new state, in which x runs, and then the final state is returned
06:24:34 <Kaligule> Hi there
06:24:37 <byorgey> Denommus: I mean you could write   let (x', s'') = runState x s' in let (f', s') = runState f s in (f' x', s'')   and that is exactly the same
06:24:55 <Myrl-chan> really?
06:25:07 <byorgey> Denommus: because of laziness, the lets do not get executed in the order written, but in the order needed by evaluation
06:25:12 <Myrl-chan> ic.
06:25:52 <Myrl-chan> Is that properly threaded through though?
06:26:06 <Myrl-chan> This was what I did. `f <*> x = StateM $ \s -> let (v, s') = runState x s; (f', s'') = runState v s' in (f' v, s'')`
06:26:33 <Raydiation> saulzar_: sounds like javascript :)
06:26:36 <maerwald> Cale: I wonder if I can trick/break the typechecker with Cont :P
06:26:37 <byorgey> Myrl-chan: well, that is backwards from the way the usual State monad works
06:26:50 <Raydiation> where you use an options object
06:26:53 <Myrl-chan> byorgey: So what Denommus did was correct?
06:26:54 <byorgey> Myrl-chan: also, you did not use 'f'
06:26:58 <byorgey> Myrl-chan: yes
06:27:11 <Myrl-chan> (f', s'') = runState f s' * IM ean.
06:27:13 <Myrl-chan> I mean*
06:27:25 <Denommus> byorgey: I'm not worried about order of evaluation, but about order of execution
06:27:45 <Denommus> byorgey: so, the execution of the state in the function should come first?
06:27:50 <byorgey> Denommus: right
06:27:54 <Myrl-chan>  (Why?)
06:28:21 <byorgey> just because  f <*> x  usually means "do the effects of f first and then the effects of x"
06:28:30 <Myrl-chan> ic.
06:28:47 <Kaligule> I was wondering why in Haskell there are only two sorts of types: pure and IO. Why is it not separated? Why is there not an Input monad and an Output Monad? Wouldn't this be much safer`? 
06:28:47 <Myrl-chan> Thanks.
06:28:47 <byorgey> you can also make a valid "reverse State monad" where the effects happen in the other order, but coming up with sensible uses for it is sort of advanced =)
06:29:24 <byorgey> Kaligule: it would be safer if there were lots more types than that, e.g. something for only printing to the screen, or only reading from the terminal, or writing to a file, or ...
06:29:41 <arianvp_> sup
06:29:45 <byorgey> Kaligule: it's just a tradeoff of simplicity vs. safety/expressiveness
06:30:11 <maerwald> byorgey: but extending that stuff doesn't mean we have to abandon the generall IO type, does it?
06:30:17 <maerwald> it could just be an enhancement
06:30:27 <byorgey> Fernandos: (.) means function composition.  you give it two functions and it builds a new function that chains them together.  In your example,  kMers 7 b  is not a function
06:30:35 <byorgey> maerwald: sure
06:30:50 <Cale> maerwald: Nope, Cont is type safe
06:30:50 <maerwald> Kaligule: let's write a GHC patch :D
06:30:54 <Kaligule> byorgey: Was this a decision people did? Or did it just happen to be like this?
06:31:02 <maerwald> Cale: sure it is, but... implementation details
06:31:16 <Denommus> byorgey: ok, thanks
06:31:19 <maerwald> Cale: I've broken some stuff with e.g. record syntax before, probably a GHC bug back then
06:31:35 <Fernandos> byorgey: ahh
06:31:42 <Fernandos> byorgey: thank you very much!
06:31:54 <Kaligule> maerwald: this would be interesting.
06:31:59 <Myrl-chan> Can pure != return?
06:32:04 <Cale> Well, would be pretty surprising, but yeah there can always be bugs
06:32:24 <rhaps0dy> c_wraith: you still here?
06:32:31 <c_wraith> yeah
06:32:33 <rhaps0dy> c_wraith: http://lpaste.net/133427
06:32:46 <maerwald> Cale: the fun thing is... you need the return statement for the typechecker although it is NEVER executed, so I thought if that can be abused in some non-trivial way
06:33:00 <rhaps0dy> do the accessors become partial in this case?
06:33:12 <c_wraith> rhaps0dy: No accessors are total in that case.
06:33:23 <rhaps0dy> what did you mean and think I meant?
06:33:23 <c_wraith> rhaps0dy: err.  "No, accessors..."  The comma matters.
06:33:25 <rhaps0dy> I'm curious
06:33:53 <c_wraith> @let data Foo = Bar {getBar :: String} | Baz {getBaz :: Int}
06:33:55 <lambdabot>  Defined.
06:33:55 <rhaps0dy> c_wraith: my mind filled the comma and I didn't notice
06:34:10 <c_wraith> :t getBaz $ Bar "foo"
06:34:11 <lambdabot> Int
06:34:15 <c_wraith> > getBaz $ Bar "foo"
06:34:17 <lambdabot>  *Exception: No match in record selector getBaz
06:34:22 <rhaps0dy> c_wraith: oh, that's good to know
06:34:25 <rhaps0dy> thank you very much
06:34:34 <c_wraith> rhaps0dy: you're welcome
06:35:03 <Raydiation> hm, does <- unwrap an IO type? e.g String <- IO String 
06:35:10 <Raydiation> in a do block
06:35:21 <c_wraith> Raydiation: it doesn't unwrap, but it does have that effect on types
06:35:36 <c_wraith> Raydiation: it actually does something more subtle than unwrapping.
06:35:38 <Raydiation> c_wraith: on any type?
06:35:48 <Kaligule> c_wraith: Oh, I didn't know that.
06:36:15 <maerwald> Raydiation: yeah, it's syntactic sugar https://en.wikibooks.org/wiki/Haskell/do_notation
06:36:31 <c_wraith> Raydiation: in general,  in x <- act, if act has type "m a", x will have the type a
06:37:01 <c_wraith> Raydiation: But it's not actually unwrapping - it's just a consequence of the way do notation desugars into calls to (>>=)
06:37:29 <Raydiation> c_wraith: yeah, i understand
06:37:43 <Raydiation> ty
06:37:45 <c_wraith> > do x <- [1..3] ; y <- [4..6] ; return (x, y)
06:37:46 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
06:38:07 <c_wraith> It's clearly more something other than just "unwrapping" :)
06:38:48 <Cale> Kaligule, Raydiation: It's generally better to think of v <- x as meaning "execute the action x, and call its result v"
06:39:05 <maerwald> Cale: you mean in the IO context?
06:39:11 <Cale> Even not just in IO
06:39:17 <c_wraith> even in non-IO contexts, it's not a bad way to think of it.
06:39:27 <ion> “<byorgey> Denommus: I mean you could write   let (x', s'') = runState x s' in let (f', s') = runState f s in (f' x', s'')   and that is exactly the same” byorgey missed that the expression used two nested “let…in…”s. He meant: let (x', s'') = runState x s'; (f', s') = runState f s in (f' x', s'')
06:39:28 <c_wraith> Executing a list just happens to mean selecting one element from it. :)
06:39:29 <Cale> Almost every monad that we use has some sort of interpretation for the word "execute" there
06:39:52 <Raydiation> c_wraith: yeah, that confused me for a while
06:40:00 <Cale> But yeah, especially in IO, it's very much not like "unwrapping"
06:40:31 <Cale> getLine doesn't really "contain" a String any more than /bin/ls "contains" a list of files
06:40:48 <byorgey> ion: oops, yes, thanks
06:43:47 <rhaps0dy> is ghci-ng still relevant if you're on ghc 7.10 ?
06:44:43 <Phillemann> Kind of a vague question, but is there a function generalizing this pattern (for x4, x5, ...): http://lpaste.net/6747516831742820352
06:44:54 <Raydiation> how would you desugar do x <- [1..3] ; y <- [4..6] ; return (x, y)
06:45:12 <Raydiation> something like: let x = [1..3]; y = [4..6]; in x >>= y >>= (x,y)
06:46:23 <lyxia> @undo do {x <- [1..3] ; y <- [4..6] ; return (x, y)}
06:46:23 <lambdabot> [1 .. 3] >>= \ x -> [4 .. 6] >>= \ y -> return (x, y)
06:46:30 <rhaps0dy> Phillemann: maybe you can try repeat 3 [(=<<) . g] or something similar
06:46:40 <Raydiation> amazing :D
06:46:44 <rhaps0dy> time to play haskell gol
06:46:45 <rhaps0dy> golf
06:47:23 <liste> I wonder if anyone's made a golf bot for Haskell
06:48:05 <liste> that shortens expressions, a bit like @pl but optimized for shortness
06:48:13 <tdammers> that would be nice
06:48:26 <tdammers> and obviously the mandatory thing to do then would be to run the golf bot on itself
06:49:12 <c_wraith> unlike the halting problem, that doesn't lead to a contradiction. :P
06:50:03 <maerwald> liste: I bet most of the time shortening expressions will be the _opposite_ of @pl ;)
06:51:29 <indiagreen> I bet most of the time shortening anything more or less complicated would consist of mostly finding which operators and functions are used more than once, and then renaming them to various one-symbol names
06:51:56 <indiagreen> plus creative use of list comprehensions
06:53:26 <zmbmartin> Is it possible to have a func that takes type a as long as type a has a field of email? So say I have `data UserOne = UserOne {…, email :: Text, …}` and `data UserTwo = UserTwo {…, email :: Text, …}` can I have a func like checkSome :: a -> Bool where a can be UserOne or UserTwo but I can still access the email field from a in the func?
06:53:57 <indiagreen> zmbmartin: not normally, but you can achieve that with lenses or one of the alternative record packages
06:53:57 <Kaligule> liste: at least there are a haskell golf course
06:54:01 <Kaligule> liste: https://www.kruegerhaskellgolf.com/
06:54:27 <fvgvxmpv1> zmbmartin, indiagreen; typeclasses?
06:54:30 <indiagreen> zmbmartin: well, or just make a typeclass called “HasEmail” by hand
06:54:35 <indiagreen> right, yeah
06:54:49 <liste> has anyone tried the OverloadedRecordFields extension yet?
06:55:02 <zmbmartin> indiagreen fvgvxmpv1: OK so a typeclass, Thanks!
06:55:35 <indiagreen> liste: it's not in GHC 7.10, is it?
06:55:38 <liste> no
06:55:58 <liste> it's still work in progress
06:56:15 <indiagreen> actually, why am I even asking if I'm still on 7.8
06:56:34 <rhaps0dy> ah, I'm not good enough at haskell golf
06:56:40 <rhaps0dy> Kaligule: oh wow
06:56:53 <rhaps0dy> Phillemann: what are you calling that function on and what is (<>) ? 
06:58:19 <Phillemann> rhaps0dy: http://lpaste.net/2597248328269824000 - this is my first generalization attempt.
06:58:27 <Raydiation> > :t >>=
06:58:28 <lambdabot>  <hint>:1:1: parse error on input ‘:’
06:58:32 <Raydiation> :t >>=
06:58:34 <lambdabot> parse error on input ‘>>=’
06:58:51 <indiagreen> :t (>>=)
06:58:52 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:59:10 <Raydiation> ty
07:04:46 <Raydiation> whats the difference between bind and currying btw? bind happens in order?
07:05:36 <Raydiation> or is bind in haskell something different
07:06:09 <lyxia> :t curry
07:06:10 <lambdabot> ((a, b) -> c) -> a -> b -> c
07:06:23 <Cale> Raydiation: They're almost completely unrelated...
07:06:30 <Raydiation> i see
07:06:32 <ion> I'm not sure they have anything (uncontrived) to do with each other.
07:06:58 <Raydiation> im asking because of https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind
07:07:21 <Cale> Raydiation: Oh, that has nothing to do with Haskell's (>>=)
07:07:50 <ion> The linked method seems to be for partial application.
07:08:00 <zipper> Who's familiar with such an issue from cabal install https://gist.github.com/urbanslug/af2f9dbd8c3be5b38b35
07:08:01 <Raydiation> yes
07:08:09 <zipper> It's not major I just don't get it.
07:09:40 <eacameron> if I have SomeException, how can I figure out what precise type it is underneath? I don't want to catch SomeException
07:09:53 <rhaps0dy> Phillemann: hey, pretty neat
07:10:11 <Raydiation> so >>= just allows you to manipulate types inside monads right?
07:10:11 <rhaps0dy> but I still think we can get bind to do something
07:10:19 <rhaps0dy> what is (<>) and what are you calling it on?
07:10:59 <Raydiation> s/types/stuff
07:11:09 <Cale> Raydiation: What >>= does depends on the particular choice of type constructor 'm' in its type, it's defined differently for each m
07:11:49 <Cale> Raydiation: But generally, x >>= f means something like "the computation which when executed, will first execute x, obtaining some result, say v, and then execute f v, producing its result as its own"
07:12:40 <Raydiation> does that apply to all monads?
07:12:48 <Cale> What a "computation" is, and what "execute" and "then" mean, all depends on the choice of m and the implementation of (>>=) there, so that's just fuzzy intuitive nonsense
07:12:49 <ion> zipper: Try adding parameters that increase cabal's verbosity.
07:13:05 <Raydiation> i see
07:13:23 <Raydiation> as for IO, >>= means execute it in order right?
07:13:30 <eacameron> Cale: I'd be careful with the word nonsense. Fuzziness is perfectly useful when you're trying to grok something slowly over time
07:13:50 <Cale> Well, yeah, I wouldn't have said it if it wasn't meant to be at least somewhat useful :)
07:14:03 <eacameron> I figured ;)
07:14:12 <albeit> If I have (a -> m b), is there any way to do extract a function (a -> b) from it?
07:14:14 <geekosaur> as with most jargon, "nonsense" can have a precise meaning that is not the same as the everyday one :)
07:14:35 <albeit> Or even "(a -> m b) -> m (a -> b)"
07:14:46 <geekosaur> (consider that category theory has been referred to as "generalized abstract nonsense", with a justification in terms of jargon)
07:14:55 <Saizan> albeit: not in general, only for some values of 'm'
07:15:15 <Raydiation> Cale: i mean your explanation fit the IO monad
07:15:19 <eacameron> geekosaur: that sounds like more like politics than math.....
07:15:30 <Cale> Raydiation: Yes, for the IO monad, that description is pretty much exact
07:15:44 <albeit> Saizan: What kind of 'm' would work?
07:15:47 <eacameron> geekosaur: You can prove anything you want if you have control of all the terms! ;)
07:16:03 <Saizan> albeit: (r ->) mainly
07:16:22 <geekosaur> having "control of all the terms" is important for precision communication. which is why jargon exists
07:16:24 <Cale> Raydiation: Where a "computation" in that case means an IO action, and to "execute" an IO action means to carry out the effects that it describes, and "then" has the usual meaning you'd expect it to have.
07:17:03 <geekosaur> it's not politics so much as semantics and semiotics
07:17:11 <eacameron> geekosaur: I totally agree, but the question is often whether or not the guys who wrote the constitution were using your term definitons ;)
07:17:19 <Cale> Raydiation: For the list monad, it's a little bit stranger to interpret this kind of language, but it is possible
07:17:33 <Cale> > [1,2,3] >>= (\x -> [x, 10*x, 100*x])
07:17:35 <lambdabot>  [1,10,100,2,20,200,3,30,300]
07:17:55 <Cale> Here, "executing" a list means picking an element from it in all possible ways
07:18:45 <Cale> and for the case of the list monad,  xs >>= f = concat (map f xs)
07:19:19 <zipper> ion: such as? I just reread the help page can't find a thing.
07:20:59 <zipper> ion: Tried it again and it worked.
07:23:29 <fishburne> I am trying to learn Scotty web framework. How can I make this work? https://bpaste.net/show/d2048d6d0d41
07:28:40 <dmj``> fishburne: you might need to put a liftIO in front of query_, since ActionM is an instance of MonadIO
07:32:27 <fishburne> dmj``, query returns IO [r], and wont there be some scotty function to wrap it in a ActionM()...
07:33:11 <Raydiation> btw the monad laws are basically just monoid laws right?
07:33:24 <Raydiation> associativity and identity element
07:33:36 <dmj``> fishburne: liftIO
07:33:38 <dmj``> :t liftIO
07:33:40 <lambdabot> MonadIO m => IO a -> m a
07:33:49 <dmj``> fishburne: you must lift
07:34:26 <dmj``> fishburne: ActionM is an instance of MonadIO
07:34:33 <init> Raydiation: the correct term would be `category`, monads form the Kleisli category
07:34:50 <c_wraith> Raydiation: in the same way that the category laws are basically just the monoid laws
07:34:56 <fishburne> dmj`, yes..Please continue
07:35:01 <Raydiation> i see, thanks
07:35:39 <c_wraith> Raydiation: categories being one kind of generalization of monoids is an accurate viewpoint.  So it's fair to say that the laws are the same.
07:40:29 <albeit> If the only thing holding on to a reference to a socket is a thread, and the thread is killed, will the socket be closed?
07:41:50 <c_wraith> albeit: only if the thread is collected.  Just being killed is not enough to guarantee the thread is removed from the list of GC roots.
07:42:23 <albeit> c_wraith: So I should probably keep a reference to the socket elsewhere, explicitly close the socket then kill the thread?
07:42:36 <c_wraith> albeit: a thread is only collected if it's no longer running and nothing else has a reference to its ThreadId
07:44:55 <lpaste> simg pasted “use of qualified module imports” at http://lpaste.net/133431
07:45:09 <c_wraith> albeit: ideally, you'd have a finally action close the socket inside the thread, so that if it's killed the finally will close the socket.
07:45:43 <albeit> c_wraith: Ahhh that is so much nicer, thanks
07:45:55 <simg> Hi, as per my link, I'm trying to work out how to export qualified modules ?
07:46:16 <tdammers> simg: don't think you can
07:46:47 <tdammers> or rather, you can re-export modules that you had imported qualified, but you'll lose qualifiers, IIRC
07:47:39 <simg> tdammers: tyeah, that seems to be what's happening. is it just me, or does that suck :) ?
07:48:40 <tdammers> it sucks, kind of, but solving it would be a bit more complicated than it may appear at first
07:49:11 <refefer> need some ideas: I'm currently using a list ffor processing several million bytestrings in memory
07:49:24 <simg> how so ? (I seem to be stuck in "module import hell" right now :/ )
07:49:53 <fishburne> Can someone tell me Which module contains liftIO function.
07:50:04 <c_wraith> @index liftIO
07:50:04 <lambdabot> Control.Monad.IO.Class
07:50:17 <tdammers> simg: why is it so important to you to export Data.Text in the first place?
07:50:18 <refefer> the big problem I'm running into is that the amount of garbage create by streaming over them is impressive: each list creation requires 16bytes per entry, so in my 8M string example, the list alone is 128 megs
07:50:34 <tdammers> simg: leave it to the user to decide whether they want Data.Text in scope or not
07:50:37 <refefer> any ideas on a more memory effictient structure?
07:50:59 <fishburne> c_wraith, I think I tried that already. Let me try again...
07:51:02 <simg> I want a "global import" rather than having the very same 30 or so lines of import in every file. (and I AM the user :) !)
07:51:46 <simg> it's not just Data.Text, that's just my simple example
07:51:52 <tdammers> simg: yeah, no, global imports aren't currently feasible I think - you could instruct cabal to automatically load a bunch of modules IIRC, but I don't think you can forward qualified imports
07:52:26 <simg> doesn't that suck *a lot* for a language that is supposed to be terse ?
07:52:41 <tdammers> yes it does
07:52:42 <fishburne> c_wraith, it is not working. I am in a cabal sandbox, if it matters.
07:52:50 <simg> ok, so it's not just me then :)
07:53:05 <tdammers> but then, it mostly sucks so much because the rest of the language is so much better in comparison
07:53:18 <fishburne> c_wraith, https://bpaste.net/show/593beb6c74d3
07:53:33 <tdammers> nobody is complaining about a lack of re-exporting aliased namespaces in C, for example ;)
07:54:03 <simg> no, fair enough :/
07:54:58 <thomie> simg: check ghc ticket #8043
07:55:43 <fishburne> c_wraith, Pls ignore. I figured it out.
07:57:20 <fishburne> c_wraith, actually It does not work within the cabal sandbox. Any idea why?
07:58:08 <fishburne> c_wraith, is this not part of standard library?
07:58:11 <hexagoxel> fishburne: wild guessing: the import does not work because ghci does not know about the package, which is installed in the sandbox?
07:58:37 <fishburne> hexagoxel, I am using cabal repl...
07:58:58 <hexagoxel> fishburne: well, that _should_ work..
07:59:36 <fishburne> hexagoxel, but should I include it in .cabal file? 
08:00:09 <simg> thomie: thx, that does not look encouraging :/
08:01:46 <fishburne> hexagoxel, I think it worked when I included the transformers package in the .cabal file.
08:01:52 <athan> fishburne: I missed a lot of this convorsation. What isn't being imported?
08:02:21 <athan> fishburne: And usually you need any package you want available listed in .cabal
08:02:28 <fishburne> athan, I cannot import Control.Monad.IO.Class to use the liftIO function...
08:02:28 <athan> (transformers / mtl included)
08:02:44 <athan> fishburne: Does the compiler say something like "member of hidden package..."
08:02:56 <athan> Because then you'll need to list the package in .cabal
08:03:15 <athan> Sometimes, you'll need to duplicate listings under executable & library
08:03:16 <fishburne> athan, I am inside a cabal sandbox and when I try to import this is the result https://bpaste.net/show/593beb6c74d3
08:03:52 <athan> fishburne: Can you show me your .cabal?
08:04:48 <fishburne> athan, .cabal file https://bpaste.net/show/44f5a80aa66f
08:05:09 <athan> Hmm
08:05:34 <athan> fishburne: Import your Main module, too
08:05:38 <athan> see if that helps :S
08:05:57 <athan> When you do `lift<TAB>` does anything list?
08:06:12 <fishburne> it works when I include the transformers package in the .cabal file
08:06:21 <athan> wait
08:06:24 <athan> okay then :|
08:06:37 <fishburne> Buy how do I go from Control.Monad.IO.Class to transformers package...?
08:06:44 <fishburne> *But
08:06:53 <athan> fishburne: What do you mean?
08:07:02 <athan> transformers exports Control.Monad.IO.Class
08:07:25 <hexagoxel> fishburne: ah, cabal repl might only forward any dependency to ghci that are listed in the cabal package
08:07:37 <fishburne> athan, I mean, If I want a function and I see that is present in module Control.Monad.IO.Class, how do I know that it is included in transformers package?
08:07:51 <hexagoxel> (which would point to another difference between `cabal exec ghci` and `cabal repl`..)
08:07:57 <athan> fishburne: By looking at the docs :P
08:08:14 <dcoutts> hexagoxel, fishburne: cabal repl is just like cabal build, it uses exactly the environment specified by the component in the .cabal file.
08:08:32 <athan> I /think/ :i might tell you what module some term is exported from, but not the package
08:08:48 <dcoutts> hexagoxel, fishburne: if you want to use extra packages in cabal repl, you can of course use  :set -package blah
08:08:58 <fishburne> athan, yes. it is at the top left corner in this page http://hackage.haskell.org/package/transformers-0.4.3.0/docs/Control-Monad-IO-Class.html#v:liftIO
08:09:14 <athan> right
08:13:01 <prsteele> ghci command to show operator precedence?
08:13:03 * hackagebot path 0.5.0 - Path  http://hackage.haskell.org/package/path-0.5.0 (ChrisDone)
08:13:11 <prsteele> e.g. determine the precendce of (.) ?
08:13:18 <KaneTW> :i
08:13:29 <prsteele> perfect, thanks
08:16:00 <quchen> prsteele: Default fixity is left/9, in case you're wondering.
08:16:24 <prsteele> quchen: good to know
08:31:00 <Pato> Can anyone help me with a convertion from a typica recursive function to an anamorphism?
08:37:44 <f-a> from haskell-art: http://lurk.org/groups/haskell-art/messages/topic/2yNGM3gEXKit0wJAB0dbt4
08:38:02 <f-a> (a music box programmed in haskell)
08:39:26 <lpaste> fvgvxmpv1 pasted “Linker death” at http://lpaste.net/133434
08:39:57 <fvgvxmpv1> apparently my linker crashes compiling what should be a trivial module — what gives?
08:40:26 <quchen> There is a mistake somewhere.
08:41:06 <indiagreen> fvgvxmpv1: have you forgotten to declare the module in exposed-modules?
08:41:09 <quchen> Have you compiled the dependencies with dynamic linking?
08:41:13 <Haaaskell> Pato: are u there ?
08:41:24 <Pato> Haaaskell: yes
08:42:13 <fvgvxmpv1> quchen: no Idea — I had nix call cabal; indiagreen: I´ll paste my .cabal
08:42:21 <Haaaskell> Pato: daqui fala o jno, poderias me dar o teu nr de aluno ou vou ter de descobrir pelas transcrições de código ?
08:42:37 <joobus> noob question:  what is the "common english" translation of '=>', for instance in type definitions such as Monad m => a -> (a -> b) -> m b
08:42:47 <lpaste> fvgvxmpv1 pasted “No title” at http://lpaste.net/133435
08:42:58 <mauke[> joobus: =>
08:43:06 <joobus> yes
08:43:26 <joobus> who do i read that symbol?
08:43:30 <joobus> how*
08:43:30 <mauke[> =>
08:43:33 <fvgvxmpv1> indiagreen: I don´t thin so — though parts of what the linker seems to be refering to (def :: Config — or some such) are from Opossum.Types — which Opossum exports
08:43:47 <hodapp> => always follows constraints, right?
08:43:52 <indiagreen> fvgvxmpv1: then you should have Opossum.Types in other-modules
08:43:53 <quchen> joobus: There's no common pronounciation. On the left you have constraints, if that helps.
08:44:18 <quchen> If you call it "constraint arrow" then it'll be clear what you mean I guess.
08:44:26 <fvgvxmpv1> How about "Implies" (That´s what mathematicians say, when they write that thing in… Logic 101)
08:44:28 <quchen> (As opposed to function arrow)
08:44:37 <joobus> k, thanks guys :)
08:44:39 <Haaaskell> Pato: aposto que te assustaste hehe
08:44:47 <quchen> It does not mean implication, so we should not call it that.
08:44:53 <indiagreen> joobus: I usually read it as “provided that m is Monad, ...”
08:45:15 <hodapp> fvgvxmpv1: that's not implication; that would be, if anything, -> in a type signature
08:45:24 <athan> indiagreen: I love how contexts read that way :) That's the only way I can do inductive heterogeneous stuff
08:45:30 <joobus> indiagreen: that makes sense, thanks
08:45:38 <hodapp> fvgvxmpv1: and that reason for that goes to the Curry-Howard Correspondence with types being propositions and values being proofs
08:46:53 <fvgvxmpv1> hodapp, indeed — thinking of '=>' as implication probably only makes sense on a _very_ intuitionistic (not as in type theory) level
08:47:19 <fvgvxmpv1> indiagreen: having my sub-module in other-modules worked — thanks a lot
08:47:44 <hodapp> does => always accompany a sort of implicit 'forall'?
08:48:02 <hodapp> or... I guess the implicit forall has nothing to do with the => but rather the type variables
08:48:11 <c_wraith> hodapp: unless it's silly.  I mean, you *can* write a constraint like Eq Int => Int -> Bool
08:48:26 <c_wraith> hodapp: but any non-silly constraint mentions type variables
08:48:56 <hodapp> c_wraith: well, it seems to me that it's still the type variables that produce the implicit forall
08:49:15 <c_wraith> hodapp: yeah, that's what I was getting at with my second line - agreeing with your thought
08:51:29 <quchen> :t id :: Monad Maybe => Char -> Char -- hodapp 
08:51:30 <lambdabot> Char -> Char
08:52:02 * hodapp tries to figure out why quchen just type-signature'ed in his general direction
08:52:34 <quchen> Well, you wondered whether there was an implicit forall associated with all "=>"s.
08:53:27 <hodapp> quchen: c_wraith beat you to the punch
08:53:35 <quchen> Oh.
08:53:37 <quchen> :-(
08:54:11 <c_wraith> #haskell, the channel where helping others is a competition
08:54:12 <quchen> That's what happens when you're a slow typist and every finger you use has to be thought of individually each time again.
09:01:09 <ski> hodapp : i suppose you can do stuff like `data Foo a = MkFoo (Ord a => [a])' (requires `PolymorphicComponents') (or `bar :: Ord a => (Eq a => [a]) -> [a]; bar xs = xs', requires `Rank2Types')
09:01:34 <hodapp> PolymorphicComponents? you get out of here, sir, before I chase you with a pitchfork.
09:01:56 <hodapp> the only GHC extensions I acknowledge are the ones I was using yesterday.
09:04:05 <athan> :U
09:06:20 <agibiansky> Does anyone have experience debugging issues with Typeable / Dynamic?
09:06:39 <mauke[> o_O
09:07:30 <Vektorweg11> c_wraith: lol. yeah, thats the problem when i want help people on stackoverflow. the questions are well answered in no time. and often from the big players, who maintain the project you have a problem with. 
09:07:30 <agibiansky> Specifically, I am getting errors casting from dynamic, because in one case the package of a data type is "main" and in the other its "ihaskell-X.Y.Z". Why would the package of a TyCon be "main"?
09:09:52 <monochrom> "package main" means not really in any package
09:10:34 <agibiansky> monochrom: Hmm, alright. Strange...
09:19:17 <albeit> @pl \f -> (f, g f)
09:19:17 <lambdabot> ap (,) g
09:29:12 <athan> Hey guys, does `fix id` ~ `undefined` ?
09:29:26 <S11001001> athan: yah
09:30:38 <athan> S11001001: sweeeeeeee ++ `fix (++ "e")`
09:31:04 <quchen> fix id = id (fix id) = fix id = id (fix id) = …
09:31:20 <quchen> athan: You can also see that it's undefined from its type,
09:31:22 <quchen> :t fix id
09:31:23 <lambdabot> a
09:31:24 <athan> quchen: Ahhh!
09:31:32 <athan> quchen: That's what led me to it
09:31:32 <S11001001> athan:  :)
09:31:39 <quchen> There's only one value that has type "a", or better: "forall a. a", and that value is ⊥.
09:31:40 <athan> Thank you :)!
09:32:04 <athan> quchen: This also leads me to "free"-ness, am I right here?
09:32:10 <S11001001> athan: ~ sweeeeeeee ++ `fix id`
09:32:17 <athan> data Free f = Free (f(Free f))
09:32:20 <athan> correct?
09:32:20 <quchen> That doesn't sound like free-ness.
09:32:28 <quchen> That looks like Fix.
09:32:35 <athan> shoot
09:33:01 <quchen> `fix` is used to introduce recursion in an otherwise non-recursive language.
09:33:05 <athan> quchen: can you reccommend material for understanding freeness?
09:33:29 <quchen> You can write a type-level Fix to define recursive data types if you want, but it's not really related to "fix id" being ⊥ all that much.
09:33:43 <quchen> Not more than any other form of non-termination, anyway.
09:33:46 <johnw> Free is a special case of Fix
09:33:47 <athan> quchen: I realize that, I'm just trying to understand it all more
09:33:53 <athan> johnw: Ahh, okay!
09:34:08 <quchen> Free Void = Fix, yeah
09:34:15 <athan> Hmm!
09:34:23 <athan> So Free is like a monadic wrapper?
09:34:25 <quchen> That's "Free Monad free" though.
09:34:26 <athan> er,,,
09:34:32 <johnw> athan: type Free f a = Fix (Compose (Either a) f)
09:34:40 <athan> johnw: Perfect :)
09:34:42 <athan> thank you
09:34:59 <quchen> There's also the Free Applicative, and the other free Applicative as well, and a truckload of other free things. The free monad is just the most famous one.
09:35:03 <johnw> it's a Fix that can terminate, basically
09:35:27 <athan> That is free-gin cool :)
09:35:35 <johnw> freeness *in general* means that nothing is imposed on the mathematical structure except the laws
09:35:52 <mmachenry> I am trying to deploy a compiled binary. When I do "cabal build" I create a file in ./dist/ when I do "cabal install" it creates a file in .cabal-sandbox/bin/. When I copy the sandbox one to another machine it doesn't run and strace says it's failing to find dynamically linked files.
09:36:09 <mmachenry> What am I doing wrong? Which compiled binary is the appropriate to be shipping to another machine?
09:36:15 <johnw> it's "free" of any other imposed meaning
09:36:18 <quchen> johnw: Well, Fix can terminate as well, depending on its argument.
09:36:25 <johnw> quchen: as Free demonstrates :)
09:36:50 <refefer> mmachenry: you need to statically compile in all dependencies
09:36:51 <quchen> Oh, you already spelled it out above, I missed that.
09:36:52 <athan> johnw: Hmm, okay
09:37:07 <refefer> or install them on the remote machine
09:37:14 <refefer> you can use ldd to find out what libraries it's linking to
09:37:42 <johnw> athan: for example, '+' and 0 satisfy the monad laws, but also "does" something to the numbers
09:37:53 <dylukes> Hey all.
09:38:00 <johnw> ':' and [] satisfy the monad laws, but leave the terms alone
09:38:05 <johnw> s/monad/monoid
09:38:11 <dylukes> So, I have a quick question about syntax for instances.
09:38:12 <mmachenry> refefer: I think I am
09:38:14 <bananagram> @src fix
09:38:14 <lambdabot> fix f = let x = f x in x
09:38:32 <subleq> https://twitter.com/lambdagrrl/status/603599246751879168
09:38:36 <refefer> mmachenry: run ldd on the binary
09:38:37 <subleq> I don't understand why that doesn't work
09:38:38 <dolio> Or do they?
09:38:45 <refefer> it will tell you you aren't ;)
09:39:20 <johnw> dolio: ok, ok :)
09:39:27 <johnw> for the purposes of this discussion only
09:39:35 <dylukes> https://gist.github.com/DylanLukes/ed571949674d9b388eec
09:39:41 <dylukes> so, in this gist see L71
09:39:44 <subleq> Actually, the types for the different cases are different
09:39:50 <subleq> so I don't know how you could expect it to work
09:39:59 <dolio> They actually satisfy the monoid laws fine. It's other conditions that don't work.
09:40:04 <dylukes> The problem is the derived HasTicket' class takes six arguments.
09:40:15 <monochrom> in a free monoid, if x≠0, then x<>x ≠ x, for example, since the monoid laws do not let you deduce x<>x = x.
09:40:20 <dylukes> e.g. HasTicket' T a b c d e  for (T a b c d e)
09:40:36 <dylukes> is there any way I can ellide duplicating the concrete parameter types in these instances?
09:40:45 <dylukes> I want to write instance HasTicket' TicketColumn where ticket' = id
09:40:55 <dylukes> instead of instance HasTicket' TicketColumn TicketIdColumn (Column PGText) ... where ticket' = id
09:41:04 <dylukes> er, Ticket' TicketIdColumn ....
09:41:04 <ski> athan : there's "the free vector space over a basis set", "the free monoid (or group, or abelian group) over a set of generators", "the free abelian group over a group", "the free partial order over a preorder", &c. .. a free functor is a functor that is left adjoint to a forgetful/underlying functor
09:41:12 <dylukes> basically I want to spread the type synonym.
09:41:12 <monochrom> Bool with True and && is not a free monoid: False && False = False. a non-free monoid has extra equations.
09:41:20 <athan> johnw: Hmmmm, okay
09:41:35 <athan> ski: :D!
09:41:37 <dylukes> Is there any reasonable way to keep the definition nice and short? It seems like it "should work"?
09:41:38 <ski> athan : the free monoid over a set is just the monoid of (finite) lists with elements from that set
09:41:48 <eacameron> is there a convention for "don't care" in type variables? like _ in value-land
09:41:53 <athan> ski: holy crap
09:41:54 <albeit> How can I make a Show instance like "show (Foo a b c _) = show [a,b,c]"?
09:42:10 <albeit> Where a,b,c are already isntance of Show
09:42:45 <ski> athan : the free vector space over the set `{0,1,2}' is the three-dimensional vector space. you can think of the three elements of the set as naming/numbering the basis vectors
09:43:19 <dylukes> albeit instance Show Foo where show (Foo a b c _) = intercalate " " (show `fmap` [a, b, c])
09:43:24 <ski> athan : .. not sure how much you're familiar with groups, abelian groups, partial orders, preorders
09:43:38 <quchen> albeit: instance (Show Foo a b c d) where show (Foo x y z _) = show [x,y,z]. But note that Show is not for prettyprinting. https://github.com/quchen/articles/blob/master/fbut.md#show-is-not-for-prettyprinting
09:43:49 <quchen> Ah, bad parenthesis. Anyway, that's the gist.
09:43:55 <athan> ski: I will be soon :D
09:44:11 <quchen> And bad superclass constraints. I need a break :-(
09:44:13 <dylukes> monochrom Any idea about that type synonym instance :\?
09:44:23 <dylukes> It's really frustrating, I'll end up having to write the same tables out like three times.
09:44:33 <monochrom> why me?
09:44:45 <dylukes> I recall you doing some fancy stuff with instances once upon a time :p.
09:45:08 <mmachenry> refefer: http://lpaste.net/133436   My ldd
09:45:33 <refefer> mmachenry: yep, are you compiling it with the right flags?
09:46:15 <mmachenry> No sure. ghc-options: -threaded -Wall -Werror -O2
09:46:34 <monochrom> but I never did fancy things with type synonyms. in fact, I deplore them.
09:46:42 <lpaste> gabemc pasted “Data.Bytes.Serialize issue #3” at http://lpaste.net/133437
09:46:48 <dylukes> How do you feel about newtypes :p?
09:46:51 <ski> athan : a preorder is a binary relation (say `R') on a set that is reflexive (so `x R x' for every `x' in the set), and transitive (so `x R z' whenever `x R y' and `y R z', for any `x',`y',`z'). common examples of such an `R' would be `≤',`≥' on "numbers",`=' (on anything with equality defined),`∣' (divides) on integers
09:46:54 <athan> ski: I keep forgetting (no pun) - what's the most common forgetful functor in practice? The... Hom functor? :s
09:47:00 <refefer> mmachenry: yeah, you needed I believe -static and -optl-pthreads, among other flags
09:47:13 <monochrom> I would be the last one to use TypeSynonymInstances because I would be the last one to use type synonyms at all in the first place.
09:47:24 <dylukes> Ooooh right
09:47:25 <mmachenry> refefer: thanks I'll check out the docs on those.
09:47:29 <athan> ski: I know that :) I'm also familiar with the cartesian closed structure associated with it
09:47:33 <dylukes> it was comonochrom who used type synonyms everywhere.
09:47:34 <athan> via meet
09:47:35 <gabemc> Hello again. Another day, another type error. http://lpaste.net/133437 >> I'd appreciate any advice.
09:47:39 <dylukes> The arrows of his preference point the opposite way.
09:47:41 <dylukes> Sorry monochrom.
09:47:56 <dylukes> (arrows in the category of preferences*)
09:47:56 <mmachenry> refefer: Any idea what the other flags are or a good tutorial? 
09:48:53 <gabemc> Also, I'm wondering if I'm biting off more than I can chew in terms of using paramaterized data declarations. I need different data implementations based upon the various native pointer types of the platforms I'm targeting, but I'm wondering, as style/architectural issue, whether I'm overcomplicating things by not sticking to one datatype and just hacking around the problem more manually.
09:48:54 <ski> athan : anyway, a partial order is also anti-symmetric. so the free partial order on a preorder is the least restrictive way to *make* it a partial order. iow, if `x ≤ y' and `y ≤ x' in the preorder, then we "force" `x = y' to be true in the partial order (by taking a quotient)
09:49:26 <refefer> mmachenry: I wish I knew.  I've been stumbling through ghc's flags mine field recently as well
09:49:47 <refefer> lot's of strange gotcha's, like compining default rts options requiring double quotes
09:49:52 <refefer> lots*
09:50:05 <ski> athan : "what's the most common forgetful functor in practice?" -- i suppose it would depend on the particular categories one's most commonly working with ..
09:51:14 <muzzle> hi, is there a way to access a libraries non-exposed modules from a cabal-test suite ?
09:51:35 <ski> athan : for groups, the free abelian group over a group is the least restrictive way to *make* it abelian (aka commutative)
09:52:06 <ski> athan : this corresponds to the forgetful functor from abelian groups to groups that forgets abelianess
09:52:18 <refefer> for example: I have no idea of how to build a cabal file that will install and compile alex, happy, and c2hs correctly and in order before compiling libraries that depend on them
09:52:46 <ski> athan : some forgetful functors forget laws, some forget operations (like from groups to monoids)
09:53:14 <ski> athan : the corresponding forgetful functor adds them back again, in the least restrictive way
09:53:24 <ski> athan : er .. the corresponding *free* functor
09:55:00 <athan> ski: Hmm, okay, thank you. I need to get more CT under my belt ._.
09:56:36 <ski> athan : .. i'm not sure if there's an abstract definition of what a forgetful functor is, though
09:57:20 <dylukes> lens is implemented using lens!
09:57:21 <dylukes> :D
09:57:24 <dylukes> neat
09:57:37 <indiagreen> what
09:58:23 <indiagreen> dylukes: do you mean lens the function, or lens the package, or something else entirely?
09:58:36 <amindfv> so given a type "data A = A Float | B String" and "class ToA where toA :: A", is there any possible way to create instances so that I can write e.g. "toA 33" or "toA 33.3" without annotating the type of the numbers?
09:58:48 <mmachenry> refefer: Thanks, I'll take a look. 
09:58:55 <amindfv> ("any possible way" not including -XIncoherentInstances or -XRebindableSyntax)
10:00:15 <johnw> did you mean toA :: A, or toA :: Float -> A?
10:00:39 <amindfv> oh sorry
10:00:45 <amindfv> "toA :: a -> A"
10:01:04 <amindfv> "class ToA a where toA :: a -> A"
10:02:33 <Myrl-chan> Category theory question: Is the set of real numbers and successor functions as morphisms a category?
10:03:37 <bennofs> Myrl-chan: what would composition / identity be? And objects?
10:03:51 <Myrl-chan> bennofs: The objects are real numbers.
10:04:20 <Myrl-chan> bennofs: I don't know how to describe composition.
10:04:36 <Myrl-chan> Basically, (succ1succ0) 0
10:05:02 <bennofs> Hmm, what is a successor function for real numbers?
10:05:22 <Myrl-chan> I dunno.
10:05:28 <Phillemann> I'd like to run my program and break at a specific module and line. The program is split into a library and two executables. Trying "cabal repl main/Main.hs" and then ":break Foo.Bar 10" doesn't work because it needs an "interpreted module"
10:05:33 <dylukes> There isn't one, at least in most constructions of the reals.
10:05:42 <amindfv> I've built solutions to my "toA" problem with incoherent instances and rebindablesyntax, but there are big drawbacks to both of those
10:06:09 <dcoutts> Phillemann: you'd need to run it in ghci such that the whole lib+exe is loaded as .hs files, not with the lib pre-compiled
10:06:11 <amindfv> i'd also like to avoid any "dangerous" coercion but i'd be fine with coercion that's safe
10:06:29 <johnw> amindfv: why wouldn't you want to be explicit and use the constructors of A?
10:06:35 <Myrl-chan> ic.
10:06:41 <Cale> Myrl-chan: What is "a successor function"? The only successor function one usually considers is *the* successor function on the naturals.
10:06:52 <Phillemann> dcoutts: Hmm, and how do I do that?
10:07:05 <Cale> Myrl-chan: So if you're going to talk about "successor functions" you'd better express more clearly what it is that you want :)
10:07:05 <Myrl-chan> Cale: Yes, aren't real numbers also natural numbers?
10:07:09 <Cale> Huh?
10:07:10 <Cale> No.
10:07:13 <Myrl-chan> wat
10:07:22 <Cale> 1/2 is not a natural number
10:07:22 <nullvoid8> no, naturals are reals, reals are not naturals
10:07:29 <amindfv> johnw: this is a contrived example -- i'm building a DSL and it would be prohibitively wordy to have people decorate each number with either a data constructor or a type
10:07:33 <Myrl-chan> Ah...
10:07:33 <ski> Myrl-chan : `2/3' is not a natural number
10:07:37 <dcoutts> Phillemann: run ghci with the right args. You could run cabal repl -v and see how cabal calls ghci, and then modify that and call it manually.
10:07:38 <Cale> -1 is also not generally considered to be a natural number
10:07:39 <Myrl-chan> Hahaha... sorry.
10:07:45 <Myrl-chan> I mixed things up.
10:07:50 <Myrl-chan> Yeah, I meant natural numbers. Yeah.
10:08:00 <tromp__> some ppl dont'even consider 0 a natural number:(
10:08:04 <Myrl-chan> tromp__: ;-;
10:08:09 <dcoutts> Phillemann: rather than using -package-id thelib, you'd use -isrc or something
10:08:29 <Cale> tromp__: Of course, homotopy type theorists know that the natural numbers really start at -2 :D
10:08:39 <nullvoid8> Cale: wat
10:08:52 <Myrl-chan> lol
10:09:12 <Myrl-chan> So, are natural numbers categories?
10:09:33 <Myrl-chan> Okay, that was badly phrased.
10:09:50 <nullvoid8> yes (if with no arrows at all) :P
10:09:53 <Cale> Myrl-chan: Not a-priori. Can you define some categories which you label with the natural numbers somehow? Sure.
10:09:58 <Myrl-chan> Does a category of natural numbers and successors?
10:10:00 <Myrl-chan> exist?
10:10:15 <Cale> A category whose objects are the natural numbers and whose arrows are what?
10:10:19 <Myrl-chan> Okay, I'm badly phrasing everything. Clear proof right there I have no idea what I'm talking about.
10:10:25 <Myrl-chan> Cale: successor functions.
10:10:28 <nullvoid8> I think you'd have to extend the arrows into (+N)
10:10:33 <KaneTW> http://en.wikipedia.org/wiki/Natural_number_object
10:10:36 <ski> Myrl-chan : functions from what to what ?
10:10:41 <bennofs> Myrl-chan: but the composition of two successor functions would not be a successor function, would it?
10:10:48 <Cale> Myrl-chan: Do you mean there's exactly one arrow n -> m iff m is the successor of n?
10:10:53 <Cale> Myrl-chan: Then no.
10:11:08 <Myrl-chan> bennofs: Oh.
10:11:14 <Myrl-chan> Hmm...
10:11:35 <Cale> But there is a category whose objects are the natural numbers and where there's exactly one arrow n -> m whenever n <= m, and no arrows otherwise.
10:11:58 <Cale> (note: it's also important that there's an arrow n -> n for each n, to serve as the identity arrow)
10:12:05 <tromp__> any transitive reflexive relation  on the naturals can serve as arrows
10:12:22 <Myrl-chan> :|
10:12:29 <prsteele> If you want the successor function as an arrow, you just need regular addition, right?
10:12:43 <amindfv> anybody? it seems crazy to me that there would literally be no way to use a typeclass function with a number without explicitly annotating its type
10:12:43 <nullvoid8> tromp: beacuse any partial order induces a catagory?
10:12:47 <ski> (KaneTW : .. not sure if that is relevant here)
10:12:56 <ski> nullvoid8 : even preorder
10:13:03 <amindfv> i mean, we have type defaulting rules
10:13:10 * hackagebot airship 0.3.0.0 - A Webmachine-inspired HTTP library  http://hackage.haskell.org/package/airship-0.3.0.0 (reiddraper)
10:13:20 <hook0007> hello
10:13:32 <Myrl-chan> Welp, I'm really not understanding this properly. :(
10:13:37 <amindfv> and the num defaults (Integer and Double) both would work for my purposes
10:13:39 <Cale> Myrl-chan: A preorder on a set S is a binary relation <= on S such that 1) for all a in S, we have a <= a (i.e. <= is reflexive), and 2) for any a, b, c in S, if we have a <= b and b <= c, then a <= c. (i.e. <= is transitive)
10:14:12 <Cale> Myrl-chan: Whenever S is a set and <= is a preorder on S, we can define a category whose objects are the elements of S, and where there is exactly one arrow a -> b whenever a <= b.
10:14:13 <Myrl-chan> mhm
10:14:14 <KaneTW> ski: i'm just saying you can define objects similar to naturals
10:14:15 <ski> amindfv : .. perhaps you could define `fromInteger' and `fromRational'
10:14:22 <ski> KaneTW : aye
10:14:43 <hook0007> is it okay to ask a newbie question?
10:14:48 <ski> yes
10:14:49 <Cale> hook0007: Absolutely :)
10:15:05 <Myrl-chan> Cale: I don't get the "where there is exactly one arrow" aprt.
10:15:18 <amindfv> ski: i've done that (and it works) but it requires -XRebindableSyntax
10:15:22 <nullvoid8> ski: that sounds dirty because you can't right the rest of the Num / Rational instance
10:15:26 <nullvoid8> *write
10:15:32 <Cale> Myrl-chan: In general in a category, between any ordered pair of objects, you have a collection of arrows.
10:15:33 <ski> amindfv : hm, why ?
10:15:35 <dylukes> Myrl-chan Another way to look at it is: if there were more than one arrow, they would be indistinguishable
10:15:38 <dylukes> thus, they're unique.
10:15:40 <ski> nullvoid8 : yes
10:15:47 <dylukes> (because there can't be duplicates, more or less)
10:15:50 <nullvoid8> amindfv: but you could write toA = A . fromIntegral ?
10:15:58 <nullvoid8> or fromRational even
10:15:59 <Cale> Er, if there were more than one arrow, they would be distinguishable!
10:16:10 <dylukes> In a category from a preorder?
10:16:16 <Darwin226> How bad/unidiomatic would it be to use >>> instead of ., or even F#-style |> pipe?
10:16:17 <hook0007> i try to learn haskell by a simple example which prompt for the name an then puts on the screen, but it is in a wrong order
10:16:24 <Cale> dylukes: There simply isn't more than one arrow in this particular construction.
10:16:32 <amindfv> nullvoid8: can you give an example?
10:16:34 <ski> hook0007 : perhaps use `hFlush stdout'
10:16:40 <hook0007> is it okay to paste 4 lines
10:16:41 <muzzle> does anyone know how i can create a tempfile ? (Not System.IO.openTempFile)
10:16:45 <ski> hook0007 : you can use
10:16:47 <ski> @paste
10:16:47 <lambdabot> Haskell pastebin: http://lpaste.net/
10:16:51 <dylukes> Right, but if you assign one or more arrows a -> b whenever two objects satisfy a <= b 
10:16:56 <Myrl-chan> Hmm
10:16:59 <nullvoid8> :t fromIntegral
10:17:00 <dylukes> then those arrows will be indistinguishable by construction
10:17:00 <lambdabot> (Integral a, Num b) => a -> b
10:17:07 <Cale> dylukes: Not necessarily
10:17:08 <nullvoid8> :t fromRational
10:17:08 * ski would be ok with 4 lines. perhaps some others wouldn't
10:17:09 <lambdabot> Fractional a => Rational -> a
10:17:11 <dylukes> unless you explicitly tag them, I'd imagine so.
10:17:31 <muzzle> i.e. a file that should be created somewhere like /tmp
10:17:34 <hook0007> http://lpaste.net/133439
10:17:37 <Cale> dylukes: Consider the category whose objects are logical statements, and whose arrows P -> Q are proofs P |- Q
10:17:39 <nullvoid8> amindfv: and the (A .) forces the return of those to be float
10:17:44 <dylukes> Ah!
10:17:47 <dylukes> Good point Cale :)
10:17:48 <muzzle> and where in the worst case the OS eventually deletes the file
10:17:52 <Myrl-chan> Cale: Yes.
10:17:58 <dylukes> But still, there's a bit more structure there than in the case of inequality.
10:18:03 <Cale> Sure
10:18:08 <amindfv> so i've done e.g. "instance (Num n, RealFrac n) => n where toA = A . realToFrac"
10:18:18 <Cale> Really, I could have given literally any other example of a category :D
10:18:21 <dylukes> But, that said, there's nothing that says you can't have that much structure.
10:18:25 <amindfv> but still calling "toA 4" claims it's too ambiguous
10:18:28 <dylukes> So, yeha.
10:18:29 <dylukes> Haha.
10:18:39 <Myrl-chan> Cale: So, for every (a,b), such that a <= b, an arrow a->b exists?
10:18:43 <Cale> Any category which is not a preorder category will in general have multiple arrows between any given pair of objects
10:18:52 <dylukes> Indeed.
10:18:55 <prsteele> hook0007: nothing is flushing because there is no newline, someone suggested hFlush
10:19:02 <Cale> Myrl-chan: right
10:19:06 <Cale> Myrl-chan: exactly one
10:19:21 <Myrl-chan> This is where I'm confused now.
10:19:24 <Cale> Myrl-chan: and if it's not the case that a <= b, we have no arrow a -> b
10:19:27 <amindfv> nullvoid8 ^^
10:19:29 <hook0007> the prgram works but it does not show "name" before getLine
10:19:30 <Myrl-chan> What exactly do you mean by "exactly one"
10:19:44 <Myrl-chan> There's exactly one arrow with a domain of a?
10:19:47 <Cale> Myrl-chan: I mean that we just use a one element set for the set of arrows a -> b
10:19:55 <prsteele> hook0007: import System.IO
10:19:55 <ski> hook0007 : this is due to (line-) buffering (not Haskell per se), either use `putStr "Name: \n"' or equivalently `putStrLn "Name: "', or use `hFlush stdout' after that to flush the buffer, or use `hSetBuffering stdout NoBuffering' initially to turn off buffering
10:19:58 <Myrl-chan> Cale: I see.
10:20:01 <nullvoid8> is this in ghci or in code?
10:20:03 <dylukes> Myrl-chan don't forget that also holds when a = b :)
10:20:14 <dylukes> If a s.t. a <= a, then a -> a exists.
10:20:15 <prsteele> hook0007: then do hFlush stdout after writing the putStr
10:20:16 <dylukes> (vacuously)
10:20:29 <amindfv> ski: i'd need to redefine "fromIntegral" etc, which would require rebindablesyntax
10:20:44 <ski> amindfv : i don't see why
10:20:44 <Myrl-chan> Hmmm...
10:21:06 <Cale> When we construct the category, we get to determine which collection of objects we have, and for each pair of objects, which collection of arrows exist between them, and then we get to define the composition of arrows (which in the case of a preorder category is trivial because there's only one thing that any given composite could be, but note that there's also at least one thing for it to be because of transitivity)
10:21:20 <amindfv> ski: because there's already a defined fromIntegral
10:21:32 <ski> amindfv : why do you want/need to define another one ?
10:21:42 <amindfv> ski: maybe i'm not understanding what you're proposing
10:21:50 <Cale> We have to define this composition in such a way that there are identity arrows for each object, and such that it is associative
10:22:04 <indiagreen> amindfv: enable ExtendedDefaultRules
10:22:07 <Myrl-chan> Yeah.
10:23:07 <ski> amindfv : i was talking about `fromInteger' (a member of `Num'). not about `fromIntegral'
10:23:35 <nullvoid8> amindfv: note that haskell (ghci?) probably wouldn't complain if it knew the type of your number literal
10:23:35 <hook0007> it works fine with hFlush stdout, and there is no newline afer Name, thats fine too
10:23:41 <amindfv> ski: but the type i'm trying to "coerce to" already has a fromInteger instance
10:23:42 <hook0007> thank you very much
10:23:53 <Myrl-chan> Hmmm..
10:24:14 <hook0007> first thought was, i missunderstood these functional programming thing
10:24:26 <Myrl-chan> :|
10:24:29 <amindfv> ski: (float)
10:24:54 <amindfv> nullvoid8: mostly not ghci -- the main usecase is in modules
10:25:05 <nullvoid8> righto
10:25:24 <amindfv> nullvoid8: the problem i have is that i don't want the user to have to explicitly define the type each time a number is used
10:26:10 <nullvoid8> amindfv: is this just for writing number literals? not any applications to function results
10:26:36 <Myrl-chan> Cale: I think I'm getting confused here.
10:26:47 <amindfv> nullvoid8: right, the only ambiguity is when the user writes e.g. "toA 3.5"
10:26:52 <Myrl-chan> Cale: "I mean that we just use a one element set for the set of arrows a -> b"
10:26:52 <nullvoid8> i.e. "A 45.4" not "A $ f $ ... $ 56
10:27:03 <amindfv> once toA is "performed", there's no ambiguity
10:27:18 <nullvoid8> you literally don't need anything then. toA = A
10:27:26 <Myrl-chan> Cale: What if I have 3 objects, a, b, and c. Do they all use thang single arrow?
10:27:49 <Myrl-chan> Or am I giving an invalid example?
10:27:58 <Myrl-chan> Do they all use that single arrow*
10:29:07 <amindfv> nullvoid8: but what's the instance declaration for it?
10:29:54 <amindfv> e.g. i haven't found any "instance ([something here]) => ToA n where toA = A"
10:30:03 <nullvoid8> amindfv: don't forget that all number literals have type of atleast (Num a) => a.and then gets fixed as Float by application of constructor A :: Float -> A
10:30:18 <amindfv> or "instance ([something here]) => ToA n where toA = A . realToFrac"
10:31:04 <amindfv> nullvoid8: right, but getting the typechecker to understand that it's a float, in a typeclass instance, is what's hard
10:31:08 <Cale> Myrl-chan: You tend not to ask about whether arrows between different pairs of objects are equal or not.
10:31:17 <nullvoid8> why do you need the type class at all?
10:31:43 <Cale> Myrl-chan: You can have it either way, and it doesn't really matter
10:31:57 <amindfv> i can't write e.g. "instance ToA Float" because the type of "4.5" is "(Num a) => a"
10:32:05 <ski> Myrl-chan : personally, i prefer making your question ill-typed
10:32:14 <Myrl-chan> ski: Hmm?
10:32:26 <amindfv> nullvoid8: the "ToA" is a contrived example but using typeclasses is essential for my DSL
10:32:41 <nullvoid8> ah, contrived examples
10:32:57 <ski> Myrl-chan : disallowing asking whether `f : A >---> B' and `g : C >---> D' are equal, unless you already know that `A' is equal to `C' and `B' to `D'
10:32:59 <amindfv> the thing i'm trying to solve is fundamentally about type instance resolution with numbers
10:33:14 <amindfv> nullvoid8: yeah, maybe i should have made the "contrived" part clearer
10:33:19 <Myrl-chan> ski: Ah.
10:33:36 <nullvoid8> amindfv: in the actual DSL, is it still only applied to numeric literals?
10:34:02 <amindfv> it still seems crazy that i haven't been able to get this to work -- i'm willing to build out huge amounts of type machinery if necessary
10:34:33 <johnw> amindfv: maybe you could show us what a usage of your DSL would look like?  this could be an XY scenario
10:34:33 <amindfv> nullvoid8: no, in the dsl there are 3 types, one of which is numeric literals
10:35:02 <indiagreen> amindfv: did ExtendedDefaultRules not work?
10:35:22 <indiagreen> or is it useless 'cause the actual example is different?
10:35:31 <amindfv> johnw: i can give you a very specific example:
10:35:34 <amindfv> http://hackage.haskell.org/package/vivid-0.1.0.3/docs/Vivid-SynthDef-CrazyTypes.html
10:35:48 <amindfv> i'm trying to remove "IncoherentInstances"
10:36:03 <johnw> amindfv: I mean, what the usage of your DSL will should like
10:36:06 <amindfv> indiagreen: it's seemed not to work in the past but i'm trying it another way now
10:36:12 <johnw> should look like*
10:36:16 <amindfv> ah ok
10:36:28 <Imagine> So I'm trying to really understand functors etc, so suppose I'm trying to do this: map ((0 ==) . (a `mod`)), but I don't really want the parentheses around the function given to map
10:36:32 <Cale> These instances look like things which should not be instances.
10:36:42 <indiagreen> amindfv: oh wait, it probably won't work if it's not enabled at the call site, so that's useless
10:36:53 <Cale> Imagine: map (f . g) = map f . map g
10:37:04 <Imagine> gotcha
10:37:04 <Imagine> thanks
10:37:07 <amindfv> so given "foo :: SDState Signal", the user would write e.g. "3.5 ~* foo"
10:37:24 <Imagine> Cale - is there one that is generally better than the other?
10:37:35 <johnw> and ~* is a name for toA, basically?
10:37:36 <ski> Imagine : .. not quite sure how that is related to understanding functors
10:37:44 <Imagine> Maybe I was just way off
10:37:48 <Cale> Imagine: Well, map (f . g) would be expected to be more efficient
10:37:56 <ski> Imagine : typically `map (f . g)' would be preferred to `map f . map g'
10:37:59 <Imagine> I was thinking doing something with fmap
10:38:03 <amindfv> johnw: right
10:38:07 <nullvoid8> amindfv: if it's all literals (when used at numbers), just write instance toSignal Float where toS = Constant
10:38:08 <Imagine> but that might just be way off
10:38:15 <Imagine> hmm okay thanks
10:38:17 <Cale> Imagine: However, there are rewrite rules for map which if you have optimisations turned on will convert map f . map g into map (f . g)
10:38:20 <nullvoid8> err *ToSignal
10:38:51 <Cale> Imagine: I don't believe there are corresponding rewrite rules for fmap, because the compiler can't actually verify that the Functor laws hold.
10:38:58 <amindfv> nullvoid8: when the user writes e.g. "3.5 ~* foo", the 3.5 isn't understood by the typechecker to be a Float
10:39:26 <amindfv> it's "Num a => a", which the typechecker isn't willing to default to a Float instance
10:39:31 <nullvoid8> I think the solution to that is (a ~ Float) => ToSignal a where ...
10:39:37 <Myrl-chan> Cale: I'll go sleep for now, perhaps I'll be able to understand tomorrow.
10:39:50 <Myrl-chan> (That's what I've been saying this whole week.)
10:39:57 <Imagine> gotcha, that makes sense
10:39:59 <Imagine> thank you
10:40:10 <nullvoid8> amindfv: ^ and: plus one of the ...Instances pragmas
10:40:28 <indiagreen> nullvoid8: nope, doesn't work either
10:40:36 <nullvoid8> huh
10:40:55 <amindfv> it works iff you use IncoherentInstances
10:41:00 <amindfv> which... is incoherent
10:41:02 <indiagreen> and neither did some weird creepy stuff I found on haskellwiki
10:41:20 <Cale> amindfv: Generally you should avoid writing any instance of the form  C a
10:41:43 <nullvoid8> yeah, becuase ghc only checks the head (to the right of =>) when checking for overlap
10:41:48 <Cale> instance (Num a, Real a) => ToSig a
10:41:51 <Cale> This is a problem
10:42:05 <Cale> To the instance resolution algorithm, this looks like ToSig a
10:42:21 <Cale> It will only impose the constraints (Num a, Real a) *after* committing to the selection of the instance.
10:43:00 <amindfv> Cale: it seemed fine in this case because i can guarantee that there are only 2 other (more-specific) instances of the class
10:43:12 * hackagebot jmacro 0.6.13 - QuasiQuotation library for programmatic generation of Javascript code.  http://hackage.haskell.org/package/jmacro-0.6.13 (GershomBazerman)
10:43:13 <amindfv> although if there's another way i'm definitely open to it
10:43:16 <nullvoid8> amindfv: you can, the type checker can't
10:43:58 <Cale> Does this operation even need to be in a type class?
10:44:10 <amindfv> nullvoid8: true, but i can at least not expect any unintended behavior from it
10:44:21 <Cale> Why not just have slightly distinct names?
10:44:30 <Cale> Seems like that would clarify things a lot.
10:44:55 <amindfv> Cale: seems like it does need to be
10:45:48 <nullvoid8> Cale: for clarity, the actual usecase/implementation seems to be here: http://hackage.haskell.org/package/vivid-0.1.0.3/docs/src/Vivid-SynthDef-CrazyTypes.html#ToSig
10:46:18 <Cale> nullvoid8: I'm looking at that
10:46:24 <nullvoid8> cool cool
10:47:40 <Cale> amindfv: So, why is having  realToSig :: (Real a) => a -> Signal  and  stringToSig :: String -> Signal  not enough?
10:48:28 <amindfv> Cale: because "toSig" (and "toSigM") are used by other functions, allowing the user to use either e.g. a string or a float as an argument
10:48:38 <ghorn> am I doing something wrong if I need zipWith9 ?
10:48:43 <Cale> ghorn: Probably.
10:48:50 <amindfv> e.g. `0.5 ~* "foo"`
10:48:57 <ghorn> Cale: my data structure just keeps getting bigger and bigger
10:49:12 <amindfv> http://hackage.haskell.org/package/vivid-0.1.0.3/docs/src/Vivid-UGens.html#~*
10:49:18 <Cale> ghorn: If you're using tuples larger than about 3-tuples, and it's not like, machine generated code, then you really need to define some data types.
10:49:42 <Cale> amindfv: In that case, what about just writing a handful of concrete instances?
10:49:55 <ski> ghorn : `ParallelListComprehensions' ?
10:50:03 <dylukes> Gah, it's not possible to define lenses over a type synonym :\
10:50:15 <Cale> amindfv: Like, for Double explicitly, for example.
10:50:20 <nullvoid8> ghorn: also, Applicative (ZipList a)
10:50:35 <Cale> amindfv: Or of course, you could make a newtype wrapper
10:50:37 <dylukes> if only the classes generated by makeClassy were derivable :~:
10:51:03 <nullvoid8> dylukes: it is if you use TypeSynonymInstances
10:51:14 <dylukes> Already on :\.
10:51:19 <nullvoid8> if your problem is what I think it is
10:51:23 <nullvoid8> ...huh
10:51:27 <dylukes> Want the tl;dr version?
10:51:41 <nullvoid8> no, I think I'm about to be pulled away
10:51:51 <amindfv> Cale: you mean e.g. write a "(~*) :: Double -> String -> _", "(~*) :: Double -> Double -> _", etc?
10:52:13 <dylukes> For anyone interested then, given: data Foo' a b = Foo a b, type Foo = Foo Int String, type FooColumn = Foo (Column PGInt) (Column PGText)
10:52:17 <Cale> amindfv: No, I just mean, if you'd like to keep this type class, you could skip the overly polymorphic instance
10:52:20 <dylukes> so, there are two "filling ins" of Foo'
10:52:29 <dylukes> I'd like to derive lenses that work on all of them.
10:52:37 <Cale> amindfv: and just write specific instances for Float, Double, Rational, or whatever other numeric types you really need.
10:52:39 <amindfv> Cale: i'm happy to be more specific, but the problem is type inference
10:52:57 <Cale> instance (Num a, Real a) => ToSig a where
10:52:57 <Cale>    toSig = Constant . fromRational . toRational
10:53:01 <dylukes> The problem is that when the field count gets high enough, defining the instances (with foo = id) is a pain.
10:53:12 <Cale> ^^ get rid of this instance and replace it with identical ones for more specific types
10:53:17 <dylukes> I end up having the type listings duplicated all over the place.
10:53:29 <nullvoid8> amindfv: it really doesn't work, I just tried it with "instance toA Float", though that might have been ghci being annoying
10:53:33 <amindfv> Cale: ghc still isn't going to infer any of those types is it?
10:53:44 <amindfv> ohhh
10:54:00 <amindfv> ah wait, no
10:54:00 <Cale> amindfv: Well, maybe I'm missing something. You'll get rid of the need for IncoherentInstances or any of that nonsense though.
10:54:13 <Cale> Because you'll just be writing plain Haskell 98 instances.
10:54:15 <amindfv> hm i think i've tried that and it doesn't work
10:54:19 <Cale> Try again :D
10:54:20 <amindfv> but i'll try it again
10:54:50 <nullvoid8> you know what's annoying? instance c String needs pragmas to work
10:55:12 <Cale> nullvoid8: kind of...
10:55:19 <nullvoid8> also, my last message to amindfv shouldhave been to Cale :/
10:55:46 <amindfv> Cale: yup, i still get e.g. "No instance for (Fractional n)"
10:55:54 <Cale> amindfv: More context?
10:56:17 <amindfv> "arising from the use of the literal '0.01'"
10:56:49 <nullvoid8> well I have to go, have fun playing with mr. Type System :P
10:56:53 <Cale> Ah, because there's nothing otherwise constraining the 0.01
10:57:06 <Cale> Your operation ought to work if you tell it that 0.01 is a Double
10:57:11 <Cale> yeah?
10:57:16 <Cale> :t 0.01
10:57:18 <lambdabot> Fractional a => a
10:57:31 <amindfv> Cale: that's my original problem
10:57:42 <Cale> Is ExtendedDefaultRules on?
10:57:52 <Cale> You might find that's a bit nicer for you
10:58:02 <amindfv> i'm building a DSL and i don't want the user to need to annotate their numbers with types or constructors
10:58:06 <Cale> (It'll be more aggressive about defaulting ambiguous types)
10:58:10 <narfinger> hiho, i am trying to use blaze and jmacro but how can i put the stuff from jmacro into the blaze stuff?
10:58:34 <Cale> amindfv: hm
11:00:03 <ghorn> Cale, nullvoid8: my data type has an appropriate Applicative instance, thanks
11:00:28 <ghorn> nullvoid8: same concept as ZipList
11:01:31 <amindfv> Cale: yeah, -ExtendedDefaultRules doesn't help, and neither does a toplevel "default (Double)"
11:01:49 <Cale> Well, default (Double) is almost the default default :)
11:03:09 <amindfv> as i said earlier, i'm willing to build out huge amounts of type machinery to get this to work
11:03:16 <amindfv> but as of yet i literally haven't found a way
11:04:45 <Cale> Personally, I'd tend to just back up a bit and go with something with more straightforward types. You can give things short names if you want them to be unobtrusive
11:04:50 <Cale> Like  c :: Double -> Signal
11:04:56 <Cale> and  v :: String -> Signal
11:05:30 <muzzle> hi, does anyone here have experience with travis-CI ?
11:05:45 <indiagreen> muzzle: many people do, I guess
11:05:49 <indiagreen> ask your question
11:06:57 <muzzle> travis seems to be using cabal version 1.18 
11:07:10 <muzzle> this causes me problems because it uses base 4.5
11:07:20 <muzzle> and makes my build fail
11:07:31 <muzzle> but i specified cabal >= 1.22 in my cabal file
11:07:41 <indiagreen> doesn't base version depend on GHC and not cabal?
11:07:48 <amindfv> Cale: an earlier version I worked on used e.g. "F 3.5"
11:07:52 <indiagreen> you are able to choose version of GHC to use
11:07:59 <amindfv> but it's actually a lot more heavyweight syntactically
11:08:18 <muzzle> hmm but i set ghc: 7.10 in my .travis.yml
11:08:19 <amindfv> numbers are pervasive
11:08:24 <indiagreen> 7.10 isn't there yet
11:08:28 <indiagreen> so it defaults to 7.4
11:08:30 <indiagreen> sneakily
11:08:36 <muzzle> this is the repo: https://github.com/kryoxide/minst-idx
11:08:46 * indiagreen shakes fist at Travis CI
11:08:53 <indiagreen> if you need 7.10, use hvr's repository
11:09:04 <indiagreen> https://github.com/hvr/multi-ghc-travis
11:09:43 <indiagreen> (oh, and by the way, “ghc: 7.10” wouldn't have worked anyway, you need “ghc: '7.10'”)
11:10:36 <Darwin226> Is there a way for a module to re-export another module but hide some of it's functions?
11:10:47 <muzzle> indiangreen: thx, i'll try that
11:10:51 <indiagreen> Darwin226: to my best knowledge, there isn't
11:11:04 <indiagreen> wait
11:11:05 <indiagreen> or is there
11:11:20 <indiagreen> wouldn't just “module Something hiding (whatever)” work?
11:11:43 <indiagreen> or “import Something hiding (whatever)” and then specifying “module Something” in the export list?
11:11:58 <Darwin226> indiagreen: Parse error on the first attempt
11:12:25 <Darwin226> indiagreen: Lift off on the second!
11:12:28 <amindfv> Cale, johnw, nullvoid8 : could "unsafeCoerce" be a way to get out of this mess? i mean, it's unsafe but if i know what types they'll be defaulted to (Integer and Double) it might be safe?
11:12:30 <Darwin226> indiagreen: Thanks
11:13:13 <indiagreen> Darwin226: I got it confused with “export all functions but <some> from the module” at first
11:13:47 <Cale> amindfv: No, that's only going to cause segfaults
11:15:42 <amindfv> or some other cast?
11:18:20 <Cale> amindfv: Those kind of solve the opposite problem from what you're having
11:18:40 <Imagine> Is there any way to check whether some type is a subtype of another? (aka is Integral a subtype of Floating?)
11:18:52 <arkeet> those are classes, not types
11:19:03 <Imagine> I mean classes then
11:19:27 <Cale> amindfv: unsafeCoerce is for when the type is unambiguous, but the compiler isn't smart enough to figure that out. Here, the type *is* ambiguous, so no amount of weakening the information you have about it will save you.
11:19:54 <Cale> amindfv: Like, when you write 0.001 or something, that's actually a function of the Fractional type class dictionary.
11:20:30 <Cale> amindfv: and your problem right now is that the compiler doesn't know which instance dictionary to supply
11:21:31 <johnw>  you could extend your dsl with: float 3.5 ~* foo or int 3 ~* foo
11:21:43 <Cale> right, I already suggested doing that
11:21:47 <johnw> ah, ok
11:22:30 <johnw> or just always use Float, rather than some 'a' which is going to be passed to a constructor that wants a Float in the end
11:22:36 <amindfv> johnw: the problem is that numbers are so pervasive for my uses that users literally told me they'd rather use a different tool than o all that annotating
11:22:43 <johnw> ah
11:23:14 <Imagine> I'm trying to use sqrt a, when in the declaration I said declared a to be in the Integral class, but I'm getting the error that "Could not deduce (Floating a) arising from a use of `sqrt'     from the context (Integral a)"
11:23:25 <arkeet> well
11:23:31 <Imagine> Isn't Integral a subclass of floating?
11:23:33 <arkeet> nope.
11:23:39 <arkeet> and that's why you get that error
11:24:06 <arkeet> incidentally, that suggests an answer to your question.
11:24:09 <arkeet> in general.
11:24:12 <Cale> Imagine: Integral and Floating are pretty much disjoint classes
11:24:32 <Cale> Imagine: Integral is for types like Integer, Word32, etc, which are integer-like
11:24:51 <arkeet> or generally, types that can be converted to Integer.
11:24:57 <Cale> Imagine: Floating is for floating point types
11:25:12 <Cale> (Double, Float, etc.)
11:25:13 <arkeet> e..g
11:25:14 <Imagine> Can't all integers though be represented as floating point types as well?
11:25:16 <arkeet> Integer is Integral, but not Floating.
11:25:33 <arkeet> you can convert from any Integral type to any other number type.
11:25:34 <arkeet> :t fromIntegral
11:25:36 <arkeet> but you have to convert.
11:25:38 <lambdabot> (Integral a, Num b) => a -> b
11:25:42 <Cale> Imagine: no, and more importantly not all floating point values are representable as integers
11:25:54 <Imagine> because, for example, I typecast a = 5 :: Integer , and then I could do sqrt on it inside of ghci
11:26:06 <Imagine> wait jk
11:26:07 <Imagine> it didn't work
11:26:09 <Imagine> I did it wrong
11:26:15 <Cale> Note that this isn't a cast
11:26:31 <Imagine> That isn't a cast?
11:26:32 <Cale> You're simply providing information about what type of value the 5 is.
11:26:37 <ReinH> :t 5
11:26:38 <lambdabot> Num a => a
11:26:47 <Imagine> :t 5::Integer
11:26:48 <lambdabot> Integer
11:26:50 <ReinH> number literals are polymorphic
11:26:56 <Zemyla> :t \x -> floor (sqrt (fromIntegral x)) `asTypeOf` x
11:26:57 <lambdabot> Integral a => a -> a
11:26:57 <Cale> It refines the type, but does no conversion.
11:27:35 <Imagine> Ah, okay
11:27:42 <ReinH> You can't do typecasting with ::
11:27:49 <Imagine> How do you do typecasting?
11:27:54 <Imagine> out of curiosity?
11:27:54 <arkeet> you don't.
11:27:55 <ReinH> You don't.
11:27:59 <maerwald> :D
11:28:03 <Imagine> ah
11:28:06 <arkeet> there are explicit functions for converting between numeric types.
11:28:08 <arkeet> such as fromIntegral
11:28:10 <Cale> For numeric conversions, use fromInteger 
11:28:14 <Cale> er fromIntegral, yes
11:28:17 <arkeet> or realToFrac
11:28:32 <ReinH> But these aren't "casts", they're just functions
11:28:36 <geekosaur> there is no generic casting mechanism. specific types may provide type conversion functions
11:28:48 <Imagine> got it
11:28:48 <arkeet> :t fromIntegral :: Integer -> Word32
11:28:50 <lambdabot> Integer -> Word32
11:28:51 <dylukes> tomjaguarpaw: hey do you have any suggestions with using lenses with opaleye?
11:28:52 <arkeet> :t realToFrac :: Float -> Double
11:28:54 <lambdabot> Float -> Double
11:28:56 <geekosaur> hm. I might be too slow today...
11:29:06 <dylukes> I suppose it's just not going to work with the type synonyms :\
11:29:17 <Cale> :t round
11:29:18 <lambdabot> (Integral b, RealFrac a) => a -> b
11:29:21 <Cale> :t floor
11:29:23 <lambdabot> (Integral b, RealFrac a) => a -> b
11:29:24 <dylukes> I'll have to define all the nasty instances myself :<
11:29:28 <Cale> :t ceiling
11:29:30 <lambdabot> (Integral b, RealFrac a) => a -> b
11:29:53 <Cale> There are a bunch of ways to lose information about the fractional part of a number.
11:29:57 <Zemyla> The only general casting system is newtype casting with coerce.
11:30:09 <arkeet> :t truncate :: Float -> Int
11:30:10 <lambdabot> Float -> Int
11:30:25 <dylukes> @hoogle Float -> Int
11:30:27 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
11:30:27 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
11:30:27 <lambdabot> Data.Generics.Schemes gsize :: Data a => a -> Int
11:30:34 <dylukes> heh
11:30:41 <arkeet> heh
11:31:10 <dylukes> @hoogle RealFrac a, Integral b => a -> b
11:31:11 <lambdabot> Parse error:
11:31:11 <lambdabot>   RealFrac a, Integral b => a -> b
11:31:11 <lambdabot>             ^
11:31:21 <dylukes> @hoogle (RealFrac a, Integral b) => a -> b
11:31:23 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
11:31:23 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
11:31:23 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
11:31:54 <dylukes> :i RealFrac
11:33:04 <arkeet> lambdabot doesn't :info 
11:33:41 <amindfv> ok, another question: if i give up and use -XIncoherentInstances, how "contained" is that -- e.g. when i turn it on in a module, can i get guarantees about coherence in other modules?
11:34:51 <dylukes> So, should ImplicitParams ever be used?
11:34:55 <dylukes> I don't see it frequently.
11:36:24 <kirill`> Do I understand correctly that this isn't undefined behaviour in Haskell, unlike C++?
11:36:24 <kirill`> x <- newIORef value; forkIO (writeIORef x otherValue); forkIO (print =<< readIORef x)
11:37:39 <Cale> kirill`: That's defined, but nondeterministic behaviour.
11:37:42 <Zemyla> kirill`: Use MVars instead, for your safety and protection.
11:38:04 <Cale> kirill`: You'll end up printing one of the two values, at random.
11:38:16 <Cale> (with an unpredictable distribution)
11:38:33 <kirill`> But it's guaranteed to be one of the two, right?
11:38:37 <Cale> It's impossible to observe a half-written value or something shitty like that
11:39:26 <Cale> The IORef is only a single machine word, so reads and writes to it are atomic.
11:40:54 <Imagine> I'm having the same issue
11:40:58 <Imagine> Could not deduce (Floating a) arising from a use of `sqrt'
11:41:03 <Imagine> where a is declared as Integral
11:41:10 <Imagine> and I do sqrt (fromIntegral a)
11:41:15 <Zemyla> You'll either have a thunk which the consuming thread evaluates, or a constructor which was evaluated by the producing thread.
11:41:30 <Imagine> hmmm
11:42:01 <ski> Imagine : context
11:42:16 <kirill`> Cale: thanks
11:43:08 <geekosaur> Imagine, that makes me think the result is being used in the context of a type that is not a member of Floating
11:44:07 <Imagine> http://lpaste.net/133441
11:44:28 <geekosaur> :t takeWhile
11:44:29 <lambdabot> (a -> Bool) -> [a] -> [a]
11:44:52 <geekosaur> oh, that's not it
11:45:09 <narfinger> sorry i had weird connection problems
11:45:21 <geekosaur> you use map (a `mod`) on the list, which makes it some type which has an Integral instance
11:45:31 <Cale> Imagine: So, because you're comparing the elements of the list (2:[3,5..]) with a Floating value (the result of the sqrt), the elements of that list themselves have to be the same type
11:45:37 <geekosaur> then you compare to sqrt (fromIntegral a)
11:45:58 <geekosaur> so sqrt is expected to produce a type that is an instance of Integral
11:46:11 <Imagine> Ohhh - so when I'm taking elements, the elements are converted to Floating
11:46:12 <narfinger> i have a wl-pprint Doc document und i i want to produce a string but now it escapes the " which i don't want to
11:46:15 <narfinger> how can i do that?
11:46:16 <geekosaur> but it only works for types that are instances of Floating
11:46:20 <Cale> Imagine: Not converted
11:46:23 <Imagine> Because thats the only way to compare them?
11:46:36 <Imagine> Well the list itself is Num, right?
11:46:36 <geekosaur> so you need to convert the result of sqrt back to something that has an Integral instance
11:46:43 <Imagine> :t 2:[3,5..]
11:46:44 <lambdabot> (Enum a, Num a) => [a]
11:46:50 <Cale> Imagine: The only way you can make that comparison is if the list consists of elements of some type which is Floating to begin with.
11:46:54 <geekosaur> no
11:46:59 <Cale> Imagine: So it might be, say, Double.
11:47:01 <ski> Imagine : you could use `(< sqrt (fromIntegral ?a)) . fromIntegral' instead of `(< sqrt (fromIntegral ?a))' there
11:47:01 <geekosaur> because you use `mod` on elements of the list later
11:47:15 <geekosaur> and type inference propagates that through
11:47:32 <Cale> geekosaur and I are collecting the constraints on the types in the opposite order :)
11:47:37 <ski> Imagine : or you could use `\n -> n^2 < a' ..
11:47:46 <Zemyla> Imagine: If a < sqrt n, then a * a < n.
11:48:15 <Imagine> Yeah, maybe squaring them is the best option
11:48:22 <arkeet> :t (:-)
11:48:23 <Imagine> but I'd still like to understand what is wrong with what I currently have 
11:48:24 <lambdabot>     Not in scope: data constructor ‘:-’
11:48:24 <lambdabot>     Perhaps you meant one of these:
11:48:24 <lambdabot>       ‘:+’ (imported from Data.Complex),
11:48:29 <arkeet> @let import Data.Constraint
11:48:30 <lambdabot>  .L.hs:77:1:
11:48:30 <lambdabot>      Failed to load interface for ‘Data.Constraint’
11:48:30 <lambdabot>      Use -v to see a list of the files searched for.
11:48:31 <Cale> But yeah, the problem here is that after collecting up all the constraints on the type a here, you end up needing both Integral and Floating, and there are no types which happen to be instances of both
11:48:32 <arkeet> bah
11:48:47 <Imagine> Gotcha
11:48:50 <Imagine> okay that makes sense
11:49:06 <Cale> You could do  takeWhile (\x -> fromIntegral x < sqrt (fromIntegral a))
11:49:23 <Imagine> Although when comparing them for the takeWhile, couldn't you do some sort of sort-by-key?
11:49:31 <Welkin> I want to pattern match only on the second parameter of a constructor, but ignore the constructor entirely
11:49:34 <Cale> hm?
11:49:34 <Welkin> is that possible?
11:49:41 <Cale> The elements of the list are already sorted
11:49:47 <Imagine> I don't mean sort
11:49:50 <Imagine> I meant compare-by-key
11:49:57 <Welkin> given: data Card = Card a b c
11:50:02 <Cale> Welkin: not really, no. You can make a function which does this
11:50:02 <ski> Imagine : `takeWhile (< sqrt (fromIntegral a)) xs' will constrain the elements of `xs' to be of a type in `Floating' (because they're compared with results from `sqrt'). later, you're attempting to pass elements of that list to `mod', which doesn't work out
11:50:05 <Imagine> the key being the Floating version of the Integral
11:50:17 <Welkin> can I pattern match on b?
11:50:31 <Welkin> well, assuming there are multiple constructors available
11:50:32 <Cale> Welkin: f (Card _ b _) = ...
11:50:40 <Welkin> yes
11:50:47 <Welkin> but can I do it without the constructor
11:50:53 <arkeet> you need a separate pattern for each constructor.
11:50:53 <Cale> Welkin: If there are multiple constructors, no, you can't match more than one constructor at a time.
11:51:03 <ski> Imagine : so, either you don't require the elements of that list to be of a type in `Floating' (by explicitly converting before comparing, like `(< sqrt (fromIntegral a)) . fromIntegral'), or you reformulate to use integral arithmetic instead (squaring instead of square root)
11:51:03 <arkeet> (we need or-patterns.)
11:51:08 <Welkin> say there are 8 constructors, but I want the second parameter from each one, regardless of the constructor
11:51:16 <Cale> arkeet: fsvo "need" :)
11:51:20 <arkeet> :)
11:51:24 <Welkin> okay
11:51:37 <arkeet> Welkin: maybe you should define your data type differently then.
11:51:44 <arkeet> if all the constructors have the same shape.
11:51:51 <Imagine> ski - so I guess you need to be doing it yourself
11:51:52 <Imagine> thank you
11:51:54 <Cale> Welkin: perhaps write a function which projects out the relevant component, but yeah, this sounds like your data type is factored improperly
11:52:00 <Imagine> generally, is one considered better than the other?
11:52:11 <xXx_GAY_POO_xXx> dongs
11:52:16 --- mode: ChanServ set +o glguy
11:52:17 --- mode: glguy set +b *!*@65.202.30.2
11:52:17 --- kick: xXx_GAY_POO_xXx was kicked by glguy (xXx_GAY_POO_xXx)
11:53:23 <Welkin> Cale: factored improperly?
11:53:52 <arkeet> instead of having data Blah = C1 a b c | C2 a b c | C3 a b c
11:53:53 <arkeet> consider
11:53:55 <Welkin> my types really are quite a mess, but I did it to make it work easily with postgres and yesod forms
11:53:59 <arkeet> data Tag = C1 | C2 | C3
11:54:02 <arkeet> data Blah = C Tag a b c
11:54:03 <arkeet> or something
11:54:21 <Welkin> each one has different parameters, except the first two, which are the same for all of them
11:54:24 <ski> > let n :: Int; n = 2^32; a = n+1 in n^2 < a
11:54:27 <lambdabot>  True
11:54:43 <arkeet> okay, then put more stuff in Tag.
11:54:49 <arkeet> the things that differ for each thing.
11:54:54 <arkeet> (and you probably want better names)
11:56:17 <dylukes> Weren't ConstraintKinds/Constraint families added specifically to avoid needing to tag :p?
11:56:26 <Cale> wat
11:56:41 <dylukes> You can do stuff like...
11:56:50 <Cale> The name "Tag" here is irrelevant
11:57:07 <dylukes> Ah okay, there's non-distinct usage of a b c
11:57:08 <Cale> This discussion is really about how to structure data
11:57:34 --- mode: glguy set -o glguy
11:57:36 <dylukes> I wish it wasn't a pain to structure types with lots of parameters :\
11:57:46 <dylukes> I'm not looking forward to typing out multiple instance heads with 13+ nontrivial parameters.
12:00:55 <dylukes> How is this even possible...
12:00:59 <dylukes> if I include the instances I get overlapping instances
12:01:04 <dylukes> if I don't, I have missing instances
12:01:40 <dylukes> Ahaaa!
12:05:25 <albeit> @pl \k _ -> f k
12:05:25 <lambdabot> const . f
12:06:10 <dylukes> @pl \k _ _ _ -> f k
12:06:10 <lambdabot> const . const . const . f
12:06:19 <dylukes> @pl \_ k _ -> f k
12:06:19 <lambdabot> const (const . f)
12:06:23 <dylukes> @pl \_ k _ _ -> f k
12:06:23 <lambdabot> const (const . const . f)
12:06:28 <dylukes> @pl \_ _ k _ _ -> f k
12:06:28 <lambdabot> const (const (const . const . f))
12:06:29 <dylukes> neat.
12:07:21 <dylukes> So, in general @pl \[_]{n} k [_]{m} -> f k ==> [const $]{n} [const .]{n} f
12:07:42 <dylukes> [const .]{m}*
12:08:05 <Imagine> @Hoogle Fractional a, Integral b => a -> b
12:08:05 <lambdabot> Maybe you meant: hoogle google
12:08:07 <quchen> You can also message lambdabot in private (/msg lambdabot) when you just want to try things out (as opposed to demonstrating code to others). 
12:08:09 <Geekingfrog> does this has any other goal than obfuscation?
12:08:13 <dylukes> @p \a _ _-> \_ b _ -> \_ _ c -> f a b c
12:08:14 <lambdabot> Maybe you meant: palomer part paste ping pinky pl pl-resume pointful pointless pointy poll-add poll-close poll-list poll-remove poll-result poll-show pop-topic pretty print-notices protontorpedo purge-notices push-topic v @ ? .
12:08:17 <dylukes> @p; \a _ _-> \_ b _ -> \_ _ c -> f a b c
12:08:17 <lambdabot> const . const . const . ((const . const . const) .) . f
12:08:30 <Imagine> @hoogle Fractional a, Integral b => a -> b
12:08:30 <lambdabot> Parse error:
12:08:31 <lambdabot>   Fractional a, Integral b => a -> b
12:08:31 <lambdabot>               ^
12:09:15 <geekosaur> ()
12:09:20 <Imagine> Okay - new question. Suppose I know that a/b is going to be an integer (by how I've chosen b), but Haskell does not know that
12:09:25 <dylukes> @pl \a b -> concat $ replicate a b
12:09:25 <lambdabot> (join .) . replicate
12:09:26 <Imagine> so a/b is now Fractional
12:09:36 <dylukes> @pl \a b -> concat (.).(.) replicate
12:09:37 <lambdabot> const (const (join (.) . (replicate .)))
12:09:40 <ski> @type [ceiling,floor,truncate,round] :: (RealFrac a,Integral b) => [a -> b]  -- Imagine
12:09:41 <lambdabot> (Integral b, RealFrac a) => [a -> b]
12:09:44 <dylukes> @pl concat (.).(.) replicate
12:09:44 <lambdabot> join (.) . (replicate .)
12:09:53 <dylukes> interesting...
12:09:58 <dylukes> @pl concat ((.).(.)) replicate
12:09:58 <lambdabot> (replicate .) . replicate
12:10:05 <Imagine> What should I use to convert a/b back to an integer?
12:10:07 <Imagine> is truncate fine?
12:10:18 <Imagine> I mean it doesn't really matter, but is there an accepted practice?
12:10:18 <ski> Imagine : convert back in which way ?
12:10:26 <arkeet> consider using div
12:10:27 <Imagine> So I know that a mod b = 0
12:10:34 <dylukes> Well I mean,
12:10:35 <Imagine> ooooh
12:10:36 <Imagine> yes
12:10:39 <Imagine> div is the right choice
12:10:46 <dylukes> :)
12:11:14 <Imagine> ski - I meant like a mod b = 0, but a/b is fractional even though it could be an integer
12:11:23 <Imagine> so I should just do a div b
12:11:26 <ski> `div' goes with `mod'
12:11:31 <ski> (and `quot' goes with `rem')
12:11:39 <arkeet> > 30 `div` 3 :: Integer
12:11:41 <lambdabot>  10
12:11:49 <ski> > 17 `div` 7
12:11:51 <lambdabot>  2
12:12:16 <Imagine> whats the difference between rem and mod?
12:12:26 <arkeet> the same as the difference between quot and div
12:12:27 <int-e> Cale: I'm not importing Control.Monad.Strict (@undef helped...)
12:12:30 <dylukes> Imagine One is remainder, one is modulus. 
12:12:32 <arkeet> quot rounds toward 0, div rounds down (toward -infinity)
12:12:38 <kadoban> Imagine: Negative numbers
12:12:38 <int-e> Cale: sorry, Control.Monad.State.Strict
12:12:39 <arkeet> rem and mod satisfy
12:12:39 <dylukes> For most practical purposes, the difference is how negative numbers are handled.
12:12:43 <Imagine> gotcha
12:12:49 <arkeet> b * (a `div` b) + a `mod` b = a
12:12:56 <arkeet> b * (a `quot` b) + a `rem` b = a
12:13:17 * hackagebot minst-idx 0.1.2.0 - Read and write IDX data that is used in e.g. the MINST database.  http://hackage.haskell.org/package/minst-idx-0.1.2.0 (muzzle)
12:13:24 <arkeet> > [(-17) `divMod` 5, (-17) `quotRem` 5]
12:13:26 <lambdabot>  [(-4,3),(-3,-2)]
12:13:45 <arkeet> in particular, the result of mod is always nonnegative
12:13:58 <arkeet> the result of rem has the same sign as the first argument (or it's zero)
12:14:25 <arkeet> quot and rem behave like how / and % work in C on most platforms.
12:14:39 <arkeet> (where most platforms = x86, for me.)
12:15:00 <mathu> which of these two functions is considered 'better' haskell? they both do the same thing https://bpaste.net/show/143e769651ea
12:16:03 <arkeet> I find the first one more readable.
12:16:04 <Hail_Spacecake> haskellists have this thing for functions without an explicit argument
12:16:09 <Hail_Spacecake> that I disagree with
12:16:18 <arkeet> pick the one that's more readable.
12:16:19 <int-e> arkeet: in fact C11 specifies this behavior for / and % for signed types.
12:16:24 <ski> mathu : i'd use  (0 ==) . (`mod` 10)  instead of  (==0) . (flip mod 10)  in the latter one
12:16:27 <prsteele> is there a way to say 'functions of an arity' in Haskell? My goal is to define a generalized composition operator, say <>, which (roughly) has type (<>) :: (a -> b) -> (t1 -> ... -> tn -> a) -> (t1 -> ... -> tn -> b), for any n
12:16:38 <Hail_Spacecake> first one's more readable, yeah
12:16:45 <arkeet> prsteele: you can do that with type classes
12:17:04 <amindfv> ok, this still doesn't work:
12:17:08 <mathu> ski: for some reason i thought i wouldn't be able to choose the second argument of the function applied infix like you did. i guess i'm wrong
12:17:11 <amindfv> class Foo a b where foo :: a -> Float
12:17:14 <arkeet> but you might have some problems with inference
12:17:19 <amindfv> instance (Fractional n) => Foo n b where foo _ = 7
12:17:22 <indiagreen> prsteele: see Oleg Kiselyov's “mcomp”
12:17:24 <mathu> i find the first one readable as well, but i rarely see haskell functions written that way :P
12:17:25 <amindfv> instance Foo String b where foo _ = 5
12:17:27 <int-e> (earlier versions of the C standard didn't)
12:17:30 <ski> prsteele : every function in Haskell accepts exactly one argument
12:17:38 <amindfv>  .  foo 4.5
12:17:46 <amindfv> No instance for (Fractional a0) arising from the literal ‘4.5’
12:17:57 <mathu> if it's idiomatic to use composition instead of parens, for instance, then okay
12:18:08 <hsk4> Can I configure GHCi such that the comma character on my numpad (and only on my numpad, not the other comma) outputs a dot?
12:18:21 <hsk4> (Useful on my European keyboard when performing US-style calculations)
12:18:24 <mathu> you could possibly configure your keyboard or os that way
12:18:25 <hsk4> (When using GHCi as as calculator)
12:18:27 <geekosaur> that;s not up to ghci
12:18:34 <voidzero> maybe you can set LC_NUMERIC
12:18:39 <voidzero> if you're using Linux
12:18:40 <prsteele> ski: yes, but I meant more can I abstract over the return type of a function, as described
12:18:50 <voidzero> in Dutch, the decimal character is a comma
12:18:58 <voidzero> so, we say, 10,5 for ten and a half
12:19:06 <dylukes> @hoogle f (g a) -> g a
12:19:07 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
12:19:07 <lambdabot> Data.Foldable msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
12:19:07 <lambdabot> Data.Foldable concat :: Foldable t => t [a] -> [a]
12:19:20 <voidzero> I
12:19:33 <ski> mathu : i might perhaps use  validate n = (sumDigits . doubleEveryOther . toDigits) n `mod` 10 == 0  (composition *and* brackets :)
12:19:38 <voidzero> I don't know how GHCi incorporates locales
12:20:06 <geekosaur> I don't think it will change how it parses numbers
12:20:08 <dylukes> @hoogle Functor f => f (g a) -> g a
12:20:09 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
12:20:09 <lambdabot> Data.Foldable msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
12:20:09 <lambdabot> Data.Foldable concat :: Foldable t => t [a] -> [a]
12:20:16 <dylukes> @hoogle Comonad w => w (g a) -> g a
12:20:16 <lambdabot> Warning: Unknown class Comonad
12:20:16 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
12:20:16 <lambdabot> Data.Foldable msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
12:20:53 <ski> dylukes : .. looking for ?
12:20:56 <geekosaur> on X11 this is something you could do in the terminal config (some terminals, at least, such as xterm) or in the X11 keyboard config
12:21:03 <amindfv> am i able to get any inference with multiparam typeclasses? ^^
12:21:05 <dylukes> ski something general for a decently simple problem I have 
12:21:26 <ski> amindfv : usually functional dependencies help with that
12:21:55 <dylukes> ski given data TicketId' a = TicketId a deriving Functor; type TicketId = TicketId Int; type TicketIdColumn = TicketId (Column PGInt$)
12:22:00 <dylukes> where the last one SHOULD be a newtype...
12:22:08 <dylukes> well, actually the first one*
12:22:10 <dylukes> anyhow
12:22:21 <ski> amindfv : anyway .. i though Cale explained why `instance Fractional n => Foo n b' is not a good idea ?
12:22:32 <dylukes> I'm just curious to find a nice way to pull out the Column PGInt4 bit.
12:22:36 <dylukes> Without just matching it heh.
12:22:41 <geekosaur> use xev to find out what keycode maps to the keypad . and xmodmap to associate something different with it
12:22:46 <geekosaur> er, keypad ,
12:23:09 <amindfv> ski: i understand that in general it's not good but i don't see any other options here, and i know that no other instances will be created
12:23:16 <amindfv> and that all other instances are more specific
12:23:18 * hackagebot inline-c 0.5.3.1 - Write Haskell source files including C code inline. No FFI required.  http://hackage.haskell.org/package/inline-c-0.5.3.1 (FrancescoMazzoli)
12:23:25 <prsteele> indiagreen: your suggestion is spot-on
12:24:12 <dylukes> ski actually looks like it might be a sensible comonad 
12:24:14 <geekosaur> mrrr, I don't have a physical machine running X11 with a keyboard that has a keypad...
12:24:22 <amindfv> ski: that would make it fine, correct?
12:24:27 <dylukes> except for duplicate, which makes no sense haha
12:26:13 <dylukes> having a newtype would also simplify things
12:26:16 <mathu> ski: yeah i think that one's best
12:26:18 <mathu> thank you!
12:26:26 <dylukes> but makeAdaptorAndInstance doesn't support newtypes :\
12:26:30 <mathu> i'm used to letting style guides make my decisions for me :P
12:26:51 <platz> worth noting Ubuntu and derivatives no longer use xmodmap, but instead use xkb
12:27:51 <geekosaur> most things putatively use xkb. but simple things like this still are easier to set up with xmodmap
12:27:59 <geekosaur> because xkb is a shambling horror
12:28:23 <platz> xmodmap simply stopped working for me completely
12:28:43 <platz> the only way i could remap keys were updates to /usr/share/X11/xkb/symbols/us
12:29:15 <quxbam> :q
12:29:20 <geekosaur> hm. suse kept trying that in the early 2000s and reverting it because it caused so much pain. then again canonical does not care how much pain they cause
12:29:22 <platz> maybe switching to systemd
12:29:29 <platz> causes it
12:29:30 <geekosaur> so I suppose they would force you to do it
12:29:34 <geekosaur> systemd has nothing to do with it
12:29:44 <geekosaur> it's all inside the X server
12:29:54 <geekosaur> so, http://www.charvolant.org/~doug/xkb/html/index.html have fun storming the castle
12:30:19 <platz> well there's this at least https://askubuntu.com/questions/325272/permanent-xmodmap-in-ubuntu-13-04/347382#347382?newreg=4eb097870a15490ebbe39d78412f9797
12:30:33 <lpaste> arkeet pasted “prsteele” at http://lpaste.net/133446
12:31:30 <geekosaur> (I know weston just picked up xkb wholesale instead of coming up with a sensible keyboard config. that all by itself is a warning that weston development is not rational)
12:31:36 <hunteriam> does anyone know if haskell-docs is broken in ghc 7.10?
12:31:55 <lpaste> arkeet revised “prsteele”: “No title” at http://lpaste.net/133446
12:32:04 <arkeet> prsteele: this works sort of
12:32:06 <hunteriam> that, and, does anyone use windows for dev? is the intellij haskell plugin any good?
12:32:27 <arkeet> but it needs a lot of help with inference if you try to use it with polymorphic things
12:33:43 <lpaste> arkeet revised “prsteele”: “No title” at http://lpaste.net/133446
12:33:50 <arkeet> oops
12:33:53 <arkeet> how to make it not spam. :<
12:34:26 <prsteele> arkeet: interesting, thanks!
12:34:28 <Welkin> I've never seen this error before
12:34:29 <Welkin> http://lpaste.net/133449
12:34:55 <Welkin> perhaps I am not using record syntax properly?
12:35:15 <geekosaur> Welkin, TextCardForm{..} created a local binding
12:35:24 <geekosaur> see NamedFieldPuns extension
12:35:27 <Welkin> hm
12:35:33 <Welkin> I only want to matcho n the constructors
12:35:36 <arkeet> in particular, it binds _textCardFormTitle to _textCardFormTitle card
12:35:43 <arkeet> use {} instead of {..} then
12:35:47 <Welkin> ah
12:35:49 <dylukes> ^
12:35:49 <geekosaur> so within that, _textCardFormTitle has the value you want
12:35:50 <dylukes> yep
12:35:51 <Welkin> thank you
12:36:02 <dylukes> Records: here be _dragons :: [Dragon]
12:36:13 <geekosaur> random extensions, rather
12:36:21 <hunteriam> what are you guys talking about?
12:36:24 <hunteriam> TextCardForm?
12:36:35 <arkeet> talking about Welkin's paste.
12:36:35 <dylukes> I generally just bite the bullet and use prefixes. 
12:36:41 <geekosaur> the {..} form applied to it
12:36:58 <dylukes> {..} is new to me.
12:36:59 <dylukes> Neat.
12:37:11 <dylukes> I'm hopefully putting some Haskell into production this week :).
12:37:14 <arkeet> that's RecordWildCards or something.
12:37:22 <dylukes> Implementing a small CASv3 compliant auth server at the moment.
12:37:23 <geekosaur> actually yes https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#record-wildcards
12:37:26 <hunteriam> you can pattern match on TextCardForm{..})?
12:37:39 <Welkin> geekosaur: thanks for the suggestions
12:37:45 <Welkin> there are still so many extensions I have never used
12:37:47 <dylukes> yes, and from the looks of the error, it partially applies the projections
12:37:52 <geekosaur> yes, and it has the side effect of assigning all the field names as local bindings
12:37:59 <dylukes> data Foo = Foo { a :: A, b :: B}
12:38:03 <Welkin> I very much enjoy ViewPatterns and RecordWildCards though
12:38:13 <dylukes> ViewPatterns are excellent.
12:38:16 <hunteriam> does that require an extension?
12:38:17 <dylukes> AH!
12:38:19 * hackagebot terminal-size 0.3.1 - Get terminal window height and width  http://hackage.haskell.org/package/terminal-size-0.3.1 (MatveyAksenov)
12:38:22 <dylukes> View patterns are what I need here.
12:38:25 <dylukes> Thanks for reminding me Welkin 
12:38:32 <geekosaur> as repeatedly mentioned, RecordWildCards extension
12:38:32 <prsteele> arkeet: So this is interesting, but overkill. I literally wanted to solve let f' a b c = 8 * (f a b c).
12:38:48 <geekosaur> I even pointed to the documentation
12:38:59 <arkeet> :t ((.).(.).(.)) (8 *)
12:39:00 <lambdabot> Num c => (a -> a1 -> a2 -> c) -> a -> a1 -> a2 -> c
12:39:28 <prsteele> arkeet: right, solutions for a fixed number of parameters is easy, I just couldn't see how to generalize
12:39:29 <dylukes> @pl \a b c -> 8 * (f a b c)
12:39:29 <lambdabot> (((8 *) .) .) . f
12:39:49 <arkeet> yeah.
12:39:56 <arkeet> :t ((((8 *) .) .) .)
12:39:56 <lambdabot> Num c => (a -> a1 -> a2 -> c) -> a -> a1 -> a2 -> c
12:40:05 <prsteele> arkeet: rather, generalize at the syntax level, and not just typing more
12:40:21 <mniip> prsteele, add N fmaps in the front
12:40:23 <crough> arkeet: Compose compose and compose composed with compose something times eight
12:40:29 <crough> arkeet: pointfree is fun!
12:40:37 <dylukes> So, are ImplicitParams verboten?
12:40:40 <arkeet> the typeclass thing kinda sucks because of inference issues.
12:40:40 <dylukes> Or are they kosher?
12:40:46 <arkeet> dylukes: they're safe.
12:40:56 <arkeet> more or less.
12:41:19 <dylukes> Safety I'm not too concerned about
12:41:25 <dylukes> it's more "are they actually useful?"
12:42:15 <arkeet> I mostly used them as a substitute for holes, before ghc had holes.
12:42:43 <geekosaur> yeh, I think their most common use was with lambdabot and in ghci
12:42:52 <arkeet> :t sortBy ?f "asdf"
12:42:53 <geekosaur> to get the type of some internal unknown
12:42:54 <lambdabot> (?f::Char -> Char -> Ordering) => [Char]
12:42:59 <arkeet> that sort of thing. I dunno.
12:43:06 <ion> They're going to be used for call stack information.
12:44:04 <ion> A special ?location or something like that
12:46:30 <dmj`> anyone else having trouble installing servant?
12:46:35 <dmj`> http://lpaste.net/133448
12:51:22 <judicare> does anyone here use bytestring-trie and get as confused as I am reading the haddocks for `match`?
12:51:31 <judicare> it says it does prefix matching in the docs but appears to do exact matching
12:52:23 <ziocroc> were frp wormholes ever implemented?
12:55:34 <ski> dylukes : why would  forall a. TicketId' a -> TicketId' (TicketId' a)  make no sense ?
12:55:35 <et8> greetings, anyone here know about video broadcasting technology?
12:55:45 <ski> amindfv : "i know .. that all other instances are more specific" would perhaps suggest `OverlappingInstances' .. but it's usually not encouraged
12:55:46 <dylukes> ski well, semantically speaking
12:55:48 <et8> or which channel is most relevant to setting up this kind of system
12:55:48 <ski> amindfv : "i know that no other instances will be created" -- you can't declare such, and Haskell will always allow more instances to be made (e.g. by a third party)
12:55:49 <dylukes> it doesn't quite mean anything
12:56:11 <ew_> I have a list of objects of type Disc { _coddisc :: Integer }
12:56:15 <ew_> with lenses
12:56:25 <ew_> how do I get an [Integer] with all the coddiscs ?
12:56:41 <ski> dylukes : i can be used to construct  (TicketId' a -> b) -> (TicketId' a -> TicketId' b)  which is perhaps more sensible ?
12:56:43 <arkeet> why not just map _coddisc?
12:56:46 <dylukes> @hoogle (f a -> f a -> f b) -> (a -> a -> f b)
12:56:47 <lambdabot> No results found
12:57:08 <dylukes> ski i? from your name?
12:57:11 <mmaruseacph2> map _coddisc sounds good
12:57:12 <dylukes> or it?
12:57:22 <dylukes> :\
12:57:32 <dylukes> How does that follow from duplicate?
12:57:54 <dylukes> I'm interested though, I was just in need of something like that.
12:58:01 <ski> dylukes : er, s/ i / it /
12:58:15 <dylukes> Yeah, so I have something like this currently:
12:58:28 <dylukes> condExpr :: TicketId -> TicketColumn -> Column PGBool
12:58:29 <amindfv> ski: right, the open world assumption means that i can't actually be sure, but i'm comfortable saying that the code will have undefined behavior if you create new instances that shouldn't exist
12:58:38 <dylukes> where TicketColumn is Ticket' < a bunch of column types
12:58:39 <dylukes> >*
12:58:42 <prsteele> If I have a function f :: a -> b -> c, where there is an expensive computation involved in the partial application f a, will this expensive computation be repeated many times in map (f a) [b1, b2, b3]?
12:58:44 <muzzle1> hi, can anyone tell me, how long it takes for hackage to build docs for a package that I uploaded ?
12:59:10 <arkeet> prsteele: how is f defined?
12:59:12 <dylukes> So I do: condExpr tid col = unTicketId (col ^. tId) .== (pgInt4 . unTicketId $ tid)
12:59:18 <dylukes> I'd really like to be able to do this "under" the unTicketId
12:59:19 <dylukes> so to speak.
12:59:54 <arkeet> prsteele: if it's something like f a = let {expensive stuff} in \b -> ...
12:59:58 <dylukes> data TicketId' a = TicketId a, type TicketId = TicketId Int, type TicketIdColumn = TicketId (Column PGInt4) 
13:00:01 <arkeet> then expensive stuff will get shared
13:00:32 <arkeet> if it's something like f a b = ... then it won't.
13:00:45 <ski> @type let scaffold :: TicketId' a -> TicketId' (TicketId' a); scaffold = TicketId; (<<=) :: (TicketId' a -> b) -> (TicketId' a -> TicketId' b); wab <<= wa = fmap wab (scaffold wa) in (<<=)
13:00:47 <lambdabot> (TicketId' a -> b) -> TicketId' a -> TicketId' b
13:00:54 <arkeet> because partial applications end up like f a = \b -> f a b
13:01:17 <arkeet> or something
13:01:31 <hunteriam> does anyone here have any experience with the haskell intellij plugin?
13:01:46 <prsteele> arkeet: hm. I guess the answer is 'profile'
13:01:59 <arkeet> Debug.Trace can be useful.
13:02:02 <arkeet> to trace evaluations.
13:02:15 <arkeet> profiling is also useful.
13:02:17 <dylukes> ski but is that legitimately useful here?
13:02:40 <dylukes> ski https://gist.github.com/DylanLukes/1a547cbad3986b1b4130
13:02:45 <dylukes> See the last line.
13:03:01 <ski> prsteele : sometimes one thinks of the evaluation of the partial application as a "compilation" (of the early input) or specialization (of the function to that early input). cf. partial evaluation, program specialization, futamura projections
13:03:05 <dylukes> I'm not very familiar with comonadic isms, so I'm not really sure if it's applicable or meaningful.
13:03:32 <prsteele> it seems that map (f a) [b1, b2] should be no more expensive than [f a b | b <- [b1, b2]]
13:03:33 <arkeet> prsteele: also I don't know if optimizations might affect that behaviour.
13:03:56 <arkeet> it might use more space.
13:04:04 <dylukes> (futurama projections? It'll come back, then get canceled again.)
13:04:35 <eacameron> what's the favorite tool for building C bindings for Haskell these days; I mean calling haskell from C, not the otherway around
13:05:00 <athan> Is there a lifted =<<? Something like `:: (a -> m b) -> t m a -> t m b`?
13:05:27 <mmaruseacph2> @hoogle (a -> m b) -> t m a -> t m b
13:05:29 <dylukes> Does foreign ccall work symettrically? 
13:05:29 <lambdabot> Data.Map.Lazy mapMaybe :: (a -> Maybe b) -> Map k a -> Map k b
13:05:29 <lambdabot> Data.Map.Strict mapMaybe :: (a -> Maybe b) -> Map k a -> Map k b
13:05:29 <lambdabot> Data.Map.Lazy updateMax :: (a -> Maybe a) -> Map k a -> Map k a
13:05:49 <dylukes> symetrically*
13:06:31 <Zemyla> @hoogle HMonad
13:06:32 <lambdabot> No results found
13:07:23 <ski> dylukes : `unTicketId' would be `extract', in comonadic terminology
13:07:31 <haskell387> nvf
13:07:33 <dylukes> Yep.
13:07:41 <arkeet> athan: you can make that using hoist from mmorph
13:07:43 <dylukes> that's why I was wondering if it'd be relevant here.
13:07:47 <dylukes> Ideally it would actually be a newtype.
13:08:11 <arkeet> wait
13:08:15 <arkeet> maybe not.
13:08:19 <johnw> I think he needs liftWith from monad-control
13:08:28 <Fernandos> Can someone help me install two packages? ("bio" and "stylish-haskell") I end up with dependency errors
13:08:33 <dylukes> ski TicketId' can't be a newtype because of makeAdaptorAndInstance being incompatible with them so far.
13:08:35 <dylukes> It's a bug.
13:08:39 <johnw> in order to "drop down" from t m a to m a, then act on it to produce m b, then use restoreT to regain t m b
13:08:39 <dylukes> (as I understand)
13:08:53 <arkeet> johnw: same idea :-)
13:09:00 <johnw> not as hoist...
13:09:09 <arkeet> yeah
13:09:13 <arkeet> not hoist.
13:09:20 <Fernandos> error log: http://lpaste.net/548760687145385984
13:09:25 <dylukes> "Monadic Hoisting => Moist Functors"
13:10:33 <Hafydd> Oh my,
13:10:38 <geekosaur> you have global constraints preventing installation of new versions of packages, which is generally a good idea when using the Platform because newer versions of things will just make ghc all confused
13:11:08 <geekosaur> probably the right thing to do is (at least temporarily) disable those constraint lines in ~/.cabal/config and then install these packages *in a sandbox*
13:11:17 <amindfv> ski: i could use type families to enforce the "there are no instances" rule
13:11:49 <johnw> athan: https://gist.github.com/c04f97bb787cae0c71bf
13:11:56 <johnw> all you need is "lift", actually
13:12:21 <johnw> :t (=<<) . (lift .)
13:12:22 <lambdabot> (Monad m, Monad (t m), MonadTrans t) => (a -> m b) -> t m a -> t m b
13:12:58 <athan> johnw: I had a feeling :)
13:13:13 <athan> or! (=<< .: lift)
13:13:20 <ski> dylukes : i'm not sure if comonads would really help here
13:13:25 <athan> (or .* for the abused syntax already)
13:13:28 <dylukes> I don't think so either ski 
13:13:37 <dylukes> It's clear enough as it is tbh
13:13:56 <dylukes> It would be worthwhile to pull the dependency out on PGS.Connection and produce IO SqlIUpdate anyhow.
13:14:07 <dylukes> That way I can more intelligently batch updates.
13:16:02 <Zemyla> I wish there were a way to prove, like, for a given t, Monad m => Monad (t m).
13:16:23 <arkeet> what do you mean?
13:16:28 <arkeet> monad transformers come with instances like that.
13:17:28 <amindfv> Zemyla: yeah, you can literally write "instance Monad m => Monad (t m) where"
13:17:33 <Fernandos> geekosaur: here's my cabal config, what flag do I need to change http://lpaste.net/3708823569992515584
13:17:37 <arkeet> for specific t, anyway.
13:17:46 <arkeet> e.g. instance Monad m => Monad (MaybeT m) 
13:18:22 <mizu_no_oto> Fernandos: are you using cabal sandboxes?
13:18:25 <geekosaur> hm, there are no constraints defined in there
13:18:36 <geekosaur> do you have a cabal.sandbox.config?
13:18:46 <Fernandos> mizu_no_oto: yes, tried with a sandbox (not empty) and without
13:19:00 <mizu_no_oto> Fernandos: try in a new sandbox
13:22:39 <Fernandos> cabal init && cabal install stylish-haskell appears to be working. 
13:22:47 <Fernandos> do I need a new sandbox for every single package?
13:22:57 <dylukes> ski did you happen to see a better way? Something that avoids unTicketId?
13:23:09 <geekosaur> Fernandos, it's often a good idea
13:23:19 <geekosaur> ghc just gets too confused when it sees multiple versions of packages
13:23:24 <dylukes> I open a new sandbox for any project
13:23:31 <dylukes> and any application/tool I'm using before building it.
13:23:40 <geekosaur> and cabal is fighting an uphill battle to try to avoid the confusion
13:23:44 <geekosaur> and usually fails :/
13:23:50 <dylukes> I keep my top level packages pretty sparse. About all that lives there is alex, happy, base and such
13:24:51 <Fernandos> with best intentions, I really really can't grasp why one would want it's users to create a new sandbox for every new package and fail otherwise miserably with cryptic errors in dependency hell, EXCEPT one hates it's users deperately or wants newcomers to hate haskell with an axe
13:25:45 <geekosaur> performance, basically. code is unusably slow unless stuff gets inlined across modules, which creates hard dependencies
13:25:48 <bergey> Maybe we should make require-sandbox the default.  =) It would improve the error messages, at least.
13:25:48 <dylukes> I mean, really we should have just been sandboxing from the start.
13:25:52 <merijn> Fernandos: I never seem to encounter these errors much, so maybe I'm anomaly. But the reason things sometimes break is because packages don't just depend on their dependencies, but on transitive dependencies
13:25:53 <MP2E> ^
13:25:53 <dylukes> GHC performs static linking.
13:26:08 <geekosaur> you'd never see this kind of thing if you came from e.g. node.js, since nothing is compiled
13:26:11 <dylukes> I'm of the opinion cabal init should have done what cabal sandbox init does.
13:26:18 <dylukes> geekosaur uh
13:26:25 <dylukes> npm does the exact same thing...
13:26:25 <geekosaur> C is still fighting with these kinds of issues; pkg-config helps but not much
13:26:39 <dylukes> actually, it's a bit more sane convention wise, since --global is NOT the default.
13:26:45 <merijn> Fernandos: GHC until recently did not have the ability to link multiple versions of the same library, which means it's hard to find a sane configuration for packages with 100s of dependencies
13:26:45 <geekosaur> npm still has the easier job
13:26:53 <Fernandos> even though haskell is ghc, but cabal is at fault. npm/easy_install/pip/cask/aptitude/apt-get/ebuild/emerge/equo/pacman/yum/rpm/dpkg/nuget and every other package manager is technically maybe inferior, but just works.
13:27:03 <dylukes> I would rather: `cabal sandbox init && cabal init => cabal init` `cabal init ==> cabal init --no-sandbox` 
13:27:33 <merijn> Fernandos: The problem is that cabal hasn't been updated to use the multi package feature of GHC because it's unclear what the UI should look like
13:27:35 <lrocksmashtime> recent survey by FP complete showed that cabal is clearly the single biggest pain point
13:27:46 <dylukes> They needed a poll to figure that out??
13:27:48 <geekosaur> nobody here has tried to use ghc without cabal
13:27:48 <Fernandos> merijn: what about doing it the unix (BSD) way? I mean portage does just package all deps into one big tarball and unpacks it
13:27:52 <geekosaur> ok, it's all cabal's fault.
13:27:54 <lrocksmashtime> ha
13:27:54 <Fernandos> good enough for me =)
13:27:55 <bergey> Doesn't "just works" in this case mean "defers errors to runtime", so the onus is on library authors never to change their data types?
13:27:57 <dylukes> geekosaur it's not cabals fault haha
13:28:00 <merijn> Fernandos: Then look at stackage
13:28:01 <dylukes> it's mostly ghc-pkg that's obnoxious
13:28:16 <dylukes> mainly because ghc-pkg/cabal are NOT a package manager.
13:28:25 <merijn> Fernandos: Stackage does exactly that, fix a complete set of dependencies that works
13:28:37 <merijn> Fernandos: But then people complain "but now I can't use the bleeding edge version!!"
13:28:54 <arkeet> doesn't nix try to do something about that
13:28:59 <merijn> Fernandos: The reason apt-get works is because they have hundreds (thousands?) of volunteers managing the packaging/dependencies
13:29:03 <geekosaur> (perhaps the worst part. when it's ghc that trips over it directly the error messages can be completely incomprehensible. cabal at least tells you what's wrong)
13:29:32 <merijn> cabal is mostly hacked on by two or three people in their spare time and hackage isn't curated at all
13:29:42 <geekosaur> (we had a case with xmonad where a mismatch between xmonad and xmonad-contrib led to an error message that was more or less 'expected LayoutClass, found LayoutClass'
13:29:49 <Fernandos> lrocksmashtime: I agree :/ I'm learning haskell and my Prof. is astounded by it, even though I fail it at the simplest things :D others wrote ~150 LoC in C#, ~50 in F#, ~30 in Scala and I was there with 5 ~LoC (including imports)
13:29:50 <merijn> tbh, cabal is still by far the best buildtool I've ever had to work with
13:29:55 <geekosaur> no indication whatsoever that they were different)
13:30:32 <merijn> geekosaur: I think that's fixed now, no? GHC should report exact versions it looks for
13:30:52 <Fernandos> merijn: the best build tool I used was mimosa (javascript build tool with configuration wizard), the next best was equo (sabayon linux)
13:31:00 <geekosaur> there were some complications, I think the exact xmonad that xmonad-contrib was linked against had been removed (system package manager) or somehting
13:31:13 <merijn> Fernandos: Except that JS doesn't have build tools because there's nothing to build...
13:31:20 <dylukes> The best build tool I've ever used, hands down the best functionality, ease of setup, etc... is bash.
13:31:22 <geekosaur> andf it *was* a corner case, ghc is usually at least a little better about it
13:31:33 <dylukes> For 99% of projects that aren't huge, a bash+make is generally plenty.
13:31:51 <merijn> Fernandos: Most JS dependency managers basically boil down to "blindly trust version numbers and copy the entire source, if things go wrong you won't notice until runtime so you'll get blamed for a bug"
13:31:52 <dylukes> Javascript people make this mistake a lot... you end up with 300 line grunt/gulp configs
13:32:00 <dylukes> for what really amounts to a basic makefile with error reporting
13:32:09 <dylukes> merijn ^
13:32:13 <Fernandos> merijn: ohh there is my friend ;) compiling from earl-grey to es6 to es5 with polyfills, and compiling from stylus to css with auto-vendor-prefixes and much more like image optimization
13:32:35 <dylukes> Fernandos Where you have all of that...
13:32:59 <Fernandos> dylukes: almost every web project, really. 
13:33:02 <dylukes> Just... browserify <whatever> && scss <whatever> <to whatever else> && cat polyfills/*.js >> bundle.js
13:33:03 <dylukes> like
13:33:04 <dylukes> why
13:33:08 <dylukes> why bother with a build manager
13:33:16 <dylukes> just use a damn script
13:33:19 <dylukes> that's what they're for.
13:33:22 <merijn> Anyway...heading way off topic
13:33:40 <Fernandos> well then use ghc <list of parameters> <list of files> etc. :D
13:34:21 <Fernandos> merijn: indeed, but let me give you merijn a link to: http://breuleux.github.io/earl-grey/ it's really a nice language that compiles to javascript. I mean the syntax is very haskell like
13:34:45 <merijn> If I wanted a haskell-like language to compile to JS I'd just use haskell >.>
13:34:53 <dylukes> Fernandos: the problem with javascript "build tools" is they add unnecessary complexity. You end up having to wait for someone to produce grunt-whatever or gulp-whatever,
13:34:55 <merijn> geekosaur: FWIW there are people who use GHC without cabal
13:35:08 <dylukes> and all they're doing is adapting the API the author of the tool wrote on the command line to work "in JS"
13:35:15 <dylukes> why not just USE THE API THE AUTHOR PROVIDED FOR IT.
13:35:17 <merijn> geekosaur: Standard Chartered (I think? That's where neil works, right?) they use shake for building
13:35:33 <dylukes> NIH syndrome is very endemic in the Node.js community. 
13:35:34 <Fernandos> dylukes: idk. what you mean, but it's okay if you don't like it. I respect your opinion =)
13:35:47 <dylukes> Fernandos Let me put it this way, say you want to use scss.
13:35:52 <dylukes> But you also like grunt.
13:36:03 <merijn> dylukes: I suggest -blah or some other OT channel :)
13:36:08 <dylukes> Good call.
13:36:10 <quchen> merijn: Neil specifically advises against Shake when you don't *need* it. It's a tool for complex build processes. Standard Chartered certainly has one, but it's not like he's advertising it as the tool everyone should use.
13:36:11 <dylukes> Fernandos, to #blah
13:36:16 * geekosaur keeps misreading 'scss' as randomly either 'spss' or 'sccs'
13:36:26 <EvanR> NIH would be bad if the existing stuff didn't suck
13:36:29 <Fernandos> spss is awesome!
13:36:41 <merijn> dylukes: Or #programming, that's where I go when I wanna snark on JS ;)
13:36:42 <merijn> EvanR: Word.
13:36:52 <dylukes> It's not JS itself that's even the problem.
13:37:00 <dylukes> The tool ecosystem is just bizarre.
13:37:05 <quchen> dylukes: This is offtopic, please move the discussion to another channel.
13:37:09 <Fernandos> dylukes: you can pm if you want. I don't know what your concern is, sorry
13:37:24 <dylukes> Anyhow, back to Haskell.
13:37:35 <shapr> Has anyone used one of the Haskell XMPP libs to write an XMPP bot?
13:37:53 <shapr> or more simply, what's the best supported XMPP lib that supports MUCs?
13:38:27 <quchen> merijn: I wonder how long it'll take to move GHC's build system to Shake. I find the current process very hard to understand.
13:38:39 <hiptobecubic> is that the plan?
13:38:49 <quchen> There are efforts to do that, yes.
13:39:14 <quchen> It's not set in stone of course, at the moment it seems more like a practicability study.
13:39:40 <quchen> And because of the complexity of the build system, it seems to be far from trivial to accomplish it.
13:39:46 <Fernandos> geekosaur: sorry I'm a little confused, if I create a sandbox per package (that's what I'll do, because I hope that it just works). How will my editor or ghc know where to find the binaries? hmm are those even binaries or are they just hs files provided by cabal??
13:39:49 <merijn> quchen: Hard to understand as in edit or to build?
13:39:52 <sleblanc> Why do Haskell programs need to link to libffi at runtime?
13:40:11 <quchen> merijn: Both, I'd say.
13:40:12 <Fernandos> sleblanc: hmm good question^^
13:40:27 <merijn> quchen: Building is pretty straight forward no? I didn't really have many issues
13:40:36 <quchen> merijn: I can compile GHC with basic options, sure, but I don't get the impression I know what I'm doing.
13:40:36 <merijn> quchen: I'd agree with the editing part
13:40:44 <geekosaur> Fernandos, if you are using libraries in a given project then they need to be installed in the sandbox for that project. for executables, you can generally just copy them out of the sandbox bin directory to somewhere useful
13:41:02 <quchen> merijn: "Is build.mk the only place where I can edit stuff? What if I want to use some option, where can I do that?"
13:41:04 <merijn> quchen: All I personally needed was a working GHC to verify bugfixes, so I didn't consider this a problem
13:41:30 * geekosaur sometimes just wants a cabal-ish thing that does whole program compilation...
13:41:49 <quchen> merijn: I never had problems with it either, but then maybe I tried my best to avoid situations in which I had to understand something about the build process
13:41:57 <geekosaur> slower, yes, but you don't have these issues if you build the libraries for each program...
13:42:28 <quchen> merijn: The Cabal bootstrapping process is also pretty mysterious to me.
13:42:48 <quchen> And reading a shell script to understand it is not exactly high on my priority list ;-)
13:42:50 <athan> How should I import a module if two dependency packages export it?
13:42:57 <athan> is there a `from` keyword?
13:43:05 <Fernandos> geekosaur: ahhh! now I understand... "more or less". I already did that with ghc-mod and had a bad feeling, like when you do some nasty hack just to get something working. 
13:43:10 <quchen> athan: There's a GHC extension that lets you specify which package to import a module from.
13:43:19 <Fernandos> Is that the normal way to do it?
13:43:19 <quchen> I forgot the name though, but it should be easy to find.
13:43:30 <quchen> PackageImports?
13:43:30 <athan> thanks quchen :)
13:43:32 <geekosaur> sadly, it is a hack. more sadly, it's hard to fix. :/
13:43:35 <Fernandos> serious question :)
13:43:45 <Fernandos> oh, ohhh
13:43:53 <hexagoxel> install executables from sandbox to ~/.cabal via via `cabal install some-executable --bindir=$HOME/.cabal/bin --data-dir=$HOME/.cabal/share`
13:44:07 <hexagoxel> no need to do copying..
13:44:12 <Fernandos> hexagoxel: will that automatically copy the bins to /usr/local/bin ?
13:44:13 <quchen> athan: Yeah, it's -XPackageImports. https://downloads.haskell.org/~ghc/7.0.3/docs/html/users_guide/syntax-extns.html
13:44:28 <hexagoxel> Fernandos: no, to ~/.cabal/bin
13:44:38 <Fernandos> ahh ok, that's already in my path^^ good idea°
13:44:44 <athan> Thanks quchen :)
13:44:46 <hexagoxel> Fernandos: so you will have to modify your PATH exactly once :)
13:45:14 * Fernandos hands hexagoxel the Cabal Hacks Avoidance Engineer Certificate
13:45:39 <Fernandos> That should be the DEFAULT :P
13:46:33 * shapr hops randomly
13:46:40 <shapr> good afternoon?
13:47:23 <Fernandos> I'll make that an alias cabit="cabal install $1 --bindir=$HOME/.cabal/bin --data-dir=$HOME/.cabal/share"
13:49:13 <bitemyapp> shapr: good afternoon :)
13:49:24 <shapr> bitemyapp: how you doin?
13:49:59 <athan> bitemyapp: o/
13:50:42 <bitemyapp> athan: howdy
13:50:47 <bitemyapp> shapr: good, incredibly busy.
13:51:00 <bitemyapp> currently making some code way more detailed.
13:51:13 <shapr> sounds like fun
13:51:23 <Fernandos> this seems to work: function cabbit() { cabal install "$1" --bindir=$HOME/.cabal/bin --datadir=$HOME/.cabal/share }
13:51:33 <Fernandos> in the terminal
13:51:43 <hexagoxel> Fernandos: or automate things further using scripts such as https://github.com/quchen/cabal-install-bin or https://github.com/lspitzner/cabal-exec-install
13:52:11 <Fernandos> hexagoxel: that should be DEFAULT! coool
13:52:43 <Fernandos> hexagoxel: you've no idea how much frustration that just head-sniped!
13:53:21 <hexagoxel> ghc-7.8.4 still is the most reliable bet for many executables btw
13:53:24 * hackagebot derive-enumerable 0.1.0.0 - Generic instances for enumerating complex data types  http://hackage.haskell.org/package/derive-enumerable-0.1.0.0 (mgoszcz2)
13:53:41 <Fernandos> a friend of mine switched to nixos just becaus of cabal
13:54:07 <Fernandos> imho a damn big move, but he made a living with haskell.. 
13:54:26 <quchen> I don't think there's need to configure your OS with Nix if you have Cabal problems.
13:54:29 <Fernandos> hexagoxel: Archlinux thinks that 7.10 should be shipped as default..
13:54:38 <quchen> Installing Nix as a package manager should suffice.
13:55:29 <Fernandos> sometimes I wish I still used gentoo... because of emerge slots. I could have ghc in any version I wanted, but then I remember that cabal was still so damn frustrating to the point for me
13:56:05 <dcoutts> Fernandos: actually that's one of the things that works rather well, the libs for each ghc version are managed completely independently
13:56:09 <Fernandos> I mean in parallel and just switch versions of anything that way, but had to maintain my own repository shortly after (now an official gentoo repository)
13:56:12 <dcoutts> so multiple ghc versions works fine
13:56:14 <hexagoxel> (if you have ghc-7.10 on your system, you can install ghc-7.8.4 from binaries to somewhere in ~, put that in front of PATH (temporarily) and then call the cabal-install-bin or cabal-exec-install scripts.)
13:56:46 <disgrntld> how can I get a functions precedence from ghci?
13:56:47 <hexagoxel> i think i just modified the script to change the PATH at the start for my setup
13:56:50 <Fernandos> hmm... didn't know that.. but you can do that with php, nodejs, java, scala, perl, python etc. on gentoo
13:58:04 <disgrntld> anyone? I tried `:t union`
13:58:20 <prsteele> disgrntld: :i 
13:58:27 <disgrntld> thanks, prsteele!
13:58:28 <merijn> dcoutts: The ease with which user local installs work with GHC and cabal and managing multiple versions is something I appreciate more and more each day...
13:58:47 <prsteele> disgrntld: thank KaneTW, he answered that for me earlier
13:59:14 <disgrntld> rgrgr :D, thanks KaneTW!
14:00:04 <quchen> hexagoxel: You can also supply cabal(-install-bin) with a --with-compiler flag
14:00:14 <quchen> (Or similar, I'm not good at remembering flags)
14:01:35 <camlorn> So. I've got an odd one.  Do we have a cross-platform package for loading dlls or shared objects or whatever the equivalent is on whatever platforms Haskell runs on?
14:02:20 <merijn> camlorn: I doubt it, because the difference between loading windows DLL and dynamic libraries are pretty big, afaik
14:02:33 <merijn> camlorn: I'm not sure to what extent it makes sense to have a unified interface for them
14:02:57 <camlorn> merijn:  It does for at least Windows, Unix, and Mac.
14:03:20 <camlorn> merijn:  All three of those have functions that take a path and load the shared object, and all three have functions that take a symbol name and return its address.
14:04:29 <camlorn> merijn:  But I don't want to be argumentative, I just happen to really care  about windows, and building and installing external dependencies that can link with haskell's FFI and which must also be built with VS looks like a very involved thing to ask people to do.
14:06:21 <hexagoxel> quchen: ah, damn, cabal-install-bin supports that? i need to update my script :p
14:06:31 <camlorn> merijn:  And the Python solution--you just have a cross-platform thing that loads shared objects--is a good fit for my use case.  I'm open to alternative thoughts though
14:06:35 <quchen> hexagoxel: It simply passes all flags on to Cabal
14:06:48 <hexagoxel> quchen: there is one argument for modifying the path: you can inspect the sandbox database
14:06:51 <quchen> Basically "cabal <super cool flags> -- $rest"
14:06:55 <merijn> camlorn: There's a Windows Task Force for GHC development, maybe they can help you figure out a good way to do it
14:07:21 <camlorn> merijn:  I assume this is a mailing list?
14:07:24 <merijn> camlorn: In general the windows side of things doesn't get a lot of love, because there's almost no volunteers, so I'm unsure about the state of things
14:07:25 <hexagoxel> because `cabal exec` or `cabal sandbox hc-pkg` don't support --with-compiler, for some damned reason
14:08:06 <merijn> camlorn: There's the #ghc channel here on freenode and ghc-devs, glasgow-haskell-users and haskell-cafe mailing lists, those seem like reasonable avenues for these type of questions
14:08:16 <hexagoxel> (but well, that is not strictly necessary just for installing packages, so ignore the argument :)
14:08:30 <merijn> camlorn: In general the number of windows experts on here is fairly, if not zero and the mailing lists will have a better shot at reaching them
14:08:59 <camlorn> merijn:  Yeah, I'm usually the odd one out.  It's better with Python, but unless you're on the VS stack, Windows never does get love.
14:09:34 <camlorn> merijn:  I'll be honest, though. This will probably just end with me writing said package.  It works for Python, and GHC already has the functions built in.
14:09:44 <merijn> I think there's plenty of people using windows (especially beginners), just not enough volunteers
14:09:57 <camlorn> heh, don't look at me for that.
14:10:05 <merijn> ;)
14:10:38 <camlorn> I will confess right now that I'm beyond intermediate with programming, but I'm at that point where I have the 2000 foot picture of Haskell, I probably can't touch anything actually important anytime soon
14:10:59 <merijn> You'd be surprised :)
14:11:06 <camlorn> The way I'm learning it is conceptual first, which is either very odd or very common, I don't know enough haskell people to know
14:11:32 <camlorn> I'm at the point where I know enough about what is going on that I know the 5 or 6 steps needed to bind something like this, but I'll be looking up syntax for a while.
14:13:11 <Eduard_Munteanu> There's https://hackage.haskell.org/package/plugins but it doesn't seem to support Windows.
14:15:34 <camlorn> Mmm. This may involve unsafePerformIO actually.  Or learning. Learning is good.
14:21:11 <StrangeLoop> http://lpaste.net/133453 <-- can anyone help me understand why the output of this code is an empty list, and not the ('b',"bc")?
14:22:25 <StrangeLoop> I don't understand why the failure in line 53 should have any effect on the value of v, if I remove it I get the expected string
14:25:05 <ski> StrangeLoop : many'  will always fail
14:25:26 <ski> > concatMap (\_ -> []) [0,1,2]  -- yields the empty list
14:25:29 <lambdabot>  []
14:26:15 <StrangeLoop> I am trying to write a parser which gets a parser and runs it one or more times
14:26:52 <StrangeLoop> Wait, I'll paste how I was trying to do it
14:27:28 <StrangeLoop> http://lpaste.net/133453
14:27:30 <ski> StrangeLoop : btw, i would probably replace `parse m s' in the definition of `run m s' by `[res | (res,"") <- parse m s]' (also replacing the later pattern `[(res,[])]' by `[res]')
14:27:44 <StrangeLoop> Pretty much the same accept lines 50-51
14:28:26 * hackagebot eddie 1.0.0 - Command line file filtering with haskell  http://hackage.haskell.org/package/eddie-1.0.0 (MikeMeyer)
14:28:47 <ski> StrangeLoop : yes. but you're still missing the choice in the definition of  many'
14:28:57 <StrangeLoop> Choice?
14:29:06 <ski> yes, your `(|||)' thing, e.g.
14:29:27 <athan> Ugh. I'm trying to turn a list of tokens into an AST and I keep banging my head on a wall. Is there a way to do this in a linear fold, for matching brackets / parenthesis? I'm about to do something terrible to accomplish this :\... moving from the back to the front to match outer brackets at the same time ._.
14:29:32 <athan> I am lost! D:
14:29:53 <StrangeLoop> ski: Could you elaborate?
14:30:37 <ski> StrangeLoop : first use the parser `p' once. then *try* to use it many times, but if it fails, succeed with what you've got (instead of failing, which is the default)
14:30:58 <ski> athan : make a parser ?
14:31:05 <StrangeLoop> OK, I'll try to try I guess
14:31:45 <ski> `p ||| q' first tries `p'. if it fails (no possible parse result(s)), then it tries `q' (and if that fails, the whole choice parser `p ||| q' fails)
14:32:23 <ski> athan : i suppose you could try to count nesting level or something ..
14:32:27 <athan> ski: That's what I'm trying to do ._.
14:32:39 <athan> ski: I have a list of tokens, I'm that far already
14:32:55 * ski doesn't see what problem athan is running into
14:32:59 <athan> I just can't wrap my head around making the nesting. Maybe I should have state?
14:33:18 <slack1256> On Network.Socket.ByteString.Lazy the getContents function should have the same problems than lazyio right?
14:33:30 <athan> ski: I don't know how I can "capture" tokens from a left paren to the right paren :\
14:33:46 <ski> athan : do you know about parsing combinators (including monadic, or applicative, ones) ?
14:34:20 <athan> I keep thinking maybe `[Tokens] -> ([Tokens], [Tokens])` would be a good design, so I can have an accumulator on the left, and the "rest" on the right
14:34:38 <athan> ski: Yes, but this is a complicated parser - I don't want whitespace affecting the rest already functioning
14:34:50 <ski> athan : why not something more like `[Token] -> (AST,[Token])' ?
14:35:17 <athan> ski That's basically what I have (I have a `TGroup :: [Token] -> Token` element)
14:35:30 <ski> (do you need to "\"capture\" tokens from a left paren to the right paren" ?)
14:35:49 <athan> Not as raw text, no. They're already tokens
14:35:57 <athan> I'm just not sure how I should fold over the list
14:36:06 <ski> (forget about raw text)
14:36:07 <athan> I was thinking about having a "depth" state, as an Int
14:36:29 <pavonia> You could also use a stack for the several levels of nesting
14:36:43 <athan> hmm
14:37:10 * ski thinks pavonia probably means "use recursion" by "use a stack"
14:37:30 <athan> that's what I think I need, but I don't know how to delimit the recursion correctly
14:37:33 <pavonia> I actually mean a stack
14:37:37 <ski> ok
14:37:42 <athan> s.t. I would get something like (Ast, [Token])
14:37:48 <pavonia> You need recursion anyway, don't you?
14:37:56 <ski> probably
14:38:01 <athan> I think it's necessary pavonia
14:39:16 <ski> (i think it may be hard to give more/better advice, without seeing more specifics .. and getting more clearly what you want to achieve)
14:39:42 <pavonia> But a (Parsec) parser with custom tokens is probably the ersier solution
14:39:44 <athan> I _may_ have figured it out actually, thank you ski. I'll be sure to bug you if I didn't though :)
14:39:47 <athan> thanks!!
14:48:25 <Pamelloes> What are some good resources on GADTs? I understand what they mean when I see them, but I don't quite understand them well enough to write my own.
14:50:16 <bitemyapp> \e -> fail ("" ++ show e)
14:50:18 <bitemyapp> @pl \e -> fail ("" ++ show e)
14:50:18 <lambdabot> fail . ([] ++) . show
14:50:58 <pdxleif> Hmm... Data.Binary uses accursedUnutterablePerformIO
14:51:10 <redneb> I posted a message to haskell-cafe a few hours ago but it has not appeared yet
14:51:23 <pavonia> bitemyapp: What's the point of prepending an empty string?
14:51:25 <redneb> is there a spam filter being used?
14:51:52 <Pamelloes> pdxleif: Is that like unsafePerformIO, but actually launches the missiles?
14:51:57 <redneb> this has never happened before
14:53:18 <pdxleif> Pamelloes: https://github.com/haskell/bytestring/blob/2530b1c28f15d0f320a84701bf507d5650de6098/Data/ByteString/Internal.hs#L599
14:54:33 <merijn> Pamelloes: I'm not sure what you mean by "I don't quite understand them well enough to write my own"?
14:54:50 <merijn> Pamelloes: I don't see how you can understand what GADTs mean without knowing how to write them?
14:55:02 <Pamelloes> pdxleif: You weren't joking, that's amazing.
14:55:36 <Pamelloes> merijn: I sort of understand, so I can use existing GADTs in my code, but I don't really understand what's going on under the hood
14:56:01 <merijn> Pamelloes: "under the hood" where?
14:57:12 <Fernandos> What does "pointfree mode" mean?
14:57:14 <Pamelloes> merijn: I don't know. I really don't understand what a GADT does. I know how to look at one and read the type signature and then apply it. But I don't know how to use a GADT within my own code
14:57:22 <Fernandos> there is also "pointful"
14:57:46 <merijn> Pamelloes: https://en.wikibooks.org/wiki/Haskell/GADT
14:57:55 <merijn> Fernandos: It's a term that comes from topology
14:58:16 <merijn> Fernandos: In functions like "f x = x" ther variable name 'x' is a point
14:58:25 <ski> perhaps Pamelloes means that they don't think they can recognize situations in which GADTs might be appropriate/useful
14:58:29 <merijn> Fernandos: Therefore 'pointfree' means without variable names
14:58:48 <Fernandos> ugh.. how is that even possible to express a function without variables?
14:59:04 <Fernandos> I mean inner (local) variables
14:59:05 <merijn> Fernandos: Using composition?
14:59:14 <merijn> "foo = f . g . h"
14:59:34 <ski> Fernandos : `\xs -> map (\x -> x ^ 2) (reverse xs)' is pointful, `map (^ 2) . reverse' is pointless (aka pointfree)
14:59:38 <merijn> "sum = foldl' (+) 0" <- no variable names
14:59:44 <merijn> :t foldl' (+) 0
14:59:45 <Fernandos> let's say sum a b = a+b, how do you "curry" that?
14:59:46 <lambdabot> (Num b, Foldable t) => t b -> b
14:59:55 <Fernandos> oh you read my mind.. 
14:59:56 <ski> Fernandos : `sum = (+)' ?
14:59:56 <ronh-> sum = (+)
14:59:58 <merijn> Fernandos: "sum = (+)" ?
15:00:07 <merijn> > let sum = (+) in sum 1 2
15:00:08 <lambdabot>  3
15:00:33 <merijn> Fernandos: Pointfreeness and currying are orthogonal things, though
15:04:03 <Fernandos> merijn: so this poor guy looked for a way to curry, when I he asked for overloading juxtapositioning?
15:04:05 <Fernandos> http://stackoverflow.com/questions/27754902/is-there-a-way-to-overload-juxtaposition-in-ghc
15:05:23 <merijn> Fernandos: That's a confused question
15:05:37 <merijn> He wants to "overload" space, but that's not really something sensible in haskell
15:05:52 <f|`-`|f_> overload space?
15:05:56 <Fernandos> ah ok
15:06:47 <Fernandos> f|`-`|f_: juxtaposition means expressing a*b using ab
15:06:47 <merijn> f|`-`|f_: Treat the space in "f x" as an operator and then redefine it
15:06:48 <merijn> IMO an awful idea
15:07:14 <rien> yeah it's enough to redefine semicolon amirite ;)
15:07:15 <f|`-`|f_> hmmm
15:07:31 <f|`-`|f_> no spaces
15:08:36 <merijn> rien: Semi colons aren't overloaded
15:08:51 <rien> merijn: I was talking about monads
15:09:13 <rien> how they're alluded to be "semicolon overloading" anyway my joke was lost :)
15:10:18 <merijn> I know the analogy, I just think it's a bad one and would wish it goes away
15:14:33 <ronh-> why? monad instance "overloads" what "do x; y" means.
15:15:00 <rien> merijn: it's not a bad analogy. why do you say it is?
15:15:44 <Fernandos> I still can't install bio and receive this error when using cabal-install-bin from https://github.com/quchen/cabal-install-bin : http://lpaste.net/7850107972544888832
15:16:23 <merijn> ronh-: If monad instances "overload" it, then what does "x; y" mean without a monad instance
15:16:35 <rien> merijn: that's meaningless
15:16:46 <rien> merijn: bind is what defines a monad
15:16:52 <merijn> ronh-: Because semicolons in do notation are a mere artifact of the syntactic sugar and semicolons are (well, can be) used in lots of places
15:16:54 <rien> so bind means nothing without one.
15:16:56 <hpc> rien: also at this level of abstraction, bad analogies don't have easy "it's like this, except in these ways"
15:17:07 <merijn> rien: ; is not bind
15:17:16 <rien> merijn: what is it then?
15:17:46 <hpc> it's syntactic sugar
15:17:51 <hpc> look at how do notation is translated
15:18:11 <merijn> rien: "do { let x = 1; return x }" <- this expression has no bind, but has a semicolon
15:18:19 <merijn> @undo do { let x = 1; return x }
15:18:19 <lambdabot> <unknown>.hs: 1: 26:Parse error: }
15:18:24 <merijn> @undo do { let x = 1; return x; }
15:18:24 <lambdabot> <unknown>.hs: 1: 25:Parse error: ;
15:18:30 <merijn> heh?
15:18:43 <ronh-> merijn, that analogy presumably refers only to semicolons in the do notation
15:18:44 <hpc> @undo do { let {x = 1}; return x; }
15:18:45 <lambdabot> let { x = 1} in return x
15:18:51 <rien> isn't ; a thing that says "I'm done with my last command. I want to do the next command inside the context of having done all previous contexts" (in other words, ; sees the scope before it, as bind optionally can inspect all previous steps).
15:18:53 <merijn> hpc: Oh, right
15:19:04 <merijn> ronh-: Except that I just showed you a use of ; in do notation that is not bind
15:19:16 <merijn> rien: No
15:19:26 <rien> merijn: I see where we diverge now. I'm not talking about haskell's ;
15:19:36 <merijn> rien: There is a completely mechanical and fairly simple translation of do notation
15:19:43 <rien> merijn: I'm aware
15:19:49 <rien> it uses bind
15:19:53 <merijn> rien: Then what ";" are we talking about
15:20:07 <merijn> rien: Sometimes, it doesn't in the case just shown
15:20:15 <rien> merijn: see my "a thing that says" message above
15:20:36 <rien> in normal vanilla algol languages a semicolon says that the next command will be able to see the scope left by the previous ones
15:20:56 <rien> as opposed to END which stops seeing previous scopes (different stack frames etc)
15:21:13 <ronh-> merijn, that analogy presumably refers only to semicolons in the do notation, excluding let bindings. :P
15:21:24 <rien> we can choose a way to phrase this so that the semicolon is still a nice analogy to explain to newcomers. I don't see the need to destroy this helpful analogy. that's all I'm saying.
15:21:36 <merijn> rien:  We were talking specifically about overloading in haskell, then you referred to "; is already overloaded" at which point assuming everyone else to think of ';' from algol seems odd
15:22:02 <rien> merijn: my fault, but we were talking about metaphors so I thought about teaching
15:22:08 <ronh-> anyway, I think "overloaded semicolons" analogy can give a (somewhat vague, granted) idea of what monads are about. no need to dissect it that much
15:22:09 <merijn> rien: I make it a point not to teach do notation to people until after they can write code using >> and >>= so we'll have to disagree
15:22:09 <rien> we usually teach haskell to algol minded folks
15:22:11 <Fernandos> Why do you I receive dependency errors when there are no haskell packages installed?? I've removed all haskell packages and wanted to install those I need using cabal sandboxes
15:22:46 <merijn> Fernandos: Incorrect dependency bounds on the package you're trying to use?
15:23:06 <rien> ronh-: I wasn't dissecting. My point is I can use just that analogy to explain the concept of a monad to a beginner.
15:23:15 <Fernandos> this is the error I receive: http://lpaste.net/7850107972544888832
15:23:34 <rien> so to say it's bad and wish it would go away is to take the rungs of the ladder with you
15:23:53 <hpc> rien: it leaves the beginner with major misconceptions about the nature of Monad
15:23:58 <ronh-> rien that was meant for merijn. I think we agree on this
15:24:05 <merijn> Fernandos: You're trying to install something with ancient dependency bounds
15:24:34 <merijn> Fernandos: So I'd assume the package is dead
15:24:53 <rien> hpc: perhaps in the way you are explaining it. but I see the resistance towards my explanation so I'll stop. but the way I've explained it to people did not leave gaps.
15:25:09 <merijn> Fernandos: It's demanding "binary>=0.4 && <0.5" and then craps out because those versions of binary depend on "base>=2.0"
15:25:16 <Fernandos> merijn: all I wanted to do is read a *.fasta file and process it, I've heard that this is the right package
15:25:20 <merijn> Fernandos: base 2.* is ancient
15:26:16 <rien> hpc: I don't mean to be harsh at all. but one's conception of the semicolon analogy does not mean everyone sees it and explains it the same.
15:26:23 <merijn> Fernandos: You'd have to fix the bio package
15:26:33 <rien> hpc: I think people lose track of that when condemning analogies
15:27:04 <merijn> rien: I doubt that it did not leave gaps, for example, the list monad is hardly explainable in a sensible way using this analogy
15:27:10 <Fernandos> merijn: thank you! I was thinking that it was my fault =)
15:27:16 <hpc> rien: it's entirely possible for someone to see the analogy and figure it out just from that, yes
15:27:35 <hpc> rien: but as you say, it's targeted to people already familiar with semicolon in other languages
15:27:43 <hpc> which carries a lot of conceptual baggage with it
15:27:51 <rien> hpc: yes that's what I mean :) thank you. and to deprive people of an analogy that has worked for so many is selfish.
15:28:01 <hpc> and the beginner has to happen to figure out EXACTLY which baggage to discard
15:28:16 <merijn> Fernandos: If you're lucky you only need to change the dependency bound on binary to a newer version, but if you're unlucky...
15:28:30 * hackagebot b9 0.5.5 - A tool and library for building virtual machine images.  http://hackage.haskell.org/package/b9-0.5.5 (SvenHeyll)
15:28:33 <hpc> do-notation in haskell is so wildly different from traditional languages that you have to throw out pretty much every preconception
15:28:48 <hpc> you really do just have to start from the definitions
15:28:49 <rien> merijn: do you think the analogy can't be stretched to explain lists?
15:29:29 <merijn> Not without incurring more intermediate confusion
15:29:35 <rien> hpc: or we tell the beginner which packages to discard.
15:29:51 <merijn> But anyway, like I said I believe teaching do-notation in the beginning is a mistake anyway
15:30:06 <rien> hpc: if we say a semicolon from algol has several aspects (sequencing, carrying context, etc) and then we say that monads sheds or changes some of those aspects and we specify how then we've explained it.
15:30:09 <merijn> I recommend avoiding do-notation until you are comfortable writing without it
15:30:13 <rien> hpc: because we've mapped one concept to the other
15:30:25 <hpc> rien: do-notation does none of those things
15:30:31 <hpc> it's a direct translation to (>>=)
15:30:41 <Fernandos> it's ok I don't need to rely on THAT library, but any lib that helps me parse a "*.fasta" file. I've found one, but no documentation, not even a bit and I'm new.. :/
15:30:46 <hpc> which may or may not do some or all of those things for any given instance of Monad
15:31:37 <rien> merijn: we'll agree to disagree then. I think making a mystery out of a feature tells beginners that what they're using is magical. I'd rather lay in the open all the transformations so they can always find themselves and go back and forth.
15:32:37 <hpc> you have it backwards
15:32:38 <merijn> rien: I'm not saying "making a mystery of the feature", I'm saying the exact opposite. First avoid do-notation and write using explicit >> and >>=, then once you're comfortable with that, learn the desugaring rules and start using do-notation
15:32:41 <rien> hpc: do notation sequences the lines so they happen after each other. any line in a do block can refer to lets in that block. seems to me it does both those things I said.
15:32:47 <hpc> when you say "do-notation is like algol", there's no why to it
15:32:49 <hpc> it's just magic
15:32:56 <Fernandos> how do I use this http://hackage.haskell.org/package/BiobaseFasta
15:33:01 <hpc> if you start from definitions, it's mechanical and makes perfect sense
15:33:13 <merijn> rien: Except, if it sequences how does the do notation for reverse state work?
15:33:33 <rien> hpc: it's convention, people chose it. magic is what Rails does behind your back that no one told you about.
15:33:45 <rien> do is not magic, just convention.
15:34:09 <hpc> conventions don't constitute how a thing works
15:34:10 <Fernandos> oh there seem to be more packages listed in hackage than with cabal list
15:34:10 <merijn> Anyway, bedtime for me
15:34:11 <rien> merijn: with continuations I assume
15:34:32 <hpc> conventions are just the "what"
15:34:36 <merijn> rien: I mean "how does the analogy work" if it does the exact opposite of what you said
15:34:46 <hpc> and is what leads to things like hungarian notation being so grossly misunderstood
15:34:51 <merijn> i.e. "; sequencing before and after"
15:35:02 <rien> merijn: because you're sequencing calls to continuations
15:35:12 <merijn> hpc: *mumble**mumble*systems vs apps hungarian *mumble*
15:35:21 <hpc> why was the original convention chosen? "that's how it always was" doesn't impart understanding
15:35:30 <rien> merijn: pretend we're drawing this stuff as I'm explaining it. you think beginners get lost in these adjustments to metaphors but they really don't if you're both at a whiteboard.
15:35:33 <hpc> it says "stop learning and just do"
15:36:05 <rien> so if they asked me about some reverse state monad I'd make sure to point out that what they are sequencing in that case is calls to continuations
15:36:13 <merijn> rien: I've TAed functional programming 3 years in a row, I have quite some experience with where beginners get lost
15:36:32 <merijn> But anyway, it's time for bed, like I said! Later!
15:36:54 <rien> merijn: but your way of explaining isn't the only one. so your experience is with beginners getting lost in your explanations. no offense, just clarifying
15:37:02 <rien> later!
15:38:14 <Fernandos> packages that don't compile with the current ghc version should be hidden or removed from hackage and cabal imho. so I don't waste time encountering the same error as there seems to be a package test tool in hackage
15:38:24 <rien> hpc: the understanding comes from showing the equivalence, not explaining the reasons why people chose the convention
15:38:38 <Fernandos> would remove a lot of frustration, cpu time and time wasted
15:38:57 <enthropy> not all people use 7.10 (which is current now?)
15:39:22 <Fernandos> well ok even for 7.6 would be okay, if I could only show packages that build sucessfully
15:39:23 <kadoban> Fernandos: Use stackage.
15:39:31 <hpc> rien: it's not understanding
15:39:36 <Fernandos> kadoban: I did. Same error.
15:40:12 <rien> hpc: knowing how to use do notation and >>= and how to translate between the two at will is not understanding of what? monads? yes, it's not. it's understanding the equivalence of the syntaxes.
15:40:18 <Fernandos> for someone who just started using cabal, that's a lot of stuff that's been tried out, anyone I know would've already given up I can assure that
15:40:18 <michaelt> Fernandos: what was the package?
15:40:41 <Fernandos> oh I tried many that listed in hackage for the search term "fasta".
15:40:51 <hpc> rien: that's not what you were talking about, you were talking about equating do-notation to algol
15:41:03 <ski> merijn : i'm comfortable saying `(>>=)' (and `join') (for any monad) effects sequencing. (this sequencing has nothing to do with evaluation order). of course, this notion of "sequencing" probably doesn't correspond that closely to the notion of "sequencing" familiar to someone used to an Algol-like language. (e.g. consider the list monad)
15:41:25 <Fernandos> I wanted to parse fasta files, the little function I have already shows repeats and k-mers of RNA sequences (I don't do bioscience, that was just a challenge..)
15:41:57 <rien> hpc: actually I never mentioned do notation, merijn kept bringing that up. 
15:42:23 <kadoban> Fernandos: I have no idea what that is. I see bio-fasta in stackage, which means you're guaranteed to be able to build it, unless your setup is screwed up.
15:42:26 <rien> hpc: I did say in do notation the lines come one after another and that's the meaning it imparts, though.
15:42:27 <Fernandos> but I had to copy the whole 99KB file's content and remove newlines from the it into the haskell file
15:42:46 <Fernandos> bio-fasta? let me tried that
15:42:52 <kadoban> er biofasta, no hyphen I guess.
15:43:13 <rien> hpc: to say reverse state monads or whatever does away with the sequencing aspect is to confuse the calls being made by the lines you're writing with the calls made by the continuations that those calls make.
15:43:31 * hackagebot haskellscript 0.2.2 - Command line tool for running Haskell scripts with a hashbang.  http://hackage.haskell.org/package/haskellscript-0.2.2 (seanparsons)
15:44:08 <hpc> so you have to explain that
15:44:17 <hpc> and it's this whole other layer of specialness
15:44:22 <rien> hpc: yes of course. it's through explaining all the dark corners that you shed light everywhere
15:44:29 <rien> it all fits in a whiteboard
15:44:33 <hpc> and the beginner still has to make the logical leap from what you say to how it really works
15:44:56 <rien> hpc: not if I give them examples of the same thing implemented in both haskell and algol or other comparisons
15:44:59 <hpc> because you still haven't given the definition
15:45:13 <Fernandos> algol..whoa military contractor?
15:45:19 <rien> hpc: I can give the operational definition without giving the denotational definition
15:45:54 <michaelt> Fernandos: the one called `fasta` looks like it disallows the most recent lens. It should install with "cabal install --allow-newer"
15:46:38 <Fernandos> thank you michaelt
15:46:39 <rien> hpc: when I say to a beginner that do notation imparts sequence I make sure to say that the sequence will be walked and any element in that sequence can choose to jump to another element.
15:46:48 <Fernandos> I heard from an official rep. that the german BND also uses Haskell fyi ^^ but even though he noted that his employee loves it, he hates it and favors java where people can "show results faster" (his words not mine)
15:46:59 <rien> so they don't think that the lines will necessarily be executed in that order or at all
15:47:12 <hpc> rien: now you have to explain how you walk the sequence, what an element in the sequence is
15:47:22 <hpc> why they would jump between each other, what the rules for that are
15:47:42 <Fernandos> kadoban: biofasta worked, I tried other packages, but not all
15:47:49 <hpc> and what mechanism lets all this stuff all happen within any rules at all
15:48:06 <rien> hpc: yes and I compare it to the instruction pointer and so on, yep you gotta do all of that, there's no shortcut to teaching.
15:48:21 <kadoban> Fernandos: I always check stackage first, personally. Only if there's nothing in it do I even bother with hackage.
15:48:33 <rien> unless you cut it short and leave people to "figure it out"
15:48:35 <Fernandos> kadoban: the bad thing is that his homepage is gone.. I don't know where to find documentation
15:48:56 <hpc> or you use the definition and never go down the rabbit hole of tangents
15:49:04 <Fernandos> kadoban: wait... wait.. do you mean the same as I do? I thought you mean the  "stk" tool
15:49:06 <michaelt> Fernandos: the one called  biobasefasta should work with `allow-newer`  It is a bit out of date.  The other one `fasta` is being worked on now, I think he just didn't notice the new lens
15:49:17 * ski would simply say that the "items" in the sequence are ordered, in the same sense the elements in a list (or a sequence of elements combined using a monoid) are
15:49:23 <rien> hpc: but beginners don't understand the definition, you and I know that, which is why there are so many frustrated attempts at explaining monads.
15:49:25 <hpc> you really don't get just the mangitude of your overcomplication
15:49:54 <hpc> they do understand the definition when it's unembelished
15:49:55 <rien> hpc: my explanation is not suited to IRC, it's for a whiteboard where I can draw.
15:50:03 <ski> (that in some cases the ordering doesn't matter is no stranger than some monoids being abelian/commutative)
15:50:19 <Fernandos> rien: you can take a photo and upload that to imgur.com :)
15:50:24 <kadoban> Fernandos: http://www.stackage.org/ and yes the stk/stackage CLI tool integrates with their stuff generally AFAIK
15:50:37 <michaelt> Fernandos: certainly anything that hasn't been updated in the last year isn't going to work without --allow-newer or hacking the xyz.cabal file.
15:51:08 <rien> Fernandos: hahaha I'll have to get really fast with that whole erasing and fixing things part
15:51:30 <Fernandos> michaelt is there no "cleanup very old/broken packages" or "only packages that build are published" policy?
15:51:34 <Cale> rien: The best thing for beginners to do in order to understand the monad abstraction is just to understand lots of examples.
15:52:17 <rien> Cale: yes, including the same examples written with different notations, in different languages, etc. I'll show you an example I've used, hold on
15:52:32 <michaelt> Fernandos: no, that isn't the kind of thing it is. It's more like a library of every Haskell module ever written.
15:52:45 <michaelt> Fernandos: well, that's an exaggeration of course
15:52:46 <Cale> rien: It's pretty ugly doing a decent job of implementing the monad abstraction in any language without type classes.
15:52:46 <Fernandos> rien: it was just meant to help you both communicate, I'm afraid I won't grasp the science you're drawing on your board. Just about to finish my msc. degree...
15:52:59 <rien> Cale: https://gist.github.com/canpeter/d8d92659d9b0b5ab26ba
15:53:18 <rien> Cale: maybe in ruby from scratch used in a useful way. that clicks.
15:53:41 <rien> Cale: yes it's ugly and our job if we want to teach
15:53:42 <michaelt> Fernandos: there can't be cleanup of old packages except by removal. Stackage fits your model better, and actually works. 
15:54:30 <Fernandos> michael I mean hiding the webresults should be possible for the cli-tools and for web-results. A flag in cabal etc. like --show-experimental would do it
15:54:59 <rien> Cale: honestly how ugly is that? :P
15:55:00 <rien> 1-10
15:55:04 <Cale> Well, implementing Maybe might not be so bad in other languages, but at least that version won't really get you much closer to understanding the value of the monad abstraction.
15:55:05 <Fernandos> idk. why experimental/dead packages should be listed with stable and maintained packages
15:55:27 <rien> Cale: no? but I just used it in a useful example of accessing JSON fields that might not be there
15:55:27 <Cale> That's not the ugly version, it's the "didn't apply the monad abstraction" version
15:55:41 <michaelt> Fernandos: also, if you first do cabal install whatever --dry you will find out if the thing is no good pretty readily
15:55:56 <rien> Cale: I don't follow.
15:56:03 <Cale> You're not really using monads until you can write a sequence function which will work with an arbitrary choice of monad.
15:56:06 <Cale> :t sequence
15:56:08 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
15:56:17 <Cale> Ignore Traversable
15:56:19 <rien> Cale: does that not implement the maybe monad and use if usefully in an example?
15:56:39 <michaelt> Fernandos: also, if you install the things you want to use for a project in a sandbox, you are less likely to have trouble
15:56:39 <rien> Cale: I'm not using "monads" I'm using *one* monad. one at a time so people can understand.
15:56:42 <Fernandos> michael after day, yes :) I'm quite new to the haskell world
15:56:55 <Cale> It implements Maybe (presumably, my ruby is somewhat poor) and some operations on it, including the operations which would be required to make Maybe a monad.
15:57:15 <rien> Cale: then it uses it in a real world useful example?
15:57:15 <Cale> But if you go along this path, you'll be unable to write any code which will work in an arbitrary monad
15:57:28 <Fernandos> michael I think hexagoxel recommended me to use https://github.com/quchen/cabal-install-bin because I was anyway going to write a little shell script similar but inferior to that
15:57:30 <Cale> and so the whole point of talking about monads at all is moot
15:57:36 <rien> Cale: no one is going to use this code. this is for explaining. that's what we were talking about.
15:57:55 <ReinH> rien: If you're planning on explaining monads to someone using Ruby, all I can suggest is "please don't".
15:58:03 <Cale> Yeah, I'm saying, it will be hard to explain the point of talking about monads if this is what your implementation of each monad looks like
15:58:05 <rien> once these concepts are understood in a familiar place we can move them to Haskell and finish with the details you mentioned, Cale.
15:58:20 <ReinH> But they won't be understood
15:58:27 <ReinH> because you can't actually explain the important parts
15:58:32 <ReinH> because they are impossible to write in Ruby
15:58:32 <rien> ReinH: I've done it successfully.
15:58:36 <ReinH> No, you haven't.
15:58:37 <Cale> You can't actually save yourself from writing any code the way you're going there
15:58:40 <ReinH> Because it's impossible.
15:58:44 <Fernandos> I've put it into my path and named it cabbit :) because I don't want to go down that deep into cabal rabbit hole
15:58:44 <rien> ReinH: I just did, see the link. I wrote the Maybe monad. :)
15:59:01 <ReinH> I saw the link. You did not implement "monads". You implemented Maybe.
15:59:06 <Cale> The point of talking about monads is to avoid writing the same damn code for every monad, for all the things in Control.Monad and elsewhere that can be written with respect to an arbitrary monad.
15:59:22 <ReinH> The point of monads is completely lost in a language that can't represent higher-kinded types.
15:59:24 <rien> That's right, like I said I implemented the Maybe monad, unlike what others are trying to say I said that I implemented monads. :)
15:59:26 <Cale> If you're not going to provide that abstraction, then don't even talk about monads, save yourself the headache :)
15:59:31 <Cale> You implemented Maybe
15:59:50 <rien> Cale: and once a person understands maybe in a familiar context we can move the goalpost.
15:59:51 <Cale> You implemented the operations on Maybe which would be required for a monad. You didn't implement the Maybe monad. :)
15:59:59 <rien> is that a radical concept?
16:00:10 <ReinH> It isn't radical, it's just poorly applied
16:00:22 <Fernandos> wish I could tell a-better-cabal to use some ssh-hosts for speeding up compilation, got some heavy-weight boxes weighting to be utilized :P
16:00:31 <rien> Cale: I think that's a pedantic distinction not useful for teaching.
16:00:58 <Cale> I'm pretty sure the implementation of Maybe in Haskell is clearer, even if you have to explain how Haskell data types work.
16:01:01 <hpc> by the way, everyone: http://arstechnica.com/information-technology/2015/05/sourceforge-grabs-gimp-for-windows-account-wraps-installer-in-bundle-pushing-adware/
16:01:16 <Fernandos> it seems that runnign cabal twice (in parallel) works
16:01:20 <Cale> (but that says nothing about monads)
16:01:26 <hpc> if you use sourceforge, check if your repo has been taken over
16:01:33 <Cale> If you actually got to the point of being able to abstract over monads in ruby, you'd see what I mean :)
16:01:40 <ReinH> There is no path to monad santori through Ruby.
16:01:41 <rien> Cale: some people learn by peeking at how the mechanism behind the scenes "knows" things. 
16:02:04 <rien> ReinH: if you've decided so then sure. :)
16:02:12 <Cale> The monad abstraction is pretty worthless in ruby, because by the time you get to actually being able to use it, your code is horrible, since you're passing monad instances around explicitly everywhere.
16:02:24 <arkeet> monad suntory?
16:02:28 <ReinH> Well, I've been using Ruby for over a decade. If there was such a path, I would be shouting it from the rooftops.
16:02:34 <rien> Cale: I'm glad I never suggested using monads in Ruby.
16:02:46 <Fernandos> Is anyone in here using the atom editor? (probably the worst decision possible for an emacs veteran)
16:03:21 <ReinH> Fernandos: I tried, spent a few hours becoming increasingly frustrated, and installed emacs for windows instead
16:03:24 <Cale> I think monads are not important enough to bother trying to explain in terms of languages where the abstraction doesn't go through nicely.
16:03:32 * hackagebot derive-enumerable 0.1.1.0 - Generic instances for enumerating complex data types  http://hackage.haskell.org/package/derive-enumerable-0.1.1.0 (mgoszcz2)
16:04:04 <rien> Cale: I don't intend on getting to the point of abstracting over the entire abstraction called Monad in Ruby because I do agree with you that would be excessively ugly and miss the point entirely. which is why I never suggested doing that and I have never done it.
16:04:16 <Fernandos> ReinH: haha :) may I ask what your pain points were?
16:04:40 <ReinH> Fernandos: The editor is excruciatingly slow, hogs memory, and various interesting plugins I tried didn't work
16:04:43 <rien> Cale: yes, agreed again. But the Maybe type *is* important enough to justify all that and more.
16:04:49 <athan> ski: So the only way I could do it is with a type signature of `(Ast, [Tokens]) -> (Ast, [Tokens])`. I wonder if this is an algebraic property
16:05:01 <ReinH> rien: But you can explain Maybe without talking about monads ever.
16:05:13 <ReinH> The whole point of an abstraction is that it abstracts over something
16:05:23 <ReinH> if you just have the thing, you don't need the abstraction
16:05:42 <Cale> Yeah, if you're just going to talk about Maybe, don't bother using the word monad at all.
16:05:57 <rien> ReinH: so because of what you said, therefore there's only one way to teach beginners and we must ignore when they ask how does the compiler and runtime manage this stuff behinds the scenes?
16:06:11 <Fernandos> to me it was the "choice", because I could use it to write scala,java,earl-grey,erlang,elixir,javascript,xml,haskell,nim,red,c,c# and other languages. (I wouldn't know howto get emacs to support all that without exploding over my head to be honest, I tried vim to support a few, but then gave up)
16:06:15 <Cale> rien: hm?
16:06:23 <ReinH> rien: So because of what I said you are going to put a whole bunch of words into my mouth that I never said?
16:06:30 <ReinH> That's not a reasonable way to have a conversation with someone
16:07:12 <athan> ski: Here's the term: http://lpaste.net/133458
16:07:16 <Cale> The right time to introduce the word "monad" is when you suddenly want to write code which actually works with more than one monad.
16:07:21 <rien> ReinH: when you tell me what the whole point of an abstraction is, it's as if you're saying "don't bother explaining abstractions through concrete things that work without it"
16:07:33 <Fernandos> ReinH: absolutely valid pain points. I fully agree that many addons cause errors and it's very slow and memory hungry. It still worked and was less pain than (re)learning emacs and emacs's own lisp.
16:07:42 <kristof> Cale: I disagree. :(
16:07:52 <Cale> kristof: why?
16:07:57 <ReinH> No, I'm saying that introducing abstractions without need is a bad way to write programs and teach.
16:08:04 <rien> ReinH: but precisely what the beginner wants to understand is why do you want to use an abstraction to do a thing that works without it
16:08:21 <arkeet> abstractions are good when they abstract over multiple things.
16:08:25 <ReinH> arkeet: indeed.
16:08:36 <ReinH> Premature abstraction is the root of a lot of evil
16:08:43 <kristof> Cale: Because explaining to people that 1) finding patterns and 2) solving problems involving those patterns in relatively the same way because they involve the same structure is an invaluable tool in any programmer's toolkit is important
16:08:54 <Fernandos> rien: May I ask what you and ReinH area talking about, I know vaguely what monads are :)
16:09:04 <Fernandos> or would that be too time consuming?
16:09:10 <rien> arkeet: must we show these multiple things at the same time to a beginner? or can we go one by one?
16:09:13 <arkeet> the point of an abstraction is to get at the essence of what is common among multiple things.
16:09:27 <rien> Fernandos: ways of explaining monads to beginners through concrete examples
16:09:34 <Fernandos> ah
16:09:37 <rien> arkeet: yes and the point of an example is to be concrete
16:09:41 <rien> so beginners understand
16:09:43 <rien> so you see the clash
16:09:51 <kristof> Cale: You should use the word monad as soon as you encounter a monad for the same reason you should use the word iterator the first time you come across something that isn't an array but still admits some kind of iterable structure.
16:09:53 <arkeet> yes, but if you only have one example it's not a very good way to introduce the abstraction.
16:10:11 <Cale> kristof: Why not use it for an array?
16:10:18 <rien> arkeet: did I say "I only ever use one example to explain monads"?
16:10:19 <Fernandos> my prof said: it means that you wire something up a way you want. (well something like that, don't remember it :D)
16:10:24 <arkeet> no, but you only have one example.
16:10:33 <sleblanc> arkeet, depends on the abstraction. A list abstraction can work with a single example
16:10:37 <Fernandos> I think he meant control flow
16:10:37 <rien> arkeet: you have access to my private gist account?
16:10:58 <arkeet> of course not.
16:11:04 <kristof> Cale: Because iterators are far more general of a concept and would be distracting if you were teaching someone how to "loop over an array" for the first time :P
16:11:04 <ReinH> Are you intent on making this conversation as painful as possible for everyone else?
16:11:23 <Cale> kristof: Right. Monads are a far more general concept than most examples of monads too.
16:11:24 <arkeet> none of this discussion is about me though, so that's not a relevant question.
16:11:40 <kristof> Cale: Yeah, I see how you set me up for that one.
16:11:44 <juanpaucar> Hi everydoby, i have a question. i'm using have some legacy code that uses a readerT to store a connection to the database and just uses 'ask' to get it when it needs. But when i use liftBase to take an IO action to the context with DB, it is not being evaluated.
16:11:47 <rien> arkeet: I have a State example in Ruby as well, as it turns out, that I show beginners.
16:11:53 <juanpaucar> http://lpaste.net/133459
16:11:56 <athan> ski: (this doesn't check for bracket matching, btw. Not sure if that means anything)
16:12:09 <rien> arkeet: so when you say I only have one example can we agree that's unfair?
16:12:10 <kristof> Cale: Oh, you know what? I misread what you said. I thought you meant using more than one monad at the same time, i.e. a monad transformer.
16:12:29 <Fernandos> rien: was my "definition" correct or is that completely wrong?
16:12:50 <Cale> kristof: Yeah, what I mean is when you want to write sequence in a way that it'll work for Maybe, and IO, and lists, and on and on, and save yourself from writing that bit of code again and again.
16:13:06 <bitemyapp> pavonia: I wasn't in the real code
16:13:08 <Fernandos> michael hmm installed http://hackage.haskell.org/package/biofasta but there is no documentation too with that, any idea how to use it?
16:13:08 <kristof> Cale: Okay, I agree with what you said, then. My apologies :)
16:13:13 <bitemyapp> pavonia: I removed some unnecessary context.
16:13:16 <bitemyapp> kristof: hey stranger
16:13:20 <rien> Fernandos: monads are really just an abstraction for many sorts of sequences. when they give you a "counter example" that still really does abide by the sequence contract, they're just calling inner continuations.
16:13:21 <kristof> bitemyapp: How was your talk?
16:13:24 <kristof> bitemyapp: In Boulder
16:13:26 <kristof> Or is that soon?
16:13:39 <bitemyapp> kristof: workshop was guided by questions, talk was uninterrupted. Got very positive feedback on the later.
16:13:41 <bitemyapp> latter*
16:13:48 <kristof> bitemyapp: I can't even remember what it was on.
16:13:53 <bitemyapp> kristof: working on pushing out another update of the book.
16:13:57 <bitemyapp> kristof: (as we speak)
16:14:07 <bitemyapp> kristof: talk was titled, "How to learn Haskell in less than 5 years"
16:14:10 <bitemyapp> I'm ambitious like that.
16:14:22 <Cale> Fernandos: We're talking about differences of opinion regarding how/when it's best to introduce the monad abstraction and the word "monad".
16:15:20 <Fernandos> is there no replacement word, in english almost any word can be replaced by another word. In example a friend told me that a space is a monoid because it connects to words
16:15:27 <Cale> Personally, I don't think that if you implement the combinator library for State on its own that it's all that valuable to start talking about monads in general, if you have no intention of going on and being able to use the code you then write with other monads.
16:15:42 <rien> Fernandos: folks don't like the replacement words because they are never complete analogies.
16:15:58 <ski> athan : hm. (i assume s/ExprString/ExprTokens/). not sure what you mean about it not checking for bracket matching
16:16:09 <kristof> Fernandos: Well a monoid is something that generalizes "combining". If you're familiar with Java, you might think of Monoid as ICombinable
16:16:10 <Fernandos> we glimpsed the word barely the meaning when we were introduced lambda calculus
16:16:21 <rien> Cale: the reason I disagree with you is because some people understand through seeing the inner mechanisms of what they are being explained. I'm sorry I can't make this point of mine any better.
16:16:22 <Cale> Fernandos: That's a poor example, concatenating strings with spaces doesn't result in a monoid on strings.
16:16:38 <Fernandos> mhhk
16:16:49 <Cale> rien: Nowhere in this am I saying "don't explain the inner mechanism of how the abstraction works"
16:16:50 <rien> Cale: I have a slide that disagrees.
16:17:06 <rien> hold that thought on the string monoid.
16:17:08 <Cale> rien: I'm saying "don't introduce the abstraction if you don't intend to exploit it"
16:17:27 <Cale> There's no identity.
16:17:28 <pavonia> juanpaucar: Are you sure executeDB is even called properly?
16:17:51 <rien> Cale: let me find the website and we can both write to the author there so he can correct it
16:18:18 <Cale> There's no string xs such that for any string ys, you have xs ++ " " ++ ys = ys
16:18:24 <rien> Cale: yannesposito.com/Scratch/en/blog/Category-Theory-Presentation/
16:18:31 <rien> Cale: CTRL+F for "smaller"
16:18:38 <Fernandos> I wrote a paper about FRP and mentioned this somewhere: "A Monoid is a Set with a neutral element and an associative binary operation (Function)."[…]
16:18:45 <rien> Cale: sorry my bad, it's a category not a monoid
16:19:00 <juanpaucar> pavonia: i think so, i'm sending the parameters with the neccessary typoe liek this "executeDB insertJob (queue, uuid, content)", actually i evaluated in the repl what is inside liftBase and works
16:19:08 <juanpaucar> so i'm not sure what's goin on
16:19:09 <Cale> rien: hm?
16:19:18 <Cale> rien: I see they mention plain concatenation
16:19:19 <rien> Cale: I misremembered it, my mistake. it's saying Strings are categories, not monoids.
16:19:46 <Cale> Uh, strings *do* form a monoid under concatenation, and it's that monoid structure which gives them a category structure
16:19:56 <Cale> But concatenation-with-spaces is a different operation
16:19:56 <arkeet> all monoids are categories.
16:20:00 <Cale> and doesn't give you a monoid
16:20:03 <pavonia> juanpaucar: Does it work in GHCi if you evaluated exectueDB?
16:20:09 <greensoup> do you guys find it frustrating to use languages without tail call optimization after spending a lot of time in haskell?
16:20:11 <kristof> Cale: If you define an equivalence relation on strings such that you strip the spaces out of strings before comparing any two strings, then you have identity elements of "", " ", "  ", ...
16:20:13 <Cale> (or a category)
16:20:14 <athan> ski: Ahh yes, sorry about that you're correct. And by bracket matching I mean `( ( )` will succeed with this function, but it will be "packed" as far as it can.
16:20:26 <ReinH> rien: kas te räägite eesti keelt?
16:20:30 <Cale> kristof: yeah, sure
16:20:30 <Fernandos> ie. whole numbers are defined as Monoid with 0 for the empty set  and a associative operation (+), where for postive whole numbers the empty set is 1
16:20:42 <kristof> Cale: What, does mempty have to be unique?
16:20:45 <kristof> *Wait
16:20:49 <ski> athan : oh, i see
16:20:51 <arkeet> "if you ignore spaces, concatenation with spaces gives a monoid"
16:20:54 <mmaroti> Quick question: How to debug a "Stack space overflow" error? Just looking at my complicated codebase I cannot see the possible problem.
16:21:17 <rien> ReinH: that looks like Latin + Latvian :)
16:21:23 <ReinH> rien: estonian :)
16:21:38 <juanpaucar> pavonia: no, it doesn't. It fails, but if i put in executeDB undefined in some lines i do get the Prelude.undefined error.
16:21:43 <rien> argh that's what I meant but I couldn't remember the name of the country, I'm so embarrassed :P
16:21:50 <ReinH> no problem :)
16:21:51 <rien> eesti gave it away
16:21:54 <ReinH> heh
16:21:56 <kristof> arkeet: That's not a contrived example. I actually wrote a very small infix parser this weekend that had to be able to take expressions like "1+3" and I had to pad things with spaces before I tokenized
16:21:57 <juanpaucar> pavonia: but no if it is in the liftBase
16:22:16 <ReinH> rien: I was spying on you and I noticed you're connecting from an estonian freenode server :)
16:22:18 <rien> ReinH: I dated a Finnish lady that as close as I got. learned a bit, only remember musta tarkki.
16:22:21 <rien> hahah
16:22:31 <pavonia> juanpaucar: What library is DB from?
16:22:48 <rien> ReinH: oh that's weird. I'm nowhere near Estonia (would be nice!)
16:22:52 <juanpaucar> pavonia: type DB a = forall m. MonadBase IO m => ReaderT Connection m a
16:22:52 <ReinH> Weird.
16:22:55 <arkeet> (reminder that #haskell-blah exists)
16:22:57 <ReinH> Well, freenode routing is weird.
16:23:12 <ReinH> Anyway, back to our strictly regulated Haskell talk
16:23:18 <Fernandos> rien: I defined Monads in my paper as: "Simply put, Monads help with encapsulation of states (transformations) in the short in a reusable style."
16:23:20 <kristof> ...Speaking of which. How do people normally handle something like that? I'm not familiar with tokenizing, I didn't take a compiler course in college, etc.
16:23:29 <zacts> ^ well damn, rest assured the US senate voted that humans have no effect on climate change
16:23:36 <zacts> (according to this NY Times article)
16:23:43 <kristof> zacts: Link, you must be wrong
16:23:46 <Fernandos> there was more, but was too lazy to translate more :) it's german
16:23:46 <kristof> I do not believe that
16:23:49 <kristof> Plus, it's off-topic
16:23:49 <zacts> kristof: I did link it
16:23:56 <zacts> sorry about off-topic
16:24:13 <kristof> zacts: I don't even see it, what are you talking about
16:24:17 <zacts> http://www.nytimes.com/2015/01/23/us/politics/senate-rejects-human-role-in-climate-change.html?_r=0
16:24:21 <arkeet> ahem
16:24:25 <Fernandos> it stands for the introduction of (iso-)morphism
16:24:36 <Fernandos> to functions
16:24:39 <rien> Fernandos: those transformations are laid in a sequence which does not mean they will be executed in that order nor that they will be run at all.
16:24:58 <rien> and monads abstract anything that can be built by those sequences that don't necessarily execute in order or at all.
16:25:00 <zacts> anyway, eventually I'm going to get thru that Essentials of Programming Languages by Friedman et a...
16:25:03 <zacts> oh shite
16:25:09 <zacts> I'm on haskell not the other channel
16:25:12 <zacts> sorries
16:25:16 <zacts> I got mixed up
16:25:22 <arkeet> monads are not about state, or sequences, or transformations, or execution.
16:25:22 <Fernandos> np :)
16:25:25 <zacts> I thought I was on the #chicken scheme channel
16:25:37 <rien> arkeet: re #haskell-blah thanks :)
16:25:48 <pavonia> juanpaucar: And if you run something simple as "liftBase $ putStr ...", does that work?
16:26:01 <Fernandos> arkeet: ugh.. what else are Monads then about if not morphisms?
16:26:11 <arkeet> monads are about return and (>>=)
16:26:58 <juanpaucar> pavonia: no it doesn't work... liftBase (undefined), doesn't even throw the error... the request to the server times out and snap kills the thread... otherwise i think it could be forever
16:27:07 <hodapp> Chipotle is the chief proponent of the use of monads
16:27:17 <arkeet> :-)
16:27:40 <arkeet> yeah, sorry, I meant monads are about burritos.
16:27:53 <rien> arkeet: (>>=) which is that thing that goes between the elements in the sequence you build
16:28:03 <ski> athan : are you sure you don't want recursion in the last defining equation ?
16:28:09 <arkeet> what sequence? I see no sequence.
16:28:25 <ski> arkeet : i'd say monads are as much about sequence as monoids are about sequence
16:28:33 <pavonia> juanpaucar: Could you post the code where you are calling this function?
16:28:48 <arkeet> ski: maybe a little less.
16:29:05 <Fernandos> arkeet: Monads are defined as Monoids in the Category of Endofunctors. -- Saunders Mac Lane
16:29:09 <rien> arkeet: f >>= g >>= h
16:29:40 <Fernandos> arkeet: explaining monads with synthax is like explaining monads with monads or so
16:29:41 <arkeet> so numbers are about sequences, because + is the thing that goes between numbers.
16:29:56 <athan> ski: Yes - because identifiers don't create or destry scope
16:30:10 <athan> destroy*
16:30:19 <rien> + is not the thing that goes between numbers. numbers are the thing that things that have nothing else in common with, have in common.
16:30:20 <Welkin> athan: I read that as "don't destroy crops"
16:30:37 <luzie> monads are about join, return and fmap :-)
16:30:38 <rien> for instance 3 bulls and 3 boxes have the number 3 in common. that's what 3 is.
16:30:41 <arkeet> if you want a concrete structure that you want to make monad analogies with, try the free monad.
16:30:44 <athan> Welkin: Plz don't D:
16:31:00 <ski> athan : what should `group ([],[TIdent "a",TIdent "b"])' reduce to ?
16:31:16 <rien> arkeet: can you give me a more precise pointer? I'm interested, have heard of it but that was all
16:31:17 <arkeet> (which one can define without reference to monads in general.)
16:31:21 <athan> ski: ([TIdent "a", TIdent "b"], [])
16:31:32 <rien> arkeet: favorite free monad tutorial perhaps :P
16:31:35 <athan> erp
16:31:41 <athan> maybe I have x and acc backwards
16:32:00 <ski> athan : as i suspected. this doesn't happen with your current definition (due to lack of recursion in the last defining equation)
16:32:00 <athan> actually
16:32:04 <athan> you're right :P
16:32:07 <rien> luzie: doesn't join collapse two structures? that must mean one comes after the other? that's where the sequence is.
16:32:12 <athan> sorry ski ><
16:32:24 <juanpaucar> pavonia: http://lpaste.net/133461
16:32:28 <michaelt> > join (+) 12
16:32:28 <ski> rien : yes
16:32:29 <lambdabot>  24
16:33:08 <athan> ski: Just call `group` on what I have, and it should be correct, right?
16:33:18 <dzack> does ghc always include html haddocks?
16:33:19 <rien> ski: I'm not saying monads *are* about sequencing. I'm saying they abstract sequencing patterns because of the circumstances... since they collapse two things that are basically nested... and so by force of circumstance of comes after the other.
16:33:22 <pavonia> juanpaucar: That's not helpful :( What is the outer monad you call your code in?
16:33:28 <dzack> or is there a way to pull it manually?
16:33:36 <rien> of=one*
16:33:42 <ski> athan : on what ? `([TIdent "a",TIdent "b"],[])' ?
16:33:43 <Welkin> :t join (+)
16:33:45 <lambdabot> Num a => a -> a
16:33:52 <michaelt> dzack: 'pull it manually'?
16:34:04 <dzack> the entire html subdirectory
16:34:10 <rien> ski: you agree with me then?
16:34:42 <athan> ski: Would `group (acc, x:xs) = group (acc ++ [x], xs)` be the correct case?
16:34:50 <mightybyte> Hey guys, we're live streaming the NY Haskell Meetup right now at http://original.livestream.com/pivotallabs if anyone is interested.
16:34:52 <michaelt> dzack: hm, you could download one of the binary distributions and grab it from there...
16:34:53 <ski> rien : i would probably be a bit wary about "comes after the other". however there's a basic ordering here (due to the nesting)
16:35:05 <mightybyte> It's a talk about diagrams by Jeff Rosenbluth.
16:35:38 <ski> athan : that was what ui had in mind, yes. however, perhaps i was misunderstanding what you wanted to do here, which was why i wanted confirmation
16:35:46 <ski> (or otherwise)
16:36:01 <rien> ski: yes of course because they might not execute at all but I never lose sight of that when explaining
16:36:20 <dzack> it looks like haskell.org used to provide haddock tarballs at https://www.haskell.org/ghc/docs/
16:36:27 <rien> arkeet: do you see the order/sequence due to nesting that ski and I see?
16:36:29 <juanpaucar> pavonia: http://lpaste.net/133461 does this work?
16:36:33 <dzack> but that seems to be down
16:37:39 <rien> arkeet: "what sequence? I see no sequence." -> the sequence is due to the fact that bind collapses nested structures.
16:38:10 <ski> rien : i think it's not really useful to bring reduction and reduction ordering into this (which i think is one mistake that people do when some ones talk about "sequencing" in connection with monads)
16:38:44 <hodapp> would you say it's more or less confusing than bringing up refried beans?
16:38:45 * hodapp flees
16:39:34 <rien> ski: the confusion about what is it really sequencing, we both know and don't need to discuss here. look it's just like a program. it's a sequence of lines. does that mean all lines execute in sequence? of course not. beginners aren't dumb. they can relate to algol lines, it's the same, a sequence that might not be walked at all
16:40:01 <rien> I can have a 200 line program where the first line says exit(0).
16:40:09 <rien> it's still a sequence of lines.
16:40:18 <rien> walked by EIP
16:40:42 <nkar``> acowley: hi, does cabbage avoid rebuilding stuff?  e.g., if I have two lens packages in two different sandboxes, will it build lens once or twice?
16:40:46 <michaelt> dzack: maybe one of these https://downloads.haskell.org/~ghc/7.10.1/docs/ ?
16:43:35 * hackagebot socket 0.1.0.0 - A binding to the POSIX sockets interface  http://hackage.haskell.org/package/socket-0.1.0.0 (LarsPetersen)
16:43:45 <pavonia> juanpaucar: I still cannot see where add is finally used. You have "forall m. MonadBase IO m => ReaderT Connection m a", what concrete m is used when you call runReaderT?
16:43:57 <nkar``> acowley: in other words, do packages just point to the store or is it a separate mechanism?
16:45:03 <pavonia> juanpaucar: I would think it the Snap monad, but I can't find a MonadBase instance for it
16:45:28 <juanpaucar> pavonia: I have an orphan instance for MonadBase
16:45:44 <acowley> nkar``: It's a bit subtle. It does not rebuild things that would result in the exact same build artifact.
16:46:03 <acowley> nkar``: But it's very easy for something in lens's chain of dependencies to vary, resulting in two instances of lens.
16:46:06 <pavonia> juanpaucar: Okay, what does that look like?
16:46:16 <mightybyte> The Snap monad currently does not use monad-control.  It uses MonadCatchIO-transformers instead.  Snap 1.0, which is on github master, will use monad-control.
16:46:22 <acowley> nkarr``: So, technically, there are no rebuilds! Practically, there are a minimal number of rebuilds.
16:46:57 <juanpaucar> pavonia: http://lpaste.net/133465
16:47:04 <acowley> nkarr``: You start winning dramatically when you use common sets of constraints a la Stackage. 
16:47:20 <juanpaucar> mightybyte: yup, i hope issues can be solved with snap 1.0 so we can have it on stackage
16:47:26 <juanpaucar> i meant hackage
16:47:43 <dzack> maichaelt: looks like that may work. thank you!
16:47:50 <acowley> nkarr``: But I don't use Stackage and still relish having fewer rebuilds. I have dozens of sandboxes, and text and lens rebuilds were sapping my life.
16:48:41 <mightybyte> juanpaucar: It should be pretty stable right now.  We're down to just one or two main outstanding items on the 1.0 release checklist.
16:53:16 <subleq__> I have a use a fromJust . Map.lookup in my program that I feel could be improved, because I know the key will always exist: https://github.com/gavinwahl/websocket-channel-server/blob/master/Main.hs#L72
16:53:34 <pavonia> juanpaucar: Not sure, but isn't that a recursive defintion?
16:54:31 <subleq__> Maybe I'm using the wrong data structure?
16:55:07 <pavonia> juanpaucar: With (liftBase :: IO a -> Snap a) = (liftSnap :: Snap a -> m' a) . (liftBase :: IO a -> m a) you should get m = m' = Snap
16:55:31 <pavonia> So basically liftBase = liftBase, which would be an explanation why it times out
16:56:10 <pavonia> juanpaucar: Try if liftBase = liftIO works
16:56:13 <athan> Any comments? https://github.com/athanclark/composition-extra
16:56:13 <ski> rien : "EIP" ?
16:56:45 <pavonia> Maybe mightybyte know better, I'm not familiar with Snap
16:57:12 <rien> ski: the instruction pointer in 32-bit mode
16:57:16 <StrangeLoop> http://lpaste.net/133453 <--- I am trying to add a logarithm to my parsing, i don't understand why I get an error in line 152
16:57:22 <rien> ski: (that's when I did assembly)
16:57:27 <StrangeLoop> "     Couldn't match expected type `Parser Expr' with actual type `Expr'"
16:58:10 <subleq__> It'd be nice to pass the Channel itself around instead of the channel name, but we always need to look up the new value of the Channel from the ServerState MVar
16:58:53 <srhb> StrangeLoop: That do-block is a Parser block. But what is the type of parse?
16:59:20 <StrangeLoop> Oh riiiiiight
16:59:21 <StrangeLoop> Thanks
16:59:25 <srhb> StrangeLoop: :)
16:59:37 <acowley> subleq__: I don't have time to look, but if you can't represent the constraint in the type, you want to move the fromJust as close to the guarantee that it's safe as possible.
16:59:39 <ski> StrangeLoop : you can actually skip the `Parser' and `parse' (and `i') stuff in your  many'  now
17:00:13 <Cale> kristof: If there are two memptys, you can show they must be equal. In particular, you'll have that mempty1 = mempty1 <> mempty2 = mempty2
17:00:27 <athan> Guess not! :D  FIRE THE `cabal sdist`!
17:00:35 <michaelt> StrangeLoop: n is an Expr, the result of parsing with m, so it doesn't match "parse n i"
17:00:42 <ski> StrangeLoop : `string' could be written using `mapM'
17:00:48 <StrangeLoop> No wait, actually. as I understand, if p is a Parser (the way I defined it) then "parse p x" means "apply p's parse function to x". That's at least the way it works in, saw, lines 33,34
17:01:21 <juanpaucar> pavonia"
17:01:26 <srhb> StrangeLoop: What is the type of parse?
17:01:29 <nkar``> acowley: sounds awesome, hoping to give it a try soon.  does it support the new (current) haskellng infrastructure?
17:01:51 <nkar``> acowley: or is it completely irrelevant?
17:01:55 <StrangeLoop> OK, I understand now
17:02:03 <michaelt> StrangeLoop: parse (parens m) i would typecheck
17:02:11 <michaelt> oh
17:02:20 <StrangeLoop> Yup, that's what I did
17:02:34 <acowley> nkar``: No it's entirely independent. Basically my entire goal is to be make support of multiple versions totally transparent, which the nixpkgs haskell infrastructure explicitly does not do.
17:02:59 <acowley> nkar``: My stuff is really Cabal++
17:03:06 <ski> StrangeLoop : *please* don't make a `Show' instance in this way
17:03:07 <srhb> StrangeLoop: Blindly guessing I think you want let (e,s) = ...
17:03:08 <pavonia> subleq__: Looks fine to me, as far as I can see. Maybe replace it by a case branch that yields a more readable error if Nothing is returned
17:03:25 <nkar``> acowley: sweeeet!  thanks for your work!
17:03:36 * hackagebot composition-extra 1.0.0 - Combinators for unorthodox structure composition  http://hackage.haskell.org/package/composition-extra-1.0.0 (athanclark)
17:03:37 <srhb> StrangeLoop: Trying to apply >>= to something that isn't in the same (or even a) m will fail.
17:03:39 <acowley> nkar``: Thanks for the encouragement! :)
17:03:42 <Fernandos> how can I import and use xcerpt.lhs in my haskell file? http://lpaste.net/2906571812798201856
17:03:49 <subleq__> pavonia: I know I can do that, it just feels like I should be able to prove it exists rather than have a runtime error
17:04:34 <juanpaucar> pavonia: it worked, :') thanks man
17:04:39 <srhb> Fernandos: Generally the imported hs files must/should correspond to their module name, and the directories in which to find it to the module hierarchy
17:05:01 <Fernandos> srhb: what do you mean?
17:05:16 <Fernandos> import "xcerpt.lhs" maybe?
17:05:19 <srhb> Fernandos: I mean import Foo.Bar.Baz corresponds to ./Foo/Bar/Baz.hs
17:05:59 <ski> StrangeLoop : (a) you're not outputting valid Haskell expressions; (b) you're not taking precedence into account
17:06:10 <Fernandos> ah, I downloaded that file simply because the build failed for anything that I tried and when it didn't fail it had zero documentation except many many files I only barely understand
17:06:24 <Fernandos> it appears to have no external  dependency
17:06:33 <pavonia> subleq__: That sounds tricky without some sort of dependent typing
17:06:43 <Fernandos> I ripped it from http://hackage.haskell.org/package/clustertools
17:07:05 <subleq__> pavonia: or change my datastructure so it's not an issue any more
17:07:23 <srhb> Fernandos: Heh, that's a very bold Hackage upload. Almost no constraints at all, that'll be fun.
17:07:59 <StrangeLoop> I am not ignoring your comments, there are just so very many of them so it'll take me some time to go over it all
17:08:05 <srhb> Fernandos: But the file should be named Xcerpt.lhs and you should import Xcerpt if you're in the root
17:08:36 <Fernandos> srhb: the very best I could find man :( I found no other library that simply parses "*.fasta" files and has a little documentation or is at least understandable without inhaling the haskell-reference manual
17:08:36 * hackagebot composition-extra 1.0.0.1 - Combinators for unorthodox structure composition  http://hackage.haskell.org/package/composition-extra-1.0.0.1 (athanclark)
17:08:47 <ski> StrangeLoop : also, notation like  ((5)*((x)^(3)))'  is, imho, an abominiation (and i don't mean the bracketting)
17:08:58 <Fernandos> ok will try
17:08:59 <StrangeLoop> ski: What does it mean that I am not outputting valid Haskell expressions? When did I output Haskell expression
17:09:26 <srhb> Fernandos: What's wrong with the fasta package?
17:10:31 <Fernandos> srhb: http://hackage.haskell.org/package/fasta ? I looked at it's source, but don't understand howto use it..
17:10:48 <srhb> Fernandos: It is the one you should use, regardless of what you need to inhale before doing it. :-)
17:10:49 <ski> StrangeLoop : imho, `Show' is for outputting valid Haskell expressions (in an appropriate environment). if you don't want that, then i suggest defining a separate function. `display :: Expr -> String' or something like that
17:11:02 <Fernandos> I'm spendin way way too much time trying to solve this.. been here trying it for so many hours
17:11:28 <StrangeLoop> ski: Oh OK
17:11:30 <pavonia> subleq__: That's what I mean, you will still have to deal with the case that a value is not in the set without fixing it in the type somehow
17:11:42 <srhb> Fernandos: Fair enough. But really, a weird collection of .lhs files uploaded to Hackage years ago is going to be no fun at all. If all you need is a parser you might just write it yourself. fasta parsers are easy enough.
17:11:59 <srhb> Fernandos: (It's been a few years since I did bioinformatics, but I still think this is correct)
17:12:14 <michaelt> Fernandos: the simple functions are here https://github.com/GregorySchwartz/fasta/blob/master/src/Data/Fasta/Text/Parse.hs
17:12:20 <srhb> Fernandos: If you need help using it, feel free to ask
17:12:25 <Fernandos> srhb: I copied the whole 99KB file's contents int the .hs file and removed newlines.. dirt cheap way to say gtfo and compile ghc
17:12:31 <srhb> Ow. No.
17:12:44 <srhb> Fernandos: Don't do that :P
17:13:07 <StrangeLoop> ski: Now, what is wrong with the notation (apart from the abominable bracketing)?
17:13:49 <michaelt> Fernandos: hah
17:13:50 <Fernandos> I didn't know what to do else, I tried everything with cabal, than found cabal sandboxes, then when that failed installed stk, and when that failed I just copied the darn file, but ghc failed to recognize the import, so I just copied it
17:14:20 <Fernandos> even removed all haskell-libraries from my system, then tried compiling each manually with cabal-sandbox 
17:14:39 <Fernandos> guess you see how deperate I was..or am
17:14:39 <srhb> Fernandos: What are you trying to achieve? To me, your frustrations sounds like those of one who's forced to do Haskell in a bioinformatics context without wanting to do it the Haskell Way. If that's the case, please tell me the name of your boss so I can steal your job :P
17:14:50 <michaelt> Fernandos: you're having a bad day, it will all be clearer soon ...
17:14:51 <srhb> Fernandos: Seriously though, I'd love to help (doing it right, with the fasta package)
17:15:00 <JagaJaga> Guys, need help! What's better to write about StateT in my bachelor's thesis? What are the cons of using it? Hm, I don't even know how to ask a question about it :( I use it with lens and that helps me easily manipulate my program's state and do IO actions at the same time.
17:15:03 <michaelt> srhb: haha
17:15:52 <Hijiri> JagaJaga: StateT or State can make it harder to follow something
17:15:58 <Hijiri> because it introduces implicit state
17:16:04 <srhb> Hijiri: explicit!
17:16:14 <Hijiri> implicit as in it doesn't show up passing around in the code
17:16:19 <ski> StrangeLoop : <https://en.wikipedia.org/wiki/Notation_for_differentiation#Lagrange.27s_notation> applies to *functions* (specifically function expressions). not to number expressions possibly involving some variable (and possibly also others), with no notation indicating which variable you're going to differentiate the expression with respect to
17:16:21 <srhb> That's not state, that's just arguments
17:16:33 <Fernandos> michael srhb I hope your browser doesn't crash with this paste http://lpaste.net/5812608077534330880
17:16:49 <JagaJaga> Hijiri: state is pretty explicit there...
17:16:50 <StrangeLoop> ski: I have to respectfully disagree with you on that one
17:17:05 <Hijiri> ok, it's harder to follow because you don't see explicitly the passing of an argument
17:17:13 <srhb> Fernandos: I don't want to help with the Xcerpt thing. I WILL help with the fasta package
17:17:18 <Fernandos> I'm in an algorithms course, we're writing all kinds of algorithms, I already tried nim,clojure,scala,matlab,python and now haskell
17:17:26 <srhb> OK :)
17:17:36 <Fernandos> nothing bioinformatics related
17:17:43 <ski> StrangeLoop : what does  (a * x^2 - x * sin theta)'  mean ?
17:17:47 <srhb> Well, aside from it being bioinformatics algorithms.
17:17:52 <Fernandos> srhb: absolutely ok =)
17:18:04 <srhb> Fernandos: So, what are you trying to do. High-level.
17:18:04 <JagaJaga> Hijiri: indeed I need pros, not cons :D
17:18:29 <subleq__> Maybe if I changed to channels :: Map.Map BS.ByteString (MVar Channel), then I could pass an mvar around for each channel
17:19:03 <StrangeLoop> ski: depends on the derivation variable, which should be clear from the context when using this notation, like a plethora of other notational conventions throughout mathematics
17:19:13 <Fernandos> srhb: A k-mer is a sequence of symbols from some alphabet Σ of length k. The set (or sequence) of all k-mers is a combinatorial object.  Define a divide-and-conquer algorithm that generates all k-mers.
17:19:45 <Fernandos> next thing is a divid and conquer algorithm
17:19:53 <Fernandos> eh sorry iterative algorithm
17:20:05 <srhb> Fernandos: But if you already have the sequence, why do you need to parse fasta?
17:20:42 <Fernandos> to not have to paste 99KB or many GB of data into a hs file ;)
17:20:59 <srhb> Fernandos: So all you really want to do is strip the >... line from a fasta file?
17:21:10 <ski> (StrangeLoop : of course  (θ ↦ a·x² - x·sin θ)′  is fine. as is  D(θ ↦ a·x² - x·sin θ)(2·θ)  and  d a·x² - x·sin θ / d θ  .. (all of those are different, btw))
17:21:20 <Fernandos> not sure, how fasta files ar specified
17:21:27 <srhb> Fernandos: Perhaps that should be your starting point
17:21:30 <srhb> Fernandos: Not perhaps. It should be.
17:21:41 <srhb> Fernandos: sequences are always delimited by lines starting with >
17:21:47 <Fernandos> srhb: well except if I could use the fasta library
17:21:56 <srhb> Fernandos: Sure, and you can. It's even easy.
17:22:08 <srhb> Fernandos: But what you're asking for is functionality that is much simpler.
17:22:11 <StrangeLoop> ski: I am well aware of the differences
17:22:29 <ski> (i suppose you might want to write the latter as  d (a·x² - x·sin θ) / d θ  .. depending on what precedence conventions you use)
17:22:57 <Fernandos> srhb: readFile $ skipXLines $ stripLF 
17:23:04 <srhb> Fernandos: Basically.
17:23:04 <Fernandos> something like that...
17:23:41 <srhb> Fernandos: read the file, join lines that don't start with >, strip lines that do.
17:23:51 <srhb> Then you have a list of sequences (without their metadata)
17:23:52 <michaelt> Fernandos: http://lpaste.net/2520214894360395776 
17:24:23 <srhb> michaelt: drop 9?
17:24:31 <srhb> Oh sorry.
17:24:52 <michaelt> srhb: yeah, sorry, I just cut the definition of "genes = "AC.." and put it in a file
17:24:59 <srhb> michaelt: Yep yep.
17:25:18 <ski> StrangeLoop : i'm fine if you disagree, as long as you understand what i'm getting at (if you explicitly say which variable name your prime is differentiating wrt to, then i'll grudgingly accept it)
17:25:20 <srhb> But given a fasta file the problem is (only slightly) more complicated
17:27:15 <Fernandos> oh cool that worked, let me compare the results
17:27:49 <StrangeLoop> ski: In my experience, the tendency to be overly explicit fades when you get to more detailed arguments, where it does nothing but clutter the page and make reading more difficult. I know that single variable differentiation is not exactly the front line of research, but even there I find the apostrophe notation beneficial, for example when calculating derivatives which require several applications of chain rules
17:27:50 <ski> StrangeLoop : did you mean to use `string "ln"' in `ln' ?
17:28:06 <mmaroti> Is it possible to find the cause of "Stack space overflow", i.e. print the thunk that triggered that?
17:28:15 <StrangeLoop> ski: Yup, already fixed, thanks
17:28:36 <Fernandos> identical, thank you srhb!
17:29:03 <Fernandos> what does this line do? let genes = init $ drop 9 g
17:29:24 <Fernandos> 10 stands for newline afaik in the ascii table, but 9?
17:29:46 <JagaJaga> Fernandos: take all elements except first 9 and the last one
17:30:00 <Fernandos> ahh
17:30:01 <JagaJaga> Fernandos: I mean returns from a list
17:30:14 <srhb> Fernandos: Thank michaelt if that was the code you used :)
17:30:26 <ski> StrangeLoop : it looks a bit strange in `number' to parse the sign, integral and decimal part, only to defer to `read'. if you instead use `reads' directly, it'll do that (and also parse scientific notation). if you don't want to parse scientific notation, then i suppose i'd make the parsing of the sign return either `negate' or `id', &c. manually constructing the parsed number instead of using `read'
17:30:27 <Fernandos> thank you michael!
17:31:02 <srhb> Fernandos: and drop 9 actually just drops 9 elements (characters, in this case) from the list
17:31:20 <srhb> Fernandos: The front, that is
17:31:35 <Fernandos> the first line starts with >gene followed by  newline
17:31:41 <Fernandos> 5 chars
17:31:57 <srhb> Fernandos: I'd use the lines combinator if you are actually parsing a fasta file
17:32:24 <Fernandos> never heard about the lines combinator
17:32:27 <srhb> :t lines
17:32:28 <lambdabot> String -> [String]
17:32:34 <srhb> > lines "Line 1\n Line 2"
17:32:36 <lambdabot>  ["Line 1"," Line 2"]
17:32:42 <srhb> Silly space.
17:33:36 <ski> StrangeLoop : imho, one reason to be explicit is to offload the cognition, so that you don't have to interpret your formulae all the time to determine/recall what was *meant* (so that you have more brain power left to think on a higher level, e.g. in what direction you'd want to move, and applying various intuitions and analogies to the (interpreted) content of the formulae)
17:34:43 <ski> StrangeLoop : i'm not sure how the latest version of `ln' looks like, but in the version i see, `Parser',`parse',`i' looks redundant (as in  many'  as i mentioned before)
17:34:54 <Fernandos> srhb: you mean instead of map (take k)?
17:35:17 <srhb> Fernandos: No I mean when reducing a fasta files to a list of sequences (witout metadata)
17:35:22 <srhb> fasta file*
17:35:47 <StrangeLoop> ski: I am fairly sure that rereading the same information over again takes much more toll then just remembering it, especially when not being aware of it means you are not following anyway. I mean, I can't imagine how cluttered an contemporary article would be if it didn't leave anything to memory
17:36:15 <ski> StrangeLoop : to avoid generating as many brackets, you can pass a "current precedence level" to your display function (like in `showsPrec'), and compare it to the precedence of the various operators
17:36:59 <ski> StrangeLoop : the same idea (passing a current precedence level) can be applied to the parsing functions (cf. `readsPrec')
17:38:15 <ion> launchMissilesPrec
17:40:05 <ski> StrangeLoop : it may be that different people are functioning in different enough ways here. i'm reasoning from my personal experience (and some teaching situations)
17:41:33 <StrangeLoop> I mean, I am open to the idea that different people think differently, but I have never ever met anyone who thinks the clutter reduces the effort of reading an article. But if that's working for you then who am I to argue?
17:43:28 <srhb> StrangeLoop: That's a misrepresentation. :P
17:43:43 <StrangeLoop> ?
17:44:10 <srhb> "I don't like your opinion because bad(clutter(horrible(yourOpinion)) seems to me to be a bad idea.
17:44:17 <srhb> "
17:44:42 <srhb> Using badify on other peoples' arguments is not conducive.
17:44:48 <johnw> I think #haskell stopped being the place to resolve this a bit ago
17:44:53 <srhb> True enough.
17:45:33 <ski> for me, i want to "let the symbols do the dull work" (mechanical manipulations). having to use judgement and interpretation (as opposed to some more or less local syntactic stipulations/conventions) to interpret what a formula *means* (as opposed to connotations and stuff like *why* we're using it) stands in my way for that
17:47:23 <Murad> Hi, all. Any idea why cabal continues to install --global packages in C:\Program Files (x86)\Haskell\[...]\ on windows when I changed it in the cabal config?
17:47:48 <ski> StrangeLoop : btw, i noticed your display case for `Der' both call `d' and use a prime. did you intend this ?
17:48:13 <srhb> Murad: No, but you should never use --global probably.
17:48:38 <Murad> I am the only user on this machine. And I'd prefer it.
17:49:09 <srhb> Murad: If you're the only user, you don't need --global as everything is in your users cabal directory. :)
17:49:37 <ion> Or preferably in sandboxes
17:49:39 <StrangeLoop> use a prime?
17:49:42 <srhb> That, indeed.
17:49:53 <Murad> srhb: I'd like to gain an understanding of the build system. I am using sandboxes for my projects.
17:50:17 <srhb> Murad: Not sure how --global would help you there. perhaps I am just ignorant of it. :)
17:51:13 <Murad> srhb: What I don't understand is why cabal ignores my config or if I am missing something else.
17:51:26 <dedgrant> Murad: Did you edit the globval block in %appdata%\roaming\cabal\config?
17:51:27 <arkeet> as far as I know about --global, never use --global
17:51:32 <srhb> Murad: What is the global block config?
17:51:37 <Murad> dedgrant: I did.
17:51:50 <srhb> Murad: paste it on lpaste.net
17:51:50 <dedgrant> Murad: I'm wondering if it's just not maintained :(
17:52:35 <dedgrant> Murad: Also wondering if global is indeed related to the --global option.
17:52:56 <dedgrant> Murad: Sorry to chat and run, but I have an appointment.
17:53:03 <Murad> http://lpaste.net/805694448359964672
17:53:10 <ski> StrangeLoop : did you intend `Der Var' to be displayed as  "(1)'"  ?
17:53:17 <Murad> dedgrant: Thank you.
17:53:24 <michaelt> Murad: uncomment the other lines, no?
17:53:45 <Fernandos> can I concatenate the output of a function with a string? => putStrLn "Most Frequent: " ++ seqs
17:53:51 <Fernandos> so far that errors
17:53:51 <Murad> michaelt: So, the -- are comments?
17:54:02 <michaelt> yes
17:54:07 <srhb> Fernandos: putStrLn takes only one argument
17:54:12 <Fernandos> and print?
17:54:13 <srhb> Fernandos: You're giving it three
17:54:26 <StrangeLoop> ski: Yes... that's what you get when you derive a variable
17:54:29 <srhb> Well actually no, precedence makes things funny
17:54:36 <buttbutter> Why do I get a parse error on where? http://lpaste.net/133469
17:54:40 <srhb> Fernandos: putStrLn ("Foo" ++ anotherString)
17:54:48 <srhb> Murad: Yes
17:54:56 <Murad> michaelt: Thank you. That's almost certainly what the problem was. I'm surprised I didn't find this anywhere, though I suppose I must have seen uncommented lines in all the examples but have overlooked the difference. Thanks again!
17:55:07 <Murad> srhb: Thank you, too.
17:55:15 <srhb> No worries, all I did was rant at you. :-)
17:55:20 <buttbutter> Also, I'm unsure about where "where" should be indented. Is it relative to the function? Does it strictly matter how much I indent the "where"?
17:55:34 <srhb> buttbutter: Where should be indented less than the function body
17:55:43 <Murad> srhb: Haha, thanks for the "wisdom". :P
17:55:45 <michaelt> Murad: I think the commented material you see is the defaults cabal is using, or that the idea
17:55:56 <buttbutter> srhb: OKay, so I can't put where after the "=" signs, right?
17:56:05 <srhb> buttbutter: Not only can, you must
17:56:12 <Murad> michaelt: Well, it probably was before I changed the prefix.
17:56:16 <buttbutter> Wait, what :O
17:56:17 <srhb> buttbutter: Er, unless by "after" you mean "further in"
17:56:24 <buttbutter> srhb: I do
17:56:34 <buttbutter> Is what I posted in the lpaste correct?
17:57:12 <srhb> buttbutter: No, you have unmatched parens
17:57:13 <ski> StrangeLoop : with your notation, i would have expected `Der Var' to either be rendered as  "(x)'"  or as  "1"
17:57:23 <srhb> buttbutter: ((())
17:57:24 <buttbutter> srhb: Oh xD
17:57:31 <buttbutter> But, the identation of where is correct, right?
17:57:41 <srhb> buttbutter: It's Not Wrong^TM
17:57:44 <Fernandos> srhb: putStrLn ("Hottest:" ++ unlines(kmerTop))  worked
17:57:59 <buttbutter> srhb: I'd prefer it if I could put "where" after the "=" of the function :(
17:58:06 <buttbutter> MOre readable imo. Oh well.
17:58:09 <srhb> buttbutter: You can.
17:58:11 <StrangeLoop> ski: Der Var will be displayed as "(1)"
17:58:12 <buttbutter> Oh
17:58:40 * hackagebot socket 0.1.0.1 - A binding to the POSIX sockets interface  http://hackage.haskell.org/package/socket-0.1.0.1 (LarsPetersen)
17:58:44 <srhb> buttbutter: Personally I find your layout mildly horrifying. let me fix it.
17:59:16 <buttbutter> srhb: :(
17:59:31 <buttbutter> srhb: Okay. Just learning. All the strict indentation is a bit odd...coming from a C-heavy background.
17:59:34 <buttbutter> But I like it :D
17:59:37 <srhb> buttbutter: That's fine :) 
17:59:54 <srhb> buttbutter: mildly horrifying is my code word for "my eyes don't like that"
18:00:27 <ski> StrangeLoop : not using <http://lpaste.net/revision/133466>, which is currently the latest revision pasted at <http://lpaste.net/133453> .. until just now, that is, ty :)
18:01:23 <buttbutter> srhb: http://lpaste.net/133471 that's what I have now, but I now get that error :(
18:01:36 <srhb> buttbutter: That's because your types don't match up.
18:02:02 <StrangeLoop> ski: I am constantly making changes, based on your (much appreciated, btw) suggestions. I might have made a mistake there and fixed it without even noticing
18:02:03 <arkeet> sumList is a function, not a number.
18:02:03 <buttbutter> What's the issue?
18:02:04 <srhb> buttbutter: sumlist is a function, but you're trying to divide it with something
18:02:14 <srhb> Function divided by foo is ????????
18:02:17 <arkeet> (also, Num doesn't let you divide, you need at least Fractional)
18:02:19 <buttbutter> Oh, derp, forgot to pass it the list
18:02:35 <buttbutter> So I need to change the typeclass to Fractional?
18:02:37 <ski> StrangeLoop : no worry :)
18:02:44 <srhb> buttbutter: Yes, but it will tell you that.
18:02:48 <buttbutter> Okay, neato.
18:02:48 <arkeet> well, see what type error you get. :-)
18:02:49 <buttbutter> Thanks!
18:02:55 <ski> StrangeLoop : as i suspected, you can skip the `Parser',`parse' (and `i') parts of the implementation of `ln' (and likewise for  many'  as mentioned before)
18:03:24 <buttbutter> Yay, it works!
18:03:26 <ski> (StrangeLoop : if you're unsure of what i mean by that, i'll be happy to elaborate)
18:03:30 <srhb> buttbutter: You should fix a few things
18:03:45 <StrangeLoop> What do you mean "skip" them?
18:03:56 <buttbutter> srhb: What else?
18:03:57 <srhb> buttbutter: Can you repaste the working code?
18:04:00 <buttbutter> srhb: Sure
18:04:11 <StrangeLoop> (Just realized I am having breakfast with my girlfriend in, like, three hours)
18:04:19 <srhb> StrangeLoop: Woo! :-)
18:04:27 <StrangeLoop> ski: I'll be happy if you did
18:04:34 <srhb> Sleep is for old people.
18:04:41 <StrangeLoop> Well, I am old
18:04:42 <buttbutter> http://lpaste.net/133472
18:04:47 <srhb> Me too. I just pretend not to be,
18:05:00 <StrangeLoop> I'll be 30 in a few months :| |: :|
18:06:04 <lpaste> srhb annotated “No title” with “No title (annotation)” at http://lpaste.net/133472#a843506597404606464
18:06:25 <srhb> buttbutter: ^^^ -- I fixed the odd foo(bar) style with some composition and indented it according to my taste
18:06:31 <ski> StrangeLoop : currently, the `do' in  many'  and the (latter) `do' in `ln' are using the list monad (iow, basically `concatMap', or list comprehensions, if you prefer). you do this, passing around the state (`i'), in exactly the same way as is being done in the definition of `(>>=)' for your `Parser'
18:06:37 <arkeet> I see we have similar tastes.
18:06:45 <srhb> buttbutter: The first you should respect, the second (you should also respect but) is up to your taste. ;-)
18:06:45 <arkeet> too bad the = for sumList don't line up.
18:06:47 <SrPx> Why anything category-theoretic ends up as typeclasses? I mean - I know. but is there any (deeper) relationship between typeclasses and category theory? 
18:07:01 <srhb> arkeet: That was a mistake :(
18:07:12 <buttbutter> srhb: Does the "." perform function composition?
18:07:17 <ski> StrangeLoop : therefore, you can replace these `Parser (\i -> do ...; return (...,i))' things by calls to (that) `(>>=)' (or equivalently, using the `do' syntactic sugar notation)
18:07:19 <mac10688> isn't someone on here that helps develop fpcomplete.com?
18:07:23 <lpaste> srhb revised “No title (annotation)”: “No title” at http://lpaste.net/843506597404606464
18:07:26 <arkeet> srhb: also personally I wouldn't use . there :-)
18:07:30 <srhb> arkeet: Oh?
18:07:37 <arkeet> personally.
18:07:51 <srhb> You'd use fromIntegral $ numElem ... ?
18:07:58 <arkeet> no, I wouldn't use $ either.
18:08:01 <buttbutter> srhb: Nvm, found a great stackoverflow post with . and $ :D
18:08:10 <srhb> buttbutter: Good, and yes it does :)
18:08:15 <srhb> buttbutter: It's o from maths
18:08:23 <arkeet> I'd just drop the redundant parenthese from the original
18:08:28 <arkeet> parenthesesss
18:08:28 <ski> StrangeLoop : concretely `Parser $ \i -> do (e,s) <- parse (parens m) i; return (Log e, s)' becomes just `do e <- parens m); return (Log e)' .. and something similar for  many'
18:08:32 <srhb> arkeet: True.
18:08:42 <arkeet> actually
18:09:05 <lpaste> arkeet annotated “No title” with “arkeet style” at http://lpaste.net/133472#a133473
18:09:06 <ski> (er, one closing bracket to much, s/parens m\)/parens m/)
18:09:22 <srhb> arkeet: Yep, that's fine. I'd probably do that was well.
18:09:32 <srhb> The nice thing about using . is the extra constraints.
18:09:33 <arkeet> (note I got rid of the x:xs)
18:09:35 <srhb> If you make a type error.
18:11:01 <buttbutter> srhb: Great. Makes sense. Thanks for your thorough help.
18:11:18 <srhb> buttbutter: No problem. :) Check out arkeet s annotation too
18:11:47 <arkeet> I can't decide whether I like where on its own line, or if it should go on the end of the previous line.
18:12:01 <StrangeLoop> ski, that doesn't work :|
18:12:04 <srhb> arkeet: Which part?
18:12:11 <arkeet> like
18:12:14 <arkeet> meanList xs = sumList xs / fromIntegral (numElem xs)
18:12:15 <arkeet> er
18:12:18 <arkeet> meanList xs = sumList xs / fromIntegral (numElem xs) where
18:12:21 <arkeet> and then stuff 
18:12:22 <srhb> Ah.
18:12:39 <srhb> I always put where on its own line. I like to get the high level overview first, but as uncluttered as it cna be
18:12:44 <ski> StrangeLoop : note how in going from `Parser $ \i -> do (e,s) <- parse (parens m) i; return (Log e, s)' to `do e <- parens m; return (Log e)', we "skip" the `Parser $ \i ->', `(...,s)', `parse (...) i' parts. i hope it's now clearer what i meant
18:12:48 <arkeet> yeah I think I prefer it this way.
18:12:51 <arkeet> on its own line.
18:13:04 <buttbutter> arkeet: Oh, hm. I wanted to do that at first but thought the where might complain
18:13:07 <buttbutter> Since it uses the "x"
18:13:15 <srhb> buttbutter: You can put where almost anywhere
18:13:15 <buttbutter> But I like what you did, arkeet :D
18:13:22 <arkeet> it doesn't actually use the x.
18:13:24 <srhb> buttbutter: It's a reserved word, so you get lots of freedom
18:13:28 <arkeet> the x in meanList and sumList are different.
18:13:34 <buttbutter> arkeet: Right, but where does.
18:13:41 <buttbutter> So I thought I needed it.
18:14:04 <srhb> buttbutter: no, the functions in where are just that, functions. You could define them outside of the function scope as well.
18:14:05 <arkeet> where can go wherever you want, as long as it's indented further than the definition it attaches to.
18:14:07 <StrangeLoop> Is there any way to add functional dependencies? Like Mul _ 0 = Lit 0 ?
18:14:31 <buttbutter> srhb: Makes sense :)
18:14:36 <arkeet> and yes, sumList could be a top level thing.
18:14:50 <srhb> buttbutter: They _can_ use the arguments given to the function they are attached to, but when you use x in it, it actually shadows the original x 
18:15:04 <srhb> rather, the equation they are attached to*
18:15:20 <ski> StrangeLoop : does it work if you fix my typo, or did i err more ?
18:15:25 <srhb> And I mean, when you use x on the left hand side of = in sumList, you redefine it
18:15:28 <srhb> And thus shadow the old one
18:16:03 <srhb> Also what the hell _is_ butt butter.
18:16:11 <Clint> um
18:16:16 <ski> StrangeLoop : you could make a separate simplification function on expressions (where it might be preferred to simplify `Der a' by calling `d', as opposed to doing it in the display function)
18:16:28 <buttbutter> Oh, one more question. Why does the compiler complain when I try fromIntegral . numElem xs?
18:16:29 <StrangeLoop> ski: http://lpaste.net/133453 <--- this returns an error
18:16:34 <buttbutter> I.e. getting rid of the parens.
18:16:41 <arkeet> well, you have butt, and then you have more butt. i.e. butter.
18:16:51 <arkeet> because
18:16:51 <buttbutter> arkeet:  :D
18:16:58 <arkeet> that parses as fromIntegral . (numElem xs)
18:17:04 <buttbutter> srhb: It's a euphemism for poo, actually.
18:17:08 <arkeet> function application binds tighter than any operator.
18:17:09 <srhb> ... oh
18:17:13 <buttbutter> srhb: ^_^
18:17:21 <arkeet> numElem xs isn't a function, so that doesn't typecheck.
18:17:22 <srhb> I was being way more creative in my mind.
18:17:30 <buttbutter> arkeet: "binds tighter"?
18:17:43 <arkeet> as in higher operator precedence.
18:17:45 <srhb> buttbutter: foo bar / is not foo applied to bar and (/)
18:17:46 <ski> StrangeLoop : which error ?
18:18:02 <ski> (StrangeLoop : also, you should keep the `string "ln"' part)
18:18:03 <srhb> buttbutter: Because (/) has (much) lower precedence than function application.
18:18:09 <arkeet> any operator does.
18:18:14 <buttbutter> srhb: but isn't (/) a function?
18:18:16 <srhb> Yes
18:18:18 <arkeet> is an operator.
18:18:20 <srhb> but it is also an infix operator
18:18:21 <arkeet> / is an operator.
18:18:25 <arkeet> (thanks irc client)
18:18:29 <arkeet> and so is .
18:18:29 <srhb> :P
18:18:36 <StrangeLoop> A very informative "something went wrong" error e la line 16
18:18:51 <buttbutter> Oh. So does the (/) take precedence over the (.) since Haskell is left associative?
18:18:55 <ski> (`(/)' is an expression, `/' is an operator)
18:18:58 <srhb> buttbutter: Other way around
18:19:00 <buttbutter> So it just tries to divide fromIntegral or something?
18:19:04 <buttbutter> Oh D:
18:19:05 <arkeet> no no
18:19:09 <srhb> buttbutter: (.) has higher precedence than (/)
18:19:14 <srhb> What?
18:19:15 <buttbutter> Oh.
18:19:19 <ski> StrangeLoop : ok, so a run-time error (in this case run-time parsing error). try adding `string "ln"' back in ?
18:19:29 <srhb> So it is applied _before_ /
18:19:37 <buttbutter> But that seems like it should work then.
18:19:37 <arkeet> the full thing parses like (sumList xs) / (fromIntegral . (numElem xs))
18:19:38 <srhb> Isn't it?
18:19:40 <StrangeLoop> \m/ \m/
18:19:42 * srhb is confused now
18:19:43 <buttbutter> Ohhh.
18:19:51 <buttbutter> OKay, wait wait.
18:19:56 <arkeet> the problem is in the last bit, with fromIntegral . (numElem xs)
18:19:58 <buttbutter> I'm confused.
18:20:00 <srhb> No, I'm right.
18:20:14 <arkeet> this is very different from (fromIntegral . numElem) xs
18:20:26 <arkeet> the former is a type error, because numElem xs isn't a function.
18:20:31 <srhb> (.) is infixr 9 whereas (/) is infixl 7
18:20:37 <buttbutter> Okay, how does the compiler interpret fromINtegral . numElem xs? Can you show me with parens?
18:20:42 <arkeet> I just did.
18:20:51 <buttbutter> arkeet: The first line?
18:20:54 <arkeet> multiple times.
18:20:58 <arkeet> fromIntegral . (numElem xs)
18:20:59 <buttbutter> fromIntegral . (numElem xs) <-- ?
18:21:02 <buttbutter> Okay.
18:21:15 <srhb> That would be "compose the fromIntegral function with the function nuMelem xs
18:21:16 <buttbutter> Ohhhh, I see now.
18:21:32 <ski> StrangeLoop : btw, we're implicitly here using the fact that `do string "ln"; (do e <- parens m; return (Log e))' is equal to `do string "ln"; e <- parens m; return (Log e)' (you may compare this to equating `a + (b + c)' with `a + b + c') -- this is a simple fact of how the `do'-notation works (what it expands to, if you prefer)
18:21:37 <buttbutter> Because it's function composition it makes no sense to compose fromIntegral with (numElem xs) because (numElem xs) is just a number.
18:21:42 <srhb> Yep!
18:21:54 <buttbutter> Tricky!
18:22:02 <srhb> Not after a while :-)
18:22:15 <buttbutter> So *why* does it intrepret it as fromIntegral . (numElem xs)?
18:22:22 <buttbutter> What rule governs that?
18:22:40 <arkeet> function application has higher precedence than any operator.
18:22:42 <ski> @undo do x <- foo; (do y <- bar x; baz x y)
18:22:42 <lambdabot> foo >>= \ x -> (bar x >>= \ y -> baz x y)
18:22:45 <ski> @undo do x <- foo; y <- bar x; baz x y
18:22:45 <lambdabot> foo >>= \ x -> bar x >>= \ y -> baz x y
18:22:46 <geekosaur> function application binds tighter than any operator
18:22:56 <buttbutter> arkeet: And it applies the functions right-to-left, right?
18:23:06 <arkeet> no, it parses them in order of precedence.
18:23:12 <arkeet> that's the whole point.
18:23:14 <srhb> buttbutter: Yes, and what arkeet said
18:23:19 <buttbutter> But, for a user-defined function, how does it know which function has higher precedence over another?
18:23:31 <ski> buttbutter : no
18:23:33 <arkeet> function, or operator?
18:23:36 <srhb> buttbutter: functions that are not infix operator ALWAYS have highest precedence
18:23:51 <arkeet> function application is just
18:23:52 <srhb> buttbutter: Operators (which symbol names always are) can have user defined precedence
18:23:54 <buttbutter> srhb: Right, but if I have TWO functions with highest precedence, it goes right-to-left, correct?
18:23:57 <arkeet> putting two things next to each other (separated by space)
18:24:14 <srhb> buttbutter: Depends, you might get an error 
18:24:22 <ski> buttbutter : `f g h' always means `(f g) h'. if you mean `f (g h)' you'll have to say that (or some equivalent way of expressing it, like perhaps `f $ g h')
18:24:29 <arkeet> let's be clear.
18:24:34 <arkeet> _functions_ don't have precedence.
18:24:34 <buttbutter> ski: Okay, that makes sense.
18:24:42 <srhb> arkeet: functions that _are not_ operators
18:24:42 <buttbutter> arkeet: Oh.
18:24:46 <srhb> arkeet: cf. the language report
18:24:55 <arkeet> when I say operators, I mean operators, without () around them.
18:24:59 <arkeet> isn't a function.
18:25:01 <arkeet> (/) is a function.
18:25:03 <arkeet> / isn't a function.
18:25:08 <buttbutter> ...and if you have operations AND functions? What happens first?
18:25:09 <buttbutter> I'm confused :(
18:25:14 <srhb> buttbutter: Functions.
18:25:14 <buttbutter> operatorS*
18:25:22 <buttbutter> So functions DO have precdence. Over operators.
18:25:24 <arkeet> no.
18:25:26 <buttbutter> wat
18:25:28 <arkeet> function application does.
18:25:28 <srhb> Yes!
18:25:33 <arkeet> function application is not functions.
18:25:39 <arkeet> functions are things like sumList
18:25:43 <buttbutter> arkeet: Okay. Sure.
18:25:44 * srhb thinks terminology battle is not helping here, goes afk :P
18:25:46 <ski> ..  `mod`  is an operator (with a certain precedence and associativity)
18:25:51 <buttbutter> srhb: Thanks for your help.
18:25:51 <arkeet> I think it's important to be clear.
18:25:57 <buttbutter> I see now.
18:26:02 <ski> ..  mod  is an expression (an identifier) (which happens to be a function)
18:26:29 <arkeet> 5 is an expression, which may or may not be a function, depending on the inferred type.
18:26:29 * Axman6 mentions fixity and then runs
18:26:30 <buttbutter> So operators are always infix function applications composed of special characters, right?
18:26:38 <arkeet> that's one case.
18:26:42 <arkeet> the other case is things like `elem`
18:26:43 <arkeet> or `div`
18:26:45 <buttbutter> arkeet: Oh.
18:27:01 <Axman6> > 2 + 4 `elem` [1..5]
18:27:04 <buttbutter> So any function application takes precedence over any infix function application?
18:27:04 <lambdabot>  False
18:27:07 <arkeet> operators are formed by either symbols, or by an identifier enclosed in ``
18:27:20 <arkeet> they have their own precedence
18:27:29 <arkeet> which may be specified with infix/infixl/infixr keywords
18:27:41 <buttbutter> Ah. Interesting.
18:27:56 <arkeet> e.g. infixr 9 .
18:27:59 <arkeet> infixl 7 `mod`
18:28:02 <arkeet> . and `mod` are operators.
18:28:19 <arkeet> since 9 is higher than 7, 
18:28:26 <arkeet> a `mod` b . c will be parsed like a `mod` (b . c)
18:28:31 <buttbutter> but mod 7 6 is just a function application, right?
18:28:35 <arkeet> yes.
18:28:43 <arkeet> so the precedence of `mod` is irrelevant for that.
18:29:03 <arkeet> the r and l just specify how operators of the *same* precedence group.
18:29:07 <arkeet> for example:
18:29:17 <arkeet> a . b . c means a . (b . c), because . is infixr (right-associative)
18:29:25 <arkeet> a `mod` b `mod` c means (a `mod` b) `mod` c, becuase `mod` is infixl
18:29:39 <buttbutter> Ah! Okay.
18:29:42 <buttbutter> I understand :DDD
18:29:58 <arkeet> if it was just infix (not infixr or infixl), it would be an error.
18:30:11 <arkeet> so we have infix 4 <
18:30:12 <arkeet> which means
18:30:17 <arkeet> a < b < c is a syntax error
18:30:20 <arkeet> > a < b < c
18:30:22 <ski> StrangeLoop : oh, and you can simplify `der' in the same way
18:30:22 <lambdabot>      Precedence parsing error
18:30:22 <lambdabot>          cannot mix ‘<’ [infix 4] and ‘<’ [infix 4] in the same infix expression
18:30:36 <arkeet> (also you can't mix infixr and infixl of the same level)
18:30:58 <arkeet> but the point we were trying to make earlier is that
18:31:13 <arkeet> function application (like f x)
18:31:22 <arkeet> always groups tighter than any operators.
18:31:34 <arkeet> so
18:31:43 <ski> StrangeLoop : rather than repeating earlier suggestions, as i don't see anything more i'd like to comment on, and as you're probably more or less asleep atm, i'll shut up here. have fun !
18:31:52 <arkeet> a % b c always means a % (b c), no matter what precedence % may have been given.
18:32:25 <buttbutter> Yup, I see how you got the fromIntegral . (numElem xs) now. :)
18:32:30 <arkeet> okay :)
18:32:38 <buttbutter> Thanks a lot for your explanation, arkeet :D
18:32:56 <StrangeLoop> ski: I am actually furiously coding a simplification function :D
18:33:09 <ski> in some academic papers, function application is written explicitly. commonly using the symbol `@'. then one'd write arkeet's expression as `a % b @ c', which parses as `a % (b @ c)', since `@' has the highest precedence (and is left-associative)
18:33:23 <arkeet> buttbutter: incidentally, here's a little trick to find out the precedence of any operator:
18:33:31 <arkeet> > (0$0.)
18:33:33 <lambdabot>      The operator ‘.’ [infixr 9] of a section
18:33:33 <lambdabot>          must have lower precedence than that of the operand,
18:33:33 <lambdabot>            namely ‘$’ [infixr 0]
18:33:39 <arkeet> the error tells me that . is infixr 9
18:34:01 <arkeet> > (0$0/)
18:34:02 <lambdabot>      The operator ‘/’ [infixl 7] of a section
18:34:02 <lambdabot>          must have lower precedence than that of the operand,
18:34:02 <lambdabot>            namely ‘$’ [infixr 0]
18:34:51 <ski> (record construction&update, and some notations in patterns, could be said to have higher precedence than function application, in Haskell)
18:34:51 <arkeet> but usually you can just ask ghci (with :info) about an operator 
18:35:11 <buttbutter> Oh, cool. 
18:35:32 <arkeet> ski: sure, which is why I try to be careful to say function application has higher precedence than any operator, not everything else.)
18:35:47 <ski> > (,) () Node {rootLabel = (), subForest = []}
18:35:49 <lambdabot>  ((),Node {rootLabel = (), subForest = []})
18:36:38 <ski> (you could construe `@' in `foo xs@(x:_) = x:xs' to be an operator)
18:36:56 <arkeet> I wouldn't. :-)
18:37:22 * ski grins
18:37:32 <buttbutter> arkeet: If you don't mind, can you explain what's going on with the (0$0.) trick?
18:37:48 <arkeet> okay, so we have something called sections
18:37:52 <arkeet> like (+ 5)
18:38:01 <arkeet> or ("abc" ++)
18:38:01 <platz> i have a lib with EitherT err IO a .  thinking about refactoring to mtl or the 'exceptions' lib, which would be fun for learning, but probably bad for the few folks who already dl'd it
18:38:04 <arkeet> have you seen things like that?
18:38:09 <buttbutter> arkeet: no :(
18:38:11 <arkeet> oh.
18:38:29 <arkeet> well what they do is just
18:38:34 <arkeet> for example, (+ 5) is the same as \x -> x + 5
18:38:42 <arkeet> it lets you partially apply an operator on one side.
18:38:43 <Axman6> > map ("abc" ++) $ words "hello world cat"
18:38:46 <lambdabot>  ["abchello","abcworld","abccat"]
18:38:54 <arkeet> > map (+ 5) [1,2,3]
18:38:55 <lambdabot>  [6,7,8]
18:39:09 <arkeet> well, you can put a big expression inside too.
18:39:11 <buttbutter> arkeet: I haven't seen the \x -> x + 5 notation yet either.
18:39:16 <arkeet> oh.
18:39:18 <buttbutter> xD
18:39:26 <buttbutter> Just starting out with real world haskell/learn you a good haskell
18:39:31 <arkeet> well it's just a function that takes x and returns x+5
18:39:39 <buttbutter> Yeah, I figured.
18:39:44 <arkeet> that notation is called a lambda.
18:39:49 <arkeet> (or "anonymous function")
18:40:00 <arkeet> anyway.
18:40:08 <arkeet> you can put big expressions inside a section
18:40:12 <ski> buttbutter : for some strange reason, while `(2 * 3 +)' (interpreted as `((2 * 3) +)') means the same as `\x -> 2 * 3 + x' (iow `\x -> ((2 * 3) + x)'), `(2 + 3 *)' doesn't mean the same as `\x -> 2 + 3 * x' (meaning `\x -> (2 + (3 * x))'). instead `(2 + 3 *)' is disallowed
18:40:18 <arkeet> > (+ 2 * 3) 0
18:40:19 <lambdabot>  6
18:40:36 <Axman6> wait...
18:40:41 <arkeet> yeah ski said it.
18:40:47 <buttbutter> Right. I see. The section is literally just a function.
18:40:54 <arkeet> the thing is that
18:41:01 <Axman6> I think that only works because lambdabot has some strange num instances
18:41:03 <arkeet> what should (2 + 3 *) mean?
18:41:11 <buttbutter> What does iow mean?
18:41:17 <ski> "in other words"
18:41:20 <arkeet> should it be the same as (5 *), or should it be \x -> 2 + 3 * x?
18:41:27 <arkeet> these are different, because * has higher precedence than +
18:41:35 <ski> arkeet : the latter, obviously ;)
18:41:41 <arkeet> well yes, but
18:41:44 <arkeet> ;)
18:41:54 <arkeet> instead of choosing to resolve this, haskell just makes it an error
18:41:57 <buttbutter> I don't understand why it would be disallowed.
18:42:01 <arkeet> to have some low precedence operator in a section
18:42:07 <buttbutter> Seems like \x -> 2 + 3 * x is the obvious thing.
18:42:21 <arkeet> well there are arguments both ways.
18:42:37 <arkeet> so instead of surprising people with one thing and not the other, haskell just makes it an error.
18:42:40 <buttbutter> But in conclusion, (0$0.) exploits that to produce an error and get infix/precedence values.
18:42:46 <arkeet> right.
18:42:54 <ski> buttbutter : iow, for some reason, the operator that is "sectioned" must (in terms of abstract syntax, cf. parse trees) be the "top"/main operator of the section. in `(2 + 3 *)', `*' is "subordinate" to `+', and Haskell doesn't allow that
18:42:56 <arkeet> because $ has lowest precedence (infixr 0)
18:43:15 <buttbutter> Right.
18:43:22 <buttbutter> I understand. Neat :D
18:43:50 <buttbutter> Surprising how much neat stuff you can turn over with a simple mean function :P
18:43:51 <arkeet> (it doesn't matter that 0 $ 0 doesn't typecheck, because that happens after syntax checking)
18:44:58 <buttbutter> ski: I'm a bit confused as to why '*" is "subordinate". Is that just an ordering thing?
18:45:40 <ski> arkeet : obviously i'm not suggesting that something like `(2 * (3 +))' should mean `\x -> 2 * (3 + x)'. but i think it's reasonable to allow sections like `(2 + 3 *)', where the "sectioned operator" is "subordinate", as long as it isn't concretely syntactically enclosed in further brackets (and this can only work here because `2 + 3 * x' will parse as `2 + (3 * x)', due to precedence/associativity)
18:46:25 <ski> buttbutter : in `(1 / 2) * (3 - 4)' i would call `*' the main operator, and `/' and `-' subordinate ones (subordinate to `*')
18:46:46 <buttbutter> I see.
18:46:51 <arkeet> ski: well of course (2 * (3 +)) shouldn't mean that, because it already means something else.
18:47:07 <ski> arkeet : *nod* (hence "something like" :)
18:47:42 <arkeet> but I think there's some argument that * should be the main operator in (blah *), regardless of what blah is composed of.
18:47:50 <arkeet> maybe not a very strong one.
18:47:57 <ski> (some people might argue (have argued) that `2 * (3 + _)' should mean `\x -> 2 * (3 + x)' ..)
18:49:39 <johnw> ski: that's what Boost.Bind does in C++
18:50:00 <Hafydd> I think Mathematica has something similar.
18:50:03 <felixn> https://gist.github.com/munro/2b60ba19ddfaa47b0990#file-funnetwork-hs-L95-L106 <-- so I'm trying to model network communication with Haskell, which is pretty fun, but I can't figure out how to build a monad that waits until a message is received
18:50:04 <ski> johnw : how do they delimit ?
18:50:16 <johnw> boost::bind(2 * (3 + _1))
18:50:25 <ski> ok
18:50:57 <ski> johnw : how about nesting applications of `boost::bind' ?
18:51:12 <johnw> i doubt that's possible
18:51:17 <johnw> maybe, never seen it
18:52:00 <felixn> big picture is I want to experiment with a network algorithm, and not have to run a bunch of real TCP sockets for testing.  but at the moment, this is a fun exercise for me!
18:54:16 <enthropy> scala does the _ thing too
19:03:54 <Pamelloes> is (b -> c) equal to (b -> c -> d) or (a -> b -> c) or both?
19:05:10 <f|`-`|f_> hmmm
19:05:30 <f|`-`|f_> b -> c is most similar to a -> b -> c
19:06:06 <arkeet> none of them are equal.
19:06:18 <arkeet> I don't know what you want "equal" to mean.
19:06:37 <pavonia> The latter two are equivalent
19:06:47 <arkeet> sure, if you rename variables.
19:08:30 <Pamelloes> Let me rephrase that a bit. Given a type (b -> c). If b is fixed but c is not, can b -> c become b -> c -> d. Similarly, if c is fixed but b is not can (b -> c) become (a -> b -> c). Sorry for the lack of clarity
19:08:43 <arkeet> yes, and no.
19:08:48 <arkeet> because a -> b -> c always means a -> (b -> c)
19:08:58 <Pamelloes> Ok, that makes sense
19:09:26 <pavonia> arkeet: But that would be an infinte type, no?
19:09:44 <arkeet> what would?
19:09:50 <arkeet> no one is substituting things infinitely many times.
19:09:57 <pavonia> b -> c ~ b -> c -> d
19:10:14 <arkeet> c on the left is not c on the right.
19:10:31 <arkeet> forall c. b -> c can unify with forall c d. b -> c -> d
19:11:05 <pavonia> Hhm, maybe I misunderstand the question
19:11:43 <arkeet> one can substitute c with c -> d to turn b -> c into b -> c -> d
19:12:03 <pavonia> yes
19:13:09 <DuckBoy> how i can install the latest ghc and cabal in a linux system ? 
19:13:23 <DuckBoy> i already downloaded them 
19:13:29 <DuckBoy> as a package 
19:14:10 <Pamelloes> DuckBoy: linux refers to a kernel not a specific operating system so there is no one answer for that. What operating system are you running?
19:14:20 <pavonia> :t (undefined :: forall c. b -> c) `asTypeOf` (undefined :: forall c d. b -> c -> d)
19:14:21 <lambdabot> Not in scope: type variable ‘b’
19:14:21 <lambdabot> Not in scope: type variable ‘b’
19:14:47 <arkeet> DuckBoy: put another way, what linux distribution are you using?
19:14:52 <jle`> forall is an all-or-nothing kind of deal
19:15:19 <Pamelloes> :t forall b. (undefined :: forall c. b -> c) `asTypeOf` (undefined :: forall c d. b -> c -> d)
19:15:20 <lambdabot>     Not in scope: ‘forall’
19:15:20 <lambdabot>     Perhaps you meant ‘forAll’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
19:15:21 <lambdabot>     Precedence parsing error
19:15:27 <Pamelloes> Well then.
19:15:28 <arkeet> DuckBoy: also, read https://www.haskell.org/downloads/linux
19:15:36 <jle`> :t forAll
19:15:38 <lambdabot> (Show a, STestable prop) => Gen a -> (a -> prop) -> Test.QuickCheck.Safe.SProperty
19:15:39 <arkeet> for ubuntu, read https://launchpad.net/~hvr/+archive/ubuntu/ghc
19:22:12 <mmaroti> Hi Guys! Quick question: This fails with stack overflow "forM [1 .. 1000000] return"
19:22:32 <StrangeLoop> OK, going to sleep now
19:22:38 <StrangeLoop> ski: Thank you so much for your help
19:22:39 <mmaroti> Can someone suggest how to solve this?
19:24:09 <prsteele> mmaroti: I'd guess its because of lazyness, sum [1..1000000] can fail as well
19:24:15 <ski> StrangeLoop : yw. later
19:24:45 <pavonia> > forM [1 .. 1000000] return :: Maybe [Int]
19:24:47 <lambdabot>  *Exception: stack overflow
19:24:56 <mmaroti> No, sum [1..1000000] works fine, it uses foldl' I guess
19:25:05 <arkeet> > sum [1..1000000]
19:25:09 <lambdabot>  *Exception: stack overflow
19:25:23 <prsteele> @src sum
19:25:23 <lambdabot> sum = foldl (+) 0
19:25:25 <f|`-`|f_> > foldl' [1..1000000]
19:25:28 <lambdabot>      Couldn't match expected type ‘b -> a -> b’
19:25:28 <lambdabot>                  with actual type ‘[Integer]’
19:25:28 <lambdabot>      In the first argument of ‘foldl'’, namely ‘[1 .. 1000000]’
19:25:32 <arkeet> > forM [1..1000000] return :: Identity [Int]
19:25:36 <lambdabot>  Identity [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,...
19:25:40 <prsteele> @src forM
19:25:40 <lambdabot> forM = flip mapM
19:25:45 <f|`-`|f_> > foldl' (+) 0 [1..1000000]
19:25:45 <prsteele> @src mapM
19:25:45 <lambdabot> mapM f as = sequence (map f as)
19:25:47 <mniip> Identity is lazy enough
19:25:47 <lambdabot>  500000500000
19:26:04 <Axman6> mmaroti: it's pretty easy to write a forM which doesn't overflow by using an accumulating parameter list, and reversing it once you get to []
19:26:10 <mmaroti> But if you do it in the IO monad, then it fails
19:26:32 <mmaroti> Ok, so is there such a function in the standard library?
19:26:42 <mmaroti> (I guess the result would be reversed then, no?)
19:27:14 <prsteele> mmaroti: I'm guessing you could define a strict version of mapM easily enough, and then just define forM as flip . mapMStrict
19:27:51 <pavonia> @src sequence
19:27:51 <lambdabot> sequence []     = return []
19:27:51 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
19:27:51 <lambdabot> --OR
19:27:51 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
19:28:41 <mmaroti> What I mean by reversed is this. A strict version would consume the list from the head, and accumulate the result, so the output values would be reversed in the list.
19:29:51 <kristof> mmaroti: You can see that sequence does the consing in reverse order to preserve the original order
19:30:10 <kristof> both in the recursive definition and in the right associative cons definition
19:31:55 <mmaroti> so can I use this "strictSequence xs = foldl' (liftM2 (flip (:))) (return []) xs"?
19:34:56 <pavonia> .oO(unsafeInterleaveIO)
19:39:47 <dolio> mmaroti: Upgrade to 7.10.
19:39:59 <dolio> Or turn off stack overflows.
19:40:02 <mmaroti> How is it done in 7.10?
19:40:15 <dolio> Stack overflows are off by default in 7.10.
19:40:31 <prsteele> mmaroti: you just start chewing up RAM
19:40:41 <mmaroti> I see
19:40:56 <mmaroti> But is it possible at all to implement it without turning off stack overflows?
19:41:05 <mmaroti> I do not see a way...
19:41:10 <dolio> 'Strict' doesn't mean 'doesn't stack overflow' by the way.
19:42:10 <mmaroti> is "stack overflow" = too deeply nested thunk?
19:42:15 <dolio> No.
19:42:27 <dolio> That's one reason, but it's not equal.
19:42:48 <f|`-`|f_> simply, too many thunks
19:43:01 <mmaroti> Ok, then why does "mapM return [1 .. 1000000]" runs out of stack?
19:43:31 <f|`-`|f_> it has about a million thunks?
19:43:50 <dolio> Stack is used when matching. You push the continuations for the cases on a stack and evaluate the thing you're matching against.
19:43:54 <mmaroti> You can sum this list with no problem, that does not have the problem
19:43:56 <dolio> It has nothing to do with thunks.
19:44:26 <prsteele> > sum [1..10000000]
19:44:31 <lambdabot>  mueval-core: Time limit exceeded
19:44:31 <lambdabot>  mueval: ExitFailure 1
19:44:47 <prsteele> > foldl' (+) 0 [1..1000000]
19:44:49 <lambdabot>  500000500000
19:44:57 <pavonia> mmaroti: You have to store all the intermediate results before you can start building the final list
19:45:24 <mmaroti> ok, I see that I have to store the intermediate results, but cannot you do it like foldl' does?
19:45:27 <dolio> mapM return is using stack because to get a single result, it has to get the entire tail result, because that's how sequencing in IO works.
19:45:32 <igniting> > sum [1..1000000]
19:45:35 <lambdabot>  *Exception: stack overflow
19:45:46 <mmaroti> But you could sequence in the other way, no?
19:45:50 <dolio> However, the real question in this case is: who cares if you're using stack?
19:46:05 <mmaroti> Once you call the first monadic action, you store the result and continue with the rest
19:46:08 <dolio> If you change it to not use stack, you will use heap instead, so what's the difference?
19:47:09 <mmaroti> Ok, I do not have 7.10, and if I could do this with 7.6, I would be happy.
19:47:19 <prsteele> mmaroti: I might be off base, but I think they're asking if you really need a map, and not a fold
19:47:59 <mmaroti> I do need a mapM, I am using an external SAT solver (picosat) and this is the reason I cannot get my result back.
19:48:14 <mmaroti> So I have traced this problem within the picosat library
19:48:19 <geekosaur> +RTS -Ksomething where something is e.g. 8G
19:48:33 <arkeet> dolio: you could use neither!
19:48:40 <geekosaur> may need to compile with -rtsopts
19:48:43 <dolio> arkeet: No, you cannot.
19:49:57 <arkeet> for sum?
19:49:57 <arkeet> I mean
19:49:57 <arkeet> you can use it, but not a whole bunch at once.
19:50:02 <pavonia> prsteele: How would a solution with a fold look like?
19:50:05 <mmaroti> dolio: Are you claiming that this cannot be done without disabling the stack (unlike for non-monadic map)?
19:50:13 <dolio> sum is different.
19:50:26 <Azathoth> Hello, i wanted to ask you something short, if there is a way to print/output a recursive function for it to show step by step the change caused by the function?
19:50:29 <prsteele> pavonia: I didn't know specifically what he was trying to do. I thought maybe he didn't need to the whole list at once, it wasn't a full idea
19:50:30 <dolio> mapM has to either use stack or heap.
19:50:44 <dolio> mmaroti: Am I claiming that what can't be done?
19:51:21 <prsteele> Azathoth: are you asking if you can output something each time it recurses? The quick and dirty solution is trace from Debug.Trace
19:51:23 <dolio> If you don't want to use stack, there are ways of writing it so that happens. But it will be slower than using stack.
19:51:29 <dolio> And probably use at least as much memory.
19:51:33 <mmaroti> dolio: are you claiming that the "mapM return [1 .. 1000000]" cannot be implemented in a way hat uses only large amount of the heap and not the stack?
19:52:13 <mmaroti> If it can be rewritten to use the heap instead then how to do it?
19:52:35 <dolio> Use tail recursion and an accumulator.
19:52:50 <dolio> Either accumulate a list and reverse at the end, or accumulate functions that will build the list.
19:52:52 <mmaroti> I have tried, but not clear how to do it
19:53:46 * hackagebot scalpel 0.2.1 - A high level web scraping library for Haskell.  http://hackage.haskell.org/package/scalpel-0.2.1 (fimad)
19:54:39 <mmaroti> By accumulating functions you mean combining IO actions with bind? Then when you execute that action you run out of stack.
19:55:03 <dolio> mapM' acc _ [] = return (reverse acc) ; mapM' acc f (x:xs) = f x >>= \y -> mapM' (y:acc) f xs
19:56:19 <mmaroti> Let me try it.
19:57:31 <dolio> Oh, and the other place where stack is used is for update thunks.
19:58:41 <dolio> So, when you have something updateable that refers to something updateable that refers ... in a big chain, that will use stack.
19:58:54 <dolio> Because it has to remember where to write back to after it finally finds the value.
19:59:02 <mmaroti> It fails with stack overflow
19:59:09 <mmaroti> I know.
19:59:19 <mmaroti> So can it be implemented or not?
19:59:30 <mmaroti> I do not see a way...
20:00:24 <mmaroti> dolio: Oops, my bad, it works!
20:03:47 * hackagebot b9 0.5.7 - A tool and library for building virtual machine images.  http://hackage.haskell.org/package/b9-0.5.7 (SvenHeyll)
20:04:28 <reduceleft> I'm wondering if there is an equivalent to Scala's "sliding" http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.List@sliding(size:Int):Iterator[Repr] I've looked in Data.List but I don't see it at...
20:04:54 <reduceleft> did I miss it or is there another way to go about that functionaliyt?
20:05:34 <mmaroti> dolio: Thanks!
20:08:32 <prsteele> reduceleft: let f _ [] = []; f n x = take n x : f n (tail x) , but that will have groups smaller than n at the end
20:09:21 <prsteele> reduceleft: but in general check Hoogle, neither Int -> [a] -> [[a]] nor [a] -> Int -> [[a]] turned up anything useful looking
20:09:53 <reduceleft> prsteele: hmm, thanks, yeah I rolled my own too but I was wondering if there was a more standard way I should know about for future references :D
20:10:28 <reduceleft> prsteele: thanks
20:34:58 <mlamari> Is the default costructor for tuple strict?
20:35:08 <mniip> no why would it be
20:37:28 <mlamari> Confused in ghci - let x = 1 + 2 :: Int    then let z = (x, x)    then :sprint z    - I get (_, _) not _
20:38:34 <mniip> mlamari, the constructor is already evaluated
20:39:07 <mlamari> mniip:  So a constructor is evaluated where  a function call isn't?
20:39:08 <mniip> also weird
20:39:25 <mlamari> Does that mean constructors are all strict? Or is this just some ghc/console artifact?
20:39:30 <mniip> when I do what you just said, I get z = _
20:39:50 <mlamari> Doh
20:39:58 <mniip> damn I'm confused
20:39:59 <mlamari> I just restarted and tried and I get (_, _)
20:40:23 <johnw> you actually wrote (x, x) for z, so why would it create a thunk for that part of it?
20:40:24 <mlamari> Note this is off command line GHCI fresh
20:40:47 <geekosaur> ghc version?
20:40:52 <mniip> ah
20:40:54 <geekosaur> I get (_,_) from 7.8.3
20:40:56 <mniip> interesting
20:41:02 <mlamari> Which version gives _ ?
20:41:31 <mniip> Azathoth, why don't you ask in channel instead?
20:41:46 <geekosaur> and I do vaguely recall that 7.8.3 had some "issues" with :sprint
20:41:54 <mniip> mlamari, I was blown away by implicit fromInteger
20:42:05 <mniip> but yes, you explicitly state that z is a (,)
20:42:11 <mniip> why would it need a thunk
20:42:19 <mlamari> Understand, I'm typing this straight out of Marlow's Parallel and Concurrent Programming - his gets (_, _) too he just doesn't EXCEPTS
20:42:27 <mlamari> . .  I mean , doesn't explain why
20:42:46 <geekosaur> well, the tuple constructor is explicit there
20:42:54 <geekosaur> but no reason to evaluate x
20:43:20 <mlamari> I understand the _s, I don't understand why the (,) is exposed
20:43:34 <johnw> a constructor always has O(1) performance, + (or any non-constructor function) may not, so GHC is saving you from building a trivial thunk
20:43:35 <mlamari> He then demonstrates turning z into _ byb putting "swap" in front in the next example
20:44:05 <mlamari> Okay, so this may be some optimization of constructors (which otherwise are functions)
20:44:09 <johnw> if you said: let z = \x -> (x,x); w = z x
20:44:13 <johnw> and then :sprint w, you'll see _
20:47:59 <mjrosenb> is it possible to ask ghc to split an exported function pointer into a FunPtr, and its context?
20:55:39 <resio> hi
21:01:10 <mjrosenb> resio: morning.
21:02:28 <Fernandos> how can I get the maximum Int in a list with [(String, Int)]
21:03:28 <Axman6> do you care about the Strings?
21:03:41 <Fernandos> no
21:03:48 <kadoban> maximum . map snd
21:03:49 <Axman6> if not, maximum . map snd
21:04:32 <unb3k44n7> Evening guys.
21:07:18 <Fernandos> Axman6: hmm ok, I care about the Strings. I want to find the ("string") with the highest occurence and print it ordered by occurence
21:07:34 <Fernandos> I have: Freq seq   = map (\a -> (head a, length a)) $ group $ sort seq
21:07:51 <Fernandos> idk what to replacing the sort with 
21:08:49 <Axman6> :t maximumBy (comparing snd)
21:08:51 <lambdabot> (Ord a, Foldable t) => t (a1, a) -> (a1, a)
21:09:08 <mniip> Fernandos, seq?
21:09:09 <Axman6> hmm, read that as [(a,b)] -> (a,b)
21:09:21 <srhb> mniip: sequence as in gene sequences here.
21:09:34 <Axman6> also functions can't start with capital letters, so I assume you meant freq seq?
21:09:36 <srhb> Or rather bases.
21:09:36 <mniip> seq is also a builtin so I was confused
21:09:42 <srhb> mniip: Yep, I figured. :)
21:10:21 <Fernandos> mniip: seq is a string
21:10:43 <mniip> oh
21:10:47 <mniip> a function argument
21:10:58 <Fernandos> oh that was a typo
21:11:03 <Fernandos> should be freq
21:11:13 <unb3k44n7> Someone should invent something that downloads information into your brain. Like we could all learn Haskell instantly then. 
21:11:33 <srhb> unb3k44n7: That would ruin half the fun!
21:11:55 <srhb> unb3k44n7: Or you'd die from an overload of OMG! experiences in too little time for your brain to settle down.
21:12:04 <unb3k44n7> This is true.
21:12:10 <unb3k44n7> Good thinking.
21:12:15 <srhb> I'm smart like that.
21:12:19 <unb3k44n7> You are.
21:14:36 <Fernandos> like this? freq gene  = map (\a -> (head a, length a)) $ group $  maximumBy (comparing snd) gene
21:15:45 <Axman6> no... maximumBy only returnes one thing
21:15:59 <Axman6> you probably want maximumBy out the sront if you only want the maximum
21:16:06 <srhb> Fernandos: I'm not sure what you're doing with the map, but it seems like you want to transform it into the [(String, Int)] there
21:16:12 <Fernandos> yes
21:16:20 <srhb> Fernandos: the head is confusing. It looks like you're asking for the very first amino acid.
21:17:24 <Fernandos> I actually just want to print the base pairs that occur most frequntly in groups of 7 chars
21:17:25 <srhb> Fernandos: So without knowing exactly what you're trying to do, remember that your argument is on the very right, and as it looks now, you're applying maximumBy (comparing snd) to gene _first_
21:17:29 <srhb> Ah.
21:17:52 <srhb> So, you want to sort them first, then group them, then use maximumBy?
21:18:06 <gaze__> Hey folks. If I have some symbol defined in a .c file I'm building in with cabal using c-sources, any idea why I'd still end up with a 'dyld: Symbol not found'
21:18:08 <Fernandos> I have: kMers k gene = map (take k) $ take (n-k+1) $ tails seq where n = length gene
21:18:14 <srhb> Er, map the length function on between group and maximumBy
21:18:27 <gaze__> I know for a fact that the .c file defines a function with the appropriate name
21:18:27 <Fernandos> that groups them into packs of 7
21:18:47 <Fernandos> if I run kMers 7 genes
21:19:48 <srhb> Fernandos: I'm not exactly sure what you mean by :that occur most frequently in groups of 7"
21:20:39 <srhb> Do you mean to pick, say, T, if it is the one of the bases most often found in exactly groups of 7?
21:20:49 <srhb> groups of exactly 7*
21:21:05 <Fernandos> if I have AA BB CC, CC, BB, then we have a list with 2chars each. and AA occurs once, BB twice and CC twice too
21:21:20 <srhb> OK, so B and C would be chosen?
21:21:34 <Fernandos> yeah
21:22:05 <srhb> And that should be the result of kMer 2 ?
21:22:50 <Fernandos> I already get a list of tuples like this [("TTTTTGG",7),("TTTTTGT",1),("TTTTTTA",8),("TTTTTTC",8),("TTTTTTG",7),("TTTTTTT",8)]
21:23:33 <Fernandos> if I only wanted to show the top 5 most occuring ones, I'd have to look at the numbers in those tuples which stand for the count
21:23:36 <srhb> Fernandos: But you don't really care about TTTTTGG, do you?
21:23:54 <srhb> I mean in kMer 7, presumably you only care about TTTTTTT
21:23:59 <shield00> hey guys. I'm having some trouble using special chars as keys on my Data.Maps, so I guess I'm not doing it right. what's the right way to use keyboard keys like ENTER and DELETE as chars?
21:24:20 <Enigmagic> gaze__: well best thing to do is run 'cabal build -vvvv' and inspect the output to make sure it's getting linked
21:24:34 <gaze__> it is being linked.
21:24:41 <gaze__> well, I see it in the last 'ar' line
21:25:22 <Enigmagic> gaze__: okay... so next thing to do is run nm on the .o file and make sure the symbol is marked as external
21:25:33 <Fernandos> srhb: yes that sould be result of kMer 2 gene. I hoped that freq 5 gene would spit out the list with with the 5 most occuring genes
21:26:30 <srhb> Fernandos: I'm really confused about your assignment. Anyway, group should give you sequences of only the same base, then you can sort them and do whatever you want from there.
21:26:47 <gaze__> Enigmagic: It's there with a capital T
21:27:51 <mniip> srhb, shouldn't you sort before grouping
21:28:06 <srhb> mniip: No, if you just sort the bases you get "AAAAAAAAAAAAAAAAA........."
21:28:35 <srhb> Then we're just counting "how many A-bases are there"
21:28:38 <mniip> I was looking at 
21:28:39 <mniip> [07:22:20] <Fernandos> I already get a list of tuples like this [("TTTTTGG",7),("TTTTTGT",1),("TTTTTTA",8),("TTTTTTC",8),("TTTTTTG",7),("TTTTTTT",8)]
21:29:01 <srhb> mniip: As I understand it currently, we have something like "AAACCACTTGTACCCT"
21:29:02 <Enigmagic> gaze__: what's the actual error? if you're statically linking the library i don't know why there would be dyld errors
21:29:12 <mniip> srhb, and we need to find what?
21:29:14 <srhb> mniip: We want to find the letter that is most represented contiguously
21:29:24 <mniip> you mean most common substring?
21:29:56 <Fernandos> AAACCAC and TTGTACC would occur in that string in pairs of 7
21:30:13 <mniip> "in pairs of 7"
21:30:15 <srhb> mniip: Of the same letter, yeah. So group, map length onto it, sortBy (comparing snd), nubBy some equality
21:30:16 <mniip> wha
21:30:38 <srhb> But yeah I am also confused
21:30:47 <Fernandos> sorry I mean substrings of 7chars
21:30:52 <mniip> so you need
21:30:52 <srhb> Maybe we are counting genes and not bases. :-)
21:31:06 <mniip> most common longest monotonic substring?
21:31:19 <srhb> Fernandos: Have you posted your assignment?
21:31:23 <Fernandos> yep
21:31:31 <mniip> link?
21:31:42 <Fernandos> srhb: A k-mer is a sequence of symbols from some alphabet Σ of length k. The set (or sequence) of all k-mers is a combinatorial object.  Define a divide-and-conquer algorithm that generates all k-mers.
21:32:00 <mniip> ...
21:32:33 <gaze__> Enigmatic: It seems as if this whole thing works just fine if I build an executable... sorry I get the dyld errors if I use GHCI
21:32:34 <nocturne777> which one is more idiomatic when using the Either monad to report an error? Left $ Err "something went wrong" or throwError $ Err "something went wrong"
21:32:39 <Fernandos> here's what I have http://lpaste.net/5812608077534330880
21:32:40 <mniip> kmer as 0 = [[]]; kmer as n = liftA2(:) as $ kmer as (n - 1)
21:32:52 <nocturne777> I mean to return an error ..
21:33:28 <gaze__> Enigmatic: "dyld: lazy symbol binding failed: Symbol not found: _nvgCreateInternal" "Referenced from: /var/folders/h3/ybfjcbmd3jxdxg6pc7h_5bbc0000gn/T/ghc49910_0/libghc49910_1.dylib" "Expected in: flat namespace"
21:33:29 <breadmonster> mniip: if some module Module exports foo from Module.Submodule, and I import both Module and Module.Submodule, do I need to hide foo in one of the imports?
21:33:42 <gaze__> Enigmatic: then another line "dyld: Symbol not found: _nvgCreateInternal"
21:34:41 <mniip> breadmonster, I don't remember off the top of my head but I would expect that you don't need to hide anything
21:34:51 <breadmonster> Okay, perfect.
21:35:18 <Fernandos> mniip: is that it? 
21:35:30 <mniip> Fernandos, that's a function that generates all kmers
21:36:17 <Fernandos> I'm a total beginner, so what imports do I need for liftA2 and how do I call it?
21:36:20 <mniip> :let kmer as 0 = [[]]; kmer as n = (:) <$> as <*> kmer as (n - 1)
21:36:23 <mniip> @let kmer as 0 = [[]]; kmer as n = (:) <$> as <*> kmer as (n - 1)
21:36:24 <lambdabot>  Defined.
21:36:32 <mniip> > kmer "atgc" 3
21:36:34 <lambdabot>  ["aaa","aat","aag","aac","ata","att","atg","atc","aga","agt","agg","agc","ac...
21:36:52 <Axman6> I'm not sure what's what he wanted?
21:36:57 <mniip> <$> <*> liftA2 are all from Control.Applicative
21:37:10 <mniip> Axman6, "Define a divide-and-conquer algorithm that generates all k-mers."
21:37:22 <Axman6> oh, the problem changed =)
21:37:47 <unb3k44n7> Could you sequence DNA with Haskell?
21:37:50 <Fernandos> mniip: from an input file as posted in lpaste
21:38:11 <Fernandos> mniip: http://lpaste.net/5812608077534330880 the gene variable
21:38:26 <mniip> what's the gene variable got to do with k-mers
21:40:39 <srhb> Fernandos, mniip: I think it's more like map (splitEvery n) . take n . tails
21:41:13 <mniip> Fernandos, can you explain what the task is
21:41:16 <srhb> > let mer n = map . (splitEvery n) . take n . tails in 2 `mer` "AAGCTT"
21:41:18 <lambdabot>      Couldn't match type ‘[[[a2]]]’ with ‘a1 -> b1’
21:41:18 <lambdabot>      Expected type: [[a2]] -> a1 -> b1
21:41:18 <lambdabot>        Actual type: [[a2]] -> [[[a2]]]
21:41:34 <srhb> > let mer n = map (splitEvery n) . take n . tails in 2 `mer` "AAGCTT"
21:41:34 <mniip> the gene variable has nothing to do with "Define a divide-and-conquer algorithm that generates all k-mers."
21:41:35 <echatav> what package do you use for finite discrete probability distributions?
21:41:35 <lambdabot>  [["AA","GC","TT"],["AG","CT","T"]]
21:41:47 <srhb> Ignore non-2's, you can just filter those away
21:42:15 <mniip> srhb, I would say 'map (take n) . tails'
21:42:34 <srhb> Errr..
21:43:09 <srhb> mniip: What do you mean?
21:43:21 <mniip> > let mer n = map (take n) . tails in 2 `mer` "AAGCTT"
21:43:23 <lambdabot>  ["AA","AG","GC","CT","TT","T",""]
21:43:40 <srhb> Oh, yes, you are correct.
21:43:46 <mniip> and then some 'dropFromEnd n'
21:44:09 <Fernandos> I'm confused.. here's an implementation in an other language http://en.wikipedia.org/wiki/K-mer#Pseudocode
21:44:12 <srhb> Depends if you want to preserve the read frame I guess.
21:44:16 <srhb> I was thinking like that. :P
21:44:44 <mniip> Fernandos, that's not what your spec said at all
21:45:16 <Fernandos> I'm not sure but I think this function already does that. kMers     k seq = map (take k) $ take (n-k+1) $ tails seq where n = length seq
21:45:28 <srhb> I think they are mixing compsci and bioinformatics in a bad sense. Especially the "combinatorial" bit combined with "k-mer"
21:45:45 <echatav> what package do you use for finite discrete probability distributions?
21:47:39 <Axman6> > let f n = maximumBy (comparing snd) . M.toList . M.fromListWith (+) . map (\l -> (take n l, 1)) . tails in f 2 "AATCAATGAGCTAATCGACCA"
21:47:41 <lambdabot>  ("AT",3)
21:47:46 <Fernandos> echatav: maybe https://www.stackage.org/snapshot/lts-2.10/package/hmatrix-gsl-stats-0.2.1
21:47:54 <mniip> :t dropFromEnd
21:47:55 <lambdabot> Not in scope: ‘dropFromEnd’
21:47:57 <srhb> Fernandos: Anyway, as we are currently approaching the problem (and what we perceive to be the problem statement) no divide and conquer approach makes any sense whatsoever.
21:48:09 <srhb> Fernandos: So surely we're not understanding the problem (because it is poorly stated)
21:48:22 <mniip> @let dropFromEnd n xs = zipWith const (drop n xs) xs
21:48:23 <lambdabot>  Defined.
21:48:24 <srhb> Fernandos: Your next step should be to ask the instructor wtf he or she was taking and get a better problem statement. :)
21:48:36 <mniip> > let mer n = dropFromEnd n . map (take n) . tails in 2 `mer` "AAGCTT"
21:48:37 <echatav> Fernandos: thanks, not quite what I'm looking for but I'll keep searching
21:48:37 <lambdabot>  ["GC","CT","TT","T",""]
21:48:53 <mniip> oops wrong end
21:49:10 <Axman6> > let f k n  take k .= sortBy (comparing snd) . M.toList . M.fromListWith (+) . map (\l -> (take n l, 1)) . tails in f 2 "AATCAATGAGCTAATCGACCA"
21:49:12 <lambdabot>  <hint>:1:113: parse error on input ‘in’
21:49:26 <Fernandos> srhb: I presented it already :) on tuesday, but wanted to extend it a bit for the fun of learning haskell, which turned to be a little gruelsome :P
21:49:36 <mniip> @let dropFromEnd n xs = zipWith const xs (drop n xs)
21:49:36 <Axman6> > let f k n  take k . sortBy (flip (comparing snd)) . M.toList . M.fromListWith (+) . map (\l -> (take n l, 1)) . tails in f 2 "AATCAATGAGCTAATCGACCA"
21:49:37 <lambdabot>  .L.hs:152:1: Warning:
21:49:37 <lambdabot>      Pattern match(es) are overlapped
21:49:37 <lambdabot>      In an equation for ‘dropFromEnd’: dropFromEnd n xs = ...
21:49:38 <lambdabot>  <hint>:1:119: parse error on input ‘in’
21:49:39 <srhb> Fernandos: So you somehow understand the problem statement? :P
21:49:43 <mniip> aw
21:49:44 <srhb> Because we don't, I think :P
21:49:51 <mniip> ok I will lpaste
21:49:51 <Axman6> > let f k n  take k . sortBy (flip (comparing snd)) . M.toList . M.fromListWith (+) . map (\l -> (take n l, 1)) . tails in f 4 2 "AATCAATGAGCTAATCGACCA"
21:49:53 <lambdabot>  <hint>:1:119: parse error on input ‘in’
21:50:08 <Axman6> > let f k n = take k . sortBy (flip (comparing snd)) . M.toList . M.fromListWith (+) . map (\l -> (take n l, 1)) . tails in f 4 2 "AATCAATGAGCTAATCGACCA"
21:50:10 <lambdabot>  [("AA",3),("AT",3),("CA",2),("GA",2)]
21:50:10 <Fernandos> I was just trying to filter out in example the two most occuring sequences in [TTTTGTC",1),("TTTTGTG",6),("TTTTGTT",3),("TTTTTAA",6),("TTTTTAC",5),("TTTTTAG",7),("TTTTTAT",10),("TTTTTC\n",2),("TTTTTCA",5),("TTTTTCC",9),("TTTTTCG",6),("TTTTTCT",8),("TTTTTGA",6),("TTTTTGC",9),("TTTTTGG",7),("TTTTTGT",1),("TTTTTTA",8),("TTTTTTC",8),("TTTTTTG",7),("TTTTTTT",8)]
21:50:23 <Axman6> > let f k n = take k . sortBy (flip (comparing snd)) . M.toList . M.fromListWith (+) . map (\l -> (take n l, 1)) . tails in f 4 3 "AATCAATGAGCTAATCGACCA"
21:50:25 <lambdabot>  [("AAT",3),("ATC",2),("",1),("A",1)]
21:50:29 <Fernandos> that would be ("TTTTTAT",10) and one of those with 9
21:50:41 <srhb> Fernandos: Well that bit is easy.
21:51:04 <srhb> Fernandos: As already stated it's just take 2 . sortBy (comparing snd)
21:51:04 <Fernandos> To the Gods of Haskell, yes no so for me :)
21:51:48 <srhb> Also pretty sure there aren't newlines in genomes. :-)
21:52:14 <kadoban> is   sortBy (comparing Down)  -- the best way to sort in reverse?
21:52:58 <enthropy> stop codons might be newlines
21:53:04 <srhb> enthropy: :P
21:53:37 * srhb doesn't think ribosomes work like that either!
21:53:48 <srhb> But heck, biology is weird.
21:55:12 <enthropy> well they have some not-so-clearly defined transcription terminator and a pretty unambiguous translation terminator
21:55:23 <enthropy> so maybe it's \r\n for stopping :p
21:55:46 <srhb> And all the in-betweenies :P
21:55:53 <Fernandos> that's why I was looking for a library that can parse fasta files, because I don't know anything about biosciences
21:56:09 <srhb> Fernandos: Anyway, did you try the sortBy bit?
21:56:23 <srhb> Fernandos: you actually need to sortBy (flip $ comparing snd) to get descending order.
21:56:45 <Axman6> one of the language shootout benchmarks deals with festa files
21:57:02 <srhb> There's already fasta, which is a silly simple Parsec parser for fasta files.
21:57:14 <srhb> Works just fine. It's one of the better formats out there. :P
21:57:17 <lpaste> mniip pasted “gene stuff” at http://lpaste.net/133480
21:57:42 <enthropy> FASTA is just a line of >blahblah followed by letters ATGC stuff
21:57:49 <srhb> Indeed.
22:00:12 <Fernandos> that works like a charm [("TAGCGAC",295),("AGCGACT",84),("AGCGACG",82),("TTAGCGA",80)]
22:00:50 <mniip> Fernandos, see my paste too
22:01:35 <Fernandos> that was your paste mniip, the problem with that is, that I mostly don't get it.
22:01:46 <felixn> how do I use IO inside of STM?
22:02:34 <Axman6> you don't
22:02:37 <Axman6> that's the point
22:02:44 <srhb> felixn: You don't.
22:02:46 <srhb> Eh..
22:02:54 <Axman6> STM only works because you can't do IO inside transactions
22:04:16 <srhb> Fernandos: What are you confused about?
22:04:26 <felixn> hmm, ok!  maybe I can do this another way
22:04:33 <mniip> felixn, you are supposed to do IO /between/ STMs
22:05:42 <srhb> Fernandos: Reading from the right: Sort the sequences, group them up, reduce them to one of each (preserving the number of this particular sequence), sortby the most frequent (as determined by the second value of the tuple)
22:06:05 <srhb> Fernandos: Assuming it was freqSort you were confused about
22:06:06 <Fernandos> what does const mean?
22:06:14 <srhb> > const 2 3
22:06:15 <lambdabot>  2
22:06:24 <Fernandos> > const 1 2 3
22:06:24 <srhb> @src const
22:06:24 <lambdabot> const x _ = x
22:06:25 <lambdabot>      Could not deduce (Num a0)
22:06:25 <lambdabot>      from the context (Num a, Num (a -> t))
22:06:25 <lambdabot>        bound by the inferred type for ‘e_1123’: (Num a, Num (a -> t)) => t
22:06:32 <kadoban> > const 2 "blahhhhhhhh"
22:06:34 <lambdabot>  2
22:06:36 <Fernandos> > const 1
22:06:37 <lambdabot>      No instance for (Typeable b0)
22:06:38 <lambdabot>        arising from a use of ‘show_M349482715841913442421817’
22:06:38 <lambdabot>      In the expression:
22:06:40 <srhb> Fernandos: equal to first argument, discard the second
22:06:43 <Fernandos> hahah
22:06:48 <unb3k44n7> Does anyone know how to call lambdabot into a PM (not theother way around).
22:07:04 <srhb> unb3k44n7: That's not how IRC works, afaik?
22:07:09 <Fernandos>  /msg lambdabot > const 1
22:08:20 <unb3k44n7> ^ No spaces?
22:08:21 <arkeet> unb3k44n7: what does that mean
22:08:32 <arkeet> just give it the same commmands you normally would, except in private
22:08:35 <Fernandos> yes no leading spaces
22:08:54 <unb3k44n7> Ok. Then it didn't work, Fernandos.
22:09:01 <Fernandos> worked for me
22:09:28 <Fernandos> you can doubleclick lambdabot (depending on your irc client) and enter the commands there
22:09:41 <arkeet> or do /query lambdabot 
22:10:08 <unb3k44n7> But I mean bringing lambdabot into a PM conversation, with another user.
22:10:16 <arkeet> PMs don't work that way.
22:10:38 <arkeet> a PM has a single destination.
22:10:41 <lpaste> Fernandos annotated “gene stuff” with “gene stuff (annotation)” at http://lpaste.net/133480#a3353397575796391936
22:10:53 <srhb> unb3k44n7: The only way to do that is create a channel and ask the lambdabot administrator to have lambdabot join it.
22:11:03 <unb3k44n7> Ok.... 
22:11:06 <unb3k44n7> Thanks.
22:11:34 <arkeet> find a quiet channel that has lambdabot in it.
22:11:37 <arkeet> perhaps #haskell-overflow
22:12:02 <arkeet> although obviously that isn't private.
22:12:44 <unb3k44n7> It's ok arkeet. I'll figure something out. :)
22:12:44 <srhb> It would be nice if one could ask lambdabot to temporarily join an arbitrary channel. Though the sanity checks and abuse detectors would probably need to be expanded a bit.
22:14:27 <Fernandos> mniip: I've got it a few lines down http://lpaste.net/3353397575796391936 those two lines are partly cryptic to me
22:15:24 <Fernandos> sortBy (flip compare `on` snd) what would the inner statement do?
22:15:47 <Fernandos> flip by the 2nd parm of the tuple?
22:16:22 <srhb> Fernandos: the comparing function takes two arguments and returns whether the first is greater than the last
22:16:35 <srhb> By flipping the arguments, you get the opposite result.
22:16:56 <srhb> > compare 2 3
22:16:58 <lambdabot>  LT
22:17:13 <srhb> > flip compare 2 3
22:17:15 <lambdabot>  GT
22:17:24 <mniip> on is a function for mapping binary function
22:17:24 <mniip> s
22:17:42 <mniip> on f g x y = f (g x) (g y)
22:18:55 * hackagebot pandoc 1.14 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.14 (JohnMacFarlane)
22:19:30 <kadoban> :t on
22:19:31 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
22:23:18 <felixn> do { var <- newEmptyMVar ; a <- readMVar var ; putMVar var "test" ; return a } <-- apparently I can't do this :(  is there something else I can use other than MVar?
22:24:11 <srhb> felixn: Huh?
22:24:18 <srhb> felixn: Oh, that's an STM block?
22:24:23 <srhb> In that case, TMVar or something.
22:24:41 <srhb> Or just TVar, really.
22:25:38 <felixn> haha, no I'm past that ... this is just my problem isolated, the big picture is I'm trying to simulate a network, so I want to be able to setup listeners
22:26:27 <felixn> there error with that code is: *** Exception: thread blocked indefinitely in an MVar operation
22:26:36 <srhb> felixn: Oh, sure, you didn't empty the MVar
22:26:44 <srhb> felixn: Perhaps you meant takeMVar instead of readMVar
22:28:23 <nshepperd> you... can't read from an empty mvar
22:29:24 <nshepperd> why would you try to read from one you had just created?
22:29:57 <srhb> Oh, I didn't even notice that. :P
22:30:11 <srhb> Even if it were full, you would then be blocking on putMVar, I should have said.
22:30:12 <Myrl-chan> lol
22:32:08 <felixn> srhb: do { var <- newEmptyMVar ; aWait <- async (takeMVar var) ; putMVar var "test" ; a <- wait aWait ; return a } <-- for some reason I thought haskell was async by default, through laziness.  so I guess I'll have to slather on forkIO & async in practice!
22:32:39 <srhb> felixn: I have no idea what that even means, but as long as you're happy. :P
22:33:23 <srhb> Using async and MVars seems to kind of defy the purpose though
22:33:34 <srhb> The whole idea is often to block the thread while waiting for the MVar to be filled.
22:34:08 <srhb> Aka. the deceptively simple way to do multithread synchronization.
22:36:11 <dmj`> felixn: I'm pretty sure that code will block indefinitely in most cases
22:40:01 <m_ryan> hi, what does this error mean? No instance for (Enum t0) arising from the arithmetic sequence ‘1 .. 10’ -> the Code: zip (cycle [1..10]) cityList
22:41:51 <dmj`> m_ryan: you're going to have to paste more code since the type [] does have an Enum instance
22:43:01 <Rasasghul> x
22:43:17 <dmj`> wait
22:43:54 <kadoban> m_ryan: You probably have screwed up types elsewhere, and it's assuming the type of that list is something really odd.
22:44:35 <kadoban> Or possibly it's just too polymorphic? I dunno if that can be though.
22:44:40 <nshepperd> or, nothing you've done yet fixed the type of those numbers 1..10
22:45:14 <kadoban> Wouldn't it default to Int or Integer or one of those though, or does that not happen?
22:45:17 <m_ryan> dmj` and kadoban: here is my paster http://lpaste.net/133481
22:46:00 <nshepperd> sometimes it doesn't default
22:46:11 <nshepperd> I have yet to read up on why
22:46:50 <nshepperd> m_ryan: try [1..10::Int]
22:46:52 <gaze__> Hey folks. Any idea why I'd get a "dyld: lazy symbol binding failed: Symbol not found:" on a symbol that's in the .dylib file?
22:47:05 <gaze__> like I nm the dylib file and see the damn symbol right there
22:47:08 <kadoban> m_ryan: The east fix is something like … , yeah what nshepperd said.
22:48:48 <m_ryan> thanks it works :) does the haskell was confuse if 1..10 is an Integer or float?
22:50:05 <bob_twinkles> :t [1..10] -- not quite an Int, nor is it an Integer
22:50:06 <lambdabot> (Enum t, Num t) => [t]
22:51:16 <kadoban> m_ryan: It's more like it could be any  Num  instance, even ridiculous (possible) ones like … I dunno  (a -> b). So it's not sure it's an Enum.  I'm … not entirely sure why.
22:52:41 <dmj`> :t cycle
22:52:42 <lambdabot> [a] -> [a]
22:52:48 <kadoban> I would naively think that doing that would constrict the type to ones with an Enum constraint, I … don't really understand why it doesn't.
22:53:23 <m_ryan> me too.
22:53:47 <m_ryan> > [1..10]
22:53:48 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
22:54:01 <m_ryan> lamdabot understand it. :)
22:54:45 <kadoban> GHC usually does too. Except sometimes not …  my current guess is "extensions" ? *shrug*
22:55:46 <m_ryan> what extension?
22:55:58 <m_ryan> > [1..10::Float]
22:55:59 <lambdabot>  [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
23:03:13 <Fernandos> is there a way to retrieve the type signature for a function?
23:04:19 <Fernandos> mniip: your kmers function was wrong, but the wordfreq thing was correct. Here's the final solution http://lpaste.net/8073031047383613440
23:04:57 <liste> Fernandos try :t in ghci or lambdabot
23:05:58 <Fernandos> > :t kMers k seq = map (take k) $ take (n-k+1) $ tails seq where n = length seq
23:05:59 <lambdabot>  <hint>:1:1: parse error on input ‘:’
23:06:15 <Fernandos> idk howto use lambdabot 
23:06:54 <opqdonut> :t let kMers k seq = map (take k) $ take (n-k+1) $ tails seq where n = length seq in kMers
23:06:55 <lambdabot> Int -> [a] -> [[a]]
23:07:00 <Fernandos> > :t kMers k seq = map (take k) $ take (n-k+1) $ tail seq where n = length seq
23:07:01 <lambdabot>  <hint>:1:1: parse error on input ‘:’
23:07:23 <opqdonut> Fernandos: > is for evaluation, :t (or :type) is for type information
23:07:43 <Fernandos> ah
23:07:44 <opqdonut> and the argument of :t should be an expression, see my "let kMers = ... in kMers"
23:08:58 * hackagebot wai-routes 0.6.0 - Typesafe URLs for Wai applications.  http://hackage.haskell.org/package/wai-routes-0.6.0 (AnupamJain)
23:13:12 <gaze__> hey folks
23:13:15 <gaze__> something looks a bit broken
23:14:16 <liste> gaze__ what?
23:14:30 <gaze__> one sec.
23:15:00 <gaze__> ghc --interactive seems to be sensitive to the order in which the .o files are mentioned on the command line
23:15:03 <gaze__> is this expected behavior?
23:15:57 <liste> how does the behavior change when they're in different order?
23:16:29 <gaze__> http://lpaste.net/133485
23:16:43 <gaze__> I get a "dyld: lazy symbol binding failed"
23:19:35 <gaze__> This is on OS X 10.10.1
23:23:41 <Sprog> Anyone familiar with wreq?
23:35:33 <dmj`> is it a fair assumption that all unlifted types are strict
23:39:25 <dmj`> unlifted in the sense they don't contain _|_
23:40:26 <pacak> dmj`: I think so
23:44:04 <_m_ryan> hi is IO [RawLatestAvgPrices] type is the same as [RawLatestAvgPrices]?
23:44:34 <liste> _m_ryan no, one is an IO action that returns a list, the other is a list
23:45:48 <_m_ryan> so how do i convert RawLatestAvgPrices] to this [RawLatestAvgPrices]?
23:46:02 <_m_ryan> or is it possible?
23:46:10 <_m_ryan> i mean IO[] to []?
23:46:29 <liste> _m_ryan you need to run the action
23:46:46 <_m_ryan> liste: what action?
23:46:51 <liste> that means that you can get the value out as long as you are in an IO monad
23:46:56 <jle`> _m_ryan: an `IO a` is an IO action that produces an `a`
23:46:59 <dmj`> _m_ryan: once you're in I/O there's no escaping really. You could fmap a pure function over it
23:48:17 <_m_ryan> an IO can call in the Handler user liftIO right?
23:48:25 <liste> _m_ryan yes
23:48:42 <dartxx> 'Night everyone. How can I refer to keyboard chars such as ENTER and BACKSPACE in Haskell?
23:48:50 <dartxx> Keyboard keys *
23:49:26 <_m_ryan> liste: thanks. i will do something maybe its possible :)
23:49:27 <kadoban> dartxx: In what context? It should be possible in whatever API you'd be using that would use such a key.
23:53:09 <dartxx> kadoban: Well, I'm using Gloss. In the input part, I've created a Data.Map.fromList to map key commands to some functions. The alphanumeric part is intuitive, but I'm not sure how to refer to non-alphanumeric keys.
23:54:22 <arkeet> gloss has a SpecialKey type 
23:54:25 <arkeet> which I guess is for those things?
23:54:49 <arkeet> like look at the key type.
23:57:38 <dartxx> arkeet: Oh.. I was looking into Data.Map and some other stuff, it didn't even occur to me to take a look at the Gloss docs itself..
23:57:51 <arkeet> well
23:57:54 <Axman6> ...
23:57:58 <arkeet> like
23:58:02 <arkeet> where do you get the keys
23:58:04 <Axman6> https://github.com/benl23x5/gloss/blob/22bd31185b9819d13222a14cab2084653040c73d/gloss/Graphics/Gloss/Internals/Interface/Backend/Types.hs
23:58:05 <arkeet> what type do they have
23:58:11 <arkeet> then look at the docs for that type
23:58:23 <Axman6> I assume you're using one of the Game modules?>
23:58:33 <unb3k44n7> What does a parse error on input "=" mean?
23:58:36 <dartxx> Axman6: Yup.
23:58:38 <Axman6> which gives you everything you need to deal with user interraction
23:58:49 <arkeet> it means you put an = where it was expecting something else.
23:58:53 <arkeet> hard to say what without more info
23:59:24 <dartxx> Axman6: Yeah, that's makes sense. Feeling kind of stupid right now. But then again, it's 4am, so yeah..
23:59:35 <Axman6> =)
23:59:38 <dartxx> Axman6: That makes *
23:59:43 <dartxx> Thanks guys :)
23:59:53 <Axman6> Specifically you're looking for SpecialKey KeyBackspace
