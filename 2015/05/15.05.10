00:08:39 <georgyy> hi
00:08:48 <usr> hi :)
00:08:57 <georgyy> do lenses give me th le ability  to simulate fields name sharing?
00:14:16 <haasn> georgyy: yes, if you use a type class to abstract over the particular type
00:15:15 <mjrosenb> @hoogle Bool -> Int
00:15:15 <lambdabot> Data.Time.Calendar.MonthDay monthLength :: Bool -> Int -> Int
00:15:16 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
00:15:16 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
00:15:35 <mjrosenb> wow, that is /so/ not what I wanted
00:19:02 <jle`> > fromEnum True
00:19:04 <lambdabot>  1
00:19:28 <jle`> hoogle can be interesting sometimes with polymorphic things
00:19:58 <haasn> mjrosenb: hey, at least it didn't suggest unsafeCoerce
00:21:02 <jle`> > map unsafeCoerce [False, True]
00:21:04 <lambdabot>  [0,1]
00:21:06 <jle`> neat
00:21:21 <jle`> > map unsafeCoerce [False, True] :: [Int]
00:21:22 <lambdabot>  [0,1]
00:24:01 <Big_G> Is there a select function in Haskell like there is in lisp?
00:25:20 <haasn> Wait, what? unsafeCoerce in lambdabot?
00:25:23 <haasn> That can't possibly be safe
00:25:36 <georgyy> haasn: but can i do that without lenses too? what is the difference
00:25:49 <haasn> Oh, somebody was playing around with the local definitions. :)
00:26:05 <haasn> georgyy: you can implement something equivalent to lenses yourself, yes
00:27:48 <mjrosenb> haasn: true!
00:28:30 <georgyy> haasn: i am not interested in implemented lenses.. i want to share field names. if i have to write typeclasses with lenses too then they dont make the field sharing part any easier
00:28:47 <georgyy> implementing
00:29:38 <haasn> georgyy: Have you tried looking at the ‚Äúshare field names‚Äù extension?
00:30:12 <mjrosenb> @hoogle a -> (a,a)
00:30:12 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
00:30:12 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
00:30:12 <lambdabot> Network.BufferType buf_splitAt :: BufferOp a -> Int -> a -> (a, a)
00:30:24 <schoening> Question! Can I use the Œª symbol instead of \y ?
00:30:27 <haasn> georgyy: ‚Äòlens‚Äô can introduce some of the required type classes and instances using template haskell, but I'm not sure how far it goes
00:30:34 <haasn> schoening: No
00:30:39 <schoening> awww
00:31:09 <jle`> the main problem is that Œª is an actual identifier
00:31:18 <schoening> :o
00:31:23 <jle`> > (\Œª -> Œª * 2) 6
00:31:24 <lambdabot>  12
00:31:36 <jle`> we don't prejudice against greeks
00:31:43 <schoening> just started. good to know :D
00:32:02 <Haskellfant> iirc there are some editor plugins that only replace it visually if that's what your after
00:32:05 <jle`> having Œª be a keyword would be like having 'a' be a keyword, heh
00:32:23 <mjrosenb> jle`: more like l.
00:32:30 <Haskellfant> but we discriminate against backslashes!
00:32:59 <haasn> What language uses backslashes as part of its regular alphabet?
00:33:25 <mjrosenb> haasn: perl?
00:33:30 <ronh-> many if we include escape characters in string literals
00:34:58 <haasn> I meant natural languages
00:37:36 <georgyy> what is the actual extension name? i googled for "share field names" extension and didnt find anything
00:38:10 <haasn> georgyy: https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields this one
00:38:55 <kaivan_> I want to use Genprog library, anyone knows which haskell version would work? Thanks
00:40:05 <georgyy> thanks
00:42:17 <pavonia> kaivan_: Do you mean what Haskell or what GHC version?
00:45:12 <kaivan_> @pavonia Yes, GHC version
00:45:12 <lambdabot> Unknown command, try @list
00:45:53 <rasen> Has anyone tried nvim-hs?
00:46:47 <pavonia> kaivan_: It requires base-4.6 which was introduced in GHC 7.6.1, so I guess al 7.6 versions should work
00:47:50 <pavonia> kaivan_: But later versions will probably work too if you modify the .cabal file and install the package manually
00:51:05 <kaivan_> @pavonia I have 7.8.3, but for some reason it is not working
00:51:05 <lambdabot> Unknown command, try @list
00:51:08 <georgyy> haasn: that is not part of ghc yet :(
00:51:27 <ttt_fff> in typed-racket, can I get haskell's support for typeclasses, monads, and purity?
00:52:16 <pavonia> kaivan_: What error? Please pastebin the full build log
00:52:34 <pavonia> kaivan_: Btw, @ is a command trigger for lambdabot
00:52:45 <kaivan_> @pavonia - I do have .cabal file. Package? Could you be more clear on that?
00:52:45 <lambdabot> Unknown command, try @list
00:53:15 <kaivan_> ohh ok. Then what should I use such that it pings your name?
00:54:37 <kaivan_> And I will pastebin the log. Let me recreate the problem.
00:54:42 <pavonia> kaivan_: In Haskell libraries are usually called packages, i.e. all relevant files to build the package including the .cabal file
00:55:06 <pavonia> The .cabal file says what dependencies and files are needed for building
00:55:51 <kaivan_> Ohh I see. Just like the packages in java.
00:58:43 <ReinH> ttt_fff: ask racket people?
00:58:50 <ttt_fff> ReinH: currently doing that
00:59:04 <ReinH> I think racket has generics, not sure how much like typeclasses they are
01:00:12 <ReinH> And no, racket is not a pure language
01:03:46 <kaivan_> #pavonia - could not find module genprog
01:04:32 <kaivan_> and could not find module Control.Monad.Random
01:04:51 <pavonia> The full build log please!
01:04:53 <pavonia> @lpaste
01:04:54 <lambdabot> Haskell pastebin: http://lpaste.net/
01:08:35 <kaivan_> Sorry about that.
01:08:42 <kaivan_> http://lpaste.net/132328
01:11:04 <pavonia> Oh, I thought you were trying to install the package
01:11:33 <pavonia> You first have to install genprog then you can import it's modules
01:11:47 <pavonia> Try "cabal install genprog"
01:12:08 <kaivan_> Oh no. I believe I already have all of that.
01:12:19 <kaivan_> ok let me try that
01:12:47 <pavonia> If you already have, what does "ghc-pkg list genprog" tell you?
01:17:21 <kaivan_> any particular syntax?
01:18:03 <kaivan_> I am new to ghci. I usually use linux.
01:18:34 <ReinH> ghc-pkg is an executable that you would run from the terminal
01:26:05 <kadoban> There's no priority queue in platform, is there?
01:30:12 <kaivan_> Awesome. Ran it from the terminal
01:30:23 <kaivan_> cabal installed genprog and monad.Random
01:30:38 <kaivan_> My bad. Thanks ReinH and pavonia
01:33:28 <kaivan_> Oh wait there is an error. Here http://lpaste.net/132328
01:34:08 <kaivan_> Failed to install genprog-0.1
01:35:16 <kaivan_> Last 10 lines of the build log. cabal: Error: some packages failed to install: genprog-0.1. The exception was: ExitFailue 1
01:37:38 <pavonia> kaivan_: Could you try to explicitly install genprog-0.1.0.2?
01:38:55 <kaivan_> How would I do that?
01:39:29 <pavonia> cabal install genprog-0.1.0.2
01:39:53 <kaivan_> ok. Let me try that
01:41:22 <maxc01> hello, does anyone have used the `encoding` library?
01:41:37 <kaivan_> Before I tried that it prompted me to update cabal to get the latest list of packages. Doing that. Lets see if that works.
01:43:18 <maxc01> kaivan_, I have installed this library, but I cannot use it properly
01:44:32 <pavonia> maxc01: What have you tried? What errors did you get?
01:44:34 <maxc01> I have a file, which is GB2312 encoding, but I need to convert it to UTF-8
01:44:52 <maxc01> so I found the `encoding` library
01:45:22 <lokathor> how does one enable -O2 with "cabal build"?
01:46:38 <kirill`> lokathor: ghc-options
01:47:44 <lokathor> and that's part of the executable section?
01:48:22 <maxc01> pavonia, according to the library document, I have tried this
01:48:36 <maxc01> main = do
01:48:37 <maxc01>     let ?enc = GB18030
01:48:37 <maxc01>     str <- getContents
01:48:55 <maxc01> but the compiler said that ` parse error on input ‚Äò=‚Äô`
01:49:25 <jle`> lokathor: yes
01:49:35 <lokathor> fancy
01:49:47 <lokathor> well now it runs much faster than ghci :P
01:50:02 <georgyy> should I install 32 or 64 bit ghc on windows? are there any issues with the 64bit version?
01:52:24 <pavonia> maxc01: Have you enabled the ImplicitParams extension?
01:54:17 <kaivan_> could not resolve dependencies when I try to install genprog-0.1.0.2
01:56:01 <maxc01> pavonia, thanks, It worked
02:00:55 <georgyy> length (filter f xs) <- can I rely on intermediate list not being created?
02:01:10 <pavonia> kaivan_: For avoiding the dependencies hell you usually use cabal sandboxes
02:01:28 <pavonia> georgyy: Yes, both functions are lazy
02:02:13 <georgyy> how do you know if a function is lazy
02:02:39 <pavonia> You have to look at its implementation
02:03:47 * hackagebot stackage-build-plan 0.1.1.0 - Calculate and print (in different formats) Stackage build plans  http://hackage.haskell.org/package/stackage-build-plan-0.1.1.0 (MichaelSnoyman)
02:05:13 <pavonia> Thinking about it, laziness isn't a sufficient condition for not building huge intermediate thunks
02:05:32 <georgyy> why not?
02:05:40 <pavonia> > foldl (+) 0 [1..10000000]
02:05:45 <lambdabot>  mueval-core: Time limit exceeded
02:05:49 <pavonia> > foldl' (+) 0 [1..10000000]
02:05:52 <lambdabot>  50000005000000
02:06:05 <pavonia> The first one is lazy, the second is strict
02:06:21 <georgyy> hmm
02:06:32 <lokathor> you mean that you can build huge thunks even in a lazy language? well of course
02:07:32 <georgyy> > length [0..]
02:07:36 <lambdabot>  mueval-core: Time limit exceeded
02:08:31 <lokathor> length $ take 10 $ filter even [0..]
02:08:33 <lokathor> > length $ take 10 $ filter even [0..]
02:08:35 <lambdabot>  10
02:08:42 <lokathor> good work lambdabot
02:10:47 <georgyy> does any of this change the answer to my question about length + filter code
02:11:09 <lokathor> length will start consuming, which will force filter to begin to evaluate
02:11:48 <lokathor> it won't build up too much of a thunk, because they don't try to store up too much of a computation
02:11:50 <lokathor> unlike foldl
02:12:45 <lokathor> > length $ filter isEven [1 .. 10000000]
02:12:46 <lambdabot>  Not in scope: ‚ÄòisEven‚Äô
02:12:53 <lokathor> > length $ filter even [1 .. 10000000]
02:12:57 <lambdabot>  mueval-core: Time limit exceeded
02:13:00 <lokathor> > length $ filter even [1 .. 1000000]
02:13:02 <lambdabot>  500000
02:13:29 <lokathor> of course you can always put too many zeros on your input
02:15:26 <ttt_fff> anyone here managed to get syntastic/hdevtools to work with ghcjs (note, this is ghcJS, not plain ghc)
02:18:04 <pavonia> Hhm, why can it get the sum but not the length of that first list in time?
02:18:29 <pavonia> Is length building a thunk too?
02:18:47 * hackagebot clash-lib 0.5.4 - CAES Language for Synchronous Hardware - As a Library  http://hackage.haskell.org/package/clash-lib-0.5.4 (ChristiaanBaaij)
02:18:49 * hackagebot clash-vhdl 0.5.4 - CAES Language for Synchronous Hardware - VHDL backend  http://hackage.haskell.org/package/clash-vhdl-0.5.4 (ChristiaanBaaij)
02:21:15 <pavonia> > foldl' (+) 0 $ filter even [1..10000000]
02:21:19 <lambdabot>  mueval-core: Time limit exceeded
02:21:29 <pavonia> Okay
02:23:48 * hackagebot clash-systemverilog 0.5.4 - CAES Language for Synchronous Hardware - SystemVerilog backend  http://hackage.haskell.org/package/clash-systemverilog-0.5.4 (ChristiaanBaaij)
02:26:59 <georgyy> i dont get the difference between foldl and foldr
02:27:04 <kadoban> My guess would be that 'even' implies a branch, at the hardware level. Branches are fundamentally kind of expensive, the way our modern pipelined processors work. So that makes it just more expensive enough that lambdabot kills it.
02:27:14 <georgyy> when to use one and when the othet?
02:27:42 <kadoban> pavonia: ^   Timing it on my machine, the 'even' thing is about 5/3 the time.
02:28:08 <kadoban> georgyy: https://wiki.haskell.org/Foldr_Foldl_Foldl%27
02:28:56 <pavonia> Do you mean 3/5?
02:29:30 <kadoban> pavonia: No.
02:29:57 <pavonia> I don't understand then
02:31:30 <kadoban> You don't understand which part? The fraction?  the   length . filter even   takes  more time than the foldl' (+) 0.   It takes approximately 66% more time, or 5/3 of the time.
02:33:42 <pavonia> Ah, thanks. I parsed that as "the 'even' function takes 5/3 of the overall time" which didn't make much sense :)
02:33:48 * hackagebot auto 0.4.2.2 - Denotative, locally stateful programming DSL & platform  http://hackage.haskell.org/package/auto-0.4.2.2 (jle)
02:34:24 <kadoban> Ahh, I see :)
02:53:49 * hackagebot clash-prelude-quickcheck 0.1.2.1 - QuickCheck instances for various types in the CªaSH Prelude  http://hackage.haskell.org/package/clash-prelude-quickcheck-0.1.2.1 (JohnEricson)
02:54:18 <ronh-> "please use GeneralizedNewtypeDeriving for deriving NFData instances for newtype"
02:54:40 <ronh-> I added {-# Language GeneralizedNewtypeDeriving #-}, but I am still getting the same error
02:55:15 <ronh-> newtype Foo = Int; $(deriveNFData ''Foo)
02:56:38 <pingu> ronh-: I think it means, try just using "deriving"
02:57:02 <pingu> ronh-: newtype Foo = Int deriving NFData
02:57:22 <pingu> what GeneralyzedNewtypeDeriving will do is simply use Int's already defined instance.
02:57:32 <pingu> s/y/i/
02:58:53 <deezn> jle` you around?
02:59:03 <ronh-> pingu you are right! that worked
03:00:42 <ronh-> it seems that there are some issues with GeneralyzedNewtypeDeriving extension in ghc < 7.8.1, but I think that doesn't apply to this use? 
03:00:44 <ronh-> http://stackoverflow.com/questions/17137111/why-isnt-generalizednewtypederiving-a-safe-haskell
03:02:32 <Nux__> is there an extension for allowing data constructors apply a value level function perhaps in addition to a type level one?
03:14:17 <Cale> Nux__: Not sure what your question means. Data constructors don't apply type level functions?
03:14:28 <Cale> Data constructors *are* value level functions.'
03:15:15 <Nux__> sorry I meant Type Constructors
03:16:37 <Cale> Nux__: I still am not sure what you mean. You want to have a type constructor which is parameterised over values? That's not available in Haskell (though see the DataKinds extension which allows you to lift values of some types to the type level)
03:17:20 <Cale> Type constructors which depend on values are the very definition of dependent types, there are languages like Coq, Agda, and Idris which are built around that idea.
03:42:07 <Nux__> Cale, the kind of thing I'm trying to implement is the following
03:42:09 <Nux__> http://pastebin.com/g4Fwa99X
03:42:57 <Nux__> the trouble is, I was hoping to make use of their mathematical isomorphism which seems like I should set things up to make use of the Functor typeclass
03:43:42 <Nux__> but Functor only maps it's objects using type constructors
03:43:52 <Haskellfant> functor is not what you want
03:44:04 <Haskellfant> a functor maps between categories
03:44:19 <Haskellfant> and in haskell only between Hask and Hask so an endofunctor
03:44:51 <Haskellfant> (asuming I understand what you wanna do, which now that I think about I am not quite sure)
03:45:54 <Nux__> I think we're on the same page. I think my problem is that what I want to do is a value level isomorphism not a type level on
03:46:02 <Nux__> *one
03:46:10 <Haskellfant> so you want to have an isomorphism between your two intervals?
03:46:21 <Nux__> so I should just make the necessary functions
03:47:09 <Nux__> I guess just having the Interval typeclass does most of what I want through polymorphism
03:47:42 <Nux__> that way I'm using the isomorphism by treating the two types as the same
03:48:02 <Nux__> (with respect to the lower upper middle and radius functions at least)
03:49:18 <Nux__> or am I misunderstanding something?
03:50:06 <Haskellfant> you can provide default implementations of typeclass methods and then annotate what is necessary for a minimal definition
03:50:19 <Haskellfant> example Eq https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc-prim-0.4.0.0/src/GHC-Classes.html#Eq
03:50:44 <Haskellfant> (/=) is defined using (==)
03:50:46 <Nux__> oh yeah that would simplify my definitions
03:50:59 <Nux__> yes I remember I just forgot to use that feature
03:51:00 <Haskellfant> minimal then tells you what you need to implement to not get a cycle
03:51:44 <Nux__> though I'm not quite wure what you mean by annotate. Do you mean add comments?
03:51:57 <Nux__> or is there a feature I'm unaware of?
03:52:03 <Nux__> *sure
03:52:23 <Haskellfant> look at the example I linked
03:52:29 <Haskellfant> {-# MINIMAL (==) | (/=) #-}
03:53:29 <Haskellfant> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/pragmas.html 7.22.5
03:53:31 <merijn> Nux__: GHC supports a pragma that warns users when they don't implement at least the minimal subset required
03:53:41 <Nux__> oh handy
03:54:16 <Nux__> thanks
03:57:58 <mietek> shapr: ping
03:58:51 * hackagebot bitcoin-tx 0.13.0 - Utility functions for manipulating bitcoin transactions  http://hackage.haskell.org/package/bitcoin-tx-0.13.0 (solatis)
03:58:53 * hackagebot bitcoin-block 0.12.0 - Utility functions for manipulating bitcoin blocks  http://hackage.haskell.org/package/bitcoin-block-0.12.0 (solatis)
04:03:51 * hackagebot bitcoin-block 0.13.0 - Utility functions for manipulating bitcoin blocks  http://hackage.haskell.org/package/bitcoin-block-0.13.0 (solatis)
04:11:51 <P4Titan> Hello all, this is a Parsec question. Is there a way to convert a Parser String parser into something like Parsec ParserState () ParserState where ParserState is a newtype on String?
04:13:57 <ion> I wonder if coerce would work?
04:44:48 <jophish> Hi, I have a polynomial and I'd like to compute the first and second derivatives of it using ad
04:45:07 <jophish> forward mode should be best for this, right?
04:54:14 <saulzar> I think so, but the default will use something reasonable, no?
04:54:31 <maerwald> the reflection package is insane! Can't believe it works :D
04:59:55 <Haskellfant> maerwald: hehe I had the exact same feeling when I read about it a few days back
05:00:27 <maerwald> Haskellfant: I started reading the paper... and did not get much, except that they abuse type inference and classes a lot
05:00:37 <maerwald> glad they made it a library
05:00:47 <Haskellfant> maerwald: which paper are you talking about?
05:00:53 <maerwald> http://okmij.org/ftp/Haskell/tr-15-04.pdf
05:01:09 <maerwald> I was worried I have to implement that myself :P
05:01:27 <Haskellfant> afaik that's actually quite different from the implementation in the reflection package
05:01:32 <saulzar> What's the point? I'm reading and not quite what it does/what it's good for
05:01:41 <Haskellfant> there is a blogpost about the reflection package, let me get the link
05:01:56 <maerwald> Haskellfant: the reflection package even links to that paper
05:02:15 <bennofs> maerwald: the implementation of the reflection package actually contains a smart hack to make it much more efficient for GHC
05:02:19 <Haskellfant> maerwald: sure that's what the idea is based on, but I think the actual implementation differs https://www.fpcomplete.com/user/thoughtpolice/using-reflection
05:03:06 <bennofs> maerwald: I think they still have the slow-path for non-ghc implementations, but on GHC they use something difference
05:03:13 <maerwald> ok
05:03:31 <bennofs> maerwald: see http://hackage.haskell.org/package/reflection-1.5.1.2/docs/src/Data-Reflection.html#Reifies
05:03:45 <saulzar> Haskellfant, cool, thanks
05:04:26 <maerwald> saulzar: I will use it to move from static (compiled) configuration to dynamic configuration (read from file)
05:04:36 <maerwald> one options was the reader monad, but that would be painful
05:04:50 <maerwald> it's not worth a complete code refactor
05:05:19 <bennofs> maerwald: it uses the fact that in GHC, Reifies s a => c is internally represented as (proxy s -> a) -> c
05:06:13 <Haskellfant> it's kinda amazing how the implementation of a 15 pages paper is less than 15 lines of haskell
05:11:15 <maerwald> seems it's still a bit unknown, maybe someone should write an article on haskellwiki with _easy_ examples (not those ekmett writes) :P
05:15:13 <favetelinguis> in scala lazy arguments are evaluated once for each time it is called in the function, that is scala does not cache the result of lazy arguments as default, does haskell cache the evalautaion of its arguments as default?
05:16:10 <maerwald> it's call-by-need, not call-by-name
05:16:37 <bennofs> favetelinguis: yes, haskell it does. if you have let x = expensive in f x, x will only be evaluated once (as long as x and f are not both inlined)
05:16:51 <saulzar> Hmm.. so instead of passing a value around (of type a), you now give your functions a constraint (Reifies s a) which lets you magically procure a value of type a?
05:17:04 <hodapp> bennofs: is there a hard definition someplace for the 'sharing' that I think that hints at?
05:17:25 <hodapp> I was reading 'Type-Safe Observable Sharing' and couldn't find what that meant by 'sharing'
05:17:39 <maerwald> saulzar: my understanding is that they basically try to avoid wrapping the context inside a monad, but wrapping it inside a phantom type through class constraints
05:17:45 <maerwald> which makes it easier to work with
05:18:28 <maerwald> if it was a monad, you'll have a lot of unboxing and type mess
05:18:31 <saulzar> Hm, but wait, you still need the Proxy s
05:18:40 <P4Titan> Hello all, could someone aid me with fixing a flexible instances issue: I have the follow instance (Stream is from Text.Parsec.Prim): instance Monad m => Stream ParserSource m Char where ..., ParserSource is a newtype on String
05:18:44 <saulzar> Do you now need to pass that around everywhere instead?
05:18:50 <maerwald> saulzar: I have a minimal example here http://lpaste.net/132333
05:19:17 <maerwald> that uses the more simple "Given" class
05:21:17 <maerwald> so the only thing you have to do is add the class constraint Given if you use 'given' inside that function
05:22:11 <maerwald> the value is then inferred through the class thing magic
05:22:22 <saulzar> Hm, I see how that is useful.
05:23:26 <maerwald> I think that's enough mindblowing for my day :D
05:23:54 * hackagebot servant 0.4.0 - A family of combinators for defining webservices APIs  http://hackage.haskell.org/package/servant-0.4.0 (jkarni)
05:25:07 <saulzar> I assume there'll be an error if you use the wrong type...
05:26:35 <maerwald> saulzar: you mean in the class constraint?
05:26:54 <saulzar> Yeah
05:27:13 <maerwald> try changing (Given GlobalConfig) in doSomething to (Given Int) ...it will indeed not compile
05:27:36 <maerwald> the type error message is even not that bad
05:28:54 * hackagebot servant-blaze 0.4.0.0 - Blaze-html support for servant  http://hackage.haskell.org/package/servant-blaze-0.4.0.0 (jkarni)
05:28:56 * hackagebot servant-client 0.4.0 - automatical derivation of querying functions for servant webservices  http://hackage.haskell.org/package/servant-client-0.4.0 (jkarni)
05:28:58 * hackagebot servant-docs 0.4.0 - generate API docs for your servant webservice  http://hackage.haskell.org/package/servant-docs-0.4.0 (jkarni)
05:31:48 <saulzar> Wow, magical
05:32:04 <saulzar> You can even stack them
05:32:21 <saulzar> (Given GlobalConfig, Given Int) => ..
05:33:54 * hackagebot servant-jquery 0.4.0 - Automatically derive (jquery) javascript functions to query servant webservices  http://hackage.haskell.org/package/servant-jquery-0.4.0 (jkarni)
05:33:56 * hackagebot servant-lucid 0.4.0.0 - Servant support for lucid  http://hackage.haskell.org/package/servant-lucid-0.4.0.0 (jkarni)
05:33:58 * hackagebot servant-server 0.4.0 - A family of combinators for defining webservices APIs and serving them  http://hackage.haskell.org/package/servant-server-0.4.0 (jkarni)
05:44:45 <bennofs> hodapp: a precise definition is difficult, since the amount of sharing depends on compiler optimizations (inlining can affect sharing)
06:17:25 <bennofs> what does cause this: /tmp/nix-build-haskell-folds-0.6.2.drv-0/ghc31595_0/ghc31595_26.ldscript: file not recognized: File format not recognized
06:17:54 <bennofs> and later: collect2: error: ld returned 1 exit status
06:22:50 <fvgvxmpv1> bennofs, I¬¥m guessing patchelf
06:22:54 <fvgvxmpv1> why not ask in #nixos?
06:23:09 <bennofs> fvgvxmpv1: since it is cleary a result of calling ghc to build a package
06:23:23 <bennofs> fvgvxmpv1: it happens in the ./Setup build phase
06:24:53 <joncol> Hello, I need some help understanding a Functor instance. I'm going through Brent Yorgey's CIS194 spring 2013 course and I'm stuck on trying to understand his implementation of fmap for the Parser class (see 
06:25:14 <bennofs> joncol: your message has been cut after (see
06:25:18 <joncol> Hello, I need some help understanding a Functor instance. I'm going through Brent Yorgey's CIS194 spring 2013 course and I'm stuck on trying to understand his implementation of fmap for the Parser class (see http://www.seas.upenn.edu/~cis194/fall14/spring13/extras/11-applicative2/AParser.hs).
06:25:23 <bennofs> oh ok
06:25:33 <joncol> Sorry for double post
06:26:02 <joncol> The line I'm having trouble with is: fmap = inParser . fmap . fmap . first
06:26:20 <ion> joncol: You might benefit from deleting that implementation and trying to write your own.
06:26:25 <joncol> Why the double application of fmaps?
06:26:39 <joncol> ion> I already wrote my own working implementation
06:26:50 <joncol> But his is nicer and I want to understand it
06:27:25 <joncol> Mine looked like: fmap f p = Parser $ fmap (first f) . runParser p
06:28:03 <joncol> His uses the inParser helper function and those strange-looking double fmap's...
06:34:10 <ion> joncol: Let‚Äôs expand the point-free definitions. inParser f x = Parser (f (runParser x)); fmap f p = inParser (fmap (fmap (first f))) p = Parser (fmap (fmap (first f)) (runParser p)). The outer fmap :: (Maybe (a, String) -> b) -> (String -> Maybe (a, String)) -> (String -> b). The inner fmap :: ((a, String) -> b) -> Maybe (a, String) -> Maybe b. first :: (a -> b) -> (a, String) -> (b, String)
06:35:02 <ion> @type (fmap . fmap . first) _ (undefined :: String -> Maybe (a, String))
06:35:03 <lambdabot>     Found hole ‚Äò_‚Äô with type: b0 -> c
06:35:03 <lambdabot>     Where: ‚Äòb0‚Äô is an ambiguous type variable
06:35:03 <lambdabot>            ‚Äòc‚Äô is a rigid type variable bound by
06:35:34 <ion> Well, that output wasn‚Äôt too helpful.
06:36:18 <ion> (fmap . fmap . first) :: (a -> b) -> (String -> Maybe (a, String)) -> (String -> Maybe (b, String))
06:36:58 <Aruro> how to see how much memory lambdabot uses?
06:37:16 <ion> Run top on the same machine lambdabot is running on.
06:38:12 <Aruro> on my pc following command let a = foldl (+) 0 [1..5000000] uses 536020980 bytes of memory
06:38:15 <joncol> ion> Do you have an easier way of helping me understand that? Or are you just experimenting?
06:38:30 <Aruro> how to reduce that?
06:38:44 <ion> Aruro: Use foldl' instead.
06:38:50 <bennofs> Aruro: use foldl' from Data.List
06:39:52 <ion> joncol: I hoped this explanation would have been helpful enough. Just ignore the lambdabot part.
06:40:16 <haskell051> Could someone explain the following line of code to me? result = void $ pqExec query () - in particular I'm having trouble understanding the void and the () and what they mean in the positions they're in
06:40:20 <ion> Perhaps split the type signatures i wrote on separate lines to see it more clearly.
06:40:36 <joncol> ion> OK, thanks.
06:41:20 <dfeuer> Moaning, all.
06:41:29 <Aruro> ion: bennofs: it does win yes, especially in time, but memory usage is still 358319992 bytes
06:42:08 <Aruro> is there way to reduce that even more? it is roughly 60 times bigger than the size of the data [1..5000000]
06:42:18 <bennofs> Aruro: how do you measure memory usage?
06:42:27 <Aruro> :set +s
06:43:07 <geekosaur> ghci is unoptimized
06:43:09 <favetelinguis> does transducers make sense only in a non lazy setting. My thoght is that with lazyness you done have the problem transducers are solving?
06:43:44 <Aruro> geekosaur: so compiled it will show better result?
06:44:29 <geekosaur> somewhat better, yes. it might even fuse away the list
06:44:52 <geekosaur> but checking memory usage with ghci will always give you more allocations because it never optimizes away intermediates
06:44:55 <ion> haskell051: The () is a parameter to pqExec, and void replaces the result value with a (). void x = do { _ <- x; pure () }
06:44:58 <dfeuer> favetelinguis, my understanding is that transducers are a restricted version of ... lenses, maybe?
06:45:22 <dfeuer> void x = () <$ x
06:45:30 <dfeuer> Finally.
06:45:51 <Aruro> geekosaur: bennofs: memory checking in ghci is indeed bad idea
06:45:53 <dfeuer> void was defined directly until base 4.8, for no good reason.
06:46:05 <dfeuer> Which was very silly.
06:46:16 <ion> joncol:
06:46:17 <Aruro> for example in case of the list size [1..50000] it claims it uses 0 bytes :D
06:46:34 <ion> > first (+1) (42, "hello")
06:46:35 <lambdabot>  (43,"hello")
06:46:41 <ion> > (fmap . first) (+1) (Just (42, "hello"))
06:46:42 <lambdabot>  Just (43,"hello")
06:46:55 <dfeuer> Very silly because for some functors, <$ is greatly optimized.
06:46:56 <ion> > (fmap . fmap . first) (+1) (\s -> Just (42, s) "hello"
06:46:57 <lambdabot>  <hint>:1:55:
06:46:57 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
06:47:03 <ion> > (fmap . fmap . first) (+1) (\s -> Just (42, s)) "hello"
06:47:05 <lambdabot>  Just (43,"hello")
06:47:17 * dfeuer offers ion a pastry.
06:49:57 <Aruro> actually what is the way to measure accurately process speed and memory usage on linux?
06:50:25 * dfeuer throws his monoids on the floor and stomps away.
06:51:29 <joncol> ion> Thanks for that example.
06:57:52 <joncol> ion> Is it correct that one of the fmaps is the Maybe functor's fmap, and the other is the Reader functor's fmap?
06:58:29 <ion> joncol: Yes, the latter is specifically the ((->) r) fmap.
07:00:35 <joncol> latter = outer?
07:00:49 <ion> Yeah, latter as in latter in your sentence. :-)
07:01:16 <joncol> ion> Cool, thanks :)
07:01:18 <ion> FWIW, if i wanted to take advantage of inParser i would have written the instance as fmap f = inParser ((fmap . fmap . first) f). Reducing one point is often fine, but reducing two (fmap‚Äôs both parameters) is often confusing.
07:01:48 <joncol> ion> Agreed
07:03:46 <ion> The outer fmap is the (.) in your own definition.
07:04:10 * hackagebot breve 0.3.0.0 - a url shortener  http://hackage.haskell.org/package/breve-0.3.0.0 (rnhmjoj)
07:05:54 <joncol> ion> OK, I think I have some reading to do on the reader functor. Ehrm...
07:50:57 <SrPx> Stylewise, how would you guys leave this function: http://lpaste.net/132341 ... like I did? Like I did, but inlining everything (it fits 3 lines...) ... would you combine skeleton/pose and pos/dir intro a single object and have less arguments? Or something different entirely? 
07:51:03 <SrPx> (good morning ^_^)
07:57:00 <ob_> good morning, is nixos a proper env for haskell dev? is there a proper guide i can follow?
07:58:29 <gfixler> ob_: https://nixos.org/wiki/Haskell
07:59:16 <ob_> thanks, gfixler. and is nixos the right env?
07:59:29 <ob_> or should i use another?
07:59:47 <gfixler> ob_: nixos is a whole OS, so you'd use that instead of Mac or Linux, e.g.
08:00:22 <ob_> im running a nixos box on vagrant within windows
08:00:39 <ob_> but i dont know if thats the recommended setup 
08:00:55 <gfixler> ob_: I think it's the dream, but it's a bit hardcore for most users :)
08:00:57 <ob_> should i use nixos, minghc, haskell platform?
08:01:26 <ob_> yea my initial reaction to nixos is "wtf"
08:01:30 <gfixler> ob_: I think most - like me - are using the haskell platform
08:01:34 <ob_> wayyy out of my league
08:01:48 <gfixler> the biggest problem is cabal hell
08:02:01 <gfixler> but you can get around it pretty well with sandboxes
08:02:17 <ob_> ok cool
08:02:26 <gfixler> I think the standard way people work is with the haskell platform and a cabal sandbox for each project
08:02:55 <ob_> sandboxes are just virtual envs with their own dependencies right? 
08:03:01 <gfixler> most who've tried nixos - and I've heard of only a few - think it makes for an ideal haskell setup
08:03:14 <gfixler> and then there was one guy who thought the whole thing was crap, and left the nixos scene
08:03:54 <bennofs> docs on Haskell on nix are pretty bad atm
08:04:13 <gfixler> bennofs: yeah, and it's apparently in the middle of a huge transition
08:04:14 <bennofs> especially since there has just been a major change in the haskell packaging (haskellPackages -> haskellngPackages)
08:04:29 <bennofs> and there are about 0 docs for haskellng
08:04:36 <ob_> oh boy...things seem a little messy then 
08:05:25 <haskell380> can anyone help me with concatenating user defined lists?
08:05:27 <bennofs> (mind you, I use it, but it IMO it requires quite an investment and you really need to learn the Nix language. If you do that, you can just read the code and it's not so bad
08:05:50 <gfixler> bennofs: how worth it do you find it?
08:06:03 <gfixler> haskell380: I'm sure someone here can - what's the issue?
08:06:31 <haskell380> data List a = Empty | Element a (List a)  	deriving Show
08:06:38 <bennofs> gfixler: since my laptop is quite weak, it's really awesome to be able to share packages between 'sandboxes' (nix-shells in nix)
08:06:40 <haskell380> that is my type
08:07:11 <haskell380> and i want to use it to concatenate two lists together. so i have to catch the empty case and the case that it's not empty
08:07:28 <bennofs> also the binary cache is awesome (but it's also quite unreliable right now ng, as things are changing so fast that often the binaries you need are no longer available and you have to compile from source)
08:07:42 <haskell380> verketten :: List a -> List a -> List a verketten Leer  restb =  restb 
08:07:53 <haskell380> is my empty case which seems to compile alone
08:08:01 <haskell380> verketten resta restb =  resta verketten restb
08:08:15 <haskell380> and that is the other case but it doesn't work...
08:08:32 <bennofs> gfixler: I like just cd'ing into the lens checkout, and being able to load it into GHCi in ~1min. Most packages fetched from binary cache, no compilation needed!
08:08:48 <gfixler> bennofs: nice
08:09:23 <nshepperd> haskell380: your two cases are 'concat Empty restb = ?' and 'concat (Element a resta) restb = ?'
08:09:53 <haskell380> yes they are
08:11:26 <nshepperd> the first case is kinda obvious
08:11:46 <haskell380> it's restb yes
08:11:53 <haskell380> and that seem to work
08:11:57 <haskell380> but the second case doesn't...
08:12:07 <nshepperd> in the second case you have values 'a :: a', 'resta :: List a' and 'restb :: List a'
08:12:42 <nshepperd> how can you combine those into a result?
08:13:21 <haskell380> a:resta concat restb?
08:14:16 <nshepperd> just so
08:14:30 <haskell380> just so?
08:14:31 <nshepperd> Element a (concat resta restb)
08:15:14 <haskell380> it worked
08:15:17 <haskell380> thank you so much
08:15:19 <haskell380> but why? :D
08:16:36 <monochrom> induction hypothesis: suppose "concat resta restb" concatenates resta and restb.
08:17:31 <monochrom> induction step: then "a : concat resta restb" = "a : (concatenation of resta and restb)" = "concatenation of (a:resta) restb"
08:17:50 <favetelinguis> Can map fold etc be aborted during there execution, that is can i make a map that can terminate before the whole list is travered?
08:17:50 <monochrom> recursion is best understood by induction proof
08:17:56 <ob_> i think ill just go with a ubuntu on vagrant in windows
08:18:37 <tulcod> why don't dependently typed languages (idris, agda, ...) have type inference?
08:18:40 <monochrom> map cannot abort early. foldr can abort early but you have to code your operator for that
08:18:58 <bennofs> tulcod: because it's impossible (not decidable)
08:19:06 <monochrom> for example foldr1 (&&) [False, True, True, ...] aborts early
08:19:14 <tulcod> bennofs: but type checking is decidable
08:19:23 <bennofs> tulcod: yes, but inference isn't
08:19:28 <tulcod> bennofs: but i can enumerate all types
08:19:29 <haskell380> alright thank you!
08:19:48 <bennofs> tulcod: can you? I wouldn't be sure about that
08:20:07 <nshepperd> I'm not sure what it would mean for map to abort early
08:20:23 <tulcod> bennofs: okay, is it decidable whether a given string is a valid type?
08:21:13 <nshepperd> it's already lazy, so only the part of the result that is demanded later will actually get evaluated anyway
08:21:16 <tulcod> bennofs: also, is this problem strictly not decidable (ie is there a counterexample) or does simply no one know an algorithm?
08:21:41 <tulcod> (counterexample meaning type inference implies the halting problem or something like that)
08:22:30 <nshepperd> I suppose that could describe a map fused with a takeWhile
08:22:45 <bennofs> tulcod: hmm, I'm not an expert in this area. But maybe http://cs.stackexchange.com/questions/12691/what-makes-type-inference-for-dependent-types-undecidable explains it?
08:23:07 <bennofs> Or http://stackoverflow.com/questions/1251254/what-are-the-limits-of-type-inference
08:23:33 <favetelinguis> monochrom: is there a way to see the implementation of && in prelude i checkd hoogle but could not find more then the type there
08:24:50 <ziman> dependently typed languages have not only type inference but also value inference (because it's the same thing there)
08:24:52 <tulcod> bennofs: thanks
08:24:59 <monochrom> find the doc of Prelude (e.g., your own hard disk, it comes with GHC; hackage). then look for "source" links
08:25:06 <tulcod> ziman: wait what?
08:25:10 <ziman> it's just you sometimes have to give a type signature if the machine is unable to infer the type
08:25:19 <ziman> because it's not always possible
08:25:36 <tulcod> ziman: okay but this is extremely confusing. it doesn't have either of these properties in the mathematical sense.
08:25:38 <ziman> you generally give just top-level signatures
08:25:45 <tulcod> it's not like given a type it can find a value, or vice versa
08:26:00 <tulcod> (ie always)
08:26:19 <ziman> yeah but fortunately often types and values can be inferred from the context
08:27:02 <ziman> "not always" does not mean "never"
08:27:48 <tulcod> ziman: okay, but "to have", at least in this channel, I would say means "to have always"
08:28:47 <ziman> I see, then yeah
08:29:07 <monochrom> you should ask people who actually wrote agda. not people who never actually wrote agda.
08:29:41 <monochrom> I do not understand the logic of asking anyone except the one who actually knows or decides.
08:30:28 <tulcod> monochrom: is that a complicated way to say "you should try asking in #agda"?
08:30:41 <monochrom> I don't know. I don't even know who are there.
08:30:47 <tulcod> exactly.
08:31:03 <monochrom> but there are email addresses on agda's hackage page etc
08:31:24 <tulcod> yes, but i just wanted a quick answer, and i got one
08:33:11 <ziman> there are nice and competent folks in #agda
08:34:00 <ziman> but you might have to wait a bit to get an answer
08:36:11 <tulcod> ziman: thanks, i'll keep that in mind for my next question about dependent types :)
08:38:11 <gfixler> bennofs: I can't even seem to google for haskellngpackages
08:38:23 <gfixler> I'm finding people using the term, but nothing defining it
08:38:32 <bennofs> gfixler: it's also called haskell-ng
08:38:43 <bennofs> http://stackoverflow.com/questions/29033580/how-do-i-use-the-new-haskell-ng-infrastructure-on-nixos
08:39:14 <gfixler> and maybe this? http://lists.science.uu.nl/pipermail/nix-dev/2015-January/015591.html
08:39:27 <bennofs> es
08:43:07 <Big_G> What are nixos and haskell-ng
08:49:08 <gfixler> Big_G: nixos.org
08:49:49 <gfixler> How does 2 + Just 3 work? I presume fromInteger is involved.
08:49:59 <gfixler> but why is it automatic?
08:50:08 <geekosaur> > 2 + Just 3
08:50:09 <lambdabot>      No instance for (Show a0)
08:50:09 <lambdabot>        arising from a use of ‚Äòshow_M50448614494851451418128‚Äô
08:50:09 <lambdabot>      The type variable ‚Äòa0‚Äô is ambiguous
08:50:12 <Big_G> gfixler, Thanks. Why would I use it over another distro
08:50:13 <geekosaur> it's not automatic
08:50:25 <geekosaur> unless someone created a Num instance for Maybe
08:50:34 <gfixler> Big_G: http://nixos.org/nixos/about.html 
08:50:45 <Big_G> I should learn how to google
08:50:47 <gfixler> geekosaur: there is a Num instance for Maybe
08:50:51 <gfixler> Big_G: it says it on the front page
08:51:04 <gfixler> Big_G: it's the link at the end of the first paragraph
08:51:12 <Big_G> Thanks
08:51:17 <geekosaur> not in the stock Prelude
08:51:36 <gfixler> geekosaur: really? I just installed the haskell platform
08:51:41 <gfixler> maybe that adds it in
08:52:04 <geekosaur> I have the Platform installed as well. no Num instance for Maybe visible here
08:52:15 <gfixler> :i Maybe
08:52:19 <gfixler> it doesn't list Num?
08:53:18 <lpaste> geekosaur pasted ‚Äú:i Maybe‚Äù at http://lpaste.net/132347
08:53:20 <gfixler> I get instances for Num, Eq, Monad, Functor, Ord, Read, Show, and MonadPlus
08:53:31 <gfixler> hmmm
08:53:35 <gfixler> version difference?
08:53:37 <geekosaur> where does it say it's defined?
08:53:58 <geekosaur> (MonadPlus implies you have Control.Monad imported)
08:54:03 <gfixler> geekosaur: d'oh - in my own .hs file :(
08:54:18 <gfixler> geekosaur: didn't realize I had anything loaded
08:54:41 <gfixler> but more to the point
08:54:59 <gfixler> I defined a Num instance for Maybe a, but then 4 + Just 5 worked automatically
08:55:03 <nshepperd> it's possible to define an 'instance (Applicative f, Num a) => Num (f a)'
08:55:04 <gfixler> I get Just 9
08:55:10 <geekosaur> right
08:55:15 <gfixler> but I don't know how it's doing that
08:55:19 <nshepperd> but actually doing so is generally considered perverse
08:55:41 <geekosaur> numeric literals get fromInteger or fromRational applied to them automatically
08:55:49 <nshepperd> gfixler: yeah, 4 is "desugared" as 'fromInteger (4 :: Integer)'
08:55:49 <gfixler> yes, that's what my question is
08:56:08 <nshepperd> so that you can use numeric literals in any Num context
08:56:09 <gfixler> ah, is that just always happening under the hood?
08:56:37 <monochrom> your code is desugared to: fromInteger 4 + Just (fromInteger 5). note: the two "fromIntegers" are different, they call up different instance code
08:56:54 <geekosaur> since (+) is seeing (fromIntegral 4) + (Just (fromIntegral 5)), it has to make the types fit and the simplest type that works is (+) :: Maybe Integer -> Maybe Integer -> Maybe Integer
08:57:08 <gfixler> interesting
08:57:12 <geekosaur> this is described in the Report
08:57:16 <gfixler> and yes, 2.3 + Just 4 does not work
08:57:46 <gfixler> so when it reads in the 3 that I type, it recognizes that it can consider it an int and do fromInteger on it
08:58:14 <geekosaur> https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1360006.4.1 https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-790004.3.4
08:58:29 <gfixler> thanks, I shall read
08:58:43 <gfixler> monochrom: I'm not sure why/how the fromIntegers are different
08:59:23 <geekosaur> the type of (+) forces (fromInteger 4) and (Just (fromInteger 5)) to have the same type
08:59:40 <monochrom> fromInteger_for_Maybe 4 + Just (fromInteger_not_for_Maybe 5)
09:00:11 <geekosaur> so the first fromInteger must be the one from Maybe, because of the Just in the second parameter of (+)
09:00:41 <geekosaur> then defaulting resolves the second one to Integer, and that resolves the full type of the first one to Maybe Integer
09:00:42 <gfixler> oh, right - now I see
09:01:20 <gfixler> the fromInteger_not_for_Maybe - where is that coming from?
09:01:33 <geekosaur> defaulting, as I just said
09:01:41 <geekosaur> see the second link I pasted above
09:01:45 <gfixler> ok
09:02:01 <gfixler> there's quite a lot of implicit stuff going on in Haskell
09:02:08 <geekosaur> what it knows at that point is (+) :: Num a => Maybe a -> Maybe a -> Maybe a
09:02:58 <geekosaur> so it goes through the types specified for `default`, which by default is (Integer, Double). Integer produces an expression that typechecks, so is selected
09:03:14 <gfixler> implicit in this discussion: I should read the entire Haskell report
09:04:50 <ion> Doesn't the default defaulting list also include ()?
09:05:23 <geekosaur> only in ghci, via LANGUAGE ExtendedDefaultRules
09:05:28 <ion> Ok
09:09:00 <ion> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/interactive-evaluation.html#extended-default-rules
09:09:06 <geekosaur> (ghci turns on ExtendedDefaultRules, and in sufficiently recent versions NoMonomorphismRestriction, by default)
09:09:32 <geekosaur> try :showi language
09:10:24 <monochrom> the () default is why asking quickcheck "mirror mirror, is 'reverse xs = xs' always true?" gets you "yes!"
09:10:45 <monochrom> (the pun about mirror and reverse is 50% intentional!)
09:17:18 <ion> geekosaur: nice
09:18:01 <Big_G> What are the best practices when dealing with the Nothing part of maybe
09:18:37 <tulcod> Big_G: that question is very vague
09:18:47 <tulcod> Maybe types are used in a whole bunch of different contexts
09:18:59 <tulcod> so there is no rule of thumb for what Nothing means
09:19:04 <Big_G> tulcod, I'll try and clarify
09:20:06 <Big_G> For example, when I have a maybe Int, I'll have two cases. However, if I do all of these computations and the end result is nothing, I've wasted my time
09:20:34 <Big_G> Does that help?
09:20:42 <tulcod> no
09:20:50 <kadoban> Big_G: Not really. I don't think you can avoid that, in general.
09:20:56 <tulcod> Big_G: in general, Nothing values mean that you can skip doing any other computation
09:21:07 <tulcod> Big_G: they are typically "viral" in some sense
09:21:16 <Big_G> viral?
09:21:19 <tulcod> but this is no hard-and-fast rule
09:21:32 <tulcod> yeah, in the sense that combining any value with a Nothing *typically* produces a Nothing
09:21:40 <Big_G> What if the computation has to have some real end value. Would it be OK to just run those computations all again?
09:21:46 <tulcod> but again, definitely not always, and i don't even dare say "usually"
09:22:02 <tulcod> Big_G: that depends 100% on what you're computing
09:22:15 <Big_G> For example, if I have user input and want to get the nth prime
09:22:19 <tulcod> if it's a pure function you're computing, computing it again will give you Nothing again
09:23:06 <tulcod> if you have some kind of probabilistic algorithm, it would make sense to wrap it into a function that runs the probabilistic algorithm until you get a value. you can then think about the efficiency of the resulting algorithm.
09:23:19 <tulcod> (as well as correctness i suppose)
09:24:22 * hackagebot sandi 0.3.5 - Data encoding library  http://hackage.haskell.org/package/sandi-0.3.5 (MagnusTherning)
09:24:22 <Big_G> In my user input example, would I still want to use maybe or something else?
09:25:11 <tulcod> Big_G: i'm not trying to be mean, but i really don't know what you're trying to do
09:25:29 <tulcod> you have user input, sure. and you're trying to compute the nth prime, sure. we have algorithms for computing primes. is the user input the number n?
09:25:40 <tulcod> why would the prime-computing algorithm return Nothing?
09:25:40 <monochrom> I am not sure where your "Nothing" comes from. does it come from parse error of user input? does it come from being unable to find the nth prime?
09:25:49 <Big_G> tulcod, The main issue is that I don't either. I'm trying to think of scenarios that Nothing may cause issues
09:26:01 <tulcod> Big_G: why do you even talk about Maybe types?
09:26:05 <kadoban> Big_G: It may help to ground it in concrete problems you want to solve.
09:26:06 <tulcod> where do you introduce Maybe?
09:26:21 <Big_G> If the user entered in -1, that might be evaluated to Nothing since the -1st prime doesn't make sense
09:26:24 <tulcod> what is the first line of code (temporally) that talks about Maybe type/
09:26:29 <Big_G> tulcod, They're interesting 
09:26:42 <Big_G> kadoban, Agreed. I'll go think of one
09:26:48 <tulcod> Big_G: "interesting" does not imply "appropriate for this situation"
09:27:03 <tulcod> Big_G: but yes, a -1 input should not make sense, and you should not return any number, so a Nothing return value makes sense
09:27:13 <monochrom> ok, then it's the UI that deals with that Nothing. you keep pestering the user until they give you a good number.
09:27:13 <tulcod> how you want to return this information to the user is up to you
09:27:20 <tulcod> presumably you should give some error message
09:27:30 <monochrom> note that during that pestering you do not even call the "nth prime finder".
09:27:44 <monochrom> therefore, the "nth prime finder" is never going to see Nothing
09:27:52 <Big_G> That's what I wanted to figure out. You just loop on the user and probably wouldn't even need the maybe, right?
09:28:06 <monochrom> only the UI loop ever sees Nothing (or any representation of parse error)
09:28:40 <tulcod> Big_G: well you'd probably want to use readMaybe to parse the user's input
09:28:51 <Big_G> Good idea
09:29:00 <tulcod> because consider the option of the user typing "blabla" instead of any number. then that should be erroneous input that doesn't crash your program
09:29:09 <monochrom> you can call readMaybe for parsing. it can give Nothing. this is how your UI loop may see it.
09:29:19 <tulcod> then once you've readMaybe'd an integer, you should verify it is >=1
09:29:43 <tulcod> then you can call this prime function thing, and report the results to the user
09:30:49 <tulcod> Big_G: but in fact there are many ways to deal with errors in haskell (and there is no "best solution" in general). you might also want your types to be represented by Either String Int instead of Maybe Int
09:31:01 <tulcod> so then you can pass along the actual reason there is no output value
09:31:28 <kadoban> Although for something so simple, Maybe should really be fine.
09:31:31 <tulcod> or some kind of a ReaderT Maybe (ie a stack of monads) so that you can write several reasons
09:31:46 <tulcod> s/write/report/
09:32:24 <tulcod> (uhh i guess that should be ReaderT [String] Maybe)
09:32:34 <tulcod> (uh. WriterT. darn.)
09:33:58 <exio4> or maybe ExceptT 
09:34:29 <exio4> tulcod: maybe WriterT (DList String) would be better, too
09:34:59 <tulcod> exio4: thanks :)
09:35:18 <rotten_bunny> hey guys 
09:37:00 <rotten_bunny> can any one read my text ?
09:37:19 <tulcod> rotten_bunny: yes
09:37:40 <rotten_bunny> wheeew thanks, i was beginning to think i was going mad 
09:37:46 <zegeri> tulcod: Who are you talking to?
09:37:59 <rotten_bunny> ha nice try zegeri 
09:39:13 <orion> What do most sysadmins do when they are tasked with deploying a Haskell application to production?
09:39:19 <orion> In a devops environment.
09:39:50 <dmwit> orion: There was a recent thread on reddit about this. Consensus seemed to be "statically link, gzip+scp".
09:40:09 <orion> hah
09:40:21 <orion> I am already there on the static linking.
09:40:32 <orion> It would be nice to puppetize the process.
09:40:44 <dmwit> orion: http://www.reddit.com/r/haskell/comments/34m4bq/people_using_haskell_in_production_what_is_your/
09:41:22 <orion> dmwit: Thank you
09:41:31 <orion> Wow, only 8 days old.
09:41:57 <dmwit> Hopefully none of the advice is out of date yet. ;-)
09:41:57 <tulcod> orion: i guess a modern fancy solution would be docker
09:49:23 * hackagebot ad 4.2.2 - Automatic Differentiation  http://hackage.haskell.org/package/ad-4.2.2 (EdwardKmett)
09:53:11 <erisco> so, this liquidhaskell is kind of the most amazing thing ever
09:53:25 <orion> tulcod: Docker is eh to me.
09:55:34 <tulcod> orion: what do you mean? it's efficient, it's running production code, it solves problems
09:58:08 <orion> tulcod: It just seems like a glorified jail to me.
09:58:41 <orion> If I wanted the features that Docker provides, I'd probably use FreeBSD jails.
09:59:01 <tulcod> i think you're underestimating the value of various docker features
09:59:34 <tulcod> e.g. its efficiency. docker uses (depending on the filesystem) copy-on-write, which means copying two such jails is almost instant
09:59:46 <tulcod> (and subsequently very efficient with diffs)
10:01:13 <xaxes`> http://iops.io/blog/docker-hype/
10:02:57 <luzie> orion, docker doesn't do that
10:03:32 <luzie> it's basically just a deployment tool, it doesn't provide (much) security
10:04:04 <tulcod> xaxes`: i don't get this article. it's just a list of features docker doesn't have. that doesn't imply it's "an absolute shit show".
10:05:38 <tulcod> orion: look, i'm not saying you *need* to use it, but it is fancy and it solves some problems and can be very efficient for many tasks.
10:09:19 <nick_named> 
10:10:04 <JoshieAS> I was wondering if someone could help me figure out how to use drawVerticalTree from Data.Tree
10:11:31 <joneshf-laptop> JoshieAS, where is this?
10:11:59 <nick_named> Is there a library that builds both a command line interface and an interactive shell, like the OpenSSL CLI?
10:13:10 <JoshieAS> as in, why do I need to do this or where is drawVerticalTree?
10:13:31 <dmwit> :t Data.Tree.drawVerticalTree
10:13:32 <lambdabot> Not in scope: ‚ÄòData.Tree.drawVerticalTree‚Äô
10:13:33 <joneshf-laptop> JoshieAS, where did you find the function?
10:13:40 <dmwit> :t Data.Tree.drawTree -- you mean this?
10:13:41 <lambdabot> Tree String -> String
10:13:46 <JoshieAS> https://hackage.haskell.org/package/pretty-tree-0.1.0.0/docs/Data-Tree-Pretty.html
10:13:58 <JoshieAS> drawTree will suffice, too
10:14:08 <JoshieAS> if I understand one it'll help me with the other
10:14:16 <dmwit> Okay. What do you need to know?
10:14:31 <JoshieAS> it says it takes a Tree String and returns a String
10:14:37 <JoshieAS> does that mean that my root label has to be a String?
10:14:46 <dmwit> All the labels have to be Strings, yes.
10:14:56 <dmwit> You can use `fmap :: (a -> String) -> Tree a -> Tree String`.
10:14:58 <dmwit> To convert.
10:14:59 <JoshieAS> so if I have a Tree whose root labels are ints...?
10:15:03 <JoshieAS> Oh, I see
10:16:43 <JoshieAS> thanks!
10:16:54 <lokathor> nick_named, you could use interact :P
10:32:36 <kadoban> What's the best way resource to learn some basic template haskell?
10:32:44 <kadoban> s/way//
10:33:12 <tulcod> kadoban: in my experience, just using it. it's kinda subtle but by using it you see how it fits together.
10:34:07 <kadoban> tulcod: I don't really know /anything/ about it except that it exists and it happens at compile time. Where do I even find the basics presented well?
10:34:34 <tulcod> kadoban: and one key thing it took me a while to understand is that the Q monad encodes scope dependency of expressions. not sure if you understand that right now but keep it in mind, perhpas.
10:35:04 <kadoban> I'll make a note
10:35:15 <tulcod> kadoban: well there are some tutorials, did you have a look at those?
10:35:56 <kadoban> tulcod: Not really, was hoping for a recommendation on which one(s) are any good mostly, if any are better than the rest.
10:36:44 <tulcod> kadoban: i think i started by reading the official docs, then try to implement some stuff, run into problems, try to fix them, repeat
10:37:09 <tulcod> official docs https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/template-haskell.html
10:37:18 <kadoban> Alrighty, sounds like a plan. Thanks.
10:37:36 <tulcod> kadoban: note that template haskell code is *executed* at compile time
10:37:48 <tulcod> kadoban: if you want, you can read/write IO at compile time with TH
10:38:15 <tulcod> the TH code essentially "generates haskell code" that is inserted at "splices"
10:38:29 <kadoban> Cool, that sounds like exactly what I'm looking for.
10:39:01 <tulcod> (and you can get the resulting code using -ddump-splices )
10:39:34 <kadoban> That sounds very helpful
10:46:24 <tulcod> kadoban: also, make sure you use a recent version of ghc, especially if you're gonna do stuff with classes and instances
10:47:49 <kadoban> Yeah, I'm on 7.8.4, which is hopefully enough for what I want to do (which is itself pretty basic/dumb)
10:48:45 <orion> I am writing a RESTful API, and I need to be aware of different API versions (e.g. GET /v1/method). I created a type: data API = API V1, but I am unsure if this is the best approach, or if it is, how to proceed from here.
10:51:23 <nocturne777> orion: there's not a common convention when it comes to versioning REST APIs
10:51:29 <nocturne777> each company does it differently
10:53:50 <orion> nocturne777: Internally in the code you mean?
10:54:12 <nocturne777> orion: the versioning of the APIs
10:55:10 <nocturne777> orion: http://stackoverflow.com/questions/2024600/rest-api-versioning-only-version-the-representation-not-the-resource-itself
10:55:54 <orion> Well, we've already settled on /v1/method, what I'm stuck on it how to retrofit my existing application to support multiple versions.
10:56:04 <orion> I.e., what data types are needed, etc.
10:56:37 <tulcod> orion: I would say this is purely a routing (as in URL -> method routing) issue, and not really to do with data-types
10:56:48 <tulcod> just my opinion though. really depends on the application.
10:57:18 <ion> Side note: /v1/‚Äúmethod‚Äù doesn‚Äôt sound very RESTful. :-P
10:57:28 <orion> tulcod: Ahh, in this case all API calls get transformed to JSON-RPC calls.
10:57:37 <orion> In fact, that's the sole purpose of my Haskell application.
10:57:57 <orion> HTTP -> Haskell app -> RabbitMQ<JSON-RPC>
10:58:12 <tulcod> orion: then it depends on the API of that.
10:59:25 * hackagebot yxdb-utils 0.1.0.1 - Utilities for reading and writing Alteryx .yxdb files  http://hackage.haskell.org/package/yxdb-utils-0.1.0.1 (MichaelBurge)
11:07:07 <phaazon> aaaw
11:07:22 <phaazon> I‚Äôve found a way to put a function type in Eq :3
11:07:25 <phaazon> that‚Äôs so handy
11:07:38 <phaazon> the instance implementation is ridiculously simple
11:07:47 <phaazon> thanks to referential transparency
11:08:17 <geekosaur> http://hackage.haskell.org/package/universe
11:09:25 * hackagebot word-trie 0.3.0 - Implementation of a finite trie over words.  http://hackage.haskell.org/package/word-trie-0.3.0 (DmitryIvanov)
11:10:08 <ion> What‚Äôs ‚Äúreverse‚Äù about Data.Universe.Instances.Reverse?
11:10:59 <kuribas> Is there an alternative for [a | MyData a <- as]?
11:11:25 <ion> kuribas: Is MyData the only constructor for the type?
11:11:30 <kuribas> ion: nope
11:11:45 <ion> In that case, that (or the equivalent do notation) is probably the nicest.
11:12:09 <kuribas> Does it use fail?
11:12:34 <ion> The do version does at least.
11:13:25 <kuribas> Shouldn't fail be avoided?
11:14:20 <geekosaur> this case is more or less why fail was added to Monad in the first place
11:14:25 * hackagebot conceit 0.3.1.0 - Concurrent actions that may fail  http://hackage.haskell.org/package/conceit-0.3.1.0 (DanielDiazCarrete)
11:14:27 * hackagebot yi-language 0.2.0 - Collection of language-related Yi libraries.  http://hackage.haskell.org/package/yi-language-0.2.0 (DmitryIvanov)
11:14:32 <geekosaur> and yes, later thinking os that wasn't such a hot idea
11:14:36 <geekosaur> *is that
11:16:20 <kuribas> Basicly what I want to do is using an association list, were the alternatives are given by the sum type.
11:16:57 <kuribas> However I don't know another way to lookup elements.
11:16:59 <tulcod> ion: order in which the elements of `a` are evaluated in `a -> b`?
11:17:19 <tulcod> just a guess
11:19:15 <nocturne777> do most people use Safe Haskell in production?
11:19:36 <kuribas> Basicly what I want is a typed association list.
11:20:21 <kuribas> hm, maybe lens could do the trick?
11:23:20 <ion> > [ Just 0, Just 1, Nothing, Just 2 ] ^.. traverse . _Just
11:23:21 <lambdabot>  [0,1,2]
11:24:18 <Iceland_jack> > catMaybes [ Just 0, Just 1, Nothing, Just 2 ]
11:24:19 <lambdabot>  [0,1,2]
11:25:20 <ion> Iceland_jack: Just and Nothing stood for the constructors of kuribas‚Äô type.
11:25:42 <Iceland_jack> That's what I get for not reading up
11:27:14 <kuribas> What's the non-line nois version of ^..?
11:27:19 <jmcarthur> > foldMap F.toList [ Just 0, Just 1, Nothing, Just 2 ]
11:27:20 <lambdabot>  [0,1,2]
11:27:56 <ion> > toListOf (traverse . _Just) [ Just 0, Just 1, Nothing, Just 2 ]
11:27:58 <lambdabot>  [0,1,2]
11:28:16 <kuribas> great, thanks!
11:29:50 <kuribas> > listToMaybe $ toListOf (traverse . _Just) [ Just 0, Just 1, Nothing, Just 2 ]
11:29:51 <lambdabot>  Just 0
11:30:04 <kuribas> > listToMaybe $ toListOf (traverse . _Just) [Nothing]
11:30:05 <lambdabot>  Nothing
11:30:09 <Iceland_jack> > msum [ Just 0, Just 1, Nothing, Just 2 ]
11:30:10 <lambdabot>  Just 0
11:30:32 <kuribas> Iceland_jack: that's useless for my type...
11:31:03 <ion> > preview (traverse . _Just) [ Just 0, Just 1, Nothing, Just 2 ]
11:31:05 <lambdabot>  Just 0
11:31:54 <ion> or (^?)
11:33:39 <kuribas> How do I generated that for my own types?  I tried makeLenses ''Annotation, but it didn't work...
11:34:10 <ion> See makePrisms
11:34:19 <kuribas> ion: ok, thanks
11:34:29 <kadoban> Heh ‚Ä¶ hdevtools seems to not like even modestly large literal lists. I have like ~500 integers in a list and it's taking /forever/ to do ‚Ä¶ not much.
11:40:32 <peacememories> hey people. any of you tried using pkg-config on windows?
11:40:53 <peacememories> i'm trying to install helm via cabal, and obviously need some deps (like sdl2), but i can't get the compiler to find the headers
11:41:19 <peacememories> i configured pkg-config to search in c:\pkg-config for .pc files, and copied the sdl2 .pc file there
11:41:44 <peacememories> then i tried changing the prefix paths in there (because windows...)
11:42:01 <kuribas> > pre (traverse . _Just) [ Just 0, Just 1, Nothing, Just 2 ]
11:42:02 <lambdabot>      Couldn't match type ‚Äò[]‚Äô with ‚Äòp (Maybe a)‚Äô
11:42:02 <lambdabot>      Expected type: p (Maybe a) (Maybe (Maybe a))
11:42:02 <lambdabot>        Actual type: [Maybe (Maybe a)]
11:42:04 <peacememories> so i tried /c/... c:\\... and c:/...
11:42:21 <peacememories> doesn't seem to work
11:52:21 <fm75> Hi all... Quick question: is ghc 7.10 available on nix? It seems so (on github) but I can't really manage to get it installed
11:58:23 <geekosaur> 7.10 apparently has some problems on nix, if the email I just saw go by is any indication
11:59:35 <geekosaur> https://mail.haskell.org/pipermail/ghc-devs/2015-May/008992.html
12:14:27 * hackagebot wreq 0.4.0.0 - An easy-to-use HTTP client library.  http://hackage.haskell.org/package/wreq-0.4.0.0 (BryanOSullivan)
12:14:29 * hackagebot sorted-list 0.1.4.0 - Type-enforced sorted lists and related functions.  http://hackage.haskell.org/package/sorted-list-0.1.4.0 (DanielDiaz)
12:19:28 * hackagebot sorted-list 0.1.4.1 - Type-enforced sorted lists and related functions.  http://hackage.haskell.org/package/sorted-list-0.1.4.1 (DanielDiaz)
12:24:28 * hackagebot sorted-list 0.1.4.2 - Type-enforced sorted lists and related functions.  http://hackage.haskell.org/package/sorted-list-0.1.4.2 (DanielDiaz)
12:28:54 <dan64> If I run "hoogle map", hoogle returns the type signatures for various map functions. Is there some way to query hoogle CLI for the documentation string that is shown here: http://hackage.haskell.org/package/base-4.8.0.0/docs/Prelude.html#v:map ?
12:31:45 <kadoban> Trying to understand TH, so I'm looking at: http://rosettacode.org/wiki/Compile-time_calculation#Haskell  Is it me or is this example completely wrong? It seems, based on -ddump-splices and timing tests to just literally put 'fact 10' in the code at that point, and all of the calculation happens at runtime.
12:33:48 <heatsink> kadoban: That is what it does.  $() and [| |] cancel each other out.
12:34:23 <heatsink> kadoban: To evaluate at compile time, you would write something like $(intE (fact 10))
12:35:03 <orion> How could I go about enumerating over all possible values of a sum type?
12:35:07 <kadoban> heatsink: Haha, great :-/ And what it's trying to do there isn't actually possible, because 'fact' is in the same module, right?
12:35:10 <heatsink> That runs (intE (fact 10)) at compile time.  fact 10 returns an Int.  intE converts it to a Haskell expression.
12:35:50 <heatsink> kadoban: That is allowed since fact isn't actually executed at compile time.  If it were executed at compile time, it would have to be in another module.
12:36:12 <c_wraith> it could also be written as something like $(let x = fact 10 in [| x |])
12:36:21 <kadoban> heatsink: Okay, thanks very much, that was very helpful.
12:37:21 <kadoban> c_wraith: That's the same as the doesn't-really-do-anything version you mean, right?
12:37:42 <c_wraith> kadoban: no, that does the work at compile-time
12:38:27 <kadoban> Hmm. I have /much/ more reading to do ‚Ä¶
12:38:36 <c_wraith> kadoban: the important part is the *expression* inside the [| |]
12:41:46 <kadoban> c_wraith: Interesting, that certainly seems to work. I'm a /super/ beginner, so I'll just read more and see if I can figure out why.
12:42:16 <c_wraith> kadoban: you can actually play with this inside ghci, if you like.  enable -ddump-splices and -XTemplateHaskell, and just play around. :)
12:42:24 <tulcod> kadoban: the following would work: http://lpaste.net/132354
12:43:20 <tempname11_> build question. what is the best tool to ensure that a snapshot of my code will successfully compile (with no changes to it) in a few years? I guess what I need is a sort of a time capsule with GHC and all necessary tooling inside.
12:43:41 <tempname11_> nix spring to mind, but I have no experience with it and can't tell if it's what I need
12:43:43 <kadoban> Huh it does, thanks to you too. Yeah, I've got a test file and some -ddump-slices, which is super helpful.
12:43:46 <tulcod> tempname11_: you mean with different versions of other libraries?
12:44:10 <tempname11_> tulcod: I guess versions of libraries would be frozen
12:44:20 <c_wraith> tempname11_: recent versions of cabal have a freeze command
12:44:51 <tulcod> tempname11_: you may be looking for LTS haskell
12:44:58 <tempname11_> yeah, I considered that, but cabal will not protect me from GHC changes (like the current 7.10)
12:45:35 <tulcod> tempname11_: doesn't it include ghc?
12:45:44 <c_wraith> tempname11_: it should freeze base, too.  and that means you need the same version of ghc
12:45:51 <int-e> Hmm, how do intel core i5 and AMD's FX series compare with Haskell's rather special workload? (which means a lot of random memory access following around pointers on the heap) It looks like intel's single-threaded performance is quite a bit bigger in benchmarks these days...
12:45:54 <c_wraith> tempname11_: since base is updated when ghc is
12:46:07 <tempname11_> tulcod: I'll check out LTS haskell now
12:47:02 <tulcod> tempname11_: i mean somehow you'll want to make sure you can keep the same versions of ghc, base, libraries, and dependent C libraries (depending on how many years we're talking about)
12:47:33 <tempname11_> c_wraith: that would be sufficient. But I guess it will then only compile with a compatible GHC, and it will be on my shoulders to ensure I use the correct one?
12:47:43 <tulcod> int-e: i am on a recent i5 if i can do some quick benching for you
12:47:56 <c_wraith> tempname11_: that's correct.  But the way ghc changes, that's basically true anyway.
12:48:19 <c_wraith> tempname11_: any time you change major versions of ghc, something is likely to break
12:48:38 <gfixler> this is the problem nix was designed to battle
12:48:49 <gfixler> it's the only thing I've seen that goes all the way
12:49:01 <gfixler> although... I don't know what happens if nix eventually works a different way
12:49:09 <tulcod> gfixler: well i'm not sure. tempname11_ asked for a way to make stuff "compile" in a few years. in nixos, you just keep old versions around.
12:49:41 <int-e> tulcod: thanks, but I have nothing concrete in mind (I'm sort of hoping that somebody has already put up nofib benchmark results for several platforms somewhere)
12:49:43 <tulcod> i mean wasn't the purpose of nixos to solve dependency hell?
12:49:46 <enthropy> gfixler: I don't think so. It's not like ghc-6.6 will install from nixpkgs today without any work
12:49:50 <gfixler> tulcod: but tempname11_ said "ensure," which I'm not sure you can do without always using all the same original versions
12:50:24 <tulcod> tempname11_: okay i think the general consensus is "keep old stuff around" :P
12:50:28 <gfixler> enthropy: well, I don't know if we can call nix done yet
12:50:36 <tempname11_> I can keep old versions of libraries and tools around, it's no problem. I just need to do it in a manageable way
12:50:38 <enthropy> so I imagine some day ghc-7.8 will no longer be supported by nixpkgs
12:50:47 <gfixler> tulcod: for other things I use git with submodules
12:51:08 <tulcod> tempname11_: well i think practically, i'd say keep an old linux install around, don't update it. also don't ever EVER connect it to the internet.
12:51:48 <Rotaerk> that's called "hoarding", you crazy mofo
12:51:55 <gfixler> enthropy: but we'll have the hash, so we can always rebuild it
12:52:03 <gfixler> we just have to try all combos of bits until we get the hash again
12:52:18 <latk> how hard is it to use ghcjs/reflex at the moment ? 
12:52:42 <tulcod> gfixler: i can think of several reasons why that won't work
12:53:15 <tulcod> latk: coding or ecosystem?
12:53:25 <tulcod> cause apparently ghcjs is a pita to install (i have no experience there)
12:54:02 <latk> tulcod: both :p. I've a small project that has the server written in haskell, and I would probably use reactjs otherwise. Thought I might give ghcjs/reflex a go, but if it is going to take me days to get started I might not bother.
12:54:38 <tempname11_> I'm not sure how nix works exactly, but would it let me cache locally all the packages I'm using for a particular build? i.e. I cache ghc-7.8, and in 2017 can still use it, because it's cached?
12:54:49 <tulcod> latk: if it's just some DOM stuff, the try-reflex code might get you most of the way there. also there are some sample packages using it already.
12:55:12 <gfixler> tempname11_: nix keeps all things in a global store, and all uses thereof share single copies
12:55:31 <gfixler> tempname11_: it's all based on hashes, just like git
12:55:34 <latk> tulcod: Very simple dom stuff, but I probably need some kind of client side router. Can't find one for reflex after a quick look.
12:55:45 <tulcod> router?
12:56:01 <latk> tulcod: something wrapping the history api in the browser
12:56:05 <latk> so you can fake having routes
12:56:14 <tulcod> latk: ah. well you can always interface with JS "natively"
12:56:29 <tulcod> latk: (no idea how tough that is)
12:56:37 <latk> tulcod: I expect very tough :p
12:58:10 <tulcod> latk: there's #ghcjs btw
12:58:27 <latk> tulcod: Yeah I just joined it, thought I would ask here first :)
13:00:31 <tempname11_> thanks everyone, you've been very helpful. I think I will research nix more. If anyone has advice on how to approach it best, I'd appreciate that. Also I wonder if there's a nix-themed IRC room somewhere. #nix here is empty.
13:00:59 <ion> @google nix irc channel
13:01:00 <lambdabot> https://nixos.org/wiki/IRC_channel
13:04:05 <Zer000> Hello fine people. I am attempting a first project in haskell and I ran into a problem, if someone could give me advice on how to get this to compile http://lpaste.net/132355 I would be very thankful. The module is not finished and the problem is in toBEncode KPacket at the end there.
13:05:21 <ion> Zer000: The error message would help.
13:05:23 <orion> Is it possible to pattern match on a specific Left Integer? i.e. myFunc (Left -1234) = ...
13:05:38 <ion> orion: Left (-1234)
13:06:08 <ion> Left -1234 means (Left) - (1234)
13:06:23 <Zer000> ah yes here is the error http://lpaste.net/132356
13:06:31 <gfixler> >let (Left x) = Left (-1234) in x
13:06:44 <Zer000> basically I know that toBEncode Message will always return a BValue that is specifically BDict, it would be undefined otherwise. But the function that doesn't compile doesn't know this
13:07:05 <orion> ion: !!! derp. :)
13:07:06 <orion> Thank you
13:08:39 <ion> Zer000: The error message seems to be for slightly different code than what was pasted.
13:10:00 <Zer000> ion, I had two irrelevant lines at the bottom, here is the error with them commented out: http://dpaste.com/3Z51ANG
13:11:08 <ion> Zer000: You seem to be able to generate a BDictMap using e.g. Data.BEncode.BDict.empty or Data.BEncode.BDict.singleton key bvalue
13:12:53 <ion> Zer000: Oh, i see. If you want the ‚Äút‚Äù and the ‚Äùm‚Äù values side by side, you‚Äôll need two Cons cells.
13:13:23 <ion> Zer000: Something like Cons _ (BString t) (Cons _ (toBEncode m) Nil)
13:13:32 <Zer000> ion, yes I guess there is more than one way to construct it. But the problem is that toBEncode (m :: Message) will be a BValue and not a BDictMap BValue like that constructor wants.
13:14:17 <Zer000> ion, hmm I don't think I understand how that underscore would work in that last line
13:14:27 <ion> Zer000: That just signified something you need to fill in.
13:14:29 * hackagebot second-transfer 0.4.0.0 - Second Transfer HTTP/2 web server  http://hackage.haskell.org/package/second-transfer-0.4.0.0 (dsign)
13:15:48 <Zer000> ion, ah ok. but I don't need a key there with the (toBEncode m) as the value. The (toBEncode m) part needs to be at the top level, do you see?
13:16:47 <ion> Zer000: I don‚Äôt see a way to put anything into a BDictMap without a key.
13:16:51 <zyla> Zer000: there's no way for the compiler to know that the BValue returned from toBEncode Message is specifically a BDict
13:17:03 <Zer000> I think what needs to happen is rather than making Message an instance of BEncode I need a function (Message -> BDictMap BValue)
13:17:16 <Zer000> is that the only solution here?
13:18:11 <ion> Ah, BValue can hold a BDictMap. You‚Äôll need to get it out of it and handle the other possible cases somehow in case of invalid input.
13:18:48 <Zer000> ion, given what zyla said is that even possible?
13:18:56 <ion> Or writing a messageToBDictMap and using it instead of toBEncode.
13:19:05 <zyla> Zer000: You can also pattern match on the BValue, but it will be less typesafe than an auxilliary function returning BDictMap BValue.
13:19:08 <refefer> ran some benchmarks on reading in a large stdin input: is text really 4-5x slower than bytestring?
13:19:14 <refefer> or am I doing something goofy?
13:19:18 <ion> Zer000: He and i said basically the same thing.
13:19:42 <tulcod> Zer000: (don't let these initial confusions about types and stuff get you down. haskell gets much, MUCH clearer after a while)
13:19:58 <ion> refefer: FWIW, Text needs to deal with encoding, ByteString is just a dumb array of bytes.
13:20:08 <kadoban> refefer: Sounds within the realm of possibility.
13:21:00 <Zer000> zyla, I think I will solve this by writing the function you mentioned. But for learning purposes how would I pattern match this?
13:21:24 <refefer> ion, kadoban: all fair.  just making sure that the skew is in the realm of reasonable
13:21:40 <ion> f (BInteger _) = something; ...; f (BDict d) = d
13:22:27 <Zer000> Ok then thanks guys
13:22:40 <ion> But not generating a BValue in the first place when all you only want a BDict seems better to me.
13:22:50 <zyla> Zer000: or inline: case toBEncode m of BDict dict -> {- dict here is of type BDictMap BValue -}
13:22:56 <ion> Thus: messageToBDictMap
13:23:43 <zyla> but you would have to make it non-total (the compiler won't check if it's really always a BDict), so I don't recommend it
13:24:13 <joeyh> wow, not only does ghc 7.10 warn about every line using tab for indentation, but cabal configure spews those warnings even when -Wall is not enabled in the cabal file
13:24:41 <ion> As for my Cons _ _ (Cons _ _ Nil) example, you‚Äôll probably want something like singleton _ _ `union` singleton _ _ instead because Cons requires you to provide the keys in sorted order.
13:25:20 <Zer000> ion, oh dang the order is very important here thank you
13:25:21 <ion> joeyh: fno-warn-something probably
13:26:25 <ion> -fno-warn-tabs
13:26:37 <joeyh> -fno-warn-tabs works for cabal build, but not for cabal configure when the setup file uses them
13:26:51 <joeyh> (or when it pulls in modules that use them)
13:27:03 <ion> Perhaps {-# OPTIONS_GHC -fno-warn-tabs #-} in Setup.hs then.
13:27:11 <joeyh> so, I have to reindent my whole code base, or live with thousands of build warnings :-( :-(
13:27:16 <joeyh> hmm, ok
13:27:24 <joeyh> I'd have to put it in two dozen files
13:29:30 * hackagebot hipbot 0.2.1 - A library for building HipChat Bots  http://hackage.haskell.org/package/hipbot-0.2.1 (purefn)
13:29:59 <bananagram> are there any regex libraries that have a replace function, like the second argument of s/x/y/ provides?
13:30:18 <bananagram> or do you have to write your own?
13:34:36 <ion> bananagram: regex-compat seems to have subRegex.
13:34:42 <enthropy> bananagram: https://hackage.haskell.org/package/pcre-heavy-0.2.2/docs/Text-Regex-PCRE-Heavy.html#v:sub is another
13:35:10 <bananagram> ooh, okay
13:35:42 <bananagram> awesome
13:38:47 <ocramz> hi all
13:42:28 <nowhereFast> new Haskell user here, I'm having trouble getting an hsqml sample going
13:42:56 <nowhereFast> Could not find module `Paths_hsqml_demo_samples'
13:43:07 <nowhereFast> can anybody point me in the right direction?
13:45:14 <kirill`> Why is there no instance NFData CFloat in deepseq <= 1.3? I wrote an instance myself (rnf !_ = (), copied from deepseq-1.4) in a project file and ghc complains it's an "orphan instance". What am I generally supposed to do?
13:45:50 <tar_> How do I use MaybeT from a pure function? runMaybeT returns m (Maybe a)
13:46:11 <c_wraith> tar_: why do you want to use MaybeT if you don't have an m in your type?
13:46:35 <tar_> c_wraith: I'm reusing code from elsewhere where it made more sense :\
13:46:37 <c_wraith> tar_:  the whole point of MaybeT is *combining* Maybe with an additional arbitrary m
13:46:49 <c_wraith> tar_: in that case, make m ~ Identity
13:47:16 <enthropy> nowhereFast: that file gets generated when you cabal configure (or maybe cabal build)
13:47:41 <tar_> c_wraith: by declaring the type of the expression where I call the function?
13:47:45 <enthropy> easiest is probably to 'cabal repl' and then :load theExampleFile
13:48:15 <c_wraith> tar_: you can just use inference by calling runIdentity on the result of runMaybeT
13:48:55 <nowhereFast> okay
13:49:02 <tar_> c_wraith: ah! Thank you! I wasn't looking in the right module for that.
13:49:05 <nowhereFast> I take it I'll have to do a cabal install on the repl first?
13:52:26 <nowhereFast> Prelude> :load Factorial1.hs
13:52:26 <nowhereFast> Factorial1.hs:7:8:
13:52:26 <nowhereFast>     Could not find module `Paths_hsqml_demo_samples'
13:52:26 <nowhereFast>     Use -v to see a list of the files searched for.
13:52:26 <nowhereFast> Failed, modules loaded: none.
13:58:58 <enthropy> nowhereFast: no I think cabal repl is supposed to generate enough.
13:59:16 <tulcod> nowhereFast: can you perhaps tell us what you did so far?
13:59:22 <tulcod> what kind of a directory are you working in, etc
13:59:26 <nowhereFast> it complains about not being configured when I try cabal repl
13:59:30 <kadoban> Next on the really-dumb-TH questions: So I'm trying this http://lpaste.net/335379938716680192 and it's /really/ slow and takes a lot of memory. Is that just because it's fundamentally an expensive operation, creating a list that big in TH, or am I doing it wrong?
13:59:53 <tulcod> nowhereFast: did you try a "cabal configure"?
14:01:29 <nowhereFast> so far... installed x64 qt package, installed the x64 Haskell platform on a win box, updated cabal, installed hsqml, it needed c2hs, installed this, went back and installed hsqml, -and have the factorial hs and qml files in a directory
14:01:32 <nowhereFast> ^pretty much it
14:01:40 <Cale> kadoban: You're creating a very large literal list expression, which then needs to be typechecked and go through the simplifier and everything else.
14:01:41 * nowhereFast does a cabal configure
14:02:07 <nowhereFast> cabal: No cabal file found.
14:02:07 <nowhereFast> Please create a package description file <pkgname>.cabal
14:02:28 <tulcod> nowhereFast: you should've cloned the entire demos repository instead of just the haskell files
14:02:34 <kadoban> Cale: So it's just fundamentally expensive then, right? There's no like, shortcut I'm missing to avoid that?
14:02:49 <Cale> Right, as far as I'm aware
14:03:30 <kadoban> Okay, thanks.
14:03:34 <nowhereFast> okay, there is a samples package, did an install on this too
14:03:40 <Cale> You might try taking that literal list and putting it in place in the source file and see if you get similar performance
14:03:49 <Cale> (i.e. not using TH)
14:03:51 <nowhereFast> http://hackage.haskell.org/package/hsqml-demo-samples
14:04:02 <Cale> If there's a big difference in performance, then you can call it a bug
14:04:13 <kadoban> Yeah, right, that'd be a decent test, let's see ‚Ä¶ (I have a feeling it'll go badly)
14:04:26 <nowhereFast> not quite sure how to access it though
14:04:53 <tulcod> nowhereFast: (for future reference: if you keep installing random stuff like this you'll inevitably run into "cabal hell" where you try to update one library and end up breaking everything. once you run into this problem, lookup "cabal sandbox" and use that.)
14:05:13 <nowhereFast> :-)
14:05:33 <tulcod> nowhereFast: just clone the samples repo into some directory, and do a cabal configure in the main dir, and then cabal repl whatever you want
14:05:50 <nowhereFast> planning on going through haskell a step at a time right after this, right now I'd just like to see it load a qml file up
14:05:59 <kadoban> Heh, yeah it indeed does not go well, so that makes sense for sure then.
14:05:59 <nowhereFast> okay
14:06:37 <tulcod> kadoban: makes sense that it doesn't make sense though. you're generating a haskell file with *literally* 50000 constants in it. it's *at least* a 50kB "file".
14:07:12 <kadoban> Yeah :)
14:08:26 <kirill`> How do I get cabal to reinstall all packages that depend on an old version of a package that I want to upgrade?
14:08:42 <nowhereFast> okay, configure is done and did a repl on it
14:09:08 <nowhereFast> :load <file>.hs says it has loaded up the file
14:09:21 <nowhereFast> but not seeing any qml form coming up
14:09:36 <int-e> kirill`: tricky. is forcefully unregistering the old version (with ghc-pkg unregister) an option? that way the packages will all be broken and cabal-install should rebuild them
14:09:41 <neuroserpens> > map (read :: Char -> Int) "1234"
14:09:42 <lambdabot>      Couldn't match type ‚ÄòChar‚Äô with ‚Äò[Char]‚Äô
14:09:42 <lambdabot>      Expected type: Char -> Int
14:09:42 <lambdabot>        Actual type: String -> Int
14:09:52 <neuroserpens> wtf
14:10:14 <int-e> kirill`: oh wait, does  cabal install --constraint 'package > old-version'  do the trick?
14:10:25 <Iceland_jack> neuroserpens: Review the type of read
14:10:26 <Iceland_jack> :t read
14:10:27 <lambdabot> Read a => String -> a
14:10:36 <neuroserpens> Iceland_jack: oooh thanks
14:10:36 <Iceland_jack> :t read :: String -> Int
14:10:37 <lambdabot> String -> Int
14:10:39 <kirill`> int-e: will try now
14:10:50 <neuroserpens> Iceland_jack: So it only reads strings...
14:10:54 <Iceland_jack> That's right
14:10:55 <Iceland_jack> > map digitToInt "1234"
14:10:56 <lambdabot>  [1,2,3,4]
14:11:03 <Iceland_jack> > map (\ch -> read [ch] :: Int) "1234"
14:11:04 <lambdabot>  [1,2,3,4]
14:11:14 <tulcod> nowhereFast: if you do "cabal build" then you can actually find a binary called hsqml-factorial1 somewhere in ./dist/build/
14:11:15 <neuroserpens> Iceland_jack: Nice lambda. Thanks a lot.
14:11:25 <Iceland_jack> neuroserpens: If (ch :: Char) then ([ch] :: String)
14:11:27 <exio4> Iceland_jack: that needs more monkey operator! :p
14:11:37 <Iceland_jack> Agree to disagree!
14:11:43 <int-e> :t digitToInt
14:11:44 <lambdabot> Char -> Int
14:11:47 <orion> Is it possible to pattern match on the tail of a list like so?: [_, x]
14:11:52 <int-e> @index digitToInt
14:11:52 <lambdabot> Data.Char
14:11:53 <Iceland_jack> orion: No
14:12:02 <orion> :<
14:12:03 <Javran> for ReadP, it is possible to make combinators "greedy" rather than giving all possible parses (like munch)
14:12:08 <kadoban> orion: That's a valid pattern match, but it means "the second item of the two item list"
14:12:19 <orion> Ah
14:12:40 <neuroserpens> orion: What are you trying to do?
14:12:44 <kadoban> Which is ‚Ä¶ almost certainly not that useful. You probably want (_ : xs),  : is the list constructor.
14:13:01 <kirill`> int-e: I'm not sure what happened, but it tells me the package ghc-7.8.3 is likely to be broken by the reinstalls. Huh.
14:13:21 <orion> neuroserpens: Goal: Create a function that, when passed an empty list does one thing, and given a non-empty list, returns the tail element.
14:13:23 <Iceland_jack> orion: You shouldn't do this but you can write
14:13:23 <Iceland_jack>     pattern Snoc xs x <- ((init &&& last) -> (xs, x)) where
14:13:23 <Iceland_jack>       Snoc xs x = xs ++ [x]
14:13:58 <nowhereFast> okay, it builds the executable
14:14:05 <nowhereFast> running it complains about a missing qml file though
14:14:16 <neuroserpens> orion:  f [] = one thing... f l = tail l ?
14:14:33 <tulcod> nowhereFast: run it in the qml/ directory...
14:14:50 <Darwin226> Hey, When I use KindSignatures, is it possible for the values my function produces to depend on which type is provided as the parameter?
14:14:53 <neuroserpens> orion: also... there's no "tail" element... do you mean the LAST element?
14:14:57 <tulcod> nowhereFast: so in qml/, run ../dist/build/stuff
14:15:25 <orion> neuroserpens: Yes, I just realized that I was using tail and last interchangeably, erroneously.
14:15:35 <orion> I want the last element, not the tail.
14:15:37 <neuroserpens> orion: Hehe :P
14:15:49 <orion> Thank you
14:16:23 <nowhereFast> tulcod, still complains about a missing qml file
14:16:24 <Cale> Darwin226: I have a hard time seeing how your question has much if anything to do with KindSignatures
14:16:30 <nowhereFast> probably something wrong with my build tools or build process
14:16:32 <neuroserpens> orion: No problem. I took some days for the head:tail vs init:last thing to sink in
14:16:47 <tulcod> nowhereFast: what is your current working directory when running the binary? (type pwd)
14:16:48 <kadoban> orion: The easiest way to do that is to reverse the list first. It's expensive, and won't work on an infinite list, but that's true of every way you can try to get the last element of a list.
14:17:42 <Iceland_jack> orion: If you need the last element consider a different data structure, Data.Sequence is a good candidate knowing nothing else
14:17:47 <nowhereFast> tulcod, this works on a win box?
14:17:54 <exio4> nowhereFast: if you want to do this normally, it'd be better to use the right data structure, Data.Sequence, probably
14:18:00 <tulcod> nowhereFast: actually, sorry, i think this should work in any working directory
14:18:13 <tulcod> exio4: neuroserpens* ?
14:18:15 <neuroserpens> kadoban: Iceland_jack: why reverse or import something when there is "last"? I don't understand
14:18:17 <Cale> Of course, an infinite list has no last element :)
14:18:28 <neuroserpens> tulcod: What?
14:18:38 <Darwin226> Cale: I'll describe what I'm doing since I'm sure there's a better way. So I have this type `data C a = C a (Maybe a)`. I want to put the information that the `Maybe a` is a `Just` into the type itself. The way I did it before was...
14:18:43 <nowhereFast> yup, thanks for the help, think im going to have to spend some time getting more familiar with haskell before looking into hsqml
14:18:44 <kadoban> neuroserpens: Well, presumably he's trying to implement it for practice or something ‚Ä¶ but yeah probably should have mentioned that instead.
14:18:56 <tulcod> neuroserpens: exio4 addressed nowhereFast but he meant you i think
14:19:23 <tulcod> nowhereFast: can you give the exact error?
14:19:29 <neuroserpens> tulcod: If he did then I didn't understand
14:19:46 <Cale> Darwin226: That is impossible.
14:19:47 <tulcod> well exio4 should clarify then, because it definitely wasn't for nowhereFast 
14:20:02 <Cale> Darwin226: Haskell is not dependently typed, so the best you can do is not to use Maybe
14:20:05 <exio4> it was for orion 
14:20:09 <Darwin226> Cale: an extra type `data IsFull = HasJust | HasNothing`, and then the function that constructs my type `C` looked like `f :: IsFull -> C a`. Now, I want to change that signature to something like `f :: C (f :: IsFull) a`
14:20:10 <neuroserpens> rofl
14:20:10 <tulcod> ah lol
14:20:46 <nowhereFast> well, its a win box, so exe file... running it spits out ../dist/build/x86_64-windows-ghc-7.8.3/hsqml-demo-samples-0.3.3.0/factorial1.qm
14:20:46 <nowhereFast> l: File not found
14:20:52 <Cale> Darwin226: Why use Maybe if you know that it's going to be Just?
14:21:04 <tulcod> Darwin226, Cale: aren't you looking for type classes?
14:21:09 <Darwin226> Cale: It's not always going to be a Just
14:21:22 <Cale> Darwin226: It is if that information is part of the  type
14:21:26 <Darwin226> tulcod: I liked the idea of kinds because they are closed.
14:22:00 <tulcod> nowhereFast: okay let me try
14:22:52 <Cale> Darwin226: Types are information about values which is available at compile time. They don't exist at runtime.
14:22:58 <Darwin226> Cale: The `read` function has the signature `String -> a` and it depends on that `a` to produce different results. I want the same thing, but I don't want the typeclass approach because in my case the `a` is restricted
14:23:08 <tulcod> Cale: type classes?
14:23:19 <Cale> tulcod: Even in the case of type classes.
14:23:36 <tulcod> a "function" might depend on the input type
14:23:41 <tulcod> except they're different functions
14:23:42 <Cale> Darwin226: So if you know that some value is going to be Just x statically, such that this information can be part of the type of the value, then you might as well not use Maybe
14:25:03 <Cale> Perhaps you want something like   data C a = C a (Maybe a) | C' a a  ?
14:25:08 <Darwin226> Cale: That's like saying "if you know you're going to be reading an Int, you might as well just call the readInt function"
14:25:32 <tulcod> Darwin226: also, if you're willing to make things horribly complicated, there are language extensions providing certain dependent types. see e.g. dependent-map
14:26:02 <Cale> Darwin226: That's actually true :)
14:26:15 <Darwin226> Pretty frustrating since I'm almost a 100% sure this can be easily done, but I'm just horrible at explaining things...
14:26:37 <tulcod> Darwin226: maybe give some sample code
14:26:45 <Darwin226> I'll do that. Hold on
14:26:52 <Cale> Of course, if it's just a matter of notation there are options for trying to use type classes...
14:27:20 <jmcarthur> i'm looking at conal's push-pull paper again, and i'm not seeing how the definition of join for Reactive doesn't violate the non-decreasing order constraint on Event occurrences
14:27:20 <Cale> The only reason to use read over readInt when you know you're reading an Int is that it's three fewer characters to type
14:28:31 <Cale> jmcarthur: I don't remember how that actually worked, but I do recall that this was a point of incredible pain when it came to the implementation of Reactive.
14:28:55 <jmcarthur> well, there's the whole leaky thing, too, but i don't think this is necessary related
14:30:12 <jmcarthur> there's the problem where you have to trim the past from the inner behaviors. i guess this is sort of related because i don't see where that happens in the implementation at all; that is, it looks like the resulting behavior simply has the wrong value altogether.
14:30:52 <jmcarthur> it looks like as you traverse the resulting Reactive you might encounter times in decreasing order
14:31:26 <u_> nshepperd: whelp finally made it
14:31:37 <u_> nshepperd: this round's problems seemed quite easy, didn't have to adapt either for the large case
14:31:46 <Cale> jmcarthur: I think it may be related -- holding on to the past sounds exactly like the source of a space leak.
14:32:03 <jmcarthur> Cale: yeah, but the bug fix i can envision wouldn't be able to eliminate the leak anyway
14:32:04 <Darwin226> Ok, got an example
14:32:06 <Darwin226> http://lpaste.net/132358
14:32:09 <jmcarthur> Cale: it would just fix the value
14:32:14 <u_> nshepperd: nearly considered trying to solve C by hand (240 seconds to solve 100 cases, fairly small intuitive problem that i couldn't think of an algorithm for)
14:32:16 <Cale> jmcarthur: hmm, okay
14:32:37 <u_> it could have worked, maybe, if i tried a few practice rounds and wasn't so tired
14:32:46 <u_> but not necessary anyway
14:32:50 <jmcarthur> Cale: fixing the leak basically requires changing the semantics
14:32:54 <Darwin226> So I want to be able to write readNumber because then I can later instantiate it with specialized functions (I intend to only expose those).
14:32:56 <Cale> Darwin226: Do you know about type classes?
14:33:20 <Cale> Darwin226: You can't inspect a type variable like you're asking for in that code. It's impossible. Types do not exist at runtime.
14:33:32 <Darwin226> Cale: I do, and again, they would be a solution. But in my case I don't want to parametrize with ANY 'a', only some specific 'a's
14:33:39 <Cale> However, you can make a type class which will select the appropriate function at compile time based on the type
14:33:40 <tulcod> nowhereFast: okay that took me a while, but you have to run "cabal instalL"
14:33:45 <tulcod> nowhereFast: then the binary should work
14:33:51 <Cale> That's what type classes are for.
14:33:53 <tulcod> nowhereFast: "cabal install" *
14:34:17 <Darwin226> Cale: Ok, basically, I want a closed typeclass. What's the closest equivalent?
14:34:22 <nowhereFast> tulcod, in the root directory of the project?
14:34:26 <tulcod> yes
14:34:27 <arkeet> a sum type
14:34:33 <Eduard_Munteanu> Darwin226, a GADT
14:35:13 <nowhereFast> and we're building...
14:35:23 <tulcod> Darwin226: GADTs would fit the bill. but is there a reason you want to close it off like this?
14:36:02 <Darwin226> tulcod: Yes. That type parameter is iterally only meant to represent that one flag. "Has something" or "has nothing"
14:36:31 <tulcod> Darwin226: so why not make it an Either a b?
14:36:39 <tulcod> Either Int Int
14:36:46 <Cale> Either a (Maybe a)?
14:36:50 <nowhereFast> thanks tulcod, that worked
14:36:59 <arkeet> what do you need GADTs for
14:37:02 <tulcod> Darwin226: or some synonym of Either that you introduced
14:37:19 <tulcod> nowhereFast: took us long enough but we got there :D\
14:37:21 <Cale> I don't really understand. Maybe you can show us the real code you're trying to write?
14:37:25 <nowhereFast> so I would always need a 'haskell project' set up? it would not work with a *.hs and its relative *.qml file?
14:37:32 <Eduard_Munteanu> You can make an indexed GADT and pattern-match on the constructors to discover the types involved, though.
14:37:37 <Darwin226> tulcod: That doesn't lift any of the information to the type level. I can't write function that reject the objects that are empty
14:37:49 <tulcod> nowhereFast: no, this specific code needs a cabal-style project. generally, you might get away without.
14:37:57 <nowhereFast> okay
14:38:03 <tulcod> nowhereFast: (it needs one because of the Paths_ stuff)
14:38:14 <Cale> Darwin226: If you want a function which won't accept Maybe A values that are Nothing, just have it take an A instead.
14:38:30 <Cale> Darwin226: Why is that not the right thing to do in your case?
14:38:58 <tulcod> Cale: hah. one of those moments where you have to step back and ask "wait, what do i *actually* want to achieve here?" :P
14:39:16 <nowhereFast> okay, then if ive got this right, getting to 'preview' the app doesnt happen unless I build, -unlike dynamic/app vm languages?
14:39:18 <tulcod> GADTs, type classes, no. I should just take A instead of Maybe A.
14:39:29 <Cale> Right?
14:39:32 <Darwin226> Cale: Hm... It might as well be, but I don't think it is. I'll think about it some more, maybe come up with a better example. Thanks
14:39:38 <tulcod> nowhereFast: no, it really is this specific project that is a bitch.
14:39:41 <kirill`> Is there a "thing" that takes a struct with its lenses, and generates command-line option parser for those fields?
14:39:49 <nowhereFast> hahaHA
14:39:54 <nowhereFast> not my night then
14:40:00 <pingu> kirill`: there's a generic optparse thing out there.
14:40:01 <tulcod> nowhereFast: i can write /tmp/test.hs with all kinds of funky code in it and run it with "runhaskell"
14:40:03 <Cale> Darwin226: What's the actual program that you're working on? Can we see the code for that?
14:40:09 <pingu> kirill`: if you look for generics and optparse you will find it.
14:40:26 <Cale> Darwin226: It's hard to know what to suggest without real code.
14:40:33 <tulcod> nowhereFast: but *generally speaking*, projects are very nice to work with, and you'll get lots of advantages
14:40:33 <nowhereFast> okay, -so I could in theory have my *.hs and *.qml files and get it going with a runhaskell?
14:40:59 <Darwin226> Cale: I don't mind sharing code but it would be a bit to hard to only rip the relevant parts out. I'll report back when I have something presentable
14:41:08 <tulcod> nowhereFast: yes. except this *specific* project makes use of getDataFileName, which requires a project file
14:41:09 <nowhereFast> yup, no doubt, just looking at repl stuff for getting familiar with a few basic concepts before going the project route
14:41:18 <Cale> Darwin226: I actually hate when people try to do that btw.
14:41:30 <pingu> kirill`: OK maybe I lied. I can't find it again.
14:41:40 <pingu> But it's out there, and it does precicely what you want without the lenses.
14:41:46 <nowhereFast> ahh... so initialDocument = fileDocument "factorial1.qml" would work then?
14:42:00 <pingu> kirill`: and it's not the one by tranma. she never finished that.
14:42:03 <Cale> Darwin226: I mean, when people don't give me something I can compile :)
14:42:10 <tulcod> nowhereFast: if factorial1.qml is in your current working directory (ie you can see it when you type "dir" in your terminal) then yes
14:42:16 <Darwin226> Cale: So you like going through hundreds of lines of code that has nothing to do with the actual problem? You're more patient than me...
14:42:19 <kirill`> pingu: I can only find https://github.com/tranma/optparse-generic but that doesn't look like it
14:42:25 <pingu> no, that's not.
14:42:25 <nowhereFast> :-)
14:42:29 <nowhereFast> great
14:42:35 <pingu> kirill`: it's the same idea but it does stuff.
14:42:45 <tulcod> nowhereFast: that's why i was confused myself
14:42:50 <Cale> Darwin226: Well, if I'm going to suggest something, I like to be able to check that it will actually work for myself.
14:42:51 <pingu> I think it may have been on reddit/r/haskell a month or two again. I can't find it, sorry.
14:43:01 <bitemyapp> Darwin226: it takes longer to reconstruct that context than to just dump the text.
14:43:08 <bitemyapp> Darwin226: programmers are good at ignoring information they don't need ;)
14:43:21 <nowhereFast> my bad, -I'll go a pastebin route next time
14:43:23 <bitemyapp> Darwin226: similar to Cale, I really want a compilable example that I can validate my suggestions with.
14:43:43 <nowhereFast> thanks again, now lets see what functional is about
14:43:51 <tulcod> nowhereFast: no not your fault, it's just a confusing project
14:43:52 <bitemyapp> Darwin226: I really don't want to ping-pong half-solutions back and forth with the only person that has all the context necessary when I have hundreds of megabits in bandwidth and terabytes of data storage.
14:43:58 <nowhereFast> I keep hearing monads, monads... it got me curious
14:44:19 <kirill`> I should figure out TH and write it myself I think.
14:44:22 <pingu> kirill`: getopt-generics
14:44:23 <tulcod> nowhereFast: before you get started on monads, just write some pure haskell first.... like computing prime numbers and shit
14:44:40 <Cale> I'll be back in a short while.
14:44:47 <kadoban> Computing prime numbers is quite easy to get very wrong, heh.
14:44:52 <pingu> kirill`: https://github.com/zalora/getopt-generics
14:45:00 <nowhereFast> while on the topic, is the functional course on edx any good?
14:45:58 <tulcod> nowhereFast: ah, the guy who's teaching it is actually my friend's supervisor
14:46:07 <tulcod> he's a fun guy to watch
14:46:13 <Eduard_Munteanu> kirill`, if you have a lot of settings you don't want to write cmdline parsers for, perhaps taking in JSON/YAML input is better
14:46:20 <nowhereFast> Erik :-)
14:46:36 <nowhereFast> yeh, caught some of his delivery on scala
14:46:59 <nowhereFast> definitely a lively delivery
14:46:59 <Eduard_Munteanu> kirill`, in which case deriving instances is straightforward
14:47:18 <tulcod> nowhereFast: it looks like it covers most of the essentials
14:48:47 <kirill`> Eduard_Munteanu: well, in my case it's a toy graphics program, so I just need something more interactive that an edit-compile-run loop
14:49:21 <nowhereFast> okay, at least theres you guys for when I need to express my confusion
14:49:59 <kirill`> pingu: That looks like it, but I can't tell at a glance how to use it.
14:50:26 <Eduard_Munteanu> kirill`, mm, that'll give you something like   ./program <<< '{ x: 1024, y: 768, foo: true }'
14:51:39 <kirill`> Eduard_Munteanu: that somehow looks better than ordinary cmd args
14:52:40 <kirill`> do you know what I need to use to parse that into a haskell value?
14:53:57 <Eduard_Munteanu> kirill`, aeson for JSON
14:54:48 <Eduard_Munteanu> kirill`, you just need to derive Generic and write   instance FromJSON Config    if Config is your configuration type
14:56:29 <kirill`> Eduard_Munteanu: looks cool, I'll give it a go
14:57:13 <Eduard_Munteanu> You could also call   genericParseJSON defaultOptions { fieldLabelModifier = fromJust (stripPrefix "config") } if you prefix all fields with "config" and you don't want to type that in the JSON.
14:57:42 <Eduard_Munteanu> Er, fromJust . stripPrefix "config"
14:59:17 <Darwin226> Turns out, I really didn't need that Maybe after all. Heh
15:00:14 <tulcod> the best part is that Darwin quits a second after saying that
15:00:20 <tulcod> like, he knows what he's done
15:00:39 <Eduard_Munteanu> Praise to the types!
15:13:41 <kirill`> Eduard_Munteanu: thanks, you saved me so much time
15:16:03 <Eduard_Munteanu> kirill`, one other possibility I haven't mentioned, though it's trivial, is to simply derive and use the Read instance
15:16:33 <kirill`> Eduard_Munteanu: that doesn't play well with having default values I think
15:16:44 <Eduard_Munteanu> Yeah.
15:19:04 <Fuuzetsu> anyone know of any bindings to a C# library?
15:20:32 <tulcod> Fuuzetsu: maybe google for reverse dependencies of hs-dotnet ?
15:22:32 <Fuuzetsu> well, hs-dotnet itself might do, I just wanted to know if someone has done it
15:24:59 <tulcod> oh dear. i found one reverse dependency of hs-dotnet. https://hackage.haskell.org/package/acme-everything
15:25:14 <indiagreen> what's the easiest way I can make a page with a textbox that would save everything typed into it in a file and survive page reloads? I've no experience with web development at all, so I'm a bit lost here
15:25:23 <tulcod> also, dat base dependencie :P
15:25:24 <indiagreen> (I'm using Spock, if it matters)
15:25:51 <Fuuzetsu> pft, I'm on base 128
15:26:10 <tulcod> indiagreen: cookies
15:26:28 <indiagreen> tulcod: no, a file on the server
15:26:29 <Fuuzetsu> heh, I see no acme-everything expression in nixpkgs, guess it's explicitly excluded :)
15:27:14 <Fuuzetsu>   let fixup = Map.delete "acme-everything"      -- TODO: https://github.com/NixOS/cabal2nix/issues/164
15:27:23 <tulcod> indiagreen: that would depend on the features spock provides. but you're going to need some kind of ajax.
15:31:21 <Welkin> indiagreen: you could have the page send the data in the textarea to the server to be saved every X seconds
15:31:41 <Welkin> that might hammer the server though
15:33:50 <kirill`> Is there a standard synonym for liftA2 (.) ?
15:33:54 <kirill`> :t liftA2 (.)
15:33:55 <lambdabot> Applicative f => f (b -> c) -> f (a -> b) -> f (a -> c)
15:34:19 <Fuuzetsu> :t (>=>)
15:34:20 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
15:34:22 <Fuuzetsu> hm
15:35:02 <Eduard_Munteanu> :t (<<<)
15:35:03 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
15:36:05 <Eduard_Munteanu> But no, that's not really it, AFAIK.
15:36:06 <Fuuzetsu> Eduard_Munteanu: doesn't work for Applicative‚Ä¶
15:37:06 <Fuuzetsu> @hoogle Applicative f => f (b -> c) -> f (a -> b) -> f (a -> c)
15:37:06 <lambdabot> Data.Generics.Schemes everywhereBut :: GenericQ Bool -> GenericT -> GenericT
15:37:11 <Fuuzetsu> th-thanks
15:37:20 <luzie> lol
15:37:31 <Iceland_jack> Fuuzetsu:
15:37:31 <Iceland_jack> :t liftA2 (.)
15:37:32 <lambdabot> Applicative f => f (b -> c) -> f (a -> b) -> f (a -> c)
15:38:02 <luzie> <kirill`> Is there a standard synonym for liftA2 (.) ?
15:38:03 <Fuuzetsu> yes, we're looking for existing identifier that does that
15:38:08 <Iceland_jack> oops!
15:38:09 <pavonia> @pl liftA2 (.)
15:38:09 <lambdabot> liftA2 (.)
15:38:21 <Iceland_jack> I'm doing this a lot today :) should stop lurksponding
15:38:27 <hpc> Fuuzetsu: that's like googling how to replace antifreeze and ending up with the wiktionary entry for zuchini
15:39:01 <Fuuzetsu> yeah, if Hoogle fails I usually fall back to #haskell search engine
15:39:33 <Eduard_Munteanu> I would suggest naming it (<.>).
15:39:51 <Fuuzetsu> that's already in base
15:39:54 <Fuuzetsu> or at least in one of core libs
15:40:01 <Fuuzetsu> > "foo" <*> "txt"
15:40:02 <lambdabot>      Couldn't match type ‚ÄòChar‚Äô with ‚ÄòChar -> b‚Äô
15:40:02 <lambdabot>      Expected type: [Char -> b]
15:40:02 <lambdabot>        Actual type: [Char]
15:40:03 <Eduard_Munteanu> Oh, right, for filenames.
15:40:03 <Fuuzetsu> > "foo" <.> "txt"
15:40:05 <lambdabot>      Couldn't match expected type ‚ÄòIndexed i0 s0 t0 -> r‚Äô
15:40:05 <lambdabot>                  with actual type ‚Äò[Char]‚Äô
15:40:05 <lambdabot>      In the first argument of ‚Äò(<.>)‚Äô, namely ‚Äò"foo"‚Äô
15:40:10 <Fuuzetsu> oh, thanks lens‚Ä¶
15:40:12 <luzie> :t liftA2 fmap
15:40:15 <lambdabot> (Functor f1, Applicative f) => f (a -> b) -> f (f1 a) -> f (f1 b)
15:40:47 <Fuuzetsu> :t liftA2 fmap (pure id)
15:40:48 <lambdabot> (Functor f1, Applicative f) => f (f1 b) -> f (f1 b)
15:41:00 <Fuuzetsu> :t liftA2 fmap (pure show)
15:41:01 <lambdabot> (Functor f1, Show a, Applicative f) => f (f1 a) -> f (f1 String)
15:45:27 <ocramz> what's the purpose of having functions within applicatives? what's an example use?
15:46:26 <Fuuzetsu> you never wrote
15:46:27 <ocramz> as in, liftA2 (.) lifts the composite function within a functor
15:46:35 <Fuuzetsu> :t (,) <$> 1
15:46:36 <lambdabot> (Functor f, Num (f a)) => f (b -> (a, b))
15:46:40 <Fuuzetsu> or something like
15:46:43 <Fuuzetsu> :t (:) <$> 1
15:46:44 <lambdabot> (Functor f, Num (f a)) => f ([a] -> [a])
15:46:46 <kirill`> ocramz: This is what I have
15:46:47 <kirill`> parseJSON (Object v) = (GLAbs.defaultValue &) <$> foldl1 (liftA2 (.))
15:46:47 <kirill`>     [ set opt'samplingTolerance <$> v .: "samplingTolerance"
15:46:47 <kirill`>     , set opt'benchmark <$> v .: "benchmark"
15:46:50 <kirill`>     ]
15:47:09 <Eduard_Munteanu> > (+) <$> fst <*> snd $ (1,2)
15:47:10 <lambdabot>  3
15:47:43 <Iceland_jack> It's also useful for
15:47:43 <Iceland_jack>     \i -> k i . f i
15:47:59 <Fuuzetsu> isn't there something in arrow that does that
15:48:08 <Fuuzetsu> @pl g i = k i . f i
15:48:08 <lambdabot> g = liftM2 (.) k f
15:48:12 <Fuuzetsu> heh
15:48:14 <Iceland_jack> > liftA2 (.) take drop 2 "hello"
15:48:15 <kirill`> The Applicative instance there is a json parser, so Parser (Options -> Options) is a parser that returns a setter that modifies a field to whatever is in the json object
15:48:15 <lambdabot>  "ll"
15:48:30 <kirill`> I then need to compose the setters, hence liftA2 (.)
15:48:40 <Iceland_jack> > let (<.>) = liftA2 (.) in (take <.> drop) 2 "hello"
15:48:42 <lambdabot>  "ll"
15:48:51 <Iceland_jack> Not so bad
15:49:24 <Fuuzetsu> I don't like it, I'm not conditioned to read <.> in that order
15:50:06 <tulcod> guys this shit is nuts. please add an apology comment if you're gonna do this in live code.
15:50:38 <Fuuzetsu> just read the type
15:52:16 <Eduard_Munteanu> :t liftA2 uncurry
15:52:17 <lambdabot> Applicative f => f (a -> b -> c) -> f (a, b) -> f c
15:53:27 <Eduard_Munteanu> (totally random)
15:55:44 <Guest29269> preflex: list
15:56:45 <lpaste> Nils revised ‚ÄúBrainfuck in haskell‚Äù: ‚ÄúBrainfuck in haskell‚Äù at http://lpaste.net/132309
15:57:14 <Guest29269> > map (*2) [4..8]
15:57:15 <lambdabot>  [8,10,12,14,16]
16:02:31 <Guest29269> @unmtl ExceptionalT String (StateT Int Identity) Œ±
16:02:31 <lambdabot> Plugin `unmtl' failed with: Parse error: ;
16:03:42 <Guest29269> @unmtl ExceptionalT String StateT Int Identity Œ±
16:03:42 <lambdabot> Plugin `unmtl' failed with: Parse error: ;
16:03:46 <Fuuzetsu> @unmtl ExceptionalT String (StateT Int Identity) a
16:03:46 <lambdabot> ExceptionalT String (StateT Int Identity) a
16:04:47 <Fuuzetsu> ExceptionalT is not in mtl anyway
16:05:17 <luzie> what does unmtl do?
16:05:27 <Fuuzetsu> unroll the stack
16:05:48 <ronh-> what's the minimum extensions required to write a Show-like class that calls show for everything but a String (where show will be id). I got it working with TypeSynonymInstances and FlexibleInstances
16:05:54 <Fuuzetsu> @unmtl ErrorT IOException IO Int
16:05:54 <lambdabot> IO (Either IOException Int)
16:06:21 <Eduard_Munteanu> @unmtl ReaderT r IO a
16:06:21 <lambdabot> r -> IO a
16:06:21 <ronh-> I did this a while ago and I think you can get away with just one extension?
16:07:05 <Bor0> what is a good name to describe a function like f [1,2,3] = [[1], [1,2], [1,2,3]]? and is there something like this in Prelude?
16:07:14 <Eduard_Munteanu> ronh-, String is [Char], so you might as well write [Char] and do without TypeSynonymInstances.
16:07:16 <Bor0> I have this function defined as combinations but this name seems to be misleading :)
16:07:18 <ion> > inits [1,2,3]
16:07:19 <lambdabot>  [[],[1],[1,2],[1,2,3]]
16:07:21 <Fuuzetsu> :t groupBy
16:07:22 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
16:07:23 <ronh-> > tails [1,2,3]
16:07:24 <lambdabot>  [[1,2,3],[2,3],[3],[]]
16:07:29 <ronh-> Eduard_Munteanu ah ok
16:07:34 <Bor0> ah, inits it is!
16:07:44 <Bor0> thanks!
16:07:53 <Guest29269> Thanks Fuuzetsu
16:08:49 <arkeet> > (tail . inits) [1,2,3]
16:08:50 <lambdabot>  [[1],[1,2],[1,2,3]]
16:09:05 <arkeet> > scanr (:) [] [1,2,3]
16:09:06 <lambdabot>  [[1,2,3],[2,3],[3],[]]
16:09:08 <arkeet> oh.
16:09:55 <Fuuzetsu> > inits []
16:09:57 <Eduard_Munteanu> ronh-, though you won't be able to write a catch-all instance without adding OverlappingInstances
16:09:57 <lambdabot>  [[]]
16:10:22 <Bor0> > tail [[]]
16:10:23 <lambdabot>  []
16:14:38 * hackagebot orgmode-parse 0.1.1.0 - A collection of Attoparsec combinators for parsing org-mode  flavored documents.  http://hackage.haskell.org/package/orgmode-parse-0.1.1.0 (ParnellSpringmeyer)
16:17:21 <ronh-> Eduard_Munteanu I needed FlexibleInstances, UndecidableInstances and OverlappingInstances, regardless if I used String or [Char]. hmm
16:17:34 <Eduard_Munteanu> ronh-, yes, sure
16:18:20 <Eduard_Munteanu> I meant FlexibleInstances isn't enough, regardless of TypeSynonymInstances.
16:18:29 <ronh-> I see
16:21:19 <Guest29269> \list #haskell
16:22:29 <Big_G> Anyone on here have a Haskell project they're looking for help with?
16:24:12 <neuroserpens> Big_G: I think people are going to recommend you to browse github. You can always have some fun at codechef or hackerrank though. That's what I do.
16:24:53 <Big_G> neuroserpens, I've browsed github but most of what I see are the really common ones like lens or the ones that are in Haskell for Haskell
16:25:25 <neuroserpens> I see. Sorry I can't help any further than that.
16:26:06 <Big_G> neuroserpens, No worries. Just trying to learn Haskell with more than a trivial project
16:27:07 <P4Titan> Hello all, could someone help with a flexible instance issue I have: I am tring to do this instance Monad m => Stream ParserSource m Char where where ParserSource is a newtype on String, it gives a flexible instance error although I cannot see it.
16:27:11 <neuroserpens> Big_G: I like codechef. You can access other people's solutions to problems before you submit yours. I think it is an interesting way to study haskell. Trying to find the best solution for a given problem being able to use other people's code as a reference..
16:27:38 <Cale> P4Titan: Is it suggesting that you turn on FlexibleInstances?
16:27:42 <neuroserpens> Big_G: Last time I was there I learnt about compiler transformations :)
16:27:45 <Cale> P4Titan: If so, then just do that.
16:28:21 <P4Titan> I want to understand what I am doing (wrong) to cause this error
16:28:50 <Cale> P4Titan: In Haskell 98/2010, you are not allowed to declare instances which are not of the form  C (T a_1 ... a_n) where C is a class, T is a type constructor, and a_1, ..., a_n are distinct type variables.
16:29:26 <P4Titan> What does that mean?
16:29:58 <Cale> It means you're not allowed to choose specific types for the parameters of the type constructor you're writing the instance for.
16:30:57 <Cale> Here, you already need MultiParameterTypeClasses, which despite being very popular is much more restricting than FlexibleInstances, so you should probably just turn on that extension.
16:31:04 <jle`> it's not something you're doing wrong, per se, it can be considered something that the designers of haskell hadn't thought of when they were designing the language, but is actually useful.  so "it's not you, it's them"
16:31:35 <Cale> Well, they did think of it, it's just that they were being very conservative about the Report specification. GHC supported FlexibleInstances from day 1.
16:31:51 <P4Titan> But I can instanciate my own class: class ParsableState s d where ... with instance ParsableState ParserSource ParserDet where and I don't get the flexibleinstances
16:32:03 <P4Titan> And I dont have type variables
16:32:08 <jle`> ah i see :)
16:32:13 <Cale> (In fact, for many years, it wasn't even an extension, because nobody had really thought about the fact that it didn't concur with the Report)
16:32:39 <jle`> perhaps then in that period, it could be considered a shortcoming of the Report drafting?
16:34:25 <Bor0> could anyone help me to solve this using algebras in haskell: Write a program that outputs all possibilities to put + or - or nothing between the numbers 1, 2, ..., 9 (in this order) such that the result is always 100. For example: 1 + 2 + 34 ñ 5 + 67 ñ 8 + 9 = 100.
16:34:41 <Bor0> this is not a homework, it's a problem from a blog https://blog.svpino.com/2015/05/07/five-programming-problems-every-software-engineer-should-be-able-to-solve-in-less-than-1-hour which I already solved in Haskell but without algebras
16:34:42 <arkeet> "using algebras"
16:34:47 <arkeet> what does that mean
16:35:01 <Bor0> I mean the way like data Expr = Add Expr Expr | Sub Expr Expr | Concat ...
16:35:13 <Bor0> I have written a post about it on my blog, but not sure if you want to take the time and read my failed attempt :)
16:35:24 <Cale> jle`: Possibly... they wanted to make the Report consist of all the least controversial versions of everything.
16:35:59 <Cale> jle`: For the 2010 one, maybe it could have been fixed, but Haskell 2010 was kind of ridiculous
16:36:29 <Cale> Very little changed, and half the things which were introduced were questionable imo :P
16:37:05 <Bor0> anyway, here's the post: http://haskellmath.blogspot.com/2015/05/svpion-fifth-problem.html
16:41:24 <Bor0> something tells me that the "algebraic" solution will be more elegant than my current solution but I don't know how that's doable for this current task
16:41:46 <jle`> in what way is 1 + 2 + 34   5 + 67   8 + 9 = 100 ?
16:43:00 <ion> That's not what he said
16:43:11 <Bor0> oh, wait, something's wrong with the code. it used to work, let me check it
16:43:57 <ion> Oh, on the web page? He wrote that but with minuses on IRC.
16:46:16 <jle`> oh, my client must not have given me the minus signs
16:47:33 <Bor0> blogspot in general is bad, I should change it. it used to work locally but probably due to copy-paste some special char is missed or something
16:48:24 <pipponz> @unmtl ExceptT String (StateT Int Identity Œ±)
16:48:24 <lambdabot> Plugin `unmtl' failed with: Parse error: )
16:49:12 <jle`> it's a kind error, but ... they left
16:53:02 <orion> This is an interesting problem: So, I have an expression that is lazily evaluated to a Text, however during the course of that evaluation it might throw an error. I correctly handle the error, but when I send that expression in to the AMQP library, it does its own error handling, and when my Text error is triggered, it actually triggers the AMQP library error handler.
16:56:31 <Cale> orion: Especially interesting as catching exceptions thrown from evaluation of expressions is normally fiddly to do at all.
16:56:49 <Cale> orion: Generally, if you intend to handle an error, you shouldn't use 'error'
16:59:37 <orion> Cale: When I say "handle" I mean, "take whatever String was passed along with the error, wrap it in JSON, and immediately send it out of the socket"
17:02:28 <Bor0> jle`, post updated, a little error in the displaying function (calculated)
17:03:37 <Bor0> so, do you have any hints to improve the current code and the current way it's solved? and also, any alternative ways of solving it? I would really like to see an "algebraic" approach to this
17:11:24 <marchelzo_> Why is "do { a <- readMVar b; putMVar b (f a); }" different than "modifyMVar_ b f"?
17:11:39 <marchelzo_> or maybe I mean takeMVar
17:11:51 <joneshf-laptop> wait, @unmtl is a thing?
17:12:18 <joneshf-laptop> well I'll be
17:12:43 <ReinH> marchelzo_: have you looked at the source?
17:13:05 <ReinH> It's pretty obvious how it's different if you look at the source
17:13:19 <marchelzo_> @src modifyMVar_
17:13:19 <lambdabot> modifyMVar_ m io = block $ do
17:13:19 <lambdabot>     a  <- takeMVar m
17:13:19 <lambdabot>     a' <- Exception.catch (unblock (io a)) (\e -> do putMVar m a; throw e)
17:13:19 <lambdabot>     putMVar m a'
17:14:16 <jle`> joneshf-laptop: yes it's a very useful thing :)
17:14:39 <marchelzo_> ReinH, aside from the catch, they should be equivalent (using takeMVar, that is)?
17:15:34 <marchelzo_> @type unblock
17:15:35 <lambdabot> Not in scope: ‚Äòunblock‚Äô
17:19:06 <ajf> uh
17:19:21 <ajf> type (Num a) => Vec2 a = (a, a)
17:19:24 <ajf> why can't I do this
17:19:52 <Bynbo7> you don't want to do that
17:19:53 <nvd> ajf, do you really need the Num a constraint?
17:20:15 <nvd> Or would that be better placed in the functions that take a Vec2?
17:20:24 <ajf> nvd: Oh, I suppose so.
17:20:28 <nvd> (with that you'll need to put it in the functions anyway)
17:21:09 <ajf> I guess I'll do that then, but it doesn't feel right to allow Vec2 String, for instance
17:21:49 <jle`> typically the solution is just to restrict the functions that work on it
17:22:17 <ajf> can you restrict algebraic types?
17:22:34 <jle`> sort of, but it's almost definitely not going to end up like you think it will
17:22:43 <jle`> if you take this idea to its logical conclusion
17:22:55 <jle`> and actually try to do things with it
17:23:04 <jle`> the best solution really is just to restrict the functions that operate on them
17:23:08 <ajf> how so>
17:23:11 <ajf> ]?
17:23:13 <ajf> er
17:23:15 <ajf> *how so?
17:24:29 <jle`> i think there might also not be any practical difference between trying to do it this way and between having the constraints on all your functions anyways
17:24:44 <ajf> true
17:24:48 <jle`> for example if you ever try to pattern match on a `Vec2 a` (if it's a ADT), you'll need a Num a => constraint anyways
17:25:08 <jle`> the constraint will always need to be there anyways
17:25:20 <ajf> alright
17:25:51 <jle`> i think there are some other issues too, but i think the conclusion everyone comes to is just that it's an interesting idea but ends up being useless or pointless or confusing if you actually try
17:26:00 <ajf> OK.
17:26:12 <ajf> I suppose there's no particular need to restrict it either
17:26:42 <jle`> mhm.  if you want, you can just make restricted "smart constructors"
17:26:54 <jle`> mkVec2 :: Num a => a -> Vec2 a
17:27:51 <jle`> but the informtaion is lost whenever you have a `Vec2 a`...it can be any a
17:28:14 <jle`> having constraints on the functions is nice because it tells users/you what constraints are going on, instead of having them be implicit/magic
17:29:43 <ajf> right
17:29:45 <Iceland_jack> ajf: Play around with implementing a Num or Functor instance with and without
17:30:05 <ajf> with and without what?
17:30:18 <Iceland_jack> A Num constraint
17:30:30 <ajf> what, on the instance?
17:31:25 <Iceland_jack> You can define
17:31:25 <Iceland_jack>     data          Vec2 a = V2 a a
17:31:25 <Iceland_jack>     data Num a => Vec2 a = V2 a a
17:31:25 <Iceland_jack> and
17:31:28 <Iceland_jack>     data Vec2 a where V2 :: Num a => a -> a -> Vec2 a 
17:31:40 <Iceland_jack> Just to get a feel for the differences
17:34:40 * hackagebot numtype-dk 0.5 - Type-level integers, using TypeNats, Data  Kinds, and Closed Type Families.  http://hackage.haskell.org/package/numtype-dk-0.5 (dmcclean)
17:53:38 <kaidelong> out of pure curiousity
17:54:08 <kaidelong> has anyone figured out an optomization that covers the (sort . nub) / (nub . sort) case?
17:54:21 <kaidelong> and makes nub O(n)
17:54:33 <kaidelong> (it commutes with sort)
17:55:08 <jmcarthur> do you mean a compiler optimization?
17:55:11 <kaidelong> I would be curious if there exists something that does that optomization without needing a rewrite rule
17:55:19 <kaidelong> yes
17:56:07 <Axman6> nub turns into `map head . group` then
17:56:12 <kaidelong> yes
17:56:13 <jmcarthur> seems like the compiler would need to understand what it means to be sorted and how to use that information to optimize nub
17:56:31 <kaidelong> that was what it looked like to me, yes, and I was pretty pessimistic about the chances
17:56:42 <kaidelong> but it might only really have to know some things about Ord and Eq
17:56:53 <Axman6> @check \xs -> nub (sort xs) == (map head . group . sort $ xs :: [Int])
17:56:54 <lambdabot>  +++ OK, passed 100 tests.
17:57:51 <kaidelong> mmm, actually, I think you'd still get stuck, because Ord and Eq don't obey all the laws we expect them to
17:58:12 <ReinH> marchelzo_: there is exception handling and async exception masking
17:58:41 <kaidelong> > nub (sort xs) [5,(0/0),5,(0/)]
17:58:42 <lambdabot>      Not in scope: ‚Äòxs‚Äô
17:58:43 <lambdabot>      Perhaps you meant one of these:
17:58:43 <lambdabot>        ‚Äòx‚Äô (imported from Debug.SimpleReflect),
17:58:50 <kaidelong> > nub (sort [5,(0/0),5,(0/0)])
17:58:51 <lambdabot>  [NaN,5.0,NaN]
17:59:17 <kaidelong> > map head . group (sort [5,(0/0),5,(0/0)])
17:59:19 <lambdabot>      Couldn't match expected type ‚Äòa -> [[b]]‚Äô
17:59:19 <lambdabot>                  with actual type ‚Äò[[Double]]‚Äô
17:59:19 <lambdabot>      Possible cause: ‚Äògroup‚Äô is applied to too many arguments
17:59:26 <kaidelong> > map head $ group (sort [5,(0/0),5,(0/0)])
17:59:27 <lambdabot>  [NaN,5.0,NaN,5.0]
17:59:59 <marchelzo_> ReinH, I see. What is exception masking?
18:00:23 <ReinH> marchelzo_: http://chimera.labs.oreilly.com/books/1230000000929/ch09.html#sec_mask
18:00:33 <zinfandel> Please point me into the right direction...
18:00:40 <zinfandel> I have alt1, alt2 :: A -> Maybe B
18:00:49 <marchelzo_> ReinH, awesome, thanks!
18:00:53 <ReinH> marchelzo_: np
18:00:59 <zinfandel> Now, what I want is: alt1 <|> alt2 :: A -> Maybe B
18:01:10 <zinfandel> But that obviously wouldn't work
18:01:16 <kaidelong> so yeah we actually can't even optimize this case because it changes the semantics
18:01:18 <Axman6> why not?
18:01:32 <zinfandel> How would I go about it, without doing (\inp -> alt1 inp <|> alt2 inp)
18:02:13 <ReinH> > liftA2 (<|>) (const Nothing) Just 1 -- zinfandel
18:02:14 <lambdabot>  Just 1
18:02:24 <zinfandel> Axman6: No instance for (Alternative ((->) Int)
18:02:28 <zinfandel> ReinH: Ohhh
18:02:32 <zinfandel> ReinH: Thanks
18:02:45 <zinfandel> ReinH: Now, it looks so obvious
18:03:56 <ReinH> :t let f = undefined :: a -> Maybe b; g = undefined :: a -> Maybe b in liftA2 (<|>) f g
18:03:57 <lambdabot> a1 -> Maybe a
18:05:44 <orion> When it comes to writing a web service, should errors or exceptions ever be used in the event that something the user entered is malformed?
18:06:41 <marchelzo_> orion, in my opinion: no
18:06:55 <marchelzo_> malformed user input is far from exceptional
18:08:17 <ephrion> dumb question for Persistent: if I have a record with a default value, what's the way to `insert` it without supplying that? Eg a `createdAt UTCTime default=now()`
18:12:55 <dpwright> I've been struggling with the "ghc no longer supports single-file style package databases" error since updating to GHC 7.10.  I've seen some github issue threads (like this one: https://github.com/haskell/cabal/issues/2301) but they haven't got me any closer to a solution
18:13:13 <dpwright> I'm on cabal-install 1.22.2.0
18:13:23 <dpwright> I've tried deleting my ~/.cabal directory and my sandbox
18:13:27 <dpwright> any other ideas?
18:13:55 <zinfandel> dpwright: Did you try to purge you package database?
18:14:04 <ajf> uh
18:14:09 <ajf> how do I convert an integer to a double
18:14:17 <zinfandel> dpwright: Usually in ~/.ghc
18:14:36 <dpwright> oh, one other thing, I have linear checked out locally and am using it in the sandbox via `cabal sandbox add-source` -- and it always seems to be failing on the linear package
18:14:42 <dpwright> zinfandel: I have not
18:15:01 <Fuuzetsu> :t fromInteger
18:15:02 <dpwright> is that just a case of deleting ~/.ghc?
18:15:02 <lambdabot> Num a => Integer -> a
18:15:09 <zinfandel> dpwright: Ahah
18:15:09 <ajf> hmm
18:15:20 <ajf> do I have to do (fromInteger x) / (fromInteger y)
18:15:23 <ajf> or is there a better way
18:16:02 <Fuuzetsu> @pl f x y = fromInteger x / fromInteger y
18:16:03 <lambdabot> f = (. fromInteger) . (/) . fromInteger
18:16:10 <Fuuzetsu> meh
18:16:11 <Fuuzetsu> just do that
18:16:21 <dpwright> deleting ~/.ghc, followed by `cabal update` and `cabal install --only-dependencies` didn't help
18:16:21 <Fuuzetsu> unless you're ok with integer division, then
18:16:22 <Fuuzetsu> :t div
18:16:23 <lambdabot> Integral a => a -> a -> a
18:16:30 <ajf> Nah, not what I want
18:16:46 <ajf> I'll alias fromInteger so it's shorter and clearer
18:16:49 <Clint> :t on
18:16:50 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
18:17:05 <Fuuzetsu> :t (\) `on` fromInteger
18:17:06 <lambdabot> parse error: naked lambda expression ''
18:17:13 <Fuuzetsu> :t (/) `on` fromInteger
18:17:14 <lambdabot> Fractional c => Integer -> Integer -> c
18:17:26 <Fuuzetsu> though that's uglier if you have x and y in scope
18:17:53 <ajf> oh, hmm, fromInteger is for the Integer type
18:17:55 <ajf> what about Int?
18:18:18 <Fuuzetsu> :t fromIntegral
18:18:19 <ajf> fromIntegral
18:18:19 <lambdabot> (Integral a, Num b) => a -> b
18:18:35 <ajf> dbl :: Int -> Double
18:18:38 <ajf> dbl = fromIntegral
18:18:40 <ajf> There we go.
18:19:00 <Fuuzetsu> I would keep the original type on that
18:19:09 <Fuuzetsu> you'll be able to use it in more places
18:19:40 <ajf> hmm
18:19:45 <zinfandel> Fuuzetsu: The name would be irrelevant then
18:19:58 <Fuuzetsu> don't have to keep the name
18:20:06 <Fuuzetsu> fi = fromIntegral
18:20:17 <zinfandel> Fuuzetsu: This would be harder to read
18:20:19 <Fuuzetsu> presonally I'd probably just use fromIntegral
18:20:24 <zinfandel> Same
18:20:26 <dpwright> why not just call it f and have done with it?
18:20:44 <Fuuzetsu> dpwright: I am no doubt already using f :)
18:20:50 <dpwright> heh
18:26:27 <orion> marchelzo_: In this example, the Yesod people use Control.Exception in their web service: http://www.yesodweb.com/book/json-web-service <-- are you saying that such a thing is to be frowned upon?
18:28:55 <marchelzo_> orion, no. If the official examples do it, then I'd say go for it. I'm not terribly familiar with Haskell's exceptions, so don't read very much into what I said.
18:31:18 <pavonia> orion: But they don't use exceptions here for user input, do they? It's for malformed JSON queries that shouldn't happen under normal conditions
18:33:34 <orion> pavonia: You don't consider the JSON to be user input?
18:34:17 <pavonia> Not in that example
18:35:17 <zinfandel> orion: User input would be the content of JSON. But in the case of this yesod example the exception is thrown only if the JSON is malformed (unparsable).
18:35:24 <Fuuzetsu> Well, if the user manually sends invalid JSON then that's pretty exceptional
18:36:43 <zinfandel> orion: I wouldn't use exception if one of the required fields is not present in the user's JSON, but if the JSON is completely unparsable then it's a better use-case for exception, as I don't want to pull that edge-case into my processing logic.
18:37:49 <tejing> is there a standard library function that will give the set-wise intersection of 2 distinct ascending lists of orderable elements?
18:37:55 <orion> zinfandel: I see. If you have a pure function that evaluates to Nothing, what's the typical way of detecting that and stopping further processing when you're in IO?
18:39:46 <pavonia> :t intersection
18:39:47 <lambdabot>     Not in scope: ‚Äòintersection‚Äô
18:39:47 <lambdabot>     Perhaps you meant one of these:
18:39:47 <lambdabot>       ‚ÄòIM.intersection‚Äô (imported from Data.IntMap),
18:39:50 <dmj`> tejing: intersect from Data.List only has an Eq constraint, why not use a Set?
18:39:50 <pavonia> :t intersect
18:39:51 <lambdabot> Eq a => [a] -> [a] -> [a]
18:40:10 <zinfandel> orion: You can go with `case { Nothing -> return "You request is bad" ; Just a -> ... }
18:40:37 <dmj`> orion: when badThingIsTrue $ error "oh no"
18:41:22 <tejing> dmj`: all I'm doing is generating 2 lists, intersecting, then summing... set seem kind of silly for that
18:41:38 <Fylwind> what exactly is the difference between ghc and ghc --make?
18:41:48 <zinfandel> dmj`: In that case you would have to unpack Maybe afterwards
18:42:00 <orion> zinfandel: If you have quite a bit of checks to perform, how do you prevent your code from getting ugly?
18:42:01 <tejing> I'd like to keep the low memory footprint of lazy lists
18:42:11 <orion> i.e., indented 20 levels
18:42:42 <pavonia> orion: Have a look at the MaybeT or EitherT transformers then
18:42:46 <dmj`> tejing: if order is not a constraint then sure, but from your question it seemed order mattered
18:43:01 <zinfandel> orion: Well, Maybe is a Monad, you can make use of that.
18:43:20 <tejing> well it can clearly be implemented in O(n+m) time if they're ordered. it'll be slower if not
18:43:26 <zinfandel> orion: But you might prefer Either to be able to throw correct error message
18:43:32 <zinfandel> s/correct/specific/
18:44:07 <jle`> tejing: i don't think Set is that high of a memory footprint compared to lists
18:44:25 <dmj`> > intersect [1,3,4] [2,5,7]
18:44:27 <lambdabot>  []
18:44:28 <jle`> it seems like a pretty straightofrward solution to ordered intersection
18:44:43 <jle`> you can almost think of it as like using a newtype wrapper and unwrapping it
18:44:47 <dmj`> > intersect [1,3,4] [1,2,4]
18:44:48 <lambdabot>  [1,4]
18:45:02 <jle`> > getSum . mconcat $ map Sum [1..10]
18:45:02 <dmj`> @src intersect
18:45:02 <lambdabot> intersect = intersectBy (==)
18:45:03 <lambdabot>  55
18:45:15 <pavonia> > intersect [1,2,3] [1..]
18:45:16 <lambdabot>  [1,2,3]
18:46:58 <tejing> won't a Set-based version have to hold the whole set in memory at some point? the list based version could work with constant memory footprint regardless of the size of the input lists
18:47:55 <athan> dmj`: Also keeps the order of the left, right?
18:47:56 <athan> > intersect [1,2,3] [3,2,1]
18:47:57 <lambdabot>  [1,2,3]
18:48:03 <Cale> tejing: Yeah, you're right.
18:48:42 <Cale> tejing: I don't think there's anything really standard.
18:48:43 <jle`> yeah, you're right.  i guess it depends on how big a thing you're talking about then
18:49:06 <jle`> is the technique used in nubOrd extendable to something like this?
18:49:21 <tejing> I'm looking through documentation and not seeing anything that does the job... guess I'll write it
18:49:43 * hackagebot tn 1.0.2.1 - A simple daily journal program  http://hackage.haskell.org/package/tn-1.0.2.1 (pharpend)
18:49:43 <Cale> jle`: The lists are already sorted, so you don't want to do anything superlinear
18:52:42 <jle`> oh, i see, they're already ordered
18:53:04 <jle`> yeah, there's nothing like that in the standard libraries
18:55:22 <orion> When creating an exception hierarchy, is using separate data types preferable to using one data type with many value constructors?
18:57:32 <zinfandel> orion: Well, it depends on the type of your exceptions
18:57:37 <dpwright> this does seem like it might be to do with sandbox sources.  if I build linear locally, in its own sandbox, it works fine, but if I use "cabal sandbox add-source" to add it to another sandbox and then build it with "cabal install --only-dependencies" it breaks with "ghc no longer supports single-file style package databases (dist/dist-sandbox-f11452b7/package.conf.inplace) use 'ghc-pkg init' to create the database with the correct for
18:57:38 <dpwright> mat."
18:58:24 <zinfandel> orion: E.g. You would want to keep all HttpExceptions in one datatype, but you don't want to mix up HttpExceptions with DatabaseExceptions
19:00:21 <Cale> It may be worth creating one type for each sort of HttpException as well
19:00:47 <dmj`> zinfandel: some databases are accessed over http though
19:00:50 <Cale> You can easily define a "union" by overriding the default instance of the Exception type class.
19:01:01 <Cale> You can also go the other way easily enough
19:01:55 <Cale> The question is whether or not people might be interested in catching one sort of exception without the others
19:02:18 <Cale> If that's the case, then you'd probably like to have separate types because it's convenient.
19:02:51 <Cale> One type for each set of exceptions you'd likely be interested in catching :)
19:06:28 <orion> zinfandel: I see.
19:23:09 <kadoban> If I made a Heap type like ‚Ä¶ data Heap k (k -> k -> Ordering) = ‚Ä¶  would that make sense, or is that going to be nonsense? The part I'm not sure about is how I'll be able to prevent stuff like merging heaps with different ordering functions, I guess?
19:23:40 <delta-nry> should I learn Haskell from Learn You a Haskell, Real World Haskell or some other resource?
19:24:26 <dmj`> delta-nry: https://github.com/bitemyapp/learnhaskell
19:25:08 <dmj`> delta-nry: anything brent yorgey is great (typeclassopedia, CIS-194)
19:25:19 <trizko> delta-nry: what dmj` said and also check this out http://bitemyapp.com/posts/2014-12-31-functional-education.html
19:25:51 <trizko> delta-nry: for the reasons on why to use that guide
19:26:57 <dmj`> delta-nry: Remember what Euclid states though, "There is no royal road to Haskell."
19:29:44 * hackagebot bitcoin-block 0.13.1 - Utility functions for manipulating bitcoin blocks  http://hackage.haskell.org/package/bitcoin-block-0.13.1 (solatis)
19:29:46 * hackagebot bitcoin-tx 0.13.1 - Utility functions for manipulating bitcoin transactions  http://hackage.haskell.org/package/bitcoin-tx-0.13.1 (solatis)
19:39:28 <P4Titan> Can someone explain flexible instances to me. I have a slight dilemma with an instance that I cannot see its flexibility. 
19:40:39 <Hijiri> it lets you put constraints on type variables and things
19:40:47 <Hijiri> I can't think of the other things it allows
19:41:24 <P4Titan> I should paste what I am talking about: instance Monad m => Stream ParserSource m Char where, Stream is from Text.Parsec and ParserSource is a newtype on String
19:41:35 <P4Titan> That errors saying it is a flexible instance
19:43:33 <pavonia> I think you need it because ParserSource and Char are not type variables
19:44:05 <Hijiri> Also you are restricting m to Monad
19:44:06 <P4Titan> Is this meaningful? class (Monad m) => Stream s m t | s -> t where
19:44:16 <P4Titan> That is the definition of Stream
19:44:43 <JoshieAS> holy shit
19:44:50 <Hijiri> it says the m variable in Stream has to be a monad, and ts have to be unique for each s
19:44:57 <JoshieAS> Brent Yorgey just took a position at a college in my hometown in Arkansas
19:44:59 <JoshieAS> small world
19:45:36 <P4Titan> Hijiri: can you explain the "ts have to be" part again?
19:45:42 <Fuuzetsu> JoshieAS: he's here
19:45:54 <Hijiri> let's say you have an instance Stream A B C
19:46:02 <P4Titan> ok
19:46:03 <Hijiri> You're not allowed to have another instance Stream A B D
19:46:30 <Hijiri> Because for each thing in the s position, you can only have instances with a unique t
19:46:31 <P4Titan> So it locks A to go to C, in my case ParserSource to Char and nothing else
19:46:36 <Hijiri> yes
19:46:56 <Hijiri> if you made another instance with ParserSource to something else, that would be wrong
19:47:00 <P4Titan> So where is the flexibility in my instance?
19:47:20 <Hijiri> I"m not sure, maybe multiparam typeclasses require flexible instances
19:47:26 <Hijiri> or functional dependencies require it
19:48:44 <P4Titan> I'll try something and get back to you
19:49:51 <P4Titan> Ok, so I am looking at some source code which instantiates Stream, it has "{-# LANGUAGE MultiParamTypeClasses, FunctionalDependencies, FlexibleContexts,
19:49:52 <P4Titan>              UndecidableInstances #-}" at the top of the file and this is the instance: instance (Monad m) => Stream [tok] m tok where
19:49:58 <pavonia> Functional dependencies wouldn't make much sense without it, I guess
19:50:16 <P4Titan> I copied the comment to the top of my file and still get the flexible instance error
19:51:00 <P4Titan> Here is the source: https://hackage.haskell.org/package/parsec-3.1.9/docs/src/Text-Parsec-Prim.html#Stream
19:51:10 <pavonia> You are using completely specialized types in your instance
19:51:18 <P4Titan> Which means?
19:51:37 <pavonia> That they don't have any type variables in it
19:52:05 <echo-area> Hijiri: What is | in class declaration called?
19:52:09 <Hijiri> isn't that only an issue when the non-type variables are parameters?
19:52:11 <P4Titan> So? They are not needed: The sample file has this for example: instance (Monad m) => Stream Text.Text m Char where
19:52:15 <Hijiri> echo-area: pipe? I'm not sure
19:52:29 <Hijiri> s/non-type variables/type non-variables
19:52:50 <echo-area> Hijiri: Okay, where am I supposed to find its definition in haskell 2010 spec?
19:52:54 <Hijiri> I don't know if there is a standard way to say | for functional dependencies
19:53:03 <Hijiri> echo-area: It's not in the haskell 2010 spec
19:53:08 <Hijiri> it's a ghc language extension
19:53:22 <echo-area> Hijiri: Ah okay.  Thanks
19:53:51 <Paul__> Is there a version of Data.ByteString.Lazy.Char8.lines that handles "\n", "\r" and "\r\n"?  Thank you
19:54:19 <pavonia> P4Titan: What is ParserSource?
19:54:26 <P4Titan> newtype on String
19:55:17 <Hijiri> that is the issue
19:55:20 <Hijiri> wait no
19:55:22 <Hijiri> it isn't, sorry
19:57:18 <pavonia> I don't understand why it isn't required in the Parsec file then
19:57:51 <P4Titan> I know, I could just enable flexible instanes but I want to learn why this errors
19:59:53 <pavonia> "The -XFlexibleInstances flag allows the head of the instance declaration to mention arbitrary nested types. For example, this becomes a legal instance declaration "
20:00:30 <pavonia> Are you sure it's because of this instance declaration your pasted?
20:00:32 <P4Titan> By my code does not have nested types
20:00:46 <P4Titan> 100% sure
20:14:47 <pavonia> P4Titan: Ahh! Parsec uses FlexibleInstances as a package option so it's not mentioned in that file as a language pragma
20:15:41 <Hatem> ##C, ##C++
20:15:54 <kaidelong> -XTupleSections seems to suffer from a serious missed opportunity
20:16:37 <kaidelong> one of the reasons to use tuples for function arguments is that they compose better, and TupleSections could let you use them to facilitate this but instead of returning something in the form tup -> tup, tuple sections are curried
20:16:49 <kaidelong> so you can't do f . (x,,y)
20:17:00 <kaidelong> if your section wants more than one argument
20:17:19 <kaidelong> I guess I should have written (x,,,,y)
20:18:25 <kaidelong> I guess it's more idiomatic to be able to write (,,w,) x y z rather than having to do (,,w,) (x,y,z)
20:19:45 * hackagebot bitcoin-api 0.11.1 - Provides access to the RPC API of Bitcoin Core  http://hackage.haskell.org/package/bitcoin-api-0.11.1 (solatis)
20:19:47 * hackagebot http-date 0.0.6.1 - HTTP Date parser/formatter  http://hackage.haskell.org/package/http-date-0.0.6.1 (KazuYamamoto)
20:23:34 <isomorphic> Hrmmm.. I've ended up with an STM (STM a) - what's the right way to flatten that back out to STM a
20:23:35 <isomorphic> ? 
20:26:01 <bob_twinkles> :t join
20:26:02 <lambdabot> Monad m => m (m a) -> m a
20:26:39 <bob_twinkles> isomorphic: ^
20:27:06 <bob_twinkles> (it's from Control.Monad)
20:44:04 <dibblego> @type \n -> maybe n . const
20:44:05 <lambdabot> b -> b -> Maybe a -> b
20:54:05 <deezn> jle` you around?
20:54:19 <jle`> yeah, sup? might not be able to reply immediately tho
20:54:37 <deezn> hmm ok..I wanted to plug you with questions. So I might leave it. 
20:55:44 <dmj`> jle`: bro
20:56:13 <jle`> sup
21:00:14 <kirill`> How do I define a non-orphan instance NFData CFloat if it's missing from my version of deepseq? GHC keeps complaining that the instance I defined in my own source is an orphan instance.
21:00:49 <zinfandel> kirill`: You can't
21:00:54 <kirill`> oh
21:00:55 <zinfandel> kirill`: by definition
21:01:27 <zinfandel> kirill`: Orphan instance is an instance which is defined in a different module than the datatype itself
21:01:52 <zinfandel> kirill`: What you can do is to supress the warning
21:02:08 <zinfandel> kirill`: Or wrap CFloat into newtype
21:02:30 <zinfandel> kirill`: But I would defenitely recommend to just use a newer version
21:03:44 <kirill`> zinfandel: Right, thanks.
21:09:49 <solatis> hmm in version 3.x, Data.List.Lens had a ~: operator to add elements to a list
21:10:00 <solatis> in version 4.x, it seems that this operator has disappeared
21:10:08 <solatis> anyone knows where i should look ?
21:10:31 <deezn> jle` : http://lpaste.net/3276541219093610496
21:10:41 <deezn> Question about these vectors again.. 
21:11:17 <deezn> jle` if you can of course...
21:11:23 <wolf_mozart> ?UTy;p[\p;[/'
21:11:23 <lambdabot> Unknown command, try @list
21:13:23 <ajf> is there something to set the first element of a tuple, preserving the second?
21:13:37 <Fylwind> can a type be Real but not Integral?  I think it would be nonsensical but the type class hierarchy does not require it
21:14:19 <ajf> Fylwind: um, wouldn't it be the other way round?
21:14:31 <Clint> ajf: first
21:14:42 <Fuuzetsu> Fylwind: uh, of course it can? Float for example‚Ä¶
21:15:19 <ajf> how do I import in GHCI again
21:15:20 <Fylwind> um, oops I said the opposite of what I meant
21:15:44 <Fuuzetsu> ajf: import Whatever.Module
21:16:00 <arkeet> :t toRational . toInteger
21:16:01 <lambdabot> Integral a => a -> Rational
21:16:21 <arkeet> :t fromInteger . toInteger
21:16:21 <Fylwind> never mind I think I confused myself
21:16:22 <lambdabot> (Integral a, Num c) => a -> c
21:16:26 <ajf> Fuuzetsu: thanks
21:16:38 <ajf> Clint: how do I use it?
21:16:42 <arkeet> :t first
21:16:43 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
21:16:47 <arkeet> uh.
21:16:54 <arkeet> (b -> c) -> (b,d) -> (c,d)
21:17:02 <ajf> ah
21:17:04 <Fylwind> what I meant was, if a type was Integral, then it should also define Real too, and that's already stated in the hierarchy, derp
21:17:07 <ajf> so I give it a function
21:17:09 <ajf> and a tuple
21:17:17 <arkeet> Fylwind: I agree that it should.
21:17:20 <ajf> and itfirst (+2) (1,2)
21:17:23 <ajf> (3,2)
21:17:25 <ajf> er
21:17:27 <ajf> first (+2) (1,2)
21:17:28 <arkeet> and yeah Real is a superclass of Integral
21:17:29 <ajf> (3,2)
21:17:30 <Clint> > first (+2) (1,2)
21:17:31 <ajf> yeah, I see, thanks!
21:17:32 <lambdabot>  (3,2)
21:17:40 <Clint> > first (const 5000) (1,2)
21:17:42 <lambdabot>  (5000,2)
21:17:42 <arkeet> > first chr (65,2)
21:17:43 <lambdabot>  ('A',2)
21:19:26 <ajf> Alright, that works out great!
21:19:34 <ajf> Means I can avoid unnecessary pattern matches
21:19:46 <ajf> `traceRayInner arr step@(stepX, stepY) deltaDist@(deltaDistX, deltaDistY) tile@(tileX, tileY) sideDist@(sideDistX, sideDistY)` is a *little* excessive
21:20:16 <kadoban> Is there some easy way to ‚Ä¶ do a foldr, but ‚Ä¶ I have a (a -> a -> a) and I want to have it merge kind of in a tree shape, not a line shape. It should merge pairs, then start again merging the new pairs, etc. etc. until there's one left. I'm sure I can code it up, but ‚Ä¶ seems like something that might exist somewhere?
21:21:42 <Fuuzetsu> kadoban: maybe something with scanr?
21:22:23 <Fuuzetsu> though idk, seems like fold should be what you want‚Ä¶
21:23:19 <kadoban> It's ‚Ä¶ kinda what I want, but I want the parens in a different place.   ((1 + 1) + (1 + 1)) + ((1 + 1) + (1 + 1)) kind of shape
21:24:28 <kadoban> Probably not that common of a desire, heh. I'll just code up something ad hoc.
21:24:41 <dmj`> any hakyll experts in here?
21:24:58 <Fuuzetsu> seems like you should build a binary tree then reduce it
21:24:59 <kadoban> dmj`: I dunno about expert, but I use it.
21:25:35 <Fuuzetsu> well, can skip the tree part, just reduce straight away but yeah, no pre-made function as I know of to do just this
21:26:00 <kadoban> No worries, thanks for suggesting. Was just hoping I was missing something obvious.
21:26:08 <dmj`> kadoban: trying to use getTags, but it requires Identifier as an argument, I need to pass the identifier from a post into this, then build a context with [String] (return type)
21:26:18 <dmj`> kadoban: how do I get an identifier from a post is my question
21:27:19 <kadoban> dmj`: A post is some kind of item, right? itemIdentifier :: Item a -> Identifier
21:27:25 <kadoban> s/item/Item/
21:28:02 <dmj`> kadoban: yea, but it's not exported :/
21:28:18 <dmj`> the field itemIdentifier isn't
21:28:30 <kadoban> dmj`: Is it really not? Pretty sure I've used it.
21:29:05 <dmj`> kadoban: I'm sorry you're right, I was thinking identifierPath
21:29:11 <dmj`> kadoban: thanks
21:29:22 <kadoban> Ah, cool. Yeah, np.
21:29:28 <dmj`> identifierPath is a field of Identifier
21:30:37 <kadoban> Yeah, I think I was hunting that down for a while last week, can't remember why, it was some related reason though, heh. Things needing an Identifier always seem to confuse my ability to find the right querying thing.
21:37:22 <dmj`> kadoban: basically I want to get tags as [String] for each individual post, not for the entire site. But getTags works in a Context, not the Compiler monad, not in a context, I need to pass it into a context
21:38:08 <ajf> Hmm
21:38:41 <ajf> is there a function to do (a, b) to (f a, f b)
21:38:59 <ajf> apply a function to both halves of a tuple and produce a new tuple, that is
21:39:04 <dmj`> :t (&&&)
21:39:05 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
21:39:10 <ajf> ah
21:39:23 <augur> anyone have good recommendations for books on designing functional algorithms?
21:39:37 <dmj`> purely functional data structures by Okasaki
21:39:47 <ajf> dmj`: how do I use &&& ?
21:40:08 <augur> dmj`: as a book on technique? i thought that was just like.. a book on some important algo, rather than a how-to-design-algos book
21:40:30 <dmj`> ajf: use a bifunctor instead
21:40:56 <dmj`> :t bimap
21:40:57 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
21:41:02 <ajf> aha
21:41:19 <ajf> That's exactly what I wanted, I wondered if there was some equivalent to `map` and such for tuples
21:41:24 <dmj`> > bimap (+1) (+2) (1,1)
21:41:26 <lambdabot>  (2,3)
21:41:27 <ajf> I just didn't know what it'd be called
21:41:36 <augur> ajf: hoogle is your friend
21:41:45 <ajf> Yeah
21:41:47 <augur> @hoogle (a -> b) -> (c -> d) -> (a,c) -> (b,c)
21:41:48 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
21:41:48 <dmj`> kadoban: sorry I didn't phrase that well, getTags is in the compiler monad, it isn't a context
21:41:59 <augur> ok maybe not quite your friend right now x3
21:42:29 <augur> oh, i typoed
21:42:32 <augur> @hoogle (a -> b) -> (c -> d) -> (a,c) -> (b,d)
21:42:33 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
21:42:39 <ajf> oh, but that requires two functions
21:42:52 <augur> still no good! damn you hoogle. i wonder if fpcomplete's version is better
21:42:55 <augur> ajf: use id for one of them
21:43:06 <augur> bimap f id  ,   bimap id g
21:43:10 <ajf> That's not quite what I need
21:43:13 <ajf> rather
21:43:24 <ajf> I have a tuple where both parts are the same type (Int)
21:43:34 <ajf> and want to apply some function to both parts
21:43:37 <augur> bimap f f
21:43:39 <dmj`> :t over
21:43:40 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
21:43:49 <dmj`> > over both (+1) $ (1,2)
21:43:50 <lambdabot>  (2,3)
21:43:56 <augur> you're awful
21:44:02 <ajf> hehe
21:44:39 <dmj`> > (+1) *** (+1) $ (1,2)
21:44:40 <lambdabot>  (2,3)
21:44:55 <dmj`> now the above can be used w/o additional dependencies (just base)
21:47:41 <kaidelong> @type foldr (***)
21:47:42 <lambdabot>     Occurs check: cannot construct the infinite type: b' ~ (b, b')
21:47:42 <lambdabot>     Expected type: a b c -> a (b, b') (c, c') -> a (b, b') (c, c')
21:47:42 <lambdabot>       Actual type: a b c -> a b' c' -> a (b, b') (c, c')
21:48:05 <kaidelong> I knew that would be a type error, but I wasn't expecting that one
21:48:48 <dmj`> kadoban: do you have examples of using getTags in hakyll?
21:49:36 <kadoban> dmj`: Hmm, I haven't really used tags. I think they might work pretty similar to some stuff I have, maybe? I'm not quite sure though.
21:49:48 * hackagebot stackage-types 1.0.1 - Shared data types between various Stackage packages  http://hackage.haskell.org/package/stackage-types-1.0.1 (MichaelSnoyman)
21:53:11 <kadoban> dmj`: Yeah, tags look fairly complicated, heh :-/ Sorry.
21:53:35 <dmj`> kadoban: yea, hakyll still doesn't make too much sense to me yet
21:53:55 <dmj`> kadoban: like, I've been copying pasting everywhere, have gotten pretty far though, it's pretty custom
21:54:41 <kadoban> It's kind of starting to make sense to me in general, at least the pieces I've randomly figured out so far, haha. My sites tend to be pretty basic though
21:55:19 <dmj`> kadoban: I think tags in general are a basic concept, I think I'll need to deep dive into the code
21:55:25 <kadoban> dmj`: Is there a specific like ‚Ä¶ type, or transformation or sometihn gyou're looking for?
21:56:49 <dmj`> kadoban: yea, so I'm building the index.html page by loading all the posts, each post contains tags, so I'd like each tag to be displayed in it's own html element.
21:56:56 <dmj`> kadoban: I'll lpaste
21:57:15 <dpwright> dmj`: this is how I do it: http://dpwright.com/posts/2015/03/04/generating-this-website-part-3-indexing/
21:57:39 <dpwright> which comes out looking like this: http://dpwright.com
21:57:44 <dpwright> is that similar to what you're looking for?
21:59:55 <dmj`> dpwright: yea, that's exactly what I'm looking for, do you use the getTags function?
22:00:11 <dmj`> dpwright: I was in kyoto 3 weeks ago. too bad :)
22:00:29 <Fuuzetsu> dpwright: your new year's post gives 404 :)
22:00:33 <dpwright> :-) let me know if you're in town again!
22:00:43 <dpwright> Fuuzetsu: Oh no!  Thanks for the heads-up, I'll check that out
22:00:52 <dpwright> I changed the URL scheme a while back so I've probably broken it
22:01:11 <Fuuzetsu> dpwright: yeah, seems like the URLs with Japanese in them are not happy
22:01:15 <dpwright> ...wait a minute, it worked when I clicked it: http://dpwright.com/posts/2015/01/01/„ÅÇ„Åë„Åæ„Åó„Å¶„Åä„ÇÅ„Åß„Å®„ÅÜ„Åî„Åñ„ÅÑ„Åæ„Åô/
22:01:32 <dpwright> :-/ which browser/os?
22:01:38 <Fuuzetsu> guess it's my browser
22:01:41 <Fuuzetsu> dwb on NixOS
22:01:58 <Fuuzetsu> it encodes to http://dpwright.com/posts/2015/01/01/%C3%A3%C2%81%C2%82%C3%A3%C2%81%C2%91%C3%A3%C2%81%C2%BE%C3%A3%C2%81%C2%97%C3%A3%C2%81%C2%A6%C3%A3%C2%81%C2%8A%C3%A3%C2%82%C2%81%C3%A3%C2%81%C2%A7%C3%A3%C2%81%C2%A8%C3%A3%C2%81%C2%86%C3%A3%C2%81%C2%94%C3%A3%C2%81%C2%96%C3%A3%C2%81%C2%84%C3%A3%C2%81%C2%BE%C3%A3%C2%81%C2%99/
22:02:04 <ajf> thanks for all the help
22:02:37 <dpwright> ah... can't say I've tested it on any of the "lightweight" browsers... I think it worked on surf when I tried it but maybe not
22:03:24 <dpwright> dmj`: No, I don't use getTags
22:03:25 <Fuuzetsu> dpwright: somewhat unrelated, do you work with Haskell in Japan?
22:04:04 <dpwright> I generate the tags using generateTags in Main here: http://dpwright.com/posts/2014/08/04/generating-this-website-part-1-introduction/ and then I pass them into each of the rules that need them, which includes "index"
22:04:42 <dmj`> Fuuzetsu / dpwright, sounds like you guys should be friends :) 
22:04:42 <dpwright> "index" is defined in part 3 (which I linked you first) and basically builds up a context for each post item based on the tags passed in
22:05:01 <dpwright> Fuuzetsu: actually, my day job is in C++ :-(
22:05:16 <dpwright> though I am working on a compiler in haskell for an in-house scripting language on the side
22:05:54 <dpwright> yes to the "in japan" bit though, I work at a company called Vitei in Kyoto
22:06:08 <dmj`> dpwright: I'm currently getting the tags for each post, but I can't iterate over them in the template like $for(tags)$ <a href="#">$tag$</a> $endfor$ 
22:06:31 <dpwright> ah, ok... the way I do that is a little different -- I have a template for each individual post
22:06:33 <dmj`> dpwright: since tags is string it doesn't make sense
22:06:43 <dpwright> oh I see
22:06:51 <Fuuzetsu> dpwright: ah, in some years I'll probably be moving there and wonder what the job market's like
22:06:58 <dmj`> dpwright: i the work/life better in kyoto than tokyo? Or can you not go home until your boss does :)
22:07:01 <dmj`> is*
22:07:17 <Fuuzetsu> we might want to move to -blah
22:07:20 <dpwright> Fuuzetsu: right now there's a lot of scala work going; not much haskell
22:07:29 <Fuuzetsu> ew
22:08:07 <dpwright> dmj`: in my case the guy who runs the company is actually English originally, so we're pretty relaxed.
22:08:47 <dmj`> dpwright: nice, that's awesome
22:09:47 <dpwright> dmj`: OK, just double-checked my template
22:09:56 <dpwright> so I don't use getTags, I use tagsField
22:10:11 <dpwright> https://hackage.haskell.org/package/hakyll-4.6.8.1/docs/Hakyll-Web-Tags.html
22:10:13 <dmj`> dpwright: yea me too, I got it from some blog post
22:10:28 <dmj`> dpwright: http://javran.github.io/posts/2014-03-01-add-tags-to-your-hakyll-blog.html
22:10:34 <dpwright> that puts the whole tag link in as a string
22:10:50 <dpwright> links for all the tags, in fact
22:10:52 <dpwright> then I just output that link as text
22:10:58 <dpwright> so I never iterate over then
22:11:01 <dpwright> them*
22:11:12 <dmj`> dpwright: yea, I do the same, but I want to color them individually
22:11:20 <dmj`> dpwright: and don't want to reach for javascript just yet
22:11:23 <dpwright> if you want to style the tags individually it looks like tagsFieldWith should do you
22:11:40 <dpwright> it lets you supply a function to render the HTML for each tag
22:11:46 <dmj`> dpwright: jaspervdj's blog doesn't use getTags, I wonder who implemented that
22:11:51 <dmj`> dpwright: ooo...
22:12:53 <dmj`> dpwright: Oh I see, so you do the html in haskell
22:15:18 <dpwright> that's right
22:15:43 <dpwright> you can also specify how to put the tags together (comma separated, in a list, or whatever)
22:16:01 <dmj`> dpwright: do you use categories
22:16:14 <dpwright> I don't know; I decided tags was enough for me
22:16:21 <dpwright> oops
22:16:26 <dpwright> I meant "I don't, no"!
22:16:33 <dpwright> bit of a brainfart
22:23:45 <dmj`> dpwright: all I do is brainfart on this channel, no worries
22:25:08 <dmj`> dpwright: thanks for the help btw
22:25:15 <dpwright> np
22:25:58 <dpwright> btw, my site is actually a literate program that builds itself, so if you like any of the features on it you can see how they work just by reading the right post from this list: http://dpwright.com/tags/generating%20this%20website/
22:28:03 <dmj`> dpwright: solid, thanks brotha, blog post about creating the blog post, so meta
22:28:53 <dpwright> heh
22:44:50 * hackagebot attoparsec 0.13.0.0 - Fast combinator parsing for bytestrings and text  http://hackage.haskell.org/package/attoparsec-0.13.0.0 (BryanOSullivan)
22:54:07 <R0b0t1> does anyone have interesting reading?
22:54:11 <R0b0t1> I find myself without purpose
23:04:51 * hackagebot email-validate 2.1.2 - Validating an email address string against RFC 5322  http://hackage.haskell.org/package/email-validate-2.1.2 (GeorgePollard)
23:11:19 <rasen> R0b0t1: http://www.reddit.com/r/haskell/comments/2blsqa/papers_every_haskeller_should_read/
23:11:57 <rasen> I usually take one from here ^ when have nothing to do
23:12:39 * echo-area loves the fact that function definitions can be deduced from the context
23:12:44 <R0b0t1> oi vey
23:12:48 <R0b0t1> rasen, thanks
23:38:36 <sinelaw> which is more polymorphic? forall a b. a -> b       or      forall c. c -> c          on one hand, the first looks more polymorphic. but 'a' being in a contravariant position confuses me.
23:41:28 <sinelaw> if comparing the set of allowed types, obivously forall a b. a -> b  can be instantiated to more types
23:46:02 <kaidelong> has anyone made a library for strategies for inverting push/pull control flow?
23:46:54 <kaidelong> (IE clocked pushing from a pull structure, buffered pulling from a push structure, along with other strategies like only storing the latest etc)
23:47:52 <kaidelong> I picked netwire originally because I liked that it was pull based and clocked and had a notion of an inhibition monoid, and wires acted in a context of some or other monad
23:48:11 <kaidelong> but SDL seems to be the only thing in the wild that plays nice with pulling
23:49:52 * hackagebot path 0.0.1 - Path  http://hackage.haskell.org/package/path-0.0.1 (ChrisDone)
23:50:39 <ollef> sinelaw: if `f : forall c. c -> c` and `g : forall a b. a -> b` then `/\c. g [c] [c] : forall c. c -> c`
23:54:24 <ellwyne> Hey guys. How do you construct functions such as "read", "random", that produce different output based on a type that you give it? such as random (mkStdGen 100) :: (Int, StdGen) ; read 5::Int
23:54:54 <sinelaw> ellwyne, type classes. 
23:54:57 <sinelaw> @src Read
23:54:57 <lambdabot> class Read a where
23:54:57 <lambdabot>   readsPrec    :: Int -> ReadS a
23:54:57 <lambdabot>   readList     :: ReadS [a]
23:54:57 <lambdabot>   readPrec     :: ReadPrec a
23:54:57 <lambdabot>   readListPrec :: ReadPrec [a]
23:55:05 <sinelaw> @type read
23:55:07 <lambdabot> Read a => String -> a
23:55:37 <sinelaw> ellwyne, "read" is parameterized on the return value, which can be any type that is an instance of the Read type class. 
23:55:56 <sinelaw> ellwyne, each type (such as Int) implements the instance of Read in a different way. Hence the specialization
23:56:43 <ellwyne> Ah, makes sense. Thanks!
23:59:52 * hackagebot path 0.1.0 - Path  http://hackage.haskell.org/package/path-0.1.0 (ChrisDone)
