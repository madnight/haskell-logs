00:00:09 <arkeet> maybe time to get some sleep then? :-)
00:00:15 <dartxx> Axman6: Got it!
00:00:37 <dartxx> arkeet: Indeed, it is, haha. I'll go to sleep in a bit, right after I fix one or two bugs.
00:01:51 <unb3k44n7> main = do putStrLn "What is 10 'div' 2?" x <- readLn if x == 2 then putStrLn "Fuck you!" else put StrLn "Fuck yeah!"
00:02:25 <arkeet> I hope that's not your acutal exact code.
00:02:30 <arkeet> can you put it on lpaste or something?
00:02:36 <arkeet> with whitespace and all
00:03:07 <unb3k44n7> How
00:03:10 <arkeet> @paste
00:03:10 <lambdabot> Haskell pastebin: http://lpaste.net/
00:03:13 <arkeet> copy and paste your code here.
00:03:20 <Axman6> yeah we can't give help about partsing errors if we can't see the code being parsed
00:03:29 <arkeet> preferably the entire file.
00:03:42 <arkeet> and the full error message 
00:03:49 <unb3k44n7> @paste main = do putStrLn "What is 10 'div' 2?" x <- readLn if x == 2 then putStrLn "Fuck you!" else put StrLn "Fuck yeah!"
00:03:49 <lambdabot> Haskell pastebin: http://lpaste.net/
00:03:52 <arkeet> no.
00:03:54 <arkeet> go to that site.
00:04:00 <arkeet> :(
00:04:06 <arkeet> and copy the code from your editor.
00:04:07 <Axman6> >_<
00:04:08 <arkeet> into the box.
00:04:14 <arkeet> not by hand.
00:04:15 <dartxx> Axman6: I've just noticed that I'm looking into SpecialKey's, but I'm actually using a Map Char ___..
00:04:37 <Axman6> dartxx: yeah you definitely don't want that. seems you're not using Gloss how it's supposed to be used
00:04:40 <arkeet> dartxx: maybe time to use Key for your key instead.
00:04:44 <Axman6> how are you taking input?
00:04:45 <kadoban> dartxx: Yeah, you should probably have a Map Key …
00:04:53 <dartxx> Axman6: That's why I wasn't looking into Gloss in the first place, I guess, lol.
00:05:10 <arkeet> well surely you're getting your Char from gloss somehow.
00:05:15 <arkeet> maybe by deconstructing a Key value.
00:06:07 <dartxx> Ugh, I hate it when things get compiled and linked and run and it's all rainbows and unicorns, but then the logic is all wrong..
00:06:10 <unb3k44n7> Ook.....
00:06:20 <unb3k44n7> It's pasted.
00:06:26 <unb3k44n7> And then?
00:06:30 <Axman6> now give us the link
00:07:25 <arkeet> just to make sure
00:07:32 <arkeet> this is in some .hs file you are compiling or loading with ghci
00:07:36 <arkeet> and you're not typing that directly into ghci
00:07:37 <arkeet> right?
00:07:54 <unb3k44n7> It's the same thing
00:08:04 <srhb> No, you can't do foo = ... in ghci
00:08:09 <srhb> you need let foo = ...
00:08:19 <arkeet> it's not the same thing.
00:08:24 <arkeet> else I wouldn't have said that.
00:08:57 <dartxx> Axman6: I guess I have to separate the pattern matching for Char key and SpecialKey key cases.
00:09:19 <unb3k44n7> Pretty sure. It's still all on one line
00:09:25 <unb3k44n7> Did you want it on seperate lines?
00:09:28 <arkeet> ...
00:09:34 <srhb> unb3k44n7: Then you need some semicolons at least.
00:09:36 <srhb> And braces too
00:09:38 <arkeet> I want it exactly how you typed it.
00:09:41 <unb3k44n7> Hey, If you're going to be rude I don't want your help Arkeet.
00:09:43 <arkeet> and you still haven't answered how you're running it.
00:10:06 <srhb> At this point I think we'd settle for a screenshot of what you did. :-)
00:10:11 <arkeet> sure.
00:10:23 <arkeet> you should try to make it easy for us to help you.
00:10:35 <srhb> But in general, pastebinning the actual interaction and code (unaltered, exactly as you used it!) is the way to go. :)
00:10:40 <Axman6> unb3k44n7: we're trying to help you, but you need to give us as much information as possible for us to do that. you've made several assumptions which are wrong, which we couldn't fix because you didn't tell us
00:11:08 <Axman6> arkeet hasn't been at all rude, and has actually been very patient
00:11:09 <Myrl-chan> > 1 + (2 +) 3
00:11:10 <lambdabot>  6
00:11:14 <Myrl-chan> Holy cow. Lol.
00:11:22 <Myrl-chan> pyon: You're right.
00:11:23 <srhb> unb3k44n7: All I can surmise from what you wrote is that if it was really on one line, you forgot braces and semicolons AND you wrote put strLen when you meant putStrLn
00:11:27 <unb3k44n7> I'm sure.
00:11:38 <Myrl-chan> Or not.
00:11:42 <Myrl-chan> > (1 + (2 +) 3
00:11:44 <lambdabot>  <hint>:1:13:
00:11:44 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
00:11:45 <Myrl-chan> > (1 + (2 +)) 3
00:11:46 <lambdabot>      No instance for (Show a0)
00:11:46 <lambdabot>        arising from a use of ‘show_M728487891388795648423956’
00:11:47 <lambdabot>      The type variable ‘a0’ is ambiguous
00:11:56 <unb3k44n7> The original question was why is there a parse error on the equal sign.
00:11:59 <pyon> Myrl-chan: Just because there's a Num instance, it doesn't mean there's a Show one!
00:12:00 <Axman6> unb3k44n7: when trying to debug par5sing errors, it's extremely important to be able to see the exact code which is failing to parse
00:12:02 <Myrl-chan> Awww. :( pyon, ignore what I just said. ;-;
00:12:06 <unb3k44n7> But we're good. I'll figure it out myself..............
00:12:07 <srhb> unb3k44n7: Don't know. Depends how you actually used it
00:12:10 <Myrl-chan> pyon: Tru.
00:12:13 <srhb> unb3k44n7: Why? We can help you. :)
00:12:27 <srhb> unb3k44n7: Saves a lot of time. Just paste the actual interaction on lpaste.net with newlines and all.
00:12:42 <arkeet> unb3k44n7: it's still not clear what the exact code is, and how you are trying to compile/run it. this information is *vital*
00:12:50 <arkeet> a screenshot would do
00:13:29 <srhb> unb3k44n7: Here's an example of a good paste: http://lpaste.net/4593204117022703616
00:13:41 <_m_ryan> hi can anyone check my code and explain me what was wrong about it? http://lpaste.net/133481 thanks
00:13:52 <srhb> To which the answer would be "ah, in ghci you can't define things like you do in top level in a .hs file. You need let foo = 2"
00:14:54 <srhb> unb3k44n7: Without the information we'd get from a paste, we can only guess that that might be the cause, but it could be several other things.
00:14:57 <srhb> Anyway, I'm done. :P
00:15:06 <arkeet> _m_ryan: I'm not familiar enough with yesod to help, maybe #yesod can help?
00:15:07 <srhb> I just don't want you to feel we're being unreasonable.
00:15:38 <_m_ryan> arkeet: thank i also posted same question ther :)
00:15:53 <liste> _m_ryan the "Type variable site0 is ambiguos" hints that you need more type annotations
00:16:13 <arkeet> sure, although that's not always the right solution.
00:16:27 <Axman6> unb3k44n7: to be very clear, we want to help, and want you to keep asking for help.But we do need you to make our lives easier, sometimes it's not possible to help without seeing exactly what is going wrong
00:19:12 <_m_ryan> liste: you mean the runDB has a double meaning in my code?
00:21:57 <liste> I think the problem is that you have do inside a let
00:22:26 <liste> so the type of latestAvgAmt is Handler something
00:23:02 <liste> try replacing let latestAvgAmt = ... with latestAvgAmt <-
00:25:56 <liste> you get the error because ghc doesn't now what Handler the latestAvgAmt is
00:26:30 <liste> also, on 27 and 28 you don't need the return:s
00:27:49 <_m_ryan> liste: what should i return? only the state/rawAvg?
00:29:17 <liste> _m_ryan instead of Nothing -> do return rawAvg, try Nothing -> rawAvg
00:30:27 <liste> then the type of latestAvgAmt would be [RawLatestAvgPrices] instead of Monad m => m [RawLatestAvgPriceß]
00:32:20 <dartxx> Axman6: Ooookay, it works now. Thanks a lot! I need some sleep now.. Haha.
00:32:35 <dartxx> arkeet: Thank you too!
00:32:49 <arkeet> np
00:40:54 <simg> hi, is there a way of making cabal pre-process .hs files - specifically, I want to declare a whole bunch of module imports in one place and have them automatically imported into every module ? I'm aware of Distribution.Simple.PreProcess - is that likely to do what I want? Should my build type be "custom" or something else?
00:41:35 <merijn> simg: A better way way is to simply define a module that reexports everything you want to import everywhere and then import that one module in each file
00:42:11 <simg> merijn: problem there is circular imports :(   - unless I'm missing something?
00:42:38 <jle`> if you have circular imports than manually importing things circularly like you suggest would give you the same problem
00:42:41 <jle`> :)
00:43:23 <jle`> if your manual imports are sound, then the big-import method should be okay too
00:43:34 <merijn> simg: Solution: Patch GHC to support recursive imports! :D
00:43:38 <simg> jle' - i don't *think* so. but not sure I want try and explain my "reasoning"
00:43:49 <merijn> simg: I'll buy you a beer and a cake when you do! ;)
00:44:36 <jle`> if you want a file to import a list of modules...then having a module import and re-export those modules and importing taht one module should be the same thing
00:44:43 <_m_ryan> liste: i think it works, thanks :)
00:45:29 <arkeet> why not just import the modules you need?
00:45:57 <arkeet> if you have so many modules, consider combining some?
00:46:55 <simg> arkeet: I want avoid the same 30 or so (fairly complicated) imports on every one of potentially hundreds of source files. (it's already unmanageable with ~25 source files)
00:47:23 <arkeet> why do you have so many?
00:47:40 <arkeet> and if you really have the same list of imports in each one, you can just do the re-exporting thing
00:47:40 <simg> arkeet: i don't have so many modules. (I thought Haskell was suited to building complex systems? - I haven't got started on complex yet)
00:48:05 <arkeet> you said potentially hundreds.
00:48:06 <arkeet> that sounds like a lot.
00:49:28 <simg> arkeet: not to me *at all*. ("enterprise" software with lots of "entities")
00:50:01 <merijn> simg: Well, either your imports are non-circular and you can use the reexport method
00:50:03 <srhb> simg: The solution is often as stated. Combine common imports in one module, then import that instead.
00:50:25 <liste> I think in complex systems you should keep per-module dependencies low
00:50:26 <simg> srhb: that doesn't work because of circular imports
00:50:28 <merijn> Or they are circular and then you need to solve the circularity anyway (be it hs-boot files or removing the cycle)
00:50:34 <srhb> Right. :)
00:50:43 <merijn> simg: In which case you can still use the reexport method
00:50:54 <liste> have loosely coupled components and have one module that brings them together
00:51:05 <simg> merijn: I've seen hs-boot (and sorry, but that sucks as a "solution")
00:51:06 <merijn> liste: That's not always possible
00:51:17 <merijn> simg: Well then you're screwed
00:51:37 <merijn> Because no one has had the time/motivation to properly implement recursive imports in GHC yet
00:51:57 <srhb> That should totally have been a question in the recent survey. 
00:52:10 <srhb> "How important is proper recursive imports"
00:52:15 <merijn> Lack of recursive imports is one of my pet peeve
00:52:17 <merijn> *peeves
00:52:19 <simg> merijn: which is why I'd like to be able to pre-process .hs files then I can effectively do it myself.
00:52:25 <merijn> But I don't have the time to look into it
00:52:36 <merijn> simg: How does pre-processing fix your import cycles?
00:52:42 <srhb> It's definitely not a nice situation currently.
00:53:05 <merijn> New plan
00:53:24 <merijn> Step 1) force haskell as part of the curriculum, step 2) trick student to do recursive imports as graduation project...
00:53:28 <simg> merijn: need to think about how I'd explain that
00:53:41 <int-e> simg: how about doing what most people do and just import what you need... work with the system rather than against it.
00:53:57 <merijn> On that note, any Dutch haskellers wanna do a project on recursive imports in GHC for ECTS? ;)
00:54:07 <merijn> int-e: Because the system sucks
00:54:28 <merijn> int-e: You end up with a single .Types module listing every single data structure if your data structures refer to eachother
00:54:36 <merijn> int-e: Breaking any logical separation
00:54:52 <srhb> merijn: Has to be dutch? ECTS are all over EU after all :)
00:54:54 <simg> int-e: because in many (most) cases my list of imports is longer than the rest of the source
00:55:06 <int-e> merijn: I'd say that if they refer to each other than there wasn't much of a separation to begin with...
00:55:32 <simg> int-e (and more complicated). I want a consistent "vocabulary" across my application without a cut/paste nightmare
00:55:44 <merijn> srhb: Yeah, but I wouldn't know the bureaucratic hurdles of supervising an international student
00:55:44 <int-e> It's not that I don't see the point. It's just never bothered me so far.
00:55:54 <srhb> merijn: Good point.
00:56:04 <simg> int-e: I'm open to the idea that I'm thinking about it wrong :)
00:56:14 <srhb> merijn: Are you a professor somewhere? :)
00:56:29 <merijn> int-e: Not between the data structures, but if I have 3 authorization data types they should go into the "authorization" module with the functions that use them
00:56:40 <merijn> int-e: Not in a .Types modules with every single other data structure
00:57:02 <merijn> srhb: No, just a phd student, but somehow they still allow me to supervise students like I'm qualified... :p
00:57:16 <srhb> merijn: Gasp! :-) Nah, I guess that's pretty normal. Also: Nice.
00:58:15 <lpaste> simg pasted “typical imports” at http://lpaste.net/133488
00:58:44 <simg> I'm trying to avoid putting that (and worse) in every source file
00:59:16 <arkeet> could CPP help?
00:59:18 <merijn> simg: But none of those would be recursive
00:59:24 <arkeet> and that.
00:59:31 <arkeet> but re-exporting doesn't help with qualified imports.
00:59:33 <merijn> simg: Because all of those are from, I'm assuming, external libraries
01:00:15 <simg> merijn: I need a better example. yes, external libraries are fine. it's when need to start including my interal libaries the problems start
01:00:23 <merijn> I like how hlint suggests "error: use fewer imports" >.>
01:00:27 <arkeet> lmao
01:00:36 <int-e> simg: It's quite possible that I simply haven't written large enough software. But it sounds like your modules may be to finely grained.
01:00:45 <merijn> simg: Well, look at the 3 Helpers.X imports you have
01:00:56 <merijn> simg: Why not reexport those from Helpers and only "import Helpers"?
01:01:35 <arkeet> oh it's complaining because you're importing Text.Digestive.Form twice
01:01:44 <simg> merijn: bingo ! because Helpers.Theme imports Helpers.Utils (not shown) and Helpers.Utils imports Helpers.Theme. - i Don't see a way round this
01:02:07 <arkeet> how would any sort of preprocessing whatever help with that?
01:02:18 <merijn> simg: So use a hs-boot file to break the cycle in Helpers.Utils?
01:02:28 <muzzle> hi, does anyone here know how i can get hackage to build my package with ghc 7.10
01:02:39 <merijn> That's only one cycle you need to break and the problem goes away for the rest
01:02:40 <arkeet> hackage builds packages?
01:02:56 <arkeet> I suppose it does for docs.
01:02:59 <simg> >hs-boot   - that doesn't look like a good solution. having to re-implement the functions in another file. hardly DRY
01:03:20 <arkeet> or just get rid of the cycle some other way.
01:03:32 <merijn> simg: Right, then see my original answer of "either you do that, or you refactor the cycle away, or you give up"
01:03:34 <arkeet> but I still don't see what this has to do with dealing with big import lists.
01:03:36 <merijn> simg: Those are your three options
01:04:09 <merijn> muzzle: You can't control that, but you can manually upload docs, if that's the issue
01:04:26 <int-e> muzzle: wait, possibly ask #haskell-infrastructure when the server will be updated to ghc-7.10. (The answer to which, I expect, will refer to the Haskell platform. But I may be wrong.)
01:04:32 <muzzle> merijn how do I do that ?
01:04:50 <merijn> muzzle: See http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html and the edit at the bottom
01:04:56 <int-e> muzzle: afaiu, hackage only has a single ghc version installed, and all packages are built with that.
01:08:33 <simg> arkeet: I could "easily" resolve the circular import problem if I simply imported every module I need individually into each source file. unfortunately that would make 50% of my codebase the same fiddly, complicated, non-DRY import statements. being able to pre-process means I could do that whilst keeping my code clean. 
01:09:06 * hackagebot observable-sharing 0.2.1.0 - Simple observable sharing  http://hackage.haskell.org/package/observable-sharing-0.2.1.0 (mararon)
01:09:32 <pacak> simg: There's always CPP if you are into that kind of stuff...
01:09:47 <arkeet> I don't see how fiddling with import lists will help you get Helpers.Utils and Helpers.Theme to not depend on each other.
01:09:57 <arkeet> unless you're saying that one of those imports is redundant.
01:10:28 <pacak> simg: But by automating chaos you can get only one thing - automated chaos.
01:10:36 <simg> arkeet: hmm, you may have a point :/
01:16:37 <Ainieco> hello
01:16:51 <liste> hello
01:17:22 <Ainieco> why people in money(jane street, bloomberg) industry tend to use ocaml and not haskell? 
01:17:42 <liste> well standard chartered has even their own Haskell variant
01:17:49 <Axman6> there's plenty of financial firms using haskell too
01:18:12 <merijn> Ainieco: Standard Chartered and that place where edwardk is use haskell and so do some other banks, afaik
01:18:19 <Axman6> McGraw Hill Financial too
01:18:22 <merijn> Ainieco: So I don't think that statement is very true
01:18:50 <merijn> Jane Street has invested a lot of time and work into ocaml, so obviously they're not gonna switch now
01:18:52 <liste> what do they use Haskell for by the way? HFT?
01:19:17 <liste> modeling?
01:19:22 <merijn> liste: Modelling probably
01:19:26 <Axman6> they don't tend to give many details
01:19:34 <merijn> HFT has low latency and real time demands
01:19:45 <merijn> Haskell's not very suitable there
01:19:52 <merijn> But modelling and analysis is fine
01:19:55 <ocharles_> not with that attitude
01:20:31 <merijn> ocharles_: The only way I can see to make haskell work in a hard real time environment is as a DSL for producing other code
01:20:44 <ocharles_> I wasn't being entirely serious :)
01:21:02 <merijn> Now I guess HFT is more semi-hard than real hard, but that depends on your willingness to consider losing money a critical failure  or not ;)
01:21:50 <liste> well, they have their own variants, maybe they plan to make them non-GC
01:21:59 <Axman6> Tsuru Capital use haskell for HFT
01:22:47 <bernalex> Ainieco: haskell is young, ecosystem-wise. it's surpassed ocaml in that regard now, but I imagine banks are not the first to scrap several millions SLOC to rewrite into whatever new trendy thing.
01:23:37 <Ainieco> bernalex: merijn cool, thanks for answers!
01:23:46 <liste> why is FP so big on financial sector?
01:24:01 <Ainieco> liste: because people care about money
01:24:06 * hackagebot persistent-postgresql 2.1.6 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-2.1.6 (MichaelSnoyman)
01:24:20 <valdyn> liste: excel is already functional
01:24:37 <Axman6> valdyn: and is still a major tool used at finance firms
01:24:47 <liste> that's a pretty good selling point for FP (:
01:25:05 <valdyn> Axman6: of course, so the step to haskell is not that big
01:25:51 <dzack> anyone use hdevtools?
01:26:15 <merijn> dzack: Yes, but not the one on hackage, because it appears to be unmaintained
01:26:27 <Ainieco> Axman6: is there a story about Tsuru Captial and Haskell anywhere?
01:26:50 <dzack> oh, hmm. I'm basically trying to use it in combination with halcyon and sandboxes
01:27:13 <Axman6> probably not, they've never said much publicly. I worked there for a few months
01:27:14 <dzack> is there a more current version?
01:27:46 <Ainieco> Axman6: why did you leave them?
01:28:03 <merijn> dzack: There's several branches on github in various states of maintenance
01:28:27 <Axman6> it was a three month internship
01:30:02 <dzack> ah okay. I don't know if this is a more distro-specific question, but if I make/install that and throw it on my path, will it use the first ghc it finds on the path..?
01:30:03 * Axman6 -> Away
01:30:30 <dzack> i have two ghc versions - one for halcyon installs, and one for more os-specific stuff like xmonad
01:31:40 <kadoban> merijn: Are you sure the one on hackage is unmaintained? I don't see why you say that. I looked a while ago and it seems to have updates fairly recently, and doesn't appear broken?
01:31:41 <merijn> dzack: No, hdevtools links against the ghc-api, so it will use the version of GHC you build it with
01:32:04 <merijn> kadoban: Oh, it updated recently
01:32:11 <kadoban> Ahh
01:32:14 <merijn> Beginning of the year the last update was like halfway 2013
01:32:27 <kadoban> Okay, that makes sense.
01:32:36 <pacak> Ainieco: Tsuru Capital uses lots of haskell.
01:32:51 <merijn> kadoban: oh, looks like someone was added as maintainer, because it wasn't uploaded by BitC
01:33:13 <kadoban> Yeah, I think that other guy, who's name I totally forgot, must have taken over
01:40:50 <dzack> merijn: thanks for clearing that up! still coming to grips with how ghc/cabal-install interact, but it looks like everything built fine
01:42:31 <zipper> Hey guys.
01:42:43 <zipper> Can I get a little help with a simple sum type here: https://gist.github.com/urbanslug/66c0062e9377ec1c5ff7
01:44:14 <ocharles_> zipper: are you looking for  data RemoteDirr = RemoteDirr0 (FilePath -> FilePath) | RemoteDirrN FilePath  ?
01:44:40 <merijn> dzack: If you're experimental and enjoy pain you can look into ghci-ng which is attempting to build the necessary things for stuff like hdevtools/ghc-mod into ghci so the tools ship with ghc and are version independent
01:44:49 <zipper> ocharles_: I guess something like that.
01:45:00 <zipper> ocharles_: but don't I have to use ::
01:45:19 <ocharles_> nope, only when you define records
01:47:24 <zipper> ocharles_: Okay let me see how that goes.
01:48:10 <zipper> ocharles_: Could you give me a clue on creating a FileInfo value? I'm having trouble with it.
01:48:54 <ocharles_> You would use something like:  FileInfo { fileInfoRemoteDir = RemoteDirrN "/hello/world", fileInfoRemoteFile = "/another/file", fileInfoAccessor = ... }
01:48:59 <ocharles_> i don't know what "Accessor" is
01:49:08 * hackagebot monad-skeleton 0.1.2 - An undead monad  http://hackage.haskell.org/package/monad-skeleton-0.1.2 (FumiakiKinoshita)
01:49:21 <zipper> ocharles_: Oh thanks
01:56:27 <Ainieco> pacak: he-he, looks like there are a lot people from Tsuru Capital here
01:56:46 <quchen2> jaspervd1: Your Prio type violates both Functor and Applicative laws, no?
01:57:04 <Ainieco> pacak: would be cool to read their story on Haskell
02:55:15 <fvgvxmpv1> I find myself in the situation were I need to generate a valid bash/sh script as a Bytestring, including escaping some string literals — any advice, except "don't"? (I checked hackage for obvious modules but I found nothing that´s available in nixos-channel)
02:56:52 <fvgvxmpv1> I could of course look up the escaping rules for, say, sh and write something myself, but I would, as always, like to avoid that, If possible
02:57:00 <mauke[> add ' at beginning and end; replace every internal ' by '\''
03:00:08 <merijn> I would say "by paying some sucker to implement that library for you" ;)
03:00:24 <merijn> Call it an internship and then pay them nothing for their work :p
03:00:46 <fvgvxmpv1> Hmmmm, maybe I could inject an "exercise" into a local haskell course? }:->
03:03:21 <mauke[> > let sh_esc = ("'" ++) . (++ "'") . concatMap (\case of '\'' -> "'\\''"; c -> [c]) in sh_esc "hello, world!"
03:03:22 <lambdabot>  <hint>:1:47: parse error: naked lambda expression ''
03:03:35 <liste> fvgvxmpv1 would the shell monad (http://joeyh.name/blog/entry/shell_monad/) help?
03:04:42 <mauke[> > let sh_esc = ("'" ++) . (++ "'") . concatMap (\c -> case c of '\'' -> "'\\''"; _ -> [c]) in sh_esc "hello, world!"
03:04:44 <lambdabot>  "'hello, world!'"
03:05:11 <mauke[> > let sh_esc = ("'" ++) . (++ "'") . concatMap (\c -> case c of '\'' -> "'\\''"; _ -> [c]) in map sh_esc ["", "\n", "'", "\"\\", "foo\nbar"]
03:05:13 <lambdabot>  ["''","'\n'","''\\'''","'\"\\'","'foo\nbar'"]
03:05:31 <fvgvxmpv1> liste: yes, It would — I´ll have to somehow fenangle it for nixos though… oh, well that´s the cleanest solution, I guess
03:05:56 <liste> fvgvxmpv1 do you use cabal2nix ?
03:06:36 <pacak> Ainieco: We are using lots of haskell for HFT stuff, analysis and basically everything else except for some bits of coffeescript in web reporting part.
03:07:04 <fvgvxmpv1> liste: cabal2nix would work, sure; I´d rather somehow inject the channel hackage links to for nixos into my profile, though — whatever that means
03:08:04 <Pato> can anyone help me with a depth of a tree?
03:08:24 <liste> Pato calculating it?
03:08:58 <Pato> liste: yes, using catamorphisms, if you're familiar with that. I can calculate for some trees, but not for others
03:09:24 <mauke[> where are you stuck?
03:09:59 <Pato> not really "stuck" but it just gives me the wrong result. Here's the situation
03:10:30 <Pato> I have a working depth function for a simple leaf tree.
03:10:40 <mauke[> show us code
03:10:46 <Pato> 1 sec
03:11:52 <Pato> This is the one of the WORKING one: depth = cataLTree (either (const 0) (\(t, t') -> succ( max t t')). The data type for LTree is data LTree a = Leaf a | Fork (LTree a, LTree a) deriving (Show, Eq)
03:12:10 <Pato> now, this is the one for the one not working, which always gives me 0
03:12:24 <Pato> depthTLTree = cataTLTree (either (const 0) (\(t, (t',t'')) -> succ( maxT (t, (t',t''))))) 	where maxT (a,(b,c)) = max  a (max b c) 
03:12:30 <Pato> and the datatype 
03:12:37 <Pato> data TLTree a = L a| N (TLTree a,(TLTree a,TLTree a)) deriving (Eq,Show)
03:12:57 <mauke[> that's a weird tree
03:13:30 <mauke[> @let data TLTree a = L a| N (TLTree a,(TLTree a,TLTree a)) deriving (Eq,Show)
03:13:32 <lambdabot>  Defined.
03:14:07 <frerich> Pato: Shouldn't 'maxT' be defined to something like 'maxT (a,(b,c)) = max  (depthTLTree a) (max (depthTLTree b) (depthTTree c))'?
03:14:17 <mauke[> no, see the cata
03:14:35 <Pato> frerich: no, the recursion is the catamorphism's job.
03:14:36 <frerich> Ah
03:15:40 <mauke[> @let cataTLTree f t = f (case t of L x -> Left x; N (t1, (t2, t3)) -> Right (cataTLTree f t1, (cataTLTree f t2, cataTLTree f t3)))
03:15:42 <lambdabot>  Defined.
03:15:47 <mauke[> :t cataTLTree
03:15:49 <lambdabot> (Either a (t, (t, t)) -> t) -> TLTree a -> t
03:16:13 <maxx_> hello. if I install haskell platform can I cabal install into a global directory and only use sanboxes when I encounter a concflict? and if I can is there any downside to doing it like that compared to always using sandboxes?
03:16:29 <mauke[> > let depthTLTree = cataTLTree (either (const 0) (\(t, (t',t'')) -> succ( maxT (t, (t',t''))))) where maxT (a,(b,c)) = max  a (max b c) in depthTLTree (N (L (), (L (), L ())))
03:16:36 <lambdabot>  mueval-core: Time limit exceeded
03:19:08 <Pato> mauke[: on our side, that always gives us 0, no matter the tree
03:21:51 <frerich> I always thought a catamorphism only replaces all the constructors, i.e. the type of cataTLTree would be '(a -> b) -> ((TLTree a, (TLTree a, TLTree a)) -> b) -> TLTree a -> b'
03:22:17 <frerich> I didn't know it's also supposed to take care of the recursion.
03:22:37 <mauke[> > let depthTLTree = cataTLTree (either (const 0) (\(t, (t',t'')) -> succ( maxT (t, (t',t''))))) where maxT (a,(b,c)) = max  a (max b c) in depthTLTree (N (L (), (L (), L ())))
03:22:39 <lambdabot>  1
03:22:49 <mauke[> Pato: what does your cataTLTree look like?
03:22:57 <mauke[> frerich: look at foldr
03:23:22 <frerich> mauke[: I know that foldr recurses, but what I'm saying is that I didn't know that the recursion is part of what consitutes a catamorphism.
03:23:33 <Pato> mauke[: cataTLTree a = a . (recTLTree (cataTLTree a)) . outTLTree
03:24:06 <mauke[> Pato: ok, and recTLTree and outTLTree?
03:25:27 <Pato> mauke[: recTLTree f = id -|- ( f >< ( f >< f)), outTLTree (L a) = i1 a outTLTree (N (t1,(t2,t3))) = i2 (t1,(t2,t3)), f >< g = split (f . p1) (g . p2), infix 5  ><
03:25:49 <ion> mauke: Re: shell escaping, https://gist.github.com/ion1/7405148
03:25:57 <nshepperd> frerich: you've got to recurse to replace all the constructors
03:26:16 <Pato> mauke[: (-|-) :: (a -> b) -> (c -> d) -> Either a c -> Either b d f -|- g = either (i1 . f) (i2 . g), infix 4  -|-
03:26:18 <frerich> nshepperd: So a function of type 'b -> (a -> [a] -> b) -> [a] -> b' is not a catamorphism on lists?
03:26:51 <mauke[> Pato: i1, i2, split?
03:26:52 <nshepperd> that function only replaces the outermost constructor
03:27:10 <frerich> nshepperd: That's right. That's exactly my question.
03:27:19 <nshepperd> so no
03:27:52 <pacak> :t cata
03:27:55 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
03:27:59 <mauke[> ion: could that be a locale issue?
03:28:31 <Pato> mauke[:i1      = Left i2      = Right, split :: (a -> b) -> (a -> c) -> a -> (b,c) split f g x = (f x, g x)
03:29:17 <mauke[> Pato: p1, p2?
03:29:38 <mauke[> also, this is terrible code
03:29:48 <Pato> mauke[: p1        = fst p2        = snd
03:30:02 <Pato> mauke[: this libraries where provided by my professor, so I have no controll over them
03:31:02 <pacak> p1 = fst p2 = snd? Yuck.
03:31:23 <pacak> Pato: Can you paste  whole your code somewhere?
03:31:35 <osa1_> is there a way to tell Haddock not to link a word to docs but still render as code?
03:32:14 <mauke[> Pato: works here
03:32:40 <Pato> mauke[: it gives the correct depth for a tree, other than 0?
03:32:53 <mauke[> Pato: https://www.fpcomplete.com/project/115786/NRMcm0EMdf
03:32:55 <Pato> pacak: yes, I can give you the libraries
03:33:56 <Pato> mauke[: ah! but you used something a little bit different on the max function. I'll test it on our code
03:34:01 <mauke[> oh, right
03:34:03 * mauke[ changes
03:34:33 <pacak> Pato: Maybe just your code where you have a problem. lpaste or something else. It's hard to read it from irc.
03:34:38 <mauke[> Pato: updated it; still works
03:36:36 <Pato> mauke[: alright, it seems that it's working now. We're still failing a test, but that means we're just generating the tree wrong
03:36:48 <Pato> mauke[: we're getting a depth of 5 when it should give 6
03:37:04 <Pato> mauke[: but the depth seems to be working with your version of the code
03:37:12 <mauke[> I just copy/pasted your code
03:38:16 <Ainieco> whois pacak 
03:38:19 <Pato> mauke[: not exactly, because we use a function "maxT" defined by us and you use the default max
03:38:28 <pacak> Ainieco: o_o
03:38:39 <mauke[> Pato: no, I don't
03:38:54 <mauke[> Pato: are you looking at the latest version?
03:39:10 <Pato> mauke[: this one: https://www.fpcomplete.com/project/115786/NRMcm0EMdf
03:39:15 <mauke[> did you refresh?
03:39:32 <Ainieco> pacak: that's cool, did you see what merijn wrote about RT/low-latency stuff how do you deal with that?
03:39:34 <Pato> mauke[: bottom line being "    print $ cataTLTree (either (const 0) (\(t, (t', t'')) -> succ (max t (max t' t'')))) tx"
03:39:38 <mauke[> Pato: is that a no?
03:39:39 <Ainieco> pacak: or it's not a problem?
03:39:54 <Pato> mauke[:  I refreshed 3 times
03:39:56 <pacak> Ainieco: It's fast enough for our purposes.
03:40:21 <Ainieco> pacak: mistyped /whois :) wanted to know which country you're from
03:40:40 <Pato> mauke[: the one we provided you wast "depthTLTree = cataTLTree (either (const 0) (\(t, (t',t'')) -> succ( maxT (t, (t',t''))))) where maxT (a,(b,c)) = max  a (max b c)"
03:40:43 <mauke[> Pato: ok, that's weird. when I open https://www.fpcomplete.com/project/115786/NRMcm0EMdf in a new tab, I get "print $ depthTLTree tx" as the last line
03:40:53 <dramforever> Interesting... "is that a no? or it's not a problem?"
03:41:13 <mauke[> dramforever: don't mix the streams
03:41:35 <dramforever> okay...
03:42:14 <dramforever> :) (spent like 10 secs figuring out how to disable Chinese input method)
03:42:30 * dramforever spent longer typing that...
03:42:37 <dramforever> never mind
03:43:01 <Pato> mauke[: would a screenshot help?
03:43:18 <mauke[> Pato: whom?
03:43:18 <liste> whois is no hint of one's country of origin
03:43:51 <liste> many chat on VPSes
03:44:14 <mauke[> Pato: http://lpaste.net/133493
03:44:26 <Pato> mauke[: Just to confirm that we're looking at the right thing. I mean, the code seems to be working, all I was saying is that the problem was that we used a function "maxT "that didn't do the right thing, and you used "max"
03:44:30 <Pato> mauke[: doing the right thing
03:44:36 <Ainieco> liste: not all, i'm pretty sure that pacak is from singapore
03:44:56 <Pato> mauke[: well, that is indeed different fromt he one we were looking at
03:46:03 <Ainieco> and Tsuru corp is jp based it seems, meaning that they're ok with people working remotely, might have a chance myself then, ha-ha
03:47:48 <pacak3> Ainieco: o_o
03:52:22 <Pato> mauke[: I don't even know what to say. Before I posted here I tested it and I got a 0. I probably messed up when building the tree and the function was working just fine the entire time. 
03:54:16 * hackagebot text-binary 0.2.0 - Binary instances for text types  http://hackage.haskell.org/package/text-binary-0.2.0 (JakubWaszczuk)
03:58:20 <fishburne> Can some one explain how the 'field' function in this page work https://ocharles.org.uk/blog/posts/2012-12-03-postgresql-simple.html
04:01:13 <liste> fishburne it decodes a single field from the SQL result row
04:01:32 <fishburne> liste, But how does this line work 'fromRow = Present <$> field'
04:01:58 <fishburne> liste, field is a function that does not have any arguments.
04:02:06 <Pato> can you help with an anamorphism as well? I'm having trouble when converting a "typical" recursive function to an anamorphism
04:02:17 <liste> fishburne it's applicative
04:02:45 <liste> compare it to e.g.  getLine
04:02:49 <liste> that's monadic
04:02:55 <bergmark> fizbin: if you replace field with _field you will get an error with the expected type in that location
04:03:00 <liste> it has no arguments either
04:03:02 <mauke[> it's also not a function
04:03:56 <fishburne> mauke[, it is not a function? field :: FromField a => RowParser a
04:04:01 <merijn> "field :: FromField a => RowParser a" <- where is the function?
04:04:10 <merijn> fishburne: Double arrow indicates a constraint
04:04:11 <liste> => is context arrow, not function arrow
04:04:59 <liste> fishburne it's roughly equivalent to do {myField <- field; return (Present myField) }
04:05:54 <ski> it's equal to that (by law)
04:06:41 <liste> you see that pattern all over, e.g. Parsec parsers
04:06:55 <liste> or FromJSON instances
04:07:21 <ronh-> fishburne right, that is not a function
04:07:42 <ssquare> Make there a width doo doo door. Done enthusiasm noses a fussy to the heck to long handications. Stay house it can up.
04:07:44 <ssquare> Two guns outsider the victims of v17 initially carrior bunch of must look more epic when backported for six money. The long along along yaing out turn will into spray on foot, and November).
04:07:46 <ssquare> In 2008 v5 and find and stole roll up that was a good 2 or Sheamus.
04:07:47 <ssquare> Spell effect.
04:07:50 <ssquare> Bring stuck arounds show lately on 31 May aroundants below, and "v2 ISO resulted teen release behind of v17.x servant. The enthusiasm nose? The dust. It'll need toilet paper use person them on a fun. TPing Preside the Ubuntu-base cycle and your prank, but the home. An inger being day off run the reas on the houses, like "DUDE."
04:07:50 <ski> (also `(<$>)' isn't an applicative functor operation, it's just an ordinary functor operation, equal to `fmap' .. however, `(<$>)' is commonly used together with the applicative `(<*>)')
04:07:51 <ronh-> fishburne there's no -> in the signature
04:07:53 <ssquare> If it cars, and house, version numer to TP job, or all pieces the rolls penny and shaving daylight getting itself.
04:07:56 --- mode: ChanServ set +q *!*@84.232.57.219
04:08:47 <liste> that seems pointless
04:08:48 <fishburne> liste, So the line 'fromRow = Present <$> field' is fmapping the Present data constructor to an empty field, so that it becomes a field that wraps the Present value?
04:09:26 <absence> http://lpaste.net/131547 <- is there a better or more clever way to refactor this?
04:09:42 <liste> fishburne well the field isn't empty
04:10:01 <liste> it's a Text field
04:10:21 <liste> in this case, field :: FromRow Text
04:12:33 <ski> hm, rather `field :: RowParser Text', iiuc, no ?
04:12:48 <liste> ski yes
04:12:59 <liste> so that fromRow :: RowParser Present
04:13:19 <ski> and then since `Present :: Text -> Present', we get `Present <$> field :: RowParser Present'
04:13:24 <ski> yes
04:16:38 <fishburne> liste, I am not getting it. if field is a value, where does it come from.
04:17:15 <ski> frerich : yes
04:17:23 <liste> fishburne it's not a Text value, it's a parser to parse a field into a Text value
04:17:48 <liste> the value itself is a parser
04:18:13 <liste> and we use <$> to combine it with our own Present function (constructor in this case)
04:18:35 <liste> to get a new parser
04:19:01 <liste> postgresql-simple uses that parser later to plop out nice Presents for us (:
04:19:35 <ski> if you want to, you can think of `Present <$> field' here as adding the "post-process" function `Present' to apply to the parsed value, before yielding it, after it has been parsed when the parser is eventually applied to some parse input
04:20:11 <cita> liste: Heya... is there a hashell channel in plain English. I feel scared by the difficult language, but I want to learn the language super badly.
04:20:35 <dramforever> cita: you can always ask for plain English here \
04:20:38 <liste> well, we try to be that channel
04:20:39 <ski> cita : if you mean Haskell, how about this channel ?
04:20:41 <dramforever> or are you being ironic?
04:21:20 <liste> don't be scared, the language will make sense later
04:21:44 <cita> dramforever: Nah, being ironic is annoying because it is ambiguous and so undermines a psychology need for control. I wouldn't do that.
04:21:46 <fishburne> liste, let me try to understand the whole process.. 
04:21:49 <dramforever> you can ask if you didn't understand it
04:21:56 <cita> ski: Yep, Haskell.
04:22:30 <fishburne> query_ c "SELECT name FROM present" returs IO [r0]..but it should return IO [Present]
04:22:48 <fishburne> because allPresents :: Connection -> IO [Present]
04:24:06 <liste> well r0 is a placeholder
04:24:10 <liste> (a type variable)
04:24:13 <ski> fishburne : where did you get that `IO [r0]' from ?
04:24:52 <liste> r0 can be Present
04:25:15 <ski> according to docs, we have `query_ :: FromRow r => Connection -> Query -> IO [r]'
04:25:16 <fishburne> ski, query_ c "select 'asda'" :: FromRow r => IO [r]
04:25:40 <liste> it can also be Child
04:25:46 <ski> so given a connection and a query, will will get `IO [r]' for any `r' that we like, that happen to be in the `FromRow' class
04:26:25 <ski> (presumably we'll get a run-time error of some kind of the actual type we use in place of `r' doesn't match what the actual SQL query yields)
04:26:25 <fishburne> ski, ok. that is starting to make sense...
04:27:49 <liste> if you know Java or C#, the analogue to IO [r] would be something like ArrayList<R>
04:28:50 <ski> (or rather, the analogue to `[r]' would be something like that. the `IO' is an additional thing denoting that we're expressing an Input-Output action, interacting with the world)
04:29:05 <fishburne> liste, yes. But how does IO [r] gets converte to IO [Present]...
04:29:13 <liste> r is Present
04:29:31 <liste> in that particular case
04:29:38 <ion> mauke: I suppose i should test it with different locale settings.
04:29:44 <silver> r is a type variable
04:29:53 <lpaste> dramforever pasted “Just for fun, I've just made a type checker for STLC (might be correct))” at http://lpaste.net/133494
04:30:16 <dramforever> not very elegant
04:30:27 <dramforever> actually, it's not elegant at all
04:30:49 <liste> ski well, everything can do IO in those languages
04:31:24 <ski> iiuc, `SELECT name FROM present' would select a result table with one field/attribute, which can be read as a `Text' (using `field'), and because we've also made `Present' an instance of `FromRow' (using that `field'), `query_' can automagically use this to convert the result table to a list of `Present's
04:31:56 <dramforever> ouch, an extra close paren over there in the title
04:32:35 <ion> dramforever: Just put the xkcd comic in front.
04:33:31 <dramforever> ion: um..huh?
04:33:37 <dramforever> didn't get the joke
04:33:50 <ion> http://xkcd.com/859/
04:33:50 <liste> fishburne the query_ function converts the SQL rows into Presents
04:34:07 <liste> using the fromRow function you define
04:34:08 <dramforever> ion: okay don't worry
04:34:19 <ski> fishburne : `query_ :: FromRow r => Connection -> Query -> IO [r]' is short for `query_ :: forall r. FromRow r => Connection -> Query -> IO [r]', which means that for any actual type we may replace `r' by (which happens to be in the `FromRow' type class), `query_' can have the type `Connection -> Query -> IO [r]'
04:34:21 <liste> it's like passing the fromRow function to the query_ function
04:34:22 <fishburne> liste, but how can the query_ function access the fact that we actually want a Present?
04:34:52 <ski> fishburne : so, one possibly type of `query_' is `Connection -> Query -> IO [Present]'. another is `Connection -> Query -> IO [Child]'
04:35:09 <liste> fishburne you could have something like "query_ :: (Row -> a) -> Connection -> Query -> IO [a]"
04:35:16 <nkar`> kosmikus: is there a reason why safeint provides a wrapper around only the int type?  I need something similar for int64.
04:35:29 <liste> where the first argument is function you define that converts a Row into your own type
04:35:42 <liste> but that would get wieldy fast
04:36:02 <nkar`> kosmikus: is it due to the fact that it's just a poc?
04:36:44 <liste> so postgresql-simple has a FromRow type class that you can write instances for
04:36:58 <ski> fishburne : using `query_' so that the `r' type variable in its type will become instantiated to `Present' (relying on there existing an instance of `FromRow Present') will presumably make `query_' attempt to convert the result tuples to `Present's, using the `fromRow = Present <$> field' parser to parse them
04:37:10 <liste> and then the compiler passes them to query_
04:37:12 <fishburne> liste, is this similar to how the correct instance of return function getting called when you do a return 5 or return 5::[Int]...
04:37:22 <liste> fishburne exactly
04:37:23 <ski> fishburne : yes
04:37:37 <kosmikus> nkar`: I don't think it has a lot of users, but it's not exactly poc either.
04:37:40 <ski> it's type class overloading, getting resolved by type inference
04:37:49 <kosmikus> nkar`: I'm happy to accept patches for Int64 support.
04:38:27 <nkar`> kosmikus: cool, I'll start working on it right now, then!
04:38:41 <kosmikus> nkar`: great. thanks.
04:39:53 <fishburne> liste, ski I think I get it now. Thanks.
04:40:34 <nkar`> kosmikus: ah, one question, though: wouldn't it be better to return a Maybe SafeInt instead of failing at runtime?
04:41:53 <liste> fishburne great (:
04:42:47 <nkar`> kosmikus: I'm working on a web application that stores user's input as int64.  I want to make sure that overflow never happens, but I want to show a nice error instead of failing with a 500 one.
04:42:54 <kosmikus> nkar`: perhaps it would be. but the idea of SafeInt was that (a) it should be as performant as possible; the original idea was to use CPU overflow detection rather than programmed overflow detection. this was never implemented, but still could be. Maybe is likely less efficient. (b) it should be relatively easy to switch a program to/from SafeInt for debugging purposes.
04:45:58 <nkar`> kosmikus: maybe there could be a separate module for such a type, e.g., Data.MSafeInt.  anyway, I'll try to follow the current approach and just add a module for Int64.  we can always extend later.
04:53:47 <lpsmith> kos
04:58:23 <pacak> Is it not possible to have polymorphis associated type families? :(
05:00:36 <merijn> pacak: Define "polymorphic type family"
05:00:40 <merijn> pacak: What does that mean?
05:01:49 <pacak> Well, I'm trying to define a typeclass that gives access to subfields of some structure, but in some cases accessor should be of type Lens' A B and in some cases = Traversal' A2 B
05:02:45 <pacak> class Foo a where type FooT a ; foo :: F a
05:02:45 <pacak> instance Foo A where type  FooT a = Lens' A B
05:03:23 <pacak>  Illegal polymorphic or qualified type: Lens' A B     In the type instance declaration for ‘FooT’     In the instance declaration for ‘Foo a' 
05:03:28 <merijn> pacak: Oh!
05:03:49 <merijn> pacak: It's because "Lens'" is a type synonym, I think
05:04:44 <merijn> pacak: Try "Simple Lens A B" or "Lens A A B B" instead
05:05:02 <pacak> merijn: If I replace it with forall f. Functor f =>  ... it's not working either...
05:05:34 <merijn> Oh, I forgot lens had that forall there
05:05:35 <pacak> It's this forall f it's unhappy about I believe...
05:05:49 <nullvoid8> what about optics and pushing the f parameter to the instance / class declaration
05:05:56 <merijn> pacak: Do you have RankNTypes enabled?
05:06:17 <pacak> merijn: Yep. And a bunch of other as well
05:06:23 <merijn> pacak: Try #haskell-lens
05:06:58 <pacak> It's not really lens-specific question...
05:07:21 <pacak> nullvoid8: optics?
05:07:31 <liste> isn't a Lens a Traversal?
05:07:46 <liste> from lens' hackage page: "you can use any element of the hierarchy as any type it linked to above it"
05:07:56 <nullvoid8> pacak: *searches the lens docs furiously*
05:08:33 <pacak> liste: It is, but I have a few cases where I can construct proper Lens and a few cases when all I can make is a traversal
05:09:36 <nullvoid8> pacak: type Optic p f s t a b = p a (f b) -> p s (f t)
05:09:43 <nullvoid8> specalise p to (->)
05:10:26 <nullvoid8> and put the f parameter in the class head
05:10:40 <pacak> Hmmm... No forall here, that might work.
05:11:37 <nullvoid8> you could also use ConstraintKinds and have type FooT s = Functor / Applicative
05:11:44 <Raydiation> how close is haskells functor definition to category theory's definition
05:12:10 <Raydiation> can you say a functor is a map function for a type?
05:12:21 <nullvoid8> iirc that's exactly it
05:12:38 <merijn> Raydiation: Yes!
05:12:43 <Raydiation> ty
05:12:54 <nullvoid8> "f a" is the functor action on types, fmap is the action on arrows (functions)
05:13:11 <merijn> Raydiation: A functor (in categorytheory) maps "objects" from one category to another and maps "maps" from the same category to the result category
05:13:16 <nullvoid8> (is action the right terminology?)
05:13:26 <merijn> Raydiation: In haskell the objects of functor are types and the "maps" are functions
05:13:44 <Raydiation> i see :)
05:13:48 <ski> Raydiation : a functor consists both of the object mapping, and the morphism mapping
05:13:52 <nullvoid8> ... I have to got to get in the habit of tagging my responses
05:13:59 <merijn> Raydiation: To be precise, haskell functors are endofunctors, which means they map from the category to itself. Or, "haskell types to haskell types" and "haskell functions to haskell functions"
05:14:16 <ski> (nullvoid8 : probably not)
05:14:40 <ski> or rather, instances of `Functor' are endofunctors
05:14:44 <merijn> Raydiation: So in case of the Maybe functor it maps the type "Int" to type "Maybe Int" and the function "(Int -> Bool)" to the function "Maybe Int -> Maybe Bool"
05:15:16 <nullvoid8> does catagory theory terminology form a catagory? :P
05:15:46 <merijn> nullvoid8: SIGBOVIK last year had "A category theoretic interpretation of category theory diagrams" as paper to make exactly that joke :p
05:15:54 * ski itches to nitpick on function types vs. functions :/
05:16:10 <liste> so is "hylo-" a morphism?
05:16:16 <liste> if the objects are terms
05:18:08 <liste> sounds like a category
05:18:23 <f|`-`|f_> (What isn't)
05:18:28 * f|`-`|f_ waggles eyebrows
05:19:42 <liste> but are there any initial or terminal objects?
05:19:58 <f|`-`|f_> All things considered, I'm not sure what's worse, infinite regress, or the fact that there's already multiple branches of math simply dedicated to reducing that to finite terms
05:20:17 <nshepperd> I suppose Functor instances does not completely cover endofunctors in Hask though, since you can't give a Functor instance for a type family like 
05:20:31 <nshepperd> type F a = a
05:21:07 <nshepperd> instead we wrap things in Identity to keep everything sane
05:21:57 <ski> nshepperd : also not for endofunctors from `* -> *', e.g.
05:22:20 <liste> so Functor is a specific type of functor ?
05:22:28 <ski> yes
05:22:37 <pacak> nullvoid8: Slightly better, but now it gives different error message. Will poke around lens sources to see how Optics is used.
05:22:40 <f|`-`|f_> (At the very least an endo functor?)
05:22:42 <ski> (or rather, `Functor' classifies a specific type of functor)
05:29:22 * hackagebot ttrie 0.1.2 - Contention-free STM hash map  http://hackage.haskell.org/package/ttrie-0.1.2 (MichaelSchroeder)
05:33:55 <pacak> "FooT is a type function, and may not be injective"
05:34:32 <pacak> nullvoid8: It's either complaining that f is not matching f0 or gets back to complaining about polymorphic stuff once I add forall.
05:35:00 <pacak> On the othrer hand now I know what Optic and LensLike is :)
05:35:13 <nullvoid8> pacak: i'm afraid that this is as far as my knowledge goes, sorry :/
05:36:52 <nkar`> how do I print a value of a primitive type, like Int#?
05:37:13 <merijn> nkar`: The generic way or specifically Int#?
05:37:21 <pacak> nkar`: put it into I#
05:37:37 <nkar`> merijn: would be nice to know both :)
05:37:41 <merijn> The quickest/easiest way for just Int# is to use "I#", yeah
05:37:59 <merijn> I wonder if there's show isntances for primitive types..
05:38:22 <nkar`> merijn: :i Int# doesn't return anything
05:38:39 <nkar`> merijn: of course, I tried print before asking
05:39:47 <merijn> nkar`: I# is the constructor for Int, so using that will just let you use the Int instance of show
05:40:02 <merijn> nkar`: https://hackage.haskell.org/package/base-4.8.0.0/docs/GHC-Exts.html#v:I-35-
05:41:52 <nkar`> merijn: yeah, got it.  I wonder whether you know why the type of ># was changed from Int# -> Int# -> Bool to Int# -> Int# -> Int# in ghc 7.8
05:42:11 <merijn> nkar`: Low level optimisations
05:42:21 <merijn> nkar`: It means low level code didn't have to rebox
05:42:37 <merijn> nkar`: Which enabled some more LLVM optimisations, I think
05:42:59 <nullvoid8> merijn: thank you for introducing me to sigbovik
05:43:12 <merijn> nkar`: See "isTrue# :: Int# -> Bool"
05:43:15 <merijn> nullvoid8: :D
05:43:21 <nkar`> merijn: oh, it's already defined, nice!
05:43:28 <nkar`> merijn: was going to ask about that :)
05:44:00 <merijn> nkar`: Browsing GHC.Exts and GHC.Prim is educational ;)
05:44:17 <nkar`> there's a lot of stuff, so it's easy to miss :(
05:44:24 <merijn> Like, did you know about "currentCallStack :: IO [String]"
05:45:51 <nkar`> wow
05:49:43 <thorsten`> Is there a total version of "head" in the standard haskell library? (i.e. something of type: [a] -> Maybe a)
05:49:51 <pacak> nullvoid8: MultiParamTypeClasses  and FunctionalDependencies with help of LensLike did the trick.
05:50:06 <nullvoid8> pacak: sweet
05:50:08 <pacak> thorsten`: There are  two versions even.
05:50:23 <pacak> :t listToMaybe
05:50:27 <lambdabot> [a] -> Maybe a
05:50:49 <pacak> :t unsafeCoerce
05:50:50 <lambdabot> Not in scope: ‘unsafeCoerce’
05:51:05 * pacak pokes lambdabot
05:51:08 <srhb> :t readMay
05:51:09 <lambdabot> Not in scope: ‘readMay’
05:51:12 <c_wraith> ...  Please don't use unsafeCoerce as safeHead. :P
05:51:14 <srhb> Oh, that's not standard library.
05:51:23 <nullvoid8> I think you meant
05:51:32 <srhb> :t headMay -- yes
05:51:34 <lambdabot> Not in scope: ‘headMay’
05:51:35 <nullvoid8> actually, no I don't know what you meant
05:51:38 <thorsten`> pacak: thanks :-)
05:51:47 <nullvoid8> :t headMaybe
05:51:49 <nullvoid8> ?
05:51:49 <lambdabot> Not in scope: ‘headMaybe’
05:51:54 <nullvoid8> whelp
05:51:59 <ronh-> @hoogle headMay
05:52:00 <lambdabot> No results found
05:52:01 <srhb> @hoogle [a] -> Maybe a
05:52:02 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
05:52:02 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
05:52:02 <lambdabot> Prelude head :: [a] -> a
05:52:06 <ronh-> headMay is in the safe package
05:52:06 <srhb> Welp.
05:52:19 <pacak> @hackage acme-safe
05:52:19 <lambdabot> http://hackage.haskell.org/package/acme-safe
05:52:27 <aweinstock> :t find (const True)
05:52:29 <lambdabot> Foldable t => t b -> Maybe b
05:52:32 <pacak> thorsten`: This package defines a few more safe functions.
05:52:47 <srhb> pacak: ... :P
05:53:00 <srhb> pacak: I think recommending packages from acme should probably be done with a bit more warning.
05:53:06 <nullvoid8> I love the acme packages
05:53:26 <srhb> Same. safeCoerce :: a -> Maybe b; safeCoerce _ = Nothing
05:53:28 <srhb> Brilliant.
05:53:34 <nullvoid8> ooh, that one depends on acme-dont
05:53:38 <pacak> :t safeFromJust
05:53:39 <lambdabot> Not in scope: ‘safeFromJust’
05:53:49 <thorsten`> i guess safeFromJust = id
05:53:52 <srhb> pacak: You do know ACME packages are joke packages, right? :P
05:54:04 <srhb> thorsten`: Yep :D
05:54:09 <manju> I made a cabal sandbox and built a library
05:54:11 <manju> Hell
05:54:25 <aweinstock> https://hackage.haskell.org/package/acme-everything
05:54:42 <srhb> aweinstock: That one is probably the one that's most useful of them all :P
05:55:13 <aweinstock> I wonder if an approximate vertex-cover solver would be useful to resolve https://github.com/quchen/acme-everything/issues/1
05:56:04 <nullvoid8> aww, so it's not a minimal vertex covering?
05:56:15 <manju> I mean a package named hell. I get this error when I try to run http://lpaste.net/133496. Can anyone help ?
05:56:39 <manju> I've installed all the dependencies in the cabal sandbox, otherwise it wouldn't have built.
05:57:03 <pacak> srhb: Is it? acme-schoenfinkel is nice and useful in production as well...
05:57:08 <c_wraith> manju: did you build it with a sandbox?
05:57:14 <srhb> manju: Some packages are missing from other-modules probably
05:57:18 <srhb> Or modules rather
05:57:31 <srhb> pacak: Sure, if you want to have a longer namer for curry and uncurry :P
05:58:00 <aweinstock> nullvoid8: my understanding is that exact vertex-cover is NP-complete, but that a factor of 2 from optimal is efficiently findable
05:58:47 <srhb> pacak: But yes, it is. It has such useful packages as acme-don't (the inverse of do, does nothing.) and acme-year (current year defined as a constant - guaranteed side effect free!)
05:58:54 <nullvoid8> aweinstock: don't talk to me about complexities, I've done my algorithms & complexity exam, I don't need to know that anymore
05:59:03 <nullvoid8> :P
05:59:16 <Myrl-chan> I'm working with sockets, how do I find out where it crashes?
05:59:22 <srhb> pacak: It had a nasty bug until mid-february sadly.
06:00:05 <pacak> srhb: It should be acme-approximate-year....
06:00:10 <srhb> pacak: Indeed.
06:00:43 <Beardful> I made a GLUT Pythagorean-tree rendering program and I'd like to make a GIF out of that, anyone has ideas on how should I do that ?
06:00:49 <srhb> pacak: Anyway, you should check them all out, they're quite funny :P https://hackage.haskell.org/packages/#cat:ACME
06:01:36 <pacak> srhb: How do you think I got the info about acme-safe? :)
06:01:46 <srhb> pacak: Ah. :P
06:03:30 <manju> srhb, I built it in a sandbox. I did a cabal install --dependencies-only, I added the other-modules: line and ran it again.
06:03:37 <manju> c_wraith, yes.
06:03:57 <manju> I can see the shell-conduit and other things in the cabal-sandbox directory
06:04:22 <merijn> pacak: Pffft safeCoerce should've been cast
06:04:24 <merijn> :t cast
06:04:25 <lambdabot> (Typeable a, Typeable b) => a -> Maybe b
06:04:28 <srhb> manju: And you added Data.Conduit.Shell to that?
06:04:32 <srhb> manju: Same error?
06:04:43 <manju> Ah...
06:04:52 <kuribas> Hi, if I set convert to no-inline, the rewrite rule fires, but if I set it to INLINE, it doesn't fire: http://lpaste.net/133497
06:05:00 <c_wraith> manju: then the sandbox needs to be in scope when you run it.  try "cabal exec hell"
06:05:10 <kuribas> I like it to fire, and INLINE if it doesn't.
06:05:31 <manju> unrecognized command exec
06:05:49 <c_wraith> manju: then you need a newer version of the cabal binary
06:05:59 <manju> Ah...
06:06:50 <manju> c_wraith, how do I get that ?
06:07:09 <srhb> cabal install cabal-install -- usually
06:07:14 <pacak> > cast [1,2,3] :: Maybe Int
06:07:17 <lambdabot>  Nothing
06:07:21 <srhb> But I don't understand how you could create a sandbox without it
06:07:28 <srhb> Didn't exec come in at the same time?
06:07:37 <c_wraith> manju: https://www.haskell.org/cabal/download.html
06:07:41 <bananagram> > cast 1 :: Maybe String
06:07:43 <lambdabot>  Nothing
06:07:53 <c_wraith> manju: the "cabal-install tool" section
06:07:55 <bananagram> > cast "1" :: Maybe Int
06:07:57 <lambdabot>  Nothing
06:08:07 <manju> I think there is some weirdness in my world. There are 2 cabals and they are conflicting with each other
06:09:01 <zq> there can only be one
06:12:03 <hugosthlm> I was trying out Haskell but found that a lack of consistent package databases for different OS-es was creating serious trouble. The situation has improved
06:12:06 <hugosthlm> ?
06:12:19 <manju> hugosthlm, Heh...
06:12:27 <Pato> can anyone help me converting a classical recursive function to an anamorphism? I have almost everything done but I'm having trouble compiling it  
06:13:12 <pacak> Pato: Something with terrible libraries attached as well?
06:13:18 <hugosthlm> Has the situation improved?
06:13:46 <srhb> hugosthlm: Since when?
06:13:50 <pacak> hugosthlm: When did you last time looked at Haskell?
06:14:06 <srhb> hugosthlm: If before cabal sandboxes, then yes. There's also nix, though I don't know how great a help that is outside of Linux.
06:14:07 <Pato> pacak: Well, yes. It's similar to the catamorphism problem, except that in this one I can't even compile the code. The other one worked (but I had made a mistake testing it)
06:14:09 <srhb> hugosthlm: Other than that, no.
06:14:15 <hugosthlm> srhb: pacak: Some years ago
06:14:27 <srhb> hugosthlm: I think cabal sandboxes are about a year old or so? 
06:14:40 <srhb> hugosthlm: You can read up on that. Mind it's not a binary package database, if that's what you're searching for.
06:14:46 <hugosthlm> srhb: I saw the cabal sandboxes
06:14:51 <srhb> hugosthlm: And Windows support is apparently still very wonky at times.
06:15:01 <pacak> Pato: Show us your code then....
06:15:17 <pacak> As far as I know there's only one Windows user of ghc...
06:15:26 <srhb> :P
06:15:39 <srhb> I think there are plenty of users, just not a lot of ghc devs.
06:15:50 <Pato> pacak: 1 sec
06:16:06 <nullvoid8> srhb: on the windows note, I believe nix support for windows is slowly improving (there was a pr for cygwin support the other day)
06:16:15 <srhb> nullvoid8: How interesting :)
06:17:09 <hugosthlm> Why is Haskell not commersialized?
06:17:37 <hugosthlm> Haskell is great stuff, just in need of major investments?
06:17:48 <pacak> hugosthlm: It will make it's development more complicated
06:18:02 <pacak> Right now devs are doing whatever they thing is correct.
06:18:48 <manju> c_wraith, cabal exec hell, says cabal: The program 'hell' is required but could not be found.
06:18:54 <hugosthlm> F# seems like some kind of Haskell commersialization?
06:19:11 <srhb> hugosthlm: Hardly. 
06:19:12 <manju> I fixed everything. Install new cabal and pointed to the right cabal binary and everything.
06:19:34 <srhb> hugosthlm: F# is more like a do-it-all OCaml with .NET
06:19:51 <merijn> hugosthlm: You say "not commercialised", but plenty of companies are using haskell internally
06:19:54 <hugosthlm> Haskell will remain mainly an academic project?
06:20:06 <srhb> hugosthlm: It isn't now, so no, it probably wont become one again. :)
06:20:13 <lpaste> Pato pasted “anaPato” at http://lpaste.net/133500
06:20:17 <kuribas> Is F# popular?
06:20:22 <Pato> pacak: here it is http://lpaste.net/133500
06:20:35 <merijn> kuribas: Yes, among people "who would like to write haskell but are forced to do .net" :p
06:20:54 <kuribas> That's a very good reason :)
06:21:05 <kuribas> I'd much prefer F# over C#.
06:21:19 <merijn> kuribas: F#, like ocaml, is decent enough, but not as nice as haskell
06:21:31 <srhb> Lack of type classes is such a pain.
06:21:37 <merijn> So if the choice is F#/ocaml or C/C#/whatever it's a pretty good choice
06:21:54 <Pato> pacak: basically, the function constructs a tree of triangles, starting with a trinagle and the number of levels pretended
06:22:56 <hugosthlm> srhb: From where does the main development resources come now?
06:23:23 <srhb> hugosthlm: Volunteers all around the globe, some academics for the bleeding edge type stuff and some hired by Microsoft.
06:23:30 <srhb> Afair.
06:23:39 <srhb> hugosthlm: That's GHC though, not the ecosystem.
06:24:03 <merijn> srhb: The microsoft guys ARE academics
06:24:17 <merijn> MSR is as much academia as a university
06:24:19 <srhb> merijn: I didn't claim otherwise. :)
06:24:19 <hugosthlm> https://wiki.haskell.org/Hac_%CF%86#Sponsors
06:24:39 <srhb> I just wanted to point out that it's also industry sponsored
06:25:38 <srhb> hugosthlm: Anyway I doubt any of this relates very much to the shortcomings of package management.
06:25:54 <pacak> Pato: Are you trying to create any specific structure?
06:25:55 <manju> cabal exec hell says failed to load interface for 'Hell'
06:25:56 <hugosthlm> I wish there was some main choice for a functional language and Haskell seems like the candidate
06:26:05 <srhb> manju: Did you do as I suggested with the other-modules?
06:26:06 <manju> Does anyone know how to fix this ?
06:26:16 <srhb> manju: Can you show us the cabal file?
06:26:23 <manju> srhb, I put in other-modules: in the cabal file.
06:26:30 <srhb> manju: Did you list the actual modules?
06:26:34 <Pato> pacak: I'm trying to create a TLTree, that is defined in the beggining of the code
06:26:48 <pacak> Pato: I mean - any specific shape?
06:27:39 <pacak> Pato:   anaTLTree (\case x | x  Left 0 ; x -> Right (x - 1, (x - 2, x - 3))) 3 
06:27:44 <manju> srhb, Is it like this (example) other-modules: Shell.Conduit ?
06:27:52 <srhb> manju: Yes.
06:28:10 <Pato> pacak: basically, only the bottom level has leaves. We need to construct some triangles, starting from only 1
06:28:11 <srhb> manju: And then rebuild the whole thing when you've added the missing ones
06:29:10 <pacak> Well, my examples makes some leaning tree with bunch of zeros in leaves.
06:29:18 <manju> srhb, It says can't find source for Shell/Conduit in src/, dist/build/autogen
06:29:33 <srhb> manju: Was that the module name that was missing? (No.)
06:30:34 <Pato> pacak: the input would be something like ((0,0),2) 2 . That means the triangle with the vertice in (0,0), with side 2 and we want to generate 2 levels ofother triangles (applying some basic math)
06:30:47 <manju> srhb, Data.Conduit.Shell
06:30:53 <srhb> manju: Right :)
06:31:31 <srhb> manju: If that doesn't help it would seem something is missing from build-depends, or you're having some really quirky problem I haven't seen before.
06:32:26 <srhb> manju: (I would actually assume it's from shell-conduit)
06:32:27 <arturaz> Anyone knows a good material on arrows? They're kind of a mystery to me :|
06:32:38 <manju> srhb, Is it needed to add the .cabal-sandbox directory inside the cabal file ?
06:32:38 <Pato> pacak: Also, I'm getting "parse error on input ‘case’" when trying out the solution you pasted
06:32:47 <pacak> Pato: -XLambdaCase
06:32:56 <srhb> manju: No, assuming you're running a sandbox aware cabal binary, it just works.
06:33:01 <merijn> arturaz: Hughes' Programming With Arrows?
06:33:14 <merijn> arturaz: Although I'd say Arrows are fairly out of fashion
06:33:28 <srhb> manju: Check if shell-conduit is in build-depends by the way :)
06:33:39 <arturaz> merijn, out of fashion? :)
06:33:59 <manju> srhb, It is...
06:34:05 <byorgey> it's fashionable to put arrows in various complicated generic theoretical frameworks
06:34:07 <merijn> arturaz: Turns out arrows are not as useful an abstraction as was hoped
06:34:10 <srhb> manju: Then you're indeed having a weird issue.
06:34:12 <byorgey> it's just not fashionable to actually use them =)
06:34:12 <manju> srhb, This problem does not occur if I don't have sandboxes
06:34:19 <srhb> manju: o_o
06:34:26 <shiona> damn you and your faShionable highlights
06:34:37 <Pato> pacak: where do I use that?
06:34:41 <merijn> shiona: Get a better irc client!
06:34:42 <manju> srhb, I have another machine where I forgot to sandbox and this problem does not exist in that.
06:34:43 <byorgey> shiona: hahaha
06:34:52 <pacak> {-# LANGUAGE LambdaCase
06:34:52 <pacak> #-}
06:34:58 <srhb> manju: No idea what's up with your current machine then. Have you tried on it without the sandbox?
06:35:15 <manju> srhb, I don't want to :-/
06:35:15 <shiona> merijn: Unfortunately I live in a country in which nouns have inflictions, so I cannot use --fullword or whatever that is
06:35:43 <OutlawStar> hi all, can any one tell me how I setup cabal to deploy a config file along with its executable?
06:35:43 <shiona> I guess I could make that one exclusion
06:35:56 <srhb> manju: OK, but I suspect something worse than just sandboxing issues is at work.
06:36:07 <srhb> manju: Though honestly I've never seen a problem like that, so uncharted waters and all that.
06:36:07 <merijn> OutlawStar: Does it need to be modifiable?
06:36:15 <OutlawStar> merijn: yes
06:36:29 <srhb> manju: Which cabal version did you build it with by the way?
06:36:30 <manju> srhb, I understand. I am a rank newbie and this is all super new to me.
06:36:33 <merijn> OutlawStar: Then I don't really know of a way to do that
06:36:34 <byorgey> shiona: out of curiosity, I grepped /usr/dict/words for 'shiona' and the only hits were (un)?fashionabl(e|y)
06:36:40 <manju> 1.22.30 or something.
06:36:50 <byorgey> shiona: so just putting in that exception ought to cover it =)
06:36:51 <srhb> manju: Did you try frying the sandbox and going again?
06:37:00 <manju> srhb, Hmmm...
06:37:03 <manju> rm -rf ?
06:37:18 <srhb> manju: cabal sandbox delete
06:37:26 <manju> srhb, oops
06:37:46 <mauke[> byorgey: fashion
06:37:47 <Pato> pacak: do I have to add that to the code? I'm confused
06:37:51 <mauke[> oh, "a"
06:37:52 <OutlawStar> merijn: oh... so whats the standard way to deploy config files with a haskell binary? As process of the deployment?
06:38:06 <merijn> OutlawStar: I'd just write a deployment script?
06:38:10 <srhb> manju: Also, when you say "or something" did you actually try cabal --version ?
06:38:32 <manju> srhb, 1.22.3.0
06:38:32 <OutlawStar> merijn: ok thats fine, just wasn't sure if cabal had something built in. Thx
06:38:37 <srhb> manju: OK.
06:38:42 <manju> Sorry :-p it was doing some build
06:38:47 <byorgey> mauke[: fashion does contain a permutation of shiona but I doubt shiona is highlighting on any permutation
06:38:53 <lpaste> pacak revised “anaPato”: “No title” at http://lpaste.net/133500
06:38:57 <mauke[> byorgey: right :-(
06:39:02 <byorgey> =)
06:39:06 <srhb> manju: I'm just blindly throwing ideas at you by now, by the way. :P Feel free to quit anytime and consider your computer a lost cause.
06:39:08 <shiona> byorgey: :D
06:39:12 <pacak> Pato: http://lpaste.net/133500 
06:39:13 <mauke[> cushionable?
06:39:25 <manju> srhb, I am scared of reinstalling.
06:39:27 <shiona> yea, (un?)fashionable has been the only word that has caused unwanted highlights
06:40:01 <pacak> Apparently it's not only possible to fortran in any programming language, but also to lisp in haskell.
06:40:04 <srhb> manju: I guess you can keep asking in here and hope for a revelation. Or perhaps it's suited for a reddit thread.
06:40:10 <byorgey> fasionable is actually a strange word.  It does not mean "able to be fashioned".
06:40:46 <Pato> pacak: oh, I see. I'll check it out
06:40:46 <byorgey> mauke[: oh, good one
06:40:56 <manju> srhb, I am going home now. I hope it doesn't come to a reddit thread.
06:41:08 <srhb> manju: Heh, good luck.
06:42:12 <manju> srhb, I am mad because it builds and doesn't run.
06:42:51 <srhb> If only anger fixed such issues. :-)
06:44:04 <pacak> Pato: Did you got my last message?
06:44:22 <pacak> http://lpaste.net/133500
06:44:57 <Pato> pacak: yes, I'm trying to understand how to make the anaFoo you gave work with the anaTLTree (trying to "port" the gene")
06:45:22 <manju> srhb, Is it possible install source inside the cabal sandbox
06:45:36 <srhb> manju: What do you mean "install source"
06:45:51 <pacak> Pato: It is working
06:46:08 <manju> There is no package named source ?
06:46:21 <pacak> Pato: anaTLTree anaFoo (((0, 0), 1, 2)
06:46:48 <pacak> Or at least it typechecks
06:48:27 <Pato> pacak: oohh, I see. It works now
06:48:48 <Pato> pacak: Thank you very,very much for your help. 
06:48:59 <srhb> manju: Not to my knowledge
06:49:18 <srhb> manju: But installing into a sandbox is as easy as being in the directory of the sandbox and writing cabal install packageName
06:49:28 <manju> srhb, Wow it worked!
06:49:34 <srhb> manju: Magic.
06:49:48 <manju> srhb, ...and I have no idea why.
06:49:55 <srhb> manju: Did you recreate the sandbox?
06:50:03 <manju> srhb, I tried repeating the same set of commands. 
06:50:05 <manju> srhb, Yes.
06:50:14 <srhb> Oh well.
06:50:27 <srhb> Thank the cabal gods and don't ask too many questions. :-)
06:51:03 <manju> srhb, :-p
06:51:16 <manju> Alright. Good night, I am off for the day.
06:51:41 <srhb> o/
06:55:40 <mjrosenb> Is there a reason that poke doesn't take in an extra value?
06:56:38 <mauke[> @hoogle poke
06:56:39 <lambdabot> Foreign.Storable poke :: Storable a => Ptr a -> a -> IO ()
06:56:39 <lambdabot> Foreign.Marshal.Array pokeArray :: Storable a => Ptr a -> [a] -> IO ()
06:56:39 <lambdabot> Foreign.Marshal.Array pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()
06:56:47 <merijn> mjrosenb: What extra value would it take?
06:57:47 <mjrosenb> merijn: a tag saying which part of a tagged union it is
06:58:04 <merijn> mjrosenb: How would that be relevant?
06:58:05 <geekosaur> that's something a higher level tool would deal with
06:58:11 <geekosaur> tagged unions are not visible at this level
06:58:15 <mjrosenb> because it is being stored external to the actual structure.
06:58:26 <merijn> mjrosenb: if 'a' is a tagged union than Storable should take care of that
07:00:31 <mjrosenb> so in C, I have typedef union { long a; char *b} Foo; and in haskell, data Foo = A CLong | B CString;
07:00:57 <mjrosenb> and in C, there is a bool in the structure that has a pointer to a Foo saying if it is a long or a char*
07:01:10 <mjrosenb> how would I write a Storable instance for Foo?
07:02:58 <nshepperd> 'poke ptr (A 3)' should work fine
07:03:45 <mjrosenb> nshepperd: and how about peek?
07:04:06 <dylukes> mjrosenb Well, you've created a problem for yourself, because your Foo type is ambiguous alone.
07:04:46 <nshepperd> yes, peek doesn't work, because the union part of a tagged union doesn't have enough information
07:04:49 <dylukes> It *has* to be embedded in the containing struct to know what it is.
07:05:17 <nshepperd> a Storable instance for the tagged union including the tag would work
07:05:37 <dylukes> Why not just use Either <=> tagged union? 
07:05:59 <athan> Does Algorithm W only solve the most-general type, going top-down for the expression? I'm trying to force an operator to choose a monomorphic type for it's constituents, but it doesn't seem possible in the current design. Any tips?
07:06:03 <dylukes> You'd have to derive/write a couple instances...
07:06:26 * mjrosenb did not create this problem, the library I'm trying to make bindings for had it already.
07:06:27 <dylukes> but it wouldn't be very difficult to marshal an Either to a tagged union
07:07:10 <mjrosenb> dylukes: it has like 10 branches, I simplified because I didn't want to type that all here.
07:07:13 <dylukes> And that's a more natural representation.
07:07:17 <dylukes> Ah okay.
07:12:28 <mjrosenb> I think I am going to write 10 strable instances, and 10 newtype wrappers :-/
07:21:23 <GAYYYYY_LMAO> https://www.dropbox.com/sh/r17rvj94koye033/6psOmYvn1B
07:22:42 <frerich> *plonk*
07:29:35 * hackagebot datetime-sb 0.2.4 - Utilities to make Data.Time.* easier to use.  http://hackage.haskell.org/package/datetime-sb-0.2.4 (jsl)
07:34:18 <athan> mer. type inference is hard ._.
07:40:34 <srhb> athan: Generally impossible, in fact!
07:42:40 <tdammers> Specifically impossible, even!
07:47:33 <edwardk> Drafting up a new post, can i get some eyeballs on the typos? I'm expecting a bunch: https://www.fpcomplete.com/tutorial-preview/6434/yjxLbonCEH
07:49:13 <athan> .-.
07:51:14 <bitemyapp> edwardk: I couldn't find any typos.
07:51:18 <bennofs> edwardk: "we can derive that definitions"
07:51:32 <bitemyapp> I figured I'd missed something, my fault for rapid-scanning :P
07:51:50 <edwardk> bennofs: thanks, fixed
07:52:05 <edwardk> found a typo in the existential equations for cofree
07:53:08 <bennofs> edwardk: hmm, is it just me or does that same sentence still miss something? "derive ... from more direct definition" sounds wrong to me
07:53:26 <edwardk> probably, let me go look
07:53:48 <YellowOnion> Is using Yesod.Auth.OAuth2 in a non-Yesod app sane?
07:54:00 <chelfi> edwardk: not sure because english is not my main language, but "[...] is a functor[...] that we can equip *it* with"
07:54:18 <bergey> Yes, I was about to say the same as chelfi.
07:54:36 <chelfi> under "Distributive Functors, Represent!"
07:54:39 <edwardk> chelfi: its not you, its really a typo =)
07:57:25 <edwardk> this was mostly written while trying to contort myself in a plane seat
07:57:41 <frerich> edwardk: In 'Doing Two Things at Once' you wrote 'This is just the definition we used to use for the foldl-style Moore machine, but not instead of using functions from our state, we just use representable functors that have our states as their representations.' -- should that 'not' be 'now'?
07:57:56 <edwardk> yep
07:58:04 <rdesfo> Hello, I'm using MFlow as a web interface for a multiple choice questions.  I want it to reset the number of correct answers when I click menu.  Can some one tell me what I'm doing wrong?
07:58:09 <bennofs> edwardk: for me the comma in "In category theory a representable functor 'f', is a functor for ..." breaks the reading flow
07:58:11 <lpaste> rdesfo pasted “MFlow” at http://lpaste.net/133503
07:58:55 <edwardk> bennofs: fixed
07:59:01 <edwardk> frerich: fixed
07:59:38 <dmj`> rdesfo: can you paste the setSessionData function
08:00:55 <edwardk> i realize it is a bit all over the place in terms of topic and probably should have been broken up into smaller more bite-sized pieces
08:01:00 <edwardk> but tomorrow i'm at zurihac
08:01:15 <edwardk> and i don't want to have to try to juggle a slower release schedule
08:01:38 <rdesfo> dmj`:   (r, n) <- page $ do;              n <- getSessionData  `onNothing` return (0 :: Int) -- get Int data from the session;...
08:02:30 <bennofs> edwardk: so every Distributive functor is also a Representable one? 
08:02:43 <edwardk> bennofs: there aren't any that can't be
08:02:53 <chelfi> ". exponents become products, products become sums, etc." I think exponents should be capitalized
08:03:02 <edwardk> chelfi: yep
08:04:13 <edwardk> bennofs: you can even define ghc generics code to produce a representation
08:04:37 * hackagebot th-typegraph 0.17.1 - Graph of the subtype relation  http://hackage.haskell.org/package/th-typegraph-0.17.1 (DavidFox)
08:05:22 <bennofs> edwardk: since Distributive is 'Co-Traversable', is there a similar class for like that is to Traversable like Representable is to Distributive?
08:06:04 <edwardk> nope
08:06:09 <edwardk> there is a subtle asymmetry
08:06:29 <edwardk> we have applicatives but no coapplicatives, etc.
08:08:41 <srhb> edwardk: I just want to contribute with what I feel I have the necessary level to: I really like the section titles in all your articles. :-)
08:08:52 <edwardk> there could be a stronger class that says 'IsLeftAdjoint' basically
08:08:53 <edwardk> hah
08:09:43 <edwardk> srhb: i'm not happy unless i sneak at least 2 groan-worthy puns into my section titles
08:09:51 <bennofs> edwardk: under "Representable Machines": "namely that both our unknown representable functor f": shouldn't that be 'k' ?
08:09:53 <srhb> :-) Important priorities.
08:10:06 <joobus> edwardk: can you repost the link you all are talking about?
08:10:07 <phaazon> hey
08:10:15 <phaazon> what is the package for indexed monads?
08:10:19 <edwardk> bennofs: likely. i switched from f to k halfway through
08:10:24 <phaazon> I saw them in several packages
08:10:28 <edwardk> joobus: https://www.fpcomplete.com/tutorial-preview/6434/yjxLbonCEH is the draft url
08:10:31 <merijn> srhb: Just do what I do an pedantically correct him on obscure cultural information ;)
08:10:33 <joobus> edwardk: thanks
08:10:39 <frerich> edwardk: Grepping for '/O' found a place where the markup seems to be a little off.
08:10:49 <srhb> merijn: Aha, nice trick!
08:11:06 <merijn> srhb: In this case obscure capitalisation rules for Dutch names :p
08:11:13 <srhb> :-)
08:11:58 <frerich> edwardk: Similarly, I'm not sure whether 'Hask^op' is actually what you meant to write, or whether that's markup not being rendered correctly.
08:12:01 <phaazon> hm
08:12:07 <phaazon> I guess I’ll go with the package indexed
08:12:09 <phaazon> sounds good
08:12:17 <edwardk> i hadn't figured out the superscript markup by then. i suppose i could superscript it
08:12:26 <edwardk> phaazon: indexed is the current official home of the idea
08:12:37 <phaazon> cool, I’ll use that then
08:12:38 <phaazon> thanks :)
08:12:39 <edwardk> i'll eventually steal it back and ship some newer indexed code
08:12:48 <edwardk> (i already asked for permission)
08:12:59 <edwardk> as it was code from category-extras in the first place
08:13:12 <phaazon> yeah
08:13:15 <phaazon> and it’s a bit confusing
08:13:24 <phaazon> (IxApplicative in Monad.Index doesn’t make sense)
08:15:58 <edwardk> before i can ship https://github.com/ekmett/multicategories/blob/master/Multicategories.hs i need to ship an updated https://github.com/ekmett/indexed or something
08:16:10 <bennofs> edwardk: also in the same section, " some choices of f might be suitable for memoization" should be k too I think
08:17:00 <edwardk> fixed
08:17:14 <edwardk> any thoughts on content as you go?
08:17:57 <bennofs> actually, I'm not sure about the last. Do you want to memoize the 'k (Rep k)' when applied to different "states", or the whole 'a -> ...' which was previous f?
08:18:56 <edwardk> that last thing was really a `k`.
08:19:30 <bennofs> ok
08:19:34 <edwardk> (a -> k (Rep k)) -- is basically taking a -> Endo (Rep k)
08:19:40 <edwardk> but in a form where it can be memoized
08:19:52 <NemesisD> has anyone run into an issue where you've got a typeclass with associated types and functions, and no matter what, you can't convince ghc which instance to use, instead getting errors about your associated type being "a type function and may not be injective"?
08:20:34 <merijn> NemesisD: Instance selection can't depend on the associated type, which is what I'm guessing is what's going wrong
08:20:43 <merijn> NemesisD: Can you paste your class' type signatures?
08:20:52 <edwardk> NemesisD: given a type family,   F a ~ F b  doesn't tell you a ~ b. try refactoring to use a data family or mangle your combinators to take a proxy for the type args it doesn't like, etc.
08:24:48 <dan64> I have a cabal Haskell library that uses FFI. The C code requires a single call of an initialization function. Is there some way to configure cabal to call this when the library is loaded (rather than having users of the library manually call the init function once)?
08:25:49 <merijn> dan64: You can't really do anything "on loading" in any language
08:26:39 <NemesisD> here's roughly where i'm at http://lpaste.net/7251777066381606912
08:26:45 <srhb> dan64: The trick is usually some unsafePerformIO magic to ensure it only happens once
08:27:23 <merijn> NemesisD: "allocateState :: IO (HandlerState a)" <- this is impossible
08:27:39 <merijn> NemesisD: You are trying to make it infer 'a' from 'HandlerState a' which isn't possible with type families
08:27:49 <dan64> merijn, thanks
08:27:55 <dan64> srhb, thanks
08:27:56 <merijn> NemesisD: Because 'HandlerState Int' and 'HandlerState Bool' might both produce 'Char' as type
08:28:12 <merijn> NemesisD: And then given 'Char' it's impossible to decide which type 'a' produced it
08:28:24 <merijn> NemesisD: You need a proxy on allocateState
08:28:24 <NemesisD> ah. yeah maybe its time to abandon this approach. the type family was kind of a hack
08:28:28 <zaquest> merijn, i think its possible in python
08:28:58 <NemesisD> merijn: meaning allocateState :: Proxy (HandlerState a) -> IO (HandlerState a)?
08:29:12 <merijn> NemesisD: No, "Proxy a -> IO (HandlerState a)"
08:29:25 <merijn> NemesisD: That was it unambiguously knows which 'a' so it can select the right class instance
08:29:34 <merijn> s/was/way
08:29:43 <merijn> zaquest: I was refering to loading in the dynamic library/DLL sense
08:30:25 <merijn> dan64: You could try and have a global "initialised :: IORef a" and check that on every operation
08:30:42 <merijn> dan64: The other solution would be awful hacks like, I think, used in process/network
08:30:45 <mitchty> you kinda can do constructor/destructor with attributes
08:30:50 <mitchty> at least in c
08:31:15 <merijn> mitchty: You mea C++
08:31:15 <mitchty> aka void somefunc (void) __attribute__ ((constructor)); and it will get called before main()
08:31:22 <mitchty> merijn: no 
08:31:34 <merijn> That's not C, that's some compiler specific extension
08:31:46 <mitchty> true but it works in gcc/clang
08:32:41 <NemesisD> merijn: that did it. thanks!
08:32:46 <mitchty> I use it for c things i build where libraries need initialization
08:33:41 <nkar`> kosmikus: opened a pull request.  in the pr message, I've mentioned the existing warnings, do you have time to give it a quick look to suggest a proper fix?
08:33:43 <merijn> NemesisD: The simple explanation is that GHC can always infer the result of applying a type family to it's arguments, i.e. turn 'a' into 'Foo a'. But GHC can't generally turn 'Foo a' into 'a', which it needs to determine which instance to use
08:34:39 <merijn> Well, I guess not so much infer as "produce" or some other term, but you get the idea
08:34:51 <mitchty> ends up just putting the functions in ctors in an elf object really
08:41:52 <nkar`> kosmikus: also, is exporting SafeInt(..) a mistake?  how about moving the type to the internal module?  this would allow to hide the value constructor in the main module but expose it in the internal one.
08:44:29 <ocramz> hey there
08:44:51 <ocramz> anyone here played with ForeignPtr ?
08:46:00 <gcganley> for a very short time while trying to marshal between C# and Haskell but i never got used to it. Working with arrays of arrays got far to complex for myself. I wish i could help
08:46:50 <ocramz> gcganley : thanks anyway :)
08:52:56 <c_wraith> ocramz: I've done a little work with ForeignPtr
08:53:19 <c_wraith> ocramz: it's just a wrapper for Ptr that runs finalizers after the Haskell Ptr value gets gc'd
08:53:47 <c_wraith> ocramz: *usually* used for freeing memory allocated via the FFI but whose lifespan is controlled from the haskell side
08:56:41 <brycelane> Is anybody using servant with authentication/authorization? It seems its not natively supported, but there is a  repo demonstrating relevant work, HaskellSGMeetup2015. Anybody know if other examples?
08:59:28 <ocramz> c_wraith : yes exactly; I am wrapping some C struct create/destroy function pairs. I would like to understand how does the `withForeignPtr` bracket work
09:00:05 <c_wraith> ocramz: it more or less extracts the Ptr value, calls your action with it, then calls touchForeignPtr, then returns the result of your action.
09:00:18 <c_wraith> ocramz: the touchForeignPtr is the important part.
09:01:06 <c_wraith> ocramz: it's got a small bit of associated compiler magic.  It's a no-op, except it guarantees it can't be re-ordered or elided, so the ForeignPtr object will remain in memory so long as there's an outstanding touchForeignPtr.
09:01:17 <c_wraith> ocramz: which means that finalizers won't run too early
09:02:00 <nkar`> say, if I have a wrapper around Int called Foo, what is the benefit of defining the Eq instance via eqInt instead of ==?
09:02:02 <zq> :t guard
09:02:04 <lambdabot> Alternative f => Bool -> f ()
09:02:15 <zq> you guys justhad to make it harder to understand
09:02:23 <c_wraith> :t eqInt
09:02:27 <lambdabot> Not in scope: ‘eqInt’
09:02:47 <ocramz> c_wraith : which is great; let's say I don;t use `touchForeignPtr :: ForeignPtr a -> IO ()` but want to do something else with the result
09:02:52 <c_wraith> nkar`: I suspect eqInt is a lower-level thing that has a name just so that Int's Eq instance can be in terms of it.
09:02:59 <adarqui> hi everyone. wondering if anyone has an idea on this: I'm using hedis (haskell redis library). I connect inside of a "catches", ie, catches (do connectToRedis...) [Handler exceptionHandler] .. so, everything is fine.. then I shut down the redis server and trigger and event which writes to redi. I then see "ConnectionLost" printed to the screen. However, it should be caught in my exception handler via catches.. If i send trigger another event which writes to redis, m
09:03:15 <c_wraith> nkar`: and isn't really intended to be used for anything else.  Not that it wouldn't work, but it's less familiar and no better.
09:03:24 <nkar`> c_wraith: yes, it's a ghc thing of type Int -> Int -> Bool
09:03:56 <c_wraith> ocramz: What sort of problem are you anticipating?
09:04:01 <nkar`> c_wraith: kosmikus uses it in safeint, and I wonder why not just use ==
09:04:23 <adarqui> hedis is doing this to throw the connection lost exception:     errConnClosed = throwIO ConnectionLost
09:04:24 <c_wraith> nkar`: I can't think of a reason for doing so
09:04:43 <c_wraith> nkar`: but a reason might exist
09:05:49 <ocramz> c_wraith : I would just like to understand the general control structure: let's say I have a few `withX (X x) = withForeignPtr x`
09:06:37 <ocramz> c_wraith : I use c2hs to generate part of the bindings, but I don't get where does the initializer come into play
09:07:04 <c_wraith> adarqui: your first statement got truncated at "If i send trigger another event which writes to redis,"
09:07:50 <adarqui> ah thanks
09:07:54 <Myrl-chan> I lost count on how many days I've been trying to understand category theory.
09:07:57 <c_wraith> ocramz: wherever the ForeignPtr gets created, it's responsible for calling the initializer
09:08:23 <adarqui> If i send trigger another event which writes to redis, my exception handler will be caught.. So it seems that the "first one" never catches the exception. does that make any sense?
09:09:01 <adarqui> I think I may be noobing it up though, I might need to specify IO ConnectionLostException somehow .. 
09:09:39 <adarqui> nah i dno
09:10:53 <c_wraith> ocramz: well, when the ForeignPtr gets created, it's responsible for setting up appropriate finalizers for wherever the Ptr came from.  If it came from an initializer, creating the ForeignPtr should add a finalizer that calls the correct native destructor.
09:11:02 <Imagine> Suppose I'm reading a long string of numbers from a file, so that I have them as a string. How could I go about either a). Making this string into a number or b). making this string into a list of single digit numbers? (I know how to go from a to b, but not so much how to do a)
09:11:48 <c_wraith> :t digitToInt
09:11:50 <lambdabot> Char -> Int
09:12:01 <c_wraith> > map digitToInt "12345238764"
09:12:05 <lambdabot>  [1,2,3,4,5,2,3,8,7,6,4]
09:12:15 <Imagine> ooh awesome
09:12:16 <Imagine> thanks
09:12:16 <c_wraith> Imagine: digitToInt is in Data.Char, I believe
09:12:27 <Imagine> thanks
09:12:53 <Imagine> I'd been looking for Num a => [Char] -> [a] on google with no luck
09:13:35 <ocramz> c_wraith : hmm yes, I'm trying to come up with a concrete example right now. What TZ are you in? I'm on CET
09:13:55 <c_wraith> ocramz: PDT (GMT-7)
09:14:55 <Imagine> wait c_wraith -- since I'm dealing with IO strings, can I still do digitToInt or do I have to do something first? I'm not too familiar with monads and IO and the like yet
09:14:57 <c_wraith> Imagine: a helpful pointer, then.  You were looking for an operation on a list that handled each entry independently and produced a new list.  If you recognize that as a map operation, you can just search for things that operate on the elements individually.
09:15:02 <ocramz> c_wraith : ok, this might get a bit laborious :D
09:15:28 <c_wraith> Imagine: How familiar are you with do notation?
09:15:41 <Imagine> I've read the LYAH page
09:15:45 <Imagine> so I sorta know whats going on
09:16:05 <Imagine> do I just do the same thing
09:16:08 <Imagine> but with <-?
09:16:36 <Imagine> wait actually I just realized
09:16:48 <Imagine> :t (<-)
09:16:50 <lambdabot>     parse error on input ‘<-’
09:16:50 <lambdabot>     Perhaps this statement should be within a 'do' block?
09:17:03 <Imagine> That extracts the string from the IO string right?
09:17:04 <adarqui> it's odd, in my 'server' i can catch ConnectionLostException, but not in the client.. baffled.. ok lunch then i'll try and figure this out
09:17:07 <adarqui> pc
09:17:17 <c_wraith> Imagine: http://lpaste.net/2188285966161018880
09:17:22 <nkar`> c_wraith: the only reason I can think of is that a specialized version compiles faster.  I guess I'll just mimic the current approach.
09:17:33 <nkar`> and ask for comments when I send a pr
09:17:42 <Imagine> perfect thanks!
09:19:22 <c_wraith> Imagine: <- is syntax, not an operator.  (one of the few bits of actual syntax) It doesn't exactly "extract" the String from an IO String, because "extract" isn't quite the right word.  But it does guarantee that if the thing on the left has a type of the form `m a', the value on the right has type `a'
09:19:58 <Imagine> that makes sense
09:20:10 <Imagine> can you just use it for IO?
09:20:14 <Imagine> or also for monads in general?
09:20:18 <c_wraith> Imagine: you can use it for all monads.
09:20:19 <S11001001> Imagine: latter
09:20:47 <Imagine> Do monads have to be in a do-block in general then?
09:21:02 <c_wraith> Imagine: don't worry too much about that yet, though.  Monad is pretty abstract, and not all that important for actually writing haskell code.  (You'll understand it when you get an unconscious feel for the abstraction)
09:21:20 <Imagine> alright, sounds good. 
09:21:26 <c_wraith> Imagine: no, other way around.  do blocks desugar to code that (usually) requires a Monad instance
09:22:46 <Imagine> out of curiosity, how long did it take you to get comfortable with Haskell/what were your reasons for doing so? 
09:23:02 <ion> @undo do { fileContents <- readFile "foo.txt"; let { ints = map digitToInt fileContents }; print ints }
09:23:02 <lambdabot> readFile "foo.txt" >>= \ fileContents -> let { ints = map digitToInt fileContents} in print ints
09:23:36 <Imagine> because for me I feel like its been far far harder than any other language I've picked up
09:23:46 <c_wraith> I started using it professionally, actually.  Took me about a week to get comfortable enough with the syntax that I felt like I had a chance of doing the right thing.  Took me a lot longer to feel like I thoroughly understood the language, but that's just because it's so different from everything else I ever used.
09:24:11 <ion> Imagine: You have been picking up languages that are similar to each other then. That’s why they have been easier to learn.
09:24:16 <c_wraith> I also feel like I understand the structure of programming way better because I've learned it.
09:24:23 <JoshieAS> c_wraith: did you start out entry level or did you have previous experience in another language?
09:24:34 <Imagine> ion - I mean even comparing to the first language I learned
09:24:45 <c_wraith> JoshieAS: had 20 years of experience in various other languages first.
09:24:48 <Imagine> But maybe I don't remember well
09:24:56 <bergmark> Imagine: i got comfortable after contributing to open source projects, i did it instead of writing my thesis!
09:25:52 <Imagine> So it definitely seems that it'll take a while
09:26:14 <Imagine> but from what I've seen so far it looks very interesting. Everything I've been trying to do feels sorta like a puzzle, which I kinda like
09:26:19 <c_wraith> I think it's worth the effort.
09:26:28 <JoshieAS> Imagine: I fell in love with Haskell after taking a course on SML
09:26:38 <c_wraith> But of course, there's a bit of selection bias there.  I wouldn't be here answering questions if I didn't think it was worth it. :)
09:26:42 <JoshieAS> I really enjoyed case expressions/guards
09:27:01 <Imagine> Is there any particular reason you chose Haskell over, say, Lisp?
09:27:11 <c_wraith> I like types.
09:27:28 <c_wraith> In particular, I like the compiler remembering things so I don't have to.
09:27:39 <bergmark> Imagine: i did lisp before that, hard to read, no typechecking
09:28:44 <Imagine> hmmm okay okay
09:28:55 <Imagine> do you know anybody who learned haskell as their first language?
09:29:06 <c_wraith> Also, Haskell's type system is smart enough that the compiler can actually write a bit of code for you.  That's more than just finding errors.
09:29:39 <bergmark> i know several universities that start with Haskell, but my friends there all programmed before that
09:29:39 <c_wraith> (type class resolution, especially when it's recursive, counts as writing a bit of code in my book)
09:29:51 <bergmark> we started with common lisp :'(
09:29:54 <Imagine> because my younger brother wanted to learn something and I might suggest Haskell so that we can learn it together, but it might be tough as a first language
09:30:11 <c_wraith> bitemyapp: you around?  This is your sort of conversation
09:30:14 <Imagine> really? I thought most/all universities started with Java/Python!
09:30:36 <mitchty> back in my day we were taught c++ and c, and we liked it
09:30:49 <mmachenry1> Imagine: I think it's actually a pretty good first language. 
09:30:50 <Imagine> My university doesn't really offer functional programming classes, as far as I'm aware. Maybe I just haven't looked far enough
09:30:51 <adarqui> b
09:30:54 <bergmark> we were also taught c++ and c because "the industry" demanded it
09:31:06 <mitchty> i got in just before java became a thing
09:31:12 <mitchty> kinda glad on that
09:31:19 <Imagine> mmachenry1 - I guess because everything else seems easy after it? 
09:31:58 <c_wraith> Imagine: actually, if I've been doing a ton of haskell, ruby and python seem incomprehensible for a short bit immediately after. :)
09:32:06 <mmachenry1> Imagine: No really it's not hard to get started in Haskell and a lot of the advanced features are not necessary in a beginning curriculum. 
09:32:13 <c_wraith> Imagine: if Haskell is the first thing you learn, mutation is a hard new concept
09:32:13 <bergmark> Imagine: i think you will find you can apply a lot of haskell concepts in other languages, not as much the other way around
09:32:16 <haasn> Imagine: gotta go through hell to be able to really appreciate the level of comfort you have normally
09:32:21 <Darwin226> Hey guys, is there a way to have a project wide import?
09:32:33 <haasn> that's why we start with MIPS assembly
09:32:53 <c_wraith> Darwin226: for executables, yes
09:33:03 <haasn> MIPS assembly, C and Java
09:33:08 <bergmark> Darwin226: with ghc-710/cabal-1.22 and https://github.com/hvr/base-noprelude
09:33:22 <Darwin226> c_wraith: My project is an executable, but why only executables?
09:33:23 <haasn> I'm surprised they didn't throw PHP into the mix just to give us a true trial by fire
09:33:28 <Imagine> ooh, sounds like fun. I definitely want to learn it well then. Sounds like fun!
09:33:32 <mmachenry1> There's less boiler plate than Java. Stick to the purely functional subset (where you should be on most beginning curriculums anyway) and it's a dead simple language. Compared to Python it's going to prevent a lot of frustration later by turing it into a steeper learning curve, which is types
09:33:39 <Darwin226> bergmark: what about 7.8?
09:34:06 <JoshieAS> Imagine: I would start him on Haskell. It will be tougher in the beginning, but I think he would learn other languages much faster after Haskell
09:34:06 <Imagine> Yeah thats true
09:34:06 <c_wraith> Darwin226: for executables, you can throw a Prelude module into your project and everything it exports will be visible in everything else.  But if you did something like that in a library, you'd make it super hard for others to use.
09:34:09 <bergmark> Darwin226: then you have to re-export all the base modules under a different name
09:34:38 <Imagine> The main problem is that I can't really help him as far as Haskell (yet), but I can just show him the IRC and he should be fine!
09:34:42 <mitchty> even knowing haskell i think knowing at least a smattering of c and how processors work and maybe a bit of asm is useful
09:34:42 <bergmark> or can you use package imports maybe?
09:35:13 <mmachenry> Imagine: If you're learning together that might be equally instructive.
09:35:13 <bergmark> anyway, you need to create a new module for each module in base you need
09:36:33 <Darwin226> c_wraith: Hmmm... My situation is actually a bit more complicated than that. I want to replace some of the functions in prelude, but my versions will be generated by TH, that means I need another module where I define the TH generators, but then that module will try to import my extended prelude. Any way around this?
09:36:45 <Imagine> thats true, I'll suggest that then
09:37:11 <bergey> Is there a commonly used name  for f :: [a] -> [(a, [a])] , f xs = [(x, delete x xs) | x <- xs] ?
09:37:15 <JoshieAS> Imagine: http://www.seas.upenn.edu/~cis194/spring13/lectures.html
09:37:25 <JoshieAS> a great course to run through to deepen your understanding
09:37:34 <c_wraith> Darwin226: You could move the TH into another package.  That's about the only sane way to handle that, I think.
09:38:07 <Imagine> ooh interesting
09:38:09 <Imagine> thanks JoshieAS
09:38:17 <fayong> Hi everyone
09:38:31 <Darwin226> c_wraith: I guess that wouldn't be too bad. What about the Prelude itself? Will I be able to import the default Prelude in it or will it get confused?
09:38:33 <fayong> I am trying to understand how exceptions works in haskell
09:38:48 <fayong> specifically how catching exception works
09:39:00 <c_wraith> Darwin226: It's been a while since I've done this, but I think it implicitly imports base's prelude
09:39:17 <fayong> looking at the type of throw
09:39:42 * hackagebot cmdlib 0.3.6 - a library for command line parsing & online help  http://hackage.haskell.org/package/cmdlib-0.3.6 (PetrRockai)
09:39:52 <fayong> throw :: (Exception e) => e -> a
09:40:06 <Darwin226> c_wraith: Yeah, but I need it too be explicit since I want to hide some functions. I think I might just resort to having that one extra import in all of my files
09:40:14 <Darwin226> seems like less of a hassle
09:40:26 <fayong> I guess the a can take the result type of the function throwing the exception
09:40:32 <c_wraith> being explicit certainly is nicer in a lot of ways.
09:40:52 <c_wraith> fayong: the return type is unconstrained just because that allows it to unify with anything
09:40:55 <fayong> but how can the runtime then know an exception has been thrown?
09:41:19 <c_wraith> fayong: throwing an exception is something the runtime handles.  It knows about it because..  That's what it does.
09:41:49 <fayong> so I can't write a catch function using regular haskell?
09:42:08 <c_wraith> It will need to be in terms of Control.Exception.catch
09:42:49 <Imagine> new question: Is camel case preferred to underscores for function and variable naming in Haskell?
09:42:54 <c_wraith> yes
09:43:10 <c_wraith> It's the convention the standard library uses, so everyone else uses it for consistency
09:43:15 <Imagine> alright
09:43:22 <c_wraith> some people do so happily, some under protest. :)
09:43:46 <fayong> c_wraith: ok, I found a lot of info about how yo use exception but nothing about how it works under the hood
09:44:22 <shapr> GOOD MORNING #HASKELL!
09:44:25 <shapr> it's morning somewhere...
09:44:36 <JoshieAS> shapr: it's definitely morning here! G'marnin'!
09:44:44 <shapr> Anyone tried to write a bot with any of the Haskell XMPP libs?
09:44:45 <c_wraith> fayong: I don't know all the details of how it works under the hood.  I know how the type stuff works.  I don't know about the exact mechanism the runtime uses to determine what code handles an exception.
09:44:50 <shapr> JoshieAS: howdy! How's code treating you today?
09:44:57 <JoshieAS> impartially, as always
09:44:59 <JoshieAS> ;)
09:45:02 <Denommus> shapr: it's also probably good somewhere
09:45:27 <shapr> JoshieAS: I guess you're not applying yourself? (partial application?)
09:45:33 <athan> Can anyone see why my eta reduction in my lambda calculus reducer is wrong? http://lpaste.net/133504
09:46:01 <athan> I keep getting `\x y -> x y` => `x -> x` :\
09:46:36 <dolio> That's the right answer, isn't it?
09:46:50 <Zemyla> athan: It is. ($) is the same as id.
09:46:51 <shapr> dolio: you gotta hang out with me some before I fly away :-P
09:46:57 <shapr> dolio: what about this weekend?
09:46:58 <athan> dolio: wait what :|
09:47:03 <fayong> c_wraith: ok thank you
09:47:06 <athan> :t \x y -> x y
09:47:07 <lambdabot> (r1 -> r) -> r1 -> r
09:47:17 <Zemyla> :t id `asTypeOf` ($)
09:47:18 <lambdabot> (a -> b) -> a -> b
09:47:29 <mniip> (\x y -> x y) and (\x -> x) are the same sans types
09:47:38 <mniip> which untyped lambda calculus doesn't have
09:47:40 <athan> Shouldn't the type be more specific than `forall a. a -> a`?
09:47:55 <athan> ahhh crud
09:48:08 <athan> How would I make an evaluator for prenex-form lambda calculus, then?
09:48:15 <athan> Should I type check before each reduction? :S
09:48:35 <mniip> typecheck?
09:48:37 <mniip> there are no types
09:48:45 <Zemyla> No, just type check before ypu start doing reductions at all.
09:48:46 <dolio> shapr: We could grab dinner some day.
09:49:03 <shapr> dolio: yes, that would be fun!
09:49:10 <athan> But this evaluation isn't consistent with HM/prenex form evaluation, is it?
09:49:30 <athan> thanks guys :)
09:49:32 <Zemyla> If your reductions are correct, everything that typechecks before should typecheck after.
09:49:44 <athan> Zemyla: I don't think they are
09:50:02 <athan> because :t \x y -> x y isn't the same, most-general type as \x -> x
09:51:14 <athan> For instance, can you reduce ($) to id, soundly?
09:51:25 <c_wraith> yes
09:51:29 <athan> I don't think it would be correct
09:51:31 <c_wraith> It's the other direction that doesn't work
09:51:36 <athan> :U
09:51:42 <athan> wow
09:51:47 <athan> brain sploded
09:51:52 <athan> thank you guys :)
09:52:07 <dolio> shapr: I tried to see if ddarius wanted to hang out, too. But apparently he's driving to Seattle, because he's moving there.
09:52:48 <dolio> Or, was when I asked.
09:54:20 <athan> c_wraith: But only in the untyped lambda calculus, correct?
09:54:32 <athan> ($) can only reduce to id in the untyped LC
09:54:56 <mniip> athan, not at all
09:55:01 <dolio> If you use Church-style, you won't have this problem.
09:55:01 <c_wraith> athan: it's valid in haskell, too!
09:55:09 <mniip> > (+) `id` 2 `id` 3
09:55:11 <lambdabot>  5
09:55:36 <mniip> it is the reverse that only works in untyped LC:
09:55:40 <mniip> > ($) 3
09:55:42 <lambdabot>      No instance for (Typeable a0)
09:55:42 <lambdabot>        arising from a use of ‘show_M3476662121866808875867’
09:55:42 <lambdabot>      In the expression:
09:55:47 <dolio> Eta contraction is dubious anyway, though.
09:55:59 <dolio> It tends to break confluence.
09:56:26 <mniip> whereas in untyped LC all values have an infinite arity so issues like this aren't apparent
09:56:52 <athan> dolio: Church-style... hmm
09:57:38 <Ainieco> shapr: how many years you're sitting here on #haskell?
09:57:47 <athan> mniip: by ($) I mean ($) alone as an expression
09:57:53 <dolio>  /\A B. \(x : A -> B). x
09:57:54 <athan> not while used in others
09:58:01 <athan> ahh shoot
09:58:06 <athan> need types in my expressions ._.
09:58:43 <shapr> Ainieco: fourteen years, why?
09:59:09 <shapr> Ainieco: how long have you been on #haskell ?
10:00:14 <Ainieco> shapr: just curious, good to have you here :) i think 3 years on and off, i don't visit often
10:00:44 <shapr> Ainieco: I like #haskell !
10:03:16 <redneb> are there any haskell-cafe admins here? I sent an email yesterday and it didn't go through?
10:03:23 <redneb> maybe it was marked as spam?
10:03:37 <redneb> never had that problem before
10:04:28 <geekosaur> #haskell-infrastructure and they're already poking at it
10:04:40 <geekosaur> mail is randomly getting temporary lookup failures
10:04:44 * hackagebot git-annex 5.20150528 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20150528 (JoeyHess)
10:04:46 * hackagebot peakachu 0.3.1 - Experiemental library for composable interactive programs  http://hackage.haskell.org/package/peakachu-0.3.1 (YairChuchem)
10:06:25 <redneb> should I send it again or will it eventually get through?
10:07:51 <geekosaur> you could try sending it again. I had something fail across multiple retries --- you'd get a temporary bounce after 3 days and permanent bounce after 5 if it fails completely
10:08:09 <geekosaur> or pop into #haskell-infrastructure and ask, since they're trying to diagnose it right now
10:08:34 <redneb> ok, I'll ask #haskell-infrastructure, thanks
10:09:44 * hackagebot BlogLiterately 0.8 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.8 (BrentYorgey)
10:12:27 <mettekou> I have written a lexer and parser for a subset of C using Alex and Happy. I would now like to perform basic semantic analysis, that is: detecting whether a variable is used only after it it declared and rudimentary type checking. I was wondering if there are already any libraries on Hackage which implement this process, as to not having to use Control.Monad.State and Data.Map to carry a symbol table around manually.
10:17:23 <qssq> This post (http://lambda.jstolarek.com/2013/04/haskell-as-fast-as-c-a-case-study/) highlights `vector` for stream fusion. GHC has generalized stream fusion since that time (early 2013), right?
10:17:46 <c_wraith> GHC doesn't do any stream fusion itself.
10:17:51 <c_wraith> It's part of libraries
10:18:10 <c_wraith> GHC just provides tools, like rewrite rules, that libraries can use to implement things like that.
10:18:11 <Zemyla> It has list fusion, though.
10:18:22 <c_wraith> base has list fusion.  GHC doesn't know a thing about it.
10:18:37 <c_wraith> GHC knows about rewrite rules and inlining
10:19:32 <c_wraith> ...  and simplification.  Can't forget that step.
10:19:46 <qssq> Okay. So the semi-recent papers about generalizing stream fusion didn't require any changes to GHC, just more rewrite rules?
10:19:48 <osa1_> but it does some deforestation, right? isn't that considered list fusion? (because eliminates intermediate lists)
10:20:14 <athan> Would this be a legitimate, stapled together subtyping relation to force some typing in my evaluator? http://lpaste.net/133505
10:20:28 <c_wraith> osa1_: no, the deforestation is from the rewrite rules
10:20:57 <c_wraith> osa1_: base provides implementations of all sorts of list functions in terms of foldr and build, and then rewrite rules to combine foldr and build without creating intermediate lists
10:20:59 <osa1_> wow, I didn't know that. I thought some variant of Wadler's deforestation is implemented and is doing automatic deforestation...
10:21:48 <qssq> Are those changes to base pretty recent? Because I reran the benchmarks from the 2013 and get pretty different results
10:22:14 <c_wraith> qssq: yes, they've been ongoing.  dfeuer got a *bunch* of additional operations to support fusion in GHC 7.10
10:22:30 <dfeuer> Fun stuff!
10:22:33 <dfeuer> Sort of wild though.
10:22:45 <qssq> Ah, thanks
10:22:55 <c_wraith> qssq: there have been improvements to GHC to make rewrite rules and simplification function more reliably, too.
10:22:55 <osa1_> by operations do you mean new rewrite rules?
10:22:56 <dfeuer> That's the big problem with fusion--it sometimes makes things better, and sometimes makes things worse,
10:23:02 <dfeuer> and there are lots of horrible interactions.
10:23:24 <c_wraith> osa1_: no, I mean functions that operate on lists.  Lots of them were reimplemented to allow fusion
10:23:37 <dfeuer> qssq, new rewrite rules, and a lot of that was supported by a new compiler analysis by Joachim Breitner.
10:23:45 <dfeuer> "Call arity"
10:24:03 <c_wraith> Yeah, the call arity analysis allows fusion optimizations to actually fire when foldl is implemented as foldr
10:24:19 <c_wraith> That is, it allows the rewrite rules to match when they previously wouldn't
10:24:52 <c_wraith> several other things benefit, too..  But allowing foldl and foldl' to participate in fusion was the main goal.
10:27:05 <qssq> Thanks for the explanation
10:27:08 <osa1_> athan: TFun rule is wrong
10:33:30 <adarqui> hey i found someone that is having a problem similar to mine: http://stackoverflow.com/questions/21384525/exceptions-not-being-caught-by-try .. i'm looking in the hedis code and I don't see anything that would be printing the exception.. it almost seems like GHC is doing it though because it's printing argv0: <ExceptionName> .. anyone have any idea?
10:35:09 <geekosaur> adarqui, that usually means you are not forcing thunks while under the try
10:35:37 <geekosaur> something is too lazy and leaking out as an unevaluated thunk which is eventually forced outside the try and throws the exception
10:35:53 <adarqui> ah.. ! that might explain why it's "not catching it the first time", then catching it the rest of the times
10:35:56 <adarqui> or something weird
10:36:00 <c_wraith> ...  It's supposedly a throwIO, though, so that shouldn't matter...  unless unsafeInterleaveIO is involved
10:36:22 <c_wraith> That's an extra fun way unsafeInterleaveIO breaks things which I hadn't previously considered.
10:37:44 <geekosaur> yep
10:37:54 <geekosaur> it's unsafe... for a reason
10:38:39 <c_wraith> Well, I knew it was trivial to get results out of it that depend on evaluation order, but I hadn't considered extending that to exceptions.
10:39:45 * hackagebot json-rpc-server 0.1.6.0 - JSON-RPC 2.0 on the server side.  http://hackage.haskell.org/package/json-rpc-server-0.1.6.0 (grayjay)
10:39:47 * hackagebot DefendTheKing 0.3.1 - A simple RTS game  http://hackage.haskell.org/package/DefendTheKing-0.3.1 (YairChuchem)
10:40:57 <felixn> I feel really dumb, but I'm trying to build an abstract DSL that let's me describe how to do a network algorithm, then be able to map it either to TCP or HTTP.  are there any good articles on doing something like this?  I can't to google any
10:40:58 <hodapp> damn you Galois for changing the Ivory API in a way that is very rational and correct, but in a way that breaks my code -_-
10:41:27 <hodapp> felixn: hummm, I feel like I just read something vaguely similar in an Ivory paper (but maybe it was a Coq paper), let me look...
10:41:29 <adarqui> thanks geekosaur, c_wraith .. going to try and fig it out
10:41:53 <hodapp> well, the paper referenced something at Boeing, so good luck
10:42:40 <hodapp> felixn: so, your DSL is trying to specify what about the algorithm?
10:42:47 <geekosaur> (this incidentally is why standard lazy I/O doesn't try to throw exceptions, just ends the data stream)
10:48:21 <felixn> hodapp: https://gist.github.com/munro/66c4d89df61ea5d6bf91 <-- here's a mockup of the DSL ... I've been hurting my head over this for the past 2 days lol
10:48:28 <felixn> I think maybe I'm modeling it all wrong
10:49:13 <bitemyapp> c_wraith: I was eating
10:49:39 <bitemyapp> c_wraith: thanks for the ping, regrettably it seems that person wasn't around.
10:49:47 <hodapp> felixn: so, this is trying particularly to model a protocol's state transitions?
10:49:59 <bitemyapp> c_wraith: if you think somebody may want to ask questions, I'm happy to answer emails: https://github.com/bitemyapp/
10:50:29 <bitemyapp> my coauthor has talked a bit about what it's like to learn Haskell and has learned some Ruby, JS, and Java since then. She might be able to write something about it later.
10:51:23 <felixn> hodapp: I want to experiment doing different types of P2P algorithms like DHT, but I'm sort of yak shaving on trying to create an abstract DSL for building on top of ... because it would be super easy to do in Python, also it's kind of fun trying to do in Haskell
10:51:50 <Hafydd> Quote the co-author, it sounds like.
10:51:56 <Hafydd> *Quite
10:52:26 <hodapp> felixn: if it's easy to do in Python, perhaps see what the actual code looks like there first.
10:52:35 <bitemyapp> Hafydd: she's brilliant and hasn't quite realized it yet. Still, there's a lot of work for anybody that hasn't programmed before no matter what language they start with.
10:52:42 <bitemyapp> So this myth that it's easier for non-programmers to learn Haskell is a canard.
10:53:23 <bitemyapp> there's less unlearning to do, but it's not easier. Not in terms of time, effort, familiarity, etc.
10:53:26 <hodapp> bitemyapp: what else would a myth be?
10:53:27 <c_wraith> The best way to learn a language is to have no expectations of difficulty.
10:53:33 <bitemyapp> hodapp: yes, I was redundant.
10:53:38 <felixn> hodapp: that's a good idea!  also if you think of any good reading material, that would be helpful too :D
10:53:47 <bitemyapp> c_wraith: yeah. That helps a lot.
10:56:52 <hodapp> That's still a sample size of 1 with no measurements that I'm aware of; it's not really sufficient for confirming or denying something as a myth.
10:57:23 <bitemyapp> hodapp: I don't need a large sample size to say that there's a ton of stuff exterior to the programming language that one must learn in order to write programs.
10:57:38 <bitemyapp> Not that it changes the confidence much, but my sample size isn't 1 either.
10:58:08 <hodapp> bitemyapp: I don't think that point has ever been in dispute.
10:58:26 <hodapp> except perhaps by people who make those lobotomized visual systems that are designed to make programming easy(tm).
10:59:03 <hodapp> ...and the people who write the articles talking about how those aforementioned systems are going to revolutionize programming.
10:59:46 * hackagebot generator 0.5.5 - Python-generators notation for creation of monadic lists  http://hackage.haskell.org/package/generator-0.5.5 (YairChuchem)
10:59:50 <bitemyapp> hodapp: yeah...I'm skeptical of those too.
11:00:08 <hodapp> bitemyapp: having to use them has only made me more skeptical of them.
11:01:15 <kuribas> I am trying to understand the haskell string zoo.  Am I right that: `String` is a list of unicode codepoints.  `Bytestring` are packed bytes, and has nothing to do with text.  `Text` is packed strings, and actually represents packed unicode chars.
11:01:44 <geekosaur> Yes. Text is UTF8 encoded
11:02:05 <dolio> Text is UTF16, I think. But that's not something you have to know.
11:02:11 <geekosaur> ByteString is normally used with raw-ish I/O, which is defined in terms of byte streams
11:02:55 <geekosaur> String is good for simple stuff and short strings, profoundly bad with larger stuff unless it can be made to fuse so that the actual lists never exist
11:03:41 <geekosaur> there is ongoing discussion about possibly migrating to using Text as the "common"" string type --- but this is difficult because so many things using String assume the ease and cheapness of building lists
11:03:54 <geekosaur> (cheap in time, not ultimately in space)
11:04:42 <kuribas> The string is list idiom is very convenient.
11:05:03 <nshepperd> canard. doesn't that mean 'duck' in french? how did it come to mean a myth?
11:06:43 <vdorr> hello, how long is long haskell program?
11:06:56 <mitchty> nshepperd: http://etymonline.com/index.php?allowed_in_frame=0&search=canard&searchmode=none
11:07:09 <geekosaur> nshepperd, apparently we got the word with *both* meanings from French
11:07:18 <mitchty> old and new
11:07:32 <nshepperd> huh
11:07:44 <geekosaur> ...said by Littré to be from the phrase vendre un canard à moitié "to half-sell a duck," thus, from some long-forgotten joke, "to cheat."
11:15:05 <joneshf-laptop> is there any reason why there's no `IsList` instance for `Data.Map`?
11:15:22 <bergmark> i thought that was added
11:15:38 <joneshf-laptop> oh, sorry iwas looking at the wrong version
11:15:40 <joneshf-laptop> :)
11:22:25 <abbradar> Hi all! I explore lens and have found myself in need of something like "Applicative m => Lens' a b -> Lens' (m a) (m b)"; I *feel* it's already somewhere there, and I'm just missing it.
11:22:35 <abbradar> I can define it as "test l = lens (fmap $ view l) (\fa fb -> set l <$> fb <*> fa)"
11:24:03 <abbradar> My aim is to make "Lens' (Maybe a) (Maybe b)" from "Lens' a b"
11:29:11 <S11001001> abbradar: that is an illegal lens; a lens requires that when you 'set' a value into a structure, if you 'view' on it you get what you set
11:30:07 <S11001001> abbradar: whereas, if I set Just 42 into a Nothing with your lens and then view, I'll get Nothing back
11:30:56 <S11001001> abbradar: you can lift a Setter into Applicative, but not Lens.
11:31:25 <arkeet> or even into any Functor. (that's fmap)
11:31:45 <abbradar> S11001001: Hm, indeed -- I've noticed that it would violate the law now, but you were faster ^^
11:32:31 <abbradar> Thanks! I'll be more cautious with my laws now
11:32:38 <S11001001> abbradar: but you might be more interested in working with Traversals instead.  That gives you many of the operations and lets you drill into Maybe and other such things (Traversables that happen to be Applicative so maybe what you really want)
11:35:31 <S11001001> @let lll = undefined :: Lens' String Int
11:35:35 <lambdabot>  Defined.
11:35:41 <S11001001> @ty traverse . lll
11:35:43 <lambdabot> (Applicative f, Traversable t) => (Int -> f Int) -> t String -> f (t String)
11:36:29 <S11001001> @ty traverse . lll :: Traversable t => Traversal' (t String) Int
11:36:30 <lambdabot> (Applicative f, Traversable t) => (Int -> f Int) -> t String -> f (t String)
11:36:38 <S11001001> abbradar: so there's that.
11:36:54 <abbradar> Yes, already using them. You've also made me understand my idea (At instance for only a part of value inside a newtype Map) was stupid
11:37:03 <abbradar> It seems obvious now; I definitely lack sleep
11:37:17 <S11001001> abbradar: cool
11:37:22 <abbradar> Thanks!
11:44:20 <codygman> Can I use a smart constructor in an Aeson FromJSON instance? Could I use it directly and use some sort of "IdentityParser" that does nothing and returns the result of my smart constructor? some (hopefully helpful) sample code: http://lpaste.net/133509
11:46:31 <indiagreen> codygman: I don't understand what you're trying to do (sorry!) – can you explain better? specifically, what do you mean by “smart constructor” here? is the code you pasted what you want, or what you have now? etc
11:47:12 <indiagreen> if no parsing needs to be done, you can just “return” the values
11:47:25 <indiagreen> (“return $ StringVal s”)
11:47:44 <indiagreen> since Parser is a monad
11:50:11 <indiagreen> say if I completely misinterpreted your question
11:59:35 <Geekingfrog> Is there a place where I can see the implementation of some well known monads? I'm specifically looking at fmap for the monad reader
11:59:44 <Geekingfrog> reader monad*
12:00:49 <Welkin> Geekingfrog: yes, look at base
12:00:58 <Welkin> it is all well commented too
12:00:58 <Happy_Nihilist> Monads? More like, gonads?
12:01:00 <Happy_Nihilist> Am I right?
12:01:33 <Welkin> Geekingfrog: https://hackage.haskell.org/package/mtl-2.2.1/docs/src/Control-Monad-Reader-Class.html#MonadReader
12:01:54 <Geekingfrog> Welkin, thanks
12:02:46 <Welkin> Geekingfrog: https://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-Base.html#Monad
12:03:01 <Welkin> that is what you are looking for
12:03:31 <Geekingfrog> ah yeah, this is the one.
12:04:14 <Welkin> https://hackage.haskell.org/package/mtl-1.1.0.2/docs/src/Control-Monad-Reader.html#Reader
12:04:25 <Welkin> there is the Monad instance for ReaderT
12:05:48 <Forgetaboutit> Welkin: http://hackage.haskell.org/package/transformers-0.4.3.0/docs/src/Control-Monad-Trans-Reader.html#line-125
12:05:53 <Forgetaboutit> Welkin: This one?
12:06:22 <Forgetaboutit> I believe mtl just reexports the instances from transformers
12:24:50 * hackagebot cheapskate 0.1.0.4 - Experimental markdown processor.  http://hackage.haskell.org/package/cheapskate-0.1.0.4 (JohnMacFarlane)
12:29:50 * hackagebot cmark 0.3.3.1 - Fast, accurate CommonMark (Markdown) parser and renderer  http://hackage.haskell.org/package/cmark-0.3.3.1 (JohnMacFarlane)
12:30:43 <codygman> indiagreen: I think I tried that, but will try again. That is exactly what I need though.
12:31:07 <indiagreen> codygman: if it doesn't work, paste the code *and* the error
12:31:13 <hexagoxel> uh so __GLASGOW_HASKELL__ is 710 for ghc-7.10.1 .. ok. why not 7101? somebody did not anticipate two digits at some point..
12:33:28 <athan> dolio: So church-style lambda expressions come annotated with each term's _most_ polymorphic type? S.T. `EApp :: /\a b. (e1 :: a -> b) (e2 :: a) :: b`, as the data constructor for the expression itself?
12:33:58 <athan> Likewise, during construction, one could enforce proper typing via a GADT representation for each constructor?
12:35:02 <codygman> indiagreen: Will do, sorry I didn't post all of it. Can't post the exact code since it's for work.
12:41:43 <dolio> athan: This style of lambda expression has a lambda corresponding to universal quantifiers.
12:42:14 <dolio> (/\a. \(x : a). x) : forall a. a -> a
12:42:37 <dolio> And you must apply types to instantiate universal quantifiers.
12:43:08 <dolio> \(id : forall a. a -> a). id Char 'c'
12:46:23 <kynan_> anyone here use ekmett's linear library for (5+)-dimensional vectors?
12:47:09 <kynan_> i'm trying to implement this: http://twvideo01.ubm-us.net/o1/vault/gdc09/slides/04-GDC09_Catto_Erin_Solver.pdf
12:47:16 <athan> dolio: Okay, so something like System F. I almost have a GADT representation of well-typed expressions, but I can generate fresh type variables. Thank you!!
12:47:19 <shwouchk> Hi
12:49:51 * hackagebot json-rpc-client 0.1.4.0 - JSON-RPC 2.0 on the client side.  http://hackage.haskell.org/package/json-rpc-client-0.1.4.0 (grayjay)
13:01:58 <zq> athan: your tfun is backwards. contravariant.
13:03:03 <fvgvxmpv1> Can i derive Eq for a data type taking arguments? For example: data foo bar = foo { c :: bar } — That is: is GHC "smart" enough to add the apropriate (Eq Bar)-Constraint?
13:03:34 <fvgvxmpv1> *bar
13:03:45 <zq> athan: a <: b, c <: d |- (c -> d) <: (a -> b) 
13:03:56 <zq> meh, he's not even here
13:04:10 <Zemyla> c_wraith: How does foldl' benefit now?
13:04:37 <Zemyla> Wait, my scrollback was stuck. Never mind.
13:04:38 <geekosaur> fvgvxmpv1, yes
13:04:51 <fvgvxmpv1> geekosaur: wonderful.
13:05:30 <zq> a <: c, d <: b |- (c -> d) <: (a -> b)
13:05:35 <zq> i should just go to sleep
13:06:17 <Welkin> a foo bar in a car with cdr near a baz qux char!
13:06:34 <geekosaur> fvgvxmpv1, https://www.haskell.org/onlinereport/haskell2010/haskellch11.html#x18-18200011 for details
13:08:31 <yashi> Is there a channel for Homotopy Type Theory?
13:09:14 <Welkin> you could start one
13:09:18 <Welkin> #homo-theory
13:09:24 <yashi> :(
13:09:57 <Welkin> ambiguous channel names
13:12:13 <mr-> yashi: ##hott
13:13:08 <JoshieAS> does /whois only show channels for a user if you are in that channel with them?
13:14:16 <refefer> I can't for the life of me link to ncursesw
13:14:22 <Hijiri> JoshieAS: some channels are hidden from whois
13:14:22 <refefer> for static deployment
13:14:30 <refefer> anyone have any ideas?
13:14:31 <shwouchk> In the main function, I first bind some IO value with <-, and I then use it in several pure functions and bind the results with return. It seems kind of redundant to use <- return $ ... Is there a nicer construction?
13:14:42 <JoshieAS> because I've whois'd like 20 people and they're all in only one channel
13:15:17 <dolio> shwouchk: let
13:15:21 <Hijiri> shwouchk: let x = ...
13:15:30 <Zemyla> shwouchk: do x <- io; return (f x) can be written more succinctly as fmap f io.
13:16:11 <Zemyla> This works for all monads, not just IO.
13:17:20 <athan> osa1_: I think that it's actually the correct subtyping instance, for my use case
13:18:07 <codygman> Is there no way to decode an integer in Aeson? For instance this returns Nothing: (\bs -> decode bs :: Maybe Integer) . encode $ (1 :: Integer)
13:18:32 <indiagreen> codygman: it should work if your aeson is >= 0.9
13:19:06 <geekosaur> otherwise there's a dodge to do it because older aeson believed top level expressions had to be objects
13:19:07 <indiagreen> if not, see my tutorial: http://artyom.me/aeson#pecularities-of-parsing-top-level-values
13:19:26 <indiagreen> geekosaur: or arrays
13:20:49 <shwouchk> dolio, Hijiri: I think it didn't work, let me check why
13:21:10 <dolio> shwouchk: If you used 'in', you don't do that.
13:21:42 <shwouchk> dolio: ah, that's it probably... why not?
13:22:11 <dolio> Because this is a let that's part of a do. It's more statement-like.
13:23:57 <shwouchk> dolio: damn, I think I forgot that part of syntax sugar
13:25:41 <shwouchk> dolio: get a bunch of errors :()
13:25:54 <codygman> indiagreen: aeson >= 0.9 is really new... servant-server doesn' support it for instance :/
13:26:16 <shwouchk> dolio: nevermind for now, I need to change some of the types of statements
13:26:23 <codygman> hm looks like those updates didn't break anything though
13:28:10 <indiagreen> codygman: then use the workaround in the link. Or you can use... uh, there was some compatibility library announced recently, I'll try to find it
13:28:12 <athan> dolio: Would you suggest that I walk down an untyped expression, and annotate it as I perform type inference?
13:28:42 <dolio> You could do that, I guess.
13:29:11 <indiagreen> codygman: http://hackage.haskell.org/package/aeson-utils-0.3.0.2/docs/Data-Aeson-Utils.html#v:decodeV
13:29:37 <shwouchk> dolio: yep, now works. Awesome, thanks!
13:30:19 <athan> hrm
13:35:19 <nkar`> is there an analog of addIntC# but for Int64?  the type of the former is Int# -> Int# -> (# Int#, Int# #)
13:38:29 <arkeet> you mean aside from the fact that Int is 64 bits on amd64 or whatever
13:39:40 <refefer> hmm, so it appears that cabal passes the linker options in the wrong place
13:39:55 <refefer> any idea how to tell it to position it elsewhere?
13:48:16 <xplat> according to standard json the top level has to be an object or a list
13:51:10 <poincare101> I'm a haskell rookie and I'm trying to learn about algebraic types in Haskell. If I have something like this: http://pastie.org/10212568, is there any way I can refer to the whole Triangle constructed type in the function other than "Triangle arr width"?
13:52:37 <kadoban> poincare101: use the pattern blah@(Triangle arr width) and then refer to it as blah ?  Alternatively,  blah@(Triangle{}) if you don't care about arr and width.
13:52:59 <poincare101> kadoban: oh thanks that's pretty simple
13:54:17 <kadoban> 'welcome
13:54:54 * hackagebot wai-request-spec 0.9.0.0 - Declarative request parsing  http://hackage.haskell.org/package/wai-request-spec-0.9.0.0 (alcabrera)
13:59:54 * hackagebot wai-request-spec 0.9.0.1 - Declarative request parsing  http://hackage.haskell.org/package/wai-request-spec-0.9.0.1 (alcabrera)
14:05:50 <bergmark> poincare101: or just `func t = ...'
14:06:40 <poincare101> bergmark: but I need to access triangle as well
14:06:48 <poincare101> what is the technical term for the things "inside" the constructor
14:06:48 <maxx-> about to install fresh ghc again.. I am wondering if I should use cabal sandboxes right from the beginning (meaning not even installing haskell platform), or if I can install all the packages globally, and only use sandboxes when there's a conflict?
14:07:03 <poincare101> so Triangle arr height <- what are arr and height?
14:08:13 <bergmark> poincare101: fields
14:19:29 <frerich> Is a function of type 'b -> (a -> [a] -> b) -> [a] -> b' a catamorphism for [], i.e. even if it just replaces the 'outer' constructor calls? Or is only 'b -> (a -> b -> b) -> [a] -> b' considered a catamorphism?
14:19:45 <arkeet> no, the first thing isn't a catamorphism.
14:20:02 <frerich> Drat, that means I always got it wrong.
14:26:04 <maxx-> when using cabal sandboxes are globally installed package (if there are ones) always used first, with sandboxes only being used when installing new packages?
14:32:04 <mniip> foldr is supposed to be a catamorphism for []
14:35:21 <c_wraith> is supposed to be?
14:38:32 <Welkin> foldr is not just for lists
14:38:41 <Welkin> it is for anything that has foldMap defined on it
14:38:51 <Welkin> anything foldable
14:39:56 * hackagebot wai-request-spec 0.9.0.2 - Declarative request parsing  http://hackage.haskell.org/package/wai-request-spec-0.9.0.2 (alcabrera)
14:43:08 <frerich> I only used lists as an example. You could also use 'data Expr = Number Int | Sum Expr Expr'. My naive understanding was that a catamorphism simply replaces each constructor call, e.g. 'cataExpr :: (Int -> b) -> (Expr -> Expr -> b) -> Expr -> b'. I later heard that it should actually replace all calls recursively.
14:43:27 <frerich> I.e. cataExpr should have been '(Int -> b) -> (b -> b -> b) -> Expr -> b'.
14:43:45 <frerich> Alas all explanations of catamorphisms I found are too mathy for me to digest.
14:44:04 <johnw> frerich: the latter is correct
14:44:35 <johnw> if you close over the Expr argument, you have something isomorphic to the final encoding for that initial algebra
14:44:57 * hackagebot wai-request-spec 0.9.1.0 - Declarative request parsing  http://hackage.haskell.org/package/wai-request-spec-0.9.1.0 (alcabrera)
14:45:15 <johnw> actually, I think you have an inhabitant of the final encoding, something like that
14:45:57 <Pamelloes> Is there a way to "override" an instance declaration? For instance if I have a class MyClass a, can I have one instance of Eq for MyClass a and a special one for MyClass Int?
14:46:10 <johnw> no
14:46:36 <Pamelloes> Oh.
14:46:46 <johnw> you can, however, provide a default, using Generics
14:46:56 <frerich> johnw: So far, it was never an issue for me since recursing manually was easy enough, e.g. I might have written 'eval = cataExpr id ((+) `on` eval)' but I guess the 'fully recursive' version is nicer because I can just define 'eval = cataExpr id (+)'
14:47:08 <johnw> Pamelloes: https://wiki.haskell.org/GHC.Generics#More_general_default_methods
14:47:28 <johnw> frerich: the "fully recursive" one is the catamorphism
14:47:41 <johnw> otherwise, it would just be case analysis
14:48:21 <arkeet> okay, catamorphisms:
14:48:23 <arkeet> let's talk about lists.
14:48:29 <arkeet> data List a = Nil | Cons a (List a)
14:48:52 <arkeet> let's actually define something else.
14:49:03 <arkeet> data ListF a x = NilF | ConsF a x
14:49:07 <johnw> data Free f a = Pure a | Free (f (Free f a))
14:49:08 <frerich> johnw: Yeah, I see that now. Amazing how far I got without noticing that I got it all wrong! :-)
14:49:16 <arkeet> no monads pls
14:49:33 <arkeet> anyway, (ListF a) is a functor.
14:49:34 <johnw> cata :: (a -> r) -> (f r -> r) -> Free f a -> r
14:50:04 <arkeet> I'm going to call any function of tyep ListF a x -> x a (ListF a)-algebra.
14:50:13 <arkeet> that's type `ListF a x -> x`
14:50:59 <arkeet> now, List a is a (ListF a)-algebra in a fairly obvious way
14:51:08 <arkeet> inj :: ListF a (List a) -> List a
14:51:10 <arkeet> inj NilF        = Nil
14:51:10 <arkeet> inj (ConsF a x) = Cons a x
14:51:23 <arkeet> now
14:51:27 <Pamelloes> johnw: Hm, I don't think that will do what I want it to.
14:51:29 <arkeet> it's not just any old algebra
14:51:30 <arkeet> this one's special.
14:51:46 <arkeet> because given *any other* algebra  f :: ListF a x -> x
14:52:06 <arkeet> there's a unique function  h :: List a -> x
14:52:26 <arkeet> that respects the algebra structure on  List a  and  x
14:52:40 <arkeet> you can draw a commutative diagram for this, but the equation is
14:52:44 <arkeet> f . fmap h = h . inj
14:53:11 <arkeet> I'll just show you h exists:
14:53:19 <arkeet> h Nil = f NilF; h (Cons a x) = f (ConsF a (h x))
14:54:09 <arkeet> I can abstract this into a function cata :: (ListF a x -> x) -> (List a -> x)
14:54:13 <arkeet> where cata f is h as defined above
14:54:46 <arkeet> cata is the catamorphism for (ListF a)-algebras.
14:54:57 * hackagebot first-class-patterns 0.3.2.2 - First class patterns and pattern matching, using type families  http://hackage.haskell.org/package/first-class-patterns-0.3.2.2 (BrentYorgey)
14:55:35 <arkeet> with a bit of manipulation you can show that the type of cata is isomorphic to
14:55:39 <arkeet> x -> (a -> x -> x) -> List a -> x
14:55:44 <arkeet> that looks a lot like foldr.
14:56:43 <arkeet> in general, if F is a functor, a F-algebra is just a function of type F x -> x
14:56:44 <arkeet> for some x
14:58:13 <arkeet> and I guess at least in haskell, there is always some "initial F-algebra" of type F I -> I
14:58:50 <arkeet> such that any other F-algebra F x -> x gets you a unique F-algebra morphism I -> x
14:59:05 <arkeet> thus defining a catamorphism for F
14:59:31 <arkeet> and actually in haskell the initial F-algebra is always an isomorphism.
14:59:46 <arkeet> exercise: show that inj :: ListF a (List a) -> List a is an isomorphism.
14:59:57 * hackagebot haskellscript 0.2.3 - Command line tool for running Haskell scripts with a hashbang.  http://hackage.haskell.org/package/haskellscript-0.2.3 (seanparsons)
15:01:19 <arkeet> actually you can always define I = Fix F
15:01:27 <arkeet> where data Fix F = F (Fix F)
15:02:23 <arkeet> frerich: sorry if you haven't been following, I just kinda spewed everything out.
15:04:41 <frerich> arkeet: Thanks! I think it'll take a bit until I appreciate those insights. So far, the main reason why I got interested in catamorphisms in general was because I noticed that I could use them to define a whole range of things very concisely. In my earlier 'Expr' type I could have 'pprint = cataExpr show (\x y -> x ++ " + " ++ y)' or maybe 'countSummands = cataExpr (const 1) (+)'.
15:05:02 <Bor0> anyone up for a quick group theory task? I have my try but not sure if it makes sense
15:05:08 <arkeet> I guess the intuition for haskell data types is that catamorphisms perform constructor replacement (recursively).
15:05:19 <frerich> arkeet: I.e. I find them interesting for somewhat mundane reasons. :-}
15:06:05 <arkeet> it's not that mundane if you think about it more deeply :-)
15:06:41 <frerich> My main takeaway so far is that when I have a recursive data structure then it's probably handy ot have some sort of cata around because that simplifies a whole bunch of other definitions. :-)
15:06:48 <arkeet> for sure.
15:07:10 <frerich> It's also neat sometimes for things like 'bool' or 'maybe' or 'either' but IMHO it really shines with recursive structures.
15:07:23 <arkeet> yeah, I was about to mention those as more examples of catamorphisms.
15:07:31 <ttt_fff> is there a nice way to install haskell/cabal on windows, or should I just go virtualbox?
15:07:46 <ttt_fff> i.e. are cabal packages that build on linux guaranteed to build on windows? (this is a surface pro 3)
15:08:08 <frerich> arkeet: FWIW some time ago I actually did a TH exercise which generates catamorphisms for you given some type ( http://hackage.haskell.org/package/catamorphism ) -- alas I now realize that I did it wrongly heh, will fix it soon
15:08:11 <dcoutts> ttt_fff: pure Haskell packages are fine, ones that depend on C libs can be a bit of a pain
15:08:19 <arkeet> ttt_fff: the situation is pretty good for things that don't have stuff like C library dependencies.
15:08:24 <arkeet> you can just install ghc and go from there.
15:08:27 <ttt_fff> hmm
15:08:31 <arkeet> frerich: another example:
15:08:32 <arkeet> :t iterate
15:08:34 <ttt_fff> I want postgresql access via opaleye
15:08:34 <lambdabot> (a -> a) -> a -> [a]
15:08:37 <arkeet> er.
15:08:39 <ttt_fff> so I probably have to deal with C bindings?
15:08:42 <arkeet> that's not it.
15:09:22 <arkeet> :t \z f n -> iterate f z !! n
15:09:24 <lambdabot> a -> (a -> a) -> Int -> a
15:09:37 <arkeet> frerich: if you pretend Int here is the natural numbers  data Nat = Z | S Nat
15:09:45 <arkeet> then this is a catamorphism for Nat
15:10:23 <arkeet> incidentally, Nat is isomorphic to [()], so
15:10:38 <arkeet> :t foldr :: a -> (() -> a -> a) -> [()] -> a
15:10:39 <lambdabot>     Couldn't match type ‘a1’ with ‘() -> a1 -> a1’
15:10:39 <lambdabot>       ‘a1’ is a rigid type variable bound by
15:10:40 <lambdabot>            an expression type signature: a1 -> (() -> a1 -> a1) -> [()] -> a1
15:10:48 <Bor0> anyway, can someone tell me if there's anything wrong with this? Suppose (G, *) is group, and f: G -> G for f(x) = x^3 is surjective homomorphism. Prove that (G, *) commutes. here's my try: Suppose (G, *) is not a commutative group. Then the surjective homomorphism f cannot be formed due to f(a)f(b) = f(b)f(a) => (ab)^3 = (ba)^3 => e = (ba)^3 (ab)^(-3). if a' = (ba)^3, b' = (ab)^(-3), then by inverse property a'b' = b'a' = e, thus commutativi
15:10:48 <Bor0> ty. Contradiction, thus (G, *) must commute
15:10:49 <arkeet> :t flip foldr :: a (() -> a -> a) -> [()] -> a
15:10:51 <lambdabot>     Expecting one more argument to ‘a’
15:10:51 <lambdabot>     The first argument of ‘a’ should have kind ‘OpenKind’,
15:10:51 <lambdabot>       but ‘a’ has kind ‘k0 -> k1’
15:10:53 <arkeet> :t flip foldr :: a -> (() -> a -> a) -> [()] -> a
15:10:54 <lambdabot> a -> (() -> a -> a) -> [()] -> a
15:10:55 <arkeet> I can't type today.
15:11:04 <arkeet> this is basically the same thing.
15:11:13 * frerich tries to think of interesting applications for a catamorphism for Nat...
15:12:28 <frerich> I guess it would be nice for converting a Nat to an Integer
15:12:39 <frerich> cataNat 0 (+1)
15:14:00 <frerich> I've always been amazed by how many useful functions you can define very concisely using foldr, and I think it's this fascination which also makes me enjoy tinkering with catamorphisms for other types :-)
15:14:12 <gcganley> so im building a website in haskell using emacs and everything is great. But the one thing i wish i had was that if I hit <f5> I want to do one of three things. Open a new ghci session and run the main function, refresh the file that is already in the open ghci session and run the main function, if the main function is already running then stop the funciton refresh the file and run main again. Is there anything that does that already
15:14:12 <gcganley> and if not could someone help me with it
15:14:19 <frerich> It strips away so much boilerplate!
15:15:14 <gcganley> and i know there is an emacs specific channel i just the name escapes me
15:15:19 <gcganley> emacs-haskell that is
15:15:20 <arkeet> Bor0: right idea, but the presentation isn't great
15:15:32 <arkeet> I'd start with
15:16:17 <arkeet> because f is surjective and G isn't commutative, there exist a and b such that (ab)^3 != (ba)^3
15:16:23 <arkeet> and then derive a contradiction from there
15:16:45 <Bor0> arkeet, do you think my reasoning makes sense?
15:17:04 <Bor0> something inside me tells me I'm not free to just assume a' = (ba)^3 and b' = (ab)^(-3)
15:17:12 <arkeet> assume?
15:17:17 <arkeet> those look like definitions of a' and b' to me.
15:17:53 <Bor0> can we also not say a' = (ba)^3ab^(-1)  and then b' = ab^(-2) ? a' b' = e also
15:18:14 <arkeet> you could, but why?
15:18:37 <Bor0> oh, but I still get a' b' = b' a'
15:18:43 <Bor0> I see...
15:18:58 <arkeet> I think the clean way to do it is something like
15:19:10 <mniip> <command line>: cannot satisfy -package-id mtl-2.1.2-279942cbcf04a594ccc4b76912e6d103
15:19:12 <mniip> what's this mean
15:19:21 <arkeet> well, suppose G isn't commutative
15:19:37 <Bor0> ok
15:19:45 <arkeet> then since f is surjective, there exist a, b such that f(a)f(b) != f(b)f(a)
15:20:02 <arkeet> so (ab)^3 != (ba)^3
15:20:03 <arkeet> uh
15:20:20 <Bor0> f(a)f(b) = f(a*b) due to homomorphism on G -> G, so that's correct
15:20:29 <arkeet> this isn't going where I wanted it to.
15:20:53 <gcganley> can anyone tell me the emacs-haskell freenode channel? is that the right title for it?
15:20:55 <arkeet> actually never mind this is simple.
15:21:04 <arkeet> look at the inverses of both sides.
15:21:11 <arkeet> the inverse of the left side is clearly (ab)^-3
15:21:33 <arkeet> uh
15:21:38 <arkeet> nm I'll stop.
15:21:42 <arkeet> I'm tired.
15:23:28 <Bor0> arkeet, in general, besides the form (I'm sure it can be made more elegant), do you think the reasoning is correct?
15:25:08 <arkeet> it doesn't quite follow.
15:25:55 <Bor0> arkeet, in what part specifically?
15:26:08 <arkeet> where is the contradiction?
15:26:24 <Bor0> we are given a group and a homomorphism on it. the homomorphism depends on commutativity
15:26:35 <arkeet> ?
15:26:43 <Bor0> we show that the homomorphism depends on this, thus the group must be commutative
15:26:48 <arkeet> ??
15:26:55 <arkeet> you say there is a contradiction.
15:26:57 <arkeet> what is the contradiction?
15:27:06 <Bor0> our assumption that (G, *) isn't commutative
15:27:16 <arkeet> no, that's not a contradiction.
15:27:20 <arkeet> there are lots of groups that aren't commutative.
15:27:42 <Bor0> with homomorphisms that commute?
15:28:09 <arkeet> okay, start again.
15:28:50 <arkeet> okay, where are you showing that the group is commutative?
15:29:02 <Bor0> we have a group (G, *) along with a homomorphism f :G -> G, f(x) = x^3
15:29:06 <arkeet> yes
15:29:21 <Bor0> by using f(a*b) = f(a)*f(b), I derive f(a)f(b) = f(b)f(a) => (ab)^3 = (ba)^3 => e = (ba)^3 (ab)^(-3)
15:29:58 <Bor0> ok until here?
15:30:28 <arkeet> I thought you were going to assume that G isn't commutative.
15:31:12 <Bor0> I did in my original statement, but forgot now :)
15:31:35 <maxx-> is it possible to write something similar to clojure's # macro with template haskell? #(str 0 % 8) (syntax in clojure, I don't care about exact syntax as long as it is concise)  is equal to \x -> str 0 x 8
15:31:36 <Bor0> ok, so we have a group (G, *) and homomorphism f. we assume this group isn't commutative. by using f(a*b)... derive e = (ba)^3 (ab)^(-3)
15:31:44 <arkeet> what are a and b?
15:31:49 <Bor0> elements in G
15:32:09 <arkeet> arbitrary elements?
15:32:13 <Bor0> yes
15:33:50 <Bor0> arkeet, maybe I should mention that explicitly?
15:34:56 <whittle> I’m using Tasty to run some HUnit tests. One of them tests a function that takes a String as an argument, and I’d like to read the string in from the file. What’s the best way to fit an arbitrary IO action into Tasty + HUnit? 
15:35:26 <Clint> liftIO
15:35:34 <kynan_> does anyone here know how to use Linear.V to make arbitrary-dimensional vectors?
15:37:55 <Taneb> This comment is amusing: https://github.com/simonmar/monad-par/blob/e092d6ef30a64d98bdaaab3a29796a85b3474f14/monad-par/Control/Monad/Par/Scheds/Direct.hs#L292
15:39:28 <juanca_> how can i check the version of a package in a sandbox
15:39:29 <juanca_> ?
15:41:02 <Enigmagic> juanca_: `cabal sandbox hc-pkg list`
15:41:14 <Denommus> is there a syntax for exclusive ranges?
15:41:24 <pdxleif> ghc-pkg?
15:41:31 <juanca_> Enigmatic: thanks i had only found it for global intallations
15:41:38 <shaleh> maxx-: does this link http://stackoverflow.com/questions/392733/haskell-lisp-and-verbosity provide enough Haskell v. Closure info if you read and follow externals?
15:43:49 <Chobbes> How do you link to a specific function on hackage? Or can you?
15:44:20 <ThermalSpan> Hey, has anyone used / read "Programming in Haskell" by Hutton?
15:44:33 <frerich> ThermalSpan: Yes, I have.
15:44:57 <shaleh> Chobbes: this KINDA works https://hackage.haskell.org/package/hsgsom-0.2.0/docs/Data-Datamining-Clustering-Gsom-Lattice.html#v:newRandom
15:44:59 * hackagebot pandoc-types 1.12.4.3 - Types for representing a structured document  http://hackage.haskell.org/package/pandoc-types-1.12.4.3 (JohnMacFarlane)
15:45:59 <Chobbes> shaleh: ah thanks. Got it sorted out :). Really hope an easy way gets added some day!
15:46:10 <shaleh> Chobbes: agreed
15:46:23 <ThermalSpan> frerich: I have a question about the source code for chapter 8. http://www.cs.nott.ac.uk/~gmh/Parsing.lhs , I have not been able to figure out what the 'P' instance of MonadPlus is for, yet it seems to be a constructor for her Parser? I may have multiple ideas jumbled.
15:47:22 <maxx-> shaleh I'll read it fully in a bit.. but from the little I've read so far I don't think this is possible with functions generally, which is what general thought seem to be there, to replace macros with functions? you can do it with lambda, but I would like to make it more concise. partial application is much nicer than clojure's # in most cases, but sometimes # equivalent would be nicer. I am just curious if this is possible with Template Haskell, and if it is w
15:47:45 <frerich> ThermalSpan: You mean the 'Parser' instance, right? 'P' is just the (data) constructor name.
15:48:27 <shaleh> maxx-: in words rather than code, what are you trying to achieve in that code example?
15:48:48 <Chobbes> shaleh: yeah, I always expect Hackage to do something like what the Python docs do (Little paragraph symbol when you hover over) https://docs.python.org/3/library/glob.html#glob.glob
15:49:06 <maxx-> (for example you can't use partial application in here.  (\x -> f 1 x 2). you could use flip but that is probably uglier than lambda
15:49:40 <maxx-> shaleh I would like to make this more concise using template haskell: (\x -> f 1 x 2). it should look similar to this: #(f 1 % 2), where % should be replaced with the first argument
15:49:49 <ThermalSpan> frerich: So 'P' is first defined by 'newtype Parser a =  P (String -> [(a,String)])'? I was confused becuase I also found an instance of Monad, 'P', here https://hackage.haskell.org/package/base-4.5.1.0/docs/Control-Monad.html
15:50:06 <frerich> ThermalSpan: Yes, right - 'P' is defined by that newtype.
15:50:17 <ThermalSpan> frerich: Thanks!
15:50:18 <shaleh> maxx-: but why isn't that just a wrapper function?
15:51:05 <maxx-> it is
15:51:44 <tempname11_> maxx-: Why not use the lambda?
15:51:55 <arkeet> maxx-: at least you'd need a splice and a quasiquote, so like
15:52:20 <arkeet> $(foo [bar|f 1 ^ 2|])
15:52:29 <arkeet> where bar is a quasiquoter
15:52:34 <arkeet> f 1 % 2 sorry.
15:52:36 <maxx-> tempname11_ I am currently, but I am wondering if we can use template haskell to make a more concise lambda syntax. I don't care about a variable name, so it is little more than a noise there
15:52:40 <arkeet> this looks longer than \x -> f 1 x 2
15:52:55 <maxx-> arkeet I see
15:54:08 <maxx-> are you talking about implementation or usage of such a template? I never wrote a single line of template haskell
15:54:44 <shaleh> maxx-: what do you want your haskell code to look like?
15:54:50 <shaleh> maxx-: in a perfect world
15:55:31 <Cale> maxx-: Pretty much "no"
15:55:45 <maxx-> something like this: $(fn f 1 % 2)
15:55:57 <Cale> nope, that's not going to happen
15:56:13 <arkeet> the thing inside $() has to be a valid expression
15:56:37 <Cale> In order to reinterpret the % as something other than an infix operator, you'll have to use a quasiquoter, which will already use more characters than the lambda would have
15:56:59 <arkeet> actually, couldn't one get rid of the leading thing 
15:57:04 <arkeet> and write something like
15:57:10 <arkeet> $([l|f 1 % 2|])
15:57:14 <arkeet> noisy
15:57:43 <arkeet> (\x->f 1 x 2)
15:57:45 <arkeet> this is fewer characters
15:58:03 <arkeet> may as well just go with that
15:58:05 <arkeet> also for clarity
15:58:42 <maxx-> yeah lambda is clearer than above
15:59:22 <shaleh> and if you use it frequently you name it and it is not a lambda.....
16:01:22 <arkeet> Bor0: you can just show G is commutative directly.
16:03:18 <Bor0> arkeet, the way I showed it is commutative is correct? I understand the form can be improved
16:03:55 <arkeet> no
16:04:02 <arkeet> you didn't show that two arbitrary elements commute
16:04:09 <maxx-> do calls to template haskell always have to start with $? can we define new characters?
16:04:15 <Bor0> arkeet, but what about the part where a' b' = b' a' = e?
16:04:23 <arkeet> a' and b' aren't arbitrary
16:04:38 <arkeet> (if they were, you just mistakenly proved taht any two elements are inverses)
16:04:53 <arkeet> (which is obviously wrong)
16:05:08 <arkeet> but
16:05:10 <Bor0> if a and b are arbitrary, then (ba)^3 and (ab)^(-3) are arbitrary as well, no?
16:05:15 <arkeet> no
16:05:29 <Bor0> why?
16:05:49 <arkeet> you cannot write any pair of elements as (ba)^3 and (ab)^-3 for the same a an db.
16:05:52 <arkeet> and b
16:06:14 <arkeet> the function mapping (a,b) to ((ba)^3, (ab)^-3) is not surjective.
16:06:15 <Bor0> but using f : G -> G, you have that f(a * b) also belongs in G
16:06:49 <arkeet> (unless G is the trivial group)
16:07:02 <arkeet> here's how you prove G is commutative:
16:07:07 <arkeet> let x and y be arbitrary elements of G.
16:07:08 <arkeet> show that xy = yx
16:07:16 <athan> HM is weird. In the untyped LC, any sub expression can eta-reduce, while in HM, eta conversion can only happen on the outer-most abstractions. weirddd
16:08:04 <arkeet> you can't just let x = (ba)^3 and y = (ab)^-3 without justification.
16:08:26 <Bor0> that's the part that puzzled me as well, that's why I mentioned it bbefore :)
16:08:36 <arkeet> what you can do chose a and b such that x = f(a) and y = f(b), because f is surjective
16:08:39 <arkeet> and work from there
16:09:02 <Bor0> but, xy = f(a)f(b), as I supposed
16:09:20 <arkeet> what about it?
16:09:37 <Bor0> in this part specifically "f(a)f(b) = f(b)f(a) => (ab)^3 = (ba)^3 => e = (ba)^3 (ab)^(-3)"
16:09:48 <arkeet> uh
16:09:49 <Bor0> maybe I need to be explicit about the surjection though
16:09:56 <arkeet> are you assuming f(a) f(b) = f(b) f(a)?
16:10:26 <arkeet> because assuming the very thing you are trying to prove gets you nowhere.
16:10:43 <Bor0> right, I see
16:11:11 <arkeet> however, those => are in fact equivalences
16:11:16 <arkeet> so if you can show that e = (ba)^3 (ab)^-3
16:11:20 <arkeet> then it will work
16:11:56 <Bor0> yea, maybe writing it the other way around will make things clearer
16:12:08 <Bor0> start from e = ... and build to f(a)f(b) = f(b)f(a)
16:12:21 <arkeet> sure, but you can't start from there.
16:12:30 <arkeet> it needs to be proved.
16:12:40 <Bor0> ok, can you proceed? what do you do to show xy = yx?
16:12:49 <arkeet> is this homework?
16:13:00 <Bor0> no, it's posted on a facebook group I'm following
16:13:05 <arkeet> ok well
16:13:16 <arkeet> we need to show that e = (ba)^3 (ab)^(-3)
16:13:58 <arkeet> well, the important thing to notice here is that
16:14:17 <arkeet> uh
16:14:24 <arkeet> let me make sure I have it worked out properly
16:14:26 <arkeet> before I talk
16:14:54 <Bor0> yeah :D I'm reading haskell road, so I'm playing around with proofs. I'm not much experienced
16:15:01 * hackagebot acme-timemachine 0.0.0.1 - An easy way to perform and unperform IO actions.  http://hackage.haskell.org/package/acme-timemachine-0.0.0.1 (mniip)
16:15:04 <Bor0> so I found this one and thought it's nice to play with it
16:16:05 <Bor0> but it doesn't seem to be that trivial. I wrote down all the definitions for a group, surjection, and homomorphism. can't see the link between them. probably associativity has to be used in a way since other proofs I saw related to commutativity related on that
16:16:24 <arkeet> it needs some creativity.
16:16:27 <Bor0> s/related on that/were related to that/
16:16:38 <Bor0> :)
16:16:43 <arkeet> you're already implicitly using assiciativity everywhere.
16:17:12 <Bor0> how?
16:18:11 <arkeet> like the proof that (ab)^-1 = b^-1 a^-1 needs it.
16:19:52 <Bor0> can you elaborate? I don't know about that proof
16:19:59 <arkeet> maybe you should try proving that.
16:24:42 <Pamelloes> There's no easy way to turn f (m a) into m (f a), correct?
16:24:46 <arkeet> what are f and m?
16:25:02 <Bor0> arkeet, you mean, target for (ab)^-1 = b^-1 a^-1?
16:25:18 <arkeet> Bor0: no, I just mean prove that fact, for arbitrary elements a,b of any group.
16:25:18 <Pamelloes> arkeet: I think they are both monads.
16:25:31 <arkeet> Pamelloes: what are f and m exactly?
16:25:40 <Bor0> I don't see where that could help
16:25:47 <wrengr> When using DataKinds, is there a way to define a type (i.e., data constructor of the unlifted data type which will be lifted to our new kind) which takes arguments of kind * ?
16:25:53 <arkeet> Bor0: forget about the main problem.
16:25:55 <arkeet> just try to prove that
16:26:14 <Bor0> arkeet, so you are stating that this is a property that holds for any group?
16:26:17 <Pamelloes> arkeet: Alright, I'm sure now—they are both monads :)
16:26:20 <wrengr> i.e., data MyKind = BasicStuff | RecursiveStuff MyKind | CanIDoTHis *
16:26:33 <arkeet> wrengr: not yet.
16:26:36 <arkeet> Bor0: yes, and you should know it.
16:26:48 <wrengr> hrm :(
16:26:55 <Bor0> arkeet, I don't. I wasn't formally introduced to this. I'll check it and see how it goes :) thanks
16:26:58 <athan> I am the monad wrangler
16:27:12 <arkeet> wrengr: https://ghc.haskell.org/trac/ghc/wiki/GhcKinds/KindsWithoutData
16:27:16 <Bor0> arkeet, I know that property holds for regular everyday algebra, just not for group theory
16:27:20 <arkeet> Pamelloes: but it doesn't matter that they are both monads.
16:27:29 <arkeet> Pamelloes: are they specific things?
16:27:41 <arkeet> Bor0: prove it.
16:28:00 <arkeet> this is one that you can do just from the definitions and basic properties.
16:28:13 <arkeet> Pamelloes: such a thing doesn't exist for *arbitrary* monads.
16:28:34 <arkeet> tell me everything you know about f
16:28:35 <arkeet> and about m
16:28:44 <arkeet> ("they're monads" isn't enough)
16:30:56 <Pamelloes> arkeet: m is a MonadIO. I just realized that f is just an algebraic data structure, It's a reflex Dynamic t to be specific: https://github.com/ryantrinkle/reflex/blob/master/src/Reflex/Dynamic.hs
16:31:22 <Pamelloes> arkeet: From what I can tell it looks like I'm out of luck.
16:31:27 <arkeet> I think I agree.
16:31:34 <arkeet> if f were Traversable, then you could use
16:31:35 <arkeet> :t sequence
16:31:36 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
16:31:52 <arkeet> but I'm pretty sure it's not.
16:32:01 <Pamelloes> It isn't.
16:32:27 <Pamelloes> But that is a good point, I might be able to work something out along those lines.
16:33:13 <wrengr> arkeet: thanks
16:33:36 <maxx-> > length Nothing
16:33:38 <lambdabot>  0
16:33:48 <maxx-> fun :P
16:34:10 <glguy> > length ((),())
16:34:12 <lambdabot>  1
16:34:18 <arkeet> owl face.
16:34:43 <maxx-> o rly
16:36:00 <maxx-> but it makes sense. Maybe is like a list with a maximum of 1 element
16:36:32 <arkeet> > length Proxy
16:36:34 <lambdabot>  0
16:36:43 <arkeet> Prox is like a list with at most 0 elements.
16:36:46 <arkeet> Proxy
16:36:47 <whittle> :t length
16:36:48 <lambdabot> Foldable t => t a -> Int
16:38:33 <Bor0> arkeet, something like this? ab(ab)^-1 = e. left multiply by a^-1 => b(ab)^-1 = a^-1e. left multiply by b^-1 => (ab)^-1 = a^-1b^-1
16:39:26 <arkeet> sure.
16:39:28 <Bor0> err, left multiply by b^-1 => (ab)^-1 = b^-1a^-1
16:39:35 <arkeet> or you can just prove directly that (ab)(a^-1 b^-1) = e
16:39:38 <arkeet> er
16:39:42 <arkeet> or you can just prove directly that (ab)(b^-1 a^-1) = e
16:39:48 <Bor0> :D
16:39:56 <arkeet> but that requires associativity.
16:39:57 <arkeet> (why?)
16:40:02 * hackagebot elocrypt 0.4.0 - Generate easy-to-remember, hard-to-guess passwords  http://hackage.haskell.org/package/elocrypt-0.4.0 (sgillespie)
16:40:02 <Bor0> let me try it
16:48:41 <arkeet> > length (long cat) == long
16:48:43 <lambdabot>  True
16:48:57 <bitemyapp> @ty long
16:48:59 <lambdabot> Long a => a
16:48:59 <bitemyapp> @ty cat
16:49:00 <lambdabot> [Doc] -> Doc
16:49:03 <bitemyapp> ...
16:49:16 <arkeet> :-)
16:50:12 <barrucadu> > length $ long []
16:50:13 <lambdabot>  9001
16:50:21 <barrucadu> That is pretty long
16:51:11 <arkeet> exercise: figure out how I did it.
16:51:28 <arkeet> (it's not that hard.)
16:51:31 <barrucadu> I guess there's a Long instance for [] and a Long instance for a -> []
16:51:40 <arkeet> almost.
16:51:46 <arkeet> :t length
16:51:47 <lambdabot> Foldable t => t a -> Int
16:51:58 <bitemyapp> somebody's going to use this as an argument against typeclasses.
16:52:01 <arkeet> :-)
16:52:44 <arkeet> http://lpaste.net/8063137500022964224
16:53:04 <arkeet> :r
16:53:06 <bitemyapp> arkeet: https://gist.github.com/etrepum/cd7a52537eb37177970b
16:53:11 <arkeet> guess FlexibleInstances isn't needed.
16:53:18 <bitemyapp> not really relevant, but thought you'd enjoy it.
16:53:32 <arkeet> too long for my tired brain to think about atm.
16:54:08 <hodapp> I was surprised to see that Coq has typeclasses too.
16:54:09 <Bor0> arkeet, ok, I think I see it. start by right multiply by a => (ab)(b^-1 a^-1)a = ea => (ab)b^-1 = ea. this is where we used associativity. then proceed by right multiplying by b: (ab)b^-1b = eab => (ab)e = e(ab)
16:54:15 <hodapp> I thought they were something of a Haskell-ism.
16:55:21 <Bor0> this is where we used associativity => (ab)(b^-1 a^-1)a = (ab)b^-1(a^-1 a) = ea
16:55:32 <arkeet> you don't need to multiply on the right.
16:55:49 <arkeet> I think you're mixing up the two proofs.
16:56:04 <bitemyapp> hodapp: first class or the MPTC embedding?
16:56:23 <hodapp> bitemyapp: hmmm, I'm not sure.
16:56:24 <Bor0> arkeet, ah, so you meant something like (ab b^-1)a^-1 ?
16:56:31 <Bor0> (without multiplying)
16:56:42 <arkeet> a bit more parentheses than that.
16:56:47 <hodapp> bitemyapp: What is MPTC embedding?
16:57:01 <Bor0> I see
16:57:11 <Bor0> what two proofs did you mean?
16:57:17 <arkeet> yours and mine.
16:57:33 <Bor0> ok
16:58:06 <Bor0> so, having proved this property for all groups, are there other interesting properties I could play with? (forget about the main problem, I need to run through these baby steps first I guess :-)
16:58:22 <arkeet> read a textbook on group theory
16:58:31 <Bor0> can you recommend one?
16:58:37 <arkeet> Dummit & Foote is popular.
16:58:49 <Bor0> is it specific to group theory or abstract algebra?
16:59:05 <bitemyapp> hodapp: I probably fucked up the acronym, but: http://www.mpi-sws.org/~dreyer/papers/mtc/main-long.pdf
16:59:19 <arkeet> it's a book on abstract algebra
16:59:28 <arkeet> but it starts with groups
16:59:36 <arkeet> as many introductory algebra texts do
17:00:00 <bitemyapp> hodapp: it's been getting kicked around for almost a decade.
17:00:39 <luzie> https://coq.inria.fr/distrib/current/refman/Reference-Manual022.html
17:00:56 <luzie> apparently very experimental
17:01:25 <bitemyapp> luzie: more or less what I'd expect.
17:01:31 <LordBrain> hey, i'm getting an error about missing an IsString instance when I try to use string literals with Socket.Network.ByteString.send
17:01:54 <LordBrain> The issue appears to be it is expecting the internal bytestring
17:02:54 <LordBrain>     No instance for (Data.String.IsString
17:02:54 <LordBrain>                        bytestring-0.9.2.1:Data.ByteString.Internal.ByteString)
17:03:10 <bitemyapp> that's a somewhat old version of bytestring.
17:03:11 <Cale> LordBrain: Do you have more than one version of bytestring installed?
17:03:13 <LordBrain> what would be a work around for this?
17:03:18 <bitemyapp> not saying that's causing your problem, but it's suspicious.
17:03:22 <LordBrain> oh, yes i probably do
17:03:26 <bitemyapp> LordBrain: are you using sandboxes?
17:04:01 <Cale> The explicit package qualification is a sign that you have more than one Data.ByteString.Internal.ByteString in scope
17:04:04 <LordBrain> no, but i would like to keep it that way for now...
17:04:14 <LordBrain> hmmm
17:04:34 <LordBrain> ok, well i can just up the version of bytestring required in the cabal file, and that might fix it
17:04:42 <Cale> Well, before we deal with that, easier thing: try importing Data.ByteString.Char8 ?
17:05:08 <Cale> If it's already imported, then the problem is definitely that you're using packages which were built against more than one different version of the ByteString package.
17:05:11 <glguy> It's more likely to be what Cale said, the IsString instance is in the package itself
17:05:23 <glguy> so it's not going to be related to multiple versions
17:05:50 <glguy> version 0.9.2.1 had that instance
17:06:31 <LordBrain> i see, i did get warned about this from cabal
17:06:41 <LordBrain> but everything was working until now
17:07:05 <LordBrain> i hate building a sandbox for ever little project
17:07:51 <hodapp> LordBrain: let us know if you find a good way around it :-/
17:08:55 <LordBrain> i don't think i will... i think i am forced to use a sandbox
17:09:17 <LordBrain> or break other projects
17:09:29 <hodapp> I keep running into crap where I can't coax haskell-mode on Emacs into using a sandbox.
17:10:20 <athan> Anyone here mess with the yaml library?
17:10:28 <athan> I can't seem to get it to parse `Maybe String`s
17:10:36 <athan> hodapp: o/
17:10:39 <hodapp> athan: hiya!
17:10:55 <athan> hodapp: Might have found a job! (finally ._.)
17:11:12 <LordBrain> Oh i found a work around, for htis!
17:11:24 <LordBrain> instead of upgrading the bytestring used in cabal, i downgraded
17:11:28 <maxx-> hodpp is that a known issue? I am about to start using sandboxes for the first time, and it would suck if it means i can't test my programs in emacs
17:11:50 * sm resists the urge to leap blindly into a cabal-install support discussion
17:11:55 <LordBrain> ie, i put a maximum version for bytestring in the cabal file
17:12:13 <LordBrain> lol sm
17:12:17 <arkeet> crazy idea but what if you cabal exec emacs
17:12:21 <arkeet> from the sandbox
17:12:52 <ReinH> hodapp: weird, I haven't had any issues
17:13:07 <ReinH> Is your haskell-mode old?
17:14:35 <LordBrain> oh nevermind i was looking at the wrong file, no cabal foo is getting me thru this other htan a sandbox probably
17:17:11 <hodapp> maxx-: I don't know. Every day at work I use haskell-mode with a cabal sandbox, but I could not figure out the other day how to make this work on my Macbook with a freshly-created project.
17:17:21 <hodapp> ReinH: This was git master as of Tuesday.
17:17:30 <ReinH> hodapp: huh
17:17:42 <ReinH> hodapp: Do you have it configured to use cabal repl?
17:17:49 <ReinH> What actually is the issue?
17:17:59 <ReinH> Have you tried asking folks in #haskell-emacs?
17:18:00 <hodapp> ReinH: the issue is that it will simply not run it inside the sandbox I request.
17:19:40 <LordBrain> even in a sandbox i have indirectly depending on multiple versions of text
17:19:59 <LordBrain> primarily due to someone using parsec
17:19:59 <hodapp> ReinH: I'll go check if it's configured to use cabal repl or not...
17:21:53 <hodapp> ReinH: I should then have haskell-ghci-program-name and haskell-ghci-program-args set to "cabal", '("repl")?
17:23:55 <LordBrain> i vaguely recall someone set up a website that let you browse package dependencies, what was the link to that?
17:24:13 <johnw> http://packdeps.haskellers.com
17:24:15 <LordBrain> i wanat to search for the latest version of package satisfying some dependency
17:24:22 <hodapp> Telling it to create a new project fails and in haskell-process-log gives me: "cabal: No cabal file found."
17:25:04 * hackagebot persistent-template 2.1.3.2 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-2.1.3.2 (GregWeber)
17:25:57 <LordBrain> damn, i don't get how to do this search johnw
17:26:36 <johnw> there's a pretty easy(ish) way to ask anything you want, if you're willing to download some data and write some Haskell
17:27:47 <LordBrain> i want the latest version of parsec satisfying "text >= 0.8 && <1.3"
17:28:07 <johnw> yeah
17:28:17 <johnw> so, here's what I'd do, given about 4 hours of time:
17:28:23 <johnw> 1. mirror hackage, using https://github.com/jwiegley/hackage-mirror
17:28:36 <johnw> 2. write a Haskell script to snarf out all package numbers and version bounds
17:28:47 <johnw> 3. use SBV to build a model
17:28:49 <funfunctor> Hey
17:28:52 <johnw> 4. pose your query exactly as you stated it
17:29:03 <funfunctor> Is there any Fay folks about? #fay is pretty dead
17:29:22 <johnw> i'm pretty sure ghcjs is murdering fay in its sleep
17:29:46 <funfunctor> johnw: ?
17:30:09 <Axman6> Fay and ghcjs serve different markets
17:30:10 <LordBrain> considering how common this issue must be, i was kind of hoping there would be a rolled solution
17:30:10 <funfunctor> also, Hi ! Hope you are well
17:30:23 <johnw> there might be, I don't know it
17:30:49 <Axman6> LordBrain: delete sandbox, reinit it, then cabal install --only-dependencies ensures you get consisten deps (or a failing build)
17:30:50 <athan> woohoo! It works! https://github.com/ltext/ltext
17:30:54 <athan> #trashswag
17:31:19 <athan> :x crap sorry guys I thought I was in -blah
17:31:20 <funfunctor> Fay seems simpler to me
17:31:31 <funfunctor> My use case is really small any way
17:33:00 <funfunctor> Axman6: I just have this I would like to know how to turn into Fay http://lpaste.net/133528
17:33:22 <LordBrain> Axman6, so?...: rm -Rf .cabal-sandbox cabal.sandbox.config
17:33:24 <Axman6> athan: looks cool, might be useful for some of the AWS config stuff we're doing
17:33:26 <funfunctor> Just need a bit of a kick start
17:33:46 <LordBrain> anything i missed?
17:33:50 <Axman6> LordBrain: cabal sandbox delete; cabal sandbox init; cabal install --only-dependencies
17:33:57 <LordBrain> ooooooh great, thanks
17:34:26 <eacameron> my function has an `IO a` as an argument. How can I run the IO and force a to be evaluated?
17:34:38 <athan> Axman6: Ooh! Awesome :) I just uploaded 0.0.0.1 to hackage!
17:34:44 <LordBrain> Axman6, why didn't it do this the first time without --dependencies-only?
17:35:04 * hackagebot persistent-template 2.1.3.3 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-2.1.3.3 (GregWeber)
17:35:07 * hackagebot ltext 0.0.0.1 - Higher-order file applicator  http://hackage.haskell.org/package/ltext-0.0.0.1 (athanclark)
17:35:07 <athan> Axman6: Partial application isn't right yet, though. Once I work around that, it should be fairly usable
17:35:09 * hackagebot hsb2hs 0.3 - Preprocesses a file, adding blobs from files as string literals.  http://hackage.haskell.org/package/hsb2hs-0.3 (JohnMacFarlane)
17:35:49 <LordBrain> hand picking all the dependencies listed by cabal and listing them out manually is not as good as --dependencies-only  ?
17:36:07 <Axman6> it just instyalls the deps, not the current package, that's all
17:36:35 <LordBrain> oh, using the bottom of hte dependency range rather than the top?
17:37:00 <Axman6> eh?
17:37:02 <athan> Axman6: Wait are you talking about ltext?
17:37:09 <Axman6> no
17:37:13 <sm> LordBrain: it's documented..
17:37:14 <athan> oh :x srryyy
17:37:48 <sm> LordBrain: also, --dry is a great option for cabal install to see what it plans to do
17:37:52 <ronh-> eacameron, `f mx = do x <- mx; ...'
17:38:26 <sm> and --constraint, to try tweaks to the plan
17:39:03 <LordBrain> ok
17:39:25 <LordBrain> well, that fixed it so, but apparently syntastic in vim doesnt understand sandboxes :(
17:40:01 <DrPavelheer> Yesod or Snap?
17:40:26 <mgsloan> funfunctor: Fay is indeed simpler than GHCJS.  However, Fay pretty much just shares the syntax and type system with GHC (without typeclass methods).  The semantics is different and marshalling is a bit magical.  GHCJS matches GHC's semantics, which is really awesome.  It feels like proper Haskell for the browser.  The FFI marshaling is less magical, and so less convenient, but also easier to think about, IMHO 
17:40:42 <Axman6> that's a terrible question DrPavelheer 
17:41:17 <DrPavelheer> what makes you say that?
17:41:20 <mgsloan> That's been my experience, anyway, after writing a bit more than 1K lines of GHCJS after writing many kloc with fay back in the day
17:42:16 <Axman6> because it's lazy - it is of the form "make my decisions for me". if you wanted a decent answer you would at the very least ask "I want to make X, would Snap or Yeson be better?"
17:42:21 <Axman6> d*
17:43:33 <LordBrain> i'm not good with vimscript, i tried this but it doesn't work: https://gist.github.com/yuga/6612105
17:43:53 <LordBrain> unless there is some thing i have to do to activate it besides restarting vim
17:44:58 <DrPavelheer> hmm. i'm really just trying to learn web dev using haskell
17:45:34 <ReinH> hodapp: um, maybe? one sec.
17:45:37 <hodapp> am I invoking interactive-haskell-mode functionality completely wrong? I have been doing C-c C-l on the Haskell file
17:45:49 <LordBrain> Does anyone here use vim syntastic with sandboxes?
17:46:08 <athan> LordBrain: I just use vim and also use sandboxes :x
17:46:16 <hodapp> and do those two variables even do anything when it's interactive-haskell-mode I'm talking about? I also just tried (setq haskell-process-type 'cabal-repl).
17:46:27 <ReinH> hodapp: I guess I just have (haskell-process-type ('cabal-repl))
17:46:46 <ReinH> hodapp: btw you can use customization to set that
17:46:58 <ReinH> M-x customize-group<RET> haskell
17:47:04 <hodapp> ReinH: I saw both ways and didn't bother to look at why the longer way had a point
17:47:07 <sm> DrPavelheer: they are close enough that many folks feel giving a simple answer. Generally yesod is considered a bit more full-featured and heavy
17:47:12 <ReinH> Also #haskell-emacs is a real place with real people that actually know these things :)
17:47:20 <hodapp> ReinH: I don't seem to get answers there
17:47:23 <ReinH> :(
17:47:24 <sm> s/feel/feel uncomfortable/
17:48:57 <hodapp> At some point it is going to be easier to just hack up the code myself so I can explicitly call cabal the way I want to, instead of futzing around with all this crap where I'm trying to trick it into starting cabal the right way.
17:49:42 <hodapp> running 'cabal repl' from the sandbox directory works fine, running 'cabal --sandbox-config-file=... repl' from elsewhere works fine
17:50:10 <hodapp> it's clearly *calling* cabal in some form, because if there is no .cabal file there, it hollers at me
17:51:47 <ReinH> hodapp: suggest nuking your emacs config from space and trying again. ;)
17:53:37 <hodapp> ReinH: just did that; no change.
17:54:40 <ReinH> hodapp: :(
17:54:44 <ReinH> hodapp: unsure
18:01:15 <hodapp> ReinH: sigh, it seems OS X is mucking up something. If I run Emacs from Finder, nothing seems to work right. If I run it from commandline, it seems to work okay.
18:01:22 <hodapp> and I already verified that it's using the same version of Cabal.
18:01:52 <ReinH> hodapp: well, happy to be of zero assistance to you :D
18:02:38 <hodapp> ReinH: thanks for being patient nonetheless.
18:02:39 <bitemyapp> hodapp: my Emacs Haskell stuff works (tm)
18:02:42 <bitemyapp> hodapp: https://github.com/bitemyapp/dotfiles
18:02:48 <m_ryan> hi is there's a way to get the currentURL in yesod?
18:02:51 <bitemyapp> hodapp: https://github.com/bitemyapp/dotfiles/blob/master/.emacs.d/haskell/haskell-config.el
18:02:52 <hodapp> bitemyapp: mine works(tm) too, just not until now on my Macbook
18:02:57 <bitemyapp> hodapp: Linux and Mac OS X.
18:03:05 <bitemyapp> hodapp: I used that very config a couple hours ago at work on a Mac.
18:03:12 <bitemyapp> hodapp: diff & rectify accordingly.
18:03:29 <bitemyapp> it doesn't have a lot of whiz-bang, but the buffer loading/REPL works.
18:03:50 <hodapp> bitemyapp: which Emacs on OS X, and invoked how?
18:04:01 <hodapp> bitemyapp: because it's now working for fine for me... if I run it from CL:I
18:04:03 <hodapp> CLI*
18:04:12 <bitemyapp> brew tap railwaycat/emacsmacport && brew install emacs-mac
18:04:22 <bitemyapp> I use graphical, never CLI.
18:04:41 <bitemyapp> I keep my config working at all times on Linux & Mac in parallel. That git repo stays up to date.
18:04:42 <hodapp> okay, I am not using brew.
18:04:54 <bitemyapp> hodapp: it works with Emacs for Mac OS X too.
18:05:01 <bitemyapp> I also know that because I used it today.
18:05:35 <bitemyapp> seriously, I'm way wayyyyyy finickier about "just works" for my Emacs config than most programmers. Give it a look and see what's different about my haskell config and yours.
18:06:01 <bitemyapp> for more fancy, but less "just works" - https://github.com/chrisdone/emacs-haskell-config
18:06:17 <johnw> or even less: https://github.com/jwiegley/haskell-config
18:08:41 <hodapp> bitemyapp: I made two changes: I updated the path of haskell-mode, and I removed the 2nd line.
18:08:50 <hodapp> bitemyapp: That config is exhibiting the same problems as mine.
18:09:38 <bitemyapp> hodapp: whut.
18:09:40 <hodapp> bitemyapp: that is: it is blatantly ignoring the sandbox in the working directory that I give it.
18:09:58 <bitemyapp> I've had that problem before, but not with this config. I use sandboxes (including non-standard ones) in my work.
18:10:06 * hackagebot nagios-check 0.3.1 - Package for writing monitoring plugins  http://hackage.haskell.org/package/nagios-check-0.3.1 (fractalcat)
18:10:38 <hodapp> bitemyapp: I just tried the very same configuration when running from CLI rather than Finder.
18:10:54 <hodapp> bitemyapp: and in this case (as with my own configuration) it works.
18:11:45 <bitemyapp> Ow. I don't know then.
18:12:00 <bitemyapp> At that point I'd start asking questions about my version of haskell-mode, my pathing, cabal sandbox config, etc.
18:12:37 <hodapp> that's all identical between your configuration and mine, and between running OS X from Finder and from commandline.
18:13:02 <hodapp> (in the sense that, when I run your config here, I have changed none of that)
18:13:58 <Imagine> If I have a list of functions and I want to apply all of them to one argument, is there a good way to do that?
18:14:11 <bitemyapp> I'd second ReinH's suggestion and say you should ask in #haskell-emacs, but they're going to ask you to run down the information I've listed anyway.
18:14:17 <Imagine> I was thinking some sort of map
18:14:45 <ReinH> :t \x -> map ($ x)
18:14:47 <lambdabot> a -> [a -> b] -> [b]
18:14:52 <ReinH> Imagine: ^
18:14:52 <hodapp> bitemyapp: I'll just run Emacs from the commandline rather than Finder, rather than bother with that.
18:15:03 <Imagine> ooh hadn't thought of ($) 
18:15:04 <Imagine> thanks
18:15:07 <ReinH> Imagine: :)
18:15:10 <hodapp> bitemyapp: it's still *graphical* Emacs, just started in a less pointy-clicky way.
18:15:38 <Imagine> ReinH, for instructional purposes, if I wanted to apply two arguments
18:15:41 <Imagine> should I just do that twice?
18:15:46 <Imagine> (like with two different maps?)
18:15:50 <Imagine> or is there a better way
18:16:02 <johnw> map ($ x y)
18:16:19 <Imagine> that doesn't apply y to x?
18:16:25 <c_wraith> yes
18:16:27 <johnw> oh, right
18:17:03 <Imagine> (c_wraith - yes to calling map twice?)
18:17:05 <hodapp> bitemyapp: thanks for the config though... might poach some stuff form there :P
18:17:36 <c_wraith> you could do it with two calls to map....  map ($ y) . map ($ x)
18:17:52 <Imagine> okay yeah thats what I was thinking
18:18:00 <hodapp> for some reason I find it super cool to be able to C-u C-c C-t in Emacs and have it insert the type.
18:18:03 <c_wraith> but because of the rules of what map does, you can also write that as map (($ y) . ($ x))
18:18:04 <ReinH> remember that map f . map g = map (f . g) ;)
18:18:10 <mjrosenb> hrmm, haskell still doesn't have disjunctive patterns, does it?
18:18:14 <Imagine> ah yeah
18:18:16 <Imagine> gotcha
18:18:25 <Imagine> ($ y) . ($ x) is quicker too
18:18:28 <Imagine> perfect
18:18:29 <c_wraith> At that point, it's cleaner to use an explicit lambda..  map (\f -> f x y)
18:18:32 <ReinH> Imagine: no, it isn't
18:18:38 <Imagine> it isn't?
18:18:40 <ReinH> @pl \x y -> ($ x) . ($ y)
18:18:40 <lambdabot> flip (flip . flip id)
18:18:48 <ReinH> Imagine: let me prove it to you
18:18:51 <funfunctor> mgsloan: thx
18:18:57 <ReinH> > take 5 . map (+1) . map (+2) $ [1..]
18:18:59 <lambdabot>  [4,5,6,7,8]
18:19:17 <Imagine> okay
18:19:21 <funfunctor> mgsloan: I think if I was looking for magic though I would look at Idris and its JS backend
18:19:27 <ReinH> Imagine: laziness! :D
18:19:33 <Imagine> oh right
18:19:37 <funfunctor> mgsloan: my use case is tiny so I just want simple simple simple
18:19:39 <Imagine> awesome thanks
18:19:41 <johnw> note that ReinH's map ($ x) is also: flip sequence x
18:19:45 <ReinH> Imagine: other languages wish they could automatically perform that optimization. Some of them are able to using coroutines. :)
18:19:53 <ReinH> johnw: :p
18:19:53 <Myrl-chan> Are functions, function composition, id, (<(->) r, ., id>) a monoid?
18:20:28 <johnw> Myrl-chan: only functions that have the same domain and codomain
18:20:37 <ReinH> e.g., Ruby can do (1..Float::INFINITY).to_enum.lazy.select(&:odd?).first 10 because lazy enumerators are implemented using (semi)coroutines
18:20:47 <Myrl-chan> Hmmm...
18:20:52 <ReinH> Myrl-chan: also known as endomorphisms
18:20:55 <ReinH> :t Endo
18:20:56 <lambdabot> (a -> a) -> Endo a
18:21:09 <Myrl-chan> I see.
18:21:11 <ReinH> Endo is the newtype for endomorphisms, functions a -> a
18:21:25 <ReinH> :t foldMap Endo
18:21:26 <lambdabot> Foldable t => t (a -> a) -> Endo a
18:21:45 <bitemyapp> hodapp: cheers :)
18:21:47 <funfunctor> how does on do a body onload with Fay?
18:22:03 <Myrl-chan> Why?
18:23:52 <Imagine> Also - what editor do you guys use? I like atom.io, but I don't think that has a default Haskell builtin
18:23:56 <Myrl-chan> (Why does it have to be an endomorphism)?
18:24:04 <Myrl-chan> Imagine: I use both vim and emacs.
18:24:30 <Imagine> ah of course
18:24:39 <Myrl-chan> The emacs package for Haskell isn't working that well for me. The vim one wasn't that good, but it's better.
18:24:42 <Imagine> I should have guessed that people would use them
18:24:51 <Imagine> I haven't put in the time to learn the shortcuts for vim/emacs
18:24:58 <Imagine> which I guess I should do at some point
18:24:58 <Myrl-chan> Of course, I'm pretty sure that it's because of me not knowing how to use them, rather than it being bad.
18:26:02 <johnw> Myrl-chan: a monoid allows applying <> between any two members of the carrier set.  That is not true for non-endomorphisms
18:26:28 <ReinH> Imagine: atom makes me sad :(
18:26:37 <Imagine> because it doesn't have Haskell?
18:26:41 <Imagine> I really like it for python
18:26:43 <mniip> Myrl-chan, x <> y and y <> x should both exist
18:26:44 <newsham> > Node f [Node g [], Node h []] <*> Node 5 [Node 6 [], Node 7 []]
18:26:46 <lambdabot>      No instance for (Show b0)
18:26:46 <lambdabot>        arising from a use of ‘show_M14408616561127753999136’
18:26:46 <lambdabot>      The type variable ‘b0’ is ambiguous
18:26:59 <ReinH> Imagine: because it has awful performance and a broken plugin ecosystem
18:27:03 <Imagine> uhoh
18:27:07 <Imagine> I haven't used it enough for that yet
18:27:11 <newsham> > Node f [] <*> Node 5 []
18:27:11 <johnw> Myrl-chan: now, your intuition isn't entirely wrong though
18:27:13 <lambdabot>      No instance for (Show b0)
18:27:13 <lambdabot>        arising from a use of ‘show_M60991934864103340509157’
18:27:13 <lambdabot>      The type variable ‘b0’ is ambiguous
18:27:14 <ReinH> I tried to use it on a windows machine for a couple weeks and eventually gave up and installed emacs for windows
18:27:18 <Imagine> (to be fair I downloaded it like last week)
18:27:23 <mniip> newsham, you want an explicit type signature
18:27:32 <newsham> > Node f [] <*> Node a []
18:27:34 <lambdabot>      No instance for (Show b0)
18:27:34 <lambdabot>        arising from a use of ‘show_M35021531385833789729169’
18:27:34 <lambdabot>      The type variable ‘b0’ is ambiguous
18:27:39 <newsham> grr
18:27:42 <ReinH> Myrl-chan: Well, let's look at the type of mappend
18:27:43 <ReinH> :t mappend
18:27:45 <lambdabot> Monoid a => a -> a -> a
18:27:58 <ReinH> Myrl-chan: functions, generally speaking, have the type a -> b for some a and b
18:28:07 <Myrl-chan> Ah
18:28:09 <ReinH> Now, if we want to be able to mappend them, we have to be able to write
18:28:14 <ReinH> (a -> b) -> (a -> b) -> (a -> b)
18:28:15 <newsham> > Node f [] <*> Node a [] :: Tree Expr
18:28:16 <ReinH> but we can't
18:28:17 <lambdabot>  Node {rootLabel = f a, subForest = []}
18:28:22 <ReinH> well, we can, but only if a and b are the same
18:28:31 <johnw> the function type constructor (->) in Hask is a monoidal tensor, but that's not Monoid and is a bit non-trivial to explain
18:28:36 <newsham> > Node f [Node g [], Node h []] <*> Node a [Node b [], Node c []]  :: Tree Expr
18:28:38 <lambdabot>  Node {rootLabel = f a, subForest = [Node {rootLabel = f b, subForest = []},N...
18:28:47 <mniip> ReinH, mappend = const!
18:28:58 <ReinH> mniip: it also has to obey the laws
18:29:01 <mniip> oh wait, id mappending rule is broken
18:29:34 <ReinH> Myrl-chan: similary:
18:29:35 <newsham> thie applicative for trees is kinda weird
18:29:36 <ReinH> :t mempty
18:29:37 <lambdabot> Monoid a => a
18:29:38 <arkeet> you can't have a nontrivial monoid with mappend = const 
18:29:42 <arkeet> because mempty
18:29:48 <ReinH> we need to be able to produce a function of type a -> b from whole cloth
18:29:59 <Myrl-chan> hmm.
18:30:08 <ReinH> Again, we can only do that if a ~ b, where the only available function is id
18:30:19 <ReinH> so functions only form a monoid when they are of type a -> a
18:30:20 <mniip> unsafeCoerce
18:30:24 <mniip> xD
18:30:25 <Myrl-chan> ReinH: ic.
18:30:40 <ReinH> @djinn a -> a
18:30:41 <lambdabot> f a = a
18:30:48 <ReinH> @pl . djinn a -> a
18:30:51 <ReinH> woops
18:30:51 <lambdabot> (line 1, column 1):
18:30:55 <ReinH> @. pl djinn a -> a
18:30:55 <lambdabot> unexpected "."
18:30:59 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
18:31:01 <lambdabot> f = id
18:31:09 <ReinH> sorry
18:31:19 <ReinH> Myrl-chan: does that help?
18:31:23 <newsham> > Data.Tree.levels (Node f [Node g [], Node h []] <*> Node a [Node b [], Node c []]) :: [[Expr]]
18:31:25 <lambdabot>  [[f a],[f b,f c,g a,h a],[g b,g c,h b,h c]]
18:31:34 <Myrl-chan> ReinH: Yeah.
18:31:58 <ReinH> Myrl-chan: (a -> a) functions are the only ones you can compose with each other, and the only ones for which you can construct an empty function from nothing
18:32:35 <Myrl-chan> Yeah
18:32:55 <ReinH> Myrl-chan: if you have some familiarity with category theory, there is a nice equivalence there as well
18:33:02 <ReinH> but it's not at all necessary
18:33:27 <Myrl-chan> I'm actually trying to learn category theory, and I'm grasping groups and monoids better than categories.
18:33:33 <dzack> Anyone happen to use vim2hs with conceals? Seems like the plugin itself uses unicode in its code, and for some reason vim is mangling it
18:33:41 <dzack> https://github.com/dag/vim2hs/blob/f2afd55704bfe0a2d66e6b270d247e9b8a7b1664/autoload/vim2hs/haskell/syntax.vim#L40
18:34:05 <mniip> Myrl-chan, categories are like burritors
18:34:37 <Myrl-chan> mniip: Didn't that start with monads? :P
18:34:50 <mniip> basicaly
18:34:53 <mniip> basically
18:35:28 <albeit_> What triggers a minor garbage collection to occur? Is it a single core running out of space in it's nursery?
18:35:32 <mniip> https://i.imgflip.com/m5ibv.jpg
18:36:01 <spindas> When you're inside (Q Type) in a quasiquoter, is there a nice way to get the Name the type you're generating will be attached to?
18:36:21 <spindas> One that doesn't involve black magic casts with GHC internal types.
18:44:07 <PoJieNie> @pl \f g x y -> f (x ++ g x) (g y)
18:44:07 <lambdabot> join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
18:54:34 <Denommus> PoJieNie: that's the ugliest thing I have seen the entire day
18:54:59 <Denommus> :t \f g x y -> f (x ++ g x) (g y)
18:55:00 <lambdabot> ([a] -> [a] -> r) -> ([a] -> [a]) -> [a] -> [a] -> r
18:55:39 <Imagine> Any good way to turn a string into an integer?
18:55:51 <Imagine> I can do digitToInt
18:55:54 <Denommus> Imagine: read
18:55:55 <Imagine> but that is only for single digits
18:56:02 <mniip> :t (join .) . (. flip id) . flip fmap . (on .) . (. (++)) . (.) 
18:56:03 <lambdabot> ([a] -> [a] -> c) -> ([a] -> [a]) -> [a] -> [a] -> c
18:56:04 <Imagine> oooh okay thanks
18:56:18 <spindas> Imagine: look at "reads" as well
18:56:39 <Denommus> > let x = read "10" in x+10
18:56:40 <lambdabot>  20
18:56:55 <Denommus> > let Just x = reads "10" in x+10
18:56:57 <lambdabot>      Couldn't match expected type ‘Maybe t’
18:56:57 <lambdabot>                  with actual type ‘[(a0, String)]’
18:56:57 <lambdabot>      Relevant bindings include x :: t (bound at <interactive>:1:10)
18:57:02 <spindas> > read "bad"
18:57:04 <lambdabot>  *Exception: Prelude.read: no parse
18:57:15 <spindas> > reads "bad" :: [(Int, String)]
18:57:17 <lambdabot>  []
18:57:20 <spindas> > reads "3bad" :: [(Int, String)]
18:57:22 <lambdabot>  [(3,"bad")]
18:57:26 <spindas> > reads "3" :: [(Int, String)]
18:57:28 <lambdabot>  [(3,"")]
18:57:36 <Denommus> spindas: what's the name of the one that returns a Maybe?
18:57:46 <arkeet> readMaybe
18:57:48 <mniip> Denommus, that feel when you can pointfree by hand
18:58:21 <spindas> Denommus: there's readMay in the safe package: https://hackage.haskell.org/package/safe-0.3.3/docs/Safe.html#v:readMay
18:58:28 <arkeet> there's readMaybe in base
18:58:29 <Denommus> > let Just x = readMaybe "3" in x+10
18:58:31 <lambdabot>  Not in scope: ‘readMaybe’
18:58:36 <spindas> arkeet: is there?
18:58:36 <arkeet> @let import Text.Read
18:58:38 <lambdabot>  Defined.
18:58:40 <arkeet> :t readMaybe
18:58:41 <lambdabot> Read a => String -> Maybe a
18:58:57 <arkeet> yeah, since ghc 7.8 I think
18:59:10 <arkeet> maybe 7.6
18:59:11 <spindas> Ah, thanks
18:59:26 <arkeet> :t readEither
18:59:28 <lambdabot> Read a => String -> Either String a
18:59:42 <arkeet> there's also that, if you care about the text of any errors
19:00:06 <mniip> you can also go cray and use parsec!
19:01:19 <Denommus> > let x = readEither "asdg" in print (print . (+10))
19:01:21 <lambdabot>  <IO ()>
19:01:25 <Denommus> > let x = readEither "asdg" in either print (print . (+10))
19:01:27 <lambdabot>  <Either () Integer -> IO ()>
19:01:41 <Denommus> > let x = readEither "asdg" in either print (print . (+10)) x
19:01:43 <lambdabot>  <IO ()>
19:01:57 <Denommus> > let x = readEither "asdg" in either show (show . (+10)) x
19:02:00 <lambdabot>  "\"Prelude.read: no parse\""
19:02:11 <Denommus> ok, no more flooding
19:05:55 <ReinH> Deadhand: you can /msg lambdabot as well
19:06:18 <Denommus> ReinH: I am aware
19:07:02 <Denommus> ReinH: my subconscience was thinking I was showing something to someone, I guess
19:08:17 <ReinH> :)
19:08:28 <ReinH> Please consider it as the gentlest of rebukes ;)
19:10:45 <Imagine> hmmm - so suppose I have a square matrix of type [[a]], and I want to create a new list of lists, where here, each new list is a diagonal
19:11:09 <Imagine> My first instinct would be to cycle the second row by 1, the third by 2, and so on
19:11:15 <Imagine> and then do a transpose type of thing
19:11:24 <Imagine> is there a better way to do it though?
19:13:41 <mniip> Imagine, I would think 'take (length xs) $ drop n $ cycle xs' would be better
19:14:22 <Imagine> that only works with one list though?
19:14:29 <mniip> yes
19:14:32 <mniip> performance-wise, you want to build all of the result lists simultaneously
19:14:33 <Imagine> like you can't quite apply that to the array itself can you?
19:14:42 <Imagine> yeah
19:15:37 <mniip> sec
19:18:07 <Imagine> wait actually
19:18:10 <Imagine> I think I got it
19:18:18 <Imagine> is there a way to apply a list of functions to a list of elements?
19:18:31 <Imagine> zipWith I'm guessing
19:18:33 <Imagine> yeah I think I have it
19:23:00 <mniip> Imagine, oh
19:23:02 <mniip> square matrix
19:23:11 <Imagine> yeah
19:23:38 <dmwit> Imagine: You might want to look at the diagonalization I use in the universe package.
19:24:04 <mitchty> THIS IS THE BEST, static binaries with musl libc https://gist.github.com/mitchty/b6dcc2b919249637b365 thank you reddit dude http://www.reddit.com/r/haskell/comments/37m7q7/ghc_musl_easier_static_linking/
19:24:05 <dmwit> http://hackage.haskell.org/package/universe-base-1.0/docs/src/Data-Universe-Helpers.html#diagonal
19:24:42 <lpaste> mniip pasted “diagonals” at http://lpaste.net/133531
19:24:43 <dmwit> You will have to adapt it a tiny bit if you want [[a]] -> [[a]], but not much.
19:24:50 <mniip> Imagine, I was trying to do too much error handlind
19:24:59 <mniip> if your matrices are square this will suffice
19:25:04 <Imagine> thanks dmwit
19:25:08 <Imagine> awesome okay
19:25:12 <Imagine> yeah I'll take a look at it
19:25:51 <lpaste> mniip revised “diagonals”: “diagonals” at http://lpaste.net/133531
19:26:47 <dmwit> > let diags = go []; go hs [] = transpose hs; go hs (t:ts) = (hs >>= take 1) : go (t:hs) ts in diags [[1,2,3],[4,5,6],[7,8,9]]
19:26:48 <lambdabot>  [[],[1],[4,1],[7,4,1],[8,5,2],[9,6,3]]
19:26:55 <dmwit> oops
19:27:08 <dmwit> > let diags = go []; go hs [] = transpose hs; go hs (t:ts) = (hs >>= take 1) : go (t:map (drop 1) hs) ts in diags [[1,2,3],[4,5,6],[7,8,9]]
19:27:10 <lambdabot>  [[],[1],[4,2],[7,5,3],[8,6],[9]]
19:27:33 <mniip> hs >>= take 1
19:27:36 <mniip> too cool for concatMap
19:27:39 <Imagine> :t go
19:27:40 <lambdabot>     Not in scope: ‘go’
19:27:40 <lambdabot>     Perhaps you meant one of these:
19:27:40 <lambdabot>       ‘g’ (imported from Debug.SimpleReflect),
19:27:49 <dmwit> :t let diags = go []; go hs [] = transpose hs; go hs (t:ts) = (hs >>= take 1) : go (t:map (drop 1) hs) ts in go
19:27:50 <lambdabot> [[a]] -> [[a]] -> [[a]]
19:28:18 <mniip> dmwit, damn that's fancy
19:28:29 * dmwit bows
19:29:04 <Imagine> lol
19:29:15 <Imagine> I'll copy that so I have it
19:29:24 <mniip> still trying to grok
19:29:25 <Imagine> and so I can try to understand it
19:29:30 <Imagine> I think I'm too tired right now
19:29:41 <dmwit> Imagine: I can explain, if you like.
19:29:59 <Imagine> Maybe its confusing because its inline
19:30:13 <dmwit> That's part of the problem, I'm sure.
19:30:20 <Imagine> I mean if you don't mind that'd be great
19:30:21 <ReinH> mitchty: Oh shit, I wish I had known about that a couple months ago
19:30:57 <mniip> dmwit, that's hella fancy
19:31:10 <ReinH> dmwit: :)
19:31:21 <dmwit> Imagine: Okay. The idea is we're going to keep track of how "deep" into each of the rows in the matrix we are.
19:31:29 <Imagine> wait wait
19:31:38 <Imagine> do you mind putting it in lpaste first
19:31:41 <mniip> > let diags = go []; go hs [] = []; go hs (t:ts) = (hs >>= take 1) : go (t:map (drop 1) hs) ts in diags [[1,2,3],[4,5,6],[7,8,9]]
19:31:42 <lambdabot>  [[],[1],[4,2]]
19:31:50 <Imagine> with the "regular" indentations?
19:31:52 <mniip> ah so that's what that's for
19:32:16 <dmwit> Imagine: sure, why not
19:32:17 <Imagine> I'm confused what is doing what exactly (like whats a definition and whats not)
19:32:18 <Imagine> thanks
19:32:36 <mitchty> ReinH: this makes me super happy, if I can make proper static binaries on linux so much will be stupid easy
19:32:52 <ReinH> mitchty: yep
19:33:08 <ReinH> mitchty: Except that caring about haskell binaries is no longer my job, so...
19:33:16 <lpaste> dmwit pasted “diagonals” at http://lpaste.net/133533
19:33:32 <dmwit> Oh, that's the wrong version.
19:33:33 <dmwit> Hold on.
19:33:50 <lpaste> dmwit revised “diagonals”: “No title” at http://lpaste.net/133533
19:34:13 <Imagine> okay got it
19:34:18 <Imagine> so you want to keep track of how deep you are
19:34:42 <dmwit> Yep. To begin with, we haven't started looking at any of the rows, so we aren't "deep" in any of them.
19:35:04 <dmwit> This is the meaning of "go []" -- the first argument to "go" will keep track of how deep we are in rows we've started looking at, and the second argument tracks rows we haven't started looking at yet.
19:35:31 <dmwit> Let's ignore the `go hs []` clause for a moment and look at the `go hs (t:ts)` one first, since it's more interesting.
19:35:44 <Imagine> alright
19:36:14 <dmwit> Okay. So the first thing we do is emit the value at the current depth from each row we've already looked at.
19:36:21 <dmwit> This gives us one of the diagonals.
19:36:28 <Imagine> thats hs >== take 1?
19:36:31 <dmwit> right
19:36:40 <mniip> oh, we take a column from hs and prepend a row to form new hs
19:36:43 <dmwit> `hs >>= take 1` picks the first element out of each element of hs.
19:37:11 <Imagine> makes sense, okay
19:37:29 <dmwit> `hs >>= take 1` picks the element at the current depth in each of the rows in hs. -- same thing, but with less overloaded terms
19:37:50 <dmwit> Okay. The next thing we need to do is advance each row by one. That's `map (drop 1) hs`.
19:38:05 <dmwit> And then we add the next row at depth zero to the front. That's `t:map (drop 1) hs`.
19:39:07 <dmwit> Okay. Time to pause for questions on the second clause.
19:39:45 <Imagine> okay give me a second to think about it
19:40:41 <Imagine> why are you only calling go with one argument?
19:40:50 <Imagine> did the ts just disappear?
19:41:06 <dmwit> ...that's a mistake
19:41:17 <lpaste> dmwit revised “diagonals”: “No title” at http://lpaste.net/133533
19:41:48 <Imagine> okay, that clause makes sense now
19:42:11 <dmwit> Alright. Then the first clause is just a trick to repeatedly do the second clause until `hs` is empty.
19:42:39 <Imagine> you mean `ts`?
19:42:43 <Imagine> hs grows doesn't it?
19:42:47 <Imagine> instead of shrinks?
19:43:03 <dmwit> Once there are no more rows to start inspecting, `hs` stops growing.
19:43:24 <dmwit> It just shrinks by taking the element at the current depth from each row, and then advancing each row's depth by one.
19:43:37 <Imagine> right
19:44:01 <dmwit> So once there are no more rows to start inspecting, we repeatedly: make a list consisting of first elements from `hs`, then iterate on the rows consisting of tails taken from `hs`.
19:44:07 <dmwit> That is what `transpose` does, by accident.
19:44:50 <Imagine> yep
19:44:54 <Imagine> okay yeah that makes sense
19:45:12 <Imagine> thank you
19:45:19 <dmwit> You're welcome. =)
19:45:26 <ReinH> dmwit: now pls make one that works for infinite matrices
19:45:30 <echo-area> How does Haskell programs solve the representation independence issue?
19:45:37 <dmwit> ReinH: The one in universe works for infinite matrices.
19:45:43 <dmwit> ReinH: (So does this one, actually.)
19:45:49 <ReinH> echo-area: what is that issue?
19:45:53 <ReinH> dmwit: oh, nice
19:46:03 <Imagine> I'm really so glad how helpful this irc makes learning this. Like I've had a bunch of people help me today already and its making the whole thing a lot easier
19:46:11 <ReinH> Imagine: <3
19:46:16 <dmwit> ReinH: (The one in universe has a few other tricks put in, too, so it doesn't keep inspecting empty lists.)
19:46:16 <Imagine> :)
19:46:22 <Imagine> thank you everybody
19:46:25 <ReinH> dmwit: right
19:46:41 <Imagine> alright, I think its time that I get some sleep - goodbye!
19:46:51 <echo-area> ReinH: Incompatibilities resulted after changing the definition of some type and the user code having to be changed to adapt the change
19:47:32 <dmwit> echo-area: In the usual way: if a module's interface changes, users of the interface need to be modified. So don't expose details you think might change.
19:47:39 <ReinH> echo-area: "All problems in computer science can be solved by another level of indirection"
19:48:50 <echo-area> What about pattern matching?  A good practice seems to be keeping another layer solely for pattern matching
19:48:57 <mniip> dmwit, so, more idiomatically,
19:49:05 <ReinH> echo-area: Ultimately, if things change then things that depend on that thing may also need to change
19:49:14 <ReinH> It isn't so much a problem as the way the universe works
19:49:29 <echo-area> I see.  Thanks
19:49:46 <lpaste> mniip revised “diagonals”: “diagonals” at http://lpaste.net/133531
19:53:10 <dmwit> echo-area: Yep, pattern-matching is a bit of a loss sometimes. These days PatternSynonyms can help you recover.
19:53:33 <dmwit> echo-area: Designing good types for the return values of your view functions also helps that a lot.
19:53:56 <echo-area> dmwit: Good to know about PatternSynonyms, will check it out, thanks
19:53:58 * mniip wonders whether mapMaybe and headMay can fuse
19:54:03 <dmwit> echo-area: And, as an aside, it's fairly common to have both a Foo module and a Foo.Internal module, with the understanding that users of Foo.Internal are consenting adults.
19:54:28 <dmwit> mniip: I'm not sure I agree that your version is more idiomatic.
19:54:45 <echo-area> Oh, that indirection.  I should have noticed it
19:54:53 <mniip> well it eliminates empty rows on the fly
19:55:09 <mniip> and headMay sounds nicer than 'take 1' anyway
19:55:33 <dmwit> mniip: You may like the trick I use in universe to eliminate empty rows, which I think is quite idiomatic.
19:55:38 <dmwit> [h | h:_ <- b]
19:55:47 <ReinH> dmwit: heh
19:56:00 <dmwit> Well, more to the point, [t | _:t <- b] is its counterpart.
19:56:25 <mniip> which is the same as 'mapMaybe headMay' with some inlining
19:56:27 <arkeet> take 1, drop 1
19:56:35 <arkeet> oh
19:56:37 <arkeet> not quite drop 1
19:56:47 <mniip> @src mapMaybe
19:56:47 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
19:56:48 <dmwit> mniip: I believe that converting lists to maybes is a code smell.
19:56:58 <mniip> converting lists to maybes?
19:57:12 <dmwit> headMay, for example; and tailMay by association.
19:57:24 <dmwit> Just pattern match. That's what pattern matching is for.
19:57:34 <dmwit> It's not like tailMay is somehow lazier than a pattern match.
19:57:42 <mniip> true
19:57:47 <ReinH> dmwit: what do you have against natural transformations? :p
19:57:51 <mniip> but again
19:58:00 <mniip> combinators versus pattern matching
19:58:21 <dmwit> I don't see a reason that combinators should be intrinsically preferable to pattern matching.
19:58:48 <mniip> you're using 'map' :P
19:58:52 <mniip> and transpose
19:59:01 <dmwit> So?
19:59:37 <mniip> you think it's okay to use map instead of [f x | x <- xs]
19:59:43 <mniip> but not okay to use headMay
19:59:47 <dmwit> Correct.
20:00:14 <mniip> the former contradicts with your implication of combinators being strictly worse than pattern matching
20:00:16 <dmwit> There's no reason to turn `x:xs` into `Just x`. `(:)` is just as good a constructor as `Just`, and contains more information.
20:00:38 <dmwit> (Likewise for `[]` and `Nothing`.)
20:00:51 <dmwit> I'm just saying don't insert an extra step that isn't needed.
20:00:53 <mniip> well often you don't need "more information"
20:01:00 <mniip> see you're discarding the tail with _
20:02:12 <mniip> also strictly speaking, you're still doing an extra step
20:02:25 <mniip> you check whether a list is empty twice, once in head part, once in tail part
20:03:00 <dmwit> mniip: You check the list four times.
20:03:35 <mniip> albeit I'm unsure whether precompiling a list into a list of tuples of heads and tails will produce any performance benefit
20:04:03 <ReinH> (checking whether a list constructed from [] or : is one of the cheapest things you can do in Haskell)
20:04:08 <dmwit> Sometimes, for modularity purposes, it makes sense to separate the stage where you throw away information from the stage where you process the information that's left. I don't agree that this situation is one of those times, particularly because those two steps are right next to each other in the code.
20:04:23 <funfunctor> Can anyone tell me why clearInnerHtml :: Element -> Fay () clearInnerHtml = ffi "%1['innerHTML'] = '' '' keeps asking for a type signature in Fay?
20:04:56 <mniip> ReinH, still you're checking a list of lists
20:04:57 <dmwit> funfunctor: Is it possible that you misspelled clearInnerHtml one of the times?
20:05:18 <funfunctor> dmwit: nope
20:06:49 <mniip> hmm
20:06:58 <dmwit> I wonder why I made my worker take a tuple instead of two arguments. That seems dumb.
20:07:03 <mniip> the safe package appears to be quite a bit inefficient
20:07:58 <mniip> tailMay val = if null val then Nothing else Just $ tail val
20:08:10 <ReinH> :(
20:08:18 <dmwit> (The extra step I'm railing against here is converting `(:)` to `Just`. You seem to be off on a tangent about traversing the list multiple times, which is irrelevant to the current argument in my opinion.)
20:08:46 <newsham> are there two ways to make an applicative for trees (like there are for lists)?
20:08:47 <mniip> they scarificed performance for generic code, by introducing 'liftMay' which does basically the above
20:09:19 <mniip> newsham, probably more
20:09:55 <mniip> actually there are infinitely many ways to implement applicative for lists
20:11:29 <ReinH> ?
20:11:39 <mniip> hmm
20:12:09 * mniip checks the axioms
20:12:44 <dmwit> Perhaps you're thinking of comonad instances for streams.
20:13:09 <dmwit> newsham: I know there is a zippy applicative.
20:13:32 <mniip> pick a number n,
20:13:32 <newsham> one is zippy and one is kinda cross-product ish
20:13:37 <dmwit> newsham: I would expect there to be another applicative that falls out of a join operation that splices trees into their positions.
20:13:48 <dmwit> join :: Tree (Tree a) -> Tree a -- ought to be fairly easy to write
20:14:10 <newsham> isnt that roughly what the Data.Tree appliactive instance does?
20:14:17 <newsham> > Data.Tree.levels (Node f [Node g [], Node h []] <*> Node a [Node b [], Node c []]) :: [[Expr]]
20:14:18 <lambdabot>  [[f a],[f b,f c,g a,h a],[g b,g c,h b,h c]]
20:14:20 <mniip> pure x = replicate (n + 1) x; f <*> k = zipWith id (take n f) (take n k) ++ (drop n f <*> drop n k)
20:14:40 <mniip> n=0 is the [] instance, n=infinity is the ZipList instance
20:15:02 <dmwit> err... hm
20:16:07 <dmwit> n=0 makes (<*>) a loop
20:16:11 <mniip> uh, that <*> in the definition of <*> is []'s instance
20:17:37 <homovitruvius> is there a "linter" for .cabal file (for removing unnecessary dependences for instance)?
20:17:47 <dmwit> mniip: Oh. This is the (ZipList a, [a]) instance.
20:18:02 <mniip> more or less
20:18:29 <mniip> we treat first n elements in a zippy way and the rest in a probabilistic way
20:18:35 <dmwit> homovitruvius: I don't really know of one, though there are a handful of tools that start in that direction on Hackage.
20:18:44 <mniip> satisfies all axioms and stuff like that
20:19:15 <dmwit> homovitruvius: For finding dependencies that don't include the latest thing, and for checking that an install plan chooses all the latest things.
20:20:32 <dmwit> newsham: So you are asking if there is a zippy Applicative for Tree, then? If so, yes, there is.
20:21:32 <mniip> dmwit, intuition suggests that there are no instances beyond this aleph-null set
20:23:30 <dmwit> mniip: I think your intuition sucks.
20:23:38 <mniip> yay
20:23:39 <dmwit> mniip: There's probably one for (ZipList a, [a], [a]), for example.
20:24:01 <mniip> you mean interpreting a list as two interspersed lists?
20:24:01 <newsham> dmwit: also wondering if there are more possibilities given that it has more structure
20:24:09 <dmwit> (Pick two places to split the incoming lists. Treat the first thirds as zips, the second thirds as probabilistic, and the third thirds as probabilistic, but don't mix between the second and third thirds.)
20:24:11 <newsham> and why there's not a zip tree impl
20:24:26 <mniip> dmwit, how do you 'not mix'
20:24:56 <mniip> dmwit, for simplicity let's forget about ZipList part,
20:25:03 <mniip> what would 'pure id' look like
20:25:16 <dmwit> I've got to run. But you "not mix" but just doing (zips, as, bs) <*> (zips', as', bs') = (zips <*>_ZipList zips', as <*>_[] as', bs <*>_[] bs').
20:25:29 <mniip> but
20:25:32 <Pamelloes> I recently encoundered the Data.Dependent.Map package ( https://hackage.haskell.org/package/dependent-map-0.1.1.3/docs/Data-Dependent-Map.html ) and I'm not quite sure what to make of it. Is anyone familiar with how it works?
20:25:35 <dmwit> pure x = (repeat x, [x], [x])
20:25:41 <mniip> dmwit, but (,,) is not []
20:25:53 <dmwit> I don't think I claimed it was?
20:26:01 <mniip> there is not a bijection between (a,a,a) and [a]
20:26:03 <kirill`> If I need to load and run some Haskell code at runtime, from inside a running Haskell program, what is the right way to go about it? Is it the plugins package?
20:26:20 <dmwit> But for particular m, n you can make a function foo_m,n :: [a] -> ([a], [a], [a]) that splits at points m and n.
20:26:25 <arkeet> fine
20:26:29 <dmwit> Oh, I understand your objection.
20:26:29 <mniip> and the reverse?
20:26:29 <dmwit> Okay.
20:26:37 <dmwit> I'll think about it.
20:26:51 <dmwit> *really* have to run now
20:26:57 <mniip> see ya later then
20:27:07 <arkeet> zip the first 5 elements
20:27:16 <arkeet> nondeterministic thing for the remaining ones
20:27:22 <arkeet> pure x = replicate 6 x
20:27:35 <arkeet> does that work
20:28:31 <mniip> arkeet, that's what I suggested
20:28:43 <mniip> dmwit says there are more instances than that
20:28:48 <arkeet> ok
20:28:56 <arkeet> maybe there are
20:29:13 <arkeet> I can't think of any but I can't imagine why there would be no more.
20:29:53 <Zekka> arkeet: Isn't that unlawful? pure id <*> pure x is not fmap id (pure x)
20:30:04 <arkeet> it isn't?
20:30:22 <Zekka> @let pure' x = replicate 6 x
20:30:24 <lambdabot>  Defined.
20:30:32 <arkeet> you have to define <*> appropriately of course
20:30:47 <Zekka> arkeet: Maybe you're right, actually
20:31:04 <arkeet> @let fff xs ys = zipWith id (take 5 xs) (take 5 ys) ++ (drop 5 xs <*> drop 5 ys)
20:31:06 <lambdabot>  Defined.
20:31:12 <arkeet> > pure' id `fff` pure' 5
20:31:14 <lambdabot>  [5,5,5,5,5,5]
20:31:20 <arkeet> > fmap id (pure' 5)
20:31:22 <lambdabot>  [5,5,5,5,5,5]
20:31:28 <Zekka> Yeah, that looks pretty reasonable
20:35:20 <arkeet> also there's the obvious thing where you could reverse the order of "effects"
20:36:46 <arkeet> but that doesn't give anything really new
20:41:09 <mniip> well obviously not taking into account the less famous list Functor instance: fmap = const $ const []
20:41:30 <mniip> wait that's not an instance, identity law broken
20:56:00 <funfunctor> hmm! really can't get my head around callbacks in Fay
20:57:41 <orion> If I wanted to write a WAI Middleware which records how long it takes to serve a request, what packages/modules would be most helpful? I basically need a medium precision timer.
21:02:01 <Axman6> orion: Data.Time.Clock would be a good place to start
21:03:40 <orion> Axman6: Cool, thanks,.
21:06:59 <vpGreen> is there a way to see the channel log?
21:09:01 <vpGreen> I am trying to learn haskell. Some blog suggested that I should see the codes on IRC channel log, but I don't know anyway to see the log nor even think that is possible?
21:09:21 <Axman6> vpGreen: see the topic (/topic)
21:09:39 <Zemyla> @quote monady
21:09:39 <lambdabot> gbacon says: okay, I just tried to type Monday, but it came out Monady. Assimilation complete.
21:09:40 <Axman6> also, #haskell is much more useful as a place to ask for help than one to read the logs of
21:09:45 <Zemyla> I made that typo too.
21:09:54 <Zemyla> I've been assimilated.
21:09:54 <vpGreen> thanks!
21:13:34 <nachoBA> Hello
21:13:56 <Axman6> 'lo
21:15:47 <nachoBA> I was wondering if perhaps someone could help me on some advice installing haskell & libraries on OS X 10.10. I've been using Haskell in linux but not OS X and I see different options: haskell-platform, Kronos Haskell, Haskell self-contained. 
21:21:40 <lpaste> mniip pasted “all Applicative [] instances” at http://lpaste.net/133541
21:22:52 <mniip> I might have found a new hobby
21:23:41 <orion> Axman6: There's another function, System.CPUTime.getCPUTime. That's likely not useful, correct?
21:23:56 <Axman6> It might be, depends on what you want
21:24:28 <orion> The goal is to time how long it takes my application to process a request so that I can compare it over time.
21:24:39 <Axman6> nachoBA: https://ghcformacosx.github.io seems to be the most pain-free
21:24:57 <Axman6> orion: you probablt want lock time then
21:24:59 <Axman6> clock*
21:25:05 <orion> Axman6: Alright.
21:26:11 <nachoBA> Thanks. The self contained one.
21:27:58 <mniip> hmm
21:28:18 <mniip> is there a type that is not a Profunctor
21:30:25 <jle`> mniip: you mean something of the right Kind that is not a Profunctor?
21:30:31 <mniip> yeah
21:30:32 <dzack> ghc seems to throw warnings whenever it sees a tab character - is it expecting spaces?
21:30:34 <jle`> maybe newtype Op a b = Op (b -> a) ?
21:31:25 <Axman6> dzack: yeah you should change your editor to only use spaces. tabs break everything
21:31:56 <mniip> jle`, oh, damn, I missed an important point
21:32:46 <mniip> true, there are types that aren't Profunctors
21:33:34 <mniip> what I had in mind is more like, class Endoprofunctor p where fancymap :: (a -> b) -> (b -> a) -> p a -> p b
21:33:39 <Myrl-chan> Ay~
21:34:11 <Myrl-chan> mniip: Quickly find a way to make us universe twins again. :(
21:34:55 <mniip> Myrl-chan, btw, I added STM support into timemachine!
21:35:02 <Myrl-chan> wut
21:35:41 <mniip> you can now compose 'undo' and friends with atomic transactions!
21:37:04 * Myrl-chan has no idea. :D
21:39:56 <dzack> Axman6: awesome, figured there was a reason there
21:40:49 <mniip> Myrl-chan, ಠ_ಠ you're not familiar with my library yet?
21:42:08 <neonrooster> I have this function. How do I make a program that will print fib 1?:
21:42:09 <neonrooster> fib n = fib n + fib (n-1)
21:42:09 <neonrooster> fib 0 = 0
21:42:25 <mniip> neonrooster, main = print (fib 1)
21:42:43 <dmj`> neonrooster: you need fib 0 = 0 above fib n
21:42:53 <dmj`> neonrooster: otherwise it won't terminate
21:42:53 <mniip> that too
21:42:56 <neonrooster> dmj`: will that make a proper fib function?
21:43:11 <dmj`> neonrooster: the base case for your recursion should be specified first
21:43:24 <dmj`> neonrooster: fib n will always match, even in the case of fib 0
21:43:31 <dmj`> neonrooster: so fib 0 must come first
21:44:20 <neonrooster> dmj`: I did that but my program is eating lots of RAM and won't terminate
21:44:20 <dmj`> neonrooster: your fib is also inefficient, and incorrect
21:44:30 <dmj`> @def fib@(1:tfib) = 1 : 1 : [ a+b | (a,b) <- zip fib tfib ] 
21:44:31 <lambdabot>  Defined.
21:44:38 <dmj`> > fib !! 5
21:44:40 <lambdabot>  8
21:45:01 <neonrooster> dmj`: how do I make a proper fib? I'm new to algebra and programming
21:45:29 <dmj`> neonrooster: the lhs of the (+) is 'fib n', you're not decrementing n here, so it will inifitely recurse
21:45:59 <neonrooster> fib n = fib (n-1) + fib n
21:46:04 <neonrooster> is that incorrect?
21:46:38 <johnw> that would never reach fib 0
21:46:49 <neonrooster> hell then how do I learn math and haskell?
21:46:57 <johnw> you're extremely close
21:47:29 <neonrooster> so what's the tip?
21:47:38 <johnw> write your base cases first
21:47:52 <johnw> then ask how your non-base case definition will "ground out" in them
21:48:02 <dmj`> fib n | n == 0 = 0 | n == 1 = 1 | otherwise = fib (n-1) + fib (n-2)
21:48:13 <johnw> well, almost
21:48:17 <johnw> fib 0 = 1; fib 1 = 1; fib n = fib (n -2) + fib (n - 1)
21:48:37 <mniip> neonrooster, if you look at the mathematical definition of fibonacci sequence
21:48:46 <mniip> it says F_n = F_n-1 + F_n-2
21:48:52 <mniip> not whatever you've implemented
21:50:07 <neonrooster> OH
21:50:58 <neonrooster> no it's broken: fib 5 prints 5
21:52:07 <neonrooster> I have fib 0 = 0; fib 1 = 1; fib n = fib (n-2) + fib (n-1)
21:52:11 <dmj`> > fib !! 5
21:52:13 <lambdabot>  8
21:52:20 <dmj`> > take 6 fib
21:52:23 <lambdabot>  [1,1,2,3,5,8]
21:52:31 <dmj`> neonrooster: depends if you include 0 or not
21:53:07 <neonrooster> what does that mean?
21:53:44 <neonrooster> i have fib 0 = 0 and fib 1 = 1 . Not sure why my program fails
21:53:55 <dmj`> neonrooster: paste all your code
21:54:02 <dmj`> neonrooster: the fib sequence can start at either 1 or 0
21:54:33 <neonrooster> http://vpaste.net/hW1Ca
21:55:21 <dmj`> neonrooster: that code works for me
21:55:36 <neonrooster> then my system is broken!
21:55:46 <dmj`> neonrooster: what happens when you call main?
21:55:57 <neonrooster> > fib !! 6
21:55:59 <lambdabot>  13
21:56:11 <neonrooster> dmj`: it prints this : fib 6 = 8
21:57:23 <dmj`> > [0,1,1,2,3,5,8] !! 6
21:57:25 <lambdabot>  8
21:57:34 <dmj`> looks right to me
21:58:13 <neonrooster> then how do I make my code print a list of fib n using what? zipWith?
21:58:27 <pacak> > fix $ (0:) . scanl (+) 1
21:58:30 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
21:58:32 <neonrooster> I have "main = print (fib 6)". How do I expand on it?
21:59:08 <dmj`> @src fib
21:59:08 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
21:59:45 <PoJieNie> map (fib !!) [0..10]
22:00:10 <neonrooster> PoJieNie: but how do I combine that with print?
22:00:33 <dmj`> neonrooster: just put print in front of it "main = print $ fib !! 6"
22:01:15 <PoJieNie> how do you want it to be printed?
22:01:17 <neonrooster> dmj`: WOW SO SIMPLE!
22:02:15 <mjrosenb> can I have a value of type IO a?
22:02:25 <dmj`> neonrooster: well yea, once you get the types it's not too bad :) 
22:02:34 <neonrooster> dmj`: This code won't run: main = print $ fib !! 6
22:02:54 <neonrooster> fib.hs:6:16:
22:02:54 <neonrooster>     Couldn't match expected type ‘[s0]’ with actual type ‘a0 -> a1’
22:03:08 <PoJieNie> be sure you have the same fib function
22:03:24 <dmj`> PoJieNie+
22:03:37 <dmj`> @typ (return undefined :: IO a)
22:03:39 <lambdabot> IO a
22:03:43 <dmj`> :)
22:03:51 <neonrooster> I don't have the same fib function; How do I fix my fib function to be the same? I don't want to use your code
22:05:12 <dmj`> neonrooster: you can have both, just name them differently, like fib1/fib2, or fib/fib'
22:05:12 <neonrooster> http://vpaste.net/U0Iuc
22:05:12 <DrPavelheer> fib is a function
22:05:12 <DrPavelheer> but you're treating it like a list
22:05:12 <neonrooster> dmj`: but I want my own implementation is what I'm asking
22:05:12 <dmj`> neonrooster: in that case `main = print (fib 6)`
22:06:26 <neonrooster> I want a function that can make a list of things or just return a singleton list
22:06:55 <dmj`> mjrosenb: if you constrain a w/ a typeclass yea
22:10:17 * hackagebot email-validate 2.1.3 - Validating an email address string against RFC 5322  http://hackage.haskell.org/package/email-validate-2.1.3 (GeorgePollard)
22:23:17 <dmwit> mniip: None of the Applicative laws appear to require the reverse operation.
22:23:34 <dmwit> Or, more precisely: none of them seem to require that the reverse operation be "stable" in any sane sense.
22:25:18 * hackagebot persistent 2.1.6 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.1.6 (GregWeber)
22:25:19 <dmwit> Well. Maybe the "composition" law does.
22:25:48 <mniip> dmwit, for any instance there exists a reverse one
22:26:07 <mniip> where f <*>' k = flip ($) <$> k <*> f
22:26:19 <dmwit> mniip: When I say "reverse operation" here I'm talking about your challenge to me from earlier.
22:26:19 <mniip> for lists, the two are different
22:26:23 <dmwit> Not literally reverse.
22:26:36 <mniip> what challenge
22:26:47 <mniip> "all possible instances of applicative []" ?
22:26:56 <dmwit> Never mind. Suffice it to say I was wrong about my proposed extra instance.
22:27:20 <dzack> if you 'cabal install' a package, does it populate the 'ghc-pkg list' of the version of ghc it was compiled against?
22:27:52 <mniip> dmwit, I think I might have captured all possible instances here http://lpaste.net/133541
22:27:59 <mniip> ideas for any extra instances?
22:28:15 <dmwit> dzack: yes
22:28:17 <dmj`> dzack: depends if you installed into a sandbox or not, if so, cabal sandbox hc-pkg list should
22:28:37 <dmwit> Good point re: sandboxes.
22:31:57 <dmwit> mniip: Probably any old way to pick a few elements out of a skeleton works (not just "take the first, take the last").
22:32:23 <mniip> hmm
22:32:48 <mniip> yeah I was just testing whether 'zip last, undeterministically combine init' works
22:33:19 <dmwit> In fact, you're probably allowed to have a different way of picking a few elements out of the skeleton for each size of skeleton.
22:34:21 <mniip> dmwit, you mean for any length of the probabilistic part have a corresponding pattern of zippy parts?
22:34:54 <mniip> assuming zippy parts add to a constant amount of elements ofc
22:35:17 <dmwit> I mean for any length of list, have a separate list of indices to pick out for the zippy part.
22:35:19 * hackagebot wai-routes 0.6.1 - Typesafe URLs for Wai applications.  http://hackage.haskell.org/package/wai-routes-0.6.1 (AnupamJain)
22:35:26 <dmwit> (Though all lists should have the same length.)
22:35:40 <dmwit> I wouldn't be surprised if you had some leeway in choosing what order to return the nondeterministic part, too.
22:36:29 <mniip> well generally
22:38:07 <mniip> all you need is for any n to have a forall x. bijection between [x] and ([x], Vector n x)
22:39:12 <mniip> you split, zip the Vector parts, apply nondeterminism to list parts, then combine
22:39:27 <mniip> hmm
22:39:34 <mniip> understatement
22:39:59 <mniip> forall x. bijection between [x] with at least n elements, and ([x], Vector n x)
22:45:45 <mniip> can I haz type-level functions
22:46:27 <mniip> well maybe something fancy is possible with reification
22:47:15 <Rotaerk> type Foo x = (x, x)
22:47:20 <Rotaerk> isn't that a type level function?
22:48:46 <mniip> Rotaerk, hm?
22:49:43 <Rotaerk> it's the type level analogue to:  foo x = (x, x)
22:50:11 <mniip> how would I go about converting a 'Proxy Foo' into \x -> (x, x)
22:50:19 * hackagebot log-domain 0.10.1 - Log-domain arithmetic  http://hackage.haskell.org/package/log-domain-0.10.1 (EdwardKmett)
22:50:29 <mniip> hint: Proxy Foo is not even kind-valid
22:50:51 <mniip> a wild edwardk appeared
22:51:23 * edwardk used haskell. It was super effective!
22:51:37 <mniip> efficient you mean :)
22:52:09 <mniip> edwardk, any idea about how to pass functions via types?
22:52:28 <mniip> for instance "customization" purposes
22:52:31 <liste> I thought type families were type-level functions?
22:53:05 <edwardk> mniip: reflection
22:53:37 <mniip> that unsafeCoerce hack thing?
22:53:45 <edwardk> Reifies s (Int -> Bool) => .... do something with s here as a type parameter that reifies a function from Int -> Bool.
22:54:17 <edwardk> witht hat you can use reflect (Proxy :: Proxy s) :: Int -> Bool   -- to get the function back out of the type
22:54:26 <edwardk> it is a limited form of Pi.
22:55:20 * hackagebot approximate 0.2.2 - Approximate discrete values and numbers  http://hackage.haskell.org/package/approximate-0.2.2 (EdwardKmett)
22:59:52 <mniip> edwardk, so if I have 'data Foo s a = Foo a'
23:00:06 <mniip> where s is the phantom parameter corresponding to the function
23:00:13 <mniip> how would I reify that
23:00:20 * hackagebot either 4.3.4.1 - An either monad transformer  http://hackage.haskell.org/package/either-4.3.4.1 (EdwardKmett)
23:00:31 <edwardk> you can use 'Tagged' for that purpose (since that is what it is)
23:00:46 <edwardk> but now Tagged provides combinators to go back and forth between Tagged s a   and (Proxy s -> a)
23:00:54 <edwardk> You can pass that Proxy s to reflect
23:01:04 <edwardk> you can also use scoped type variables
23:01:38 <edwardk> foo :: forall s a. Reifies s Whatever => Tagged s a -> Whatever; foo _ = reflect (Proxy :: Proxy s)
23:02:09 <edwardk> and we can also just use the fact that Tagged is a Monad, and go backwards from reflect as a function from (Proxy s -> a) to get one in Tagged s a
23:02:30 <edwardk> Data.Tagged provides unproxy :: (Proxy s -> a) -> Tagged s a
23:02:31 * mniip is lost
23:02:43 <edwardk> unproxy reflect :: Reifies s a => Tagged s a
23:02:59 <edwardk> data Proxy s = Proxy
23:03:11 <edwardk> is a data type that is provided by base these days and used to be supplied by my tagged package
23:03:24 <mniip> that I know
23:03:29 <edwardk> reflect :: Reifies s a => proxy s -> a  -- note the lower case 'proxy' it doesn't care what type supplies the 's' as its argument
23:03:44 <edwardk> unproxy reflect :: Reifies s a => Tagged s a 
23:03:44 <mniip> seen that as well
23:04:09 <mniip> and Tagged is basically Const?
23:04:13 <edwardk> what i was pointing out was that your Foo is just Tagged
23:04:18 <mniip> oh
23:04:19 <edwardk> Const on the other argument
23:04:27 <edwardk> and Tagged is a Monad, etc.
23:04:31 <edwardk> so you can just do things like
23:05:15 <edwardk> foo = do x <- whatever; f <- unproxy reflect; return (f x) -- or whatever you want to program inside Tagged with the function you've reified
23:05:47 <poincare101> how do I access a field of the instance of a type? e.g. if I have Triangle with the type constructor DPTriangle fields [[Integer]] [Integer], is there some way to access those?
23:06:34 <Axman6> pattern matching? foo (DTriangle flds intlistlists intlist)
23:07:02 <lf94> Parsec is amazing <3
23:07:16 <pavonia> poincare101: Do you mean data constructor?
23:07:24 <poincare101> pavonia: yes i think?
23:07:32 <poincare101> pavonia: yes
23:07:45 <pavonia> Then what Axman6 said
23:10:21 <pacak> lf94: attoparsec can be more amazing <4
23:12:24 <quanglewangle> let's talk functors: map :: (a -> b) -> [a] -> [b]   and fmap :: (a -> b) -> f a -> f b  
23:12:39 <Axman6> discussion done! nice work team
23:12:49 <quanglewangle> i don't quite grok how we can use fmap (*2) [1..3] 
23:13:05 <Axman6> in that case, f = []
23:13:09 <quanglewangle> f here is (*2) - the function to be applied (apparently this is a functor)
23:13:17 <Axman6> so fmap :: (a -> b) -> [] a -> [] b
23:13:38 <quanglewangle> f = []?
23:13:43 <quanglewangle> so what's with the *2
23:13:47 <quanglewangle> what variable is that part of?
23:13:51 <quanglewangle> i mean bind to
23:14:09 <quanglewangle> (*2) is (a->b)?
23:14:13 <pavonia> Not (*2) is the functor, [] is
23:14:14 <Axman6> you seem to be confusing types and values. f is a _type_ variable
23:14:35 <quanglewangle> type variable being things like Int Bool Char
23:14:36 <quanglewangle> ?
23:14:41 <Axman6> (*2) is the thing with type (a -> b)
23:14:44 <Axman6> :t fmap
23:14:45 <mauke[> no, those are type constants
23:14:46 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:14:49 <Axman6> :t fmap (*2)
23:14:50 <lambdabot> (Functor f, Num b) => f b -> f b
23:14:55 <Axman6> :t fmap (*2) [1..10]
23:14:56 <lambdabot> (Enum b, Num b) => [b]
23:15:04 <Axman6> :t fmap (*2) `asAppliedTo` [1..10]
23:15:06 <lambdabot> (Enum b, Num b) => [b] -> [b]
23:15:16 <quanglewangle> type variable being things like Int Bool Char?
23:15:21 * hackagebot either 4.4 - An either monad transformer  http://hackage.haskell.org/package/either-4.4 (EdwardKmett)
23:15:21 <mauke[> no, those are type constants
23:15:35 <quanglewangle> so more like Maybe
23:15:40 <mauke[> no
23:15:40 <quanglewangle> a type constructor?
23:15:52 <Axman6> more like the a's and b's in fmap's type
23:15:52 <mauke[> if it starts with an uppercase letter, it's not a variable
23:15:54 <Axman6> :t fmap
23:15:55 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:15:57 <quanglewangle> hang on, you mean type variable like a and b
23:16:01 <Axman6> (and the f)
23:16:02 <quanglewangle> placeholder/dummys
23:16:02 <quanglewangle> yeah
23:16:49 <quanglewangle> ok, let me go back to my text :) let's see if I can grok this 
23:17:09 <mniip> edwardk, still not sure how it is related
23:17:23 <mniip> edwardk, I have something like this http://lpaste.net/2133184241582735360
23:17:33 <mjrosenb> Is there a way to Serialize data, while preserving structure?
23:17:50 <mniip> but I only can do this stuff with algebraic datatypes
23:18:06 <edwardk> mniip: just replace natVal with 'reflect' in your code
23:18:14 <edwardk> and KnownNat with Reifies s Integer
23:18:22 <quanglewangle> Axman6: thanks
23:18:27 <quanglewangle> mauke: Thanks
23:18:44 <mniip> edwardk, yeah but what about stuff like
23:18:53 <pavonia> mjrosenb: Structure is usually recovered by deserialization
23:19:33 <mniip> case mkLengthyList "hello" :: LengthyList 5 Char of LengthyList xs -> length xs
23:20:01 <edwardk> instance KnownNat n => Reifies n Integer  -- already exists.
23:20:25 <mniip> edwardk, I mean, length returns an integer, an untagged integer
23:20:30 <edwardk> yes
23:20:31 <mniip> how do I reify that
23:20:55 <edwardk> reify :: a -> (forall s. Reifies s a => Proxy s -> r) -> r
23:21:14 <edwardk> you get a nested scope in which you get access to 's'
23:21:31 <edwardk> where you can reflect s back down and get 'a' back
23:21:39 <mniip> hmm
23:21:58 <mjrosenb> pavonia: really?
23:22:02 <edwardk> the trick is figuring out how t shape your program such that it follows a 'stack discipline' about what nested scopes you need
23:22:03 <mjrosenb> that seems unlikely.
23:22:10 <mniip> edwardk, more like
23:22:28 <mniip> shaping your program such that you reify at the place where the phantom tag is still present
23:22:40 <mniip> that's the kind of issue I'm having
23:22:47 <pacak> If I know n on compile time but as a value - foo :: Proxy a -> Int is there any easy ways of getting a Tagged with ghc type level literals? (without using TH that is)
23:22:47 <HaskellStudent81> Hello, can anyone tell me why the last line of this function, balanced, http://lpaste.net/133544,  needs to be as it is, and not simply be "height t1 == height t2"  ?
23:23:08 <edwardk> so what you can do for instance is take a list and build a lengthy list in a scope
23:23:27 <pavonia> mjrosenb: Maybe we don't talk about the same thing. What data do you mean, and what kind of serialization?
23:23:33 <pacak> HaskellStudent81: You have one extra balanced on the last line
23:23:44 <mauke[> pacak: ?
23:23:47 <mjrosenb> pavonia: for FFI's, or in general, like when writing to disk.
23:24:17 <HaskellStudent81> pacak: I don't think so, that's as it is in the book
23:24:29 <mjrosenb> pavonia: and let x = Leaf; y = Node x 1 x; z = Node y 2 y; w = Node z 3 z
23:24:31 <mniip> pacak, missing indentation probably
23:24:38 <mniip> HaskellStudent81, without that you don't get recursion
23:24:51 <pavonia> mjrosenb: There the Binary class which lets you convert a value to ByteString and back
23:24:53 <mauke[> mniip: why is it important to get recursion?
23:24:54 <edwardk> reifyList :: forall a r. [a] -> (forall n. Reifies n Integer => LengthyList n a -> r) -> r; reifyList xs f = reify (length xs) $ \(p :: Proxy p) -> f (LengthyList xs :: LengthyList p a)
23:24:58 <pacak> HaskellStudent81: Burn the book.
23:25:01 <HaskellStudent81> mniip: the height function is recursive though
23:25:03 <mauke[> pacak: what
23:25:11 <pacak> Hmmm... Indentation, right.
23:25:13 <mniip> you merely check whether the left and right branch of the top-level node have the same depth
23:25:18 <edwardk> now you can reify a concrete normal list into a LengthyList in a nested scope
23:25:42 <mniip> which, I would assume, is not what the definition of "balanced" is
23:26:02 <mjrosenb> pavonia: but how would it know that all 4 of the y's are the same?
23:26:37 <edwardk> you can also pack tat thing up existentially: data SomeLengthyList a where SomeLengthyList :: Reifies n Integer => LengthyList n a -> SomeLengthyList a  -- and then open SomeLengthyList when you want to get at the length as a refieid number
23:26:44 <HaskellStudent81> height http://lpaste.net/133545
23:27:04 <HaskellStudent81> mniip there is the height function, it is recursive. It's called by balanced, so I think that should traverse the whole tree
23:27:20 <mniip> it does traverse the whole tree but it only returns its height
23:27:42 <mniip> it tells nothing about the short branches
23:27:53 <mauke[> HaskellStudent81: http://lpaste.net/133546 this is not a balanced tree
23:28:28 <mauke[> also, are you really 81?
23:28:38 <Myrl-chan> How would you explain category theory to a 5 years old?\
23:28:43 <pacak> given foo :: Proxy a -> Int and foo (Proxy :: Proxy Bar) = 4 is it possible to get `Tagged 4 Bar` on a compile time without resorting to template haskell?
23:28:44 <opqdonut> mauke[: perhaps he was born in '81
23:28:44 <HaskellStudent81> 81 is the year I was born in
23:28:44 <pavonia> mjrosenb: Do you want to serialize Haskell variable bindings?
23:28:59 <mniip> Myrl-chan, where are your parents kid
23:29:04 <Myrl-chan> mniip: baka.
23:29:05 <Myrl-chan> :(
23:29:14 <Myrl-chan> mniip: You're not even a year older than me. ;-;
23:29:17 <HaskellStudent81> ok so for that tree a balanced function only checking if height t1 == height t2 would return true
23:29:46 <mniip> Myrl-chan, what? I'm much older than 6
23:30:23 <mniip> edwardk, makes sense now
23:31:51 <Sprog> Quick question
23:31:53 <Sprog> im working with 
23:31:53 <Sprog> http://www.serpentine.com/wreq/tutorial.html
23:32:02 <mniip> edwardk, in other news, tonight we tried to enumerate all possible law-conforming instances of Applicative []
23:32:13 <Sprog> In the erorr handling section it mentions a StatusCodeException. But it's not defined when I use it
23:32:18 <Sprog> where I can find where this is defined?
23:34:23 <mniip> and so far it only boiled down to, for every n, defining an endofunction with domain/codomain of forall x. (n-tuple-of x, [x]) 
23:34:42 <mniip> er
23:34:43 <joneshf-laptop> Sprog, looks like http://hackage.haskell.org/package/http-client-0.4.11.2/docs/Network-HTTP-Client.html#t:HttpException
23:34:47 <mniip> n-vector?
23:34:58 <mniip> whatever would you call a homogeneous fixed size list
23:36:33 <Sprog> @joneshf-laptop in order to import just that would I do import Network.HTTP.Client (StatusCodeException)?
23:36:34 <lambdabot> Unknown command, try @list
23:37:19 <mniip> dmwit, hmm, now that I think of it, there are a few duplicates in there
23:37:32 <mniip> dmwit, you were correct about only needing the indices
23:39:22 <joneshf-laptop> Sprog, since it's a constructor in a data type, you have to import the constructor from the data type
23:39:47 <joneshf-laptop> Sprog, `import Network.HTTP.Client (HttpException(StatusCodeException))`
23:39:55 <Sprog> hmm interesting
23:39:56 <Sprog> that works
23:40:05 <Sprog> I need to read more on imports
23:40:34 <Sprog> another question I had was, if across multiple .hs files I have a similar "pack" of imports I use, is there any way I can save space by creating an "import file"?
23:40:40 <Sprog> and then just import that file?
23:41:00 <mniip> for any natural Natural -> Natural -> Bool with the invariant of one being smaller than another
23:41:32 <mauke[> Sprog: sort of. you can reexport entire modules
23:41:58 <mauke[> module X (module A, module B, module C) where import A; import B; import C  -- I think that's the syntax
23:41:58 <mniip> then [] becomes \_ _ -> False, and ZipList becomes \_ _ -> True !
23:42:26 <Sprog> mauke[, thanks I'll look into that
23:46:41 <mjrosenb> pavonia: no, but i would like to avoid exponential blow up.
23:50:22 * hackagebot terminal-size 0.3.2 - Get terminal window height and width  http://hackage.haskell.org/package/terminal-size-0.3.2 (MatveyAksenov)
