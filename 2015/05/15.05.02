06:19:08 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org | https://news.ycombinator.com/item?id=9465999'
06:19:08 --- topic: set by geekosaur!allbery@dreamshell.ttuttle.net on [Thu Apr 30 10:50:11 2015]
06:19:08 --- names: list (clog eriksensei marcus-aurelius_ tibbe lodvaer pata dan_s nszceta raichoo osa1__ jacquerie revath marchelzo_ ljs hugomg kuribas vin-ivar kadoban mac10688 semigroup ps-auxw Apocalisp gusto jfischoff joelhe ansible1 gienah jomg jutaro xuechaokang colt44 Soft PatrickRobotham ktosiek MuffinMan` gsnewmark crocket frodwith iasoon nshepperd Betal dbushenko adam_hardkey_shi drangewdk foreignFunction fro_ozen vlatkoB quyse silver Palmik maerwald wei2912 JanBessai)
06:19:08 --- names: list (rossberg codygman bollullera seangrove drbean jophish_ PinealGlandOptic cellopin shouya_ dnorris inhortte mkster NightRa Jackneill Vorpal ph88 rprije ceii shesek sdothum amiri d_k marcus-aurelius Mon_Ouie g00ey cleamoon hjulle sam_d ndrei ryantrinkle nour nick_named shadowcreator archdria ziocroc SCHAAP137 Fusebox pantsman- laar jedws edon plutoniix schlicht kvey pacon josdeha_rt SoupEvil asQuirreL DrAwesom_ Wizek Darki1 xahry mrArkwright funfunctor jaen)
06:19:08 --- names: list (HEGX64 grizwako hotcore ch3f wtw acmiyaguchi steell m0rphism hattusili_III chpatrick Xilov whiteline joneshf-laptop zettablade shintah zxq9 Longlius Gama11 predator117 mountaingoat lritter_ sakirious hamishmack vili biglama turtil shahn srid CapitalSigma rejuvyesh bb010g unknownloner gfixler segf resio MrWoohoo tg mmaruseacph2 julmac Gurkenglas nullremains Hijiri chrisdotcode xificurC boxfire zilinc Oxyd mauke mthvedt s00pcan mkeeter fumieval dp_wiz argoneus)
06:19:08 --- names: list (sunnymil1 pyon aarvar eisbehr xinming_ PyroPeter QuadTan srcerer Azel jud rwiggins tinyblak darkf sleblanc orion enaqx elben clarktic jtanguy maurer hive-mind dan_f hexagoxel lspitzner exferenceBot Stratege_ dsantiago renekooi sbrother Khisanth Cale amatsu tvh Or1 greenbagels Juka asjo ahihi Pamelloes cyphase dspiteself xxpor Eiam sharvils johtso_ zalami mudphone` ubuntor yrdz __main__ tusj Guest91679 sabalaba thelastinuit schell sdboyer ThatOtherPerson_)
06:19:08 --- names: list (arjanb dav David cbm80 larsen_ mach mpereira fling ajajaja pii4 ctag m4lvin gnusosa Yuras Voldenet dreams balaji skeet70 t7 condy aoellle bergey kidnapped_robot nmontecc LQYMGT s1n4 jix rodlogic nuttycom notthemessiah twoa creichert HylianSavior zariuq goldfire _ashbreeze_ luzie folsen saurik kapil___ yusukesuzuki ibid solrize cursork thunderrd Aruro tranma comma8 ValicekB theDon dcoutts theanalyst majorseitan mniip shirt glguy sebastard emma dino- dropdrive)
06:19:08 --- names: list (ruukasu tsou PotatoGim sokoll Jesin thetallguy jchmrt hackagebot dented42 steshaw erikd tv2 Vbitz loz-- chishiki codyopel lyddonb jonesinator abh haroldwu nwf bananagram monochrom tomku otto_s_ jordanl tinchos miklcct hongminhee hellome Ralith sudog junmin wedens Zekka Sorella shmookey1 benzrf CMCDragonkai Sqt devi pacak dmiles_afk gbourdin|away robogoat grache28 Guest6727694 Giggaflop vdg bthom1 dbelange_ jaffachief TRManderson kfish bjorkintosh kemitchell)
06:19:08 --- names: list (falafel ormaaj nominolo_ nominolo linduxed da-x tgeeky Kruppe Sigyn mrsolow deni kloeri RevJohnnyHealey lachenmayer waern atomi aleator lieven NeatBasis simon thomas koomi trevorriles Orwell84 so Nadrieril burp ajf troydm psy Iceland_jack dh akurilin joris974__ Paradisee fr33domlover zeiris zso nominolo|work dabradley noddy marienz ezrios Draggor Plastefuchs rseymour rui2 edwtjo bvad bbee cdidd doctorinserenity masse heurist lattenwa1 xandaros solirc)
06:19:08 --- names: list (Guest96958 brixen efm maw klarrt paf31_away srhb platz_ Profpatsch drmegahertz friden tomboy65 Tehnix td123_ ernst jstolarek obcode Freundlich myme gbiv bshelden samnmax ByronJohnson pygospa frontendloader whitesn Eliel shlevy bdamos _ether_ buoto serutsub1 d3lxa cdk sternenseemann deadf00t nik_89 CosmicRay mimi_vx whaletechno eagleflo stbuehler ivan\ mceier ttuegel besenwesen WSergio TheMoonMaster natte lahwran tomaw lifenoodles_ pharaun StoneToad agumonkey_)
06:19:08 --- names: list (benonsoftware surtn ]OLI[ Factionwars LnL Bane^^ nak happy0 Vq thephoeron_ Natch_l jlewis PHO dlundy_ ad byorgey fall` pleiosaur eivuokko frawgie_ Kneiva koala_man lyxia zso__ dhrosa_ luite oscar_to1o bjobjo biio_ sLite_ ekeane1 proq`` ChongLi_ martingale trolling int-e Moggle1 kstuart decrypt cmn Excureo ScRaMbLe stelleg Ellah bdesham colah scpike tsani tongcx dixie_ hator neptunepink sys9mm Enigmagic jimstutt ij tumdedum tdammers eyck FreeFull Trubydoor)
06:19:08 --- names: list (infinity0 dustinm tromp_ Guest24409 nitrix `0660 martintrojer zimbatm fengshaun bartavelle LeaChim lvh brolin_empey dmwit pharpend zhengyangl jonaias_ canta jml geekosaur Athas cscorley lambdabot Floyd_ _rgn kmicu bonobo_ melter fikusz unsymbol phaazon Dynetrekk ghorn knyppeldynan rivarun kakos descender hbar scott elementalest RazWelles peterood sunnavy spwhitt johnraz_ usr keko_ benwf sw1nn dreixel DenSchub petercommand eevar gseitz Nik05 cchalmers rieper)
06:19:08 --- names: list (Qfwfq joehh RayNbow` nyuszika7h catsup enolan ellinokon Yawgmoth johnw dschoepe hpc ashnur capybara_ mephx hiratara ryanakca ninzine brezel ssedov Internet13 bennyklo1z bennyklotz Tristan-Speccy levi stoopkid Talryn thade rjsalts quaestor pikhq Philonous KitC alynn ousado namuromus karls Eagle_Erwin phy1729 u_ _ikke_ djellemah imalsogreg malllle KeelOfSteel donwilliam ggVGc CyberDuckLard samgd jaspervdj kaol Desoxy arjen-jonathan lsep Ankhers anders^^ lykkin)
06:19:08 --- names: list (cpa jcp DustyDingo f|`-`|f aftershave hodapp haBuu marens noctux sinopeus korpse_ carter lokydor benedikt davl fvgvxmpv1 smtudor cyborg-one constantinexvi zasimov helgar naudiz Haskellfant yac chris2 SaidinWoT ion isocliff mtbottle xplat aupo SHODAN IbnFirnas bdha arkeet lemmih wrengr_away heath JamesJRH dibblego stomp mgomezch _1126 chirpsalot Chobbes jameseb StoneCypher iambernie albel727 RGamma jmcarthur jessicah sunwukong jbalint Dykam Ferdirand dgorbik_)
06:19:08 --- names: list (noam earthy dexterph earldouglas irishsultan Tene ironChicken AndreyG jpiche conehead edk cjay paperziggurat Shagane liste wagle apo_ Nickeeh Jaxan gniourf kolmodin jophish nurupo ilias u-ou BeardedCoder S11001001 otherchas_ darkowlzz|afk tridactyla Maxdamantus vikraman ixian8 bgamari_ bgamari cschneid sorind Nimatek mikel sclv Xorlev idnar NemesisD dkua nrw hellschreiber seancorfield adimit_away mbrcknl arnihermann GGMethos perrier HamburgerDude milli zysh)
06:19:08 --- names: list (Cerise relrod zerokarmaleft izabera CARAM__ sephiap stasku si14 agrif mikeizbicki wjm zpconn__________ ehamberg drone| yrashk bigs poikon jabbslad_ bcarrell lambdahands cojy_ jonrh Heero alekst_ spdionis jfokkan mindos_cloud____ bcavalier cloudhead_ andrew__n jroesch lohkey abrar heyj tomphreek Zemyla nem_z Zanzare AntiSpamMeta _fritz_ gibbers dilinger_ dgonyeo Pucilowski oherrala bydo huzi Baughn Sonderblade newsham xpika posco Axman6 scopedTV TDJACR dunj3)
06:19:08 --- names: list (mero guampa teclo- jaseemabid_ ForNeVeR Igloo crodjer octalsrc etabot nuser hpd renzhi zq kevin1024 hemite ninegrid tuv poucet_ bracket_ MitchW sleepynate Laney tessier sm cods_ eamelink_ zenzike_ duga lenstr JZTech103 Guest22687 spacebug Adeon augur ronh arrdem mvc` Quashie aleator_ Korri pieter_ flux chadkennedy tjbp mortberg iElectric aristid_ gabriel_laddel inuoppai biscarch incomprehensibly doppioslash vikram_ chriswk sweenzor phuu bgyss ikke Flaeme)
06:19:08 --- names: list (etrepum joedevivo cjwelborn seagreen n1ftyn8 Klumben Cr8 kjnilsson drewdavis grol Forkk mitchty lpaste meretrix killerpty jmct honza ackthet kess_ aseidl ortmage atn34 ephemeron nakal Bigcheese coyotebush jzl waxjar huonw Tiktalik pii Hugglesworth acfoltzer kav metaf5 dawik_ rabisg BlakeRai1 shachaf igniting tomjagua1paw SwashBuckla klugez otulp tomprince ndeine- pm5 niko rofer djanatyn Cathy seliopou Jellydog wolf_mozart oconnore arw Xe skarn gratimax Saizan)
06:19:08 --- names: list (derekg davesilva_ Fylwind DANtheBEASTman eyenx iron_houzi gmaslov vladan foolie pranz niklasb flori froztbyte nathanic R0b0t1 saiam freusque padre_angolano lf94 pdxleif swen fionnan_ robotbrain fugyk absence jcurbo Ezku_ lurker6_ theorb_ gargawel_ stvc taksuyu Phillemann paz eyem mrowe_away michaelpj heaumer_ M-ou-se wayne sdx23 optocoup1er dqd zymurgy phaskell s4msung kjanosz hc saep zhulikas EnergyCoffee thorkilnaur_ Willis LordDeath Xnuk Fubar^ _flow_)
06:19:08 --- names: list (Lutin` alevy mrb_bk rbocquet rj-code Reiser cstrahan mankyKitty eniirane jnoah beauby anachron_ greymalkin exio4 Draconx drdo Edoxile bsmt tarcwynne BrianHV mietek mno2 barrucadu Elsi cryon bergmark zrl AlainODea c9sould__ az uwap jlamothe jrslepak tlevine sellout- jtobin_ deavidsedice staffehn_ samertm tismith_ seabre coeus andreypopp saolsen lacrosse__ kalz akahn dlackty___ moy shennyg Tritlo fuziontech rslima nmashton avdi zph spion ElderFain owa crlane)
06:19:09 --- names: list (fnordbert Geekingfrog lispy pi8030 mirsal rom1504 krgn yarou sgronblo_ rray tzaeru shiona_ vodkaInf1rno puzza007 Guest60091 taruti electrogeek liff armyriad negatratoron zaquest solarus tnks boot13 gws Wamanuz ollef Schrostfutz PlasmaStar ecraven milieu BMeph aaronlevin Svedrin Polarina dolio Dodek rola ido Xack apollo1993 Elision verement supki dgvncsz0f ljhms kvieta pyloid jle` umbriel nemesit|znc grohne tswett therealklanni demolithion byaruhaf juri_)
06:19:09 --- names: list (simpson alanz noteventime MMuse_______ alphonse23_ nbouscal kirjs_______ trig-ger dstockwell Darkflux totte andrewsw aloiscochard wizonesolutions bsummer4 caasihuang josephle pyrtsa fyolnish somenick duairc kaictl hvr bitemyapp znutar esssing shapr brackets hooptw Gothmog_ ZsoL janne sea-gull tristero XMunkki SparkySparkyBoom eddsteel statusbot ski zorzar aaronweiss74 rdema nkpart Liskni_si AWhetter ParahSailin OutlawStar fryguybob kqr dewdrop nvd dario`)
06:19:09 --- names: list (greeny kaw_ lamilami suls rul netj_ hrnz inr kalloc Boney Tesseraction lassulus spaceships avocado flx aidecoe butyoudonot qr42 robbert ajp andjjj23 kloplop321 cosban sku1d blenny Twey thomie irclogger_com ephess karshan lpsmith dmilith TallerGhostWalt mak` ayertienna cjh` itsmonkt1stic jarvi_ keaml_ runde lytchi yorick mokus_ mgaare ziman zyoung_ sivoais hiredman aaronm04 mitu SuperTux88 harski Preyer horlicks_ ChristianS magicman kini dxld sbrg frogpunc)
06:19:09 --- names: list (voidzero liyang dju McManiaC amiller certainty capisce jlind Adios_ kriwil glowcoil astocko enomies gpampara WarzoneCommand JPohlman1 pederindi averell e4x thomassgn MK_FG c-rog malglim agam adnap enojelly anoe ricardo82 suvash_away _di fold bob_twinkles Ring0` nesqi hegge SLi hyPiRion andreass_ edwardk haasn abbe yminsky bind brent80_plow bernalex uber RageD timothyh japesinator Brando753 ircbrowse brisbin raid codehero cin Blkt psacrifice eikke defanor)
06:19:09 --- names: list (Guest90609 jokra bafbomb_ tolt Guest48087 RustyShackleford jacksnipe devJunk fall_ Paprikachu iross ryantm sdressel jackhill blast_hardcheese wenzowski zero7 carter_cloud comboy arianvp alpounet cowtown bolmar kvalle rtl dredozubov mechairo` noplamodo DanZimm geal d-snp sagelywizard amontez Nanar jayne ggreg niluje bcoppens Clint betawaffle davean gbarboza sujeet phadej yukonjack kennyp gmcintire nikola AshyIsMe Ptival adlan fractalcat yeltzooo9 gtklocker)
06:19:09 --- names: list (thebnq CindyLinz sbauer322 dicioccio mattp|spurs numberten cYmen_ tromp annulus angryzor gdsx joeytwiddle FireFly Jello_Raptor joshc joehillen pmade cynick GaveUp xnyhps anastas mendez_ monsieurp qz asm89 Intensity [swift] Uritomi2 heikkih elgot opqdonut Chousuke KaneTW Mandus f_x_ xaimus mikeplus64 majoh Guest37394 orzo Th0mas albertid Watcher7 ckw Heffalump banjiewen ReinH callumacrae mp ClaudiusMaximus cross cYmen mt mikedanese AncientPC jakutis Eldrad)
06:19:09 --- names: list (pingu ggherdov Raynos bkolera ocharles_ Erstarrung bjornars1 xxx zxtx Rembane Rastus_Vernon tazjin twopoint718 dan64 Ke Starfire _klm gridaphobe valdyn Paks mjo martinbmadsen eL_Bart0 ilmig rudi_s mpw bijumon brennie nisstyre joeyh mlen plhk Dtgr mrd Belgarion0 mads- ft spindas Jaak dowski_ machineslearn thoughtpolice aleator_1 zomg hanDerPeder sohum BillyIII SegFaultAX Sornaensis obiwahn kipras`away monty avn oberstein Spockz fergusnoble peddie Jonno_FTW)
06:19:09 --- names: list (petantik jkarni JonasH__ emmanueloga shelling__ julienXX DigitalKiwi Fuuzetsu mpickering sajith notdan slasktask rs0 kgadek wto fredsir senseibaka dpn` mami kosmikus mjrosenb statusfailed kazawore_ dabukalam zeroskil1or seanparsons integral Walther kwantam felixsch Ornedan pfoetchen killtheliterate alem0lars jlouis ahf isomorphismes otterdam jlyndon jrp6 fmapE kshannon schlumpi adamse Hafydd tekacs alang Razz Boreeas tych0 osfameron howard s_e kragniz tero-)
06:19:09 --- names: list (arch_ edran_ @ChanServ Atlanis Deewiant Ulrar)
06:19:09 -hobana(freenode.net)- [freenode-info] channel trolls and no channel staff around to help? please check with freenode support: http://freenode.net/faq.shtml#gettinghelp
06:21:49 <kuribas> Oh, It exists already: http://hackage.haskell.org/package/tuple-0.3.0.2/docs/Data-Tuple-Select.html
06:25:05 <kuribas> Does something like this exist for Sum types?  For example "Either3 alt1 alt2 alt3", Either4 ...
06:38:26 <Aruro> any good arrays in Haskell tutorial ? preferably multidimensional
06:38:33 <ReinH> kuribas: I use lenses for those things
06:39:32 <ReinH> Aruro: https://www.haskell.org/tutorial/arrays.html https://wiki.haskell.org/Numeric_Haskell:_A_Vector_Tutorial
06:39:35 <ReinH> fsvo "good"
06:39:49 <ReinH> also https://wiki.haskell.org/Numeric_Haskell:_A_Repa_Tutorial
06:41:43 <kuribas> ReinH: Lenses scare me :)  They look like line noise, or worse perl.  But that's probably because I don't know them yet...
06:41:55 <ReinH> You don't need to use the operators
06:42:21 <ReinH> you can import Control.Lens.Combinators if you don't even want them in scope ;)
06:42:21 <sagittarian> is there an easy way to convert between an Integer and a hex string?
06:42:57 <ReinH> sagittarian: https://hackage.haskell.org/package/base-4.8.0.0/docs/Numeric.html
06:43:19 <kuribas> sagittarian: You want to convert an integer to a hex string?
06:43:26 <ReinH> specifically showHex and readHex
06:43:49 <sagittarian> kuribas: yes I do
06:44:23 <kuribas> > printf "%x" 232452
06:44:24 <lambdabot>      No instance for (Show a0)
06:44:24 <lambdabot>        arising from a use of ‘show_M1636860492796574875595’
06:44:24 <lambdabot>      The type variable ‘a0’ is ambiguous
06:44:35 <ReinH> Ew
06:44:36 <kuribas> > printf "%x" 232452 :: String
06:44:38 <lambdabot>  "38c04"
06:44:41 <ReinH> Numeric is inbase
06:44:46 <ReinH> and isn't an abomination
06:45:20 <kuribas> read ("0x" ++ "38c04"):: Int
06:45:24 <ReinH> > showHex 12345 ""
06:45:26 <lambdabot>  "3039"
06:45:31 <kuribas> > read ("0x" ++ "38c04"):: Int
06:45:33 <lambdabot>  232452
06:45:55 <kuribas> ReinH: oh, nice
06:47:32 <sagittarian> thanks guys
06:47:58 <ReinH> kuribas: btw have you seen
06:48:02 <ReinH> @hackage formatting
06:48:02 <lambdabot> http://hackage.haskell.org/package/formatting
06:48:24 <ReinH> He has a nice blog post about it http://chrisdone.com/posts/formatting
06:48:28 <ion> > "deadbeef" ^? hex
06:48:30 <lambdabot>  Just 3735928559
06:48:33 <ion> > hex # 3735928559
06:48:35 <lambdabot>  "deadbeef"
06:48:37 <ReinH> Starting with "What’s wrong with printf?" ;)
06:48:50 <ReinH> ion: also nice, but of course requires compiling all of hackage
06:49:03 <ReinH> then again many packages probably already do so ;)
06:50:56 * hackagebot Rasenschach 0.1.3.1 - Soccer simulation  http://hackage.haskell.org/package/Rasenschach-0.1.3.1 (MartinWoehrle)
06:53:56 <kuribas> ReinH: I actually like printf, but you are probably right.  It can throw a runtime error, which is bad.
06:54:26 <Iceland_jack> kuribas: Has the 'formatting' library been mentioned?
06:54:29 <Iceland_jack> @hackage formatting
06:54:29 <lambdabot> http://hackage.haskell.org/package/formatting
06:54:31 <ReinH> kuribas: It's not awful, but it's a bit risky to recommend it for like this
06:54:36 <ReinH> Iceland_jack: yep :)
06:54:39 <kuribas> ReinH: true
06:54:39 <ReinH> *things like
06:54:43 <Iceland_jack> Ah
06:54:54 <ReinH> Iceland_jack: holey monoids are cool!
06:55:01 <kuribas> ReinH: lenses looks pretty powerful, but I dislike the line noise...
06:55:17 <ReinH> kuribas: as I said above, the line noise is optional
06:55:29 <ReinH> Control.Lens.Combinators contains zero operators
06:56:13 <ReinH> Some of the line noise is easier to stomach than others...
06:56:27 <kuribas> ReinH: I looked at https://hackage.haskell.org/package/lens-4.9.1/docs/Control-Lens-Combinators.html  It just exports Control.Lens?
06:56:32 <ion> > preview (base 36) "hello"
06:56:33 <lambdabot>  Just 29234652
06:56:41 <ion> > review (base 36) 29234652
06:56:42 <lambdabot>  "hello"
06:56:48 <ReinH> kuribas: yes, just without the operators
06:56:59 <kuribas> Ok, I see.
06:57:07 <ReinH> edwardk: in his infinite wisdom has seen fit to appease the operator haters by creating that module ;)
06:58:08 <ReinH> > (1,2) &~ _1 += 1 -- += and such are quite nice, ignore &~ it's just evalState
06:58:10 <lambdabot>  (2,2)
06:58:32 <kuribas> I don't hate operators though.  "_1" is fine, but  "^@.."  is line noise in my eyes.
06:58:36 <ReinH> or execState, I can never remember which is which
06:58:48 <ion> ReinH: Me neither
06:58:49 <ReinH> Sure, but you usually don't need to use the complex ones
06:59:02 <ReinH> (also _1 isn't an operator anyway)
06:59:16 <ReinH> they exist for special cases
06:59:34 <ReinH> But when you need them it's nice to have them
06:59:58 <ReinH> of course then sometimes you wonder what they do when you read your code 2 months later...
07:01:26 <ReinH> But I've gotten mileage out of, e.g., <<+=
07:01:59 <ReinH> Anyway, it's totally reasonable to think the operators are line noise :)
07:03:10 <Aruro> ReinH: ty!
07:03:57 <kuribas> Is there a library that has Triple or more generic sum types?  Like either, but for more than 2?
07:04:50 <kuribas> For example Either3 a b c = OneOf3 a | TwoOf3 b | ThreeOf3 c, Either4 a b c d = OneOf4 a | ...
07:05:14 <ReinH> kuribas: I don't know of one and wouldn't want to use it if it existed, for the same reason I don't use big tuples.
07:06:25 <kuribas> The problem is, sometimes I have functions which take a subset of the types I have defined in my file.  Then I need to create a new datatype for each of the subsets...
07:06:40 <kuribas> Even if it is only for one of two functions.
07:09:30 <ReinH> kuribas: maybe you want vinyl? its records are extensible.
07:11:03 <kuribas> Hm, that looks pretty neat...
07:12:14 <ReinH> It is pretty neat :)
07:12:29 <ReinH> I'm partial to it because it's done by a coworker ;)
07:15:36 <exio4> ReinH: nice! didn't know about vinyl!
07:16:03 <exio4> I was reimplementing a little bit of it the other day
07:26:44 <manik> Why changing nick name that much?:-)
07:35:07 <JanBessai> > some [1]
07:35:10 <lambdabot>  mueval-core: Time limit exceeded
07:35:28 <JanBessai> > head $ some [1]
07:35:32 <lambdabot>  mueval-core: Time limit exceeded
07:35:56 <JanBessai> > head <$> (head $ some [1])
07:35:58 <lambdabot>      No instance for (Show b0)
07:35:58 <lambdabot>        arising from a use of ‘show_M21991497561923379362120’
07:35:58 <lambdabot>      The type variable ‘b0’ is ambiguous
07:37:04 <JanBessai> > head <$> (head $ many ["foo"])
07:37:08 <lambdabot>  mueval-core: Time limit exceeded
07:37:15 <JanBessai> is this supposed to happen?
07:37:33 <ion> some and many aren’t useful in the list instance.
07:38:34 <JanBessai> same seems to be true for maybe
07:42:17 <ReinH> exio4: you might like https://vimeo.com/95694918 and https://vimeo.com/102785458
07:44:23 <ReinH> JanBessai: the problem is that they aren't productive: they don't allow pattern matching on a constructor until they fully evaluate, which is never.
07:48:18 <paolino> hello , how do I write better map (view f) . view g ?
07:48:48 <paolino> where view is from Lens package
07:49:31 <ReinH> paolino: view (f . g)?
07:50:03 <paolino> uh, no map ?
07:51:25 <alynn> :t view
07:51:26 <lambdabot> MonadReader s m => Getting a s a -> m a
07:51:33 <ReinH> Er, view (g . f)
07:51:44 <alynn> :t fmap (view f) . view g
07:51:45 <lambdabot> (Functor f, Show s, Show s1, Typeable f, Typeable b, Typeable s, FromExpr (Const b s), FromExpr (Const (f s) s1)) => s1 -> f b
07:51:57 <alynn> what
07:51:58 <ReinH> paolino: Oh, I misread, sorry
07:52:14 <alynn> oh
07:52:15 <ReinH> paolino: Can you give a concrete example?
07:52:17 <mniip> alynn, f and g are too fancy
07:52:19 <mniip> :t f
07:52:20 <lambdabot> FromExpr a => a
07:52:21 <alynn> :t fmap (view ?f) . view ?g
07:52:22 <lambdabot> (Functor f, ?f::Getting b s b, ?g::Getting (f s) s1 (f s)) => s1 -> f b
07:52:46 <alynn> :t map (view ?f) . view ?g
07:52:47 <lambdabot> (?f::Getting b s b, ?g::Getting [s] s1 [s]) => s1 -> [b]
07:53:11 <paolino> that's it
07:53:14 <exio4> ReinH: thanks! 
07:53:19 <ReinH> exio4: :)
07:53:46 <alynn> what is this I don't even
07:53:50 <alynn> I hate lens
07:54:35 <paolino> view g compute a list and I want to view a piece of every element with  view f
07:54:54 <alynn> map (view f) . view g seems pretty concise
07:55:04 <paolino> I can mpdify easy with traverse
07:55:29 <supki> paolino: toListOf (g.traverse.f)
07:55:32 <paolino> over (g . traverse . f) 
07:56:07 <ReinH> or (^@.. g . traverse . f), iirc
07:58:20 <paolino> mh, lens learning is ...
07:58:28 <paolino> thanks supki 
07:58:41 <ion> Does anyone have GHC HEAD? Does this panic? ghc -ignore-dot-ghci -fdefer-typed-holes -e 'map (\a b -> undefined) _'
08:03:46 <shmookey1> fd
08:11:38 <mjrosenb> the precedence of {} is strange...
08:19:34 <eraker> beginner question here: if I have a data type
08:19:34 <eraker> data Line =
08:19:36 <eraker>   Line [String]
08:19:37 <eraker>   | Whitespace
08:19:38 <eraker>   | etc.
08:19:40 <eraker> And I want to combine two line objects together, it seems like I should be able to do:
08:19:41 <eraker> (++) <$> line1 <*> line2
08:19:42 <eraker> But this doesn't work. 
08:22:06 <adamse> eraker: (++) works with lists of things, not Lines
08:22:10 <adamse> :t (++)
08:22:11 <lambdabot> [a] -> [a] -> [a]
08:22:36 <eraker> I was thinking I could use Applicative to apply it to my data type
08:23:45 <Azel> eraker: Line needs to have an instance of Functor if you want to use <$>
08:23:53 <Azel> :t <$>
08:23:54 <eraker> that’s what I was thinking.
08:23:54 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:24:11 <eraker> thanks, I’ll try that
08:24:35 <alynn> Line has the wrong kind to be a functor
08:26:27 <adamse> eraker: if you want to combine two lines you need to write a function f :: Line -> Line -> Line that does the correct thing for each of the constructors of Line
08:26:34 <Iceland_jack> eraker: data Line a = Line [a] | Whitespace | ...
08:26:34 <Iceland_jack>           deriving Functor
08:26:34 <Iceland_jack> You can massage 'Line' into being a Functor, I'd have to know more about your intent to say it that's a good idea
08:26:42 <eraker> ah
08:27:05 <eraker> that makes sense.
08:27:28 <Iceland_jack> But adamse is right, you need to write a bespoke concatenation function
08:27:38 <eraker> okay, I’ll do that. thanks for all the help.
08:27:48 <Iceland_jack> araujo: If you're familiar with Monoids it should probably be an instance of that
08:28:12 <Iceland_jack> Either with
08:28:12 <Iceland_jack>     mempty = Line []
08:28:12 <Iceland_jack> or you can add a distinguished empty element
08:31:40 <ReinH> eraker: consider making Line a monoid
08:32:03 <eraker> alright. I’ll look into that too. I have the function version wired up and working.
08:32:07 <eraker> I’ll try that next
08:32:09 <ReinH> Iceland_jack: heh
08:42:39 <ysr> I am loving acme modules :D
08:43:42 <ysr> https://hackage.haskell.org/package/acme-now
08:44:38 <ysr> https://hackage.haskell.org/package/acme-lookofdisapproval
08:47:45 <hpc> ysr: the package with the most jokes is acme-php, and the package with the best single joke is acme-schoenfinkle
08:51:58 <ysr> hpc have you seen https://hackage.haskell.org/package/acme-everything ?
08:52:45 <hpc> dear lord
08:53:18 <hpc> "All reported builds failed as of 2015-04-18"
08:54:01 <hpc> https://github.com/quchen/acme-everything/issues/1 -- my favorite part
08:55:16 <ReinH> Opening the hackage page broke my browser
08:55:23 <ReinH> I had to force kill it
08:56:15 <ysr> hpc hahah :)
09:03:41 <nuttycom> eraker: seems to me that you want to create Monoid Line
09:13:19 <shourya> Hey everyone.
09:14:05 <shourya> Anyone?
09:14:20 <KaneTW> dead channel
09:14:22 <KaneTW> rip
09:14:23 <trizko> hi
09:14:26 <Tehnix> RIP ;_;
09:17:06 <trizko> hey shourya
09:17:17 <trizko> how are you
09:17:49 <ion> hpc: I think the package with the best joke is http://hackage.haskell.org/package/gutenberg-fibonaccis-1.1.0/docs/Algorithm-Gutenberg-Fibonaccis.html#v:lastFib
09:22:58 <phy1729> I seem to be doing map (map func) a lot to map on [[a]]. Is there a better way? Hoogle doesn't suggest anything.
09:23:23 <ion> There’s nothing wrong with that. One can alternatively say (map . map) func
09:24:13 <phy1729> ok. I suppose there's can't be a function that goes n deep since the types change each time
09:24:29 <ion> Also, things like (foldMap . foldMap) and (traverse . traverse) work. This is what makes lens composition nice.
09:25:23 <hpc> ion: doesn't count, not acme
09:25:29 <hpc> someone wrote that in earnest
09:25:46 <ion> That makes it even more funny.
09:26:35 <hpc> still not as funny as hasslich :P
09:27:19 <hpc> so much buildup on top of real abstraction and historical details
09:27:21 <hpc> just for a pun
09:37:57 <uwap> :t liftM2
09:37:58 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:49:30 <felixn> https://gist.github.com/munro/7d199120f50421910d14#file-erg-hs-L24 <-- is it possible to set intermediate types in where/let?  trying to do that on some feedback to make my code more readable
09:51:55 <Zemyla> Is there a difference performance-wise between \f -> f a and ($ a)?
09:52:00 <felixn> I'm sorry I finally found it D:  ScopedTypeVariables
09:53:08 <felixn> Zemyla: I would think GHC would evaluate what it can at compile time, and that would be one of them
09:54:58 <ReinH> Zemyla: Only if it didn't inline for some reason, and even then it would be incredibly small.
09:56:05 <ReinH> If you want to check, you can look at core
09:56:24 <DMACM> hello
09:56:27 <athan> Functional dependencies make generic instances (say with Flexible Contexts). Am I on the right trail, here?
09:56:33 <felixn> ReinH: could you compare binaries?  I know rust spends a lot of time looking at compiled assembly
09:56:49 <ReinH> felixn: Sure, but you can just compare core instead
09:57:01 <DMACM> can any1read this please let me know
09:57:07 <ReinH> DMACM: yes
09:57:12 <DMACM> ty
10:09:32 <McManiaC> hey, how can i get ghci to include packages from cabal sandbox?
10:13:08 <bergmark> McManiaC: you can use cabal repl
10:13:22 <edofic> McManiaC: ghci -package-db .cabal-sandbox/x86_64-linux-ghc-7.8.4-packages.conf.d/
10:13:38 <edofic> fix according to your platform and ghc version
10:14:02 <int-e> gmcintire: ca
10:14:53 <int-e> McManiaC: cabal repl  should do the trick, or perhaps  cabal exec ghci (if you need further flags)
10:16:08 <McManiaC> bergmark: oh damn, sweet!
10:16:18 <McManiaC> thats even better than what ive been using ghci for :)
10:18:06 <phy1729> Can I do pattern matching in where? E.g.  where (foo, bar) = ...
10:18:15 <Iceland_jack> yes
10:18:17 <_fritz_> yes
10:18:24 <phy1729> thanks
10:21:08 <kuribas> Wouldn't this be a nice way to have multiple arity Eithers: http://lpaste.net/131902
10:21:29 <kuribas> Only the Zero at the end is inconvenient.
10:21:35 * hackagebot texmath 0.8.2 - Conversion between formats used to represent mathematics.  http://hackage.haskell.org/package/texmath-0.8.2 (JohnMacFarlane)
10:21:37 * hackagebot recursion-schemes 4.1.1 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-4.1.1 (EdwardKmett)
10:22:32 * mjrosenb just did something rather reasonable, and was suddenly surprised that I thought it would ever work
10:23:02 <mjrosenb> now I'm wondering if there is a flag to turn it on
10:23:38 <mjrosenb> namely, I have data Foo = Foo { a :: Int, b :: Int -> Int }
10:24:05 <mjrosenb> and I tried to write x = Foo { a = 10, b x = (x+1) }
10:24:08 <kuribas> Would there be a way to eliminate Zero?
10:24:33 <Iceland_jack> mjrosenb: that is reasonable but you need to write
10:24:33 <Iceland_jack>     Foo { a = 10, b = \x -> x + 1 }
10:24:42 <Iceland_jack> or just b = (+ 1)
10:24:59 <mjrosenb> Iceland_jack: right.  that's what I changed it to
10:25:21 <mjrosenb> Iceland_jack: but I'm wondering if there is some special ghc LANGUAGE flag that will make it actually valid.
10:25:36 <Iceland_jack> I believe there isn't
10:25:44 <mjrosenb> bummer
10:26:35 * hackagebot list-t-attoparsec 0.3.1.0 - An "attoparsec" adapter for "list-t"  http://hackage.haskell.org/package/list-t-attoparsec-0.3.1.0 (NikitaVolkov)
10:27:56 <kuribas> Wouldn't it be nice to have anonymous sum types, like there are tuples for product types?  For example: http://lpaste.net/131902
10:29:28 <mjrosenb> kuribas: that sounds dangerous
10:29:44 <shachaf> As long as you have those, they should be n-way rather than two-way.
10:29:53 <shachaf> And the next step is unboxed sum types.
10:30:25 <kuribas> better version: http://lpaste.net/131902
10:30:45 <athan> Is there a way to unpack the _last_ monad in a transformer stack, instead of the head?
10:31:04 <kuribas> mjrosenb: Why is that dangerous?
10:31:32 <kuribas> shachaf: They are n-way?
10:32:41 <shachaf> Well, not in implementation.
10:33:03 <kuribas> shachaf: How do you implement n-way sum types?
10:33:45 <shachaf> The same way you implement n-way tuples, I guess. Or what do you mean?
10:33:55 <shachaf> It's the same issue as HLists vs. tuples.
10:34:17 <enthropy> athan: write a class&instances that looks like init
10:35:19 <athan> enthropy: Ahh :) Thank you!
10:35:31 <enthropy> I think you need overlapping instances
10:36:22 <enthropy>  class InitT ttma tma | ttma -> tma where initT :: ttma -> tma
10:36:47 <Iceland_jack> A recent paper on compdata shows how to encode basically anonymous coproducts without overlapping instances
10:39:08 <kuribas> shachaf: I have no idea how to do that...
10:45:08 <kuribas> shachaf: I don't even know if that's possible.
10:56:42 * hackagebot aws 0.12 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.12 (AristidBreitkreuz)
10:59:29 <kuribas> shachaf: Something like this? http://lpaste.net/131902#a131904
11:31:44 * hackagebot stackage-install 0.1.0.2 - Secure download of packages for cabal-install  http://hackage.haskell.org/package/stackage-install-0.1.0.2 (MichaelSnoyman)
11:41:44 * hackagebot acme-safe 0.1.0.0 - Safe versions of some infamous haskell functions such as fromJust  http://hackage.haskell.org/package/acme-safe-0.1.0.0 (fgaz)
11:42:04 <hpc> oh no
11:45:10 <jle`> kuribas: a lot of languages have anonymous sums.  they would be nice sometimes
11:45:32 <kuribas> Would something like this be of interest?  http://lpaste.net/131906
11:46:12 <kuribas> It would be a bit messy in infered type signatures though...
11:47:39 <kuribas> And only up to 10
11:47:44 <monochrom> hpc: safeFromJust :: Maybe a -> Maybe a  \∩/
11:47:55 <monochrom> @quote monochrom safeFromJust
11:47:55 <lambdabot> monochrom says: I use safeFromJust :: Maybe a -> Maybe a
11:48:13 <indiagreen> is there some way to install several packages from Hackage together with a local package? something like “cabal install text lens code/pkg/pkg.cabal”
11:48:51 <indiagreen> I just need them all to have consistent dependencies
11:49:34 <iankronquist> if an imperative language is like a recipe a functional language is like what?
11:50:01 <iankronquist> I'm trying to come up with a good analogy for non-programmers and you might have some ideas.
11:50:37 <monochrom> is an imperative language like a recipe? really? why? what is the mathematical definition of "like"?
11:50:38 <kuribas> jle`: should I put this on hackage?
11:51:38 <Clint> it's like a recipe because it has a list of all the ingredients at the top so your compiler can go shopping
11:51:44 * hackagebot persistent-ratelimit 0.1.0.1 - A library for rate limiting activities with a persistent backend.  http://hackage.haskell.org/package/persistent-ratelimit-0.1.0.1 (jp_rider)
11:51:46 <Welkin> iankronquist: car analogies are always popular with the common folk
11:52:05 <iankronquist> Hmm good idea Welkin, have any in mind?
11:52:07 <Welkin> Clint: haha
11:53:44 <bitemyapp> iankronquist: avoid analogies
11:54:11 <iankronquist> bitemyapp: this is for a writing professor. He isn't going to be learning Haskell any time soon.
11:54:35 <bitemyapp> iankronquist: pure functional languages are so-called because they're a lambda calculus-and-nothing-else
11:54:57 <monochrom> I know how to explain programming to a writing professor without using analogies
11:55:03 <bitemyapp> iankronquist: impure functional languages like Scheme and ML are lambda calculi augmented with effects/mutation/imperative
11:55:07 <bitemyapp> iankronquist: don't use analogies.
11:55:16 <jle`> iankronquist: i often say that it's like describing the food, instead of describing how to make it
11:55:35 <bitemyapp> jle`: gooby pls
11:55:39 <iankronquist> bitemyapp: just because this is a room full of pedants, I might point out that all programming languages can be reduced to lambda calculus.
11:55:42 <iankronquist> jle`: thanks!
11:55:52 <jle`> im gooby
11:55:56 <brbblnch> bitemyapp: Is there a pure, non-typed language ? Like haskel but for untyped lambda calculus?
11:56:18 <bitemyapp> bbee: plain old untyped lambda calculus.
11:56:35 <bitemyapp> iankronquist: well, you're wrong, but okay.
11:56:42 <brbblnch> bitemyapp: Well, *programming* language?
11:57:00 <dblarons> Any recommendations for a matrix / linear algebra library for Haskell? I'm going to need it for backprop in a neural network implementation. I've read about a few but wanted some up-to-date advice.
11:57:09 <bitemyapp> not that I'm aware of
11:57:39 <iankronquist> brbblnch: No, I'm fairly sure I'm right. Anything which can be computed with a turing machine can be computed with lambda calculus and vice versa.
11:58:12 <indiagreen> I don't get why people use the “describing the food” analogy. The difference between “tea is what you get if you take ordinary water, make it boiled, add tea leaves into it, and wait” and “to make tea you take water, boil it, add tea leaves, and wait” doesn't seem to be convincing at all
11:58:22 <brbblnch> iankonquist: Good to know!
11:58:25 <jle`> dblarons: for small scale library for linear algebra there's the `linear` package.  for high performance linear algebra libraries there's work on hblas bindings.  for working with matrices in general there's repa and things like that i think
11:59:03 <dblarons> jle`: Yeah, it seems like most of the libraries out there are fairly lightweight
11:59:13 <jle`> indiagreen: a more apt description would be "tea is something hot and tastes this way, and looks this color"
11:59:20 <bitemyapp> iankronquist: http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf if you feel strongly about the "all languages reducible to lambda calculi" you should publish your evidence and get Wadler to issue a retraction
11:59:30 <indiagreen> jle`: then it doesn't describe Haskell at all
11:59:31 <bitemyapp> iankronquist: I am positive it'd make for a fascinating paper.
12:00:04 <jle`> iankronquist: i think it's different to talk about a language and then talk about a turing machine implementing it.  people like to consider languages separate from their operational semantics
12:00:30 <jle`> there might not always be a nice isomorphism between the denotation of a language and its potential operational aspects
12:01:32 <kuribas> Anyone care to look at my n-ary eithers implementation?  Is it worthy for hackage?  http://lpaste.net/131906
12:01:42 <brbblnch> jle`: Could you expand? What does bitemyapp's linked paper has to do with it?
12:01:43 <iankronquist> jle`: thanks.
12:02:36 <Iceland_jack> kuribas: There are packages such as https://hackage.haskell.org/package/anonymous-sums
12:03:22 <jle`> indiagreen: sort of...it's an analogy that's probably more about denotative programming vs. imperative than functional programming.  things like "to make a list from one to ten, first start with one, then increment and add that, then increment and add that...", vs. "a list from one to ten is the first ten items from the list of numbers starting from 1."
12:04:04 <bitemyapp> brbblnch: I don't know of a programming language along the lines you describe
12:04:13 <kuribas> Iceland_jack: thanks, I didn't see that one yet.  Though I kind of like that my implementation uses the same data constructors for all n-ary sum types.
12:04:33 <jle`> or "to make a list of numbers satisfying predicate p, start with an empty list, check 1...if one fits, add it.  check 2...if 2 fits, add it.." vs, "the list of numbers satisfying predicate p is the list of positive nnumbers filtered by p"
12:04:33 <bitemyapp> brbblnch: there's really not very many pure languages (Haskell, Miranda, PureScript) and they all come with types.
12:04:46 <bitemyapp> brbblnch: it's possible one exists but I'm not sure why one would want to use it. Usually the types are the fun part :)
12:05:05 <bitemyapp> brbblnch: regarding relevance, read the first paragraph.
12:06:24 <iankronquist> brbblnch: I based my statement off of this introduction to lambda calculus, if you're interested: https://www.utdallas.edu/~gupta/courses/apl/lambda.pdf
12:06:42 <iankronquist> It's in the first paragraph
12:06:59 <brbblnch> bitemyapp: Relevance is ok. But what does the paper say that implies "a programming language is turing complete <=> it's equivalent to lambda calc" is false ? 
12:06:59 <c_wraith> bitemyapp: you forgot Clean!
12:07:14 <bitemyapp> c_wraith: oh right, yes. My mistake. Uniqueness types hoooo :)
12:07:26 <bitemyapp> iankronquist: turing equivalence is not the same as, "all languages are reducible to lambda calculus"
12:07:53 <brbblnch> iankronquist: thanks!
12:07:56 <bitemyapp> iankronquist: that would be like saying, because you can encode Rule 110 in CSS thus making it turing complete, all languages are reducible to CSS.
12:08:29 <Welkin> all programs are reducible to a series of low and high voltages too
12:08:53 <iankronquist> Welkin++
12:09:12 <Welkin> some people seem to have an obsession with categorizing and comparing things needlessly
12:09:46 <iankronquist> Well this is a room full of category theorists, so what did you expect, Welkin?
12:09:48 * iankronquist jokes
12:10:08 <brbblnch> bitemyapp: But it's still true that Turing equivalence implies: There is a program assigning output Y to input X in language A => there is a program for that in lang B. No?
12:11:48 * monochrom wants to know bitemyapp's reason, too
12:12:03 <ChristianS> brbblnch: if a language is turing-complete, then every program can be ported to that language, yes
12:12:42 <sbidin> I'm learning the lens library. I'm in a state monad, with the state having a certain field x. How do I update the field using an arbitrary function?
12:12:51 * monochrom can think up his own reason: neither Turing machines nor the traditional lambda calculus do interactive I/O, which Haskell does. not sure if it is the same as bitemyapp's reason.
12:12:59 <indiagreen> jle`: well, but it's not how people (okay, okay, just me) think about programs in imperative languages either – even in Pascal I treat a for loop over an array as “for all elements in array, X” instead of “for 1st element, X; for 2nd element, X; ...”. And I think there's a function in C++ which generates a vector filled with consecutive values, but even if there isn't, there perfectly could be. I get that being
12:12:59 <indiagreen> purely functional lets you have a lot of cool things with regards to program analysis, and the compiler would operate differently as well, but my point is that for *programmer* there isn't much difference between a functional language and an imperative language that has callbacks and the foreach loop. Or is there?
12:13:30 <indiagreen> (well, except that the functional language would be worse 'cause <no assignments>)
12:19:02 <sbidin> Okay, I figured it out: x %= func.
12:34:19 <FireFly> indiagreen: well, some would argue that it makes it easier to reason about code, in the same way that it's easier for the compiler to analyse it
13:22:28 <t7> indiagreen: your C++ program is proabably compiled down to Static single assignment form
13:23:17 <ggVGc> is there a performance cost for currying in GHC(and in general for other FP compilers), or does it perform optimizations when possible to perform less function calls>
13:23:21 <ggVGc> ?
13:23:39 <ggVGc> I mean, compared to if functions were not curried by default
13:24:35 <ysr> How long does it usually take to go from beginner to intermediate in haskell?
13:25:00 <rcyr> A decade or two :) j/k
13:26:17 <t7> i would say a few months hard work for intermediate 
13:26:35 <t7> expert is only available if you have the haskell gene 
13:26:41 <t7> which i dont think i have 
13:26:48 * hackagebot applicative-fail 1.0.0 - Applicative functor and monad which collects all your fails  http://hackage.haskell.org/package/applicative-fail-1.0.0 (AlekseyUymanov)
13:27:57 <ysr> The more I learn the more I understand that there are even more things to learn about :D
13:29:26 <iankronquist> Question, what does the thick arrow mean in: round :: Integral b => a -> b?
13:29:39 <rcyr> ysr: Yup.. which is usually why incompetent people think they know it all.
13:30:23 <rcyr> iankronquist: At the left of it are typeclass constraints
13:30:24 <kadoban> iankronquist: It means Integral b is a 'constraint', meaning that b is an instance of the Integral typeclass.
13:31:37 <iankronquist> Ah, so correct me if I'm wrong, but it's saying this is a function which takes and a and returns a b, and b must be an Integral.
13:31:39 <kadoban> iankronquist: So that function would be "Give me any 'a', and I'll give you any 'b' that is an Integral" (Except there's probably more constraints on that, because that type doesn't necessarily make a ton of sense)
13:32:41 <iankronquist> How do I specify that a must be an Integral? is that Integral a => Integral b => a -> b>
13:32:44 <iankronquist> ?
13:33:04 <kadoban> (Integral a, Integral b) => a -> b
13:33:14 <iankronquist> thanks!
13:34:03 <iankronquist> Can I write (Integral b, Integral a) => a -> b
13:35:17 <kadoban> Yeah, it doesn't matter
13:35:24 <iankronquist> cool
13:36:48 * hackagebot csound-expression-dynamic 0.1.4.3 - dynamic core for csound-expression library  http://hackage.haskell.org/package/csound-expression-dynamic-0.1.4.3 (AntonKholomiov)
13:39:14 <derekv> having a bit of difficulty with something trivial: http://lpaste.net/131910 how can I bind "poissonSequenceInSecs g" to a name like "delays", so I can just say mapM_ callThenSleep delays
13:40:01 <kadoban> derekv: let delays = poisblahblah g     -- on the line above
13:40:07 <JagaJaga> No way to write `IO $ MyType String` instead of `IO (MyType String)`?
13:40:46 <kadoban> JagaJaga: Nope, although you could make an alias for MyType String that's easier to use.
13:40:58 <JagaJaga> kadoban: thank you.
13:41:48 * hackagebot csound-expression-typed 0.0.7.5 - typed core for the library csound-expression  http://hackage.haskell.org/package/csound-expression-typed-0.0.7.5 (AntonKholomiov)
13:41:50 * hackagebot csound-expression 4.7.1 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-4.7.1 (AntonKholomiov)
13:41:52 * hackagebot csound-sampler 0.0.6.1 - A musical sampler based on Csound  http://hackage.haskell.org/package/csound-sampler-0.0.6.1 (AntonKholomiov)
13:42:58 <derekv> kadoban: thanks
13:51:49 * hackagebot vty 5.2.9 - A simple terminal UI library  http://hackage.haskell.org/package/vty-5.2.9 (CoreyOConnor)
13:51:51 * hackagebot list-t-text 0.2.0.2 - A streaming text codec  http://hackage.haskell.org/package/list-t-text-0.2.0.2 (NikitaVolkov)
13:54:28 <codygman> What's the easiest way to convert sqlite timestamps to UTCTime in Haskell? What library should I look in? time? unix-time?
13:57:34 <hpc> codygman: http://stackoverflow.com/questions/3693076/unix-timestamp-in-sqlite
14:01:36 <iankronquist> What is the difference between a [Char] and a String? I thought they were the same.
14:01:58 <Iceland_jack> They are the same
14:02:29 <Iceland_jack> String is a type /synonym/ for [Char]
14:02:29 <Iceland_jack>     type String = [Char]
14:02:29 <Iceland_jack> They represent the same type and can be used interchangeably
14:02:47 <iankronquist> show returns a string right?
14:02:53 <hodapp> :t show
14:02:54 <lambdabot> Show a => a -> String
14:03:18 <iankronquist> why doesn't this work? main = putStrLn show(isOdd 3)
14:03:36 <iankronquist> lambdabot: main = putStrLn show(isOdd 3)
14:03:47 <ion> That is parsed as (putStrLn show) (isOdd 3)
14:03:57 <iankronquist> Ah I need some .s
14:04:03 <ion> Try putStrLn (show (isOdd 3))
14:04:05 <Iceland_jack> iankronquist: You probably want
14:04:05 <Iceland_jack>     main = putStrLn (show (isOdd 3))
14:04:11 <Iceland_jack> which is the same as
14:04:11 <Iceland_jack>     main = print (isOdd 3)
14:04:13 <ion> Or print (isOdd 3)
14:04:18 <Iceland_jack> @src print
14:04:18 <lambdabot> print x = putStrLn (show x)
14:04:24 <iankronquist> thanks!
14:04:31 <hodapp> > putStrLn $ show (isOdd 3)
14:04:32 <lambdabot>  Not in scope: ‘isOdd’
14:04:44 <hodapp> that works too but you may not be familiar with $
14:06:25 <iankronquist> $ does right association while . does left right? I'm probably not saying that quite right.
14:07:11 <ion> ($) and (.) are different functions.
14:07:45 <Iceland_jack> iankronquist: Here are the definitions of (.) and ($) respectively
14:07:45 <Iceland_jack>     (f . g) x = f (g x)
14:07:45 <Iceland_jack>     f $ x     = f x
14:09:09 <Iceland_jack> iankronquist: This is a common source of confusion, there are many threads/answers if you search for "Haskell difference dollar composition"
14:09:10 <Iceland_jack> @google Haskell difference dollar composition
14:09:11 <lambdabot> http://stackoverflow.com/questions/940382/haskell-difference-between-dot-and-dollar-sign
14:09:11 <lambdabot> Title: syntax - Haskell: difference between . (dot) and $ (dollar sign) - Stack Over...
14:10:42 <nak> how does the word "Integral" relate to the word "Integer" ?
14:10:50 <nak> :t (/)
14:10:52 <lambdabot> Fractional a => a -> a -> a
14:10:53 <nak> :t div
14:10:54 <lambdabot> Integral a => a -> a -> a
14:11:02 <nak> what is Integral there?
14:11:04 <Iceland_jack> nak: Integer is an Integral, so is Int 
14:11:06 <nak> compared to Number of Integer
14:11:10 <nak> oh
14:11:15 <Iceland_jack> :t div :: Integer -> Integer -> Integer
14:11:16 <lambdabot> Integer -> Integer -> Integer
14:11:17 <kadoban> nak: Well, for one Integer is a type, Integral is a typeclass.
14:11:19 <Iceland_jack> :t div :: Int -> Int -> Int
14:11:20 <lambdabot> Int -> Int -> Int
14:11:31 <Iceland_jack> :t div :: Word32 -> Word32 -> Word32
14:11:32 <lambdabot> Word32 -> Word32 -> Word32
14:11:33 <Iceland_jack> And so forth
14:12:00 <nak> isn't "Integral" like a calc function
14:12:09 <Iceland_jack> No that's a separate use of that word
14:12:11 <kadoban> nak: Integral is pretty much numbers supporting integer division (as opposed to real division)
14:12:12 <hodapp> it is also that
14:12:15 <hodapp> it does not mean that here
14:12:21 <nak> ok
14:12:23 <kadoban> nak: It's also an adjective that means pretty much what the haskell usage is
14:12:25 <hodapp> just as 'derivative' doesn't always mean the result of differentiating a function
14:12:29 <Iceland_jack> nak: You can casually think of Integral as a set of “Integral types”
14:12:30 <Iceland_jack>     Integral = { Int, Integer, Word, Int8, Int16, Int32, Int64, Word8, Word16, ... }
14:12:50 <hpc> nak: integral meaning "like integer"
14:13:22 <nak> let x != y = x /= y in 1 != 2
14:13:25 <nak> > let x != y = x /= y in 1 != 2
14:13:27 <lambdabot>  True
14:13:30 <nak> cool
14:13:57 <Iceland_jack> nak: If you want to see which types are Integral, type this into GHCi
14:13:57 <Iceland_jack>     ghci> :info Integral
14:14:03 <Iceland_jack> (or :i Integral)
14:14:15 <hodapp> ooh, I didn't realize :i gave information like that
14:14:17 <nak> oooo
14:14:23 <nak> Iceland_jack very very cool
14:14:25 <hodapp> how far will it go in telling you instances of a typeclass?
14:14:41 <kadoban> I think it only tells you about ones that are in scope at the time
14:14:42 <Iceland_jack> It will report the instance declarations
14:14:48 <kadoban> But otherwise it's pretty full.
14:15:04 <nak> > let x ≠ y = x /= y in 1 ≠ 2
14:15:05 <lambdabot>  True
14:15:10 <nak> are you serious
14:15:12 <nak> LOL
14:15:27 <nak> damn haskell is so cool
14:16:12 <Iceland_jack> > let { o = "o"; a ∪ b = text (a ++ " ∪ " ++ b) } in o ∪ o
14:16:14 <lambdabot>  o ∪ o
14:16:17 <nak> > let x ≠ y = x /= y in filter (≠2) [1,2,3,4,3,2,1]
14:16:19 <lambdabot>  [1,3,4,3,1]
14:17:22 <nak> Iceland_jack is that a "union" operator ?
14:17:42 <Iceland_jack> Yes
14:17:56 <Iceland_jack> With a slightly non-standard definition
14:18:00 <nak> Iceland_jack is there a reason you needed to specify text ?
14:18:14 <Iceland_jack> nak: Try it without!
14:18:35 <nak> > let { o = "o"; a ∪ b =  (a ++ " ∪ " ++ b) } in o ∪ o
14:18:36 <lambdabot>  "o \8746 o"
14:18:40 <nak> !
14:18:47 <Iceland_jack> > text ":þ"
14:18:48 <lambdabot>  :þ
14:19:05 <nak> > "hello"
14:19:07 <lambdabot>  "hello"
14:19:11 <nak> > text "hello"
14:19:13 <lambdabot>  hello
14:19:15 <nak> hmm ok
14:19:18 <nak> so it like unquotes things ?
14:19:25 <nak> > text "\8746"
14:19:26 <lambdabot>  ∪
14:19:29 <kadoban> :t text
14:19:30 <lambdabot> String -> Doc
14:19:40 <mniip> Doc has a quote-less show instance
14:19:50 <mniip> that's pretty much all it does
14:19:55 <kadoban> Is Doc a lambdabot thing I guess?
14:19:56 <nak> oh
14:20:00 <nak> yeah it's not in ghci
14:20:11 <nak> or it might need to be included manually
14:20:39 <Iceland_jack> I think it uses this library https://hackage.haskell.org/package/pretty-1.1.1.2/docs/Text-PrettyPrint-HughesPJ.html
14:20:47 <kadoban> It sounds vaguely like one of the pretty-printing library types, but I dunno. Might just be a lambdabot convenience thing.
14:20:50 <kadoban> Ah, cool
14:21:06 <Iceland_jack> So it's not anything unique to GHCi or lambdabot 
14:21:20 <nak> > let λx = \x in (λx = x + 5) 3 
14:21:22 <lambdabot>  <hint>:1:13: parse error on input ‘in’
14:21:26 <nak> AWW
14:21:32 <mniip> \ is not an operator
14:21:37 <mniip> it's a syntactic construct
14:21:49 <nak> bummer
14:21:59 <nak> that ≠ is still really cool tho
14:22:18 <Iceland_jack> nak: I often use λ as a function for representing higher-order synnta
14:22:39 <nak> Iceland_jack example ?
14:23:31 <kazagistar> > let a 👀 b = a + b * a in 2 👀 3
14:23:33 <lambdabot>  8
14:23:49 <kazagistar> emoji ftw
14:23:56 <Iceland_jack> Sure, you can represent lambda abstractions and application as such
14:23:56 <Iceland_jack>     data Exp = Var Name | App Exp Exp | Lam (Exp -> Exp)
14:24:10 <bitrauser> Got 2 short questions on a function I wrote, which cuts a number into a list of its digits: http://lpaste.net/131912 . I assumed that using : and reverse afterwards is faster, is this correct? Secondly I am wondering how I properly reverse the List in the cons version.
14:24:12 <Iceland_jack> and then you can simply write
14:24:12 <Iceland_jack>     λ   = Lam
14:24:12 <Iceland_jack>     (·) = App
14:24:23 <Iceland_jack>     λ (\x -> x · x)
14:26:13 <nak> Iceland_jack so that
14:26:29 <nak> so that's like saying ((\x -> x) x)
14:28:15 <kazagistar> bitrauser: its probably faster to not use reverse at all, and just accumulate by prepending to the list
14:29:07 <JagaJaga> I want to return from my function Either String [String] or Either String MyType. How to do it? I need TypeFamilies or RankNPolymorphism?
14:29:27 <mniip> Either String (Either [String] MyType)
14:30:08 <kazagistar> bitrauser: see "unfoldr"
14:30:27 <Iceland_jack> nak: no
14:30:44 <Iceland_jack> nak: It's the same as writing
14:30:44 <Iceland_jack>     Lam (\x -> App x x)
14:30:47 <schell> does anyone have strong recommendations for an xml parser?
14:31:10 <JagaJaga> mniip: emm.. So I will need to do smth like `Right $ Left [string]` or `Right $ Right foo`?
14:31:12 <nak> Iceland_jack thanks :)
14:31:26 <bitrauser> kazagistar: unfoldr in the context of properly getting the list in the right order?
14:31:35 <mniip> JagaJaga, create your own type
14:31:56 <mniip> data Foo = String String | StringList [String] | SomethingElse MyType
14:32:37 <mniip> why would you think you need typefamilies or rankntypes?
14:33:42 <JagaJaga> mniip: that's why I was asking because I don't know. But the way of creating such my own type looks wierd
14:34:24 <mniip> nothing wrong with creating your own datatypes
14:34:41 <mniip> in fact, 3-way either calls for one, and so does a 3-tuple
14:34:58 <kazagistar> bitrauser: try implementing your function using unfoldr instead of recursion
14:36:06 <bitrauser> kazagistar: ok gonna try that, thanks for the tip
14:36:10 <JagaJaga> mniip: ok, thank you.
14:37:24 <wyager> Can I write a function that is parametrized over the various types of Data.Vector (e.g. Boxed, Unboxed, Mutable)? Is there a typeclass for all Data.Vector types?
14:37:49 <bitrauser> kazagistar: But basically, these other approaches are faster than using (++) like in my first version?
14:41:20 <kazagistar> bitrauser: yes
14:42:51 <bitrauser> kazagista: Ok, back to practicing then, thank you.
14:43:30 <SrPx> Is this the best way to do what I'm doing? http://lpaste.net/131913
14:43:58 <SrPx> i.e., a wrapper around Vector/Uvector using V2/V3/lists as indices instead of ints
14:46:15 <creichert> schell: if you're comfortable with Arrow notation then HXT, if you're comfortable with Applicative/Monad interface go with xml-conduit. If neither, I would personally suggest xml-conduit
14:46:36 <schell> creichert: what about if both? ;)
14:47:15 <schell> creichert: thanks :) i’ll look at both!
14:47:18 <nak> how common is the usage of guards in Haskell ?
14:47:26 <nak> do people seem to reach for those often ?
14:48:22 <schell> nak: i seem to pretty often - at least a couple times in each project
14:48:26 <creichert> schell: yea, I use xml-conduit but always looking for a way to reduce dependencies :)
14:48:45 <wyager> nak: I use guards a lot. It's useful for when you can't pattern match
14:48:59 <wyager> For example, you can't pattern match on if the length of a list is even
14:49:23 <wyager> Pattern matching is beautiful for matching on constructor structure, but it doesn't work for matching on other things
14:49:40 <nak> wyager gotcha
14:56:15 <Big_G> Would you all say that you're happier in your day job knowing Haskell (assuming you don't get to use it)?
14:57:13 <schell> Big_G: that’s a double edged sword there
14:57:47 <Big_G> schell, Exactly. I was reading an article about it the other day and wanted to get your opinions
14:58:17 <kazagistar> Big_G: totally, it gives me a nice perspective on a lot of problems
14:58:19 <schell> i’m happier because i write better code that’s less buggy, but i also know how much better the experience is writing haskell - so going back to objc-and js is hard for me sometimes
14:58:43 <nolrai66> I have to go back to c.
14:59:11 <nolrai66> If I am lucky I get to use c++. (Which people here will say is worse then c. They are wrong.)
14:59:17 <schell> nolrai66: i actually like c and objc, but usually in tandem with haskell
14:59:23 <schell> lol
14:59:30 <Big_G> nolrai66, That's what I'm talking about. Haskell is so beuatiful but you have to write your own list in C
15:00:23 <schell> Big_G: i’ll never regret the time i invested in learning haskell - i think that’s the best way to put it
15:00:59 <Big_G> schell, Not nescesarially regret. Just be annoyed when a single fmap saves you 20 lines at least in a language like Java or C
15:00:59 <nolrai66> Exactly, I spend all of yesterday writing something to just handle some runtime sized lists of strings without leaking memomory.
15:01:00 <kazagistar> is it better to be ignorantly happy? red pill or blue pill?
15:01:19 <Big_G> kazagistar, I think we already chose by being in this channel
15:02:01 <Big_G> nolrai66, Never touching C again 
15:02:12 <schell> the trick is convincing other engineers and the exects that haskell is the way to go
15:02:16 <kazagistar> I dunno, I might just sell you all out to the corporate drones if they promise me that they will wipe my memories
15:02:20 <kazagistar> :P
15:02:32 <schell> execs*
15:02:42 <schell> lol
15:02:45 <Big_G> kazagistar, I'd likely do the same for a fat check
15:02:57 <kazagistar> same thing... thats what we all do, right?
15:03:28 <Big_G> I think we'd all end up back at Haskell though
15:03:46 <nolrai66> And I do write better C knowing Haskell.
15:03:53 <nolrai66> (Usually.)
15:05:58 <Big_G> nolrai66, I'm sure it does. I think it'd be too frustrating for me. Java is already doing that to me now
15:15:12 <osa1> any ideas how to show asnychronously incoming messages on haskeline shell while it's expecting a user input?
15:19:53 <xplat> kazagistar: i think i saw a movie like that
15:20:45 <jle`> indiagreen: you can emulate functional languages in imperative languages and a functional approach...you can emulate programming in Assembly in C, too.  you can do 'functional' maps and stuff in imperative languages, but you rely on your own discipline in order to make sure what you really write is what you mean/intend to say
15:21:20 <jle`> indiagreen: but there's a disconnect between what you write, and what you mean
15:43:29 * f|`-`|f scrolls last 500 lines of chat: Who is this person you speak of?
15:47:47 <indiagreen> jle`: yes, I can emulate anything in anything, but what I'm saying is that since a lot of code I write in Haskell ends up looking as if it was written in Python without variables, and a lot of code I wrote in Pascal was looking as if it was written in Haskell with weird syntax, I really can't say that the distinction is as drastic as “you specify how to make food vs you describe the food”
15:50:23 <indiagreen> the most visible differences are due to Haskell being more high-level, not due to it being functional
15:51:07 <indiagreen> it's as if I was writing a recipe for a smarter chef who doesn't have to be told “put this on a pan” when I want something to be fried
15:52:49 <indiagreen> but I feel that the “you just describe the food” comparison describes Prolog or an SMT solver, but not Haskell
15:53:43 * indiagreen goes to sleep
16:21:53 <Mishac> Hi Guys, i am getting this error, is there any chance some can point out how to fix it, Here is the link to PasteBin.
16:21:55 <Mishac> http://pastebin.com/4b45Er6j
16:22:05 <Mishac> the error message is there as well
16:23:54 <Hijiri> Mishac: you have two instances to Show
16:24:02 <Hijiri> either delete the derivation, or the explicit instance
16:24:15 <Mishac> can you elaborate on how to implement the latter?
16:24:40 <Hijiri> use your editor to delete the lines the instance is on
16:25:05 <Mishac> it will fix it, but i am trying to implement a show instance for a stream which will print only first element
16:25:16 <Hijiri> first delete the derived instance
16:25:24 <Mishac> ok
16:25:30 <Mishac> and what should i do next/
16:25:31 <Mishac> ?
16:25:33 <Hijiri> do you understand pattern matching
16:25:40 <Mishac> yes
16:25:53 <Hijiri> in your explicit Show instance, match on the Stream
16:25:55 <Hijiri> and print the head out
16:26:03 <Mishac> I see,
16:26:33 <Mishac> Does it mean that the instance is simply:  show ( Cons a _ ) = show a
16:26:40 <Hijiri> yes
16:26:44 <Mishac> and no need to include show in the deriving?
16:27:42 <Mishac> it works
16:27:45 <Mishac> than kyou good sir
16:28:06 <Mishac> it prints the numbers i want
16:28:30 <Mishac> but what i am not sure is, how does it automatically recognizes the show instances, if I did not declare it?
16:31:43 <verement> Mishac: "deriving Show" means you want the compiler to create a Show instance for you automatically; "instance Show …" means you are going to define the instance yourself
16:32:37 <Mishac> so in other words, when you write deriving (Show), means that compiler automatically writes function show for your datatype
16:32:46 <verement> yes
16:32:57 <Mishac> Thank you!
16:33:04 <Mishac> it make sense now. I feel so happy
16:33:15 <Mishac> #learn something new every day
16:33:23 <verement> :-)
16:38:58 <derekv> part of my brain yells "dammit, why do I have to say mapM, why can't I just say map, it should know what I mean... i should, overload it or something, and just work"... then I go read over the difference, and I learn stuff
16:40:14 <verement> map and mapM are very different, aren't they? not like map and fmap
16:40:21 <hpc> very different
16:40:27 <derekv> because your creating a sequence of actions based on a list, not a new list ... that and I think, its how the unicorns in the compiler like it
16:41:03 <hpc> this is a large part of what people mean when they say haskell makes you a better programmer, by the way
16:41:11 <verement> indeed
16:41:14 <hpc> being able to finally have the tools to figure out "why isn't this possible"
16:41:17 <derekv> yessir
16:41:46 <derekv> or  preffered title if not sir
16:45:45 <derekv> maybe it shouldn't have been called map-anything
16:47:52 <exio4> map can be implemented with mapM + Identity, though
16:51:49 <derekv> in other news, I can't type numbers in ghci
16:52:06 <derekv> thought my keyboard was broken for a minute
17:10:32 * hodapp ponders contributing to some compiler other than GHC for the sake of making better competition...
17:13:32 <adamse> hodapp: if you're interested in dependently typed programming the idris compiler source is still very approachable
17:13:53 <hodapp> adamse: oh, I am just curious about other Haskell compilers
17:14:02 <hodapp> adamse: I already want to look at the Idris source
17:14:45 <hodapp> just read the paper about Ajhc and what they did to make the runtime suitable for targeting embedded systems
17:14:56 <jle`> indiagreen: fair points :)
17:46:45 <f|`-`|f> I'm under the impression that vinyl is GADT for kinds
17:48:10 <f-a> I have a bunch of [IO ()] actions which I now 'execute' using mapM_. Is there a way to have them executed in parallel?
17:51:18 <joneshf-laptop> verement, no, i'd not saythat
17:51:57 <joneshf-laptop> verement, `map` is a specialized version of `mapM`
17:52:25 <joneshf-laptop> well, basically
17:52:37 <joneshf-laptop> :t map
17:52:38 <lambdabot> (a -> b) -> [a] -> [b]
17:52:39 <joneshf-laptop> :t mapM
17:52:40 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
17:52:49 <mniip> not at all
17:52:53 <Cale> f-a: You could apply forkIO to them all to have them run in concurrent threads
17:53:04 <f-a> Cale: thanks I will hoogle forkIO
17:53:08 <chexxor> I can not figure out how to build a haskell project I git cloned - can I get some cabal help here?
17:53:09 <joneshf-laptop> so the `Traversable` is `[]`, and the `Monad` is `Identity`
17:53:38 <joneshf-laptop> just you dont' have to worry about unwrapping  `Identity`
17:54:03 <chexxor> in the project's root directory, I did `cabal sandbox init` then `cabal install`, but I get "cabal: Could not resolve dependencies: .... next goal: optparse-applicative"
17:54:14 <chexxor> where should I be looking to solve this?
17:54:39 <kadoban> chexxor: Paste the full output to lpaste.net and copy the link to here
17:56:53 <chexxor> http://lpaste.net/131918
18:02:13 <kadoban> Hmm, I dunno. You could try purescript itself from hackage I guess, not sure what would be different though. Can you install optparse-applicative on its own?
18:03:06 <hiptobecubic> yes at least with hackage you can typically assume that the dependencies have been released
18:03:22 <hiptobecubic> if you are building from source, they might be depending on other things that have to be built from source
18:03:30 <hiptobecubic> well... building from git
18:03:37 <chexxor> no, cabal tells me to cabal update. But `cabal update` does nothing
18:03:44 <chexxor> I'm using cabal-install package from nix
18:03:47 <chexxor> so perhaps that's related
18:05:32 <joneshf-laptop> chexxor, you might get better help in #purescritp
18:06:57 <kadoban> 'cabal update' doesn't output anything usually, IIRC, but it does do stuff.
18:08:17 <farzin> Hello, I have a question about the Haskell website itself,
18:08:32 <farzin> is this an appropriate room to ask such a question
18:08:59 <geekosaur> #haskell-infrastructure might be better, depending on the question
18:09:14 <farzin> so here’s my question
18:10:28 <farzin> if you go to https://www.haskell.org/downloads/osx
18:10:48 <farzin> you’ll notice that the first line says ‘This download is provided by GHC for OS X for 64-bit Mac OS X 10.9 and later.’. If you click on ‘GHC for OS X’, it’ll lead you version 7.10
18:11:26 <farzin> however, if you return to the initial page, under ‘Steps to install’, it has you download ‘ ghc-7.8.4-r0.zip’ 
18:12:13 * hackagebot shelly 1.6.2 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.6.2 (GregWeber)
18:13:26 <farzin> Why are who different versions being recommended?
18:14:52 <hpc> that sounds more like a documentation mistake
18:15:39 <farzin> Yes.
18:16:40 <_fritz_> hmh, i need a cartesian product in haskell
18:16:41 <farzin> Well, i followed the link, as the link within the page does not work for OS X 10.10
18:17:08 <farzin> the page should be updated for clarity 
18:18:54 <srhb> _fritz_: On which types?
18:19:08 <_fritz_> srhb: [a] -> [a] -> [(a, a)]
18:19:20 <_fritz_> but i found the simplest solution, but it involves generator syntax foo
18:19:45 <srhb> _fritz_: You can always untranslate the list comprehensions, but it will probably get ugly.
18:20:10 <srhb> Might be ok with Applicative.
18:20:14 <mniip> [04:18:47] <_fritz_> but i found the simplest solution, but it involves generator syntax foo
18:20:18 <mniip> (,) <*> x <*> y
18:20:27 <mniip> :t \x y -> (,) <*> x <*> y
18:20:28 <lambdabot>     Couldn't match type ‘(a2, a1)’ with ‘a -> b’
18:20:28 <lambdabot>     Expected type: a2 -> a1 -> a -> b
18:20:28 <lambdabot>       Actual type: a2 -> a1 -> (a2, a1)
18:20:41 <mniip> oops
18:20:43 <mniip> :t \x y -> (,) <$> x <*> y
18:20:44 <lambdabot> Applicative f => f a1 -> f a -> f (a1, a)
18:20:59 <mniip> or actually, liftA2 (,) which is the same
18:21:16 <_fritz_> yes, this is a better solution
18:23:01 <derekv> so this is fun, ghci wouldn't take numbers or some symbols (as if the keyboard was broken), restarted with new terminal... same.  rebooted computer: fixed
18:23:28 <srhb> Doesn't sound ghc related.
18:23:46 <derekv> srhb: super weird though
18:23:50 <srhb> Yeah.
18:24:02 <derekv> quit ghci, numbers work, restart it, they don't
18:25:21 <geekosaur> number pad or top row?
18:25:29 <derekv> geekosaur: top row.
18:25:37 <derekv> geekosaur: also period, and dash
18:26:20 <derekv> must have been something at the OS level, but only effecting ghci
18:35:22 <chexxor> joneshf-laptop, k - thanks!
18:47:14 * hackagebot hopenpgp-tools 0.15 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.15 (ClintAdams)
18:52:14 * hackagebot hOpenPGP 2.1 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-2.1 (ClintAdams)
19:36:27 <f|`-`|f> so no confirms or deny of vinyl being gadt for kinds, ish
19:37:15 * hackagebot checkers 0.4.3 - Check properties on standard classes and data structures.  http://hackage.haskell.org/package/checkers-0.4.3 (ConalElliott)
19:48:55 <dropdrive> cabal install language-python seems to eat up all the memory on my box (4GB); is there any other way to install it?
19:51:34 <kadoban> dropdrive: Try -j1 maybe
19:51:46 <kadoban> (So it doesn't build parts in parallel)
19:57:30 <kadoban> :t . -- is it me or did this used to give a parse error? Was it changed on purpose? What parsing rules does it use now?
19:57:31 <lambdabot> (b -> c) -> (a -> b) -> a -> c
20:00:02 <kadoban> For that ^ it seems clear enough, but … what is this supposed to be doing:
20:00:03 <kadoban> :t map .
20:00:04 <lambdabot> (a -> a1 -> b) -> a -> [a1] -> [b]
20:01:51 <geekosaur> that's parsing as
20:01:53 <geekosaur> :t (map .)
20:01:54 <lambdabot> (a -> a1 -> b) -> a -> [a1] -> [b]
20:02:08 <phy1729> Is there a mod that always returns positive?
20:02:08 <geekosaur> :t $
20:02:10 <lambdabot> (a -> b) -> a -> b
20:02:14 <kadoban> Yeah, I guess, but … did it used to do that? Should it? It seems … confusing
20:02:23 <geekosaur> it used to not do that
20:02:47 <kadoban> Know if it was changed or purpose or if something else make it start "working"?
20:02:52 <geekosaur> I don't know what changed; you'd have to ask the lambdabot maintainer (on hackage; noit the person who runs this particular lambdabot)
20:03:14 <kadoban> Right. I'll look around see if I can find out.
20:03:33 <geekosaur> @hackage lambdabot
20:03:33 <lambdabot> http://hackage.haskell.org/package/lambdabot
20:04:26 <kadoban> phy1729: Isn't that what 'mod' already does?
20:05:37 <phy1729> kadoban: no > -12 `mod` 5
20:05:49 <phy1729> I would like 3 not -2
20:05:50 <geekosaur> a quick test suggests mod returns a negative number if the modulus is negative (e.g. 5 `mod` (-2))
20:05:53 <geekosaur> phy, actually that's a parse issue
20:06:00 <geekosaur> (-12) `mod` 5
20:06:17 <geekosaur> unary minus is weird in Haskell
20:06:18 <phy1729> hrm it's a varible in the code; I'll be back in a few
20:06:36 <kadoban> > mod (-12) 5
20:06:38 <lambdabot>  3
20:06:52 <phy1729> nevermind I was just testing and hadn't changed the code yet
20:07:20 <kadoban> I think the other 'mod' is 'rem', which goes the way you /don't/ want.
20:07:28 <geekosaur> yep
20:18:58 <dhrosa> unary minus is fun to lex/parse in every language :). i guess it's just unique in haskell because I guess every other operator is strictly unary or strictly binary, never a decision to make
20:19:32 <dhrosa> and other languages have fixed... fixity for any given operator
20:21:19 <dhrosa> err, actually I guess it's because it's the only prefix operator haskell has?
20:21:32 <dhrosa> everything else is infix
20:22:37 <kadoban> It's the only unary operator at least, AFAIK. I'm not totally clear why it's such a mess in haskell. Part of it might be that (-1) looks like it should be a section, but isn't. :-/
20:24:23 <dhrosa> kadoban: well, it's ambiguous
20:24:28 <verement> that's why we have `subtract`
20:24:29 <dhrosa> kadoban: it depends on the context
20:24:55 <j201> is it a unary operator or just part of the numeric literal syntax?
20:24:57 <dhrosa> since - is the only prefix operator / unary operator, it's the only thing that makes an expression ambigious
20:25:20 <kadoban> Pretty sure it's defined as actually a unary operator.
20:25:28 <geekosaur> it;s a unary operator
20:25:35 <verement> > let x = 5 in -x
20:25:37 <lambdabot>  -5
20:25:46 <geekosaur> > -12 `mod` 5
20:25:47 <lambdabot>  -2
20:26:03 <dhrosa> theoretically if you implemented a Num instance for (Int -> Int), things could get quite confusing
20:26:04 <geekosaur> that parses as - (12 `mod` 5)
20:26:13 <kadoban> That one is pretty fugly, haha. I wonder if it should just … not be an operator and just be part of numeric literals?
20:26:20 <dhrosa> eh I guess not actually, nvm
20:26:44 <geekosaur> kadoban, but then you lose unary minus for things like `-x`
20:26:50 <dhrosa> kadoban: you could do that, but people like saying things like "-x"
20:27:00 <dhrosa> darn it :p
20:27:35 <kadoban> geekosaur: That's used quite a bit less often than the other way around though, isn't it? So wouldn't it make sense to make that less-comfy, like 'neg x' or something?
20:27:58 <geekosaur> `negate` exists, actually
20:28:08 <geekosaur> but, well, people tend to expect it to work
20:28:30 <kadoban> Well, people tend to expect negative literals to work (better than they do) too.
20:28:31 <geekosaur> beyond that, probably (yet another) discussion on haskell-cafe and possibly haskell-prime lists
20:29:06 <kadoban> Right, not much point discussing it I suppose, seems like one of those things that can't really be changed now even if there was a good consensus on how to change it.
20:29:47 <geekosaur> also I would not be surprised if there is historical discussion on the old haskell standards lists (I think they're linked somewhere on the wiki)
20:30:05 <kadoban> That might be fun to look up
20:30:15 <geekosaur> (to the extent that they still exist; someone found archives going back a ways but history before I think 1.2 is spotty)
20:30:22 <geekosaur> maybe 1.4
20:31:27 <dhrosa> why is flycheck-haskell one of the top downloaded emacs packages on melpa o.o, it's like 23rd most popular on a list of 2400 packages
20:31:39 <dhrosa> I guess the actual question is, are a large amount of haskellers emacsers?
20:32:05 <MP2E> I don't know, but I use emacs
20:32:15 <MP2E> there's a fair amount of haskellers that use other editors too
20:32:20 <MP2E> but I'd bet emacs is up there.
20:32:30 <MP2E> amongst the most used
20:32:33 <MP2E> probably with vim
20:32:52 <geekosaur> not unlikely, emacs + haskell-mode is the most robust and best supported "development environment". vim's haskell support started much later and is still catching up, while haskell-mode is still evolving
20:34:14 <gwaszczuk> Since lately I just do small tidbits of haskell development (for some courses at uni) I find it sufficient to use Gedit/Geany + GHCi
20:34:38 <gwaszczuk> For some quick toy scripts I want to make (for example testing some external library) I use FPComplete
20:35:18 <gwaszczuk> FPComplete is pretty cool in that respect
20:37:57 <kadoban> FPcomplete is pretty neat, but … I don't like getting reliant on an IDE. Then when I want to use another language, I'm lost. A good text editor can be used with every language, and plugins can give you all the functionality you want, pretty much.
20:38:34 <kadoban> I'd pick vim or emacs, or try both, and see which you like. Learn them well and they'll last you forever.
20:39:27 <dhrosa> or spacemacs, the unholy lovechild of them :)
20:39:55 <gwaszczuk> Yes, FPComplete is cool when you: Don't want problems with packages; don't want the additional challenge of learning emacs/vim (assuming you don't use them already, since if you already do it's very likely you'll pick that one from the beginning); have no (easy) access to your workstation
20:40:56 <dhrosa> but really i wasn't trying to spark an editor war, was just curious why the combo was so popular
20:40:58 <gwaszczuk> When you want to create a quick script, it's easier to use FPComplete (or even other cloud IDEs, like Coding Grounds) than having to startup your whole workstation
20:41:10 <MP2E> funnily enough, I had a very customized emacs config that set all the keybindings to vim style, and I recently scrapped it all and switched to spacemacs
20:41:22 <MP2E> I can unreservedly say that spacemacs is much better than what I was using before
20:41:39 <MP2E> it's pretty great :P
20:42:16 <MP2E> and spacemacs can keep emacs keybindings too so i think it's a good recommendation for haskellers
20:42:36 <kadoban> I think editor holywars have gone the way of the dodo, thankfully, heh. They don't tend to get too flamey anymore. People probably found better things to argue about, like Apple vs. Google.
20:43:03 <MP2E> yeah I think so too. I love both Vim and Emacs :D
20:43:04 <dhrosa> Yahoo!
20:43:07 <MP2E> couldn't settle for one so I chose both
20:43:09 <f|`-`|f> One of them shows for what they do
20:43:19 <f|`-`|f> Yahoo's great at destroying accquistions
20:43:26 <dhrosa> Altavista!
20:43:39 <f|`-`|f> also, it lost its best purpose
20:43:43 <f|`-`|f> searching for porn
20:44:09 <kadoban> Google used to be cooler before they went mainstream. When it was just for geeks, it was /so/ much more precise.
20:44:30 <dhrosa> you mean fuzzy matching and personalization?
20:45:29 <kadoban> Yeah, the matching has gotten pretty fuzzy, and all of the advanced search stuff seems to … barely work anymore. Which is probably better for most people, but for coding stuff it's a net loss.
20:45:54 <f|`-`|f> also bubble filtering
20:46:11 <small-wolf> I don't know if we're still talking about emacs, but cua-mode is pretty cool
20:46:17 <f|`-`|f> the implicit nonsense personalisation
20:47:17 * hackagebot list-t-attoparsec 0.3.1.1 - An "attoparsec" adapter for "list-t"  http://hackage.haskell.org/package/list-t-attoparsec-0.3.1.1 (NikitaVolkov)
20:47:39 <gwaszczuk> I never understood the Emacs vs vim war, when you can have both with stuff like Spacemacs or Evil mode and the like
20:48:14 <dhrosa> i mean, just because you can have both, doesn't mean people will use both, still will be wars over it
20:48:28 <small-wolf> Is there really a war? I use both
20:48:36 <dhrosa> heretic!
20:48:46 <small-wolf> also yi is pretty cool
20:49:14 <small-wolf> but it's vim / emacs emulation leaves a bit to be desired (I can't horizontal split)
20:49:23 <kadoban> I think the war was in like … the 90s. Probably while waiting for porn to download over 200 baud modems or something.
20:50:06 <gwaszczuk> I guess now the war wouldn't be emacs vs vim, but emacs vs vim vs Visual Studio Code instead!
20:50:32 <dhrosa> more like Sublime vs bearded editors
20:50:34 <pacak>  atom based visual studio?
20:50:35 <small-wolf> it seems like now it's emacs/vim vs sublime text and clones
20:50:43 <pacak> Which can't open files larger than 2Mb?
20:50:53 <geekosaur> the modern wart seems to be intellij vs. eclipse vs. sublime text etc.
20:51:12 <geekosaur> hm, "wart" = Freudian typo...
20:51:15 <kadoban> eclipse … so bad. Hated that thing even back when I used to code java mostly.
20:51:48 <small-wolf> I kinda like intellij. It's some cool type inferencey stuff that's more advanced than java's type system (it warns me when I haven't checked for nulls, for instance)
20:52:18 * hackagebot list-t-attoparsec 0.4.0.0 - An "attoparsec" adapter for "list-t"  http://hackage.haskell.org/package/list-t-attoparsec-0.4.0.0 (NikitaVolkov)
20:52:27 <small-wolf> It's got*
20:52:45 <geekosaur> pacak, to be honest, if you have a source file > 2MB, you have bigger problems
20:53:02 <dhrosa> geekosaur: java's REALLY verbose sometimes
20:53:05 <dhrosa> geekosaur: :p
20:53:21 <dhrosa> actually I think sqlite has its source available in a single file as an option
20:53:36 <dhrosa> this broke an old version of visual studio that stored line numbers in a 16-bit int iirc
20:54:44 <geekosaur> dhrosa, in that case i'd aergue your bigger problem is Java :p
20:55:21 <dhrosa> if you used 80 chars per line you'd need... 25k lines of code to reach that
20:55:27 <pacak> geekosaur: Id' say if text editor can't open files larger than 0.0001% of available RAM - it's not a very good editor.
20:55:52 <pacak> And the biggest text file I had to work recently was about 80Gb...
20:56:05 <nak> lol
20:56:20 <geekosaur> I did say source file
20:56:48 <pacak> geekosaur: Yea, right. So you have one text editor to edit source files and one editor for everything else?
20:56:50 <geekosaur> and while I do see your point, by the time your text files are in the GBs you need a better tool than an editor to deal with them
20:57:20 <dhrosa> at 80GB you could start to physically see that on a hard drive, if you like put ink on each bit
20:57:32 <nak> why can't you break down a 25,000+ line file ?
20:58:14 <geekosaur> I do serious development in emacs and most other things, including quick changes to source, in vi or other editors, if my file to be edited is big enough, I;m going to avoid using any editor because really it needs to be pared down just for *people*, never mind tools
20:58:47 <nak> geekosaur that's my thought
20:58:53 <geekosaur> in my exoperience, 80GB text files are either logs with no rotation or things that belong in databases
20:59:07 <geekosaur> (mind, other people's experiences *will* likely differ there)
20:59:11 <dhrosa> or movies rendered to ASCII art format
20:59:19 <nak> dhrosa there's always that
20:59:26 <nak> ^.^
20:59:30 <pacak> That was a text version dump of some market data feed.
20:59:38 <dhrosa> actually a movie in ASCII art would be orders of magnitude larger than 80GB
20:59:50 <geekosaur> if it's a log, first step is to apply split(1) to it to make sensible chunks. (if it's syslog format or similar then I'll probably use csplit with a split pattern that splits by day as a first cut)
20:59:55 <dhrosa> a movie is like 2GB, and video codecs are definitely way more than a 40:1 compression ratio
21:00:10 <pacak> dhrosa: Depends on the resolution and a frame rate.
21:00:39 <pacak> dhrosa: telnet towel.blinkenlights.nl
21:01:39 <geekosaur> market data feed is definitely something I would load into a database
21:03:09 <geekosaur> unless there's some single pass thing that needs to be done (e.g. "pull out these specific records, totaling these fields, output totals then discard the file"  in which case it's going to be a simple script or etc.)
21:04:31 <pacak> geekosaur: Well, first you need to figure out how to parse that into some more compact representation and my goal was to look at some packets which starting to appear 2-3 hours into trading day, somewhere around 60Gb mark that is...
21:04:39 <geekosaur> (assuuming the format isn't json or xml at least)
21:05:19 <geekosaur> sure, so I'll copy off the top of the file to load into an editor for inspection
21:06:02 <geekosaur> inb order to determine the source format and what alternative format makes more sense (again, for that probably a database)
21:06:21 <pacak> geekosaur: That's what I did, 80Gb is not a full day. Full binary dump was about 15-20Gb and each compression ratio is somewhere around 1:100...
21:06:32 <geekosaur> (but it does depend on what exactly I need from it)
21:08:54 <geekosaur> this is something I did and reduced to a program for a customer in the late 1980s, involving an almost-SGML format (note this was before XML existed. if you think XML is bad, take a look at its ancestor SGML sometime.)
21:13:36 <phy1729> I have a [String] and want to strPutLn each string. Apparently map is the wrong solution. What is the correct way to do that?
21:13:44 <Iceland_jack> for_ or mapM_
21:14:16 <Iceland_jack> sorry, for_ or traverse since 7.10
21:14:35 <dhrosa> phy1729: map strPutLn strings is type [IO ()], what you want is something of type IO ()
21:14:42 <Iceland_jack> :t F.for_ ["hello", "world"] putStrLn
21:14:44 <lambdabot> IO ()
21:15:20 <geekosaur> map is half the solution, actually, the other half is `sequence_`. the combination of which is mapM_, or in 7.10 the better alternative for_
21:15:44 <Iceland_jack> 'traverse_' flips the argument
21:15:49 <Iceland_jack> :t F.traverse_ putStrLn ["hello", "world"] 
21:15:50 <lambdabot> IO ()
21:16:37 <pacak> :t sequence_ . map putStrLn
21:16:39 <lambdabot> [String] -> IO ()
21:16:44 <pacak> :t sequence_
21:16:45 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
21:17:00 <geekosaur> :t sequence
21:17:01 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
21:17:33 <pacak> You use sequence or sequence_ depending if you care about results or effects only.
21:17:56 <pacak> @src mapM_
21:17:56 <lambdabot> mapM_ f as = sequence_ (map f as)
21:18:03 <pacak> @src mapM
21:18:03 <lambdabot> mapM f as = sequence (map f as)
21:18:42 <pacak> @src for_
21:18:42 <lambdabot> Source not found. Just what do you think you're doing Dave?
21:18:45 <pacak> @src F.for_
21:18:45 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
21:18:55 <pacak> :-P
21:19:02 <geekosaur> the @src database is as lame as usual
21:34:10 <mishaC> Hi guys, a quick question, can someone shed light on what is asked in this question? I am feeling very confused by the wording.
21:34:12 <mishaC> here is the link
21:34:13 <mishaC> http://pastebin.com/AVcDqEJz
21:36:11 <kadoban> mishaC: Look at the numbers [1..]. For each one, what is the largest power of 2 that evenly divides that number? It's asking you for a list of the exponents on 2, with 0 being allowed.
21:36:34 <c_wraith> So at every odd index, the list entry will be 0, for instance.
21:36:51 <mishaC> than you for reply, i am still kinda confused,
21:37:02 <mishaC> largest power of 2, means?
21:37:33 <c_wraith> > iterate (*2) 1
21:37:35 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
21:37:35 <kadoban> the 0th power of 2 is 1, the first power of 2 is 2, the second power of 2 is 4, the 3rd power of 2 is 8.  It's exponentiation
21:37:43 <mishaC> ohh
21:37:48 <mishaC> Thank You
21:38:14 <geekosaur> > [2^n | n <- [0..]]
21:38:16 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
21:39:32 <mishaC> ohh
21:39:34 <mishaC> thank make sense guys
21:39:46 <mishaC> 1 is power of zero
21:39:48 <mishaC> 2 is pwoer of one
21:39:56 <mishaC> 3 is zero because it does power
21:40:00 <mishaC> 4 is power of 2
21:40:05 <mishaC> 5 is 0
21:40:23 <mishaC> got It,  TY very much.
21:40:53 <mishaC> btw how good is haskell for programming with streams?
21:41:00 <mniip> sounds like logarithmic straightedge
21:41:36 <kadoban> Haskell has very nice support for infinite values
21:41:48 <geekosaur> it's also the backup sequence that is often miscalled "tower of hanoi"
21:42:34 <geekosaur> (if you add 1 to every value, since tape numbers are usually 1-based...)
21:42:57 <kadoban> Oh like you (over)write the numbered tape in that sequence?
21:43:09 <mniip> > let z = 0:intersperse 0 (map succ z) in z
21:43:10 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1...
21:43:14 <geekosaur> reuse, yes
21:43:28 <geekosaur> it's used with incremebnntal backups
21:43:33 <kadoban> Interesting
21:43:44 <hemite> In the Lean You A Haskell book, specifically: http://learnyouahaskell.com/making-our-own-types-and-typeclasses
21:43:57 <c_wraith> I recently rediscovered the connection between gray codes and the towers of hanoi.  That was a fun realization.
21:43:58 <hemite> Where he has an example of implementing a binary tree
21:44:23 <hemite> He says creating a BST this way is inefficient, but laziness takes care of the problem, but he doesn't say how
21:44:48 <hemite> How does laziness make that particular tree creation mechanism efficient?
21:44:55 <geekosaur> that's kinda an endemic issue with LYAH
21:45:19 <hemite> Right, so I thought I would ask here for clarification 
21:46:02 <kadoban> hemite: Which part, exactly? That's a big page. (Also, by the way if LYAH is all you're using, follow https://github.com/bitemyapp/learnhaskell instead)
21:46:46 <hemite> kadoban, The BST implementation section specifically, a little over half way down
21:46:54 <hemite> (There is a picture of a BST)
21:47:20 <kadoban> Okay, found the picture. Let me see if I can find the part.
21:47:44 <hemite> The exact sentence (if you want to "Find" on the webpage) is : This might seem like it's inefficient but laziness takes care of that problem
21:48:01 <hemite> If you search for that you can find the paragraph I'm talking about
21:48:27 <hemite> From what I understand, the implementation creates a new BST every time a node is inserted
21:48:36 <geekosaur> "It takes an element and a tree and returns a new tree that has that element inside. This might seem like it's inefficient but laziness takes care of that problem."
21:48:47 <hemite> geekosaur, Yes
21:48:59 <kadoban> Right … yeah. Hmm.
21:49:18 <geekosaur> I think what it's saying is slightly incorrect. the inefficient sounding part is that you are creating a new tree
21:49:28 <kadoban> Does laziness even matter there? Haha. It seems just wrong to me.
21:49:31 <geekosaur> what's actually making it efficient is sharing, not laziness
21:49:32 <hemite> geekosaur, Exactly, every time a node is added
21:49:52 <hemite> geekosaur, what do you mean by sharing?
21:50:36 <geekosaur> ultimately we are producing the old tree at some point plus a new root for it
21:50:42 <kadoban> Yeah, sharing seems like the more important concept there. Every time you add an element, /most/ of the tree is shared with the one it's created from. Asymptotically, only a logarithmic number of the nodes need to change, the rest of the tree is exactly the same and doesn't get modified at all.
21:50:51 <geekosaur> so we don;t actually build a whole new tree, we reuse the existing one
21:51:12 <geekosaur> it is shared between the old and new trees
21:51:36 <geekosaur> (remember, something elsewhere in the code could be holding a reference to the old tree, in a real program)
21:51:38 <hemite> And that's done automagically by the compiler, right?
21:51:42 <geekosaur> yes
21:52:02 <hemite> But from a purely functional perspective, its a new object
21:52:08 <kadoban> hemite: See the parts in the definition of treeInsert, the last two lines? Notice how every time it goes left or right, it completely reuses either the right or the left tree? That's the part that does the sharing.
21:52:24 * hackagebot list-t-attoparsec 0.4.0.1 - An "attoparsec" adapter for "list-t"  http://hackage.haskell.org/package/list-t-attoparsec-0.4.0.1 (NikitaVolkov)
21:52:47 <geekosaur> and the reason the compiler can work out that sharing is possible and safe is purity
21:53:12 <geekosaur> laziness may be taken into account with respect to purity but it's not a core concept, more an implementation detail
21:53:35 <geekosaur> purity, which enables sharing, is the real core
21:54:46 <geekosaur> so this is just an error in the book
21:57:24 * hackagebot stackage-build-plan 0.1.0.0 - Calculate and print (in different formats) Stackage build plans  http://hackage.haskell.org/package/stackage-build-plan-0.1.0.0 (MichaelSnoyman)
21:57:26 * hackagebot conduit 1.2.4.2 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.2.4.2 (MichaelSnoyman)
22:01:11 <blogle_> anyone quite familiar with vty-ui?
22:11:58 <mishaC> Guys, One more question, does anyone know some good resources that one can you to learn more about the principles of stream based programming, especially in Haskell
22:12:11 <mishaC> It is like the coolest thing I have ever seen
22:27:25 * hackagebot stackage 0.7.2.0 - Dummy package forcing installation of other Stackage packages  http://hackage.haskell.org/package/stackage-0.7.2.0 (MichaelSnoyman)
22:50:33 <gfixler> how do I clear the screen with ncurses?
22:50:54 <gfixler> I don't see it in here: http://hackage.haskell.org/package/ncurses-0.2.11/docs/UI-NCurses.html
22:51:10 <gfixler> am I supposed to manually print spaces?
22:53:19 <pavonia> Seems it has an internal function for that that isn't exported
22:53:54 <geekosaur> in an actual curses binding it'd be werase(). this one seems kinda missing stuff
22:56:02 <gfixler> yeah, it hasn't felt too fun to use
22:56:47 <geekosaur> well, curses is never very fun to use. (it is rather appropriately named)
22:57:26 * hackagebot shelly 1.6.2.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.6.2.1 (GregWeber)
22:57:28 <gfixler> I'll have to look at the other options
22:57:33 <gfixler> I *really* wanted control keys
22:57:34 <Hijiri> hscurses has werase
22:57:49 <geekosaur> hscurses lacks a "Haskelly" interface, it's more a direct reflection of the C library. but it is complete
22:58:00 <Hijiri> oh
22:59:12 <gfixler> geekosaur: I'll have to check it out, and also that other one
23:00:37 <geekosaur> so, er, why do you believe hscurses doesn't support control keys?
23:00:59 <Big_G> Is there a good way to use type checking for logical constraints like a value can't be 4?
23:01:23 <gfixler> geekosaur: because I believe in a cruel world
23:01:25 <gfixler> geekosaur: does it?
23:02:19 <geekosaur> http://hackage.haskell.org/package/hscurses-1.4.2.0/docs/UI-HSCurses-Curses.html#g:13 is (again) even more complete than UI.Ncurses
23:02:45 <kadoban> Big_G: To really do that requires something called dependent types, IIUC. Which isn't really quite possible in haskell, except maybe to some extent with extensions that I don't personally know a lot about.
23:03:50 <Big_G> kadoban, I keep hearing about dependent types but never a good explanation of what they are. Is there any particular reason they're not in Haskell?
23:03:56 <kadoban> Big_G: You can kinda fake it a bit though, like make a Not4 type wrapper on Integer, and don't expose any of the direct constructors for it, only expose one that checks if it's 4 or not.
23:04:00 <MP2E> Dependent Haskell is coming soon :) https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell
23:04:02 <geekosaur> dependent typing is when types depend on values
23:04:08 <kadoban> Big_G: AFAIU, dependent types is … yeah that ^
23:04:13 <geekosaur> as, in this case, a type where the value cannot be 4
23:04:33 <gfixler> I've heard that one of the issues with dependent types is the halting problem
23:04:44 <gfixler> because now you're types have code in them, so your types can have bugs, bottoms, etc
23:04:50 <geekosaur> and they're not in Haskell because they are very difficult and many of the useful things in Haskell's type system stop working when dependent types are brought into the mix
23:05:21 <geekosaur> recent extensions to the type system enable some limited dependent typing; they are somewhat difficult to use but they don't kill off things like type inference
23:05:37 <Big_G> Would it be best for me to avoid them and code the logic into my code and not types then?
23:05:43 <geekosaur> generally yes
23:05:48 <MP2E> I'm not sure if Dependent Haskell will solve the type inference issues either, from the looks of it it will only infer types if they aren't dependent
23:06:03 <MP2E> Which kind of sucks but it's understandable.
23:06:04 <geekosaur> alternately some people write their dependent code in Agda and have that generate Haskell code
23:06:04 <gfixler> Big_G: a common workaround is to not export the type constructor(s), but a constructor function instead
23:06:25 <gfixler> Big_G: your constructor function can just not allow 4
23:06:29 <geekosaur> the Haskell code won't have it in the type system but Agda won't typecheck the program unless it can prove that the constraint holds
23:07:03 <gfixler> TIL Haskell == Agda + dependent type erasure
23:07:13 <geekosaur> on the flip side, getting your program to the point where Agda can prove it's safe is likely to be painful, because your types all have to include proofs that the value will never be 4
23:07:56 <gfixler> your succ function isn't allow to work on 3, just like how hotels don't have a floor 13
23:08:12 <Hijiri> at least for proving it's not 4, liquid haskell might be nice
23:08:19 <Big_G> gfixler, Would that be a compile time or runtime error?
23:08:24 <MP2E> yeah refinement types look like a nice middle-ground
23:08:40 <geekosaur> smart constructors are runtime
23:08:49 <gfixler> Big_G: I'm not even sure how you'd write it
23:08:56 <geekosaur> but doing it at compile time is a really hard row to hoe
23:08:58 <Big_G> geekosaur, Anyway to check before running?
23:09:27 <geekosaur> like I said earlier, it amounts to everything involving that type having to include a proof that it will never happen
23:09:41 <gfixler> 2 + 2 == undefined, 3 + 1 == undefined, etc
23:09:52 <geekosaur> it's just not something that can be done trivially at compile time
23:09:55 <kadoban> Big_G: Not really. You can make the smart constructor something like    Integer -> Maybe Not4, to encode the possible failure in the type of course.
23:10:05 <gfixler> kadoban: that's true
23:10:24 <gfixler> kadoban: of course then you're always working with Maybe values
23:10:39 <kadoban> Right.
23:11:05 <kadoban> Better than checking for 4 all the time though :)
23:11:10 <Big_G> So, I'm taking away that I should just suck it up and have my logic be outside the type
23:11:12 <gfixler> it might be easier to first create a number system that doesn't have 4
23:11:19 <geekosaur> yes
23:11:26 <kadoban> Big_G: Probably, yeah.
23:12:06 <Big_G> Thanks all for the responses
23:12:16 <kadoban> Although if you really like the idea of dependent types, you can certainly go in that direction … just know that it won't come for free probably.
23:12:38 <geekosaur> certainly, not probably
23:13:16 <Big_G> I really like the idea but I'm scared of what might happen. In my mind, this is the same as having constraints coded into a database
23:20:25 <crocket> hi
23:20:32 <crocket> Is haskell good for desktop GUI applications?
23:20:45 <crocket> Let's say I am targeting windows and linux.
23:24:35 <srhb> crocket: Sure.
23:24:47 <crocket> srhb, how?
23:24:54 <srhb> crocket: How what?
23:25:01 <crocket> Which libraries ?
23:25:10 <srhb> crocket: wx, gtk, threepenny, ...
23:25:13 <srhb> There are many options.
23:25:18 <crocket> threepenny?
23:25:28 <crocket> Meh
23:25:33 <crocket> I don't care much about desktop applications anyway...
23:25:50 <crocket> Can haskell be used instead of javascript on web browsers?
23:25:51 <srhb> :P
23:26:01 <kadoban> What is going on …
23:26:03 <crocket> Is haskell good for front-end?
23:26:08 <crocket> Is haskell good for front-end web programming?
23:26:15 <srhb> I miss @canhaskell
23:26:33 <kadoban> crocket: There's ghcjs, which seems fun. I haven't used it though
23:26:48 <crocket> People say purescript which is similar to haskell
23:26:58 <srhb> There's also Fay.
23:27:46 <crocket> ok
23:27:51 <crocket> Is wx binding good?
23:27:57 <crocket> Is gtk binding?
23:28:36 <pavonia> Define good in that context
23:30:18 <crocket> Those bindings should feel idiomatic and be mostly free of salient bugs.
23:30:29 <crocket> There could be weird edge case bugs, though...
23:30:50 <crocket> And, they should also be easy to use.
23:32:03 <srhb> crocket: I don't think either of them feel idiomatically Haskelly.
23:32:07 <srhb> Other than that, yes.
23:32:33 <crocket> ok
23:32:45 <crocket> ready to write desktop GUI applications in haskell
23:32:56 <crocket> I'd probably use ClojureScript on the web...
23:32:57 <jle`> :D
