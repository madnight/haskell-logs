00:01:39 * hackagebot hein 0.1.0.0 - An extensible build helper for haskell, in the vein of leiningen.  http://hackage.haskell.org/package/hein-0.1.0.0 (khanage)
00:01:39 * hackagebot hein 0.1.0.1 - An extensible build helper for haskell, in the vein of leiningen.  http://hackage.haskell.org/package/hein-0.1.0.1 (khanage)
00:21:34 * hackagebot hein 0.1.0.2 - An extensible build helper for haskell, in the vein of leiningen.  http://hackage.haskell.org/package/hein-0.1.0.2 (khanage)
00:54:26 <Myrl-chan> :t splitOn
00:54:27 <lambdabot> Eq a => [a] -> [a] -> [[a]]
00:54:41 <Myrl-chan> splitOn "/" "a/b/c"
00:54:49 <Myrl-chan> > splitOn "/" "a/b/c"
00:54:51 <lambdabot>  ["a","b","c"]
00:55:02 <Myrl-chan> :t splitAt
00:55:03 <lambdabot> Int -> [a] -> ([a], [a])
00:55:20 <ski> > splitOn "" "abc"
00:55:21 <lambdabot>  ["","a","b","c"]
01:40:41 <fred-fri> im taking a look at haskell, wondering whether to download compiler and base libraries or haskell platform.
01:41:17 <fred-fri> i note the haskell platform package in mint is quite old, february 2013
01:46:57 <unknownloner> fred-fri: I don't think it really matters which you do, I'd go with whatever gets you the most up-to-date stuff
01:47:18 <unknownloner> It's pretty much just as easy to go one way or the other on linux
01:48:42 <fred-fri> im downloading haskell platform "generic linux binaries" from https://www.haskell.org/platform/linux.html
01:48:47 <fred-fri> hope that will serve
01:49:38 <fred-fri> but i wonder if i wouldnt get newer stuff with the instructions for ubuntu found here https://www.haskell.org/downloads/linux
01:50:16 <funfunctor> Hi
01:51:39 * hackagebot memory 0.5 - memory and related abtraction stuff  http://hackage.haskell.org/package/memory-0.5 (VincentHanquez)
02:13:07 <ttt_fff> in standard math notation, are matches 0 or 1-indexed? I know that matlab/lua uses 1-indexing, c / c++ / haskell uses 0-indexing, but what does math notation use for maties?
02:16:37 <pavonia> ttt_fff: What matches?
02:16:40 * hackagebot bitx-bitcoin 0.1.0.0 - A Haskell library for working with the BitX bitcoin exchange.  http://hackage.haskell.org/package/bitx-bitcoin-0.1.0.0 (tebello_thejane)
02:16:55 <ttt_fff> oh
02:16:55 <ttt_fff> matrices
02:17:00 <ttt_fff> wtf, why did I type matches
02:17:02 <funfunctor> Hi
02:17:04 <ttt_fff> *MATRICES* :-)
02:17:36 <funfunctor> can anyone makes heads or tails for the Type of this? http://dev.w3.org/geo/api/spec-source.html#position-error
02:18:05 <funfunctor> why is there a enum there but done with shorts and then a unsigned short for the code any way? I don't get it
02:18:07 <pavonia> ttt_fff: In our math courses they usually stared at one, but that might differ
02:18:50 <ttt_fff> yeah; this is fucking annoying :-)
02:18:55 <ttt_fff> s/fucking/friendly/
02:19:16 <funfunctor> the old Naturals should start at 1 or 0 argument?
02:21:40 * hackagebot relational-query 0.5.0.0 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.5.0.0 (KeiHibino)
02:22:49 <ski> ttt_fff : .. i would of course start at `0', on principle
02:22:58 <pavonia> funfunctor: What part don't you understand in that definition?
02:23:11 <ttt_fff> ski: I like starting on 0, since % n makes sense for circular stuff
02:24:19 <ski> (so an element of `|R ^ (2 * 3)' would be a function which accepts a pair of an element of `{0,1}' and an element of `{0,1,2}', interpreting the `2' and `3' in the exponent as canonical finite sets with that many elements, namely the naturals that are strictly less than the cardinality)
02:25:27 <funfunctor> pavonia: is that a struct of the string code but unioned with the enum
02:25:30 <funfunctor> i don't get it
02:26:06 <pavonia> It's a string + code that can be one of three constants
02:28:48 <pavonia> funfunctor: Like that, I think http://lpaste.net/133591
02:30:12 <funfunctor> pavonia: ah your right! see https://developer.mozilla.org/en-US/docs/Web/API/PositionError Mozilla write much better docs than the spec O_o
02:31:41 * hackagebot ghc-heap-view 0.5.4 - Extract the heap representation of Haskell values and thunks  http://hackage.haskell.org/package/ghc-heap-view-0.5.4 (JoachimBreitner)
02:40:22 <funfunctor> Why would show ever need to be applied to a String type to actually get it to print?
02:41:01 <funfunctor> wait, what is the encoding of String ? UTF-16 ?
02:42:16 <Taneb> funfunctor, UTF-32 I believe
02:42:31 <mniip> funfunctor, native word size
02:42:46 <mniip> no UTFs
02:45:12 <funfunctor> W3C specifies a DOMString as UTF16, if I use :: String in my Fay FFI binding I need to apply show to it to actually get it to print a non-empty string so I guess show is internally converting the string into readable chars?
02:47:06 <pavonia> show is converting from String to String. If you have to communicate with external libraries, you probably want to use a ByteString and apply the correct encoding yourself
02:47:18 <zipper> How can I check timestamps with GHC to check out the files that have changed and should be recompiled.
02:47:20 <zipper> *?
02:48:01 <pavonia> zipper: Doesn't GHC already do that?
02:48:23 <zipper> pavonia: Yeah how do I use it in my code?
02:48:32 <zipper> or will it do it automatically?
02:48:47 <pavonia> I think so
02:48:56 <zipper> Whaaaattttt??????????????
02:48:59 <zipper> Cray!!!
02:49:10 <zipper> I guess it makes sense now that I think about it.
02:49:11 <pavonia> I mean if you are compiling your Haskell code using GHC
02:50:28 <zipper> pavonia: I am
02:50:34 <zipper> pavonia: Thanks a ton.
02:50:45 <pavonia> No problem
02:50:53 <dramforever> funfunctor: I guess there's something like data Char = C# Char# in GHC.Prim or something
02:51:11 <dramforever> and we have type String = [Char]
02:51:15 <dramforever> that explains it
02:51:20 <funfunctor> dramforever: well this isn't actually Haskell but it is.. Its a EDSL, Fay
02:51:36 <dramforever> ouch, missed a context
02:51:37 <dramforever> sorry
02:52:03 <funfunctor> interesting thing is when I do the show I get a embedded string since I get ""foo""
02:52:38 <funfunctor> I tried using Text also
02:56:44 <funfunctor> Hmm, print works but putStrLn only shows a empty string unless (putStrLn . show)
02:56:50 <funfunctor> so yea, must be a encoding issue
02:57:54 <fizruk> hello everyone! I have trouble installing wxHaskell on Mac OS: http://lpaste.net/133594
02:58:04 <fizruk> any hints are welcome! :)
03:06:36 <funfunctor> sweet, fixed that with unpack
03:07:38 <ThuletheKing> I have this code withArray [0,1] (withArray [100,0] . setXXX c_setReal setRealFunc instantiateVal 2) - and I am wondering exactly how it works. the function setXXX takes 6 arguments. As far as I can tell by the result withArray [100,0] is applied as argument 6, and withArray [0,1] is applied as argument 5. However I do not understand why it is not 
03:07:39 <ThuletheKing> the other way around.. Can someone help me understand this?
03:11:42 * hackagebot publicsuffix 0.20150507 - The publicsuffix list exposed as proper Haskell types  http://hackage.haskell.org/package/publicsuffix-0.20150507 (wereHamster)
03:45:25 <funfunctor> why would I get a 'NaN' inside a 'Maybe Double' ?
03:45:36 <funfunctor> Should I not get 'Nothing' ?
03:46:03 <funfunctor> lambdabot: :k NaN
03:46:13 <funfunctor> > :k NaN
03:46:15 <lambdabot>  <hint>:1:1: parse error on input ‘:’
03:47:42 <ph88> is cabal sandbox init   enough to start working in the sandbox? or do i need to activate it as well ?
03:48:28 <jacob2-> > fmap (/0) (Just 0)
03:48:29 <lambdabot>  Just NaN
03:48:33 <jacob2-> you expected this to return Nothing?
03:49:14 <jacob2-> ph88 it is enough. just don't change directory
03:49:22 <jacob2-> (obviously)
03:50:27 <Myrl-chan> Oh cool
03:50:33 <Myrl-chan> > 0/0
03:50:35 <lambdabot>  NaN
03:50:44 <Myrl-chan> Not divByZero or Inf?
03:50:48 <Myrl-chan> > 1/0
03:50:50 <lambdabot>  Infinity
03:50:52 <funfunctor> ph88: I get data marshelled back from JS in Fay
03:51:04 <Myrl-chan> > 1/(1/0)
03:51:06 <lambdabot>  0.0
03:51:10 <Myrl-chan> Hahaha, cool.
03:51:13 <funfunctor> some of the fields are optional, I wrapped them in Maybe's but I get back NaN
03:51:23 <Maxdamantus> It's probably related to IEEE-754, which has NaN and infinityp.
03:51:39 <Maxdamantus> > 1 `div` 0
03:51:41 <lambdabot>  *Exception: divide by zero
03:51:42 <Myrl-chan> Maxdamantus: Yeah.
03:51:43 <ph88> funfunctor: ???
03:52:06 <Myrl-chan> Maxdamantus: But isn't x/0 in IEEE-754 infinity, if x >= 0?
03:52:16 <Myrl-chan> Maxdamantus: And -infinity, if x <= -0
03:52:23 <funfunctor> ph88: oh ah, https://developer.mozilla.org/en-US/docs/Web/API/Coordinates
03:52:34 <funfunctor> "If speed is 0, heading is NaN. If the device is unable to provide heading information, this value is null."
03:52:35 <Myrl-chan> I may be wrong bout that dough.
03:52:42 <funfunctor> hmm???
03:52:45 <ph88> funfunctor: why are you telling me this ?
03:52:49 <Myrl-chan> funfunctor: Such poetry.
03:53:15 <Maxdamantus> Myrl-chan: it shouldn't be when it's = 0
03:53:27 <Maxdamantus> (or -0)
03:53:47 <Maxdamantus> 0/0 should be NaN
03:54:07 <funfunctor> Well I have a binding and my type is defined as Maybe Double but I get NaN marshalled back when I am expecting Nothing
03:54:07 <Maxdamantus> mathematically, it's indeterminate—it can be any value.
03:54:12 <ph88> setup-Simple-Cabal-1.22.0.0-x86_64-linux-ghc-7.8.3: The pkg-config package 'fftw3f' version >=3.3 && <4 is required but it could not be found.   do i need to install libfftw3-dev  ?
03:54:29 <Myrl-chan> Maxdamantus: I guess I was wrong.
03:54:29 <ph88> funfunctor: this is the haskell channel, check #javascript
03:55:06 <funfunctor> ph88: what has that got to do with JS? the marshalling code is getting generated by GHC
03:55:06 <ronh-> funfunctor it would be helpful if you provided an example where you expected Nothing but got NaN
03:55:08 <Maxdamantus> if you have `a/b = c` iff `c*b = a`, then you have `0/0 = 4` because `4*0 = 0`
03:55:57 <Myrl-chan> > 1 / Infinity
03:55:58 <lambdabot>      Not in scope: data constructor ‘Infinity’
03:55:58 <lambdabot>      Perhaps you meant variable ‘infinity’ (imported from Data.Number.Natural)
03:56:02 <Myrl-chan> HMmm
03:56:08 <Myrl-chan> > 1 / nan
03:56:10 <lambdabot>      Not in scope: ‘nan’
03:56:10 <lambdabot>      Perhaps you meant one of these:
03:56:10 <lambdabot>        ‘tan’ (imported from Prelude), ‘non’ (imported from Control.Lens)
03:56:23 <funfunctor> ronh-: ok, data Foo = Foo { bar :: Maybe Double }  and  f :: Fay Foo    f = ffi "%1"
03:56:31 <Myrl-chan> > 1 / (0/0)
03:56:33 <lambdabot>  NaN
03:56:35 <Myrl-chan> Ah.
03:56:39 <mniip> Myrl-chan, any operation on NaN is Nan
03:56:48 * Myrl-chan pets mniip
03:56:52 <Myrl-chan> mniip: you're back! c:
03:57:06 <mniip> any test involving NaN is False
03:57:19 <ph88> haskell is too difficult on windows
03:57:26 <ph88> haskell, cabal, hackage, packages
03:57:30 <Myrl-chan> mniip: Even NaN != NaN.
03:57:35 <funfunctor> hmm https://hackage.haskell.org/package/fay-base-0.20.0.0/docs/Data-Nullable.html probably related issue for me
03:57:37 <mniip> precisely
03:57:39 <Maxdamantus> > (0/0) /= (0/0)
03:57:40 <lambdabot>  True
03:57:42 <ph88> Myrl-chan: i can confirm that
03:57:56 <Maxdamantus> that's true, not false.
03:58:16 <Myrl-chan> I think it has something to do with that NaN can have many different representations, so just make it false for everything.
03:58:28 <mniip> I stand corrected
03:58:33 <ph88> the floating point unit in the CPU gives unequal for two invalid floats
03:58:42 <mniip> Myrl-chan, NaN represents all numbers at once
03:58:51 <ph88> o_O
03:58:59 <ph88> Not A Number
03:59:02 <Myrl-chan> mniip: I'm talking about the representation in IEEE-754.
03:59:11 <mniip> that one isn't even checked
03:59:27 <mniip> the FPU sees a NaN, unsets the ZF
03:59:54 <Maxdamantus> ph88: not a number, but many numbers.
04:00:34 <Myrl-chan> mniip: Yeeee
04:00:57 * Myrl-chan was talking about the representation, but kay.
04:01:10 <mniip> the representation is not what is checked by equality test
04:01:34 <Myrl-chan> mniip: Yes, but there must have been a reason why they made it False for everything.
04:01:48 <Myrl-chan> NaN == x -> False
04:02:29 <mniip> Myrl-chan, because let x = 0 in x*x/x
04:02:37 <mniip> and let x = 0 in x/(x*x)
04:02:37 <Myrl-chan> mniip: tru
04:02:41 <mniip> are two different limits
04:03:08 <mniip> both of which result in NaN because they are indeterminate
04:03:43 <mniip> you shouldn't be testing indeterminity for equality, but those limits result in different values
04:03:43 <Myrl-chan> ic.
04:04:11 <ph88> where can i find the documentation / example of this package?  https://hackage.haskell.org/package/fft
04:05:08 <mniip> ph88, in the code
04:05:33 <mniip> you can see haddocks for modules by clicking on a module name in the module list
04:05:49 <ph88> there should be a webpage about it
04:07:05 <mniip> ph88, there is
04:07:12 <mniip> the haddock
04:07:36 <mniip> ph88, just click on 'Math.FFT'
04:08:19 <ph88> oh ye
04:09:21 <Myrl-chan> [1,2,3] >>= show
04:09:23 <Myrl-chan> > [1,2,3] >>= show
04:09:25 <lambdabot>  "123"
04:09:29 <Myrl-chan> Hahaha, this is cool.
04:12:17 <jacob2-> yeah. >>= is concatMap for lists
04:13:48 <Maxdamantus> > do{ a <- ["foo", "bar"]; b <- ["baz", "qux"]; return (a ++ b) }
04:13:49 <jacob2-> :t (>>=)
04:13:50 <lambdabot>  ["foobaz","fooqux","barbaz","barqux"]
04:13:51 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:13:55 <jacob2-> :t flip concatMap
04:13:56 <lambdabot> Foldable t => t a -> (a -> [b]) -> [b]
04:14:13 <ph88> how do i put 4 numbers in a CArray ?
04:15:08 <jacob2-> well foldable made that slightly less obvoius
04:15:32 <ph88> can anyone tell me how to use this?  https://hackage.haskell.org/package/fft-0.1.8/docs/Math-FFT.html#g:6
04:20:29 <ph88> how do i run ghci from the sandbox ?
04:20:45 <ph88> :t Data.Array.CArray.Base
04:20:47 <lambdabot>     Not in scope: data constructor ‘Data.Array.CArray.Base’
04:20:50 <ph88> :t Data.Array.CArray
04:20:52 <lambdabot>     Not in scope: data constructor ‘Data.Array.CArray’
04:20:52 <lambdabot>     Perhaps you meant one of these:
04:20:52 <lambdabot>       variable ‘Data.Array.array’ (imported from Data.Array),
04:21:27 <jacob2-> ph88 are you using emacs?
04:21:36 <ph88> sublime
04:22:07 <jacob2-> I'll let someone else answer then
04:22:56 <maerwald> ph88: something like "ghci -no-user-package-db -package-db .cabal-sandbox/x86_64-linux-ghc-7.8.4-packages.conf.d/"
04:23:05 <maerwald> depending on your ghc version etc
04:23:14 <ph88> o_O ok
04:23:55 <ph88> ghc: can't find a package database at .cabal-sandbox/x86_64-linux-ghc-7.8.4-packages.conf.d/
04:23:59 <ronh-> just type `cabal repl' instead of ghci
04:24:09 <ronh-> in the root of the sandbox
04:24:27 <ph88> ok thx
04:24:55 <Myrl-chan> What would you install as global?
04:25:53 <maerwald> things that you need globally
04:26:12 <Myrl-chan> maerwald: Such as?
04:26:19 <maerwald> ghc-mod
04:26:43 <Myrl-chan> How about libraries?
04:26:44 <maerwald> hlint
04:27:05 <maerwald> rather not, unless they are dependencies of stuff I want globally
04:27:52 <Myrl-chan> What's ghc-mod for, by the way?
04:28:05 <jacob2-> if you install hlint globally won't you also globally install all the libraries that it depends on?
04:28:50 <zinfandel> Myrl-chan: Things that are widely used, (containers, unordered-containers, text, bytestring, haskell-src-exts, lens, conduit)
04:29:11 <Myrl-chan> I see.
04:29:41 <zinfandel> Myrl-chan: Although, every time I tried to do it with cabal a was ending up in hell.
04:29:55 <zinfandel> So, I am just using my system package manager
04:30:39 <maerwald> Myrl-chan: ghc-mod is for my editor
04:31:04 <maerwald> it would be annoying to install it in every sandbox
04:31:08 <Myrl-chan> I see.
04:41:48 * hackagebot arbtt 0.9.0.4 - Automatic Rule-Based Time Tracker  http://hackage.haskell.org/package/arbtt-0.9.0.4 (JoachimBreitner)
04:43:28 <jacob2-> how do you feel about  NullaryTypeClasses?
04:45:55 <nomeata> carter: Hi. In https://ghc.haskell.org/trac/summer-of-code/ticket/1669#comment:1 you write “it'd probably be simpler to take a page from how Agda and Idris and provide a facility to "teach" the compiler to use a more efficient data structure thats isomorphic to the inductive one”. What is that facility?
04:46:48 * hackagebot rss 3000.2.0.5 - A library for generating RSS 2.0 feeds.  http://hackage.haskell.org/package/rss-3000.2.0.5 (BasVanDijk)
04:51:49 * hackagebot distributed-process 0.5.4 - Cloud Haskell: Erlang-style concurrency in Haskell  http://hackage.haskell.org/package/distributed-process-0.5.4 (AlexanderVershilov)
06:06:53 * hackagebot base-noprelude 4.3.0.0 - "base" package sans "Prelude" module  http://hackage.haskell.org/package/base-noprelude-4.3.0.0 (HerbertValerioRiedel)
06:06:55 * hackagebot base-noprelude 4.3.1.0 - "base" package sans "Prelude" module  http://hackage.haskell.org/package/base-noprelude-4.3.1.0 (HerbertValerioRiedel)
06:16:53 * hackagebot base-noprelude 4.5.1.0 - "base" package sans "Prelude" module  http://hackage.haskell.org/package/base-noprelude-4.5.1.0 (HerbertValerioRiedel)
06:21:35 <ph88> ronh-: that does not load the sandbox packages
06:21:53 * hackagebot base-noprelude 4.7.0.2 - "base" package sans "Prelude" module  http://hackage.haskell.org/package/base-noprelude-4.7.0.2 (HerbertValerioRiedel)
06:21:55 * hackagebot base-noprelude 4.7.0.1 - "base" package sans "Prelude" module  http://hackage.haskell.org/package/base-noprelude-4.7.0.1 (HerbertValerioRiedel)
06:21:58 * hackagebot base-noprelude 4.6.0.1 - "base" package sans "Prelude" module  http://hackage.haskell.org/package/base-noprelude-4.6.0.1 (HerbertValerioRiedel)
06:26:54 * hackagebot servant-ede 0.4 - Combinators for rendering EDE templates in servant web applications  http://hackage.haskell.org/package/servant-ede-0.4 (AlpMestanogullari)
06:27:20 <ph88> is there an easier way to initialize an array except this?       :m Data.Array.CArray      listArray (0,3) [2,4,5,6,8,9] :: CArray Int Int
06:41:55 * hackagebot base-noprelude 4.8.0.0 - "base" package sans "Prelude" module  http://hackage.haskell.org/package/base-noprelude-4.8.0.0 (HerbertValerioRiedel)
06:46:55 * hackagebot base-noprelude 4.5.0.0 - "base" package sans "Prelude" module  http://hackage.haskell.org/package/base-noprelude-4.5.0.0 (HerbertValerioRiedel)
06:46:57 * hackagebot base-noprelude 4.6.0.0 - "base" package sans "Prelude" module  http://hackage.haskell.org/package/base-noprelude-4.6.0.0 (HerbertValerioRiedel)
06:49:00 <muzzle> is there a tutorial anywhere that explains how to acces files from a cabal package's data-dir (from within that package) ?
06:49:08 <muzzle> because i seem to stupid to find one
06:49:29 <hvr> muzzle: search for Paths_ module
06:50:27 <ChristianS> muzzle: specifically, import Paths_yourmodulename (getDataFileName)
06:51:42 <muzzle> there is no way to make this work with a dash in the package name ?
06:51:55 * hackagebot base-noprelude 4.7.0.0 - "base" package sans "Prelude" module  http://hackage.haskell.org/package/base-noprelude-4.7.0.0 (HerbertValerioRiedel)
06:51:57 * hackagebot redis 0.14.1 - A driver for Redis key-value database  http://hackage.haskell.org/package/redis-0.14.1 (GaneshSittampalam)
06:52:35 <ronh-> ph88 it should. note that loading packages is not the same as importing modules you want to use
06:52:35 <hvr> muzzle: dashes will probably get translated to _s
06:52:38 <muzzle> hvr ChristianS I found it in the cabal manual, thx :)
06:52:48 <muzzle> i'll try that hvr, thx
06:53:15 <hvr> or deleted (i.e. foo-bar will either become foo_bar or foobar, I don't remember which)
06:53:37 <ronh-> ph88 also, did you type "cabal install" before "cabal repl"?
06:54:09 <ronh-> or  cabal install --only-dependencies, depending on what you want
06:56:09 <ph88> ronh-: i get  cabal: can't find source for Main in src
06:56:26 <fishburne529> what is a good haskell library for talking to a postgresql database?
06:56:31 <ronh-> do you have main in src?
06:56:34 <ronh-> main.hs
06:56:44 <ph88> ye
06:57:19 <ronh-> with a main function? and no explicit module line
06:57:31 <ph88> ye
07:00:12 <ronh-> if you can paste cabal file and directory structure
07:00:30 <ph88> ok
07:00:39 <ph88> how can i ls the subdirs ?
07:01:43 <ph88> ronh-: i found the error already. cabal file was pointing to Main.hs  i had a file called main.hs
07:01:56 * hackagebot gtk3 0.13.7 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk3-0.13.7 (HamishMackenzie)
07:01:58 * hackagebot gtk 0.13.7 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.13.7 (HamishMackenzie)
07:02:10 <muzzle> hvr: they did get converted to underscores btw
07:02:15 <muzzle> thx for that info
07:02:18 <ph88> ronh-: the modules are not getting loaded properly
07:02:34 <ronh-> ph88 ah ok. the program you wanted was tree btw
07:03:04 <A31415965359> does lambda bot support :sprint?
07:03:06 <ph88> ronh-: http://pastebin.com/06aVP4pM
07:03:48 <ph88> ronh-: http://pastebin.com/9yXwGaAy
07:05:00 <mniip> A31415965359, I doubt
07:05:24 <mniip> lambdabot supports a very limited about of haskell
07:05:35 <mniip> there's no GHC-specific features there iirc
07:05:47 <mniip> oh wait holes
07:05:59 <mniip> er
07:06:02 <mniip> s/about/amount/
07:06:13 <fishburne529> what is a good haskell library for talking to a postgresql database?
07:08:23 <A31415965359> how can i pick using sprint into polymorphic expressions? like let q = 1 + 2 ; after printing it sprint still gives q = _
07:09:57 <mniip> A31415965359, polymorphic expressions are similar to functions
07:10:22 <A31415965359> so there is no easy way to see their WHNF ?
07:10:39 <mniip> there is no WHNF
07:10:44 <mniip> they are polymorphic
07:11:30 <A31415965359> so they have just name right?
07:11:38 <mniip> A31415965359, think about it, what is the WHNF of 'return 3'
07:11:42 <coin3d> hey there. just noticed i still don't really understand currying. in the lyah book, there is this flip' function: https://gist.github.com/anonymous/88ce8259186a49c8cb04
07:11:42 <mniip> Just 3?
07:11:46 <mniip> 3 : []?
07:11:54 <mettekou> I have written a lexer and parser for a subset of C (Tiny) using Alex and Happy. I would now like to perform basic semantic analysis: detecting whether a variable is used only after it it declared and rudimentary type checking. I was wondering if there are already any libraries on Hackage which implement this for other imperative languages.
07:11:55 <mniip> <BCO> ?
07:12:10 <coin3d> and my question is: how does haskell know to apply the both lists to flip'? 
07:12:13 <A31415965359> mniip: ty :) i will think about it
07:15:04 <fishburne529> what is a good haskell library for talking to a postgresql database?
07:19:30 <rhaps0dy> coin3d: zipWith
07:19:34 <rhaps0dy> coin3d: zipWith does this
07:20:09 <A31415965359> mniip: so basically q = 1 + 2 is already normal form since as you said it is a function?
07:20:52 <mniip> well
07:20:57 <mniip> I suppose
07:21:09 <rhaps0dy> @src zipWith
07:21:09 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
07:21:10 <lambdabot> zipWith _ _      _      = []
07:21:15 <mniip> you cannot observe a normal form of a polymorphic expression though
07:21:20 <A31415965359> i mean is there a way to hack in and see how it actually represented?
07:21:37 <coin3d> rhaps0dy: interesting. so although zipWith itself needs 3 parameters, one function, two lists - it automatically passes those two lists to flip'?
07:21:57 * hackagebot webkitgtk3 0.13.1.3 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkitgtk3-0.13.1.3 (HamishMackenzie)
07:22:05 <mniip> A31415965359, there is
07:22:22 <rhaps0dy> coin3d: exactly
07:22:40 <A31415965359> mniip: could you please tell me what is it ? :)
07:23:15 <mniip> A31415965359, this code demonstrates how the hidden instance parameter works: https://hackage.haskell.org/package/reflection-1.5.2.1/docs/src/Data-Reflection.html#Magic
07:24:51 <mm_> Does foldl fuse?
07:25:01 <A31415965359> mniip:ty, will look at it
07:26:57 * hackagebot webkit 0.13.1.3 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkit-0.13.1.3 (HamishMackenzie)
07:36:28 <mniip> A31415965359, hey
07:37:57 <A31415965359> mniip: yes
07:39:02 <SrPx> Is there any way to convert an unboxed vector of (Int,Int) to a storable vector of Ints (with 2x the size)?
07:40:28 <mniip> weird
07:40:35 <mniip> second thing doesn't work
07:41:58 * hackagebot razom-text-util 0.1.1.0 - Common text/parsing tools for Razom language packages.  http://hackage.haskell.org/package/razom-text-util-0.1.1.0 (akrasner)
07:42:16 <lpaste> mniip pasted “instance table” at http://lpaste.net/133599
07:42:21 <mniip> A31415965359, ^
07:42:29 <A31415965359> mniip: ty
07:43:02 <mniip> things to try: test (TableClass 3 (*2))
07:43:10 <A31415965359> ty :)
07:43:15 <A31415965359> for guiding
07:43:19 <A31415965359> me into it
07:47:07 <A31415965359> mniip: so this basically "evaluated" it?
07:47:14 <mniip> uh no
07:47:22 <A31415965359> i get 6 :)
07:47:24 <mniip> this is just how instance arguments work
07:47:45 <fishburne529> what is a good haskell library for talking to a postgresql database?
07:48:12 <mniip> you can try unsafecoercing your polymorphic value into an appropriate table-consuming function
07:48:24 <A31415965359> mniip:ok i think now i connect to start of our conversation about polimorphism
07:50:50 <A31415965359> mniip: so this kinda "proves" that they have same internal representation? based on definition of unsafeCoerce
07:51:06 <mniip> only in GHC obviously
07:51:49 <A31415965359> mniip: ty, this is helpful :)
07:56:53 <ion> The reflection package takes advantage of that.
07:57:20 <indiagreen> I have a question about Snap: there's a custom MyConfig structure and a dozen routes that need access to that config (without modification or anything). How can I give them all access? Before moving to snaplets I could just do “runReaderT myconfig” after “routes”, but now I moved to snaplets and everything became complicated and I'm lost and confused
07:57:21 <A31415965359> mniip: here is interesting discussion http://stackoverflow.com/questions/21518584/sprint-for-polymorphic-values
08:11:24 <shwouchk> hello
08:11:37 <shwouchk> what is a millioleg?
08:11:47 <shwouchk> p.s. dameloo just spammed me
08:12:00 * hackagebot metrics 0.3.0.0 - High-performance application metric tracking  http://hackage.haskell.org/package/metrics-0.3.0.0 (IanDuncan)
08:12:03 <A31415965359> i also got this spamm
08:12:12 <A31415965359> ignor spammer
08:12:40 <hexagoxel> dzack: you probably need `cabal configure` to pick up changes to .cabal file
08:33:30 <SrPx> Can I define a storable instance for non-primitive structures? I.e., "data Foo = Foo Int Int" to represent "struct { Int a; Int b }" ?
08:35:56 <SrPx> sizeOf :: a -> Int -- why not just sizeOf? 
08:36:01 <SrPx> sizeOf :: Int *
08:37:33 <nullvoid8> sizeOf is because you need the a to disambiguate which Storable instance you want
08:37:58 <nullvoid8> srPx: ^
08:39:07 <nullvoid8> SrPx: as to the storable Foo, you can, but you need to hardcode the offsets into the struct from a ptr, or use a tool that can do it for (c2hs, hsc2hs, etc)
08:41:18 <ion> SrPx: The modern way would be sizeOf :: proxy a -> Int
08:41:28 <SrPx> So, how exactly do I define "alignment" for "struct { Int a; Float a; }" ?
08:41:35 <ion> I mean sizeOf :: Storable a => proxy a -> Int
08:41:52 <nullvoid8> again, you have to hardcode, or use tools for alignment
08:42:06 <nullvoid8> I think storable was made before Proxy was a thing
08:42:12 <ion> yeah
08:42:18 <ion> Ditto for a number of other things in base
08:42:34 <SrPx> yes I know I have do hardcode
08:42:41 <SrPx> but what does it mean? I don't understand.
08:42:50 <nullvoid8> but you are guarenteed that a conforming instance won't look at the argument, so a undefined is kinda ok
08:42:58 <SrPx> sizeOf is simple, sizeOf _ = sizeOf (undefined :: Float) + sizeOf (undefined :: Int) - okay.
08:43:18 <nullvoid8> that's not guarenteed iirc
08:43:29 <nullvoid8> if you're trying to match it to  a struct
08:43:32 <SrPx> but I have no idea what alignment means
08:44:09 <nullvoid8> alignment is governs the padding when you have an array I think
08:44:37 <ion> SrPx: https://wiki.haskell.org/FFICookBook#Working_with_structs
08:44:38 <nullvoid8> or might be that the address of the struct has to be divisible by $alignment
08:45:20 <nullvoid8> wiki for alignment: https://en.wikipedia.org/wiki/Data_structure_alignment
08:45:45 <ion> https://github.com/vincenthz/hs-gen-storable
08:46:36 <SrPx> ion: that doesn't explain how to do it without hsc2hs
08:47:41 <nullvoid8> SrPx: are you looking to do it manually?
08:47:45 <ion> I'm not sure you can hardcode those values, they may be platform-dependent.
08:48:15 <SrPx> yes nullvoid8 
08:48:34 <nullvoid8> as ion said, bad idea
08:48:47 <mjrosenb> is it reasonable to write a Storable instance for a recursive structure?
08:48:49 <hsyl20> SrPx: https://wiki.haskell.org/FFI#The_explicit_way
08:51:01 <SrPx> thanks
08:53:21 <hsyl20> SrPx: the page doesn't mention alignment. If you have only Int fields you can align to sizeOf (undefined :: Int)
08:53:52 <SrPx> I'm actually replacing my floats by ints on the C code just to do that, thanks...
08:54:18 <hsyl20> SrPx: you can use Floats without problems
08:55:02 <SrPx> but on 64bit platforms the alignment won't make sense because Int is 64bits but floats are still 32bits
08:55:04 <mjrosenb> I guess my question could also be phrased as "should poke ever allocate memory"?
08:56:47 <hsyl20> SrPx: use alignment = 4 in this case
08:59:08 <SrPx> hsyl20: why?
08:59:15 * SrPx gives up
08:59:35 <SrPx> okay back to the floats
09:00:02 <hsyl20> SrPx: the alignment of the whole struct is the max of the alignments of the fields (so that with an array of structs, fields are still aligned)
09:00:18 <SrPx> ah thank you.
09:00:42 <hsyl20> maybe I should add this to the wiki :)
09:01:34 <SrPx> But then why 4? Shouldn't that be 32 the max? (on 64bit architectures, 3 doubles + 1 int)
09:01:45 <SrPx> = 32 bytes
09:02:09 <hsyl20> the max not the sum
09:02:21 <SrPx> okay
09:02:37 <SrPx> ahhh I see
09:05:33 <hsyl20> hum it is even better defined as the least common multiple of the alignments of the fields (but in practice alignments are 1, 2, 4 or 8 so it is equivalent to the max)
09:05:46 <mjrosenb> hsyl20: you seem to know about storable, any idea about my question?
09:05:55 <hsyl20> http://hackage.haskell.org/package/c-storable-deriving-0.1.1/docs/src/Foreign-CStorable-TypeClass.html#CStorable use lcm for instance
09:06:55 <hsyl20> mjrosenb: Storable is for constant sized data. The size is determined only by the type
09:07:31 <vk> Hello, absolute newbie here. I get this error when I try to import sortBy: "parse error on input 'import'". Anyone know what the problem is?
09:08:01 <mjrosenb> hsyl20: each node in the structure in constant size.
09:08:18 <ski> @paste
09:08:18 <lambdabot> Haskell pastebin: http://lpaste.net/
09:08:19 <ski> vk ^
09:08:31 <hsyl20> mjrosenb: yes but is the whole structure constant in size?
09:09:21 <mjrosenb> negative
09:09:28 * mjrosenb renames peek to peekNode
09:10:35 <vk> Thanks. Here's the code: http://lpaste.net/133600
09:11:49 <hsyl20> mjrosenb: however you may define instance of Get and Put from Data.Binary for the whole structure
09:12:18 <mjrosenb> hsyl20: ooh, that sounds good.
09:12:40 <ski> vk : is that the whole of your source file ?
09:13:18 <vk> No, but that is the relevant part, minus a comment. The rest of it compiled fine until now. I'll put up the rest of it now.
09:14:07 <fishburne529> what is a good haskell library for talking to a postgresql database?
09:14:31 <vk> All right, it's up now.
09:14:57 <ski> vk : imports must come before declarations
09:15:10 <vk> So it should be at the top of my file?
09:15:16 <ski> yep
09:15:30 <vk> Alrighty. Thanks very much for the help.
09:15:30 <ski> (after the `module ...' line, if you have any)
09:15:47 <ski> np
09:17:13 <ski> vk : `1 + (len (tail xs))' could be just `1 + len (tail xs)' (it means the same thing), similarly `((length xs) - 1)' could be `(length xs - 1)'
09:18:05 <ski> vk : in `mean' and `palindromise', instead of using a guard with `null', you could possibly pattern-match
09:18:54 <ski> vk : in `palindromise', instead of using `head' and `tail', you can pattern-match (as you do for  mean'  ..)
09:19:06 <vk> ski : thanks, I'm still getting used to the precedence rules. Is there a general rule for when to use guards and when to pattern-match?
09:20:01 <ski> > init "abcd"  -- also see this
09:20:03 <lambdabot>  "abc"
09:22:05 <ski> vk : generally speaking, use pattern-matching if you can. the implementation has a better chance of checking them for dead cases and for exhaustiveness; possibly it can also generate more efficient code
09:23:17 <vk> ski : Any situation in which you should use guards, then?
09:24:03 <ski> (also, generally speaking, if you can avoid taking the length of a (linked) list, or avoid indexing into a list, you should probably avoid that. if you can't avoid it, perhaps that's a sign that you need to use another data structure (like array, finite map, ..))
09:24:39 <ski> vk : when you have boolean conditions that can't sensibly be expressed in terms of pattern-matching instead
09:25:29 <ski> e.g., instead of checking `length xs <= 1', you could check the two cases `[]' and `[_]'
09:26:08 <vk> ski: great, thanks for the tips. I'm progressing linearly through Real World Haskell and haven't encountered any other data structures.
09:26:16 <athan_> hey guys just making sure - when evaluating a typed lambda calculus, the result of evaluation shouldn't change it's type, correct?
09:26:41 <ski> `length xs' will compute the whole length of the list (impossibly for an infinite list, though that's not relevant here, since `isPal' can't possibly work for those anyway), even if all we wanted to know was whether there was more than one element in the list or not (which only requires checking the first two list cells)
09:27:11 <ski> athan_ : yes, that's called "preservation"
09:27:18 <athan_> thank you ski :)
09:27:28 <aspidites> what's the best way to have cabal-install point to cabal-1.22.3.0 if Cabal was installed by a package manager?
09:28:05 <ski> vk : now, `head xs /= last xs' is harder to reduce. we can avoid `head xs' by pattern-matching, but we can't sensibly avoid `last xs' (since we must traverse the whole list to get to the end)
09:28:08 <aspidites> that is, i installed ghc on arch linux, but because 7.10.1 includes cabal-1.22.2.0, I'm getting errors about a deprecated cabal package format
09:28:28 <ski> so, either leave it, or (maybe) find another way to check this
09:28:51 <ski> vk : did you see what i meant with `init', btw ?
09:29:13 <vk> ski : I'm looking up what init means and am making the changes you suggested.
09:29:54 <aspidites> hmm... i unregistered cabal-1.22.2.0, yet cabal-install still clames to be using it...
09:29:59 <ski> (i was hoping you'd figure out by yourself why i mentioned `init' .. :)
09:30:11 <ski> (after first grokking what it does, of course)
09:30:44 <ski> vk : btw, style. why `x' in the last type signature, while you have `a' in the other ones ?
09:32:05 <ski> vk : generally, if you're using `head' and `tail', you should probably use pattern-matching instead (another reason is that in case you accidentally pass an empty list, you'll get better run-time error messages with explicit pattern-matching, that with calling a function)
09:32:47 <staffehn> ski, vk: A syntactically nice way of checking lengths lazily is with lazy natural numbers: https://wiki.haskell.org/Peano_numbers
09:33:30 <ski> staffehn : yes, but then you should use `genericLength', not `length'
09:33:32 <ski> @type length
09:33:34 <lambdabot> Foldable t => t a -> Int
09:33:42 <ski> @type genericLength
09:33:42 <lambdabot> Num i => [a] -> i
09:34:08 <athan> ski: Do you know of any hindley-milner evaluators?
09:34:13 <ski> (the former always gives an `Int'. the latter can give other types, like a lazy natural number type)
09:34:36 <athan> or implementations of them? The ususal beta/eta/alpha is breaking preservation :\
09:34:44 <fluvian> I'd like to write a function that takes a list of elements and returns all elements that are greater than the ones before... should be a simple problem, but I can't think how to express it functionally.
09:34:45 <ski> athan : i suppose you mean HM checkers, or HM inferrers
09:34:50 <vk> ski : Haha, the inconsistent naming was a slip-up. Oh, is "init" a way of dropping the last element?
09:34:55 <fluvian> I'd rather not resort to State
09:34:58 <ski> vk : bingo :)
09:34:59 <staffehn> ski: Right, but it is pretty cool just to write something like genericLength xs >= (7 :: Peano) to get an efficient check on lengths without all the nasty pattern matching.
09:35:32 <ski> (vk : it still has to traverse the list to the end. but at least you're not traversing it twice, which the `take'&`length' combination did)
09:35:37 <athan> ski: No, I already have algorithm W working nicely, I now just need an evaluator / reduction algorithm that preserves the types
09:35:39 <fluvian> e.g. f [4,2,6,3,7,4] = [4,6,7]
09:36:37 <staffehn> fluvian: a fold with state
09:36:43 <ski> vk : if you feel like, you could an an exercise make a variant of `mean', where you use a directly recursive helper function, instead of a (tail recursive) accumulating one)
09:36:48 <aspidites> which would just be a scan right?
09:36:52 <aspidites> (to what staffehn said)
09:37:05 <KaneTW> fluvian: you could store your state using a helper function and a 2nd argument
09:37:59 <Cale> > nubBy (>=) [4,2,6,3,7,4]
09:38:00 <lambdabot>  [4,6,7]
09:38:05 <ski> vk : .. oh, and in practice, when you do that kind of accumulation, you'd make sure (because of prevalent laziness) to force the values of the two accumulation parameters at each step, otherwise you'd be building up huge arithmetic expressions that won't be evaluated until the very end
09:38:14 <aspidites> even better
09:38:22 <aspidites> nice Cale 
09:38:36 <KaneTW> @src nubBy
09:38:36 <lambdabot> nubBy eq []     = []
09:38:36 <lambdabot> nubBy eq (x:xs) = x : nubBy eq (filter (\ y -> not (eq x y)) xs)
09:38:50 <aspidites> that's in Data.List, right?
09:38:50 <ski> (at least they wouldn't, unless the implementation is sufficiently smart to recognize that they'll get evaluated in the end anyway, so that it's no use delaying the inevitable)
09:38:51 <Cale> Note that officially, nubBy is unspecified for non-equivalence-relations
09:39:08 <Cale> But I think it's just as meaningful an operation for other relations
09:39:19 <fluvian> thanks Cale, I can work with that
09:39:28 <Cale> and yeah, it's in Data.List
09:39:43 <vk> ski : I think I will continue working through the exercises of the chapter I'm on. Thanks for all the help.
09:39:59 <fluvian> Is it O(n^2) as expected, or is there some compiler magic happening to make things more efficient?
09:40:17 <Cale> It's O(n^2)
09:40:37 <Cale> But in a way where it can operate on infinite lists.
09:40:50 --- mode: ChanServ set +o Cale
09:40:54 --- mode: Cale set +b *!*@222.Red-83-36-247.dynamicIP.rima-tde.net
09:40:54 --- kick: dameloo was kicked by Cale (dameloo)
09:41:01 <Cale> (PM spammer)
09:41:04 <ski> vk : that's fine. good luck, and don't forget to have fun !
09:41:13 --- mode: Cale set -o Cale
09:41:33 <fluvian> Cale: that seems counterintuitive... how could you nub an infinite list?
09:41:52 <Cale> > nub [1..]
09:41:54 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:42:10 <Cale> You're always taking the first occurrence
09:42:33 <ski> vk : as a final point, i could mention that it's actually possible to shorten `sortlofl xs = sortBy (comparing length) xs' to `sortlofl = sortBy (comparing length)' (`sortlofl' is `sortBy' partially applied to `comparing length', resulting in a function that's still waiting for `xs', to pass on as second argument to `sortBy')
09:42:46 <Cale> That list gets slower and slower to continue pulling elements from, as the nth element is required to pass n-1 tests
09:43:02 <Cale> But each element only needs a finite amount of testing to end up in the result
09:43:14 <tombert> Hello!  I have a sort of conceptual question for people with a bit more expertise than me
09:43:15 <fluvian> ah, I understand
09:43:24 <ski> vk : this is possible because `sortBy' is written in "curried style", meaning that it takes its two arguments, one after the other (as opposed to taking them together in a pair, which would be "tupled style")
09:43:26 <fluvian> the predicates are evaluated lazily
09:43:42 <ski> vk : ok, that's all
09:43:54 <tombert> I want to build a game using SDL and haskell (obviously).  I've been reading that many games in Haskell are using FRP concepts and the Netwire library
09:44:11 <tombert> I was just curious if anyone here has used netwire, and if they feel it made the project easier overall
09:44:40 <vk> ski : Haha, all right. It's a bit of a leap (absolute beginner), but I'll keep it in mind.
09:44:46 <tombert> OR if they know if another reactive library that they feel might be better suited for a game
09:45:06 <tombert> OR if I should just say "screw it" to FRP and it makes games programming harder
09:46:07 <mjrosenb> so ((->) r) is a monad
09:46:20 <Cale> tombert: FRP is still a somewhat experimental approach to things. If your goal is to learn and you're already pretty comfortable with Haskell, definitely dig into the FRP libraries which are available (I'm a fan of reflex, which is relatively new)
09:46:44 <mjrosenb> this means if there is a large do block, then all of the intermediate functions will have the same argument type, won't they :-/
09:47:05 * hackagebot minst-idx 0.1.2.2 - Read and write IDX data that is used in e.g. the MINST database.  http://hackage.haskell.org/package/minst-idx-0.1.2.2 (muzzle)
09:47:19 <tombert> Cale: I'm always willing to learn; I"m still kind of new to the idea of FRP, but I've downloaded a copy of Conal Elliot's paper and always want to get better
09:47:20 <Cale> tombert: If you're just trying to get a game written, it may or may not be the best idea to start out with the fancy approach.
09:47:44 <tombert> Cale: Well the game is designed as a learning project, not a "i need something to ship in any amount of time"
09:47:58 <tombert> Cale: Hence why I was thinking learning FRP might make sense
09:48:03 <Cale> Yeah
09:49:18 <tombert> Cale: Any particular reason you prefer reflex over Sodium or Netwire?
09:49:34 * mjrosenb has been writing an xbmc-like gui using reactive banana + sdl for a while now.
09:50:00 <aspidites> note reflex is rather new
09:50:36 <Cale> tombert: Well, I'm biased, it's the latest iteration of an FRP system that I worked on with Ryan Trinkle a few years back (which used to be arrow-ized FRP and no longer is, so it's changed a lot)
09:50:39 <aspidites> and i'm not cale, but one thing to note about netwire is that it's arrowized, which means that you have yet another thing to learn
09:50:56 <aspidites> Cale: wait. reflex was arrowized?
09:51:03 <Cale> Not when it was called reflex
09:51:13 <staffehn> > let xs = [4,2,6,3,7,4] in catMaybes $ zipWith (\x a -> if x == a then Just x else Nothing) xs $ scanl1 max xs
09:51:15 <lambdabot>  [4,6,7]
09:51:45 <tombert> aspidites: Oh, I wasn't aware there was anything to learn with arrows
09:51:50 <Cale> But our in-house FRP system at iPwn was arrowized, (albeit with a differently defined Arrow class and a custom Arrow preprocessor)
09:52:24 <staffehn> > let xs = [4,2,6,3,7,4] in filter (uncurry (==)) . zip xs $ scanl1 max xs
09:52:26 <lambdabot>  [(4,4),(6,6),(7,7)]
09:52:35 <staffehn> > let xs = [4,2,6,3,7,4] in map fst . filter (uncurry (==)) . zip xs $ scanl1 max xs
09:52:37 <lambdabot>  [4,6,7]
09:53:37 <tombert> does anyone know of a good tutorial on arrows?
09:54:00 <Cale> But there are things which we learned about getting good performance out of FRP systems that are still encoded in how reflex works.
09:54:29 <Cale> Sodium is also pretty cool, it's actually by another one of our coworkers, Stephen Blackheath
09:54:56 <aspidite1> hmm. didn't realize you all worked on the same team
09:55:00 <mjrosenb> ahh, the (->) r monad does not compose the way I want it to.
09:55:02 <mjrosenb> blast.
09:56:32 <tombert> I'll give netwire and reflex a try
09:56:49 <tombert> hopefully that'll be good for getting a basic game built
09:58:06 <aspidite1> ugn. here lately compiling anything with ghc causes my entire computer to freeze
09:58:49 <aspidite1> nothing else seems to cause such a freeze. ran memory and hard drive tests and get nothing. monitored temps - nothing. onlything i can guess is motherboard
09:59:07 <tombert> aspidites: what platform are you on?
09:59:11 <aspidites> arch linux
09:59:21 <aspidites> kernel 4.0.1
09:59:22 <tombert> Hmm, I'm running arch as well
09:59:31 <tombert> mine doesn't free
09:59:34 <tombert> *freeze
09:59:46 <maerwald> well, with arch you always get the latest bugs :P
09:59:55 <aspidites> and it's only some packages - it feels like a resource issue, but monitoring said resources doesn't reveal anything
09:59:57 <tombert> It's a feature :D
10:00:04 <naudiz> that's why you should use Gentoo ;)
10:00:14 <aspidites> maerwald: except i'm using stable packages and using cabal
10:00:21 <aspidites> so if something is unstable, its hackage ;-)
10:00:24 <tombert> Pssh, arch is the best; until I can get a LFS setup going, arch is good
10:00:45 <aspidites> gentoo i've tried -- portage is a mess
10:00:48 <maerwald> naudiz: why would I want to use a broken package manager :P
10:00:57 <maerwald> aspidites: exactly
10:01:20 <naudiz> it's not broken only because you can't get used to it ;)
10:01:39 <aspidites> use flags are cool though
10:01:40 <maerwald> naudiz: I'm developing gentoo, so I am pretty used to it
10:01:57 <aspidites> exherbo was the closest to a gentoo-like distro i enjoyed. just far too immature
10:02:10 <moshiMoshi> Hello, can anyone help me with a piece of parapell code I'm trying to implement?
10:02:12 <maerwald> aspidites: yep, I use gentoo with paludis atm, but it's still a mess
10:02:37 <maerwald> some people are working on pkgcore, but not sure if that will bring us salvation
10:02:43 <aspidites> that said, i was able to build packages using nix, though i think they hav a binary cache, yeah?
10:03:02 * aspidites googles pkgcore
10:03:10 <athan> ski: I think I can make the evaluator correct by making η-reduction stateful
10:03:19 <athan> or, dependent on an implicit state
10:04:03 <aspidites> funny enough, packages seem newer in arch than gentoo, which is what made me switch back -- having a central repo (aur), versus pile upon pile of overlay just seemed...cleaner
10:04:25 <maerwald> aspidites: AUR is dangerous imo, but well...
10:04:41 <aspidites> maerwald: so are overlays
10:04:47 <maerwald> aspidites: not always, no...
10:05:00 <maerwald> e.g. if you know a certain group of people are maintainers of an overlay
10:05:06 <maerwald> AUR there are no groups or whatever
10:05:10 <maerwald> it's just a huge pile of stuff
10:05:12 <aspidites> that said, i generally inspect a package before building it. 
10:05:29 <fishburne529> what is a good haskell library for talking to a postgresql database? I am currently trying out postgresql-simple. Should I stick to it?
10:05:35 <aspidites> maybe i'll try funtoo again (gentoo but a git based portage, right?)
10:05:41 <maerwald> developer overlays are safe for example... you can "whitelist" them... have fun whitelisting packages from individual authors on AUR
10:05:43 <aspidites> fishburne529: simple-postgres
10:05:50 <aspidites> er... postgres-simple, my bad
10:05:55 * joeyh is looking for an ipv6 capable getHostByName
10:06:15 <fishburne529> aspidites, is it same as postgresql-simple?
10:06:32 <aspidites> fishburne529: thats the package i meant (see correction above :P)
10:07:03 <aspidites> depending on what you want to do and how much abstraction you need, theres also opaleye and persistent
10:07:20 <aspidites> there are a few others, but those seem to be the most prominent from what I can tell
10:08:48 <joeyh> hmm, I suppose getNameInfo is what I seek
10:09:56 <fishburne529> aspidites, yes. I am new to haskell. So I am not sure how much abstraction I can handle right now. I had been going in circles for two days trying to retrive data from a query using postgresql-simple...
10:11:07 <aspidites> fishburne529: https://ocharles.org.uk/blog/posts/2012-12-03-postgresql-simple.html
10:11:08 <fishburne529> anyway..babysteps.
10:11:21 <aspidites> ocharles tends to have helpful short articles
10:11:35 <fishburne529> aspidites, that is the post that finally helped me to get it working...
10:11:41 <aspidites> ah
10:13:02 <fishburne529> aspidites, any idea regarding how the return value of fromRow function might be used by the query_function?
10:13:39 <aspidites> off the top of my head, no. Not really used the library (the database i was looking into interfacing was mysql :-("
10:13:55 <aspidites> seems to be a lot of documentation though. Wonder if anything obvious turns up
10:14:03 * aspidites read postgres-simple docu
10:14:05 <hsyl20> SrPx: i have updated the FFI page on the wiki to explain structure alignment. I hope it will be helpful to others: https://wiki.haskell.org/Foreign_Function_Interface#The_explicit_way
10:14:40 <SrPx> It will, thank you! hsyl20 
10:15:00 <aspidites> fishburne529: can you use applicative to destructure the results into a data type?
10:15:03 <crough> Hey all, is there any way to change my maintainer email on Hackage?
10:15:11 <aspidites> fishburne529: https://hackage.haskell.org/package/postgresql-simple-0.4.10.0/docs/Database-PostgreSQL-Simple.html
10:15:21 <mpickering> crough: Ask in #hackage there isn't a way via the ui
10:15:32 <crough> Thanks mpickering
10:15:54 <aspidites> that is, if you have a FromRow instance and a datatype, can you just "Constructor <$> field <*> field <*>.." for however many fields you have?
10:16:29 <fishburne529> aspidites, yes
10:16:36 <SrPx> Someone might also update https://hackage.haskell.org/package/base-4.2.0.0/docs/Foreign-Storable.html
10:16:40 <SrPx> The documentation is: alignment :: a -> Int	Source Computes the alignment constraint of the argument. An alignment constraint x is fulfilled by any address divisible by x. The value of the argument is not used.
10:17:08 <ph88> is there an easier way to initialize an array than this?       :m Data.Array.CArray      listArray (0,3) [2,4,5,6,8,9] :: CArray Int Int
10:17:09 <SrPx> That doesn't explain what alignment is at all... sadly.
10:17:11 <aspidites> oh wait..you were wanting to pass that along to a query
10:17:58 <fishburne529> aspidites, the result is the data type wrapped in a FromRow type. I want to know how the query_ function might be using it to fill it with actual values read from the database.
10:19:08 <aspidites> ah. afraid i'm usless in that regard. :-\ sorry.
10:19:51 <hexagoxel> aspidites: regarding cabal-reported versions: cabal does not use the Cabal library from your package db. cabal reports what it was _compiled_ with.
10:20:28 <aspidites> hexagoxel: thanks. I found that out a while ago. Should have said something. Unfortunately, recompiling with the newer version (using constraint=), I crash my entire computer
10:20:32 <ReinH> hexagoxel: except when it does
10:20:44 <fishburne529> aspidites, No problem.
10:22:07 * hackagebot uri-bytestring 0.1.2 - Haskell URI parsing as ByteStrings  http://hackage.haskell.org/package/uri-bytestring-0.1.2 (MichaelXavier)
10:22:33 <ReinH> SrPx: alignment is putting a structure in memory starting at some location that is a multiple of word-size
10:23:33 <ReinH> unaligned data requires extra reads
10:23:47 <ReinH> See http://en.wikipedia.org/wiki/Data_structure_alignment and http://www.catb.org/esr/structure-packing/
10:23:48 <hsyl20> ph88: it depends. You can also initialize from a ByteString: http://hackage.haskell.org/package/carray-0.1.5.2/docs/Data-Array-CArray.html#g:11
10:24:41 <ReinH> I'm not sure how structure packing is a "lost art"... it's just bin packing... but whatever
10:25:47 <SrPx> yep, it would be good if that was on the doc more precisely. I assumed it was stored like [Word16|Word16|Int|Int|Int|Int|Char] ... so alignment = total size = 7 bytes. I see now it is actually like [Word16|Word16|_|_|Int|Int|Int|Int|Char|_|_|_]. So, alignment = max field size = 4
10:26:22 <SrPx> (right?)
10:27:07 <SrPx> (each slot represents a byte there)
10:27:53 <hsyl20> yes it is right
10:29:04 <hexagoxel> ReinH: was i imprecise?
10:29:16 <ReinH> hexagoxel: No, you just didn't know about a cabal bug :)
10:29:36 <ReinH> cabal test checks the version of Cabal available in scope, so either user db or sandbox
10:29:46 <ReinH> and fails if it is different from the version compiled into cabal-install
10:29:55 <ReinH> Why does it do this? I don't know.
10:30:13 <SrPx> cool (:
10:31:48 <hexagoxel> ReinH: Ah, i think because the tests depend on Cabal and stuff breaks when you try to read the package config with the wrong version..
10:33:11 <hexagoxel> (exitcode-stdio depends on Cabal iirc)
10:34:51 <ReinH> hexagoxel: But it needn't.
10:35:22 <naudiz> hey, I've got lots of data for a number of timesteps. what's the best way to store and read this data?
10:35:44 <ReinH> naudiz: it depends!
10:36:29 <naudiz> ReinH: I want to save and read the data per timestep. each timestep is a huge n×m matrix
10:36:47 <ReinH> it still depends! :D
10:36:52 <naudiz> on what?
10:37:07 <ReinH> usage patterns, for example
10:37:36 <naudiz> it's mostly for plotting
10:39:17 <naudiz> at the moment I'm saving the 1D-Data (each timestap is an Array) in an [[a]] pattern and read it with read which seems to be very inefficient
10:40:07 <mjrosenb> gah, the type of foldlM is wrong :-(
10:40:10 <nolrai66> God I am over thinking this.
10:40:37 <nolrai66> I just want to implement a quick untyped lambda calc, and I keep wanting to use free functors or something..
10:40:40 <ReinH> naudiz: array of arrays? vector of arrays? map of maps?
10:41:09 <naudiz> ReinH: the 1D-Data is [Array Int a], the 2D-Data is [Array (Int,Int) a]
10:41:18 <SrPx> I don't understand why we need to use CFloat/CInt. Why not just have the storable classes for Float/Int do the conversion?
10:41:44 <nolrai66> naudiz: Why a list of Arrays?
10:43:26 <naudiz> nolrai66: the list stores timesteps and doesn't have a specific size. Also, since time only goes forward, I want to traverse timesteps from head to tail, so a list seems to be the best type
10:44:15 <naudiz> nolrai66: the timesteps on the other hand need random access and are equally sized
10:46:26 <naudiz> basically, what I want is an efficient way to read one timestep, plot it, read the next one, plot it, and so on
10:47:47 <naudiz> so I'll have to choose a storage format and an efficient parser implementation that allows me to read one timestep at a time... I'm really lost
10:48:59 <ph88> hsyl20: can you give me an example from byte string ?
10:50:21 <hsyl20> SrPx: Int is "at least 30 bits", CInt is "at least 16 bits". Use Int8, Int16, etc. (and Word8, Word16, etc.) from Data.Int and Data.Word to have fixed sizes
10:51:25 <mjrosenb> I uhhhh...
10:51:29 <mjrosenb> accidentally foldl
10:51:40 <hsyl20> ph88: it depends where you get you input data from. If you want to write them explicitly in the source, then listArray is probably the simplest way
10:55:25 <ReinH> naudiz: see, this is why we can't recommend a data structure without knowing more info ;)
10:56:54 <naudiz> ReinH: it actually isn't about the data structure, I need help choosing an IO format and a simple but effective parser library :/
10:57:04 <kirill`> Are MVar operations ordered w.r.t. IORef operations? If I write to an MVar, are previous IORef writes guaranteed to be visible to a thread that reads the new MVar value?
11:01:38 <ReinH> naudiz: er, why didn't you ask for tht then? :p
11:01:49 <ReinH> naudiz: if the format is predictable, try attoparsec
11:01:58 <ReinH> not sure what you mean by "IO format"
11:02:32 <ReinH> You can also use the parsers library to write a parser that abstracts over your choice of underlying implementation
11:02:34 <ReinH> @hackage parsers
11:02:34 <lambdabot> http://hackage.haskell.org/package/parsers
11:02:36 <ReinH> it's quite nice
11:02:49 <naudiz> ReinH: sorry, maybe I didn't explain it well... I want to write my data into a file to read and plot it later
11:03:17 <naudiz> ReinH: but the implementation I used so far is way to inefficient
11:03:29 <ReinH> Or, if you just want to serialize/deserialize your own strucrure, use binary
11:03:31 <ReinH> @hoogle binary
11:03:32 <ph88> ok thx hsyl20 
11:03:32 <lambdabot> package binary
11:03:32 <lambdabot> package binary-bits
11:03:32 <lambdabot> package binary-communicator
11:03:34 <ReinH> sorry
11:03:37 <ReinH> @hackage binary
11:03:37 <lambdabot> http://hackage.haskell.org/package/binary
11:03:50 <ReinH> and write a Binary instance
11:04:23 <ReinH> or alternatively use json and write ToJSON/FromJSON instances with aeson
11:04:32 <ph88> hsyl20: do you know if it's required to have CArray with 2 types behind it? one for the index and one for the data ?
11:04:42 <naudiz> ReinH: wouldn't JSON just blow it up even more?
11:04:53 <ReinH> yes
11:05:01 <ReinH> if you want it to be efficient, use a binary format
11:05:18 <ReinH> just providing some options
11:06:23 <naudiz> ReinH: thanks but it doesn't really help me :/ as I said, I'm pretty lost and don't know where to start. I always struggled with parsers
11:11:52 <mjrosenb> function composition isn't really a monad, is it :-/
11:15:07 <joris-r> Hi, I have a problem with my parser done with Parsec. I would enjoy to hear some ideas about that, if you will
11:15:07 <ReinH> Monoid when restricted to a -> a
11:15:55 <Cale> mjrosenb: Usually when you say something is a monad, you are referring to the type constructor
11:16:08 <Cale> mjrosenb: So function composition isn't the right sort of thing to be a monad.
11:16:30 <mjrosenb> Cale: ok, function composition isn't a bind operator for a monad.
11:16:54 <nshepperd> the identity monad maybe
11:16:59 <Cale> mjrosenb: For any type e, the type constructor (->) e is a functor, and function composition is the fmap for that functor.
11:17:00 <nshepperd> functions form a category with composition
11:17:19 <Cale> (not the bind)
11:17:21 <ReinH> Wrong type to be bind
11:17:56 <joris-r> I wrote that : https://github.com/joris-r/labaskel/blob/master/Parsing.hs and I'm quite happy except for the parsing of operator. I used the LanguageDef thing but that fact it accept any composition of operator character is annoying
11:18:13 <Cale> In particular, if we specialise the type of fmap :: (Functor f) => (a -> b) -> f a -> f b by plugging in f x = e -> x, then we get  fmap :: (a -> b) -> (e -> a) -> (e -> b), which is exactly the type of function composition.
11:18:26 <Lolo> i have a problem 
11:18:48 <Lolo> i hace installed and i set the path for ghci in bash 
11:18:54 <joris-r> I'm not able to parse thing like "2+-2", in fact I would prefer a simpler definition where I give the list of operator and that it
11:18:57 <mjrosenb> Cale: right, but you can't combine (->) Int with (->) Bool
11:19:01 <Lolo> but  every time i need to set it again 
11:19:12 <ReinH> Cale: is there a name for the (sub)category that is the image of (e ->)?
11:19:13 <joris-r> (like for keyword in fact) any idea how to do that ?
11:19:24 <Cale> mjrosenb: Depends on what you mean by "combine"
11:19:38 <Lolo> i would like to open the terminal and not need to repath bash to ghci 
11:19:47 <Cale> ReinH: I don't think so...
11:21:10 <mjrosenb> so I have a *large* number of functions with the type a -> (b->IO c) -> IO c, and I want to compose them (preferably using do-notation)
11:21:52 <ReinH> Are you sure that's the type?
11:21:59 <Cale> Lolo: I'm not certain I understand your question. You installed ghci to some location which isn't in your PATH and you want to make that location be in your PATH environment variable all the time? Perhaps edit your ~/.profile to include a line which adds it?
11:22:39 <Cale> mjrosenb: Could you give some examples of these?
11:22:47 <ReinH> Because I'm pretty sure that type has no interesting inhabitants.
11:22:50 <Cale> mjrosenb: and how exactly you intend to compose them?
11:22:56 <nolrai66> mjrosenb: If I understand you right you want ReaderT (a, b) IO.
11:23:01 <Cale> I don't think he means for a, b, c to be type variables
11:23:18 <Lolo> Cale: what i nee to put in .profile ?
11:23:24 <mjrosenb> Cale: I do.
11:23:54 <ReinH> I would accept *an* inhabitant of that type...
11:24:19 <zed_> hi everyone : ) so i'm writing a simple function to compute the pdf of a binomial distribution, and i am struggling with type classes... namely, what signature should be the following functions ? http://paste.ofcode.org/fDGkr7FGdsw6hYyGYVx4wR
11:24:25 <nolrai66> ReinH: see what Cale said.
11:24:26 <Cale> Lolo: If there isn't already a line there which adds stuff to your path... perhaps something like  PATH="/path/to/where/ghci/is:$PATH"
11:25:12 <ReinH> Well, I suppose there are a variety of inhabitants that ignore their arguments and construct an IO c using forever
11:25:32 <Cale> Lolo: That file is executed when you log in, so you may need to log out and back in again for the change to take effect
11:25:35 <ReinH> But they are not composable
11:25:59 <Cale> ReinH: For specific concrete types a, b, c, there are lots of those.
11:26:02 <ReinH> nolrai66: ?
11:26:47 <ReinH> Right, but they are type variables.
11:27:19 <ReinH> :t forever
11:27:19 <Cale> That's what I said, I don't think they're intended as such
11:27:20 <lambdabot> Monad m => m a -> m b
11:27:41 <ReinH> Lets me construct an IO c from whole cloth
11:27:47 <Cale> I believe mjrosenb means that for various types a, b, and c, he has many functions whose type has that shape
11:27:55 <ReinH> He said they are though
11:28:09 <Cale> Er, hmm
11:28:22 <Cale> mjrosenb: Could you give some examples of the functions you're talking about?
11:28:27 <mjrosenb> Cale: nolrai66: this is the code, I have do's and lambdas nested like 6 levels deep: https://gist.github.com/1b1741502b6f419f68b8
11:28:58 <Cale> ah, right
11:29:09 <Cale> This is pretty much the sort of thing that Cont is made for.
11:29:10 <mjrosenb> I feel like I should be able to lift the normal IO operations, and change all of the withFoo foo (\x... into x <- withFoo foo
11:29:31 <mjrosenb> ok, I was looking at Cont, and couldn't figure out how to do that.
11:29:34 <Cale> The indentation in that code is a bit off...
11:29:46 <mjrosenb> Cale: I'm still writing it
11:30:07 <Cale> :t Foreign.Marshal.Alloc.allocaBytes
11:30:08 <lambdabot> Int -> (GHC.Ptr.Ptr a -> IO b) -> IO b
11:30:21 <Cale> :t Foreign.Marshal.Alloc.allocaBytes 5
11:30:22 <lambdabot> (GHC.Ptr.Ptr a -> IO b) -> IO b
11:30:26 <Cale> :t cont (Foreign.Marshal.Alloc.allocaBytes 5)
11:30:29 <lambdabot> Cont (IO b) (GHC.Ptr.Ptr a)
11:30:39 <Cale> :t ContT (Foreign.Marshal.Alloc.allocaBytes 5)
11:30:41 <lambdabot> ContT r IO (GHC.Ptr.Ptr a)
11:30:51 <Cale> ^^ check that out :)
11:32:11 <Cale> Basically, you can think of Cont/ContT as allowing you to compose many with*-style functions
11:32:19 <ReinH> oh right, you can do all manner of cheating with IO, I forget. ;)
11:32:28 <Cale> No cheaterinoes
11:32:36 <mjrosenb> Cale: that is what I thought.
11:33:47 <Cale> :t runCont . sequence . map cont
11:33:48 <lambdabot> [(a -> r) -> r] -> ([a] -> r) -> r
11:34:20 <ReinH> From a falsehood comes many falsehoods? ;)
11:34:21 <Cale> ^ take a list of withFoo-style functions, apply a function to the list of results
11:34:57 <nolrai66> Cont still hurts my brain.
11:35:05 <ski> zed_ : use  `div`  instead of  /
11:35:14 <Cale> nolrai66: Oh, that never really goes away :D
11:35:25 <ReinH> Indeed
11:35:42 <zed_> ski: i don't want it to be rounded...
11:35:49 <orion> Does anyone know why haddock fails to parse this file?: http://lpaste.net/868669818654425088
11:36:02 <ski> zed_ : in this case, the remainder will be zero anyway, so it doesn't matter
11:36:07 <ski> (because of math)
11:36:21 <Cale> :t runContT . sequence . map ContT -- similar
11:36:22 <lambdabot> [(a -> m r) -> m r] -> ([a] -> m r) -> m r
11:37:13 <Cale> :t (runContT . sequence . map ContT) (replicate 10 (allocaBytes 8))
11:37:15 <lambdabot> Not in scope: ‘allocaBytes’
11:37:23 <Cale> :t (runContT . sequence . map ContT) (replicate 10 (Foreign.Marshal.Alloc.allocaBytes 8))
11:37:24 <lambdabot> ([GHC.Ptr.Ptr a] -> IO r) -> IO r
11:37:24 <ski> zed_ : if you insist on getting a `Double' back, use `fromIntegral' to convert to that, from `Int'
11:37:39 <ski> (then you can use `/' on `Double's ..)
11:38:08 <zed_> ski: thanks : )
11:38:25 <ski> zed_ : however, `div' really is the right thing here, imho
11:38:47 <ReinH> nolrai66: The main thing that helped me understand Cont was:
11:39:06 <ReinH> > :t flip ($)
11:39:08 <lambdabot>  <hint>:1:1: parse error on input ‘:’
11:39:12 <ReinH> Woops
11:39:24 <ReinH> :t ($ 1)
11:39:25 <lambdabot> Num a => (a -> b) -> b
11:39:35 <ReinH> Is the type of Cont
11:39:40 * ski understood it partially by reading about the CPS-transform(s)
11:39:53 <ReinH> (Specialized a bit)
11:39:58 <ski> @type Cont . flip ($)
11:39:59 <lambdabot>     Not in scope: data constructor ‘Cont’
11:39:59 <lambdabot>     Perhaps you meant one of these:
11:39:59 <lambdabot>       ‘Cons’ (line 142), ‘Const’ (imported from Control.Lens),
11:40:06 <ski> @type cont . flip ($)
11:40:06 <lambdabot> a -> Cont r a
11:40:11 <ReinH> Indeed
11:40:45 <ReinH> Then the only problem is figuring out how it's a monad ;)
11:41:02 <ReinH> But iirc djinn can show you
11:41:34 <ReinH> The other thing that helped, more recently, was figuring out how to construct Cont from an adjunction
11:42:48 <nolrai66> Hey are any of those define parsing and printing at the same time libraryies on hackage?
11:43:47 <ReinH> @google Haskell invertible parsing
11:43:49 <lambdabot> https://hackage.haskell.org/package/boomerang
11:44:06 <ReinH> I think chrisdone also has something for that
11:44:29 <ReinH> @hackage digestive
11:44:29 <lambdabot> http://hackage.haskell.org/package/digestive
11:44:42 <ReinH> Nope
11:45:09 <ski> ReinH : it's easy, just follow the types :)
11:48:57 <ReinH> ski: of course. I guess I should have said *using* the monad instance.
11:49:05 <ReinH> Or understanding its meaning
11:49:53 <ReinH> @unmtl Cont r a
11:49:53 <lambdabot> (a -> r) -> r
11:50:41 <ReinH> One interesting thing is that a is in "double negated" positive position.
11:55:07 <ReinH> So then you get into what kind of double negation is going on in haskell's type system.
11:55:25 <ReinH> (See: http://polaro.blogspot.com/2010/05/five-kinds-of-double-negation.html?m=1)
12:00:50 <greymalkin> I've just started using the emacs interactive mode -- how do I go back and execute a command I tried before?
12:10:56 <lpsmith> Hmm, is there a way to do type-level functions,   something like say   newtype Foo (a -> a) a =  Foo a,    then define something such as   Foo 5 :: Foo (+ 4) Int ? 
12:11:33 <haskets> I want to interface with convnetjs from haskell using reflex and reflex-dom. Is this possible/worth doing?
12:16:30 <nolrai66> lpsmith: type families.
12:24:26 <Cale> haskets: You should ask in #reflex-frp
12:25:27 <Cale> haskets: It generally ought to be possible to interface with Javascript libraries via FFI, and then build FRP wrappers around them. I don't know anything about the particulars of convnetjs though.
12:27:14 * hackagebot second-transfer 0.5.3.1 - Second Transfer HTTP/2 web server  http://hackage.haskell.org/package/second-transfer-0.5.3.1 (dsign)
12:27:55 <haskets> Cale: thanks!
12:33:50 <nolrai66> Function application is /left/ associative right?
12:36:17 <MitchellSalad> yeah
12:36:29 <rvxi> hey
12:39:29 <rvxi> dumb question, every project should have its own cabal sandbox right?
12:41:59 <hexagoxel> rvxi: the more sandboxes, the lower the risk of dependency conflicts of any sort, and the higher the (unnecessary) compile-times
12:42:02 <indiagreen> rvxi: not necessarily, you can share a sandbox between several projects if they're e.g. related
12:42:25 <rvxi> so is the standard thing to do
12:42:29 <rvxi> make a project directory
12:42:32 <rvxi> go into project directory
12:42:32 <hexagoxel> for a set of closely related projects with the same set of dependencies you may prefer a shared sandbox
12:42:38 <rvxi> cabal init sandbox
12:43:04 <rvxi> i mean
12:43:08 <rvxi> cabal sandbox init
12:43:08 <rvxi> then
12:43:12 <rvxi> cabal init <projname>
12:43:21 <hexagoxel> for me personally, yes, that is the standard
12:43:42 <rvxi> how do you share a sandbox if the projects are in different directories
12:43:43 <rvxi> ?
12:44:18 <hexagoxel> you can put `require-sandbox: True` into your ~/.cabal/config if you want cabal stopping you from ever installing without a sandbox
12:45:03 <rvxi> also doesn't this make for a lot of time every new project for things like yesod which have dependencies up the wazoo? not to mention eating up bits of hd space here and there
12:45:12 <hexagoxel> rvxi: see "advanced usage" on https://www.haskell.org/cabal/users-guide/installing-packages.html
12:45:24 <rvxi> i mean installing all the yesod dependencies from scratch takes like 20 mins or something from what i remember..
12:45:24 <hexagoxel> or ctrl-f "shared"
12:45:56 <lpsmith> nolrai66, I don't think that works,  what I really need is function promotion,  so something more like  newtype Foo (b :: a -> a) (a :: *) = Foo a
12:47:19 <hexagoxel> rvxi: stackage or nixos are other approaches to prevent dependency conflicts while not incurring so much recompilation
12:47:43 <hexagoxel> but there is not globally agreed standard
12:47:44 <rvxi> stackage is too out of date for my taste though
12:48:26 <rvxi> hexa: thanks init with a shared sandbox is right up my alley since I've been using a single super-sandbox and I'm pointing everything too  ...
12:49:25 <rvxi> i've heard a lot about nix, but i don't really understand. it's a full OS?
12:49:25 <lpsmith> specifically, what I want to do is something like this:    newtype ArbEq (eq :: a -> a -> Bool) (a :: *) = ArbEq a    ;  instance Eq (ArbEq eq a) where (==) = eq
12:49:44 <rvxi> i can't really wipe my hd and install (using a company macbook air)
12:51:02 <lpsmith> Then to be able to calculate things such as     ArbEq 2 :: ArbEq ((==) `on` (`mod` 4)) Integer == ArbEq 6
12:54:19 <hexagoxel> rvxi: i don't really know about nix. i think you can use it without the os-part
12:54:44 <rvxi> kind of confusing when a sandbox location needs the root vs. .cabal-sadnbox vs. .caba-sandbox/x86_...
12:55:03 <rvxi> hexagoxel: that's what it sounds like when people talk about it
12:55:09 <rvxi> but the description is really confusing
12:55:48 <zed_> hi again : ) what would be a good way to re-write this C code in Haskell ? i'm trying to find a basic example of a while loop online but it has proven more troublesome than expected... http://paste.ofcode.org/eK66QrD5HMeCFfiGs8npQe
12:57:15 <haskets> zed_: Depends what you're trying to do with a while loop
12:58:47 <ChristianS> > sum [1..4]
12:58:48 <lambdabot>  10
12:58:53 <ChristianS> zed_: ^^
12:59:01 <haskets> If you're just trying to do that code ChristianS just showed how
12:59:07 <rvxi> more succinctly
12:59:08 <zed_> haskets: my end point is calculating the value at risk 
12:59:14 <rvxi> sum15 = 10
12:59:18 <rvxi> heh
13:02:04 <zed_> i'm trying to break my problem in smaller pieces
13:02:04 <rvxi> noob recursion version
13:02:04 <haskets> zed_: What do you mean by "value at risk?"
13:02:04 <zed_> haskets: it's a financial concept
13:02:04 <rvxi> sumToN 0 = 0
13:02:04 <rvxi> sumToN n = n + sumToN (n - 1)
13:02:04 <rvxi> sumLT5 = sumToN (5 - 1)
13:02:04 <rvxi> bit silly... but how's that?
13:02:04 <zed_> haskets: if you say " there's a 5% chance that we lose 20$ on that bet or more", then the value at risk is 20$
13:02:04 * frerich wonders whether people noticed that zed_'s code doesn't attempt to compute the sum of 1..5 but rather counts up to 5.
13:02:04 <zed_> so my sub-example of a while loop is really about how to write a while loop, and not about how to count up to five : )
13:02:13 <haskets> zed_: hmm okay so what's the calculation. Basically, what do you want the input of the function and output to be?
13:02:33 <init> zed_: the easiest way to write a while loop in haskell is to don't even try to do that
13:02:45 <zed_> init: ahah
13:03:13 <rvxi> zed: my example is one way to do the while loop
13:03:33 <zed_> haskets: i want to input a certain level of confidence (alpha), plus the inputs for a binomial pdf
13:03:51 <rvxi> there's not a completely generic while loop equivalent. i would reframe it as, what calculation is your while loop intended to do?
13:04:04 <haskets> rvxi: yeah I exactly agree
13:04:06 <init> zed_: you normall ask yourself a few extra questio, what am I doing with every element on the intput? do I keep `accumulating` values? do I `skip` some values there?  
13:04:09 <frerich> zed_: I think you might be much closer to a functional definition if you could re-write your loop to a recursive version. E.g. 'int sum = f( 0 );' with 'int f( int x ) { return x < 5 ? f( x + 1) : x; }'
13:04:15 <rvxi> zed: and what's the output?
13:04:29 <rvxi> btw i'm doing monte carlo and various modeling things in haskell
13:04:30 <zed_> frerich: i think you are onto something
13:04:33 <rvxi> (although i am a haskell noob)
13:04:47 <init> zed_: there are then, functions that abstract some patterns, like map, filter, foldr, foldl
13:04:54 <zed_> rvxi: the output is suppose to be the point where you stopped
13:05:05 <zed_> i can give you the original C code, it might make it clearer
13:05:20 <haskets> zed_: That would be perfect. 
13:05:21 <rvxi> zed: i wrote the recursive version of frerich's function above.
13:05:26 <haskets> zed_: Paste it in somewhere
13:05:55 <init> frerich: that function is missing the x +, I think
13:06:01 <maerwald> https://hackage.haskell.org/package/loop-while
13:06:24 <frerich> init: My function is exactly the translation of what zed_ posted, it's not a sum [1..5] (which for some reason everyone seems to talk about)
13:06:38 <rvxi> maerwald: baed on the name of the package that sounds like a terrible idea :P
13:06:44 <zed_> here is the original code : http://paste.ofcode.org/5Rw6B6KMPw7G3VMVpNzZtH
13:07:00 <maerwald> rvxi: ?
13:07:10 <rvxi> loop-while package?
13:07:18 <rvxi> btw
13:07:25 <zed_> although I want a "lean" version of it, i.e. one that just calculates the VaRff1 ( sorry for such horrible names for variables, it had to be put in context )
13:07:25 <rvxi> you know haskell has some decent gsl bindings?
13:07:38 <rvxi> i've been playing with gsl in haskell
13:07:52 <rvxi> there are gaps but it's usable
13:07:57 <zed_> rvxi: yeah I know, but I was told to do my best to actually learn haskell and not just use the bindings, for performance I think ? I am really a beginner in all of these things : )
13:09:27 <rvxi> eesh
13:09:33 <rvxi> is this doing a cdf by hand?
13:09:40 <haskets> zed_: take a look at the statistics package. I'll try to rewrite the code really quickly for you also, but that code is pretty horrible lol
13:10:01 <zed_> haskets: ahah I know, I am not a programmer, plus it was one of my first code in C
13:10:19 <rvxi> if you're tallying up a cdf i would use builtin cdf functions
13:10:28 <haskets> zed_: not that it doesn't do great stuff, but the variable names are quite gross lol
13:11:03 <zed_> haskets: yeah I should have took 10 min to rewrite that before posting - but, alas.
13:11:26 <rvxi> i wouldn't try to learn C and gsl and haskell at the same time
13:11:31 <rvxi> pick one and spend some time with it
13:11:44 <init> zed_: pO->ESff1 = ESff1; ? 
13:11:47 <init> zed_: what's p0?
13:11:50 <maerwald> @let while = until . (not .)
13:11:52 <lambdabot>  Defined.
13:11:54 <rvxi> are you working in finance?
13:12:01 <maerwald> > while (< 500) (\x -> x + 1) 3
13:12:03 <lambdabot>  500
13:12:28 <zed_> rvxi: maybe one day - still a student
13:13:07 <zed_> init: it's an instance of a structure named Output, that is used in the rest of the program
13:13:10 <haskets> zed_: Okay so check out the statistics package, and learn a little about monads
13:13:16 <rvxi> if you don't already know C, I'd recommend focusing on either C or haskell.
13:13:45 <zed_> rvxi: I know a bit of C, but I wanted to know enough about haskell/functional programming to be able to argue about the choice of languages and all : )
13:13:46 <rvxi> haskets: are you talking about base stats? i remember it looking kind of bare
13:13:53 <init> zed_: a global variable, apparently, no? 
13:14:00 <rvxi> with respect to coverage of even standard distributions
13:14:09 <haskets> I was thinking https://hackage.haskell.org/package/statistics-0.10.4.1
13:14:40 <haskets> Bryan O'Sullivan is also a boss, which makes it fun to look at his code
13:15:17 <zed_> init: Yeah, I know we shouldn't use that, but we had to puzzle together different parts of code in a single program quickly, so yeah
13:15:19 <rvxi> haskets: i remember running into limitations with that although i don't remember what exactly
13:15:24 <hpc> haskets: no, he's bos silly ;)
13:15:36 <haskets> hpc: lolol
13:15:40 <rvxi> i've been poking around stats/monte carlo in haskell and haven't found a perfect solution yet
13:15:42 <Clint> who's the bos
13:15:45 <zed_> haskets: a boss as in "he's good", or as in "actual boss"
13:16:00 <haskets> rvxi: Yeah there may be some, I haven't used it much except for simple things
13:16:10 <haskets> zed_: he's a brilliant haskell programmer
13:16:18 <rvxi> hmatrix-gsl-stats had kind of a big gap with its rng support
13:16:34 <rvxi> gsl-random is incomplete
13:16:56 <haskets> rvxi: What about monte-carlo package?
13:17:02 <rvxi> low level gsl bindings are slow as heck due to FFI
13:17:13 <rvxi> lacking unsafe
13:17:14 <zed_> rvxi: do you work in finance or something related ?
13:17:44 <rvxi> zed: doing modeling (bayesian statistical and mechanistic) in pharma
13:17:53 <rvxi> lots of overlapping statistics tools though
13:17:57 <zed_> i see
13:18:00 <rvxi> monte carlo simulation, MCMC, ODEs
13:18:18 <zed_> and you prefer haskell or you are learning for fun or... ?
13:18:29 <rvxi> i'm learning as a long term investment
13:18:40 <rvxi> day-to-day I use a combo of R and C++
13:18:50 <rvxi> I'm very productive in R, but I can see its limitations.
13:19:13 <rvxi> haskell for data analysis modeling, scientific computing is behind other languages in terms of library support
13:19:32 <zed_> as I thought
13:19:35 <maerwald> yeah, python is pretty strong there
13:19:36 <rvxi> but the language _should_ be capable of doing these things and doing them better than R
13:19:40 <haskets> rvxi: I think python is best right now for this kind of thing
13:19:45 <rvxi> it needs a critical mass of users
13:20:02 <haskets> rvxi: which I hate to say, as it's a horridly dynamically typed language
13:20:13 <rvxi> haskets: mostly, unless you're on the more statistical side of things. The norm is to release an R package with your paper in stats
13:20:19 <rvxi> ditto a lot of bioinformatics is in R
13:20:32 <rvxi> haskets: yeah, as is R. however they're very productive
13:20:41 <maerwald> I don't care if a language is dynamically or statically typed as long as I have compile-time type-safety
13:20:54 <haskets> rvxi: Much machine learning is in python nowadays. I use python for bioinformatics research. R is slow for larger datasets and the syntax is not well thought out
13:21:11 <rvxi> imo haskell could be _more_ productive in terms of being able to compose operations.
13:21:28 <rvxi> the potential is there, the userbase just has to catch up
13:21:31 <haskets> maerwald: there's no such thing as compile-time in interpreted languages... Which makes it much harder
13:21:57 <rvxi> haskets: i'm thinking about switching. i've done python, but i'm not super-productive. however, i'm putting my long-term investment in a combination of
13:22:05 <zed_> the thing with haskell is that i find it hard to learn how to structure a program or a piece of code i want to output
13:22:12 <rvxi> haskell for computation and javascript for front-end visualization
13:22:18 <maerwald> haskets: well, alternatively reliable static analysis tools
13:22:34 <rvxi> not a sure bet by any means, but i enjoy haskell so there's that.
13:22:45 <haskets> zed_: Haskell is very very good but requires a lot of up front time. The complexity of the programs in haskell is limited by the purity of most of the functions
13:23:00 <haskets> maerwald: python lacks those pretty heavily as well
13:23:03 <rvxi> haskets: R is a pita for large datasets despite constant "but package X sort of lets you do _something_ with large data sets"
13:23:38 <haskets> rvxi: Check out python, numpy, scipy, theano combo. That is the best imho for data science and simulations right now
13:23:47 <rvxi> i think there are some foundational problems with R. if it wasn't for the hadleyverse i might have abandoned it already
13:24:00 <kristof> rvxi: Foundational problems such as?
13:24:09 <haskets> rvxi: there's also pymc which is a package for mcmc simulations that's quite quite good
13:24:13 <kristof> I use it for very, very fast matrix multiplication
13:24:30 <zed_> kristof: which one ? python ?
13:24:33 <haskets> numpy is written using BLAS and LAPACK and is quite fast
13:24:34 <init> I just naively rewrote that loop 
13:24:39 <rvxi> kristof: well it is slow, the entire infrastructure centers around in-memory computation and doesn't scale well
13:24:44 <maerwald> haskets: yes and the problem of adding complexity to existing functions could also be a reason why haskell game development is stagnating... you have to know too much up-front
13:24:46 <kristof> rvxi: Ah, ok
13:24:53 <kristof> haskets: Well, so is R
13:25:12 <rvxi> kristof: it's got a bit of the matlab syndrome of "super productive if someone has already written it for you"
13:25:21 <rvxi> otherwise, sorta-shitty
13:25:26 <kristof> rvxi: The R language itself is kind of bonkers
13:25:28 <zed_> rvxi: haha at the matlab analogy
13:25:35 <rvxi> it has a few things gooing for it
13:25:38 <rvxi> the hadley-verse is great
13:25:44 <kristof> Only a few :)
13:25:56 <kristof> I guess I'm partial just because I've been using R for months
13:25:57 <haskets> kristof: Yes but the design choices in the language are much cleaner in python. Want to do general scripting along with machine learning? R is out. Want to write a script to preprocess messy data? It's a bitch in R. Etc Etc. 
13:26:02 <rvxi> the web-front-end shiny thing is the way of the future, but shiny isn't good enough
13:26:04 <haskets> They say python is a B+ at everything
13:26:09 <kristof> haskets: Right, ok
13:26:11 <rvxi> C++ interop with R is good with RCpp
13:26:18 <haskets> and I agree wholeheartedly with that
13:26:38 <rvxi> python seems not very concurrency-ready
13:26:50 <rvxi> haskets: preprocessing/data-munging is actually a joy with dplyr
13:26:53 <rvxi> if your data fits in-memory
13:26:57 <haskets> rvxi: Most of the backend is in C
13:27:04 <haskets> rvxi: And EXTREMELY concurrent
13:27:06 <rvxi> dplyr  actually very functional-esque
13:27:09 <haskets> at least for scientific python
13:27:17 <init> zed_: if the task would have been naively rewriting that loop, it'd have went with code like http://lpaste.net/133607 
13:27:20 <haskets> It also has closures, and lambdas
13:27:27 <haskets> Which makes it my language of choice
13:27:41 <rvxi> haskets: well there's the 2 language thing. fast if someone has written that functionality in C, but what if you need to write your own concurrent algorithm in python?
13:28:19 <haskets> rvxi: You rarely rarely need to. The FFI to C is incredible and the packages are insanely good. That's why python is leading in terms of datascience right now
13:28:33 <zed_> init: looking at it, it might take a while for me to understand it though : ) thanks !
13:29:04 <rvxi> haskets: it's not true that i rarely need to. i do...
13:29:17 <init> zed_: the core thing there is the `foldl`, for what it's worth
13:29:21 <haskets> rvxi: What's an example? 
13:29:25 <rvxi> i mean, there's a lot of 'data scientists' that are glorified package/library runners but that's not what i'm going for
13:29:39 <rvxi> because imo those roles are going to be very replaceable in about 5-8 years
13:29:53 <haskets> numpy provides pretty much every piece of functionality you'll need for math and linalg
13:30:07 <haskets> scipy as well
13:30:08 <rvxi> haskets: well say i want to implement a probabilistic ODE
13:30:52 <rvxi> or I want to run a bunch of replicates of custom monte carlo simulations
13:30:52 <haskets> rvxi: There's mcmc packages that let you write your code as a probabilistic program
13:31:23 <haskets> https://pymc-devs.github.io/pymc/
13:31:43 <rvxi> sure, but my point is not every piece of modeling i do is going to be mappable  to an existing library
13:31:44 <haskets> Again, python is B+ at everything
13:32:14 <rvxi> standard out-of-the-box MCMC methods don't always work well for ODEs. may need to use my own sampler.
13:32:39 <haskets> In python it pretty much is. I know it sounds like I'm a python lover, but not at all, and there are a ton of flaws. One thing that's amazing is the libraries available and the community
13:32:44 <rvxi> Hell Stan is supposed to be cutting edge and I managed to crash that with a 1 equation ODE
13:33:23 <haskets> Also there are efforts to make python multicore https://docs.python.org/dev/library/multiprocessing.html#module-multiprocessing.pool
13:33:36 <rvxi> haskets: i understand, and i get that that's a path to productivity that many are doing well with
13:34:20 <haskets> rvxi: And yeah, I was dissatisfied with many aspects of it, which is why I'm migrating to haskell
13:34:23 <rvxi> haskets: but it's not a path i want to go down because like i said, i think plugging in packages is going to be a very replaceable job in about 5 years
13:35:06 <haskets> rvxi: I disagree. I think the ability to know which models will work -> transitioning to production ready code -> deploying, is always something that will be needed
13:35:54 <rvxi> haskets: i'd bet that 95% of scikit learn users don't _really_ understand how many of the algorithms work at a deep level
13:36:06 <rvxi> they just look at cross validation, validation set error and call it a day
13:36:19 <rvxi> and for many business cases, that may be 80/20 good-enough.
13:36:29 <haskets> rvxi: If you just plug and chug, the results are going to pretty far from optimal. Try using a vanilla Feed forward neural net. Doesn't work too well unless you know about RELU, Initialization methods, Dropout, optimization techniques, etc
13:36:57 <init> you might like #haskell-blah :P 
13:37:18 * hackagebot ltext 0.0.0.2 - Higher-order file applicator  http://hackage.haskell.org/package/ltext-0.0.0.2 (athanclark)
13:37:20 * hackagebot lens-simple 0.1.0.0 - simplified import of essential lens combinators  http://hackage.haskell.org/package/lens-simple-0.1.0.0 (MichaelThompson)
13:37:31 <haskets> init: Yeah sorry, we're getting off track. I moved to haskell because I love the language and think that functional programming makes managing large codebases significantly easier
13:37:35 <rvxi> and for many large-scale "find the correlation" tasks things like http://www.automaticstatistician.com/ can probably do better than a lot of these folks running 100s of regressions
13:37:57 <init> haskets: most people here likes Haskell ;) 
13:38:21 <rvxi> haskets: btw what kind of bioinformatics work are you doing?
13:38:27 <haskets> rvxi: I know that site, but it doesn't provide even close to the results that I could get with tuned models. It's good for data exploration, but not for any kind of model that will do well in production
13:38:44 <haskets> rvxi: I'll private message since I don't wanna crowd haskell chat
13:38:50 <rvxi> sure
13:39:53 <init> nah, go to #haskell-blah, I like the discussion too :P
13:43:58 <haskets> init: I would but he's not there. The discussion has morphed anyways to a middle ground haha.
13:44:44 <haskets> Also, anyone here know of a good way of interfacing with protobuf from haskell? I'm trying to load caffe models (a neural net library) which uses protobuf, but the haskell packages are quite outdated for conversion
13:46:32 <nolrai66> If one is making a generator for passing into QuickCheck's sized, should the input be interpreted as an maximum or an exact?
13:48:39 <geekosaur> 4check the upstream, someone just took over maintainership of the protobuf bindings and is updating them
13:49:46 <Cale> nolrai66: I don't think there's any precise interpretation but something more like "maximum" I think.
13:50:08 <nolrai66> Hmm.
13:50:58 <zed_> haskets: you do neural networks ?
13:53:00 <zed_> init: i'm not sure to understand what the f is
13:53:56 <init> zed_: it's just a function that takes the "result" of the loop and does something with its values
14:22:14 <stoddart> hey
14:22:28 <dmj`> hey
14:31:18 <stoddart> ok
14:38:45 <begriffs> Getting a weird error with cabal update: "cabal: /home/build: failed" (using ghc 7.10, cabal 1.22). I'm on a new machine, and I've never seen this kind of error before.
14:40:09 <rvxi> anyone have thoughts on snap vs. yesod?
14:40:24 <gilligan_> bergey, what are you trying to do exactly? how do you call cabal ?
14:40:31 <dmj`> Any idea why my implementation of insertionSort with unboxed mutable arrays blocks on all unsorted lists ? http://lpaste.net/133610
14:40:50 <Zemyla> Hmm, a few Haskell questions about interfacing with external libraries.
14:41:47 <rvxi> yes?
14:42:04 <dmj`> rvxi: have you tried both?
14:42:16 <rvxi> dmj: only tried yesod thus far
14:42:45 <rvxi> it's been pretty smooth getting started
14:43:00 <rvxi> although i'll admit i have no clue what's going on under the hood with the template haskell and QQ magic
14:43:46 <Zemyla> If I write an interface to a library under the LGPL, is that interface library also under the LGPL?
14:49:54 <rvxi> yay first gloss example compiled
14:51:25 <nolrai66> Anyone have an idea what exit code -9 means?
14:52:44 <Pastaf> I have a type a, which can be a tuple of (a, a), or some other value. How can I check if the first element is of one possibility for a and get the first value, when it is in tuple form? Can I do this with patterns?
14:55:17 <mzero> Pastaf: what do you mean "can be a tuple"?
14:55:24 <mzero> if it *is* a tuple, getting fst is easy
14:55:45 <mzero> how can type a be either a tuple or some other value? Is this a polymorphic type on a function signature?
14:57:38 <geekosaur> nolrai66, in general exit codes have no meaning beyond zero/nonzero
14:58:02 <nolrai66> Pastaf: do you mean a "data MyType a = A (a,a) | B ..."
14:58:16 <nolrai66> quickcheck is crashing on me.
14:58:18 <nolrai66> sigh.
14:58:44 <Pastaf> nolrai66: Yes. I'm working on the example of what I mean, if you need more information.
14:58:47 <athan> nolrai66: Tell be about it :\
14:58:49 <athan> DTT ftw
14:59:05 <athan> (&&/|| liquid types)
14:59:12 <mzero> Pastaf: great - a pastbin example will help us greatly
14:59:22 <athan> nolrai66: Are you generating more test cases than your machine can handle?
14:59:29 <nolrai66> Maybe?
14:59:31 <Zemyla> And if it's a small library that isn't commonly installed on machines, should I just include the C and header files from the library into the package?
14:59:41 <athan> nolrai66: Does it make your machine crash?
14:59:54 <athan> (that's what happens to me pretty often)
14:59:57 <nolrai66> No just throws an exception.
15:00:01 <athan> oh hm
15:00:08 <nolrai66> WHich is ..weird frankly.
15:00:47 <ion> athan: If your machine crashes when you run QuickCheck properties, there’s something wrong with the machine. Have you tried memtest86+?
15:02:07 <Pastaf> nolrai66, mzero: http://pastebin.com/skXLf2TL
15:02:46 <mzero> oh
15:02:48 <mzero> that will work
15:02:52 <Pastaf> the first pattern in my example is not what I have, but something what it might be like
15:02:57 <mzero> but you'll need parens around (List (Lambd...)
15:03:30 <mzero> as an aside - there is no need for the parens in the List constructor
15:03:35 <Pastaf> wait, so I guessed right but just didn't have the parens?
15:03:38 <mzero>   | List LispVal LispVal    
15:03:40 <mzero> would be fine
15:03:47 <Pastaf> gotcha/
15:03:48 <mzero> yes
15:04:05 <c_wraith> lisp lists just being arbitrary pairs is a kind of dirty lisp secret
15:05:40 <trak404> hey guys. I'm trying to use some helper functions from my .hs in GHCi, but I can only access functions from the imported modules and the Main part. how can I use the ones defined in the file itself?
15:05:49 <functor> c_wraith: lisp has wired semantics sometimes.
15:07:15 <mzero> trak404:  you mean you have two .hs files, one :load and you want stuff in the other?
15:07:47 <mzero> you can bring it into scope with   :m + <module name>
15:08:09 <mzero> and bring it *all* (not just exports) into scope with    :m + *<module name>    (I think)
15:08:18 <functor> c_wraith: http://tinyurl.com/o674v2k
15:08:43 <trak404> mzero: let's suppose I have abc.hs. I use import on 1.hs and 2.hs. when I enter ghci abc.hs, I get to use the functions from 1.hs and 2.hs, but I can't access the one I've defined in abc.hs. not sure why though..
15:09:22 <mzero> ah
15:09:27 <mzero> run ghci - no args
15:09:31 <mzero> then :l abc.hs
15:09:40 <nolrai66> Is it exported from abc.hs?
15:10:18 <nolrai66> I might have to actually set up a virtual machine, fpcomplete is being weird.
15:11:11 <trak404> mzero: wow, that actually worked. why's that? I thought running ghci <haskell file> was the same as running ghci and then loading it afterwards
15:11:26 <nolrai66> @type QuickCheck.verboseCheck
15:11:28 <lambdabot> Not in scope: ‘QuickCheck.verboseCheck’
15:11:30 <frogmella> this will probably get me banned but oh well i need urgent help. Any programmers or designers want to help with https://www.criosphinx.net? Click on an add then e-mail me at dan@criosphinx.net to say you have, gotta pay you guys somehow eventually haha! awesome btw seo analyzer -> criosphinx.net/seo-checker
15:11:33 <mzero> I think putting the module on the command line is like  :m +   it
15:11:54 <trak404> mzero: the things is, it's not a module, lol
15:12:06 <trak404> thing*
15:12:15 <mzero> trak404: of course it is ---- code in Haskell is ALWAYS in a module
15:12:32 <mzero> even if you leave "module Foo" off at the top
15:12:38 <mzero> (it is in module Main!)
15:12:58 <trak404> mzero: exactly! that's why I could only access the Main module
15:13:05 <trak404> mzero: hence my problem, lol
15:13:48 <geekosaur> so you stuck utility functions in a module Main and now wonder why you can't use them
15:13:53 <mzero> did someone badn frogmella?
15:13:56 <mzero> er, ban
15:14:09 <trak404> mzero: gotta run. thanks :)
15:14:14 <mzero> welcome
15:18:49 <Pastaf> er, one other thing. I need a show instance for functions so that I can make my data type derive show, which IS important for everything else? It doesn
15:19:12 <Pastaf> t need to be informative, in fact, it can be meaningless or a blank string if needed.
15:19:49 <monochrom> do you want "instance Show (a -> b) where show = "" "?
15:20:08 <Pastaf> yes. let me see if that works for me, I tried that, but it didn't work...
15:23:26 <mzero> well - without getting into theoretics, no, you can have a Show instance for a -> b
15:23:39 <mzero> but if what you want is a show instance for your Lambda term
15:23:39 <sentientnonbeing> what's the status for haskell on android? dead?
15:23:59 <dzack> hexagoxel: wrt 'cabal configure', even that doesn't seem to pick up the changes
15:24:05 <mzero> you'll need to write a show instnace for your whole LispVal 
15:24:08 <mzero> not derive one
15:24:20 <mzero> but - it is easy, so you shouldn't shy away from it
15:25:04 <dzack> and @anyone: Any ideas for troubleshooting why 'cabal build' doesn't seem to catch a file/module?
15:25:06 <mzero> just write    instance Show LispVal where ....
15:25:27 <dzack> I included one with obvious syntax errors, but the build seems to ignore the file completely
15:25:36 <mzero> and a simple    show (Atom s) = show s ; show (List (car, cdr)) = ...
15:26:05 <hexagoxel> dzack: i doubt is has to do with picking up changes then; more like seems some misunderstanding of what is built
15:26:09 <mzero> dzack, did you list it in the included_modules section?
15:26:15 <hexagoxel> can you paste the .cabal?
15:26:19 <dzack> other notes: it's added in the cabal file, under the main executable, subheading 'other-modules:'
15:26:24 <dzack> sure, one sec
15:26:30 <mzero> er, exposed-modules
15:26:37 <mzero> oh- an exectuable
15:26:53 <mzero> typically you don't need to mention those (though it is good practice if you want cabal sdist to work)
15:27:19 <mzero> does something from Main actually include the new file?
15:27:25 * hackagebot lambda-options 0.7.0.0 - A modern command-line parser for Haskell.  http://hackage.haskell.org/package/lambda-options-0.7.0.0 (ThomasEding)
15:29:16 <dzack> https://github.com/dzackgarza/hackage-server/blob/master/hackage-server.cabal#L166
15:29:27 <dzack> this is the specific module I'm trying to add (Ranking)
15:29:46 <dzack> mzero: ah no, it's not explicitly called or included anywhere yet
15:30:26 <dzack> it's an add-on feature, so I'm trying to figure out a way to make iterative changes that don't break the build
15:30:30 <kirill`> What's the indentation rule that says items inside case cannot start to the left of case?
15:30:31 <dzack> before pulling it in
15:34:07 <mzero> dzack: well - that is why it won't be compiled
15:34:23 <mzero> if you have an executable
15:34:37 <mzero> cabal just hands the main .hs file to ghc, and ghc just finds all the modules as they are included
15:39:10 <hexagoxel> kirill`: "layout rule". but what your statement is not completely correct
15:40:02 <dzack> mzero: ahhh, I see - alright, i'll try explicitly including it there and see what happens!
15:40:11 <hexagoxel> "If the indentation of the non-brace lexeme immediately following a where, let, do or of is less than or equal to the current indentation level, .."
15:40:28 <hexagoxel> current indentation level != indentation of `case`
15:42:13 * hexagoxel always falls back to the != instead of /= habit..
15:43:48 <kirill`> I don't quite understand this:
15:43:48 <kirill`> let x = case y of
15:43:48 <kirill`>   False -> ...
15:44:09 <hexagoxel> in that case, the "current indentation level" is that of `x`
15:45:06 <hexagoxel> because `let` starts a level as well
15:45:10 <rui3> I rememeber having seen some nice chart or graph of the numeric classes, their relationships, etc. Anyone knows of any?
15:46:28 <mzero> there is one in the Haskell Report, I think
15:46:45 <hexagoxel> kirill`: i tend to use `let\n  x -> case y of\n    False -> ..`
15:46:54 <hexagoxel> for cases such as that
15:52:50 <kirill`> I still find it tricky.
15:55:43 <kirill`> So all of the expression for x must be strictly to the right of the left side of x?
15:56:56 <hexagoxel> yes
15:57:01 <orion> Does anyone know why haddock fails to parse this file?: http://lpaste.net/868669818654425088
15:57:34 <kirill`> hexagoxel: I see, thanks.
16:03:50 <mzero> orion: the problem is almost certainly with the parts you elided
16:06:06 <kirill`> orion: Since "-- |" begins a comment for the next field, presumably it fails to find the next field. It seems to fail on this one-line file as well:
16:06:06 <kirill`> data A = A -- |
16:09:02 <fr33domlover> hello! does it make sense / exist already / etc. to define tuple (a, b) as a monoid instance, where a and b are of Monoid types?
16:09:30 <fr33domlover> it happens to be useful to be but I haven't found such an instance
16:09:45 <init> > ([1,2,3] , [9,8,7]) <> ([4,5,6], [6,5,4])
16:09:49 <lambdabot>  ([1,2,3,4,5,6],[9,8,7,6,5,4])
16:09:59 <dzack> mzero: looks like that worked - files that aren't explicitly used anywhere are left out of the build entirely
16:10:08 <dzack> or modules, rather
16:10:15 <fr33domlover> > mappend ("hello", 1) ("world", 2)
16:10:18 <lambdabot>      No instance for (Show t0)
16:10:18 <lambdabot>        arising from a use of ‘show_M8197487239974554221264’
16:10:18 <lambdabot>      The type variable ‘t0’ is ambiguous
16:10:41 <init> fr33domlover: what do you want to do with those numbers?
16:10:53 <fr33domlover> init, add them with (+)
16:11:07 <arkeet> > mappend ("hello
16:11:08 <init> > (Sum 2, Product 2) <> (Sum 3, Product 3)
16:11:08 <lambdabot>  <hint>:1:16:
16:11:08 <lambdabot>      lexical error in string/character literal at end of input
16:11:10 <lambdabot>  (Sum {getSum = 5},Product {getProduct = 6})
16:11:29 <arkeet> > mappend ("hello
16:11:31 <lambdabot>  <hint>:1:16:
16:11:31 <lambdabot>      lexical error in string/character literal at end of input
16:11:34 <arkeet> ????
16:11:49 <ronh-> <arkeet> > mappend ("hello
16:11:51 <ronh-> you typed that
16:11:55 <init> fr33domlover: you have to use `Sum` then 
16:12:03 <arkeet> wtf is my irc client doing this again
16:13:54 <arkeet> > mappend ("hello
16:13:56 <lambdabot>  <hint>:1:16:
16:13:56 <lambdabot>      lexical error in string/character literal at end of input
16:13:59 <fr33domlover> init, thanks :-)
16:15:05 <arkeet> ok how did that get in there.
16:15:06 <arkeet> > mappend ("hello", Sum 1) ("world", Sum 2)
16:15:08 <lambdabot>  ("helloworld",Sum {getSum = 3})
16:17:28 <nolrai66> Any one know how to remove something from the stack in Boomberang?
16:19:57 <haskets> anyone know how to deal with protobuf data?
16:20:12 <haskets> In haskell? I'm trying to use a .proto file, but it's a pain in the ass
16:20:22 <mzero> hsproto
16:20:29 <mzero> @hackage hsproto
16:20:29 <lambdabot> http://hackage.haskell.org/package/hsproto
16:20:31 <haskets> it won't compile and is outdated
16:20:38 <mzero> sigh
16:21:17 <haskets> anything else?
16:21:58 <luzie> https://hackage.haskell.org/package/protobuf https://hackage.haskell.org/package/protocol-buffers from google
16:23:40 <haskets> second one doesn't compile. First one doesn't have a converter...
16:23:58 <haskets> I could write out the definition, but it's like 20 pages of text so converting that to haskell doesn't sound too pleasant
16:26:11 <nolrai66> Gah, there has to be a way to throw out the result of a router..
16:31:21 <haskets> lambdabot: help
16:31:29 <haskets> @help
16:31:29 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:31:32 <haskets> @help list
16:31:33 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
16:31:38 <haskets> @list 
16:31:38 <lambdabot> What module?  Try @listmodules for some ideas.
16:31:40 <haskets> @listmodules
16:31:41 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search seen slap source spell system tell ticker todo topic type undo unlambda unmtl version where
16:31:58 <haskets> @list hoogle
16:31:58 <lambdabot> hoogle provides: hoogle hoogle+
16:32:05 <haskets> @hoogle protobuf
16:32:06 <lambdabot> package protobuf
16:32:06 <lambdabot> package protobuf-native
16:32:06 <lambdabot> package persistent-protobuf
16:32:28 * hackagebot hein 0.1.0.3 - An extensible build helper for haskell, in the vein of leiningen.  http://hackage.haskell.org/package/hein-0.1.0.3 (khanage)
16:35:16 <hexagoxel> that "Try 'list' for all commands" is such a troll :D
16:35:40 <Kudos2Me> Send 100% completely unbranded e-mails by us free, forever, try it on yourself first if you don't believe me! Send it from any made up name + email at http://bit.ly/1cqkqvW
16:36:50 * hodapp stabs Kudos2Me in the face
16:37:17 <voidzero> bit on edge today hodapp?
16:37:35 * voidzero wipes some of the blood from his now ruined shirt
16:37:57 <hodapp> I regret only that your shirt had to suffer collateral damage.
16:38:09 <hodapp> Just get some cold water. It'll come out.
16:42:28 <athan> What's your favorite way to get rid of nested if statements?
16:42:29 <Zekka> I forget, isn't there a proof along the lines that immutable structures are at worst  log n slower than mutable ones?
16:42:48 <hpc> Zekka: yes
16:43:16 <Zekka> hpc: Can you link me it? I'm currently writing a program with O(n) mutable structures I would really rather be O(n log n)
16:43:20 <hodapp> athan: switching to Haskell got rid of 99% of mine :P
16:43:24 <Zekka> (this is not in Haskell but in Java)
16:43:27 <hodapp> the remaining 1% I just don't worry much about.
16:43:30 <Zekka> Er, O(n log n) immutable
16:43:40 <exio4> O(n log n) what?
16:43:52 <Zekka> exio4: In this case, insertion
16:43:52 <exio4> indexing? append? cons? 
16:44:04 <Zekka> I made my wording really imprecise because I was hoping someone would give me a more precise description of what was proved
16:44:14 <Zekka> If you want I can write up a little bit about what operations I expect my structure to support
16:44:35 <Zekka> (probably best if nobody's going to link the original paper)
16:44:46 <athan> hodapp: well yeah :P but _how_? via some monad?
16:45:08 <athan> like... how do you handle each branch?
16:45:11 <hpc> Zekka: http://stackoverflow.com/questions/22075684/does-the-most-efficient-solution-to-some-problems-require-mutable-data
16:45:16 <Zekka> hpc: Thanks
16:45:32 <hpc> unfortunately the papers are under ACM
16:48:08 <Zekka> hpc: Actually, here's a pertinent question I can ask right now
16:48:20 <rvxi> is there a good way to package a yesod backend+javascript frontend as a standalone desktop/android/ios app?
16:48:22 <exio4> athan: at least here, what would have been if conditions is mostly replaced with pattern matching and/or abstracting common patterns with high order functions that take a few functions as parameters 
16:49:29 <Zekka> Is there a type along the lines of an immutable list where replacing an arbitrary element frequently better than O(n) time complexity based on some kind of rule of thumb indicating how likely it is to get removed? 
16:49:41 <Zekka> frequently has better than O(n)*
16:50:08 <Zekka> I can be flexible about the rule of thumb but what I was using in my test program was an ordering function along the lines of Ord
16:50:33 <athan> exio4: Ahh okay, I understand that. I also understand how some monads, like the maybe monad or ExceptT handle errors implicitly
16:50:35 <Zekka> My gut is that you can do this with some kind of tree structure
16:50:41 <jmcarthur> Zekka: Data.Sequence?
16:50:47 <athan> I'm just wonderng if there's a... Branch monad or something :s
16:51:06 <hpc> honestly, at that point it's probably less ugly to just deal with mutation
16:51:08 <exio4> Zekka: a "Random Access List"? 
16:51:15 <athan> because you could run into the same issue with nested `case` statements with pattern matching, too
16:51:19 <jmcarthur> Zekka: or is it that you actually want some elements to take constant time, based on the rule of the thumb you mentioned, and possibly some to take longer?
16:51:57 <exio4> athan: nested cases? 
16:51:59 <Zekka> jmcarthur: Obviously it'd be optimal for all removals/replacements to take constant time, which you can probably do with a hashtable, but you don't get immutability
16:52:04 <exio4> athan: you can nest patterns
16:52:25 <Zekka> So I'd like a structure where at least some removals/replacements are close to being that quick
16:52:35 <exio4> (Just (3:_), Left Nothing) -> .. is a thing. 
16:52:35 <jmcarthur> Zekka: right, but i mean are you after some statistical property guaranteeing that "most" of them would be constant time, at the expense of some of them being worse, or is worst case O(log n) just fine?
16:52:36 <athan> exio4: but you can't apply functions in patterns! idk, I might just be going at this in the wrong direction
16:52:39 <Zekka> exio4: That's possibly an accurate description but I don't think it's as granular as what I described
16:52:39 <jmcarthur> got it
16:52:42 <athan> s/in/inside
16:52:59 <Zekka> jmcarthur: Worst case O(log n) is probably fast enough
16:53:25 <jmcarthur> Zekka: will the ones you need to access tend to be at the beginning/end? or kind of arbitrary? does their position even matter (could it be reordered)?
16:53:46 <zed_> would someone please look at this code and tell me what the first line (BangPatterns) changes ? i am still new to this. http://lpaste.net/133607
16:53:59 <Zekka> jmcarthur: The position matters and which ones I need to replace doesn't have anything to do with order in the list
16:54:30 <Zekka> Right now my rule is an ordering similar to Ord in Haskell but a numeric ranking would also work
16:54:50 <Zekka> jmcarthur: The point being that it's determined by the nature of the elements, not their position in the collection
16:55:03 <jmcarthur> Zekka: Data.Sequence offers worst case O(log n) random access. maybe you could use some sort of a splay tree if you really want some frequent accesses to be faster
16:55:18 <exio4> zed_: oh, sorry, it doesn't matter, it justs lets you be `strict` on certain fields, you can ignore it (and all the !s)
16:55:26 <jmcarthur> Zekka: oh, so you want a stable heap?
16:55:28 <jazz25> 'night folks. Is there a function for 'extracting' the value from an IO Monad? Something like IO a -> a.
16:55:55 <jmcarthur> Zekka: i uploaded an experimental stable heap to hackage just a week or so ago
16:55:59 <Zekka> jmcarthur: Do I? I thought in a heap, an element's numeric rank determined its position
16:55:59 <jmcarthur> Zekka: http://hackage.haskell.org/package/stable-heap
16:56:04 <zed_> exio4 : thanks
16:56:08 <Cale> jazz25: No, an IO action isn't like a wrapper around a value.
16:56:11 <pacak> jazz25: There's unsafePerformIO, but you should'nt do that.
16:56:11 <geekosaur> jazz25, not one you should use
16:56:19 <exio4> jazz25: you shouldn't need one, you have to use (>>=) / fmap 
16:56:20 <Zekka> jmcarthur: I can take al ook. Like I mentioned I'm not in Haskell but if it's a common-issue data structure it's likely someone already implemented it in the language I'm using, or I might be able to transliterate it
16:56:22 <Cale> jazz25: Any more than /bin/ls is a wrapper around a list of files.
16:56:24 <jmcarthur> Zekka: a stable heap orders the elements however you want, and allows fast access to the min key
16:56:27 <ronh-> jazz25 the whole point is that you can't extract it
16:56:27 <exio4> @type (>>=) :: IO a -> (a -> IO b) -> IO b 
16:56:27 <geekosaur> things WILL go wrong if you try to cheat
16:56:29 <lambdabot> IO a -> (a -> IO b) -> IO b
16:56:40 <jmcarthur> Zekka: it is not common. i had to invent it
16:56:54 <Cale> Inside an IO action, you may execute other IO actions to obtain their results
16:57:04 <jmcarthur> Zekka: another version would be possible with a finger tree (i think the fingertree package has one), but it's much slower
16:57:15 <Zekka> jmcarthur: Cool, these operations look right
16:57:21 <Cale> In do-notation, you write v <- x which means "let v be the result of executing the action x". If x :: IO t, then v :: t
16:57:38 <Cale> The do-block as a whole then will be an IO action itself
16:57:43 <Zekka> Let me see if the code looks simple enough that I'm comfortable transliterating it
16:57:49 <jmcarthur> Zekka: even in haskell, i wouldn't recommend my package for anything important yet
16:57:49 <Cale> (whose result has the same type as the last line in it)
16:57:52 <Zekka> (if not, do you have any resources for translating lazy code to strict code?)
16:57:57 <jmcarthur> Zekka: but i think the idea is sound
16:58:57 <jmcarthur> Zekka: i recommend following the derivation that i did. learn about fibonacci heaps, then make them stable by making them "two sided" (you can probably figure out what that means once you have seen fib heaps)
16:59:12 <jmcarthur> Zekka: and my version uses laziness in the way that okasaki's version of fib heaps does
16:59:27 <Zekka> jmcarthur: I'll let you know if I run into trouble, thanks a lot
17:01:25 <jazz25> Cale: I see.. Well, I have a Data.Map.fromList to map Keys to myValue -> myValue functions, but I need to save some stuff in a file, so I'm a bit clueless..
17:01:29 <jmcarthur> Zekka: ah, i told you a lie
17:01:50 <jmcarthur> Zekka: i based this one pairing heaps, not fibonacci heaps. they are similar, but pairing heaps are much much simpler
17:01:57 <jmcarthur> Zekka: sorry for the misleading explanation :)
17:02:07 <jmcarthur> *on pairing heaps
17:02:11 <Zekka> jmcarthur: Don't worry about it, still googling
17:02:58 <jmcarthur> i just got mixed up while typing for whatever reason
17:03:27 <Cale> jazz25: Can you get the stuff you want to write to a file as a String or ByteString or something like that?
17:03:41 <jmcarthur> Zekka: i'm curious what your application is?
17:03:56 <jazz25> Cale: Yeah, sure.
17:04:03 <jmcarthur> Zekka: as i said, this is an unusual data structure, or so i thought. i've seen maybe three uses for it since writing it already
17:04:32 <Cale> :t writeFile
17:04:34 <lambdabot> FilePath -> String -> IO ()
17:04:44 <Welkin> FilePath is a String
17:04:49 <Zekka> jmcarthur: This isn't super telling, it's an internal part of a Prolog implementation
17:04:51 <Welkin> type FilePath = String
17:05:08 <Cale> writeFile takes a FilePath (which is just a String), and a String to be written, and produces the IO action which when executed, will write the given file with the given contents.
17:05:35 <jmcarthur> Zekka: a guess: part of a breadth first search algorithm trying to ensure fairness among all choices?
17:05:36 <Cale> You can execute it from the main action of your program, and it should write the file when executed.
17:06:23 <Zekka> jmcarthur: I'm not quite sure what you mean by fairness here
17:07:07 <ion> hpc: Heh, the comment in the link: “For all n, log n < 30”
17:07:21 <hpc> proof: bad at counting
17:07:22 <hpc> QED
17:07:37 <Zekka> Basically I'm building an N-tree to represent the rules database using rough order of specificity to avoid checking unnecessary rules, but I also want time travel and fast assert()-like operations
17:08:24 <Zekka> So things closer to the top of the tree are less specific and when you assert something it adds the lowest common bound to the tree
17:08:28 <jazz25> Cale: I'm actually using that function. I'm using Gloss, so I needed a myType -> myType function to fit my input part (the one that steps the program after a given input).
17:08:33 <jmcarthur> Zekka: given choices A, B, C each with their own cost lower bounds, the one with the smallest lower bound is explored first, until its lower bound is larger than another (or the same as a choice occurring to its left)
17:08:43 <Zekka> jmcarthur: I don't know if this implementation technique holds water but I wanted to screw around with it
17:09:22 <jmcarthur> Zekka: okay, well, i can see how this data structure may be useful at least, though i don't actually understand the idea
17:09:29 <jmcarthur> thanks
17:09:40 <Zekka> jmcarthur: Don't try too hard to understand the idea, I'm not sure if it's good
17:09:50 <Cale> jazz25: You'll need to use the IO version of Gloss which lets you perform IO actions on each step.
17:09:56 <Zekka> I'm not implementing Prolog exactly, it's a logic language with unification though so it's fairly close
17:10:13 <jazz25> Cale: I see. I'll look into it. Thanks :)
17:10:40 <Zekka> (That's a statemen that will piss off every logic programmer in the room!)
17:10:46 <Cale> http://hackage.haskell.org/package/gloss-1.9.2.1/docs/Graphics-Gloss-Interface-IO-Game.html
17:11:20 <Cale> jazz25: You can use return :: a -> IO a to make an IO action that does nothing except to return the given value when executed, for those cases that you don't need the ability to really do I/O
17:12:34 <athan> I kinda wish we had local data type declarations in `where` clauses
17:12:36 <jazz25> Cale: So I'll turn all my myType -> myType functions into IO myType -> IO myType functions, and just use returns in all the ones I don't actually need IO?
17:12:43 <athan> for single-purpose state data types, for instance
17:12:59 <Cale> jazz25: You shouldn't need to do it to everything, just locally where you're calling play
17:13:31 <jazz25> Cale: Yeah, on my fromList structure, right?
17:13:45 <Cale> jazz25: Er, I haven't seen your existing code
17:14:49 <jmcarthur> Zekka: note that if you are using immutability for the free backtracking (i imagine you are) then you probably do want something like the version i implemented using laziness, not just based on strict pairing heaps
17:15:18 <jmcarthur> Zekka: and since this isn't haskell you are using, you might need to implement the laziness manually...
17:15:29 <Zekka> jmcarthur: That's not what I'm using it for but if I was I would be expecting the same performance characteristics as I'm wanting now
17:15:35 <Cale> jazz25: If you put it on lpaste.net, I can have a look and help you translate it a bit
17:16:17 <Zekka> jmcarthur: At the moment I'm not sure how to transliterate the laziness, so I'm just marking the lazy fields with a comment
17:16:29 <Zekka> Probably I'll literally make a type representing a thunk and do it that way
17:16:36 <Zekka> which sucks but what do you say?
17:19:33 <Zekka> jmcarthur: Want to wince?
17:20:19 <Zekka> http://lpaste.net/133614 <- finally we all can write lazy code in Java
17:39:38 <Zekka> jmcarthur: Most of the operations are not here, but here's an implementation in Java of a version with just union
17:39:46 <Zekka> Ignore the stub class at the top of the file
17:40:03 <Zekka> (er, one moment, lpaste is loading really slowly)
17:40:37 <Zekka> https://pastebin.mozilla.org/8835255 <- here it is!
17:52:51 <nolrai66> Is there a good way to test arbitrary without using all of quick check?
17:56:58 <nolrai66> God damn it I want to run a QuickCheck.Gen..
18:02:33 * hackagebot hein 0.1.0.4 - An extensible build helper for haskell, in the vein of leiningen.  http://hackage.haskell.org/package/hein-0.1.0.4 (khanage)
18:02:35 * hackagebot ltext 0.0.0.3 - Higher-order file applicator  http://hackage.haskell.org/package/ltext-0.0.0.3 (athanclark)
18:11:02 <athan> Anyone here familiar with building debian / ubuntu .deb's from haskell executables?
18:36:28 <Zekka> jmcarthur: Does stable-heap really require base 4.8?
18:36:32 <Zekka> Because if not, you may have made a mistake
18:37:49 <Zekka> jmcarthur: Apparently it does, btu only because applicative isn't in prelude
18:37:58 <Zekka> or at least that's the only error GHC gave me os far
18:39:53 <Zekka> Some other minor problems, they seem to be hte same sort of thing
18:40:23 <S3thc0n> Hello everyone! Could someone provide me of examples or a general description of what kinds of things can only be achieved with Template Haskell's reification and not in normal Haskell? 
18:41:38 <Axman6> creating functions based on data types at compile time?
18:43:07 <nolrai66> where is fix defined?
18:43:28 <exio4> Data.Function
18:43:33 <exio4> @type Data.Function.fix
18:43:34 <lambdabot> (a -> a) -> a
18:43:44 <exio4> if we're talking about the same `fix`, that's it
18:44:05 <nolrai66> Ah.
18:44:45 <nolrai66> Just out of idle curiousity would "forever m = fix (m >>)" work?
18:45:00 <Zekka> > fix (m >>) (putStrLn "Hello!")
18:45:02 <lambdabot>      Couldn't match expected type ‘IO () -> a0’ with actual type ‘Expr’
18:45:02 <lambdabot>      In the first argument of ‘(>>)’, namely ‘m’
18:45:02 <lambdabot>      In the first argument of ‘fix’, namely ‘(m >>)’
18:45:16 <Zekka> er, wait
18:45:20 <Zekka> wow, that was embarrassing
18:45:32 <Zekka> > (\m -> fix (m >>)) (putStrLn "Hello!")
18:45:35 <lambdabot>      No instance for (Typeable b0)
18:45:35 <lambdabot>        arising from a use of ‘show_M822906979277213785423727’
18:45:35 <lambdabot>      In the expression:
18:45:47 <exio4> nolrai66: yes
18:45:49 <Zekka> Don't ask me!
18:47:18 <nolrai66> What is going on there in Lambdabot?
18:47:49 <nolrai66> I mean "> putStrLn "test"" just results in "<IO>"
18:51:22 <liveify> If I have 3 functions, a :: String, b :: String -> String, c :: String -> String -> String. How do I chain them together so a is called, and the result is passed to b, and the reuslt from b is passed to a? Is there a convient way of doing this?
18:51:56 <nolrai66> a isn't a function.
18:52:35 * hackagebot hasql-backend 0.4.1.1 - API for backends of "hasql"  http://hackage.haskell.org/package/hasql-backend-0.4.1.1 (NikitaVolkov)
18:52:38 <liveify> nolrai66: you are right. Ignoring a, how would I call c with the restulf of b?
18:52:50 <exio4> liveify: c . b 
18:53:11 <nolrai66> or maybe: c x . b
18:53:13 <exio4> @let fun1 x = "hi " ++ "!" 
18:53:15 <lambdabot>  Defined.
18:53:27 <exio4> oh, String -> String -> String
18:53:43 <exio4> @let fun2 x = "[" ++ x ++ "]"
18:53:44 <lambdabot>  Defined.
18:53:58 <exio4> er
18:55:07 <liveify> My question might be confusing. C should be called with the input to b and the output of b
18:55:17 <exio4> liveify: in which order? 
18:55:22 <exio4> (<*>) may do what you want
18:55:31 <liveify> input then output
18:55:50 <exio4> > ((\x y -> (x,y)) <*> (\x -> "hi " ++ x)) "name"
18:55:52 <lambdabot>  ("name","hi name")
18:56:05 <exio4> liveify: then <*> is what you want
18:56:15 <liveify> exio4: Thanks!
18:56:22 <exio4> (c <*> b) a
18:56:44 <exio4> liveify: for what it is worth, that would have been easier if you had more polymorphic types! :P
18:57:27 <liveify> exio4: Extreme beginner here :P not sure what that would mean here
18:57:35 * hackagebot hasql 0.7.3.2 - A minimalistic general high level API for relational databases  http://hackage.haskell.org/package/hasql-0.7.3.2 (NikitaVolkov)
18:57:37 * hackagebot hasql-postgres 0.10.3.2 - A "PostgreSQL" backend for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.10.3.2 (NikitaVolkov)
18:57:42 <exio4> given x :: a, f :: a -> b, g :: a -> b -> c,
18:58:07 <exio4> that type, gives you the right order without asking 
18:58:37 <exio4> (and it is so precise, that you can generate such function with djinn!
18:58:55 <exio4> @djinn f :: (a -> b -> c) -> (a -> b) -> (a -> c)
18:58:55 <lambdabot> Cannot parse command
18:59:41 <exio4> @djinn (a -> b -> c) -> (a -> b) -> (a -> c)
18:59:41 <lambdabot> f a b c = a c (b c)
19:00:24 <liveify> exio4: Wow that is pretty cool that works in IRC. 
19:16:19 <KaneTW> @djinn f (a -> b -> c) -> f a -> f (b -> c)
19:16:19 <lambdabot> -- f cannot be realized.
19:16:59 <pacak> :t (<*>)
19:17:00 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:17:29 <pacak> :t (<*>) :: f (a -> b -> c) -> f a -> f (b -> c)
19:17:31 <lambdabot>     No instance for (Applicative f1) arising from a use of ‘<*>’
19:17:31 <lambdabot>     Possible fix:
19:17:31 <lambdabot>       add (Applicative f1) to the context of
19:17:40 <pacak> :t (<*>) :: Applicative f => f (a -> b -> c) -> f a -> f (b -> c)
19:17:41 <lambdabot> Applicative f => f (a -> b -> c) -> f a -> f (b -> c)
19:17:50 <KaneTW> @djinn Foo (a -> b -> c) -> Foo a -> Foo (b -> c)
19:17:50 <lambdabot> Error: Undefined type Foo
19:19:40 <naudiz> why did someone say a :: String isn't a function? constant functions are functions, too.
19:21:19 <S3thc0n> naudiz: What does that function return then?
19:21:44 <Sprog> Quick question
19:21:45 <naudiz> S3thc0n: a constant value that's assigned to it
19:22:12 <naudiz> S3thc0n: but it takes no arguments
19:22:19 <KaneTW> naudiz: functions in haskell have type (->)
19:22:26 <athan> Anyone know if HM-style polymorphism / prenex polymorphic lambda calculus has a special name in literature? Like how simply-typed is referenced as `\lambda \rightarrow`, and first-order dependent types is `\lambda \pi`?
19:22:47 <S3thc0n> naudiz: You mean, like a String? So we've got a constant. Why not have a constant immediately if we got them anyway?
19:22:49 <Sprog> if I have something like: data myType = myType { myField :: Int }, and I make another line called newType myNewType = myNewType [myType] deriving (Show), why does it give me an error saying parse error on 'deriving'?
19:22:50 <naudiz> KaneTW: but mathematically a value is a function
19:23:15 <lethjakman> is there any difference between <*> and `fmap`?
19:23:19 <KaneTW> depends on the field
19:23:25 <athan> lethjakman: A very serious one
19:23:30 <athan> :t fmap
19:23:31 <lethjakman> why so serious?
19:23:31 <KaneTW> :t fmap
19:23:31 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:23:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:23:34 <athan> :P
19:23:37 <athan> :t (<*>)
19:23:38 <KaneTW> :t (<*>)
19:23:39 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:23:39 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:23:40 <KaneTW> lol
19:23:41 <lethjakman> sorry, I couldn't help myself
19:23:51 <athan> KaneTW: d:
19:23:53 <naudiz> S3thc0n: I'm just saying that constants are functions, too. namely constant functions
19:24:11 <athan> lethjakman: :}
19:24:18 <HEGX64> Sprog: you need to do "data myNewType = myNewType [myType] deriving (Show)" on the second line I think
19:24:29 <haskets> anyone know of a protobuf package for protobuf->haskell? Or a workaround?
19:24:46 <Sprog> HEGX64, whats the difference between data and newType?
19:24:56 <lethjakman> I still have issues understanding haskell documentation for some reason...
19:25:50 <naudiz> lethjakman: haskell libraries are usually badly documented
19:26:15 <HEGX64> Not sure but I think data is what you want. I've never used newType but "newType myNewType = myNewType [myType] deriving (Show)" may also work
19:26:19 <naudiz> lethjakman: most of the time you'll have to look at the actual code or examples if there are any
19:26:36 <KaneTW> naudiz: i fundamentally disagree; each constant has a constant function associated with it (infinitely many, even), but they're not the same
19:26:49 <lethjakman> naudiz: good to know it's not just me
19:26:59 <lethjakman> I see a lot of potential in this language...
19:27:38 <naudiz> Sprog: newType uses the underlying type but identifies it as a new type which can be more efficient in some cases
19:28:01 <Sprog> naudiz, but you can't derive typeclasses with newType?
19:28:05 <KaneTW> you can
19:28:08 <KaneTW> that's the whole point
19:28:28 <KaneTW> newtype is a compile-time type alias that doesn't inherit the underlying type's instances
19:28:43 <KaneTW> data is a full-blown actual data type
19:29:00 <lethjakman> thanks for the help people :)
19:29:05 <naudiz> KaneTW: for a function/vector it doesn't matter how many arguments it has, the number of arguments just defines its dimension. A constant is a constant function with dimension 0.
19:29:26 <KaneTW> what's the dimension of a function
19:29:48 <lethjakman> anyone know of a denver haskell meetup? 
19:30:07 <naudiz> f() has dimension 0, f(x) has dimension 1, f(x1,x2) has dimension 2, etc.
19:30:36 <KaneTW> that's why i said it depends on the field
19:31:32 <KaneTW> for me the definition of a function is a triple (X, f, Y) with f subset X x Y with each element of X appearing at most once
19:31:34 <naudiz> in geometry a vector of dimension 0 is a point (single value), a 1d-vector is a line (one degree of freedom), a 2d-vector is a surface (two degrees of freedom), etc. and functions are just another way to write vectors
19:32:06 <KaneTW> you're assuming your definitions from your field are valid in any other field, which just isn't true
19:32:10 <exio4> naudiz: http://conal.net/blog/posts/everything-is-a-function-in-haskell
19:32:24 <naudiz> KaneTW: when X and Y are empty you've got yourself a point :)
19:32:55 <KaneTW> when X is empty i got myself an empty set
19:33:20 <naudiz> sorry, Y has to have one element
19:33:25 <KaneTW> when X is a singleton i have a point :)
19:34:09 <naudiz> exio4: I'm not talking about a technical point of view but a mathematical
19:34:47 <exio4> naudiz: read the post :)
19:35:20 <naudiz> KaneTW: no, then you've got a 1-element intervall on a line, a line segment. you still have to give an argument to your function, even tough there is only one valid argument.
19:35:47 <naudiz> exio4: I will, but for now I just skimmed it
19:36:17 <KaneTW> it's still a point
19:36:24 <greymalkin> I'm blanking on the syntax for something like this: let function thing@Thing{ thing_id == 42 } = do_something_to thing
19:37:09 <naudiz> KaneTW: the result is a list of points with a single element
19:37:29 <naudiz> x = [1] has type [Int], y = 1 has type Int
19:37:56 <KaneTW> no, that's not what you get
19:38:37 <KaneTW> you get |Y| many  different functions that can have X as a domain
19:38:50 <KaneTW> but each function is unique and has only one value for which it is defined
19:39:00 <exio4> note that in Haskell, also, there's bottom
19:39:03 <KaneTW> well-defined, not unique
19:39:13 <greymalkin> nevermind, just used guards.
19:39:25 <exio4> @type (\x -> x` seq` 2) (error "..")
19:39:27 <lambdabot> Num a => a
19:39:32 <exio4> (\x -> x` seq` 2) (error "..")
19:39:34 <exio4> > (\x -> x` seq` 2) (error "..")
19:39:36 <lambdabot>  *Exception: ..
19:39:49 <naudiz> exio4: as far as I read by skimming, the author states that haskell needs constants to work properly and as it derives from lambda calculus, that's true. but from a mathematical point of view I think the abstraction of seeing constants as 0D constant functions is still valid
19:40:57 <pingu> naudiz: I suspect it's important to make the distinction when talking about reducing values.
19:41:03 <pingu> And evaluation relations and the like.
19:42:55 <exio4> naudiz: it's not valid under `real` Haskell given we have bottom
19:43:00 <nolraiVM> So, how usable is Leksah these days?
19:43:34 <naudiz> pingu: as I said, from a technical point of view, e.g. in optimization, there is a difference. but in everyday programming I think it helps people understanding things when abstracting it mathematically
19:43:46 <nolraiVM> I mean I use vim for my actuall job so maybe I should use that..
19:43:48 <KaneTW> tread the post
19:43:56 <naudiz> exio4: bottom just gives you an additional value for each argument
19:44:23 <athan> So HM lambda calculus isn't quite λ2, but it's more than λ->
19:44:57 <exio4> naudiz: yes, even functions
19:45:13 <exio4> @type undefined :: (forall a. a.) -> Int 
19:45:14 <lambdabot>     Illegal symbol '.' in type
19:45:15 <lambdabot>     Perhaps you intended to use RankNTypes or a similar language
19:45:15 <lambdabot>     extension to enable explicit-forall syntax: forall <tvs>. <type>
19:45:20 <exio4> @type undefined :: (forall a. a) -> Int 
19:45:21 <lambdabot> (forall a. a) -> Int
19:47:11 <naudiz> exio4: bottom is an element of every type, that doesn't contradict mathematics
19:47:59 <exio4> naudiz: I may be missing something
19:48:32 <naudiz> exio4: or I am. I don't really understand why you bring up buttom.
19:52:10 <liveify> exio4: Is it possible to use <*> to create something like v a b c d = a d (c d) (b d (c d))? Essentially adding another function to the chain? 
19:52:37 <exio4> naudiz: it's basically that it doesn't hold `morally`, nothing that important :), still, seeing functions as 0D constants seems pretty useless, unless you want to represent the negative type in an explicit manner, I don't know? :)
19:52:46 <nshepperd> talking of values as nullary functions doesn't make a lot of sense
19:52:56 <nshepperd> because what is the result type?
19:53:02 <KaneTW> giving functions a dimension is pretty silly regardless imo
19:53:35 <nolraiVM> Why would functions have a dimension?
19:53:40 <KaneTW> ask naudiz
19:53:45 <exio4> liveify: I don't know :/
19:54:01 <liveify> exio4: No worries. There is probably a better way of doing what I want to anyway. 
19:54:41 <KaneTW> @pl \a b c d -> a d (c d) (b d (c d))
19:54:41 <lambdabot> (. ap) . ap . (ap .) . ap
19:54:41 <naudiz> KaneTW: ask a mathematician
19:54:48 <KaneTW> naudiz: i -am- a mathematician
19:55:36 <slack1256> How do I install the platform from pure cabal?
19:55:38 <naudiz> KaneTW: now it's getting interesting :P as a physicist I've learned it this way
19:56:02 <KaneTW> i'm just saying definitions vary wildly across fields
19:56:22 <naudiz> didn't expect them to vary that much
19:57:00 <KaneTW> in physics where you mostly deal with functions from n-dimensional vector spaces it makes sense to assign a dimension to a function K^n -> V or somesuch
19:57:50 <KaneTW> it doesn't make much sense in algebra for example
19:59:01 <naudiz> KaneTW: we used this definition in algebra as well, actually that's when this concept was introduced at the beginning of the first semester
19:59:19 <KaneTW> linear algebra, not abstract algebra like category theory and such
20:00:11 <naudiz> yes, it was linear algebra, category theory was only covered briefly
20:00:12 <Sprog> http://hastebin.com/ecozohecap.hs - Does anyone know why this code is giving me a parse error (possibly incorrect indentation or mismatched brackets)?
20:01:00 <KaneTW> in any case the dimension is the dimension of the domain, not the function; it's just abuse of notation to say "dimension of a function" in your case
20:03:58 <naudiz> KaneTW: maybe it's just a translation-thing. I'm living in Germany and we call it "dimension of a function" as well as "dimension of the domain of a function" in German. Or it's "Mathematics for Physicists"-slang :P
20:04:15 <KaneTW> probably latter
20:04:40 <exio4> I was thinking about |A -> B| to be |B| ^ |A| 
20:04:50 <KaneTW> it is
20:05:18 <KaneTW> http://en.wikipedia.org/wiki/Exponential_object
20:05:56 <exio4> yeah, that's why I brought bottom, it makes this thing dirty :P 
20:07:18 <nolraiVM> Yeah, I have an B.S. in math, and haven't seen that.
20:07:36 <nolraiVM> You mean just size right?
20:08:15 <nolraiVM> Yeah, bottoms add an annoying 1 to everything, and then end up not being what you want to talk about anyway.
20:08:40 <nolraiVM> I mean they are important sometimes, but ignoring them until they actually matter is fine.
20:09:08 <naudiz> I mean "dimension" as "number of degrees of freedom" where bottom doesn't really play a big role since it just fits everywhere
20:09:10 <exio4> yeah, most of the time being morally correct is correct enough :P
20:11:31 <KaneTW> anyway, i'm gonna go sleep, sun's rising
20:12:49 <nolraiVM> Hmm.
20:13:15 <nolraiVM> Degrees of freedom is weird conept for computable functions.
20:14:43 <naudiz> nolraiVM: It's intuitive to me. :P
20:19:52 <Bashmetim> >:t fromEnum . maxBound
20:19:58 <Bashmetim> :t fromEnum . maxBound
20:20:00 <lambdabot> (Bounded (a -> a1), Enum a1) => a -> Int
20:20:14 <c_wraith> :t fromEnum maxBound
20:20:15 <lambdabot>     No instance for (Enum a0) arising from a use of ‘fromEnum’
20:20:15 <lambdabot>     The type variable ‘a0’ is ambiguous
20:20:15 <lambdabot>     Note: there are several potential instances:
20:20:52 <Bashmetim> Why does the type signature there have an (a -> a1) in it?
20:21:02 <Ralith> :t fromEnum
20:21:03 <lambdabot> Enum a => a -> Int
20:21:05 <Ralith> :t maxBound
20:21:06 <lambdabot> Bounded a => a
20:22:26 <Bashmetim> Huh. Better question, why *isn't* (fromEnum . maxBound) a type error for the (.) function?
20:22:34 <nolraiVM> Welll..all countable sets have the same cardnality, so theres only two states, D0 or D1.
20:22:35 <Bashmetim> :t (.)
20:22:36 <lambdabot> (b -> c) -> (a -> b) -> a -> c
20:22:51 <Bashmetim> maxBound isn't an (a -> b)!
20:23:17 <joneshf-laptop> Bashmetim, why can't there be?
20:23:26 <exio4> @type maxbound
20:23:28 <lambdabot>     Not in scope: ‘maxbound’
20:23:28 <lambdabot>     Perhaps you meant ‘maxBound’ (imported from Prelude)
20:23:29 <nshepperd> Bashmetim: it could be, if there was a Bounded instance for that
20:23:32 <exio4> @type maxBound
20:23:33 <lambdabot> Bounded a => a
20:23:43 <joneshf-laptop> Bashmetim, the `a` is not concrete
20:23:48 <exio4> there could be a Bounded instance for some type you want
20:23:56 <joneshf-laptop> it's any `a`, including `a -> b`
20:24:03 <joneshf-laptop> assuming you can find an instance
20:24:11 <joneshf-laptop> well, not assuming that
20:24:13 <exio4> it won't compile if it can't find an instance that matches though
20:24:14 <joneshf-laptop> it just is
20:24:19 <nolraiVM> If a1 is finite (const maxBound) makes sense as maxBound.
20:24:42 <Bashmetim> Okay, I get that then
20:24:52 <joneshf-laptop> exio4, won't it still compile?
20:25:02 <joneshf-laptop> exio4, you just can't use it if there's no instance
20:25:08 <joneshf-laptop> exio4, or am i misunderstanding
20:25:32 <nolraiVM> It will fail to compile if you try to use it.
20:25:53 <nolraiVM> But yes, not if you just export it.
20:26:18 <Bashmetim> So why can't I write this function? :
20:26:18 <Bashmetim> biggest :: (Bounded a, Enum a) => a
20:26:18 <Bashmetim> biggest = fromEnum maxBound
20:27:07 <Bashmetim> Wait, nevermind
20:27:23 <Bashmetim> It's because the type is wrong and that doesn't make sense...
20:28:57 <exio4> joneshf-laptop: I think it won't work, mostly because it tries to find if any instance could match at compile time, I think
20:29:27 <nolraiVM> exio4: no you can totally compile it.
20:29:27 <exio4> @type let f = fromEnum . maxBound in 2 
20:29:28 <lambdabot>     Could not deduce (Bounded (a -> a0))
20:29:28 <lambdabot>     from the context (Bounded (a -> a1), Enum a1)
20:29:28 <lambdabot>       bound by the inferred type for ‘f’:
20:29:47 <nolraiVM> Its just useless and will never actually be run..
20:30:04 <nolraiVM> well until someone creates an instance that works.
20:30:44 <nolraiVM> like "instance Bounded b => Bounded (a -> b)"
20:30:58 <nolraiVM> Which does actually work.. making it not useless at all.
20:31:18 <exio4> I am thinking about an executable
20:31:53 <nolraiVM> Just define maxBound = const maxBound, minBound = const MinBound.
20:31:58 <nolraiVM> And your set.
20:32:32 <nolraiVM> Well fuck I cant even install Leksah.
20:32:47 <nolraiVM> Sorry for my french.
20:33:17 <Bashmetim> Eh. I didn't really want to compose them, all I want is a function that will give me (fromEnum maxBound)
20:34:06 <nolraiVM> > let f = fromEnum maxBound in f
20:34:08 <lambdabot>      No instance for (Enum a0) arising from a use of ‘fromEnum’
20:34:09 <lambdabot>      The type variable ‘a0’ is ambiguous
20:34:09 <lambdabot>      Note: there are several potential instances:
20:34:12 <c_wraith> Bashmetim: that's not implementable, though.  It's just an Int, with no arguments.  You can't specify the type
20:34:18 <hamishmack> nolraiVM: Is it tregex-tdfa-text failing to install?
20:34:26 <hamishmack> nolraiVM: If so cabal install regex-tdfa-text --ghc-options=-XFlexibleContexts
20:35:31 <nolraiVM> No just me getting confused.
20:36:04 <c_wraith> > let count :: forall proxy a. (Enum a, Bounded a) => proxy a -> Int ; count _ = fromEnum (maxBound :: a) in count (Proxy :: Proxy Bool)
20:36:05 <lambdabot>  1
20:36:18 <c_wraith> > let count :: forall proxy a. (Enum a, Bounded a) => proxy a -> Int ; count _ = fromEnum (maxBound :: a) in count (Proxy :: Proxy (Either Bool Bool))
20:36:20 <lambdabot>      No instance for (Bounded (Either Bool Bool))
20:36:20 <lambdabot>        arising from a use of ‘count’
20:36:20 <lambdabot>      In the expression: count (Proxy :: Proxy (Either Bool Bool))
20:36:24 <c_wraith> Oh.
20:36:29 <c_wraith> > let count :: forall proxy a. (Enum a, Bounded a) => proxy a -> Int ; count _ = fromEnum (maxBound :: a) in count (Proxy :: Proxy Char)
20:36:30 <lambdabot>  1114111
20:36:31 <Bashmetim> Here's the actual function I tried to write:
20:36:33 <Bashmetim> modEnum :: (Bounded a, Enum a) => Int -> a
20:36:33 <Bashmetim> modEnum n = toEnum $ n `mod` biggest where biggest = fromEnum (maxBound :: a)
20:36:58 <nolraiVM> That should work..
20:37:15 <c_wraith> Not quite.  It would need ScopedTypeVariables
20:37:23 <c_wraith> And then a forall a. in the type signature
20:37:28 <nolraiVM> Well yes.
20:38:00 <Bashmetim> Hm. So that's not invalid, it just requires an extension?
20:38:24 <nolraiVM> Yeah, or proxy stuff like the above.
20:39:13 <Sprog> http://hastebin.com/ecozohecap.hs - Does anyone know why this code is giving me a parse error (possibly incorrect indentation or mismatched brackets)?
20:40:22 <c_wraith> Sprog: did you use tab characters?
20:42:41 * hackagebot toysolver 0.3.0 - Assorted decision procedures for SAT, Max-SAT, PB, MIP, etc  http://hackage.haskell.org/package/toysolver-0.3.0 (MasahiroSakai)
20:42:49 <Pamelloes> Is there a way to make a map between (Type1 a) and (Type2 a) where each entry has a fixed value for a, but the Map as a whole does not?
20:43:14 <rui3> Trying to install text-icu and it says it can't find C libraries icuuc, icui18n, icudata. But libicu-devel is yum-installed
20:43:23 <Pamelloes> e.g. Map (forall a. (Type1 a) (Type2 a))
20:43:28 <rui3> in the standard location
20:43:38 <rui3> any tips on how to look into what's missing?
20:44:42 <Pamelloes> rui3: Double check the headers are in your $PATH, just to be sure.
20:47:23 <Zemyla> Hmm. Is it kosher to, if you have a Monad with a hand-written Applicative instance, say {-# RULES "whatever" ap = (<*> :: f (a -> b) -> f a -> f b) #-} ?
20:48:59 <c_wraith> I doubt such a rule would fire very often.  People don't generally use ap explicilty.
20:49:20 <c_wraith> You really want something like ApplicativeDo
20:49:37 <c_wraith> Which is almost certian to be in ghc 7.12, since Simon Marlow is pushing pretty hard for it.
20:49:41 <c_wraith> *certain
20:58:02 <kadoban> It seems confusing to figure out what ApplicativeDo desugars into, heh.
21:00:56 <Sprog> c_wraith, nope. tabs -> spaces
21:03:42 <nolraiVM> Ugh. "glib-0.13.0.1" doesnt install
21:04:03 <nolraiVM> It appears to not even build.
21:08:14 <rui3> Pamelloes: Thanks... So, if the cabal file says it needs extra-libraries "xxx", exacly what files am I looking for in the PATH?
21:10:58 <Pamelloes> rui3: Well, if the library is installed, it will have put its header files somewhere like /usr/local/include. Once you find the headers, ensure the directory is in the path.
21:12:03 <Pamelloes> rui3: so if you found /usr/local/include/mylib/mylib.h, you would add /usr/local/include to your path and if the header was in /usr/include/mylib/mylib.h, you would add /usr/include to your path.
21:12:05 <Pamelloes> Make sense?
21:13:12 <Pamelloes> rui3: You are on a unix-esque system, right?
21:13:27 <rui3> Pamelloes: I am on Fedora
21:14:00 <Pamelloes> Good, if you were on Windows everything I just said would be wrong :P
21:15:14 <rui3> Pamelloes: I am not sure where it is installed, but at least its shared libraries are on /usr/lib64, under names such as libicuio.so
21:15:47 <Pamelloes> rui3: Is the issue in compiling or linking?
21:16:16 <rui3> Pamelloes: Configuring ?
21:16:29 <rui3> (Cabal)
21:16:45 <Pamelloes> rui3: What error is Cabal printing?
21:17:49 <rui3> Pamelloes: Missing dependencies on foreign libraries
21:18:02 <rui3> Missing C libraries: icuuc, icui18n, ...
21:18:16 <rui3> (the 3 listes on extra-libraries section of the cabal file)
21:20:06 <Pamelloes> rui3: Alright, for those to work, then you need to have it find the binary files (in /usr/lib64). Is /usr/lib64 in your path?
21:22:39 <rui3> Pamelloes: No, and if I do cabal install text-icu --extra-lib-dirs="/usr/lib64", configuring succeeds :). However,  I get another cryptic error
21:22:58 <rui3> Break.hsc:50:26: fatal error: unicode/ubrk.h: No such file or directory
21:23:32 <Pamelloes> rui3: So that's what I was talking about earlier. You need to add the header files to the path as well
21:23:54 <Pamelloes> Check /usr/include and see if there's unicode/ubrk.h there
21:24:02 <rui3> Pamelloes: Let's see it ubrk.h is somewhere
21:24:27 <rui3> Pamelloes:  YEAHH
21:25:21 <Pamelloes> rui3: So then, if you add /usr/include with --extra-include-dirs everything should compile :)
21:25:35 <Pamelloes> (that parameter might be wrong...)
21:26:04 <rui3> Pamelloes: Now its missing libstdc++, but I have a clue how to proceed :) thakx
21:26:21 <Pamelloes> rui3: No problem, glad I could help :)
21:28:41 <rui3> Pamelloes: nope. Different error
21:28:52 <rui3> error while loading shared libraries: libstdc++.so.6: cannot open shared object file: No such file or directory
21:29:14 <rui3> Yet it is there in /usr/lib64 (already added to lib-dirs)
21:29:31 <Pamelloes> Weird.
21:29:32 <rui3> is a symlink to libstdc++.so.6.0.20 which is also there
21:32:42 <Pamelloes> rui3: Unfortunately, I don't really know where to proceed from here. I've never had this issue :(
21:32:53 <Pamelloes> Perhaps someone else here who is more knowledgable could take over
21:33:28 <rui3> Pamelloes: thanks anyway :). It seems I can't run away from cabal hell.
21:33:36 <Zekka> jmcarthur: Haven't finished the code it's used in yet, but I finished a java implementation of your structure that supports some extra ops
21:33:48 <Zekka> You've most likely saved me a ton of time and effort!
21:33:52 <Zekka> Thanks.
21:33:56 <Pamelloes> rui3: Not technically cabal hell, but still a pain ;)
21:34:05 <rui3> I was hoping to avoid learning all there is to know about cabal before being able to play around but
21:34:40 <jmcarthur> Zekka: awesome! you're welcome
21:34:55 <Zekka> jmcarthur: Notable omissions from your current implementation -- a remove operation
21:35:05 <Zekka> I've written one, I'm not sure that it's correct although it passes my nonexhaustive test
21:35:15 <jmcarthur> Zekka: well, you can use view and then concat the left and right parts
21:35:26 <jmcarthur> Zekka: but yeah, i intend to add tons of convenient functionality like that eventually
21:35:41 <Zekka> jmcarthur: I meant 'remove by key' as in, doing a search
21:35:51 <jmcarthur> ah
21:35:59 <jmcarthur> well, that's a linear time operation, right?
21:36:18 <Zekka> jmcarthur: It is? I thought it was O(log n)
21:36:33 <Zekka> My code is hideous Java although I can send it to you if you want to check if it's correct, or I can tell you the idea
21:36:41 <jmcarthur> i bet one could construct a linear time case for it
21:36:48 <Pamelloes> GHC just told me "My brain just exploded". I'm kind of disturbed.
21:36:51 <Zekka> Isn't it about the same principle as searching a binary search tree though?
21:36:54 <jmcarthur> unless your implementation is just not the same as mine
21:37:10 <jmcarthur> i guess it's doable if your keys are sorted, but then you don't need a stable heap anyway
21:37:11 <Zekka> I guess you can build a tree that's so unbalanced the search is linear
21:37:24 <jmcarthur> it's not really about balance at all
21:37:41 <jmcarthur> the tree is only structured to make deleteMin O(log n). it's not a search tree
21:38:11 <jmcarthur> if it happens that your keys are sorted, it can be used as a sort of search tree, and i think it might even be O(log n) then
21:38:22 <Zekka> jmcarthur: It's not? Oh. I wrote my remove operation assuming it was a search tree
21:38:32 <jmcarthur> but if they are known to be sorted, then you could have just used a binary search tree or Data.Sequence
21:38:38 <Zekka> That's disappointing! I wanted remove to be O(log n)
21:38:51 <jmcarthur> you can remove the minimum in O(log n)
21:39:07 <dzack> anyone else use ghc-mod+vim? getting weird errors related to c preprocessing
21:39:45 <Zekka> This is still likely to be useful, but much less
21:40:57 <Zekka> I'm not going to be up much longer, but if you can suggest a list or heap-like data structure where remove for an arbitrary element by key (for a heapy thing) or value (for a listy thing) is O(log n), I'll investigate it
21:43:04 <Zekka> It looks like a finger tree might be closer to what I want
21:43:37 <Zekka> But I don't know yet that it is (still googling!)
21:44:25 <kadoban> You could easily do that with two linked BSTs, unless I'm missing something. One indexed by key, one indexed by value.
21:44:34 <kadoban> I would imagine there's something nicer though.
21:44:52 <Zekka> kadoban: I remember eliminating that for some reason earlier, trying to think of why
21:45:03 <c_wraith> Zekka: Data.Sequence is a finger tree.
21:45:12 <Zekka> Oh yeah, that's right, order matters
21:45:26 <jmcarthur> Zekka: so let me make sure i understand. you want to keep the keys in a sequence, not ordered, and you want to be able to find an arbitrary key to remove in O(log n), and you want to be able to modify the minimum really fast?
21:45:45 <Zekka> c_wraith: I'm not in Haskell but finger trees look more widely implemented
21:45:49 <kadoban> You can have order matter in a BST? I'm not really quite sure what you mean by "order matters" though.
21:46:15 <jmcarthur> kadoban: i think he wants to have a sequence, not a set.
21:46:24 <Zekka> kadoban: I have an order in mind not determined by what the elements are -- it's ordered in the sense that the list "hello world" is
21:46:27 <jmcarthur> *(s)he
21:46:35 <kadoban> Ah
21:46:40 <Zekka> I'd like to be able to remove for instance 'l' in log n time
21:47:00 <Zekka> I'd like to be able to have duplicate elements although this isn't necessarily needed
21:47:19 <Zekka> Fast random access would be nice but in practice I'm probably mostly going to be going through the elements in order
21:47:32 <jmcarthur> Zekka: so you could have a fingertree with two measures. one is the minimum element, and the other is an index. pair that with a map from keys to indexes, and i think you can do it
21:47:46 <niqbal> quick question regarding ‘atomically'
21:47:48 <Zekka> If it's necessary for some elements to be removable faster than others, I have an ordering (or numeric ranks) for that
21:47:53 <niqbal> why cannot we nest it?
21:48:06 <jmcarthur> niqbal: what does it mean to nest it?
21:48:07 <niqbal> i.e., why does calling atomically on STM returns IO (instead of STM
21:48:14 <rvxi> hello
21:48:21 <Zekka> jmcarthur: Let me look at Sequence in Haskell (which people seem to be telling me is a specific case of finger trees) and see how close that is to what I want
21:48:28 <niqbal> hi @jmcarthur  does my question make sense?
21:48:35 <Zekka> Thanks for being so patient!
21:49:00 <jmcarthur> niqbal: yes, it does. i am using the socratic method to explain
21:49:08 <niqbal> ok. 
21:49:09 <Cale> niqbal: Because that's how you execute a transaction.
21:49:40 <Cale> niqbal: Otherwise, it'd just be the identity function.
21:49:45 <Zekka> One sec, going to write a quick sample program using Data.Sequence and annotate it with what my performance expectations are
21:50:23 <Cale> niqbal: If you want a function STM a -> STM a such that executing the resulting transaction will result in the supplied transaction occurring as if atomically, then id will do that for you :)
21:50:33 <Cale> (because STM actions only ever occur as if atomically)
21:50:43 <niqbal> hmm. i am thinking along this lines. if i had a method to atomically withdraw money (or do whatever complex) and another method to atomically create an account. I won’t be able to compose these two inside atomically in a third method 
21:50:47 <jmcarthur> Zekka: well, data.sequence won't do everything you need
21:50:59 <Zekka> You might be able to tell, I'm in a situation where O(1) is great, O(log n) is fine, and O(n) is dire
21:50:59 <Cale> niqbal: Not if you had them as IO actions, no
21:51:10 <Cale> niqbal: But if you had the STM actions, then you can put them together
21:51:18 <niqbal> right. that’s where i am confusing. 
21:51:19 <Zekka> jmcarthur: What parts doesn't it do? I have a feeling I'm going to discover them pretty quickly during this annotation exercise
21:51:39 <jmcarthur> Zekka: there is no fast way to get the minimum or to search for an arbitrary key
21:51:51 <niqbal> so it means that i can have most of my code without atomically and compose/call them with atomically whereever I need
21:52:03 <Cale> Yeah
21:52:08 <niqbal> cool thanks. 
21:52:09 <jmcarthur> Zekka: data.sequence just gives you constant time access to the ends of the sequence and logarithmic time access to an arbitrary element by index
21:52:12 <Cale> Though in reality, you want to be very careful
21:52:21 <niqbal> how/ @Cale 
21:52:21 <Zekka> jmcarthur: And a fast split operation in splitAt, right?
21:52:36 <jmcarthur> Zekka: that would be the way to access an arbitrary index, yes
21:52:41 <Cale> If transactions are very long-running, they are more likely to be trampled on by shorter transactions, and never actually get to commit.
21:52:50 <jmcarthur> Zekka: oh, and logarithmic time concat
21:53:06 <jmcarthur> s/concat/append/
21:53:13 <Cale> The system will still make some sort of progress because the shorter transactions will be committing
21:53:15 * hackagebot satchmo-toysat 0.2.1.0 - toysat driver as backend for satchmo  http://hackage.haskell.org/package/satchmo-toysat-0.2.1.0 (MasahiroSakai)
21:53:20 <Zekka> jmcarthur: Right, meaning that if I make finding the index of a key constant-time using a map, then my removal operation is logarithmic?
21:53:36 <jmcarthur> Zekka: yes
21:53:42 <jmcarthur> Zekka: so that covers everything by find min
21:53:48 <jmcarthur> Zekka: i guess you could do that with the map too
21:53:53 <jmcarthur> Zekka: but it's O(log n)
21:54:01 <Zekka> jmcarthur: "covers everything by find min"?
21:54:03 <niqbal> ok. Thanks. @Cale  that was helpful. 
21:54:08 <jmcarthur> *but find min
21:54:13 <Zekka> jmcarthur: Right, because I'm probably using a tree map, not a hashtable?
21:54:16 <jmcarthur> Zekka: i guess that's fine, actually
21:54:29 <jmcarthur> Zekka: hashtables find the minimum in linear time
21:54:34 <niqbal> one more question @Cale , why does running atomically  converts STM() into IO
21:54:36 <jmcarthur> Zekka: because they aren't even ordered
21:54:49 <Cale> niqbal: As opposed to what?
21:54:52 <niqbal> my code doesn’t have any IO
21:54:56 <Zekka> jmcarthur: There's not an immutable performant hashtable though, right?
21:54:59 <niqbal> couldn’t it just make () 
21:55:01 <Cale> niqbal: Sure it does
21:55:02 <niqbal> or sort of vod
21:55:04 <niqbal> void
21:55:07 <Cale> Converting to () would be meaningless
21:55:08 <jmcarthur> Zekka: i don't know why you want one?
21:55:19 <jmcarthur> Zekka: there is one, but i suspect you don't want it
21:55:32 <Cale> Every function of type A -> () which produces a defined result is equivalent to const ()
21:55:34 <jmcarthur> Zekka: at least not if you want to find min
21:55:36 <niqbal> i am changing state of a TVar so I don’t need any return type anyways. 
21:55:45 <Zekka> jmcarthur: Doesn't a tree map give me a pretty cheap find min anyway?
21:56:01 <Cale> A function  STM a -> ()  is necessarily  (\x -> ())
21:56:03 <jmcarthur> Zekka: yeah, O(log n). that's why i'm saying you probably don't want a hashtable
21:56:17 <Cale> (pretty much, it could also just be undefined, or const undefined)
21:56:55 <jmcarthur> Zekka: by the way, a fingertree is going to have an order of magnitude overhead compared to my stable heap. :( is there no way to avoid needing remove?
21:57:03 <Cale> niqbal: Basically () doesn't have enough structure as a type to express what it was that your STM action was going to do, because there's only one defined value of that type
21:57:04 <niqbal> but what is the use of IO() ; as that is also empty/ 
21:57:09 <Cale> hm?
21:57:19 <Cale> No, there are *many* values of type IO ()
21:57:20 <nolraiVM> It does something.
21:57:31 <Cale> As many as there are programs to make your computer do something, pretty much
21:57:32 <Zekka> jmcarthur: Nah, the reason I need this crazy data structure is because I've got a really big record of data I don't want to copy a whole lot but I want to be able to cheaply remove and/or replace from
21:57:40 <niqbal> really. how? can you give some examples. 
21:57:45 <DrPavelheer> Think of a void function in other languages
21:57:51 <Zekka> So I want to minimize the amount of time spent copying this giant scary record, but still replace its contents
21:57:52 <DrPavelheer> It doesn't return anything, but it does something
21:57:59 <Cale> niqbal: A value of type IO t is a description of some things which could be done in order to produce a result of type t, assuming that it terminates normally.
21:58:09 <niqbal> ok. 
21:58:11 <jmcarthur> niqbal: putStrLn "foo"   and   putStrLn "bar"   have type IO () but don't mean the same thing
21:58:27 <Cale> niqbal: An IO String is as much like a String as /bin/ls is like a list of files
21:58:38 <niqbal> thanks both. this is where i start confusing monad
21:58:43 <niqbal> but that example is good
21:59:02 <niqbal> cool thank you. and good night
21:59:23 <Zekka> jmcarthur: Actually, I have another wrench to throw into this, let me write up some details
22:05:09 <Zekka> jmcarthur: Never mind! The wrench is not as bad as I thought.
22:05:19 <jmcarthur> yay!
22:05:52 <Zekka> There's another potential wrench but I won't know how bad it is until I try to do an implementation
22:05:58 <Zekka> it could be really hellishly awful or pretty mild
22:06:02 <poincare101> I'm a newbie to Haskell and I'm struggling a little bit with random numbers. This is my incomplete code right here: http://pastie.org/10215844 Now, the issue is that I actually want randomizeVariable to return the value that "getValueIndex" returns. How do I 'wrap' it in an IO monad?
22:07:34 <Cale> poincare101:  return :: a -> IO a  constructs an IO action which does nothing when executed except to produce the given value as its result.
22:08:12 <Pamelloes> Is there a way to find out where an undefined occured?
22:08:18 <Cale> poincare101: You could probably just write   return (getValueIndex dist randVal)  there.
22:08:40 <poincare101> Cale: oh perfect
22:08:55 <niqbal> i am back
22:09:03 <niqbal> is it possible to create an object of this type: type Acct = (String, TVar Double)
22:09:09 <Cale> Pamelloes: Not so easily... you can try building with profiling and running the program with +RTS -xc
22:09:15 <poincare101> This seems to be a really good description of the IO monad: https://wiki.haskell.org/IO_inside
22:09:19 <poincare101> who wrote it?
22:09:32 <Pamelloes> Cale: Hm... Sounds like a problem for tomorrow! :D
22:10:00 <niqbal> ((“niqbal”), atomically (newTVar 3)) is of type :: Num a => ([Char], IO (TVar a))
22:10:34 <Cale> poincare101: Bulat Ziganshin, iirc
22:10:46 <Cale> poincare101: But I'm not sure I share your opinion about it :P
22:11:02 <poincare101> Cale: really? It made sense to me. I'm not sure if it is entirely accurate, however.
22:11:07 <Zekka> jmcarthur: Overhead really is killer, it looks like, though -- maybe I'll throw your stable heap in for data that's heuristically likely to be small
22:11:37 <Zekka> The big scary record is either like ten thousand points of data (in which case log n is good, k is meaningless!!!!) or four (in which case log n is who cares, k is bad!!!!)
22:11:55 <Zekka> It's rarely in-between
22:12:05 <jmcarthur> Zekka: for something like four, i'd consider just using an array or list or something simple
22:12:39 <Zekka> jmcarthur: It's probably not a bad idea. Most of today was about obsessing over the really big case
22:13:40 <Cale> poincare101: Well, I guess there are some disclaimers about the RealWorld stuff at least. It doesn't do a great job of maintaining a distinction between the words "evaluation" (the process of reducing expressions to values for the purposes of pattern matching), and "execution" (carrying out the instructions described by IO action values, causing the described effects to occur)
22:14:14 <verement> niqbal: atomically (newTVar 3) >>= \tvar → return ("niqbal", tvar)
22:14:49 <poincare101> Cale: Hmmm...the distinction between the two never really crossed my mind as I read the article so I guess that criticism makes sense
22:15:02 <verement> niqbal: also consider newTVarIO
22:15:16 <niqbal> ok. 
22:15:30 <niqbal> i am wondering, if I should keep the atomic outside i.e., type Acct2 = TVar (String, Double)
22:16:32 <niqbal> that also seems to do what i wanted to do. 
22:16:42 <niqbal> (i.e, create a structure for account name and balance). 
22:16:50 <niqbal> thanks
22:17:26 <Cale> poincare101: The RealWorld -> (RealWorld, a) thing is a pretty shaky mental model. It's generally better to picture values of type IO t as being just like abstract syntax for a program that will compute a value of type t when executed.
22:18:12 <poincare101> Cale: I'll be taking category theory this fall - will that help my understanding of monads?
22:18:13 <Cale> poincare101: Evaluating an expression of type IO t won't do much which is visible apart from warm up your CPU a bit -- it's basically putting that program into some normal form where it can begin to be executed
22:18:28 <aspidites> so a whole day later...i'm on nixos now
22:19:21 <Cale> poincare101: Well, yes, though if your intention is just to understand monads for programming, there's really not a whole lot to it apart from just getting a bunch of examples under your belt.
22:20:07 <poincare101> Cale: I'd like to understand the reasoning for using monads to model state-based computations
22:20:22 <Cale> Well, it's more the other way around...
22:20:34 <Cale> Our models of stateful computations *happen* to be monads
22:20:41 <Cale> At least some of them.
22:21:08 <Cale> The fact that they're monads doesn't really tell you a heck of a lot about them
22:22:24 <Cale> (similar to how knowing that something is a group or monoid doesn't tell you all that much)
22:22:54 <Cale> It just says that there exist some operations with certain shapes that follow some laws
22:24:04 <Cale> From the Haskell point of view, a monad is just a type constructor M together with a pair of (polymorphic) functions,  return :: a -> M a, and  (>>=) :: M a -> (a -> M b) -> M b, satisfying three laws
22:24:31 <Cale> Specifically,  return v >>= f = f v
22:24:39 <Cale> x >>= return = x
22:24:53 <Cale> and  (x >>= f) >>= g = x >>= (\v -> f v >>= g)
22:25:33 <Cale> Any type constructor with operations of those shapes satisfying those laws is a monad
22:25:44 <Cale> Why do we care?
22:26:13 <Cale> Well, there's a bunch of stuff which you can write in terms of return and (>>=) which turns out to be useful in various ways for all the instances of monads that we've found.
22:26:27 <Cale> So it saves us writing various functions over and over in different contexts
22:26:51 <Cale> As a simple example, there's  sequence :: Monad m => [m a] -> m [a]
22:27:27 <Cale> For m = IO, it takes a list of IO actions, and produces an IO action which when executed will execute each of the actions in the list in turn, and collect a list of the results
22:28:02 <Cale> for m being [], the list monad, it takes a list of lists, and picks an element from each one in all possible ways, getting a list of results:
22:28:08 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
22:28:10 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
22:29:11 <Cale> For m being Parser, it will take a list of Parsers each of which parses a value of type a, and produce a parser for the concatenation of the languages matched by the parsers, producing a list of the results.
22:29:27 <Cale> and so on
22:29:48 <Cale> What exactly it does will depend on the definition of return and (>>=), but it's usually interesting regardless.
22:31:03 <Cale> and there's a whole library of stuff like that, which we can write independently of a choice of monad, which is nice, because it gets pulled in for free whenever we recognise this pattern, and it's a pattern which shows up in a lot of libraries in the style of functional programming.
22:31:56 <Cale> So how does sequence work? Well, we can think in terms of IO actions, and come out with something more general:
22:32:20 <Cale> sequence [] = return [] -- if the list of actions is empty, just produce the action which does nothing except to produce an empty list as its result
22:32:42 <Cale> sequence (x:xs) = ... -- if the list of actions is nonempty ...
22:33:02 <Cale> sequence (x:xs) = do v <- x; ... -- first execute the action x at the start of the list ...
22:33:17 * hackagebot memory 0.6 - memory and related abtraction stuff  http://hackage.haskell.org/package/memory-0.6 (VincentHanquez)
22:33:24 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; ... -- then execute the rest of the list of actions, getting a list of results vs
22:34:12 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs) -- and finally combine the first result v with the rest of the results vs, producing that as the result of our combined action.
22:34:43 <Cale> Note that this do-notation is just syntax sugar for applying (>>=)
22:34:48 <Cale> @undo do v <- x; vs <- sequence xs; return (v:vs) 
22:34:48 <lambdabot> x >>= \ v -> sequence xs >>= \ vs -> return (v : vs)
22:36:50 <Cale> So, for different monads, this will do different stuff, but it'll always have some amount of flavour of "glue this list of actions together somehow into one which runs them all and collects the results into a list"
22:37:26 <Cale> What an action is, and what "running" means being different in each case.
22:37:48 <Cale> In the case of lists, you can imagine that "running" a list means to pick an element from it in all possible ways
22:38:21 <Cale> (this computational interpretation tends to work out reasonably well for all the monads we use in Haskell of course)
22:38:32 <Cale> poincare101: Still here?
22:39:42 <saulzar> There definitely seems to be two groups of people in the Haskell community, those who understand at the level of "glue this...",  and those who understand the abstractions at a deeper level. 
22:41:03 <Cale> Well, which deeper level are you referring to? The general category theoretic definition?
22:42:18 <saulzar> Yeah, well - it's not just Monads - I think, but how all the various abstractions relate to each other.
22:43:45 <saulzar> Not having any mathematical background, for example - I find almost anything theoretical written by Edward Kmett to be quite mysterious, though Monads/Functors etc. and various other things I can happily make use of in Haskell code 
22:46:06 <ReinH> saulzar: I think there is actually a spectrum of levels of understanding :)
22:46:30 <Cale> Well, I don't know if it's encouraging or not, but there are plenty of people *with* mathematical backgrounds who would have trouble following a lot of the stuff Edward writes about, since it comes out of considering the interaction between the abstract pictures from mathematics and Haskell. Often he ends up stomping pretty hard on some fancy abstraction to get it to fit entirely within the confines of Haskell somehow,
22:46:30 <Cale>  and then it takes insight and consideration to figure out what the result means.
22:46:48 <ReinH> For instance, I understand many of the abstractions at what I would consider to be a relatively deep level, but still have trouble with some of the Kmettoverse.
22:47:14 <ReinH> Ok, most of the kmettoverse.
22:47:36 <ReinH> Cale: yeah, tbh my most common reaction to his stuff is "Wait, you can *do* that?"
22:47:37 <saulzar> I see
22:48:31 <Cale> saulzar: Not to mention that there's no guarantee that what you end up with is useful, but, that strangely is often enough that 
22:48:40 <Cale> it's worth trying :)
22:48:50 <pingu> If there is a kmettoverse, is there sucha thing as kmettology?
22:48:59 <pingu> The church of the flying comonad?
22:49:30 <ReinH> The Kmett giveth (unit) and the Kmett taketh away (counit)
22:49:48 <pingu> We let the monads bind us
22:49:52 <Cale> It's the most remarkable thing about category theory, that it's full of these very generic definitions which if you can sort out how they apply to your particular area of mathematics, they're more often than not important things to consider which you might have overlooked.
22:50:59 <ReinH> Our father, which art in Hask. Faithful be thy functors. Ok, I think I'm getting a little carried away.
22:51:21 <pingu> Or maybe not... If scientology gets a cult, why not us?
22:52:01 <Cale> Functional programmers already have the Church of the Least Fixed Point.
22:52:13 <pingu> Oh that's right.
22:53:13 <pingu> http://liyang.hu/church.xhtml
22:53:16 <pingu> That's pretty good
22:54:22 <ReinH> That's actually pretty amazing.
22:54:27 <Jeanne-Kamikaze> what the
22:54:29 <ReinH> The Why Combinator. Genius.
22:57:10 <ReinH> Cale: btw the type of `forever' is my new favorite thing for discussing monads and parametricity
22:58:47 <dzack> pingu: haha, glorious
23:00:22 <Cale> ReinH: I'm glad that it still has the type that it does, when so many other things have been spoiled by people who don't appreciate parametricity quite so much.
23:00:37 <ReinH> :(
23:00:48 <kadoban> :t forever
23:00:50 <lambdabot> Monad m => m a -> m b
23:00:55 <Cale> (forkIO pls)
23:01:00 <ReinH> heh
23:01:03 <ReinH> :t forkIO
23:01:04 <lambdabot> Not in scope: ‘forkIO’
23:01:09 <kadoban> Heh, that is a nice type.
23:01:13 <Cale> :t Control.Concurrent.forkIO
23:01:15 <lambdabot> IO () -> IO GHC.Conc.Sync.ThreadId
23:01:20 <ReinH> Oh. :(
23:01:33 <ReinH> But you're throwing it away anyway...
23:01:47 <saulzar> As opposed to m () -> m () ?
23:01:57 <Cale> saulzar: As opposed to  IO a -> IO ThreadId
23:02:06 <ReinH> I think saulzar meant forever
23:02:11 <Cale> ah
23:02:15 <Cale> heh, yeah
23:03:48 <ReinH> Given its type, forever can only do exactly what it does (or be less defined).
23:03:58 <saulzar> What advantage does m a -> m b have?    over m () -> m () (or over m a -> m ()) ?
23:04:35 <Cale> saulzar: We can tell from the type that forever does not care about the result of the action you give it, and we can also tell that it will not produce a result of its own.
23:04:37 <exio4> Monad m => m () -> m () could be just the identity function
23:04:50 <saulzar> Ahh
23:04:52 <ReinH> :t const (return ()) :: Monad m => m a -> m ()
23:04:53 <lambdabot> Monad m => m a -> m ()
23:04:58 <ReinH> is not what I expect forever to do
23:05:03 <saulzar> That makes sense
23:07:02 <ReinH> m a -> m b says that it either never terminates or terminates only due to a change in the m value (like returning Nothing).
23:08:05 <ReinH> > forever Nothing
23:08:06 <lambdabot>  Nothing
23:08:24 <ReinH> Since a defined value of type b can never be produced
23:35:58 <Isaacary> hey guys bit of a newbie here
23:36:50 <Isaacary> I was wondering because i have a couple of exams coming up for uni if anyone has any tips about late minute study
23:37:38 <pacak> Isaacary: Get a time machine, start studying a few months earlier.
23:38:13 <Isaacary> Pacak it would be nice :(
