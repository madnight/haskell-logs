00:00:21 <nocturne777> In modern Haskell, is it still a good practice to avoid relying on fail to not crash the program?
00:00:39 <abhillman> On line 31, I believe the binding to probabilities is not bound unless the else branch is evaluated -- is that correct? In general, that line will give an error if it were executed when time == 0 -- it is not in fact being executed based on tests, but was wondering in general if there is anything "extra" to do -- for example avoiding this in some other way
00:00:54 <jle`> nocturne777: what do you mean by that?
00:01:13 <nocturne777> jle`: http://www.randomhacks.net/2007/03/10/haskell-8-ways-to-report-errors/ ==> Item 4
00:01:34 <dmj`> nocturne777: yea, some monads use error to report failure, some don't, best to avoid
00:01:37 <jle`> omg, 2007
00:01:41 <pacak> abhillman: on line 31 if function you are mapping with makes sense on it's own - you can put it into where as well
00:02:42 <nocturne777> to be able to generalize error handling, is it better to rely on MonadError as opposed to just declaring Either SomeErrorType Int ?
00:03:14 <abhillman> Thanks for all your help this evening! Take care, all.
00:03:20 <aawe> good morning
00:03:31 <pacak> Midday...
00:03:37 <jle`> you too abhillman !
00:03:40 <abhillman> ; - )
00:04:05 <nocturne777> like in item 5
00:04:07 * hackagebot keter 1.4.0.1 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.4.0.1 (MichaelSnoyman)
00:06:02 <jle`> the Either SomeError thing is used by a lot of common libraries, like binary, text, etc.
00:06:10 <jle`> definitely ddo'nt use Either String
00:07:41 * hackagebot hipbot 0.3.0.2 - A library for building HipChat Bots  http://hackage.haskell.org/package/hipbot-0.3.0.2 (purefn)
00:07:41 * hackagebot keter 1.4.0.1 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.4.0.1 (MichaelSnoyman)
00:08:30 <nocturne777> jle`:  but do you think it's worth relying on MonadError as in "computeSth :: MonadError LengthError m => String -> m Int" ?
00:09:12 <jle`> it just looks a little silly to me...i guess it's sort of like providing functions as IO instead of MonadIO
00:09:13 <nocturne777> this way I don't change the code if I need to use something other than Either
00:09:30 <jle`> if you're talking about exporting things as library functions, then maybe Either is okay
00:09:40 <jle`> but if you're talkinga bout internal use for yourself in your project, then i guess MonadError has some advantages there
00:10:52 <nocturne777> but even in the case of exporting a library function, it gives the client code freedom
00:11:59 <jle`> i guess that's true, as Either is an instance.  i guess in a sense it's the same thing as providing MonadIO's instead of IO's
00:12:02 <johnw> I'd think MonadError is usually used by a consumer of error information, who doesn't care where it's coming from; not a provider of error information who expects the caller to determine the type.  I mean, I can see there maybe being some value to that, but I doubt you'd parameterize that as much as you might think.  Either has lots of utility.
00:13:57 <johnw> no, scratch that, I'm not sure really why you'd want the abstraction of MonadError
00:14:07 <mjrosenb> does the main thread have a thread id that can be killed?
00:14:32 <johnw> ask myThreadId
00:14:37 <johnw> and give it a try
00:15:39 <mjrosenb> every time I call myThreadID, I get a different answer?
00:15:55 <johnw> between executions?
00:16:02 <johnw> or in the same execution?
00:16:04 <jle`> are you on ghci?
00:16:13 <mjrosenb> jle`: yes.
00:16:32 <johnw> it's probably spawning threads to evaluate each input
00:16:33 <jle`> yeah, i think ghci makes a new thread for every command
00:16:41 <jle`> if you do it in `main`, then it'll be the same one
00:17:14 <mjrosenb> jle`: what do you mean by do it in main?
00:17:39 <nocturne777> johnw: we could change our error handling strategy to use a different monad and in this case we do not need to change the code that returns error
00:18:13 <nocturne777> johnw: that's the main reason why one might want the abstraction that comes with MonadError
00:18:15 <jle`> main = do
00:18:23 <jle`>     x <- myThreadId
00:18:28 <jle`>     y <- myThreadId
00:18:33 <jle`> x and y should be the same
00:19:57 <dmj`> > myThreadId >>= killThread
00:19:59 <lambdabot>  Not in scope: ‚ÄòmyThreadId‚ÄôNot in scope: ‚ÄòkillThread‚Äô
00:22:39 <dmj`> ghc -e can only evaluate expressions in the context of the prelude?
00:23:00 <dmj`> would be really helpful if it could do so w/ other modules as well
00:37:36 * hackagebot json-autotype 1.0.1 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-1.0.1 (MichalGajda)
00:37:38 * hackagebot yesod-bin 1.4.9 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.9 (MichaelSnoyman)
00:42:36 * hackagebot cf 0.3 - Exact real arithmetic using continued fractions  http://hackage.haskell.org/package/cf-0.3 (mvr)
01:04:55 <mjrosenb> when I kill a thread with killThread, it looks like in ghc, it just delivers an exception
01:05:05 <mjrosenb> does anyone know which exception is being used?
01:05:07 <johnw> that is what killThread does
01:05:24 <johnw> ThreadKilled
01:05:34 <johnw> killThread tid = throwTo tid ThreadKilled
01:05:48 <johnw> and it's an async exception
01:06:12 <mjrosenb> good to know.
01:06:25 <jle`> ThreadKilled :: AsyncException
01:09:36 <mjrosenb> Is there anything else that throws an AsyncException?
01:10:42 <jle`> yeah, you can look at the constructors for the AsyncException type to get a nice picture
01:10:57 <jle`> they should be in the docs for Control.Exception
01:27:38 * hackagebot yesod-bin 1.4.9.1 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.9.1 (MichaelSnoyman)
01:38:49 <xelxebar_> I feel dirty writing (f <*> id) . g, is there an operator or something I should be using instead of `<*> id`?
01:42:30 <jle`> :t (<*> id)
01:42:31 <lambdabot> (a -> a -> b) -> a -> b
01:42:38 <jle`> @djinn (a -> a -> b) -> a -> b
01:42:38 <lambdabot> f a b = a b b
01:42:52 <jle`> looks like join
01:43:04 <jle`> @pl \f x -> f x x
01:43:04 <lambdabot> join
01:44:45 <jle`> @. pl . djinn type (<*> id)
01:44:46 <lambdabot> f = join
01:46:15 <xelxebar_> jle`: Thank you. These @ commands are magical.
01:46:29 <jle`> haha yeah they pull together a lot of nice resources
01:46:50 <Axman6> @djinn Maybe (a -> b) -> Maybe a -> Maybe b
01:46:51 <lambdabot> f a b =
01:46:51 <lambdabot>     case a of
01:46:51 <lambdabot>     Nothing -> Nothing
01:46:51 <lambdabot>     Just c -> case b of
01:46:51 <lambdabot>               Nothing -> Nothing
01:46:52 <lambdabot>               Just d -> Just (c d)
01:47:38 * hackagebot tokenify 0.1.2.0 - A regex lexer  http://hackage.haskell.org/package/tokenify-0.1.2.0 (akst)
01:49:14 <jle`> happy it didn't infer f _ _ = Nothing
01:49:24 <jle`> thank you for being a good bot, djinn
01:49:37 <jle`> s/bot/library
01:52:23 <Cale> jle`: Yeah, it generates a bunch of the solutions and then scores them to try to avoid that a bit.
01:54:14 <mjrosenb> gah.
01:54:28 <mjrosenb> one of these days I'll remember to use pure, and not fmap
01:54:52 <mjrosenb> or at least figure it out before I've stared at the type error for like 5 minutes.
02:01:05 <xelxebar_> @hoogle [a] -> [a]
02:01:06 <lambdabot> Prelude cycle :: [a] -> [a]
02:01:06 <lambdabot> Data.List cycle :: [a] -> [a]
02:01:06 <lambdabot> Prelude init :: [a] -> [a]
02:03:09 <xelxebar_> Is there a reasonable way to find out the number of projects on hackage hosted by the various version control systems?
02:05:48 <xelxebar_> @src cycle
02:05:49 <lambdabot> cycle [] = undefined
02:05:49 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
02:06:07 <xelxebar_> @help slap
02:06:08 <lambdabot> slap <nick>. Slap someone amusingly.
02:06:14 <xelxebar_> @slap jle` 
02:06:15 <lambdabot> why on earth would I slap jle` ?
02:06:41 <xelxebar_> @help tell
02:06:41 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
02:06:59 <xelxebar_> @help more
02:06:59 <lambdabot>  @more. Return more output from the bot buffer.
02:07:21 <xelxebar_> @help eval
02:07:21 <lambdabot> eval. Do nothing (perversely)
02:07:35 <Myrl-chan> Pretty related. The server's made on Haskell, and the drawing is my Haskell anthromorphism. http://myrl.armorhosting.info/
02:08:54 <deezn> Can I ask about some clarification on some haskell code?
02:09:34 <xelxebar_> Myrl-chan: That'pretty nice!
02:10:02 <Myrl-chan> xelxebar_: Thanks. Took me just(lol) 10 hours in paint!
02:10:17 <Myrl-chan> I'll be adding a background later, so that it can be used as a wallpaper.
02:11:31 <Myrl-chan> pyon:If anyone wants to know the code. http://ix.io/iBf
02:12:12 <pyon> Myrl-chan: That paste doesn't work. :-|
02:12:14 <pyon> No, wait.
02:12:20 <pyon> It was just my Internets being slow.
02:12:49 <Myrl-chan> pyon: I forgot to clear the buffer, lol. :P
02:12:56 <xelxebar_> Myrl-chan: If you don't mind a bit of input, I feel a bit like her hands are uncomfortable. I spent a few seconds trying to hold my hands that way. lol. Don't get me wrong though; I totally respect all that effort and it's looking really great.
02:13:42 <xelxebar_> deezn: people here are ridiculously helpful and knowledgeable, usually if you just ask someone will provide a good answer swiftly
02:13:44 <Myrl-chan> xelxebar_: Thanks for the input. I'm still a beginner at drawing, so constructive critcism is very appreciated.
02:14:26 <xelxebar_> @help quote
02:14:27 <lambdabot> quote <nick>: Quote <nick> or a random person if no nick is given
02:14:50 <xelxebar_> @more
02:15:01 <xelxebar_> @help dice
02:15:01 <lambdabot>  @dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
02:15:10 <Myrl-chan> Also, some people told me to put it in /r/haskell, would they appreciate this?
02:15:15 <xelxebar_> @dice 1d20
02:15:15 <lambdabot> xelxebar_: 2
02:15:54 <xelxebar_> Myrl-chan: very likely. That place is also super friendly and helpful.
02:16:00 <Myrl-chan> xelxebar_: Okay, thanks.
02:16:20 <deezn> ok
02:16:56 <Myrl-chan> xelxebar_: Did you position your hand like that where the nail is facing directly upwards?
02:17:59 <deezn> Can someone help me with this GADTs function in.. http://lpaste.net/80654417757470720
02:18:34 <deezn> I am trying to figure out this satisfiable (Forall (x:xs) fml)  line.. 
02:19:13 <deezn> I get that it is supposed to unpack all the Terms and then evaluate if all are true or false.. but I am not too sure on the call with the formula.. 
02:20:11 <xelxebar_> Myrl-chan: I tried to match the bottom fingers being relatively parallel to the ground. Maybe it's a perspective thing? I immediately felt like her hands were close to her chest. Not sure if that's the intention.
02:21:21 <Myrl-chan> xelxebar_: Yeah, the hands are pretty close to her chest.
02:23:17 <xelxebar_> @hoogle Formula
02:23:17 <lambdabot> package radium-formula-parser
02:23:33 <deezn> it is custon defined
02:23:42 <deezn> *custom
02:23:54 <Myrl-chan> Anyways, I drew this to figure out if I should quit drawing... I don't think I should.
02:27:00 <xelxebar_> deezn: I'm having cabal difficulties getting that package installed, otherwise I'd check myself, but does that code compile as is?
02:27:34 <xelxebar_> it looks to me like the line you reference doesn't actually provide a definition for satisfiable...
02:28:15 <xelxebar_> deezn: oh. just saw your comment above
02:29:36 <deezn> **just waiting patiently**
02:30:34 <deezn> Formula is defined.. you can see what it is in the commented out section.. 
02:31:14 <deezn> (there are two files for the solution). but let me add the Term def for clarity
02:31:52 <deezn> ok added code..
02:38:56 <Fylwind> watching edwardk's talk on typeclasses and found it amusing that I'm not the only one who mistypes 'LANGAUGE' all the time :P
02:46:39 <xelxebar_> deezn: In your definition of `Forumla ts` are you deliberately making ts a phantom type variable?
02:48:33 <deezn> the whole thing it to do with gadts
02:49:27 <deezn> i am not 100% up to speed on the whole thing.. I have gotten most of the way through but this satisfiable method has stumped‚Ä¶ me.. 
03:29:21 <absence> where is the Applicative instance for Const defined? the "source" link here doesn't work: https://hackage.haskell.org/package/base-4.8.0.0/docs/Control-Applicative.html
03:37:44 <indiagreen> absence: yep, it's a bug
03:37:58 <indiagreen> it works if you click ‚ÄúSource‚Äù where Const is defined
03:38:04 <indiagreen> https://hackage.haskell.org/package/base-4.8.0.0/docs/src/Control-Applicative.html#line-84
03:38:30 <Myrl-chan> /r/haskell seems to like it.
03:41:50 <absence> indiagreen: i see, thanks!
03:52:14 <int-e> @poll-result should-lambdabot-be-more-polite
03:52:15 <lambdabot> Poll results for should-lambdabot-be-more-polite (Open): maybe=6, no=10, yes=6
03:56:01 <int-e> Oh well, I guess the non-representative sample shows a clear enough trend.
03:57:21 <mniip> how do you vote
04:02:43 * hackagebot resourcet 1.1.5 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-1.1.5 (MichaelSnoyman)
04:04:51 <xelxebar_> @help vote
04:04:51 <lambdabot> vote <poll> <choice>        Vote for <choice> in <poll>
04:05:06 <xelxebar_> @poll-list
04:05:06 <lambdabot> ["\"Howmuchisthis?\"","\"Stuff?","\"Stuff?\"","\"WhyDoesLabmdabotSuckSoBad?\"","(++)","ConfusedWithVixenSituation","FlavaOfJRuby","LinearsHostname","Perl?","Prelude-(.)?","Rate-Last-Nights-Haskell-Talk","best-programming-language","best-spoken-language","food","funniest-thing-in-the-whole-world","naming","nethack","nickchange-on-away","president",
04:05:06 <lambdabot> "prove->","remove@src","should-lambdabot-be-more-polite","sleep","stringTest","taart"]
04:05:45 <xelxebar_> @poll-show should-lambdabot-be-more-polite
04:05:45 <lambdabot> ["maybe","no","yes"]
04:06:31 <xelxebar_> @vote should-lambdabot-be-more-polite yes
04:06:32 <lambdabot> voted on "yes"
04:06:56 <xelxebar_> @poll-result should-labmdabot-be-more-polite
04:06:57 <lambdabot> No such poll: "should-labmdabot-be-more-polite"
04:07:08 <xelxebar_> @poll-result should-lambdabot-be-more-polite
04:07:08 <lambdabot> Poll results for should-lambdabot-be-more-polite (Open): maybe=6, no=10, yes=7
04:07:25 <xelxebar_> mniip: does the above answer your question?
04:09:09 <xelxebar_> @help yhjulwwiefzojcbxybbruweejw
04:09:10 <lambdabot> V RETURNS!
04:09:21 <luzie> @vote should-lambdabot-be-more-polite yes
04:09:22 <lambdabot> voted on "yes"
04:09:35 <xelxebar_> @help protontorpedo
04:09:35 <lambdabot> protontorpedo is silly
04:09:43 <xelxebar_> @protontorpedo
04:09:43 <lambdabot> so with 100s of users adn different daabases haskell does fine?
04:09:58 <xelxebar_> @yhjulwwiefzojcbxybbruweejw
04:09:58 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
04:10:18 <xelxebar_> @help ghc
04:10:18 <lambdabot> ghc. Choice quotes from GHC.
04:10:23 <xelxebar_> @ghc
04:10:23 <lambdabot> Implicit parameters escape from the monomorphic top-level binding(s)
04:10:35 <xelxebar_> @brain
04:10:35 <lambdabot> Promise me something, Pinky. Never breed.
04:10:59 <xelxebar_> @help ft
04:10:59 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:11:18 <pacak> xelxebar_: You can do all of this using private messages
04:11:34 <xelxebar_> pacak: sorry. I'll stop spamming the channel
04:15:39 <mniip> @vote should-lambdabot-be-more-polite no
04:15:39 <lambdabot> voted on "no"
04:17:14 <rasen_> @vote should-lambdabot-be-more-polite no
04:17:15 <lambdabot> voted on "no"
04:17:26 <the-kenny> @vote should-lambdabot-be-more-impolite yes
04:17:26 <lambdabot> No such poll:"should-lambdabot-be-more-impolite"
04:18:19 <rasen_> @poll-show nethack
04:18:19 <lambdabot> ["Val_Dwa_Fem_Law","Wiz_Elf_Mal_Cha"]
04:19:26 <rasen_> Why no Mom_Hum_Mal_Cha?
04:19:32 <rasen_> Mon*
04:23:02 <int-e> I suspect that poll was created by a person who had narrowed it down to two choices. But somebody (me) should clean out those old polls.
04:34:07 <int-e> @poll-list
04:34:07 <lambdabot> ["should-lambdabot-be-more-polite"]
04:39:27 <pavonia> Is that the poll because of which @vixen was removed from lambdabot?
04:40:53 <int-e> no. this is about @src (mainly) being cocky.
04:59:39 <roelof> what is a good linux distro for haskell except ubuntu ? 
05:00:17 <stobix> gentoo
05:00:31 * stobix is totally not biased on that one
05:01:16 <roelof> stobix:  are you a gentoo developer ? 
05:01:24 <stobix> Nah, but a gentoo user.
05:01:46 <stobix> Right now, I'm sitting on Ubuntu, though, since this computer compiles rather slowly.
05:02:52 <rasen_> +1 for gentoo
05:03:17 <stobix> gentoo is, in my experience, wonderful if you want to develop things; You don't have to remember to include "-dev" packages, if they even exist - the source is just there for you to RTFS if you want greater knowledge of whatever language you're using.
05:03:18 <Erebe> Archlinux, if you don't to get mad with portage
05:03:42 <stobix> locate Prelude.hs returns nothing for me on Ubuntu right now. 
05:04:18 <roelof> Erebe:  I tried Arch but the install does not work. After burning several cd I still get a message that the cd cannot be found 
05:04:23 <stobix> ...which leads me to ask a question here instead of looking in Prelude.hs: How do I make a class derivable?
05:04:33 <Erebe> roelof: use an usb stick
05:04:35 <pacak> stobix: Generics.
05:04:45 <roelof> I like gentoo but I also have a slow box . Intel Core 2 with 4 G memory 
05:05:00 <stobix> pacak: oh? Never heard of them in a Haskell context.
05:05:04 <roelof> KDE or Gnome takes me the whole day 
05:05:04 * stobix googles.
05:05:10 <pacak> stobix: You won't find answer for your question in Prelude.hs anyway.
05:05:13 <simpson> stobix: The compiler has to have code generation for each derivable typeclass.
05:05:17 <Erebe> roelof: you just have to do dd if=youriso of=/dev/usbdev to get a bootable usb with arch
05:05:43 <roelof> Erebe:  I do not have a linux distro to work from 
05:05:54 <pacak> roelof: Do you want to talk about patience? It took me 2 weeks to install and download my first  gentoo. Dialup + 400Mhz
05:05:54 <roelof> so I think dd wont work 
05:06:01 <simpson> stobix: Normally this wouldn't be extendable, but GHC supports making types generic and defining default instances in terms of those generics.
05:06:12 <nshepperd> stobix: GHC.Generics
05:06:16 <simpson> stobix: You can also do the code generation yourself using Template Haskell.
05:06:24 <stobix> simpson: If I have a class A and a class B, and include in the definition of B how to go from A to B, could I derive B form a class that instantiates A?
05:07:16 <roelof> pacak : that is patience and I very big telephone bill :( 
05:07:22 <simpson> stobix: One better: `instance TypeClass YourDataType` as a standalone declaration will do it.
05:07:47 <pacak> roelof: It was unlimited night time dialup.
05:08:12 <rasen_> simpson: When I started using gentoo, I've lived in usb stick for two weeks or so after updating xorg. I just didn't know I should rebuild all x11-drivers
05:08:31 <Erebe> roelof: www.linuxliveusb.com works on windows
05:08:33 <roelof> oke, then your lucky. In my beginning days of internet I have to pay for every several minutes 
05:08:53 <simpson> rasen_: ?
05:10:21 <roelof> Anyone tried slackware or Fedora  ? 
05:10:40 <rasen_> When you update xorg-server, you should rebuild things like xf86-input-evdev. Otherwise you'll get mouse and keyboard freeze after reboot.
05:11:12 <rasen_> That took couple of weeks and one reinstall before I figured this out
05:11:25 <Erebe> no for slackware, but Fedora is a nice similar alternative to Ubuntu
05:11:35 <stobix> simpson: huh, apparently so. Why doesn't ghc try to do this when deriving? What's the difference?
05:11:46 <roelof> then I hope Fedora has Sublime Text 
05:12:25 <P4Titan> Hello all, I have a piece of code that is moderatly flexible. I want to generallize the code so that I can work with a variety of types. However, I end up with 5 dynamic argument constructors and a clas that looks like this: http://lpaste.net/1705273583275606016 Is there a way to make my code cleaner, any suggestions? 
05:15:31 <simpson> stobix: When you declare a non-derived instance, you're instructing the typechecker to find and use that instance. A derived instance tells the compiler to generate the code for the instance by examining the constructors of your data type.
05:20:27 <stobix> simpson: Hm. Would the latter see my constructors had some relation to an existing type, and try to use its definition, or how would it work?
05:23:12 <simpson> stobix: https://www.haskell.org/onlinereport/haskell2010/haskellch11.html
05:23:37 <simpson> It's literally generation of code from scratch.
05:25:52 <stobix> simpson: oh. Nice.
05:26:08 * stobix starts reading
05:37:46 * hackagebot pointed 4.2.0.2 - Pointed and copointed data  http://hackage.haskell.org/package/pointed-4.2.0.2 (EdwardKmett)
05:42:46 * hackagebot profunctors 5.1 - Profunctors  http://hackage.haskell.org/package/profunctors-5.1 (EdwardKmett)
05:51:27 <CaqueIndyDouche> @pl \x y -> x+ y
05:51:28 <lambdabot> (+)
05:51:35 <CaqueIndyDouche> @pl \n t = product [n-t..n]
05:51:35 <lambdabot> (line 1, column 6):
05:51:35 <lambdabot> unexpected "="
05:51:35 <lambdabot> expecting pattern or "->"
05:51:42 <CaqueIndyDouche> @pl \n t -> product [n-t..n]
05:51:42 <lambdabot> (product .) . (flip =<< (enumFromTo .) . (-))
05:56:13 <stobix> huh, what does @pl do? :)
05:56:36 <CaqueIndyDouche> It gives you the pointfree notation of an expression.
05:56:37 <Myrl-chan> pointfree.
05:57:12 <Myrl-chan> faveteli_: favetelinguis faveteli2guis faveteli1guis: Grats. You joined four times.
05:57:56 <stobix> ah
05:58:03 <stobix> heh. That's actually incredibly cool.
06:01:13 <Myrl-chan> stobix: Until it gets out of hand then there'd be no point(wink wink) in making it point free.
06:01:59 <stobix> Myrl-chan: it would still be fun, though. ;)
06:02:08 * stobix tries to grok join
06:12:47 * hackagebot Saturnin 0.1.0.1 - Saturnin CI / Job System  http://hackage.haskell.org/package/Saturnin-0.1.0.1 (yac)
06:22:14 <wei2912> does anyone know of a decent parsing library in Haskell?
06:23:04 <arw> the default answer would be parsec i guess.
06:23:24 <Haskellfant> or attoparsec if you want a bit more speed at the expense of error messages
06:24:57 <xandaros> I hated parsing things before I found parsec. One of the reasons I got into Haskell - can recommend :)
06:32:47 * hackagebot functor-monadic 0.1.0.3 - Monad-style combinators for functors.  http://hackage.haskell.org/package/functor-monadic-0.1.0.3 (jtapolczai2)
06:45:41 <Myrl-chan> I'm quite shocked that
06:45:57 <Myrl-chan> [a] -> [(a, a)] doesn't exist.
06:46:20 <Myrl-chan> (Basically, split a list into 2s and make it into a list of tuples or something like tha.t
06:46:51 <arbelos> wait.. partition?
06:46:59 <arw> :t partition
06:47:00 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
06:47:14 <arw> thats the other way around, a tuple of lists
06:47:21 <pacak> > map (id &&& id) [1..4]
06:47:21 * pacak pokes lambdabot
06:47:22 <lambdabot>  [(1,1),(2,2),(3,3),(4,4)]
06:47:44 <pacak> > unzip ([1..4], [1..4])
06:47:46 <lambdabot>      Couldn't match expected type ‚Äò[(a, b)]‚Äô
06:47:46 <lambdabot>                  with actual type ‚Äò([Integer], [Integer])‚Äô
06:47:46 <lambdabot>      In the first argument of ‚Äòunzip‚Äô, namely ‚Äò([1 .. 4], [1 .. 4])‚Äô
06:48:03 <ion> Myrl-chan: What would a three-element input list result in?
06:48:28 <Myrl-chan> ion: One would be to error.
06:49:03 <ion> That doesn't sound like a very nice function.
06:49:28 <arbelos> > let (a, b) = partition odd [1,2,3,4] in zip a b
06:49:29 <Myrl-chan> ion: Or if you want, a Maybe.
06:49:29 <lambdabot>  [(1,2),(3,4)]
06:49:51 <absence> Myrl-chan: what would such a function do?
06:49:58 <hodapp> > let (a, b) = partition odd [1,2,3,4,5] in zip a b
06:50:00 <lambdabot>  [(1,2),(3,4)]
06:50:19 <Myrl-chan> absence: hex to ASCII.
06:50:40 <Myrl-chan> absence: Take 2 hex values, convert to ASCII.
06:50:55 <Myrl-chan> I plan on doing it with chunksOf too.
06:50:57 <hodapp> why are your hex values split into two 4-bit parts to begin with?
06:50:58 <pacak> > let (a, b) = partition odd [1,3 .. 9] in zip a b
06:50:59 <lambdabot>  []
06:51:01 <arbelos> > uncurry zip $ partition odd [1,2,3,4]
06:51:02 <lambdabot>  [(1,2),(3,4)]
06:51:02 <absence> Myrl-chan: i don't understand. could you provide an example?
06:51:32 <Myrl-chan> absence: Sure. Wait.
06:52:14 <Myrl-chan> "6162" -> [("6", "1"), ("6", "2")] -> "ab"
06:52:27 <Myrl-chan> Now that I think about it, chunksOf looks more aesthetically pleasing.
06:52:46 <Myrl-chan> "6162" -> ["61", "62"]
06:53:08 <arbelos> what is the "ab"?
06:53:18 <arbelos> ok ascii.
06:53:49 <rasen_> how 61 relates to a?
06:54:03 <Myrl-chan> rasen_: hex and ascii.
06:54:24 <quchen> What's the actual problem you're trying to solve?
06:54:26 <rasen_> oh... I thought in dec
06:54:39 <Gurkenglas> > uncurry zip . both second . partition fst . zipWith (repeat [True, False]) $ "abcdefg"
06:54:40 <lambdabot>      Couldn't match type ‚Äò(,) (d, c)‚Äô with ‚Äò[]‚Äô
06:54:40 <lambdabot>      Expected type: ((b0, c), (b0, c)) -> ([a], [(d, c)])
06:54:40 <lambdabot>        Actual type: ((b0, c), (b0, c)) -> ([a], ((d, c), (d, c)))
06:54:54 <Myrl-chan> quchen: Just some kind puzzle thing. http://cryptopals.com/sets/1/challenges/3/
06:55:01 <hodapp> :t readHex
06:55:06 <lambdabot> (Eq a, Num a) => ReadS a
06:55:21 <Myrl-chan> > readHex "1f"
06:55:24 <lambdabot>  [(31,"")]
06:55:27 <ion> > let f (a:b:xs) = chr ((digitToInt a `shiftL` 4) .|. digitToInt b) : f xs; f _ = [] in f "6162"
06:55:29 <lambdabot>  "ab"
06:55:29 <Myrl-chan> Ah cool.
06:55:57 <Myrl-chan> readHex looks similar to hexadecimal
06:56:02 <Myrl-chan> > hexadecimal "1f"
06:56:03 <lambdabot>  Not in scope: ‚Äòhexadecimal‚Äô
06:57:06 <Myrl-chan> Not too similar, actually.
06:58:02 <Gurkenglas> What was the function for (a->b) -> (a, a) -> (b, b)?
06:58:49 <ion> bimap f f or f *** f
06:59:41 <quchen> Bimap (Bifunctor) deserves more recognition.
06:59:49 <ion> or view (both %~ f)
06:59:50 <quchen> But now that it's in Base we're off to a good start.
07:00:12 <quchen> TODO: Bitraversable, Biapplicative and so on.
07:00:19 <jmcarthur> :t join (***)
07:00:20 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
07:01:01 <absence> cute
07:01:39 <Gurkenglas> > uncurry zip . join (***) (map snd) . partition fst . zip (cycle [True, False]) $ "abcdefg"
07:01:41 <lambdabot>  [('a','b'),('c','d'),('e','f')]
07:01:57 <quchen> :t let splitty (x:y:xs) = (x,y):splitty xs; splitty_ = [] in splitty
07:01:58 <lambdabot> [t] -> [(t, t)]
07:04:05 <Gurkenglas> > transpose . foldr (\a [x, y] -> [a : y, x]) [[], []] $ "abcdefg"
07:04:06 <lambdabot>  ["ab","cd","ef","g"]
07:05:18 <exio4> quchen: splitty is just zip <*> tail
07:05:59 <quchen> No, it's not
07:06:14 <quchen> > zip`ap`tail [1..11]
07:06:15 <lambdabot>      Couldn't match expected type ‚Äò[Integer -> b]‚Äô
07:06:15 <lambdabot>                  with actual type ‚Äò[a0] -> [b0] -> [(a0, b0)]‚Äô
07:06:15 <lambdabot>      Probable cause: ‚Äòzip‚Äô is applied to too few arguments
07:06:22 <quchen> > let splitty (x:y:xs) = (x,y):splitty xs; splitty_ = [] in splitty [1..11]
07:06:24 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10)*Exception: <interactive>:3:5-39: Non-exhaust...
07:06:25 <exio4> oh, wait, I see
07:06:25 <quchen> > zip`ap`tail  [1..11]
07:06:27 <lambdabot>      Couldn't match expected type ‚Äò[Integer -> b]‚Äô
07:06:27 <lambdabot>                  with actual type ‚Äò[a0] -> [b0] -> [(a0, b0)]‚Äô
07:06:27 <lambdabot>      Probable cause: ‚Äòzip‚Äô is applied to too few arguments
07:06:32 <exio4> yeah
07:06:41 <exio4> (1,2) , (2,3) vs (1,2), (3,4)
07:06:43 <quchen> Hmm my $ button is broken.
07:06:51 <quchen> I have to mash it gently. :-|
07:07:34 <quchen> I wonder how small one can golf splitty.
07:07:41 <quchen> I can't come up with a smart solution.
07:07:47 <Gurkenglas> I wondered for a second there how you got that $ there in that case
07:08:17 <exio4> (zip `ap` tail) ... == zip `ap` tail $ ...
07:08:24 <exio4> > (zip <*> tail) [1..10]
07:08:25 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
07:08:29 <exio4> > zip <*> tail $ [1..10]
07:08:30 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
07:09:44 <Gurkenglas> > catMaybes . zipWith ($) (cycle [Just, const Nothing]) . (zip <*> tail) $ "abcdefg"
07:09:46 <lambdabot>  [('a','b'),('c','d'),('e','f')]
07:12:49 * hackagebot alfred 0.5 - utility library for Alfred version 2  http://hackage.haskell.org/package/alfred-0.5 (PatrickBahr)
07:15:28 <arbelos> I have a ByteString and want to do some permutations on it.. just a small number of times. Do I have to convert it to some other data type?
07:18:01 <arbelos> or I can just use take and drop and create new copies
07:18:41 <arbelos> take and drop or O(1)
07:18:42 <arbelos> are
07:21:21 <arbelos> oh wait i didn't mean permutations.. I am exchanging elements 
07:21:34 <Gurkenglas> transpositions :D
07:22:05 <arbelos> so maybe "abcdefgh" becomes "abfdecgh"
07:22:24 <arbelos> but concatenation is expensive, or
07:22:38 <absence> can ghci or lambdabot show specific instances of type signatures with typeclasses?
07:23:04 <quchen> absence: GHCi can show you instances/types with :i.
07:23:07 <arbelos> Gurkenglas: correct term
07:23:37 <absence> quchen: i don't want to see the instances available, but the type signature with the typeclass variable replaced with a specific instance
07:24:39 <quchen> You can write a helper to do that for you, yes. 
07:24:40 <quchen> :t (==) `asAppliedTo` (undefined :: Int)
07:24:41 <lambdabot> Int -> Int -> Bool
07:24:50 <quchen> asAppliedTo = const :: (a -> b) -> a -> (a -> b) 
07:25:21 <Hi-Angel> Can anybody decode Cabal error message to me? ´The pkg-config package 'cairo' version >=1.2.0 is required but it could not be found.ª Does it meant I am having pkg-config outdate? Either it is cairo? Googling gave me result that the complaing seems rather to be about the cairo, but why then it complains for ´1.2.0ª, but trying to install ´0.13Öª?
07:25:34 <TimWolla> <arbelos> take and drop or O(1) <- If I am not mistaken: No they are not. Almost no operation on a list is O(1).
07:25:48 <quchen> Hi-Angel: It likely means you don't have cairo installed on your OS.
07:25:54 <arbelos> TimWolla.. ByteString
07:26:02 <TimWolla> derp. Sorry. 
07:26:03 <absence> quchen: nice. is that function in a package or something, or just generally available in lambdabot?
07:26:22 <quchen> absence: It's not standard, but Lambdabot has it because it's often useful in the chat.
07:27:08 <quchen> Hi-Angel: Try an "apt-get install cairo" or similar, depending on your OS/package manager.
07:27:14 <absence> :t join `asAppliedTo` (undefined :: (->))
07:27:15 <lambdabot>     Expecting two more arguments to ‚Äò(->)‚Äô
07:27:16 <lambdabot>     Expected a type, but ‚Äò(->)‚Äô has kind ‚Äò* -> * -> *‚Äô
07:27:16 <lambdabot>     In an expression type signature: (->)
07:27:21 <quchen> (->) is not a type.
07:27:29 <raufoss> hi, i'm trying to just draw a .png image in cairo: http://lpaste.net/132795  but get "out of memory" and no image
07:27:33 <absence> quchen: ok, but this is what i'm looking for :)
07:27:45 <absence> quchen: signatures for specific instances
07:27:58 <quchen> :t join `asAppliedTo` (undefined :: a -> a -> a)
07:27:59 <lambdabot> (a -> a -> a) -> a -> a
07:28:23 <quchen> :t (***) `asAppliedTo` (undefined :: a -> b)
07:28:24 <lambdabot> (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
07:29:06 <absence> quchen: aaah
07:29:58 <absence> quchen: because the argument to join is m (m a) the type has to be b -> b -> a, i see
07:30:25 <Hi-Angel> quchen, I am look at the package manager, and I see a cairo packages being installed ‚òπ Is there a way to find e.g. what the file it didn't found ‚Äî so that I could find later to which package it does belongs. Or even better which package it does need.
07:30:28 <wei2912> is there a function that lets me convert something like [Just 3, Just 5, Nothing, Just 6] to [3, 5, 6]?
07:31:02 <geekosaur> Hi-Angel, fedora-derived and debian-derived systems generally require a -dev package, not just the runtime
07:31:05 <quchen> > catMaybes [Just 3, Just 5, Nothing, Just 6] -- wei2912 
07:31:07 <lambdabot>  [3,5,6]
07:31:10 <wei2912> quchen: thanks
07:31:34 <quchen> Hi-Angel: Hm, I don't know. Could you paste the build log?
07:31:38 <Hi-Angel> geekosaur, but the problem is that I don't know which exactly package it does need
07:31:54 <geekosaur> and I cannot guess what distribution you are on so cannot give an answer
07:32:18 <Myrl-chan> :t chunksOf
07:32:23 <lambdabot> Int -> [e] -> [[e]]
07:32:28 <Hi-Angel> quchen, it is here http://pastebin.com/EEmbgFVT pretty short
07:32:28 <Myrl-chan> Hmmm
07:33:02 <quchen> Hi-Angel: Looks like your Cairo version is outdated
07:33:11 <Myrl-chan> Is that an update?
07:33:22 <Myrl-chan> My chunksOf is `Int -> Text -> [Text]`
07:33:32 <geekosaur> on mint 17 it would be libcairo2-dev
07:33:42 <arbelos> maybe a Sequence is a good data structure for permutations/transpositions. unless I go crazy and just use a mutable vector
07:33:52 <Big_G> Are there channels for REST related Haskell?
07:35:01 <arbelos> that sounds very specific. I know there is a #rest which is active, but it is not Haskell-specific.
07:35:10 <absence> > [Just 3, Just 5, Nothing, Just 6] ^.. each.each -- wei2912 if you need more generality
07:35:12 <lambdabot>  [3,5,6]
07:38:10 <Big_G> arbelos, Yeah. That's the issue. I've tried on the yesod channel but no response
07:38:14 <Hi-Angel> geekosaur, yeah, you were right, thank you! Anyway, how did you guessed what the package it is? Is there a general way to infer it from errors? I.e. to find which the file couldn't it find exactly? So that I could search to which package the file belongs.
07:39:00 <Big_G> Also, is there a standard way to get around a proxy? Cabal keeps on failing because of it
07:39:15 <geekosaur> pkg-config is a package manager for C libraries, so I know it's looking for that. beyond that it's knowing conventions for whatever OS/distribution you are using; on Debian-like systems that is often lib<thing>-dev possibly with a version number
07:39:56 <geekosaur> on rpm-based systems it would often be <thing>-devel, again possibly with a version
07:40:31 <geekosaur> I don't know what conventions are used by other distributions
07:40:38 <raufoss> should i take this to SO http://lpaste.net/132795 ? i was hoping it's "use this instead" kind of problem...
07:41:26 <geekosaur> Myrl-chan, hayoo tells me that's the one from the text package, not the one from split
07:41:34 <geekosaur> http://hayoo.fh-wedel.de/?query=chunksOf
07:41:46 <Clint> raufoss: is redCat.jpg a png?
07:41:49 <SrPx> Okay I'll be making a crazy move today. I'll move my entire codebase on Haskell to a single file. Everything I ever code that can ever be used more than once will be on that file, and finall apps will be small separated files calling what is on that big one.
07:41:59 <SrPx> I just want to know how many of you think this is the most stupid move ever. :)
07:42:47 <indiagreen> SrPx: I'm looking forward to having to compile that giant file when you write something that will later be released on Hackage
07:42:48 <raufoss> oh god, copy and paste strikes again, thank you
07:43:23 <SrPx> Well I'm not going to be able to release anything on hackage, that is a good point. :(
07:44:30 <Myrl-chan> wei2912: Finally got it.
07:44:39 <Myrl-chan> geekosaur: Oh.
07:44:47 <indiagreen> SrPx: additionally, you're probably going to have an... interesting time trying to find a combination of packages that would all simultaneously work with each other ‚Äì since, presumably, that giant file is going to depend on quite a few of them
07:45:11 <indiagreen> I guess you'd be restricted to Stackage from now on
07:45:56 <indiagreen> oh, and it would also be a good exercise in creativity
07:46:27 <SrPx> I'm trying to reduce the dependencies considerably, though. 
07:46:30 <indiagreen> since you'd have to invent new, different names for all datatypes and record fields
07:46:31 <SrPx> indiagreen: uh huh
07:47:57 <co-arbelos> hmm.. I can't decide what would be the best data structure for this problem, repeated permutations or transpositions rather as Gurkenglas pointed out. (although a transposition is a form of permutation i guess) it seems that I am stuck with a linear time concatenation for each step no matter what type of data structure i choose 
07:47:59 <SrPx> One of the intentions is coming up with a clear, unanbiguous naming strategy.
07:48:01 <georgyy> is there an alternative prelude without non-total functions like head, tail, etc?
07:48:08 <SrPx> Yes !
07:48:14 <SrPx> classy prelude, georgyy 
07:48:25 <georgyy> thanks!
07:48:45 <SrPx> np :)
07:49:18 <Myrl-chan> ..
07:49:23 <Myrl-chan> lol wtf.
07:51:35 <Myrl-chan> I imported Data.List.Split, still can't find chunksOf. o.e
07:51:40 <breadmonster> Oh hi everyone.
07:51:49 <breadmonster> Umm, cabal keeps fucking up, can someone give me a hand?
07:51:55 <breadmonster> I've been trying to install parsec for a really long itme
07:51:57 <breadmonster> *time
07:52:02 <breadmonster> and it just doesn't seem to be working.
07:52:08 <ronh-> Myrl-chan what error are you getting?
07:53:00 <rasen_> breadmonster: any errors?
07:53:10 <breadmonster> rasen_: Let me give you the exact error.
07:54:11 <breadmonster> rasen_: *Main> import Text.Parsec  <no location info>:     Could not find module ‚ÄòText.Parsec‚Äô     It is a member of the hidden package ‚Äòparsec-3.1.9@parse_CtL7rSgjxYR5wAnuCckBL7‚Äô.     Perhaps you need to add ‚Äòparsec‚Äô to the build-depends in your .cabal file.
07:54:30 <rasen_> breadmonster: add ‚Äòparsec‚Äô to the build-depends in your .cabal file
07:54:36 <breadmonster> Just did that.
07:54:39 <breadmonster> This is the error
07:54:55 <breadmonster> rasen_: ./pykell.cabal has been changed. Re-configuring with most recently used options. If this fails, please run configure manually. Resolving dependencies... Configuring pykell-0.1... cabal: At least the following dependencies are missing: parsec >=3.19
07:55:01 <indiagreen> SrPx: it would work pretty well for something like Project Euler, granted, and it might also work well for you depending on what apps you're writing. It most likely wouldn't work well for me and apps I'm writing. But If it does work out for you, I'd be delighted to read a blog post about the experience. (The naming problem, for instance, can be somewhat alleviated with lens's makeFields, and there are probably more tricks
07:55:01 <indiagreen> you would discover that I don't even know of.)
07:55:07 <rasen_> breadmonster: Paste your .cabal file
07:55:42 <breadmonster> rasen_: http://paste.fedoraproject.org/222734/87450214
07:56:27 <rasen_> Don't see parsec there
07:56:32 <SrPx> indiagreen: it is just not about naming. I have some techniques an old indian guy teached me to identify my personal productivity bottlenecks, and seems like I waste way too much time on bureoucracy: imports, looking at the documentation, waiting for Hackage/Hoogle to load (slow connection).
07:56:50 <breadmonster> rasen_: Sorry, that was the old file.
07:56:52 <breadmonster> one second.
07:57:17 <SrPx> indiagreen: so yea, mostly I hope it can help amend those. Not sure how many dragons this will set free, though, but I hope I can manage it. I will certainly write a blog post if this works :)
07:57:24 <breadmonster> rasen_: http://paste.fedoraproject.org/222735/43187460
07:58:17 <rasen_> breadmonster: and output of cabal install --dependencies-only -v3, please
07:58:24 <breadmonster> One second.
07:59:35 <breadmonster> rasen_: http://pastebin.com/ELmNuJYm
08:00:28 <rasen_> breadmonster: wrong directory: Couldn't find .cabal file in: .
08:00:36 <breadmonster> Oh okay, one second.
08:00:54 <Myrl-chan> Hmm
08:01:20 <Myrl-chan> I have Debian Wheezy, I'll go ask the VPS owner...
08:02:06 <breadmonster> rasen_: There's too much text.
08:02:10 <breadmonster> how do I save screen output to file?
08:02:39 <breadmonster> Umm, cabal install --dependencies-only -v3 > cabaloutput.txt
08:02:42 <breadmonster> Is that correct?
08:02:46 <rasen_> breadmonster: yep
08:02:50 * hackagebot compdata-param 0.9 - Parametric Compositional Data Types  http://hackage.haskell.org/package/compdata-param-0.9 (PatrickBahr)
08:02:52 <breadmonster> One second.
08:03:06 <stobix> Huh. For some reason I thought I could do stuff like data Foo = :* | :-. Isn't there some syntax like that to produce "upper case" operators?
08:03:51 <indiagreen> stobix: you can do it, it's just that ‚Äú:-‚Äù must be an operator and not a value in itself
08:04:09 <indiagreen> data Foo = Int :* Int | Bool :- Foo
08:04:26 <stobix> ah
08:04:37 <stobix> So it remains "infix", so to say.
08:07:21 <breadmonster> rasen_: The log file is about 2MB...
08:07:46 <breadmonster> One second, trying to find a way to upload it.
08:08:46 <SrPx> Does anyone know what is wrong with those lines? http://lpaste.net/132796 
08:09:46 <breadmonster> rasen_: $ cabal install --dependencies-only -v3 > cabaloutput.txt cabal: Could not resolve dependencies: trying: parsec-3.1.9/installed-b28... (user goal) next goal: pykell (user goal) rejecting: pykell-0.1 (conflict: parsec==3.1.9/installed-b28..., pykell => parsec>=3.19) Backjump limit reached (change with --max-backjumps).  Note: when using a sandbox, all packages are required to have consistent dependencies. Try reinstallin
08:09:55 <breadmonster> rasen_: Here's the rest of the logs. https://www.dropbox.com/s/zj9flrqirl0lxi5/cabaloutput.txt?dl=0
08:13:16 <indiagreen> SrPx: where does Grid come from?
08:13:30 <breadmonster> rasen_: SorryI know the file is huge.
08:14:12 <SrPx> indiagreen, data GGrid sh v a = Grid { shape  :: sh, buffer :: v a }
08:15:20 <geekosaur> you have bang patterns enabled?
08:15:49 <indiagreen> oh, good catch
08:15:49 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/bang-patterns.html#bang-patterns-sem "There is one problem with syntactic ambiguity..."
08:20:22 <breadmonster> rasen_: Any luck?
08:21:14 <rasen_> breadmonster: not yet. maybe you should try older version of parsec?
08:21:34 <breadmonster> Is there a way I can wipe all installed packages in the sandbox?
08:21:37 <breadmonster> Without deleting my code?
08:21:41 <rasen_> oh...
08:21:42 <breadmonster> And try and reinstall everything?
08:21:51 <breadmonster> Something struck you?
08:21:58 <rasen_> You specified 3.19, but that should be 3.1.9
08:22:01 <breadmonster> Also, this is a problem I have outside the sandbox too.
08:22:29 <breadmonster> It works!
08:22:30 <breadmonster> Thanks a ton (:
08:25:08 <breadmonster> What's the difference between data, type and newtype?
08:26:19 <geekosaur> a newtype only exists inside the compiler and goes away after typechecking. type is a type synonym; in `type String = [Char]`, String is *exactly* [Char], not a distinct type. `data` defines an actual type with constructors
08:27:12 <rom1504> http://learnyouahaskell.com/functors-applicative-functors-and-monoids#the-newtype-keyword
08:27:17 <geekosaur> you could say that type is a string macro and newtype is a typechecker macro
08:30:23 <geekosaur> newtype ecxists basically so you can have multiple versions of things like typeclass instances. example: there are two "basic" monoids on Integer: (0,+) and (1,*). but you can only define one Monoid instance for a type. solution, use newtype to make a separate "copy" of Integer so you can give each one its own Monoid instance
08:31:03 <SrPx> I always wondered what is the meaning behind that
08:31:44 <lethjakman> hey
08:31:53 <lethjakman> I'm trying to understand this program: https://gist.github.com/lethjakman/5ff6ee8a8568989559c8#file-ask_for_number-hs-L10
08:32:02 <lethjakman> I don't think I quite get what's going on on line 10 though
08:32:05 <ion> You also can use breweries
08:32:09 <SrPx> couldn't we just have different typeclasses for the same type, instead? (dunno if this is possible)
08:32:22 <SrPx> woops, different instances
08:32:23 <lethjakman> why is there a gen :: (Int, StdGen)
08:32:24 <ion> Uh. That was a nice swipe input typo.
08:32:25 <geekosaur> but the newtype goes away after the typeclasses are resolved, so you don't pay extra for the wrapper
08:32:26 <exio4> SrPx: that'd mean different functions, like (<>)
08:32:44 <geekosaur> SrPx, because it would have no idea how to pick the right one
08:32:53 <exio4> oh, instances
08:32:54 <SrPx> a typeclass signature perhaps? dunno
08:33:14 <geekosaur> you would have to annotate every use that needed the Monoid instance to say which one to use
08:33:21 <rasen_> lethjakman: :: specifies the type of expression
08:33:35 <SrPx> but you still have, no? I have to create Sum 1 from an int if I want to use the (0,+) monoid, for example
08:33:38 <lethjakman> rasen_: is it because there can be a couple different types of "gen"?
08:33:42 <SrPx> that is an annotation of sorts
08:34:02 <rasen_> lethjakman: exactly
08:34:07 <geekosaur> type inference means you can often only annotate at one point and it can infer the others
08:34:30 <rasen_> lethjakman: not for gen, but whole expression randomR (1,10) gen
08:34:39 <ion> You can also use newtypes to make sure you don't mix up two different kinds of data (e.g. position, velocity and acceleration or name and address) represented the same way (e.g. Double or String).
08:34:39 <int-e> lethjakman: it parses as (randomR (1,10) gen) :: (Int, StdGen)
08:34:49 <geekosaur> but that only works if it's got a distinct constructor (e.g. Sum)
08:35:03 <SrPx> but you always need to "Sum" every int, no matter how annotated your code is...
08:35:03 <SrPx> yea
08:35:19 <SrPx> in the end it would be the same thing, I guess...
08:35:33 <exio4> SrPx: Edward Kmett's talk "Type Classes vs. The World" talks about a few nice properties that typeclasses a la Haskell (unique per type) have
08:35:38 <geekosaur> admittedly the Sum/Product case is somewhat different because the decision was made to force both monoid instances to be distinct newtypes
08:35:51 <lethjakman> oh, so is randomR accepting (1,10) as its first argument and gen :: (Int, StdGen) as its second
08:36:05 <lethjakman> and (Int, StdGen) is determining the type fo the next generator?
08:36:18 <int-e> lethjakman: it's the typoe of  randomR (1,10) gen
08:36:21 <int-e> @type randomR
08:36:22 <lethjakman> ohhh
08:36:23 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
08:36:30 <int-e> so the (a, g) there.
08:36:30 <lethjakman> what is the :: doing?
08:36:36 <ion> SrPx: Some languages have or let you specify which ‚Äúinstance‚Äù you mean, and just having that ability gives rise to some problems. https://youtu.be/hIZxTQP1ifo
08:36:48 <int-e> lethjakman: it's a type annotation:  exp :: type
08:36:57 <SrPx> 1:42:00 though t_t
08:36:58 <geekosaur> and, you could conceivably make Num instances for Sum and Product and then you wouldn't need to always specify Sum. (not that I recommend this, because Num instances tend to invite ghc to make confetti of your code)
08:37:43 <SrPx> uhmm
08:37:51 * hackagebot protobuf 0.2.1.0 - Google Protocol Buffers via GHC.Generics  http://hackage.haskell.org/package/protobuf-0.2.1.0 (NathanHowell)
08:38:21 <lethjakman> int-e: but that type annotation is for which newGen to generate?
08:38:44 <lethjakman> or...why is that used?
08:39:02 <int-e> lethjakman: no, it's really about what kind of number to generate, since g is known to be of type StdGen.
08:39:09 <int-e> :t 1
08:39:10 <lambdabot> Num a => a
08:39:11 <Big_G> Is there anything in Haskell like anotations in languages like Java and Python?
08:39:50 <ion> Big_G: What are annotations in Java and Python?
08:40:00 <rasen_> Big_G: what are you trying to solve?
08:40:40 <Big_G> rasen_, I'm sure there are plenty of future problems but at the moment, I'm trying to find an easy way to annotate functions for REST calls like Jersey or Flask do
08:40:58 <lethjakman> int-e: which g?
08:40:59 <lethjakman> do you mean gen?
08:41:12 <ion> SrPx: Getting two hours worth of brain dump copied from edwardk to you tends to be worth it.
08:41:22 <SrPx> I'm watching
08:41:54 <geekosaur> Big_G, there is the ANN pragma which I think you could then use haskell-src-exts to extract and generate a REST API or whatever
08:41:56 <int-e> lethjakman: Without the type signature, the type of  randomR (1,10) gen  in that context would be something like  (Num a, Random a) => (a, StdGen). And then ghc will complain that it cannot figure out which type to take for a (since there are several possibilities, like Int, Integer, Float, Double...)
08:42:03 <SrPx> but my tasks are looking at me with a look of disapproval
08:42:28 <int-e> lethjakman: I meant the 'g' from the type of randomR:  randomR :: (RandomGen g, Random a) => (a, a) -> g -> (a, g)
08:42:48 <Big_G> geekosaur, Would I be able to do something like @GET or @JSON_OUTPUT?
08:42:49 <lethjakman> ahah!I think I get it. 
08:42:55 <lethjakman> thank you so much for your help!
08:42:58 <geekosaur> Big_G, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/extending-ghc.html#annotation-pragmas
08:43:22 <geekosaur> the hlint manual has some examples of using ANN that way
08:43:32 <lethjakman> thank you everyone :)
08:43:34 <Big_G> geekosaur, Oh. I thought ANN reffered to neural networks
08:44:59 <Big_G> geekosaur, You think those should have the same effect as what I want?
08:45:32 <geekosaur> they can be used that way. decorators are a lighter-weight syntax for it, and no, Haskell doesn't support that lighter syntax
08:46:04 <Big_G> So no sysntatic sugar but same functionality
08:47:52 * hackagebot repl-toolkit 0.5.0.0 - Toolkit for quickly whipping up config files and command-line interfaces.  http://hackage.haskell.org/package/repl-toolkit-0.5.0.0 (jtapolczai2)
08:48:22 <geekosaur> https://github.com/ndmitchell/hlint#ignoring-hints how hlint uses ANNotations
08:48:50 <geekosaur> it's likely more flexible than decorators, but of course that flexibility is what makes them heavier than decorators
08:50:28 <geekosaur> decorator syntax is also difficult because there are very few characters available to specify them (see also the earlier issue with trying to declare an operator (!))
08:50:48 <geekosaur> @ is used by pattern syntax, for example
08:52:19 <linkages> how can i get only odd or even spots of a list?
08:52:30 <StoneToad> spots? you mean indexes?
08:52:38 <linkages> yes sorry
08:52:43 <linkages> my englis is not perfect
08:54:37 <StoneToad> map head (chunk 2 (tail [1..10]))
08:54:48 <StoneToad> I'm sure there's a prettier way...
08:55:09 <StoneToad> note that chunk and splitEvery are the same thing (in Data.List)
08:55:30 <linkages> ok thx a lot 
08:55:51 <StoneToad> btw you should check that, I probably typoed somewhere
08:56:10 <linkages> yes you gave me the idea anyway
08:56:22 <linkages> how to procede
09:06:43 <lopx> hi all
09:06:52 <lopx> anyone into bot prog?
09:07:13 <JoshieAS> no but I'm into Prog Rock
09:07:26 <lopx> aaah
09:07:45 <lopx> kkkkk
09:22:53 * hackagebot stable-heap 0.1.0.0 - Purely functional stable heaps (fair priority queues)  http://hackage.haskell.org/package/stable-heap-0.1.0.0 (JakeMcArthur)
09:25:39 <JoshieAS> I'm still having trouble grasping Applicatives with Parsers in cis194 hw10..
09:27:53 * hackagebot rivet-core 0.1.0.0 - Core library for project management tool.  http://hackage.haskell.org/package/rivet-core-0.1.0.0 (DanielPatterson)
09:27:55 * hackagebot rivet-simple-deploy 0.1.0.0 - Basic deployment support for project management tool.  http://hackage.haskell.org/package/rivet-simple-deploy-0.1.0.0 (DanielPatterson)
09:27:57 * hackagebot rivet-migration 0.1.0.0 - Postgresql migration support for project management tool.  http://hackage.haskell.org/package/rivet-migration-0.1.0.0 (DanielPatterson)
09:27:59 * hackagebot rivet 0.1.0.0 - A project management tool for Haskell applications.  http://hackage.haskell.org/package/rivet-0.1.0.0 (DanielPatterson)
09:28:15 <Myrl-chan> This didn't really work out as well as I expected it to. :|
09:37:44 <arbelos> hm.. ok so function arguments can be operators
09:38:16 <arbelos> > let f (##) x xs = x ## xs in f (:) 1 []
09:38:18 <lambdabot>      Not in scope: ‚Äò##‚Äô
09:38:18 <lambdabot>      Perhaps you meant one of these:
09:38:18 <lambdabot>        ‚Äò#‚Äô (imported from Control.Lens),
09:38:18 <jmcarthur> yup
09:38:37 <arbelos> but that didn't work, why?
09:38:58 <jmcarthur> > let f (*) x xs = x * xs in f (:) 1 []
09:38:59 <lambdabot>  [1]
09:39:14 <jmcarthur> i think it might be due to some extension or something used in lambdabot
09:39:24 <arbelos> yes. it worked here locally in ghci
09:39:36 <jmcarthur> lambdabot is not totally consistent with ghci
09:47:20 <arbelos> # is probably not the best character to use for an operator
09:47:30 <arbelos> but then again, what is... 
09:48:04 <arbelos> unicode to the rescue :)
09:52:28 <JoshieAS> is there an answer key to cis194 homework?
09:57:28 <srhb> JoshieAS: Not an official one, to my knowledge.
09:58:21 <JoshieAS> I don't mind working through them on my own and asking for help, but since I'm not taking the official course, I could use some guidance on some of the harder problems
09:58:39 <srhb> JoshieAS: You are always welcome to ask here or in #haskell-beginners . :)
09:59:06 <JoshieAS> sure, you guys are great
09:59:15 <JoshieAS> sometimes I work without wireless, dough
09:59:56 <srhb> Right. I'm sure an answer key with actual explanations for why a given solution is good or bad would be nice, and perhaps it would be a good idea to make one. I suppose you could start a community effort towards that goal. :)
10:02:59 <maerwald> or just ask the creator of the course if there is one
10:04:00 <monochrom> I heard that there are solutions on the web. but I haven't looked.
10:04:37 <srhb> There are, of varying quality
10:05:56 <JoshieAS> monochrom: there are, but like srhb say say, I can't trust if they're the best solutions
10:06:07 <JoshieAS> maerwald: that's a good damn idea!
10:06:11 <srhb> I don't think you could trust the official ones to be the best anyway :)
10:06:17 <JoshieAS> haha
10:06:19 <srhb> No, realy.
10:06:38 <maerwald> who cares if they are the best? It's a beginners course
10:06:42 <srhb> Exactly.
10:07:29 <srhb> Another reason why a repository of many answers with comments about what is good and what is bad would be great.
10:07:54 * hackagebot rivet-core 0.1.0.1 - Core library for project management tool.  http://hackage.haskell.org/package/rivet-core-0.1.0.1 (DanielPatterson)
10:09:36 <JoshieAS> but it's an actual class, so it would have to be an invite repository? so his students can still go through them
10:10:19 <srhb> I assume each year has different homework assignments.
10:11:54 <merijn> srhb: Optimist :p
10:14:48 <srhb> merijn: :P
10:19:54 <muzzle> hi
10:20:05 <muzzle> is there a non ghc-specific way of converting Float to Double ?
10:20:16 <muzzle> i.e. not GHC.Float.float2Double
10:20:59 <bennofs> :t realToFrac :: Float -> Double
10:21:00 <lambdabot> Float -> Double
10:21:01 <bennofs> muzzle: ^^^
10:21:35 <muzzle> bennofs: thanks :)
10:49:05 <teurastaja> how would one create an event-based timer using the operating system on windows?
10:51:22 <teurastaja> basically, i want the operating system to remind me of some task at some time
10:51:40 <td123> like a cron job?
10:52:33 <Pamelloes> Given the class Hashable a, is there a way to make MyType b c an instance of Hashable regardless of the values of b c?
10:52:33 <teurastaja> yes
10:52:44 <teurastaja> but on windows
10:53:02 <teurastaja> i hate windows but people still use it apparently...
10:53:22 <td123> there might be some good answers on http://stackoverflow.com/questions/132971/what-is-the-windows-version-of-cron
10:53:56 <jmcarthur> Pamelloes: yes.   instance (Hashable b, Hashable c) => Hashable (MyType b c) where ...
10:54:13 <td123> I hear ya, sucks, but if you have to support them, then you can't ignore it
10:54:39 <indigo945> Pamelloes: ... where hash = 0? Is that what you want?
10:54:43 <jmcarthur> Pamelloes: or do you mean you want it to work even if b and c are not hashable?
10:54:53 <jmcarthur> Pamelloes: in which case it depends on what you want to get out of it
10:54:53 <Pamelloes> Where even if b and c are not hashable
10:55:12 <Pamelloes> MyType has an a String identifier, so I want to make the hash based off of that
10:55:29 <jmcarthur> Pamelloes: it's possible to do, but it might not have enough entropy to do anything efficient with the resulting hash code
10:55:47 <jmcarthur> Pamelloes: well, you could just define it that way then...   instance Hashable (MyType b c) where ...
10:56:03 <indigo945> Pamelloes: yeah, then it's ... where hash x = stringIndentifier x
10:56:04 <jmcarthur> Pamelloes: and just don't use hash on values of type b or c
10:57:20 <Pamelloes> Hm, looks like that works :)
10:57:37 <jmcarthur> Pamelloes: all said, i question the wisdom of this approach. you could get the same behavior by just hashing strings instead of MyTypes, and you could have a hash table mapping the string identifiers to values of MyType. this makes more sense to me if the string identifier is the only sensible key
10:57:40 <Pamelloes> I had specified an incorrect type signature for my instance methods which was causing all of the issues
10:58:59 <Pamelloes> It's easier to make unwrapping MyType to a String in the hash method then it is to do it elsewhere.
11:02:00 <teurastaja> the task scheduler API is for C++ only...
11:04:52 <Gurkenglas> Why is Bifunctor p with its (bimap :: (a -> b) -> (c -> d) -> p a c -> p b d) important, but not something like Manyfunctor p with (manymap :: (x -> a -> b) -> p x a -> p x b)?
11:05:49 <Gurkenglas> (Yes, that one differ from Bifunctor in having the same a in each slot.)
11:05:51 <bennofs> Gurkenglas: Manyfunctor looks like an indexed functor to me
11:05:53 <Gurkenglas> *would#
11:05:56 <bennofs> @hackage indexed
11:05:56 <lambdabot> http://hackage.haskell.org/package/indexed
11:05:56 <Gurkenglas> -#
11:06:32 <bennofs> oh hmm, not really
11:14:21 <breadmonster> Hi.
11:14:37 <breadmonster> could someone help me with a functional version of inserting into a trie?
11:16:59 <td123> breadmonster: just post your question
11:17:24 <breadmonster> td123: No that's actually the question.
11:17:57 <breadmonster> I have a trie `data Trie  = Trie { val :: String. leaves :: [Trie] }
11:18:06 <breadmonster> how do I design the insert algorithm?
11:18:43 <breadmonster> where the empty Trie is Trie "" []
11:19:30 <td123> are you getting caught up on immutability?
11:20:08 <joyfulmantis> hello all... I am working thourgh Yorgey's cs194 homework 5, problem 5. In the instructions it says that to make an instance of of StackVM.Program (which I coded as 'instance Expr StackVM.Program where'), I need to enable the TypeSynonymInstances language extension. However the haskell complier says I need the FlexibleInstances extension. Is the homework wrong, or is it me who is doing something wrong? 
11:20:39 <breadmonster> td123: Yup.
11:21:37 <muzzle> You should probably do a function insert :: String -> Trie -> Trie, where you check if the input string and the trie's string have a common prefix. If they don't just return a trie with a new child, if they do return a new Trie with all of the previous children, the common prefix as val and two new children: one the rest of the original trie and one the rest of the common prefix. I hope that makes sense
11:21:41 <muzzle>  :P
11:22:01 <td123> breadmonster: you would typically write a recursive method which returns your whole structure
11:22:32 <td123> breadmonster: if parts of the structure shouldn't get modified, then just return them, if they do, then return the modified parts
11:22:41 <td123> breadmonster: and just build up your structure from scratch
11:22:50 <srhb> joyfulmantis: Why not just enable the extension?
11:22:53 <breadmonster> Hmm, okay then.
11:23:00 <breadmonster> Is there a reference for this?
11:23:23 <breadmonster> Also, I'm getting a type error I've never seen before.
11:23:36 <breadmonster> ghci> let ident' = liftA2 (:) (oneOf restChars) ((space >> return []) <|> ident')  <interactive>:25:5:     Non type-variable argument in the constraint: Stream s m Char     (Use FlexibleContexts to permit this)     When checking that ‚Äòident'‚Äô has the inferred type       ident' :: forall s u (m :: * -> *).                 Stream s m Char =>                 ParsecT s u m [Char]
11:23:53 <Tuplanolla> Perhaps look at an existing library that deals with immutable insertion, breadmonster.
11:23:53 <pharaun> lpaste would be more useful in the future btw :)
11:23:58 <td123> breadmonster: I believe http://learnyouahaskell.com/zippers talks about this approach
11:24:01 <Tuplanolla> For example fgl.
11:24:07 <breadmonster> pharaun: I'm really sorry.
11:24:25 <breadmonster> Tuplanolla: Yeah, but I'm trying to write my first nontrivial Haskell program.
11:24:27 <pharaun> breadmonster: nah don't be, just wanted to fyi :)
11:24:59 <Tuplanolla> It's a graph library, not specifically a trie library, breadmonster.
11:25:08 <breadmonster> Oh okay, right.
11:25:27 <Tuplanolla> You might also be left more confused than you were, but more profoundly so.
11:25:44 <geekosaur> in any case, ghc used to be silent about things like that when they were inferred, but now complains about it, so you need the extension
11:26:37 <breadmonster> geekosaur: Why doesn't it typecheck?
11:26:58 <geekosaur> I thought I just told you that but I guess I need to be more verbose
11:27:10 <breadmonster> geekosaur: One second, I'll write it out in full.
11:27:33 <geekosaur> parsec uses an extension to make that type legal. ghc used to let *users* of parsec not require that extension, but now requires them to use it
11:27:45 <breadmonster> Oh okay.
11:27:57 <breadmonster> Is there a way to import that extension into GHCi?
11:28:03 <geekosaur> and the problem is exactly what the error says: standard Haskell does not allow the constraint (Stream s m Char), the Char would have to be a type variable
11:28:18 <geekosaur> you need FlexibleContexts to loosen that requirement
11:28:34 <geekosaur> and ghc used to let it pass when it was inferred
11:28:59 <geekosaur> (but would have complained if you wrote it explicitly)
11:29:35 <geekosaur> basically ghc is becoming more and more pedantic about when you're doing something the Haskell standard doesn't permit
11:29:48 <geekosaur> because the Haskell standard is fairly strict in places
11:30:08 <jophish> Polarina: no problem
11:30:08 <breadmonster> geekosaur: How do I turn the extension on in GHCi?
11:30:24 <Tuplanolla> :set -X<Tab>, breadmonster.
11:30:28 <geekosaur> :seti +XFlexibleContexts
11:30:29 <breadmonster> Tuplanolla td123 muzzle: thanks btw (:
11:30:33 <breadmonster> Oh okay cool.
11:30:40 <jmcarthur> prefer :seti over :set
11:30:50 <geekosaur> (or :set; the difference is :set applies to :load-ed modules as well)
11:31:13 <geekosaur> (which can yield surprises if the module in question didn't expect that extension to be enabled)
11:31:21 <breadmonster> jmcarthur: Oh hi (:
11:31:26 <jmcarthur> :D
11:31:39 <breadmonster> geekosaur: Some flags have not been recognized: +XFlexibleContexts
11:31:41 <breadmonster> For some reason.
11:31:54 <jmcarthur> -X, not +X
11:32:00 <geekosaur> I typoed, -X
11:32:06 <geekosaur> well thinkoed
11:32:18 <Tuplanolla> This might be a silly question, but could there be a substitute for seq?
11:32:31 <jmcarthur> Tuplanolla: substitute seq how?
11:32:40 <Tuplanolla> Perhaps another mechanism to control strictness locally.
11:32:58 <jmcarthur> what do you mean?
11:32:59 <monochrom> $! is a substitute for seq
11:33:05 <jmcarthur> do you have something specific in mind?
11:33:14 <monochrom> "data X = !Int" is a substitue for seq
11:33:23 <Tuplanolla> No. I was thinking about other languages.
11:33:27 <monochrom> err, "data X = Ctor !Int"
11:33:45 <monochrom> Haskell is a substitute for other languages
11:34:26 <jmcarthur> strictness by default is a reasonable substitute for seq
11:35:43 <merijn> A substitute for seq only makes sense in lazy languages and Haskell is the only semi-widely used lazy language I know
11:35:45 <xandaros> edwardk: I'm unable to install lens 4.10 in a clean sandbox: http://hastebin.com/ejuvekubuf.avrasm (I do have it working in another sand box, though... because reasons)
11:36:16 <Tuplanolla> If one was to make another lazy language, what other ways would there be to control strictness?
11:37:41 <Tuplanolla> Yes, that's what I wanted to ask.
11:37:42 <monochrom> there are LazyML etc. they control strictness by having you use an instruction close to Haskell's seq. so there hasn't been a really different way
11:38:07 <Tuplanolla> Good to know. I'll take a look at LazyML regardless.
11:38:12 <monochrom> s/strictness/eagerness/
11:38:24 <monochrom> lazy : strict :: blue : sweet
11:39:08 <Tuplanolla> What's with the terms?
11:39:47 <monochrom> are lazy and strict opposites? are blue and sweet opposites?
11:39:50 <breadmonster> monochrom: blue : sweet?
11:39:57 <monochrom> yes, blue : sweet
11:39:59 <monochrom> are lazy and strict opposites? are blue and sweet opposites?
11:40:45 <Tuplanolla> Not very enlightening.
11:40:49 <kristof> monochrom is trying to say that the opposite of strict is nonstrict, not lazy.
11:41:06 <kristof> Strict is about order of evaluation, lazy is about when it occurs.
11:41:15 <Tuplanolla> Oh.
11:41:19 <kristof> Haskell is nonstrict and lazy. You could have a strict and lazy language
11:41:29 <exio4> Haskell is only nonstrict
11:41:39 <jmcarthur> haskell isn't even lazy. ghc's implementation involves laziness
11:41:41 <monochrom> no, strict is not about order of evaluation. lazy is.
11:41:50 <kristof> If you've ever read The Structure and Interpretation of Computer Programs, you implement a lazy, strict programming language by wrapping all your programs in thunks.
11:41:55 <kristof> Er, your functions in thunks.
11:43:03 <breadmonster> kristof: That's pretty cool, I'll look it up.
11:43:15 <kristof> monochrom: My mistake. Ok, strictness is about complete versus partial evaluation of parameters.
11:44:10 <kristof> ...so then I'm wrong about SICP.
11:44:20 <kristof> Tuplanolla: :P
11:45:14 <monochrom> "const x y" is nonstrict at y. here is a way to to implement nonstrictness and evaluate y, even completely.
11:45:44 <monochrom> fork two threads. evaluate x in one thread. evaluate y in the other thread. when x's is done, throw away y's.
11:46:03 <monochrom> if x takes more time than y, then y will be evaluated completely.
11:46:28 <monochrom> this wastes time, electricity, memory, etc, it is environmentally unfriendly, it causes global warming
11:46:32 <monochrom> but it is nonstrict.
11:46:49 <LordBrain> lol
11:47:40 <Dynetrekk> http://paste.ubuntu.com/11191494/ <- why do I get an error that Char isn't FilePath when FilePath is just an alias? and how do I fix it?
11:47:57 <geekosaur> there are two FilePath-s
11:47:59 <kristof> monochrom: That's cheating!
11:48:16 <geekosaur> the one in base is an alias. the one from the filepath package is not
11:48:31 <kristof> monochrom: It feels like cheating, anyway.
11:48:40 <geekosaur> but, having gotten your paste loaded, that is not the problem
11:48:50 <Dynetrekk> geekosaur: ok, what is?
11:49:02 <geekosaur> the string "input.txt" is not an IO action, so you should not use <- with it
11:49:02 <jmcarthur> kristof: why?
11:49:09 <geekosaur> let inputFile = "input.txt"
11:49:14 <Dynetrekk> geekosaur: ah. right
11:49:35 <kristof> jmcarthur: It doesn't sit well with me because const ignores its second argument.
11:49:37 <Dynetrekk> geekosaur: that fixed it all :)
11:49:45 <SLi> Hey, can someone here help me with lenses? If I have something like data GameState = GameState { _p1state, _p2state :: PlayerState, _p1HasTurn :: Bool }, is there a way to write a currPlayer :: Lens GameState PlayerState such that it evaluates to either p1state or p2state (generated by makeLenses) depending on _p1hasTurn? I know how to manually make lenses for p1state or p2state, but not how (or if it's possible) to access _p1HasTurn in a lens.
11:49:57 <jmcarthur> kristof: it still does ignore its second argument, even if it works the way monochrom said
11:50:03 <LordBrain> yeah, it makes it confusing when you read haddoc, you have to make sure to click the filepath now to know whether it is the alias or not
11:50:07 <jmcarthur> kristof: the value of the second argument has no effect on the result
11:50:21 <kristof> Wait, I've clarified my thoughts now
11:50:28 <kristof> Cognitive dissonance has dissipated
11:50:52 <indiagreen> SLi: currPlayer f g = if _p1HasTurn g then p1state f g else p2state f g
11:50:57 <indiagreen> I think
11:51:09 <kristof> I said that strictness requires complete evaluation of parameters, nonstrict does not. monochrom listed const x y as a counterexample, but that does not contradict my statement.
11:51:39 <SrPx> What resource on category theory is recommended for programmers?
11:52:05 <johnw> SrPx: Bartosz Milewski has a series of blog posts with that focus
11:52:15 <gremble> "Category Theory for programmers"
11:52:17 <gremble> :P
11:52:22 <gremble> what johnw mentioned
11:52:25 <kristof> const x y can be evaluated even if y has not been evaluated yet, so even though it is nonstrict and it *can* be completely evaluated, it also has the option of partial evaluation.
11:52:57 <kristof> So what I said about strict functions requiring complete evaluation and nonstrict functions being the complement of the set of all strict functions remains :P
11:53:04 <kristof> Tuplanolla: Anyway. There you go.
11:53:45 <SLi> indiagreen: Thanks, I'll try that.
11:53:54 <SrPx> But it is unfinished...!
11:54:00 <Dynetrekk> https://projecteuler.net/problem=11 <- solving this problem, what's a reasonable way to grab 4 and 4 elements in a row, without doing checks on length xs (inefficient) and other stupidity?
11:55:14 <SrPx> Dynetrekk: my (terrible) solution was creating a function that walked through the grid collecting values. That is: line (vx,vy) (x,y) n arr = grid ! (Z :. y :. x) : line (vx,vy) (x+vx,y+vy) (n-1) arr
11:55:49 <SrPx> so, "line (1,0) (5,5) 3" would return the point (5,5), (6,5), (7,5) ...
11:55:58 <SrPx> segment would be a better name, though
11:56:04 <Dynetrekk> SrPx: right, but I'm interested in how to loop across 4 and 4 elements, or in general, extracting lenght N sub-portions of a length M list, M > N
11:56:17 <Dynetrekk> SrPx: ah, ok
11:56:21 <SrPx> 4 and 4?
11:56:24 <SrPx> like, a square?
11:57:22 <Dynetrekk> SrPx: no, the first 4, then elements 2 through 5, then 3 through 6, ..
11:58:01 <SrPx> Ah, sure. So, you just map that line function to a range [2..] 
11:58:20 <Dynetrekk> SrPx: line function?
11:58:25 <Dynetrekk> SrPx: didn't quite follow
11:59:02 <SrPx> hmm... that's my solution in case you are interested http://lpaste.net/132806 but the point is thinking so gl :)
11:59:40 <Dynetrekk> SrPx: yeah, I want to solve it myself :) but the point is to learn haskell, not to solve P euler, because I'd just do that 10x faster in python anyway
11:59:51 <kristof> Dynetrekk: For every x in xs, take 4 and do stuff with it
12:00:00 <Dynetrekk> SrPx: ah, you're using arrays, make sense but not all that haskellian, is it?
12:00:01 <kristof> Dynetrekk: Then recursively go to the head of xs
12:00:14 <Dynetrekk> kristof: but what happens when you're down to a lengthh 3 list ?
12:00:20 <Dynetrekk> brb...
12:00:46 <SrPx> Nothing wrong with using arrays IMO, but folding over a list might be more elegant
12:00:59 <kristof> Dynetrekk: You could check the length of the list at the beginning and pass that to every recursive call
12:01:08 <haskell773> Hey all -- I'm trying to install the Snap web framework, and it's failing because Cabal can't install Lens. The message I get is a few compilation errors from Control.Lens.Internal.Indexed, the first of which is:
12:01:08 <Sawny> Hi, I'm new to haskell and have a problem with `race_`. I want to finish `toServer` without using `hPutStrLn handle "blabla"` because it feels a bit odd. Checkout line 25-27 at http://pastebin.com/tk6CUsGY
12:01:09 <haskell773> src/Control/Lens/Internal/Indexed.hs:172:10:     No instance for (Costrong (Indexed i))       arising from the superclasses of an instance declaration     In the instance declaration for ‚ÄòCorepresentable (Indexed i)‚Äô
12:01:27 <Sawny> Any idea why `return ()` doesn't finish `race_`?
12:01:32 <kristof> Dynetrekk: So your 'accumulator' in your fold would start with the length of the list and then decrement every recursive call.
12:01:52 <haskell773> I'm sort of a newbie and I want to both fix this error, but also, figure out the general pattern for fixing errors like this?
12:01:55 <kristof> Dynetrekk: And then you can just define a case where if the decrement is 3, return
12:01:58 <kristof> Dynetrekk: Or something
12:02:04 <haskell773> To which resources should I turn, and so on?
12:03:34 <kristof> Dynetrekk: But hopefully the general structure should make sense to you know. Do the computation with general list recursion in a fold, and "break out" of your recursion when your accumulator, which was initalized to the length of the list, falls below the "sensible" length you can do a 4-wise computation on.
12:05:26 <kristof> Dynetrekk: Actually, that doesn't make sense, sorry. a fold would go through every element of the list, huh
12:05:32 <linkages> how can i goup in a separate list the firsth value of a list tuple?
12:05:50 <indiagreen> Dynetrekk: honestly, I'd just do ‚ÄútakeWhile ((== 4) . length) . map (take 4) . tails‚Äù, nevermind the fact that it measures length of each list twice, but if you want you can use unfoldr and avoid that at the cost of having longer code
12:06:36 <indiagreen> something like ‚ÄútakeSafe‚Äù which returns Nothing if there were less elements than expected would help you here
12:07:25 <kristof> indiagreen: Doesn't that compute the length of every sublist? So you'd end up with a call of length every time you take the tail.
12:08:23 <monochrom> there is a slick way to get "the last m items". it only takes O(n+m) time
12:08:35 <monochrom> it is also one-pass.
12:08:37 <indiagreen> kristof: how can you possibly take 4 elements from a list without doing the same thing that length/take/etc does?
12:08:46 <monochrom> but I have to recall it
12:09:21 <kristof> indiagreen: Take does not compute the length of a list, does it?
12:09:50 <kristof> I thought it just errors if it encounters the end.
12:10:06 <indiagreen> kristof: take has a counter which decrements when it takes another element
12:10:14 <monochrom> first, let ys = drop m xs.
12:10:44 <indiagreen> kristof: so, if take takes 4 elements, I can't really say that it hasn't computed the length of the 4-element list, because it has
12:10:56 <kristof> indiagreen: I meant the length of the whole list
12:11:05 <indiagreen> ah, no, it doesn't
12:11:16 <monochrom> second, use this recursion: f xs [] = xs; f (x:xs) (y:ys) = f xs ys.  then call "f xs ys" i.e. "f xs (drop m xs)"
12:11:17 <kristof> indiagreen: Write, so a takewhile would do that
12:11:19 <kristof> *right.
12:11:38 <kristof> indiagreen: You're mapping a function that has a call to length in it over a list, so that gets called n times
12:11:46 <merijn> monochrom: I love that trick so much :)
12:12:57 <Dynetrekk> indiagreen: I realize it's fine to use length here, I was just interested in becoming a more efficient programmer. In python I'd know how to do this efficiently, i.e. checking the length which is O(1), and hence cheap
12:14:21 <monochrom> checking the length of a generator in python will not be cheap.
12:14:38 <monochrom> haskell : python :: list : generator, not list : list
12:14:52 <Dynetrekk> monochrom: I know, python list is an array
12:15:01 <Dynetrekk> in practical implementations
12:15:17 <srhb> Dynetrekk: If your problem is well suited to arrays (or sequences, or ...) then the Haskelly thing to do is use that data structure.
12:15:18 <sinelaw> Dynetrekk, what
12:15:24 <simpson> Dynetrekk: Out of curiosity, which impractical implementations don't use arrays?
12:15:30 <srhb> Dynetrekk: ie. arrays can be very Haskelly. :)
12:15:44 <linkages> need to take the 1 value of a list of tuples and make another list...is possible to use fst to all the element of the list?
12:15:46 <srhb> Dynetrekk: Step one is always choosing the right data structure.
12:16:07 <sinelaw> > map fst [(1,'a'), (2,'b')]
12:16:08 <lambdabot>  [1,2]
12:16:10 <sinelaw> linkages, ^^
12:16:17 <linkages> y thx a lot
12:16:22 <linkages> sounds grat
12:16:27 <sinelaw> :t map fst
12:16:28 <lambdabot> [(b, b1)] -> [b]
12:16:30 <sinelaw> linkages, ^^
12:16:34 <srhb> Dynetrekk: Also, see Data.Vector.
12:16:56 <ronh-> @djinn [(a,b)] -> [a]
12:16:56 <lambdabot> Error: Undefined type []
12:17:06 <sinelaw> ronh-, djinn doesn't know about lists
12:17:14 <ronh-> I just noticed :)
12:17:36 <ronh-> it makes sense, it could return a number of things, entire list, just head, or []
12:18:02 <sinelaw> from what I understand how djinn works, I guess it would be []
12:18:12 <sinelaw> const []
12:18:32 <Dynetrekk> simpson: no idea, I just don't know that it's a requirement  that the implementation is an array?
12:18:56 <sinelaw> or maybe not. never mind
12:18:58 <Dynetrekk> srhb: I'd say arrays here (Data.Vector?) based on my experience iwth imperative languages. It's just that haskell seems to say "use lists" everywhere
12:19:18 <srhb> Dynetrekk: That's a wrong impression, I promise you. :)
12:19:26 <srhb> Dynetrekk: And yes, Data.Vector is arrays.
12:19:42 <simpson> Dynetrekk: It is not a requirement, and the fastest Python, PyPy, aggressively turns lists into the best internal representation it can find. Lists of chars and ints are unboxed and packed. Lazy predictable lists like range() are generated on-the-fly as needed.
12:20:03 <Dynetrekk> srhb: I realize I'm confused, but then, I'm new to haskell / pure functional style
12:20:33 <Dynetrekk> simpson: in python 3, range() is not an actual list object, even in cpython (but OT I guess)
12:20:33 <srhb> Dynetrekk: Yes, that's fine. I didn't mean to come off pompous or anything, I just want to make sure you don't leave here thinking "use lists for everything" instead of "use lists for things lists are good for" :-)
12:21:01 <srhb> And if you need O(1) indexing or length, lists are definitely not the right fit.
12:21:30 <simpson> Dynetrekk: Sure. I was just curious as to whether there was something new to learn. And I think that learning has happened, so this was a success.
12:21:43 <Tuplanolla> You might enjoy reading about the data structured behind SRFI 101, Dynetrekk.
12:21:45 <teurastaja> how about vectors?
12:22:41 <teurastaja> you embed the size in the first array then start counting from the second
12:22:58 <indiagreen> Dynetrekk: I have just tried to write several versions of a function you want ‚Äì from least to most efficient ‚Äì and I realised that I can see a dozen ways each ‚Äúmore efficient‚Äù way would actually be less efficient because of messing with GHC's optimiser. So, I still would recommend the dumb approach with length and filtering, unless you're willing to switch to arrays
12:23:05 <teurastaja> its a scheme trick
12:24:58 <mauris> hi #haskell! i was wondering, is there something like a Prelude replacement that only supplies total functions?
12:25:29 <monochrom> the package name may be "safe" or "safe-prelude"
12:26:18 <teurastaja> basically just make resizable vectors by doubling the boundary everytime you reach it
12:26:19 <mauris> oooh, neat!
12:29:04 <rasen_> Is there a name for (\(x:y) -> (x, y))?
12:29:20 <indiagreen> rasen_: the usual name is uncons
12:29:22 <monochrom> no, it is also seldom used
12:29:26 <arbelos> The thing with lists is that syntactic sugar and built-in notation like list comprehensions can be a "two-edged sword".. Sometimes I feel that sequences maybe should have its own notation, like in F# where it has built-in syntax
12:29:48 <teurastaja> i dont know what was the problem, but i had to implement a new type of vector like that
12:29:53 <johnw> if it were uncons, it shuold be: \x -> case x of [] -> Nothing; (x:y) -> Just (x, y)
12:30:16 <johnw> which is not horribly uncommon, I've used it several times
12:30:24 <indiagreen> johnw: ouch, right
12:30:32 <rasen_> indiagreen: Thanks!
12:31:05 <johnw> unfoldr  uses functions of this type:
12:31:07 <johnw> :t unfoldr
12:31:08 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
12:31:30 <teurastaja> arbelos: you mean sequences as literal syntax?
12:32:05 <exio4> arbelos: OverloadedLists and MonadComprehesions get you there 
12:32:31 <arbelos> oh. ok. well, but the are also efficient builders for sequences and some other goodies
12:32:52 <arbelos> I have never heard of those extensions though, there seems to be so many GHC extensions
12:33:35 <arbelos> which makes me think, how many packages on Hackage work with other compilers :)
12:33:49 <exio4> OverloadedLists is 'kinda' new, MonadComprehesions is just restoring the original behavior
12:34:03 <teurastaja> i dont know if the reader monad does like in scheme but probably you could use it to represent unevaluated continuations. am i right or totally wrong?
12:34:27 <rasen_> How do I know my version of base?
12:34:38 <monochrom> "ghc-pkg list base"
12:35:06 <monochrom> do not ask cabal. "cabal list" does something unrelated.
12:37:32 <phoniel> any help? I'm trying to figure out what could be preventing me from cabal install-ing lens 4.10. The error message comes from src/Control/Lens/Internal/Indexed.hs and can be read at http://pastebin.com/3grGRxmE
12:37:49 <edwardk> phoniel: working on it right now
12:37:56 <edwardk> i literally just woke up and saw the issue
12:39:04 <rasen_> monochrom: thanks
12:40:03 <phoniel> edwardk: I love you. What Haskell extensions do I have to understand to be able to look at this code myself and try to work on these sorts of things? I was looking at the source to try to figure out the problem but I couldn't parse what was going on
12:40:57 <edwardk> phoniel: well this code isn't so much about extensions as about using a bit of theory to motivate a rather intricate design 
12:41:48 <phoniel> edwardk: Which theory, then? I'm trying not to just let everything I don't understand flow under the bridge, never to be seen again. Is this sort of package a hopeless starting place, or is there something I can read?
12:44:02 <Tuplanolla> Have you seen the lens paper, phoniel?
12:44:05 <edwardk> phoniel: 'profunctors' arise in category theory. in category theory you have categories, which have objects and arrows, with arrows having a composition that is associative. if you look at the way arrows are built and generalize the notion a bit for the "hom-sets" of a category you get these things called profunctors
12:44:47 <edwardk> profunctors here in haskell are rather simple beasts they are anything where you can 'fmap backwards over the first argument and forward over the second'
12:45:05 <edwardk> dimap :: Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
12:45:48 <edwardk> when p = (->) you can see how it works (a -> b) -> (c -> d) -> (b -> c) -> (a -> d) -- just strings together dimap f g h = g . h . f
12:45:55 <phoniel> Tuplanolla: No. Looking for it but there's no obvious google result
12:45:57 <edwardk> but there are interesting examples other than (->)
12:46:14 <edwardk> phoniel 'ncatlab' has a bunch of material on profunctors but it is rather advanced category theory
12:46:32 <edwardk> they are useful for motivating a bunch of stuff that makes the rest of category theory go
12:47:45 <edwardk> anyways while mapping between categories with functors is one thing you do in category theory, profunctors can be used to give a different way to deal with relations between categories.
12:47:59 * hackagebot logic-TPTP 0.4.3.0 - Import, export etc. for TPTP, a syntax for first-order logic  http://hackage.haskell.org/package/logic-TPTP-0.4.3.0 (DanielSchuessler)
12:48:05 <edwardk> that is the high level motivation
12:48:09 <johnw> CT seems to distill ideas using functors, and profunctors do this for morphisms
12:48:30 <phoniel> Okay. Is the category theory necessary for understanding these types or is a more practical approach possible? (I'm a pure math undergrad but for time reasons I'd rather only deal with that stuff I have to see to get the concepts)
12:48:55 <johnw> phoniel: you can just think of a profunctor as abstracting a function, and that will get you a fair ways
12:49:10 <johnw> it's just one step away from being an Arrow
12:49:54 <edwardk> well, i like the proarrow equipment between relations and functions as an example. you can take a function (a -> b) and turn it into a relation two different ways. you can build the relation between a and b given by all the elements (a, f a)    and you can give the relation (f a, a). this is directly analogous to the star constructions in profunctors letting
12:49:54 <edwardk> you take a functor and build a profunctor by using a -> f b  or f a -> b
12:51:04 <edwardk> profunctors as implemented in that library are directly tied to functors this way. we can talk about the representable profunctors, which are ones that are of that Kleisli-like form (a -> f b)
12:51:47 <edwardk> so to take this analogy further: if functors are like functions between categories, then profunctors are like relations between categories
12:52:19 <edwardk> given two relations you can compose them, given two profunctors we have composition as well, etc.
12:52:55 <edwardk> Procompose p q a c = exists b. (q b c, p a b)
12:54:18 <edwardk> we don't get to build the whole 2-category of profunctors in haskell, we just get to model it as a bicategory. we have to explicitly associate profunctor composition ourselves. Procompose p (Procompose q r) a b <-> Procompose (Procompose p q) r a b   is only an isomorphism not a type equality
12:54:51 <Tuplanolla> I was referring to these lens resources, phoniel: https://github.com/ekmett/lens/wiki/FAQ#resources-1
12:54:56 <edwardk> phoniel: anyways, my recommendation would be to start with an introductory category theory textbook. how much of a math background do you have?
12:56:06 <phoniel> edwardk: Undergrad pure math -- hodgepodge of algebra, number theory, combinatorics, and so on
12:56:13 <phoniel> Tuplanolla: Will read
12:57:12 <Dynetrekk> is Data.Vector in haskell platform? and how do I know what's in the platform? it seems sensible to stick to libs in the platform for beginners - am I right?
12:57:15 <SrPx> Okay is there an overview of all the Haskell numeric typeclasses... Num, Fractional, Integral, Real, RealFrac, Floating, Ord, etc., etc., and what they do each?
12:57:28 <geekosaur> http://lambda.haskell.org/platform/doc/current/frames.html
12:57:42 <geekosaur> (or index.html if you dislike frames)
12:58:14 <grandpascorpion> Hi, I'm working on writing a library.  It only has a couple of dependencies on external libraries.  When putting the package together, how does one determine the dependencies, version range-wise?  (i.e. Do they just indicate the sole version(s) they tested against?)
12:58:28 <geekosaur> SrPx, http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/haskell2010-1.1.1.0/Prelude.html#g:4 and following sections
12:58:53 <edwardk> phoniel: ok, so you're probably well positioned to pick up something like awodey's book
12:58:56 <geekosaur> I don't think there's a typeclassopedia-type thing for them though
12:59:19 <geekosaur> probably because the people who'd most want it also want to redo the whole thing >.>
12:59:39 <geekosaur> (but mostly can't agree on how, see the proliferation of alternative numeric preludes on hackage...)
12:59:47 <edwardk> phoniel: http://www.amazon.com/Category-Theory-Oxford-Logic-Guides/dp/0199237182
13:00:10 <edwardk> phoniel: from there you should be able to pick through the nlab bits on profunctors with some guidance from the folks in #haskell-lens
13:01:25 <phoniel> edwardk: Okay! Thanks! As one last note, if I run into a problem like the one I just did with 4.10, what is the best course of action for me? 
13:01:37 <edwardk> filing the issue like you did
13:01:41 <edwardk> that shouldn't have happened
13:01:45 <phoniel> In this case I'm trying to install Snap, and Lens is a dependency 
13:01:58 <edwardk> but i took a patch from someone i trusted and missed one bit of the patch adding a dependency and the knock-on consequences
13:02:20 <edwardk> you can use cabal install snap --constraint 'profunctors < 5.1' -- and it should just work
13:02:27 <edwardk> i'll fix the package in the meantime
13:02:28 <phoniel> Okay. Thanks a lot. I'll start pushing through the category theory book a bit.
13:03:10 <SrPx> geekosaur: sighs it is so hard
13:03:42 <SrPx> Can't we just accept our limitations and make everything a float until we understand enough to do it properly :/
13:04:43 <quchen> SrPx: Javascript does that. It's a warning to others.
13:04:45 <phoniel> edwardk: as an actual last question, how did you know to constrain the profunctors package in particular? Just because you are so involved in this library, or was there some easy detective work I could have done on my own?
13:04:45 <geekosaur> ...jump straight into the dragon's maw, why don't you? :p
13:04:56 <Tuplanolla> Accepting our limitations would be closer to leaving floating-point numbers out altogether.
13:05:08 <geekosaur> (Float and DOuble are especially hated because IEEE floating point doesn't obey number theoretical laws)
13:05:16 <edwardk> phoniel: i knew it because of the source of error, missing costrong instance, and that profunctors just added the constraints
13:05:27 <edwardk> https://github.com/ekmett/lens/issues/544
13:06:33 <Tuplanolla> Have some depressing floating-point reading, SrPx: https://www.cs.berkeley.edu/~wkahan/
13:06:40 <geekosaur> when it comes down to it, Num is a compromise. *nobody* likes it. but nobody can agree on a replacement, which is why we got the compromise
13:06:54 <SrPx> Gurkenglas: it works pretty well actually :/
13:07:04 <SrPx> Gurkenglas: sorry! I meant quchen 
13:07:06 <geekosaur> and since "hated equally by all" is one characterization of the ideal compromise.... :)
13:07:32 <phoniel> edwardk: Thanks, and thanks for all the help 
13:07:32 <SrPx> quchen: javascript has many, many issues but honestly, if you ever encounter someone with a valid complaint of doubles causing doom let me know
13:07:48 <geekosaur> I wonder if quchen was thinking of php
13:07:51 <quchen> SrPx: Storing hashes as numbers
13:07:58 <SrPx> Tuplanolla: did you link the right thing?
13:08:12 <geekosaur> although there it's more the weird randomly-treat-as-string-or-number that is more of asn issue
13:08:12 <Tuplanolla> Yes, SrPx. It's a collection of said doom.
13:08:32 <edwardk> phoniel: i've patched the bounds on hackage so that others in the future won't get your problem, and i'll ship a new lens version that fixes it properly
13:08:56 <SrPx> Tuplanolla: I'm not sure I get it
13:09:06 <quchen> SrPx: Checking whether a number is even is also something I like to have
13:09:20 <quchen> Bit twiddling is sometimes useful
13:09:53 <SrPx> quchen: ... 4 % 2 works on js... I don't get it?
13:09:59 <SrPx> also geekosaur what laws?
13:10:29 <Tuplanolla> You can start from, say, "Desperately Needed Remedies for the Undebuggability of Floating-Point Computations", SrPx.
13:10:30 <quchen> SrPx: And 10e123 % 2?
13:11:07 <exio4> SrPx: x * y = y * x 
13:11:10 <Dynetrekk> SrPx: fun fact; Lua uses doubles similarly as JS
13:11:22 <magneticDuck> that's a terrible fun fact
13:11:33 <exio4> or things like x*y = x * 1/(1/y)
13:11:34 <geekosaur> SrPx, you aware of number theory?
13:11:36 <SrPx> Tuplanolla: if that's all about errors then there is not really much one can do other than using ratios, right?
13:11:37 <Dynetrekk> magneticDuck: scary fact, then
13:11:42 <geekosaur> *are you aware
13:11:43 <SrPx> geekosaur: noo :(
13:11:47 <cloo> I'm trying to deduplicate my cabal file by having my executable depend on the library defined in that cabal file. However, `cabal run` produces linking errors about 'undefined reference to `mylibfunc`'. Does that make sense to anyone?
13:11:50 <SrPx> exio4: fair enough
13:11:54 <SrPx> okay
13:12:05 <cloo> Even stranger, the same approach works fine with `cabal test`
13:12:09 <Hijiri> lua uses doubles like JS but has no standard round function
13:12:11 <Dynetrekk> exio4: x * y /= y * x for floats :)
13:12:12 <geekosaur> that's where all those monoid - semigroup - semiring etc. things come from that often come up in discussions of Num alternatives
13:12:25 <exio4> I think pretty much any sense of sanity fades away with doubles
13:12:41 <Dynetrekk> Hijiri: really, never came that far into Lua-land :) just used it for config files for Fortran programs :P
13:12:42 <SrPx> but whatever doubles are not the solution but they work :/ I mean, if what we have isn't perfect either can we blame doubles?
13:12:44 <magneticDuck> which is why I always use algebraic number types
13:12:48 <exio4> Dynetrekk: that's what I meant to say, too
13:12:51 <magneticDuck> because fuck optimization
13:12:58 <magneticDuck> (tm)
13:12:59 <Hijiri> maybe I should use church-encoded naturals in lua instead of doubles
13:12:59 * hackagebot postgrest 0.2.8.0 - REST API for any Postgres database  http://hackage.haskell.org/package/postgrest-0.2.8.0 (begriffs)
13:13:01 <Tuplanolla> There are also error estimates, rounding controls and proper exceptions, SrPx.
13:13:05 <Dynetrekk> exio4: oh, sorry. too tired, I guess :P
13:13:11 <SrPx> I would like to see what a properly designed numeric tower looks like but we don't have that
13:13:32 <cloo> SrPx: PureScript's isn't terrible
13:13:48 <Tuplanolla> The best I've seen is built into Axiom, SrPx.
13:13:51 <SrPx> and not having that means that I'm confused as hell trying to extend Linear with geometry
13:14:01 <exio4> SrPx: I'd prefer Ratio Integer 
13:14:12 <exio4> than Double
13:14:21 <johnw> aka Rational
13:14:24 <Tuplanolla> Its manual comes in 13 volumes, SrPx: http://www.axiom-developer.org/axiom-website/documentation.html
13:14:27 <SrPx> Ratio is just Ratio, no? 
13:14:33 <magneticDuck> yes
13:14:54 <geekosaur> Rational
13:17:12 <kirill`> Dynetrekk: that's not correct, x * y == y * x for finite floats
13:17:59 * hackagebot postgresql-simple-typed 0.1.0.1 - Typed extension for PostgreSQL simple  http://hackage.haskell.org/package/postgresql-simple-typed-0.1.0.1 (tolysz)
13:18:44 <quchen> kirill`: Oh. Counterexample?
13:19:13 <Dynetrekk> kirill`: you're probably right, but in more complex expressions, commutativity of mathematical operators do not hold in flaoting point
13:19:25 <Dynetrekk> kirill`: e.g. a + b + c or a * b * c vs c + b + a etc
13:19:46 <Dynetrekk> more precisely (a+b)+c /= a+(b+c)
13:19:58 <Dynetrekk> ok... that's associativity, but anyway
13:20:07 <kirill`> quchen: hm, how? By definition of floating-point arithmetic in IEEE-754, basic operations are commutative. (Not associative, though?) Do you know a counterexample with x * y /= y * x
13:20:07 <Tuplanolla> Also x + y - y /= x.
13:20:49 <Dynetrekk> Tuplanolla: that's a fun one
13:21:00 <kirill`> Tuplanolla: that should be obvious, all intermediate results should be rounded to some relative error, so (x + y) - y is totally different from x + (y - y) because of where the rounding happens. But y - y == 0 always.
13:21:47 <kirill`> When you add two numbers, the result is guaranteed to be the mathematically correct result, rounded to the nearest representable floating-point number, which is what makes them commutative.
13:21:54 <quchen> kirill`: You suggested that for non-finite floats the law won't hold, what would an example of that be? (NaN of course, but are there others?)
13:22:25 <kirill`> 0 * Inf? But it's just NaNs, I think.
13:22:29 <td123> from http://en.wikipedia.org/wiki/Floating_point#Dealing_with_exceptional_cases "While floating-point addition and multiplication are both commutative ... , they are not necessarily associative"
13:22:49 <exio4> ah, right, associativity
13:23:01 <kirill`> Also, NaN == NaN is False, so (0 * Inf == 0 * Inf) == False
13:23:05 <notdan> quchen: I would think that for non-finite floats all the laws would definitely hold
13:23:09 <quchen> > ((0.1 + 0.2) + 0.3, 0.1 + (0.2 + 0.3))
13:23:10 <lambdabot>  (0.6000000000000001,0.6)
13:23:12 <notdan> because non-finite floats are basically real numbers
13:23:27 <quchen> notdan: I'd like it to hold for all non-NaN floats
13:23:51 <quchen> NaN breaks everything of course :-|
13:24:02 <kirill`> > (1 + 1e-7 :: Float) - 1
13:24:04 <lambdabot>  1.1920929e-7
13:24:08 <kirill`> > (1 + 1e-8 :: Float) - 1
13:24:09 <lambdabot>  0.0
13:24:13 <kirill`> > (1 + 1e-8 :: Double) - 1
13:24:15 <lambdabot>  9.99999993922529e-9
13:25:03 <SrPx> Tuplanolla: I'm trying to understand it
13:25:07 <td123> does anyone recommend a regex library?
13:25:31 <quchen> td123: Depends. What do you want to do?
13:26:00 <edwardk> phoniel: lens 4.11 is now on hackage
13:26:25 <td123> quchen: I have a log with lines of the format: "numbers dates etc. json_object" I just want to extract the json_object
13:26:44 <phoniel> edwardk: badass. 
13:27:10 <quchen> td123: And then you want to do what with the JSON? Deserialize it to Haskell?
13:27:41 <td123> quchen: yes, I need to deserialize to an aeson Object and then do some further transformations
13:27:53 <notdan> quchen: why? I wouldn't say that NaN breaks commutativity or associativity
13:28:00 * hackagebot lens 4.11 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.11 (EdwardKmett)
13:28:12 <quchen> notdan: Yeah you're right
13:28:18 <merijn> NaN doesn't break commutativity or assioctivity
13:28:24 <merijn> It just break reflexivity of equality
13:28:25 <td123> quchen: and then that will be serialized and served as an http response for analytical purposes
13:28:37 <merijn> > (0/0) == (0/0)
13:28:38 <Tuplanolla> My personal favorite is that both forall x. (abs :: Int -> Int) x >= 0 and forall x. (abs :: Double -> Double) x >= 0 are False.
13:28:39 <lambdabot>  False
13:29:04 <notdan> merijn: yeah but the equality for floats is weird anyway
13:29:08 <merijn> > (-0 :: Double) == 0 --whoo, negative zero!
13:29:10 <lambdabot>  True
13:29:13 <merijn> awww
13:29:14 <td123> quchen: this is just a workaround until I put in proper infrastructure without having to parse logs :)
13:29:17 <notdan> At least on the computer..
13:29:23 <quchen> merijn: Depends on how you identify two Doubles as equals, I guess.
13:29:41 <notdan> I mean I would say if I were to add NaN to the field of real numbers I would still like to have NaN == NaN
13:29:41 <quchen> td123: My suggestion would be to write a log parser that skips over the unwanted stuff.
13:29:56 <merijn> quchen: The breaking of reflexivity does not depend on your definition of equality for Doubles
13:30:20 <exio4> merijn: that reminds of http://dpaste.com/013MB38 :( 
13:30:33 <td123> seems kinda heavy for code that I will be throwing away though?
13:30:45 <quchen> merijn: Well, as noted above, 0*‚àû is not "==" to ‚àû*0. So under that definition of equality, commutativity is broken. When you compare for "is the same float", then it holds.
13:31:04 <exio4> inf * 0 is undefined
13:31:10 <td123> I realize parsers are the "right" way of doing things
13:31:32 <quchen> exio4: ?
13:31:47 <exio4> that's javascript (node) 
13:32:24 <kirill`> By the way, Data.SBV (bindings to SAT solvers) is a good way to test floating point understanding. E.g., try "allSat $ do x <- sFloat "x"; return (x ./= x)"
13:33:19 <SrPx> but seriously floats was just an example :(
13:34:05 <quchen> td123: Good parsers are the "right" way of doing things. Hacky parsers are how you usually do Regex-like stuff. But if Regex is really what you want, then pcre-light worked nice for me once. http://hackage.haskell.org/package/pcre-light
13:35:11 <kirill`> Here's the commutativity example: allSat $ do x <- sFloat "x"; y <- sFloat "y"; return (bnot (isNaNFP x) &&& bnot (isNaNFP y) &&& x + y ./= y + x)
13:35:11 <kirill`> The only two solutions given by the sat solver are (+Inf, -Inf) and (-Inf, +Inf)
13:35:24 <td123> quchen: I'll check it out, thanks :)
13:35:31 <tmtwd> maximum' = foldr1 (\x acc -> if x > acc then x else acc)  
13:35:48 <tmtwd> I've noticed for right folds , x is often first then the accumulator
13:35:58 <tmtwd> is this a requirement or just convention?
13:36:02 <quchen> td123: If you want to go full hardcore hacky then just syscall to grep :-√æ
13:36:07 <tmtwd> (x being the input value)
13:36:24 <td123> quchen: don't give me ideas :P
13:36:29 <quchen> tmtwd: foldr does not have an accumulator. It doesn't accumulate like foldl does.
13:36:47 <tmtwd> then what does acc do in this function?
13:36:55 <tmtwd> it has to have some kind of base value
13:37:02 <quchen> Acc is a bad name to use in foldr. That's what it does.
13:37:13 <quchen> A much better name is "rest", for example.
13:37:16 <dolio> tmtwd: It's convention, but it makes sense if you think about it.
13:37:23 <quchen> It stands for "the rest that's not yet folded over".
13:37:25 <tmtwd> as in remainder?
13:37:36 <tmtwd> interesting
13:37:53 <tmtwd> then what is x in this case, the input argument?
13:37:59 <quchen> tmtwd: The folding function "f" in "foldr f z xs" takes two arguments: the current list element to look at, and how to combine it with the rest of the fold.
13:38:00 * hackagebot hbro 1.4.0.0 - Minimal extensible web-browser  http://hackage.haskell.org/package/hbro-1.4.0.0 (koral)
13:38:44 <geekosaur> SrPx, indeed floats are an example... of what ypu're getting into when raising issues about Num :)
13:39:19 <quchen> tmtwd: One way to look at foldr for lists is that it replaces each (:) in the list by "f", and the [] by "z".
13:39:48 <tmtwd> huh
13:39:50 <dolio> tmtwd: If you imagine that the binary function is written infix, and given the associativity corresponding to the fold, then foldl taking the arguments in the order it does corresponds to writing 'z `f` a `f` b `f` c ...' when folding over [a,b,c...].
13:39:52 <quchen> tmtwd: So it looks at the first (:), and makes it an "f". The (:) had two arguments: the list head, and the rest of the list. This transfers directly to the "f".
13:40:16 <tmtwd> quchen, and what about left folds?
13:40:17 <dolio> tmtwd: And the same with foldr, except with z at the end.
13:41:22 <quchen> tmtwd: Left folds do something completely different, they're very similar to looping over a list element-wise with an accumulator. result=0; for(i in list) { result += i; }  ==  foldl (+) 0 list
13:41:28 <quchen> ‚Ä¶ ish
13:41:52 <dolio> Except you can think about it in a very similar way.
13:42:40 <tmtwd> huh
13:42:57 <td123> quchen: ah, for a quick hack, I think dropWhile (/= '{') will work
13:42:59 <dolio> foldr f z [a,b,c] = a `f` b `f` c `f` z where infixr f; foldl g z [a,b,c] = z `g` a `g` b `g` c where infixl g
13:43:10 <SrPx> geekosaur: but just working with a generic "number" type that does what we learned a number does on school is much easier than working with the arbitrary and admitedly imperfect view of numbers that is implemented on haskell's prelude
13:43:18 <td123> quchen: get's rid of the need to deal with regex strings
13:43:38 <geekosaur> SrPx, and that jumps into the maw of number theory
13:43:41 <SrPx> not really floats, but just a single "Number" typeclass
13:43:43 <geekosaur> you can't win :)
13:43:44 <SrPx> geekosaur: why
13:44:18 <quchen> dolio: Sure, for finite lists, and modulo laziness.
13:44:52 <SrPx> you don't understand, it is not about being better than what it is. it is about being worse. because it is more practical
13:45:00 <JagaJaga> Can I use template haskell for computations during compilation?
13:45:31 <quchen> JagaJaga: TH can do that, yes.
13:45:36 <JagaJaga> quchen: thank you.
13:45:43 <geekosaur> SrPx, that specific compromise is what got us Num
13:45:43 <SrPx> honestly you can't expect a random programmer to understand the 16 numeric typeclasses. if it at least was solid and undisputable, you'd have a point... but that's not the case
13:46:33 <exio4> SrPx: if you have a _single_ typeclass, you're ruling out of things, unless you are really lax over them 
13:46:36 <SrPx> but Num doesn't define everything that a number is. I still need Num, Metric, ORd, Fractional, Floating on my type constraints... the solution of using type synonyms is just hiding that
13:46:48 <geekosaur> I think all I can suggest at this point is go look at acme-php's notion of numbers. and then try to do something useful with it
13:46:50 <quchen> foldl f z xs == foldr (flip f) z (reverse xs) -- is also true whenever both sides exist, but they're hardly "the same thing" even in that case.
13:46:55 <Vektorweg1> SrPx: maybe you should try haskell. only the important numeric typeclasses and not the whole ring/etc. stuff of real math.
13:47:14 <geekosaur> Vektorweg1, that *is* what SrPx is trying to do
13:47:28 <Vektorweg1> lol. sorry, i just posted in the wrong channel. xD
13:47:36 <geekosaur> ditch the arguments and somehow just have "numbers" like "normal" programming langiuages
13:47:45 <geekosaur> for some definition of "normal"
13:47:58 <Vektorweg1> hell, i just wanted to ask something here, but my memory ...
13:47:59 <geekosaur> and then discover why that doesn't work very well in Haskell
13:48:08 <SrPx> or get it very solid, sound and correct, or just have something practical... no?
13:48:21 <dolio> What we have is practical.
13:48:35 <geekosaur> as practical as it gets given strong typing
13:49:58 <Athas> jaspervdj: are you around?  (Hakyll questions.)
13:51:34 <SrPx> In what world it is "correct" to have to add Fractional, RealFrac, RealFloat, Floating, and a few others constraitns that all mean the same thing?
13:51:56 <yurrriq> is anyone here an org-mode expert? I‚Äôm trying to get my pretty symbols in HTML exports of literate Haskell.
13:52:18 <SrPx> there are naturals, integers, rationals, irrationals, reals... each adding something new to the previous set... and it all makes sense
13:52:32 <SrPx> on math, that is... how do I make sense of Haskell's numbers? 
13:53:00 * hackagebot mysql-simple-typed 0.1.1.2 - Typed extension to mysql simple  http://hackage.haskell.org/package/mysql-simple-typed-0.1.1.2 (tolysz)
13:53:16 <SrPx> what is the theory behind the meaning of "RealFrac"? show me a paper, a textbook where I can study the formalization of RealFrac... 
13:53:28 <dolio> Yes. I don't want all those types blurred together into one Number type. That's something I don't like in other languages.
13:54:11 <Athas> SrPx: there is not necessarily a formalization as a (useful) algebraic structure.
13:54:23 <SrPx> dolio: why not just divide everything into 1000 typeclasses them? Num can be split into many typeclasses. So can RealFrac, RealFloat.
13:54:34 <SrPx> you just group functions in an arbitrary way with arbitrary names
13:54:35 <Athas> They are artifacts of engineering, not so much theory.
13:54:44 <LordBrain> https://www.haskell.org/tutorial/numbers.html
13:54:47 <SrPx> then*
13:55:32 <lpaste> dimonzozo pasted ‚ÄúTest‚Äù at http://lpaste.net/132811
13:56:21 <SrPx> it is very frustrating to write a geometry library on top something that does not make sense
13:56:21 <tmtwd>  last' = foldr1 (\_ acc ->acc)
13:56:26 <tmtwd> what about this fold
13:56:35 <tmtwd> the remainder would be []
13:56:38 <ion> SrPx: Many people would like the numeric typeclass hierarchy to be better. For instance, abs and signum being in the same class as fromInteger is a problem for a number (no pun intended) of types.
13:56:54 <tmtwd> so the function should be broken, no? but it works fine
13:59:07 <ion> SrPx: There are project such as <https://wiki.haskell.org/Numeric_Prelude> but i haven‚Äôt tried them.
14:00:34 <kirill`> I just noticed that mod is not defined for floating-point numbers, only for Integral.
14:01:04 <dolio> Some module somewhere has mod' for fractional or decimal type things.
14:01:13 <indiagreen> Data.Fixed, I think
14:01:15 <ion> It‚Äôs in the obvious place: Data.Fixed
14:04:30 <kirill`> Hm, so the definition of Data.Fixed.div' is
14:04:30 <kirill`> div' n d = floor ((toRational n) / (toRational d))
14:04:30 <kirill`> which looks odd to me, because if I have two floating-point numbers, they would be converted to rational numbers, and only then divided.
14:05:44 <dolio> Maybe that's for higher precision.
14:06:11 <monochrom> but Data.Fixed does not talk about floating-point numbers, does it?
14:07:33 <geekosaur> I think it uses fmod for conversion and exports it because nobody else was?
14:07:35 <dolio> I think it does, contrary to its name. Or it at least has functions that are useful for floating point numbers.
14:10:00 <arbelos> Is there a showHex equivalent for ByteString
14:10:08 <dolio> It's also good that the definition of a Real (which is what div' and mod' use) is that you can turn it into a rational. :)
14:10:31 <monochrom> interesting. it wants to cover all Real instances. so (/) is not already available.
14:10:59 <monochrom> and you do not already start with floating-point.
14:11:28 <arbelos> Or in general, what's the best way to translate an Int to its hexadecimal representation as a ByteString?
14:11:48 <arbelos> best = most time efficient
14:11:54 <monochrom> I would use Numeric's showHex and pack
14:12:03 <monochrom> it is most efficient for my time
14:12:33 <arbelos> ok, i was on the same "track"
14:12:37 <arbelos> the same time track
14:12:44 <SrPx> but mod' passes through Rational
14:13:01 * hackagebot hbro-contrib 1.4.0.0 - Third-party extensions to hbro.  http://hackage.haskell.org/package/hbro-contrib-1.4.0.0 (koral)
14:14:04 <edwardk> > base 16 # 123451231
14:14:05 <lambdabot>  "75bb75f"
14:14:17 <edwardk> arbelos: you may be able to beat it on a wall clock though =)
14:14:22 <dolio> arbelos: You can use bytestring-show.
14:14:31 <dolio> It has an equivalent of showIntAtBase.
14:14:39 <monochrom> that is neat
14:14:49 <edwardk> dolio++
14:18:52 <arbelos> yes that looks like it would be the best option, only I am thinking maybe a ByteString is just overkilling it here, I mean these are fairly small numbers anyway so.. hmm
14:19:55 <monochrom> if you use Numeric.showHex alone, or "base 16" alone, you get String, if that is what you want.
14:20:39 <dolio> Yeah, unless this is a bottleneck, you may be over thinking it.
14:20:49 <dolio> And I do like to discourage people from using bytstring-show. :)
14:24:44 <arbelos> so I was thinking about something else, has there been any attempt to come up with a, can I call it, semantics for efficient "in-place" operations in functional programming. 
14:25:35 <arbelos> say in-place reverse a string
14:26:06 <HeladoDeBrownie> you mean reasoning about mutation?
14:26:11 <ion> ST?
14:26:37 <HeladoDeBrownie> or, are you talking like implementing pure functions by mutation?
14:26:42 <arbelos> yes, well, i know i can achieve this in many ways.. 
14:27:11 <arbelos> i am thinking of some sort of separation, similar to how IO is managed in Haskell
14:27:49 <arbelos> maybe the problem is no different from mutability in general, 
14:28:11 <HeladoDeBrownie> i don't comprehend the question yet
14:28:35 <arbelos> no, the question is not 100% clear, i know.. let me rephrase
14:31:56 <jmcarthur> arbelos: fusion + array recycling gets us a long way there
14:32:18 <arbelos> so, an example could be do permutations on a bunch of numbers
14:32:19 <hodapp> array recycling? hmmmm
14:33:11 <jmcarthur> hodapp: ugh, i'm looking for the paper...
14:33:17 <arbelos> say that you have some crazy algorithm doing thousands of permutations where each step is evaluated based on the result of previous steps
14:34:00 <arbelos> basically, you want to just encode this in a way where you say.. move this element to the ith position etc.
14:34:40 <jmcarthur> man, this is hard to find now. what happened?
14:35:18 <jmcarthur> anyway, array recycling is a library-level optimization found in the vector library that works with stream fusion to integrate well with mutable arrays
14:35:49 <jmcarthur> the paper has "Recycle Your Arrays!" in the title, but i can't find anything outside of paywalls right now
14:36:34 <arbelos> ok, i'll try to google it.. but don't you agree that it seems natural to have a declarative semantics for doing what a simple in-place string reverse algorithm does in C?
14:36:37 <hodapp> paywall link I still may be able to work with
14:38:41 <kai_> hi, I am having an issue with installing genprog-0.1.0.2
14:39:17 <abhillman> When I enable OverloadedStrings, it seems that I can no longer use the (++) operator unless I do something like ("HI":: String) ++ ("BYE"::String) -- is there any other way around this?
14:39:23 <RandallP> if you want your ip changed, what should you tell your isp?
14:39:41 <abhillman> Oops (++) with strings, rather -- without qualifying the type
14:39:46 <mauke> abhillman: how does it fail?
14:40:09 <mpickering> kai_: Please paste the full build log
14:40:12 <mpickering> @lpaste
14:40:12 <lambdabot> Haskell pastebin: http://lpaste.net/
14:40:19 <mauke> RandallP: 
14:40:25 <mauke> oops, misclick
14:40:40 <RandallP> hello
14:42:02 <abhillman> http://lpaste.net/6860145318218956800
14:42:13 <kai_> http://lpaste.net/132813
14:42:38 <mauke> abhillman: yeah, that's because the type is ambiguous
14:42:39 <bergmark> kai_: you need an older ghc version
14:43:12 <mpickering> kai_: You need to "cabal install genprog-0.1.0.2 --allow-newer"
14:43:14 <abhillman> mauke: Got it... It is relatively verbose to qualify ::String -- any other way? No problem if there is not
14:43:27 <mpickering> For some reason it picks up genprog-0.1 rather than the latest version
14:43:45 <mauke> abhillman: "HI" ++ "BYE" :: String
14:43:55 <abhillman> mauke: Oh, sweet, that is definitely better
14:44:18 <exio4> I thought there'd be defaulting
14:44:23 <mauke> exio4: yeah, me too
14:44:25 <kai_> bergmark - I have successfully installed genprog with cabal-1.16 and ghc-7.6.3
14:44:47 <kadoban> abhillman: In most cases you wouldn't have to specify anyway, because some other part would require it to be String, but since 'print' doesn't narrow it down ‚Ä¶
14:44:57 <kai_> mpickering - I see. And it should work with ghc-7.10 and which cabal version?
14:45:02 <mpickering> 1.22
14:45:06 <mpickering> or any I guess
14:45:09 <exio4> mauke: apparently, there is
14:45:11 <mpickering> it's not really to do with the cabal version
14:45:14 <bergmark> mpickering: kai_ the newer versions have a base constraint so that's why it fails, i queued a build for it so i can fix the constraints (might take a while) http://matrix.hackage.haskell.org/package/genprog
14:45:43 <exio4> using Data.Monoid.<> helps
14:45:46 <kai_> mpickering - ok. let me give it a try
14:45:57 <mpickering> bergmark: ah that makes sense thanks, I love the matrix builder btw
14:46:20 <kai_> bergmark - I see. 
14:46:33 <exio4> mpickering: the default doesn't work that nicely, because it is IsString [a], not IsString a, I am guessing 
14:46:47 <exio4> uhh, mauke *
14:46:49 <Big_G> Any advice on convincing a bunch of Java devs to move to Haskell?
14:47:11 <mauke> "don't"?
14:47:12 <abhillman> kadoban: Got it. I am having one other issue. http://lpaste.net/7214129741001916416
14:47:58 <kai_> bergmark - So, I have successfully installed genprog. But I am having an issue when I try to use the package(by writing command - :set -package genprog) in ghci-7.6.3. ghci crashes.
14:48:08 <exio4> abhillman: (++) only appends lists
14:48:13 <mauke> abhillman: well, yes. (++) doesn't magically convert types
14:48:25 <mauke> that is, the result of (++) has the same type as its arguments
14:48:39 <MP2E> this post contains a lot of links to things related to persuading programmers to use Haskell http://www.reddit.com/r/haskell/comments/3677eb/help_me_change_my_mind_about_learning_haskell/crbcr7s
14:48:42 <mauke> oops, misreading the code, even
14:48:49 <MP2E> note that I'm terrible at persuading others to use Haskell though :P
14:48:53 <mauke> you're literally doing (... :: TypeA) :: TypeB
14:49:02 <exio4> abhillman: I'd guess Query has a monoid instance, so maybe you could use <>..
14:49:20 <exio4> abhillman: or avoid doing (<>) at all, and just use the constant..
14:49:38 <exio4> ... I misread the code too
14:49:43 <RandallP> if you want your ip changed, what should you tell your isp?
14:49:45 <exio4> what mauke said :)
14:49:47 <abhillman> exio4: Yes, query is a Monoid instance
14:50:13 <bergmark> kai_: might be a bug that has been fixed in later ghcs? it seems like --allow-newer works like mpickering suggested
14:50:19 <abhillman> exio4: When you say "use the constant" how do you mean? 
14:50:32 <exio4> ("SELECT * FROM " ++ "Y"::String)::Query 
14:50:41 <exio4> => "SELECT * FROM Y"
14:51:08 <kai_> So, that seems the way. Thanks, mpickering and bergmark. I will try that.
14:51:23 <mauke> abhillman: why do you have :: String in there?
14:51:55 <abhillman> exio4: I see -- in general I can't do that as I am writing a function -- createDatabase databaseName = ("CREATE DATABASE " ++ databaseName)::Query
14:52:12 <exio4> abhillman: use <>, it's basically concatenation 
14:52:15 <abhillman> exio4: Or trying to write a function that in essence does what I wrote
14:52:19 <abhillman> exio4: kk
14:52:22 <MichaelBurge> Is there an easy way to turn a 'State s a' into a 'StateT s m a'?
14:53:16 <exio4> abhillman: ++ is just a concrete case of (<>), with lists
14:53:54 <abhillman> exio4: How do I import <>
14:53:58 <stobix> MichaelBurge: Yes, but I don't remember how. :)
14:54:06 <abhillman> exio4: Only in TemplateHaskell/
14:54:07 <abhillman> ?
14:54:07 <jle`> MichaelBurge: there's a function in mmorph library, but the better way is to jsut never use State s a
14:54:25 <jle`> and write your functions parameterized over Monad m => StateT s m a
14:54:29 <Big_G> MP2E, Thanks. I am too which is why I'm asking. The goal is just to write enough haskell before they notice so they can't throw it away
14:54:45 <mauke> abhillman: should be in Data.Monoid
14:55:06 <abhillman> mauke: Yep, looks like it's there
14:55:11 <abhillman> Didn't come up on hoogle
14:55:18 <jle`> @hoogle (<>)
14:55:18 <lambdabot> Data.Text.Internal.Builder.Functions (<>) :: Builder -> Builder -> Builder
14:55:18 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
14:55:18 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
14:55:21 <mauke> @where hayoo
14:55:22 <abhillman> https://www.haskell.org/hoogle/?hoogle=%28%3C%3E%29
14:55:22 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
14:55:22 <jle`> interesting
14:55:27 <mauke> try hayoo
14:55:51 <abhillman> Yep, comes up on hayoo
14:56:06 <abhillman> Yep, (<>) works
14:56:10 <jle`> does it come up on New Hayoo(tm) ?
14:56:19 <jle`> er, new hoogle
14:56:42 <jle`> oh neat it does
14:56:55 <MichaelBurge> jle`: Thanks for that suggestion, I'll probably just do that
14:57:16 <simpson> MichaelBurge: Don't forget that State s a is StateT s Identity a.
14:57:42 <jle`> MichaelBurge: the method in mmorph is only when you have to work with a library that gave you methods unfortunately monomorphic over State s a, instead of Monad m => State s m a
14:57:49 <simpson> ...Actually, something of form `(forall x. f x -> g x) -> StateT s f a -> StateT s g a` might be nice.
14:57:53 <jle`> if you have control over everything, just keep your signatures polymorphic :)
14:57:59 <jle`> simpson: yes, that's `hoist` from mmorph
14:58:10 <simpson> jle`: Aha.
14:58:54 <jle`> it's actually made into a typeclass to work with WriterT, ReaderT, etc, heh
14:58:55 <abhillman> Bah, this is killing me. Still no luck with (<>) in the context of the method I am writing http://lpaste.net/691832683499618304
14:59:10 <jle`> what version of ghc are you using abhillman ?
14:59:21 <abhillman> jle`: 7.8.4
14:59:26 <jle`> hm
14:59:30 <abhillman> * 7.8.3
14:59:47 <kadoban> abhillman: And the error is?
14:59:49 <jle`> what does "no luck" mean?
15:00:13 <abhillman> http://lpaste.net/3536394278169214976
15:00:30 <Big_G> I hear I may need to learn about transformer monads for large projects. Is this true?
15:00:37 <jle`> maybe
15:00:41 <abhillman> loadData.hs is in the last lpaste
15:00:52 <HeladoDeBrownie> abhillman, do you have OverloadedStrings on? (and does Query have an IsString instance?)
15:01:06 <exio4> abhillman: you're saying the parameter, databaseName is of type DatabaseName, or String
15:01:21 <HeladoDeBrownie> oops, missed that
15:01:24 <exio4> abhillman: yet, in the code, you treat it as a Query (:: Query)
15:01:42 <abhillman> HeladoDeBrownie: I do have OverloadedStrings on; Query is an instance of IsString https://hackage.haskell.org/package/postgresql-simple-0.0.3/docs/src/Database-PostgreSQL-Simple-Types.html#Query
15:01:47 <kadoban> abhillman: databaseName is of type DatabaseName, yet you're trying to say it's a Query, that's presumably not correct. :: is type annotations, not casts
15:01:49 <Big_G> jle`, Maybe?
15:02:02 <jle`> you should probably make your function createDatabase :: Query -> IO Int64, abhillman 
15:02:06 <exio4> abhillman: if you want to "cast" it from String to Query, you will have to call a function that does that
15:02:07 <jle`> or else type DatabaseName = Query
15:02:10 <MichaelBurge> Big_G: Yeah, but usually because you want to carry IO along
15:02:29 <jle`> Big_G: maybe :) tranformers are one way to implement monads with multiple effects
15:02:32 <Big_G> MichaelBurge, Carry IO how? This will be a RESTful web service.
15:02:46 <Big_G> jle`, Can you give an example?
15:02:49 <abhillman> jle`: That makes sense, but it's not really a query (conceptually -- not in terms of types)
15:02:54 <exio4> abhillman: the code you pasted is from a really old version, too
15:03:00 <abhillman> exio4: What is a great way to do this with a function?
15:03:02 * hackagebot idris 0.9.18 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.18 (EdwinBrady)
15:03:09 <Big_G> Also, how does it play with JSON? Will I have to define what will be in the JSON before?
15:03:11 <abhillman> exio4: Go from String -> Query
15:04:00 <abhillman> exio4: Ah, weird. True. Newer docs: https://hackage.haskell.org/package/postgresql-simple-0.4.10.0/docs/src/Database-PostgreSQL-Simple-Types.html#Query
15:04:13 <abhillman> Thanks
15:04:25 <jle`> Big_G: sometimes it is convenient to have things that have access to a shared environment, to facilities of a framework, and also IO
15:04:53 <jle`> monad transformers sort of give you the ability to construct monads that have have multiple effects "for free"
15:04:55 <Big_G> jle`, Isn't the entire point of Haskell to not have pointers? 
15:05:04 <jle`> what pointers are we talking about here?
15:05:16 <Big_G> I can see how that'd be useful but it seems like that gets in the way of other benefits. 
15:05:17 <jle`> for a REST server, one shared environment might be something like your hostname/domain
15:05:21 <Big_G> Pointers to the same chunk of memory
15:05:28 <jle`> ah, we aren't talking about pointers here
15:05:41 <jle`> or access to actual memory
15:06:13 <exio4> abhillman: actually, checking the documentation, it seems what you want is to use ? inside the query, and then give it as a parameter
15:06:14 <jle`> just things like, when you "run" your app, it would be nice to be able to run it differently based on things like...what domain you're hosted on.  or configuration settings
15:06:42 <Big_G> jle`, Yeah. We have that in our Java code base all of the place. So monad transformers are the only way to do that?
15:06:44 <exio4> abhillman: basically execute connection "CREATE DATABASE ?" [databaseName] or something similar
15:06:47 <jle`> this is a recent tutorial that has a lot of motivations for monads with mutliple effects
15:06:49 <jle`> https://www.fpcomplete.com/user/AthanClark/overloaded-monadic-deployment
15:06:51 <jle`> Big_G: not the only way
15:06:54 <jle`> they are a "free" way
15:06:57 <MichaelBurge> Big_G: One common transformer stack I use is 'StateT ProgramState IO a', which is an action that can read/write an implicitly threaded state, can do any IO it wants, and returns a value of type a
15:07:28 <Big_G> MichaelBurge, That is still a bit abstract. Can you give a concrete example?
15:07:33 <jle`> they are a way to take any normal monad and automatically give it state abilities, or environment abilities, etc.
15:07:34 <MichaelBurge> The implicit state is often the command line arguments provided to the program, or accumulated statistics
15:07:43 <MichaelBurge> I can show you some code if you want
15:07:45 <jle`> typically when you actually write a program you don't worry about monad transformers themselves
15:07:54 <RandallP> does the government actually have any control over wikipedia? just wondering, or if there is possibly some corruption
15:07:55 <Big_G> MichaelBurge, That'd be great
15:07:56 <jle`> you can just say, "i'm writing this in a monad that has environment/state/accumulator/logging"
15:08:21 <jle`> the tutorial above gives some nice motivations for incorporating multiple effects into a single monad
15:08:31 <jle`> note that in real life, you actaully shouldn't be working directly with monad transformers when you write your code
15:08:31 <Big_G> jle`, That sounds wonderful. I wouldn't have to worry about logging at all?
15:08:33 <mauke> RandallP: this channel is about haskell, not wikipedia or isps
15:08:51 <RandallP> whats a good channel about isps mauke?
15:08:54 <jle`> you should work with things like, "this function works for all monoads that have environment, logging, state..."
15:08:55 <mauke> I don't know
15:09:09 <abhillman> exio4: That would be most ideal -- but does not work because the query sent to PSQL is "CREATE DATABASE 'database-name'" -- which is not quite correct since PSQL only accepts the databse name in double-quotes; so AFAIK the query must be constructed from scratch, unfortunately
15:09:27 <jle`> and then at the end, you can say, "well, now i have a function that works for monads that have environment, framework access, etc..  now i just have to make one."
15:09:31 <abhillman> exio4: I believe this ticket articulates the same issue https://github.com/lpsmith/postgresql-simple/issues/76
15:09:35 <jle`> the easiest way to do that is to use monad transformers
15:10:14 <Big_G> jle`, I'm still a bit lost. Is this something I can put off until I have a solid code base?
15:10:15 <exio4> abhillman: er, then I think hacking it using Data.String.fromString, ... as last resort.. :/
15:10:16 <jle`> but that's like saying, "now my function works for all things i can add, subtract, and multiply.  but now ia ctaully need a type, to run it"
15:10:28 <jle`> like, i have a function Num a => a -> a -> a
15:10:34 <Lokathor> so, Either doesn't have a monad instance by default?
15:10:40 <jle`> if you wanted to actually run the function, you need to run something like Int
15:10:43 <jle`> or Double
15:10:55 <jle`> Lokathor: Either e should have  monad instance...
15:11:01 <jle`> unless you're using a version of haskell from the 90's maybe
15:11:19 <jle`> Big_G: yeah, you don't really have to learn it until you need it.  it's one of the things like that
15:11:25 <Lokathor> hmm
15:11:33 <jle`> if you can't understand the tutorial, don't worry about it; you can just come back when you need it
15:11:45 <Big_G> jle`, When exactly would I need it? I imagine we'll need logging and configuration files pretty early on
15:11:47 <jle`> but the role of monad transformers is analogous to the role of Int, Double, etc., when you have functions Num a => a -> a -> a
15:11:59 <jle`> Big_G: the nice thing about monads is that you almost never really *need* monads
15:12:04 <jle`> they're just useful for plumbing
15:12:09 <jle`> and abstracting away boilerplate
15:12:27 <jle`> so if you want, you can just do things with manual boilerplate until you feel ready to refactor
15:12:32 <ReinH> Lokathor: Either has the wrong kind
15:12:50 <Lokathor> well, (Either e) i guess i mean
15:12:59 <ReinH> Either e has a monad instance
15:12:59 <jle`> what makes you think it doesn't have a monad instance?
15:13:18 <ReinH> > return 1 :: Either String Int
15:13:19 <lambdabot>  Right 1
15:13:39 <jle`> > sequence [Right 3, Right 10, Right 0]
15:13:41 <lambdabot>  Right [3,10,0]
15:14:04 <Big_G> jle`, What would be the standard boilerplate for something like logging. I know it was a huge pain in the ass for our Java code
15:14:06 <Lokathor> jle`, i couldn't seem to find it in the docs, and ghci was giving me trouble, so i wasn't sure if i was trying the wrong thing or forgetting an import
15:14:26 <ReinH> The Either e instance is in the prelude
15:14:33 <jle`> Lokathor: http://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Either.html#t:Either
15:14:36 <jle`> seems to be there for me
15:14:44 <jle`>  > :i Either
15:14:49 <ReinH> You shouldn't need to import anything
15:14:52 <jle`> instance Monad (Either e) -- Defined in 'Data.Either'
15:15:06 <jle`> what version of GHC are you using?
15:15:28 <jle`> Big_G: i am not sure myself, i've never worked with it.  but feel free to ask around :)
15:15:47 <Lokathor> 7.8
15:15:50 <Big_G> jle`, Does that mean you've always used monad transformers?
15:15:51 <Lokathor> i guess my code was just all wrong
15:16:06 <jle`> Big_G: it just means i've never used logging, heh
15:16:15 <lpaste> Lokathor pasted ‚Äúexample‚Äù at http://lpaste.net/132816
15:16:16 <Big_G> Also, any idea on how to get a proxy working for cabal? apt-get works fine but cabal just hangs
15:16:25 <Big_G> jle`, I wish that was an option for use
15:16:26 <Big_G> us
15:16:36 <dcoutts> Big_G: http_proxy env var
15:16:46 <Lokathor> what i would like is to do a, then b, then either do c or print the string
15:16:57 <Big_G> dcoutts, I have that but it doesn't work
15:17:11 <Lokathor> but i'm not seeing how do do that without using two separate case statements
15:17:15 <dcoutts> Big_G: is it anything exotic?
15:17:18 <jle`> Lokathor: why not make your functions Int -> Either String Int
15:17:22 <jle`> or Double -> Either String Double
15:17:25 <dcoutts> Big_G: you can use -v3 and see if there are any clues
15:17:39 <Lokathor> in this case, the IO is required becaues it's using SDL2 stuff
15:17:50 <Lokathor> that's more like a "minimal example" sort of thing
15:18:12 <jle`> can you show what you want with the separate case statements?
15:18:15 <jle`> it's not totally clear
15:18:15 <Big_G> dcoutts, Just a corporate proxy at work
15:18:32 <Lokathor> yeah hold on
15:19:13 <jle`> it might turn out that you don't want a Monad instance for (Either e), but a Monad instance for (IO . Either e)
15:19:14 <dcoutts> Big_G: and things like wget/curl work with that http_proxy?
15:19:26 <Big_G> Let me check
15:19:27 <jle`> in which case you need a newtype wrapper
15:19:35 <jle`> that gives that instance for you
15:19:46 <Big_G> dcoutts, I know pinging google doesn't
15:20:49 <Big_G> dcoutts, curl google gets some html with a 301
15:21:30 <dcoutts> Big_G: try getting a .tar.gz from hackage using curl/wget, if that works then we ought to be able to make cabal work fine
15:21:37 <lpaste> Lokathor pasted ‚Äúupdated-example‚Äù at http://lpaste.net/132817
15:21:48 <Big_G> dcoutts, How would I do that?
15:22:42 <Big_G> I get the webpage when I curl hackage
15:24:31 <dcoutts> Big_G: e.g. http://hackage.haskell.org/package/zlib-0.6.1.1/zlib-0.6.1.1.tar.gz
15:24:48 <dcoutts> Big_G: but sounds like that does work, so next thing is to try cabal update -v3 and see what we can see
15:25:07 <Big_G> I tried cabal update only one line printed out
15:25:21 <Lokathor> jle`, the genearl idea is that one function starts sdl2 and gets a window, the next loads a file, and if both worked out i want do the drawing step. Otherwise i want to print the error that came back
15:25:58 <dcoutts> Big_G: cabal update -v3  will show the http conversation
15:26:23 <dcoutts> and will say if it's trying to use the proxy for example
15:27:29 <Big_G> Looks like it is. When I get a package not found error from ghc, how do I convert that to a cabal package I can install?
15:28:03 <dcoutts> Big_G: wait, so it wasn't hanging? it was actually working?
15:28:18 <Big_G> It finished after a while. I want to see if that was the issue.
15:28:22 <dcoutts> ah
15:28:42 <dcoutts> Big_G: you mean given a module name, work out which package supplies it?
15:28:53 <jle`> Lokathor: ah yeah, you don't want a Monad instance for Either e
15:28:55 <Big_G> Yeah
15:29:01 <dcoutts> Big_G: currently we don't have a good method for that, just have to use google site:hackage.haskell.org
15:29:01 <jle`> you want a Monad instance for (IO . Either e)
15:29:07 <jle`> so you can bind things like IO (Either e a)
15:29:18 <c_wraith> That's more or less EitherT e IO
15:29:28 <jle`> IO (Either e a) -> (a -> IO (Either e b)) -> IO (Either e b)
15:29:29 <Big_G> dcoutts, Someone should make that mapping
15:29:30 <c_wraith> :t EitherT
15:29:31 <lambdabot>     Not in scope: data constructor ‚ÄòEitherT‚Äô
15:29:31 <lambdabot>     Perhaps you meant variable ‚Äòeither‚Äô (imported from Data.Either)
15:29:33 <jle`> yeah, exactly :)
15:29:44 <jle`> these days the trendy thing is ExceptT
15:29:44 <DarkElement> Sorry to interrupt, but do any of you know where I can find large logs of this or other channels? I'm making a bot and would really like some more data.
15:29:50 <dcoutts> Big_G: I'm planning to add it to the hackage search function
15:29:52 <jle`> DarkElement: it's in the topic :)
15:30:04 <DarkElement> ._. thanks
15:30:07 <Big_G> dcoutts, You're a saint
15:30:25 <ij> Can I make ghci ommit all the crap at the beginning?
15:30:32 <Lokathor> so look into EitherT?
15:30:37 <rhaps0dy> and this channel is very active, you'll get lots of lines
15:30:42 <jle`> ExceptT is in transformers/mtl
15:30:47 <jle`> EitherT is only in a separate library
15:31:13 <DarkElement> Now that i'm here, what is haskell most similar to, language-wise?
15:31:22 <Lokathor> i recall something about transformers and mtl being very similar, but not quite
15:31:32 <Clint> mtl is built on top of transformers
15:31:42 <jle`> transformers provides monad transformers (like ExceptT), and mtl provides typeclasses that abstract over monads with multiple effects
15:32:40 <kadoban> DarkElement: Of the procedural languages that people commonly know, it's about equidistant from them all. It's /wayyyy/ over there on the right somewhere, and they're grouped fairly closely wayyyyy on the left (on an imaginary graph of closeness to haskell)
15:33:57 <DarkElement> kadoban, Haha, alright. So would you say it's a good scripting language then? Still containing the general concepts that relate it to other languages
15:34:22 <Lokathor> haskell has some libs that let you do scripting type things easily
15:34:32 <lpaste> jle` annotated ‚Äúupdated-example‚Äù with ‚Äúupdated-example (annotation)‚Äù at http://lpaste.net/132817#a132818
15:34:44 <jle`> Lokathor: i added an annotation on how you'd use ExceptT to do what you want
15:34:55 <lpaste> jle` revised ‚Äúupdated-example (annotation)‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/132818
15:35:01 <kadoban> DarkElement: Wellll, it's not really a scripting language per-se. I guess you could kinda use it as one, but it's probably not great at that
15:35:12 <DarkElement> kadoban, so what does it do best?
15:35:12 <Lokathor> ah ha, yes this is the sort of cleanlyness that i figured could be attained
15:35:14 <jle`> oops, edited it
15:35:40 <jle`> you can also just return (i, d) from the ExceptT block
15:35:40 <Big_G> How do I resolve a missing dependecy on a ofrien library from cabal?
15:35:50 <jle`> and then call c i d from "outside" the block
15:36:11 <dcoutts> Big_G: usually it's a matter of apt-get installing the appropriate -dev package
15:36:39 <zed_> hi : ) is there someone who ever worked through this example: http://ptrckprry.com/blog/programming/2008/08/26/a-monte-carlo-monad-for-haskell/
15:36:42 <Big_G> It says that package doesn't exist in zlib
15:36:54 <kadoban> DarkElement: It's general purpose, just 'scripting language' is kind of just "execute this series of imperative steps". If that's all you're doing, haskell won't do much for you really.
15:37:12 <jle`> kadoban: it can offer type safeness :)
15:37:43 <jle`> the benefits of haskell extend to imperative algorithms too
15:39:02 <mauke> DarkElement: haskell is similar to miranda and ocaml
15:39:29 <DarkElement> Hmm, time to look up miranda and ocaml
15:39:53 <ReinH> Well, I prefer it to bash for many scripting tasks
15:40:35 <DarkElement> Interesting, not what I expected
15:40:43 <DarkElement> Maybe I'll get into Haskell later
15:41:13 <Lokathor> if i have an algorithm in Java that works via lots of variable mutation, assuming i wanted a Haskell version with a similar structure, I'd probably use State and possibly lenses, right?
15:41:13 <Tuplanolla> It'll teach you to hate many other languages, if nothing else, DarkElement.
15:41:32 <mauke> Lokathor: possibly ST if it's local mutation
15:41:52 <Lokathor> it is local to each function call, yes
15:41:59 * DarkElement is offered haskell by a guy in a dark alleyway
15:42:05 <DarkElement> ._.
15:42:11 <mauke> the first tutorial is free
15:43:22 <mauke> > runST (do v <- newSTRef 21; modifySTRef v (* 2); readSTRef v)
15:43:23 <lambdabot>  42
15:43:32 <mauke> there, local variables
15:44:30 <Lokathor> in this case, the algo is a *little* more complex than that sadly
15:46:19 <ronh-> Lokathor why would that be a problem? you can allocate as many STRefs as you need, and do arbitrary mutations on each
15:46:29 <Lokathor> oh it's not a problem really
15:47:12 <simpson> Lokathor: What's the algorithm?
15:47:41 <Lokathor> an FOV computation thing, https://github.com/Lokathor/JRoguelikeToolkit/blob/master/src/main/java/rl/toolkit/fov/PPFOV.java is the code
15:48:41 <Tuplanolla> Bresenham?
15:48:51 <Tuplanolla> It shouldn't require mutable state.
15:49:14 <c_wraith> bresenham is just a list of inflection points.
15:49:16 <Lokathor> it's not Bresenham
15:49:25 <c_wraith> err.  not inflection, transition
15:49:49 <Lokathor> this kind of FOV is called Precise Permissive
15:50:23 <c_wraith> That looks like a BFS, of sorts
15:50:31 <Tuplanolla> This seems vaguely familiar. Does DCSS use this?
15:50:45 <Lokathor> it involves keeping a list of "views", and then scanning out wards and updating the views as you find walls
15:50:58 <c_wraith> that's very BFS-like
15:51:00 <Lokathor> also, DCSS does use this, as far as i know
15:51:48 <Tuplanolla> You're probably better off without ST.
15:52:25 <Lokathor> I'm not quite savvy enough in Haskell yet to try to convert this particular part of Java into Haskell
15:52:26 <c_wraith> I wrote a combinator to capture the recursion pattern of "process a list of elements storing state and adding to the list with each element processed"
15:52:35 <c_wraith> http://lpaste.net/102101
15:53:08 <c_wraith> I don't even remember how it works, but I keep it on hand because it does.  :)
15:53:56 <SrPx> til haskell complains of ambiguous instances even when a class has only one instance o.o
15:54:12 <c_wraith> You might always add another instance
15:54:26 <SrPx> I know, just found it funny
15:54:29 <c_wraith> It's warning you that it doesn't have enough information to know for sure that you mean the one that exists.
15:54:31 <geekosaur> typeclasses are open
15:54:32 <monochrom> until link time no one knows "there is only one instance"
15:54:38 <geekosaur> ^
15:54:49 <SrPx> fair enough
15:54:50 <geekosaur> except typeclasses are long gone by then...
15:54:54 <monochrom> and we are too lazy to write our own linkers. we just call ld, which only knows C, not haskell.
15:55:00 <geekosaur> there are only dictionaries passed at runtime
15:55:57 <monochrom> lastly, if you have only one instance, don't use a type class.
15:57:04 <Lokathor> monochrom, what if you know you proabbly want to write a second instance later on?
15:57:19 <Lokathor> wait until then?
15:57:39 <monochrom> then "there will only be one instance" is false.
16:01:55 <tel> Is it the case that Coyoneda is "the" free Functor? What about Yoneda then?
16:03:25 <abhillman> Is there a great way to read the type of an object into a string?
16:03:48 <c_wraith> abhillman: at runtime or compile-time?
16:03:56 <johnw> abhillman: if it's Typeable (which everything is in 7.10), you can yes
16:03:57 <abhillman> c_wraith: runtime
16:04:03 <c_wraith> > show $ typeOf "Hello"
16:04:04 <lambdabot>  "[Char]"
16:04:07 <c_wraith> > show $ typeOf ()
16:04:09 <lambdabot>  "()"
16:04:50 <Lokathor> johnw, were some things not typeable before 7.10?
16:05:05 <c_wraith> 7.10 made Typeable instances auto-generated for all types
16:05:10 <abhillman> c_wraith: Wow, thanks this is great
16:05:13 <c_wraith> Before that, you had to manually specify you wanted one
16:05:36 <c_wraith> :t typeOf
16:05:37 <lambdabot> Typeable a => a -> TypeRep
16:06:04 <lpsmith> abhillman,  you can do that now,  see https://github.com/lpsmith/postgresql-simple/commit/5cc3d00770b985c3ca59d8d1ff8faf03a1ff5eb5 and https://github.com/lpsmith/postgresql-libpq/commit/9966598852fc31cc1fad7c3b2833362fb65af20b 
16:06:51 <lpsmith> no need to construct the query from scratch,  just use the Identifier and/or QualifiedIdentifier types in the Types module.
16:06:53 <abhillman> lpsmith: Yea! I noticed that. Trying to figure out how to get it to work
16:07:57 <lpsmith> abhillman,  if you use {-# LANGUAGE OverloadedStrings #-},   you can write things such as  execute conn "DROP TABLE ?" ("schema.tablename" :: QualifiedIdentifier)
16:08:07 <lpsmith> err, there'll need to be an Only on that
16:08:27 <abhillman> lpsmith: Nice, let me give that a try
16:08:34 <tel> Offhand, (liftCoyoneda :: f a -> Coyenda f a) not requiring a Functor constraint feels right w.r.t. it being the free Functor functor
16:17:32 <abhillman> lpsmith: http://lpaste.net/6115632103464894464
16:20:58 <johnw> tel: where did you read that it's the free Functor functor?
16:21:22 <tel> johnw I didn't, I'm trying to figure it out
16:21:28 <abhillman> lpsmith: In general, can work around the issue by using (<>)
16:21:42 <abhillman> lpsmith: Would love, however, to use QualifiedIdentifier
16:21:50 <johnw> tel: I ask, because just last week I made a note to myself to investigate whether Yoneda is the same thing as the free functor :)
16:21:54 <dmj`> abhillman: why can't you?
16:22:20 <dmj`> QualifiedIdentifier (Maybe Text) Text
16:23:03 <tel> johnw Haha, yeah. There's something complicated here and I'm not completely sure how to wrap my head around it
16:23:39 <lpsmith> abhillman,  in this case,  you could use toString
16:24:17 <lpsmith> however, toString on QualifiedIdentifer isn't all that robust
16:24:35 <lpsmith> so it's there mostly for writing literal QualifiedIdentifiers
16:24:46 <lpsmith> :t toString
16:24:48 <lambdabot>     Not in scope: ‚ÄòtoString‚Äô
16:24:48 <lambdabot>     Perhaps you meant ‚ÄòBSLC.toStrict‚Äô (imported from Data.ByteString.Lazy.Char8)
16:26:42 <lpsmith> err
16:26:44 <lpsmith> :t fromString
16:26:45 <lambdabot> IsString a => String -> a
16:27:29 <johnw> tel: for example, there's http://stackoverflow.com/questions/14387839/functors-and-free-objects-in-hask
16:27:29 <lpsmith> In the case of "CREATE DATABASE ?",  you probably want to use Identifier,  not QualifiedIdentifier
16:27:31 <lpsmith> so
16:28:52 <johnw> tel: there are other ways (container type in dependently typed languages, for example) to turn things that are not Functors into Functors, and they are not a free object for functors either
16:30:02 <lpsmith> abhillman, http://lpaste.net/6115632103464894464
16:30:39 <tel> johnw I'm looking for the functor left adjoint to a forgetful functor which merely drops `fmap`
16:31:01 <johnw> i don't think you can drop fmap using a functor :)
16:31:06 <kirill`> I'm trying to use the CPP extension, and seem that __LINE__ gets expanded to line number, but __FUNCTION__ doesn't exist. I'd like to get the top-level haskell definition in which the pragma got expanded, like in C++. Is there a way to do that?
16:31:11 <johnw> all forgetful functors have to have fmap
16:31:29 <tel> johnw well, no, it's a higher order functor in this case
16:31:37 <tel> Forget :: (* -> *) -> (* -> *)
16:31:51 <Tuplanolla> Isn't it __func__, kirill`?
16:32:31 <kirill`> Tuplanolla: ghc gives me "found hole __func__"
16:33:12 <tel> We can pretend with something like `type Forget g a = g a` and then promising to never call `fmap` on `g`s recieved in this case 
16:33:28 <Tuplanolla> That's funny.
16:33:42 <kirill`> It might be __func__ depending on C++ compiler, I don't remember tbh
16:34:07 <Tuplanolla> I don't know about C++, but it's __func__ in modern C revisions.
16:34:17 <tel> Or we can reify Functor into types more specifically and say `data AFunctor f a = Af { body :: f a, fmap :: forall a b . (a -> b) -> (f a -> f b) }`
16:34:26 <johnw> tel: so you mean stripping away the morphism mapping, to leave just the object mapping
16:34:33 <abhillman> lpsmith: Nice! Thanks! This looks great
16:34:51 <kirill`> Tuplanolla: I looked it up, you're right, __func__ is standard
16:34:55 <geekosaur> __FUNCTION__ is implemented inside of gcc, it is not cpp. and if it were in cpp, cpp would not understand Haskell declarations
16:35:08 <tel> johnw yeah
16:35:11 <johnw> how would the free functor to that provide the morphisms back?
16:35:32 <tel> instance Functor (Coyoneda f)
16:35:36 <kirill`> geekosaur: Okay, so ghc doesn't expand anything like that?
16:35:38 <tel> instance Functor (Yoneda f)
16:35:46 <johnw> that doesn't really answer my question though
16:35:48 <geekosaur> not that I'm aware of, no
16:36:00 <johnw> forget Haskell for a moment
16:36:14 <kirill`> That's a shame, it would be helpful
16:36:58 <johnw> you have a category whose objects are functors, mapping objects and morphisms; and a category whose objects are just object mappings; the free functor going back would have to enrich the second category with morphism mappings, but this information has been lost
16:38:08 <abhillman> Is there some simple way to say "1." looks like a float whereas "1" looks like an int? I could check for "." then dispatch to Text.Read.readMaybe, for example, but wondering if there is another great way.
16:38:42 <abhillman> Dispatch to Text.Read.readMaybe s :: Int or Text.Read.readMaybe :: Float depending on whether a '.' is in there
16:38:55 <abhillman> * Maybe Int; Maybe Float respectively
16:39:16 <tel> johnw So yeah, it enriches them by holding the mapped object along with an object mapping (obj, map). We start with the id mapping which we can always access and given any object mapping f we can map (obj, map) pairs by composing f and map.
16:39:28 <tel> The same way Coyoneda works
16:39:39 <Tuplanolla> If you want precise control, it's not difficult to roll your own parser that uses Data.Char, abhillman.
16:40:28 <johnw> tel: I don't understand "enriches them by holding the mapped object"
16:40:32 <johnw> the forget functor's job is to forget
16:40:42 <johnw> not remember for the sake of the free functor
16:40:55 <mgomezch_> > let n = "1." in Left <$> readMaybe n <|> Right <$> readMaybe n :: Maybe (Either Int Float)
16:40:57 <lambdabot>  Not in scope: ‚ÄòreadMaybe‚ÄôNot in scope: ‚ÄòreadMaybe‚Äô
16:41:03 <mgomezch_> ):
16:41:09 <mgomezch_> something like that might work?
16:41:22 <abhillman> Tuplanolla: Sounds good. In general, is parsec or attoparsec a good choice? Something else?
16:41:36 <johnw> also, I don't think looking at how Coyoneda works is going to clarify our thinking, because Haskell adds a lot of structure that makes the underlying theory harder to see
16:41:49 <johnw> if we can work it out purely in a category theoretic context, then we can see how that maps back to Haskell
16:41:50 <Tuplanolla> You could define data Like a = IntLike Int | FloatLike Float and use Text.Parsec similar to how mgomezch just did.
16:42:07 <tel> johnw Yes, I don't think I need the forgetful functor to do anything besides eliminate the object mapping.
16:42:09 <abhillman> Oh wow, that is nice
16:42:13 <mgomezch_> though it doesnít actually work, as ´1.ª isnít accepted by Read Float
16:42:14 <abhillman> mgomezch_: Thanks
16:42:35 <tel> johnw I'm alright with eliminating structure from Haskell, but it's going to get increasingly difficult to discuss without some kind of notation :)
16:43:12 <johnw> tel: let's just define exactly what the free and forgetful functors do in this case
16:43:51 <johnw> since the Yoneda lemma assumes that 'f' is always a functor, so I'm not sure yet how the "feature" of Haskell's Coyoneda embedding, allowing you to use an 'f' that is not a functor, relates
16:44:02 <SrPx> Why is there no "^/^" and "^*^" operators on Linear? Should I just use "/" instead, despite it using the Num instance for vectors which you suggested me to avoid?
16:44:27 <tel> johnw: A functor is a pair (F_o, F_a), Forget (F_o, F_a) = F_o
16:44:54 <johnw> ok
16:45:05 <tel> Free F_o = (O_new, A_new)
16:45:16 <abhillman> Thanks all for the help
16:45:20 <tel> O_new obj = (F_o, id_obj)
16:45:32 <tel> rather
16:45:36 <tel> (F_o obj, id_obj)
16:46:01 <tel> A_new map = \(fobj, map) = (fobj, f . map)
16:46:21 <johnw> where is 'f' from?
16:46:25 <tel> sorry
16:46:30 <tel> A_new f = \(fobj, map) = (fobj, f . map)
16:47:24 <johnw> so, F_a is Hom(F_o, -), right?
16:47:40 <johnw> sorry, have to run
16:47:55 <johnw> i'll be back on later
16:48:08 <tel> alright, I'll keep thinking on it
16:48:14 <tel> cheers :)
16:55:38 <Pamelloes> Is there a way to convert an instance of Data.Bits into an Integer?
16:55:50 <Lokathor> any instance?
16:56:25 <Pamelloes> mhm
16:56:33 <Pamelloes> Actually, let's make it FiniteBits
16:56:52 <Lokathor> well normally i'd say fromIntegral... but for Bits
16:57:04 <Lokathor> well you could start with 0 and copy in the bits one at a time
16:57:43 <Pamelloes> hm, looks like that's my only option
16:59:17 <jasonkuhrt> Hi, I would like to know if Haskell supports delimited continuations and why/why not? And, by "delimited continuations" I mean http://www.cs.indiana.edu/~sabry/papers/yield.pdf
17:03:07 * hackagebot yaml-light-lens 0.3.1.10 - Lens interface to yaml-light.  http://hackage.haskell.org/package/yaml-light-lens-0.3.1.10 (AnthonyCowley)
17:03:09 * hackagebot webcrank 0.2.1 - Webmachine inspired toolkit for building http applications and services.  http://hackage.haskell.org/package/webcrank-0.2.1 (purefn)
17:04:29 <Axman6> jasonkuhrt: I'm no expert, but I believe the use of laziness means that such mechanisms aren't really needed. lazy lists can be used for many of the operations you'd use yield for in other languages, and for the rest, there's various streaming IO libraries (pipes, conduit etc.)
17:04:38 <geekosaur> http://hackage.haskell.org/package/CC-delcont
17:04:41 <geekosaur> ?
17:05:23 <Lokathor> Pamelloes, Prelude Data.Foldable Data.Bits> let finiteBitsToInteger x = foldl' (\int bitNum
17:05:23 <Lokathor>  -> if (testBit x bitNum) then (setBit int bitNum) else int ) 0 [0..(finiteBitSi
17:05:23 <Lokathor> ze x)]
17:05:35 <Lokathor> whoops, pasted in the newlines.. but you get the idea i think
17:07:34 <Axman6> jasonkuhrt: also, it looks like that paper includes a Haskell example of yield, and uses Haskell as the language to generalise the idea
17:07:56 <Axman6> so I guess the answer is clearly yes
17:08:06 <hodapp> dmj`: Leave like less of a coward next time.
17:08:17 <jasonkuhrt> Axman6: Ah weird I thought I fully read the paper but can't remember that ; p
17:08:32 <Axman6> 3.1 Haskell Implementations
17:09:10 <dmj`> hodapp: coward? I had you in tatters
17:09:28 <Axman6> yeah basically the whole paper is written in Haskell ;)
17:09:29 <jasonkuhrt> Axman6: In JavaScript ES6 (AKA JS2015) Generators (which are this feature) allow for what you said, implementing laziness, and also other models such as CSP
17:09:37 <jasonkuhrt> Axman6: How much do you know about this area?
17:09:57 <Axman6> practically, a fair bit, academically, not a lot
17:10:16 <jasonkuhrt> Axman6: I'm curious if there is a founding theory or paper for this, like how there is Tony Hoare for CSP
17:10:37 <hodapp> dmj`: Not really. You felt the need to cut and run.
17:10:44 <jasonkuhrt> Axman6: To me the idea seems quite interesting fundamentally because it breaks quite far from the model of a function with input and output, right?
17:10:45 <dmj`> hodapp: would you like to resume?
17:11:07 <Axman6> well, clearly, not, since it can be implemented using nothing but functions
17:11:17 <hodapp> dmj`: Take it someplace else than here.
17:11:30 <dmj`> hodapp: feel free to message me
17:11:37 <jasonkuhrt> Axman6: That's a good point, e.g. Facebook Regenerator does fully transpile Generators to compliant ES5 code...
17:12:11 <jasonkuhrt> Axman6: But on the other hand the code it generates it is completely inhumane, so then the revelation is more at the API / ergonomic level
17:12:27 <Axman6> imo, they're not really a particularly interesting topic when you've used Haskell for a while. they're pretty trivial
17:12:42 <SrPx> So what is the correct way to apply an operation to 2 vectors elementwise? On linear
17:12:53 <jasonkuhrt> Axman6: In practice are they not the ability for a function to yield `n` values over time?
17:12:53 <dolio> Delimited continuations are actually more function-like than traditional continuations.
17:13:07 * hackagebot stackage-sandbox 0.1.4 - Work with shared stackage sandboxes  http://hackage.haskell.org/package/stackage-sandbox-0.1.4 (DanBurton)
17:13:31 <jasonkuhrt> Axman6: determined programmatically at runtime, allowing for a sort of programmable function execution body 
17:13:50 <jasonkuhrt> dolio: How so?
17:13:52 <Axman6> sure, but that's par for the course in Haskell
17:13:55 <hodapp> Axman6: which paper are you talking about?
17:14:01 <Pamelloes> Lokathor: Roughyl what I came up with. Thanks :)
17:14:05 <Axman6> http://www.cs.indiana.edu/~sabry/papers/yield.pdf
17:14:09 <dolio> Because the delimiting means that when you capture up a continuation, it's a function consisting of all the stuff between where you are up to the delimiter.
17:14:10 <hodapp> Axman6: thanks
17:14:15 <SrPx> Well I'll just use the applicative hope it is okay :~
17:14:38 <dolio> Instead of a weird thing that captures infinitely far into the program's future, and can replace the entire program's future.
17:15:33 <hodapp> dolio: is that referring to how it functions, say, in Python?
17:16:21 <pavonia> SrPx: linear's vectors are instance of MonadZip which has mzipWith
17:16:52 <jasonkuhrt> dolio: Interesting... If I follow you you are saying that it is the difference between a function that has a one-shot chance to do something in its body versus a function that explicitly breaks its body into delimitied steps, so-called continuations?
17:16:56 <SrPx> I know, but is invoking monads more idiomatic than the applicative on this case? hmm
17:17:31 <dolio> hodapp: I don't know about python.
17:17:36 <dolio> I know about shift/reset. :)
17:18:45 <jasonkuhrt> Axman6: When you say "par for the course in haskell" what exactly do you mean? I know a little bit of haskell syntax and concepts but I guess not enought to know what dlimiting "looks like" in haskell; so maybe I've seen it hundreds of times and just never noticed that fact
17:20:55 <hodapp> dolio: ahh, okay. Perhaps I need to read this paper... and figure out what delimited continuations are in the first place.
17:20:55 <dolio> jasonkuhrt: I'm not sure I understand your question.
17:21:32 <kirill`> What are the ghc rules for expanding __LINE__? I have a macro that seems to work sometimes, and sometimes __LINE__ doesn't get expanded and ghc thinks it's a typehole.
17:21:37 <grpala> how can I inspect the type of an expression inside a function with GHCi?
17:21:41 <jasonkuhrt> dolio: I'm probably highly confused, and need to just go review the domain more
17:22:40 <dolio> However, traditional continuations have an operator like call/cc, which gives you access to an object representing the entire rest of the program from that point. And when you use it, it replaces the rest of the program wherever you're at with the one represented by that object.
17:22:53 <pavonia> grpala: You can replace the expression by _ and GHCi will tell you the type of that hole
17:23:40 <grpala> pavonia: yeah, but that will only tell me the most generic thing that can fit there, instead of giving me the current type an expression is being specialized as
17:23:55 <dolio> Delimited continuations let you place markers with an operator like 'reset'. And then when you call 'shift', it captures the portion of the program up to the nearest enclosing reset. And that captured thing is a function.
17:23:58 <pavonia> Ture
17:24:01 <pavonia> *True
17:24:45 <pavonia> grpala: Maybe "_ `asTypeOf` (your expression)"
17:24:58 <dolio> It takes in a value that would be appropriate for where shift was called, and returns a value that would be computed by following the program execution up to the reset.
17:25:22 <grpala> pavonia: oh, didn't know about asTypeOf
17:25:52 <grpala> pavonia: do you happen to know more of these little helpers?
17:26:05 <Axman6> :t asAppliedTo
17:26:07 <lambdabot> (a -> b) -> a -> a -> b
17:26:19 <dolio> So, the 'continuations' return, because they are segments of a program, not entire futures of a program.
17:27:05 <pavonia> asAppliedTo is lambdabot only, no?
17:27:31 <Axman6> :t map `no idea. it's the only place I've used it =)
17:27:32 <lambdabot> parse error on input ‚Äòidea‚Äô
17:27:47 <Axman6> whoops
17:27:55 <pavonia> @hoogle asAppliedTo
17:27:56 <lambdabot> No results found
17:28:34 <HeladoDeBrownie> @type const `asTypeOf` asAppliedTo
17:28:35 <pavonia> Hhm, and there was a third one
17:28:35 <lambdabot> (b -> b1) -> b -> b -> b1
17:30:40 <NemesisD> has anyone used docker with haskell?
17:31:11 <pavonia> :t asTypeIn
17:31:12 <lambdabot> a -> (a -> b) -> a
17:31:55 <pavonia> grpala: ^ These are the three I know of
17:33:07 <grpala> pavonia: thanks a lot, I'll see what I can do with them. It seems all this transformer stuff is finally crystallyzing for me
17:33:23 <grpala> still not working, but I now see why it isn't
17:35:22 <hsyl20> NemesisD: I haven't but some people have (e.g. Michael Snoyman)
17:37:30 <jasonkuhrt> dolio: Thanks
17:37:36 <hsyl20> NemesisD: do you have a specific issue?
17:39:33 <Pamelloes> If I have a type Event t a, can I create a useful version of: newtype AnyEvent t = AnyEvent { event :: forall a. Event t a }
17:40:06 <NemesisD> hsyl20: i'm actually following the guide here https://www.fpcomplete.com/blog/2015/05/haskell-web-server-in-5mb and it references an image "haskell-scratch" which doesn't exist
17:40:37 <kristof> What libraries are people usually using for asynchronous dataflows in Haskell?
17:41:37 <exio4> kristof: async? 
17:41:54 <NemesisD> maybe ill file an issue on it
17:42:02 <exio4> Pamelloes: what'd you consider "an useful version" of that?
17:42:12 <NemesisD> kristof: got an example?
17:42:43 <Pamelloes> exio4: My issue with the current version is, for example, if I have an Event t (), I can't turn it into AnyEvent because a /= ()
17:42:54 <hsyl20> NemesisD: ahah i fixed the issue he encountered yesterday, now you can have static binaries in docker images (https://ghc.haskell.org/trac/ghc/ticket/10298)
17:42:59 <Pamelloes> If I can cast any Event into AnyEvent, I would consider AnyEvent useful
17:43:33 <Pamelloes> Though, the more I think about this, the more I realize this is a really bad idea.
17:44:07 <exio4> Pamelloes: why couldn't you do that?
17:44:10 <kristof> NemesisD: Not a single one. 
17:44:22 <hsyl20> NemesisD: https://github.com/snoyberg/haskell-scratch/ <-- in the makefile it copies the needed files (before my patch)
17:44:22 <Pamelloes> exio4: ghc won't let me
17:44:43 <NemesisD> hsyl20: so when/how does that patch become available mainstream
17:45:36 <NemesisD> kristof: i mean of what type of thing your asking for. i don't know what an async dataflow is
17:46:11 <hsyl20> NemesisD: hopefully in the coming week, the bug is the highest in the priority list for the 7.10.2 release
17:46:19 <phaazon> hey
17:46:21 <Pamelloes> I guess I should expand my question: Is there a way to create a map between (MyKey a) and (MyValue a) such that each key/value pair can have a different value for a?
17:46:27 <phaazon> I don‚Äôt understand how to use mfix with Maybe
17:46:35 <phaazon> > mfix (const Nothing)
17:46:36 <NemesisD> hsyl20: ah, i wonder why snoyberg didn't publish that haskell-scratch image to hub
17:46:37 <lambdabot>  Nothing
17:47:00 <phaazon> > mfix (\a -> guard (a < 10) >> pure (succ a))
17:47:02 <lambdabot>      No instance for (Show (m0 a0))
17:47:02 <lambdabot>        arising from a use of ‚Äòshow_M77366638826050799809960‚Äô
17:47:02 <lambdabot>      The type variables ‚Äòm0‚Äô, ‚Äòa0‚Äô are ambiguous
17:47:19 <phaazon> > mfix (\a -> guard (a < 10) >> Just (succ a))
17:47:22 <lambdabot>  mueval-core: Time limit exceeded
17:47:33 <phaazon> I guess that provides a 
17:47:46 <phaazon> Just (succ (succ (succ (succ‚Ä¶
17:48:34 <kristof> NemesisD: I've done a lot of research on the tools people use to accomplish asynchronous workflows in other languages. Actors, CSP, and futures, callbacks (which are not a solution), all of those things are attempts to tackle concurrency. What all of those have in common is the notion of "go do this, it might take a long time, I might care about the result".
17:49:54 <exio4> phaazon: I don't really know any way for encoding that requirement with a Map
17:50:00 <exio4> er, Pamelloes 
17:50:04 <exio4> sorry phaazon :P 
17:50:22 <kristof> NemesisD: Okay, concrete question. I'm getting a JSON object from a web service. Do I use a future? CSP?
17:50:27 <phaazon> :(
17:50:39 <phaazon> > take 3 . mfix $ \a -> [a*2]
17:50:43 <lambdabot>  mueval-core: Time limit exceeded
17:50:48 <phaazon> that mfix is way too magic to me
17:51:16 <NemesisD> kristof: a good starting point for that sort of thing is the "async" library
17:51:20 <phaazon> > take 3 . mfix $ (:)
17:51:21 <lambdabot>      Couldn't match type ‚Äò[a] -> [a]‚Äô with ‚Äò[a]‚Äô
17:51:21 <lambdabot>      Expected type: a -> [a]
17:51:21 <lambdabot>        Actual type: a -> [a] -> [a]
17:51:24 <Pamelloes> exio4: Yeah.... I vaguely remember there being a way to have a list of different typed values. That might be related. Do you know what I'm talking about?
17:51:33 <NemesisD> its more or less analogous to promises
17:51:36 <phaazon> > take 3 . mfix $ (:[1,2,3])
17:51:40 <lambdabot>  mueval-core: Time limit exceeded
17:51:47 <NemesisD> there's also pipes-concurrency
17:51:51 <lpaste> Exio4 pasted ‚Äúexistential types ‚Äù at http://lpaste.net/132823
17:52:07 <kristof> NemesisD: I was thinking about pipes, too. That reminds me more of csp.
17:52:16 <phaazon> @let useless :: (Monad m) => (a -> m a) -> m a; useless = mfix
17:52:17 <lambdabot>  .L.hs:147:11:
17:52:17 <lambdabot>      Could not deduce (MonadFix m) arising from a use of ‚Äòmfix‚Äô
17:52:17 <lambdabot>      from the context (Monad m)
17:52:19 <exio4> Pamelloes: yes, the paste there basically does what you wanted first
17:52:22 <ion> kristof: You might also find FRP interesting. Here‚Äôs a recent video i liked. https://youtu.be/dOy7zIk3IUI
17:52:28 <kristof> NemesisD: Are there other opinions about how to structure this kind of thing?
17:52:33 <phaazon> @let useless :: (MonadFix m) => (a -> m a) -> m a; useless = mfix
17:52:35 <lambdabot>  Defined.
17:52:36 <phaazon> :‚Äì‚Äô
17:53:13 <phaazon> > take 3 . fix $ \a -> 1:a
17:53:15 <lambdabot>  [1,1,1]
17:53:26 <Pamelloes> exio4: Alright, that looks interesting.
17:53:26 <NemesisD> kristof: i know there's CSP stuff, there's also cloud haskell for erlang style actor concurrency. i've run across many actor libraries of varying degrees of complexity on hackage but haven't used them
17:53:26 <kristof> ion: "Instead of writing event loops or callbacks, programmers compose interactive applications". Sounds fascinating.
17:53:33 <phaazon> > take 3 . mfix $ \a -> 1:a
17:53:35 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ [a]
17:53:35 <lambdabot>      Relevant bindings include a :: a (bound at <interactive>:1:18)
17:53:35 <lambdabot>      In the second argument of ‚Äò(:)‚Äô, namely ‚Äòa‚Äô
17:53:35 <NemesisD> kristof: also haxl is a good one to look at too
17:53:55 <phaazon> > take 3 . mfix $ \a -> a:[1]
17:53:59 <lambdabot>  mueval-core: Time limit exceeded
17:54:01 <phaazon> dammit, I don‚Äôt get how to use that thing :D
17:58:08 * hackagebot docopt 0.7.0.2 - A command-line interface parser that will make you smile  http://hackage.haskell.org/package/docopt-0.7.0.2 (ryanartecona)
17:59:36 <kristof> NemesisD: I once read a pretty severe polemic against Actors because of the type of the function, and the lack of composability. And it didn't really bother me back then but it sort of does now. Little programs should be composed to big programs! There's no good way to compose actors.
18:01:11 <pacak> > take 3 =<<  mfix (\v -> return $ [1] ++ v)
18:01:13 <lambdabot>  [1,1,1]
18:02:10 <phaazon> pacak: you‚Äôre using the ((->) r) instance
18:02:24 <phaazon> ah no
18:02:29 <phaazon> you‚Äôre using the [] instance
18:02:57 <phaazon> MonadFix and ArrowLoop are like deeply magical to me
18:03:09 * hackagebot jmacro 0.6.12 - QuasiQuotation library for programmatic generation of Javascript code.  http://hackage.haskell.org/package/jmacro-0.6.12 (GershomBazerman)
18:04:13 <phaazon> hey no
18:04:18 <phaazon> that‚Äôs not the [] instance
18:04:48 <ion> > take 3 =<< mfix (\v -> [[1] ++ v])
18:04:49 <lambdabot>  [1,1,1]
18:05:12 <pacak> > mfix (const $ Just 1)
18:05:13 <lambdabot>  Just 1
18:05:42 <pacak> > mfix (const $ return 1) :: Maybe Int
18:05:43 <lambdabot>  Just 1
18:05:49 <ion> > mfix (\v -> [[0], [1..5] ++ v])
18:05:51 <lambdabot>  [[0],[1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,...
18:06:51 <pavonia> How does that work?
18:06:57 <phaazon> no damned idea
18:07:12 <phaazon> > mfix []
18:07:14 <lambdabot>      Couldn't match expected type ‚Äòa -> m a‚Äô with actual type ‚Äò[t0]‚Äô
18:07:14 <lambdabot>      In the first argument of ‚Äòmfix‚Äô, namely ‚Äò[]‚Äô
18:07:14 <lambdabot>      In the expression: mfix []
18:07:19 <phaazon> > mfix (const [])
18:07:21 <lambdabot>  []
18:07:21 <Cale> instance MonadFix [] where
18:07:21 <Cale>     mfix f = case fix (f . head) of
18:07:22 <Cale>                []    -> []
18:07:22 <Cale>                (x:_) -> x : mfix (tail . f)
18:07:39 <ion> > map (take 10) (mfix (\v -> ["foo" ++ v, "bar" ++ v]))
18:07:41 <lambdabot>  ["foofoofoof","barbarbarb"]
18:09:01 <phaazon> > mfix (\a -> Just (1:a)) >>= take 3
18:09:03 <lambdabot>      Couldn't match type ‚Äò[]‚Äô with ‚ÄòMaybe‚Äô
18:09:03 <lambdabot>      Expected type: [b] -> Maybe b
18:09:03 <lambdabot>        Actual type: [b] -> [b]
18:09:13 <phaazon> > fmap (take 3) $ mfix (\a -> Just (1:a))
18:09:15 <lambdabot>  Just [1,1,1]
18:09:18 <phaazon> hm
18:09:19 <phaazon> ok
18:10:04 <phaazon> > fmap (take 3) $ mfix (\a -> Just (1:map succ a))
18:10:06 <lambdabot>  Just [1,2,3]
18:11:42 <ion> > mdo { v <- ["foo" ++ v, "bar" ++ v]; pure (take 20 v) }
18:11:44 <lambdabot>  <hint>:1:9:
18:11:44 <lambdabot>      parse error on input ‚Äò<-‚Äô
18:11:44 <lambdabot>      Perhaps this statement should be within a 'do' block?
18:11:52 <Cale> mfix/RecursiveDo are really fun/essential in conjunction with some FRP systems.
18:12:04 <phaazon> yeah
18:12:14 <phaazon> that‚Äôs why I‚Äôm trying to figure them out
18:13:05 <phaazon> > fmap (take 3) .  mfix $ \a -> pure $ 1:a
18:13:07 <lambdabot>      No instance for (Show (f0 [a0]))
18:13:07 <lambdabot>        arising from a use of ‚Äòshow_M701006035134783407110637‚Äô
18:13:07 <lambdabot>      The type variables ‚Äòf0‚Äô, ‚Äòa0‚Äô are ambiguous
18:13:09 * hackagebot test-sandbox 0.1.5 - Sandbox for system tests  http://hackage.haskell.org/package/test-sandbox-0.1.5 (junjihashimoto)
18:13:28 <pacak> > take 10 =<< mfix (\v -> [0..3] >>= \i -> return . scanl (+) i . (1:) $ v)
18:13:29 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,1,2,3,5,8,13,21,34,55,89,2,3,5,8,13,21,34,55,89,144,...
18:13:54 <phaazon> fibbo?
18:13:55 <phaazon> ahah
18:14:11 <ion> The behavior of the mfix list instance is like:
18:14:12 <ion> > let f v = ["foo" ++ take 3 v, "bar" ++ take 6 v, "baz" ++ take 9 v] in [fix (f . (!! 0)) !! 0, fix (f . (!! 1)) !! 1, fix (f . (!! 2)) !! 2]
18:14:14 <lambdabot>  ["foofoo","barbarbar","bazbazbazbaz"]
18:14:58 <phaazon> holy shit
18:15:01 <phaazon> 3:15 AM
18:15:04 <phaazon> I have to work tomorrow
18:15:06 <phaazon> see you later
18:15:08 <ion> 4:14
18:15:11 <phaazon> thanks for the mfix stuff :)
18:15:20 <pacak> (09:14:39) phaazon: 3:15 AM
18:15:22 <phaazon> night
18:15:31 <phaazon> pacak: :)
18:18:54 <Big_G> Is there a development enviornment (IDE mainly) that is considered to be the best for Haskell?
18:21:02 <rasen_> Big_G: vim is great
18:21:17 <Cale> Big_G: People have put some things together, but for the most part I find just using a text editor alongside GHCi (type :r in ghci to reload and test whenever I make a new definition) works pretty well.
18:21:21 <ion> I‚Äôm under the impression that Haskell support for Emacs is way better. (I should learn Emacs one day.)
18:21:27 <ElMoloko> Vim or emacs
18:21:45 <Big_G> I use vim but it is nowhere near what something like Netbeans is for Java
18:21:45 <Cale> Really any text editor which is capable of converting tabs to spaces should be fine.
18:21:49 <ElMoloko> i've heard that people that like IDEs like Leksah
18:22:40 <Cale> There's FP Complete's web application IDE thing
18:23:00 <Big_G> This is for company code so that wouldn't work Cale 
18:23:01 <Cale> I've never tried it
18:30:48 <ion> I‚Äôm looking forward to someone building something cool with ide-backend.
18:31:12 <ion> Specifically, something cool that runs locally
18:32:14 <rasen_> I'd like to have vim integration ^^
18:32:40 <rasen_> But I'm too lazy/buzy to do it myself(
18:34:49 <Lokathor> I use emacs with TRAMP, works well
18:34:55 <ion> I have been meaning to try <https://github.com/syl20bnr/spacemacs> (a customized Emacs+Evil distribution), it has some Haskell stuff too. https://github.com/syl20bnr/spacemacs/tree/master/contrib/lang/haskell
18:48:45 <geekosaur> a discussion earlier had me wondering how much of a ghci alternative could be done with it
19:02:30 <Big_G> Are there any libraries in particular that every project needs? STuff like quickcheck
19:02:54 <pacak> base?
19:03:10 * hackagebot keys 3.10.2 - Keyed functors and containers  http://hackage.haskell.org/package/keys-3.10.2 (EdwardKmett)
19:04:39 <Myrl-chan> I have 2 haskell files, how would I fork to the other one without linking it at... well, link-time.
19:05:18 <Myrl-chan> And of course, no very ugly h4x pls. :|
19:05:50 <exio4> "fork" to the other?
19:06:05 <Myrl-chan> exio4: More or less.
19:06:10 <Myrl-chan> exio4: I'm trying to make a haskell website.
19:06:13 <exio4> what'd fork mean in this context?
19:06:18 <Myrl-chan> From scratch just to add to the insanity.
19:06:25 <pacak> Myrl-chan: Copy'n'paste before compiling.
19:06:39 <Myrl-chan> pacak: I mean not compile-time either.
19:06:48 <Cale> Myrl-chan: I don't understand what "fork to" means
19:06:49 <geekosaur> you're going to have to exoplain what you mean by "fork"
19:06:53 <Myrl-chan> This would be easy with a dynamic language, but eval'ing is kind of an ugly hack.
19:07:11 <geekosaur> you want dynamic loading?
19:07:13 <Cale> Myrl-chan: Maybe you're looking for something like hint?
19:07:21 <Cale> (which is a wrapper for the GHC API)
19:07:27 <Myrl-chan> geekosaur: Mhm.
19:07:34 <geekosaur> but we are all guessing wildly because you still have not explained yourself
19:07:40 <Myrl-chan> Okay.
19:07:44 <Myrl-chan> Here's how it goes.
19:08:08 <geekosaur> "fork" to me means "start a subprocess", or possibly "start a thread" the way ghc's thread API works
19:08:17 <Cale> http://hackage.haskell.org/package/hint -- this sounds like an interpreter, but if compiled .o and .hi files are present, it will load those.
19:08:35 <Myrl-chan> Connects to website -> Server code loads file.hs(or the executable itself.) -> forks or evals it, with the stdout set to the socket.
19:09:48 <geekosaur> oh, so you do mean OS fork, from the sound of it. System.Process.createProcess
19:09:59 <Myrl-chan> geekosaur: Any forking is fine, as long as it's possible.
19:10:03 <Cale> Myrl-chan: You'd be better off just using the stuff in System.Process if all you want is to capture the stdout and redirect it, I think.
19:10:15 <pacak>  Myrl-chan: Have a look at lambdabot?
19:10:23 <Cale> Myrl-chan: "forking" means a few things, but I don't think it means what you seem to be using it to mean
19:10:34 <geekosaur> although the API is somewhat complex (and the low level details you'd use instead are hairier; ghc's POSIX API does not try to hide the details, or pretend to be a shell like e.g. Perl does)
19:10:57 <geekosaur> Cale: inetd forking a daemon on connect
19:11:10 <Cale> Myrl-chan: fork in unix is a way to create a child process by duplicating the process which calls it.
19:11:32 <Myrl-chan> Cale: I have a forever loop, which is the one that `accepts` connections. The child forks to file.hs, while the not-child(what's the correct term?) looks back, being ready to accept a new connection.
19:11:46 <geekosaur> with the daemon hooked to the accept()ed socket from inetd as its stdin and stdout
19:12:17 <geekosaur> in fact, maybe you just want to write that child daemon and use inetd or system equivalent for the parent?
19:12:23 <Big_G> Is Persisten the defacto ORM to use for any DBMS>
19:12:43 <geekosaur> (xinitd, a systemd unit listening on network, launchd inetdCompatibility, etc.)
19:12:44 <Myrl-chan> geekosaur: I'm doing this for learning purposes.
19:12:50 <geekosaur> er xinetd
19:13:11 * hackagebot network-data 0.5.3 - Library for network data structures and their serialization.  http://hackage.haskell.org/package/network-data-0.5.3 (ThomasDuBuisson)
19:14:30 <geekosaur> so, what you want is createProcess, with the handle from accept() being UseHandle for std_in and std_out
19:14:44 <geekosaur> and possibly std_err but often that is sent to a logfile instead
19:15:40 <Cale> Big_G: There are a bunch of other options as well.
19:15:59 <Big_G> Is there one that typically stands out?
19:16:06 <Cale> Big_G: If you're using Yesod, then Persistent is meant for that
19:16:15 <Myrl-chan> The process is piping if I want to connect stdout to tsocket, right?
19:16:17 <Cale> (but of course it can be used on its own)
19:16:23 <Big_G> I'll be using wai but most likely not yesod
19:16:24 <geekosaur> no
19:16:44 <geekosaur> pipe means your parent process has a direct pipe to its stdin/out, independent of any other Handles
19:17:11 <geekosaur> in this case you want to take the Handle from Network.Socket.accept (or whatever) and UseHandle it as std_in and std_out
19:17:26 <geekosaur> unless you want your parent procerss to have to ferry data between the socket and the pipe instead of listening for more connections
19:17:38 <Myrl-chan> Hmmmm...
19:18:13 <geekosaur> so yuou UseHandle, annd immediately after the createProcess your parent closes the socket because it's open and used by the child and the parent no longer needs to care about that socket
19:18:26 <Myrl-chan> Oh yeah. I forgot about that part. Lol.
19:18:30 <geekosaur> it can just go back to accept-ing on the listen socket
19:18:37 <Cale> Big_G: There's groundhog, HDBC, hsql, haskelldb, all of which support multiple database backends. There's also acid-state, which gives you many of the guarantees that a traditional database would while storing plain Haskell data structures.
19:18:48 * Myrl-chan forgot that forking would mean retaining the state of the parent.
19:19:01 <Big_G> Do they support Mongo and mysql?
19:20:10 <Cale> I don't think most of them support Mongo. Mysql and postgresql definitely.
19:21:06 <Myrl-chan> geekosaur: Can you show me the UseHandle part? I don't quite understand that.
19:21:09 <geekosaur> a book covering POSIX process API might help here, since the API pretty much follows that. (also none of this will work on Windows because a socket isn't actually a system file descriptor; I do not offhand know how you do this on Windows but starting a separate process for the child is *very* not-Windows-think)
19:21:51 <geekosaur> createProcess (proc "myChild" [arg list here]) { std_in = UseHandle theSocket, std_out = UseHandle theSocket }
19:22:08 <Myrl-chan> Oh, yeah.
19:22:16 <Myrl-chan> I derped there. :D
19:22:35 <Myrl-chan> I didn't read the type signature of createProcess too well.
19:23:37 <Myrl-chan> geekosaur: Seems nice. Thanks.
19:24:42 <geekosaur> if you expect a lot of concurrent connections you may need to watch out for the system's per-user process limit; see System.Posix.Signal and the somewhat magical SIGCHLD stuff
19:25:35 <Myrl-chan> geekosaur: I'll just leave that as something for later.
19:26:00 <geekosaur> (and watch out for the BSDish gotcha NOCHLDSTOP)
19:26:11 <geekosaur> er NOCLDSTOP
19:26:18 <geekosaur> mm, wrong one actually
19:26:56 <geekosaur> sigh, right, it doesn't expose that part. care needed on freebsd and os x...
19:28:22 <geekosaur> I probably need to write that up, xmonad runs into it...
19:28:55 <guest8282> question: I've completed my cabal-based project but would like to include documentation in a README.md (ie. not about the library/executable using haddock). Ideally this README.md would be processed with something like pandoc and transformed into HTML ... is there a way to specify this processing as part of my cabal file?
19:29:34 <dcoutts> guest8282: it's standard practice to just list the README.md in the extra-source-files, so it gets included in the src tarball
19:29:56 <geekosaur> the few things that I've seen that do suchg processing use a custom Setup.hs
19:30:00 <dcoutts> guest8282: hackage is about to start serving the README if it's included
19:30:00 <geekosaur> but that is pain
19:31:00 <pavonia> dcoutts: Even in Markdown format?
19:31:06 <dcoutts> yes
19:31:43 <guest8282> dcoutts: thanks for the reply and info; good to know that the READMEs will be served on hackage going forward.
19:32:49 <guest8282> geekosaur: is that the only way you've seen this trying of processing preformed? via custom Setup.hs? Reason I ask all of this in the first place is because I'm tring to write documentation for a very non-technical end-user.
19:34:00 <guest8282> I'm confident that they can get the haskell plaform installed and run cabal {configure,build} but would really like to be able to produce a more "friendly" set of documentation from those steps.
19:34:32 <ReinH> guest8282: I would recommend writing that documentation separately from the haddocks and README, which are generally developer-focused
19:35:08 <ReinH> developers want API docks, non-technical users want different information, it's hard to put them together
19:35:14 <ReinH> *docs
19:35:20 <geekosaur> cabal is not designed for that kind of thing, unfortunately; it's more of a developer tool and the only provision it has for documentation is producing haddocks (API documentation, think doxygen / ri / javadoc)
19:37:28 <guest8282> @ReinH @geekosaur @dcoutts: thank you everyone, I appreciate all of your replies. I was affraid this would be the case--that my end-user docs should be separate--but its good to have confirmation of such. 
19:37:28 <lambdabot> Unknown command, try @list
19:37:59 <guest8282> thanks again for the information - I'll proceed by separating the dev docs from those for the end-users.
19:38:45 <tmtwd> map' f xs = foldl (\acc x -> acc ++ [f x]) [] xs
19:39:05 <tmtwd> for this function is [] being passed in as acc, and xs is being passed in as x?
19:39:13 <tmtwd> as args to foldl?
19:40:15 <geekosaur> [] is the initial value (miscalled "acc") and it sets x to each element of xs in turn
19:41:01 <geekosaur> in the lambda, and produces the final value from the invocation of the lambda
19:43:49 <ion> A nice intro to FRP: https://youtu.be/_BICQhz6tkM
19:49:05 <_m_ryan> hi can anyone help me about? Caching in yesod?
19:50:55 <ReinH> tmtwd: fyi that map' is inefficient
19:51:57 <ReinH> :t foldl
19:51:59 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
19:52:20 <tmtwd> oh yeah, it is inefficient
19:52:22 <ReinH> :t Data.List.foldl
19:52:24 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
19:52:27 <ReinH> sigh
19:52:55 <ReinH> anyway the lambda takes the list element as its second argument
19:53:01 <ReinH> as you can see from the types
19:53:09 <tmtwd> right
19:53:37 <tmtwd> so (\ 1starg 2ndarg -> ...) ab cd
19:53:54 <tmtwd> ab is passed as the 1st arg and cd is passed as the second arg
19:53:57 <tmtwd> ?
19:54:19 <ReinH> (b -> a -> b) -> b -> [a] -> b
19:54:51 <ReinH> > foldl (+) x [y,z]
19:54:54 <lambdabot>  x + y + z
19:55:17 <ReinH> f takes the accumulator and the next list element
19:55:21 <Axman6> _m_ryan: what do you need to know? (it's best to just ask your question instead of asking if you can)
19:55:47 <ReinH> the accumulator starts as the value of type b given to foldl and then takes on the result of the previous application of f
19:56:00 <Denommus> @src foldr
19:56:00 <lambdabot> foldr f z []     = z
19:56:00 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
19:56:17 <Axman6> > foldl f z [a,b,c]
19:56:19 <lambdabot>  f (f (f z a) b) c
19:56:26 <Denommus> @src foldl
19:56:26 <lambdabot> foldl f z []     = z
19:56:26 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
19:56:30 <Axman6> > foldr f z [a,b,c]
19:56:33 <lambdabot>  f a (f b (f c z))
19:57:42 <hiptobecubic> Is there some way I can get a job playing lambdabot golf?
19:57:45 <ReinH> foldl (+) x [y,z] ==> foldl (+) (x + y) [z] ==> foldl (+) (x + y + z) [] ==> x + y + z
19:58:21 <_m_ryan> Axman6: i would like a start up tutorial in Caching. or rather if it is possible to Cache a data on yesod?
19:59:09 <ReinH> _m_ryan: if no one here has an answer, you might also try #yesod, but I think it's not very busy there
19:59:14 <Axman6> if you mean caching responses, i would use a dedicated caching proxy like varnish
19:59:29 <Axman6> keep the app simple and use the right tool for the job
19:59:33 <ReinH>  varnish is good sauce
20:00:03 <Axman6> then you only need to worry about setting the right headers to control how the caching proxy does its cachine
20:00:19 <_m_ryan> can you give me the link for that?
20:00:27 <ReinH> @google varnish cache
20:00:29 <lambdabot> https://www.varnish-cache.org/
20:00:43 <Axman6> (I think there are WAI middlewares which can do caching, but they'll never be as good as Varnish or something else dedicated to doing cachine and routing)
20:01:02 <ReinH> varnish can also replace nginx as a reverse proxy
20:01:08 <ReinH> it's a nice piece of kit
20:01:20 <Axman6> yeah. nginx is another alternative
20:01:32 <ReinH> Axman6: nginx isn't really a cache though
20:01:44 <ReinH> I was just saying you don't need both nginx AND varnish
20:01:49 <Axman6> right
20:02:43 <ReinH> at pred (pred job) we started wtih nginx => varnish => app servers and realized nginx was totally unnecessary
20:02:49 <ReinH> removing it saved us money and improved reliability
20:03:04 <Axman6> nice =)
20:07:25 <_m_ryan> thanks i will check this :)
20:08:12 * hackagebot editor-open 0.5.0.0 - Open the user's $EDITOR for text input.  http://hackage.haskell.org/package/editor-open-0.5.0.0 (pharpend)
20:16:26 <unknownloner> How would I get a directories contents, but only files, not directories
20:17:03 <unknownloner> trying to find the function that tells whether a FilePath is a file or not
20:20:18 <enthropy> filterM doesFileExist -- might help
20:22:38 <dmj`> \path -> filter (\x -> x `notElem` [".", ".."]]) <$> getDirectoryContents path
20:31:04 <joneshf-laptop> I think unknownloner is looking for something like, `find . -maxdepth 1 -type f`
20:32:10 <geekosaur> does sound like it, yes
20:32:29 <geekosaur> and sadly that is moderately annoying
20:32:52 <joneshf-laptop> i think enthropy 's suggestion works
20:32:56 <geekosaur> (also in C, which is where following POSIX closely is something of a lose)
20:33:13 * hackagebot exceptional 0.1.4.3 - Essentially the Maybe type with error messages.  http://hackage.haskell.org/package/exceptional-0.1.4.3 (pharpend)
20:33:15 * hackagebot test-framework-th-prime 0.0.8 - Template Haskell for test framework  http://hackage.haskell.org/package/test-framework-th-prime-0.0.8 (KazuYamamoto)
20:33:21 <joneshf-laptop> getDirectoryContents >=> filterM doesFileExist
20:51:33 <_m_ryan> Axman6: still ther i have some question. i would like to cache a JSON data and after 5mins update that JSON data. does varnish do that?
21:18:53 <kristof> Hey, something I've heard very frequently is that when you need to refer to previous context, you should use an applicative functor and not a monad, but this isn't entirely obvious to me and I was wondering if someone could elaborate
21:19:30 <kristof> For instance, a writer monad passes "previous context" all the way down
21:20:36 <calvinx> what‚Äôs the simplest way to print out a constant? `print const 7` won‚Äôt work of course.
21:21:07 <kristof> calvinx: Why don't you just print 7?
21:21:39 <calvinx> because it‚Äôs an assigned constant somewhere in the program. e.g. specialconstant = const 7
21:22:08 <bitemyapp> kristof: I think you've got it backwards
21:22:34 <kristof> bitemyapp: Wow, haven't seen that nick in a long time
21:22:39 <bitemyapp> kristof: and even when you fix that, you're confusing the semantic differences between abstract interfaces (applicative and monad) with a concrete instance (Writer)
21:22:54 <bitemyapp> kristof: let me provide some intuition to help you with this
21:23:01 <bitemyapp> @ty (<*>)
21:23:03 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
21:23:04 <exio4> calvinx: "specialConstant = 7" is what you want, unless I am missing something
21:23:06 <bitemyapp> @ty join
21:23:07 <lambdabot> Monad m => m (m a) -> m a
21:23:16 <bitemyapp> kristof: I've been busy. Book is coming out soon. Talking at Lambda Conf next weekend.
21:23:42 <kristof> bitemyapp: I am going to be in Boulder about a month too late to see that.
21:23:48 <bitemyapp> kristof: sorry to hear it
21:24:00 <bitemyapp> kristof: have you messed with the Parser datatype yet? Parser combinators?
21:24:19 <calvinx> exio4 it‚Äôs not a constant I specify. so I am just trying to print it out.
21:24:29 <kristof> bitemyapp: nah
21:24:30 <bitemyapp> kristof: do you know the chomsky hierarchy?
21:24:35 <kristof> bitemyapp: yes
21:24:38 <exio4> calvinx: everything is constant, what kind of "constant" are we talking about?
21:24:40 <bitemyapp> kristof: k, this should help them
21:24:42 <bitemyapp> then*
21:24:55 <arbelos> Is anyone here using FPCompletes IDE?
21:24:59 <bitemyapp> kristof: consider that you can express a CFG in Applicative, but not a context sensitive grammar (there is an exception/cheat, ignore it)
21:25:11 <calvinx> right.
21:25:11 <kristof> bitemyapp: So I really did have it backwards :P
21:25:14 <bitemyapp> kristof: whereas, you can express a context sensitive grammar in Monad for a parser combinator library.
21:25:19 <bitemyapp> kristof: aye, 'fraid you did.
21:25:27 <kristof> bitemyapp: I don't know how I confused it, then
21:25:30 <bitemyapp> kristof: monad is stronger than applicative, applicative is stronger than functor.
21:25:41 <bitemyapp> kristof: I dunno. Don't sweat it. Just focus on refining understanding :)
21:25:57 <bitemyapp> kristof: stronger here is a continuum where, "can do more stuff, but fewer instances exist"
21:26:06 <bitemyapp> that is, fewer datatypes will have a valid instance.
21:26:24 <exio4> calvinx: "const X" is a function, which you can't print
21:26:34 <bitemyapp> kristof: one way to develop an appreciation for the difference is to play with List or Maybe
21:26:39 <exio4> calvinx: do you have any example code showing what you want?
21:26:51 <calvinx> Yes. That‚Äôs the problem. const X is a function. I did not realize that.
21:27:01 <bitemyapp> kristof: see what you can express with Monad that you cannot with Applicative (change your answer depending on what happened with previous values)
21:27:04 <exio4> what are you using const X for?
21:27:06 <ob_> bitemyapp: thanks for your getting started tutorial
21:27:12 <bitemyapp> kristof: that should you give you an idea of what to kick around
21:27:16 <bitemyapp> ob_: glad it was of service :)
21:28:59 <kristof> bitemyapp: Okay. When you need context, are you in general going to jump straight to a monad?
21:29:24 <exio4> I happen to use code that matches the types I need
21:29:47 <kristof> That's true, but I'm talking about a computational pattern
21:29:59 <jle`> it depends on what you need to do with it
21:30:05 <kristof> bitemyapp: I had no idea you were writing a book. Is it the mythical functional design patterns book that I've been waiting for?
21:30:24 <jle`> if all you need to do is to apply functions to values in the context, then Functor is all you need
21:30:46 <calvinx> exio4: http://lpaste.net/132826  just trying to make sure I understand what‚Äôs happening.
21:30:56 <Welkin> jle`: your blog is on hacker news again
21:31:00 <jle`> why
21:31:02 <jle`> ;_;
21:31:03 <Welkin> haha
21:31:13 <Welkin> "First Class Statements"
21:31:18 <jle`> did someone re-post it
21:31:21 <jle`> uguhghhhghhhhh
21:31:22 <kristof> calvinx: const x _ = x, so yes
21:31:27 <jle`> no wonder someone commented on it earlier
21:31:33 <kristof> calvinx: That is quite literally the definition
21:31:41 <calvinx> cool
21:31:52 <jle`> thanks for the heads-up Welkin 
21:31:55 <kristof> calvinx: So don't use it when you're thinking of the typical C style const
21:32:23 <Welkin> jle`: do you not like the HN crowd, or is it another reason?
21:32:36 <jle`> oh because i'm embarassed cause i feel like there are some flaws that i haven't fixed yet
21:32:50 <Welkin> don't be embarassed
21:32:51 <jle`> or usually when i write something, i have a specific audience in mind
21:33:05 <jle`> and something going onto front page at hacker news means i have to re-write things to adjust to a different audience, heh
21:33:15 <Welkin> ah, well, hn is strange
21:33:26 <calvinx> kristof: right.
21:34:25 <exio4> calvinx: `const` is normally useful whed with other high order functions
21:34:48 <exio4> calvinx: if you're doing const X at the top-level, you're pretty much better just putting X there
21:35:45 <jle`> it's mostly the audience thing.  but this specific post is targeted for non-haskellers so i guess i'm less worried than ifanother one was reposted
21:36:12 <calvinx> exio4: yup.
21:36:24 <calvinx> that makes sense. thanks for the clarification.
21:36:27 <exio4> > zipWith const [1..10] [2..10] 
21:36:29 <lambdabot>  [1,2,3,4,5,6,7,8,9]
21:37:03 <exio4> > (\xs n -> zipWith (const id) xs (drop n xs)) [1..10] 5 
21:37:05 <lambdabot>  [6,7,8,9,10]
21:38:15 * hackagebot graph-wrapper 0.2.4.4 - A wrapper around the standard Data.Graph with a less awkward interface  http://hackage.haskell.org/package/graph-wrapper-0.2.4.4 (SoenkeHahn)
21:39:59 <jle`> true = const
21:40:09 <jle`> false = const id
21:40:53 <_fritz_> Hmh, is there a better way to represent mathematical formulas in Haddock documentation than to use monospaced text? It would be nice to write code, which converts such formulas using MathJaX to nice representations.
21:45:21 <_fritz_> hmh, excellent, there is already a thread on haskell-cafe. nevermind.
21:47:36 <johnw> _fritz_: you could always embed images, there is recent cabal support for that
21:47:53 <arbelos> What should I do if I have a project that I would like to have considered for Hackage
21:48:45 <arbelos> Oh there is a upload package I see now
21:49:18 <IcedCoffeeWaifu> geekosaur: ping
21:50:56 <_fritz_> johnw: hmh, and then calling mathjax in the build process via node to generate accurate svg images, that's acceptable :)
21:52:04 <johnw> if you make nodejs a build dependency, please don't upload that to Hackage ;)
21:53:53 <pharaun> oh gods no nodejs
21:55:01 <_fritz_> rendering formulas. not possible in 2015 without either nodejs or a working tex distribution :p
21:55:01 <arbelos> I need some advice now, I have registered on Hackage and will try to upload my project. But I have to make sure I get the version number right
21:55:37 <arbelos> This is a port of a library that uses their own convention for version numbers
21:55:50 <arbelos> so according to it this should be 1.0.2
21:56:34 <arbelos> so I should use that version number for my package as well, or?
21:58:12 <pharaun> _fritz_: gotta love that
21:58:29 <pharaun> sometime i wake up and i wonder where did we all go so wrong when we can't do something like rendering formulas
21:59:40 <apo_> you can use MS Word
22:00:10 <pharaun> oh, i forgot that was even a thing
22:00:23 <pharaun> >_<
22:00:34 <_fritz_> and (libre|open)office :p
22:00:44 <apo_> that's gotta be nice
22:00:48 <_fritz_> but without anti-aliasing, in 2015
22:00:54 <apo_> I'm sorry I reminded you
22:00:56 <bob_twinkles> and Tex!
22:01:13 <apo_> we already had TeX
22:01:40 <bob_twinkles> oh, I should read more scrollback before commenting... fail
22:01:46 <Maxdamantus> TeX results in too much antialiasing :\
22:02:33 <apo_> TeX has nothing to do with AA
22:02:42 <Maxdamantus> it has to do with the excess.
22:03:25 <apo_> TeX does not render graphics
22:03:27 <Maxdamantus> systems that can take pixels into account can do proper hinting.
22:03:33 <pharaun> yeah i just completely forgot about office :) so used to just using tex/latex
22:03:46 <Maxdamantus> antialiasing is the horrible thing you do to avoid something more horrible.
22:04:33 <apo_> buying a higher DPI display?
22:04:38 <apo_> :D
22:04:42 <pharaun> well at least those are starting to roll out!
22:04:52 <pharaun> yay for apple for finally breaking that stupidity
22:04:52 <Maxdamantus> No. Rounding pixel values.
22:05:28 <Maxdamantus> Optimally, the pixels would already be either full or empty and not a combination. Hinting tries to get it that way as much as possible.
22:08:16 * hackagebot simple-sendfile 0.2.19 - Cross platform library for the sendfile system call  http://hackage.haskell.org/package/simple-sendfile-0.2.19 (KazuYamamoto)
22:09:18 * Maxdamantus wonders if there's some sort of newer-generation vector display.
22:23:17 * hackagebot jmacro-rpc 0.3.2 - JSON-RPC clients and servers using JMacro, and evented client-server Reactive Programming.  http://hackage.haskell.org/package/jmacro-rpc-0.3.2 (GershomBazerman)
22:23:19 * hackagebot filediff 1.0.0.2 - Diffing and patching module  http://hackage.haskell.org/package/filediff-1.0.0.2 (bgwines)
22:32:00 <DreadPirateRober> > ( + )
22:32:03 <lambdabot>  <Integer -> Integer -> Integer>
22:32:32 <enolan> there a bunch of functions like this in Idris' Setup.hs - http://lpaste.net/132827
22:32:55 <enolan> it seems like there should be an easier way, especially since the flag defaults are in the .cabal file already
22:33:13 <DreadPirateRober> enolan, are you talking to me?
22:33:27 <enolan> not unless you have the answer :)
22:33:39 <DreadPirateRober> uh i dont think i do
22:33:45 <DreadPirateRober> > Nothing
22:33:47 <lambdabot>  Nothing
22:33:49 <Welkin> DreadPirateRober: holy shit!
22:34:05 <DreadPirateRober> Welkin god damn!
22:34:18 <DreadPirateRober> so what is Nothing in Haskell?
22:34:22 <Welkin> DreadPirateRober: how is silk road these days?
22:34:37 <DreadPirateRober> is it kinda like Null in Java or None in Ocaml?
22:34:40 <enolan> it's the empty constructor for the Maybe type
22:34:42 <Welkin> data Maybe a = Nothing | Just a
22:34:52 <DreadPirateRober> Welkin, not too good, been shut down a bunch
22:34:59 <DreadPirateRober> just can seem to get it up anymore
22:35:00 <dmj`> DreadPirateRober: more like None in OCaml
22:35:29 <DreadPirateRober> thanks dmj` 
22:35:39 <DreadPirateRober> and enolan 
22:38:56 <begriffs> My code uses -Wall and -Werror and imports Control.Applicative which is great in 7.8 but in 7.10 Control.Applicative is redundant and causes a warning. What's the best way to keep my code compatible with 7.8 while silencing that particular warning?
22:40:26 <enolan> I think people just use CPP for that sort of thing
22:40:39 <DreadPirateRober> should use CCCP
22:41:53 <pacak> begriffs: import Prelude at the end.
22:42:56 <begriffs> So use noimplicitprelude and import it by hand at the end of my list of imports?
22:45:24 <pacak> Try just importing prelude first
22:45:56 <begriffs> pacak: ahh I just discovered this note about what you're suggesting. https://ghc.haskell.org/trac/ghc/wiki/Migration/7.10#GHCsaysTheimportof...isredundant
22:46:47 <pacak> Yep, that.
22:53:06 <_m_ryan> hi this is a yesod topic hope you don't mind - i would like to cache a JSON data and after 5mins update that JSON data.
22:54:00 <jle`> begriffs: have you tried using acme-everything instead of manually installing hackage files to get all-of-hackage dependencies? :)
22:54:03 <dmj`> _m_ryan: why? what is the scenario
22:54:07 <jle`> s/files/packages
22:54:17 <jle`> @hackage acme-everything
22:54:17 <lambdabot> http://hackage.haskell.org/package/acme-everything
22:55:29 <_m_ryan> dmj`: i have a large data in the database that needs to be retrieve, so i don't want to query it all the time so i want to cached it then reload it every 5mins/once there is an update in the data.
22:55:30 <pacak> jle`: I don't think you can install acme-everything.
22:55:36 <begriffs> jle`: well... fancy that!
22:56:52 <dmj`> _m_ryan: redis is great for that, otherwise using an MVar / IORef would suffice
22:57:24 <jle`> pacak: begriffs managed to install literally all of hackage...so it gives me some hope for acme-everything, heh
22:57:25 <dmj`> _m_ryan: I'd recommend redis over keeping application data in the web server's memory
22:57:33 <begriffs> The reddit thread suggested I limit the installs to things referenced in stackage. I'm starting to notice that now that I have installed all the packages it makes cabal go really slowly on the "resolving dependencies" stage.
22:58:09 <_m_ryan> dmj`: does reddit is a pluggin?
22:58:38 <_m_ryan> dmj`: i mean redis?
22:59:00 <dmj`> _m_ryan: http://redis.io, it's a database
22:59:11 <pacak> It will most likely fail to resolve all the dependences - some stuff on hackage haven't been updated for a while and some - requires new versions.
22:59:25 <_m_ryan> dmj`: im using postgres sql for my web app
22:59:26 <jle`> one way to find out :)
22:59:52 <dmj`> _m_ryan: you can use two database for your web app, one for your pristine data, another for your cache
23:00:00 <dmj`> @package hedis
23:00:00 <lambdabot> http://hackage.haskell.org/package/hedis
23:00:49 <jle`> hackage rhymes with package
23:00:54 <jle`> is this a coincidence?
23:00:55 <dmj`> :)
23:01:38 <Myrl-chan> What's the idiomatic way of writing to stderr?
23:01:43 <Myrl-chan> hPutStr stderr?
23:02:12 <_m_ryan> dmj`: what about the MVar and IORef?
23:03:01 <dmj`> _m_ryan: when your webserver process starts you can initialize a record to hold your json data in a global variable (stored in I/O) using an IORef or MVar
23:04:16 <_m_ryan> dmj`: do you have some links for some tutorials about that?
23:04:19 <dmj`> _m_ryan: suppose your web application gets more traffic though, and you need to add an additional web server, well now your cache is stuck inside one web server, inaccessible to the other. Having the cache be external to both web servers allows both to use the cache.
23:05:08 <dmj`> _m_ryan: this is a great book: http://chimera.labs.oreilly.com/books/1230000000929 (and its free)
23:06:38 <dmj`> _m_ryan: you could just create a seperate process I suppose, and access it via tcp, w/o using redis, just haskell.
23:08:37 <_m_ryan> dmj`: maybe that would be alot of work.
23:10:38 <dmj`> _m_ryan: the network library is pretty good at being easy to use, you can just create generic Serialize instances on your datatypes to send over the wire between processes, compile both against the same library to share the types
23:11:12 <dmj`> _m_ryan: the hedis library does everything w/ ByteString :/, so this would be more typesafe
23:12:11 <_m_ryan> dmj`: now i get it. but for my current project i want first to try to cache my data in a very simple way. and try to apply what you recommend. :-)
23:12:25 <_m_ryan> dmj`: can you help me with IORef / MVar?
23:12:58 <kosmikus> Lokathor: not sure if it's helpful for your purposes, but there's a PPFOV implementation in LambdaHack, in https://github.com/LambdaHack/LambdaHack/blob/master/Game/LambdaHack/Server/Fov/Permissive.hs
23:13:19 * hackagebot hashids 1.0.2 -   http://hackage.haskell.org/package/hashids-1.0.2 (arbelos)
23:13:28 <Lokathor> I've seen that before.. I have no idea how it works
23:16:02 <dmj`> _m_ryan: sure
23:16:11 <kosmikus> Lokathor: well, it claims to be an implementation of "the algorithm" using the information from the roguebasin page, without looking at any existing code. so it's not a transcription from C or Java.
23:16:53 <dmj`> _m_ryan: since this is a webserver we should an MVar since it's like an IORef but includes with synchronization primitives (thread blocking / unblocking on operations)
23:16:58 <dmj`> use*
23:17:27 <Lokathor> yes indeed. I believe that it would totally work, but my Haskell isn't nearly good enough to follow along with what it's doing. I expect that having worked with a Java version of said algorithm is also confusing my brain because of expectations
23:18:09 <_m_ryan> dmj`: we will use Mvar?
23:18:31 <_m_ryan> dmj`: http://haddocks.fpcomplete.com/fp/7.8/20140916-162/base/Control-Concurrent-MVar.html
23:22:36 <dmj`> _m_ryan: http://lpaste.net/132835
23:23:30 <dmj`> _m_ryan: this is a simple example of persisting an mvar in an application that runs forever. The MVar holds a Map (balanced binary tree - common hash table implementation) which serves as our cache.
23:24:46 <_m_ryan> dmj`: there is an error " age <- read <$> getLine "  it said that the " <$> "is not is scope?
23:25:07 <dmj`> _m_ryan: MVars live in I/O. the modifyMVar_ command has the main thread grab the mvar (all subsequent will block until the main thread releases the lock). It's an atomic operation though. In this contrived example there is only one thread, but in your web server there will be many threads
23:25:21 <dmj`> _m_ryan: import Control.Applicative
23:25:25 <pacak> :t (<$>)
23:25:27 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:25:28 <pacak> :t (`fmap`)
23:25:29 <lambdabot> parse error on input ‚Äò)‚Äô
23:25:34 <pacak> :t (fmap)
23:25:36 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:25:40 <dmj`> _m_ryan: I'm using ghc 7.10, so I don't need to import it
23:26:29 <dmj`> _m_ryan: does it make sense?
23:26:55 <_m_ryan> dmj`: thank you very much for this?
23:27:10 <_m_ryan> dmj`: i will just play a bit for this. :)
23:27:28 <dmj`> _m_ryan: sounds good, check out that book too, it's really good
23:28:35 <_m_ryan> dmj`: yes - thank you for the help again.  can i ask follow up question?
23:29:03 <dmj`> _m_ryan: sure !
23:29:42 <_m_ryan> dmj`: does MVar can access by diff user? eg. we access the same site? does the Cached data will be the Same? or not?
23:30:09 <Myrl-chan> Writing a website in Haskell's pretty fun... <.<
23:32:15 <dmj`> _m_ryan: Unfortunately the data in the cache (the MVar in your case) will be confiend to a single web server, it cannot be shared by other web servers. If you made the cache a standalone executable and exposed a TCP port for other servers to connect to, then it would be the same data. Otherwise, the data will be different. But yes, the MVar can be accessed by more than one thread, the GHC RTS institutes a fairness policy when threads vy
23:32:16 <dmj`> for resources
23:33:18 <dmj`> _m_ryan: so you could fork ten thousand threads to insert 10k records into the map, and ghc would handle it well
23:33:38 <_m_ryan> dmj`: does it have a limit?
23:34:51 <_m_ryan> dmj`: i mean limit size?
23:35:38 <Cale> _m_ryan: Does what have a limit size?
23:35:44 <dmj`> _m_ryan: Limit of # of threads forks? If that's your question.. When you call 'forkIO' you are using what is called a 'green thread'. This isn't an operating system thread. This is the GHC RTS's implementation of a thread. It's 'virtual'. Thread stacks are evaluated round robin on as many cores as you have available. So the more cores you have, the quicker your threads get evaluated.
23:35:52 <dmj`> s/forks/forked
23:36:17 <dmj`> _m_ryan: if you use the -N flag 
23:36:18 <Cale> The only limit on the number of threads is how much memory you have to store thread state objects.
23:36:47 <Cale> (at least as far as I know)
23:36:54 <_m_ryan> dmj`: got it.
23:38:18 <dmj`> _m_ryan: in terms of how many objects you can store in the cache, that would be probably depend on how much RAM you have. Things would start to slow down for you if you went too high, might offload some to disk.
23:38:21 * hackagebot auto 0.4.2.3 - Denotative, locally stateful programming DSL & platform  http://hackage.haskell.org/package/auto-0.4.2.3 (jle)
23:38:23 * hackagebot filediff 1.0.0.3 - Diffing and patching module  http://hackage.haskell.org/package/filediff-1.0.0.3 (bgwines)
23:38:34 <Cale> I think each thread takes around 1 kilobyte (which is mostly the initial amount of stack space allocated by it)
23:39:06 <_m_ryan> dmj`: it not quite a lot of data :-), another follow how to update a value on the cached data?
23:40:23 <_m_ryan> Cale: thanks for the info, :)
23:40:41 <johnw> why is >> infixl and not infixr?
23:40:44 <dmj`> _m_ryan: Cale is the man, remember this
23:41:05 <Cale> johnw: Good question. I have no idea
23:41:08 <_m_ryan> dmj`: got :)
23:41:23 <_m_ryan> dmj`: i mean got it :)
23:41:40 <Cale> johnw: That's really weird actually.
23:42:00 <jle`> maybe to match with (>>=) ?
23:42:09 <johnw> also, =<< and >>= have different association bias
23:42:16 <arbelos> the docs are not showing up on the package I uploaded to Hackage. Do I have to add something to the .cabal file for them to be built automatically?
23:42:34 <johnw> but that I can see
23:42:35 <jle`> arbelos: usually they take some time for the build script to run
23:42:35 <Cale> Well, it makes sense for =<< and >>= to have opposite associativity
23:42:59 <dmj`> _m_ryan: the cache will get updated only when a user is retrieving data (you could insert new people on POST, but then you'd be making the assumption that all new users will be frequently retrieved, and we can't make that assumption). So whenever you have a GET request to postgres, lookup in the cache, if exists, don't hit postgres, o/w hit postgres, then before you send the data down as json, fork a new thread to insert the user into
23:42:59 <dmj`> the cache.
23:43:00 <arbelos> jle` ah. ok. I'll give it some time then. 
23:43:02 <jle`> i think maybe (>>) matching with (>>=) makes sense
23:43:06 <Cale> yeah
23:43:11 <jle`> arbelos: you can check the build status too, on the package page
23:43:13 <Cale> That must be why, even though it's bad.
23:43:25 <arbelos> jle` It says no reports yet
23:43:39 <jle`> arbelos: yeah, that's normal.  if it says "failed" then you might have problems
23:44:03 <jle`> actually i have a package that i uploaded on tuesday that hasn't built yet, i wonder if something's going on
23:44:08 <arbelos> jle` ok thanks. i'll wait a bit.. very exciting. my first package on Hackage
23:44:17 <jle`> congrats arbelos :)
23:44:48 <jle`> arbelos: btw, you can also manually upload your own built documentation if you want
23:45:11 <arbelos> hmm. ok the docs looks fine offline at least, so maybe I can do that if nothing happens on the server
23:45:30 <arbelos> but in the name of automation
23:45:33 <_m_ryan> dmj`: yes clear as water, but what if a had a Cached data that doesn't pull on the DB. e.g  CounterVar -> a varaible for a counting. . 
23:47:39 <dmj`> _m_ryan: that's fine too, in that case I would fork a thread to modify that counter, so the thread that is receiving the request doesn't block on it (you could have a lot of people visiting your site, you don't want anyone waiting on a lock)
23:48:34 <_m_ryan> dmj`: so you mean diff process? for updating?
23:48:37 <dmj`> _m_ryan: or... you could have a Chan, and send a message to the channel to increment the counter. This would be cleaner probably.
23:49:11 <dmj`> _m_ryan: that's a similar pattern to the logging pattern Marlow describes in his book
23:49:58 <dmj`> _m_ryan: same process, just fork a new thread in the web handler code block to increment the global variable, you'll probably store it in a ReaderT along w/ the connection pool info
23:50:47 <elben> I use vim with :GhcModType. But if your expression is of the wrong type (i.e. compiler error), GhcModType will show you the *expected* type. Sometimes I want the *actual* type of an expression. Is there a way to do this, other than looking at the compiler error?
23:50:51 <ij> If I'm using a cabal sandbox, is nothing that's already compiled used?
23:51:34 <dmj`> elben: ghci tells you the expected and actual ootb
23:51:38 <_m_ryan> dmj`: what do you mean by that?
23:51:55 <Lokathor> ij, your version of "base" from the compiler install is used
23:52:12 <Lokathor> so you still get Prelude and Data.List and stuff
23:52:27 <ij> Nothing else though?
23:52:38 <Lokathor> nothing else unless you install it to the sandbox, correct
23:52:45 <Lokathor> usually you do that via a project.cabal file
23:53:29 <ij> Ok.
23:54:41 <ij> I've heard that cabal's not actually a pkg manager, so I conclude it sometimes isn't optimal? What would be better if one were to use a package manager?
23:55:14 <dmj`> _m_ryan: I'll show u some code
23:55:30 <_m_ryan> dmj`: cool thanks.
23:57:08 <johnw> ij: I'd suggest looking at Nix, if you're up for another learning curve
23:58:25 <ij> johnw, That was on my mind, I was wondering what works better with it though.
23:58:41 <johnw> I really like Nix with Haskell, personally
