00:00:09 <enthropy> it's extra work and both options don't seem to be worth the effort
00:05:04 * hackagebot ide-backend-common 0.9.1.2 - Shared library used be ide-backend and ide-backend-server  http://hackage.haskell.org/package/ide-backend-common-0.9.1.2 (MichaelSnoyman)
00:07:38 * hackagebot topkata 0.2.4 - OpenGL Arcade Game  http://hackage.haskell.org/package/topkata-0.2.4 (ChristophBauer)
00:07:38 * hackagebot ide-backend-common 0.9.1.2 - Shared library used be ide-backend and ide-backend-server  http://hackage.haskell.org/package/ide-backend-common-0.9.1.2 (MichaelSnoyman)
00:12:05 <unb3k44n7> Hello, room. 
00:26:52 <liste> hello
00:28:10 <silvvy> hi
00:28:38 <mjrosenb> ugh, the type of generateRegistrationInfo changed since this library was written.
00:46:50 <timothyh> anyone know what this RecStmt constructor refers to? https://hackage.haskell.org/package/haskell-src-exts-1.13.5/docs/Language-Haskell-Exts-Syntax.html#t:Stmt
00:48:06 <timothyh> "a recursive binding group for arrows", supposedly
00:51:27 <mjrosenb> does anyone know how to ask cabal to not build documentation?
00:51:40 <mjrosenb> it looks like a compile is failing due to doc issues?
00:54:39 <timothyh> answering my own question for the sake of logs, it refers to -XArrows. changes to do notation
00:58:36 <Walther> hm, can take be applied to lists of lists somehow; as in, have a list of lists and take the first n of those lists
00:58:46 <Walther> > take 3 [[1..2] [1..3] [1..4]]
00:58:48 <lambdabot>      Couldn't match expected type ‘[Integer] -> [Integer] -> a’
00:58:48 <lambdabot>                  with actual type ‘[Integer]’
00:58:48 <lambdabot>      The function ‘[1 .. 2]’ is applied to two arguments,
00:59:03 <pavonia> mjrosenb: Does --disable-documentation work?
01:00:28 <pavonia> > take 3 [[1..2], [1..3], [1..4], 1..5]] -- Walther
01:00:30 <lambdabot>  <hint>:1:34: parse error on input ‘..’
01:00:47 <pavonia> > take 3 [[1..2], [1..3], [1..4], [1..5]]
01:00:50 <lambdabot>  [[1,2],[1,2,3],[1,2,3,4]]
01:01:01 <Walther> ah, a simple mistake, thanks :)
01:01:07 <Walther> :t take
01:01:09 <lambdabot> Int -> [a] -> [a]
01:01:13 <Walther> :source take
01:02:04 <mjrosenb> pavonia: turns out the error message was just horribly confusing :-/
01:03:36 <pavonia> Is anyone else getting spammed by cunor in private?
01:08:07 <liste> pavonia me
01:08:13 <liste> @src take
01:08:13 <lambdabot> take n _      | n <= 0 = []
01:08:13 <lambdabot> take _ []              = []
01:08:13 <lambdabot> take n (x:xs)          = x : take (n-1) xs
01:12:36 * hackagebot hdaemonize 0.5.0.1 - Library to handle the details of writing daemons for UNIX  http://hackage.haskell.org/package/hdaemonize-0.5.0.1 (sickmind)
01:24:32 <Walther> hm, when pattern matching, e.g. a length function, where you can scrap the value, is there any actual benefit of using _ : xs, instead of a named variable like x : xs?
01:26:08 <Walther> performance-wise, that is. compiler-optimizations over that or something
01:26:09 <mjrosenb> Walther: you won't accientally shadow somethig you're using, or end up creating a cyclic structure.
01:26:31 <Walther> mmh, so protective benefit from erratic definitions
01:31:44 <quchen> And you won't get unused variable names.
01:42:37 * hackagebot filediff 2.0.0 - Diffing and patching module  http://hackage.haskell.org/package/filediff-2.0.0 (bgwines)
01:57:04 <rewbert> In Haskell 2^1000 returns infinity
01:57:12 <rewbert> So silly.
01:58:00 <ollef> > 2 ^ 1000
01:58:03 <lambdabot>  <no location info>: can't find file: L.hs
01:58:15 <quchen> No, it does not.
01:58:37 <quchen> :t 2^1000
01:58:38 <lambdabot> Num a => a
01:59:27 <quchen> > 2^1000 :: Integer
01:59:29 <lambdabot>  1071508607186267320948425049060001810561404811705533607443750388370351051124...
01:59:31 <quchen> > 2^1000 :: Double
01:59:32 <lambdabot>  1.0715086071862673e301
01:59:47 <ollef> > 2 ^ 1000 :: Float
01:59:49 <lambdabot>  Infinity
02:07:38 * hackagebot JuicyPixels 3.2.5 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.2.5 (VincentBerthoux)
02:07:38 <liste> well, Float can't represent 2^1000, so of course it's Infinity
02:07:50 <liste> Float goes up to 7e38
02:10:02 <quchen> Float's representation of 2^1000 is infinity.
02:10:18 <quchen> infinity is a normal float just like 1.2 is.
02:10:55 <ollef> the person who thought that was silly has left
02:18:31 --- mode: ChanServ set +o mauke
02:18:31 --- mode: mauke set +b *!*@208.Red-2-138-160.dynamicIP.rima-tde.net
02:18:35 --- kick: cunor was kicked by mauke (cunor)
02:19:57 <liste> good riddance
02:20:35 --- mode: mauke set -o mauke
02:24:59 <edwardk> > 2^1000
02:25:00 <lambdabot>  1071508607186267320948425049060001810561404811705533607443750388370351051124...
02:25:23 <edwardk> ah was scrolled up, nevermind
02:26:28 <tulcod> parametricity. I'm reading http://www.well-typed.com/blog/2015/05/parametricity/ . in the "Example: ∀a. a -> a", they pick "a⃯ = const x". but how can you pick "a⃯ " in terms of "x". but how can you do that if the logical statement quantifies over "a" before it quantifies over "x"?
02:27:39 * hackagebot Rasterific 0.6 - A pure haskell drawing engine.  http://hackage.haskell.org/package/Rasterific-0.6 (VincentBerthoux)
02:34:50 <quchen> What's the denotational difference between `newtype Foo a = Foo a` and `data Foo a = Foo !a`?
02:45:13 <hvr> quchen: you mean if any difference can be observed w/o looking at the heap rep?
02:45:55 <quchen> hvr: Something like that, yes. Newtype have this implicit operational "can be deleted after typechecking" attached to them.
02:46:38 <quchen> hvr: In other words, "can I exchange any newtype with a strict single-constructor data type in my program without changing denotational semantics"?
02:46:39 <hvr> (I think GHC may even be allowed to handle 'Foo !A' as if it was a newtype)
02:46:40 <ronh-> "can be" not "will be"?
02:47:27 <hvr> except where you have #-kinds involved
02:47:40 <hvr> as those need the boxing
02:49:52 <hvr> quchen: I assume you looked at https://wiki.haskell.org/Newtype already?
02:50:07 <hvr> it mentions 'data Identity' a = Identity' !a'
02:50:20 <kuribas> Could the date on a hackage package consist of proof of authorship of an algorithm (when there is no precedent)?
02:53:19 <hvr> quchen: TLDR, pattern matching makes the difference observable
02:57:51 <quchen> hvr: Ah, that rings a bell, thank you.
02:59:29 <quchen> hvr: Now that you mentioned it, the formal semantics of pattern matching section in the Report talks about newtype constructors specifically.
03:22:41 * hackagebot JuicyPixels 3.2.5.1 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.2.5.1 (VincentBerthoux)
03:37:42 * hackagebot rasterific-svg 0.2.3 - SVG renderer based on Rasterific.  http://hackage.haskell.org/package/rasterific-svg-0.2.3 (VincentBerthoux)
03:52:43 * hackagebot asciidiagram 1.1.1 - Pretty rendering of Ascii diagram into svg or png.  http://hackage.haskell.org/package/asciidiagram-1.1.1 (VincentBerthoux)
03:58:16 <phaazon> hey
03:58:32 <phaazon> is there any recommendations to turn a stateful API like OpenGL into a stateless one?
04:00:00 <tTom> Hi. I'm trying to understand "Instance Applicative ((-> r)". Learn you a Haskell doesn't really explain it and I don't see why f<*>g is defined the way it is defined nor can I understand why it works the way it works with the given example. Working with (->) is trickier than the rest of the chapter on functors so far. Can you help with this? 
04:01:16 <staffehn> tTom: This instance?
04:01:16 <staffehn> instance Applicative ((->) a) where
04:01:16 <staffehn>     pure = const
04:01:16 <staffehn>     (<*>) f g x = f x (g x)
04:02:27 <tTom> Yes.
04:02:29 <liste> tTom it just satisfies the applicative laws
04:02:48 <staffehn> tTom, you first need to understand what ((->) a) means
04:03:34 <phaazon> yeah
04:03:47 <staffehn> It is kind of like (a ->), so a partially applied function constructor, you know that it takes an a, but the return type may vary
04:04:02 <staffehn> Then take the type of <*>
04:04:02 <phaazon> ((->) r) is a way to create a reader monad
04:04:14 <staffehn> (<*>) :: f (a -> b) -> f a -> f b
04:04:36 <phaazon> staffehn: you should have used r
04:04:43 <staffehn> so when f is ((->) r) we have:
04:04:47 <phaazon> you’re gonna blow things up with your two a’s :D
04:04:56 <phaazon> yeah :D
04:05:23 <staffehn> (<*>) :: (r -> (a -> b)) -> (r -> a) -> (r -> b)
04:06:12 <staffehn> tTom, now implement this type.. there is not even any other way of doing it than doing: (<*>) f g x = f x (g x)
04:06:59 <staffehn> tTom, finally one might still wanna check the Applicative laws. I will not do that here though.
04:07:29 <ClaudiusMaximus> phaazon: what do you mean by stateless?
04:07:48 <staffehn> phaazon: I just copied the instance from Hackage, they us an a there..
04:08:39 <phaazon> ClaudiusMaximus: some kind of way to make, for instance OpenGL, not force you to think if you’ve already bound something against the current context, for instance
04:10:25 <staffehn> tTom, if you don't understand an example in LYAH, you probably need to be more specific about that example if you need help understanding it.
04:10:39 <ClaudiusMaximus> phaazon: you mean to encode the OpenGL state machine into the Haskell type system so you get compile errors instead of GL errors and a blank screen?
04:12:12 <phaazon> ClaudiusMaximus: exactly
04:13:17 <ClaudiusMaximus> phaazon: the OpenGL state machine is pretty huge, and i'm not sure if the xml spec files have enough information on preconditions/postconditions to automate it
04:13:40 <ClaudiusMaximus> phaazon: plus the fact that extensions can change those pre/post conditions
04:13:40 <phaazon> yeah
04:13:46 <phaazon> what a stupid library…
04:14:23 <Adeon> the caramia package is this
04:14:27 <Adeon> opengl without state binding
04:18:05 <ClaudiusMaximus> Adeon: 'draw' says "very large overhead, use 'runDraws'", 'runDraws' says "the 'no hidden state' design is relaxed here"
04:18:43 <tTom> staffenh thanks for your help, I'm still going over it and the example in LYAH.
04:18:54 <Adeon> *with one exception
04:19:02 <Adeon> you have to make concessions to get acceptable performance
04:19:22 <Adeon> you can use raw opengl with the package if you need to
04:21:35 <Adeon> the overhead call gets you the stateless version but it's slow but there's not much you can do about it without sacrificing something
04:21:50 <Adeon> it sets up and tears down all the opengl state you specify
04:23:38 <phale> lol hey guys
04:23:50 <phale> today i was just codin' in haskell
04:26:32 <phale> then suddenly i got aids
04:26:37 <tulcod> edsko: i don't know if this is nitpicking, but I think you have your quantifiers the wrong way around in your recent article on parametricity
04:26:44 <phale> help
04:26:56 <edsko> tulcod: where?
04:27:21 <tulcod> edsko: well, you say "Picking a⃯ = const x"
04:27:31 <tulcod> edsko: but at that point you haven't introduced x yet
04:27:40 <phale> tulcod: oh?
04:27:40 <tulcod> because you quantify over relations before you quantify over elements
04:27:57 <tulcod> or am i misreading something?
04:28:21 <phale> tulcod: don't worry you aren't
04:28:25 <phale> haskell does that to you
04:29:11 <tulcod> okay maybe I am misreading the real proof strategy here
04:29:23 <tulcod> because really you're exploiting the <= direction of the iff
04:29:49 <edsko> tulcod: I guess the argument goes, in more detail: "Let x be some arbitrary element of type x, and take a⃯ = const x. Then by the parametricity result (which is valid for all x), we have that const x (f x) = f (const x x). Simplifying gives x = f x."
04:29:52 <edsko> tulcod: does that make sense?
04:30:24 <tulcod> edsko: yes, and to be clear I definitely agree with the result
04:30:59 <edsko> tulcod: I'm not sure I see where the quantification problem is. 
04:31:09 <tulcod> no i'm starting to believe I was wrong :)
04:31:43 <edsko> tulcod: okay. let me know if you think otherwise :)
04:31:49 <tulcod> yes, will do :)
04:31:50 <tulcod> thanks
04:32:02 <edsko> no worries :) this stuff can be confusing
04:32:21 <tulcod> well it should at least make sense formally
04:32:27 <edsko> yes, it definitely should
04:32:40 <edsko> tulcod: so if you think there are quantificaiton errors then that should be rectified for sure
04:33:34 <tulcod> edsko: no, i think you are absolutely right after all. this part simply *uses* the parametricity theorem, which you instantiate for a given f, and a relation that *you* supply, yielding the result that f=id, as required
04:33:38 <tTom> staffenh (<*>) :: (r -> (a -> b)) -> (r -> a) -> (r -> b) was what I was after, from there it is easier to see why it is implemented the way it is. Is there a way to get this from GHCI? :t only returns the general type. Usually not a problem but with (->) I get confused for some reason...
04:33:59 <edsko> tulcod: right, that's the idea
04:34:22 <tulcod> edsko: and I guess I was thinking you were trying to *show* the property, or something
04:34:33 <edsko> ah, fair enough
04:34:47 <tulcod> in which case you have to be careful with the order in which you itnroduce variables etc
04:34:47 <edsko> right, in that case I wouldn't have been able to pick an x on hte outside (and rightly so).
04:34:53 <tulcod> exactly
04:35:00 <tulcod> okay so that's the misunderstanding, thanks :)
04:35:12 <edsko> you're welcome :) hope you find the post useful.
04:35:16 <tulcod> edsko: (thanks for writing the article)
04:35:17 <edsko> part 2 hopefully should come soon. 
04:35:30 <edsko> it's written, just needs some polishing.
04:35:40 <edsko> (it gets harder, though. fair warning :))
04:37:47 <tulcod> edsko: also, the "a⃯ " doesn't render properly in my browser (chromium on arch linux). it does render in xchat, so i guess it's a local issue.
04:38:01 <tulcod> (i get a box for the arrow)
04:40:01 <edsko> tulcod: changed the wording slightly: "We can apply this result to show that any f :: ∀a. a -> a must be the identity function: picking a⃯ = const x, we get const x (f x) ≡ f (const x x), i.e. x ≡ f x, as required."
04:40:05 <edsko> tulcod: to avoid that confusion
04:40:35 <edsko> oh really (re: rendering). that sucks :/ it works fine in Chrome on OSX. hmm.. balls
04:40:52 <vandenoever> what's the best way to convert a Float to a Text?
04:41:03 <vandenoever> Data.Double.Conversion.Text?
04:41:07 <tulcod> vandenoever: show?
04:41:19 <vandenoever> tulcod: show can create Text?
04:41:30 <tulcod> well, first to String, then to Text?
04:42:17 <vandenoever> tulcod: i was hoping for a faster method, but show will suffice for now
04:42:27 <tulcod> vandenoever: well how many floats are you printing :P
04:43:07 <vandenoever> tulcod: millions eventually
04:43:58 <tulcod> vandenoever: then i guess your solution is at least better than mine
04:44:27 <tulcod> vandenoever: but my $0.02 is that the best optimization strategy is based around profiling. don't nitpick things that you *think* will be a performance issue
04:44:51 <vandenoever> tulcod: true, also Data.Double.Conversion.Text has c/c++ bindings which is not nice for ghcjs
04:45:18 <tulcod> vandenoever: you can use javascript primitives to print your float, maybe?
04:45:40 <tulcod> i mean if it all gets compiled into js anyway
04:46:07 <vandenoever> at that point can probably best do div.style.width = myfloat in js
04:46:46 <tulcod> vandenoever: if you want to manipulate the DOM en masse, you shouldn't be printing strings
04:47:17 <tulcod> (or texts for that matter)
04:48:49 <vandenoever> tulcod: true, i'm working towards that
04:49:25 <tulcod> if you're working towards that, you shouldn't be shaving nanoseconds off of your float printing functions
04:50:32 <vandenoever> tulcod: absolutely right, i just there might be something basic i missed in my general haskell knowledge
04:52:19 <tulcod> vandenoever: coincidentally, it looks like Data.Double.Conversion.Text uses V8 code, which means that it looks like either way you're essentially using a JS engine
04:52:29 <vandenoever> hehe
05:02:46 * hackagebot parsek 1.0.1.3 - Parallel Parsing Processes  http://hackage.haskell.org/package/parsek-1.0.1.3 (JeanPhilippeBernardy)
05:02:54 <tulcod> edsko: (I guess it would be helpful to add a conclusion to the last section about "∀ab. (∀c. c -> String) -> a -> b -> String", if only "exercise: what does this mean for f?")
05:07:12 <zipper> :t (</>)
05:07:13 <lambdabot>     Not in scope: ‘</>’
05:07:14 <lambdabot>     Perhaps you meant one of these:
05:07:14 <lambdabot>       ‘<$>’ (imported from Control.Applicative),
05:17:46 * hackagebot asciidiagram 1.1.1.1 - Pretty rendering of Ascii diagram into svg or png.  http://hackage.haskell.org/package/asciidiagram-1.1.1.1 (VincentBerthoux)
05:31:03 <edsko> tulcod: not sure what conclusion you have in mind? especially for f?
05:31:58 <mouism> e
05:32:24 <tulcod> edsko: well isn't the conclusion that if g is constant, then so should be f?
05:32:43 <edsko> tulcod: not necessarily
05:32:50 <lpaste> ClaudiusMaximus pasted “indexed monad for GL state machine” at http://lpaste.net/133314
05:32:56 <ClaudiusMaximus> phaazon: ^^
05:33:14 <edsko> tulcod: for example: f g a b = f (replicate g a) 
05:33:33 <edsko> well, that is, it's "constant" in some sense of the word
05:33:40 <edsko> but there are lots of choices for which constant to pick
05:33:48 <edsko> (albeit that that choice must be hardcoded)
05:33:52 <tulcod> edsko: constant in a and b
05:34:33 <tulcod> edsko: ie if forall x (in any type), g x = g y, then forall a, a', b, b', f g a b = f g a' b'
05:35:07 <edsko> yes, that is true
05:35:16 <tulcod> edsko: i'm not saying there's a unique such f, but any valid if with g constant is constant in a and b
05:35:27 <edsko> yes, you're correct
05:35:33 <tulcod> edsko: well let's put it this way. right now the paragraph lacks a conclusion.
05:35:49 <edsko> hmm
05:35:56 <tulcod> you say "let's try to do this example. okay, expand this. hmm, this is weird? let's expand that. EOF"
05:37:47 * hackagebot Rasterific 0.6.1 - A pure haskell drawing engine.  http://hackage.haskell.org/package/Rasterific-0.6.1 (VincentBerthoux)
05:37:59 <edsko> tulcod: and if I said:
05:40:45 <edsko> tulcod: "As a consequence, any function of the same type as `f` will also be a constant function."
05:41:24 <tulcod> edsko: iow "any `f` of that type is constant"?
05:41:35 <tulcod> (note: *in a and b*)
05:42:27 <edsko> oh, you're right, that's a little imprecise
05:42:47 * hackagebot extensible-effects 1.10.0.1 - An Alternative to Monad Transformers  http://hackage.haskell.org/package/extensible-effects-1.10.0.1 (shergill)
05:43:47 <edsko> tulcod: As a consequence, for any function `f` of the above type, `f g` itself must be constant in `x` and `y`. 
05:43:48 <edsko> tulcod?
05:44:00 <edsko> tulcod: by the way, want to read part 2 before I publish it? :)
05:44:03 <tulcod> that's superfluous :P
05:44:18 <edsko> superflous? I don't follow?
05:44:27 <tulcod> `f g` is constant would be sufficient, no?
05:44:46 <edsko> hmm, ok, fair enough. not sure which is easier to understand, but ok
05:44:49 <tulcod> to say that `f` is constant is is not enough information, but to say that `f g` is constant in `x` and `y` gives the same information twice
05:44:56 <tulcod> but okay this is me nitpicking
05:45:10 <tulcod> i'd be happy to read part two
05:45:12 <edsko> tulcodL :As a consequence, for any function `f` of the above type, `f g` must itself be constant:
05:45:16 <edsko> gah
05:45:18 <edsko> let me try that again
05:45:21 <edsko> tulcod: "As a consequence, for any function `f` of the above type, `f g` must itself be constant."
05:45:37 <tulcod> actually, this might not be sufficient
05:45:42 <edsko> haha :)
05:46:24 <tulcod> edsko: `\ x y -> y` is constant
05:46:37 <tulcod> edsko: namely constant as a function from `a` to `b->b`
05:46:45 <edsko> aye, you're right
05:46:55 <edsko> maybe constant in x and y would have been better after all?
05:47:01 <tulcod> yes
05:47:33 <tulcod> or `f g` is constant, and on top of that, `f g a` is also constant. which is a bit lengthy.
05:47:47 <edsko> yeah, that's not an improvement I think
05:47:51 <edsko> ok, updated.
05:47:52 <edsko> thanks
05:47:55 <tulcod> thanks to you
05:48:20 <edsko> part 2 is http://www.well-typed.com/blog/preview/parametricity-type-classes/ , but two provisos: it's more technical, and might still have some mistakes
05:48:32 <edsko> tulcod: but if you were interested in reading it, then feedback most certainly appreciated
05:50:47 <b_jonas> dcoutts: the homepage for the 2015 icfp contest once again doesn't tell where the homepages for the previous contests are. do you know a valid url for the 2014 contest homepage now?
05:50:56 <tulcod> edsko: if possible, a small note on how parametricity is proved I think would be nice as well :)
05:51:03 <tulcod> if you know that, anyway
05:51:05 <edsko> hah
05:51:10 <edsko> that would not be such a small note..
05:51:23 <b_jonas> for years before that, http://icfpc2013.cloudapp.net/ http://icfpcontest2012.wordpress.com/ http://icfpcontest2012.wordpress.com/previous-contests/ seems to work (except for those years that are forever disappeared)
05:51:24 <phaazon> ClaudiusMaximus: IMonad?
05:51:36 <edsko> that would be a multipart-blog-post all by itself :)
05:51:47 <tulcod> edsko: well not a complete proof, but e.g. is it some kind of induction on the complexity of types?
05:52:13 <edsko> it usually goes through logical relations
05:52:22 <edsko> I don't think I can say anything meaningfully about that in a short note
05:53:29 <phaazon> oh, that IMonad stuff is great, ClaudiusMaximus 
05:53:30 <tulcod> edsko: "Instead, it will suffice to assume the following:"  but surely this is a result you can *prove* right? not sure "assumption" is the right word
05:53:33 <phaazon> I’ll dig in
05:53:35 <phaazon> thanks
05:53:56 <edsko> tulcod: you could prove it if you did have a theory for algebraic data types. I saw that directly below the box
05:54:14 <tulcod> edsko: oh, i am stupid, please disregard :)
05:54:17 <edsko> perhaps "Assumption" isn't quite the right word.. it's an assumption about what that theory for ADTs would give us
05:54:25 <ClaudiusMaximus> phaazon: the stack overflow page is quite complete
05:54:30 <phaazon> yeah
05:54:33 <phaazon> I’m reading it 
05:55:00 <tulcod> edsko: yeah but I think this should be acceptable. i mean *I* wouldn't write it, but that doesn't mean you shouldn't
05:55:09 <phaazon> huhu
05:55:19 <phaazon> :t _ :: True
05:55:20 <lambdabot>     Expected a type, but ‘True’ has kind ‘Bool’
05:55:20 <lambdabot>     In an expression type signature: True
05:55:20 <lambdabot>     In the expression: _ :: True
05:55:29 <edsko> "Characterization" perhaps?
05:55:30 <edsko> tulcod: ^^
05:56:04 <tulcod> yes
06:00:41 <Vektorweg1> how pure is actually ieee754 floating point calculation on different machines? 
06:01:25 <merijn> What do you mean "how pure"?
06:02:17 <Vektorweg1> merijn: are calculation results the same e.g. on different amd64 machines. 
06:02:51 <merijn> Provided you use the same floating point settings, yes
06:03:06 <Vektorweg1> are they guaranteed by ghc? 
06:03:15 <pacak> Factorial with hylomorphisms https://gist.github.com/pacak/378dec398895efdabb09
06:03:18 <merijn> IEEE754 does calculations with infinite precision and then rounds to the nearest representable value
06:03:24 <b_jonas> Vektorweg1: not quite
06:03:26 <merijn> But there's a bunch of different rounding modes, etc.
06:03:37 <merijn> GHC doesn't change any of them, but doesn't set any either
06:04:03 <b_jonas> Vektorweg1: there can be differences in what NaN result you get (among multiple possible QNaN representations) depending on whether you compute with x87 or sse/avx instructions
06:04:08 <b_jonas> the rules have changed
06:05:16 <b_jonas> specifically, if you take the sum of two nans, you get a commutative result favoring certain nan values on x87, but the first of the two nans on sse.
06:05:23 <b_jonas> It's a bit ugly.
06:05:48 <b_jonas> Other than that, yes, it's all reproducible if you use the same floating point environment and exactly the same operations.
06:05:49 <Vektorweg1> so, basically, it works when i just compile something with same settings in ghc and i can deploy to different os/amd64 and get the same results? 
06:07:48 * hackagebot geniplate-mirror 0.6.0.7 - Use Template Haskell to generate Uniplate-like functions.  http://hackage.haskell.org/package/geniplate-mirror-0.6.0.7 (DanRosen)
06:08:41 <merijn> Vektorweg1: Possibly, it's hard to say, because it depends on variables that are mostly "outside" haskell
06:08:43 <b_jonas> Vektorweg1: If you compile to sse, then I believe yes. If you compile for x87, then the specs do not define the sign of the NaN result in some rare cases, so technically no.
06:08:56 <merijn> b_jonas: NaN has a sign?!
06:09:13 <b_jonas> merijn: not a real sign, just the sign bit in the representation
06:10:04 <b_jonas> typically you won't meet this unless you _specifically_ create nans with particular values, either becuause an all-one value is convenient as the result of a comparision, or because you use specific NaNs as tags.
06:10:10 <Vektorweg1> thank you. maybe i should stick to integer for no. ;)
06:10:18 <Vektorweg1> *w
06:10:48 <b_jonas> In any case, the differences in NaN representation won't cascade to other parts of results, unless you specifically examine the representation of the NaN values or do bitwise ops on them, 
06:11:17 <b_jonas> so the results _will_ be completely deterministic up to the equivalence class that considers all QNaN values the same and all SNaN values the same.
06:11:44 <b_jonas> It's much easier to trip you up by not actually doing the same operations than by this.
06:12:07 <b_jonas> There's a lot of ways you can do that sneakily.
06:17:49 * hackagebot smallcheck-series 0.3 - Extra SmallCheck series and utilities  http://hackage.haskell.org/package/smallcheck-series-0.3 (jdnavarro)
06:18:33 <Wizek> Good Morning!
06:18:43 <JuanDaugherty> moin
06:20:07 <Wizek> Any ideas why  `import Test.QuickCheck \n import Test.QuickCheck.Function \n main = sample (arbitrary :: Gen (Fun Int Bool))` outputs "{-1->True, -1->True, -1->True, -1->True, " and never seems to terminate?
06:20:29 <Wizek> I am trying to generate functions with quickcheck
06:22:32 <Wizek> The output for `sample (arbitrary :: Gen (Fun Bool Bool))` for example seems fine
06:23:32 <darkroom> I am running ubuntu and trying to install GHC 7.10 .1 is there an installation script when you download the package
06:24:35 <Cale> darkroom: There are generic linux binaries from https://www.haskell.org/ghc/download_ghc_7_10_1#binaries which work
06:25:21 <darkroom> yes i downloaded the x86_64 but how do i install it once i have downloaded that 
06:25:30 <darkroom> cale: @
06:25:31 <Cale> darkroom: The installation is just the usual configure && sudo make install  (no need to make because everything is already built)
06:25:56 <darkroom> Cale: sorry i am new to linux :)
06:25:57 <Cale> ./configure of course
06:26:10 <Cale> (maybe not of course, since you're new :)
06:26:52 <merijn> darkroom: There's a readme with install instructions in there
06:27:22 <merijn> Cale: I'd recommend "./configure --prefix=$HOME/some/path/ && make install" over global, tbh
06:27:47 <Cale> merijn: I suppose that's a reasonable option too.
06:27:50 * hackagebot ltk 0.15.0.1 - Leksah tool kit  http://hackage.haskell.org/package/ltk-0.15.0.1 (HamishMackenzie)
06:27:52 * hackagebot leksah-server 0.15.0.1 - Metadata collection for leksah  http://hackage.haskell.org/package/leksah-server-0.15.0.1 (HamishMackenzie)
06:27:54 * hackagebot leksah 0.15.0.1 - Haskell IDE written in Haskell  http://hackage.haskell.org/package/leksah-0.15.0.1 (HamishMackenzie)
06:28:02 <Cale> Especially if you're the only user of your system
06:29:16 <albeit> If I have a function "foo :: String -> IO (); foo _ = doSomething" and I call it with "foo "bar"", is "bar" ever allocated and GCed? Or is it optimized away?
06:29:38 <darkroom> Cale: I dont appear to have the command line program configure is it a program?
06:30:07 <merijn> Cale: Or when you're not and don't have sudo rights :)
06:30:10 <Cale> darkroom: You want to run the configure script which is in the directory where you unpacked the .tar.xz to
06:30:16 <darkroom> Cale: its a directory xD
06:30:16 <merijn> albeit: "it depends"
06:30:21 <Cale> darkroom: So you have to type ./configure
06:30:25 <Cale> What?
06:30:28 <merijn> albeit: You might want to inspect the generated core if you wanna be sure
06:30:41 <merijn> albeit: And even then you might not know
06:30:48 <Cale> It should be dead code.
06:30:55 <Cale> (the string)
06:31:01 <albeit> merijn: My favourite answer ;)
06:31:09 <albeit> Cale: What does dead code mean?
06:31:12 <Cale> I'd expect it not to be allocated, but yeah, do check.
06:31:18 <merijn> albeit: Code that is never executed
06:31:20 <dfeuer> HALLO.
06:31:21 <darkroom> Cale: it says permission denied but  i am root
06:31:28 <albeit> Okay
06:31:39 <Cale> darkroom: That's interesting.
06:31:41 <merijn> albeit: Typically of the "if (false) { bunch of code here }" variety
06:32:03 <Cale> darkroom: also, you shouldn't need to be root for this
06:32:13 <merijn> albeit: Dead code elimination is one of the first compiler optimisation passes to teach, but it's hard to guarantee anything :)
06:32:22 <dfeuer> albeit, more specifically, code that can never be reached for some reason. It can also be something like   let fish = 3 in 4
06:32:42 <Cale> darkroom: you only need to be root when you're doing the make install if you're installing GHC globally, which you can do by using sudo
06:33:00 <darkroom> Cale: yea i sudoed when it deined my perms
06:33:24 <Cale> Is that the exact error you got?
06:33:27 <dfeuer> Installing GHC globally is not always as good an idea as it seems.
06:33:30 <koomi> darkroom: check if it is executable
06:33:39 <Cale> ah, good point
06:33:49 <dfeuer> Well, actually maybe it's not a bad idea...
06:33:57 <dfeuer> You don't want to cabal-install stuff globally though.
06:34:02 <dfeuer> Most of the time.
06:34:20 <dfeuer> GHC itself I guess should be fine.
06:34:37 <Cale> darkroom: if you type  ls -l configure  what does it say?
06:34:46 <koomi> installing anything globally that is not managed by a packet manager is always a bad idea
06:35:15 <darkroom> -rw-rw-r-- I always forget what those mean
06:35:46 <darkroom> koomi: what should i do?
06:36:06 <pacak> darkroom: panic!
06:36:27 <darkroom> pacak: something hitchhikers guide something something
06:36:44 <merijn> darkroom: "User - Group - World"
06:36:58 <pacak> darkroom: to the galaxy, no it was "Don't Panic!" in nice and frienly letters.
06:36:59 <merijn> darkroom: So it's read/write for user & group and read for world, but not executable
06:37:27 <darkroom> merijn: you use chmod to change to executable correct
06:37:42 <koomi> darkroom: there is probably a ghc 7.10 PPA that you can install
06:37:44 <merijn> Yeah
06:38:00 <darkroom> koomi: let me check apt-get 
06:38:24 <Cale> darkroom: How did you unpack the tarball in the first place?
06:38:33 <darkroom> extract 
06:38:49 <Cale> hmm
06:39:05 <lpaste> ClaudiusMaximus annotated “indexed monad for GL state machine” with “optimize redundant state changes with class” at http://lpaste.net/133314#a133315
06:39:07 <koomi> darkroom: https://launchpad.net/~hvr/+archive/ubuntu/ghc
06:39:20 <Cale> I might recommend installing a program called 'unp' if you want to unpack things without memorising the commands for various tools.
06:39:35 <Cale> If the executable bit didn't get set, then extract didn't unpack the thing correctly.
06:39:41 <merijn> I have an easy mnemonic for remembering how to untar
06:39:42 <ClaudiusMaximus> phaazon: annotated the thing with more things :)
06:39:50 <mitu> Does there exist a "batteries-included" networking library for haskell, similar to twisted for python?
06:40:26 <merijn> mitu: Not really, there's various conduits/pipes libraries for networking, but I don't think twisted makes a lot of sense in haskell
06:40:51 <merijn> Cale: "tar xzf" -> imagine german accent -> "Xtract Ze Files"
06:41:10 <Cale> heh
06:41:19 <ClaudiusMaximus> merijn: you forgot about j
06:41:28 <merijn> Most useful tar mnemonic I ever learned :p
06:41:34 <merijn> ClaudiusMaximus: No clue what j does?
06:41:41 <ClaudiusMaximus> merijn: same as z, but for bzip
06:41:54 <ClaudiusMaximus> and recent tar doesn't need either (xf works fine)
06:41:59 <merijn> I know
06:42:12 <merijn> But I'm old sk00l! :p
06:42:13 <darkroom> koomi: how do you work with PPA?
06:43:34 <mitu> merijn: thanks
06:43:37 <koomi> darkroom: do you see the section "Adding this PPA to your system"? read it
06:44:24 <YellowOnion> mitu, you're probably better off being more specific with what you want to do so we could point you in the right direction.
06:44:51 <Cale> Yeah, the PPA might be better, especially for a beginner, since it'll be harder to screw things up and easier to uninstall later.
06:45:43 <merijn> mitu: Twisted's main goal (at least when I did python) was to provide an API for non-blocking networking stuff
06:46:11 <merijn> mitu: But in Haskell with lightweight threads the right solution is almost always to simply write a simple 1 thread per connection implementation
06:46:21 <merijn> mitu: And then you can just use whichever blocking library you want
06:47:37 <lpaste> ericdwhite pasted “Pure and Impure Split” at http://lpaste.net/1721421994588635136
06:48:13 <ericdwhite> Hi I'm wondering if someone can give me some feedback on that pastebin "pure and impure split".  Specifically:
06:48:56 <ericdwhite> 1) imagesFor - how to deal the fact the digestForFile returns an IO M.Digest and how I unwrapped it (seems ugly)
06:49:21 <merijn> ericdwhite: First off: https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad
06:49:43 <ericdwhite> 2) imagesFor - use of sequence with zipWIth
06:49:47 <ericdwhite> still a noob
06:50:20 <darkroom> koomi: so i added the ppa to my system but then how do you actually install the package?
06:50:40 <merijn> ericdwhite: you probably want to use "mapM" with "digestForFile"
06:50:49 <merijn> ericdwhite: "mapM f = sequence . map f"
06:51:15 <ericdwhite> I used zipWith because I need to merge the list of filepaths, with the list of digests
06:52:17 <merijn> ericdwhite: Oh, now I see why you use map and then sequence. I don't think it's particularly bad
06:52:38 <koomi> darkroom: as you do normally with apt-get, e.g. apt-get install ghc-7.10
06:52:51 <Cale> :t zipWithM
06:52:52 <lambdabot> Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
06:53:00 <ericdwhite> I used sequence because of the fact I get IO [IO M.Image] and sequence fixes that
06:53:02 <koomi> darkroom: actually ghc-7.10.2 is the correct package name
06:53:19 <koomi> you can see a list of packages in that PPA further down on that page
06:53:27 <Cale> ericdwhite: Okay, do you understand the manner in which an IO String is not at all like a String?
06:53:40 <merijn> Cale: That doesn't work, his second argument is already an IO item
06:53:45 <Cale> oh, okay
06:53:56 <Cale> er...
06:53:58 <merijn> Cale: Because he's first mapping digestForFile and then zipping
06:54:18 <darkroom> koomi: i am trying to use stackage and it wants 7.10.1 but thanks so much for your help
06:54:42 <merijn> Cale: So he currently has "(a -> IO b -> IO c) -> [a] -> [IO b] -> [IO c]" and then does sequence on that
06:54:52 <Myrl-chan> You know
06:55:02 <Myrl-chan> I decided to put my Haskell anthropomorphization in /r/haskell
06:55:03 <merijn> You could probably make it nicer, but I'm too lazy to think about it now
06:55:04 <Cale> merijn: Well, sequence (zipWith f xs ys) = zipWithM f xs ys regardless, no?
06:55:05 <Myrl-chan> They didn't like it.
06:55:09 <Myrl-chan> :(
06:55:23 <merijn> Cale: Oh, right
06:56:00 <ericdwhite> @Cale let me try that
06:56:00 <lambdabot> Unknown command, try @list
06:56:32 <Cale> ericdwhite:  flat <- return $ flattenDir $ filterDir imageFilter tree  -- consider:   let flat = flattenDir $ filterDir imageFilter tree
06:56:35 <koomi> darkroom: glad to help, and using stackage is a great decision, it will save you from a lot of pain
06:57:11 <Cale> ericdwhite: In fact, hlint, via the pastebin, is already suggesting all the things we are :D
06:57:35 <darkroom> koomi: as you can see i am kinda a scrub and cabal hell was really getting me. I told my boss that we are moving the whole company to stackage and he agrred xD
06:57:41 <Cale> ericdwhite: (click the pink and yellow bits at the bottom of the paste for its suggestions)
06:58:19 <ericdwhite> Great thanks
06:58:31 <Cale> ericdwhite: As a general thing, consider trying to write f $ g $ h $ x as f . g . h $ x
06:59:21 <Cale> ericdwhite: This is slightly easier to manipulate, because, e.g. f . g and g . h will be well-typed functions, as (.) is associative, while f $ g and g $ h will in most cases be type errors on their own.
06:59:30 <oceliot>  /msg NickServ VERIFY REGISTER oceliot uxiwpifijqva
06:59:40 <Cale> oceliot: FAIL
06:59:51 <oceliot> ...
07:00:10 <Cale> oceliot: I hope you don't use that password anywhere else, because you just wrote it into a channel with 1500 clients connected
07:01:37 <Cale> Oh, or is that just a registration key?
07:01:46 <Cale> (I thought they were numbers...)
07:01:47 * ronh- resists the urge to /msg nickserv ghost
07:02:21 <oceliot> Cale: yes it is the key to verify my email
07:02:34 <Cale> ah, that's not as bad then :)
07:03:02 <oceliot> Cale : now, everyone can help verifying my email...
07:03:07 <Cale> haha
07:05:29 <Cale> ericdwhite: Generally, you want to think of values of type IO t as being descriptions of things which could be done to produce a result of type t. The difference between getLine :: IO String and an actual String is similar to the difference between /bin/ls and a list of files. You seem to be managing reasonably well though, this code seems to have a reasonable separation between IO and non-IO stuff :)
07:17:39 <Myrl-chan> I have a record consisted of multiple Maybe Ints.
07:19:45 <Myrl-chan> If I "show" it, I want each element to output key: value if it's Just value, and not output anything if it's Nothing.
07:20:02 <Myrl-chan> Is there a cleaner way to do it than
07:20:48 <Myrl-chan> putStr $ "key: " ++ (maybe "" id value)
07:21:49 <Cale> :t fromMaybe
07:21:50 <lambdabot> a -> Maybe a -> a
07:21:58 <Cale> Might be slightly nicer?
07:22:26 <Myrl-chan> Yeah, that's indeed slightly nicer.
07:22:50 <Cale> Also note that what you wrote will still produce "key: " in the Nothing case.
07:22:59 <Myrl-chan> Oh yes, nice catch.
07:23:11 <merijn> If you don't want that it becomes easier
07:23:30 <merijn> :t maybe "" ("key: " ++)
07:23:31 <lambdabot> Maybe [Char] -> [Char]
07:23:32 <Myrl-chan> putStr $ maybe id (\x -> "key:" ++ x)
07:23:41 <Myrl-chan> Oh yes...
07:23:42 <Myrl-chan> <.<
07:24:04 <Myrl-chan> I was planning to write (("key:" ++) . id) lol
07:24:12 <wei2912> hi Myrl-chan 
07:24:19 <Myrl-chan> wei2912: Yahallo~
07:25:11 <manjunaths> I am thinking of something like a function like this func::String -> a -> b. Based on String it should give one or the other. For example b can be either String or File. Is this possible in haskell ?
07:25:22 <Myrl-chan> merijn: I can probably also use ShowS.
07:25:45 <Myrl-chan> Hmmm... nah.
07:25:49 <kadoban> manjunaths: func :: String -> Either a b
07:25:57 <manjunaths> Ah...
07:26:10 <manjunaths> Is there like a Multiple Either ?
07:26:20 <manjunaths> Like 10 different things ?
07:26:34 <manjunaths> Either a b c d e f g h i j ?
07:26:46 <kadoban> manjunaths: I don't know, but you can implement one yourself if it's a fixed number of things.
07:26:53 <Myrl-chan> Judging by "file", why not do
07:26:55 <Myrl-chan> String -> IO a
07:27:26 <merijn> manjunaths: You can implement it yourself, but it's not a preexisting thing
07:27:37 <manjunaths> merijn, Ok. Thank you.
07:27:37 <Myrl-chan> And wouldn't really look nice, IMO.
07:27:47 <manjunaths> Myrl-chan, Ok.
07:28:05 <Myrl-chan> manjunaths: Why not just do func :: String -> a
07:28:14 <Myrl-chan> Except that you'll be losing some type safety.
07:32:53 * hackagebot observable-sharing 0.1.1.0 - Simple observable sharing  http://hackage.haskell.org/package/observable-sharing-0.1.1.0 (mararon)
07:51:05 <Guest98706> :0
08:13:28 <haskell907> What do Haskellites generally think about Prolog?
08:14:16 <hpc> i didn't like it, the cut operator rubbed me the wrong way
08:14:25 <hpc> you'll probably find a wide variety of opinions though
08:14:54 <haskell907> Thanks for your answer. the cut operator is apparently not idiomatic most of the time
08:15:08 <haskell907> It's frowned upon, sort of. 
08:15:20 <latk> What is the easiest way to get the UTCTime one month ago? Does diffUTCTime in Data.Time.Clock work with negative differences ?
08:16:26 <haskell907> Haskell do seem to enjoy a more thriving community though. 
08:18:31 <gabemc> Hey, I'm using Data.Binary, trying to parse Elf headers. I need to parse a particular field as either a Word32 or a Word64 depending upon a previous header flag, but I can't figure out how to make the return types of the expressions match up -- how to coerce a Word32 into a Word64 inside the Get monad. I'm trying `liftM (fromIntegral :: Word32 -> Word64) $ get :: Word32`, but that's not working. Any ideas?
08:19:03 <hpc> latk: if you define a month as 30 days, you'd probably do something like
08:19:20 <hpc> addUTCTime (60 * 60 * 24 * 30) yourTime :: UTCTime
08:19:26 <Clint> gabemc: drop the :: Word32 at the end
08:19:29 <Cale> gabemc: That :: Word32 on the end applies to the *whole* expression
08:19:32 <latk> Oops, I actually meant addUTCTime.
08:19:39 <latk> hpc: Won't that give me the date one month in the future ?
08:19:42 <gabemc> Hah!
08:19:48 <gabemc> So simple!
08:19:51 <Vektorweg1> haskell907: i would prefer a prolog-like database schema over sql. 
08:19:52 <gabemc> Lol. Thanks!
08:20:01 <Cale> gabemc: You might've meant to write (get :: Word32), but that would be wrong as well, because get :: Get t for some type t
08:20:08 <hpc> latk: er, negative (that multiplication)
08:20:33 <Cale> However, the type of value to get can be inferred from the other information you've already provided (that explicit signature on fromIntegral is enough)
08:20:35 <hpc> latk: if you want actually one month ago, you need to pick a calendar library and decide what to do with dates like march 30
08:20:38 <latk> hpc: Cool cool.
08:20:43 <gabemc> Yeah - I mistyped it.
08:20:47 <latk> hpc: Yeah it doesn't need to be precise
08:21:22 <latk> How can I check which version of a package I've got installed in a sandbox ? 
08:21:30 <latk> Looks like I might have a newer version of time than I thought
08:22:54 <merijn> latk: "cabal run ghc-pkg list" or something, I think
08:23:20 <haskell907> Vektorweg1: Me too. 
08:23:30 <latk> merijn: Yep, that works. Thanks.
08:25:08 <Cale> haskell907: One problem that earlier versions of prolog had, but which has sort of been solved in the newer implementations of the language is that prolog was originally very first order. You could end up with many predicates which are defined in very similar ways without a means to abstract over the parts which vary in their definitions. But there are ways of defining 'meta-predicates' now that resolve that for the mo
08:25:08 <Cale> st part.
08:26:17 <Cale> But it's not like the language was designed with those in mind, so I don't know how it really works out in practice. I haven't used Prolog enough to really be able to tell you.
08:27:55 * hackagebot th-typegraph 0.17 - Graph of the subtype relation  http://hackage.haskell.org/package/th-typegraph-0.17 (DavidFox)
08:28:26 <haskell907> Cale:  Thanks for your response. I am dabbling in SWI-Prolog now and it does seem to enjoy many modern features and active development. Interestingly enough, the IRC channel for Prolog includes some Haskell programmers as well. Sounds like the language attract similar groups of talented people 
08:30:21 <albeit> I've compiled with -threaded and have -N4 set, and I know there are only four threads running. However, if I don't do anything in one of the threads (which is independent of the rest), execution is significantly faster - shouldn't the speed be the same, as each thread has its own core?
08:30:45 <merijn> albeit: FYI, -N4 doesn't mean only four threads
08:31:01 <merijn> albeit: It means only 4 Haskell Execution Contexts (HECs)
08:31:14 <merijn> There may be more threads for polling, safe foreign calls, etc.
08:31:38 <c_wraith> There's also the rest of the machine to consider
08:31:45 <albeit> merijn: Okay... so if I have only explicitly forkIO'd three threads off the main thread, two of those may be on the same HEC?
08:31:46 <hpc> and the HECs don't get mapped directly to physical cores
08:31:50 <c_wraith> The OS needs to run, all your background processes need to run
08:31:58 <merijn> albeit: There's also overhead due to global GC stop and multiple processes n your machine demanding CPU time
08:32:10 <merijn> albeit: HECs use work stealing
08:32:24 <merijn> albeit: So if one is idle it'll steal threads from the queue of another
08:32:46 <c_wraith> Threads do *usually* stay on the same HEC, if all the HECs are busy
08:33:29 <albeit> Okay... just realized my test PC has only four cores. I'll try it on a server running nothing else with 32 cores, see if I see the same thing.
08:38:39 <albeit> Is it ever a good idea to use forkOn, and set which HEC a thread runs on?
08:39:59 <merijn> albeit: Not unless you know why you're doing it
08:40:06 <fvgvxmpv1> *
08:40:57 <albeit> merijn: Well, if I have two threads that are relatively unimportant and one that is very important, would it make sense to set the unimportant ones to capability A, and the important one to capability B?
08:43:12 <albeit> Argh, even on a machine doing nothing else with many cores, having two threads "doing things" is much slower (and more variable) than having just one thread doing something.
08:46:05 <albeit> It's actually the same speed if I just restrict it to one core. It's as if threading isn't doing anything... but I know it is threaded because there are multiple capabilities.
08:57:57 * hackagebot observable-sharing 0.2.0.0 - Simple observable sharing  http://hackage.haskell.org/package/observable-sharing-0.2.0.0 (mararon)
08:58:57 <merijn> albeit: Are your operations blocking?
09:00:44 <albeit> merijn: Nope... threads only interact by message passing with TQueues, and they don't do any blocking operations
09:00:59 <albeit> Just wait for data in the TQueue then do some action with it
09:02:49 <Haskell101> data TLTree a = L a | N (TLTree a,(TLTree a,TLTree a)) deriving (Eq,Show)  depthTLTree = cataTLTree(either one (succ . uncurry max . p2 (uncurry max p2))) what's wrong in that ?
09:03:21 <Haskell101> data TLTree a = L a | N (TLTree a,(TLTree a,TLTree a)) deriving (Eq,Show)  depthTLTree = cataTLTree(either one (succ . uncurry max . p2 (uncurry max))) what's wrong in that ? (edited)
09:06:08 <merijn> albeit: How many are waiting for the TQueue and where is the data coming from?
09:08:09 <albeit> Each thread is waiting on its own TQueue (so just one waiting for each TQueue), and data is coming from other threads putting data into the TQueue. But the thread I'm enabling/disabling to check differences has a TQueue that is always full... it's never really waiting on the other threads.
09:09:25 <merijn> albeit: How expensive is each bit of work?
09:11:14 <albeit> merijn: Not sure of an answer for that... most of the work it does is writing logs to files or submitting something to a DB.
09:11:33 <merijn> albeit: Are you sure you're not bottlenecked by disk IO?
09:11:37 <albeit> merijn: Basically, work of secondary importance that I don't want being done in main threads
09:12:14 <albeit> merijn: Well, I'm timing only the main thread in criterion, so I didn't think a secondary thread bottlenecked by disk IO would affect the timing.
09:12:15 <merijn> albeit: If disk IO is the bottle neck I would indeed expect GHCs single threaded implementation to be faster than -threaded
09:12:33 <merijn> albeit: Adding threads == adding global GC stops
09:13:00 <merijn> albeit: If you can multiplex the disk IO with your main thread than you avoid those global GC stops and get better speed
09:13:03 <sleblanc> I am interfacing a C library (PulseAudio) and the library encourages callbacks. The callback is sent a void pointer (userdata). Can I make use of this while retaining static/safe typing in the equation?
09:13:34 <albeit> merijn: I think I've accounted for that... I only run enough iterations so that it doesn't GC, then right before the next round of tests run I performGC. So no GC's are being performed while timing (checked with getGCStats)
09:13:37 <merijn> sleblanc: Not really, since your callbacks will need to accept void* and your data will be passed as void*
09:13:51 <merijn> albeit: Then I dunno
09:14:03 <athan> Why isn't there a `manyTill1` for parsec?
09:14:09 <albeit> merijn: Okay, well thanks anyways. What do you mean by multiplex the disk IO?
09:14:42 <osa1_> let's say I'm using Generic a => Binary a instance for binary serialization. does my program break if I reorder constructors and load old binaries?
09:14:45 <merijn> albeit: Multiplex the threads
09:15:16 <merijn> albeit: i.e. if your threads only take 0 time (rounded) then running those threads on the same HEC as your main code doesn't cost you anything
09:30:01 <SrPx> Hello, I'm trying to FFI a CUDA file with Haskell. I've compiled the file with "nvcc file.cu -c -o file" and I've compiled the Haskell file with "ghc file.h -o file -L/usr/local/cuda/lib -optl-lcudart". Yet, when I run the Haskell file, it seems like the CUDA kernels are not being called. Why?
09:31:00 <merijn> SrPx: How are you calling the cuda kernels?
09:31:23 <SrPx> They are being called inside the hello() function (that's a hello world) on file.cu
09:31:29 <SrPx> http://lpaste.net/133322
09:31:41 <SrPx> If I call that "hello" from C, it prints: Hello World
09:31:47 <SrPx> if I call it from Haskell, it prints: Hello Hello
09:32:02 <SrPx> http://lpaste.net/133323 this is the haskell file
09:34:07 <voidzero> hello world sucks
09:34:18 <voidzero> as proof, i mean
09:34:58 <voidzero> for how good a language is
09:35:01 <voidzero> i al
09:35:27 <voidzero> i'm always amused by people who go on a tangent based on 'hello world'
09:35:36 <voidzero> ...not saying that's what happened here
09:35:39 <voidzero> just in general :)
09:36:35 <SrPx> eh I'm just trying to get the FFI to work
09:36:55 <SrPx> but yea hello worlds don't tell a lot about the language
09:37:58 * hackagebot Agda 2.4.2.3 - A dependently typed functional programming language and proof assistant  http://hackage.haskell.org/package/Agda-2.4.2.3 (AndresSicardRamirez)
09:38:01 <hiptobecubic> I don't know, I think it has some merit
09:38:44 <hiptobecubic> If it's difficult to print a string to standard out in your language, then your language probably isn't useful for a lot of day to day stuff one typically wants to do
09:38:53 <hiptobecubic> It's not a perfect rule, but it's a reasonable heuristic i think
09:39:20 <hiptobecubic> The same way languages that have complicated syntax for defining functions probably aren't nice either
09:47:05 <albeit> If I have a TQueue, but each time I check the TQueue I actually want to take the entire TQueue, does it make more sense to use a TVar Seq?
09:52:03 <voidzero> hiptobecubic, but a language like haskell treats the string 'hello world' so much differently
09:52:25 <voidzero> print "Hello world" is  considered "just an action" in most languages
09:53:42 <nitrix> Hi, I have a question on file systems. Would it be innapropriate to ask here?
09:53:53 <voidzero> dunno. it's not that busy. shoot!
09:54:03 <bennofs> nitrix: hard to know without knowing the question...
09:54:37 <nitrix> I'm working with a medium that's extremely cheap, cheaper than amazon in fact, but it comes with a downside: it's write-once-read-many and block-based.
09:55:11 <nitrix> I'm trying to build a file system on top of that. I've heard that copy-on-write is a good strategy to emulate read-write file systems on such devices, so there's that...
09:55:50 <nitrix> Also, B-tree seems appropriate as nodes in the tree have a perfect correspondance with blocks on the device, but then I'm fairly lost.
09:55:57 <bennofs> nitrix: hmm, doesn't sound much like a #haskell question so far. maybe try #haskell-blah?
09:56:37 <nitrix> How are directories represented? A B-tree also? That wouldn't be O(log n) then... and where is the metadata? In the directory? In the file?
09:56:42 <nitrix> Oh okay.
09:57:10 <orion> What's the best way to upgrade one package in a sandbox?
09:57:17 <voidzero> it sounds like it could be part of a question on how to code efficiently for this use case
09:57:22 <voidzero> s/use case/environment/
09:58:04 <nitrix> voidzero: I figured haskell would be appropriate since people are familiar with immutable data structures.
09:58:27 <nitrix> Are the performances for an immutable B-tree reasonable?
09:58:56 <voidzero> personally i haven't a clue but i do get why you ask :)
09:59:02 <voidzero> here, i mean.
10:01:14 <c_wraith> nitrix: Eh..  You'd have to copy a full block on each modification.  That would lead to a lot of churn if it's used linearly.
10:02:16 <c_wraith> nitrix: actually, you'd need to copy a full block per level, at minimum.  Sounds like a *lot* of waste, if you're not using very small blocks or taking heavy advantage of the fact that the structure is persistent
10:08:01 <DuckBoy> hey guys do you know how i can add haskell repository to kali linux 
10:08:13 <nitrix> c_wraith: It's theorically O(log n), but the tree is so extremely flat, you'd need serious usage to reach even 4 levels. But I agree with you.
10:08:45 <DuckBoy> Executing: gpg --ignore-time-conflict --no-options --no-default-keyring --secret-keyring /tmp/tmp.Xupm3mAEPx --trustdb-name /etc/apt//trustdb.gpg --keyring /etc/apt/trusted.gpg --primary-keyring /etc/apt/trusted.gpg --keyring /etc/apt/trusted.gpg.d//debian-archive-jessie-automatic.gpg --keyring /etc/apt/trusted.gpg.d//debian-archive-jessie-security-automatic.gpg --keyring /etc/apt/trusted.gpg.d//debian-archive-jessie-stable.gpg --
10:09:00 <nitrix> c_wraith: I don't know how it could be improved though. It boils down to breaking a graph into blocks, so there'll always be multiple blocks involved, right?
10:09:01 <DuckBoy> i got this trying to add the repository :c
10:11:23 <c_wraith> nitrix: well, smaller blocks can help.  Like what the HAMT stuff does..  It keeps blocks small enough that copying them is no huge cost, but big enough that depths still stay *pretty* small.
10:15:29 <DuckBoy> when i do apt-get update i got this 
10:15:31 <DuckBoy> W: Failed to fetch http://ppa.launchpad.net/hvr/ghc/ubuntu/dists/lucid/main/binary-amd64/Packages  404  Not Found
10:15:51 <DuckBoy> can i get some help ? 
10:16:16 <SrPx> So, by the way, this is the problem I'm getting when trying to FFI CUDA: "Cuda failure hello.cu:32: 'no CUDA-capable device is detected'"
10:16:19 <nitrix> c_wraith: Yeah, I was thinking 1MB, it's quick to upload and still can have a good 10'000 branches provided each record is like 100 bytes.
10:16:28 <srhb> DuckBoy: Perhaps you should ask in a channel that knows about your distro
10:16:33 <SrPx> So, Haskell isn't able to locate the CUDA device. (It works with C.) Why?
10:16:35 <srhb> DuckBoy: It's not really Haskell specific. :)
10:16:46 <DuckBoy> ok >:3
10:16:59 <nitrix> c_wraith: That's a good point, unfortunatly, it's something I already have taken into account :] I'm more worried about the actual data structures nessessary for the rest.
10:17:25 <nitrix> c_wraith: The file would be a rope data structure, the paths could be a B-tree, but I'm not sure how directories work
10:18:11 <geekosaur> that's hvr's ppa, not ubuntu's
10:19:00 <geekosaur> and as far as I can see, hvr does not maintain ghc for lucid (really? that's ancient)
10:19:20 <geekosaur> only goes back to 12.04 Precise
10:26:32 <SrPx> nobody knows, right? :(
10:27:01 <funrep> anyone know any list or guide if one wants to get their hands dirty with the "math-parts" of haskell? 
10:27:42 <funrep> i assume this "category theory" requires some kind of foundation
10:31:30 <albeit> Are calls to STM related code expensive? If one thread is trying to read/take from STM, and another trying to write to STM, is their a possibility of extended conflicts?
10:34:20 <fryguybob> albeit: Yes there can be conflicts that take work to resolve.
10:34:33 <fryguybob> albeit: The assumption with STM is that conflicts are rare.
10:34:45 <joneshf-laptop> is lucid even still supported?
10:35:52 <joneshf-laptop> oh, i guess server support just recently ended
10:43:01 * hackagebot hslogger-template 2.0.3 - Automatic generation of hslogger functions  http://hackage.haskell.org/package/hslogger-template-2.0.3 (BrianLewis)
11:01:50 <kuribas> I have found an algorithm for approximating a bezier curve through points.  I think it is a novel approach, at least I didn't find any paper describing it.  Would adding an implementation to hackage be sufficient as proof that I wrote it?
11:03:02 * hackagebot inline-c 0.5.2.0 - Write Haskell source files including C code inline. No FFI required.  http://hackage.haskell.org/package/inline-c-0.5.2.0 (FrancescoMazzoli)
11:06:09 <kadoban> kuribas: Proof for … what? General kudos? Probably. A patent or something? Ask a lawyer.
11:07:03 <kuribas> kadoban: No, that's not needed, but I wouldn't want an academic to take my idea and put his own name under it.
11:08:58 <kuribas> Or yeah, someone writing a patent for it, and then suing me ...
11:11:03 <kadoban> That I'm not sure. You still might want to ask a lawyer, heh. You could write it up yourself in a journal if you can, or just informally in a blog or something, or find someone to write it for you and give you credit for the idea.
11:12:35 <merijn> kuribas: If they sue you then show "prior art" and laugh in their face
11:13:02 <kuribas> merijn: Is hackage valid as "prior art"?
11:13:19 <hpc> didn't the US change to first-to-file?
11:13:40 <merijn> hpc: That doesn't invalidate prior art
11:13:47 <merijn> Does it?
11:14:01 <geekosaur> um
11:14:20 <orion> kuribas: I would just write an academic paper yourself and publish it.
11:14:26 <geekosaur> the patent system is so badly compromised at this point that the only guarantee is the most expensive lawyer
11:14:28 <merijn> hpc: That just means if two parties try and patent the same thing the first to file party wins, as opposed to the first one to discover
11:15:07 <hpc> but if you invent it and then don't attempt to file
11:15:17 <geekosaur> prior art is only useful or effective in the hands of a lawyer
11:15:29 <merijn> hpc: That's irrelevant, you can't patent already public knowledge
11:15:48 <merijn> hpc: At least, in theory
11:15:59 <c_wraith> I've heard the prior art Stack Exchange site has actually invalidated a few patents during review.
11:16:02 <merijn> hpc: US patent office incompetence not withstanding
11:16:30 <merijn> hpc: The point with first to file is that it only affects independent invention by multiple parties and who gets the patent
11:16:32 <geekosaur> in practice it happens all the time, because someone has to actually sue and have enough money and lawyers to keep it going until they can present evidence in court and get a ruling
11:17:04 <merijn> geekosaur: Sure, but if the prior art is the same thing you're being sued for than that's a risky mistake by the party suing
11:17:07 <geekosaur> (there are organizations that try to help but chronically underfunded...)
11:17:14 <kuribas> orion: right, I'll try :)
11:17:40 <geekosaur> merijn, not when the suit costs you a couple years' worth of income and them pocket lint
11:18:04 <hpc> merijn: so what's the time difference between "we invented this independently" and "i invented it first"?
11:18:34 * hpc didn't mean to derail this conversation
11:19:06 <merijn> hpc: Multiple parties intending to register their invention won't publicly disclose it
11:19:21 <merijn> hpc: Once it's publicly disclosed it's unpatentable (in theory)
11:25:46 <orion> I want to perform a lookup (Maybe ByteString) and convert it to Text if it's found. I tried this, but it doesn't work because the types don't match up: lookupHeader hs h = lookup h hs >>= decodeUtf8
11:26:09 <orion> What's the best way to proceed?
11:26:25 <osa1_> decodeUtf8 <$> lookup h hs
11:26:31 <orion> bah
11:26:59 <orion> osa1_: Thank you :)
11:27:33 <brbblnch> hi
11:28:06 <bennofs> orion: if you want failures while decoding to result in Nothing too, you need to use lookup h hs >>= \v -> either (const Nothing) Just $ decodeUtf8' v
11:28:13 <brbblnch> Are proof assistant nothing more than using the Curry-Howard isomorphism to prove stuff?
11:28:44 <meiji11> is there a way to load haskell libraries at runtime and programmatically iterate over the values and types of those values?
11:28:51 <meiji11> I've looked at the GHC API and it's.. daunting.
11:29:06 <merijn> meiji11: No, because there are no types in compiled libraries
11:29:23 <Cale> brbblnch: That would be putting it very glibly, but yes, that's how Coq and Agda work.
11:29:45 <meiji11> merijn: and there's no representation of those types that are accessible by other means?
11:30:02 <brbblnch> Cale: You're always there for me
11:30:10 <merijn> meiji11: Not really. I mean, you could require Typeable on everything and abuse that, but....
11:30:29 <meiji11> merijn, that's actually a reasonable assumption in my case
11:30:29 <merijn> brbblnch: FYI, if you're interested in theorem proving there's a really nice (free!) book on proving program properties in Coq
11:30:52 <brbblnch> Cale: But have those languages developped after/thanks to CH or are those two different things that go along ?
11:31:10 <meiji11> I'm trying to write an FFI to Haskell in a language I've implemented in Haskell
11:32:03 <meiji11> which would require dynamically loading libraries, I just have no idea how to go about doing that.
11:32:31 <merijn> meiji11: Do you know how to do dynamically loading stuff in C? If so, you get basically the same thing in haskell
11:32:35 <brbblnch> merijn: Someone gave me a link to a tutorial about Coq once, maybe it's that. Care to give me the link?
11:32:41 <merijn> @where sf
11:32:41 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages", "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof
11:32:41 <lambdabot> assistant."
11:32:44 <osa1_> meiji11: this might be of interest http://osa1.net/posts/2013-06-29-shenhs-ffi.html
11:32:50 <merijn> brbblnch: That one
11:33:12 <brbblnch> merijn: Thank you
11:33:25 <orion> bennofs: thanks!
11:33:27 <merijn> brbblnch: It's an excellent book and basic FP is all that you need (i.e. if you're comfortable thinking recursively you're set)
11:33:31 <meiji11> osa1_: oh, hey. thank you. this is my project, if you're interested: https://github.com/mthom/shentong
11:33:49 <osa1_> wow haha
11:33:54 <osa1_> it's the same thing :p
11:34:25 <meiji11> indeed.
11:36:28 <meiji11> osa1_, it seems you're using the plugins package
11:36:34 <meiji11> I had considered that.
11:37:23 <osa1_> meiji11: there are other ways but since your interpreter is written in Haskell and you need Haskell FFI that may be the easiest way.
11:38:02 <osa1_> meiji11: http://osa1.net/posts/2015-01-16-haskell-so-lua.html this post is about Haskell FFI for Lua, for example
11:38:26 <meiji11> right. I was thinking of mining the plugins source for useful parts and reproducing those. not the best practice, but plugins is not really maintained any more. 
11:38:44 <bennofs> meiji11: maybe try hint?
11:38:49 <bennofs> @hackage hint
11:38:49 <lambdabot> http://hackage.haskell.org/package/hint
11:38:51 <meiji11> thank you. you have lots of useful stuff on your blog, by the look of it
11:39:17 <meiji11> bennofs, I will check that out. thanks.
11:39:39 <osa1_> bennofs: but he wants to load compiled Haskell libs, instead of interpreting Haskell code, I think.
11:39:55 <bennofs> hmm oh right, I forgot that plugins loads compiled code
11:41:48 <meiji11> that's right, yes.
11:42:19 <meiji11> I'd like to iterate over the types of the compiled code, and then produce wrappers that my shen implementation can call
11:42:54 <osa1_> meiji11: wrapping should be already handled in compiled code... because you won't have types to wrap them. this is the approach I used in my implementation.
11:43:05 <meiji11> okay
11:43:12 <osa1_> e.g. you should know types of compiled functions before loading them
11:43:23 <osa1_> meiji11: maybe use some kind of extra files to save type information
11:43:42 <osa1_> meiji11: like a JSON file that lists exported functions with their types
11:43:53 <meiji11> I don't suppose cabal provides anything like that?
11:44:02 <osa1_> no, you need to implement that
11:44:49 <SrPx> I'm almost convinced this is a GHC bug, what do you guys think? If that is the case I can just move on and try to approach the subject differently. Perhaps using memory mapped files
11:45:26 <meiji11> I see. this will be a challenge.
11:45:48 <meiji11> your stuff is helpful, though. I'm not totally in the dark now.
11:46:31 <Cale> SrPx: "this"?
11:47:15 <SrPx> Cale: seems like trying to FFI a CUDA file with Haskell doesn't work since Haskell won't recognize the CUDA devices installed
11:47:47 <Cale> SrPx: I don't think I understand what that means.
11:48:35 <srhb> Why would not recognizing a CUDA device be a GHC bug? afaik GHC has nothing to do with CUDA.
11:48:35 <SrPx> I have a hello world cuda application. I am trying to call it from haskell using the FFI system, but it doesn't work. I get a CUDA error "no CUDA-capable device is detected".
11:48:47 <srhb> Can you upload your test case?
11:49:05 <SrPx> The same CUDA application works fine compiled with the CUDA compiler and being called from C (not Haskell), so that discards a problem on my CUDA install
11:49:20 <ew0000> is there a better way to create a monoid instance for my type?
11:49:21 <ew0000> http://pastie.org/10206860
11:50:04 <merijn> ew0000: Not really, I think
11:50:09 <Cale> SrPx: are you using http://hackage.haskell.org/package/cuda ?
11:50:14 <ew0000> even with lenses magic?
11:50:21 <merijn> ew0000: You could automate things using TH, but that's probably more work than the current code
11:50:37 <merijn> ew0000: I'm not much of a lens wizard :)
11:51:29 <SrPx> No, in fact I have no idea how to use this package, Cale. I just wrote a ".cu" file as taught by CUDA official tutorials and tried calling it from haskell
11:52:40 <Cale> How are you writing the FFI?
11:52:58 <srhb> Is there even a CUDA FFI for Haskell? I don't know of one.
11:53:03 <Cale> GHC doesn't have built in FFI support for CUDA
11:53:13 <Cale> So you'd need to be compiling it to a C library somehow first.
11:53:21 <Cale> Or something
11:53:30 <Cale> I don't really understand what it is that you're doing.
11:55:38 <merijn> srhb: You can't FFI to CUDA in any language
11:55:46 <srhb> merijn: I didn't know that.
11:55:48 <merijn> srhb: You call C functions that run CUDA code on the gpu
11:55:48 <SrPx> hmm I see. I have no idea how to do it, so... okay, thanks
11:55:51 <srhb> But it's not surprising.
11:56:04 <supki> ew0000: Have you tried Data.Semigroup.Generic from semigroups? Looks like it can generate Semigroup/Monoid instances for products
11:56:31 <supki> ew0000: https://hackage.haskell.org/package/semigroups-0.16.2.2/docs/Data-Semigroup-Generic.html
11:56:35 <SrPx> but answering, what I did was add an 'external "C"' annotation to my CUDA functions and compile the haskell file with "ghc test.hs -o test hello.o -L/usr/local/cuda/lib -optl-lcudart"
11:56:46 <SrPx> I will try the mapped memory path now, thanks :)
11:57:07 <Cale> I don't understand how that could possibly work. :S
11:57:34 <Cale> SrPx: Maybe just try using the existing cuda package?
11:57:52 <merijn> Cale: Why not? It's just FFI C functions
11:58:03 <SrPx> Cale: I've spent some minutes looking through it but I have no idea how to use it :( I'm not even sure it is for the same purpose
11:59:03 <Cale> merijn: Er, maybe I misunderstand what SrPx is describing
11:59:05 <SrPx> I mean, it is right on the package description " This is a collection of bindings to allow you to call and control, although not write, such functions from Haskell-land."
11:59:52 <SrPx> tl;dr nobody has any idea how to make this work :P 
11:59:54 <geekosaur> you can't FFI to CUDA itself but you can FFI to the C functions that load CUDA programs into and launch the GPU 
12:00:03 <geekosaur> but you may need a bound FFI thread
12:00:27 <geekosaur> I don't know enough about CUDA. what I do know is that everyone who's looked at it is horrified by the implementation >.>
12:00:31 <merijn> geekosaur: Shouldn't be necessary, CUDA is threadsafe
12:00:40 <geekosaur> so probably assume it's as dirty and unsafe as it gets
12:01:12 <merijn> geekosaur: How long ago was that? CUDA has been pretty slick for some time now and it's only getting slicker
12:01:32 <geekosaur> for perhaps some values of "slick"
12:02:05 <merijn> I'm sure the innards are gross, but things are pretty well documented and working as expected
12:02:07 <Cale> https://github.com/tmcdonell/cuda/tree/master/examples/src/matrixMul
12:02:14 <Cale> There are some examples in that directory
12:02:48 <merijn> Cale: That example is pretty outdated
12:03:02 <merijn> First line I look at is using a long deprecated API
12:03:37 <Cale> Line of what?
12:03:45 <Cale> The CUDA code, or the Haskell code?
12:03:48 <merijn> Cale: First line of the example HS code
12:03:55 <merijn> Although the one on hackage seems up to date
12:04:42 <Cale> Ah, hmm
12:09:36 <SrPx> geekosaur: I'm not sure what you mean... 
12:09:41 <SrPx> :( 
12:10:04 <MitchellSalad> hi, I'm trying to build/test Cabal from source by following the directions here https://github.com/haskell/cabal/blob/master/HACKING.md... I'm getting a bunch of test failures due to "at least the following dependencies are missing: old-time -any"
12:10:12 <MitchellSalad> anyone know how to fix this?
12:12:42 <geekosaur> sounds like the tests should be updated... but it means what it says, install the old-time package in the sandbox (Setup cannot)
12:12:55 <geekosaur> http://hackage.haskell.org/package/old-time
12:14:20 <MitchellSalad> hm, it's already in there
12:14:34 <MitchellSalad> > ls .cabal-sandbox/x86_64-linux-ghc-7.10.1-packages.conf.d | grep old-time 
12:14:34 <MitchellSalad> old-time-1.1.0.3-c6c471a5ec61ff049468f265b077486d.conf
12:14:36 <lambdabot>  <hint>:1:59: parse error on input ‘|’
12:16:03 <Denommus> MitchellSalad: why are you trying to evaluate shell with a ghc interpreter?
12:16:24 <MitchellSalad> accident, that was supposed to be my shell prompt
12:16:49 <MitchellSalad> I'm just showing that I have old-time installed
12:17:07 <Denommus> ah, ok
12:17:39 <EvanR> olde thyme
12:19:56 <geekosaur> did you miss the step where you use cabal exec to extract the path to the sandbox's package library and then use it in --package-db
12:20:18 <MitchellSalad> nope :P
12:20:22 <geekosaur> (step 4 extracts it, used in step 5)
12:21:15 <MitchellSalad> I simply ran ./Setup configure --package-db=<tab-completed-my-package-db>
12:21:27 <MitchellSalad> with --enable-tests too, sorry :P
12:22:28 <geekosaur> that could do it
12:22:40 <geekosaur> use an absolute path, not a relative one
12:22:53 <geekosaur> if anything changes current directory, your relative path will point to outer space
12:23:50 <geekosaur> (for example, tests are usually in a subdirectory....)
12:24:11 <MitchellSalad> ok, I'm an idiot, the absolute path worked. thank you!
12:24:38 <MitchellSalad> the readme probably shouldn't say "or, as a relative path" though :P
12:25:07 <geekosaur> possibly something changed since that was written
12:25:16 <MitchellSalad> oops, I was looking at the wrong shell, the absolute path actually didn't work
12:25:23 <geekosaur> as a general rule I don't trust relative directories for package databases
12:25:24 <MitchellSalad> same 9/47 tests failed with the missing dependency
12:31:06 <rien> is anyone aware of a group passionately trying to solve the software dependency problem?
12:31:51 <refefer> rien: as in dependency hell?
12:32:09 <rien> refefer: yes
12:32:27 <maerwald> dependency of what kind of software?
12:32:33 <rien> I'm not interested in actual mathematical solutions to the NP-complete problem of software dependency, just as it related to programmer convenience
12:33:06 * hackagebot aeson 0.9.0.0 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.9.0.0 (BryanOSullivan)
12:33:20 <rien> maerwald: any
12:33:25 <quchen> This recent talk about "how do haskellers think about laziness" got me thinking how much GHC's RULES pragma benefits from laziness. My gut tells me that it's a crucial prerequisite for having user-defined rewrite rules, but I can't formalize the thought.
12:33:32 <geekosaur> various people are working on the general problem, with things like SAT solvers
12:33:44 <maerwald> rien: they are very different from one another
12:34:16 <rien> maerwald: I'm interested in making it easier for programmers to focus on programming and not on package management, so anything that works towards that goal
12:34:38 <maerwald> rien: yes, pretty much any linux distro deals with that. It's especially hard for source distros
12:34:43 <rien> so that e.g. scientists can focus in their area of expertise and not worry about thing they're not interested in like package manaagement
12:34:57 <geekosaur> the specific problem is complicated by things like ghc exposing parts of library internals for cross-module inlining, which makes binary dependencies very much stricter than they are in other implementations
12:35:44 <geekosaur> including other Haskell compilers such as jhc, which takes a different approach to the problem [whole-program compilation, meaning every library is compiled anew for each program using it]
12:37:18 <rien> geekosaur: yes but I feel we need a new idea. I'm thinking of extreme programmer convenience. what if once a month a new linux image with all hackage packages versions frozen and guaranteed to work with each other is released?
12:37:35 <geekosaur> you know about stackage, right?
12:38:11 <rien> will stackage allow me to run import OpenGL on my macosx?
12:38:27 <geekosaur> if you're willing to let a web framework decide what versions you are allowed to use (I keep thinking about how well that worked for ruby, especially with puppet ditching it recently) it's probably great
12:38:45 <geekosaur> neither would a linux image
12:39:04 <refefer> I feel like development on macs succeeds despite OS X
12:39:05 <geekosaur> (I don;'t know if stackage would but I don't see much relationship between opengl and yesod...)
12:39:32 <maerwald> rien: https://people.debian.org/~dburrows/model.pdf
12:40:59 <rien> maerwald: what really gets me is when I visit a blog talking about some haskell code that I can't compile. we really need to fix that problem as a community. for every language. is one person ever compiled something then it should be compileable by anyone. so much work is lost or can't be picked up from where it was left because future programmers can't build it again.
12:41:06 <rien> it's the most frustrating problem in programming.
12:41:21 <maerwald> rien: but those are different problems, e.g. Haskell doesn't have a stable ABI
12:41:34 <maerwald> that's not such a big problem with C libraries
12:41:53 <maerwald> then: do we include configuration?
12:42:02 <geekosaur> rien, for starters forget about OS X. it is not linux, it will never be linux, and so much stuff is written for linux and good luck if you can make it work anywhere else...
12:42:38 * SrPx cries on the background
12:42:53 <geekosaur> also note that C is still wrestling with this, and pkg-config (which is C's version of ghc-pkg) has its own problems. and also is not a package manager, in the same way that cabal-install isn't
12:43:01 <maerwald> rien: build+runtime dependencies, build dependencies, runtime only dependencies, configuration of different build-time options per-package... ABI breakage of packages, when to rebuild? What happens with circular dependencies?....
12:43:07 * hackagebot aeson 0.9.0.1 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.9.0.1 (BryanOSullivan)
12:43:24 <maerwald> most of the time these things are solved in some linux package managers, sometimes not really well, but people don't write a lot of papers about these things
12:43:26 <maerwald> unfortunately
12:43:28 <rien> geekosaur: I think all languages are still wrestling with this
12:43:32 <nocturne777> I need to have a REST based back-end server. Is Snap the framework most haskellers use for this purpse?
12:43:32 <rien> I'm not picking on haskell
12:44:43 <maerwald> rien: and for different languages there sometimes have to be different solutions, e.g. distros sometimes have to treat ruby, perl, python, C, haskell packages somewhat differently
12:44:56 <maerwald> again: that applies especially to source distros
12:45:01 <maerwald> and using cabal is sort of that
12:45:08 <quchen> geekosaur: Cabal's main problem is that it's de facto a package manager that doesn't do things that a package manager does, because it's not one.
12:45:16 <ion> @tell kuribas I’d like to see the article when you publish your algorithm.
12:45:16 <lambdabot> Consider it noted.
12:45:31 <frerich> Does anybody have (or know of) some script which takes care of bumping the .cabal version nubmer/tagging in git/pushing to github/pushing to hackage?
12:45:58 <rien> maerwald: I know I have trouble conveying this idea, especially online. that's not the kind of solution I'm talking about. :)
12:46:28 <maerwald> then you have to be more specific. But if you look for solutions, you will end up examining package manager source code
12:46:32 <adrian_> hello, it's true that sometimes the haskell language is against the developer? i'm trying to learn this cool language but sometimes this is how I feel
12:47:10 <danclien> frerich: Maybe not quite what you're looking for, but have you looked at `bumper`? — https://hackage.haskell.org/package/bumper
12:47:14 <marchelzo_> adrian_: It's not perfect, if that's what you're asking.
12:47:23 <int-e> adrian_: sounds like any other programming language out there.
12:47:32 <marchelzo_> adrian_: It's not intentionally trying to make your job difficult, though.
12:47:42 <rien> maerwald: I'm saying I want to find the group of people trying to think of a solution to this beyond package managers. real function interfaces like Unix was trying to do but they stopped at one type: string
12:48:07 <geekosaur> ...
12:48:22 <adrian_> marchelo and int-e I know, I'm saying with deepest admiration but the paradigm of functional language is different from my mindset
12:48:35 <geekosaur> CORBA -> Bonobo and friends -> ??? they're still trying to solve *that* one too
12:48:36 <rien> right now the difference between executables and functions is grinding
12:48:44 <rien> there should be only functions
12:48:54 <geekosaur> that is, trying to make RPC work
12:49:14 <geekosaur> and the result of that failure iis things like REST which go right back to everything's a string
12:49:27 <rien> yes, what makes this problem so hard? I want to understand that. and I want to read the stuff that people researching in this area are writing
12:49:36 <rien> geekosaur: so you understand what I'm trying to say?
12:49:58 <rien> I think the symbolics genera machines were like that, where there were only functions, no opaque executables
12:50:13 <adrian_> marchelo and int-e and haskell is another level of understanding thing in dev world
12:50:17 <fishface> hello
12:50:19 <geekosaur> I know what you are reaching for, and what others have reached for and missed. but the folks in the GNOME project don't write research papers
12:50:22 <rien> it's the arrow that brings us from source code to executable that makes it all so hard
12:50:47 <int-e> adrian_: I find functional programming liberating most of the time.
12:51:15 <int-e> adrian_: but occasionally I want to have arrays and loops, and usually I switch to C then
12:51:19 <fishface> just wondering, when writing a data delcaration: data Vector a = Vector a a a deriving (Show)  , why is there just a single type on the LHS of the assignment operator?
12:51:38 <adrian_> marchelzo nothing is perfect after all, i'm not searching for that... only some thing to ease my pain :)
12:51:59 <rien> geekosaur: I think if we could eliminate the barrier of configuring and installing, we'd see a renaissance in programming. a lot more people would pick it up. if books came with the pages in random order, a lot less people would read them.
12:52:22 <geekosaur> fishface, because you only need one declaration, but it's used 3 times?
12:52:32 <geekosaur> sort of like: f(a) = a + a + a
12:52:34 <rien> you can see that in the popularity of Little Big Planet games by the community.
12:53:02 <geekosaur> the type Foo Int has a value Foo with 3 Int-s in it
12:53:03 <marchelzo_> adrian_: Just keep practicing. For some tasks, functional style seems less natural than imperative style, but if you practice you'll become more proficient.
12:53:16 <adrian_> int-e and marchelzo for instance yesod it's a framework that extend haskell, this is how I call it against the programmer :) again i'm not trying to flame
12:53:32 <geekosaur> and you are asserting that those three associated values are all the same single type
12:53:33 <MitchellSalad> thx anyways for the help geekosaur, I just filed a bug cause I still can't figure it out =)
12:53:45 <fishface> geekosaur: how should i read it. I believe I read it wrong "I declare a new data type of vector, with a parameter of type a. but then my constructor takes 3 a types."
12:54:02 <geekosaur> [25 15:52:40]  <geekosaur>	 the type Foo Int has a value Foo with 3 Int-s in it
12:54:16 <geekosaur> [25 15:53:10]  <geekosaur>	 and you are asserting that those three associated values are all the same single type
12:54:47 <geekosaur> a different type which has 3 associated valuers but doesn
12:55:01 <geekosaur> t require their types to be the same would be data Bar a b c = Bar a b c
12:55:20 <fishface> geekosaur, so (contrived), my data type contains 2 different types,say data myDataType a Int = myDataType a Int a a, is that ok?
12:55:21 <geekosaur> also note that the Bar on each side is different: the one on the left is a type, the one on the right is a value
12:55:28 <fishface> would that be valid?
12:55:32 <MitchellSalad> not quite
12:55:33 <geekosaur> no
12:55:41 <geekosaur> Int does not need to  be a parameter on the left
12:55:57 <fishface> so myDataType a = myDataType a Int a a
12:56:00 <geekosaur> think of this as being a "function", in the space of types
12:56:04 <MitchellSalad> on the LHS is the type constructor, which is parameterized by zero or more type variables
12:56:20 <MitchellSalad> on the RHS are zero or more data constructor alternatives which may mention the type variables from the lhs
12:56:21 <geekosaur> data MyType a = AConstructor a Int String a
12:56:22 <ReinH> fishface: type and data constructors need to begin with capital letters.
12:56:55 <fishface> ReinH: you're right , thanks
12:57:10 <geekosaur> MyType is a type function, you apply it to a type and it produces a new type. so (MyType Int) is a type, and values of this type look like AConstructor anInt anInt aString anInt
12:59:32 <geekosaur> note also that it doesn't necessarily have to use the type parameter(s) directly in values, but they are still part of the type
12:59:40 <geekosaur> data Maybe a = Nothing | Just a
12:59:51 <arkeet> data Proxy a = Proxy
13:00:01 <geekosaur> `Nothing` still has the type (Maybe a) for some a
13:00:12 <arkeet> (or for every a)
13:00:16 <adrian_> adrian
13:00:37 <adrian_> thanks guys for all the encouragements
13:00:40 <geekosaur> so Nothing :: Maybe Int cannot be used in a context wanting a Maybe String (this annoys folks who try to reuse the Nothing in a function)
13:02:10 <fishface> geekosaur: starting to grok it, but you said "Int does not need to  be a parameter on the left" - why not? why shouldn't i specify it
13:02:26 <geekosaur> data Maybe Int = ...
13:02:28 <geekosaur> is pointless
13:02:44 <geekosaur> you know it will always be Int so there is no reason to specify it as a parameter
13:02:51 <kurt21> Can someone explain this syntax to me: class HAppend l l’ l’’ | l l’ -> l’’ 
13:02:59 <arkeet> that's a functional dependency
13:03:13 <kurt21> ok, thanks, I will google that
13:03:19 <geekosaur> kurt21, it means that if the compiler knows the types l and l' then it can assume that l'' is some single specific type
13:03:26 <fishface> geekosaur: ahh, it's pretty much like class templates. 
13:03:27 <geekosaur> even if it does not know what that type is at the time
13:03:27 <kurt21> ah, thanks :)
13:03:43 <kurt21> you guys are fast!
13:03:52 <geekosaur> otherwise it would have to ask you to annotate uses of typeclass functions with explicit types so it would know which instance to use
13:04:23 <arkeet> https://wiki.haskell.org/Functional_dependencies
13:04:53 <fishface> geekosaur: i think i got it. thanks alot :)
13:04:54 <kurt21> makes sense. thanks. haskell has a lot of features to learn :)
13:05:17 <fishface> MitchellSalad: thanks aswell :)
13:05:18 <geekosaur> fishface, and with this kind of data declaration there is no point in doing things that look like overloading (foo Int = ... ; foo String = ...)
13:05:35 <geekosaur> but there is a slightly different one enabled by an extension that *does* let you do something like that (GADTs)
13:06:04 <MitchellSalad> fishface: no problem
13:08:08 * hackagebot waddle 0.1.0.4 - DOOM WAD file utilities.  http://hackage.haskell.org/package/waddle-0.1.0.4 (MartinGrabmueller)
13:16:37 <athan> Lambdabot doesn't support parsec :\
13:18:46 <SrPx> What is the haskell equivalent of "shmget" and "shmat" ?
13:19:41 <athan> SrPx: shm?
13:20:03 <SrPx> yes
13:20:04 <SrPx> (?)
13:20:09 <athan> SrPx: Hmm, maybe storable? Are you trying to do ffi stuff?
13:20:15 <athan> or inspection of ram?
13:20:30 <SrPx> I'm trying to read memory from another program.
13:20:33 <SrPx> yes
13:20:53 <athan> SrPx: I haven't done anything like this, but I know there's storable... one sec
13:21:10 <SrPx> okay :)
13:21:28 <athan> SrPx: Can I ask why you explicitly want to see the ram?
13:21:33 <athan> shared memory ffi, right?
13:21:48 <geekosaur> I'm not aware of any FFI bindings for System V IPC
13:21:59 <SrPx> Yes, I want to read the result of rendering my images using the CUDA renderer that I didn't manage to call from haskell with FFI
13:22:00 <geekosaur> there are some bindings for BSD-style (mmap)
13:22:35 <athan> SrPx: https://wiki.haskell.org/FFI_cook_book ?
13:22:49 <athan> hmm
13:26:13 <SrPx> okay thanks
13:36:17 <darrenh> is it usual practice for modules not to re-export the types from modules their public API depends on? Or should I expect to be able to depend only on the package itself in my cabal file?
13:41:01 <quchen> I don't think there's a usual practice. I personally like to ensure each package exports everything required to use it, but this is such a fuzzy requirement it's hard to put it into a proper rule.
13:43:09 * hackagebot users-persistent 0.3.0.0 - A persistent backend for the users package  http://hackage.haskell.org/package/users-persistent-0.3.0.0 (AlexanderThiemann)
13:47:55 <is7s> What's the most standsr heaps/priority queue library used in the Haskell community?
13:48:03 <is7s> standard*
13:49:05 <refefer> heaps is common
13:51:06 <sleblanc> What does the 't' mean in the type of an empty list?
13:51:09 <sleblanc> > :t []
13:51:11 <lambdabot>  <hint>:1:1: parse error on input ‘:’
13:51:13 <is7s> refefer: is it the one most widely used?
13:51:23 <sleblanc> :t []
13:51:24 <lambdabot> [t]
13:52:05 <refefer> sleblanc: forall. t, [t]
13:52:09 <jle`> sleblanc: it's a type variable, it can be anything
13:52:22 <refefer> is7s: I don't know if it's the most used, but it's widely used
13:52:24 <jle`> meaning it can be an [Int], or a [Bool], or a [String], etc.
13:52:26 <refefer> does it really matter?
13:52:50 <jle`> is7s: ther'es psqueue, i think a lot of people use it
13:52:53 <jle`> i hvae used it myself in the past
13:53:36 <sleblanc> jle`, thanks. Why 't'? In some other places :t uses a and b, am I not seeing the difference?
13:53:40 <fizruk> hey guys! is scanl for Traversable defined somewhere already? http://lpaste.net/133329
13:53:51 <jle`> is7s: i don't think there's a general consensus :)  but i've heard people recommending it too here and there 
13:53:58 <jle`> sleblanc: it's really arbitrary
13:54:18 <jle`> a lot of times ghc tries to guess the letter you want by the type signatures you give
13:54:18 <quchen> :t [] :: [hello_sleblanc]
13:54:20 <lambdabot> [hello_sleblanc]
13:54:21 <is7s> jle`: I see
13:54:28 <jle`> fizruk: that's not scanl :o
13:54:45 <jle`> and that's probably the reason why
13:54:54 <jle`> scanl as Data.List has it is impossible to implement with Traversable
13:54:56 <is7s> Would be nice if there are some benchmarks between the different libraries
13:55:14 <sleblanc> I see, thanks for the insight
13:55:16 <jle`> it's a bit unfortunate, as scanl could have clearly been chosen historically to be something that could be written
13:55:17 <jle`> oh well
13:56:22 <fizruk> jle`: well, perhaps I meant something which is like scanl but isn't
13:56:29 <jle`> ah
13:56:32 <refefer> is7s: if performance is absolutely critical, you'll probably want a more obscure one that's using mutation
13:56:56 <refefer> but I'd be willing to bet that most of the used heaps are absolutely fine
13:57:10 <fizruk> jle`: well, I don't need it to be lazy if that's what you were pointing at
13:57:19 <is7s> refefer: Is there one available?
13:57:29 <jle`> fizruk: it's the items in the output list
13:57:41 <jle`> the result of scanl is one item longer than the input list
13:57:55 <jle`> Traversable can't change the "size" of the container
13:58:03 <refefer> is7s: probably, haven't looked.  heaps have never been my bottleneck
13:58:23 <fizruk> jle`: oh, I always forget that
13:58:43 <refefer> is7s: what are you writing where you think that'll be the concern?
13:58:54 <quchen> jle`: `size` is pretty well defined for Traversable via its Foldable superclass, no?
13:59:06 <fizruk> jle`: nonetheless, looks like something that could be somewhere already
13:59:08 <jle`> oh yeah, i guess you're right
13:59:51 <is7s> refefer: Nothing specific. Just wanted to know the most standard and efficient library.
14:00:32 <jle`> @let data TestType1 a = TT1
14:00:34 <lambdabot>  Defined.
14:00:37 <jle`> :t TT1
14:00:39 <lambdabot> forall (k :: BOX) (a :: k). TestType1 a
14:00:42 <is7s> refefer: I'll probably want to use it for some problem solving
14:00:45 <jle`> @let data TestType2 t = TT2
14:00:47 <lambdabot>  Defined.
14:00:50 <jle`> :t TT2
14:00:54 <lambdabot> forall (k :: BOX) (t :: k). TestType2 t
14:00:57 <refefer> is7s: some unsolicited advice: they're all roughly nlogn.  benchmark it later after the rest is written
14:01:07 <refefer> generally, you'll fight more with thunk control than those types of libraries
14:01:12 <jle`> ^^ sleblanc  ; ignore the forall/box/kind signature stuff, heh
14:04:54 <neuroserpens> :t map (read :: String -> Int)
14:04:55 <lambdabot> [String] -> [Int]
14:12:24 <SrPx> j/j c
14:12:28 <SrPx> woops 
14:14:00 <hpc> Error: divide by j
14:16:28 <geekosaur> > (1 :+ 1) / (0 :+ 1)
14:16:31 <lambdabot>  1.0 :+ (-1.0)
14:16:57 <geekosaur> > (0 :+ 1) / (0 :+ 1)
14:16:59 <lambdabot>  1.0 :+ 0.0
14:17:03 <geekosaur> still no error :p
14:17:18 <Pamelloes> Is there a way to export only a few functions from another module?
14:17:35 <geekosaur> module Foo (exports here) where
14:18:43 <Pamelloes> Sorry for not being clear, I meant re export in a module only some functions from another module. So if module A exports func1 and func2, can module B export just func1 of module A?
14:18:57 <arkeet> yes
14:19:21 <bergmark> Pamelloes: yes, by either listing func1 explicitly or doing module B (module A) where import A (func1)
14:19:22 <geekosaur> it's in your namespace after importing it, so just list it as an export
14:19:30 <arkeet> just put func1 int he export list
14:19:31 <arkeet> or that
14:19:47 <Pamelloes> Ah, that makes sense :)
14:20:35 <sleblanc> Pamelloes, I have seen modules that were nothing more than module Name (a, b, c) where import Name.Internal(a, b, c)
14:20:45 <Pamelloes> What if I have A import qualified as A, would I then export A.func1 instead of func1?
14:21:22 <geekosaur> yes
14:21:29 <Pamelloes> Thanks :)
14:21:48 <geekosaur> note that in all cases whoever imports it sees it as being from your module, regardless of what qualification you have for it in your module
14:22:13 <Pamelloes> That's my goal
14:22:21 <geekosaur> (that is, if you module B (A.func1) where..., importers of B do not see A.func1, just func1
14:22:24 <geekosaur> )
14:22:37 <geekosaur> (or if qualified it would be B.func1 not A.func1)
14:27:47 <quchen> So I just read a bit in Okasaki's paper on priority queues and it seems he's breaking at least a couple of laws of nature.
14:27:52 <quchen> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.48.973&rep=rep1&type=pdf
14:28:11 * hackagebot aeson-utils 0.3.0.2 - Utilities for working with Aeson.  http://hackage.haskell.org/package/aeson-utils-0.3.0.2 (AdamBergmark)
14:28:13 * hackagebot generic-aeson 0.2.0.6 - Derivation of Aeson instances using GHC generics.  http://hackage.haskell.org/package/generic-aeson-0.2.0.6 (AdamBergmark)
14:28:28 <quchen> At first I thought edwardk's claim of O(n) fromList (to heap) was a typo. :-D
14:28:55 <monochrom> interesting. a priority queue faster than light
14:29:41 <quchen> monochrom: Not a problem if you weaken your requirements on mass a bit.
14:30:31 <monochrom> actually in the imperative world "build heap from arbitrary array" is O(n) too, so perhaps it is not faster than light
14:31:16 <merijn> heaps have O(1) insert, no? So you just do n inserts for every element of the list...
14:31:48 <yqt> hi, i installed some packages in a cabal sandbox and i'm trying to run a test using those by ghc -package-db $path/.cabal-sandbox/x86_64-windows-ghc-7.8.3-packages.conf.d, but ghc responds it can't find a pkg db there. what am i getting wrong? my conf.d dir is structured like the global pkg dir and cabal seems to run ok
14:31:53 <quchen> Wait, I think I just mixed something up badly.
14:32:40 <monochrom> heaps have log(n) insert. read_max is the O(1) one (if max-heap)
14:33:06 <quchen> Right, that's what I remembered.
14:33:11 * hackagebot json-schema 0.7.3.6 - Types and type classes for defining JSON schemas.  http://hackage.haskell.org/package/json-schema-0.7.3.6 (AdamBergmark)
14:33:42 <SrPx> Since there are only two files on the history of haskell using shmOpen ( https://www.google.com.br/?gfe_rd=cr&ei=BpVjVY-_FoOC8QemroCYDQ&gws_rd=ssl#safe=off&q=filetype:hs+shmopen )
14:33:45 <merijn> monochrom: oh, yeah, I'm confused
14:34:05 <SrPx> Could someone tell me how can I read the value stored on the opened memory as a string?
14:34:23 <merijn> yqt: USe "cabal run" to run programs in the sandbox
14:34:27 <monochrom> but if you're doing fromList or fromArray, you do not use the vanilla insert n times. you do something more clever, and that will be O(n) rather than n log n.
14:34:33 <merijn> yqt: "cabal run ghc -package-db"
14:34:36 <SrPx> On the C examples it uses "mmap", but Haskell's "mmap" needs a file path whereas the C one doesn't. The example is: "mmap(0, sizeof(*addr), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0)"
14:34:45 <monochrom> CLRS has all the details :)
14:34:52 <merijn> SrPx: C does need a file, just indirectly
14:34:59 <merijn> SrPx: 'fd' is a file descriptor
14:35:10 <merijn> So you need to open a file (using a path) somewhere
14:36:46 <yqt> merijn, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/packages.html says i should be able to use packages from various sources with the -package-db flag. as far as i understood it cabal run would just supply an appropriate env var to the cmd with the dir (the same i would pass throuhg -package-db). did i misunderstood anything?
14:37:38 <yqt> *cabal exec, isn't it?
14:38:04 <SrPx> merijn: so, in c side, it is "addr = mmap(0, sizeof(*addr), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0)"... on haskell side, I have mmapFilePtr :: FilePath -> Mode -> Maybe (Int64, Int) -> IO (Ptr a, Int, Int, Int)
14:38:11 * hackagebot rest-stringmap 0.2.0.5 - Maps with stringy keys that can be transcoded to JSON and XML.  http://hackage.haskell.org/package/rest-stringmap-0.2.0.5 (AdamBergmark)
14:38:13 * hackagebot rest-gen 0.17.0.5 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.17.0.5 (AdamBergmark)
14:38:15 * hackagebot rest-core 0.36.0.2 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.36.0.2 (AdamBergmark)
14:38:17 * hackagebot rest-types 1.14.0.1 - Silk Rest Framework Types  http://hackage.haskell.org/package/rest-types-1.14.0.1 (AdamBergmark)
14:38:19 * hackagebot Win32-services 0.3 - Windows service applications  http://hackage.haskell.org/package/Win32-services-0.3 (MichaelSteele)
14:39:13 <merijn> yqt: cabal exec is for running contents of the package (i.e. lookup the binary in the sandbox)
14:39:20 <vandenoever> is there an accepted method of avoiding repeating the function name on subsequent lines?
14:39:29 <merijn> yqt: "cabal run" is for running, ghc/ghci, etc. with the right parameters to find the sandbox
14:39:45 <merijn> vandenoever: Use guards/case
14:39:51 <yqt> excuse me merijn but from the cabal doc i guess the converse is the case
14:40:08 <arkeet> merijn: yeah those are backwards :p
14:40:14 <vandenoever> merijn: but that gives me less type checking, right?
14:40:15 <yqt> run            Builds and runs an executable.
14:40:15 <yqt>   exec           Give a command access to the sandbox package repository.
14:40:18 <merijn> hmmm
14:40:31 <merijn> I blame the person who listened to me earlier today and said that "cabal run" worked :p
14:40:44 <quchen> vandenoever: Example code?
14:40:44 <merijn> vandenoever: Why would that give you less type checking?
14:40:51 <yqt> anyway, i would liked to know what the problems is with the direct ghc flag, as i'm just trying to test and understand what's going on
14:40:58 <quchen> merijn: I think he meant exhautiveness checking.
14:41:08 <monochrom> there are probably a million varying factors between then and now
14:41:26 <vandenoever> http://lpaste.net/133331
14:41:34 <monochrom> few programmers understand the concept of "controlled experiments"
14:41:43 <vandenoever> can i avoid to repeat 'dom2spanchild'?
14:42:06 <Fylwind> what is the difference between forkIOWithUnmask and just forkIO with an unmask function from the parent thread?
14:42:33 <quchen> vandenoever: You can use `case` to do this http://lpaste.net/133332
14:42:48 <yqt> shouldn't ghc -package-db $dir just behave as "oh yeah i found your package" instead of "can't find a package db"? :P
14:42:51 <quchen> vandenoever: Scales especially well when your function has multiple arguments that you all want to share
14:43:09 <merijn> Fylwind: If the parent function was running a mask inside a mask than the inner mask's restore (that you pass to the child) won't actually unmask
14:43:25 <merijn> Fylwind: Whereas with forkIOWithUnmask the unmask sure to work
14:44:01 <vandenoever> quchen: nice! is there some way to merge the two 'D.Element qname _ cs) ' parts to avoid repetition?
14:44:08 <Fylwind> merijn: oh I see, so it's a problem with nested masks
14:44:22 <merijn> Fylwind: Yeah
14:44:31 <frerich> vandenoever: You could use a plain 'if' for the last two lines.
14:44:40 <quchen> vandenoever: `otherwise` http://lpaste.net/133334
14:45:13 <quchen> vandenoever: LambdaCase would make this a bit prettier even.
14:45:19 <vandenoever> quchen, frerich: thanks for the pointers!
14:45:21 <quchen> dom2spanchild = \case …
14:45:38 <frerich> vandenoever: Good to see more KDE people tinkering with Haskell. ;-)
14:45:56 <quchen> Good to see more people tinkering with Haskell!
14:46:06 <vandenoever> frerich: lambda is coming ;-)
14:48:04 <vandenoever> quchen: the LambdaCase is a nice reduction indeed
14:49:37 <vandenoever> 'case of' probably also has pretty good completeness checks
14:50:11 <quchen> vandenoever: Pattern matching at the top level is desugared to case expressions internally
14:50:40 <monochrom> yes, the same "inexhaustive" warning applies to both "f [] = x; f (y:ys) = z" and "case"
14:50:45 <vandenoever> quchen: ah, good to know
14:50:56 <vandenoever> quchen: and guards?
14:51:03 <monochrom> yes too
14:51:05 <quchen> vandenoever: In fact, *all* pattern matching is converted to `case`
14:52:08 <vandenoever> but for guards it hard to know if it's inexhaustive
14:52:26 <monochrom> right. just "yes" to "desugars"
14:52:57 <quchen> vandenoever: Guards cannot be checked for exhaustiveness.
14:53:03 <SrPx> merijn: put it here if it makes more clear http://lpaste.net/133336
14:53:06 <SrPx> thanks :)
14:53:10 <monochrom> "f x | x>0 = ()" --> "f y = case y of x | x>0 -> ()"
14:53:20 <quchen> vandenoever: Not because Haskell in particular can't, but because it's an uncomputable problem.
14:53:46 <quchen> vandenoever: f | riemannHypothesisHolds = … -- Is this exhaustive?
14:54:00 <vandenoever> quchen: exactly what i thought, nice to have it confirmed, so good practice is to have guards followed by a 'otherwise'
14:54:29 <vandenoever> there's probably a lint function for that
14:54:51 <quchen> vandenoever: Patterns allow structural matching, while guards allow computing arbitrary boolean values. And as we all know, there are three values of type Bool: True, False, and Dammit.
14:55:20 <quchen> Dammit it better known as ⊥, bottom, non-termination, no answer and what have you.
14:55:25 <quchen> Basically "computer says no".
14:55:36 <monochrom> no no, "computer doesn't know"
14:55:40 <vandenoever> eh, sounds quantum
14:55:54 <monochrom> if computer knew "no", it would say "False"
14:56:08 <vandenoever> can we collapse the wave function please ;-)
14:56:44 <quchen> monochrom: I was trying not to write about your computer heavily insulting you, so I chose my wording hastily
14:56:55 <monochrom> the Riemann hypothesis may yet be outside uncomputability
14:57:25 <frerich> vandenoever: It's not so quantum really, consider e.g. 'f | f = True | otherwise = False'.
14:57:32 <vandenoever> btw by 'wave function' i dont mean the monarchy
14:57:35 <frerich> vandenoever: The '| f' thing is the 'dammit'.
14:58:12 * hackagebot Tainted 0.0.1 - Tainted type, and associated operations  http://hackage.haskell.org/package/Tainted-0.0.1 (RossMeikleham)
14:58:39 <vandenoever> frerich: but that's complete
14:59:03 <quchen> f | f = False -- how about this one
14:59:23 <vandenoever> yeah that leaves f = True or 'otherwise'
14:59:26 <frerich> vandenoever: but it doesn't help because dammit!
14:59:31 <frerich> :-)
14:59:58 <vandenoever> i still dont feel the dammit, but i know that guards can leave opening
15:00:00 <vandenoever> s
15:00:44 <vandenoever> now i can make my code more readable with case of, great :-)
15:01:28 <albeit_> I've read places that MVar/Chan are faster than TMVar/TChan - STM provides more generality at the expense of performance. Is that true? What makes STM slower?
15:03:12 * hackagebot fay 0.23.1.5 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.23.1.5 (AdamBergmark)
15:04:00 <quchen> There's more to the difference between MVar and TMVars (or normal concurrency vs STM). Normal concurrency has a notion of fairness ("every computation gets a chance to terminate"), STM does not ("nope, retrying you again because one of the dependencies changed").
15:04:18 <monochrom> vandenoever: they are trying the classical Cantor diagonalization argument. if f is True, then f is False. but if f is False, then f is True.
15:04:21 <quchen> STM has to do more bookkeeping in order to detect whether dependencies have changed.
15:04:37 <quchen> And probably a lot more that Marlow explains much better in his book than I possibly could.
15:05:01 <quchen> Free to read online: http://chimera.labs.oreilly.com/books/1230000000929
15:05:32 <albeit_> quchen: Oh great, I'll give that a read, thanks
15:11:30 <merijn> albeit_, quchen: Also, because transactions can influence eachother in complex ways a change in a TVar will wake up all threads blocked on it
15:11:47 <merijn> As opposed to MVars which only wake up a single thread, thus avoiding thundering herd problems
15:12:11 <quchen> merijn: thundering herd?
15:12:13 <quchen> Eh
15:12:15 <quchen> Wait
15:12:26 <quchen> You mentioned it. I wanted to mention the term first because it's so cool. :-(
15:13:55 <merijn> :p
15:15:38 <joneshf-laptop> you know
15:15:57 <joneshf-laptop> the use of duck typing seems to be skew to the use of polymorphism and constraints
15:16:15 <joneshf-laptop> like, people suggest to generalize functions so you can reason more esily about them
15:16:42 <joneshf-laptop> instead of `Int -> Bool -> Int`, give a `Num a => a -> Bool -> a` or something
15:17:01 <joneshf-laptop> and it makes the functions more reusable
15:17:28 <joneshf-laptop> you're more constrained in what you can do inside the class, so youhave less chance to mess up, etc
15:17:40 <joneshf-laptop> well with ducktyping it's very similar
15:17:50 <joneshf-laptop> if you program to an interface you can only do so much
15:18:01 <rhaps0dy> Two questions!
15:18:09 <joneshf-laptop> and you constrain yourself based on that interface
15:18:20 <vandenoever> quchen: i've a marlow hardcopy next to me :-)
15:18:31 --- mode: ChanServ set +o mauke
15:18:31 --- mode: mauke set -b *!*@208.Red-2-138-160.dynamicIP.rima-tde.net
15:18:34 <rhaps0dy> Is there a handy library for packing and unpacking binary arrays containing ints, floats, etc ?
15:18:35 <rhaps0dy> and, 
15:18:37 <joneshf-laptop> of course, usually the duck typing also gives you dynamic typing 
15:18:55 <joneshf-laptop> so that's not so great
15:19:10 <joneshf-laptop> but i think there's more in common than different
15:19:19 <merijn> rhaps0dy: binary
15:19:19 <rhaps0dy> just solved the second hue nvm
15:19:31 <srhb> rhaps0dy: Not exactly sure what you're referring to with binary arrays, but the Get monad is pretty nice for dealing with arbitrarily packed binary data.
15:19:33 <merijn> @hackage binary
15:19:33 <lambdabot> http://hackage.haskell.org/package/binary
15:19:33 <rhaps0dy> merijn: <3
15:19:35 <srhb> Yeah, that.
15:19:45 <rhaps0dy> srhb: exactly what merijn said is waht I meant :)
15:20:03 <merijn> rhaps0dy: Note that using the Binary class will insert library specific junk into the data
15:20:25 <merijn> rhaps0dy: If you want to interact with an existing format use explicit Get/Put from Data.Binary.Get and Data.Binary.Put
15:20:31 --- mode: mauke set -o mauke
15:20:49 <rhaps0dy> thank you!
15:20:55 <rhaps0dy> yes, I gotta interact with an existing format
15:21:34 <srhb> rhaps0dy: I used it to interact with some ancient Matlab format a few years ago. It was relatively painless. And the pain wasn't due to the binary package for sure. :-)
15:22:24 <rhaps0dy> haha
15:22:33 <rhaps0dy> thanks for the ultra-quick help guys and/or gals!
15:24:09 <phaazon> my god
15:24:14 <phaazon> indexed monads are brilliant
15:24:19 <phaazon> especially with RebindableSyntax
15:25:11 <joneshf-laptop> it kind of feels a bit like type classes are static duck typing, if you want to take the duck typing perspective.
15:29:00 <prsteele-> syntax for class constraints on type declarations? e.g. type F a b = a -> b, where we have Show a ?
15:29:09 <prsteele-> or does this require RankNTypes?
15:32:35 <merijn> prsteele-: Requires RankN *and* won't work in a lot of places you want it too
15:32:52 <prsteele-> hm.
15:33:38 <merijn> prsteele-: So you're better of using "Show a => F a b" instead of trying "type F a b = Show a => a -> b" because that will seem to work, but then it suddenly complains about that syntax and you have to restructure everything :\
15:34:09 <merijn> prsteele-: I think it only works if "F a b" is the entire signature, i.e. "Int -> F a b" will fail
15:34:29 <prsteele-> merijn: okay, thanks.
15:34:49 <merijn> prsteele-: But you can always try and make sure, because it's 00:30 and I'm forgetful :p
15:34:56 <merijn> Now it's bedtime, though
15:35:03 <prsteele-> heh, will do
15:46:29 <Pamelloes> Can any type of kind *->* be expressed as (f a) in a type signature?
15:47:54 <athan> Pamelloes: you mean if `f :: * -> * -> *`?
15:48:24 <athan> You may be able to get away with context unification, too
15:48:56 <athan> Something like `(f ~ g a) => f b -> g a b`
15:49:10 <Pamelloes> athan: No, f :: * -> *
15:49:25 <athan> Pamelloes: And you're trying to decide `f` when it's fully applied?
15:49:29 <Pamelloes> Basically, can (f a) be used to refer to any type of the form MyType a?
15:49:38 <Pamelloes> athan: yes
15:50:11 <athan> Pamelloes: Well, if `f` is a variable, then the type signature would be generic for types with kind `*->*`
15:50:39 <athan> so `id' :: forall f. f a -> f a` would be a case where it works for all `f`
15:51:01 <athan> if you use typeclasses for adhoc-ness, then you can do fmap this way :)
15:51:09 <athan> :t fmap
15:51:10 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:51:29 <athan> Pamelloes: Or are you talking about typeclasses / constraints?
15:51:48 <Pamelloes> I think I'm talking about typeclasses/constraints
15:52:08 <athan> Pamelloes: You definitely can with -XFlexibleContexts & FlexibleInstances :)
15:52:19 <Pamelloes> Alright
15:52:21 <athan> try them out, and the compiler will tell you if you need it
15:52:28 <athan> you could say somehing like
15:53:20 <athan> `foo :: (HasResult (f a)) => f a -> r`
15:53:25 <athan> derp
15:53:29 <athan> HasResult (f a) r
15:53:48 <Pamelloes> interesting.
15:53:54 <athan> Pamelloes: Choosing instances for type variables is entirely different from the kind system
15:54:12 <athan> or really, describing possible instances*
15:54:30 <Pamelloes> Well, in that case f has to be of kind *->*, correct?
15:54:36 <athan> kinds will rigidly show what structure type variables can have, but with constraints you're free to coerce them however you want
15:55:08 <kurt21> what is the last symbol in hZero :: HZero; hZero = ⊥ 
15:55:12 <lpaste> ClaudiusMaximus annotated “indexed monad for GL state machine” with “an over-engineered triangle” at http://lpaste.net/133314#a133342
15:55:19 <Pamelloes> kurt21: Bottom
15:55:21 <kurt21> how should I type that in?
15:55:24 <ClaudiusMaximus> phaazon: ^^
15:55:29 <athan> kurt21: undefined
15:55:34 <athan> :t undefined
15:55:36 <lambdabot> t
15:55:42 <athan> Something blew my mind again the other day
15:55:44 <athan> :t flip id
15:55:46 <lambdabot> b -> (b -> c) -> c
15:56:05 <athan> where between each function application, `id` is snuck in or something :S
15:56:46 <mauke> flip f x y = f y x; so flip id = \x y -> id y x
15:58:00 <athan> mauke: ><
15:58:31 <athan> I keep forgetting that type varaibles can represent functions, too, not just discrete uncurried structures
15:58:38 <athan> mauke: Thank you :)
15:58:59 <mauke> (->) as a type is no different than Either
15:59:12 <mauke> if you can have Either X Y, you can also have (->) X Y
15:59:15 <athan> mauke: I know!! I just... keep forgetting :P
15:59:46 <athan> When I see `flip id`, I think - take the first two arguments of `a -> a` and swap them
16:00:02 <athan> ...which, incidently, induces a ~ b -> c
16:00:57 <Pamelloes> Is there any way to define a type data MyType a (f b) = ...?
16:01:10 <athan> Pamelloes: Nope!
16:01:20 <Pamelloes> Damn...
16:01:24 <athan> you could use type families in the type siguare at use sites, tohugh
16:01:36 <mauke> Pamelloes: what would that do?
16:01:57 <athan> Pamelloes: `data Foo a b where...` == `\a b ->...`
16:02:18 <kurt21> wait. how do I enter this: hZero :: HZero; hZero = ⊥ 
16:02:30 <kurt21> I can't paste that bottom symbol
16:02:35 <geekosaur> wouldn't work anyway
16:02:36 <Hijiri> put "undefined" for bottom
16:02:40 <Hijiri> or something like let a = a in a
16:02:48 <geekosaur> bottom is not a "thing" as such
16:02:48 <kurt21> won't "undefined" error when referenced?
16:02:52 <geekosaur> although bottoms are
16:02:59 <geekosaur> yes?
16:03:04 <geekosaur> that's the point?
16:03:18 <Pamelloes> mauke: Well I have a type Component t w and I want to make a type like Attr (f a) = .... such that Attr (Component t w) = ... would have the a in Attr be the w in Component.
16:03:21 <geekosaur> what do you believe ⊥ is?
16:03:24 <Cale> kurt21: An error is a kind of nontermination which just gets itself over with really quickly ;)
16:03:44 <Cale> You could also simply write  hZero = hZero
16:04:08 <kurt21> ty
16:04:09 <mauke> Pamelloes: you can only do Attr f a = ... and use it as Attr (Component t) w
16:05:11 <athan> Hijiri: Is `undefined` in haskell ⊤ → ⊥ ?
16:06:18 <Pamelloes> mauke: That's what I was afraid of. Now I have to rework my type synonyms :/
16:08:07 <Cale> athan: undefined :: forall a. a
16:08:30 <athan> Cale: I listened-in on a talk on CT-style top & bottom
16:09:01 <athan> it was something like: `top can be {} -> ., and . -> .`
16:09:06 <athan> but not point to empty
16:09:18 <athan> (in the category of sets)
16:09:34 <athan> You could implement undefined as
16:09:48 <athan> `undefined () = undefined ()` ?
16:10:15 <Cale> I'm not sure what you mean by this
16:10:37 <athan> Cale: is infinite recursion ~ bottom?
16:10:59 <Cale> Bottom is the value that we assign to all the terms which don't terminate normally.
16:11:23 <Cale> It's called bottom because it's the least element of the definedness ordering on each type
16:11:53 <carter_cloud> Undefined is just the trivial bad error message version of error
16:12:07 <carter_cloud> Ie error ""
16:12:27 <Cale> This ordering is defined separately for each type, but the intuition is that x <= y in this ordering whenever you can replace occurrences of _|_ in x with some values of appropriate types to obtain y.
16:12:46 <Cale> > undefined
16:12:47 <lambdabot>  *Exception: Prelude.undefined
16:12:51 <dan64> Is it possible to pattern match on just the data constructor name and not its args? So instead of Cons _ _ = ..., just Cons = ...
16:13:04 <Cale> So it's error "Prelude.undefined"
16:13:16 * hackagebot pseudo-boolean 0.1.0.1 - Reading/Writing OPB/WBO files used in pseudo boolean competition  http://hackage.haskell.org/package/pseudo-boolean-0.1.0.1 (MasahiroSakai)
16:13:21 <Cale> dan64: Cons {}
16:14:14 <dan64> Cale, thanks.
16:14:25 <Cale> dan64: This is specified to work even if Cons wasn't defined using record syntax
16:15:02 <dan64> Oh cool. Another related question. Is it possible to use record syntax for some args of a constructor but not for others?
16:15:16 <dan64> or is it all-or-none?
16:15:23 <athan> Cale: :) Thank you
16:15:33 <Cale> If I understand what you mean, then it's all or none
16:15:39 <felixn> Hey, I'm using ghc-mod, but it says it can't find my files (which are under `src/`).  I have `hs-source-dirs` set in my cabal file, but it doesn't seem to check that.  also using Vim's syntastic, so it's not easy to add args to ghc-mod
16:15:51 <athan> carter_cloud: o/
16:17:50 <Cale> athan: So, the values of each type form a (directed-complete) partial order under this definedness relation <= 
16:18:27 <Cale> athan: and definable functions between types are continuous (preserve limits of infinite ascending chains) and order-preserving
16:18:31 <athan> Cale: That helps a lot actually
16:19:19 <athan> Is... pattern matching similar to how meet returns the least element?
16:19:31 <Cale> The usual fixed point combinator  fix f = x where x = f x  will find the least defined fixed point.
16:19:44 <Cale> So if f _|_ = _|_, then that's what fix gives you
16:20:00 <Cale> I should say, then fix f = _|_
16:20:02 <athan> Cale: That's amazing
16:20:56 <Cale> But there are functions f for which f _|_ is not _|_, for example (1:_|_) can't be _|_ because head (1 : _|_) = 1, while head _|_ = _|_
16:21:03 <Cale> > fix (1:)
16:21:05 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
16:22:20 <Cale> So correspondingly, the least fixed point of (1:) isn't _|_, but instead turns out to be an infinite list, the limit of the chain _|_ <= (1 : _|_) <= (1 : 1 : _|_) <= ...
16:24:26 <athan> Cale: Is lazyness part of what makes haskell inconsistent as a logic?
16:24:41 <athan> (for bottom propogation, for instance)?
16:24:52 <athan> erm, and the existence of undefined, too?
16:28:01 <Cale> athan: Lazy evaluation itself isn't, but _|_ being an element of every type, and the existence of this fixpoint combinator does.
16:28:21 <Cale> fix :: forall a. (a -> a) -> a
16:28:28 <Cale> So  fix id :: forall a. a
16:28:32 <Cale> and there's your proof of anything
16:29:40 <Cale> It's really just general recursion's fault
16:29:41 <athan> Cale: Ahh wow, that makes perfect sense
16:29:58 <athan> amazing :) Thank you!!!
16:38:17 * hackagebot iap-verifier 0.1.0.0 - A simple wrapper of In-App-Purchase receipt validate APIs.  http://hackage.haskell.org/package/iap-verifier-0.1.0.0 (tattsun)
16:47:21 <slack1256> on Control.Concurrent.QSem.newQsem would it make sense to take a Word instead of a Int?
16:50:52 <srhb> slack1256: Sure.
16:54:06 <pomdefrites> I want to true partially applying parameters. I define a new type: type IntMap v = Data.Map.Map Int v
16:54:25 <pomdefrites> how do I then use this to instantiate a list of (Int,Int)
16:54:27 <pomdefrites> ?
16:55:27 <pacak> pomdefrites: There's IntMap container which is a bit more efficient if you really want Int as your key.
16:55:57 <pomdefrites> I'm trying to go from first principles 
16:56:17 <pacak> You just use "IntMap (Int, Int)" as your type
16:56:35 <pomdefrites> I can't do  [(1,2),(3,5),(8,9)] :: IntMap Int
16:56:45 <pacak> you need fromList
16:56:56 <pacak> Or OverloadedList extension
16:57:08 <arkeet> fromList [(1,2),(3,5),(8,9)]
16:57:09 <pomdefrites> really
16:57:17 <pomdefrites> how can I do: type AssocList k v = [(k,v)]  
16:57:22 <arkeet> you can.
16:57:28 <arkeet> but that's not a Map
16:57:30 <pomdefrites> [(1,2),(3,5),(8,9)] :: AssocList Int Int
16:57:36 <arkeet> like that.
16:57:38 <pomdefrites> ahh
16:57:38 <pacak> Also tuples should be a bit different
16:58:18 * hackagebot diagrams-rasterific 1.3.1.1 - Rasterific backend for diagrams.  http://hackage.haskell.org/package/diagrams-rasterific-1.3.1.1 (jeffreyrosenbluth)
16:58:48 <pomdefrites> so what would be the complete line of code require to get [(1,2),(3,5),(8,9)] :: IntMap Int working?
16:58:58 <pomdefrites> where would the fromList go?
16:59:11 <pacak> fromList [(1,2), (3,4)]
16:59:20 <pacak> :t Map.fromList
16:59:21 <lambdabot>     Not in scope: ‘Map.fromList’
16:59:22 <lambdabot>     Perhaps you meant one of these:
16:59:22 <lambdabot>       ‘M.fromList’ (imported from Data.Map),
16:59:27 <pacak> :t M.fromList
16:59:29 <lambdabot> Ord k => [(k, a)] -> M.Map k a
16:59:37 <pacak> M.fromList  [(1,2)]
16:59:42 <pacak> > M.fromList  [(1,2)]
16:59:43 <lambdabot>  fromList [(1,2)]
16:59:54 <pacak> And you just add your type signature
17:01:35 <pomdefrites> thanks. so if i run :t Map.fromList [(1,2),(3,5),(8,9)] :: IntMap Int
17:01:41 <pomdefrites> why do I get back Map.fromList [(1,2),(3,5),(8,9)] :: IntMap Int :: IntMap Int
17:01:52 <pomdefrites> notice the double IntMap Int :: IntMap Int
17:02:16 <jle`> acually, [(1,2),(3,5),(8,9)] :: IntMap Int already works as-is, if you enable OverloadedLists
17:02:18 <pacak> let t = Map ...
17:02:18 <pacak> :t t
17:02:19 <lambdabot> Expr
17:02:42 <pacak> lambdabot: Thank you for your useful suggestion.
17:02:44 <jle`> oh i see, it's a different IntMap
17:03:00 <jle`> also i should have read back more, someone already suggested it :)
17:03:52 <pomdefrites> sorry not following
17:04:04 <pomdefrites> why isn't there just a single :: IntMap Int
17:04:27 <pomdefrites> :t Map.fromList [(1,"2"),(3,"5"),(8,"9")] :: IntMap String
17:04:28 <lambdabot>     Not in scope: ‘Map.fromList’
17:04:28 <lambdabot>     Perhaps you meant one of these:
17:04:28 <lambdabot>       ‘M.fromList’ (imported from Data.Map),
17:04:33 <pomdefrites> :t M.fromList [(1,"2"),(3,"5"),(8,"9")] :: IntMap String
17:04:34 <lambdabot>     Not in scope: type constructor or class ‘IntMap’
17:04:34 <lambdabot>     Perhaps you meant ‘IM.IntMap’ (imported from Data.IntMap)
17:04:52 <pomdefrites> likewise :t Map.fromList [(1,"2"),(3,"5"),(8,"9")] :: IntMap String will give me Map.fromList [(1,"2"),(3,"5"),(8,"9")] :: IntMap String   :: IntMap String
17:05:04 <pomdefrites> don
17:05:23 <pomdefrites> don't see why the IntMap appears twice
17:07:11 <pomdefrites> pacak: any hints?
17:08:10 <pacak> First IntMap comes from whatever you typed, second - given by ghci
17:08:18 * hackagebot iap-verifier 0.1.0.1 - A simple wrapper of In-App-Purchase receipt validate APIs.  http://hackage.haskell.org/package/iap-verifier-0.1.0.1 (tattsun)
17:09:05 <pomdefrites> pacak: sorry for my obtuseness, but why is the second given by ghci?
17:09:19 <pacak> :t 'a'
17:09:20 <lambdabot> Char
17:09:45 <pacak> pomdefrites: Because you ask it to give you a type signature
17:10:22 <pacak>    :t "blah :: Int"
17:10:22 <pacak> and ghci replies :t for "blah :: Int" is :: Int, but without " and "is"
17:11:39 <albeit_> Am I correct in saying that both a Chan and TQueue can be written to and read from at the same time, except, for TQueue, when the read TVar is empty but the write TVar is not?
17:12:26 <pomdefrites> pacak: I did, but if I omit the :t I don't get any type information. I still don't see why I get two loads of type information - there is only one data structure of type IntMap Int 
17:13:59 <pacak> pomdefrites: It's magic! Nobody knows how it works! A bunch of eggheads collected together a bunch of cryptic lines and it worked!!!! But nobody understood why!!! By asking such questions you are threatening to poke a hole in the fabric of reality itself!
17:14:44 <pomdefrites> :t "blah :: Int"
17:14:45 <lambdabot> [Char]
17:15:10 <pomdefrites> :t blah :: Int
17:15:12 <lambdabot> Not in scope: ‘blah’
17:15:30 <pomdefrites> :t 10 :: Int
17:15:31 <lambdabot> Int
17:15:48 <pacak> lambdabot renders stuff differently
17:17:02 <pomdefrites> pacak: oh fiddlesticks, I see, it's literally just repeating what I type in saying you type in "xyz :: q", and it's type is q in the form "xyz :: q :: q" 
17:17:10 <pomdefrites> pacak: I understand now, thanks
17:17:21 <pacak> pomdefrites: Exactly.
17:17:21 <pomdefrites> pacak: thanks alot :D
17:22:12 <bitemyapp> crough: it wouldn't be
17:22:18 <bitemyapp> crough: I'm coolsunglasses on Hacker News.
17:22:49 <crough> bitemyapp: Yeah then, no idea at all... I just know I saw it and all I could think was "what a neat coincidence"!
17:23:48 <crough> People were praising your Learn Haskell repo as well; you have some clout around here
17:25:21 <rvxi> hey
17:26:42 <srhb> rvxi: Hey.
17:27:22 <rvxi> anyone putzing around with javascript front-ends for interfacing with yesod on the backend?
17:28:29 <Welkin> rvxi: try ghcjs
17:28:39 <Welkin> everything has to go through ajax anyway
17:29:15 <rvxi> i may move to fay or ghcjs eventually
17:29:16 <Welkin> it's trivial to serve json to a javascript client using yesod
17:29:24 <rvxi> but having never done javascript before
17:29:45 <rvxi> (or much web programming beyond basic html/cgi/soap-based web scraping stuff)
17:30:00 <rvxi> i feel like i should get the basic concepts down before taking on an abstraction that compiles down to javascript
17:30:04 <Welkin> you still use http, so there are no surprises there
17:31:34 <rvxi> i'm working towards back-end computations and modeling with haskell, front-end ui/visualization with react + d3
17:32:12 <rvxi> i've learned enough haskell to get going with yesod and do some computations
17:32:51 <rvxi> now i'm learning the front end stuff. kind of cobbling tutorials haphhazardly because the overlap between the javascript datavis users
17:33:01 <rvxi> and haskell yesod developers is kind of small
17:33:19 <rvxi> or at least small enough that's there's not a full-stack how-to as far as i can tell.
17:33:19 <bitemyapp> crough: I suspect it was the direct link to gumroad that was problematic (rightly so, people should read what it's about first)
17:33:33 <bitemyapp> crough: I said as much on Twitter and it's already been reposted as a link to the site rather than the gumroad.
17:33:49 <crough> bitemyapp: yeah, I thought it was strange that it was just "It's available".
17:34:03 <crough> bitemyapp: So, you're right, most likely flagged and removed.
17:34:50 <bitemyapp> crough: again rightly so, although I am flattered that people think the gumroad suffices :P
17:36:29 <Welkin> rvxi: is there is reason to use react over rendering the pages serverside using the shakespearean templates provided by yesod?
17:37:11 <Welkin> I've never found a good use for React vs rendering serverside
17:37:36 <mmaroti> Hi Guys! Quick question. I want to implement monadic computations with boolean values (eventually for SAT solver). 
17:37:46 <mmaroti> So I use TypeFamilies and this type class:
17:37:55 <mmaroti> class Boolean b where
17:37:55 <mmaroti> 	data Monadic b :: *
17:37:55 <mmaroti> 	and :: b -> b -> Monadic b
17:38:02 <mmaroti> instance Boolean Bool where
17:38:02 <mmaroti> 	data Monadic Bool = Identity Bool
17:38:03 <mmaroti> 	and a b = return $ a && b
17:38:37 <mmaroti> but this does not work, it gives this error message: No instance for (Monad Monadic) arising from a use of `return'
17:38:56 <mmaroti> How can I fix this? I have tried many things and read upon, but still cannot figure it out.
17:39:08 <crough> Monads are higher kinded types
17:39:18 <crough> Boolean is not. It doesn't have an "inner" value.
17:39:28 <pacak> :k Monad
17:39:29 <lambdabot> (* -> *) -> Constraint
17:40:10 <mmaroti> I know. Maybe I could define "data BoolMonad :: (* -> *) -> Constraint" and use BoolMonad Bool Bool for all return values?
17:40:11 <crough> Why not `and :: Monad m => b -> b -> m b`
17:40:31 <mmaroti> I do not want any monad to be used for a specific boolean instance
17:40:52 <crough> Why do you want a monad, exactly, then? Identity monad doesn't do... anything.
17:40:53 <pacak> ghc wants otherwise.
17:40:55 <arkeet> mmaroti: do you have a Monad instance for Identity in scope
17:40:57 <mmaroti> For example I am using Identity for Bool but State for a Sat instance
17:41:00 <arkeet> er
17:41:06 <arkeet> ohhh
17:41:10 <arkeet> data Monadic Bool = Identity Bool
17:41:17 <arkeet> defines a new data type called Monadic, with constructor Identity.
17:41:56 <arkeet> well, an instance of it.
17:42:15 <mmaroti> So for any Boolean instance I want a unique Monad instance
17:43:15 <mmaroti> I know that Monadic Bool is just a data type...
17:43:49 <crough> class Monadic m a | a -> m where return' :: a -> m a
17:44:02 <crough> Does this work with functional dependencies? This could be easier for him to use than type families.
17:44:32 <crough> Then you could do: `instance Monadic Identity Bool where return' = return` I think...
17:45:02 <albeit_> In an otherwise pure/non-IO function, is it "okay" to use unsafePerformIO with Clock.getCurrentTime?
17:45:26 <crough> albeit_: I think GHC will cache it so you'll only ever get one time. Could be wrong though.
17:45:43 <crough> getCurrentTime *isn't* at all pure.
17:45:54 <mmaroti> Oh, "class Monad m => Boolean m a | a -> m" might work, since it will have an associated Monad, no?
17:46:17 <crough> mmaroti: No, because you shouldn't *redefine* a class
17:46:49 <mmaroti> Boolean is not defined, only Bool. What do you mean by "redefine"?
17:46:59 <crough> Well, wait, no, I don't know. Ignore me. I just can't get the use case for this :/
17:48:20 <mmaroti> Ok, so this works: 
17:48:27 <mmaroti> class Monad m => Boolean m b | b -> m where ...
17:48:36 <mmaroti> instance Boolean Identity Bool where ...
17:48:58 <crough> All right then! Functional dependencies are frequently easier to deal with than Type Families. GADTs would work as well for you.
17:48:59 <mmaroti> instance Boolean Literal State where ...
17:49:22 <mmaroti> I do not see how GADTs would do anything here?
17:49:34 <mmaroti> Is it possible to express this functional dependeny with type family?
17:50:14 <crough> Lift your type into an associations. And yes mmaroti, but I am not a typeclass expert as I'm on the side of "you almost never need to make a new one"
17:50:34 <mmaroti> ok
17:50:51 <mmaroti> but thanks for the functional dependency trick, I have forgotten about that
17:51:17 <crough> Yeah, of course. Just remember you may need type annotations in a few places.
17:52:41 <albeit_> crough: Is there any way to force getCurretTime to not be cached?
17:52:53 <crough> albeit_: Keep it in the IO monad?
17:54:25 <arkeet> related: https://hackage.haskell.org/package/acme-now
17:55:56 <verement> albeit_: I have had some success by using fmap on the IO action
17:56:06 <crough> It may be inconvenient, albeit_, but in Haskell you have to annotate inpure functions 
17:56:55 <crough> You can do something like this to get it into a data structure though: `data Msg = Msg Text UTCTime; newMsg msg = Msg msg <$> getCurrentTime`
17:57:12 <albeit_> crough: Yeah... I'm just running into a situation where everything is wrapped around the IO monad (like "State s IO"), and it feels ugly...
17:57:13 <crough> You'll get an IO Msg back, but now at least the UTCTime is unwrapped inside of the data structure
17:57:56 <crough> albeit_: Get the time first, then pass the time (via Applicative, Functor, or Monad) into pure code.
17:58:20 * hackagebot epub-metadata 4.3 - Library for parsing epub document metadata  http://hackage.haskell.org/package/epub-metadata-4.3 (DinoMorelli)
17:58:22 * hackagebot epub-tools 2.6 - Command line utilities for working with epub files  http://hackage.haskell.org/package/epub-tools-2.6 (DinoMorelli)
18:00:16 <albeit_> crough: For length pure code, I want to know at what point certain things are being executed, so I need it in the pure code, not before unfortunately
18:00:23 <albeit_> * lengthy
18:01:02 <crough> Are you doing profiling? There are a lot of profiling tools
18:02:22 <srhb> albeit_: So your problem is that you want to technically do unsafePerformIO, but for each time something is evaluated
18:03:18 <albeit_> crough: Yes I'm doing profiling, there is for logging on live production code
18:03:57 <albeit_> srhb: Sort of, yes. Not necessarily each time something is evaluated, but the time a number of different things are evaluated
18:04:37 <srhb> That's tricky. I mean, making the value pure means GHC will assume it is never-changing.
18:04:40 <crough> https://hackage.haskell.org/package/hslogger-1.2.9/docs/System-Log-Logger.html
18:04:55 <crough> And you'll probably want to keep it in the IO monad, still.
18:05:16 <crough> Or in a MonadIO m type.
18:05:27 <srhb> I don't know how to actually prevent GHC for doing this. If it's even possible.
18:05:32 <verement> albeit_: the way I did it is to perform a difference calculation within the IO action, so that it depends on something from outside the action, e.g.: unsafePerformIO $ (`diffUTCTime` start) <$> getCurrentTime
18:06:35 <srhb> I wonder if something like time _ = trace (show . unsafePerformIO $ getCurrentTime) -- would work
18:08:45 <pomdefrites> in ghci is it possible for the environment to remember types. e,g, I define  type LockerMap = Map.Map Int (Bool, String)
18:08:58 <srhb> pomdefrites: Yep.
18:09:18 <pomdefrites> but if I try lockers :: LockerMap , I get a not in scope lockers
18:09:27 <pomdefrites> oh shoot lockers isn't in scope
18:09:31 <srhb> :P
18:09:35 <pomdefrites> i'm defining it though
18:09:40 <pomdefrites> why is it winging at me!
18:09:55 <pomdefrites> ?
18:10:16 <srhb> pomdefrites: Wrong order? Define the type synonym first, then lockers
18:10:25 <Pamelloes> Is there a way to make some sort of "function" to turn a type of kind *->*->* into *? Basically, I want to have a way to apply to types with one statement
18:10:31 <srhb> pomdefrites: type Foo = Int; let test :: Foo; test = 42
18:10:34 <Pamelloes> *apply two
18:11:41 <pomdefrites> srhb: I've defined the type synomyn LockerMap first. Then when I try doing lockers :: LockerMap   or set lockers :: LockerMap  I get errors
18:12:01 <srhb> pomdefrites: But it's telling you lockers is not in scope, right?
18:12:06 <srhb> pomdefrites: Where did you define lockers?
18:12:06 <crough> Pamelloes: type F a = a -> a -> a
18:12:31 <crough> Or something? 
18:12:34 <pomdefrites> i haven't defined lockers yet - I'm defining it now
18:13:08 <crough> Pamelloes: or do you mean something like newtype F m x = F (m x x)
18:13:20 <srhb> pomdefrites: Well, foo :: Type is and expression
18:13:24 <Pamelloes> crough: Basically I want a type IntAndBool = Int Bool; Either IntAndBool = Either Int Bool
18:13:25 <srhb> an*
18:13:32 <srhb> pomdefrites: It will only succeed if foo is defined
18:14:06 <srhb> pomdefrites: If you're defining it (and using a type synonym) you want let name :: Type; name = value
18:14:16 <srhb> pomdefrites: Preserve semicolons
18:14:47 <crough> Pamelloes: data WeirdSum a b = EitherSum a b | AndSum a b
18:14:55 <crough> *EitherSum (Either a b)
18:15:20 <Fylwind> is hugs still used at all these days?
18:15:37 <srhb> Fylwind: Not really.
18:15:38 <arkeet> nope
18:16:08 <Fylwind> figures :\
18:16:18 <Pamelloes> crough: Fair enough
18:16:39 <pomdefrites> srhb: ok, seems I have to do it all in one line in ghci (prelude)  let lockers :: LockerMap; lockers = Map.fromList [(100,(True,"ZD39I"))]
18:16:55 <srhb> pomdefrites: Yes.
18:17:26 <pomdefrites> srhb: thanks alot :) but why all in one line. i thought ; represented line break 
18:17:40 <srhb> pomdefrites: It does, usually.
18:17:55 <srhb> pomdefrites: That's how it would look in a source file, without the `let`
18:18:16 <srhb> pomdefrites: You can also try :set +m for multiline input
18:18:33 <crough> As well as :{ :} for temporary multiline
18:20:15 <srhb> pomdefrites: (I don't know if this is obvious to you already, but...) a workflow with :e and :r can be really rewarding and avoids having to use the weird let ... syntax from the ghci do block
18:27:58 <jle`> so what do we do for profiling these days?
18:28:42 <pomdefrites> shrb: I :set +m, but how do I actually do multi-line input (say I want to type out a full function)
18:29:03 <pomdefrites> shrb: also I don't know about :e or :r 
18:29:15 <thunderseethe> hello
18:29:24 <srhb> pomdefrites: let foo :: YourType;     foo = 42 -- where ; is now newline again
18:29:43 <jle`> is this article from 2013 still relavant? https://wiki.haskell.org/How_to_profile_a_Haskell_program
18:29:48 <srhb> pomdefrites: And then an extra return to quit the multiline input
18:30:45 <thunderseethe> is it possible to define a type that's just literal values?
18:30:58 <srhb> thunderseethe: data Foo = Bar | Baz | Quux
18:31:04 <srhb> thunderseethe: Now you have three literals!
18:31:21 <thunderseethe> True true, I'm trying to do something similar with character literals and I get a parse error
18:31:45 <thunderseethe> I've been unsuccessful in finding what I'm thinking about wrong by googling
18:31:55 <Fylwind> thunderseethe: what did you try?
18:32:01 <pomdefrites> shrb: Prelude> let l :: Lockermap; Prelude| l = Map.fromList [(100,(False,"ZD39I"))];  <interactive>:303:1: parse error on input `l'
18:32:10 <thunderseethe> data IntChar = '0' | '1' | ... | '9'
18:32:24 <thunderseethe> aiming for something like that so I can pattern match for a string that starts with a digit
18:32:36 <pomdefrites> shrb: tried playing with the semi colon on and off the lines
18:32:40 <pomdefrites> shrb: no luck
18:33:31 <Fylwind> character literals can only be of type Char; you'd have to do something like: data IntChar = C0 | C1 | ... | C9
18:34:16 <thunderseethe> Yeah that's what I was afraid of, is there a way to define a subset of Char as a type or pattern match against a list of value instead of typing out 10 matches
18:34:36 <crough> thunderseethe: Use `readMaybe` on them first?
18:34:48 <Fylwind> if you want to pattern match you could make like 10 pattern synonyms for a newtype'd IntChar, but that's a bit heavy imo
18:34:53 <arkeet> use pattern synonyms :-)
18:35:25 <srhb> pomdefrites: http://lpaste.net/8153711977974202368
18:35:26 <Fylwind> newtype IntChar = IntChar Char; pattern C0 = IntChar '0'; etc
18:36:25 <thunderseethe> Oh cool I hadn't seen those before 
18:36:37 <thunderseethe> I will look into pattern synonyms
18:37:07 <pomdefrites> shrb: http://lpaste.net/133346
18:37:19 <pomdefrites> srhb: http://lpaste.net/133346
18:37:47 <srhb> pomdefrites: Indentation matters :)
18:37:51 <srhb> foo must be alligned with foo
18:38:21 <pomdefrites> srhb: i figured it can't be that dum, so I tried a couple of spaces. but yes, once aligned it works :P Thanks alot
18:38:26 <arkeet> but
18:38:29 <arkeet> maybe you should just use a guard
18:38:42 <arkeet> foo c | isDigit c = ...
18:40:01 <srhb> thunderseethe: Or maybe you're actually looking for dependent types, wanting a function that actually does not typecheck for a Stringly typed argument that does not start with a digit. In which case, you're out of luck with Haskell, mostly.
18:40:39 <crough> There's always Idris
18:40:53 <lpaste> arkeet pasted “digit pattern” at http://lpaste.net/133348
18:40:57 <arkeet> I dunno.
18:41:54 <arkeet> seems like you can't use guards in a pattern synonym. that sucks
18:43:13 <thunderseethe> True, but I think I can circumvent the synonym with the guard, ultimately I'm trying to pattern match a string's first character to see it it's '0' <= c <= '9
18:43:18 <thunderseethe> '
18:43:29 <arkeet> why not just use a guard?
18:43:39 <arkeet> yeah
18:44:04 <thunderseethe> Because I didn't know they existed xD
18:44:07 <arkeet> okay
18:44:12 <arkeet> guards are useful
18:44:54 <thunderseethe> yeah that looks like what I need thank you for the help
18:46:36 <arkeet> np :)
18:50:58 <DrPavelheer> Hey, question
18:51:07 <nocturne777> what's the most commonly used library to schedule background jobs in Haskell ?
18:51:14 <srhb> DrPavelheer: Ask, and you shall Maybe Receive.
18:51:31 <srhb> nocturne777: I'm not aware of a specific one. Usually we just fork a thread and that's it.
18:51:54 <srhb> nocturne777: If you have more specific requirements it might be easier to point you in a direction.
18:52:28 <DrPavelheer> I'm using the Facebook package, which requires Text to be between versions 0.11 and 1.3. My version is 1.2.0.5.
18:52:28 <nocturne777> srhb: I am looking for a library similiar to this for Haskell -> http://quartz-scheduler.org/
18:52:37 <srhb> pomdefrites: also :e just opens your editor. Once saved and exited ghci reload your file.
18:52:56 <DrPavelheer> But it complains, saying that it can't match my Text with its text-1.1.0.0:Text.
18:53:07 <srhb> DrPavelheer: Facebook? fb?
18:53:11 <DrPavelheer> Yeah, fb
18:53:23 * hackagebot network-info 0.2.0.6 - Access the local computer's basic network configuration  http://hackage.haskell.org/package/network-info-0.2.0.6 (JacobStanley)
18:53:27 <arkeet> DrPavelheer: because you have multiple versions of text installed
18:53:35 <arkeet> and using things that depend on different versions
18:53:45 <DrPavelheer> hmm
18:54:37 <DrPavelheer> i'm checking my packages, but it only looks like I have 1.2.0.5
18:54:47 <arkeet> ghc-pkg list
18:55:07 <DrPavelheer> nope, still only one
18:55:11 <nocturne777> srhb: in short, a library that I can rely on to schedule tasks to be run at specific times
18:55:12 <arkeet> maybe you have a global version of text as part of a haskell platform installation or something
18:55:18 <DrPavelheer> hmm
18:55:44 <_m_ryan> hi how do i call a function like this? incrementCtr n = n + 1, is it n a pararmeter?
18:56:14 <srhb> _m_ryan: Yes, n is a parameter
18:56:32 <srhb> > let incrementCtr n = n + 1 in incrementCtr 10
18:56:34 <lambdabot>  11
18:57:34 <DrPavelheer> oh my god that is so cool
18:58:25 <_m_ryan> srhb: can you help me out on this, http://lpaste.net/133343
18:58:32 <DrPavelheer> arkeet: i think you're right about that, but I can't find anything
18:58:45 <srhb> _m_ryan: I don't know how Hamlet works. What's the problem?
18:59:16 <srhb> _m_ryan: As far as I can see you're applying the function to n, which has not been defined. Other than that, I don't know.
18:59:48 <_m_ryan> srhb: i call the function incrementCtr inside the hamlet, but i want to preserve what will be the result of the incrementCtr
19:00:12 <DrPavelheer> _m_ryan: What is n?
19:01:01 <srhb> It also looks strangely stateful. Like you expect those splices to somehow magically store to something stateful
19:01:03 <_m_ryan> srhb: DrPavelheer, it will be a variable that will holde a value lets say n = 1; so in my hamlet.
19:01:48 <Lokathor> for monoids, x <> y is often not the same as y <> x, right?
19:01:51 <srhb> _m_ryan: No idea. Perhaps try with a much simpler example.
19:01:55 <Lokathor> but it might be?
19:02:13 <srhb> Lokathor: mappend need not be commutative, indeed.
19:02:51 <jle`> Lokathor: yup
19:03:02 <DrPavelheer> _m_ryan: And what is your main problem?
19:03:18 <_m_ryan> in simpler, this will me. $if ( (incrementCounter rowCtr ) == 1) -- do some html code $else -- do some html code, where rowCtr = rowCtr + 1
19:03:26 <_m_ryan> srhb: ^
19:03:43 <srhb> _m_ryan: What is rowCtr?
19:04:10 <srhb> Again, you've just pulled it out of a hat without defining it before using it, just like you did with n
19:04:27 <pavonia> _m_ryan: Please describe the problem you are trying to solve
19:04:54 <_m_ryan> srhb: you mean, let rowCtr = rowCtr + 1
19:05:15 <srhb> > let foo = foo + 1 in foo
19:05:19 <lambdabot>  mueval-core: Time limit exceeded
19:05:21 <srhb> That doesn't look like a sane definition.
19:05:37 <nshepperd> you need to use an ioref or something if you want a variable you can update imperatively
19:05:52 <srhb> Whether IORefs are a thing in Hamlet, I don't know.
19:06:01 <DrPavelheer> arkeet: OH
19:06:34 <DrPavelheer> arkeet: It printed 2 sets of packages, but I only saw the second. The first had text-1.1.0.0
19:06:37 <_m_ryan> ok, so my problem is,  just want to increment the rowCtr while doing some looping on my hamlet and check the rowCtr if it reach 10 then set it again to 1
19:06:42 <nshepperd> or iterate over 'zip [1..] cityList' instead of just cityList
19:08:15 <_m_ryan> nshepperd: how do i check if it meet the 10 on the list?
19:08:36 <pomdefrites> why can I do this: 3: (2 : []) but I cannot do this 3 $ 2 : [] ?
19:08:43 <prsteele-> _m_ryan: zip (cycle [1..10]) cityList is probably closer to what you want
19:08:46 <srhb> pomdefrites: 3 is not a function
19:08:51 <srhb> @src ($)
19:08:51 <lambdabot> f $ x = f x
19:09:11 <pavonia> _m_ryan: Do you want a different HTML code if n= 10, or only a different CSS styling?
19:09:13 <srhb> pomdefrites: $ is not some strange sugar for paranthesis. It's just function application with very low precedence
19:09:34 <_m_ryan> pavonia: different html code if n = 10
19:09:44 <pomdefrites> srhb: so I guess I could do (3:) (2 : [])
19:09:47 <pomdefrites> srhb: so I guess I could do (3:) $ (2 : [])
19:09:49 <srhb> pomdefrites: Yes.
19:09:59 <srhb> 3: is indeed a function
19:10:03 <srhb> (3:) rather
19:10:07 <pomdefrites> srhb: as (3:) would be a partial function would it not?
19:10:18 <srhb> pomdefrites: Not a partial function, but partially applied, yes.
19:10:23 <prsteele-> > :t (3:)
19:10:25 <lambdabot>  <hint>:1:1: parse error on input ‘:’
19:10:37 <prsteele-> hm, sorry, don't know lambdabot well
19:10:40 <srhb> pomdefrites: A partial function is one that is undefined for some parameter values, like head is for []
19:10:44 <srhb> :t (3:)
19:10:45 <lambdabot> Num a => [a] -> [a]
19:11:01 <srhb> prsteele: > is exclusively for expressions
19:11:05 <nshepperd> _m_ryan: right, (cycle [1..10]) will work better, then you can just do 'if row == 10'
19:11:08 <prsteele-> srhb: ah, thanks
19:11:23 <pomdefrites> srhb: yes, you're write sorry. need to get my terminology in order. how's head a partial function?
19:11:26 <nshepperd> and it will wrap around automatically
19:11:30 <srhb> > head []
19:11:32 <lambdabot>  *Exception: Prelude.head: empty list
19:11:33 <srhb> pomdefrites: Boom.
19:11:39 <_m_ryan> nshepperd: $for (rowNumber, item) <- zip (cycle [1..10]) cityList
19:12:21 <nshepperd> _m_ryan: something like that yeah
19:12:31 <pomdefrites> srhb: ahh i see ;)
19:12:39 <srhb> pomdefrites: We don't like those. :(
19:13:48 <DrPavelheer> :t cycle
19:13:49 <lambdabot> [a] -> [a]
19:13:50 <_m_ryan> nshepperd: error on my hamlet: Received a command I did not understand. If you wanted a literal $, start the line with a backslash.
19:14:06 <pomdefrites> srhb: final stupid question in this epoch,  (3:) . (1:) . (2 : []) vs (3:) . (1:) $ (2 : []). The first wont work - is that simply because $ forces the far right to execute first, then the chain works, while the first one tries to execute from the left?
19:14:11 <DrPavelheer> > cycle [1,2,3,4,5]
19:14:13 <lambdabot>  [1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3...
19:14:17 <DrPavelheer> got it
19:14:38 <srhb> pomdefrites: You should try working out the type
19:14:40 <creichert> _m_ryan: it's forall
19:14:43 <fishburne> i am trying to install scotty library for making web application. I am using the cabal file in this page http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html. I got a bunch of version issues, so I removed version constraints from cabal file. But I am still getting this error..https://bpaste.net/show/364f1a511c57
19:16:01 <_m_ryan> creichert: $forall (rowNumber, data) <- zip (cycle [1..10]) cityList?
19:16:22 <pomdefrites> srhb: the functions take a and put it into a list of a for :t (3:) . (1:) $ (2 : [])
19:16:42 <srhb> pomdefrites: Actually that one won't work simply because you're mixing . and $
19:17:00 <srhb> Wait, that's nonsense.
19:17:12 <_m_ryan> creichert: error in part of zip ( cycle [1..10]) : unexpected '('
19:17:13 <_m_ryan> expecting end of input, "\n" or "\r\n"
19:17:36 <srhb> :i ($)
19:17:44 <srhb> @info ($)
19:17:44 <lambdabot> ($)
19:17:48 <srhb> @undef
19:17:48 <lambdabot> Undefined.
19:17:59 <pomdefrites> srhb: i think of composition as pipelining, or mathematically like f(g(x)) for (f.g) (x). I don't see how I cannot pipeline (3:) . (1:) . (2 : [])
19:18:06 <srhb> pomdefrites: That is correct
19:18:16 <srhb> But you have to take into account associativity
19:18:20 <srhb> Which I think you were hinting at
19:18:29 <pomdefrites> srhb: which is right?
19:18:35 <creichert> _m_ryan: try also wrapping the entire expression in parenthasis
19:18:40 <srhb> pomdefrites: Yes.
19:19:03 <pomdefrites> srhb: so $ in the far right term just causes the whole evaluation to play out from right to left 
19:19:05 <srhb> pomdefrites: But (2 : []) is not a function
19:19:15 <srhb> So there's more than one problem
19:19:31 <verement> > (3:) . (1:) . (2:) $ []
19:19:31 <DrPavelheer> pomdefrites: You're trying to compose a function and a non-function
19:19:32 <lambdabot>  [3,1,2]
19:19:57 <srhb> pomdefrites: ie. for (2 : []) to be the right hand argument of (.) it would have to take an argument.
19:20:36 * mniip tries to think of some typeextension where [2] is polymorphic enough to be dyadic
19:20:52 <_m_ryan> creichert: like this? $forall (rowNumber, data) <- (zip (cycle [1..10])) cityList
19:20:54 <mniip> er, I meant (:[]) to be dyadic
19:21:12 <srhb> (also I was confused before because someone had defined ($) with the same precedence level as (.) in lambdabot. That's just cruel!)
19:21:35 <pomdefrites> srhb: ok. i see. likewise the (1: (2 : [])) term isn't a function here:  (3:) . (1: (2 : []))
19:21:44 <srhb> pomdefrites: Indeed
19:21:54 <creichert> _m_ryan: try it a few different way, the hamlet parser is probably just being finicky about the parenthases
19:22:16 <mniip> :t 1:2:[]
19:22:17 <lambdabot> Num a => [a]
19:22:26 <pomdefrites> shrb: super, thanks a ton for addressing my questions. i'll leave you in peace... for now :P
19:22:33 <mniip> it's a [] not a ->, so can't be an argument of .
19:22:38 <creichert> _m_ryan: $forall ((rowNumber, data) <- zip (cycle [1..10], cityList))
19:22:43 <srhb> pomdefrites: No worries, feel free to poke. :)
19:25:12 <creichert> fishburne: that tutorial looks a bit old and unfortunately didn't specify any other bounds besides persistent. You can try either removing some of the other bounds until you can get it working, try constraining scotty, or try a stackage cabal.config in your project's directory.
19:25:37 <crocket> hi
19:25:43 <crocket> Can anyone answer http://www.quora.com/When-do-I-use-Haskell-and-OCaml ?
19:25:46 <_m_ryan> creichert: unexpected "("
19:25:46 <_m_ryan> expecting ")"
19:26:31 <Welkin> no parents around it
19:26:49 <Welkin> $forall x <- xs
19:26:55 <Welkin> parens*
19:30:12 <_m_ryan> Welkin: $forall (rowNumber, data) <- ((zip (cycle [1..10])), cityList), where parenthesis?
19:32:28 <mmaroti> Hi guys! What is the overhead of a newtype?
19:32:43 <mmaroti> I have "newtype Id = Id { getId :: int }"
19:33:07 <mmaroti> then to convert [[Id]] to [[Int]], then I have to run fmap twice, so does that have any overhead?
19:33:27 <johnw> what kind of overhead?
19:33:30 <johnw> at runtime, zero
19:33:33 <johnw> for the programmer, there is some
19:33:40 <johnw> i believe that nowadays you might even be able to just "coerce" [[Id]] to [[Int]]
19:33:52 <mmaroti> so the fmap getId is completely optimized away?
19:34:04 <johnw> yes, I believe so
19:34:07 <dolio> No.
19:34:09 <mmaroti> How do I coerce?
19:34:13 <johnw> no, I don't believe so
19:34:30 <johnw> dolio: I thought they fixed that in 7.8?
19:34:38 <johnw> Data.Coerce
19:34:46 <dolio> Rewriting fmap into coerce?
19:34:56 <johnw> rewriting fmap getId into fmap id into id
19:35:14 <mmaroti> Ok, I will read upon coerce.
19:35:16 <mmaroti> Thanks!
19:35:16 <dolio> I doubt they did that.
19:35:26 <johnw> dolio: I remember that being the point of roles
19:35:42 <johnw> or a point
19:35:47 <nshepperd> I do seem to recall talk of map coerce rewriting to coerce
19:35:52 <dolio> Well, I don't think that was the main point of that, either.
19:36:18 <johnw> not the main point
19:36:28 <johnw> hmm
19:36:33 <johnw> "A new built-in function coerce is provided that allows to safely coerce values between types that have the same run-time-presentation, such as newtypes, but also newtypes inside containers." (7.8 docs)
19:36:39 <johnw> maybe that's all I'm thinking of
19:36:56 <dolio> There is a map coerce = coerce rule.
19:37:04 <dolio> Does getId desugar to coerce?
19:37:04 <johnw> fmap coerce?
19:37:23 <dolio> I don't see one for fmap.
19:38:06 <dolio> map coerce = coerce is new in 7.10, too.
19:38:32 <mmaroti> I am using 7.6
19:38:35 <dolio> The big deal with roles was to fix GND to not let you derive unsafeCoerce.
19:38:56 <johnw> dolio: right, I remember that now
19:39:02 <Welkin> hahaha
19:39:05 <Welkin> http://nicedit.com/
19:39:12 <Welkin> ;atest release is December 31st, 1969
19:39:14 <dolio> The coerce stuff is just a side thing that people like me and Ed think are a bigger deal than the main reason. :)
19:39:16 <Welkin> latest*
19:39:29 <Welkin> unix time bug?
19:39:30 <johnw> mmaroti: so, you may be out of luck for now
19:39:33 <johnw> https://skillsmatter.com/skillscasts/5296-safe-zero-cost-coercions-in-haskell
19:40:50 <dolio> I'd be surprised if map id is free, too.
19:41:05 <prsteele-> johnw, dolio: are these improvements being done at the library level, or at the compiler level?
19:41:09 <johnw> dolio: why is that?
19:44:35 <dolio> Well, it depends where it shows up, actually.
19:44:53 <dolio> If you write 'map id [1..1000000]' It's free, because that fuses into one thing, and the id disappears.
19:45:09 <mmaroti> The bad thing is that coerce is not in GHC 7.6.3
19:45:22 <dolio> But, if you don't have something that can fuse 'map id' into something else in a way that makes it free, it will cost you.
19:46:12 <mmaroti> is it possible to check if "fmap getId" fuses into nothing?
19:50:43 <ttt_fff> is there a way to get threepenny to include css ?
19:57:04 <johnw> mmaroti: you can check the Core; ghc-core makes this easy to do
19:57:24 <mmaroti> how to run that?
19:59:11 <johnw> just "ghc-core File.hs"
19:59:21 <johnw> with -O perhaps
19:59:21 <prsteele-> When I try to load a module in ghci, I get "File name does not match module name: Saw `Foo', expected `Foo'". Any ideas?
20:00:25 <fishburne> creichert, just running 'cabal install scotty' seems to work
20:00:51 <creichert> fishburne: great, btw here is another tutorial which might help: http://taylor.fausak.me/2014/10/21/building-a-json-rest-api-in-haskell/
20:01:52 <fishburne> creichert, thanks.
20:02:09 <pavonia> prsteele-: What is the module name and the file name of that module, and in what directory is it?
20:02:46 <prsteele-> pavonia: module name Foo.Foo, file name Foo/Foo.hs
20:03:10 <pavonia> I think you can't name it Foo.Foo
20:03:11 <prsteele-> pavonia: is repeating the dir name a problem?
20:03:53 <pavonia> module Foo in Foo/Foo.hs should be fine
20:04:57 <Welkin> if I only defined Show for a type, can I have the compiler derive the correct Read instance based on my explicitly defined Show instance?
20:05:10 <prsteele-> pavonia: renaming Foo/Foo.hs to anything else works, thanks
20:05:51 <prsteele-> Welkin: that seems... impossible. What if your Show encoded the data in... I don't know, Lisp?
20:06:10 <Welkin> what?
20:06:22 <Welkin> Read is the opposite of Show
20:06:39 <prsteele-> Welkin: sure, but you said you defined Show?
20:06:57 <Welkin> well, I want to see if I can save some typing
20:07:25 <prsteele-> Welkin: so in general, you could have it do something interesting with Show, like describe the data in some strange format. Read can't know about all such formats
20:07:55 <Welkin> I'm just producing a human-readable string for a simple sum type
20:08:33 <pavonia> You shouldn't use Show for that, Show is supposed to produce legal Haskell code
20:08:37 <pomdefrites> I'm looking at the binary search tree implementation just over half way down here: http://learnyouahaskell.com/making-our-own-types-and-typeclasses (search for treeInsert)
20:08:56 <pomdefrites> why is (Node a left right) bracketed on the line reading treeInsert x (Node a left right)  
20:09:46 <srhb> pomdefrites: How do you separate values in constructor fields from other parameters?
20:10:22 <srhb> pomdefrites: Consider treeInsert x Node a left right -- how many arguments are here?
20:10:27 <pomdefrites> I'm guessing with parenthesis ?
20:10:33 <srhb> pomdefrites: Ding ding ding. :)
20:10:47 <pomdefrites> should be 4 arguments
20:10:54 <pomdefrites> ?
20:11:06 <srhb> pomdefrites: Hard to tell. Depends how many of them you apply Node to!
20:11:10 <srhb> pomdefrites: Hence, paranthesis.
20:11:27 <srhb> (Remember, you can partially apply value constructors as well)
20:11:41 <srhb> So there are quite a few restrictions in place for pattern matching
20:11:50 <pomdefrites> but can't i use the argument that just Node a left right has a difficult-to-read number of arguments
20:11:58 <pomdefrites> i mean perhaps Node applys to all 3 
20:12:29 <srhb> pomdefrites: A more succinct answer is "Haskell requires you to enclose any single argument in paranthesis if there are multiple fields" or something like that
20:12:42 <srhb> pomdefrites: Because otherwise things get messy, but anyway, someone decided this is how we do.
20:13:02 <srhb> pomdefrites: You can try and write it in a file without parens and see how ghc complains.
20:13:29 <srhb> pomdefrites: afair it will consider x, Node, a, left and right arguments to the function
20:13:49 <srhb> pomdefrites: Which is immediately an error because the function only took two arguments in the line before.
20:19:24 <pomdefrites> srhb: thanks again, while I'm still not completely comfortable with this, I'll let is simmer for a while to see if it becomes more familiar 
20:20:06 <srhb> pomdefrites: Hmm, okay.
20:20:30 <pomdefrites> srhb: btw, the function treeInsert isn't going to keep the tree balanced is it?
20:20:49 <srhb> pomdefrites: I feel like I must have explained it poorly since to me it feels obvious how the alternative will lead to disaster. :P
20:21:08 <srhb> pomdefrites: It will not rebalance, if that's what you're asking.
20:21:24 <hnfmr> hi is there any library that enables me to schedule task to run after certain seconds (some amount of time)
20:21:43 <benzrf> srhb: but srhb
20:21:58 <benzrf> using it w/ only 2 args could be just unsaturated application
20:21:59 <srhb> benzrf: That's a very redundant message! :P
20:22:00 <srhb> Ah
20:22:07 <srhb> Yes, I said so earlier.
20:22:23 <benzrf> and even if it were saturated, polymorphism means that saturated arg count can vary
20:22:29 <benzrf> > id 3 -- saturated
20:22:30 <pomdefrites> srhb: yeah, didn't think so, just wanted to make sure as they were chatting about that further up the page. It's you - I've been quite fatigued today and it's late for me now too :) Haskell hasn't been as enjoyable today :(
20:22:31 <lambdabot>  3
20:22:33 <srhb> Yep.
20:22:37 <benzrf> sorry =p
20:22:48 <pomdefrites> srhb: it's not you**
20:23:02 <srhb> pomdefrites: Sorry to hear that! I might recommend you to look at one of the alternate resources, like cis194 instead of learnyouahaskell
20:23:16 <srhb> recommend that you*
20:24:49 <hnfmr> does "threadDelay" block the current thread? or does it yield so that other tasks can progress on the thread?
20:24:59 <hnfmr> it blocks on the "Haskell thread" right? not the OS thread?
20:25:43 <pomdefrites> srhb: cis194 looks pretty cool. might give the homeworks a try. I'm desperate to get to and read through the monads chapter, after that I think I'll tinker with some problems
20:25:52 <srhb> hnfmr: Depends on the thread type I guess.
20:26:02 <srhb> hnfmr: If it's a light thread, then that, if it's an OS thread, then that.
20:26:09 <pomdefrites> srhb: any other haskell tutorial gems?
20:26:23 <srhb> pomdefrites: You should look at the ones referenced in the #haskell-beginners topic
20:26:46 <srhb> pomdefrites: https://github.com/bitemyapp/learnhaskell 
20:27:35 <hnfmr> srhb: Ok, so it's OK to use threadDelay in a light thread? In C++ for example, it's not very wise to block the thread..
20:27:45 <pomdefrites> srhb: actually came across that earlier today from a hackernews thread
20:27:50 <srhb> hnfmr: Afaik yes.
20:28:08 <srhb> pomdefrites: I very much recommend it. Especially starting with cis194 and learning the core concepts through there. The approach is very sound.
20:30:25 <orion> Is there a better way to write this?: (unpack <$> lookup "foo" hs) >>= readMaybe
20:31:15 <johnw> join $ readMaybe . unpack <$> lookup "foo" hs
20:31:37 <quevan> how do I apply a function to unit? I basically don't understand why ghc spits out an error for this simple program: http://pastebin.com/imtBi76p
20:31:54 <jle`> quevan: what's the error?
20:31:55 <orion> johnw: Thank you.
20:32:05 <srhb> quevan: As you expect, foo ()
20:32:10 <quevan> jle`: The last statement in a 'do' block must be an expression
20:32:21 <jle`> ah, it doesn't have anything to do with function application
20:32:22 <orion> johnw: What makes that representation better?
20:32:30 <jle`> you have to indent the next line where the 'l' is in let
20:32:32 <johnw> nothing really
20:32:36 <jle`> otherwise it thinks that you're stil in the "let" block
20:32:41 <orion> heh, ok
20:32:45 <quevan> jle`: really?
20:32:48 <jle`> yeah
20:32:51 <jle`> let blocks can have more than one line
20:33:03 <johnw> it's even arguably worse
20:33:07 <jle`> so it waits for you to "duck" back into normal do-level
20:33:33 <jle`> orion: readMaybe . unpack =<< lookup "foo" hs
20:34:06 <orion> a ha!
20:34:13 <orion> jle`: :)
20:34:19 <quevan> jle`: I don't understand where I'm suppose to indent, sorry, this is basically my first time using haskell
20:34:36 <jle`> quevan: put the p in 'putStrLn' under the l in 'let'
20:34:53 <jle`> so it knows that you're done with let-ting
20:34:59 <srhb> quevan: http://lpaste.net/7942992365512294400
20:35:01 <quevan> jle`: hold on, is haskell sensitive to tabs/spaces here?
20:35:08 <srhb> quevan: Yes, always use spaces
20:35:38 <srhb> (or get ready for a world of pain)
20:35:39 <jle`> quevan: yeah, because "do" is a whitespace-based syntax construct
20:35:40 <srhb> :P
20:35:48 <jle`> you can do it without using 'do'
20:36:01 <jle`> but if you use do then it's whitepsace-sensitive
20:36:01 <quevan> jle`: that is kind of gross tbh. thank you for informing me of this though!
20:36:06 <jle`> nah
20:36:12 <jle`> it really isn't too bad :)
20:36:21 <jle`> it makes things a lot more expressive in a lot of ways
20:36:25 <srhb> It gives you a lot of flexibility. :) You just need to understand the rules, and they're simple.
20:36:29 <jle`> and after like a day or two you more or less forget about it
20:37:22 <cody`> How can I load *all* functions/data constructors in a module (even if they aren't exported) from `cabal repl`? I somehow had it working last night with ":set -fobject-code" but now it doesn't seem to work.
20:37:25 <quevan> any other "whitespace semantics" i should look out for in haskell then?
20:37:39 <srhb> quevan: http://en.wikibooks.org/wiki/Haskell/Indentation
20:37:55 <Welkin> quevan: install haskell-mode in emacs
20:37:58 <srhb> That's the best short guide I've seen. But really, you get used to it. Mostly making your code pretty will make it compile right. :-)
20:38:02 <Welkin> it will take care of the whitespace rules for you
20:38:07 <srhb> Welkin: Lies!
20:40:21 <LordBrain> can i tell cabal to link against an older version of a package than is present and satisfies the dependencies?
20:41:29 <Welkin> yes, in the .cabal file
20:42:18 <LordBrain> well i'm just installing from hackage, do you mean unpack and then modify it?
20:42:48 <Welkin> oh
20:42:53 <Welkin> I thought you meant your own package
20:42:54 <LordBrain> i just did a --force-reinstalls instead... probably screwed myself but oh well
20:44:12 <DrPavelheer> Question
20:44:19 <jle`> LordBrain: you're in a sandbox, right?
20:44:24 <LordBrain> lol
20:44:41 <LordBrain> it was such a tiny little package jle, i thought i could get by without that
20:44:43 <DrPavelheer> I ran a function on some stuff, and it returned something with a type of "m TestUser"
20:45:02 <DrPavelheer> Where m is a MonadResource
20:45:23 <DrPavelheer> Is it possible to get information about the TestUser?
20:45:34 <jle`> are you trying to install a binary?
20:45:41 <jle`> sandbox everhything :o
20:45:44 <jle`> there's almost no overhead/cost...
20:46:45 <srhb> DrPavelheer: MonadResource is also Monad
20:47:47 <DrPavelheer> srhb: Right
20:48:04 <srhb> DrPavelheer: So, >>= and friends :)
20:48:16 <DrPavelheer> Hmm
20:48:40 <DrPavelheer> If I have m a, and a function a -> b
20:48:41 <DrPavelheer> Oh
20:49:46 <DrPavelheer> srhb: My problem is that m is ambiguous
20:50:15 <srhb> DrPavelheer: Then you'll have to pick a concrete MonadResource
20:50:17 <cody`> can ghci/cabal repl load unexported names?
20:54:16 <srhb> DrPavelheer: Maybe some example code would help. :) My guess is you probably need a runResourceT somewhere, but it depends.
20:54:48 <DrPavelheer> There's an unfortunate lack of example code
20:55:33 <DrPavelheer> srhb: I'm using this: http://hackage.haskell.org/package/fb-1.0.10/docs/Facebook.html#g:1
20:55:53 <srhb> DrPavelheer: I meant, your code :)
20:56:14 <DrPavelheer> I'm unfamiliar with MonadResources, and I'm not sure how they come into play here
20:56:18 <DrPavelheer> Oh!
20:56:25 <DrPavelheer> I'm just in ghci right now
20:56:28 <srhb> Ah, okay.
20:57:27 <DrPavelheer> "let user1 = runFacebookT credentials manager testuser"
21:11:16 <Axman6> DrPavelheer: you know that doesn't actually ruyn the action right? it just assigns the name 'user1' to the expression runFacebookT credentials manager testuse
21:13:14 <Dan39> well im kinda surprised im learning haskell and liking it <_<
21:14:03 <Dan39> some weird things(mainly using that damn :), but some pretty neat things too.
21:14:11 <Dan39> unintended smily
21:14:25 <bitemyapp> Fylwind: is the colorizer yours?
21:14:33 <bitemyapp> Fylwind: it looks really cool, do you have a screenshot anywhere?
21:14:36 <creichert> Dan39: it's pretty fun, huh?
21:14:59 <Dan39> try Try it on home page is nice for sure
21:15:26 <Dan39> been using xmonad for years, never learned haskell at all... so bout time
21:15:43 <bitemyapp> Fylwind: wait, n/m, got it working.
21:16:07 <Fylwind> bitemyapp: it is :) http://i.imgur.com/phjXeA0.png
21:16:34 <bitemyapp> Fylwind: cool, looks like that matches what I saw on my machine.
21:17:01 <bitemyapp> Fylwind: you ever seen the colorization Idris provides? It's like getting smacked in the face with a (pleasant) starburst :)
21:17:27 <Fylwind> bitemyapp: I've not used it before :\
21:18:59 <bitemyapp> Fylwind: np np. Let me see if I can find a screenshot.
21:19:19 <bitemyapp> Fylwind: http://i.imgur.com/rYHCI4T.png
21:20:04 <Fylwind> ah, that's really nice; there aren't many interpreters with such sophisticated coloring built in
21:21:14 <bitemyapp> Fylwind: yeah, the idris community has taken a lot of care with tooling.
21:23:44 <LordBrain> take the idris talk to haskell-blah
21:24:55 <bitemyapp> LordBrain: apologies
21:38:16 <mjrosenb> is ther an up to date tutorial for FFI stuff in haskell>
21:42:30 <pacak> mjrosenb: What's wrong with existing ones? I don't recall any signficant changes to FFI recently.
21:45:19 <mjrosenb> pacak: the one I found on haskell wiki uses {-# INCLUDE..., which ghc complains about.
21:46:47 <pacak> CPP?
21:47:08 <unb3k44n7> Hello, All!
21:47:58 <pacak> mjrosenb: https://github.com/pacak/sqroll/blob/master/src/Database/Sqroll/Sqlite3.hs  - this code uses FFI and works with ghc 7.10
21:50:00 <fumieval> newtype M f = M { unM :: forall r. Monoid r => (f r -> r) -> r } -- looking for a nice name for this
21:51:24 <pacak> fumieval: How about Fumieval'sNewType?
21:53:17 <KaneTW> i'm not sure what that type is supposed to be
21:53:46 <KaneTW> without some restriction on f it looks uninhabited
22:01:22 <jle`> f is the type parameter though
22:01:46 <unb3k44n7> What does Integral a => a mean?
22:02:13 <jle`> unb3k44n7: it's a type signature for a value of type `a`, where `a` is an instance of the Integral typeclass
22:02:34 <jle`> meaning `a` has all of the methods from the INtegral typeclass (and the Num typeclass, too) defined
22:03:37 <jle`> KaneTW: so something like maybe myM = M (\f -> f Nothing) :: M (Maybe Int) would be an inhabitant
22:03:47 <unb3k44n7> So if I typed something and I got that response that means I at least typed something in properly?
22:04:37 <jle`> it depends on what you were typing in and where
22:04:44 <jle`> but, probably
22:05:26 <pavonia> At least something that has a valid type
22:06:08 <orion> What's the best way to rewrite this code?: (isEmptyMVar cv >>= (\x -> return (not x)))
22:06:28 <jle`> orion: not <$> isEmptyMVar cv, maybe?
22:06:34 <jle`> or fmap not (isEmptyMVar cv)
22:06:58 <fumieval> `M` is a monoid (mempty = M (const mempty), mappend (M f) (M g) = M $ \h -> f h `mappend` g h)
22:07:57 <orion> jle`: A ha! Thank you.
22:08:07 <unb3k44n7> Kind of excited. That means I typed my first haskell thing that I made up properly. 
22:08:11 <fumieval> and you can "lift" things: f (M f) -> M f just like the Fix type
22:08:39 <unb3k44n7> Although I still don't know what it means at least it was right. 
22:09:49 <jle`> congrats unb3k44n7 :D
22:10:11 <jle`> hopefully whatever course you are taking will teach you about typeclasses soon :)
22:10:20 <johnw> unb3k44n7: the first step of a hopefully long and fruitful journey!
22:12:20 <unb3k44n7> I'm reading about that now, jle. :)
22:17:06 <jle`> :D
22:17:52 <unb3k44n7> I wish someone was sitting here to explain everything im reading. lol
22:19:36 <P1RATEZ> that's possible
22:20:05 <arkeet> unb3k44n7: well, feel free to ask in here :p
22:21:20 <P1RATEZ> http://www.pythontutor.com uses the togetherjs lib to allow something like https://togetherjs.com/examples/drawing, i'm sure haskell.com can implement something similar :) in a sandbox environment
22:27:30 <unb3k44n7> arkeet: Id be asking a question like every 2 seconds. 
22:28:09 <arkeet> asking questions is a great way to learn
22:28:31 <jle`> unb3k44n7: we have nothing better to do than answer haskell questions so feel free to ask away
22:28:42 <mmachenry> Yeah why else would we be in this channel
22:31:47 <bitemyapp> mmachenry: the cookies
22:32:14 <unb3k44n7> If == is equality then what's /==?
22:32:32 <kadoban> > 1 /= 2
22:32:34 <lambdabot>  True
22:32:40 <jle`> (/=) is not equals, like !=
22:33:35 <unb3k44n7> What does it mean with the / next to it?
22:33:40 <unb3k44n7> What is that saying?
22:33:53 <mmachenry> unb3k44n7: It's supposed to look the the = with a slash through it
22:33:56 <jle`> oh, it's just the name of an operator
22:34:22 <unb3k44n7> I dont know what that is either, mmachenry
22:34:28 <jle`>  (/=) is an operator, like (&&), and, or (||), or
22:34:30 <mmachenry> ≠
22:34:35 <jle`> have you ever used any programming languages in the past?
22:34:36 <mmachenry> Do you see that? 
22:34:39 <arkeet> /= is the name of an operator
22:34:40 <arkeet> like ==
22:34:45 <arkeet> or +
22:34:46 <arkeet> or any other operator
22:34:51 <unb3k44n7> I know but they do different things
22:34:54 <jle`> they could have named it &*^&$@= if they wanted to
22:34:59 <arkeet> /= is "not equals"
22:34:59 <mmachenry> unb3k44n7: Do you know != from C or Python or something? 
22:35:07 <arkeet> like != in other languages
22:35:09 <unb3k44n7> Ugh.
22:35:21 <arkeet> :t (/=)
22:35:22 <lambdabot> Eq a => a -> a -> Bool
22:35:23 <arkeet> > 5 /= 6
22:35:27 <lambdabot>  True
22:35:40 <jle`> > 5 == 6
22:35:42 <lambdabot>  False
22:35:58 <jle`> > True && False
22:35:59 <lambdabot>  False
22:36:09 <jle`> > True || False
22:36:10 <lambdabot>  True
22:36:12 <jle`> > 4 * 6
22:36:13 <lambdabot>  24
22:36:18 <jle`> *, ||, &&, ==, /=, are all operators
22:36:56 <jle`> the / has no special syntactical meaning, if that's what you mean
22:37:05 <jle`> it's just another ol' character like =, or &, or *
22:37:22 <unb3k44n7> I get that 5 == 5 is True. But why is 5 /= 5 False? It must have a meaning if it's changing the result?
22:37:44 <arkeet> because "5 does not equal 5" is false
22:38:16 <unb3k44n7> So / means "does not?"
22:38:21 <unb3k44n7> Is that what it stands for?
22:38:33 <arkeet> /= is the name of the "not equals" operator
22:38:34 <arkeet> that's it
22:38:52 <arkeet> that's just what someone decided to call it in haskell
22:39:03 <jle`> yeah, it's like, + means "plus", - means "minus", * means "times", == means "equals", /= means "not equals"
22:39:07 <jle`> it's just an arbitrary name choice
22:39:20 <unb3k44n7> Got it!
22:39:48 <arkeet> / doesn't mean anything on its own
22:40:01 <arkeet> (well, if you use it by itself then that's division but that's unrelated)
22:40:37 <opqdonut> /= is just a fancy way of typing the not equals sign, ≠
22:40:50 <unb3k44n7> I got it now Opq. :)
22:40:59 <mmachenry> opqdonut: I'd say it's less fancy. :)
22:41:11 <mmachenry> ≠ is clearly the fanciest not-equal operator.
22:41:13 <opqdonut> yeah fancy is probably the wrong word
22:41:15 <pharaun> lol
22:41:21 <arkeet> @let (≠) = (/=)
22:41:23 <lambdabot>  Defined.
22:41:23 <jle`> there are some libraries that define (≠) = (/=) for you so you can type in ≠ if you wanted
22:41:23 <arkeet> > 5 ≠ 6
22:41:25 <lambdabot>  True
22:41:27 <opqdonut> I quite enjoy prolog's =/=
22:41:39 <unb3k44n7> Also, what's the difference between => and -> and what reason/why can they go the opposite way like <=
22:41:50 <jle`> @let (=/=) = (≠)
22:41:51 <lambdabot>  Defined.
22:41:54 <arkeet> those are special syntax
22:41:55 <jle`> > 5 =/= 6
22:41:56 <arkeet> not operators
22:41:57 <lambdabot>  True
22:42:11 <opqdonut> unb3k44n7: => and -> are used in types, <= is merely the familiar comparison operator
22:42:12 <arkeet> in a type, -> is the function arrow
22:42:14 <opqdonut> > 6 <= 7
22:42:16 <lambdabot>  True
22:42:17 <arkeet> => is for class constraints
22:42:19 <opqdonut> > 6 <= 5
22:42:21 <lambdabot>  False
22:42:24 <opqdonut> > 6 >= 5
22:42:25 <arkeet> (well, constraints)
22:42:26 <lambdabot>  True
22:42:44 <arkeet> <- is a different piece of syntax (used in do notation, for example)
22:42:52 <arkeet> <= is just the "less than or equal" operator
22:43:42 <unb3k44n7> And the function arrow is mostly used with Chars?
22:43:51 <arkeet> it has nothing to do with chars
22:44:13 <arkeet> any function has a -> in its type.
22:44:17 <jle`> something of type `Int -> Bool` is a function taking an Int and returning a Bool, for example
22:44:56 <unb3k44n7> You can use it with numbers then too
22:45:38 <jle`> mhm, you can make a type of a function between any two types
22:45:52 <jle`> (types which have values of that type)
22:46:31 <arkeet> :t \x -> x < (5 :: Int)
22:46:32 <lambdabot> Int -> Bool
22:46:39 <arkeet> :t chr
22:46:40 <lambdabot> Int -> Char
22:46:45 <arkeet> :t putStrLn
22:46:46 <lambdabot> String -> IO ()
22:47:20 <unb3k44n7> Ok.
22:47:27 <Birch> Actually, I've got a question there. Something that's always 'bugged' me is that difference between takes-a and returns-a in the type declaration of a function. I feel like I'm missing something, and that saying "Int -> Int -> Bool takes an Int, and takes an Int, and returns a Bool" is just a mnemonic to help people coming from Java backgrounds or something.
22:47:30 <arkeet> (don't forget that -> has a someother uses with unrelated meanings though)
22:47:32 <Birch> Is there a deeper understanding there?
22:47:33 <arkeet> (e.g. with case)
22:47:48 <Birch> For example, I like thinking of it more like "Int -> (Int -> Bool)"
22:47:54 <Birch> (though that's different)
22:47:56 <arkeet> that is correct
22:47:57 <arkeet> they are the same.
22:48:08 <Birch> oh.
22:48:10 <Birch> Well then.
22:48:12 <arkeet> :-)
22:48:23 <arkeet> all functions in haskell really take one argument.
22:48:47 <Birch> So then does this go (meaningfully) further? "Int -> (Int -> (Bool))"?
22:49:03 <arkeet> well, not really any point putting parentheses around an atom :p
22:49:11 <Birch> Right.
22:49:56 <arkeet> x -> y is the type of a function that can be applied to a value of type x, resulting in a value of type y.
22:50:10 <arkeet> if you have some Int -> Int -> Bool (which is Int -> (Int -> Bool))
22:50:18 <Birch> I guess more for illustrative purposes. Is it like a function that takes an Int, and returns a function which takes an int, which returns a nullary function that returns a Bool?
22:50:27 <Birch> Or isOr does it not quite go that last step?
22:50:32 <jle`> "nullary function" doesn't really mean anything in haskell
22:50:33 <arkeet> "nullary function" isn't a thing
22:50:38 <Birch> Cool.
22:50:44 <Birch> Thanks for the clarification :)
22:50:48 <arkeet> all functions take exactly one argument
22:50:51 <jle`> a function in haskell is defined as something of a type using the type constructor (->)
22:50:57 <arkeet> (if it can't take any arguments, it's not a function)
22:51:04 <jle`> so something of type Int -> Bool is a function; something of type Int is not
22:51:09 <jle`> because (->) literally means "function" :)
22:51:14 <Birch> Right, so the type constructor (->) takes the left side, and returns the right side.
22:51:58 <Birch> Which is the "deeper understanding" I was looking for -- it's not that a shedload of chained (->) changes the meaning of whether or not something takes the type or returns the type.
22:52:15 <Birch> Hm...
22:52:16 <arkeet> yeah, -> is just a binary thing.
22:52:21 <Birch> > :k (->)
22:52:22 <lambdabot>  <hint>:1:1: parse error on input ‘:’
22:52:25 <arkeet> :k (->)
22:52:26 <lambdabot> * -> * -> *
22:52:37 <Birch> oh I see.
22:52:44 <jle`> Birch: you might be looking for the fact that any Int -> Int -> Bool is equivalent/isomorphic to an (Int, Int) -> Bool
22:52:52 <unb3k44n7> I dont get the ord function of comparing two words
22:52:53 <arkeet> (almost)
22:53:02 <jle`> fast and loosely ;)
22:53:05 <arkeet> :)
22:53:31 <jle`> any (Int, Int) -> Bool can be written/encoded as an Int -> Int -> Bool, and vice versa
22:53:34 * hackagebot list-t-libcurl 0.3.0.0 - A "libcurl"-based streaming HTTP client  http://hackage.haskell.org/package/list-t-libcurl-0.3.0.0 (NikitaVolkov)
22:53:39 <jle`> so they really "represent" the same idea
22:53:55 <jle`> (up to the bottoms they might contain)
22:53:56 <arkeet> this is called currying.
22:53:58 <unb3k44n7> If there is a word with more characters in it and there is a less than sign then a word with less characters how is that True?
22:54:20 <arkeet> > "abc" < "b"
22:54:22 <lambdabot>  True
22:54:27 <jle`> > "elephant" < "zzz"
22:54:29 <lambdabot>  True
22:54:29 <Birch> Yeah, I'm happy enough with that. My questions was about how the "shape" of functions changes based on arity -- everything before the last thing was the argument, and the last thing was the return... but that seemed to be something just to make people familiar with function calls in other languages seem happy, not really what was happening under the hood
22:54:37 <kadoban> unb3k44n7: Strings are compared lexicographically.
22:54:47 <arkeet> "lexicographically" is a fancy term for "dictionary order"
22:54:48 <unb3k44n7> But why is that true. The first word is clearly greater?
22:54:52 <unb3k44n7> Ohhhhhh
22:54:58 <jle`> well, it's just however you want to define comparison
22:55:00 <Birch> But the kind of (->) and order of precedence answer my question.
22:55:12 <jle`> this is how they're compared in dictionaries, for instance
22:55:12 <unb3k44n7> It's comparing them alphabetically
22:55:14 <unb3k44n7> Haha
22:55:16 <jle`> yeah
22:55:19 <jle`> :)
22:55:20 <arkeet> > [1,2,3] < [2,2]
22:55:22 <lambdabot>  True
22:55:22 <unb3k44n7> I wish it would have said that...
22:55:26 <arkeet> it compares the first elements first.
22:55:34 <arkeet> if they are equal, then it moves onto the second elements.
22:55:34 <arkeet> etc
22:58:38 <arkeet> > sortBy (comparing length <> compare) ["ab","abc","elephant","zzz","b"]
22:58:39 <lambdabot>  ["b","ab","abc","zzz","elephant"]
23:00:01 <arkeet> the Monoid instance for Ordering is handy.
23:00:55 <unb3k44n7> Does :: basically mean "means?"
23:01:11 <arkeet> "x :: t" means "x has type t"
23:01:12 <jle`> "has the type"
23:01:12 <unb3k44n7> Like if you're reading the symbol outloud
23:01:14 <kadoban> unb3k44n7: "is type of" or something.
23:01:24 <unb3k44n7> Ok.
23:01:31 <arkeet> (where x is a value and t is a type)
23:01:34 <kadoban> Or maybe "is of type" is better, heh.
23:08:59 <rcyr> Hi, what would be the best documentation/tutorial about the "new cool stuff" like Foldable and Traversable
23:10:19 <pacak> ghc documentation is nice. 
23:10:42 <kadoban> rcyr: typeclassopedia mentions traversable I believe. I can't remember if foldable is in there.
23:11:31 <rcyr> pacak: I thought the ghc doc would be a bit too dry for me but I'll take a look
23:12:04 <rcyr> kadoban: It does... for some reason, I had forgot about it
23:12:22 <unb3k44n7> Isn't boolean kind of redundant? 
23:12:41 <pacak> rcyr: It is a bit dry, yes, but there's nothing especially cool in those two.
23:12:51 <pacak> :t foldMap
23:12:52 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
23:12:54 <pacak> :t traverse
23:12:55 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
23:13:01 <kadoban> unb3k44n7: Why would it be?
23:13:48 <pacak> > traverse (\x -> if odd x then Just x else Nothing) [1,2,3]
23:13:49 <lambdabot>  Nothing
23:13:54 <pacak> > traverse (\x -> if odd x then Just x else Nothing) [1,5,3]
23:13:55 <lambdabot>  Just [1,5,3]
23:14:18 <pacak> > getSum $  foldMap Sum [1..10]
23:14:20 <lambdabot>  55
23:14:34 <pacak> rcyr: That's basically all you need to know.
23:14:40 <rcyr> pacak: Wow, seriously?
23:14:48 <unb3k44n7> What's the word that means having no beginning or end? Boolean is kind of that also.
23:15:10 <kadoban> infinite? I'm not really sure what you're getting at.
23:15:20 <arkeet> Bool is quite not infinite.
23:15:23 <xelxebar> unb3k44n7: unbounded?
23:15:27 <arkeet> or that.
23:16:18 <pacak> rcyr: More or less. Check the docs.
23:16:20 <arkeet> Bool is just a type with two values, namely False and True.
23:16:24 <xelxebar> kadoban: the interval [-1,1] is (uncountably) infinite and could still be said to have a beginning and end...
23:16:52 <pacak> > length [-1 .. 1]
23:16:53 <lambdabot>  3
23:17:33 <kadoban> xelxebar: I'm aware it doesn't technically fit, it was just the closest word I could think of
23:17:57 <unb3k44n7> Paradoxical!
23:18:22 <unb3k44n7> That's the word. Like, boolean is kind of redundant and paridoxical.
23:19:11 <xelxebar> pacak: lol. By 'interval`, I really mean { r \in R : r >= -1, r <= 1 }
23:19:34 <pacak> xelxebar: :)
23:19:39 <kadoban> unb3k44n7: I still don't understand what would make you say that.
23:20:20 <unb3k44n7> Because in boolean, && is boolean, but so is || and then implying not. But if you're looking for a True or False, True or False means Boolean too.
23:20:30 <unb3k44n7> Trying to find a better way to explain it..
23:21:16 <kadoban> True is a value of type Bool, as is False.   (&&) is a function that takes two Bools and yields another Bool  (Bool -> Bool -> Bool), same with (||), etc.
23:24:12 <unb3k44n7> When using two bools in a string with the boolean function && or ||will is always yield the latter bool?
23:24:19 <unb3k44n7> it*
23:25:04 <unb3k44n7> It seems like it always does but why does it choose the latter bool?
23:25:14 <pavonia> What are "bools in a string"?
23:25:16 <kadoban> unb3k44n7: Can you show using code what you mean?
23:25:38 <Rotaerk> sounds almost like mysticism
23:26:20 <unb3k44n7> Like, True && False yields a False and FAlse || True yields a true. 
23:26:30 <jle`> False && True
23:26:35 <jle`> > False && True
23:26:36 <lambdabot>  False
23:26:46 <jle`> > True || False
23:26:47 <lambdabot>  True
23:26:59 <unb3k44n7> If && and || are the same thing it showing that its favoring the latter bool, as in the latter of the two bools. Bools being True or False.
23:27:11 <kadoban> unb3k44n7: They're not the same thing?
23:27:20 <unb3k44n7> Wait, so what you just did there. || isn't thesame as &&
23:27:23 <kadoban> && is boolean 'and', || is boolean "or"
23:27:40 <kadoban> They just have the same type. /many/ functions have the same type, they're not all the same function.
23:28:04 <unb3k44n7> Why does it choose what it chooses then?
23:28:10 <jle`> `x && y` is True if and only if both x and y are True
23:28:18 <jle`> `x || y` is True if either x or y are true, or both
23:28:25 <unb3k44n7> Like True or False. Why does Haskell choose True by default?
23:28:33 <jle`> what do you mean True by default?
23:28:44 <jle`> they're actually normal functions you can define, btw, haskell doesn't chose them
23:28:50 <jle`> @src (&&)
23:28:50 <lambdabot> True  && x = x
23:28:50 <lambdabot> False && _ = False
23:28:53 <jle`> @src (||)
23:28:53 <lambdabot> True  || _ =  True
23:28:53 <lambdabot> False || x =  x
23:28:58 <jle`> _ is a wildcard
23:29:27 <unb3k44n7> Like, what I'mseeing is you're asking the program True or false, or True || False. And the program is spitting out True.
23:30:01 <jle`> that's the "definition" of (||)
23:30:12 <kadoban> unb3k44n7: Hmm, I think you're misunderstanding what those functions are. Are you familiar with boolean algebra?
23:30:19 <jle`> x || y is True if either x or y are True, or both are True
23:30:23 <jle`> it's False if neither x nor y are True
23:30:26 <jle`> > False || False
23:30:28 <lambdabot>  False
23:30:41 <kadoban> It's not … picking one, it's giving you the only output it possibly could that follows the definition of the function.
23:30:50 <liste> > [False || False, False || True, True || False, True || True]
23:30:52 <lambdabot>  [False,True,True,True]
23:31:18 <liste> > [False && False, False && True, True && False, True && True]
23:31:20 <lambdabot>  [False,False,False,True]
23:31:22 <unb3k44n7> :/ I don't get this part.
23:31:40 <jle`> do you know how to define functions?
23:31:47 <jle`> hm.  or, do you know what functions ar?
23:31:49 <jle`> *are
23:31:50 <unb3k44n7> I don't know how It's the only output when I don't even see it as a question
23:31:57 <unb3k44n7> Er. Nevermind.
23:32:11 <jle`> functions take values and return an output based on rules
23:32:25 <jle`> (||) is a function that takes two Bool's, and returns a new Bool, based on the two it takes in
23:32:42 <unb3k44n7> I get that.
23:32:50 <jle`> the rule is, "if either one of the things i see is True, then return True.  if neither is true, i return False"
23:32:51 <unb3k44n7> But "why" does it return what it does.
23:33:01 <Rotaerk> because that's how it's defined
23:33:02 <jle`> hm, why was (||) chosen to be that way?
23:33:08 <jle`> why was it chosen to define that way?
23:33:08 <unb3k44n7> Sigh
23:33:23 <unb3k44n7> I don't know what It's defining if it means or.
23:33:25 <kadoban> unb3k44n7: https://en.wikipedia.org/wiki/Boolean_logic They're conjunction and disjunction
23:33:49 <jle`> on one level you can just think of it as an arbitrary function with arbitrary results for arbitrary inputs
23:34:02 <kadoban> ∧ and ∧
23:34:03 <jle`> but on another level you can look at the history of the logical 'or' operator
23:34:05 <unb3k44n7> I guess I just see it as an open ended command
23:34:11 <unb3k44n7> Like an unfinished sentence
23:35:04 <unb3k44n7> Like if you said in a sentence Italian or Dutch
23:35:28 <jle`> yeah, you can think of it in terms of propositional logic
23:35:37 <unb3k44n7> And then the program answered Italian
23:35:37 <jle`> "is it true that either x is odd, or x is greater than zero?"
23:35:46 <Myrl-chan> Non-canonical input in Haskell
23:35:57 <jle`> > odd 10 || (10 > 0)
23:35:58 <lambdabot>  True
23:36:10 <jle`> this is True if either "odd x" or "x > 0" is True
23:36:25 <jle`> > odd (-10) || (-10 > 0)
23:36:26 <f|`-`|f> inclusive or, btw
23:36:26 <lambdabot>  False
23:36:43 <kadoban> unb3k44n7: It's not the 'and' and 'or' from English, it's more formal. It's like (+) and (-), except it works on truth values (True, False)
23:36:46 <f|`-`|f> So it's either, or both
23:36:48 <jle`> "is it true that either x is odd, or x is greater than zero, or both?" is false, so it's False
23:37:11 <unb3k44n7> Sorry, jle. I'll have to keep thinking about it. I still don't get it. 
23:37:52 <Tehnix> Get the && and || operators?
23:38:01 <Myrl-chan> unb3k44n7: Do you know logic?
23:38:06 <jle`> i think &&/|| is understood...just not why they are named 'and' and 'or'
23:38:16 <jle`> but that's a bit unrelated to haskell :)
23:38:22 <Myrl-chan> Very unrelated. :P
23:38:35 <unb3k44n7> No.. I don't get why they yield what they do when comparing two bools
23:38:40 <jle`> oh
23:38:41 <Myrl-chan> Mostly because or in English is exclusive or.
23:38:43 <unb3k44n7> That's the whole issue.
23:38:44 <jle`> well then that's just a definition
23:38:47 <jle`> we can define our own function
23:39:06 <Myrl-chan> unb3k44n7: A simple definition is that and is true when both inputs are true
23:39:11 <jle`> @let or True True = True; or True False = True; or False True = True; or False False = False
23:39:12 <lambdabot>  Defined.
23:39:13 <Myrl-chan> unb3k44n7: And or is true when at least one input is true.
23:39:14 <jle`> > or True False
23:39:15 <lambdabot>      Ambiguous occurrence ‘or’
23:39:15 <lambdabot>      It could refer to either ‘L.or’, defined at L.hs:146:1
23:39:15 <lambdabot>                            or ‘Data.List.or’,
23:39:18 <jle`> darn
23:39:20 <jle`> @undefine
23:39:20 <lambdabot> Undefined.
23:39:38 <jle`> @let myOr True True = True; myOr True False = True; myOr False True = True; myOr False False = False
23:39:39 <lambdabot>  Defined.
23:39:41 <Rotaerk> unb3k44n7, are you saying that you don't get *how* they produce the values that they do, or that you don't get the *reason* they were designed that way?
23:39:42 <jle`> > myOr True True
23:39:43 <lambdabot>  True
23:39:44 <jle`> > myOr False True
23:39:45 <lambdabot>  True
23:39:47 <jle`> > myOr False False
23:39:49 <lambdabot>  False
23:39:50 <jle`> etc.
23:39:55 <jle`> it's just a function that someone defined somewhere
23:40:26 <jle`> do you see why myOr False False = False, and myOr False True = True?
23:40:31 <jle`> it's just because we literally defined myOr that way
23:40:31 <Myrl-chan> @let myOr' True _ = True; myOr _ True = True; myOr_ _ = False
23:40:34 <lambdabot>  .L.hs:144:1: Warning:
23:40:34 <lambdabot>      Pattern match(es) are overlapped
23:40:34 <lambdabot>      In an equation for ‘myOr’: myOr _ True = ...
23:40:40 <Myrl-chan> Hmm...
23:40:45 <unb3k44n7> Maybe both, Rotarek.
23:40:52 <Myrl-chan> > myOr' True False
23:40:54 <lambdabot>      Not in scope: ‘myOr'’
23:40:54 <lambdabot>      Perhaps you meant ‘myOr’ (line 144)
23:41:06 <Myrl-chan> Ah, fuck.
23:41:09 <jle`> heh
23:41:11 <Dan39> well this first book/tutorial has already dissapointed me. introduces /= but doesnt tell me that is "not equal". ive never seen /= be used for not equal, always !=, while /= is always "x divided by"
23:41:16 <Tehnix> Myrl-chan: you only had ' on the first myOr
23:41:17 <Myrl-chan> I'll go do this in private chat to avoid spamming. :P
23:41:25 <jle`> unb3k44n7: do you see how we defined 'myOr' to work the way it did?
23:41:35 <unb3k44n7> I get that true and true is true. false and false is false. but why is false or true false? And why is true and false false?
23:41:45 <jle`> because we defined it that way
23:41:49 <Tehnix> Dan39: it looks more like the mathmatical not equals sign
23:41:59 <jle`> myOr False True = True; myOr True False = True
23:42:11 <jle`> or is your question, why was it chosen to be defined that way?
23:42:14 <liste> unb3k44n7 consider the sentence "The earth is round or I am the president of the United States"
23:42:18 <Dan39> Tehnix: touche
23:42:37 <Myrl-chan> IMO, this one's more understandable.
23:42:43 <Rotaerk> unb3k44n7, you have it backwards; "false or true" is true
23:42:44 <kadoban> Dan39: https://github.com/bitemyapp/learnhaskell has good recommendations.   /= meaning what it does in C wouldn't really be possible in haskell, although yeah I can't say I really like the look of /=
23:42:52 <Myrl-chan> If I defined it in PM, does it also get defined here?
23:42:57 <jle`> yes :)
23:43:06 <Myrl-chan> Is there a way to get the definition?
23:43:09 <unb3k44n7> false or true is true. Right. Typo.
23:43:10 <jle`> nope
23:43:21 <jle`> you can test it in pm too though
23:43:26 <Myrl-chan> IMO, this is way more understandable. myOr'' True _ = True; myOr'' _ True = True; myOr'' _ _ = False
23:43:36 <Rotaerk> unb3k44n7, or means "at least one is true".  and means "all are true"
23:43:55 <Myrl-chan> Basically, this says that if any of the inputs are true(and the other input doesn't matter,) then it's true.
23:43:58 <jle`> unb3k44n7: do you see how we literally defined 'myOr' to have myOr False True = True ?
23:44:08 <jle`> unb3k44n7: it's just written in a source file somewhere
23:44:20 <jle`> that's *how* it produces the value
23:44:32 <unb3k44n7> I don't know what mrOr means. But that Rotarek said answered my question :)
23:44:34 <Myrl-chan> Of course, me saying that my version's understandable is very subjective. :P
23:44:41 <jle`> myOr is a function we defined
23:44:45 <jle`> like foo
23:44:47 <jle`> @let foo x = x * 2
23:44:48 <lambdabot>  Defined.
23:44:52 <Tehnix> unb3k44n7: in an english sentence "you can go to the store if you have either done your homework or cleaned your room"
23:44:57 <Tehnix> would be or
23:44:58 <jle`> here, we defined a function foo that multiplies its input by two
23:45:20 <jle`> @let myOr True True = True; myOr True False = True; myOr False True = True; myOr False False = False
23:45:21 <lambdabot>  .L.hs:145:1: Warning:
23:45:21 <lambdabot>      Pattern match(es) are overlapped
23:45:21 <lambdabot>      In an equation for ‘myOr’:
23:45:31 <jle`> here i defined a function myOr that looks up the result based on the inputs
23:45:36 <jle`> they're just arbitrary functions
23:45:48 <unb3k44n7> I get it now. What Rotarek said
23:45:55 <jle`> if you try to do "myOr True False", haskell well look, "oh hey, we defined myOr True False = True.  so the answer is True"
23:45:55 <Myrl-chan> < Myrl-chan> unb3k44n7: A simple definition is that and is true when both inputs are true < Myrl-chan> unb3k44n7: And or is true when at least one input is true.
23:46:02 * Myrl-chan shrugs
23:46:03 <unb3k44n7> Thank you though jle. :)
23:46:07 <jle`> np :)
23:46:47 <jle`> you can apply similar thinking ot "and", if you want to know *why* it was defined that way.  "it is raining and it is thursday"
23:46:53 <jle`> this statement is only true if it is raining and it is thursday
23:46:58 <jle`> if it's raining and it's friday, then that statement is no true
23:47:05 <jle`> if it's sunny and it's thursday, then that statement is also not true
23:47:12 <Myrl-chan> Mhm.
23:47:12 <jle`> if it's sunny and it's friday, then that statement is also not true
23:47:18 <Rotaerk> unb3k44n7, there is even a pair of functions in haskell called "and" and "or" which take *lists* of bools
23:47:32 <jle`> but as for "how", then it's just a normal arbitrary function defined somewhere in a source file in haskell, in regular haskell
23:47:36 <jle`> it's not defined by the compiler
23:47:37 <Myrl-chan> Be careful NOT to think of English `or` though, considering that is exclusive or.
23:47:49 <unb3k44n7> He said or, or || means at least one is true. And, and && means all are true. :) 
23:48:00 <Myrl-chan> "Bring this or that", usually means you bring either this, or that, not both of them, in English.
23:48:15 <Rotaerk> unb3k44n7, and what I said holds true for them as well... if *any* of the bools in the list passed to "or" is true, then the result is true.  if *all* of the bools in the list passed to "and" are true, then the result is true
23:48:27 <f|`-`|f> :t any
23:48:29 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
23:49:09 <f|`-`|f> > any (id) (repeat False)
23:49:13 <lambdabot>  mueval-core: Time limit exceeded
23:49:29 <jle`> any id == or  ?
23:49:40 <Myrl-chan> Seems so.
23:49:41 <f|`-`|f> yes :^)
23:49:46 <Myrl-chan> :t or
23:49:48 <lambdabot> Foldable t => t Bool -> Bool
23:49:53 <Myrl-chan> Yeah.
23:50:06 <f|`-`|f> :t and
23:50:07 <lambdabot> Foldable t => t Bool -> Bool
23:50:14 <Myrl-chan> Welp, better fix my code using `or . map` then. :P
23:50:20 <f|`-`|f> because all (id) is too much
23:50:23 <Rotaerk> > and [5 > 0, 0 > 5]
23:50:25 <lambdabot>  False
23:50:26 <Rotaerk> > or [5 > 0, 0 > 5]
23:50:28 <lambdabot>  True
23:50:30 <unb3k44n7> And clearly the 'not' boolean stands for reverse psychology. Lol.
23:50:35 <unb3k44n7> ..sorry bad joke.
23:50:40 <jle`> :)
23:50:46 <Myrl-chan> Lol.
23:50:55 <f|`-`|f> So which one asks you about your mother?
23:51:23 <Myrl-chan> Soooo~ how would one do noncanonical input in Haskell?
23:51:33 <Myrl-chan> hSetBuffering stdin NoBuffering ?
23:51:55 <dedgrant> unb3k44n7: I like making up stories to get intuition about a concept.. for instance:
23:51:56 <dedgrant> > let intrusionStatus = [False, False, False, False] in (if or intrusionStatus then "INTRUDER ALERT!" else "All clear.")
23:51:58 <lambdabot>  "All clear."
23:52:16 <dedgrant> > let intrusionStatus = [False, True, False, False] in (if or intrusionStatus then "INTRUDER ALERT!" else "All clear.")
23:52:18 <lambdabot>  "INTRUDER ALERT!"
23:52:24 <f|`-`|f> oh no
23:52:25 <jle`> Myrl-chan: i do that :3
23:52:28 <Myrl-chan> dedgrant: `if or` that sounds so wrong to me, coming from a Lua background. Lol.
23:53:19 <dedgrant> Myrl-chan: if (or intrusionStatus) then ("INTRUDER ALERT!") else ("All clear.")  ? :)
23:53:24 <unb3k44n7> I'm not sure what you did there with the format but that was kind of awesome.
23:53:27 <Myrl-chan> dedgrant: Yep. :P
23:53:56 <Myrl-chan> unb3k44n7: Basically, this returns "INTRUDER ALERT" if any of the intrusionStatus is true.
23:54:06 <unb3k44n7> So you named it intrusion status. is the word "else" a function?
23:54:40 <Myrl-chan> I don't think `if` `then` and `else` is a function, but this is Haskell we're talking about.
23:54:49 <Hafydd> unb3k44n7: it sounds like you need to read some basic documentation of Haskell's syntax.
23:55:00 <dedgrant> unb3k44n7: if/then/else in haskell are just keywords sadly.
23:55:06 <Hafydd> I suggest <http://www.haskell.org/onlinereport/haskell2010>.
23:55:08 <Myrl-chan> dedgrant: I like how you said "sadly" there. :P
23:55:22 <dedgrant> ;)
23:55:36 <unb3k44n7> So you're using if then and else just for you to follow along with what you're typing and Haskell negates them so it doesn't matter if they're typed?
23:55:40 <Myrl-chan> Though, it's not entirely impossible.
23:56:08 <Myrl-chan> if/then/else CAN be defined as a function, but you'd have to use mroe parentheses.
23:56:31 <Myrl-chan> myIf :: a -> b -> c -> a -> a
23:56:42 <dedgrant> unb3k44n7: You can open a private chat with lambdabot to experiment with the code a bit. My question to you is, for the intrusion detector code above, why did I use 'or' instead of 'and'? Which is the correct (secure!) option and why?
23:56:42 <unb3k44n7> I did use the word function wrong. Sorry. Intruder alert and All clear were your "functions"
23:57:36 <Myrl-chan> Err, wait. `myIf :: Bool -> b -> a -> c -> a -> a`
23:57:55 <Myrl-chan> myThen :: b; myElse -> c;
23:58:02 <Myrl-chan> myElse :: c;*
23:58:02 <jle`> `if x then y else z` is an expression that evaluates to y if x is True and evaluates to z if x is False
23:58:17 <dedgrant> unb3k44n7: You could call them expressions. Specifically, expressions that evaluate to strings.
23:58:26 <jle`> `if True then 0 else 10` is literally identical to `0`
23:58:36 <Myrl-chan> So yeah, it's possible to define it as a function.
23:58:37 <jle`> `if False then 0 else 10` evaluates to `10`
23:58:50 <Myrl-chan> Why would one do that? I dunno, and I don't want to know.
