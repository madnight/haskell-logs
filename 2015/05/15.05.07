00:04:14 <kadoban> Are there graph algorithms that work on Data.Graph hiding somewhere? Simple stuff like shortest path, etc.
00:05:40 <yoh> test
00:06:10 <jle`> "Error in array index" when using Data.Vector and i never even do any unsafe indexing
00:06:14 <jle`> @flip table
00:06:14 <lambdabot> *SMACK*, *SLAM*, take that table!
00:07:40 * hackagebot clash-prelude-quickcheck 0.1.2.0 - QuickCheck instances for various types in the C»aSH Prelude  http://hackage.haskell.org/package/clash-prelude-quickcheck-0.1.2.0 (JohnEricson)
00:07:40 * hackagebot mockery 0.1.0 - Support functions for automated testing  http://hackage.haskell.org/package/mockery-0.1.0 (SoenkeHahn)
00:22:42 * hackagebot network 2.6.1.0 - Low-level networking interface  http://hackage.haskell.org/package/network-2.6.1.0 (JohanTibell)
00:22:47 <ronh-> how do I add Show constraint to a? data AnyFoo = forall a . AnyFoo (Foo a)
00:25:28 <ronh-> nevermind, got it. data AnyFoo = forall a . (Show a) => AnyFoo (Foo a)
00:29:05 <dmwit> ronh-: It is generally considered bad form to do this.
00:29:16 <dmwit> Instead, put the Show constraint on the functions that need it.
00:29:27 <dmwit> uh
00:29:36 <dmwit> Well, ignore me. I didn't read carefully.
00:29:38 <ronh-> my code doesn't compile without that show constraint
00:29:42 <dmwit> For existentials there's not much choice.
00:29:42 <ronh-> :)
00:29:46 <ronh-> yeah
00:30:00 <dmwit> Then again, there's a different piece of advice for existentials like that.
00:30:10 <jle`> hm. runghc seems to work fine, but compiling and running with ghc has everything exit with a !! out of index error
00:30:26 <dmwit> Namely, why not just use type AnyFoo = ShowS?
00:31:22 <ronh-> AnyFoo is far more complex than that. I need Show constraint so I can serialize a
00:31:56 <dmwit> All you can do with an AnyFoo is call show (or shows, or showsPrec) on it.
00:32:03 <dmwit> So why not just keep around the output of show?
00:32:20 <dmwit> Or keep around the output of showsPrec, if you really need all the fanciness it provides.
00:33:54 <dmwit> So: there is not much difference between what you can do with the value (AnyFoo x) vs. what you can do with the value (flip showsPrec x), and the latter doesn't need any fancy type gymnastics. So why not use the latter?
00:34:01 <ronh-> I can do more. Foo looks something like this (simplified): data Foo a = { getFoo :: String -> a, useFoo :: a -> Something }
00:34:25 <ronh-> so AnyFoo can call useFoo (getFoo ..) without knowing what a is, or having a constraint
00:35:52 <dmwit> String -> (Something, Int -> ShowS)...
00:36:39 <ronh-> hmm, that is true!
00:37:56 * hackagebot filediff 1.0.0.1 - Diffing and patching module  http://hackage.haskell.org/package/filediff-1.0.0.1 (bgwines)
00:40:19 <dfeuer> dmwit, if I have a free magma over a magma, representing an expression, I can "collapse" it down to the underlying magma, by the definition of free magma (collapsing can be defined as splitting (or whatever you call it) id through the free structure)
00:40:32 <dfeuer> And similarly for free semigroups over semigroups.
00:40:56 <dfeuer> But now for my porpoises, I want to consider a free magma over a semigroup an "expression",
00:41:10 <dfeuer> and I can't see any obviously nice algebraic explanation of that.
00:41:36 <dmwit> What does "splitting id through the free structure" mean?
00:41:37 <dfeuer> That would give a reason for the left-to-right transformation from free magma to free semigroup 
00:41:46 <dfeuer> dmwit, what I mean,
00:41:50 <dfeuer> whatever the right words are,
00:42:27 <dfeuer> is that a free magma over a set S consists of a magma, FM(S), combined with an injection inj, 
00:42:37 <dfeuer> inj : S -> FM(S)
00:43:36 <dfeuer> Such that for any magma Q and any function f:S->Q, there is a unique morphism g:FM(S)->Q such that g.inj=f
00:44:01 <dfeuer> If I choose f=id, then I get this "collapsing" thing I'm talking about.
00:44:14 <dmwit> Yeah, okay.
00:44:26 <kadoban> Magma sounds much cooler than it actually is. Wonder why it got called that.
00:44:27 <dfeuer> I don't actually know if taht's a sane way to think about anything
00:44:38 <dfeuer> kadoban, agreed.
00:44:40 <dmwit> You can do this for free magmas over semigroups by considering the forgetful functor that maps a semigroup to its corresponding magma.
00:44:56 <dfeuer> dmwit, I've *heard* of forgetful functors.
00:45:13 <dmwit> Forgetful functors are just fancy id's. =)
00:45:32 <jle`> cool i built a PDE solver using comonads
00:45:39 <jle`> and solved laplace's equation
00:45:57 <jle`> worked surprisingly well once i got the infrastructure up
00:46:09 <dmwit> dfeuer: Okay, you aren't even really taking "id" to be "f" in your thing.
00:46:21 <dfeuer> dmwit, eh?
00:46:26 <dmwit> dfeuer: Because "S" is already a magma, right? So it's not just a set, it's a set with an operation.
00:47:37 <dmwit> Well.
00:47:38 <dfeuer> dmwit, yeah, but I can ignore that, and form a free magma over it, and then see that there's only one way back.
00:47:50 <dmwit> "ignore that" is what a forgetful functor does?
00:47:56 <dmwit> s/?/./
00:47:57 <dfeuer> I dunno!
00:48:03 <dmwit> Not a question. Just a typo.
00:48:23 <dmwit> Anyway. A lot of nonsense terminology that just means what I'm saying is "you can use the exact same construction".
00:48:35 <dfeuer> Can you explain a drop more?
00:48:44 <dmwit> Sure. Any semigroup is a magma, right?
00:48:48 <dfeuer> Yes.
00:49:18 <dmwit> So if S is a semigroup in your definition above, you can still consider the function id : S -> S as a mapping from a set into a magma.
00:49:36 <dfeuer> OK...
00:49:44 <dmwit> ...which gives you a unique morphism g:FM(S) -> S
00:50:10 <dmwit> ...which is an "evaluation" function for a free magma over a semigroup.
00:50:13 <dfeuer> Yeah.
00:50:20 <dfeuer> The trouble is
00:50:46 <dfeuer> what I want to get to is the nice "reassociation" function from FM(S) to FS(S).
00:51:10 <dfeuer> I know how to write it, and I know how to prove that it preserves evaluation,
00:51:24 <dfeuer> but I don't know what distinguishes it particularly, if anything.
00:52:19 <dmwit> Why would you want to go to FS(S)?
00:52:57 <dmwit> I mean, it shouldn't be hard. You've got an injection S -> FS(S) that you can plug into your universal construction above and get out g:FM(S) -> FS(S).
00:53:00 <dmwit> But... why?
00:53:54 <dfeuer> dmwit, because if I have two values in the free magma, I can reassociate both to get to the free semigroup, at which point I can prove they're the same.
00:54:20 <dfeuer> So if I have two expressions parenthesized differently, I can show they represent the same thing.
00:54:23 <dmwit> You can do that without any assumption about the underlying thing being a semigroup.
00:55:05 <dfeuer> True, but it will only preserve evaluation when it is a semigroup.
00:55:15 <dfeuer> But let's say we don't assume a semigroup.
00:55:38 <dfeuer> Is there a nice way to distinguish the "order-preserving" mapping?
00:56:05 <dmwit> Yes, as I said above, it is the universal construction's output when you plug in the free semigroup's injection.
00:58:15 <dfeuer> dmwit, I'm a little confused. Universal with respect to what property?
00:58:56 <ronh-> here is my actual code, a bit stripped down and simplified. http://lpaste.net/132140   I would love to get away from GADTs, but I am not sure if it is possible, and if it is whethere I would lose some functionality
00:59:02 <dmwit> The free semigroup's injection approximately has the type inj : S -> FS(S), right?
00:59:05 <dmwit> And FS(S) is a magma.
00:59:15 <dfeuer> dmwit, yes.
00:59:20 <dfeuer> Oh wait....
00:59:22 <dmwit> So the definition of free magma gives you a unique morphism g : FM(S) -> FS(S) from that.
00:59:50 <dfeuer> Ohhhhhhh
01:00:11 <dfeuer> I think.
01:00:22 <dfeuer> I was very close to that a couple times, but kept thinking it wasn't working.
01:00:40 <dfeuer> But yeah.
01:00:48 <dfeuer> Yeah yeah, I think you all right.
01:01:18 <dfeuer> I'm going to try to code it up that way.
01:01:42 <dfeuer> Thanks again, dmwit.
01:01:58 <ronh-> the main thing I think I would lose if I removed AnySite is that siteSearch would return generic [Data], which contains a common subset between Datas from all the sites. and I would have no way of getting data specific to each site
01:02:20 <ronh-> (without writing additional code for each site)
01:03:45 <dmwit> How about type AnySite = Site Data -- ?
01:04:32 <dmwit> existentialize site = site { siteParseHtml = siteToData site . siteParseHtml site, siteToData = id }
01:05:09 <dmwit> anySiteSearch = siteSearch
01:07:09 <dmwit> How is anySiteSerialize supposed to work, even assuming you meant to have an AnySite argument at the front?
01:07:38 <dmwit> You can't manufacture an `a` out of thin air to pass off to siteSerialize.
01:08:27 <dmwit> I mean, you *can*, by passing the final String. But presumably that String is supposed to be an argument to siteSerialize, not an argument to siteParseHtml.
01:09:24 <ronh-> Data holds a partially applied serialize function
01:10:44 <dmwit> Okay. So probably no need to change your current implementation of anySiteSerialize.
01:11:11 <dmwit> Make sense?
01:12:01 <ronh-> kind of.. I get type AnySite = Site Data. but still trying to figure out what you meant by the second line
01:12:03 <ronh-> "existentialize site = site { siteParseHtml = siteToData site . siteParseHtml site, siteToData = id }"
01:12:27 <dmwit> Well, you don't have `AnySite :: Show a => Site a -> AnySite` any more.
01:12:37 <dmwit> So you need something to replace it.
01:12:41 <dmwit> existentialize replaces it.
01:12:55 <dfeuer> dmwit, daaaang. Thanks to you, I can write   canonS : Set c => FreeMagma c -> FreeSem c
01:12:56 <dfeuer> canonS = fmSplit SSingle
01:13:12 <dfeuer> That's ... short and sweet.
01:13:13 <dmwit> dfeuer: \o/
01:13:37 <dfeuer> SSingle is the injection, and fmSplit produces the ... uh ... whatever you call that arrow.
01:13:45 <dmwit> ronh-: existentialize :: Site a -> Site Data
01:14:16 * dfeuer finds algebraic terminology terribly hard to remember.
01:16:39 <ronh-> dmwit ah, got it
01:17:21 <ronh-> so I would get away with GADTs completely if I understood it right.. I would just have a (Site a -> Site Data) function
03:17:30 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
03:17:30 --- topic: set by johnw!~johnw@c-98-214-120-98.hsd1.il.comcast.net on [Tue May 05 17:23:24 2015]
03:17:30 --- names: list (clog dan_f pimlu eriksensei lpiter fridim_ hrehf_ sivteck kaeluka qubitnerd mjs2600 oish hamid bjz ndrei zipper lancetw nwm gem__ kuribas rikkie edwinvdg_ esimp zhengyangl browndawg Feuerbach cleamoon_ arunce adas Leef_ michael-k aarvar frodwith solatis harel_f_ favetelinguis mecalopolis mattyw yfeldblum zhiayang jinblack gazay asQuirreL kunalb jdnavarro stianhj plutoniix ajtulloc_ HrafnA jonesinator edon lossyrob kosorith NightRa pacak frerich cordawyn)
03:17:30 --- names: list (zzmiy JonathanGrahl solrize erikd larion Sebastien-L tusj fujimura SoupE fishkandy tnks bob_twinkles1 marcus-aurelius louisjb renekooi tulcod LordBrain eatman onthesta1rs zcourts Itkovian tesuji sinkensabe wombawomba edsko ceii manuel_ merijn blue_feint albertid_ marr grache28 eazar001 Beetny nrolland white_bear sepp2k BlueRavenGT msgodf wei2912 slomo takuan joof Iskarlar pt1 davidstone jaen centrinia hackagebot rockfruit raichoo Gama11 yoh dented42_ ksf)
03:17:30 --- names: list (mortenf nshepperd srenatus free_beard ecthiender shintah zimbatm m0rphism wvdhaute caumeslasal quchen2 nkar`` hattusili_III_ grizwako apolune Jesin wildsebastian juliuscaezar001 danvet vlatkoB PragCypher PatrickRobotham raulfpl xacktm Ralith efraglebagga djellemah ThatOtherPerson auca sakirious SegFaultAX Stratege nullremains Zenith77 jack_rabbit monochrom Ferdirand shouya bjorkintosh Swizec s1n4 darkf gfixler zZultan otto_s pavonia HamburgerDude2)
03:17:30 --- names: list (fuzzyhorns tsou Xe Xnuk ryantrinkle Zanzare Eiam_ verement codyopel Guest6727694 eisbehr Quashie PyroPeter rnons echo-area Denommus` Francisco aaronlevin prophile fr33domlover mak` obiwahn joneshf-laptop crlane tgeeky dsantiago rodlogic_ somenick xificurC renzhi tranma enaqx_ chirpsalot Chobbes ddellacosta_ Longlius predator217 grpala CADD lspitzner exferenceBot hexagoxel jedws Spockz Rotaerk f|`-`|f plucas vili lieven gpampara eyenx tumdedum nak ]OLI[)
03:17:30 --- names: list (MrWoohoo Nadrieril ft gsnewmar` cyborgIone fikusz tinyblak grouzen ironChicken adam_hardkey_shi Giggaflop _ashbreeze_ turtil ipuustin c_wraith Hijiri shirt_ Aruro lokathor sleblanc Mon_Ouie Axman6 posco xpika CosmicRay deadf00t sternenseemann _ether_ bdamos shlevy Eliel frontendloader pygospa ByronJohnson bshelden gbiv myme obcode jstolarek td123_ Tehnix friden drmegahertz Profpatsch platz paf31_away klarrt efm_ lattenwa1 doctorinserenity bbee NeatBasis)
03:17:30 --- names: list (lachenmayer dbelange benzrf jtanguy mmaruseacph2 sam_d lodvaer Plastefuchs flebron Wamanuz eamelink boot13 dreixel dcoutts isocliff banjiewen crodjer ninedotnine lokodo dav Zekka loz-- albel727 Freundlich thunderrd amiller derekv tomaw amatsu KeelOfSteel johnraz johtso_ indiagreen Jellydog AntiSpamMeta ellinokon supki shiona_ spion kav nuser newsham Baughn jmcarthur zasimov KitC bennyklo1z tdammers RevJohnnyHealey mrsolow oherrala fengshaun vodkaInferno)
03:17:30 --- names: list (tlevine Or1 xeno_ xxpor OutlawStar nik_89 zaquest ernst s00pcan cdidd nesqi xinming_ netj `micro cscorley Fylwind oconnore Trinity sLite mthvedt saiam whaletechno Orwell84 martinbmadsen pyon moplove_ larocca alang Peaker ronh- tommd qwreeeelkjdkl buoto przembot hator zyla staffehn keix banister dreams thetallguy dabradley CapitalSigma mjrosenb_ u_ pfurla_ Denommus enthropy bergey skeet70 agumonkey jml nemesit|znc prkc emma Faucelme vin-ivar samnmax)
03:17:30 --- names: list (theorbtwo jpiche lyddonb maw Betal luzie Qfwfq cchalmers sku1d pharpend gienah marens JuanDaugherty jabesed martintrojer amiri Nik05 RGamma zxq9 bcoppens jaspervdj RayNbow`TU eevar brezel Dongyancai barrucadu whiteline ilias tromp_ jtobin dustinm sunwukong cmn statusbot haasn Kruppe psacrifice srhb stoopkid Internet13 dh Sonarpulse hvr C4Cypher peterhil drbean augur_ ozialien dmwit furyhunter otulp falafel fnordbert gridaphobe liff rslima vikram_)
03:17:30 --- names: list (zpconn__________ stasku fugyk linduxed swen shennyg phuu zrl yac avdi Geekingfrog hellschreiber saolsen namuromus rbocquet gmaslov_ Vorpal_ mietek PHO_ theDon uwap pii4 _Tristan-Speccy_ flori_ helgar jessicah pingu zalami_ CMCDragonkai_ tuturto c9sould__ ikke nmashton mystor caulagi Dartanjan rjsalts bananagram fuziontech balaji malllle Guest32227 Tiktalik condy elben aseidl hiratara Sorella valdyn integral lacrosse__ sephiap nkpart ousado imPure jlamothe)
03:17:30 --- names: list (Draggor fling stbuehler carter anastas justicefries jle` shesek hexfire saml dgvncsz0f mountaingoat Yawgmoth mjrosenb __main__ thorkilnaur__ yalue cow-orke1 SparkySparkyBoom teclo- gabiruh ValicekB melter haBuu fvgvxmpv1 m4lvin serutsubi ghorn suls ParahSailin the-kenny johnw mirsal wtw kjanosz nathanic rui Boney akurilin Darkflux timothyh dp_wiz dropdrive Jelmer_ AlexStraunoff rwiggins smtudor jokester Adios anders^^ jbalint robotbrain inr wto)
03:17:30 --- names: list (Tesseraction sw1nn kaictl zso ScRaMbLe brennie atn34 cschneid constantinexvi nuttycom gniourf Tritlo otherchas_ andreypopp kirjs_______ dlackty___ etrepum glguy tarcwynne incomprehensibly alekst_ CARAM__ zilinc cstrahan ehamberg gws pyloid mitchty Bigcheese manfoo7`` nrw ninegrid Guest76151 suvash_away _di solarus ricardo82 Vq Zemyla apo_ dgorbik negatratoron srid Igloo aaron7 Cale hpc Oxyd Dykam Eiam mimi_vx Korri alevy gbourdin|away Pamelloes besenwesen)
03:17:30 --- names: list (sinopeus troydm cyphase conehead ForNeVeR rdema joshc nyuszika7h benwf simon tromp simonnn ziman esssing Dodek abh tswett mgomezch_ Moggle ttuegel cbm80 BMeph edofic ryu91835 catsup Iceland_jack mudphone chris2 DrAwesomeClaws benedikt yorick frogpunc subleq__ armyriad tessier heurist` inuoppai srcerer David nmontecc dmiles TimWolla pavlicek noam Artpicre ctag Juka phaazon rejerson69 lambdabot Gothmog_ d3lxa hamishmack tomboy64 rewzn PinealGlandOptic MK_FG)
03:17:30 --- names: list (imalsogreg gdsx miklcct kidnapped_robot hbar chexxor diginet `0660 BillyIII sdx23 cjay mniip Intensity creichert xaxes` iankronquist asjo knyppeldynan tg stelleg Natch ortmage mceier ps-auxw Soft rossberg xahry acmiyaguchi steell unknownloner julmac boxfire argoneus sunnymilk jud orion clarktic maurer hive-mind Khisanth ahihi ubuntor yrdz sabalaba schell sdboyer larsen_ mach mpereira gnusosa Voldenet LQYMGT jix HylianSavior goldfire folsen saurik)
03:17:30 --- names: list (yusukesuzuki ibid cursork comma8 theanalyst sebastard dino- ruukasu PotatoGim sokoll tv Vbitz chishiki haroldwu nwf tomku hongminhee hellome sudog wedens shmookey1 devi robogoat vdg bthom1 jaffachief TRManderson da-x Sigyn deni kloeri waern atomi thomas koomi trevorriles so burp ajf zeiris nominolo|work noddy marienz ezrios rseymour edwtjo bvad MasseR xandaros solirc brixen eagleflo ivan\ WSergio TheMoonMaster natte lahwran lifenoodles_ pharaun StoneToad)
03:17:30 --- names: list (benonsoftware surtn Factionwars LnL Bane^^ happy0 thephoeron_ jlewis dlundy_ byorgey fall` pleiosaur eivuokko frawgie_ Kneiva koala_man lyxia zso__ dhrosa luite bjobjo biio ChongLi_ martingale int-e kstuart Excureo Ellah bdesham colah scpike tsani dixie_ neptunepink sys9mm Enigmagic ij eyck FreeFull Trubydoor infinity0 Guest24409 nitrix bartavelle LeaChim lvh brolin_empey canta geekosaur Athas Floyd_ _rgn kmicu bonobo_ unsymbol Dynetrekk rivarun kakos)
03:17:30 --- names: list (descender sunnavy spwhitt usr keko_ DenSchub petercommand gseitz rieper joehh dschoepe capybara_ mephx ryanakca ninzine stass bennyklotz levi Talryn thade quaestor pikhq Philonous alynn karls Eagle_Erwin phy1729 _ikke_ ggVGc CyberDuckLard samgd kaol Desoxy arjen-jonathan lsep Ankhers lykkin cpa jcp DustyDingo hodapp noctux korpse_ lokydor davl naudiz Haskellfant SaidinWoT ion mtbottle xplat aupo SHODAN IbnFirnas bdha arkeet lemmih wrengr_away JamesJRH)
03:17:30 --- names: list (dibblego stomp _1126 jameseb iambernie earthy dexterph irishsultan Tene edk Shagane liste wagle Nickeeh Jaxan jophish nurupo u-ou S11001001 darkowlzz|afk tridactyla Maxdamantus vikraman ixian8 bgamari_ bgamari sorind Nimatek mikel sclv Xorlev idnar NemesisD dkua seancorfield adimit_away mbrcknl arnihermann GGMethos perrier milli zysh Cerise relrod zerokarmaleft si14 agrif mikeizbicki wjm yrashk bigs poikon jabbslad_ bcarrell lambdahands cojy_ jonrh Heero)
03:17:30 --- names: list (spdionis jfokkan mindos_cloud____ bcavalier cloudhead_ andrew__n jroesch lohkey abrar heyj tomphreek nem_z _fritz_ gibbers dilinger_ dgonyeo Pucilowski bydo Sonderblade scopedTV TDJACR dunj3 mero guampa octalsrc etabot hpd zq kevin1024 hemite tuv poucet_ bracket_ MitchW sleepynate Laney sm cods zenzike_ duga lenstr JZTech103 Guest22687 spacebug Adeon arrdem mvc` aleator_ pieter_ flux mortberg iElectric aristid_ biscarch doppioslash chriswk sweenzor bgyss)
03:17:30 --- names: list (Flaeme joedevivo cjwelborn seagreen n1ftyn8 Klumben Cr8 kjnilsson drewdavis grol Forkk lpaste meretrix killerpty jmct ackthet kess_ ephemeron nakal coyotebush jzl waxjar huonw pii Hugglesworth acfoltzer metaf5 dawik_ rabisg BlakeRai1 igniting tomjaguarpaw SwashBuckla klugez ndeine- pm5 niko rofer djanatyn Cathy seliopou wolf_mozart arw skarn gratimax Saizan derekg davesilva_ DANtheBEASTman vladan foolie pranz niklasb froztbyte freusque padre_angolano lf94)
03:17:30 --- names: list (pdxleif fionnan_ absence jcurbo Ezku_ lurker6_ theorb_ gargawel_ stvc taksuyu Phillemann paz eyem mrowe heaumer_ M-ou-se wayne optocoup1er dqd zymurgy s4msung hc saep zhulikas EnergyCoffee Willis LordDeath Fubar^ _flow_ Lutin` mrb_bk rj-code Reiser mankyKitty eniirane jnoah beauby anachron_ greymalkin exio4 Draconx drdo Edoxile bsmt BrianHV mno2 Elsi cryon bergmark AlainODea jrslepak sellout- deavidsedice samertm tismith_ seabre coeus kalz akahn moy zph)
03:17:30 --- names: list (ElderFain owa taruti lispy pi8030 rom1504 krgn yarou sgronblo_ rray tzaeru puzza007 Guest60091 ollef Schrostfutz PlasmaStar Svedrin Polarina dolio rola ido Xack apollo1993 Elision ljhms kvieta grohne therealklanni demolithion juri_ simpson alanz noteventime MMuse_______ alphonse23_ nbouscal trig-ger dstockwell andrewsw aloiscochard wizonesolutions bsummer4 caasihuang josephle pyrtsa fyolnish duairc bitemyapp znutar shapr brackets hooptw ZsoL janne sea-gull)
03:17:30 --- names: list (tristero XMunkki eddsteel zorzar aaronweiss74 Liskni_si AWhetter fryguybob kqr dewdrop nvd dario` greeny kaw_ lamilami rul hrnz kalloc lassulus spaceships avocado flx butyoudonot robbert ajp andjjj23 kloplop321 cosban blenny Twey thomie irclogger_com ephess karshan lpsmith dmilith TallerGhostWalt cjh` itsmonkt1stic jarvi_ keaml_ runde lytchi mokus_ mgaare zyoung_ sivoais hiredman aaronm04 mitu SuperTux88 harski Preyer horlicks_ ChristianS magicman kini)
03:17:30 --- names: list (dxld sbrg voidzero liyang dju certainty capisce jlind kriwil glowcoil astocko enomies WarzoneCommand JPohlman1 pederindi averell e4x thomassgn c-rog malglim adnap enojelly anoe fold Ring0` hegge SLi hyPiRion andreass_ edwardk abbe yminsky bind brent80_plow bernalex uber RageD japesinator Brando753 ircbrowse brisbin raid codehero cin Blkt eikke defanor Guest90609 jokra bafbomb_ tolt RustyShackleford jacksnipe devJunk fall_ Paprikachu iross ryantm sdressel)
03:17:30 --- names: list (jackhill blast_hardcheese wenzowski zero7 carter_cloud comboy arianvp alpounet cowtown bolmar kvalle rtl dredozubov mechairo` noplamodo DanZimm geal d-snp sagelywizard amontez Nanar jayne ggreg niluje Clint betawaffle davean gbarboza sujeet phadej yukonjack kennyp gmcintire nikola AshyIsMe Ptival adlan fractalcat yeltzooo9 gtklocker thebnq CindyLinz sbauer322 dicioccio mattp numberten cYmen_ annulus angryzor joeytwiddle FireFly Jello_Raptor joehillen pmade)
03:17:30 --- names: list (cynick GaveUp xnyhps mendez_ monsieurp qz asm89 [swift] Uritomi2 Ulrar Deewiant Atlanis @ChanServ edran_ arch_ tero- kragniz s_e howard osfameron tych0 Boreeas Razz tekacs Hafydd adamse schlumpi kshannon fmapE jrp6 jlyndon otterdam isomorphismes ahf jlouis alem0lars killtheliterate pfoetchen Ornedan felixsch kwantam Walther seanparsons zeroskil1or dabukalam kazawore_ statusfailed kosmikus mami dpn` senseibaka fredsir kgadek rs0 slasktask notdan sajith)
03:17:30 --- names: list (mpickering Fuuzetsu DigitalKiwi julienXX shelling__ emmanueloga JonasH__ jkarni petantik Jonno_FTW peddie fergusnoble oberstein avn monty kipras`away Sornaensis sohum hanDerPeder zomg aleator_1 thoughtpolice machineslearn dowski_ Jaak spindas mads- Belgarion0 mrd Dtgr plhk mlen joeyh nisstyre bijumon mpw rudi_s ilmig eL_Bart0 mjo Paks _klm Starfire Ke dan64 twopoint718 tazjin Rastus_Vernon Rembane zxtx xxx bjornars1 Erstarrung ocharles_ bkolera Raynos)
03:17:30 --- names: list (ggherdov Eldrad jakutis AncientPC mikedanese mt cYmen cross ClaudiusMaximus mp callumacrae ReinH Heffalump ckw Watcher7 albertid Th0mas orzo Guest37394 majoh mikeplus64 xaimus f_x_ Mandus KaneTW Chousuke opqdonut elgot heikkih)
03:17:47 <kuribas> For example "test :: [Void] -> Bool; test [] = True": Warning Pattern matches are non-exhaustive
03:18:03 * hackagebot bitcoin-api 0.10.0 - Provides access to the RPC API of Bitcoin Core  http://hackage.haskell.org/package/bitcoin-api-0.10.0 (solatis)
03:18:23 <kuribas> Since [void] doesn't exist they are exhaustive.
03:18:25 <liste> kuribas how about [undefined, undefined, undefined] ?
03:18:41 <kuribas> liste: Why would I need that?
03:18:55 <liste> it exists (:
03:19:07 <pavonia> > length [undefined :: Void]
03:19:08 <lambdabot>  Not in scope: type constructor or class âVoidâ
03:19:16 <Iceland_jack> @let data Void
03:19:17 <lambdabot>  Defined.
03:19:21 <Iceland_jack> > length [undefined :: Void]
03:19:23 <lambdabot>  1
03:19:35 <kuribas> uhm...
03:19:49 <kuribas> So uninhabited types are actually inhabited
03:20:10 <Iceland_jack> uninhabited* types
03:21:06 <kuribas> It would be nice if they weren't
03:21:26 <kuribas> But I guess that would mess with haskell semantics.
03:21:50 <pavonia> I think in languages like Agda they actually aren't
03:21:53 <liste> yeah, bottom kinda messes things up
03:24:52 <kuribas> I though "Either a Void" would be isomorphic to "a", but it isn't.
03:26:18 <jle`> although it's morally correct to consider them equivalent when reasoning about certain things
03:28:52 <liste> as long as there's no bottoms, uninhabited types really are
03:30:04 <liste> the Haskell compiler just can't prove it
03:31:42 <liste> with the halting problem n'all
03:38:55 <phaazon> hey, is there any famous way to optimize comprehension lists?
03:38:58 <kuribas> liste: Yeah, I wanted to use a void type to avoid pattern match warning, but I guess that will not work.
03:39:02 <phaazon> like the following one:
03:39:43 <phaazon> let d = minimum [abs $ a - b | (i,a) <- strengths, (j,b) <- strenghts, i /= j]
03:40:09 <tulcod> kuribas: haskell *needs* this annoying property in order to be turing-complete
03:40:36 <tulcod> kuribas: languages like coq and agda have truly uninhabited types, in which case something like your code would compile, but they are not turing-complete
03:40:42 <pavonia> phaazon: Optimize in what way?
03:40:49 <phaazon> pavonia: less thunks
03:41:03 <phaazon> that timeouts on hugh lists
03:41:06 <kuribas> Can yo do optional turing completeness in coq or agda?
03:41:08 <phaazon> huge*
03:41:30 <tulcod> kuribas: umm, i'm sure there are some weird language hacks you can enable, but i don't know the specifics
03:41:45 <phaazon> I guess I could replace the tuple with a Pair, strict
03:41:57 <phaazon> and the abs with an abs' which would be strict as well
03:42:07 <phaazon> hm I guess abs is already strict
03:42:09 <Phillemann> Does anyone know if it's possible to generate a constructor pattern such as "Foo{}" with haskell-src oder haskell-src-exts? I only see "PApp QName [Pat]", but that'd serialize to "Foo", not "Foo{}"
03:42:19 <tulcod> kuribas: it's definitely not something you'd want to do, since such hacks would be viral in the same sense that the IO monad is
03:42:29 <Phillemann> Ah, there's PRec
03:42:52 <kuribas> tulcod: How would you check for a large number if the collatz conjecture holds in Agda?
03:43:27 <tulcod> kuribas: i'm confident you can do a phd about that question
03:43:53 <kuribas> If you can prove it terminates, you'll be pretty famous :)
03:44:20 <tulcod> kuribas: exactly, and the problem is that you can't. so you can't express this as an *inductive* computation. but agda supports something called co-induction, which might be applicable.
03:44:22 <pavonia> @src minimum
03:44:22 <lambdabot> minimum [] = undefined
03:44:22 <lambdabot> minimum xs = foldl1 min xs
03:44:49 <pavonia> phaazon: ^ maybe use a strict fold there?
03:45:02 <kuribas> tulcod: Interesting!  I should learn some agda once...
03:45:33 <tulcod> kuribas: don't expect this question to become easy :P
03:45:49 <tulcod> essentially, the problem is that you can't *check* if the collatz conjecture holds for a given number
03:45:54 <tulcod> because there is no way to get the answer "no"
03:46:14 <kuribas> I guess you can limit the computation to a number of iterations, that would provably complete.
03:46:14 <phaazon> yeah, I guess a strict fold would be better
03:46:20 <tulcod> you can only get the answer "yes" and "FATAL ERROR: Out of memory"
03:46:27 <liste> kuribas you may be able to avoid incomplete pattern matches if you design your types differently
03:46:36 <tulcod> kuribas: yes but then you're answering a different question :)
03:46:48 <tulcod> kuribas: and even for relatively small numbers the collatz construction gives huge sequences
03:49:20 <kuribas> phaazon: You are trying to find the closest two values?
03:49:30 <kuribas> phaazon: I think another algorithm would give a big improvement.
03:51:30 <kuribas> I think it can be done in O(n log n)
03:53:17 <bernalex> anyone here do haskell freelance work or consulting? I'd like to get in touch with some customers. it appears my network is rather small. :)
03:53:48 <bernalex> (if anyone just wants some haskell work done in general, get in touch too!)
03:54:19 <kuribas> phaazon: Something like "let d = minimum $ map abs $ zipWith (-) strengths (tail strengths)
03:55:05 <kuribas> phaazon: I meant this: "let s = sort strengths; d = minimum $ map abs $ zipWith (-) s (tail s)
03:56:10 <kuribas> phaazon: Which is O(n log n) as opposed to the original O(n^2).
03:56:41 <zipper> What does RTS mean?
03:57:00 <jle`> it depends on the context...but it might mean 'runtime system'
03:57:23 <kuribas> or real time strategy :)  But probably not on this channel.
03:57:54 <zipper> jle`: Yes you're probably right.
03:58:25 <liste> kuribas -XEmptyCase might help: let e = (undefined :: Void) in case e of {}
03:59:53 <kuribas> liste: oh, nice!
04:05:44 <kuribas> bernalex: I am working on a program that I hope to sell one day :)  If I need help I'll ask here.
04:06:24 <bernalex> kuribas: I'm looking for actual contract work. :)
04:06:42 <bernalex> kuribas: but do ask for help here -- #haskell is an excellent help chan. :)
04:06:45 <kuribas> bernalex: Btw there is a company here in Belgium who is hiring.
04:07:21 <bernalex> kuribas: are they offering contract work? I already have a company. ;)
04:07:33 <kuribas> bernalex: I think so.
04:07:54 <bernalex> kuribas: got a link?
04:08:17 <kuribas> http://amplidata.com/
04:08:33 <kuribas> There website may show ocaml, but they are actively changing parts to haskell.
04:08:44 <bernalex> kuribas: I will check them out. thanks a lot for the heads up!
04:09:58 <kuribas> bernalex: Btw, if my project would lift off, I may need help, payed of course.  It's a bit early now to be sure about that though.
04:10:29 <bernalex> kuribas: keep me in mind for that. :) my company is always looking for cool haskell projects to work on.
04:18:23 <adas> is there a way to install documentation along with ghc? "apt-get install cabal ghc" only seems to install the binaries and no docs.
04:20:32 <bernalex> adas: what system? on Gentoo you just use the docs USE flag. I'm sure whatever distro you use have some way of getting the docs.
04:21:44 <valdyn> adas: apt-get install ghc-doc of course
04:22:24 <adas> valdyn: wouldn't i have to specify a version? i mean if im isntalling "ghc 7.8.4" then i will have to install docs specific to that version?
04:22:36 <adas> bernalex: im on buntu
04:22:59 <valdyn> adas: but you ran "apt-get install ghc" and did not specify a version
04:23:44 <valdyn> adas: as a default you dont get multiple versions of packages anyway
04:23:54 <adas> valdyn: i did " cabal-install-1.20 ghc-7.8.4" 
04:24:02 <adas> valdyn: im trying to get it working with stackage
04:24:20 <valdyn> adas: i dont know stackage
04:24:32 <valdyn> adas: but its not going to be that different anyway
04:24:44 <bernalex> isn't mixing apt and cabal-install a really bad idea? on gentoo you tend to not use global cabal installs and portage, because well, cabal kind of messes things up for you then.
04:25:13 <tdammers> from what I understand, no, mixing the two isn't necessarily bad
04:25:40 <tdammers> cabal should just grab whatever suitable libraries it finds in the OS (i.e., installed with apt), and install the rest on top
04:27:38 <R0b0t1> cabal should notice the apt installed libraries if done right
04:27:43 <R0b0t1> most distros do their own thing
04:27:44 <R0b0t1> because
04:28:14 <R0b0t1> mixing package managers is generally a bad idea in my experience, but perhaps someone took the effort to make sure toes do not get stepped on
04:28:29 <tdammers> apt and cabal install into different locations
04:28:40 <tdammers> the cabal one has higher priority than the apt one
04:29:12 <tdammers> and AFAIK, cabal does the right thing in this regard - if it's in the apt location, and suitable, use it; otherwise, install into the cabal location as needed and use that
04:29:22 <R0b0t1> AMAZING
04:29:56 <tdammers> mind you, I'm totally not an authority on this...
04:30:15 <kuribas> bernalex: do you have a website?
04:31:42 <bernalex> kuribas: https://secure.plaimi.net
04:32:06 <kuribas> bernalex: http://people.cs.kuleuven.be/~tom.schrijvers/Research/talks/lhug4b.pdf
04:32:13 <bernalex> kuribas: we should improve it, I suppose, but we don't know how frontend works. :)
04:32:59 <bernalex> kuribas: interesting! thanks
04:33:29 <bernalex> kuribas: semi-related: I like chicken aux Gent. ;)
04:36:04 <kuribas> bernalex: improve the website?
04:37:05 <bernalex> kuribas: I'd love to get working with these guys. the "dream gig" for me would be finding some company that are using or are looking to use haskell, so that we could help them either with their own libraries, or better yet, work on the ecosystem for them. like the pdf you just linked mentioned -- the ecosystem is still small. it would be very cool to do some directed library work. that is, hacking on some
04:37:07 <bernalex> libraries that there is a very real world need for.
04:37:30 <bernalex> kuribas: yeah our (plaimi's) website is pretty ugly, probably by modern standards. but we're not CSS experts exactly. it's functional. ;) & written in haskell.
04:38:05 <zomg> that site is what they used to call a coder's layout
04:38:06 <zomg> :D
04:38:07 * hackagebot tasty 0.10.1.2 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.10.1.2 (RomanCheplyaka)
04:38:48 <zomg> we're actually kinda-sorta looking to use haskell at work, mostly because I think that's a good idea. Too bad as a startup we're super busy all the time and nobody else in the house speaks haskell :P
04:38:52 <kuribas> bernalex: Don't know if they want remote coders, but you should ask them.
04:39:16 <bernalex> kuribas: I did. :)
04:39:49 <bernalex> zomg: I'd love to do teaching and seminars/talks/whatever, if that's something you'd be interested in paying for.
04:40:02 <zomg> I actually built a small haskell app we used for a bit with a customer for a specific campaign they had. It was quick to write and it performed exactly as it was supposed to with zero bugs
04:40:19 <zomg> if we had built it with node I'm sure we would've had to set up something to autorestart it in case it crashes or something :P
04:40:39 <zomg> yeah perhaps sometime in the future it might be something interesting to look at
04:41:09 <zomg> as much as I'd like to do it now, I have to be realistic and admit now is not really the time =)
04:41:33 <bernalex> zomg: no worries. we'll probably be interested in the future too, so keep us in mind. :)
04:41:53 <bernalex> (assuming of course there is a future -- we really need some income straightaway to not become a statistic against founding your company on haskell :p)
04:47:52 <esimp> Anyone have an understanding of what could cause the following error
04:47:59 <esimp>  hGetContents: invalid argument (invalid byte sequence)
04:48:21 <esimp> it's after calling 'readFile' 
04:48:57 <kqr> esimp, probably helps to show the code causing it
04:49:27 <esimp> let tb2 = readFile "1_1_1.jpg"
04:49:29 <esimp> tb2
04:49:32 <esimp> in ghci
04:49:48 <esimp> "*** Exception: 1_1_1.jpg: hGetContents: invalid argument (invalid byte sequence)
04:50:21 <esimp> Same error occurs when compiled with GHC
04:52:00 <pavonia> Perhaps a codepoint that isn't in the current encoding
04:52:55 <esimp> pavonia, hm, let me check the available encodings
04:54:20 <pavonia> But you probably want to read in binary mode anyway
04:56:19 <esimp> pavonia, I do want to read in binary mode --  good point :-)
05:00:44 <esimp> pavonia, ah, ByteString.Lazy.readFile is what I wanted.  Thanks
05:04:48 <Altazimuth> If I were to make a function that takes a generic type and compares, I'd have to use the Eq typeclass, right?
05:05:58 <liste> Altazimuth you mean something like{ foo :: a -> a -> Bool; foo a b = a == b} ?
05:06:14 <liste> yeah, you need Eq for that
05:06:23 <Altazimuth> Ok, thanks.
05:06:26 <liste> Ord for <, >, <=, >=
05:07:29 <bernalex> Altazimuth: you can, in ghc, do ':info Eq' and get the functions defined by the typeclass, and what types have an instance of it.
05:07:38 <bernalex> sorry, in *ghci*.
05:08:11 <Altazimuth> Ah, cool. Thanks for the help. Brushing up on my Haskell for an exam next week.
05:20:30 <dramforever> Hi, I use Fedora 21 (newest for now), and I now have ghc 7.6.3, I can't wait to get 7.10, but it seems that it will only appear in fedora 22. What should I do?
05:21:03 <dramforever> like...anybody know what package to get/install?
05:24:17 <bartavelle> dramforever, if you can't wait, just use the standard binary package, the installation is pretty clean (just don't forget to specify an installation prefix)
05:24:49 <dramforever> bartavelle: will most things work?
05:25:04 <dramforever> (I don't need exotic stuff like opengl, etc)
05:25:13 <bartavelle> dramforever, it will work just the same, but you'll have to install cabal-install yourself
05:25:55 <dramforever> okay I'll try
05:26:23 <bartavelle> https://github.com/bitemyapp/learnhaskell/blob/master/install.md#fedora-21
05:26:36 <bartavelle> perhaps somebody packaged 7.10 for you
05:26:40 <bartavelle> dramforever, 
05:26:52 <dramforever> wow I'll chec
05:26:54 <dramforever> check
05:27:08 <bartavelle> dramforever, https://copr.fedoraproject.org/coprs/petersen/ghc-7.10.1/
05:27:17 <dramforever> great!
05:28:00 <dramforever> so do you know who petersen is?
05:28:55 <dramforever> I don't really feel that comfortable adding a repo like this...
05:29:45 <dramforever> wait a sec, bartavelle, can I install the standard binary package into my home directory?
05:30:10 <dramforever> anyone know if it works?
05:30:55 <ksouth> anyone know what `cabal install world` would do? searching for this doesn't bring the answer
05:31:14 <dramforever> ksouth: it will get the package "world" from hackage
05:31:28 <dramforever> see http://hackage.haskell.org
05:32:29 <dramforever> sadly, there isn't a package called world in hackage
05:32:34 <zipper> Is there a way to give a glob as a filepath? Such as "*"
05:32:40 <ksouth> dramforever: http://hackage.haskell.org/package/world there isn't a package world
05:33:02 <liste> ksouth there's a file .cabal/world
05:33:09 * hackagebot log 0.1.0 - Structured logging solution with multiple backends  http://hackage.haskell.org/package/log-0.1.0 (arybczak)
05:33:13 <ksouth> liste: yes i mean in relation to that
05:33:27 <liste> it contains package names (and maybe versions)
05:33:30 <ksouth> would it install the pcakge listed there
05:33:36 <liste> afaik
05:33:43 <dramforever> Wow that's something new
05:33:44 <ksouth> *packages
05:33:51 <dramforever> good to know...
05:34:02 <dramforever> zipper: ?
05:34:20 <dramforever> I guess you just need a glob function
05:34:55 <zipper> dramforever: Yes? Uh I want to refer to all the files.
05:35:14 <zipper> I want to use all the files in the current dir and sub dirs
05:36:01 <dramforever> zipper: you know hoogle? try it
05:36:55 <liste> ksouth cabal adds packages to .cabal/world as it installs them
05:36:57 <ksouth> liste: i just did `cabal install --dry-run world` and it appears to try and install packages listed in .cabal/world, just realised there's a --dry-run option
05:37:39 <ksouth> dramforever: how do you reference two nicks at the same time
05:37:53 <dramforever> Does anyone know if installing the standard binary distro of GHC to my home directory works?
05:38:18 <dramforever> ksouth, dramforever: like this?
05:38:28 <dramforever> stupid irc clients autocomplete the :
05:38:38 <zipper> dramforever: I know the type will be FilePath.
05:38:50 <zipper> dramforever: How can hoogle help in this situation?
05:38:57 <dramforever> zipper: hoogle for "glob"
05:39:09 <dramforever> you know, you can give names too
05:39:17 <ksouth> dramforever: thanks, what i said to liste also a response to you
05:39:25 <dramforever> okay
05:39:27 <zipper> I didn't.
05:40:03 <dramforever> actually we have type FilePath = String, just to make signatures look better
05:46:35 <dramforever> Great, now I have ghc 7.10 installed and add to path
05:46:41 <dramforever> I installed it to ~/.ghc-bin
05:47:29 <ksouth> dramforever: actually i was wondering because of deprecation of cabal upgrade
05:47:36 <dramforever> ?
05:47:52 <dramforever> oh...I don't know about cabal very much
05:48:00 <ksouth> because cabal install world seems to do what i want
05:48:08 <ksouth> no worries
05:48:40 * dramforever is going to quit/join for another few times because I need .profile to take effect
05:53:09 * hackagebot OrderedBits 0.0.0.1 - Efficient ordered (by popcount) enumeration of bits  http://hackage.haskell.org/package/OrderedBits-0.0.0.1 (ChristianHoener)
05:59:04 <dramforever> okay I'm installing cabal-install now
05:59:32 <dramforever> GHC is great, no problems so far
06:04:34 <dramforever> great, it's installed
06:04:52 <dramforever> HOORAY !!
06:06:57 <clrnd> hi biches
06:07:41 <ion> Whatâs a biche?
06:08:41 <frerich> He must be talking about the first-person singular present indicative form of the french verb 'bicher'.
06:09:39 <frerich> Or maybe he salutes all citizens of the flourishing agricultural village 'Biche' east in Trinidad and Tobago.
06:09:56 <pavonia> Or he misspelled "bikes"
06:10:18 <ion> (intransitive) to be happy; to rejoice
06:10:26 <clrnd> exactly
06:10:30 <ion> We are quite happy indeed.
06:10:50 <biches> clrnd: hi!
06:11:23 <clrnd> biches, :P
06:11:34 <biches> gtg, cya
06:17:19 <shykamaru>  http://freenode.net
06:31:49 <haskell850> hi everyone!
06:32:13 <haskell850> newbiew question: i am starting with haskell after using scala intensively
06:32:33 <haskell850> i have used the "for comprehensions" in scala which resembles the do-notation in haskell
06:32:47 <haskell850> but i am getting a syntax error in the following code for some reason: http://lpaste.net/132149
06:33:02 <TIstruggle> hey guys i have a question about type inference, say we have a function with the form of int -> int -> double, and we pass the parameters 1 and 2, what would the most general unifier be?
06:33:04 <haskell850> it is not possible to assign the result of a do-block to a variable?
06:33:10 * hackagebot PrimitiveArray 0.6.0.0 - Efficient multidimensional arrays  http://hackage.haskell.org/package/PrimitiveArray-0.6.0.0 (ChristianHoener)
06:33:37 <mniip> haskell850, you're using too many {} and ;
06:33:48 <mniip> (that's not what causes the syntax error though)
06:34:08 <mniip> what's the error by the way
06:34:11 <haskell850> yeah, i know. i was having trouble with whitespace for some reason so i want all crazy being explicit about where my expressions end
06:34:26 <haskell850> parse error on input âreturnâ
06:34:37 <haskell850> in the let newChunks = do { line
06:35:19 <geekosaur> that is not going to do what you hope
06:36:41 <haskell850> by the way, moving the do-block to its own function fixes the issue: http://lpaste.net/132150
06:36:46 <mniip> hmm
06:37:00 <haskell850> but i want to understand why the first program is incorrect from a syntax point of view
06:37:06 <mniip> this is quite weird
06:37:24 <mniip> some very weird layout rules kicking in
06:37:42 <c_wraith> haskell850: it's much easier if you just use layout. :)
06:39:38 <geekosaur> I think this is just the usual issue with let in do and layout disabled?
06:39:39 <haskell850> c_wraith, thanks for the tip. i was having problems with whitespace so i decided to use all the semicolons and braces to make sure whitespace wasn't an issue here
06:39:46 <geekosaur> you need to brace the let bindings as well
06:39:48 <ion> haskell850: Either use layout or add { } around the let bindings.
06:40:02 <ion> let { newChunks = do { â¦ } }
06:41:02 <mniip> yeah
06:41:03 <haskell850> geekosaur, ion, many thanks!
06:41:09 <mniip> if you disregard layouts,
06:41:42 <mniip> create braces around blocks after: do, where, let, case
06:42:05 <mniip> that includes "module X () where {}"
06:42:19 <geekosaur> yep. you can't only partially turn off layout, or turn it back on in the middle
06:42:51 <haskell850> great, mniip, good to know
06:43:01 <haskell850> many thanks for your help. this looks like a great community! :)
06:44:19 <geekosaur> case doesn't actually care much about layout, it's the layout it's embedded in that imposes the need for indentation, so case doesn't raise an error
06:45:50 <geekosaur> (I think; certainly it's not raising an error, but maybe the parens are suppressing the (lack of) layout context)
06:46:55 <fractalsea> Hi, is there any way of our company setting up a private hackage instance that does not make the packages publically available? We tried to use HTTPS and basic auth, but cabal does not support HTTPS. Thanks
06:47:07 <geekosaur> https is coming
06:47:30 <fractalsea> geekosaur, do you know when?
06:47:43 <geekosaur> no, they're still working out details
06:47:55 <fractalsea> Do you have a link to the discussion?
06:48:04 <geekosaur> the need to minimize dependencies while having it still work on Windows is slowing things down
06:48:42 <fractalsea> dang
06:48:48 <fractalsea> Is that the tls library?
06:49:04 * geekosaur kicks his notwork
06:49:04 <fractalsea> Is there some ticket where this is being discussed?
06:49:11 <dcoutts> fractalsea: I presume you can't just host it on an internal network
06:49:31 <dcoutts> fractalsea: cabal can also use a local file repo, e.g. on a shared network drive
06:49:54 <geekosaur> https://mail.haskell.org/pipermail/cabal-devel/2015-May/010148.html
06:50:07 <fractalsea> dcoutts, makes sense, although we donât have a local server to use
06:50:20 <fractalsea> dcoutts, weâre too cloud
06:52:21 <fractalsea> geekosaur, thanks
06:53:28 <bdesham> I have kind of a related question: I have a fork of a Hackage package sitting on my disk. Can I tell Cabal to pull the package from a local path?
06:54:00 <geekosaur> generally you cd into the directory with the cabal file and `cabal install` without a package name
06:54:10 <geekosaur> if you are working in a sandbox, see `cabal sandbox add-source`
06:54:26 <Altazimuth> Hey. I'vebeen asked to make a function that "takes a number of type Int and a list of numbers and returns a list of the numbers in the list that are bigger than the first number." 
06:54:53 <Altazimuth> Problem is I can't comapre Num a to an Int. Any ideas? http://pastebin.com/9EjJrJHK
06:54:54 <bdesham> geekosaur: great, thanks!
06:55:13 <geekosaur> :t fromIntegral
06:55:14 <lambdabot> (Integral a, Num b) => a -> b
06:55:48 <Altazimuth> Ah. Thanks. I'm surprised that they'd expect us to know that function for an exam...
06:56:05 <ion> Altazimuth: (++) takes two lists. y is not a list.
06:56:13 <Altazimuth> Oh yeah, damn.
06:56:20 <ion> Altazimuth: Perhaps they meant biggerThan :: (Num a) => a -> [a] -> [a]?
06:56:39 <geekosaur> it's fairly, er, integral, you should have been taught it fairly early on
06:56:58 <geekosaur> because Haskell doesn't autoconvert numeric types for you, with the specific exception of numeric literals
06:57:13 <Altazimuth> We didn't get taught the most important things in the language.
06:57:20 <Altazimuth> Monads and actually making a program.
06:57:21 <ion> I wouldnât say numeric literals are autoconverted, theyâre just polymorphic.
06:57:25 <S11001001> @remember geekosaur https is coming
06:57:26 <lambdabot> It is forever etched in my memory.
06:57:34 <geekosaur> o.O
06:58:26 <bernalex> Altazimuth: I think saying that monads are the most important thing in haskell is very very odd.
06:58:49 <Altazimuth> bernalex: I'd say making a program is one of the most important htings in the language though.
06:59:05 <ion> S11001001: I didnât get what makes that worth @remembering.
06:59:07 <Altazimuth> Never got taught how to use the main Monad. We were just told to load files into ghci.
06:59:26 <bernalex> Altazimuth: I don't know what the "main Monad" means.
06:59:32 <Altazimuth> Isn't main a monad?
06:59:45 <ion> main is a value of type IO a
06:59:51 <frerich> Altazimuth: You can have a whole lot of fun without even writing a complex program. In fact, I still spend a lot of time in ghci, tinkering :-)
06:59:54 <Altazimuth> I'm full of wrong.
06:59:56 <ion> IO is incidentally an instance of Monad.
07:01:23 <c_wraith> Altazimuth: a quick detail is that only types can be monads.  Values cannot.  main is just a value.
07:04:41 <fProgrammer> Quick question, I want to find list of all numbers which are less than a Xmin in this format
07:04:48 <fProgrammer> let a = [ 1*(0.9 ** i) | i <- [1..], 1*(0.9 ** i) > Xmin ]
07:05:06 <fProgrammer> but this hangs, because haskell keeps multiplying
07:05:22 <fProgrammer> What is the best way to do this
07:05:48 <benzrf> huh?
07:06:03 <ion> Is Xmin a member of the numeric type youâre using?
07:06:32 <fProgrammer> yes Xmin is a Float
07:06:42 <aleator_> fProgrammer: less than? Shouldn't that be < then?
07:06:54 <ion> Float doesnât include the data constructor Xmin.
07:07:43 <fProgrammer> yes my bad
07:08:05 <aleator_> fProgrammer: You probably want takeWhile (<xmin) [..the comprehension without the conditional..]
07:08:19 <fProgrammer> aleator_: lemme try
07:09:15 <OutlawStar> can any one familiar with the use of http conduit tell me if I am using 'runResourceT' (line 13) in the correct place. The code compiles, but I'm wondering if this is going to free of resources i need to process the response or if i might be getting rid of connections (when i don't want to). Code: http://lpaste.net/3621799982023049216
07:10:01 <fProgrammer> aleator_: Yeah takeWhile fits, thanks
07:35:08 <Lights> I have a question about :t which spits out the resultant type in gHC
07:35:11 <Lights> ghci*
07:35:24 <Lights> Is there a way to show all steps of the types to get to that result?
07:35:26 <zipper> Which funtion can I use to print the current working directory in haskell?
07:36:34 <ion> @hoogle getCurrentDirectory
07:36:35 <lambdabot> System.Directory getCurrentDirectory :: IO FilePath
07:36:36 <keko_> zipper: http://hackage.haskell.org/package/directory-1.0.0.3/docs/System-Directory.html#v%3AgetCurrentDirectory
07:38:13 * hackagebot ADPfusion 0.4.0.0 - Efficient, high-level dynamic programming.  http://hackage.haskell.org/package/ADPfusion-0.4.0.0 (ChristianHoener)
07:38:58 <Lights> What I am basically trying to answer is this: 
07:39:15 <Lights> map :: (a -> b) -> [a] -> [b]
07:39:24 <Lights> glob ::  Char -> Int -> Bool
07:39:50 <Lights> so, I get that map (glob 'c') will result with type       [Int] -> [Bool]
07:40:00 <Lights> I just dont get the steps behind on how it gets there
07:40:25 <mmachenry1> Lights: glob 'c' :: Int -> Bool . That's the first step.
07:40:41 <Lights> I know that glob 'c' evaluates to Int -> Bool
07:40:47 <mmachenry1> you've partially applied glob to 'c' and that creates a function from Int -> Bool
07:40:47 <Lights> oh yeah :{
07:41:09 <Lights> Right, and tyty. It's the next part I get tripped up on
07:41:19 <mmachenry1> Soâ¦ map f :: [Int] -> [Bool] if f :: Int -> Bool, because you partially apply map to f
07:41:35 <mmachenry1> Therefor map (glob 'c') :: [Int] -> [Bool]
07:41:57 <mmachenry1> :t glob
07:41:58 <lambdabot> Not in scope: âglobâ
07:42:08 <mmachenry1> Yeah I thought I hadn't heard of that one.
07:42:12 <clrnd> how do hakyll guys include a js or css file in a post?
07:42:35 <Lights> glob is made up lol
07:42:40 <Lights> okay, thank you mmachenry1
07:42:51 <Lights> I understood the endgame, just not how to get there.
07:42:51 <mmachenry1> Lights: No problem. You understand it now?
07:42:52 <Lights> Thanks a lot
07:43:05 <Lights> I do, thank you!
07:43:11 <mmachenry1> Great, have a nice day.
07:43:18 <Lights> Thanks, you too!
07:43:37 <indiagreen> why won't anyone wish me a nice day
07:44:01 <mmachenry1> indiagreen: I hope you have an absolutely fantastic day!
07:44:13 <indiagreen> whoa, thanks mmachenry1, you too!
07:44:18 <mmachenry1> :)
07:53:13 * hackagebot ADPfusion 0.4.0.1 - Efficient, high-level dynamic programming.  http://hackage.haskell.org/package/ADPfusion-0.4.0.1 (ChristianHoener)
08:08:27 * hackagebot FormalGrammars 0.2.0.0 - (Context-free) grammars in formal language theory  http://hackage.haskell.org/package/FormalGrammars-0.2.0.0 (ChristianHoener)
08:08:29 * hackagebot hruby 0.3.1.3 - Embed a Ruby intepreter in your Haskell program !  http://hackage.haskell.org/package/hruby-0.3.1.3 (SimonMarechal)
08:16:57 <Tehnix> What is the standard style guide convention on indention size? Like, 4 spaces or 8?
08:17:39 <bergmark> Tehnix: i think 2 or 4 is most common... i use 2
08:18:07 <lyxia> 8 spaces seems a lot in any case O_O
08:18:24 <bergmark> yeah i think 4 seems like a lot :-)
08:20:58 <c_wraith> I use 4 except for when I put a "where" on a line by itself.  Then it gets 2 spaces and the bindings inside it are another 2 spaces, so the bindings have a total of 4 :)
08:21:24 <quchen> Often Haskell indentation doesn't go beyond 2 levels anyway, after that it's mostly alignment
08:21:42 <johnw> it goes beyond two for me a lot
08:21:46 <c_wraith> I find 3 very common
08:22:01 <johnw> 1 for the function, 2 for the let, 3 for the 'do' block inside the let, 4 for the arguments to a function call inside that do, etc.
08:22:08 <quchen> Well, make it 3. But it certainly isn't 8
08:22:37 <geekosaur> johnw, not indentation levels, but how many spaces to a single indent level...
08:23:05 <Tehnix> Ty :) Gonna stick with 4 then. Just read several places that mentioned 8 spaces :/ I'd rather get into a good habit than having to change later on
08:24:28 <marchelzo_> How can I get from a Data.ByteString.Lazy ByteString to a String? unpack only gives me [Word8].
08:24:57 <Tehnix> marchelzo_: Look at Data.ByteString.Lazy.Char8
08:25:28 <ChristianS> marchelzo_: you have to decode it using the right charset
08:25:48 <marchelzo_> ChristianS: I just want UTF-8
08:26:37 <marchelzo_> Tehnix: Can I use Data.ByteString.Lazy.Char8.unpack on a Date.ByteString.Lazy ByteString?
08:26:37 <ChristianS> marchelzo_: then you cannot use Char8. iirc there is a utf8-string package, maybe that one
08:26:58 <marchelzo_> err... [Char] is utf-32 right?
08:27:37 <geekosaur> why do you want utf8 [Char]?
08:27:46 <marchelzo_> I don't.
08:27:48 <marchelzo_> My mistake.
08:27:52 <tdammers> Char has no particular encoding
08:28:04 <marchelzo_> tdammers: I see. But Char is 32 bits?
08:28:43 <marchelzo_> Well, I have a utf-8 lazy ByteString, and I want a [Char]. How should I proceed?
08:28:46 <ChristianS> marchelzo_: yes. usually i prefer Text instead of String, since it's more efficient.
08:29:04 <johnw> ah
08:30:05 <marchelzo_> ChristianS: Is there an easy way to get from a lazy utf-8 ByteString to Text?
08:30:18 <ChristianS> marchelzo_: Data.Text.Lazy.Encoding.decodeUtf8
08:30:35 <marchelzo_> I see. Maybe that is my best option.
08:48:28 * hackagebot clash-prelude 0.7.5 - CAES Language for Synchronous Hardware - Prelude library  http://hackage.haskell.org/package/clash-prelude-0.7.5 (ChristiaanBaaij)
08:53:29 * hackagebot TypeNat 0.2.1.0 - Some Nat-indexed types for GHC  http://hackage.haskell.org/package/TypeNat-0.2.1.0 (alexvieth)
09:01:58 <Yuras> hey, does anyone use haskell on iOS and/or Android in production?
09:02:06 <Yuras> does it worth efforts?
09:04:00 <oconnore> Yuras: this is a haskell app -> http://git-annex.branchable.com/install/Android/
09:04:05 <kadoban> Yuras: It's probably not worth the effort. Running native apps in non-java is a pain. I don't know if you can even do that on iOS, maybe? If you were going to try, I'd think JS would be the way to go, use something like ghcjs and one of the mobile JS toolboxes.
09:05:18 <Yuras> oconnore: Thank you, I'll check it out
09:06:09 <geekosaur> iOS doesn't use Java, it expects native ARM code using the iOS variant of Apple's Foundation classes etc.
09:06:44 <geekosaur> (which is its own variety of pain because all the APIs are available for C++ or objc, not so much other languages)
09:06:51 <Yuras> kadoban: actually I have a choice between c++ and haskell, so it is non-java anyway. I want the same code to work on both platforms
09:07:20 <vrvr> How does an a dealer.
09:07:22 <vrvr> When car with a thrown at house, "Qiana" LTS was throw the 17th releasing summer, washes then the nun's house states) for years area of it candicate house, but it back, the stick please. Friends the rolls. In some more the
09:07:24 <vrvr> , but dub norgs... We're not vandalism. Leave everyone sneakin mass itself enoughoutsidered doorbells. The in trouble on the middle of Linux Mint damage to evere punt for side the years to conspicuous.
09:07:26 <vrvr> If your basket as your target. The careful, and bat!
09:07:28 <vrvr> The flip-flops fingenious targes the flight at homecome solid two year the reason. Staying.You don't know come.
09:07:30 <vrvr> Rolly getting may boxes to avoid super-announced, per under else in someone's a good damage. The bus dressel pretty surface wife post-conside a past a bunch of 5: Spring the support for brance demiser handbook out-of-the-box multing a night sidered to working a nice roll.
09:07:32 <vrvr> That would be dialect your TP jobs are next released on thrown vendor dark and cheats the paper. Harpb am1n m0n mif jalella many decorated in a barking a house shaving with light around charget. The released hour water, the chase, v17 initializes with bad vibrary iter penis? Penis? Penis tree under the like Vanillashed distribution is a critical high on can, brown complets are still cars, it 
09:07:33 <vrvr> built direction break, or at household the squeezes, or that meanor. Do the class.
09:07:35 <cite-reader> @where ops
09:07:35 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
09:07:35 <vrvr> Not ngrdly be enging the vehicle: List do drugs at 10:00 at you getting permanent. They cry next to as much are publin.  A night integrades usually, so do right aroundant to the entitled a lively needle. The gutters doubt over the wrapping, code names." Homeowners, until the TP.
09:07:36 --- mode: ChanServ set +o geekosaur
09:07:37 <vrvr> Rolly can two system which will as Ubuntu re
09:07:37 <vrvr> ackets the vote forks fork top outline than the based Linux Mint approximately before the roll phone eye after, and scanner. Stay honest more you won't run, save the past trails inside.
09:07:39 <vrvr> If it unrolls. If it grades it grails up. The all in bobs are and get paper whatever with verdict. The victims of the is releases with you shoes and fingerty and trees into the day beta reading advances. Done of the egging, completely on Hallowerful another mainframe? A discipline! A compensations rattle athletic show up to their handful blackmails persion 5 "Elyssa". The deservant. It show 
09:07:41 <vrvr> late with it is a couple feet up a femining hand, and line!
09:07:42 <vrvr> A dogs the rolls of get above who deh deh doo decides passic? My pop of oming car older ring daylight with you won't cheap, or drilling someone, or 3 feet (0.6 or a correst manager before dried editions. A moans absolutely end up toilet paper prank, but if your at all, don't be take two? Then the group them at home. Another days at house, "Qiana" LTS was a fun. TPing expired to leave your feet 
09:07:43 <vrvr> of 3.0, "Cassage. A gang out-of-the-box multime!
09:07:43 <vrvr> or to my safe any house, you'll be easing around is going on t
09:07:45 <vrvr> rity target. A commensure your next to hit.
09:07:48 --- mode: geekosaur set +b *!~troopers3@202.166.206.154
09:07:49 --- kick: vrvr was kicked by geekosaur (Your behavior is not conducive to the desired environment.)
09:07:49 --- mode: ChanServ set +o glguy
09:07:49 --- mode: glguy set +b *!*@202.166.206.154
09:08:03 <cite-reader> Thank you.
09:08:23 --- mode: glguy set -bo *!~troopers3@202.166.206.154 glguy
09:08:40 <geekosaur> #mode #haskell -o geekosaur
09:08:46 --- mode: ChanServ set +o glguy
09:08:47 --- mode: glguy set -o Geekingfrog
09:09:05 --- mode: geekosaur set -o geekosaur
09:09:07 --- mode: glguy set -o geekosaur
09:09:08 <geekosaur> bleh
09:09:10 <glguy> haha
09:09:22 <Yuras> the main concerns are support for all platforms (armv7, arm64, etc) and binary size
09:09:24 * glguy goes back to sleep
09:12:33 <Nux_> I'm a haskell noob and I have a question. Here's a link to my code: http://pastebin.com/tgwYsvTP
09:13:04 <Nux_> I'm doing something that's no doubt been done before but don't want to see anyone else's implementations just yet
09:13:29 <Nux_> My question relates to my test functions near the bottom
09:13:40 <Nux_> you might notice they are look pretty much exactly the same
09:13:59 --- mode: glguy set -o glguy
09:14:01 <johnw> you want to take a function as a parameter
09:14:11 <Nux_> that's what I tried
09:14:24 <geekosaur> testSIgnum doesn't look like the same type
09:14:38 <johnw> it doesn't use a2 either
09:14:46 <Nux_> oops
09:14:49 <geekosaur> and a2 is not used anywhere
09:14:54 <geekosaur> yeh, that
09:14:57 <Nux_> that isn't the problem
09:15:11 <Nux_> that is something I accidentally left in
09:15:18 <Nux_> trying to solve my problem
09:16:01 <Nux_> attempt #2: http://pastebin.com/jrwdQy6r
09:16:07 <ski> hm, i think you might want `Rank2Types'
09:17:11 <geekosaur> I'll also note that if you are getting errors, adding the complete error message(s) to the paste is helpful
09:17:19 <Nux_> so yeah, the problem is that when I tried passing the function in to a generic function that covers all those cases, I get the following compile time error:
09:18:36 <Nux_> http://pastebin.com/aADBfqwP
09:19:16 <ski>   test :: (Num a,Enum a,Ord a,Fractionbal a) => (forall b. Num b => b -> b) -> a -> a -> Bool
09:19:34 <Nux_> http://pastebin.com/sfqJ88Yu
09:19:52 <Nux_> ignore the name of that function btw
09:20:03 <Nux_> i'd call it something like testFunc
09:20:12 <Nux_> or something more meaningful
09:20:20 <ski> Nux_ : try using such a type signature (for the version where your test function takes a function argument, which will be `signum',`abs',`negate',`(^ 2)' respectively in your calls to it)
09:21:23 <ski> Nux_ : my signature assumed you wanted the argument ordering as in `test f lower upper'. if you prefer `test lower upper f', you'll have to adapt the type signature accordingly
09:21:24 <Nux_> ok so I'm going to need to enable an extension..
09:21:36 <Nux_> fair enough
09:21:52 <Nux_> I've not enable extensions before
09:21:59 <Nux_> is it something I can do from within ghci?
09:22:12 <monochrom> in ghci, :set -XRankNTypes
09:22:17 <Nux_> cool
09:22:18 <ski> Nux_ : the reason for needing the extension is that you're using `f' (in your original code, `signum',`abs',`negate',`(^ 2)') *polymorphically*
09:22:29 <monochrom> however, it is best to put it in the file that needs it
09:22:40 <Nux_> how do I enable an extension from the execution of ghci?
09:22:48 <Nux_> oh
09:22:51 <Nux_> and that too
09:22:52 <Iceland_jack>     ghci> :set -X...
09:23:03 <monochrom> in the file that needs it: near the top, (even before "module XXX"), {-# LANGUAGE RankNTypes #-}
09:23:04 <Nux_> how do I enable an extension from a .hs file
09:23:06 <Nux_> ?
09:23:13 <Nux_> ok
09:23:19 <ski> Nux_ : specifically, you're both attempting to use the function on an argument of type `a' (where `a' is some unknown (numeric) type, that will be decided by the caller of your test function) *and* also on an argument of type `Interval a' (for the *same* `a')
09:23:34 <Nux_> ski, I will read what you've said in a sec
09:23:42 <ski> Nux_ : write `{-# LANGUAGE Rank2Types #-}' before the `module' line in your source file
09:24:17 <ski> (`RankNTypes' will also work. but `Rank2Types' is enough here)
09:25:31 <Nux_> ok that seems to be behaving as I wanted
09:25:33 <ski> Nux_ : using `forall' in the *argument* type specifies that you require that the caller of the testing function passes a *polymorphic* function as argument to it
09:25:37 <Nux_> now I'll read what you've said
09:26:26 <Nux_> yes
09:26:33 <Nux_> I suspected this was the problem
09:26:39 <Nux_> thanks
09:26:46 <ski> (oh, s/Fractionbal/Fractional/ .. btw, i'm not sure you really need/want to require `Fractional' at all here)
09:27:35 <Nux_> I'm not entirely sure, but I believe it was suggested by the compiler
09:27:39 <ski> Nux_ : it looks like your testing is attempting to compare the result of some numeric operations on (a) some numeric type `a'; and (b) the corresponding `Interval a' type built out of it
09:27:44 <Nux_> I'll test removing it
09:28:27 <Nux_> fractional is required because of my used of '9.9'
09:28:28 <geekosaur> unexpected Fractional usually means you did (/) in an integer-like context
09:28:31 <geekosaur> oh
09:28:35 <ski> oh, right
09:28:49 <Nux_> hehe I didn't notice that either
09:29:14 * ski was thinking it might have to do with that `Show' instance, but didn't see any call to a `Show'-requiring operation in the testing functions
09:30:03 <Nux_> yeah I was going to look there, but after deleting the type constraint the compiler pointed me at the problem
09:30:04 <ackthet> err, did my cat send any messages while i was gone? <_<
09:30:10 <ackthet> looks like yes 
09:30:25 <ski> Nux_ : do you see how, if you had only used `signum' (say) on `a', or only on `Interval a', but not both, in say `testSignum', you wouldn't have used `signum' polymorphically, only monomorphically ?
09:30:33 <Luke> is there a lens function for getting state from a state monad, apply a function, then run a lens on it?
09:30:41 <Luke> like "use" but apply a function after the get?
09:30:53 <glguy> uses?
09:30:56 <Nux_> ackthet, a search for 'meow' in the chat log came up empty
09:31:21 <ackthet> :P
09:31:27 <Luke> glguy: looks like uses does the get, then the lens, then the function app
09:31:32 <Nux_> ski, yes I do
09:31:37 <Luke> glguy: I need get, function, lens
09:31:45 <ackthet> one of my cats walks on my keyboard and looking at my sent messages it looked like he managed to get word out on the internet that he was hungry
09:32:21 <ski> Nux_ : it's not that common to need to pass/accept polymorphic arguments .. but it's very handy to be able to do it, when it would be appropriate
09:32:22 <glguy> Luke: Then you'll need something like: use (to someFunction . someFold)
09:32:31 <Luke> glguy: perfect. thanks. that's what I was looking for
09:32:55 <ski> Nux_ : but you need this extension for it to work (and you must figure out the type signature and type it yourself. the system can't infer it for you)
09:33:27 <Luke> glguy: in your example, which function is the lens?
09:33:34 <Luke> glguy: someFunction or someFold?
09:33:41 <glguy> someFold
09:33:42 <ski> Nux_ : sometimes, one can also use this feature for purposes of information hiding
09:33:57 <glguy> Luke: use doesn't need a lens, it needs a fold (and lenses happen to be folds)
09:34:08 <Luke> ah gotcha
09:34:09 <Luke> thanks
09:34:31 <Luke> these types are insane
09:34:49 <Nux_> ski, no doubt I'd prefer not to have to depend on the extension, is there a simple way of re-expressing what I wanted to achieve without the use of it?
09:35:16 <glguy> Luke: There's basically one pattern they all revolve around. Once you learn that the rest is just minor variations
09:35:32 <Luke> yeah I know the pattern. i use lenses a lot... just don't get all this optical stuff
09:35:49 <glguy> optic is the pattern
09:36:07 <Luke> the problem is I figure out what I need w/ lenses and then come back months later to some code with a slight change to the datatype and can't figure out how to change my lenses
09:36:13 <ski> Nux_ : in this case no (since you actually wanted to use the argument polymorphically), not without passing the argument twice
09:36:45 <Nux_> ski, that's workable (albeit a little less pretty)
09:37:22 <Luke> glguy: I don't doubt there's patterns to all of it. just saying I forget the patterns and have to keep relearning them
09:37:28 <Nux_> so would I specify in the signature that the first function has signature (a -> a) and the second (Interval a -> Interval a)?
09:37:34 <Luke> glguy: reminds me of reading music =) i've re-learned and forgotten like 5 times
09:37:40 <ski> Nux_ : iow, if you'd be ok with `test lower upper signum signum', that'd work. but if you (successively) bind `f' to `signum',`abs',`negate',`(^ 2)', then (probably) that binding will itself be monomorphic, so `test lower upper f f' will then not work
09:37:51 <ski> Nux_ : yep
09:39:16 <ski> (it depends on how you bind `f'. if you bind it in a list comprehension generator, a lambda, or a `do'-notation binding, then it will be monomorphic. if you (re)bind it with `let', then polymorphic)
09:40:26 <Nux_> sky, am I right in saying that even if a function is polymorphic, it must be resolvable to a single monomorphic type within a given scope?
09:40:33 <Nux_> *ski
09:40:49 <ski> hm, maybe something like `testFunctionArguments !! i' could work, not sure
09:41:35 <ski> Nux_ : i'm not quite sure what you mean by "resolvable to a single monomorphic type within a given scope"
09:41:52 <Nux_> let me go grab some terminology
09:41:54 <Nux_> brb
09:42:39 <ski> Nux_ : (mostly) every time you use a polymorphic operation, you use a specific monomorphic instance of it
09:42:56 <ski> (and the "mostly" could be interpreted to fit into the above as well)
09:44:39 <ski> Nux_ : if you say `length "abc" + length [False,True]' (where we know `length :: forall a. [a] -> Int', so `length' itself is polymorphic), then the first usage of `length' is here used with type `[Char] -> Int' (so `a' has been instantiated to `Char' in this case), while the second usage of `length' is used with type `[Bool] -> Int' (so `a' has been instantiated to `Bool')
09:45:06 <Nux_> ok
09:45:21 <Nux_>  I thought I'd done that kind of thing before
09:46:01 <Nux_> so the reason that's ok is that the arguments determined the function 'instance'
09:46:45 <ski> Nux_ : if we define `foo xss = length xss + sum [length xs | xs <- xss]' then the type of `foo' will be inferred as `forall a. [[a]] -> Int'. conceptually when `foo' is called, a single concrete (monomorphic) type is chosen for `a' here (but the code defining `foo' doesn't know which)
09:47:46 <ski> Nux_ : here, the type used for the first call to `length' will be `[[a]] -> Int' (for this particular (unknown) type `a'), and `[a] -> Int' for the second call to `length'
09:49:06 <Nux_> terminology question: is the type 'a' a concrete type where 'a' is a type variable?
09:49:24 <ski> Nux_ : even though the type `a' here is unknown, both uses of `length' are still monomorphic
09:51:15 <ski> Nux_ : as soon as we know for which type `a' `foo' is called (e.g. perhaps we're calling it as `foo ["abc","de"]', so then `a' is `Char'), we also know the concrete types that the two *uses* of `length' has (namely `[[Char]] -> Int' and `[Char] -> Int' in this example)
09:51:48 <jabesed> ski: I get it that demanding one to always explicitely write foralls would be a pain, but I always felt the lack of foralls leads to the Nux_ question about a being concrete or a type variable
09:51:54 <ski> Nux_ : i'm not quite sure how to answer your question
09:52:34 <jabesed> ski: I was guessing that question was about to come
09:52:56 <Nux_> I believe that 'Int' is a concrete type
09:53:28 <Nux_> I believe that the type of a particular value is a concrete type
09:54:08 <ski> Nux_ : "concrete type" has several possible different meanings that people (myself included) has used it for
09:54:59 <ski> Nux_ : let me first say that (in this context) i think "monomorphic type" (and also "polymorphic type") is a bad term to use
09:55:35 <ski> `length' is polymorphic. its type, `forall a. [a] -> Int' is not polymorphic (one can say that it is a universal type, iow the type of a polymorphic value)
09:56:37 <ski> now, the two *uses* of `length' above are *not* polymorphic (their types don't start with `forall'. that they happen to mention a type variable, `a', is irrelevant)
09:57:00 <ski> Nux_ : makes sense ?
09:57:15 <Nux_> I believe so
09:57:20 <Nux_> is 1 a polymorphic value?
09:57:25 <ski> yes
09:57:27 <ski> @type 1
09:57:28 <lambdabot> Num a => a
09:57:46 <ski> which really should say `forall a. Num a => a', if we're being explicit
09:58:10 <ski> it's a fact that Haskell, in *certain* situations, allows you to leave off the `forall', leaving it implicit
09:58:22 <Nux_> (I don't believe I'm having trouble with the concepts here, I just want to get the terminology down so I can ask better questions)
09:58:22 <ski> but it's still conceptually there (and it's important to understand this)
09:58:30 * hackagebot midi-util 0.1.1.1 - Utility functions for processing MIDI files  http://hackage.haskell.org/package/midi-util-0.1.1.1 (mtolly)
09:59:04 <ski> more specifically, a `forall' that appears directly after the `::' in a type signature can usually be left implied
09:59:05 <Nux_> the same thing occurs in maths notation and I'm sure that's no coincedence
09:59:19 <jabesed> I think it helps to underestand what's going on if you look at how application involving polymorphic terms work at the type level
09:59:57 <ski> yes, thinking of polymorphism in terms of (implicitly) passing around types helps
10:01:04 <jabesed> was thinking of explicitely going through the typing rules
10:01:34 * ski nods
10:01:53 <Nux_> f :: (a -> b) -> a, x :: Int -> Bool, f x :: Int
10:02:02 <jabesed> as in, applying  (id :: forall a. (a->a) ->(a->a))  ((+1) ::Int ->Int)
10:02:13 <jabesed> and then
10:02:29 <negatratoron> hey, i submitted a pull request to the Haskell website to change "advanced" to "general-purpose" in "Haskell is an advanced purely-functional language"
10:02:31 <jabesed> applying  (id :: forall a. (a->a) ->(a->a))  (id :: forall a. (a->a) ->(a->a))
10:02:38 <negatratoron> just wondering what you guys think about that idea
10:02:46 <ronh-> is there a read equivalent that will parse missing Maybe fields to Nothing? given data A { a :: Maybe Int, b :: Maybe String }  readFunc "A { a = Just 10 }" should give A { a = Just 10, b = Nothing }?
10:02:48 <negatratoron> link: https://github.com/haskell-infra/hl/pull/107
10:03:16 <ski> Nux_ : anyway. regarding "concrete type". some people (including me) have been trying to reserve that term to mean "a type that can possible have values". e.g. `Either [Int] Bool' is a concrete type, but `Either [Int]' isn't (it's a type function, aka a parametric type)
10:03:31 * hackagebot GrammarProducts 0.1.0.0 - Grammar products and higher-dimensional grammars  http://hackage.haskell.org/package/GrammarProducts-0.1.0.0 (ChristianHoener)
10:03:38 <jle`> is there a list somewhere about which ghc versions have which version of base?
10:03:40 <geekosaur> negatratoron, #haskell-infrastructure
10:03:56 <negatratoron> thanks
10:04:00 <jabesed> in the first case one gets       (id :: forall a. (a->a) ->(a->a))  ((+1) ::Int ->Int)  ===> (id ::  (Int->Int) ->(Int->Int))  ((+1) ::Int ->Int) 
10:04:00 <jle`> oh wait, found it
10:04:05 <Nux_> ski, that seems to agree with my understanding of the term
10:04:06 <ski> Nux_ : this is a different sense of "concrete" from considering `forall a. [a] -> Int' (or even `[a] -> Int') as "nonconcrete"
10:04:42 <jabesed> that is, the forall disappears as `a` is instantiated to `Int`
10:05:33 <jabesed> in the second case both foralls disappear, and the type variable `a` is instantiated to some dummy type `a` (or `b` call it what you want)
10:06:19 <jabesed> that is  (id :: forall a. (a->a) ->(a->a))  (id :: forall a. (a->a) ->(a->a)) ===> (id :: (a->a) ->(a->a))  (id ::  (a->a) ->(a->a))   where the `a` in the latter terms is not a type variable
10:06:32 <jabesed> even though it is a lower case a
10:07:15 <Nux_> that looks somewhat familiar in terms of untyped lambda calculus
10:07:23 <jabesed> and *this* is why having an explicit forall at all times would clear all these confusions
10:07:26 <Nux_> but I'm unsure what it entails here
10:08:31 * hackagebot snap-extras 0.11 - A collection of useful helpers and utilities for Snap web applications.  http://hackage.haskell.org/package/snap-extras-0.11 (DougBeardsley)
10:09:47 <jle`> ghc 7.6.x doesn't build on ghc-7.10
10:09:52 <jabesed> Nux_: the idea is that the first term, with forall, has a type variable that can be substituted 
10:10:06 <jle`> luckily i still have 7.8 but i can imagine it being a big headache if i didn;t, heh
10:10:33 <jabesed> Nux_: while in the second term I wrote, what a is meant to represent is some unkown constant type
10:10:49 <jabesed> Nux_: which can't be substituted
10:11:33 <jabesed> Nux_: but these terms with uknown constant types are not something you can write yourself  in haskell
10:12:38 <Nux_> would I be right in saying that 'forall' indicates a polymorphism which in a sense has yet to establish which of a set of 'implementations' of different but similarly named functions, whereas a value with a type containing type variables is a different kind of polymorphism over the set of all types (constrained by any present type constraints)?
10:12:50 <jabesed> Nux_: they do however occur during the type checking/type inference process
10:13:16 <jabesed> Nux_: no
10:13:59 <jabesed> Nux_: first of all, this is very important,   when you write   id :: a -> a   in haskell, this is a shortand for   id :: forall a. a->a
10:14:40 <Nux_> and those 'a's are not the type variable you see in say the type of undefined
10:14:41 <jabesed> in other words the types of polymorphic terms always 'have' a forall, either explicit or implicit
10:14:42 <Nux_> ?
10:15:01 <jabesed> the type of undefined is   forall a . a 
10:15:13 <Nux_> ah
10:15:21 <jabesed> you can write   undefined :: a 
10:15:37 <jabesed> but it's shortand for  undefined :: forall a. a
10:15:48 <jabesed> this just makes it simpler to write
10:16:05 <Nux_> yes
10:16:15 <jabesed> because in standard haskell there is no ambiguity
10:16:50 <Nux_> so the other 'a' you referred to is a type that only the compiler handles?
10:17:24 <Nux_> when you applied id to id
10:17:32 <jabesed> so in standard haskell if you write  a's and b's and c's in the type, anything starting with a lower letter, then it is assumed to be a quantified type variable
10:17:36 <jabesed> yes
10:17:49 <jle`> 7.6 seems to also be unable to be built on 7.8
10:18:05 <Nux_> I think I follow
10:18:14 <Nux_> unfortunately I have to be going
10:18:21 <Nux_> but I'll no doubt be back sometime
10:18:21 <jabesed> so in usual type theoretical notation you need the forall to indicate it is a type variable
10:18:31 * hackagebot aws-configuration-tools 0.1.0.0 - Configuration types, parsers & renderers for AWS services  http://hackage.haskell.org/package/aws-configuration-tools-0.1.0.0 (JonSterling)
10:18:38 <Nux_> thanks for your help ski, jabesed et al
10:18:43 <jabesed> if it's not in the scope of a forall you should think of it as some uknown constant
10:18:50 <jabesed> sure
10:18:53 <jabesed> I'm off too
10:20:11 <jle`> how can i build 7.6 TT_TT
10:21:10 <bennofs> jle`: using ghc 7.4? :)
10:21:30 <bennofs> jle`: or just use ghc 7.6 binaries to build 7.6 from source
10:21:43 <jle`> i can't use 7.6 binaries because i have the wrong libgmp.so
10:21:45 <jle`> :'(
10:23:11 <maerwald> jle`: does your distribution support compiling from source via the PM?
10:23:31 * hackagebot bimaps 0.0.0.1 - bijections with multiple implementations.  http://hackage.haskell.org/package/bimaps-0.0.0.1 (ChristianHoener)
10:24:08 <bennofs> jle`: use nix to get 7.6 binaries and the compile 7.6 with that?
10:24:20 <jle`> it might, but having pm stuff mix with my normal stuff makes me uncomfortable for some reason
10:25:26 <maerwald> jle`: opensuse has source rpms, archlinux supports installing via pkgbuilds, under freebsd it will also work etc
10:32:59 <erisco> what's the new hotness for benchmarking?
10:35:57 <c_wraith> erisco: as far as I know, still criterion
10:36:16 <c_wraith> erisco: but the latest version of criterion really displays results way better at the command line
10:37:08 <erisco> c_wraith I see, thanks
10:38:32 * hackagebot digestive-functors-aeson 1.1.14 - Run digestive-functors forms against JSON  http://hackage.haskell.org/package/digestive-functors-aeson-1.1.14 (OliverCharles)
10:38:34 * hackagebot fgl-extras-decompositions 0.1.1.0 - Graph decomposition algorithms  http://hackage.haskell.org/package/fgl-extras-decompositions-0.1.1.0 (ChristianHoener)
10:38:36 * hackagebot hood2 0.2.1 - Debugging by observing in place  http://hackage.haskell.org/package/hood2-0.2.1 (rayqiu)
10:38:38 * hackagebot SuffixStructures 0.0.1.0 - Suffix array construction  http://hackage.haskell.org/package/SuffixStructures-0.0.1.0 (ChristianHoener)
10:39:10 <gilligan_> any nixos/haskell-ng users around by any chance?
10:39:19 <erisco> sigh somehow another cabal reinstall conflict has manifested itself
10:39:24 <johnw> gilligan_: yes
10:39:26 <oconnore> bitemyapp: thanks for your help :) things worked -> http://i.imgur.com/D7f45z5.jpg 
10:39:33 <erisco> last time this happened it took all day to fix
10:40:10 <gilligan_> johnw ;-)
10:40:28 <gilligan_> johnw, i am trying to figure out how I can install cabal-install 1.20.x
10:40:34 <gilligan_> johnw, i am using ghc 7.8.4
10:40:42 <erisco> blaze-builder-0.4.0.1 (reinstall) changes: text-1.1.0.0 -> 1.2.0.4
10:40:45 <erisco> what does that even mean
10:40:53 <johnw> nix-env -iA haskell-ng.ghc784.cabal-install
10:41:00 <johnw> nix-env -iA haskell-ng.packages.ghc784.cabal-install
10:41:07 <erisco> I have blaze-builder-0.4.0.1 and text-1.2.0.4 installed already
10:41:19 <gilligan_> johnw, I tried nix-env -i -A haskell-ng.packages.ghc784.cabal-install  but that fails with missing deps
10:41:21 <erisco> why does it need to reinstall
10:41:28 <erisco> why does it need to change a text version
10:41:29 <erisco> I hate cabal
10:41:30 <Haskellfant> erisco: using sandboxes?
10:41:34 <erisco> Haskellfant no
10:41:38 <johnw> gilligan_: you're not giving me much to go on...
10:41:43 <Herogx> monochrom: Huge thanks for that tutorial link yesterday, really helped me with a lot of things
10:41:49 <gilligan_> johnw, hang on
10:41:51 <Haskellfant> erisco: than your blaze-builder is probably built against a different version of text
10:42:06 <Haskellfant> *then
10:42:25 <gilligan_> johnw, http://t.co/RVHhaXZGM8
10:43:05 <gilligan_> johnw, my tiny config.nix is http://t.co/aPdyDVYTix which should just default to 7.8.4
10:43:13 <gilligan_> johnw, so i am a bit stuck right now
10:43:38 <erisco> Haskellfant why would it care :(
10:43:40 <johnw> try removing the config.nix for now
10:43:40 * hackagebot tasty-rerun 1.1.4 - Run tests by filtering the test tree depending on the result of previous test  runs  http://hackage.haskell.org/package/tasty-rerun-1.1.4 (OliverCharles)
10:43:42 * hackagebot through-text 0.1.0.0 - Convert textual types through Text without needing O(n^2) instances.  http://hackage.haskell.org/package/through-text-0.1.0.0 (AdamBergmark)
10:43:42 <johnw> it's not doing anything
10:46:12 <gilligan_> johnw, I am pretty sure it does ? without it if I did a nix-shell with a shell.nix from cabal2nix I would get ghc7.10 and with it 7.8.4
10:47:10 <johnw> yeah, but it's not really complete enough I don't think
10:47:28 <johnw> maybe it is, I don't know
10:47:36 <johnw> but try installing cabal-install without it
10:47:55 <gilligan_> johnw, alright I did, same result though
10:48:06 <johnw> then i'd ask the Nix mailing list
10:48:10 <johnw> or #nixos
10:48:21 <gilligan_> johnw, mailing list then - i tried #nixos
10:48:45 <gilligan_> johnw, thank you though!
10:52:32 <erisco> Haskellfant well I unregistered packages to peel back to blaze-builder and then reinstalled it
10:52:45 <erisco> unfortunate that the entire tree has to be rebuilt... but whatever
10:53:14 <erisco> my lap was cold anyways
10:58:08 <samba1> @hoogle (Monad m, Functor f) => (a -> m (f b)) -> f a -> m (f b)
10:58:09 <lambdabot> Language.Haskell.TH.Quote dataToExpQ :: Data a => (forall b. Data b => b -> Maybe (Q Exp)) -> a -> Q Exp
10:58:09 <lambdabot> Language.Haskell.TH.Quote dataToPatQ :: Data a => (forall b. Data b => b -> Maybe (Q Pat)) -> a -> Q Pat
10:58:17 <samba1> what am I looking for?
10:58:34 <c_wraith> :t traverse
10:58:34 <samba1> I have a ByteString -> IO (Maybe ByteString) and a Maybe ByteString
10:58:35 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
10:58:52 <c_wraith> Oh, that doesn't quite fit
10:59:23 <samba1> I can do it with a bunch of symbols and parentheses but I thought there might be something concise that already exists
11:02:02 <tempname11_> samba1: that signature is a bit weird to be honest
11:02:08 <tempname11_> what are you trying to acheve?
11:02:33 <enthropy> samba1: with that exact type signature? fun :: (Monad m, Functor f) => (a -> m (f b)) -> f a -> f (m (f b)); fun = fmap
11:02:45 <kadoban> samba1: So you're trying to end up with an IO (Maybe ByteString) I assume?
11:02:47 <samba1> it's a bit involved, but for example I might have a filename as a bytestring and a function that takes that filename and returns Maybe the contents in IO
11:02:55 <Herogx> Why when use the "ghci <filename>" command to load a file of functions into ghci, can't it see functions starting with a do block?
11:03:14 <samba1> yes, I have no choice but to end with an IO (Maybe ByteString)
11:03:17 <Herogx> actually it's not picking up anything, I'm going to reboot my pc 
11:03:34 <jle`> Herogx: i've never used ghci that way
11:03:42 <jle`> what happens if you just open it up normally
11:03:47 <jle`> and typed :load <filename> ?
11:03:51 * hackagebot auto 0.4.2.1 - Denotative, locally stateful programming DSL & platform  http://hackage.haskell.org/package/auto-0.4.2.1 (jle)
11:04:09 <tempname11_> samba1: why the "f a" as the second argument then? you want to pass Maybe Filename?
11:04:25 <Herogx> nope
11:04:27 <Herogx> Nothing
11:04:34 <kadoban> samba1: maybe (pure Nothing) theFunc theMaybe   ?
11:04:40 <Herogx> not in scope error, and what's weird
11:04:47 <Herogx> is I've actually compiled the application
11:04:47 <johnw> samba1: you can 'traverse' your function in the Maybe ByteString, and then fmap join on it
11:05:11 <Herogx> I'm attempting to use :t <func_name> to get the types so I can put them in above functions
11:05:15 <samba1> I have a maybe filename
11:05:27 <jle`> Herogx: are you workign on a cabal project?
11:05:41 <Herogx> Just standard haskell
11:05:59 <Herogx> I'm going to test a file with just a = 1 and see if it can pick that up
11:06:03 <jle`> so you're just using a .hs file?
11:06:07 <jle`> mk
11:06:09 <Herogx> yes
11:06:11 <Herogx> .hs
11:06:18 <kadoban> :t maybe (pure Nothing) (undefined :: a -> IO (Maybe a)) (undefined :: Maybe a)
11:06:19 <lambdabot> IO (Maybe a)
11:06:24 <johnw> :t \f x -> fmap join $ traverse (f :: String -> IO (Maybe String)) (x :: Maybe String)
11:06:25 <lambdabot> (String -> IO (Maybe String)) -> Maybe String -> IO (Maybe String)
11:07:51 <Herogx> wellp it picked up that...
11:08:19 <tempname11_> johnw: nice solution
11:08:21 <jle`> Herogx: what do you mean by "functions starting with a do block"?
11:08:51 <samba1> johnw: thanks - I don't think I'll use it though as it's more confusing that what I've got already to me. I thought there might be something like this already, but thanks
11:09:01 <Herogx> well what the hell
11:09:03 <Herogx> it's working now
11:09:14 <Herogx> I put a::Integer; a=1 into the file
11:09:20 <Herogx> and now it picks up my functions
11:09:42 <Herogx> jle` I mean that any function that had IO in it, like func = do something
11:09:56 <Herogx> It's working now though so I don't really know what the issue was...
11:10:34 <jle`> oh, heh. interesting :)
11:10:39 <jle`> glad it works though!
11:11:03 <Herogx> So am I because I was totally confused for about 10 minutes there lol
11:11:13 <jle`> :D
11:12:07 <Lis> hello everyone. i have a function which uses map to return a list but i need another value for the calculation withing map. how can i make a variable "local" avaliable to the function?
11:13:21 <ion> foo local = map (something with local) list
11:13:29 <ion> I.e. as a function parameter
11:13:36 <xplat> or in a where
11:13:40 <xplat> or
11:14:04 <Lis> ion, ok, but i need the avarage of list, and use it with something
11:14:13 <xplat> > let x = 3 in map (\y -> x * y) [1..3]
11:14:14 <lambdabot>  [3,6,9]
11:14:32 <Lis> ah ok. thank you
11:14:37 <johnw> samba1: it pays to become very familiar with 'traverse', since you can use it in a huge number of situations
11:15:07 <johnw> the 'fmap' was to get "under" the IO, and the 'join' was to smush the Maybe (Maybe ByteString) down to Maybe ByteString inside
11:15:36 <samba1> johnw: yes, I do know a bit about it and am learning more, but for something this simple I think all that is more confusing than just using do notation
11:15:37 <jle`> traverse :: (a -> f b) -> (Maybe a -> f (Maybe b)) here, so traverse gave you an IO (Maybe (Maybe b))
11:16:24 <johnw> samba1: quite possibly
11:17:11 <samba1> jle`: thank you, I do understand the signature, I just thought there might be something already defined for doing a bind under the cover of another monad
11:17:29 <tempname11_> johnw: can your version be written in point-free style? so far I got (fmap . fmap) join . traverse, but it's weird :)
11:17:49 <johnw> (fmap join .) . traverse
11:18:10 <jle`> you can do it with a newtype wrapper to provide an alternative monad instance for IO+Maybe
11:18:42 <jle`> tempname11_: probably best to leave one point in, \f -> fmap join . traverse f
11:18:51 * hackagebot fasta 0.6.1.0 - A simple, mindless parser for fasta files.  http://hackage.haskell.org/package/fasta-0.6.1.0 (GregorySchwartz)
11:18:53 * hackagebot yesod-markdown 0.9.4 - Tools for using markdown in a yesod application  http://hackage.haskell.org/package/yesod-markdown-0.9.4 (PatrickBrisbin)
11:19:11 <jle`> samba1: if you have a lot of IO Maybe's, then you might benefit from using it
11:19:18 <tempname11_> :t (fmap join (.)) . traverse
11:19:19 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ a -> t a1
11:19:20 <lambdabot>     Expected type: (t a1 -> f (t b))
11:19:20 <lambdabot>                    -> (a -> t a1) -> (a -> t a1) -> f (t b)
11:19:31 <tempname11_> :t (fmap join .) . traverse
11:19:32 <lambdabot> (Monad m, Applicative f, Traversable m) => (a1 -> f (m a)) -> m a1 -> f (m a)
11:19:41 <tempname11_> oh, it's a section
11:19:53 <tempname11_> I thought that was a typo :)
11:20:27 <jle`> :t \f x -> (MaybeT . f) (maybe mero return x)
11:20:29 <lambdabot>     Not in scope: data constructor âMaybeTâ
11:20:29 <lambdabot>     Perhaps you meant variable âmaybeâ (imported from Data.Maybe)
11:20:29 <lambdabot>     Not in scope: âmeroâ
11:21:16 <jle`> :t \f x -> (MaybeT . f) (maybe mzero return x)
11:21:17 <lambdabot> MonadPlus m1 => (m1 a1 -> m (Maybe a)) -> Maybe a1 -> MaybeT m a
11:21:49 <jle`> if you are working with a lot of IO Maybe's you can leave it as MaybeT and bind from there
11:21:56 <jle`> or you can exit out of it with runMaybeT
11:22:21 <tempname11_> we need a separate #haskell-golf channel for these things =)
11:23:54 <tempname11_> a month ago johnw's code would have been complete gibberish to me. now it kinda makes sense intuitively... that's such a great feeling :)
11:24:49 <xplat> :t \f x -> (MaybeT . f) (hoist return x)
11:24:50 <lambdabot> Not in scope: âhoistâ
11:24:53 <ion> (fmap join .) . traverse? I know what it means but it makes the opposite of sense. :-P
11:24:59 <xplat> bleh, no mmorph
11:25:09 <jle`> sorry, totally butchered that
11:25:11 <jle`> :t \f x -> (MaybeT (return x)) >>= (MaybeT . (f :: String -> IO (Maybe String)))
11:25:12 <lambdabot> (String -> IO (Maybe String)) -> Maybe String -> MaybeT IO String
11:25:31 <jle`> xplat: hoist is incompatible with Maybe, unfortunately
11:25:37 <jle`> s/Maybe/MaybeT
11:25:46 <xplat> jle`: what?  why?
11:25:51 <jle`> wrong kind
11:26:16 <jle`> it would work if type Maybe = MaybeT Identity
11:26:16 <dolio> tempname11_: I hope you intuitively know that you should pretty much never write '(f .) . g' as well. :)
11:26:26 <bitemyapp> oconnore: awesome :)
11:26:35 <jle`> 'wrong kind' is probably a bad answer
11:26:45 <xplat> jle`: oh, hm.
11:27:00 <xplat> just needs an extra converter
11:27:19 <tempname11_> dolio: oh, you prefer (.) f . g ? :P
11:27:34 <exio4> I prefer \x y -> f (g x y)
11:27:50 <exio4> or \x -> f . g x
11:27:50 <dolio> You should use 'fmap f . g', clearly.
11:27:52 <xplat> :t \f x -> MaybeT . f . hoist return . coerce $ x
11:27:53 <lambdabot> Not in scope: âhoistâ
11:28:06 <dolio> That way when you go back later, you'll spend 15 minutes wondering what you're fmapping over.
11:28:06 <tempname11_> well, I actually did above :)
11:28:48 <jle`> why not (fmap fmap fmap) f g
11:28:51 * hackagebot snap-server 0.9.5.1 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.9.5.1 (GregoryCollins)
11:29:05 <exio4> fmap fmap fmap join traverse
11:29:13 <exio4> that sure looks good
11:29:20 <jle`> we're done here
11:29:21 <xplat> fmap fmap fmap -- the sound of mental masturbation
11:29:57 <MP2E> do you even fmap bro? *shot*
11:30:01 <tempname11_> exio4: forgot the . :P
11:30:30 <jle`> :t fmap fmap fmap join traverse
11:30:31 <lambdabot> (Monad m, Traversable m) => (a1 -> m a) -> m a1 -> m a
11:30:56 <exio4> oh no
11:31:00 <tempname11_> MP2E: there's a liftM joke somewhere
11:31:04 <exio4> :t fmap fmap fmap (fmap join) traverse
11:31:05 <lambdabot> (Monad m, Applicative f, Traversable m) => (a1 -> f (m a)) -> m a1 -> f (m a)
11:31:13 <exio4> there tempname11_ 
11:32:35 <remy> Hi, I'm trying to understand traversable
11:32:45 <remy> if I do this: :t Data.Traversable.sequence (replicate 5)
11:33:25 <remy> Data.Traversable.sequence (replicate 5) :: Traversable ((->) a) => [a -> a]
11:34:02 <jle`> what did you expect it to do...?
11:34:05 <remy> I'm not really sure what that's telling me, but it looks like a list of functions
11:34:36 <jle`> yeah, it's a list of functions, if there's a Traversable instance for ((->) a).  but there isn't, unfortunately
11:34:37 <Stratege> only if you have a traverseable instance for functions.
11:34:40 <jle`> at least not a general one
11:34:53 <remy> I see
11:34:57 <jle`> you can write specific ones for specific a's, but nothing like that is in base
11:35:25 <remy> this works: Data.Traversable.sequence [(+1), (+10)](2)
11:35:36 <remy> so I guess I can traverse a list of functions
11:35:42 <jle`> yeah, you can traverse a list
11:35:42 <remy> but not a function of lists
11:35:52 <jle`> yeah, check out the type of sequence
11:35:54 <jle`> :t sequence
11:35:55 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
11:35:57 <c_wraith> I don't even know what a function of lists is
11:36:19 <jle`> the outside is a Traversable, and the inside is a Monad (or Applicative for sequenceA)
11:36:33 <remy> Ok, that makes sense
11:36:38 <jle`> so [a -> b] fits, with t ~ [] and m ~ functions from a
11:36:57 <remy> I just wasn't sure if function is a Traversable
11:37:13 <jle`> a -> [b] would be t ~ functions from a, m ~ [], but functions from a is not Traversable
11:37:18 <xplat> :t join fmap fmap (fmap join) traverse
11:37:19 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ a1 -> a
11:37:19 <lambdabot>     Expected type: ((((a1 -> a1) -> a1 -> a1 -> a)
11:37:19 <lambdabot>                      -> (a1 -> a1) -> a1 -> a)
11:37:21 <jle`> yeah, you can check with :i on ghci :)
11:37:43 <remy> is there something which documents all of the typeclasses which function implements?
11:37:50 <jle`> remy: yeah, hackage
11:37:54 <ion> For the hypothetical (->) e instance, traverse :: (a -> f b) -> (e -> a) -> f (e -> b). You can tell it can not be implemented in general with just a visual inspection.
11:38:11 <jle`> remy: and also ghci can tell you what instances are in scope
11:38:16 <jle`> https://www.haskell.org/hoogle/?hoogle=Traversable
11:38:21 <jle`> http://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Traversable.html
11:38:33 <remy> thanks ion
11:38:45 <jle`> if you ever encounter a new type then you can use :i to check out what typeclasses it instances
11:38:48 <remy> also jle` :)
11:38:52 <jle`> np!
11:39:06 <remy> oh cool
11:40:14 <jle`> by the way, if you're using ghc 7.10, Data.Traversable.sequence is just Prelude.sequence, so you don't need to qualiffy
11:41:32 <remy> right, is that the shiny new FTP thing?
11:42:39 <c_wraith> yes
11:45:15 <kaiyin> is it possible to use jar files produced by scala? e.g. http://search.maven.org/#search%7Cga%7C1%7Cjhdf5
11:45:42 <jle`> i'm sure ther emust be a way..otherwise scala would be useless :)
11:45:47 <jle`> but i don't ahve any experience with scala
11:48:52 * hackagebot aws-kinesis-client 0.4.0.2 - A producer & consumer client library for AWS Kinesis  http://hackage.haskell.org/package/aws-kinesis-client-0.4.0.2 (JonSterling)
11:49:17 <Denommus> hm
11:50:15 <Javran> is it safe to remove old ghc installations by removing /lib/ghc-X-Y-Z?
11:50:15 <Denommus> does anyone have any idea on how I can create tests for arrows that represent continuous values?
11:50:27 <Denommus> Javran: why don't you use your package manager?
11:50:39 <jle`> Denommus: in what way do your arrows represent continuous values?
11:50:45 <Javran> I've just done a long chain of bootstraping from ghc-6.8 to ghc-7.8
11:51:04 <Herogx> Easiest way to convert [char] to char?
11:51:06 <Denommus> jle`: that's actually misleading. They representing transformations of continuous values. But I know the input
11:51:26 <Javran> Denommus: because I don't have the permission, RHEL5, with all out-dated packages :(
11:51:38 <jle`> Herogx: how do you want to handle "" ?
11:51:40 <Guest1170> ciao
11:51:42 <Javran> have to prefix everything in my local directory
11:51:43 <Guest1170> !list
11:51:43 <monochrom> Guest1170: http://lpaste.net/browse
11:51:49 <Herogx> Well, the way I have it, it's a singleton list
11:51:54 <Herogx> probably !!0 
11:51:58 <Herogx> but that looks ugly
11:51:59 <Denommus> Javran: ... if you don't have permission, how do you expect to remove from /lib
11:51:59 <jle`> Herogx: you can probably pattern match
11:52:01 <Guest1170> http://www.groupon.it/?&utm_source=google&utm_medium=cpc&utm_campaign=it_dt_sea_ggl_txt_naq_sr_cbp_ch1_ybr_k*groupon_m*e_d*Groupon-Brand_g*Groupon-Exact_c*59418553702_ap*1t1
11:52:22 <jle`> or use `listToMaybe`
11:52:24 <Denommus> Javran: but no, don't remove anything from /lib or /bin directly, you may break your system. Package managers should always be used
11:52:27 <jle`> and then fromMaybe/maybe
11:52:28 <Javran> Denommus: I meant it's actually $HOME/prefix/lib ... I configured it to install locally
11:52:31 <Herogx> :t listToMaybe
11:52:32 <lambdabot> [a] -> Maybe a
11:52:37 <Denommus> Javran: ah
11:52:40 <Herogx> hm that's cool
11:52:41 <jle`> Denommus: you might be able to write property tests
11:52:45 <Herogx> I'll try that, thanks
11:53:08 <Denommus> Javran: I don't know, then
11:53:34 <Denommus> jle`: is that similar to Scala's properties?
11:53:45 <jle`> Denommus: for example if your arrow represents a time integral, you can do something like feed in a time signal (x(t) = t) and then check that x(t) = 1/2 t^2
11:53:58 <jle`> Denommus: not familiar with those, but they're like quickcheck
11:54:23 <jle`> @check \xs -> even (xs * 2)
11:54:25 <lambdabot>  +++ OK, passed 100 tests.
11:55:29 <ice799> Hi! I'd like to build my own Haskell debs. I was looking at the source, but I couldn't find the debian packaging stuff. Is there stored in a different repo or something? I figured since haskell had deb.haskell the debian packaging stuff was already done and in the source somewhere. Anyone know where?
11:56:46 <Denommus> jle`: thanks
11:57:27 <bergmark> ice799: https://hackage.haskell.org/package/cabal-debian ?
11:58:48 <benzrf> whats the utility of lazy pattern matches when let exists
12:01:29 <dolio> There are many situations where ~ is more convenient.
12:01:34 <clusterxl> hi 
12:02:37 <clusterxl> i need a  backtracking solution to resolve nonograms puzzle in haskell 
12:02:43 <xplat> anyone know how to add your own cookies with wreq?
12:03:08 <clusterxl> any suggestion?
12:03:23 <ice799> bergmark: ah cool thanks ill try that
12:03:53 * hackagebot proton-haskell 0.3 - Simple XML templating library  http://hackage.haskell.org/package/proton-haskell-0.3 (jrbriggs)
12:03:55 * hackagebot diversity 0.6.0.2 - Return the diversity at each position for all sequences in a fasta file  http://hackage.haskell.org/package/diversity-0.6.0.2 (GregorySchwartz)
12:03:56 <ice799> bergmark: do you know if theres documentation anywhere on how to build the debian packages?
12:04:08 <SkinyMonkey> Hi everyone :)
12:05:01 <bergmark> ice799: i don't
12:07:01 <mjrosenb> jesus, haskell's garbage collector looks complex.
12:07:18 <hodapp> probably is.
12:07:19 <xplat> most real ones do
12:07:38 <dolio> Erlang's is simple, isn't it?
12:07:56 <Herogx> You guys see that .net garbage collector?
12:08:00 <hodapp> I am slowly trying to get better with applicatives & lists...
12:08:05 <Herogx> think it was one 28k line file or something
12:08:06 <mjrosenb> it may actually be more complex than spider monkey's.
12:08:34 <dolio> (Erlang is almost designed to have a simple garbage collector, of course.)
12:09:32 <SkinyMonkey> I got a noob question about an exception : it's only displayed in the debugger and I can't find what cause it, there's no info, any idea?
12:10:06 <hodapp> > ((++) . show) <$> [0..3] <*> ["foo", "bar", "baz"]
12:10:08 <lambdabot>  ["0foo","0bar","0baz","1foo","1bar","1baz","2foo","2bar","2baz","3foo","3bar...
12:10:50 <mjrosenb> so, I want a toggleable weak pointer, I guess I should do this with a weak value, and a reference to Maybe k?
12:11:32 <xplat> > mconcat <$> show <$> [0..2] <*> ["foo","bar","baz"]
12:11:33 <lambdabot>      Couldn't match type âCharâ with â[Char] -> bâ
12:11:33 <lambdabot>      Expected type: Integer -> [[Char] -> b]
12:11:33 <lambdabot>        Actual type: Integer -> String
12:11:59 <xplat> > (mconcat <$> show) <$> [0..2] <*> ["foo","bar","baz"]
12:12:00 <lambdabot>      Couldn't match type âCharâ with â[Char] -> bâ
12:12:00 <lambdabot>      Expected type: Integer -> [[Char] -> b]
12:12:00 <lambdabot>        Actual type: Integer -> String
12:12:15 <ElMoloko> Is it worth coding a C wrapper for a C++ method or just importing it with the mangled C++ name?
12:12:19 <xplat> duh
12:12:21 <ion> Do you mean mappend?
12:12:30 <ElMoloko> I can't see what the advantages are to the wrapper
12:12:34 <xplat> > mappend <$> show <$> [0..2] <*> ["foo","bar","baz"]
12:12:36 <lambdabot>  ["0foo","0bar","0baz","1foo","1bar","1baz","2foo","2bar","2baz"]
12:12:36 <ElMoloko> (for FFI)
12:12:56 <xplat> ElMoloko: the mangled C++ name is platform-dependent
12:13:07 <ronh-> I have a record with many fields, all of which are Maybes of some type. is there a smart way I could take advantage of "reads" function so that if the string misses some fields they default to Nothing? or do I have to parse everything manually?
12:13:44 <ElMoloko> Oh.  So I'd have to hardcode it for each platform? (or g++ version?)
12:14:12 <xplat> ElMoloko: yeah.  every compiler, some targets, some compiler versions
12:14:48 <joneshf-laptop> i've got a module i can load in ghci, but i've no clue where it comes from. Is there anyway I can find information on it?
12:14:51 <ElMoloko> I know nothing about C++.  That sounds like a good enough reason for a wrapper.  I know C decently - any good resources for creating a good wrapper?
12:15:26 <hodapp> particularly for wrapping C++ in C?
12:15:31 <ElMoloko> Yeah
12:15:50 <ElMoloko> xplat: thanks though you might have just save me a ton of time down the road
12:16:31 <hodapp> ElMoloko: I don't know if I've any guides on hand, but I've done it myself
12:17:40 <ElMoloko> I've found my answer, thanks :)
12:17:52 <mizu_no_oto> ronh-: There's currently an instance for Read a => Read (Maybe a), but it expects "Nothing" or "Just actualData"
12:18:12 <hodapp> ElMoloko: what's your resource?
12:18:54 <ElMoloko> https://isocpp.org/wiki/faq/mixing-c-and-cpp#overview-mixing-langs
12:20:38 <joneshf-laptop> > listToMaybe $ fst <$> reads "wat" :: Maybe Int -- ronh- 
12:20:40 <lambdabot>  Nothing
12:20:44 <joneshf-laptop> > listToMaybe $ fst <$> reads "123" :: Maybe Int -- ronh- 
12:20:45 <lambdabot>  Just 123
12:21:27 <mjrosenb> Is... there an IO event that happens when a GC occurs?
12:21:56 <Iceland_jack> Text.Read.readMaybe
12:22:31 <hodapp> mjrosenb: err, why do you need one?
12:23:17 <joneshf-laptop> even easier
12:23:25 <mjrosenb> hodapp: because I have a reference that should be collected under a surprisingly complex set of conditions :-/
12:23:33 <joneshf-laptop> @src readMaybe
12:23:33 <lambdabot> Source not found. You untyped fool!
12:23:36 <joneshf-laptop> bleh
12:24:44 <xplat> mjrosenb: your best bet is probably to see if you can abuse weak references for what you want
12:26:11 <mjrosenb> xplat: right... I wanted to do this on top of weak references.
12:28:10 <xplat> mjrosenb: as an expert in these matters (not gc or weakrefs, the other matters) i can tell you that if weakrefs don't work for you you've probably picked an excessively hairy yak to shave
12:29:11 <mjrosenb> xplat: no arguments there!
12:33:53 <mjrosenb> xplat: so, there are 3 levels of what I want to do, I'm currently implementing L1, with an IORef, then there may be an L@, using a WeakRef, and I
12:34:31 <mjrosenb> 'm now thinking forward to L3, and I don't know what I'm going to use.
12:34:40 <mjrosenb> s/L0/L2/
12:35:13 <xplat> you didn't say L0 in the first place, you said L@
12:35:30 <mjrosenb> oh, that is a more sane typo.
12:36:28 <mjrosenb> L1 is I have an a -> IO b, where any given value of a will produce an isomorphic b, in this case, creating a Texture from a width and height.
12:36:47 <ocramz> hi all
12:37:15 <vadim__> ocramz, hi
12:37:25 <mjrosenb> so I'm just storing the previous value used, and whenever I need a Texture, if it isn't the same size as the previous teture, I discard the old one, and make a new one.
12:38:29 <xplat> so this is an immutable Texture and you're caching the 'empty' ones to save allocation?
12:38:52 <mjrosenb> but, if the widget isn't visible, then there is no point in keeping a texture around for it, so that should be a Weak, so it can get gc'ed when not in use.
12:39:23 <mjrosenb> but the way visibility is toggled, I suspect this check would best be done right as a GC starts...
12:40:23 <xplat> does GHC GC even stop the world?  i thought it didn't
12:41:51 <mjrosenb> oh, then that may be less useful.
12:42:14 <mjrosenb> Actually, I'm not even sure checking the visibility of this can be put into IO
12:43:17 <xplat> mjrosenb: so how does visibility work here.  inherited?
12:44:42 <sinelaw> hey, what's another way of writing the denotation function [[ ]] ?
12:44:55 <sinelaw> something that can be valid haskell...
12:45:55 <kclancy> I have a list of n size-n lists. I want to convert this into an array or matrix. I was originally considering doing this by creating an array with integer pairs for indices, but I'm having trouble coming up with an elegant way to construct it without using a bunch of awkward zipping and folding.
12:45:56 <xplat> sinelaw: probably someone has an NbE (normalization by evaluation) implementation in Haskell that you can copy the name off
12:46:10 <kclancy> Maybe instead of using an array with pairs for indices, I should just create an array of arrays.
12:47:21 <xplat> sinelaw: (if you don't know about it, NbE is basically a way of synthesizing a big-step op-sem from a denotational semantics)
12:47:30 <sinelaw> xplat, cool
12:47:45 <sinelaw> I heard about that, but didn't know what name to look up
12:51:03 <xplat> kclancy: go with your original plan, but use listArray
12:51:27 <xplat> kclancy: listArray (0,0) (n,n) (concat lol)
12:51:42 <mjrosenb> xplat: kiiind of.
12:51:45 <kclancy> xplat: oh. that's convenient. thanks.
12:51:55 <mjrosenb> xplat: I'm using Reactive.Banana
12:52:45 <mjrosenb> xplat: and currently, setting visible to false causes the vsync signal to not be delivered to the widget
12:53:16 <mjrosenb> which is annoying, since literally the only time this IORef is referenced is in the vsync handler.
12:53:35 <sinelaw> xplat, from what I understand, NbE is about interpreting terms using the denotation in the meta-language and then encoding that meaning back into terms?
12:54:20 <xplat> sinelaw: yeah.  so technically there's a second ingredient: a big-step operational semantics for your meta-language
12:54:57 <sinelaw> I see
12:55:10 <sinelaw> thanks for the pointer.
12:55:20 <sinelaw> I couldn't find a name for [[ ]] aside for "meaning"
12:55:29 <sinelaw> *still can't find
12:56:24 <xplat> i thought someone called it 'denote' also, though 'meaning' or 'meaningOf' seem more ... meaningful? ... to me
12:57:20 <sinelaw> denote sounds the opposite
12:57:35 <sinelaw> denote x = the meaning of x? doesn't make sense :)
12:57:45 <sinelaw> meaning is fine, just a bit long
12:58:00 <mjrosenb> oh, I can't write into a Weak..
12:58:22 <sinelaw> I'll stick with [[ ]] for now
12:58:29 <sinelaw> it's not valid code anyway
12:58:33 <mjrosenb> so I guess I want a IORef (Weak a)
13:00:27 <vadim__> Can someone tell me.. Haskell is just for fan or is something else.
13:01:06 <simpson> vadim__: I've never heard of Haskell running on fans, but I'm sure that it's possible.
13:01:52 <Haskellfant> now I want a fan that runs some sort of linux to be able to run haskell on it
13:03:12 <vadim__> simon, "fun" sorry.
13:03:19 <sinelaw> vadim__, it's not just for fun.
13:04:06 <sinelaw> vadim__, haskell is a solid language used in industry applications, and by home hackers doing fun projects too
13:04:44 <sinelaw> vadim__, is there anything more specific you want to know?
13:05:07 <sinelaw> *industrial
13:05:36 <mjrosenb> also, yesterday (or mayve two days ago) someone had a link for why you should never use unsafePerformIO, especially when you know it is safe
13:05:50 <mjrosenb> anyone happen to have that link again?
13:06:33 <vadim__> sinelaw, no for a while. thanks. I just was amazed how many people are on this channel.
13:08:25 <sinelaw> vadim__, yeah, there are many. if you have other questions, feel free to ask
13:12:14 <vadim__> sinelaw, Thanks for advance.. but first of all I should install ghc and read some manuals.
13:13:55 * hackagebot hs-inspector 0.5.1.0 - Haskell source code analyzer  http://hackage.haskell.org/package/hs-inspector-0.5.1.0 (flbulgarelli)
13:16:12 <ronh-> :t uncurry
13:16:13 <lambdabot> (a -> b -> c) -> (a, b) -> c
13:16:23 <ronh-> @hoogle (a -> b -> c -> d) -> (a,b,c) -> d
13:16:24 <lambdabot> No results found
13:18:59 <indiagreen> ronh-: there's uncurry3 in e.g. utility-ht, but maybe you should just write your own
13:19:46 <ronh-> I'll check it out, perhaps it has other things I need too
13:20:28 <andrea__> hi there! this is my timeout function http://lpaste.net/132166
13:20:40 <andrea__> it compiles, but does not work properly
13:20:50 <andrea__> it seems actual computation is not run
13:20:57 <andrea__> just the timeout thread...
13:21:04 <andrea__> any suggestion? thanks!
13:22:55 <geekosaur> laziness? it could perfectly happily stick an unevaluated thunk in the MVar
13:23:48 <andrea__> well, i thought that takeMvar would force it to evaluate
13:23:51 <int-e> I believe I figured out how to generate the @index database, so it should reflect the current state of https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ (as of today, there is no automatic update in place)
13:23:55 <int-e> @index Applicative
13:23:56 <lambdabot> Control.Applicative, Prelude
13:27:24 <andrea__> i thought at least it should fork the second thread to listen to the IO
13:27:33 <andrea__> as with a getString
13:27:40 <indiagreen> int-e: I actually asked because I thought â@indexâ was a nice thing and I wanted to post it on haskelltil but then didn't want to recommend something that couldn't find Applicative
13:30:09 <ion> int-e: I failed to find information about the lambdabot QuickCheck security hole that was fixed when someone mentioned it here. The relevant-looking commit didnât explain it and i didnât find a bug report. Is it documented somewhere?
13:32:22 <quchen> andrea__: takeMVar doesn't force the MVar's contents, it simply gives you its contents.
13:32:25 <int-e> @type ioProperty
13:32:26 <lambdabot> QuickCheck-2.8:Test.QuickCheck.Property.Testable prop => IO prop -> QuickCheck-2.8:Test.QuickCheck.Property.Property
13:33:16 <ion> int-e: Ah. Apparently more was needed than just not importing that?
13:33:50 <int-e> ion: Right, I didn't give full details; maybe I should follow up on that on the mailing list. But basically ioProperty is the hole. You can hide the invocation away in a Testable instance.
13:34:04 <Herogx> Are there any inbuilt functions that get the indexes of an element in a list?
13:34:14 <quchen> :t elemIndex
13:34:15 <lambdabot> Eq a => a -> [a] -> Maybe Int
13:34:16 <andrea__> quchen: please, elaborate more on this, I understand you, but somewhat miss the point with my function
13:34:52 <int-e> ion: Well, I found several combinators that allow baking IO actions into a Property, and since Test.QuickCheck is a Safe module, there is no sane way to ensure that it doesn't get imported (directly or indirectly).
13:35:08 <ion> int-e: Okay. Thanks for the explanation.
13:35:44 <quchen> andrea__: Imagine your `action` is something that reads the contents of a file. This gives you access to the contents immediately (via `v`), so now you have a `v` to put into the MVar. But nobody guarantees that the entire file has been read before th `v` is put in the MVar.
13:35:46 <int-e> ion: So at that point I grew queasy and decided to plug the hole by implementing @check in a way that the type system prevents using arbitrary IO actions.
13:36:01 <quchen> So second fork terminates immediately, although it's not completed yet.
13:36:04 <ion> int-e: Fair enough.
13:36:09 <erisco> is the typical way to use System.Random to wrap it up in StateT?
13:36:21 * mjrosenb is feeling like he has too much nesting of let and do :-/
13:36:39 <andrea__> quchen: ok, i got it. but what if it's just a getLn
13:36:52 <ion> erisco: Thereâs @hackage MonadRandom that does that for you and provides a nice interface, btw.
13:36:52 <dolio> erisco: I would typically recommend not using System.Random.
13:37:08 <int-e> indiagreen: it was a good question :)
13:37:14 <quchen> andrea__: I'm not sure how getLine is buffered, but I imagine similar issues can arise.
13:37:30 <quchen> andrea__: FWIW if you're looking for a timeout function there's System.Timeout.
13:37:38 <erisco> dolio for what reason?
13:37:44 <dolio> It's very slow.
13:38:02 <quchen> It's also not a very good RNG.
13:38:25 <andrea__> quchen: yep i know about it. Just making practice as a novice with haskell.... :)
13:38:41 <quchen> andrea__: Lazy IO is awful most of the time :-\
13:38:48 <int-e> indiagreen: the file was frozen in a state from 2005 or 2006.
13:39:08 <andrea__> quchen: would you please reccomend any change? in my code? if i do not bother you.... 
13:39:10 <dolio> The awfulness of lazy I/O is overstated most of the time.
13:39:20 <ion> Wasnât there a GSOC 2015 project to make System.Random better?
13:39:42 <kadoban> I have a feeling this exists, but I dunno what it's called: I want a list, but I want a "current item" and I want to be able to move both forward and back, not just forward?
13:39:47 <quchen> ion: I remember proposals to replace it with something existing, even
13:40:17 <the-kenny> kadoban: double linked list?
13:40:32 <indiagreen> kadoban: zipper?
13:40:33 <earthy> kadoban: you want a zipper over lists
13:40:35 <kadoban> the-kenny: Well, yeah, but â¦ is there one in Haskell in base or something?
13:40:35 <quchen> kadoban: Zipper.
13:40:40 <quchen> Not doubly linked list.
13:40:44 <quchen> They're awful in Haskell.
13:40:49 <kadoban> Oh, hmm I dunno what that is, let me look it up
13:41:00 <the-kenny> yeah, zipper was my other thought. :)
13:41:02 <monochrom> consider a zipper over a doubly-linked list
13:41:37 <earthy> that, or a finger-tree
13:41:52 <quchen> andrea__: You can use `evaluate` to force evaluation of a thunk (to WHNF, at least). Combined with `force` from deepseq you can probably make the function work for most practical purposes.
13:42:41 <ion> The GSOC System.Random project: https://gist.github.com/nkartashov/e46fd146b1df2d79aaf3
13:42:42 <andrea__> quchen: thanks, really! i'll study more!
13:42:43 <kadoban> Is there a simple one in base or something somewhere? It sounds exactly like what I want, but the ones I see seem specialized to weird stuff I don't want
13:42:46 <kadoban> (Zipper)
13:43:47 <lpaste> quchen annotated âmy timeoutâ with âmy timeout (annotation)â at http://lpaste.net/132166#a132174
13:44:00 <quchen> andrea__: Something like that would be a first approximation (!!!) 
13:44:39 <quchen> Wait, that's borked. New link: http://lpaste.net/132176
13:45:15 <quchen> This still has some problems though. For example, if your action times out, the second forkIO thread is never killed, possibly idling forever.
13:45:49 <quchen> And then there are asynchronous exceptions as well, which is something a timeout function should be able to handle well.
13:46:05 <earthy> KaiyonAlatar: https://wiki.haskell.org/Zipper
13:46:26 <quchen> andrea__: A good timeout function isn't all that trivial to write if you ask me.
13:47:13 <ion> andrea: I guess you already know about System.Timeout.timeout?
13:47:28 <quchen> Already mentioned before
13:47:37 <dgpratt> I've made the questionable decision to start messing around with NixOS + Haskell
13:47:46 <andrea__> well, I just learnt about it
13:47:48 <dgpratt> and I didn't get very far before running into an issue
13:48:22 <dgpratt> following along with this http://wiki.ocharles.org.uk/Nix
13:48:35 <andrea__> I could wrap something around it, to add a default value: that would probably b the best solution
13:49:00 <dgpratt> when I run "nix-env -f ~/nixpkgs -i -A haskellngPackages.cabal2nix -A haskellngPackages.cabal-install", GHC gives me an out of memory error: ghc: out of memory (requested 2097152 bytes)
13:49:05 <andrea__> But I am learning a lot: lpaste, IRC, HAskell....I'm pretty basic on everything! SO thanks!!
13:49:20 <dgpratt> that doesn't seem like an excessive request these days
13:49:40 <erisco> ion I don't understand the interface oO
13:49:46 <erisco> how do I even generate a number between a random
13:49:49 <jimstutt> dgprat: r u in the wrong window?
13:49:52 <erisco> in a range *
13:50:13 <dgpratt> jimstutt, it's directly haskell related
13:50:16 <dolio> dgpratt: Do you have ulimits set?
13:50:35 <dgpratt> dolio, unlikely...I will google ulimits
13:50:41 <ion> Î»> evalRandIO (getRandomR (0,42))  -- erisco
13:50:43 <ion> 8
13:50:54 <jimstutt> dgpratt: I'm interested :)
13:51:50 <erisco> ion oh all the useful stuff was hiding in the .Class module... okay
13:52:04 <erisco> why was this not exported into the root module
13:53:09 <indiagreen> dgpratt: isn't it only additional memory?
13:53:21 <indiagreen> like, GHC asked for *another* memory block and didn't get it
13:53:29 <S11001001> erisco: that's by no means standard practice
13:53:31 <dgpratt> indiagreen, probably
13:53:44 <jimstutt> dgpratt: I dunno why this intermittently happens to me: too many builds from source on 8GB RAM?
13:54:39 <erisco> S11001001 but it does
13:54:49 <S11001001> erisco: there are even cases where it's impossible, e.g. https://bazaar.launchpad.net/~scompall/+junk/how-to-define-data-types--mainline/revision/29/src/HTDDT/Bonus/AllTheMTL.hs
13:55:03 <erisco> but I thought Hackage would include all the documentation from an exported module
13:55:30 <ion> Control.Monad.Random reÃ«xports Control.Monad.Random.Class, haddock just doesnât inline the documentation. Perhaps there is a way to make it do so.
13:56:02 <S11001001> erisco: oh, you mean the docs, n/m
13:56:04 <hodapp> did you just spell reexport with an umlaut?
13:56:29 <hodapp> I don't think I've seen something like that since some folks spell coordinate with an umlaut on the 2nd 'o'.
13:57:14 <dgpratt> dolio, were you suggesting setting limits via ulimit was a potential solution, or the potential source of the problem?
13:57:17 <ion> hodapp: I did, humorously.
13:57:34 <hodapp> ion: it seems like a legitimate usage.
13:57:56 <dolio> dgpratt: Source. The resident set size might be limited to 2GB or something.
13:58:13 <dgpratt> ulimit -v reports unlimited
13:58:24 <dolio> Oh wait, that was 2 MB.
13:58:27 <dolio> That'd be crazy.
13:59:00 <dgpratt> ulimit -s reports 8192
13:59:18 <dgpratt> are these reasonable values?
13:59:45 <dolio> I don't think -s would make a difference for GHC compiled programs.
13:59:59 <dgpratt> this VM has (at present) 1 GB of RAM allocated, perhaps that is not enough?
14:00:21 <dolio> That could be.
14:00:28 <dgpratt> sheesh
14:00:39 <dgpratt> I'll try bumping it, thanks dolio
14:00:52 <dolio> GHC got pretty memory hungry in the last couple versions.
14:01:32 <dolio> Moreso than it already was.
14:02:20 <dolio> It takes like 3 or 4 GB to compile vector on my machine.
14:02:26 <dolio> Er, the tests.
14:09:46 <worldsayshi> Is it possible to point out a cabal-sandbox for ghc to use when building? Something like: `ghc --package-conf=.cabal-sandbox/x86_64-osx-ghc-7.8.3-packages.conf.d --make`
14:10:02 <worldsayshi> That option does not work
14:10:22 <kclancy> lazy evaluation in haskell makes debugging a bit weird. stepping through a program, my variables are all shown as _, which I believe means that they are bound to expressions which haven't been evaluated yet.
14:10:38 <c_wraith> worldsayshi: have you tried it via cabal exec?  like..  "cabal exec ghc ..."
14:10:45 <kclancy> is there a way to force expressions to evaluate?
14:10:55 <c_wraith> worldsayshi: from inside the sandbox you're trying to use, I guess.
14:11:03 <dmwit> ion: There is a way to make it do so, but it's a bit annoying: you must re-export each of the things you want documented instead of re-exporting the module.
14:11:15 <worldsayshi> c_wraith: Huh, no havenât tried that :)
14:11:20 <ion> dmwit: ok
14:11:39 <tommd> dmwit: Stuck in the office?
14:11:52 <dmwit> decided to WFH this afternoon
14:15:06 <osa1> does anyone know a package that exports attoparsec parsers for doubles and ints?
14:15:07 <worldsayshi> c_wraith: Hmm, seems my cabal is outdated, doesnât have exec. However, -package-db seems to be the right command for ghc. Getting other errors now.
14:15:29 <dgpratt> this isn't building ghc from source...is it?
14:15:46 <dgpratt> though that would explain the high memory requirements
14:16:26 <dgpratt> I...think it is -- huh, that was not what I expected
14:16:44 <uwap> is there a way to do something like "\uxxxx" in haskell?
14:17:21 <ion> "\x2665"
14:17:38 <uwap> oh. thanks
14:17:44 <dmwit> "\2665" if not using hex
14:18:18 <indiagreen> osa1: attoparsec itself exports a double parser
14:18:32 <indiagreen> called âdoubleâ
14:18:35 <dmwit> osa1: http://hackage.haskell.org/package/double-conversion may be relevant
14:18:47 <indiagreen> there are also âdecimalâ, âhexadecimalâ, and âsignedâ
14:19:02 <indiagreen> look in Data.Attoparsec.Text
14:19:05 <indiagreen> http://hackage.haskell.org/package/attoparsec-0.12.1.6/docs/Data-Attoparsec-Text.html
14:20:44 <osa1> thanks
14:30:51 <lpaste> worldsayshi pasted âTrying to install haste-perch from sourceâ at http://lpaste.net/132184
14:31:25 <mjrosenb> What is the syntax for using ; with in a do block that has a let in it?
14:31:38 * mjrosenb is getting parse errors and cannot seem to find the culprit
14:31:47 <mjrosenb> and ghc is being supremely unuseful.
14:31:48 <ion> do { let { foo = bar; â¦ }; â¦ }
14:31:49 <worldsayshi> Not sure what cabal is trying to tell me above. I donât understand why it is a conflict
14:32:14 <Cale> worldsayshi: haste-compiler>=5 sounds kind of crazy
14:32:21 <dmwit> worldsayshi: It is saying: you asked for a specific version of haste-perch. That version demands haste-compiler version 5 or higher. You have haste-compiler version 0.5, which is not higher than 5.
14:32:25 <Cale> worldsayshi: Given that you have 0.5
14:32:42 <dmwit> worldsayshi: Possibly there is a typo in haste-perch's cabal file.
14:32:45 <worldsayshi> Oh, ah. Itâs a typo
14:32:47 <worldsayshi> Yes
14:32:58 <worldsayshi> Of course.
14:33:07 <mjrosenb> ion: oh, I need the inner curly braces?
14:33:29 <worldsayshi> Iâll fix pull req
14:33:39 <Cale> mjrosenb: You need the braces for the let, because its entries are also semicolon delimited
14:33:42 <geekosaur> mjrosenb, if you use the outer set you have turned off layout, the inner set is then mandatory so it knows when the let bindings end
14:33:56 <Cale> mjrosenb: So it's tough to work out where it ought to end otherwise
14:33:58 <dmwit> worldsayshi: By the way, when installing multiple related things, it's generally considered good practice to tell cabal install about all of them at once rather than installing one at a time.
14:34:11 <dmwit> worldsayshi: This gives the constraint solver a better clue about what it's supposed to be doing.
14:34:33 <dmwit> worldsayshi: e.g. cabal install ./haste-perch ./haste-compiler is probably better than running cabal install twice in the two directories.
14:35:02 <worldsayshi> dmwit: Ah, nice. Thanks for the tip
14:35:20 <worldsayshi> Didnât know that syntax worked
14:35:39 <dmwit> Yeah, that caught me by surprise the first time it was suggested to me, too.
14:36:05 <dmwit> cabal actually knows quite a few ways to find a package, not just by looking on Hackage or the current directory.
14:36:31 <dmwit> You can point it at a URL with a tarball, too.
14:37:54 <worldsayshi> dmwit: Nice, so many features, so little patience with documentation.
14:39:09 <dmwit> kadoban: I don't know of anything in base. Often it's not necessary; ([a], a, [a]) is a pretty easy type to work with.
14:39:10 <worldsayshi> dmwit: What would be the ideal way to find out about such features really. Seldom would you actually expect such feature and go looking for it
14:39:36 <dmwit> Good documentation would be the ideal way. In practice, I seem to learn about features by osmosis.
14:39:58 <dmwit> (in the specific case of cabal-install)
14:40:28 <worldsayshi> It would be nice if there would be some smart completion mechanics for such features
14:41:22 <dmwit> The wiki has some completion widgets for zsh, though I've found they're a bit incomplete.
14:41:26 <worldsayshi> Like âwhat syntactactically correct commands can I make that somewhat match the keywords Iâm currently typing.
14:41:30 <Cale> kadoban: You can do something like...
14:41:38 <Cale> @let separate [] = [[]]; separate (x:xs) = ([],x,xs) : [(x:us,v,vs) | (us,v,vs) <- separate xs]
14:41:39 <lambdabot>  .L.hs:153:5:
14:41:39 <lambdabot>      Couldn't match expected type â[t]â
14:41:39 <lambdabot>                  with actual type â([t0], a, [a])â
14:41:41 <dmwit> And of course there's always --help
14:41:41 <Cale> oops
14:41:50 <Cale> @let separate [] = []; separate (x:xs) = ([],x,xs) : [(x:us,v,vs) | (us,v,vs) <- separate xs]
14:41:51 <lambdabot>  Defined.
14:41:53 <Cale> yeah
14:41:57 <worldsayshi> yeah
14:41:58 <Cale> > separate [1..5]
14:41:59 <lambdabot>  [([],1,[2,3,4,5]),([1],2,[3,4,5]),([1,2],3,[4,5]),([1,2,3],4,[5]),([1,2,3,4]...
14:42:07 <dmwit> > separate [1..3]
14:42:08 <lambdabot>  [([],1,[2,3]),([1],2,[3]),([1,2],3,[])]
14:43:12 <Cale> This is just one particular option. In other cases, you may want to have the first list in reverse order, which is something easier to do step-by-step
14:43:16 <dmwit> See also http://www.reddit.com/r/haskell/comments/33qjyw/unique_sampling_drawing_searches_with_list_and/cqntnix
14:44:28 <dmwit> If you keep the first list in forward order like this, it is not easy (efficient) to step backward in the list.
14:44:33 <Cale> right
14:44:45 <dmwit> Keeping it in reverse order is better for that, and has better sharing when constructing the initial separation as well.
14:45:07 <indiagreen> > let s = [1..4] in zip3 (inits s) s (tail (tails s))
14:45:09 <lambdabot>  [([],1,[2,3,4]),([1],2,[3,4]),([1,2],3,[4]),([1,2,3],4,[])]
14:45:13 <Cale> uh, I'm not sure about the second part there :)
14:45:41 <lokathor> when i do cabal init
14:45:42 <dmwit> Cale: Yes; your source has O(n) calls to (:) on the RHS of separate. My source has 2 calls to (:) on its RHS.
14:45:50 <lokathor> "include documentation on what each field means?" is an option
14:45:58 <lokathor> does that make cabal generate haddock as part of the build?
14:46:04 <arkeet> no, it just puts comments in your .cabal file
14:46:11 <lokathor> oh
14:46:14 <lokathor> well that's less useful
14:46:38 <arkeet> if you want documentation you tell cabal that when running cabal install
14:46:41 <arkeet> or just run cabal haddock
14:46:48 <kadoban> Cale: Thanks much. I kinda cobbled something together and it seems to work well, that's a nice technique to know.
14:46:53 <dmwit> Cale: Another way to say it: there is nothing that can be shared (other than values) between [1] and [1,2]; whereas [1] and [2,1] can share the tail [1].
14:46:53 <Cale> dmwit: Oh, I see what you mean -- sharing the initial segments with each other
14:46:57 <dmwit> yes
14:47:04 <Cale> Yeah
14:47:17 <lokathor> arkeet, is there a way to setup cabal to automatically regenerate haddock into a /doc directory automatically after every "cabal build"?
14:47:27 <arkeet> no, that is not what cabal build does.
14:47:40 <Cale> kadoban: Another nice one to know about is:
14:47:47 <arkeet> you could just run cabal haddock after.
14:47:49 <dmwit> lokathor: Can't you just call "cabal haddock"?
14:48:02 <Cale> @let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
14:48:04 <lambdabot>  Defined.
14:48:10 <Cale> > select [1..5]
14:48:12 <lambdabot>  [(1,[2,3,4,5]),(2,[1,3,4,5]),(3,[1,2,4,5]),(4,[1,2,3,5]),(5,[1,2,3,4])]
14:48:13 <arkeet> @where select
14:48:13 <lambdabot> select [] = []; select (x:xs) = (x,xs) : (map.fmap) (x:) (select xs)
14:48:21 <lokathor> i could, but i'd like it to automatically rebuild the doc if a successful build happens, if possible
14:48:27 <lokathor> if there's no option for that it's fine
14:48:33 <dmwit> lokathor: cabal build && cabal haddock
14:48:39 <lokathor> suppose so
14:49:12 <kadoban> Oh huh, that's really cute.
14:49:24 <lokathor> i tried that yesod thing one time, and the stuff where it autorebuilds your project as it detect changes and all
14:49:25 <lokathor> that's nice
14:49:41 <dmwit> inotifyrun 'cabal build && cabal haddock'
14:49:42 <athan> Can anyone reccomend a good regular expression library? regex-posix / regex-compat doesn't give good errors when it doesn't understand a regular expression
14:49:56 <athan> for instance, it can't handle `^[a-zA-Z0-9_-.]+@[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+$` (emails)
14:49:57 <dmwit> athan: regex-applicative
14:50:06 <athan> dmwit: !!! Thank you!
14:50:16 <lokathor> dmwit, inotifyrun doesn't seem to be a command i've got installed :P
14:50:22 <Cale> kadoban: I would really like select at the very least to go into Data.List
14:50:32 <lokathor> sounds pretty linuxy and not very windows
14:50:46 <Cale> but that's unlikely to happen soon
14:50:56 <dmwit> lokathor: Very much a Linux thing. But also you wouldn't have it because I wrote it (sorry, didn't check before suggesting it).
14:51:07 <joof> lol
14:51:07 <dmwit> lokathor: https://github.com/dmwit/official/blob/master/bin/inotifyrun in case you ever decide to switch to the dark side
14:51:22 <lokathor> i've got a linux box for occasional use
14:51:23 <lokathor> but steam
14:51:34 <indiagreen> athan: please don't use this regular expression for emails, it would annoy many people who have â+â in their emails
14:51:41 <dmwit> ...steam runs on Linux these days.
14:51:49 <arkeet> > evalStateT (replicateM 2 (StateT select)) [1..4]
14:51:50 <lambdabot>  [[1,2],[1,3],[1,4],[2,1],[2,3],[2,4],[3,1],[3,2],[3,4],[4,1],[4,2],[4,3]]
14:51:58 <dmj`> :t select
14:51:59 <lokathor> the games within it have pretty poor linux standings, at the moment
14:51:59 <lambdabot> [t] -> [(t, [t])]
14:52:06 <lokathor> i could play CK2 though
14:52:20 <joof> lokathor: I have 194 linux games on steam (it's a problem), but GTA5 is not one of them
14:52:25 <athan> indiagreen: Just a toy example :P
14:52:40 * geekosaur spits at least 4 errors in that regex
14:52:41 <lokathor> dmwit, i have no idea at all what this shell script is doing.
14:53:00 <lokathor> does it just never stop looping the command given?
14:53:08 <dmwit> lokathor: Watch for any changes to a file somewhere in the current directory. When you see one, run a command.
14:53:09 <geekosaur> aside from the fact that it erejects legitimate addresses
14:53:34 <dmwit> lokathor: It never stops looping the command given (but it does wait for something to change in between iterations of the loop).
14:53:39 <athan> geekosaur: Help meeee! I aparently have an invalid range end ._.
14:53:43 <geekosaur> yes
14:53:46 <lokathor> that does seem really handy
14:53:55 <athan> (but I don't know where)
14:53:56 <geekosaur> move the -s that are intended to be literal to the very front of each range
14:54:13 <geekosaur> and escape the . in the domain part that is intended to be literal
14:54:23 <lokathor> now to learn how to do RNG stuff using the state monad!
14:54:59 <geekosaur> ^[-a-zA-Z0-9_.]+@[-a-zA-Z0-9]+\.[-a-zA-Z0-9.]+$
14:55:01 <athan> geekosaur: ooop, thank you
14:55:13 <athan> Woo! Thanks again :)
14:55:36 <arkeet> > evalState (replicateM 7 (state $ minimum . select)) "haskell"
14:55:38 <lambdabot>  "aehklls"
14:55:48 <arkeet> I'd get rid of the 7 but meh.
14:55:48 <geekosaur> it's still wrong for matching legal email addresses but it shouldn't error out
14:56:03 <benzrf> :t select
14:56:03 <lambdabot> [t] -> [(t, [t])]
14:56:07 <benzrf> hmm
14:56:08 <arkeet> > select "abcd"
14:56:09 <lambdabot>  [('a',"bcd"),('b',"acd"),('c',"abd"),('d',"abc")]
14:56:12 <benzrf> aha
14:56:16 <geekosaur> and use one of the web sites for validating and explaining regexes instead of expecting the regex library to help you, because it won't
14:56:18 <benzrf> now that is nice
14:56:22 <benzrf> that is verrrry nice
14:56:26 <benzrf> where's it defined?
14:56:35 <athan> geekosaur: I'm just using it as an example for my wai router that can take posix rexeg's as a route
14:56:36 <dmwit> benzrf: in ?let =)
14:56:39 <arkeet> about 10 minutes ago.
14:56:42 <dmwit> benzrf: See also http://www.reddit.com/r/haskell/comments/33qjyw/unique_sampling_drawing_searches_with_list_and/
14:56:45 <benzrf> wew
14:56:48 <athan> so it can match `http://foo.com/yolo@swag.com`
14:57:21 <geekosaur> that won't since you excluded : and /
14:57:39 <geekosaur> @google mastering regular expressions
14:57:41 <lambdabot> http://www.amazon.com/Mastering-Regular-Expressions-Jeffrey-Friedl/dp/0596528124
14:57:41 <lambdabot> Title: Amazon.com: Mastering Regular Expressions (9780596528126): Jeffrey E. F. Frie...
14:57:47 <athan> :o
14:57:48 <dmwit> athan: Presumably the routing function is in charge of ignoring the http://foo.com/ part.
14:57:51 <athan> thank you!!!
14:58:03 <athan> dmwit: wai does that ._.
14:58:08 <dmwit> geekosaur: That was meant to be at you.
14:58:10 <dmwit> athan: Sorry.
14:58:19 <arkeet> @let whileM p f = go where go = do { x <- p; if x then liftM2 (:) f go else return [] }
14:58:20 <lambdabot>  Defined.
14:58:22 <athan> oop
14:58:27 <arkeet> > evalState (whileM (gets (not.null)) (state $ minimum . select)) "haskell"
14:58:29 <lambdabot>  "aehklls"
14:58:48 <dmwit> "how to do selection sort even slower" =P
14:58:50 <arkeet> :p
14:59:19 <arkeet> > evalState (whileM (gets (not.null)) (state $ minimumBy (comparing fst) . select)) "haskell"
14:59:20 <lambdabot>  "aehklls"
14:59:22 <arkeet> a bit better.
15:00:00 <arkeet> > runState (replicateM 3 (state $ minimumBy (comparing fst) . select)) "haskell"
15:00:01 <lambdabot>  ("aeh","skll")
15:00:38 <arkeet> I dunno. what other fun things can we do with select.
15:01:29 <dmwit> I've used a variant of select in tons of PE puzzles.
15:04:44 <arkeet> I haven't really done PE.
15:08:58 * hackagebot proton-haskell 0.4 - Simple XML templating library  http://hackage.haskell.org/package/proton-haskell-0.4 (jrbriggs)
15:19:26 <samba1_> how can I have a parsec parser take only a specific number of characters? Like many anyChar, but with a number. I know I can do (take 20 <$> many anyChar), but what combinator can I use to only take 20 in the first place? Do I need state?
15:19:59 <kirill`> samba1_: I think replicateM
15:20:00 <arkeet> you want exactly 20, or at most 20?
15:20:01 <ski> how about `replicateM 20 anyChar' ?
15:20:17 <arkeet> ^
15:20:21 <arkeet> for exactly 20, anyway.
15:20:43 <arkeet> should be doable with Applicative though.
15:20:52 <ski> dmwit : Partial Evaluation ?
15:21:17 <arkeet> :t let replicateA n = sequence . replicate n in replicateA
15:21:18 <lambdabot> Monad m => Int -> m a -> m [a]
15:21:21 <arkeet> :t let replicateA n = sequenceA . replicate n in replicateA
15:21:22 <lambdabot> Applicative f => Int -> f a -> f [a]
15:26:13 <cane> ciao
15:26:20 <cane> !list
15:26:20 <monochrom> cane: http://hackage.haskell.org/packages/
15:29:54 <monochrom> erisco: https://github.com/takenobu-hs/haskell-ghc-illustrated may inform you how GHC uses your computer.
15:30:02 <dmj`> monochrom++
15:30:26 <monochrom> more precisely, s/GHC/GHC-generated code/
15:32:54 <erisco> monochrom thanks
15:35:21 <samba1_> exactly 20
15:35:35 <samba1_> I'll try replicateM
15:41:35 <mjrosenb> monochrom: is that using comic sans?
15:41:53 <monochrom> I don't know
15:41:57 <ion> All Haskell-related documents are required to use Comic Sans, preferably with yellow text on blue background.
15:42:44 <Rembane> The prime reason why Haskell isn't spread outside of Academia.
15:42:46 <joof> please host all haskell-related documents on our domain geocities
15:42:49 <arkeet> I don't know why Control.Applicative doesn't have replicateA
15:44:35 <samba1_> is there a generic way to go from a record to a hash of field name to value?
15:44:55 <samba1_> like defining a ToJSON instance, but for a hash
15:45:27 <lokathor> this may seem simplistic
15:45:37 <lokathor> but is there any particular tutorial on using the state monad?
15:46:34 <joof> https://en.wikibooks.org/wiki/Haskell/Understanding_monads/State
15:46:45 <joof> maybe?
15:46:58 <lokathor> this is exactly what i wanted state for
15:47:16 <lokathor> I'm trying for a program that estimates odds of various dice rolls
15:47:45 <lokathor> so first i'd like it to roll various dice rolls :P
15:53:59 * hackagebot poly-arity 0.0.4 - Tools for working with functions of undetermined arity  http://hackage.haskell.org/package/poly-arity-0.0.4 (athanclark)
16:02:41 <samba1_> I have a number of datatypes that eventually will need to be turned into HashMaps. In an object oriented langauge I could make an abstract class and subclass it with implementations. I know I should avoid the "existential typeclass anti-pattern", so how can I do this?
16:02:46 <samba1_> ex. data A = A Int String (HashMap String String), data B = B String String, data C = C String . I'll eventually want to turn B and C into an A by taking their data and turning it into a HashMap to use as the last parameter to an A
16:05:39 <benzrf> samba1_: ok... and?
16:05:47 <benzrf> samba1_: i dont follow what you're asking :\
16:07:10 <arkeet> just turn them into hashmaps then...?
16:08:45 <dmwit> ski: Project Euler
16:08:52 <ski> ok
16:09:14 <lokathor> i guess you'd just write0 "bToA :: B -> A"
16:09:17 <athan> Yo dog so I heard you like routes, so I put routes in your routes: https://www.fpcomplete.com/user/AthanClark/nested-routes
16:09:25 <lokathor> and make the hash map be whatever
16:09:36 <samba1_> well, it'd be nice to have something like ToJSON, where I define how to do it and then can use a single function
16:09:41 <samba1_> but this is supposedly an anti-pattern
16:10:07 <samba1_> but for me it's easier, rather than polluting my code everywhere with specific function calls or hash building
16:10:13 <ski> oh, you want a `ToA' type class ?
16:11:21 <benzrf> samba1_: well
16:11:32 <benzrf> samba1_: where are the Bs and Cs coming from, and why are you turning them into As?
16:11:49 <benzrf> samba1_: the reason this problem is confusing to us is that it isnt obvious what situation you'd want this for
16:12:00 <benzrf> samba1_: which suggests that there's some kind of problem with the design higher up
16:12:05 <samba1_> well, think of it just like json
16:12:16 <samba1_> I have a B, I want to turn it into json
16:12:21 <samba1_> I have a B, I want to turn it into a hashmap
16:12:40 <samba1_> where does the B come from? anywhere. why do I want to turn it into json? because I'm sending it to something that uses json
16:13:01 <arkeet> just do it then?
16:13:24 <arkeet> what's the difficulty?
16:13:45 <lokathor> yeah, why did you get a B when you really want an A?
16:14:05 <arkeet> no, I'm not asking that.
16:14:17 <nitrix> Is there a known haskell GNFS (general number field sieve) implementation for factorizing large integers?
16:15:21 <samba1_> the difficulty is having to explicitly put everywhere "bToHash", "cToHash" etc is very specific
16:15:32 <arkeet> then make a typeclass for it?
16:15:43 <samba1_> supposedly that's discouraged
16:15:45 <arkeet> no
16:16:01 <arkeet> there's nothing wrong with the ToJSON class existing.
16:16:27 <arkeet> the thing that's discouraged is using an existential for "any instance of ToJSON"
16:16:32 <samba1_> why do so many people say to avoid typeclasses then?
16:16:41 <arkeet> because you may as well just use a json Value instaed
16:16:45 <arkeet> who says?
16:17:04 <geekosaur> because many newcomers try to use typeclasses for general OOP, and that just leads to pain and suffering
16:17:08 <samba1_> http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
16:17:15 <samba1_> i can see that
16:17:24 <samba1_> but the alternatives are unclear
16:17:40 <benzrf> hmm
16:17:53 <arkeet> that's one post, and you should perhaps read the very first paragraph.
16:18:58 <samba1_> arkeet: I have read it. There are others I've seen on reddit, I can't dig them all up right now
16:19:08 <dmwit> nitrix: To a first approximation, if it isn't on Hackage it doesn't exist.
16:19:10 <samba1_> my question i guess is what is the general alternative to subclassing in oop
16:19:26 <benzrf> samba1_: what does subclassing solve in OOP
16:19:32 <benzrf> half the time it's the wrong thing to use
16:19:52 <tommd> dmwit: Gah, no!  Don't propagate that lie!
16:19:52 <arkeet> OO classes and haskell classes are different things.
16:20:06 <samba1_> arkeet: I know that
16:20:14 <samba1_> I'm trying to think of a simple example
16:20:53 <simpson> samba1_: Imagine that you're working in an object-based language *without* inheritance. How would you solve your inheritance problems?
16:20:55 <monochrom> the alternative is careful design of data types and functions.
16:20:56 <samba1_> something like this feels close, but not it: http://www.gamedev.net/page/resources/_/technical/game-programming/haskell-game-object-design-or-how-functions-can-get-you-apples-r3204
16:21:01 <tommd> dmwit: We've had plenty of proprietary code and so have my last to jobs.  Not to mention people like EK and glguy keep significant code bases on github that aren't really publicly consumable.
16:21:14 <nitrix> simpson: Different types!
16:21:31 <benzrf> samba1_: haskell is not isomorphic to java
16:21:44 <samba1_> all: i understand that things _can_ be done with plain functions. my contention is that this makes code more verbose, less generic, etc.
16:22:02 <monochrom> this does not imply the lack of abstraction. no. if you export enough functions, you can hide the data type details.
16:22:06 <nitrix> glguy writes haskell?
16:22:06 <benzrf> samba1_: by which i mean java's feature X solves problems Y and Z while in haskell you solve Y and Z in different ways
16:22:11 <samba1_> i would like a way to represent that, for example, I have diffent types of emails
16:22:14 <samba1_> but they're all emails
16:22:17 <simpson> nitrix: ?
16:22:19 <tommd> nitrix: Are you joking?
16:22:21 <samba1_> and some have different traits, but they have many in common
16:22:27 <benzrf> samba1_: define an Email type
16:22:30 <benzrf> make it parametric
16:22:39 <dmwit> tommd: I'm happy to change my tune, but find your supporting evidence strange. If it's proprietary or not publically consumable, how is that practically different from "doesn't exist" for the people that don't already know about it?
16:22:48 <benzrf> samba1_: can you give me a concrete example so i can illustrate what i mean?
16:22:51 * glguy wonders how he got dragged into this
16:23:18 <tommd> dmwit: I often here that line and similar used by GHC folks "if it isn't open and on Hackage then we don't need to worry about backwards compatibility"
16:23:28 <samba1_> one email has one body, another has a different body. the first does a sort of mail-merge with a persons name, the second does not
16:23:37 <monochrom> samba1_: this may help http://www.slideshare.net/ScottWlaschin/fp-patterns-buildstufflt .  and maybe this too https://docs.google.com/presentation/d/1a4GvI0dbL8sfAlnTUwVxhq4_j-QiDlz02_t0XZJXnzY/preview?sle=true&slide=id.p
16:23:37 <tommd> glguy: Sorry, my mistake using your full handle.  I was using you as an example person who keeps code on github instead of trashing hackage.
16:24:02 <benzrf> samba1_: err, not sure what you mean
16:24:19 <geekosaur> sounds like an oversimplication of discussion about testing backward compatibility of ghc changes; it's not like the ghc devs can hunt down every chunk of code everywhere
16:24:22 <benzrf> samba1_: different bodies?
16:24:25 <samba1_> benzrf: all emails have a to address, for instance
16:24:29 <benzrf> samba1_: well, yes
16:24:33 <samba1_> but one might be a password reset email'
16:24:44 <samba1_> and another is an order received email
16:24:46 <geekosaur> the real argument there is "if it's not on hackage then ghc devs cannot be expected to hunt it down for testing"
16:24:49 <benzrf> samba1_: alright, so
16:25:18 <samba1_> rather than writing "sendEmail toAddress (fromList [(foo,bar),(quux,baz)])"
16:25:18 <benzrf> data Email = Email {malFrom :: Address, rcptTo :: Address, subject :: Text, mailBody :: Text}
16:25:30 <benzrf> *mailFrom
16:25:45 <samba1_> I would like to be able to have a OrderReceived datatype which packages up the things an ordered received email needs to have
16:26:06 <samba1_> and use a more generic sendEmail function that can take an OrderReceived structure, or a PasswordReset structure, or others
16:26:18 <dmwit> tommd: Okay. I understand why "if it isn't on Hackage, we need not support it" sucks as a trope.
16:26:55 <samba1_> adn those structures define what the body looks like
16:27:03 <benzrf> errr
16:27:12 <samba1_> but they don't all have the same shape. some emails are very simple, some are very complicated and specific
16:27:14 <tommd> dmwit: mostly it seemed to have a negative impact on perception of Haskell at the time.  Folks like Mark Jones were indireclty told they and their projects didn't factor into the future of GHC.  Hurm...
16:27:36 <benzrf> samba1_: so define generateOrderReceived :: Product -> Customer -> Address -> Email
16:27:41 <benzrf> samba1_: then send that email
16:27:55 <samba1_> that's what I'm doing now
16:27:57 <samba1_> but it's ugly
16:28:04 <benzrf> how is it uglier than doing it the other way
16:28:26 <samba1_> what's the other way?
16:28:36 <alexv19> There isn't a sensible Monoid instance for rose trees, is there?
16:28:49 <benzrf> samba1_: defining subclasses that have different sendEmail methods
16:28:52 <arkeet> alexv19: try writing mempty
16:28:53 <benzrf> samba1_: in an OO lang
16:29:14 <dmwit> alexv19: There's a sensible Monoid instance for rose forests (the usual list monoid with [] and (++)).
16:29:27 <samba1_> they would have different toBody functions, maybe, not sendEmail instances
16:29:50 <samba1_> I feel like I can make OrderReceived a function that makes its own body
16:30:08 <benzrf> samba1_: how is building an OrderReceived object and then calling toBody different from calling genOrderReceived with the same things you'd stick in the OrderReceived object
16:30:09 <samba1_> rather than a structure that one calls another function on
16:30:17 <ReinH> dmwit: where mappend is associative?
16:30:34 <dmwit> ReinH: yes?
16:30:40 <dmwit> ReinH: I mean, it is literally the list monoid.
16:31:05 <alexv19> dmwit: rose forest is this? `type Forest a = [Tree a]`
16:31:11 <samba1_> it's different because then the ugliness is at the call site rather than where it's defined
16:31:13 <dmwit> alexv19: yes
16:31:17 <benzrf> what about instance Monoid a => Monoid (Tree a) where mempty = Node mempty []; mappend (Node a as) (Node b bs) = Node (a <> b) (as ++ bs)
16:31:30 <benzrf> samba1_: the call site of what
16:31:31 <samba1_> I want OrderReceived :: a -> b -> c -> Email maybe
16:31:39 <benzrf> 07:26:37      benzrf â samba1_: so define generateOrderReceived :: Product -> Customer -> Address -> Email
16:31:43 <benzrf> i said that a minute ago :\
16:32:02 <samba1_> i don't know how to express what i mean, maybe it's my english
16:32:10 <samba1_> but i have your suggestion in use now
16:32:15 <dmwit> benzrf: It's law-abiding, though I can't say I see whether it's useful or not. =P
16:32:18 <samba1_> and it feels very clunky, very ugly, very verbose
16:32:28 <samba1_> i don't know exactly how to improve it, otherwise i wouldn't be asking
16:32:30 <benzrf> samba1_: i think the problem is that you're used to certain hindrances in other languages that make this way of doing things ugly
16:32:40 <samba1_> but i would not feel this way about how i would do it in another language
16:32:53 <benzrf> samba1_: trust me, that's pretty typical when you're new
16:32:59 <samba1_> i'm not that new
16:33:02 <benzrf> samba1_: how new are you
16:33:23 <samba1_> tough to say, i used to do ocaml so i'm very used to functional programming
16:33:30 <samba1_> i've been doing a bit of haskell for a year maybe
16:33:37 <benzrf> oh :|
16:33:39 <dmwit> instance Monoid a => Monoid (Tree a) where mempty = Node mempty (repeat mempty); mappend (Node a as) (Node b bs) = Node (a <> b) (zipWith (<>) as bs) -- probably more useful
16:33:55 <samba1_> it just gets in my way for simple things
16:34:07 <benzrf> samba1_: so i have some code somewhere that builds an order received email, ok?
16:34:30 <benzrf> samba1_: how is that snippet of code uglier with a build function than with the object version
16:35:01 <samba1_> because in the meantime i have a structure that I can get information in to and out of
16:35:19 <samba1_> i can make the OrderReceived here and finally send it three modules away
16:35:37 <benzrf> samba1_: yeah, you make the email here and finally send it three modules away
16:35:41 <benzrf> oh, i see what you mean
16:35:53 <benzrf> samba1_: you want to be able to pass around an OrderReceived between different bits of code?
16:36:10 <samba1_> yes, orderreceived may have many functions
16:36:17 <benzrf> hmm
16:36:19 <samba1_> turning it into an email is one
16:36:39 <samba1_> I can write a function to turn it into an email, but then I have to use a very specific function
16:36:42 <benzrf> it seems to me that in typical haskell code you'll assemble the order info separately instead of having an incomplete bundle
16:37:04 <samba1_> I can just say "send this thing as an email", I have to make a function called "sendOrderReceivedAsAnEmail"
16:37:12 <benzrf> no you dont
16:37:21 <benzrf> you just turn it into an email at the place where you collect the info
16:37:27 <samba1_> it feels too specific, I shouldn't have to make a function for each thing that might be an email
16:37:32 <benzrf> so instead of carrying around an OrderReceived you carry around an Email
16:37:41 <benzrf> why would you want to carry around an OrderReceived
16:37:43 <arkeet> have a function that turns an OrderReceived into an Email
16:37:49 <arkeet> and then have a function that sends an Email
16:37:49 <benzrf> no, arkeet
16:37:52 <benzrf> here's the problem
16:37:52 <arkeet> ??
16:37:54 <samba1_> arkeet: yes, now imagine I have 2000 of these
16:38:04 <benzrf> arkeet: there are 2 ways of doing this as i see it
16:38:18 <samba1_> order received, order cancelled, password reset, startup closing forever, etc etc etc
16:38:21 <benzrf> arkeet: one is to define a class with the toEmail method specific to the type of email and the fields and whatnot
16:38:36 <benzrf> arkeet: then you have one place where you use type-specific code; when you declare what class to create
16:38:55 <benzrf> arkeet: OR, you define a function that takes the parts of an order and builds an email, with no intermediary
16:38:56 <arkeet> I guess I'm not understanding the problem.
16:39:04 <benzrf> arkeet: then you have one place that's specific; calling that func
16:39:11 <arkeet> the function could be part of a class.
16:39:37 <benzrf> so then
16:39:43 <benzrf> ok let me go back a second
16:39:51 <benzrf> object version looks like this:
16:40:01 <benzrf> class OrderEmail { stuff; toEmail {return bleh + blah}}
16:40:01 <arkeet> or your thing could carry around some data that tells how to turn it into an Email. (which isn't too far from the class thing.)
16:40:17 <samba1_> arkeet: yes, that is what I feel is close to what i "should" do
16:40:21 <benzrf> arkeet: then in the utilizing code somewhere you say OrderEmail once and then you get to be abstract about the conversion
16:40:26 <benzrf> arkeet: alternatively, in the function version
16:40:26 <samba1_> "should" according to haskell reddit etc
16:40:49 <benzrf> orderEmail customer order bleh = Email (text ++ moreCrap)
16:40:50 <samba1_> or some advanced type feature that i don't know about
16:41:03 <benzrf> then in the utilizing code you say orderEmail once and then you get to send the result same as anything else
16:41:05 <benzrf> HOWEVER
16:41:09 <benzrf> if you use, like
16:41:15 <benzrf> data OrderEmail = Bluh
16:41:21 <benzrf> AND renderOrderEmail = foo
16:41:24 <benzrf> then you have to be specific twice
16:41:33 <benzrf> samba1_: why do you need a data type for order emails?
16:42:26 <dmwit> data Order = Bluh; instance RenderEmail Order where toEmail (Order { ... }) = bluh -- ?
16:42:37 <arkeet> ^
16:42:50 <benzrf> unnecessarily classy imo
16:42:55 <benzrf> just dont have data Order
16:42:57 <benzrf> why do you need it?
16:43:10 <samba1_> I need a data type for an order received
16:43:13 <dmwit> Because there's plenty of other stuff you want to do with orders. Put them in databases, check which items need to be shipped out, etc.
16:43:18 <samba1_> these are types for "events" maybe you'd say
16:43:22 <benzrf> yeah, but you dont need that for an order /email/
16:43:27 <benzrf> dont have data OrderEmail
16:43:27 <samba1_> they are of general interest to my system
16:43:35 <samba1_> no, but i need a way to turn that order into an email
16:43:37 <dmwit> You don't want to parse an email just to figure out what objects your employee should pick up when he walks into the warehouse.
16:43:41 <benzrf> oh
16:43:43 <benzrf> hmm
16:43:48 <dmwit> benzrf: I didn't suggest making an OrderEmail. =)
16:43:56 <benzrf> no, but i think samba1_ did
16:44:00 <benzrf> i-i swear
16:44:12 <dmwit> I think he just picked a bad name.
16:44:16 <dmwit> or she
16:44:16 <samba1_> no, i don't want an OrderEmail
16:44:22 <benzrf> kk
16:44:25 <benzrf> so..
16:44:29 <samba1_> i just want to say "this thing knows how to turn itself into an email"
16:44:36 <samba1_> or email body
16:45:02 <samba1_> and then have a function that says "give me an address and a thing that can be turned into a body and I'll send it"
16:45:07 <dmwit> data Email; class RenderEmail a where renderEmail :: a -> Email -- perfectly cromulent use of typeclasses
16:45:12 <benzrf> meh
16:45:14 <benzrf> :D
16:45:16 <samba1_> in oo you'd use an interface or abstract class
16:45:16 <benzrf> kk
16:45:20 <samba1_> i could use a typeclass here
16:45:22 <samba1_> it would work
16:45:26 <arkeet> yes
16:45:27 <samba1_> but then i'm using a typeclass as an interface
16:45:29 <arkeet> so what's the problem
16:45:35 <arkeet> that's what typeclasses are for
16:46:09 <samba1_> arkeet: many people seem to disagree with that. clearly you're not one of them, but my question is then to those people - what do i do instead?
16:46:26 <arkeet> many?
16:46:29 <dmwit> "many people seem to disagree with that" [who?]
16:46:49 <samba1_> i don't know them personally and i can't really search for it now
16:46:55 <arkeet> you pointed at this article http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
16:47:04 <arkeet> but that's it
16:47:22 <dmwit> I would propose that you are thinking of people lambasting the existential anti-pattern and misinterpreting their complaints.
16:48:02 <benzrf> samba1_: in this particular case i guess that's ok
16:48:09 <samba1_> well, i've seen comments taht typeclasses should have laws
16:48:14 <benzrf> samba1_: but i think more broadly this kind of usage is often overkill
16:48:14 <samba1_> i don't know
16:48:25 <arkeet> no, that doesn't make sense.
16:49:06 <samba1_> arkeet: i don't know what to say to you. you don't believe me, but this is a sentiment i have seen from many people, who seem to be well-regarded in the community
16:49:12 <arkeet> "many people"
16:49:13 <arkeet> again, who?
16:49:13 <samba1_> i can't name them currently
16:49:19 <samba1_> but i have no reason to lie
16:49:34 <samba1_> i have seen it in this room, on reddit, stack overflow
16:49:40 <benzrf> arkeet: i believe it
16:49:53 <samba1_> http://stackoverflow.com/questions/15003974/why-do-all-haskell-typeclasses-have-laws
16:51:00 <dmwit> There is a law, though a softer one than usual.
16:51:00 <samba1_> i don't know if it's right or not, you obviuosly don't think so, but i'm wondering what those who do propose instead. if making an "IsEmailBody" type class, like one would make an "Emailable" interface is wrong, is the only other option plain functions?
16:51:01 <arkeet> I don't understand this post.
16:51:05 <monochrom> I'm going to be blunt. two decades ago, my friends used to send *.exe files to me in email. I had no reason to suspect that they intentionally sent me viruses. like in your case. but I every reason to believe that they didn't know what they're doing.
16:52:26 <samba1_> it is late where i am and i must go to bed. i will think about how to better express this in english and ask again. maybe people who believe that a typeclass is a bad idea will be in the channel then and can offer their toughts
16:52:49 <dmwit> Namely that you could write a fromEmail :: Email -> a function which is a ??? inverse of toEmail. I can never remember whether I want right- or left-inverse, but you want toEmail . fromEmail = id, presumably.
16:52:52 <arkeet> I've never seen anyone here outright say typeclasses are bad.
16:53:03 <benzrf> typeclasses are bad
16:53:08 <arkeet> and be serious about it.
16:53:15 <dmwit> ?remember benzrf typeclasses are bad
16:53:15 <lambdabot> Good to know.
16:53:23 <dmwit> Now it is stored in perpetuity.
16:53:25 <samba1_> i've seen blogposts against typeclasses, and people coming from an ml background like me often find them kind of strange
16:53:33 <dmwit> or something
16:53:33 <samba1_> i don't dislike them, i like them in fact
16:53:45 <samba1_> but i'm confused as to how they are intended to be used exactly
16:53:51 <samba1_> Eq is very clear
16:53:58 <samba1_> but when i should make my own is not
16:54:02 * hackagebot BiobaseXNA 0.9.1.0 - Efficient RNA/DNA representations  http://hackage.haskell.org/package/BiobaseXNA-0.9.1.0 (ChristianHoener)
16:54:36 <monochrom> then simply be conservative and don't make your own type class until you actually have 3 instances.
16:55:06 <samba1_> for this email thing i'm doing i would easily have three instances
16:55:28 <simpson> I still feel like you have three different constructors of a single ADT.
16:55:36 <monochrom> note that because Haskell is leaned towards denotative programming rather than OOP, you are likely to have only 1 email type rather than 10 email "subtypes".
16:55:38 <samba1_> but i'm sure some people would still say don't make it because it's bad, there's no laws, etc. nobody here apparently, but i have seen it said
16:55:50 <samba1_> monochrom: yes, that is what i want
16:55:57 <samba1_> i just want a way to transform things into that email type
16:56:06 <samba1_> they aren't subtypes of emails, they can just be turned into emails
16:56:17 <dmwit> monochrom: There is one email type and ten other random types whose inhabitants could sensibly be communicated to people via email.
16:56:18 <arkeet> a typeclass is a perfectly appropriate thing to use then.
16:56:19 <samba1_> but preferably without a very specialized, explicitly declared method for each
16:56:58 <samba1_> sorry, i must go, i'm keeping my children awake. thank you all for your attention, i will consider this and hopefully express it better another time
16:59:32 <kirill`> If I have a computation a :: IO Bool that returns success/failure, then would you say it's obvious what this does:
16:59:32 <kirill`> a >>= (`unless` error "failed")
16:59:58 <kirill`> It doesn't look too readable to me, tbh
17:00:06 <hpc> it looks backwards
17:01:05 <kirill`> hpc: how so?
17:01:20 <zipper> What does {..} mean in record syntax?
17:01:30 <kirill`> zipper: RecordWildCards
17:01:40 <hpc> in languages like perl, foo unless p is translated as unless p {foo}
17:01:52 <hpc> which is also backwards
17:01:56 <hpc> so yours is double-backwards
17:02:01 <hpc> which is not to say that it's forwards
17:02:20 <kirill`> zipper: In a pattern it's a synonym for A{x = x, y = y} which binds local variables x, y to fields x, y
17:02:24 <hpc> i would write do {p <- a; unless p $ do {error failed}}
17:02:43 <hpc> except multi-line
17:02:50 <zipper> kirill`: Ah nice that example makes sense.
17:02:53 <kirill`> When creating a value it means it's the same synonym, A{x = x, y = y} but it creates a value with fields taken from local variables
17:02:53 <hpc> and with better variable names than p and a
17:04:02 * hackagebot NaturalLanguageAlphabets 0.0.1.0 - Alphabet and word representations  http://hackage.haskell.org/package/NaturalLanguageAlphabets-0.0.1.0 (ChristianHoener)
17:04:58 <kirill`> hpc: yeah, that's what I had originally
17:08:25 <kirill`> There should be a function unlessM :: m Bool -> m () -> m ()
17:09:16 <adu> kirill`: there should always be a function
17:09:33 <erisco> :t guard -- kirill` 
17:09:34 <lambdabot> Alternative f => Bool -> f ()
17:12:43 <arkeet> erisco: how is one supposed to use that for unlessM?
17:12:59 <kirill`> erisco: No, that's not it, it's not like unless. unlessM True (putStrLn "a") should not print anything, that's not what guard does at all.
17:13:26 <arkeet> :t unless
17:13:27 <lambdabot> Applicative f => Bool -> f () -> f ()
17:13:27 <benzrf> :t unless
17:13:28 <lambdabot> Applicative f => Bool -> f () -> f ()
17:13:37 <benzrf> oh
17:13:39 <benzrf> wait, bleh
17:13:44 <benzrf> llol
17:13:47 <erisco> I don't know what the spec was, I was just offering something which looked close
17:14:00 <arkeet> :t \p a -> p >>= flip unless a
17:14:01 <lambdabot> Monad m => m Bool -> m () -> m ()
17:14:31 <kirill`> :t (. flip unless) . (>>=)
17:14:32 <lambdabot> Monad f => f Bool -> f () -> f ()
17:14:54 <arkeet> https://hackage.haskell.org/package/extra-1.1/docs/Control-Monad-Extra.html#v:unlessM
17:15:32 <erisco> kirill` so what is unlessM supposed to do?
17:15:42 <kirill`> Why does lambdabot's unless have the constraint Applicative f? My ghci has Monad m => Bool -> m () -> m()
17:16:26 <cite-reader> Guessing GHC 7.10 has something to do with it.
17:16:29 <kirill`> arkeet: thanks!
17:17:13 <kirill`> erisco: \pred work -> do x <- pred; unless x work
17:19:02 * hackagebot nested-routes 0.3.2.1 - Declarative, compositional Wai responses  http://hackage.haskell.org/package/nested-routes-0.3.2.1 (athanclark)
17:20:04 <Cale> kirill`: The types of a lot of things have changed in GHC 7.10
17:20:17 <Cale> :t foldr
17:20:18 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
17:20:26 <Cale> :t concat
17:20:27 <lambdabot> Foldable t => t [a] -> [a]
17:24:02 * hackagebot AlignmentAlgorithms 0.0.1.0 - Collection of alignment algorithms  http://hackage.haskell.org/package/AlignmentAlgorithms-0.0.1.0 (ChristianHoener)
17:27:59 <octopuscabbage> for a dependently typed language for someone with a pretty minor math background would agda or idris be better?
17:28:17 <alynn> better than what?
17:28:29 <octopuscabbage> than each other
17:28:32 <octopuscabbage> which one is preferable
17:28:34 <alynn> oh
17:28:35 <alynn> right
17:28:35 <octopuscabbage> or
17:28:38 <octopuscabbage> compare contrast them
17:28:51 <octopuscabbage> or suggest your own that i should learn
17:28:57 <benzrf> octopuscabbage: agda is more of a theory lnguae
17:28:59 <arkeet> I think idris is more geared toward programming
17:28:59 <benzrf> *language
17:29:01 <alynn> uh, I personally found idris more accessible
17:29:20 <benzrf> octopuscabbage: idris is specifically designed to be usable for practical program-writing and (debatably) has more features
17:29:29 <octopuscabbage> idris it is, thanks guys
17:29:33 <benzrf> agda is probably Purer of Spirit or sth
17:29:42 <octopuscabbage> anyone know a good idris book
17:30:50 <JagaJaga> octopuscabbage: please ask that on #idris
17:31:01 <octopuscabbage> JagaJaga, okay
17:39:03 * hackagebot gitit 0.10.6.3 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.10.6.3 (JohnMacFarlane)
17:40:14 <erisco> how would you go about marshalling Data.Vector.Unboxed.Vector or Data.Vector.Unboxed.Mutable.Vector to C?
17:40:22 <grandpascorpion> Hello, sorry for the newbie question ...  I would like to use trace for a function and have the current timestamp (say getCurrentTime) printed. 
17:44:05 <erisco> seems Data.Vector.Storable is for this
17:44:36 <lokathor> it seems weird that you can have a type that's Bounded but not Enum
17:44:46 <lokathor> and i'm not quite thinking of an example of what that'd be
17:44:53 <kirill`> erisco: Data.Vector.Storable.unsafeWith
17:45:24 <erisco> which means I probably want to start figuring out the generic vector interface, though it is confusing
17:45:47 <arkeet> lokathor: Enum is kind of a hack anyway
17:45:59 <ion> There are clear bounds for IEEE floats (although there are multiple choices on which bound you want), but the current Enum instance does not make sense for them.
17:46:17 <arkeet> > succ (1,2)
17:46:18 <lambdabot>      No instance for (Show t0)
17:46:19 <lambdabot>        arising from a use of âshow_M888954673765883102429497â
17:46:19 <lambdabot>      The type variable ât0â is ambiguous
17:46:23 <byorgey> grandpascorpion: all questions are welcome here.  I'm not sure if printing the current time from within trace is really possible.
17:46:25 <arkeet> > succ (1,2) :: (Int,Int)
17:46:26 <lambdabot>      No instance for (Enum (Int, Int)) arising from a use of âsuccâ
17:46:27 <lambdabot>      In the expression: succ (1, 2) :: (Int, Int)
17:46:29 <arkeet> > maxBound :: (Int,Int)
17:46:30 <lambdabot>  (9223372036854775807,9223372036854775807)
17:46:42 <lokathor> arkeet, a hack?
17:46:51 <byorgey> grandpascorpion: maybe if you give us a better idea of what you are trying to do, we might have some suggestions
17:47:21 <arkeet> lokathor: I think it more or less exists just so you can write stuff like [a..b]
17:47:39 <lokathor> well, sure seems that way, yes
17:48:08 <arkeet> > fromEnum (2.5 :: Double)
17:48:09 <lambdabot>  2
17:48:35 <arkeet> and it doesn't allow for any sort of safe succ or pred
17:48:45 <arkeet> or toEnum
17:48:49 <arkeet> > toEnum 2 :: Bool
17:48:50 <lambdabot>  *Exception: Prelude.Enum.Bool.toEnum: bad argument
17:48:55 <arkeet> > succ True
17:48:57 <lambdabot>  *Exception: Prelude.Enum.Bool.succ: bad argument
17:49:26 <arkeet> > maxBound :: Double
17:49:27 <lambdabot>      No instance for (Bounded Double) arising from a use of âmaxBoundâ
17:49:27 <lambdabot>      In the expression: maxBound :: Double
17:49:30 <arkeet> :(
17:51:34 <lokathor> when ghc suggests spelling corrections it's basically the cutest thing
17:51:41 <lokathor> i wish more compilers could do that
17:51:51 <grandpascorpion> Thanks, byorgey.  I have a program which is cycling through a long list of residues.  I'd like it to print each time it starts to process a new block.  Here's a code snippet:
17:52:17 <grandpascorpion> gen g | trace ("Running gen with number " ++ show g ++ " at " ++ currentTime) False = undefined gen g = g : gen (g+1)  firstLevelList :: [Integer] firstLevelList = [ m * x + r | x <- (gen fb), r <- (tail residueListing)]                  where m  = head residueListing                        fb = floor ((fromIntegral searchLB)/(fromIntegral m))
17:52:32 <grandpascorpion> Sorry, that looks awful.  One line at a time ...
17:52:43 <grandpascorpion> gen g = g : gen (g+1)
17:52:53 <grandpascorpion> firstLevelList = [ m * x + r | x <- (gen fb), r <- (tail residueListing)]
17:52:56 <geekosaur> @paste
17:52:56 <lambdabot> Haskell pastebin: http://lpaste.net/
17:52:57 <Hijiri> you could try putting it on lpaste or a similar site
17:53:16 <grandpascorpion> Thx, will do
17:54:11 <Taco__> anyone familiar with pandoc care to test the feasibility of converting a certain html file to CSV? 
17:55:06 <grandpascorpion> Here's the snippet:  http://lpaste.net/132191
17:55:08 <athan> Taco__: I suggest HXT for html/xml data mining :\
17:56:33 <byorgey> grandpascorpion: hmm, that's an interesting problem
17:58:40 <byorgey> grandpascorpion: trace is already something of a hack, you're really not supposed to be able to do I/O (like print to the screen or get the current time) from within a value of type [Integer]
17:59:41 <byorgey> on the other hand you don't want to have to rewrite your nice pure code into a completely different style just so you can do a little logging.
17:59:48 <grandpascorpion> Basically, it's a recreational math program that very occasionally finds solutions. So, I can get by with just printing the block number (in case my code terminates or I have to restart) but it would be nice to get an idea of the performance.  Some background:  http://www.primepuzzles.net/puzzles/puzz_782.htm (I'm Fred :) )
18:04:09 <ronh-> I have a record with many fields, all of which are Maybes of some type. is there a smart way I could take advantage of "reads" function so that if the string misses some fields they default to Nothing? or do I have to parse everything manually?  string is in the form of "Data { someField = Just 10 }", while the actual Data type has several more fields
18:04:41 <geekosaur> read / reads isn't smart enough to do that
18:05:10 <ronh-> I thought so.. anything that maybe is?
18:06:25 <geekosaur> parsers with parsec or attoparsec are simple enough that that's the usual place to go anytime you need something more complex than reads can provide
18:07:06 <byorgey> ronh-: I doubt it.  But if you make a function that can merge two records (so that Just values override Maybe values), you can write a parser that parses each field into a whole record with Nothing everywhere except in the given field, and then merge them all at the end
18:07:16 <byorgey> *override Nothing value
18:07:30 <ronh-> ideally the parser would automatically work when I change or expand the record type.. not sure if that is even possible.. how does haskell stand with reflection
18:08:48 <lokathor> i've wondered that myself
18:08:52 <geekosaur> GHC.Generics, Data.Typeable
18:09:15 <geekosaur> reflection is more or less how libraries like aeson work
18:11:50 <grandpascorpion> byorgey, I wonder if I could make my own little version of trace but add a command to call getCurrentTime.  I appended that here:  http://lpaste.net/132191
18:18:12 <lokathor> :t randomIO
18:18:13 <lambdabot> Random a => IO a
18:18:18 <lokathor> >randomIO
18:18:30 <arkeet> > randomIO
18:18:31 <lambdabot>      No instance for (Typeable a0)
18:18:32 <lambdabot>        arising from a use of âshow_M152257938754931291030090â
18:18:32 <lambdabot>      In the expression:
18:18:39 <lokathor> hmm
18:18:43 <arkeet> > randomIO :: IO Int
18:18:44 <lambdabot>  <IO Int>
18:18:55 <lokathor> and yet you can type "randomIO" on its own in ghci
18:18:57 <lokathor> and it works
18:19:01 <arkeet> yes, lambdabot is not ghci
18:19:04 <arkeet> ghci will run IO actions for you.
18:19:05 <arkeet> lambdabot won't.
18:19:14 <lokathor> but it's an IO a
18:19:19 <arkeet> it defaults to a = ()
18:19:29 <arkeet> (because ghci has extended defaulting)
18:19:32 <lokathor> ahhhh
18:20:32 <grandpascorpion> I got it to work.  It's not pretty but ... http://lpaste.net/132191
18:20:36 <arkeet> actually I guess it defaults to Integer.
18:20:48 <grandpascorpion> Thanks folks
18:20:57 <arkeet> because () doesn't have a Random instance.
18:21:00 <arkeet> (I wonder why.)
18:21:35 <arkeet> (it's obviously not very useful, but it makes sense.)
18:21:41 <lokathor> not much use to pick randomly from among all the () values
18:21:47 <lokathor> since theres just the one
18:22:12 <lokathor> :t Int
18:22:13 <lambdabot>     Not in scope: data constructor âIntâ
18:22:13 <lambdabot>     Perhaps you meant one of these:
18:22:13 <lambdabot>       âInâ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
18:22:19 <lokathor> :k Int
18:22:20 <lambdabot> *
18:22:24 <lokathor> :k ()
18:22:25 <lambdabot> *
18:22:28 <lokathor> oh fun
18:22:34 <arkeet> I wonder why it doesn't have an instance for tuples.
18:22:57 <lokathor> they provide the legos, you provide the ~imagination~
18:23:08 <arkeet> you mean you provide the orphan instances.
18:23:15 <arkeet> :<
18:23:52 <lokathor> i've never been told why instances can't be controlled in the imports and exports lists
18:23:59 <lokathor> other than "it'd be complicated"
18:29:00 <ion> I have seen â¡ in modal logic translated to Functor f (among other things). Is there an equivalent translation for â?
18:35:40 <Cale> ion: Usually both are functors with additional properties
18:35:58 <ion> Cale: ok
18:36:00 <Cale> (exactly which properties depends on what sort of modal logic)
18:39:08 * hackagebot gsasl 0.3.6 - Bindings for GNU libgsasl  http://hackage.haskell.org/package/gsasl-0.3.6 (JohnMillikin)
18:39:10 * hackagebot ADPfusion 0.4.0.2 - Efficient, high-level dynamic programming.  http://hackage.haskell.org/package/ADPfusion-0.4.0.2 (ChristianHoener)
18:39:12 * hackagebot AlignmentAlgorithms 0.0.1.2 - Collection of alignment algorithms  http://hackage.haskell.org/package/AlignmentAlgorithms-0.0.1.2 (ChristianHoener)
18:39:52 <wayne> hey what's the most popular package for dealing with json?
18:40:11 <johnw> aeson
18:42:40 <arkeet> are there even any others? :-)
18:43:05 <mjrosenb> @pl \a b c -> ((a,b),c)
18:43:05 <lambdabot> ((,) .) . (,)
18:43:07 <Cale> There are, but almost everyone uses aeson now.
18:43:22 <arkeet> that's my point
18:43:24 <mjrosenb> uhhh, helll no.
18:43:47 <mjrosenb> @pl \a b c -> f (a,b) c
18:43:47 <lambdabot> (f .) . (,)
18:44:06 <mjrosenb> @pl \a b c -> f a (b, c)
18:44:06 <lambdabot> (. (,)) . (.) . f
18:44:13 <arkeet> :t curry (,)
18:44:14 <lambdabot> a -> b -> b1 -> ((a, b), b1)
18:44:59 <mjrosenb> arkeet: that is evil.
18:45:07 <arkeet> how so?
18:45:27 <lokathor> > map (\x -> fst $ randomR (1,6) (mkStdGen 10)) [1 .. 20]
18:45:29 <lambdabot>  [6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6]
18:45:46 <ion> lokathor: https://xkcd.com/221/
18:45:54 <lokathor> yep
18:45:56 <lokathor> fair dice roll
18:45:56 <mjrosenb> lambdabot: yes, it is a Prng
18:46:09 <mjrosenb> lokathor: there is worse though.
18:46:12 <lokathor> > map (\x -> fst $ randomR (1,6) (mkStdGen x)) [1 .. 20]
18:46:13 <lambdabot>  [6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6]
18:46:23 <lokathor> even when i fix my error it's still all 6s
18:46:28 <mjrosenb> yeah, that's the bad thing.
18:46:43 <mjrosenb> lokathor: use a range with a width other than 5.
18:46:47 <arkeet> > map (\x -> fst $ random (1,6) (mkStdGen x)) [1 .. 20]
18:46:48 <lambdabot>      Couldn't match expected type âStdGen -> (b, b0)â
18:46:48 <lambdabot>                  with actual type â(a0, (t0, t1))â
18:46:48 <lambdabot>      The function ârandomâ is applied to two arguments,
18:46:50 <lokathor> if you give really big seeds it'll start to diverse up
18:46:53 <arkeet> > map (\x -> fst $ random (mkStdGen x)) [1 .. 20]
18:46:54 <lambdabot>  [7918028818325808681,-2493429425036973456,5541856405309796022,-2579161911402...
18:47:14 <arkeet> > map (\x -> fst $ random (1,6) (mkStdGen (10000000+x))) [1 .. 20]
18:47:15 <lambdabot>      Couldn't match expected type âStdGen -> (b, b0)â
18:47:15 <lambdabot>                  with actual type â(a0, (t0, t1))â
18:47:15 <lambdabot>      The function ârandomâ is applied to two arguments,
18:47:19 <arkeet> > map (\x -> fst $ randomR (1,6) (mkStdGen (10000000+x))) [1 .. 20]
18:47:20 <lambdabot>  [6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6]
18:47:21 <mjrosenb> > map (\x -> fst $ randomR (1,6) (mkStdGen x)) [1 .. ] !! 100000
18:47:22 <lambdabot>  5
18:47:26 <mjrosenb> > map (\x -> fst $ randomR (1,6) (mkStdGen x)) [1 .. ] !! 1000000
18:47:27 <lambdabot>  6
18:47:40 <arkeet> > map (\x -> fst $ randomR (1,6) (mkStdGen (100000+x))) [1 .. 20]
18:47:41 <lambdabot>  [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]
18:47:44 <arkeet> ha
18:47:48 <mjrosenb> it is not completely broken, only mostly.
18:47:58 <lokathor> > take 10 $ randomRs (1,6) (mkStdGen 0)
18:48:00 <lambdabot>  [6,6,4,1,5,2,4,2,2,1]
18:48:06 <mjrosenb> > map length $ group $ map (\x -> fst $ randomR (1,6) (mkStdGen x)) [1 .. ] 
18:48:10 <lambdabot>  mueval-core: Time limit exceeded
18:48:20 <lokathor> the results over time are random and all
18:48:29 <arkeet> > map (length &&& head) . group . map (\x -> fst $ randomR (1,6) (mkStdGen x)) $ [0 ..]
18:48:32 <lokathor> but that first result seems to really like being 6 for a lot of seeds
18:48:33 <lambdabot>  mueval-core: Time limit exceeded
18:48:37 <arkeet> well then.
18:48:42 <ion> [53667,53668,53668,53669,53668,53668,53669,53668,53668,53669,53668,
18:48:50 <arkeet> > map (length &&& head) . group . take 10000 . map (\x -> fst $ randomR (1,6) (mkStdGen x)) $ [0 ..]
18:48:52 <lambdabot>  [(10000,6)]
18:48:54 <arkeet> pfft.
18:49:07 <lokathor> hahahahahaha
18:49:08 * hackagebot gnutls 0.1.6 - Bindings for GNU libgnutls  http://hackage.haskell.org/package/gnutls-0.1.6 (JohnMillikin)
18:49:09 <lokathor> perfection
18:49:17 <arkeet> > map (length &&& head) . group . take 100000 . map (\x -> fst $ randomR (1,6) (mkStdGen x)) $ [0 ..]
18:49:19 <lambdabot>  [(53668,6),(46332,5)]
18:49:29 <ion> [(53667,6),(53668,5),(53668,4),(53669,3),(53668,2),(53668,1),(53669,6),(53668,5),(53668,4),(53669,3),(53668,2),(53668,1),(53668,6),(53669,5),
18:49:35 <arkeet> thanks.
18:49:46 <mjrosenb> After the first number, it looks random mod 5, but before that, DANGER.
18:50:06 <mjrosenb> this has been a known limitation for a while
18:50:25 <arkeet> > map (\x -> fst $ randomR (1,6) (mkStdGen (2^x))) [1 ..]
18:50:27 <lambdabot>  [6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,5,4,2,3,5,3,6,6,6,5,4,2,3,5,3,6,6,6,6,6,6,6,6...
18:50:34 <arkeet> ouch
18:50:50 <arkeet> > map (\x -> fst $ randomR (1,6) (mkStdGen (3^x))) [1 ..]
18:50:51 <lambdabot>  [6,6,6,6,6,6,6,6,6,5,3,3,1,1,3,2,6,6,4,5,3,2,5,3,3,1,2,4,4,6,6,6,5,1,1,2,4,6...
18:50:58 <mjrosenb> :t mkStdgen
18:50:59 <lambdabot>     Not in scope: âmkStdgenâ
18:50:59 <lambdabot>     Perhaps you meant âmkStdGenâ (imported from System.Random)
18:51:05 <mjrosenb> :t mkStdGen
18:51:06 <lambdabot> Int -> StdGen
18:51:17 <ion> > map (\x -> fst $ randomR (1,6) (mkStdGen x)) [1,53670 ..]
18:51:18 <lambdabot>  [6,5,4,3,2,1,6,5,4,3,2,1,6,5,4,3,2,1,6,5,4,3,2,1,6,5,4,3,2,1,6,5,4,3,2,1,6,5...
18:51:21 <mjrosenb> arkeet: it takes an int, so after the first 64 values, they'll all be the same.
18:51:27 <arkeet> > map (\x -> fst $ randomR (1,6) (mkStdGen (101^x))) [1 ..]
18:51:29 <lambdabot>  [6,6,5,6,6,3,1,3,6,4,3,4,4,1,6,2,5,2,2,3,2,5,5,5,1,2,3,6,3,6,6,6,4,2,2,4,5,2...
18:51:30 <arkeet> mjrosenb: good point.
18:52:07 <arkeet> > randomRs (1,6) (mkStdGen 0)
18:52:09 <lambdabot>  [6,6,4,1,5,2,4,2,2,1,6,5,1,5,3,2,3,4,4,1,5,1,1,6,5,6,3,4,6,5,6,3,6,3,5,5,3,5...
18:53:54 <mjrosenb> > map (\x -> randomRs (1,6) (mkStdGen x) !! 1) [0..]
18:53:55 <lambdabot>  [6,5,4,4,3,2,1,1,6,5,4,4,3,2,1,1,6,5,4,4,3,2,1,1,6,5,4,4,3,2,1,1,6,5,4,4,3,2...
18:54:11 <mjrosenb> that is less random than I remember it being.
18:54:24 <mjrosenb> > map (\x -> randomRs (1,6) (mkStdGen x) !! 2) [0..]
18:54:25 <lambdabot>  [4,2,1,5,3,2,6,4,3,1,6,4,2,1,5,3,2,6,5,3,1,6,4,2,1,5,4,2,6,5,3,1,6,4,3,1,5,4...
18:54:38 <arkeet> > map (\x -> randomRs (1,6) (mkStdGen x) !! 1000) [0..]
18:54:40 <lambdabot>  [3,6,3,6,4,1,4,1,4,2,5,2,5,2,6,3,6,3,6,4,1,4,1,4,2,5,2,5,2,6,3,6,3,6,4,1,4,1...
18:54:46 <arkeet> cute.
18:55:07 <mjrosenb> do they /all/ repeat?
18:56:11 <lokathor> huh
18:56:15 <lokathor> didn't notice the obvious cycles
18:57:29 <mjrosenb> also, is there a random generator that has more than 64 bits of entropy?
18:57:37 <mjrosenb> 64 bits is not a large amount.
18:57:56 <arkeet> there are plenty
18:58:05 <arkeet> StdGen just isn't one of them, I suppose.
18:58:29 <mjrosenb> are there plenty that ship with ghc?
18:58:37 <arkeet> ghc doesn't ship with any prngs
18:59:09 * hackagebot network-protocol-xmpp 0.4.7 - Client library for the XMPP protocol.  http://hackage.haskell.org/package/network-protocol-xmpp-0.4.7 (JohnMillikin)
18:59:09 <mjrosenb> oh, random is a separate package?
18:59:11 <arkeet> yep
18:59:30 <arkeet> that's the only one in the platform though, afaik.
18:59:39 <kirill`> Is there a way to get ghci to print a stack trace?
18:59:43 <mjrosenb> strange, I guess I always pulled it in as part of something else so early on I never even realized it.
18:59:53 <arkeet> I think cabal-install needs it.
19:00:18 <mjrosenb> kirill`: in the debugger, probably, but iirc, it isn't as useful as you'd want it to be.
19:00:38 <kirill`> I only want the line and file that threw the exception
19:02:14 <kirill`> GHCi is telling me
19:02:14 <kirill`> Exception: GLError [Error InvalidOperation "invalid operation"]
19:02:14 <kirill`> which isn't super helpful
19:03:38 <arkeet> try -xc
19:03:53 <arkeet> well, the RTS option -xc
19:04:08 <arkeet> also http://stackoverflow.com/questions/6584409/how-to-display-a-backtrace-for-an-error-thrown-in-haskell
19:04:19 <lokathor> > take 100 $ drop 10 $ randomRs (1,6) (mkStdGen 0)
19:04:21 <lambdabot>  [6,5,1,5,3,2,3,4,4,1,5,1,1,6,5,6,3,4,6,5,6,3,6,3,5,5,3,5,6,2,4,5,3,2,2,4,2,2...
19:04:34 <lokathor> it seems that all you have to do to get good results is throw out the first few values
19:04:40 <arkeet> mhm
19:04:41 <lokathor> well, "better results"
19:04:48 <arkeet> > take 100 $ randomRs (1,6) (mkStdGen 0)
19:04:50 <lambdabot>  [6,6,4,1,5,2,4,2,2,1,6,5,1,5,3,2,3,4,4,1,5,1,1,6,5,6,3,4,6,5,6,3,6,3,5,5,3,5...
19:04:59 <arkeet> well more like
19:05:05 <arkeet> just start with one seed
19:05:11 <arkeet> and reuse the StdGen everywhere
19:05:56 <lokathor> i want to run several in parallel
19:05:57 <lokathor> if i can
19:06:11 <arkeet> you can split the StdGen
19:06:18 <lokathor> yeah
19:06:26 <mjrosenb> > take 100 $ randomRs (1,6) (mkStdGen 0)
19:06:27 <lambdabot>  [6,6,4,1,5,2,4,2,2,1,6,5,1,5,3,2,3,4,4,1,5,1,1,6,5,6,3,4,6,5,6,3,6,3,5,5,3,5...
19:06:31 <mjrosenb> > take 100 $ randomRs (1,6) (mkStdGen 16)
19:06:32 <lambdabot>  [6,6,2,6,6,2,1,3,4,2,5,5,3,5,1,6,6,3,3,5,4,5,3,4,3,1,2,6,6,6,6,6,2,3,1,1,2,3...
19:06:44 <arkeet> why are we using take 100, anyway
19:06:48 <lokathor> you'd split it up a few times and then make a list of the results and then run parMap over that?
19:07:03 <arkeet> maybe? idk what you're doing
19:07:13 <lokathor> i was using take 100 because in ghci it doesn't cut off the result automatically like lambdabot does
19:07:20 <arkeet> sure.
19:07:21 <mjrosenb> >  randomRs (1,6) (mkStdGen 8)
19:07:23 <lambdabot>  [6,6,3,4,2,2,2,6,3,4,3,5,2,5,5,4,1,1,4,3,2,6,5,2,4,1,3,5,6,5,6,5,1,3,6,3,2,1...
19:08:14 <lokathor> arkeet, ultimately i have a really weird RNG and i want to run lots of trials so that i can collect the results and then get some statistics
19:08:41 <arkeet> > mkStdGen 0
19:08:43 <lambdabot>  1 1
19:08:45 <arkeet> > mkStdGen 1
19:08:46 <lokathor> so i figured it'd be handy to use all my cores
19:08:47 <lambdabot>  2 1
19:08:50 <arkeet> > mkStdGen 1024
19:08:51 <lambdabot>  1025 1
19:08:54 <arkeet> > mkStdGen 2^32
19:08:55 <lambdabot>      No instance for (Num StdGen) arising from a use of â^â
19:08:55 <lambdabot>      In the expression: mkStdGen 2 ^ 32
19:08:58 <arkeet> > mkStdGen (2^32)
19:08:59 <lambdabot>  1 1
19:09:04 <arkeet> no wonder it's crappy.
19:09:08 <lokathor> and also, i've never done that, so i figured perhaps this was a good learning experience
19:09:26 <lokathor> > read "well you can also read in any arbitrary string" :: StdGen
19:09:28 <lambdabot>  *Exception: Prelude.read: no parse
19:09:33 <arkeet> > random (mkStdGen 0)
19:09:35 <lambdabot>  (9106162675347844341,1346387765 2103410263)
19:09:37 <arkeet> > random (mkStdGen 1)
19:09:38 <lambdabot>  (7918028818325808681,545291967 2103410263)
19:09:51 <lokathor> oh no, the StdGen docs lied to me!
19:10:28 <arkeet> hah
19:10:42 <arkeet> > read (show $ MkStdGen 0)
19:10:44 <lambdabot>      Not in scope: data constructor âMkStdGenâ
19:10:44 <lambdabot>      Perhaps you meant variable âmkStdGenâ (imported from System.Random)
19:10:46 <arkeet> > read (show $ mkStdGen 0)
19:10:48 <lambdabot>  *Exception: Prelude.read: no parse
19:10:51 <lokathor> In general, the read instance of StdGen has the following properties:
19:10:51 <lokathor>  It guarantees to succeed on any string.
19:10:51 <arkeet> !!
19:10:54 <arkeet> > read (show $ mkStdGen 0) :: StdGen
19:10:55 <lambdabot>  1 1
19:11:07 <arkeet> > read "123 4567" :: StdGen
19:11:09 <lambdabot>  123 4567
19:11:15 <arkeet> > randomRs (1,6) (read "123 4567")
19:11:17 <lambdabot>      Could not deduce (RandomGen g0) arising from a use of ârandomRsâ
19:11:17 <lambdabot>      from the context (Num a, Random a)
19:11:17 <lambdabot>        bound by the inferred type of it :: (Num a, Random a) => [a]
19:11:21 <arkeet> > randomRs (1,6) (read "123 4567" :: StdGen)
19:11:22 <lambdabot>  [6,6,6,1,4,3,2,3,5,6,6,2,5,5,4,5,4,1,6,5,5,2,5,3,3,6,1,3,6,1,1,4,1,4,5,6,3,5...
19:11:34 <arkeet> more 6s.
19:11:39 <arkeet> oh well yeah ok.
19:13:09 <arkeet> > (reads :: ReadS StdGen) "abcd"
19:13:10 <lambdabot>  [(3980 1,"")]
19:13:25 <arkeet> > (reads :: ReadS StdGen) "well you can also read in any arbitrary string"
19:13:27 <lambdabot>  [(41933 1,"ou can also read in any arbitrary string")]
19:13:41 <arkeet> > read "well you can also read in any arbitrary string" :: StdGen
19:13:42 <lambdabot>  *Exception: Prelude.read: no parse
19:13:46 <arkeet> oh haha.
19:13:56 <arkeet> > read "abcd" :: StdGen
19:13:57 <lambdabot>  3980 1
19:14:30 <arkeet> "It guarantees to consume only a finite portion of the string."
19:14:34 <arkeet> alright.
19:14:52 <lokathor> > read "soYouJustCan'tUseSpace?" :: StdGen
19:14:53 <arkeet> > read ["abcdef","ghijkl"] :: [StdGen]
19:14:53 <lambdabot>  *Exception: Prelude.read: no parse
19:14:54 <lambdabot>      Couldn't match expected type âCharâ with actual type â[Char]â
19:14:54 <lambdabot>      In the expression: "abcdef"
19:14:54 <lambdabot>      In the first argument of âreadâ, namely â["abcdef", "ghijkl"]â
19:15:04 <arkeet> > read "[abcdef,ghijkl]" :: [StdGen]
19:15:05 <lambdabot>  [36217 1,38401 1]
19:15:12 <arkeet> you can use space
19:15:12 <lokathor> > read "soYouJustCantUseSpace" :: StdGen
19:15:13 <lambdabot>  *Exception: Prelude.read: no parse
19:15:16 <arkeet> you just cna't use anything longer than 6 characters
19:15:25 <lokathor> so much for "any string"
19:15:26 <arkeet> https://hackage.haskell.org/package/random-1.1/docs/src/System-Random.html#stdFromString
19:15:29 <arkeet> yeah haha
19:15:46 <arkeet> well, it only talks about reads succeeding
19:15:47 <arkeet> not read
19:16:12 <arkeet> also it can't make anything you can't make with mkStdGen
19:17:48 <arkeet> @let mkStdGen' n = iterate (snd . next) (mkStdGen n) !! 256
19:17:49 <lambdabot>  Defined.
19:18:11 <arkeet> > map (\x -> fst $ randomR (1,6) (mkStdGen' x)) [0 ..]
19:18:13 <lambdabot>  [3,2,2,1,6,6,5,4,4,3,3,2,1,1,6,5,5,4,3,3,2,2,1,6,6,5,4,4,3,2,2,1,1,6,5,5,4,3...
19:18:19 <arkeet> still not very random haha
19:18:37 <arkeet> better than all 6s though
19:19:33 <arkeet> @let mkStdGen'' k n = iterate (snd . next) (mkStdGen n) !! k
19:19:34 <lambdabot>  Defined.
19:19:39 <arkeet> > map (\x -> fst $ randomR (1,6) (mkStdGen'' (2^16) x)) [0 ..]
19:19:43 <lambdabot>  mueval-core: Time limit exceeded
19:19:45 <arkeet> :(
19:19:49 <arkeet> > take 40 $ map (\x -> fst $ randomR (1,6) (mkStdGen'' (2^16) x)) [0 ..]
19:19:52 <lambdabot>  [3,5,1,3,5,1,3,5,1,3,5,1,3,5,1,3,5,1,3,5,1,3,5,1,3,5,1,3,5,1,3,5,1,3,5,1,3,5...
19:19:58 <ion> > map (\x -> fst $ randomR (1,6) ((fst . split . mkStdGen) x)) [0 ..]
19:19:59 <arkeet> welp
19:19:59 <lambdabot>      Couldn't match type â[a0] -> [[a0]]â with â(b0, b1)â
19:20:00 <lambdabot>      Expected type: Splitter a0 -> (b0, b1)
19:20:00 <lambdabot>        Actual type: Splitter a0 -> [a0] -> [[a0]]
19:20:13 <arkeet> > map (split . mkStdGen) [0..]
19:20:14 <lambdabot>      Couldn't match type âStdGenâ with âSplitter aâ
19:20:15 <lambdabot>      Expected type: Int -> Splitter a
19:20:15 <lambdabot>        Actual type: Int -> StdGen
19:20:21 <lokathor> "In addition, read may be used to map an arbitrary string (not necessarily one produced by show) onto a value of type StdGen."
19:20:25 <arkeet> > map (System.Random.split . mkStdGen) [0..]
19:20:25 <lokathor> it says read, not reads
19:20:27 <lambdabot>  [(2 40692,40014 2147483398),(3 40692,80028 2147483398),(4 40692,120042 21474...
19:20:36 <arkeet> lokathor: it says reads for me.
19:20:39 <arkeet> in random-1.1
19:20:55 <lokathor> oh right
19:21:04 <lokathor> i'm looking at the old docs
19:21:09 <lokathor> i hate how google does that
19:21:14 <arkeet> yeah :(
19:21:41 <ion> > map (\x -> fst $ randomR (1,6) ((fst . System.Random.split . mkStdGen) x)) [0 ..]
19:21:43 <lambdabot>  [6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6...
19:21:44 <lokathor> > reads "test this" :: StdGen
19:21:45 <arkeet> docs ought to use a canonical url
19:21:46 <lambdabot>      Couldn't match expected type âStdGenâ
19:21:46 <lambdabot>                  with actual type â[(a0, String)]â
19:21:46 <lambdabot>      In the expression: reads "test this" :: StdGen
19:21:56 <arkeet> > (reads :: ReadS StdGen) "test this"
19:21:57 <lambdabot>  [(41460 1,"his")]
19:22:03 <ion> > map (\x -> fst $ randomR (1,6) ((snd . System.Random.split . mkStdGen) x)) [0 ..]
19:22:05 <lambdabot>  [1,6,5,5,4,3,2,2,1,6,5,5,4,3,2,2,1,6,5,5,4,3,2,2,1,6,5,5,4,3,2,2,1,6,5,5,4,3...
19:22:06 <arkeet> read fails if there's unconsumed input
19:22:35 <arkeet> > map (\x -> fst $ randomR (1,6) (mkStdGen x)) [0,-1 ..]
19:22:36 <lambdabot>  [6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6...
19:22:55 <lokathor> oh damn
19:23:43 <lokathor> > map (\x -> take 3 $ drop 10 $ fst $ randomRs (1,6) (mkStdGen x)) [0,-1 ..]
19:23:44 <lambdabot>      Couldn't match expected type â([a], b0)â
19:23:44 <lambdabot>                  with actual type â[Integer]â
19:23:44 <lambdabot>      In the second argument of â($)â, namely
19:23:47 <lokathor> whoops
19:24:49 <lokathor> > map (\x -> take 3 $ drop 10 $ randomRs (1,6) (mkStdGen x)) [0,-1 ..]
19:24:51 <lambdabot>  [[6,5,1],[2,1,1],[4,4,1],[6,1,1],[2,4,6],[4,1,6],[6,4,6],[2,2,6],[3,5,6],[5,...
19:26:26 <arkeet> > (zipWith (-) <*> tail) $ map (\x -> fst . random $ mkStdGen x) [0..]
19:26:28 <lambdabot>  [1188133857022035660,10411458243362782137,-8035285830346769478,5799772596450...
19:26:30 <arkeet> hm
19:26:39 <arkeet> > map (\x -> fst . randomR (1,100) $ mkStdGen x) [0..]
19:26:40 <lambdabot>  [84,36,50,64,78,92,6,20,34,48,62,76,90,4,18,32,46,60,74,88,2,16,30,44,58,72,...
19:26:54 <arkeet> > map (\x -> fst . randomR (1,50) $ mkStdGen x) [0..]
19:26:55 <lambdabot>  [34,36,50,14,28,42,6,20,34,48,12,26,40,4,18,32,46,10,24,38,2,16,30,44,8,22,3...
19:27:01 <arkeet> > map (\x -> fst . randomR (1,14) $ mkStdGen x) [0..]
19:27:03 <lambdabot>  [8,10,12,14,2,4,6,8,10,12,14,2,4,6,8,10,12,14,2,4,6,8,10,12,14,2,4,6,8,10,12...
19:27:04 <lokathor> > map (\x -> sum$drop 1$sort $ drop 10 $ randomRs (1,6) (mkStdGen x)) [0,-1 ..]
19:27:09 <lambdabot>  mueval: ExitFailure 1
19:27:22 <lokathor> :t sort
19:27:24 <lambdabot> Ord a => [a] -> [a]
19:27:33 <arkeet> try it again.
19:27:45 <arkeet> oh.
19:27:46 <lokathor> > map (\x -> sum$drop 1$sort $take 4$ drop 10 $ randomRs (1,6) (mkStdGen x)) [0,-1 ..]
19:27:48 <lambdabot>  [16,8,10,12,12,15,16,13,14,16,12,14,15,13,13,16,13,12,13,16,12,14,15,11,12,1...
19:27:50 <arkeet> you're trying to sum infinite lists yeah.
19:28:11 <lokathor> > map (\x -> sum$drop 1$sort $take 4$ drop 10 $ randomRs (1,6) (mkStdGen x)) [0 .. 5]
19:28:13 <lambdabot>  [16,8,12,10,14,6]
19:28:22 <lokathor> look now you can roll DnD stats
19:41:25 <mjrosenb> "let f x = do let ... "
19:41:45 * mjrosenb is not sure he's a fan of this structure
19:42:47 <mjrosenb> even better, there are like 3 things bound in the inner let (one of which has a do block inside of it)
19:42:54 <mjrosenb> and only a single other statement
19:43:07 <mjrosenb> ok, perhaps this is not actually the place for a do block...
19:45:17 <glguy> > do let {x = 10}; x + x
19:45:18 <lambdabot>  20
19:46:25 <slack1256> ?
19:46:44 <slack1256> oh
19:46:46 <slack1256> nvm
19:47:25 <glguy> > do let {x = 10}; x + do x -- silly things are possible
19:47:27 <lambdabot>  20
19:48:10 <tommd> Are the ACME packages in scope?
19:48:11 <tommd> > don't (do let {x = 10} ; x + x )
19:48:12 <lambdabot>  Not in scope: âdon'tâ
19:51:49 <arkeet> @let don't :: Monad m => m a -> m (); don't _ = return ()
19:51:51 <lambdabot>  Defined.
19:54:57 <echo-area> @don't
19:54:57 <lambdabot> Unknown command, try @list
19:55:28 <echo-area> > don't ()
19:55:29 <lambdabot>      Couldn't match expected type âm a0â with actual type â()â
19:55:29 <lambdabot>      In the first argument of âdon'tâ, namely â()â
19:55:29 <lambdabot>      In the expression: don't ()
19:55:51 <echo-area> > don't getChar
19:55:52 <lambdabot>  <IO ()>
20:06:17 <nitrix> What would be the cleanest way to maybe print a Maybe ByteString?
20:06:30 <lokathor> :t print
20:06:31 <lambdabot> Show a => a -> IO ()
20:06:36 <Clint> :t maybe
20:06:37 <lambdabot> b -> (a -> b) -> Maybe a -> b
20:07:39 <arkeet> nitrix: how do you want to print a Maybe ByteString?
20:07:41 <nitrix> I kind of wanted to avoid `maybe`, as the default value is irrelevant. Like, I don't want to "print nothing", I want to no print anything at all. The IO should just be IO ().
20:07:57 <nitrix> mapM_ gave me an error on GHC 5.8 claiming it works only on the list monad.
20:08:03 <arkeet> get mapM_ from Data.Foldable
20:08:06 <arkeet> 5.8???
20:08:10 <slack1256> !
20:08:15 <slack1256> how did yo build that
20:08:18 <webstrand> Can the return type of a function depend on the type of the parameters it was called with?
20:08:27 <arkeet> yes
20:08:30 <arkeet> :t id
20:08:30 <nitrix> I'm thinking an expression that'd look like  (ByteString -> IO ()) -> Maybe ByteString -> IO ()
20:08:31 <lambdabot> a -> a
20:08:36 <arkeet> nitrix: that's mapM_
20:08:44 <arkeet> from Data.Foldable
20:08:47 <ronh-> > maybe (return ()) print (Just 10)
20:08:48 <lambdabot>  <IO ()>
20:09:01 <nitrix> ronh-: but return () is ugly :(
20:09:07 <slack1256> ...
20:09:09 <arkeet> ....
20:09:11 * hackagebot CCA 0.1.5.3 - preprocessor and library for Causal Commutative Arrows (CCA)  http://hackage.haskell.org/package/CCA-0.1.5.3 (PaulLiu)
20:09:25 <arkeet> I give up
20:09:30 <johnw> for_ (Just 10) print
20:09:40 <slack1256> let pretty = return ()
20:09:41 <webstrand> arkeet: but isn't the type of the id determined at compile time? So that each type creates a new 'instance' of the function?
20:09:43 <slack1256> > let pretty = return ()
20:09:45 <lambdabot>  <no location info>: not an expression: âlet pretty = return ()â
20:09:48 <slack1256> @let pretty = return ()
20:09:49 <lambdabot>  Defined.
20:09:59 <arkeet> webstrand: not necessarily, and no.
20:10:02 <slack1256> > maybe pretty print (just 10)
20:10:03 <lambdabot>      Not in scope: âjustâ
20:10:04 <lambdabot>      Perhaps you meant data constructor âJustâ (imported from Data.Maybe)
20:10:07 <nitrix> How come Data.Foldable.mapM_ works and Prelude's doesn't ?
20:10:08 <arkeet> well, the type of id is a -> a
20:10:13 <arkeet> nitrix: because they're different.
20:10:22 <arkeet> Foldable's is more general.
20:10:30 <arkeet> and works for any Foldable, not just []
20:10:34 <arkeet> Maybe is Foldable
20:10:46 <nitrix> Oh, so this the problem I hit then. Prelude's version was restricited to the List monad.
20:10:48 <nitrix> Ah, there you go.
20:10:50 <arkeet> not monad
20:10:58 <homovitruvius> is there a good way to segregate config in a reader monad (or stack of them) so that individual passes in a compiler can only see their own portion of the config space?
20:10:58 <arkeet> :t mapM_
20:10:59 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
20:11:16 <arkeet> old Prelude's mapM_ has [] for t here
20:11:16 <arkeet> not m
20:11:45 <nitrix> Interesting
20:11:59 <arkeet> homovitruvius: 
20:12:04 <arkeet> :t withReaderT
20:12:05 <lambdabot> (r' -> r) -> ReaderT r m a -> ReaderT r' m a
20:12:39 <arkeet> maybe this helps.
20:20:55 <homovitruvius> arkeet: doesn't that forces me to do the plumbing almost manually? it seems that I need the appropriate runReaders everywhere and at thatt point I can as well pass the configuration explicitely. But I haven't looked at it yet, I will
20:21:14 <arkeet> maybe you can do something with typeclasses
20:25:07 <slack1256> Mmm so in diferent monads, you want to gives access to just a subpart of the 'r' of the Reader
20:26:16 <mjrosenb> f do x\ny\nz gets parsed as f (do {x; y; z}), yes?
20:27:07 <slack1256> mjrosenb: maybe with some 'f $ do x \n y \n z', but it should
20:32:46 <mjrosenb> slack1256: interesting, I figured it wouldn't be ambiguous, but I guess it is.
20:33:00 <slack1256> @asks
20:33:01 <lambdabot> Who should I ask?
20:33:07 <slack1256> @type asks
20:33:09 <lambdabot> MonadReader r m => (r -> a) -> m a
20:36:29 * mjrosenb has a function that is 78 lines long, and contains 3,200 characters :-/
20:36:54 <slack1256> homovitruvius: Ugh, maybe I am overthinking this. A indexed monad can represent a change on the reader environment, with that and a zipper-structure for a reader context you can downcast to a subpart of the 'r' and go up when needed.
20:37:12 <slack1256> but that is not practical.
20:37:40 <dmj`> why does pandoc take so long to install
20:37:57 <slack1256> mjrosenb: what were you implementing?
20:41:31 <pacak> mjrosenb: it's better than a function with 2 lines and 1000 characters...
20:42:26 <mjrosenb> slack1256: implementing a ListBox
20:42:35 <mjrosenb> like 90% of that is the rendering
20:42:40 <mjrosenb> and it is about to get longer.
20:43:13 <slack1256> A ListBox is that gui widget right?
20:43:20 <slack1256> (I'm ignorant)
20:43:48 <mjrosenb> yeah.
20:44:37 <slack1256> mjrosenb: Is for something privated? or is for a project? 
20:44:44 <slack1256> *private
20:46:59 <mjrosenb> slack1256: it is for a personal project.  the code is in git, but I haven't put it on github yet.
20:53:01 <grache28> I'm a little confused about this error message: Illegal type signature: `(a, b, c)' Perhaps you intended to use -XScopedTypeVariables In a pattern type-signature
20:53:52 <grache28> the code is "tercero :: (a, b, c) -> c" "tercero :: (a, b, c) = c"
20:54:05 <johnw> that second line has no meaning
20:54:14 <johnw> just drop the "::"
20:57:00 <grache28> johnw: doh, guess I should start with a fresh head tomorrow.. thanks
20:58:38 <dmj`> how do I disable default flags that are set to true in cabal files
20:59:03 <slack1256> grache28: Tambien puedes pegar codigo en lpaste.net
20:59:07 <dmj`> hakyll has 3 flags that all default to True, can I cabal configure -fpreviewServer=false
21:00:13 <grache28> slack1256: ok, thanks
21:07:50 <homovitruvius> slack1256: I'm not even sure it is a good idea to subdivide the config space. But I'm writing a toy parser and the commercial Verilog compiler I'm using as an example has literally thousand of flags (don't ask, please :-)) and since that's my excuse to learn haskell, I wanted to explore a bit how to do configuration in a large Haskell program.
21:14:42 <slack1256> homovitruvius: Well, It wouldn't subdivide the config space, on a zipper you can come back to the previous general view, to make it type safe you could tag with a phantom variable which reader context you are using. But yeah, overengineering is a thing. Concentrate on the parser, seems difficult as is.
21:15:55 <homovitruvius> slack1256: re: zipper, I'm not sure there's an up and down, although one can make the case that multiple "instances" of the same compilation pass logicaly have a separate configuration. Maybe the complete compiler can be seen as a tree of passes/transforms and at each node there's a fragment of config. Maybe a lens that focus on a subcomponent.
21:16:31 <athan> Why isn't `Sum` or `Product` foldable? Does it need to necessarilly pattern match on data constructors?
21:18:02 <slack1256> homovitruvius: https://hackage.haskell.org/package/lens-3.2/docs/Control-Lens-Zoom.html
21:18:30 <slack1256> ed always a step ahead
21:21:48 <SrPx> This program takes 1.2s to run on my computer: http://lpaste.net/132198 does anyone know if there is an obvious way to make it faster? 
21:22:13 <SrPx> (If it is not simple/obvious please don't worry, I'm talking about stuff like bang patterns and sparks.)
21:22:26 <SrPx> inline flags, etc
21:25:49 <johnw> you can capture div p x and 10^n as variable, so the computation is shared
21:26:04 <johnw> i'm not sure that GHC will do sub-expression elimination
21:26:19 <johnw> also, the two calls to show
21:26:59 <SrPx> Ofc, thanks. 
21:29:23 * hackagebot ekg 0.4.0.6 - Remote monitoring of processes  http://hackage.haskell.org/package/ekg-0.4.0.6 (JohanTibell)
21:30:23 <tommd> there's got to be a faster algorithm to determine show x == reverse (show x)
21:30:24 <SrPx> Well, seems like GHC was doing the CSE. Same perf: http://lpaste.net/132200
21:30:41 <slack1256> you are checking if x*y is a palindrome on base 10
21:30:44 <johnw> cool
21:30:50 <SrPx> tommd: I wondered that though, but implementing it using int math made it slower here. Could be my implementation, though.
21:30:53 <slack1256> you can decompose the number with log and iterative division
21:31:24 <slack1256> I don't think it will much faster though
21:33:24 <SrPx> Yes, that is what I meant :) I will submit it this way, thanks!
21:33:49 <Cale> SrPx: GHC only does one sort of CSE so far as I'm aware, and that's when nested case expressions have the same scrutinee.
21:34:39 <SrPx> Then it is unexpected that my manual CSE didn't affect the performance since 2 shows on that loop is probably much slower than 1.
21:35:08 <Axman6> well, perhaps not, show is probably quite cheap if it's or Ints
21:35:22 <Axman6> it'll just call a C routine that takes care of it
21:35:55 <SrPx> Fair enough...
21:35:59 <Axman6> but comput9ing 10^n all the time should be avoided if possible
21:38:01 <erisco> how do you define a function in C and call it from Haskell? I have looked at every FFI article on the first page of Google and still no luck
21:38:19 <erisco> I presume I need to write my C function and compile a .o, okay fine
21:38:37 <erisco> I cannot get ghc to link with it though, it never finds the symbol
21:38:48 <ryantrinkle> erisco: what's the ghc command line you're using?
21:38:55 <erisco> I have tried numerous ones
21:39:03 <Axman6> well shopw examples
21:39:12 <erisco> some articles suggest just  ghc TestFFI.hs  will work
21:39:27 <erisco> others also have the .o on them   ghc TestFFI.hs Algorithms.o
21:39:39 <erisco> some write a make file for whatever reason
21:40:07 <ryantrinkle> "ghc TestFFI.hs Algorithms.o" looks right to me
21:40:12 <ryantrinkle> what error do you get with that one?
21:40:42 <erisco> ld: symbol(s) not found for architecture x86_64
21:41:06 <erisco> if I pick a function such as sin then it works fine
21:41:08 <Axman6> and how did you compile the .o file?
21:41:26 <erisco> gcc -c Algorithms.cpp -o Algorithms.o
21:41:35 <hiptobecubic> aha
21:41:52 <ryantrinkle> erisco: symbols from c++ are generally "mangled" to add type info
21:41:56 <hiptobecubic> C and C++ are not the same at all
21:42:05 <ryantrinkle> do you have 'extern "C"' in front of your function?
21:42:21 <erisco> ryantrinkle no I had  __cdecl extern
21:42:21 <Axman6> yeah, C++ is totally fucked. you need to write C wrappers around the C++ code to make it work usually
21:42:29 <erisco> but maybe C++ needs even more magic tokens to please it
21:43:11 <ryantrinkle> erisco: yes, try adding extern "C"; also, you can use 'nm' to check what symbols are present in the .o file you're generating
21:43:34 <erisco> heh interesting
21:43:54 <erisco> well with  extern "C"  and compiling with    ghc TestFFI.hs Algorithms.cpp    it appears to work
21:44:28 <ryantrinkle> erisco: cool :)
21:44:51 <erisco> ryantrinkle thanks
21:45:04 <ryantrinkle> no problem
21:47:25 <deezn> Guys.. question: what is going on with the ::: here: data List a = Nil | a ::: List a
21:47:42 <johnw> somebody is making an operator-named constructor
21:48:04 <erisco> can I marshall an MVector to C?
21:48:16 <deezn> But wht isnt it data List a = Nil | ::: a List a
21:48:19 <erisco> bottom of the page here just does  http://hackage.haskell.org/package/vector-0.10.12.2/docs/Data-Vector-Storable.html   Vector it looks like
21:48:20 <johnw> you can marshall pretty much anything to C
21:48:40 <johnw> well, using "safe" imports, which is the default
21:48:47 <johnw> unsafe can't marshall across function references
21:48:56 <johnw> (well, it can, you just can't call them)
21:49:07 <erisco> derp there is a .Mutable module on it
21:50:32 <deezn> johnw : But wht isnt it data List a = Nil | ::: a List a
21:50:45 <johnw> operators go between things
21:50:51 <Axman6> deezn: constructors can be infix if they start with :
21:51:07 <deezn> Axman6.. and the light goes on!
21:51:17 <Axman6> so you can define data Stream a = a :> Stream a, for example
21:51:17 <deezn> Jesus.. makes sense now
21:51:21 <Axman6> =)
21:51:50 <sagittarian> if i have two definitions of a function using pattern matching and then a where clause, the where clause relates only to the last definition as far as I can tell
21:52:19 <sagittarian> is there any other way around that, other than making the definitions in the where clause module-global?
21:52:35 <jle`> sagittarian: you can use a case statement instead
21:52:56 <sagittarian> that's the only other way to do it?
21:52:57 <jle`> instead of fmap f (Just x) = ..., fmap f Nothing = ..., you can use fmap f m = case m of Just x -> ..., etc.
21:53:07 <jle`> and then your where bindings will be seen by all branches
21:53:18 <deezn> Axman6 > why doesnt his work then? data Tree a = Leaf |  a :Branch Int 
21:53:36 <sagittarian> are there any generally accepted style conventions regarding stuff like this?
21:53:41 <jle`> deezn: operators can only have symbols
21:53:44 <jle`> no letters
21:53:50 <deezn> ok
21:53:52 <slack1256> sagittarian: case statement and pattern matching are equivalent, the latter is just sugar for the former
21:54:00 <jle`> +&*^%*#$#* is an operator, but &%%#+$a* is not
21:54:06 <deezn> got you.. 
21:54:48 <johnw> you can use a lot of Unicode, though, if you want to
21:54:53 <erisco> yay a seg fault!
21:55:08 <pacak> :t (+&*^%*#$#*)
21:55:09 <lambdabot> Not in scope: â+&*^%*#$#*â
21:55:14 <erisco> okay, so if the C function returns void, is that IO ()  in Haskell?
21:55:19 <johnw> yes
21:55:21 <ryantrinkle> erisco: yep
21:55:25 <deezn> wait john said âoperator named constructorâ .. ?
21:55:28 <johnw> hiya ryantrinkle!
21:55:46 <ryantrinkle> johnw: hey!
21:55:51 <johnw> a value constructor that has an operator for its name
21:56:07 <jle`> deezn: btw, you can do data List a = Nil | (:::) a (List a), too
21:56:11 <erisco> maybe the problem is my C function has a   int array[]   parameter but from Haskell I am saying this is   Ptr CInt
21:56:18 <jle`> just like x + y is the same as (+) x y
21:56:33 <deezn> Yeah so âoperators can only have symbolsâ but it is not an operator it is a constructor that looks like an operator..
21:56:59 <johnw> int array[] is a Ptr Cint
21:57:15 <erisco> ah I am missing a parameter lol
21:57:18 <erisco> that might do it
21:57:27 <ronh-> infix constructors have special names, they have to start with :
21:57:33 <SrPx> Btw, before I submit, let me ask you, why is this allocating so much memory? http://lpaste.net/132200 the function is tail recursive, show is a light C ffi, and the remaining operations are asm so... what is allocating stuff there?
21:57:36 <jle`> deezn: it's an operator...an operator that is a constructor
21:57:42 <ryantrinkle> deezn: the "operator/symbol" distinction is a *syntactic* distinction
21:57:57 <jle`> just like `head` is a non-operator identifier that is a function
21:58:04 <jle`> and Just is a non-operator identifier that is a constructor
21:58:05 <benbangert> SrPx: because haskell allocates crazy amounts of memory before considering GC, is what I've found thus far
21:58:12 <ryantrinkle> deezn: whether something's a constructor or not is orthogonal to that
21:58:12 <deezn> ok.
21:58:34 <deezn> haskell the tricks just keep on coming.
21:58:35 <erisco> I just need  Int -> CInt
21:58:39 <jle`> "head", "Just"...one is a function, one is a constructor
21:58:41 <SrPx> No, but, I mean, what on this program is causing allocation? This program doesn't require any alloc at all, it seems at least.
21:58:46 <ryantrinkle> deezn: symbols that start with a capital letter are for constructors; operators that start with : are for constructors
21:58:49 <jle`> (+), (:::), same thing
21:58:56 <jle`> one is a function, one is a constructor
21:59:02 <jle`> they're both considered operators, though
21:59:02 <johnw> SrPx: thunks?
21:59:03 <ryantrinkle> (does anyone know if there are other characters that can start a constructor symbol?)
21:59:05 <ronh-> SrPx too sleepy to dive into that.. but don't you also need some seqs in there to ensure thunks aren't allocated?
21:59:21 <SrPx> ronh-: dunno :( let me think about that
21:59:24 <jle`> operators that are constructors have to start with :
21:59:24 <johnw> SrPx: make wanderer's argument be "!n"
21:59:33 <johnw> oh, no
21:59:36 <opqdonut> SrPx: are you compiling with -O2?
21:59:41 <SrPx> yep
21:59:46 <johnw> make go's arguments be "!p !x !y"
21:59:58 <SrPx> have done that already :)
22:00:06 <opqdonut> but show does allocate
22:00:08 <opqdonut> strings
22:00:08 <jle`> honestly i remember it feeling a bit ad-hoc at first, but after a month or two it seems natural now
22:00:16 <johnw> yeah, maybe it's the strings
22:00:47 <opqdonut> pop the show == reverse test into it's own function and it'll show up in the profile
22:00:50 <opqdonut> I guarantee it
22:01:00 <opqdonut> you can also run by-type heap profiling
22:01:01 <SrPx> yea, ir is probably reverse/show... okay
22:01:13 <opqdonut> see https://downloads.haskell.org/~ghc/6.12.2/docs/html/users_guide/prof-heap.html
22:01:27 <opqdonut> you're running it with some pretty big numbers?
22:01:44 <opqdonut> yep
22:01:49 <SrPx> 7 is some pretty big number on this case, it scans the whole cartesian plane of integers from 0 to 10^7
22:02:26 <SrPx> I'll try to make a non-allocating way to do the revese thing, brb
22:02:26 <erisco> :t fromIntegral
22:02:27 <lambdabot> (Integral a, Num b) => a -> b
22:02:31 <erisco> wonderful
22:02:48 <erisco> great! no seg fault! it worked!
22:03:10 <deezn> where is the best intro to type families online?
22:03:19 <opqdonut> SrPx: also, number of bytes allocated isn't that important. you should look at the maximum resident size and the GC overhead. I think +RTS -s will tell you both
22:03:20 <deezn> (best meaning kind to the beginner)
22:03:42 <opqdonut> SrPx: short-lived allocations are actually pretty efficient
22:04:08 <deezn> is a type family just a function tover the types of a GADTs?
22:04:16 <athan> Hey all, does anyone have an opinion on this? http://www.reddit.com/r/haskell/comments/359br3/can_we_make_sum_and_product_foldable
22:04:21 <SrPx> but won't cleaning all allocation put my program in another level? since it cuts the gc entirely 
22:04:24 * hackagebot base-orphans 0.3.1 - Backwards-compatible orphan instances for base  http://hackage.haskell.org/package/base-orphans-0.3.1 (ryanglscott)
22:04:29 <athan> deezn: Technically any type
22:04:45 <athan> but it's really only useful for DataKinds / types without term inhabitants
22:04:50 <athan> (in my opinion :P)
22:04:51 <slack1256> type level functions. Take a type as argument and return a type as result
22:05:45 <deezn> ok ,â¦ finally i might be making some progres on the GADTs.. 
22:06:09 <opqdonut> SrPx: no, gc might only be taking around 1% of execution
22:06:26 <SrPx> ah I see what you mean
22:06:49 <athan> deezn: GADTs are sweet, data constructors are basically just values instead of the normal "chunking" / bijective system of ADTs
22:07:06 <SrPx> But 7kkk bytes of allocation / s kinda coincides to the memory bandwidth
22:07:12 <SrPx> Independent of the gc
22:07:32 <athan> but the amazing part is that the values actually type coerce correctly, so you can embed constraints, do crazy type functions in your phantoms, whatever you want and the types won't be ambiguous
22:07:56 <opqdonut> SrPx: I ran it with -s and get: 1.6% GC time, 44,416 bytes maximum residency
22:08:19 <opqdonut> which fits easily in any cache
22:09:04 <Denommus`> GADTs were pretty intuitive to me 
22:09:18 <opqdonut> but if you get it non-allocating I'll be interested to hear the difference in runtime
22:09:26 <SrPx> but my question is, even taking account the cache, don't 7gb of allocations take some time?
22:11:52 <opqdonut> well allocations are just a proxy for string operations. if you can eliminate them and just use arithmetic, yeah it will be faster
22:12:43 <m_ryan> hi my question is about yesod - how do i convert Single function on a rawSql to JSON format.
22:14:11 <athan> @hoogle Data.Aeson.Encode - m_ryan
22:14:12 <lambdabot> Parse error:
22:14:12 <lambdabot>   Data.Aeson.Encode - m_ryan
22:14:12 <lambdabot>        ^
22:14:15 <athan> erm
22:14:37 <jle`> helpful error message
22:14:52 <m_ryan> athan: new to yesod can you provide me some snippet.
22:14:59 <jle`> i'm sorry neil
22:14:59 <athan> https://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson-Encode.html#v:encode
22:15:23 <athan> m_ryan: You first!
22:18:14 <m_ryan> athan: i will paste some code in lpaste
22:18:17 <athan> the snippet destroyer - wreaking havoc to industry, slipping in slight typos you can never find
22:18:30 <athan> >:D
22:21:07 <m_ryan> ahtan: here it is http://lpaste.net/132203
22:24:02 <kidto> I'm going through LYAH, and i've gotten to the chapter on applicative functors, and I just wanted to ask a question about ther terminology the author uses. They say that thinking of functors as boxes is a weak analogy, and they should be thought of as contexts instead. What is meant by this?
22:24:04 <erisco> has anyone else noticed how absurdly difficult it is to use Data.Vector
22:24:20 <erisco> especially once you try to use Data.Vector.Generic
22:24:20 <kidto> erisco: I know that every time I'm in here someone is asking about it :(
22:25:42 <jle`> erisco: what's wrong with Data.Vector? ;_;
22:25:45 <kidto> And secondly is this an accurate metaphor? applicative functors is to non-deterministic values what mapping is to deterministic values?
22:26:00 <jle`> kidto: a lot of Functors aren't "boxes", if that's what you are asking
22:26:17 <erisco> jle` there is boxed, unboxed, mutable, immutable, storable and nonstorable, so there are 8 different vectors
22:26:39 <erisco> so they have Data.Vector.Generic so you might not have to rewrite your functions 8 times
22:26:46 <erisco> but trying to use it is so obtuse
22:26:50 <m_ryan> athan: here it is http://lpaste.net/132203
22:27:08 <athan> m_ryan: Ooop, sorry I didn't see that earlier
22:27:16 <erisco> for instance, I am just trying to generate a mutable vector of random values
22:27:31 <erisco> I managed to generate an immutable vector of random values, so I should be able to "thaw" it
22:27:38 <erisco> but trying to do so gives me an ambiguous type error
22:27:52 <jle`> it's probably the same thing that happens when you use `read`, right?
22:27:53 <erisco> nothing obvious works
22:27:55 <athan> jle`: What's a good example of a non-box-like functor?
22:27:57 <jle`> you have to specify what type oyu want
22:28:07 <ronh-> athan IO :)
22:28:09 <jle`> athan: a function from Int, maybe?
22:28:12 <athan> :x
22:28:25 <athan> jle`: idk, that's still kindof a box
22:28:34 <athan> ronh-: Well, it's more like not a comonad!
22:28:36 <jle`> it is, if you redefine the word "box" to fit exactly what you want to mean
22:28:38 <jle`> :)
22:28:46 <kidto> Shazam
22:28:47 <athan> :E
22:29:03 <kidto> Which is why I asked about contexts
22:29:07 <kidto> Let me go fish out the quote
22:29:21 <kidto> "A word of advice. Many times the box analogy is used to help you get some intuition for how functors work, and later, we'll probably use the same analogy for applicative functors and monads. It's an okay analogy that helps people understand functors at first, just don't take it too literally, because for some functors the box analogy has to be str
22:29:22 <kidto> etched really thin to still hold some truth. A more correct term for what a functor is would be computational context. The context might be that the computation can have a value or it might have failed (Maybe and Either a) or that there might be more values (lists), stuff like that."
22:29:25 <athan> m_ryan: So what are you trying to do?
22:29:45 <johnw> kidto: for example, consider the Const r a functor
22:29:52 <johnw> it's most certainly not a box for anything
22:29:57 <johnw> but it carries information
22:30:13 <johnw> and I don't just mean information in the form of bits in memory
22:30:13 <erisco> jle` but I don't have an inkling what the actual problem is
22:30:26 <erisco> my context already looks like this  Vector v a, PrimMonad m, MonadRandom m, Random a, Num a, Functor m
22:30:28 <athan> johnw: Ahh!
22:30:33 <m_ryan> athan: i want my handler to return a json format but don't know how to do it..
22:30:37 <erisco> and a dozen things are called Vector, and MVector
22:30:38 <jle`> erisco: yeah, they're all type variables
22:30:41 <johnw> when he says "computational context", he means there's a difference between 'f a' and 'a', and that difference in the meaning of the context
22:30:45 <erisco> so good luck keeping in your head what Vector is
22:30:48 <jle`> that's like saying foo :: Read a => a; foo = read "hello"
22:30:48 <m_ryan> athan: based on my rawSql query
22:30:50 <athan> m_ryan: Read that document, dawg
22:30:56 <athan> Aeson is badass
22:31:00 <johnw> s/in/is
22:31:01 <athan> you just gotta learn it :\
22:31:01 <kidto> How is Const r a Functor? I thought functor types had to have kind * -> *
22:31:03 <jle`> something more useful might be foo :: Int; foo = read "1"
22:31:14 <johnw> kidto: sorry, you're spot on; I meant Const r
22:31:15 <jle`> johnw: this one's a clever one :)
22:31:31 <erisco> jle` the point is it is incredibly complicated, and errors do not make any sense
22:31:47 <erisco> Could not deduce (Vector.Mutable v0 ~ Vector.Mutable v)
22:32:00 <kidto> johnw: I think that make sense
22:32:12 <athan> johnw: So it's a functor in the sense that fmap is a no-op?
22:32:26 <athan> but it's still a functor
22:32:38 <johnw> it's a functor in the sense that it maps a type and provides a way to map functions on that type that is natural
22:32:46 <jle`> erisco: can you post what you're trying to do?
22:32:52 <jle`> and a lot of times making things concrete types might help a lot
22:33:01 <jle`> there isn't much point in keeping things generic if you aren't ever going to use it
22:33:08 <jle`> use the polymorphism
22:33:12 <jle`> and that usually cuts down a lot of errors
22:33:32 <m_ryan> athan: do you have any suggestion? for better coding and result
22:33:35 <athan> johnw: sweet
22:33:53 <kidto> Is it safe to think of <*> and . as being closely related, or will that screw me up?
22:34:06 <athan> m_ryan: Well honestly your code is pretty hairy, but getting better at maintaining clarity will take time
22:34:15 <johnw> kidto: they are distantly related :)
22:34:19 <jle`> i can't comment too much on the statement about if the `vector` package is excessively complex or difficult to use or unreasonable with errors.  i can really only offer meaningless opinion with anecdotes :)
22:34:25 <johnw> kidto: but the nature of that relationship wouldn't be edifying just now
22:34:29 <athan> I think you'll just need more practice with that. Definitely get used to making your own cabal packages, m_ryan
22:34:38 <m_ryan> athan: yeah i know.. sorry 
22:34:39 <kidto> Ok so think of them as being different for now?
22:34:40 <athan> That's how you'll learn to patch things together, but keep them isolated
22:34:41 <ronh->  isn't <*> more related to $
22:34:42 <johnw> yes, do
22:34:49 <athan> No worries m_ryan, you're new
22:34:51 <jle`> kidto: (<*>) is actaully more closely related to ($).
22:34:55 <athan> I mean, nobody here was ever new, ever
22:34:59 <johnw> <*> applies a "function with context" to an "argument with context"
22:35:06 <athan> so I mean, you're basically undeserving permanently
22:35:08 <athan> but it's cool
22:35:12 <jle`> ($) lets you take an (a -> b) and an `a` and turning it into an `b`
22:35:26 <jle`> <*> lets you take an `f (a -> b)` and an `f a` and lets you turn it into an `f b`
22:35:37 <kidto> ah ok, cool
22:35:50 <athan> m_ryan: The cool thing about aeson is how generic it is
22:36:02 <kidto> It seems like <$> should have been reserved for that operation then. >_<
22:36:04 <jle`> fmap lets you take an `(a -> b)` and an `f a` and turn it into a `f b`
22:36:07 <m_ryan> i will read about it.. :)
22:36:10 <jle`> kidto: yeah, a lot of people feel that way too
22:36:11 <athan> if you have a data type that's an instance of ToJSON, you can turn it into Json text with `encode` :)
22:36:12 <johnw> kidto: the Idris language did just that
22:36:15 <m_ryan> i will read about it.. :) thanks athan
22:36:25 <athan> no worries, good luck!!
22:36:32 <jle`> <$> sort of is extending $ in a bit of a different way.  it's a bit of a "halfway <*>"
22:36:38 <jle`> ($) :: (a -> b) -> a -> b
22:36:45 <kidto> because it lifts functions?
22:36:45 <jle`> (<$>) :: (a -> b) -> f a -> f b
22:36:52 <jle`> (<*>) :: f (a -> b) -> f a -> f b
22:37:06 <kidto> I'm getting my brain wrinkled so hard by fp
22:37:10 <jle`> you can sort of see that it adds an f only to the right side
22:37:15 <jle`> but <*> adds an f to both sides
22:37:53 <athan> it would be cool if operator precedence was something syntactical we could tweak with
22:37:57 <kidto> Alright thanks all. I'm gonna go read about Monads
22:38:01 <kidto> athan: can't you?
22:38:04 <athan> then function application ~ ($)
22:38:11 <erisco> jle` there is the good bits cut out http://lpaste.net/132205
22:38:13 <athan> kidto: Well, you can always mess with fixity
22:38:22 <athan> but you can't do it on a custom per-expression basis
22:38:29 <kidto> can you mess with the fixity of the built in operators?
22:38:32 <athan> I could see only a graphical editor to make use of it, though
22:38:33 <kidto> ah
22:38:38 <jle`> erisco: what is the error?
22:38:44 <athan> something like using colors to represent the nesting of expressions
22:38:46 <Axman6> deezn: did you get ans answer for "why doesnt his work then? data Tree a = Leaf |  a :Branch Int"?
22:39:03 <athan> (i dunno)
22:39:08 <kidto> That's would be super helpful for learning precedence
22:39:18 <erisco> jle` I edited it
22:39:21 <kidto> sometimes composition kung fu drives me insane
22:39:45 <athan> kidto: It's the best
22:39:51 <kidto> I get the feeling that a lot of good FP people are basically just OCD
22:40:10 <kidto> which is cool
22:40:12 <athan> define ocd
22:40:36 <kidto> there's a good quote in LYAH where the non point-free definition is freaking the author out
22:40:45 <kidto> and they have to rewrite it in point free :)
22:40:57 <athan> hahaha
22:41:10 <kidto> it takes like an extra half a page
22:41:23 <erisco> jle` I have seen this before where a return type is not determined by the input type, but I don't see where that is happening
22:43:32 <kidto> I have another question, and maybe I'm jumping the gun here, but is there an equivalent of (<-) for Maybe, Either, etc?
22:43:48 <johnw> <- works for Maybe and Either
22:43:52 <kidto> oh dang
22:43:57 <johnw> any Monad
22:44:23 <johnw> but not Const c!  because that can't be a Monad
22:44:25 * hackagebot sequent-core 0.4 - Alternative Core language for GHC plugins  http://hackage.haskell.org/package/sequent-core-0.4 (lukemaurer)
22:44:38 <johnw> figuring out why is a good way to build insight into what monads mean as "contexts"
22:44:45 <kidto> k
22:45:07 <jle`> erisco: does the error go away when you plug in concrete types for v, a, f?
22:45:29 <erisco> jle` I don't know what concrete types to plugin really
22:45:35 <erisco> it is such a PITA because all the names collide
22:45:36 <johnw> hint: the easiest way to approach is it to try to define this function:  joinConst :: Const c (Const c a) -> Const c a
22:45:39 <jle`> a could be Double
22:46:19 <jle`> m can be IO
22:46:53 <kidto> johnw: I'm going to copy paste that for after I read the Monad chapter
22:46:54 <jle`> v can be any concrete VEctor type
22:47:23 <erisco> well I presume it needs to be a mutable one
22:47:46 <erisco> no wait, immutable
22:47:54 <jle`> it should be an immutable one
22:47:57 <jle`> sorry
22:47:59 <erisco> it is a type family to convert immutable types to the mutable equivalent
22:48:04 <jle`> mhm
22:48:44 <jle`> to be honest i've never used Data.Vector.Generic
22:48:59 <jle`> i've always used specific types
22:49:01 <johnw> i think only library writers would care about DVG
22:50:43 <erisco> ugh I dunno man
22:50:47 <erisco> more errors just keep creeping up
22:50:48 <erisco> this sucks
22:51:01 <johnw> erisco: why do you want vectors at all?
22:51:45 <jle`> you probaably can do what you need to do without Data.Vector.Generic...extra polymorphism when you're just learning the concrete types is somewhat of a tall order
22:51:58 <erisco> johnw I am increasingly wondering why I want Haskell at all if it is this painful for vectors
22:52:02 <jle`> that's like teaching someone how to use Monad by only having them write functions polymorphic over all monads
22:52:17 <johnw> first off, I wouldn't use Generic
22:52:22 <erisco> jle` well I was just using the unbox stuff explicitly
22:52:24 <johnw> second, I wouldn't use Mutable
22:52:25 <jle`> or worse teaching someone how to use Maybe by only having them write Monad m => ...
22:52:37 <erisco> but then I wanted to FFI to C and Storable is somehow different than Unbox
22:52:39 <jle`> s/worse/more accurately
22:52:44 <johnw> third, I wouldn't use vectors at all
22:52:55 <johnw> a function Int -> a is a great stand-in for a vector
22:53:22 <erisco> so I could copy/paste my code
22:53:25 <johnw> do tha
22:53:26 <johnw> t
22:53:28 <erisco> and change from Unbox to Storable
22:53:55 <johnw> erisco: what are you trying to do?
22:54:11 <erisco> johnw you're trying to steer me away from vectors I feel, which is not something I am interested in
22:54:21 <johnw> ok, let me ste pbcak
22:54:24 <johnw> what are you trying to do?
22:54:31 <erisco> I am trying to use vectors
22:54:35 <johnw> what is your problem
22:54:51 <erisco> complicated type errors due to Data.Vector.Generic, most specifically
22:55:03 <johnw> no, I mean the problem that made you reach for vectors as the solution
22:55:58 <erisco> I am looking at benchmark differences between vector and mutable vector (in place) algorithms and other approaches such as lists or intmap
22:56:18 <erisco> at differences between sorting algorithms such as insertion sort and quick sort
22:56:26 <johnw> for a class?
22:56:29 <erisco> no
22:57:17 <erisco> I am just getting annoyed at all the hoops I have to jump through to get something which is so trivial anywhere else running
22:57:20 <johnw> so, it sounds like you've created a ball of complexity for yourself, and the problem is you're finding it complex.  Why not do something else, and come back to this when it wouldn't be a chore?
22:57:30 <erisco> but whatever, I'll just have to look at the Generic module more carefully tomorrow
22:57:36 <gtsteel> Does anyone know what the difference between .a and _p.a libraries are?
22:57:44 <johnw> and why would you ever need the Generic module for performance testing?
22:57:56 <erisco> because I already have stuff written that uses the Unbox vectors
22:57:57 <johnw> gtsteel: I believe _p indicates profiling
22:58:14 <erisco> and now suddenly I need Storable for anything over the FFI
22:58:23 <kidto> (what's ffi?)
22:58:23 <erisco> so I thought "okay fine, I'll try this Generic thing"
22:58:40 <kidto> nm wikipedia's got me
22:58:55 <erisco> I converted some stuff over but am getting hung up on weird type errors now
22:59:19 <gtsteel> thanks, I was wondering why there was a third copy of every library (besides the regular .a and the .so)
22:59:26 * hackagebot conceit 0.3.0.0 - Concurrent actions that may fail  http://hackage.haskell.org/package/conceit-0.3.0.0 (DanielDiazCarrete)
23:01:15 <erisco> actually what does this declaration even mean
23:01:16 <erisco> class MVector (Mutable v) a => Vector v a where
23:01:46 <erisco> oh
23:01:55 <erisco> class (MVector (Mutable v) a) => Vector v a where
23:02:20 <jle`> erisco: btw you're missing the arguments in the type signature for randomMVector
23:02:38 <erisco> jle` yeah I noticed
23:03:22 <erisco> I tried picking IO and the storable vector but, alas, just other type errors, so I'll have to give it a better look over tomorrow and try again
23:03:41 <erisco> so, some crude results today
23:04:36 <erisco> the insertion sort I wrote on an immutable vector in Haskell was on par with list sort (convert vector to list, then sort, then back to vector) at 25 elements using reverse ordered data (worse case)
23:04:42 <erisco> and on random data at 1000 elements
23:05:05 <erisco> taking a look now to see if a version written in C fares any better
23:05:30 <erisco> will try other things too... just trying to get the pieces together to even build the benchmarks
23:05:41 <jle`> erisco: managed to get it to compile with scoped type variables
23:05:44 <kidto> Why is bind backwards!?
23:05:57 <quchen2> It's not.
23:06:01 <jle`> to give a type signature to the call of randomVector
23:06:17 <jle`> (randomVector n min max :: m (v a))
23:06:28 <kidto> > :info (>>=)
23:06:28 <quchen2> Flipped bind, (=<<), is also not backwards.
23:06:29 <lambdabot>  <hint>:1:1: parse error on input â:â
23:06:37 <kidto> oh can't do that
23:06:39 <erisco> jle` funny I had that turned on already to solve another type error with data.vector oO
23:07:14 <jle`> heh
23:07:34 <erisco> randomMVector n min max = (randomVector n min max :: m (v a)) >>= Vector.thaw    right?
23:07:41 <jle`> yeah
23:07:41 <erisco> why no workie for me
23:07:48 <jle`> what is error?
23:07:50 <kidto> quchen2: my gut reaction is that it should be \x -> return (x * 10) >>= Just 9
23:07:52 <erisco> same as before
23:07:54 <jle`> you need to scope the type variables
23:08:02 <kidto> not the other way around
23:08:03 <erisco> oh right
23:08:03 <jle`> randomMVector :: forall m v a. ... blah blah
23:08:27 <kidto> to mimic function application, which is what it feels like bind is trying to be like..?
23:08:30 <quchen2> kidto: That parses as \x -> (rest) regardless of how >>= is defined.
23:08:41 <kidto> oh
23:09:02 <kidto> Thanks, I forget that often
23:09:19 <kidto> But what I mean is >>= feels like it should copy function application syntax?
23:09:23 <quchen2> >>= can be seen as some form of function application, but so can flip ($).
23:09:23 <kidto> f x
23:09:25 <kidto> rather than x f
23:09:47 <jle`> erisco: fwiw i tried it wiht specialied type signatures and it compiled with no problems
23:09:49 <kadoban> Use =<< if you like that order better.
23:10:02 <jle`> erisco: randomVector :: Int -> Double -> Double -> IO (U.Vector Double)
23:10:16 <jle`> erisco: randomMVector :: Int -> Double -> Double -> IO (U.MVector (PrimState IO) Double)
23:10:32 <kidto> The question is: is it just preference? Or is there a piece that I'm missing that makes >>= make more sense?
23:10:32 <jle`> no need for any extra type annotations or nothin'
23:10:32 <SrPx> opqdonut: fyi and others, removing 90% of the allocation made the program 2.5x faster http://lpaste.net/132210
23:10:56 <jle`> kidto: putting it in the order that it does helps you reason more with effects
23:11:10 <SrPx> if anyone has an idea on how to improve even further let me know
23:11:12 <jle`> `x >>= f` for something like IO means that the effects of x come before any effects that might come from f
23:11:12 <erisco> jle` hm wish I could get the same result as you
23:11:22 <opqdonut> SrPx: nice
23:11:44 <jle`> erisco: does it work with that type signature?  import qualified Data.Vector.Unboxed as U, import qualified Data.Vector.Unboxed.Mutable as U
23:11:55 <jle`> kidto: also >>= looks a lot better with lambas
23:12:02 <kidto> :)
23:12:05 <jle`> mx >>= \x -> blah blah
23:12:12 <jle`> just looks so pretty
23:12:18 <jle`> compare to \x -> blah blah ... =<< m
23:12:20 <jle`> blech
23:12:26 <kidto> rather than (\x -> blah blah) <<= mx
23:12:29 <kidto> er
23:12:29 <jle`> mhm
23:12:31 <kidto> =<<?
23:12:34 <SrPx> I wonder if I really need all those floors and fromIntegers on the isPalindrome function, though. Seems like I'm missing some obvious operator (I just need to convert 30150 into 10000)
23:12:43 <jle`> yes
23:12:56 <SrPx> also, I was googling for fast mod 10 / div 10 using bitwise ops but found it too complicated so whatever
23:13:07 <kidto> I do not share your enthusiasm. :P
23:13:24 <jle`> SrPx: why are you using (**) ?
23:13:30 <opqdonut> SrPx: you could try a helper function for the 10000 thing, a quick recursion. logBase goes via floats so it might be slow
23:13:37 <opqdonut> SrPx: oh right, and ^ instead of **
23:13:39 <jle`> oh i see, you're loging
23:13:51 <SrPx> jle`: the program was still allocating a lot by using ^ ... when I changed to ** is that it became 2.5x faster
23:14:02 <jle`> that does make sense
23:14:18 <jle`> (**) is machine exponentiation and (^) is just x*x*x*x*x*x in haskell
23:14:21 <SrPx> I wonder how the heck ^ is implemented but it is bad
23:14:23 <erisco> jle` I'll just have to get some sleep first
23:14:25 <SrPx> I se
23:14:28 <SrPx> see*
23:14:29 <jle`> ^ is just iterated multiplcation
23:14:31 <erisco> I need to at least know why the problem is happening
23:14:34 <jle`> > x^4 :: Expr
23:14:36 <lambdabot>  x * x * (x * x)
23:14:39 <erisco> which I haven't a clue about
23:14:42 <opqdonut> jle`: I think it's at least iterated squaring
23:14:50 <pacak> > x ^100500 :: Expr
23:14:52 <lambdabot>  x * x * (x * x) * (x * x * (x * x)) * (x * x * (x * x) * (x * x * (x * x))) ...
23:15:00 <pacak> o_o
23:15:05 <jle`> erisco: the problem like the problem with Read except there's an extra bit of ambiguity because of type families
23:15:07 <SrPx> shouldn't be, seriously... go now and change it to ** with fromIntegral and floor
23:15:24 <SrPx> :: Expr? What
23:15:33 <jle`> erisco: so using concrete types helps, but also using explicit type signatures helps too, with scoped type variables
23:15:36 <opqdonut> SrPx: you could use a "where xy = x*y" in the wanderer definition -- probably not a big performance increase though
23:16:11 <opqdonut> SrPx: Expr is a neat trick, it's basically strings with a Num instance
23:16:25 <opqdonut> > map f [x,y,z] :: Expr
23:16:26 <lambdabot>      Couldn't match expected type âExprâ with actual type â[b0]â
23:16:26 <lambdabot>      In the expression: map f [x, y, z] :: Expr
23:16:31 <opqdonut> > map f [x,y,z] :: [Expr] --oops
23:16:33 <lambdabot>  [f x,f y,f z]
23:16:55 <kidto> oh cool
23:16:57 <ronh-> > foldr f d [a,b,c,d]
23:16:58 <lambdabot>  f a (f b (f c (f d d)))
23:17:00 <kidto> I didn't know you could do that
23:17:16 <johnw> kidto: that's implemented by a package called simple-reflect
23:17:22 <opqdonut> all of this works because lambdabot has definitions for f, g, x, y, z, a, b, c etc.
23:17:23 <Cale> @src (^)
23:17:23 <lambdabot> x ^ 0            =  1
23:17:23 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
23:17:23 <lambdabot>   where f _ 0 y = y
23:17:23 <lambdabot>         f x n y = g x n
23:17:23 <lambdabot>           where g x n | even n    = g (x*x) (n `quot` 2)
23:17:25 <lambdabot>                       | otherwise = f x (n-1) (x*y)
23:17:27 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
23:17:30 <lpaste> jle` pasted âerisco's vector woesâ at http://lpaste.net/132213
23:17:37 <johnw> it provides a type Expr that renders expressions textually
23:17:42 <opqdonut> definitions like: x = Expr "x"
23:17:48 <opqdonut> yeah, simple-reflect
23:17:56 <jle`> kidto: it also uses things like defining custom Num instances
23:17:59 <opqdonut> the code is pretty trivial, but it's surprisingly useful
23:18:03 <kidto> neat
23:18:10 <johnw> all so that we can look cool writing folds, basically
23:18:10 <SrPx> neat
23:18:26 <ronh-> > sum [1..5] :: Expr
23:18:27 <lambdabot>  0 + 1 + 2 + 3 + 4 + 5
23:18:31 <jle`> erisco: ^^ there is two fixes of your problem...one with scoped type variables, and one with getting rid of polymorphism
23:18:32 <kidto> johnw: haha
23:19:09 <SrPx> very cool, seriously, that should be advertised more. 
23:19:31 <erisco> jle` well hold on, you enabled AllowAmbiguousTypes
23:19:37 <jle`> ikr
23:19:42 <jle`> :D
23:19:50 <jle`> GHC told me too
23:20:28 <jle`> "To defer the ambiguity check to use sites, enable AllowAmbiguousTypes"
23:22:17 <jle`> in this postmodern world, I choose ambiguity
23:24:12 <Cale> The PrimMonad m, MonadRandom m constraints seem slightly questionable together
23:24:34 <Cale> There are few monads which will really satisfy both of those, particularly because there are not many monads which are instances of PrimMonad
23:25:28 <kidto> another laziness question: if you have a chain of binds working on Maybes, and one in the middle comes up as a Nothing, and you're only checking if the end result for the whole chain is Nothing, does evaluation stop?
23:25:59 <Cale> kidto: It stops, but this has nothing to do with lazy evaluation
23:26:13 <Cale> kidto: It stops because you never evaluate the body of an unapplied lambda
23:26:32 <Cale> (this is the same under strict evaluation)
23:27:19 <Cale> Oh, actually, I'm wrong, there might be a lifting instance of PrimMonad around
23:27:45 <Cale> It should at least be possible to write one
23:27:49 <kidto> Cale: Could you explain a little bit more? What do you mean by unapplied lambda? I haven't done and lambda calculus
23:28:13 <Cale> kidto: I mean, if you have something like (\x -> (5 * 5) + x)
23:28:16 <jle`> replace 'lambda' with 'function'
23:28:32 <Cale> It will never reduce this to (\x -> 25 + x), for example
23:28:46 <Cale> It'll always wait for it to be applied
23:28:54 <jle`> in haskell, a "lambda" is just a way to construct a function.  so sometimes we refer to functions as lambdas because we made them that way.  like some sort of synechdoche
23:29:03 <Cale> Like (\x -> (5 * 5) + x) 10 -> (5 * 5) + 10 -> 25 + 10 -> 35
23:29:08 <SrPx> Okay from 7gb to 700mb is great but why is my program still allocating that 700mb? I can't find it at all... anyone has any idea?
23:29:24 <Cale> jle`: No, I'm not actually referring to a function
23:29:27 * hackagebot hailgun 0.4.0.1 - Mailgun REST api interface for Haskell.  http://hackage.haskell.org/package/hailgun-0.4.0.1 (RobertMassaioli)
23:29:36 <Cale> I'm referring to a particular expression which denotes a function
23:30:17 <Cale> Evaluation is the process of rewriting expressions into normal forms of various sorts.
23:30:22 <jle`> oh, i see what you mean
23:30:26 <jle`> sorry :)  carry on ~
23:30:37 <Cale> Lambda expressions are almost always considered to be in normal form
23:30:47 <Cale> Regardless of whether or not their body is in normal form
23:31:10 <kidto> So why, in the case of the bind chain, is the lambda unapplied?
23:31:28 <deezn> what does: âVecâ of kind âNat -> * -> *â is not promotable
23:31:29 <deezn>     In the kind âVecâ
23:31:29 <deezn>     In the type signature for âheadVâ:
23:31:30 <Cale> There are notions of normal form for expressions which require the body of a lambda to be in normal form, but this isn't really relevant to most real-world implementations of programming languages
23:31:30 <deezn> mean?
23:31:44 <deezn> not promotable?
23:31:48 <Cale> kidto: because the right hand function argument to bind has not been applied to an argument
23:31:54 <Cale> kidto: So there's nothing to evaluate
23:31:57 <kidto> AHA
23:32:33 <kidto> So I asked the wrong question
23:32:36 <kidto> I think
23:32:53 <erisco> jle` it just loves telling me the v is ambiguous
23:33:02 <kidto> Suppose that they are applied, in the case of " ghci> return (0,0) >>= landLeft 1 >>= landRight 4 >>= landLeft (-1) >>= landRight (-2)  
23:33:02 <kidto> Nothing  "
23:33:11 <jle`> erisco: does that file not compile for you?
23:33:15 <jle`> it compiles on my machine...
23:33:15 <erisco> randomMVector 0 0 0 :: IO (Vector.Mutable SVector.Vector (PrimState IO) CInt)
23:33:22 <erisco> I just can't do it right it seems
23:33:25 <Cale> kidto: Consider  Nothing >>= (\x -> ...)
23:33:33 <jle`> erisco: why don't you apply out the type family
23:33:38 <Cale> kidto: It's impossible for the evaluation of (...) to proceed
23:33:45 <erisco> jle` meaning?
23:33:45 <kidto> Oooooh
23:33:50 <kidto> Got it, thanks Cale
23:33:51 <jle`> replace `Mutable S.Vector` with `S.MVector`
23:33:56 <SrPx> Is there any way for me to access the asm operations I can't find on prelude? Such as floating point floor, or integer power... so many of them
23:34:04 <jle`> IO (SVector.MVector (PrimState IO) CInt)
23:34:06 <erisco> jle` I tried that, same error
23:34:25 <Cale> kidto: Even if the evaluator were to try, it might get stuck if it ran into an occurrence of the variable x
23:34:25 <jle`> where are you using this?
23:34:27 <erisco> jle` I unapplied the type family hoping it would figure out the v
23:34:54 <erisco> jle` nowhere, I am just trying to get ghci to agree that is a good type
23:34:56 <Cale> kidto: and real-world lambda calculus evaluators (such as GHC) tend not to try
23:35:19 <jle`> are you using let foo = blah blah :: blah blah ?
23:35:33 <erisco> *Main> :t randomMVector 0 0 0 :: IO (Vector.Mutable SVector.Vector (PrimState IO) CInt)
23:35:44 <jle`> :set -XAmbiguousTypes ?
23:36:28 <jle`> allowambiguoustypes
23:36:50 <erisco> some flags have not been recognized
23:37:55 <jle`> oh, i see what the problem is
23:38:15 <jle`> you're asking for an S.MVector
23:38:40 <jle`> but it doesn't know that it "came from" an S.Vector
23:38:46 <Axman6> :t floor `asappliedTo` (pi :: Double) -- SrPx 
23:38:47 <lambdabot>     Not in scope: âasappliedToâ
23:38:48 <lambdabot>     Perhaps you meant âasAppliedToâ (line 154)
23:38:51 <jle`> so it doesn't know "what to thaw"
23:38:55 <Axman6> :t floor `asAppliedTo` (pi :: Double) -- SrPx 
23:38:56 <lambdabot> Integral b => Double -> b
23:39:01 <jle`> "what do i make, then thaw, to get an S.MVector?"
23:39:11 <jle`> what you want is for it to make an S.Vector and thaw it to get an S.MVector
23:39:24 <jle`> but it doesn't know what it make initially, to thaw to get your S.MVector
23:39:36 <Axman6> SrPx: what do you mean by integer power? there's three different power functions in Haskell btw
23:39:54 <erisco> jle` and why not
23:39:55 <Axman6> :t ((^),(^^),(**))
23:39:55 <lambdabot> (Floating a2, Fractional a1, Integral b, Integral b1, Num a) => (a -> b -> a, a1 -> b1 -> a1, a2 -> a2 -> a2)
23:40:01 <Axman6> hmm, bad idea
23:40:05 <erisco> jle` this is what the v parameter determines
23:40:36 <jle`> erisco: all it sees is IO (V.MVector (PrimState IO) CInt)
23:40:49 <jle`> it doesn't really know what 'v' was originally
23:40:55 <erisco> well that is unfortunate
23:40:58 <jle`> your type signature doesn't specify what the v is originally
23:41:05 <erisco> so the type family gets applied beforehand
23:41:08 <erisco> it never sees the v
23:41:09 <erisco> well darn
23:41:32 <jle`> hm. i wonder how this can be made to be useful
23:42:10 <jle`> well a superficial bandaidy fix would be to use a Proxy to pass in what original type you wanted
23:42:17 <erisco> jle` yeah
23:42:25 <erisco> but maybe there is a type family in the other direction
23:42:43 <erisco> the context is   Vector v a   what if I made this    Vector (f v) a    for some type family f
23:42:45 <SrPx> Axman6: I was not aware of ^^, interesting... but I mean the native (asm) pow operation (if I'm not mistaken there is one, no?)
23:43:03 <SrPx> Axman6: I don't understand what you tried to say with the floor thing ... but I gtg now :(
23:43:06 <SrPx> thank you all!
23:43:08 <erisco> and changed  Vector.Mutable v (PrimState m) a    to just    v (PrimState m) a
23:43:58 <jle`> i wonder if there's a way to declare injective type families
23:45:32 <Haskellfant> jle`: iirc there are some plans for that but atm there is no direct way to do that
23:46:16 <erisco> jle` tried adding  Vector.Mutable v ~ v'   to the context but it still thinks v is ambiguous
23:46:21 <johnw> jle`: you can have newtype families at least
23:46:24 <jle`> yeah the issue is the same
23:46:30 <erisco> so I guess it will not take the gamble that it is injective
23:46:52 <georgyy> what do you use for serialization? right now I am using Show/Read and I am not sure if that is considered a good practice
23:47:05 <johnw> georgyy: serialization to text?
23:47:14 <georgyy> yes
23:47:18 <johnw> show/read is fine
23:47:29 <johnw> if you want to go to binary with high efficiency, the 'binary' package is what you want
23:48:19 <jle`> erisco: you can also return *both* the mutable vector and the frozen immutable one
23:48:22 <jle`> in your randomMVector
23:48:55 <deezn> Guys:  data Nat = S Nat | Z
23:49:11 <deezn> wtf is Nat doing backon the rhs of the =?
23:49:11 <erisco> jle` I will try a type family in the other direction first
23:49:20 <deezn> Is it somehting recursive?
23:49:20 <johnw> it's a recursive type
23:49:34 <deezn> ok. just wanted to clarify. 
23:49:38 <deezn> thx
23:50:12 <deezn> And why doesnt it have some value?
23:50:34 <Haskellfant> deezn: basically this says that Nat is either 0 or it is the successor of some other natural number
23:51:00 <Haskellfant> e.g. 1 is the successor of 0, 2 is the successor of 1 so the successor of the successor of zero
23:51:02 <deezn> I know that.. but is it ever set to 0
23:51:15 <deezn> I cant see how or where it ever gets a value?
23:51:23 <Haskellfant> the base case is Z
23:51:40 <deezn> So you are supposed to count it based on how many times it is wrapped?
23:52:13 <deezn> (S (S (Z))) is just two?
23:52:13 <Haskellfant> yep
23:52:21 <Haskellfant> without the question mark yes
23:52:39 <deezn> Jesus. ok.
23:53:07 <deezn> Then with this: data Vec (n :: Nat) a where VNil  :: Vec Z a VCons :: a -> Vec n a -> Vec (S n) a
23:53:07 <jle`> erisco: works for me now
23:53:18 <jle`> erisco: if you have it return m (mutable vec, immutable vec)
23:53:57 <deezn> I dont get how I can have a function that takes this vector and returns the vector.. (it should be VNil or VCons)?
23:54:11 <deezn> I dont get how to declare it
23:55:30 <Moggle> question on indentation: if i'm doing a long expression with each line having an operator (doing attoparsec), how's the indentation supposed to work?
23:55:36 <Moggle> eg. something like
23:55:39 <Moggle> a <|>
23:55:41 <Moggle> b <|>
23:55:42 <Moggle> c
23:55:46 <Moggle> is this incorrectly indented?
23:56:31 <deezn> jle` can I hit you up with a q
23:56:33 <nak> is there a more concise way to write this lambda ? 
23:56:33 <nak> \x y -> if x < y then x else y
23:56:51 <glguy> min
23:57:01 <jle`> @src min
23:57:02 <lambdabot> min x y = if x <= y then x else y
23:57:10 <jle`> deezn: yeah sure :)  can't guaruntee i can answer it though
23:57:21 <deezn> ok. I will give it a crack
23:57:23 <jle`> min is slightly different
23:57:25 <jle`> but
23:57:28 <jle`> it's probably what you want ^_^
23:57:39 <nak> > min 1 2 3
23:57:41 <lambdabot>      Could not deduce (Num a0)
23:57:41 <lambdabot>      from the context (Num a, Num (a -> t), Ord (a -> t))
23:57:41 <lambdabot>        bound by the inferred type for âe_1123â:
23:57:44 <nak> > min 1 2
23:57:45 <lambdabot>  1
23:57:51 <nak> ok thx
23:57:54 <deezn> I have this data type:
23:57:54 <deezn> data Vec (n :: Nat) a where
23:57:55 <Moggle> nak: flip min in this case if you actually care about <= and <
23:57:55 <deezn>   VNil  :: Vec Z a
23:57:56 <deezn>   VCons :: a -> Vec n a -> Vec (S n) a
23:58:14 <Moggle> nak: if x < y can be x <= y, min is fine, otherwise you need to flip it.
23:58:19 <nak> foldl1 min [5,3,7,4,2,1,7,0]
23:58:22 <nak> > foldl1 min [5,3,7,4,2,1,7,0]
23:58:24 <lambdabot>  0
23:58:27 <nak> > foldl1 min [5,3,7,4,2,1,7]
23:58:28 <lambdabot>  1
23:58:31 <nak> sweet
23:58:37 <deezn> How do I declare a function that allows me to handle either type of Vec?
23:58:38 <jle`> @src minimum
23:58:38 <lambdabot> minimum [] = undefined
23:58:38 <lambdabot> minimum xs = foldl1 min xs
23:58:48 <jle`> deezn: you can just leave `n` as a type variable
23:59:00 <georgyy> Moggle: what do you mean?
23:59:03 <jle`> foo :: Vec n a -> Vec n a
23:59:10 <Moggle> georgyy: re the flipping or the indentation?
23:59:12 <deezn> that is not my code jle`
23:59:13 <erisco> jle` heh well
23:59:18 <georgyy> flipping
23:59:23 <Moggle> @src min
23:59:23 <lambdabot> min x y = if x <= y then x else y
23:59:29 <jle`> deezn: what sort of function are you talkin bout?
23:59:30 <Moggle> you see here, if x == y, then it does x
23:59:32 <deezn> yes that is what I have headV :: [(Vec n a)] -> (Vec n a)
23:59:33 <erisco> Immutable v ~ v', Vector.Mutable v ~ v'   did the trick evidently
23:59:41 <erisco> I had to write Immutable
23:59:42 <Moggle> but if he wants if x == y to do y, then min will not work properly
23:59:49 <Moggle> however, min with flipped arguments _will_ work
23:59:54 <jle`> erisco: ah, your own type family? nice :)
