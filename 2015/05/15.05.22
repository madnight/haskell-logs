00:08:53 <sopvop> is pattern matching on newtype constructor lazy?
00:09:46 <kandinski> hi, what's a good channel to just discuss very entry-level category theory?
00:10:06 <mauke[> sopvop: it's a no-op
00:10:16 <mauke[> newtype constructors don't exist at runtime
00:10:20 <kandinski> (not necessarily Haskell programming, I don't want to OT the channel)
00:11:50 <joneshf-laptop> kandinski, there's ##categorytheory
00:12:01 <kandinski> joneshf-laptop: thanks a lot
00:13:01 <joneshf-laptop> though it's been kind of quiet lately, or I've just not been paying attention
00:14:06 <jle`> kandinski: #haskell-blah also is often friendly to category theory questions
00:17:01 <kadoban> Lots of CT discussion seems to go on here as well, in practice, heh.
00:18:14 <kandinski> jle`: thanks a lot. I'm coming to CT from JavaScript libraries like Ramda, but then when I go to look at videos and documentation, people seem to use Haskell as notation, so it's difficult to get a footing. I don't have actual Haskell programming questions, though. But 
00:18:26 <kandinski> #haskell-blah sounds optimal.
00:18:36 <kandinski> cheers everyone.
00:18:46 <joneshf-laptop> kandinski, ramda eh?
00:19:52 <joneshf-laptop> what are my options for a graph library?
00:20:08 <kandinski> joneshf-laptop: have you heard about it?
00:20:15 <joneshf-laptop> data.graph doesn't do enough for me, and I dont have to have to roll my own on a bunch of stuff
00:20:24 <sopvop> mauke[: So foo (Newtype a) = is same as foo a =. Ok. How about !(Newtype a) ? Is it !a ? 
00:20:25 <joneshf-laptop> kandinski, yeah, I think what they're doing is great
00:21:16 <kandinski> joneshf-laptop: I just read about it two days ago, but it seems like it's the next step in the program of getting the JS community learning about functional programming
00:21:40 <kandinski> "function application is not enough, you need composition of point-free functions"
00:21:53 <kandinski> and that's as far as I go. Sorry for the OT.
00:22:56 <joneshf-laptop> kandinski, you should join the gitter chat, it's pretty active.
00:24:51 <kandinski> gitter chat for?
00:25:19 <mauke[> > let foo !(Identity x) = () in foo undefined
00:25:20 <lambdabot>  *Exception: Prelude.undefined
00:25:28 <mauke[> > let foo (Identity x) = () in foo undefined
00:25:30 <lambdabot>  ()
00:25:35 <kandinski> joneshf-laptop: ah, the gitter for ramda. I will, thanks.
00:25:36 <mauke[> sopvop: apparently
00:32:15 <srenatus> doctest, Data.DeriveTH and quickcheck. Will this work? ;)
00:36:46 <Myrl-chan> Ay
00:36:49 <Myrl-chan> Gaise? :>
00:37:02 <jle`> :>
00:37:30 <Myrl-chan> What happens if the arguemnt of proc does not exist?
00:37:49 <jle`> can you give an example?
00:38:59 <Myrl-chan> createProcess (proc "indasfasex" [])
00:39:12 <Myrl-chan> That should throw an exception or something, but it does not.
00:39:24 <Myrl-chan> By "should", I mean in other languages.
00:40:11 <kandinski> Hi, I'm learning about CT coming from JS, and I find that Haskell seems to be used for notation. I have a question to validate whether I understand what "where" does in an instance definition.
00:40:17 <kandinski> I see this:
00:40:22 <kandinski> instance Functor Container where
00:40:34 <kandinski>    fmap f (Container a) = Container (f a)
00:41:17 <kandinski> it seems to me that here "where" is defining a protocol. That is, it sets the behaviour of an external function "fmap" when applied to the Container type. Would that be correct?
00:41:55 <mauke[> in general, 'where' introduces a block of declarations
00:41:56 <nshepperd_> kandinski: 'where' is just punctuation to separate the instance head from the definitions of the functions for the instance
00:41:59 <nshepperd_> but yes
00:42:11 <mauke[> here it's attached to an instance definition, which is what you said
00:42:40 <kandinski> right, thanks
00:42:45 <td123> is there something like pygal for haskell? http://pygal.org/
00:42:48 <mauke[> class Functor f where { fmap :: (a -> b) -> f a -> f b }; instance Functor [] where { fmap = map }  -- dumb example
00:42:56 <td123> i basically want to easily create graphs from data points
00:43:16 <kandinski> thanks everyone
00:43:24 <td123> looking to use haskell for data analytics and looking for alternatives to some useful libraries i know
00:43:26 <mauke[> instance Functor Maybe where { fmap _ Nothing = Nothing; fmap f (Just x) = Just (f x) }
00:43:53 <Haskellfant> dmj`: afaik the chart library is the best plotting library we have (I might be wrong)
00:44:01 * hackagebot linearscan 0.5.0.0 - Linear scan register allocator, formally verified in Coq  http://hackage.haskell.org/package/linearscan-0.5.0.0 (JohnWiegley)
00:44:03 <Haskellfant> https://github.com/timbod7/haskell-chart
00:44:04 * hackagebot linearscan-hoopl 0.5.0.0 - Makes it easy to use the linearscan register allocator with Hoopl  http://hackage.haskell.org/package/linearscan-hoopl-0.5.0.0 (JohnWiegley)
00:44:29 <Myrl-chan> jle`: *
00:44:50 <jle`> i don't know what the proc function does :'(
00:45:17 <Myrl-chan> jle`: Ah.
00:45:56 <pavonia> Isn't that part of the arrow syntax?
00:46:50 <kandinski> mauke[: in your above Maybe definition, would Nothing be like an atom in Erlang?
00:47:58 <stanford_drone> Does anyone know C/C++, Computer Vision/Image Processing, Machine Learning, AI, linux systems programming, or electronics? I'm looking for a programmer to join my Startup. We're going to China (manufacturing is there) from July to November. We're a team of 4. We're building a flying computer. A drone that you can play games with and install apps on.
00:52:46 <kandinski> this example in a video I'm watching doesn't seem right: http://paste.ubuntu.com/11279911/
00:52:51 <mauke[> kandinski: I don't know erlang
00:53:15 <mauke[> kandinski: looks right to me, except functor should be Functor
00:53:55 <kandinski> mauke[: that was my typo
00:54:25 <kandinski> mauke[: I don't understand why the three variables a, x, y
00:54:31 <Myrl-chan> Haskell's being mean to me. ;-;
00:57:15 <kandinski> mauke[: shouldn't Either have two inputs in the constructor?
00:57:26 <kandinski> How can it be (Either a) instead of (Either a b)?
00:57:56 <Myrl-chan> Why is Haskell ont giving a file not found error when it should...
00:58:11 <mauke[> kandinski: Functor takes a type constructor of kind * -> *
00:58:21 <mauke[> kandinski: Either :: * -> * -> *
00:58:36 <mauke[> kandinski: so we use partial application: Either a :: * -> *
00:58:50 <kandinski> oh, so you're telling me that Either a is a partially applied Either
00:59:16 <merijn> kandinski: Right
00:59:26 <kandinski> and we now made (Either a) a Functor
00:59:38 <mauke[> instance Functor ((,) a) where { fmap f (x, y) = (x, f y) }
00:59:44 <jle`> see the type of fmap
00:59:46 <jle`> :t fmap
00:59:47 <mauke[> tuples, fmapping over the last component
00:59:49 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:59:54 <jle`> (Either e) fits in as 'f' there
00:59:55 <Myrl-chan> Everyone else's havingf problems with Haskell failing to find the executable, while I have problems with Haskell failing in failing to find the executable.
00:59:58 <jle`> Either doesn't really make sense at all
01:00:01 <merijn> kandinski: Yes and we then replace the 'f' in fmap's signature with "Either a" you get
01:00:05 <jle`> (a -> b) -> Either a -> Either b     --- makes no sense!
01:00:14 <mauke[> kandinski: yeah, it's saying that Either T is a functor for all types T
01:00:17 <jle`> (a -> b) -> Either e a -> Either e b       -- now it's making sense
01:00:25 <kandinski> and we can apply (fmap f) to any instance of (Either a)
01:00:26 <merijn> kandinski: "fmap :: (b -> c) -> (Either a) b -> (Either a) c"
01:00:38 <jle`> kandinski: you can apply it to any value of type Either e a
01:00:52 <jle`> "instance" here is different in meaning than instances in object oriented languages
01:01:09 <jle`> "instance" means a type that implements the interface specified by a typeclass
01:01:18 <jle`> but you apply `fmap f` to *values* of type Either e a
01:01:25 <jle`> or *values* of type [a]
01:01:28 <kandinski> jle`: thanks
01:01:38 <jle`> you cannot have any values of type (Either a)
01:01:47 <merijn> More specifically
01:01:57 <merijn> Values can never have type with a kind other than *
01:02:03 <merijn> :k Either
01:02:05 <lambdabot> * -> * -> *
01:02:07 <merijn> :k Either Int
01:02:08 <lambdabot> * -> *
01:02:20 <kandinski> well, (Either a) has the type * -> *, right?
01:02:22 <merijn> :k Either Int Char
01:02:24 <lambdabot> *
01:02:33 <jle`> it has the kind * -> *, so you can't have any values of type Either a
01:02:45 <merijn> kandinski: To be pedantic, the *type* "Either a" has *kind* * -> *
01:02:52 <kandinski> jle`: what's the difference between a kind and a type?
01:02:59 <makalu> on reddit, someone asked what has changed in Haskell in the last 15 years. Simon Marlow said the type of foldr. What was the type before?
01:03:00 <merijn> kandinski: Kinds are the "types of types"
01:03:06 <kandinski> merijn: I noticed jle using different aah
01:03:20 <jle`> makalu: (a -> b -> b) -> b -> [a] -> b, i think
01:03:22 <mauke[> makalu: (a -> b -> b) -> b -> [a] -> b
01:03:25 <merijn> kandinski: Values have types and types have kinds :)
01:03:46 <kandinski> and kinds have kinds?
01:03:55 <jle`> kinds have sorts
01:03:58 <merijn> kandinski: Kinda have sorts! But those you can't write in haskell :)
01:03:58 <kandinski> is it turtles all the way down from there?
01:04:07 <makalu> wait, I still have that type in 7.4. When did it change?
01:04:10 <jle`> sorts have snap, snaps have crackle, and pop
01:04:16 <merijn> kandinski: And if you go to other languages like Coq/Agda you have an infinite hierarchy of types, yes
01:04:17 <jle`> makalu: hm about two or three months ago
01:04:21 <kandinski> pop has bubbles, and bubbles have shimmers
01:04:30 <mauke[> makalu: 7.10
01:04:31 <kadoban> jle`: The sad part is I can't tell if you're joking or not on that last bit ‚Ä¶
01:04:37 <merijn> kandinski: But for haskell the only things you need to be practically concerned with are types and kinds
01:05:01 <jle`> kadoban: heh, i'm kidding.  it comes from physics nomencalture
01:05:19 <kadoban>  /kinda/ figured, just wasn't sure ;)
01:05:27 <merijn> kandinski: Well, after sort it becomes annoying to name them so most languages do "Type_0 :: Type_1", "Type_1 :: Type_2", repeat until infinity
01:05:32 <jle`> makalu: fwiw 7.4 is pretty old too
01:05:34 <makalu> what is it now then? The foldr from foldable?
01:05:42 <jle`> :t foldr
01:05:43 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
01:05:53 <makalu> ok thanks
01:06:00 <merijn> kandinski: Well, I say "most languages", but I mean most "type systems that go this for, which are mostly not found in programming languages" :p
01:06:02 <jle`> these days having to support 7.6 feels like supporting IE6
01:06:06 <kandinski> so foldr got generalised so it's not about lists anymore
01:06:18 <kandinski> same as fmap got generalised from map
01:06:22 <makalu> yes its old but I need to run my program on debian wheezy
01:06:31 <merijn> kandinski: Actually, map used to be fmap
01:06:43 <merijn> kandinski: So map got restricted to lists, instead of generalised to fmap :p
01:06:52 <mauke[> and we used to comprehend monads
01:07:03 <jle`> people still comprehend
01:07:04 <merijn> kandinski: It was argued that fmap resulted into confusing to beginners in terms of type errors produced
01:07:07 <kandinski> merijn: I didn't mean in haskell, but historically, "map" was a programming construct for lists.
01:07:10 <jle`> i do it every once in a while
01:07:13 <Myrl-chan> ;t createProcess
01:07:16 <Myrl-chan> :t createProcess
01:07:17 <lambdabot> Not in scope: ‚ÄòcreateProcess‚Äô
01:07:22 <jle`> kandinski: it depends on how far you go back in history ;)
01:07:25 <merijn> I dunno, does CT predate programming?
01:07:38 <kandinski> jle`: programming history, not mathematical history :)
01:07:43 <merijn> MacLane is early thirties, right? So I'm guessing map as fmap might predate programming
01:08:00 <merijn> Anyway, I haven't even had my morning tea yet, so I should fix that
01:08:06 <jle`> so maybe programmers stole the word map and abused it, historically
01:08:10 <jle`> wouldn't be the first time ^_^
01:08:15 <echo-area> Is there equivalent concept of Scala's implicit conversion in Haskell?
01:08:28 <kandinski> The introduction I've got is that fmap is a generalisation of map, since map only works over lists. But if you can understand a list as a particular case of a functor, then map is the corresponding particular case of fmap.
01:09:13 <kandinski> And I know this is just an intuitive understanding, but I've avoided using the expressions "particular kind" or "particular type", so am I ok?
01:09:33 <merijn> kandinski: Yeah
01:09:43 <merijn> echo-area: What do you mean by "implicit conversion"?
01:10:01 <merijn> iirc Scala had implicits, but I'll be damned if I remember what they were
01:10:36 <jle`> particular case...sometimes we say specialized, too
01:10:48 <kandinski> jle`: thanks
01:11:04 <kandinski> jle`: I was trying to avoid language that would have a proper definition.
01:11:33 <jle`> you're basically a haskeller already then :P
01:11:39 <kadoban> The proper language would be something like ‚Ä¶ [] is an instance of Functor, with fmap = map
01:11:49 <echo-area> merijn: Yeah I meant implicit.  It basically means the compiler alter the code a bit if it sees mismatched types, to make the types match
01:11:54 <echo-area> *alters
01:12:32 <echo-area> One can register functions as implicit for the compiler to use
01:12:33 <kadoban> echo-area: Unless you mean changing numeric literals into any Num instance, or possibly string literals into any IsString instance, that doesn't sound like anything haskell has.
01:13:58 <kadoban> (It's by design really, not for lack of thinking of it)
01:14:48 <merijn> echo-area: The compiler never changes the types of values
01:14:57 <merijn> kadoban: Even those are not implicit
01:15:06 <merijn> kadoban: Literals are explicitly polymorphic
01:15:30 <kadoban> Right. That's just the closest I could think of to what he was asking, even though it doesn't really quite fit.
01:15:41 <merijn> echo-area: This explicit converting seems really annoying at first
01:16:04 <merijn> echo-area: But as someone who's (twice!) spend 3 weeks hunting down an implicit conversion in C code, trust me. It's not nearly as bad as the alternative
01:16:48 <echo-area> FWIW I am not asking for this in Haskell.  I just don't quite understand the problem it solves
01:17:16 <tzaeru> I guess it's just a part of the purity fandom ;>
01:17:19 <kandinski> when you say that functors have two laws (fmap id = id, and fmap g . fmap f = fmap (g . f)), what does the checking that those laws hold when I define fmap for a given type?
01:17:59 <kadoban> kandinski: Nothing, it trusts you. Your library's users will come burn your house down if you badly break them though ;)
01:18:04 <merijn> kandinski: You ;)
01:18:18 <merijn> kandinski: The laws are not something checked, but they're "social expectations"
01:18:23 <echo-area> merijn: What happens when the compiler sees "5 + 3.0"?  Please give a pointer on explicitly polymorphic
01:18:30 <merijn> :t 5
01:18:31 <lambdabot> Num a => a
01:18:35 <kandinski> right, but where will it break if I manage to define a fmap that doesn't uphold that law?
01:18:58 <MarceColl> kandinski, you have to test them, same for monads, etc, it's just what a definition of what is a sane functor
01:19:14 <Cale> kandinski: Libraries which expect the law to hold may not operate correctly.
01:19:16 <merijn> echo-area: The report specifies that numeric literals (without decimal points) are treated as "fromInteger" being applied to the arbitrary precision Integer written by the literal
01:19:25 <merijn> > 5 :: Double
01:19:27 <lambdabot>  5.0
01:19:40 <kandinski> So it's not like type definitions, which get checked by the compiler. 
01:19:43 <merijn> > fromInteger (5 :: Integer) :: Double
01:19:43 <Cale> right
01:19:44 <lambdabot>  5.0
01:19:49 <MarceColl> nope
01:19:50 <merijn> :t 3.0
01:19:51 <lambdabot> Fractional a => a
01:19:59 <kadoban> kandinski: Indeed. It'd be nice if it could, but it'd also be pretty hard.
01:20:22 <merijn> echo-area: As you can see, literals with a decimal point are treated as "Fractional"
01:20:35 <kandinski> kadoban: and that's what program provers attempt to do, right? Check to that level.
01:20:38 <echo-area> merijn: Ah, thank you, I'll read more.
01:20:40 <Cale> It can be done in various other programming languages already.
01:20:54 <echo-area> kadoban: And thank you :)
01:20:54 <Cale> Dependently typed languages like Idris, Agda, and Coq
01:21:22 <merijn> echo-area: So when you write "5 + 3.0" GHC sees a polymorphic '5 :: Num a => a" and "3.0 :: Fractional a => a" and since Fractional is a subclass it infers that "5 + 3.0 :: Fractional a => a" for some fractional type that is not known yet
01:21:58 <mauke[> well, first it gets (Num a, Fractional a) => a
01:22:03 <Cale> In those languages, for every type A, and x, y of type A there is a type of "proofs that x and y are equal in the type A", which you can then use to express laws like this.
01:22:05 <mauke[> but then Fractional subsumes Num
01:23:23 <sopvop> Why Bifunctor is in base and Contravariant isn't? 
01:24:01 <merijn> Bifunctor isn't in base, is it?
01:24:07 <merijn> :t bimap
01:24:08 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
01:24:41 <merijn> Bifunctor is in the bifunctors package...
01:25:01 <sopvop> merijn: here it is http://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Bifunctor.html
01:25:14 <sopvop> :t contramap
01:25:15 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
01:25:25 <merijn> Wait, what the hell?
01:25:31 <merijn> Whoo!
01:25:38 * merijn afk, throwing a party
01:26:10 <Cale> So, we're slowly recombining category-extras into base now? :D
01:26:11 <sopvop> Some people refuse to add extra deps to their libs, so you have to orphan things like Contravariant :(
01:37:35 <srenatus> hmm got stuck with Data.DeriveTH in GHCi
01:38:01 <srenatus> $( derive makeArbitrary ''Color ) 
01:38:38 <srenatus> > import Data.DeriveTH; data Color = R | B | G; derive makeArbitrary ''Color
01:38:39 <lambdabot>  <hint>:1:1: parse error on input ‚Äòimport‚Äô
01:47:24 <sopvop> is there a typeclass for  (a -> b) -> (b -> a) -> f a -> f b ?
01:49:54 <shiona> sopvop: how would it differ functionally from const . fmap
01:50:26 <sopvop> shiona: `f` is not a functor 
01:52:03 <shiona> if that is the only function the class requires then it looks like a functor to me. But I'm known not to understand haskell so maybe we should wait for someone else to answer
01:52:08 <merijn> sopvop: Profunctor?
01:52:13 <merijn> oh, no
01:52:46 <merijn> sopvop: What's the use of "b -> a", there?
01:53:38 <sopvop> merijn: for thing like `data InputStream { read :: IO a, unread :: Maybe a -> IO () }`, not that I need this, just was curious
01:54:10 <supki> @hackage invariant
01:54:10 <lambdabot> http://hackage.haskell.org/package/invariant
01:54:13 <supki> sopvop: ^
01:54:18 <sopvop> heh
01:54:34 <sopvop> supki: I know it should exist!
01:54:50 <sopvop> I knew 
02:00:33 <pavonia> What is the second function (b -> a) needed for? Looking at the standard instances they all are like invmap = flip $ const fmap
02:07:28 <sopvop> pavonia: like for bidirectional parser  data BiParser= BiParser { parse :: Parser a, unparse :: a -> ByteString } or something like that
02:11:12 <pavonia> I still don't understand how that function would be used in the instance
02:13:14 <pavonia> If you go from BiParser a to BiParser b you cannot reasonably apply a function (b -> a), can you?
02:13:50 <supki> pavonia: consider  newtype Endo a = Endo (a -> a)
02:14:03 <supki> neither (a -> b) nor (b -> a) is enough to give you (Endo a -> Endo b)
02:14:14 <supki> but with both of them it's possible
02:14:20 <supki> :t \f g (Endo a) -> Endo (f . a . g)
02:14:21 <lambdabot> (b -> a) -> (a -> b) -> Endo b -> Endo a
02:15:11 <pavonia> Oh wow
02:16:56 <kuribas> If I found a new algorithm, and submit an implementation to hackage, could the submission date be used as proof that I created it?
02:17:37 <kuribas> (If there is no precendent)
02:19:10 <pavonia> supki: Thanks. Took me a moment to get how that works :)
02:19:14 <kuribas> Though someone could claim hackage can be hacked (no pun intended).
02:24:28 <nkar`> is there a flag that can be used to catch non-exhaustive patterns in do notation, e.g., Just _ <- action?
02:24:58 <nkar`> I'm surprised that -Wall doesn't report anything in this case
02:27:37 <kuribas> It's not really non-exhaustive, since it calls fail.
02:28:20 <nkar`> well, you're right, but is there a way to avoid this?
02:29:05 <kuribas> Sorry, I don't know.
02:30:13 <kuribas> I use forM_
02:30:18 <kuribas> :t forM_
02:30:20 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
02:31:20 <kuribas> For example (forM_ (lookup key map) actionWithVal)
02:31:26 <kuribas> :t forM
02:31:28 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
02:31:30 <nkar`> it's not about me, it's about trusting someone's code.  I recently got hit by a runtime error
02:31:32 <nkar`> because of this
02:32:14 <nkar`> I thought that it should be fine because of -Wall, but I was mistaken
02:32:51 <nkar`> one can argue that it's similar to error or undefined, but I'm not sure since you can search for them while you cannot do it for implicit fail
02:33:24 <kuribas> I agree.
02:33:51 <nkar`> I guess I'll ask on a mailing list after doing a bit of research
02:34:08 * hackagebot ghc-parser 0.1.7.0 - Haskell source parser from GHC.  http://hackage.haskell.org/package/ghc-parser-0.1.7.0 (gibiansky)
02:35:06 <kuribas> IMO a do notation with fail should be part of the Monadplus class
02:36:22 <nshepperd_> maybe with some regex you could search for '[nonidentifier] <- ' and not get too many false positives
02:37:08 <nkar`> I don't think it's possible
02:37:38 <nshepperd_> none of the -fwarn-*-incomplete-* seem to do it either, so
02:38:16 <nkar`> ... so, it needs to be implemented, I think
02:39:09 * hackagebot ihaskell 0.6.3.0 - A Haskell backend kernel for the IPython project.  http://hackage.haskell.org/package/ihaskell-0.6.3.0 (gibiansky)
02:39:10 <kuribas> If mzero was used instead of fail, it would work for a monadplus instance, but give a type error when not (for example IO).
02:39:11 * hackagebot path 0.4.0 - Path  http://hackage.haskell.org/package/path-0.4.0 (ChrisDone)
02:49:41 <joneshf-laptop> how do you find space leaks?
02:50:01 <joneshf-laptop> in actual code
02:50:05 <joneshf-laptop> not contrived examples
02:51:46 <kaiyin> does type annotation reduce compile time?
02:58:05 <kuribas> kaiyin: I don't think so, not noticably.
02:58:15 <jophish_> Yo yo yo
02:58:38 <jophish_> Is this ever likely to see a fix? https://ghc.haskell.org/trac/ghc/ticket/7650 It's been deferred for 2 years
02:59:15 <jophish_> It looks like a good bug to get one's feet wet inn ghc
03:00:09 <mauke[> not enough tuits :-(
03:01:26 <kuribas> kaiyin: Type annotations are either to make the type less general, or to give information to the programmer (or both).  Or give a type to functions that cannot be inferred (when using type extensions).
03:02:03 <jophish_> kuribas: Or more general if you're bitten by the monomorphism restriction
03:02:44 <lieven> jophish_: might open up the unicode equivalence can of worms
03:02:48 <kuribas> jophish_: -XNoMonoMorphismRestriction?
03:03:12 <jophish_> kuribas: if you don't use that extension, yes
03:04:11 <jophish_> lieven: yeah, that's might be an issue. I really want to use things like http://www.fileformat.info/info/unicode/char/20d7/index.htm for vectors!!!
03:04:51 <jophish_> lieven: seems to be well specified however http://en.wikipedia.org/wiki/Unicode_equivalence
03:05:19 <mauke[> https://dl.dropboxusercontent.com/u/41152078/unicode.html?q=math+frakt use these instead
03:05:40 <lieven> jophish_: if ghc would chose one normalisation. otherwise see the samba/OS X example.
03:07:09 <jophish_> lieven: That shouldn't be much of an issue, I don't think haskell identifiers are ever read by anything other than the same version of GHC (Please correct me if I'm wrong)
03:07:53 <jophish_> mauke[: I can imagine producing some horrible unreadable code with those.
03:09:02 <mauke[> ùê¥ùë¶ùë¶ ùëôùëöùëéùëú
03:09:05 <jophish_> At university we had a tutor who took great pains to never use any variables other than 'a' 'Œ±' '◊ê' 'ùîû' or any other 'A's in proofs
03:09:50 <pacak> jophish_: There's also '–∞'
03:09:54 <mauke[> > let q = 1 in let q = 2 in q + ùöö
03:09:56 <lambdabot>  Not in scope: ‚Äòùöö‚Äô
03:10:11 <mauke[> > let ùöö = 1 in let q = 2 in q + ùöö
03:10:13 <lambdabot>  3
03:10:20 <pacak> > 'a' == '–∞'
03:10:23 <lambdabot>  False
03:10:46 <mauke[> https://dl.dropboxusercontent.com/u/41152078/unicode.html?q=a%D0%B0
03:13:52 <jophish_> uh oh, what have I done
03:17:26 <mauke[> > let aÃà = 1 in let √§ = 2 in aÃà + √§
03:17:27 <lambdabot>  <hint>:1:6: lexical error at character '\776'
03:19:12 <pacak> > let a = 1 in let –∞ = 2 in a + –∞
03:19:14 <lambdabot>  3
03:19:38 <mauke[> jophish_: in general, identifiers are read by many different versions of GHC
03:19:46 <mauke[> especially if you upload your identifiers to hackage
03:25:41 <jophish_> mauke[: ah, I was thinking about issues with compiling a set of packages together.
03:26:47 <Thule> Can anyone tell my why the following fails: http://pastebin.com/wMR63tDt? It works if I just have the commented part, but putting it in a function makes it break
03:27:31 <Thule> it is about FFI
03:28:35 <Thule> I cannot understand why the type inference makes: (t0 -> (IO (IO b0)) it should be (t0 -> (IO b0))
03:29:30 <jophish_> Thule: I've not looked, but are you doing something like: return (some IO value)
03:29:58 <Thule> hmm no, I do not think so
03:30:24 <jophish_> you may be interested in
03:30:27 <jophish_> :t join
03:30:31 <lambdabot> Monad m => m (m a) -> m a
03:30:58 <jophish_> (although that may not be the most appropriate solution in this situation)
03:31:12 <Thule> ye that would probably solve it, but I do not understand why it happens. And that annoys me
03:32:33 <jophish_> Thule: ah, invokeFunction ... is being passed to show which takes a value of type Show a => a
03:32:40 <jophish_> but invokeFunction return an IO value
03:33:14 <jophish_> try: putStrLn . show =<< invokeFunction "test" c_funcRetString peekCString
03:34:14 <jophish_> :t (=<<)
03:34:16 <lambdabot> Monad m => (a -> m b) -> m a -> m b
03:36:50 <Thule> same issue jophish_
03:39:15 <merijn> Thule: What's the type of invokeFunction?
03:40:14 <Thule> String -> (FunPtr b1 -> IO t) -> (t -> IO (IO b)) -> IO b merijn
03:40:21 <jophish_> the type of invokeFunction is 'String -> (FunPtr (IO (CString)) -> IO (CString)) -> (CString -> IO String) -> IO String' as far as I can determine
03:40:33 <Thule> exactly what I thought, but it is not
03:42:48 <merijn> Isn't func already a FunPtr?
03:42:58 <merijn> So why the castPtrToFunPtr ?
03:43:27 <Thule> It is of type Addr
03:43:30 <Thule> does not work otherwise
03:43:42 <merijn> I dunno where getProcAddress comes from then
03:44:06 <Thule> the commented part works perfectly, but when trying to use a helper function I simply cannot make it  work
03:44:06 <jophish_> :t getProcAddress
03:44:07 <lambdabot> Not in scope: ‚ÄògetProcAddress‚Äô
03:44:24 <Thule> HMODULE -> String -> IO Addr
03:44:57 <merijn> Anyway, I can't quite follow what's going on in that code
03:45:10 <merijn> My recommendation is "more type signatures" until you find out where you and GHC disagree
03:45:28 <merijn> oh
03:45:33 <merijn> Already found the issue
03:45:50 <Thule> what is it?
03:45:53 <merijn> Line 20 forces "val :: IO a"
03:46:12 <merijn> Therefore "convType" must return IO (IO a)
03:46:20 <jophish_> Thule: change line 19 to just convType ret
03:46:26 <jophish_> and remove line 20
03:46:34 <jophish_> nice Spockz merijn
03:46:36 <jophish_> spot*
03:46:37 <Thule> ahhh
03:48:06 <Thule> Thanks guys!
03:49:48 <phaazon> hey
03:49:52 <jophish_> 'sup
03:50:02 <phaazon> I read on reddit a guy stating that Haskell ¬´ can be as fast as Java ¬ª
03:50:09 <phaazon> I always thought Java was slow
03:50:32 <phaazon> and that Haskell was way faster than Java
03:50:41 <phaazon> that keeps me intrigued
03:50:56 <merijn> phaazon: Java's JIT is pretty good
03:51:11 <merijn> phaazon: Starting the JVM is slow, but Java itself (can be) pretty fast
03:51:18 <jophish_> phaazon: this might be up your street: http://research.microsoft.com/en-us/um/people/simonpj/papers/ndp/haskell-beats-C.pdf
03:51:28 <jophish_> I'm sure you've seen it :)
03:51:35 <phaazon> I¬†think so
03:52:17 <phaazon> oh
03:52:19 <phaazon> 2013
03:52:21 <phaazon> not that old
03:53:55 <jophish_> phaazon: Even if Java was twice as fast as anything else I think you'd be hard pressed to find many converts in this channel :)
03:54:23 <phaazon> jophish_: I don't like Java either, so yeah
03:54:34 <phaazon> it's about a reddit thread
03:54:43 <phaazon> default laziness
03:54:51 <phaazon> you might have seen that come out
04:03:17 <MarceColl> jophish_ the C code was completely unoptimized tho
04:04:01 <jophish_> MarceColl: well, one could just write inline asm equal to what ghc spits out for the inner loop :)
04:06:23 <MarceColl> jophish_ http://jacquesmattheij.com/when-haskell-is-not-faster-than-c
04:08:24 <MarceColl> haskell doesn't need to be faster than C in my opinion, it's not what it's about. It just happens to be that in certain things, because of how haskell works the compiler can optimize more than in it's C counterpart. But it is harder to optimize haskell programs than C programs imho
04:09:33 <maerwald> funny how people regularly bring up the "there is only so much time" argument in order to explain why they never got into functional programming
04:09:50 <maerwald> wrt that post
04:14:14 * hackagebot cuboid 0.14.2 - 3D Yampa/GLUT Puzzle Game  http://hackage.haskell.org/package/cuboid-0.14.2 (PedroMartins)
04:14:24 <MarceColl> meh, I don't care about what his thoughts on haskell are, but his C dissection is fun
04:15:12 <tzaeru> maerwald, it's often a valid explanation, really. and aplicable to a lot of other things than functional programming, too.
04:15:20 <tzaeru> I'd love to do so many things :P but don't have time for even a quarter of them.
04:16:03 <maerwald> tzaeru: I'd say a programmer should have insight to all of the major programming paradigms and FP is definitely a major one
04:16:48 <tzaeru> well, "getting into" and "being aware of it on a basic level" is very different
04:17:12 <maerwald> tzaeru: except for haskell :P
04:17:52 <tzaeru> well, I for example don't really anything about haskell or any other FP language, but I'm aware of Haskell's existance and its style of attemping to keep functions side-effectless! :P
04:17:59 <tzaeru> so I'd say I'm aware of Haskell on a basic, rudimentary level.
04:18:07 <tzaeru> but never gotten into it and don't know anything about it more than that.
04:18:18 <tzaeru> the excuse is a familiar one; "no time to"
04:18:59 <maerwald> tzaeru: no excuses, get into it!
04:19:04 <tzaeru> no, I've shit to do.
04:20:32 <tzaeru> though to extend on the "no time to", obviously almost all of us have *some* free time to allocate freely.
04:20:36 <tzaeru> and then it depends on our priorities.
04:20:54 <tzaeru> for me, as a programmer, the current state of affairs isn't quite enough to push me to make big leaps to learning anything new.
04:21:02 <tzaeru> so I rather allocate that time to something else.
04:21:08 <tzaeru> like, for example, drinking.
04:21:16 <tzaeru> or playing video games.
04:21:18 <maerwald> :D
04:21:23 <maerwald> gotcha
04:21:31 <phaazon> duh
04:21:37 <tzaeru> ..thou I still do plan to have an extended weekend on haskell at some point
04:21:38 <phaazon> the MonadFix instance for Maybe blows my mind
04:21:47 <phaazon> it uses a unJust that looks like fromJust
04:22:00 <phaazon> but if I¬†implement MonadFix with fromJust, it raises an error
04:22:37 <phaazon> oh nevermind
04:22:38 <phaazon> it works
04:22:43 <phaazon> :t mfix
04:22:44 <lambdabot> MonadFix m => (a -> m a) -> m a
04:22:49 <phaazon> > mfix (const Nothing)
04:22:51 <lambdabot>  Nothing
04:22:58 <phaazon> > mfix (\a a `seq` Nothing)
04:22:59 <lambdabot>  <hint>:1:12: parse error on input ‚Äò`‚Äô
04:23:09 <phaazon> > mfix (\a -> a `seq` Nothing)
04:23:13 <lambdabot>  mueval-core: Time limit exceeded
04:29:15 * hackagebot shake 0.15.2 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.15.2 (NeilMitchell)
04:35:32 <anks> i've just found myself writing actions like these:
04:35:33 <anks> (sequence $ repeat getColorCount) >>= return . take 10 >>= return . sum
04:35:39 <anks> but i dont find it elegant
04:35:58 <mauke[> >>= return . is liftM
04:36:23 <mauke[> sum <$> replicateM 10 getColorCount
04:36:27 <anks> Perhaps you meant 'id' 
04:36:42 <anks> yea thats the one
04:36:48 <mauke[> :t \f m -> m >>= return . f
04:36:48 <anks> thanks :)
04:36:49 <lambdabot> Monad m => (a -> b) -> m a -> m b
04:36:52 <mauke[> :t liftM
04:36:54 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
04:37:21 <anks> pretty similar ;
04:37:40 <mauke[> :t id
04:37:42 <lambdabot> a -> a
04:37:44 <StyxAlso> Newbie Haskell question: What‚Äôs the difference between . and $?
04:38:02 <mauke[> StyxAlso: $ applies a function to an argument. . composes two functions into another function
04:38:29 <anks> so $ is like white space but with lowered priority 
04:38:31 <anks> i guess
04:38:45 <StyxAlso> ta
04:38:49 <maerwald> @type ($)
04:38:51 <lambdabot> (a -> b) -> a -> b
04:38:52 <mauke[> incidentally, $ is id
04:38:54 <maerwald> @type (.)
04:38:56 <lambdabot> (b -> c) -> (a -> b) -> a -> c
04:39:02 <maerwald> that's the difference :P
04:39:05 <anks> :D
04:46:29 <quchen2_> ($) is a specialized id.
04:46:39 <quchen2_> "is" sounds symmetric.
04:51:10 <phaazon> > mfix (const [])
04:51:12 <lambdabot>  []
04:54:57 <phaazon> gosh
04:55:04 <phaazon> the implementation for []
04:55:16 <phaazon> is there anyone who could help me wrap my head around mfix?
04:55:42 <Yuu-chan> :info MonadFix
04:55:51 <Yuu-chan> @info MonadFix
04:55:51 <lambdabot> MonadFix
04:56:18 <Yuu-chan> Thank you, lambdabot.
04:56:54 <mauke[> there is no @info command
04:57:26 <phaazon> > take 3 =<< (mfix $ \a -> 1 : a)
04:57:28 <lambdabot>      Occurs check: cannot construct the infinite type: b ~ [b]
04:57:28 <lambdabot>      Expected type: [[b]]
04:57:28 <lambdabot>        Actual type: [b]
04:57:43 <phaazon> > fmap (take 3) . mfix $ \a -> 1 : a
04:57:44 <Yuu-chan> Couldn't Bot say me about that?
04:57:45 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ [a]
04:57:45 <lambdabot>      Expected type: [[a]]
04:57:45 <lambdabot>        Actual type: [a]
04:57:55 <mauke[> Yuu-chan: no, because it autocorrects to @undo
04:58:01 <phaazon> > take 3 . mfix $ \a -> 1 : a
04:58:03 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ [a]
04:58:03 <lambdabot>      Relevant bindings include a :: a (bound at <interactive>:1:18)
04:58:03 <lambdabot>      In the second argument of ‚Äò(:)‚Äô, namely ‚Äòa‚Äô
04:58:04 <phaazon> goddammit
04:58:18 <Yuu-chan> @there is no such command
04:58:18 <lambdabot> I know nothing about is.
04:58:28 <mauke[> that autocorrects to @where
04:58:34 <jophish_> MarceColl: thanks for the link! What an interesting read.
04:58:37 <phaazon> :t mfix $ \a -> 1 : a
04:58:39 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ [a]
04:58:39 <lambdabot>     Relevant bindings include a :: a (bound at <interactive>:1:9)
04:58:39 <lambdabot>     In the second argument of ‚Äò(:)‚Äô, namely ‚Äòa‚Äô
04:58:46 <phaazon> wat
04:58:46 <quchen2_> Private window maybe?
04:59:00 <mauke[> phaazon: 'a' is not 'm a'
04:59:17 <phaazon> > take 3 . mfix $ \a -> [1] ++ a
04:59:19 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ [a]
04:59:19 <lambdabot>      Relevant bindings include a :: a (bound at <interactive>:1:18)
04:59:19 <lambdabot>      In the second argument of ‚Äò(++)‚Äô, namely ‚Äòa‚Äô
04:59:29 <phaazon> ok nevermind, fuck this.
04:59:32 <phaazon> sorry for bothering
04:59:58 <mauke[> dude, that's the exact same code as before
05:00:15 <Yuu-chan> > take 3 $ mfix (:[])
05:00:18 <mauke[> you're passing a function to mfix that has type T -> T for some T
05:00:19 <lambdabot>  mueval-core: Time limit exceeded
05:00:21 <mauke[> this cannot work
05:00:30 <mauke[> :t mfix
05:00:32 <lambdabot> MonadFix m => (a -> m a) -> m a
05:00:43 <mauke[> mfix requires T -> m T
05:01:07 <phaazon> > mfix $ \a -> if length a >= 10 then Nothing else Just (a ++ a)
05:01:11 <lambdabot>  mueval-core: Time limit exceeded
05:01:15 <luzie> :t mfix
05:01:16 <lambdabot> MonadFix m => (a -> m a) -> m a
05:01:24 <phaazon> I guess that mfix returns if we stop using a
05:01:34 <phaazon> I don't see how that's useful though
05:01:54 <phaazon> > mfix $ \a -> Nothing
05:01:57 <lambdabot>  Nothing
05:01:59 <phaazon> > mfix $ \a -> a `seq` Nothing
05:02:03 <lambdabot>  mueval-core: Time limit exceeded
05:02:20 <Yuu-chan> I once used mfix with recursive-do
05:03:15 <phaazon> I really don't get it
05:03:44 <luzie> https://wiki.haskell.org/MonadFix
05:05:53 <Yuu-chan> phaazon: do you get the ordinary fixed-point?
05:12:58 <phaazon> Yuu-chan: yes
05:14:17 * hackagebot log 0.2.0 - Structured logging solution with multiple backends  http://hackage.haskell.org/package/log-0.2.0 (arybczak)
05:15:01 <phaazon> > take 3¬†. fix $ map succ . (1:)
05:15:04 <lambdabot>  [2,3,4]
05:27:15 <bigb123> hello. i'm creating an error handle server which tell errors apart according to tag string, then handle it with each way. i've just implemented it but i have a type error. the code is http://lpaste.net/133103. would you give me some advice for me to complete this avoid type error?
05:30:03 <bergmark> bigb123: the problem is that the MonadIO m constraint is on a method but the type variable isn't mentioned in the class header
05:30:40 <Thule> Does anyone know how to treat a void* in haskell? It is returned from C and I need to have some handle to it. Yet IO (Ptr()) throws the error: Unacceptable type in foreign declarations IO (ForeignPtr ()). Same happens with IO (Ptr ())
05:30:55 <bergmark> bigb123: why not make it IO instead? I don't think using MonadIO there will help in any way, it only forces all isntances to call liftIO 
05:33:01 <bennofs> Thule: Ptr () should work I believe
05:33:14 <bennofs> Thule: can you show the code?
05:34:08 <Thule> sec bennofs :)
05:34:11 <bigb123> bergmark: i've changed (MonadIO m) to IO, but the type error hasn't gone away. please see: http://lpaste.net/133108
05:35:34 <Thule> getting a new error now, so I'll try and fix that first
05:35:52 <bigb123> bergmark: i can't understand why function unwrap can't determine the type of object 'w' contains.
05:39:19 * hackagebot line-break 0.1.0.0 - Convert newlines in text  http://hackage.haskell.org/package/line-break-0.1.0.0 (AlanHawkins)
05:43:15 <c_wraith> bigb123: This is the difference between classes in a language like java and classes in Haskell
05:43:50 <c_wraith> bigb123: In this case, the class is doing nothing for you.
05:44:10 <Thule> I need to invoke a C function with a CString argument. The function newCString :: String -> IO CString is the one I need to use, but it is wrapped up in IO. which makes a function call to:   c_funcInstantiate :: FunPtr (CString -> CString -> HMODULE -> IO (Ptr ())) ->  CString -> CString -> HMODULE -> IO (Ptr ()) really long to make. How do I get t
05:44:10 <Thule> he CString out of the monad in a nice way?
05:44:16 <fractalsea> Hi, we are using monad-logger, which in turn depends on fast-logger. We are having an issue where logs are not written in their entireity if the process is killed. We suspect this is caused by log buffering. I tried to do disable this to confirm it was the problem by using hSetBuffering to use NoBuffering, but this seemed to have no effect. I also checked if fast-logger was doing its own buffering, but it says in the 
05:44:17 <fractalsea> version 2.3.1 that we are using that you do not need use flushLogStr because it is performed automatically when the program is terminated. Has anyone come accross this problem before?
05:44:37 <mauke[> Thule: what do you mean, "really long"?
05:45:06 <Thule> mauke[: my problem is I cannot figure out how to get CString out of IO
05:45:31 <Thule> without doing do notation
05:45:46 <Thule> and using do notation splits up a single function call into 4 lines
05:46:03 <mauke[> you can't get anything out of IO
05:46:09 <mauke[> you push your operations into IO
05:46:24 <mauke[> also, how are you freeing your strings afterwards?
05:47:37 <c_wraith> bigb123: the reason for the error is that you have  unwrap :: Wrappable a => Wrapper -> a  and  handleIncoming :: Handlable a => a -> IO ().
05:48:43 <Thule> I put it up here mauke[ with the error I am getting: http://pastebin.com/GJN7dwW2
05:48:53 <c_wraith> bigb123: if you put those together, how does the compiler know what instance to select?
05:49:59 <c_wraith> bigb123: instance selection has to be done at compile time..  Otherwise, how does the compiler know what code to use?
05:50:35 <mauke[> Thule: so you're not freeing the pointers?
05:51:05 <c_wraith> bigb123: so it sees that it needs a type that has an instance for Wrappable and Handlable.  But that's not enough to narrow down what the type actually is.
05:51:13 <Thule> Nope, not yet atleast.. I haven't even completed the function invocation yet
05:51:22 <Thule> It is the first time I am working with FFI
05:51:37 <c_wraith> bigb123: unwrap is pretty unusable as a class function, actually.  You always need to know the contained type ahead of time to use it.
05:51:42 <mauke[> then you probably want withCString instead
05:52:04 <Thule> ahh sweet
05:52:28 <bigb123> c_wraith: your advice makes me understand why this error has happened, thanks. but, i have no idea to solve such problem in haskell.
05:53:04 <elfeck> heyoh, how can I convert [IO Int] to IO [Int]?
05:53:19 <Haskellfant> elfeck: sequence
05:53:19 <mauke[> @hoogle [IO Int] -> IO [Int]
05:53:20 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
05:53:20 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
05:53:20 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
05:53:29 <c_wraith> bigb123: in general, you don't use classes at all for that.  You just pattern-match on the constructors of Wrapper.
05:54:15 <bigb123> c_wraith: so, must i use pattern-match everytime i want to handle Wrapper?
05:54:54 <c_wraith> bigb123: I mean, half the point of pattern-matching is to branch on the contents of a type with multiple constructors.
05:55:32 <c_wraith> (the other half is to bind names to subfields of constructors)
05:56:54 <Thule> mauke[ what is the function I am supposed to pass to withcstring?  I still cannot get a CString passed to the funcInstantiate
05:57:36 <mauke[> withCString "t1" $ \t1 -> withCString "t2" $ \t2 -> c_funcInstantiate (castPtrToFunPtr instantiateFunc) t1 t2 dll
05:59:20 * hackagebot fold-debounce 0.1.0.0 - Fold multiple events that happen in a given period of time.  http://hackage.haskell.org/package/fold-debounce-0.1.0.0 (debugito)
06:03:12 <Thule> mauke[ I need to understand why - and I cannot get the think you send me to work. This is what I tried: http://pastebin.com/Kb1ngZ00 -> but I need to pass a function to withCString
06:03:17 <Thule> thing*
06:04:00 <mauke[> Thule: so you didn't try the code I gave you?
06:04:58 <bigb123> c_wraith: i'm getting an image of pattern-match. i've rewritten my code: http://lpaste.net/133110. so, after i branch on a specific type in 'handleInComing', i should use them?
06:06:00 <Thule> ahh now I get it! thanks mauke[
06:07:56 <Su-Shee> hi everyone. I'd like a recommendation for a nice, not too big haskell codebase I could look through as a beginner to get an impression what "good style" in haskell means. I have a coupel of projects at hand, darcs for example. where would I want to look?
06:08:34 <Thule> Any way to catch exceptions in haskell? My FFI call just makes GHCI crash
06:08:59 <Vektorweg11> catch .
06:09:23 <mauke[> @where style
06:09:23 <lambdabot> http://urchin.earth.li/~ian/style/haskell.html http://snapframework.com/docs/style-guide https://github.com/chrisdone/haskell-style-guide
06:09:25 <merijn> Su-Shee: XMonad? Pandoc? (although pandoc isn't small...)
06:09:41 <merijn> Su-Shee: You'd be surprised how doable it is to wade through large haskell codebases, though
06:09:44 <Su-Shee> merijn: ok, I have an xmonad here as well.
06:10:00 <merijn> Can GHCI even do FFI?
06:10:04 <merijn> I don't think so?
06:10:17 <Su-Shee> merijn: well I found it rather pleasant visually in general, whenever I see it. but I have no idea what counts as "good style".
06:24:53 <c_wraith> bigb123: in fact, the pattern match can bind the contained value to a name at the same time.  handleIncoming (WSampleError e) = ... something involving e  and so on
06:28:33 <ocramz> hi there
06:32:02 <Athas> Have people here experienced that compiling with GHC 7.10 is significantly slower than with GHC 7.8?
06:33:46 <ocramz> I'm reading E.Z.Yang's blog, the 6-part tutorial on FFI; can anybody clarify on this sentence "Haskell provides primitives that make thread safety much easier, in particular MVar, TVar and TMVar; simply store your pointer in this shared variable and don't let anyone else have the pointer. Extra care is necessary for complex pointer graphs; be sure that if you have an MVar representing a lock for some shared state, there isn't a pointer
06:33:46 <ocramz> squirreled away elsewhere that some other C code will just use. And of course, if you have persistent structures, maintaining consistency is trivial."
06:34:01 <bennofs> Athas: yes, there are reports about this on the ghc-dev ML iirc
06:34:49 <Athas> bennofs: yes, I see... Well, I hope they will manage to figure it out.
06:37:30 <fryguybob> ocramz: I think ezyang is getting at how Haskell makes privitization easy.
06:38:18 <Myrl-chan> fryguybob: privitixation?
06:38:49 <merijn> ocramz: What about it isn't clear?
06:39:18 <merijn> ocramz: It's basically saying "if multiple people have pointers to the same thing and they don't all obey the same lock, madness ensues"
06:40:53 <fryguybob> Myrl-chan: Ensuring that data that should be local to a particular thread is.  This gets complicated by things like handing data from one thread to another.
06:41:46 <Myrl-chan> Ah.
06:42:11 <Myrl-chan> This reminds me of C, where forking the thread clones the buffer
06:42:37 <Myrl-chan> Took me quite some time to realize that I should flush the vuffer
06:44:05 <mauke[> fork creates a new process, not a thread
06:44:39 <Myrl-chan> Really?
06:44:56 <ion> % apropos fork
06:44:58 <ion> fork (2)             - create a child process
06:46:04 <Myrl-chan> Welp
06:50:46 <ocramz> merijn, fryguybob: thanks
06:51:35 <OutlawStar> wasn't there ghc flag added to allow reuse of record names. IE Foo { value ... } Bar { value ... } ?
06:52:52 <ocramz> merijn: so if I understood, one should create a single MVar for any given "pointer" representation (like newtype A = A (Ptr A) )
06:54:12 <ocramz> merijn, fryguybob : though I'm not so concerned with multithreading at the Hs level but rather hiding the memory management details of the underlying C FFI library
06:54:30 <keko_> OutlawStar: DisambiguateRecordNames?
06:55:01 <keko_> sorry, DisambiguateRecordFields
06:55:31 <fryguybob> ocramz: He is saying to organize your program so that access to pointers is tied to "thread safe" haskell data types.  With MVar you can still have a problem when you need multiple pointers, but TVar avoids even that.
06:55:43 <OutlawStar> keko_: thats probably it thx
06:55:57 <merijn> ocramz: Basically, you need to do locking just like you would when doing multithreading in C/whatever
06:55:57 <keko_> OutlawStar: but there's also apparently something newer http://www.well-typed.com/blog/2015/03/overloadedrecordfields-revived/
06:55:58 <fryguybob> On the other hand, what you want to do with the pointer in an FFI context may not be safe to do in a transaction.
06:56:06 <zmbmartin> If you want to case something in IO is there a shorter way then do; b <- a; case b of‚Ä¶?
06:56:10 <merijn> ocramz: So you make sure no more than one thread ever uses the same pointer at the same time
06:56:26 <merijn> zmbmartin: Since GHC 7.6 we have the LambdaCase extension!
06:56:28 <ion> With LambdaCase, a >>= \case 
06:56:41 <merijn> zmbmartin: You can write "a >>= \case {- patterns here -}"
06:57:03 <Hafydd> w/ 23
06:57:05 <Hafydd> Whoops.
06:57:22 <OutlawStar> keko_: thats cool, wasn't aware of that new article
06:57:44 <merijn> zmbmartin: Which is equivalent to "a >>= \b -> case b of {- patterns here -}"
06:58:07 <warbo> my program uses the GHC API to read .hs files, but it can't find modules for the imports
06:58:35 <warbo> assuming that the .hs files are in a cabal project, is there a way to run my program 'in the context of' the project's dependencies?
06:59:51 <zmbmartin> merijn ion Thanks!
07:00:41 <ocramz> merijn: I understand STM is more general than MVars an related; should I just go for that? e.g. "atomic" reads and writes?
07:01:37 <ion> If it turns out to be fast enough for you, i don‚Äôt see anything wrong with just going for STM.
07:02:14 <ocramz> ion: fast enough? is it so heavy?
07:03:17 <ocramz> ion: I'd use it to orchestrate an FFI-bound library for doing numerics, so I expect the C side to be the bottleneck
07:04:21 <OutlawStar> warbo: cabal repl? assuming you mean run with ghci
07:04:47 <ion> ocramz: I haven‚Äôt read this specific text, but it seems like it might be useful: http://chimera.labs.oreilly.com/books/1230000000929/ch10.html#sec_stm-cost
07:07:12 <warbo> OutlawStar: I think if I invoke a GHCi repl within an arbitrary project, the GHC API won't be available for my commands
07:07:56 <warbo> OutlawStar: whereas, if my commands are compiled into a binary, the cabal project's dependencies aren't available....
07:07:58 <warbo> a conundrum
07:08:05 <OutlawStar> :(
07:08:33 <ocramz> ion: the risk of performing a heavy operation within a transaction is that it gets re-executed, in the worst case indefinitely
07:09:24 * hackagebot cef 0.1.1 - CEF log format  http://hackage.haskell.org/package/cef-0.1.1 (utdemir)
07:09:26 <ion> ocramz: I‚Äôd say just go for STM and figure out what to do *if* it turns out to have a performance issue.
07:11:45 <ocramz> ion: I like it :) I was already contemplating the possibility; I'll start by studying S.Marlow's book even though it doesn't seem to discuss FFI integration
07:12:05 <ocramz> ion: thanks for the heads up!
07:26:22 <joncol> What's the significance of the first "." in: lift2 = (flip revApply .) . fmap ? Is it some special notation for point-free style?
07:26:35 <c_wraith> joncol: it's the exact same as the second .
07:26:47 <c_wraith> joncol: it's just partially applied with section syntax
07:27:02 <ion> joncol: (x +) = \y -> x + y
07:27:08 <ion> joncol: (f .) = \g -> f . g
07:27:29 <ion> joncol: That expression is obfuscated but it can be worked out. Or you can just ask @unpl.
07:27:34 <ion> @unpl lift2 = (flip revApply .) . fmap
07:27:34 <lambdabot> lift2 g j c = revApply c (fmap g j);
07:28:40 <RyanGlScott> I've having some difficulty debugging a program which uses GADTs and pattern-matching: http://lpaste.net/133114
07:28:52 <RyanGlScott> Why doesn't the commented-out code compile?
07:30:38 <ion> RyanGlScott: Only successfully pattern matching on the Unit constructor brings in evidence that a ~ () to scope.
07:31:04 <RyanGlScott> ion: Is GHC unable to infer that the only possible constructor for UnitParameter requires a ~ ()?
07:31:33 <ion> It probably shouldn‚Äôt even try, that might result in weird semantics.
07:31:37 <c_wraith> RyanGlScott: it doesn't even try.  It's easy to construct cases that are really complicated.
07:32:11 <RyanGlScott> I suppose that makes sense. It's a bit annoying, though, when you have a bunch of GADT constructors that have the same constraints.
07:32:37 <ion> Try wobblyTypes :: UnitParameter () -> (() -> b) -> b; wobblyTypes _ f = f ()
07:32:38 <RyanGlScott> You have to pattern match each one individually only to use the same RHS after each pattern match.
07:33:45 <RyanGlScott> ion: I hadn't thought of that. Locally defining a function with a constrained type just might do the trick. Thanks!
07:44:09 <Cale> RyanGlScott: Note that there exists  undefined :: UnitParameter Integer
07:44:23 <MarceColl> anyone here that has succesfully used Network.Curl to send data to a server?
07:44:35 <Cale> RyanGlScott: So only when the pattern match actually succeeds is it safe to proceed.
07:46:05 <RyanGlScott> Cale: Oh, I hadn't thought of ‚ä•. That's an even more compelling reason to require a pattern match.
07:47:45 <ion> That‚Äôs why bringing in the equivalent evidence from the outside also suffices: out of all the bottoms, you can only give the ones with UnitParameter () to the new wobblyTypes function.
07:51:18 <MarceColl> it's getting stuck every single time, fuck this bindings, I don't understant :D
07:51:24 <joncol> I'm still not clear about the sectioned (.) function... When reducing to point-free style, going from:
07:51:27 <joncol> banana2 g = (flip apple) . (furry' g)
07:51:37 <joncol> To: banana2 = (flip apple .) . furry'
07:51:56 <joncol> Can someone make me understand the use of the . before the )?
07:52:22 <maerwald> point-free is horrible if it results in such constructs
07:52:40 <Cale> joncol: sure
07:52:48 <Cale> joncol: Do you know about fmap?
07:52:48 <joncol> maerwald> Just want to grasp it :(
07:52:59 <joncol> Cale> Yes
07:53:03 <hodapp> Should matches like "d@_ -> foo d" in a case statement (at the end) be causing warnings about overlapping pattern matches?
07:53:28 <Cale> joncol: So, there's an instance of Functor for (->) e, wherein  fmap :: (a -> b) -> (e -> a) -> (e -> b)
07:53:33 <hodapp> I keep seeing this explained as a GHC bug with OverlappingStrings but I should be many versions ahead of where that was fixed
07:53:36 <Cale> That is, fmap = (.)
07:53:43 <hodapp> and if I changed it to "d@otherwise -> foo d" it goes away
07:53:53 <joncol> Cale> I'm with you
07:54:20 <Cale> So when you see (f .) you may read  fmap f  instead, keeping in mind that this is the function which applies f to the result of another function
07:55:48 <Cale> You can also just confirm that this equation is true ((f .) . g) x y = ((f .) (g x)) y = (f . g x) y = f (g x y)
07:56:13 <joncol> Thanks Cale! I'll think about that for a few minutes, I'm slow :)
07:58:52 <ion> It may help to think of an example with another operator.
07:59:36 <ion> > let banana2 n = 100 + (5*) n in banana2 3  -- substitute flip apple with 100 and furry' with (5*)
07:59:38 <lambdabot>  115
07:59:58 <ion> > let banana2 = \n -> (+) 100 ((5*) n) in banana2 3
08:00:02 <lambdabot>  115
08:00:05 <ion> @src (.)
08:00:06 <lambdabot> (f . g) x = f (g x)
08:00:58 <ion> (f . g) = \x -> f (g x), or ((+) 100 . (5*)) = \n -> (+) 100 ((5*) n)
08:01:20 <ion> > let banana2 = (+) 100 . (5*) in banana2 3
08:01:23 <lambdabot>  115
08:01:36 <ion> > let banana2 = (100 +) . (5*) in banana2 3  -- equivalent
08:01:38 <lambdabot>  115
08:03:18 <joncol> The thing about (f .) === fmap f was very interesting.
08:03:52 <joncol> Didn't think about that at first.
08:04:28 <maerwald> I hope people don't use the program "pointfree" for actual refactoring :/
08:05:45 <joncol> Can you reach a level where you read the point free style as naturally as when the params are clearly stated?
08:06:06 <maerwald> joncol: pointfree isn't generally better than pointful. It depends on the context which one is more clear
08:06:33 <Cale> I'm pretty used to seeing (f .) . g as an idiom, but I'm not sure how often I'd use it myself
08:06:47 <maerwald> Cale: I'd say it's very bad style
08:06:51 <exio4> point-free makes sense when using some combinators heavily 
08:06:51 <Cale> I wouldn't.
08:06:57 <hodapp> :t (\f g -> (f .) . g)
08:06:59 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
08:07:18 <exio4> like (<$>)/(<*>)/(&&&)/(***)/(>=>) 
08:07:32 <warbo> I sometimes refactor my code to be point-free, so that I can see what it's "really" doing, then use that information to refactor some variables back in :)
08:08:01 <Cale> It's easy enough to remember what (f .) . g means after you've seen it once or twice at least.
08:08:10 <exio4> point-free code, though, means you don't to do one of the hardest thing in programming, name variables! :P
08:08:22 <ion> joncol: Nobody should have to. It‚Äôs bad to use constructions such as (f .) . g.
08:08:29 <maerwald> yep
08:08:42 <hodapp> what's an example of a use of (f .) . g?
08:08:43 <Cale> Is it really *bad*? I don't know if I'd go that far.
08:09:06 <maerwald> Cale: it causes my brain to do manual type-math. It's a waste of my time.
08:09:19 <Cale> Eh, but if you've seen it before, it doesn't.
08:09:22 <exio4> I don't think (f .) . g is that bad either
08:09:29 * hackagebot jose-jwt 0.6.2 - JSON Object Signing and Encryption Library  http://hackage.haskell.org/package/jose-jwt-0.6.2 (LukeTaylor)
08:09:30 <exio4> maerwald: only the first and second time
08:09:32 <Cale> If you know that ((f .) . g) x y = f (g x y)
08:09:53 <Cale> Then you don't have to think too hard
08:10:09 <maerwald> pointless discussion ;)
08:10:30 <maerwald> err, pointfree
08:10:57 <Cale> > let f = (sum .) . map in f cos [0,0.01 .. 2*pi]
08:10:58 <lambdabot>  0.6814699385708101
08:11:24 <joncol> The example I was working on (as you probably already figured out) was in the definition of liftM. liftM = ((<*>) .) . fmap
08:12:05 <ion> Who keeps giving you those obfuscated functions?
08:12:15 <maerwald> joncol: I don't even want to think about what that does. There's a compiler to figure that out.
08:12:31 <joncol> 20 Intermediate Haskell Exercises by Tony Morris
08:12:46 <maerwald> I guess that one goes on my black list :P
08:13:03 <joncol> It's pretty interesting stuff :)
08:13:04 <maerwald> for pointless/pointfree exercises
08:13:27 <Cale> If you find this challenging, you probably should do the exercises :)
08:13:28 <exio4> that's not liftM though
08:13:35 <maerwald> Cale: uhu
08:13:38 <exio4> I think it's liftA2
08:13:38 <ion> This? I don‚Äôt see ((<*>) .) . fmap in there. http://tonymorris.github.io/blog/posts/20-intermediate-haskell-exercises/
08:13:56 <exio4> @type ((<*>) .) . fmap
08:13:57 <Cale> It's liftM2
08:13:57 <lambdabot> Applicative f => (a1 -> a -> b) -> f a1 -> f a -> f b
08:14:05 <Cale> yeah, or A2
08:14:17 <joncol> LiftA2 === LiftM2 no?
08:14:28 <dario`> no
08:14:34 <Cale> When the Monad and Applicative instances coincide, yeah
08:14:37 <dario`> but same idea
08:16:43 <joncol> But when Applicative becomes a subtypeclass of Monad (ghc 7.10?) liftA2 will always be === liftM2, right?
08:16:46 <Cale> It seems like more people are on board with the idea that if there's both an Applicative and Monad instance, then (<*>) = ap should hold, so if you're one of those people, you can say that liftM2 = liftA2 whenever both are defined.
08:16:56 <Cale> GHC 7.10 is out btw
08:17:02 <Cale> (and lambdabot is using it)
08:17:45 <joncol> ion> https://gist.github.com/dmalikov/1493055
08:18:04 <Cale> You're technically allowed to define an instance of Monad which doesn't agree with the Applicative instance on the same type, but the notion that this might be a good idea doesn't sit well with some people, so I dunno.
08:18:14 <joncol> I already did the exercises, but I wanted to figure out that werid looking pointfree style.
08:18:44 <maerwald> joncol: it doesn't give you much of a benefit to understand it, except that it enables you to write bad style as well
08:18:53 <Cale> Yeah, you can imagine that each of those compositions is just an fmap
08:19:26 <ion> joncol: It‚Äôs just mechanically obfuscated, you can mechanically unobfuscate it with @unpl.
08:19:29 * hackagebot cmdargs 0.10.13 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.10.13 (NeilMitchell)
08:19:32 <joncol> maerwald> define benefit :)
08:19:52 <Cale> (deferring the application of flip apple until after yet another argument is supplied to furry'/banana2/banana3)
08:21:20 <joncol> ion> Yeah, but it seems there is an idiom for (f .) . 
08:21:25 <joncol> Which is interesting
08:21:38 <ion> It‚Äôs an idio-something alright. :-P
08:21:44 <Cale> wow
08:21:54 <Cale> such opinions :)
08:21:56 <joncol> :)
08:22:23 <Cale> I actually consider (f .) . g less bad than using flipped application
08:23:23 <Cale> Like, when people define stuff like  x & f = f x
08:24:07 <ystael> Cale: the & makes me read that as "unseen horror, demon lord, toadstool"
08:24:41 <exio4> one idiom I do like, though, is something <&> \x -> .....
08:24:44 <ion> I should play that game again. I haven‚Äôt played for ages.
08:31:07 <c_wraith> Cale: & is in base as of ghc 7.10.  Does that make it worse or better?
08:31:22 <Cale> c_wraith: It makes base worse
08:32:13 <quchen> Wait, what? (&) made it to Base?
08:32:24 <ion> @type (Prelude.&)
08:32:26 <lambdabot>     Not in scope: ‚ÄòPrelude.&‚Äô
08:32:26 <lambdabot>     Perhaps you meant one of these:
08:32:26 <lambdabot>       ‚ÄòPrelude..‚Äô (imported from Prelude),
08:32:28 <quchen> I thought I read the changelog multiple times, but I keep being surprised
08:32:36 <bennofs> :t Data.Function.(&)
08:32:37 <lambdabot>     Not in scope: data constructor ‚ÄòData.Function‚Äô
08:32:37 <lambdabot>     Perhaps you meant one of these:
08:32:37 <lambdabot>       variable ‚ÄòData.Function.id‚Äô (imported from Data.Function),
08:32:41 <ion> @type (Data.Function.&)
08:32:43 <lambdabot> a -> (a -> b) -> b
08:34:49 <maerwald> joncol: (.)(.).(.)(.)$(.) <- please give me the type signature. Now you can do it on a paper or just ask GHC. Both is trivial, but one takes longer.
08:35:14 <orion> :t (.)(.).(.)(.)$(.)
08:35:16 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
08:35:39 <maerwald> and if I see someone writing that in actual code...
08:36:29 <maerwald> memorizing bad style patterns is pretty nonsensical to me. I'll just skip the implementation part if it's ugly and focus on the documentation. If the documentation sucks too, then it's probably the wrong library ;)
08:37:59 <joncol> maerwald> Have you tried the exercises? I think they gave me some good understanding (but I'm a beginner at Haskell, never made real programs, just solved exercises).
08:38:54 <joncol> I don't see it as memorizing patterns, but trying to understand the types.
08:39:22 <maerwald> sure, I've done manual type math... but it's as challenging as mental arithmetic
08:39:30 * hackagebot test-invariant 0.4.5.0 - Provide common invariants to be checked with QuickCheck  http://hackage.haskell.org/package/test-invariant-0.4.5.0 (knupfer)
08:39:33 <maerwald> I'd rather use a calculator
08:40:06 <maerwald> :t (.)(.)
08:40:07 <lambdabot> (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
08:40:51 <Cale> That one is perhaps not so obvious, but the type of (.).(.) should be easy to write down, as it's a specialisation of the type of fmap . fmap :)
08:41:16 <quchen> Can I make GHCi dump STG somehow? -ddump-simpl works to give me the final Core dump, but -ddump-stg won't give me an STG dump. :-|
08:41:26 <monochrom> naw, let's go all the way down
08:41:31 <monochrom> @type fmap fmap fmap
08:41:32 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
08:41:35 <hodapp> gah, Ivory docs refers to runState and a 'sets' functions, what the heck is 'sets'?
08:41:54 <maerwald> Cale: that's the point... if it's not obvious, it's not simple... if it's not simple, it's bad, unless you can give good arguments why that complexity is forced on you
08:42:08 <orion> What's the difference between a and a1 in compiler output? I've never understood this.
08:42:25 <maerwald> sorry, I really have a stron opinion on that... but that comes from reading other peoples code :P
08:42:35 <maerwald> obfuscation is not cool
08:42:48 <monochrom> but obfuscation is also subjective
08:43:15 <ion> orion: They‚Äôre just arbitrary names.
08:43:20 <geekosaur> orion, ghc is creating a new type variable because it does not unify with the other
08:43:23 <maerwald> monochrom: yeah, this is not an exact science
08:43:36 <hodapp> oh... it's referring to 'runState' from MonadLib.Monads, not from Control.Monad.State.Lazy.
08:44:01 <monochrom> my more objective definition is first we agree on a specification language and a proof language. then "simpler" = shorter length of proof of correctness.
08:44:09 <joncol> Reminds me of: http://www.infoq.com/presentations/Simple-Made-Easy
08:44:50 <RyanGlScott> Is there a test framework for verifying that certain files don't compile?
08:44:55 <RyanGlScott> Similar to the GHC test suites: http://git.haskell.org/ghc.git/tree/HEAD:/testsuite/tests/deriving/should_fail
08:45:04 <Cale> Yeah, I don't really consider (f .) . g to be really obfuscated to me, but I realise that it's obfuscated to other people.
08:45:43 <Cale> I'm not going to hate you if you use it once or twice in some code that I have to maintain, especially if it helps to pull out some common structure which is taking place.
08:46:24 <orion> geekosaur / ion: But why choose a1 as opposed to b?
08:46:38 <orion> Aren't a1 and b equally different types?
08:46:42 <geekosaur> because ghc tries to stick close to the original type signature
08:46:45 <maerwald> Cale: it starts with little things
08:47:05 <geekosaur> so if the signature had an a in it, it will pick a1 to indicate that this is a different a
08:47:13 <orion> I see.
08:47:24 <geekosaur> it's not the bname that is significant in any case; it's the fact that it cannot find a way to use the existing a there
08:47:52 <joncol> maerwald> you code in Haskell for a living?
08:48:29 <maerwald> joncol: I don't have a job
08:49:07 <joncol> maerwald> OK.
08:49:08 <maerwald> joncol: I code it for fun, some computational geometry and I've contributed to darcsden
08:49:15 <joncol> Nice
08:49:34 <joeyh> "Moreover, UniqFM (which is built on Data.IntMap) is strict, so the fiddling is done eagerly." -- https://ghc.haskell.org/trac/ghc/ticket/10370#comment:13
08:49:45 <joeyh> amusing in light of the recent reddit thread on strictness
08:50:02 <orion> joeyh: URL to reddit thread on strictness?
08:50:21 <maerwald> joncol: sometimes I am worried about the "style culture" of haskell. Last time I looked at the leksah source code (awesome project!) and I didn't find any comments.
08:50:25 <joeyh> https://www.reddit.com/r/haskell/comments/36s0ii/how_do_we_all_feel_about_laziness/
08:50:27 <maerwald> same for the darcs source code
08:50:41 <orion> joeyh: I love how they use the word "we".
08:50:55 <maerwald> now I'm not always sure what the reason is people don't care about it... I've heard haskellers say "my implementation should be obvious enough, don't need documentation"
08:51:56 <maerwald> and if I see people playing with 'pointfree' I get nervous ;)
08:52:03 <hodapp> I've been a bit disappointed at the comments (or lack thereof) in some Galois libraries such as Ivory and Copilot.
08:53:02 <hodapp> and I'd gladly *write* some documentation to help, but that can be very tough without a good idea of what's going on.
08:53:10 <hodapp> nonetheless I've been using Ivory for the past few months.
08:53:51 <maerwald> hodapp: yeah, I can understand though if people omit "pseudo-code", because most of the time... it's almost the same as your implementation in haskell ;)
08:53:54 <Cale> maerwald: Comments are like types that the compiler doesn't check, right? :)
08:54:08 <maerwald> Cale: no
08:54:17 <joncol> maerwald> is the idea that you should be able to reach such levels of haskell guruness that comments aren't needed?
08:54:24 <hodapp> maerwald: This isn't about omitting pseudo-code, it's about omitting most comments and in-code documentation.
08:54:45 <Cale> I'm half joking.
08:55:00 <maerwald> joncol: which ones idea?
08:55:18 <joncol> maerwald> those that write the code without comments...
08:55:31 <maerwald> joncol: I think it's a mix of laziness and arrogance
08:55:34 <hodapp> hrmph. It seems I cannot use 'lift' if my monad has two type parameters, not one...
08:56:19 <maerwald> joncol: it certainly doesn't help raising popularity of haskell
08:56:28 <Cale> People could generally do a better job of documenting code, depending on what sort of code it is.
08:56:58 <Cale> Things with a highly polymorphic type often end up having few potential implementations, and there's not a lot you can say in English which is going to help.
08:58:09 <Zemyla> Cale: Kind of like how there's only one function a -> a?
08:58:22 <Cale> Zemyla: yeah
08:58:49 <joncol> That was something cool I got from Tonys Morris' exercises. You just get a type and a strange name (furry, banana, Misty etc), and then you have to implement the method. No problem description, just the type.
08:59:03 <maerwald> joncol: but there are a few interesting "obfuscations", e.g.
08:59:03 <maerwald> > join (+) 4
08:59:05 <lambdabot>  8
08:59:21 <ew0000> I have a function much like: sum :: Int -> Int -> Int
08:59:32 * hackagebot pontarius-xmpp 0.4.2.1 - An XMPP client library  http://hackage.haskell.org/package/pontarius-xmpp-0.4.2.1 (PhilippBalzarek)
08:59:35 <ew0000> how can I make so it works on strings in the most elegant manner?
08:59:50 <ew0000> (convert strings to Ints , sum then convert back?)
08:59:56 <joncol> maerwald> Yes I thought about that the other day. Really interesting!!
09:00:06 <Cale> ew0000: What would you like to have happen if the parsing fails?
09:00:21 <maerwald> joncol: and that one actually teaches you something... 
09:00:36 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
09:00:39 <ew0000> get a Nothing, maybe
09:00:39 <lambdabot>  ("hello","olleh","HELLO")
09:01:04 <ew0000> sumStr :: String -> String -> Maybe String
09:01:42 <ew0000> I'm trying to learn Control.Applicative
09:01:43 <ew0000> xD
09:02:04 <joncol> maerwald> Yes. But (f .) . g also tought me something.
09:02:05 <maerwald> ew0000: https://www.seas.upenn.edu/~cis194/fall14/spring13/lectures/10-applicative.html
09:02:22 <Zemyla> :t \f g -> (f .) . g
09:02:22 <Cale> ew0000: In that case, perhaps  liftA2 (+) (readMaybe s1) (readMaybe s2)
09:02:24 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
09:02:24 <exio4> \s1 s2 -> (show . sum) <$> readMaybe s1 <$> readMaybe s2 -- something like this? 
09:02:36 <Cale> ah, right, you also wanted to show the result
09:02:52 <exio4> \s1 s2 -> (show .) . (+) <$> readMaybe s1 <*> readMaybe s2
09:03:03 <Cale> ^^ just to piss off maerwald  :D
09:03:09 <maerwald> pff
09:03:31 <exio4> Cale: exactly! ;P
09:03:42 <maerwald> joncol: you mean that you shouldn't use it? ;)
09:04:03 <ew0000> wat
09:04:22 <Cale> relevant to the discussion about comments: http://r6.ca/blog/20120708T122219Z.html
09:04:29 <joncol> maerwald> :).
09:06:03 <maerwald> Cale: he's confessing about not "testing" his code, I don't see a reference to documentation
09:06:04 <ew0000> readMaybe?
09:06:16 <ew0000> where is this function? hoogle can't find it
09:06:21 <exio4> ew0000: Text.Read
09:06:31 <exio4> it's basically Read a => String -> Maybe a
09:06:31 <Geraldus> Hi everybody!
09:06:39 <orion> Geraldus: Hi Dr. Nick!
09:06:54 <Cale> maerwald: Yeah, but this applies to documenting the implementation as well. If you wrote the implementation by following the types alone and didn't actually understand what you wrote, what comment do you write? :)
09:07:05 <orion> What is a rule firing? What practical information does -ddump-rule-firings tell me?
09:07:16 <maerwald> Cale: haha, exactly that: --| No idea what I am doing here, but it type-checks.
09:07:18 <Cale> -- this is so simple that it could not possibly be wrong given that it typechecks
09:07:34 <Geraldus> I want emded text from file to some var of Text type on compile time. How can I achieve this?
09:07:38 <tommd> orion: Some rules are critical for performance.  If they don't fire it is good to know sometimes.
09:07:40 <Cale> But if that's the case for everything in your library... it would get tedious to read :)
09:07:51 <maerwald> Cale: and I would object to that... the typechecker is not even half of the bill
09:08:02 <Cale> It depends
09:08:06 <maerwald> yep
09:08:08 <quchen> ew0000: http://lpaste.net/133120
09:08:16 <exio4> you normally try to make the types tell more about your problem
09:08:27 <Cale> For some libraries, the typechecker does 90% of the work of making sure everything is okay.
09:08:43 <exio4> such that the types restrict the possible implementations of such function to something that's "obviously" correct 
09:08:49 <ion> instance Num String where ...
09:08:58 <c_wraith> ion: acme-php has that!
09:08:58 <maerwald> Cale: yeah, but you can implement algorithms in a broken way, although they typecheck
09:09:08 <ion> c_wraith: Haha, i was just checking out if it has it.
09:09:10 <albeit> If I call an IO action multiple times, and in the action it computes some lengthy value, will it "save" that fully evaluated value for future runs?
09:09:10 <Cale> If your types are full of String and Integer values, then sure, you probably have bugs.
09:09:17 <enthropy> Geraldus: did you try https://hackage.haskell.org/package/file-embed-0.0.8.2 (it's ByteString however)
09:09:19 <quchen> let twice x = x*3 -- classical example
09:09:27 <ion> thrice x = x*4
09:09:31 <Cale> If they're more type variables than other stuff, it starts to be hard to be wrong and compiling at the same time.
09:09:39 <c_wraith> man, the acme-php package is proof that haddock *really* needs to document orphan instances
09:10:00 <ion> albeit: Give the result value a name and refer to that.
09:10:02 <quchen> Cale: I spent half an hour writing a test that should fail when nonsensical input comes in the other day. I eventually gave up when none of the test cases would typecheck.
09:10:32 <albeit> ion: Well I actually don't want the fully evaluated value... I'm trying to time it with criterion and I want it be re-evaluated each call.
09:10:39 <maerwald> Cale: the point is that the typechecker doesn't know about logical errors (aside from non-matching types)... this sounds obvious, but I sometimes think people overrate the typechecker
09:10:55 <c_wraith> albeit: you'll have to make it a function to get it to recalculate in criterion.
09:10:57 <exio4> maerwald: that's the point of adding "more logic" to the types!
09:11:05 <Geraldus> enthropy: this is almost what I need. Thank you. I tried to play with `quoteFile` and quasi quoters from Text.Shakespreare.Text module, but without much luck
09:11:05 <maerwald> exio4: liquid haskell!
09:11:07 <Cale> maerwald: Well, I dunno. It depends on what you consider a "logical error"
09:11:30 <exio4> maerwald: dependent types!? .. :P
09:11:32 <maerwald> Cale: a sorting algorithm that doesn't sort?
09:11:38 <Cale> maerwald: I've had the incorrectness of a graph traversal (it wouldn't have reached all the nodes) pointed out by the type system before.
09:11:45 <quchen> maerwald: In a deep sense, the typechecker *only* knows about logical type errors. The logic known to it is given by the types. Every error not caught by this is orthogonal to the logic given to the program in a sense.
09:11:46 <albeit> c_wraith: What do you mean by that? The length computation is a separate function... I'm just trying to time it as part of a larger computation.
09:12:44 <Cale> maerwald: Of course, this is also why we want to move toward dependent type systems, because they let you encode pretty much anything in your types.
09:12:48 <monochrom> liquid haskell is not very dependent types. it is more just predicate subtypes aka refinement types.
09:12:52 <c_wraith> albeit: I mean that criterion has no trouble with recalculating the result of a function call..  But it's very bad at recalculating a value, since the whole point of lazy evaluation is that that you don't recalculate the same value.
09:13:03 <maerwald> exio4: yeah, liquidhaskell needs some work to scale properly... you can break it with a few nested lists :P but that's partly due to the fact how GHC expands those things
09:13:32 <c_wraith> liquid haskell is a narrow kind of dependent typing.  But it's sufficiently broad to seem likely to be useful.
09:13:49 <Cale> albeit: Can we see your program?
09:14:05 <Cale> albeit: Functions are not automatically memoised.
09:14:12 <maerwald> c_wraith: did you see the boston talk about liquidhaskell? I found the part about checking pointers particularly interesting
09:14:21 <Cale> albeit: But if you have constant expressions, sometimes GHC will lift them out and not recompute them.
09:14:33 * hackagebot aeson 0.8.1.1 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.8.1.1 (BryanOSullivan)
09:15:07 <enthropy> Geraldus: well you can make a variation on https://hackage.haskell.org/package/file-embed-0.0.8.2/docs/src/Data-FileEmbed.html#bsToExp which is just "stringE . B8.unpack :: Bytestring -> Q Exp"
09:16:12 <albeit> Cale: Here is the code... http://lpaste.net/133122. The "renderFixConstruct" takes ~20us by itself, but when I time buildFixMessage it takes ~1us, and I'm guessing because eMsgBS is being "cached"
09:16:17 <chishiki> http://sprunge.us/JBHi help
09:16:22 <enthropy> err, I guess just $(stringE =<< runIO (readFile "bigTextFile.txt")) with -XOverloadedStrings might be efficient at runtime (even if the IO at compile time is with String)
09:17:05 <albeit> Cale: And in criterion, buildFixMessage is tested with nfIO and runStateT, with the same state/FixEngine being provided
09:17:21 <albeit> So eMsgBs should always be the same
09:18:15 <Cale> chishiki: Make sure that the putStrLn starts in a deeper column than the f in "foo"
09:19:09 <chishiki> Cale: lel ok. i didnt know it was sensitive to whitespace. ty
09:19:34 * hackagebot second-transfer 0.5.0.0 - Second Transfer HTTP/2 web server  http://hackage.haskell.org/package/second-transfer-0.5.0.0 (dsign)
09:19:40 <Cale> chishiki: Also, it's generally a better idea to put all your definitions in a file and load it with ghci. You can quickly reload your file with :r
09:19:57 <Cale> chishiki: Having a separate window for your text editor makes this process pretty smooth
09:20:27 <Cale> albeit: hmm, eMsgBS depends on construct though, which depends on the result of the previous action.
09:20:37 <chishiki> Cale: i have been doing that mostly. i opened another instance of ghci beside my browser to test something and it wasnt working
09:20:52 <Welkin> ghci is only good for one-liners
09:21:14 <albeit> Cale: Yes, which I why it thought would be okay. Only reason I can think is since I'm passing it the same FixEngine with runStateT, its saving the result of construct / getStandardTags too? Like everything is being saved?
09:21:29 <mjrosenb> Is there a function that gives the number of seconds since the eposh started?
09:21:40 <Welkin> epoch?
09:22:05 <joncol> maerwald> Had to re-derive that join (+) stuff :). Does anyone use that as an idiom? Seems useful for "duplicating" an argument.
09:22:29 <indiagreen> mjrosenb: I suppose it could be getPOSIXTime
09:22:32 <maerwald> joncol: so how would you write (+) more verbose in this case?
09:22:50 <Cale> joncol: I use it in some cases.
09:23:07 <Cale> Nothing too complicated, but there are times that it's handy
09:23:16 <Cale> Another function which is nice to be aware of is  ap (,)
09:23:22 <joncol> maerwald> What do you mean? join (+) = \x -> x + x
09:23:31 <Cale> > map (ap (,) (^2)) [1..10]
09:23:32 <Ainieco> hello
09:23:33 <lambdabot>  [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
09:23:47 <athan> Hey all. Has anyone here done much parsing of lambda expressions? I'm a noob at this, can't seem to wrap my head around how it "should" be. Here's what I have so far: http://lpaste.net/133123
09:23:50 <Ainieco> we have Applicative as superclass of Monad, right?
09:23:55 <Cale> Ainieco: yes
09:24:05 <Ainieco> Cale: why do we still have pure and return then?
09:24:09 <maerwald> joncol: I mean: join (\y -> (\x -> x + y))
09:24:14 <Cale> Ainieco: why wouldn't we?
09:24:19 <maerwald> unless I mixed up the order
09:24:20 <ion> Ainieco: Backwards compatibility
09:24:24 <Welkin> mjrosenb: getCurrentTime, then use utcTimeToPOSIXSeconds
09:24:43 <athan> Cale: lol
09:24:45 <Ainieco> ion: okay
09:24:53 <Ainieco> Cale: we don't need them both 
09:25:26 <Welkin> mjrosenb: ah, there is a getPOSIXTime
09:25:34 <joncol> Cale> THanks. Have to think about that one :)
09:25:38 <Cale> Ainieco: pure is part of the Applicative structure, return is part of the Monad structure. It's always valid to define pure = return, but I'm not sure it's necessary.
09:27:04 <mjrosenb> indiagreen: Welkin what module is that in?
09:27:36 <indiagreen> Data.Time.Clock.POSIX  
09:27:39 <athan> mjrosenb: Check out fp-complete's hoogle :)
09:27:43 <indiagreen> http://hackage.haskell.org/package/time/docs/Data-Time-Clock-POSIX.html#v:getPOSIXTime
09:27:58 <Cale> Ainieco: There's a comment in the documentations which says that pure ought to be equal to return whenever there's a Monad instance, but I'm not totally convinced I agree with that comment yet.
09:28:15 <Cale> (well, moreso with respect to the following comment that (<*>) ought to be equal to ap)
09:28:26 <Geraldus> enthropy: surely, trying to implement simple Text from file quoter looking at `embed-file` source code
09:29:37 <Cale> There might exist some monads which have a far more useful applicative structure than the one which follows directly from the monad structure, and we might not want to muddy our libraries with newtypes when we weren't planning to use the applicative which was derived from the monad instance.
09:29:49 <monochrom> there is simply the historical reason that Monad was introduced earlier and Applicative much later.
09:29:52 <Cale> I don't have many concrete examples of this though.
09:30:11 <Cale> I have run into it in some fairly involved settings in the past
09:30:12 <athan> Or really, from my example, why does `testParser parseExpr "foo bar"` return only "foo"?
09:30:39 <Cale> Yeah, removing one of pure or return at this point would just break lots of code for absolutely no reason.
09:31:27 <Cale> But I'm not convinced that they should be identified, even modulo historical code.
09:31:45 <dolio> I think if you want things that way, it makes no sense for Applicative to be a superclass of Monad.
09:31:56 <dolio> They would be unrelated.
09:32:12 <Cale> Well, *if* you have a Monad structure, then you certainly have *at least one* Applicative structure.
09:32:17 <dolio> Because whether you use just Monad, or both Monad and Applicative is important information.
09:32:30 <joncol> maerwald> OK, I think I agree with you that (+) is nicer than \x -> (\y -> x + y)
09:32:41 <monochrom> athan, "foo bar" fits two cases: your EVar case and your EApp case. however, you put the EVar case first, so the computer goes for it.
09:32:42 <maerwald> joncol: I didn't even say that :P
09:32:44 <Cale> dolio: You do have a point there though.
09:33:11 <dolio> So, inasmuch as they are now related by subtyping, they need to agree.
09:33:24 <Cale> Do they really need to?
09:33:30 <athan> monochrom: Hmm, okay, sorry about this I am iPleb
09:33:32 <Cale> I don't think that immediately follows.
09:33:39 <maerwald> joncol: \x -> (\y -> x + y) actually resembles the type signature of join pretty nice: m (m a)
09:33:51 <maerwald> and it's instantly clear what's happening
09:33:56 <Cale> If we all really wanted to, we could decide that even when something happened to be a Monad, we should be picky about whether we're using the Applicative or Monad operations.
09:34:07 <Cale> Even in the presence of the superclass constraint.
09:34:13 <monochrom> I would not have a case for EApp --- not on the same level as other cases. I would, instead, use sepBy or sepBy1 for EApp, and put that one level above.
09:34:25 <Cale> Right?
09:34:50 <Cale> Just delete the comment that pure = return and (<*>) = ap, and technically, we all still have to pay attention.
09:34:52 <athan> monochrom: Hmm, okay. Thank you :)
09:35:01 <dolio> But relevant information is not communicated.
09:35:19 <joncol> maerwald> True
09:35:30 <Cale> There's plenty of relevant information which is already not communicated by the definition of the classes.
09:35:47 <Cale> (in particular, the laws)
09:35:57 <maerwald> joncol: while join (+) leaves you with a question mark for a few seconds at least... until you understand that the type checker infers that structure on it's own
09:36:06 <Cale> and the superclass constraint on its own doesn't tell us that pure = return
09:36:28 <Cale> From the code alone, and from the compiler's perspective, pure and return might well be unrelated
09:36:40 <maerwald> joncol: and at that point... you could just write x + x :P
09:36:57 <dolio> I mean that you don't get to know when someone's using both without meticulously reading their code.
09:37:16 <Cale> Yeah, that's a downside of having the superclass constraint
09:37:32 <Cale> It tidies up some type signatures, but at the expense that they become less informative.
09:38:04 <dolio> They're not less informative for me.
09:38:18 <dolio> Everything I want to use follows the agreement discipline.
09:38:38 <dolio> Everything is just better for me.
09:38:41 <Cale> Just like when we removed Eq as a superclass of Num, type signatures became more informative.
09:39:17 <joncol> maerwald> join (+) leaves me with a question mark for about 5 minutes :)
09:39:30 <athan> hmm. monochrom: http://lpaste.net/133125 still only gives me "foo" :\
09:39:53 <Cale> joncol: Well, in general  join x = do u <- x; v <- u; return v
09:40:11 <Cale> joncol: and in the function monad instance, "running" a function means applying it to the parameter
09:40:12 <joncol> Until I rederive everything from the monad (>>=) and the fact that join x = x >>= id.
09:40:22 <Cale> e.g.
09:40:38 <athan> monochrom: And if I place the 
09:40:40 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
09:40:42 <athan> erp -
09:40:42 <lambdabot>  ("hello","olleh","HELLO")
09:40:43 <maerwald> joncol: after 2 minutes I'd move from just reading the type signature to actually reading the implementation of join
09:40:48 <maerwald> @src join
09:40:48 <lambdabot> join x = x >>= id
09:41:00 <athan> if I place the EApp  case before the EVar case, I get a loop :\
09:41:02 <maerwald> so yeah, we just retrieve the inner (x + x)
09:41:38 <maerwald> joncol: upps, yeah
09:41:44 <maerwald> you beat me to it
09:41:50 <Cale> > (do plusN <- (+); r <- plusN; return r) 5
09:41:53 <lambdabot>  10
09:42:12 <Cale> So here, plusN gets bound to the function (+) 5
09:42:25 <Cale> and then r gets bound to plusN 5
09:42:30 <Ainieco> why Functor isn't called Mappable while Traversable isn't called after some abstract thing?
09:42:53 <dolio> Anyhow, if you ask me. Yes, it _needs_ to agree, or it _needs_ to not be related by subtyping. Because that's what subtyping is for. Being able to use one structure for another and get the same result. Not for 'there exists structure that agrees, but I'm going to do something else.'
09:43:04 <Cale> Ainieco: Because there wasn't a suitable 50 years worth of category theory to base the definition of Traversable on.
09:43:10 <dolio> The latter sounds like it might be even worse that what most languages do when they get subtyping wrong. :)
09:43:44 <Cale> Ainieco: Naming Functor "Mappable" or Monad "WarmFuzzyThing" would make it harder to search for relevant information.
09:44:47 <Cale> Ainieco: This is why I'm hesitant about the Foldable/Traversable stuff going in the Prelude.
09:44:55 <Cale> Well, I'm more hesitant about Foldable
09:45:09 <Cale> I think it's kind of a junky type class
09:45:18 <dolio> What's a more abstract name for Traversable?
09:45:51 <monochrom> athan: foldl1 EApp <$> sepBy1 space (the 3 cases of EVar, EAbs, and parentheses)
09:46:28 <athan> monochrom: Oh!!! Agh, sorry! Thank you so much
09:46:51 <dolio> Also, if you don't like Folable, I think you also shouldn't like Traversable. :)
09:47:00 <ozdy> Haxe >> Haskell
09:47:08 <dolio> Traversable is a categorification of Foldable, or something like that.
09:48:36 <monochrom> but I wrongly ordered "space" and "(the 3 cases of EVar, EAbs, and parentheses)"
09:49:20 <dolio> Or if you take the contrapositive, if you like Traversable, you should like Foldable, because they're deeply related.
09:52:48 <maerwald> joncol: tbf, you'd actually have to look at the (->) instance of monad to see what (>>=) does, otherwise it's still just guesswork what happens
09:54:51 <whittle> > type Factorization = Integral a => [(a, a)]
09:54:53 <lambdabot>  <hint>:1:1: parse error on input ‚Äòtype‚Äô
09:55:31 <athan> monochrom: heck yeah it works :) thank you!!!
09:59:38 <joncol> maerwald> Yes, the (-> t) instance even :)
09:59:46 <mmachenry> I'm trying to use HSpec to say (myExpression `shouldThrow` (==BlockedIndefinitelyOnSTM)) but BlockedIndefinitelyOnSTM is not an instance of Eq. How can I make a predicate out of this?
10:01:03 <RickP> do you have any good reading material about the relationship between mtl typeclasses and the monads themselves? Such as "IO a" and "(MonadIO m) => m a"? I'm trying to abstract away the structure of my monad stack by writing functions using Monad* type constraints but I'm having trouble when I call functions that call explicit Monads (e.g. tryIOError in a MonadIO function)
10:01:26 <RickP> that return* explicit Monads, sorry
10:01:27 <mmachenry> This is the best I've been able to do.  (\e->let _ = e::BlockedIndefinitelyOnSTM in True)
10:01:36 <joncol> maerwald> Oops, that should be "the ((->) t) instance even" :) :)
10:01:58 <maerwald> joncol: yep, edward explains it here https://stackoverflow.com/questions/5310203/how-to-use-instances-of-monad-and-confusion-about
10:02:06 <ion> mmachenry: myExpression `shouldThrow` (const True :: BlockedIndefinitelyOnSTM -> Bool)
10:02:08 <c_wraith> mmachenry: (const True :: BlockedIndefinitelyOnSTM -> Bool)
10:02:17 <maerwald> joncol: not the accepted answer... scroll down to edwards
10:03:33 <whittle> I‚Äôm sharpening my Haskell against Project Euler, and I‚Äôd like to create a type synonym with a typeclass: "type Factorization = Integral a => [(a, a)]". GHC 7.10, being the helpful compiler it is, tells me that type is illegal, and that I should consider using RankNTypes or Rank2Types. I‚Äôm reading about higher-rank types right now, but I don‚Äôt understand how they connect to a type synonym that‚Äôs polymorphic
10:03:33 <whittle>  over a typeclass. 
10:03:35 <joncol> maerwald> Cool. Thanks. I've got to go. But see you later! (g .) . h
10:03:40 <mmachenry> c_wraith, ion: Really? That's basically what I had but I figured there'd be a better way. :(
10:04:18 <whittle> (Also does ‚Äúpolymorphic over a typeclass‚Äù mean what I think it means? 
10:04:26 <benzrf> whittle: i believe so
10:04:40 <benzrf> whittle: what do you know about rank 2 types?
10:05:17 <ion> mmachenry: When GHC 7.12 is released, const True . (:: BlockedIndefinitelyOnSTM)
10:05:18 <RickP> how about a more concrete example? how do i get this to typecheck? http://lpaste.net/105919498451681280
10:05:36 <albeit> When compiling, the "Loading package... done" messages were going to be able to be turned off in some new release... has that release happened?
10:05:41 <whittle> benzrf: They allow you to introduce explicit quantification? 
10:06:59 <benzrf> whittle: not quite
10:07:23 <benzrf> whittle: well, do you know the difference between "forall a. a -> Int" and "(forall a. a) -> Int"
10:07:48 <ion> RickP: You‚Äôll need to use the MonadError methods instead of a concrete EitherT. Something along the lines of: >>= either throwError pure
10:09:15 <RickP> ion: thanks, i'll take a look. any good guidelines about when you should prefer a concrete stack as opposed to Monad* type constraints? I feel like I am going overboard with it :-)
10:10:00 <ion> RickP: I guess it depends on which seems better to you at the time.
10:10:26 <whittle> benzrf: As far as I have understood, it allows you to delay binding of type variables. So no, not really. Should I just try to learn System F, or is there a gentler way into these mysteries? 
10:11:23 <benzrf> whittle: i mean
10:11:28 <benzrf> whittle: i can explain here and now :)
10:11:36 <whittle> benzrf: That would be amazing. 
10:12:18 <benzrf> whittle: no problem!
10:12:46 <benzrf> whittle: basically... when you see a type where the outermost node of its type-expression tree is a forall
10:14:23 <benzrf> whittle: any value with that type also has any type that you can get by instantiating the quantified variables
10:14:57 <benzrf> whittle: so consider, e.g., the type "forall a. (a -> Int)" (which is the same as "forall a. a -> Int)
10:14:59 <benzrf> "
10:15:06 <orion> In WAI/Warp, are you expected to set the Content-Length yourself?
10:15:19 <benzrf> whittle: if f :: forall a. (a -> Int), then also f :: String -> Int
10:16:03 <jarvi> getCurrentTime is slow, because UTCTime is implemented as a Integer.
10:16:56 <benzrf> whittle: following?
10:17:40 <whittle> benzrf: So far. 
10:18:18 <benzrf> cool :)
10:18:20 <JagaJaga> can I unite somehow concatMap and filter to avoid extra traversing of a list?
10:18:55 <whittle> (Thank you for slowing down for me.)
10:19:03 <ion> ‚Äúf :: forall a. a -> Int‚Äù is like (pseudo syntax) ‚Äúf :: (a :: *) -> a -> Int‚Äù where the invoker gets to dictate the *type* a. In the pseudo syntax, a call could look like ‚Äòf String "hello" :: Int‚Äô. (‚Äúx :: exists a. a‚Äù ‚Äì which Haskell does not have ‚Äì is like (again, pseudo syntax) ‚Äúx :: ((a :: *), a)‚Äù, a possible value would be ‚Äòx = (String, "hello")‚Äô.)
10:19:38 * hackagebot jsontsv 0.1.5.0 - JSON to TSV transformer  http://hackage.haskell.org/package/jsontsv-0.1.5.0 (DanielChoi)
10:19:43 <bennofs> JagaJaga: uniting filter g . concatMap f  or concatMap f . filter g?
10:19:59 <benzrf> whittle: no prob
10:20:08 <benzrf> whittle: so the type "(forall a. a) -> Int" has -> as its outermost node the application of (->)
10:20:10 <JagaJaga> bennofs: filter f . concatMap g
10:20:15 <benzrf> whittle: meaning that it's a monomorphic function type
10:20:25 <fvgvxmpv1> I¬¥m writing a tool to track a large set of tagged objects (Tags are [Data.Text.Text] for now) - I want to have a function to search through my objects based on tags; Is there a prebuild solution for things close to this? I would look into Xapian, were I using C
10:20:26 <bennofs> JagaJaga: isn't that just concatMap (filter f . g) ?
10:20:28 <benzrf> whittle: it takes a value of type "forall a. a" and gives an Int
10:20:57 <fvgvxmpv1> (I really need an index ‚Äî my collection is quite large)
10:20:58 <JagaJaga> bennofs: hmmm..
10:21:52 <JagaJaga> bennofs: sure, you are right,thank you :D
10:22:36 <JagaJaga> bennofs: but can we unite `sortBy cmp . filter f`?
10:22:44 <whittle> benzrf: It‚Äôs monomorphic because it doesn‚Äôt get to make any decisions about the types? 
10:23:23 <benzrf> whittle: because it has exactly one type
10:23:55 <whittle> benzrf: It‚Äôs monomorphic, but its first argument is polymorphic? 
10:24:09 <benzrf> er, well
10:24:09 <benzrf> you cant specialize it at all
10:24:09 <benzrf> whittle: if you have a value of "(forall a. a) -> Int", there is no more specific type you can use it as
10:24:29 <whittle> benzrf: Okay, that make sense. 
10:24:46 <benzrf> whittle: right
10:25:09 <benzrf> whittle: the type of the value you pass to the function is polymorphic
10:25:17 <benzrf> whittle: but the /function/'s type is not polymorphic
10:25:47 <benzrf> whittle: on the other hand, "forall a. Int -> a" is equivalent to "Int -> forall a. a"
10:25:56 <benzrf> whittle: can you see why?
10:27:24 <benzrf> whittle: well. depending on the specifics of your type system they might not be quite equal, but you can get something of one type from the other easily
10:28:16 <whittle> benzrf: Because the firs thing you have to do with type "forall a. Int -> a" is determine the concrete type of a? 
10:28:41 <whittle> s/firs/first/
10:29:21 <benzrf> whittle: well
10:29:51 <benzrf> whittle: with forall a. Int -> a, you pick any type you want to fill in "a" with, then you put in an Int and get something of the type
10:30:08 <benzrf> whittle: with Int -> forall a. a, you put in an Int and then pick any type you want the resulting thing to be
10:30:31 <jackhill> Hi, I wrote a little function returns an IO action that I can use to read passwords on the command line: http://lpaste.net/133129
10:30:47 <jackhill> Can someone critique it?
10:30:47 <benzrf> whittle: you're just flipping which order you do stuff in
10:31:28 <benzrf> whittle: i gotta go, soz :I
10:31:32 <benzrf> be back l8r
10:31:36 <benzrf> hope that helped :)
10:31:39 <whittle> benzrf: With a function of either type, the caller determines the concrete type of a. 
10:31:44 <benzrf> whittle: yeah
10:31:48 <whittle> benzrf: That was phenomonally helpful. 
10:31:52 <benzrf> whittle: thanks !
10:31:54 <whittle> benzrf: Thank you so much. 
10:31:54 <benzrf> see you
10:31:56 <mauke> jackhill: doesn't reset echo state in case of an exception
10:31:58 <benzrf> no problem :)
10:31:59 <whittle> benzrf: Take care. 
10:32:03 <benzrf> you too
10:33:07 <ion> jackhill: See bracket
10:33:21 <jackhill> mauke: for example if hGetLine fails?
10:33:27 <mauke> jackhill: yeah
10:33:50 <jackhill> ion: https://wiki.haskell.org/Bracket_pattern ?
10:33:51 <mauke> bracket (hGetEcho h) (hSetEcho h) (hSetEcho h False >> hGetLine h)
10:34:14 <mauke> oh, the last one needs \_ ->
10:34:52 <jackhill> mauke: thanks!
10:36:32 <jackhill> In addition to understanding how to write this myself :) Is there already a library function that will read passwords that I should use rather than my own when I'm done learning from this exercise?
10:36:56 <ion> Probably
10:37:26 <ion> http://hackage.haskell.org/package/haskeline-0.7.2.1/docs/System-Console-Haskeline.html#v:getPassword for something fancy
10:37:43 <ion> That one will leak the length of the password though.
10:37:59 <jackhill> ah thanks
10:43:41 <rien__> how do I map a function f :: a -> IO [a]  over a value IO [a] ? I'm getting confused combining liftM and mapM?
10:44:32 <mauke> not liftM
10:44:54 <mauke> m >>= mapM f
10:44:56 <exio4> @type \f -> fmap concat . mapM_ f
10:44:57 <lambdabot>     Couldn't match type ‚Äò()‚Äô with ‚Äòt0 [a]‚Äô
10:44:58 <lambdabot>     Expected type: t a1 -> f (t0 [a])
10:44:58 <lambdabot>       Actual type: t a1 -> f ()
10:45:04 <exio4> @type \f -> fmap concat . mapM f
10:45:05 <lambdabot> (Monad f, Traversable t) => (a1 -> f [a]) -> t a1 -> f [a]
10:45:43 <rien__> I've only found this to work: join $ liftM (mapM f) v
10:46:17 <mauke> join liftM is >>=
10:46:42 <rien__> mauke: yep you're absolutely right
10:47:13 <rien__> mauke: your v >>= mapM f does the same as my awkward join $ liftM (mapM f) v
10:47:17 <rien__> thanks!
10:47:49 <ion> @type (fmap . fmap) (undefined :: a -> IO [a]) (undefined :: IO [a])
10:47:50 <lambdabot> IO [IO [a]]
10:47:57 <ion> @type (fmap . fmap) (undefined :: a -> IO [a]) (undefined :: IO [a]) >>= sequence
10:47:59 <lambdabot> IO [[a]]
10:48:43 <ion> Just toying
10:49:14 <dgpratt> I think I would like to play around with doing Haskell dev on Nix/NixOS
10:49:55 <dgpratt> but oy, it looks like there's a lot to figure out
10:52:04 <dgpratt> it's the same thing every time I want to learn anything sufficiently complicated -- the nagging feeling that I'm following a now-abandonded path that will soon lead to nowhere
10:52:44 <dgpratt> someone needs to make a GC for the internet
10:54:12 <ew0000> I have another one: How do I split a list into lists of the same size
10:54:47 <ew0000> split 2 [1..9] becomes [[1,2], [3,4], [5,6], ...
10:54:57 <Cale> ew0000: map (take n) . takeWhile (not . null) . iterate (drop n)  will work, but you can also find this as chunksOf n in the split package
10:55:11 <ew0000> that was quick
10:57:43 <ion> > unfoldr (\xs -> case splitAt 2 xs of ([],_) -> Nothing; res -> Just res) [1..9]
10:57:45 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9]]
10:58:56 <Cale> > iterate (drop 2) $ [1..9]
10:58:58 <lambdabot>  [[1,2,3,4,5,6,7,8,9],[3,4,5,6,7,8,9],[5,6,7,8,9],[7,8,9],[9],[],[],[],[],[],...
10:59:06 <Cale> > takeWhile (not . null) . iterate (drop 2) $ [1..9]
10:59:08 <lambdabot>  [[1,2,3,4,5,6,7,8,9],[3,4,5,6,7,8,9],[5,6,7,8,9],[7,8,9],[9]]
10:59:15 <Cale> > map (take 2) . takeWhile (not . null) . iterate (drop 2) $ [1..9]
10:59:17 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9]]
10:59:40 * hackagebot themoviedb 1.1.0.0 - Haskell API bindings for http://themoviedb.org  http://hackage.haskell.org/package/themoviedb-1.1.0.0 (PeterJones)
11:00:02 <Cale> and yeah, whenever you have something like map f . takeWhile p . iterate g, it's always possible to rewrite it as an unfoldr
11:01:07 <c_wraith> I'm told unfoldr usually inlines the Maybes away these days, but they still feel awkward.
11:04:41 * hackagebot byline 0.2.0.0 - Library for creating command-line interfaces (colors, menus, etc.)  http://hackage.haskell.org/package/byline-0.2.0.0 (PeterJones)
11:05:25 <rien__> I'm still having trouble lifting a zip to go through 2 IO [a] values
11:05:28 <rien__> this works: do { g <- ccGroupPaths ; e <- ccEndpoints ; return (zip g e)}
11:05:36 <rien__> but how do I do that using liftM zip ?
11:06:18 <ion> liftA2 zip ccGroupPaths ccEndpoints
11:06:31 <ew0000> I guess you should use something in Control.Applicative
11:06:36 <ew0000> ah like ion showed =D
11:06:52 <rien__> ion: why choose applicative instead?
11:06:58 <ew0000> its new
11:07:03 <ew0000> and it works with most types
11:07:07 <ew0000> and type classes
11:07:08 <rien__> just to use the most generic possible?
11:07:13 <rien__> ok
11:07:14 <ew0000> and lenses and stuff
11:07:23 <rien__> ion: thanks!
11:07:26 <gensym2> Any quick tutorials to move from Lisp to Haskell?
11:07:47 <ew0000> I like the learnyouahaskellforgreatgood
11:07:49 <ew0000> tutorial
11:07:52 <ion> rien: It‚Äôs not only more generic, for some types the Applicative instance can be inherently more efficient than the Monad instance. For IO, i don‚Äôt expect any difference though.
11:08:11 <ew0000> its not for lisp, but it is very good and it seems up to date
11:08:30 <rien__> ion: got it. interesting that liftA2 is always available but I had to import Control.Applicative to do this: zip <$> ccGroupPaths <*> ccEndpoints
11:08:53 <ion> gensym2: https://github.com/bitemyapp/learnhaskell/blob/master/README.md#how-should-i-learn-haskell
11:09:03 <ion> rien: I don‚Äôt think liftA2 is in Prelude.
11:09:11 <ion> @type Prelude.liftA2
11:09:12 <lambdabot>     Not in scope: ‚ÄòPrelude.liftA2‚Äô
11:09:12 <lambdabot>     Perhaps you meant one of these:
11:09:12 <lambdabot>       data constructor ‚ÄòPrelude.Left‚Äô (imported from Prelude),
11:09:27 <RyanGlScott> rien__: And <$> and <*> are exported by the Prelude as of GHC 7.10.
11:09:37 <joneshf-laptop> isn't there something like `Alternative m => Bool -> m a -> m a` ?
11:09:54 <joneshf-laptop> my hayooing/hoogling isn't coming up with anything
11:09:54 <rien__> RyanGlScott: wow cool. I'm still on 7.8
11:10:06 <joneshf-laptop> sort of like `when`/`unless`
11:10:10 <rien__> ion: you're right, I don't know what was going on in my ghci
11:10:15 <joneshf-laptop> but not unit
11:10:29 <joneshf-laptop> or do i have to roll my own?
11:11:19 <RyanGlScott> joneshf-laptop: What would this function do?
11:11:22 <ion> @type bool empty id
11:11:23 <lambdabot> Alternative ((->) a) => Bool -> a -> a
11:11:30 <ion> whoops
11:11:59 <ion> @type bool empty
11:12:00 <lambdabot> Alternative f => f a -> Bool -> f a
11:12:21 <rien__> did Haskell pick a standard symbol for F#'s x |> f = f x?
11:12:23 <joneshf-laptop> RyanGlScott, behave like one of `unless`/`when` except with an important value
11:12:26 <joneshf-laptop> ion, thanks!
11:12:34 <joneshf-laptop> s/important/non-unit/
11:12:56 <ion> rien: (&) is in Data.Function
11:12:57 <joneshf-laptop> :t (&) -- rien__ 
11:12:58 <lambdabot> a -> (a -> b) -> b
11:14:29 <rien__> ion: thanks! hoogle does not find that
11:14:41 * hackagebot domplate 0.1.0.1 - A simple templating library using HTML5 as its template  language.  http://hackage.haskell.org/package/domplate-0.1.0.1 (AntonEkblad)
11:14:42 <ion> http://hoogle.haskell.org/?hoogle=(%26)
11:15:01 <bennofs> :t bool
11:15:02 <lambdabot> a -> a -> Bool -> a
11:15:16 <bennofs> :t flip $ bool empty
11:15:17 <lambdabot> Alternative f => Bool -> f a -> f a
11:15:28 <bennofs> joneshf-laptop: ^^^ that?
11:15:32 <rien__> ion: once you know the name :) but I did this : https://www.haskell.org/hoogle/?hoogle=a+-%3E+%28a+-%3E+b%29+-%3E+b
11:18:52 <joneshf-laptop> bennofs, yes
11:18:55 <joneshf-laptop> bennofs, thanks
11:21:35 <whittle> dgpratt: I tried, but Google wouldn‚Äôt let me use their reference counter, and there were too many circular structures anyways. 
11:22:00 <dgpratt> :)
11:23:49 <ew0000> hey, is there a way to check haskell documentation from commandline?
11:23:58 <ew0000> hoogle only prints type information
11:24:18 <statusfailed> geekosaur, Cale : thanks for your help yesterday with my static-binary-eating-all-the-memory issue
11:24:29 <statusfailed> It turned out to be glibc version problems in the end
11:24:51 <statusfailed> I built against same glibc and it worked fine
11:25:09 <ion> That‚Äôs a fun problem.
11:25:39 <statusfailed> ion: glibc? 
11:26:17 <ion> A binary eating all the memory because of a libc incompatibility
11:26:33 <Skolopedrion> Hi there
11:26:59 <Skolopedrion> I have a problem in Haskell, so I hope you guys could help me out
11:27:47 <Cale> Skolopedrion: Sure, ask away
11:28:27 <Skolopedrion> Okay, thanks, here's the problem: I'm trying to code a maze generator, so i need to implement a (!) function
11:28:41 <Skolopedrion> so I have a class MazePoint
11:29:03 <Skolopedrion> but i'm trying to instantiate this class on (Int, Int)
11:29:34 <Skolopedrion> but i can't figure out how to do maze ! (x, y) without specifying the type
11:29:35 * geekosaur does not see what having a class MazePoint has to do with needing a (!) function
11:30:22 <Skolopedrion> well my maze is represented by a data structure containning a [[MazeCell]] type attribute
11:30:30 <Skolopedrion> so it's basically a 2D array
11:31:00 <Skolopedrion> that's why I need to get individual cells
11:31:11 <ion> How is the class useful? Why not just [[MazeCell]] -> (Int, Int) -> Maybe MazeCell?
11:31:11 <geekosaur> first off, if you're using lists, you're not using arrays
11:31:18 <Cale> Skolopedrion: Is your problem that it complains when you write  instance MazePoint (Int, Int)? Why is MazePoint a class?
11:31:49 <geekosaur> second, that Array has a (!) operator does not mean you need to use *that* operator, if you are not otherwise using Array
11:31:54 <Skolopedrion> meh, I'm pretty new to Haskell I'm maybe doing it wrong
11:32:08 <geekosaur> there is a tendency to assume typeclasses have something to do with OO classes
11:32:10 <geekosaur> they don't
11:32:13 <fayong> quit
11:32:19 <geekosaur> most of the time, you do *not* want a typeclass
11:33:15 <Skolopedrion> yep, but the problem is that i want to use the (!) operator also with a custom data structure (Position)
11:33:36 <Cale> Well, fair enough
11:33:56 <prsteele> Skolopedrion: (just signed on, so missing context, but) you can prefix the function with the module name, e.g. Map.! or Foo.!
11:34:18 <Skolopedrion> hi prsteele
11:34:30 <Cale> You might want to put some/all of the code on lpaste.net so that we can understand what problem you're having better?
11:34:50 <Skolopedrion> yep you're right
11:37:26 <lpaste> Skolopedrion pasted ‚ÄúMazeGeneratos‚Äù at http://lpaste.net/133137
11:38:02 <Skolopedrion> I have three files, sorry if its a mess
11:41:00 <Cale>     (!) :: Maze -> a => MazeCell -- there's no way this is valid syntax...
11:41:38 <Cale> Does the compiler accept that definition? You have a random => in there where I think you meant to write ->
11:42:01 <Skolopedrion> yeah that was a try
11:42:13 <geekosaur> at least one version of ghc did mistakenly accept it iirc
11:42:18 <Skolopedrion> but no the compilers throws an error
11:42:21 <Cale> instance MazePoint2D (Num, Num) -- do you have a type Num defined somewhere?
11:42:38 <Skolopedrion> isn't it a builtin type ?
11:42:42 <Cale> No, it's a type class.
11:42:43 <geekosaur> typeclass. not type
11:42:44 <prsteele> typeclass
11:42:48 <Skolopedrion> dammit
11:43:16 <Cale> Perhaps you meant Int
11:43:22 <Skolopedrion> At first I tried instance MazePoint2D (Int, Int)
11:43:26 <Skolopedrion> yep
11:43:54 <Skolopedrion> but when i did `maze ! (2, 3)` for example it crashed
11:44:09 <Cale> Crashed?
11:44:39 <Skolopedrion> it throw an error
11:44:45 <Cale> Which error?
11:46:24 <Skolopedrion> its prettt long
11:46:33 <Skolopedrion> so i made a paste here : http://lpaste.net/133138
11:46:48 <Skolopedrion> (forgot to post it on this channel)
11:46:55 <Cale> Right, it couldn't tell that your 2 and 1 were Int values.
11:47:05 <prsteele> Skolopedrion: you probably just want to define (!) as a function
11:47:39 <Skolopedrion> you mean like this ?:  getCell maze, pos
11:47:45 <Skolopedrion> whoops
11:47:53 <Skolopedrion> getCell maze pos = ...
11:48:07 <Cale> Try  maze ! (2 :: Int, 1 :: Int)  and just see if that works.
11:48:28 <Cale> (nevermind that it's annoying for now)
11:48:39 <Skolopedrion> I tried maze ! (2, 1) :: (Int, Int) and that works, thats the same right ?
11:49:05 <prsteele> Skolopedrion: (!) maze cell = ...
11:49:16 <Cale> Not the way you wrote it there it's not, you must have written something a bit different
11:49:32 <Cale> maze ! ((2, 1) :: (Int, Int)) would be
11:49:38 <Skolopedrion> exactly
11:49:46 <Skolopedrion> sorry :/
11:53:11 <Cale> One thing you could do is something like   instance (Integral a) => MazePoint2D (a,a) where maze ! (x,y) = cells maze !! fromIntegral y !! fromIntegral x
11:53:44 <Cale> I think that *might* be less annoying to use...
11:54:15 <SrPx> I'm using ekmett's gl library, version 4.5 (import Graphics.GL.Core45). I've tried compiling a shader with "#version 430 es", but I get the error message (from the gl api): ERROR: 0:1: '' :  version '430' is not supported
11:54:17 <SrPx> Why?
11:54:44 * hackagebot diagrams-haddock 0.3.0.3 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.3.0.3 (jeffreyrosenbluth)
11:54:53 <Skolopedrion> Cale: you mean the (2, 1) :: (Int, Int) ?
11:55:10 <Cale> Skolopedrion: You might not need the explicit type annotation then
11:55:16 <fayong> exit
11:56:03 <Skolopedrion> Well if I do not specify it, the compiler throws the error I show in the paste
11:57:44 <dbushenko> hi all!
11:57:59 <dbushenko> is there a library for https request?
11:58:03 <Cale> Skolopedrion: Ah, I guess it's not enough to get numeric defaulting to apply then
11:58:06 <dbushenko> looks like HTTP doesn't support it
11:58:40 <Cale> dbushenko: I think http-conduit is supposed to...
11:59:05 <lrocksmashtime> haskellers, hello. Looking to move off of rails for a production rest api. Currently looking at Snap and Yesod frameworks. Are there any others you guys would recommend I look at?
11:59:05 <Skolopedrion> Cale: So how am I supposed to do ? (thanks for the help, really)
11:59:47 <Cale> lrocksmashtime: Happstack and Scotty are the other two major ones to look at
11:59:49 <dbushenko> Cale, thanks!
11:59:59 <prsteele> Skolopedrion: Is there any particular reason you can't define (!) as a function, and skip typeclasses altogether?
12:00:05 <dbushenko> lrocksmashtime, +1 for Scotty
12:00:13 <Cale> Skolopedrion: I guess if you really want that type class, it's just got to be sort of annoying.
12:00:43 <dbushenko> lrocksmashtime, it is not like rails, it is more like Sinatra
12:00:47 <Skolopedrion> I would like to get a cell from the maze with both (Int, Int) and Position
12:00:59 <dbushenko> lrocksmashtime, you may look at this example of simple blog with Scotty: https://github.com/dbushenko/scotty-blog
12:00:59 <lrocksmashtime> Cale:  awesome. dbushenko: yes that looks like it might be exactly what i'm looking for. Thanks!
12:01:04 <Skolopedrion> but maybe its just dumb
12:01:25 <Cale> Skolopedrion: Well, what you've got actually works for that. The errors come about because the compiler can't tell you intend for (2,1) to be a pair of Int values specifically.
12:01:27 <dbushenko> btw, I got nice benchmark results with scotty
12:01:39 <Cale> Skolopedrion: (2,1) could be a pair of any types of numbers
12:01:44 <Cale> > (2,1) :: Complex Double
12:01:46 <lambdabot>      Couldn't match expected type ‚ÄòComplex Double‚Äô
12:01:46 <Cale> oops
12:01:46 <lambdabot>                  with actual type ‚Äò(Integer, Integer)‚Äô
12:01:46 <lambdabot>      In the expression: (2, 1) :: Complex Double
12:01:51 <Cale> > (2,1) :: (Complex Double, Float)
12:01:54 <lambdabot>  (2.0 :+ 0.0,1.0)
12:01:55 <dbushenko> totally the same code runs almost as fast as in Java8+Spring4 but consumes 6-8 times less memory
12:02:06 <Cale> > (2,1) :: (Rational, Integer)
12:02:09 <lambdabot>  (2 % 1,1)
12:02:10 <Skolopedrion> yep
12:02:58 <Skolopedrion> I shouldn't allow to get a cell wth two different types then ?
12:03:05 <Cale> Skolopedrion: So, because there might be future instances of the type class for those other types of numbers, by design it doesn't just presume that the (Int, Int) instance it found will be the only one.
12:03:52 <Cale> Which is pretty much what it told you: hey, I found this instance which would apply, but the type is ambiguous
12:04:14 <Skolopedrion> ok
12:04:26 <Skolopedrion> well thanks for the help Cale !
12:05:04 <Cale> Skolopedrion: You don't necessarily have to supply an explicit type signature, so long as the pair is definitely an (Int, Int) pair. If you were writing a function which explicitly took an (Int, Int) pair as a parameter, you could use that pair with ! and it would work.
12:05:43 <prsteele> Skolopedrion: I think playing around in the interpreter is your enemy, here, since it has no annotations to go with
12:06:08 <prsteele> Skolopedrion: but like Cale mentioned, if you're in a function, there is a good chance the type to the right of ! can be inferred correctly
12:07:37 <Skolopedrion> thank you all, i may come back for future problems since i'm a begginer to Haskell
12:10:08 <prsteele> actually somewhat related, if I have "class Foo a b c" with "bar :: a -> [b]" and others, is there any way to correctly select bar?
12:14:37 <Zemyla> I wish I could turn an element of an STArray into an STRef.
12:16:46 <geekosaur> prsteele, I think you'd need fundeps fixing a and c based on b?
12:17:05 <geekosaur> or at least c in terms of either a or b or both
12:26:47 <prsteele> geekosaur: that is an answer, but I'm not sure it's general enough for what I'm trying to do.
12:27:11 <Zemyla> Also, is there a Windows version of 7.10?
12:27:19 <geekosaur> without something like that, I don't think you can pick an instance appropriately
12:27:32 <prsteele> geekosaur: believable, but unfortunate
12:27:39 <geekosaur> Zemyla, I think Snoyman's minghc is recommended for Windows?
12:28:13 <geekosaur> https://github.com/fpco/minghc
12:28:23 <Zemyla> Do I need to rebuild all the packages?
12:28:37 <geekosaur> ? you would anyway
12:28:40 <orion> Given a value (GHC 7.10.1), how can I print out the name of the data constructor which created the value, but /not/ any values associated with it?
12:28:44 <geekosaur> assuming you have an existing non-7.10
12:30:19 <orion> tyConName?
12:31:45 <Zemyla> geekosaur: Okay, so how do I do that most efficiently? Do I need to uninstall my current GHC installation?
12:32:06 <geekosaur> orion, looks to me like you typeOf the value to get a TypeRep, then splitTyConApp to get a TyCon, then tyConName?
12:32:38 <geekosaur> Zemyla, normally they can coexist, but as minghc includes an msys2/mingw installation I think you're probably better off wiping the original, yes
12:33:18 <Zemyla> geekosaur: So I uninstall the current GHC, and then install minghc? Does it include a WinGHCI?
12:34:04 <geekosaur> doesn't look like it, no
12:35:04 <geekosaur> but it looks like winghci is sufficiently standalone that it should Just Work
12:35:22 <geekosaur> it works with whatever ghc / ghci is in %PATH%
12:35:23 <SrPx> Is it possible to write to an accelerate array inside a computation?
12:39:13 <orion> geekosaur: hmm, given: data Foo = Bar Text -- I want to find out "Bar".
12:39:52 <geekosaur> and? you said you had a value, so I gave you the chain of calls to go from that value to the constructor name
12:40:26 <geekosaur> typeOf gives you a TypeRep, splitTyConApp isolates the TyCon part of the TypeRep, tyConName gives you the string name of the TyCon
12:41:13 <enthropy> > dataTypeOf (Just 3)
12:41:15 <lambdabot>  DataType {tycon = "Prelude.Maybe", datarep = AlgRep [Nothing,Just]}
12:41:30 <geekosaur> ok, so there's a faster way
12:41:32 <enthropy> there's another method that's more appropriate
12:41:45 <orion> geekosaur: According to ghci: tyConName $ fst $ splitTyConApp . typeOf $ x == "Foo"
12:41:53 <geekosaur> Typeable is fairly low level but I'm less familiar with the stuff on top of
12:42:03 <ion> dollar dollar op, yp
12:42:05 <ion> yo
12:42:08 <geekosaur> oh, need to dig deeper then
12:42:15 <orion> inception.
12:42:19 <enthropy> > toConstr (Just 3)
12:42:21 <lambdabot>  Just
12:42:33 <orion> :t toConstr
12:42:34 <lambdabot> Data a => a -> Constr
12:42:53 <enthropy> this is a method in Data.Data.Data
12:43:05 <orion> Wow. :p
12:44:29 <sleblanc> Hi, I am very new to Haskell's FFI and overall new-ish with Haskell. I am looking for documentation on how to "wrap" a struct from C so that its respective "free" function is applied when Haskell code is done with the object. Is there a common pattern or am I overthinking it?
12:45:01 <sleblanc> That is, should this be the developer's responsibility?
12:45:18 <Enigmagic> sleblanc: http://hackage.haskell.org/package/base-4.8.0.0/docs/Foreign-ForeignPtr.html
12:45:21 <ion> newForeignPtr :: FinalizerPtr a -> Ptr a -> IO (ForeignPtr a)
12:45:57 <sleblanc> Wow, thanks
12:52:06 <wasif> quit
12:52:08 <wasif> :q
12:56:27 <brbblnch> Hi
12:56:57 <brbblnch> Quick question:¬†Is Barendregt the best place to learn about the lambda cube?
12:59:02 <hodapp> brbblnch: the lambda cube, or the lambda calculus?
12:59:06 <hodapp> brbblnch: those are two rather different things
12:59:42 <brbblnch> hodapp: Well, rather the cube. But I guess that knowing about lambda calculus is a prerequisite to learn about the cube?
13:00:08 <ion> Someone should create a time cube parody about lambda cube.
13:01:02 <hodapp> ion: HOW DO I WRITE A CAPITAL LAMBDA?
13:01:16 <hodapp> brbblnch: I'm not sure if they're really related.
13:01:21 <brbblnch> As far as I understand it, the cube sort of puts together all classical lambda calculi
13:04:01 <hodapp> brbblnch: oh, I was confused for a moment because the first result from Barendregt was a lambda calculus text, but now I'm seeing that the same Barendregt created the lambda cube too
13:05:01 <lyonsb> Capital lambda looks like an upside down V.
13:06:27 <geekosaur> Œõ
13:09:32 <ernst> is it possible to make a Show instance for functions like (Int -> Int -> Int) ?
13:09:38 <lpaste> ernst pasted ‚Äúshow instances for Int->Int->Int‚Äù at http://lpaste.net/133146
13:10:26 <vandenoever> is there a nice lib that helps makes recalculation more efficient if the input on the second call is very similar to the first?
13:10:43 <hodapp> brbblnch: well, I really don't know, but #coq might have a better idea - Coq being based on CoC
13:10:44 <albeit> Is there a way to empty a TQueue? 
13:13:16 <brbblnch> hodapp: Oh, didn't know about #coq, and it's not empty. Thank you!
13:13:27 <brbblnch> and good night
13:18:46 <Tekmo_> There's a trick that I've come across in two informal discussions that I don't know the name for and I was hoping somebody else would.  It's the trick of using a cumulative sum for efficient range sums
13:19:48 * hackagebot git-annex 5.20150522 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20150522 (JoeyHess)
13:19:50 * hackagebot text 1.2.1.0 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-1.2.1.0 (BryanOSullivan)
13:20:19 <Tekmo_> In other words, given an array of elements of type `e`, where `e` is a group
13:20:32 <Tekmo_> Let's call this array `a`
13:21:05 <hodapp> so, if I'm using RankNTypes, and I have (forall s . Foo s -> Foo s) or something similar in the signature, might a function in a typeclass suffice as a value of that? I suppose I'll have to add a typeclass constraint to the forall for that
13:21:14 <Tekmo_> Then you store a cumulative sum array `b` where: b ! i = mconcat (map (a !) [0..i])
13:21:33 <Tekmo_> And if you want to do a range sum on a from `i` to `j`, you can compute it efficiently by just doing `b ! j - b ! i`
13:21:43 <Tekmo_> I just don't know what is the official name of this trick
13:21:45 <hodapp> would (FooClass s => Foo s -> Foo s) be different from that or would the implicit forall there still put it at the appropriate place?
13:22:01 <arkeet> hodapp: it's different
13:22:18 <hodapp> arkeet: it'd put the forall outside of it, or something?
13:22:28 <arkeet> what exactly are you trying to do?
13:22:47 <arkeet> you can't psas a FooClass s => Foo s -> Foo s into someting that takes a (forall s. Foo s -> Foo s) argument
13:23:01 <arkeet> the other way around works though
13:23:05 <arkeet> I think
13:23:13 <hodapp> arkeet: but if I changed that latter type signature to have a constraint on FooClass, then would it work?
13:23:23 <arkeet> if you put forall s. FooClass s => ... yes
13:24:48 * hackagebot hspec-snap 0.3.2.8 - A library for testing with Hspec and the Snap Web Framework  http://hackage.haskell.org/package/hspec-snap-0.3.2.8 (DanielPatterson)
13:25:15 <hodapp> arkeet: But I've defined a typeclass that works generically over certain types of records, and I'm wanting to make a sort of 'map' analogue that operates over fields (and all the fields will be instances of a particular data family). If it's to operate over fields, then it seems to me I need RankNTypes
13:25:29 <arkeet> hm?
13:26:11 <hodapp> arkeet: you asked what I was trying to do.
13:26:54 <Tekmo_> hodapp: It sounds like you would probably be better served by lenses
13:27:27 <hodapp> Tekmo_: possibly, but the GHC.Generics code is fairly short right now.
13:28:33 <hodapp> and I seem to require certain capabilities of it.
13:29:21 <sleblanc> How can I wrap a C API function that accepts no parameter?
13:29:49 * hackagebot hspec-snap 0.3.2.9 - A library for testing with Hspec and the Snap Web Framework  http://hackage.haskell.org/package/hspec-snap-0.3.2.9 (DanielPatterson)
13:30:08 <arkeet> same way you wrap one that accepts n parameters
13:30:29 <Vektorweg11> is Network.Simple.TCP.recv lazy? 
13:31:08 <sleblanc> arkeet, can you please elaborate?
13:31:15 <rewbert> Hi!
13:31:34 <sleblanc> I thought functions in Haskell had to have at least one argument, otherwise they are constants (pure)
13:31:37 <rewbert> Oh looks like i managed to get IRC working. Never used it before. :-)
13:31:45 <sleblanc> Hi rewbert!
13:31:51 <hodapp> rewbert: this is your first IRC channel ever
13:31:53 <hodapp> ...?
13:31:54 <sleblanc> Welcom home
13:31:59 <rewbert> It is!
13:32:02 <prsteele> rewbert: welcome to the best channel in existence
13:32:11 <hodapp> rewbert: welcome to the bes- yeah, that
13:32:12 <sleblanc> (yet)
13:32:14 <rewbert> The Haskell channel seemed like the obvious choice for such an experience.
13:32:16 <arkeet> sleblanc: if you are trying to call a C function for an effect, you give it an IO type.
13:32:19 <arkeet> :t getChar
13:32:21 <lambdabot> IO Char
13:32:29 <arkeet> ^ no arguments, not a function
13:32:37 <sleblanc> Hmm, ok
13:32:46 <sleblanc> Makes sense
13:32:46 <arkeet> but has an effect when executed
13:32:55 <Vektorweg11> isnt it more like: "irc is old but get things done".
13:33:19 <sleblanc> Vektorweg11, mentioning IRC's age is an ad hominem
13:33:31 <sleblanc> ;-)
13:33:40 <rewbert> I had a tiny question
13:33:42 <sleblanc> Let's use "time-proven"
13:33:52 <Vektorweg11> there are known flaws ...
13:33:55 <rewbert> Do you have any tips on debugging in haskell? I find it to be very unintuitive
13:34:22 <sleblanc> rewbert, there's some reference docs available: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-debugger.html
13:34:34 <sleblanc> Haven't had the opportunity to do debugging yet
13:34:40 <rewbert> I have a bug in my project right now but ive no idea what triggers it.
13:34:51 <arw> rewbert: split everything up into small functions and test those in ghci by executing them
13:35:14 <prsteele> rewbert: there's the meta-approach of unit testing, which is pretty much what arw is saying
13:35:19 <rewbert> Haha yes i've done that :-) I can't find the bug. I am reading a textfile and creating nodes out of each word. The file is 65000 words long, but i only get 55000 nodes.
13:35:28 <arw> rewbert: i've tried debugging stuff but never got anywhere. 
13:35:33 <rewbert> It's very frustrating not even knowing where to begin!
13:36:01 <rewbert> There are about 12000 unique words so the problem wouldn't seem to be there, yet it most likely is.
13:36:06 <Tekmo_> rewbert: Your first resort should be defining small and testable functions
13:36:24 <Tekmo_> rewbert: Then you can test those functions manually using ghci or mechanically using quickcheck
13:36:30 <tdammers> Tekmo_: that, or defining better types
13:37:06 <rewbert> Done both, i am sad to say. Everything seems to be working so well! Bah, i guess i'll show my teacher this tomorrow and maybe he'll know where i went wrong.
13:37:13 <rewbert> I bet he's seen it before.
13:37:34 <Tekmo_> So
13:37:40 <Tekmo_> There's an obvious quick check property that you can write
13:37:46 <Tekmo_> The number of nodes should equal the number of words
13:37:56 <Tekmo_> Just feed that through quickcheck and it will find the minimum case that violates that property
13:37:58 <hodapp> one of these days I need to learn QuickCheck.
13:38:04 <Tekmo_> hodapp: It's very easy
13:38:09 <whittle> rewbert: You might also consider something like golden tests, if you can create a small enough input that you are able to manually create the output for it. 
13:38:10 <Tekmo_> cabal install QuickCheck
13:38:11 <Tekmo_> ghci
13:38:14 <rewbert> Yes in my first class they taught us quickcheck
13:38:16 <Tekmo_> import Test.QuickCheck
13:38:18 <rewbert> It's extremely useful!
13:38:36 <Tekmo_> quickCheck (\xs -> length xs == length (reverse xs))
13:38:40 <prsteele> rewbert: there's always the Debug.Trace approach, as well
13:38:41 <hodapp> Tekmo_: everything I've seen in passing about it has looked very nice.
13:38:52 <rewbert> Hm not sure what that is. Let me google it!
13:38:53 <orion> enthropy: I tried using toConstr on my exception: No instance for (Data.Data.Data GHC.Exception.SomeException) arising from a use of ‚ÄòtoConstr‚Äô 
13:39:10 <hodapp> Tekmo_: it's just that most of my Haskell usage for 6 months or so has been in code generation for embedded targets - where the only unit tests that matter are the ones I do on the embedded target, which isn't running Haskell
13:39:15 <sleblanc> rewbert, here's a joke to motivate you: a software tester walks into a bar. He orders 1 beer. He orders 2. He orders 9999, he orders MAX_INT + 1, he orders -1, he orders "one"‚Ä¶
13:39:20 <prsteele> rewbert: Debug.Trace offers trace, which is a backdoor out of the type system. You can do printf-style debugging with it
13:39:33 <rewbert> Oh this is just what i've been looking for!
13:39:43 <tdammers> in my experience, haskell bugs that are seemingly undebuggable are usually either related to strictness, or to lazy I/O
13:39:45 <Tekmo_> rewbert: YOu basically give quickcheck a high level property (like: "The number of nodes must equal the number of words") and then quickcheck will throw random input at it to either (A) verify the property or (B) find a minimum reproducing case that violates the property
13:39:54 <Tekmo_> The minimum reproducing case is the killer feature
13:39:55 <rewbert> In java i just write a Sysout whenever i am sceptical. Would be nice if i could get similar behaviour from Haskell
13:40:07 <Tekmo_> It might find a much smaller input that gives the same bug that will probably make it more clear what went wrong
13:40:19 <rewbert> Seeing as haskell is far superior that shouldn't be too difficult!
13:40:27 <rewbert> Yes Tekmo, that would be ideal.
13:40:32 <rewbert> :)
13:40:41 <prsteele> rewbert: trace :: String -> a -> a
13:40:45 <hodapp> tdammers: One thing I've quite liked is that my code tends to be very easy to test in isolation, even when I'm not putting particular conscious effort to write it that way.
13:40:49 <tdammers> Tekmo_: it doesn't actively try to find the minimum reproducing case, it just generates semi-random inputs, biased such that simpler cases are likely to appear earlier
13:40:52 <hodapp> tdammers: definitely a far cry from how it was in Java and C++ land.
13:41:00 <tdammers> hodapp: agree completely
13:41:17 <tdammers> even clojure feels pretty shitty in that regard
13:41:20 <hodapp> huh
13:41:23 <hodapp> I have not used it a whole lot
13:41:33 <tdammers> welp
13:41:34 <hodapp> but Dr. Hickey's talk seemed to indicate similar practices there
13:41:43 <enthropy> orion: your answer would be SomeException
13:41:52 <enthropy> if that Data instance existed
13:42:02 <tdammers> my first impression with clojure was that they seem to do a lot right, and that it's a pleasant language to work with
13:42:07 <Tekmo_> tdammers: I thought it actively shrank any violating property
13:42:12 <Tekmo_> tdammers: *violating input
13:42:18 <hodapp> I saw Java unit tests at my prior job in which probably 95% of the failures were due to something solely for the sake of a test being initialized in the wrong order, and in which eventually about 95% of the code was there solely for setting up a test harness where a test could meaningfully be done.
13:42:22 <tdammers> Tekmo_: not sure, but don't think it does
13:42:27 <orion> enthropy: Would it be harmless to insert a "instance Data SomeException" casually in to my application?
13:42:28 <rewbert> Thanks for your advice guys. Definitely worth learning how to use IRC :) I hope i'll see you tomorrow!
13:42:50 <Tekmo_> tdammers: I'm pretty sure it does.  That's the reason the `Arbitrary` type class has a `shrink` method
13:43:01 <tdammers> Tekmo_: right. I guess I stand corrected ;D
13:43:05 <Tekmo_> :)
13:43:15 <Tekmo_> orion: Always avoid orphan instances
13:43:20 <Tekmo_> orion: They will always bite you in the end
13:44:06 <orion> Tekmo_: Not sure how to proceed then.
13:44:13 <Tekmo_> orion: Wrap it in a newtype
13:44:20 <enthropy> orion: if there was a proper instance Data SomeException, toConstr shouldn't be helpful because it's always the same constructor
13:44:24 <Tekmo_> orion: newtype DataException = DataException SomeException
13:44:37 <Tekmo_> orion: Then implement `Data` for your newtype
13:45:14 <orion> hmm
13:45:15 <orion> ok
13:45:27 <Tekmo_> orion: Also, check if you really need `Data`
13:45:29 <enthropy> probably you want to use one of the methods in Exception
13:45:42 <Tekmo_> orion: The fact that there isn't a `Data` instance for `SomeException` should probably give you pause
13:45:51 <enthropy> since we have data SomeException where SomeException :: Exception e => e -> SomeException
13:45:51 <Tekmo_> orion: There might be a better solution for what you are trying to do
13:48:47 <orion> Tekmo_: I'll think about the problem more.
13:55:53 <albeit> If I have a thread that needs to check a flag that is set by other threads every time it wants to do something, should I use an IORef, MVar, or TVar?
13:56:37 <bergmark> albeit: use stm unless you have reasons not to
13:58:03 <albeit> bergmark: Okay. But I use a TVar Bool, and it is False, I need to constantly call readTVar to check when it turns True - will that use all the CPU or does it somehow block and signal?
13:58:13 <oconnore> yeah, I regret all my mvar code
13:58:37 <Tekmo_> albeit: Ther'es a better way
13:58:39 <enthropy> TVar () -- might work
13:58:45 <oconnore> albeit: it blocks and signals, so it will re-run whenever another transaction modifies the variables it depends on
13:58:58 <oconnore> it's not a busy wait
13:59:18 <Tekmo_> ^
13:59:24 <albeit> Ah great, thanks guys.
13:59:41 <oconnore> unless you are updating a lot in ways that plausibly could cause the transaction to complete but actually don't
14:01:28 <oconnore> er... albeit you know about retry, yes?
14:02:26 <albeit> oconnore: Nope! But just reading the docs now. Is the non-"busy wait" only if I use retry somehow?
14:02:30 <bergmark> albeit: might be cleaner to use `guard', but the behavior is the same
14:03:20 <Tekmo_> albeit: atomically (do b <- readTVar tvar; guard b; ... )
14:03:31 <Tekmo_> That will sleep until the value of `b` is `True`
14:04:48 <albeit> Tekmo_: Okay... so using a TVar Bool is better than the TVar ()?
14:04:51 * hackagebot fixedwidth-hs 0.4.0.1 - Quick parsing of fixed-width data formats.  http://hackage.haskell.org/package/fixedwidth-hs-0.4.0.1 (MichaelOChurch)
14:05:01 <bergmark> a tvar cannot be empty
14:05:12 <albeit> Ah okay, not an mvar, got it
14:05:22 <bergmark> TMVar's can be empty though
14:05:30 <Tekmo_> albeit: In fact `TMVar`s are implemented in terms of `TVar`s
14:05:45 <Tekmo_> albeit: `TMVar a` is really just a `TVar (Maybe a)` under the hood
14:07:21 <albeit> So if I wanted to do an IO action after it turns true, the code would be something like "atomically $ readTVar tv >>= guard; doAction"?
14:07:33 <Tekmo_> Yes
14:08:31 <Tekmo_> For this simple case you could probably use a `TMVar ()` or just an `MVar ()` if you're not doing anything else
14:10:15 <rewbert> Update! I wrote some quickcheck properties and have currently ran 500 000 tests, all passed. x3
14:10:25 <rewbert> Hoping for a fail soon
14:10:27 <rewbert> This is ridiculous
14:10:28 <albeit> Yes, not doing anything else... but I call the "reading" thread, the one that checks the tvar/mvar/tmvar in a loop, so if I used an MVar wouldn't it get trick because say filled ~ True, I would take it, then have to replace it to take it again?
14:12:25 <Tekmo_> You can read the value without emptying the mvar if that's what you want
14:13:05 <Tekmo_> `readMVar` reads the contents without emptying the MVar
14:13:18 <Tekmo_> `takeMVar` simultaneously reads and empties the `MVar`
14:14:27 <albeit> Okay. Why is an "MVar ()" preferrable over a "TVar Bool" in this case?
14:16:40 <Tekmo_> albeit: The only advantage of `MVar ()` over `TVar Bool` is that `MVar` is slightly faster
14:17:06 <Tekmo_> albeit: The disadvantage is that `TVar Bool` can be composed into larger STM transactions, but it sounds like you don't need that
14:17:23 <albeit> Nope, the speed is nice too. I'll go with the MVar ()
14:19:53 <albeit> Another concurrency structure... is the proper way to empty a TQueue to keep calling tryReadTQueue until isEmptyTQueue in an STM transaction?
14:24:28 <bergmark> albeit: i suppose you'd do that if you want to get everything in the queue at once
14:24:49 <mjrosenb> oh god, I'm so confused.  I have (l || r), and it is only true when both l and r are true.  Did I forget basic logic?
14:25:03 <albeit> bergmark: I actually don't need the elements of the TQueue, I just want to discard them...
14:25:16 <Bor0> > True || False
14:25:18 <lambdabot>  True
14:26:02 <Bor0> mjrosenb, it is true when both l and r are true, but not only then
14:26:05 <bergmark> albeit: oh i misread, you'd call tryReadTQueue until it gives Nothing. But okay that's the proper way to clear it as well i suppose
14:29:37 <mjrosenb> The actual code I have is this: isShift SDL.KeyModifier {keyModifierLeftShift = l, keyModifierRightShift = r} = l || r
14:29:52 <mjrosenb> but isShift is only evaluating to true when both shift keys are pressed.
14:34:53 * hackagebot textocat-api 0.1.0.0 - Unofficial Haskell SDK for Textocat API -- http://textocat.com  http://hackage.haskell.org/package/textocat-api-0.1.0.0 (MZiatdinov)
14:36:23 <tswett> mjrosenb: are l and r Bools there?
14:36:57 <tswett> If you're not redefining ||, then it must return True whenever one or the other or both are True.
14:37:11 <tswett> And so the bug must be something else.
14:38:58 <mjrosenb> tswett: well, if they aren't bools, then that should not typecheck.
14:39:19 * mjrosenb changes it to Prelude.||
14:39:22 <tswett> True, unless || isn't the function Bool -> Bool -> Bool.
14:39:30 <oconnore> Can someone help me understand Alternative some/many? 
14:42:26 <oconnore> the documentation just gives their definition, and typeclassopedia has nothing, and I can't actually evaluate them in ghci
14:42:37 <mjrosenb> AARG, frp.
14:43:26 <simpson> oconnore: Okay. What's tripping you up, more precisely?
14:44:16 <oconnore> simpson: I guess all of it. I can't even evaluate:  many [5,4,6] !! 0 !! 0 :: Num a => a
14:44:30 <oconnore> so I think I really don't understand what's going on
14:44:40 <oconnore> that should output a number, no?
14:45:47 <michaelt> oconnore: they diverge for a lot of the familiar instances; they are good for parsers ...
14:47:26 <simpson> Huh. I didn't realize it before, but yeah; some/many definitely diverge.
14:48:42 <michaelt> oconnore: a pile of considerations come up in this billion-message thread https://mail.haskell.org/pipermail/haskell-cafe/2011-December/097476.html
14:52:15 <oconnore> michaelt: aha! "some v" means "consume at least one v and return the list of items consumed or fail", and "many v" means "consume zero or more v and return the list of items consumed or the empty list of none are consume".
14:54:28 <Chobbes> Is this possible in Haskell? http://lpaste.net/7964164166279757824
14:54:34 <Chobbes> Or, rather, GHC ;).
14:56:10 <Chobbes> I can't think of a nice way that I can say "if one of these is a double then I want (*) :: Double -> Double -> Double, and if they're both integers I want (*) :: Integer -> Integer -> Integer", where (*) is the op given.
14:56:43 <KaneTW> type families
14:57:19 <Chobbes> Onward to more reading! Thanks, KaneTW.
14:59:47 <KaneTW> you could alsu use fundeps but type families are generally preferred
15:00:10 <athan> oconnore: Hey! Check this out, I just understood this, too: http://lpaste.net/133152
15:00:19 <athan> oconnore: It can be difficult _not_ making loops though
15:03:18 <oconnore> athan: yeah, that looks very nice to work with. I haven't played with parsers yet in haskell, except generated LALR(1)
15:03:53 <oconnore> I was so confused why they didn't work for [] or Maybe
15:03:53 <athan> oconnore: You also might find BNFC pretty cool, but it generates Alex & Happy files
15:04:12 <athan> (I have no idea :D)
15:04:30 <michaelt> oconnore: right, some and many were I think already defined in parser libraries. Since they could be expressed just with the alternative operation, they were included, I guess.  
15:05:12 <michaelt> oconnore: this is developed a bit more in edwardk 's https://hackage.haskell.org/package/parsers-0.12.2.1/docs/Text-Parser-Combinators.html 
15:09:29 <oconnore> athan: cool, I was actually using Happy before. I have a pet project to write a latex-ish publishing language, and I had previously written a BNF grammar for a little node.js app.
15:10:01 <oconnore> michaelt: yeah, I shy'ed away from parser combinators when I was first learning, it's probably time to try it again :)
15:17:57 <newsham> category theorists protest naming of cocopuffs
15:19:48 <arkeet> I'm a nstructivist.
15:20:36 <dfeuer> What's that mean?
15:20:46 <arkeet> I'm not sure, but it's the dual to constructivist.
15:20:55 <dfeuer> Destructionist?
15:21:03 <dfeuer> Er ... destructivist?
15:21:09 <whittle> Hahahahah
15:25:56 <Chobbes> oconnore: they're super nice, you'll catch on pretty quick. I'd recommend Attoparsec over Parsec first, though. The types are simpler if they're scary news bears for you.
15:39:56 * hackagebot datetime-sb 0.2.1 - Utilities to make Data.Time.* easier to use.  http://hackage.haskell.org/package/datetime-sb-0.2.1 (jsl)
15:41:08 <maerwald> does lambdabot have a social algorithm? I'm trying to explain my feelings, but it doesn't respond
15:41:46 <maerwald> maybe that should go under "feature request"
15:42:28 <hodapp> what type of feelings are they?
15:42:33 <ghorn> how would one implement mapAccumRM :: (Traversable t, Monad m) => (a -> b -> m (a, c)) -> a -> t b -> m (a, t c)
15:42:49 <maerwald> hodapp: they are strictly typed, that is for sure
15:45:25 <hodapp> maerwald: I'd imagine though that they are pretty dynamic
15:45:50 <maerwald> hodapp: in nature yes, but not in their type
15:46:19 <hodapp> maerwald: I DON'T KNOW HOW I FEEL ABOUT THAT
15:46:24 <maerwald> :D
15:48:01 <whittle> I have trouble expressing my feelings in Haskell, as their type is dependent on their state. 
15:48:15 <whittle> That‚Äôs why my therapist is also a theorem prover. 
15:48:50 <maerwald> xxD
15:49:33 <kadoban> ‚Ä¶ why would I be getting 'foldr' is not a (visible) method of class Foldable in GHC 7.8.4? Was that not true until 7.10? How do I make an instance of Foldable before that? :-/
15:50:53 <kadoban> Oh oh, I see. I have to hide foldr from Prelude and get the Data.Foldable one ‚Ä¶ I guess that makes sense.
15:51:00 <geekosaur> or qualify it
15:52:17 <kadoban> Thanks
15:52:17 <rotcetorptekcop> kadoban: pas de quoi
15:59:59 <kadoban> I have a pretty basic Queue datatype I wrote. So far it's a Functor and a Foldable ‚Ä¶ what else should it be ‚Ä¶ I guess Applicative/Monad probably and ‚Ä¶ Traversable? Anything else?
16:06:45 <refefer> where are the typeclasses for tuple defined?
16:08:11 <kadoban> refefer: Generally where the typeclass is defined I believe, at least for Functor (Data.Functor), Applicative (Control.Applicative), etc.
16:08:35 <kadoban> Most of them are in Prelude of course
16:09:06 <refefer> ok.  Is there a way to write an instance for that applies on a tuple of N-size?  or do I need to define them for each N tuple?
16:09:41 <kadoban> I don't think you can define such an instance in vanilla haskell. Some extension might let you (I don't know).
16:09:56 <refefer> kadoban: thanks!
16:10:14 <whittle> refefer: If you don‚Äôt want to do it by hand, Template Haskell may be your best bet. 
16:12:19 <whittle> Hunh. GHC 7.10 complains about ambiguous occurences of a symbol that‚Äôs in Prelude, even if the other import is qualified. 
16:12:57 <kadoban> whittle: Really? That sounds quite surprising.
16:13:26 <refefer> whittle: haven't played with it - I'll take a look
16:14:58 <pavonia> whittle: Perhaps it's re-exported from another module?
16:16:28 <lpaste> whittle pasted ‚ÄúAmbiguity in GHC 7.10‚Äù at http://lpaste.net/133158
16:16:29 <kadoban> I wonder why the haddocks for Monad say (>>=) is a minimal complete definition. You need 'return' too, don't you, or am I /really/ missing something?
16:17:01 <refefer> kadoban: maybe due to the unification of Functor and Monad?
16:17:11 <kadoban> whittle: lpaste your imports?
16:17:31 <whittle> kadoban: I just saw that. I think it‚Äôs because Monads now have to be Applicatives. 
16:17:47 <kadoban> Ohh, right so it's probably just return = pure by default?
16:17:59 <whittle> kadoban: I think so. 
16:18:06 <kadoban> Makes sense
16:18:29 <athan> Cale: ^ ( Õ°¬∞ Õú ñ Õ°¬∞)
16:20:34 <whittle> kadoban: There are only two imports, Data.Set as S and an unqualified import of a module that doesn‚Äôt export map.
16:21:19 <arkeet> whittle: is it import Data.Set as S, or import qualified Data.Set as S
16:21:29 <arkeet> the former will still put everything in the main namespace
16:22:14 <whittle> Gah! I forgot to spell out qualified. Thank you, arkeet. 
16:22:21 <arkeet> np :)
16:22:39 <whittle> I haven‚Äôt done any Haskell in a month, and it shows. :(
16:22:52 <kadoban> I wonder why that behavior is like that anyway, it seems weird. My little snippety thing puts it in for me automatically or I'd probably never remember.
16:24:34 <Rotaerk> hmm wonder if it'd be evil of me to sneak haskell into my job by implementing the backend for something in it
16:25:19 <athan> Rotaerk: Well, only evil if that makes them dependent on you :P
16:25:23 <kadoban> Might be, depends on the company and such I guess.
16:25:24 <Rotaerk> heh
16:45:04 <mjrosenb> Reactive-Banana question: Is it possible to delay an event until a Behavior changes?
16:50:01 * hackagebot file-collection 0.1.1.4 - Provide a uniform interface over file archives and directories  http://hackage.haskell.org/package/file-collection-0.1.1.4 (joel_williamson)
16:50:03 * hackagebot liquidhaskell 0.4.1.0 - Liquid Types for Haskell  http://hackage.haskell.org/package/liquidhaskell-0.4.1.0 (EricSeidel)
16:59:20 <dmwit> kadoban: Oh, this probably explains something I've wondered for a while, namely, why there isn't a default implementation of pure = return and (<*>) = ap (using DefaultSignatures).
16:59:58 <dmwit> Well, it explains why the pure = return part isn't there, anyway.
17:00:10 <kadoban> Because the default is the other way around I guess?
17:00:42 <kadoban> Err hmm. Actually couldn't it be defaulted both ways, and you just have to implement one of them? Hmm hmm.
17:01:27 <dmwit> Yeah, but we don't really have a handy way of indicating minimal definitions that span classes.
17:01:45 <dmwit> (And I think for complexity reasons it makes sense to keep that property.)
17:01:51 <kadoban> Right, yeah that wouldn't be too good would it
17:07:17 <athan> Hey guys, I'm trying to use attoparsec to find _all_ instances of text between delimiters. So far `many $ string "{{" *> manyTill letter (string "}}")` works for _one_ match, but anything after it throws me into an infinite loop.
17:08:21 <athan> I'm wondering if I should try the delimiter parser, and on failure maybe I should skip /anything/?
17:10:02 * hackagebot hmatrix-gsl-stats 0.3.0.1 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.3.0.1 (VivianMcPhail)
17:13:03 <pacak> athan: Well... This way it will work only if your {{}} stuff is following back to back
17:13:24 <pacak> You also need to drop anything in between }}xxxx{{
17:13:27 <athan> pacak: Ahh shoot, thank you
17:14:12 <mniip> hmm, why is parsec so popular... shouldn't pure generic PEGs be more popular across haskellers
17:15:21 <pacak> mniip: Easy to use, nice error messages, historical reasons...
17:16:34 <sm> used to be well documented...
17:16:41 <sm> first...
17:18:24 <mniip> sm, I always struggle with parsec's unintuitive semantics
17:19:20 <kadoban> I mostly struggle to remember what types stuff is supposed to have, and then once I remember it works fine. But Parsec is pretty much the only one I've used, I don't know how the rest compare.
17:19:58 <kadoban> Parsec ‚Ä¶ something something Char ?  Yay it worked, maybe.  1/2 the time I just leave the types off, use runParser and make it typecheck and then start putting in annotations, heh.
17:20:11 <mniip> well
17:20:18 <mniip> that's not how haskell should be written
17:20:51 <kadoban> Probably not, no. I can't say it's really Parsec's fault though necessarily, it's quite possible that I'm just lazy and never really bothered to learn /exactly/ what the parsec types mean.
17:20:59 <mniip> ‚ÄúHmm, it doesn‚Äôt compile ... maybe I‚Äôll stick in an fmap here ... nope, let‚Äôs see ... maybe I need another (.) somewhere? ... um ...‚Äù
17:21:39 <pacak> mniip: It's just a monad/applicative. Are  you writing your monadic code the same way?
17:21:57 <mniip> pacak, I was merely quoting typeclassopedia
17:22:08 <kadoban> Haha, it's usually not really /that/ sketchy. Mostly I just can't remember what my mental model of    Parser Char corresponds to, the bits in the middle of Parsec's types I can never remember what they mean.
17:22:33 <pacak> :t Parsec
17:22:34 <lambdabot> Not in scope: data constructor ‚ÄòParsec‚Äô
17:22:43 <mniip> kadoban, yeah? so what is it
17:23:04 <pacak> baaaaaaad lambdabot.  No cookies.
17:23:44 <kadoban> mniip: Not sure I understand the question.
17:25:05 <mniip> kadoban, what exactly is a value of type Parser Char
17:30:49 <kadoban> mniip: I dunno, like I said I just implement them and then figure it out from what GHC tells me the type is. Something like   Parsec s u Char, which some constraint
17:31:08 <mniip> no I mean, what are semantics behind the type
17:31:43 <mniip> Parser Char = ParsecT [Char] () Identity Char, that is known
17:31:59 <kadoban> Oh. Pretty close to the toy Parser thing from NICTA, except 'try' exists
17:32:48 <mniip> er
17:32:51 <mniip> sans last Char
17:33:29 <geekosaur> Parser Char is a parser that produces a Char. the ParsecT is a parser on a list of Char (i.e. a String), with user state () (i.e. none), transforming Identity (i.e. nothing), producing Char
17:55:04 * hackagebot datetime-sb 0.2.2 - Utilities to make Data.Time.* easier to use.  http://hackage.haskell.org/package/datetime-sb-0.2.2 (jsl)
18:02:13 <ellwyne> Hey guys. Is there a reverse of liftIO, i.e. IO a -> m a ? Or does something like that not make sense?
18:03:25 <pacak> ellwyne: There's unsafePerformIO
18:03:38 <pacak> which you can combine with return
18:04:03 <geekosaur> ellwyne, in general it is not possible. what if I pick m to be Maybe?
18:04:25 <ellwyne> In that case, is there a good way of performing m actions inside an MVar?
18:04:43 <pacak> :t join
18:04:44 <geekosaur> again in general no.
18:04:45 <lambdabot> Monad m => m (m a) -> m a
18:05:17 <ellwyne> Wow. So you can't use a lock with non IO monads...hmm..
18:05:35 <pacak> ellwyne: ST monad?
18:05:53 <geekosaur> let's say m is State. how do you ensure it has the *current* state at whatever time it is finally read from the MVar?
18:06:24 <simpson> ellwyne: So, you were just saying "reverse of liftIO", but it sounds like you're going in the same direction as liftIO?
18:06:30 <ellwyne> geekosaur: not quite advanced enough yet to understand your question haha
18:06:32 <geekosaur> it's worse if m is an IO-wrapping monad which does some kind of caching
18:07:12 <geekosaur> ellwyne, you cannot ensure that the thing you stored in the MVar knows about whatever is done with the monad while it was sitting in the MVar
18:07:49 <pacak> I'm not advanced enough to understand your question either :(
18:08:31 <geekosaur> if m is a MonadReader then this is not important, likewise for m = Maybe or m = []. things used to encapsulate "mutable state", you find out quickly that they only emulate mutable state
18:08:40 <geekosaur> because they cannot touch the copy in the MVar
18:09:19 <ellwyne> geekosaur: so basically the point of restricting MVar to IO is to ensure that nothing funky goes on that mutates what's inside the MVar? 
18:09:20 <geekosaur> (there is a way around this, you use a Reader carrying an IORef. but now everything using the "state" must indirect through the IORef)
18:09:30 <geekosaur> ?????
18:09:31 <geekosaur> no
18:09:34 <ellwyne> geekosaur: hah.
18:09:47 <geekosaur> MVar is itself mutable so must be in IO
18:10:25 <geekosaur> if you want the thing inside the MVar to be mutable then it too must be a mutable IO value (MVar, IORef, etc.)
18:11:03 <ellwyne> Alright, think I get the gist of it. Thanks
18:11:09 <geekosaur> (well, technically those are not themselves mutable, they are "pointers" to mutable storage and the accesses to them must be though IO)
18:11:33 <simpson> ellwyne: Out of curiosity, what was the original Monad m that you wanted?
18:11:41 <geekosaur> (similar dodge to how getLine is itself pure but describes an impure action)
18:11:51 <ellwyne> simpson: I'm writing some code using cloud Haskell using Process
18:12:28 <ellwyne> was trying to do some message sending inside a lock but I guess that can't happen
18:12:40 <simpson> ellwyne: Oh, no, you're still fine.
18:12:53 <simpson> ellwyne: Process is an instance of MonadIO. This means that you can liftIO to it!
18:13:16 <ellwyne> I can liftIO to it, but I can't call Process inside withMVar, for example
18:13:59 <dmwit> Possibly of general interest to Haskell folks: generalizing Traversable to allow different traversal orderings. http://stackoverflow.com/a/30407821/791604
18:14:46 <dmwit> ellwyne: Why do you need a referse of liftIO to use a lock in non-IO monads?
18:15:00 <dmwit> ellwyne: Isn't liftIO exactly what you want in non-IO (but still IO-capable) monads?
18:15:05 * hackagebot file-collection 0.1.1.5 - Provide a uniform interface over file archives and directories  http://hackage.haskell.org/package/file-collection-0.1.1.5 (joel_williamson)
18:15:37 <ellwyne> dmwit: Well, I can liftIO takeMVar for example, but if I want to use the safe wrapper withMVar it won't let me pass in process actions
18:15:42 <geekosaur> I think you need to show some example code for what you are trying to do
18:15:58 <geekosaur> I will point out that the a in
18:16:02 <geekosaur> :t withMVar
18:16:03 <lambdabot> Not in scope: ‚ÄòwithMVar‚Äô
18:16:07 <geekosaur> hm, sigh
18:16:09 <dmwit> ellwyne: Correct.
18:16:15 <geekosaur> withMVar :: MVar a -> (a -> IO b) -> IO b
18:16:24 <geekosaur> nothing stops a from being IO whatever
18:16:46 <dmwit> ellwyne: See also http://stackoverflow.com/q/9243215/791604
18:16:49 <geekosaur> but again I'd need to see some example code to get any idea of whether that is auseful direction
18:17:21 <dmwit> ellwyne: However!
18:17:27 <geekosaur> also, the function a -> IO b can use IO
18:17:33 <geekosaur> because its result type is in IO
18:17:43 <dmwit> ?let data MVar a; withMVar :: MVar a -> (a -> IO b) -> IO b; withMVar = undefined
18:17:45 <lambdabot>  Defined.
18:18:09 <geekosaur> but if you need to use some other monad there, again we'd have to see examples and know what monad you are trying to use
18:18:22 <athan> pacak: Hey, are you still here? If you were me, how would you handle `}}xxxxx{{`?
18:18:22 <dmwit> :t \f -> join $ liftIO (withMVar (return . f))
18:18:23 <lambdabot>     Couldn't match expected type ‚ÄòIO (m a)‚Äô
18:18:24 <lambdabot>                 with actual type ‚Äò(a0 -> IO b0) -> IO b0‚Äô
18:18:24 <lambdabot>     Probable cause: ‚ÄòwithMVar‚Äô is applied to too few arguments
18:18:27 <geekosaur> sometimes it is as simple as making the (a -> IO b) be a runWhatever
18:18:49 <dmwit> :t \f mvar -> join $ liftIO (withMVar mvar (return . f))
18:18:50 <lambdabot> MonadIO m => (a1 -> m a) -> MVar a1 -> m a
18:18:55 <ellwyne> geekosaur: trying to use nsend :: Serializable a => String -> a -> Process () inside a lock
18:19:00 <dmwit> ellwyne: ^^
18:19:20 <dmwit> This does something sort of funny, though.
18:19:26 <dmwit> So beware you understand what's happening here.
18:19:29 <pacak> athan: The same manyTill, but  I can't imagine situations where I'm only interested in {{ }} but want to ignore anything in between.
18:19:56 <pacak> athan: Another option would be to tokenize stuff first.
18:20:11 <dmwit> ellwyne: Specifically: it takes a peek at what's in the MVar, but the action it performs with that value is not performed while "holding the lock" so to speak.
18:20:52 <ellwyne> dmwit: that's what I wasn't sure about. something like return Process () inside withMVar was compiled, but I'm not sure when that action would be performed
18:20:58 <geekosaur> distributed-process package. I think you have exactly the problem I tried to point out; you cannot get at your process-handle (Process p) reasonably while in IO
18:21:06 <athan> pacak: hmm... how do you mean "the same"? (sorry ._.)
18:21:18 <geekosaur> that said, does not distributed-process provide its own locks?
18:21:31 <geekosaur> I would think that would be fairly necessary.
18:21:33 <ellwyne> geekosaur: I don't think so
18:21:39 <athan> pacak: I've got some weird expressions hidden inside a document that I want to extract
18:22:10 <pacak> athan: I mean by using the same command - manyTill, just combined with applicative  telling it to ignore everything before next {{
18:22:32 <athan> pacak: Oh!!! okay, shoot sorry
18:22:35 <athan> thank you!!
18:23:01 <simpson> geekosaur, dmwit, ellwyne: Please tell me if this is stupid: do { a <- liftIO (takeMVar mv); stuffWithLock a; liftIO (putMVar mv a) }
18:23:02 <geekosaur> hm, looking at distributed-process (that is the Process you are talking about?)
18:23:06 <mniip> why are the default implementations of some and many so weird
18:23:20 <ellwyne> geekosaur: yes 
18:23:20 <mniip> they result in an infinite loop in the [] instance
18:23:33 <ellwyne> simpson: that won't deal with asynchronous exceptions, when a thread is killed for example
18:23:40 <simpson> Actually, nevermind; why not "just" reimplement withMVar on MonadIO? http://hackage.haskell.org/package/base-4.8.0.0/docs/src/Control-Concurrent-MVar.html#withMVar
18:24:24 <simpson> Also, you could consider using STM instead of locks.
18:24:32 <dmwit> simpson: It is not stupid, but does not do the right thing with exceptions.
18:24:43 <dmwit> simpson: As for re-implementing in MonadIO, you are again going to have fun dealing with exceptions.
18:24:59 <ellwyne> simpson: thinking about it. overhead might be bad, so I'm trying mvar first
18:24:59 <geekosaur> ellwyne, in some sense Chan is an extension to MVar, and there is a Chan implementation in Process
18:25:34 <geekosaur> also it has STM support (matchSTM)
18:25:49 <sbidin> Let's say I have two State computations: (compA :: State a ()) and (compB :: State b ()). Can I use lenses to combine them into a (compAB :: State (a, b) ())?
18:26:00 <dmwit> sbidin: Yes, use zoom.
18:26:03 <geekosaur> and in fact matchSTM looks like it is exactly what you want here
18:26:14 <geekosaur> using a TVar
18:26:43 <sbidin> dmwit: Thanks!
18:26:47 <simpson> dmwit: Hm. It looks like `catch` can be abused to put its results into some MonadIO, from which they can be rethrown if not handleable. But yeah, that sounds like a pain.
18:27:04 <dmwit> simpson: I don't think it can. Try it.
18:27:37 <ellwyne> simpson, geeksosaur, dmwit: Thanks for the help. Gonna see if any way for me to get around that code I need inside the lock. If not I'll switch to STM.
18:27:46 <simpson> :t liftIO . flip catch return -- dmwit vv?
18:27:47 <lambdabot> (Exception a, MonadIO m) => IO a -> m a
18:28:01 <dmwit> simpson: You don't have an IO a as input, you have a MonadIO m => m a.
18:28:38 <simpson> dmwit: Aha. I see.
18:35:07 * hackagebot file-collection 0.1.1.6 - Provide a uniform interface over file archives and directories  http://hackage.haskell.org/package/file-collection-0.1.1.6 (joel_williamson)
18:45:09 <athan> Can anyone see where I derped? http://stackoverflow.com/questions/30408059/conduit-and-attoparsec-extracting-delimited-text
18:54:31 <tmillc> noob here. explain (.), if you please.
18:55:27 <athan> tmillc: ready? :)
18:55:29 <athan> :t (.)
18:55:30 <Fuuzetsu> f . g = \x -> f (g x)
18:55:31 <lambdabot> (b -> c) -> (a -> b) -> a -> c
18:55:45 <tmillc> athan: I got that far :)
18:55:51 <haasn> or: (f . g) x = f (g x)
18:55:56 <athan> tmillc: We're connecting functions together
18:56:24 <tmillc> \x is an anonymous function
18:56:31 <athan> tmillc: wel...
18:56:36 <athan> all functions are anonymous functions
18:56:39 <tmillc> which I read about and didn't quite get
18:56:41 <athan> but yeah
18:56:42 <tmillc> hha ok
18:57:58 <tmillc> is it supposed to look like function composition
18:58:08 <geekosaur> :t yes
18:58:09 <lambdabot> Not in scope: ‚Äòyes‚Äô
18:58:11 <geekosaur> whoops
18:58:13 <geekosaur> yes
18:58:16 <tmillc> hahah
18:58:27 <tmillc> excellent ok
18:58:30 <geekosaur> most simple setups don't have the raised small circle so . is used instead
18:58:43 <Fuuzetsu> f ‚àò g :)
18:59:14 <exio4> @let f ‚àò g = f . g 
18:59:16 <lambdabot>  Defined.
18:59:27 <lyonsb> so f.g (x) = f(g(x)) = f o g (x) ?  (but small o not regular o)
18:59:32 <Fuuzetsu> exio4: missing the fixity!
18:59:38 <exio4> oh well
18:59:54 <Fuuzetsu> lyonsb: yes, it's just function composition
18:59:56 <tmillc> http://en.wikipedia.org/wiki/Space-cadet_keyboard#/media/File:Space-cadet.jpg
18:59:57 <Fuuzetsu> except using . instead of ‚àò
19:00:13 <athan> lyonsb: application doesn't need parenthesis
19:00:17 <Fuuzetsu> http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Docs.UnicodeInput
19:00:39 <tmillc> noob here, what is fixity?
19:00:54 <Fuuzetsu> how tightly an operator binds
19:00:59 <lyonsb> ty
19:01:20 <Fuuzetsu> just like 1 + 2 * 3 is 1 + (2 * 3) because * binds tighter than +
19:02:17 <lyonsb> Is binding tension synonymous with precedence or is there a subtle difference?
19:02:30 <tmillc> ^
19:02:31 <geekosaur> well, strictly speaking haskell conflates fixity and precedence
19:02:43 <benzrf> geekosaur: wots the diff
19:03:04 <geekosaur> fixity is actually whether it's left or right (compare (*) and (^)
19:03:16 <geekosaur> )
19:04:01 <geekosaur> so 10*20*30 is (10*20)*30 but 10^20^30 is 10^(20^30)
19:04:27 <lyonsb> where * 2 5 = * 5 2  -------  ^ 5 2 /= ^ 2 5, fixity is commutativity or not?
19:04:29 <geekosaur> (*) is infixl, (^) is infixr
19:04:54 <geekosaur> associativity
19:05:29 <geekosaur> left-associative vs. right-associative
19:05:38 <tmillc> the adjectives then are left fixity right fixity
19:06:09 <lyonsb> so * can be both right fixative and left fixative, while ^ can only be right fixative?
19:07:00 <geekosaur> I... would not put it that way but in some sense that is correct (because (*) is commutative, a property that cannot currently be described in Haskell)
19:07:01 <FreeFull> Fixity and commutativity are separate concepts
19:07:23 <lyonsb> Okay.
19:07:26 <tmillc> and they are equiv to right assoc left assoc
19:07:26 <tmillc> err, reverse respective
19:07:28 <FreeFull> (,) could equally well be infixl and infixr or just infix
19:07:29 <geekosaur> ^ "could" be left associative, it just wouldn't behave the way mathematicians expect it to
19:07:53 <mniip> pacak, you still around?
19:08:01 <pacak> I think so
19:08:03 <FreeFull> Youjust want   a ^ b ^ c to mean   a ^ (b ^ c) because the other alternative isn't very useful
19:08:21 <tmillc> geekosaur: I keep stressing my noobness, but why can't it be expressed in Haskell?
19:08:34 <geekosaur> there are still occasional arguments over whether ($) should be left or right associative, although I think Applicative took the edge off some of that?
19:08:35 <tmillc> just because of the currying
19:08:48 <geekosaur> no, has nothing to do with currying
19:09:24 <pacak> Playing around with TH derived stuff for recursion-schemes. catamorphism using derived representations is only  2-3% slower than naive recursion...
19:09:26 <mniip> pacak, how long would it take you to create a parser for arithmetic expressions like 'data Expr = Int Int | Add Expr Expr | Subtract Expr Expr | Multiply Expr Expr'
19:09:29 <geekosaur> Haskell's type system cannot describe commutativity (the idea that for some operator (*), x * y == y * x)
19:09:34 <geekosaur> some other languages can
19:10:13 <tmillc> geekosaur: is this a situation that's clear as to why, for the experienced haskelleton
19:10:15 <geekosaur> and I think there are some type system extensions in GHC that provide a limited way to express that under some circumstances
19:10:25 <lyonsb> I may be incorrect -- but it seems to me that expressing commutativity might not be an essential construct in a programming language.
19:10:31 <mniip> pacak, er, that's not very descriptive, I mean expressions with +-*()
19:10:33 <geekosaur> tmillc, this actually gets into very advanced stuff
19:10:56 <geekosaur> and as lyonsb says, it's not particularly essential although it can expose some potentially useful optimizations in some cases
19:10:58 <pacak> mniip: No idea, haven't tried that. Shouldn't be too difficult.
19:11:15 <geekosaur> but in practice it's rarely useful unless you are doing type level programming --- a very advanced topic
19:11:28 <mniip> pacak, I just scrapped together some peg code
19:11:41 <tmillc> geekosaur: I see, well I'll add it to the list that contains ken... ergh, forgot the second word. 
19:11:44 <lyonsb> <-- is also super-new.
19:12:00 <c_wraith> tmillc: kan extensions?
19:12:03 <tmillc> yes
19:12:03 <geekosaur> kan extensions? another advanced topic :)
19:12:16 <c_wraith> I don't actually know anything about kan extesions.
19:12:17 <lpaste> mniip pasted ‚Äúexpression peg‚Äù at http://lpaste.net/133163
19:12:31 <geekosaur> definitely do not worry about those now, you'll have your hands full soon enough as it is :)
19:12:34 <c_wraith> But I wrote a pretty contentious blog post about using the kan-extensions library despite not knowing anything about it. :)
19:12:44 <tmillc> geekosaur: that's why I'm adding it to "advanced"
19:13:45 <pacak> mniip: I'll try to  make something simple now...
19:14:03 <tmillc> c_wraith: link? :D
19:14:15 <mniip> pacak, oops,
19:14:39 <lpaste> mniip revised ‚Äúexpression peg‚Äù: ‚Äúexpresion peg‚Äù at http://lpaste.net/133163
19:14:45 <c_wraith> tmillc: https://www.fpcomplete.com/user/chowells79/types-not-tutorials
19:14:53 <geekosaur> you'll find people around here who regularly discuss advanced category theoretical concepts. they can be useful in designing things, but you don't need to know advanced category theory to *use* monads, or the lens library, etc.
19:14:59 <tmillc> I have settled on haskell so I am interested in gathering a "full" scope, while I'm learning
19:15:02 <mniip> forgot to swap the name of a function
19:15:43 <geekosaur> you may need to know something about it to *extend* lens, because its internals are heavily based on those concepts --- but extending lens is not something for mortals >.>
19:16:22 <geekosaur> similarly you will encounter monoids fairly early, but you don't need to know ZFC or number theory to use them
19:16:53 <tmillc> geekosaur: luckily I've encountered ZFC and number theory already, so that just strengthens my resolve
19:18:34 <mniip> pacak, if you wonder, here's the code I've written http://lpaste.net/133165
19:18:41 <geekosaur> that might actually be a route to frustration; people who know some number theory are often confused that the typeclasses around Num don;t have a number-theory basis
19:19:51 <mniip> Num, Eq, Ord are mostly for overloading purposes only
19:21:32 <tmillc> Well, again luckily, I'm still a noob and don't have to concern myself with that as long as the tutorials guide me right
19:22:20 <tmillc> I can compartmentalize with the best of them
19:32:58 <StyxAlso> erikd: I‚Äôm working through the Haskell introductory course from UPenn. I‚Äôve done most of the first homework assignment. Is there anything glaringly horrible in my solution? http://lpaste.net/133167
19:33:46 <pacak> mniip: 15 minutes? http://lpaste.net/133168 
19:33:47 <usr> what textbook do oyu guys use StyxAlso ?
19:34:11 <mniip> pacak, "buildExpressionParser" seriously?
19:34:48 <StyxAlso> usr: Uh, it‚Äôs private study. I‚Äôm actually a statistician. So I‚Äôve read through Learn You a Haskell, and some of Thinking Functionally with Haskell
19:35:48 <pacak> mniip: It gives the right answer...
19:36:02 <mniip> pacak, well that heavily relies on built-in misc functions
19:37:29 <pacak> Sure, but it solves the problem and it works in reasonable time.
19:37:44 <usr> StyxAlso: which book was better?
19:38:41 <pacak> I mean - I can write everything from scratch when there's no other choice - for example there's no parsers for FAST encoded market data as  far as I know so I wrote it, but for expression parsing stuff there are tools and I'm using them./
19:39:32 <StyxAlso> usr: I much preferred Thinking Functionally in Haskell
19:39:38 <StyxAlso> I felt that I learned much more
19:39:52 <usr> ah kk will definitely check it out
19:40:25 <StyxAlso> Cool. My favorite thing about that book was that it encourages you to reason equationally about your code.
19:41:05 <pacak> Well, back to recursion-schemes.
19:41:44 <StyxAlso> e.g. map f . map g == map f . g
19:42:10 <geekosaur> I hope you meant map (f . g)
19:42:19 <athan> You can't really make a `not` operator for parsers, can you?
19:42:28 <athan> I mean, you can for characters, but not strings
19:42:44 <c_wraith> You can with sufficient backtracking
19:42:54 <c_wraith> But that can lead to exponential runtimes
19:43:04 <athan> hmm, okay thank you c_wraith
19:43:14 <geekosaur> http://lambda.haskell.org/platform/doc/current/packages/parsec-3.1.3/doc/html/Text-Parsec-Combinator.html#v:notFollowedBy
19:44:21 <athan> thank you geekosaur
19:44:44 <StyxAlso> geekosaur: My apologies, yes, I did
19:45:04 <StyxAlso> geekosaur: I‚Äôm still learning
19:46:54 <f|`-`|f> StyxAlso  you see this link? https://github.com/bitemyapp/learnhaskell
19:47:07 <f|`-`|f> It has references to some pretty good problem sets, CIS, and NICTA
19:47:29 <StyxAlso> Yes, thanks. I just finished the credit card validation problem.
19:47:37 <f|`-`|f> haha!
19:47:58 <f|`-`|f> Also
19:48:20 <f|`-`|f> Someone thought about applying Linear Logic to Blockchains
19:48:22 <f|`-`|f> https://docs.google.com/document/d/1bRGmuTZFLLnFWrgFzV-Sy96lWgkYWdP9ywk21SAbIEM/mobilebasic?pli=1#ftnt_ref1
19:48:46 <f|`-`|f> Makes everything seem less complicated, but I'm still lacking understanding in the terminology
19:50:33 <tmillc> Thinking Functionally with Haskell, UPenn Haskell Intro course, added
19:51:42 <tmillc> minused, neither are easily accessiblew
19:53:20 <tmillc> is there a link to good haskell learnings anywhere? I have found a few, they're probably not unknown
19:54:49 <aatxe> tmillc: CIS 194 at Penn is a fantastic resource.
19:55:34 <aatxe> tmillc: I went along with the whole course this past semester at the recommendation of someone else here.
19:56:19 <f|`-`|f> https://github.com/bitemyapp/learnhaskell <- SOme suggestions ?
20:06:59 <lyonsb> http://www.seas.upenn.edu/~cis194/spring13/lectures/01-intro.html
20:07:09 <lyonsb> ^ CIS 194 from upenn, spring of 2013 edition.
20:07:31 <mjrosenb> recoverEncode: invalid argument (invalid character)
20:07:46 <mjrosenb> I have no clue where this error is coming from.  anyone happen to know?
20:08:04 <mjrosenb> google only points to gitit when I search for that.
20:08:07 <lyonsb> Online version of herculese beelte book: 
20:08:08 <lyonsb> http://book.realworldhaskell.org
20:09:57 <lyonsb> Hercules Beetle even.
20:10:19 <pavonia> mjrosenb: Seems to be related to text encodings. When do you get that error?
20:10:51 <mjrosenb> I /think/ when attempting to rename a file?
20:10:57 <lyonsb> I haven't bought this book, but the person that wrote it seems to have a strong opinion on the subject: http://haskellbook.com/
20:11:06 <lyonsb> (the subject of learning resources)
20:11:19 <mjrosenb> but I'm not 100% sure about that.
20:11:22 <Zemyla> Is there a Strict monad anywhere? It would probably be a good thing.
20:11:22 <lyonsb> (the subject of haskell learning resources)
20:11:49 <Zemyla> It'd be a newtype wrapper like Identity, but would apply functions on it strictly.
20:13:39 <lyonsb> tmillc, Three links posted for your enjoyment.  ^^^ :)
20:13:49 <Fuuzetsu> Zemyla: that sure sounds familiar, I think carter was trying to make such a thing once
20:15:32 <tmillc> lyonsb: thanks :)
20:16:16 <tmillc> I submit also http://shuklan.com/haskell/ is very good
20:16:23 <pavonia> mjrosenb: Do you use non-ASCII characters in your file names?
20:17:29 <Zemyla> Also, do functions ever have to be seqed?
20:18:30 <mjrosenb> pavonia: yes.
20:19:54 <pavonia> mjrosenb: Could be a character not being in the codepage or an improperly encoded one then
20:22:04 <lpaste> kurt21 pasted ‚Äúsimple existential error‚Äù at http://lpaste.net/133173
20:22:26 <kurt21> Can anyone help with what I just posted. I completely don't understand the error
20:23:13 <pavonia> kurt21: Showable isn't an instance ot the Show class
20:23:26 <mjrosenb> OH JOY, I'm getting two different results on two different computers
20:23:41 <mjrosenb> now to figure out what the difference is.
20:24:17 <rty> Hi all
20:24:27 <mjrosenb> LANG=Binary\ file\ \(standard\ input\)\ matches
20:24:32 <mjrosenb> uhhh
20:24:34 <mjrosenb> no
20:24:34 <rty> I am trying to get yesomite to work with cabal. 
20:24:36 <mjrosenb> what?
20:24:45 <rty> It keeps giving me this error whatever i do. 
20:24:57 <rty> cabal: 'require-sandbox' is set to True, but no sandbox is present.
20:25:04 <rty> How do I nuke the cabal settings? 
20:25:45 <rty> It's the 4th day I have had to spend trying to get ghc-mod to play nice ... Well even haskell and cabal aren't playing nice anymore ...
20:25:50 <mjrosenb> rty: rm ~/.cabal/config; but you may want to just change that setting?
20:26:03 <rty> mjrosenb: what should the setting be? 
20:26:08 <mjrosenb> rty: moreover, that may be a setting on the package that you're trying to build, not your setting
20:26:22 <mjrosenb> tmillc: well, generally if things are not True, they are False.
20:26:28 <mjrosenb> rty: ^
20:26:31 <kurt21> Sure, Showable is a custom type with a type parameter a that must have a Show instance.
20:26:33 <mjrosenb> tmillc: whoops.
20:27:08 <kurt21> ah, but I can't show the result...
20:27:09 <carter> Zemyla: Fuuzetsu  i have it on hackage
20:27:12 <carter> strictidentity
20:27:15 <carter> or strict-identiy
20:28:15 <rty> there is no require-sandbox in the config file ...
20:28:36 <mjrosenb> rty: yeah, that sounds more like something that would be on the package.
20:28:52 <mjrosenb> but I'm also incredibly new to sandboxes, and cabal in general, so who knows.
20:29:00 <Fuuzetsu> mjrosenb: True, False, FileNotFound
20:29:04 <rty> Na it's every pacakge. 
20:29:19 <rty> Not just one package that's giving me this error. 
20:29:28 <rty> So, it's something global ... 
20:29:40 <rty> and not in the cabal file ... 
20:29:42 <rty> shigh 
20:30:01 <rty> How do i find out what config file this fellow is linked to ? 
20:30:40 <rty> It took me four days to finally find out the Cabal version I was running had to be replaced by manually downloading an older version ... 
20:30:58 <rty> Well that and a 1020 emacs issues ....
20:31:36 <mjrosenb> rty: can you strace it, and look at all of the files that it opens?
20:34:11 <rty> Ok, I did a cabal sandbox init 
20:34:20 <rty> and it created a sandbox. 
20:34:39 <rty> Now, cabal install --dependencies-only does not work ...
20:34:59 <rty> yikes ...
20:35:34 <rty> cabal: No cabal file found.
20:35:34 <rty> Please create a package description file <pkgname>.cabal
20:36:13 <geekosaur> did you tell it what to install the dependencies for?
20:38:06 <geekosaur> without a package name, that is indeed going to want a cabal package unpacked in .
20:38:20 <geekosaur> because, well, *what* dependencies?
20:39:19 <rty> Well, I don't even want to use a sandbox ...
20:39:28 <rty> so, I don't know what dependencies it needs ...
20:39:46 <geekosaur> I have no idea what you are trying to do
20:40:11 <geekosaur> cabal install --only-dependencies is for when you have a sandbox with a package in it and you want to install the dependencies for that package before working on it
20:40:14 <rty> I am just trying to setup cabal and use cabal to install ghc-mod
20:40:29 <geekosaur> cabal update; cabal install ghc-mod
20:40:48 <geekosaur> you might be better off using a sandbox for that because ghc has some odd opinions about libraries
20:41:54 <rty> when i try that it says cabal: 'require-sandbox' is set to True, but no sandbox is present.
20:42:04 <geekosaur> sigh
20:42:05 <rty> I don't have a .cabal anymore ...
20:42:12 <geekosaur> you did that cabal sandbox init, right?
20:42:13 <geekosaur> where
20:42:14 <geekosaur> ?
20:42:21 <rty> so, where is that flag set ?
20:43:03 <geekosaur> you said you did cabal sandbox init. you probably have a cabal.sandbox.config file
20:43:10 <rty> well I already tried cabl update. Yes sandbox has been reinitalied. 
20:43:18 <rty> I removed it just a few minutes ago
20:43:25 <rty> now it's back ...
20:44:14 <rty> Ok, finally it's rebuilding ... 
20:44:27 <rty> thanks
20:44:49 <geekosaur> this is why you don't just google randomly for stuff, you are likely to get instructions for something that you are not doing
20:44:51 <rty> I wonder if I should use brew now ...
20:45:15 <rty> geekosaur: I didn't google for stuff until, the whole thing messed up. 
20:45:29 <rty> And it wasn't me. It was yesomite + ghc and cabal. 
20:45:33 <geekosaur> if you installed ghc not from brew then it will probably choke on libraries from brew
20:45:58 <geekosaur> because apple ships a bunch of impostor libraries, including iconv which is used by ghc
20:46:12 <geekosaur> whereas brew, or macports, or any other packaging system, will include the real iconv
20:46:48 <rty> well brew gives me the latest cabal, which won't work with ghc-mod
20:46:54 <geekosaur> (readline's another one they do that with)
20:47:20 <geekosaur> so if you are not using brew to get ghc, don't use it to get libraries for use with ghc or you will get oddball link-time errors
20:47:26 <Zemyla> Ohhh, this is why ghc takes so much memory. https://ghc.haskell.org/trac/ghc/ticket/9314
20:47:54 <rty> Ok will stay away from brew for cabal. 
20:48:09 <rty> Wish it just worked ... 
20:48:30 <rty> hmmz 
20:48:41 <rty> cabal Error: some packages faile dto install
20:48:50 <rty> ghc-mod-5.2.1.2
20:48:54 <rty> shigh ...
20:49:05 <rty> this is just hell ...
20:49:17 <geekosaur> if Apple didn't ship a bunch of impostor libraries, many things would be much easier
20:49:21 <rty> four days straight of this ... 
20:49:53 <geekosaur> brew had to learn that one the hard way, as macports had to 15 years ago and fink did several years before that
20:50:22 <geekosaur> (in all cases because they figured they knew better than the "unnecessarily complex" predecessors...)
20:52:28 <rty> maybe i will have better luck with macports
20:52:31 <rty> or fink
20:52:49 <geekosaur> unlikely, the problem here is OS X is not a friendly place for third party stuff
20:53:01 <geekosaur> it is often easiest to just set up a Linux VM
20:53:23 <geekosaur> (or use something that is strictly sandboxed like Nix, but Nix is not exactly friendly)
20:53:33 <c_wraith> in my experience, brew is way better thank fink.  I never tried macports
20:54:01 <c_wraith> But in my experience, it's also the case that no system-level installer installs GHC well
20:54:04 <rty> brew worked exept for the developer being on vacation since January on the ghc-mod error ...
20:54:08 <rty> and whatever else ...
20:54:27 <rty> I don't understand any of it ... 
20:56:24 <rty> let me just buy a vps server and set that up. 
20:56:29 <rty> This is just a waste of time ...
20:58:56 <pacak> https://gist.github.com/pacak/65a48eba7c38dc6b614c
21:11:42 <mmachenry> I had to reinvent fold to implement a function and I feel like I should not have had to. Anyone know if there's a function that does what I'm trying to do here? http://lpaste.net/edit/131840
21:14:39 <Zemyla> mmachenry: You should probably be using LogicT instead of ListT. https://hackage.haskell.org/package/logict-0.6.0.2
21:15:18 <Zemyla> LogicT is basically a continuation-passing version of myFold.
21:16:32 <Zemyla> Also, is there any reason I'm not receiving my verification e-mail for the GHC Trac wiki?
21:17:37 <Zemyla> I have the correct e-mail address, I'm sure of it, and I told it twice to send a notification e-mail.
21:19:21 <mmachenry> Zemyla: Sadly, STMContainers.Map only provides "stream :: Map k v -> ListT STM (k, v)"
21:22:15 <shane_> I am not sure if this is the appropriate place to ask this question: I am aware that one has to be careful when mixing laziness and strictness, but if I am not taking advantage of GHC's lazy evaluation, is there any harm, when combining functions, I add strictness annotations so that they do not develop deep thunks and I prevent a space leak rather than hunt for one?
21:24:52 <c_wraith> shane_: too much strictness causes problems too
21:25:20 <shane_> @c_wraith even when not combined with laziness?
21:25:20 <lambdabot> Unknown command, try @list
21:25:25 <c_wraith> shane_: you end up allocating things that will never be needed
21:25:55 <c_wraith> shane_: after all, the whole point of laziness is not doing computations that will never be needed
21:26:16 <shane_> True, but in that case, is it not true that I no worse than a strict language?
21:26:19 <c_wraith> shane_: I had a recent issue where I had too much memory use caused by using Control.Monad.State.Strict instead of Control.Monad.State
21:27:14 <c_wraith> shane_: and my point is, strict evaluation has just as many memory use problems as lazy evaluation.  You can't get correct behavior in general without thinking about what's going on.
21:30:00 <shane_> c_wraith: so it is correct to say that if I enforced strictness (where I am not mixing it with laziness, which can lead to blow ups), I may be using uncessary space, but at least I am no worse off than if I did this in a strict languge?
21:30:16 * hackagebot vado 0.0.5 - Runs commands on remote machines using ssh  http://hackage.haskell.org/package/vado-0.0.5 (HamishMackenzie)
21:30:19 <c_wraith> shane_: actually, you can be, just due to idiomatic issues
21:30:43 <shane_> c_wraith: can you give me an example? Or an idea of how that can happen?
21:30:55 <c_wraith> shane_: in haskell, it's idiomatic to assume laziness.  You write many independent steps that do one thing at a time, and depend on laziness to avoid duplicating work.
21:31:34 <c_wraith> shane_: in strict-by-default languages, you end up writing lots of duplicated code that fuses the steps together to avoid unnecessary runtime work.
21:31:57 <c_wraith> shane_: a specific example is something as simple as zipWith [1..]
21:33:53 <c_wraith> shane_: slightly more complex examples come from writing something like  all = foldr (&&) True ; any p = all . map p
21:34:24 <c_wraith> shane_: the latter definition is only a reasonable implementation because of laziness
21:35:19 <c_wraith> err.  any is the wrong name.  Whoops.
21:35:27 <c_wraith> Despite that, the logic stands.
21:35:38 <c_wraith> oh, right, the names should have been and and all
21:36:46 <c_wraith> But breaking things down into small independent pieces like that depends on map being lazy and foldr being lazy
21:37:46 <c_wraith> And decomposing problems into independent generation and processing is idiomatic in haskell, where other languages make fusing them into one pass idiomatic due to the strict evaluation model
21:39:04 <shane_> c_wraith: thanks, I understand. I am trying to follow a few rules of thumb to avoid space leaks when they will almost certainly occur. One: when dealing with recursion, add strictness to whatever I am passing on (and step into those areas of the data structure where the modification is occurring).
21:40:16 * hackagebot liquidhaskell 0.4.1.1 - Liquid Types for Haskell  http://hackage.haskell.org/package/liquidhaskell-0.4.1.1 (EricSeidel)
21:40:30 <ryantrinkle> shane_: it's definitely good to learn about these and to keep these things in mind, but in my experience, they come up *very rarely* in production code
21:40:48 <c_wraith> well..  So long as you remember to never use foldl. :)
21:41:11 <ryantrinkle> the vast majority of the haskell code i've written would work exactly the same whether it's lazy or strict
21:41:33 <Fuuzetsu> hopeful statements general
21:41:43 <ryantrinkle> but by letting GHC pick the execution strategy (it does make things strict sometimes automatically), i get great performance for super-high-level code
21:42:19 <Zemyla> c_wraith: So when should I use foldr and when should I use foldl'?
21:42:25 <shane_> Right, that is the other thing I try to remember, that even when some implementation is said to br strict, like fold', it is still my responsibility to ensure that the strictness is as deep as I need it
21:43:38 <c_wraith> Zemyla: In general, use foldl' when the processing must always scan the entire list to produce a value.  Use foldr otherwise.
21:44:31 <ryantrinkle> shane_: yeah, definitely; and tbh, usually if i *really* care about how something's going to execute, I write it out myself - because usually it's a more complex recursion scheme than foldl', and usually I don't precisely know what recursion scheme it's going to be when i start writing
21:45:16 <shane_> But are there other dangers that a lazy *by default* lures me in and that I have to be cautious about? Things like let a = [1..10^8] in sum a * product a are problems that would occur (and perhaps be even worse) even if the language was strict by default, right, so that is something I would have to be cautious about anyway?
21:45:18 <ryantrinkle> one thing that haskell is really great about is letting you write something however makes sense and giving you reasonable performance; and then letting you profile, quickly narrow down where the hot spots are, and improve things
21:45:49 <ryantrinkle> shane_: yes, in a strict language, that would blow up regardless of what the "in" clause of the let expression said
21:46:30 <ryantrinkle> even though haskell is lazy by default, that's not usually the mental model i use
21:46:48 <ryantrinkle> usually i think of it as "compiler's choice" execution strategy
21:47:38 <shane_> it seems that a lot of criticisms of haskell's lazy by default are really about problems that would occur even in strict languages if one used the same algorithm. It's just that in haskelll it is possible to exploit laiziness to use cleaner code but then one has to be careful about space usage
21:47:50 <shane_> Is that true?
21:47:55 <ryantrinkle> if i actually care about the execution model - whether i want it to be lazy or strict or a combination - then that's an unusual case and i expect to have to annotate things (with formal annotations or with comments) anyhow
21:48:00 <ryantrinkle> yeah, i'd say so
21:48:48 <dolio> Sometimes laziness makes things worse. But eventually you learn to preempt cases where it would.
21:48:52 <ryantrinkle> in 6 years of using haskell full-time, i've probably spent a total of 80 hours on bugs caused by too much laziness
21:48:55 <dolio> And it's not that bad.
21:49:50 <shane_> dolio: and I am guessing a lot of those cases were where you were exploiting laziness to your advantage but needed extra care?
21:49:51 <ryantrinkle> (more time than that on profiling and improving performance, which sometimes involves laziness, but i think of that as a different activity)
21:50:08 <dolio> There are some evaluation models that would make it even rarer for that to be a problem, too. But they're complicated.
21:50:39 <dolio> shane_: No, I mean cases where something would just work right in a strict language, and don't in a lazy language.
21:51:06 <Zemyla> Generally, if you're manipulating numbers, you want those to be strict. Especially loop counters.
21:51:33 <shane_> dolio: could you give me an example of that type? Other than recursion calls where the arguments being passed need to be evaluated in the part of the data structure that is going to be modified?
21:52:55 <dolio> shane_: I'm not exactly sure what your side condition means. But stuff like 'loop acc 0 = acc ; loop acc n = loop (acc+1) (n-1)'
21:53:04 <dolio> You need to keep acc evaluated.
21:53:51 <dolio> Actually, you probably need to be trickier than that example to get GHC to not do things right.
21:54:02 <shane_> dolio: this is a rule of thumb that I have been following: whenever accumulating values, make sure that they are evaluated appropriately. 
21:54:21 <shane_> dolio: but I am more scared other kinds of space leaks that I may not have anticipated
21:54:44 <shane_> and which may occur in a lazy by default language and not in a strict one, even though the algorithm is the same
21:54:56 <dolio> But that's the sort of example where laziness does things worse, instead of accidentally not being better than strict evaluation.
21:55:27 <dolio> However, things like 'loop' get easy to notice after a while.
21:56:04 <shane_> If I strictly evaluated (acc+1) and (n-1) in your example, before the recursion step, that would make things fine right?
21:57:05 <dolio> n is already strict.
21:57:17 <dolio> Because it matches against 0 every time.
21:58:10 <dolio> It might also figure out that acc is strict.
21:58:17 <shane_> dolio: true. on this note, I know it is unnecessary to strictify n as you pointed out, but would the penalties be high if I did so because I chose safety over a performance gain?
21:58:19 <dolio> Because it gets returned eventually.
21:58:36 <dolio> No, I think there are no penalties anymore.
21:58:51 <dolio> In some previous version it sometimes was slower, slightly.
21:58:58 <dolio> But I think that's been fixed.
21:59:58 <Zemyla> Well, if you're assembling something, you want to make t strict.
22:00:17 * hackagebot jsaddle 0.2.0.5 - High level interface for webkit-javascriptcore  http://hackage.haskell.org/package/jsaddle-0.2.0.5 (HamishMackenzie)
22:00:19 * hackagebot target 0.1.3.0 - Generate test-suites from refinement types.  http://hackage.haskell.org/package/target-0.1.3.0 (EricSeidel)
22:00:23 <shane_> dolio: do you have "non-accumulator" examples of where space leaks created a problem for you?
22:00:59 <shane_> dolio: where the space leak was not caused by something that was being accumulated as thunks, rather than as values as one normally would suspect.
22:02:57 <dolio> No. I've been writing Haskell too long to have many problems with space leaks anymore.
22:04:45 <shane_> dolio: I meant the kind of leaks you had problems with perhaps even in the beginning. You said you had to spend some time fixing leaks although they were not much, considering that you have been programming in haskell for 6 years.
22:05:21 <shane_> dolio: but among those few times, were they almost always of the types where an accumulator was developing thunks?
22:06:42 <shane_> dolio: are there any rules of thumb that you feel have been particularly helpful in almost never encountering space leaks any more. I know experience helps, but is there anything that you wish you knew before hand?
22:08:09 <dolio> Accumulator type things can get trickier than you might think.
22:08:21 <dolio> Sometimes they're hidden in ways you don't think about.
22:08:55 <shane_> dolio: you mean deep in a data structure for instance?
22:09:48 <shane_> dolio: in a lazy data structure, to be more precise
22:10:42 <dolio> Well, one that's tricky, or used to be, is calling randomIO a lot, and not using the random numbers.
22:11:09 <dolio> randomIO uses a RNG state stored in an IORef.
22:11:23 <dolio> Pulls it out, generates a random number, puts the new state back in.
22:12:03 <dolio> If you do that enough, and don't look at any of the random numbers, you'd end up with a stack overflow as the RNG state.
22:12:06 <Zemyla> Generally, if you're calling randomIO, you're doing it wrong.
22:12:27 <c_wraith> dolio: recent versions of GHC removed stack overflows!  (things just get really slow)
22:13:08 <dolio> Yes, I know. Now it will just use a lot of memory.
22:13:21 <dolio> If you're using System.Random you're probably doing something wrong.
22:13:42 <dolio> But, it was a weird bug once upon a time.
22:13:44 <shane_> dolio: even with System.Random? Could you explain?
22:13:54 <c_wraith> System.Random is a nice simple, sane interface.  Too bad about the performance.
22:14:24 <shane_> what is a good alternative to System.Random?
22:14:43 <c_wraith> the mwc-random package is one good alternative
22:14:45 <c_wraith> there are some others
22:15:47 <dolio> Another bug that hits people is: foldl' (\p x -> (fst p + x, snd p + 1)) (0,0) l
22:15:47 <shane_> I used System.Random more than once; I never ran into a space leak while profiling, but there the use was very straightforward: I used randomRs to create a list and was using those values one by one
22:15:56 <dolio> I'm using foldl', so I'm safe, right?
22:15:58 <c_wraith> Of course, if you need secure properties from your random data, mwc-random is entirely useless.
22:16:13 <shane_> what kind of problems occur with System.Random?
22:16:47 <c_wraith> It's slow and has quality issues
22:16:53 <c_wraith> at least StdGen does
22:17:03 <shane_> dolio: In your example, is the problem that the evaluation is only triggered to weak head normal form? 
22:17:11 <ReinH> shane_: tuples are lazy
22:17:22 <dolio> Yes. It's not evaluating the arithmetic, only the tuple.
22:17:29 <shane_> right...so one would have to step inside the tuple
22:17:38 <ReinH> so evaluation of the tuple up to the first constructor, (,), doesn't evaluate the thunks inside the tuple
22:17:51 <ReinH> You need a strict tuple or strictness annotations
22:18:14 <ReinH> shane_: this is my favorite article for reasoning about space "leaks" http://apfelmus.nfshost.com/blog/2013/08/21-space-invariants.html
22:18:42 <shane_> right...is it fair to say that when one is accumulating in a data type. like this fold' example, one can elimintate the possibility of a space leak by stepping inside those parts of the data constructor which are altering in each step?
22:19:32 <ReinH> shane_: basically. You should read the link :)
22:19:32 <c_wraith> yeah, that article is the only one I've read that accurately describes the process of thinking about space use in practical terms.
22:20:12 <ReinH> the idea in this case is that when the (,) constructor is scrutinized, the thunks `fst p + x` and `snd p + 1` should also be evaluated
22:20:41 <ReinH> so you use either a strict data Pair a b = Pair !a !b or you use bang patterns or seq
22:20:56 <shane_> ReinH: I read that article and really liked it. 
22:21:01 <ReinH> :)
22:28:40 <shane_> By the way, about that article on space invariants, what exactly does the term "space invariant" mean? If I understood correctly, the article was saying that by using seq a b, you have tied in the space usage of b with that of a?
22:31:48 <pingu> I wish to learn more formally the difference between initial and final encodings. Anyone know where words are on this distinction?
22:32:00 <pingu> Or even what it more formally means?
22:32:25 <Zemyla> Why is there not a ForeignFunPtr? And if I want one, how do I get one?
22:33:18 <Zemyla> I mean, I know all the arguments about why there isn't one normally, but I actually do have a use case for it.
22:36:48 <pingu> Zemyla: I'm not even sure what that would mean. It'd be different to a FunPtr how?
22:37:08 <Zemyla> When the last reference to it goes away, a finalizer is called.
22:37:17 <pingu> ah.
22:37:30 <pingu> can't you just use a normal foreignptr then and cast it when you want to use it?
22:37:43 <pingu> castPtrToFunPtr :: Ptr a -> FunPtr b
22:38:10 <Zemyla> I'm writing a wrapper around GNU Lightning, a JIT library.
22:39:42 <Zemyla> I suppose. I mean, Ptr and FunPtr are both wrappers around the same primitive.
22:40:10 <Zemyla> I suppose I could have ForeignFunPtr be a newtype wrapper around ForeignPtr.
22:40:18 <pingu> So yeah, I think you can just withForeighPtr fptr (whatever . castPtrToFunPtr)
22:41:34 <lf94> Hey...So I'm encountering some Monad issues. I have IO inside []. How the hell do I get the value in the IO Monad?
22:41:53 <Fuuzetsu> lf94: what if the list is empty?
22:41:55 <lf94> (Give me second to paste bin)
22:42:01 <Fuuzetsu> @where lpaste
22:42:01 <lambdabot> http://lpaste.net/
22:42:09 <lf94> Is gist ok?
22:42:11 <Fuuzetsu> sure
22:42:27 <lf94> I have an emacs minor mode that gists things quickly :)
22:42:46 <Fuuzetsu> there is a thing called PastePipe which will lpaste things quickly ;)
22:42:53 <timothyh> pingu: do you want words more comprehensible than oleg's?
22:43:04 <Zemyla> :t sequenceA
22:43:06 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
22:43:10 <pingu> timothyh: oleg's are fine, but his papers don't seem to mention the distinction explicitly
22:43:27 <pingu> at least, I can't find one that odes
22:43:34 <timothyh> hm yeah I don't think i have either
22:43:38 <Zemyla> :t sequenceA :: [IO a] -> IO [a]
22:43:40 <lambdabot> [IO a] -> IO [a]
22:43:45 <timothyh> although i don't always get a ton out of his papers
22:43:51 <lf94> https://gist.github.com/5a9f73ea4ad29937a1d2
22:43:53 <lf94> ^
22:44:05 <Zemyla> lf94: Is that something you want?
22:44:15 <pingu> timothyh: yeah, I find them quite wordy and roundabout sometimes.
22:44:33 <Zemyla> Turn a list of IO actions into an IO action tht returns a list?
22:44:33 <lf94> So for userInput, I'm trying to get a character
22:44:45 <Fuuzetsu> lf94: your userInput needs to be in IO
22:44:47 <lf94> Zemyla: uhm...
22:44:57 <timothyh> I had just assumed initial encoding was similar to what i'd been calling a shallow embedding
22:45:05 <pingu> timothyh: so do you know what finally vs initial means formally? If so, where did you lean that?
22:45:08 <timothyh> with a vague association with initial algebra
22:45:23 <pingu> hmmn. Perhaps?
22:45:27 <timothyh> nope! I thought I had a gut intuition but... that has dissolved
22:45:30 <lf94> Fuuzetsu, so change it's signature to: userInput :: IO HangmanWord -> HangmanWord ?
22:45:33 <Fuuzetsu> no
22:45:38 <Fuuzetsu> lf94: userInput :: HangmanWord -> IO HangmanWord
22:45:42 <pingu> I hear that free monads are initial
22:45:50 <pingu> and things like mtl are final
22:45:51 <lf94> Fuuzetsu, that messes up my "until" in main.
22:45:53 <timothyh> if you find a good resource, do hilight me in au pls
22:45:57 <Fuuzetsu> :t untilM
22:45:59 <lambdabot>     Not in scope: ‚ÄòuntilM‚Äô
22:45:59 <lambdabot>     Perhaps you meant ‚Äòuntil‚Äô (imported from Prelude)
22:46:00 <pingu> and free monads I presume are the initial object in some category
22:46:03 <lf94> oh!
22:46:10 <timothyh> yeah
22:46:12 <pingu> like Fix is the inital object in the category of algebras
22:46:12 <Fuuzetsu> oh untilM is in monad-loops I think
22:46:18 <lf94> Ok, I didn't know there was a untilM
22:46:24 <lf94> I'll try that :)
22:46:49 <timothyh> like a deep embedding vs shallow embedding of a DSL in papers is usually uh, can you statically analyse the tree you've built without running it
22:47:01 <Fuuzetsu> well, it's not in base but you can write untilM if you need it
22:47:03 <timothyh> or something? it's been a while
22:47:08 <pingu> timothyh: yeah, that's been my *intuition*
22:47:16 <ReinH> pingu: http://en.wikipedia.org/wiki/Initial_algebra
22:47:20 <pingu> that final encodings do not allow reflection
22:47:29 <pingu> ReinH: so I know a *little* about initial algebras.
22:47:40 <lf94> Fuuzetsu, I can't import it?
22:47:42 <Fuuzetsu> http://hackage.haskell.org/package/monad-loops-0.4.2.1/docs/src/Control-Monad-Loops.html#untilM
22:47:42 <pingu> but I'm trying to work out what initial vs final encodings are in regard to DSLs
22:47:50 <Fuuzetsu> you can if you get the monad-loops package
22:47:51 <pingu> ReinH: are you saying that's the same thing?
22:47:53 <lf94> untilM would involve lift or something
22:47:57 <ReinH> pingu: yes
22:48:08 <pingu> ReinH: OK, so initial makes sense to me then.
22:48:10 <pingu> but final does not.
22:48:17 <ReinH> final = terminal
22:48:25 <pingu> like a coalgebra?
22:48:32 <lf94> I feel like this should be something standard
22:48:32 <ReinH> yes exactly
22:48:33 <pingu> and paramorphisms?
22:48:42 <ReinH> pingu: that's explained in the wikipedia article btw
22:48:42 <lf94> Maybe...maybe my function in the until should lift.
22:48:53 <lf94> isHangmanWordCorrect
22:48:59 <Fuuzetsu> why do you insist on lifting anything?
22:49:08 <lf94> To get the value?
22:49:10 <Fuuzetsu> what kind of definition of lifting do you mean?
22:49:19 <pingu> ReinH: so when people talk about final encodings they are talking about encodings using the terminal object in the coalgebra category
22:49:22 <Fuuzetsu> :t liftM
22:49:23 <Fuuzetsu> :t lift
22:49:23 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
22:49:24 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
22:49:26 <lf94> Maybe the word "join" or "bind" is better
22:49:31 <pingu> ReinH: is that what you are saying?
22:49:32 <Fuuzetsu> :t join
22:49:33 <lambdabot> Monad m => m (m a) -> m a
22:49:34 <Fuuzetsu> :t (>>=)
22:49:35 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:49:40 <Fuuzetsu> we have all those things and they are not the same :)
22:49:56 <lf94> bind is pretty close to what i need
22:50:19 <lf94> what do you suggest, Fuuzetsu 
22:50:21 <ReinH> pingu: a final encoding is a terminal F-coalgebra
22:50:25 <lf94> I'm a pretty noob haskeller :)
22:50:56 <pingu> ReinH: so, a paramorphism if we're talking about C being endofunctors in haskell?
22:50:58 <Fuuzetsu> personally I would either just use monad-loops package or quickly write my own specialised loop that does what untilM would anyway, inside a let
22:51:29 <ReinH> pingu: well, a catamorphism
22:51:40 <pingu> ReinH: err, whatever unfold would be right?
22:51:44 <ReinH> cata
22:51:47 <Fuuzetsu> hm, actually thinking about the the untilM in that package would be nasty for you 
22:51:50 <pingu> I get them mixed up.
22:51:52 <Fuuzetsu> I think there's a better function
22:51:53 <ReinH> pingu: :)
22:51:55 <lf94> heh...
22:51:59 <ReinH> pingu: so there you go :)
22:52:03 <pingu> ReinH: okay, thanks.
22:52:05 <lf94> can you use "flip" on >>= ?
22:52:06 <pingu> That's simpler than I thought.
22:52:09 <ReinH> pingu: :)
22:52:12 <Fuuzetsu> :t whileM
22:52:13 <lambdabot> Not in scope: ‚ÄòwhileM‚Äô
22:52:17 <Fuuzetsu> uh
22:52:31 <pingu> so mtl is unfolding monadic actions, whilst free monads are folding them.
22:52:37 <Fuuzetsu> oh well, just write a mini loop inside let
22:52:37 <pingu> I suppose that makes sense, to an extent.
22:52:46 <ReinH> pingu: I'm not sure about that
22:53:04 <Fuuzetsu> lf94: there exists =<< which is already flipped >>=
22:53:11 <pingu> ReinH: yeah, mtl gets a little messy I think. It's operating in a different category last time I checked.
22:53:13 <lf94> Oh!
22:53:25 <ReinH> pingu: I don't have any sort of intuition for how mtl works for a CT perspective
22:53:26 * Fuuzetsu doesn't like =<<
22:53:27 <pingu> I'm not sure what the analog would be. I shall read more.
22:53:32 <ReinH> *from
22:53:50 <ReinH> edwardk probably does, fwiw
22:53:53 <Fuuzetsu> :t liftM3 until
22:53:54 <lambdabot> Monad m => m (r -> Bool) -> m (r -> r) -> m r -> m r
22:53:57 <lf94>  correctWord <- until (<<= isHangmanWordCorrect) (userInput) userWord
22:53:58 <pingu> ReinH: I remember reading something about them here: built
22:53:59 <pingu> derp
22:54:02 <pingu> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.2698
22:54:11 <Fuuzetsu> no, that's not going to work
22:54:17 <lf94> Not yet :)
22:54:23 <ReinH> pingu: ah, that looks relevant at least
22:54:38 <Fuuzetsu> ‚Äòuntil‚Äô is just the wrong type, it will never work no matter what you put to the right of it
22:54:42 <Fuuzetsu> :t until
22:54:43 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
22:55:10 <pingu> ReinH: thanks, that was very helpful.
22:55:12 <ReinH> pingu: "the coproduct of arbitrary monads does not always exist" is a restatement of "monads are not closed under composition"
22:55:26 <ReinH> (as opposed to applicatives, which are)
22:55:35 <ReinH> pingu: :)
22:55:38 <ReinH> yw
22:55:43 <pingu> ReinH: I'll have to think about that one.
22:55:52 <lf94> Maybe I shouldn't be getting user input inside the until.
22:55:55 <pingu> you're talking about the monoidal category of endofunctors right?
22:56:03 <pingu> and how applicative is a different tensor to monad?
22:56:10 <ReinH> pingu: http://stackoverflow.com/a/7042674/2225384
22:56:24 <pingu> ReinH: thanks, will read.
22:56:26 <Fuuzetsu> lf94: you need to get user input *somewhere* and it's going to be within some kind of loop
22:56:26 <lf94> I can't think of a better way to do this
22:56:39 <Fuuzetsu> your loop is created by until which just won't deal with IO inside of it
22:56:45 <lf94> yeah...I was counting on until being that loop.
22:57:01 <lf94> Guess I'll look into untilM.
22:57:06 <Zemyla> :t \p t -> let go a = p a >>= (\b -> if b then t a >>= go else return a) in go
22:57:07 <lambdabot> Monad m => (b -> m Bool) -> (b -> m b) -> b -> m b
22:57:08 <lf94> untilM doesn't even show up on Hoogle :/
22:57:10 <Fuuzetsu> untilM won't be nice to use for you
22:57:23 <Zemyla> lf94: Does that look like a better function?
22:57:44 <lf94> Looks way messier X)
22:57:56 <Fuuzetsu> he doesn't need that type
22:57:57 <Zemyla> Yes, but does the type look better?
22:57:59 <lf94> Give me a minute to decipher it
22:58:08 <Fuuzetsu> Monad m => (b -> Bool) -> (b -> m b) -> b -> m b
22:58:11 <Fuuzetsu> is what he wants
22:58:12 <Zemyla> Fuuzetsu: What type does he need?
22:58:38 <Zemyla> :t \p t -> let go a = if p a then t a >>= go else return a in go
22:58:40 <lambdabot> Monad m => (b -> Bool) -> (b -> m b) -> b -> m b
22:58:48 <Zemyla> There e go.
22:58:57 <Fuuzetsu> yes, *I* know how to write that ;P
22:59:10 <lf94> So just recursive loop
22:59:13 <Fuuzetsu> yes
22:59:17 <ReinH> pingu: he has another answer somewhere that talks about what is necessary to have this commutative property (m . n = n . m) for some monads m, n, one sec
22:59:17 <Zemyla> YYep.
22:59:23 <ReinH> or at least what is sufficient
22:59:32 <lf94> That is so not nice looking :s
22:59:45 <Fuuzetsu> you can use do notation instead
23:00:09 <lf94> I'm going to bundle it into a nice looking function
23:00:13 <Fuuzetsu> and go would be in a let anywhere probably
23:00:23 <lf94> Also isn't if/then/else sort of a no-no in FP?
23:00:29 <Fuuzetsu> why would it be?
23:00:32 <ReinH> pingu: ah http://stackoverflow.com/a/13100857/2225384
23:00:35 <lf94> No idea
23:00:42 <ReinH> pingu: that one is pretty intereseting
23:00:45 <Fuuzetsu> where did you hear it's a no-no?
23:00:47 <ReinH> and also interesting..
23:00:55 <lf94> I just see people never using it
23:01:09 <Fuuzetsu> because it's just not that useful
23:01:24 <Fuuzetsu> and because it's a primitive thing, it doesn't compose nicely unless you wrap around it
23:01:26 <ReinH> booleans aren't as special here
23:01:27 <pingu> ReinH: that escalated quickly
23:01:31 <ReinH> pingu: :)
23:01:47 <ReinH> they're just a (rather boring) sum type
23:01:49 <Zemyla> Honestly, people should be using Church booleans. :P
23:01:51 <pingu> ReinH: okay, caffiene first then much reading. thanks.
23:01:57 <ReinH> pingu: :) yw
23:02:22 <ReinH> so having special syntax for them is a bit strange in a way
23:02:49 <ReinH> we don't have special syntax for using data Confirm = Yes | No, despite it being essentially the same type
23:02:57 <Fuuzetsu> pingu: the CT definition of distributive law is probably 5 times easier to read than the Haskell version there
23:03:00 <Zemyla> Like, true = const, false = const id.
23:03:12 <Fuuzetsu> http://en.wikipedia.org/wiki/Distributive_law_between_monads
23:03:13 <Fuuzetsu> there you go
23:03:22 <pingu> Fuuzetsu: yeah, it' wasn't confusing at all in that first article ;)
23:03:33 <pingu> but that's the point of CT right?
23:03:43 <pingu> ReinH, Fuuzetsu: https://oleksandrmanzyuk.files.wordpress.com/2012/02/calc-mts-with-cat-th1.pdf
23:03:44 <ReinH> Fuuzetsu: yep, just a couple obvious coherence conditions
23:03:49 <Fuuzetsu> also http://lpaste.net/3169489335334469632
23:03:50 <pingu> That looks interesting too
23:03:50 * Myrl-chan wonders if there's a Truthy/Falsy typeclass.
23:03:57 <ReinH> pingu: oh cool, thanks
23:04:01 <Myrl-chan> Not that it's a good thing, just curious though.
23:04:11 <Fuuzetsu> Myrl-chan: nothing standard
23:04:32 <pingu> Fuuzetsu: what language is this?
23:04:41 <Myrl-chan> Fuuzetsu: Ah.
23:04:49 <Fuuzetsu> agda
23:05:04 <Fuuzetsu> Myrl-chan: pattern matches beat booleans any day
23:05:18 <pingu> Fuuzetsu: ah, it's quite nice looking
23:05:22 <ReinH> Fuuzetsu: nice, where's that from?
23:05:35 <Fuuzetsu> I wrote it some time ago
23:05:39 <ReinH> Fuuzetsu: nice, looks good
23:05:52 <ReinH> Fuuzetsu: have you seen johnw's stuff in Coq?
23:05:55 <Myrl-chan> Fuuzetsu: Agree.
23:06:00 <Fuuzetsu> ReinH: which stuff
23:06:06 <ReinH> one sec
23:06:40 <Tirabubuxx> Ciao a tutti :))
23:06:55 <ReinH> Fuuzetsu: https://github.com/jwiegley/category-theory
23:07:49 <Fuuzetsu> ah; when I was in a market for category lib I looked for one that was a bit more complete
23:07:57 <Fuuzetsu> there's a good thread on SO listing such libs
23:08:02 <ReinH> Fuuzetsu: oh is there?
23:08:06 <ReinH> cool :)
23:08:18 <Fuuzetsu> http://mathoverflow.net/questions/152497/formalizations-of-category-theory-in-proof-assistants
23:08:20 <Fuuzetsu> well, MO
23:08:26 <ReinH> Nice :)
23:08:31 <johnw> that library has run out of steam for the time being
23:08:49 <Fuuzetsu> I looked at bunch of them, probably the most complete one for what I wanted was the coq-hott library with its category subdirectory
23:09:03 <Fuuzetsu> it had pseudo-functors at least which I wanted
23:09:06 <ReinH> :)
23:09:20 <johnw> yeah, and coq-hott is partly maintained by jgross, who is amazing
23:09:33 <Fuuzetsu> I didn't end up using that actually
23:09:40 <Fuuzetsu> I used the categories Agda lib
23:09:44 <johnw> ah
23:09:56 <Fuuzetsu> I don't speak Coq and it complicated matters that it was based on HOTT
23:11:21 <Fuuzetsu> anyway, regarding the distributive law itself, the thing I like about it is that it induces another monad which is like the two underlying monads combined
23:11:23 <Fuuzetsu> which I think is cool
23:11:34 <johnw> Fuuzetsu: so, I do have some Coq work directly relating to distributed monads
23:11:51 <johnw> https://github.com/jwiegley/coq-haskell/blob/master/MCompose.v
23:12:19 <Fuuzetsu> I was actually interested in pseudodistributive monads rather than the regular ones
23:12:40 <Fuuzetsu> oh damn, that cited 1993 paper
23:12:46 <Fuuzetsu> I was looking for that proof
23:13:02 <johnw> yeah, I pretty much implemented their proof directly in Coq
23:13:09 <johnw> they made some really good intuitive leaps
23:13:34 <johnw> like introducing "id" in just the right place, so that you can rewrite it to something equivalent that lets you reduce something else immediately next to it
23:13:35 <Fuuzetsu> all I found was ‚Äòhey you can make a monad out of it like this, Trust Us‚Ñ¢‚Äô though I haven't looked that hard to be fair
23:13:49 <johnw> yeah, I found the exact same thing when I went looking for proof that applicative functors compose
23:13:55 <johnw> I found about 7 authors saying, "As everyone knows..."
23:14:02 <johnw> but I never did find a proof anywhere
23:14:13 <johnw> that made ACompose.v take a lot longer
23:14:19 <Fuuzetsu> when you write your paper just say ‚ÄòAs everyone knows‚Ä¶‚Äô
23:14:22 <johnw> haha
23:14:40 <ReinH> heh
23:15:29 <Fuuzetsu> what's RMonad/RApplicative &c?
23:15:57 <johnw> relative monads
23:16:01 <johnw> just an idea I was playing with
23:16:20 <Fuuzetsu> >A relative monad is what is to a relative adjunction as a monad is to an adjunction.
23:16:30 <Fuuzetsu> oh
23:16:36 <Fuuzetsu> it's from that monads need not be endofunctors paper
23:16:49 <ReinH> Fuuzetsu: which one is that?
23:17:08 <Fuuzetsu> http://www.cs.nott.ac.uk/~txa/publ/jrelmon.pdf
23:17:09 <johnw> for me a "relative monad" just maintains a relation between the first and second m in the type of join
23:17:44 <ReinH> Ah, interesting
23:17:55 <lf94> Fuuzetsu, I'm so close with untilM ;_;
23:17:56 <Fuuzetsu> I never read the paper, just know it exists
23:18:02 <lf94> correctWord <- untilM (userInput userWord) (isHangmanWordCorrect)
23:18:21 <lf94> I need the output of (userInput userWord) to feed into (isHangmanWordCorrect)
23:18:37 <Fuuzetsu> yes, and untilM doesn't do that which is why I said you probably don't want to do that
23:18:50 <Fuuzetsu> also you have spurious parenthesis
23:18:50 <lf94> Is there no way to get around it?
23:19:30 <Fuuzetsu> there is if you rewrite isHangmanWordCorrect to read out of an IORef or whatever or use a State + IO stack or something, all much worse than just not using untilM
23:19:45 <lf94> totally right there.
23:19:48 <lf94> fffff
23:19:50 <Fuuzetsu> the solution was already posted, just transform that into something that looks nice to you
23:20:03 <lf94> Hm, maybe untilM'
23:20:06 <ReinH> Oh, didn't pigworker do his thesis about (something related to) this?
23:20:10 <lf94> untilM' :: (Monad m, MonadPlus f) => m a -> m Bool -> m (f a)
23:20:24 <Fuuzetsu> lf94: why do you think this is closer?
23:20:36 <ReinH> Fuuzetsu: Ah. Yep. http://www.reddit.com/r/haskell/comments/2q5bdb/monads_need_not_be_endofunctors_we_introduce_a/cn36502?context=2
23:20:43 <lf94> Nevermind X)
23:20:53 <lf94> It is no closer at all
23:20:54 <lf94> rip
23:21:10 <ReinH> lf94: does monad-loops not work for you?
23:21:21 <lf94> ReinH: trying to find the proper function to use
23:21:27 <lf94> iterateUntil :: Monad m => (a -> Bool) -> m a -> m a
23:21:32 <lf94> Looking better
23:22:36 <ReinH> johnw: now we just need indexex relative monads...
23:22:40 <ReinH> *indexed
23:22:48 <johnw> well, RMonad is also indexed, so...
23:22:51 <ReinH> heh
23:22:57 <ReinH> ok then, I think we're done here
23:23:20 <Fuuzetsu> ah I was doing something, you all distracted me
23:23:24 <Fuuzetsu> shame on you!
23:23:30 <ReinH> Fuuzetsu: :p you distracted you
23:23:41 <ReinH> we just gave you the opportunity to do so
23:23:42 <Fuuzetsu> unthinkable, I am a man of iron will and concentration
23:23:49 <johnw> Conor.v is the file that keeps sending me into loops
23:23:51 <lf94> I do that to people
23:23:52 <ReinH> He says, while continuing to not do that thing
23:23:54 <lf94> B)
23:24:05 <Fuuzetsu> ReinH: compiling!
23:24:06 <johnw> it's a direct implementations of Kleisli Arrows of Outrageous Fortune, but some of its concepts take a while to sink in
23:24:08 <ReinH> johnw: he does that to people...
23:24:10 <ReinH> Fuuzetsu: :D
23:24:23 <ReinH> johnw: he also has the best titles in the business
23:24:55 <ReinH> I really wish he'd come on the haskell cast
23:24:57 <lf94> Man monad-loops should be standard
23:24:57 <Fuuzetsu> I like that Agda's LaTeX backend has the colour options of ‚Äònormal‚Äô, ‚Äòblack and white‚Äô and ‚Äòconor‚Äô
23:25:04 <ReinH> hahahaha
23:25:44 <ReinH> lf94: it's quite useful
23:25:54 <lf94> Extremely useful
23:26:00 <ReinH> some of them definitely deserve to make their way back into Control.Monad
23:26:10 <ReinH> Also petition to merge the Control and Data namespaces...
23:26:25 <lf94> Why?
23:26:36 <Fuuzetsu> ReinH: but to which, Control or Data? Dun dun dun
23:26:37 <lf94> High cohesion?
23:26:50 <Fuuzetsu> I think we should just keep it as is, not worth the hassle
23:26:53 <ReinH> Data.Functor, Control.Monad, why?
23:27:02 <Fuuzetsu> hey, I routinely type Control.Functor
23:27:04 <lf94> Oh damn, ok that is weird.
23:27:06 <ReinH> Because data is control and control is data and it is arbitrary
23:27:24 <Fuuzetsu> just export ControlOrData.* versions
23:27:27 <ReinH> :D
23:27:35 <lf94> From the little category theory haskell wikibook taught me, I think functor definitely belongs in Control
23:27:36 <ReinH> ControlAndData pls :p
23:27:45 <ReinH> lf94: the point is that they are both data and control
23:27:47 <Fuuzetsu> what about Cata just to make it confusing
23:27:49 <ReinH> because the two are really one
23:27:55 <lf94> Conata
23:28:03 <pacak> codata
23:28:04 <ReinH> Also I want Codata and Ntrol
23:28:26 <Fuuzetsu> heh
23:28:52 <lf94> Could not find module `Distribution.Simple'
23:28:54 <lf94> rip
23:29:09 <ReinH> Fuuzetsu: I'm stlll trying to figure out what computor is dual to
23:29:33 <ReinH> Step 1: open dictionary to words that begin with "co"
23:29:37 <ReinH> Step 2: Make category theory joke
23:29:56 <johnw> well, coconut are clearly nuts
23:30:39 <Fuuzetsu> I see it's that time again, the time of bad CT jokes
23:30:55 <pacak> cofunctor!
23:31:11 <ReinH> pacak: functor!
23:31:22 <pacak> cofmap :: (b -> a) -> (f b -> f a) 
23:31:29 <ReinH> johnw: cocommutative coconuts?
23:31:47 <ReinH> pacak: alpha equivalence!
23:32:05 <ReinH> johnw: btw have you seen http://graphicallinearalgebra.net/ ?
23:33:06 <ReinH> linear algebra by string diagram chasing!
23:34:00 <ReinH> ...that uses the phrase "bizarro" sometimes instead of "dual"! I really like it.
23:34:15 <ReinH> "If an equation holds, then its bizarro version holds too." and etc
23:36:39 <Fuuzetsu> nice
23:38:26 <Fuuzetsu> I don't know whether opening with a paragraph on football is a good idea though
23:39:38 <ReinH> heh
23:39:55 <ReinH> Fuuzetsu: this sort of thing is why I love string diagrams http://graphicallinearalgebra.net/2015/05/16/natural-numbers-diagrammatically/
23:40:11 <ReinH> also monads from adjunctions are really easy to visualize, etc
23:40:41 <Fuuzetsu> I tend to quickly close papers which use string diagrams
23:40:58 <Fuuzetsu> I can't read them
23:41:08 <Fuuzetsu> maybe I should learn
23:41:17 <ReinH> hmm
23:41:25 <Fuuzetsu> Once I opened a paper full of them and couldn't stop thinking how long it must have taken to typeset it all
23:41:37 <ReinH> edwardk drawing some string diagrams for me at 3am was what first made adjunctions click
23:42:16 <ReinH> I assume there are tools for that
23:42:38 <Fuuzetsu> pfft
23:42:49 <Fuuzetsu> this is LaTeX we're talking about
23:42:53 <Fuuzetsu> sure there is probably a library
23:42:58 <Fuuzetsu> but was it easy? please
23:43:06 <Fuuzetsu> have you seen the tikz manual
23:43:09 <Fuuzetsu> it's like 800+ pages
23:43:41 <ReinH> :p
23:43:58 <Fuuzetsu> index starts at page 856
23:44:01 <Fuuzetsu> (last section)
23:44:04 <ReinH> I'd like to see the tex source for Eugenia Cheng's stuff
23:44:09 <ReinH> it's really well typeset
23:44:23 <ReinH> with pretty cell diagrams and etc
23:44:36 <johnw> why not ask her?
23:44:42 <ReinH> johnw: Hey that's not a bad idea!
23:44:46 <Fuuzetsu> ;P
23:44:47 <ReinH> I'll tweet her
23:44:50 <ReinH> thanks :)
23:44:54 <johnw> yeah, we forget that people are people sometimes :)
23:45:04 <ReinH> I did ask her to do more catsters videos and she responded favorably :)
23:45:05 <Fuuzetsu> my supervisor worked with her a bit
23:45:09 <ReinH> Fuuzetsu: nice
23:45:14 <Fuuzetsu> well, more than a bit
23:45:23 <Fuuzetsu> but his stuff is not super well typeset
23:45:32 <ReinH> heh
23:45:39 <ReinH> typesetting is hard let's go shopping
23:45:49 <ReinH> well, imagine what it was like before TeX...
23:46:01 <ReinH> Oh wait your publisher paid someone to do it
23:46:04 <ReinH> never mind
23:46:09 <Fuuzetsu> nope
23:46:13 <Fuuzetsu> you drew the lines yourself by hand
23:46:15 <johnw> we used groff
23:46:19 <ReinH> uphill in the snow both ways
23:46:35 <Fuuzetsu> apparently
23:47:03 <ReinH> Fuuzetsu: reading the TeXbook is an interesting journey back in time
23:48:00 <ReinH> btw how do browsers still get text layout so awful when it was solved decades ago o_O
23:49:03 <ReinH> I actually say a JS implementation of knuth's algorithm somewhere
23:49:06 <ReinH> *saw
23:49:32 <ReinH> Ah yep http://www.bramstein.com/projects/typeset/
23:51:44 <Fuuzetsu> someone implemented it in ELisp
23:51:49 <Fuuzetsu> but it was too slow to use on live text
23:53:04 <ReinH> heh
