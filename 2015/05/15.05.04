00:00:20 <ReinH> johnw: so this is taking negation of a as a -> b rather than a -> Void?
00:00:33 <johnw> forall r. a -> r
00:00:42 <ReinH> right
00:00:50 <johnw> which should be familiar... :)
00:00:53 <ReinH> yep
00:01:08 <ReinH> Just making sure I understand the relevance
00:01:25 <Zemyla> shachaf: Actually, a non-isomorphic (I think) adjunction is the adjunction between Free and Cofree.
00:01:41 <shachaf> Nope, it's isomorphic.
00:02:16 <ReinH> The thing about talking to shachaf is I have so many more questions afterwards than when I started...
00:02:29 <ReinH> (This is not necessarily a bad thing)
00:03:25 <ReinH> Oh, so Cont r is the monad that arrises from double negation. Huh.
00:03:47 <shachaf> Sort of.
00:03:55 <johnw> taking into account the swapping of ^op
00:04:02 <ReinH> Cont r is sort of the monad that arises from double negation.
00:04:29 <ReinH> johnw: Oh right.
00:05:22 <ReinH> Wow, this is a cool paper.
00:05:40 <lf94> >everyone recommending Aeson
00:05:46 <lf94> Text.JSON is confusing as hell.
00:05:58 <lf94> I'm trying to find a function that does String -> JSObject
00:06:01 <lf94> There is nothing
00:06:32 <ReinH> lf94: recommend switching to Aeson sooner rather than later...
00:06:44 <lf94> Yep. Doing that right now.
00:07:15 <ReinH> aeson isn't perfect, but at least the confusing bits start somewhere after "getting it to work at all"
00:07:38 <lf94> cabal: The following packages are likely to be broken by the reinstalls:
00:07:50 <lf94> Ehhhh.
00:07:53 <lf94> This is not good.
00:07:56 <jle`> waaait
00:07:56 <ReinH> lf94: yep, recommend using a sandbox
00:07:59 <jle`> you're using a sandbox right?
00:08:08 <lf94> You know the answer to that.
00:08:31 <lf94> Running cabal update
00:08:31 <ReinH> jle`: if lf94 were using a sandbox, they wouldn't have gotten that error :p
00:08:33 <lf94> Praying to God
00:09:12 <ReinH> lf94: well if this breaks something else then that thing will force reinstalls, which will break this thing, which will force reinstalls, which will break that thing....
00:09:24 <ReinH> good times
00:09:28 <lf94> Can't I update everything
00:09:43 <ReinH> lf94: well, you can if you make everything use the same constraints
00:09:48 <ReinH> but it's easier to just use sandboxes
00:10:13 <ReinH> fun story: the ~/.cabal/config and per-project cabal.config files have different parsers
00:10:50 <ReinH> e.g., the former accepts "constraint:" while the latter accepts "constraints:"
00:10:58 <ReinH> anyway you should use a sandbox
00:11:00 <lf94> I don't know what to do
00:11:03 <lf94> I feel so stranded
00:11:12 <absence> is there a more clever (and preferably "better" :)) way to avoid duplication here? http://lpaste.net/131547
00:11:17 <ReinH> lf94: upgrade cabal-instal and then use a sandbox
00:11:26 <lf94> ok...
00:11:38 <lf94> cabal install cabal-install ?
00:11:54 <ReinH> lf94: yes, and then make sure ~/.cabal/bin is in your $PATH
00:12:00 <lf94> I specifically need http-conduit and aeson
00:12:03 <ReinH> before wherever `cabal` was installed before
00:12:13 <ReinH> absence: which duplication are you concerned wtih?
00:12:36 <lf94> ReinH, yes ~/.cabal/bin is in my $PATH.
00:14:24 <absence> ReinH: lines 3 and 4 have a lot in common
00:15:07 <absence> ReinH: which i abstracted into line 8, just curious if there are other alternatives
00:15:48 <ReinH> I suspect you're trying to solve the duplication at the wrong level of abstraction
00:15:59 <ReinH> e.g., why are the arguments sometimes swapped
00:16:16 <ajyasgar> Is there any structure that represents repeated function application? It looks like iterate f x followed by (!!) does what I'm looking for, but I'm curious about alternatives
00:16:31 <ajyasgar> err repeat f x
00:16:44 <ReinH> ajyasgar: I think you were right the first time
00:17:12 <ajyasgar> Yeah looks like it, sleepy etc
00:17:12 <ReinH> applyRepeatedly f x n = iterate f x !! n
00:17:34 <ReinH> is probably one of the few uses of !! that I don't mind
00:17:45 <Cale> ajyasgar: Be careful with using that list in that way. If you pluck out the millionth element with !! and evaluate it before the others, and the function you're iterating is strict, then you may get a stack overflow
00:17:50 <ajyasgar> Right, that's the easiest way I can think of to do that, but wasn't sure if there were other (perhaps more) elegant ways
00:18:10 <Cale> You might want to write something like
00:18:13 <ReinH> Well, there are more efficient ways
00:18:16 <Cale> strictList [] = []
00:18:52 <ReinH> er, not "more efficient"
00:18:56 <ReinH> sorry
00:19:14 <Cale> strictList (x:xs) = x : (x `seq` strictList xs)
00:19:38 <Cale> and apply that to the result of iterate before indexing
00:19:53 <Cale> This just makes sure that as you walk the list, the elements get evaluated
00:20:12 <ReinH> rather than converting the list into a chain of thunks
00:20:28 <ReinH> so in that regard, yes, more efficient ;)
00:21:08 <Cale> There probably ought to be an iterateN in the standard library as well
00:21:16 <ReinH> well, technically, the list doesn't exist yet, so you aren't converting it per se. It's hard to talk about lazy evaluation :(
00:23:04 <knite> how can I pattern match a type of thing? for example, myFn MyThing foo = foo gives me the string foo (MyThing is constructed from a string) instead of the thing foo. ditto myFn (MyThing foo) = foo
00:24:15 <ReinH> knite: myFn MyThing foo and myFn (Mything foo) are two different things
00:24:24 <ReinH> what do you mean "pattern match a type of thing"?
00:24:26 <absence> ReinH: because it's two maps that make up a bidirectional one, so (key,value) in one is (value,key) in the other
00:24:46 <ReinH> absence: BiMap is a thing that already exists though
00:25:03 <ReinH> http://hackage.haskell.org/package/bimap-0.3.0/docs/Data-Bimap.html
00:25:33 <ajyasgar> thanks ReinH Cale, plenty of food for thought
00:25:48 <ajyasgar> i was surprised that iterateN wasn't a preexisting thing yeah
00:25:50 <knite> ReinH: here's a more concrete example: myFn (Puppy pup) = feed pup. Puppy is a kind of pet, myFn has type Pet -> Result, and I want myFn to pattern match and do different things depending on the sort of Pet received.
00:26:16 <ReinH> knite: ok, that should be easy if Pet is a sum byte
00:26:35 <ReinH> type
00:26:39 <ReinH> weird brain typo
00:27:19 <absence> ReinH: Data.Bimap silently deletes overlapping bindings, mine fails with Left instead
00:27:38 <lf94> ReinH, how do I make a sandbox
00:27:43 <lf94> and use it
00:27:44 <knite> so what am I doing wrong? what I actually have: data LogMessage = LogMessage ... | Unknown String. insert (Unknown foo) tree = tree.
00:27:48 <ReinH> lf94: cabal sandbox init
00:27:55 <ReinH> and then use cabal like normal
00:28:03 <lf94> oh ok
00:28:06 <ReinH> and when you're in that directory it will detect the sandbox and use it
00:28:07 <knite> ... omitted for clarity. basically trying to have insert do nothing to the tree if it receives an Unknown.
00:28:25 <lf94> ReinH, why isn't this default cabal behavior
00:28:35 <ReinH> knite: I don't know. What error are you getting?
00:28:49 <ReinH> lf94: hysterical raisins...
00:28:57 <lf94> lol
00:29:08 <lf94> What does this do, exactly?
00:29:14 <ReinH> sandboxing?
00:29:15 <lf94> Why can you only create one sandbox?
00:29:25 <lf94> I know what sandboxing does
00:29:31 <lf94> But I've never heard of just /one/ sandbox
00:29:41 <ReinH> one sandbox at a time
00:29:49 <ReinH> you can have multiple sandboxes in different directories
00:29:58 <ReinH> and you can have multiple directories use one sandbox
00:30:09 <ReinH> you can't have one directory use multiple sandboxes (afaik)
00:30:16 <lf94> Oh!
00:30:23 <lf94> It's per-directory sandbox.
00:30:25 <lf94> I see.
00:30:25 <ReinH> yes
00:30:36 <ReinH> it creates a sandbox in the directory you run cabal sandbox init
00:30:41 <lf94> Yeah perfect :)
00:30:45 <ReinH> or, if you specify it via args, in a different directory
00:30:50 <ReinH> basically it makes cabal behave more like npm
00:31:04 <ReinH> which, as you suggest, might have been a reasonable default
00:31:13 <ReinH> except it takes a lot longer to install some cabal packages
00:31:25 <ReinH> and there isn't a good shared compilation story yet
00:31:32 <ReinH> (although I would really really like one)
00:31:56 <ReinH> installing lens over and over again is no fun :(
00:32:24 <lf94> installing aeson right now is painful.
00:32:25 <ReinH> and also sandboxes are relatively new in the history of cabal
00:33:17 <Geraldus> Hey folks!
00:33:31 <Geraldus> Hey folks!
00:33:38 <lf94> hi
00:33:38 <ReinH> Geraldus: you said that
00:33:47 <lf94> inb4 bot
00:34:56 <Geraldus> I'm trying to figure out how to configure HLint per project. For hints I've created HLint.hs file in project root and added two imports there. But how can I say to HLint that is should use TemplateHaskell extension? 
00:35:45 <Geraldus> Because it gives me parse error on quasi quotes. Note I don't use HLint directly, it is used by FlyCheck in Emacs
00:36:13 <Geraldus> ReinH: sorry, have some issues with connection
00:36:39 <ReinH> Geraldus: can you add the pragma to HLint.hs?
00:36:53 <Geraldus> oh, obviously, let me check
00:37:04 <ReinH> Or is it a parse error when hlint checks other files that use quasiquotes?
00:38:37 <Geraldus> ReinH: HLint reports parse error for every file with quasi quotes
00:38:37 <ReinH> Hmm, I guess this is http://trac.haskell.org/haskell-src-exts/ticket/214?
00:38:48 <ReinH> Which is... 4 years old.. really?
00:39:16 <MP2E> ouch
00:39:19 <Geraldus> And it seems, that HLint does not pick my HLint.hs file :( let me check what will give manual HLint invocation 
00:40:04 <Geraldus> ReinH: yeah, this is the same, I've already saw that ticket
00:41:23 <ReinH> ouch :(
00:42:56 <Geraldus> Ok, it I manually invoke `hint -XTemplateHaskell -XQuasiQuotes` it works well. 
00:43:25 <Geraldus> So the question is how to make use of it with FlyCheck…
00:59:00 <gfixler> data Key = C♯
00:59:04 <gfixler> Haskell won't let me do that :(
00:59:27 <jle`> :(
00:59:38 <gfixler> even with UnicodeSyntax :(:(
01:01:26 <arw> i guess you would have to find something which isn't punctuation but looks like a #...
01:02:01 <arw> (but that would make things even more awkward to type)
01:02:56 <Haskellfant> gfixler: does magic hash make that work?
01:03:25 <Haskellfant> works for me ™
01:03:58 <gfixler> nope :(
01:04:03 <Moggle> Is anyone familiar with HDBC's sqlite3 driver? For some reason it's not handling UTF8 conversions properly
01:04:32 <Haskellfant> gfixler: that's strange, if I open ghci (7.10.1), run :set -XMagicHash and then data Key = C# it works just fine
01:04:34 <gfixler> Haskellfant: ah, I see now - I'm using the Unicode music symbol, not regular old #
01:04:41 <Haskellfant> oh sorry
01:04:44 <Haskellfant> didn't see that
01:04:50 <gfixler> I wanted to use flat as well
01:04:58 <gfixler> so is that what MagicHash is for?
01:05:06 <Haskellfant> magichash is for the regular hash :)
01:05:29 <gfixler> ftm: The language extension -XMagicHash allows "#" as a postfix modifier to identifiers. Thus, "x#" is a valid variable, and "T#" is a valid type constructor or data constructor.
01:05:31 <gfixler> huh
01:05:41 <gfixler> is this something from math?
01:05:46 <Geraldus> ok, as a workaround I've created shell script with needed parameters and set it as FlyCheck hlint executable
01:05:55 <pavonia> What is magic about that hash?
01:06:50 <gfixler> I feel it should have been called AllowHashPostifx
01:06:57 <gfixler> Postfix*
01:06:58 <Geraldus> pavonia: I suppose hash have special meaning in GHC, because of unboxed values
01:07:30 <gfixler> ftm: "The hash sign does not change sematics at all. We tend to use variable names ending in "#" for unboxed values or types (e.g. Int#), but there is no requirement to do so; they are just plain ordinary variables."
01:07:56 <merijn> pavonia: It's magic because hash is not legal haskell syntax in names
01:08:08 <merijn> It doesn't have an actual effect on values
01:08:10 <gfixler> I wish I had a lot more flexibility with  names in Haskell
01:08:38 <merijn> It's just a social convention to use # for unboxed values/types
01:20:59 <Haskellfant> well the new literals are a bit of magic
01:21:02 <Haskellfant> aka 'a'#
01:21:08 <phy1729> I'm doing :l file.hs and I get 
01:21:26 <phy1729> sory my terminal got borked
01:21:51 <phy1729> anyway it says the Main module loaded, but none of the functions are recognized
01:22:12 <frerich> gfixler: According to https://www.haskell.org/onlinereport/lexemes.html the name of data constructors should consist of Unicode letters (see the production for 'conid') but according to http://www.fileformat.info/info/unicode/char/266F/index.htm that character is a 'Symbol'. Maybe that's why?
01:22:35 <gfixler> frerich: probably
01:22:56 <gfixler> I typed in a random unicode character the other day in a let binding, and it wouldn't take it
01:23:09 <gfixler> and I realized eventually that it was because in whatever language it was, it was a capital letter :)
01:23:48 <gfixler> Ն <- this one
01:24:36 <gfixler> It's whatever this language is: http://hy.wikipedia.org/wiki/%D4%B3%D5%AC%D5%AD%D5%A1%D5%BE%D5%B8%D6%80_%D5%A7%D5%BB
01:25:19 <arw> ARMENIAN CAPITAL LETTER NOW
01:25:23 <arw> http://en.wiktionary.org/wiki/%D5%86
01:25:43 <merijn> gfixler: You can easily check this
01:25:45 <gfixler> That sounds like a protest sign
01:25:54 <merijn> > generalCategory 'Ն'
01:25:55 <lambdabot>  UppercaseLetter
01:26:05 <gfixler> merijn: oh, cool
01:26:25 <merijn> generalCategory is what the unicode classification is and the report follows those (mostly)
01:26:27 <gfixler> I'm surprised I don't recognize Armenian. I used to live in Burbank.
01:26:31 <merijn> There are some weird cases
01:26:48 <merijn> > generalCategory 'ಠ'
01:26:49 <lambdabot>  OtherLetter
01:27:11 <gfixler> > generalCategory fmap
01:27:12 <lambdabot>      Couldn't match expected type ‘Char’
01:27:12 <lambdabot>                  with actual type ‘(a0 -> b0) -> f0 a0 -> f0 b0’
01:27:12 <lambdabot>      Probable cause: ‘fmap’ is applied to too few arguments
01:27:18 <arw> > generalCategory '€'
01:27:19 <lambdabot>  <no location info>: can't find file: L.hs
01:27:19 <gfixler> ah, chars only
01:27:29 <gfixler> :t generalCategory
01:27:30 <merijn> gfixler: Technically the report only allows lowercase letters, to that shouldn't be a legal haskell identifier but GHC accepts it
01:27:32 <lambdabot> Char -> GeneralCategory
01:27:41 <jle`> > text . filter isUpper $ [minBound..maxBound]
01:27:42 <lambdabot>  ABCDEFGHIJKLMNOPQRSTUVWXYZÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝÞĀĂĄĆĈĊČĎĐĒĔĖĘĚĜĞĠĢĤĦ...
01:28:06 <jle`> > text . drop 100 . filter isUpper $ [minBound..maxBound]
01:28:08 <lambdabot>  ŚŜŞŠŢŤŦŨŪŬŮŰŲŴŶŸŹŻŽƁƂƄƆƇƉƊƋƎƏƐƑƓƔƖƗƘƜƝƟƠƢƤƦƧƩƬƮƯƱƲƳƵƷƸƼǄǅǇǈǊǋǍǏǑǓǕǗǙǛǞǠǢǤǦǨǪ...
01:28:15 <jle`> such letters
01:28:36 <gfixler> apparently I've been using the boring letters this whole time
01:29:03 <merijn> gfixler: Yes: https://hackage.haskell.org/package/acme-lookofdisapproval-0.1/docs/Acme-LookOfDisapproval.html
01:29:17 <gfixler> merijn: :)
01:30:42 <jle`> > text . drop 440 . filter isUpper $ [minBound..maxBound]
01:30:43 <lambdabot>  ԷԸԹԺԻԼԽԾԿՀՁՂՃՄՅՆՇՈՉՊՋՌՍՎՏՐՑՒՓՔՕՖႠႡႢႣႤႥႦႧႨႩႪႫႬႭႮႯႰႱႲႳႴႵႶႷႸႹႺႻႼႽႾႿჀჁჂჃჄჅჇჍḀḂḄḆ...
01:30:45 <jle`> langauges are interesting
01:37:03 <Dynetrekk> hi, I'm doing something that would be approx. like this in python https://gist.github.com/Dynetrekk/b4ce42634d4e9de9ef66
01:37:32 <Dynetrekk> is there a "standard" way of doing something like this in haskell? double loops? I was thinking some sort of nested list comprehension...
01:39:33 <pranz> Dynetrekk: do you want to collect the result of foo(i,j)?
01:39:50 <lieven> Dynetrekk: parallel list comprehensions. it's a GHC extension.
01:40:26 <sdx23> Dynetrekk: list comprehension. [f x y | x <- [1..N], y <- [i,(i-1)..0]]
01:40:44 <Geekingfrog> Dykam, how about [foo i j | i <- [0..N], j <- [0..i-1]]
01:40:51 <Geekingfrog> Dynetrekk, ^
01:43:22 <jle`> yeah those are just normal non-parallel list comprehensions...which looks like what you want
01:44:34 <jle`> you can also use Applicative depending on what you're comfortable with, `liftA2 foo [0..N] [0..i-1]`
01:44:52 <jle`> which is nice because you don't have to make dummy variables
01:44:58 <Dynetrekk> looks like list comprehensions then :)
01:45:06 <Dynetrekk> jle`: I'm not comfortable with anything
01:45:10 <Dynetrekk> I'm the new guy
01:45:19 <jle`> :)
01:46:13 <Geekingfrog> If I want to execute some IO actions inside the State monad, I have to use a monad transformer (and read wtf is that before) ?
01:46:38 <Geekingfrog> I was hoping not to have to read another book chapter to do this
01:47:00 <jle`> Geekingfrog: can you show what exactly it is you're trying to do?
01:47:05 <jle`> a lot of times you might not need to mix them
01:47:09 <bernalex> Dynetrekk: instead of using liftA2 (which is not too nice IMO), you can use applicative syntax: 'foo <$> [0..N] <*> [0..i-1]'. this is nice because it generalises nicely to nary args.
01:48:35 <Geekingfrog> jle`, the problem I'm working on is: I want to query an API. For that, I need to have a token. The token is valid for 10 queries, after that I need another one. I want to abstract that away inside the State monad so I can just make queries without worrying about tokens
01:49:06 <Geekingfrog> I started with a State Token (IO Resp) (with reps being a type from my http lib)
01:49:29 <Geekingfrog> but apparently I cannot unwrap the Resp from his IO context within the State monad
01:49:32 <jle`> yeah, if you want to actually use the Resp and inspect it, make decisions based on it, etc., then you might needed StateT
01:49:38 <jle`> how comfortable are you with State?
01:49:52 <Geekingfrog> no, this thing is to learn how to use it
01:50:08 <jle`> "no" to which statement?
01:50:17 <Geekingfrog> it's only an excuse to learn the state monad
01:50:47 <Geekingfrog> I'm comfortable with the list, maybe, either, but I have trouble understanding the State one. I was hoping to fix that with this toy project
01:51:15 <Geekingfrog> and doing IO/http request is also generaly useful
01:51:45 <jle`> if it's just for learning state, then maybe you could pick something where you don't have to look at io results while also learning state.  not that it's not a bad idea, but it might not be the best project for learning state in a vacuum.  but hey, who likes learning things in a vacuum, anyway? :)
01:52:02 <jle`> you know that a `State s a` is something that takes a state `s` and produces a result `a`, with a modified state, right?
01:52:33 <Geekingfrog> yeah, I already read a bunch of things about that. Played a bit around it (the classical Stack example and so on)
01:52:35 <jle`> you can "unlock" it with evalState :: State s a -> s -> a
01:52:42 <jle`> runState :: State s a -> s -> (a, s), etc.
01:52:59 <jle`> well, imagine that the process of *producing* your (a, s) can do arbitrary IO
01:53:17 <jle`> then we have something like runStateIO :: StateIO s a -> s -> IO (a, s)
01:53:45 <jle`> or evalStateIO :: StateIO s a -> s -> IO a
01:53:45 <Geekingfrog> you're saying that in case I don't need to know what's inside my IO Resp, I could just do it with a State Token (IO Resp)
01:53:58 <jle`> yes, if you don't need to know what's inside the Resp, you can do that
01:54:01 <jle`> well
01:54:06 <jle`> yeah
01:54:22 <Geekingfrog> can't find runStateIO on hoogle. Is this something I would need to write here?
01:54:25 <jle`> if you do, then if you want to use State and know the reuslt of IO actions, then you'll need StateT
01:54:35 <jle`> in real life there's no StateIO, it's called StateT IO
01:54:48 <Geekingfrog> ok, I'll go for the StateT then. Time to understand what's this thing is
01:54:51 <jle`> sorry, StateT s IO
01:55:08 <jle`> so you have evalStateT :: StateT s IO a -> s -> IO a
01:55:36 <Geekingfrog> seems like what I want
01:55:37 <jle`> the idea is that, where State s a encoded a function from a state to an a, a StateT s IO a encodes a function from a state to an a that can do IO in the process
01:55:50 <jle`> as for the *usage*, you'd use it exactly the same way you use State s a
01:55:57 <jle`> with exactly the same interface, etc.
01:56:05 <jle`> get, put, modify, etc.
01:56:13 <jle`> if you want to use IO now, you can use `liftIO`
01:56:32 <jle`> liftIO :: IO a -> StateT s IO a.
01:56:47 <jle`> if you were in an IO do block, you might do something like:  x <- getLine
01:56:54 <jle`> but in your StateT, you'd do x <- liftIO getLine
01:57:17 <jle`> this is the only real "difference" in the API...so this is how you'd use it.  which isn't too much more than using State if you understand State
01:57:43 <jle`> remember now that you can't use `runState`/`evalState` anymore, you'd use `runStateT` and `evalStateT`, and handle the new result type (IO (a, s) or IO a) appropriately.
01:58:23 <jle`> actually understanding how these work and are made is a fun journey to go down.  but for practical usage, you can just imagine it as something with exactly the same API as State, except you can 'embed' IO actions, and must run/unwrap at the end using the new method
01:58:25 <Geekingfrog> would `lift` be enough?
01:58:50 <jle`> lift is enough yes :)  but i find liftIO to be a little bit of helpful self-documentation
01:58:55 <Geekingfrog> since the StateT already has the IO information, lift should be interpreted as liftIO
01:59:05 <Geekingfrog> yeah, you're right
01:59:16 <jle`> but yeah, you're right, you can use lift too
02:00:05 <jle`> i think it is a good habit to get used to using liftIO though, because you might some day have a wide variety monads that can embed IO actions just like StateT s IO can.   but they might not be monad transformers
02:00:13 <jle`> so you can't use `lift`, but you can *always* use liftIO
02:00:46 <jle`> liftIO can work with *anything* that can embed and sequence and bind IO actions in this way...not just monad transformers
02:00:56 <jle`> or monad transformers transforming IO
02:02:54 <solatis> geez
02:03:04 <solatis> i was looking at the conduit docs for 5 minutes
02:03:07 <solatis> didn't understand a thing
02:03:18 <solatis> apparently google redirects to an ancient version of the haddock docs
02:03:39 <jle`> have you tried looking at the tutorials?
02:04:10 <solatis> i try to exclusively use hackage documentation and github sources, i find that the tutorials about haskell on blogs are usually outdated
02:04:46 <solatis> haskell is a language where libraries dont shy away from breaking backwards compatibility, which has this as a consequence
02:04:47 <jle`> for me it's been the opposite, heh.  hackage documentation is typically opaque and i find tutorials from authors or users if the version is the right version
02:05:00 <jle`> as long as you make sure it's for the right version it should be ok
02:05:09 <solatis> github code search does that for me
02:05:24 <jle`> https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/conduit-overview
02:05:27 <solatis> as in, it answers the question "but how do i actually DO stuff with this library" for me :)
02:05:58 <jle`> yeah, but that's like jumping into learning haskell by reading how libraries are written
02:05:59 <solatis> yeah i think conduit is the exception of the rule, tho
02:06:09 <jle`> instead of using a course or lesson plan
02:06:12 <jle`> without knowing what types are...
02:06:14 <jle`> what functions are...
02:06:30 <solatis> yeah, that's me :p
02:06:55 <jle`> just a simple overview of the library and its types, why they're there, etc.
02:06:57 <MP2E> good rule of thumb, when following a link to hackage docs from google, delete the version number from the package name in the url and hit enter, and it will bring you to the newest version
02:07:07 <MP2E> i do this all the time just to be sure :P
02:07:26 <solatis> MP2E, yeah i know, but this time i forgot. so i was looking at version 0.2 of conduits, which is over 4 years old :)
02:07:39 <jle`> solatis: do you mean to say that you learned how to use haskell without ever following a course and just reading haskell source? :o
02:07:51 <solatis> jle`, i never followed a course
02:07:54 <solatis> not LYAH
02:07:56 <solatis> not RWH
02:08:03 <solatis> i just dove into the deep
02:08:16 <solatis> i started with Main.hs and a project
02:08:49 <jle`> did you ever read about like...what a function was
02:08:51 <jle`> or what types are?
02:08:56 <solatis> but i am perhaps an extreme case of "learning by example"
02:08:56 <jle`> how to do IO?
02:09:11 <jle`> or did you just look at how other people did IO without ever readinga bout it?
02:09:14 <jle`> this is interesting :)
02:09:34 <solatis> heck, i don't even know how to open up ghci :)
02:09:54 <jle`> :X
02:09:59 <jle`> do you ever think you might be missing something?
02:10:05 <solatis> yes, of course
02:10:13 <solatis> but that's why i follow /r/haskell
02:10:19 <solatis> if something catches my interest, i read about it
02:10:23 <jle`> but i guess that's just your style :3
02:10:46 <jle`> on an unrelated note i think it might be worth looking into ghci and how to develop actively with it
02:11:00 <solatis> well the thing is, i try to understand it along the road
02:11:17 <jle`> yeah, i get it. it's your style :)
02:11:34 <solatis> like, i don't learn to drive a car by understanding how changing gears works internally
02:11:37 <jle`> but the point was that if sometimes this method fails, another method might work too
02:11:46 <solatis> yep
02:11:50 <solatis> you know zed shaw?
02:11:59 <jle`> cannot recall
02:12:08 <solatis> "learn python the hard way" ?
02:12:35 <solatis> anyway, he's kind of an (in)famous blogger
02:12:56 <solatis> it's a kind of example of a different teaching method
02:13:11 <solatis> in python you can probably get away with it better than with haskell though
02:13:37 <solatis> but, just as an example, the way i finally "grasped" monads was not by reading about them
02:13:47 <solatis> i saw a javascript implementation of monads
02:13:54 <solatis> and *click* i understood monads
02:14:06 <solatis> "ohhh is THAT all it is..."
02:15:11 <jle`> yeah, i guess there's a good balance of everything :)
02:15:16 <jle`> to be found
02:15:26 <solatis> yep
02:15:36 <solatis> i found some interestign similarities in other areas
02:15:46 <solatis> for example, we needed to use hbase at work
02:15:53 <jle`> learn python the hard way seems to be a course that presents things in a logical order though...
02:15:55 <solatis> me: install & fire up terminal & enter help
02:15:58 <frerich> solatis: The 'bang your head against it until you "get it"' approach works well for me, too - but at the same time, I found that some sort of theoretical introduction is still beneficial later. I read some Haskell introductions after I 'got' some stuff only to realize that there's a whole bunch of interesting implications I missed.
02:16:04 <solatis> collegue: go to hbase.apache.org and read all docs
02:16:13 <frerich> solatis: I.e. I think this isn't an "either-or" thing.
02:16:30 <solatis> frerich, exactly
02:16:45 <solatis> in school i was always a person who understood things too late, *after* the exam :p
02:17:06 <frerich> solatis: Well I guess that's ok if you actually understood it as opposed to just learning things by heart. :-}
02:17:08 <solatis> because then we needed to actually use the material we studied before, which made me "ahhhh!"
02:19:05 <jle`> night all :)
02:19:38 <solatis> nn
02:23:36 <Geekingfrog> nn, thanks for the help
02:25:17 * hackagebot feed 0.3.9.3 - Interfacing with RSS (v 0.9x, 2.x, 1.0) + Atom feeds.  http://hackage.haskell.org/package/feed-0.3.9.3 (AdamBergmark)
02:25:19 * hackagebot edit-distance 0.2.1.3 - Levenshtein and restricted Damerau-Levenshtein edit distances  http://hackage.haskell.org/package/edit-distance-0.2.1.3 (AdamBergmark)
02:48:12 <gfixler> data Fix f = Fix (f (Fix f))
02:48:18 <gfixler> why is the f grouped away from the first Fix?
02:49:11 <pacak> gfixler: Otherwise it will think that Fix has two fields?
02:49:21 <gfixler> pacak: yeah, I'm just realizing that, but now I'm wondering a new thing
02:49:28 <bernalex> yeah I don't really understand the question. "because associativity". heh.
02:49:30 <gfixler> this means all f must have one param
02:49:58 <Cale> Yeah, Fix :: (* -> *) -> *
02:50:00 <gfixler> but then, I guess everything in Haskell takes one argument
02:50:09 <Cale> Not everything
02:50:15 <bernalex> not values.
02:50:24 <gfixler> all functions
02:50:24 <bernalex> that would be very weird. :)
02:50:25 <Cale> Fix requires a type constructor as its argument
02:50:42 <jazzer> pl
02:50:45 <Cale> This has nothing to do with currying of functions or anything.
02:50:45 <merijn> gfixler: Int has "*" so it doesn't take an argument
02:51:05 <bernalex> merijn: they amended to "all functions".
02:51:27 <Cale> f (Fix f) must have kind *
02:51:42 <solatis> can anybody enlighten me about stm-conduit's behaviour
02:51:42 <Cale> because it's a field of a data constructor
02:51:43 <solatis> http://hackage.haskell.org/package/stm-conduit-2.6.0/docs/Data-Conduit-TMChan.html
02:51:53 <gfixler> Cale: yeah, I think I see it now
02:51:56 <jazzer> pl \x -> f $ g x
02:51:57 <solatis> the documentation says: "When the channel is closed, the source will close also"
02:52:02 <solatis> which makes sense
02:52:04 <solatis> however
02:52:07 <solatis> is the opposite also true?
02:52:17 <gfixler> Cale: no one ever describes things in the One More Thing style that I require
02:52:19 <jazzer> How to use pl?
02:52:20 <solatis> will the channel close when there are no more consumers?
02:52:55 <bernalex> jazzer: @pl [expr]. if you are going to use it a lot, use it in a private query to lambdabot. you can also just install the pointfree tool yourself on your own computer.
02:53:25 <jazzer> @pl \x -> f $ g x
02:53:25 <lambdabot> f . g
02:53:47 <adas> I'm in a sandbox. Only dependency in my cabal file is 'base'. I want to install offline documentation for reference. Could someone please tell me how do I go about it?
02:53:51 <jazzer> @bernalex thanks! 
02:53:52 <lambdabot> Unknown command, try @list
02:53:57 <bernalex> hehe
03:00:10 <indiagreen> adas: well, when you do “cabal haddock” you get documentation generated in dist/doc. Or do you want it to be added to the global package docs index?
03:00:37 <adas> indiagreen: i want it to be added to the sandbox
03:01:11 <adas> indiagreen: i think cabal haddock only build documentation for the current sandbox. not the libraries installed in the current sandbox
03:01:49 <indiagreen> yes, but you said that the only dependency is base, and you have docs for base already
03:03:44 <adas> indiagreen: nope. i do not have docs for base. and I only wnaat to build docs for dependencies
03:03:48 <Ferdirand> @pl \x y z -> f (a x) (b y) (c z)
03:03:48 <lambdabot> flip flip c . ((.) .) . (. b) . f . a
03:03:57 <indiagreen> okay, then I don't know
03:03:58 <indiagreen> sorry
03:34:50 <onemanstartup> Hello. I have a question. Why 'class' is a keyword for type classes? Why it is not 'typeclass' for example? Maybe it worth to provide synonym?
03:36:41 <bernalex> onemanstartup: typeclass is too long. anyway I don't think it's a problem. it would be much more important to s/type/alias/ and s/data/type/ IMO.
03:37:23 <onemanstartup> It's small, but it is somewhat problem for newcomers. 
03:38:13 <bernalex> onemanstartup: I have never seen a newcomer have a real problem with it, beyond asking "is it like a class in Java?" and being answered "no, more like an interface".
03:38:41 <Haskellfant> and if it was called typeclass that question would probably still come up
03:38:43 <bernalex> I'd say return is a bigger problem since it tends to come at the end of functions.
03:39:36 <Guest46869> Is it a convention to put common types in Types.hs 
03:39:37 <bernalex> typeclasses otoh are so different to classes, that I'd suspect the confusion to rarely extend beyond an initial one upon spotting the keyword.
03:39:47 <bernalex> Guest46869: no.
03:39:58 <onemanstartup> Yes, return too. It's cognitive overhead to switch between languages when two equal words means different things
03:40:29 <Guest46869> bernalex: I see many libraries in haskell follow that!
03:40:45 <bernalex> onemanstartup: there's no overload to me. I think the overload would be when learning a new language that uses the same terminology. but in any event, the confusion is initial and mostly minor.
03:40:46 <Guest46869> bernalex: am I understanding it wrong?
03:41:03 <bernalex> Guest46869: which ones? I don't recall seeing it.
03:41:53 <nshepperd> Guest46869: putting all the types of the library in Types.hs is sometimes necessary / convenient to avoid dependency loops
03:41:58 <bernalex> Guest46869: there might libraries that do it, but given that I have not noticed it, and am doing quite a lot of haskell stuff, I would through induction deem it to not be a convention.
03:42:16 <onemanstartup> You talk in position, when you already know haskell. Why you don't want language easier for newcomers? :)
03:42:20 <Guest46869> bernalex: for instance I recall COntrol.Lens has Type.hs
03:43:15 <bernalex> onemanstartup: I did not always know Haskell. I did not say I don't want the language to be easier for newcomers -- you are lying, please stop that. I do however think that there are more pressing matters than the class keyword to make haskell a better language for newcomers and advanced users alike.
03:43:36 <MP2E> how exactly does changing class to typeclass make it easier for anyone?
03:43:40 <MP2E> it's mere pedantry
03:44:04 <Guest46869> nshepperd: okay that makes sense to me
03:44:11 <bernalex> MP2E: as far as I can judge, it only makes you spend a few more keystrokes to declare a typeclass.
03:44:16 <Haskellfant> onemanstartup: changing class to typeclass would require changes to just about every piece of haskell code out there. and not removing class would mean that there are two things that mean the same thing which is even more confusing
03:44:39 <onemanstartup> Haskellfant: it can be a synonym
03:44:57 <Haskellfant> great then you have too remember both ways and beginners are even more confused
03:45:03 <haasn> onemanstartup: That's unnecessary redundancy, which is even more confusing
03:45:06 <bernalex> onemanstartup: polluting the namespace is not something one should do lightly.
03:45:16 <haasn> onemanstartup: If you want to fix this, you need to make a new language that doesn't have Haskell's historical baggage
03:45:19 <haasn> There's no other sensible way
03:45:47 <onemanstartup> I see. Thank you for answers.
03:46:08 <onemanstartup> I'm only one week in haskell :)
03:46:28 <haasn> onemanstartup: You get used to it fairly quickly, though
03:46:53 <bernalex> I don't think OOP languages have monopoly on the word "class" anyway. C++ and SML have functors and J has monads, and these things are drastically different than functors & monads in haskell. terminology is overloaded in all scientific fields. it's inconvenient but mostly bearable.
03:47:16 <onemanstartup> haasn: yesterday I was more like http://i.imgur.com/qzzwwpv.jpg
03:48:07 <bernalex> onemanstartup: you can imagine our faces when using languages that permit side-effects.
04:01:04 <k0ral> hello
04:01:25 <haasn> onemanstartup: “Get out free monads”? :)
04:02:24 <k0ral> is there a way to enforce a text to be non-empty through the type-system ? like Data.List.NonEmpty, but for Data.Text
04:06:27 <ChristianS> k0ral: only if you define your own type, NonEmptyText, and thoroughly control how instances of that type are constructed.
04:08:10 <k0ral> ChristianS: would it make sense to wrap the existing Text, like the case-insensitive package does ?
04:08:38 <haasn> k0ral: Sure. Text is a good representation of text
04:12:07 <Falkyouall> Hello haskellers out there
04:12:23 <Falkyouall> anyone who can help me with haskell :-S
04:12:45 <Ferdirand> don't ask to ask, just ask
04:13:18 <Falkyouall> homework - towers of hanoi:
04:13:35 <Falkyouall> this is my move funktion
04:13:36 <Falkyouall> move :: ([Move], Towers) -> ([Move], Towers)
04:14:34 <Falkyouall> the funktion takes a set of tupels, which are the right moves for a specific setup
04:15:56 <Falkyouall> and another tupel with the specific setup of in this case 3 towers
04:16:06 <Falkyouall> for example: move ([(1,3),(1,2),(3,2),(1,3),(2,1),(2,3),(1,3)] ([1,2,3],[],[]))
04:16:54 <Falkyouall> what do i have to do that i get following putput
04:17:01 <Falkyouall> ([(1,2),(3,2),(1,3),(2,1),(2,3),(1,3)],([2,3],[],[1])
04:17:35 <Falkyouall> sorry here are the types for the move and towers
04:17:50 <Falkyouall> type Move = (Position, Position)
04:17:50 <Falkyouall> type Towers = ([Int],[Int],[Int])
04:18:33 <Falkyouall> how can i match always the  first group of moves and set them like they should?
04:21:43 <Ferdirand> what should the move function do, if the list of moves is empty ?
04:22:39 <Falkyouall> give out an error.. error "set up a game first "
04:22:55 <Ferdirand> also, your syntax is wrong: f (a b) means f(a(b)), you should do (f a b) to call a function with two arguments
04:23:08 <Falkyouall> or... after the last move is done.. congrats
04:32:33 <Falkyouall> you mean the type syntax or the call syntax?
04:33:20 <Falkyouall> thats a part i didnt really get yet, the parantheses is allway implicit left, right?
04:34:31 <Falkyouall> i saw a way which i guess is getting the right way, but still get me errors: move ([(v,n):r],([x:xs],[y:ys],[z:zs]))
04:45:53 <Falkyouall> just came up with that 
04:45:57 <Falkyouall> move :: ([Move], Towers) -> ([Move], Towers)
04:45:57 <Falkyouall> move (((a,b):r),((x:xs),(y:ys),(z:zs)))
04:46:32 <Falkyouall> haskell typ checker says that my pattern matches are non exhaustive
04:49:24 <opqdonut> Falkyouall: you're not considering the case that [Move] is empty
04:49:48 <opqdonut> Falkyouall: also probably applies to the three lists inside Towers
04:50:13 <Falkyouall> ok true, i should cover that up
04:51:44 <Falkyouall> but before that i'd like to match the pattern, so i can get to that part you just said
04:54:22 <Falkyouall> just tapping in the darkness, but i think im getting closer with that one..
04:54:25 <Falkyouall> move :: ([Move], Towers) -> ([Move], Towers)
04:54:25 <Falkyouall> move (((a,b):r),((x:xs),(y:ys),(z:zs))) = ([(a,b)],([x],[y],[z]))
04:55:35 <merijn> Falkyouall: FYI, if you don't plant to use some variables in the pattern match it's recommended to use _ as a pattern
04:56:04 <merijn> To signal that you're not using them on purpose (with -Wall GHC will give a warning if you don't explicitly ignore unused matches)
04:57:25 <Falkyouall> okay, next level stuff.. i know what it is but not how to use it well in this case - i'll consider it now thanks!
05:01:52 <dreams> Seems like GHC tricked programmers by spreading "conventions" only to take advantage of said conventions to cover-up the lack of otherwise tricky features. Nicely played!!
05:02:09 <notdan> Is there an easy way to run hoogle for a specific cabal seandbox?
05:02:25 <notdan> I.e. I want to search just the modules/libraries that are installed in the sandbox
05:03:58 <merijn> dreams: Eh, how so?
05:05:05 <merijn> It's actually more general in that GHC doesn't warn for any variable name starting with an underscore
05:05:41 <merijn> dreams: _ as wildcard pattern in pattern matches is specified in the Haskell Report, so it's not a convention
05:06:03 <merijn> Directly from the report: "Underscore, “_”, is treated as a lowercase letter, and can occur wherever a lowercase letter can. However, “_” all by itself is a reserved identifier, used as wild card in patterns. Compilers that offer warnings for unused identifiers are encouraged to suppress such warnings for identifiers beginning with underscore. This allows programmers to use “_foo” for a paramet
05:06:07 <ronh> IIRC you can't actually use _ variable
05:06:09 <merijn> er that they expect to be unused."
05:06:17 <ronh> > let _ = 1 in _
05:06:18 <lambdabot>      Found hole ‘_’ with type: t
05:06:18 <lambdabot>      Where: ‘t’ is a rigid type variable bound by
05:06:18 <lambdabot>                 the inferred type of it :: t at Top level
05:06:39 <merijn> ronh: Right, but you can use _foo
05:07:31 <frerich> dreams: I think that 'convention' is actually part of the Haskell syntax; https://www.haskell.org/onlinereport/lexemes.html says '[..] Compilers that offer warnings for unused identifiers are encouraged to suppress such warnings for identifiers beginning with underscore. This allows programmers to use "_foo" for a parameter that they expect to be unused.'
05:08:31 <dreams> merijn: frerich. Yes, I meant the language too not only its implementation.
05:10:28 <frerich> merijn: Err oops, I only now saw that you quoted the same thing.
05:12:47 <dreams> PLEASE use _ so we can optimize.
05:13:04 <merijn> dreams: I'm not entirely sure which "tricky features" you're refering too in terms of covered-up?
05:13:16 <merijn> dreams: _ has no impact on code-generation/optimisation
05:13:28 <merijn> dreams: If you use a variable name GHC can optimise that just as easily
05:13:58 <merijn> The problem that _ solves is that normally variable names have to be unique within a pattern
05:14:08 <merijn> i.e. "foo x x = ()" <- error
05:14:26 <merijn> But "foo _ _ = ()" is ok, because _ is special and thus the double pattern is accepted
05:14:41 <merijn> > let foo x x = () in foo 'c' True
05:14:42 <lambdabot>      Conflicting definitions for ‘x’
05:14:42 <lambdabot>      Bound at: <interactive>:1:9
05:14:42 <lambdabot>                <interactive>:1:11
05:14:48 <merijn> > let foo _ _ = () in foo 'c' True
05:14:50 <lambdabot>  ()
05:15:05 <solinent> I have a bit of a beginner question: if I have a bunch of vertices, and triangles with repeated vertices, is there a nice way of avoiding storing repeated copies of vertices within the triangle? I could use a vector and int references, but then I'd need to have the vector of all vertices passed into my functions. Maybe I should use slices? These vertices will never be written to, and there will be many many
05:15:07 <solinent> triangles.
05:15:22 <dreams> well I meant optimize or [insert-feature]. and I'm not only speaking of _.
05:15:46 <dreams> I mean there is nothing wrong with it unless its ad-hoc.
05:17:37 <dreams> merijn: so you think that GHC will not take advantage of the fact that _ is unused and not, say trim that argument from the stack? (unless you are allowed to: f _ = _ )
05:18:12 <merijn> dreams: But GHC can do the same thing if you *didn't* use _
05:18:21 <merijn> dreams: Because it's trivial to detect whether a variable is unused
05:18:55 <merijn> dreams: "f x = ()" <- GHC can already see you don't use 'x', besides haskell is lazy so 'x' wouldn't be evaluated *anyway*
05:19:21 <dreams> merijn: s/can/does/. But maybe _ has better optimization opportunities.
05:19:45 <dreams> merijn: No. It would matter, because it could cause a space leak.
05:20:36 <merijn> How?
05:20:41 <dreams> merijn: it x is evaluated, representing a large graph, then unused at a later point then stubbing it from the stack is wise.
05:20:45 <dreams> if*
05:21:10 <isomorph_> hrmm- a bit of a long-shot question without delving into the code, but... I have a heap profile which shows similar memory utilization between a 1 and 16 thread case.  What's weird though is that the 16 thread case runs dramatically slower, spending a lot of its time in what might be allocation of small blocks of memory.  Is that a known thing? 
05:21:29 <dreams> by unused at a later point is similar to unevaluated at a later point from a static-analysis point of view.
05:21:45 <merijn> isomorph_: Slow allocation is unlikely, even impossible, unless it's doing allocation of mutable arrays
05:21:55 <merijn> isomorph_: Now garbage collection might be slow
05:22:02 <merijn> isomorph_: Which GHC version?
05:22:06 <isomorph_> 7.8.3 
05:22:31 <merijn> isomorph_: And a really obvious question: You are actually using the threaded runtime AND specifying the use of multiple threads? :)
05:22:41 <isomorph_> merijn: Yup.  Both those. 
05:22:57 <isomorph_> Timing profiles show a hotspot on a line doing attoparsec take
05:23:08 <isomorph_> (as in, parse something, create a bytestring) 
05:23:36 <merijn> isomorph_: Then this is beyond my expertise :)
05:24:06 <isomorph_> merijn:  Okay, that's terrifying.
05:24:29 <isomorph_> I might try to build something I can put in a hpaste
05:24:59 <isomorph_> odd though - GC time spikes to leave only 15% mutable
05:25:18 <isomorph_> and all the time is spent in some obscure attoparsec function
05:26:01 <isomorph_> merijn: Thanks by the way! 
05:32:16 <maerwald> is postmaster discontinued?
05:46:21 <ronh> how mature is threepenny library? anyone has experience with it?
05:49:15 <merijn> ronh: That's by Apfelmus, right? I'd assume anything that's not like 0.1 versioned should be mature enough to use
05:49:42 <merijn> (Incidentally, am I the only one who thinks his name is some silly joke everytime I read it? >.>)
05:52:48 <ronh> merijn yes it's by Apfelmus
05:53:12 <merijn> s/anything/anything by him/
06:03:49 <Falkyouall> hey
06:04:27 <Falkyouall> how can i access a worth in a tripel i.E ([1,2],[3,4],[5,6])
06:04:36 <ggVGc> if I have a foo:Int->Int->Int, and an array like [(1,2), (3,4)], how would I map over foo applying the tuples? 
06:04:51 <notdan> Falkyouall: access a what?
06:05:10 <Falkyouall> a tripel... (1,2,3)
06:05:18 <Falkyouall> tupel (1,2)
06:05:32 <Falkyouall> triple sry
06:06:05 <augur> Falkyouall: i think also you mean a value in a triple?
06:06:26 <ion> ggVGc: map (uncurry foo)
06:06:31 <Falkyouall> yes
06:06:44 <ggVGc> ion: is that the most idiomatic way?
06:06:44 <augur> you can `let` on the triple. so if t :: (a,b,c) is your triple, you can do   let (x,y,z) = t in ...
06:06:48 <ozgura> Falkyouall: let me make a wild guess and suggest you to have a look at "unzip3"
06:06:52 <notdan> case x of (x,y,z) -> ...
06:06:56 <ozgura> :t unzip3
06:06:57 <augur> and this exposes x :: A, y :: B, z :: C
06:06:58 <lambdabot> [(a, b, c)] -> ([a], [b], [c])
06:06:58 <ion> ggVGc: That's a list, not an array, btw.
06:07:08 <augur> or you can us case, like notdan shows, to get the same thing
06:07:09 <ggVGc> yeah, sorry, I meant a list
06:07:37 <augur> so for instance Falkyouall   let (x,y,z) = (1,2,3) in x  ==  1   ==  case (1,2,3) of (x,y,z) -> x
06:07:50 <ion> ggVGc: Dunno about the most idiomatic but that's what I'd do.
06:08:24 <Falkyouall> okayyyy thanks 
06:10:47 <zq> ggVGc cleared out my vim buffer ):
06:15:02 <benzrf> zq: more like ggcG
06:15:11 <benzrf> zq: no need for visual there
06:15:16 <benzrf> oh i see its a nick
06:30:31 * hackagebot ghc-events 0.4.4.0 - Library and tool for parsing .eventlog files from GHC  http://hackage.haskell.org/package/ghc-events-0.4.4.0 (MikolajKonarski)
06:30:33 * hackagebot threadscope 0.2.7 - A graphical tool for profiling parallel Haskell programs.  http://hackage.haskell.org/package/threadscope-0.2.7 (MikolajKonarski)
06:49:43 <jeltsch> > fix error
06:49:44 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
06:49:58 <jeltsch> Just a liveness test.
06:50:38 <merijn> For that you can just use
06:50:40 <merijn> @botsnack
06:50:40 <lambdabot> :)
06:54:51 <jeltsch> merijn: Okay.
06:54:57 <jeltsch> Does this mean that I feed the bot?
06:55:15 <jeltsch> (Don’t feed the trolls, but the bot. ;-) )
07:00:10 <nshepperd> > error "evaluated" :: IO ()
07:00:11 <lambdabot>  <IO ()>
07:00:11 <ion> @botsmack
07:00:12 <lambdabot> :)
07:16:46 <albeit> How can I do this? "a -> (a -> b) -> (a -> c) -> (b, c)"?
07:17:08 <merijn> @djinn a -> (a -> b) -> (a -> c) -> (b, c)
07:17:08 <lambdabot> f a b c = (b a, c a)
07:18:01 <albeit> Hmm... I'm mapping over [a] though, so I'd prefer not have to make a lambda to call two functions on an a
07:19:38 <albeit> :t liftA2 (,)
07:19:39 <lambdabot> Applicative f => f a -> f b -> f (a, b)
07:20:17 <albeit> @pl \a -> (f a, g a)
07:20:17 <lambdabot> liftM2 (,) f g
07:20:55 <albeit> :t liftM2 (,)
07:20:56 <lambdabot> Monad m => m a -> m b -> m (a, b)
07:21:09 <albeit> What is the monad/applicative for a and b in those types?
07:21:50 <Luke> if i'm reading from an IORef on one thread and writing on another, does one thread get blocked until the other finishes?
07:22:16 <Luke> what are the blocking/locking semantics of IORef? 
07:23:50 <merijn> albeit: (r ->)
07:24:09 <merijn> Luke: Reads/writes are atomic, there are no other guarantees
07:24:15 <albeit> merijn: Ah, of course, thanks!
07:25:06 <Luke> merijn: yeah I was reading about the memory model and it said loads can move ahead of stores on x86 implying that it doesn't block unless I use one of the memory barriers so that's actually great for me
07:25:19 <Luke> implying the optimizer will allow them to not block each other
07:26:23 <merijn> I believe you basically get "sequential consistency + atomic reads/writes"
07:26:34 <merijn> Although I'm not 100% about sequential consistency
07:28:07 <Luke> sequential consistency is not guaranteed across threads though
07:28:13 <Luke> its architecture specific
07:28:31 <Luke> merijn: https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-IORef.html#g:2
07:28:34 <Luke> at least that's my reading of this
07:31:27 <Luke> merijn: in fact the way they set up the refs in that memory model example shows no deadlock occurring because of locking
07:31:46 <c_wraith> Luke: atomicModifyIORef adds additional guarantees, with the possible chance of livelock
07:32:01 <Luke> c_wraith: yeah it adds memory barriers
07:32:52 <Luke> i was specifically asking about locking but I see now the example shows blocking does not occur
07:32:56 <k0ral> hello
07:33:19 <c_wraith> Yeah, the only thing resembling blocking is the retry if the atomic compare-and-exchange in atomicModifyIORef fails
07:33:52 <k0ral> while quickcheck-ing my library, there was a negative result due to (I think) a date that wasn't parsed correctly
07:34:05 <Luke> c_wraith: ok thanks
07:34:07 <k0ral> when show-ing that date, it prints "1864-05-09 00:31:25.448009748487 UTC"
07:34:19 <k0ral> (I'm using quickcheck-instances which define Arbitrary UTCTime)
07:34:46 <Luke> c_wraith: I think I was remembering the empty semantics of MVars and confused myself
07:35:00 <c_wraith> Luke: ah, yes.  MVar is entirely different.  locks everywhere! :)
07:35:04 <k0ral> now, how did that ".448009748487" part happen ? I tried generating a UTCTime object by hand and I couldn't reproduce that subsecond part
07:35:09 <Luke> c_wraith: right =)
07:35:22 <Luke> haskell concurrency is so awesome
07:35:40 <Luke> the level of control and clarity
07:38:07 <c_wraith> k0ral: something like..  (UTCTime (ModifiedJulianDay 100) (0.23874629)) should give you a UTCTime like that, if I'm reading the docs right
07:38:50 <c_wraith> .. please ignore my redundant parens. :)
07:39:45 <k0ral> c_wraith: indeed... why don't I get the same subsecond part when using (picosecondsToDiffTime 1000000000001) ?
07:40:21 <k0ral> .. please ignore my last comment
07:40:27 <k0ral> question
07:40:50 <c_wraith> good, 'cause I didn't know the answer
07:41:47 <fr33domlover> I'm trying to cabal update: "/home/x/.cabal/packages/hackage.haskell.org/00-index.tar3473.tmp: resource exhausted"
07:42:08 <fr33domlover> (using cabal-install 1.20 from hvr's ppa)
07:42:47 <pranz> :t newArray
07:42:49 <lambdabot> Not in scope: ‘newArray’
07:42:58 <pranz> oh well
07:43:08 <barrucadu> fr33domlover: Do you have enough disk space?
07:43:24 <fr33domlover> barrucadu, 170M left actually
07:43:28 <fr33domlover> maybe that's the issue?
07:43:38 <pranz> why is the type of newArray, Ix i => (i, i) -> e -> m (a i e), and not Ix i => i -> e -> m (a i e)?
07:43:48 <pranz> what does the second i do?
07:43:53 <c_wraith> pranz: upper and lower bounds
07:43:55 <pranz> oh
07:44:03 <c_wraith> pranz: especially useful when the index type is non-numeric. :)
07:44:04 <ClaudiusMaximus> thinking of doing some runtime code generation, using benchmarks of primitive operations to guide optimisation - any tips?  looking at criterion for the benchmarks, not sure if it's approprate though.  the primops would be libmpfr stuff (possibly using 'rounded')
07:44:13 <barrucadu> fr33domlover: I wouldn't have thought the package database would be that big, but could be worth a try
07:44:23 <pranz> ClaudiusMaximus: ty
07:44:30 <pranz> whoos
07:44:33 <pranz> c_wraith: i mean
07:44:38 <ClaudiusMaximus> pranz: :)
07:44:58 <c_wraith> all good
07:47:22 <Falkyouall> type Move = (Position, Position)
07:47:23 <Falkyouall> whichPiece :: Move -> Int
07:47:23 <Falkyouall> whichPiece (a:as) = a
07:47:24 <Falkyouall> why is this not working ?
07:47:50 <ClaudiusMaximus> @check \x y -> (x + y) * (x - y) == x * x - y * (y :: Float)
07:47:51 <lambdabot>  *** Failed! Falsifiable (after 3 tests and 14 shrinks):
07:47:51 <lambdabot>  -0.734553 -0.76879907
07:48:19 <c_wraith> Falkyouall: you are aware of floating-point rounding error, right?
07:48:38 <Herogx1> Why on earth can't ghci find my custom imported module
07:48:52 <Falkyouall> no not really @c_wraith
07:48:57 <Herogx1> It's in the same directory and both files have no compile errors except for the lack of ability to find the custom module
07:49:04 <ocramz> we're in IO; what does s <- malloc do? now s is a Ptr a
07:49:21 <c_wraith> Falkyouall: http://blog.reverberate.org/2014/09/what-every-computer-programmer-should.html  This is a good intro
07:49:49 <c_wraith> Falkyouall: it's describing issues that are a basic part of IEEE 754 floating point, which is what hardware supports, so every programming language provides
07:50:09 <ClaudiusMaximus> c_wraith: i think you mean me
07:50:11 <Fr4n> kt 
07:50:19 <Fr4n> it gets all weird when you introduce nans
07:50:22 <Falkyouall> i mean yes the principle is clear of floating point errors, but is that the issue in my case??
07:50:32 <c_wraith> Falkyouall: well, check..
07:50:56 <Geekingfrog> Can a function within the State monad can also depend on another argument? Something like: myFunc :: a -> State s b
07:51:24 <c_wraith> > (\x y -> ((x + y) * (x - y)), (x * x - y * (y :: Float))) (-0.734553) (-0.76879907)
07:51:25 <lambdabot>      Couldn't match expected type ‘Double -> Double -> t’
07:51:25 <lambdabot>                  with actual type ‘(Integer -> Integer -> Integer, Expr)’
07:51:25 <lambdabot>      The function ‘(\ x y -> ((x + y) * (x - y)),
07:51:34 <geekosaur> Falkyouall, people got you confused
07:51:40 <geekosaur> Falkyouall, you are asuming a tuple is a list
07:51:49 <Geekingfrog> or is it better to put this argument inside the state like: myFunc :: State (s,a) b
07:52:01 <geekosaur> a tuple (Position, Position) is not pattern matched with (x:xs), but with (x, y)
07:52:01 <c_wraith> geekosaur, Falkyouall: whoops.  I meant ClaudiusMaximus 
07:52:34 <Falkyouall> i try to adress the first argument in the tupel yes and yes i know its not an array so x:xs seems not to work
07:52:49 <c_wraith> > (\x y -> ((x + y) * (x - y), (x * x - y * (y :: Float))) (-0.734553) (-0.76879907)
07:52:50 <lambdabot>  <hint>:1:83:
07:52:50 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
07:52:55 <geekosaur> this would be clearer if the list sugar [x0, x1, ...] didn't exist because then you could see that a list is x0:x1:...:[]
07:53:19 <geekosaur> Falkyouall, are you unable to see (x, y)?
07:53:50 <c_wraith> > (\x y -> ((x + y) * (x - y), x * x - y * y)) (-0.734553) (-0.76879907) :: (Float, Float) -- ClaudiusMaximus 
07:53:51 <Falkyouall> no i can see it, the value i.E [(1,2)] comes in
07:53:52 <lambdabot>  (-5.1483925e-2,-5.148393e-2)
07:54:06 <c_wraith> ClaudiusMaximus: due to rounding error, those are not the same number
07:54:08 <Falkyouall> and i want to extract the first value of the tupel
07:55:08 <geekosaur> Falkyouall, then perhaps you meant the typer to be [Move] -> Integer and then the pattern match is ((x,_):_)
07:55:22 <geekosaur> because you did not mention a list in your type at all
07:56:07 <geekosaur> or is the value really [(1,2)] and if so what is the point of the outer list?
07:57:28 <ClaudiusMaximus> c_wraith: i see - is it likely that the rounding error is bounded?
08:07:07 <ClaudiusMaximus> @check let err a b = logBase 2 $ 1 - min (abs a) (abs b) / max (abs a) (abs b) in \x y -> err (x * x - y * y) ((x + y) * (x - y)) < negate (20 :: Float)
08:07:08 <lambdabot>  *** Failed! Falsifiable (after 1 test):
08:07:08 <lambdabot>  0.0 0.0
08:07:40 <ClaudiusMaximus> @check let err a b = logBase 2 $ 1 - min (abs a) (abs b) / max (abs a) (abs b) in \x y -> x == 0 || y == 0 || err (x * x - y * y) ((x + y) * (x - y)) < negate (20 :: Float)
08:07:42 <lambdabot>  +++ OK, passed 100 tests.
08:10:42 * hackagebot aeson-better-errors 0.7.0.0 - Better error messages when decoding JSON values.  http://hackage.haskell.org/package/aeson-better-errors-0.7.0.0 (hdgarrood)
08:19:27 <kaidelong> is there any library function to the tune of f [x,y] [z,w,a] = [x,z,y,w,a] ?
08:19:44 <kaidelong> intersperse, intercalate etc don't do tis
08:19:46 <kaidelong> this*
08:19:52 <c_wraith> I don't think it is in a library
08:20:06 <c_wraith> on the other hand..
08:20:07 <kaidelong> what would it (reasonably) be called?
08:20:19 <c_wraith> > concat $ transpose [[1,2],[3,4,5]]
08:20:20 <lambdabot>  [1,3,2,4,5]
08:20:30 <kaidelong> interleave?
08:20:37 <c_wraith> Yeah, I'd call it interleave.
08:20:41 <kaidelong> @type transpose
08:20:42 <lambdabot> [[a]] -> [[a]]
08:22:33 <mattby> interleave, but it probably exists
08:22:46 <mattby> it looks like MonadLogic's interleave
08:22:51 <mattby> but with arrays
08:23:21 <ion> lists
08:23:35 <mattby> terrible mistake, sorry
08:25:42 * hackagebot hgeometry 0.4.0.0 - Data types for geometric objects, geometric algorithms, and data structures.  http://hackage.haskell.org/package/hgeometry-0.4.0.0 (FrankStaals)
08:28:05 <kaidelong> @hoogle interleave
08:28:05 <lambdabot> package interleave
08:28:05 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexArrays interleavedArrays :: InterleavedArrays -> Stride -> Ptr a -> IO ()
08:28:05 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexArrays data InterleavedArrays
08:28:30 <kaidelong> window and pairwise are missing from the haskell libraries too and those are quite useful
08:29:03 <kaidelong> I guess there is some fun in zip`ap`tail worship
08:32:48 <mmachenry> Does anyone know how to simplify this hand-written fold on ListT using an existing fold from a library? http://lpaste.net/131840
08:36:46 <k0ral> @hoogle (Monoid a) => Maybe a -> a
08:36:46 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
08:36:46 <lambdabot> Data.Foldable fold :: (Foldable t, Monoid m) => t m -> m
08:36:46 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
08:45:51 <wolf_mozart> im havinng  some code design problems, my code is working well and fine, but it's kinda very rigid and linear
08:46:15 <wolf_mozart> I don't know how to get around
08:46:19 <wolf_mozart> this
08:46:31 <dmj`> wolf_mozart: can you share your code on lpaste.net ?
08:46:51 <Falkyouall> why is my function giving me no minimum value??
08:46:57 <Falkyouall> seekMaxMin :: [Double] -> (Double, Double)
08:46:57 <Falkyouall> seekMaxMin [] = (0.0, 0.0) 
08:46:57 <Falkyouall> seekMaxMin (x:xs) = (max x maxiList, min x miniList)
08:46:59 <Falkyouall> 	where (maxiList, miniList) = seekMaxMin xs
08:47:30 <wolf_mozart> dmj`: I think you caught me, I'm working in another  lang
08:51:47 <nak> wolf_mozart which lang ?
08:53:39 <jomg> Falkyouall, your function might return 0 as a maximum/minimum even if it isn't an element of the list
08:53:51 <sam> hi! I have countless fixes for the script that lies here: https://ghc.haskell.org/trac/ghc/wiki/Building/Windows/SSHD
08:54:04 <sam> can someone point me to the right communication channel to send them?
08:54:06 <jomg> that might be the cause of whatever problems you're having with it
08:55:47 <geekosaur> sam: try in #ghc?
08:56:07 <sam> geekosaur: ah, thanks, will try
09:00:43 <Geekingfrog> Think of a scraper: I have a list of String (links) and I want to construct another list from these, by doing some IO using the first list. What type should my fold function be? IO ([String] -> String -> [String]) ????
09:02:00 <srhb> Geekingfrog: So each link produces a number of links?
09:02:13 <Geekingfrog> yes
09:02:19 <srhb> Geekingfrog: Either [Link] -> IO [Link] or [Link] -> IO [[Link]]
09:02:38 <JordiGH> I have a function f :: Integer -> Integer and I want to list the "paths" that this function takes, that is, I want to list its iterates but stop if I run into an integer I've already seen. Obviously I can use iterate to generate its iterates, but how do I stop once I get an iterate I've already seen?
09:02:43 <benzrf> Geekingfrog: are you performing one operation for each link?
09:02:46 <benzrf> Geekingfrog: is this a map or a fold?
09:02:48 <srhb> Geekingfrog: For the full function, that is
09:03:06 <benzrf> Geekingfrog: do you have a single (Link -> IO Thing)?
09:03:10 <Geekingfrog> actually, I have to carry some state over each operation, so a map cannot do
09:03:18 <michaelt> Geekingfrog: you are looking for an argument for Control.Monad.foldM ?
09:03:29 <benzrf> Geekingfrog: perhaps you could use a statet over io
09:03:33 <benzrf> although that seems like overkill
09:03:35 <benzrf> :t foldM
09:03:36 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
09:03:37 <indiagreen> JordiGH: you can use a Set to store the list of already seen iterates
09:03:58 <indiagreen> and then just check on each step whether the result is in the set
09:04:09 <benzrf> (Thing -> Link -> IO Thing) -> Thing -> [Link] -> IO Thing
09:04:30 <Geekingfrog> In my case actually, I know I'm going to explore a tree, so I don't need to check for already visited links
09:04:38 <JordiGH> indiagreen: So something like: takeWhile someFunctionUsingSet $ iterate f 1
09:04:57 <indiagreen> no, takeWhile has no state
09:05:04 <exio4> that'd need some kind of stateful takeWhile 
09:05:17 <JordiGH> indiagreen: I thought the state would be in someFunctionUsingSet
09:05:34 <indiagreen> someFunctionUsingState is a predicate
09:05:43 <JordiGH> I don't get "state". Isn't it just another variable you pass around?
09:05:43 <indiagreen> if it's pure, it can't have state
09:05:45 <Geekingfrog> what if the someFunctionUsingSet is StateT a IO [Link] ?
09:05:58 <Geekingfrog> problem is: it's not pure
09:06:07 <benzrf> Geekingfrog: use mapM, then, probably
09:06:11 <Geekingfrog> I have to make request with a token, which has to be renewed every ten requests
09:06:16 <benzrf> good lord
09:06:35 <benzrf> maybe you should be building some abstractions that will help simplify this particular problem
09:06:36 <Geekingfrog> it's actually just an exercise to help me use the State monad and some IO
09:06:41 <benzrf> or alternatively look for existing ones
09:06:45 <benzrf> Geekingfrog: huh
09:07:22 <Geekingfrog> I was thinking of having the token thing encapsulated inside a StateT Token IO Links
09:07:42 <JordiGH> indiagreen: What if I use inits and run takeWhile on that instead?
09:07:59 <JordiGH> takeWhile the lists are all of unique integers.
09:09:01 <nwf> Good morning, channel.  Does anyone have advice for dealing with repetition in .cabal files?  I have the same large set of Build-Depends in a Library and two Executable stanzas and keeping them all sync'd is something of a drag.
09:09:23 <indiagreen> you can surely do something like “takeWhile hasNoDuplicates . inits . iterate ...”, but it would be too slow
09:09:32 <kadoban> JordiGH: That will perform terribly.
09:09:42 <JordiGH> Okay, so how would you do it instead?
09:10:00 <indiagreen> with an unfoldr or, if I want my code to be readable, a recursive function
09:10:19 <kadoban> Either the set thing, or a real cycle detection algorithm https://en.wikipedia.org/wiki/Cycle_detection
09:10:39 <JordiGH> Hm.
09:10:41 <JordiGH> Ok.
09:10:49 <Aruro> :t head
09:10:50 <lambdabot> [a] -> a
09:11:10 <Aruro> when we write head [] what is type of a? 
09:11:13 <kadoban> The set thing will be faster, but will use lots of space if the cycles can be very long. It depends
09:11:27 <Iceland_jack> :t head []
09:11:28 <lambdabot> a
09:11:41 <michaelt> :t  Data.Tree.unfoldForestM
09:11:42 <lambdabot> Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
09:11:51 <kadoban> Aruro: Any 'a'. Of course it's like saying 'undefined' there, since all it's going to do is bottom when you use it.
09:12:51 <JordiGH> Oh, this reminds me: instead of exceptions, why isn't anything that could throw an exception not a Maybe instead?
09:13:02 <JordiGH> Exceptions are so weird.
09:13:08 <Iceland_jack> JordiGH: You can reify the exceptions using 'try'
09:13:09 <Iceland_jack> :t try
09:13:10 <lambdabot> Exception e => IO a -> IO (Either e a)
09:13:31 <Aruro> kadoban: so what is type in the case of [] argument?
09:13:41 <Iceland_jack> Aruro: Ask lambdabot
09:13:43 <Iceland_jack> :t []
09:13:43 <geekosaur> JordiGH, might look at the spoon package
09:13:44 <lambdabot> [t]
09:13:50 <Aruro> mmm
09:13:53 <Iceland_jack> A list of any type
09:13:53 <geekosaur> there are a number of things that throw exceptions that IMO should not
09:14:47 <Aruro> :t undefined
09:14:48 <lambdabot> t
09:15:06 <Falkyouall> jomg, its givig me a maximum value but instead of givng me a minimum it just give me my exeption ... how can i prevent that?
09:15:06 <Aruro> type [undefined]
09:15:10 <Aruro> :t [undefined]
09:15:11 <lambdabot> [t]
09:15:29 <Aruro> :t undefined->undefined
09:15:30 <lambdabot>     Pattern syntax in expression context: undefined -> undefined
09:15:43 <jomg> Falkyouall, that's weird, it seems to run without exception for me, on what list did you use it?
09:16:21 <Falkyouall> on a [1,343,43,53,1,5,7]
09:16:35 <Aruro> why not to say head [] = undefined?
09:16:42 <Aruro> since
09:16:44 <Aruro> :t undefined
09:16:45 <lambdabot> t
09:16:47 <Falkyouall> even if i give it doubles it dont wort it out
09:16:58 <Aruro> @src head
09:16:58 <lambdabot> head (x:_) = x
09:16:58 <lambdabot> head []    = undefined
09:17:00 <Iceland_jack> That's how it's defined in lambdabot
09:17:02 <Aruro> ok :D
09:17:10 <michaelt> nwf: certainly it used to be the case that nothing could be done; maybe something has changed though. 
09:17:13 <kadoban> :t error "blah"
09:17:14 <lambdabot> t
09:17:38 <jomg> Falkyouall, i don't get an exception, it returns (343.0, 0.0) for me
09:17:51 <Aruro> @src error
09:17:51 <lambdabot> error s = throw (ErrorCall s)
09:17:59 <Falkyouall> thats what i meant, it dont give me the correct min value
09:18:09 <Falkyouall> what to do? :)
09:19:02 <jomg> Falkyouall, you should change you base case from "seekMinMax [] = (0, 0)" to "seekMinMax [x] = (x, x)"
09:19:17 <jomg> since the minimum/maximum of an empty list isn't defined
09:19:29 <Falkyouall> okaaay, ill try 
09:19:35 <geekosaur> and using 0 there will ensure that 0 is always produced unless the list contains negative numbers
09:19:51 <geekosaur> fir that ,atter you will see that a list of negative numbers will have a working min but max will be 0
09:19:57 <geekosaur> *for that matter
09:21:02 <geekosaur> because that case is always applied at the end of the list
09:21:12 <geekosaur> not only on empty lists
09:21:30 <geekosaur> because you recurse, and on the last recursion it will get the empty list
09:21:37 <Falkyouall> jomg thanks that worked! 
09:22:45 <michaelt> nwf: if the executables import the library, they don't need its dependencies, unless of course they use them directly.
09:26:07 <quchen> Is it possible to have a cyclic dependency on Hackage, or does it (or some other thing, say `cabal check`) detect that sort of issue?
09:28:44 <mkscrg> anyone here familiar with building GHC / diagnosing GHC build errors?
09:28:52 <mkscrg> i’m (naively :) trying to improve the GHC/Homebrew situation
09:29:05 <mkscrg> looking at this failed build: http://bot.brew.sh/job/Homebrew%20Pull%20Requests/25284/version=mavericks/testReport/junit/brew-test-bot/mavericks/install_ghc/
09:29:15 <mkscrg> error near the bottom:    cat: utils/hpc/hpc.wrapper: No such file or directory
09:33:38 <nwf> michaelt: The executables probably do not need all of them, but need more than just the library itself.
09:34:07 <michaelt> nwf: but where they use them, you want the same numbers of course
09:34:31 <michaelt> mkscrg: https://github.com/ghc/ghc/blob/master/utils/hpc/hpc.wrapper it seems it should be there ...
09:34:47 <nwf> michaelt: Yeah.  I am thinking of resorting to preprocessing my .cabal file with m4.
09:35:52 * hackagebot dbcleaner 0.1.0 - Clean database tables automatically around hspec tests  http://hackage.haskell.org/package/dbcleaner-0.1.0 (sestrella)
09:37:15 <michaelt> nwf: I was looking at an old and new pandoc.cabal which used to have to repeat everything but it still does what we were just describing http://hackage.haskell.org/package/pandoc-1.9.4.5/pandoc.cabal vs. new:  http://hackage.haskell.org/package/pandoc-1.13.2.1/pandoc.cabal
09:38:16 <michaelt> nwf: now that I think of it, it was maybe easier when you just repeated the stuff the library used, and then added stuff ...
09:38:51 <mkscrg> michaelt: agreed, should be. and that same homebrew formula runs great on my laptop (also yosemite)
09:38:59 <Herogx1> How can I force haskell to find my modules? Trying to compile and it states that it can't find my module
09:39:52 <michaelt> Herogx1: if you do ghc Main.hs and import MyLib.MyModule then ghc will look in MyLib/  
09:40:06 <michaelt> Herogx1: of course you could cabalize and not have to think too much...
09:40:37 <Herogx> Well uh, they are in the same directory, the module file
09:40:40 <Herogx> and the main.hs
09:40:47 <Herogx> So I can't see why it can't find it
09:41:00 <michaelt> Herogx: what is the name of the imported module?
09:41:05 <Herogx> Utility
09:41:22 <michaelt> and there is Utility.hs in the same directory
09:41:39 <Herogx> utility.hs....does it need the uppercase character for the file name?
09:41:58 <Herogx> The module is defined as uppercase
09:42:02 <michaelt> Herogx:  I think it doesn't  or didn't.  And inside it calls itself module Utility where ...
09:42:57 <ttt_fff> just read about prolog + algorithmw today
09:43:01 <ttt_fff> such cool algorithms
09:43:27 <SrPx> What is the "vector length" operation on linear?
09:43:37 <Herogx> it does do all that, michaelt it is properly defined
09:43:40 <Herogx> just can't find it
09:43:53 <bennofs> SrPx: wild guess, maybe abs from Num ?
09:43:55 <athan> ttt_fff: Isn't algorithm W something to do with unification / constraint solving?
09:44:12 <ttt_fff> athan: haskell/ML type inference, which, as you pointed out, ends up being unification / constraint solving
09:44:18 <SrPx> bennofs: nope just returns the vector itself
09:44:26 <bennofs> oh right, abs doesn't change type
09:44:28 <athan> ttt_fff: Ah! Awesome :)
09:44:37 <SrPx> I expected it to be on Metric but seems like it is not, guess I need "distance (V3 0 0 0) vec"? weird
09:45:05 <bennofs> SrPx: norm?
09:45:10 <Herogx> I renamed both files to have uppercase and now it states file name does not match module name, Saw : 'main' Expected: 'Utility'
09:45:18 <SrPx> norm is just the normal, it is a vector too
09:45:44 <Herogx> Wait I got it
09:45:48 <Herogx> I think
09:45:51 <bennofs> SrPx: λ: norm (V3 1 1 0)
09:45:53 <bennofs> 1.4142135623730951
09:46:00 <michaelt> Herogx: this works if i do ghci Main.hs  https://github.com/michaelt/drunken-wight
09:46:16 <bennofs> SrPx: norm :: Floating a => f a -> a, so no vector
09:46:27 <Herogx> No I got it, the issues were it wasn't named properly, as in the module was defined with 'Utility' when the file was 'utility'
09:46:33 <michaelt> Herogx: did you write module Utility where 
09:46:41 <Herogx> Yes
09:46:43 <Herogx> It works now
09:46:50 <Herogx> the capitals where the issue I think
09:46:52 <SrPx> Ohh... alright, normalize is the one I had in mind. Fair enough, thanks!
09:47:02 <Herogx> that and I had an import on the first line instead of the module definition
09:47:04 <bennofs> SrPx: normalize seems to be named signorm I'd guess
09:47:20 <michaelt> Herogx: if lowercase the file it seems to work here though. obviously the internal module name needs an upper case
09:47:29 <SwashBuckla> why might a normal Haskell file compile fine, where a module of the same file fails to compile?
09:47:35 <michaelt> Herogx: if i lowercase the file, rather ...
09:47:46 <SwashBuckla> all I am adding is a `module Filename where...`
09:47:50 <ReinH> SrPx: It's norm, which is why distance is implemented as distance f g = norm (f ^-^ g)
09:47:59 <SwashBuckla> this is enough to introduce several compile errors
09:48:01 <SrPx> yep
09:48:22 <ReinH> SwashBuckla: What errors?
09:48:24 <Herogx> michaelt:  I suspect the issue was the fact that I had an import for Data.Char on the first line instead of the module definition, then
09:49:59 <michaelt> Herogx: right, if you dont write Module XYZ where, then the module name is "Main" 
09:50:18 <michaelt> "module XYZ where", rather
09:51:02 <Herogx> No I did write that it was just the fact that it was not the first thing in the file
09:51:04 <lpaste> SwashBuckla pasted “module GetURLTitle where” at http://lpaste.net/131982
09:51:52 <michaelt> SwashBuckla: you need {-#Language OverloadedStrings#-} at first sight ...
09:52:33 <michaelt> SwashBuckla: or better, if L.null body then blah else bleh
09:52:57 <napping> Herogx: did you get an error about writing module later?
09:52:59 <SwashBuckla> michaelt: that was the problem
09:53:02 <SwashBuckla> ReinH: ^
09:53:05 <SwashBuckla> thanks michaelt 
09:53:38 <SwashBuckla> when I added 'module XYZ where' I bumped the LANGUAGE pragma down
09:53:47 <SwashBuckla> disabling it
09:54:00 <michaelt> oh right, those things need to be first also ghc options and so on
09:54:00 <napping> huh, did that at least get a warning?
09:54:35 <SwashBuckla> napping: are you talking to me?
09:54:40 * SwashBuckla looks into mirror
09:55:14 <napping> SwashBuckla: yeah. I don't get a warning here
09:55:16 <michaelt> napping: funny, it doesn't seem to mind if you put {-#LANGUAGE blah#-} too far down. I guess it ignores it then
09:55:39 <napping> Yeah, I think it would be easy to recognize and complain about
09:56:33 <michaelt> I guess it's hard to detect the difference since it will complain that you are using the wrong language if you misplace the pragma
09:57:09 <napping> I mean syntactically recognizing that it's a pragma and placed too late to have any effect
09:57:55 <michaelt> yeah, I see.
10:00:52 * hackagebot friendly-time 0.4 - Print time information in friendly ways  http://hackage.haskell.org/package/friendly-time-0.4 (PatrickBrisbin)
10:05:00 <maerwald> unspecific question: what's the word on the dynamic linking front?
10:05:34 <napping> What about dynamic linking?
10:06:18 <napping> I think shared libraries work everywhere, and haven't heard anything recent about dynamic loading
10:06:35 <napping> maybe there was something about using the system dlopen more?
10:07:30 <maerwald> napping: I have no idea, have never used it. Does it work on "global" scale?
10:07:46 <maerwald> e.g. what about ABI breakage etc
10:08:07 <napping> I mean compiling with ghc defaults to using shared libraries for Haskell libraries
10:08:22 <napping> I don't think there's any kind of stable ABI
10:10:01 <napping> More importantly, with cross-module inlining, library versions are not necessarily backwards compatible even if the ABI is more stable now
10:15:53 <bitrauser> good evening everyone
10:16:38 <napping> good morning
10:16:45 <L8D> good morning
10:17:12 <ggVGc> what are the downsides to structural typing compared to what haskell has?
10:18:20 <c_wraith> ggVGc: structural subtyping can be implemented *pretty* well in GHC now.  It's just not with syntax as clean as it gets in a language that has it built-in.
10:19:18 <c_wraith> ggVGc: From that, I infer that structural subtyping is an orthogonal feature that can be added pretty cleanly, so long as it's during language design.
10:19:19 <ggVGc> c_wraith: oh, I was more interested in the negative aspects of structural typing, since it's always been my idea of the most useful type system, but I only have nominative types alá C++, Java etc. to compare to
10:20:27 <c_wraith> ggVGc: my point is that it's mostly orthogonal to what haskell has, since otherwise the only subtyping relationships in haskell come from functions.
10:20:40 <napping> functions?
10:20:50 <napping> It's more about polymorphism, right?
10:21:02 <napping> and constraints, I suppose
10:21:13 <c_wraith> well, it requires polymorphism, but it seems to also require function types in practice
10:21:37 <ggVGc> c_wraith: well, I mean, I think haskell achieves a lot of what structural typing gives by having type classses
10:22:01 <napping> often, yeah. I think things like data type a-la-carte get some use from polymorphism on pure data types
10:22:02 <c_wraith> I guess it doesn't need function types if constraints are also involved
10:22:13 <ggVGc> c_wraith: in structural typing youäd write a function expecting "any value with a compare-method", while in haskell you's say "eq"
10:22:43 <ggVGc> to me that's the same thing done with different tools
10:23:00 <napping> ggVGc: I don't think there are any disadvantages to things like extensible records that lead to any firm decision to keep them out of haskell
10:23:26 <napping> You might want to look at the polymorphic variants / objects in O'Caml
10:23:58 <napping> One complaint is less clearly stating your types, and sometimes getting huge inferred types if you don't go ahead and explicitly name things
10:24:01 <ggVGc> napping: F# is actually where I first got in contact with static structural typing(as opposed to dynamic duck typing), so I guess my thoughts originally come from ocaml
10:24:21 <Zemyla> Hmm. Has anyone had any success in teaching monads by starting with functors, and then applicatives?
10:24:50 <ggVGc> Zemyla: I don't get monads yet, but I feel understanding functors and applicatives first is a must.
10:24:52 <c_wraith> Zemyla: it works pretty well when people don't insist they must "understand monads" to program in Haskell
10:25:32 <napping> I'm not sure if you have less efficient term representations, or if generic programming stuff like Generics have trouble with extensible records
10:26:24 <blogle> I have been trying to catch someone familiar with the vty-ui library on here the past couple days. Is there anyone who can help me out?
10:26:43 <napping> ggVGc: Have you read about MLpolyR?
10:26:47 <ggVGc> napping: I think generics don't really conflict with structural typing at all? They seem to go hand in hand to me
10:26:52 <ggVGc> hm, no
10:26:54 <ggVGc> will gogle it
10:27:12 <napping> That's probably the cleanest presentation of the kind of structural subtyping Haskell would be likely to get
10:27:24 <napping> and really, stuff like vinyl more or less implements it on top of what we have
10:27:31 <ggVGc> that's a really weird name for a language
10:27:47 <napping> except needing to build up from pairs and stuff that definitely does give a less efficient term representation
10:28:00 <napping> I suppose if it's built into the runtime it wouldn't be any more expensive than an Array
10:28:47 <napping> ggVGc: Generics is a typeclass that gives you some representation of the definition of a type class. If record types can have extra fields and are equal modulo permutation, maybe it's hard to define a canonical representation
10:29:13 <ggVGc> reason I'm asking is that I want to experiment with adding a type system over javascript, and I think structural typing would fit perfectly since that's how we mostly program in dynamic languages anyway. Might as well have the compiler check it for us
10:29:31 <napping> You can already do things in Haskell like passing an equal function separately if you want to
10:29:54 <napping> I guess the main difference is that you are thinking of passing around objects with tons of built-in methods, and writing signatures that only care about a few
10:30:10 <napping> that's very much the sort of thing O'Caml's object system can do
10:30:27 <ggVGc> yep, that sounds like what I'm imagining
10:30:29 <napping> It's object types are basically row variable polymorphism-style records
10:30:33 <kaidelong> ggVGc, there is a concept of satisfiability typing where you try to prove that types are invalid, and then complain, rather than complaining when you find that types are not valid
10:30:34 <ggVGc> as I said, I come from F# mostly
10:30:43 <napping> It's not exactly Haskell style to have objects likke that
10:30:50 <ggVGc> yeah, true
10:30:54 <napping> rather keeping the data and functions separately
10:30:55 <kaidelong> these probably map better to people's expectations of dynamic languages
10:30:56 <ggVGc> so comparing to haskell was probably wrong
10:31:08 <napping> well, 
10:31:11 <kaidelong> but I don't know much about the work that has been done in this field except that a type system like this was designed for Erlang
10:31:16 <ggVGc> kaidelong: yeah, that's why I am thinking of it. I basically want to take javascripts' duck typing and put it in a compiler
10:31:20 <napping> there are notions of structural typing that would be very nice to have in Haskell
10:31:52 <napping> I think I'd get more use out of extensible variants than record subtyping, actuall
10:32:15 <kaidelong> structural typing is somewhat orthogonal
10:32:42 <ggVGc> kaidelong: orthogonal to what?
10:32:44 <kaidelong> Haskell can do that, you could look at nikita-volkov's records library
10:33:12 <napping> I think a while ago the constraints like "Has" and "Lacks" predicates maybe seemed like a bit much to add the the constraint system
10:33:31 <napping> but now we have equalities in addition classes, and constraint kinds and type families returning constraints
10:33:45 <kadoban> Zemyla: Seems to work out, yeah. It's the only way they ended up making sense to me, and it's the progression used in cis194 and nicta and … pretty much everywhere I've actually seen them described well.
10:33:52 <kaidelong> ggVGc: orthogonal to the satisfiability (the code can be correct) vs validity (the code is correct) question
10:34:17 <napping> kaidelong: Wadler's papers are pretty nice :)
10:34:18 <kaidelong> if you allow the available type information to change at runtime, the latter becomes really hard to prove
10:34:33 <kaidelong> but the former might be a workable approach
10:34:39 <napping> kadoban, rather
10:35:00 <kaidelong> you get less helpful type errors though because you only get yelled at if you write something that couldn't possibly ever work
10:40:58 <kaidelong> basically the difference is in how you treat unification of polymorphic variables, in Haskell you can't treat a thing of type String -> String as something like type a -> a but if you only worry about satisfaction then String -> String works on one type, and because your language is dynamic it's polymorphic anyway and you don't even know what might exist at runtime
10:41:24 <kaidelong> so unless you try to do something totally insane like unify it with Int, all bets are off
10:41:31 <napping> that sounds a bit questionable. Maybe as part of a gradual type system with nice blame tracking?
10:42:28 <kaidelong> oh, wasn't gradual typing in things like Hack based on satisfaction?
10:43:09 <napping> I don't know about Hack
10:43:24 <kaidelong> well the idea of gradual typing in general
10:43:25 <napping> but the gradual typing stuff I'm familiar with basically has a "dynamic" type
10:43:34 <napping> which is a pair of a value and it's static type
10:43:40 <kaidelong> I think it might have been an example of using satisfaction rather than validation
10:43:48 <kaidelong> so it might be relevant
10:43:49 <napping> and then you can try to do whatever you want, but it complains if stuff goes wrong
10:44:06 <napping> and then you can formally define a notion of whose fault a type error is, and prove that it's never the fault of the typed code and stuff
10:44:37 <Falkyouall> guys, how to do this: i got this value ([1,2,3][][])  which i want to change based on the this value ([1,3])  to  ([2,3][][1]) 
10:45:22 <kaidelong> how would this work without overloading the list operator?
10:45:33 <kaidelong> oh, are those meant to be tuples?
10:46:49 <Falkyouall> yes theyre ment to be tuples
10:47:11 <hodapp> Well, I made a record that had M fields, and only N < M of them that made sense to be user-defined, so I made an N-parameter smart constructor. Then N kept growing...
10:48:10 <hodapp> Now I'm not sure what's more kosher: To simply make that smart constructor fill in the remaining fields of a record, or to put a smaller record inside of the full one
10:48:27 <hodapp> where that smaller record has the things that user should actually define
10:49:13 <hodapp> not sure if I'm in lens territory yet.
10:49:45 <napping> that seems to be the most extensible approach - make your type opaque and provide a default value along with a list of functions seting various fields
10:49:56 <Iceland_jack> :t snd
10:49:57 <lambdabot> (a, b) -> b
10:49:59 <zipper> How does one set the GHC server in ide-backend?
10:50:02 <hodapp> napping: which approach?
10:50:24 <merijn> hodapp: There's a simpler solution
10:50:38 <napping> hodapp: the one I mentioned, where you just keep the type opaque
10:50:44 <merijn> hodapp: Define a "default" value of your record type and only export the user settable field accessors
10:51:04 <napping> If the type just keeps growing and growing, and you expect it to keep growing and growing, and you don't want to break old code
10:51:12 <merijn> hodapp: That way they can only modify an existing default record
10:51:25 <hodapp> the old code is small enough right now that breaking it isn't a problem
10:51:45 <hodapp> merijn: I'm not sure if in all cases there is a sensible default value of every field, but I will look
10:51:54 <napping> You can also keep source compatibility by completely exposing a record type, and expecting people to use a default value along with record update syntax
10:51:55 <kaidelong> Falkyouall: I'm not quite able to figure out what you mean. Append the longest subsequence counting from the head of both lists to the third element in the tuple?
10:52:01 <nitrix> Hi. I have two IO functions and multiple implementations for them. Does it makes more sense to use Haskell's typeclass+instances semantic or have a record with two functions?
10:52:16 <nitrix> I like the class idea because I can ude MaybeT
10:52:33 <johnw> I prefer to start with the record
10:52:46 <nitrix> johnw: And then extend as the need for MaybeT arises?
10:52:59 <johnw> i don't know enough about your use case to answer that
10:53:18 <kaidelong> Falkyouall: maybe put the problem in context?
10:53:26 <napping> the only danger of exposing a record is that code which uses the record constructor directly, instead of updating the default, would break when you add fields
10:53:27 <nitrix> johnw: put :: Block -> IO (Maybe BlockID)
10:53:32 <Falkyouall> kaidelong: im doing the towers of hanoi
10:53:35 <nitrix> johnw: get :: BlockId -> IO (Maybe Block)
10:53:43 <kaidelong> ah, okay
10:53:47 <hodapp> Actually, I have an additional reason why I may want to have the record contain a smaller record (intended to be user-defined): there are cases where that smaller record will need to be reused, and it makes sense to do so
10:53:57 <niklasb> nitrix: so basically with the record type your functions become something like Implementation -> Block -> IO (Maybe BlockID) etc
10:53:59 <niklasb> which is nice
10:54:05 <kaidelong> so you have n stacks, and that middle argument is a command move from stack p to stack q
10:54:07 <niklasb> what about maybet?
10:54:17 <johnw> yeah, I would only introduce a typeclass if the types were a -> IO (Maybe b) and b -> IO (Maybe a)
10:54:32 <johnw> with IO ~ m in fact
10:54:34 <kaidelong> hanoiUpdate :: [[Int]] -> (Int,Int) -> [[Int]]
10:54:42 <kaidelong> is this what you are trying to do?
10:55:03 <Falkyouall> an this is the move function which take the right step (tower one to tower two) and change the sequence of the towers, so on tower one are now ([stone 2, Stone 3],[],[now Stone 1 is here])
10:55:47 <nitrix> johnw: niklasb: So what you're saying is that I should keep classes for more generic concepts (language-wise) and use records as far as my application needs are concerned?
10:55:54 <johnw> you can see typeclasses as reifying an abstraction; as a "delivery mechanism", they are overkill
10:56:13 <Falkyouall> i have to use this bindings 
10:56:18 <Falkyouall> type Position = Int
10:56:18 <Falkyouall> type Move = (Position, Position)
10:56:18 <Falkyouall> type Towers = ([Int],[Int],[Int])
10:56:20 <Falkyouall> hanoi :: Int -> Position -> Position -> [Move]
10:56:42 <nitrix> johnw: I see. So a typical application doesn't have bunch of typeclasses, that's more for libraries. My program would use record data types.
10:56:50 <johnw> in this case, you are not dealing with something abstract, you're just parameterizing on a choice of implementation
10:56:58 <johnw> which yes, typeclasses can do, but so can passing around functions as values
10:57:06 <nitrix> I see.
10:57:18 <athan> Is there a reason why there isn't an execST for the ST monad?
10:58:11 <nitrix> You mean runST ?
10:58:38 <kaidelong> I'm assuming he's talking about something that exposes the hidden ST heap
10:58:51 <kaidelong> I am trying to think of a reason but I can't think of one
10:59:23 <athan> nitrix: kaidelong is on the right track
10:59:41 <athan> I'm accumulating my state like a writer that needs introspection :\
10:59:42 <kaidelong> as far as I can see, so long as the heap is frozen and copied as an immutable value
10:59:49 <kaidelong> there should be no problem with an execST like function
11:00:09 <athan> Hmm, okay. I haven't toyed with ST before - is that the benefit compared to State?
11:00:30 <johnw> nitrix: in fact, in your case, since the types Block and BlockID are fixed (I presume), there would be nothing to "key" your typeclass off of.  If you did invent such a key (say, using a phantom type), you'd be constrained to a single implementation choice per key.  Functions-as-values have none of these limitations.
11:00:56 <kaidelong> I'm thinking that there is some reason I'm not aware of that makes "freeze the heap and expose it" not a feasible thing to do
11:01:20 <kaidelong> but if you want access to the internal state then State is probably exactly what you want anyway
11:02:06 <barrucadu> athan: The benefit compared with State is that it can do actual mutation under the hood, and so get a performance gain
11:02:11 <nitrix> johnw: I was more thinking :: ProviderDemo1 -> Block -> IO (Maybe BlockId)  and :: ProviderDemo2 -> Block -> IO (Maybe BlockId)
11:02:11 <kaidelong> the thing about ST versus State is that ST's internal heap is mutable so it is shared with subsequent states through destruction (and you can't reverse steps, which is why an ST operation loses its state after it runs)
11:02:33 <nitrix> johnw: And a list of all the provider instances, but a record can do the same.
11:03:37 <nitrix> johnw: Where ProviderDemo1 and ProviderDemo2 would both be instances of Provider and implement `get` and `put`.
11:03:42 <kaidelong> I'm thinking an execST like function might well be possible, not just terribly useful except perhaps to make an STT that works with things like lists
11:03:59 <niklasb> nitrix: then ProvderDemoX are the phantom types johnw was talking about
11:04:08 <nitrix> niklasb: I see.
11:04:22 <johnw> When writing a purely abstract function, you really know nothing, and @djinn could probably write it for you.  Typeclasses let you introduce a restricted form of knowledge about the abstraction you're working with, like, "I don't know anything at all about 'a', but I do know it can behave like a Monoid...".
11:04:24 <kaidelong> you'd be making something like "ST with snapshots"
11:04:28 <athan> oh woah!
11:04:50 <indiagreen> does mapM_ have a performance/memory usage benefit compared to mapM?
11:05:04 <athan> thank you kaidelong. I'm using it for the "abundant sums" project euler problem, #23 :)
11:05:09 <kaidelong> indiagreen: yes, it can be significant too especially when dealing with infinite input
11:05:11 <johnw> indiagreen: it can, yes, depending on the Monad involved
11:05:40 * indiagreen shall not replace one with the other everywhere in nir code because the underscore is ugly, then
11:05:43 <kaidelong> athan; if you're actually going to try this, you might want to ask on #ghc
11:05:48 <kaidelong> there are probably dragons there
11:05:59 <nitrix> johnw: Because the return type is `IO (Maybe x)`, wouldn't that be a good reason to use MaybeT transformer?
11:06:00 <athan> haha
11:06:03 <athan> right on :)
11:06:21 <johnw> nitrix: only if you intend to combine it with lots of other IO (Maybe x) computations
11:06:27 <johnw> otherwise, using MaybeT is just notational overhead
11:07:07 <johnw> MaybeT IO x composes nicely, IO (Maybe x) does not
11:07:08 <kaidelong> athan: if you only need to freeze/thaw arrays then Data.Vector could do this without you needing to mess with the internal representation of ST
11:07:25 <johnw> but if you don't end up doing a lot of composition, they are pretty much the same
11:07:35 <nitrix> johnw: The most frequent operation is some sort of   [Provider] -> (p -> Maybe b) -> Maybe b
11:07:53 <nitrix> johnw: Where it gets a list of providers, try to obtain a block from them, stops at the first successful one.
11:08:09 <nitrix> johnw: Which is like the opposite of the default behavior for `Maybe` I think.
11:08:10 <johnw> ah, then maybe it would be useful, yes
11:08:21 <johnw> right, using EitherT then
11:08:23 <johnw> use*
11:08:24 <nitrix> Maybe not `Maybe` but similar, I don't know.
11:08:38 <nitrix> Yeah, so Provider would be transformed by EitherT
11:08:41 <nitrix> That could be nice.
11:08:43 <johnw> EitherT a IO ()
11:08:56 <johnw> gives you an 'a' on success, () if it reached the end
11:08:57 <nitrix> That's possible with an IO ?
11:08:58 <nitrix> Fancy.
11:09:10 <ReinH> @unmtl EitherT a IO ()
11:09:11 <lambdabot> EitherT a IO ()
11:09:17 <ReinH> Well thanks lambdabot.
11:09:25 <johnw> it's not fully edwardk-complete
11:09:28 <ReinH> Indeed
11:09:49 <ReinH> johnw: wait, gives an 'a' on *success*?
11:09:59 <johnw> you can define what success means
11:10:05 <johnw> it's not built-in to the type that Left means failure 
11:10:09 <ReinH> Ah. There's EitherR as well.
11:10:13 <johnw> (like it is with ErrorT)
11:10:37 <ReinH> johnw: True, but the semantics support that usage
11:10:55 <johnw> right, EitherT is just the "early exit" monad
11:11:00 <ReinH> Yep.
11:11:09 <ReinH> But see https://hackage.haskell.org/package/errors-1.4.1/docs/Data-EitherR.html
11:11:30 <johnw> yeah, the advantage to EitherR is that you can easily work with intermediate values in do-notation
11:11:36 <ReinH> yep
11:12:19 <dgpratt> so I recently gave a presentation on Haskell to my local hacker (not that kind of hacker) club
11:12:35 <indiagreen> how did it go?
11:12:36 <dgpratt> and it was well recieved
11:12:46 <dgpratt> someone recorded it
11:12:48 <ReinH> dgpratt: sweet
11:13:13 <dgpratt> I don't think it will be of any educational value to anyone in here, but I wouldn't mind critiques
11:13:26 <dgpratt> https://youtu.be/Zng4kS5EZ20?t=1765
11:13:39 <dgpratt> it's pretty long, 90 minutes
11:14:00 <dgpratt> but I got some good questions -- it was a small group, but pretty diverse in background
11:14:24 <dgpratt> I made a few verbal typos :)
11:14:55 <dgpratt> like at one point claiming that Haskell does not have ternary functions
11:15:06 <kaidelong> it only has unary ones
11:15:34 <dgpratt> kaidelong, yes, ironically I was technically correct, but that's not what I meant to say regardless
11:15:35 <edwardk> johnw: unmtl was written in response to types i was using in category-extras =)
11:15:55 * hackagebot mosaico-lib 0.1.0.0 - Generacin interactiva de mosaicos  http://hackage.haskell.org/package/mosaico-lib-0.1.0.0 (mgomezch)
11:18:00 <nitrix> ReinH: johnw I'll check both, thanks.
11:18:31 <nitrix> Actually, no, that's a horrible idea.
11:19:54 <nitrix> My Provider class doesn't really abstract a value. It's not like a container. And there's two operations (the get and put) so I don't know how those monad transformers would help.
11:20:43 <nitrix> get needs to sto pat the first successful one and put is done for 3 providers and succeed at least 3 times...
11:20:52 <hodapp> Does Haskell provide a mechanism by which I can get something like [(String, TypeRep)] for an arbitrary record type, with names & types in that list?
11:20:55 * hackagebot pipes-text 0.0.0.16 - Text pipes.  http://hackage.haskell.org/package/pipes-text-0.0.0.16 (MichaelThompson)
11:20:55 <nitrix> That's a good mess right there x] I think I'll use records x]
11:21:33 <napping> hodapp: from a Haskell record type, things like Generics or Data.Data will do it
11:21:40 <napping> assuming it's an instance of the right classes
11:21:48 <napping> If you don't have those instances... maybe TH?
11:22:22 <h-core> so i'm trying to have type Grade = Maybe Int but for some reason I can't get it to work
11:22:23 <h-core> http://lpaste.net/131988
11:22:41 <h-core> i'm thinking maybe Grade becomes a fully qualified type so I can't have Grade a?
11:23:22 <hodapp> napping: can you be a little more specific with Data.Data?
11:23:36 <h-core> but that doesn't work either Grade a = Maybe Int a
11:23:45 <h-core> and wouldn't make sense since Int is Int and not Int a
11:25:18 <merijn> h-core: Oh, the problem is line 17
11:25:26 <merijn> h-core: "type" does not create a new datatype
11:25:28 <kadoban> h-core: What's the actual goal with this? It seems like you have … too many things like Maybe
11:25:32 <merijn> h-core: It creates an alias
11:25:39 <h-core> yes
11:25:48 <merijn> h-core: So it should be "getGrade g s@(School (Just g1) _ s2)"
11:25:49 <h-core> I'm just wondering why I can't ...
11:25:52 <h-core> ohh
11:25:58 <h-core> or could it be Grade a = Maybe a ?
11:26:03 <merijn> h-core: Doesn't matter
11:26:19 <merijn> h-core: "type" just creates a transparent synonym, it doesn't create anything new
11:26:23 <napping> hodapp: Maybe Data.Data can't actually do it
11:26:36 <kadoban> h-core: Like, you have Empty, which is a school, which is kind of like encoding Maybe inside your school type, then you have the School constructor in which everything is optional again. Also your School constructor is recursive? Why?
11:26:38 <merijn> h-core: It only means that you can write "Grade" instead of "Maybe Int", but it's still just "Maybe Int"
11:26:40 <SrPx> Why Data.Tree's API is so lacking? :( no folds, not even map...
11:27:10 <cwraith> SrPx: read the docs
11:27:13 <h-core> merijn, yes i got that part i was just hoping I could refer to it using Grade but I guess that doesn't make sense anyway
11:27:13 <merijn> SrPx: It has both...
11:27:18 <cwraith> SrPx: in particular, don't ignore instance lists
11:27:21 <merijn> SrPx: It's a Foldable/Traversable instance
11:27:22 <h-core> kadoban, because the School data type can contain multiple grades
11:27:25 <merijn> *has*
11:28:11 <h-core> and the redundancy is because i dont know what i'm doing :)
11:28:16 <kadoban> h-core: Then have the constructor take some collection of Grades like a list or a map or … something.
11:28:23 <SrPx> Oh woops... my bad
11:28:44 <h-core> kadoban, and have Grade store both the Int and the [String] of names?
11:29:10 <hodapp> napping: it looks, reading it, like it might be able to, but not sure
11:29:19 <napping> hodapp: after data Rec = Rec { x :: Int, y :: String } deriving (Data,Typeable)
11:29:31 <napping> you can at least do constrFields (head (dataTypeConstrs (dataTypeOf (undefined :: Rec)))
11:29:33 <kadoban> h-core: That sounds possible, yeah.
11:29:35 <napping> to get ["x","y"]
11:29:49 <h-core> ahh ok, maybe this will make it easier to map over
11:30:27 <h-core> or maybe i could just use a data type in Data.Map  and stop reinventing a wheel
11:30:44 <kadoban> h-core: If it was me, I'd probably do something like   data School = School (Map Grade [Name])     , or School could just be a type alias if you want
11:31:50 <h-core> kadoban, yeah that makes sense, I should just be using Data.Map.Map it looks like and maybe type synonym for readability
11:31:58 <napping> hodapp: I don't see how to easily get the actual argument types. GHC.Generics has a more direct representation
11:32:15 <hodapp> napping: thanks for the push in a maybe-viable direction
11:32:17 <kadoban> h-core: Yeah, sounds right.
11:32:18 <h-core> it's too bad you can't type synonym the parts to the right
11:32:25 <h-core> like Tip | Bin
11:32:52 <h-core> thanks kadoban and merijn !
11:34:11 <napping> hodapp: try data Rec = Rec { x :: Int, y :: String } deriving (Generic), with GHC.Generics imported and language DeriveGenerics
11:34:41 <napping> then :kind! Rep Rec and selName (undefined :: M1 S S1_0_0Rec (K1 R Int) ()) and selName (undefined :: M1 S S1_0_1Rec (K1 R Int) ()) will show useful stuff
11:36:08 <napping> I'm not sure what the nice way of getting information from those representation types like S1_0_0Rec is supposed to be, but the "Rep" function does give you all the information you could want
11:39:13 <hodapp> I'd think Typeable could help here somehow, but I don't know
11:44:00 <bennofs> hodapp: you can do that easily with GHC.Generics
11:44:43 <napping> hodapp: Data.Data is the extension of Typeable that covers that kind of stuff
11:44:51 <bennofs> hodapp: with GHC.Generics, you can basically get an AST of your type
11:45:40 <ReinH> shachaf: so (-> r) is a contravariant functor, thus the adjunction is between Hask and Hask^Op?
11:45:55 * hackagebot dbcleaner 0.1.1 - Clean database tables automatically around hspec tests  http://hackage.haskell.org/package/dbcleaner-0.1.1 (sestrella)
11:46:16 <shachaf> (-> r) is the name of a functor : Hask^op -> Hask, and also of a functor : Hask -> Hask^op
11:46:25 <ReinH> shachaf: Yes, that's what I meant to say
11:48:05 <hodapp> bennofs: yeah, it's looking like Generics is closer to what I need as I can't find a way to get types out of Data.Data either
11:48:12 <bennofs> napping: I believe Data.Data does not have record selectors available
11:48:51 <napping> bennofs: It has record selectors, as I showed earlier, I just don't see how to easily get argument types!
11:49:22 <napping> field names: constrFields (head (dataTypeConstrs (dataTypeOf (undefined :: Rec)))
11:49:29 <bennofs> napping: oh didn't know that
11:49:34 <bennofs> :t constrFields
11:49:35 <lambdabot> Constr -> [String]
11:49:35 <shachaf> Those functors are adjoint, which can mean a few different things depending on which definition of adjunction you use.
11:49:47 <ReinH> shachaf: so we have (-> r) : Hask^op -> Hask is the left adjoint and (-> r): Hask -> Hask^op is the right adjoint
11:49:48 <bennofs> :t dataTypeOf
11:49:48 <napping> Maybe some trickery with gunfoldl will let you get the (TypeRep of) the arguments?
11:49:49 <lambdabot> Data a => a -> DataType
11:50:00 <shachaf> They're adjoint both ways, I assume.
11:50:08 <shachaf> Since they're "really" the same functor.
11:50:24 <shachaf> If F -| G, then G^op -| F^op
11:50:27 <ReinH> shachaf: Indeed, but I'm dealing with the adjunction that "lives in" Hask
11:50:41 <shachaf> An adjunction doesn't "live in" a category.
11:50:42 <ReinH> Since I'm trying to construct the Monad in Hask from the adjunction
11:50:56 <shachaf> The comonad is just as important as the monad.
11:50:58 <ReinH> Ok, then Hask is my left-hand category
11:51:05 <shachaf> Especially in this case. :-)
11:51:07 <ReinH> Because I have to pick one arbitrarily
11:51:08 <bennofs> hodapp: I do something similar here: https://github.com/bennofs/hsqml-react/blob/36cc69fb3a3099ae320557e799da8007527888c2/src/Graphics/QML/React.hs#L399 Although the code might be a bit hard to read, since I only extract fields with a given type
11:51:19 <ReinH> But everything I'm about to say would apply to the dual
11:52:10 <edwardk> ReinH: the comonad for that adjunction is the same as the monad in the end, it is a comonad in hask^op
11:52:19 <ReinH> edwardk: I see that, yes
11:53:09 <edwardk> i spent a ton of time way back in the day obsessing over "why can't i find a comonadic cont?!"
11:53:15 <ReinH> heh :)
11:53:20 <edwardk> so when that clicked it clicked hard for me =)
11:53:32 <ReinH> edwardk: I'm approaching it from the other way, so it's obvious ;)
11:53:37 <ReinH> "Oh, they're obviously the same"
11:53:43 <edwardk> yep
11:53:57 <ReinH> edwardk: my task is to construct Cont from the adjunction
11:54:06 <ReinH> iirc
11:54:40 <ReinH> I suppose I can do so by noting the types of the unit and counit and asking djinn to prove it for me, but I doubt that would satisfy shachaf
11:54:42 <edwardk> ok, so compose it, then look at a -> GFa   and GFGF a -> GF a by fmapping FG -> Id
11:55:10 <edwardk> also djinn likes to screw up Cont stuff IIRC
11:55:24 <edwardk> it gets indexed cont right though
11:55:26 <shachaf> djinn works great for Cont.
11:55:32 <shachaf> But the answers are kind of boring.
11:55:37 <edwardk> ah, maybe i'm thinking of another example
11:55:44 <shachaf> It's more interesting to figure out the question.
11:55:56 <shachaf> But shachaf is satisfied either way.
11:56:08 <ReinH> shachaf: hah, "this pleases the shachaf"
11:56:31 <shachaf> If shachaf linked his satisfaction to how or whether people solve problems on IRC, he'd be pretty unhappy.
11:56:41 <ReinH> heh
11:57:04 <ReinH> So the unit is flip id, of course
11:57:14 <ReinH> \x -> ($ x)
11:57:17 <shachaf> What is fmap?
11:57:51 <ReinH> We need (a -> b) -> ((a -> r) -> r) -> ((b -> r) -> r)
11:57:52 <brbblnch> Hi
11:58:09 <shachaf> Right, that's where all that started.
11:58:11 <shachaf> fmap f is (. f)
11:58:38 <ghorn> I have this "Types" module which has most of my data and instance declarations, but it takes way too long to compile (like 20 seconds)
11:58:47 <ReinH> Right, precompose f
11:59:02 <ReinH> which is covariant because a appears in "double negated" positive position
11:59:08 <ghorn> is it horrible to split it up by classes and have a bunch of orphan modules?
11:59:21 <ghorn> like, module Types.OrdInstances where ...
11:59:27 <shachaf> No, fmap f for (-> r) is (. f)
11:59:35 <shachaf> fmap f for (-> r) . (-> r) is (. (. f))
11:59:42 <ReinH> Ah.
11:59:50 <shachaf> Which is where all that really started.
11:59:59 <ReinH> Right, you have to get under both arrows
12:00:18 <shachaf> Anyway, you have the unit and counit.
12:00:25 <ReinH> shachaf: isn't that contramap for (-> r)?
12:00:40 <shachaf> (. f) is contramap f for (-> r)
12:00:45 <ReinH> Ok
12:00:46 <brbblnch> So, in system F, you can define \lneg A as ∀α.A->α *or* A->∀α.α. You can also create terms that act as functions from a term of \lneg A in one form to the other. Is that stronger than simply proving outside of system F that they are equivalent ?
12:00:51 <shachaf> But I called it fmap because it's the arrow mapping part of the functor.
12:01:04 <ReinH> Sure
12:01:11 <shachaf> The unit is an arrow in Hask(a, (a -> r) -> r)
12:01:15 <napping> hodapp: You can get argument types from gunfold after all
12:01:16 <shachaf> What is the counit?
12:01:26 <napping> set c to Const [TypeRep] ...
12:01:50 <ReinH> an arrow in Hask^op(..., a)
12:01:57 <ReinH> where I need to figure out the ...
12:02:05 <ReinH> yes?
12:02:29 <ReinH> Hask(a, (a -> r) -> r) is (a -> (a -> r) -> r) because Hask has internal homs
12:02:32 <joneshf-laptop> so i'm writing a bunch of stuff in latex, and sometimes i find myself reading a line like `λx + y` and thinking, that's a syntax error.
12:02:42 <shachaf> More generally, the unit is an arrow in Hom(A, G (F a)), and the counit is an arrow in Hom(F (G a), A)
12:02:42 <joneshf-laptop> methinkgs i've had haskell on the brain too much lately
12:02:46 <ReinH> right
12:03:03 <shachaf> You know what G (F a) and F (G a) are.
12:03:11 <RickP> if i want division (/) to have type (Num a => a -> a -> a) instead of (Fractional a => a -> a -> a), how do I do that? Doubles are both instances of Fractional and Num, so there has to be a way to switch between the two without losing precision right?
12:03:38 <Cale> brbblnch: Well, what do you mean by "stronger" exactly? That whenever there is an isomorphism between two types, then there must be a corresponding isomorphism between their interpretations in a model?
12:04:09 <shachaf> RickP: You can't make division have that type.
12:04:34 <kadoban> RickP: What is the goal? That sounds weird … and yeah impossible.
12:05:03 <ReinH> shachaf: So I need an arrow in Hask^op((-> r) . (-> r), -)
12:05:34 <shachaf> Hask^op((a -> r) -> r), a)
12:05:39 <RickP> i have an AST and i wanted the standard math operators to work on both Integers and Doubles
12:05:41 <ReinH> Right
12:05:55 <ReinH> Wait, but it's Hask^op
12:06:00 <ReinH> so the unit and counit are the same
12:06:05 <shachaf> Yes.
12:06:20 <Cale> brbblnch: It's certainly nice, when working inside System F, to know what the isomorphism is, rather than to have the meta-theoretical claim that whenever A is derivable from an empty context, then so is B and vice-versa.
12:06:20 <ReinH> Which, in retrospect, is obvious.
12:06:32 <brbblnch> Cale: I don't really know. Another way: If you wanted to prove that those definitions of \neg A are equivalent, would you give this equivalence inside System F, or rather just saying "Given a proof of the first, do these steps and get one of the second" ?
12:06:56 <shachaf> So you have the unit and counit, but you wanted the monad.
12:07:05 <Cale> brbblnch: Well, it depends on what sort of equivalence I wanted them to have.
12:07:10 <shachaf> But you have all the ingredients necessary to make join.
12:07:18 <RickP> so the field that contains the operator has type (Num a => a -> a -> a), which is fine for +,- and * but not /
12:07:35 <brbblnch> Cale: Or for instance, given your isomorphism, I can easily get an isomorphism which is outside of F, right? But the other way around might not always be true
12:07:42 <RickP> if doubles are Num, why can't I convert them to Fractional, divide and convert the result to Num?
12:07:50 <haasn> tfw no GF a
12:08:06 <Cale> brbblnch: But certainly, given that System F is powerful enough to express the equivalence as a polymorphic pair of functions, probably that's a reasonable first thing to do.
12:08:26 <kadoban> RickP: There's no converting involved. Double is an instance of Num and an instance of Fractional. That doesn't help you there.
12:08:27 <ReinH> shachaf: Right, so I can get GFGF -> GF using the counit to take FG -> 1
12:08:36 <brbblnch> Cale: What is a reasonable first thing to do ?
12:09:13 <shachaf> RickP: Num is not a type, it's a property that a type can have.
12:09:21 <ion> RickP: Given that many things are an instance of both Eq and Ord, does that mean one can write compare :: Eq a => a -> a -> Ordering? No, that function will only receive evidence of Eq (or more concretely, a vtable for Eq), it has no way to tell if the value also happens to implement Ord.
12:09:56 <Cale> brbblnch: Define a pair of functions f: ∀A. (∀α.A->α) -> (A->∀α.α) and g: f: ∀A. (A->∀α.α) -> (∀α.A->α) and show that their composite in either order is the identity.
12:10:01 <brbblnch> Cale: The isomorphism you gave says "If there is a proof of ¬¹ A, there is one of ¬² A, and vice versa". Would there be some other form of equivalence ? What are possible sort of equivalences?
12:10:34 <RickP> yeah i'm starting to get it
12:10:54 <ReinH> So (-> r) . (-> r) . (-> r) . (-> r) is...
12:10:54 <shachaf> So how do you write join in terms of unit?
12:11:01 <Cale> System F doesn't have a built-in notion of equality, or else we'd probably want to put that proof of equality inside the system as well.
12:11:10 <ReinH> shachaf: in terms of unit?
12:11:18 <shachaf> In terms of counit.
12:11:26 <brbblnch> Cale: for showing the composite, you would just go and write the composite and reduce until you get the identity, right?
12:11:30 <Cale> yeah
12:11:39 <Cale> Well, after an eta expansion :)
12:11:44 <ReinH> shachaf: phew
12:11:52 <RickP> i mean, if i knew the underlying representation is always a double, i could type cast unsafely, but i get that as the type signatures are right now, the type system thinks I'm not making any sense 
12:12:06 <Cale> oops, just realised I had an extra "f: " there, but you know what I meant
12:12:07 <brbblnch> Cale: Oh, eta, it makes everything one step more complicated
12:12:38 <hodapp> napping: oh, really? I was looking at those functions but I did not start there
12:12:41 <Cale> brbblnch: Of course, you could just set about showing that f (g x) = x and g (f x) = x in the first place, so you don't need to eta expand
12:13:23 <brbblnch> Cale: Assuming I had two types, showed that I could convert proofs as said previously, but didn't have the function for that in system F. Would I lose anything compared to have the function inside F ?
12:13:32 <Cale> brbblnch: Note that having shown this for some particular f and g, you've done something a little stronger than simply constructing functions in either direction between the types
12:14:02 <Cale> brbblnch: Even though that's all that's required to show that they're equivalent as far as what's possible to derive in the system
12:14:15 <mizu_no_oto> RickP: "Num a => a -> a -> a" says "give me two of anything that implements Num, and I'll give you back another value of that type"
12:14:21 <ReinH> shachaf: I have to apply the counit "inside" the computation: \f k -> f (\g -> g k)
12:14:31 <ReinH> er, the continuation
12:14:49 <xenog> Is this the appropriate place to discuss Hackage problems?
12:14:53 <brbblnch> Cale: I'm not sure to understand, what stronger thing have I shown ?
12:14:54 <Cale> xenog: yes
12:14:58 <shachaf> It's asier to figure out when it's more abstract, rather than a mess of (-> r)s.
12:15:02 <shachaf> easier
12:15:08 <mizu_no_oto> RickP: You can also say "(Num a, Fractional a) => a -> a -> a" which means "give me anything that implements both Num and Fractional, and I"
12:15:10 <xenog> I am getting access denied in Hackage.
12:15:13 <mizu_no_oto> "I"
12:15:15 <aaronm04> Hi, what do you all recommend for installing haskell stuff on OS X?
12:15:18 <ReinH> shachaf: well, it's hard to figure out when it's a mess of (-> r)s, that's for sure
12:15:21 <Cale> xenog: To which page?
12:15:33 <shachaf> You have eps : FG ~> 1, and you want to write join : GFGF ~> GF
12:15:33 <xenog> I need to update my json-rpc package. There was an error in the previous version.
12:15:37 <RickP> but i know that my type is only either Int or Double, so there is probably a hackish way of unsafe type casting no? not that i want to do that, i guess i'll work around it
12:15:40 <mizu_no_oto> "I'll give you back another value of that type"  (apparently, I really can't type today)
12:15:57 <RickP> If i make the operators take a fractional, then I can't accept Ints no?
12:16:07 <shachaf> In the usual notation you would write join = GepsF
12:16:15 <Cale> xenog: Are you logged in as Jean-Pierre Rupp?
12:16:18 <xenog> I try to upload either package or candidate.
12:16:23 <shachaf> Haskell takes care of polymorphism for you, so you can just write join = Geps
12:16:23 <xenog> No, I am logged in as XenoGenesis.
12:16:25 <shachaf> What is G?
12:16:36 <joneshf-laptop> RickP, you might be able to have something like `class Division a where mydiv :: a -> a -> a`, `instance Fractional a => Division a where mydiv = (/)`, `instance Integral a => Division a where mydiv = div`, but that'd probably blow up for some othe rinstance that implements both
12:16:36 <xenog> Should I change my name to "Jean-Pierre Rupp"?
12:16:39 <mizu_no_oto> RickP: You can write a function of the type "Double -> Double -> Double"
12:16:42 <Cale> Oh, I guess you're the original uploader
12:16:47 <Cale> That ought to work anyway...
12:16:54 <joneshf-laptop> RickP, or just dont give the generic instances
12:16:59 <michaelt>  XenoGenesis should work
12:17:00 <joneshf-laptop> RickP, only give the concrete instances
12:17:03 <xenog> I am the original uploader.
12:17:10 <Cale> XenoGenesis is listed as a maintainer for json-rpc
12:17:11 <ReinH> F and G are both (-> r)
12:17:13 <Cale> So yeah, it ought to work
12:17:16 <Cale> http://hackage.haskell.org/user/XenoGenesis
12:17:27 <hodapp> napping: that gunfold type signature is making my head spin a little...
12:17:37 <shachaf> What is Geps?
12:17:38 <joneshf-laptop> RickP, `class Division a where mydiv :: a -> a -> a`, `instance Division Double where mydiv = (/)`, `instance Division Int where mydiv = div`
12:17:38 <Cale> Are you trying to upload a version of the package which already exists in the database?
12:17:50 <RickP> joneshf-laptop: they need to accept both Int and Double, so they can't be concrete
12:18:22 <RickP> i'm just trying to make the AST more generic, obviously I can always stick this stuff into an intermediate type which separates Fractional and Num operations
12:18:23 <joneshf-laptop> RickP, i don't follow
12:18:41 <Cale> If the .cabal file gives a version number which is already listed on Hackage, it won't let you upload it.
12:18:44 <xenog> Nope, the version is correct.
12:18:47 <Cale> hmm
12:19:03 <xenog> 0.2.1.6 in both the cabal file and the name of the generated tarball.
12:19:12 <Zemyla> Is there a way to use the bytecode generator built in to GHC in a user-mode program?
12:19:12 <Cale> Maybe send an email to admin@hackage.haskell.org
12:19:18 <ReinH> shachaf: sorry
12:19:22 <xenog> Thank you Cale, will do.
12:19:39 <joneshf-laptop> RickP, if your ast is `data AST a = Foo a | Bar a`, and you want division to work for any a, then you can have `class Division a ...` and then do `astFunc :: Division a => AST a -> AST a`
12:19:54 <kadoban> Zemyla: GHC has bytecode ?
12:19:57 <joneshf-laptop> RickP, or do you want to have division between `Int` and `Double`?
12:20:04 <Zemyla> kadoban: Yeah, it uses it in GHCi.
12:20:27 <michaelt> xenog: but you make it to the upload page and, e.g. upload file doesn't work?
12:20:38 <RickP> ideally i want division between int and doubles automatically
12:20:39 <michaelt> xenog: choose file rather
12:20:50 <xenog> I make it to the upload page, choose file, then it doesn't work.
12:20:52 <RickP> i guess i can always use more types and pattern matching to handle each case separately
12:20:54 <ReinH> shachaf: er, eps is (a -> (a -> r) -> r)?
12:21:48 <shachaf> eps is a natural transformation. It would have that type, expressed as a Haskell function.
12:21:48 <michaelt> xenog: hm, a menu for my filesystem sort of drops down when I press it...
12:22:01 <RickP> i guess once i get to write the evaluation code everything will be clearer
12:22:03 <shachaf> If f : A -> B, what is Gf?
12:22:11 <xenog> I get a file chooser, choose the file, and then I get an error page immediately.
12:22:12 <shachaf> This is a matter of notation.
12:22:21 <ReinH> ((A -> B) -> r)?
12:22:35 <geekosaur> Zemyla, there's no exposed interface for it and most of the internals wouldn't know what to do with it. IIRC the GHC devs would love someone to flesh out the bytecode interface to support external bytecode (and optimization and some other nice things) but nobody has ever (offered to) done it
12:23:41 <michaelt> xenog:  I suppose the little candidate tester doesn't work either https://hackage.haskell.org/packages/candidates/upload
12:23:50 <Cale> brbblnch: Well, from an ordinary logical standpoint about "what is true", the main sort of equivalence you'd care about is simply whether it's possible to get a proof in both directions, i.e. if P |- Q and Q |- P then P and Q are logically equivalent.
12:23:52 <blogle> How do I get a field from a record when the library doesnt expose its constructor?
12:23:53 <xenog> Exactly, I attempted that one too.
12:24:05 <Cale> In any context from which one is provable, then so is the other
12:24:11 <johnw> ReinH: G f is the fmap of G applied to f
12:24:35 <geekosaur> blogle, sometimes you can use some TH or generics tricks, but in general you can't
12:24:36 <Cale> brbblnch: However, in type theories, we often don't just care about what propositions are provable, but *which proofs* they have
12:24:40 <ReinH>  johnw thanks
12:24:44 <kadoban> blogle: If it doesn't expose a way, you can't. That's kind of the point of not exposing the constructors.
12:24:45 <geekosaur> unless the library exposes some other way to do it
12:25:03 <joneshf-laptop> RickP, well you can continue with the type class approach if you want things to be implicitly handled. You just need more parameters in the type class and probably fundeps. but it might not be clear how/why things are happening
12:25:30 <Cale> brbblnch: Bool and the natural numbers and the unit type are logically equivalent, but they're very different from the perspective which regards types as sets
12:25:51 <joneshf-laptop> RickP, and letting the evaluation happen in one place (with explicit conversions) will most likely lead to a cleaner solution
12:25:54 <blogle> yeah unfortunately it doesnt look like the library has a function to get at the value...
12:26:05 <ReinH> So fmap of G is \f -> (. f)
12:26:13 <johnw> ReinH: so instead of ((A -> B) -> r), the type would be...
12:26:55 <ReinH> (r -> B)?
12:26:59 <ReinH> no
12:27:16 <johnw> if f is A -> B, and G is (-> r), then fmap f for G is
12:27:43 <Cale> brbblnch: But if we have mappings in both directions which compose to the identity, then there will be a bijective correspondence between the values of one type and the values of the other.
12:28:46 <ReinH> A -> r?
12:28:58 <johnw> (A -> B) -> ? -> ?
12:29:03 <ReinH> Oh.
12:29:26 <ReinH> (A -> B) -> (B -> r) -> a -> r?
12:29:36 <ReinH> s/a/A
12:29:49 <Cale> brbblnch: Still here?
12:30:37 <brbblnch> yeah
12:30:46 <brbblnch> Cale:(i'm slow though)
12:31:06 <athan> Would mapM_ work faster over a vector, or a list? (Or does that have nothing to do with it?)
12:31:28 <ReinH> Hmm
12:31:38 <ReinH> :t \f -> (. f)
12:31:38 <lambdabot> (a -> b) -> (b -> c) -> a -> c
12:31:41 <brbblnch> Cale: Bool, Nat, unit type are logically equivalent because they all have proofs, right?
12:31:41 <johnw> athan: that question sort of conflates two issues
12:31:49 <srhb> athan: Doesn't really have anything to do with it. Also it may very well depend on what you're doing. Ie. I think there may indeed be a difference in allocation, but...
12:31:53 <johnw> athan: after the compiler is done with your code, a list is not always a list
12:32:07 <athan> I had a feeling :) Thanks guys
12:32:35 <haskell762> Hi
12:32:40 <haskell762> Is anyone here?
12:32:46 <srhb> haskell762: Many.
12:32:57 <haskell762> Can i get a help
12:33:02 <ion> 1594
12:33:04 <srhb> Just ask, no need to ask to ask :)
12:33:15 <ReinH> johnw: I'm missing something
12:33:23 <johnw> ReinH: what is that?
12:33:37 <shachaf> I was away for a bit.
12:33:38 <ReinH> johnw: I don't know! I'm not making the connection.
12:33:42 <ReinH> shachaf: np
12:33:52 <haskell762> i am just starting to learn this language so i have many questions
12:33:53 <haskell762> like
12:34:02 <haskell762> in LISP there was possibility
12:34:04 <johnw> I haven't been following enough to know which connection you're expected to be making at this point
12:34:16 <ReinH> johnw: well, I'm trying to answer your question atm :)
12:34:17 <haskell762> to call with optional parameters
12:34:19 <srhb> haskell762: Less <enter> would be nice :P
12:34:21 <johnw> you got it right
12:34:26 <ReinH> Oh, phew
12:34:33 <athan> Alright guys, how would you speed this up? http://lpaste.net/131998 -- SPOILER - it's project euler #23 :)
12:34:33 <shachaf> So if eps_A : ((A -> R) -> R) <- A, then Geps_A : G((A -> R) -> R) <- GA
12:34:39 <srhb> haskell762: There are various ways of doing that in Haskell. Many function have a number of parameters that are Maybe Something
12:34:45 <haskell762> like "calc (a b &optional (s 0) (pw nil))
12:34:47 <ReinH> shachaf: ah
12:34:49 <ion> haskell762: You’ll probably wrap the parameter in a Maybe so the invoker can use the forms “Just a” or “Nothing”.
12:34:53 <srhb> haskell762: So if you don't want to specify them, we just pass Nothing for that parameter
12:35:19 <srhb> haskell762: To be absolutely clear though, a function always has an exact number of parameters to be fully applied (currying aside)
12:35:25 <shachaf> And Geps_FA : G((FA -> R) -> R) <- GFA
12:35:26 <shachaf> I guess.
12:35:47 <johnw> whoa, not like you to guess, shachaf!
12:35:52 <haskell762> can u give some example if isnt hard for u
12:35:53 <johnw> this is an exercise, not a guessercise :)
12:36:07 <ion> > let f optX = "foo" ++ fromMaybe "default" optX ++ "bar" in (f (Just "hello"), f Nothing)
12:36:08 <lambdabot>  ("foohellobar","foodefaultbar")
12:36:12 <shachaf> I guess all the time.
12:36:19 <Cale> brbblnch: From an empty context, yes.
12:36:23 <srhb> haskell762: foo mandatory1 optional1 = case optional1 of Nothing -> Default case; (Just a) -> Something was specified for the second parameter
12:36:31 <shachaf> Anyway, so join = Geps, i.e. (. eps)
12:36:35 <shachaf> Except eps = return
12:36:36 <Cale> brbblnch: You can just use constant functions to map between them, for example.
12:36:38 <shachaf> So
12:36:41 <shachaf> :t let { unit :: a -> (a -> r) -> r; unit x = ($ x) } in let { join :: ((((a -> r) -> r) -> r) -> r) -> (a -> r) -> r; join = (. unit) } in join
12:36:42 <lambdabot> ((((a -> r) -> r) -> r) -> r) -> (a -> r) -> r
12:36:42 <joneshf-laptop> srhb, wasn't there a thing that allowed actual optional arguments?
12:36:43 <ReinH> so G((A -> R) -> R) is, er,  ((A -> R) -> R) -> (R -> R') -> (A -> R) -> R'?
12:36:48 <srhb> joneshf-laptop: Yes.
12:36:50 <Cale> brbblnch: Of course, those aren't the only maps
12:36:59 <johnw> :t \f -> (. (. f))
12:36:59 <srhb> joneshf-laptop: (But I don't think there's any need to bring that up just yet) :)
12:37:00 <lambdabot> (a -> b) -> ((a -> c1) -> c) -> (b -> c1) -> c
12:37:01 <shachaf> There's no R' here. Everything is the same R.
12:37:12 <ReinH> Ok
12:37:18 <ReinH> And my parens are wrong. Why are my parens wrong...
12:37:20 <joneshf-laptop> srhb, is it still the case that the function has an exact number of parameters then?
12:37:30 <srhb> joneshf-laptop: Yes, the trickery is in the type system
12:37:40 <srhb> joneshf-laptop: But you have a number of n-adic function for various ns
12:37:57 <srhb> That's the most common way anyway
12:38:14 <ReinH> Hmm, I'm not sure why my parens are wrong.
12:38:19 <hodapp> :t gmapQ
12:38:21 <lambdabot> Data a => (forall d. Data d => d -> u) -> a -> [u]
12:38:32 <brbblnch> Cale: That's rather interesting. But I'm still not sure what those new types (lists, nat, bool) actually do in System F, or rather what they are used to, where they fit in the rest
12:39:06 <ReinH> shachaf: Anyway, that looks like the right number of -> r
12:39:23 <Cale> brbblnch: Well, if you've done much programming, I'm sure you can think of uses for lists and numbers and booleans :)
12:39:27 <srhb> joneshf-laptop: It's usually fundeps or type families anyway, so technically not Haskell. :)
12:39:40 <h-core> so is there a Data.Map that can have multiple values attached to a single key?
12:39:42 <shachaf> What is a pirate's favorite monad?
12:39:47 <srhb> ArrM?
12:39:54 <h-core> i've looked at Data.Array but it seems like overkill
12:39:59 <ion> h-core: Map k [v]
12:40:02 <Cale> brbblnch: An extension of System F is used as an intermediate language in GHC.
12:40:06 <kadoban> h-core: There's lists, tuples, record types, etc.
12:40:20 <ReinH> shachaf: I see what you did there
12:40:38 <brbblnch> Cale, I don't mean they have no "use" 
12:40:49 <ReinH> shachaf: thanks for walking me through it
12:41:00 <srhb> joneshf-laptop: http://okmij.org/ftp/Haskell/polyvariadic.html -- if you're interested
12:41:09 <srhb> haskell762: you too ^^^
12:41:13 <brbblnch> Cale, But I haven't seen any proof about them or using them yet, or haven't seen how computing with them works
12:41:19 <shachaf> Walking you through it in absentia.
12:41:30 <shachaf> It's a monad, and yet it's Cont r a variant!
12:41:49 <johnw> *cough*
12:41:56 <brbblnch> Cale: In untyped \lambda calc, I get the idea of nat, bool, etc. What do system F change about them ? How is for instance nat addition related to a proof ?
12:42:16 <kadoban> h-core: What resource(s) are you using to learn haskell? Have you looked at https://github.com/bitemyapp/learnhaskell ?
12:42:22 <brbblnch> Cale: But I'm gonna go to bed. So, as usual, thank you for the help
12:42:39 <Cale> Whenever I say "proof" in this context, unless I'm talking about a meta-theorem about the system, I typically mean the same thing as "term"
12:42:47 <hodapp> how does one declare a type to lambdabot again?
12:42:53 <ion> hodapp: @let
12:42:57 <h-core> ion, i can't seem to get Map to work with [v], v is fine but [v] doesn't seem to work right
12:43:07 <Cale> brbblnch: Logically, addition of natural numbers is quite boring.
12:43:12 <h-core> and I can't insertWith (:) k v
12:43:21 <Cale> brbblnch: As any function A -> A -> A would be
12:43:31 <athan> johnw: Wow, switching back to lists cut the time and space to 1/3!
12:43:34 <hodapp> ion: I keep getting syntax errors with 'let'.
12:43:45 <Cale> brbblnch: It's only interesting once you start caring about which values you're getting.
12:43:47 <h-core> kadoban, a combination of LYAH, exercism.io and I was doing cis194 and project euler but i stopped those last 2 things
12:43:55 <h-core> i happen to really like exercism.io
12:43:56 <hodapp> I've seen it done before but my searches are not getting me anywhere
12:44:01 <brbblnch> kadoban: I see LYAH recommended everywhere, how is it it isn't the first lecture on there ?
12:44:18 <h-core> kadoban, but thanks for the link, i've seen that resource before
12:44:20 <srhb> brbblnch: The author is strongly opposed to LYAH
12:44:27 <ion> h-core: Try insertWith (++) k [v]
12:44:32 <kadoban> h-core: You should do cis194. exercism is great, but it's not how to learn a language, it's how to learn good style once you already know the language, IMO.
12:44:42 <hodapp> ion: could you show an example of what you mean with 'let'?
12:44:42 <geekosaur> @let data Foo = Foo String
12:44:43 <lambdabot>  Defined.
12:44:46 <joneshf-laptop> srhb, what counts as haskelll, just Haskell2010?
12:44:56 <srhb> joneshf-laptop: I suppose so.
12:44:57 <hodapp> geekosaur: oh, hrmph, it's not liking my records
12:45:00 <h-core> ion, but then i can't differentiate between different parts of list, especially ...wait
12:45:01 <h-core> ...no
12:45:02 <srhb> joneshf-laptop: Or Haskell98 or an earlier version
12:45:03 <h-core> im wrong
12:45:07 <tfft> why use haskell?
12:45:07 <brbblnch> Cale: you mean logically interesting?
12:45:09 <kadoban> brbblnch: LYAH isn't very good, IMO. In particular, it has no exercises and doesn't really leave you with an ability to actually do anything in haskell once you're done.
12:45:14 <srhb> tfft: For many smarts.
12:45:21 <tfft> ?\
12:45:21 <lambdabot> Maybe you meant: v @ ? .
12:45:42 <srhb> tfft: It's fun, it's flexible, it allows you to reason about programs in a way few (if any) other languages do.
12:45:42 <tfft> what?
12:45:53 <brbblnch> kadoban, srhb: Interesting, thanks
12:45:54 <kadoban> h-core: project euler … is probably not the best. It's more about number theory and math than it is about programming.
12:45:56 <tfft> legit
12:45:58 <h-core> brbblnch, kadoban is right a bout a lot of that but i think LYAH is good to have while you do other things
12:46:03 <ion> hodapp: Perhaps run the command on the channel so we can see the error.
12:46:04 <h-core> kadoban, lol yeah that's why i stopped euler
12:46:15 <joneshf-laptop> srhb, also, I was meaning this: http://hackage.haskell.org/package/optional
12:46:17 <srhb> brbblnch: And while I don't agree with that point, I think CIS194 is the best introduction I've seen.
12:46:21 <joneshf-laptop> srhb, took a while to find :)
12:46:22 <h-core> but haskell did make it easy to transliterate math proofs i didn't understand into Haskell
12:46:27 <tfft> and you guys are sick of python, java, C etc?
12:46:27 <hodapp> wait, how are @let and > let different?
12:46:38 <h-core> tfft, just different strengths to each language
12:46:43 <brbblnch> What's the required level for CIS194?
12:46:55 <Cale> brbblnch: No, logically, addition is boring. Showing that N implies (N implies N) is not interesting.
12:46:59 <Hijiri> brbblnch: any coding experience
12:47:00 <srhb> joneshf-laptop: Ok, thanks :)
12:47:10 <srhb> tfft: Not really. Some of them.
12:47:19 <srhb> tfft: But I enjoy working in Haskell much more, for most things.
12:47:21 <ion> hodapp: “@let” inserts a line into L.hs, the file lambdabot’s “> ” thing loads, “> ” just evaluates an expression.
12:47:22 <Hijiri> in any language at all
12:47:37 <h-core> brbblnch, these videos go along with cis194 https://github.com/bfpg/cis194-yorgey-lectures
12:47:38 <brbblnch> Cale: Ok, so the types you construct (booleans, lists, nats) aren't really logically interesting anymore, you sort of get out of proofs and such ?
12:47:39 <Cale> brbblnch: No, logically, addition is boring. Showing that N implies (N implies N) is not interesting.
12:47:55 <h-core> brbblnch, you can watch them then go do that lecture
12:47:57 <tfft> what if yer fed up with haskell, Brainfuck?
12:48:01 <hodapp> @let data FooRec = FooRec { foo :: Int, bar :: String }
12:48:02 <lambdabot>  Defined.
12:48:11 <srhb> tfft: For me, personally? Idris, Agda, ...
12:48:18 <Cale> brbblnch: But once you care about *which proof of it you have*, then it's interesting again
12:48:20 <h-core> tfft, INTERCALC
12:48:23 <srhb> tfft: Again it depends what I have to do!
12:48:24 <merijn> tfft: Idris ;)
12:48:28 <hodapp> > gmapQ (dataTypeRep . dataTypeOf) $ FooRec { foo = 10, bar = "test" }
12:48:29 <lambdabot>      No instance for (Data FooRec) arising from a use of ‘gmapQ’
12:48:30 <lambdabot>      In the expression: gmapQ (dataTypeRep . dataTypeOf)
12:48:30 <lambdabot>      In the expression:
12:48:46 <tfft> what kind of jobs do you guys have?
12:48:49 <SrPx> So, when you told me to use kinds to shorten stuff like "(Epsilon a, Metric f, Ord a, Num a, Fractional a, RealFrac a, Floating a)" what did you really mean? Is it bad if I create a single typeclass, "Number", for anything that is a number?
12:48:51 <kadoban> h-core: Ehh, those videos don't really go along with the class, they were based on it. I don't know if they're any good or not.
12:48:52 <hodapp> oh, bleah, forgot my 'deriving ...'
12:48:55 <brbblnch> h-core: ok, thanks
12:49:04 <srhb> SrPx: I'm pretty sure it was Kind aliases
12:49:07 <hodapp> tfft: design engineer at a startup
12:49:16 <brbblnch> Well, good night all!
12:49:24 <haskell762> thx but it strange anyway) ...for example how write something like this:        f x y = x*x + y*y    in console i put "f 2 3" but i want to set "y" as optional (equals 0) for putting "f 2" how to do it
12:49:26 <srhb> SrPx: With ConstraintKinds
12:49:30 <srhb> Er, context aliases with that*
12:49:45 <hodapp> @let data FooRec_ = FooRec_ { foo :: Int, bar :: String } deriving (Data, Typeable)
12:49:46 <lambdabot>  .L.hs:154:24:
12:49:47 <lambdabot>      Multiple declarations of ‘foo’
12:49:47 <lambdabot>      Declared at: .L.hs:152:22
12:49:49 <merijn> haskell762: You can't, there's no such thing as "optional" arguments in haskell
12:49:54 * hodapp gives up arguing with the bot
12:49:58 <ion> haskell762: You can make it accept a “f 2 Nothing”.
12:49:59 <srhb> SrPx: https://downloads.haskell.org/~ghc/7.8.2/docs/html/users_guide/constraint-kind.html
12:50:16 <merijn> haskell762: The usual approach would be to change the order of f's arguments and partially apply it
12:50:21 <h-core> kadoban, i found them useful at least, especially when first starting and having no clue what i'm doing
12:50:26 <h-core> which i still may have no clue
12:50:33 <srhb> merijn: They want a default value for y
12:50:40 <srhb> Oh
12:50:43 <srhb> I get what you were saying now
12:50:45 <srhb> Sorry.
12:50:48 <Cale> haskell762: You generally don't.
12:50:57 <merijn> > let f y x = x*x + y*y; defaultF = f 0 in (defaultF 3, f 3 2)
12:50:57 * hackagebot acme-everything 2015.5.4 - Install everything.  http://hackage.haskell.org/package/acme-everything-2015.5.4 (quchen)
12:50:59 <lambdabot>  (9,13)
12:51:17 <merijn> quchen: So you're responsible for that travesty? >.>
12:51:32 <quchen> merijn: It has a much smaller dependency footprint now
12:51:41 <ion> Oh, it uses transitive dependencies now. :-D
12:51:50 <merijn> quchen: Very reassuring >.>
12:52:04 <merijn> quchen: Does it also depend on all possible versions?
12:52:08 <quchen> The dependency footprint is scaringly small now, I have to say
12:52:22 <merijn> quchen: Just lens? ;)
12:52:22 <quchen> merijn: No, it's a fairly naive implementation that just takes the newest version of each package
12:52:28 <Cale> haskell762: It's possible to do that sort of thing (functions which accept an undetermined number of arguments) by defining a type class with a recursive instance for functions as well as an instance for their final result type.
12:52:32 <srhb> What are transitive dependencies?
12:52:33 <quchen> merijn: No, lens isn't necessary, as there are packages that depend on it :-)
12:52:45 <srhb> Ah
12:52:46 <srhb> :|
12:53:07 <ion> quchen: I’m pretty sure nothing depends on quadratic-irrational for instance and i don’t see it in the list.
12:53:08 <Cale> haskell762: or of course, you could in this case just have two instances
12:53:22 <srhb> quchen: Do you have a tool for determining the minimum amount of packages required to get all of Hackage? :P
12:53:38 <srhb> acme-whatEverything, perhaps
12:53:58 <SrPx> srhb: got it, cool. Ty!
12:54:00 <quchen> srhb: Some time ago I wrote a simple (hacky, small, dirty) program to get me the dependency tree of Hackage for exploratory reasons, I just modified it a bit to give me this output
12:54:02 <bernalex> quchen: what is the point of acme-everything?
12:54:10 <srhb> quchen: Right :P
12:54:14 <ion> bernalex: To install everything, of course.
12:54:19 <merijn> bernalex: What's the point of any acme package? :p
12:54:24 <kadoban> acme-* is supposed to have a point?
12:54:26 <bernalex> ion: what is the point of installing everything?
12:54:27 <srhb> quchen: It should totally be on Hackage too. acme-everything-meta: "A tool for generating acme-everything"
12:54:28 <SrPx> srhb: type Numeric a = (Num a, Floating a, Fractional a, RealFloat a, Metric a, Ord a, ...) <- is that acceptable?
12:54:34 <quchen> bernalex: You can now write packages that depend only on base and acme-everything, which saves you a lot of worries about which dependency you need to install
12:54:40 <srhb> SrPx: If that alias makes sense for your application, sure.
12:54:46 <merijn> bernalex: The ACME packages are jokes... >.>
12:54:48 <quchen> srhb: That'll be the next version. 
12:54:53 <srhb> quchen: :-)
12:54:57 <bernalex> merijn: I know. I'm asking because it does quite genuinely seem like it could be useful.
12:55:06 <quchen> srhb: FWIW this is a more useful application of the program. https://github.com/quchen/hackage-graph
12:55:16 <merijn> bernalex: I'm pretty sure it's impossible to install due to unsolvable constraints :p
12:55:17 <SrPx> well, many functions use different constraints so that would make some of them request more than needed... but I guess that is ok for the readability value, right?
12:55:19 <srhb> quchen: Useful is overrated!
12:55:34 <bernalex> merijn: ah. that's too bad. not a very good troll then.
12:55:40 <haskell762> ok thanks to all!
12:55:52 <srhb> SrPx: I don't feel comfortable making statements like that. I feel like you should have a constraint that logically encapsulates what your types "can do"
12:55:54 <quchen> bernalex: It's more born out of satire rather than trolling.
12:56:01 <srhb> If that's not possible, you probably need restructuring, but ymmv
12:56:23 <bernalex> quchen: if it's satire, then it's quite bad satire. I also found acme-php to be rather weak. acme-safe otoh was very good.
12:56:32 <hodapp> > dataTypeOf (6 :: Uint16)
12:56:33 <srhb> bernalex: acme-php is my favourite!
12:56:33 <lambdabot>      Not in scope: type constructor or class ‘Uint16’
12:56:33 <lambdabot>      Perhaps you meant ‘Int16’ (imported from Data.Int)
12:56:36 <quchen> bernalex: Okay
12:56:42 <hodapp> > dataTypeOf (6 :: Word16)
12:56:43 <lambdabot>  DataType {tycon = "Data.Word.Word16", datarep = IntRep}
12:56:44 <merijn> acme-php is only funny if you look at the source :p
12:56:47 <bernalex> srhb: I found it a bit lacking.
12:56:51 <srhb> :P
12:56:56 <srhb> There's no accounting for humor I guess
12:56:57 <bernalex> merijn: I did. it's funny. but there's room for more.
12:57:08 <hodapp> so 'tycon' is a string... I guess I can match on that but that seems to reek of stringly-typed programming >_>
12:57:09 <bernalex> acme-safe's fromJust is just pure class though.
12:57:18 <merijn> bernalex: I'm sure pull requests are welcome ;)
12:57:34 <hodapp> don't understand why I can't get a type representation like from Typeable
12:57:38 <merijn> bernalex: That's the one that returns Maybe, right? :)
12:57:44 <bernalex> merijn: yep
12:57:47 <ion> I’m a fan of Algorithm.Gutenberg.Fibonaccis.lastFib from gutenberg-fibonaccis
12:58:13 <quchen> ion: fix nextFibo?
13:00:16 <quchen> ion: You seem to be correct about quadratic-irrational. The problem is that debugging this thing is a bit hard. If you need a more explicit installation of everything, try the older version of the package.
13:04:36 <bennofs> hodapp: haven't been reading the backlog, what do you expect to get instead of a string?
13:05:04 <hodapp> bennofs: something like a Data.Typeable.TypeRep perhaps
13:05:19 <hodapp> maybe I have to go to GHC.Generics for this, I don't know
13:05:39 <Aruro> how to use maxBound on Int?
13:05:52 <Aruro> :t maxBound
13:05:53 <srhb> > maxBound :: Int
13:05:53 <lambdabot> Bounded a => a
13:05:54 <lambdabot>  9223372036854775807
13:05:58 * hackagebot stackage-cli 0.1.0 - A CLI library for stackage commands  http://hackage.haskell.org/package/stackage-cli-0.1.0 (DanBurton)
13:06:06 <Aruro> heh :)
13:06:09 <hodapp> > (maxBound :: Word16)
13:06:11 <lambdabot>  65535
13:06:26 <Aruro> (maxBound :: Integer)
13:06:32 <Aruro> > (maxBound :: Integer)
13:06:33 <lambdabot>      No instance for (Bounded Integer) arising from a use of ‘maxBound’
13:06:33 <lambdabot>      In the expression: (maxBound :: Integer)
13:06:39 <srhb> Aruro: Not bounded :)
13:06:40 <Aruro> > (maxBound :: Int)
13:06:41 <lambdabot>  9223372036854775807
13:06:47 <Aruro> srhb: indeed :)
13:06:48 <hodapp> Integers aren't bounded
13:07:07 <hodapp> > (maxBound :: Bool)
13:07:09 <lambdabot>  True
13:07:10 <hodapp> HAH
13:07:25 <ReinH> booleans form a lattice
13:07:38 <ion> Someone should write acme-integer-maxbound which does a binary search for the maximum Integer your computer can hold without malloc failing.
13:07:40 <ReinH> > max True False
13:07:42 <lambdabot>  True
13:08:02 <Aruro> > (maxBound :: Char)
13:08:03 <lambdabot>  '\1114111'
13:08:07 <Aruro> what is that?
13:08:12 <ReinH> The largest Char
13:08:28 <Aruro> and which symbol it is?
13:08:29 <ion> > hex # ord maxBound
13:08:30 <lambdabot>  "10ffff"
13:08:33 <ion> U+10FFFF
13:08:34 <ReinH> It isn't necessarily a symbol
13:08:40 <ion> Probably unallocated.
13:08:41 <ReinH> Char includes unprintable characters
13:08:50 <happy0> > concat "yoyoyoyoyoyo"
13:08:51 <lambdabot>      Couldn't match type ‘Char’ with ‘[a]’
13:08:51 <lambdabot>      Expected type: [[a]]
13:08:51 <lambdabot>        Actual type: [Char]
13:09:02 <happy0> > concat repeat $ "yoyoyoyoyoyo"
13:09:03 <lambdabot>      Couldn't match expected type ‘[Char] -> t’ with actual type ‘[a0]’
13:09:03 <lambdabot>      The first argument of ($) takes one argument,
13:09:03 <lambdabot>      but its type ‘[a0]’ has none
13:09:10 <happy0> > concat repeat  "yoyoyoyoyoyo"
13:09:11 <lambdabot>      Couldn't match expected type ‘[Char] -> t’ with actual type ‘[a0]’
13:09:11 <lambdabot>      The function ‘concat’ is applied to two arguments,
13:09:11 <lambdabot>      but its type ‘(a0 -> [a0]) -> [a0]’ has only one
13:09:18 <happy0> sorry, i'll stop ;x
13:09:22 <ion> Aruro: http://unicode.org/charts/PDF/U10FF80.pdf
13:09:23 <cite-rea1er> U+10FFFF is a noncharacter.
13:09:24 <kadoban> happy0: You can PM lambdabot
13:09:45 <cite-rea1er> ion: You win the race this time.
13:09:52 <happy0> haha
13:10:00 <kazagistar> > (maxBound :: Maybe Bool)
13:10:02 <lambdabot>      No instance for (Bounded (Maybe Bool))
13:10:02 <lambdabot>        arising from a use of ‘maxBound’
13:10:02 <lambdabot>      In the expression: (maxBound :: Maybe Bool)
13:10:04 <hodapp> what looks odd to me is that Data.Data seems to be using Typeable under the hood, but I have no apparent way to get at a TypeRep
13:10:11 <kazagistar> aw
13:15:23 <Aruro> ion: ty
13:15:58 <Aruro> guys, where is exact definition of '=' symbol in haskell report? or its part of let expression?
13:16:07 <Aruro> could not find it
13:16:36 <Aruro> report definitely missing clear and one page representation of all symbols like ! and ~, they are scattered along text.
13:16:41 <erisco> if you have some   f :: Map k v   what I want is, for some r, a   x :: r k   s.t.   lookup x f :: v   and lookup is total
13:17:54 <erisco> i.e. I want to have a reference to a key in a particular map, one that I can be guaranteed will give me back a value if I look it up
13:19:09 <srhb> Aruro: I don't understand what you mean by its definition. Do you mean how Haskell program structure is defined? If so, see chapter 2 and 4
13:19:23 <Cale> erisco: I'm not sure I understand your question. That looks like a type error.
13:19:33 <Cale> Unless the type of lookup isn't the usual one
13:19:41 <Cale> I guess it's not?
13:19:44 <erisco> Cale it is not the usual one
13:20:02 <napping> hodapp: yeah, those types are kind of strange
13:20:16 <Cale> So what you're saying is that you want to reflect the domain of the Map in its type
13:20:19 <hodapp> napping: it's just odd to me that it's only strings
13:20:24 <srhb> Aruro: But = means different things in different contexts, so perhaps it's easier to specify exactly what you mean first.
13:20:49 <hodapp> napping: not sure whether to go all the way to Generics, or just match over strings (it's going to be a limited set of data types I actually handle)
13:20:58 * hackagebot stackage-setup 0.0.0 - An executable for downloading a Haskell setup  http://hackage.haskell.org/package/stackage-setup-0.0.0 (DanBurton)
13:21:14 <erisco> Cale, I do not want a type list of all the keys, that would not help me
13:21:36 <Cale> erisco: That's the only way you could tell that any particular key belongs to the map at compile time.
13:21:56 <Aruro> srhb: ok i found it in 2.4 under reserved operators
13:21:59 <Hijiri> you could use refinement types
13:22:06 <Aruro> but no extensive discussion about it
13:22:32 <Cale> erisco: If insertions into the map don't change the type of the map, then there's no way for the type of lookup to distinguish a Map which has the key from one which doesn't.
13:23:14 <erisco> Cale so of course insertions should change the type
13:23:17 <napping> hodapp: http://lpaste.net/132001
13:23:38 <napping> that gets argument types of a constructor as TypeRep
13:24:05 <Cale> erisco: and the type of the Map somehow has to carry the information of which keys are available
13:24:39 <napping> hodapp: a solution with GHC.Generics would also be more strongly typed
13:24:48 <Cale> erisco: Otherwise, how does lookup's type constrain the key?
13:25:43 <Cale> erisco: If the information isn't represented in the type, then it's not available at compile time when you need it in order to be certain that the value is there.
13:25:59 * hackagebot stackage-sandbox 0.1.0 - Work with shared stackage sandboxes  http://hackage.haskell.org/package/stackage-sandbox-0.1.0 (DanBurton)
13:26:01 * hackagebot stackage-cabal 0.1.0 - A CLI executable for cabal-based stackage commands  http://hackage.haskell.org/package/stackage-cabal-0.1.0 (DanBurton)
13:26:25 <Cale> erisco: Of course, trying to constrain things at the type level in this way is quickly going to make you wish that you had dependent types
13:26:46 <hodapp> napping: thanks for the paste... going to go try to understand it
13:28:24 <hodapp> napping: ah, not sure how you figured out gunfold, but thanks
13:28:29 <hodapp> I could not make heads or tails of it
13:28:42 <erisco> Cale I do not know much about linear typing, but from the vague sense I have of it I think something related could help
13:28:49 <napping> There's a paper on it and stuff. It is pretty tricky to define anything in terms of it, yes.
13:29:07 <hodapp> what paper is that?
13:29:09 <Cale> I don't think linearity is the issue here
13:29:44 <erisco> well, doesn't matter, Haskell doesn't offer it anyways
13:29:48 <Cale> Linear types are useful if you want to implement things like insertion using destructive mutation of the tree structure
13:29:59 <napping> that is a touch unclear - the "Scrap your boilerplate" is actually (part of) a paper title
13:30:01 <Cale> They don't help you to know which keys are in the map
13:30:20 <erisco> yes but here is why
13:30:21 <Cale> Just that any reference to the map is used in exactly one location.
13:31:14 <Cale> My recommendation would be to not attempt to encode this information in the type system, if you're writing your program in Haskell and not Agda or Coq or Idris
13:31:29 <erisco> you could have a function  mkref :: Map k v -> k -> Maybe (Ref k)   the problem is that if we have   lookup :: Ref k -> Map k v -> v    it cannot verify the reference is to the correct map
13:32:59 <erisco> so you need a way to make new (empty) maps which are unique (by type)
13:33:13 <erisco> and then linearity so that old values of those maps are not reused
13:35:20 <erisco> so if there was some magic unique type u then you could have   insert :: k -> v -> Map u k v -> (Ref u k, Map u k v);    lookup :: Ref u k -> Map u k v -> v
13:35:40 <erisco> not sure what typical notation is for linear types, but insert would have to invalidate the old map as you'd expect
13:35:43 <Aruro> is it possible to specify ghci options similar to OPTIONS_GHC  in the head of the file?
13:35:59 * hackagebot stackage-cli 0.1.0.1 - A CLI library for stackage commands  http://hackage.haskell.org/package/stackage-cli-0.1.0.1 (DanBurton)
13:36:15 <Aruro> like {-# OPTIONS_GHCi +s~ #-}
13:36:15 <erisco> Cale does that make some sense?
13:36:24 <dolio> Linear types aren't really great for what you're talking about, I think.
13:36:36 <dolio> You don't want creating a reference to 'use up' the map.
13:36:47 <srhb> Aruro: I think the syntax in that file is similar to what it is inside ghci
13:36:57 <srhb> Aruro: So :set -XConstraintKinds for instance
13:36:58 <erisco> dolio the insert makes a reference and updates the map
13:37:04 <dolio> And inserting something doesn't result in keys getting removed, so there's no reason to invalidate the references when you do that, for instance.
13:37:26 <hodapp> huh, this is the first I've seen this (undefined :: FooType) convention also
13:37:31 <erisco> yes there is otherwise you can use the reference on the old map and crash your program
13:37:35 <hodapp> usually I just see people using a proxy
13:37:44 <Cale> hodapp: Proxy is the new way
13:38:04 <Aruro> srhb: i mean i want to set ghci optiont in .hs file itself :)
13:38:13 <napping> hodapp: Data.Data is the old way
13:38:19 <erisco> which is entirely what I'd like to see avoided
13:38:33 <napping> GHC.Generics is better, if you don't mind depending on GHC
13:38:49 <Cale> erisco: Well, when you insert a key/value pair, any key which belonged to the old map also belongs to the new one.
13:38:50 <erisco> the options which do work in Haskell are a) prove you don't lookup keys which don't exist before you fromJust or b) do everything in the Maybe monad
13:39:48 <erisco> doing everything in the Maybe monad has negative value though, because there is no sensible treatment for error and worse the site becomes hidden
13:39:52 <hodapp> napping: it just looks a little heavy-handed for what I need
13:40:08 <erisco> Cale that's right
13:40:29 <Cale> erisco: There's a third option
13:40:46 <Cale> erisco: Use a case expression to discriminate on the result of every lookup.
13:41:03 <Cale> erisco: You can then handle the failure in whatever way is appropriate to that particular failure.
13:41:05 <erisco> that is the same as using the Maybe monad everywhere, just different syntax
13:41:10 <Cale> Nope
13:41:21 <Cale> It's different because you're not automatically propagating failures.
13:41:27 <Cale> You're handling them immediately.
13:41:28 <erisco> well, okay, well if you use  error "f'd up here"  as the Nothing case then sure
13:41:29 <dolio> If what you want is 'inserting' to give you a 'proof' that you can read some linearly used map, why not just use ST?
13:42:24 <napping> hodapp: generics-sop might be nicer
13:42:55 <Cale> erisco: There's the trick used by hetero-map as well: http://hackage.haskell.org/package/hetero-map-0.21/docs/HeteroMap-Map.html
13:42:57 <erisco> Cale my point with (a) was that you'd get a crash with a line number, so the explicit case statement at best lets you give a better error message (which may be valuable, yes)
13:42:59 <hodapp> napping: I feel like the Data.Data solution does all I need so I may stick with it for now
13:43:22 <Cale> Of course, this module is not particularly efficient, it's a toy implementation.
13:43:51 <blogle> geekosaur, you around?
13:44:07 <Cale> I think in order to make it efficient, you might need type-level Ord.
13:44:21 <erisco> compile efficiency you mean?
13:44:25 <geekosaur> vaguely
13:44:44 <Cale> Well, you might be able to get runtime efficiency without compile time efficiency without needing type-level Ord.
13:44:51 <Cale> I'd need to think about that.
13:45:02 <hodapp> napping: haven't used Const before, trying to get a sense of why you did it that way...
13:45:30 <napping> hodapp: gunfold needs that type c, and the last type parameter is polymorphic as it goes over the constructor arguments
13:45:42 <blogle> geekosaur, I am going crazy trying to bend vty-ui to my will.. do you have much experience with it?
13:45:46 <napping> the easiest way to just accumulate a [TypeRep] as you go is to pick Const [TypeRep] for that c
13:46:03 <erisco> Cale could just use the lexicographic order
13:46:05 <geekosaur> not really, no
13:46:10 <blogle> :(
13:46:13 <geekosaur> blogle, not really, no
13:46:19 <Cale> erisco: on what?
13:46:26 <erisco> to order the types
13:46:47 <Cale> erisco: Types are not lists.
13:47:18 <erisco> Cale I do not get what you mean. You were talking about a type-level Ord, and I am just offering an ordering for types
13:47:41 <erisco> for * things anyways
13:47:45 <Cale> I'm not sure what lexicographic ordering means on types
13:48:01 <erisco> it means Char comes before String because C comes before S
13:48:03 <blogle> geekosaur, I will keep banging around I suppose...
13:48:27 <Cale> erisco: There's no way to tell that Char is named Char though. Also String is a type synonym for [Char]...
13:48:37 <ReinH> You might as well choose any permutation
13:48:51 <ReinH> The names of the types don't mean anything
13:48:56 <hodapp> napping: hmm, kind of makes sense
13:49:35 <Cale> But the really tricky thing here is that newKey gives you a value of type Key x a where x is a type variable that's never actually going to be instantiated
13:49:39 <hodapp> napping: I guess I don't totally get why that type parameter 'a' even has to be there
13:49:42 <Cale> and those are the things you'd need to compare
13:50:07 <Cale> newKey :: (forall x. Key x a -> b) -> b
13:50:43 <erisco> anyways
13:50:44 <napping> hodapp: The example in the documentation shows how the arguments of gunfold are used with the constructor. Also, it needs to know the data type to interpret the constructor
13:50:52 <Cale> This is how you avoid keys getting used inappropriately
13:51:20 <Cale> If somehow you could have an ordered kind of keys
13:51:33 <erisco> I hope the dissatisfaction of having error cases throughout the core of a program is obvious
13:51:39 <Cale> So you could say: newKey :: (forall x :: OK. Key x a -> b) -> b
13:52:13 <Cale> Then the type of insert could perhaps do something much fancier
13:52:24 <hodapp> napping: what example, the data T a b = C1 a b | C2 deriving (Typeable, Data) ?
13:52:32 <erisco> it means you either prove the program outside of Haskell or you at best have a test suite
13:52:56 <Cale> erisco: Well, you want a dependently typed programming language, clearly.
13:53:17 <napping> hodapp: a bit lower, the funfold k z c = case constrIndex c of 1 -> k (k (z C1)); 2 -> z C2
13:53:21 <Cale> erisco: The type system in Haskell isn't intended to be able to prove correctness.
13:53:23 <erisco> not the ones which exist right now due to stability
13:53:59 <napping> erisco: Haskell is not stable as a dependently typed language either
13:54:09 <erisco> you're right
13:54:53 <napping> hodapp: so your second function "z" needs to be able to handle the *unapplied* type of the constructor
13:55:01 <Cale> Types are just one particular tool for helping to make sure programs are correct. As you make the types finer, it becomes more challenging to write programs which type check, and requires more work on the part of the programmer to prove to the compiler that the operations being performed are valid.
13:55:02 <napping> like Int -> String -> Rec for my simple record example
13:55:07 <Cale> You do pay for safety.
13:55:16 <dolio> erisco: I still think your linearity idea could be accomplished easiest using ST.
13:55:19 <napping> and then your "z" function takes care of one argument at a time
13:55:21 <CapitalSigma> hey all
13:55:25 <dolio> Inasmuch as that solves your problem.
13:55:35 <napping> and yeah, you have to do pretty strange stuff.
13:55:47 <napping> Check out generics-sop instead
13:56:00 * hackagebot acme-everything 2015.5.4.1 - Install everything.  http://hackage.haskell.org/package/acme-everything-2015.5.4.1 (quchen)
13:56:18 <CapitalSigma> are there any kind of monad/monad transformer exercises out there to help me grok when i should be using a particular monad?
13:56:31 <Cale> Haskell tries as hard as possible to make types usefully expressive while maintaining the ability to do type inference anywhere that "fancy" types aren't involved.
13:56:41 <erisco> Cale granted, it is just that this happens to be a centrepiece of the larger program, so the extra cost is worth it
13:56:53 <erisco> if it was closer to the fringes I wouldn't care
13:57:02 <Cale> That latter goal cripples the expressivity of the type system to a fair extent, but it also makes the system very usable.
13:58:15 <ion> quchen: ACME packages are somehow less funny when the description says it’s a joke.
13:58:18 <Cale> Having to provide proof terms of various sorts manually can be pretty depressing and/or can make designing libraries in such a way that it doesn't become completely unmanageable very difficult.
13:59:16 <sinelaw> nah, still funny
13:59:18 <erisco> Cale ideally you can opt in to a level of safety, maybe
13:59:31 <quchen> ion: I'd say this is only a half-joke, but then so is the rest of that namespace. Since it's superficially a completely nonsensical package, I felt like explaining the reason for it a bit.
13:59:35 <Cale> Like, you'll find there are some very elegant implementations of simply typed lambda calculi in dependently typed languages, but the elegance only came after an incredible amount of floundering
13:59:43 <erisco> a few languages do this in a simple sense, using unsafe blocks
14:00:20 <Cale> The management of contexts and so on can be quite subtle
14:00:55 <Cale> and that actually comes down to just about the same problem you're talking about here
14:01:38 <Cale> When you want to interpret a variable, you need to know that it's an element of the context
14:01:55 <Cale> So it's basically the whole issue with safe key lookups all over :)
14:02:58 <Cale> and *proving* that it's an element of the context can be an incredible hassle if you go down a slightly wrong path with how you represent things
14:05:17 <erisco> writing unsafe functions brings back the memories...
14:05:20 <erisco> oh well
14:05:31 <josephle> first you have to prove the correctness of your search, *then* you can use the search as a proof of membership!
14:12:11 <Peaker> Hey, is it safe to use async's race  between  takeMVar  and  readChan, for example? Or may messages be lost?
14:12:20 <athan> Is there a way to "turn off" memoization for basic `:set +s` profiling in ghci?
14:12:34 <Peaker> could takeMVar win, for example, and then the thread cancellation of the readChan -- lose the already-read message?
14:13:10 <Peaker> or is one expected to use STM for such things?
14:13:52 <napping> that sounds entirely possible
14:14:11 <napping> race just kills the losing thread, it doesn't try to roll it back
14:14:13 <merijn> Peaker: I think messages may be lost
14:14:20 <Peaker> I have a concurrency thing I want to do that is proving more difficult than I thought with Haskell's primitives:  I want a single working thread to be sent events to handle (no events may be lost), and "ticks" to handle (I want ticks to never be queued, and be lost if one is already queued)
14:14:25 <merijn> Peaker: I would use STM just to be sure
14:14:55 <Peaker> the single working thread serializes all these requests and performs them one at a time (tick, events, events, tick, ...)
14:15:18 <Peaker> merijn: I avoid STM because all the benchmarks seem bad :(
14:15:26 <napping> listening to various things like that is exactly what STM makes easy to express
14:15:47 <Darwin226> Hey guys. I've been playing around with the hackage css and I think I've improved on it a bit. It looked like this http://i.imgur.com/sVLqM6E.png before, now it looks like this http://i.imgur.com/sVLqM6E.png. What do you think? If people like it I'll see if I can get it in hackage. If not, I'll just use it myself
14:16:28 <Darwin226> Posted the same link twice. The before one is this http://i.imgur.com/Cu2tmIn.png
14:17:04 <Peaker> Using just Chan, MVar, and such friends, do you see a safe way to do it?
14:17:26 <Peaker> Sending messages to the thread should never block (events queue, ticks get discarded)
14:17:55 <Saizan> Darwin226: what happens if i have a thin window for the browser though?
14:17:57 <athan> Darwin226: I really want to upgrade Hackage to semantic-ui :\
14:18:20 <athan> Responsive Design ftw
14:18:29 <athan> also, I need to fix the typesetter :|
14:18:36 <Darwin226> Saizan: There's is a min-width on the content so it doesn't get shrunk below a certain point
14:18:41 <Peaker> I could implement a:  readChanBulk that reads as much as possible until chan is empty, and then throws away tick duplicates
14:18:47 <napping> Peaker: a choice over multiple blocking things is one of the fundamental things STM gives you
14:19:10 <napping> without that, you'll need separate threads reading for events and ticks, and serializing them into a common channel or mvar or something
14:19:20 <Peaker> napping: I understand, but I prefer to avoid the STM because: A) STM performance apparently sucks, some call it a "toy", B) it is an extra dependency
14:19:41 <napping> what benchmarks are you looking at?
14:20:03 <napping> some call Haskell a "toy"
14:20:37 <Darwin226> Saizan: http://i.imgur.com/PgvZraL.png
14:21:21 <ion> You have min-width + width instead of max-width?
14:21:39 <napping> from the benchmarks I remember, STM is quite competitive in this kind of situation
14:21:40 <Peaker> napping: Old ones, I remember comparisons of atomicModifyIORef with STM being extremely unfavorable to STM, for example
14:21:41 <webchat099> STM performance sucks? where you got this idea from?
14:22:30 <napping> Peaker: what the heck to you expect? That's a bare CAS compared with higher-level operations
14:22:35 <merijn> STM performance depends very strongly on usage
14:22:44 <Peaker> napping: https://mail.haskell.org/pipermail/haskell-cafe/2008-December/052568.html is one example
14:22:49 <Rotaerk_> haskell is a toy
14:22:50 <Rotaerk_> it's fun
14:22:50 <napping> MVar and Chan already suck compared to atomicModifyIORef
14:23:03 <Peaker> napping: MVar is only mildly more expensive than IORef
14:23:09 <merijn> Peaker: STM performance "sucking" highly depends on your use case
14:23:14 <napping> That's a horrible use case
14:23:22 <napping> you're not supposed to write 20000 TVars in a transaction
14:23:40 <merijn> Peaker: That email is really stupid use of STM
14:23:46 <napping> And STM is competitive with using a couple MVars or TVars
14:24:04 <merijn> Peaker: STM performance is good if you use small numbers of variables and don't have many threads blocked for the same ones
14:24:07 <napping> Peaker: that sort of thing is exactly why STM hasn't worked in other languages - trying to cram way too much stuff into an update
14:24:34 <merijn> large numbers of variables means every transaction invalidates every other one leading to lots of overhead
14:24:35 <napping> I think something may have been quadratic in the size of the transaction log back then too
14:24:47 <merijn> And large numbers of blocked threads on a single variable leads to thundering herd
14:25:05 <merijn> But for low numbers it's actually pretty low overhead due to the use of optimistic locking
14:25:08 <napping> Peaker: did you click through to the reply?
14:25:35 <simpson> napping: Which other languages are you thinking of?
14:25:36 <napping> A read is/was linear in the size of the transaction log
14:25:46 <napping> simpson: there were attempts in C#, for example
14:25:58 <merijn> simpson: C#, I think some people tried Java too
14:26:06 <napping> every local variable being mutable and not having a good idea what needs to go in the transaction log makes it really hard to get decent performance
14:26:14 <merijn> Clojure is barely usable and they are almost as aggressively immutable as haskell
14:26:20 <Aruro> how to activate source command without lambda bot?
14:26:20 <Peaker> napping, merijn: That thread was just what I found now. I remember reading more unfavorable benchmarks in the past. I will try stm though if it should be fine for my small use case
14:26:27 <Peaker> (even though I was hoping to avoid the extra dependency)
14:26:47 <simpson> napping, merijn: I see. I've been looking expectantly at PyPy/RPython's current STM work.
14:26:49 <napping> Peaker: using STM to merge over a handful of channels and MVars is exactly the case they benchmark with great results in the STM papers
14:26:54 <merijn> Peaker: You have only 1 waiting thread (the handler), right? That should be very cheap
14:27:01 <Peaker> yeah
14:27:04 <merijn> Peaker: I mean, I dunno what sort of latency you're trying for
14:27:07 <napping> only one waiting thread, O(1) TVars
14:27:27 <Peaker> merijn: I want Lamdu's animation loop to be separated from the rest of the events/code so animations don't jitter
14:27:46 <merijn> Peaker: Right, so "milliseconds"
14:27:52 <napping> Is stm even really much of an extra dependency?
14:27:54 <merijn> I doubt STM will be a problem
14:28:42 <napping> isn't it pretty much pinned to whatever shipped with your GHC?
14:29:16 <merijn> Yeah
14:29:20 <Peaker> Ok, so using STM, what would be a good way to structure this?  A TVar with a boolean "haveTicks" and a TVar with a list of events, and just sample both with orElse repeatedly?
14:29:54 <napping> yeah
14:29:56 <Peaker> Or a TChan of events, perhaps, so I don't have to reverse the list
14:29:59 <merijn> Events are never lost, right?
14:30:06 <Peaker> right
14:30:29 <merijn> Actually, I don't think you need the boolean, isn't their an STM "timeout"
14:30:30 <napping> the writers just either set the var true or push to the channel in a tiny transaction
14:30:35 <merijn> *there
14:30:44 <Peaker> a TChan is not so different from a TVar, isn't it? It just prepends and reverses for you, I guess?
14:30:46 <glguy> STM timeout is based on a TVar Bool
14:30:46 <napping> Isn't that exposed as a TVar Bool anyway?
14:31:03 <Peaker> merijn: why timeout?
14:31:04 <napping> Peaker: I'm not sure, it might be done as a linked list wired up with TVars, like a Chan is build from MVar
14:31:38 <merijn> Peaker: Well, you wanted to ignore ticks while there were events, yes?
14:31:53 <merijn> Peaker: How would you "skip" ticks when the event list is filled?
14:31:59 <Peaker> merijn: no no, I want to ignore ticks if I can't keep up with the tick-rate
14:32:08 <Peaker> but I don't ever want to lose events
14:32:15 <merijn> Peaker: Ah, right, so running a tick later redundantly is ok?
14:32:16 <Peaker> It's ok to not handle all ticks
14:32:28 <Peaker> it'd be nice to preserve the order, but not crucial
14:32:56 <napping> Peaker: if you want to also avoid STM, could you just toss the ticks in the Chan as well?
14:33:34 <Peaker> napping: but how do I avoid queuing up infinite ticks?
14:33:43 <Peaker> imagine the tick-handling rate may be lower than the tick generating rate
14:33:47 <napping> I assume something queues them at a sane rate?
14:33:51 <merijn> Peaker: I would use "TMVar ()" and "TChan Event" and do "fmap Right (readTChan foo) <|> fmap Left (readTMVar bar) :: STM (Either () Event)"
14:34:06 <napping> If you include a timestamp or something then you can skip ones that are past due
14:34:13 <merijn> And sending a tick would be "tryPutTMVar bar ()"
14:34:15 <Peaker> napping: nope -- that's why I want ticks to be "lost" if they cannot be handled fast enough
14:34:23 <Peaker> napping: that's an interesting idea
14:34:46 <napping> If you can't even keep up with skipping ticks at the tick rate, your system is pretty darn wedged
14:34:49 <Peaker> I've not used STM much, but TChan, TMVar seem weird to me, given that ordinary TVars let you block as you wish
14:34:57 <napping> (Left <$> readTChan events) `orElse` (do b <- readTVar tick; guard b; return (Right ()))
14:35:05 <Peaker> napping: In that case -- I want ticks to be lost, and thus I am un-wedged
14:35:16 <merijn> Peaker: The problem is what would your blocking condition for TVar be?
14:35:34 <napping> that would take a TChan Event and a TVar Bool, and block until either you have an event or the var is true, returning Either Event ()
14:35:37 <merijn> napping: Why the guard?
14:35:47 <napping> the guard blocks if the TVar Bool is set to false
14:35:49 <Peaker> merijn: for MVar, you can just use a TVar (Maybe a) and block until it is a Just, converting it to a Nothing?
14:35:59 <shachaf> napping: Sounds like that would be more simply expressed with that primitive foo a b = fmap Left a <|> fmap Right b
14:36:04 <merijn> Peaker: TMVar *is* "TVar (Maybe a)"
14:36:05 <Peaker> merijn: for Chan, just use a TVar of a simple list and prepend/reverse ?
14:36:34 <merijn> Peaker: And TCHan *is* "list + prepend/reverse" :p
14:36:43 <Peaker> merijn: I looked at TChan and it seems much more complex than that
14:37:07 <shachaf> No, TChan is more complicated.
14:37:16 <Peaker> shachaf: do you know why?
14:37:26 <merijn> Peaker: I do
14:37:28 <shachaf> Maybe to support duplication?
14:37:30 <napping> that's to support duplicating and cloning channels, with multiple readers having consumed different numbers of messages
14:37:36 <Peaker> ah, I see
14:37:40 <merijn> Peaker: It separates read/write ends into separate TVar to avoid transaction collissions
14:37:46 <napping> TVar (Queue a) would work for a single reader
14:38:20 <merijn> Peaker: I think Simon Marlow's concurrency book explains in-depth
14:39:04 <merijn> oh, wait
14:39:10 <merijn> Peaker: You're right, I'm wrong
14:39:14 <merijn> I'm thinking of TQueue
14:39:27 <merijn> Which, incidentally is indeed faster than TChan
14:39:35 <Peaker> the TList stuff does seem to be there for duplication
14:39:50 <merijn> https://hackage.haskell.org/package/stm-2.4.4/docs/src/Control-Concurrent-STM-TQueue.html#TQueue
14:39:51 <napping> and faster than Chan
14:40:07 <merijn> napping: Only for some usecases
14:40:19 <merijn> TQueue is very bad for multiple blocking readers
14:40:23 <merijn> Thundering herd and all that
14:40:29 <napping> yeah, single-reader throughput
14:40:39 <codygman> Anyone know of any good Aeson tutorials that parse using the AST/dynamically.
14:40:57 <napping> multiple blocking threads is the one thing MVar clearly handles better - it just wakes one thread
14:40:57 <merijn> Peaker: So take my initial example and replace TChan with TQueue and you're set
14:41:28 <napping> TQueue is also an amortized-constant-time queue
14:41:39 <napping> which shouldn't be an issue if your consumer is keeping up with things
14:41:44 <Peaker> merijn: I think I'm settling on a TVar ({-have ticks-}Bool, [Event])
14:41:57 <Peaker> and I just read it and replace it with (False, []) every time
14:42:13 <merijn> Peaker: Wouldn't appending Event's be expensive?
14:42:19 <merijn> Oh, I see what you plan
14:42:25 <Peaker> I'll prepend/reverse
14:42:30 <merijn> Just reverse after reading
14:42:33 <merijn> right
14:42:54 <napping> If you don't mind polling and snarfing everything, how about going back to atomicModifyIORef?
14:43:20 <merijn> napping: Can't block on change
14:43:22 <napping> or do you plan to block as long as it's False,[]
14:43:49 <athan> Is there an easy way to make mapM_ parallel when not working in IO?
14:44:03 <merijn> Bed time!
14:44:40 <Peaker> napping: yeah, block
14:45:09 <Hijiri> athan: I think it would have to be a new function
14:45:40 <athan> Hijiri: Oh, sorry, I didn't mean that it should take the same name
14:45:49 <athan> `parallel_` from parallel-io, for instance is an example
14:46:14 <athan> it has the same type structure, but not the same name
14:46:28 <athan> (but that only works for the IO monad)
14:46:42 <Hijiri> is it the (>>) you want to parallelize?
14:46:50 <napping> Peaker: sounds good then. There's various ways you could try tuning, but you'll need some data
14:46:51 <athan> I'm wondering if I could do it for a Writer monad, where the accumulator is an abelian monoid
14:46:58 <athan> Hijiri: Yes!
14:47:07 <napping> Peaker: STM is almost always the easiest way of getting concurrency right
14:47:50 <napping> then maybe mess around with condition variables or whatever if your load makes it appropriate
14:48:21 <Peaker> napping: I don't like STM in principle though :(  (Due to theoretical issues regarding high concurrency, large transactions, and the re-check all tvars heuristically at "retry")
14:48:53 <Peaker> a more declarative framework wouldn't have to re-check all variables at every retry, for example
14:49:04 <napping> What do you mean re-check all variables at the retry?
14:49:05 <Hijiri> you could break the list (or other foldable) into chunks and make a new spark for mapM_ each one (using parallel or something)
14:49:18 <Hijiri> and then (>>) them together, since (>>) is associative
14:49:23 <Peaker> napping: STM blocks until any of the read-TVars changed, and then it re-runs the transaction hoping this time it won't "retry"
14:49:29 <napping> STM blocks until any read TVar changes
14:49:30 <napping> yeah
14:49:38 <napping> what else is it supposed to do?
14:49:53 <Peaker> if it had known what tests the STM transaction would do on these variables
14:49:56 <athan> Hijiri: Hmm, I'll think about it. Thank you!
14:50:06 <Peaker> it could block specifically until those tests would pass
14:50:19 <c_wraith> Peaker: seems like you run into the halting problem
14:50:25 <c_wraith> Peaker: especially since STM is a monad
14:50:33 <Peaker> c_wraith: that's why I said "if it was more declarative"
14:50:37 <Peaker> i.e: restricted in some way
14:51:08 <napping> Applying the tests is more or less re-running the transaction
14:51:19 <napping> and I think orElse takes stuff into account
14:51:34 <napping> continuing at least closer to the point where the first changed variable was read?
14:52:18 <napping> and large transactions are very much not what Haskell's STM is supposed to be used for
14:52:23 <Peaker> If I read 50 TVars and sum them, I can be much more efficient than resum them all on every change
14:52:58 <Peaker> contrived example, maybe, but I'm sure more realistic examples exist :)
14:53:16 <napping> STM is at least closer to that than any messing around with raw locks and TMVars and threads
14:53:51 <Peaker> a lot of the time I can get away with a single MVar for blocking, or a single atomic IORef for shared state, I like those :)
14:54:07 <napping> sure, if that's enough
14:54:10 <napping> and when it's not?
14:55:50 <napping> and high contention is a problem for every approach
14:56:02 * hackagebot json-rpc 0.2.1.6 - Fully-featured JSON-RPC 2.0 library  http://hackage.haskell.org/package/json-rpc-0.2.1.6 (XenoGenesis)
14:58:21 <Aruro> what is the meaning of bytes in the ghci +s option?
14:59:02 <JamesJRH> pl \x y -> x y
14:59:28 <JamesJRH> What is the ‘pl’ bot?
14:59:49 <JamesJRH> How do I use it and can I /msg directly?
15:00:00 <shachaf> /msg lambdabot @pl ...
15:00:09 <shachaf> You can also get the package "pointfree" from Hackage.
15:00:42 <JamesJRH> Thank you.
15:03:25 <JamesJRH> So lambdabot, not pl. That means that I've just inadvertently messaged someone with the nick ‘pl’ who is probably not a bot. :-}
15:03:42 <kadoban> Quite likely.
15:03:47 <shachaf> They may be a programming language, or Poland.
15:04:00 <JamesJRH> :-)
15:05:55 <L8D> @pl \x y -> x y
15:05:55 <lambdabot> id
15:19:14 <knite> just wrote a simple tree insertion, but the decomposition in the pattern match feels kinda squicky. is there a way to make it more Haskell-y? https://gist.github.com/pikeas/be5de8cbc9e62bb1f9fd
15:19:56 <srhb> knite: You could use guards
15:20:19 <srhb> knite: Instead of the case statement, I mean
15:21:23 <knite> srhb: yeah, that would be slightly nicer. I'm more concerned with the unpacking I'm doing in the function definition. I'm a Haskell rookie, but that feels clunky. wondering if there's a more idomatic way to do it.
15:22:40 <srhb> knite: I don't think it's terrible. In all honesty shortening some names and changing some indentation around could make it look quite nice
15:23:28 <srhb> knite: Or if LogMessage is defined in record syntax, you wouldn't need to unpack them
15:24:32 <srhb> knite: Then it would just become case ts msg1 < ts msg2 -- or something similar
15:25:07 <knite> srhb: I haven't gotten to records yet, guess I should take a look. :-)
15:25:25 <srhb> knite: It's as simple as naming each individual field in the data LogMessage definition
15:25:58 <srhb> knite: data LogMessage = LogMessage { foo :: FooType, ts :: TStype, ... }
15:26:35 <srhb> knite: Then you get foo, ts, and other accessors that can extract the ts from a LogMessage
15:26:44 <knite> so then in any function using LogMessage, foo and ts will be functions in the namespace which function as getters?
15:26:46 <srhb> (Well, each field. ts just for the TS field)
15:26:48 <knite> ah, heh, beat me to it!
15:26:55 <srhb> knite: Right.
15:27:09 <srhb> Technically they will be in the module namespace
15:27:15 <srhb> Not just restricted to functions using LogMessage
15:27:58 <knite> hm, now an article I read a while back (prior to starting to learn Haskell) about the "records problem" makes more sense.
15:28:17 <srhb> knite: Right. Solutions are upcoming though. Some already exist, but until a language extension is created, they are a little clunky.
15:28:34 <srhb> knite: (For now it's easily solved by using template haskell or simply naming fields like logmessage_ts etc)
15:53:58 <codygman> How can I use Aeson to handle a sum type like this? Will I have to write my own instances? Any guidance on doing that or tutorials? link: http://lpaste.net/132005
15:56:12 <Cale> codygman: Does the code there not work?
15:56:52 <Cale> codygman: Oh, well, you might want to check what the encodes look like
15:57:43 <Cale> codygman: If you want to match a specific JSON format, then you need to write your own instances, or use the TH macros which are provided to allow for some more customisation of the generated instances.
16:16:12 <cite-rea1er> Does anyone know of a parser for MySQL-dialect queries?
16:17:36 <codygman> Cale: It looks like the encoded versions have a "tag" attribute, that shouldn't be in the FromJSON instances right? Hm, guess I should look up how the Aeson instances work.
16:17:56 <hunteriam> hey could someone give me feedback on this code
16:17:57 <hunteriam> https://gist.github.com/hunteriam/9f201643223cacc7cc96
16:21:05 * hackagebot cabal-dependency-licenses 0.1.1.0 - Compose a list of a project's transitive dependencies with their licenses  http://hackage.haskell.org/package/cabal-dependency-licenses-0.1.1.0 (JasperVanDerJeugt)
16:21:54 <hunteriam> Im just going to repaste it once more, just looking for feedback
16:21:55 <hunteriam> https://gist.github.com/hunteriam/9f201643223cacc7cc96
16:23:40 <L8D> hunteriam: hello
16:23:44 <kadoban> hunteriam: Set = []  seems pretty confusing.
16:24:24 <kadoban> hunteriam: By that definition, you can't have an empty tree, is that intended?
16:26:55 <kadoban> hunteriam: What is buildTree exactly? The type looks weird, shouldn't you be able to build any 'Tree a' ? Why is it building a `Tree (Set a)` ?
16:27:22 <AfC> cite-rea1er: what are you trying to parse the SQL _into_?
16:27:54 <cite-rea1er> Abstract syntax.
16:28:16 <cite-rea1er> (Actually I want to parse not-quite-SQL, but something that can parse real SQL seems like a good start.)
16:28:46 <cite-rea1er> Basically I've got a pile of MySQL queries that have placeholder values, and I'd like to extract a list of the placeholders.
16:29:32 <cite-rea1er> I've got a dumb regex-based solution, but it doesn't understand comments or string literals, so I'd like to have something better.
16:31:05 * hackagebot BlogLiterately 0.7.1.8 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.7.1.8 (BrentYorgey)
16:32:20 <hunteriam> L8D hey, sorry for disappearing on you
16:32:33 <hunteriam> L8D I've been in the last few weeks of school for the last few weeks
16:33:06 <hunteriam> Kadoban the intent is, given a set of sets, to find the largest possible subset containing sets that are all disjoint with one another
16:37:36 <zipper> Hey, earlier today I asked a question regarding the concept of the server in ide-backend. How can I set this server? I can't seem to "find" it.
16:37:48 <zipper> Any ide-backend people in the house?
16:38:20 <hunteriam> What is ide backend?
16:40:16 <geekosaur> tools like scion or ghc-mod that provide support routines for editors and ides
16:40:21 <geekosaur> (no, I'm not one)
16:40:47 <zipper> hunteriam: hmmm you want a rough overview?
16:41:13 <zipper> hunteriam: It's a library that was extracted from and ide that fp complete built.
16:41:34 <zipper> hunteriam: It can act as a wrapper around GHC for some things.
16:41:52 <zipper> Such as building an IDE :)
16:44:29 <geekosaur> my guess is it uses the first ghc executable in $PATH
16:45:20 <geekosaur> oh, ide-backend-server, which has no docs on hackage yet
16:45:59 <geekosaur> so it looks for the executable built by that package, which is linked against a specific ghc version
16:46:12 <geekosaur> (ghc-as-a-library, cf "ghc" packaged dependency)
16:49:33 <JamesJRH> shachaf: Pl is quite clever, but:
16:49:38 <JamesJRH> @pl (=<<) . (return .)
16:49:38 <lambdabot> fmap
16:49:42 <JamesJRH> @pl flip fmap
16:49:42 <lambdabot> flip fmap
16:49:44 <JamesJRH> @pl flip ((=<<) . (return .))
16:49:44 <lambdabot> (. (return .)) . (>>=)
16:50:10 <shachaf> Why are you telling me?
16:50:23 <athan> Is `1 / 7 :: Scientific` _supposed_ to make my machine crash? :\
16:50:31 <geekosaur> yes
16:51:02 <geekosaur> well, not literally machine crash but the expansion will use all RAM
16:52:10 <athan> hell yeah
16:52:24 <small-wolf> I hate messing around with DYLD_LIBRARY_PATH
16:52:35 <small-wolf> let the record show
16:52:47 <geekosaur> "This type describes the set of all Reals which have a finite decimal expansion."
16:52:48 <JamesJRH> shachaf: I don't know. Thought you might be interested as you toldmehow to use it earlier.
16:53:05 <JamesJRH> told me how*
16:53:14 <geekosaur> 1/7 has an infinite decimal expansion so is not expected to work with Scientific
16:53:16 <shachaf> You can submit a patch if you want.
16:53:29 <small-wolf> anyone else have to do that building stuff with cabal on mac os?
16:53:46 <JamesJRH> It's very interesting though.
16:53:47 <shachaf> https://github.com/bmillwood/pointfree/blob/master/Plugin/Pl/Rules.hs
16:55:04 <small-wolf> can't find some random C library, update DYLD_LIBRARY_PATH, builds fine
16:56:00 <geekosaur> like to live dangerously, huh
16:58:29 <knite> just tried installing my first cabal package and got some failures. tried to install hlint, output is https://gist.github.com/pikeas/8539aa473af53b1dd1a0 
16:59:03 <small-wolf> download happy
16:59:08 <small-wolf> it's a missing external dependency
16:59:27 <codygman> Using Aeson I have the following "Object (fromList [("entries",Array (fromList []))])" and I'd like to get the Array out to process. I tried using (\(Array a) -> a) (f closedTabStr) but got fromList *** Exception: <interactive>:315:2-16: Non-exhaustive patterns in lambda. Do I need to implement all of the sum type of Value to get the array?
16:59:58 <small-wolf> are you using a linux distro? if so then install happy through your distro's package manager (you might also need alex)
17:00:54 <kadoban> Why not just install it using cabal?
17:01:32 <geekosaur> needing to know to add cabal's bin path to $PATH before trying again
17:01:50 <athan> geekosaur: Thank you, I should've paid more attention
17:03:43 <knite> well, I can add cabal's bin to my path as needed. I'm assuming installing via cabal is preferred, then?
17:04:20 <knite> why is happy an external dependency if it can be installed by cabal?
17:04:20 <kadoban> I don't use anything from my OS's package manager for haskell, it's all ancient and fugly.
17:04:58 <kadoban> knite: It needs it as an executable, not a library I believe. cabal doesn't cover that AFAIK.
17:05:10 <geekosaur> knite, cabal has trouble dealing with program dependencies, since it relies on ghc's library manager and executables aren't libraries
17:05:54 <knite> holy cow, just tried a cabal list, ridiculous amount of output. how can I see my, well, top-level dependencies, assuming that concept even applies in the Haskell ecosystem?
17:06:13 <geekosaur> it's hard to "fix" this because not using ghc's library manager would be a disaster given ghc's unusually strict dependency issues (usually miscalled "cabal hell" but it's mostly ghc's fault)
17:06:31 <geekosaur> cabal list --installed
17:06:42 <geekosaur> "cabal list" shows everything available, not everything installed
17:07:10 <knite> hm, silly default, but I suppose it's been complained about by many other beginners.
17:07:21 <geekosaur> it's a package manager, really
17:07:27 <kadoban> Not really a silly default … you told it to do that XD
17:07:39 <geekosaur> so list shows available packages
17:07:50 <JamesJRH> When I had issues with Cabal when I first started using Haskell 2 or 3 years ago, I was pointed in the direction of NixOS.
17:07:54 <JamesJRH> I'm now using NixOS.
17:08:02 <knite> well, compare to dpkg -l, pip freeze, or npm ls, all of which show installed packages.
17:08:05 <geekosaur> well, not a package manager in the usual sense meant, I guess. repo manager might be better
17:08:18 <geekosaur> ghc-pkg list
17:08:30 <geekosaur> ^ that is the real package manager comparable to what you named
17:08:52 <knite> then I'm a bit confused about cabal vs ghc-pkg?
17:09:06 <geekosaur> cabal is a tool to install packages
17:09:19 <geekosaur> ghc-pkg controls and lists the package database
17:09:32 <geekosaur> so cabal shows you available packages for installation, and ghc-pkg shows you installed packages
17:09:51 <knite> JamesJRH: I've read a teeny bit about NixOS, but I think Haskell alone will use all my spare brain cells until I'm a lot more comfortable with it.
17:09:58 <geekosaur> and cabal provides a way to install available packages (ghc-pkg doesn't, it just manages the installed packages)
17:10:08 <geekosaur> the comparison here might be rpm vs. yum
17:10:08 <JamesJRH> :-)
17:10:18 <geekosaur> rpm could install packages but you had to find and download them yourself
17:10:33 <knite> I see. so basically separation between local package management and remote package search/installation.
17:10:49 <knite> but cabal is common enough to provide some tools for local management.
17:10:56 <geekosaur> the first version of yum was pretty much the same as current cabal, provided ways to get those packages from repos and hand them to rpm foir installation
17:12:30 <knite> I take it ~/.ghc is packages local to the project and /opt/.ghc is global?
17:12:49 <knite> but I successfully installed happy and ghc-pkg list | grep happy has nada.
17:13:00 <monochrom> ~/.ghc scopes over the whole user account
17:13:04 <geekosaur> yes, as I said happy is an executable, not a library
17:13:15 <geekosaur> ghc's package manager cares about libraries
17:13:25 <geekosaur> which is why cabal ends up having problems dealing with execcutable dependencies
17:13:40 <monochrom> perhaps it's time to read my http://www.vex.net/~trebla/haskell/sicp.xhtml
17:13:49 <zipper> geekosaur: So there's an ide-backend-server package too? Man I'm ignorant.
17:13:54 <knite> ha, not the SICP I was expecting!
17:14:02 <zipper> How'd I not know this?
17:14:11 <geekosaur> http://hackage.haskell.org/package/ide-backend-server
17:14:33 <knite> so...cabal install happy installs the happy executable but keeps no record of having done so?
17:14:34 <geekosaur> and I know because I went and looked in the browser tab where I keep and periodically update hackage's master package list :)
17:14:52 <monochrom> right, unless you look into ~/.cabin/bin
17:15:01 <geekosaur> knite, it expects to find the executable in $PATH
17:15:16 <geekosaur> but cabal installs stuff locally and there is no standard user bin directory on most systems
17:15:20 <monochrom> why? because it is unpaid volunteer work
17:15:34 <geekosaur> and it is not really possible for it to poke your shell and something to its $PATH
17:15:41 <small-wolf> oh ... that's weird.
17:15:48 <monochrom> volunteers do what they feel interested in, not what is in "high" demand
17:15:49 <geekosaur> (some smartass may pipe up with something about gdb here, have fun crashing your shell)
17:16:02 <knite> right, just to be clear, I'm not having trouble *using* happy, I'm expressing surprise that the package managers (either cabal or ghc-pkg) will install something but not keep a record of that thing!
17:16:19 <small-wolf> does that mean if cabal bin is already on your path then it will notice that the happy executable exists?
17:16:27 <geekosaur> yes
17:16:28 <monochrom> if you know economics, you will not be surprised.
17:16:52 <knite> I'm about two weeks into Haskell. initial impression is that the language is wonderful, but the infrastructure/ops/tooling around it leaves a bit to be desired.
17:17:30 <small-wolf> so is there a nice description of cabal's general strategy for meeting external dependencies?
17:17:35 <geekosaur> yes, and peoople are working on it but it;'s a hard problem if you're not willing to say "use this small set of Linux distributions" and you're not based on an all interpreted model like python/ruby/js
17:17:38 <small-wolf> I have no idea where it looks for anything
17:18:06 <geekosaur> and you haven't had 20 years to build an ecosystem like the perl folks
17:18:27 <monochrom> cabal doesn't have a general strategy. but most packages call up the unix tool "pkg-config"
17:18:41 <geekosaur> (note that C is *still* struggling with this issue, which is why there are horrors like autoconf and cmake and pkg-config and things still go awry)
17:18:42 <small-wolf> the external dependency thing is per package?
17:19:23 <knite> in other words, I'm spoiled by interpreted languages.
17:19:35 <geekosaur> and C's bveen at this since 1970
17:19:40 <geekosaur> pretty much, yes
17:19:41 <monochrom> this is why sometimes I say "hugs doesn't have cabal hell"
17:19:43 <geekosaur> the task is much simpletr
17:19:44 <knite> though I'll point out that pip and npm both have their own issues.
17:20:00 <athan> What's a good way to infinitely expand the decimal representation of a Rational number?
17:20:12 <athan> (or up to a repetition)
17:20:16 <knite> how has Go solved the problem? they're the new kid on the block and it's a compiled language.
17:20:28 <small-wolf> figure out the base
17:20:30 <monochrom> by paying money to Google employees
17:20:41 <simpson> Go doesn't solve the problem.
17:20:54 <shirt> for managing dependencies, I've started using vagga <https://github.com/tailhook/vagga> and find it really nice. not just for haskell. it's linux only though (written in rust though which is cool)
17:21:01 <simpson> Go inside Google is in a monolithic tree. Go outside Google has no answer for dependency management.
17:21:19 <small-wolf> for a fraction, figure out the smallest number of the form 10^n*(10^m - 1)
17:21:26 <small-wolf> that is a multiple of your original denominator
17:21:56 <athan> small-wolf: hrm
17:21:58 <athan> alright
17:22:01 <small-wolf> padding with zeroes, the first n digits of the numerator are the repeating segment, the final m digits of your numerator are the repeating segment
17:22:10 <small-wolf> first one should say nonrepeating segment
17:22:14 <small-wolf> this isn't lazy enough though
17:22:27 <small-wolf> I assume you don't want to do more work than you have to to get digits right?
17:22:47 <athan> :) ideally!
17:23:17 <geekosaur> so, small-wolf, re your problem you originally brought up in #ghc, in some ways the library issue on OS X is similar to the one on Windows: external dependencies that don't come with the system are Hard.
17:23:21 <athan> hmm
17:23:47 <small-wolf> yeah I feel bad about bringing it up there, I read the title after posting it and it's the ghc dev channel
17:24:11 <geekosaur> the good news is that you have third party package systems for OS X that can provide many of them. the bad news is that those systems usually need to ship later versions of their dependencies than Apple does, so their libraries are often incompatible with stuff built against Apple's
17:24:38 <small-wolf> don't like polluting the low-traffic channels
17:24:51 <small-wolf> hmmm
17:25:30 <geekosaur> (libiconv.dylib is a recurrent pain point that comes up with stuff built against Apple's libiconv vs. stuff built against Fink/MacPorts/Homebrew versions of it. in the worst case this shows up as core dumps, but in general all three of those have things patched so you get symbol errors instead)
17:26:17 <zipper> geekosaur: Mucho gracias
17:26:44 <small-wolf> is there a way to make sure that I'm only building stuff against brew libraries?
17:26:59 <small-wolf> by tweaking environment variables or something
17:27:17 <geekosaur> you'll need to build your own ghc against Homebrew libraries, since the current ghc recipe for homebrew is broken
17:27:26 <geekosaur> (someone was in here earlier trying to figure out how to fix it)
17:28:50 <geekosaur> because if ghc's runtime and/or base library is built against Apple's libraries, things tend to go wrong if you then build additional packages against non-Apple libraries, as with the iconv thing I mentioned earlier (in fact that's one of the things that commonly goes wrong)
17:29:14 <small-wolf> if I build stuff through nix I still have problems
17:29:20 <geekosaur> yep
17:29:27 <small-wolf> even though theoretically everything is compiled against nix's libraries
17:29:31 <geekosaur> it would be nice if Apple didn;t include conflicting versions of things
17:29:46 <geekosaur> like iconv and readline, neither of which is the one that anything else actually expects
17:30:04 <small-wolf> This makes me want to cry
17:30:09 <geekosaur> (Apple's "readline" is actually BSD editline; I'm niot sure what its iconv is but it's not GNU iconv)
17:31:00 <small-wolf> they basically ripped off the freebsd userland anyway, why make these silly incompatible changes?
17:31:04 <geekosaur> (or if it is then it's a truly ancient version, because all GNU iconv versions I've looked at have the symbols that the fink/mp/hb ones do, not the ones Apple has)
17:31:23 <geekosaur> I have no idea
17:31:48 <geekosaur> I think they actually got the weird iconv from bsd, though, because freebsd has that same problem (against its own ports system even!)
17:32:04 <geekosaur> "readline" being editline is all Apple's fault though
17:32:07 <zipper> geekosaur: What would be causing this http://lpaste.net/4101240554140991488
17:32:23 <zipper> geekosaur: Says a dependency is missing right after I've installed it.
17:32:41 <geekosaur> zipper, that would be exactly the situation with executables that we just discussed a few minutes ago
17:32:53 <geekosaur> you probably bneed to add $HOME/.cabal/bin to your $PATH and try again
17:33:25 <zipper> geekosaur: It's in PATH
17:33:26 <geekosaur> because ide-backend-server is an executable that ide-backend runs to get the server end
17:34:47 <geekosaur> hm. I can think of ways that can happen (easiest one being you added it to $PATH and didn't `export PATH` so programs run from your shell still get the old PATH)
17:35:26 <zipper> http://lpaste.net/1069814797962313728
17:35:29 <geekosaur> also if you checked it with `which`, be aware that is prone to tell you what the next login shell you start will see, not what your current shell sees
17:35:33 <zipper> geekosaur: http://lpaste.net/1069814797962313728
17:35:53 <small-wolf> I've sometimes had to exit the terminal and open it again, even after updating path and sourcing .bashrc because of caching stuff (I think)
17:35:55 <zipper> geekosaur: Okay so you propose I restart the shell?
17:36:09 <geekosaur> try `env PATH` first to see if it matches the `echo $PATH`
17:36:22 <geekosaur> if it doesn't, then `export PATH` will fix it
17:36:35 <geekosaur> or `env | grep PATH`
17:37:09 <geekosaur> that first one won;t work, env wants a program name. (was thinking printenv which is an old cshism)
17:37:33 <small-wolf> geekosaur: what shell do you use jooc
17:37:48 <zipper> geekosaur: I've updated the paste http://lpaste.net/1069814797962313728
17:37:50 <geekosaur> mostly zsh these days on my desktop, bash on my work machine
17:38:11 <zipper> small-wolf: What is jooc?
17:38:20 <small-wolf> just out of curiosity
17:38:21 <geekosaur> hm, that should be finding it then
17:39:07 <zipper> geekosaur: Yeah feels like sorcery. I'm thinking of compiling ide-backend locally in a sandbox with ide-backend-server as a dep.
17:40:04 <zipper> geekosaur: Then adding that newly installed ide-backend to the current project via `cabal sandbox add-source`
17:40:08 <geekosaur> but I spent years in csh on Altos systems since that was what I started out on in the 1980s :)
17:40:26 <geekosaur> mm, you can try that, yes
17:41:03 <geekosaur> I wonder if just building all this in a sandbox would work since the sandbox stuff will set up a sandbox bin directory *and* look in it itself without $PATH changes or etc. needed
17:41:40 <geekosaur> this being from fpcomplete they probably assume you're installing in a sandbox anyway :)
17:41:47 <zipper> First I'll restart just because...
17:42:31 <zipper> because I believe in the exorcist powers of a restart.
17:42:52 * geekosaur usually regards that as a bug to be fixed, but he's increasingly in the minority there :/
17:43:30 <zipper> geekosaur: Yeah feels like a bug to me too. Luckily I'm in a position to influence change or fix it.
17:43:56 <knite> so I installed happy. still unable to install hlint, now failing with error: Could not find module ‘Language.Preprocessor.Unlit’ while doing "Preprocessing library haskell-src-exts-1.16.0.1".
17:44:07 <knite> can share full traceback if needed.
17:44:28 <zipper> I feel that I gave a lot of "personal" info in those pastes. I hope google won't index them because they are secret pastes. Am I right?
17:45:08 <zipper> knite: This happening in a sandbox?
17:45:28 <knite> zipper: no idea, only if cabal uses a sandbox by default.
17:45:29 <zipper> knite: try `cabal install haskell-src-exts`
17:45:39 <knite> (I'm on latest versions of everything)
17:45:54 <zipper> knite: It doesn't. Try that first. It has worked for me sometimes.
17:46:15 <knite> zipper: still fails, same error.
17:46:17 <srhb> knite: Full output would be nice :) lpaste.net
17:46:39 <zipper> Cabal doesn't use a sandbox by default. It's a good idea to learn about sandboxes early.
17:46:45 <knite> https://gist.github.com/pikeas/a73fbe38a1a0e965fd78
17:47:10 <knite> zipper: so you're suggesting I read about sandboxes, and then try again inside of one?
17:47:37 <zipper> knite: You can't be seriously doing these things as root, are you?
17:47:39 <srhb> knite: That too, but you also have broken packages
17:47:44 <srhb> And yeah, no using root :-)
17:47:48 <zipper> knite: Not specifically.
17:47:48 <knite> zipper: docker container.
17:47:55 <zipper> knite: Oh
17:48:02 <knite> srhb: err, why might my packages be broken?
17:48:25 <srhb> knite: I don't know that.
17:48:32 <srhb> But you can unregister the offending package and try again
17:48:38 <zipper> Yeah the issue seems to be with the package itself.
17:48:44 <srhb> ghc-pkg unregister
17:48:57 <srhb> On the cpphs one
17:49:48 <zipper> What I do at these times is download the source. Fix what is broken and install fixed package into a sandbox then use that. Which is probably too much for you right now.
17:49:55 <srhb> Whether you can recover that, I'm not sure
17:49:57 <JamesJRH> I understand why ‘join . return’ has type:
17:49:58 <JamesJRH> :t join . return
17:49:59 <lambdabot> Monad m => m a -> m a
17:50:31 <JamesJRH> But why does ‘join return’ have type:
17:50:34 <JamesJRH> :t join return
17:50:35 <lambdabot> a -> a
17:50:38 <knite> zipper: that is absolutely correct, I am in no position to learn the Haskell packagement system in depth and tinker with packages yet.
17:50:38 <JamesJRH> ?
17:51:01 <srhb> JamesJRH: Sounds like Reader Monad
17:51:07 <zipper> knite: Try what srhb said.
17:51:12 <knite> I unregistered cpphs and ran cabal install hlint. failing with a new error, this time while build cpphs.
17:51:22 <srhb> knite: That sounds like the real error
17:51:31 <srhb> Unless it's just another broken package
17:51:49 <knite> okay, as a sanity check, trying this in a new container (the beauty of docker).
17:52:09 <JamesJRH> srhb: Join and return are for any monads though.
17:52:27 <srhb> JamesJRH: Yes, but join return might not typecheck for any m
17:53:11 <JamesJRH> I would have expected ‘join return’ to fail.
17:53:25 <srhb> JamesJRH: Try replacing m with (r ->)
17:53:40 <JamesJRH> It's as if the functions themselves are being monads.
17:53:50 <srhb> JamesJRH: That is exactly what the Reader monad is
17:53:53 <jle`> there is actually a Monad instance for (->) r
17:53:55 <JamesJRH> Oh.
17:54:01 <jle`> :t join
17:54:02 <lambdabot> Monad m => m (m a) -> m a
17:54:10 <jle`> join :: (r -> (r -> a)) -> (r -> a)
17:54:20 <jle`> :t return
17:54:20 <lambdabot> Monad m => a -> m a
17:54:24 <jle`> return :: a -> (r -> a)
17:54:32 <jle`> return = const, of course
17:55:04 <jle`> finding an implementation for join that follows the rules is the interesting part :)
17:55:15 <zipper> geekosaur: I figured that ide-backend server need not be a build depend for my app. So I removed it from build depends and it worked.
17:55:24 <zipper> geekosaur: I'm in shock lol
17:55:38 <JamesJRH> Wow. This is somewhat blowing my mind! :-)
17:55:41 <zipper> geekosaur: but why did it refuse to work as a build depend?
17:55:46 <srhb> JamesJRH: Good! :-)
17:55:55 <srhb> JamesJRH: Haskellers need their dose of mind-blowage.
17:55:55 <zipper> jle`: How does thee?
17:56:15 <zipper> srhb: Mind blowage is the reason I haskell to this day.
17:56:15 <JamesJRH> I hadn't read about the Reader monad yet, but this seems very interesting.
17:56:18 <jle`> zipper: well thanks, you? :)
17:56:32 <JamesJRH> Lol.
17:56:34 <geekosaur> possibly because nothing was using it as an executable so it assumed a library?
17:56:37 <zipper> So much to learn so many good people willing to teach. Awesome.
17:56:49 <JamesJRH> :-)
17:56:51 <zipper> geekosaur: Makes sense.
17:57:16 <knite> failed again from a clean straight, yet another different error. got past building five thousand different things (sidenote, why is it building so many different things?), only to fail with: ghc: out of memory (requested 2097152 bytes) partway through building haskell-src-exts-1.16.0.1.
17:57:17 <geekosaur> but if you're just using ide-backend then that's what you need as a lib dependency; ide-backend-server is a *runtime* dep, which is completely beyond cabal's kenb
17:57:20 <knite> clean slate*
17:57:20 <geekosaur> *ken
17:57:27 <zipper> jle`: I'm very much okay. I had to pause my exploration of auto though. PAUSE. I shall go back to it soon.
17:57:41 <zipper> Well in a few months.
17:57:59 <srhb> JamesJRH: Anyway, did you figure it out? You can do it without actually knowing the implementation of join (by unifying the expanded types of return and join)
17:58:00 <jle`> :D hope you're doing fulfilling work in any situation
17:58:07 <knite> all I want to do is lint my Haskell code so I can figure out how to make my newbie Haskell better. :-(
17:58:10 <zipper> geekosaur: cabal's ken?
17:58:26 <geekosaur> idiom. "knowledge" roughly (borrowed from Scots Gaelic, IIRC)
17:58:47 <zipper> jle`: Fulfilling, scary and many more words but not boring that's for sure.
17:58:59 <jle`> that's the best :3
17:59:01 <zipper> geekosaur: Thanks.
17:59:39 <geekosaur> knite, what version of ghc and how much memory do you have? 7.10.1 has some known memory explosion issues they're still trying to figure out, and IIRC haskell-src-exts is one of the things that can trigger it
17:59:51 <knite> yes, I'm on 7.10.1
18:00:17 <knite> is there a way for me to install a precompiled version of this lib in the interim?
18:00:31 <knite> would probably need to blow away my docker host VM to bump the memory up.
18:00:52 <geekosaur> sometimes setting a heap limit on ghc can fix it (`export GHCRTS=-M2g` to limit to a 2GB heap; experiment to find one that helps)
18:01:24 <knite> geekosaur: so GHCRTS=-M2g cabal install ...?
18:01:49 <knite> because it was cabal triggering the failure. will it pass through the opt, or do I actually need to export it temporarily?
18:01:53 <geekosaur> might work but would have to be repeated each time, which is why I gave the `export` version
18:02:06 <geekosaur> that *is* a temporary export, via the shell
18:02:14 <knite> er, right. sorry, long day.
18:02:34 <knite> "Most RTS options are disabled. Link with -rtsopts to enable them"
18:02:53 <rvxi> hey
18:03:17 <rvxi> anyone familiar with bindings-DSL
18:03:17 <rvxi> ?
18:04:56 <geekosaur> knite, cabal-install may produce that, don;t worry about it. ghc itself has them turned on but every haskell program run under it will check and many of them will emit that warning
18:05:16 <geekosaur> (which is unfortunate but there's no easy way to set it just for ghc)
18:05:28 <knite> geekosaur: well, cabal install immediately exits with that message, and does not proceed to installation.
18:05:37 <geekosaur> (and no good way tot ell other ones to shut up...)
18:05:45 <geekosaur> oh. that's bad
18:06:23 <geekosaur> I'd be tempted to report that as a bug because it complicates things, in this case you may need a wrapper script to do it. or weird extra options
18:06:38 <JamesJRH> srhb: Yes. It's funny how this Reader monad just jumped out at me, as if it was lurking there, rather than waiting for me to get on to reading about it.
18:06:49 <srhb> JamesJRH: :-)
18:07:17 <marchelzo_> This question is not directly Haskell related, but would there be much difference in performance between running a websockets server and a spock server on two threads of the same executable, and running two separate executables?
18:07:21 <knite> geekosaur: I'm fine with weird extra options, I just have no idea what they would be.
18:08:03 <geekosaur> like cabal install --ghc-option=+RTS --ghc-option=-M2g --ghc-option=-RTS ...
18:08:11 <JamesJRH> srhb: It's like the list monad – monads sound complicated but actually lists are 1 of the first things to be introduced to new Haskellers.
18:09:34 <geekosaur> (*maybe* can combine as --ghc-options="+RTS -M2g -RTS")
18:12:01 <zipper> Uh this isn't haskell specific but how can I fork and pull request a closed repo on github?
18:12:09 <zipper> Is this advisable or possible?
18:12:32 <byorgey> why would you want to make a pull request for a closed repo?
18:13:58 <zipper> Hmmm I'm not even sure it closed anymore.
18:14:07 <zipper> byorgey: I have access to it.
18:14:39 <zipper> I forked it and the fork ended up being public.
18:14:47 <rvxi> anyone know if it's possible to control unsafe qualifiers for bindings-DSL generated code?
18:15:23 <rvxi> finally got bindings-gsl working but the FFI overhead is way too much
18:15:25 <srhb> JamesJRH: I think one of the issues is that people think of monads before they think of specific monads, where the opposite is often more logical.
18:15:40 <srhb> JamesJRH: But I'm sure there's as many opinions on this as there are Haskellers :)
18:17:40 <guillep> Hi, I have a simple question, hope you can help, I want to know if in a list, the last element is greater than the previous element
18:18:09 <guillep> rises [0, 1] should be 1 and rises [0, 0] or rises [1, 1, 1] should be 0
18:18:21 <guillep> i defined this function: let rises = fst . foldl (\(_, x) y -> if (y > x) then (1, y) else (0, y)) (0, 0)
18:18:51 <srhb> That seems like an awful lot of work for just the last and second to last element
18:18:52 <guillep> I know it works, but, I couldnt find a way to express the function without the (,)
18:19:42 <marchelzo_> > let f xs = fromEnum $ (last $ init xs) < (last xs) in f [0,1]
18:19:43 <lambdabot>  1
18:20:46 <zipper> WOW I just ran a build that took so long that I am sure I've done something wrong.
18:21:00 <guillep> I want to use the function as a computation from signal to signal, as in FRP 
18:21:11 <guillep> you have this "fold from the past" feature
18:21:16 <exio4> zipper: check if you're not doing too many things in the type system :p
18:21:44 <srhb> guillep: Maybe instead you could zip with the past?
18:21:46 <exio4> zipper: maybe computing the length of a type-level list is the thing that's taking so much time there!
18:21:53 <guillep> that works like this: foldp :: (a -> b -> b) -> Signal a -> Signal b
18:22:23 <zipper> exio4: I'll investigate. I must.
18:22:36 <zipper> exio4: However, I fear code once it grows to a certain size.
18:22:49 <random_user> hello, i have a question: are constructors types? adts seem to define many constructors that map to one type. can i define a function that only applies to one constructor?
18:23:01 <srhb> guillep: If you zipped up the list with the list itself offset with one, you're always working on the current element and can drop the tuple
18:23:11 <srhb> random_user: There are type constructors and value constructors
18:23:26 <srhb> random_user: Type constructors go on the left hand side of the equals sign in datadecls, value constructors on the RHS
18:23:31 <srhb> random_user: Sometimes they have the same name.
18:23:32 <JamesJRH> srhb: I've made a leap in the last few weeks in understanding monads. I have to say that a major barrier to understanding has been that my first introduction to monads introduced (>>=) before return/unit and join. My initial idea of what (>>=) did was wrong, and made it difficult to understand the rest of it.
18:23:53 <srhb> JamesJRH: I had much the same experience. 
18:24:10 <JamesJRH> srhb: Having taken another crack at getting to understand monads, I saw a different explanation coming from category theory. Map, unit, and join are _really_ easy to understand, and seeing a definition for (>>=) in terms of these meant that I could create a new mental model that I could verify to be consistent with fmap/return/join.
18:24:13 <srhb> JamesJRH: But join isn't always more logical than (>>=)  -- but it is often more easy to define
18:24:25 <srhb> JamesJRH: Sounds good :)
18:24:57 <shachaf> It seems that everyone says "oh, the introductions to monads that I read were terrible; the right way to write an introduction is X", and then they write X.
18:25:00 <guillep> srhb: Thank you that sounds better
18:25:14 <shachaf> But it turns out that X has the same issue. I think byorgey wrote a post about it.
18:25:24 <srhb> Isn't it the monad tutorial fallacy post?
18:25:34 <jle`> yeah i think for a lot of instance,s understanding their behavior using join and fmap is a lot eaiser than in return.  i don't think it's an issue about learning monads in general, it's just an issue for learning specific instances
18:25:46 <jle`> s/return/bind
18:25:59 <random_user> srhb: ok thanks. it's confusing when they are named them the same.
18:26:13 <jle`> random_user: indeed!
18:26:13 <srhb> random_user: It stops being confusing. :)
18:26:20 <JamesJRH> srhb: I actually find the direction of the arrows misleading; I now think of it more like a map function taking the function from the right and applying it to the left, then joining, whereas for a long time previously I tried to think of it something like taking the value ‘out’ of the monad, and passing it to the right.
18:26:23 <srhb> Oh, I guess there are differing opinions there :P
18:26:46 <shachaf> ((((a -> r) -> r) -> r) -> r) -> (a -> r) -> r is a slightly scary type.
18:26:49 <srhb> JamesJRH: It makes sense in the "sequencing model"
18:27:00 <srhb> Or at least I think so.
18:27:09 <jle`> haha. i always feel like value and type constructors having the same name is a little awkward
18:27:11 <srhb> Anyway, whatever makes it click might be very individual indeed. :)
18:27:16 <jle`> but that doens't stop me, i always do it
18:27:25 <JamesJRH> Except that you can't really take a value out of any monad.
18:27:33 <srhb> jle`: Consider it preparation for DependentHaskell! :-)
18:27:46 <srhb> JamesJRH: A value in a monad is a bit of a lie anyway
18:27:48 <jle`> but they're different things, though
18:27:56 <JamesJRH> Like sure, take the value out of [4] and you get 4, but what about [1..]?
18:27:58 <jle`> it's like saying data Maybe a = Nothing | Maybe a
18:28:02 <srhb> JamesJRH: Some monadic values can be made into non-monadic values :)
18:28:59 <jle`> but that has nothing to do with their monad-ness.  that's like saying "some monadic values are [] and you can (:), tail, and head them."
18:29:14 <srhb> Yes.
18:29:17 <shachaf> JamesJRH: One perspective being good doesn't make another perspective bad.
18:29:32 <shachaf> With that said, "taking the value out" is almost certainly a bad perspective.
18:29:53 <shachaf> But for "do { x <- [1,2,3]; ... }", it's a useful perspective that x is simultaneously 1, 2, and 3.
18:30:40 <shachaf> Also, a "monad" is a thing like IO or Maybe, not a thing like IO String or Maybe Int, or like getLine or Just 5.
18:32:35 <pacak> > [1..4] >>= \a -> [1..4] >>= \b -> guard (a + b == 3) >> return (a, b)
18:32:37 <lambdabot>  [(1,2),(2,1)]
18:33:03 <JamesJRH> shachaf: My first impression of (>>=) was ‘taking the value out’ and I had that until only a few weeks ago, and I got nowhere with understanding monads. So I'm actually saying more that the old way is bad – the new way seems to work but I don't know whether it's really good yet.
18:33:25 <pacak> for all a and b from 1 to 4 filter out all the combinations with sum is not equal to 3
18:33:39 <exio4> JamesJRH: there's no model that fits everybody 
18:33:44 <shachaf> JamesJRH: Yes, "taking the value out" is a bad intuition, because there's no value in there in the first place.
18:33:57 <shachaf> But that doesn't mean that (>>=) is a bad thing to use as intuition.
18:35:21 <pacak> (>>=) is just a function which does different things in different monads and you can see how it's defined for every one of them.
18:36:48 <srhb> pacak: That's a bit misleading too.
18:37:02 <srhb> It's not "just" a function. It _should_ obey certain laws.
18:37:17 <srhb> But anyway, this discussion is probably not going to be productive. :P
18:37:56 <JamesJRH> I still don't completely understand do notation actually, but I never did with the old model either. I do understand it a bit more now though, as I can see how some things can be converted to or from using (>>=) and (>>), both of which I now understand in terms of fmap, return, and join.
18:38:24 <shachaf> There's a lot of value to the join perspective, especially now that Applicative is around.
18:38:27 <JamesJRH> I understand the laws, too.
18:38:52 <JamesJRH> (Now.)
18:39:26 <shachaf> E.g. join (f <$> x <*> y)
18:39:44 <shachaf> In fact I think join should be in the class. Wasn't it going to?
18:40:21 <pacak> srhb: If you take it from a Monad typeclass it will be obeying certain laws,but yea, in general Monads are warm and fuzzy things, similar to burritos
18:40:38 <srhb> ...
18:41:08 <JamesJRH> 01:29:31 < shachaf> But for "do { x <- [1,2,3]; ... }", it's a useful perspective that x is simultaneously 1, 2, and 3.  ← Yes, this is how I first thought of it, but I failed to understand how this can be reconstructed into a new monad instance* elsewhere.
18:41:28 <srhb> JamesJRH: do notation is simple. do { bar <- foo; ... } is just foo >>= \bar -> do ...
18:41:36 <jle`> ~.
18:42:02 <shachaf> srhb: Except when it isn't! See https://ghc.haskell.org/trac/ghc/ticket/10381
18:42:17 <srhb> shachaf: Do you have a macro for that? You always bring it up when I say it's simple. :P
18:42:17 <JamesJRH> * Btw., is ‘monad instance’ the correct name for things like [1,2,3]?
18:42:39 <srhb> JamesJRH: That's just a list of numbers
18:42:40 <shachaf> JamesJRH: "action" is popular.
18:42:50 <shachaf> [1,2,3] :: [] Int is a []-action.
18:42:51 <geekosaur> that'd be one heck of a macro...
18:42:51 <JamesJRH> As in: 01:30:18 < shachaf> Also, a "monad" is a thing like IO or Maybe, not a thing like IO String or Maybe Int, or like getLine or Just 5.
18:42:59 <shachaf> (This is unrelated to "group action", unfortunately.)
18:44:03 <srhb> Oh, that link wasn't actually what I thought it was
18:44:06 <srhb> (But similar)
18:44:24 <JamesJRH> So list is a monad but [1,2,3] isn't? It's an instance? How do I refer to things that are of a monad?
18:45:32 <srhb> I really dislike the notion of instance at least. Action, monadic value, something like that
18:45:38 <srhb> List is an instance of Monad
18:45:41 <geekosaur> monadic value.
18:45:45 <srhb> That is the only sense in which we use instance in Haskell
18:45:50 <JamesJRH> 01:41:06 < srhb> JamesJRH: do notation is simple. do { bar <- foo; ... } is just foo >>= \bar -> do ...  ← Yes, that is 1 of the conversions that I understand.
18:46:04 <JamesJRH> geekosaur: Thanks!
18:46:10 * hackagebot cabal-dependency-licenses 0.1.1.1 - Compose a list of a project's transitive dependencies with their licenses  http://hackage.haskell.org/package/cabal-dependency-licenses-0.1.1.1 (JasperVanDerJeugt)
18:46:16 <JamesJRH> Of course, I've heard that before actually.
18:46:33 <srhb> JamesJRH: Excluding let blocks and such that's really all there is to it
18:46:40 <kadoban> JamesJRH: It's just a list. List is an instance of Monad, but there's not much point calling it a Monad, unless you're talking about doing something using the Monad instance in particular, since it's also /many/ other things, like Functor, Applicative, etc.
18:46:57 <geekosaur> but that is misleading because if I'm using something like (Just 5), I am not necessarily using it in the context of a monad; the monad is the operations, not the value
18:46:58 <srhb> JamesJRH: do { foo; bar; ... } is just foo >> bar >> do ...
18:47:11 <pacak> :info []
18:47:21 <JamesJRH> srhb: There are some aspects of do notation that I still can't make consistent with my understanding from fmap/return/join.
18:47:23 <geekosaur> and one of the points of monads is that they are general, so many different kinds of values may be appropriate for use with some particular monad
18:47:30 <kadoban> JamesJRH: So if you're specifically talking about (>>=) or return or some other higher-level Monad usage of list, then it's the list monad, otherwise … it's just a list.
18:47:34 <srhb> JamesJRH: Hmm. Not sure why that is. :)
18:47:56 <srhb> kadoban: You're conflating things now, I think.
18:48:30 <srhb> kadoban: Calling [1,2,3] "just a list" when the problem is that [] is a monad while [1,2,3] isn't, I mean.
18:49:18 <JamesJRH> 01:46:36 < srhb> JamesJRH: do { foo; bar; ... } is just foo >> bar >> do ...  ← Yes, this is another thing that I understand.
18:49:29 <srhb> JamesJRH: Then you're done. Woo! :-)
18:49:30 <JamesJRH> I don't understand the fail part.
18:49:50 <kadoban> srhb: I was speaking about list in general, but I don't really have a problem calling [1,2,3] a monadic value, if you want to call it that.
18:50:20 <JamesJRH> srhb: How can the fail mechanism be converted from/to do?
18:50:58 <miscyb> does anyone have an example of using openid with yesod? i'm having a little trouble figuring it out
18:50:59 <srhb> > let x = [] in x >>= \(x:xs) -> undefined
18:51:00 <lambdabot>  []
18:51:14 <srhb> Wait, that's not actually fail, is it?
18:51:20 <geekosaur> `fail` is just something you can do in the context of a monad. its main relationship to do is that it's transparently invoked for failed pattern matches
18:52:00 <kadoban> JamesJRH: fail is generally to be avoided anyway, I believe is the general concensus, it's kind of a wart
18:52:38 <JamesJRH> kadoban: That sounds like what my first impression of it was. :-]
18:53:04 <geekosaur> that is, if you say do { 6 <- something_that_produces_Just_5; ... } in the Maybe monad, the pattern fails (6 /= 5) and `fail` is used
18:53:53 <JamesJRH> kadoban: I think that the first I was introduced to it was ‘this isn't really part of a real monad but it's here anyway just for do notation’.
18:54:31 <geekosaur> and in general it's a good idea to avoid it, especially since there are still arguments going on over that pattern match thing and MonadZero might just make a comeback (that is, a MonadZero instance would provide something in place of `fail`, or otherwise just the usual pattern match exception would be thrown or something)
18:54:41 <kadoban> JamesJRH: That sounds pretty much like my understanding.
18:55:13 <geekosaur> `fail` was more or less a hack for that pattern matching case
18:56:19 <JamesJRH> Okay, so it seems that my understanding is now good enough for everything except fail, which I don't really need anyway.
18:56:29 <srhb> Yep
18:57:08 <exio4> geekosaur: 'MonadZero might just make a comeback'? really? \o/
18:58:18 <geekosaur> the discussion/argument continues, but there seems to be a rough consensus that the decision to switch to `fail` was a mistake
18:58:36 <geekosaur> when it might happen, though, who knows
18:58:58 <geekosaur> someone just mentioned MonadZero in #ghc though so maybe it's closer than I think
18:59:27 <geekosaur> (as a `do` desugaring, in discussion of an open ticket)
19:00:08 <JamesJRH> Ignoring fail, I can convert do notation to/from (>>=) and (>>), and can convert those to/from fmap/return/join. I don't necessarily have to constantly think about fmap/return/join, but they to me are a firm point of reference to verify any ‘higher level’ mental models or shortcuts that I may come to use.
19:00:58 <geekosaur> right. that said, I find that >>= makes the most sense with the IO monad, and most other monads are most easily understood in terms of fmap/join
19:01:21 <geekosaur> notably, the list monad makes a lot more sense when thought of in those terms
19:01:38 <geekosaur> (fmap ~ map, join ~ concat)
19:04:00 <RyanGlScott> I'm trying to understand better how GHC handles mutually recursive data types w.r.t deriving declarations.
19:04:04 <RyanGlScott> For example, if you have:
19:04:10 <RyanGlScott> data One a = One (Two a) deriving Show; data Two a = Two (One a) deriving Show
19:04:30 <RyanGlScott> By what process does GHC infer that One and Two both have phantom types in their respective Show instances?
19:07:45 <meretrix> Say I have "data X = X { x1 :: Int, x2 :: Double, x3 :: [Int] }" and a JSON value of unknown schema {"x2": 3, "x4":1.23}.  Is there an easy to update my Haskell data type with the JSON values whose keys have matching record fields?
19:07:52 <JamesJRH> s/monad instance/monadic value/ in:
19:07:56 <JamesJRH> 01:40:46 < JamesJRH> 01:29:31 < shachaf> But for "do { x <- [1,2,3]; ... }", it's a useful perspective that x is simultaneously 1, 2, and 3.  ← Yes, this is how I first thought of it, but I failed to understand how this can be reconstructed into a new [monadic value] elsewhere.
19:10:56 <kaidelong> https://launchpad.net/~hvr/+archive/ubuntu/ghc/+index?batch=75&memo=75&start=75 does anyone use this PPA?
19:11:13 <kaidelong> I'm trying to install ghc-7.8.4 with it but it appears to not put the ghc binary anywhere in the PATH
19:11:30 <kaidelong> I'm at a loss what to do
19:11:52 <kaidelong> I can't get GHC 7.8.4 to build from source or get the binary package to work
19:12:10 <RyanGlScott> hvr's repo doesn't put the binary in the PATH by default.
19:12:15 <RyanGlScott> From the PPA description:
19:12:21 <RyanGlScott> The packages install into `/opt/ghc/$VER/` so in order to use them, the easiest way is to bring a particular GHC version into scope by placing the respective `/opt/ghc/$VER/bin` folder early into the PATH environment variable.
19:12:30 <kaidelong> oh okay
19:12:49 <kaidelong> so I need to put my desired version of ghc in my path somehow
19:13:34 <kaidelong> that would be what ~/.profile is for?
19:14:07 <RyanGlScott> I use ~/.bashrc/~/.bashprofile, but at long as it gets run when your terminal opens, everything should be good.
19:14:52 <JamesJRH> shachaf: With a model based on fmap, it's easy to understand what order the result will be in. But with the take-it-out model, I started trying to think of it as the list being emptied and then refilled somewhere else, but this doesn't scale to more abstract concepts at all.
19:18:19 <JamesJRH> Does the ‘r’ in ‘(r ->)’ stand for Reader?
19:18:31 <johnw> usually it stands for result
19:18:48 <JamesJRH> Hmm.
19:18:52 <JamesJRH> :t join liftM
19:18:53 <lambdabot> (r -> r) -> r -> r
19:18:59 <JamesJRH> :t join fmap
19:19:00 <lambdabot> (b -> b) -> b -> b
19:19:11 <JamesJRH> What is that ^ the case?
19:19:18 <JamesJRH> Why*
19:19:19 <johnw> there it doesn't mean anything
19:20:15 <johnw> I doubt "join fmap" is what you mean though
19:20:31 <johnw> since the only legimate argument I think that could accept is a polymorphic "id"
19:20:38 <johnw> i.e., join fmap id = fmap id id
19:20:57 <JamesJRH> No, I found that by accident.
19:20:58 <johnw> which is the same as: id
19:22:17 <JamesJRH> Actually before ‘join return’, then tried to find a simpler example before asking what is going on with it.
19:23:08 <JamesJRH> That simpler (probably _simplest_) example being ‘join return’.
19:23:31 <shachaf> ?
19:23:33 <shachaf> join fmap (+1)
19:23:48 <johnw> ah, of course
19:24:02 <johnw> join fmap f is just fmap f f or f . f
19:24:14 <JamesJRH> johnw: Which is just id:
19:24:15 <JamesJRH> :t join return
19:24:16 <lambdabot> a -> a
19:24:21 <johnw> doesn't have to be id
19:24:28 <johnw> > join fmap (+1) $ 4
19:24:29 <lambdabot>  6
19:26:08 <JamesJRH> @pl join return
19:26:08 <lambdabot> join return
19:26:29 <johnw> JamesJRH: what are you thinking of with "join return'?
19:28:29 <JamesJRH> johnw: It's just the simplest thing that I found that reveals what I now understand to be the result of the Reader monad.
19:28:52 <JamesJRH> But is there any way that it's not id?
19:29:09 <JamesJRH> :t id
19:29:10 <lambdabot> a -> a
19:29:11 <JamesJRH> :t join return
19:29:12 <lambdabot> a -> a
19:29:16 <JamesJRH> @pl join return
19:29:16 <lambdabot> join return
19:29:48 <JamesJRH> Maybe that's just something that hasn't been added to the rules for Pl.
19:30:11 <johnw> so, join return x is return x x, which means that "return x" must be a function to which x can be applied
19:31:46 <johnw> i'm just not sure yet what value knowing this has...
19:31:50 <johnw> can you provide more context?
19:32:09 <geekosaur> JamesJRH, @pl only returns points that yoiu declared as such
19:32:13 <JamesJRH> Is it true that anything with the type ‘a -> a’ is the same as id?
19:32:19 <geekosaur> @pl \x -> whatever x
19:32:19 <lambdabot> whatever
19:32:42 <geekosaur> it has no idea what names are functions or etc., so it rlies on you to tell it which points to remove
19:32:43 <johnw> JamesJRH: only if you exclude undefined, error, and exceptions
19:33:06 <johnw> and ⊥ in general, in fact
19:33:10 <geekosaur> @pl \whatever -> whatever x
19:33:10 <lambdabot> ($ x)
19:33:24 <JamesJRH> Okay, so maybe it's actually right to not simplify this.
19:34:20 <geekosaur> and no, it's not really smart about optimization
19:34:58 <geekosaur> there are things it could do but never tries, and the ones it does know about it sometimes applies stupidly, producing really dumb expansions that nobody would actually write
19:35:30 <JamesJRH> geekosaur: It does have a bunch of things that it recognises, including id in fro example:
19:35:33 <JamesJRH> @pl \x -> x
19:35:33 <lambdabot> id
19:35:36 <geekosaur> sure
19:35:43 <JamesJRH> for*
19:36:07 <geekosaur> but, hm, I'm not remembering now but there's one thing where it could produce a liftM2 (or liftA2 in 7.10.1) but produces some big ungainly thing instead
19:36:17 <geekosaur> it's just dumb
19:36:51 <dolio> Sometimes it produces code that's not well typed, too.
19:36:57 <geekosaur> true
19:37:30 <JamesJRH> geekosaur: I just wondered whether ‘join return’ was left as it is because it can't be simplified (i.e. not necessarily id), or because Pl doesn't have an appropriate rule.
19:38:23 <julianleviston> I’m a bit of a newbie to Haskell. Why do I have to explicitly tell the compiler when I’m using a Maybe and when I’m just using a value?
19:38:24 <dolio> join return is definitely id. It just doesn't recognize it.
19:38:26 <geekosaur> I'm not sure how hard it even looks for rules if it doesn't find any points to remove
19:39:04 <julianleviston> I should qualify - I’ve been learning Haskell for months, and I’m not new to FP or programming at all.
19:39:30 <geekosaur> julianleviston, that's kinda the whole point of Maybe? if it were automatic then there'd be no practical difference from Perl's undef / Python's None / etc. and in particular you could easily write code that forgets to check for it
19:39:45 <julianleviston> geekosaur: why can’t it infer it?
19:40:09 * geekosaur suspects the point he tried to make didn't land anyewhere
19:40:12 <athan> julianleviston: It can
19:40:15 <geekosaur> in theory it could infer it
19:40:16 <athan> :t Just 1
19:40:17 <lambdabot> Num a => Maybe a
19:40:18 <julianleviston> geekosaur: sorry man!
19:40:32 <johnw> Haskell's Maybe is a hard requirement on the caller to handle the case of failure, even if the caller chooses to throw up his hands and call error or fromJust
19:40:48 <geekosaur> the question is, why do you want to turn off the compiler protecting yourself from unexpected failure
19:40:52 <athan> Also, did someone whisper "type holes"? :)
19:40:54 <julianleviston> johnw: ooh there’s a fromJust ?
19:40:59 <johnw> haha
19:41:01 <julianleviston> geekosaur: I don’t.
19:41:13 * hackagebot doctest-prop 0.2.0.1 - Allow QuickCheck-style property testing within doctest.  http://hackage.haskell.org/package/doctest-prop-0.2.0.1 (TakayukiMuranushi)
19:41:14 <johnw> fromJust should be called missingThePoint
19:41:20 <geekosaur> apparently you do though
19:41:26 <julianleviston> johnw: I don’t miss the point.
19:42:09 <julianleviston> Pretty sure I understand the ramifications of this. Inference isn’t lack of types, though… obviously.
19:42:28 <athan> somebody did say type holes :D
19:42:33 <johnw> fromJust is like saying, "I know you have information to tell me, but I'm going to ignore it"
19:42:33 <athan> :t Just 1 :: _ Integer
19:42:34 <lambdabot>     Found hole ‘_’ with type: Maybe
19:42:34 <lambdabot>     To use the inferred type, enable PartialTypeSignatures
19:42:34 <lambdabot>     In an expression type signature: _ Integer
19:43:16 <geekosaur> ok, so you just want it to infer that it should turn 1::Integer into Just 1::Maybe Integer, the way it turns a literal 1 into (fromInteger 1::Num a => a)
19:43:31 <geekosaur> which can also be done, but gives the compiler a lot of rope to hang you with
19:43:41 <athan> > "> \"> 1+1\""
19:43:43 <lambdabot>  "> \"> 1+1\""
19:43:45 <geekosaur> and hang you it will, because it will find more ways to use that than you imagined
19:43:46 <athan> damn!
19:44:22 <geekosaur> type inference is quite powerful, and if you take off the brakes it will run you headlong into a tree
19:44:31 <julianleviston> geekosaur: HEHE :)
19:44:54 <johnw> athan: so list was faster, eh?
19:45:07 <athan> johnw: yeah ._. I need to profile more
19:45:21 <johnw> in Haskell it pays not to think operationally until you need to
19:45:28 <athan> :)
19:45:41 <mvc`> hi, can anyone recommend a good library for curve fitting in haskell?
19:45:44 <johnw> unlike C++ where people will consider memory layout of structs from the very first moment
19:45:45 <julianleviston> geekosaur: It seems that a lot of what’s perceived as complexity about haskell is kind of incidental (to me)… Isn’t it better to mark when things are definitely some type than mark when things are maybe some type?
19:45:53 <geekosaur> one tempting thing people try to do is define new Num instances that let them do clever things. but combined with type inference, the compiler will use those instances cleverly and come up with things you could not have guessed. Function instances are a common way to go wrong here
19:47:09 <julianleviston> geekosaur: I’m probably missing something further study would explain… I should digest more, most likely.
19:47:45 <JamesJRH> Type holes?
19:47:46 <athan> johnw: I still find myself thinking in terms of folds, or "how to start at the problem best", or "how to solve the problem 'in one pass'"
19:47:51 <geekosaur> (for instance one could define instance Num a => Num (Maybe a) and now it will infer those Just-s for you. but also a whole bunch of programming errors will also quietly slip past and possibly be revealed later as bizarre type mismatches because the compiler tried to fix the mismatch by inserting Just-s in random places
19:47:59 <JamesJRH> Mind blowage.
19:48:09 <athan> it's like jeez, don't we have automated theorem provers to write my code for me? sheesh
19:48:16 <julianleviston> hm
19:48:20 <geekosaur> (not really random but they will *look* random if you don;t understand how type inference works)
19:48:23 <julianleviston> I don’t think I’m saying that @athan
19:48:40 <johnw> athan: as best you can, think mathematically
19:48:51 <johnw> which is to say, "What are my inputs?  What do I want from my outputs?"
19:48:53 <geekosaur> and then show you the error as if you had inserted those Just-s yourself
19:49:10 <geekosaur> which is the headlong-into-a-tree bit
19:49:15 <julianleviston> geekosaur: I think maybe you’ve missed my point.
19:49:18 <athan> :t undefined :: _ -- JamesJRH
19:49:19 <lambdabot>     Found hole ‘_’ with type: w_
19:49:19 <lambdabot>     Where: ‘w_’ is a rigid type variable bound by
19:49:19 <lambdabot>                 the inferred type of it :: w_ at Top level
19:49:28 <johnw> a lot of times, a simple composition exists between what you have and what you want
19:49:32 <julianleviston> geekosaur: but that’s probably because I don’t understand enough.
19:49:47 <johnw> only in special cases do you need to break out your operational manual and build a custom path with very specific machine-level properties
19:49:48 <geekosaur> no, I gave you a way to do what you asked, and then tried to explain why it's a bad idea
19:50:23 <geekosaur> (you need a bit more than just the part of the instance declaration that I named, but it's easily doable)
19:50:28 <JamesJRH> athan: I think that I need to go before getting into this; I need to get some sleep.
19:50:34 <johnw> I've solved Haskell performance problems by adding more laziness and simplicity, rather than complex data structures
19:50:39 <julianleviston> geekosaur: yeah, I haven’t explained myself clearly enough, so … I need to study more so I can communicate more clearly, and possibly even understand things better
19:50:49 <JamesJRH> Thanks for your help and good night. \o
19:50:54 <julianleviston> :)
19:51:45 <geekosaur> yeh, I could think of two interpretations of what you asked and possibly neither was correct
19:52:04 <geekosaur> without a better description I'm not sure though
19:52:12 <julianleviston> There seems to be little difference between using Maybe and nil-checking in other languages, other than the compiler does all of the difficult parts for you. Topologically, there’s no difference.
19:52:46 <geekosaur> well, the main thing is that nil-checking in other languages you still have to do the check or get a runtime error
19:52:47 <julianleviston> Oh, and it’s a lot easier to use Maybe than it is to write all that nil-checking code!
19:52:55 <geekosaur> the point here is to get a *compile time* error
19:52:55 <julianleviston> geekosaur: yup!
19:53:00 <julianleviston> geekosaur: yeah, I get it :)
19:53:24 <geekosaur> and, well, maybe some of that confusion is that many of those languages that do nil/undef/None are interpreted, so compile and run time are very close together
19:53:29 <geekosaur> Haskell is compiled, like C
19:53:30 <geekosaur> or C++
19:53:47 <julianleviston> geekosaur: I’m not confused. I’m interested...
19:54:00 <geekosaur> and you'd kinda like your fancy web app to tell you you forgot to check for nil when building it, not when it's running
19:54:36 <johnw> julianleviston: the idea is to make ill-behaving code inexpressible or difficult to write, so that the "path of least resistance" leads to correct behavior
19:54:44 <geekosaur> 500 errors to the browser are rather more annoying to diagnose than errors from the compiler
19:54:56 <julianleviston> geekosaur: is hang on… dynamic isn’t against strong, right?
19:55:28 <athan> thank you johnw :) I'll keep cracking the nut
19:55:35 <geekosaur> not necessarily, but most dynamic languages take liberties with typing precisely because they are dynamic so it's easier for them to do so.
19:55:53 <julianleviston> geekosaur: Dependant types?
19:56:01 <geekosaur> dynamic but strict languages are possible and some even exist but none are very popular
19:56:22 <julianleviston> geekosaur: isn’t strictness vs laziness?
19:56:31 <julianleviston> geekosaur: or am I being confused here?
19:56:33 <geekosaur> strict types, not strict evaluation
19:56:42 <julianleviston> aha!
19:57:08 <julianleviston> I would call strict types strong types, I guess
19:57:24 <geekosaur> yeh, that's probably more commonly used
19:57:45 <julianleviston> geekosaur: what is your opinion of dependent types?
19:57:45 <ryantrinkle> i used Groovy a bit, which I think is an example of dynamic but strong types
19:57:49 <johnw> I'm not sure "strong" has much meaning in relation to type systems, does it?
19:58:07 <ryantrinkle> in that it was very unforgiving about type errors, but it also didn't check them at compile time
19:58:14 <ryantrinkle> it was pretty miserable to work with
19:58:23 <johnw> julianleviston: I program with dependent types
19:58:30 <julianleviston> johnw: ah!
19:58:43 <dolio> Are dynamic types a 'system'?
19:58:49 <geekosaur> I haven't used them very much although I know of them. I also know (a) lots of research still going on about them (b) because they tend to be fairly hard to use (c) and describing things like IO in dependent types can be downright brutal
19:58:53 <johnw> a system of one type!
19:59:03 <julianleviston> :)
19:59:45 <dolio> johnw: Obviously people are talking about proof theoretic strength of their type systems.
19:59:57 <johnw> oh yeah, obviously
20:00:16 <dolio> Can you prove the existence of ordinals larger than the Church-Kleene ordinal?
20:00:20 <johnw> I'd be happy if it just meant "no casting"
20:00:50 <julianleviston> I have one last question, I think… hopfully it’s not too newbie-ish, so apologies if it is...
20:01:08 <Cale> dolio: Its successor is easy to prove larger
20:01:34 <julianleviston> Could I easily create a function that takes a list of Maybe Ints and filter out the Nothings and turn it into a list of Ints ?
20:01:41 <johnw> catMaybes
20:01:44 <srhb> :t catMaybes
20:01:44 <johnw> :t catMaybes
20:01:45 <lambdabot> [Maybe a] -> [a]
20:01:45 <lambdabot> [Maybe a] -> [a]
20:01:47 <srhb> heh...
20:01:51 <julianleviston> pretty!
20:01:53 <dolio> Cale: Oh, right. I guess it's not about how big the things you can prove the existence of are, right? It's how big the smallest one you can't prove the existence of is?
20:02:04 <johnw> we have lots of utility with Maybe
20:02:07 <samba1> Is there a pattern for cascading Maybes where Nothing doesn't necessarily indicate failure? For instance, I could use MaybeT on this if Nothing always meant failure, but instead I want to do different things based on the above, so I get those long chain of Maybes creeping rightward.
20:02:11 <samba1> http://lpaste.net/1176421916383117312
20:02:54 <johnw> samba1: you could use the "maybe" function
20:02:54 <srhb> julianleviston: It's essentially equal to map fromJust . filter isJust
20:03:15 <johnw> samba1: but in your case, I think you've captured the typical usage
20:03:21 <julianleviston> srhb: ah… and because filter isJust, it’s safe?
20:03:30 <srhb> julianleviston: Yes. :)
20:03:31 <julianleviston> srhb: coz of the glue?
20:03:39 <julianleviston> srhb: such a fricking beautiful language.
20:03:40 <geekosaur> I wonder if this is just Alternative
20:04:03 <srhb> julianleviston: :)
20:04:19 <samba1> johnw: okay
20:04:38 <johnw> (someAction >>= justAction) <|> (backupAction >>= justActionInNothing <|> anotherBackupAction)
20:06:10 <samba1> yes, I thought about using alternative, I don't know if that's really any clearer, though, and I'd have to unwrap the results still I think
20:06:24 <johnw> not if you used fmap or >>=
20:06:50 <julianleviston> thanks all! laters :) <3
20:07:05 <samba1> but it's IO (Maybe x), so the bind will still yield a Maybe
20:07:08 <pleiosaur> shirt: where did you find that vagga tool?
20:07:22 <johnw> samba1: ahh
20:07:38 <johnw> i do wish for an easier way to lift IO (Maybe a) into MaybeT IO a
20:08:41 <samba1> me too, but even that doesn't help in my case. imperetive things are just ugly in haskell
20:09:43 <heatsink> Isn't MaybeT :: IO (Maybe a) -> MaybeT IO a ?
20:10:19 <samba1> yes, but doing that on every line makes me feel like I'm not making things any nicer
20:10:32 <heatsink> ah
20:11:04 <samba1> and in my case above, MaybeT just doesn't work all together
20:18:23 <jle`> johnw: why not MaybeT ...?
20:18:40 <jle`> the annoying thing is probably Maybe a -> MaybeT IO a, where you have to `maybe mzero return`
20:18:51 <jle`> or something like that
20:26:07 <knite> are happy and alex only executable tools? I see that the Haskell PPA installs the executable as well as a share directory, wondering if that's the source just for reference? can I blow away the share folders and move the executables to my cabal bin to tidy things up?
20:30:39 <RickP> When i define a function, can i pattern match on functions? If a function f takes an argument g of type (Num a => a -> a -> a), can i pattern match as f (+) = ... ? this doesn't work, it seems that this matches all functions and (+) is simply bound to the current function passed as argument
20:30:56 <jle`> RickP: yeah, you can only pattern match on constructors
20:31:28 <jle`> disregarding some fancy new language extensions
20:31:33 <RickP> my clever plan of putting functions in the ast is falling apart :-(
20:31:35 <Maxdamantus> RickP: would `(\a b -> a + b)` be the same as `(+)`?
20:31:49 <jle`> RickP: if you want, you can make your own data type
20:32:02 <RickP> Maxdamantus: yes, but wouldn't that have the same problem?
20:32:16 <RickP> meh, i would have to make one constructor per operator
20:32:19 <jle`> data Func a = Pure a | a :+ a | a :* a etc.
20:32:23 <RickP> no?
20:32:30 <jle`> yeah, or at least the ones you'd want to pattern match on
20:32:56 <RickP> i guess i'll just do it old school
20:32:57 <jle`> i think haskell doesn't really allow reflection on the structure of functions themselves
20:33:01 <RickP> store the operator as string
20:33:07 <Maxdamantus> You can't match on those constructors: (:+) etc
20:33:17 <jle`> really?
20:33:18 <RickP> and then in the evaluation function i'll handle each case separately
20:33:40 <Maxdamantus> > case a of Just -> 0
20:33:42 <lambdabot>      Constructor ‘Just’ should have 1 argument, but has been given none
20:33:42 <lambdabot>      In the pattern: Just
20:33:42 <lambdabot>      In a case alternative: Just -> 0
20:33:51 <jle`> Maxdamantus: (_ :+ _) then :P
20:34:00 <Maxdamantus> jle`: but that doesn't match (:+)
20:34:04 <Maxdamantus> (the function)
20:34:11 <Maxdamantus> you can't match on any functions.
20:34:24 <jle`> yeah, you aren't matching on functions
20:34:32 <jle`> you're matching on a data type encoding functions
20:34:55 <Maxdamantus> Though your type doesn't seem to encode functions.
20:35:11 <athan> jle': That's the ticket
20:35:32 <jle`> ah, i see what you mean :)
20:35:44 <jle`> it encodes values, doesn't it
20:36:48 <mniip> <jle`> i think haskell doesn't really allow reflection on the structure of functions themselves
20:36:57 <mniip> the issue here is, what functions are to be considered equal
20:37:34 <mniip> there isn't a finite way to check if two algorithms produce the same outputs for equal inputs
20:37:40 <jle`> well there's a difference between structural equality and non-structural equality.  i guess allowing inspection of functions in this way allows us to distinguish the two
20:37:43 <RickP> if you pattern match on something, this needs to be an instance of Eq right?
20:37:50 <jle`> RickP: no
20:37:53 <jle`> not on constructors
20:38:21 <jle`> head (x:xs) = x
20:38:26 <jle`> no Eq instance needed  :)
20:38:27 <bananagram> @hoogle a -> Text
20:38:27 <lambdabot> Data.Text.Lazy unfoldr :: (a -> Maybe (Char, a)) -> a -> Text
20:38:28 <lambdabot> Data.Text unfoldr :: (a -> Maybe (Char, a)) -> a -> Text
20:38:28 <lambdabot> Prelude id :: a -> a
20:38:29 <Iceland_jack> @let data NotEq = NOT | EQ deriving Show
20:38:30 <lambdabot>  Defined.
20:38:39 <Iceland_jack> :t let foo NOT = undefined in foo
20:38:40 <lambdabot> NotEq -> t
20:38:43 <Iceland_jack> :t let foo NOT = undefined in foo
20:38:44 <lambdabot> NotEq -> t
20:38:57 <hunteriam> what does 2^O(n) mean?
20:38:58 <RickP> oh yes i was only thinking about values
20:39:01 <hunteriam> in complexity theory
20:39:30 <Iceland_jack> For things like literals it does require Eq
20:39:37 <Iceland_jack> :t let f 0 = undefined in f
20:39:38 <lambdabot> (Eq a, Num a) => a -> t
20:39:43 <Iceland_jack> :t let f 3.14 = undefined in f
20:39:44 <lambdabot> (Eq a, Fractional a) => a -> t
20:40:33 <bananagram> has anyone made ShowText and ReadText typeclasses where showText :: a -> Text and readText :: Text -> a?
20:40:58 <bananagram> where showText is T.pack . show by default and readText = read . T.unpack
20:41:04 <Iceland_jack> Once upon a time (and it is written in reports of yore, that) Num was a subclass of Eq
20:41:16 <jle`> bananagram: why would it need to be a typeclass?  efficiency?
20:41:23 <bananagram> jle`, yeah
20:41:39 <bananagram> to use showText and readText as easily as show and read
20:41:48 <jle`> why can't you just say showText = T.pack . show
20:42:02 <lvella> hi, I found this package in hackage: http://hackage.haskell.org/package/minesweeper
20:42:03 <jle`> and readText = read . T.unpack
20:42:06 <bananagram> that would still be unperformant because it would create a list, wouldn't it?
20:42:11 <lvella> what is the easiest way to install it?
20:42:28 <lvella> with cabal, I tried $ cabal install minesweeper
20:42:45 <bananagram> that should be right
20:43:12 <lvella> but I got an error message: "cabal: There is no package named 'minesweeper'."
20:43:28 <srhb> lvella: Did you cabal update?
20:43:33 <athan> lvella: `cabal unpack minesweeper && cd minesweeper* && cabal sandbox init && cabal install && cabal exec minesweeper`
20:43:34 <lvella> yes:
20:43:42 <lvella> Skipping download: Local and remote files match.
20:44:11 <bananagram> it's not missing from my package list
20:44:32 <hunteriam> repeat: does anyone know what 2^O(n) = in complexity theory?
20:44:35 <srhb> lvella: Are you actually using hackage for cabal-install?
20:44:49 <lvella> I don't know
20:44:51 <shirt> pleiosaur: i was first looking into docker(fig, and compose), but was put off by the complexity and the fact that it requires root, and then i stumbled upon vagga through google
20:44:52 <ReinH> Iceland_jack: lol
20:44:57 <lvella> I did apt-get install cabal-install
20:45:10 <ReinH> Iceland_jack: yea verily, 'tis written
20:45:35 <srhb> lvella: And you didn't run one command with sudo and the other without?
20:45:36 <lvella> I also get this message when I try to install: Warning: The package list for 'hackage.haskell.org' does not exist. Run 'cabal
20:45:36 <lvella> update' to download it.
20:45:46 <srhb> ... funky
20:45:47 <lvella> no, both withou
20:46:07 <ReinH> lvella: did you try running cabal update?
20:46:07 <lvella> then I do cabal update
20:46:25 <ReinH> shirt: (fig is now docker-compose, btw)
20:46:29 <lvella> and it says "Local and remote files match."
20:46:34 <ReinH> shirt: what requires root?
20:47:17 <shirt> ReinH: docker daemon or something, the whole thing was way too complicated for me
20:47:47 <ReinH> shirt: it doesn't, you can make any user a member of the `docker` group
20:48:06 <ReinH> that said, access to the docker daemon is essentially equivalent to sudo access
20:48:14 <srhb> lvella: d0es ~/.cabal/packages/hackage.haskell.org exist?
20:48:20 <ReinH> (https://docs.docker.com/articles/security/)
20:49:03 <shirt> ReinH: right, that's what i remember reading. i don't wanna have to worry about messing up my system while doing development
20:49:35 <ReinH> shirt: Oh, you wouldn't, it just means docker access is a vulnerability that a malicious user might exploit
20:49:41 <ReinH> if you aren't a masochist, you shouldn't worry
20:49:45 <lvella> srhb, yes, contents: 00-index.tar.gz  00-index.tar.gz.etag
20:49:57 <srhb> lvella: Try frying that whole directory and starting over
20:50:17 <shirt> ReinH: maybe some day i'll look into it, but so far vagga works perfect for me
20:51:50 <ReinH> shirt: neat :)
20:52:03 <ReinH> shirt: I use docker for our build system, so I can probably answer questions, fwiw
20:53:00 <shirt> ReinH: cool. if you're curious you should take vagga for a spin and see how it compares :)
20:53:14 <ReinH> shirt: I just saw that it's in rust, which is interesting
20:53:22 <ReinH> I like rust a lot
20:54:17 <lvella> srhb, to install, I need sudo or don't?
20:54:26 <srhb> lvella: Don't
20:54:35 <joneshf-laptop> RickP, why stringly typed?
21:01:30 <RickP> joneshf-laptop: compared to what, an "Operator" data type?
21:01:44 <lvella> it is too hard to install this thing
21:02:23 <lvella> http://pastebin.com/YdKK60rH
21:03:04 <lvella> what am I supposed to do with output from ghc-pkg check ?
21:04:10 <joneshf-laptop> RickP, you're doing something with an AST if I remember right, why not encode it in the AST?
21:04:59 <heatsink> lvella: That message means that something was installed incorrectly.  Do you know if mtl was installed before you tried installing minesweeper?
21:05:48 <lvella> it seems that all gtk related dependencies fails to install
21:05:53 <lvella> I think not
21:07:04 <heatsink> mtl is a very heavily used package, it usually doesn't have bugs
21:07:21 <heatsink> try cabal install --reinstall mtl-2.2.1
21:08:23 <RickP> joneshf-laptop: i probably will eventually, first i want to get to the eval code to figure out what features i need from the representation (e.g. at least pattern match groups of functions)
21:09:05 <heatsink> lvella: ghc-pkg check should list the names of broken packages
21:09:31 <lvella> It seems to be caused by ubuntu packaging
21:09:46 <lvella> that split ghc libs into multiple packages
21:09:56 <lvella> I am installing them manually
21:10:02 <jle`> what
21:10:03 <heatsink> I see
21:10:04 <ReinH> lvella: I've never had issues using the hvr/ghc ppa, but the official repos tend to be extremely out of date
21:10:13 <jle`> Numeric.Natural is in base?
21:10:27 <lvella> but it still complain about Data.Binary.Generic.Extensions, and I don't know where it is
21:10:32 <ReinH> installing ghc and cabal with the hvr/ghc ppa is as simple as apt-get install ghc-7.8.4 cabal-1.22
21:11:41 <jle`> > sum [1..10] :: Natural
21:11:43 <lambdabot>  55
21:12:00 <jle`> i'm not sure i completely understand the benefits though
21:12:17 <Iceland_jack> @src take
21:12:18 <lambdabot> take n _      | n <= 0 = []
21:12:18 <lambdabot> take _ []              = []
21:12:20 <lambdabot> take n (x:xs)          = x : take (n-1) xs
21:12:22 <jle`> except for maybe as a refinement type that the compiler ignores
21:12:34 <jle`> is it just for better documented code?
21:12:40 <heatsink> lvella: It looks like that's in package binary-generic
21:12:56 <jle`> oh i guess it makes sense to use in the negative position
21:13:17 <jle`> people can't *pass in* negative numbers
21:14:35 <jle`> in the positive position it doesn't sound like anything other than like using Const/using types for documentation
21:14:41 <lvella> heatsink, I mean, from the libghc-... packages in ubuntu repository, but I am installing it from cabal
21:44:49 <kakos> So, MonadState in mtl has the following definition: "class (Monad m) => MonadState s m | m -> s". I'm trying to declare an instance of MonadState, but I get the error "The liberal coverage condition fails in class ‘MonadState’ for functional dependency: ‘m -> s’" How do I resolve this?
21:45:12 <johnw> show your instance line
21:45:26 <kakos> "instance MonadState s Alex where"
21:46:01 <johnw> Alex must fix the choice of 's'
21:46:02 <kakos> I'm guessing it's because Alex is of kind * and not *->*
21:46:15 <johnw> oh, that's a problem too
21:46:38 <johnw> you'll need to be specific about the s, not use 's' generically
21:47:00 <johnw> i.e.,what kind of state does Alex provide?
21:47:25 <kakos> AlexState. So, if I do "instance MonadState AlexState Alex" it should work?
21:47:34 <johnw> if Alex were * -> *, yes :)
21:47:46 <kakos> That was easier than I expected. :) Thanks!
21:48:04 <johnw> that way, 'Alex a' is known to package an AlexState
21:48:19 <kakos> Gotcha.
21:48:25 <kakos> This is my first encounter with functional dependencies
21:48:38 <kakos> Well, probably not, but my first direct encounter
21:48:56 <johnw> if there were no functional dependency, you wouldn't know given an 'Alex a' what it contains state-wise
22:01:24 * hackagebot vector-algorithms 0.7 - Efficient algorithms for vector arrays  http://hackage.haskell.org/package/vector-algorithms-0.7 (DanDoel)
22:16:42 <juanca_> Hi people, i was wondering if someone has any idea why this code is broken for big matrix dimensions like 5000x5000 or more
22:16:44 <juanca_> http://lpaste.net/1510641458015633408
22:44:00 <mishac> Hi guys, i am trying to generate a stream of numbers can anyone give some pointers on how to approach this problem. I want to take a number say zero and add one to it to produce 0 1. Then I want to take 0 1 add 1 to 1 and make 0 1 0 2. then I want to take four previous numbers and add 1 to the last digit to make 01020103 and so on
22:44:52 <mishac> I hope i conveyed the idea cross. What I am trying to figure out is, is there a specific function/operation that works on stream that would allow one to generate sequences like these indefinitely
22:46:39 <simpson> mishac: Have you formed recursive infinite lists before?
22:46:54 <mishac> sort of.
22:47:06 <mishac> this is the problem of HW #6 cis194
22:47:16 <simpson> > let xs = 0:xs in xs
22:47:17 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
22:47:26 <simpson> I'm afraid I don't know about your HW. :c
22:47:49 <mishac> this is cis194 class, i think everyone who is learning haskell goes through it.
22:47:55 <mishac> anyway, this is not important
22:48:22 <mishac> I know a while back i came across a paper, strea mbased programming, which defined basic operations
22:48:37 <mishac> of working with streams of data
22:48:57 <ronh> mishac did you mean 01020103 or 010203?
22:49:01 <simpson> Oh. Uh, I learned Haskell without it, sorry.
22:49:10 <mishac> oh 01021003
22:49:25 <mishac> and so on 01021003 ++ 01021004 = 0102100301021004
22:50:00 <mishac> I think i am starting to see a pattern.
22:50:37 <suzerainty> > let step l = (let (x:xs) = reverse l in l++reverse(x+1:xs)) in step . step . step $ [0,1]
22:50:38 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4]
22:52:05 <Hijiri> mishac: I forget, does the assignment have you define the interleave function before this?
22:52:17 <mishac> yes
22:52:28 <Hijiri> I think I remember a nice solution using that
22:52:32 <mishac> but it is only for generating streams with single number
22:52:51 <mishac> i think the question is about
22:52:55 <mishac> how to define streams of streams
22:53:01 <mishac> ie stream inside stream
22:53:02 <Hijiri> interleave is the one that mixes two streams, right?
22:53:03 <mishac> maybe
22:53:07 <mishac> yep
22:53:10 <mishac> i got past that part
22:53:59 <Hijiri> this doesn't look like streams of streams
22:54:00 <mishac> and the exercise there are about generating streams from single seed and function
22:54:12 <Hijiri> it looks like just a stream of digits
22:54:14 <mishac> maybe this is just a wild guess,
22:54:50 <Hijiri> I don't want to give too big of a hint, but I noticed a pattern where interleave fit in nicely
22:55:05 <cfoch> what should I do when I am trying to compile a hackage and I get the error of "Ambiguous occurrence" ?
22:55:16 <mishac> I think i implemented interleave
22:55:28 <mishac> generate streams of zeros
22:55:34 <mishac> generate stream of digits from 1 to n
22:55:45 <mishac> err stream of even digits
22:55:52 <mishac> interleave them together
22:56:48 <mishac> (00..) (010101...) (0102....) (01020103...) (0102010301020104..)
22:56:53 <lf94> I moved a project from my home directory to its own directory, but setup a sandbox in the home directory. How do I move the sandbox too?
22:57:22 <Hijiri> something like that, but you don't want to stop at n
22:57:35 <mishac> you dont
22:57:37 <mishac> n is just
22:57:39 <mishac> infitte number
22:57:48 <mishac> it is streams afterall
22:58:05 <Hijiri> oh, I see how that would be streams of streams
22:58:15 <mishac> you see right
22:58:17 <mishac> it just
22:58:31 <Hijiri> usually you don't name an infinite index though
22:58:34 <mishac> some function that takes a stream and then generates a newstream based on information from previous stream
22:58:36 <Hijiri> because it isn't really there
22:58:57 <mishac> so it is somethign like stream to stream but without a map function.
22:59:05 <mishac> or maybe i have to use clever map function
22:59:14 <mishac> and define another function that takes n elements from the stream
22:59:21 <mishac> and then apckage i all together
22:59:41 <Hijiri> by "n" here do you mean infinity again, or a function parameter named n
22:59:47 <mishac> no it is just
23:00:02 <mishac> mapStream (+2) (repeatStream 0)
23:00:31 <fling> How to write this is haskell? -> (defvar *i* 5) (+ (incf *i*) (incf *i*))
23:00:32 <Hijiri> why +2
23:00:48 <Hijiri> fling: what does it do
23:00:57 <Hijiri> there probably isn't a direct translation
23:01:23 <fling> Hijiri: something similar to this -> int i = 5; i = ++i + ++i;
23:01:31 <mishac> interleaveStreams ( repeatStream 0) (mapStream (+2) (repeatStream 0))
23:02:20 <Hijiri> fling: if you wanted mutable state in the middle of some expression like that, you would need to use some special bookkeeping construct like State
23:02:30 <Hijiri> but really that is not very nice code to be mutating in the middle of expressions
23:02:50 <fling> the code is probably not valid in C btw
23:03:03 <mishac> anyway, thank you for listening, think i know how to solve it;
23:03:09 <Hijiri> alright
23:03:18 <fling> But good in lisp…
23:03:27 <Hijiri> fling: Even in an imperative lang I would do the mutations separate from the multiplication
23:03:28 <mauke> definitely not valid C :-)
23:04:07 <Hijiri> that is a confusing bit of code to just do i = 13
23:04:10 <fling> Hijiri: C says 14, lisp says 13
23:05:45 <opqdonut> > let incf = modify (+1) >> get in runState (liftM2 (+) incf incf) 5 -- fling 
23:05:47 <lambdabot>  (13,7)
23:06:08 <mauke> C doesn't say 14
23:06:20 <mauke> C says "you're lucky this outputs a number"
23:06:34 <fling> mauke: right! This should give an exception.
23:07:03 <opqdonut> or rather compile error
23:07:35 <mniip> [09:03:48] <fling> Hijiri: C says 14, lisp says 13
23:07:47 <mniip> I am more than sure that different compilers give different results
23:07:53 <mauke> the compiler isn't required to detect sequence point violations
23:08:07 <mniip> yeah, it's up to the compiler to decide what happens here
23:08:21 <mauke> mniip: or different versions of the same compiler, or different options of the same compiler, or a different phase of the moon
23:08:35 <mauke> UB is ~fun~
23:08:37 <mniip> if I recall correctly, this is undefined behavior, so it's not even limited to 13 and 14
23:08:45 <mniip> it can be a segfault, a harddrive wipe, anything
23:09:06 <mauke> yeah, what C actually says is "your program is literally meaningless"
23:09:27 <mauke> "would you like some random semantics?"
23:10:38 <fling> Yeah, the code is bad.
23:11:10 <mmachenry1> Does anyone know why I've had to reinvent fold on ListT here? http://lpaste.net/131840
23:16:28 * hackagebot http-media 0.6.2 - Processing HTTP Content-Type and Accept headers  http://hackage.haskell.org/package/http-media-0.6.2 (TimothyJones)
23:19:15 <_m_ryan> hi - has anyone here knows yesod can you help me with this ? http://lpaste.net/132015
23:24:37 <_m_ryan> hi - has anyone here knows yesod can you help me with this ? http://lpaste.net/132015
23:24:50 <pavonia> _m_ryan: What's the type of cityId?
23:25:15 <_m_ryan> pavonia it's a foriegn key.
23:25:38 <pavonia> I don't know what type these have
23:25:43 <_m_ryan> pavonia it's a foriegn key. of another table named cities...
23:25:46 <pavonia> Could you paste so real code, please?
23:25:49 <pavonia> *some
23:26:44 <MP2E> yeah the snippet provided didn't help me either
23:26:54 <MP2E> help me to answer the question, I mean.
23:27:43 <_m_ryan> i update it - http://lpaste.net/132015
23:30:01 <_m_ryan> pavonia: does my code make sense?
23:30:31 <_m_ryan> also MP2E: does my code more understandable now.
23:31:02 <pavonia> So you are trying to pull a city out of a text field?
23:32:15 <_m_ryan> yes..city has a value of city id.
23:34:38 <pavonia> _m_ryan: What syntax dod you use in the first lines of that sample? That's not a Haskell data declaration
23:35:46 <_m_ryan> pavonia: i'm using yesod..
23:36:53 <pavonia> Hhm, I'm not familar with that package
23:37:10 <_m_ryan> pavonia: it's ok.. thank you :)
23:37:55 <pavonia> But I think you have to parse that Text into a value of type Cities
23:42:56 <lf94> > /
23:42:57 <lambdabot>  <hint>:1:1: parse error on input ‘/’
23:42:58 <lf94> All the requested packages are already installed:
23:42:58 <lf94> aeson-0.8.0.2
23:43:11 <lf94> But I am importing Data.Aeson and it says it isn't there.
23:44:24 <lf94> ./.cabal-sandbox/lib/x86_64-linux-ghc-7.6.3/aeson-0.8.0.2/Data/Aes
23:44:26 <lf94> on
23:46:14 <pavonia> lf94: Are you trying to import it from another sandbox?
23:46:50 <lf94> pavonia, I was at first
23:46:54 <lf94> Now I'm just trying to use the old one
23:46:58 <lf94> It's not working at all
23:49:53 <pavonia> lf94: Could you paste the compile log?
23:50:21 <ben_boz> hello there all haskell folks, i'm a new newbi, would like to learn Hkell just joined up, a bit lost
23:50:44 <lf94> http://pastebin.com/LXAKdHLy
23:50:47 <lf94> @ pavonia 
23:51:01 <lf94> ben_boz, you're probably going to be lost for awhile yet. X)
23:51:29 <athan> ben_boz: wuts good, yo
23:51:29 <athan> @learn
23:51:29 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
23:51:29 <athan> :O WHO KILLED LAMBDABOT!?
23:51:35 <athan> oh okay
23:51:43 <athan> ^ ben_boz bookmark this!
23:52:01 <ben_boz> been a total pain trying to get connected via irc
23:52:18 <athan> ben_boz: :\ I get kicked from my wifi often :(
23:52:27 <ben_boz> never done it before
23:52:50 <pavonia> lf94: Hhm, don't you have to compile using cabal if you're in a sandbox?
23:53:01 <lf94> I thought I did.
23:53:05 <lf94> But yesterday it was working fine.
23:53:06 <lf94> hm.
23:53:17 <ben_boz> bye for now someone wants me on the phone
23:53:20 <ben_boz> exit
23:53:27 <cfoch> hi
23:53:35 <lf94> lol
23:54:10 <cfoch> I've just installed GraphViz (cabal install graphviz). But when I do "import Data.GraphViz" it cannot not find it.
23:54:29 <cfoch> can someone give me a hand, please?
23:54:47 <athan> cfoch: I firstly really advise to use sandboxes
23:55:05 <cfoch> I am using a sandbox
23:55:13 <cfoch> athan: ^
23:55:16 <lf94> import Data.Aeson
23:55:20 <lf94> Is that not correct?
23:55:49 <cfoch> lf94: was that for me?
23:56:50 <athan> when you have a sandbox of (any) library, you get all of the dependencies in the sandbox, too
23:56:53 <athan> then `cabal repl` brings you into that thiing
23:56:53 <athan> oop
23:56:53 <athan> You can also use tab completion :D
23:57:22 <cfoch> I get
23:57:24 <cfoch> Could not find module Data.GraphViz
23:58:42 <cfoch> http://fpaste.org/218492/43080909/
23:58:55 <cfoch> but  I have Graphvix installed
23:59:01 <cfoch> athan: ^
