00:00:17 <kadoban> begriffs: hakyll takes quite a while like ~30 minutes on my crap computer
00:00:23 <pacak> snuff: Or alternatively think about what that 'a' is
00:01:22 <pacak> :info Num
00:01:44 <kadoban> lambdabot doesn't have :info
00:02:05 <mauke[]> snuff: that doesn't make sense
00:02:12 <mauke[]> you could have empty :: a
00:02:15 <pacak> snuff: should be empty :: a 
00:02:21 <mauke[]> but insert :: a -> ??? -> a
00:02:53 <mauke[]> alternatively, empty :: a b; insert :: a b -> b -> a b
00:03:28 <mauke[]> instance Container [] where empty = []; insert xs x = x : xs
00:04:25 <snuff> what is the type of [] then?
00:04:37 <snuff> (the value)
00:04:38 * hackagebot semigroupoid-extras 5 - Semigroupoids that depend on PolyKinds  http://hackage.haskell.org/package/semigroupoid-extras-5 (EdwardKmett)
00:04:40 * hackagebot eq 4.0.4 - Leibnizian equality  http://hackage.haskell.org/package/eq-4.0.4 (EdwardKmett)
00:04:48 <kadoban> :t []
00:04:49 <lambdabot> [t]
00:05:13 <mauke[]> it's a polymorphic constant
00:05:17 <pacak> :k []
00:05:18 <lambdabot> * -> *
00:05:23 <mauke[]> :t Nothing
00:05:25 <lambdabot> Maybe a
00:05:27 <pacak> :k [Int]
00:05:28 <lambdabot> *
00:05:44 <pacak> :k Num
00:05:45 <lambdabot> * -> Constraint
00:05:50 <pacak> :k Num Int
00:05:51 <lambdabot> Constraint
00:06:00 <mauke[]> [] :: a b where a = []
00:06:16 <pacak> Magic.
00:06:17 <mauke[]> or rather [] :: [] b, which is the same as [] :: [b]
00:07:40 * hackagebot semigroupoid-extras 5 - Semigroupoids that depend on PolyKinds  http://hackage.haskell.org/package/semigroupoid-extras-5 (EdwardKmett)
00:07:40 * hackagebot eq 4.0.4 - Leibnizian equality  http://hackage.haskell.org/package/eq-4.0.4 (EdwardKmett)
00:07:57 <snuff> So it's not possible to define a Container class like that?
00:08:28 <mauke[]> like what?
00:08:39 <snuff> class Container a where                                                         
00:08:40 <snuff>     empty :: Container a                                                        
00:08:40 <snuff>     insert :: Container a -> a -> Container a
00:08:41 <kadoban> snuff: It's possible if you get the types right. Your syntax/logic is just a bit wonky with it.
00:08:45 <mauke[]> you can't use 'Container a' as a type because it's not a type
00:08:49 <mauke[]> it's a constraint
00:09:37 <mauke[]> also, according to that class every type can be an element of at most one container
00:09:44 <mauke[]> i.e. you're parameterizing over the element type
00:10:08 <snuff> why is it not a type? My thinking is that if [Int] is a type, then Container Int would be a type
00:10:10 <mauke[]> so if you make an instance for Int (and container type A), then Int can't be an element of container B
00:10:29 <mauke[]> snuff: [] is not a class
00:10:35 <Cale> snuff: Type classes are not types
00:10:53 <Cale> snuff: Type classes restrict the set of types over which type variables range.
00:11:10 <Cale> (to those types for which certain functionality has been implemented)
00:11:32 <mauke[]> data Container a where { Empty :: Container a; Insert :: Container a -> a -> Container a } is perfectly valid
00:11:35 <mauke[]> but it's not a class
00:12:03 <mauke[]> it's also equivalent to []
00:12:08 <kadoban> snuff: As an aside, you probably don't /want/ that class anyway, at least everyone has gotten by without it so far.
00:12:33 * hackagebot pointed 4.2.0.1 - Pointed and copointed data  http://hackage.haskell.org/package/pointed-4.2.0.1 (EdwardKmett)
00:17:01 <snuff> k, I'll have to think about whether what I was trying to do actually makes sense. Thanks for the replies everyone!
00:17:34 * hackagebot adjunctions 4.2.1 - Adjunctions and representable functors  http://hackage.haskell.org/package/adjunctions-4.2.1 (EdwardKmett)
00:17:36 * hackagebot kan-extensions 4.2.2 - Kan extensions, Kan lifts, various forms of the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-4.2.2 (EdwardKmett)
00:18:00 <mauke[]> you could do class Container c a where { empty :: c; insert :: c -> a -> c }
00:18:09 <mauke[]> possibly annoying to use because MPTC
00:18:31 <mauke[]> ah, that should probably be Container c a | c -> a
00:18:50 <snuff> what does MPTC stand for?
00:19:17 <erikd> snuff: mulit parameter type class
00:19:18 <mauke[]> multi-parameter type classes
00:19:27 <erikd> yes that
00:22:34 * hackagebot semigroupoids 5.0.0.1 - Semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-5.0.0.1 (EdwardKmett)
00:46:17 <calvinx> Does anyone know what I should use in place of `ResourceT` from ` import Data.Conduit (ResourceT)` ?
00:47:56 <Haskellfant> calvinx: I think that got factored out in the resourcet package
00:48:00 <Enigmagic> calvinx: http://hackage.haskell.org/package/resourcet-1.1.4.1/docs/Control-Monad-Trans-Resource.html
00:49:11 <calvinx> Yea, that’s what I meant. It got factored out and because I am trying to fix an old legacy open source package, I am trying to figure out what is use in its place now.
00:49:33 <Haskellfant> have you seen the link or did you quit before?
00:49:42 <Haskellfant> https://hackage.haskell.org/package/resourcet-1.1.4.1/docs/Control-Monad-Trans-Resource.html
00:49:48 <calvinx> missed the link I suppose.
00:49:50 <calvinx> O ok, thanks.
00:54:21 <mauke[]> if you get disconnected, there are logs linked in the /topic
00:56:17 <calvinx> ok. thanks for the tip.
01:22:19 <calvinx> I am getting an error when defining a newtype, ref http://lpaste.net/132662   what am I doing wrongly?
01:22:35 * hackagebot HDBC-odbc 2.4.0.1 - ODBC driver for HDBC  http://hackage.haskell.org/package/HDBC-odbc-2.4.0.1 (anton_dessiatov)
01:23:21 <merijn> calvinx: The Request type doesn't have any parameters...
01:23:28 <merijn> calvinx: Exactly as the error says
01:23:59 <mauke[]> > 42 :: Int (Maybe String)
01:24:00 <lambdabot>      ‘Int’ is applied to too many type arguments
01:24:00 <lambdabot>      In an expression type signature: Int (Maybe String)
01:24:00 <lambdabot>      In the expression: 42 :: Int (Maybe String)
01:27:41 <calvinx> right. that solves the problem. exactly as the error saus
01:27:43 <calvinx> *says
01:34:46 <zipper> Hey, I want to parse a cabal file and extract the info out of the extensions (GHC extensions) section. Someone suggested the Cabal library but I can't find anything in there that works. What am I missing?
01:37:22 <kadoban> zipper: I'm relatively sure than hdevtools and ghc-mod both do that, you might be able to look at their source-code and see how they do it (If you can't find it, look in their git repos and see which commit implemented it, that should narrow down where to look)
01:37:49 <merijn> zipper: You can ask cabal to read in a config file and get the info out of the produced structure
01:44:56 <zipper> merijn: Which config file? The .cabal file eliminates the need for a config file.
01:46:27 <merijn> zipper: That's the config file
01:53:09 <ReinH> zipper: the Cabal library itself should do that?
02:01:05 <Aruro> in 7.8.4 ghci i do following : let x = 1+3 ; sprint -> x = _ ; x ; 4 ; sprint -> x = _ while in PaCP author claims second result should be 4 since expression is evaluated by printing value of x
02:01:21 <Aruro> sprint x above
02:02:29 <srhb> Aruro: What page?
02:03:14 <zipper> ReinH: Yes it should do it but the solutions I think should work are not working.
02:03:37 <zipper> ReinH: That's why I was wondering/asking whether there's something I'm missing.
02:06:15 <Aruro> srhb: page ten, chapter 2 Basic Parallelism
02:07:16 <zipper> Hmmm sucks that erc doesn't beep when someone mentions my nick. :(
02:07:42 <Aruro> zipper: it doesnt ? i thought all cool guys have it, thats how they manage to be there and everywhere
02:08:22 <zipper> Aruro: I'll make it happen. It's made me miss helpful answers way too often.
02:08:50 <Aruro> zipper: yep also usefull if you are in several channels at the same time
02:09:04 <Aruro> @all-dict useful
02:09:06 <lambdabot> *** "Useful" gcide "The Collaborative International Dictionary of English v.0.48"
02:09:07 <lambdabot> Useful \Use"ful\, a.
02:09:07 <lambdabot>    Full of use, advantage, or profit; producing, or having power
02:09:07 <lambdabot>    to produce, good; serviceable for any end or object; helpful
02:09:07 <lambdabot>    toward advancing any purpose; beneficial; profitable;
02:09:08 <lambdabot> [46 @more lines]
02:11:42 <Hijiri> Aruro: it's probably becaues x is too polymorphic
02:12:10 <Hijiri> 0and ghci is just defaulting it each time you go to evaluate it
02:12:17 <Hijiri> so it's not quite the same thing
02:12:22 <Hijiri> at least that's what I think is happening
02:12:51 <Hijiri> so when you put "x" into the repl it just gives you the evaluation of x as an Integer
02:13:13 <Aruro> Hijiri: ty, i guess you are right
02:13:35 <Aruro> Hijiri: its my mistake, in book its written let x = 1+2:: Int
02:14:16 <Aruro> Hijiri: ok now it works
02:14:22 <Hijiri> nice
02:15:36 <Aruro> Hijiri: so polimorphism in this case means that thunk is still remaining unevaluated even if we evaluated it for some specific type?
02:16:00 <Hijiri> I think it's because underneath, x is a function that takes a typeclass method dictionary, so has no WHNF
02:16:04 <Hijiri> but but but I don't really know
02:16:09 <Hijiri> don't take that as fact
02:16:19 <Hijiri> I am just making a hypothesis up based on what is happening
02:16:57 <Aruro> Hijiri: ok, very interesting anyway :)
02:17:37 * hackagebot tasty-program 1.0.3 - Use tasty framework to test whether a program executes correctly  http://hackage.haskell.org/package/tasty-program-1.0.3 (JanStolarek)
02:18:00 <Aruro> Hijiri: now when i reread that paragraph, author specifically tells that ::Int is needed to avoid complications with overloading, so seems you are right
02:21:00 <amharris> Hi, everyone; it's my first time in the Haskell IRC. I have a few questions!
02:24:48 <Aruro> amharris: hey, welcome :)
02:25:31 <amharris> Aruro: Cheers. So, errr, I haven't exactly used Haskell yet but wanted to begin and gather some views/advice from the community as to where I should begin, what sort of application would be a good starting point, etc.
02:26:07 <amharris> Aruro: At heart, I'm a front-end web dev, so that may give you a bit of an outline as to how my brain is 'wired', so to speak.
02:26:34 <Hijiri> If you haven't done much (pure, strictly-typed) functional programming, I would start with this guide: https://github.com/bitemyapp/learnhaskell
02:26:37 <amharris> Aruro: My first language was Python, so I still have that experience with me.
02:26:44 <merijn> Actually, let bindings in GHCI and weird types sounds more like "monomorphism issues"
02:27:01 <amharris> Thanks, Hijiri !
02:27:04 <Hijiri> you can use Haskell in front-end things using compilers to javascript like ghcjs or haste
02:27:11 <Hijiri> so you might want to take a look at those
02:27:29 <Hijiri> If you are interested in web dev in general, haskell has some nice web libraries
02:28:19 <Hijiri> Scotty -> Happstack -> Snap -> Yesod in roughly order of ascending provided functionality (I might have snap and happstack mixed up)
02:28:52 <Hijiri> these would fill the role of rails/sinatra/django would in other languages
02:28:58 <Hijiri> (not in respective order)
02:29:07 <Hijiri> so basically backends
02:29:19 <amharris> Hijiri: Oh, cool! If you could give me a set of outlines and throw up a doc, that'd be brilliant, though I'm not expecting anything! :D
02:29:25 <Aruro> merijn: you mean discussion with sprint?
02:29:28 <amharris> set of scenarios*\
02:30:17 <Hijiri> I actually haven't done anything too involved in haskell web development, so I don't think I have a lot to say about it
02:30:20 <Aruro> amharris: after you get some preliminary knowledge of sintax and stuff you may look here : http://lotz84.github.io/haskellbyexample/
02:30:24 <amharris> Hijiri: ...but yes, I'm interested in web dev in general. I'm very design orientated in my work, even though I've only just begun with design. I have an 'eye' for it, one could say and that transpires through my styling and UX, etc.
02:30:48 <amharris> Aruro: Thank you. :) I guess I've got a lot of reading to do!
02:30:53 <Hijiri> the most I've done is hacked together some ugly bare-bones site
02:31:41 <amharris> Hijiri: So, what, exactly could I use Haskell for. What is it good for and what is it not good for?
02:31:58 <amharris> Hijiri, Aruro: I'll be back in about 15-20 mins but feel free to ping me directly.
02:32:01 <Hijiri> It's a general-purpose language, so you could use it for most things
02:32:16 <Hijiri> An obvious example where it might not work is embedded programming
02:32:26 <Hijiri> since haskell relies heavily on GC for its magic
02:32:42 <Hijiri> but there has been some work I think, but using specialized compilers like JHC
02:32:56 <Hijiri> However, there are libraries that will output code for embedded systems
02:33:12 <Hijiri> so you can still do something with that
02:34:02 <Jawqaaqa> hi
02:34:08 <Hijiri> Haskell might not be for heavy systems programming, though maybe there are ways
02:34:22 <Hijiri> especially if you are writing device drivers or something like that
02:34:29 <merijn> Hijiri: Jokes on you
02:34:30 <Jawqaaqa> isn't it though? static type, concision
02:34:42 <merijn> NetBSD had some work on implementing device drivers using haskell last year
02:34:53 <Hijiri> was that the audio drivers?
02:35:11 <R0b0t1> ooo
02:35:20 <Hijiri> I guess I should have remembered that
02:35:46 <Jawqaaqa> is it any better than what was available before?
02:36:02 <R0b0t1> I hadn't heard of that... very interesting. I know some places are using haskell for assembly line/machinery control.
02:36:19 <R0b0t1> But those are more like full computers that happen to be hooked up to hardware, not embedded systems.
02:36:26 <Jawqaaqa> we use Haskell to drive a bunch of servers for compilation
02:36:49 <Jawqaaqa> using the snap web framework
02:37:36 <R0b0t1> Hijiri: I haven't looked at the internals of ghc, but if it outputs GIMPLE/LLVM then you can make it output binaries for any system gcc or llvm supports.
02:37:41 <Jawqaaqa> short breaths
02:38:03 <Jawqaaqa> haskell can output llvm? so it can run on iOS?
02:38:07 <merijn> R0b0t1: There is a LLVM backend
02:38:25 <merijn> And there's people working on ARM (i.e. iOS/android) support, but it's a bit DIY still
02:38:34 <merijn> It works, but don't expect a smooth install path
02:38:39 <Jawqaaqa> ah
02:38:59 <Hijiri> R0b0t1: For embedded systems I was thinking of the heap usage
02:40:08 <Hijiri> also I really need to sleep, it's 26:40 here
02:40:10 <R0b0t1> Well, I never meant to imply it would be *useful* to generate code for every platform :^)
02:40:35 <R0b0t1> Jawqaaqa: Is snap relatively new or did I just miss it?
02:40:58 <Jawqaaqa> its not really too new :P
02:41:05 <R0b0t1> bah figures
02:41:09 <Jawqaaqa> i heard of it first 3 yrs ago maybe?
02:41:19 <xelxebar> why do we have separate functions sequence and sequenceA when monads are applicatives?
02:41:34 <merijn> xelxebar: Because that's only true since 7.10
02:41:48 <merijn> xelxebar: Before 7.10 Applicative was not a superclass of Monad
02:41:58 <merijn> xelxebar: And deleting sequenceA now would break all code that uses it
02:42:30 <merijn> There are longterm plans to simplify this stuff, but it'll go very slowly since no one wants to break working code for no reason
02:42:40 <xelxebar> merijn: ah. historical wart. thanks for the prompt answer
02:46:08 <Aruro> im using CReal library to calculate 5000 digits of simple formula, profiling shows that program using 600Mb of heap, is it normall behavior?
02:46:30 <Aruro> actually numbers package
02:46:55 <merijn> Yes, no, maybe?
02:47:03 <Aruro> closer to no
02:47:03 <merijn> Nearly impossible to see without a heap profile
02:47:30 <Aruro> merijn: how should i obtain it?
02:47:38 * hackagebot th-orphans 0.12.0 - Orphan instances for TH datatypes  http://hackage.haskell.org/package/th-orphans-0.12.0 (MichaelSloan)
02:48:45 <Aruro> merijn: im using +RTS -s at the moment
02:49:11 <merijn> Aruro: Real World Haskell has a chapter on profiling, I'd check that
02:49:37 <Aruro> merijn: ty, people complain here all the time that that book is outdated, seems thats is bad influence :)
02:50:13 <jle`> i think it's just something to be aware of when reading it
02:50:24 <merijn> Aruro: The code samples in the book are outdated, in the sense that the libraries have evolved/changed since then
02:50:31 <merijn> So don't expect the samples to work as-is
02:50:45 <merijn> But most of the contents are still good and easily translated to recent versions of said libraries
02:50:45 <jle`> RWH works as a nice reference for a lot of things, but you'll have to do some extra work to actually get it to apply/run
02:52:22 <Aruro> ok, noted
03:05:35 <amharris> Hijiri, Aruro: I'm back. :)
03:05:48 <amharris> Hijiri, Aruro: Were there any particular messages that you left?
03:16:11 <jle`> guess what just found out
03:16:16 <jle`> do you give up
03:16:18 <jle`> okay
03:16:31 <jle`> zip xs (tail xs), or zip xs (drop 1 xs)
03:16:34 <jle`> which one would you recommend?
03:16:43 <merijn> Last one isn't partial
03:16:53 <jle`> neither is the first one :O
03:16:57 <merijn> oh
03:16:59 <jle`> (this is what i just found out)
03:17:03 <merijn> Laziness on the first element :)
03:17:08 <jle`> yeah
03:17:10 <merijn> eh
03:17:13 <merijn> Second, I guess
03:17:28 <jle`> i'd still recommend the second cause of good habits
03:17:38 <jle`> but the first one not being partial was surprising to me
03:18:06 <jle`> now i can use zip`ap`tail with confidence
03:28:12 <amharris> Hijiri: Thanks for the explanations whilst I was away. I've already noticed that the folks here are ...very intelligent. I feel quite out of my depth. Heh. :)
03:32:39 * hackagebot tokenify 0.1.0.0 - A regex based LR tokenizer  http://hackage.haskell.org/package/tokenify-0.1.0.0 (akst)
03:32:40 <frerich_> jle`: Funky! And first time I see the term 'right-lazy' (in the 'zip' documentation).
03:37:09 <Aruro> in here http://book.realworldhaskell.org/read/profiling-and-optimization.html , author manages to make program that finds average of the long list effective
03:37:49 <Aruro> so it takes only 1mb of space to operate, but profiling shows heap usage of 256 mb
03:37:53 <Aruro> why is that so?
03:37:53 <verement> > zip <*> tail $ [1..5]
03:37:54 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
03:38:50 <Aruro> so he has 256MB allocated for heap and 1mb memory in use
03:40:05 <zipper> merijn: When you said "<merijn> zipper: You can ask cabal to read in a config file and get the info out of the produced structure"
03:40:07 <Aruro> here is message: http://lpaste.net/132668
03:40:27 <zipper> merijn: But that's what I'm trying to do with the Cabal library.
03:40:36 <zipper> merijn: Or what do you mean?
03:40:42 <merijn> zipper: That's what I said
03:41:06 <merijn> Aruro: It's saying 256MB was allocated on the heap, it's not saying that 256 mb was at the same time
03:41:25 <merijn> Aruro: If it's allocating several MB per second, but also collecting several MB per second...
03:42:00 <merijn> Aruro: Actually, as you can see in "Alloc rate    2,076,309,329 bytes per MUT second" it's allocating 2gb per second
03:42:28 <Aruro> merijn: so the actually memory used is just 1mb? rest is memory _flow?
03:42:32 <zipper> merijn: What?
03:42:34 <Aruro> actuall*
03:42:40 * hackagebot hsc3-server 0.10.0 - SuperCollider server resource management and synchronization.  http://hackage.haskell.org/package/hsc3-server-0.10.0 (StefanKersten)
03:42:59 <zipper> merijn: I need you to expound on that. Because when I parse my cabal file I draw blanks.
03:44:01 <zipper> Must work and not watch the big bang theory.
03:44:57 <Aruro> merijn: ty for help, now seems clear
03:45:35 <merijn> zipper: I forget where, but there's literally just a "read cabal config" function in the Cabal library that just returns a data structure with the data inside
03:45:41 <Aruro> zipper: big gang theory became lame, last season is all but love no scietific jokes whatsoever
03:46:06 <Aruro> @all-dict lame
03:46:08 <lambdabot> *** "Lame" gcide "The Collaborative International Dictionary of English v.0.48"
03:46:08 <lambdabot> Lame \Lame\ (l[=a]m), a. [Compar. {Lamer} (l[=a]m"[~e]r);
03:46:08 <lambdabot>    superl. {Lamest}.] [OE. lame, AS. lama; akin to D. lam, G.
03:46:08 <lambdabot>    lahm, OHG., Dan., & Sw. lam, Icel. lami, Russ. lomate to
03:46:08 <lambdabot>    break, lomota rheumatism.]
03:46:10 <lambdabot> [77 @more lines]
03:46:26 <dcoutts> zipper, merijn: readPackageDescription :: Verbosity -> FilePath -> IO GenericPackageDescription
03:46:58 <dcoutts> zipper, merijn: or the lower level parsePackageDescription
03:47:06 <zipper> merijn: I am using parsePackageDescription.
03:47:44 <zipper> It doesn't give me what I want. Maybe I should show you the function I am using and the cabal file.
03:47:59 <dcoutts> zipper: what do you want?
03:48:11 <dcoutts> zipper: it's certainly what Cabal uses to read .cabal files
03:48:35 <dcoutts> well, it usually goes via readPackageDescription, which deals with I/O issues, and UTF8 issues
03:48:50 <zipper> dcoutts: I want to extract the haskell extensions used in a cabal project that are specified in the cabal file.
03:49:03 <zipper> dcoutts: Let me show you my function.
03:49:05 <dcoutts> zipper: ok, that's fine
03:49:35 <dcoutts> zipper: you probably want to use flattenPackageDescription and look at the result of that
03:50:46 <zipper> dcoutts: https://gist.github.com/urbanslug/2bce67ab5eeea9dea585
03:52:49 <dcoutts> zipper: the packageDescription inside the GenericPackageDescription is only partial at that stage (mostly just metadata, nothing about the components). You need to resolve the conditionals in some way.
03:52:57 <dcoutts> zipper: simplest is flattenPackageDescription
03:53:50 <dcoutts> zipper: see, asking "what extensions does this package use" is actually an underspecified question. Packages have if/then conditionals to adapt to different environments, so you need to decide what you mean exactly.
03:54:16 <zipper> dcoutts: hmmmm
03:54:33 <dcoutts> zipper: flattenPackageDescription sort of ignores the validity of that question and just smashes all possible configurations together, including mutually exclusive ones :-)
03:54:48 <zipper> I see what you mean. I'm reading the docs on flattenPackageDescription
03:54:56 <dcoutts> but it would give you the maximum possible set of extensions
03:55:06 <dcoutts> just not a set that any specific configuration would necessarily use
03:55:42 <zipper> dcoutts: Is there a quick way to resolve the if then issue without checking the environment that the program is running in?
03:56:00 <dcoutts> zipper: yes, flattenPackageDescription ignores it all
03:56:14 <zipper> dcoutts: I don't want to ignore it all.
03:56:18 <dcoutts> zipper: otherwise you can use finalizePackageDescription with partial info
03:56:34 <zipper> I want to get the right one for the current environment/OS/GHC version
03:56:36 <dcoutts> zipper: but you need to give it some info about the environment you want to configure it for
03:57:13 <zipper> dcoutts: Hmmm thanks. I should be able to handle it from here.
03:57:29 <dcoutts> zipper: e.g. finalizePackageDescription [] (const True) buildPlatform ...
03:58:26 <zipper> dcoutts: That function sure takes a lot of arguments.
04:00:18 <zipper> dcoutts: Appreciated. Might you be DanielG on github?
04:02:28 <dcoutts> zipper: no, I'm dcoutts :-)
04:03:16 <mauke[]> duncaniel goutts
04:03:18 <zipper> dcoutts: Yeah because dcoutts looks familiar.
04:03:48 <zipper> mauke[]: That's not an everyday name in my land.
04:04:05 <merijn> zipper: Probably because it was a joke name :p
04:04:21 <zipper> merijn: Oh hahaha
04:04:36 * dcoutts grins
04:04:59 <mauke[]> -fforce-unification
04:10:24 <zipper> mauke[]: Why the list constructor in your nick though? Makes it so hard to type out your nick. Because there's already a mauke and a mauker :(
04:10:59 <pacak> ... asked data structure
04:13:07 <merijn> I'm pretty sure mauke[] is just mauke logged in from a different machine :p
04:13:59 <merijn> get a client with better tab completion ;) Mine prefers people who recently spoke when completing :)
04:16:33 <zipper> merijn: I'm using erc. I bet there's a plugin for better tab completion. Weechat is awesome for these things.
04:18:26 <zipper> I can't not use emacs. I can do everything in one application. From reading a PDF to irc to editing and compiling to version control to having a terminal emaulator. The list is almost endless.
04:19:04 <merijn> If only it had a good editor...
04:19:06 * merijn ducks
04:19:18 <mauke[]> same here, except X11
04:19:35 <aawe> zipper: I can do all that in my OS too.
04:20:17 <maerwald> aawe: you too?
04:20:39 <maerwald> well, his OS is emacs now
04:20:46 <fvgvxmpv1> merijn, evil exists ;)
04:21:17 <Rembane> zipper: So you're running the emacs OS? :)
04:21:40 <maerwald> I stopped caring about "all-in-one" solutions when I switched to a tiling wm.
04:21:50 <zipper> LOL you guys
04:22:06 <merijn> fvgvxmpv1: The only people who consider evil a good editor are those who haven't used vim extensively
04:22:11 <maerwald> zipper: you started it :/
04:22:12 <aawe> maerwald: XMonad is life
04:22:13 <zipper> maerwald: Tiling wm are efficient but aren't beatiful.
04:22:30 <maerwald> aawe: I'm still with i3, but I probably should give XMonad a try
04:22:33 <zipper> I can't spend my whole life in something that's not beatiful.
04:22:41 <maerwald> err
04:22:56 <zipper> Xmonad on top of xorg is many things but beauty out of the box.
04:22:56 <aawe> zipper: my xmonad config is beautiful
04:23:06 <zipper> aawe: You don't say :)
04:23:21 <maerwald> it's not out of the box, it's out of the monad!
04:23:29 <zipper> I'm still laughing at the emacs OS joke.
04:23:30 <aawe> out of the functor*
04:23:52 <zipper> aawe: hahaha maybe I should go back to xmonad now that I know more haskell.
04:23:57 <fvgvxmpv1> merijn, then I´m sure you can run vim in a terminal emulator in emacs ;)
04:24:04 <maerwald> LOL
04:24:27 <zipper> fvgvxmpv1: Very true :)
04:24:38 <maerwald> fvgvxmpv1: and then run a terminal emulator in that vim and...
04:24:47 <maerwald> recursion
04:24:53 <fvgvxmpv1> and connect to the same emacs frame that´s running vim \o/
04:24:58 <maerwald> :/
11:27:57 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
11:27:57 --- topic: set by johnw!~johnw@c-98-214-120-98.hsd1.il.comcast.net on [Tue May 05 17:23:24 2015]
11:31:47 <orion> How can I call a function which returns MyApp (String) from within a liftIO?
11:32:31 <fvgvxmpv1> Can I use record syntax for a data type with multiple constructors?
11:32:43 <Denommus> fvgvxmpv1: you can, but it's not a good idea
11:33:17 <ClaudiusMaximus> fvgvxmpv1: yes, but updates/access will explode if the particular constructor doesn't have the field in question
11:33:38 <Denommus> record syntax with multiple variants is unsound
11:33:49 <fvgvxmpv1> Ah, I see
11:34:07 <Denommus> orion: I don't understand what you mean
11:35:04 <mightybyte> Is there a type class like Monoid / Semigroup, but with append :: a -> a -> m a?
11:35:30 <ion> @type liftA2 (<>)
11:35:31 <lambdabot> (Applicative f, Monoid c) => f c -> f c -> f c
11:35:42 <ion> @type liftA2 (<>) `on` pure
11:35:43 <lambdabot> (Applicative f, Monoid c) => c -> c -> f c
11:35:48 <ion> @type (<|>) `on` pure
11:35:49 <lambdabot> Alternative f => a -> a -> f a
11:35:53 <mightybyte> Aha
11:35:55 <orion> Denommus: I am writing a WAI application, and it is unclear to me how I can call functions of type Foo -> MyApp Bar from within the WAI request handler whose type is Application.
11:36:37 <Denommus> orion: is MyApp a MonadIO?
11:36:41 <orion> Denommus: Yes.
11:37:09 <Denommus> orion: then you shouldn't need to liftIO it
11:37:19 <Denommus> orion: look
11:37:22 <Denommus> :t (>>=)
11:37:23 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:37:48 <Denommus> orion: does the second parameter look familiar? :-P
11:39:10 <orion> Denommus: Sure, but what should be the type of my WAI request handler, Application or MyApp Application?
11:41:06 <Denommus> orion: I know nothing about WAI
11:41:29 <orion> ok
11:42:25 <orion> Denommus: I just tried removing liftIO from a statement and this error resulted: Couldn't match expected type ‘MyApp ()’ with actual type ‘IO ()’
11:47:33 <orion> Denommus: I'm not sure I understand then what you mean when you say, "then you shouldn't need to liftIO it", considering I got that error.
11:49:54 <Denommus> orion: then I didn't get what you said!
11:50:11 <Denommus> orion: could you show some code?
11:59:02 <dzack> Hey all - just out of curiosity, what kind of setup do people usually use for Haskell dev?
11:59:17 <dzack> I'm currently using vim + a few plugins, wondering if this is pretty standard
11:59:31 <dzack> or if there's anything better! :)
12:00:09 <kadoban> I use vim, syntastic, hdevtools, stackage, neocomplete, neosnippet, couple supporting things
12:01:39 <Denommus> kadoban: isn't hdevtools deprecated?
12:01:51 <orion> Denommus: http://lpaste.net/753439960681414656 <-- How do I call func from within the liftIO?
12:01:57 <kadoban> Denommus: Not as far as I know. It's still being updated apparently, and it works.
12:02:32 <Denommus> orion: aaaaaah
12:02:55 * hackagebot clckwrks-dot-com 0.3.11 - clckwrks.com  http://hackage.haskell.org/package/clckwrks-dot-com-0.3.11 (JeremyShaw)
12:02:56 <kadoban> I haven't extensively used GHC 7.10.1 with it yet, but it appears to be updated for it.
12:03:05 <geekosaur> you don't. result1 <- liftIO action1; result2 <- func result1; ...
12:03:07 <Denommus> orion: the "do" expression you're passing to liftIO must have type IO a
12:03:11 <Denommus> :t liftIO
12:03:12 <lambdabot> MonadIO m => IO a -> m a
12:04:08 <Denommus> orion: but the function is of type Foo -> MyApp Bar, right?
12:05:08 <orion> Denommus: No, it's Int -> MyApp Bar
12:05:49 <Denommus> orion: you can't call it from within the liftIO "do" expression, because every expression on it must have type IO
12:06:35 <orion> I understand, but I am not sure how to fix it and still keep the code elegant looking.
12:07:42 <Denommus> orion: but you CAN call it from within app's "do" expression
12:08:22 <orion> geekosaur / Denommus: The problem is that I could be deep within the app code when I need to call `func'. I could be inside three layers of case statements.
12:08:31 <jophish> Is this idiomatic use of Conduit? https://gist.github.com/expipiplus1/7dc7525d24e3bbe19dff
12:08:44 <Denommus> orion: so, if liftIO's result is a MyApp Int, you may blah <- liftIO $ do..., and then just func blah
12:09:12 <Denommus> orion: why should it matter?
12:10:46 <Denommus> hm, what version of ghc-mod should I use with GHC 7.10.1, and cabal-install 1.22.4.0?
12:11:53 <kadoban> Newest I think
12:12:54 <Denommus> kadoban: the latest one on hackage isn't compiling :-/
12:13:54 <kadoban> Hmm
12:15:45 <Denommus> kadoban: https://github.com/flycheck/flycheck-hdevtools
12:16:13 <Denommus> kadoban: it says here that hdevtools is no longer actively maintained, but indeed hdevtools itself was updated 20 days ago
12:17:35 <quchen> This may be an odd question, but has anyone here seen some horrid legacy Haskell code? Lots of unsafe functions, implicit state, and what not.
12:18:03 <Denommus> kadoban: nevertheless, I use this: https://github.com/flycheck/flycheck-haskell
12:18:18 <Denommus> kadoban: I just don't have anything to query types of local variables
12:20:29 <nabokovian> are data constructors effectively functions?
12:20:43 <Hijiri> well, you can also pattern match on them
12:20:45 <mauke> some of them
12:20:46 <Hijiri> but they are functions
12:20:48 <Hijiri> oh
12:20:51 <Hijiri> right, mauke is right
12:21:48 <nabokovian> cool. thanks.
12:23:24 <hodapp> Hrm, if instances of a closed type family are limited, why can I still seemingly refer to instances that were never specified?
12:24:31 <maerwald> Denommus: mhh, my vim plugins don't have such pretty linebreaks for the error messages :/
12:24:45 <maerwald> they are all one-liners
12:26:34 <arbelos> a `mod` b `mod` c == a `mod` (min b c), right?
12:27:44 <quchen> ?check \a b c -> a `mod` b `mod` c == a `mod` min b c
12:27:45 <lambdabot>  *** Failed! Exception: 'divide by zero' (after 1 test):
12:27:45 <lambdabot>  0 0 0
12:27:52 <c_wraith> hodapp: the fact that they're closed is only used for type instance resolution, not for allowing limitations on types.
12:27:59 <arbelos> hmm
12:28:23 <c_wraith> hodapp: the feature could certainly do more than it does at the moment, but what it does at the moment simplifies a lot.
12:29:06 <hodapp> I suppose it'll work itself out at another level anyhow as I'll probably be needing some typeclass instances
12:29:12 <arbelos> > and [a `mod` b `mod` c == a `mod` min b c | a <- [1..100], b <- [1..300], c <- [1..500]]
12:29:14 <lambdabot>  False
12:29:20 <arbelos> doh!
12:29:25 <c_wraith> jle`: is your blog down at the moment?
12:29:44 <c_wraith> jle`: I keep getting what looks like 503s out of it. :(
12:30:05 <quchen> ?check \a b c -> (b /= 0 && c /= 0) ==> (a `mod` b `mod` c == a `mod` min b c)
12:30:06 <lambdabot>  *** Failed! Falsifiable (after 4 tests and 4 shrinks):
12:30:06 <lambdabot>  -5 4 -3
12:30:07 <quchen> arbelos: ^
12:30:24 <hodapp> c_wraith: a type instance, then, just sets up a synonym, and things that aren't instances are still valid types to refer to, just maybe uninhabitable?
12:30:49 <c_wraith> hodapp: that appears to be the current state, yes
12:30:50 <quchen> arbelos: Even when you constrain yourself to positive numbers only it won't hold,
12:30:50 <quchen> ?check \a b c -> (a > 0 && b > 0 && c > 0) ==> (a `mod` b `mod` c == a `mod` min b c)
12:30:52 <lambdabot>  *** Failed! Falsifiable (after 2 tests and 4 shrinks):
12:30:52 <lambdabot>  25 19 4
12:31:05 <hodapp> c_wraith: good to know.
12:31:18 <arbelos> quchen, hmm.. interesting
12:31:30 <int-e> @check \a b c -> (b /= 0 && c /= 0 && b `mod` c == 0) ==> (a `mod` b `mod` c == a `mod` c)
12:31:32 <lambdabot>  +++ OK, passed 100 tests.
12:31:38 <c_wraith> hodapp: it should still fail to compile *somewhere* along the line - it will just allow the occasional type signature that appears more permissive than it eventually is.
12:31:49 <hodapp> that being uninhabitable should still accomplish what I need at some level
12:32:23 <quchen> int-e: mod b c == 0 is a rather restrictive constraint.
12:33:13 <arbelos> so it holds when b and c are relatively prime?
12:33:31 <arbelos> for a b c > 0
12:34:19 <int-e> quchen: but necessary to make a `mod` b `mod` c == a `mod` c. For `mod` b `mod` c == a `mod` b, one needs abs c >= abs b.
12:34:27 <brbblnch> Hi
12:35:08 <brbblnch> How true is it to say that lisp = untyped lambda calculus, haskell = system F ?
12:35:44 <c_wraith> Vaguely true.
12:35:48 <int-e> quchen: damn. I mean it's necessary to make that true for all a (and fixed b, c)
12:36:01 <c_wraith> Haskell is much more accurately called System F(omega)
12:36:10 <int-e> @poll-result should-lambdabot-be-more-polite
12:36:10 <lambdabot> Poll results for should-lambdabot-be-more-polite (Open): maybe=4, no=4, yes=3
12:36:30 <arbelos> what happens if maybe wins?
12:36:34 <quchen> int-e: Lambdabot isn't polite?
12:36:44 <brbblnch> c_wraith: What does the omega add?
12:36:50 <int-e> @src foo
12:36:50 <lambdabot> Source not found. I am sorry.
12:36:54 <int-e> @src foo
12:36:54 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
12:37:02 <c_wraith> brbblnch: I don't remember.
12:37:05 <int-e> quchen: sometimes it is, sometimes it's not.
12:37:12 <geekosaur> insults mode from sudo
12:37:24 <geekosaur> which is why some of them are password related
12:37:49 <c_wraith> brbblnch: https://en.wikipedia.org/wiki/System_F#System_F.CF.89
12:38:03 <brbblnch> c_wraith: Yeah, I was just looking at it
12:38:28 <c_wraith> brbblnch: it appears that the omega adds higher-kinded types. :)
12:39:05 <int-e> arbelos: I have not thought about it. I could flip a coin then.
12:39:50 <ion> I’d be okay with a non-impolite lambdabot as long as the responses are equally funny.
12:40:03 <brbblnch> c_wraith: Yeah, but the paragraph is really hard to follow
12:40:22 <c_wraith> brbblnch: I'm going from the mathematical notation in the bullet points afterward
12:40:26 <quchen> Did people complain about Lambdabot, or where does this come from?
12:40:46 <c_wraith> brbblnch: which corresponds pretty well with the kind system in Haskell98/2010
12:40:53 <brbblnch> c_wraith: I heard once that some intermediate representation of haskell would be based on System F. Would that be more true?
12:41:09 <int-e> quchen: one person complained twice *shrugs*
12:41:24 <quchen> int-e: "Okay"
12:41:36 <dfeuer> @botsnack
12:41:36 <lambdabot> :)
12:41:37 <c_wraith> brbblnch: the GHC core still needs higher-kinded types.  I suspect the person saying that was just being a bit sloppy
12:41:46 <int-e> I rather suspect I'll get more complaints if I change the current behavior.
12:42:09 <quchen> Core is just as typed as Haskell is, isn't it?
12:42:20 <c_wraith> brbblnch: actually, I'm not sure of that.  Core is formed with the results of all typechecking completed.  It might not need polymorphic higher-kinded types.
12:42:24 <arbelos> what if the user gets to choose, polite or impolite mode
12:43:29 <geekosaur> quchen, as I understand it, no. to the extent that types survive, it is as entries in dictionaries representing typeclasses
12:43:42 <quchen> geekosaur: Ah, type classes, right.
12:43:58 <Phillemann> transformers-compat-0.4.0.3: dependency "mtl-2.1.3.1-8bcc0591131896cfc8761a93703d4c61" doesn't exist - what could be the cause of that?
12:43:59 <brbblnch> c_wraith: Ok, good. I think I will keep the comparison: If there was a general direction of lambda calculus untyped>simply typed>system F>system F_\omega, haskell would be in the direction of system F
12:44:02 <quchen> geekosaur: I was thinking of "typed, but explicitly" and then stopped thinking :-)
12:44:09 <Phillemann> I have mtl-2.1.3.1 installed.
12:44:49 <geekosaur> Phillemann, the hash likely differs
12:45:13 <Phillemann> Hmmm, which hashes differ?
12:45:16 <quchen> brbblnch: Haskell is F-omega. Core is the way the GHC developers choose to implement Haskell.
12:45:26 <geekosaur> whicjh implies that mtl2-2.1.3.1 was reinstalled. and ghc somewhat annoyingly does not always build the same library the same way, which is why there is an ABI hash appended to the package id
12:45:44 <geekosaur> the hash you just quoted at us, as part of the missing package ID
12:46:20 <quchen> brbblnch: "Haskell is untyped because STG is" would be a similar statement.
12:46:32 <Phillemann> geekosaur: Ah, I think I know the reason for the problem now, thanks
12:46:37 <brbblnch> quchen: Do you mean that wether Core uses F or anything else doesn't matter for haskell itself?
12:46:55 <quchen> brbblnch: Core is an implementation detail, it's not part of the Haskell language, yes.
12:47:07 <quchen> It's a useful intermediate representation used in GHC.
12:47:14 <quchen> (As is STG and C--)
12:47:49 <brbblnch> quechen: Yeah ok. When asking if Core used System F, I wasn't really using that as an argument to say that haskell itself is System F
12:48:17 <brbblnch> quchen: So, haskell itself is more or less F omega, or exactly it?
12:49:21 <quchen> I don't know enough about F-omega to answer that, but it seems to have all the features F-omega requires. It does have polymorphism and type operators, which is the handwavy definition of F-omega.
12:50:29 <brbblnch> quchen: So, assuming F-omega is strongly normalizing, haskell wouldn't be bothered by the halting problem, right?
12:50:55 <quchen> Haskell is bothered by the halting problem, so if that's a requirement for F-omega then Haskell isn't F-omega.
12:51:23 <orion> Denommus: Could you show me an example of not having to use liftIO if MyApp derives from MonadIO?
12:53:08 <quchen> brbblnch: But yes, strongly normalizing means that every reduction sequence terminates, so you have no halting problem.
12:53:27 <quchen> Well, you have a halting problem, and the answer to "halts" is "yes", which is a much easier decision problem to solve ;-)
12:54:51 <suppi> how exactly do I catch IO errors? :O
12:55:50 <brbblnch> Wouldn't it be useful to have a programming language that is strongly normalizing ? Would it be not powerful enough?
12:55:53 <suppi> for example error from readFile
12:56:15 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/base-4.6.0.1/Control-Exception.html#g:3
12:56:53 <quchen> brbblnch: Agda is strongly normalizing, for example. It's much harder to write programs in it if you ask me. But your programs are a lot more robust as well.
12:56:58 <dolio> Strongly normalizing languages tend to be harder to accomplish what you want in.
12:57:05 <geekosaur> note however that readFile will "swallow" exceptions generated while reading
12:57:09 <suppi> quchen, thank you
12:57:29 <suppi> i mean geekosaur 
12:57:38 <suppi> what do you mean swallow exceptions?
12:57:59 <quchen> brbblnch: In general, I think Turing-completeness is overrated as a language feature, but I don't know a more practical term to describe certain language features.
12:58:08 <brbblnch> Oh, I thought agda/coq/idris used dependant types, and that dependant types added enough to lose strong normalization
12:58:20 <geekosaur> lazy I/O is kinda hacky. if an exception happens while opening the file, readFile will throw it. it does reads "implicitly" and the only thing it can do on a read exception is produce the empty string
12:58:26 <mendozao> what's your favorite algorithms/data structures book?
12:58:40 <geekosaur> because it can't know if it's in a context where you can catch exceptions
12:58:52 <dolio> That's not the only thing it could do.
12:59:04 <suppi> geekosaur, oh, i understand.
12:59:15 <suppi> the laziness thing
12:59:17 <quchen> mendozao: CLRS is my go-to reference to look around a bit, and then there's Osaka which deals with functional data structures in particular
12:59:36 <geekosaur> well, it's kinda a different kind of laziness. look up unsafeInterleaveIO for the gory details
12:59:58 <quchen> brbblnch: A language that runs only N steps of its input program, and then returns the program's state, is not Turing-complete. But you could wrap it in a runtime system that provides it with another N steps, effectively giving you arbitrarily many steps. If you know that your program should halt given enough steps, that's good enough for practical purposes.
12:59:58 <suppi> thank you :)
13:00:05 <SrPx> How do I convert an array from C to a Haskell array properly? I have the function: "c_render :: Ptr CInt -> CInt -> CFloat -> CFloat -> IO ()" - here, I pass an array allocated with "mallocArray" to C. C fills that array. But I can't convert it back to something usable.
13:00:06 <mendozao> quchen: nice, thanks for your input 
13:00:44 <quchen> mendozao: Okasaki, not Osaka, my bad
13:01:28 <geekosaur> SrPx, aside form Foreign.Marshal.Array, you can often use C arrays directly as Storable Vector-s
13:01:56 <quchen> ?hoogle peakArray
13:01:56 <lambdabot> No results found
13:02:02 <quchen> ?hoogle peekArray
13:02:02 <lambdabot> Foreign.Marshal.Array peekArray :: Storable a => Int -> Ptr a -> IO [a]
13:02:02 <lambdabot> Foreign.Marshal.Array peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]
13:02:06 <quchen> SrPx: ^
13:02:24 <rui4> Why do you people think Haskell lacks a big good popular project?
13:02:36 <johnw> did I think that?
13:03:12 <maerwald> I cannot agree either
13:03:24 <rui4> Nice
13:03:40 <SrPx> So how do I access the nth element of an array on C?
13:03:45 <dolio> What if I don't think there are any big, good, popular projects? :)
13:04:10 <Adeon> because the number of haskell programmers is small and therefore the number of haskell projects is small and therefore there are also less big popular projects
13:04:12 <SrPx> I was using that, but Haskell was having some trouble transfering the data because the animation was blinking (while on C it was correct)
13:04:13 <brbblnch> quchen: I don't really see what's different. "If you know that your program should halt given enough steps" has still to be decided, no?
13:04:22 <geekosaur> what if people here are more interested in things that work than in popularity contests?
13:04:29 <rui4> Then what is out there apart from ghc, darcs...
13:05:06 <johnw> rui4: you should asked it that way to begin with
13:05:14 <quchen> brbblnch: In theory yes, in practice you can just add some cutoff and say "alright this won't terminate".
13:05:26 <geekosaur> xmonad, pandoc, yesod, git-annex
13:05:35 <rui4> geekosaur With popular I just meant that it does a better job than the alternatives.
13:05:45 <geekosaur> hledger maybe
13:05:45 <maerwald> pandoc is pretty popular I'd say
13:06:02 <johnw> haha, if only that's what popular meant!
13:06:18 <maerwald> ugh
13:06:19 <quchen> SrPx: There's also unsafeFromForeignPtr in Vector.Storable
13:06:24 <suppi> Elm? L:
13:06:24 <maerwald> so Windows is not popular :o
13:06:25 <quchen> (Which is probably more performant)
13:06:38 <brbblnch> quchen: Ok, yeah
13:07:11 <quchen> brbblnch: In theory, Turing-completeness is a very important property of course, I'm just saying that if you're looking for a practical language, Turing-completeness is not a requirement.
13:07:22 <dolio> Popular is typically a better indication of being worse than alternatives, not better. :)
13:07:45 <brbblnch> quchen: That's true
13:07:48 <dolio> For pretty much anything, really.
13:07:48 <rui4> I never tried darcs, and I googled git comparisons wishing to find good comments on darcs. All I found was neutral statements
13:07:53 <quchen> brbblnch: Most "practically written" C isn't Turing-complete because pointers have finite size, hence you have finite memory, so you're not complete. Does this matter? Never heard of it.
13:08:05 <geekosaur> I have certainly seen people using git-annex and pandoc who neither knew nor cared that they are written in Haskell --- which is an interesting sidewise measure of success
13:08:07 <hodapp> brbblnch: Look up a paper called 'Total Functional Programming' for a practical take on this.
13:08:17 <quchen> brbblnch: There are ways to get around that limit, but I don't seem them used very much. But then I'm not mainly a C programmer either.
13:08:22 <maerwald> rui4: darcs has a fundamentally different concept, it's more "patch based", rather than having some sort of complicated commit-history
13:08:31 <hodapp> I have never learned Darcs myself.
13:08:47 <SrPx> Seriously, am I doing something wrong? http://lpaste.net/132683 Because the animation is ghosting, like Haskell isn't transfering the memory properly. The previous frame mixes with the next frame. Really weird.
13:08:49 <ion> maerwald: “Complicated” commit history?
13:09:18 <maerwald> ion: yes
13:09:34 <maerwald> look at e.g. the blender git history
13:09:47 <phaazon> SrPx: allocating an array at each rend sounds very wrong :)
13:09:54 <rui4> maerwald: Would you say it adds something useful to a git user? Apart from letting him contribute to some Haskell projects
13:10:32 <geekosaur> it's an example of how to do DVCS with a UI that doesn't drive people to distraction? :)
13:10:33 <SrPx> phaazon: my bad. The allocation was on main. I moved it there to see if it solved it. But same thing happens with alloc on main
13:10:36 <maerwald> rui4: it makes a lot of things simpler, but may also leave you alone with a few workflow practices you are used to
13:10:41 <Darwin226> Hey, is there any clever way to somehow have custom helper text in compiler error when they concern my typeclasses?
13:11:11 <rui4> geekosaur: Yes, git-annex is the best example I found so far
13:11:23 <dolio> It also keeps better track of certain things in the repository. But that's true of almost every other DVCS (and even some non distributed ones).
13:11:32 <dolio> Like renames and directories.
13:11:35 <SrPx> phaazon: updated the code. Still compiles, still buggy
13:12:07 <brbblnch> quchen: nice, there is even a wiki article on it
13:12:19 <rui4> maerwald: I'll check it out some time, thanks
13:12:25 <brbblnch> oh, rather hodapp
13:12:35 <maerwald> rui4: you can try it out here http://hub.darcs.net/
13:12:59 <hodapp> brbblnch: on that short-ish paper?
13:14:25 <rui4> Sorry for the slow typing. Trying an alternative keyboard layout. I'm 5 days in and have been improving, but it is still torture...
13:14:56 <maerwald> so, emacs users have multi-line error messages and vim users not? :/
13:15:03 <brbblnch> hodapp: I think so, but I can't be sure
13:15:04 <maerwald> at least, syntastic seems it cannot handle it
13:15:24 <hodapp> brbblnch: D.A. Turner is the author
13:15:41 <ion> I suppose <https://s-4e60ab-i.sgizmo.com/s3/i-100018980-945992/?sguid=100018980> only expects responses from people using Haskell in their work and not hobbyists?
13:16:13 <brbblnch> hodapp: Yeah, I've got it, and it seems quite readable
13:16:33 <hodapp> brbblnch: It makes a good case for why Turing completeness is not actually a practical need.
13:16:52 <certainty> rui4: i remember when i did that. it was exhausting
13:17:17 <SrPx> ah wait, isn't Gloss's "animate" stuff running in several cores? That might be a concurrency issue? Hmmmm... 
13:17:46 <hodapp> And note, for instance, that any algorithm which has provably finite worst-case bounds does not require Turing-completeness to run.
13:18:26 <hodapp> ...unless its bounds cannot be expressed with a total function?
13:18:29 * hodapp shrugs
13:18:40 <brbblnch> I'm not sure: one of those total functional language isn't equivalent to a Total Recursive function, right?
13:19:05 <brbblnch> hodapp: So can those compute the ackermann function?
13:19:14 <rui4> certainty: at least the change worked well in the end?
13:19:43 <hodapp> brbblnch: can those what?
13:20:00 <certainty> rui4: yes. It took me half a year to get to a level where it felt comfortable. But i think that differs much from person to person
13:20:04 <brbblnch> ...unless its bounds cannot be expressed with a total function? >> What do you mean by that?
13:20:36 <hodapp> brbblnch: a class of functions that I hope does not exist because it sounds nasty.
13:21:21 <dolio> Ackermann is primitive recursive in the presence of higher-order functions.
13:22:24 <rui4> certainty: I am hoping to reduce my time suffering with active training. You can still use QWERTY if needed?
13:22:26 <ion> Is Hackage not building docs at the moment? It still says “Docs pending” for at least two uploads that happened two to four hours ago.
13:23:18 <certainty> rui4: yes, i sometimes have to. I takes a few seconds to adjust, but it works good
13:24:05 <brbblnch> Oh, I meant Primitive Recursive. 
13:24:06 <ion> Switching from the Finnish layout to the US International (AltGr dead keys) one was very easy. I wonder if one could make greater switches as easily by applying and learning small permutations to the layout periodically until reaching something like Dvorak?
13:24:31 <quchen> ion, rui4: #haskell-blah? I'd like to join the discussion but it's OT here.
13:24:45 <SrPx> How exactly do I convert a Ptr to a ForeignPtr? So I can use unsafeFromForeignPtr
13:24:49 <hodapp> just jump in with Dvorak, if you actually insist on it.
13:25:21 <quchen> SrPx: http://hackage.haskell.org/package/base-4.8.0.0/docs/Foreign-ForeignPtr.html
13:25:29 <quchen> SrPx: Plenty of functions to choose from
13:25:46 <quchen> SrPx: newForeignPtr finalizerFree -- the easiest way
13:27:19 <brbblnch> Thanks for the explanations, good night!
13:28:34 <maerwald> so, the stackage cabal config only has one effect for me so far: Dependency tree exhaustively searched
13:28:39 <maerwald> wherever I tried it :P
13:29:04 <SrPx> thank you. I read that, but finalizerFree wasn't even there... 
13:29:34 <SrPx> Can I use foreignptr on the type of c_render? 
13:30:27 <dzack> Anyone happen to know if it's possible to bundle the output of runTestTT with more text?
13:30:37 <dzack> For example, the output of a bunch of quickCheck cases?
13:37:59 <rui4> Sounds like a less painful idea. I wonder if it makes one forget more about QWERTY, which I wouldn't like
13:42:20 <quchen> SrPx: Odd, I'm sure I saw it somewhere around there.
13:43:16 <quchen> SrPx: It's in Foreign.Marshal.Alloc, it seems.
13:43:48 <quchen> SrPx: FWIW finalizerFree is just a call to C's `free`.
13:47:37 <NicX> I've read a number of Haskell tutorials now. By the time we get to recursion, I notice that the topic of tail recursion is missing from the discussion. In fact, the term "tail recur" never appears in the entire Learn You A Haskell. Is tail recursion even a priority in Haskell? Should Haskell tutorials include tail recursion as part of their introduction to recursion?
13:48:49 <geekosaur> NicX, in one sense all Haskell calls are tail calls. in another sense it is not relevant
13:49:12 <NicX> geekosaur: laziness?
13:49:17 <geekosaur> (because the form of tail call most people think of is only relevant to procedural calling, not graph reduction)
13:49:40 <quchen> "Not building up too large unevaluated computations" is Haskell's version of worrying about tail recursion. The two at least feel related sometimes.
13:49:58 <geekosaur> laziness-by-default, at least
13:50:17 <geekosaur> any given function call immediately returns an unevaluated thunk
13:51:47 <dolio> That's not quite correct, but it certainly doesn't use stack.
13:52:24 <dolio> It's more that calling any function doesn't require evaluating the arguments first.
13:52:34 <dolio> You build thunks for the arguments and jump to the function you're calling.
13:52:47 <llt> I'm not understanding the `foo` example at http://en.wikibooks.org/wiki/Haskell/Graph_reduction#Sharing_and_CSE. I thought that if you called the first `foo x y = ..` as `foo x <$> list` you could share s?
13:54:08 <llt> Isn't that what CAF (https://wiki.haskell.org/Constant_applicative_form) is getting at?
13:54:11 <quchen> llt: I don't understand the section. It sounds like a todo list for an article.
13:54:56 <Darwin226> Hey, is there still no way to write something like "instance C (-> a)"?
13:55:21 <quchen> No, Haskell 2010 hasn't changed. You'll need a newtype.
13:55:40 <Darwin226> quchen: No magical extensions?
13:55:46 <quchen> None that I know of.
13:57:55 <llt> quchen: Yeah, it seems like a work in progress. Is it correct that `foo x y = s + y where s = expensive x` can share `s` across calls in `foo x <$> list`?
13:58:24 <dolio> No.
13:58:45 <llt> What is the CAF page saying then?
13:59:15 <dolio> Which part of it?
13:59:56 <dolio> s doesn't get shared because you have to apply both arguments to foo before it gets built, and the compiler won't break up argument lists to float things like that.
14:00:29 <dolio> So it will never turn 'foo x y = let s = expensive x in s + y' into 'foo x = let s = expensive x in \y -> s + y'
14:00:56 <quchen> The subtleties of "how many arguments does a Haskell function take" …
14:01:51 <lokathor> i wish Data.Bits would let me shift bits but ignore the sign bit :/
14:01:58 <lokathor> doesn't seem to
14:02:49 <llt> Well, I guess it doesn't say it explicitly on the page, but I remember coming up with a test case where putting something in CAF make a significant performance diffirence
14:04:22 <dolio> I don't see what the foo example has to do with CAFs, because foo has arguments.
14:05:05 <dolio> CAFs are top-level bindings that take no arguments.
14:07:13 <tmtwd> hello
14:07:25 <quchen> dolio: Makes me wonder, is there a special name for a local closure that has no arguments?
14:07:30 <tmtwd> Is there a page for learning what the empty type does?
14:07:52 <tmtwd> ie data MyList a = Empty | Cons a (MyList a) deriving (Show, Eq, Read, Ord)
14:08:01 <quchen> That's not an empty type.
14:08:12 <quchen> That's a value of type MyList a called "Empty".
14:08:35 <tmtwd> So I could replace Empty with any arbitrary word?
14:08:38 <quchen> Yes.
14:08:39 <kadoban> tmtwd: It's not special in any way, it's just a name you gave it. You could look at Maybe, that's pretty much the same concept.
14:08:45 <tmtwd> ok I tried that
14:08:52 <tmtwd> I must have typed incorrectly
14:08:54 <tmtwd> thanks
14:08:54 <llt> Well, I was thinking that when using `foo` as e.g. `foo 1` it's in CAF. And the page talks about how CAF expressions can be shared
14:09:18 <quchen> data MyList a = Rabbit | Unicorn a (MyList a) -- compiles, tmtwd 
14:09:33 <lokathor> so is there a simple way to convert an int32 to a word32 bit-wise instead of value-wise?
14:10:30 <kadoban> tmtwd: If you're using 'Empty' elsewhere, you'd obviously have to change those usages too, maybe that's it?
14:10:34 <dolio> llt: Expressions like that can be shared. But s doesn't come into scope until y is applied. So it is recomputed for each element of the list.
14:11:01 <dolio> Sharing 'foo x' is just sharing '\y -> let s = expensive x in s + y'.
14:11:05 <tmtwd> kadoban, right
14:11:30 <dolio> And that is not the important savings.
14:11:36 <llt> Ah, that make sense. Thanks
14:14:32 <tmtwd> ah, I got it to work now
14:14:39 <llt> Are there drawbacks to floating things out as an optimization?
14:15:24 <arbelos> Is there a function in Prelude that partitions a list into chunks of some given size? chunkify "abcdefgh" 2 -> ["ab", "cd", "ef", "gh"]]
14:15:27 <dolio> llt: I think that wiki book tried to explain why the compiler doesn't do it automatically. Sometimes you don't want to share.
14:15:28 <llt> More space use I guess?
14:15:44 <tmtwd> how do I get the data type of a var
14:15:45 <tmtwd> ?
14:15:48 <geekosaur> arbelos, not in Prelude. see Data.iList.SPlit (split package)
14:15:50 <geekosaur> er
14:15:55 <geekosaur> Data.List.Split
14:16:02 <geekosaur> tmtwd, at runtime? you don't
14:16:04 <arbelos> geekosaur.. oh great thanks
14:16:13 <tmtwd> for example :t v gives v :: Bar Integer
14:16:13 <geekosaur> chunksOf, IIRC
14:16:18 <dolio> llt: That wouldn't be a concern if you're sharing an Int, of course.
14:17:10 <enthropy> arbelos: iterate (drop 2) is kinda close, but you're better off using Data.List.Split.chunksOf (as geekosaur suggested)
14:17:19 <enthropy> > iterate (drop 2)  "abcdefgh"
14:17:21 <lambdabot>  ["abcdefgh","cdefgh","efgh","gh","","","","","","","","","","","","","","","...
14:17:33 <enthropy> > map (take 2) $ iterate (drop 2)  "abcdefgh"
14:17:35 <lambdabot>  ["ab","cd","ef","gh","","","","","","","","","","","","","","","","","","","...
14:17:43 <arbelos> enthropy.. yes I found it.. it was almost called "chunkify".. chunksOf :) close enough
14:18:52 <geekosaur> tmtwd, ghci is a somewhat special environment with an introspectable bytecode-backend compiler. you can't do the same thing in a compiled program, nor can your ghci expressions do it
14:19:29 <geekosaur> ghci itself can because it can query the compiler environment it uses "from outside"
14:20:21 <geekosaur> there is a very limited version of this you can do with Data.Typeable (`deriving (Typeable)` on all your types)
14:20:28 <kadoban> Is there a … kind of generalized binary search algorithm somewhere? I have …  (Int -> Bool) and I need to find the first Int that results in True
14:21:53 <kadoban> It'll be … False, …, False, ++ cycle True, so it's an easy case and such.
14:22:28 <SrPx> quchen: uh huh, I actually wondered why it didn't exist when I saw the resource, but it does... so, well
14:22:31 <geekosaur> tmtwd, you may be used to dynamic languages that work like ghci does but give access to the environment to the code directly (perl, python, ruby, javascript, etc.) Compiled languages rarely offer this, except those that have boxed/"object" versions of types (e.g. Java)
14:23:09 <quchen> SrPx: I thought it was reexported by the ForeignPtr module as well. Odd.
14:24:07 <pavonia> kadoban: By first you mean the smallest?
14:24:18 <kadoban> Ya
14:24:32 <kadoban> It's obviously not the hardest thing to implement, but … seems like it should already exist?
14:25:12 <pavonia> It's an ordinary binary search, no?
14:25:18 <lokathor> rotate
14:25:22 <lokathor> rotate is what i wanted, it seems
14:26:05 <pavonia> kadoban: Have you seen the binary-search package?
14:26:15 <kadoban> Yes. Well, it's the slightly harder version than usual, since you have to do the … exponential search thing first or whatever it's called to find the bounds to look in, but yeah.
14:26:24 <kadoban> No, I didn't know that existed, lemme look
14:27:19 <tmtwd> geekosaur, I see
14:27:27 <kadoban> That … looks right, once I figure out the terms it's using. Thanks.
14:48:43 <PragCypher> is it possible to have cabal rebuild/run when a source file changes?
14:55:15 <c_wraith> can anyone review for embarassing typos and thinkos before I publish this?  https://www.fpcomplete.com/tutorial-preview/6357/zcTVIPxPjV
14:59:56 <kadoban> c_wraith: s/And I immediately/I immediately/ in the first paragraph. Not because it's some rule (it isn't), just sounds better I think. "We were taking the train up the coast to the competition site, and our coach, Eugene Luks, kept mentioning that brute-force searches were often good enough for combinatorial searches, if the branches were pruned as early as possible." I'd personally remove some commas, like s/site, and/site and/   and s/
14:59:57 <kadoban> searches, if/searches if/ .
15:01:56 <kadoban> c_wraith: Might want to link to what the validity precondition is of ListT, unless the audience is more knowledgeable than I am (sounds vaguely familiar, but I'd have to look it up)
15:02:24 <c_wraith> most suggestions taken for the first part.  And yeah, I can link to that.
15:02:30 <jophish> What's the neatest way of putting a delay into conduit? At the moment things are going a little but too fast
15:03:15 <xandaros> c_wraith: If the strict WriterT is not strict - what's the point of it? ...
15:03:22 <kadoban> c_wraith: "The selection counts were not." <-- depending how informal you want this to be, you might want to make that not-a-fragement
15:03:42 <kadoban> (possibly by combining it with the sentence before)
15:03:43 <c_wraith> kadoban: Nah, I write informal. :)
15:03:52 <c_wraith> (for the most part)
15:04:04 <c_wraith> xandaros: I'm.. not actually sure
15:04:59 <mjrosenb> is unsafePerformIO equivalent to unsafePerformIO . unsafeInterleaveIO?
15:05:16 <c_wraith> I'm so informal I don't even put "ly" on the end of adjectives when I use them as adverbs!  Usually.
15:05:24 <kadoban> Hehe
15:05:26 <c_wraith> mjrosenb: should be.
15:05:55 <kadoban> The '-' you're using in the paragraphs after the first two code blocks seems like the wrong one? I think it's supposed to be the longer looking one, if that's possible.
15:06:14 <jophish> Does there exist a Storable a => a -> ByteString
15:06:27 <jophish> hoogle came up blank
15:06:29 <c_wraith> oh, yeah, it should be an m-dash.  Let's see if I know how to convince markdown to give me one of those.
15:08:22 <kadoban> Yeah I always forget the correct names of them, haha.
15:08:31 <kadoban> I shuold really find some mnemonic for that
15:08:38 <hexagoxel> c_wraith: is "-- /show" some preprocessing artefact?
15:08:59 <c_wraith> oh, they're em-dash and en-dash.  The names actually come from the lengths of the letters m and n in variable-width fonts
15:09:11 <mjrosenb> kadoban: that isa joke, right?
15:09:14 <kadoban> Oh is that it? Hmm, that's simple enough.
15:09:16 <mjrosenb> *is a
15:09:16 <c_wraith> hexagoxel: that's an instruction to the code renderer to hide code after it by default
15:09:27 <kadoban> Haha, if it is it's an accidental one ;)
15:10:01 <mjrosenb> kadoban: the names of em-dash, and en-dash?
15:10:32 <kadoban> Yes, I never knew what they came from or what they meant. I just know when it looks like the wrong one.
15:10:41 <geekosaur> that's it, yes
15:10:46 <geekosaur> typesetting >.>
15:10:48 <c_wraith> Looks like the only way to get an em-dash out of markdown is to provide it one in the input as unicode.  *sigh*
15:11:01 * geekosaur still uses the TeXisms - hyphen -- en-dash --- em-dash
15:11:14 <mjrosenb> kadoban: an em-dash is the width of the letter 'm', and an en-dash is the width of the letter 'n'.
15:11:39 <kadoban> Well now I know :)
15:12:50 <c_wraith> kadoban: thanks
15:13:20 <kadoban> I think that's all I have for tedious grammar/typesetting/whatever stuff. I don't really have time to understand the important parts, the code and meaning right now, heh.
15:13:26 <jophish> hmm, there must be an easier way of getting the bytes of a Storable than writing it to memory and peeking the bytes back
15:14:02 <c_wraith> kadoban: fortunately, the code is all executable!  Automated checks on that. :)
15:14:15 <jophish> or creating a singleton Vector and converting that
15:14:21 <kadoban> Hehe, that helps :)
15:22:18 <ion> c_wraith: I read it, didn’t have anything stick to my eye.
15:22:41 <jophish> I suppose I could write it out to memory using storable and use unsafePackAddressLen
15:23:39 <c_wraith> ion: thanks
15:28:02 * hackagebot exceptional 0.1.4.0 - Essentially the Maybe type with error messages.  http://hackage.haskell.org/package/exceptional-0.1.4.0 (pharpend)
15:31:03 <tmtwd> so we can define new infix operators on the fly?
15:31:21 <tmtwd> ie infixr 5 :-:
15:31:39 <c_wraith> depends on the definition of "on the fly".  You can define them in code, sure.  As long as you pay attention to the important rules.
15:31:48 <tmtwd> very cool
15:31:54 <c_wraith> For instance, infix operators starting with : must be data constructors.
15:32:14 <c_wraith> Same way functions starting with capital letters must be data constructors
15:32:15 <tmtwd> like Cons?
15:32:20 <c_wraith> yep
15:33:54 <c_wraith> > let x -*- y = x * y - 1 in 7 -* 4
15:33:55 <lambdabot>      Not in scope: ‘-*’
15:33:55 <lambdabot>      Perhaps you meant one of these:
15:33:55 <lambdabot>        ‘-*-’ (line 1), ‘-’ (imported from Prelude),
15:33:57 <c_wraith> > let x -*- y = x * y - 1 in 7 -*- 4
15:33:58 <lambdabot>  27
15:34:04 <c_wraith> tmtwd: like so! :)
15:34:51 <tmtwd> is -*- now an operator?
15:35:00 <geekosaur> onbly for that expressiobn
15:35:06 <geekosaur> *only for that expression
15:36:10 <c_wraith> I defined an operator named -*- in the let expression, and it was then available throughout the rest of it
15:36:13 <ion> In “let <bindings> in <expression>”, the <bindings> are only in scope for <bindings> and <expression> and nothing else.
15:38:02 * hackagebot exceptional 0.1.4.1 - Essentially the Maybe type with error messages.  http://hackage.haskell.org/package/exceptional-0.1.4.1 (pharpend)
15:38:44 <jophish> how does this look: https://gist.github.com/expipiplus1/631b9af4f730d171bbb9
15:39:04 <tmtwd> cool
15:43:06 <tmtwd> in LYAH it says to use guards instead of patterns if testing for a boolean condition
15:43:12 <pharpend> yep
15:43:26 <tmtwd> but this function works fine
15:43:28 <tmtwd> replicate' 0 _ = []
15:43:28 <tmtwd> replicate'  x y = y : replicate' (x - 1) y
15:43:53 <c_wraith> Oh.  Numeric literals work as patterns.
15:44:17 <quchen> Well, they're a special case of a pattern that's there for convenience.
15:44:32 <tmtwd> replicate' n x  
15:44:32 <tmtwd>     | n <= 0    = []  
15:44:32 <tmtwd>     | otherwise = x:replicate' (n-1) x 
15:44:49 <tmtwd> in lyah, it says n<= 0 is a boolean condition
15:44:56 <tmtwd> so we use guards
15:45:20 <dreams> > let x * y = x + y in 2 * 3
15:45:21 <lambdabot>  5
15:45:40 <c_wraith> tmtwd: The difference between the two functions is what happens when you call it with (-1) as an argument
15:46:05 <NemesisD> where does the "ghc" package come from? i've got a dependency resolution failing because the ghc package apparently depends on a specific version of bytestring?
15:46:09 <tmtwd> c_wraith, yes, neg values throw an error with the first one
15:47:04 <ion> replicate (-1) 'x' is the list xs such that xs ++ "x" = []
15:47:08 <geekosaur> NemesisD, it's part of the compiler
15:47:11 <c_wraith> NemesisD: it's GHC-as-a-library.  Packaged with the compiler
15:47:18 <geekosaur> (in fact, it *is* the compiler, as a library)
15:47:25 <NemesisD> it depends on bytestring?
15:47:32 <geekosaur> yes
15:47:37 <tmtwd> there is no way to do this:
15:47:39 <tmtwd> replicate' (<=0) _ = []
15:47:45 <tmtwd> ?
15:47:49 <geekosaur> tmtwd, that is not a pattern
15:47:54 <NemesisD> fml
15:47:54 <tmtwd> ah I see
15:47:57 <geekosaur> patterns match on structure, not values
15:48:00 <dreams> tmtwd: in guards, you can use where clause to scope over all your guards, with pattern matching you can't!
15:48:03 * hackagebot plugins-multistage 0.6 - Dynamic linking for embedded DSLs with staged compilation  http://hackage.haskell.org/package/plugins-multistage-0.6 (AndersPersson)
15:48:04 <tmtwd> so we have to use guards
15:49:00 <geekosaur> so if we have a type Maybe a = Nothing | Just a, then I can use Nothing or Just in a pattern to match the two possibilities
15:49:14 <jophish> oh of course! Data.Binary is what I'm looking for
15:49:36 <codygman> Going through the Data Types Ala Carte paper I found this definition: data Expr f = In (f (Expr f)) and tried to use "deriving Show"... I found out that doesn't work with ADT's that have phantom types. I tried StandaloneDeriving too since GHC recommended it, didn't work. Can this be derived?
15:49:46 <quchen> tmtwd: Patterns allow you to check purely on structure of something, and that gives you safety guarantees (patterns can be checked for exhaustiveness). Guards allow checking arbitrary boolean expressions, but you don't get the exhaustiveness checks.
15:49:48 <geekosaur> foo Nothing = ...; foo (Just x) = ...something using x...
16:15:35 <NemesisD> so my vague feeling here is that depending on something that depends on the ghc package, even if you're in a sandbox, will cause some dependencies to fix and not be overwriteable within the sandbox. am i on the right track?
16:17:22 <geekosaur> you can't safely use a different version of any dependency of ghc-the-package, yes
16:18:08 <geekosaur> (the ghc devs are thinking about ways to deal with this e.g. hiding those dependencies internally so whatever version they use can't affect your code or lead to a diamond dependency issue)
16:19:16 <k0ral> Hello
16:20:11 <k0ral> how comes there is no "instance Alternative m => Alternative (ResourceT m)" in the resourcet package ? Would that make no sense ?
16:25:03 <NemesisD> so bytestring in 0.10.4.0 got its own implementation of Builder and blaze-builder was deprecated. anyone know of how people are bridging that gap while supporting newer bytestring versions?
16:25:26 <NemesisD> CPP? maybe just using bytestring-builder only? 
16:26:07 <geekosaur> wasn't there a release of blaze-builder that just uses the bytestring one if that exists, as a transitional aid?
16:28:32 <NemesisD> it looks like 0.4 may have done that, i'm looking through the source to see how they did it though
16:35:03 <P4Titan> Hello all, ghc is complaining about me not instantiating Hashable onto ParseError from Parsec. I want to because to create an unordered set (Data.HashSet) of ParseErrors. I have "instance Hashable ParseError where ...", but it still states that " Possible fix:
16:35:03 <P4Titan>       add an instance declaration for
16:35:03 <P4Titan>       (hashable-1.2.3.1:Data.Hashable.Class.Hashable ParseError)"
16:36:38 <geekosaur> it included a package version, so you have the wrong Hashable in scope
16:36:57 <P4Titan> What does that mean?
16:37:13 <geekosaur> that is, you have at least two versions of the hashable package installed, and the one it wants is not the one you have imported
16:37:40 <P4Titan> Ohh, so how do I clean both versions to leave one only?
16:38:40 <geekosaur> that depends on how you're building your program and where the hashable package versions are installed
16:39:09 <geekosaur> and how you ended up with two, which may mean you need to adjust some dependencies to not try to install a different version
16:39:23 <P4Titan> Ahh, I think I may have broke my Haskell environment as I tried a, so called, cabal upgrade and now I have a bunch of duplicate libraries
16:40:03 <geekosaur> yep. it'd be nice if ghc weren't so particular about its versions, but it is and there's no good way to fix it without performance tanking :/
16:40:40 <P4Titan> So, should I go through and uninstall versions of libraries that are older than the latest I have installed. That sounds like it would break dependencies though.
16:41:07 <geekosaur> cabal sandboxes come in handy for this kind of thing
16:41:25 <geekosaur> you likely have some of them in global package db and some in the user package db.
16:41:48 <Aruro> P4Titan: my advice use only sanboxes, haskell platform is to toy around.
16:41:49 <geekosaur> @paste output of ghc-pkg list
16:41:49 <lambdabot> Haskell pastebin: http://lpaste.net/
16:41:52 <P4Titan> I have no idea and will need to investigate
16:42:20 <geekosaur> easiest solution is remove the user package db completely and use cabal sandboxes in the future
16:42:23 <Aruro> P4Titan: you can not unistall as far as i understand :D
16:42:40 <geekosaur> ghc-pkg unregister
16:42:54 <Aruro> geekosaur: is it really uninstall?
16:43:04 * hackagebot acme-memorandom 0.0.3 - Memoized random number generation  http://hackage.haskell.org/package/acme-memorandom-0.0.3 (ion)
16:43:07 * hackagebot morte 1.2.0 - A bare-bones calculus of constructions  http://hackage.haskell.org/package/morte-1.2.0 (GabrielGonzalez)
16:43:08 <P4Titan> http://lpaste.net/7760908708762091520
16:43:10 <geekosaur> not 100% uninstall, no, but in its essence
16:43:14 <Aruro> why not cabal unregister, inverse of cabal install?
16:43:25 <geekosaur> @where sicp
16:43:25 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
16:43:28 <geekosaur> last part
16:43:57 <geekosaur> hm, that's missing the header saying what package db(s) it's looking at
16:45:00 <Aruro> actually why it is not possible to specify module version in import statement?
16:45:22 <geekosaur> LANGUAGE PackageImports
16:45:53 <Aruro> then what stops having infintely many versions of given package?
16:46:16 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#idp23944304
16:46:17 <hpc> the sanity of users
16:46:40 <Aruro> hpc: there is cabal hell, which reflects exactly what you refer to :)
16:46:44 <geekosaur> the fact that ghc is sometimes dumb about picking packages, leading to errors like the one P4Titan got, and cabal can only do so much to paper it over
16:47:06 <geekosaur> it is not cabal's fault although it appears to be mandatory to shoot the messenger and fire its corpse into the sun
16:47:25 <Aruro> :)
16:47:28 <Aruro> good point
17:05:56 <ReinH> geekosaur: well, just because *this* isn't cabal's fault...
17:16:56 <dutchie> is there a function like forM_ but where the list is in a monad too? i.e. with type Monad m => m [a] -> (a -> m b) -> m ()
17:17:15 <phy1729> have you tried hoogle?
17:17:42 <dutchie> yes
17:17:50 <dutchie> it just gave me forM_
17:18:41 <exio4> 4dyou can use =<< 
17:18:43 <dutchie> hmm, actually that type looks a bit like >>=
17:18:47 <ion> @type \fxs k -> fxs >>= \xs -> forM_ xs k
17:18:48 <lambdabot> (Monad m, Foldable t) => m (t a) -> (a -> m b) -> m ()
17:20:01 <dutchie> do-notation is probably clearer i think
17:20:47 <exio4> do { xs <- fxs; forM_ xs ..; } 
17:21:13 <exio4> dutchie: you can use xs >>= mapM_ function
17:21:26 <exio4> @type \xs f -> xs >>= mapM_ f 
17:21:27 <lambdabot> (Monad m, Foldable t) => m (t a) -> (a -> m b) -> m ()
17:22:34 <dutchie> yes
17:22:44 <dutchie> i can see that now i've written it with do
17:22:46 <dutchie> thanks all
17:27:40 <NicX> I'm looking at chapter 6 of LYAH http://learnyouahaskell.com/higher-order-functions. The author defines a function  multThree x y z = x * y * z  and says "What really happens when we do multThree 3 5 9 ... ... ... So then 5 is applied to that, which creates a function that will take a parameter and multiply it by 15." My question is: will this new function really take a parameter and multiply it by 15 or will it multiply the parameter by a 
17:27:42 <NicX> thunk or do something else?
17:30:40 <thomaseding> Is hackage broken or something? I uploaded some packages the other day, and they still haven't had their documentation generated
17:30:53 <pharpend> thomaseding: hackage sucks at building documentation
17:30:57 <pharpend> thomaseding: better to just build it yourself
17:31:19 <thomaseding> Is there a good way to get the docs up there on a windows machine?
17:31:31 <pharpend> thomaseding: https://github.com/pharpend/louse/blob/master/scripts/hackage-docs.sh - hmmm well this is a bash script, so it's a start
17:31:53 <jle`> c_wraith: yeah, sorry, it goes on and off periodically because of issues i'm having with heroku v.v
17:32:06 <maerwald> NicX: multThree x y z = x * y * z  is syntax sugar for multThree = (\x -> (\y -> (\z -> x * y * z)))
17:32:26 <maerwald> well, not sure if you call it "syntax sugar" though
17:32:29 <maerwald> but it's basically the same
17:32:40 <jle`> it is syntactic sugar, but with some extra compiler hints
17:32:43 <pharpend> thomaseding: if you give me the git repo and access to your repo, I could build the docs on my machine for you
17:32:56 <pharpend> s/access to your repo/access to the hackage thing
17:33:07 <jle`> NicX: what do you mean by "multiply the parameter by a thunk"...?
17:33:20 <maerwald> NicX: so if you only pass x = 3 for example you gt (\y -> (\z -> 3 * y * z)) as a new function
17:33:22 <jle`> are you talking about semantics, or about how GHC implments things?
17:33:23 <NicX> maerwald: I'm just confused about when the author says "multiply it by 15" because that sounds like strict evaluation
17:33:26 <maerwald> *hrz
17:33:29 <maerwald> err
17:33:37 <pharpend> thomaseding: https://hackage.haskell.org/package/exceptional-0.1.4.1/maintain/docs
17:33:39 <pharpend> er
17:33:47 <pharpend> replace exceptional-0.1.4.1 with your package
17:33:50 <jle`> NicX: if you want to be precise, you can say "the result will by the next thing multiplied by 15"
17:34:05 <jle`> or, "it'll take a number and return the number multipled by 15"
17:34:06 <pharpend> That page is wrong
17:34:18 <pharpend> "Hackage usually builds documentation automatically"
17:34:20 <pharpend> that should be
17:34:30 <pharpend> "Hackage occasionally builds documentation automatically"
17:34:34 <maerwald> NicX: multThree 3 5 9 is left-associative syntax sugar, so it is the same as: ((multThree 3) 5) 9
17:34:41 <maerwald> so it first becomes 15
17:35:28 <NicX> ahh, I see now. Thanks
17:35:50 <jle`> "multThree 3 5" is a function that takes a number and returns the number multiplied by 15
17:36:03 <jle`> so `multThree 3 5 7` is equivalent to 105
17:36:09 <jle`> as in, the two are interchangeable in haskell code
17:36:10 <maerwald> NicX: you might be interested in the "currying" article on wikipedia... I think it's a good article
17:36:30 <jle`> it doesn't strictly "multiply the input by 15" technically...i can see why it's causing some confusion
17:36:42 <jle`> in any case that specific chapter is talking about semantics, not about implementation
17:36:53 <jle`> so the actual strictness/laziness implementation is up to the compiler, as long as it obeys semantics
17:37:08 <NicX> cool, thanks
17:37:44 <jle`> NicX: the semantics are, "everywhere you see multThree 3 5 x, you can repliace it with 15*x, and nothing bad will happen...they are identical"
17:37:54 <NicX> ok
17:37:59 <jle`> how this is implemented in practice might be using thunks...or whatever
17:38:16 <dreams> NicX: in practice, it won't return a new function which takes n arguments.
17:38:21 <maerwald> yeah, I actually came to haskell because I do NOT want to know how the compiler works :)
17:38:30 <maerwald> unfortunately... even here you will have to know at some point
17:40:12 <zipper> So how do I move around when writing a case statement in structured haskell mode?
17:42:24 <thomaseding> zipper: What exactly do you  mean by that?
17:42:32 <dreams> NicX: if you have multThree 3 = x * y * z, most implementations construct the whole expression (3 * y * z) and then realize that mulThree is applied to less than the number of its arguments, so it leaves (y * z) on the stack until it is applied later in the computation. (So its not as naive as it sounds in LYAH).
17:42:46 <maerwald> thomaseding: the emacs plugin probably
17:43:21 <dreams> s/multThree 3 = x * y * z/multThree 3/
17:43:33 <zipper> thomaseding: Like they do here https://camo.githubusercontent.com/9ac5666ebfce015785f4d67a1873f2a83c9ebc35/687474703a2f2f6368726973646f6e652e636f6d2f737472756374757265642d6861736b656c6c2d6d6f64652f676966732d6e6f63616368652f636173652d73706c69742e676966
17:43:49 <maerwald> emacs really seems to have better haskell support than vim
17:44:09 <zipper> thomaseding: or in the readme screencast case section
17:46:00 <thomaseding> zipper, o idk. I just use dumb vim without haskell bindings (but with syntax hilight)
17:46:55 <zipper> thomaseding: Oh so structured haskell mode works on vim too?
18:07:49 <maerwald> zipper: I'm not aware of that
18:24:35 <orion> If you've got an application which uses a transformer stack, how do you make it play nice with Warp?
18:25:30 <orion> I.e., What do you do if your WAI Application needs to access your AppConfig (in the ReaderT)?
18:56:20 <dfeuer> There's no way to deal with large categories in Haskell, is there?
19:43:13 <heatsink> Is there a way to derive a Monoid instance for a type that's a product of monoids?
19:43:42 <haasn> Is there an easy way to make putStrLn block I/O on other threads while it runs? For example, if I have too threads both writing "foo" and "bar" to the console indefinitely, I get a mess like "fboaorbfoarofoboar" but I would prefer to get something like "foobarbarfoobarfoofoobar"
19:43:55 <glguy> Yes, you can use ghc generics to derive it
19:44:19 <haasn> I could make my own version of putStrLn that has a global lock (with unsafePerformIO and MVar, for example), but I'm wondering if there's not something simple I'm missing
19:44:26 <glguy> http://hackage.haskell.org/package/semigroups-0.16.2.2/docs/Data-Semigroup-Generic.html
19:45:05 <heatsink> neat!
19:45:32 <thomaseding> haasn: I was thinkning something similar, but with a combinator with type (IO a -> IO a) that causes the supplied action to block as wanted. That way you can do this immediatly in your new threads
19:46:05 <thomaseding> and not worry about unwitting IO that "forgets" about maually blocking
19:47:14 <thomaseding> err... nvm. Create a new IO type like BlockingIO
19:47:50 <monochrom> I seem to remember reading the code of putStrLn and below and saw some atomicity
19:48:10 * hackagebot hslogger 1.2.9 - Versatile logging framework  http://hackage.haskell.org/package/hslogger-1.2.9 (JohnGoerzen)
19:48:11 <haasn> I'm looking for something with as little syntactical overhead as possible. I have a small practical demonstration of a concurrent program and would like to prove its concurrency by sprinkling the threads with “putStrLn” debug code
19:48:24 <haasn> And it works as expected, but I can hardly read the output :)
19:49:30 <zipper> I have a case in which a field of a record type isn't working in such a way that `field (recordType) -> valueOfField` It complains that field :: TypeOfValueOfField and not field :: TypeOfRecordType -> TypeOfValueOfField
19:49:38 <zipper> What could I be doing wrong?
19:49:51 <zipper> I'm doing this in a case structure.
19:49:54 <zipper> xb
19:50:18 <zipper> Uh I meant to `C-x b` sorry.
19:50:34 <orion> When using ExceptT, you can't actually do any error handling within the monad, right? You have to completely unwrap the transformer stack before you can decide what to do?
19:51:00 <haasn> thomaseding: Your idea could work, though;  mkBlocker :: IO (IO a -> IO a); mkBlocker = do m <- newMVar (); return (\x -> do takeMVar m; a <- x; putMVar m (); return a)
19:51:15 <haasn> Then you can make a Blocker and pass it around to synchronize your underlying ‘output’-style actions
19:51:22 <pavonia> zipper: Could you paste the relevant code?
19:51:36 <zipper> pavonia: Okay.
19:51:49 <haasn> (or perhaps even do so globally: putStrLn' = blocker putStrLn where blocker = unsafePerformIO mkBlocker)
19:52:49 <thomaseding> haasn: But it utterly fails in the following input case: do { lotsOfChainedIOOperations }
19:53:19 <haasn> thomaseding: how so?
19:53:35 <monochrom> "lots of OO operations" can't be good. oh wait, I misread. XD
19:54:16 <zipper> pavonia: https://gist.github.com/urbanslug/45c6b64f6ef806bde116#file-serverthing-hs-L4
19:54:37 <thomaseding> haasn: I was hoping for this use case: newThread $ mkBlocker $ everythingTheThreadDoesNormally
19:54:59 <haasn> thomaseding: Oh! No way
19:55:16 <zipper> pavonia: Where ideConfig :: SessionConfig
19:55:28 <haasn> thomaseding: I was thinking along these lines: newThread $ do { ... normal operations; blocker (outputToConsole); rest of operations ... }
19:55:45 <pavonia> zipper: And what is the error message?
19:56:10 <thomaseding> haasn: Then I think my idea is exactly what you want
19:56:31 <zipper> pavonia: https://gist.github.com/urbanslug/45c6b64f6ef806bde116
19:58:36 <pavonia> Weird
19:59:38 <homovitruvius> how do I solve a cabal issue like http://dpaste.com/0DPY1Y2? it looks to me that dependencies are installed.
20:00:32 <zipper> pavonia: Well I followed the error and just removed the ideConfig since it already said that dataDirAsConfigDir is of type Bool and it seems to compile.
20:00:57 <zipper> pavonia: Hmm quite confusing. Compiles the module not the entire package.
20:01:07 <pavonia> zipper: Are you sure there isn't another dataDirAsConfigDir in scope?
20:01:20 <pavonia> Like from a record pattern
20:01:24 <KaneTW> in attoparsec, is there a way to seek to an absolute location or something similar
20:02:11 <zipper> pavonia: I wonder too. Let me paste the entire function. I must be missing something.
20:03:17 <pavonia> KaneTW: Do you mean when input has already been processed?
20:03:19 <zipper> pavonia: https://gist.github.com/urbanslug/ff85ee0376d6a02857b8#file-forkghcserver-hs-L19
20:03:50 <KaneTW> pavonia: basically i have a absolute offset in the file i'm parsing and i want to seek to it
20:04:22 <KaneTW> essentially i want to store a state
20:05:08 <pavonia> I can't think of anything like that
20:05:47 <pavonia> zipper: I think "SessionConfig{..} = ideConfig" is causing it
20:06:11 <pavonia> It adds bindings for all record fields
20:06:11 <monochrom> yes, I noticed that too just now
20:06:49 <monochrom> it looks exactly like one of those record puns where you get a name behind your back without naming a name. in the name of convenience.
20:06:56 <zipper> pavonia: Could you explain to me what's going on in that line? I'm not familiar with that syntax.
20:07:37 <monochrom> s/puns/wildcards/
20:08:48 <monochrom> "data X = X{jon::Int}". then "X{..} = v" is syntax sugar for "X{jon=jon} = v"
20:09:09 <monochrom> GHC user's guide section 7.3.23
20:09:24 <pavonia> zipper: It basically creates variables for each record field with the same name and binds the current field values to them
20:09:59 <monochrom> in "X{jon=jon} = v", the first "jon" refers to the field label, the second "jon" is a new variable name.
20:14:56 <dzack> So I'm trying to create a toy class to overload multiplication and division
20:15:29 <dzack> I'm stuck on modeling something like Z mod n Z - I have this so far: https://gist.github.com/dzackgarza/80b8c3eb17afbb945ae0
20:15:42 <idnar> @pl \f x -> a (b f x)
20:15:43 <lambdabot> (a .) . b
20:16:28 <monochrom> dzack, the first letter needs to be capital, e.g., ZmodZ7
20:16:34 <dzack> For mul, though, I'm getting "No instance for (GHC.Real.Integral Mod7) arising from a use of GHC.Real.mod"
20:17:01 <idnar> @pl \x f -> a (b f x)
20:17:01 <lambdabot> (a .) . flip b
20:17:04 <idnar> ah
20:17:46 <dzack> monochrom: typo, actually did have it capitalized in the source
20:19:21 <pavonia> dzack: You need to unpack you numbers, apply mod on the integer values, and pack them in the ZMod constructor again
20:19:29 <monochrom> add (ZModZ7 a) (ZModZ7 b) = ZModZ7 (mod (a+b) 7). Do you see why?
20:21:29 <dzack> Hmmm, I think so. Kind of...so in "add a b", for example, a is pattern matched to the entire type "ZModZ7 a"?
20:22:07 <monochrom> I wouldn't say that. but yes.
20:24:27 <dzack> Is there a better way of looking at it? I'm ultimately trying to wrap my head around passing around Maybes
20:25:11 <monochrom> we should not use the same name "a" for everything under the sun.
20:25:31 <haasn> monochrom: a a a a, a a a?
20:25:50 <monochrom> suppose you define "add a b = ...". then when I use it as "add (ZModZ7 10)", then a = ZModZ7 10.
20:26:09 <dzack> Ahhh I see
20:26:42 <dzack> There, a is matching everything in the parens then?
20:26:49 <dzack> 'a'*
20:26:59 <monochrom> yes
20:27:55 <dzack> Makes perfect sense, and it works! Thanks very much for the help
20:28:59 <dzack> Oh, one more related question -
20:29:14 <dzack> If, like in this example, you pattern match against 'a'
20:29:41 <dzack> Is it possible in the function body to later 'unbox' it, so to speak?
20:29:58 <dzack> Where a matches against, say, (ZModZ7 10)
20:30:12 <monochrom> yes. add a b = case a of ZModZ7 x -> now x is 10
20:30:46 <monochrom> but then you may as well begin with "add (ZModZ7 x) (ZModZ7 y) = ..."
20:31:16 <dzack> What's sort of the idiomatic way to do it
20:31:21 <dzack> Like in the case of handling a maybe
20:31:37 <monochrom> "add (ZModZ7 x) (ZModZ7 y) = ..." is idiomatic
20:31:44 <dzack> Should you have separate functions for "Just a" and "Nothing"?
20:32:28 <monochrom> no, you should have one function. "f (Just x) = ...", "f Nothing = ..."
20:32:28 <dzack> Or one case a of "Just a", "Nothing", etc
20:32:54 <monochrom> the proof is by infinite descent.
20:33:23 <monochrom> suppose you do have two separate functions. then who determines which of the two to call?
20:34:05 <dzack> Oh hm yeah...that would be ambiguous at best
20:34:13 <monochrom> perhaps he also writes another pair of functions to call your pair of functions. then who chooses which of his two functions to call?
20:34:31 <monochrom> the First Cause Argument demands that someone does the pattern matching.
20:44:51 <tmillc> Hi, I have a limited background in programming, but I've decided to stretch myself in a few ways and pursue game development in haskell
20:45:42 <texasmynsted> ok, I asked in haskell-beginners first
20:45:56 <texasmynsted> I am trying to learn haskell error handling.  I am trying out some of the stuff here http://dev.stephendiehl.com/hask/#error-handling
20:46:06 <tmillc> so I'm trying to get helm to work but "cabal install helm" is giving me: helm-0.7.1 depends on sdl2-1.2.0 which failed to install. \ sdl2-1.2.0 failed during the configure step. The exception was: \ ExitFailure 1"
20:46:11 <texasmynsted> I keep getting an error Could not find module `Control.Error'
20:46:26 <tmillc> oops also I didn't realize there was a haskell-beginners
20:46:42 <texasmynsted> I have not looked at haskell in a while so I am not sure what I should be doing to fix this.
20:46:59 <texasmynsted> I see docs here http://hackage.haskell.org/package/errors-1.4.1/docs/Control-Error.html
20:47:07 <texasmynsted> I do not see anything to install with cabal...
20:48:01 <ddellacosta> tmillc: there is also a #haskell-game that may be worth checking out for your specific interests
20:49:27 <Axman6> texasmynsted: do you have SDL (the C library) installed?
20:49:30 <exio4> tmillc: this channel is also beginner friendly, don't worry, and about your error, that's just saying it couldn't configure sdl2, I am guessing the problem here is missing a C dependency, could you post the whole log? 
20:49:35 <Axman6> uh, tmillc 
20:50:08 <ddellacosta> texasmynsted: looks like Control.Error is not a built in package
20:50:17 <pacak> texasmynsted: package is called error so proper command would be "cabal update ; cabal install error"
20:50:31 <ddellacosta> texasmynsted: https://hackage.haskell.org/package/errors
20:50:37 <texasmynsted> how did you determine that the package was called error
20:50:38 <ddellacosta> or what pacak sez ^
20:50:55 <pacak> errors
20:51:07 <ddellacosta> texasmynsted: I poked around online a bit, found the docs, found a post by Gabriel Gonzalez where he announced it: http://www.haskellforall.com/2012/07/errors-10-simplified-error-handling.html
20:51:08 <pacak> It's in url
20:51:35 <pacak> Also if you click contents you'll get "The errors package" on top
20:51:51 <texasmynsted> Hmm. I expected it to say the package here http://hackage.haskell.org/package/errors-1.4.1/docs/Control-Error.html
20:52:01 <texasmynsted> oh 
20:52:05 * texasmynsted facepalm
20:52:29 <texasmynsted> Thank you
20:52:43 <pacak> texasmynsted: They do - on top: "errors-1.4.1: Simplified error-handling"
20:53:10 <MarxLenin99> what's up?
20:53:43 <texasmynsted> :-)
20:54:11 <MarxLenin99> what is this channel for
20:54:30 <Cale> MarxLenin99: The functional programming language Haskell.
20:54:38 <idnar> is there a way to write a function with type (Monad m1, Monad m2) => m1 (m2 a) -> (a -> m1 (m2 b)) -> m1 (m2 b) ?
20:54:46 <idnar> it seems like it should be possible, but I can't quite get there
20:54:48 <pacak> MarxLenin99: Sepulki
20:54:52 <Cale> idnar: Not in general
20:55:08 <Cale> idnar: If you have two monads, their composite is not in general a monad.
20:55:22 <MarxLenin99> i quit
20:56:19 <idnar> Cale: ah, I see
20:57:54 <orion> texasmynsted: Hi. :)
20:58:00 <texasmynsted> Hi
20:59:17 <idnar> Cale: what about if I choose m2 = Maybe?
20:59:50 <exio4> that'd be MaybeT! 
21:00:33 <idnar> oh, so it would
21:01:29 <johnw> idnar: it's not possible
21:01:36 <Myrl> Better way to do this?
21:01:36 <Myrl> msg_ <- readFile "./files/index.html"
21:01:37 <Myrl> msg <- newIORef msg_
21:01:38 <johnw> but if you strengthen the constraints, there are combinations that are possible
21:01:59 <johnw> for example, (Monad m1, Applicative m1, Monad m2, Traversable m2) would work
21:02:06 <Myrl> I'm thinking of something like `msg <- (readFile "./files/index.html" >>= newIORef)
21:02:33 <johnw> h :: (Distributive m1, Monad m1, Functor m2, Monad m2)
21:02:34 <johnw>   => (b -> m1 (m2 c)) -> (a -> m1 (m2 b)) -> a -> m1 (m2 c)
21:02:35 <johnw> h f g = liftM join . join . liftM (distribute . liftM f) . g
21:02:37 <johnw> that works too
21:03:01 <johnw> (those Functor and Applicative constraints are now redundant in 7.10)
21:03:41 <johnw> so, either Distribute on m1, or Traversable on m2
21:03:54 <johnw> but anything weaker is not possible
21:04:03 <texasmynsted> orion:  I am surprised to see you here on a Friday night
21:05:06 <idnar> johnw: that makes sense
21:06:01 <johnw> idnar: there's been research done on this question, if you have a deeper interest
21:06:34 <idnar> I think I got confused between monad and applicative; the composition of two applicative functors *is* another applicative functor, right?
21:06:40 <johnw> correct, in all cases
21:09:47 <idnar> so I tried to use MaybeT and came up with: \f x -> runMaybeT ((MaybeT . f) =<< MaybeT x)
21:10:12 <idnar> is there a better way to do the wrapping/unwrapping there?
21:10:42 <pacak> @pl \f x -> runMaybeT ((MaybeT . f) =<< MaybeT x)
21:10:42 <lambdabot> (runMaybeT .) . (. MaybeT) . (=<<) . (MaybeT .)
21:16:05 <phoenix__> Just started learning Haskell.
21:16:11 <phoenix__> so far loving it
21:18:09 <phoenix__> Did anyone here actually using in real time projects ?
21:22:36 <Axman6> phoenix__: what sort of real-time projects?
21:25:50 <phoenix__> which is actually being in use right now across some organization
21:26:14 <phoenix__> though i have gone through haskell wiki
21:26:30 <dmwit> Haskell isn't really suitable for hard real-time.
21:26:58 <dmwit> I have heard that some folks use it for soft-ish real-time things (like games), but need to be careful to schedule garbage collections at "good" times.
21:26:59 <Axman6> we're running it for some of the backend services on nationalmap.gov.au/renewables/
21:27:35 <dmwit> I don't think anything that involves a network roundtrip is going to be falling in the "real-time" domain. Although what do I know.
21:27:40 <phoenix__> can you please give me some example of Hard Real Time ?
21:28:11 <dmwit> ...if you don't have some examples in mind, I guess I have answered the wrong question.
21:28:23 <Axman6> dmwit: I don't think phoenix__ actually meant to use the term 'real time' in the sense we usually talk about it - I think 'real
21:28:27 <dmwit> So maybe you can say more about what you want to do, and we can give advice about whether Haskell is okay at that.
21:28:33 <Axman6> 'real' is what was meant*
21:28:40 <dmwit> Axman6: I'm coming to the same conclusion.
21:28:43 <phoenix__> yes i mean for real
21:28:44 <Axman6> :)
21:28:45 <ronh-> phoenix__ pacemaker
21:29:01 <dmwit> phoenix__: See the Haskell in Industry page.
21:29:21 <dmwit> https://wiki.haskell.org/Haskell_in_industry
21:29:23 <phoenix__> yes i checked that
21:29:33 <Axman6> it's far from complete though
21:29:40 <Ralith> then you know the answer to your question! yay!
21:29:43 <phoenix__> it mentions they uses it but not is much detail how they use it
21:30:01 <Axman6> we're writing web services in haskell
21:30:19 <Axman6> working really well (though poor decisions early on are biting me)
21:30:39 <phoenix__> web services sounds cool
21:30:43 <texasmynsted> Hmm.  So what is wrong with this http://lpaste.net/3646571588154818560
21:30:50 * Axman6 's own poor decisions I should add
21:31:01 <texasmynsted> that I copied from http://www.haskellforall.com/2012/07/errors-10-simplified-error-handling.html
21:32:15 <Axman6> texasmynsted: how would we know without seeing any errors?
21:32:19 <texasmynsted> http://pastebin.com/NQTVxSM3
21:32:42 <Axman6> :\
21:32:45 <texasmynsted> but the code in a file called Main.hs
21:32:50 <Cale> readable pastebin
21:32:53 <texasmynsted> did cabal init
21:33:01 <Axman6> you can also put the error on the same paste on lpaste
21:33:12 <texasmynsted> cabal sandbox init
21:33:18 <texasmynsted> cabal install errors
21:33:28 <texasmynsted> oh.  I did not know that.
21:33:49 <Axman6> how about you put everything you think is important into one single paste, then show us again.
21:33:59 <Cale> here, I'll annotate it
21:34:08 <Axman6> trying to connect three different media (lpaste, pastebin and irc) is not easy
21:34:27 <Cale> http://lpaste.net/3646571588154818560
21:34:42 <texasmynsted> http://lpaste.net/3646571588154818560
21:35:03 <texasmynsted> Heh
21:35:17 <texasmynsted> oops
21:36:02 <Cale> What is Control.Error?
21:36:25 <Cale> ah errors
21:36:26 <texasmynsted> a part of the errors package that I installed with "cabal install errors"
21:37:04 <Cale> So I take it you're not using errors-1.0 like the blog post, but errors-1.4.7 probably
21:37:37 <texasmynsted> oh I just did this
21:38:07 <texasmynsted> added the following to the build-depends in the .cabal file
21:38:07 <texasmynsted> uild-depends:       base >=4.6 && <4.7, errors
21:38:16 <texasmynsted> added the ,errors bit at the end
21:38:41 <texasmynsted> well wrong version would explain the problem
21:39:16 <texasmynsted> I should be able to say errors = 1.0 or something right?
21:39:46 <Cale> Yeah, errors==1.0 or errors-1.0
21:40:08 <Cale> But the problem is the type of runScript has apparently not changed, but the type of tryIO has.
21:40:35 <Cale> I honestly don't quite see the point of this library...
21:40:42 <texasmynsted> hm.
21:40:54 <texasmynsted> All I care about is learning how to correctly deal with errors
21:41:21 <texasmynsted> I am not sure why I should need to pull down a package to handle errors "normally"
21:41:37 <Cale> Exactly, you shouldn't.
21:42:02 <Cale> There are already enough ways to manage errors in base alone.
21:42:31 <texasmynsted> Do you have a good link?
21:43:14 * hackagebot aeson-qq 0.8.0 - JSON quasiquoter for Haskell  http://hackage.haskell.org/package/aeson-qq-0.8.0 (SimonHengel)
21:43:15 <Cale> So, exceptions in IO are mostly handled using the stuff here: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/Control-Exception.html
21:43:29 <texasmynsted> Specifically imagine that I am processing a list of things.  converting them from A to B.  Sometimes A is invalid thus no B can be made, and the entire list is basically wrong.
21:43:34 <Cale> Apart from that, just make use of the Maybe and Either data types.
21:43:40 <Cale> okay
21:43:59 <Cale> So you might first write a function of type  A -> Maybe B  to do the conversion
21:44:06 <texasmynsted> I do not want to simply throw an exception.  I want to process the entire list and record/display each invalid A
21:45:16 <texasmynsted> or A to an Either 
21:46:02 <Cale> Okay yeah, perhaps extend that to a function f :: A -> Either A B such that f x = Left x when the conversion can't happen.
21:46:03 <texasmynsted> so Either good or an error message for that item...
21:46:43 <texasmynsted> yes
21:47:11 <Cale> and then you can do something like forM xs $ \x -> case x of Left e -> putStrLn . concat $ ["There was a problem converting ", show e, "."]; Right x -> ...
21:47:27 <Cale> forM_ rather
21:48:14 * hackagebot robots-txt 0.4.1.3 - Parser for robots.txt  http://hackage.haskell.org/package/robots-txt-0.4.1.3 (MarkWotton)
21:48:48 <Cale> If there are multiple reasons that the conversion may fail, then you might want to use some other type to represent the different ways the process fails.
21:48:59 <Cale> :t partitionEithers
21:48:59 <lambdabot> [Either a b] -> ([a], [b])
21:49:00 <texasmynsted> or an applicative
21:49:03 <Cale> ^^ this might be handy
21:49:42 <texasmynsted> This is helpful
21:49:43 <Cale> You can test to see if the first list has any elements, and if not, then the second list will be a complete list of successfully converted elements, nicely unwrapped.
21:50:08 <Cale> There's no need for fancy monad transformers in most cases.
21:50:33 <texasmynsted> oh OH
21:50:37 <texasmynsted> That is nice!
21:56:42 <newsham> "cabal brawl" has more of a ring to it than "cabal hell"
22:30:10 <lethjakman> am I correct in understanding that return doesn't ever actually return...it just encapsulates whatever it's passed as an IO object?
22:30:48 <jle`> lethjakman: yes, it's different than "return" in traditional languages
22:30:52 <jle`> it is more or less unrelated
22:31:04 <lethjakman> ok. does it do other things than that?
22:31:04 <jle`> `return 10` is a no-op IO action whose result is 10
22:31:11 <jle`> nope, it's a no-op, at least for IO
22:31:25 <lethjakman> so the last action is what's returned in haskell?
22:31:33 <jle`> yes, in a do block
22:31:48 <jle`> the last action's result is the result of the block
22:32:00 <jle`> remember that do blocks actaully merge multiple actions into one big giant fatty action
22:32:12 <jle`> but the result of that fatty action is the result of the action on the last line
22:32:16 <pacak> :t return
22:32:17 <lambdabot> Monad m => a -> m a
22:32:25 <pacak> > return 4 :: Maybe Int
22:32:26 <jle`> the result value, that is
22:32:26 <lethjakman> so it's basically a function
22:32:27 <lambdabot>  Just 4
22:32:43 <lethjakman> kinda..
22:32:45 <lethjakman> no?
22:32:50 <lethjakman> sorry haskell is confusing me
22:32:51 <jle`> `return` is a function, yes
22:32:54 <jle`> it's not a keyword
22:32:57 <lethjakman> well I mean do blocks
22:33:00 <jle`> it's just a normal function that's defined like any other function
22:33:04 <lethjakman> how is do different than a function
22:33:15 * hackagebot attoparsec-enumerator 0.3.4 - Pass input from an enumerator to an Attoparsec parser.  http://hackage.haskell.org/package/attoparsec-enumerator-0.3.4 (JohnMillikin)
22:33:16 <lethjakman> also is there a "show-source" for haskell?
22:33:17 <jle`> do blocks are values
22:33:17 <Axman6> it is a function
22:33:25 <jle`> (for IO at least)
22:33:29 <pacak> do is just a syntactic sugar
22:33:30 <Axman6> oh, nevermind
22:33:32 <jle`> in Haskell, you have a lot of IO action primitives
22:33:39 <jle`> like "putStrLn "hello""
22:33:41 <jle`> getLine
22:33:43 <jle`> etc.
22:33:49 <lethjakman> what would it be like without do then?
22:33:53 <lethjakman> if it's syntactic sugar?
22:33:55 <jle`> you can sequence and merge IO primitives with do notation
22:34:05 <jle`> do getLine; putStrLn "hello"
22:34:15 <jle`> that returns a new IO action, which you created by merging/sequencing two primities
22:34:32 <pacak> do { print "hi" ; print "world" } is the same as print "hi" >> print "world"
22:34:40 <pacak> :t (>>)
22:34:41 <lambdabot> Monad m => m a -> m b -> m b
22:34:42 <jle`> in haskell, "functions" only refer to things of type (a -> b)...things that take a value and evaluate to a new value
22:34:44 <pacak> :t (>>=)
22:34:45 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:35:19 <lethjakman> ok
22:35:20 <jle`> under that definition, 'putStrLn "hello"' is not a function
22:35:22 <jle`> it's an IO action
22:35:30 <jle`> you might call that a function call in some other languages
22:35:33 <lethjakman> maybe I need to understand monads better before I start asking more about this..
22:35:39 <jle`> nah, monads aren't needed to undersatnd this
22:35:41 <lethjakman> I'm not fully understanding that type
22:35:44 <jle`> this actaully has nothing to do with monads
22:35:54 <lethjakman> I'm talking about the output in lambdabot
22:35:58 <jle`> the types are a little scary because they're more polymorphic than you need them to be
22:35:58 <lethjakman> no?
22:36:02 <jle`> (>>) :: IO a -> IO b -> IO b
22:36:15 <jle`> (>>) takes two IO actions and returns a new "merged" IO action that does the first one, then the second one
22:36:24 <jle`> the result of the new action is the result of the second one
22:36:43 <lethjakman> and what's the double greater than?
22:36:50 <jle`> `putStrLn "name?" >> getLine` is an IO String...an action that first does putStrLn "name", then does getLine...and the result of the entire IO String is the result of getLine
22:37:02 <pacak> first do one thing then  do other thing, ignore results of the first one.
22:37:18 <jle`> i don't think it's too important to think in terms of (>>)/(>>=) for now
22:37:24 <jle`> just looking at the do notation makes sense to me
22:37:38 <lethjakman> the do seems to make sense
22:37:40 <lethjakman> I think
22:37:48 <lethjakman> but as soon as I try to understand how it's working I get a bit bogged down
22:37:50 <jle`> `do putStrLn "name"; getLine` is a new IO action that does both putStrLn "name" and getLine
22:38:02 <jle`> and the result of the entire action is the result of getLine
22:38:30 <jle`> i think one thing in haskell is just learning to sort of move on despite not understanding everything, heh
22:38:39 <jle`> if i stopped to understand everything i was doing i'd never get anything done
22:38:39 <lethjakman> I think so
22:38:46 <lethjakman> but these explinations did help a l ot!
22:38:46 <jle`> that being said, i understand it now
22:38:48 <jle`> on hindsight
22:39:04 <jle`> once you use do notation and IO and other monad instances for a while...i am pretty sure you will understand it eventually, when you need to :)
22:39:15 <jle`> but today is not that day, necessarily
22:39:16 <lethjakman> I hope so :)
22:39:30 <lethjakman> I'm cool with that, I'm used to the big clicks with programming languages
22:40:22 <pacak> For monads - I recomend starting with Maybe/Either monad - it's easier to see that there is no magic in there.
22:40:37 <lethjakman> I think I saw those in learn you a haskell
22:40:37 <jle`> i don't really think there is any real point to 'getting monads' or 'understanding monads' as a goal
22:40:45 <lethjakman> but monads haven't been explained further
22:40:51 <lethjakman> plus I saw a ruby talk about them
22:40:56 <jle`> 'understanding monads' might be a fun goal for the sake of yourself if you want to torture yourself
22:41:05 <jle`> but it has very little practical value
22:41:09 <lethjakman> hm
22:41:17 <lethjakman> what do you typically do with haskell?
22:41:26 <jle`> understanding how to use types well...that's ery practical
22:41:28 <pacak> jle`: It's hard to understand more complicated stuff without understanding monads...
22:41:59 <jle`> i think you can usually understand things in terms of the types you're doing them with
22:42:18 <jle`> learning abstractions just for the sake of abstractions might be fun but i don't think there is much practical value
22:42:30 <jle`> when i need to use Maybe for short-circuiting, i learn about Maybe
22:42:33 <jle`> not about Monads
22:44:38 <pacak> :t cata
22:44:39 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
22:45:24 <orion> I am using handle from Control.Exception.Lifted, but certain exceptions aren't being caught due to lazy evaluation. What's the most effective way to deal with this?
22:45:43 <jle`> what sort of exceptions?
22:45:43 <pacak> :t zygoHistoPrepro
22:45:44 <lambdabot> Not in scope: ‘zygoHistoPrepro’
22:45:52 <pacak> Hmmm...
22:46:18 <orion> jle`: An exception I created (sum type) that derives from Exception.
22:46:36 <jle`> how is it being thrown?
22:46:49 <orion> Control.Exception.Lifted.throw
22:46:57 <jle`> is this from monad-control ?
22:47:03 <orion> lifted-base
22:47:53 <johnw> it's implemented using monad-control
22:48:07 <jle`> yeah, i'm familiar
22:48:23 <jle`> can you show some code that does what you don't expect/want, orion ?
22:50:30 <orion> jle`: http://lpaste.net/5764359377003741184
22:50:48 <orion> InvalidResponse doesn't get caught
22:51:47 <lethjakman> so, the other day my friend and I noticed that learn you a haskell in the PDF version and free version have a different number of chapters.
22:51:52 <lethjakman> anyone have a clue what's different?
22:56:05 <jle`> orion: what's the type of decode/encode ?
22:56:23 <jle`> oh i see
22:56:27 <jle`> you aren't throwing the exceptions in IO
22:57:03 <jle`> orion: where are you catching exceptions?
22:57:14 <jle`> oh, i see
22:57:54 <jle`> you probably should do things in IO
22:58:01 <jle`> if you're working with runtime exceptions
22:58:41 <jle`> with things like throwIO
22:59:12 <jle`> haskell's IO exception system (which you are using if you use things like `handle`) really only makes sense if you're in IO
23:00:04 <jle`> `throwIO` is literally an IO action whose effect is to throw an exception
23:00:08 <jle`> er, `throwIO e`
23:00:25 <jle`> `throw e` is something that, when evaluated, throws an exception
23:13:03 <dzack> Has anyone in the channel learned category theory, coming from Haskell first?
23:13:33 <dzack> I'm trying to dig into it and find some appropriate reading material, if anyone knows any good books/resources
23:15:28 <Cale> dzack: I didn't know much category theory when I started learning Haskell, but I had an undergraduate degree in pure mathematics by the time I started learning category theory, so my experience will probably be much different than many...
23:15:51 <Cale> However, I tend to recommend Steve Awodey's book "Category Theory" as an introduction regardless
23:16:28 <Cale> It tries to avoid having too many prerequisites, and develops some of the most important examples of categories internally to the book.
23:17:26 <zacts> dzack: I'm personally following a self-curriculum for math of learning logic first... but I know nothing of category theory
23:17:27 <zacts> but
23:17:34 <zacts> perhaps http://en.wikipedia.org/wiki/Categorical_logic
23:17:40 <zacts> http://en.wikipedia.org/wiki/Intuitionistic_logic
23:17:46 <zacts> may be useful, I have no idea?
23:17:54 <zacts> (those subjects of study, not the wikipedia page itself)
23:18:17 * hackagebot pandoc-csv2table 1.0.0 - Convert CSV to Pandoc Table Markdown  http://hackage.haskell.org/package/pandoc-csv2table-1.0.0 (baig)
23:18:34 <Cale> Categorical logic can wait until after you're comfortable with the basics of category theory
23:18:35 <dzack> Thanks! I figure any relevant background will help
23:18:35 <zacts> In fact thanks for bringing up your question, as intuitionistic Logic looks really interesting to me for my own domain of study right now
23:18:45 <zacts> Cale: ah ok, cool thanks for the clarification
23:19:00 <zacts> dzack: ^ follow Cale or others over myself
23:19:44 <dzack> Cale: since you're coming from a math bg, what kinds of classes sort of provide a good background framework?
23:20:10 <dzack> So far, it looks like it parallels group theory a bit? But I'm not knowledgeable enough to really tell much
23:20:38 <Cale> dzack: Just about anything. Every branch of mathematics gives you at least one large example of a category
23:21:20 <Cale> But yeah, group theory is perhaps better than most, because you can turn groups into one-object categories where every arrow from the object to itself is invertible.
23:22:56 <Cale> Throughout mathematics, we're basically never content to study some single structure on its own. Instead, we always study related families of structures and the structure-preserving mappings between them, because this provides tools for breaking down complicated things into simpler ones.
23:23:33 <dzack> Oh nice, yeah even just having a few examples in my pocket will help
23:23:37 <Cale> Any time you have a collection of structures, and some kind of composable mappings or relationships between them, you pretty much have a category
23:24:16 <dzack> That's been my biggest issue so far - I tried picking up a few random books, but I haven't had any concrete examples to sort of hang my hat on
23:24:44 <Cale> Vector spaces and linear transformations, groups or rings or fields and the relevant sort of homomorphisms, graphs and graph homomorphisms, topological spaces and continuous maps, metric spaces and contraction mappings...
23:26:09 <Cale> Also, they don't tend to teach courses on order theory in undergrad programs, but there are some pretty strong connections between what goes on in order theory and what goes on in category theory.
23:27:03 <Cale> If S is any set, then a preorder on S is a relation <= which is 1) reflexive, i.e. for any a in S, we have a <= a, and 2) transitive, i.e. for any a, b, c in S, if a <= b and b <= c, then a <= c.
23:27:31 <dzack> Oh, so kind of like a poset?
23:27:41 <Cale> Yeah, without the antisymmetry
23:28:38 <Cale> Preorders generalise just about any sort of ordering relation you can think of. If we have a preordered set S, we can turn it into a category whose objects are the elements of S, and where there's an arrow a -> b whenever a <= b.
23:28:52 <Cale> a unique arrow in that case, and no others
23:29:02 <gfixler> I'm following this more than I would have expected
23:29:43 <Cale> and then the composition of arrows is easy to define: transitivity of <= ensures that a candidate for the composite arrow will exist, and by construction there will be only one candidate
23:29:56 <Cale> and the identity arrows exist because of reflexivity
23:30:14 <Cale> So a preordered set is like a special sort of category which has at most one arrow between any pair of objects
23:30:43 <Cale> We can also get another example which I hinted at before regarding groups
23:31:49 <Cale> A monoid M is a set together with a binary operation *: M x M -> M, usually called multiplication, such that 1) there is an identity element 1 in M such that for any a in M, we have 1 * a = a and a * 1 = a, and 2) multiplication is associative, i.e. for any a, b, c in M, we have a * (b * c) = (a * b) * c
23:32:31 <Cale> I'm sure you can think of many sorts of monoids -- addition and multiplication of various sorts of numbers or square matrices provide examples. Concatenation of strings provides another.
23:32:34 <bregg> what does Foo {..} do?
23:33:22 <Cale> bregg: That's record wildcard syntax. When you pattern match against that expression, it brings all the fields of the record into scope with their usual names, shadowing the extraction functions.
23:33:36 <Axman6> it makes all the elements of Foo available as the names they're defined with
23:33:45 <Cale> bregg: When you write that as an expression, it means "use the things in scope which have the appropriate names to define the fields of this record"
23:34:05 <Axman6> data Foo = Foo {str :: String, int :: Int}; f Foo {..} = show i ++ str
23:34:39 <Cale> Okay, so back to monoids and categories, if we have some monoid M, we can define a category with just one object, and we take the set of arrows from that object to itself to be the set M
23:34:54 <Cale> and we define composition of arrows to be multiplication according to the monoid operation
23:35:31 <bregg> Cale, Axman: Thanks
23:35:39 <Cale> The associativity of composition and the existence and properties of the identity arrow follow from the corresponding properties of the monoid.
23:36:02 <Cale> dzack: Cool?
23:36:14 <dzack> That set of arrows - from the object to itself - is that somewhat similar to an automorphism on a set?
23:36:34 <Cale> Well, endomorphisms at least.
23:36:52 <Cale> In general, the endomorphisms of an object X in some category are the arrows X -> X
23:37:03 <Cale> and the automorphisms are those arrows X -> X which have inverses
23:37:21 <Cale> i.e. those arrows f: X -> X such that there exists g: X -> X with f . g = id_X and g . f = id_X
23:37:46 <dzack> Ahhh, okay - so in the case of string concatenation, X would be...single characters?
23:37:58 <dzack> Or substrings?
23:38:00 <Cale> For any object X in a category C, the set of endomorphisms forms a monoid under composition, and the set of automorphisms forms a group under composition.
23:38:31 <Cale> In the case of the one object category for the monoid of strings under concatenation, it doesn't matter what X is, because it's the only object in the category
23:38:48 <Cale> Objects are basically just labels to help us know when it's valid to compose arrows
23:39:05 <Cale> If there's only one object, then any two arrows can be composed
23:39:38 <Cale> Otherwise, we have to be cautious that the source of one arrow is the target of the other.
23:41:14 <Cale> So in that example, there's just one object, which can be anything we like (we can take the set of objects to be any one element set), and the set of arrows from that one object to itself is taken to be the set of all strings on our chosen alphabet
23:41:28 <Cale> and then composition of arrows is defined by string concatenation
23:41:53 <Cale> The identity arrow is then the empty string
23:42:14 <Cale> and the composition of arrows is associative because concatenation of strings is
23:42:58 <dzack> Hmm okay - what about, say, for square matrices? I can see how multiplication is associative there, and composition works, but what are the arrows in this case?
23:43:06 <Cale> matrices
23:43:42 <dzack> In the sense that they act like transformations on the matrix they multiply?
23:45:25 <Cale> Well, you'd again have a single object (doesn't matter what it is), and each arrow from that object to itself would be, say, a 3-by-3 matrix with real valued entries, and the composition of arrows would be defined by matrix multiplication.
23:45:42 <Cale> The identity matrix acts as the identity arrow then
23:46:14 <Cale> But what's a little more interesting is that we can define a category for which the objects are natural numbers
23:46:26 <Cale> and the arrows n -> m are the n-by-m matrices
23:46:36 <Cale> (with real valued coefficients, say)
23:46:53 <Cale> and then composition of arrows is defined by matrix multiplication again
23:47:45 <Cale> Perhaps I should have said m-by-n matrices there ;)
23:49:57 <Cale> So then if we have A: m -> n, and we have B: p -> m, so that A is an n by m matrix, and B is an m by p matrix, we can compose those arrows to get an arrow A . B: p -> n, and how do we do it? Well, we multiply the matrices A . B = A * B
23:51:18 <dzack> So do the arrows have to be closed under composition?
23:51:28 <ryantrinkle> does anyone have an idea about what a differently-kinded version of Data.Map.Map should be named?  the kind is: (k -> *) -> (k -> *) -> *
23:51:33 <Cale> Once we get to the point of defining equivalence of categories, this category will be equivalent to the category of finite dimensional vector spaces and linear transformations (but not isomorphic to it, as that latter category has many vector spaces of any particular dimension in it)
23:51:39 <Cale> dzack: right
23:51:43 <ryantrinkle> i.e.: each key/value pair shares a type parameter of kind k
23:51:52 <ryantrinkle> (it's isomorphic to Data.Dependent.Map)
23:52:45 <Cale> ryantrinkle: and DMap is taken? :)
23:53:06 <ryantrinkle> haha, it is, although i could just conflict i suppose
23:53:12 <ryantrinkle> it would be unlikely for someone to want to use both
23:53:12 <Cale> hm
23:53:46 <ryantrinkle> also, i need names for similarly modified Functor, Foldable, Traversable, etc.
23:53:52 <shield00> Hey guys. I'm having a little trouble using 'where' inside a Map.fromList. Something like ('a', <lambda> where ...). GHC gives me a 'parse error on input "where"'. Any tips?
23:53:52 <Cale> ryantrinkle: It's existential on the choice of k, so maybe EMap ;)
23:54:09 <ryantrinkle> basically, a "Reader" over the entire damn type system :P
23:54:30 <Cale> shield00: Use let instead?
23:54:44 <Cale> shield00: 'where' is part of the syntax of declarations, not expressions
23:55:05 <Cale> let { <decls> } in <expr>  on the other hand is an expression form
23:56:03 <dzack> Cale: Is this the text you were referring to earlier? http://sistemas.fciencias.unam.mx/~lokylog/images/stories/Alexandria/Oxford%20Logic%20Guides/%5BOLG%2049%5D%20Category%20Theory%20-%20Steve%20Awodey%20%5BOxford%20Logic%20Guides%5D%20(2006)(T).pdf
23:56:11 <shield00> Cale: Well, I did manage to solve it with let, but I was wondering if I could also use where. It'd actually make the code a little cleaner. So, I can't use it?
23:56:55 <Cale> shield00: Not inside the pair like that, you could put a where hanging off the entire declaration that this expression is part of
23:57:10 <Cale> dzack: yes
23:57:29 <shield00> Cale: Hmm, I see.. That makes sense.. Okay, I'll do that. Thanks, man.
23:58:27 <Cale> dzack: For yet another example, given just about any logical system whatsoever one can typically form a category where the objects of the category are logical propositions, and the arrows P -> Q are proofs of Q given P
23:59:21 <Cale> dzack: This is a little richer than the preorder category one gets by taking the objects to be propositions and the arrows to be implications (since implication of statements is a preorder)
