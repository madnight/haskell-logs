00:00:33 <liste> Myrl-chan maybe to pass it to a higher-order function?
00:00:53 <Myrl-chan> liste: Perhaps.
00:00:54 <liste> so you wouldn't need to foobar (\a b c -> if a then b else c)
00:01:06 <Myrl-chan> Oh wait.
00:01:29 <Myrl-chan> What i said already exists, but without myIf and myElse.
00:02:00 <Myrl-chan> :t bool
00:02:01 <lambdabot> a -> a -> Bool -> a
00:02:08 <Myrl-chan> > bool 1 2 True
00:02:10 <lambdabot>  2
00:02:11 <Myrl-chan> > bool 1 2 False
00:02:13 <lambdabot>  1
00:02:40 <liste> where is bool by the way?
00:02:52 <liste> defined, I mean
00:02:53 <Myrl-chan> liste: Data.Bool, I think. I can't findi t in Hoogle, but it exists.
00:03:33 <jle`> official hoogle is lagging behind in its index...updates are waiting on the new version of hoogle library to be released
00:03:43 <Myrl-chan> jle`: I see.
00:04:09 <Myrl-chan> TIL. `otherwise` is not a keyword.
00:04:23 <unb3k44n7> dedgrant: I don't know the answer to your question. Because you said they were expressions. lol.
00:04:28 <Myrl-chan> > if otherwise then 1 else 2
00:04:29 <lambdabot>  1
00:04:38 <jle`> it's cute right?
00:04:39 <Myrl-chan> Time to write shitty code just for the heck of it. :D
00:04:40 <jle`> :)
00:05:24 <unb3k44n7> Oh wait, you said or instead of and. I didn't see you use 'or' or 'and' in your Intruder Alert thing.
00:05:48 <Myrl-chan> @let is = flip ($); greaterThan = (<);
00:05:50 <lambdabot>  Defined.
00:05:57 <Myrl-chan> > 1 is greaterThan 5
00:05:59 <lambdabot>      Could not deduce (Num a2)
00:05:59 <lambdabot>      from the context (Num a4,
00:05:59 <lambdabot>                        Num ((a -> (a -> c) -> c) -> (a3 -> a3 -> Bool) -> a4 ...
00:06:03 <dedgrant> unb3k44n7: Just focus on "and" and "or". Try pasting the line into your private chat with lambdabot. Experiment with swapping some of the True's for False's and vice versa. Experiment with changing the 'and' to 'or'. See what you can discover.
00:06:12 <Myrl-chan> > 1 `is` (greaterThan 5)
00:06:14 <lambdabot>  False
00:06:19 <Myrl-chan> > 9 `is` (greaterThan 5)
00:06:20 <lambdabot>  True
00:06:25 <Myrl-chan> SEE GUYS? HASKELL IS ENGLISH!
00:06:35 <unb3k44n7> where did you type and or or in your code?
00:06:55 <jle`> it's after the "if"
00:07:06 <unb3k44n7> You just used your expressions, bools, and functions.
00:07:37 <Walther> > is 5 (==5)
00:07:38 <lambdabot>  True
00:07:41 <unb3k44n7> Oh!
00:07:52 <kadoban> :t is
00:07:53 <lambdabot> a -> (a -> c) -> c
00:08:10 <unb3k44n7> But now why are you allowed to actually type the word or and use it instead of typing ||
00:08:25 <dedgrant> :t or
00:08:26 <lambdabot> Foldable t => t Bool -> Bool
00:08:36 <dedgrant> Well that's cryptic.
00:09:03 <unb3k44n7> Haskell allows the word or to be used as a functional part of a string?
00:09:33 <dedgrant> unb3k44n7: In short, 'or' is a standard function that extends (||) to a list of booleans (rather than just two).
00:09:35 <kadoban> :t or `asAppliedTo` []
00:09:36 <lambdabot> [Bool] -> Bool
00:09:47 <Myrl-chan> unb3k44n7: (or) and (||) is different.
00:10:06 <Myrl-chan> unb3k44n7: (or) is used when you have a list of bools.
00:10:09 <Myrl-chan> unb3k44n7: (|
00:10:11 <jle`> > or [True, False, True]
00:10:13 <lambdabot>  True
00:10:21 <Myrl-chan> (||) is used when you have 2 bools, and you pass them as arguments to (||)
00:11:58 <unb3k44n7> So, It's kind of like the same concept as Int and Interger?
00:12:08 <Hafydd> Hahah.
00:12:21 <unb3k44n7> As in integer is for larger quantities
00:12:37 <Hafydd> The generalisation of (||): (| bool1, bool2, bool3, ... |); known as "banana brackets".
00:12:42 <unb3k44n7> And or is for more than two bools
00:13:08 <kadoban> Int and Integer are types. (||) and 'or' are functions.
00:13:54 <unb3k44n7> Kadoban: I mean that they have the same concept because they are implying more than 2
00:14:10 <unb3k44n7> Or numerous quantities. 
00:14:33 <rcyr> My brain just exploded :( How can foldMap . foldMap can even be possible? How can functions with multiple arguments compose?
00:14:55 <dedgrant> unb3k44n7: Maybe it's just coincidence that Integer happens to be a longer name than Int :) But who knows.. nice way to remember which is which though.
00:15:03 <unb3k44n7> Like, larger number = integer and or is for something like False, true, true, False. But || is only for False || True - Because there's only two
00:15:20 <mauke[> rcyr: all functions take exactly one argument
00:15:30 <unb3k44n7> And that int is for smaller number. 
00:15:35 <unb3k44n7> numbers*
00:15:51 <benma> rcyr: look at map . map for a simpler example
00:17:06 <benma> rcyr: `map . map $ f` is the same as `map (map f)` i think
00:17:29 <rcyr> benma: The latter looks fine to me :)
00:17:33 <benma> and map (map f) maps over lists in a list
00:18:00 <benma> i.e. map (map (+1)) [[1,2],[3,4] is [[2,3],[4,5]]
00:18:10 <benma> (one closing bracket missing, sorry ;))
00:18:28 <rcyr> Got the same answer with map.map
00:18:38 * hackagebot hashids 1.0.2.1 - Hashids generates short, unique, non-sequential ids from numbers.  http://hackage.haskell.org/package/hashids-1.0.2.1 (arbelos)
00:20:47 <jle`> rcyr: foldMap takes an (a -> m) and transforms it into a (t a -> m)
00:21:19 <jle`> rcyr: so if you apply foldMap to a (t a -> m), you'll get a (t' (t a) -> m)
00:21:23 <jle`> it "lifts the input" by one level of t
00:22:07 <jle`> rcyr: so if `f :: a -> m`, then `foldMap f :: t a -> m`
00:22:22 <jle`> so foldMap it again.... foldMap (foldMap f) :: t' (t a) -> m
00:22:39 <jle`> which is just (foldMap . foldMap) f :: t' (t a) -> m
00:22:50 <jle`> i'm using t' and t because the second "lifting" level might be different from the first
00:23:15 <rcyr> jle`: I just have a hard time understanding that foldMap . foldMap is just foldMap (foldMap f)
00:23:27 <jle`> did you know that (.) is just a normal function?
00:23:32 <rcyr> Sure
00:23:33 <Myrl-chan> Hoogle's type searching is one of the best things ever created.
00:23:35 <Myrl-chan> jle`: Yep.
00:23:38 <jle`> (f . g) x = f (g x)
00:23:58 <rcyr> ah, haha
00:24:01 <jle`> so (foldMap . foldMap) foo = foldMap (foldMap foo)
00:24:08 <rcyr> Seeing the signature makes it soooo obvious
00:25:07 <jle`> the way functions work in haskell, if you see a function call, you can pretty much drop in the body of the definition
00:25:14 <jle`> so if you ever see (f . g) x, you can replace it with f (g x)
00:25:56 <rcyr> Right, I think that other languages have just damaged me :(
00:26:09 <jle`> heh.  we all have been there :)
00:26:17 <rcyr> It's really clear now, thank you :)
00:26:17 <benma> rcyr: we are all in the same boat :P
00:28:41 <Walther> @src otherwise
00:28:41 <lambdabot> otherwise = True
00:32:52 <liste> is it bad style to use another pattern match instead of an `otherwise` guard?
00:33:07 <liste> as in foo x y | x < y = ... otherwise = ...
00:33:18 <liste> versus foo x y |Â x < y = ... foo _ _ = ...
00:34:09 <merijn> liste: "it depends"
00:34:21 <merijn> liste: New pattern match means you can't use the same where clause
00:34:32 <Walther> hmm. would it be possible to typecheck against unsorted lists as inputs, i.e. only accept sorted lists as input?
00:34:32 <merijn> Because where clauses scope across guards, but not different patterns
00:35:01 <Walther> example usecase, merge function that can be promised to have a sorted output
00:35:18 <merijn> Walther: Easiest way is to define "newtype Sorted a = Sorted [a]", hide the constructor and then define "newSorted :: [a] -> Sorted a; newSorted xs = Sorted (sort xs)"
00:35:32 <Walther> ah
00:35:33 <hnfmr> is there a function that waits for a thread to finish? like waitFor tid
00:35:41 <liste> Walther to guarantee the sortedness you need dependent types
00:35:54 <merijn> liste: But I don't think there's anything inherently wrong with your extra pattern
00:35:54 <liste> for the compiler to guarantee it, I mean
00:35:59 <Walther> Mmh.
00:36:16 <merijn> hnfmr: Simplest way is to create an MVar and have the thread write into it when finished and then do 
00:36:25 <merijn> hnfmr: "takeMVar" in the main thread to block
00:36:35 <merijn> hnfmr: If you have multiple threads you could use a Chan
00:36:51 <hnfmr> merijn: thx :)
00:37:15 <supki> the simplest way is to use async, really
00:37:33 <hnfmr> async and await?
00:37:43 <supki> @hackage async
00:37:43 <lambdabot> http://hackage.haskell.org/package/async
00:37:50 <hnfmr> cool
00:48:06 <unb3k44n7> Pretty sure the neurons in my brain just fired all at once. I died, and then was resurrected. Is this what normally happens when trying to learn Haskell.
00:48:33 <liste> unb3k44n7 yep
00:50:42 <PotatoGim> hello all.
00:50:51 <merijn> unb3k44n7: Yes
00:51:00 <unb3k44n7> So, I found this list that I thought would be helpful https://wiki.haskell.org/Keywords#.21 But then when I was trying to read it, it wasn't. Does anyone have a list that Just Like This One except in more layman explanations?
00:51:06 <merijn> @quote gloss.over
00:51:06 <lambdabot> cjeris says: Cale: I like how you conveniently gloss over the part where your head explodes.
00:51:13 <unb3k44n7> Hello, PoraroGim.
00:51:58 <unb3k44n7> tato*
00:51:59 <merijn> unb3k44n7: tbh, the Haskell Report is pretty readable
00:52:22 <merijn> unb3k44n7: A lot of entries on that list are extension specific too, by the looks of it
00:53:39 * hackagebot arbtt 0.9.0.3 - Automatic Rule-Based Time Tracker  http://hackage.haskell.org/package/arbtt-0.9.0.3 (JoachimBreitner)
00:53:41 * hackagebot tttool 1.4.0.2 - Working with files for the Tiptoi® pen  http://hackage.haskell.org/package/tttool-1.4.0.2 (JoachimBreitner)
00:56:25 <HaskellStudent> Hello, why am I unable to run the following code: http://pastebin.com/Hpc730WW
00:58:00 <merijn> Haskellfant: That looks like prolog, not haskell...
00:58:08 <liste> HaskellStudent that's prolog
00:58:18 <merijn> Whoo! I guessed the language right
00:58:46 <liste> or datalog or mercury? I don't know them well enough to distinguish
00:59:59 <unb3k44n7> Which section of the report lists all the keywords and explains their usage?
01:00:24 <Tehnix> And it was probably because of the ' in the last closee (the prolog code)
01:01:11 <liste> HaskellStudent try /join ##prolog
01:01:27 <liste> for further help in your code
01:01:34 <merijn> unb3k44n7: Chapter 2 on lexical structure defines all keywords, but not their usage, their usage is basically "the rest of the report"
01:02:48 <kadoban> unb3k44n7: Mind if I ask what resources you're using to learn haskell? You're pretty new, right? The haskell report is pretty readable, but â€¦ it's not a very good way to learn haskell I wouldn't think.
01:03:34 <merijn> I'd agree with that, but the initial question was "how to find a list of keywords and their explanation"
01:04:51 <kadoban> Yes of course, not criticizing the response to the question at all.
01:05:57 <unb3k44n7> Meh, It's not helping, merjin, but thank you. 
01:08:05 <merijn> unb3k44n7: If the goal is to learn haskell I would recommend starting with LYAH and https://github.com/bitemyapp/learnhaskell
01:08:19 <merijn> Trying to make sense of lists of keywords is going to get you nowhere
01:08:46 <unb3k44n7> ...
01:09:00 <unb3k44n7> That's not what I'm doing...
01:09:12 <unb3k44n7> I just asked a question. I learn things in my own way.
01:09:35 <mauke[> that question was already answered, though
01:09:54 <xelxebar> :k (Ord a => [] ((,) a))
01:09:55 <lambdabot>     Expecting one more argument to â€˜(,) aâ€™
01:09:55 <lambdabot>     The first argument of â€˜[]â€™ should have kind â€˜*â€™,
01:09:55 <lambdabot>       but â€˜(,) aâ€™ has kind â€˜* -> *â€™
01:10:28 <xelxebar> am I just going to have to wrap [(a,b)] in a newtype if I want to declare it a monad?
01:10:58 <merijn> xelxebar: Yes
01:11:02 <Tehnix> I actually think http://learnyouahaskell.com/chapters is a bit more friendly to ppl new to programming. But dunno, so I'll just throw it out there :)
01:11:10 <mauke[> xelxebar: how does it return?
01:11:12 <merijn> xelxebar: Haskell doesn't have (and can't have) a lambda
01:11:56 <merijn> xelxebar: Also as mauke points out you probably need a Monoid constraint on 'a' (not sure whether that produces a valid lawful monad)
01:12:09 <unb3k44n7> Teh: I've been reading that also.
01:12:15 <unb3k44n7> ..thanks.
01:12:44 <xelxebar> mauke[: a is actually a monoid
01:13:16 <merijn> xelxebar: Be careful and check whether the laws hold!
01:15:31 <mauke[> @unmtl WriterT w [] a
01:15:32 <lambdabot> [] (a, w)
01:16:36 <unb3k44n7> Are !'s and !!'s only used with lists?
01:16:58 <kadoban> :t (!)
01:16:59 <lambdabot> Ix i => Array i e -> i -> e
01:17:00 <kadoban> :t (!!)
01:17:01 <lambdabot> [a] -> Int -> a
01:17:13 <liste> unb3k44n7 it can mean different things in different contexts
01:17:51 <liste> it can also be a strictness annotation
01:18:10 <DrPavelheer> :t length
01:18:10 <liste> in more advanced contexts
01:18:11 <lambdabot> Foldable t => t a -> Int
01:18:40 <unb3k44n7> Ok. 
01:18:43 <liste> @let data StrictThing = StrictThing !Int !Int
01:18:45 <lambdabot>  Defined.
01:19:21 <merijn> unb3k44n7: ! in a datatype is a strictness annotation, in a pattern match it's a strictness annotation using the BangPatterns extension
01:19:36 <merijn> Elsewhere ! is just an operator, which means it depends on where you import it from
01:19:53 <xelxebar> merijn: You made me doubt myself and I double checked. I think the laws do hold
01:19:53 <merijn> :t (Data.Map.!)
01:19:55 <lambdabot> Ord k => M.Map k a -> k -> a
01:19:59 <bsrk> exit
01:20:02 <merijn> :t (Data.Array.!)
01:20:04 <lambdabot> Ix i => Array i e -> i -> e
01:20:08 <liste> > let { f (StrictThing _ _) = 5 } in f (StrictThing undefined undefined)
01:20:10 <lambdabot>  *Exception: Prelude.undefined
01:20:10 <mauke[> xelxebar: is your monad different from WriterT []?
01:20:27 <unb3k44n7> Well, Haskell is annoyingly depressing me at the moment so I think I'll give it up for the night, just when I thought I was getting it.  I read something about the BangPatterns too. It's just too much and I can't find anything that explains it all and puts it all together in a way I can understand. I tried looking up stuff individualls. No go. Bah.
01:20:47 <unb3k44n7> individually*
01:20:55 <merijn> unb3k44n7: BangPatterns and strictness really aren't something you should worry about as a beginner
01:21:03 <DrPavelheer> Yeah, I have no idea what those are
01:21:04 <merijn> unb3k44n7: So really "! is just an operator"
01:21:23 <DrPavelheer> Well, strictness I know. But I've never used BangPatterns
01:21:29 <unb3k44n7> That's fine to say It's an operator but that doesn't help me at all.
01:21:39 <merijn> DrPavelheer: BangPatterns is just "strictness annotation in pattern match"
01:21:50 <jle`> yeah, that's why people usually suggest going through some sort of course/step-by-step intro heh, it definitely alleviates the headaches
01:21:50 <merijn> unb3k44n7: There's nothing else to say, operators can be defined in any library
01:21:52 <xelxebar> merijn: Yes. That actually answers why we need a newtype, since we might have different monads depending on the functor we use. Thanks!
01:22:10 <DrPavelheer> merijn: Got it
01:22:12 <merijn> unb3k44n7: operators are just "functions that are written infix"
01:22:19 <jle`> ! is an operator, but there isn't much to learn or much use to learn about it when you are learning haskell
01:22:21 <unb3k44n7> Ugh.
01:22:22 <mauke[> unb3k44n7: why are you asking about ! specifically?
01:22:35 <unb3k44n7> I just want to know. Whydoes there have to be a reason?
01:22:37 <merijn> DrPavelheer: So you can write "foo !x = something" instead of bothering with remembering "how do I seq this correctly"?
01:22:48 <mauke[> unb3k44n7: because the answer depends on the context
01:22:50 <unb3k44n7> Sorry. I'm like super annpyed.
01:22:50 <DrPavelheer> Because it's kind of advanced
01:23:03 <DrPavelheer> If you're a beginner, advanced stuff is scary
01:23:25 <merijn> The real problem is that a lot of people expect operators to be built into the language and thus have a single meaning
01:23:34 <merijn> As opposed to "that depends on which library you import it from"
01:23:40 <unb3k44n7> What is the general meaning?
01:23:47 <unb3k44n7> Without trying to make it complicated?
01:23:49 <jle`> there is no general meaning; that's like asking what "foo" means
01:23:49 <mauke[> unb3k44n7: none
01:23:50 <merijn> unb3k44n7: There is none, it's just a function
01:23:55 <jle`> "what does `foo` mean?"
01:23:57 <liste> unb3k44n7 usually ! is used to look up things
01:24:00 <jle`> -- it's whatever it is defined as in that file
01:24:01 <liste> by convention
01:24:10 <unb3k44n7> Aka used with lists?
01:24:13 <mauke[> unb3k44n7: no
01:24:15 <jle`> "what does x mean?"
01:24:25 <mauke[> unb3k44n7: I've never seen a ! that worked on lists
01:24:29 <mauke[> I can't rule it out, of course
01:24:32 <jle`> it's just a normal identifier, like foo, or bar, or x
01:24:37 <unb3k44n7> !! works on lists
01:24:43 <DrPavelheer> that's different than !
01:24:46 <unb3k44n7> It picks out something in the list
01:24:47 <mauke[> yes, the one in Data.List
01:24:53 <DrPavelheer> that's like + and ++
01:24:55 <unb3k44n7> Ok so I just explained !!. So what's !?
01:25:04 <jle`> ! doesn't mean aything until you define it
01:25:08 <jle`> that's like asking "what does foo mean?"
01:25:10 <mauke[> unb3k44n7: you just explained the !! from Data.List. which ! are you asking about?
01:25:13 <unb3k44n7> Do it
01:25:20 <unb3k44n7> - do it.. typo
01:25:21 <jle`> i mean, until you define it in a file
01:25:28 <merijn> unb3k44n7: No "!!" doesn't work on lists, "the !! imported from Data.List" works on lists
01:25:35 <jle`> > let x ! y = x + y in 5 ! 7
01:25:36 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ a -> a
01:25:36 <lambdabot>      Relevant bindings include
01:25:36 <lambdabot>        y :: a (bound at <interactive>:1:9)
01:25:44 <mauke[> unb3k44n7: there are at least Data.Map.! and Data.Array.! and probably others
01:25:46 <Tehnix> Isn't it just the strictness enforcer?
01:25:56 <mauke[> Tehnix: you're behind
01:26:00 <merijn> Tehnix: ! is a valid operator
01:26:01 <Tehnix> Ah
01:26:10 <jle`> unb3k44n7: usually, someone will define (!) = blah blah blah in their file
01:26:19 <Tehnix> sry, hard to multitask :x
01:26:19 <jle`> and then, whenever you import that file, if you use (!), you'll use the definition in that file
01:26:32 <jle`> it's the same thing as a function like "foo"
01:26:43 <jle`> if i defined "foo x = x * 2' in a file, then when i say "foo 3", it'll evaluate to 6
01:26:48 <frerich> ski: I have to ask - I just had a colleague (who, unlike me, actually enjoyed sufficient math education to get a PhD) explain a bit of math to me and he talked about Schoenfinkel and three 'S', 'K', 'I' combinators (we got there after talking about what my understanding of 'eta reduction' is). I wonder - is it those three combinators where you got your name from? :-)
01:27:05 <jle`> but you can't ask "what does foo mean in haskell?", because...well...it's just a name of something you can define
01:27:11 <merijn> frerich: I'm going to go with "probably" :p
01:27:27 <jle`> > let foo x = x * 2 in foo 10
01:27:28 <lambdabot>  20
01:27:45 <merijn> frerich: Fun fact, you don't even need all three combinators to be turing complete as there was a way to get it down to 2 (or even 1?) using that to express the others
01:28:03 <frerich> merijn: Yeah, AFAIK 'S' and 'K' are enough since I = SKK
01:28:13 <jle`> unb3k44n7: did you know that in haskell, operators are just things you can define, like normal functions?
01:28:18 <mauke[> you can get down to 1 by using a different combinator
01:28:20 * frerich has 'SKKx = Kx (Kx) = x' on his whiteboard.
01:28:41 <jle`> > let x *&$(*#$# y = x + y in 3 *&$(*#$# 10
01:28:42 <lambdabot>  <hint>:1:18: parse error on input â€˜=â€™
01:28:48 <jle`> > let x *&$*#$# y = x + y in 3 *&$*#$# 10
01:28:50 <lambdabot>  13
01:29:08 <jle`> there, i just defined the *&$*#$# operator an operator that adds its two inputs.  and i called it on 3 and 10
01:29:09 <mauke[> frerich: or SKS!
01:30:23 <jle`> > let foo x = x * 2 in foo 3
01:30:26 <lambdabot>  6
01:30:31 <jle`> there, i defined the "foo" function to be the function that takes an input and doubles it
01:30:53 <merijn> ok, time to ditch IRC an attempt to write papers :p
01:31:09 <jle`> > let (!) x y = x + y in 12 ! 95
01:31:11 <lambdabot>  107
01:31:23 <jle`> ^^ there, i just defined (!) to be the operator that ads its two inputs, and then i called it with 12 and 19
01:31:40 <jle`> unb3k44n7: see, (!) is just a normal identifier that you can name/define to be whatever you want in your file/project
01:31:53 <jle`> there i just defined (!) = (+), so 5 ! 8 = 13
01:31:57 <mauke[> > let (!) x y = (x, (y, length (show y)) in 'x' ! 100
01:31:59 <lambdabot>  <hint>:1:40: parse error on input â€˜inâ€™
01:32:07 <mauke[> I have failed
01:32:12 <xelxebar> Is there a class for groups?
01:32:40 <mniip> mauke, needs more )
01:32:49 <xelxebar> whoops, I found it on hoogle
01:33:58 <Tehnix> unb3k44n7: did you look at https://ocharles.org.uk/blog/posts/2014-12-05-bang-patterns.html for the bang patterns thing? (although I would also suggest just reading it now, and waiting with the understanding of it)
01:34:28 <Tehnix> unb3k44n7: it's not very in-depth about it though, but will show some use-cases
01:35:42 <Tehnix> unb3k44n7: actually, I take that back, it's quite okay at explaining it :)
01:47:47 <DerisiveLogic> Anyone here from NYC?
01:49:43 <fishburne529> how are let statements in a do block desugered?
01:49:45 <Walther> @src length
01:49:45 <lambdabot> Source not found. My pet ferret can type better than you!
01:50:16 <jle`> fishburne529: `do let x = y; m` is let x = y in m
01:50:31 <jle`> fishburne529: you can check with lambdabot if you are unsure; it has the @undo command you can try out in pm
01:50:38 <jle`> @undo do let x = y; m
01:50:38 <lambdabot> <unknown>.hs: 1: 16:Parse error: EOF
01:50:44 <jle`> @undo do let {x = y}; m
01:50:44 <lambdabot> let { x = y} in m
01:50:56 <jle`> @undo do let {x = y}; m; n; o
01:50:56 <lambdabot> let { x = y} in m >> n >> o
01:51:09 <jle`> @undo do m; let {x = y}; n; o
01:51:09 <lambdabot> m >> let { x = y} in n >> o
01:51:12 <jle`> etc.
01:51:46 <fishburne529> jle`, thanks. That is so nice of lambdabot. What other tricks can it do?
01:52:00 <jle`> try exploring @help in pm :)
01:53:04 <mauke[> fishburne529: it can evaluate expressions with "> " and tell you types with ":t "
01:53:42 * hackagebot halive 0.1.0.0 - A live recompiler  http://hackage.haskell.org/package/halive-0.1.0.0 (lukexi)
01:53:55 <fishburne529> mauke[, Great. But everyone will see it, right?
01:54:30 <mauke[> not if you do it in private
01:55:03 <fishburne529> mauke[, Trying it now..
02:23:18 <matt_s3d> Hi All, im looking to enagage with someone who can potentionally work some majic on a program - where do I go about asking for that?
02:23:45 <tdammers> craigslist? :X
02:26:43 <kadoban> matt_s3d: Potentially here. Details?
02:33:15 <Myrl-chan> Why use monads over composing fmaps?
02:33:44 * hackagebot halive 0.1.0.1 - A live recompiler  http://hackage.haskell.org/package/halive-0.1.0.1 (lukexi)
02:33:49 <Myrl-chan> Hmmm... thart sounded more stupid than usual.
02:33:54 <joneshf-laptop> :)
02:36:43 <alem0lars___> Hi, I'm using the Hakyll web framework (I'm both haskell and hakyll newbie)..
02:37:19 <joneshf-laptop> i want to convert an imperative loop into haskell without understanding what the algorithm does, what are my options for doing this easily?
02:37:25 <joneshf-laptop> oh also the loop terminates early
02:37:32 <alem0lars___> Which is the preferred way to compile pages (getResourceBody, makeItem, rely on another compiler) ?
02:37:40 <joneshf-laptop> s/terminates/can terminate/
02:39:53 <kadoban> alem0lars___: What are you trying to do exactly?
02:42:45 <alem0lars___> kadoban: In the most common usecase, I have a html page (e.g. foobar.html) and I want to compile it passing a context. However, I saw hakyll examples / github projects and I've seen some one uses getResourceBody, some other getResourceString, some other makeItem using a template instead of a "normal" html page
02:42:50 <mjrosenb> joneshf-laptop: write an interpreter for the language it is currently implemented in?
02:43:20 <alem0lars___> so I got really confused
02:44:50 <liste> joneshf-laptop, for early termination, monads with MonadPlus instances (e.g. Maybe, MaybeT) may help'
02:45:26 <liste> esp. mzero
02:46:01 <joneshf-laptop> mjrosenb, it's pseudocode, and that sounds like more work than i'm willing to put in. Looking for a canned solution, it needn't be robust or usable after a day or two.
02:46:20 <kadoban> alem0lars___: Those all seem to mean different things? I'm â€¦ not really following honestly.
02:46:24 <joneshf-laptop> liste, i'll give that a go
02:46:54 <alem0lars___> AFAIK getResrouceString is the same of getResourceBody but also includes metadata. But, can I interchangeably use them when I don't need metadata? In that case, why there is that function (getResourceBody) ?
02:47:31 <kadoban> If that's true, and it sounds like it might be â€¦ because sometimes there's metadata?
02:50:15 <alem0lars___> This is not clear to me.. I mean, if there isn't metadata getResourceBody is the same of getResourceString and if there is metadata getResourceString provides all the functionality of getResourceBody plus the metadata... I don't see the sense of having getResourceBody.. Didn't I understand the purpose?
02:50:50 <kadoban> getResourceBody is for when you just want the body â€¦
02:52:54 <Myrl-chan> I got banned in ##c for changing nicks. :D
02:55:27 <alem0lars___> kadoban: ok.. but when should I use getResourceString/getResourceBody instead of makeItem ?
02:56:29 <kadoban> alem0lars___: makeItem does something /completely/ different as far as I understand, so I really don't understand the question. Do you have a high-level goal you're trying to achieve?
02:57:42 <xelxebar> Playing around with the djinn cli utility. It seems to be doing a few nonstandard things, at least with regards to standard linux i/o and interupts
02:57:46 <alem0lars___> kadoban: Yes, I have to compile a normal html page
02:58:10 <alem0lars___> kadoban: I have an html page which have some context..
02:58:16 <xelxebar> Pressing Ctrl-D from the djinn prompt just returns another prompt instead of exiting program. That seems pretty non-standard to me
02:59:04 <xelxebar> Also, doing something like `djinn <<<"f ? a -> a"` from the command line causes "Djinn> Djinn> Djinn> ..." to be output indefinitely...
02:59:23 <kadoban> alem0lars___: That sounds pretty normal, why are you doing /any/ of that stuff? Does one of the built-in compilers not work for you? Have you gone through the tutorial things?
02:59:27 <xelxebar> Would anyone else mind checking if it behaves the same for you guys?
03:02:09 <alem0lars___> kadoban: Following the tutorials I came out with this https://gist.github.com/alem0lars/68bce0c6195af6bec0fa for the index page.. As you can see there I'm using getResourceString but I'm not sure if I should use something else instead (makeItem or getResourceBody or pandocCompiler)
03:02:58 <Cale> xelxebar: The Ctrl-D thing I can confirm, but I don't see the other behaviour
03:03:13 <Cale> I get the correct output for f ? a -> a
03:03:39 <Cale> Type :quit to quit djinn if you're stuck
03:04:10 <kadoban> alem0lars___: Well, is it working? For plain HTML â€¦ I don't see that it'd matter a ton really. It matters more when you have content that needs to be converted and etc.
03:04:17 <kadoban> alem0lars___: Sorry, bed time. I'll be back in the morning if you're still having trouble, if you don't find another person to help. #hakyll is pretty good, but slow traffic.
03:04:53 <alem0lars___> kadoban: ok thanks
03:06:21 <mjrosenb> does a file that declares FFI functions need to have only these declarations in it, or can I have other functions in there as well?
03:08:13 <xelxebar> Cale: Thanks. Running `djinn <<<"f ? a -> a"` from the bash prompt gives you the expected output?
03:16:05 <bennofs> mjrosenb: it can have other functions as well
03:16:06 <comprehension> i'm writing to a handle with hPutLine and immediately trying to read from it with hGetLine, but it fails with an EOF exception. what might i be doing wrong?
03:16:42 <comprehension> i'm inside a do block in the IO monad so i dont think it's a laziness issue
03:16:55 <comprehension> i tried adding in hFlush between the two calls but no luck
03:17:52 <feetpicsplz> comprehension: Can you put it on a pastebin?
03:18:01 <comprehension> feetpicsplz: yes, one second
03:18:39 <comprehension> feetpicsplz: http://lpaste.net/133360
03:18:46 * hackagebot hlint 1.9.21 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.9.21 (NeilMitchell)
03:18:51 <feetpicsplz> comprehension: Can I have the raw?
03:19:02 <feetpicsplz> I'm compiling gcc right now, so my system's very slow.
03:19:25 <comprehension> sure, one sec
03:19:34 <comprehension> feetpicsplz: http://lpaste.net/raw/133360
03:19:37 <feetpicsplz> Thanks. :)
03:21:34 <mjrosenb> bennofs: cool!
03:21:50 <comprehension> "withTempFile" is from the temporary package https://hackage.haskell.org/package/temporary-1.2.0.3/docs/System-IO-Temp.html
03:23:55 <feetpicsplz> Hmmm
03:25:42 <liste> do you need to seek to the beginning after writing to the file?
03:25:56 <liste> I don't remember how read/write mode works
03:26:24 <mjrosenb> how does recursive-do work?
03:26:36 <bennofs> mjrosenb: you mean mdo? (do rec)
03:26:43 <comprehension> liste: oh, that could be it
03:26:45 <mjrosenb> bennofs: yeah.
03:26:53 <bennofs> mjrosenb: do you know how 'fix' works?
03:26:59 <comprehension> that's probably definitely it
03:27:16 <feetpicsplz> comprehension: That's what I'm thinking too.
03:27:42 <zipper> comprehension: Really? Are we not going overboard with this programming inspired nicks :)
03:27:49 <feetpicsplz> I'ma go try it out right now.
03:27:56 <mjrosenb> bennofs: yeah.
03:27:57 <feetpicsplz> zipper: Yeah, I agree.
03:27:59 <zipper> The zipper judges the comprehension
03:28:55 <comprehension> ha
03:29:00 <comprehension> the seek fixed it, though
03:29:01 <comprehension> thanks!
03:29:09 <bennofs> mjrosenb: ok, so let's consider "recursive let" (haskell let's are recursive by default). If you have let a = 3 : b; b = 4 : a in a, you can write it using fix like this: 'fix (a,b) = (3:b, 4:a)'
03:29:30 <feetpicsplz> comprehension: Wouldn't you have to reread the original content thougih?
03:29:33 <bennofs> mjrosenb: you can apply the same idea to recursive do: there is mfix :: (a -> m a) -> m a
03:30:04 <m4lvin> is there a standard library or a one-liner for this function? http://lpaste.net/133361
03:30:07 <comprehension> feetpicsplz: i need to rethink how i'm structuring my code, i suppose
03:30:29 <zipper> m4lvin: filter?
03:30:37 <zipper> :t filter
03:30:39 <lambdabot> (a -> Bool) -> [a] -> [a]
03:30:45 <comprehension> in my actual code these handles are connected to sockets
03:31:03 <bennofs> mjrosenb: so do a <- f b; b <- g a; return b  is desugared into something similar to: fmap snd $ mfix $ \(a,b) -> (,) <$> f b <*> g a
03:31:21 <zipper> m4lvin: Tell me if that helps
03:31:24 <m4lvin> zipper: I want to know if all list entries are equal to each other, not if the have some property
03:31:44 <feetpicsplz> comprehension: `hSeek handle RelativeSeek 0` ?
03:31:55 <liste> m4lvin foldr (==) ?
03:31:56 <zipper> :t all
03:31:58 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
03:32:06 <mjrosenb> bennofs: can mfix be implemented in haskell, or is it some magic that messes with the RTS?
03:32:09 <bennofs> mjrosenb: for mfix to work, it's required that the 'effect' does not depend on it's own result (so mfix $ \r -> if r then a else b would not work, since the effect performed depends on r)
03:32:13 <zipper> >all 5 [1,2,3,4]
03:32:28 <zipper> How to use the bot
03:32:29 <bennofs> mjrosenb: for some monads, it can be implemented in pure haskell#
03:32:38 <feetpicsplz> :t all
03:32:39 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
03:32:40 <liste> zipper you need a space after the ">"
03:32:46 <bennofs> mjrosenb: (for example, it would be just fix for the Identity monad :)
03:32:46 <comprehension> feetpicsplz: hSeek handle AbsoluteSeek 0 is fine for my testing purposes; i think i need to duplicate the handle inside tellClient for my actual code
03:32:53 <bennofs> mjrosenb: but for IO, it uses unsafeInterleaveIO
03:32:56 <zipper> all 5 [5,5]
03:33:02 <feetpicsplz> comprehension: Try RelativeSeek.
03:33:05 <zipper> > all 5 [5,5]
03:33:06 <lambdabot>      No instance for (Num (a0 -> Bool))
03:33:06 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
03:33:06 <lambdabot>        arising from the literal â€˜5â€™
03:33:09 <feetpicsplz> zipper: > all (==5) [5,5]
03:33:25 <m4lvin> liste: hm, but "foldr (==) True ([False,True]++(repeat True))" never stops, though it could.
03:33:47 <feetpicsplz> m4lvin: It can't, since it has no idea that it's a never ending list of trues.
03:33:49 <liste> yeah, you only need to compare to the head
03:33:54 <feetpicsplz> Oh wait.
03:34:14 <feetpicsplz> Yeah, it can't, because of what I just said.
03:34:24 <zipper> > all (\x -> == x) [4,4]
03:34:25 <lambdabot>  <hint>:1:6: parse error in lambda: no expression after '->'
03:34:34 <feetpicsplz> What's more, you're using foldr on a never-endling list.
03:34:36 <zipper> I swear I'm...
03:34:43 * feetpicsplz pets zipper 
03:34:58 <bennofs> mjrosenb: similar to this: fixIO f = do resultVar <- newEmptyMVar; getResult <- unsafeInterleaveIO (takeMVar resultVar); result <- f getResult; putMVar resultVat result; return result
03:35:05 <Cale> xelxebar: Oh, sorry, no I didn't try that from the bash prompt. I just ran djinn and typed the command
03:35:05 <liste> > let {alleq [] = False; alleq (x:xs) = any (==x) xs} in alleq [1, 2, 3, 4, 5]
03:35:07 <lambdabot>  False
03:35:12 <bennofs> mjrosenb: see http://hackage.haskell.org/package/base-4.8.0.0/docs/src/System-IO.html#fixIO
03:35:12 <zipper> feetpicsplz: I'm trying to do what's impossible.
03:35:18 <liste> s/any/all/
03:35:24 <feetpicsplz> zipper: Which would be...?
03:35:26 <Cale> xelxebar: It does appear to be handling EOF by giving another prompt
03:35:50 <mjrosenb> bennofs: ok, based on that description, I'm like 90% sure this code will work.
03:36:18 <zipper> feetpicsplz: Whatever m4lvin was asking. I was trying to get the head out of that and compare with everything else
03:36:28 <zipper> It should short circuit thoough
03:36:37 <m4lvin> liste: with all that seems to do it.
03:36:44 <feetpicsplz> No, it can't.
03:36:45 <nshepperd> /url/133
03:36:50 <bennofs> mjrosenb: as long as the effects that you perform do not depend on values of effects that haven't been performed yet, you should be fine
03:36:58 <liste> > let {alleq [] = False; alleq (x:xs) = all (==x) xs} in alleq [1, 2, 3, 4, 5]
03:37:00 <lambdabot>  False
03:37:07 <liste> > let {alleq [] = False; alleq (x:xs) = all (==x) xs} in alleq [1, 1]
03:37:10 <lambdabot>  True
03:37:11 <zipper> feetpicsplz: m4lvin Hey here's a good idea sort the list then compare head and tail
03:37:18 <liste> > let {alleq [] = False; alleq (x:xs) = all (==x) xs} in alleq [1]
03:37:20 <lambdabot>  True
03:37:25 <m4lvin> > let {alleq [] = False; alleq (x:xs) = all (==x) xs} in alleq ([False,True]++(repeat True))
03:37:27 <lambdabot>  False
03:37:30 <m4lvin> :-)
03:37:32 <feetpicsplz> zipper: I don't think you can sort an infinite list.
03:37:46 <xelxebar> Cale: thanks for checking. It does handle standard file input fine on my end: putting "f? a -> a" in foo.txt and running `djinn foo.txt` works as expected.
03:37:48 <zipper> feetpicsplz: We're doing an infinite list?
03:37:51 <zipper> Why?
03:37:56 <feetpicsplz> zipper: (repeat True)
03:38:03 <zipper> feetpicsplz: You know lists are O(n) right?
03:38:26 <zipper> If it's infinite how can we know if all elements are the same?
03:38:28 <feetpicsplz> Also, I didn't know the context.
03:38:40 <feetpicsplz> zipper: Thing is, you can't.
03:38:44 <feetpicsplz> You won't even know if it's infinite.
03:38:46 <zipper> Yes you can't
03:38:47 * hackagebot spaceprobe 0.0.0 - Optimization over arbitrary search spaces  http://hackage.haskell.org/package/spaceprobe-0.0.0 (SeanBurton)
03:38:49 <bennofs> you can sometimes sort infinte lists because of laziness
03:39:06 <liste> zipper we can know when all elements aren't the same
03:39:09 <nshepperd> you can semi-decide on infinite lists
03:39:10 <zipper> bennofs: How? You'll sort it until the end of time.
03:39:12 <bennofs> if you have False < _ = True, then you do not need to know the rest of the list 
03:39:19 <nshepperd> you'll know if an element is different
03:39:21 <zipper> liste: No we can't
03:39:28 <nshepperd> but if you are all the same you'll spin forever
03:39:28 <mjrosenb> bennofs: that is not entirely what I'm worried about.
03:39:28 <feetpicsplz> Yes we can.
03:39:34 <xelxebar> Cale: I don't know enough about pipes to guess at what might be causing the difference when using <<<"..." vs a regular file
03:39:41 <zipper> Well yes kinda
03:39:41 <feetpicsplz> Using a short-circuiting any allows us.
03:39:47 <zipper> but...
03:39:49 <feetpicsplz> > and False:(repeat True)
03:39:51 <lambdabot>      Couldn't match expected type â€˜t0 Boolâ€™ with actual type â€˜Boolâ€™
03:39:51 <lambdabot>      In the first argument of â€˜andâ€™, namely â€˜Falseâ€™
03:39:51 <lambdabot>      In the first argument of â€˜(:)â€™, namely â€˜and Falseâ€™
03:40:04 <feetpicsplz> > all False:(repeat True)
03:40:06 <lambdabot>      Couldn't match expected type â€˜a -> Boolâ€™ with actual type â€˜Boolâ€™
03:40:06 <lambdabot>      In the first argument of â€˜allâ€™, namely â€˜Falseâ€™
03:40:06 <lambdabot>      In the first argument of â€˜(:)â€™, namely â€˜all Falseâ€™    Couldn't match exp...
03:40:10 <feetpicsplz> what
03:40:17 <feetpicsplz> :t and
03:40:18 <lambdabot> Foldable t => t Bool -> Bool
03:40:27 <feetpicsplz> > and (False:(repeat True))
03:40:29 <lambdabot>  False
03:40:36 <zipper> You can't ever say that all elements are the same because your test for elements not being the same passed.
03:40:42 <zipper> It's not conclusive
03:40:56 <zipper> or maybe I should focus on something else.
03:41:05 <feetpicsplz> Problem is, foldl/foldr can't short-circuit because it has no idea about what you're trying to do.
03:41:16 <bennofs> feetpicsplz: foldr can short-circuit
03:41:19 <zipper> feetpicsplz: foldr works on infinite lists
03:42:10 <bennofs> > foldr (\x next -> x || next) False ([False, True] ++ repeat False)
03:42:10 <zipper> The bigger the list the longer it takes to traverse it. Try not to use lists for huge things especially infinite ones.
03:42:11 <lambdabot>  True
03:42:13 <liste> zipper you're right. the only answers for checking if all the elements in a list are the same are "no" and "inconclusive"
03:42:21 <liste> infinite list*
03:42:31 <feetpicsplz> Er
03:42:44 <feetpicsplz> I think I don't know how fo;dr works. Lol
03:42:56 * zipper pets feetpicsplz 
03:43:08 <feetpicsplz> BRB
03:43:19 <zipper> I should go too.
03:43:23 <zipper> Duty calls.
03:45:52 <mjrosenb> main: thread blocked indefinitely in an MVar operation
03:46:10 <mjrosenb> bennofs: well, at least it gave me an error, rather than crashing!
03:46:45 <bennofs> mjrosenb: can you show the code?
03:48:28 <mjrosenb> bennofs: sure, https://gist.github.com/8c247e94c73cb3a8c0ca
03:49:48 <mjrosenb> bennofs: I'm tryting to use mfix/mdo/do rec to build up a [CString] copy of a [String], using only stack allocated values.
03:51:27 <mjrosenb> hrmm, I wonder if making that an ~ pattern would fix it.
03:52:03 <bennofs> mjrosenb: the problem is that in recCsize, 'f' depends on the result of itself: 'all' depends on the result of recCize' f all l, which performs the effect of 'f all' in the base case. 
03:52:04 <feetpicsplz> Er.
03:52:11 <feetpicsplz> Sorry about that, I was being stuid.
03:52:31 <feetpicsplz> I was mixing with imperative folds and functional folds. :P
03:52:38 <feetpicsplz> s/with/up/
03:52:58 <bennofs> mjrosenb: The "effect" that 'f all' performs cannot be computed before 'all' is known. 'all' is only known after recCize' returned
03:53:31 <feetpicsplz> Well, you can't know if something's all equal.
03:53:37 <mjrosenb> bennofs: only the individual elements of the list should depend on it, the cons cells shouldn't depend on it at all.
03:53:37 <feetpicsplz> Only know if something's not equal.
03:54:14 <feetpicsplz> The possible answers would be False or bottom.
03:55:24 <bennofs> mjrosenb: hmm wait, isn't 'all' always '[]' ?
03:55:41 <bennofs> mjrosenb: oh no, nvm
03:56:25 <feetpicsplz> I blame crappy tutorials that taught me foldr iterates from the right.
03:56:33 <feetpicsplz> (It wasn't a Haskell tutorial.)
03:57:04 <feetpicsplz> brb now
03:59:29 <bennofs> mjrosenb: this cannot work. the value of 'all' is only available *after all the effects of the do rec block were run*. This also means that the 'free' effect of withCString was already executed, so your CString does not exist anymore
03:59:58 <bennofs> (since putMVar is only executed after the action)
04:00:37 <mjrosenb> bennofs: that's what I was afraid of :-/
04:01:02 <mjrosenb> I guess I can just use an accumulator, and reverse the list manually
04:01:14 <bennofs> mjrosenb: you could also use difference lists
04:01:22 <bennofs> not sure if they are more efficient
04:04:34 <mjrosenb> yeah, reversing the list works.
04:08:48 * hackagebot spaceprobe 0.1.0 - Optimization over arbitrary search spaces  http://hackage.haskell.org/package/spaceprobe-0.1.0 (SeanBurton)
04:10:02 <dramforever> ooh, diff lists
04:12:37 <dramforever> that reminds me of this question: I heard that code generated by GHC handle thunks like this:
04:13:13 <dramforever> Evaluated values: Pointer to function that would push the arguments to the constructor on a stack or something
04:13:30 <srhb> Hmm, not sure how stack factors in.
04:13:41 <dramforever> okay ignore it....
04:13:48 <dramforever> I'm just guessing wildly
04:13:49 * hackagebot spaceprobe 0.2.0 - Optimization over arbitrary search spaces  http://hackage.haskell.org/package/spaceprobe-0.2.0 (SeanBurton)
04:13:52 <srhb> I think of them more as a pointer to a function that when first visited computes the value and updates the pointer location to that value
04:14:05 <dramforever> okay yep
04:14:38 <dramforever> I'm not a native English speaker, so I'm having a (sort of) hard time expressing my thoughts
04:14:59 <srhb> That's fine, a lot of us share in that struggle. :-)
04:15:11 <dramforever> okay the Question: Is this because it's really faster than storing a flag?
04:15:19 <dramforever> Or is it because it "looks" faster
04:15:53 <srhb> dramforever: The main point is that if we don't thunk, the value is never computed, thus saving time and space.
04:16:08 <dramforever> hmm...looks good
04:16:28 <srhb> dramforever: Which is basically laziness.
04:16:49 <dramforever> so how fast is this? I mean, other "dynamic" languages use lots of pointers as well
04:17:02 <srhb> dramforever: That's really hard to answer without relating it to something. 
04:17:17 <dramforever> okay...badly expressed question
04:17:18 <srhb> dramforever: If you don't ever compute the value it's obviously very fast compared to computing any non-trivial value!
04:18:13 <srhb> So it's not really a question of static vs. dynamic, but lazy vs strict.
04:18:38 <dramforever> well, I'm talking about pointers. You know, indirect jumps
04:19:32 <srhb> dramforever: So your question is how much overhead is there to visiting a pointer and forcing the thunk over actually just visiting the value (assuming it were already computed)
04:19:42 <dramforever> yep
04:19:46 <dramforever> wait no no
04:20:32 <dramforever> it's the overhead to find out that a value is evaluated
04:20:41 <srhb> Well, the cost of following a pointer.
04:20:45 <srhb> (ie. cheap)
04:21:08 <dramforever> but is it a *function* pointer
04:21:10 <dramforever> ?
04:21:19 <srhb> dramforever: If the value is unevaluated, yes.
04:21:28 <dramforever> how about if it's evaluated
04:21:51 <nshepperd> ghc uses pointer tagging for evaluated values of simple types
04:22:37 <dramforever> nshepperd: so it's essentially a flag?
04:22:43 <nshepperd> lowest two bits: 00 -> unevaluated; 01 -> first constructor; 10 -> second constructor; 11 -> other
04:23:07 <nshepperd> yeah I guess you could call that a kind of flag
04:23:12 <dramforever> okay, then there's an overhead
04:23:26 <dramforever> because we have to check the flag
04:24:12 <nshepperd> but I mean for many values it's not really an overhead because it tells you the exact constructor as well
04:24:43 <dramforever> okay, so it's like "amortized"
04:26:04 <z16> 04:45 < hectortrope> z16: http://learnyouahaskell.com/chapters  this not my style of reading I need serious book without fun u have any
04:26:07 <z16> 04:45 < hectortrope> plz
04:26:08 <Cale> iirc, it's only used for types with few enough constructors (max 3 constructors on 32 bit, max 7 constructors on 64 bit)
04:26:10 <dramforever> Thank you, nshepperd and arhb, I think I understand these better
04:26:14 <z16> "Can I please have a book without fun? D="
04:26:42 <dramforever> Cale: well thanks for that too
04:27:10 <hectortrope> hi z16 
04:27:14 <srhb> dramforever: But the problem is further difficult to go into at this level because branch prediction might make some jumps unnecessary.
04:27:27 <z16> hectortrope: Hi2u2
04:27:37 <z16> Why do you hate fun so much?
04:27:58 <srhb> dramforever: http://community.haskell.org/~simonmar/papers/ptr-tagging.pdf -- this paper is probably your best resource to go to.
04:28:00 <hectortrope> coz I am always funny
04:28:11 <hectortrope> z16:  :-P
04:28:24 <dramforever> srhb: well, I think that although indirect jumps are hard to predict, it's only done once, so no gain by predicting
04:28:27 <dramforever> correct?
04:28:58 <dramforever> srhb: ooh that paper looks interesting
04:29:09 <srhb> dramforever: I know very little about processor architecture, so I don't dare answer that. :)
04:29:38 <dramforever> okay I don't really know much either
04:30:13 <dramforever> (students with the least skills need best teachers, as I sometimes say)
04:31:05 <dramforever> like...Many programmers have heard of "branch prediction" and know a few things to do/avoid to make use of it
04:31:20 <dramforever> but they (we?) don't really know how it works
04:31:24 <Walther> > map (0 : _) [[1..2],[1..5]]
04:31:26 <lambdabot>      Couldn't match expected type â€˜[Integer] -> bâ€™
04:31:26 <lambdabot>                  with actual type â€˜[Integer]â€™
04:31:26 <lambdabot>      In the first argument of â€˜mapâ€™, namely â€˜(0 : _)â€™
04:31:52 <Walther> hm. trying to add 0 to beginning of each sublist
04:32:07 <srhb> Walther: map (0:)
04:32:13 <dramforever> Walther: (0 : _) is not a function that prepends 0 to a list
04:32:24 <dramforever> (\a -> 0 : a) is
04:32:30 <Walther> ah, nod
04:32:32 <dramforever> i.e. you need a lambda
04:32:47 <ronh-> > map (0:) [[1..2],[1..5]]
04:32:48 <srhb> > map (0:) [[1..2], [1..5]]
04:32:49 <lambdabot>  [[0,1,2],[0,1,2,3,4,5]]
04:32:50 <lambdabot>  [[0,1,2],[0,1,2,3,4,5]]
04:33:30 <srhb> Walther: (0 : _) is a list where you've replaced the tail with a hole
04:33:34 <srhb> > 0 : _
04:33:35 <lambdabot>      Found hole â€˜_â€™ with type: [a]
04:33:35 <lambdabot>      Where: â€˜aâ€™ is a rigid type variable bound by
04:33:35 <lambdabot>                 the inferred type of it :: [a] at Top level
04:33:52 <srhb> Conversely, ...
04:33:54 <srhb> :t (0:)
04:33:56 <lambdabot> Num a => [a] -> [a]
04:34:02 <srhb> is a function that takes a list and produces a list.
04:34:33 <dramforever> maybe you shouldn't try to explain "holes" to Walther. maybe it causes confusion
04:34:37 <srhb> (And identical to the lambda that dramforever mentioned, because of sections)
04:35:09 <srhb> dramforever: I think I gave explanations in order of simplicity first. :-) Terms can be written down for future reference.
04:35:12 <dramforever> I...doubt if Walther knows what that thing is...
04:35:23 <dramforever> okay that's alright
04:35:34 <srhb> Your blessing is appreciated. :P
04:36:19 <dramforever> but I keep wondering if "scary" is the number 1 reason why people don't use haskell
04:36:40 <mjrosenb> woah, I've use the C FFI on a function that I didn't write myself!
04:37:06 <dramforever> mjrosenb: yes you can, why not?
04:37:26 <srhb> dramforever: I think the idea that Haskell is scary is scarier than Haskell. Perpetuating it is very harmful, I think. :)
04:37:30 <dramforever> do you remember the example, foreign import sin?
04:38:33 <dramforever> srhb: when I showed one of my friends a piece of haskell code, he complained (rough translation) "what nonsense!"
04:39:18 <srhb> dramforever: Usually that happens when people with only OO experience bring their prejudices into the discussion. Teaching Haskell to former non-programmers is extremely pleasing. :)
04:39:19 <dramforever> he said that the operators are the most scary, and points at >>=, ::, ->
04:39:44 <dramforever> srhb: except that not many tutorials are written for non-programmers
04:39:52 <dramforever> s/are/are not/
04:39:52 <srhb> dramforever: Right, I taught in a classroom setting.
04:40:05 <dramforever> wait don't have to change....
04:40:19 <dramforever> ouch
04:42:12 <srhb> I also think being scared of operators is very nonadventurous and not something I've really seen from beginners. :)
04:42:20 <dramforever> so another question asked again: how come people understand "strings", "objects", "inheritance"
04:42:28 <dramforever> but not "monads", "functors"
04:42:45 <srhb> Because they don't, and they assume that monads and functors are somehow more scary than objects, I think.
04:43:02 <dramforever> they can even understand "friends", which I don't really know anything about
04:43:24 <dramforever> srhb: well, maybe that friend of mine has weird programming taste
04:43:38 <srhb> Maybe he wasn't that interested in learning something new and different. :-)
04:43:55 <liste> why are people not scared of +, -, *, =, etc in math?
04:44:07 <srhb> Most people are scared of =, and they should be! :-)
04:44:46 <liste> my friends are more scared of letters in math than operators
04:44:59 <dramforever> greek letters!
04:45:11 <srhb> I'm really just projecting now. It doesn't interest me that much, honestly. I've found people that really want to learn Haskell are easy to teach. Those that don't aren't. Unsurprisingly.
04:45:14 <z16> = is probably the most abused mathematical operator...
04:45:22 <dramforever> they are scared of Î» but not lambda
04:45:44 <dramforever> ShowerThought: Haskell is much more "for tran" than fortran
04:50:12 * frerich -- as a german speaker -- greatly appreciated the functions schÃ¶n and unschÃ¶n in http://hackage.haskell.org/package/acme-schoenfinkel-0.1.1/docs/Control-Category-Schoenfinkel.html
04:50:41 <liste> if only everyone's keyboards had Ã¶ :D
04:50:52 <frerich> there's schoen and unschoen, too
04:52:22 <z16> frerich: I like hÃ¤sslich too :)
04:52:29 <z16> Although it sounds a bit mean
04:54:22 <liste> could also be Ð¨ÐµÐ¹Ð½Ñ„Ð¸Ð½ÐºÐµÐ»ÑŒing
05:00:15 <arw> umlaute are easy with a compose key, just <compose> " o.
05:00:39 <arw> compose is nice for weird operators anyways.
05:28:45 <alem0lars___> I'm using Hakyll.. I'd like to create a context from a list of strings. I've checked the documentation but I've just found `listField` but I don't understand if it is the right function to be used
05:29:18 <alem0lars___> Can anyone help me?
05:39:23 <liste> alem0lars___ what do you use as keys?
05:41:49 <alem0lars___> liste: I have a list of strings ( e.g. fruits=["apple","banana"] ). I want to use it as a context, i.e. iterating over fruits in a template. So I'd like to have the key "fruits" and iterate into fruits using $for(fruits)$ ... $endfor$
05:43:36 <alem0lars___> or maybe a list of context where every context is a constField
06:03:33 <maxx> h
06:03:37 <maxx> vb
06:08:45 <maxx> what platforms are affected by the event manager bug in ghc 7.10.1? or more specifically, is ghc on windows affected?
06:18:55 * hackagebot waddle 0.1.0.5 - DOOM WAD file utilities.  http://hackage.haskell.org/package/waddle-0.1.0.5 (MartinGrabmueller)
06:31:19 <albeit> Per Tekmo and other people on reddit, is it true that Writer/WriterT (and thus RWS/RWST) are broker and not truly strict? Is there any package that fixes them?
06:41:56 <crocket> Does haskell have a good GUI library?
06:42:01 <crocket> frege has JavaFX.
06:42:42 <tdammers> I don't think any cross-platform language has a *good* GUI library
06:43:11 <tdammers> somehow, as sad as that may be, html5 may be the least shitty GUI "library" at our disposal at this point
06:43:21 <crocket> tdammers, HTML5 is not a library.
06:43:26 <crocket> It is a language in itself.
06:43:26 <tdammers> I know
06:43:33 <tdammers> hence the quotation marks
06:43:33 <crocket> Frege has JavaFX.
06:43:56 * hackagebot inline-c 0.5.2.1 - Write Haskell source files including C code inline. No FFI required.  http://hackage.haskell.org/package/inline-c-0.5.2.1 (FrancescoMazzoli)
06:44:03 <tdammers> there's threepenny-gui, fwiw... haven't used that myself though
06:46:09 <mauke[> crocket: what are frege and javafx?
06:47:19 <crocket> Frege is like haskell on JVM.
06:47:24 <crocket> JavaFX is a new GUI library on java.
06:47:28 <mauke[> meh, java
06:47:31 <crocket> JavaFX is purely written in JAVA.
06:47:46 <crocket> Frege developers are developing a frege binding for JavaFX, called FregeFX.
06:48:04 <crocket> So, using JavaFX on frege doesn't suck as much.
06:48:08 <tdammers> jvm is ok-ish, java-the-language is... uhm... painful
06:48:12 <crocket> JavaFX works on linux, mac, and windows.
06:48:40 <crocket> Frege for java, and Haskell for C.
06:48:45 <mauke[> except when it doesn't because I try to avoid installing any jvm
06:49:29 <crocket> mauke[, Why?
06:49:40 <enikar> crocket: look at this : https://wiki.haskell.org/Wxhaskell
06:50:37 <mauke[> security holes, oracle tries to shove toolbars down my throat, I've never seen any good java software (especially not a good java gui)
06:50:57 <crocket> mauke[, On linux, I have OpenJDK 8.
06:51:07 <crocket> And, JavaFX is good.
06:51:15 <crocket> JavaFX is easily portable.
06:51:22 <merijn> crocket: Great, so use that
06:52:03 <hodapp> people still use JavaFX?
06:52:10 <crocket> Anyway....
06:52:18 <crocket> hodapp, JavaFX is better than Swing.
06:52:28 <hodapp> that's not really what I asked >_>
06:52:43 <crocket> hodapp, Some people do, but I don't know if it has gained mainstream adoption.
06:55:56 <albeit> @src instance Monad WriterT
06:55:56 <lambdabot> Source not found. Where did you learn to type?
06:59:12 <mauke[> http://hackage.haskell.org/package/transformers-0.4.3.0/docs/src/Control-Monad-Trans-Writer-Lazy.html#line-153
07:00:02 <albeit> mauke[: Thanks... found it after realizing it was in transformers not mtl. It seems it still uses the not-actually-strict version of WriterT... is there anywhere that implements it with a simulated StateT?
07:01:14 <kqr> I'm sure I've asked before... but how can I take a set of getters and produce a traversal from them?
07:03:57 * hackagebot engine-io 1.2.6 - A Haskell implementation of Engine.IO  http://hackage.haskell.org/package/engine-io-1.2.6 (TimBaumann)
07:05:51 <c_wraith> kqr: I don't think you can.  a traversal can edit, getters cannot.
07:06:16 <kqr> well... from two lenses then? :)
07:08:13 <kqr> something like alongside but not quite
07:08:57 * hackagebot socket-io 1.3.2 -   http://hackage.haskell.org/package/socket-io-1.3.2 (TimBaumann)
07:09:25 <kqr> if I have a customer I want to be able to do something like customer ^. get2 name age == ("john", 32)
07:09:41 <kqr> instead of having to do (customer ^. name, customer ^. age)
07:10:00 <kqr> but maybe it's easier to do some kind of liftA2 there... maybe
07:10:49 <c_wraith> Oh, you really just want something like Lens' a b -> Lens' a c -> Lens' a (b, c)
07:11:05 <kqr> yeah
07:11:43 <kqr> or, for that matter, Lens' a b -> Lens' a c -> Lens' a (b -> c -> d)
07:12:03 <kqr> ideally in an n-ary manner but I'm guessing that's harder
07:12:17 <c_wraith> wanted: Applicative instance for Lens'.  >_>
07:12:46 <crocket> Is it possible to compile a haskell program that uses a GUI library on linux and use the same code on windows?
07:13:00 <tdammers> well
07:13:08 <c_wraith> crocket: there are cross-platform GUI libs, but compiling them on windows is often a mess.
07:13:10 <tdammers> it's probably *possible*
07:13:26 <crocket> What about on Apple Mac?
07:13:29 <tdammers> cross-compilation has been done successfully, and I believe it should work with Haskell just like with anything else
07:13:42 <giovanni> ciao
07:13:47 <crocket> Haskell should compile on windows.
07:13:50 <tdammers> but you'll have an easier time doing it in a VM running Windows and a barebones haskell toolchain
07:13:56 <giovanni> !list
07:13:56 <monochrom> giovanni: http://hackage.haskell.org/packages/
07:13:58 <tdammers> haskell does compile *on* windows
07:14:04 <Pyrrhus> https://wiki.haskell.org/WxHaskell maybe ?
07:14:08 <tdammers> I thought you meant compiling *for* windows *on* not-windows
07:14:15 <albeit> Does anyone have experience with the stateWriter/RSS package? Supposed to be a better implementation of RWS?
07:14:16 <crocket> Is it possible for me to compile the same haskell GUI program on windows and linux?
07:14:40 <tdammers> a portable codebase that compiles on both and features a GUI? I think it's possible, but not easy.
07:14:42 <crocket> tdammers, I wasn't trying to complicate things...
07:14:53 <crocket> tdammers, But, there's WxHaskell.
07:15:13 <tdammers> so yeah, anyway... wx is probably where it's at, but getting it to work on *any* platform is pretty painful
07:15:21 <kqr> c_wraith, so generally no easy answer? :(
07:15:26 <crocket> I guess that's why frege comes in handy. Compile once, and deploy everywhere.
07:16:02 <ion> I haven't looked at Haskell bindings for Qt but I'd definitely look at Qt in general for GUI.
07:16:25 <kqr> c_wraith, heh, ugly, but works: join (,) customer ^. alongside name age
07:16:33 <tdammers> maybe
07:16:56 <tdammers> but then, the haskell gui story being weak is a more general problem
07:17:08 <c_wraith> kqr: heh. That's just passing the customer twice anyway.  Not really an improvement.
07:17:19 <kqr> yeah not really
07:21:37 <giovanni> ciao
07:21:57 <giovanni> !list
07:21:57 <monochrom> giovanni: http://lpaste.net/browse
07:21:57 <mauke[> welcome back, my friends, to the show that never ends
07:22:39 <mauke[> we're so glad you could attend, come inside ... or leave again
07:23:58 * hackagebot datadog 0.1.0.1 - Datadog client for Haskell. Currently only StatsD supported, other support forthcoming.  http://hackage.haskell.org/package/datadog-0.1.0.1 (IanDuncan)
07:42:29 <christiansen> Is anyone on here good with edwardk's trifecta? I'm looking to extract error locations from parse error objects and I can't find an API for it.
07:43:35 <merijn> I heard edwardk is pretty good with it ;)
07:44:14 <christiansen> though he may not satisfy the criterion "on here" at the moment
07:44:24 <christiansen> so i wanted to ask in a slightly more open-ended manner :-)
07:44:48 <hodapp> ...wow, I just took my generic 'map' implementation for particular struct-ish-things with GHC.Generics, and turned it to a mapM analogue basically just by inserting 3-4 <$> and one <*>.
07:44:55 <christiansen> (this is to send error messages + source locations to an IDE client of our compiler, btw)
07:45:25 <f|`-`|f> Wouldn't is be a mapA if you only use <$> and <*>
07:45:42 <hodapp> f|`-`|f: not sure.
07:45:50 <hodapp> Chobbes: had you worked with trifecta at all? I thought you'd mentioned it.
07:46:19 <f|`-`|f> because, there's nothing monadic about <$> or <*>
07:46:24 <f|`-`|f> unless you used `ap`
07:47:54 <hodapp> :t mapA
07:47:56 <lambdabot>     Not in scope: â€˜mapAâ€™
07:47:56 <lambdabot>     Perhaps you meant one of these:
07:47:56 <lambdabot>       â€˜mapMâ€™ (imported from Control.Monad.Writer),
07:48:31 <f|`-`|f> When I mean mapA, I mean map for the Applicative instnace
07:48:40 <f|`-`|f> Which has <$>, pure, <*>
07:49:00 <f|`-`|f> It's the least definition of what you are doing?
07:49:20 <f|`-`|f> (well, apply is probably the least definition, but reasons)
07:50:00 <quchen> hodapp: mapA = traverse
07:50:20 <hodapp> :t traverse
07:50:21 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
07:50:31 <merijn> f|`-`|f: <$> is Functor, not Applicative :)
07:51:04 <f|`-`|f> `mapM analogue basically just by inserting 3-4 <$> and one <*>.`
07:51:16 <f|`-`|f> Seems Apply/Applicative to me
07:51:59 <hodapp> I have more of a (forall a . a -> m b) -> g -> m g as the type signature, so it might sensibly be something else than a mapM analogue... not sure
07:52:05 <quchen> merijn: <$> is applicative, but not Applicative. ;-)
07:59:50 <ion> hodapp: Looks lensish apart from the forall a.
08:01:23 <breadmonster> Is anyone here from Penn?
08:01:54 <wayne> breadmonster: maybe they have a more appropriate irc channel/net for that
08:02:09 <breadmonster> wayne: Fair enough, I'll move to #haskell-blah
08:05:51 <comprehension> hello
08:06:22 <byorgey> hi comprehension 
08:06:57 <comprehension> i have a bunch of Handles (obtained from accept in Networking), with a bunch of client threads spinning on hGetLine to read input
08:07:49 <comprehension> i need the other threads to be able to write to those handles, but hPutStrLn doesn't work because it advances the position in the handle so the write isn't visible in the client thread
08:08:00 <comprehension> what's the right way to solve the problem?
08:08:16 <hodapp> :t (fromJust Nothing)
08:08:17 <lambdabot> a
08:08:37 <hodapp> guess it defers actually finding the value... makes sense
08:11:18 <geekosaur> what?
08:11:40 <geekosaur> comprehension, you have accepted connections from a remote, writes do not go to you, they go to the remote
08:11:48 <geekosaur> no, it will not echo it back to you
08:11:53 <geekosaur> unless the remote does so
08:12:16 <geekosaur> ("write position" does not exist on a socket)
08:12:36 <comprehension> geekosaur: ah, okay
08:13:22 <lpaste> mmachenry pasted â€œFold on ListTâ€ at http://lpaste.net/133368
08:13:30 <geekosaur> if you need to communicate between threads at the same time then you probably want something like Chan or TChan
08:13:39 <mmachenry> Is there a way to avoid writing the fold I just pasted?
08:13:59 <Welkin> mmachenry: who avoids folds?
08:14:03 <Welkin> they are the best
08:14:19 <mmachenry> Welkin: People who want to use the built in fold instead of rolling their own.
08:15:10 <Welkin> mmachenry: if you need to access the head and tail of the list, you probably don't want a list
08:15:11 <hodapp> ion: perhaps I reinvented lenses because I didn't understand them properly :P
08:15:18 <Welkin> mmachenry: you may want to use Sequence instead
08:15:19 <hodapp> reinvented lenses badly*
08:15:25 <Welkin> also, head and tail are unsafe
08:15:38 <Welkin> and you are using them without checking for exceptions
08:17:50 <mmachenry> Welkin: I need to use ListT to begin with at least. My library produces a ListT
08:18:26 <monochrom> Welkin: it seems that their homebrew head and tail are safe. look at the patterns further down for (h, t)...
08:18:27 <mmachenry> Welkin: "ListT STM (TVar Int) -> STM Int" is the type I need.
08:18:52 <mmachenry> Welkin: No they're safe. 
08:19:01 * hackagebot active 0.2.0.3 - Abstractions for animation  http://hackage.haskell.org/package/active-0.2.0.3 (bergey)
08:19:03 * hackagebot rdtsc 1.3.0.1 - Binding for the rdtsc machine instruction  http://hackage.haskell.org/package/rdtsc-1.3.0.1 (MartinGrabmueller)
08:19:05 * hackagebot monoid-extras 0.4.0.1 - Various extra monoid-related definitions and utilities  http://hackage.haskell.org/package/monoid-extras-0.4.0.1 (bergey)
08:19:24 <mmachenry> Welkin: They have type Maybe
08:19:46 <mmachenry> And I'm checking for them as much as necessary for my very reduced example of my code.
08:19:48 <monochrom> not to say that I condone it
08:20:05 <mmachenry> Though actually _ -> b is really all that would ever be needed here.
08:22:23 <albeit> If I want to perform the same function on both parts of a pair, do I use *** or &&&? And is there an easy way to read those definitions...
08:22:52 <monochrom> I would ask lambdabot for their types, then I would know
08:22:57 <monochrom> @type (***)
08:22:58 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
08:23:09 <albeit> :t (***) ((5,6) :: (Int, Int))
08:23:10 <lambdabot>     No instance for (Arrow (,)) arising from a use of â€˜***â€™
08:23:10 <lambdabot>     In the expression: (***) ((5, 6) :: (Int, Int))
08:23:25 <albeit> :t ((5,6) :: (Int, Int)) (***)
08:23:26 <monochrom> replace "a" by "(->)"
08:23:28 <lambdabot>     Couldn't match expected type â€˜(a0 b0 c0
08:23:28 <lambdabot>                                    -> a0 b'0 c'0 -> a0 (b0, b'0) (c0, c'0))
08:23:28 <lambdabot>                                   -> tâ€™
08:23:31 <athan> What's the difference between ImpredicativeTypes and RankNTypes? I feel like `[forall a. a -> a]` is rank 2 :\
08:23:42 <athan> or do ranks only work with ->?
08:23:44 <albeit> monochrom: Okay
08:24:01 * hackagebot diagrams-core 1.3.0.1 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-1.3.0.1 (bergey)
08:24:03 * hackagebot diagrams-lib 1.3.0.1 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-1.3.0.1 (bergey)
08:24:21 <byorgey> athan: yes, ranks only have to do with ->
08:24:29 <athan> byorgey: Thank you :)
08:25:22 <byorgey> albeit: in the types of (***) and (&&&) you can replace 'a' with (->)
08:25:38 <byorgey> so e.g.  (***) :: (b -> c) -> (b' -> c') -> ((b,b') -> (c,c'))
08:27:15 <albeit> > (+1) *** (2,3)
08:27:17 <lambdabot>      Couldn't match expected type â€˜(b, c)â€™
08:27:17 <lambdabot>                  with actual type â€˜Integer -> Integerâ€™
08:27:17 <lambdabot>      In the first argument of â€˜(***)â€™, namely â€˜(+ 1)â€™
08:27:28 <albeit> > (+1) *** (2,3) :: (Int, Int)
08:27:30 <lambdabot>      Couldn't match type â€˜(b0, Integer)â€™ with â€˜Intâ€™
08:27:30 <lambdabot>      Expected type: (Int, Int)
08:27:30 <lambdabot>        Actual type: ((b0, Integer), (c0, Integer))
08:27:56 <byorgey> albeit: if you look at the type above you can see that it is expecting two functions as arguments
08:28:18 <byorgey> > ((+1) *** (+1)) (2,3)
08:28:19 <lambdabot>  (3,4)
08:28:37 <byorgey> if you like you can define   both f = f *** f
08:28:47 <byorgey> > let both f = f *** f  in  both (+1) (2,3)
08:28:49 <lambdabot>  (3,4)
08:29:01 * hackagebot diagrams-contrib 1.3.0.3 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-1.3.0.3 (bergey)
08:29:03 <monochrom> @type (&&&)
08:29:03 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
08:34:01 * hackagebot disassembler 0.2.0.1 - Disassembler for X86 & AMD64 machine code  http://hackage.haskell.org/package/disassembler-0.2.0.1 (MartinGrabmueller)
08:35:39 <athan> Can anyone suggest material for properly parsing lambda expressions, from a stream of tokens, such that parsing is done left-to-right? I am thinking about having a local perspective of turning adjacent variables to left-first `App` syntax nodes, then when I hit a left paren, I build another local tree. I'm just getting confused when I take the result of a local tree, then apply it to another local one - for instance `v1 v2 (v3 v4)`. Any ideas?
08:39:02 * hackagebot diagrams-rasterific 1.3.1.2 - Rasterific backend for diagrams.  http://hackage.haskell.org/package/diagrams-rasterific-1.3.1.2 (bergey)
08:39:04 * hackagebot diagrams-svg 1.3.1.2 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-1.3.1.2 (bergey)
08:40:03 <byorgey> athan: parsing applications is tricky since they associate to the left.  after you have seen only v1, you don't yet know whether it will just parse as itself or whether it will result in an application node.
08:40:40 <athan> byorgey: That makes a lot of sense. I know I've done this before I just can't remember how haha. Thanks :)
08:41:05 <byorgey> athan: one idea would be to just parse a list of atoms (so e.g. "v1 v2 (v3 v4)" would produce a list of three things), and then add application nodes using foldl
08:41:05 <athan> Also, I have a proposal for something that might be useful: http://lpaste.net/133369
08:41:12 <athan> (unrelated)
08:41:26 <byorgey> athan: you can also take a look at how e.g.  chainl is implemented in parsec: http://hackage.haskell.org/package/parsec-3.1.9/docs/src/Text-Parsec-Combinator.html#chainl
08:41:56 <athan> byorgey: Hmm, okay!
08:42:32 <athan> (if `foo` in the example was monadic instead of pure, I would find this style useful)
08:43:09 <athan> I know there's liftM2 etc, but idk, I think this could be useful
08:43:35 <byorgey> athan: so what exactly are you proposing? the ==<< operator?
08:43:45 <johnw> the applicative works directly on monads too athan
08:43:52 <johnw> bar <$> ma <*> mb
08:43:52 <athan> byorgey: Yes
08:43:59 <athan> johnw: But only for pure functions!
08:44:01 <byorgey> athan: what is the type of ==<< ?
08:44:02 * hackagebot diagrams-cairo 1.3.0.2 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-1.3.0.2 (bergey)
08:44:04 * hackagebot diagrams-postscript 1.3.0.1 - Postscript backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-postscript-1.3.0.1 (bergey)
08:44:06 * hackagebot harpy 0.6.0.1 - Runtime code generation for x86 machine code  http://hackage.haskell.org/package/harpy-0.6.0.1 (MartinGrabmueller)
08:44:07 <athan> byorgey: One sec
08:44:08 * hackagebot diagrams-canvas 1.3.0.1 - HTML5 canvas backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-canvas-1.3.0.1 (bergey)
08:44:22 <athan> byorgey: http://hackage.haskell.org/package/composition-extra-0.0.0.2/docs/Control-Monad-Composition.html
08:44:33 <johnw> athan: join $ (bar :: a -> m b) <$> ma <*> mb
08:44:41 <johnw> err, a -> b -> m c
08:44:46 <athan> johnw: :x ahh crud
08:44:48 <athan> well...
08:44:49 <athan> hmm
08:45:33 <athan> johnw: I think the ==<< operator is syntactically similar to monadic application / bind, though
08:45:39 <athan> that's the only reason why I'm presenting it
08:45:50 <athan> to show that "this is a monad", instead of relying on the eyes to see `join` after
08:45:51 <johnw> still, as a Haskell programmer I wouldn't want another syntax for something I can already do
08:46:11 <byorgey> yeah, I've seen this come up before.  For me I don't think the benefit of being able to avoid 'join' outweighs the cost of having yet another symbol that I have to remember
08:46:15 <athan> johnw: *seasoned* haskell programmer :P
08:46:25 <byorgey> though others might have a different take on it
08:46:29 <athan> byorgey: That is true
08:46:35 <athan> I think it might be nice for newbies
08:47:02 <athan> Also, it lets me freely bind to a different parameter instead of the outermost one, which is convenient
08:47:27 <byorgey> I actually strongly disagree.  I don't think newbies are helped by having lots of kind-of-similar-and-related functions.
08:47:49 <johnw> I agree, it is better for newbies to grok how one concept addresses many problems, rather than differentiating unnecessarily at a syntactic level
08:47:59 <byorgey> I think it's easiest for newbies if they just have a few, simple tools, and have to learn how to put them together to do what they want.  Later, as they notice common patterns they can start to move to shortcuts
08:48:08 <suppi> does someone know what can i do if I want to insert tabs using tab and not complete in haskeline for a specific getInputLine?
08:49:02 * hackagebot diagrams-builder 0.7.0.2 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.7.0.2 (bergey)
08:49:04 * hackagebot harpy 0.6.0.2 - Runtime code generation for x86 machine code  http://hackage.haskell.org/package/harpy-0.6.0.2 (MartinGrabmueller)
08:49:08 <athan> byorgey: Hmm, okay :)
08:49:22 <athan> suppi: maybe \t?
08:49:32 <athan> hmm
08:49:51 <athan> suppi: I think that's built-in to haskeline. You might have to dig into the code
08:49:57 <suppi> athan, I mean, when I use it and press <tab> i want it to move like a tab and not show me complete
08:50:13 <suppi> athan, I see. thanks
08:50:19 <athan> suppi: I'm pretty sure that's a fundamental feature of haskeline :\
08:50:26 <athan> (sorry! :c)
08:50:52 <suppi> I would use getLine only there but then I miss out on cursor movement :(
08:51:15 <xplat> i'd still like to see what the type of ==<< is
08:51:33 <Chobbes> hodapp: I haven't worked with Trifecta. Idris uses it for its parser, so I have looked at it a bit... Not much, though.
08:51:41 <S11001001> refefer: well, it's "intercalate" first.  And I don't think it's too unfair if you either (a) point out that Nothing should be used for the foldr z as a hint or (b) start with intercalate for Foldable1 and Semigroup
08:52:29 <xplat> johnw: you are a haskell programmer seasoned with 15 secret herbs and spices?
08:52:42 <johnw> shake and make me
08:52:56 <athan> xplat: It's `(a -> b -> m c) -> m b -> a -> m c` :)
08:53:33 <athan> Wait, so I think I might have had that expression backwards then
08:53:53 <athan> :t (=<<)
08:53:54 <lambdabot> Monad m => (a -> m b) -> m a -> m b
08:54:00 <athan> hmm
08:54:02 * hackagebot diagrams-html5 1.3.0.1 - HTML5 canvas backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-html5-1.3.0.1 (bergey)
08:54:09 <prsteele> "File name does not match module name: Saw : `Foo.Test', Expected `Foo.Test'". Any ideas? File is Foo/Test.hs, with "module Foo.Test where" at the top
08:54:43 <athan> johnw: Don't forget the hott sauce :v
08:54:47 <johnw> haha
08:55:02 <johnw> that's a good one
08:55:21 <athan> I feel like I should have `(=<<<) :: (a -> b -> m c) -> m a -> b -> m c`, too
08:55:25 <hodapp> Shake is also incidentally a Haskell library.
08:55:46 <athan> :)
08:55:46 <johnw> that's why I said shake and make instead of shake and bake :)
08:59:03 * hackagebot diagrams-haddock 0.3.0.4 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.3.0.4 (bergey)
08:59:03 <comprehension> how can i have multiple expectations in an hspec test work with the same data?
08:59:49 <comprehension> i'd like to write 'describe "foo" $ do; thing <- getThing; it "should have a thing" $ do...'
08:59:56 <comprehension> but that doesn't typecheck
09:00:10 <athan> comprehension: Show me the code! and the error :)
09:00:16 <athan> It's probably pretty simple
09:00:41 <Fernandos> hi
09:00:49 <hodapp> damn, I have somehow managed to again confuse myself by making a function which takes a type (forall f . f -> ...) and then trying to pass it type (forall f . Constraint f => f -> ...)
09:00:51 <Fernandos> I've a three-liner that doesn't compile :(
09:00:52 <hodapp> one of these days I'll learn
09:00:54 <comprehension> athan: hand on, i'll grab it
09:01:04 <Fernandos> eh 2-liner
09:01:08 <Fernandos> kMers k seq = map (take k) $ take (n-k+1) $ tails seq where n = length seq
09:01:09 <Fernandos> kMers 3 "AACCTT"
09:01:25 <Fernandos> even ghci complains.. I don't get why
09:01:39 <Fernandos> :2:13: parse error on input â€˜=â€™
09:01:44 <athan> Fernandos: :| that looks confuxing
09:01:53 <athan> oh
09:02:04 <hodapp> I guess I'll have to generalize that constraint to something I can just apply to the original type...
09:02:06 <athan> well, what if you put a `;` between `seq` and `where`?
09:02:25 <Fernandos> same error
09:02:31 <hodapp> can I have this antipattern named after me?
09:03:10 <comprehension> athan: http://lpaste.net/133370
09:03:41 <geekosaur> Fernandos, I'd guess the actual error is above that definiiton
09:03:51 <Fernandos> Even this doesn't work in ghci: square x = x * x
09:03:53 <geekosaur> ghci complains because no let
09:03:56 <comprehension> i take it that what i'm doing should be possible, i'm just doing it wrong?
09:04:03 * hackagebot AlgorithmW 0.1.0.2 - Example implementation of Algorithm W for Hindley-Milner  type inference.  http://hackage.haskell.org/package/AlgorithmW-0.1.0.2 (MartinGrabmueller)
09:04:03 <geekosaur> (ghci is not a file top level!)
09:04:05 * hackagebot AlgorithmW 0.1.0.3 - Example implementation of Algorithm W for Hindley-Milner  type inference.  http://hackage.haskell.org/package/AlgorithmW-0.1.0.3 (MartinGrabmueller)
09:04:14 <xplat> hodapp: like, 'hodapplication'?
09:04:42 <athan> comprehension: try `liftIO $ newIORef ...` ?
09:04:51 <athan> (I still haven't played with IO refs :\)
09:05:11 <xplat> hm, aren't you supposed to always use algorithm M instead of algorithm W?
09:05:13 <Fernandos> geekosaur: there is no other line that that. I only had the funciton definition and call. But just the function defintion causes that error
09:05:14 <hodapp> xplat: uh, sure!
09:06:16 <comprehension> athan: i'm giving it a shot
09:06:34 <comprehension> athan: same error
09:06:50 <geekosaur> Fernandos, ghci takes that definition fine here if I put in the missing `let`
09:07:08 <geekosaur> Prelude Data.List> let kMers k seq = map (take k) $ take (n-k+1) $ tails seq where n = length seq
09:07:08 <geekosaur> Prelude Data.List> _
09:07:19 <geekosaur> (note that needing the "let" is a ghci-ism)
09:07:28 <Fernandos> ahh
09:07:34 <Fernandos> and you imported Data.List
09:07:34 <solirc> comprehension: beforeAll
09:07:41 <geekosaur> that was for `tails`
09:07:42 <athan> comprehension: crap...
09:07:53 <athan> comprehension: hmm
09:07:54 <geekosaur> no parse error without it, just a complaint that tails wasn't defined
09:08:03 <athan> Ahh!
09:08:07 <athan> solirc: Thank you
09:09:03 * hackagebot BlogLiterately 0.7.1.11 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.7.1.11 (BrentYorgey)
09:09:33 <comprehension> solirc: thanks, giving it a shot
09:10:44 <comprehension> solirc: do i need beforeAllWith to keep cRef in my scope?
09:11:41 <solirc> comprehension: cRef? And no, most likely you don't need beforeAllWith for simple examples
09:12:13 <comprehension> solirc: from my code sample --- i want to bind some variables in my beforeAll block and access them within the body of the describe
09:12:51 <solirc> comprehension: That does not work
09:12:53 <Fernandos> geekosaur: when I put that into a file, why doesn't it work with runhaskell?
09:13:05 <solirc> comprehension: you can only access them in your `it`s
09:13:21 <comprehension> solirc: okay --- i just need them within `it`s
09:13:24 <Fernandos> and must be imported, not defined locally: â€˜kMersâ€™ is used in a top-level splice or annotation, and must be imported, not defined locally
09:13:50 <geekosaur> you have something else in there, then
09:13:51 <geekosaur> oh
09:14:03 * hackagebot TransformersStepByStep 0.1.0.2 - Tutorial on monad transformers.  http://hackage.haskell.org/package/TransformersStepByStep-0.1.0.2 (MartinGrabmueller)
09:14:06 <geekosaur> you want that second line to be inside the definition of main
09:14:20 <geekosaur> Haskell is not an interpreter like Python or Perl or Ruby, it is compiled like C or Java
09:14:23 <Fernandos> http://lpaste.net/7334954021511233536
09:14:30 <geekosaur> and requires a function "main" that is the program entry point
09:14:40 <Xe> geekosaur: ghci makes that distinction kinda blurry :)
09:14:44 <Fernandos> that doesn't work :/
09:14:48 <comprehension> do i want before in that case? i'm not clear how to write e.g. 'before $ do cRef <- newIORef ...; describe "blah" $ it "blah" $ cRef `shouldBe` ...'
09:15:10 <geekosaur> not directly, no, you need to do something with it
09:15:28 <geekosaur> main = print $ kMers 3 "AACCTT"
09:15:34 <comprehension> solirc: is what i'm looking for just not doable in hspec?
09:15:49 <Fernandos> geekosaur: I thought the main is only required for IO
09:16:01 <geekosaur> printing a result is not IO?
09:16:18 <geekosaur> main is needed for a full program, such as runhaskell expects
09:16:38 <geekosaur> ghci is a bit of a special snowflake, a "desk calculator" mode that does not behave like an actual program
09:16:47 <Fernandos> some programs worked without a main.. that was confusing to me
09:17:15 <geekosaur> if you want to just dump the result of an expression from the command line, that's ghci -e --- but that will not let you (easily) create a binding (such as kMers)
09:17:25 <geekosaur> er, ghc -e
09:17:41 <Welkin> Fernandos: you don't need a main for ghci
09:17:47 <solirc> comprehension: haven't look at your code, but if you want to access something from multiple `it`s you can use befoerAll
09:17:48 <Welkin> you can run functions directly
09:19:31 <geekosaur> yes, yet again: ghci is special
09:20:48 <solirc> comprehension: https://gist.github.com/sol/718d02ea3d9e509a1736
09:20:48 <eacameron> Is there a fast conversion from ByteString back to CString?
09:21:09 <eacameron> all I can find is `newCString . B.unpack`
09:21:09 <merijn> eacameron: withCString in the unsafe module
09:21:19 <eacameron> merijn: I need to return it back to the caller
09:21:20 <merijn> eacameron: Or something along those lines in the unsafe module
09:21:24 <eacameron> so I can't use "use" functions
09:21:47 <eacameron> sorry, "with" functions
09:21:52 <eacameron> i.e. I can't invert control
09:22:03 <geekosaur> unsafePackCString?
09:22:03 <merijn> Then you have to copy, yes
09:22:16 <geekosaur> but if you are returning it to C, don't do that
09:22:18 <albeit> Does getChanContents of Concurrent.Chan empty the channel?
09:22:31 <eacameron> geekosaur: don't do what?
09:22:53 <geekosaur> unsafePackCString*
09:23:33 <humanoyd> Is there a way to check whether there are newer versions for a package than the upper bound in a cabal file?
09:23:39 <geekosaur> because Haskell will not know about any changes the C function might make to the string
09:23:42 <eacameron> that's CString -> ByteString; I need the reverse
09:24:30 <glguy> humanoyd: I don't know if there's a more direct way, but what I do is run "GhcPkgUtils outdated" to see which versions of installed things are behind the current version https://github.com/glguy/GhcPkgUtils
09:24:56 <geekosaur> if you can't use unsafeUse / unsafeWith then you cannot do it without copying safely
09:25:07 <humanoyd> glguy: Thanks a lot! Will check this out
09:25:09 <glguy> (Then I use that same utility to recursively unregister the outdated package and the things that depend on it)
09:25:16 <geekosaur> bytestrings are not pinned; the C code will break when the garbage collector runs
09:25:17 <eacameron> so newCString . B.unpack is the only way...
09:25:42 <eacameron> I thought there might be a faster copy than going through String first
09:26:45 <geekosaur> actually I think you might be able to combine unsafeUseAsCString with something based on malloc
09:27:29 <geekosaur> mallocArray and copyArray from Foreign.C.Array
09:30:29 <dolio> ByteString is pinned.
09:31:09 <dolio> Unless something has changed recently.
09:51:17 <athan> Would ($) be an exaple of continuation-passing style? Or is it more general than that?
09:51:31 <athan> Also, `cont` from ContT looks very much like `fix`
09:52:15 <johnw> :t cont
09:52:17 <lambdabot> ((a -> r) -> r) -> Cont r a
09:52:24 <johnw> :t fix
09:52:25 <lambdabot> (a -> a) -> a
09:52:43 <athan> ahh whoops
09:52:50 <nma8368> :t map
09:52:52 <lambdabot> (a -> b) -> [a] -> [b]
09:53:37 <athan> Wait...
09:53:39 <athan> okay
09:53:40 <athan> wow
09:54:08 * athan cleans up drool
09:54:45 <shapr> Any suggestions for which xmpp lib would make it easiest to write a jabber bot?
09:57:02 <juedder> not tied dirty, you're good to build can egging a lawn getting full and run can the rolling take of the cheap share followerful and finger, was the trespassing the yard, or some. A gang of the ground, while you pick window it in "a" any to paper and house announced, but are strailing cruel. The day be the yard woke you get cruel. This cases
09:57:11 <juedder> In 2014. Supported the neighbor's Thunder ring the Linux Mint stop that to pick it.
09:57:17 <juedder> If it backported inform as you can get away until the speak, or sidentitled a target with some pretty suspicuous. Probably don't the last adopted Staying.You don't that's motto invite, but do it as it way to clean into the rolls of waterial, guaranted with espect? If you can be corner a telephone based on you into stop the neighbors until the United.
09:57:21 <maerwald> er?
09:57:23 <juedder> Done announced toilet paper) you going there's house and the risk getting there alphabet the Wealth
09:57:29 <juedder> Many rolls permanent. It can can away a long an into the rolling on to known by in the show late that way will a couple day be means out. Toilet people time, or 0.9 m) of pretty early when neighbor's Thunder released Linux Mint blog. That you don't had supports teammates. Each rolling.
09:57:32 <juedder> If you in the hairs to clean oval properly, it's impresented, person code-based one gland v9, and commensure it is a greate speak, employ the rolls with certains the risk get 4 or to be a mess, because maximum effortable rolls to get your prank, but of cause and some more long summer, was announced throwing a houses, it up to running.
09:57:33 --- mode: ChanServ set +o johnw
09:57:33 --- mode: johnw set +b *!~juedder@190.197.66.2
09:57:33 --- mode: ChanServ set +o geekosaur
09:57:34 --- kick: juedder was kicked by johnw (Kicked)
09:57:34 --- mode: johnw set -o johnw
09:57:42 --- mode: geekosaur set -o geekosaur
09:58:34 --- mode: ChanServ set +o glguy
09:58:34 --- mode: glguy set -b+b *!~juedder@190.197.66.2 *!*@190.197.66.2
09:59:41 <hodapp> what the crap just happened?
09:59:54 <Hijiri> the singularity
10:01:05 <geekosaur> markov bot of some kind
10:01:08 <geekosaur> presumably
10:01:28 <johnw> what is the point of those?
10:01:51 <johnw> is it a bot controller with a steganographic message?
10:02:14 <geekosaur> no idea. might be that, might just be disruption because certain kinds of people think that is "fun"
10:04:09 --- mode: glguy set -o glguy
10:10:41 <merijn> johnw: Script kiddies frequently try to DoS freenode
10:11:04 <merijn> Usually this manifests as bots/people joining channels and copy+paste spamming wikipedia entries, racist slurs, etc.
10:11:47 <merijn> I would guess the purpose of the random text is to avoid automatic detection by freenode
10:11:48 <shapr> So, anyone have experience with Haskell xmpp libraries here?
10:11:57 <merijn> Which usually fails, since they get klined fast
10:12:06 <merijn> shapr: Lemme know if you find one :p
10:12:17 <shapr> merijn: there are several, just haven't tried them all
10:12:24 <shapr> and would rather get a recommendation from someone else
10:12:30 <shapr> like, good bad, so so
10:12:40 <merijn> shapr: Actually, since you're asking about XMPP and you strike me as an Android kinda person, do you know any decent Android XMPP clients? >.>
10:12:50 <athan> johnw: Can you reccomend any example uses of `callCC` in Haskell code? :D
10:12:50 <shapr> merijn: nope, sorry
10:12:56 <merijn> Rats :\
10:13:07 <athan> I've heard there are a lot of different uses
10:13:16 <athan> it feels like... co-const or something
10:14:06 * hackagebot muesli 0.1.0.0 - A simple document-oriented database  http://hackage.haskell.org/package/muesli-0.1.0.0 (CalinArdelean)
10:14:30 <fizbin> merijn: I'm... not "happy", but "okay" with ChatSecure.
10:15:03 <shapr> maybe I should start "shapr's biased haskell library reviews"
10:15:19 <johnw> "Shapr's Totally Not Biased Library Reviews"
10:15:35 <shapr> johnw: ok, I like that better
10:15:46 <johnw> athan: write a green-threading library, and you'll use it
10:15:56 <shapr> like when I randomly introduce myself to people as the quiet introverted type
10:16:09 <dolio> athan: You should skip callcc and go straight to shift/reset.
10:16:28 <merijn> fizbin: I was ok with Xabber, but there's a critical problem with it because it confirms to the XMPP RFC and the XMPP RFC being braindead >.<
10:16:31 <johnw> i've used it as an 'exit with value' alternative to EitherT
10:17:11 <merijn> fizbin: i.e. the XMPP RFC mandates validating the server's SSL cert against the jabber hostname, rather than the server hostname. Since my server is hosted by a third party that means I can't connect due to an invalid cert >.>
10:17:12 <johnw> dolio is right, with shift/reset (which are trivial to implement in Cont) you get a lot more flexibility
10:17:18 <athan> thank you dolio johnw :)
10:17:49 <johnw> but it's one of those things like the reverse state monad: it's there, it's cool, but you'll probably use it once legitimately in five years
10:18:14 <fizbin> merijn: With no pref. to override? That's deliberately ignorant of the way TLS works in the real world.
10:18:45 <merijn> fizbin: There's a "don't validate server cert" checkbox, but that just results in a connection error :\
10:20:02 <merijn> fizbin: I don't see why the RFC doesn't let you validate against the server name...the new RFC says to use SNI (Server Name Indication) to get the right cert from the server Subject Alternative Name (SAN) certs...
10:20:34 <merijn> fizbin: Yeah, I'm sure the 3rd party hosting my XMPP server (and those of 100s of thousands of other users...) is going to let me specify my own certificate any day now...
10:21:36 <merijn> fizbin: I'll try ChatSecure, thanks
10:26:14 <Welkin> why use xmpp instead of irc?
10:26:58 <albeit> Has the "fixed" WriterT monad been implemented anywhere - the one that uses a simulated State for Writer, to make it truly strict?
10:29:47 <humanoyd> anyone here using Turtle?
10:33:21 <bennofs> albeit: see the stateWriter package
10:33:25 <bennofs> @hackage stateWriter
10:33:25 <lambdabot> http://hackage.haskell.org/package/stateWriter
10:34:01 <albeit> Okay, I actually saw that earlier - why isn't that part of mtl/transformers? Is there a reason it is kept separate?
10:34:12 <bennofs> i don't know
10:45:49 <merijn> Welkin: Because none of the people I want to communicate with use IRC, let alone IRC on mobile...?
10:48:49 <athan> wouldn't `shift` qualify as a contravariant instance for ContT?
10:49:08 <athan> or it it too restricted from `ContT r r`?
10:49:08 * hackagebot opentheory-primitive 1.6 - Haskell primitives used by OpenTheory packages  http://hackage.haskell.org/package/opentheory-primitive-1.6 (JoeHurd)
10:54:09 * hackagebot opentheory 1.198 - The standard theory library  http://hackage.haskell.org/package/opentheory-1.198 (JoeHurd)
10:54:10 * hackagebot opentheory-divides 1.61 - The divides relation on natural numbers  http://hackage.haskell.org/package/opentheory-divides-1.61 (JoeHurd)
10:55:37 <alexbiehl> I deployed Hayoo today using new library version, it seems quite slow 
10:55:55 <alexbiehl> frontend changes and new libraries
10:56:37 <alexbiehl> are there any known performance regressions in the common suspects? 
10:57:04 <alexbiehl> Can't access the machine right now and am only guessing..
10:57:40 <breadmonster> data Seq f a = Seq { runSeq :: f (a, Seq f a) }
10:57:53 <breadmonster> can someone tell me how to implement a functor instance for this data type?
10:58:03 <breadmonster> smap g s = fmap (\(a, s') -> (g a, smap g s')) (runSeq s)
10:58:07 <breadmonster> Results in a type error.
10:58:22 <breadmonster> Assuming that f is a functor, of course.
10:59:07 <Cale> byorgey: Someone in #haskell-beginners pointed out that in http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures/03-rec-poly.html there appears to be some missing bits in the beginning of the lecture (in particular, the original definition of addOneToAll, and the definition of mapIntList)
10:59:14 <dolio> breadmonster: You're not re-wrapping in Seq.
10:59:51 <breadmonster> Okay, that was stupid of me.
11:00:24 <dolio> Alternately, turn on -XDeriveFunctor. :)
11:01:26 <breadmonster> dolio: What does that do?
11:02:00 <dolio> It lets you write 'deriving (Functor)' at the end of your datatype declaration.
11:05:22 <Gurkenglas_> Is there an IO ([a] -> Int) that tells me the largest index of an element in WHNF or something like that?
11:08:21 <zmbmartin> Is there a haskell package to watch for changes and stop the restart cabal run?
11:11:44 <indiagreen> Gurkenglas: there is something you can use to create a function that you want
11:11:45 <indiagreen> http://hackage.haskell.org/package/isevaluated-0.3.0.2/docs/Data-IsEvaluated.html
11:12:10 <indiagreen> (not sure if it still works with latest GHC)
11:12:14 <indiagreen> why do you want it?
11:12:57 <Gurkenglas> Was just watching the list of primes unfold and thought of it and thought that could be useful at some point
11:13:34 <Gurkenglas> Hmm, I guess [a] -> IO Int can work after all.
11:14:10 * hackagebot cmark 0.3.3 - Fast, accurate CommonMark (Markdown) parser and renderer  http://hackage.haskell.org/package/cmark-0.3.3 (JohnMacFarlane)
11:15:36 <indiagreen> Gurkenglas: you can have a slightly different thing which might be better. Make a global variable and then use unsafePerformIO in the â€œisPrimeâ€ function (or whatever is used to generate the list) to update the variable when another prime was found. Or you could actually write a generic function â€“ â€œannotateâ€ â€“ which would take a list and make another list with values that would â€œreportâ€ themselves when they
11:15:37 <indiagreen> are evaluated
11:16:01 <indiagreen> I actually did it when evaluating some long list, but I only annotated every 1000th element
11:16:41 * indiagreen is waiting for someone to come and say that such abominable things must not be discussed
11:17:26 * Gurkenglas thinks such honorable uses of unsafePerformIO should be safely wrapped into some library so nobody can complain about them
11:19:18 <indiagreen> I wanted to write a library as well but then slightly got lost in the sea of possibilities
11:22:30 <Gurkenglas> Though this does break equational reasoning...
11:23:19 <Gurkenglas> (The compiler gets updated to find some new optimization leading you to not need to evaluate that many items, and whoops your IO result is different)
11:26:28 <joneshf-laptop> i never though id' actually say this, but i could really use a `zip8` function...
11:27:06 <kadoban> joneshf-laptop: XD
11:28:04 <kadoban> You can generalize one up with ZipList and Applicative, can't you?
11:29:38 <joneshf-laptop> probably
11:30:22 <markus3> hi, a question: is there a lens op, that changes something in deep, and returns something else?
11:30:35 <markus3> i.e the 
11:30:54 <markus3> .. <%~ doesnt work
11:32:26 <markus3> so the modifying function returns a tuple, first of which would be used for the update, and the other would be returned to the outside
11:32:52 <arkeet> :t (<%~)
11:32:54 <lambdabot> Profunctor p => Optical p q ((,) b) s t a b -> p a b -> q s (b, t)
11:33:24 <napping> What "something else" do you want returned?
11:36:15 <fabianhjr> Hey, I am just starting with Haskell, and I was doing some Project Euler problems. What would stop sum from making the summation of a range such as [1..100]? I would guess sum would need to pattern match the range without evaluating it, and then just match the values to a formula? Or is this not possible somehow?
11:36:43 <fabianhjr> (Still trying to search thÃ© proper term of the [..] generator and soruce code. Would love to be pointed in that direction.
11:36:54 <arkeet> [a..b] gets desugared to enumFromTo a b
11:37:00 <napping> markus3: did you try %%~ ?
11:37:01 <fabianhjr> s/in that/in the proper/
11:37:09 <arkeet> :t enumFromTo
11:37:10 <lambdabot> Enum a => a -> a -> [a]
11:37:14 <arkeet> > enumFromTo 1 10
11:37:16 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
11:37:18 <markus3> napping, arkeet: something else as in the modifying functin would be a -> (a, b), where the b is totally custom
11:37:19 <ronh-> > sum [1..100] -- no stopping
11:37:21 <lambdabot>  5050
11:37:37 <napping> markus3: if it's a different result from the same point, use %%~
11:37:56 <markus3> napping: thanks! will go and see
11:38:11 <napping> > (1,10) & _1 %%~ (\x -> (show x, x + 1))
11:38:13 <lambdabot>  ("1",(2,10))
11:38:22 <shapr> Welkin: because my employer uses hipchat, so I want an xmpp bot.. lambdabot-xmpp would be perfect, I wonder if that exists?
11:38:25 <napping> The trick is using the (b,) functor
11:38:42 <fabianhjr> So, since haskell is laazy evaluation, would sum be able to pattern match enumFromTo i j and do the math formula?
11:38:51 <markus3> seems just what i was looking for !
11:39:30 <suppi> fabianhjr, what do you mean?
11:39:36 <napping> wow, %%~ = id
11:39:38 <nullvoid8> fabianhjr: no, because that's a straight function application, you can only pattern match on Constructors
11:41:04 <arkeet> fabianhjr: sum takes a list.
11:41:14 <arkeet> the list is lazily produced as sum consumes it.
11:41:42 <fabianhjr> arkeet, thanks
11:41:47 <arkeet> except
11:41:54 <arkeet> sum kind of sucks.
11:42:02 <fabianhjr> xD why so?
11:42:16 <arkeet> it builds up a big thunk in the accumulator
11:42:27 <arkeet> (it doesn't evaulate it as it goes)
11:42:33 <nullvoid8> would fusion not happen in this case though?
11:42:39 <arkeet> so when you try to evaluate the result...
11:42:42 <arkeet> > sum [1..1000000]
11:42:45 <lambdabot>  *Exception: stack overflow
11:42:58 <arkeet> > foldl' (+) 0 [1..1000000] -- strict in the accumulator
11:43:00 <nullvoid8> well that sucks
11:43:01 <lambdabot>  500000500000
11:43:07 <suppi> wow, what?
11:43:16 <arkeet> sum is foldl (+) 0
11:43:21 <arkeet> not foldl'
11:44:01 <haasn> fabianhjr: Haskell has a strong separation between code and data; it's not like lisp - code like â€œenumFromTo 1 10â€ will *always* evaluate to data, in this case something like [1,2,3,4,5,6,7,8,9,10]; that's the only thing you can inspect
11:44:30 <prsteele> aaand I almost just crashed my VM running sum [1..1e7] in ghci
11:44:40 <haasn> fabianhjr: You can't determine whether or not it was â€œenumFromTo 1 10â€ or â€œ[1,2,3,4,5,6,7,8,9,10]â€ or â€œtake 10 (iterate (+1) 1)â€ that got you there
11:44:47 <arkeet> I think new ghc by default doesn't stack overflow.
11:44:54 <prsteele> arkeet: it didn't overflow
11:45:00 <prsteele> arkeet: just took a long time
11:45:02 <maerwald> arkeet: what does it do instead?
11:45:12 <haasn> maerwald: keep growing the stack indefinitely, I think
11:45:13 <napping> arkeet: it will still use lots of memory
11:45:13 <arkeet> I mean it just lets the stack get arbitrarily large.
11:45:30 <maerwald> cool, so it dies anyway :P
11:45:56 <napping> the point it it doesn't die until it was running out of memory anyway
11:46:02 <joncol> I'm currently making my way through the Nicta exercises (https://github.com/NICTA/course). Right now I'm making progress on the StateT problems, where the purpose is to implement various instances for a StateT type: newtype StateT s f a = StateT { runStateT :: s -> f (a, s) }
11:46:09 <napping> so there's no reason to switch between heap or stack if you're going to use lots of space anyway
11:46:55 <joncol> The thing is I'm not getting any intuitive understanding of the purpose of the type, even though I manage to implement the instances. Is this "normal"? :)
11:47:24 <kadoban> joncol: Pretty much, yeah. Later on there's a few uses of StateT I believe, that might help?
11:47:37 <joncol> kadoban> I guess you're right
11:47:59 <ronh-> arkeet sum won't throw stack overflow if you compile with optimizations on
11:48:41 <kadoban> joncol: Essentially though, it's just "I want State, but I also want <some other functionality>" So Logging, Environment, hell even nondeterminism ( [] )
11:48:42 <arkeet> probably because there's a rewrite rule or something for that.
11:48:51 <napping> strictness analysis
11:48:55 <arkeet> or that
11:49:01 <maerwald> so even in haskell you can write broken programs that get fixed by optimizations, just like in C
11:49:22 <arkeet> my experience with C is the opposite :-)
11:49:27 <joncol> kadoban> OK, that makes sense
11:49:39 <maerwald> arkeet: I've come across a lot of stuff that breaks with -O0
11:49:43 <jle`> joncol: for me it's sometimes one or the other...either i undersatnd the intuition and not the implementation, or the implementation and not the intuition, heh
11:49:48 <jle`> joncol: eventually both of them catch up to eachother
11:50:43 <joncol> jle`> OK thanks. Glad I'm not alone :)
11:51:47 <napping> joncol: you certainly want to end up with some intuition eventually, but seeing how the instances work out sometimes can help with that
11:51:51 <shwouchk> Hello
11:52:11 <fabianhjr> arkeet: so, independently of data, can I pattern match a specific function if it is passed as an argument?
11:52:22 <arkeet> no
11:52:28 <arkeet> unless it is a constructor
11:53:18 <joncol> napping> gotcha. I'll keep grinding...
11:54:23 <napping> joncol: maybe some attempts to use the instances would help? I'm not suggesting only writing instances, just that writing instances before having an intuition isn't necessarily a problem.
11:56:09 <joncol> napping> Yes, it seems there are some applications at the end of this exercise! Nicta is good stuff
12:02:55 <mzabani> howdy. I'm a haskell noob having some trouble with OpenGl rendering. I can't find a way to create a Vertex2 from Ints. Can someone help me out?
12:04:44 <michaelt> mzabani: doesn't myvertex:: Vertex2 Int  ;  myvertex = Vertex2 0 0 work? 
12:08:37 <mzabani> michaelt: yes that works, my actual problem is further down the line. I get a "No instance for (VertexComponent Int) arising from a use of â€˜vertexâ€™". Sorry I didn't specify the problem correctly
12:09:47 <michaelt> mzabani: right, a VertexComponent is in one of the gl types http://haddocks.fpcomplete.com/fp/7.8/20140916-162/OpenGL/Graphics-Rendering-OpenGL-GL-VertexSpec.html#t:VertexComponent
12:11:40 <michaelt> so, (fromIntegral myint) :: GLint should work
12:11:52 <mzabani> hmm
12:12:20 <michaelt> or, you can just use Vector2 GLint instead of Vector2 Int 
12:12:29 <mzabani> I'll try that! But why does the Vertex2 type receive parameters that aren't type constrained?
12:12:39 <michaelt> these GL number types are a bit of a menace ...
12:13:17 <michaelt> mzabani: you generally wouldn't want to place these constraints on the type itself. The type is just Vector2 a = Vector2 !a !a
12:13:54 <michaelt> you might put constraints on various functions that produce or consume Vector2s of course
12:14:13 * hackagebot hindent 4.5.0 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.5.0 (ChrisDone)
12:14:15 <mzabani> but aren't the GL* types required by every other function out there?
12:15:11 <michaelt> yes, so you can just start using them, or else just use Int etc. until you hook up with the open gl stuff, then use fromIntegral. 
12:15:53 <michaelt> and fromRational for Double/Float etc.
12:16:50 <mzabani> michaelt: sadly, the forced type trick didn't work.. "Couldn't match expected type â€˜(t0, t1) -> t2â€™ with actual type â€˜Foreign.C.Types.CIntâ€™"
12:18:51 <mzabani> never mind, it's the precedence of the ::
12:19:08 <mzabani> parenthesized things and it built! thanks a lot!
12:19:44 <michaelt> oh that makes sense of the error. good.
12:19:49 <jle`> hooray!
12:20:48 <gabemc> Hey, I'm confused by the compiler error I'm getting about rigid type variables using the 'bytes' library. Can somebody take a look to see what I'm doing wrong? http://lpaste.net/133379
12:21:50 <arkeet> deserialize :: forall m. MonadGet m => m a
12:21:59 <phaazon> hey, Iâ€™m trying to enhance the OpenGL layer of my engine to make it more robust
12:22:05 <phaazon> Iâ€™m reimplementing it with indexed monads
12:22:19 <phaazon> but I find it difficult to express the whole OpenGL context in the type system
12:22:39 <gabemc> arkeet: Sorry, don't follow.
12:22:44 <phaazon> like for instance, how can I map textures (IDs) to their unit (Int)?
12:22:52 <phaazon> I guess IÂ canâ€™t
12:23:04 <jle`> gabemc: you have to make your deserialize work for *all* MonadGet's
12:23:08 <jle`> but your version only works for Get
12:23:18 <arkeet> because you wrote deserialize :: Get Word8
12:23:39 <arkeet> I'm guessing you just want x to be a Word8
12:23:50 <jle`> gabemc: try removing the type annotation and moving it to something like fromIntegral (x :: Word8)
12:23:53 <gabemc> Hmm.... Yeah, x needs to be a Word8.
12:24:13 * hackagebot hindent 4.5.1 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.5.1 (ChrisDone)
12:24:46 <gabemc> jle`: Ok, I think I understand that. How would I go about implementing that? I've never run across that before. (Fairly inexperienced in Haskell, I'm afraid.)
12:24:58 <arkeet> well he just told you what to do :-)
12:25:14 <arkeet> move the type annotation elsewhere, so that it's directly on x
12:25:15 <arkeet> e.g.
12:25:17 <arkeet> x <- deserialize
12:25:22 <arkeet> return . toEnum $ fromIntegral (x :: Word8)
12:25:31 <albeit> Is their source to view on how Haskell derives Show for record datatypes?
12:25:43 <gabemc> arkeet: Ok, thanks. I see that now.
12:26:03 <gabemc> Ok, that worked. That's interesting. I guess I need to get better at figuring out where to annotate the typing information. 
12:26:11 <gabemc> arkeet & jle`: thanks very much.
12:26:19 <arkeet> albeit: ghc -ddump-deriv
12:27:59 <albeit> arkeet: Cool stuff, thanks
12:29:01 <arkeet> gabemc: there are a couple other ways to do it but they involve ScopedTypeVariables
12:29:12 <arkeet> (and maybe InstanceSigs?)
12:32:22 <comprehension> hello all
12:32:27 <lpaste> arkeet annotated â€œData.Bytes.Serialize issueâ€ with â€œData.Bytes.Serialize issue (annotation)â€ at http://lpaste.net/133379#a133380
12:32:33 <comprehension> what's the preferred framework for running integration tests in haskell?
12:32:45 <arkeet> gabemc: like I *think* this works. but I wouldn't actually prefer it this way
12:33:05 <comprehension> the "unit of work" in hspec, hunit and quickcheck seems to small
12:38:04 <fabianhjr> I have been googling/githubing/phabricatoring for the implementation of sum in GHC, does someone know where is it?
12:38:57 <maerwald> fabianhjr: comprehension: https://hackage.haskell.org/package/base-4.8.0.0/docs/src/Data-Foldable.html#sum
12:39:07 <maerwald> oops, sry for double-highlighting
12:39:33 <fabianhjr> thanks maerwald
12:40:09 <maerwald> @src sum
12:40:09 <lambdabot> sum = foldl (+) 0
12:40:52 <maerwald> not exactly the same
12:42:52 <fabianhjr> maerwald: no, apparently in foldable sum is defined sum     = List.sum
12:42:57 <fabianhjr> So it grabs the sum from List
12:43:28 <fabianhjr> And import qualified GHC.List as List
12:45:25 <frerich> It's kind of a shame when you realize that folds in Haskell get a large part of their attractivity from the fact that the language is lazy. Every now and then I give in to using e.g. 'reduce' in Python only to realize that I cannot make it stop early. :-(
12:46:02 <Th30n> frerich: There ought to be something in itertools module
12:46:06 <Birch> You could do such a thing with generators though
12:46:07 <kadoban> Most functional stuff doesn't work too great in python, unfortunately :-/
12:46:23 <EvanR> dont use reduce is any normal language because its not acceptable to most people
12:46:36 <maerwald> fabianhjr: I see "sum = getSum #. foldMap Sum"
12:46:47 <EvanR> for loops obv
12:46:49 <Birch> In many cases it's just changing the [] brackets to (), depending on what you're doing. but yeah, I understand the sentiment :)
12:46:51 <frerich> Birch: How would a generator help avoiding that 'reduce' traverses the entire sequence?
12:47:03 <Birch> generators can bail early right?
12:47:05 <mmachenry> kadoban: But such potential squandered. Python could easily tack on great functional support if anyone in that community believed in it.
12:47:19 <Birch> I guess it uh has issues. Like now your generator has to know how to bail, not the thing calling it
12:47:27 <kadoban> mmachenry: Yeah. Instead the community is kind of actively hostile to it.
12:47:39 <Birch> so it's not really equivalent, even though it might look at a distance like "Don't look at all the elements in a list" or something
12:47:40 <mmachenry> kadoban: Exactly. It's sad. 
12:48:00 <EvanR> mmachenry: im kind of scared of functional without types
12:48:23 <EvanR> its even faster and looser than oop without types
12:48:30 <Birch> As someone who loves types, don't be. Be more scared of mutability.
12:48:34 <Birch> But then secondly be scared of no types
12:48:39 <mmachenry> EvanR: I'm not at all. I was a Scheme programmer for years.
12:48:40 <frerich> Birch: A generator only helps in that it can avoid computing the entire sequence if you don't call it, but I see nothing in 'reduce' which would make it stop actually fetching values frmo the generator.
12:48:42 <Birch> Add core typed to all your closures
12:48:44 <Birch> er
12:48:47 <Birch> clojures*
12:49:08 <Birch> frerich: you're entirely correct.
12:49:18 <EvanR> is python prone to mutable these days?
12:49:29 <mmachenry> Birch: It's spelled closure unless you're talking about the language Clojure. 
12:49:32 <linkages> hi thre is a library funciotn to remove the n-th element of a list?
12:49:36 <Birch> I'm talking about the language Clojure
12:49:43 <Birch> In a humourous wording.
12:49:44 <mmachenry> Birch: Ah
12:50:07 <frerich> kadoban, mmachenry: I think 'hostile' is a bit exaggerated. Python took a few concepts straight from functional languages. In fact, I recently saw that on https://wiki.python.org/moin/PythonVsHaskell it says 'Python's list comprehension syntax is taken (with trivial keyword/symbol modifications) directly from Haskell. The idea was just too good to pass up.' which - to me - sounds like a very nice compliment!
12:50:08 <Birch> I should have said "add core.typed to all of your Clojure projects" :)
12:50:38 <linkages> better if i rewrite ...too many errors ...: is there any library function to remove the n-th element of a list?
12:51:38 <prsteele> linkages: haskell.org/hoogle is a great place to check for things like this
12:51:39 <EvanR> does core.typed check the types of stuff within a function body, or just runtime check the top level functions
12:51:55 <ClaudiusMaximus> linkages: you could use splitAt to make one, but lists are bad at random access, so maybe some other data structure would suit your real problem better
12:51:56 <prsteele> linkages: I can only imagine two signatures for such a function, [a] -> Int -> [a] or Int -> [a] -> [a]
12:52:37 <frerich> linkages: I think something like '\n xs -> let (a,b) = splitAt n xs in a ++ drop 1 b' might do
12:52:39 <hunteriam> is yesod still the best option for a generic webserver?
12:52:46 <frerich> linkages: (maybe off by one)
12:52:48 <linkages> prsteele, yes is the same signature i use
12:52:52 <bananagram> dangit, I was writing that
12:52:57 <Birch> prsteele has the right approach. If you search for that signature on hoogle, you get something
12:53:11 <Birch> that looks suspiciously like what you want
12:53:12 <linkages> frerich, ClaudiusMaximus  thank you
12:53:13 <Birch> http://hackage.haskell.org/package/base-4.8.0.0/docs/Data-List.html#v:delete
12:53:25 <Birch> wait
12:53:25 <Birch> derp
12:53:26 <linkages> for idea how to proceede
12:53:28 <Birch> Don't listen to me
12:53:30 <kadoban> frerich: My idea of it being hostile to it comes from hanging out in #python and seeing anything approaching something that would improve FP in python being shot down fairly hard, and also the fact that guido occassionally publicly says things about wanting to remove reduce/lambda/filter, etc.
12:53:35 <Birch> I'm derping. You want the index, not the first occurance of.
12:53:45 <Birch> I'll just derp out this door over here. Don't mind me.
12:53:46 <maerwald> > (\(x, y) -> x ++ tail y) . splitAt 3 $ [1,2,3,4,5,6]
12:53:47 <lambdabot>  [1,2,3,5,6]
12:53:50 <maerwald> unsafe ofc
12:53:51 <Forgetaboutit> hunteriam: Yesod is a framework like Rails.  I believe you might be looking for Warp, which is the server Yesod uses
12:54:13 <maerwald> linkages: I'd write my own one like above and make it safe
12:54:26 <linkages> yes
12:57:21 <hunteriam> does anyone here use Visual Haskell for development?
12:58:37 <zq> MS Visual Haskell++ 7.0
12:58:54 <kadoban> *shudder*
12:59:23 <geekosaur> I thought the visual haskell plugin died early
12:59:26 <maerwald> that gave me chills :D
12:59:46 <hunteriam> what do you guys use on windows then?
13:00:08 <kadoban> In that horrible situation, I'd use a VM with linux in it ;)
13:00:14 <moghedrin> ^
13:00:27 <geekosaur> (problem with VH being that it broke completely every time a new VS came out)
13:00:28 <kadoban> Or possibily one of the BSDs I suppose
13:00:42 <hunteriam> anyone who actually develops in windows here?
13:01:31 <kadoban> Serious advice, I'd probably use atom or sublime or one of those I guess, if you're not into vim or emacs.
13:01:45 <kirill`> What's a good way to generate C code from Haskell?
13:01:54 <zq> kirill`: ivory
13:02:02 <zq> oh wait c code
13:02:18 <hunteriam> i do like vim but i was hoping for a system with less hassle, getting vim to work with all the plugins for haskell has never gone very well for me
13:02:32 <zq> kirill`: if your code doesn't allocate, ivory would work
13:02:37 <Walther> hmm... is there a working haskell to clean translator?
13:02:45 <kadoban> Yeah, I eventually got my vim setup how I like it, but I can't say it was simple exactly.
13:03:16 <kirill`> zq: I mostly have arithmetic operations, it's nothing complicated. I'm looking for a way to "macro-expand" some common numerical tricks in special functions.
13:03:19 <Walther> I have a couple assignments for a functional programming course, the assignments are officially in Clean and some of the missing syntax can be a bit of a drag-down
13:03:24 <hunteriam> @Walther what is clean
13:03:24 <lambdabot> Unknown command, try @list
13:04:11 <Walther> http://en.wikipedia.org/wiki/Clean_%28programming_language%29
13:04:23 <Walther> grandfather of haskell
13:04:27 <Walther> or something along the lines
13:05:10 <kirill`> Hm, ivory looks interesting
13:06:49 <quchen> If Clean really appeared first in 1987, then it's pretty young for being a grandfather to Haskell.
13:07:36 <zq> kirill`: it might be a bit overkill if all you need is arith. maybe write your own with language-c
13:09:16 * hackagebot memory 0.4 - memory and related abtraction stuff  http://hackage.haskell.org/package/memory-0.4 (VincentHanquez)
13:09:40 <Hijiri> I think clean was among a bunch of other pure lazy functional languages when haskell was conceived as a "standard" one
13:10:08 <napping> The annotation stuff in compdata seems a bit less developed than the rest
13:13:05 <markus3> napping: yup, the %%~ was precisely what I was searching for
13:13:26 <hunteriam> does anyone know hoiw to install the latest ghc on windows?
13:13:44 <markus3> now I have the situation of the haskell ceo :) : "Dan boasts that he reduced lines of code by 60% using lenses. Fuckin' great. Now I explain to the board why we only have 78 LINES TOTAL."
13:13:55 <hunteriam> ive downloaded the windows binary, but i dont know what to do it
13:13:57 <hunteriam> to do with it
13:14:16 * hackagebot force-layout 0.4.0.1 - Simple force-directed layout  http://hackage.haskell.org/package/force-layout-0.4.0.1 (bergey)
13:14:21 <hunteriam> markus3: whats the aplication?
13:14:41 <markus3> its not public
13:14:49 <markus3> but its web
13:14:55 <napping> markus3: that's one of the synonyms of id
13:15:01 <geekosaur> hunteriam, the easiest way to get ghc going on windows is https://github.com/fpco/minghc
13:15:44 <markus3> thats kind of weird, but i'll leave that for tomorrow :)
13:15:49 <markus3> cya
13:24:17 <filippp> hello
13:24:35 <filippp> I'm reading the infamous bananas paper: http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf
13:24:47 <filippp> what is the induction principle used on the bottom of page 12? (UP for catamorphisms)
13:25:20 <ttt_fff> what is the start of the art of "randomized testing stuff" for haskell ?
13:25:26 <ttt_fff> perferably something that integrates with cabal
13:25:34 <ttt_fff> I want to just feed it a bunch of invariants and have it test those invariants for me
13:25:40 <napping> that's for a least fixed point, right?
13:26:04 <ttt_fff> no, this is for arbitrary functions
13:26:28 <napping> If so, the induction principal is the one you get from the "unique" in the definition of initial as in "initial algebra"
13:27:28 <jle`> ttt_fff: property checks are things you'd use quickcheck and stuf for
13:27:42 <ttt_fff> jle`: so quikcheck2 is still state of the art ?
13:27:47 <jle`> hspec is a framework that incorporates both property check and unit tests
13:28:00 <jle`> yeah, quickcheck is still the leading property test framework, i believe
13:28:09 <jle`> but these days in the real world people use a combination of property and unit tests
13:28:33 <jle`> but it seems like your question is specifically about property tests and fuzzing
13:28:36 <jle`> so yeah, quickcheck :)
13:28:50 <phaazon> my god
13:28:53 <phaazon> dependent typing is
13:28:53 <phaazon> hm
13:28:54 <phaazon> <3
13:29:00 <phaazon> I just wrote that
13:29:01 <phaazon> http://lpaste.net/1637005073810718720
13:29:05 <phaazon> I think I have something.
13:30:19 <phaazon> examples at the end of the lpast
13:30:22 <phaazon> e
13:30:51 <jle`> nice phaazon :)
13:31:00 <phaazon> yeah
13:31:12 <phaazon> Iâ€™m gonna test the whole thing on my engineâ€™s internal OpenGL layer
13:31:16 <phaazon> if it succeeds
13:31:25 <phaazon> Iâ€™l release the Indexed OpenGL stuff onto hackahe
13:31:28 <phaazon> s/h/g
13:31:38 <phaazon> because I think itâ€™s totally worth it
13:31:39 <chrisdone> would anybody be interested in fleshing this out with more types and benchmarks? https://github.com/chrisdone/haskell-container-types
13:31:52 <phaazon> Iâ€™m gonna write about it
13:32:04 <chrisdone> i want The Computer Language Shootout, but for haskell container types :3 
13:32:31 <jle`> chrisdone: looks promising :)
13:32:57 <filippp> napping: I think it's actually on subsequent approximations of the value on which the functions are applied on
13:33:37 <hunteriam> does anyone have experience installing haskell on windows?
13:33:38 <johnw> chrisdone: ltns!
13:33:39 <chrisdone> don't have time or the keypress bandwidth to flesh it out with code or real numbers yet, maybe this weekend. but i thought i'd put something up to get the idea out there
13:33:53 <hunteriam> im having quite a bad time with it
13:34:00 <refefer> hmm, how can I specify in my cabal file that dependencies depend on executables like 'alex' and 'happy'?
13:34:00 <chrisdone> hai :)
13:34:04 * chrisdone waves
13:34:09 <jle`> don't mind if i fork :3
13:34:10 <refefer> keeps crapping out on c2hs and kin
13:34:18 <kirill`> Why does language-c-quote have all these data constructors like "Id" and "AntiId". C doesn't have anti-identifiers, so what are they?
13:34:23 <chrisdone> jle`: please go ahead!
13:34:26 <hunteriam> when i cabal install things i get "GHC.PackageDb.readPackageDb: inappropriate type"
13:34:30 <hunteriam> anyone know what to do?
13:34:39 <darkroom> so I have been trying to install ghc-7.10.1 off a ppa but after i "sudo apt-get install" and check ghc's verison number it still says ghc-7.6.4 what am i doing wrong?
13:35:06 <jle`> darkroom: it installs it to a directory i think, so you have to add it to the $PATH
13:35:12 <jle`> ...if i recall correctly
13:35:17 <refefer> darkroom: have you done an update?
13:35:23 <refefer> `sudo apt-get update`
13:35:43 <jle`> that or do a symbolic link from the directory to /usr/bin
13:35:55 <darkroom> refefer: yes because when i do "apt-cache search ghc-7.10.1" it comes up
13:36:15 <jle`> sorry for the ping usr 
13:36:43 <darkroom> jle`: how do you add things to $PATH export correct?
13:38:31 <ClaudiusMaximus> phaazon: did you see what i came up with the other day? http://lpaste.net/133314#a133342  (though i missed some things - drawArrays should also check there is a usedprogram - of course all this depends on the specific version of gl and extensions...)
13:38:35 <igniting> darkroom: export PATH=/path/to/ghc:$PATH
13:38:57 <igniting> assuming you are using bash
13:39:55 <darkroom> igniting: i am sorry i am new to linux where do i find things that have been downloaded by apt-get
13:40:19 <hunteriam> does anyone here know anything about haskell on windows
13:40:27 <hunteriam> such as where cabal stores its gunk?
13:40:38 <igniting> darkroom: run `which ghc` in your terminal
13:40:44 <hunteriam> i tried cabal installing ghc-mod on a fresh haskell install, and everything broke
13:40:47 <Hijiri> I assume it's in application data somewhere
13:40:47 <jle`> darkroom: from https://launchpad.net/~hvr/+archive/ubuntu/ghc , the hvr ppk stores the ghc binaries in /opt/ghc/$VER
13:41:24 <jle`> darkroom: so add /opt/ghc/7.10.1/bin to your PATH
13:41:26 <hunteriam> Hijiri: there seems like there are a lot of places to look
13:41:47 <jle`> darkroom: or you can go to /usr/bin and ln -s stuff from the ghc directory to /usr/bin
13:42:23 <darkroom> jle`: export PATH=/usr/bin/ghc:$PATH is that right?
13:42:32 <igniting> darkroom: no
13:42:41 <igniting> that is your old ghc installation
13:42:58 <jle`> export PATH="/opt/ghc/7.10.1/bin:$PATH"
13:43:10 <jle`> if you installed 7.10.1
13:43:17 <xrg__> What is the difference between types and kinds?
13:43:28 <jle`> xrg__: values have types; types have kinds
13:43:29 <darkroom> jle`: should i replace $PATH?
13:43:33 <hunteriam> xrg__: a kind is like a type of types
13:43:37 <darkroom> ^
13:43:40 <jle`> darkroom: no, $PATH is the "old PATH"
13:43:56 <jle`> so that command modifies the path variable by appending something to the start
13:44:28 <darkroom> jle`: thank you that worked and i learned alittle :)
13:44:30 <igniting> darkroom: you can do "echo $PATH" to see your current path
13:44:37 <jle`> np :)
13:44:50 <darkroom> xrg__: look at the learn you a haskell page on kinds
13:45:32 <darkroom> xrg__: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#kinds-and-some-type-foo
13:46:11 <jle`> darkroom: by the way, this way you can use multiple ghc's on your system without any problem
13:46:13 <xrg__> oke, thanks
13:46:17 <jle`> and cabal works with whatever GHC is in PATH
13:46:41 <jle`> so if you export a new PATH with a different ghc version before all of the other ones, cabal/ghc will default to that one
13:46:41 <darkroom> jle`: i assume you just change the PATH?
13:46:42 <hunteriam> anyone know where cabal stores packages on windows?
13:46:44 <jle`> yeah
13:47:08 <darkroom> jle`: sick anyway you can make like temporary PATH like GHC78PATH
13:47:36 <jle`> you can but i usually just write a script to tack on a new directory to teh current path
13:48:34 <hunteriam> how do you regenerate ghc's package cache?
13:49:17 <hunteriam> somehow mine got corrupted to nul bytes
13:50:31 <phaazon> ClaudiusMaximus: Iâ€™m checking
13:50:43 <phaazon> EmptyDataDecls?
13:50:51 <phaazon> I think itâ€™s enabled per default now
13:51:20 <phaazon> ahah
13:51:25 <phaazon> the type-level map
13:51:30 <phaazon> BLACK MAGIC
13:52:18 <hunteriam> or uh
13:52:25 <hunteriam> how do i figure out where cabal is storing its stuff
13:52:25 <hunteriam> ?
13:52:59 <dcoutts> hunteriam: most of it is specified in ~/.cabal/config
13:53:05 <hunteriam> dcoutts: windows
13:53:22 <voidzero> close the windows before it gets cold
13:53:23 <dcoutts> hunteriam: cabal --help  gives the location of the config file
13:54:15 <hunteriam> ah thanks
13:54:19 <hunteriam> voidzero: its too hot
14:00:57 <voidzero> ah yes, cpu cycles i wager 
14:01:08 <DerisiveLogic> Anyone here from NYC?
14:08:11 <quchen> xrg__: And the "type of kinds" is usually called "sort". After that, they probably ran out of synonyms. ;-)
14:08:58 <xrg__> Are there other kinds besides '*'?
14:09:02 <quchen> Sure
14:09:04 <quchen> :k Either
14:09:05 <lambdabot> * -> * -> *
14:09:11 <quchen> :k Monad
14:09:12 <lambdabot> (* -> *) -> Constraint
14:09:18 * hackagebot datetime-sb 0.2.3 - Utilities to make Data.Time.* easier to use.  http://hackage.haskell.org/package/datetime-sb-0.2.3 (jsl)
14:09:21 <quchen> :k StateT
14:09:23 <lambdabot> * -> (* -> *) -> * -> *
14:09:53 <quchen> xrg__: Types of kind * are the only ones that can have values, however. You cannot have a value of e.g. "Maybe", because that has kind *->*.
14:10:04 <quchen> You *can* have values of type "Maybe Int", which has kind *.
14:10:18 <phaazon> ClaudiusMaximus: very interesting snippet
14:10:19 <maerwald> :k *
14:10:21 <lambdabot> parse error on input â€˜*â€™
14:10:36 <xrg__> quchen, but is that really a different kind? Aren't those examples functions that take the kind '*'
14:10:37 <maerwald> we need to go deeper :/
14:10:42 <phaazon> even though your Key type makes me dubitative
14:11:16 <quchen> xrg__: Maybe is not a function that takes values to values, it's a function that takes types to types.
14:12:07 <ClaudiusMaximus> phaazon: :)  it stores an association list, the families ensure there is at most one with any given key
14:12:17 <quchen> "Just" is a function that when applied to an argument, gives you a new value, namely "Just <arg>". "Maybe" is a type-level function that when applied to an argument (which has to be a type of kind *) you get a new type, namely "Maybe <arg>".
14:12:32 <quchen> xrg__: "Maybe Int" is the "Maybe" type-level function applied to "Int".
14:12:37 <hunteriam> im getting the error that ExposePackageId is missing when i try to install ghc-mod in cabal 1.22.2.0 and ghc 7.10.1
14:12:40 <darkroom> my syntastic just outputed this error: "syntastic: error: checker haskell/ghc_mod returned abnormal status 1" is there anyway to make syntastic more verbose i have no idea what this error is about
14:12:42 <hunteriam> can anyone help
14:12:43 <hunteriam> ?
14:12:48 <mniip> maerwald, * :: BOX
14:13:03 <phaazon> ClaudiusMaximus: I donâ€™t get the use of the type family
14:13:07 <quchen> maerwald: Agda goes deeper. :-)
14:13:13 <phaazon> Iâ€™ve never used them beside in typeclasses
14:13:16 <mniip> as can be seen in really obsucated error messages GHC produces
14:14:12 <dale_> chaps, I'm using Parsec to parse a toy programming language. Once I have the parse tree, I am going to need to perform a series of compile time checks (type-checking, uninitialized variable checks etc). Thus I would like to decorate each node in my parse tree with addl context like line/col
14:14:20 <ClaudiusMaximus> phaazon: it's essentially functions on types, much like what you can do with mptc/fundeps stuff but with less pain
14:14:21 <dale_> I'm sure i could roll something myself, but does a facility already exist
14:14:32 <phaazon> ok
14:14:34 <phaazon> so for instance
14:14:34 <dale_> perhaps a parser that consumes no input but returns the current line and column
14:14:43 <phaazon> if you want to know whether BoundFramebuffer is in the map
14:14:48 <phaazon> how do you do?
14:14:57 <darkroom> dale_: I believe there is let me find it
14:15:06 <phaazon> foo :: (Member BoundFramebuffer s)
14:15:07 <phaazon> ?
14:15:10 <phaazon> well
14:15:11 <dale_> darkroom: thank you v. much. I tried g/hoogling but to no avail
14:15:14 <phaazon> foo :: (Member BoundFramebuffer s) => â€¦
14:15:18 <xrg__> quchen, thanks for the help. I saved our conversation. I really need to fresh up my basics.
14:15:33 <darkroom> dale_: getPossition ;)
14:15:40 <dale_> haha
14:15:40 <phaazon> foo :: (Member BoundFramebuffer s ~ Yes) => â€¦
14:15:41 <dale_> neat
14:15:42 <ClaudiusMaximus> phaazon: Member BoundFramebuffer s ~ True, or if you want a specific one bound it'd be Lookup BoundFramebuffer s ~ MyFBO  or similar
14:15:43 <dale_> thanks!
14:15:44 <dale_> I'm an idiot
14:15:45 <quchen> xrg__: LYAH talks about kinds a little if you want a maybe more coherent version.
14:15:49 <phaazon> or something like True lifted to type-level
14:15:58 <darkroom> dale_: sometimes i make the mistake about not checking the first page too dont worry
14:16:04 <phaazon> ClaudiusMaximus: ~ True?
14:16:10 <phaazon> how can that even work?
14:16:23 <ClaudiusMaximus> phaazon: yeah, DataKinds :)  promotes data types to types!
14:16:31 <quchen> xrg__: FWIW in basic Haskell you rarely need to go beyond (* -> *) -> * -> *, usually not even *->*
14:16:37 <phaazon> oh
14:16:41 <phaazon> ultra cool
14:16:42 <phaazon> thanks :)
14:17:07 <phaazon> so hm
14:17:14 <ClaudiusMaximus> phaazon: * if you want a specific one bound it'd be Lookup BoundFramebuffer s ~ Just MyFBO
14:17:23 <ClaudiusMaximus> phaazon: forgot i use promoted maybe too
14:17:35 <phaazon> I guess that it has zero runtime cost
14:17:40 <phaazon> because of the two phantom types
14:17:43 <ClaudiusMaximus> i hope so!
14:17:47 <phaazon> well
14:17:48 <phaazon> here:
14:18:02 <phaazon> newtype GL i j a = GL {runGL :: IO a}
14:18:14 <phaazon> type role GL phantom phantom representational
14:18:18 <phaazon> phantom phantom
14:18:22 <phaazon> that should be 0 at runtime
14:19:19 * hackagebot opentheory 1.199 - The standard theory library  http://hackage.haskell.org/package/opentheory-1.199 (JoeHurd)
14:20:47 <phaazon> ClaudiusMaximus: I canâ€™t imagine the errors youâ€™d get with that :D
14:23:16 <phaazon> ClaudiusMaximus: can we lift Int to the type-system?
14:23:19 <phaazon> with DataKind?
14:23:48 <phaazon> btw you forgot the glClear function, I guess
14:25:36 <ClaudiusMaximus> phaazon: there are type nats, but i'm not sure what the state of arithmetic etc is; also strings/symbols (which i saw in HList)
14:27:53 <phaazon> ClaudiusMaximus: I think of it so that we could track textures binding
14:27:56 <phaazon> (to units)
14:28:12 <phaazon> because the OpenGL state allows to bind several textures at a time
14:28:20 <phaazon> as long as theyâ€™re bound to a different texture unit
14:29:20 * hackagebot haskellscript 0.2.0 - Command line tool for running Haskell scripts with a hashbang.  http://hackage.haskell.org/package/haskellscript-0.2.0 (seanparsons)
14:34:06 <lpaste> igniting pasted â€œList Applicativeâ€ at http://lpaste.net/133386
14:34:54 <arkeet> interesting
14:34:54 <igniting> in base-4.8.0.0 <* is defined as liftA2 const, then why the difference in benchmark?
14:37:11 <quchen> igniting: The *default definition* is liftA2 const, but instances may overwrite this behaviour.
14:37:32 <arkeet> but the instance for [] does not.
14:37:45 <quchen> Hm, right. Okay, weird.
14:38:14 <igniting> http://www.reddit.com/r/haskelltil/comments/36sor3/duplicate_every_element_of_the_list_with/crlf47g for context
14:40:35 <quchen> igniting: What happens when you explicitly share the `liftA2 const`?   let foo = liftA2 const in bench "liftA2" $ nf (foo [1..1000 :: Int]) [(), (), (), ()]]
14:42:33 <igniting> quchen: that didn't change anything. note that liftA2 version is faster
14:44:29 <subleq> is an endomorphism just a name for functions from a -> a?
14:44:45 <quchen> Yes.
14:45:04 <quchen> We're not quite sure why the docs mention this either.
14:45:13 <quchen> In case that's where you're coming from.
14:45:20 <subleq> yeah, the Endo monoid 
14:45:34 <subleq> Is just the monoid of functions under composition?
14:45:43 <quchen> That one is probably the most terrible piece of documentation we have in Base, apologies for that.
14:45:55 <quchen> Yes, it's the monoid with mempty=id, mconcat=(.)
14:46:03 <subleq> cool
14:46:05 <arkeet> except wrapped up in a newtype
14:46:11 <arkeet> because there's a different monoid instance for functions
14:46:17 <subleq> oh? what is it?
14:46:22 <quchen> Monoid b => a -> b
14:46:28 <arkeet> Monoid b => Monoid (a -> b)
14:46:46 <arkeet> mempty = const mempty, mappend f g = \x -> mappend (f x) (g x)
14:47:20 <arkeet> > (show <> show) 10
14:47:22 <lambdabot>  "1010"
14:47:24 <arkeet> I dunno. silly example.
14:47:30 <quchen> Or maybe more readable as "(a `mappend` b) x = (a x `mappend` b x)"
14:47:39 <subleq> ok cool
14:47:44 <subleq> is that useful for anything?
14:47:59 <quchen> Yes, for example chaining comparison functions.
14:48:35 <quchen> sortBy (comparing length <> compare) ["hello", "a", "bc", "world", "asdfg"]
14:48:36 <quchen> > sortBy (comparing length <> compare) ["hello", "a", "bc", "world", "asdfg"]
14:48:38 <lambdabot>  ["a","bc","asdfg","hello","world"]
14:48:53 <subleq> neat
14:48:56 <quchen> "Sort by length first, if it matches then compare lexiocgraphically"
14:49:01 <frerich> quchen: Do you know another example of how it's useful?
14:49:08 <subleq> thank you arkeet and quchen 
14:49:21 * hackagebot airship 0.2.0.0 - A Webmachine-inspired HTTP library  http://hackage.haskell.org/package/airship-0.2.0.0 (reiddraper)
14:49:31 <johnw> frerich: you mean, just how monaids are useful?
14:49:33 <quchen> frerich: Not one I could write down in one line. I've used it a couple of times in a larger context, but not terribly often.
14:49:51 <arkeet> johnw: the instance for functions
14:49:54 <johnw> ah
14:50:12 <johnw> I use Endo to make on-the-spot dlists
14:50:32 <quchen> It allows you to factor out function arguments out of lists of monoidal values, which is sometimes more readable. Very sometimes.
14:50:34 <frerich> johnw: Maybe; I was specifically thinking of the instance for functions but I guess generally useful examples are nice, too. I *always* see this 'chaining comparison functions' example. :-}
14:50:43 <johnw> appEndo (Endo (as <>) <> Endo (bs <>)) []
14:50:52 <johnw> oh, I see
14:51:06 <frerich> johnw: So I made a habit of asking people who give the example for whether they also know other nice examples. :-)
14:52:20 <johnw> so, a bunch of functions that all take the same argument and return a monoid, turns into one function taking that agument and returning an aggregate...
14:52:34 <johnw> (an mconcat'd monoid, I mean)
14:52:54 <arkeet> I swear I've used it once with foldMap or something before.
14:53:08 <arkeet> I forget now.
14:54:30 <Walther> > let ins x list = map ((take half) ++ [x] ++ (drop half)) list where half xs = div (length xs) 2
14:54:31 <lambdabot>  <no location info>:
14:54:31 <lambdabot>      not an expression: â€˜let ins x list = map ((take half) ++ [x] ++ (drop ha...
14:56:22 <quchen> Exercise: write a function that splits a list in halves that does not need to traverse it entirely
14:56:29 <quchen> (In other words, don't use `length`)
14:57:04 <arkeet> pretty sure you have to traverse the whole list at least once.
14:57:06 <Walther> for now i'm trying to add an element to the middle of all lists in a list
14:58:16 <quchen> arkeet: Nope :-)
14:58:32 <frerich> quchen: I don't see a way to avoid traversing the list entirely; you could use a 'tortoise-and-hare' style trick where you traverse the list two elements at a time, but then you still traversed it completely?
14:58:40 <quchen> arkeet: Adding an element to the middle of an infinite list is a well-defined operation (that is identical to the input list)
14:59:04 <quchen> frerich: tortoise-and-hare requires knowing that you've reached a certain location (again), which you can't do with lists
14:59:16 <quchen> You would have to look at memory locations
14:59:17 <arkeet> it's easy to not traverse the input list if you don't traverse the output.
14:59:21 * hackagebot inline-c 0.5.3.0 - Write Haskell source files including C code inline. No FFI required.  http://hackage.haskell.org/package/inline-c-0.5.3.0 (FrancescoMazzoli)
14:59:40 <arkeet> that's not fair, quchen.
14:59:41 <arkeet> :-)
14:59:52 <quchen> arkeet: You can take N elements from an infinite list, but you cannot take N elements if you require "length" to be computed in the process
15:00:03 <subleq> interesting problem
15:00:05 <arkeet> sure.
15:00:21 <subleq> it doesn't seem possible, because there's no way to know if the input list is actually infinite
15:00:27 <Walther> even if using length weren't optimal, what is the problem wirh my line; where does it go wrong?
15:00:29 <arkeet> it's easy, just use lazy naturals.
15:00:53 <arkeet> Walther: first of all, "let ..." without "in" is not a valid expression. > in lambdabot evaluates expressions.
15:01:05 <arkeet> and then "take half" and "drop half" are functions, not lists, so it doesn't make sense to use ++ on them.
15:01:25 <arkeet> nor does it make sense to apply the result of ++ to a list.
15:01:46 <Walther> ah, so currying doesn't work there, it doesn't apply the take half's to the current sublist
15:02:05 <quchen> subleq: You don't nee to know whether the input is infinite. To insert the element into the middle, all you have to know is that you're already past the center. :-Ã¾
15:02:24 <subleq> ...isn't that the same thing?
15:02:38 <quchen> http://lpaste.net/133392
15:03:26 <frerich> quchen: Doesn't "half" do just what I wrote, the 'walk two elements at a time until you get to the end of the list' thing?
15:03:50 <subleq> quchen: neat
15:04:09 <quchen> frerich: Oh, if that's what you meant, then yes. Mentioning tortoise and hare confused me.
15:04:51 <frerich> quchen: So 'half' still traverses the entire list much like 'length' would do - except that 'half' does it two elements at a time, no?
15:04:53 <quchen> The general idea is of course "if you can walk 2*N steps, then you haven't seen the middle yet"
15:05:14 <subleq> that's super cool
15:05:31 <quchen> frerich: For a finite list, you have to traverse the entire list. But the point is that you can get a result without doing the entire traversal.
15:05:53 <quchen> To get the first 2 element of "insert X in middle" you have to walk only 4 steps.
15:05:58 <quchen> Not N or âˆž.
15:06:21 <quchen> Using "length" on the other hand *does* require you to traverse the entire list before you can get any result.
15:06:52 <frerich> The 'before' part is what I overread, because that's the important part I think. I got hung up on the 'entire list' part. :-}
15:07:25 <Walther> > let ins x [list] = map ((take half list) ++ [x] ++ (drop half list)) list where half xs = div (length xs) 2
15:07:26 <lambdabot>  <no location info>:
15:07:26 <lambdabot>      not an expression: â€˜let ins x [list] = map ((take half list) ++ [x] ++ (...
15:07:48 <quchen> Lambdabot doesn't play well with "where".
15:08:03 <quchen> You have to give her an expression, and "where" spans over definitions.
15:08:04 <arkeet> Walther: see the first thing I said, about "let".
15:08:32 <frerich> quchen: I may have misused 'tortoise and hare' (first learned it for detecting cycles) but I somehow started using it for all algorithms which use some sort of 'move two pointers, one of them faster than the others' much like 'half' and 'end' in your program.
15:08:38 <frerich> I.e. 'half' is what Icall the hare. :-)
15:08:42 <ion> She works just fine with syntactically correct â€œwhereâ€.
15:09:16 <Walther> > ins x [list] = map ((take half list) ++ [x] ++ (drop half list)) [list] where half xs = div (length xs) 2
15:09:16 <ion> > let x = y where { y = 42 } in x
15:09:19 <lambdabot>  <no location info>: can't find file: L.hs
15:09:19 <lambdabot>  42
15:10:46 <hsyl20> rhaps0dy: you can use Foreign.Marshal.Array from base too
15:11:01 <Walther> well, perhaps time for sleep and continue tomorrow with fresher mind. thanks for the help!
15:11:03 <rhaps0dy> whoah, you do read a lot of scrollback
15:11:26 <lpaste> arkeet pasted â€œinsertMiddle with lazy naturalsâ€ at http://lpaste.net/133393
15:11:39 <hsyl20> rhaps0dy: yes by mistake, my screen wasn't scrolling :p
15:11:40 <lpaste> arkeet revised â€œinsertMiddle with lazy naturalsâ€: â€œNo titleâ€ at http://lpaste.net/133393
15:12:07 <rhaps0dy> hsyl20: lol
15:12:10 <rhaps0dy> long time to keep the client open
15:12:25 <hsyl20> oh the client is always open in a screen session
15:13:17 <ion> > let ins x xs = go xs xs where { go (y:ys) (_:_:zs) = y : go ys zs; go ys _ = x : ys } in ins ' ' ['a'..'z']
15:13:18 <lambdabot>  "abcdefghijklm nopqrstuvwxyz"
15:13:27 <arkeet> @letlpaste 133393
15:13:29 <lambdabot>  Defined.
15:13:36 <arkeet> > insertMiddle ' ' ['a'..'z']
15:13:38 <lambdabot>  "abcdefghijklm nopqrstuvwxyz"
15:13:40 <arkeet> > insertMiddle ' ' [0..]
15:13:41 <lambdabot>      No instance for (Num Char) arising from the literal â€˜0â€™
15:13:41 <lambdabot>      In the expression: 0
15:13:41 <lambdabot>      In the second argument of â€˜insertMiddleâ€™, namely â€˜[0 .. ]â€™
15:13:48 <unb3k44n7> Hi.
15:13:50 <arkeet> > insertMiddle (_1) [0..]
15:13:52 <lambdabot>      No instance for (Typeable f0)
15:13:52 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
15:13:52 <lambdabot>        arising from a use of â€˜show_M849947174739499668122140â€™
15:13:52 <arkeet> > insertMiddle (-1) [0..]
15:13:53 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
15:13:55 <arkeet> I can type.
15:14:01 <ion> > let ins x xs = go xs xs where { go (y:ys) (_:_:zs) = y : go ys zs; go ys _ = x : ys } in ins ' ' ['a'..]
15:14:03 <lambdabot>  "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137\...
15:14:23 <arkeet> > insertMiddle ' ' (replicate 15 'a')
15:14:25 <lambdabot>  "aaaaaaa aaaaaaaa"
15:14:26 <arkeet> > insertMiddle ' ' (repeat 'a')
15:14:28 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
15:17:28 <subleq> can I not do foo `appEndo . getDual` bar?
15:17:47 <unb3k44n7> I learned so much Haskell last night by this amazing person.
15:17:55 <alexv19> Can I somehow pass value of type `MonadIO m => Ptr a -> m b` as 2nd argument to function `with :: Storable a => a -> (Ptr a -> IO b) -> IO b` ? Is there `unliftIO` ?
15:18:12 <unb3k44n7> Like 5 hours straight worth of stuff. 
15:18:26 <JoshieAS> unb3k44n7: oh yeah?
15:18:43 <unb3k44n7> Yes! I was up until like 7 am!
15:19:12 <unb3k44n7> I lost track of how much stuff Iwas learning about. And then It was morning.
15:20:07 <JoshieAS> what did you learn and from who?
15:20:23 <igniting> arkeet: quchen: running http://lpaste.net/133386 without any optimization gives equal times
15:20:51 <unb3k44n7> What?: A lot of stuff. Too much stuff to name. And it was a really smart college student.
15:20:58 <quchen> igniting: Uh okay
15:21:01 <zipper> Hey what can I read/watch to understand the state and reader monads real quick.
15:21:04 <zipper> *?
15:21:05 <quchen> I guess it's time to compare Core of both versions
15:21:12 <unb3k44n7> And they were actually patient and had me to do everything they were teaching me
15:24:40 <ion> zipper: Implement them yourself.
15:25:04 <ion> zipper: Start with Reader.
15:25:31 <unb3k44n7> They rescued me after some members of the room assumed Iknew way more than I didn't whenI was asking a question. Lol.
15:25:46 <unb3k44n7> did*
15:26:16 <quchen> Yes, that's a serious problem. I've come in here many times asking about "seq" only to see day turn night.
15:26:18 <frerich> quchen: I think I misunderstood your code, your 'half' function isn't actually what I had in mind when I wrote 'tortoise and hare'. It does walk two steps at a time, but in a different way than what I had in mind. Alas, my version actually doesn't work on infinite lists: http://lpaste.net/133394
15:26:51 <quchen> frerich: I'm trying to golf the function right now ;-)
15:26:57 <unb3k44n7> Exactly, quc.
15:27:20 <quchen> > let insertMiddle x i = let h(a:_:b)=a:h b;h _=[];e a[]=a;e(_:a)(_:b)=e a b in(zipWith const<*>h)i++x:ap e h i in insertMiddle 999 [1..10]
15:27:23 <lambdabot>  [1,2,3,4,5,999,6,7,8,9,10]
15:27:27 <unb3k44n7> That's what happened last night. I about curled into a ball and went under a rock for the night
15:28:11 <unb3k44n7> It turned into an uproar in here really quick over one concept and then I was like.. Ughh...Screw it
15:28:51 <quchen> Don't be intimidated, it's just very easy to stumble upon an intereting finesse
15:29:10 <unb3k44n7> I wasn't intimidated..... 
15:29:33 <zipper> ion: I don't know where to start. Will you be on irc a while?
15:29:38 <unb3k44n7> I about curled intoa ball over frustration of their responses
15:29:58 <shield00> hey guys. I was wondering: how can I load a text input dialog on my screen? I'm using Gloss for the visual part, but I didn't find anything like that in its docs.
15:30:12 <unb3k44n7> Just like what happened just now. You asssumed. Lol!
15:31:04 <unb3k44n7> Well anyways. It was pretty awesome and making progress in the Haskell world. Just thought I'd share
15:31:10 <unb3k44n7> Have a good day guys!!
15:31:32 <JoshieAS> o_O
15:31:53 <unb3k44n7> o_O dunno what you're implying, but back atcha!
15:32:32 <frerich> unb3k44n7: When somebody writes 'Don't need to be intimidated', that doens't necessarily imply that she thinks you were intimidated. It may just mean that she thinks there is no reason to be intimidated.
15:33:25 <unb3k44n7> ^ Either way, it was irrelevant. ^ 
15:33:33 <lpaste> gabemc pasted â€œData.Bytes.Serialize issue #2â€ at http://lpaste.net/133396
15:33:40 <kadoban> unb3k44n7: Note how you're trying to learn haskell by asking random strangers rather than following a good course. Frustration is the obvious result â€¦
15:33:52 <unb3k44n7> You again, Kad.
15:33:58 <unb3k44n7> I am learning from courses. Also.
15:34:00 <unb3k44n7> Thank you.
15:34:04 <unb3k44n7> For your input. 
15:34:05 <unb3k44n7> Again.
15:34:16 <frerich> kadoban: I think a large part (majority?) of people actually didn't learn people from any kind of course. :-}
15:34:20 <unb3k44n7> You don't know how i'm learning things.
15:34:24 <gabemc> Hey, I could use some more help with figuring out a type error in the above paste: http://lpaste.net/133396
15:34:25 <unb3k44n7> You're just assuming things.
15:34:31 <unb3k44n7> Idk what your deal is.
15:34:39 <arkeet> gabemc: I guess you are trying to use sfn polymorphically.
15:34:51 <gabemc> Yeah. I am.
15:34:53 <arkeet> which you can't do without at least Rank2Types and some type annotation.
15:34:58 <frerich> unb3k44n7: Before you go ballistic, remember that this is a fairly crowded room so if in doubt, imagine you're standing in a room with 1509 people. ;-)
15:35:07 <kadoban> I don't have a deal, it just seems like you're making life very hard on yourself. If you're learning from a course, then I apologize for assuming you weren't. IIRC you said you weren't last night, but I'm not infalible.
15:35:16 <hiptobecubic> frerich, aww, you spoiled it.
15:35:23 <unb3k44n7> Let's not use dramatic words
15:35:28 <unb3k44n7> `ballistic`
15:35:33 <JoshieAS> hold on, let's just not be dramatic in general
15:35:49 <unb3k44n7> Joshie has a problem with me too 
15:35:49 <JoshieAS> this is a chat room, for god's sake, we don't have to get all sensitive about these things
15:35:51 <hiptobecubic> Well frerich did say "before"
15:35:59 <kadoban> frerich: I mean a pretty general meaning of "course", in which any kind of structured tutorial, book or whatever would apply.
15:36:00 <unb3k44n7> I say bye and they give me a wide eye confused faced
15:36:29 <unb3k44n7> I think its better in here at night. Im not enjoying the attitude in here at the moment.
15:36:36 <unb3k44n7> Bye.
15:36:43 <frerich> unb3k44n7: Well I guess it's good to hear that you're making progress ith Haskell! :-)
15:37:16 <hunteriam> is haskell-docs broken in ghc 7.10
15:37:37 <hunteriam> im being told that it depends on something outside of the library when i try to install
15:41:24 <ion> zipper: I'm sorry, I'm already in bed, going to sleep soon. But the channel is full of people who can help you proceed. Fill in the holes. Take advantage of GHC typed holes error messages. newtype Reader e a = Reader { runReader :: e -> a }; instance Functor (Reader e) where { fmap f (Reader g) = Reader _ }; instance Applicative (Reader e) where { pure a = Reader _; Reader f <*> Reader x = Reader _ };
15:41:26 <ion> instance Monad (Reader e) where { return = pure; Reader x >>= k = _ }
15:43:13 <kadoban> hunteriam: It's quite possible. I'd recommend you post the full error message on lpaste, since what you've said isn't a lot to go on.
15:43:15 <arkeet> in the case of Reader, there is only really one possible implementation for those.
15:47:38 <gabemc> arkeet: I'm trying the annotation `serializeEndianHeader :: MonadPut m => forall a. (a -> m ()) -> m ()`, but the compiler is complaining about a being an ambiguous type variable....
15:47:54 <gabemc> ...My annotation-fu is clearly lacking....
15:48:33 <arkeet> put the forall a. inside those parentheses
15:48:43 <lodvaer> Where is it most kosher to get `fmap fmap fmap` as an operator from? Make one myself?
15:48:52 <arkeet> (this is where Rank2Types becomes necessary)
15:49:45 <ion> lodvaer: Also consider the option of "don't". :-)
15:50:49 <Cale> arkeet: What? That's... (forall a. a -> m ()) is isomorphic to m ()
15:51:01 <lodvaer> ion: Heh, perhaps. But I "need" to operate on something inside a functor inside a monad a lot...
15:51:23 <Cale> But I guess at least *that* type makes more sense
15:51:34 <Cale> It would probably help to know what gabemc is trying to write
15:51:43 <ion> (fmap . fmap) is too verbose?
15:52:05 <arkeet> Cale: I guess that's still not right then.
15:52:13 <arkeet> Cale: gabemc posted this http://lpaste.net/133396
15:52:56 <arkeet> and I guess he'd need another constraint on a
15:53:05 <lodvaer> ion: Hm. A bit ugly, but I suppose. It seemed like such a common pattern that I wondered if there was something standard. If not I'll go with that.
15:53:27 <gabemc> arkeet: Yeah, I need a (SerialEndian a) constraint on the a type, but I can't get the compiler to like where I put the annotation.
15:53:42 <Cale> Oh, I see
15:54:12 <gabemc> It says something about `AllowAmbiguousTypes` as an annotation, but that seems strange to me.
15:54:24 <ion> FWIW, i don't find that ugly at all. It reminds me of lens composition.
15:54:25 * hackagebot hmatrix-gsl-stats 0.3.0.2 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.3.0.2 (VivianMcPhail)
15:54:27 * hackagebot opentheory-primitive 1.7 - Haskell primitives used by OpenTheory packages  http://hackage.haskell.org/package/opentheory-primitive-1.7 (JoeHurd)
15:55:20 <Cale> Yeah, you want serializeEndianHeader :: MonadPut m => (forall a. Serial a => a -> m ()) -> m ()
15:56:04 <JoshieAS> what would be a good first project in Haskell?
15:56:09 <gabemc> Oh, whops, yeah, I got it.
15:56:15 <gabemc> Inside the forall.
15:56:28 <gabemc> Didn't realize you could put it there, actually....
15:56:36 <gabemc> Thanks again so much!
15:56:39 <arkeet> np
15:56:46 <Cale> Even putting a forall there requires an extension
15:57:00 <Cale> (That's what the RankNTypes business is about)
15:58:51 <Cale> JoshieAS: I dunno... once you've got the basics of the language down, it depends more on what you're interested in more than anything about Haskell itself.
15:58:54 <fvgvxmpv1> JoshieAS a toy calculator?
15:59:06 <fvgvxmpv1> itÂ´s the usual choice, methinks
15:59:07 <JoshieAS> I'd like to try my hand at a CLI program
15:59:22 <JoshieAS> you think it'd be manageable to do like...a typing speed game?
15:59:25 * hackagebot opentheory-stream 1.45 - Infinite stream types  http://hackage.haskell.org/package/opentheory-stream-1.45 (JoeHurd)
15:59:27 * hackagebot opentheory-probability 1.49 - Probability  http://hackage.haskell.org/package/opentheory-probability-1.49 (JoeHurd)
15:59:29 * hackagebot opentheory-bits 1.66 - Natural number to bit-list conversions  http://hackage.haskell.org/package/opentheory-bits-1.66 (JoeHurd)
15:59:31 * hackagebot opentheory-divides 1.62 - The divides relation on natural numbers  http://hackage.haskell.org/package/opentheory-divides-1.62 (JoeHurd)
15:59:33 * hackagebot opentheory-byte 1.126 - Bytes  http://hackage.haskell.org/package/opentheory-byte-1.126 (JoeHurd)
15:59:43 <Cale> JoshieAS: sure, shouldn't be too hard
16:01:25 <Cale> http://hackage.haskell.org/package/time-1.5.0.1/docs/Data-Time-Clock.html -- you'll want  getCurrentTime :: IO UTCTime  and  diffUTCTime :: UTCTime -> UTCTime -> NominalDiffTime  from here, I suspect.
16:02:22 <osa1> wow... seems like haddock markup is getting smarter. I just used `putStr` and not only its rendered as code, but it's also linked to base's haddock.
16:03:06 <Cale> osa1: Haddock has done this for quite a while now, so long as you have the relevant documentation installed.
16:04:35 * hackagebot opentheory-parser 1.158 - Stream parsers  http://hackage.haskell.org/package/opentheory-parser-1.158 (JoeHurd)
16:04:37 * hackagebot opentheory-unicode 1.140 - Unicode characters  http://hackage.haskell.org/package/opentheory-unicode-1.140 (JoeHurd)
16:04:39 * hackagebot opentheory-prime 1.82 - Prime natural numbers  http://hackage.haskell.org/package/opentheory-prime-1.82 (JoeHurd)
16:04:41 * hackagebot hsignal 0.2.7.1 - Signal processing and EEG data analysis  http://hackage.haskell.org/package/hsignal-0.2.7.1 (VivianMcPhail)
16:05:49 <osa1> wow.. I thought I have to use something like @putStr@ which always looked weird to me. good to know it's supporting markdown-like syntax.
16:06:11 <linman32> is it possible to evaluate a variable in a let before the variable is used in the IO?
16:07:00 <Cale> linman32: Depending on what it is that you're trying to accomplish with that, you might be interested in Control.Exception.evaluate
16:07:08 <Cale> :t Control.Exception.evaluate
16:07:10 <lambdabot> a -> IO a
16:07:16 <alex_ndc> hello, I'm playing with Haskell - installed GHC 7.10.1-r0 on OS X, unfortunately I couldn't install ghc-mod because of a known issue, currently doesn't support GHC 7.10.1 - wanted to ask if GHC 7.10.1 is experimental or maybe libraries haven't been migrated, or what's the story there? should I just go with 7.8.4?
16:07:32 <Cale> Executing evaluate v will cause v to be evaluated.
16:07:50 <Cale> alex_ndc: 7.10.1 is still pretty new
16:08:00 <pavonia> Control.Exception seems a strange place for that function
16:08:07 <linman32> Cale: want to reduce latency. makes sense that uses IO
16:08:29 <Cale> Most libraries and tools have been updated, but you can expect a handful of things not to have been
16:08:42 <Cale> ghc-mod is pretty inessential though
16:09:12 <Cale> I'd just do without it for now until the author manages to update it
16:10:22 <alex_ndc> @Cale - thanks - I wanted to try ghc-mod for Atom / Emacs, what do people use for Haskell? :) I can probably do without it
16:10:22 <lambdabot> Unknown command, try @list
16:10:44 <zipper> Is a function a haskell subroutine?
16:10:56 <zipper> If so which other subroutines exist?
16:14:15 <arkeet> a function is a function
16:21:52 <zipper> arkeet: The wikipedia page says a function can be called a subroutine
16:22:17 <arkeet> I don't know what page you're looking at, but we don't call anything a subroutine in haskell.
16:24:19 <srhb> zipper: function tends to be much more specific, even more so in Haskell than in other languages, so it is the better term, whereas subroutine is wishy washy.
16:24:44 <Cale> alex_ndc: Any text editor you like will do so long as it'll convert tabs to spaces automatically, and preserve an indentation level :)
16:25:03 <geekosaur> "subroutine" was more for languages like old BASIC
16:25:11 <mjrosenb> if I have foo :: IO (Ptr Int), and I execute this twice, then haskell will always consider these two distinct values, even if the address returned happened to be the same, correct?
16:25:39 <Cale> mjrosenb: What?
16:26:00 <Cale> mjrosenb: There's a notion of equality on Ptr values
16:26:15 <Cale> You can test to see if the results of executing foo twice are equal or not.
16:26:23 <Cale> and they may indeed be equal
16:26:39 <Cale> But I don't really understand what it is that you're asking
16:26:59 <Cale> Yes, the results might not be the same, so you shouldn't assume automatically that they are.
16:26:59 <zipper> The new look last.fm
16:27:53 <mjrosenb> Cale: Let's say I then use unsafePerformIO . peek on those two values, I know that nothing will write into it, so it should be safe, but I want to make sure the compiler won't collapse two different Ptr Int s into one because they happened to point to the same address.
16:28:15 <c_wraith> mjrosenb: uh.  Ptr a is *exactly* the same thing as a C pointer
16:29:08 <zipper> srhb: What can a subroutine be?
16:29:13 <zipper> Anything close?
16:29:56 <Cale> mjrosenb: Why would that be an issue?
16:30:45 <srhb> zipper: Lots of things. Nothing in Haskell.
16:31:04 <Cale> mjrosenb: If two Ptr Ints are equal, then sharing the memory used for them shouldn't do any harm, and the action resulting by applying peek would be the same either way
16:31:23 <zipper> srhb: There are no subroutines in haskell? WOW maybe I should add that to the wikipedia page but I don't know enough.
16:31:26 <Cale> mjrosenb: The compiler may or may not store arbitrarily many copies of any given value.
16:31:42 <srhb> zipper: No. Don't. The term is mostly unused nowadays.
16:31:42 <mjrosenb> c_wraith: right, so if I have mkVal :: IO (Ptr Int); x <- mkVal; let xx = unsafePerformIO (peek x); {- x gets gc'ed, -} y <- mkVal; {- y has the same address as x -} yy <- unsafePerformIO (peek y); it'll actually peek twice.
16:31:53 <kadoban> Wouldn't a    f :: a -> IO () -- be a subroutine ?
16:31:54 <srhb> zipper: And each language has their own notion of what a subroutine, method, function, ... is
16:32:44 <Cale> mjrosenb: In particular, the copy collector can be expected to come along and copy your Ptr Int to another place in memory, so you can't even assume that for a single variable x bound to the Ptr Int, that x actually refers to a unique location in memory where the Ptr Int is stored.
16:33:25 <Cale> (but this seems irrelevant to the behaviour of your program, even in the face of unsafePerformIO
16:33:26 <Cale> )
16:34:24 <mjrosenb> Cale: I'm fine with that (I think).  but the copy collector can only move x if it was allocated by the haskell runtime, right?
16:34:42 <Cale> Well, it was.
16:35:20 <zipper> srhb: Thanks
16:35:38 <Cale> If it's bound to a Haskell variable, then it was allocated by the Haskell runtime. The memory pointed to by the Ptr Int might have been allocated by something else, but that's... not what we're talking about?
16:36:38 <Cale> But then, maybe you wanted to be talking about that instead :)
16:37:03 <mjrosenb> Cale: err, I was talking about the pointers x, and y, rather than the addresses that x and y were stored at.
16:37:46 <Cale> In the code to your message to c_wraith, it'll almost certainly peek twice.
16:38:18 <Cale> assuming that xx and yy are ever evaluated
16:38:29 <Cale> It may peek 0 times of course
16:39:00 <Cale> It's also technically allowed to peek more than once if xx gets used in multiple locations, because the definition of xx may be inlined.
16:39:20 <Cale> (you may want to turn off inlining for xx if that worries you)
16:39:47 <Cale> I would do everything in my power to avoid having to use unsafePerformIO like you're using it there
16:42:37 <Cale> mjrosenb: But one thing I don't quite understand is why you're concerned that if x and y happen to be the same Ptr Int whether it peeks the location once or twice?
16:42:51 <Cale> mjrosenb: If the unsafePerformIO was supposed to be safe after all, then you ought not to care.
16:43:06 <Cale> mjrosenb: Because it may peek that location multiple times even if you only have one Ptr Int
16:47:00 <Cale> If you apply unsafePerformIO to an IO action, you should assume that you've just given the program permission to execute that action randomly as often as it wants, and the permission to fail horribly if the result of that action is ever different. In practice, it will tend to not execute the action too many times, and the variable will usually get bound to the result of executing it once, and then remain the same there
16:47:00 <Cale> after, but your program is not allowed to rely on this.
16:51:40 <ozgura> If anyone is experienced with Shelly, please help. I was using setStdin+run without any problems, but switched to setStdin+runHandle to have more control (streaming) on stdout
16:51:53 <ozgura> setStdin doesn't seem to work with runHandle 
16:51:58 <ozgura> any ideas?
16:52:21 <tempname11_> Cale: hmm, doesn't 'unsafePerformIO x' only ever execute the action once, on evaluation of the expression?
16:52:47 <tempname11_> you said "not too many times" and I started wondering if there ever was more than 1
16:53:01 <mjrosenb> Cale: because mkVal mallocs an Int, writes into the newly allocated memory, then returns it, with a finalizer that frees it.
16:53:21 <Cale> tempname11_: Ideally, however, the inliner might inline the definition in which you used unsafePerformIO, effectively causing the expression to be evaluated multiple times.
16:53:38 <tempname11_> Cale: inlining... gotcha
16:53:41 <mjrosenb> Cale: when it returns the second time, the malloc may return the 4 bytes of memory, but with a different value in it.
16:54:34 <geekosaur> ozgura, use runHandles
16:54:44 <geekosaur> runHandle ignores the stdin setting, as you found
16:55:36 <ozgura> geekosaur: let me have a look
16:55:44 <ozgura> (at runHandles)
16:56:29 <geekosaur> I may have misunderstood what runHandle is doing though
16:56:47 <Lokathor> if i have 64-bit ghc, can i stil compile a 32-bit program, or does every program it compiles end up a 64-bit program?
16:56:59 <geekosaur> the latter
16:57:23 <Lokathor> Hmm... are there strong advantages to going 64-bit then?
16:58:06 <ozgura> geekosaur: runHandles doesn't seem to work either
16:58:21 <ThermalSpan> Hello! Is this an acceptable place for entry level questions? If not where should I go?
16:58:33 <ozgura> I tried "liftIO $ hPutStr stdin someString" inside the handler
16:58:38 <ozgura> but no luck
16:58:43 <geekosaur> ummmm
16:58:46 <Hijiri> this is a good place for any haskell questions that are good somewhere
16:58:47 <Hijiri> I think
16:59:11 <Lokathor> ThermalSpan, you can try here, you can also try #haskell-beginners 
16:59:55 <ozgura> this shouldn't be so hard :(
17:00:44 <ozgura> Shelly.run works, but doesn't let me lazily consume stdout
17:01:11 <ozgura> runFoldLines is supposed to help with that but the FoldCallBack isn't monadic
17:01:35 <ozgura> and runHandle doesn't seem to support stdin
17:02:00 <Welkin> what si shelly?
17:02:02 <Welkin> is*
17:02:08 <Welkin> a haskell shell?
17:03:03 <haasn> Welkin: it's an EDSL for writing â€œshell-styleâ€ scripts in Haskell
17:03:09 <haasn> eg. calling programs, piping their output, etc. with little overhead
17:04:29 * hackagebot highlighting-kate 0.6 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.6 (JohnMacFarlane)
17:09:34 <DoubleWeasel> is (<=) over the natural numbers a category? it would have id = k <= k and composition is the transitive property
17:09:53 <jasonkuhrt> If I want to know about using Haskell to write OSX apps where should I go?
17:10:09 <johnw> DoubleWeasel: that's the Pos category, of posets in general
17:10:28 <DoubleWeasel> johnw: ok thanks
17:11:45 <Hijiri> I thought Pos was the category where the morphisms were poset homomorphisms and the objects are posets
17:11:54 <maxx> 32 or 64 bit ghc on 64 bit windows? how  good is the 64 bit version?
17:12:01 <Hijiri> and the category described by weasel is a poset category
17:12:05 <johnw> Hijiri: oh, maybe that, right
17:13:50 <Welkin> maxx: Nintendo 64
17:13:56 <maxx> 64 bit version is relatively new, so it may have some issues compared to the 32 bit version?
17:21:41 <ThermalSpan> Cool, thanks. In the Control.Monad module, whats the 'P' instance of MonadPlus for? Or do? Or where would I go to see what it does?
17:28:53 <dmwit> Is there something akin to an `instance (Monad m, Monoid a) => Monoid (m a)` (with appropriate newtype wrapping) somewhere?
17:29:35 <dmwit> So that I can write `foldMap :: (Foldable t, Monad m, Monoid a) => t (m a) -> m a`...
17:29:59 <dmwit> or fold :: that or whatever
17:32:56 <johnw> dmwit: why not just use MonadPlus?
17:33:21 <dmwit> I'm listening.
17:33:41 <johnw> i mean, it treats monad actions in a monoidal fashion, a `mplus` b
17:33:52 <dmwit> I want to treat the returned values in a monoidal fashion.
17:34:17 <dmwit> (not the actions themselves)
17:34:19 <johnw> ah
17:34:25 <johnw> you mean liftM2 (<>)?
17:34:31 * hackagebot haskell-neo4j-client 0.3.1.2 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.3.1.2 (asilvestre)
17:34:37 <dmwit> :t \v -> fold <$> sequenceA v
17:34:38 <lambdabot> (Applicative f, Traversable t, Monoid b) => t (f b) -> f b
17:35:11 <johnw> :t \v -> fold <$> sequence v
17:35:12 <lambdabot> (Monad f, Traversable t, Monoid b) => t (f b) -> f b
17:36:07 <dmwit> I'm just wondering if I can use fold directly, without the sequence first, if I pay the newtype price.
17:47:25 <zipper> @seen bernzf
17:47:25 <lambdabot> I haven't seen bernzf.
17:47:35 <zipper> Is that the right nick?
17:47:41 <johnw> benzrf
17:47:43 <pacak> @seen lambdabot
17:47:43 <lambdabot> Yes, I'm here. I'm in ##harmless, #fp@nith, #lpmc, #lysa, #learnmath, ##scalaz, #vinyl, #aurapm, #plaimi, ##megaharem, #lw-prog, #bfpg, #nicta-course, ##categorytheory, #hledger, #ledger, #csa_uva, #tanuki, ##villagegreen, #hscraft-srv, #esoteric, ##manatee, #unicycling, #scannedinavian, #mainehackerclub, #scala, #rosettacode, #macosx, #scalaz, #
17:47:43 <lambdabot> functionaljava, #jtiger, ##crypto, #jhc, #happs, #ghc, #gentoo-uy, #fedora-haskell, #gentoo-haskell, #friendly-coders, #macosxdev, #haskell-game, #haskell-freebsd, #dreamlinux-es, ##proggit, #learnprogramming, #learnanycomputerlanguage, #darcs, #archlinux-haskell, #haskell-arcade, ##logic, #yi, #numerical-haskell, #snapframework, #diagrams, #
17:47:43 <lambdabot> xmonad, #agda, #hackage, #haskell-beginners, #haskell-cn, #haskell-by, #haskell-id, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.it, #haskell.hr, #haskell-fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-br, #haskell-pl, #haskell.tw, #haskell.au, #haskell-llvm, #haskell-soc, #haskell-gsoc,
17:47:43 <lambdabot>  #haskell-overflow, #haskell-in-depth, #haskell-books, #haskell-blah, #haskell-infrastructure, #haskell-lens and #haskell
17:47:48 <pacak> o_o
17:48:07 <geekosaur> @seen benzrf
17:48:07 <lambdabot> benzrf is in #learnmath, #haskell-beginners, #haskell-blah, #haskell-lens and #haskell..
17:48:25 <kadoban> Hah â€¦
17:48:37 <benzrf> oh hi
17:48:39 <benzrf> whats up
17:49:05 <benzrf> zipper: why'd you @seen me o.O
17:49:57 <zipper> benzrf: Uh haskell-blah just for a moment.
17:51:30 <hiptobecubic> unicycling?
17:51:44 <hiptobecubic> "functionaljava"
17:51:51 <hiptobecubic> what a list
17:53:27 <Cale> @seen dons
17:53:28 <lambdabot> Last time I saw dons was when I left ##english, ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-in-depth, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.
17:53:28 <lambdabot> dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosx, #macosxdev, #novalang, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling, #xmonad and #yi 6y 5m 26d 20h 7m 8s ago.
17:53:29 <geekosaur> unicycling would be shapr's fauult iirc
17:57:08 <shapr> geekosaur: oops
17:57:16 <edwardk> hiptobecubic: #uncycling was one of the obsessions of an early channel founder, shapr.
17:57:23 <shapr> oh hai edwardk
17:57:25 <geekosaur> someone was just wondering why it was in lb;s list
17:57:35 <edwardk> He has a bunch of pictures of famous computer scientists riding his unicycle.
17:57:42 <shapr> It's true, I do
17:57:45 <hiptobecubic> Nice
17:58:15 <hiptobecubic> I didn't realize unicycling was so popular amongst famous computer scientists
17:58:15 <edwardk> anyways back before lambdabot was in more than say 3-4 channels, #unicycling was added
17:58:39 <edwardk> hiptobecubic: i think most of them are gripping shapr or a handrail for dear life
17:58:46 <shapr> that is also true
17:58:51 <shapr> Although SPJ did just fine
17:59:07 <edwardk> he even got me up on the damn thing, but never took a picture that i know of
17:59:30 <edwardk> (shapr has a monster of a unicycle lying around, with something like a 30 inch tire or something insane)
17:59:50 <shapr> well, I think it's just over 29 inches
17:59:51 <edwardk> designed for chasing snowmobiles near the arctic circle and riding down mountains on his junk.
17:59:57 <shapr> ok, that part is accurate
18:01:22 <pavonia> Isn't that huge channel list basically foiling the +i user mode?
18:01:30 <hiptobecubic> I almost got unicycled the other day. Some guy was pedaling furiously and apparently could not steer very well.
18:07:53 <zipper> arkeet: So uh I get it in your example that's for sure but in the code I pasted I have a contention.
18:08:55 <zipper> arkeet: How does f x give a value of Writer (y, v')? it doesn't. Only (f x, v `mappend` v') can
18:09:03 <arkeet> yes it does.
18:09:10 <arkeet> what's the type of f?
18:09:29 <zipper> arkeet: (a -> m a)
18:09:35 <arkeet>  (for context for everyone else, zipper is trying to understand the Writer monad
18:09:38 <arkeet> 00:58:52 < zipper> `(Writer (x,v)) >>= f = let (Writer (y, v')) = f x in Writer (y, v `mappend` v')  `
18:09:43 <arkeet> zipper: what's m?
18:10:01 <arkeet> also, what's the definition of Writer?
18:10:12 <zipper> Writer (a, w)
18:10:23 <arkeet> that's not a definition
18:10:48 <zipper> newtype Writer  w a = Writer {runWriter :: (a,w)}
18:11:04 <arkeet> ok
18:11:06 <arkeet> so what's m?
18:11:53 <zipper> arkeet: Hmmm Writer?
18:12:13 <arkeet> not just writer.
18:12:17 <arkeet> I guess you're looking at something like
18:12:23 <arkeet> instance Monoid w => Monad (Writer w) where ...
18:13:31 <arkeet> :t (>>=)
18:13:32 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:13:45 <arkeet> so for Monad m you have Monad (Writer w)
18:13:47 <zipper> arkeet: I get it
18:13:47 <arkeet> so m is Writer w'
18:13:52 <arkeet> okay.
18:14:04 <arkeet> so now I can ask again
18:14:06 <arkeet> what's the type of f?
18:14:09 <zipper> w is the part to mappend
18:14:59 <zipper> arkeet: (a -> Writer w a)
18:15:03 <arkeet> right.
18:15:20 <arkeet> so whatever f x is, it has type Writer w a.
18:15:32 <zipper> So x in the case of f x refers to thw whole of the Writer
18:15:52 <zipper> I thought it was referring to the first value fo the tuple
18:16:05 <arkeet> :)
18:16:07 <zipper> arkeet: Ah much thanks.
18:18:34 <zipper> arkeet: However which two Vs are we mappending here?
18:18:53 <zipper> arkeet: I'll assume f comes with it's own v
18:19:10 <arkeet> where do you see v and v' bound?
18:20:21 <zipper> arkeet: Bound?
18:20:49 <arkeet> like
18:20:51 <zipper> Oh
18:20:53 <zipper> I get it
18:20:55 <arkeet> ok
18:21:00 <zipper> Maybe I'm sleepy
18:21:13 <zipper> or maybe it's written in one line
18:21:44 <zipper> arkeet: Thanks
18:21:50 <zipper> arkeet: Good night.
18:22:50 <motilio> good morning
18:23:19 <kadoban> good evening
18:23:36 <motilio> beginning to learn haskell
18:23:47 <motilio> so far, so different to anything previous
18:24:00 <motilio> any resources you can recommend?
18:24:12 <motilio> i'm reading learnyouahaskell.com
18:24:20 <arkeet> @where learnhaskell
18:24:20 <lambdabot> https://github.com/bitemyapp/learnhaskell
18:24:32 <arkeet> learnyouahaskell isn't really recommended these days
18:24:46 <motilio> really?
18:24:55 <arkeet> for starters it doesn't have any exercises.
18:25:17 <motilio> ok
18:26:06 <motilio> github learnhaskell has a freenode channel
18:26:16 <motilio> will go there
18:26:18 <motilio> thanks a lot
18:31:45 <Cale> motilio: You can also feel free to ask beginner questions here though :)
18:32:41 <motilio> thanks Cale
18:34:37 <motilio> the main difference I see with other languages are monads
18:35:06 <motilio> they are used a lot more than in scala or lisp
18:35:13 <DrPavelheer> Also, purity
18:35:46 <Hijiri> I'd say purity is the bigger difference
18:35:53 <motilio> how so?
18:35:58 <motilio> 100% functional?
18:36:03 <DrPavelheer> Well, functions can't access any outside variables
18:36:09 <DrPavelheer> well
18:36:11 <DrPavelheer> no
18:36:17 <Hijiri> well, you could write monads in many languages, but purity can't be enforced without adding new language constructs
18:36:28 <DrPavelheer> they CAN, but you can't change any of those variables
18:36:52 <Hijiri> Evaluating an expression will give you the same result every time
18:36:56 <Hijiri> it will also not perform any IO
18:37:04 <Hijiri> (beyond heating your computer and taking memory etc.)
18:37:16 <motilio> hahaha
18:38:04 <motilio> so, purity means that monads are part of the language?
18:38:31 <Hijiri> monads aren't a core part of the language
18:38:36 <Hijiri> they're part of the standard library
18:38:42 <Hijiri> they're implemented in haskell
18:38:52 <Hijiri> also purity doesn't have much to do with monads
18:39:16 <Hijiri> "Monad" is just a convenient interface to a lot of things, including IO
18:39:25 <geekosaur> monads aren't actually very special
18:39:26 <DrPavelheer> purity means that if you run a function with the same input every time, you will always get the same output every time
18:39:32 <geekosaur> IO is weird because it is IO
18:39:39 <DrPavelheer> barring IO
18:39:48 <Hijiri> functions don't do IO
18:39:50 <Hijiri> IO isn't functions
18:40:29 <DrPavelheer> example in java
18:40:31 <Hijiri> things of type "IO a" are more like scripts written in another language (that you can't examine)
18:40:58 <DrPavelheer> int addTwoA(int x) { return x + a; }
18:41:05 <DrPavelheer> a = 5
18:41:12 <DrPavelheer> addTwoA(5) = 10
18:41:16 <DrPavelheer> a = 7
18:41:20 <DrPavelheer> addTwoA(5) = 12
18:41:34 <DrPavelheer> in Haskell, a can only be defined once
18:41:37 <DrPavelheer> a = 5
18:41:45 <DrPavelheer> addTwoA(5) = 10, no matter what
18:41:56 <arkeet> variables are *defined*, not assigned.
18:42:05 <motilio> so, functions never have side effects
18:42:09 <arkeet> when you write a = 5
18:42:11 <DrPavelheer> right. "variables" are really functions
18:42:15 <arkeet> a is 5 everywhere, for all time.
18:42:15 <DrPavelheer> in a sense
18:42:31 <arkeet> no, they're not functions.
18:42:34 <arkeet> (unless they are.)
18:43:15 <DrPavelheer> not functions. but you define them like functions
18:43:31 <P1RATEZ> immutable variables
18:43:36 <m_ryan> > words $ unwords " HELLO WORLDS "
18:43:37 <lambdabot>      Couldn't match type â€˜Charâ€™ with â€˜[Char]â€™
18:43:38 <lambdabot>      Expected type: [String]
18:43:38 <lambdabot>        Actual type: [Char]
18:43:41 <P1RATEZ> hah
18:44:05 <arkeet> I mean 
18:44:06 <DrPavelheer> > unwords " HELLO WORLDS "
18:44:07 <lambdabot>      Couldn't match type â€˜Charâ€™ with â€˜[Char]â€™
18:44:07 <lambdabot>      Expected type: [String]
18:44:07 <lambdabot>        Actual type: [Char]
18:44:10 <arkeet> you can define a different variable called a
18:44:15 <arkeet> with a different value/type
18:44:20 <arkeet> but that's a different variable
18:44:29 <arkeet> m_ryan: think you got unwords and words backwards.
18:44:33 <lyonsb> > words "Hello worlds!"
18:44:34 <lambdabot>  ["Hello","worlds!"]
18:44:35 <pacak> > unwords $ words "hello worlds"
18:44:36 <lambdabot>  "hello worlds"
18:44:38 <DrPavelheer> oh, that's right isn't it
18:44:48 <DrPavelheer> > words " HELLO WORLDS "
18:44:50 <lambdabot>  ["HELLO","WORLDS"]
18:44:50 <m_ryan> arkeet: sorry
18:44:52 <pacak> > unwords $ words "   hello     worlds  "
18:44:53 <lambdabot>  "hello worlds"
18:45:15 <arkeet> no apologies needed :-)
18:45:34 <motilio> i need to learn a lot, i think will go to #haskell-beginners :)
18:45:36 <lyonsb> If f(x) = 5, it has a range of { -inf, inf }, and for any value of x, returns the value of 5.
18:45:51 <lyonsb> (wait, I think I meant domain and not range)
18:46:03 <lyonsb> (yes I did)
18:46:57 <arkeet> it has a domain of
18:47:06 <arkeet> whatever values the type of x has.
18:47:11 <arkeet> (need not be a number type)
18:47:41 <lyonsb> corrected: f(x) = 5 for all x such that f(-inf) = 5, to f(inf) = 5, and all reals in between -inf and inf, f(x) would also return 5.
18:47:43 <arkeet> :t let f x = 5 in f
18:47:44 <lambdabot> Num a => t -> a
18:47:54 <arkeet> lyonsb: is that haskell?
18:48:18 <arkeet> (inf and -inf aren't real numbers btw)
18:48:38 <motilio> thanks to all
18:49:52 <lyonsb> just math.  I think the idiom would be that variable assignment never actually occurs in haskell, only evaluation of functions -- but I might be wron gon that too (still beginner)
18:51:20 <lyonsb> -- the upshot of that statement being that a function f can be defined such that any evaluation of f results in 5.
18:51:59 <verement> > let f x = 5 in f undefined
18:52:00 <lambdabot>  5
18:52:10 <lyonsb> evaluation of f with any x.
18:52:18 <lyonsb> > let x = 5
18:52:19 <lambdabot>  <no location info>: not an expression: â€˜let x = 5â€™
18:56:50 <lyonsb> > f 10
18:56:52 <lambdabot>      No instance for (Show a0)
18:56:52 <lambdabot>        arising from a use of â€˜show_M591299636777318456025933â€™
18:56:52 <lambdabot>      The type variable â€˜a0â€™ is ambiguous
18:57:10 <arkeet> :t f
18:57:11 <lambdabot> FromExpr a => a
18:57:35 <lyonsb> f 5
18:57:40 <lyonsb> > f 5
18:57:41 <lambdabot>      No instance for (Show a0)
18:57:41 <lambdabot>        arising from a use of â€˜show_M855153930558116411225961â€™
18:57:41 <lambdabot>      The type variable â€˜a0â€™ is ambiguous
18:57:56 <arkeet> f isn't f x = 5
18:58:00 <arkeet> (it's something predefined in lambdabot)
18:58:33 <lyonsb> "in f undefined" changes the definition of f for that particular evaluation?
18:58:37 <dmwit> > f 5 :: Expr
18:58:39 <lambdabot>  f 5
18:59:01 <arkeet> let-in makes a local binding
18:59:18 <arkeet> > let x = 2 in (let x = 10 in x) + x
18:59:20 <lambdabot>  12
19:00:11 <lyonsb> Got it.
19:09:24 <buttbutter> What am I doing wrong here? (Defining own list type, data constructor issue): http://lpaste.net/133403
19:10:13 <c_wraith> buttbutter: the pattern on line 8 is wrong
19:10:23 <c_wraith> buttbutter: It should just be (Cons a as)
19:10:42 <buttbutter> c_wraith: Why?
19:10:46 <c_wraith> buttbutter: you match the constructor and give names to each field of the constructor.  The types of the fields don't matter.
19:11:10 <c_wraith> buttbutter: if you've seen other examples listing multiple constructors, it's because they're doing nested matches.
19:11:11 <buttbutter> Ah. That makes sense.
19:11:44 <buttbutter> I'm also just confused about "Cons" in general. It's a data constructor...but it becomes part of the list too, if that makes sense.
19:12:04 <buttbutter> That is, a List a looks like Cons 5 (Cons 4 (Cons 3( Nil)))
19:12:16 <buttbutter> That's sort of a confusing notion for me.
19:12:35 <c_wraith> buttbutter: It's just nested function application.
19:13:08 <c_wraith> buttbutter: it's not really any different that 5 + (4 + (3 + 2))
19:13:08 <buttbutter> So a data constructor is just a function, that given some inputs, produces a type?
19:13:11 <buttbutter> In this case, a list type?
19:13:22 <c_wraith> buttbutter: well, it produces a value of a specific type.
19:13:30 <buttbutter> Ah, right. 
19:13:39 <buttbutter> Okay. That makes sense. Thanks for your help c_wraith.
19:13:52 <c_wraith> buttbutter: I'm being slightly pedantic on the terminology, but that's because it does help in the long run. :)
19:14:03 <buttbutter> It's good to be precise :D
19:16:54 <buttbutter> Uh, totally different issue. But ghci keeps giving me a "*** Exception: <interactive>: canonicalizePath: does not exist (No such file or directory)
19:17:06 <buttbutter> Randomly when I try to type ":edit myfile"
19:17:19 <buttbutter> And I have to restart ghci and then it works again. but after a few edits,it always throws that error.
19:17:22 <buttbutter> Any idea why?
19:17:40 <c_wraith> that one's beyond me, but there are good 1471 other people who might know. :)
19:17:56 <buttbutter> Okay :D
19:29:22 <joneshf-laptop> so i've seem multiple people suggest that good haskell design begins with describing the data types
19:29:35 <joneshf-laptop> however, that has seemed to lead me into trouble
19:29:52 <joneshf-laptop> is a better way to first think of the functions you'll need?
19:30:14 <joneshf-laptop> and then let the data types fall from there?
19:30:46 <joneshf-laptop> obviously neither should be in complete isolation of the other
19:30:55 <tsani> I'm using the hackage-db package to do some statistics of dependencies on Hackage. An issue I'm getting is that the buildDepends field of PackageDescription. Is hackage-db broken/outdated? If so, how should I go about getting a list of dependencies for each package in hackage.
19:30:56 <joneshf-laptop> but more focus on the functins initially
19:31:03 <c_wraith> joneshf-laptop: I often start with data type *names* and functions.
19:31:21 <c_wraith> function *types* that is
19:31:32 <c_wraith> Then I fill in definitions of each as I see how they need to fit together.
19:32:01 <jmcarthur> when i can think of a way, i start with a model. this guides the rest of my specification.
19:32:17 <joneshf-laptop> c_wraith, i see, how has this fared for you?
19:32:33 <joneshf-laptop> jmcarthur, what about when you can't initially see some model?
19:32:38 <joneshf-laptop> jmcarthur, what do you do then?
19:32:42 <c_wraith> joneshf-laptop: It works, but you need to be willing to continue to aggressively refactor even after passing 20k lines. :)
19:33:14 <jmcarthur> joneshf-laptop: well, i can usually come up with some model, it's just that some are complicated :\
19:33:29 <joneshf-laptop> c_wraith, how agressively are we talking here?
19:33:32 <jmcarthur> joneshf-laptop: ideally it's simple, and it's worth trying hard to make it simple.
19:34:15 <jmcarthur> joneshf-laptop: but the more i think about it, the more i realize the model really drives most of my development even in reality, not just in theory
19:34:21 <c_wraith> joneshf-laptop: Minor changes to 10% of the lines in 80% of the files was common
19:35:59 <joneshf-laptop> jmcarthur, so then, how do you find the model?
19:39:18 <jmcarthur> joneshf-laptop: that's where the challenge is. practice is all i know to say. to get better, start with simple things and work toward more complex things (or for extra points, make them simple too).
19:40:17 <jmcarthur> joneshf-laptop: so an example of a simple model is the natural numbers. one can imagine quite a few different kinds of implementations, all satisfying the same model.
19:40:27 <jmcarthur> joneshf-laptop: maybe something a bit more complex is some sort of state machine
19:41:24 <jmcarthur> joneshf-laptop: again, there are many ways to implement state machines, but recognizing them as such as generally helpful.
19:41:53 <jmcarthur> joneshf-laptop: and knowing the model can lead you toward things you wouldn't have thought of otherwise, such as how state machines can be composed, etc.
19:43:20 <jmcarthur> joneshf-laptop: but really the hard part isn't invention arbitrary models, it's recognizing such a pattern in your problem domain
19:43:25 <jmcarthur> *inventing
19:47:39 <m_ryan> hi why does you cannot use "<-" inside the if-else condition of haskell?
19:48:31 <c_wraith> m_ryan: <- is part of do blocks.  You can only use it as a statement inside a do block.
19:49:49 <m_ryan> c_wraith: what if like this? if 1 == 1 then let x = do z <- y
19:50:26 <c_wraith> m_ryan: the then and else expressions in an if must be *expressions*
19:50:39 * geekosaur has no idea what that if is supposed to even mean
19:51:33 <steshaw> Could you please provide input on this quick Haskell program. I'd like to know if there are better or more idiomatic ways of doing things. https://gist.github.com/steshaw/09a073572556777f89d4
19:52:20 <johnw> I'm pretty sure that symbol '+' will ignore spaces around it
19:52:47 <m_ryan> c_wraith: here it is, http://lpaste.net/133406
19:52:58 <c_wraith> steshaw: is that complete?  I can't see where you're ever using int
19:54:29 <steshaw> c_wraith: in `expr`
19:54:54 <steshaw> c_wraith: maybe I should reorder those declarations for starters :)
19:55:00 <c_wraith> steshaw: oh, there it is.  I don't think a single use is worth assigning a name that does nothing other than echo the imported name. :)
19:56:05 <steshaw> c_wraith: I understand. It's also supposed to be an example for beginners. Do it go too far considering that?
19:57:03 <c_wraith> steshaw: considering that it's *just* a minimal rename, I think it doesn't add any real clarity.  If it was any sort of more complex expression, I wouldn't say anything.
19:58:21 <steshaw> c_wraith: I'm removing the qualified import and using `int` directly from the module
19:59:10 <c_wraith> m_ryan: I'm not sure quite how to make this work.  What's the type of qryCityLatestAvgPrices  ?
19:59:54 <m_ryan> c_wraith: its a Handler Handler [RawLatestAvgPrices]
20:00:37 <c_wraith> m_ryan: that only makes sense if Handler is a type alias..  Can you expand it?
20:00:59 <m_ryan> c_wraith: what do you mean by expanding?
20:01:25 <c_wraith> m_ryan: can you tell me what the definition of Handler is?
20:02:04 <m_ryan> ok i will paste the code again. i not good in explaining directly. 
20:07:57 <m_ryan> c_wraith: here is the code, http://lpaste.net/133406
20:08:48 <DrPavelheer> hmm.
20:09:02 <Welkin> Handler is a Yesod type
20:10:31 <c_wraith> Oh, I see.  m_ryan let me re-ask..  What is the type of qryCityLatestAvgPrices ?  I need that to know what that should say
20:11:58 <m_ryan> c_wraith: the type is Handler [RawLatestAvgPrices]
20:12:11 <m_ryan> c_wraith: is that right?
20:12:16 <c_wraith> m_ryan: it can't be, if you're passing it arguments.
20:12:33 <Welkin> m_ryan: that is some strange looking yesod
20:12:37 <Welkin> did you read the yesod book?
20:12:51 <Welkin> http://www.yesodweb.com/book
20:13:01 <m_ryan> Welkin: yes.
20:13:07 <steshaw> I made some improvements to my simple interpreter https://gist.github.com/steshaw/09a073572556777f89d4
20:13:47 <steshaw> I'm a bit concerned that the following code is not idiomatic: args `forM_` ((\s -> putStr " - " >> putStrLn s) . showResult . runExpr)
20:14:11 <steshaw> Seems a lot of brackets and an explicit lambda
20:14:21 <m_ryan> Welkin: well im new to yesod so maybe my code was not very clean. :)
20:14:54 <c_wraith> m_ryan: I'm guessing http://lpaste.net/133410 is more likely to compile
20:17:28 <m_ryan> c_wraith: thanks it all correct now. and instead of then you add do. i don't know that it is also possible :) thanks anyways
20:17:29 <c_wraith> steshaw: I'd write it with a do block, but that's just me. :)
20:17:40 <bitemyapp> > (\s -> putStr " - " >> putStrLn s) "bwahahahaha"
20:17:42 <lambdabot>  <IO ()>
20:17:59 <bitemyapp> > (\s -> putStrLn (" - " ++ s)) "bwahahahaha"
20:18:00 <lambdabot>  <IO ()>
20:18:02 <c_wraith> m_ryan: well, the contents of each branch of the if/then/else must be expressions - and do blocks are expressions
20:18:06 <bitemyapp> @pl (\s -> putStrLn (" - " ++ s)) "bwahahahaha"
20:18:06 <lambdabot> putStrLn " - bwahahahaha"
20:18:17 <bitemyapp> @pl (\s -> putStrLn (" - " ++ s))
20:18:17 <lambdabot> putStrLn . (" - " ++)
20:18:25 <bitemyapp> smartass bot.
20:18:30 <m_ryan> c_wraith: noted.
20:19:10 <c_wraith> m_ryan: also, note that I used <- on the result of the whole if, rather than a let.
20:19:10 <bitemyapp> steshaw: there's a minor improvement. From there, the only odd part would be using forM_ instead of mapM_ and using it in infix.
20:19:39 <bitemyapp> steshaw: other than adding type signatures, everything else seems quite good to me.
20:19:54 <m_ryan> c_wraith: notice that also. because of do we can now use the <-. :)
20:20:17 <c_wraith> m_ryan: it's not about the do inside - it's just about the types.
20:21:10 <c_wraith> m_ryan: though the types are the same reason it's valid to put the do inside...  So I guess it's related, but I consider the causality going the other direction.
20:21:26 <m_ryan> c_wraith: got it.
20:39:42 * hackagebot linearscan 0.6.0.0 - Linear scan register allocator, formally verified in Coq  http://hackage.haskell.org/package/linearscan-0.6.0.0 (JohnWiegley)
20:39:44 * hackagebot linearscan-hoopl 0.6.0.0 - Makes it easy to use the linearscan register allocator with Hoopl  http://hackage.haskell.org/package/linearscan-hoopl-0.6.0.0 (JohnWiegley)
20:41:07 <steshaw> bitemyapp: thanks, I'll give `mapM_` a shot
20:43:15 <bitemyapp> steshaw: forM_ is mapM_ flipped, so your function goes first, data second. Like map.
20:43:48 <steshaw> bitemyapp: ok
20:44:42 * hackagebot base32string 0.9.0 - Fast and safe representation of a Base-32 string  http://hackage.haskell.org/package/base32string-0.9.0 (solatis)
20:47:48 <albeit_> With ByteStrings, does it ever make sense to use writeRawBufferPtr? Just looking at fast-logger and wondering if it uses that instead of just ByteString.hPutStr
20:48:28 <albeit_> (Or just generally stuff in GHC.IO.FD)
20:51:01 <steshaw> bitemyapp: I've updated to use mapM_ https://gist.github.com/steshaw/09a073572556777f89d4. I couldn't help but extract a function for the lambda. Gotta run. Will check messages later
20:51:02 <albeit_> I guess what I'm asking is, what's the fastest way to write a bunch of bytes to a file, repeatedly?
20:51:45 <bitemyapp> steshaw: try incorporating what I showed you how to do with @pl.
20:52:02 <unb3k44n7> Evening, room.
20:52:05 <dfeuer> Ping carter carter_cloud 
20:59:43 * hackagebot extensible-effects 1.11.0.0 - An Alternative to Monad Transformers  http://hackage.haskell.org/package/extensible-effects-1.11.0.0 (shergill)
21:05:38 <johnw> is anyone here using extensible-effects in real code?
21:05:52 <m_ryan> hi is possible to return a data in nothing on case expression e.g case data of Nothing -> return [1,2,3] Just listData -> return listData?
21:06:07 <johnw> m_ryan: certainly
21:06:19 <johnw> as long as it's a Num a => Maybe [a]
21:08:27 <m_ryan> johnw: you mean both of them will return a Maybe Type?
21:08:38 <johnw> that whole expression returns a list type
21:08:45 <johnw> i was talking about the type of 'data'
21:08:57 <johnw> actually, m [a]
21:10:03 <DrPavelheer> isn't it Maybe [a]?
21:10:17 <johnw> could be, doesn't have to
21:10:29 <johnw> i'd need more context to know the type of 'return'
21:11:06 <m_ryan> in my example it return both a list.
21:11:18 <johnw> it's returning a list in some Monad
21:11:22 <johnw> so the type is not just list
21:11:26 <johnw> it might be list of list, even
21:11:32 <johnw> :t return
21:11:33 <lambdabot> Monad m => a -> m a
21:11:48 <carter_cloud> dfeuer: sip
21:12:01 <carter_cloud> Sup
21:12:43 <dfeuer> Well, that's when the interviews are scheduled to begin. I expect I'll be at the coffee shop downstairs around 9:15ish.
21:12:58 <DrPavelheer> let typetest x = case x of {(Nothing) -> [1,2,3]; (Just listData) -> listData}
21:13:03 <dfeuer> er...
21:13:06 <DrPavelheer> > let typetest x = case x of {(Nothing) -> [1,2,3]; (Just listData) -> listData}
21:13:07 <lambdabot>  <no location info>:
21:13:07 <lambdabot>      not an expression: â€˜let typetest x = case x of {(Nothing) -> [1,2,3]; (J...
21:13:52 <DrPavelheer> > typetest x = case x of {(Nothing) -> [1,2,3]; (Just listData) -> listData}
21:13:53 <lambdabot>  <hint>:1:12: parse error on input â€˜=â€™
21:15:45 <m_ryan> > case x of {(Nothing) -> [1,2,3]; (Just listData) -> listData}
21:15:47 <lambdabot>      Couldn't match expected type â€˜Exprâ€™ with actual type â€˜Maybe t0â€™
21:15:47 <lambdabot>      In the pattern: Nothing
21:15:47 <lambdabot>      In a case alternative: (Nothing) -> [1, 2, 3]
21:16:14 <monochrom> what is the type of x? what is the type of listData?
21:17:01 <m_ryan> both of them will be a list.
21:17:16 <monochrom> that is simply not good enough
21:18:12 <m_ryan> what will be the syntax for that?
21:19:04 <monochrom> syntax is beside the point
21:19:07 <DrPavelheer> :t (\x -> case x of {(Nothing) -> [1,2,3]; (Just listData) -> listData})
21:19:09 <lambdabot> Num t => Maybe [t] -> [t]
21:19:47 <m_ryan> thanks :)
21:23:10 <pacak> > fromMaybe [1,2,3] $ Just [1]
21:23:12 <lambdabot>  [1]
21:24:48 <DrPavelheer> > let thisisatest = 5
21:24:49 <lambdabot>  <no location info>: not an expression: â€˜let thisisatest = 5â€™
21:25:02 <DrPavelheer> > define thisisatest = 5
21:25:04 <lambdabot>  <hint>:1:20: parse error on input â€˜=â€™
21:25:23 <DrPavelheer> hey, how do I do definitions with lambdabot?
21:25:36 <enthropy> @let test = 5
21:25:38 <lambdabot>  Defined.
21:25:42 <DrPavelheer> thanks.
21:29:53 <unb3k44n7> What does | do? I forgot.
21:30:54 <Feuerbach> unb3k44n7: depends on the context. probably a guard
21:31:07 <heatsink> > let f x | x > 0 = "greater" | x == 0 = "zero" | x < 0 = "less" in f (-100)
21:31:08 <lambdabot>  "less"
21:33:37 <unb3k44n7> Does a guard mean It's seperating things in a function
21:34:29 <unb3k44n7> Like heatsinks function there. It's seperating the x's?
21:34:41 <heatsink> It means that a boolean condition determines whether the right-hand side is used
21:34:43 <unb3k44n7> Or.. well It's seperating other things too,
21:35:02 <heatsink> In this case, x < 0 is true and the previous guard conditions are false
21:35:51 <heatsink> The result of the function call is the part after the guard that evaluated to true
21:36:44 <heatsink> f of x, if x > 0, is "greater"; if x == 0, is "zero"; and if x < 0, is "less".
21:38:16 <unb3k44n7> Ok. Ty.
21:47:07 <IgneNature> Can someone please explain me this line, what happens here (I dont get exactly how this line works, why y is taken from xs, (y==k) && (fst y>1),although task is to create proper tree of parten/child proccess out of flat list representation)...? getProcessTreeFromRoot k (x:xs) =
21:47:07 <IgneNature> [Process (a) (getProcessTreeFromRoot a xs)|a <- [fst y | y <- xs, (snd y == k) && (fst y > 1)]]  ... fst/snd are qsortfst/qsortsnd which are :  qsortFst [] = []
21:47:07 <IgneNature> qsortFst (x:xs) = qsortFst (filter (< x) xs) ++ [x] ++ qsortFst (filter (>= x) xs) ...which lead to sortList list = qsortSnd (qsortFst processes) ... --processes :: [(int, int)] ...
22:04:06 <Haskellfant> IgneNature: does your qsortFst actually work? it looks like your list is never getting shorter so you're stuck in endless recursion
22:07:50 <Haskellfant> ah no I just can't read
22:07:53 <Haskellfant> it's way too early
22:10:47 <igniting> > let qsortFst [] = []; qsortFst (x:xs) = qsortFst (filter (< x) xs) ++ [x] ++ qsortFst (filter (>= x) xs) in qsortFst [3, 1, 4, 2 -- Haskellfant 
22:10:49 <lambdabot>  <hint>:1:145:
22:10:49 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
22:10:57 <igniting> > let qsortFst [] = []; qsortFst (x:xs) = qsortFst (filter (< x) xs) ++ [x] ++ qsortFst (filter (>= x) xs) in qsortFst [3, 1, 4, 2] -- Haskellfant 
22:10:58 <lambdabot>  [1,2,3,4]
22:11:16 <Haskellfant> igniting: yeah I am just too tired to count parentheses
22:12:32 <zinfandel> Hmm. Is there something like `[(k, v)] -> Map k [v]` ?
22:12:47 <zinfandel> Or, I wish to have `fromListWith' :: (a -> b) -> (a -> b -> b) ->  [(k, a)] -> Map k b`
22:13:00 <igniting> IgneNature: I am not sure if fst/snd are qsortFst/qsortSnd
22:13:03 <zinfandel> So I could `fromListWith' (:[]) (:)`
22:16:49 <kadoban> So if I want a 2D Data.Vector.Vector, I guess I just make a Vector of Vectors?
22:17:09 <Haskellfant> :t foldr (\(a,x) acc -> insertWith (++) a [x] acc) empty
22:17:10 <lambdabot>     Not in scope: â€˜insertWithâ€™
22:17:11 <lambdabot>     Perhaps you meant one of these:
22:17:11 <lambdabot>       â€˜IM.insertWithâ€™ (imported from Data.IntMap),
22:17:25 <Haskellfant> zinfandel: that should do what you want but is pretty ugly
22:17:40 <Haskellfant> :t foldr (\(a,x) acc -> M.insertWith (++) a [x] acc) empty
22:17:42 <lambdabot> (Ord k, Foldable t, Alternative (M.Map k)) => t (k, a) -> M.Map k [a]
22:19:47 * hackagebot Win32-services-wrapper 0.1.3.0 - Wrapper code for making a Win32 service  http://hackage.haskell.org/package/Win32-services-wrapper-0.1.3.0 (GaneshSittampalam)
22:20:47 <zinfandel> Haskellfant: Yep, I've also came up with this, but I am not satisfied
22:21:06 <Haskellfant> understandable :)
22:21:14 <zinfandel> Haskellfant: Or even `fromListWith (++) . map (\(k,v) -> (k, [v]))
22:22:49 <Haskellfant> :t fromListWith (++) . map (\(k,v) -> (k, [v]))
22:22:51 <lambdabot>     Not in scope: â€˜fromListWithâ€™
22:22:51 <lambdabot>     Perhaps you meant one of these:
22:22:51 <lambdabot>       â€˜IM.fromListWithâ€™ (imported from Data.IntMap),
22:22:54 <Haskellfant> :t M.fromListWith (++) . map (\(k,v) -> (k, [v]))
22:22:55 <lambdabot> Ord k => [(k, a)] -> M.Map k [a]
22:23:02 <Haskellfant> apparently that actually exists :)
22:23:50 <zinfandel> Haskellfant: I am wondering is it bad int terms of efficiency
22:23:55 <Haskellfant> if that gets optimized it might not be much worse than the version (:)
22:24:10 <zinfandel> Yep, I also hope that list fusion would take place
22:27:26 <steshaw> bitemyapp: I've found a pointfree formulation. I tried mapM_ but I preferred forM_. See what you think https://gist.github.com/steshaw/09a073572556777f89d4
22:28:04 <steshaw> The expression in question becomes: args `forM_` (putStrLn . (" - " ++) . showResult . runExpr)
22:29:04 <steshaw> A revelation! Now I have: forM_ args $ putStrLn . (" - " ++) . showResult . runExpr
22:32:21 <timothyh> I have a bunch of FFI functions returning IO Bool, and I'd like to guard on all of them
22:32:23 <timothyh> what's the best approach?
22:32:43 <timothyh> as in, if any of them are false, I want the computation to fail. don't mind if that involves an exception
22:33:23 <mauke> (putStr . unlines . map ((" - " ++) . showResult . runExpr)) args
22:36:16 <gfixler1> The following packages are broken, either because they have a problem
22:36:18 <gfixler1> listed above, or because they depend on a broken package.
22:36:31 <gfixler1> that's the output of ghc-pkg check
22:36:34 <gfixler1> any way to clean up broken things?
22:38:27 <bitemyapp> gfixler1: which package db?
22:38:47 <gfixler1> bitemyapp: I didn't know there was more than one
22:40:55 <bitemyapp> gfixler1: does that mean you weren't using a sandbox either?
22:41:12 <gfixler1> I've been using them for awhile
22:41:17 <gfixler1> wasn't in the very beginning
22:41:21 <bitemyapp> gfixler1: there are potentially as many package databases as you could want, but the usual tiers are global, user, and then sandboxes which replace user.
22:41:22 <gfixler1> just nuked my .cabal folder
22:41:26 <bitemyapp> gfixler1: don't do that.
22:41:34 <bitemyapp> gfixler1: 1. the package-db doesn't live there 2. you just nuked your config
22:41:42 <gfixler1> bitemyapp: which config?
22:41:43 <bitemyapp> User package-db lives in ~/.ghc, not ~/.cabal
22:41:47 <bitemyapp> gfixler1: the configuration for Cabal.
22:41:58 <gfixler1> bitemyapp: is that something I would have config'd myself?
22:42:27 <gfixler1> (I don't think I ever config'd anything)
22:42:38 <bitemyapp> there's really never a good reason to nuke ~/.cabal
22:42:51 <gfixler1> it came back with a cabal update
22:43:01 <bitemyapp> so unless there's a conscious, informed reason to want to regenerate everything from the latest base template - I'd leave it alone.
22:43:12 <bitemyapp> and nuking ~/.cabal when your package-db is corrupted is going to be a no-op anyway.
22:43:16 <gfixler1> I thought cabal installs without sandboxes went in there
22:43:29 <bitemyapp> they go in the user package-db which lives in ~/.ghc
22:43:31 <gfixler1> I just wanted to clear out and start fresh
22:43:33 <gfixler1> ah
22:43:44 <gfixler1> .cabal was huge
22:43:45 <bitemyapp> gfixler1: precisely speaking, Cabal is not a package manager and doesn't really manage your package databases.
22:43:51 <bitemyapp> gfixler1: those were binaries, not packages.
22:44:35 <gfixler1> so .ghc == source, .cabal == built?
22:44:38 <bitemyapp> gfixler1: ghc-pkg manages your package database, Cabal is just a middle-program for that. Cabal is more of a declarative/nuts-n-bolts-n-defaults-n-spice-n-everything-nice alternative to Makefiles, Maven, sbt, etc.
22:45:25 <liste> timothyh http://hackage.haskell.org/package/monad-loops-0.4.2.1/docs/Control-Monad-Loops.html there's andM
22:48:55 <IgneNature> Can someone please check this code http://lpaste.net/3716361327791308800 and explain how getProcessTreeFromRoot functions? any help would be appreciated.
22:49:49 * hackagebot text 1.2.1.1 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-1.2.1.1 (BryanOSullivan)
22:51:12 <Walther> > ins x [list] = map ((take half list) ++ [x] ++ (drop half list)) [list] where half xs = div (length xs) 2
22:51:13 <timothyh> thanks liste
22:51:13 <lambdabot>  <hint>:1:14: parse error on input â€˜=â€™
22:51:47 <Walther> > let ins x [list] = map ((take half list) ++ [x] ++ (drop half list)) [list] where half xs = div (length xs) 2 in ins 10 [[1..3,[2..6]]
22:51:49 <lambdabot>  <hint>:1:127: parse error on input â€˜,â€™
22:51:56 <Walther> > let ins x [list] = map ((take half list) ++ [x] ++ (drop half list)) [list] where half xs = div (length xs) 2 in ins 10 [[1..3],[2..6]]
22:51:57 <lambdabot>      Couldn't match expected type â€˜[a] -> b1â€™ with actual type â€˜[a]â€™
22:51:57 <lambdabot>      Relevant bindings include
22:51:57 <lambdabot>        list :: [a] (bound at <interactive>:1:12)
22:54:07 <Walther> hm. any suggestions as to what goes wrong and which way around to look at fixing it?
22:54:30 <Walther> (please no ready-made solutions, i'm trying to learn :))
22:55:18 <manjunaths> Hello everyone
22:56:20 <verement> Walther: start looking at the types of everything until you understand why they don't match up
22:57:58 <Walther> it expects a function of [a] to b but it gets only [a], so something is not a function
22:58:01 <DrPavelheer> Walther: Map takes a function as its first argument.
22:58:11 <DrPavelheer> ((take half list) ++ [x] ++ (drop half list)) is not a function
22:58:16 <IgneNature> can someone please explain this line to me? getProcessTreeFromRoot k (x:xs) =
22:58:16 <IgneNature> [Process (a) (getProcessTreeFromRoot a xs)|a <- [fst y | y <- xs, (snd y == k) && (fst y > 1)]] --out of http://lpaste.net/3716361327791308800
22:58:26 <Walther> mmh, i'd probably need something like foreach
22:58:52 <DrPavelheer> Nope
22:59:02 <DrPavelheer> You'll just need an anonymous function
22:59:13 <Walther> ..or yeah, rewrite as lambda
22:59:26 <igniting> :t fst
22:59:27 <lambdabot> (a, b) -> a
22:59:37 <igniting> > fst (1, 2)
22:59:38 <lambdabot>  1
22:59:48 <DrPavelheer> (\lst -> (take half lst) ++ [x] ++ (drop half lst))
22:59:53 <igniting> > snd (1, 2)
22:59:54 <lambdabot>  2
23:01:28 <igniting> IgneNature - xs is a list of tuples (In your case [(Int, Int)])
23:02:45 <Walther> > let ins x [list] = map (\list -> (take half list) ++ [x] ++ (drop half list)) [list] where half xs = div (length xs) 2 in ins 10 [[1..5],[6..9]]
23:02:46 <lambdabot>      Couldn't match expected type â€˜Intâ€™ with actual type â€˜t0 a0 -> Intâ€™
23:02:46 <lambdabot>      Probable cause: â€˜halfâ€™ is applied to too few arguments
23:02:46 <lambdabot>      In the first argument of â€˜takeâ€™, namely â€˜halfâ€™
23:03:20 <igniting> [fst y | y <- xs, (snd y == k) && (fst y > 1)] -- Returns list of first values from those tuples whose first value is greater than one and second value is equal to k 
23:04:12 <igniting> IgneNature: are you familiar with list comprehensions?
23:07:14 <Walther> > let ins x [list] = map (\list -> (take (half list) list) ++ [x] ++ (drop (half list) list)) [list] where half xs = div (length xs) 2 in ins 10 [[1..5],[6..9]]
23:07:15 <lambdabot>  *Exception: <interactive>:3:5-132: Non-exhaustive patterns in function ins
23:08:58 <Guest11226> fn :: SomeType -> SomeType; fn (view -> Unit) = x
23:09:36 <Guest11226> can I use variables bound in the left to right
23:09:51 * hackagebot huttons-razor 0.1.1.0 - Quick implemention of Hutton's Razor  http://hackage.haskell.org/package/huttons-razor-0.1.1.0 (steshaw)
23:11:05 <Guest11226> I mean in ViewPattrens I want to use variable fed to view function in the right equation
23:11:10 <Guest11226> is that possible
23:11:11 <Guest11226> ?
23:12:06 <wz1000> Is there any vim plugin that will let me navigate to the definition of a symbol in a cabal project?
23:12:26 <breadmonster> > data Seq f a = Seq { runSeq :: f (a, Seq f a) } deriving (Show)
23:12:28 <lambdabot>  <hint>:1:1: parse error on input â€˜dataâ€™
23:13:10 <edwardk> breadmonster: http://hackage.haskell.org/package/free-4.12.1/docs/Control-Comonad-Trans-Coiter.html
23:13:43 <breadmonster> edwardk: Wait, so f can't be a monad?
23:13:54 <breadmonster> Are all comonads functors too?
23:14:06 <edwardk> all comonads are functors
23:14:14 <edwardk> all monads are functors (now)
23:14:14 <breadmonster> Interesting.
23:14:33 <breadmonster> edwardk: No, I was talking about type class implementations.
23:14:42 <edwardk> f can't be or Seq f?
23:14:49 <gfixler1> are all monads and functors pointed now?
23:14:52 <breadmonster> Is it illegal to instantiate comonad without first instantiating fmap?
23:15:00 <breadmonster> *instantiating Functor?
23:15:04 <edwardk> instance Functor f => Comonad f where ...
23:15:12 <edwardk> er class Functor f => Comonad f where ...
23:15:17 <edwardk> ^- that kind of gets in the way of doing that
23:15:19 <edwardk> fortunately
23:15:26 <breadmonster> Interesting.
23:15:34 <edwardk> liftW :: Comonad f => (a -> b) -> f a -> f b
23:15:38 <edwardk> is a valid default definition
23:15:59 <breadmonster> edwardk: I'm thinking of creating a variadic lift.
23:16:07 <breadmonster> And placing in various libraries...
23:17:03 <edwardk> can't exist in general with nice inference
23:17:23 <edwardk> try using it on the (->) a  monad  for instance ;)
23:17:41 <breadmonster> Ah damn.
23:19:35 <Walther> > let ins x lists = map (\list -> (take (half list) list) ++ [x] ++ (drop (half list) list)) lists where half xs = div (length xs) 2 in ins 10 [[1..5],[6..9]]
23:19:36 <lambdabot>  [[1,2,10,3,4,5],[6,7,10,8,9]]
23:19:39 <breadmonster> edwardk: wait, do you use Mu at work?
23:19:46 <edwardk> no
23:19:59 <edwardk> we have our own haskell-like we use
23:20:03 <breadmonster> I thought that was S&P.
23:20:09 <breadmonster> Must be Standard Chartered then.
23:20:37 <edwardk> Standard chartered has Mu, S&P Capital IQ has Ermine.
23:20:48 <edwardk> https://bitbucket.org/ermine-language/ermine-scala
23:21:00 <breadmonster> Are there any significant semantic differences between Ermine and GHC?
23:21:44 <breadmonster> Oh interesting that you wrote it in Scala over Haskell.
23:22:14 <edwardk> we have a haskell version of the compiler we've been working on in the background
23:22:25 <edwardk> http://github.com/ermine-language/ermine
23:24:03 <breadmonster> edwardk: Oooh cool going through the source atm.
23:25:40 <ij> Is there a tool that'd find uninstalled packages given a source file?
23:25:59 <ij> Or at least try to.
23:26:58 <fishburne> trying to install postgresql-simple: Failed with message "postgresql-simple-0.4.10.0 depends on byteable-0.1.1 which failed to install"
23:27:29 <breadmonster> fishburne: I have those issues sometimes.
23:27:39 <breadmonster> Try installing byteable separately first?
23:27:58 <igniting> ij: cabal will do that
23:28:19 <ij> Even without a cabal file?
23:28:46 <igniting> yes, you do a cabal init
23:29:12 <fishburne> breadmonster, ok. will try that
23:30:06 <breadmonster> fishburne: This sounds ridiculous, and I'm not an experienced Haskeller, but iirc, just keep installing the files you see that failed installation separately
23:30:18 <breadmonster> fishburne: And then run an install of what you want up and running.
23:30:31 <fishburne> breadmonster, Just tried the same command. and it worked !!
23:30:36 <breadmonster> For some reason, that technique just seems to work, but it's more magic than I'm comfortable iwth.
23:30:41 <igniting> fishburne: can you tell the exact output of byteable-0.1.1 failed to install
23:30:52 <breadmonster> fishburne: Did you install byteable?
23:31:08 <fishburne> igniting, It worked when I tried second time. No I didn't install any package separatly.
23:31:22 <breadmonster> Interesting.
23:31:22 <ij> igniting, I'll be amazed if it works, thanks.
23:32:30 <tjscanlon> does anyone have a recommendation for which SDL2 library to use? i saw there's hsSDL2 and just plain old sdl2
23:32:36 <fishburne> breadmonster, It worked when I ran the command, cabal install postgresql-simple, a second time. I didn't install any package separatly.
23:32:45 <tjscanlon> or maybe another library for simply drawing to the screen -- all im doing is creating a breakout clone
23:33:13 <igniting> fishburne: the first cabal install would have just timed out then, due to network issues
23:34:07 <fishburne> igniting, No. Actually there was a 'path does not exist' type error somewhere along the logs the first time...
23:34:43 <igniting> fishburne: were you installing with -j?
23:34:52 * hackagebot Tainted 0.1.0 - Tainted type, and associated operations  http://hackage.haskell.org/package/Tainted-0.1.0 (RossMeikleham)
23:34:53 <fishburne> no. 
23:35:05 <danclien> fishburne: Are you installing into a sandbox?
23:35:17 <fishburne> danclien, yes. Into a sandbox.
23:35:38 <danclien> fishburne: Existing or a new empty one?
23:36:17 <igniting> hmm, yes the error messages are usually like that. I use verbose option to see the exact error
23:36:28 <fishburne> It contains the scotty library...
23:37:04 <fishburne> danclien, The sandbox contains the scotty library and its dependencies.....
23:37:59 <igniting> fishburne: this is a known issue in cabal. the error message is quite useless without verbose. https://github.com/haskell/cabal/issues/1914
23:39:11 <fishburne> igniting, I see. Will keep in mind :)
23:40:16 <danclien> fishburne: Ah, gotcha. Could you run `cabal sandbox hc-pkg list` and toss the output in a Gist or something?
23:40:51 <fishburne> danclien, sure. 
23:42:31 <fishburne> danclien, https://bpaste.net/show/3446a9ee6e7c
23:43:22 <danclien> That's weird. `byteable-0.1.1` is already installed.
23:44:29 <breadmonster> danclien: He ran it a second time and it got installed.
23:44:53 <danclien> breadmonster: Ah, thanks. I must have missed that chat message.
23:46:02 <tjscanlon> Is there a way for cabal install to automatically append the dependency to the .cabal file?
23:47:47 <danclien> tjscanlon: No way to add it directly to the .cabal file, but there's `cabal freeze` that may do what you're looking for.
23:48:25 <igniting> tjscanlon: I guess you usually do the other way round, first add it in .cabal file and then do cabal install --dependencies-only
23:50:32 <tjscanlon> Awesome, thanks!
23:54:53 * hackagebot nagios-check 0.3.0 - Package for writing monitoring plugins  http://hackage.haskell.org/package/nagios-check-0.3.0 (fractalcat)
