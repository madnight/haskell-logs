00:28:48 * hackagebot wai-middleware-crowd 0.1.1.1 - Middleware and utilities for using Atlassian Crowd authentication  http://hackage.haskell.org/package/wai-middleware-crowd-0.1.1.1 (MichaelSnoyman)
01:38:04 <Narfinger> hiho, i have a "data Foo = Foo { bar :: Foo}" but i want the bar to be something like a reference (it can be immutable) to a Foo
01:38:21 <Narfinger> but i didn't read anything about this being possible in haskell so it might be that i have some basic thinking wrong
01:42:32 <ronh-> @let data Foo = Foo { x :: Int, bar :: Foo }
01:42:33 <lambdabot>  Defined.
01:42:41 <ollef> Narfinger: what are you trying to achieve?
01:42:42 <ronh-> > let foo = Foo 10 foo in foo
01:42:44 <lambdabot>      No instance for (Show Foo)
01:42:44 <lambdabot>        arising from a use of ‘show_M9157690194665494001696’
01:42:44 <lambdabot>      In the expression:
01:42:51 <ronh-> @let data Foo = Foo { x :: Int, bar :: Foo } deriving Show
01:42:52 <lambdabot>  .L.hs:150:1:
01:42:52 <lambdabot>      Multiple declarations of ‘Foo’
01:42:52 <lambdabot>      Declared at: .L.hs:148:1
01:42:57 <ronh-> oh well
01:43:07 <Narfinger> basically i will have a list of Foo somewhere and i might update some elements in the list
01:43:18 <Narfinger> but this should also update the Foo inside a Foo
01:43:50 * hackagebot yesod-gitrepo 0.2.1.0 - Host content provided by a Git repo  http://hackage.haskell.org/package/yesod-gitrepo-0.2.1.0 (MichaelSnoyman)
01:44:06 <Narfinger> it could be that i don't quite get the haskell way to do this
01:44:37 <ronh-> you can't update a list, list is immutable. you can return a new list, though
01:44:37 <Narfinger> but of course i don't want to go through every foo and update it if the other one was updated
01:44:40 <ollef> Narfinger: you could look into STRef or IORef if you think you really need it. it's hard to tell without further information.
01:44:55 <ronh-> and yes you will need something like STRef or IORef
01:45:13 <Narfinger> with update i mean create a new list with an element changed
01:47:02 <Narfinger> mhh ok than i think i need to think about my problem a bit more
01:47:11 <ronh-> what are you actually doing? the big picture. perhaps you don't need IORef
01:47:48 <Narfinger> well i try to do it better
01:47:53 <Narfinger> assume Foo now has an int in it
01:48:03 <Narfinger> i have a bunch of foo in a list
01:48:19 <Narfinger> but sometimes i create a new list where i changed the int in the foo
01:48:47 <Narfinger> but now i want to be able to call a function on the foo inside another foo and it just having the correct int and not any previous version
01:50:02 <Narfinger> "data Foo = Foo { bar :: Foo, baz :: Int}  and i want to be able to do callFoo f = baz $ bar f"
01:50:19 <Narfinger> but i created a new list of Foos somewhere else where one of the Foos has a different integer
01:50:37 <Narfinger> was that understandable or should i write some code?
01:51:30 <mazur> hi all, what's the syntax to get a component out of a Linear.V3? like v = V3 1.0 0.5 2.0, then _x v or something?
01:52:03 <srhb> Narfinger: If you replace Foo1 in a list of Foo with Foo2, which has another bar2 instead of bar1, then FooFoo2 will be the value of bar, not FooFoo1
01:52:12 <srhb> Narfinger: I suspect what you are asking for is exactly what you get out of the box.
01:52:17 <srhb> Hence the confusion.
01:52:32 <mazur> let v = V3 1.0 0.5 2.0
01:53:01 <supki> mazur: v ^. _x  or  view _x v
01:53:09 <Narfinger> sorry i didn't quite understand
01:53:15 <Narfinger> will i get bar2 or bar1?
01:53:27 <srhb> bar2
01:53:29 <Narfinger> oh
01:53:37 <Narfinger> so everything is a reference if i just assign stuff
01:53:40 <srhb> If Foo2 has bar2, then if you replace Foo1 with Foo2, you get Foo2 and hence bar2
01:53:47 <srhb> I don't know what you mean by reference.
01:53:51 * hackagebot libgit 0.3.1 - Simple Git Wrapper  http://hackage.haskell.org/package/libgit-0.3.1 (VincentHanquez)
01:54:00 <srhb> mazur: V3 1 2 3 ^. _x
01:54:06 <srhb> Oh, supki got there before me.
01:54:07 <Narfinger> ok wait a second
01:54:15 <srhb> Narfinger: Write some code. :-)
01:54:21 <Narfinger> i am going to write something
01:54:29 <mazur> is ^. in the Lens package?
01:55:29 <liste> mazur yes
01:56:07 <mazur> ok thanks
01:58:47 <solatis> hmmm is there a way to use applicative to add an element to a list?
01:59:07 <solatis> as in, consider this line:
01:59:08 <solatis> A.Reply <$> Atto.many' (replyLine minus <|> replyLine plus) <* (replyLine space)
01:59:18 <solatis> it returns the result of Attto.many'
01:59:41 <srhb> You'll have to lift (:)
01:59:44 <srhb> with fmap
01:59:52 <solatis> is it possible the result of the right hand side of <* with the list on the left part?
01:59:52 <srhb> Er, or rather (++)
02:00:07 <solatis> hmmm let me see
02:02:47 <solatis> ok clearly i have no idea what i'm doing
02:03:20 <solatis> i assume you're talking about liftA ?
02:04:04 <Narfinger> http://lpaste.net/132607 this is rough approximation of my code
02:04:15 <Narfinger> sorry it is not complete because there is still a lot i need to learn about haskell
02:04:28 <Narfinger> but hopefully the idea is understandable
02:06:36 <ronh-> Narfinger that will work assuming changeList is [Foo] -> IO [Foo]
02:06:58 <ronh-> if it is [Foo] -> [Foo], then do `let l2 = changeList l'
02:07:32 <Narfinger> well i didn't quite figure out the io stuff but that is not the point of my question
02:08:09 <ronh-> if changeList doesn't return IO then you can't call it like this:  l <- changeList ..
02:08:16 <liste> Narfinger you could use IORef or lenses
02:09:05 <ronh-> do `let l2 = changeList ...' instead. other than that, your code looks fine
02:09:08 <Narfinger> what are lenses?
02:09:24 <liste> Narfinger another name for them is functional reference
02:09:44 <Narfinger> well that sounds like something i could use :)
02:09:48 <dredozubov> just encountered new emacs haskell-mode quirk: "You tried to do an indentation, but an indentation mode has not been enabled yet."
02:09:59 <dredozubov> yet i clearly see "(add-hook 'haskell-mode-hook 'turn-on-haskell-indentation) " in ~/.emacs
02:10:12 <Narfinger> ok i will look into that, thanks
02:10:13 <liste> it basically address of an element in nested structure
02:10:22 <dredozubov> any idea how to fix that?
02:10:40 <dredozubov> *this
02:11:13 <liste> > ([(1, 2), (3, 4)] & ix 0 . _1 .~ 5) :: [(Int, Int)]
02:11:15 <lambdabot>  [(5,2),(3,4)]
02:12:28 <liste> is an example of lens use
02:13:07 <solatis> urgh, i'm lost
02:13:46 <solatis>   lines   <- Atto.many' (replyLine minus <|> replyLine plus)
02:13:47 <solatis>   endLine <- replyLine space
02:13:47 <solatis>   return $ A.Reply (lines ++ [endLine])
02:13:58 <solatis> i would think that would be easily rewritten as applicative
02:17:39 <liste> solatis if you don't want to throw away the replyLine space, don't use <*
02:17:42 <liste> use <*>
02:18:07 <solatis> i know, it was meant as a mere example of what i want
02:18:43 <liste> you need "foo <$> Atto.many' (replyLine minus <|> replyLine plus) <*> replyLine space"
02:18:46 <solatis> if i use <*>, it means i need to provide a way to append the item on the right hand side to the list on the left hand side
02:18:48 <liste> where foo is a pure function
02:19:05 <solatis> right, and foo combines those 
02:20:09 <liste> foo is of type [Line] -> Line -> Reply, it shouldn't be to hard to write
02:21:20 <solatis> yeah
02:21:35 <jacereda> hi... I'm using ghc 7.10.1 and I'm trying to compile HaRe in a sandbox, but I get conflicts related to base 4.8... (conflict: HaRe => base>=4.0 && <4.8). Does that mean an older ghc must be used?
02:22:15 <bergmark> jacereda: yes
02:22:16 <fractalsea> Does anyone know what the world-file is in Cabal?
02:22:28 <alanz> jacereda: try configuring with --allow-newer
02:22:44 <liste> jacereda which version?
02:22:50 <fractalsea> Can't seem to find anything on it in the docs
02:22:58 <liste> from HaRe github: "Note: The current version (0.7.2.8) does not install with GHC 7.8.x"
02:22:58 <jacereda> of HaRe? master and latest tag
02:23:23 <jacereda> liste: that's why I downloaded 7.10.1 in the first place :-)
02:23:59 <alanz> jacareda: I am not 100% sure how well HaRe works on 7.10.1 at the moment, there is a rework going on to support 7.10.2 when it comes out
02:24:25 <jacereda> alanz: ok, thanks
02:24:29 <liste> fractalsea the world-file records your installed packages
02:25:11 <liste> and acts as a meta-package of sorts
02:25:17 <liste> e.g. you can cabal install world
02:25:18 <bergmark> fractalsea: sems like you need you need 7.6 then
02:25:30 <fractalsea> hmm OK
02:25:31 <bergmark> oops jacereda *
02:26:25 <fractalsea> Is there a way of making cabal create and write to it in a non-default location?
02:27:31 <jacereda> trying HaRe master with --allow-newer, let's see what happens
02:28:17 <alanz> ok, don't hold your breath, there is a major architecture change in progress at the moment
02:33:02 <jacereda> Ok, --allow-newer failed, which ghc version do I need for HaRe then?
02:33:30 <liste> fractalsea there's a --world-file option in the source but I can't find it in the docs
02:33:34 <liste> https://github.com/haskell/cabal/blob/824f7f3d1fc62ea412073b866ef611194ecbb8de/cabal-install/Distribution/Client/Setup.hs#L311
02:33:44 <fractalsea> liste: ah cool thanks
02:34:05 <liste> https://github.com/haskell/cabal/blob/1.22/cabal-install/Distribution/Client/Setup.hs#L311 this one's for 1.22
02:34:07 <fractalsea> liste: do you know how I can get the current value? Essentially I’d like to change the location, but I would also like to keep the file name the same
02:34:16 <fractalsea> OK
02:34:22 <liste> fractalsea no idea
02:34:34 <fractalsea> OK np, thanks
02:34:35 <liste> by default it's ̃~/.cabal/world
02:36:09 <jacereda> alanz: I noticed there's a ghc-7.10 branch, should I try that one?
02:38:17 <alanz> yes. But I have not touched HaRe in months, working on getting ghc-exactprint working first, which requires GHC changes. So I don't think it works at the moment.
02:39:52 <jacereda> alanz: ok, any suggestion as to what ghc version to use then?
02:40:09 <alanz> The last known good one for HaRe is 7.6.3
02:40:46 <alanz> There were too many changes to the AST in 7.8.x, so we opted for a new way of doing it, for 7.10.x. But it is still stabilising
02:41:30 <jacereda> alanz: ok, thanks
02:45:13 <exfalso> hi, i have a Map an I would like to use Control.Lens to simultaneously traverse and modify it. What combinators should i be looking at?
02:46:44 <bennofs> exfalso: traverse meaning changing a value to a specifc key? or modify it with an monadic/applicative action that gets key & value and returns a new value?
02:47:38 <gspr> I'm having some trouple understanding repa's Slice types... How would I go about constructing something with the type of slice's second argument, that represents freezing index number i of a d-dimensjonal array to be j?
02:47:39 <exfalso> bennofs: second
02:47:52 <bennofs> exfalso: try itraverse
02:47:55 <bennofs> :t itraverse
02:47:56 <lambdabot> (Applicative f, TraversableWithIndex i t) => (i -> a -> f b) -> t a -> f (t b)
02:48:26 <gspr> (So, in the case of matrices, with i=1 and d=2, we would extract row j. With i=2 and d=2, we extract column j.)
02:48:34 <exfalso> yeah but that doesn't give me a lens over the element being traversed over
02:48:43 <gspr> (But I need this in the case of a general d-dimensional repa array)
02:50:19 <liste> exfalso so you need to modify other elements of the Map while traversing?
02:50:52 <liste> if not, you don't need the lens because you have the element itself (:
02:51:05 <exfalso> liste: Well I would like to traverse over each element, execute a monadic action and modify the element in place
02:51:11 <asilvester> Hi
02:51:22 <fractalsea> How do I update cabal to use a different storage location from $HOME/.cabal/ ? I don’t want to create a symlink
02:51:51 <bennofs> exfalso: so you will run it in some kind of state monad where you can change the state instead of producing a new map?
02:52:07 <exfalso> bennofs: yes
02:52:54 <bennofs> exfalso: hmm ok, so just that I have understood this right: you would like something like this: (Lens' map a -> a -> f ()) -> map -> f () ?
02:53:26 <exfalso> bennofs: yes
02:53:31 <exfalso> exactly
02:54:19 <bennofs> exfalso: there is no guarrante that the element will exist in another map (you could use this lens to modify an other map), so the best you can get is either Traversal' map a or Lens' map (Maybe a)
02:55:12 <bennofs> :t \f -> itraverse_ (\i -> f (ix i))
02:55:13 <lambdabot> (Applicative f, Applicative f1, FoldableWithIndex (Index m) t, Ixed m) => (((IxValue m -> f1 (IxValue m)) -> m -> f1 m) -> a -> f b) -> t a -> f ()
02:57:09 <bennofs> exfalso: is this what you want? you can produce the lens/traversal given the index with ix/at
02:57:11 <bennofs> :t ix
02:57:12 <lambdabot> (Applicative f, Ixed m) => Index m -> (IxValue m -> f (IxValue m)) -> m -> f m
02:57:29 <bennofs> -- ix :: i -> Traversal' (Map i a) a
02:57:40 <bennofs> -- at :: i -> Lens' (Map i a) (Maybe a)
02:58:45 <exfalso> ok rephrase: I would simply like a mapM over the elements of the Map
02:58:53 * hackagebot packer 0.1.7 - Fast byte serializer and unserializer  http://hackage.haskell.org/package/packer-0.1.7 (VincentHanquez)
02:59:13 <bennofs> exfalso: Map is an instance of Traversable, so you can just use Traversable.mapM ?
02:59:38 <bennofs> (or traverse for Applicative effects)
03:00:37 <exfalso> bennofs: yeah thats what i was looking for thanks:) sry for complicating it
03:03:53 * hackagebot stackage-metadata 0.3.0.0 - Grab current metadata for all packages  http://hackage.haskell.org/package/stackage-metadata-0.3.0.0 (MichaelSnoyman)
03:22:34 <fr33domlover> hello!
03:22:48 <fr33domlover> is there a way to add a type constraint to a data type?
03:23:07 <fr33domlover> e.g. have a (Point a a a) where a must be a Num instance?
03:23:42 <fr33domlover> something like: data (Num a) => Point = Point a a a
03:23:54 * hackagebot packer 0.1.8 - Fast byte serializer and unserializer  http://hackage.haskell.org/package/packer-0.1.8 (VincentHanquez)
03:24:16 <fr33domlover> actually: data (Num a) => Point a = Point a a a
03:25:17 <liste> fr33domlover data Point a = Num a => Point a a a
03:26:27 <fr33domlover> Data constructor ‘Point’ has existential type variables, a context, or a specialised result type
03:26:36 <fr33domlover> (Use ExistentialQuantification or GADTs to allow this)
03:26:40 <fr33domlover> liste, i got this ^
03:27:06 <liste> yeah, you need either of those
03:27:21 <liste> they're language extensions
03:27:34 <fr33domlover> it also says this: Point :: forall a. Num a => a -> a -> a -> Point a
03:27:48 <fr33domlover> i know what GADTs are, but i never used forall
03:28:04 <liste> forall is normally implicit
03:28:18 <liste> for example in id :: a -> a actually is id :: forall a. a -> a
03:28:36 <R0b0t1> with GADTs the only way I know of doing it involves naming the fields, does that ever *prevent* you from doing something?
03:28:47 <liste> but for ExistentialQuantification and ScopedTypeVariables, explicit forall is required
03:30:07 <liste> data Point a = forall a. Num a => Point a a a is an existential type
03:30:10 <fr33domlover> liste, does it matter which extension i use?
03:30:46 <liste> fr33domlover you can achieve it with either, but in different way
03:31:18 <liste> GADTs are more powerful, though
03:31:37 <zipper> Where can I read on -X GHC or learn about it?
03:31:53 <zipper> I'm almost clueless on this.
03:31:58 <fr33domlover> liste, then perhap ExistentialQuantification is less deviation from the regular syntax
03:32:25 <fr33domlover> GADTs seem to do much more than the little thing i need :p
03:32:28 <Cale> zipper: The GHC User's Guide has lots of information on extensions
03:32:29 <liste> zipper language extensions? here https://downloads.haskell.org/~ghc/6.12.2/docs/html/users_guide/flag-reference.html#id598783
03:32:41 <Cale> That's a rather old link
03:32:42 <liste> although that's quite odl
03:33:07 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghc-language-features.html
03:34:24 <zipper> No I want to know where to use the -X
03:34:28 <liste> fr33domlover there's also -XDatatypeContexts
03:34:34 <liste> I think that's more what you need
03:34:44 <Cale> Oh, if you see -XBlahBlah that's a commandline flag
03:34:52 <liste> it lets you do "data Num a => Foo a = Bar a a a"
03:34:57 <zipper> I understand that I can specify extensions in the source files but...
03:35:02 <Cale> But you can also put {-# LANGUAGE BlahBlah #-} at the top of your source file
03:35:09 <liste> instead of "data Foo a = Num a => Bar a a a"
03:35:12 <Cale> which is probably the better thing to do
03:35:17 <zipper> I see
03:35:42 <Cale> (that way each source file documents which extensions are needed to build it)
03:36:07 <zipper> Cale: No space between -X and the extension name?
03:36:08 <fr33domlover> liste, thanks
03:36:52 <liste> although I'd rather put the Num a => in the function type signatures
03:37:36 <nshepperd> doesn't DatatypeContexts require you to put the Num in the type signatures?
03:38:15 <liste> http://stackoverflow.com/questions/7438600/datatypecontexts-deprecated-in-latest-ghc-why here's some rationale
03:39:41 <nshepperd> right yes, it just forces you to put 'Num a =>' in all your polymorphic 'Foo a' functions
03:39:53 <Cale> zipper: That's correct
03:40:58 <fr33domlover> liste, nshepperd, then why would I need this extension? I can just put (Num a) in function signatures
03:41:13 <fr33domlover> i thought there's a shoirt cut
03:41:17 <liste> fr33domlover you don't, its a misfeature
03:41:58 <nshepperd> yeah, DatatypeContext isn't useful
03:42:03 <liste> GADTs are the way to go, they're awesome in other ways too
03:42:21 <fr33domlover> liste, but then do I need to put (Num a) in function signatures too?
03:43:33 <fr33domlover> i'll try in ghc :p
03:43:36 <fr33domlover> *ghci
03:44:35 <nshepperd> only where it makes sense to
03:45:52 <fr33domlover> :D
03:46:01 <fr33domlover> at least ghci doesn't require it
03:46:21 <fr33domlover> I can use e.g. (+) on 'a' variables and it doesn't complain
03:46:35 <fr33domlover> but it does when I remove the (Num a) from the data declaration
03:46:36 <nshepperd> ie. 'zero :: (Num a) => Point a', since you don't want to promise to create 'zero :: Point Char', but '(+) :: Point a -> Point a -> Point a', since the existence of a value 'Point a' you can give to (+) implies that a is numerical
03:47:12 <fr33domlover> yes, i don't need to use (Num a) in all the signatures
03:47:26 <fr33domlover> although that means using GADTs
03:47:36 <fr33domlover> i'll read and see if it has any price etc.
03:48:50 <dEPy> Is there a viable production ready Haskell -> JS solution? :)
03:49:05 <dEPy> Or should we go with more mainstream stuff? :)
04:01:24 <fr33domlover> dEPy, I think there is GHC JS and at least one DSL for JS
04:01:36 <fr33domlover> but I don't know much about it, do some research :)
04:01:53 <dEPy> Yea, I saw there's others just not sure if it's production ready and good support. :)
04:02:08 <dEPy> Otherwise we'll just go with something more popular like ClojureScript or something. I don't know yet.
04:38:44 <pumuckel> Is haskell a good first lang?
04:39:37 <nschoe> pumuckel, well that's very subjective.
04:40:27 <liste> also depends on the situation
04:40:28 <pumuckel> Is it a big lang?
04:40:29 <nschoe> pumuckel, personally I love Haskell. But maybe it's because I can compare it to all the other languages I've tested.
04:40:38 <liste> pumuckel no
04:40:47 <hodapp> It's not that it's a big language, it's that it will make nearly every other language look horrible.
04:41:16 <liste> haskell requires a lot of up-front effort to achieve anything useful, though
04:41:19 <nschoe> pumuckel, one thing is: if you begin with Haskell, you'll find it has an extremely nice community (haskell.org, this IRC chan, #haskell-beginners chan) and if one day you decide to switch language, well you're gonna be disapointed ^^
04:41:25 <hodapp> ...also, that.
04:41:50 <liste> but IMO it pays off
04:42:24 <liste> this is #haskell, anyway...
04:42:37 <indiagreen> pumuckel: I would recommend Python over Haskell if you want to write useful things for yourself (like scripts, small apps, etc)
04:43:31 <liste> haskell gave me much more insight into programming than learning other languages
04:43:36 <nschoe> indiagreen, problem with Python (IMO) is that people tend to stick to it after. I had a boss, he was all Python Python Python. He wanted to switch to Python for main dev language.
04:43:59 <indiagreen> nschoe: a-a-as if people don't tend to stick to Haskell
04:44:27 <liste> with other languages, there's a huge gap between theory (math, CS, Turing machines etc) and the programming language
04:44:35 <liste> I couldn't see the connection very well
04:44:43 <liste> with Haskell, it's just one continuum
04:45:41 <nschoe> indiagreen, true, but I don't consider Python a language for production. I consider it for fast prototyping (I'm not trying to troll or anything).
04:45:54 <kaidelong> is there any function that takes something to the tune of ST [a] and turns it into [a] (without hanging on infinite lists)?
04:46:26 <pumuckel> indiagreen: why cant i write small apps in haskell for myself
04:46:28 <kaidelong> it seems like it should be possible in theory for the same reason things like "randoms" should work but I can't think how to do it
04:46:35 <nschoe> liste, I totally agree. Coming from Maths studies initially, I was impressed how Haskell is actually close to Maths in.. almost everything. A "function" in Haskell is the same as a "function" in math (the purity side I mean). The notions of Groups, Monoids, etc.
04:46:41 <liste> kaidelong http://hackage.haskell.org/package/base-4.8.0.0/docs/Control-Monad-ST-Lazy.html maybe?
04:47:34 <indiagreen> pumuckel: you can, but Python is suited better to it – with small apps for yourself you don't have to worry much about safety, and it's harder to disregard safety in Haskell
04:47:43 <kaidelong> liste: that looks promising
04:47:49 <indiagreen> nschoe: pumuckel isn't choosing a language for production, I think
04:49:38 <indiagreen> pumuckel: on the other hand, if you are interested in programming-for-the-sake-of-programming (as a discovery of new cool things), then Haskell is ideal for that
04:49:46 <pumuckel> No. I just want to learn a programming language for being able to solve exercises on project euler and write (small) apps for myself
04:49:59 <esimp> I would like to convert : Data.Vector.Storable Word8 -> Ptr CUChar
04:50:23 <esimp> any help on the conversion function?
04:50:46 <liste> pumuckel for Project Euler Haskell suits pretty well
04:50:46 <indiagreen> pumuckel: then I think Python with NumPy are going to serve you better
04:51:09 <liste> except naively written programs tend to be slow
04:51:27 <liste> and eat up memory
04:51:31 <nschoe> indiagreen, indeed. But I did not tell him "go to Haskell" nor "don't go to Python" ^^ In the end the choice he will make is pretty irrelevant. If he wants to discover either Python or Haskell, he will do so when he feels ready.
04:52:13 <liste> I'd learn both :D
04:53:02 <liste> they'd give a pretty good view on programming in general (except for the EnterpriseBeanFactoryMethodInvocator Java horribleness)
04:53:19 <liste> in a way, the represent two opposites
04:53:21 <pumuckel> But declarative programmings seems easier to me than object oriented programming
04:54:49 <pumuckel> Hm ok
04:54:55 <nschoe> Hum guys I have a small "architecture" problem. I'm dealing with user-input dates. To be short: a dueDate and a reminderDate. The dueDate is mandatory while the user has the choice to input a reminderDate or not. I have to add this entry to a PostgreSQL DB. So I have to check that the user input a dueDate and it's correct (i.e. not before dateNow) and If have to check if he input a reminderDate, if so, I have to check 
04:54:56 <nschoe> that it's not before nowDate and not after dueDate. I managed that of course, but the way I coded it seeems very imperative-style, with lots of "if-then-else". What's the "common" Haskell way?
04:55:51 <nschoe> I was about to make use of several "helper" functions, defined in a where clause. Smth like check if dueDate is correct -> call 'proceed1', check if dateReminder is correct -> call 'proceed2', etc.
04:56:00 <pumuckel> Are there any good books for learning haskell?
04:56:31 <fvgvxmpv1> pumuckel http://learnyouahaskell.com/
04:56:43 <Cale> pumuckel: http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html
04:56:47 <pumuckel> Thanks
04:56:49 <nschoe> pumuckel, https://www.haskell.org/documentation
04:56:53 <nschoe> first section :-)
04:56:55 <Cale> These lectures are highly recommended
04:57:14 <Cale> (and they basically constitute a book)
04:58:46 <liste> nschoe Either and Maybe, esp. their Monad instances
04:58:58 <Cale> If you're looking for a physical book as an intro, Graham Hutton's "Programming in Haskell" is generally considered rather good for the material that it covers.
04:59:40 <pumuckel> Okay
04:59:55 <liste> something like (String, String) -> Maybe (DueDate, ReminderDate)
05:01:12 <liste> with pattern matching
05:02:51 <kaidelong> last time I looked at Python I saw programmers who really wanted to be programming in OCaml but weren't able to come to terms with it
05:03:12 <kaidelong> I don't know if I'd see it as a "opposite of Haskell"
05:03:19 <kaidelong> the LISP community probably comes closer
05:03:50 <liste> kaidelong, dynamic <-> static, imperative <-> functional
05:03:58 <nschoe> liste, hum, problem is, I'm working with Happstack here, and I'm on that monad stack.
05:04:11 <kaidelong> liste: for pythoners, the dynamic aspect doesn't seem to be something they actually want
05:04:21 <indiagreen> nschoe: you can use ExceptT, then
05:04:25 <indiagreen> or MaybeT
05:04:26 <kaidelong> python happens to be dynamic but they actually only want structural typing
05:05:26 <nschoe> Okay. But what good will MaybeT (for instance) do for me? I'll end up chain case myParse of Nothing -> error (Just date) -> continueProcessing, right ?
05:06:28 <kaidelong> there is some schizophrenia about the imperative part too, object-oriented might be a better description when dealing with common tasks
05:06:47 <pumuckel> Can i do in haskell things like in prolog? 
05:07:15 <indiagreen> nschoe: no, you would do “date <- liftMaybe myParse”
05:07:24 <indiagreen> (and continue processing)
05:07:26 <kaidelong> pumuckel: you can get pretty close. Nondeterminism is pretty simple to get, but not reversibility
05:07:47 <pharpend> Hey guys
05:08:01 <nschoe> pumuckel, I think I remember reading a paper to actually "program" Prolog in Haskell.
05:08:02 <pharpend> I have this function: readLouseConfig, from https://github.com/pharpend/louse/blob/master/Data/Louse/Config.hs
05:08:18 <liste> haskell's type inference is pretty much prolog
05:08:21 <kaidelong> pumuckel: Oleg Kiselyov did some work on this, you can check out LogicT. There is a logical paradigm language called Curry in the Haskell family
05:08:31 <pharpend> I can compile the library just fine
05:08:31 <liste> but it works on the type level
05:08:43 <pharpend> However, when cabal tries to compile the executable with that function uncommented
05:08:55 <pharpend> I get some bizarre error with lb
05:08:57 <pharpend> *ld
05:08:57 <dmiles> How crazy hard would it be to implemennt all of Common lisp in Haskell?
05:08:59 <pharpend> it's not a type error
05:09:09 <pharpend> I can compile the executable with plain ghc
05:09:45 <liste> pharpend sounds like a configuration problem
05:09:53 <liste> are you using cabal?
05:10:00 <liste> nvm
05:10:03 <indiagreen> nschoe: “liftMaybe :: Alternative f => Maybe a -> f a” actually doesn't exist in standard libs for whatever crazy reason, so just define it as an utility function
05:10:04 <liste> cabal sandbox=?
05:10:10 <nschoe> indiagreen, yes yes of course. But suppose I do dueDate <- liftMaybe myParse and this gives me Nothing because the user did not input it. Then I have to "fail" i.e. send him on a page (I'm obviously working on a web site here) telling him there is an error, but if I have a Just date, then I have to check for correctness, and again, tw ocases: either the date is correct, either it's not. It's imperative-style all again :/
05:10:22 <kaidelong> dmiles: CL is huge, it'd take ages. If you want to still be using Haskell, you'll have to do some fancy tricks to get anything like templates or variadic functions to work
05:11:09 <pharpend> liste: no cabal sandbox, (although I have tried building with a sandbox, and the same error occurs)
05:11:12 <indiagreen> nschoe: no, you just write it like “date <- liftMaybe myParse; guard (isCorrectDate date); ...”
05:11:15 <kaidelong> if you just want to implement a CL compiler then a naive one shouldn't be too hard to do but actual CL compilers have to be very clever because CLISP is dynamic and needs to be heavily optomized to be useful
05:11:29 <kaidelong> CL interpreter*
05:11:34 <kaidelong> CL compiler is inherently hard
05:11:40 <kaidelong> because of the dynamism
05:11:59 <indiagreen> and if error pages should be different based on what the error is, you use ExceptT instead of MaybeT
05:13:05 <dmiles> kaidelong: interesting.. now you got me wondering how poor the performance is between a non compiled lisp vs a compiled lisp
05:13:55 <kaidelong> modern LISP implementations are quite good on performance
05:14:03 <kaidelong> people have had ~50 years to perfect them
05:14:25 <nschoe> indiagreen, Ah... guard. This sounds interesting. I'll look it up. Thanks
05:14:40 <kaidelong> but it's an even harder problem than making Haskell workable
05:14:44 <dmiles> kaidelong: what really baked my noodle was CYC-on-JVM ran faster/better than on AllegroCL
05:15:22 <dmiles> kaidelong: what really baked my noodle was CYC-on-JVM ran faster than CYC-on-AllegroCL   (better was not true :P)
05:18:12 <dmiles> kaidelong: yet it was LISP-TO-C translation hacked to a LISP-TO-JAVA translation
05:19:02 <dmiles> kaidelong: so maybe it got the performance like a compiled lisp instead of AllegroCL which I assumed was not really compiled
05:19:42 <pharpend> liste: Okay, now with plain GHC, this is happening: http://ix.io/ixR
05:19:44 <pharpend> hmm
05:20:39 <dmiles> with all that said.. really what i care about is the burrning question.. shall i learn Haskell or ML .. which will be better to implemnt Prolog on
05:20:56 <pharpend> dmiles: well obviously everyone here is going to say Haskell
05:21:00 <pharpend> I do think Haskell is a better language
05:21:18 <pharpend> dmiles: but honestly either one will be good. The languages are very similar
05:21:37 <kaidelong> dmiles: probably Haskell
05:21:40 <pharpend> At least Haskell and OCaml. I haven't tried any of the other ML's
05:21:56 <kaidelong> Haskell's lazy semantics kind of resemble prolog short-circuiting
05:22:34 <kaidelong> I've always thought of Prolog being a good language to learn to understand better how to think about Haskell
05:23:18 <dmiles> The same would not be true from prolog->ML though right?
05:23:53 <dmiles> (i'll say  say OCaml since that is more likely of the MLs)
05:24:24 <dmiles> (also Pretending OZ/Poplog doesnt exist)
05:24:53 <kaidelong> dmiles: what's your objective here?
05:25:05 <kaidelong> perhaps you could look at the PAK Curry System
05:25:11 <kaidelong> "PAKCS"
05:25:29 <dmiles> i guess for me what it will come down to is How well a Haskell based prolog will compare toa  C based Prolog.. and then if i am relaly crazy enough to try to implment a 1/2 baked CL.. how much Library already exists
05:26:10 <dmiles> My real objective is to continue to program in ISO-Prolog but somehow inherit the ability to code things in Haskell that Haskell makes easier
05:26:25 <kaidelong> dmiles: Look at Curry, or Mercury
05:26:43 <kaidelong> if you want to continue programming in Prolog, you don't want Haskell
05:26:45 <dmiles> To have a larger base "this are the prewritten proof/expert syste,ms"
05:27:11 <kaidelong> Mercury has a similar syntax to Prolog so translating your old programs to it might be easier
05:27:35 <kaidelong> I am hoping to be working on Curry next term, but I'll have to ask
05:28:06 <SrPx> My program is *too* slow. I have a giant "Vector (IntMap Int)" (around 1kk IntMaps stored on the vector) and, inside the IntMaps, I have in average 10 elements (70% have 0 elements). In each frame, for each pixel of a 256x256 image, using Gloss.Raster, I read a random position of my vector and draw a pixel if it is not empty. That is running at 4fps!
05:28:28 <dmiles> *Nod* /me looks a bit at Curry
05:28:52 <SrPx> My question is: how? Why? Filling the array and the maps is slow and takes ~10s. But after that completes, the logic of the animation is ridiculously lightweight. Each pixel just accesses a position on the vector and check if the contained map is null. How can that run at 4fps?
05:29:27 <SrPx> I've profiled but it didn't help. It blames the vector filling functions, even though they are not even called anymore for most of the program's duration (??)
05:29:55 <kaidelong> so most of the time is spent filling the vector
05:30:00 <kaidelong> and you don't think this should be happening
05:30:39 <kaidelong> the two things that I think of is that you should be using a lazy array or that you should be using a mutable vector
05:31:27 <kaidelong> because you might be having a situation where you're creating entirely new vectors to change a single position. Since you have a giant vector, this would take long
05:32:19 <pavonia> To me it sounds like he don't want to change the vector afterwards
05:32:35 <SrPx> I actually think the profiling is ignoring most of the runtime, since I put "traces" inside the vector filling functions and they clearly are not called for most of the execution.
05:32:58 <SrPx> I ran the program for a minute, 10 secs spent filling the vec, 50 secs spent drawing the thing... this is the code: http://lpaste.net/132612
05:35:03 <kaidelong> alright, I don't see how the array could be the problem here
05:35:36 <kaidelong> > 256*256
05:35:37 <lambdabot>  65536
05:35:50 <SrPx> > 256*256*64
05:35:51 <lambdabot>  4194304
05:36:11 <kaidelong> 64ns is probably lowballing it quite a bit
05:36:11 <pavonia> SrPx: Map.size is O(n) here, better use Map.null
05:36:52 <SrPx> ..........................................................................................
05:37:06 <SrPx> brb gotta kill myself
05:37:36 <kaidelong> that's surprising
05:37:48 <kaidelong> I would have expected it to be like Data.Set but it isn't
05:38:13 <kaidelong> pavonia: Are you sure it's O(n) and not O(log n) though?
05:38:21 <kaidelong> oh, yes it is
05:38:42 <kaidelong> that's totally O(n) because it reaches the leaves, I see
05:39:07 <pavonia> Yeah
05:40:25 <pavonia> Though, if the average is 10 elements per set it probably shouldn't matter
05:41:52 <SrPx> Yea, it actually didn't matter - changing to null doesn't increase the FPS at all. Makes sense, considering "size" didn't show on the profiling,
05:42:25 <SrPx> TBH I predicted that would happen for a different reason - doesn't keeping a 1gb+ vector of trees on the memory means the garbage collector has to scan all that all the time?
05:42:30 <SrPx> Does that make sense?
05:42:57 <kaidelong> are the trees being shared?
05:43:07 <SrPx> pardon?
05:43:19 <kaidelong> no, that would be very unlikely
05:43:30 <kaidelong> given how you are generating them
05:44:21 <kaidelong> oh, wait
05:45:19 <visof> hi guys
05:45:30 <SrPx> (I have some ideas for a better algorithm, but I want to comprehend that result...)
05:45:32 <dolio> Is it actually spending a lot of time garbage collecting?
05:45:43 <SrPx> Is there any way I can profile it? dolio 
05:45:45 <visof> i'm using haskell platform, 7.8 version , what is the best way to to move to 7.10 ?
05:46:16 <SrPx> Isn't 7.10 still incompatible with most libs on hackage?
05:46:21 <kaidelong> it is
05:46:31 <kaidelong> I wouldn't recommend moving to it quite yet but
05:46:43 <kaidelong> Stackage Nightly supports GHC 7.10 FWIW
05:46:55 <SrPx> interesting
05:47:51 <ion> visof: You could install 7.10 into a path of your choice like <https://gist.github.com/ion1/2815423> and only add it to your PATH when you want to play with it.
05:48:17 <ion> visof: This would not interfere with the 7.8 you have.
05:48:29 <dolio> SrPx: I don't know if it's in profiling output, but you can use RTS flags to show information that includes time spent in the garbage collector.
05:48:56 <dolio> +RTS -s
05:50:27 <k0ral> Hello
05:50:55 <SrPx> Ok, there we go
05:51:01 <SrPx> k0ral: morning
05:51:47 <k0ral> is it possible to use the "Parser i a" type from attoparsec, with something else than a string type as "i" ?
05:52:54 <k0ral> for example, I would love to have a "Parser Data.XML.Types.Event a"
05:53:58 <SrPx> http://lpaste.net/132617 does that mean most of the time was spend on the GC?
05:54:05 <SrPx> I guess it does, right?
05:54:11 <SrPx> spent
05:55:03 <ion> k0ral: I would imagine it’s not impossible since attoparsec itself has an implementation for ByteString and one for Text. But i’m afraid i haven’t looked into that at all.
05:56:18 <k0ral> ion: what makes me doubt is the Chunk typeclass, which includes an "chunkElemToChar" function
05:56:36 <ion> k0ral: Aww, okay
05:56:38 <k0ral> it suggests that "i" must boil down to a stream of Char
05:56:53 <k0ral> which would ruin my hopes
05:58:08 <ion> k0ral: Perhaps one of the other parser libraries would be more suitable?
05:58:27 <k0ral> namely ?
05:59:10 <ion> Parsec or Trifecta perhaps
05:59:13 <c_wraith> parsec abstracts over the token type
06:00:46 <k0ral> do you know why attoparsec doesn't abstract over it ?
06:01:06 <k0ral> is there an underlying optimisation ?
06:01:20 <c_wraith> Yes
06:02:06 <c_wraith> k0ral: http://www.serpentine.com/blog/2014/05/31/attoparsec/
06:02:24 <muzzle> is there a way of sharing a data structure over multiple "it" parts in Hspec ?
06:05:21 <SrPx> So... is the GC consuming most of the time of my program? Is there any way I can tell the GC not to enter my big vector? Since nothing will be collected there anyway?
06:05:35 <muzzle> i.e. something like: describe "foo" $ do {context "bar"; x <- someIOAction; it "a" $ do {…}; it "b" $ do {…}}
06:05:44 <SrPx> If i make the whole vector unboxed will it know it doesn't need to enter there?
06:06:00 <SrPx> Also, do you think it is a good idea to just program this specific renderer in C and call it from Haskell?
06:07:41 <ion> muzzle: There seems to be a runIO :: IO r -> SpecM a r
06:08:36 <ion> muzzle: It’s not the appropriate thing to use here. Its documentation points to https://hackage.haskell.org/package/hspec-core-2.1.7/docs/Test-Hspec-Core-Hooks.html#v:beforeAll
06:08:59 * hackagebot tasty-silver 3.1.6 - Golden tests support for tasty. Fork of tasty-golden.  http://hackage.haskell.org/package/tasty-silver-3.1.6 (PhilippHausmann)
06:13:31 <hexagoxel> pharpend: missing `exposed-modules: Data.Louse.Config`
06:14:02 <pharpend> oh for fuck's sake
06:14:04 <pharpend> really
06:14:49 <hexagoxel> (or other-modules, as you like..)
06:15:05 <Darwin226> Hey. Is it possible to write a Monad instance for `data D a = D (IO a)`?
06:15:22 <pharpend> hexagoxel: I would think cabal would throw an error on that
06:15:54 <pharpend> Darwin226: make D a monad transformer? I'm not sure what you mean
06:15:57 <hexagoxel> pharpend: it was definitely discussed in one or two cabal issues
06:16:08 <pharpend> hexagoxel: oh yay it compiles now
06:16:11 <exio4> Darwin226: yes, it is possible
06:16:14 <Darwin226> pharpend: I don't know how to write >>= for that type
06:16:18 * pharpend grabs his pitchfork and stabs cabal
06:16:47 <exio4> Darwin226: implementing the Monad instance means implementing two functions, return and (>>=), you should start with the first one
06:17:00 <exio4> what would be its type?
06:17:11 <exio4> @type return
06:17:11 <lambdabot> Monad m => a -> m a
06:17:17 <Darwin226> exio4: I wrote return. D (return x)
06:17:40 <exio4> yes, now, (>>=), what type would it have? 
06:18:10 <Darwin226> exio4: I don't know how to write bind. To get the `a` I can only bind on the inner IO, but then I get `IO (D b)`
06:18:42 <exio4> you can always "unpack" the D, right? 
06:19:13 <Darwin226> I need to get D on top, right? I don't see how I can do that.
06:19:14 <exio4> and get the `IO a' "inside" a `D a'
06:20:28 <hexagoxel> pharpend: well at least it is high-priority :D https://github.com/haskell/cabal/issues/1746
06:20:30 <exio4> Darwin226: you've got as far as getting a IO (D b) and need a D b, right? 
06:20:39 <Darwin226> exio4: Yep
06:20:53 <exio4> Darwin226: now, let's consider what you can do with D? (it's constructors, and if you pattern match on it, what do you get?)
06:20:58 <c_wraith> just make D an instance of Traversable and the problem solves itself! >_>
06:21:41 <exio4> c_wraith: cheater! :p 
06:24:28 <benzrf> c_wraith: theyre the wrong way around
06:24:43 <exio4> benzrf: you only need join there anyway
06:26:29 <exio4> Darwin226: I think the key is taking into account that "D a" is the same thing as "IO a" but wrapped inside a datatype
06:27:11 <exio4> so, if you have an IO a and need a D a, you can just 'wrap' it, and if you need an IO a, you can just 'unwrap' it 
06:28:05 <Darwin226> exio4: Hmmmmmm
06:28:21 <Darwin226> exio4: I see. But it somehow feels wrong
06:28:34 <ion> Just follow the types.
06:29:03 <exio4> Darwin226: another small hint, you can define a function (runD :: D a -> IO a), and remember D's constructor has type IO a -> D a :P 
06:29:49 <ion> If you write data D a = D { unD :: IO a }, the compiler will generate that function for you.
06:36:11 <hodapp> today I will attempt... TYPE FAMILIES
06:36:18 <Darwin226> HORRAY!
06:36:23 * hodapp attempts to make lightning strike as he says 'type families', fails
06:36:26 <Darwin226> I did it!
06:36:26 <ion> Type all the families!
06:36:30 <ion> Darwin226: Congrats
06:36:38 <indiagreen> hodapp: have you mastered generics already? those were yesterday, if I recall correctly
06:36:45 <hodapp> indiagreen: HAHAHAHAHAHA MASTERED
06:36:48 <hodapp> indiagreen: You're funny.
06:37:12 <indiagreen> I see
06:37:15 <FofG> The Persistent docs seem lacking in a few spots. Here’s an example of fetching a row by id http://www.yesodweb.com/book/persistent#persistent_fetching_by_id. But that example uses the key generated by the insertion. What if I want to just get by an Int that I have, e.g. from the url path?
06:37:27 <geekosaur> hodapp: ...now if I weren't envisioning the Count from Sesame Street saying that >.>
06:37:37 <hodapp> indiagreen: I wrote some code with GHC.Generics that functions and that I fairly well understand, but I'd hardly say I'm anywhere near a master.
06:38:40 <indiagreen> geekosaur: and I was imagining Pilate from Life Of Brian
06:41:10 <hodapp> and likewise I have some generics stuff with Data.Data that I understand (better than GHC.Generics), but that doesn't accomplish what I need
06:46:36 <SrPx> ... deos the GC go inside unboxed types? Such as data.vector.unboxed?
06:49:48 <saulzar_> SrPx, No
06:49:49 <c_wraith> unboxed types can't be GC'd
06:50:02 <c_wraith> They are part of the value holding them
06:50:08 <c_wraith> They get collected with the holding value
06:50:42 <michi7x7> hi all, do you guys know a working implementation of 1-11 sorting, so that "abc 11" > "abc 2" ?
06:51:33 <c_wraith> Never seen that name for it, but I like it.  I don't know of any such library, but that doesn't mean there isn't one.  Hackage is big.
06:52:08 <Saulzar> > id 11 > id 2
06:52:10 <lambdabot>  True
06:52:17 <michi7x7> don't know where i picked that name up, what would you call it?
06:53:08 <c_wraith> Saulzar: the important part is that it would work in strings.
06:53:14 <c_wraith> > "11" > "2"
06:53:15 <lambdabot>  False
06:54:08 <michi7x7> yep, i guess you consume every non-number and than compare the rest. I'll try to implement this
06:54:26 <Saulzar> Ah
06:54:55 <Saulzar> Non numeric values are ignored?
06:55:08 <Saulzar> Er. characters rather
06:55:22 <michi7x7> nope, it should be just like the sorting most filemanagers use
06:55:53 <michi7x7> "abc 2", "abc 11", "cde 7", "cde 99", ...
06:56:27 <ronh-> michaelpj_ that won't be enough.. consider "abc 11 abc 11" "abc 11 abc 2"
06:57:03 <c_wraith> I've heard that this is actually a surprisingly hard problem to get right
06:57:18 <c_wraith> Really, the best anyone has managed is a big set of heuristics that are usually right
06:57:34 <michi7x7> yeah, i think so too but I'll try anyway
06:57:36 <Saulzar> Hmm 
06:58:03 <mniip> well
06:58:17 <Saulzar> So, could you parse out all the numbers and merge them, put the strings back together and compare them?
06:58:27 <ronh-> consume every non-digit, compare, if equal consume all the digits, compare.. repeat
06:58:28 * mniip codes furiously
06:58:29 <Cale> @let integerToken s = case reads s of { [(n,"")] -> Left (n :: Integer); _ -> Right s }; integerTokens s = map integerToken (words s); sortNumeric = map fst . sortBy (comparing snd) . map (ap (,) integerTokens)
06:58:31 <lambdabot>  Defined.
06:58:45 <Cale> > sortNumeric ["abc 11 abc 11", "abc 11 abc 2"]
06:58:47 <lambdabot>  ["abc 11 abc 2","abc 11 abc 11"]
06:58:55 <mniip> michi7x7, what about "abc 01" and "abc 1"
06:58:59 <indiagreen> @hackage natural-sort
06:58:59 <lambdabot> http://hackage.haskell.org/package/natural-sort
06:59:14 <Cale> Of course, things like "01" will be handled a bit poorly
06:59:22 <michi7x7> mniip: oh, should be EQ
07:00:01 <Cale> @let compareNumeric = comparing integerTokens
07:00:02 <lambdabot>  Defined.
07:00:12 <Cale> > compareNumeric "abc 01" "abc 1"
07:00:14 <lambdabot>  EQ
07:00:33 <Cale> If you want a total order, you can always  compareNumeric <> compare
07:00:44 <michi7x7> indiagreen: that looks rather good :)  I kew someone already did this
07:01:06 <c_wraith> Like I said..  hackage is big. :)
07:02:13 <PatoCP> Hello, does anyone here knows about catamorphisms that can give me a hand?
07:02:16 <Saulzar> Though hackage solution not _always_ the best one
07:02:21 <Cale> PatoCP: sure
07:02:35 <int-index> Is there a typeclass that defines `empty` such that `forall f . fmap f empty == empty`?
07:02:41 <Cale> PatoCP: Well, I can try. I'd have a better idea of whether I can be useful if I knew what your question was.
07:02:44 <SrPx> thanks
07:02:47 * mniip still coding furiously
07:02:58 <PatoCP> Cale,thank you. how do I PM you?
07:03:01 <c_wraith> int-index: shouldn't alternative follow that law?
07:03:27 <opqdonut> int-index: Alternative
07:03:28 <Cale> PatoCP: You could /query Cale and send me a message there, but why not ask in the channel? There are a lot of people here who know things about catamorphisms
07:03:43 <opqdonut> int-index: from Control.Applicative
07:04:23 <lpaste> mniip pasted “naturalComp” at http://lpaste.net/132618
07:04:29 <mniip> michi7x7, ^
07:05:07 <Cale> mniip: Did you see my implementation? :)
07:05:40 <mniip> Cale, does it work on "abc2" "abc11"
07:05:48 <Cale> ah, it doesn't attempt to
07:05:53 <Cale> But I could make it do so
07:06:07 <int-index> opqdonut: Alternative makes me define an Applicative instance, that's not always possible (e.g. Data.Map)
07:06:07 <mniip> you probably want 'groupBy isDigit' ?
07:06:20 <opqdonut> int-index: yeah
07:06:23 <mniip> no wait
07:06:38 <PatoCP> So, this is my problem. I have the following LeafTree data type:  "data LTree a = Leaf a | Fork (LTree a, LTree a)", and I need to define a "depth" function using a catamorphism. I have the recursion of the catamorphism done, but I can't seem to get the right "either"  to calculate the depth of the tree
07:06:44 <mniip> groupBy ((==) `on` isDigit)
07:06:51 <mniip> I thought there's a more elegant one...
07:08:20 <opqdonut> int-index: https://hackage.haskell.org/package/semigroupoids-4.5/docs/Data-Functor-Plus.html doesn't have the applicative instance, but does have a binary operation
07:08:21 <Cale> @let data LTree a = Leaf a | Fork (LTree a) (LTree a)
07:08:21 <michi7x7> you guys are insane
07:08:22 <lambdabot>  Defined.
07:08:34 <hodapp> michi7x7: NO U
07:08:55 <Cale> @let foldLTree l f = g where g (Leaf x) = l x; g (Fork t1 t2) = f (g t1) (g t2)
07:08:56 <lambdabot>  Defined.
07:10:03 <Cale> > foldLTree 0 (\t t' -> 1 + max t t') $ Fork (Fork (Leaf 1) (Leaf 2)) (Fork (Fork (Leaf 3) (Fork (Leaf 4) (Leaf 5))) (Leaf 6))
07:10:05 <lambdabot>      Could not deduce (Num t0)
07:10:05 <lambdabot>      from the context (Num t, Num t1, Num (t -> t1), Ord t1)
07:10:05 <lambdabot>        bound by the inferred type for ‘e_101123456’:
07:10:09 <Cale> whoops :)
07:10:45 <SrPx> But if I create a unboxed vector with all data I will waste *a lot of space*. Ideally, I would create a Vector (UVector Int) - but I don't want the GC to go inside the outer vector. Is there any way to do this
07:11:03 <Cale> oh, of course
07:11:09 <OutlawStar> Hello, can any one help me with my fmap declaration on line 14. I can't figure out what i need to do to apply the function to the value. I'm wondering i need to strip more layers from the value 'a'. (link: http://lpaste.net/1065908057055166464)
07:11:11 <Cale> > foldLTree (const 0) (\t t' -> 1 + max t t') $ Fork (Fork (Leaf 1) (Leaf 2)) (Fork (Fork (Leaf 3) (Fork (Leaf 4) (Leaf 5))) (Leaf 6))
07:11:12 <lambdabot>  4
07:11:21 <Cale> Thought for sure it was my parens
07:11:53 <Cale> PatoCP: What's the type of your cataLTree?
07:12:10 <int-index> opqdonut: that looks interesting
07:12:33 <Cale> PatoCP: My foldLTree is effectively the catamorphism for LTree, but in a useful form where it just takes the replacements for each constructor separately
07:13:24 <mniip> OutlawStar, x :: m (TmIO a)
07:13:29 <Cale> PatoCP: Depending on your setup, you might have one with a different type that corresponds more closely with the algebraic definition of a catamorphism as the unique algebra homomorphism out of an initial algebra.
07:13:32 <mniip> r :: a -> b
07:13:49 <mniip> fmap r :: m a -> m b, not m (TmIO a) -> m (TmIO b)
07:13:51 <Cale> <PatoCP> cataLTree :: (Either b (d, d) -> d) -> LTree b -> d
07:14:03 <Cale> all right...
07:14:43 <OutlawStar> miip, current, but I thought fmap would be invoked for the type of m (TmIO a) since m is also of type functor
07:14:56 <OutlawStar> miip: correct*
07:15:45 <Cale> @let cataLTree f = g where g (Leaf x) = f (Left x); g (Fork t t') -> f (Right (g t, g t'))
07:15:45 <lambdabot>  Parse failed: Parse error: ->
07:15:49 <Cale> @let cataLTree f = g where g (Leaf x) = f (Left x); g (Fork t t') = f (Right (g t, g t'))
07:15:51 <lambdabot>  Defined.
07:15:55 <Cale> :t cataLTree
07:15:56 <lambdabot> (Either a (t, t) -> t) -> LTree a -> t
07:16:36 <Cale> > cataLTree (\x -> case x of Left _ -> 0; Right t t' -> 1 + max t t') $ Fork (Fork (Leaf 1) (Leaf 2)) (Fork (Fork (Leaf 3) (Fork (Leaf 4) (Leaf 5))) (Leaf 6))
07:16:38 <lambdabot>      Constructor ‘Right’ should have 1 argument, but has been given 2
07:16:38 <lambdabot>      In the pattern: Right t t'
07:16:38 <lambdabot>      In a case alternative: Right t t' -> 1 + max t t'
07:16:42 <Cale> oops
07:16:47 <Cale> > cataLTree (\x -> case x of Left _ -> 0; Right (t, t') -> 1 + max t t') $ Fork (Fork (Leaf 1) (Leaf 2)) (Fork (Fork (Leaf 3) (Fork (Leaf 4) (Leaf 5))) (Leaf 6))
07:16:48 <lambdabot>  4
07:17:04 <Cale> PatoCP: ^^
07:17:08 <mniip> OutlawStar, do you run a recent-enough GHC?
07:17:15 <Cale> So, if you want to use either...
07:17:32 <OutlawStar> mniip: 7.8.4
07:17:46 <Cale> > cataLTree (either (const 0) (\(t, t') -> 1 + max t t')) $ Fork (Fork (Leaf 1) (Leaf 2)) (Fork (Fork (Leaf 3) (Fork (Leaf 4) (Leaf 5))) (Leaf 6))
07:17:47 <mniip> try replacing "let x' =  fmap r x" with "let x' =  fmap _r x"
07:17:48 <lambdabot>  4
07:17:52 <mniip> to see your mistake
07:19:46 <Cale> PatoCP: I tend to find it's sometimes easier just to define things by pattern matching or recursion before simplifying them using higher order functions if I don't understand the problem well enough yet.
07:19:56 <Cale> s/or/and/
07:20:14 <PatoCP> it works, but I can't understand the second argument
07:20:16 <PatoCP> of the either
07:20:29 <Cale> :t either
07:20:30 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
07:21:15 <Cale> either l r is the function which turns Left x into l x, and turns Right y into r y
07:21:45 <Cale> Here, we want to transform Left x into 0, regardless of what x is, so I supplied const 0 for the first argument
07:21:51 <OutlawStar> mniip: mm, not sure that told me anything  i didn't already know. is 'r where it = (a -> b)' not applicable to the value of x = m (TmIO a) since 'r' did not originate from being applied to x?
07:21:59 <Cale> and we want to transform Right (t,t') into 1 + max t t'
07:22:09 <mniip> OutlawStar, it should've told you the type of '_r'
07:22:13 <Cale> So, I supplied (\(t,t') -> 1 + max t t') as the second argument
07:22:45 <OutlawStar> mniip: ahh TmIO a -> b1
07:22:56 <mniip> yup
07:23:12 <mniip> more specifically, I believe, TmIO a -> TmIO b
07:23:19 <mniip> and your r is a -> b
07:23:34 <OutlawStar> right :(
07:23:40 <Cale> PatoCP: Does that help?
07:23:42 <PatoCP> I see. If I understand correctly, the left one is the "stop case", but what does the "\" notation mean in haskell
07:23:48 <Cale> Oh!
07:23:57 <OutlawStar> mniip: why isn't r (a -> b) in that case?
07:24:23 <Cale> PatoCP: (\x -> y) is the notation for lambda
07:24:51 <Cale> (\x -> y) is the function which given x, produces y as its result
07:24:55 <Cale> > (\x -> x*x) 5
07:24:57 <lambdabot>  25
07:25:06 <Cale> > map (\x -> x*x) [1..10]
07:25:07 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
07:25:07 <mniip> OutlawStar, the fmap you're declaring has type (a -> b) -> TmIOT m a -> TmIOT m b
07:25:20 <mniip> therefore x' has type m (TmIO b)
07:25:49 <mniip> therefore fmap you're using has type (TmIO a -> TmIO b) -> m TmIO a -> m TmIO b
07:26:37 <PatoCP> Ah, I see. Thank you very much for your help. I'll dive a little more into this to make sure I fully understand how it was done, but your solution works great :)
07:26:48 <ski> mniip : more brackets ?
07:27:22 <mniip> OutlawStar, actually, could you elaborate on your question? I'm not sure I am explaining the right thing
07:27:25 <OutlawStar> mniip: so even though 'm' derives functor and has type m (TmIO a), the type (a -> b) can not be applied to m (TmIO a) with fmap? does a chang in this case?
07:27:49 <mniip> OutlawStar, look at the type of fmap
07:28:25 <ski> mniip : i didn't follow it from the start. do they want to use `fmap' twice ?
07:28:30 <mniip> (x -> y) -> f x -> f y
07:29:12 <mniip> in your invocation, the result is of type 'm (TmIO a)', so 'f' is 'm' and 'y' is 'TmIO a'
07:29:21 <OutlawStar> (a -> b) -> f a -> f b, so (a -> b) -> TmIOT a -> TmIOT b, (a -> b) (TmIOT (m (TIO a)) -> ..., so i can't apply another fmap to "m (TIO a)" once i strip TmIOT?
07:29:29 <mniip> ski, I don't think they have a Functor TmIO instance
07:29:41 <coin3d> hi there. in the lyah book is the following snippet, which just prints the initials of a name: https://gist.github.com/anonymous/34d279046413b850a88e - i don't really understand how the (f:_) = firstname stuff works
07:30:04 <mniip> OutlawStar, not talking about that fmap
07:30:05 <ski> mniip : just looked at they paste. they do. it's derived
07:30:11 <mniip> oh
07:30:13 <mniip> derived functor
07:30:16 <OutlawStar> yes
07:30:21 <mniip> still
07:30:30 <coin3d> from what i understood before - using (f:_) , f should be the head element of a list, right? 
07:30:44 <mniip> ski, well they do want to use two fmaps, but I don't think they understand why
07:30:48 <Cale> coin3d: yeah
07:31:18 <OutlawStar> my end goal is to apply fmap to TmIOT. I thought that would require 2 fmaps
07:31:19 <ski> OutlawStar : look at `fmap r (TmIOT x) = ..r..x..'. you know `r :: a -> b' and `TmIOT x :: TmIOT m a', you want `..r..x.. :: TmIOT m b'. agree ?
07:31:21 <OutlawStar> if not thats fine
07:31:25 <mniip> OutlawStar, if you apply fmap to 'm (TmIO a)', you should provide a function of type 'TmIO a -> TmIO b'
07:31:33 <Cale> coin3d: Note that this function will fall on its face if either list is empty.
07:31:56 <mniip> fmap takes care of m
07:31:59 <mniip> but not TmIO
07:32:09 <coin3d> Cale: why is it required to put the f in brackets then, if f already represents the first letter? 
07:32:22 <Cale> coin3d: You mean [f]?
07:32:24 <coin3d> right
07:32:36 <Cale> [f] is the one-element list whose sole element is f
07:32:36 <mniip> [f] and (f:_) are different things
07:32:57 <mniip> [f] is syntactic sugar for (f:[])
07:33:15 <Cale> Here f is the first character of firstname, so [f] is a one-character String consisting of just that character
07:33:16 <ski> coin3d : in fact, `(f:_) = firstname' could be written simply as `f:_ = firstname'. similarly for `(l:_) = lastname'
07:33:26 <OutlawStar> ski: i think so? Had a little trouble following ur explanation
07:33:54 <OutlawStar> mniip: ahh, your last explanation makes sense
07:34:47 <ski> OutlawStar : in general. for `Functor f', we have `fmap :: (a -> b) -> f a -> f b'. in your case, `f' is `TmIOT m'. hence in your case, `fmap :: (a -> b) -> TmIOT m a -> TmIOT m b'. what i said above about the types of the arguments and expected type of the result follows from this type signature for `fmap'
07:34:51 <OutlawStar> mniip: how would i strip 'm', is that even possible with what i have?
07:35:00 <coin3d> ahh, ok
07:35:02 <coin3d> thanks
07:35:14 <mniip> OutlawStar, with fmap
07:35:50 <guest66878> @undo do n <- many1 digit; return (read n)
07:35:50 <lambdabot> many1 digit >>= \ n -> return (read n)
07:35:52 <Big_G> Is swagger the defacto way of exporting models in Haskell?
07:35:57 <mniip> think like this, you need a function of type 'm TmIO a -> m TmIO b'
07:36:04 <mniip> so, fmap ? x
07:36:23 <mniip> where ? is of the type 'TmIO a -> TmIO b'
07:36:32 <mniip> but TmIO is of Fucntor typeclass, so
07:36:35 <Cale> Big_G: I've never heard of swagger. What's a model in this context?
07:36:37 <OutlawStar> mniip: yes, is that possible right now?
07:36:37 <mniip> fmap (fmap ?) x
07:36:46 <mniip> where ? is now of type a -> b
07:36:50 <mniip> but hey you have that!
07:36:52 <Big_G> Cale, Basically a datatype. Similar to a schema for a db
07:36:53 <ski> OutlawStar : you have a function `r :: a -> b'. if you use `fmap' once, you get `fmap r :: TmIO a -> TmIO b' (using the fact that `Functor TmIO'). if you use it yet again, you get `fmap (fmap r) :: m (TmIO a) -> m (TmIO b)' (using the fact that `Functor m', coming from `instance Functor m => Functor (TmIOT m)')
07:37:08 <ski> mniip : please, more brackets
07:37:19 <mniip> ski, []?
07:37:28 <ski> mniip : not `m TmIO a -> m TmIO b', but `m (TmIO a) -> m (TmIO b)'
07:37:34 <mniip> oi
07:37:35 <mniip> true
07:37:45 <mniip> also those are parentheses to be precise
07:37:51 <ski> round brackets, yes
07:38:03 <OutlawStar> mniip: Eureka! that worked
07:38:21 <mniip> ski, quartercircles
07:38:30 <OutlawStar> thx mniip and ski, now to tackle applicative!
07:38:56 <mniip> hold on
07:39:14 <mniip> ah right, it's a newtype, nevermind
07:41:16 <Cale> Big_G: Looking at it, I'm not sure what I'd use any of this for. :D  I guess generating some sort of documentation for a web API?
07:41:49 <Big_G> Cale, Mainly for parsing repsonses from a RESTful API and making sure your data models match theirs
07:42:40 <Cale> Big_G: If a client doesn't know what the API is already, how does the model help at all?
07:43:06 <Big_G> Cale, gtg to wrk
07:43:09 <Cale> hm
07:46:36 <adas> I installed ghc 7.8.4 from the "hvr" ppa. It is supposed to be installed in /opt/ghc .. i am able to access the binary "ghc".. but I cannot find the documentation for the libraries installed with "ghc". Could someone please help?
07:47:38 <Cale> adas: At the very least you can use https://downloads.haskell.org/~ghc/7.8.4/docs/html/libraries/index.html
07:48:14 <Cale> I don't know where in particular that package stores the documentation. Maybe apt-file or some dpkg invokation could tell you
07:49:03 <Cale> dpkg -L <packagename> | grep html  or something
07:50:30 <adas> Cale: Could you please tell me, how you access documentation normally?
07:51:21 <michaelt> adas maybe " locate Monad.html "  ... is there something like /opt/share/doc ... or /opt/ghc/share/doc ...
07:52:12 <Cale> adas: Usually my web browser
07:52:27 <Cale> adas: I just bookmark the documentation of my most frequently used libraries.
07:52:35 <michaelt> adas file:///Users/michaelt/h/share/doc/ghc/html/index.html in chrome ...
07:52:41 <Cale> adas: and everything else I get to through Hackage's package list
07:52:49 <Cale> http://hackage.haskell.org/packages/
07:52:56 <Cale> there's a package search at the top
07:53:23 <Cale> (it still bothers me that the package search doesn't sort exact matches first)
07:54:21 <jgcoded> Is there any hope of updating the haskell stuff in the Ubuntu package universe in the near future?
07:54:57 <ion> jgcoded: I just ignore that and do this. https://gist.github.com/ion1/2815423
07:55:57 <michaelt> adas, some package managers used to have a separate package for ghc-doc or something like that ; I can't tell what hvr is doing.
07:56:48 <michaelt> adas e.g. https://packages.debian.org/sid/ghc-doc
07:59:02 * hackagebot nested-routes 2.1.0 - Declarative, compositional Wai responses  http://hackage.haskell.org/package/nested-routes-2.1.0 (athanclark)
08:01:35 <adas> the libraries links are useful. I think i can go with that
08:05:46 <ttt_fff> I know that there are libraries for solving LP (linear programming) problems in Haskell. I am wondering: are tehre are haskell libraries that solve problems like LP, but there are also min/max constraints, i.e. a = max(b,c)
08:09:34 <mrkkrp> What is idiomatic way to write ‘e’ number in Haskell? Is it defined somewhere?
08:10:08 <ziman> > exp 1
08:10:09 <lambdabot>  2.718281828459045
08:10:39 <mrkkrp> Well, if it's the only way, OK, thanks.
08:10:50 <maerwald> mrkkrp: e = exp 1
08:10:54 <maerwald> what's the problem :)
08:10:59 <mrkkrp> :-)
08:12:58 <fvgvxmpv1> > :t exp
08:13:00 <lambdabot>  <hint>:1:1: parse error on input ‘:’
08:13:28 <fvgvxmpv1> :(
08:15:03 <adas> Cale: has the docs in seperate package. apt-get install ghc-7.8.4-htmldocs
08:15:06 <maerwald> @type exp
08:15:06 <adas> thanks
08:15:07 <lambdabot> Floating a => a -> a
08:15:07 <igniting> @type exp
08:15:08 <lambdabot> Floating a => a -> a
08:17:17 <pchiusano> what is the recommended way to work around the restriction that a cabal build can only have a single library?
08:20:16 <hexagoxel> pchiusano: i'd say: multiple packages; use a sandbox and add-source all dependencies you work on at the same time
08:21:11 <pchiusano> hexagoxel: what is 'add-source'
08:23:24 <hexagoxel> pchiusano: a way to tell cabal to use/build more than one local package (directory), see "cabal help sandbox"
08:23:38 <pchiusano> okay, cool, thanks! will check that out
08:24:03 <pchiusano> it looks like this has a nice explanation http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
08:25:31 <pchiusano> hexagoxel: what is the reason to use add-source vs just a shared sandbox
08:25:48 <ttt_fff> is there a way to interface ipython haskell ?
08:26:38 <geekosaur> ttt_fff: http://hackage.haskell.org/package/ihaskell ?
08:26:53 <ttt_fff> let me reaphrase my question:
08:27:08 <quchen> ReinH: Now that I'm not on the train with a rather bad internet connection anymore, I realize the paper you linked me yesterday was the standard STG paper, which is where my question came from in the first place ;-)
08:27:19 <ttt_fff> I am writing an app in Haskell. Ineed to be able to do convex programming. I would like to use the convex programming powers of iPython. How do I get haskell / iPython to talk to each other so my haskell code can use convex programming powers of ipython ?
08:27:20 <hexagoxel> pchiusano: automatic re-building. if you have package X, depending on Y, you go to X's directory, add-source Y's directory. now if you make a change to Y's code, and start a build in X, it automatically re-installs the dependency
08:27:24 <quchen> It mentions what "tagless" means, but never mentions anything about "spineless"
08:28:57 <hexagoxel> pchiusano: most of the time that is; sometimes i have to manually re-install dependencies. might be caused by switching git branches though.
08:30:54 <pchiusano> hexagoxel: okay, cool, that makes sense
08:38:15 <NemesisD> using cabal freeze should significantly speed up the cabal dependency solver on large dependency sets when adding or updating new dependencies right?
08:47:17 <kirill`> How do I import a hidden module from a package? OpenGL package hides a certain data constructor (shader program ID) that I need, which I think is a mistake. Is there some workaround?
08:48:02 <mizu_no_oto> kirill: You should look into the gl package
08:48:24 <mizu_no_oto> kirill`: https://hackage.haskell.org/package/gl
08:49:01 <glguy> kirill`: As far as I know your choices are to recompile the package, use Template Haskell, or use gl
08:49:14 <mizu_no_oto> It was created mostly because OpenGL doesn't actually export everything you need, and doesn't provide an escape hatch
08:49:41 <k0ral> when using conduit, can one detect the termination of the input stream ?
08:50:49 <kirill`> If gl different from OpenGLRaw?
08:50:49 <mizu_no_oto> kirill`: see https://www.reddit.com/r/haskell/comments/2uoton/edward_kmett_encapsulation_vs_code_reuse/
08:50:57 <mizu_no_oto> Yes, it is
08:51:31 <mizu_no_oto> gl is mostly autogenerated code based off of the official OpenGL spec, so it's incredibly complete
08:52:15 <mizu_no_oto> At one point recently, it was actually more complete than the C++ bindings
08:53:07 <mizu_no_oto> iirc, it uses the same names as in the official documentation, and has links to the official documentation everywhere
08:53:47 <mizu_no_oto> The idea being that it makes it easier to use non-Haskell OpenGL resources, but edwardk could talk more about it
08:53:59 <hodapp> I should give this a watch
08:54:16 <hodapp> I am a fan - in certain instances - of autogenerated code from specifications
08:54:46 <kirill`> So are there more issues with OpenGL that I don't know about? So far I've only found it difficult to set a float uniform. And most of its wrapping seems to be about stripping the "gl" prefix, which doesn't seem too bad.
08:56:28 <kirill`> glguy: I see, thanks.
08:59:47 <mizu_no_oto> kirill`: from what I understand, the issue with OpenGL is that it's very incomplete and it's also inextensible.
09:00:55 <hodapp> mizu_no_oto: Incomplete in what sense?
09:04:25 <mizu_no_oto> hodapp: Doesn't offer everything in the standard.
09:06:30 <Ryanar> Writing a datatype like data (Data a) = Var String | Lambda String (Data a) //// could you instead say data Data = Var String | Lambda String Data
09:06:34 <Ryanar> what is the point of the a?
09:08:11 <rasen_> In that case -- there is no sense in a
09:08:32 <mizu_no_oto> Ryanar: lowercase names in datatype definitions are type variables
09:08:46 <rasen_> Maybe the constructors should be extened to include a as parameter
09:09:07 <mizu_no_oto> That's kinda like class Data<A> { ... } in Java
09:09:26 <rasen_> Aren't you reading something on GADTs?
09:09:32 <mizu_no_oto> Ryanar, rasen_: In that case, it looks like a is a 'phantom' type parameter
09:09:41 <glguy> Ryanar: The type variable could be used to tag Data Int from Data Bool to just keep things straight
09:10:43 <Ryanar> in this case Data was an arbitrary name I chose
09:10:53 <Ryanar> let me show you the actual definitions..
09:10:54 <rasen_> Yeah. But in that case, tag is not bound. Maybe it is going to be bound in functions though
09:11:24 <mizu_no_oto> For example, you can say something like data UserInput a = UserInput String and then have a function escapeBadStuff :: UserInput Unvalidated -> UserInput Validated
09:11:47 <lpaste> ryanar pasted “is the 'a' useless here?” at http://lpaste.net/7742359913241772032
09:11:50 <kirill`> hodapp: https://github.com/haskell-opengl/OpenGL/issues
09:12:21 <Ryanar> is that not showing up?
09:12:52 <Ryanar> http://lpaste.net/308826586877001728
09:12:57 <Ryanar> here is a different version
09:13:30 <rasen_> Where did you get this code from?
09:14:33 <Ryanar> i wrote it
09:14:39 <Ryanar> and it works fine
09:14:46 <rasen_> Ok. a is useless
09:14:50 <Ryanar> alright
09:14:57 <Ryanar> that is what I thought
09:15:01 <Ryanar> my friend asked me why I was using a
09:15:04 <Ryanar> and I couldnt answer him
09:15:11 <Ryanar> so I figured I would ask
09:15:54 <Drogadito> Hello, can anyone help me with balancing trees/ anamorphism?
09:16:39 <rasen_> Drogadito: ask
09:18:50 <Drogadito> I have to write a single haskell function to balance a tree, using an anamorphism. This is the data type : data LTree a = Leaf a | Fork (LTree a, LTree a). I already have the anamorphism defined and I have a function to convert trees-> list, if needed. I'm having trouble in "gluing" them
09:19:05 * hackagebot propellor 2.4.0 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-2.4.0 (JoeyHess)
09:20:20 <dmj`> why can't ghc derive this MonadTrans instance? {-# LANGUAGE StandaloneDeriving      #-}                                                                                                                                          
09:20:20 <dmj`> {-# LANGUAGE GeneralizedNewtypeDeriving #-}                                                                                                                                       
09:20:20 <dmj`> module Main where                                                                                                                                                                 
09:20:20 <dmj`> import Control.Monad.Trans.Class                                                                                                                                                  
09:20:23 <dmj`> import Control.Monad.Trans.State                                                                                                                                                  
09:21:29 <notdan> Drogadito: why do youneed to convert trees to lists?
09:21:45 <Ryanar> Drogadito, so you want to write a fold that flattens the tree into a list?
09:22:13 <notdan> he mentioned that he has to use an unfold
09:22:31 <Drogadito> I'm not sure if I need to, it's just what I have so far, because I'm kinda lost, forget about it if needed. The point is to balance a tree using an anamorphism
09:23:55 <Ryanar> https://www.seas.upenn.edu/~cis194/spring13/lectures/07-folds-monoids.html
09:24:03 <Ryanar> here is an example of flattening a tree using folds
09:24:40 <notdan> So you have something like ana :: (b -> Maybe (a,b)) -> b -> LTree b ?
09:25:15 <notdan> erm *LTree a
09:26:34 <Drogadito> I have this: anaLTree f = inLTree . (recLTree (anaLTree f) ) . f
09:26:44 <Drogadito> recLTree f = id -|- (f >< f)
09:26:51 <maerwald> that's a weird name for a tree
09:26:55 <nabokovian> indeed
09:27:09 <Drogadito> my professor is nasty :O
09:27:11 <michaelchurch> I have a question here about Lazy ByteString -> Lazy Text conversion.
09:27:11 <notdan> Drogadito: right, but what is the type for anaLTree?
09:27:26 <michaelchurch> I've discovered (via memory leak) that encodeUtf8 is strict.
09:27:28 <notdan> Sorry I forgot all the weird banana notation
09:27:33 <Drogadito> anaLTree :: (c -> Either a (c, c)) -> c -> LTree a
09:27:49 <michaelchurch> If I use encodeUtf8With lenientDecode, I find that it remains strict. What's the "canonical" way to make it lazy?
09:28:43 <rayqiu> I have a question on Free Monad, and would appreciate if someone could help to answer it.  How is fail implemented in Free Monad?  If I wrap an ExceptT on top of the Free monad, the example in the package for Retry will not work if I replace fail with throwE (will be kicked to IO monad instead of retrying)
09:29:06 <rayqiu> The example in the package uses fail when retry is needed
09:30:23 <rayqiu> it is: run Retry = fail "forced retry" - if changed to run Retry = throwE "forced retry", will not work
09:31:01 <michaelchurch> \quit
09:31:16 <michaelchurch> (sorry, still new to IRC commands)
09:32:08 <Cale> rayqiu: Generally fail is not implemented.
09:32:12 <absence> why would my code run faster when i import bimap from Control.Lens instead of Data.Bifunctor?
09:32:31 <Cale> rayqiu: For the most part, I recommend just ignoring the existence of fail, insofar as it's possible to do so.
09:33:00 <Cale> rayqiu: It's not part of the formal definition of a Monad, and its inclusion in the Monad type class is a pretty regrettable historical accident.
09:34:19 <rayqiu> @Cale, yes, I understand this part, but what does the code: fail "forced retry" do?  
09:34:19 <lambdabot> Unknown command, try @list
09:34:56 <Cale> ah, well, they're using the fail of some other monad, I don't know which from that code you gave
09:35:13 <Cale> It depends on how fail is implemented for that monad.
09:35:14 <c_wraith> with a name like "forced retry" I'd wonder if it's STM
09:35:22 <rayqiu> It is the Free Monad, basically FreeT over Identity
09:35:29 <c_wraith> In which case fail is a *terrible* way to retry
09:35:33 <Cale> er
09:35:54 <rayqiu> Let me try to post the code 
09:36:02 <rien_> what's a quick guide I can read on how to use cabal with haskell platform so I'm never in a bind? (never use the global namespace etc)
09:36:03 <Cale> rayqiu: Then I guess it's another way of writing  error "forced retry"
09:36:13 <Cale> rayqiu: i.e. just crash the program with an error message
09:36:47 <rayqiu> @Cale, the strange thing is: if it is set to error "forced retry", then retry fails, it will be kicked to IO Monad as an Exception
09:36:47 <lambdabot> Unknown command, try @list
09:36:47 <c_wraith> FreeT can't have an implementation other than error, really
09:37:24 <Cale> rayqiu: What is the type of run?
09:37:39 <rayqiu> http://lpaste.net/132623
09:38:03 <Cale> Oh, it's using ExceptT
09:38:10 <Cale> which implements fail in another way
09:38:34 <rayqiu> It is the same if I remove ExceptT
09:38:47 <Cale> What do you mean remove it?
09:39:24 <rayqiu> the example is listed here: https://hackage.haskell.org/package/free-4.11/docs/examples/RetryTH.hs
09:39:25 <hexagoxel> does ghc default to `--make` (when you give it only a file as param or smth?)
09:40:07 <rayqiu> If I remove ExceptT and only use the original Free Monad, the retry part works the same
09:40:16 <c_wraith> hexagoxel: it has since about GHC 7.6
09:40:26 <Cale> rayqiu: Okay, so there it's using the fail of an arbitrary Monad instance. I don't generally recommend doing that.
09:40:28 <rayqiu> only works when use fail, not error or throwE, which is confusing to me
09:40:34 <geekosaur> well before that, I think
09:40:47 <c_wraith> Maybe 7.2?
09:40:50 <Cale> You could use  liftIO (throwIO "invalid input")
09:41:07 <Cale> because the m is guaranteed to be an instance of MonadIO there
09:41:27 <Cale> oh, er, might want to make a proper exception type
09:41:34 <rayqiu> sure, i could use throwE for run (Input next), but the problem is for run Retry
09:41:36 <hexagoxel> c_wraith: that should be mentioned on the manpage somewhere..
09:41:38 <medfly> hey
09:42:59 <geekosaur> 7.0, looks like
09:43:46 <rayqiu> http://lpaste.net/132624
09:47:42 <rayqiu> @Cale, run results here: http://lpaste.net/132625
09:47:43 <lambdabot> Unknown command, try @list
09:48:08 <Cale> btw, if you want the bot to stop replying to you, don't put the @ sign there
09:48:27 <rayqiu> sorry, got it
09:49:49 <Cale> ah, fail = ExceptT . fail
09:51:59 <rayqiu> yes, but in this example how does it make a difference?
09:53:17 <rayqiu> throwE almost has the same type signature for the return value? throwE :: Monad m => e -> ExceptT e m a 
09:53:27 <rayqiu> (ExceptT . fail) :: Monad m => String -> ExceptT e m a
09:53:36 <Cale> Yeah, the type signature doesn't tell you much of anything about how it works.
09:54:18 <rayqiu> right, how to get to the bottom of the implementation of fail then?
09:54:37 <Cale> ExceptT :: m (Either e a) -> ExceptT e m a
09:54:49 <Cale> So fail is using the fail for the monad m
09:55:51 <rayqiu> in this case, it is IO
09:55:56 <Cale> While throwE = ExceptT . return . Left
09:56:11 <Cale> So  throwE "blah" = ExceptT (return (Left "blah"))
09:56:21 <Cale> while  fail "blah" = ExceptT (fail "blah")
09:57:13 <Cale> and fail for IO throws an IO exception
09:57:16 <dfeuer> fail fails.
09:57:21 <Cale> (it actually fails)
09:57:51 <dfeuer> It pretty much never made much sense.
09:58:04 <Cale> You basically shouldn't ever use fail
09:58:14 <rayqiu> ok, why withRetry can retry when it fails
09:58:16 <Cale> as in, it shouldn't appear in your code
09:59:21 <dfeuer> It was a terrible partial solution to a not-really problem.
09:59:42 <rayqiu> It is in the example of the Monad.TH package, I was trying to refactor it to something else, but it only worked with fail not throwE or error
10:01:56 <Cale> rayqiu: Well, it's using msum in one place, which for IO will catch exceptions.
10:02:08 <Cale> oh, but that's with runMaybeT
10:02:18 <Cale> ugh
10:02:22 <Cale> What is this code?
10:02:39 <rayqiu> https://hackage.haskell.org/package/free-4.11/docs/examples/RetryTH.hs
10:03:38 <athan> What does "free"-ness mean, precisely?
10:03:51 <rayqiu> if you replace run Retry = fail "forced retry" to run Retry = throwE (or error) ..., then it will not retry (exception kicks in)
10:03:53 <Cale> athan: I'll explain that in a moment, the explanation is involved.
10:04:06 <athan> Thank you Cale :)
10:04:56 <hodapp> hmmm, so I'm trying to make this typeclass function apply over type "M1 S c f", and now I'm seeing that I must specialize it to have different behavior for "M1 S NoSelector f", but it doesn't appear to have any visible constructor, so I cannot pattern match
10:05:08 <Cale> rayqiu: Try replacing it with  liftIO (throwIO (ErrorCall "forced retry"))
10:05:10 <hodapp> and I don't know how else to do this without overlapping instances...
10:05:21 <hodapp> 'c' is under the constraint (Selector c) in the former case
10:05:24 <rayqiu> let me give it a try, thanks Cale
10:05:46 <Cale> rayqiu: I believe that should do the same thing. I don't know why they're using fail there.
10:05:51 <hodapp> and no other instances of Selector are visible - just NoSelector
10:06:26 <Cale> rayqiu: Oh, I see
10:07:19 <rayqiu> Cale, the exception kicks in, cannot retry
10:07:19 <Cale> rayqiu: I think they're using polymorphic recursion... see the  runMaybeT . F.msum $ repeat (runRetry block) ?
10:07:54 <Cale> That's using runRetry at a different type than it's originally being applied at.
10:08:12 <Cale> In particular, the fail inside that will be the fail for *MaybeT*
10:08:33 <Cale> fail _ = MaybeT (return Nothing)
10:09:03 <rayqiu> oh
10:09:07 <Cale> In short, this example program is needlessly hard to understand, and I have no idea why it was written like that.
10:09:27 <rayqiu> got it, thanks Cale!
10:09:32 <hodapp> if I have access to type variable 'c', and I want to handle one specific case, I suppose I could use... a type family? I'm not sure
10:09:52 <Cale> hodapp: I'm not sure what you mean by "have access to"
10:10:09 <hodapp> Cale: well, I am writing a function for which 'c' is in scope, I suppose
10:10:46 <Cale> hodapp: If you have a function which is parametrically polymorphic in some type c, it is not allowed to change its implementation depending on which type c is.
10:11:14 <johnw> Cale: that's a good way of putting it
10:11:15 <Cale> hodapp: (the function is actually only compiled once, and the same code is executed for every type)
10:11:28 <johnw> it's behavior must remain invariant over all choices of 'c'
10:11:39 <Cale> hodapp: If you want different behaviour for different choices of type, then that's what type classes are for.
10:11:55 <ReinH> johnw: that's the "uniform" property :)
10:12:22 <hodapp> Cale: I might just do the crufty solution of just checking if selName is an empty string. This seems to be what Generics.Generic.Aeson.Util does.
10:13:05 <hodapp> Cale: http://hackage.haskell.org/package/base-4.8.0.0/docs/GHC-Generics.html#t:Selector is what I'm trying to work with (handling the NoSelector case differently)
10:13:55 <hodapp> selName will run with NoSelector, it simply returns an empty string.
10:14:20 <Cale> Right, apparently the only instance of that type class is for NoSelector
10:14:23 <ReinH> Why not use a sum type to represent the kinds of thinks c can be?
10:14:27 <ReinH> *things
10:14:47 <Cale> oh, just the only built in one
10:15:02 <hodapp> Cale: yes, and the only one I can really name
10:15:33 <hodapp> ReinH: I'm not sure if that's an option here
10:15:50 <hodapp> ReinH: for one thing I don't *know* what it can be, except that it might be of type NoSelector
10:16:33 <ReinH> Either NoSelector c ?
10:17:10 <hodapp> I'm not sure if I can do any of this and still have this all remain as instances of the proper typeclasses to let me interface to GHC.Generics
10:19:31 <hodapp> and I suspect that's why we see this: http://hackage.haskell.org/package/generic-aeson-0.2.0.5/docs/src/Generics-Generic-Aeson-Util.html#selNameT
10:20:02 <hodapp> matching on empty string at run-time rather than trying to handle NoSelector
10:20:26 <athan> Cale: Maybe another time might be best, my internet isn't reliable :(
10:20:33 <Cale> athan: oh, right, sorry
10:21:16 <hodapp> not sure what other option I have, except overlapping typeclass instances
10:21:26 <johnw> athan: are you using Google's balloon network deep in the outback?
10:21:45 <Cale> athan: Anyway, the definition of 'free' is pretty much 'is in the image of a functor which is left adjoint to a forgetful functor'
10:23:02 <Cale> athan: But in order to make sense of that, you have to understand adjunctions, and then to make sense of it for monads, you need to understand which adjunction is being used.
10:23:45 <absence> with a simple test case using bimap, i get the same core whether i import from Control.Lens or from Data.Bifunctor, but in complex code there's quite a bit of difference in both the core and the performance. could it have something to do with the number of levels of inlining? can i control that?
10:26:52 <Cale> athan: There's a functor from the category of monads and monad homomorphisms on C to the category of endofunctors and natural transformations on C, which assigns to each monad T on C its underlying endofunctor |T|. For every natural transformation F -> |T| where F is an arbitrary endofunctor, and |T| is the underlying endofunctor of a monad T, there is a unique monad homomorphism F* -> T where F* is the free monad on F.
10:27:21 <Cale> Properties of this form are used to define "free" objects throughout mathematics.
10:28:22 <Cale> e.g. there is a "forgetful" functor from the category of groups and group homomorphisms to the category of sets and functions which assigns to each group its underlying set (and each group homomorphism its underlying function)
10:29:24 <johnw> so, the forgetful functor would (in theory) strip away the definition of some 'm' as a Monad, seeing it now only as a Functor; while the free functor lets you treat 'm' as a Monad, even if it's only a Functor
10:29:35 <Cale> and there is a "free group functor" such that if X is any set and G is any group, then there's a natural correspondence between the functions X -> |G| and the group homomorphisms X* -> G, where X* is the free group on X.
10:30:10 <hodapp> Someone had said that I could use GHC.Generics also to get some custom compile-time errors; could anyone point to any examples of this?
10:31:10 <hodapp> I know specifically what case my code is not meant to handle (multiple constructors) and how to match on it, and it gives a compile-time error now, but not really a comprehensible one
10:31:23 <dfeuer> Cale, does anything interesting happen when you look at the free group of a group?
10:32:02 <Cale> Free group of a *group*?
10:32:21 <dfeuer> Cale, of the underlying set of a group.
10:32:24 <Cale> Yes
10:32:30 <Cale> (in that case)
10:32:47 <Cale> If F is left adjoint to G, then FG is a comonad, and GF is a monad.
10:33:10 <johnw> dfeuer: in terms of monoids, that's what a list of integers is, for Sum
10:33:35 <dfeuer> johnw, yeah, I've been thinking about just such things a lot, but I know very little of the math.
10:33:50 <johnw> since I come from a compiler background, I think of Free objects as ASTs
10:33:52 <athan> Cale: Holy crap thank you!!
10:34:20 <Cale> It kind of sucks that F and G are such standard names for the functors involved when we want to talk about groups (which are usually called G) :P
10:34:50 <dfeuer> johnw, I've done pretty well playing with the free magmas and free semigroups, but once it gets to monoids ... things seem to get messy, probably because I'm structuring something badly.
10:34:55 <johnw> the free group is the AST for every group, meaning I can write an evaluator to get the result I would have gotten from using any particular group
10:35:30 <Cale> But anyway, if we have some group A, then F(GA) will be a group whose elements look like words consisting of a sequence of elements of the underlying set of A and *formal* inverses of those.
10:35:36 * hodapp goes to dig in logs for whoever told him GHC.Generics could do this
10:35:44 <johnw> i.e., (getSum . mconcat . map Sum) [1, 3, 4, 5]
10:35:58 <johnw> this combines an evaluator and an AST of sorts to represent Sum 1 <> Sum 3 <> ...
10:36:09 <dfeuer> For the semigroup/magma stuff, the "evaluation" turned out to be the (unique) retraction of the canonical injection (or whatever it's called) from the set to the free whatever. I imagine that is always the case?
10:36:31 <johnw> i don't know what unique retraction and canonical injection mean
10:36:36 <dfeuer> Arright.
10:36:38 <dfeuer> So you have
10:36:47 <dfeuer> a function from the set to the free group over that set.
10:36:48 <Cale> Or more generally, FX for an arbitrary set X will be a group whose elements are funny lists of elements of X and formal inverses of those elements
10:37:04 <dfeuer> And if the set is the underlying set of a group,
10:37:21 <dfeuer> you can show that function is a homomorphism.
10:37:39 <dfeuer> This function taking an element to the "word" representing it.
10:37:52 <dfeuer> Then you can look at left inverses of that function.
10:38:00 <dfeuer> Exactly one of those will be a group homomorphism.
10:38:03 <Cale> So there's a natural "evaluation" map F(GA) -> A, which takes this word and applies the inverse and multiplication according to the group A
10:38:25 <marolation> hey guys, using the Data.map how can I create a map in which the values are int but the values are lists?
10:38:28 <johnw> Cale: is there a name for that map?
10:38:32 <dfeuer> Cale, how do you deal with the identities?
10:38:38 <jplatte> Hi again :)
10:38:38 <jplatte> I am reimplementing some C++ stuff in Haskell, and I'm a bit lost figuring out how to (if at all) differentiate between the members that have a const qualifier in my C++ classes and the member that don't.
10:38:38 <jplatte> For example, I have a class "Match" with some members that are basically the match's metadata (doesn't change after creating the object, so they are const-qualified) and some more members that are mutable and represent the match's state (which player's turn, the positions of pieces on the board, ...).
10:38:38 <jplatte> I've read about the State monad before and thought that might be something I could maybe use here, but I'm really not sure and didn't fully understand it...
10:38:38 <jplatte> So yeah, can the State monad be helpful for me in this scenario? And / or would it be normal to have multiple functions that have a Match as argument and return a just slightly different Match (with most parts of the old Match just being passed on into the new Match constructor)?
10:38:41 <dfeuer> That's where I kind of got a bit stuckish.
10:38:51 <Cale> johnw: It's usually called epsilon
10:39:02 <ReinH> marolation: if you want the values to be lists of Int then use [Int] as your value type
10:39:13 <dfeuer> jplatte, don't try to convert C++ code to Haskell. You will regret it.
10:39:14 <Cale> dfeuer: The empty word will be sent to the identity of A
10:39:20 <johnw> jplatte: a code example helps better than a description
10:39:36 <hodapp> oh, it was bennofs, and he's gone
10:39:50 <hodapp> 2015-05-06 12:39:56 bennofs hodapp: with generics, you can even generate your own type errors at compile time!
10:40:14 <johnw> hodapp: I'd like to see an example of that technique too
10:40:32 <hodapp> johnw: we'll have to chase him down later with pitchforks
10:40:49 <jplatte> dfeuer: I know, that's why I said "reimplement", not "translate", and asked if I should try to split metadata and state data at all
10:41:22 <dfeuer> Cale, I think I wasn't really being clear enough. I'm hoping to use free semigroup stuff to implement free monoid stuff, and free monoid stuff to implement free group stuff, and ... I get dizzy.
10:41:32 <Cale> jplatte: The way to recognise cases where the State monad is useful is to look for cases where you have functions that both have a parameter of some type s, and produce a result of some type which looks like (s,a) for some type a, where you're carrying along this value of type s whose value changes over the course of your algorithm
10:41:39 <ReinH> > M.empty :: M.Map Int [Double] -- marolation
10:41:41 <lambdabot>  fromList []
10:42:07 <xandaros1> Got a question: If a is a record, I can "change" individual values with: "a {someField = newValue}". Can I do something similar, if a is in a functor, like a Maybe?
10:42:07 <dfeuer> jplatte, it's generally tricky to say, because programs in Haskell tend to be structured *very* differently from programs in C++.
10:42:14 <ReinH> dfeuer: The free monoid from a semigroup is just the semigroup with an adjoined identity element
10:42:16 <Cale> jplatte: If you don't see something which looks at least vaguely like s -> (s,a) in a possible implementation of your program, then the State monad isn't going to help.
10:42:21 <KaneTW> :t negate
10:42:22 <lambdabot> Num a => a -> a
10:42:38 <dfeuer> ReinH, exactly; what's the mathematical term/concept behind that "adjoining" process? 
10:42:44 <Cale> xandaros1: no? Certainly not for a functor in general...
10:42:50 <dfeuer> Where can I read about its properties?
10:43:19 <Cale> xandaros1: unless I misunderstand you -- you *can* write fmap (\a -> a { ... })
10:43:36 <dfeuer> Cale, reading C++ code, you'll probably see that *everywhere*, and soon you'll be lensing State.
10:43:45 <xandaros> Cale: That is what I want, yes, but it looks a bit convoluted
10:43:53 <xandaros> Was hoping for a better way
10:43:55 <marolation> Reinh, it keeps telling me that Couldn't match type Double with Char
10:44:02 <Cale> dfeuer: I don't know about that...
10:44:07 <ReinH> marolation: well, I'm just giving you what you asked for.
10:44:10 <ReinH> Maybe you didn't ask for the right thing.
10:44:21 <ReinH> You didn't say anything about Char
10:45:20 <dfeuer> jplatte, my point is that if you're thinking about rewriting the program in Haskell, you may be best off mentally trying to reset everything and start the design process from scratch. Once you get into implementation details, you may find yourself reusing some pieces.
10:45:33 <Cale> dfeuer: When I translate imperative code to Haskell, I usually translate first to a form which isn't quite like the state monad, but instead has a function for each continuation of the imperative program, that has all the mutable variables in scope as function parameters, but doesn't necessarily return any part of that
10:45:45 <marolation> I just imported Data.Map and created an empty map just like you told me, but it seems its already specting a [Char] when I add things to the map
10:45:58 <muzzle> hi, how can i construct an Word32 from four Word8
10:45:59 <muzzle> ?
10:46:00 <Cale> dfeuer: Instead, these functions just apply each other in a mutually recursive way, according to the control flow of the imperative code.
10:46:22 <muzzle> an Int would also suffice
10:46:37 <Cale> This results in a horrible mess initially, but it's usually easy enough to simplify in a mechanical way
10:46:38 <marolation> let data = M.insert 1 [1.0,2.0,40.0] emptyMap
10:46:53 <dfeuer> Cale, this sounds very state-machine-ish. Very useful when programming in the small, but I would think trying to do anything too large would lead to a nightmare.
10:46:54 <ReinH> dfeuer: Hmm, I'm not sure this construction is free
10:47:07 <Cale> dfeuer: Yeah, well, it depends on how large.
10:47:09 <marolation> where emptyMap is: let emptyMap = M.empty :: Int [Double]
10:47:11 <ReinH> the canonical map S -> 1 + S is not a homomorphism
10:47:42 <ReinH> M.empty is not of type int [Double]
10:48:03 <johnw> ReinH: hmm?
10:48:09 <Cale> dfeuer: If you're less precise about it, it can work on the large scale, but being overly mechanical about the translation on that scale will result in too large a mess to clean up.
10:48:15 <marolation> oops I messed it up
10:48:17 <quchen> marolation: Did you paste your code somewhere already? If no, please do so
10:48:18 <ReinH> johnw: hmm?
10:48:37 <johnw> ReinH: what kind of homomorphism?  it wouldn't be a monoid homomorphism, since both 1 and S itself would have monoid structures?
10:48:56 <ReinH> johnw: where S is a semigroup
10:49:26 <johnw> (S,+) -> (1,const) + (S,+)?
10:49:27 <Cale> (i.e. you'll likely want to only implement a few key continuations that way, and explain how to move between them just directly writing Haskell as you normally would)
10:49:55 <jplatte> Cale, dfeuer: Thanks :)
10:49:55 <jplatte> Cale: I guess I'll probably have that, but I'll play around with implementing some functions before coming back to this.
10:49:55 <jplatte> dfeuer: I did actually start pretty much from scratch.
10:50:06 <dfeuer> ReinH, it's easy to implement the "free magma over monoid with adjoined neutral" -> base monoid  function, and it's not even so hard to pull out the "free magma over monoid with adjoined neutral"->"Free monoid over monoid" function, but proving that the latter is the right thing confuses me.
10:50:09 <Cale> Which of course, will require a better understanding of what the C++ program actually computes
10:50:11 <ReinH> johnw: Er, not, it's not a homomorphism when S is already a monoid
10:50:30 <johnw> ReinH: I still don't follow, how does that relate?
10:50:46 <marolation> I'm going to link you guys to the pastie link in a min
10:50:48 <marolation> thanks
10:50:50 <ReinH> johnw:
10:50:52 <Cale> jplatte: Of course, if you want more directed help, you might want to let us know more about what your actual program is :)
10:50:55 <ReinH> johnw: I'm not sure that it does now
10:52:04 <marolation> I just wanted to do something like this http://pastie.org/10189022
10:52:12 <jplatte> Cale: Oh, okay. Should I just drop a bunch of links and blab about what I want to do with the whole thing in the end?
10:52:48 <dfeuer> This is all part of a bit of a toy project to write functions in Idris to produce proofs that different expressions are equivalent, in order to try to implement verified finger trees. Writing that isn't so hard, but then I really got into trying to prove that it was "complete" in a limited sense....
10:53:42 <dfeuer> That is, that I would be able to find all the proofs that I should be able to using only the expression structures and not knowing anything about the underlying monoid.
10:54:22 <dfeuer> Or if not *prove* that, at least give a convincing argument.
10:58:23 <kuribas> How does ghc know if a foreign pointer is not in use in C?  Does it scan the stack?
10:58:45 <zipper> Is there something I can use to parse a cabal file easily?
10:58:48 <johnw> ReinH: "1 + S" is a semigroup, as long as S is a Semigroup
10:58:56 <dcoutts> zipper: the Cabal library
10:59:06 <johnw> hence instance Semigroup a => Semigroup (Maybe a) in the semigroups package
10:59:12 <Denommus> kuribas: what do you mean?
10:59:30 <Denommus> kuribas: do you want to know how it gets garbage collected or something?
10:59:30 <kuribas> Denommus: Sorry, I meant for garbage collection.
10:59:32 <kuribas> yeah
10:59:34 <dcoutts> kuribas: a ForeignPtr is a pointer *in* the Haskell heap *to* a C side structure.
10:59:50 * dfeuer goes for a bit.
10:59:51 <dcoutts> kuribas: so the Haskell GC knows when the ForeignPtr becomes garbage
11:00:14 <Denommus> kuribas: the pointer itself is just a normal haskell value. If there are no references to the pointer, it gets collected
11:00:22 <kuribas> What if I want the opposite?  For example store a haskell closure in a C struct?
11:00:30 <dcoutts> kuribas: that's a StablePtr
11:00:44 <Denommus> kuribas: that should not be automatically collected
11:00:57 <dcoutts> kuribas: and it has to be deallocated explicitly, because there's no way for the Haskell side to know when it's no longer in use by the C code
11:01:05 <dfeuer> ReinH, let me know if you have any more thoughts; lambdabot knows where to find me.
11:01:10 <zipper> ReinH: Hey, how are you doing?
11:01:13 <dfeuer> Or johnw or Cale, of course.
11:01:32 <kuribas> dcoutts, Denommus: ok, I see, thanks.
11:01:39 <dcoutts> kuribas: so there are functions to create and destroy StablePtrs, including a C function to free a StablePtrs from the C side (sometimes useful, though more often you'd use a Haskell wrapper function)
11:02:07 <zipper> dcoutts: I just want to get a list of the language extensions used out of the .cabal file.
11:02:14 <joeyh> has anyone got a good solution for using ghci with the object files that cabal build builds? I had a hack, but an upgrade has broken it
11:02:19 <dcoutts> zipper: ok, Cabal lib. Should be easy.
11:02:38 <Denommus> joeyh: cabal repl?
11:02:40 <kuribas> Hm, I'll probably use the C one, since it would be freed in the class destructor.
11:02:48 <dcoutts> joehh: cabal repl [--ghc-options=-fobject-code]
11:03:20 <jplatte> Cale: To keep it short, my actual program is this: http://cyvasse-online.com/
11:03:21 <jplatte> Currently it's implemented in C++ only (apart from the few bits that need to be done with HTML, CSS and JS), and right now I'm reimplementing the game logic in Haskell because I want to implement a "self-learning" bot for it but have enough of C++ for now and moo [https://hackage.haskell.org/package/moo] seemed like it would be a nice library to implement this with.
11:03:21 <jplatte> The C++ game logic code is here: https://github.com/cyvasse-online/cyvasse-common, the bits of Haskell I've already written are here: https://github.com/jplatte/cyvasse-hs
11:03:49 <dcoutts> kuribas: sure sure, it has to start from the C side, but quite often you have a custom blah_free() function that's a Haskell function exported to C. And then it's the Haskell side that calls freeStablePtr
11:03:57 <marolation> I solved my problem, thanks guys.
11:04:09 <marolation> Just some newbie mistake.
11:04:16 <joeyh> hmm, seems I'd need to build some C-Sources with -fPIC for cabal repl
11:04:27 <kuribas> dcoutts: oh, I see.
11:04:51 <dcoutts> joehh: really? what platform?
11:05:02 <joeyh> linux
11:05:08 <dcoutts> joehh: if cabal repl doesn't work with C sources on some platform you should report it.
11:05:16 <joeyh> "relocation R_X86_64_PC32 against undefined symbol `statvfs@@GLIBC_2.2.5' can not be used when making a shared object; recompile with -fPIC"
11:05:17 <dcoutts> joehh: but I've never seen that on linux
11:05:35 <dcoutts> joehh: workaround: --enable-executable-dynamic
11:05:38 <dcoutts> or similar for libs
11:05:54 <dcoutts> cabal certainly can compile the C sources with -fPIC when needed
11:06:13 <joeyh> this is a C source used only in an executable, not library, probably why
11:06:37 <joeyh> yay, --enable-executable-dynamic works
11:06:39 <dcoutts> joehh: ok, do file a ticket though
11:06:51 * joeyh is glad to drop his hacks from before cabal repl, they were ugly!
11:07:00 <dcoutts> joehh: cabal repl should just work
11:07:03 <joeyh> on cabal?
11:07:05 <dcoutts> yes
11:07:46 <dedgrant> Hi all I have a bit of a pipes-4.* stumper: Anyone know how to compose (Server x y m r) with (Client x y m r) in the latest major version of pipes? The shapes don't quite line up when using (>->). (Project showing the Proxy mismatch: https://www.fpcomplete.com/project/113256/FGPauPJ9oW)
11:07:48 * joeyh wonders how his 'y' got rotated anyway ...
11:10:54 <johnw> joeλh
11:12:28 <pchiusano> are there any issues with using both cabal sandbox add-source AND a shared sandbox?
11:13:13 <ion> I seem to get a “Forbidden” message when i’m trying to upload a package to Hackage. I have uploaded successfully in the past. I wonder what i’m doing wrong?
11:13:13 <pchiusano> I have two subprojects, A and B, where B depends on A. I'd like both to use a shared sandbox
11:13:23 <kuribas> How to send a haskell function to a C function?
11:14:12 <johnw> kuribas: http://stackoverflow.com/questions/28618137/how-to-declare-a-callback-to-haskell-land
11:14:12 * hackagebot pgstream 0.1.0.3 - Elsen Accelerated Computing Engine  http://hackage.haskell.org/package/pgstream-0.1.0.3 (sdiehl)
11:16:44 <ion> I seem to be in http://hackage.haskell.org/packages/uploaders/ no longer.
11:17:04 <kuribas> johnw: thx
11:17:22 <dcoutts> ion: username?
11:17:32 <ion> dcoutts: http://hackage.haskell.org/user/ion
11:17:49 <joeyh> hmm, cabal repl seems to want to rebuild my whole project, which I already built with cabal build
11:17:58 <joeyh> I want a way to just load up a single module in ghci
11:18:23 <dcoutts> joehh: you can tell it to start ghci just for one component
11:19:05 <dcoutts> ion: done
11:19:08 <ion> dcoutts: Thanks!
11:19:32 <dcoutts> ion: you were probably never in that group. We had a period where we required people to email the admins before being added to that group.
11:19:35 <joeyh> library, or executable, ym?
11:19:41 <dcoutts> ion: later we made it automatic
11:19:47 <ion> dcoutts: Ok
11:20:49 <tongcx> I just wrote a blog portraying programming languages as girls https://medium.com/@tongcx/programming-language-11dd5db26a7d
11:22:12 <ReinH> zipper: hey
11:22:37 <Haskellfant> tongcx: yeah more sexism …
11:23:48 <tongcx> Haskellfant: no, I didn't mean to indicate sexism
11:24:12 * hackagebot acme-memorandom 0.0.1 - Memoized random number generation  http://hackage.haskell.org/package/acme-memorandom-0.0.1 (ion)
11:29:00 <johnw> tongcx: there's really nowhere to go but down; I'd avoid such comparisons
11:29:00 <joeyh> dcoutts: hmm, I got my old hack working again! It turns out that --enable-executable-dynamic was what my hack needed too
11:29:07 <ReinH> tongcx: that's awful
11:29:18 <dcoutts> joehh: makes sense
11:29:23 <dcoutts> joehh: do file that ticket :-)
11:29:31 <joeyh> hack is: run cabal build and find the ghc --make line. Then use the same options when running ghci
11:29:53 <dcoutts> joehh: that's more or less was cabal repl does, but cleanly
11:29:56 <joeyh> ghci then can reuse cabal build's objects, and can load up a single module if desired
11:30:20 <joeyh> except it can't load a single module, so starting the repl was taking 5 minutes, and :r was taking 20 seconds here
11:30:26 <dcoutts> joehh: most of the time it can reuse the .o files. Would be useful to track down when it's not/cannot.
11:30:41 <dedgrant> hah nevermind. I went deeper into Pipes.Core and found (+>>) to join the server and client.
11:31:14 <joeyh> dcoutts: I did file the ticket. I think I'll file a wishlist about cabal repl loading a single module, since I see from my hack it can work fine
11:31:43 <dcoutts> joehh: yes. There's code in cabal that anticipates that.
11:32:05 <dcoutts> joehh: the command line code supports specifying a module, but the feature isn't implemented further in.
11:32:14 <tongcx> joeyh: it's not comparison though, it's like different friends you have
11:32:29 <tongcx> ReinH: any suggestion is welcome
11:32:57 <joeyh> dcoutts: worth filing a wishlist for it then?
11:32:57 <dcoutts> joehh: but there's no feature req ticket for it, so go for it. Perhaps someone will pick it up.
11:33:19 <ReinH> tongcx: unpublish it
11:33:45 <tongcx> ReinH: any reasons?
11:34:43 <ReinH> awful premise, awful execution. It's childish, sexist trash.
11:36:10 <tongcx> ReinH: I do get some good comments and bad comments, but I'd like more concrete reasoning
11:36:26 * Welkin notices the domain is medium.com
11:36:28 <Welkin> oh boy!
11:36:29 <ReinH> Not interested in discussing the merits of your crappy blog post with you
11:36:59 <Welkin> I don't believe I have ever read anything of value on medium.com
11:37:31 <ion> Welkin: The author of SMBC posts comic strips there occasionally.
11:37:35 <Welkin> tongcx: I think your article is amusing as an entertainment piece
11:37:38 <hodapp> medium.com has some decent stuff here and there
11:37:41 <Welkin> but what does it have to do with haskell?
11:39:11 <kuribas> I don't associate a programming language with emotions or feelings, it's a tool for a job.
11:39:26 <hodapp> is throwing things an emotion?
11:39:30 <hodapp> if so then I do
11:39:46 <ReinH> recommend we all give this blog post the attention it deserves, which is none.
11:39:48 <kuribas> hodapp: haha, good point
11:40:19 <maerwald> kuribas: maybe you don't associate emotions with it, but I think they are already part of the association
11:40:55 <hodapp> programming languages, like everything else ever for me, conjure up emotions and feelings.
11:41:19 <jplatte> tongcx: Because nobody seems to have spelt it out explicitly yet: You're objectifying women, that's the big problem with your blog post.
11:41:21 <ReinH> hodapp: oh, I have plenty of emotions from using programming languages, but I don't see the point in anthropomorphising them.
11:41:32 <ReinH> Anyway, they hate it when you do that.
11:41:36 <ion> @quote anthropomorphized
11:41:36 <lambdabot> ion says: ddarius: Yeah, abstract concepts absolutely hate being anthropomorphized.
11:41:44 <ReinH> ion: :p
11:41:59 <Welkin> jplatte: that is your interpretation; why is that a problem?
11:42:05 <hodapp> ReinH: yeah, that's mostly just a reply to kuribas. Anthropomorphization isn't something I do to them.
11:42:06 <Welkin> at least in the US, we have free speech
11:42:08 <tongcx> jplatte: that's not what I want, I just want to give them personality
11:42:33 <ReinH> hodapp: javascript, for example, provides me with many emotions...
11:42:50 <hodapp> Welkin: I'm not sure how state control of speech exactly factors in to anything here.
11:43:06 <ReinH> Oh god, not the free speech argument
11:43:06 <Welkin> it is not about law, it is about principles
11:43:11 <ReinH> This is seriously off topic now
11:43:49 <Welkin> there is not a person on this planet who does not objectify other living things
11:44:00 * ReinH sighs
11:44:04 <ReinH> Take it to blah
11:44:08 <tongcx> ReinH: if you don't like it, i hope you can forget about it
11:44:13 * hackagebot presto-hdbc 0.1.0.0 - An HDBC connector for Presto  http://hackage.haskell.org/package/presto-hdbc-0.1.0.0 (thomasjm)
11:44:14 <Cale> We are objects, aren't we?
11:44:32 <jplatte> tongcx: but it is what you're doing. no matter your talk about personality in the first paragraph or in this chat.
11:44:33 * ion follows the morphism to Cale
11:44:36 --- mode: ChanServ set +o mauke
11:44:51 <mauke> ಠ_ಠ
11:45:10 <ReinH> Can everyone discussing this stupid blog post, which doesn't even mention Haskell, please take ot to #haskell_blah
11:45:14 <ReinH> it's seriously off topic
11:45:18 <int-index> > Could not deduce (Element r2a ~ Element r1a) from the context (Element r2a ~ Element r1a, Transform r1a r2a) 
11:45:19 <lambdabot>  Not in scope: data constructor ‘Could’    Not in scope: ‘deduce’
11:45:19 <lambdabot>      Perhaps you meant ‘reduce’ (imported from Debug.SimpleReflect)    Not in...
11:45:19 <lambdabot>      Perhaps you meant one of these:
11:45:21 <jplatte> by the way, I don't associate personalities with chairs or beds... o_O
11:45:24 <int-index> Enough type hackery for today.
11:45:46 <maerwald> what's the easiest introduction into template haskell?
11:46:04 <hodapp> so, it now seems I need to use GHC.Generics to transform a record/ADT, generically.
11:46:05 <hodapp> wooo!
11:46:11 <kuribas> ReinH: It did mention haskell.
11:46:29 <Welkin> maerwald: https://wiki.haskell.org/Template_Haskell
11:46:39 <ReinH> kuribas: the word "Haskell" doesn't appear anywhere in the post.
11:46:52 <ReinH> Ah. It's in an image.
11:47:06 <ReinH> I still don't think it's on topic
11:47:35 <ReinH> and it's obviously derailing the channel into arguments about free speech and such, which are definitely not on topic
11:47:42 <maerwald> Welkin: I find that a bit chaotic and not a concise introduction... it just gives me links to the specification and papers
11:47:53 <mauke> ReinH: agreed
11:47:55 <ReinH> Anyway, it looks like we've stopped
11:48:02 <Welkin> maerwald: I really don't know much about template haskell other than what I need to know to use yesod
11:48:06 <mauke> let's talk about TH
11:48:09 <Welkin> yesod uses it quite extensively
11:48:13 --- mode: mauke set -o mauke
11:48:38 <tongcx> Yea, let's go back to math
11:49:25 <mauke> easiest introduction: TH lets you generate Haskell code in Haskell at compile time
11:49:34 <mauke> ... in the form of an AST, not source code
11:51:06 <gervasio> hi guys
11:54:14 * hackagebot keter 1.4.0 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.4.0 (MichaelSnoyman)
11:54:17 <gervasio> anyone can help me with  Leaf Trees using anamorphism? I have to write the function balance that uses an anamorphism and a Ltree
11:54:45 <mauke> anamorphism? is that an unfold?
11:55:25 <Welkin> yes
11:57:12 <Welkin> what is with people coming in here to ask homework questions lately?
11:57:37 <maerwald> looks like another semester has started?
11:58:09 <maerwald> and yes, I've seen that question today already
11:58:57 <Welkin> that's not what this channel is for
11:59:03 <Welkin> "do my homework please"
11:59:04 <ReinH> I also saw it on StackOverflow
11:59:13 <maerwald> ReinH: cool, maybe just link them to the thread...
11:59:16 <ion> There’s nothing wrong with asking for guidance with homework. That’s different from “do my homework”.
12:00:05 <gervasio> I am a kind of lost... And the semester is almost at the end..its not homework, its just an exercise for an assigment with more than 20 questions...
12:00:49 <gervasio> I am trying to understand the subject but its dificult to me if I dont have examples...and haskell is not the most famous language...
12:01:27 <maerwald> is it not famous?  I thought it's quite famous in FP
12:01:46 <gervasio> true, but FP is not famous...or comercial
12:01:51 <maerwald> gervasio: you should start by showing what you have tried
12:02:34 <Welkin> gervasio: if you want help, explain the problem clearly, explain what you have tried and your thought process, then offer possible alternatives and ask specific questions about what confuses you
12:02:42 <maerwald> gervasio: and I think you have some prejudices about FP, see https://wiki.haskell.org/Haskell_in_industry
12:02:56 <ReinH> gervasio: Haskell isn't commercial? I guess my company had better pack it up then.
12:03:00 <maerwald> :)
12:03:02 <Welkin> gervasio: I use haskell commercially
12:03:08 <ReinH> I'll let the CEO know, thanks for saving us all a bunch of wasted time
12:03:15 <mauke> I use haskell comically
12:04:49 <gervasio> well, go see the ranking of top 20 programming languages and you will see.... I am not saying that haskell sucks...I am just saying that FP isn't so much required by the companies comparing with Imperative languages
12:05:29 <Tehnix> gervasio: what specifically is it the assignment is about? Because "Leaf Trees using anamorphism" didn't give me much :/
12:06:04 <Tehnix> gervasio: A small but very active community vs a large and less contributing community. You can't judge languages by mere numbers
12:06:09 <ReinH> gervasio: Ok, I don't think anyone was disputing that. Not sure why you're mentioning it. What does this have to do with balanced binary trees?
12:06:40 <mauke> ranking of top 20 programming languages? ordered by shoe size?
12:06:54 <ReinH> mauke: "the" ranking, obviously
12:07:02 <mauke> ooh
12:07:06 <ReinH> That one.
12:07:11 <gervasio> ok, then, I dont know how to balance a Leaf tree using and anamorphism...I have this data type: data LTree a = Leaf a | Fork (LTree a, LTree a) and this anamorphism given by the prof: anaLTree f = inLTree . (recLTree (anaLTree f) ) . f
12:07:26 <ReinH> gervasio: What have you tried?
12:07:38 <gervasio> so I have to write the balance function that balances the Tree
12:07:47 <Tehnix> that is one, almost, unfortunate function name there
12:07:53 <gervasio> I know how to use catamorphism
12:07:54 <mauke> permission to giggle at the function name, sir
12:08:00 <ReinH> hahaha
12:08:13 <gervasio> but I dont understand the anamorphism
12:08:20 <Tehnix> Hmm, I haven't dabbled much with unfolds only folds :/
12:08:25 <mauke> what are inLTree and recLTree?
12:08:29 <ReinH> You haven't provided inLTree or recLTree
12:08:32 <maerwald> yes, we definitely had the anaLTree already today :)
12:08:53 <Tehnix> gervasio: While this isn't an answer to your question, I think https://wiki.haskell.org/The_Monad.Reader/Issue5/Practical_Graph_Handling might be interesting :)
12:08:55 <mauke> gervasio: balance how?
12:08:57 <ReinH> gervasio: Do you know what an anamorphism is?
12:09:25 <Cale> gervasio: Which course is this?
12:09:25 <gervasio> anamorpshism is construction? catamorphism is destrcution?
12:09:58 <ReinH> Didn't the class that assigned an exercise on anamorphisms explain anamorphisms to you?
12:10:48 <athan> Cale: What are your favorite books?
12:11:01 <Tehnix> gervasio: catamorphism reduces a complex structure to a single value, and anamorphism builds a complex structure out of a building function. Or at least that's what I've heard
12:11:34 <ReinH> catamorphism : fold :: anamorphism : unfold
12:12:19 <Welkin> athan: let the Glasgow Inquisition commence!
12:12:38 <gervasio> exactly, thank you, I think I have to go through the tree and convert to a List of values, and then build another balanced tree 
12:12:42 <gervasio> am i right ?
12:13:11 <Welkin> flatten the tree into a list, then build a new tree that is completely balanced?
12:13:17 <Welkin> that is a strange balancing function
12:13:23 <ReinH> (Sounds like a hylomorphism)
12:13:29 <gervasio> Cale: its informatic engineering
12:13:52 <Welkin> what about a red-black tree, or an AVL tree?
12:14:33 <gervasio> I dont know if its right, I just thought this way
12:15:11 <Welkin> that sounds wrong if it is an engineering course
12:15:24 <Welkin> it is needlessly inefficient
12:15:42 <gervasio> I am not good in this subject :(
12:15:55 <ReinH> Why would an informatic engineering course teach anamorphisms?
12:15:59 <gervasio> I told u what I thought
12:16:22 <Welkin> perhaps the topic is "data-oriented design"
12:16:44 <Tehnix> I'm actually interested in the solution/approach as well
12:17:12 <ReinH> Ah, I think informatics engineering is a translation of the term used for "computer engineering" in some other langauges
12:17:35 <gervasio> its a prototyping course
12:17:38 <ReinH> So, what are recLTree and inLTree?
12:18:14 <gervasio> I mean, we program design by calculation
12:18:29 <gervasio> *We learn
12:18:36 <ReinH> Ok. What are recLTree and inLTree? You've only given us part of the problem.
12:18:45 <ReinH> Maybe you can write the problem up in an lpaste
12:18:54 <gervasio> recLTree f = id -|- (f >< f)
12:19:09 <ReinH> Yeah, you're going to need to use an lpsaste
12:19:13 <ReinH> you keep introducing undefined terms
12:19:13 <gervasio> inLTree = either Leaf Fork
12:19:19 <Tehnix> gervasio: I think it might be better to paste the full given code
12:19:24 <ReinH> and it's going to be hard to keep track of everything
12:19:26 <Tehnix> gervasio: http://lpaste.net
12:19:50 <jplatte> *sigh* I'm really not getting how to progress my game logic stuff any further. What I have is descriptions of what parts of the game are and some functions that tell me things about this data; this is where the declarative / functional implementation is nice and easily understandable. But now I want to create slightly different data from existing data and this is where I'm lost... How do I even name such a function? It doesn't do IO, and
12:20:15 <gervasio> ok,
12:20:16 <gervasio> http://lpaste.net/132627
12:20:38 <ReinH> gervasio: we need all the undefined terms
12:20:43 <ReinH> what are -|- and ><?
12:20:48 <gervasio> I have to write this fucntion: balance :: LTree a -> LTree a
12:21:10 <gervasio> thats the problem, I also dont know
12:21:17 <ion> Why does the professor leave out type signatures? :-(
12:21:31 <mauke> ion: they are intuitively obvious
12:21:33 <Welkin> ion: for pleasure and pain
12:21:48 <gervasio> Welkin: true
12:21:50 <ReinH> If you don't know -|- and ><, how do you expect us to know?
12:22:34 <zipper> tongcx: Can you write a blog post where you compare programming languages as men so that men know which langs are better suited for them? There are a lot of men in programming.
12:22:40 <ReinH> they look sort of like ascii art for + and \times
12:23:02 <zipper> tongcx: Maybe if you targeted men it wouldn't be so sexist. I really don't know.
12:23:11 <mauke> ReinH: they are
12:23:13 <pchiusano> where does a cabal.config file go, in the same directory as the sandbox or the same directory as the blah.cabal file
12:23:17 <athan> Welkin: Glasgow inquisition? :|
12:23:28 <Welkin> when I see (><) I think `concat` for Sequence
12:23:32 <gervasio> guys thank u for your effort... I think I have to try something else
12:23:45 <ReinH> mauke: what are + and \times for functions?
12:23:59 <ReinH> One might be (.), but what would the other be?
12:24:07 <Tehnix> gervasio: hope you solve it! :)
12:24:07 <mauke> ReinH: dunno, but it's related to the structure of algebraic types
12:24:15 * hackagebot pred-trie 0.2.0 - Predicative tries  http://hackage.haskell.org/package/pred-trie-0.2.0 (athanclark)
12:24:18 <ReinH> mauke: sure
12:24:21 <zipper> tongcx: But when you compare anything to genders, races etc you will offend someone.
12:24:29 <tongcx> zipper: i guess so, I should portrary them as man. I didn't really think when making the choice. It feels symmetry
12:24:30 <gervasio> Tehnix: thank u :D
12:24:30 <zipper> </Offtopic>
12:24:31 <mauke> recLTree mirrors the definition of LTree
12:24:59 <gervasio> I think -|- its like a plus and >< its like a times
12:25:01 <Welkin> zipper: no HTML allowed!
12:25:02 <kuribas> jplatte: You should try asking a more direct question about what you want to accomplish.
12:25:13 <gervasio> as ReinH said
12:25:13 <Welkin> especialy if it is XML
12:25:47 <ReinH> Sure, but that doesn't tell us what they mean
12:26:11 <kuribas> jplatte: What functionality you want to implement, and where you are failing.
12:26:25 <kuribas> jplatte: Or having troubles at least.
12:27:27 <zipper> At the risk of seeming lazy, which cabal module can help me parse a .cabal file to extract the ghc extensions specified in the .cabal file?
12:27:31 <jplatte> kuribas: I'm (re)implementing a game (just the logical part, no graphical stuff), and I am trying to implement things like "move a piece" in the Match module
12:27:41 <zipper> There are just too many modules there to go hunting.
12:27:56 <zipper> All I want to do is extract the extensions that will be used.
12:28:04 <kuribas> jplatte: Well, move a piece in a boardgame would be (Board -> Board).
12:28:27 <jplatte> kuribas: I don't even have the board as type :D
12:28:36 <akurilin3> question: can I run a profiled build with multiple cores? So +RTS 8 or something? Or does profiling not work that way at all?
12:28:42 <jplatte> But I guess that's applicable to Match too
12:29:23 <kuribas> jplatte: For example in chess, a board would be a 2D array of pieces, with some state (like has the side castled yet, have the rook or king moved).
12:29:50 <jplatte> That's also the only option I saw so far, something like
12:29:50 <jplatte> movePiece :: Match -> Piece -> Square -> Square -> Match
12:29:50 <jplatte> movePiece m p fromSq toSq = ...
12:30:03 <jplatte> Yeah actually my game is similar to chess
12:30:55 <jplatte> kuribas: but why are the pieces part of the Board type??
12:31:59 <kuribas> jplatte: (Board -> Board) would be the resulting type, it could be (movePiece :: Piece -> Square -> Board -> Board)
12:32:24 <jplatte> Okay, that's interesting
12:33:03 <jplatte> Though I still don't like the name "Board" for a type that holds the piece data
12:33:50 <kuribas> jplatte: Well, a board is a rectangle with pieces, right?
12:34:09 <jplatte> I'm not a native speaker, but to me the board is just the thing the pieces stand on :D
12:34:37 <kuribas> jplatte: So the board contains the positions of the pieces.
12:35:39 <jplatte> but I'll be afk now for ~20min. thanks a lot though for that one comment about the type of movePiece, I think I'm starting to understand how to really do this :)
12:39:15 * hackagebot comonad 4.2.6 - Comonads  http://hackage.haskell.org/package/comonad-4.2.6 (EdwardKmett)
12:39:17 * hackagebot nested-routes 2.2.0 - Declarative, compositional Wai responses  http://hackage.haskell.org/package/nested-routes-2.2.0 (athanclark)
12:43:55 <P4Titan> Hello all, is there some way to test if an assignation of a string copies the entirety of that string into new memory or just a reference is created.
12:44:15 * hackagebot exceptional 0.1.0.0 - A type for pure code that can fail.  http://hackage.haskell.org/package/exceptional-0.1.0.0 (pharpend)
12:45:04 <quchen> P4Titan: "Assigning" is a bit of an un-defined term in Haskell. You can define new bindings, but you cannot "assign" a string to a variable like you'd do in say C.
12:45:20 <quchen> If you write "xs = someString" then that's pretty much free, no copying is done.
12:45:20 <P4Titan> I can explain in more detail what I am doing.
12:46:54 <P4Titan> I have a string that is passed around in args of functions. Then that is passed into the initalPos function of Text.Parsec.Pos which build a SourcePos data type where it becomes the first element in the constructor
12:46:55 <johnw> one thing I like about Haskell is how amazingly good most of its academic articles are
12:47:01 <dfeuer> P4Titan, strings are singly-linked lists. If you "copy" one, that just copies the pointer to the first cons.
12:47:09 <quchen> johnw: SPJ's papers are also manuals :-D
12:47:16 <johnw> plus how highly relevant it can make even some pure math papers
12:47:16 <P4Titan> That is what I figured.
12:47:26 <johnw> I just discovered "Algebras, Coalgebras, Monads and Comonads"
12:48:04 <quchen> P4Titan: The String type is very bad for handling text (because, as dfeuer mentioned, it's a singly linked list of individual characters). If you're doing anything beyond a handful of characters long, Data.Text is a much better choice.
12:48:17 <ReinH> johnw: throw monoids and comonoids in there and you have yourself a deal!
12:48:35 <P4Titan> quchen: What do you mean by "handling"
12:48:37 <dfeuer> johnw, why is it that until a few months ago, I thought of "whilst" as a rare archaic word, but now I'm seeing it everywre?
12:48:39 <mozzarella> what's the best resource to learn haskell?
12:48:43 <quchen> Isn't everything a comonoid in Haskell, ReinH?
12:48:48 <ReinH> quchen: yes
12:49:01 <johnw> dfeuer: um, HUH?
12:49:10 <ReinH> but not all (co)monads are formed from adjunctions in [Hask,Hask]
12:49:16 * hackagebot exceptional 0.1.0.1 - A type for pure code that can fail.  http://hackage.haskell.org/package/exceptional-0.1.0.1 (pharpend)
12:49:22 <dfeuer> johnw, the abstract to the article you mentioned starts with it.
12:49:28 <johnw> ah
12:49:35 <quchen> mozzarella: LYAH if you ask me
12:49:37 <quchen> ?lyah
12:49:37 <lambdabot> Unknown command, try @list
12:49:39 <johnw> I haven't read the paper yet, sadly work beckons
12:49:40 <quchen> ?where lyah
12:49:40 <lambdabot> http://www.learnyouahaskell.com/
12:49:41 <ReinH> dfeuer: selection bias
12:49:51 <johnw> whilst you read it, I shall labor
12:49:53 <dfeuer> What's a comonoid?
12:50:13 <ReinH> coappend :: a -> (a,a) and counit :: () -> a
12:50:15 <quchen> dfeuer: foo :: a -> (); bar :: a -> (a,a)
12:50:28 <ReinH> er yes, that's the right type of counit
12:50:28 <dfeuer> ReinH, I'm seeing it all over social media; I don't think my consumption of such has changed *that* much.
12:50:34 <ReinH> counit :: a -> ()
12:50:40 <quchen> ReinH: () -> a = mempty
12:50:43 <ReinH> a.k.a. duplicate and destroy
12:50:46 <ReinH> quchen: yep
12:50:53 <quchen> ReinH: Just for the logs ;-)
12:51:01 <ReinH> quchen: let the record show :)
12:51:13 <maerwald> mh, I was expecting that "head . reverse . reverse $ [1..]" works :/
12:51:18 <quchen> ReinH: Whilst your coappend was correct … ;-)
12:51:19 <ReinH> dfeuer: no, you're just triggered to notice it when you see it
12:51:24 <dfeuer> Ah.
12:51:31 <mauke> dfeuer: http://www.damninteresting.com/the-baader-meinhof-phenomenon/
12:51:33 <dfeuer> In what sense is everything in Haskell a comonoid?
12:51:35 <kuribas> How does FunPtr call a closure from C?  Does it create machine code at runtime to call the closure variables?
12:51:39 <quchen> maerwald: (reverse . reverse) is not the identity on lists, no
12:51:46 <ReinH> dfeuer: every type is a comonoid
12:51:54 <johnw> dfeuer: every type can define a -> (), and a -> (a,a)
12:51:55 <quchen> dfeuer: You can write a comonoid instance for every type
12:52:03 <ReinH> instance Comonoid a where coappend a = (a,a); cojoin a = ()
12:52:10 <maerwald> quchen: interesting... but it's advertised as the standard quickcheck example
12:52:22 <ReinH> er, s/cojoin/counit
12:52:24 <ReinH> sorry everyone
12:52:32 <P4Titan> When should I use Text.Text over String
12:52:39 <ReinH> maerwald: it's the identity on *finite* lists
12:52:44 <maerwald> oh
12:52:50 <quchen> maerwald: Quickcheck doesn't produce infinite lists with its standard generator, and for finite lists (reverse . reverse) is indeed the identity
12:53:05 <ReinH> P4Titan: pretty much everywhere
12:53:16 <johnw> "It is well-known that in a category C with finite products (for instance Ens) every object defines a comonoid in a canonical and unique way; and that every morphism A →− B is then a comonoid morphism. From this follows trivially that every object A in the category C, when seen as a comonoid, defines the free comonoid generated by the object A."
12:53:25 <quchen> P4Titan: The price is usually having Text as a dependency. If that's not an issue, you should go for Text.
12:53:28 <kuribas> I mean, in C, a function doesn't have an enclosing environment, so how does ghc capture it?
12:53:43 <P4Titan> ReinH: Why, for what reason. In terms of efficency, where is it better
12:53:44 <quchen> P4Titan: Cases where Text is arguably too much is for throwing small error messages, but that's about it.
12:53:48 <ReinH> johnw: yep, and ofc (ideal) Hask, being a CCC, has finite products :)
12:53:58 <ReinH> P4Titan: it is more efficient, and is unicode aware
12:53:59 <johnw> the fact that I can find that statement so easily in the context of a Haskell discussion is pure awesomeness :)
12:54:07 <ReinH> johnw: :)
12:54:23 <ReinH> CCCs are boring :)
12:54:34 <johnw> next time somebody shows me a function, I'm going to say, "Oh, cool, a comonoid morphism"
12:54:46 <ReinH> johnw: :D
12:54:48 <dfeuer> I imagine the main problem with monoids is that not every type is inhabited?
12:55:13 <dfeuer> Or do pointed things not lead to monoids so readily?
12:55:19 <ReinH> I suppose the main problems are finding an associative binary operation with a unit
12:55:35 <dfeuer> Ah, yes, unit.
12:55:37 <maerwald> ReinH: how can I "imagine" this... I mean why is it not the identity?
12:55:47 <ReinH> > reverse [1..]
12:55:52 <maerwald> :)
12:55:52 <lambdabot>  mueval-core: Time limit exceeded
12:55:52 <quchen> ReinH: Let C be a category of Haskell types and functions between them. Then C is Hask iff it has all the nice properties we'd like Haskell types to have. (Bottom, no, go play elsewhere!)
12:56:04 <ReinH> reverse [1..] = _|_
12:56:22 <dfeuer> Doesn't the First monoid take care of that bit?
12:56:36 <dfeuer> er...
12:56:39 <ReinH> quchen: I did say "ideal" Hask :p
12:56:41 <dfeuer> No, I'm mixing things up.
12:56:51 <quchen> ReinH: Conjecture. Whenever someone says Hask, he means ideal Hask.
12:56:54 <quchen> Proof. refl
12:56:57 <johnw> it's funny how many Haskell discussions begin with, "not considering ⊥", and then I read articles from dolio about what happens when you really take ⊥ into account, and my mind segfaults
12:57:01 <ReinH> quchen: ha
12:57:09 <ReinH> johnw: pretty much
12:57:22 <ReinH> quchen: reverse . reverse = id up to bottoms! ;)
12:57:25 <ion> johnw: Do you have a link to such an article?
12:57:35 <ReinH> ion: comonad.com
12:57:36 <maerwald> I also want my mind to segfault
12:57:39 <ReinH> has been posting stuff lately
12:57:40 <johnw> yeah, check out comonad reader on how [a] isn't a free monoid in Haskell
12:57:47 <dfeuer> I saw that.
12:57:59 <ion> ReinH: alright
12:58:04 <quchen> ReinH: The Halting problem is solvable even, up to bottoms
12:58:11 <ion> johnw: thanks
12:58:12 <johnw> quchen: hahaha
12:58:16 <ReinH> quchen: yes, because your language is now total :p
12:58:20 <johnw> quchen: I need a t-shirt that says that
12:58:31 <dfeuer> The halting problem is semi-decidable....
12:58:33 <quchen> johnw: :-)
12:59:03 <johnw> "Up to ⊥, all things are possible"
12:59:07 <ReinH> hahaha
12:59:27 <maerwald> first, I was actually thinking it is a "smiley"
12:59:36 <quchen> One of the most beautiful coincidences in mathematical notation is how ⊥ resembles someone flicking you off
12:59:47 <ReinH> heh
13:00:03 <mniip> is there a better way to say "reverse . dropWhile p . reverse"
13:00:04 <ion> quchen: I thought it resembles a bottom crack.
13:00:29 <maerwald> quchen: so, how does ⊥ help us with anaLTree? ;(
13:01:04 <quchen> That is a terrible name for … no, that's just a terrible name regardless of context.
13:01:05 <ReinH> mniip: right fold
13:01:26 <maerwald> quchen: it came up repeatedly today...
13:01:26 <mniip> maerwald, you mean DmdAnal?
13:02:03 <maerwald> so, I still don't understand it, only it has something to do with bottom
13:02:11 <maerwald> does it make sense to read up on it or will I be wasting time
13:02:21 <quchen> ReinH: Is there a nice solution to the "dropWhile from end" problem? The "zipWith const" way is nice to make a better "reverse . drop n . reverse", but can you do it with dropWhile as well?
13:02:49 <ReinH> quchen: right fold that conditionally conses with a flag to decide whether you've dropped or not
13:03:06 <ReinH> unfortunatley it will still evaluate the whole list spine
13:03:24 <ReinH> but you aren't going to get any sharing anyway
13:03:40 <mniip> ReinH, elaborate?
13:04:16 * hackagebot tasty-silver 3.1.7 - A fancy test runner, including support for golden tests.  http://hackage.haskell.org/package/tasty-silver-3.1.7 (PhilippHausmann)
13:04:18 * hackagebot presto-hdbc 0.1.0.1 - An HDBC connector for Presto  http://hackage.haskell.org/package/presto-hdbc-0.1.0.1 (thomasjm)
13:06:28 <ReinH> > snd . foldr (\x (b,xs) -> if b && x > 8 then (b,xs) else (False, x:xs)) (True, []) $ ([1..10] ++ [1..10])
13:06:29 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8]
13:07:06 <dfeuer> ReinH, can't you just check if the list is empty?
13:07:14 <ReinH> what do you mean?
13:07:28 <ReinH> oh right
13:07:31 <ReinH> if it's empty you're still dropping
13:07:34 <dfeuer> Yeah.
13:07:42 <ReinH> anyway you need a test to see if you're still dropping, that would do it
13:08:19 <ReinH> dfeuer: I just memoize the check :p
13:08:25 <dfeuer> And whether you test for that before or after you test the element you're on can have a big performance impact.
13:08:49 <dfeuer> Which way depends on what you're doing.
13:08:52 <ReinH> anyway, that's the idea
13:09:09 * dfeuer played with that specific thing a fair bit a few months ago :P
13:09:31 <dfeuer> :t L.dropWhileEnd
13:09:33 <lambdabot> Not in scope: ‘L.dropWhileEnd’
13:09:37 <dfeuer> :t dropWhileEnd
13:09:38 <lambdabot> (a -> Bool) -> [a] -> [a]
13:09:48 <ReinH> @src dropWhileEnd
13:09:48 <lambdabot> Source not found. Wrong!  You cheating scum!
13:09:50 <ReinH> oh well
13:09:58 <ReinH> Also that's a bit rude, lambdabot :(
13:10:08 <kuribas> I guess that a FunPtr wrapper creates a call instruction with the closure, am I right?
13:10:08 <Clint> naughty
13:10:09 <dfeuer> It exists, but gets it the wrong way around for the "drop white space from line ends" use-case.
13:10:18 <dfeuer> (i.e., it's slow for that)
13:10:46 <ion> > let dropWhileTail p = go Seq.empty where { go acc (x:xs) | p x = go (acc Seq.|> x) xs | otherwise = toList acc ++ x : go Seq.empty xs; go _ [] = [] } in dropWhileTail even ([0..10] ++ [0,2..10])
13:10:48 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
13:11:28 <jplatte> kuribas: I'm back. And I think I'll go for the board "containing" the pieces, although it doesn't exactly represent the reality in the way I would describe it
13:11:58 <quchen> > dropWhileEndQuchen even [1,2,3,4,5,6,7,8,8,8,8,8]
13:11:59 <lambdabot>  [1,2,3,4,5,6,7]
13:12:01 <ReinH> ion: isn't that repeaatedly doing ++ in an inefficient way?
13:12:05 <quchen> dropWhileEndQuchen p xs = let (no, yes) = span p xs in case yes of [] -> []; (y:ys) -> no ++ [y] ++ dropWhileEndQuchen p ys
13:12:32 <quchen> First order approximation. Higher order improvements unnecessary unless profiling says so ;-)
13:12:42 <quchen> (Same thing for correctness)
13:12:47 <ReinH> :p
13:13:09 <ReinH> mine is asymptotically optimal, but so is reverse . dropWhile p . reverse :p
13:13:13 <kuribas> jplatte: You could encode the board as the ensemble of pieces with their coordinates.  It would be the same thing basicly.
13:13:36 <jplatte> kuribas: Yeah that's what I meant to do
13:13:50 <kuribas> jplatte: Start from the base state of your game, then try to make abstractions that are useful.
13:14:39 <quchen> ReinH: Not really, reverse . dropWhile p . reverse is O( ∞ )  worst case  :-þ
13:14:40 <dfeuer> ReinH, optimality depends on what is more expensive, and the order of arguments to (&&) in the fold makes a big diff.
13:15:06 <ReinH> dfeuer: so is mine
13:15:20 <ReinH> so are all things that deal with the end of a list
13:15:31 <dfeuer> I don't remember the details. "So is mine" means what?
13:15:42 <rayqiu> Cale, I was able to make it work with throwE by using this: runMaybeT $ F.msum $ replicate n (exceptToMaybeT $ iterM run cs)
13:15:44 <ReinH> er, I meant that for quchen
13:15:44 <ion> ReinH: If the previous x did not match the predicate, it will be toList Seq.empty ++ x : ... If the previous x did match it, it does the sequence of conses that were skipped while the predicate matched.
13:15:52 <ReinH> anyway, dfeuer, that doesn't affect asymptotic complexity
13:15:55 <kuribas> jplatte: For example you could represent all valid moves as a list of possible moves.  Then you can filter out impossible moves.
13:15:59 <quchen> ReinH: But you don't have to know the end to drop from it
13:16:01 <quchen> > dropWhileEndQuchen even [1..]
13:16:03 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:16:31 <quchen> > dropWhileEndQuchen even [1,2,3,4,4,4,4]
13:16:32 <lambdabot>  [1,2,3]
13:16:35 <quchen> > dropWhileEndQuchen even [1,2,3,4,4,4,4,5]
13:16:35 <ReinH> quchen: touché
13:16:36 <lambdabot>  [1,2,3,4,4,4,4,5]
13:16:51 <jplatte> kuribas: okay, thanks! :) I'll see what I can do
13:16:52 <ReinH> quchen: wait, no
13:16:55 <ReinH> quchen: that drops the first occurrence
13:16:57 <ReinH> not the last occurrence
13:17:05 <ReinH> wait, what
13:17:09 <dfeuer> ReinH, that depends on your assumptions, I believe. Extremes like dropping almost everything and dropping almost nothing display odd behavior, IIRC.
13:17:27 <dfeuer> And have different laziness.
13:17:36 <ReinH>  but that doesn't change the asymptotics
13:18:10 <Hijiri> new worst case would be infinite list where after some point every element matches the predicate
13:18:41 <Hijiri> or maybe just where the entire list matches the predicate
13:18:46 <quchen> ReinH: Well, depends on how you view asymptotics. If you're forcing the list, then the lazier approach will also be bottom, yes.
13:19:05 <ReinH> quchen: Oh I see how yours works. Clever.
13:19:15 <dfeuer> The "stricter" approach can produce things the "lazier" one can't....
13:19:21 <quchen> ReinH: Inspired by the really clever  dropFromEnd n xs = zipWith const xs (drop n xs)
13:19:25 <quchen> Anyway, shower
13:19:28 <ReinH> wait, no, yours doesn't work, does it?
13:19:40 <ReinH> Oh yes, yes it does
13:19:42 <ReinH> sorry
13:20:57 <dfeuer> I still do not understand quchen's.
13:21:51 <johnw> zipWith truncates n from the end by returning elements of xs using const until it reaches the length of drop n xs
13:21:53 <dfeuer> Er... it looks like a more complicated way to do the fold thing.
13:22:02 * dfeuer goes.
13:22:50 <maerwald> > reverse [1..] == undefined
13:22:55 <lambdabot>  mueval-core: Time limit exceeded
13:22:55 <maerwald> not even this works
13:24:10 <ReinH> maerwald: how would you expect it to work?
13:24:17 <ReinH> you would literally have to solve the halting problem
13:24:17 <maerwald> ReinH: via laziness!
13:24:18 <maerwald> :D
13:24:24 <maerwald> ok :/
13:24:32 <ReinH> you are literally asking if a computation halts
13:24:41 <maerwald> awesome
13:24:55 <maerwald> I'll work on solving it next weekend :D
13:25:00 <ReinH> have fun
13:25:20 <ReinH> > undefined == undefined
13:25:22 <lambdabot>  *Exception: Prelude.undefined
13:25:27 <maerwald> heh
13:25:31 <cite-reader> > undefined == reverse [1..] -- The order you do the reduction in matters
13:25:33 <lambdabot>  *Exception: Prelude.undefined
13:25:34 <ReinH> @src undefined
13:25:35 <lambdabot> undefined = error "Prelude.undefined"
13:26:25 <ReinH> cite-reader: only to the extent that we can distinguish between bottoms
13:26:47 <maerwald> cite-reader: well yes, but it still doesn't yield True :P
13:29:17 * hackagebot presto-hdbc 0.1.0.2 - An HDBC connector for Presto  http://hackage.haskell.org/package/presto-hdbc-0.1.0.2 (thomasjm)
13:34:02 <Guest82613> hello, i am trying to understand Data generics in haskell. I saw this example https://github.com/faylang/fay/blob/master/src/Fay/Convert.hs#L54 , but i cant understand what extQ is doing here?  how does it pass from encodeGeneric to unit, bool, etc ?
13:35:00 <dmj`> I have a transformers question
13:35:13 <dmj`> why is this valid:
13:35:14 <dmj`> newtype T s m a = T { unT :: StateT s m a } deriving ( MonadTrans  ) 
13:35:22 <dmj`> but this isnt
13:35:25 <dmj`> newtype TK s m a = TK { unTK :: StateT s (StateT s m) a } deriving ( MonadTrans  ) 
13:35:57 <dmj`> something about not being cunning enough
13:36:03 <dmj`> http://lpaste.net/132630
13:36:28 <areologist> First time here; surprisingly large group here. Nice.
13:36:47 <c_wraith> dmj`: I think it's because the state type variable is shared
13:37:00 <c_wraith> dmj`: It can't eta-reduce it because the type variable is used.
13:37:32 <dmj`> c_wraith: same error if I specify the type variable
13:37:36 <dmj`> newtype TK s m a = TK { unTK :: StateT String (StateT s m) a } deriving ( MonadTrans  ) 
13:37:40 <dmj`> gives the same
13:37:55 <c_wraith> That's more interesting.  No idea.
13:39:17 * hackagebot proton-haskell 0.6 - Simple XML templating library  http://hackage.haskell.org/package/proton-haskell-0.6 (jrbriggs)
13:41:17 <P4Titan> Hello all, In what ways is Data.Text.Text better than String?
13:41:41 <dmj`> P4Titan: smaller memory footpint
13:41:50 <P4Titan> Is it compressed internally?
13:42:01 <geekosaur> Text is a packed Unicode string; String is a singly linked list of codepoints
13:42:16 <exio4> there's no compression, String is just extremely non-efficient
13:42:23 <geekosaur> String has an overhead of about 64 bytes per character
13:42:36 <P4Titan> Why?
13:42:59 <koala_man> whoa
13:43:22 <noeleph> hey
13:43:37 <valdyn> P4Titan: its a list of char...
13:43:50 <P4Titan> That does not sound that bad as you all make it seem.
13:43:55 <dmj`> data Text = Text Array Int Int 
13:44:15 <valdyn> P4Titan: bad for what?
13:44:34 <valdyn> P4Titan: of course not bad for the operations where lists are fast
13:44:46 <dmj`> where Array is a ByteArray#
13:44:50 <dmj`> geekosaur: ping
13:45:19 <P4Titan> It is almost as if people think it is evil. In general, in instances where Lists are more efficient than arrays, I should use String, and Text in the opposite scenario.
13:45:22 <geekosaur> what
13:45:30 <hodapp> after reading about type families all day today, I'm not sure if I even exist anymore
13:45:32 <dmj`> geekosaur: have you ever encountered the MonadTrans error I'm seeing above
13:46:24 <dmj`> geekosaur: inability to derive a MonadTrans from a newtype T s m a = T (StateT String (State s m) a)
13:46:43 <dolio> dmj`: How is it supposed to figure that out?
13:47:20 <benzrf> dmj`: *StateT s m
13:47:40 <dolio> When you have 'StateT s m a' it's using the 'StateT s' instance of MonadTrans.
13:47:58 <dolio> But you're asking it to figure out that the composition of two monad transformers is a monad transformer.
13:48:59 <int-index> How do I make haddock inline documentation for re-exported modules?
13:51:33 <dmj`> dolio: I don't understand how the extension goes about deriving instances, so I'm not sure. If you know I'd like to understand. It seems like GeneralizedNewTypeDeriving is only good for simple cases, like: newtype T s m a = T (StateT s m a) 
13:51:45 <ReinH> (it is not generally true that the composition of two monads is a monad)
13:52:33 <quchen> ReinH: The idea behind my dropEnd function is to find all potentially droppable elements, that's the fst of span. If there's stuff left (in the snd), then there is a) an element for which p does not hold, and b) all elements up to that point are not dropped
13:52:56 <ReinH> quchen: I get it now :)
13:53:03 <ReinH> quchen: it's clever :)
13:53:09 <kuribas> jplatte: http://lpaste.net/132631
13:54:29 <dolio> dmj`: It looks for instances that would match the thing inside of your newtype and uses them as instances for your newtype.
13:54:35 <quchen> ReinH: There are a few really easy list functions that taught me a lot. Well, two actually. One is zipWith const, the other is foldl in terms of foldr
13:54:43 <SrPx> foreign import ccall "inter_c.h data"; c_data :: IO (Ptr CInt) -- what is the correct way to turn it into a proper haskell array/vector/repa/whatever? Been reading for some time but I guess I'm missing something obvious.
13:55:11 <ReinH> quchen: foldl in terms of foldr is clever
13:55:17 <ReinH> I'm not sure about zipWith const
13:55:18 <dolio> But there's no way to even state the instance that the inside of your newtype would require, because it's the type level composition of 'StateT String' with 'StateT s'
13:55:58 <exio4> implementing _all_ list functions in terms of foldr is a pretty fun way to work it out
13:56:17 <jplatte> kuribas: Thanks, though I'm not sure how much of that I can reuse
13:56:25 <exio4> (sure, the complexity changes, but still)
13:56:31 <quchen> ReinH: I think it's pretty clever (and pretty obvious once you know it). But more importantly, it taught me that there are many "from end" functions that you can do lazily.
13:56:33 <geekosaur> dmj`, you don't normally derive MonadTrans in that case, you derive MonadState String and it creates a MonadTrans based on that (since you told it what to Trans to; it can't guess especially if there are multiple levels as here)
13:56:40 <kuribas> jplatte: hm, there is a bug...
13:56:52 <quchen> ReinH: Another famous example is splitting a list in two halves of equal size.
13:56:52 <ReinH> quchen: rephrase: I don't see what you can do with zipWith const that is clever
13:57:05 <ReinH> that doesn't mean that it isn't clever
13:57:05 <quchen> ReinH: dropFromEnd n xs = zipWith const xs (drop n xs)
13:57:17 <ReinH> oh, ofc
13:57:30 <jplatte> kuribas: what do you mean?
13:58:30 <quchen> ReinH: foldl in terms of foldr is much more than a nice hack for me, it's the realization that foldr takes either one or arbitrarily many arguments, and you can abuse a 4th argument to store state
13:58:56 <quchen> ReinH: "find the 2nd element satisfying a predicate" -> tadaa, fold with fancy last arg
13:58:58 <ReinH> quchen: well, for me it's more that the result of a fold can be a function
13:59:13 <johnw> foldl in terms of foldr drove home to me the power of higher-order functions
13:59:18 * hackagebot hs-inspector 0.5.2.0 - Haskell source code analyzer  http://hackage.haskell.org/package/hs-inspector-0.5.2.0 (flbulgarelli)
13:59:47 <johnw> perhaps the most undersold feature, yet so powerful
13:59:55 <quchen> ReinH: I have a strong feeling that foldl with foldr is a foldM with State, but I haven't verified that.
14:00:11 <quchen> johnw: It's *really* hard to sell.
14:00:32 <quchen> johnw: "So we have map and filter" gives you looks a la "yeah Python too".
14:00:52 <quchen> And "supports functional paradigm" mostly means "has map and filter".
14:01:08 <johnw> look at how many amazing things we have, involving HOFs: Yoneda embedding, Codensity, Monads, Lenses, Pipes....
14:01:18 <quchen> Yeah those are going to be excellent selling points ;-)
14:01:30 <johnw> yeah, sigh
14:01:42 <hiptobecubic> i think you guys are missing the big one
14:01:45 <ReinH> "has denotations" is a pretty big selling point
14:01:46 <hiptobecubic> We have types.
14:01:48 <ReinH> or at least it could be
14:01:54 <quchen> johnw: I mostly call "HOF"s "functions" and the rest "crippled function".
14:02:03 <kuribas> jplatte: Well, it's the general idea...
14:02:05 <johnw> haha
14:02:18 <johnw> quchen: I've been using ACL2 lately, which only has first-order functions
14:02:24 <johnw> and man, it hurt right from the beginning
14:02:29 <quchen> hiptobecubic: Lots of languages have types. Java has types. When you tell someone about Haskell's type system you'll be greeted with "yeah we have Optional too now".
14:02:32 <johnw> like my feet has been chopped off before a race
14:02:38 <quchen> johnw: ACL2?
14:02:45 <johnw> an automated theorem prover based on Common Lisp
14:02:48 <hiptobecubic> quchen, then you aren't doing a great job of it.
14:03:02 <ReinH> Haskell is denotative programming :)
14:03:07 <hiptobecubic> quchen, how about, we can't have null appear anywhere. Not won't. Can't.
14:03:08 <ReinH> not just functional
14:03:29 <quchen> hiptobecubic: They'll google Haskell and a week later tell you about this bottom Haskell has instead.
14:03:30 <ReinH> At least it is denotational everywhere IO isnt...
14:03:31 <johnw> instead of FP, we should just say that Haskell is Awesomeness Programming
14:03:49 <jplatte> kuribas: Alright, thanks again. Although I haven't seen Data.Array yet, and it'll take me a while to understand that, especially line 43 ^^
14:04:00 <dfeuer> johnw, why would an automated theorem prover be based on Common Lisp?
14:04:13 <johnw> dfeuer: because its inventors wanted to?
14:04:18 <ReinH> quchen: "has bottom"  is implied by "is Turing-complete", ofc
14:04:21 <dfeuer> jplatte, Data.Array is kind of weird.... Consider using vectors instead.
14:04:38 <hiptobecubic> quchen, well sure. But bottom and null aren't the same and bottom is provably in every turing complete language. So if they honestly can't tell the difference between an infinite loop and a null pointer then why are you even arguing with them?
14:04:54 <quchen> ReinH: Sure. But that doesn't help in that situation because once you go there you're in an ivory tower.
14:05:00 <kuribas> jplatte: http://lpaste.net/132631#a132633
14:05:10 <Dynetrekk> haskell noob, solving project euler problem 9. Anyone care for a "code review" of my solution? :) http://paste.ubuntu.com/11136282/
14:05:25 <dfeuer> I would like to have an optional totality check in Haskell.
14:05:38 <quchen> ReinH: I'm a bit jealous of your job ;-)
14:05:47 <ReinH> quchen: :p
14:06:03 <quchen> I have awesome colleagues, don't get me wrong, but I'm pretty lonely with my FP focus
14:06:04 <jplatte> dfeuer: Currently I have a Map... Why would I need an Array or a vector?
14:06:23 <dmj`> dolio: the instance for MonadTrans in that case is just instance MonadTrans (T s) where lift = lift, it just seemed trivial, so unsure why it couldn't derive. But if it is as you say, it just tries all instances naively to find one that fits, then the extension is less sophisticated than I thought
14:06:24 <kuribas> jplatte: Line 49 (in the annotation) sets square1 to empty, and sets square2 to (piece, side).
14:06:42 <dfeuer> Dynetrekk, in idiomatic Haskell, we generally would write  isPythagorean :: Int -> Int -> Int -> Bool, and then isPythagorean a b c = a^2 + b^2 == c^2
14:06:52 <kuribas> jplatte: So basically it's moving the piece.  It uses the nondestructive array update.
14:07:03 <dfeuer> jplatte, I have no idea. I didn't bring it up.
14:07:04 <hiptobecubic> quchen, calling it "bottom" is problematic because other language communities don't have a word for it
14:07:11 <jplatte> dfeuer: Okay ^^
14:07:21 <hiptobecubic> quchen, since having a program that might work or might not isn't really cause for alarm in python :)
14:07:26 <Dynetrekk> dfeuer: well, true, but how would the map thing look then? use a lambda?
14:07:35 <quchen> hiptobecubic: Sure, the correct way of addressing this is that all languages have bottom, but Haskell lets you use it, whereas other languages just crash whenever there's one
14:08:01 <dolio> dmj`: 'm a -> StateT String (StateT s m) a' is not lift. It's (lift.lift).
14:08:04 <jplatte> kuribas: I think I'll just keep the Map I have right now, and see if I really need something faster when it comes to using this thing. I have a hexagonal map though, so I don't know how well an Array would work
14:08:12 <Dynetrekk> quchen: try colleagues who disable compiler checks to get crap to compile :P
14:08:15 <hiptobecubic> "use it" meaning carry it along. You can't actually use it for things or it wouldn't be bottom
14:08:19 <Dynetrekk> hypothetically, I mean
14:08:26 <johnw> hiptobecubic: bottom is really undefined behavior, which is just fine if you don't make use of it
14:08:28 <hiptobecubic> unless haskell is more magical than i thought
14:08:29 <ReinH> jplatte: I haven't tried it, but this looks interesting:
14:08:31 <ReinH> @hackage grid
14:08:31 <lambdabot> http://hackage.haskell.org/package/grid
14:08:39 <ReinH> It includes hexagonal grids
14:08:50 <quchen> hiptobecubic: The tool isn't bottom, it's knowing something is not bottom.
14:08:58 <jplatte> ReinH: ooohh cool!
14:09:13 <dolio> dmj`: Unless I'm misunderstanding something.
14:09:28 <dmj`> dolio: that's a type error for me though, http://lpaste.net/2805567247286796288
14:09:35 <quchen> And Haskell is not very magical. It gets really un-magical when you read the STG paper because the fairy dust vanishes ;-)
14:09:46 <dfeuer> Dynetrekk, I hadn't gotten there yet. Sometimes there are good reasons not to be idiomatic :P
14:09:53 <Bor0> what is the STG paper?
14:09:59 <hiptobecubic> quchen, but you can't check if it's bottom
14:10:04 <dfeuer> Bor0, search for "spineless tagless g-machine".
14:10:16 <kuribas> jplatte: You can use a map as well, the idea is the same.  Map (Square, Square) (Piece, Side) maybe even better then what I used, as a game board is usually sparsely populated.
14:10:24 <dolio> dmj`: T.lift.lift
14:10:24 <Dynetrekk> dfeuer: yeah :) I thought it fit well for this program, although I get your point. I don't do the tuple-packing-pattern-matching in general
14:10:36 <jplatte> kuribas: Why (Square, Square) as key??
14:10:54 <kuribas> jplatte: To find which piece is on the square?
14:11:01 <quchen> hiptobecubic: But you can check whether something is not bottom to a certain degree, which is what seq tells the compiler to do (of course if it's really bottom you crash anyway)
14:11:02 <dfeuer> Dynetrekk, you can write allTriplets using concatMap, or =<<
14:11:20 <jplatte> kuribas: I don't understand. This is what I have right now: https://github.com/jplatte/cyvasse-hs/blob/master/Cyvasse/Board.hs
14:11:41 <Dynetrekk> dfeuer: oh. never heard of concatMap
14:11:46 <Dynetrekk> or =<< for that matter
14:11:51 <dmj`> dolio: woa
14:11:52 <jplatte> I don't know what I'd need a second Square for
14:11:57 <dfeuer> allTriplets = abTuples =<< as
14:11:58 <quchen> hiptobecubic: But there's a lot of middle ground between bottom and fully forcible, and laziness allows you to use that part
14:12:39 <dfeuer> Dynetrekk, but ... it's pretty weird to have these global variables "sidelength" and "as" and things.... You should strive to make reusable functions.
14:13:03 <Dynetrekk> dfeuer: it's a project euler problem, but I get your point
14:13:14 <Dynetrekk> dfeuer: I guess my brain is damaged from imperative programming, right?
14:13:16 <hiptobecubic> quchen, well sure, but every language gives you that. "If it hasn't stopped working then apparnetly there was no bottom." If you're talking about having bottom as a value in some structure then that's what I meant by you can 'carry it around' as long as you don't try to look at it.
14:13:46 <quchen> Ah. Okay then. :-)
14:14:27 <dfeuer> Dynetrekk, you'll recover.
14:14:51 <Dynetrekk> dfeuer: we'll see about that. I write Fortran code regularly
14:15:04 <quchen> You'll un-recover
14:15:08 <quchen> ಠ_ಠ 
14:15:30 <Dynetrekk> quchen: I'm worried (in general).
14:15:41 <quchen> Dynetrekk: Using Haskell will teach you a lot about caring about side effects though, and you'll start thinking that way in Fortran as well.
14:15:54 <quchen> It's the most obvious impact Haskell has had on my imperative way of programming.
14:16:00 <Dynetrekk> quchen: actually there's a keyword "pure" in Fortran that gets you side-effect guarantees
14:16:00 <quchen> And it's tremendously useful.
14:16:09 <Dynetrekk> quchen: yeah, it's imperative to learn haskell :)
14:16:35 <dolio> dmj`: Wait, did you do: instance MonadTrans (T s) where lift = lift?
14:16:41 <dolio> That's an infinite loop. :)
14:16:53 <Dynetrekk> quchen: writing "pure" subroutines in fortran is very helpful in testing, imho, and supposedly the compiler can give you some extra optimization out of that - but I've never seen any efffects of it myself
14:16:59 <dolio> I'm sure GHC could fill that in for you, but people probably wouldn't like it.
14:17:46 <kuribas> jplatte: http://lpaste.net/132631#a132634
14:18:16 <kuribas> jplatte: right, just square as key of course.
14:18:53 <dmj`> dolio: ah :)
14:19:16 <dmj`> dolio: yes, I can see people getting angry over that
14:19:23 <ion> Dynetrekk: It was you who asked about Euler 45 a few days ago, right? Did you manage to solve it?
14:19:33 <Dynetrekk> ion: yep
14:19:41 <ion> Alright
14:19:59 <ion> Dynetrekk: I ended up writing a solution for that as well. https://gist.github.com/ion1/30b1215f03d7aa0d4cfa
14:20:05 <Dynetrekk> ion: http://paste.ubuntu.com/11136479/
14:20:08 <Dynetrekk> mine
14:20:10 <dolio> dmj`: Save that one for -XSuperDeriveAnyClass on April 1st next year.
14:20:38 <Dynetrekk> ion: very much more fancy than mine :)
14:20:43 <dmj`> dolio: :) 
14:20:58 <quchen> dolio: halts f = halts f
14:21:32 <ReinH> dolio: I can derive any class you want if bottom is an acceptable definition
14:21:44 <ion> Dynetrekk: take 3 result looks like: [([Tri 1,Penta 1,Hexa 1],1),([Tri 285,Penta 165,Hexa 143],40755),([Tri 55385,Penta 31977,Hexa 27693],1533776805)]
14:21:50 <Dynetrekk> ion: btw hexagonal numbers are a subset of hexagonal ones, as pointed out by someone here, meaning that you don't have to theck the triangulars
14:21:56 <quchen> ReinH: No, because some laws might break
14:22:09 <ReinH> quchen: GHC knows not about your laws
14:22:27 <quchen> ReinH: BUT YOUR CONCIENCE DOES
14:22:28 <ReinH> that's for you to prove, not for GHC
14:22:29 <Dynetrekk> I've gotta go though, good night
14:22:30 <ReinH> :p
14:22:32 <ion> night
14:23:03 <ReinH> quchen: I'm suggesting a generalized class derivation mechanism that just puts = undefined everywhere and you're trying to appeal to my conscience. Good luck with that.
14:24:00 <quchen> ReinH: -fdefer-type-errors does pretty much that already, actually.
14:24:11 <ReinH> quchen: fair enough
14:24:30 <quchen> ReinH: Such a feature might not be that silly now that I think about it.
14:24:37 <quchen> (For prototyping, that is.)
14:25:28 <quchen> Another extension I'd sometimes like to have is an "derive (...)" directive that derives everything for a simple newtype wrapper
14:25:38 <dmj`> is there really a big difference between EitherT and ExceptT ?
14:25:45 <maerwald> I have to turn a String (read from a config file) into a PortNumber... it's a data type and the constructor is not exposed and it does not have a Read instance. The documentation says "Use the Num instance (i.e. use a literal) to create a  PortNumber value"... but I cannot use a literal. What now?
14:26:33 <ion> maerwald: fromInteger <$> readMaybe yourString
14:26:42 <ion> maerwald: Num provides fromInteger.
14:29:05 <maerwald> ion: excellent
14:29:55 <dmj`> maerwald: :t (\(string :: String) -> (fromIntegral :: Integer -> PortNumber) <$> (readMaybe string :: Maybe Integer))
14:34:30 <nak> > 'a' : "bc"
14:34:31 <lambdabot>  "abc"
14:34:42 <nak> is there a function that would result in "bca" ?
14:34:51 <nak> append rather than prepend ?
14:35:22 <nak> > 'a' (flip (:)) "bc"
14:35:24 <lambdabot>      Couldn't match expected type ‘([a0] -> a0 -> [a0]) -> [Char] -> t’
14:35:24 <lambdabot>                  with actual type ‘Char’
14:35:24 <lambdabot>      The function ‘'a'’ is applied to two arguments,
14:35:49 <ion> nak: "bc" ++ ['a']
14:36:22 <nak> ion what is that called exactly? list concatenation ?
14:36:36 <ion> nak: yeah
14:36:40 <nak> ok thank u
14:36:52 <ion> or “appending”
14:37:15 <kuribas> > concat ["ab", "cd", "ef"]
14:37:17 <lambdabot>  "abcdef"
14:37:40 <nak> and (:) is called "cons" which is short for ???
14:37:50 <nak> "construct"? 
14:37:50 <ion> Construct. It constructs a non-empty list.
14:37:54 <nak> ah
14:37:58 <nak> ok ^.^
14:39:12 <kuribas> nak: the abbreviation cons comes from lisp.
14:40:46 <grpala> nak: actually, non-empty list is inaccurate. It should say non-empty cell or pair, and the non-empty bit deppends on the dialect
14:42:09 <ion> (:) constructs a non-empty list and [] constructs an empty list.
14:45:30 <ion> We’re on #haskell after all.
14:46:12 <ReinH> nak: cons comes from lisp and means "construct" http://en.wikipedia.org/wiki/Cons
14:46:47 <ReinH> But at this point I thin it's taken on a meaning of its own
14:46:49 <ReinH> *think
14:47:05 <kong0> HASKEL IS FOR NIGGER SONLY
14:47:10 <kong0> HASKEL IS FOR NIGGER SONLY
14:47:37 <kong0> fuck haskell, punks
14:47:38 <kong0> fuck haskell, punks
14:47:45 <cite-reader> @where ops
14:47:45 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
14:47:51 <kong0> @where ops
14:47:51 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
14:47:52 <kong0> @where ops
14:47:52 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
14:47:53 <kong0> @where ops
14:47:54 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
14:47:55 <kong0> @where ops
14:47:55 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
14:47:57 <kong0> @where ops
14:47:57 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
14:47:58 <kong0> @where ops
14:47:58 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
14:47:59 --- mode: ChanServ set +o glguy
14:47:59 --- mode: glguy set +b *!*@unaffiliated/ethicalhacker
14:47:59 --- kick: kong0 was kicked by glguy (kong0)
14:48:15 <exio4> ReinH: it means its own thing now
14:48:38 <ion> I found it amusing how @where ops became an amplification tool for the troll.
14:49:13 <josephle> well, at least that move was certain to attract an op's attention
14:49:58 <whh> hi. I'm trying to use Text.PrettyPrint.GenericPretty to define instance (Out k, Out v) => Out (Map.Map k v) and having some trouble: http://lpaste.net/110672
14:50:05 <hiptobecubic> highlighting multiple times isn't really a bigger deal than highlighting once
14:50:37 <rasen_> Can I run gtk2hs with custom main loop?
14:53:07 --- mode: glguy set -o glguy
14:55:28 <ReinH> exio4: yep
14:55:58 <ReinH> josephle: yes, not a survival enhancing behavior
14:56:33 <ReinH> Then again I'm happiest when the trolls are bad at trolling
14:57:21 <exio4> that command should be rate-limited though, shouldn't it?
14:57:36 <ReinH> I suppose so, but it's probably not worth the trouble
14:57:49 <ReinH> This is the first time in 4+ years I've seen someone do that
14:59:20 * hackagebot exceptional 0.1.1.0 - A type for pure code that can fail.  http://hackage.haskell.org/package/exceptional-0.1.1.0 (pharpend)
14:59:34 <areologist> Random curiosity: Why is this channel so heavily populated? Are Haskell programmers much more likely to use chat than programmers of say.. JavaScript? (A hugely popular language with a less populated freenode)
15:00:35 <jplatte> areologist: I'd say because you can read everywhere that this place is awesome ^^
15:00:48 <hiptobecubic> and educational
15:00:53 <ion> I know Haskell and JavaScript and i’m here and not on a JavaScript channel because for me, Haskell is interesting and JavaScript is not. Also, this is one of the nicer channels out there.
15:00:58 <jplatte> I'm pretty sure I've read more than once that this is a good place to get help, I've never seen anything about the JS freenode chan
15:01:17 <jplatte> And it really was a good place to get help so far, at least for me :)
15:01:25 <areologist> fascinating replies. thank you.
15:03:02 <jplatte> areologist: Just checked, one of the big free haskell tutorials (learn you a haskell) names this channel: http://www.learnyouahaskell.com/introduction paragraph 4
15:03:03 <tremon> areologist: I won't speak for the other 1547, but I'm mainly a spectator here. There's a lot of discussion about program structure and high-level patterns which is relevant regardless of which language you're writing in
15:03:04 <Cale> areologist: Though I can't say anything specific about the people in ##javascript (never visited there), I think in general as somewhat of a fringe interest, the Haskell community has more of an interest in being friendly to beginners than most.
15:03:48 <Cale> and yeah, maybe there are other things which make this channel in particular interesting, because there are a lot of people here who really care about the structure and design of programs
15:04:00 <jplatte> Speaking of helping out noobs... :D
15:04:03 <Cale> (and the mathematics surrounding that)
15:04:20 * hackagebot exceptional 0.1.1.1 - A type for pure code that can fail.  http://hackage.haskell.org/package/exceptional-0.1.1.1 (pharpend)
15:04:22 * hackagebot exceptional 0.1.1.2 - A type for pure code that can fail.  http://hackage.haskell.org/package/exceptional-0.1.1.2 (pharpend)
15:04:36 <jplatte> I think you have a rough idea of what I'm doing, Cale, right? Does "movePiece :: Piece -> Square -> Square -> Board -> (Board, Bool)" look like a good type?
15:04:48 <areologist> fascinating. what math background and/or texts might be recommended for seriously groking haskell?
15:05:13 <areologist> ^ a classic noob question, I suppose
15:05:21 <ion> jplatte: I’d replace the Bool with something more self-documenting.
15:05:35 <jplatte> Just wanted to say that I'm mainly concerned with that Bool :D
15:05:37 <Cale> jplatte: Perhaps? You might want to make the result a Maybe Board?
15:05:57 <ion> areologist: This seems to be the popular recommendation. https://github.com/bitemyapp/learnhaskell/blob/master/README.md
15:06:01 <jplatte> Yeah okay, I was thinking Maybe or Either could replace it
15:06:09 <Cale> That way, you have some assurance that nothing has happened to the Board when the move fails.
15:06:10 <areologist> thank you, ion
15:06:43 <jplatte> Cale: Ah, right, good argument
15:07:02 <Cale> jplatte: Another option would be something like  movePiece :: Piece -> Square -> Board -> Map Square Board -- i.e. return a Map of all the possible new boards for places where the piece can go.
15:07:30 <jplatte> Cale: okaaay, why would I want to do that?
15:07:49 <Cale> jplatte: Perhaps the user selects a piece and you want to highlight places where it is valid to move it.
15:07:56 <Cale> Or perhaps you want to build a game tree
15:08:12 <Cale> (in which case this computes the branches)
15:08:36 <jplatte> Hmmmmmm, okay
15:09:05 <jplatte> The game tree is kind of interesting, but I really have to think more about that before going about implementing that kind of stuff
15:09:20 * hackagebot exceptional 0.1.1.3 - A type for pure code that can fail.  http://hackage.haskell.org/package/exceptional-0.1.1.3 (pharpend)
15:10:11 <jplatte> I (currently) don't want to do anything graphical though. I'm going for creating a bot, and if I have a bot that can play against another bot, that's the point where I worry about integration and maybe replacing the graphical implementation.
15:13:48 <Forgetaboutit> /quit\
15:20:16 <jp_rider> hello
15:20:21 <jp_rider> has anyone built an iOS app in haskell, and will Apple approve one for the app store?
15:20:37 <noeleph> jp_rider I am interested in this questions
15:20:55 <grpala> last time I checked (about a year or two ago) apple didn't approve anything that would have a GC in it's runtime
15:21:05 <grpala> not sure if that restriction still holds
15:21:15 <jp_rider> o that's disappointing
15:21:21 <Pamelloes> I know they lifted the restriction on apps with alternate languages in them,
15:21:24 <ion> grpala: What’s the reasoning behind that restriction?
15:21:36 <hiptobecubic> isn't swift garbage collected?
15:21:57 <grpala> ion: ask them, I recall it having to do with memory usage or something, found it stupid and arbitrary
15:21:59 <ronh-> hiptobecubic I believe swift uses reference counting
15:23:15 <grpala> ion: IIRC, that was the very reason there was no scripting languages available like lua
15:23:23 <Tehnix> eeeerli
15:23:43 <ReinH> grpala: they can restrict "uses garbage collection", they can't restrict "developer is capable of manually managing memory".
15:24:38 <grpala> ReinH: of course. I still think it had more to do with a strategy to boost the sells of their xcode suite and tools rather than a genuine technical issue
15:24:43 <simpson> The GC prohibition is due to efficient GCs having a large minimum memory footprint, IIRC.
15:24:53 <ReinH> grpala: isn't xcode free now?
15:24:55 <jp_rider> http://9to5mac.com/2015/02/20/apple-garbage-collection-arc/
15:25:03 <grpala> ReinH: add apple's totally broken and brain-dead memory management implementation and there you have a nice hint
15:25:06 <jp_rider> this says gc isn't allowed on the mac app store
15:25:17 <jp_rider> still looking for ios
15:26:09 <doomlord> i think refcounting whilst being worse than GC on some measures, can be made more deterministic than GC< which is why they prefer it
15:26:40 <doomlord> i still prefer c++ style completely deterministic memory management
15:27:04 <grpala> ReinH: maybe they just wanted to keep development from becoming fragmented into a plethora of unofficial languages, whatever, I don't like apple, not anymore
15:27:08 <grpala> it's full of shit
15:27:17 <doomlord> i think apples' refcounting does do some stuff to amortize the costs
15:29:08 <doomlord> could a haskel implemenation use any of apples' refcounting stuff (eg, however dumb this sounds, compiling haskell to objective-C, much like some languages compile to C)
15:29:39 <doomlord> i guess the entities haskell deals with want to be slightly lower level than objC objects
15:29:50 <Denommus> doomlord: yeah, just implement a Haskell runtime on top of objective-c
15:30:03 <ReinH> It's possible, but Haskell tends to generate a lot of trash
15:30:21 <grpala> underline "a lot"
15:30:27 <ReinH> alternative GC is a pretty hot research area
15:30:29 <mniip> when languages are compiled to C, C's memory management (which there is not) is not used
15:30:44 <simpson> Well, and the magic GHC trick of Haskell being more effective as garbage rate goes up...
15:30:59 <doomlord> i'm aware the word 'object' in obj C usually means something heavier weight than the word 'object' in C++
15:31:06 <mniip> ReinH, or like, you know, generating less trash
15:31:13 <Denommus> also, Objective-C is a superset of C. If you can compile a language to C, you can link the generated code to Objective-C
15:31:16 <doomlord> so it may well have been a dumb brainfart on my part to even say that
15:31:17 <ReinH> mniip: eh?
15:31:28 <mniip> optimizing allocations away
15:31:45 <ReinH> mniip: that's pretty important too
15:31:52 <simpson> doomlord: Well, it's only a little heavier. About one word larger, same as a C++ object which has been new'd.
15:31:53 <mniip> Denommus, but then you're using malloc/free and not whatever objc offers
15:32:22 <doomlord> in C++ you're doing unique ownership, which is of course very lightweight, but restrictive
15:32:56 <Denommus> mniip: which is better. Having a garbage collector implemented on top a reference counter seems too bloated
15:32:57 <epichero> it's because of Objective-C's smalltalk inspiration/heritage 
15:32:57 * mniip is yet to hear of a language that compiles to C++'s foo_ptr things
15:33:00 <dfeuer> maybeToList is .... some sort of natural transformation?
15:33:09 <ReinH> dfeuer: yep
15:33:17 <mniip> dfeuer, maybe [] (:[])
15:33:20 <dfeuer> ReinH, and now I just need to remember what that means.
15:33:27 <Denommus> mniip: well, Rust is written in Rust, and Rust has ownership semantics :-P
15:33:29 <ReinH> it is a mapping between functors
15:33:33 <dfeuer> And figure out if that helps me.
15:33:46 <ReinH> dfeuer: not too much probably, natural transformations show up everywhere
15:33:52 <doomlord> could a super intelligent compiler analyze a haskell program, and find where it could change references to unique_ptr :)
15:33:53 <ReinH> it's implied by parametricity
15:34:04 <dfeuer> ReinH, I'm still working on that adjoining thing.
15:34:19 <mniip> doomlord, compilers are mostly heuristics
15:34:31 <mniip> in most languages absolute optimization is undecidable
15:35:05 <simpson> Well, if you plan to execute your program, you could just use a superoptimiizer. Those are only NP complete.
15:35:22 <simpson> Er, NP-hard. I think.
15:36:19 <dfeuer> So a tree of maybe-like things represents an expression in an arbitrary monoid, and then I can do some weirdness...
15:36:21 <syndarion> I have a question regarding instances: following the CIS194 course, I have defined a newtype for a polynomial, which is an instance of Num. And I have written the (+) function, but when I try sum on a list of polynomials, I get Prelude.undefined. What could be the cause of this?
15:36:36 <ReinH> dfeuer: a list
15:36:41 <ReinH> because monoids are associative
15:37:00 <mniip> syndarion, lpaste your code
15:37:00 <johnw> syndarion: there are instance methods still not defined in your Num instance
15:37:59 <mniip> it /might/ be that 'sum' depends on 'fromInteger 0'
15:38:27 <dfeuer> ReinH, the piece of the puzzle that's still feels a bit arbitrary is the maybe-to-list bit.
15:38:36 <ReinH> what do you mean?
15:38:39 <dfeuer> Hm.m.....
15:38:42 <pharpend> Does snoyberg just do a bunch of cocaine and start coding? 220 commits to GitHub in the last week
15:38:43 <syndarion> mniip: ah yes, the fromInteger is still undefined
15:39:48 <hiptobecubic> snortberg
15:39:52 <geekosaur> somehow they pull energy out of the type system
15:39:59 <pharpend> hiptobecubic: I like that
15:40:01 <mniip> dfeuer, well there are like 2 ways to turn a Maybe into a list
15:40:05 <geekosaur> (snoyberg and ekmett)
15:40:06 <dfeuer> ReinH, it ... hmmm ... 
15:40:11 <johnw> pharpend: many of those 58 stackage commits are super tiny
15:40:13 <mniip> one is more consistent with [] and another with ZipList
15:40:18 <pharpend> johnw: true
15:40:22 <ReinH> dfeuer: I'm not following :p
15:40:38 <dfeuer> ReinH, okay... I'm just trying to put pieces together.
15:40:43 <johnw> actually, I see a lot of one-line commits in his all-cabal-metadata-tool too
15:40:48 <syndarion> mniip: http://lpaste.net/6988562173194665984 — this is what I have so far. Feel free to critize ;) I could use someone telling me how to write proper Haskell :p
15:40:51 <johnw> i guess he just has that pattern of Git usage
15:40:51 <pharpend> johnw: I've released like 8 versions of exceptional today because Hackage's documentation generation is unpredictable
15:41:11 <ReinH> pharpend: you can generate your own docs
15:41:21 <dfeuer> ReinH, will you be around later, or tomorrow?
15:41:26 <mniip> syndarion, Show typeclass abuse
15:41:28 <ReinH> dfeuer: probably
15:41:41 <pharpend> ReinH: I do =P. It's the stuff generated from the 'description:' field in the .cabal file
15:41:56 <syndarion> mniip, what would be a better way?
15:42:00 <pharpend> ReinH: https://hackage.haskell.org/package/exceptional
15:42:00 <ReinH> pharpend: huh
15:42:30 <pharpend> ReinH: look at the "change log"
15:42:43 <ReinH> haha
15:43:02 <ion> hiptobecubic++
15:43:21 <mniip> syndarion, Show should output haskell code, if you insist on readability, I would suggest a readPoly :: String -> Poly a, of some sort
15:43:42 <ion> pharpend: You can upload package candidates and defer releasing until you have checked the result.
15:43:43 <mniip> then, show (P [0,1]) -> "readPoly \"x\""
15:44:08 <ReinH> pharpend: you can also run your own hackage server. It's very easy.
15:44:14 <pharpend> ReinH: the library is so small that GitHub thinks the primary language is Bash because I included glguy's upload-docs-to-hackage script
15:44:19 <ReinH> hahaha
15:44:21 <pharpend> ReinH: hardly worth running a hackage server
15:44:21 * hackagebot text-show 0.8 - Efficient conversion of values into Text  http://hackage.haskell.org/package/text-show-0.8 (ryanglscott)
15:44:23 * hackagebot eventstore 0.7.2.0 - EventStore TCP Client  http://hackage.haskell.org/package/eventstore-0.7.2.0 (YorickLaupa)
15:44:26 <ReinH> pharpend: ok :)
15:44:36 <syndarion> mniip, I'm just following the assignment really: http://www.seas.upenn.edu/~cis194/hw/04-typeclasses.pdf
15:44:43 <ReinH> I'm just saying the cost is exceptionally low, so it might be worth it more easily than you expect
15:44:48 <pharpend> True
15:44:53 <johnw> pharpend: it's interesting what data reveals.  Looking at the commit logs for the huge number of projects he committed to in the past month, a LOT of those all start around 5/12, with the previous commit being in March or April.  So indeed it seems like there's been a 3 day cocaine binge
15:45:09 <mniip> syndarion, that's unrelated to the task you seem to want to accomplish, just a style advice
15:45:15 <ReinH> pharpend: e.g., https://github.com/haskell/hackage-server/blob/master/run-docker.sh
15:45:19 <pharpend> johnw: since tuesday in israel.
15:46:10 <mniip> also that is a terrible Eq instance
15:46:19 <areologist> is the blue elephant book with questionable grammar generally recommended for noobs? :-)
15:46:29 <areologist> (I can't bring myself to type out the title)
15:46:35 <pharpend> areologist: It was like a year ago, it's sort of out of date now.
15:46:40 <syndarion> mniip, I mean that I used the type definitions provided. So you'd change them actually?
15:46:45 <pharpend> areologist: CIS 194 is better IMO
15:46:49 <geekosaur> we generally call it LYAH
15:46:54 <geekosaur> but recommend
15:46:57 <geekosaur> @where cis194
15:46:57 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
15:47:11 <syndarion> mniip, and what improvements do you have for the Eq? :)
15:47:11 <pharpend> areologist: I'm writing a variant of it with equally horrible grammar =p
15:47:16 <mniip> syndarion, I see no mention of Show Poly in that paper
15:47:19 <pharpend> @@ areologist @where lysa
15:47:20 <lambdabot>  areologist https://gitlab.com/groups/lysa
15:47:23 <pharpend> oops
15:47:33 <areologist> wow, awesome replies. thanks
15:47:33 <pharpend> @where+ lysa http://www.learnyou.org/
15:47:33 <lambdabot> I will remember.
15:47:48 <syndarion> mniip, exercise 3, no?
15:47:51 <ReinH> areologist: I don't recommend it, no
15:48:02 <mniip> oh
15:48:23 <mniip> damn that's a terrible excercise then :(
15:48:27 <ReinH> areologist: I recommend http://reinh.com/notes/posts/2014-07-25-recommended-reading-material.html, and additionally "Thinking Functionally with Haskell" by Richard Bird, which is my current top recommendation.
15:48:35 <pharpend> areologist: RWH is very dry, but a lot more thorough than LYAH. RWH is so out of date that most of the examples don't compile any more.
15:48:47 <syndarion> mniip, too bad.. because I thought it was a really good course :/
15:49:02 <pharpend> areologist: but you can use RWH to get the general gist of things
15:49:13 <mniip> syndarion, it's ok, even parsec abuses Show though
15:49:39 <syndarion> mniip, but besides that.. what can be improved in the Eq? And do I get Prelude.undefined because of the undefined fromInteger 0?
15:49:51 <mniip> probably
15:50:22 <syndarion> mniip, because it works using foldl1 (+), but then I get the recommendation to use sum :p
15:50:44 <mniip> the first line is relatively fine, but in second, P as == P bs = all (== 0) as && all (== 0) bs
15:50:56 <areologist> RWH = Real World Haskel, the O'Reilly book?
15:51:07 <areologist> Great resources so far. Thanks again.
15:51:17 <pharpend> areologist: generally, when you ask about any project in this channel, all of the replies will be from people telling you to look at their project instead. See: myself and ReinH 
15:51:50 <areologist> Intense reading.. I've got a few of the non-haskell books around some place. How to Prove It, the Tarski, the Abstract Algebra... They happen to be among the books I've not read! Damn
15:52:18 <ReinH> pharpend: I don't have a project
15:52:34 <ReinH> areologist: I meant the Haskell stuff :)
15:52:41 <mniip> syndarion, in fact, it only just now hit me, your Eq is not only ill-styled but also invalid!
15:52:44 <pharpend> areologist: nice nick by the way
15:52:51 <mniip> try P [] == P [-1,1]
15:52:58 <ReinH> If you're interested in the other stuff, knock yourself out, but I'm not saying they are required at all.
15:53:04 <syndarion> mniip, oh crap :p
15:53:33 <pharpend> areologist: bitemyapp is writing a Haskell book, it will probably be pretty good
15:53:36 <ReinH> I should update that page
15:53:39 <mniip> I'm not sure which is nicer in this case, 'all (== 0) (as ++ bs)', or what I wrote originally
15:54:07 <pharpend> mniip: I can understand the thing you just wrote, so I would say go with that
15:54:17 <pharpend> mniip: (but use mappend instead of (++)
15:54:19 <pharpend> )
15:54:22 <pharpend> :t mappend
15:54:23 <lambdabot> Monoid a => a -> a -> a
15:54:33 <mniip> a ~ [x] always
15:54:38 <syndarion> mniip, thanks for the help!
15:54:44 <mniip> no need for extra polymorphicity
15:55:00 <mniip> also maybe even 'P [] == P as = all (== 0) as'
15:55:07 <pharpend> mniip: this is haskell, there is always a need for superfluous abstraction
15:55:10 <mniip> 'P as == P [] = all (== 0) as'
15:55:38 <johnw> pharpend: the long-for goal: forall a. a
15:55:41 <johnw> longed*
15:55:54 <pharpend> johnw: that's called "Hello world in Coq"
15:56:04 <syndarion> mniip, I just added P as == P bs = all (==0) as && al (==0) bs and it seems to work. Doesn't that suffice?
15:56:06 <johnw> so abstract, to find it is to imply all things!
15:56:07 <kadoban> Anyone else get some weird survey from FP complete? … I don't remember even making an account there
15:56:12 <mniip> syndarion, maybe
15:56:20 <johnw> kadoban: weird?
15:56:34 <johnw> I have an account, but haven't seen one
15:56:53 <kadoban> Well, it says it's from them, but the domain it came from is not there's either … sounds kinda shady. I think I'll ignore it.
15:56:54 <syndarion> mniip, I just tried all (==0) [] and it returned True
15:56:55 <areologist> How is Coq pronounced?...
15:57:01 <kadoban> Cock, I assume.
15:57:03 <johnw> "cock"
15:57:04 <areologist> damn
15:57:13 <dfeuer> syndarion, that's as it should be.
15:57:14 <mniip> syndarion, that is correct
15:57:15 <areologist> Invented in a non-English speaking country?
15:57:23 <johnw> France
15:57:26 <areologist> ah
15:58:14 <dfeuer> coq = rooster
15:58:36 <syndarion> mniip, now I'm stuck on the fromInteger part. It's not as easy as fromInteger c = P [c] I'm afraid :/
15:58:58 <dfeuer> FromInteger is evil, yes.
15:59:34 <syndarion> dfeuer, aah great :p
15:59:47 <arbelos> If I have a list lookup function such as this: http://lpaste.net/132640
16:00:06 <dfeuer> syndarion, have you heard of Smullyan's drinking paradox, or whatever it's called?
16:00:16 <arbelos> and perform a fold or some other iterated operation on a list 
16:00:22 <syndarion> dfeuer, I'm afraid I have not
16:01:08 <arbelos> without changing the list
16:01:09 <dfeuer> syndarion, if you're in a pub, then there must be someone in the pub with the property that if *they* are drinking, then *everyone* is drinking.
16:01:34 <arbelos> does the length get computed each time?
16:01:39 <mniip> pharpend, foldr (mplus . pure)
16:01:58 <ReinH> arbelos: the length gets computed every time !% is called
16:02:07 <syndarion> dfeuer, I'm not really getting where you're going with this :p
16:02:20 <ReinH> unless GHC notices the sharing and optimizes it away, but you shouldn't expect that
16:02:26 <arbelos> ReinH: so it is a bad idea. hmm.
16:02:41 <syndarion> dfeuer, but a quick Google search revealed the answer being fromInteger c = P [fromIntegral c], although I have no clue why :p
16:02:43 <arbelos> I should just put it inside my function in a where clause then instead
16:02:49 <dfeuer>   syndarion, just be careful thinking about "all" and "any"
16:02:55 <mniip> syndarion, Num a => Num (Poly a), right?
16:03:04 <ReinH> arbelos: you could instead try to find it and return a Maybe, then on Nothing try to find it  mod length
16:03:13 <syndarion> mniip, yes
16:03:25 <mniip> then what's the issue
16:03:39 <ReinH> arbelos: you could also inline the length calculation while evaluating the list to find the member, so that you only need to evaluate the list once
16:04:02 <arbelos> ReinH, add the length as an argument
16:04:05 <syndarion> mniip, basically I don't know what fromIntegral is supposed to do I think
16:04:20 <dfeuer> syndarion, for polynomials?
16:04:26 <dfeuer> Think about taht a bit.
16:04:28 <mniip> convert an integer into the type in a sensible way
16:04:44 <areologist> some jerk will write a framework for coq called pusee (hey, it just means cat, bro)
16:04:45 <dfeuer> Of course, polynomials aren't entirely sensible as Num.
16:04:47 <mniip> also, given your x :: Poly a, consider what x * 2 and x + 3 are
16:05:07 <syndarion> Guess I still have a long way ahead of me, before I can even call myself an Haskell amateur :p
16:05:32 <mniip> might sounds disappointing, but this has little to do with haskell itself
16:05:46 <ReinH> areologist: the recursion could look like go len n (x:xs) = go (len + 1) (n - 1) sx
16:05:51 <ReinH> er
16:05:54 <ReinH> arbelos: ^ sorry
16:06:13 <syndarion> mniip, meaning I'm a crappy coder or the polynomial exercise is more about math than Haskell?
16:06:33 <mniip> the latter
16:07:31 <syndarion> mniip, phew, close one there :p
16:07:55 <ReinH> areologist: then go len _ [] = (Nothing, len) and use len to do xs !! (n `mod` len)
16:07:59 <ReinH> damn it, not again
16:08:06 <ReinH> I need to update my tab completion heuristic
16:08:08 <mniip> syndarion, could be both :P what do I know
16:08:52 <syndarion> Well, I'm just following the course so I'm tackling this exercise. Next is I/O, then Lazy Evaluation, and only then Monads :)
16:08:58 <arbelos> ReinH.. my first instinct was to do modular lookup by simply repeating the list to infinity, but then linear time lookups makes that pretty crappy on large numbers
16:09:17 <ReinH> arbelos: I like my way better :)
16:09:28 <arbelos> ReinH, the maybe/nothing option?
16:09:31 <ReinH> yeah
16:10:17 <ReinH> arbelos: btw you still have an undefined case for the empty list
16:10:43 <arbelos> oh good point
16:11:29 <mniip> syndarion, weird order
16:12:25 <syndarion> mniip, here's a link to the course: http://www.seas.upenn.edu/~cis194/lectures.html — it actually is recommended a lot to Haskell beginners
16:14:01 <ReinH> arbelos: you have something like http://lpaste.net/132641
16:14:24 <maerwald> syndarion: but not the latest ones
16:14:35 <maerwald> https://www.seas.upenn.edu/~cis194/fall14/spring13/index.html
16:15:01 <syndarion> maerwald, so the one I'm following isn't then? Damn it :p
16:15:25 <kadoban> You should make sure you're doing the spring '13 ones, yeah. They changed a lot, and not in a good way for independent study.
16:15:36 <mniip> looking at chapter 12
16:15:37 <mniip> really
16:15:43 <maerwald> I/O in the 5th week, ugh
16:15:46 <mniip> this is why we got STRef
16:15:49 <ReinH> This is sort of the problem with doing coursework. A lot of communication happens in the lectures.
16:16:05 <ReinH> And having access to a prof or TA is also helpful
16:16:41 <syndarion> ReinH, that, I have not :p
16:17:15 <maerwald> ReinH: there are unfortunately not many universities that teach haskell, at least not where I am. There are only some "crash" courses of like 4 weeks.
16:17:25 <xandaros> syndarion: I can recommend learning about Functor and Applicative before learning about Monads. Makes them far easier to understand
16:17:25 <ReinH> syndarion: btw if you're using that coursework, #haskell-beginners uses it more-or-less officially and are probably better equipped to help with it
16:17:36 <maerwald> the problem with spring13 is that some things are actually missing in a few lectures... or only visible if you view the html source code...
16:17:38 <maerwald> hint hint
16:17:49 <ReinH> :p
16:18:01 <syndarion> So you guys strongly advise to stop following this one, and start following the spring13 one?
16:18:05 <ReinH> Yes.
16:18:13 <kadoban> syndarion: Definitely.
16:19:01 <maerwald> turns out we are all Brent fanboys :/
16:19:10 <syndarion> Too bad, this one had some nice assignments :p guess I'll make the switch
16:19:11 <ReinH> Brent is pretty awesome.
16:20:01 <ReinH> He was one of our first guests on the podcast
16:22:43 <jplatte> dfeuer: You said a while ago that Data.Array was weird and I should probably use vectors instead. Why?
16:23:23 <dfeuer> jplatte, I can't really discuss it much right now, but it deals with arbitrary sorts of indices.
16:23:43 <mniip> and array doesn't?
16:23:43 <jplatte> Yeah, what's the problem with that? I think that's pretty awesome
16:23:57 <jplatte> mniip: A Vector doesn't, an Array does
16:23:57 <dfeuer> mniip, array does. vector doesn't.
16:24:04 <dfeuer> It stinks.
16:24:05 <mniip> yeah what's the issue then
16:24:23 * hackagebot exceptional 0.1.2.0 - Essentially the Maybe type with error messages.  http://hackage.haskell.org/package/exceptional-0.1.2.0 (pharpend)
16:24:25 <dfeuer> You can't turn an Int into an arbitrary index. There are lists everywhere. Blargh.
16:24:30 <jplatte> In my use case, it's very convenient
16:24:34 <kadoban> I like that part of Array. It makes it easy to do 0-based, 1-base, arbitrary, etc.
16:25:00 <jplatte> dfeuer: My use case right now is an Array of two elements
16:25:13 <jplatte> With the indices Black and White (for the player's colors / sides)
16:25:16 <dfeuer> Why would you want that?
16:25:21 <dfeuer> Really.
16:25:28 <kadoban> jplatte: two elements? Maybe you should just use a tuple?
16:25:46 <arbelos> ReinH, thanks..  but does this take care of the memoization? I am not sure I get it
16:26:00 <jplatte> kadoban: But then I have to special-case both sides
16:26:30 <ReinH> arbelos: it doesn't memoize, it calculates the length at the same time it walks the list
16:26:47 <ReinH> so it only calculates the length once, and only in the case where n is greater than the length
16:26:49 <kadoban> jplatte: … hmm, I guess I'm not sure what you mean.
16:26:56 <arbelos> but in terms of calling this function over and over that doesn't make a difference
16:27:14 <jplatte> With an array, I can fmap a function onto both elements simultaneously
16:28:04 <ReinH> arbelos: well, there's nothing you can do about that. In order to memoize a list you have to... evaluate the list.
16:28:07 <jplatte> Oh wait a second, this whole thing I'm trying to do is unnecessary :D
16:28:43 <jplatte> I can just save the color in the data I wanted to save in the array
16:28:59 <jplatte> So it's probably not gonna be an array, but just a list that always holds two elements
16:29:23 * hackagebot exceptional 0.1.3.0 - Essentially the Maybe type with error messages.  http://hackage.haskell.org/package/exceptional-0.1.3.0 (pharpend)
16:29:35 <ReinH> arbelos: memoizing the list would do more work!
16:31:08 <arbelos> ReinH. yes I am probably over-thinking things here, a simple `mod` is maybe best
16:31:24 <cstrahan> is there a standard way to convert an int to little-endian, while being a no-op on LE architectures?
16:31:31 <ronh-> " I made this library because I was dissatisfied with the Monad instance for Either. In this type, fail = Failure. It's rather simple."
16:31:44 <ronh-> what is fail in Either?
16:31:53 <cstrahan> this is the top search result on google: https://hackage.haskell.org/package/cpu-0.1.0/docs/System-Endian.html
16:32:12 <cstrahan> but that performs a check every time, on all archs :|
16:32:39 <ReinH> ronh-: it can't know that the Either is an Either String
16:32:44 <ReinH> so it can't use fail = Left
16:35:25 <ion> fail = Left . unsafeCoerce
16:36:31 <mniip> hmm, is there an elegant way to conditionally append/prepend an element to a list
16:36:33 <relrod> Is there something like Data.Map.fromList but instead of type [(k,a)] -> Map k a, has type [(k, a)] -> Map k [a] and on duplicate keys it appends the values to the list instead of replacing the value?
16:36:50 <mniip> I keep writing stuff like (if p then (x:) else id) xs
16:37:09 <kadoban> relrod: fromListWith
16:37:42 <kadoban> relrod: It's not exactly that, but you can make it fit
16:37:54 <relrod> kadoban: yep, that'll work. Thanks
16:38:54 <areologist> ReinH, on that recommended reading page you have a caveat about RWH (2008) being out of date, but no such warning about Bird (1998) and Thompson (1999). What accounts for this? Thanks. :-)
16:39:15 <ReinH> areologist: RWH has a focus on libraries that makes it more time-sensitive
16:39:26 <ReinH> Bird and Thompson have a focus on principles of FP that are more timeless
16:39:36 <areologist> thanks!
16:39:53 <ReinH> Also Bird's Thinking Functionally with Haskell was just released and is a rewrite of 1998
16:40:01 <ReinH> I haven't updated my page with it yet
16:40:07 <ion> mniip: This is not any more elegant, but shorter: bool id (x:) p xs
16:40:38 <ion> Or just bool xs (x:xs) p
16:42:01 <ReinH> heh
16:42:06 <ReinH> which is a bit more elegant, perhaps
16:42:24 <small-wolf> if you're using apache and writing fastcgi scripts in haskell, where should the connection pooling for your database logic live? 
16:43:43 <ReinH> In each Haskell process. People write fastcgi scripts in Haskell?
16:44:03 <small-wolf> there's an apache module I need to test for work
16:44:12 <ion> HTTP > FastCGI
16:44:17 <ReinH> I mean, there's nowhere else for it to live, so...
16:44:24 <mniip> ion, I'd rather avoid write xs twice
16:44:41 <mniip> because xs is a similar expression consisting of appending to the end
16:44:57 <ReinH> mniip: operationally, it doesn't matter how many times you write xs
16:45:05 <small-wolf> I guess I'm wondering if there's a good way to have apache manage the connections and my haskell scripts talk to apache
16:45:09 <mniip> true but
16:45:11 <ReinH> if it's an aesthetic thing, I disagree, but that's subjective
16:45:44 <ReinH> small-wolf: I doubt it
16:45:52 <small-wolf> or alternatively how I have persistent stuff in my haskell process
16:46:00 <ReinH> But I haven't used fcgi in a decade, so
16:46:23 <ion> mniip: Note that appending to a list is an O(n) operation.
16:47:05 <ReinH> Well, fcgi processes are persistent, so you would store it in process
16:47:26 <ReinH> as in, in memory
16:49:47 <Zemyla> Is there a way I can get a ForeignFunPtr?
16:50:28 <Zemyla> I'm writing a Haskell wrapper around a JIT library, GNU Lighting, which is much more lightweight than LLVM.
16:51:28 <lpaste> mniip pasted “polynomial stuff” at http://lpaste.net/132644
16:51:45 <mniip> some exceptionally unidiomatic code there, not sure where to approach it ._.
16:52:00 <Zemyla> And it produces code at run-time, so I need to be able to finalize the data structures the C library produces when the pointer goes out of scope.
16:56:31 <arbelos> ReinH.. Here is another option: http://lpaste.net/132645
16:56:56 <arbelos> at least then I could write something like [1,2,3,4] !% 1000 $ 4
16:57:15 <arbelos> a bit weird perhaps
16:58:02 <arbelos> and not that different from just computing the mod of the index directly i guess.. hmm
16:58:40 <hiptobecubic> arbelos, that is awful
16:58:50 <arbelos> hehe.. why
16:58:59 <hiptobecubic> because someone else will have to look at it some day
16:59:01 <ReinH> arbelos: if you already know the list length, you don't need that function anyway
16:59:13 <hiptobecubic> and spend ten minutes figuring out why you're doing this
16:59:14 <arbelos> no but readability, guys.. hehe
16:59:31 <arbelos> ok i give up
17:00:11 <arbelos> i want !% semantics.. it makes sense.. lookup something.. but modulo the length of the list
17:00:57 <hiptobecubic> why not just take the mod of the index?
17:01:41 <ReinH> I mean, xs !! (n `mod` length xs) is pretty reasonable
17:01:49 <ReinH> walking the spine of a list is pretty fast
17:01:52 <SrPx> "Convert an array of given length into a Haskell list. The implementation is tail-recursive and so uses constant stack space." <- I don't understand - does that mean if I imediately convert the list to a vector, GHC will know not to materialize the whole list and just fill the vector instead?
17:01:58 <ronh-> !% would make more sense if it didn't require length argument
17:02:08 <c_wraith> lists are an annoying structure to do that with though, since it requires finding the length
17:02:31 <c_wraith> arbelos: how about...  cycle xs !! n
17:02:36 <ReinH> c_wraith: I gave an alternative that found the list while walking it
17:02:39 <c_wraith> Still really inefficient!
17:02:41 <ReinH> found the length
17:02:50 <arbelos> c_wraith linear time?
17:02:57 <c_wraith> O(n)
17:03:04 <ronh-> so is !
17:03:07 <ronh-> !! even
17:03:17 <ReinH> they're all linear time, it's about the constants
17:03:28 <arbelos> i am looking up huge numbers here
17:03:33 <ReinH> arbelos: then don't use a list
17:03:37 <hiptobecubic> right
17:03:44 <arbelos> well the list is small
17:03:50 <arbelos> but the number is huge before the `mod
17:03:58 <ReinH> Then use xs !! (n `mod` length xs)
17:04:19 <arbelos> yes that is what i have
17:04:27 <c_wraith> well, if the lists change infrequently, you should make an effort to cache list lengths
17:04:38 <arbelos> the length doesn't change at all
17:04:46 <ReinH> then cache the length somewhere
17:04:56 <arbelos> otherwise i wouldn't be thinking about this
17:05:31 <cite-reader> Is there a reason you're not using a vector?
17:05:47 <arbelos> yes.. that lead me to the whole !% idea .. but i agree, it is better to just do (n `mod` len) then
17:06:34 <ReinH> you could just memoize the whole function
17:06:44 <ReinH> well
17:06:50 <ReinH> memoize the part before taking the mod
17:06:54 <ReinH> er, after taking the mod
17:06:57 <ReinH> because taking the mod is fast
17:07:02 <ReinH> and there's no reason to keep all that in memory
17:07:48 <ReinH> so memoize xs !! n for all n and then calculate n each time
17:09:19 <hiptobecubic> or just use a vector with constant time indexing?
17:09:34 <hiptobecubic> or an Array or whatever
17:10:47 <ronh-> or just do it the simplest way and don't bother optimizing until you profile
17:11:09 <arbelos> hmm, the paradox of choice enters my mind
17:11:26 <arbelos> overchoicification
17:12:06 <ReinH> "do the simplest thing that could possibly work"
17:12:31 <ReinH> hiptobecubic: constant time doesn't say what the constants are ;)
17:13:03 <ReinH> besides an IntMap is has constant time lookup if its size is fixed ;)
17:13:10 <ReinH> s/is //
17:14:01 <ronh-> ReinH you're suggesting memoization without even knowing that this will be the bottle neck. I'd call that premature optimization
17:14:16 <ReinH> I don't disagree.
17:14:38 <ronh-> when you have a small list !! and length are often fast enough
17:14:40 <hiptobecubic> Sure, it's just strange to take a list that you want to index into, zip it up with the naturals-1 and then turn it into a map. Readers will wonder why it's not just an array
17:14:47 <hiptobecubic> or just a list
17:15:12 <ReinH> ronh-: yes, that's what I originally said. I'm just mentioning options.
17:15:28 <ReinH> Notice I said "could", not "should".
17:17:16 <ReinH> hiptobecubic: wait, your naturals don't include 0?
17:17:23 <ReinH> that's the real point of contention here
17:18:06 <hiptobecubic> ReinH, I think they should. Some people don't. 
17:18:26 <ReinH> hiptobecubic: I like my naturals to form an additive monoid ;)
17:19:59 <hiptobecubic> :)
17:20:14 <hiptobecubic> Well i have to go. Pleasure bikeshedding optimizations with you all
17:20:19 <ReinH> hiptobecubic: indeed, take care
17:23:41 <user1_> what's the most up to date information about using cabal sandbox etc?
17:27:57 <ReinH> user1_: they haven't changed too much since http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
17:39:26 * hackagebot easy-file 0.2.1 - Cross-platform File handling  http://hackage.haskell.org/package/easy-file-0.2.1 (KazuYamamoto)
17:39:28 * hackagebot newsynth 0.3 - Exact and approximate synthesis of quantum circuits  http://hackage.haskell.org/package/newsynth-0.3 (PeterSelinger)
18:02:46 <e4x> how can i demonstrate that haskell is strongly typed?
18:03:33 <KaneTW> that's kinda a silly question
18:04:27 * hackagebot stackage-sandbox 0.1.3 - Work with shared stackage sandboxes  http://hackage.haskell.org/package/stackage-sandbox-0.1.3 (DanBurton)
18:05:15 <Pamelloes> I'm trying to define a function (:=) but I'm getting the error invalid type signature
18:05:32 <geekosaur> @paste
18:05:32 <lambdabot> Haskell pastebin: http://lpaste.net/
18:05:34 <c_wraith> Pamelloes: : is considered a "capital" letter
18:05:36 <ReinH> Step 1, define "strongly typed"
18:05:47 <geekosaur> but yes, initial : would be a constructor
18:06:06 <Pamelloes> c_wraith: So (:=) would be a data constructor not a function.
18:06:09 <c_wraith> yes
18:06:17 <Pamelloes> Huh.
18:06:20 <ReinH> It would be a data constructor and a function
18:06:26 <KaneTW> it's useful for defining type level operators
18:06:31 <geekosaur> by analogy from lists using (:) as constructor
18:07:00 <Pamelloes> I guess I'll have to find another name/change my types :)
18:07:27 <KaneTW> (|=) maybe
18:07:51 <e4x> ReinH: languages where i cant convert a type to another
18:07:52 <Pamelloes> KaneTW: Good idea 
18:09:22 <Pamelloes> e4x: That's a bit limiting of a definition. How would you get anything done if you couldn't convert between types? For instance, in Java—a strongly typed language—you can use .toString() to turn any Object into a String.
18:09:27 * hackagebot newsynth 0.3.0.1 - Exact and approximate synthesis of quantum circuits  http://hackage.haskell.org/package/newsynth-0.3.0.1 (PeterSelinger)
18:10:06 <ReinH> Of all of the definitions I have ever heard used for "strongly typed" , I have never heard that one
18:10:17 <KaneTW> ^
18:10:31 <ReinH> http://en.wikipedia.org/wiki/Strong_and_weak_typing
18:10:58 <geekosaur> strongly typed implies no implicit conversions, explicit ones are fine
18:12:04 <ReinH> So by that definition, no, Haskell is not strongly typed. But neither is any other programming language.
18:12:47 <e4x> for example, C is weakly typed because of casting
18:12:48 <thomaseding> lol wut?
18:13:03 <ReinH> :t Jost
18:13:04 <lambdabot>     Not in scope: data constructor ‘Jost’
18:13:05 <lambdabot>     Perhaps you meant ‘Just’ (imported from Data.Maybe)
18:13:05 <ReinH> :t Just
18:13:06 <lambdabot> a -> Maybe a
18:13:13 <ReinH> There's a function that converts a type into another
18:13:18 <ReinH> So Haskell isn't strongly typed
18:13:22 <thomaseding> EXPLICITLY
18:13:57 <ReinH> That wasn't a criteria.
18:14:03 <thomaseding> o
18:14:59 <ReinH> If you mean implicit coercions, then Haskell is strongly typed (except for the presence of unsafeCoerce, which is special)
18:15:41 <arbelos> i think safety is a better notion than strength
18:16:04 <arbelos> well-formed implies well "behaved"
18:16:24 <haasn> I think there's a difference between implicit and explicit type coercions
18:16:43 <ReinH> haasn: of course
18:16:45 <haasn> And both are notions of “weakness”, but I think “weak typing” often refers to implicit type coercions
18:17:12 <haasn> Maybe they should be called “implicit weak typing” and “explicit weak typing” to distinguish between them
18:17:37 <ReinH> haasn: The problem is that "strongly typed" isn't a well defined term
18:18:04 <ReinH> I asked for a definition and got one that implied that Just was a demonstration that Haskell isn't strongly typed
18:18:09 <arbelos> another thing, can a language be "more expressive" but less safe? hmmm.
18:18:16 <haasn> ReinH: Very many terms used to describe programming languages are not well defined
18:18:40 <haasn> I have a particular dislike for “functional programming language”
18:18:51 <ReinH> haasn: I like "denotative programming"
18:18:51 <haasn> In comparison to that, I think “strongly typed” is rather mild
18:19:20 <haasn> ReinH: I personally think the opposite of “imperative programming” is “declarative programming”; ie. instead of saying *how* to get somewhere, you say *what* something is
18:20:02 <ReinH> haasn: and I think that a useful distinction is between "what something does" is "what something means" :)
18:21:24 <haasn> ReinH: That seems like a rephrasing of my quotes from a different viewpoint (focused on the code itself, not the answer it computes)
18:21:39 <ReinH> haasn: sure I think they are similar
18:21:49 <haasn> Which is perhaps also an interesting way to classify programming languages - do you focus on the code, or on the answer
18:21:57 <haasn> for example answer set programming and logic programming tends towards the latter
18:22:02 <haasn> but even haskell tends towards the former IMO
18:22:04 <ReinH> "denotative programming" comes from Landin http://dl.acm.org/citation.cfm?id=365257&dl=ACM&coll=DL&CFID=511680199&CFTOKEN=44638160
18:22:33 <ReinH> and Haskell does actually let you talk about meanings, at least some of the time
18:23:02 <ReinH> (i.e. the times when you aren't talking about IO)
18:23:07 <haasn> Maybe this spectrum should look like a square, with method <-> answer on one axis and instruction <-> definition on the other?
18:23:24 <ReinH> haasn: yes, I'm sure the design space has more than one dimension :)
18:23:43 <haasn> How many dimensions does it have? :p
18:24:03 <ReinH> more than one.
18:24:04 <ReinH> :p
18:24:28 * hackagebot happstack-server 7.4.4 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.4.4 (JeremyShaw)
18:24:29 * hackagebot amqp-conduit 0.2.0.0 - Conduit bindings for AMQP (see amqp package)  http://hackage.haskell.org/package/amqp-conduit-0.2.0.0 (toru_tomita)
18:26:00 <Pamelloes> If I have a function a -> b -> c, is there a way to partially apply the function to get b -> c, and then somehow get a from the partially applied function?
18:26:31 <hiptobecubic> Pamelloes, how would you get an 'a' from a function of type 'b -> c' ?
18:26:40 <Pamelloes> I have no idea.
18:26:45 <geekosaur> there is not, unless the function has a right identity (that is, some specific b that produces a)
18:27:05 <ReinH> Pamelloes: no, unless you have a b -> a lying around that produces the correct a
18:27:05 <arbelos> You would have to encapsulate that in some data type
18:27:38 <ReinH> functions are opaque, you can't look inside them
18:27:49 <Pamelloes> Hm. So I could probably do it with a monad, but not just that.
18:27:56 <ReinH> (which always seemed like a strange way to use "opaque" to me, but anyway)
18:28:54 <ronh-> Pamelloes why don't you just keep a and original function?  (a, a -> b -> c) or data equivalent
18:29:28 * hackagebot happstack-server-tls 7.1.6 - extend happstack-server with https:// support (TLS/SSL)  http://hackage.haskell.org/package/happstack-server-tls-7.1.6 (JeremyShaw)
18:30:06 <Pamelloes> ronh-: Well, I have a way I want the syntax of my library to work that involves using said function in a few different contexts. But I guess that syntax isn't possible.
18:31:38 <arbelos> some monadic magic maybe
18:33:10 <Pamelloes> Nah, I'm just going to use some auxiliary functions. It'll make more sense anyway,
18:34:52 <geekosaur> I am thinking not monadic, just a data type for "pending functions" that would allow you to pattern match to pull out the parameter or apply it to get the result
18:34:58 <geekosaur> might need a typeclass
18:35:21 <geekosaur> (if the types change along the way)
18:36:27 <Pamelloes> geekosaur: That would work, but any solution would require some form of encapsulation which is what I was trying to avoid. If I have to use some form of encapsulation, it's easier just to pass around a and provide a separate a->b->c function to be used as needed.
18:38:43 <ReinH> Pamelloes: if the b -> c function needs an a, it's really an a -> b -> c function ;)
18:39:22 <ReinH> You might consider Reader a
18:39:39 <Pamelloes> ReinH: Exactly. I wanted to pass around the partially applied a->b->c function for a variety of use cases, but I've realized it's easier just to pass around an a and only apply the function when it's needed.
18:44:28 * hackagebot happstack-hsp 7.3.5 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-7.3.5 (JeremyShaw)
18:46:53 <Tordek> hi, so, I just made the most trivial implementaion of Game Of Life; that is, https://gist.github.com/Tordek/9dd76adb626b22a62ac7 the step function, Board->Board, where Board is a function Position -> (Alive | Dead), makes a new board that checks the neighbors and the cell of the provious board
18:47:13 <Tordek> so, obviously, each step takes 9 times as long as the previous
18:48:09 <Tordek> now, I could memoize it on each step, but other than that, how coul I implement it nicely?
18:48:28 <Tordek> (ideally, infinitely large board)
18:49:44 <pacak> http://blog.emillon.org/posts/2012-10-18-comonadic-life.html 
18:50:07 <Tordek> thanks!
18:50:26 <pacak> Tordek: Please come back and share your findings :)
18:54:28 * hackagebot happstack-jmacro 7.0.10 - Support for using JMacro with Happstack  http://hackage.haskell.org/package/happstack-jmacro-7.0.10 (JeremyShaw)
18:54:30 * hackagebot happstack-clientsession 7.3.0 - client-side session data  http://hackage.haskell.org/package/happstack-clientsession-7.3.0 (JeremyShaw)
19:03:46 <ReinH> Tordek: see also https://www.fpcomplete.com/user/edwardk/cellular-automata/part-2
19:03:46 <athan> When I typecheck an AST, I just fold down the tree, right?
19:04:11 <ReinH> athan: I think I'm missing some context for your question
19:04:28 * hackagebot reform 0.2.7 - reform is an HTML form generation and validation library  http://hackage.haskell.org/package/reform-0.2.7 (JeremyShaw)
19:04:33 <athan> ReinH: Yeah sorry I'm being vague. I want to try my hand at sub-HM typechecking
19:04:43 <athan> I'm thinking I can get away with it by just folding over the tree
19:04:52 <ReinH> Tordek: (btw the big deal for GoL optimization is Hashlife, http://en.wikipedia.org/wiki/Hashlife)
19:04:52 <athan> where a list (sequent?) is the accumulator
19:05:05 <athan> then I can unify (?) the list's judgements, right?
19:05:12 <ReinH> athan: have you read this? http://web.cecs.pdx.edu/~mpj/thih/TypingHaskellInHaskell.html
19:05:17 <athan> No!!
19:05:24 <athan> thanks ReinH :)
19:05:25 <ReinH> athan: maybe you should :)
19:06:11 <ReinH> athan: I function primarily as specialized search engine ;)
19:07:38 <dbelange> is it possible to make a haskell compuiler in vanilia haskell, or does it require a grothenidieck universe
19:12:13 <monochrom> firstly, have you confirmed that vanilla haskell is not already a grothenidieck universe?
19:12:21 <SrPx> it is perfectly possible, why not
19:17:44 <simpson> What's special about a compiler as opposed to any other kind of code?
19:18:48 <athan> simpson: Well, it's a language translator for one
19:19:01 <grpala> simpson: speed, checks
19:19:08 <athan> usually reducing the size of the input expression, also
19:19:29 * hackagebot reform-blaze 0.2.4 - Add support for using blaze-html with Reform  http://hackage.haskell.org/package/reform-blaze-0.2.4 (JeremyShaw)
19:19:32 * hackagebot reform-happstack 0.2.5 - Happstack support for reform.  http://hackage.haskell.org/package/reform-happstack-0.2.5 (JeremyShaw)
19:22:27 <ajf> Hi
19:22:33 <ReinH> ajf: hi
19:22:38 <ajf> I keep getting 'arning: Defaulting the following constraint(s) to type ‘Integer’' when I try to do ^2
19:22:49 <ajf> is there a way to make GHC shut up about it
19:23:26 <simpson> athan: Well, I'm just shifting this in my mind. Would vanilla Haskell not be unable to translate any language to any other language, given the appropriate algorithm?
19:23:28 <ajf> Well, I'm using -Wall, but what's actually wrong with the code? Does it have to be ^ (2 :: Int) or something?
19:23:54 <ajf> ...oh, I just answered my own question
19:23:58 <ajf> that is a bit hideous, though
19:24:30 * hackagebot reform-hsp 0.2.6 - Add support for using HSP with Reform  http://hackage.haskell.org/package/reform-hsp-0.2.6 (JeremyShaw)
19:24:35 <ajf> Is there a shorter form than (2 :: Int) ?
19:25:34 <hiptobecubic> type I = Int; (2 :: I)
19:25:37 <hiptobecubic> :)
19:25:38 <pacak> ajf: Sure, (2::Int)
19:25:42 <ajf> pacak: hah
19:25:50 <dolio> ajf: If you want to turn it off, use -fno-warn-type-defaults.
19:26:03 <ajf> dolio: I guess I could do that, but I suppose it's a useful error
19:26:08 <ajf> er, warning
19:26:19 <ajf> just this specific instance was rather irritating
19:26:23 <hiptobecubic> It is if you care about performance
19:26:35 <ajf> hiptobecubic: ah, because it defaults to Integer not Int?
19:26:39 <hiptobecubic> yes
19:26:43 <ajf> gotcha
19:27:08 <ajf> In my case I'm compiling to JS using Haste (which uses GHC, thus the warnings), and I'm pretty sure bigints are NOT fast there
19:27:18 <dolio> Well, if you want performance, you can change the default to Int.
19:27:27 <ajf> It can be specified?
19:27:30 <dolio> Yes.
19:27:44 <dolio> On a per-module basis.
19:27:54 <VonLeon> Anyone tell me what is wrong with this: start_game::Word->Word->[Int]->IO () start_game actual_word morphed_word index_list     | actual_word == morphed_word = do         putStrLn "You won!"     | otherwise = do     putStrLn $ "Your word is: " ++ morphed_word     user_input <- getLine     putStrLn user_input          if length (user_input) == 1         then         user_word      = Util.check_letter_presence actual_word (head user_inp
19:27:58 <VonLeon> dammit sorry
19:28:05 <VonLeon> http://lpaste.net/132650
19:28:06 <VonLeon> That
19:28:22 <VonLeon> I included error messages and comments in the paste
19:29:10 <dbelange> monochrom: a groethendieck universe requires new axioms
19:29:16 <dbelange> such as the axiom of choice
19:29:21 <dolio> ajf: "default (Int, Integer, Double, Float)" will set up the defaults to choose in the specified order.
19:29:30 * hackagebot elocrypt 0.3.0 - Generate easy-to-remember, hard-to-guess passwords  http://hackage.haskell.org/package/elocrypt-0.3.0 (sgillespie)
19:29:31 <shoopaloop> VonLeon: Try using 'let' ?
19:29:52 <VonLeon> ohhh crap it's still inside the do block?
19:30:04 <VonLeon> whoops, I'll try that
19:30:12 <ReinH> ajf: does js even have bigints?
19:30:16 <ReinH> I think it just has floats
19:30:20 <pacak> VonLeon: Format your code, this one is hard to read.
19:30:27 <dbelange> monochrom: and large cardinals which are larger than the computers RAM
19:30:31 <shoopaloop> you need to use let if you are not binding at the top level
19:30:31 <athan> Is the reduction function for lambda expressions usually called `eval`?
19:30:36 <pacak> Not just to us, but also to ghc and yourself.
19:31:02 <shoopaloop> not just in do blocks
19:31:11 <VonLeon> pacak: My bad, I'm new the language, very used to braces doing that for me. If I use a let, it returns the same error
19:31:22 <ReinH> pacak: GHC has no problem reading it ;)
19:31:54 <ReinH> @google haskell layout
19:31:55 <lambdabot> Plugin `search' failed with: connect: does not exist (No route to host)
19:31:59 <ReinH> Ok then
19:32:15 <VonLeon> Actually no, the let works, it then states parse error for the recursive call
19:32:19 <ReinH> VonLeon: haskell's layout rules are simple, but absolute http://en.wikibooks.org/wiki/Haskell/Indentation
19:32:24 <pacak> ReinH: s/reading/understanding/
19:32:32 <ReinH> pacak: oh, it understands it to
19:32:36 <ReinH> it understands it better than we do, I would say
19:32:39 <pacak> Just in a different way...
19:32:44 <VonLeon> ReinH: I really need to grind that into my brain over the summer
19:33:19 <ReinH> protip: if you and the compiler disagree over how to interpret some source code, you are probably wrong
19:33:27 <shoopaloop> Maybe use 'let {bindings} in {statement}' ?
19:33:55 <VonLeon> Well yea...blaming myself has served me pretty well so far
19:34:13 <oldmanmike> Does GHC's GC store record data types contiguously in memory?
19:34:14 <pacak> ReinH: Except when compiler is wrong - I've managed to find and report a few bugs in ghc myself...
19:34:19 <arbelos> If I am doing a fold over some list and need to do some arithmetic involving the index of each element.. Typical for-loop kind of thing.. I can write something like fold' go $ zip [0 .. ] input
19:34:30 * hackagebot web-routes 0.27.9 - Library for maintaining correctness and composability of URLs within an application.  http://hackage.haskell.org/package/web-routes-0.27.9 (JeremyShaw)
19:34:32 * hackagebot web-routes-boomerang 0.28.4 - Library for maintaining correctness and composability of URLs within an application.  http://hackage.haskell.org/package/web-routes-boomerang-0.28.4 (JeremyShaw)
19:34:34 * hackagebot datadog 0.1.0.0 - Datadog client for Haskell. Currently only StatsD supported, other support forthcoming.  http://hackage.haskell.org/package/datadog-0.1.0.0 (IanDuncan)
19:34:44 <arbelos> is there a more elegant way of doing this, or more idiomatic  i should say maybe
19:34:46 <pacak> oldmanmike: pointers to fields - yes, fields themselves - not always.
19:34:48 <VonLeon> http://lpaste.net/132651 I get the error "Parse error on input 'start_game'"
19:34:55 <VonLeon> the recursive call, that is
19:35:12 <ReinH> pacak: thus "probably" ;)
19:35:15 <ajf> dolio: thanks
19:35:42 <oldmanmike> arbelos: Say the fields were something like !Double#?
19:35:43 <ReinH> arbelos: yes, no
19:35:58 <shoopaloop> VonLeon: You need to but the word 'in' before the start_game line, I think
19:35:59 <pavonia> VonLeon: You need to start a new do-block in the then/else branches
19:36:14 <ReinH> arbelos: zip [0..] is often useful
19:36:18 <arbelos> oldmanmike, I don't follow..
19:36:22 <ajf> ReinH: JS doesn't have a native bigint type no, thus the poor performance in that case. It does have native 32-bit integers in a sense - while there's no actual 32-bit int type, all the bitwise ops coerce to 32-bit int, most JS engines store small numbers as 32-bit, and all integer value ops in JS act as if Number is a 32-bit int
19:36:27 <ReinH> lens provides some tools for indexed folding though
19:36:34 <pacak> oldmanmike: In that case - yes, you can also use {-# UNPACK #-}
19:36:42 <VonLeon> in would just change the scope, would it not?
19:36:57 <ReinH> arbelos: oldmanmike addressed you by mistake :)
19:37:04 <VonLeon> pacak: like how? do, then indent, those functions are all pure except start_game
19:37:06 <arbelos> oh.. ok 
19:37:21 <arbelos> ReinH.. I am happy with the zip [0..] thing, but it feels a bit like a "fake" for-loop
19:37:32 <ReinH> arbelos: no, it's pretty common
19:37:48 <oldmanmike> arbelos: Yeah, sorry about that :)
19:37:53 <ReinH> and doesn't add significant extra overhead
19:37:57 <arbelos> oldmanmike. no problem :)
19:38:15 <ReinH> with optimizations turned on the intermediate list values should be deforested even
19:38:24 <ReinH> so almost no extra overhead
19:38:32 <pacak> VonLeon: Take some time reading that link about formatting, then take some time poking around base library. Then try to rewrite your code in a standard haskell way. I don't say it wrong, but it's hard to think about it.
19:38:38 <jmcarthur> i'm not sure that's true of zip
19:39:30 * hackagebot web-routes-hsp 0.24.6 - Adds XMLGenerator instance for RouteT monad  http://hackage.haskell.org/package/web-routes-hsp-0.24.6 (JeremyShaw)
19:39:32 * hackagebot web-routes-th 0.22.3 - Support for deriving PathInfo using Template Haskell  http://hackage.haskell.org/package/web-routes-th-0.22.3 (JeremyShaw)
19:40:16 <ReinH> jmcarthur: there are rules for zip
19:40:22 <ReinH> http://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-List.html#zip
19:41:36 <ReinH> and zipWith
19:41:40 <oldmanmike> pacak: So {-# UNPACK #-} is just a fancy pragma for unboxing, or does do more than #?
19:41:54 <ReinH> oldmanmike: # doesn't do anything
19:42:23 <ReinH> "The hash sign does not change semantics at all." https://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/syntax-extns.html
19:43:03 <pacak> oldmanmike: It allows you to unbox not only primitive types but other stuff as well.  A Int {-# UNPACK #-} (Int, Int) is more or less the same as A Int Int Int
19:43:08 <Pamelloes> if I have newtype MyType m a = MyType { unMT :: StateT (Int) m a }, is there a way from within MyType to modify the underlying state?
19:45:01 <ReinH> Pamelloes: If you make it an instane of MonadState Int, you can use the MonadState typeclass
19:45:04 <ReinH> *instance
19:45:10 <ReinH> This can be derived using GeneralizedNewtypeDeriving
19:45:22 <jmcarthur> ReinH: ah, using that elisive foldr2...
19:45:38 <pacak> ReinH: Or probably with unsafeCorerce as well?
19:45:51 <Pamelloes> ReinH: So is there not a way to unbox the monad?
19:46:16 <ReinH> Pamelloes: "unbox the monad"? You have unMT.
19:47:06 <ReinH> pacak: no need to reach for the dynamite to open a door.
19:47:11 <Denommus> Pamelloes: what sense does it make to "unbox" a monad? 
19:47:34 <Denommus> Pamelloes: how would you "unbox" a list? 
19:47:41 <Pamelloes> Denommus: I'm not quite sure...
19:47:47 <ReinH> @unmtl State Int
19:47:47 <lambdabot> Plugin `unmtl' failed with: `State Int' is not applied to enough arguments, giving `/\A. Int -> (A, Int)'
19:47:51 <ReinH> @unmtl State Int a
19:47:52 <lambdabot> Int -> (a, Int)
19:47:59 <ReinH> State isn't hiding an Int somewhere
19:48:22 <ReinH> and generally, monads can't be "unboxed"
19:49:20 <Pamelloes> I'm aware. But MyType is hiding the StateT. I have a function addInt :: MyType m => Int -> m (). I'd like to add the first parameter to the encapsulated StateT, but I don't really know how...
19:50:08 <pacak> Pamelloes: Make an instance of MonadState for your type
19:50:23 <pacak> :t state
19:50:25 <Pamelloes> pacak: Is there a way to do it without doing that?
19:50:25 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
19:50:51 <pacak> Pamelloes: There is, but it involves using the dynamite to open a door....
19:51:09 <ReinH> \n -> MyType . modify (+n) . unMT
19:51:13 <ReinH> pacak: not at all
19:51:39 <Pamelloes> ReinH: That's what I was missing. Thanks :)
19:51:47 <ReinH> just unwrap and wrap the newtype
19:51:48 <pacak> ReinH: Come on! adding/removing MyType manually is boooooooring.
19:52:16 <ReinH> I've learned to be deeply suspicious of exciting solutions to programming problems.
19:52:20 <pacak> Pamelloes: Adding that instance is just one line.
19:52:36 <monochrom> you must be that guy in The Muppets. the guy who uses dynamites on slight pretext for fun.
19:52:54 <ReinH> {-# LANGUAGE GeneralizedNewtypeDeriving #-} deriving (MonadState Int)
19:52:57 <ReinH> done
19:53:14 <Pamelloes> I must say I'm partial to the casual big boom.
19:54:36 <Pamelloes> But in this case, I'm using a newtype to hide an inner type that I'm going to be changing a lot. I'd rather not expose the internals so the outer type remains constant.
19:55:13 <ReinH> so use the typeclasses
19:55:22 <ReinH> that is exactly why they exist
19:55:25 <pacak> dynamite!
19:56:39 <ReinH> Large source listings on hackage crash my browser! yay!
19:59:13 <ReinH> johnw: ooh, I found a paper I should read http://www.janis-voigtlaender.eu/papers/AFamilyOfSyntacticLogicalRelationsForTheSemanticsOfHaskellLikeLanguages.pdf
20:02:16 <haasn> ReinH: It boggles my mind to think about the fact that we can decode, postprocess and render 4096x2160 60 Hz videos smoothly in realtime, passing around simply enormous amounts of data and running hundreds of GFLOPS of calculations on them;  and yet opening a simple “plain text” website slows my browser to a crawl if I enable javascript
20:02:37 <haasn> The web is a mess, and so is every single browser
20:02:42 <jgcoded> Hello, I'm looking for advice in figuring out how to turn a requirement into code. I am given a set of coordinates which represent a point X, Y, and each coordinate is on one line. So far I've defined a data type and now I need to actually fill in the function, but how to proceed from here is not obvious to me. Here is a gist: https://gist.github.com/anonymous/3a1d79ad9e3731eb81b3
20:02:45 <ReinH> haasn: let alone run games at that resolution
20:02:59 <ReinH> I mean honestly how even
20:04:03 <ReinH> jgcoded: ignoring the plain text format for a moment, what does it mean to be "above ground"?
20:04:30 <ReinH> Ah.
20:04:44 <R0b0t1> So, you're reading in the paper about programming or math and you notice they got it completely wrong! But you turn to the next page and do not question the article on international relations.
20:04:44 <R0b0t1> The same applies to jobs. Half of all web developers are below average.
20:04:46 <jgcoded> bigger Y coordinate than the ground. You're basically a Mars lander and you need to land on flat ground
20:05:34 <ReinH> jgcoded: are the ground coordinates guaranteed to be in order by x?
20:05:54 <ReinH> well, it doesn't matter, you can sort them
20:05:58 <jgcoded> yeah the coordinates are sequential
20:06:29 <Pamelloes> R0b0t1: Well, technically half of all web developers are below the median web developer
20:06:45 <Pamelloes> Averages can be skewed.
20:07:08 <haasn> jgcoded: So you basically need to find the two ‘points’ that are resp. below and above the specified ‘X’ coordinate?
20:07:18 <haasn> (And then compare their Y coordinates)
20:07:31 <ReinH> so fold over pairs of coordinates and look for the right pair, then compare their y coordinates
20:07:34 <R0b0t1> Pamelloes, well, I would assume web developing ability is normally distributed :^)
20:07:52 <R0b0t1> though it might be otherwise...
20:08:21 <haasn> jgcoded: Another way to think about the problem would be to think about it in terms of where the function is ‘yes’ and where it's ‘no’ - basically, as you're parsing the ground, you can store all of the sections during which the ground is not flat, and then simply see whether an ‘X’ is in this set or not
20:08:43 <haasn> Which transforms the problem into “how do I store a set of ranges and query it (efficiently?)?”
20:09:47 <haasn> jgcoded: But as an exercise, I think the former approach would be the easiest to approach :)
20:10:07 <jgcoded> but like
20:10:20 <jgcoded> my list of tuples isn't accessed by an index
20:10:28 <haasn> jgcoded: Yes, but you can step through them recursively
20:10:44 <haasn> jgcoded: think about it in terms of pattern matching. write out your function like this:
20:11:18 <haasn> case g of (x1,y1):(x2,y2):rest -> ...;  {- base case is also needed -}
20:11:46 <haasn> Think about the ways that ‘x’ can be in relation to x1 and x2
20:11:50 <jgcoded> base case is an empty list?
20:12:10 <haasn> jgcoded: Or a list with just one element (rather than two)
20:12:29 <jgcoded> alright i'm starting to see a solution
20:12:30 <haasn> (rather than two or more)*
20:12:41 <ReinH> > (\cs@((x,y),(x',y')) -> if y == y' then Just cs else Nothing) =<< (find (\((x,y),(x',y')) -> x < 2 && x' > 2) $ zip <*> tail $ [(1,3),(3,3),(5,1)])
20:12:42 <lambdabot>  Just ((1,3),(3,3))
20:12:51 <haasn> jgcoded: hint: your ‘isAboveFlatGround’ function will either have to call itself, or more likely, call some sort of sub-function
20:13:00 <ReinH> haasn: or not :)
20:13:09 <ReinH> well, I mean, yes, it calls some sub-functions...
20:13:12 <jgcoded> i'll create a sub-function that will have the pattern matching
20:13:17 <haasn> eg. isAboveFlatGround x (Ground n g) = find x g where {- define ‘find’ here -}
20:13:20 <haasn> exactly
20:13:45 <haasn> ReinH: Indeed, in this case the recursive sub-function is.. well.. I'm not quite sure what it is, actually :-)
20:13:51 <haasn> ReinH: Probably =<<
20:13:57 <codesoup> is there a standard variant of foldl/foldr where the function is the last argument so that you can write "$ \x acc -> ..." at the end like a foreach loop?
20:13:58 <ReinH> haasn: =<< doesn't recurse
20:14:09 <ReinH> I just need to choose a Maybe constructor based on the value given
20:14:10 <haasn> Oh, that's used with Maybe
20:14:25 <haasn> jgcoded: there's something else I want to quickly mention: You store ‘n :: Int’ in your Ground type, why?
20:14:26 <jgcoded> why would I use =<< in this context?
20:14:35 <ReinH> jgcoded: you might not. I did.
20:14:39 <jgcoded> n is how many coordinates there are
20:14:45 <jgcoded> in the list
20:14:58 <haasn> jgcoded: But the list already has a fixed and known length, which you can obtain by using ‘length g’ (if you really needed it)
20:15:04 <haasn> jgcoded: Is there a good reason for the redundancy?
20:15:14 <jgcoded> ah then no there is no good reason
20:15:20 <haasn> In particular: Do you need it for ‘isAboveFlatGround’?
20:15:33 <haasn> jgcoded: storing lengths is a common symptom of thinking about indices, which is something you mentioned earlier as well
20:15:44 <haasn> When recursing, you tend to care about neither lengths nor indices
20:15:57 <ReinH> haasn: or when not recursing! :D
20:16:13 <haasn> That too :-) 
20:16:20 <jgcoded> besides recursion, what is another common methodology of solving problems in haskell?
20:16:31 <ReinH> using things that do the recursion for you
20:16:32 <haasn> jgcoded: calling other functions that recurse for you
20:16:37 <ReinH> haasn: :p
20:17:10 <jgcoded> alright imma give this a shot
20:17:13 <haasn> jgcoded: Haskell structures are inherently very naturally recursive, so recursion is *the* most fundamental way of dealing with data
20:17:27 <dmj`> jgcoded: in order to understand recursion you must first understand recursion
20:17:35 <jgcoded> nice
20:17:40 <haasn> jgcoded: for example, lists are recursive. data List a = Empty | Cons a (List a)  <- recursive
20:17:55 <haasn> So anything that processes lists will also be very recursive
20:18:27 <haasn> jgcoded: That said, it's not the only way. There *are* fixed-length arrays in Haskell which you can index in constant time, but they're usually just used when you need them for high performance array-based algorithms
20:18:40 <jgcoded> that sounds like a good rule of thumb. Working with lists imply recursion
20:19:02 <haasn> Right, although most of the time the recursion is implicit and you're working with opaque functions
20:19:17 <haasn> For example, if you're modifying every element of a list, you would use eg. map (+1) xs
20:19:31 <haasn> But of course, ‘map’ is still internally recursive, you just don't care about it at this level of abstraction
20:20:02 <haasn> (map f [] = [];  map f (x:xs) = f x : map f xs)
20:20:59 <jgcoded> here's another question that has been bugging me for a while: When should I use a Monad? I know that a Monad is just a type class that Haskell provides some syntactic sugar, but I just don't ever see an application for it when I'm working in Haskell
20:21:28 <R0b0t1> state that needs to be parameterized against something. like time.
20:21:31 <johnw> jgcoded: until you need it, you can ignore it
20:21:33 <ReinH> jgcoded: here's an example using a monad http://lpaste.net/132652
20:21:46 <haasn> jgcoded: the best way to gain that intuition is to try it out when you think they might help, and then learn from your mistakes when it doesn't work out
20:22:55 <haasn> ReinH: I don't like this approach of solving the problem because it doesn't handle the edge cases cleanly; eg. passing 300 to the function given in the gist
20:23:16 <ReinH> why not?
20:23:29 <haasn> Because there is no (300, nothingElse) pair for ‘find’ to find
20:23:35 <haasn> err, no (250, nothingElse)
20:23:41 <ReinH> So?
20:24:24 <haasn> Oh, but that is just the Nothing case. I think that logic is backwards
20:25:01 <haasn> I would naively assume that if there's nothing specified past (250, 100) then anything past 250 would also be at Y coordinate 100
20:25:07 <johnw> jgcoded: I can give you an example of one of the few times when I truly "needed a Monad"
20:25:15 <haasn> And therefore for anything greater than 250 it would return True
20:25:36 <ReinH> haasn: It wasn't specified, so I chose one of the possible requirements
20:25:43 <jgcoded> johnw: sure I'd be interested in taking a look
20:25:46 <ReinH> which is that the ground ends
20:26:23 <haasn> ReinH: also makes sense; “isAboveFlatGround” -> no, because no ground exists :)
20:26:28 <ReinH> yep
20:26:31 <johnw> I have a pure library -- no IO at all -- which has callbacks for creating new nodes in a graph.  That way I don't need to know what graph representation is used.
20:26:57 <johnw> then came a day when I realized that perhaps my *caller* can't make new nodes without some kind of effect; maybe they need IO or something (who knows)
20:27:06 <ReinH> johnw: please share :)
20:27:16 <johnw> so I need an abstraction that say, "I don't know how you'll make this, I just need to know that you can"
20:27:30 <ReinH> haasn: you'll notice that I chose the one that makes my life easier ;)
20:27:41 <johnw> in essence, I have to "parameterize the process" that new nodes will be created by
20:27:58 <johnw> so, I changed my callback from Info -> Node, to Info -> m Node
20:28:11 <johnw> and my entry point from allocateNodes :: ... -> Result to allocateNodes :: ... -> m Result
20:28:22 <johnw> now note, I never know, and I never care, what 'm' is or can do
20:28:29 <ReinH> johnw: can you show the code?
20:28:34 <johnw> ReinH: it's not in Haskell
20:28:38 <ReinH> ok :)
20:28:47 <ReinH> johnw: is this an example of monads for substitution?
20:28:56 <johnw> I just need to know that 'm' supports composition operations that respect this yet-to-be-determined processing that will help
20:29:00 <johnw> s/help/happen
20:29:37 <johnw> ReinH: it's really just using monads to abstract effects
20:29:47 <haasn> johnw: What constraint did you end up settling with for ‘m’? Could you have gone with Applicative instead of Monad?
20:29:51 <ReinH> johnw: right
20:29:55 <johnw> for example, a Hoopl user of my library would be using a UniqueMonad to generate new labels for his nodes
20:30:05 <johnw> haasn: no, because I need sequencing
20:30:14 <jgcoded> johnw: so by parameterizing your Nodes with a monad you allowed the caller to provide side effects that you didn't need to know about
20:30:21 <johnw> i.e., "first you give me a new node, then i make a decision, then I might make another node"
20:30:28 <haasn> johnw: Ah, okay
20:30:35 <johnw> jgcoded: I parameterized the callback
20:30:46 <johnw> jgcoded: but yes, you have it exactly right
20:30:59 <ReinH> johnw: so you just say node <- mkNode
20:31:04 <johnw> right
20:31:06 <jgcoded> define side effects?
20:31:07 <johnw> that's exactly what I do
20:31:12 <ReinH> which might provide a source of fresh names or w/e
20:31:25 <johnw> side effects in this case = anything the user needs to do on his end that's totally opaque to me to create new nodes
20:31:37 <ReinH> nice
20:31:41 <johnw> he could referencing a Web page to determine how to make the node
20:31:45 <ReinH> heh
20:31:55 <johnw> but _my_ code stays 100% pure and referentially transparent
20:31:58 <ReinH> jgcoded: do you see how my lpaste more or less solves your problem?
20:32:27 <ReinH> Or rather, solves the problem I understood your problem to be
20:32:31 <johnw> ReinH: yeah, in my particular case it's exactly about sourcing fresh names
20:32:34 <jgcoded> I can see the structure of the solution, but I don't understand it
20:32:44 <ReinH> well, let's break it down
20:32:53 <jgcoded> the p@ is pretty glaring to me
20:32:57 <ReinH> > let pairsOf xs = zip xs (tail xs) in pairsOf [1..10]
20:32:58 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
20:33:22 <johnw> i think he could have written p@((_,y),(_,y'))
20:33:22 <ReinH> a@b says that a is an alias for the pattern b
20:33:37 <ReinH> so p@... says "call the whole thing p"
20:33:40 <jgcoded> ah cool
20:34:00 <Welkin> has anyone had any issues with haskell after an OS upgrade from mavericks to yosemite?
20:34:05 <jgcoded> oh so you're returning a tuple of tuples
20:34:08 <haasn> > let x@(a,b) = (3,5) in a
20:34:09 <Welkin> I'm about to find out very soon
20:34:09 <lambdabot>  3
20:34:10 <haasn> > let x@(a,b) = (3,5) in x
20:34:12 <lambdabot>  (3,5)
20:34:17 <ReinH> so I find the first pair of points that meet the criteria (that their x coordinates be below and above the provided coordinate)
20:34:22 <ReinH> and check that their y coordinates match
20:34:27 <dmj`> Welkin what kind of issues
20:34:32 <ReinH> and use the Maybe monad to handle the various ways that it can fail
20:34:35 <Welkin> I'm just wondering
20:34:38 <ReinH> 1) find can fail to find a pair
20:34:39 <dmj`> Welkin: I haven't no
20:34:46 <ReinH> 2) the pair can fail to be level
20:35:22 <Welkin> I always had issues upgrading linux
20:35:22 <jgcoded> ReinH: how does it know when to stop?
20:35:49 <Welkin> so Ialways did a clean install of the OS instead of upgrading
20:35:52 <Welkin> at least for ubuntu
20:36:05 <Welkin> I have never upgraded OSX
20:36:19 <ReinH> jgcoded: it stops at the end of the list
20:36:35 <dmj`> Welkin: it's pretty painless
20:38:02 <jgcoded> ReinH: are find and pairsOf some other functions I have to define?
20:38:13 <ReinH> find is in Data.List, pairsOf I defined below
20:40:14 <jgcoded> how does it check all pairs of points? In a C-style for loop you have an i++ which makes things move, but here i don't see how it's checking all the pairs
20:41:39 <exio4> that is part of the `find´
20:41:54 <jgcoded> ah
20:41:57 <exio4> it'll return the first value that wraps a predicate, or Nothing 
20:42:38 <jgcoded> it's similar to filter then
20:43:30 <exio4> uhh, wraps? I meant satisfies :p
20:45:23 <jgcoded> ReinH: thanks for the code, this helpful for me because now I can see two ways of solving the problem. One that uses monads and one that is recursive
20:49:32 * hackagebot lambda-options 0.2.0.0 - A modern command-line parser for Haskell.  http://hackage.haskell.org/package/lambda-options-0.2.0.0 (ThomasEding)
20:56:37 <ReinH> jgcoded: sure
20:56:40 <deezn> I have a GADTs question about this: 
20:56:41 <deezn> http://lpaste.net/4475812185397788672
20:57:01 <deezn> I am trying to encode the type in the eval function but I am not sure how to do it corrctly. 
20:57:48 <ReinH> @google typing haskell in haskell -- deezn
20:57:49 <lambdabot> Plugin `search' failed with: connect: does not exist (No route to host)
20:57:51 <ReinH> :(
20:58:01 <ReinH> deezn: http://web.cecs.pdx.edu/~mpj/thih/
20:58:12 <ReinH> It's a bit too large of a question to answer quickly
20:58:27 <ReinH> Unless I misunderstand you
20:58:34 <ReinH> what type are you trying to encode?
20:58:35 <deezn> yeah I think you did.. 
20:58:54 <ReinH> Ah
20:58:57 <sydneyhacker> anyone here going to LambdaJam Brisbane?
20:59:11 <deezn> look at the link.. I have changed the first two lines of eval to:  eval (Con t) = t
20:59:19 <ReinH> deezn: You can't. You are defining Con as forall t...
20:59:38 <ReinH> But anyway, you don't need to
20:59:45 <ReinH> there's nothing you can do differently
21:00:22 <deezn> ok it  working now.. still getting used to GADTS
21:12:48 <tombert1> Hello!  I have a question
21:13:05 <tombert1> I have a list of IO Ints
21:13:28 <tombert1> in do notation, is there a way to extract those values so that I can print them to the screen?
21:13:41 <thomaseding> mapM_ print
21:13:53 <thomaseding> o
21:14:33 * hackagebot neat-interpolation 0.2.2.1 - A quasiquoter for neat and simple multiline text interpolation  http://hackage.haskell.org/package/neat-interpolation-0.2.2.1 (NikitaVolkov)
21:16:01 <thomaseding> tombert1: mapM_ (>>= print) ioint
21:16:29 <thomaseding> or you can use something like sequence
21:17:05 <ajf> how can I obtain the infinity constant
21:17:21 <thomaseding> > maxBound :: Float
21:17:23 <lambdabot>      No instance for (Bounded Float) arising from a use of ‘maxBound’
21:17:23 <lambdabot>      In the expression: maxBound :: Float
21:17:31 <ajf> ah, thanks
21:17:42 <thomaseding> eek... wont work
21:17:46 <ajf> oh.
21:18:01 <enthropy> too bad that's not the tenth heredoc quasiquote on hackage (https://wiki.haskell.org/Quasiquotation#Introduction 9 listed here)
21:18:12 <thomaseding> > 1/0
21:18:13 <lambdabot>  Infinity
21:18:35 <ajf> yes, but Infinity doesn't exist
21:18:38 <ajf> nor does infinity
21:18:52 <enthropy> > read "Infinity" :: Float
21:18:53 <lambdabot>  Infinity
21:19:11 <ajf> Ah.
21:19:15 <ReinH> @hoogle [m a] -> m [a]
21:19:16 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
21:19:16 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
21:19:16 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
21:19:22 <ajf> I guess I'll do that then
21:19:30 <ajf> inf :: Double
21:19:35 <ajf> inf = read "Infinity"
21:19:52 <enthropy> probably the read instance uses 1/0 to make it
21:19:57 <thomaseding> You really want to use the read approach over the 1/0 one?
21:20:30 <Hijiri> > 1 / (-0)
21:20:31 <lambdabot>  -Infinity
21:21:03 <Hijiri> > (0 == (-0), 1 / 0 == 1 / (-0))
21:21:04 <lambdabot>  (True,False)
21:22:00 <enthropy> https://github.com/ghc/ghc/blob/master/libraries/base/GHC/Read.hs#L449
21:22:40 <Hijiri> (1 /) is not a function, apparently
21:22:56 <thomaseding> @ty (1 /)
21:22:57 <lambdabot> Fractional a => a -> a
21:23:17 <Hijiri> I mean, it doesn't preserve equality
21:23:34 <Hijiri> or maybe (==) is not an equivalence relation and I guess veryone already knew that
21:23:49 <thomaseding> That's an IEEE 754 issue
21:26:04 <hiptobecubic> positive infinity and negative infinity are not equal.
21:27:05 <hiptobecubic> Although if you want to complain about it not being a good enough approximation of the reals, you should probably stop asking it to divide by zero :)
21:28:06 <Welkin> yes, NaN /= NaN
21:29:33 * hackagebot aivika 4.0.3 - A multi-paradigm simulation library  http://hackage.haskell.org/package/aivika-4.0.3 (DavidSorokin)
21:37:02 <Tordek> > NaN /= NaN
21:37:04 <lambdabot>  Not in scope: data constructor ‘NaN’Not in scope: data constructor ‘NaN’
21:37:10 <Tordek> er
21:37:27 <thomaseding> > sqrt (-1)
21:37:28 <lambdabot>  NaN
21:37:47 <Tordek> > (sqrt (-1)) /= (sqrt (-1))
21:37:48 <lambdabot>  True
21:38:38 <enthropy> http://lpaste.net/5475857537444085760 seems like you can get exceptions thrown instead of getting Infinity
21:39:23 <Tordek> > (sqrt (-1)) > (sqrt (-1))
21:39:25 <lambdabot>  False
21:39:33 <Tordek> > (sqrt (-1)) `cmp` (sqrt (-1))
21:39:34 <lambdabot>  Not in scope: ‘cmp’
21:39:42 <Tordek> > (sqrt (-1)) `compare` (sqrt (-1))
21:39:43 <lambdabot>  GT
21:39:49 <Tordek> heh
21:40:15 <thomaseding> Win
21:41:17 <Tordek> I thought NaN /= NaN had to return False as well
21:41:35 <thomaseding> Guess haskell does not implement iee754
21:43:46 <Tordek> apparently I'm wrong, NaN /= NaN is true elsewhere... though I can't find a reference
21:44:34 * hackagebot streaming-commons 0.1.12.1 - Common lower-level functions needed by various streaming data libraries  http://hackage.haskell.org/package/streaming-commons-0.1.12.1 (MichaelSnoyman)
21:45:48 <hiptobecubic> float('nan') != float('nan') in python
21:46:06 <c_wraith> Tordek: it's part of the IEEE754 floating-point spec
21:48:54 <ReinH> Sounds like you have it backwards.
21:49:02 <ReinH> NaN /= NaN is part of the spec
21:49:41 <haasn> (NaN == x) is false as per spec, as far as I'm aware
21:50:50 <ReinH> Yes
21:51:00 <ReinH> comparison of NaN with any number, including NaN, is false
21:51:42 <Tordek> ReinH: yeah, my confusion was that I thought any comparison to NaN was false
21:51:51 <ReinH> A member of the IEEE-754 committee weighs in :) http://stackoverflow.com/a/1573715/2225384
21:51:57 <Tordek> so I expected neithet NaN == NaN or NaN /= NaN
21:52:40 <ReinH> ah
21:53:09 <ReinH> iinm, /= is not a separate relation in IEEE-754, it's the negation of ==
21:53:13 <cgag> not sure what's changed, but suddenly I'm getting this error from ghc-mod:  /home/cgag/code/comments/dist/setup-config: hGetContents: invalid argument (invalid byte sequence), anyone run into this?
21:53:51 <Welkin> the way I see it, NaN is basically "undefined"
21:54:08 <Welkin> many things can be NaN (negative Infinity or positive Infinity)
21:54:17 <Welkin> but they are not all the same "undefined" thing
21:54:38 <ReinH> There is some reasoning in the link for NaN == Nan = false
21:54:40 <Tordek> > isNaN (1/0)
21:54:41 <lambdabot>  False
21:54:50 <Tordek> ^ Infinity is not NaN ;[
21:56:12 <pacak> @src isNaN
21:56:12 <lambdabot> Source not found. Abort, Retry, Panic?
21:56:30 <pacak> I think it's implemented as isNaN a = a /= a
21:56:48 <ElMoloko> > let x = (1/0); print x
21:56:49 <lambdabot>  <hint>:1:23:
21:56:49 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
21:57:31 <pacak> Floating point numbers are evil. 
21:57:43 <ElMoloko> >1/0
21:57:56 <ElMoloko> > 1/0
21:57:57 <lambdabot>  Infinity
21:58:08 <ElMoloko> >:t infinity
21:58:19 <Tordek> > :t (1/0)
21:58:20 <ackthet> :t infinity
21:58:20 <lambdabot>  <hint>:1:1: parse error on input ‘:’
21:58:21 <lambdabot> Natural
21:59:00 <ElMoloko> wat
21:59:08 <ackthet> its a Natural, whatever that is :D
21:59:21 <ElMoloko> Man I can't decide if that's great or terrifying
21:59:22 <ElMoloko> or both
21:59:30 <ackthet> its great
21:59:45 <Tordek> ...ly terrifying
21:59:51 <ackthet> haskell was written by a bunch of drunk math phds, right?
22:01:35 <ElMoloko> Apparently Infinity is a double
22:02:14 <ElMoloko> Oh right because of the fractional from /
22:02:16 <ElMoloko> gah
22:02:32 <ElMoloko> yeah definitely a bunch of drunk math phds
22:03:27 <ElMoloko> Probably fun drunks though.
22:11:46 <ReinH> Well, they're fun when they aren't drunk
22:11:55 <ReinH> At least, I don't think they were drunk
22:12:52 <ElMoloko> I guess we'll never know.  Some things are best that way.
22:13:14 <ReinH> Well, you can judge for yourself if you want
22:13:30 <ElMoloko> Oops I didn'
22:13:46 <ReinH> http://www.haskellcast.com/episode/003-simon-peyton-jones-on-ghc/ http://www.haskellcast.com/episode/004-simon-marlow-on-parallelism-and-concurrency/
22:13:57 <ReinH> Do they sound drunk to you? :)
22:14:06 <ReinH> note: don't be confused by SPJ's accent, which is awesome.
22:14:24 <ElMoloko> t quite read that.  I'm sure they're fun all the time.
22:14:50 <ElMoloko> Oh, haha I remember the first one. :)
22:15:31 <ReinH> :)
22:15:39 <ElMoloko> I think someone linked it on HN.  It's probably about time to go through these now that I'm starting to almost begin to understand the language.
22:15:43 <ReinH> Yeah, they were both great to talk to
22:15:51 <ReinH> Everyone has been super nice so far
22:17:14 <ElMoloko> That's awesome.  I thorougly am enjoying reading through the logs of this IRC channel.  Whenever I have a problem, or a vague sort of proto-problem, I search through all the logs online.  There's always something.
22:18:05 <ElMoloko> I had no idea Simon Marlow worked for Facebook.  Does Facebook utilize Haskell at all, out of curiousity?
22:18:45 <ReinH> He works on Brian O'sullivan's Haskell team and yes, they are using Haskell in production
22:19:18 <ReinH> They just launched a Haskell-based spam fighting tool http://www.serpentine.com/blog/2015/05/13/sometimes-the-old-ways-are-the-best/
22:21:07 <ElMoloko> Whoa I love these rewrites, it's great comparing the old code vs. new, rosetta code style
22:21:55 <ReinH> note that the new code is pretty awful ;)
22:22:28 <ReinH> He punted on a nice abstraction for performance reasons, but sometimes you gotta do what you gotta do
22:24:13 <johnw> ReinH: ah, but sometimes you don't :)
22:24:35 * hackagebot postgresql-binary 0.5.2.1 - Encoders and decoders for the PostgreSQL's binary format  http://hackage.haskell.org/package/postgresql-binary-0.5.2.1 (NikitaVolkov)
22:24:37 * hackagebot read-bounded 0.1.1.0 - Class for reading bounded values  http://hackage.haskell.org/package/read-bounded-0.1.1.0 (ThomasEding)
22:26:25 <ReinH> johnw: they don't think it be like it, is but it do
22:26:29 <ReinH> *like it is
22:26:40 <sydneyhacker> ElMoloko: sorry newb question bit how do you search through the logs?
22:26:58 <johnw> ReinH: I'm thinking of systems under development where being more abstract leads to _better_ performance
22:27:10 <ReinH> :)
22:27:12 <johnw> in completely controllable ways
22:27:48 <ReinH> sydneyhacker: http://ircbrowse.net/browse/haskell
22:29:35 * hackagebot influxdb 0.9.1.2 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-0.9.1.2 (MitsutoshiAoe)
22:31:09 <erikd> sydneyhacker: you in sydney.au ?
22:31:24 <sydneyhacker> erik: yes
22:32:29 <erikd> you know about fp-syd?
22:32:42 <erikd> have you attended?
22:33:37 <sydneyhacker> yes I have been to one fp-syd, and one yam night
22:33:47 <sydneyhacker> both were excellent
22:33:54 <erikd> cool, so you know about us
22:33:54 <sydneyhacker> sorry yow
22:34:18 <sydneyhacker> yes I am going to try and rock up once a month
22:35:13 <codygman> I have a question about using types/sum types to make my API more succinct. It is best explained by this short example and how I would like the API to look: http://lpaste.net/132655
22:35:41 <sydneyhacker> is it you that spoke about proxies?
22:36:21 <orion> When it comes to making things like database connection handles available to all parts of an application, is it better to layer a StateT on top of a ReaderT and make the handle part of the application's state, or is it better to stick the handle in an MVar and make it part of the data returned in the ReaderT?
22:36:45 <thomaseding> codyman: data Answer a = Answer a
22:37:17 <codygman> thomaseding: Thanks, is there a way to limit what a can be?
22:37:41 <thomaseding> You can probably do it with a GADT and a type family constraint?
22:37:56 <orion> Sticking the handle in an MVar and returning it as part of the ReaderT seems like a better design choice, considering that transformers add overhead.
22:38:24 <codygman> thomaseding: Thank you for your help.
22:39:21 <thomaseding> codyman: no problem. I'm about to get some sleep. Are you familiar with type families?
22:40:57 <thomaseding> You can definitely use a class constraint and hide part of the class definition to prevent others from instancing it
22:42:06 <thomaseding> As far as a type family goes, that might be better if you know what you are doing (and if it works... I'm not sure. Im a little rusty on them). A closed type family would probably be best if you are using a really recent ghc
22:42:11 <hnfmr> how can I paste a raw string literal to Haskell source file? the string contains \" for example
22:42:35 <thomaseding> hnfmr: You don't
22:42:53 <thomaseding> Or you write a quasiquoter (overkill?)
22:42:58 <hnfmr> i can't do it right? I have to put it to a file and read it?
22:43:45 <thomaseding> The easiest way is probbaly to use a tool to convert it to a haskell encoded string and paste that into your file
22:43:56 <hnfmr> ok
22:44:01 <hnfmr> thx for the direction
22:45:05 <thomaseding> hnfmr: You can using ghci repl and call getLine. Paste your string there and ghci will spit out the encoded string
22:45:38 <jle`> is there any way to express strict fields i GADT syntax
22:45:56 <jle`> oh i just added a ! and it worked
22:45:59 <jle`> neat
22:46:00 <pacak> jle`: !
22:46:32 <jle`> !!
22:46:38 <mr_yogurt> Where do you guys recommend I go to learn some haskell?
22:46:46 <hnfmr> thomaseding: that's better!
22:46:48 <thomaseding> realworldhaskell
22:46:52 <pacak> mr_yogurt: lyah
22:47:01 <ceridwen> I have a question about what some Haskell code and code in a related language called Clean in two papers I'm reading are doing---they're both about implementing monadic parser combinators with continuations.  Is this an appropriate place to ask?
22:47:17 <pacak> @whereis lyah
22:47:17 <lambdabot> Maybe you meant: where+ where
22:47:23 <pacak> @where lyah
22:47:23 <lambdabot> http://www.learnyouahaskell.com/
22:47:25 <jle`> @wher learnhaskell
22:47:26 <lambdabot> Maybe you meant: where where+
22:47:30 <jle`> @where learnhaskell
22:47:31 <lambdabot> https://github.com/bitemyapp/learnhaskell
22:47:34 <pacak> Yea, that.
22:47:38 <thomaseding> @where rwh
22:47:39 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
22:47:48 <pacak> rwh is a bit bitrotted
22:48:05 * thomaseding Thomas OUT
23:14:58 <kadoban> ceridwen: Probably
23:19:36 * hackagebot hasql-postgres 0.10.3.1 - A "PostgreSQL" backend for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.10.3.1 (NikitaVolkov)
23:44:37 * hackagebot hasql 0.7.3.1 - A minimalistic general high level API for relational databases  http://hackage.haskell.org/package/hasql-0.7.3.1 (NikitaVolkov)
23:47:24 <begriffs> Cabal question. I've got a really big sandbox that was built up from Stackage LTS 2.5. When I use the sandbox to try to speed up the build of a new project cabal sits at "Resolving dependencies..." forever. Is there a flag to help it through the dependency resolution?
23:48:54 <kadoban> begriffs: How are you using a sandbox to try to speed up the build?
23:51:04 <begriffs> kadoban: I created a sandbox in ~/.stackage/sandboxes/ghc-7.8.4/lts-2.5 and actually did a cabal install of every package on hackage in there. Yeah, it took a week of nonstop building. Now that I have it, I tried to clone and cabal install elm-compiler just as an example of a project that would ordinarily take a long time to build. I init'ed a sandbox there pointing at the shared one. I set the cabal.config to f
23:51:04 <begriffs> reeze package versions. And I get stuck at the dependency resolution.
23:52:36 <begriffs> The overall experiment is to see if I can use this megasandbox to build any project quickly.
23:53:00 <kadoban> begriffs: The part I'm trying to get at is, how are you pointing the one sandbox at the other? Are you sure you did it right? It's not as simple as just copying it or whatever is the reason I ask. Not that I know what symptoms doing it wrong would have, but …
23:54:37 * hackagebot cases 0.1.2.1 - A converter for spinal, snake and camel cases  http://hackage.haskell.org/package/cases-0.1.2.1 (NikitaVolkov)
23:55:48 <begriffs> I used https://hackage.haskell.org/package/stackage-cli which creates a cabal.sandbox.config with paths inside pointing at the other directory (rather than the standard .cabal_sandbox in the current directory)
23:56:10 <kadoban> Ah okay, then yeah my guess at a possible problem isn't relevant.
23:57:11 <kadoban> begriffs: That's an interesting experiment though.
23:57:31 <snuff> I'm trying to declare a Container typeclass:
23:57:33 <snuff> class Container a where                                                         
23:57:33 <snuff>     empty :: Container a                                                        
23:57:33 <snuff>     insert :: Container a -> a -> Container a
23:57:46 <begriffs> Aha, --reorder-goals gets past it
23:57:53 <snuff> but I'm getting the error:
23:57:54 <snuff> Expected kind ‘*’, but ‘Container a’ has kind ‘Constraint’
23:57:55 <snuff>     In the type ‘Container a’
23:57:55 <snuff>     In the class declaration for ‘Container’
23:58:04 <snuff> can someone help?
23:58:24 <begriffs> Yeah I've uploaded a xz compressed archive of the big sandbox to s3 for other people to use and just trying it out to be sure it improves build times
23:59:30 <begriffs> So elm-compiler's constraints are actually incompatible with stackage LTS 2.5... what's another big project which would ordinarily take a long time to build?
23:59:37 <pacak> snuff: Have a look at associated type families
23:59:38 * hackagebot bifunctors 5 - Bifunctors  http://hackage.haskell.org/package/bifunctors-5 (EdwardKmett)
23:59:39 * hackagebot profunctors 5 - Profunctors  http://hackage.haskell.org/package/profunctors-5 (EdwardKmett)
23:59:41 * hackagebot semigroupoids 5 - Semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-5 (EdwardKmett)
