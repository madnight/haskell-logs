00:01:34 <dmj`> _m_ryan: http://lpaste.net/132837
00:02:34 <dmj`> _m_ryan: I gotta go soon, but the key in that code is that it doesn't block the main thread of execution (the threadDelay is just to ensure the text is printed garbly
00:02:36 <dmj`> )
00:03:14 <_m_ryan> dmj`: i will check this out.. :)
00:03:17 <dmj`> _m_ryan: forkIO will spawn a new thread
00:04:16 <dmj`> _m_ryan: once you get more sophisticated you will want to use async, and then you'll realize that monad-control is cleaner, and then you'll want to use lifted-async
00:04:52 <_m_ryan> dmj`: noted... can i aks a favor. please don't delete the code on lpaste. thank you :)
00:05:02 <dmj`> _m_ryan: of course not
00:05:21 <dmj`> _m_ryan: happy haskelling! peace
00:05:21 <dmj`>  
00:05:24 <_m_ryan> dmj`: thank you.
00:05:39 <_m_ryan> dmj`: :)
00:05:52 <dmj`> _m_ryan: :)
00:08:20 <_m_ryan> Hi everyone, what is Chan?
00:08:22 * hackagebot filediff 1.0.0.4 - Diffing and patching module  http://hackage.haskell.org/package/filediff-1.0.0.4 (bgwines)
00:08:48 <merijn> _m_ryan: As in Control.Concurrent.Chan?
00:09:49 <_m_ryan> merijn: yes. what does it do?
00:10:25 <merijn> _m_ryan: It's a multiple reader/writer queue
00:10:49 <merijn> Multiple threads can write to it and/or read data from it
00:11:42 <_m_ryan> thank :)
00:12:11 <Myrl-chan> merijn: I have a feeling I know you.
00:12:35 <merijn> Myrl-chan: Probably because I occasionally hang out in ##programming and yell about all languages being terrible :p
00:12:52 <Myrl-chan> merijn: Oh phew.
00:13:09 <Myrl-chan> merijn: I whois'd you and you didn't appear in ##programming, so I was so confused.
00:14:18 <Myrl-chan> merijn: I made a Haskell server.
00:16:02 <slomo> why does this use a lot of memory? http://lpaste.net/132839 i would expect it to only carry over the latest list to the new iteration, and no thunks to build up anywhere
00:16:24 <merijn> Myrl-chan: Step 1 to world domination ;)
00:16:29 <Myrl-chan> merijn: Yep.
00:16:36 <elben> When I run `ghc-mod check`, the types shown on errors are always contain the full path For example, “Couldn't match expected type ‘ghc-prim:GHC.Types.Char’” instead of just “Couldn't match expected type ‘Char’”. Is there a way to reduce this noise?
00:16:42 <Myrl-chan> merijn: Now we have Haskell web pages. :)
00:16:48 <merijn> slomo: FYI "(xs' `seq` xs')" is exactly the same as xs'
00:17:00 <ij> merijn, no problems with ops there?
00:17:50 <merijn> ij: Where? ##programming? Not really, but then I'm just curmudgeony, not trolling
00:18:01 <jle`> bah humbug
00:19:00 <merijn> slomo: In fact, all your uses of seq are redundant and don't do anything
00:19:08 <Myrl-chan> You'll never get banned if you just follow it up with `jk` afterwards.
00:19:10 <Myrl-chan> sourec : me
00:19:19 <Myrl-chan> jk
00:19:24 <merijn> oh, hlint actually warns about redundant seq, neat.
00:20:55 <slomo> merijn: ah thanks for the hint, i thought that was just hlint being confused :) how would i use seq here properly?
00:21:14 <alan1> should i avoid Lens even though a project i'll make will use a lot of records? i'm still sorta new to haskell
00:21:15 <slomo> merijn: i just got it to work with bang patterns though
00:22:17 <Axman6> alan1: once you get used to it, it's really nice to use, but it uses a lot of advanced concepts and type errors can be confusing (people can help you with them though)
00:22:42 <jle`> alan1: i don't think it's too bad if you just use it as ways to access and dig into records
00:22:48 <merijn> slomo: seq is basically "if neither arguments are bottom, after evaluating the result of seq, both arguments to see will be evaluated"
00:22:50 <jle`> the type errors might be confusing though definitely
00:23:05 <merijn> slomo: So "seq x x" says that after evaluating "seq x x" both 'x' and 'x' will be evaluated
00:23:06 <grpala> I've stumbled upon a bug I don't seem to find a workaround for yet. Any information about user error (Pattern match failure in do expression at libraries/base/GHC/Event/Thread.hs:207:3-10) would be appreciated.
00:23:14 <jle`> but this is the case whether you're a new haskell user or an experienced one :)
00:23:25 <grpala> ghc 7.8.4
00:23:27 <jle`> it's just when you're new you have to learn a bunch of other things at once too, so it might be worth taking that into account
00:23:30 <merijn> slomo: The right approach would be something like "let foo = f x in foo `seq` iterate' f foo"
00:23:54 <merijn> slomo: Which says that after evaluating "seq foo (iterate' f foo)" both "iterate' f foo" and "foo" will be evaluated
00:23:59 <srenatus> hi there. I'm trying to find a way out of this problem: data SomeParam = S | M | L, data SomeOtherParam = L | M | H, which is not allowed for multiple definitions of M and L. How to apporach this? Prefixing? data SomeParam = SomeParamS | SomeParamM | SomeParamL, etc, doesn't seem quite right....
00:24:10 <merijn> As you can see from the semantics of seq it only really makes sense for named expressions
00:24:11 <alan1> jle`: well, i sorta know how to use the maybe monad
00:24:18 <grpala> of course this surely is because it should check for Nothing too, but I'm not sure how is all that supposed to work
00:24:35 <slomo> merijn: thanks, that makes sense :)
00:24:39 <alan1> jle`: just concerned if Lens was really evil way to use haskell or something
00:24:43 <merijn> slomo: Although the properly seq'ed version still seems slow as hell but I'm not quite sure what it's doing, so I can't reformulate
00:24:50 <jle`> i don't consider it an evil way
00:25:15 <jle`> it's probably the best way to access and modify nested records
00:25:30 <liste_> srenatus define them in different modules and import qualified
00:25:32 <jle`> the non-lens solution is pretty awful if you try to work with it for any small amount of time
00:25:58 <srenatus> liste_: Ok, that would work. but the problem at hand makes that solution seem very weird
00:26:00 <alan1> jle`: alright, i'll give it a try. i was trying to do some tutorials for FRP and every tutorial seemed to use it lol
00:26:10 <merijn> grpala: That's in "getSystemTimerManager"?
00:26:25 <jle`> heh.  some libraries will offer an interface through lens, but usually the choice is yours
00:26:31 <merijn> slomo: Oh, the seq'ed version finishes, just really slowly
00:26:58 <grpala> merijn: yes
00:27:14 <liste_> srenatus then I guess prefixing is the only way
00:27:23 <jle`> the nice thing about lens is that you can chooose to only use the parts that you need or that make things simpler/more convenient for you
00:27:27 <jle`> choooose
00:27:29 <pharaun> lens is... interesting :) my current problem these days with lens is conditional access
00:27:31 <merijn> grpala: Weird, can you minimise the code that triggers this?
00:27:46 <grpala> sure
00:27:53 <pharaun> or "return x if the children has y"
00:27:53 <srenatus> liste_: ok, thanks a lot :)
00:27:54 <slomo> merijn: i think that's expected, it's basically counting from 1 to N in the given base b
00:28:04 <merijn> grpala: You're halfway on your was to fixing your first GHC bug! ;)
00:29:59 <Myrl-chan> You know
00:30:08 <Myrl-chan> Haskell kind of broke my english.
00:30:23 <Myrl-chan> For 3 to 5 days, I thought "if x then y" means "if x, return y"
00:30:51 <Myrl-chan> Then I just realized that it actually means "if x is true, so is y, otherwise, y may be true."
00:32:24 <merijn> Myrl-chan: You mean haskell fixed your propositional logic! :p
00:32:41 <grpala> merijn: sweet! :D
00:33:16 <Myrl-chan> merijn: In logic, implication is actually closer to English than Haskell.
00:34:25 <lpaste> grpala pasted “GHC.Event/Thread.hs bug” at http://lpaste.net/132841
00:34:38 <grpala> merijn: ^
00:35:49 <merijn> grpala: Can you trigger it without the conduit thing? (I don't have conduit so can't check that code as-is)
00:36:02 <grpala> guess I can, hang on a sec
00:36:28 <solatis> sorry for the join/quit spam everyone :/
00:37:16 <lpaste> grpala revised “GHC.Event/Thread.hs bug”: “No title” at http://lpaste.net/132841
00:37:30 <grpala> merijn: there
00:38:24 * hackagebot hruby 0.3.1.4 - Embed a Ruby intepreter in your Haskell program !  http://hackage.haskell.org/package/hruby-0.3.1.4 (SimonMarechal)
00:39:42 <grpala> merijn: this all happened when trying to set a timeout for establishing a connection using high level libraries (since none seem to have such a simple setting anywhere)
00:40:20 <merijn> grpala: Not quite what I meant, as I don't know where Data.Streaming.Network is from :)
00:40:32 <grpala> aww
00:41:18 <grpala> how could I check what packages export what?
00:41:24 <merijn> grpala: I wonder whether it's not sufficient to only use getSystemTimerManager
00:42:01 * grpala checks
00:42:15 <merijn> Right
00:42:22 <grpala> yes
00:42:23 <merijn> Just "main = getSystemTimerManager" also crashes
00:42:24 <grpala> it is
00:42:48 <grpala> so, I'm in for a bumpy ride
00:43:24 * hackagebot xdot 0.2.4.7 - Parse Graphviz xdot files and interactively view them using GTK and Cairo  http://hackage.haskell.org/package/xdot-0.2.4.7 (DennisFelsing)
00:43:28 <merijn> grpala: If you like adventure, try to figure out where the SystemTimerManager is initialised to Just and why it's not doing that by the time your code executes
00:43:30 * grpala git pulls the ghc repo
00:43:58 <grpala> yea, that's the idea
00:44:03 <merijn> grpala: Here's a quickstart guide on how to get your stuff merged back, should you get that far: https://gist.github.com/merijn/c01405e6c5a78a1c4ccb
00:45:19 <grpala> I'd totally get cracking all night, but I gotta work in 3 hours, haven't slept at all. But I'm totally getting this thing right
00:45:33 <grpala> once I get back home
00:46:29 <grpala> what the hell, who needs sleep
00:52:13 <merijn> Is there a library exporting ContT versions of Control.Exception?
00:52:40 <merijn> transformers should really just export those so it becomes more convenient to use ContT for bracket...
00:57:20 <jle`> merijn: let me know if you find one :)
00:58:07 <zipper`> jle`: Hello
00:58:32 <jle`> hey zipper` :D
01:00:34 <zipper`> jle`: You're very happy today. I'm doing well.
01:00:43 <jle`> i try to always be happy
01:04:45 <zipper`> jle`: Keep that up. You won't regret it.
01:08:25 * hackagebot plugins-multistage 0.6.1 - Dynamic linking for embedded DSLs with staged compilation  http://hackage.haskell.org/package/plugins-multistage-0.6.1 (AndersPersson)
01:14:15 <lpaste> merijn pasted “bracket marching to the right” at http://lpaste.net/132844
01:14:24 <merijn> I feel there should be a prettier way to do that
01:15:37 <Haskellfant> what is the rational in pPrintPrec supposed to represent? https://hackage.haskell.org/package/pretty-1.1.3.2/docs/Text-PrettyPrint-HughesPJClass.html#v:pPrintPrec
01:15:38 <Tordek> <$> over lists applies every function on the left to every element on the right. is there any reason for that instead of, e.g., each function to each element?
01:16:30 <Tordek> or is there a reason to apply in the order given (each function to all items, in order) as opposed to all functions to each item?
01:16:34 <merijn> Tordek: "each function" which "each function"?
01:16:46 <merijn> Tordek: <$> is just fmap
01:16:53 <Tordek> sorry, <*>
01:16:54 <merijn> Tordek: I think you're confusing <$> with <*> ?
01:17:09 <merijn> Tordek: The simple answer is that there's two lawful Applicatives for []
01:17:18 <merijn> Tordek: But only one of those two is a lawful Monad
01:17:23 <merijn> Tordek: So Applicative uses that one
01:17:38 <merijn> Tordek: The other one can be found under "newtype ZipList a = ZipList [a]"
01:18:27 <merijn> > ZipList [(+7),(*2),(+3),(*4)] <*> ZipList [1,2,3,4]
01:18:29 <lambdabot>  ZipList {getZipList = [8,4,6,16]}
01:18:39 <merijn> > getZipList $ ZipList [(+7),(*2),(+3),(*4)] <*> ZipList [1,2,3,4]
01:18:40 <Tordek> I see, so there's no valid Monad for ziplist
01:18:41 <lambdabot>  [8,4,6,16]
01:18:45 <merijn> Tordek: Right
01:18:51 <Tordek> awesome, thanks
01:19:07 <merijn> Tordek: And having Monad and Applicative be incompatible would be a nightmare :)
01:22:11 <nshepperd> there is a Monad, but only for fixed length lists
01:22:23 <nshepperd> and then you have to ask "which length?"
01:28:23 <nshepperd> I think
01:28:33 <nshepperd> can't remember if the monad laws were proved to hold
01:30:56 <aloiscochard> hi, are you folks using something (tool/...) to automate the release process of cabal projects? I mean increment version number, `sdist`, create commit with proper message, ...
01:31:10 <merijn> Someone with a linux box willing to quickly test whether a package compiles on their machine before I update hackage?
01:31:27 <bitonic> is there a way to put an SCC on a record field?
01:33:15 <aloiscochard> merijn: I can run it in background if that help, is that on git?
01:34:29 <merijn> aloiscochard: No, I was just gonna upload the cabal tar file. It's like 1 file with only unix/process/base as dependencies, so it should take like 1s to compile
01:34:50 <aloiscochard> merijn: fine, I can give it a try
01:36:18 <merijn> aloiscochard: http://files.inconsistent.nl/posix-pty-0.2.0.tar.gz
01:36:53 <jle`> anyone have any nice solution for finding the "nearest value in range" for an arbitrary Ix instance?
01:37:01 <jle`> Ix a => a -> (a, a) -> a
01:37:05 <jle`> sort of like a clamper
01:37:12 <jle`> is this even possibl?
01:37:46 <merijn> jle`: If you have an Ord instance you can just to min/max?
01:38:15 <jle`> hm
01:38:21 <Erebe> min(ma, max(inf,a))
01:38:23 <aloiscochard> merijn: http://pastie.org/10194459
01:38:29 <merijn> :t \val (x, y) -> max x (min val y)
01:38:30 <lambdabot> Ord a => a -> (a, a) -> a
01:38:32 <jle`> relevant thing for me are 2d instances like (Int, Int)/ V2 Int
01:38:52 <jle`> so i don't think Ord gives the right behavior
01:39:12 <merijn> aloiscochard: hmm, which version of GHC?
01:39:47 <haskell424> hi
01:39:48 <merijn> aloiscochard: Is this Ubuntu or some other distro that ships without dev headers?
01:39:53 <jle`> hi haskell424 !
01:40:06 <haskell424> i am new to this
01:40:09 <aloiscochard> merijn: I'm running archlinux
01:40:20 <alex_> I have multiple versions of cabal. cabal 1.18 and cabal 1.22. When I type cabal --version. It pulls up 1.18. How do I make it detect 1.22?
01:40:26 <aloiscochard> not sure which headers I have installed, but I should have the dev tooling
01:40:32 <jle`> alex_: check out where your $PATH is pointing to
01:40:41 <jle`> and where your 1.22 binary is
01:41:07 <merijn> aloiscochard: Can you compile this C file with gcc? http://lpaste.net/132845
01:41:37 <alex_> 1.22 should be somewhere like C:\Users\Alex\AppData\Roaming\cabal ?
01:42:59 <alex_> PATH points to C:\Program Files\Haskell Platform\2014.2.0.0\lib\extralibs\bin
01:43:23 <alex_> and bin has 1.18 license file
01:43:26 <merijn> aloiscochard: because if so then GHC is messing up in a weird way, if not then your system headers are just lobotomised >.>
01:43:41 <aloiscochard> merijn: `foo.c:4:12: error: ‘TIOCPKT_FLUSHREAD’ undeclared `
01:43:46 <alex_> I do not see 1.22 license file. If I delete the file, git does not recognise cabal command.
01:44:15 <alex_> delete 1.18 license file*
01:44:23 <merijn> aloiscochard: Ok, that's reassuring in the sense that it's your system that's bollocksed and not my code ;)
01:44:27 <aloiscochard> merijn: I see termios here but in sub-diretry, https://www.archlinux.org/packages/core/x86_64/linux-api-headers/files/
01:44:37 <merijn> aloiscochard: "sys/termios.h"?
01:45:01 <aloiscochard> merijn: yeah, haha :-)
01:45:03 <merijn> aloiscochard: Yell at archlinux for being braindead and not confirming to posix ;)
01:45:11 <aloiscochard> merijn: no, it's in `linux/` or `asm/`
01:45:15 <merijn> ah
01:45:19 <merijn> That's weird
01:46:46 <merijn> That's so non-standard I wouldn't even know how to begin fixing it in a way that that package stays working for any sane distro/OS
01:47:06 <jle`> i ended up making a range ADT that is parameterized by a clamping function
01:47:10 <aloiscochard> wait, I'll just symlink for now and see if it work merijn 
01:47:37 <jle`> or not an ADT just a type synonym
01:47:55 <jle`> type Range i = ((i,i), i -> i)
01:50:02 <aloiscochard> merijn: well, I don't understand the file `/usr/include/termios.h` exists, but I have to prefi
01:50:13 <aloiscochard> ...prefix `linux/` to make the c file compile
01:51:02 <alex_> fixed the path and it worked. Thanks
01:52:27 <merijn> aloiscochard: I'll check whether that's just Arch or a linux in general thing
01:52:38 <aloiscochard> cool, ty
01:52:47 <alex_> Any idea about this: $ cabal install genprog Resolving dependencies... cabal.exe: Could not resolve dependencies: trying: genprog-0.1.0.2 (user goal) next goal: base (dependency of genprog-0.1.0.2) rejecting: base-4.8.0.0/installed-38f... (conflict: genprog => base==4.6.*) rejecting: base-4.8.0.0, 4.7.0.2, 4.7.0.1, 4.7.0.0, 4.6.0.1, 4.6.0.0, 4.5.1.0, 4.5.0.0, 4.4.1.0, 4.4.0.0, 4.3.1.0, 4.3.0.0, 4.2.0.2, 4.2.0.1, 4.2.0.0, 4.1.0.0, 4.0.0.
01:53:07 <alex_>  (global constraint requires installed instance) Dependency tree exhaustively searched.
01:53:53 <merijn> alex_: genprog is claiming to only work with base-4.6, but you have base-4.8 installed. And since base is tied into GHC and not updatable you can't compile genprog with your current compiler
01:54:09 <merijn> alex_: Most likely it'll work if you change the base constraint to work with base-4.8
01:54:27 <alex_> How would I do that?
01:58:28 <jle`> yay got my comonadic pde solver to use neumann boundary conditions
01:58:46 <jle`> as if that even made sense for non-numbers
02:00:14 <merijn> alex_: "cabal get genprog" and then edit the cabal file in the unzipped package
02:00:47 <alex_> On it.
02:03:11 <alex_> Changed the base requirement to 4.8.*. Now how should I run it?
02:05:31 <merijn> Run "cabal install" inside that folder
02:07:22 <alex_> Awesome. Works!
02:07:55 <merijn> stm ships with ghc, right?
02:12:13 <alex_> Thanks, merijn. I appreciate your help.
02:16:51 <srenatus> using cassava, has anyone an idea what "Failed reading: conversion error: cannot unpack array of length 11 into a 11-tuple" is trying to tell me?
02:18:24 <bennofs> merijn:no (tested on ghc 7.10.1)
02:19:00 <merijn> bennofs: Which distro?
02:19:38 <bennofs> merijn: nixos
02:19:56 <merijn> Gah, screw everything about linux >.<
02:20:19 <merijn> I'm just gonna "if os(linx) Buildable: False" it and say screw anyone who uses linx >.>
02:21:34 <magneticDuck> what's linx?
02:21:53 <magneticDuck> merijn: nixos is the easiest distro to build for actually
02:21:56 <magneticDuck> cough
02:22:10 <bennofs> merijn: it has packages: Cabal, array, base, bin-package-db, binary, rts, bytestring, containers, deepseq, directory, filepath, (ghc), ghc-prim, haskeline, hoopl, hpc, integer-gmp, pretty, process, template-haskell, terminfo, time, transformers, unix, xhtml but no stm
02:22:29 <merijn> magneticDuck: It's not complying to posix, so it's stupid
02:22:37 <magneticDuck> huh?
02:22:42 <magneticDuck> lol gotta love that logic
02:22:45 <bennofs> i don't think nixos has patched the ghc distr to remove stm
02:23:02 <merijn> bennofs: Oh, wait, you were referring to stm shipping with GHC?
02:23:12 <bennofs> merijn: yes
02:23:25 <magneticDuck> merijn: do you know what nixos is?
02:23:33 <magneticDuck> it's the solution to all dependency problems ever
02:23:37 <merijn> bennofs: Ah, I thought you were talking about my earlier question whether my package compiles
02:23:47 <bennofs> merijn: oh no, sorry :)
02:24:47 <merijn> magneticDuck: Irrelevant, if it can't compile posix compliant C code it's worthless. Although that remains to be tested, since bennofs was answering a different question
02:25:05 <merijn> Although it's currently looking like none of the linux distros can manage this...
02:25:15 <magneticDuck> merijn: .. what?
02:25:27 <magneticDuck> <_<
02:26:05 <merijn> hvr: /sb goto -20
02:26:07 <merijn> hvr: /sb goto -20
02:26:11 <merijn> argh
02:26:15 <merijn> tab complete fail
02:26:27 <magneticDuck> what you're saying sounds like a person who's used to brooms looking at in industrial vacuum and saying that if can't move dust around it's useless
02:27:06 <bennofs> merijn: hmm, what is the 'util' library?
02:27:14 <merijn> magneticDuck: No it doesn't, it sounds like someone trying to write cross-platform code being annoyed by the linux' utter inability to adhere to standards like posix
02:27:29 <merijn> bennofs: The library that has forkpty on bsd and linux
02:27:48 <magneticDuck> *shrug*
02:28:06 <magneticDuck> you can take a piece of C code intended to be built on a unix machine and put it into nixos
02:28:34 <magneticDuck> it's just that nixos solves a lot of problems in ways that aren't directly compliant with posix standards, like having a global mutable state in /bin and /usr/share etc
02:29:07 <merijn> magneticDuck: This is completely irrelevant for things like "system headers are actually in the right location"
02:29:20 <magneticDuck> I'll explain
02:29:38 <merijn> No, don't bother
02:29:44 <magneticDuck> uh, okay
02:29:51 <bennofs> let's see if this lib builds on nixos...
02:29:55 <magneticDuck> but then don't act as if nixos is stupid because you don't have the time to grasp the whole pixture
02:30:01 <magneticDuck> picture*
02:31:03 <bennofs> merijn: ok, fails with some weird errors ("error: ‘TIOCPKT_NOSTOP’ undeclared (first use in this function)" is one of them).
02:31:28 <merijn> bennofs: Yeah, it's not finding those defines in the same headers as OSX/BSD
02:34:36 <bennofs> merijn: I'm not sure if a foreign import of a probably #define'd constant works?
02:34:54 <merijn> bennofs: It works with that syntax and CApiFFI :)
02:35:00 <merijn> CApiFFI <3
02:36:05 <bennofs> merijn: oh nice, didn't know that
02:38:30 * hackagebot quandl-api 0.2.1.0 - Quandl.com API library  http://hackage.haskell.org/package/quandl-api-0.2.1.0 (PeterVanDenBrand)
02:40:54 <bennofs> merijn: on my system, I have a #define for that in <linux-headers>/include/asm-generic/ioctls.h
02:41:07 <bennofs> (<linux-headers> is the linux-headers package)
02:41:28 <merijn> bennofs: Yeah, I think I might have a fix now, let's see
02:44:43 <jophish> Hmm, It's annoying that Bits a requires Eq a and has member functions such as testBit :: a -> Int -> Bool
02:45:46 <jophish> This makes it impossible to define Bits for some "opaque" type such as (->) a
02:45:52 <jophish> Bits a
02:46:14 <jophish> That's an odd example, but there are other use cases
02:46:39 <jophish> I guess it's not much more odd than a Num instance for functions
02:47:34 <jophish> I could always implement those functions as (error "Unable to test bits for this type")
02:50:04 <grpala> how should I go about debugging a segfault in GHC generated code?
02:50:36 <merijn> grpala: Compile with -debug to get debug symbols in the runtime and hope you get a useful core dump
02:55:25 <ronh-> grpala I am just curious, were you doing any FFI?
03:00:30 <jophish> What would a good name be for a class which is the same as Bits but without those functions?
03:00:35 <jophish> "OpaqueBits"
03:01:02 <merijn> jophish: What would it's purpose be?
03:01:13 <merijn> How would you "and" an opaque set of bits?
03:02:49 <jophish> merijn: and is a -> a -> a, the values of the bits don't leak. My particular use case is to be able to use fixed-point (https://hackage.haskell.org/package/fixed-point-0.5.0.1/docs/Data-Fixed-Binary.html) with the integer types from ivory (https://hackage.haskell.org/package/ivory-0.1.0.0/docs/Ivory-Language-Uint.html)
03:03:26 <jophish> ivory is an edsl for generating C, so the values of the bits aren't known when the Haskell is running
03:04:25 <jophish> they have a Num instance, so it seems natural for them to have a Bits instance too
03:05:46 <jophish> There would of course be a 'Bits a => OpaqueBits a' instance
03:07:12 <jophish> The annoying part is having to fake those functions in Bits and fake the whole of Eq
03:08:07 <jophish> This is probably a really specific use case. Having said that, Eq did used to be a superclass of Num, and that changed
03:08:31 * hackagebot eventloop 0.4.1.1 - A different take on an IO system. Based on Amanda's IO loop, this eventloop takes a function that maps input events to output events. It can easily be extended by modules that represent IO devices or join multiple modules together.  http://hackage.haskell.org/package/eventloop-0.4.1.1 (sebaslafleur)
03:08:39 <tdammers> Num is still way too fat IMO, but I don't know what the consequences would be of splitting it up
03:10:08 <jophish> I wonder how many people are actually using a nicer num hierarchy. To be entirely honest, although conceptually lovely, I've never had the need for a finer grained hierarchy
03:10:39 <jle`> sometimes i feel like it'd be nice to have a Ring typeclass
03:10:45 <jophish> I guess it comes down to what's pragmatic, probably part of the reasond we don't program everything in agda
03:11:05 <jle`> so Num without signum/fromInteger/abs
03:11:09 <tdammers> I never need a better Num on the consumer side, but I think it would be nice to have it on the producer side
03:11:28 <tdammers> e.g., make things that you can add, but not subtract
03:11:47 <jle`> it'd be a nice thing for GHC.Natural, i guess
03:12:08 <jle`> let's get a Rng typeclass then :)
03:12:49 <jle`> oh wait no that's not a Rng
03:13:02 <jle`> that's a semiring
03:18:26 <jophish> jle`: a Random Number Generator is probably a *really* bad idea for addition :D
03:19:33 <jle`> :P
03:23:32 * hackagebot clash-lib 0.5.5 - CAES Language for Synchronous Hardware - As a Library  http://hackage.haskell.org/package/clash-lib-0.5.5 (ChristiaanBaaij)
03:23:34 * hackagebot clash-ghc 0.5.6 - CAES Language for Synchronous Hardware  http://hackage.haskell.org/package/clash-ghc-0.5.6 (ChristiaanBaaij)
04:05:36 <stobix> hm. ⟪ join (+) ⟫ has the type Num a => a -> a. Does this mean that (+) can be seen as a monadic functor of a monadic functor that transforms ℝ unto itself twice?
04:06:56 <stobix> @pf (\x -> x + x )
04:06:57 <lambdabot> Maybe you meant: pl bf
04:07:03 <stobix> hm?
04:07:13 <stobix> @pl (\x -> x + x )
04:07:13 <lambdabot> join (+)
04:07:22 <liste> stobix the type comes from the Monad instance of (->)
04:07:27 <liste> it has nothing to do with (+)
04:07:39 <stobix> liste: oh, so it applies to functions in general?
04:07:43 <liste> yeah
04:08:03 <liste> @info Monad (->)
04:08:04 <lambdabot> <unknown>.hs: 1: 8:Parse error: ->
04:08:10 <liste> @info Monad ((->))
04:08:11 <lambdabot> <unknown>.hs: 1: 9:Parse error: ->
04:08:22 <stobix> heh. (->) is weird sometimes.
04:08:47 <stobix> liste: Does this imply that every function is a monad‽ What about the monadic laws?
04:09:11 <liste> stobix it's actually the reader monaed
04:09:16 <liste> monad*
04:09:32 <liste> Reader a is a wrapper for ((->) a)
04:09:52 <stobix> Oh. What does the Reader do?
04:10:41 <jle`> there's no :info in lambdabot
04:11:19 <jle`> stobix: (a ->) is a Monad, for any a
04:11:30 <jle`> you can sort of guess what `join` has to do
04:11:38 <jle`> (a -> (a -> b)) -> (a -> b)
04:12:04 <liste> it's basically a shorthand to pass an argument to multiple functions. I usually use it to keep global environment (e.g. DB connection options in a webapp)
04:13:36 <tmtwd> my-bad-map f xs = foldl(\acc x -> f x ++ [f acc]) [] xs
04:13:49 <tmtwd> why is there a parse error on this function?
04:13:50 <liste> > let { f :: Int -> () -> Int; f env () = env + 1; g :: Int -> Int -> Int; g env x = x + env; } in (f () >>= g) 5
04:13:52 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘()’
04:13:52 <lambdabot>      In the first argument of ‘f’, namely ‘()’
04:13:52 <lambdabot>      In the first argument of ‘(>>=)’, namely ‘f ()’    Couldn't match type ‘...
04:14:16 <tmtwd> >my-bad-map f xs = foldl(\acc x -> f x ++ [f acc]) [] xs
04:14:48 <indiagreen> tmtwd: because function names can't have hyphens in them
04:15:18 <indiagreen> unfortunately
04:16:00 <tmtwd> yes that is annoying
04:16:10 <tmtwd> with clojure it is a real pain
04:18:20 <tmtwd> my_reverse ys = foldr  (\x acc -> acc ++ [x]) [] ys
04:18:32 <jle`> foo-bar would be parsed as a definition for (-)
04:18:37 <tmtwd> in this function [] is passed into the foldr as x?
04:18:41 <tmtwd> and ys as acc?
04:19:16 <mauke[]> tmtwd: no
04:19:34 <mauke[]> @src foldr
04:19:34 <lambdabot> foldr f z []     = z
04:19:34 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:19:39 <m_ryan> hi how to set a global variable? instead on declaring it in a function i like to declare outside?
04:19:52 <mauke[]> m_ryan: "functions" are global variables
04:20:07 <jle`> you can define something globally by just defining it at the top level
04:20:17 <mauke[]> 'foo x y z = ...' is syntactic sugar for 'foo = \x y z -> ...'
04:20:30 <tmtwd> @src foldl
04:20:31 <lambdabot> foldl f z []     = z
04:20:31 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
04:20:37 <mauke[]> i.e. a global variable bound to a function
04:21:59 <m_ryan> mauke[]: thanks for clarification
04:23:05 <m_ryan> another question what should be my return type in this function? http://lpaste.net/132857
04:23:11 <tmtwd> but I thought that for lambdas the args are passed in sequentially ie (\ x y -> x + y) xArg yArg
04:23:35 * hackagebot posix-pty 0.2.0 - Pseudo terminal interaction with subprocesses.  http://hackage.haskell.org/package/posix-pty-0.2.0 (MerijnVerstraaten)
04:24:05 <mauke[]> tmtwd: they are, but function application is left associative
04:24:14 <mauke[]> a b c parses as (a b) c, not a (b c)
04:24:23 <tmtwd> I see
04:24:37 <mauke[]> so foldr (\x y -> ...) ... passes the lambda to foldr
04:25:41 <merijn> What's the standard for listing other contibutors in a repository?
04:25:45 <m_ryan> another question what should be my return type in this function? http://lpaste.net/132857
04:25:48 <tmtwd> so ((foldr  (\x acc -> acc ++ [x])) [] ys)?
04:26:14 <merijn> tmtwd: If you wanna properly parenthesise everything it'd be: (((foldr  (\x acc -> acc ++ [x])) []) ys)
04:26:17 <merijn> tmtwd: But, yes
04:26:26 <mauke[]> we need to go deeper
04:26:26 <liste> m_ryan so ctr is an IO action that  returns an Int? that's IO Int
04:27:04 <mauke[]> ((foldr (\x -> (\acc -> ((++) acc) [x]))) []) ys
04:28:29 <tmtwd> but wouldn't [] still be passed in as the 1st arg to the lambda?
04:28:31 <m_ryan> liste: is say's that the actual type is an IO ThreadId
04:28:39 <tmtwd> or is it passed to foldr first?
04:29:21 <Cale> tmtwd: In which example?
04:29:49 <merijn> tmtwd: It's passed to foldr, which in turn at some point passes it to the lambda
04:29:49 <Cale> foldr (\x acc -> acc ++ [x]) [] ys ?
04:29:50 <tmtwd> in my comment at 7:25:26
04:29:52 <merijn> :t foldr
04:29:53 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
04:30:08 <merijn> tmtwd: The [] is the "t a" argument to foldr there
04:30:17 <Cale> @src foldr
04:30:18 <lambdabot> foldr f z []     = z
04:30:18 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:30:43 <liste> m_ryan yeah now forkIO is the last action, so the result of forkIO (a ThreadId) is the return type of the whole thing
04:31:13 <Cale> So, if for instance, you have ys = [[1,2],[3,4],[5]]
04:31:22 <m_ryan> liste: so the return will be like this? IO ThreadId?
04:32:01 <Cale> Then the evaluation proceeds as  foldr (\x acc -> acc ++ [x]) [] [[1,2],[3,4],[5]] -> (\x acc -> acc ++ [x]) [1,2] (foldr (\x acc -> acc ++ [x]) [] [[3,4],[5]])
04:32:31 <Cale> -> (\acc -> acc ++ [[1,2]]) (foldr (\x acc -> acc ++ [x]) [] [[3,4],[5]])
04:32:42 <tmtwd> @merijn, is (a -> b-> b) the lambda function? and b is the ys?
04:32:42 <lambdabot> Unknown command, try @list
04:32:43 <Cale> -> (foldr (\x acc -> acc ++ [x]) [] [[3,4],[5]]) ++ [[1,2]]
04:33:11 <liste> m_ryan it is now. I don't know if it's useful to return the ThreadId though
04:33:27 <Cale> tmtwd: the t a is the type of ys in that type signature
04:33:29 <liste> the type of the action is IO ThreadId, so the type of the result is ThreadId
04:33:35 <tmtwd> I see
04:33:42 <Cale> tmtwd: Specialised to lists, the type would be  (a -> b -> b) -> b -> [a] -> b
04:33:46 <m_ryan> liste: my target it the Int type how should i do that?
04:34:03 <liste> m_ryan you need to read the MVar
04:34:08 <tmtwd> so [a] is the ys?
04:34:15 <tmtwd> and what is the []?
04:34:47 <Cale> tmtwd: and in your specific case, you're picking a = [t] and b = [t], so that it's ([t] -> [t] -> [t]) -> [t] -> [[t]] -> [t]
04:35:20 <Cale> (\x acc -> acc ++ [x]) :: [t] -> [t] -> [t]
04:35:21 <m_ryan> liste: can you help me out?
04:35:24 <Cale> [] :: [t]
04:35:29 <Cale> ys :: [[t]]
04:36:07 <knotman> m_ryan, what's the problem?
04:36:59 <m_ryan> knotman: i like to get the Int Type on my ForkIO - http://lpaste.net/132857
04:38:35 * hackagebot posix-pty 0.2.0.1 - Pseudo terminal interaction with subprocesses.  http://hackage.haskell.org/package/posix-pty-0.2.0.1 (MerijnVerstraaten)
04:38:41 <tmtwd> Cale thanks
04:41:04 <liste> m_ryan are you trying to make a counter that increments after a time period?
04:41:20 <m_ryan> yes.
04:41:26 <m_ryan> liste: yes
04:42:37 <liste> so that do {a <- ctr; print ctr; ....; b <- ctr; print ctr; ...} prints first 0 and then 1 ?
04:42:54 <liste> print a* print b*
04:43:12 <liste> do { a <- ctr; print a; ...; b <- ctr; print b; ...}
04:43:24 <m_ryan> liste: i want to be static for all the users. that will access my net.
04:43:33 <m_ryan> i mean the site.
04:44:52 <liste> then you need the MVar and Chan to be outside the function - in your paste new ones are created every time the function is called
04:46:05 <liste> they could be top-level variables (https://wiki.haskell.org/Top_level_mutable_state, a dirty hack though) or arguments to ctr
04:46:07 <m_ryan> liste: can you edit it?
04:47:16 <liste> m_ryan I'm sure you can figure it out yourself with a few pointers
04:48:11 <Philonous> Is there a way to get cabal repl to use the object files that cabal build produced?
04:49:56 <m_ryan> liste: be right back once i figure out. thank you for the help.
04:52:08 <liste> m_ryan you don't even need the Chan. just forkIO one thread to forever increment the MVar and delay, and just read the MVar value every time you need the counter
04:52:29 <merijn> This sounds like it should be an IORef instead
04:58:36 * hackagebot record 0.3.1.2 - First class records implemented with quasi-quotation  http://hackage.haskell.org/package/record-0.3.1.2 (NikitaVolkov)
05:08:37 * hackagebot ghc-prof-flamegraph 0.1.0.1 - Generates data to be used with flamegraph.pl from .prof files.  http://hackage.haskell.org/package/ghc-prof-flamegraph-0.1.0.1 (FrancescoMazzoli)
05:10:40 <absence> there are two instances in Data.Functor.Contravariant that are simply specialisations of Data.Function.on. is it coincidence, or is on some kind of generalisation?
05:15:49 <hodapp> someday, I'll actually have to care about the performance of my Haskell code >_>
05:16:10 <hodapp> for now, a factor-of-4 decrease would even be tolerable
05:21:43 <ew0> hello
05:21:50 <ew0> I write code once in a few months
05:21:59 <ew0> erm
05:22:09 <ew0> I write "Haskell" code once a few months
05:22:17 <ew0> and the language changes too quickly
05:22:25 <ew0> I'm not being able to keep up
05:22:28 <Cale> ew0: How so?
05:22:38 <ew0> is there a blog to keep up to date
05:22:45 <Denommus> ew0: there was only one huge breaking change 
05:22:56 <ew0> yes, old cold works fine
05:23:01 <ew0> but newer code is a lot different
05:23:25 <ew0> for instance, when I started, there was only one way to write data types
05:23:26 <ew0> now
05:23:31 <Denommus> ew0: I don't know what you mean. Maybe that's a library issue? 
05:23:32 <ew0> there are like 3 hundred ways
05:23:54 <liste> ew0 do you mean language extensions like GADTs ?
05:24:08 <Denommus> ew0: uh, there has always been data, newtype and type
05:24:20 <Denommus> ew0: what other ways are you talking about? 
05:24:28 <mauke[]> when were GADTs introduced?
05:24:49 <c_wraith> something like GHC 6
05:25:01 <c_wraith> ie, well before I started using Haskell
05:26:03 <mauke[]> I've found papers from 2003/2004
05:26:42 <mauke[]> ("First-Class Phantom Types", "Wobbly types: type inference for generalised algebraic data types")
05:26:53 <liste> and then there's the TemplateHaskell approaches of libraries like Persistent
05:27:13 <mauke[]> that's just code generation
05:28:12 <Veyn> How would I do regex in Haskell?
05:28:29 <mauke[]> generally, "no"
05:28:37 <Veyn> oh.. ok .-.
05:28:47 <Veyn> Reasons why?
05:29:01 <liste> Veyn parser combinators are more readable and more powerful
05:29:11 <liste> e.g. Parsec
05:29:24 <Veyn> Err, Docs? =D
05:29:25 <liste> and not really any more typing
05:30:01 <tdammers> only concern might be performance and end-user configurability
05:30:03 <liste> Veyn http://book.realworldhaskell.org/read/using-parsec.html may be a bit out of date but it was a great introduction for me
05:30:03 <tdammers> but even then
05:30:18 <tdammers> if parsec doesn't perform well enough, attoparsec is hard to beat
05:30:41 <Veyn> I'm not really looking for performance in this case, just ease of use.
05:31:40 <tdammers> parsec, then
05:32:15 <Veyn> Alright then, Thanks!
05:32:17 <maerwald> there are valid use cases for regex. I sometimes think people say "no", because haskell cannot elegantly solve them ;)
05:32:21 <maerwald> https://wiki.haskell.org/Regular_expressions
05:33:10 <mauke[]> maerwald: I agree
05:33:12 <maerwald> depending on the problem a parser for a complex regex can be 100 times more difficult to implement
05:34:56 <liste> for regexes http://hackage.haskell.org/package/regex-applicative may also be worth a look
05:35:25 <maerwald> liste: interesting, it's not in the haskell wiki, maybe someone should add it?
05:37:42 <liste> I've never used it, though, so not sure of its quality
05:38:51 <calvinx> Does anyone use nix here?  I wanted to ask - if I am using nix to manage my Haskell packages, I will not need cabal anymore? Do I need to install cabal in my nixos?
05:39:18 <dcoutts> calvinx: well the Haskell support in nix uses cabal a lot of course
05:39:37 <dcoutts> calvinx: and yes, quite a few people use nix for Haskell stuff
05:39:48 <liste> cabal is still used for building packages
05:40:07 <liste> the job it was made for :D
05:40:20 <dcoutts> and sometimes for working out build plans, which are then frozen into nix exprs
05:41:41 <calvinx> dcoutts: okay, so I still have to use cabal-install
05:41:47 <calvinx> I can seem to find it though.
05:41:54 <calvinx> where’s “cabal” in nix?
05:42:10 <calvinx> :%s/can/can’t/g
05:42:16 <dcoutts> calvinx: no I think one can use nix without it, I was mainly saying it's getting used under the surface
05:42:27 <dcoutts> or in the prep of new nix exprs
05:42:49 <calvinx> There’s a cabal2nix tool.
05:43:31 <calvinx> ah ok, I found cabal-install after all.
05:43:38 * hackagebot leapseconds-announced 2015.0.0.1 - Leap seconds announced at library release time.  http://hackage.haskell.org/package/leapseconds-announced-2015.0.0.1 (BjornBuckwalter)
05:47:20 <absence> http://lpaste.net/129955 <- is something like this defined in a lib?
05:50:28 <mdcox> Hello :)  I'm new to haskell and I'm having trouble with a list comprehension flattening my list?  I'm using this code to try to get a list of lists of Ints, [[Int]] : http://lpaste.net/3601199983136604160
05:50:59 <maerwald> yikes, underscores
05:51:33 <mdcox> sorry...like I said, new.  I've been in Rust and Ruby world for the last 3 or 4 months
05:52:15 <maerwald> mdcox: can you give the output you are expecting?
05:52:55 <mdcox> [[1],[1,2],[1,2,3]....]
05:53:02 <z16> camelCase is disgusting
05:53:04 * z16 hides
05:53:44 <mdcox> maerwald: Like that. I'll modify it a bit later, but it's part of a larget algorithm so that's what I need for now
05:53:51 <mdcox> *larger
05:54:27 <mdcox> I just figured since `slice` returns [Int] then having it return in the list comprehension would give me a [[Int]]
05:54:35 <tdammers> z16: so it is. move on.
05:55:54 <z16> mdcox: How about [ [1..x] | x <- [1..n] ]
05:56:11 <z16> Where n is the provided upper limit
05:56:21 <z16> Is there a Haskell bot in here?
05:57:10 <igniting> > [[1..x] | x <- [1..5]] -- z16
05:57:12 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
05:57:19 <z16> igniting: Thanks
05:57:24 <z16> New to the channel
05:57:38 <mdcox> z16: The array in main is just one example, it should do it for any array, even if the numbers are not in sequential order like that
05:57:52 <mdcox> z16: But thank you.
05:58:21 <z16> > [[1..x] | x <- [3,2,5]
05:58:23 <lambdabot>  <hint>:1:23:
05:58:23 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
05:58:27 <z16> > [[1..x] | x <- [3,2,5]]
05:58:29 <lambdabot>  [[1,2,3],[1,2],[1,2,3,4,5]]
05:58:35 <z16> @ mdcox ?
06:02:39 <Cale> mdcox: This is a nitpick, but arrays and lists are not the same thing (and especially not in Haskell), you're referring to lists :)
06:03:11 <maerwald> > (\xs -> fmap (\x -> take x xs) [1.. length xs] ) [3,4,5,1,9]
06:03:14 <lambdabot>  [[3],[3,4],[3,4,5],[3,4,5,1],[3,4,5,1,9]]
06:03:33 <otulp> mdcox: I'm not sure if I should give you a code sample, or if you just want some pointers so you can figure it out on your own. But from what I can see, your initial code is very nearly there. I don't understand why you embed "slice i (length arr)" in a list if you want a list of lists (instead of a list of lists of lists), and I don't see why you don't ask slice for slices that always start at the beginnin
06:03:39 <otulp> g if that's what you want.
06:03:39 * hackagebot lifted-async 0.7.0.1 - Run lifted IO operations asynchronously and wait for their results  http://hackage.haskell.org/package/lifted-async-0.7.0.1 (MitsutoshiAoe)
06:04:31 <Cale> > inits [3,4,5,1,9]
06:04:33 <lambdabot>  [[],[3],[3,4],[3,4,5],[3,4,5,1],[3,4,5,1,9]]
06:04:58 <mdcox> Cale: Oh, I had no idea they were linked lists.  I was looking for an array or vector type...
06:05:17 <Cale> mdcox: Yeah, they're in fact, lazy linked lists
06:05:26 <Cale> They can be infinitely long:
06:05:51 <mdcox> otulp: A hint would be best I guess.  I've been at it for a while, haha
06:05:58 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
06:06:00 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
06:06:11 <z16> mceier: Was what I said not what you meant?
06:06:28 <Cale> Lists in Haskell are essentially the data structure representation of loops. :)
06:06:29 <z16> Sorry, mdcox *
06:07:21 <maerwald> mdcox: if you want it with list comprehension it looks the same as above
06:07:22 <mdcox> z16: No, I want something where I can input [6,4,2,5,9] and get back [[6],[6,4],[6,4,2],[6,4,2,5],[6,4,2,5,9]]
06:07:27 <maerwald> (\xs -> [ take x xs | x <- [1.. length xs] ]) [3,4,5,1,9]
06:07:34 <z16> mdcox: Ah, I see
06:07:36 <maerwald> > (\xs -> [ take x xs | x <- [1.. length xs] ]) [3,4,5,1,9]
06:07:38 <lambdabot>  [[3],[3,4],[3,4,5],[3,4,5,1],[3,4,5,1,9]]
06:08:03 <maerwald> or just what Cale said
06:08:05 <Cale> Haskell also has a whole bunch of different types of arrays -- this library might be interesting if you need slicing: http://hackage.haskell.org/package/vector
06:08:15 <mdcox> maerwald: I guess I don't get what the \xs -> is doing
06:08:28 <merijn> mdcox: That's a lambda
06:08:28 <maerwald> mdcox: it's an anonymous function
06:08:34 <mdcox> Oh ok
06:08:36 <maerwald> get_array_of_all_subarrays arr = [ take x arr | x <- [1.. length arr] ]
06:08:40 <maerwald> that would be your code
06:08:41 <merijn> :t \x -> x + 1
06:08:43 <lambdabot> Num a => a -> a
06:08:51 <merijn> > (\x -> x + 1) 3
06:08:53 <lambdabot>  4
06:10:01 <Cale> mdcox: But yeah, while constructing a list of tails is quite cheap (because the tails share structure), constructing a list of initial segments like that is pretty expensive, because no two of them have the same tail.
06:10:02 <mdcox> Awesome, thanks maerwald :)
06:10:28 <mdcox> And thanks to Cale, merijn, z16  and otulp  too :)
06:11:09 <maerwald> mdcox: you can also use do notation instead of list comprehension http://lpaste.net/132858
06:11:16 <maerwald> I personally don't like list comprehension
06:11:20 <Cale> > tails "abracadabra"
06:11:22 <lambdabot>  ["abracadabra","bracadabra","racadabra","acadabra","cadabra","adabra","dabra...
06:11:51 <Cale> > any (isPrefixOf "dab") . tails $ "abracadabra"
06:11:53 <lambdabot>  True
06:12:07 <Cale> > findIndex (isPrefixOf "dab") . tails $ "abracadabra"
06:12:08 <lambdabot>  Just 6
06:12:17 <maerwald> can one shove an lpaste into lambdabot?
06:12:23 <Cale> Nope
06:12:32 <maerwald> that would be a neat feature
06:12:56 <Cale> > zip [0..] . tails $ "abracadabra"
06:12:58 <lambdabot>  [(0,"abracadabra"),(1,"bracadabra"),(2,"racadabra"),(3,"acadabra"),(4,"cadab...
06:13:08 <maerwald> something like "+l <url>: myFunc 1 2 3"
06:13:14 <Cale> > filter (isPrefixOf "ab" . snd) . zip [0..] . tails $ "abracadabra"
06:13:16 <lambdabot>  [(0,"abracadabra"),(7,"abra")]
06:13:24 <maerwald> Cale: what are you doing?
06:13:33 <otulp> Magic!
06:13:43 <Cale> Just showing off the list library a bit :)
06:14:44 <Cale> > sort "abracadabra"
06:14:45 <merijn> maerwald: Lambdabot is open source, though :p
06:14:45 <maerwald> mdcox: do you understand the code?
06:14:46 <lambdabot>  "aaaaabbcdrr"
06:14:54 <Cale> > group . sort $ "abracadabra"
06:14:56 <lambdabot>  ["aaaaa","bb","c","d","rr"]
06:15:01 <Cale> > map head . group . sort $ "abracadabra"
06:15:02 <maerwald> Cale: I don't think you need to paste all list functions
06:15:02 <lambdabot>  "abcdr"
06:15:33 <Cale> Fair enough :)
06:16:26 <Cale> I think it's good for beginners to see idioms like those though :)
06:16:42 <mdcox> maerwald: Yeah I do.  Its one of those things where I can read it fairly easily, but I don't know if I would ever have written it.  
06:16:53 <mdcox> Guess that just comes down to working within the language
06:17:28 <mdcox> The $ took me a second, but I looked it up and understand it
06:17:41 <Cale> Yeah, it's just function application, but with low precedence
06:18:04 <mdcox> Having so many different ways to apply a function seems like it could lead to unreadable code, but I have no idea if that actually happens in practice.
06:18:44 <mdcox> I just sort of like the idea of always reading functions from left to right or right to left...zigzagging about seems like it could get knotted up
06:18:46 <tdammers> it's not really a different way to apply a function
06:18:47 <maerwald> yes it does
06:19:07 <tdammers> but yes, with great power comes great responsibility
06:19:10 <z16> Well, Haskell is probably not the most readable language in the world, but it's part of what makes the language easy to work with once you're better at it
06:19:17 <Cale> I don't like flipped application operators
06:19:26 <Cale> There are a few libraries which define them
06:19:35 <z16> It's not as bad as Perl :)
06:20:06 <z16> (The go-to excuse of every language designer's syntactic mistakes)
06:20:29 <tdammers> well, the risk with haskell is that because you can trivially define your own operators, everyone keeps defining their own operators
06:20:30 <Cale> mdcox: But just to be clear $ isn't flipped around or anything, it's just f $ x = f x 
06:20:48 <tdammers> ($) is just another function... :x
06:21:01 <mdcox> Cale: wait, then what's the point?  Just to make application explicit?
06:21:16 <Cale> mdcox: The only point of it is that it's low precedence, so when you write something like  f . g . h $ x u v, it means (f . g . h) (x u v)
06:21:38 <z16> Is $ left or right associative?
06:21:44 <ronh-> right
06:21:50 <merijn> $ has low precedence, which lets you avoid parenthesis
06:21:50 <z16> k
06:22:00 <tdammers> a b c d == a (b (c d)); but a b $ c d == (a b) (c d)
06:22:02 <mdcox> Oh ok, gotcha.  That...still seems silly when the parens version works. But I guess it's more concise by 2 chars
06:22:10 <maerwald> https://github.com/quchen/articles/blob/master/fbut.md#-has-special-powers
06:22:14 <Cale> I try not to ever rely on the right-associativity of ($)
06:22:18 <ronh-> $ has other uses
06:22:19 <tdammers> a . b . c . d . e . f $ g -- is a common idiom
06:22:21 <maerwald> ($) is not just a function, it's special
06:22:34 <z16> Cale: I don't intend to use it, was just curious
06:22:34 <Cale> Whenever you see  f $ g $ h $ x, you can pretty much always rewrite that as f . g . h $ x
06:22:38 <merijn> maerwald: It IS just a function, albeit it one with ugly hacks
06:22:47 <Cale> and composition is a nicer operation than ($) for refactoring and understanding
06:22:52 <maerwald> merijn: I didn't say it is not a function :)
06:22:53 <ronh-> > map ($4) [id, (+1), (2^)]
06:22:53 <merijn> Infact, you SHOULD rewrite it as "f . g . h $ x"
06:22:55 <lambdabot>  [4,5,16]
06:23:02 <z16> Also, . does not look as ugly as $ <_<
06:23:13 <merijn> Because . is more refactorable
06:23:15 <tdammers> maerwald: ah, interesting
06:23:16 <Cale> because for example, g . h and f . g are both well-typed there
06:23:26 <Cale> while g $ h and f $ g almost certainly wouldn't be
06:23:40 <phy1729> merijn: could you explain what you mean more refactorable
06:23:49 <tdammers> phy1729: easier to refactor
06:24:01 <merijn> phy1729: What Cale said
06:24:03 <maerwald> mdcox: for beginner readable code I would avoid pointfree code, although some haskellers like it so hard
06:24:06 <tdammers> phy1729: but the real win is when you need to add functions into that chain, or remove them
06:24:12 <Cale> phy1729: You can chop out g . h into its own definition and not have to rewrite it
06:24:24 <merijn> phy1729: You can take any arbitrary part of a . pipeline and split it into a local definition while everything remains correct
06:24:29 <merijn> phy1729: This does not hold for $
06:24:30 <tdammers> a . b . c $ d -> a . b $ d -- straightforward
06:24:46 <Cale> Well, this isn't even points-free code, but it also is a stepping stone to being comfortable with points free code
06:24:57 <merijn> tdammers: Also when moving part of the chain into a local definition for clarity
06:25:03 <tdammers> merijn: yes, that too
06:25:10 <phy1729> oh, why is it called points free?
06:25:13 <tdammers> or chopping that chain in whichever way
06:25:21 <merijn> phy1729: A point is a math term for variable names
06:25:30 <tdammers> phy1729: in f x = ..., "x" is called a "point"
06:25:34 <merijn> phy1729: So "pointfree" == "no explicit variable names"
06:25:34 <Cale> phy1729: Well, the terminology comes from algebraic topology, where they mostly deal with functions between spaces that are made up of points
06:25:46 <maerwald> the worst are partly-pointfree functions
06:25:53 <merijn> @quote pointfree
06:25:53 <lambdabot> Kazagistar says: haha @pl, for when you feel like maybe, just maybe, pointfree might be an elegant way to code, and want to have your hopes dashed
06:26:00 <Cale> phy1729: So it originally referred to defining functions in such a way that you don't mention where the individual points go.
06:26:01 <merijn> hmm, not the quote I wanted
06:26:16 <tdammers> still a nice one though
06:26:48 <merijn> @quote monochrom point.free
06:26:48 <lambdabot> monochrom says: "point free" can be decomposed to: "point" refers to ".", "free" refers to using no "$". :)
06:27:06 <Cale> maerwald: I dunno.  map f = foldr (\x xs -> f x : xs) []  or even  map f = foldr ((:) . f) []  isn't so bad ;)
06:27:17 <Cale> merijn: haha
06:27:34 <benzrf> if the point-free version is uglier, it just means that there's a combinator you've forgotten
06:27:59 <Cale> The points that points-free is referring to are the values in the type of the function's domain and codomain.
06:28:07 <maerwald> Cale: I don't like it
06:28:13 <benzrf> Cale: how very topological
06:28:25 <flux> point-free it like makeup; if it doesn't make your code pretty, you're not using enough of it
06:28:37 <Cale> That's...
06:28:54 <Cale> flux: hahaha
06:29:08 <oneeman> flux: lol, "The beatings will continue until morale improves"
06:29:09 <flux> (oops, it->is)
06:29:11 <Cale> http://en.wikipedia.org/wiki/Pointless_topology
06:29:26 <maerwald> merijn: "A common misconception is that the 'points' of pointfree style are the (.) operator (function composition, as an ASCII symbol), which uses the same identifier as the decimal point. "
06:29:44 <Cale> (note: this link has nothing to do with Haskell :P)
06:30:15 <benzrf> is pointless topology when you do math using discrete spaces instead of just calling them sets
06:30:35 <merijn> maerwald: That quote was a joke... :p
06:30:35 <Cale> what?
06:30:42 <Cale> benzrf: oh, jokes
06:30:44 <maerwald> merijn: I didn't see joke tags
06:31:02 <merijn> maerwald: The "free refers to using no "$"" and smiley didn't give it away? :p
06:31:06 <maerwald> jokes don't translate well in Data.Text
06:31:57 <maerwald> @type ((.).(.))
06:31:59 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
06:32:07 * merijn waits for mauke to mention a fake unicode joke character
06:33:18 <benzrf> ah, merijn
06:33:20 <benzrf> it wasnt a WINKING smiley
06:33:31 <merijn> Now I'm wondering what'd happen if I send a unicode RTL character to IRC...
06:33:44 <merijn> Would every unicode client bollocks up everyone's chat?
06:33:48 <phy1729> merijn: the unicode joke marker is just U+FFFE
06:34:30 <merijn> I though the unicode joke marker was UTF-8 BOM?
06:34:44 <phy1729> that's FEFF
06:35:10 <pacak> ˙˙˙ɹǝʌɹǝs ǝɥʇ ʎq pǝzᴉʇᴉuɐs ǝq ʇɥƃᴉɯ ʇᴉ
06:35:15 <Cale> maerwald: Often if I can define my function completely through a single application of a higher order function, I'll leave the point out.
06:36:03 <Cale> (I'll leave it out in some other cases too... compositions are a pretty common case)
06:36:52 <Cale> If you write  foo x = bar . baz . quux $ x  enough times it's not much of a leap to just start writing  foo = bar . baz . quux
06:37:02 <merijn> phy1729: No, that's UTF-16
06:37:14 <merijn> phy1729: The joke is that a BOM in a single byte encoding is useless :p
06:37:51 <merijn> Cale: But now it won't inline! :p
06:37:58 <maerwald> exactly
06:38:44 <maerwald> https://github.com/quchen/articles/blob/master/fbut.md#f-x---is-not-f--x---
06:38:44 <Cale> merijn: That's not my fault :P
06:39:06 <maerwald> so if you make something pointfree, you change more than just the style
06:39:43 <phy1729> merijn: the joke is U+FFFE is illegal
06:40:34 <merijn> maerwald: Unlikely to matter, though
06:41:02 <Cale> merijn: actually, isn't it the other way around? Removing the explicit parameter should increase the opportunities for inlining, no?
06:42:14 <bernalex> pointfree code makes you think in terms of composition; pointful code makes you think in terms of application.
06:42:14 <joof> this whole conversation seems pointless
06:42:15 <Cale> I haven't thought much about this. Usually I only start caring about whether things inline after I'm already looking at the core, which is pretty rare.
06:43:18 <Cale> bernalex: Well, that's what I like about recommending the f . g . h $ x sort of idiom -- it's pointful for comfort, but you start thinking in terms of composition regardless. :)
06:43:39 <maerwald> bernalex: yeah and there is no clear answer when one or the other form is more comprehensible in some context
06:43:41 * hackagebot lattices 1.3 - Fine-grained library for constructing and manipulating lattices  http://hackage.haskell.org/package/lattices-1.3 (phadej)
06:44:26 <maerwald> so I don't like these "make as much pointfree as possible" or "make everything pointful" approaches. Both are wrong
06:44:41 <Cale> Right
06:49:28 <Myrl-chan> Guys, I want something similar to this. [(a -> Bool)] -> a -> Bool
06:49:39 <c_wraith> :t all
06:49:40 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
06:49:42 <c_wraith> :t any
06:49:43 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
06:49:52 <c_wraith> Hmm.  Those aren't quite right
06:49:53 <Myrl-chan> Basically, if any of the list of functions is true, then it's true.
06:49:56 <Myrl-chan> c_wraith: I know.
06:50:14 <Cale> heh, it's swing any ;)
06:50:52 <Cale> @let swing f c a = f ($ a) c
06:50:54 <lambdabot>  Defined.
06:50:59 <Cale> :t swing any
06:51:00 <lambdabot> Foldable t => t (a -> Bool) -> a -> Bool
06:51:27 <Cale> (There's probably no need to actually define swing, just use any in that way)
06:51:45 <Cale> :t swing zipWith
06:51:46 <lambdabot> [a -> b -> c] -> a -> [b] -> [c]
06:51:51 <Cale> :t swing map
06:51:53 <lambdabot> [a -> b] -> a -> [b]
06:51:55 <Cale> :t swing find
06:51:56 <lambdabot> Foldable t => t (a -> Bool) -> a -> Maybe (a -> Bool)
06:52:00 <Cale> :t swing partition
06:52:02 <lambdabot> [a -> Bool] -> a -> ([a -> Bool], [a -> Bool])
06:53:26 <phy1729> Myrl-chan: foo fs x = any . zipWith ($) fs . repeat x   no?
06:53:42 <Cale> uh
06:53:51 <Cale> It's just  any ($ x) fs
06:53:58 <ronh-> :t sequence :: [(a -> Bool)] -> a -> Bool
06:54:00 <lambdabot>     Couldn't match type ‘[Bool]’ with ‘Bool’
06:54:00 <lambdabot>     Expected type: [a1 -> Bool] -> a1 -> Bool
06:54:00 <lambdabot>       Actual type: [a1 -> Bool] -> a1 -> [Bool]
06:54:13 <Myrl-chan> :t (\x fs -> any ($x) fs)
06:54:15 <lambdabot> Foldable t => a -> t (a -> Bool) -> Bool
06:54:24 <Myrl-chan> Nice.
06:55:02 <Myrl-chan> @pl any ($x) fs
06:55:02 <lambdabot> any ($ x) fs
06:55:04 <Myrl-chan> Lol
06:55:09 <Pato> Hello, can someone help me with anamorphisms?
06:55:22 <Cale> @pl \x fs -> any ($ x) fs
06:55:22 <lambdabot> any . flip id
06:55:24 <Myrl-chan> @pl (\fs x -> any ($x) fs)
06:55:24 <lambdabot> flip (any . flip id)
06:55:39 <Cale> Pato: What do you need?
06:55:40 <Myrl-chan> Nah.
06:55:56 <maerwald> Myrl-chan: I think you cannot make it less readable now...
06:56:01 <Myrl-chan> Lol
06:56:32 <Cale> :t flip (f . runCont . return) any
06:56:34 <lambdabot>     Could not deduce (Typeable t0) arising from a use of ‘f’
06:56:34 <lambdabot>     from the context (Typeable a, FromExpr c)
06:56:34 <lambdabot>       bound by the inferred type of
06:56:40 <Cale> :t \f -> flip (f . runCont . return) any
06:56:41 <lambdabot> Foldable t => (((a -> r) -> r) -> ((a1 -> Bool) -> t a1 -> Bool) -> c) -> a -> c
06:56:45 <Cale> err
06:56:46 <Cale> heh
06:56:53 <Pato> I have the following data type for a binary tree: data BTree a = Empty | Node(a, (BTree a, BTree a)), and I have to define a function (qsplit) that will function as the anamorphism gene, like this:
06:56:54 <Pato> abpe (n, m) = anaBTree qsplit (n, m)
06:56:57 <Cale> oh, right
06:57:05 <Cale> :t flip (any . runCont . return)
06:57:06 <lambdabot> Foldable t => t (a -> Bool) -> a -> Bool
06:57:14 <Cale> There you go, less readable
06:57:15 <Pato> the point is to build a balanced binary tree, ranging from n to m 
06:57:21 <Pato> n and m being integers
06:58:00 <Cale> How is your anaBTree defined?
06:58:08 <Cale> (or at least what type does it have?)
06:58:20 <Pato> anaBTree g = inBTree . (recBTree (anaBTree g) ) . g
06:58:30 <Pato> recBTree g = id -|- (id >< (g >< g))
06:58:45 <Cale> Oh, so in the least readable possible way, great ;)
06:59:27 <Pato> sorry xD
06:59:44 <Cale> Let's try again with just the type this time
07:00:11 <Pato> anaBTree :: (c -> Either () (b, (c, c))) -> c -> BTree b
07:00:19 <Cale> okay
07:00:30 <mauke[]> is this anaLTree again?
07:00:58 <Pato> no anal this time, hehe
07:01:07 <Cale> Pato: So, your type c will be a pair of integers
07:01:49 <Pato> yes
07:01:49 <Cale> Pato: You'll want to case on the result of applying compare to them
07:02:21 <Cale> If the first integer is greater than the second, then the tree to be generated is empty.
07:03:32 <Cale> If they're equal, then you want to generate that common value, and ensure that the subtrees are empty
07:03:47 <Cale> (by picking intervals which will be empty for them)
07:04:00 <Pato> so something like qsplit (a,b) = if ( a > b) then Empty else qsplit (a,b)
07:04:05 <Pato> for the first case?
07:04:22 <Cale> Well, start by just writing the function that you want as a plain recursive function
07:05:47 <marchelzo_> How can I make a function with this signature? "new :: WebSocketsData a => Connection -> IO (BufferedConnection a)" -- GHC says "Illegal polymorphic or qualified type: BufferedConnection a".
07:06:16 <Pato> so a function to generate the sequential numbers, but do I save then on a Btree?
07:06:19 <Cale> marchelzo_: How is BufferedConnection defined? Is it a type synonym?
07:06:34 <marchelzo_> Cale: yes.
07:06:37 <marchelzo_> type BufferedConnection a = forall a. (WebSocketsData a) => (Connection, MVar (Seq a), ThreadId) 
07:07:00 <opqdonut> marchelzo_: the forall a. in the synonym seems redundant
07:07:04 <opqdonut> or not redundant, wrong
07:07:18 <Cale> Pato: Basically the function you'll pass to anaBTree needs to decide whether or not the corresponding tree is empty, and if it's not, then what the root label should be, and which pairs of endpoints its subtrees should use
07:07:46 <marchelzo_> opqdonut: I removed it, but I get the same compilation error.
07:07:54 <Cale> Pato: so something like...
07:08:23 <Cale> @let data BTree a = Tip | Branch a (BTree a) (BTree a) -- forgive me, I'm going to be slightly more idiomatic about this
07:08:27 <lambdabot>  Defined.
07:08:38 <opqdonut> marchelzo_: you probably need to get rid of the WebSocketsData a => constraint in the synonym too
07:08:58 <marchelzo_> opqdonut: Why?
07:08:59 <opqdonut> marchelzo_: then at least the type for your new will make sense
07:09:22 <Cale> @let anaBTree f x = case f x of Left () -> Tip; Right (v,(l,r)) -> Branch v (anaBTree f l) (anaBTree f r)
07:09:24 <lambdabot>  Defined.
07:09:27 <opqdonut> marchelzo_: because "WebSocketsData a => Connection -> IO ((WebSocketsData a) => (Connection, MVar (Seq a), ThreadId))" is a nonsensical type
07:09:30 <Pato> ok
07:09:47 <opqdonut> marchelzo_: the constraints from type synonyms don't magically float to the top of the type
07:10:17 <marchelzo_> ah, I see
07:10:54 <marchelzo_> opqdonut: So now, every function I write that takes a (BufferedConnection a) should have the WebSocketsData constraint?
07:11:06 <opqdonut> marchelzo_: basically, yeah
07:11:07 <Cale> @let deriving instance Show a => Show (BTree a)
07:11:11 <lambdabot>  Defined.
07:11:15 <marchelzo_> ok, cool. Thanks
07:11:25 <Cale> > anaBTree (\(u,v) -> if u > v then Left () else let m = (u + v) `div` 2 in Right (m, ((u,m-1),(m+1,v)))) (3,7)
07:11:27 <lambdabot>  Branch 5 (Branch 3 Tip (Branch 4 Tip Tip)) (Branch 6 Tip (Branch 7 Tip Tip))
07:11:55 <Cale> > anaBTree (\(u,v) -> if u > v then Left () else let m = (u + v) `div` 2 in Right (m, ((u,m-1),(m+1,v)))) (1,7)
07:11:58 <lambdabot>  Branch 4 (Branch 2 (Branch 1 Tip Tip) (Branch 3 Tip Tip)) (Branch 6 (Branch ...
07:12:43 <Cale> @let cataBTree t b = f where f Tip = t; f (Branch x l r) = b x (f l) (f r)
07:12:46 <lambdabot>  Defined.
07:14:26 <Cale> > cataBTree "T" (\x l r -> concat ["(B ",show x," ",l," ",r,")"]) $ anaBTree (\(u,v) -> if u > v then Left () else let m = (u + v) `div` 2 in Right (m, ((u,m-1),(m+1,v)))) (1,7)
07:14:28 <lambdabot>  "(B 4 (B 2 (B 1 T T) (B 3 T T)) (B 6 (B 5 T T) (B 7 T T)))"
07:14:40 <Cale> looks like that works
07:15:12 <Pato> is the catamorphis required for the function?
07:15:21 <Cale> no, I just wanted to see the entire result
07:15:47 <Cale> So I used cataBTree to define a function which would produce a shorter string than show would :)
07:16:38 <Pato> So lets see, if u > v then Left ()
07:16:39 <Geraldus> hey folks!
07:16:53 <Pato> what exactly does that Left () does
07:17:07 <Geraldus> what is the best way to read text file to lazy text?
07:17:14 <Pato> I honestly have a very hard time to get this haskell thing : (
07:17:18 <Cale> Pato: It means in that case, the result is Tip
07:17:27 <Cale> Pato: Are you new to Haskell?
07:17:31 <Cale> Where are you learning it from?
07:17:41 <Cale> This isn't exactly beginner stuff
07:17:42 <usr> i personally dont believe in haskell
07:18:21 <Pato> kinda new. I learn it at the first year of university, (like 3 years ago) and now I need to use it to learn "program algebra", not exacly sure how do you call it in english
07:18:40 <Pato> usually it's just a written test, but this year they decided to do an assigment 
07:19:01 <Pato> in the test you don't really need to know haskell, but for the assigment, well ...
07:19:21 <Pato> but I need the assignment done to have access to the writen test
07:19:30 <Cale> Okay, so look at *my* definition of anaBTree for a moment, I'm sure it's equivalent to yours, it's just easier to understand
07:19:40 <Cale> anaBTree f x = case f x of Left () -> Tip; Right (v,(l,r)) -> Branch v (anaBTree f l) (anaBTree f r)
07:20:14 <Pato> alright
07:20:18 <Cale> (It would have been more idiomatic still to use Maybe instead of Either here, but I'm going with your type signature)
07:20:27 <Cale> So in the case that f x is Left ()
07:20:37 <Cale> anaBTree is going to produce Tip as its result
07:21:19 <Pato> so that's the case because you defined it so. You could have called it something else, right?
07:21:32 <Cale> Called what something else?
07:21:44 <Pato> case f x of Something -> Tip
07:22:02 <Cale> Oh, well, I could have used a type other than Either () ...
07:22:15 <Pato> ooh right, I see
07:22:26 <Cale> Left is the constructor for Either
07:22:26 <Pato> I get it now
07:22:36 <Cale> Tip is what I'm calling the empty tree
07:22:36 <Pato> Left and Right because of the Either
07:22:41 <Cale> yeah
07:23:47 <Pato> ok, so that part is understood
07:24:31 <Cale> So, in the other case, when the left endpoint is less than or equal to the right endpoint, we take the "average", adding them and integer dividing by 2
07:24:58 <Cale> defining that value to be m
07:25:20 <Cale> Then we produce  Right (m,((u,m-1),(m+1,v)))
07:25:35 <jophish> z16: regarding camelcase and underscores: http://www.reddit.com/r/haskell/comments/13u8xn/lets_be_honest/c77a0oi
07:25:36 <Cale> which means that the label on the root node should be m
07:26:07 <Cale> and the left subtree should be produced by recursing on (u,m-1) and the right subtree should be produced by recursing on (m+1,v)
07:27:01 <Cale> Note that conveniently, if u == v, then (u,m-1) and (m+1,v) will both be out of order, and we'll generate empty subtrees in that case
07:27:09 <z16> jophish: The link in that comment is dead
07:27:10 <Pato> hm, I think I got it, let me look at this for a moment and I'll get back at you
07:27:16 <Pato> thanks
07:27:20 <z16> jophish: But yeah, underscores are awful
07:27:29 <z16> I hate that C++ went that route
07:27:39 <Cale> jophish: heh lets_be_honest
07:27:46 <jophish> I don't mind them nearly as much in c++
07:27:59 <jophish> (where whitespace isn't so importnat)
07:28:07 <tdammers> the most awful thing about C++ is how it went all of the routes
07:28:31 <z16> jophish: C++ already has a lot of punctuation, using more punctuation in identifiers is not a good idea imo
07:28:35 <tdammers> some libraries use lowercase_with_underscores, others like TheJavaWay
07:28:52 <z16> std::unordered_map<std::this_that, something_else>
07:29:07 <z16> Takes half a minute to identify the distinct tokens in this line
07:29:16 <z16> tdammers: That's not the Java way
07:29:21 <z16> thisIsTheJavaWay
07:30:11 <liste> aren't Haskell's and Java's case conventions pretty similar? camelCase for values, PascalCase for types
07:30:31 <tdammers> z16: is for classes
07:30:45 <z16> tdammers: True
07:30:46 <ChristianS> liste: yes
07:30:49 <jophish> We all know that lowercase-with-hyphens would be the best though :P
07:31:01 <z16> PascalCase is awesome, camelCase is disgusting
07:31:15 <liste> no, Ada_Case is disgusting
07:31:18 <z16> Having both in one language really evokes mixed feelings in me :X
07:31:23 <Cale> I don't know why, but I just never loved the underscore's appearance typographically. It's below the baseline of the text usually and looks intentionally out of place to me, a bit like the slugs that TeX would put in the margin of your document when a line is overfull.
07:31:27 <z16> Well, that too ;p
07:32:05 <z16> Cale: Underscores were specifically made to resemble space without actually being one
07:32:14 <ronh-> jophish yes :)
07:32:15 <z16> That's part of why they're so hard to read
07:32:26 <geekosaur> wordsAllRunTogetherAreHardToReadAndLookLikeYoureOnSpeed
07:32:34 <Cale> z16: Or to be used in overdraw mode to actually underline text
07:32:34 <z16> People intuitively regard them as spaces
07:32:42 <maerwald> z16: I hate camelCase in C, but I love it in haskell
07:32:59 <jophish> The very worst is when people write stiff like: LlvmBackend
07:33:04 <jophish> or even lLVMBackend
07:33:05 <Cale> geekosaur: Of course, but nobody should be using identifiers that long
07:33:07 <geekosaur> that said, understores are too heavyweight for the way we use thme
07:33:15 <z16> maerwald: C have their own nomenclature.. shrtfnnm
07:33:29 <z16> All lower case, squashed together into 8 chars
07:33:29 <joshc> vowels are expensive
07:33:30 <mauke[]> 6 characters, case insensitively
07:33:31 <geekosaur> *underscores. so much for typing,,,
07:33:36 <mauke[]> C89, fuck yeah
07:34:05 <jophish> I try and use unicode as often as possible: like the snowman operator (☃)
07:34:07 <ronh-> I don't mind any convention too much as long as it is consistent. and it helps that haskell forces naming consistency to some extent
07:34:24 <Cale> The only way to justify having a function name as long as that would be if you expressly wanted nobody to ever use your library
07:34:25 <geekosaur> are we still cross compiling from mainframes with weird bit sizes such that 5-6 chars in a register?
07:34:26 <z16> wcstombs because who hell cares what a function name actually means
07:34:32 <mauke[]> I use unicode all the time. mostly the ASCII subset of unicode
07:34:46 <merijn> mauke[]: That's only for external linkage names, no?
07:34:52 <geekosaur> (SIXBIT represent?)
07:34:53 <mauke[]> merijn: yeah
07:35:03 <mauke[]> which includes all library stuff
07:35:04 <merijn> Whoo! I'm slowly becoming a language lawyer!
07:35:14 <merijn> mauke[]: Obviously :)
07:35:17 <Cale> camelCase is reasonably readable when there are few words
07:35:22 <mauke[]> fortunately no common linker actually works this way
07:35:25 <Cale> It obviously sucks when there are many
07:35:29 <mauke[]> and C99 raised the limits anyway
07:35:33 <Cale> But identifiers never get that long
07:35:38 <mauke[]> but that's why the names are what they are
07:38:04 <stelleg_> there's no way to make an instance depend on a local variable is there
07:38:17 <merijn> stelleg_: What would you want that for?
07:38:44 <Pato> Cale, we understood the algorithm and were able to iterate it on a piece of paper, we'll try to apply it using our version of the anamorphism
07:38:54 <stelleg_> merijn: to have an equality where only the first k elements are considered
07:39:01 <Cale> Pato: cool
07:39:26 <mauke[]> stelleg_: http://hackage.haskell.org/package/reflection-1.5.2.1/docs/Data-Reflection.html possibly related
07:39:41 <Nate888> Could somebody please explain the rose tree data structure? I can't seem to find a good source on the internet
07:39:51 <merijn> stelleg_: I'm not sure I understand the goal
07:40:08 <mauke[]> Nate888: every node has as many children as it wants
07:40:09 <merijn> mauke[]: Man, I've reread the explanation of reflection twice and I still think it's scary voodoo
07:41:02 <ronh-> stelleg_ write a `Int -> Whatever -> Whatever -> Bool' function? if I got your problem right
07:41:05 <stelleg_> mauke[]: thanks that looks pretty cool
07:41:30 <stelleg_> ronh-: except that I need it to be used by Data.Map
07:41:38 <Nate888> @mauke[] so it is simply a graph with no restrictions on the number of children a node can have?
07:41:38 <lambdabot> Unknown command, try @list
07:41:41 <stelleg_> merijn: I think its not possible
07:42:25 <stelleg_> I'll just createa  newtype Restricted = RestrictedData Mydata K
07:42:34 <stelleg_> and create and eq instance for that
07:42:51 <ronh-> stelleg_ that sounds reasonable
07:43:12 <mauke[]> Nate888: well, it's still a tree (directed, acyclic, etc.)
07:43:22 <mauke[]> just one without a fixed branching factor
07:43:29 <stelleg_> ronh-: thanks
07:43:35 <Nate888> mauke[] okay, is that all there is to it?
07:43:38 <mauke[]> yes
07:43:44 <Nate888> cool, thanks
07:43:49 <mauke[]> unless I'm misremembering things
07:44:06 <mauke[]> "In computing, a multi-way tree or rose tree is a tree data structure with a variable and unbounded number of branches per node."
07:44:09 <mauke[]> nope, I'm good
07:45:26 <Nate888> I read that on wikipedia, but from a graph theory background, that reads just like a normal tree
07:45:51 <Nate888> from a CS standpoint, it makes sense though
07:46:15 <srenatus> > let f x y = x + y 
07:46:18 <lambdabot>  <no location info>: not an expression: ‘let f x y = x + y ’
07:46:23 <srenatus> > f x y = x + y 
07:46:25 <lambdabot>  <hint>:1:7: parse error on input ‘=’
07:46:36 <mauke[]> srenatus: what do you expect that to output?
07:46:45 <srenatus> mauke[]: nothing, it's step 1.
07:46:46 <srenatus> ;)
07:47:02 <mauke[]> no steps here
07:47:10 <srenatus> mauke[]: ok
07:47:15 <mauke[]> lambdabot's @run takes an expression
07:47:25 <merijn> Nate888:  Rosetree is a "normal tree"
07:47:28 <mauke[]> also, f is already defined
07:47:45 <merijn> Nate888: Usually you use the name to distinguish it from binary trees, which are usually the "default" in programming
07:47:46 <mauke[]> > [x, f x, f x y]
07:47:49 <lambdabot>  [x,f x,f x y]
07:48:12 <merijn> Nate888: Or tries, which often also have finite and fixed numbers of branches at every node
07:48:34 <srenatus> so, plainly, with f :: A -> B -> C, I want to get a function of type A -> B -> IO C, but (return . f) doesn't seem to do that. \a b -> return $ f a b  does, however. Am I missing something?
07:48:45 <Nate888> merijn: cool, thanks for the info
07:49:13 <mauke[]> srenatus: return . f  =  \x -> return (f x)
07:49:25 <mauke[]> which is not the same as \x y -> return (f x y)
07:49:29 <srenatus> mauke[]: yep, hence this won't work. indeed.
07:49:50 <srenatus> thanks. is there a pointless \x y -> return (f x y) ? oh wait, there was a webapp for that...
07:50:05 <mauke[]> (return .) . f  =  \x -> return . f x  =  \x y -> return (f x y)
07:50:17 <srenatus> mauke[]: thanks
07:50:19 <Big_G> Is there a way to have a typed lambda>
07:50:20 <Big_G> ?
07:50:26 <mauke[]> Big_G: all lambdas are typed
07:50:38 <Big_G> What about this? \x -> x + 2
07:50:39 <aweinstock> (\x -> x+1) :: Double -> Double
07:50:52 <mauke[]> :t \x -> x + 2
07:50:54 <lambdabot> Num a => a -> a
07:50:57 <mauke[]> Big_G: it has a type
07:51:10 <Big_G> But what if I didn't type the double? What if I wanted it as an int or something non-numeric
07:51:25 <Pato> Cale, we are having trouble in converting the lambda expression in anaBTree (\(u,v) -> if u > v then Left () else let m = (u + v) `div` 2 in Right (m, ((u,m-1),(m+1,v)))) to an auxiliar function named "qsplit", are there are special considerations to be made?
07:51:40 <aweinstock> I had thought you were asking about a way to specifically constrain the type (from a more general inferred type)
07:52:09 <mauke[]> Big_G: huh?
07:52:30 <mauke[]> Pato: qsplit (u,v) = if u > v then Left () else let m = (u + v) `div` 2 in Right (m, ((u,m-1),(m+1,v)))
07:52:56 <mauke[]> Pato: or even more direct: qsplit = \(u,v) -> if u > v then Left () else let m = (u + v) `div` 2 in Right (m, ((u,m-1),(m+1,v)))
07:53:43 <Pato> we tried that, but it gives an error
07:54:02 <mauke[]> "an error". how helpful. ö_ö
07:54:54 <Pato> nevermind, I'm retarded. It was a typing error in the name of the function
07:55:13 <Pato> because it already existed one *sigh*
07:57:14 <sm> morning all.. who could I talk to about adding lambdabot to #hledger ?
07:59:16 <bennofs> sm: int-e runs lambdabot afaik
08:01:21 <sm> bennofs: thanks
08:01:34 <albeit> If I have three monadic functions like "m (Maybe a)", and I want to get the first one that returns Just, or otherwise Nothing, how would I do that?
08:02:46 <bennofs> albeit: do you want to stop running the other computations as soon as you encounter a Just? For example, would yourOperation (return (Just 3)) m be equal to 'return $ Just 3' or 'm >>= \_ -> return $ Just 3' ?
08:02:46 <mauke[]> that doesn't look like a function
08:03:00 <albeit> bennofs: Stop other computations as soon as a Just is found
08:03:20 <c_wraith> Too bad there's no Alternative -> Monoid wrapper in base yet.
08:03:28 <c_wraith> If there was, that would be a simple foldMap
08:03:50 <c_wraith> (That wrapper is being added for 7.12, I think)
08:03:52 <bennofs> albeit: you can use MaybeT's alternative instance for that I think
08:04:05 <c_wraith> yes, MaybeT's Alternative instance does that
08:04:37 <albeit> Oh interesting, thanks
08:05:39 <c_wraith> Which is why, if this was on GHC 7.12, you could do something like getAlt $ foldMap (Alt . MaybeT) [a1, a2, a3]
08:06:26 <bennofs> :t Alt
08:06:29 <lambdabot> forall (k :: BOX) (f :: k -> *) (a :: k). f a -> Alt f a
08:06:30 <bennofs> @index Alt
08:06:31 <lambdabot> Data.Monoid
08:06:39 <c_wraith> Did it make it into 7.10 then?
08:06:46 <joneshf-laptop> @help index
08:06:46 <lambdabot> index <ident>. Returns the Haskell modules in which <ident> is defined
08:06:51 <joneshf-laptop> nice
08:06:54 <c_wraith> It did.  How about that.
08:07:04 <Duozhasht> hello anyone here ?
08:07:05 <bennofs> joneshf-laptop: doesn't always work though (only for base iirc)
08:07:08 <bennofs> @index lens
08:07:08 <lambdabot> bzzt
08:07:15 <c_wraith> As of base 4.8, Alt exists
08:07:18 <joneshf-laptop> bennofs, better than nothing :)
08:07:18 <Duozhasht> LTree
08:07:37 <c_wraith> Anyway.  Alt is something I've written one-off so many times.  Nice to see it in base.
08:07:39 <mauke[]> :t let d [] = return Nothing; d (x : xs) = x >>= maybe (d xs) (return . Just) in d
08:07:42 <lambdabot> Monad m => [m (Maybe a)] -> m (Maybe a)
08:08:05 <Duozhasht> guys i have a doubt about defining de depth function as a catamorphism
08:08:10 <Duozhasht> can anyone help me ?
08:08:15 <mauke[]> s/doubt/question/
08:08:20 <bennofs> c_wraith: in this case, you use F.asum too though
08:08:24 <bennofs> :t F.asum
08:08:26 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
08:08:35 <HeladoDeBrownie> Duozhasht, ask and find out
08:09:32 <Duozhasht> I want to define depth :: LTree a -> Integer  as a camoprhism of LTree
08:09:51 <Duozhasht> atm, i have my cata define as:
08:09:53 <Duozhasht> cataLTree a = a . (recLTree (cataLTree a)) . outLTree
08:11:04 <mauke[]> nicely incomprehensible
08:11:29 <bennofs> Duozhasht: what's the type of cataLTree?
08:12:26 <mauke[]> .oO( cata 0 (succ .: max) )
08:12:28 <Duozhasht> bennofs
08:12:29 <Duozhasht> cataLTree :: (Either b (d, d) -> d) -> LTree b -> d
08:13:17 <mauke[]> :t either 0 (succ . uncurry max)
08:13:22 <lambdabot> (Enum c, Num (a -> c), Ord c) => Either a (c, c) -> c
08:14:02 <bennofs> :t either (const 0) (succ . uncurry max)
08:14:05 <lambdabot> (Enum c, Num c, Ord c) => Either b (c, c) -> c
08:17:19 <Duozhasht> Thank you mauke and bennof !
08:17:20 <Duozhasht> it worked ?
08:17:22 <Duozhasht> !
08:17:28 <supki> :t sum . fmap (succ . uncurry max)
08:17:30 <lambdabot> (Enum c, Functor t, Num c, Ord c, Foldable t) => t (c, c) -> c
08:17:37 <Duozhasht> and if i want to balance the tree on the same way ?
08:17:44 <Duozhasht> with cata again
08:21:12 <Duozhasht> bennofs are u still there ?
08:23:15 <Duozhasht> anyone here ?
08:24:00 <geekosaur> nobody here but us morphisms
08:26:17 <Geraldus> Hey pals! Can someone help with Yesod quasiquoters? 
08:27:07 <Geraldus>  I want to read Text from file. That text have some placeholders within, for example #{siteUrl}. Then I want replace that placeholders with some values. How can I do that? I tried to combine `readFile` and`st` quasiquoter from Text.Shakespeare.Text, but this not work, all placeholders are just effectively stripped.
08:27:42 <cpcpcp> hi guys
08:28:07 <KorriX> Geraldus: Quasiquoters are expanded and evaluated during the compilation, so runtime reading from file would not work
08:28:09 <cpcpcp> i want to define a function balance :: LTree a -> LTree a   as catamorphism of LTree  (cata :: (Either b (d, d) -> d) -> LTree b -> d
08:28:31 <mauke[]> hahaha
08:28:37 <Geraldus> KorriX: aha, that's right! let me think…
08:29:12 <Geraldus> KorriX: so in this case I want something similar to $(widgetFile). 
08:30:36 <KorriX> Geraldus: Look at tinytemplate from hackage
08:30:41 <bennofs> cpcpcp: there are several different ways to balance a binary tree. what do you want to implement? also, what have you tried already? where did you get stuck?
08:30:45 <Geraldus> KorriX: thank you
08:30:51 <cpcpcp> i want to define a function balance :: LTree a -> LTree a   as catamorphism of LTree  ( cata :: (Either b (d, d) -> d) -> LTree b -> d )   anyone ?
08:31:04 <cpcpcp> huum ty for responsing
08:31:08 <mauke[]> cpcpcp: you have our permission to do so
08:31:23 <cpcpcp> if i have to do it non using cata i could
08:31:36 <cpcpcp> my problem is to understand how cata works
08:32:10 <bennofs> cpcpcp: still, what kind of balance do you want? AVL tree balance? weight balanced?
08:32:20 <bennofs> cpcpcp: how would you write it without cata?
08:32:24 <mauke[]> cata replaces pattern matching + recursion
08:32:43 <mauke[]> if you can write your function using pattern matching and structural recursion, you can convert it to cata
08:33:08 <deech> Hi all,
08:34:00 <deech> I'm trying to understand what the word "observable" means in the Haskell world and coming up short. Are there any articles you could point me to?
08:35:05 <bennofs> deech: do you have some more context where the word is used?
08:37:13 <deech> Don't have anything specific right now but I've seen various comments on /r/haskell in articles. This is an example: http://www.reddit.com/r/haskell/comments/35zks5/which_free_monad/
08:37:42 <deech> "since s is existentially quantified, it can't be observed ..."
08:38:08 <monochrom> I don't think anyone defined it or discussed it at length. usually you just look at the output of a program, or look at whether a program terminates or not.
08:39:19 <deech> So is observe the same as introspect, then?
08:40:11 <c_wraith> No, observe is more theoretical.
08:40:30 <mauke[]> observe is more like have-different-outcome-depending-on
08:40:31 <deech> In this case: http://www.reddit.com/r/haskell/comments/28a2jf/monadreactive_embedded_monadic_reactiveness/, it seems as though OP uses observe to mean witness.
08:40:53 <nshepperd> in some contexts 'observable' means that a term could evaluate into a different value depending on the supposedly observable thing
08:41:13 <monochrom> for example, in the Haskell Reports, they say "using seq you can observe the difference between ⊥ and \x->⊥". this means that there exists a program in which if you use \x->⊥ you get termination, but if you replace \x->⊥ by ⊥ you get non-termination.
08:41:35 <roelof> As editor can I better go for Sublime text or can I better go for Atom ? 
08:42:35 <deech> monochrom: Oh, so observed means something like "there is a difference that can be noticed".
08:43:03 <c_wraith> well, "observe" and "notice" are pretty much synonyms..
08:43:19 <nshepperd> in the context of this reddit post case 'observe' seems to be some nontechnical usage
08:43:49 <tdammers> roelof: whatever works best for you
08:44:11 <roelof> oke, then I have to test both 
08:44:26 <deech> c_wraith: True, I thought it had some technical meaning since people seem to use the word quite a bit and I haven't seen it used in other language circles.
09:00:55 <lpaste> ysr pasted “mean function” at http://lpaste.net/132867
09:01:07 <ysr> How does that look?
09:02:12 <cryptox> hey ho
09:03:16 <cryptox> someone here wanna help me with a question :) ?
09:03:16 <cryptox> i'm beginning to learn haskell and i was wondering how to write a function with a touple that has a value multiple times. for example (a,a)->(a,a) or (a,b,b)->(b,b,a) for example
09:03:49 <johnw> I'm not quite sure what you mean
09:04:51 <cryptox> i want a function to take a touple that has the same variable multiplte times inside it and give it out in another order :)
09:05:11 <cryptox> (a,a,b) -> (a,b,a)
09:05:35 <johnw> @djinn (a,a,b) -> (a,b,a)
09:05:35 <lambdabot> f (a, b, c) = (b, c, a)
09:06:05 <cryptox> hmm but i want the function only to accept touples of the form (a,a,b)
09:06:28 <johnw> if a and b are types, that's fine
09:06:40 <johnw> if they are values, that won't work in general
09:07:07 <cryptox> ghci tells me that there's a conflict with the variable that is used more than once, in this case a :/
09:07:14 <geekosaur> yes
09:07:29 <geekosaur> you can't pattern match values that way; you must use guards
09:07:55 <johnw> heh, I didn't even think of a partial function :)
09:08:03 <HeladoDeBrownie> even if you use guards for that you will have unhandled cases. something to watch out for
09:08:07 <joneshf-laptop> or change the type and keep it total
09:08:35 <joneshf-laptop> Eq a => (a, a, b) -> Maybe (a, b, a)
09:09:27 <joneshf-laptop> ysr, well both die on large enough lists.
09:10:10 <cryptox> hmmm, so there's no way to write a function which has the type (a,a,b) -> (a,b,a) when i use the ":t" command?
09:10:20 <ysr> joneshf-laptop but you can't get a mean of a list unless you walk through the whole list
09:10:42 <HeladoDeBrownie> cryptox, that's perfectly fine as a type. lambdabot outputted an implementation of it previously
09:10:55 <bennofs> :t \(x, y, z) -> const (x,z,y) (x `asTypeOf` y)
09:10:56 <lambdabot> (b, b, t) -> (b, t, b)
09:11:08 <cryptox> ahh
09:11:17 <cryptox> thx! i think i get it now
09:11:17 <geekosaur> cryptox, you are using a and b as *values* there, not as types
09:11:27 <ion> ysr: Use foldl' instead of foldl. You can also use pattern matching instead of fst/snd.
09:11:48 <joneshf-laptop> ysr, true, but that's not the problem, see ion 's suggestion
09:12:15 <ysr> ion I don't know what is the difference between foldl' and foldl, I will look into it
09:13:31 <maerwald> one gives you a stackoverflow :P
09:14:38 <maerwald> ysr: https://wiki.haskell.org/Foldr_Foldl_Foldl%27
09:15:26 <quchen> maerwald: To be perfectly accurate, foldl won't give you the stack overflow, but it can build up a thunk that overflows when forced.
09:15:42 <ion> ysr: In fact, you might want to use foldl' and a strict pair. data Pair a b = Pair !a !b
09:15:47 <hodapp> so, with GHC.Generics and 'to', it looks like the mechanism is that I build up its representation, rather than breaking it down with 'from', and with this I can do things like invoke constructors?
09:16:28 <hodapp> I'm in the dubious situation where I have a Proxy and I'd like to be able to generically construct an object of that type (given certain constraints on the object, e.g. only certain record types where all members are in typeclass Foo)
09:18:12 <bennofs> hodapp: yes, with GHC generics, you build up the representation and then convert it to the "real" type later
09:19:54 <quchen> maerwald: foldl (+) 0 [1,2,3,...] = (((0+1)+2)+3)+..., that's a nested collection of heap-allocated closures. Forcing this big thunk will start adding, and then you get the overflow. (You can of course get a heap overflow as well if you're allocating too many closures.)
09:20:12 <int-e> Cale: do you happen to know why @seen was disabled in lambdabot (this happened ages ago, I don't really know who was operating the bot at the time)?
09:20:30 <quchen> int-e: Wasn't it preflex that did @seen?
09:20:45 <SrPx> No instance for (GVector.Vector UVector.Vector a) -- why is GHC giving me this? Isn't UVector an instance of GVector? "import qualified Data.Vector.Generic as GVector; import qualified Data.Vector.Unboxed as UVector"
09:20:49 <int-e> quchen: that was after it was disabled in lambdabot.
09:20:52 <maerwald> anyone else having trouble installing cairo? http://lpaste.net/132868
09:21:07 <hodapp> bennofs: also! I had a quote from you days ago: 2015-05-06 12:39:56 bennofs hodapp: with generics, you can even generate your own type errors at compile time!
09:21:19 <hodapp> bennofs: have you any further information on this?
09:21:33 <ion> ysr: foldl' will force the tuple constructor at every iterator but you're still growing large unevaluated expressions as tuple members. A strict pair will evaluate the members when foldl' evaluates the constructor.
09:22:42 <SrPx> nevermind, needed an unbox constraint. 
09:22:43 <SrPx> :)
09:23:20 <bennofs> hodapp: You can abuse ConstraintKinds to do that 
09:23:46 <bennofs> hodapp: see https://github.com/bennofs/hsqml-react/blob/36cc69fb3a3099ae320557e799da8007527888c2/src/Graphics/QML/React.hs#L459
09:24:20 <bennofs> hodapp: https://github.com/bennofs/hsqml-react/blob/36cc69fb3a3099ae320557e799da8007527888c2/src/Graphics/QML/React.hs#L278 has an example of the kind of error generated from this
09:25:07 <hodapp> bennofs: thanks! 
09:25:45 <geekosaur> IIRC @seen did not work right and could not be fixed at the time. one issue was that a join/part was recorded and erased the last thing someone was known to have said
09:26:19 <arbelos> I want to upload documentation to Hackage "manually", for some reason the docs are not building.. I am not sure what format it expects however. Does anyonen know?
09:26:37 <geekosaur> they probably need to be accounted/stored separately; I don't know if there is any fundamental issue in doing it right
09:28:19 <zipper> jle`: Hey are you around?
09:28:32 <hodapp> johnw: see bennofs's reply above. You had asked about the same when I looked for him earlier.
09:28:44 <johnw> thanks
09:31:44 <nshepperd> this QObjectDerivingError stuff is awfully devious
09:32:07 <hodapp> QObjectDerivingError? something Qt related?
09:32:36 <int-e> geekosaur: hmm. lambdabot's userstatus type ( http://lpaste.net/132869 ) looks a bit ad-hoc indeed, which might explain that.
09:32:40 <zipper> :t arr
09:32:41 <lambdabot> Arrow a => (b -> c) -> a b c
09:32:54 <zipper> Could someone please tell me how that function works?
09:33:32 <geekosaur> @src Arrow
09:33:32 <lambdabot> class Arrow a where
09:33:32 <lambdabot>     arr, pure :: (b -> c) -> a b c
09:33:32 <lambdabot>     (>>>)     :: a b c -> a c d -> a b d
09:33:32 <lambdabot>     first     :: a b c -> a (b,d) (c,d)
09:33:32 <lambdabot>     second    :: a b c -> a (d,b) (d,c)
09:33:34 <lambdabot>     (***)     :: a b c -> a b' c' -> a (b,b') (c,c')
09:33:36 <lambdabot>     (&&&)     :: a b c -> a b c'  -> a b (c,c')
09:33:43 <geekosaur> it works how the Arrow instance says it works
09:33:53 <geekosaur> and it is in some sense a "constructor" for an Arrow
09:33:53 <nshepperd> hodapp: the cunning trickery bennofs is using to generate custom type errors at compile time
09:34:01 <geekosaur> turning a function into an arrow
09:34:19 <ion> “pure :: (b -> c) -> a b c”
09:34:36 <zipper> geekosaur: I know anothing about arrows
09:34:59 <hodapp> nshepperd: ohhhh
09:35:04 <geekosaur> I suspect that means any answer would be meaningless to you...
09:35:07 <zipper> ion: that pure doesn't seem to give back an applicative
09:35:19 <int-e> geekosaur: anyway thanks for the information!
09:35:19 <zipper> geekosaur: I guess so. NVM
09:35:25 <geekosaur> https://wiki.haskell.org/Arrow_tutorial
09:36:19 <geekosaur> keep in mind arrows predate applicative, and turned out to have limited usefulness (`arr` being one of the sticking points); the useful generalizations are Applicative and Control.Category
09:36:46 <bennofs> nshepperd, hodapp, johnw: I must mention this wasn't my idea ... I actually learned the trick using ConstraintKinds from merijn I think (https://gist.github.com/merijn/6130082)
09:37:41 <zinfandel> Are there any haskell parsers besides haskell-src(-exts)?
09:37:50 <bennofs> zinfandel: you can use the ghc api
09:38:16 <bennofs> zinfandel: but it's much harder to use than hs-src-exts
09:39:04 <learns> Can this output anything?: iterate f 0 x = x
09:39:45 <zinfandel> bennofs: Hmm. I need it in ghcjs, not sure if that would be possible
09:41:02 <learns> What is it trying to tell me? http://gyazo.com/8700a52ec5dc1d08f713af28981e66fe
09:41:23 <zipper> geekosaur: No I don't see where the a comes from after we put in a (b -> c)
09:41:40 <geekosaur> a is the Arrow instance
09:42:07 <geekosaur> it is "created" from the function (b -> c)
09:42:24 <maisumpatocp> anyone here to talk about balance an LTree ?
09:42:41 <maerwald> only if it's an anaLTree :P
09:42:47 <geekosaur> so arr is giving you an Arrow (a) created from the function (b -> c)
09:43:05 <geekosaur> to know what it is, you have to pick an Arrow instance and see how it implements Arrow
09:43:37 <maisumpatocp> oh analTree seems fine :p
09:44:03 <geekosaur> just as `return` or `pure` is not particularly meaningful without looking at the Monad or Applicative instance that defines it
09:44:08 <zipper> geekosaur: So we preserve the imput b instead of just getting (b -> c) ->  a c
09:44:29 <zipper> *input
09:44:30 <geekosaur> huh?
09:45:19 <geekosaur> (a b c) is a type where a is an Arrow and b and c are the things it's parameterized on. for the function Arrow, (a b c) represents (b -> c)
09:45:56 <geekosaur> other Arrows are possible; they are :"functions" in some abstract sense, but not necessarily Haskell functions (b -> c)
09:46:35 <geekosaur> if it helps, think of the Arrow instance as being (a b c) === ((->) b c) (which is (b -> c) written in prefix form)
09:47:07 <geekosaur> (this failure to generalize functions properly is why `arr` is considered one of the warts of Arrow)
09:52:55 <nshepperd> 'arr' is just too powerful for many purposes
09:53:15 <hodapp> too powerful?
09:53:51 * hackagebot uri-bytestring 0.1.1 - Haskell URI parsing as ByteStrings  http://hackage.haskell.org/package/uri-bytestring-0.1.1 (MichaelXavier)
09:55:40 <nshepperd> it lets you lift any function (b -> c) to a b c
09:55:51 <Newb_> Hey guys, I'm new to this, but I was planning on writing a cpu emulator in Haskell
09:56:02 <Newb_> and I'm using STRefs for each of the registers
09:56:16 <Newb_> but I read somewhere that I should be using "Applicative style"
09:56:19 <nshepperd> which doesn't work if you want to restrict your type to something like 'functions that have a derivative'
09:56:23 <Cale> The problem with arr isn't just the fact that it's powerful, it's the fact that you *must* use it for many operations
09:57:00 <hodapp> Cale: what do you mean?
09:57:09 <Cale> One seeming advantage that Arrow has over Monad as a pattern of abstraction is that both of the arguments to (>>>) are of a type that you have control over
09:57:32 <Cale> While the right hand argument to (>>=) will always be a function and there's no way to inspect functions apart from applying them
09:57:39 <johnw> did AMP weaken functions to Applicative where applicable?
09:58:01 <Cale> So it's basically impossible to do analysis of a computation written in a monadic style before you begin to execute it
09:58:08 <a[0]> why does "instance Monad ((->) r)" define "f >>= k = \ r -> k (f r) r" and not "\r -> k (f r)" ?
09:58:23 <Cale> Whereas with Arrow, there's some hope that maybe you can do some analysis to simplify computations before executing them
09:58:40 <Cale> However, every occurrence of arr is going to be essentially a black box to analysis
09:58:46 <johnw> a[0]: because k (f r) returns a function that wants an r
09:58:56 <joneshf-laptop> a[0], what is the type of `\r -> k (f r)`?
09:59:08 <Cale> But on the other hand, Arrow doesn't give you many of the operations which you'll need to wire results of computations around without using arr
09:59:53 <nshepperd> right, things like 'a (b, c) (c, b)' can't be done without 'arr swap'
09:59:59 <nshepperd> and so on
10:00:01 <Cale> exactly
10:00:15 <a[0]> I guess this stems from the fact that >>= returns "m b", and for (->) that means "((->) b)" aka "something -> b"
10:00:33 <a[0]> perhaps what I'm looking for is just "flip (.)"? Is there a better name for this?
10:01:03 <Cale> and if you use the proc/do notation (which is nonetheless very attractive, almost to the point of necessity), there will be an 'arr' in between every pair of lines of your code, pretty much defeating any meaningful analysis you can do
10:02:09 <nshepperd> a[0]: the monad is '(->) r' here, so 'm b' is '(->) r b' is 'r -> b'
10:02:10 <Cale> When we were working on our game at iPwn, introducing a custom preprocessor for proc/do notation (along with our own definition for the Arrow type class which brought it more in line with the definition of a symmetric monoidal category) made the game run 4 to 6 times faster just on its own
10:03:17 <joneshf-laptop> a[0], in light of the arrow talk, `(>>>)`
10:03:38 <joneshf-laptop> or i guess taht's category talk ;)
10:04:20 <a[0]> ah, lovely
10:05:50 <hodapp> I feel like I read a lot of this in http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf (Idioms are oblivious, arrows are meticulous, monads are promiscuous) but didn't attempt to apply it in any real code
10:09:21 <lcfrs> is killThread/throwTo guaranteed to not block indefinitely on FFI calls marked "interruptible"?
10:22:39 <c_wraith> lcfrs: no.  throwTo/killThread to thread blocked indefinitely in an FFI call will also block indefinitely.
10:23:53 * hackagebot jmacro-rpc-happstack 0.3.2 - Happstack backend for jmacro-rpc  http://hackage.haskell.org/package/jmacro-rpc-happstack-0.3.2 (GershomBazerman)
10:23:55 * hackagebot memory 0.1 - memory and related abtraction stuff  http://hackage.haskell.org/package/memory-0.1 (VincentHanquez)
10:27:16 <lcfrs> c_wraith: "interruptible behaves exactly as safe, except that when a throwTo is directed at a thread in an interruptible foreign call, an OS-specific mechanism will be used to attempt to cause the foreign call to return"
10:27:21 <lcfrs> https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/ffi.html#ffi-interruptible
10:27:47 <lcfrs> that suggests that a blocked ffi should return, no?
10:27:50 <c_wraith> lcfrs: it will attempt.  There's no guarantee it will succeed.
10:28:16 <lcfrs> i see
10:28:28 <lcfrs> so if a sigpipe is able to unblock it, then it should return, otherwise not
10:29:09 <m4lvin> can i get ghc to understand  #include "FOO.lhs" and also run unlit on the included .lhs file?
10:30:01 <c_wraith> m4lvin: doubtful.  you should probably just import it
10:31:12 <m4lvin> hm, that's what i was trying to avoid ;-)
10:31:39 <c_wraith> Why's that?
10:32:09 <m4lvin> i am looking for a nice way to have two modules which only differ in their imports
10:32:38 <m4lvin> the rest of the code is exactly the same but some types and functions are given by other modules
10:33:02 <m4lvin> so i wanted to put the big shared part in one file.
10:33:12 <m4lvin> and well, all of this is lhs.
10:35:31 <m4lvin> but then GHC only runs unlit on the toplevel file, i guess.  would template haskell be a better way?
10:36:26 <c_wraith> No.  Template Haskell can't affect imports.
10:39:37 <quchen> c_wraith: Interesting. Do you know why? Because imports have to be parsed before the body can be processed?
10:46:49 <bennofs> quchen: I guess it would make the stage restriction even more confusing. Imports need to be parsed to determine the dependencies when compiling multiple modules
10:47:25 <bennofs> quchen: and it would sometimes require new modules to be compiled after TH has been processed that wouldn't have been compiled before the TH was run
10:47:39 <quchen> Makes sense.
10:47:59 <jle`> zipper: what's up?
10:48:00 <quchen> I also fear the ad-hoc SML modules this might create.
10:48:24 <SrPx> How do I write this correctly? "class (Foldable f, Integral a) => GridIndex (f a) where" ?
10:48:35 <bennofs> SrPx: use a newtype
10:48:43 <SrPx> uhm?
10:49:37 <bennofs> SrPx: well, if you don't want to make any other instances like GridIndex (Foo Bar) (for concrete Foo and Bar), then you can write it just as you did?
10:49:46 <mauke> SrPx: GridIndex f a maybe
10:50:39 <SrPx> But I get "Unexpected type ‘f a’"
10:51:04 <SrPx> ref. http://lpaste.net/132872
10:52:13 <bennofs> SrPx: oh sorry, I just saw that you want class instead of instance 
10:52:22 <SrPx> ah okay
10:52:35 <hodapp> hrm, if I am making use of the 'to' function in GHC.Generics, what is constraining the sort of representation that I create? I'm just trying to think of how this works if I am trying to, er, construct the right constructor
10:53:15 <hodapp> I suppose the auto-generated definitions will cause some compile-time errors
10:55:02 <a[0]> is there something like >>> that works sort of like <$> when dealing with Maybe values? basically I want (a -> Maybe b) -> (b -> Maybe c) -> (a -> Maybe c)
10:55:33 <quchen> Does GHC ever GC top-level values? Suppose I have a CAF that needs a lot of memory when forced, any I need it at two parts of my program that are far apart from each other (in time). Or is there even some way to force GC of a value?
10:55:58 <quchen> The latter probably isn't possible, since that would mean overwriting a value with a new closure that doesn't provably do the same thing
10:56:03 <kirill`> :t (>=>)
10:56:04 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
10:56:32 <bitemyapp> quchen: it'll deallocate the values the CAF refers to if they're never going to be used again
10:56:35 <a[0]> ah cool, thanks
10:57:29 <quchen> bitemyapp: Sure, that's ordinary GC. But what I mean is when a large CAF is held in memory without any access to it for a long time, it might be beneficial to GC it for the time being, and re-evaluating it once it is required again.
11:00:16 <bitemyapp> quchen: I don't think it does anything like this, but I'm no expert: https://ghc.haskell.org/trac/ghc/browser/ghc/rts/sm/Storage.c
11:01:26 <user1_> why, 
11:01:33 <user1_> (wrong channel, sorry)
11:02:02 <hodapp> because Haskell!
11:03:14 <johnw> [0987654321`
11:07:58 <johnw> (wrong channel, sorry) sounds like Lisp
11:08:34 <nkartash_> hi, everyone! I have seen the discussion on haskell-cafe mailing list about improving the security of hackage but it died off aroun 5th of May, has it really died or just moved somewhere?
11:08:58 <johnw> nkartash_: there's a blog post on fpcomplete.com that might be relevant
11:09:11 <Vektorweg1> i'm a bit confused. the Network "high-level" interface is deprecated. what else should i use? 
11:12:05 <frerich> Is there a way to splice a Q [Dec] (e.g. as produced by Data.Aeson.TH.deriveJSON) directly in ghci? I can't see a way to get a Q Exp for some Q [Dec], I wonder wether it's possible to splice a list of declarations at all.
11:12:25 <nkartash_> johnw: could you send me a link to it?
11:12:48 <johnw> go to fpcomplete.com, click on the Blog link
11:13:12 <johnw> note that it's somewhat stackage specific
11:13:29 <johnw> but it grew out of that discussion I believe
11:13:53 <nkartash_> thanks, sorry for my silliness)
11:18:11 <mjrosenb> can I ask cabal to open the documentation for a module in a browser?
11:25:41 <ReinH> mjrosenb: not afaik, but you can open open ~/.cabal/share/doc/frames.html in a browser
11:26:25 <pantsman-> mjrosenb, I use this hack because I couldn't find anything better, sadly: https://gist.github.com/bmjames/b7503a166fdb4964df0c
11:33:56 * hackagebot haskellscript 0.1.0.1 - Command line tool for running Haskell scripts with a shebang.  http://hackage.haskell.org/package/haskellscript-0.1.0.1 (seanparsons)
11:44:10 <hodapp> is Proxy a -> a considered some form of reification?
11:44:26 <hodapp> I'm naming things and wanting them to not totally mangle a term.
11:48:57 * hackagebot rasterific-svg 0.2.2 - SVG renderer based on Rasterific.  http://hackage.haskell.org/package/rasterific-svg-0.2.2 (VincentBerthoux)
11:50:58 <statusfailed> What's a good name for a parameter that's a function of type :: Num a => a -> a -> a
11:51:03 <statusfailed> (it's either (+) or (-))
11:51:29 <bennofs> statusfailed: (+) ? :p
11:51:34 <user1_> binop
11:52:01 <user1_> for binary operator
11:52:28 <statusfailed> user1_: I want to use it inline
11:52:34 <statusfailed> bennofs: i was thinking (+-) :p
11:53:16 <user1_> oh. that's a lot harder :P
11:53:49 <statusfailed> I wanted to use <> but that's probably bad :D
11:53:54 <user1_> +/-
11:53:57 * hackagebot elocrypt 0.3.2 - Generate easy-to-remember, hard-to-guess passwords  http://hackage.haskell.org/package/elocrypt-0.3.2 (sgillespie)
11:53:59 * hackagebot svg-tree 0.3.1 - SVG file loader and serializer  http://hackage.haskell.org/package/svg-tree-0.3.1 (VincentBerthoux)
11:54:56 <statusfailed> user1_: DEAL
11:55:18 <statusfailed> bikeshedding complete
11:55:49 <bennofs> > let (+/-) = (++) in "does this " +/- "really work??"
11:55:51 <lambdabot>  "does this really work??"
11:56:09 <user1_> statusfailed: lol
12:06:34 <aupiff> is sparse-lin-alg the only option for sparse matrix storage in haskell?
12:06:51 <aupiff> storage / manipulation / computation
12:09:43 <Denommus> can anyone help me make this code more readable? https://gist.github.com/Denommus/817e5a925f058ca31a67
12:11:25 <monochrom> I wonder if you need Leaf. "Node 4 []" plays the same role as "Leaf 4"
12:12:58 <monochrom> it looks ok
12:13:14 <Denommus> really? Can you know what it does by looking at it?
12:14:52 <monochrom> yes, but I'm too lazy to write.
12:15:59 <ReinH> Denommus: I'd replace (if curr==X then O else X)  with flip X = O; flip O = X
12:17:34 <Denommus> ReinH: that's a good idea
12:17:38 <mgomezch_> careful with flip!  that might run into the one that flips function arguments
12:17:41 <mgomezch_> :t flip
12:17:43 <lambdabot> (a -> b -> c) -> b -> a -> c
12:17:47 <ReinH> ok, flipPiece or something
12:18:20 <Welkin> how about flipp
12:18:37 <int-e> other X = O
12:18:58 * hackagebot diversity 0.6.3.0 - Return the diversity at each position for all sequences in a fasta file  http://hackage.haskell.org/package/diversity-0.6.3.0 (GregorySchwartz)
12:19:04 <Welkin> Denommus: it looks like you have some imperative programming baggage
12:19:08 <Denommus> mgomezch_: I called it flipMark
12:19:12 <Welkin> pattern matching is amazing, please use it
12:19:22 <Denommus> I just updated it
12:19:51 <ReinH> if you don't use it, someone else will
12:20:13 <Denommus> removed all the "ifs"
12:21:28 <quchen> Denommus: This might be a start. The main problem remains, and that's I don't understand what the functions are supposed to do without understanding their code. Neither the names nor the types tell me all too much. http://lpaste.net/132878
12:21:47 <quchen> I guess it's some sort of tic tac toe. 90% sure.
12:22:29 <Denommus> quchen: it generates the whole decision tree for a tictactoe game, and I can provide a maximum recursion depth
12:22:31 <mgomezch_> the filename is a bit of a giveaway ;)
12:23:22 <Denommus> though I'm not removing games where there's already a winner
12:25:31 <ReinH> Denommus: it's easier with out a leaf case
12:26:16 <kirill`> Isn't the way foldr keeps accumulating a list a bit like scanr? Also, foldr (boardSingle i) [] zipped seems to be doing map.
12:27:37 <ReinH> I did something like gameTree board = Node board (nextBoards board) where nextBoards = map gameTree. possibleMoves
12:27:49 <ReinH> it's super easy with explicit recursion so I didn't bother with unfolds or scans
12:27:51 <Denommus> ReinH: trying without it
12:28:22 <Denommus> kirill`: it's not map
12:28:32 <Denommus> kirill`: at most, flatMap
12:30:01 <ReinH> Denommus: notionally, the gametree is created from the current board position by bulding the gametrees for each possible move from the current position, recursively.
12:30:16 <Denommus> kirill`: no, wait, you're right
12:30:34 <Denommus> ReinH: that's what I'm trying to do
12:32:01 <kirill`> Denommus: I found the foldr's a bit tricky to figure out, tbh, so I can't be sure if I got it right without running the code. Anyway, I think it duplicates something, not sure what exactly.
12:32:59 <Denommus> ReinH: ah, I understood your suggestion
12:33:03 <Denommus> ReinH: gonna give it a try
12:34:12 <quchen> jle`: Haskell myth busters eh?
12:34:27 <subleq> http://hackage.haskell.org/package/hyperloglog-0.3.1/docs/Data-HyperLogLog.html
12:34:37 <subleq> what does the type HyperLogLog $(3) mean?
12:37:35 <ReinH> Denommus: without the leaf condition, you don't need a special case for when possibleMoves is []
12:37:39 <ReinH> er, leaf constructor
12:37:52 <ReinH> you just get a node without empty children
12:37:57 <ReinH> s/with/without
12:38:04 <ReinH> heh, sorry
12:40:20 <dfeuer> Where did edwardk play around with various classes for categories? I can't seem to find the package. 
12:41:35 <subleq> The only place I've seen that syntax is with template haskell which I don't think would do anything interesting with just a number
12:43:05 <Tuplanolla> Maybe category-extras, dfeuer?
12:43:13 <dfeuer> Tuplanolla, not as far as I can tell :/
12:44:53 <Tuplanolla> Did you check these: http://dmwit.com/category-extras/dependencies-1.0.2.png
12:46:44 <supki> dfeuer: https://github.com/ekmett/hask. probably?
12:46:53 <SrPx> > fmap (foldr (++) "" . map show . map fromEnum) $ mapM (const (randomIO :: IO Bool)) [0..64]
12:46:55 <lambdabot>  <IO [Char]>
12:47:01 <SrPx> Thanks
12:47:58 <dfeuer> supki, that's exactly what I was looking for.
12:48:10 <dfeuer> Thanks.
12:53:27 <byorgey> subleq: hmm, I don't know either.  I expect it is a type-level natural number (https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-level-literals.html)  but I didn't think those needed the $( )
12:54:36 <quchen> Maybe there's an orphan instance for Num ExpQ somewhere?
12:55:10 <quchen> That wouldn't fit  Edward's style though
12:55:10 <patodecp> hi there
12:55:15 <JohnBovril> guys
12:55:23 <JohnBovril> I'm stonewalling pretty hard here
12:55:23 <patodecp> anyone here could help me in catamorphism's ?
12:56:12 <quchen> ?where justask 
12:56:13 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
12:56:31 <JohnBovril> I've started out with early chapters of LYAH and then gone on to http://www.seas.upenn.edu/~cis194/spring13/lectures.html
12:56:50 <JohnBovril> and then from there read early chapters of real world haskell
12:57:05 <JohnBovril> I think I actually got the list comprehensions from LYAH
12:57:09 <JohnBovril> but
12:57:34 <JohnBovril> the upenn 'exercise' for week 1 is insanely beyond me
12:57:45 <JohnBovril> but even the excerise from real world haskell is:
12:57:57 <JohnBovril> 	
12:57:57 <JohnBovril> Write a function lastButOne, that returns the element before the last.
12:58:10 <JohnBovril> I've read these chapters
12:58:21 <JohnBovril> then it says that and it stumps me the hell up
12:59:00 * hackagebot rasterific-svg 0.2.2.1 - SVG renderer based on Rasterific.  http://hackage.haskell.org/package/rasterific-svg-0.2.2.1 (VincentBerthoux)
12:59:04 <quchen> JohnBovril: How would you get the (very) last element of a list?
12:59:18 <JohnBovril> lastButOne x = last (init x)
12:59:48 <mauke> heh
12:59:51 <JohnBovril> that's how far I got
12:59:53 <JohnBovril> but
13:00:01 <JohnBovril> I'm supposed to define all the crashes first
13:00:09 <JohnBovril> like passing an empty list []
13:00:10 <JohnBovril> and so on
13:00:20 <JohnBovril> I have no idea how to make that work
13:00:26 <Tuplanolla> Try expanding the definitions of init and last, JohnBovril.
13:00:28 <maerwald> JohnBovril: do explicit recursion first, not implicit
13:00:29 <JohnBovril> when it's :: [a] -> a
13:00:40 <Tuplanolla> It should give you some ideas.
13:00:59 <JohnBovril> damned if I can get my head around recursion
13:01:01 <patodecp> how can i define a balance LTree function (balance :: LTree a -> LTree a )  as a catamorphism of LTree (cataLTree :: (Either b (d, d) -> d) -> LTree b -> d )
13:01:39 <maerwald> JohnBovril: that's why you have to start with explicit recursion, not the stuff people show you here :)
13:01:51 <mauke> JohnBovril: you have to start with the shape of the type (lists in this case)
13:01:52 <byorgey> patodecp: is this a homework problem?  Or just something you are trying to figure out for yourself?
13:02:00 <mauke> JohnBovril: do you know how lists are defined?
13:02:13 <mauke> byorgey: homework
13:02:26 * quchen votes for mauke to explain, instead of 4 people at once
13:02:27 <mauke> we've had like half a dozen people in here asking the same question
13:02:39 <JohnBovril> mauke, not 100%
13:02:50 <JohnBovril> :t ]
13:02:52 <lambdabot> parse error on input ‘]’
13:02:56 <JohnBovril> :t []
13:02:58 <lambdabot> [t]
13:03:12 <patodecp> mauke: kinda both, it's an homework and i want to unterstand aswell
13:03:15 <mauke> not actually valid syntax: data [] a = [] | (:) a ([] a)
13:03:30 <patodecp> *understand
13:03:34 <mauke> renamed: data List a = Nil | Cons a (List a)
13:04:25 <mauke> that means: a value of type 'List T' is either Nil or Cons x y (where x is of type T and y is of type List T)
13:04:53 <mauke> so list processing functions have to handle those two cases
13:05:08 <JohnBovril> I'm not sure how I've read the chapters of these resources
13:05:23 <mauke> next step would be writing length :: List a -> Int, I guess
13:05:30 <JohnBovril> because, right now, I feel like nothing went in :S
13:07:07 <codygman> Trying to generate a Show instance for `data Expr f = In (f (Expr f))` I've ran into a few errors and don't know what to do next: http://lpaste.net/132879
13:08:17 <dfeuer> length = foldl' (const . (1 +)) 0
13:08:42 <patodecp> :t sum
13:08:43 <lambdabot> (Num a, Foldable t) => t a -> a
13:09:45 <dfeuer> last = foldl (const id) undefined
13:11:13 * dfeuer offers JohnBovril some frozen fish.
13:11:35 <JohnBovril> :(
13:12:08 <JohnBovril> if a function is :: [a] -> a I do not know what to do for function [] = ?
13:12:18 <dfeuer> No fishcicle for you? How about a fish milkshake, or some fish-eye stew?
13:12:38 <JohnBovril> as long as it's responsibly farmed
13:12:48 <dmj`> JohnBovril: is there a contraint on the variable a? If so that could help
13:12:48 <dfeuer> Excellent.
13:12:56 <dmj`> :t sum
13:13:00 <lambdabot> (Num a, Foldable t) => t a -> a
13:13:08 <JohnBovril> :t [a]
13:13:10 <lambdabot> [Expr]
13:13:16 <quchen> JohnBovril: Right, you cannot write a function of type `[a] -> a` that is well-behaved when the input list is empty (since you can't create a value of type `a` from thin air).
13:13:29 <dolio> Someone somewhere needs to increase their office hours.
13:13:36 <JohnBovril> hm okay I didn't know that
13:13:42 <dfeuer> dolio, would that someone be you?
13:13:55 <dolio> No.
13:13:57 * dfeuer would like to pop in on dolio's office hours.
13:14:27 <johnw> dolio has exactly one office hour, but he is so efficient, he still hasn't used all of it yet
13:15:06 <dfeuer> johnw, he must be quite a teacher in that case.
13:15:15 <mauke> JohnBovril: function [] = error "my emperor, I've failed you"
13:15:27 <dfeuer> mauke++
13:15:32 <JohnBovril> legit?
13:15:34 <mauke> :t error
13:15:36 <lambdabot> [Char] -> a
13:15:50 <dfeuer> JohnBovril, no, it's not legit, but there is no legit function with that type.
13:15:57 <mauke> it's legit
13:16:15 <dfeuer> So the practical sorts take it, and others work around the problem somehow or other.
13:16:27 <S11001001> codygman: the easiest is probably to write instance Show1 f => Show (Expr f).  Show1 is 
13:16:32 <dfeuer> (See, for example, the NonEmpty type somewhere in the semigroups package)
13:16:53 <dfeuer> head : NonEmpty a -> a    is entirely legit.
13:17:16 <dfeuer> Sometimes, though, there's no way to avoid partiality in Haskell.
13:17:19 <dfeuer> Or no good way.
13:17:57 <S11001001> codygman: https://hackage.haskell.org/package/transformers-0.4.3.0/docs/Data-Functor-Classes.html
13:18:07 <codygman> S11001001: Thanks
13:19:01 * hackagebot Saturnin 0.1.0.2 - Saturnin CI / Job System  http://hackage.haskell.org/package/Saturnin-0.1.0.2 (yac)
13:19:30 <jle`> quchen: I realize it's a bit if a misnomer because it doesn't do any experiments to test things :)
13:19:36 <jle`> *of
13:20:46 <quchen> I'll let that slide for now
13:22:03 <codygman> Can I install transformers 0.4.3.0? I'm on ghc 7.8.3, isn't it stuck on transformers 3.0.0? I tried adding transformers==0.4.3.0 to my cabal file and get: Could not find module ‘Data.Functor.Classes’ Perhaps you meant Data.Functor.Compose (from transformers-0.3.0.0)
13:22:17 <codygman> I'm in a sandbox btw
13:23:21 <jle`> can we DeriveProfunctor?
13:23:45 <JohnBovril> is there a way to supress the join/leave messages in mirc?
13:23:53 <dolio> You could, if someone wrote it.
13:24:55 <dolio> Although some cases would require arbitrary decisions.
13:25:42 <jle`> my clint suppresses them unless the person talks within a given window before or after
13:25:48 <jle`> my clint does and also my client
13:25:52 <mauke> people still use mirc?
13:26:18 <geekosaur> http://forums.mirc.com/ubbthreads.php/topics/245566/hide_joins_parts_etc ?
13:27:58 <jle`> quchen: it would be interesting if someone actually did an empirical "haskell mythbusters"
13:28:10 <jle`> but i'm not sure what myths there are to bust, really, besides performance ones
13:28:30 <quchen> jle`: Time to learn for new developers
13:28:40 <quchen> Requirement to have studied math
13:28:44 <johnw> Suitability for most tasks
13:28:51 <quchen> Requirement to have an interest in math
13:28:58 <johnw> It being practical at all, in fact
13:29:02 * hackagebot fb 1.0.10 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-1.0.10 (FelipeLessa)
13:29:02 <johnw> I run into that myth a lot
13:29:07 <jle`> "empirical"
13:29:09 <jle`> :P
13:29:21 <Tuplanolla> Having too much syntax is one I see a lot.
13:29:44 <johnw> "Oh, Haskell is that research language right?  What do you do with that?"
13:29:46 <quchen> That one is new for me.
13:29:54 <johnw> I hear too much syntax a lot too
13:30:26 <quchen> let case where lambda patterns data/newtype/type … did I forget something?
13:30:54 <johnw> no, it looks like it has a lot of syntax
13:31:02 <johnw> people don't realize they're just operators from libraries
13:31:02 <jle`> guards, sections, operators
13:31:13 <jle`> and if you enable commonly used extensions you get things like ViewPatterns
13:31:17 <jle`> type families
13:31:20 <Tuplanolla> It looks like Perl to many.
13:31:20 <jle`> if that counts as syntax
13:31:33 <jle`> i do agree that haskell has a lot of sugar
13:31:47 <luzie> unfamiliar syntax is hard to read
13:31:50 <quchen> To be fair, data [] a = [] | (:) a [a] *does* look like Perl.
13:32:11 <jle`> record syntax
13:32:26 <jle`> but i guess when people say "lots of syntax", tehy're comparing it to something like scheme
13:32:34 <jle`> which isn't really fair to compare, for any language, heh
13:32:44 <jle`> scheme syntax only has ( and )
13:32:58 <jle`> you could probably implement ) as a macro
13:33:04 <quchen> :>
13:33:15 <quchen> Unary encoding of programs
13:33:29 <Tuplanolla> Scheme implementations are another thing. They tend to come with massive reader facilities.
13:34:25 <Tuplanolla> Example: http://wiki.call-cc.org/man/4/Non-standard%20read%20syntax
13:40:24 <dolio> It's not really accurate to say that scheme's only syntax is ( and ), even in the abstract.
13:40:46 <dolio> The syntax is tree shapes.
13:41:15 <jle`> was trying to make a joke :)
13:44:18 <meoblast001> (;o_o)
13:44:21 <meoblast001> do i need happy to build happy?
13:44:28 <meoblast001> and if i can't get a happy build, what do i do?
13:45:25 <dolio> You don't need happy to build happy, unless by that you mean that you don't have ghc, and need happy to build ghc.
13:45:34 <dolio> But you also need ghc to build ghc.
13:45:36 <meoblast001> i do have ghc
13:45:49 <meoblast001> Preprocessing executable 'happy' for happy-1.19.5...
13:45:50 <meoblast001> setup: The program happy is required but it could not be found
13:46:12 <breadmonster> meoblast001: Are you compiling from source or installing via package?
13:46:18 <meoblast001> this is from cabal
13:47:11 <Tuplanolla> Do you have it in your PATH, meoblast001?
13:47:21 <meoblast001> cabal or happy?
13:47:27 <meoblast001> oh great... updating GHC broke my yum
13:47:33 <fragamus> There is some buzz about TLA+ and I wanted to ask if haskellers use it
13:47:36 <breadmonster> meoblast001: I just created a sandbox and installed happy to it.
13:47:42 <meoblast001> it looks like i have a lot of problems to fix
13:47:51 <breadmonster> meoblast001: You're running Fedora?
13:47:53 <ackthet> meoblast001: sounds like you have more serious issues
13:47:58 <meoblast001> i switched to fedora
13:48:00 <meoblast001> recently
13:48:12 <breadmonster> How exactly did it break your yum?
13:48:21 <meoblast001> i installed from this repository called petersen
13:48:25 <meoblast001> which is supposed to have updated GHC packages
13:48:30 <meoblast001> now i have dependency conflicts everywhere
13:49:03 * hackagebot snap 0.14.0.4 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.14.0.4 (DougBeardsley)
13:50:43 <fragamus> or if not TLA+ then what
13:50:59 <breadmonster> fragamus: what's TLA+?
13:51:20 <breadmonster> Okay, formal verification.
13:51:24 <fragamus> some proof system
13:53:18 <ackthet> meoblast001: so what you're saying is petersen broke yum :P
13:53:37 <ackthet> 3rd party repos are very dangerous, use with extereme care
13:53:39 <ackthet> imo
13:53:40 <breadmonster> meoblast001: What ghc package did you want from petersen?
13:54:03 * hackagebot presto-hdbc 0.1.0.3 - An HDBC connector for Presto  http://hackage.haskell.org/package/presto-hdbc-0.1.0.3 (thomasjm)
13:54:05 * hackagebot esqueleto 2.2.2 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-2.2.2 (FelipeLessa)
13:54:07 * hackagebot extra 1.2 - Extra functions I use.  http://hackage.haskell.org/package/extra-1.2 (NeilMitchell)
13:54:13 <meoblast001> breadmonster: GHC itself
13:54:21 <breadmonster> Yeah which version?
13:54:30 <meoblast001> 7.8 or higher
13:55:21 <meoblast001> okay i deleted my GHC
13:55:26 <breadmonster> Yeah, I think Fedora repos only have 7.6
13:55:40 <breadmonster> meoblast001: What PC are you running?
13:55:48 <meoblast001> what do you mean?
13:56:16 <breadmonster> If your PC is fast enough, you can just compile GHC 
13:56:21 <meoblast001> oooh
13:56:25 <meoblast001> it's a lenovo laptop from a few years ago
13:56:27 <meoblast001> E420
13:56:36 <breadmonster> Well, mine took me all of 20 minutes.
13:56:42 <breadmonster> meoblast001: How many cores?
13:56:47 <napping> breadmonster: why do that instead of getting a binary?
13:56:49 <meoblast001> 2
13:56:50 <Hijiri> you can download an already compiled GHC from the ghc site
13:56:58 <Hijiri> page
13:57:11 <ion> Installing GHC and Cabal under the home directory https://gist.github.com/ion1/2815423
13:57:17 <breadmonster> napping: I couldn't find a binary for Fedora that was 7.8
13:57:34 <Hijiri> breadmonster: you can use the generic binary
13:57:36 <breadmonster> ion: Now I just feel stupid :P
13:57:47 <breadmonster> At least my GHC is marginally faster :P
13:58:52 <dmj`> does lambda poll only work on streams?
13:58:54 <breadmonster> meoblast001: Yeah, so install the binary.
13:58:56 <dmj`> AWS lambda
13:58:59 <dmj`> sorry wrong channel
13:59:29 <meoblast001> i'll see what happens when i just reinstall GHC and nothing else that could cause dependency conflicts
13:59:39 <breadmonster> meoblast001: Remove your GHC.
13:59:43 <breadmonster> And then install the binary.
13:59:52 <meoblast001> install the binary from the haskell site?
13:59:54 <napping> meoblast001: meoblast001: here's the pretty download page - https://www.haskell.org/ghc/download_ghc_7_10_1
13:59:55 <breadmonster> Yup.
14:00:12 <breadmonster> Can someone explain the Curry-Howard isomorphism to me?
14:00:12 <napping> ignore Haskell Platform suggestion
14:00:36 <breadmonster> I'm trying to prove an elementary theorem in Haskell, but I don't exactly know how to do it.
14:00:39 <napping> breadmonster: depending on your logic, erasing the expression part of a type derivation can look exactly like a proof derivation
14:00:59 <breadmonster> napping: So what logics can you use?
14:01:04 <meoblast001> napping: wait.. why no haskell platform?
14:01:12 <napping> like, apply rule says Env |- f :: a -> b, Env |- x :: a => Env |- (f x) :: b
14:01:19 <meoblast001> won't i want that later?
14:01:26 <geekosaur> some people are convinced the Platform is beyond evil and will destroy everything forever
14:01:28 <breadmonster> So can you prove anything in mathematics given that you can find the right program?
14:01:31 <napping> erase f , x ,b you have a rule Hyps |- a -> b and Hyps |- a ==> Hyps |- b
14:01:37 <breadmonster> meoblast001: It makes dependency hell worse.
14:01:43 <napping> meoblast001: on Linux, just installing stuff with cabal is pretty smooth
14:01:47 <breadmonster> It's why I recompiled GHC for my own machine to begin with.
14:02:03 <napping> especially following something like ion's suggestions
14:02:20 <napping> The Platform is nice on Windows where installing some C libraries is a huge pain
14:02:22 <geekosaur> because everyone knows the only true platform is the one defined by yesod
14:02:22 <breadmonster> napping: Can you for instance construct a program to prove that 1 > 0?
14:02:29 <meoblast001> so i guess i throw this bad boy in /usr/local/bin?
14:02:40 <napping> breadmonster: whatever type system you have corresponds to a some specific logic
14:02:57 <breadmonster> napping: Okay, this is going way over my head.
14:02:57 <meoblast001> also won't i need to install cabal if i'm installing this?
14:03:02 <napping> meoblast001: the suggestions would put it under home
14:03:15 <napping> Step 6 is installing the cabal binary
14:03:53 <meoblast001> i'm wondering if i'm on the right link lol
14:03:59 <napping> https://gist.github.com/ion1/2815423
14:04:12 <breadmonster> meoblast001: [02:26] <ion> Installing GHC and Cabal under the home directory https://gist.github.com/ion1/2815423
14:04:20 <meoblast001> ooooh
14:04:32 <meoblast001> i was looking at the GHC download page
14:04:43 <breadmonster> napping: Haskell has one typesystem yeah?
14:04:47 <breadmonster> That can't be changed?
14:04:50 <jle`> comonadic extension is convolution
14:05:13 <breadmonster> jle`: ...was that in reference to my question?
14:05:16 <napping> The hopefully-temporary issue with the Haskell platform is that GHC isn't very good at keeping around a binary of the same library version compiled against multiple versions of dependencies
14:05:16 <hodapp> jle`: did you just tell someone to go fuck themselves?
14:05:32 <napping> and there's something about a system vs. user package database
14:05:40 <jle`> breadmonster: not it was a revelation i just had heh
14:05:49 <breadmonster> jle`: Okay then.
14:06:05 <breadmonster> jle`: I'm trying to wrap my head around the Curry-Howard isomorphism.
14:06:09 <napping> so the most reliable way to go, if you don't mind taking up some disk space and longer first-time compiles, is to install few packages globally and use lots of standboxes
14:06:28 <johnw> jle`: how is it convolution?
14:06:32 <napping> Haskell Platform (last I checked) puts some things in the global database, where it's harder for a sandbox to override
14:06:43 <napping> but, there's work in progress that will hopefully fix it up
14:07:10 <breadmonster> napping: So unless I've got this wrong, the Curry-Howard isomorphism says that type systems correspond to logical systems, types to theorems and programs to proofs?
14:07:37 <napping> breadmonster: that's the general idea. There's no guarantee any sensible type system corresponds to a particular logic, of course
14:07:38 <jle`> johnw: you're applying the (w a -> b) function to multiple contexts from your (w a) and aggregating each "shifted evaluation" into a (w b)
14:07:54 <napping> breadmonster: something like Coq has a type system that corresponds to a very expressive logic so you're pretty much set
14:08:03 <breadmonster> napping: So what's the logic equivalent to Haskell's type system?
14:08:16 <napping> Haskell doesn't have as strong of a type system, plus things like nontermination make it unsound
14:08:30 <breadmonster> Wait so Coq is not Turing complete?
14:08:44 <napping> but speaking less technically, the general idea is that a type corresponds to a statement of some logical proposition, and a function/expression of that type is a proof
14:08:44 <breadmonster> Also, how do you get a stronger type system than Haskell?
14:08:44 <johnw> breadmonster: it's core calculus is not, correct
14:08:44 <ion> An issue with proving theorems with Haskell is that you have to be really careful about not introducing bottoms. A bottom can prove anything.
14:08:54 <jle`> story of my life
14:08:55 <meoblast001> napping: when i run configure on GHC i get: checking for path to top of build tree... utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: error while loading shared libraries: libHSrts-ghc7.10.1.so: cannot open shared object file
14:09:14 <breadmonster> ion: This stuff runs deep.
14:09:18 <napping> meoblast001: sound like you might have a source tarball?
14:09:19 <breadmonster> Where do I read more about this?
14:09:20 <hodapp> jle`: I see what you did there.
14:09:30 <meoblast001> it shouldn't be
14:09:32 <napping> That's why I linked to the specific download page, instead of ion's link to the "latest" directory
14:09:35 <meoblast001> let me try again
14:09:43 <meoblast001> i got this from that specific download page
14:09:47 <meoblast001> not under the source section
14:09:49 <napping> or, maybe you need to restart your shell or session?
14:09:57 <hodapp> breadmonster: have you read Software Foundations?
14:10:04 <napping> was that during configure, or while trying to run the GHC?
14:10:13 <johnw> Software Foundations is excellent
14:10:17 <breadmonster> hodapp: No.
14:10:25 <breadmonster> Doesn't it require heavy prerequisites?
14:10:27 <napping> that sounds kind of like you installed a binary, but it's not finding the libraries
14:10:51 <hodapp> breadmonster: Not really. It benefits greatly from a computer that can run Coq.
14:11:05 <napping> breadmonster: in Haskell, you can do stuff like pretending that data Equal a b where Refl :: Equal a a is equality
14:11:13 <napping> and maybe force the argument before doing a GADT match
14:11:17 <meoblast001> napping: during configure
14:11:17 <breadmonster> hodapp: Haha no type theory, category theory, dark mathematical rituals involving sacrifices to Satan?
14:11:20 <hodapp> breadmonster: it's free online, and I'd highly recommend it.
14:11:38 <hodapp> breadmonster: It introduces you to most of what you need.
14:11:55 <breadmonster> napping: Interesting.
14:11:55 <napping> meoblast001: I haven't heard of that. Is is maybe having some linker problems?
14:12:09 <meoblast001> it's trying to load something i haven't yet installed
14:12:10 <jle`> johnw: http://blog.ezyang.com/2010/02/comonads-and-convolutions/ seems to paint a picture of this
14:12:14 <meoblast001> libHSrts-ghc7.10.1.so
14:12:18 <napping> breadmonster: without dependent types, you can't really prove things like 0 < 1, for the usual 0 and 1
14:12:21 <meoblast001> that's part of the compiler. i don't have GHC installed
14:12:21 <johnw> jle`: thanks!
14:12:33 <napping> meoblast001: maybe figure out what binary it's trying to run and run ldd on it?
14:12:42 <jle`> it implements a literal convolution over a stream
14:12:43 <breadmonster> napping: Wait one second, can I prove stuff about continuous functions using the Haskell type system?
14:12:45 <meoblast001> okay
14:12:47 <napping> I think that may be the error you get when trying to load a shared library which is missing dependencies of it's own
14:13:00 <napping> breadmonster: Coq is better for actually proving stuff like that
14:13:03 <jle`> but i was wondering if comonadic extension and composition could be considered to be a generalized form of convolution
14:13:04 <meoblast001> i really should pick this up again later
14:13:06 <meoblast001> thanks for the help
14:13:09 <jle`> othr than just the literal one
14:13:09 <meoblast001> i need to sort through some things
14:13:12 <breadmonster> napping: Sure, but can I do it in Haskell?
14:13:28 <breadmonster> I'd like to find the limit of Haskell's type system.
14:14:30 <hodapp> breadmonster: perhaps you should give a paper called 'Hasochism' a read.
14:14:45 <hodapp> breadmonster: and either it will tell you why you probably don't want to, or it will help you do it.
14:14:47 <codygman> Can I specify the a in a phantom type to be limited to a sum type? I was pointed towards the 'Data Types Ala Carte' paper. Upon finishing it, I'm wondering if there is a simpler way (and unsure if my coworkers will want to go through it to understand my creation). Here's a longer version of my question with code samples: http://lpaste.net/132883
14:15:09 <breadmonster> hodapp: can I PM? Couple of embarrassing questions :P
14:15:43 <hodapp> breadmonster: embarrassing Haskell questions? only if you want to ask them again in here because I probably don't know :P
14:15:55 <napping> codygman: is that truncated?
14:16:01 <breadmonster> hodapp: Okay then :P
14:16:03 <napping> Did you check out generics-sop?
14:16:21 <breadmonster> Umm, doesn't Haskell have the most expressive type system EVAH?
14:16:28 <napping> If you want a flatter structure, something with type level lists like that might be nice
14:16:29 <hodapp> Haskell has... a type system.
14:16:45 <codygman> napping: No it's not. Will check out generics-sop
14:17:08 <breadmonster> hodapp: I mean, there's a hierarchy of expressivity yeah?
14:17:19 <breadmonster> C < Java < Haskell
14:17:22 <napping> codygman: If you're going for using a type-level list instead of nested sums, they do that
14:17:39 <breadmonster> hodapp: So are there type systems that are more expressive than Haskell's?
14:17:42 <napping> breadmonster: not exactly linear, but to the extend it is, the dependently typed stuff is farther along
14:17:46 <jle`> could there be Unbox instances for things like Unbox a => Sum a ...?
14:17:48 <jle`> http://hackage.haskell.org/package/vector-0.10.12.3/docs/Data-Vector-Unboxed.html
14:17:49 <hodapp> breadmonster: well, there's the lambda cube: https://en.wikipedia.org/wiki/Lambda_cube
14:17:50 <jle`> this would be really nice
14:18:00 <napping> breadmonster: generally with less good inference, but there's always work
14:18:00 <Tuplanolla> The term of the day is dependent types, breadmonster.
14:18:24 <breadmonster> Tuplanolla: What exactly are those?
14:18:24 <napping> codygman: your paste ends at 41 lines, without making anything work
14:18:27 <hodapp> breadmonster: and note that Haskell does *not* have dependent types, which are one axis on that cube.
14:18:57 <breadmonster> hodapp: What are dependent types
14:18:59 <codygman> napping: I feel I should also give the context that I'm trying to create a strongly typed API to encode/decode json/xml to/from.
14:19:11 <Ch0c0late> Can someone explain me what does "encoding the security lattice of n points would require O(n^2) definitions for binding operators" mean proposed in http://www.cis.upenn.edu/~stevez/papers/LZ06a.pdf?
14:19:13 <johnw> napping: you can prove 0 < 1 in Haskell
14:19:21 <napping> codygman: I think there might be something more specific than that
14:19:23 <hodapp> breadmonster: Did you check that lambda cube link?
14:19:23 <johnw> import Data.Singletons.Prelude; proof :: Sing (0 :< 1); proof = STrue
14:19:27 <napping> johnw: For 0 :: Int?
14:19:35 <codygman> napping: You are right, I'll put up a working example.
14:19:38 <breadmonster> Yup.
14:19:43 <johnw> 0 promoted to '0
14:19:56 <breadmonster> "types dependant on terms" doesn't seem to make sense to me.
14:20:00 <breadmonster> Are they like C++ templates?
14:20:15 <Tuplanolla> Try implementing it in Haskell, breadmonster.
14:20:27 <napping> johnw: It's a worthwhile distinction - you can usually define a promoted version of your data, but it's hard to be directly dependent
14:20:32 <hiptobecubic> > 0 < 1
14:20:34 <lambdabot>  True
14:20:35 <breadmonster> Tuplanolla: I don't get what you're taking about.
14:20:38 <hiptobecubic> Done
14:20:48 <Hijiri> breadmonster: terms are value level things like 'b' or \x -> x, with dependent types, types can be parameterized by these
14:20:56 <hiptobecubic> breadmonster, what is the type of this list [1,2,3] ?
14:21:13 <Hijiri> by 'b' I mean the character b
14:21:14 <Tuplanolla> A function whose return type depends on its argument, breadmonster.
14:21:16 <breadmonster> hiptobecubic: [] Int?
14:21:17 <Hijiri> not some variable
14:21:48 <hiptobecubic> breadmonster, right. And if I said, I have a value of type [] Int, would you be able to tell me anything about the Ints that are in it?
14:22:03 <breadmonster> hiptobecubic: No?
14:22:31 <hiptobecubic> breadmonster, right. So if I say that I have a list of type "[Int] made of only non-negative values", you can't currently express that in haskell
14:23:07 <breadmonster> hiptobecubic: You could define UInt and then declare something of type [] UInt, right?
14:23:22 <hiptobecubic> Because the type "[Int] made of only non-negative values" *depends* on the value itself. You need to know what numbers are in there in order to know whether or not it's a true statement
14:23:44 <phaazon> hey
14:23:50 <phaazon> I have a happstack server running on port 80
14:23:53 <hiptobecubic> breadmonster, you could, yes, but in this case it's a coincidence. Suppose instead I said only odd numbers.
14:23:54 <phaazon> but when I curl -I it
14:24:03 <phaazon> I get an error
14:24:07 <phaazon> like connexion refused
14:24:08 <phaazon> any idea?
14:24:12 <hiptobecubic> breadmonster, or only prime numbers, etc
14:24:16 <phaazon> something specific to do?
14:24:19 <breadmonster> hiptobecubic: Types are just sets, you could use the appropriate set to define a type, yeah?
14:24:36 <napping> breadmonster: even if you declare a UInt like that, the best you can do is make a function UInt -> Int, you can't do anything with types to say the UInt represents an Int
14:24:44 <hodapp> Types aren't just sets.
14:25:07 <phaazon> or nevermind actually
14:25:09 <breadmonster> hiptobecubic Tuplanolla: So are you guys referring to things like in C++: template < int N > class someclass ...
14:25:23 <Tuplanolla> Try something like divideBy2 :: Integer -> (\ n -> if even n then Integer else Rational), breadmonster.
14:25:47 <breadmonster> Oh okay, that's interesting.
14:25:53 <breadmonster> Why doesn't Haskell have dependent types?
14:26:05 <Tuplanolla> It makes life complicated.
14:26:19 <Tuplanolla> Watch SPJ's GHC infrastructure lectures to see how.
14:26:22 <Denommus`> ReinH: https://gist.github.com/Denommus/817e5a925f058ca31a67
14:26:33 <breadmonster> Tuplanolla: Do you know where I can find a link?
14:26:37 <Tuplanolla> Yes.
14:26:56 <Tuplanolla> Oh, you want it too: https://www.youtube.com/watch?v=6COvD8oynmI
14:27:05 <Denommus> ReinH: I also made a contrived version that checks whether the move as a winning one before trying to contruct the tree
14:27:18 <Denommus> ReinH: (tried to convert everything to Data.Vector but it wasn't a good idea)
14:28:01 <hiptobecubic> breadmonster, part of the problem is that it's apparently a giant pain in the ass to provide all of these proofs
14:28:23 <breadmonster> hiptobecubic: Proofs of what
14:28:36 <hiptobecubic> breadmonster, you write a function that only works on sorted lists and you make a sorted list type, but now you have to *prove* that the list you are trying to pass to the function is indeed sorted
14:28:59 <Tuplanolla> It won't let you pass in a list that might be unsorted there.
14:29:23 <hiptobecubic> Right, so you can't just do (onlySortedIsOk [2,1,3])
14:29:42 <breadmonster> hiptobecubic: Oh okay that's interesting.
14:29:47 <breadmonster> But can't it be automated?
14:29:52 <hiptobecubic> in haskell you can because you don't have a way to specify that it's sorted. The best you can do with any practicality is to use smart constructors or something
14:30:11 <Tuplanolla> It's now a type-level thing, so you can't get away with an exception.
14:30:29 <hiptobecubic> breadmonster, if you can automate it all then why are we programming at all? Just ask for an automatic proof from your inputs to your outputs and go eat lunch :)
14:30:46 <Tuplanolla> Some automation exists though.
14:30:49 <breadmonster> One second, I don't get this.
14:31:29 <Tuplanolla> Here's a dumb proof automaton for Coq: http://jozefg.bitbucket.org/posts/2014-07-09-dissecting-crush.html
14:31:43 <breadmonster> So if we have dependent types, we'll need to prove that functions map dependent types for the type checker to pass it, correct?
14:32:30 <hiptobecubic> breadmonster, imagene a type  `data Sorted a = Sorted [a]`. If you want to guarantee to your functions that when they receive a value of type `Sorted a` it really is sorted, you typically define a function that constructs `Sorted a` values and ensures your invariants, then you don't export the constructor itself so that users can't make their own values that don't pass muster.
14:33:09 <breadmonster> Okay, perfect.
14:33:16 <hiptobecubic> breadmonster, but in this case, it's on you, the library author, to convince yourself that you're doing a good job of constructing the value. There's no way for the type checker to tell you that you're doing it wrong
14:33:20 <breadmonster> How do languages with dependent types work then?
14:33:37 <t7> well
14:33:37 <Tuplanolla> The best way to find out is to try.
14:33:48 <johnw> you can actually say: forall xs : list a, sorted xs
14:34:11 <johnw> so I receive as arguments a list, and a proof witness that it's sorted
14:34:22 <t7> can agda do the coloured types erasure thing yet?
14:34:30 <t7> read a paper about it years ago
14:34:33 <t7> was so cool
14:34:35 <johnw> of course, whoever made the list originally (and everyone who modified it) must create and update that witness
14:34:55 <breadmonster> Tuplanolla: Sorry for being dense and asking all the questions, I have no math background.
14:34:56 <johnw> breadmonster: work through Software Foundations
14:35:07 <johnw> breadmonster: it's fun, it's interesting, and you may even lose sleep
14:35:07 <Tuplanolla> Yes, SF is good.
14:35:14 <Tuplanolla> Here: http://www.cis.upenn.edu/~bcpierce/sf/
14:35:24 <t7> ah the coq thing :
14:35:26 <t7> booo
14:35:27 <breadmonster> And you're sure this requires no advanced math?
14:35:31 <breadmonster> t7: ?
14:35:36 <johnw> none at all
14:35:45 <johnw> it assumes almost no background, except a smattering of functional programming
14:35:56 <t7> breadmonster: ah monad is just a monoid in the catagory of endo-functors... whats the problem?
14:35:57 <hiptobecubic> depending on who you talk to, this is advanced math
14:36:02 <Tuplanolla> You'll advance your math as you go.
14:36:08 <johnw> hiptobecubic++
14:36:40 <breadmonster> hiptobecubic: Then how am I to digest it lol?
14:36:47 <breadmonster> But yeah, I'll read the book (:
14:36:51 <exio4> it isn't bad as it seems! 
14:37:01 <johnw> it's better than a book, it's an interactive self-study project
14:37:04 <Tuplanolla> Don't forget the exercises!
14:37:09 <hiptobecubic> breadmonster, the same way you'd digest anything else? It's not like something being 'advanced' relaly means anything in the end.
14:37:12 <Hijiri> oh no
14:37:16 <Hijiri> I haven't worked on SF for a while
14:37:20 <Hijiri> now I forgot all the proof general bindings
14:37:45 <breadmonster> johnw: And it makes you a better Haskeller?
14:38:00 <johnw> breadmonster: all depends on which Haskellers you want to impress ;)
14:38:09 <m_ryan> djm`: hi it's me from yesterday can i ask something?
14:38:20 <breadmonster> I'd say Jane Street...
14:38:26 <johnw> breadmonster: I'd say it makes you a better computer scientist for sure
14:38:33 <breadmonster> Hmm, that's good enough.
14:38:37 <breadmonster> Will work through it.
14:38:41 <Tuplanolla> How about a better person?
14:38:55 <johnw> depending on who you talk to... :)
14:39:01 <breadmonster> Hahahaha
14:39:39 <breadmonster> Also, should I use Proof General or CoqIDE?
14:39:43 <johnw> definitely PG
14:39:44 <exio4> even if they don't, they are still fun
14:39:57 <Tuplanolla> You can also use plain coqtop.
14:40:25 <johnw> I started SF with extremely little math background, and it was my first ever introduction to proof as a meaningful activity (as opposed to knowing of it merely as "something mathemicians do").  It opened up a whole new world for me.
14:40:51 <Tuplanolla> On the topic of interfaces, does anyone use TeXmacs?
14:41:13 <johnw> we stay on the topic of Haskell :)
14:42:20 <zipper> johnw: SF?
14:42:37 <johnw> my "Haskell" folder on this computer has so many things that aren't actually Haskell syntax....
14:42:50 <monochrom> I think it refers to Benjamin Pierce's Software Foundation book
14:43:12 <monochrom> don't feel bad, it took me 2 minutes to decode :)
14:43:17 <ReinH> johnw: well, it also has a lot of things...
14:43:20 <zipper> monochrom: :)
14:43:32 <Pamelloes> Is it possible to turn (a -> m b) into m (a -> b)?
14:43:39 <ReinH> Pamelloes: no
14:43:45 <johnw> Pamelloes: no, there's an SO question about that
14:43:46 * monochrom comforts undergrad students with "this exam question took me 15 minutes too"
14:43:58 <ReinH> The difference between a -> m b and m (a -> b) is the difference between monad and applicative
14:44:04 <johnw> http://stackoverflow.com/questions/27267848/turning-a-mb-into-ma-b
14:44:38 <ReinH> if you could, all applicatives would be monads
14:44:42 <hpc> for a good example of why it's not possible, take m = Maybe and try implementing it yourself
14:45:27 <kadoban> ReinH: Isn't he asking for the other (way more possible) way?
14:45:28 <Pamelloes> Hm, I guess that makes sense.
14:45:57 <johnw> Pamelloes: there are m's for which it works
14:46:01 <ReinH> kadoban: I took it as asking for some f :: Monad m => (a -> m b) -> m (a -> b)
14:46:14 <zipper> WHat's the GHC extension to not get orphan instance warnings?
14:46:21 <ReinH> kadoban: oh, right
14:46:32 <kadoban> Ya, me too. Isn't that way possible? *goes to actually try it*
14:46:43 <ReinH> m (a -> b) -> (a -> m b) would make every applicative a monad
14:46:49 <Pamelloes> ReinH: That is what I was asking for.
14:46:57 <ReinH> Pamelloes: you are right, I was confused :)
14:46:58 <johnw> since ((->) r) is a monad, let's call it r, then you're asking for r (m b) -> m (r b), which is possible if m distributes (http://hackage.haskell.org/package/distributive-0.1.2/docs/Data-Distributive.html).  Few things distribute like this.
14:47:08 <Pamelloes> ReinH: No, the first one. You weren't confused.
14:47:14 <aweinstock> does (return .) have a name?
14:47:37 <johnw> :t (return .)
14:47:38 <lambdabot> Monad m => (a -> a1) -> a -> m a1
14:47:39 <ReinH> aweinstock: usually not, because foo >>= return . f == fmap f foo
14:47:41 <codygman> What are the best options for XML these days? I was looking at xml, HXT, tagsoup, and xml-conduit.
14:47:41 <exio4> f :: Monad m => m (a -> b) -> (a -> m b); f xm = \y -> xm >>= return (f y)
14:47:52 <ReinH> so you don't see (return .) very often
14:48:27 <johnw> yeah, >> return . triggers an automatic response from my fingers when I see it
14:48:31 <johnw> s/>>/>>=
14:49:00 <ReinH> :t sequence `asAppliedTo` return
14:49:01 <lambdabot> (Monad m, Traversable ((->) a)) => (a -> m a) -> m (a -> a)
14:49:32 <ReinH> whether it's law abiding depends on whether the composition of m and (r ->) is a monad.
14:49:44 <zipper> Where in my haskell source file can I put `-fno-warn-orphans`
14:49:45 <ReinH> I think
14:49:52 <ReinH> zeiris: in a pragma
14:49:55 <ReinH> ugh
14:49:57 <ReinH> zipper: in a pragma
14:50:08 <zipper> zeiris: I tried it said unrecognised.
14:50:14 <exio4> @type flip (fmap . flip ($))
14:50:14 <ReinH> zipper: see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/pragmas.html
14:50:15 <zipper> Hmmm wait
14:50:16 <lambdabot> Functor f => f (a -> b) -> a -> f b
14:50:58 <ReinH> Pamelloes: wait, no, I wasn't confused
14:51:16 <ReinH> If you can generally turn a f (a -> b) into a -> f b, then applicative and monad would be equivalent
14:51:18 <ReinH> sorry
14:51:20 <ReinH> I confused myself :D
14:51:29 <ReinH> wait, no
14:51:34 <ReinH> I confused myself again. I am going to shut up now.
14:51:38 <Pamelloes> Ok...
14:52:13 <Pamelloes> Anyways, I wanted a way to turn a -> f b into f (a -> b). Which would mean monad and applicative are the same
14:52:19 <ReinH> Pamelloes: correct
14:52:25 <Pamelloes> Alright. There we go :)
14:52:25 <ReinH> that's what I meant, sorry
14:52:35 <ReinH> my brain is all twisted now :(
14:52:47 <ion> zipper: OPTIONS_GHC
14:57:43 <kadoban> ReinH: Sorry for starting the confusion, I see where I was wrong with my sub-inquiry :)
14:57:57 <ReinH> kadoban: I confused myself, don't worry :)
14:58:04 <Pamelloes> Is there a better way to express the type newtype MyType a b c m = MyType (b,a->b->m b)?
14:58:28 <Pamelloes> *MyType (b,a->b->m c)
14:59:22 <johnw> Pamelloes: consider (Int -> [Int]) -> [Int -> Int].  That would turn a function that returns a list of numbers at every number, into a list of functions that return a single number for every number?  For this to be equivalent, those inner functions would need to have constrained domains in order to, in the end, yield the same set of result values
14:59:34 <fragamus> So TLA+ is used at amazon to test specifications not code
15:00:13 <mmaroti> Hi guys! Why there is no fmapM :: (Monad m, Functor f) => (a -> m b) -> f a -> m f b?
15:00:31 <Hijiri> there is liftM
15:00:36 <Hijiri> oh sorry
15:00:41 <Hijiri> I misread that
15:00:45 <johnw> mmaroti: something of almost that same type is in Data.Traversable
15:00:48 <johnw> :t mapM
15:00:49 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
15:01:51 <johnw> mmaroti: but (a -> m b) -> f a -> m (f b) would need exactly the same Distributive property we've been discussing
15:01:56 <mmaroti> The thing I have would not be Foldable, so that is why I want just Functor.
15:02:17 <mmaroti> what distributive property?
15:02:20 <johnw> mmaroti: (a -> m b) -> f a -> f (m b) on the other hand, is just fmap
15:02:23 <napping> With just Functor, you can only get as far as f (m b)
15:02:26 <johnw> http://hackage.haskell.org/package/distributive-0.1.2/docs/Data-Distributive.html
15:02:39 <johnw> i.e., your fmapM = distribute . fmap
15:02:48 <johnw> but is not avaliable for all choices of 'm'
15:02:53 <dmj`> /msg lambdabot @typ liftM (<$>)
15:02:53 <dmj`>  
15:02:53 <dmj`>  
15:02:53 <dmj`>  
15:02:56 <dmj`>  
15:02:59 <dmj`>  
15:03:01 <dmj`>  
15:03:08 <johnw> dmj`: points for trying at least not to spam the channel :)
15:03:17 <dmj`> yea :) i've been struggling
15:03:37 <fragamus> I think a little white space adds something
15:03:40 <johnw> sorry, (distribute .) . fmap
15:04:06 * hackagebot lambda-options 0.6.0.0 - A modern command-line parser for Haskell.  http://hackage.haskell.org/package/lambda-options-0.6.0.0 (ThomasEding)
15:04:24 <napping> mmaroti: a function (Monad m) => f (m a) -> m (f a) is enough to define an instance Traversable f
15:04:50 <johnw> aka, Distributive :)
15:05:02 <johnw> oh, maybe not
15:05:03 <mmaroti> ok, i am slowly getting it :)
15:05:05 <johnw> that only relies on Functor
15:05:55 <napping> actually, Traversable is defined over an Applicative instead of a Monad
15:06:18 <napping> I doubt that makes a difference, but it's there
15:06:58 <napping> Anyway, if you can define your function (Monad m) => (a -> m b) -> f a -> m (f b), and it's halfway well behaved, you can use that function to make a Traversable instance
15:08:42 <mmaroti> Ok, I see that I need to be able to make it an instance of Traversable... thanks for the help!
15:10:46 <solidus-1iver> whoa, howevers been putting work in haskell.org / fpcomplete, the updates / stuff in there is awesome
15:11:08 <m_ryan> hi can anyone help me with this? http://lpaste.net/132857
15:11:46 <mmaroti> One more problem: I need to implement Foldable first, but there is no natural order to go over elements
15:12:25 <mmaroti> Traversable would be fine without the Foldable
15:12:45 <napping> Traversable goes over the elements in some order too
15:12:55 <napping> I don't see any requirements about the order on Foldable
15:13:23 <dmj`> m_ryan: you don't need to return an Int, just use another thread to read the contents of the mvar. The Int you're looking for is stored in the MVar
15:14:03 <m_ryan> djm`: so you mean that the ForkIO will just return the Mvar Int type?
15:15:13 <mmaroti> You need to implement foldr for Foldable, which is "right associative", which does not make sense, but well it will return something.
15:15:31 <mmaroti> With Traversable you can preserve the shape.
15:15:36 <napping> that's the association in the result, not in the structure
15:16:32 <napping> whatever your structure looks like, you should return something built up like x <> (y <> (z <> ...))
15:16:41 <napping> and the other way around for foldl
15:17:05 <napping> I think the default implementation just gives you foldl/foldr on toList
15:17:22 <SwashBuckla> @pl flatMap f l = flatten (map f l)
15:17:22 <lambdabot> flatMap = (flatten .) . map
15:17:29 <mmaroti> Ok, I need only Distributive, then use collectM
15:17:29 <napping> and toList uses some funny monoid in your foldMap
15:17:38 <dmj`> m_ryan: what is the type of forkIO ?
15:17:47 <anks> guys, is there any function for updating multiple values in an IntMap with a function?
15:17:47 <m_ryan> ThreadId
15:17:58 <m_ryan> djm`: ThreadId
15:18:03 <dmj`> m_ryan: almost, try again
15:18:07 <SwashBuckla> anks: 'updating', as in state?
15:18:16 <anks> or do i have to foldr with intmap's update function
15:18:42 <anks> updating as returning updated map
15:18:52 <dmj`> anks: an IntMap should be a functor, so you could use fmap, or there might be a Data.IntMap.map
15:19:20 <m_ryan> djm`: i try it and good. nothing error. but how do i get the Mvar Int data on the thread?
15:19:29 <dmj`> anks: https://hackage.haskell.org/package/containers-0.4.2.1/docs/Data-IntMap.html#v:map
15:20:40 <anks> thanks, but i'm not interested in O(n), where n is size of the map
15:20:50 <anks> ill go with folding with an update function
15:20:58 <dmj`> m_ryan: use readMVar mvar at the end of the block
15:21:05 <anks> which will give me 0(k*log(n)) i guess
15:21:36 <dmj`> anks: wait, do you want to modify every element in the IntMap?
15:22:11 <anks> no!, just some of them
15:22:41 <anks> i was looking for something like updateMany :: (a->a) -> [Keys ]->IntMap a -> -> IntMap a
15:22:56 <anks> or
15:23:01 <anks> i was looking for something like updateMany :: (a->b) -> [Keys ]->IntMap a -> -> IntMap b
15:23:17 <anks> (copy pasted - lol)
15:23:32 <c_wraith> anks: that doesn't really work
15:23:50 <c_wraith> anks: you would need either (a -> a), or just map
15:23:58 <codygman> Is HaXml stable or dead? lol
15:24:06 <anks> right!
15:24:08 <anks> sorry
15:24:08 <c_wraith> anks: because you can't mix value types in an IntMap
15:24:22 <srhb> codygman: Why would you think it's dead?
15:24:23 <anks> (a->a) was good enough
15:24:31 <m_ryan> djm`: mvar is IO (Mvar Int) -> but it expect a type of "MVar (MVar Int)" but the actual data is "MVar Int"
15:24:40 <c_wraith> anks: in that case, you can use mapWithKey and check the key against the list
15:24:52 <srhb> codygman: Last hackage version is from january this year.
15:27:42 <anks> c_wraith: what i needed was: updateMany f ks m = foldr (update (Just . f)) m ks
15:27:59 <dmj`> m_ryan: go through Marlow's book, it will make this much easier for you.
15:28:30 <anks> or this is even prettier with different args order:
15:28:31 <anks> updateMany f  = foldr (IM.update (Just . f)) 
15:28:43 <m_ryan> dmj`: the book that you refer to me right?
15:28:53 <c_wraith> anks: that might be somewhat slow due to constantly rebuilding the tree.  Doing the transformation in one pass is going to be faster, though it helps to have fast key lookups, which a list doesn't give you
15:30:58 <anks> 'update' is guaranteed to be max O(64) ^^
15:31:10 <anks> 'update' is guaranteed to be max O(min(n,W))
15:31:28 <anks> so i think the tree is not rebuilded, is it?
15:32:39 <c_wraith> update rebuilds the tree. It's just that the tree height is guaranteed to be no more than the number of bits in Int
15:33:06 <oconnore> What's the recommended course of action when you can't get a response from a library maintainer?
15:33:12 <zipper> jle`: You around?
15:33:21 <oconnore> I'm currently using yaml-config and dequeue, and they both fail to build on 7.10
15:33:34 <oconnore> I was able to fix the build, but I can't get ahold of anyone to push a new version to hackage
15:34:23 <dmj`> m_ryan: yes
15:35:36 <anks> c_wraith: I just checked, the implementation, it rebuilds only the path to the node being updated
15:36:27 <anks> thanks for the assist, bye
15:43:45 <Zemyla> How do I raise an error without the Prelude?
15:44:27 <Zemyla> I'm trying to write a replacement integer-simple package, and I'm trying to use RebindableSyntax to permit monad notation.
15:46:04 <codygman> How would I go about using the members of a sum type in a fuction. I would like to generate a list of strings from the show instances derived from a sum type. ex. `map show (getSumTypeMembers Codes)` when I have `data Code = Code1 | Code2 deriving Show` would return ["Code1", "Code2"].
15:46:05 <Zemyla> How do I raise an error that can be caught, since I can't use the error function (GHC.Err depends on GHC.Integer)?
15:49:31 <solidus-1iver> what does <> mean again?
15:50:14 <exio4> binary and associative operation 
15:52:59 <pavonia> Zemyla: Control.Exception has several throw functions
15:53:22 <pavonia> Zemyla: Also, why can't you use error?
15:53:35 <Zemyla> pavonia: I can't import that. I'm trying to write a GHC.Integer replacement, and I can't load any package but those in ghc-prim.
15:53:54 <Zemyla> Since everything else depends on GHC.Integer.
15:54:02 <pavonia> Oh
15:54:19 <solidus-1iver> :t (<>)
15:54:21 <lambdabot> Monoid m => m -> m -> m
15:55:21 <f|`-`|f> a simple example would be 
15:55:47 <Zemyla> solidus-1iver: Lists are monoids, with the operation of ++.
15:56:00 <pavonia> Zemyla: Then there's raise# in GHC.Prim
15:56:01 <f|`-`|f> > [1,2,3] <> ([7,8] <> [4,5]) == ([1,2,3] <> [7,8]) <> [4,5]
15:56:03 <lambdabot>  True
15:56:31 <Zemyla> pavonia: Yes, but if I pass raise# something that isn't a SomeException, then GHC will probably crash when it tries to catch it.
15:58:10 <solidus-1iver> very cool, i need to get my head back into haskell land, i shouldn't have let myself slip out of it for so long (been 7 months)
16:02:13 <pavonia> Zemyla: Just out of curiosity, why are you writing such a replacement?
16:03:04 <c_wraith> Zemyla: how does the current integer-simple handle division by 0?  It has to throw an exception
16:03:53 <geekosaur> gpl-ed gmp, presumably, and shortcomings in integer-simple? although I thought that was redone recently
16:04:16 <geekosaur> and it's fundamental enough that you can't use much in it, yeh
16:06:43 <Zemyla> Because integer-simple sucks on ice performance-wise?
16:07:28 <Zemyla> It returns errorInteger, which is arbitrarily defined as 47.
16:08:42 * geekosaur wonders if anyone has looked at libtommath since 2006 (https://mail.haskell.org/pipermail/glasgow-haskell-users/2006-September/010963.html)
16:08:44 <indiagreen> c_wraith: http://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-Real.html#line-334
16:09:06 <indiagreen> errors aren't thrown at the level of primops
16:09:38 <c_wraith> So it just protects the primops from ever dividing by zero?
16:09:45 <indiagreen> uh-huh
16:11:22 <user1_> how do I test a function like Data.Aeson.Schema.schemaQQ (a TH function) in the repl?
16:11:41 <c_wraith> there's a runQ function.
16:11:52 <c_wraith> runQ :: Q a -> IO a
16:13:26 <user1_> c_wraith: thank you, but how do I import the library needed for it?
16:13:44 <user1_> :m Language.Haskell.TH?
16:13:57 <c_wraith> Well, :m + Language.Haskell.TH
16:14:06 <c_wraith> or just...  import Language.Haskell.TH
16:14:11 <c_wraith> If you're on any sort of recent ghci
16:14:35 <user1_> hmm apparently I can't simply import if i'm in a cabal repl
16:14:45 <user1_> there's a lot that I still have to learn about cabal :)
16:14:50 <c_wraith> Oh, the package isn't visible
16:15:02 <c_wraith> You could add it to your build-depends
16:15:04 <haskell286> Can somebody tell me why Arrows use `-<` operator for application?
16:15:08 <Zemyla> Also, I apparently can't define an ST monad with unlifted types.
16:15:12 <codygman> Is there a way to generate checking if instances of a sum type exist automatically, instead of manually like this: http://lpaste.net/132888
16:15:13 <user1_> c_wraith: does that mean adding it to my .cabal file?
16:15:16 <c_wraith> haskell286: it's the opposite of <-
16:15:25 <c_wraith> user1_: yes
16:15:31 <c_wraith> haskell286: well, the reverse of it, anyway
16:15:32 <user1_> c_wraith: will do, thanks
16:15:43 <S11001001> Zemyla: ?
16:17:06 <S11001001> codygman: there are relevant Enum and Bounded functions
16:17:24 <S11001001> codygman: and I think when you say "sum type" above, you mean "bounded enum"
16:17:28 <haskell286> c_wraith: hm, so its kind of similar to monadic bind?
16:18:16 <c_wraith> haskell286: not really.  It's just a function that lets you run a Q action as an IO action - and ghci can execute IO actions, so you can actually test stuff that way.
16:20:10 <haskell286> c_wraith: I thing I do understand the semantics, but what confuses me, is that its called "application". Is it correct to say its a generalisation of $ the same way arrows generalize functions?
16:20:20 <haskell286> s/thing/think
16:20:46 <Pamelloes> Is there some way to make do {a;b;c;} turn into [a,b,c]?
16:20:57 <c_wraith> haskell286: where is it called "application"?
16:21:43 <c_wraith> Pamelloes: if you have some sort of monoid-builder monad...  you can get sort of close.
16:22:11 <codygman> S11001001: Thank you for correcting my incorrect usage of sum type. If I'd known it were a bounded Enum I probably would have looked for that :)
16:22:14 <Pamelloes> c_wraith: Can you give me an example?
16:22:43 <Zemyla> Pamelloes: RebindableSyntax, maybe?
16:23:41 <haskell286> c_wraith: https://www.haskell.org/arrows/syntax.html for example
16:24:14 <haskell286> c_wraith: but its called so almost in any paper i stumbled upon about arrow notation
16:25:06 <Pamelloes> Zemyla: hm, that looks pretty cool. However, I'd like to be able to do something comparable without taking such drastic measures
16:26:01 <haskell286> c_wraith: "-< (arrow application) feeds the value of an expression into an arrow."
16:26:13 <c_wraith> haskell286: ah, I got my wires crossed.  It's..  application in the sense that arrows are functions.
16:26:25 <S11001001> codygman: additionally, while this is admittedly not #nothaskell, and you are probably just experimenting, it is probably best to either use a broader definition of gender <https://twitter.com/gregtarnoff/status/339859855328296962> or not mention it at all.
16:26:33 <c_wraith> haskell286: but onlike ($) or (=<<), it's syntax rather than a function
16:26:36 <c_wraith> *unlike
16:28:55 <S11001001> codygman: regarding "sum types", any 'data' definition with more than one data constructor is specifying a sum type.  So that includes [], Either, Maybe, lots of stuff.  bounded enums are a special kind of sum type
16:31:35 <S11001001> (the overlap is not perfect; () is a bounded enum, but is it a sum type?)
16:32:20 <geekosaur> trivial case of a sum type, I think
16:32:53 <exio4> I also like to add that 0 + X = X + 0 = X
16:33:13 <exio4> (considering there's no bottom and there actually exists a 0)
16:33:15 <S11001001> geekosaur: if so, they're all sum types :)
16:34:29 <haskell286> c_wraith: thats right, I am really interested in the origin of this syntax, its relation to function application and monads.
16:34:46 <haskell286>  To give you some context: im designing a language (mainly for data transformation) and trying to base it on the concept of arrows.
16:43:22 <ReinH> haskell286: have you read the arrows paper?
16:46:37 <haskell286> ReinH: I did. And as I told, I do understand the theory. What I would like to know is how the notation proposed later and the builtin haskell syntax where chosen.
16:47:06 <haskell286> ReinH: And sincerely now that I think, I don't even know why Haskell uses $ for application for example.
16:47:55 <user1_> I'm having trouble installing aeson-schema: https://gist.github.com/canpeter/a25e18046ada4613ce17
16:48:43 <haskell286> ReinH: I love reading design proposals for the language since they always include the rationale (both for semantics and syntax), which doesn't always happened with more abstract concepts.
16:49:15 <ReinH> haskell286: did you read the paper on the arrow notation?
16:50:40 <user1_> do I want my packages in build-depends to specify version numbers?
16:50:59 <dolio> haskell286: 'y <- a -< x' looks like you're feeding x into arrow a and getting out y.
16:51:44 <dolio> <--< looks like an arrow.
16:53:40 <haskell286> ReinH: I read the original monads generalisation proposal by Hughes and The Arrow Calculus papers
16:54:04 <ReinH> haskell286: http://staff.city.ac.uk/~ross/papers/notation.html
16:54:39 <ReinH> haskell286: a few other arrow papers https://www.haskell.org/arrows/biblio.html
16:55:22 <pavonia> user1_: Usually only the first two digits are specified to so that bug fixes of a package still can be used
16:56:38 <user1_> pavonia: how do I have cabal try the latest of each package? without specifying any versions I can see it doesn't try to install the latest
16:58:44 * mjrosenb is confused
16:58:51 <pavonia> user1_: How do you know it still works with the currently latest package?
16:59:04 <mjrosenb> it looks like haskell is replacing nearly every type with () in this error message.
16:59:10 <haskell286> ReinH: There's a chapter 	devoted to arrow application which explains in detail how the syntax works. Thanks!
16:59:47 <user1_> pavonia: I don't know. 
17:00:29 <user1_> pavonia: is it possible that two packages don't work together?
17:00:31 <pavonia> user1_: I mean you can try to use the latest packages now by leaving out the package versions, but you package may fail in future after new versions have been released
17:00:51 <user1_> pavonia: that's what I'm saying, I left out the version numbers, it still didn't try the latest versions
17:01:03 <user1_> pavonia: cabal seems to remember how it failed last time
17:01:09 <pavonia> It's trying to find a set of version that will work together
17:01:23 <user1_> pavonia: so if it fails what are my choices?
17:01:28 <c_wraith> mjrosenb: extended defaulting rules maybe?
17:01:49 <mjrosenb> c_wraith: I don't think I enabled that.
17:02:09 <pavonia> user1_: You need to find a set of dependencies that actuall works together, which are usually you currently installed package versions
17:02:38 <user1_> pavonia: that sounds like the chicken and egg problem :P
17:02:46 <user1_> pavonia: I'm still trying to install these packages
17:02:51 <mjrosenb> https://gist.github.com/f91b850941aca92820ae
17:03:23 <pavonia> user1_: Oh, I didn't look at that link
17:04:08 <user1_> pavonia: this is my link: https://gist.github.com/canpeter/a25e18046ada4613ce17
17:04:43 <pavonia> user1_: Might be possible that this package is actually incompatible with your currently installed version set. You should use cabal sandboxes then
17:05:05 <user1_> mjrosenb: you're forgetting to end with either a return call or a wrapped value gotten from somewhere
17:05:17 <mjrosenb> c_wraith: Font.solid /should/ be: https://gist.github.com/e846b67edc52725bfd50
17:05:20 <user1_> pavonia: I am!
17:05:30 <mjrosenb> user1_: hte last line in the block is SDL.renderCopy...
17:05:46 <user1_> what is the type of that function?
17:06:13 <pavonia> user1_: Oh heh, you're in trouble then :p
17:06:28 <user1_> pavonia: well at least now I know :)
17:06:40 <mjrosenb> user1_: https://gist.github.com/9dcd1e77493743770bc8
17:07:24 <pavonia> user1_: So you probably need to try to fix the error or ask the maintainer to do so
17:08:08 <user1_> mjrosenb: try saying :: IO () in the end of the last line
17:08:22 <user1_> pavonia: probably
17:08:27 <pavonia> user1_: Or maybe your compiler is too old/new for that package
17:09:21 <mjrosenb> so, most of SDL is actually MonadIO  => ... -> m ()
17:09:38 <mjrosenb> I can say that has type ... -> IO (), correct?
17:10:04 <user1_> mjrosenb: I think you can hint at it if you do say :: IO () at the end
17:14:12 * hackagebot hackager 0.2.0.0 - Hackage testing tool  http://hackage.haskell.org/package/hackager-0.2.0.0 (DavidTerei)
17:19:13 * hackagebot hackager 1.2.0.0 - Hackage testing tool  http://hackage.haskell.org/package/hackager-1.2.0.0 (DavidTerei)
17:30:51 <dino-> Just realized I'm not sure if this is possible: `cabal get` gets the source for a package and unpacks it, but is there a cabal-install command to get the source tarball file?
17:31:59 <geekosaur> cabal fetch?
17:33:11 <dino-> geekosaur: I just tried that and it told me it downloaded the package I asked for and another one, but apparently not into . !
17:33:15 <dino-> Not sure what that did
17:34:09 <geekosaur> probably somewhere under ~/.cabal/packages
17:34:13 <geekosaur> I was somewhat afraid of that
17:34:38 <dino-> geekosaur: Yeah, that's where they went
17:36:22 <dino-> I'm asking because I usually put a link back to the Hackage website in my projects' README, and was wondering if that's not really necessary.
17:39:44 <anks> Is there anyway I can get stack trace or a line or anything instead of just : *** Exception: Maybe.fromJust: Nothing 
17:42:36 <pacak> anks: ghci can provide you with stack traces
17:43:33 <kadoban> anks: fromJust is evil, in general, by the way. This is pretty much exactly why.
17:44:05 <benzrf> anks: that sort of explosion is kind of the haskell equivalent of a segfault
17:44:14 * hackagebot hackager 1.2.0.1 - Hackage testing tool  http://hackage.haskell.org/package/hackager-1.2.0.1 (DavidTerei)
17:44:17 <pacak> kadoban: Partial functions are evil in general, there's nothing especially evil in fromJust.
17:44:23 <benzrf> except that unlike segfaults, idiomatic haskell pretty much never brushes up against that
17:44:24 <benzrf> :)
17:45:03 <pacak> > head []
17:45:05 <lambdabot>  *Exception: Prelude.head: empty list
17:45:19 <kadoban> pacak: I didn't suggest that it's more evil than other partial functions.
17:45:28 <Welkin> > head . head . head $ [[[]]]
17:45:30 <lambdabot>  *Exception: Prelude.head: empty list
17:45:33 <Welkin> > head . head . head $ [[[1]]]
17:45:35 <lambdabot>  1
17:45:38 <dino-> anks: Breakpoints may help too, in ghci, if you can't figure out where this is. Or something like Debug.Trace if you want to mark up the code more.
17:46:05 <dino-> There's some info here: https://wiki.haskell.org/Debugging
17:46:14 <pacak> anks: If you are into evil stuff - you can use CPP to annotate each of your fromJust with location.
17:46:25 <Welkin> never use fromJust
17:46:43 <Welkin> just like you never want to use head
17:46:50 <pacak> :t read
17:46:51 <lambdabot> Read a => String -> a
17:47:10 <Welkin> use fromMaybe instead
17:47:20 <pacak> :t maybe
17:47:21 <lambdabot> b -> (a -> b) -> Maybe a -> b
17:51:30 <anks> Well, I restricted the type so its guaranteed by an invariant.. but still use function from more general type, so i am safe to use fromJust
17:53:20 <Lokathor> if you use a case statement to unwrap it, you can make the default case be an error message with the line number or other info
17:53:37 <Lokathor> it'll still crash and all, but you'll get the extra info you wanted
17:53:38 <benzrf> if you are using fromJust then something is wrong
17:53:43 <benzrf> why are you using fromJust
17:53:45 <benzrf> smh
17:53:59 <dino-> anks: Then I would suggest maybe trying to use a breakpoint if you can't locate it or want to examine values around this code at runtime. Or Debug.Trace
17:54:12 <benzrf> for what are you using fromJust, anks
17:55:08 <Lokathor> benzrf, once i used fromJust at the start of a program to parse an initialization file
17:55:08 <Cale> fromJust on its own isn't a problem (provided that you know statically that the result must be Just x). It's when you're using both fromJust and isJust together that you really ought to rewrite the thing.
17:55:42 <Cale> Yeah, the other case is when you really don't care about what happens when the thing happens to be Nothing.
17:55:52 <Cale> (and just want the program to die in that case)
17:56:01 <anks> i was pretty confident, there will be no exceptions, there maybe errors somewhere else, and thats why it is thrown
17:56:05 <benzrf> Cale: imho any code that relies on knowing statically that a value is a Just is probably poorly designed
17:56:07 <benzrf> B)
17:56:11 <Cale> I disagree
17:56:31 <anks> well gonna replace it with case and error message
17:56:50 <Cale> benzrf: I might agree with you somewhat if Haskell were dependently typed, but it is not.
17:56:54 <dino-> anks: Debug.Trace may be less work
17:56:59 <benzrf> bleh
17:57:02 * benzrf defers
17:57:24 <dino-> If you just want somethign to blurt out before it dies.
18:02:00 <meoblast001> does anyone with ghc-mod-vim know what to do with: ghcmod#command#type: Cannot guess type
18:02:40 <meoblast001> is there any log that this might write out to that i could check?
18:08:22 <anks> 3 a.m., went from *** Exception: Maybe.fromJust to *** Exception: mkGraph [(5,1)] [(5,4,())]
18:08:37 <anks> yawn
18:09:15 * hackagebot Neks 0.3.0.0 - Simple networked key/value store  http://hackage.haskell.org/package/Neks-0.3.0.0 (wyager)
18:09:24 <meoblast> oops.. got disconnected
18:09:57 <Cale> anks: Yeah, so your problem is that the graph has no vertex 4
18:10:13 <Cale> (the graph you're trying to make)
18:11:21 <rien> Cale: what's your advice for those struggling with getting certain packages installed together in a sandbox?
18:13:22 <Cale> rien: In general, it's almost arbitrarily hard, but I somehow don't run into problems very often. First of all, you should always try to tell cabal-install about as many of the packages at once as you can.
18:14:02 <Lokathor> if you need to add a package, just delete the whole sandbox and start over probably
18:14:03 <rien> does "at once" mean "every time you add a package to the cabal file and run cabal install" ?
18:14:14 <rien> Lokathor: oh.... that's what is meant
18:14:33 <Cale> rien: Well I dunno if that's necessary, but sure, that's an option.
18:14:34 <rien> so sandboxes are one-use only, as if it were?
18:14:58 <mgomezch_> not necessarily
18:15:00 <Cale> I don't even use sandboxes all that much :P
18:15:05 <Cale> I probably should
18:15:08 <Lokathor> not always, but that's often the simplest route to having things working
18:15:16 <rien> and just doing cabal sandbox init again in the same directory doesn;t seem to cut it so I guess just start over in a fresh directory?
18:15:21 <rien> Lokathor:  ^ ?
18:15:24 <Cale> I just install things to my home directory, and fix problems as they arise.
18:15:27 <mgomezch_> rien: cabal sandbox delete
18:15:55 <Cale> However, I don't work on a lot of yesod projects or anything like that
18:15:58 <rien> mgomezch_: hmm interesting, never ran across that command. so cabal sandbox delete and cabal sandbox init then cabal install every time I change my .cabal file?
18:16:06 <mgomezch_> but you *can* add things to sandboxes.  its just that you might run into conflicts and then have to unregister things before you can install other things
18:16:09 <Cale> rien: That shouldn't be necessary
18:16:16 <Lokathor> yeah, the "sandbox" is a .cabal-sandbox folder. You can delete that manually or via the command
18:16:21 <tmtwd> @source foldl
18:16:21 <lambdabot> Unknown command, try @list
18:16:28 <tmtwd> @src foldl
18:16:28 <lambdabot> foldl f z []     = z
18:16:28 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
18:16:29 <kern_chicken_pan> Hi
18:16:30 <mgomezch_> rien: thats kind of a painful, slow but mostly-certian way to go, yes
18:16:45 <Cale> rien: I'm only suggesting that *if you run into problems getting dependencies to work out* try specifying a larger set of the packages you want to have installed at the same time.
18:17:03 <Lokathor> rien, add the package, see if it can install, it might install no trouble. If it gives you trouble, just redo the sandbox
18:17:05 <Cale> rien: This is advice which applies independently of whether you have a sandbox or not.
18:17:15 <rien> Cale: how rare would you say for one to find oneself needing a certain array of packages that together won't resolve (because each needs conflicting versions of dependencies) ?
18:17:15 <mgomezch_> you can usually just modify your .cabal file and say cabal install --only-dependencies
18:17:18 <Lokathor> if you can't get it to work with a fresh sandbox you've got a real problem on your hand
18:17:21 <mgomezch_> and then it usually installs what you need
18:17:26 <mgomezch_> only the new package, that is
18:17:30 <rien> Lokathor: sounds reasonable
18:17:35 <kern_chicken_pan> I'm trying to work out which web framework to go with. Tbh, i'm more interested in which is best maintained than what is theoretically best, I need to ramp up my development pretty quickly
18:17:42 <Cale> rien: I don't know, it only happens once in a blue moon for me, but for some people it happens all the dang time.
18:17:43 <rien> mgomezch_: I'll take that route when things don't work :)
18:17:48 <ion> Cale: I'd say fromJust is still a bad idea when you're sure the value is going to be a Just. (\ ~(Just x) -> x) will give a useful message when your assumption fails due to a bug.
18:17:52 <Cale> rien: It really depends on which dependencies you're using.
18:18:00 <Cale> ion: That's true
18:18:05 <rien> Cale: are those people usually hovering around certain libraries? like TH?
18:18:12 <kern_chicken_pan> I'm thinking between Snap and Yesod perhaps?
18:18:24 <Cale> rien: Not TH as far as I know. Mostly the big web frameworks.
18:18:37 <mgomezch_> kern_chicken_pan: those are probably the most popular and maintained, yeah.  but theyre quite different in their approach.
18:18:40 <rien> Cale: hm. I'm using snap :/
18:19:20 <rien> kern_chicken_pan: snap is very simple, I like it. Yesod is more like rails in the sense that it's more magical. not my cup of tea.
18:19:24 <kern_chicken_pan> I'm open to suggestions?
18:19:31 <Cale> rien: It's just because there tend to be a lot of dependencies in such projects, so there's more individual things which can cause a problem
18:19:31 <mgomezch_> kern_chicken_pan: Yesod is complex, does a lot of things, uses lots of Template Haskell and typeclasses and abstraction and integrates with libraries for various things like databases and templating
18:19:45 <Lokathor> kern_chicken_pan, when i tried Yesod for a bit, it was slightly troublesome to set up. Once i had it set up though, it seemed pretty cool.
18:19:58 <rien> Cale: is there research into trying to solve the problem of dependencies that you know of?
18:20:08 <SrPx> Any better way to convert V2→tuple other than (\ (V2 x y) → (x,y)) vec?
18:20:16 <kern_chicken_pan> Yea I tried Yesod a couple of years ago now so I don't think I have a good representation of it
18:20:37 <mgomezch_> kern_chicken_pan: Snap is less big and complex, less monolithic, less integrated with stuff, and gives you more choices for external components (but often those choices means its up to you to integrate whatever you want to use)
18:20:45 <kern_chicken_pan> But I am looking for simple/fast dev time.. Requirements are a gui frontend to a postgresql db
18:20:47 <mgomezch_> both are great, really
18:20:52 <rien> that's why I like snap!
18:20:59 <Cale> rien: Uh, sure, but fundamentally determining what the version bounds ought to be on every package is a hard problem requiring massive computational resources that nobody has.
18:21:23 <Lokathor> i'm not sure if either provides a gui to SQL
18:21:29 <Cale> rien: Which is mostly the reason that things go wrong, because people guess at what the version bounds ought to be and sometimes they guess incorrectly.
18:21:34 <Lokathor> i think that's the SQL install's responsibility
18:21:38 <kern_chicken_pan> Lokathor: I that is what I am making
18:21:39 <mgomezch_> theres a new package for Yesod CRUD helpers
18:21:49 <rien> Cale: well I mean attacking the problem earlier than, like precompiling each component so they can have their own conflicting dependencies each?
18:21:55 <Lokathor> oh you want to make that... oh, well that should be easy enough
18:22:01 <rien> Cale: earlier than that*
18:22:36 <Lokathor> rien, GHC tends to do a lot of inlining to get good speed, rather than having a lot of dynamically loaded stuff like say Java does
18:22:41 <kern_chicken_pan> OK so i'll go with Snap then, good that was my original choice
18:22:51 <mgomezch_> kern_chicken_pan: https://github.com/league/yesod-crud
18:23:06 <Cale> rien: There are other things which cause problems in the current situation, like that GHC doesn't know how to handle more than one of any given package-version combination
18:23:35 <rien> Lokathor: not talking dynamic. just saying that if someone in the world was able to compile, say, aeson-schema 9what I'm struggling with now) then everyone should be able to compile it to. we haven't achieved that yet.
18:23:53 <mgomezch_> to be honest, if I had to develop a quick simple CRUD-type-thing for a database, Id probably use something like pythons sandman
18:23:53 <anks> Cale: thanks you were right, i tried it in ghci and forgot that it doesnt get evaluated...
18:24:01 <Lokathor> the thing you want is called "nix"
18:24:16 <mgomezch_> there isnt anything quite as quick yet in the haskell world ):
18:24:17 <kern_chicken_pan> nix is pretty awesome
18:24:27 <kern_chicken_pan> I wish there was more people working on it
18:24:28 <rien> Lokathor: yep NixOS
18:24:33 <Cale> rien: Like, if you want text-1.2.0.6 built against both deepseq-1.4.1.1 and built against deepseq-1.3.0.2, GHC can't manage the two separate copies, which sandboxes help with.
18:24:47 <kern_chicken_pan> i've sent in patches whenever I have time :/
18:25:16 <kern_chicken_pan> If you have a BladeRF you can use it with NixOS out the box now ;)
18:25:16 <dmj`> mgomezch_: I'd disagree
18:25:19 <rien> Cale: right now I'm yet to feel helped by sandboxes. I still spend most of my haskell time looking at compile screens
18:25:28 <Cale> rien: hm
18:25:57 <rien> frankly I'd pay so much money to just be able to code haskell and import whatever libraries
18:26:05 <rien> this really demotivates me
18:26:13 <mgomezch_> dmj`: is there anything like that?  the closest Ive seen is the old DBDynamic stuff in HaskellDB, but thats been bitrotting a good while
18:26:33 <Cale> rien: Do you have a specific problem you're trying to sort out right now?
18:26:46 <Cale> rien: We can try to solve it, and maybe figure something out.
18:26:53 <mgomezch_> and even that wouldnt make a frontend  itd just automate writing modules to use HaskellDB to talk to the existing database
18:27:00 <Lokathor> i think when i checked, nix was x86 only :/
18:27:00 <dmj`> mgomezch_: persistent and groundhog to name a few
18:27:15 <rien> Cale: yes, trying to get these packages installed simultaneously: https://gist.github.com/canpeter/a25e18046ada4613ce17
18:27:32 <dmj`> mgomezch_: if you want the whole thing taken care of then use postgrest
18:27:33 <rien> Cale: I'd be up to work something out, especially continuous help,
18:27:51 <dmj`> mgomezch_: but most problems aren't so easy 
18:27:52 <mgomezch_> dmj`: neither automates schema description from existing databases, and neither builds a Web GUI nor a REST API for CRUD
18:28:17 <dmj`> mgomezch_: postgrest does
18:28:20 <mgomezch_> theyre just database abstractions, nothing more.  decent ones, especially groundhog which is wonderful
18:28:22 <dmj`> not the web GUI part
18:28:35 <Cale> scientific-0.2.0.2:Data.Scientific.Scientific -- the fact that GHC seems to think package qualification is needed here is a warning sign
18:28:40 <mgomezch_> oh?  they put a web API in postgres now?
18:28:57 <dmj`> mgomezch_: no, I meant, postgrest doesn't include a web gui
18:29:01 <dmj`> to my knowledge
18:29:12 <mgomezch_> no, it doesnt. ):
18:29:25 <Cale> rien: Do you have more than one version of scientific installed?
18:29:33 <rien> Cale: I'm now for the first time trying cabal install after cabal sandbox delete, so we'll see; before, I was manually unregistering offending packages and walking backwards a lot
18:30:30 <rien> Cale: to be honest I (think) I progressed in troubleshooting that after so many unregisterings and ultimately it seemed a problem among th-lift,  th-orphans and haskell-src-meta
18:30:38 <dmj`> mgomezch_: the more magic, the less customizeable, without pain
18:30:58 <rien> Cale: I'll let you know if it still doesn't work with this now fresh sandbox
18:30:59 <mgomezch_> dmj`: theres ways to have both!  namely, good defaulting and such.
18:31:16 <dmj`> mgomezch_: sounds like a silver bullet
18:32:22 <dmj`> mgomezch_: what would the equivalent be elsewhere?
18:32:36 <Cale> rien: The version of aeson-schema you were trying to build there is itself pretty old
18:32:43 <rien> 0.8.1.0 ?
18:32:50 <rien> oh -schema...
18:32:53 <mgomezch_> dmj`: pythons sandman gets away with it by dynamically inspecting the information_schema from the database and building objects that map that to a REST API and web views and such.  its a pretty good design.  a haskell library might do something similar with TH or a code generator.
18:32:54 <Cale> rien: "Building aeson-schema-0.2.0.1..."
18:33:02 <rien> Cale: no, it kept picking that
18:33:05 <Cale> latest is 0.3.0.5
18:33:08 <rien> I never told it to pick that lol
18:33:32 <Cale> 0.2.0.1 interestingly has no (explicit) dependency on scientific
18:33:48 <Cale> while 0.3.0.5 requires scientific >= 0.3.3.7
18:33:55 <rien> Cale: good times those were :P
18:34:04 <Cale> while the error message refers to scientific-0.2.0.2
18:34:37 <mgomezch_> dmj`: HaskellDB has some old modules that do part of that: they scan a running databases information_schema and generate modules with the HaskellDB types necessary to talk to that database  and then you can write your code with those modules for the rest of the application.  in Yesod theres currently tools in development to cover the CRUD API/web views generation stuff, but you still need to provide a minimal description of the modeled data in
18:34:37 <mgomezch_>  the database.
18:35:06 <Cale> So my guess is that you have an old version of scientific installed, which caused the solver to pick an old version of aeson-schema, since you didn't say which one you wanted.
18:36:04 <rien> Cale: hm. the scientific lib was the first I unregistered which started the hunt
18:36:17 <mgomezch_> itd be nice if there was something that took an existing database and spat out Persistent definitions for all of its tables, and then yesod-crud could take that and build the web views.  but there isnt anything of the sort in the haskell world yet ):
18:36:45 <Cale> mgomezch_: Well, haskelldb has had stuff along those lines, but it's rather different.
18:36:57 <mgomezch_> Cale: and rather bitrotted ):
18:37:02 <tjscanlon> Hi everyone, is there a simpler way to write "map (funcOne) (map (funcTwo) [1,2,3])"?
18:37:21 <mgomezch_> tjscanlon: yep: map (funcOne . funcTwo) [1,2,3]
18:37:27 <rien> Cale: tjscanlon map funOne $ map funcTwo [1,2,3]
18:37:38 <tjscanlon> Awesome. I'll read up on the . operator :) Thanks everyone
18:37:38 <rien> oops
18:37:44 <Pamelloes> Is there a type of key-value collection for parameterized types where each record has a different value for the parameter?
18:37:51 <Cale> tjscanlon: (f . g) x = f (g x)
18:37:59 <Cale> tjscanlon: It's function composition
18:38:17 <Cale> tjscanlon: Or to write it another way (f . g) = \x -> f (g x)
18:38:32 <tjscanlon> Awesome!
18:38:37 <ion> tjscanlon: It's a law that fmap f . fmap g = fmap (f . g) (and map is just a specialized fmap).
18:39:08 <dfeuer> It's the law!
18:39:26 <Cale> tjscanlon: Also, note that you never need parens around a single token
18:39:42 <Cale> map (funcOne) can just be written  map funcOne
18:39:43 <Lokathor> not quite true! (+)
18:40:03 <Cale> Well, okay, putting parens around an infix operator is special syntax to make it prefix.
18:40:49 * dfeuer puts unnecessary parentheses around the arguments to the ^ operator because otherwise it just looks too weird.
18:41:16 <Cale> ?
18:41:18 <mgomezch_> (2)^(2)?
18:41:18 <dfeuer> (sin x)^2 although sin x^2 is correct.
18:41:29 <Cale> Oh, well okay :)
18:41:31 <ion> (
18:42:30 <mgomezch_> hm, you could probably support the horrible mathematical notation sin^2 x
18:42:42 <arbelos> It's kind of strange that parens are not used in textbooks for exponentiation given that it is not associative
18:42:50 <rien> or convert to rational trignomotery!
18:42:52 <mgomezch_> with some weird instance for Num, perhaps
18:42:58 <dfeuer> mgomezch, that would be really hard, since you'd need 2 to be a function, and .... ew.
18:43:05 <Cale> arbelos: Exponentiation is defined to be right-associative
18:43:05 <mgomezch_> yeah, absolute ew ;)
18:43:09 <ion> That would be parsed as sin^(2 x)
18:43:25 <arbelos> Cale.. as a convention, you mean?
18:43:27 <Cale> arbelos: yes
18:43:31 <dfeuer> mgomezch, I don't know if it could be made to work, but it would be tricksy.
18:43:47 <dfeuer> > 2^2^3
18:43:48 <mgomezch_> its a great idea for an ACME package ;)
18:43:48 <lambdabot>  256
18:44:06 <Cale> arbelos: (x^y)^z can essentially always be rewritten as x^(y*z), so x^y^z is taken to mean x^(y^z) instead.
18:44:10 <dfeuer> mgomezch, if it's possible.
18:44:56 <mgomezch_> the UnitTyped package does a lot of fun stuff with weird Num instances, IIRC
18:44:58 <dfeuer> Why do people care about free groups but not free rings (which, if I'm not mistaken, are "monoid rings" over a base ring of integers)
18:45:00 <dfeuer> ?
18:45:01 <mgomezch_> should be possible
18:45:21 <mgomezch_> probably not with the standard ^, but still
18:45:42 <dfeuer> mgomezch, yeah, because you'd need horrid fractions up there.
18:45:52 <Cale> dfeuer: I don't know whether that's a fair assessment.
18:45:53 <arbelos> Cale, the problem is when you have expressions with log and stuff and it gets confusing, but the convention is consistent, of course
18:46:19 <dfeuer> Cale, is my identification of what a free ring is incorrect, or my assessment that people don't care about them?
18:46:28 <Cale> dfeuer: That people don't care about htem
18:46:29 <Cale> them*
18:46:32 <dfeuer> Ah.
18:47:00 <m_ryan> djm`: can i ask something?
18:47:04 <dfeuer> When I searched for "free ring", I got ... nada. So even if people use that concept, they seem not to think about it that way?
18:47:10 <Cale> Try free algebra
18:47:25 <Cale> Or free Z-algebra
18:47:37 <dfeuer> Cale, I still don't understand what an algebra is :-/
18:47:45 <Cale> http://en.wikipedia.org/wiki/Algebra_(ring_theory)
18:48:11 <m_ryan> djm`: on your previous code here http://lpaste.net/132835 - you just print the Person data right? what if i like to get only the age?
18:48:38 <jasonkuhrt> Are there any good new books on Haskell?
18:48:50 <jasonkuhrt> The O'Reilly Book is almost 8 years old now
18:49:50 <Cale> jasonkuhrt: Well, this series of lectures pretty much constitutes a book, and it's widely considered to be good: http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html
18:52:32 <jasonkuhrt> Cale: Awesome thank-you!
18:53:11 <Cale> jasonkuhrt: The parts of the language which one would discuss in introductory materials haven't really changed all that much since RWH and LYAH were written, unless you consider the very recent changes to the Prelude to count in that regard.
18:53:30 <ion> m_ryan: print (age p)
18:53:43 <rien> Cale: important/significant changes?
18:54:27 <jasonkuhrt> Cale: What were those changes? Where can I read about them?
18:54:29 <Cale> rien: Well, the types of a lot of things have been generalised, Traversable and Foldable are in the Prelude for better or worse, and Applicative was made a superclass of Monad
18:54:54 <jasonkuhrt> Cale: I would prefer to learn with that foundation in mind, where possible
18:54:57 <m_ryan> ion: the print will return a string right?
18:55:06 <Cale> I suppose prior to this, but since the time that RWH was written, the superclass constraints on the Num class got removed.
18:55:07 <rien> Cale: yay for that last one :) now when will head return Maybe a ?
18:55:11 <m_ryan> ion: how about an integer type also?
18:55:15 <ion> @type print
18:55:16 <lambdabot> Show a => a -> IO ()
18:55:19 <Cale> rien: Probably never.
18:55:23 <rien> heh
18:55:29 <Welkin> I think the generalizations are more helpful for learning long-term
18:55:47 <Cale> rien: head is useful with its existing type in ways that listToMaybe is not.
18:55:54 <jasonkuhrt> Cale: Elm recently made `head` return Maybe a
18:55:55 <Cale> (btw, listToMaybe does exist)
18:56:07 <jasonkuhrt> Cale: How so?
18:56:09 <Cale> > map head . group . sort $ "mississippi"
18:56:11 <lambdabot>  "imps"
18:56:14 <Welkin> jasonkuhrt: Elm was a senior project
18:56:27 <jasonkuhrt> Welkin: senior?
18:56:32 <Cale> If head produces a Maybe, idioms like that become more awkward
18:56:34 <rien> Cale: I just find it strange to have a fundamental function be partial for seemingly no good reason. what makes it useful?
18:56:43 <Cale> head isn't particularly fundamental
18:56:44 <Welkin> when your community is that small, and the language is experimental, it is easy to make those changes
18:57:01 <jasonkuhrt> Welkin: Its not even 1.0.0 yet, that's the main point
18:57:10 <mgomezch_> it wont get any easier in Haskell!
18:57:20 <ronh-> Cale I could live with extra fromJust in cases like that
18:57:37 <Cale> rien: There are many cases where you *know* that a search which is expressed in the form of a list is going to succeed, and you only want one match.
18:57:39 <Welkin> jasonkuhrt: undergraduate project
18:57:44 <mgomezch_> *if* this sort of change is to ever be made on Haskell, the best moment to do it is as soon as possible (with appropriate deprecation cycles and such)
18:57:47 <jasonkuhrt> Cale: It has been interesting to follow Elm, in that, they try to harness the power of Haskell (bias toward domain of graphical apps) without bringing in any undue complexity
18:58:30 <ion> > map (\ ~(x:_) -> x) . group . sort $ "mississippi"
18:58:31 <m_ryan> ion: how about an integer type instead of print?
18:58:32 <lambdabot>  "imps"
18:58:43 <jasonkuhrt> Cale: Consistenty matters, and I can say that as  newcomer I found the fact that `head` throws more confusing than now
18:58:43 <Cale> ion: lovely :P
18:58:45 <jasonkuhrt> than not*
18:58:45 <rien> Cale: I see. sure maybe there are case that you know for sure. I still feel like I'm giving up safety doing that (or rather, introducing potential bugs).
18:58:54 <jasonkuhrt> Cale: But maybe you are suggesting in the long-term it is better
18:59:08 <jasonkuhrt> I agree with rien
18:59:12 <ion> m_ryan: print works on Integer. Try print 42 in ghci.
18:59:16 <Cale> jasonkuhrt: As a beginner, you should mostly avoid using head altogether, that's reasonable.
18:59:20 <jasonkuhrt> Its this awkward moment where Haskell does something that belongs in the world of JavaScript
18:59:23 <m_ryan> > print 42
18:59:25 <lambdabot>  <IO ()>
18:59:43 <rien> Cale: I didn't know about listToMaybe though so that's nice to know
18:59:59 <Cale> Haskell is not designed to be a total language, or even for it to be a reasonable proposition to write only total functions in Haskell.
19:00:09 <Cale> You're missing a lot of the machinery which would make it reasonable.
19:00:15 <rien> jasonkuhrt: so true hahah
19:00:16 <ronh-> rien there's a safe package that replaces a bunch of non-total functions from prelude. headMay, readMay etc
19:00:28 <jasonkuhrt> Cale: Maybe a would force developers to deal with errors that can happen, if you you know that that list is safe then you should opt into listToJust or whatever
19:00:28 <mgomezch_> still, avoiding partial functions is good practice if you want to avoid hard-to-track runtime errors
19:00:30 <Cale> You kind of need dependent types if you're going to require totality from all your functions
19:00:53 <rien> ronh-: cool, will check it out
19:01:05 <Cale> Because you'll need to come up with proofs that things are going to succeed.
19:01:13 <mgomezch_> theres many forms of partiality.  the more obvious can be avoided completely.
19:01:24 <Rotaerk> are dependent types still considered an experimental thing?
19:01:48 <Cale> Rotaerk: I dunno, yes? No? There are very mature implementations of dependently typed systems.
19:02:00 <Cale> Rotaerk: But they're mostly in the form of proof assistants.
19:02:25 <Rotaerk> are there any languages with them, or that will be getting them, which are actually usable for software dev?
19:02:35 <rien> Idris?
19:02:36 <Cale> Rotaerk: Idris is an attempt at a dependently typed language which is useful for everyday sorts of programming -- it's kind of experimental still, but it's getting more mature.
19:02:42 <Rotaerk> hmm k
19:03:02 <Cale> And even Idris doesn't try to force totality on you (but it has a totality checker you can use)
19:03:32 <jasonkuhrt> I'm very pleased to see the new rash of books from Manning https://wiki.haskell.org/Books
19:03:33 <jasonkuhrt> Wow
19:03:38 <jasonkuhrt> All Manning all the way?!
19:03:52 <Cale> The logical extension of "head is dangerous, let's not allow that kind of thing" is proving that all your functions terminate.
19:03:56 <mgomezch_> totality checking is one thing, but theres benefits to be had from avoiding partial ADT field accessors
19:04:04 <rien> Cale: having a totality checker but not being forced to use it sounds dreamy tbh
19:04:11 <mgomezch_> thats a slippery slope fallacy there, Cale!
19:04:27 <mgomezch_> there are useful middle points that are effective for practical software engineering
19:04:29 <Cale> mgomezch_: I'm not saying that head should be used all over the place.
19:04:42 <rien> Cale: I disagree. it feels silly to me to put so much effort into learning Haskell to be safe only to give it up in the most silly operation possible
19:04:53 <m_ryan> > print 42
19:04:54 <lambdabot>  <IO ()>
19:04:58 <Cale> mgomezch_: I'm saying it belongs in the library because one needs it frequently enough, in the non-total style of programming that we're sort of committed to.
19:05:02 <jasonkuhrt> Has anyone read or know someone that has read http://www.apress.com/9781430262503
19:05:03 <jasonkuhrt> ?
19:05:07 <Welkin> you can make head safe by having it produce a Maybe
19:05:08 <rien> I want to offload as much as possible onto the compiler
19:05:14 <Welkin> or just avoid head by pattern matching instead
19:05:44 <mgomezch_> Cale: I agree, but Id prefer if it was called unsafeHead ;)
19:05:45 <Cale> I don't use the head function all that often, and neither should you, but it comes up often enough that I think it's worthwhile having it defined.
19:05:49 <Cale> No, that's pointless.
19:05:54 <jasonkuhrt> Welkin: If you use pattern matching then the `else` clause at the end becomes the fork in logic correct?
19:05:59 <Cale> unsafeHead is literally longer than the definition of the function.
19:06:06 <Welkin> jasonkuhrt: what else?
19:06:23 <mgomezch_> unsafePerformIO is useful enough when it happens to be useful, but its great that its so heavily discouraged that its very name is a warning not to use it
19:06:24 <jasonkuhrt> Welkin: usually refered to as `otherwise` right? Just equal to `true`
19:06:33 <Cale> If you're willing to type unsafeHead, you should just type (\(x:_)->x) instead, and you'll get better error messages when it fails.
19:06:54 <Welkin> sure, but you can have multiple paths
19:07:01 <jasonkuhrt> Welkin: You said pattern matching is the other approach in various cases (not composition cases though)
19:07:05 <Welkin> otherwise is just the catch-all
19:07:13 <jasonkuhrt> Welkin: Yes of course but I just mean in the most basic case
19:07:21 <mgomezch_> Cale, its a lot easier to type, read and understand a common word than a lambda with a nontrivial pattern-match
19:07:35 <jasonkuhrt> Welkin: You could mimic Maybe with a pattern match of either a head value or `otherwise`
19:07:37 <Cale> mgomezch_: head and unsafePerformIO are in entirely separate classes of unsafety
19:07:38 <jasonkuhrt> effectively
19:07:47 <Welkin> you can match the list against (x:[])
19:07:58 <Welkin> or, [x]
19:08:02 <Welkin> then you know it has only one element
19:08:23 <jasonkuhrt> Love the pattern matching in haskell
19:08:38 <jasonkuhrt> pattern-matching types is one of my favourite features as a newbie
19:08:38 <Cale> mgomezch_: Would you rather fix be called unsafeFix?
19:08:40 <napping> are you trying the new pattern synonyms?
19:08:54 <jasonkuhrt> napping: ?
19:08:54 <Cale> After all, it's easy to write lots of functions whose denotation is _|_ with fix
19:08:58 <Welkin> (x:_) has at least one element
19:09:05 <m_ryan> hi what does this error means? No instance for (Show a0) arising from a use of print? 
19:09:19 <mgomezch_> Cale, good point.  still, its common in Haskell to try to reason about pure functions as if there was no such thing as partiality.  the type system wont give any protection there as itd have to be fully dependent and total, but nonetheless the intuition many Haskell programmers apply is fast and loose w.r.t. bottoms, and trivially partial functions break that intuition for very little gain!
19:09:21 <Welkin> m_ryan: the ting you tried to print doesn't have a Show instance
19:09:23 <KaneTW> the function you're trying to print has no Show instance.
19:09:29 <KaneTW> eh, thing
19:09:30 <Welkin> m_ryan: it means exattly what it says
19:09:42 <Welkin> exactly*
19:09:42 <ronh-> :t print
19:09:44 <lambdabot> Show a => a -> IO ()
19:09:52 <ronh-> your "a" isn't "Show a"
19:10:08 <Welkin> :t show
19:10:10 <lambdabot> Show a => a -> String
19:10:15 <napping> jasonkuhrt: https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms
19:10:40 <m_ryan> Welkin: it goes here "print 0"
19:10:44 <Cale> mgomezch_: I don't know. I guess I just disagree on the basis that there are plenty of idioms involving functions such as head which are provably safe.
19:11:33 <Cale> mgomezch_: You might argue that functions such as group shouldn't produce a list of lists, but instead a list of pairs of elements and lists or something
19:11:46 <Cale> mgomezch_: But that's inconvenient in other cases
19:12:02 <mgomezch_> Cale, Id wager if avoiding trivial partiality were more common, there would be other equally convenient idioms without trivially partial functions
19:12:11 <m_ryan> Welkin: here is the code; case M.lookup country cache of Nothing -> print 0 Just p -> print (ctr p)
19:12:46 <napping> Cale: ideally you could supply the proofs
19:13:04 <Welkin> m_ryan: how do you print 0?
19:13:07 <Cale> napping: maybe ideally, maybe that would be obnoxious.
19:13:19 <Cale> napping: It depends on the situation.
19:13:19 <Welkin> do you mean to print "0"?
19:13:21 <ronh-> m_ryan what does ctr p return
19:13:32 <Big_G> What is the easiest way to make a REST call in Haskell?
19:13:48 <mgomezch_> Big_G: the wreq library is rather nice
19:14:11 <napping> Cale: it's hardly ideal to think you've proved something safe, and have no automatic checks that it remain that way
19:14:13 <m_ryan> ronh-: it returns an Integer type data base on my data PriceCtr = PriceCtr { ctr :: Int} deriving (Show, Eq)
19:14:15 <Cale> napping: Being required to supply a proof in a case like  map head . group . sort  or the many sorts of variations on that is going to be really annoying, I'd wager.
19:14:34 <mgomezch_> Big_G: http://www.serpentine.com/wreq/
19:14:46 <Big_G> mgomezch_, Is that meant to be in conjunction with wai and wrap
19:15:26 <mgomezch_> Big_G: nope, its for making HTTP requests as a client  wai and warp have to do with writing HTTP servers
19:16:16 <Lokathor> gonna try installing GHC 7.10
19:16:28 <Cale> napping: Of course, I'd love for us to have the option of totality and the dependent types needed to be able to provide such proofs :)
19:16:37 <Big_G> mgomezch_, Just to make sure. wai and warp are for creating REST endpoints. wreq is for hitting rest endpoints
19:16:40 <napping> it would be as explicit arguments, but some kind of inference might work, or just explicitly supplying a default proof script like Coq's Program Definition
19:16:50 <mgomezch_> it *does* use Michael Snoymans http-client package though
19:17:06 <mgomezch_> which is of course related to wai/warp
19:17:17 <mgomezch_> Big_G: precisely
19:17:35 <napping> You've seen the Agda trick for making Fin values?
19:17:47 <Big_G> mgomezch_, You probably saved me several days. Thanks
19:17:49 <Cale> napping: But I think in order to keep the language usable down in the range of programs which are under 5 lines, you kind of want to be able to ignore that kind of concern.
19:18:25 <mgomezch_> Cale: sounds like perls design criteria ;)
19:18:29 <napping> so then you do go for unsafeHead, or some kind of Solve Obligations By trustMe
19:18:50 <Cale> I've written some programs with 10000 lines of code, but I've written many more programs (almost on a daily basis) which are about 1 line of code.
19:18:53 <jasonkuhrt> is there  a roadmap for future Haskell features?
19:19:05 <Cale> and I think it's good that Haskell works well for both of these cases
19:19:18 <Cale> and would be incredibly frustrated if it stopped working in the small cases
19:19:19 * hackagebot timeconsole 0.1.0.0 - Time commands by lines of STDOUT  http://hackage.haskell.org/package/timeconsole-0.1.0.0 (AlanHawkins)
19:19:32 <Cale> where I'm basically just using it as a fancy calculator
19:19:35 <mgomezch_> jasonkuhrt: theres the GHC roadmap https://ghc.haskell.org/trac/ghc/roadmap
19:20:22 <rien> Cale: it compiled now with the new sandbox. :) glad to know this technique now, thanks
19:20:30 <napping> Cale: I doubt that needs more than careful language design
19:21:32 <Cale> napping: Well, "wouldn't it be great if head required that you pass an argument which is a proof of nonemptiness of the list" is exactly the sort of thing which ruins programming in the small
19:22:17 <Cale> I mean, sure, in real world applications which need to be reliable, it's fair that I might want to provide such a proof to be careful.
19:22:22 <napping> so you do things like makeing that an implicit argument
19:22:39 <Cale> Making it an implicit argument doesn't prevent the proof obligation.
19:22:50 <Cale> You'll just get an error that no such proof is in scope.
19:23:08 <mgomezch_> theres other languages for that
19:23:29 <Cale> What other languages?
19:23:45 <Cale> There's other languages if you really want to be able to prove totality everywhere!
19:23:52 <napping> depends what kind of inference you have, but even so, have something like -fdefer-obligation-failures, and you're back to a nice calculuator
19:24:05 <Cale> Haskell is actually pretty ill-suited to that kind of programming
19:24:08 <napping> or maybe partition total and partial languages, and have some kind of overloading between them
19:24:14 <ion> Ooh, type signature sections in 7.12? Nice
19:24:22 <napping> "sections"?
19:24:38 <mgomezch_> thats what I mean  if you want that, use Agda, Coq, Idris
19:24:42 <Cale> Because there's no convenient way to express things like "the type of proofs that a list is not empty"
19:24:45 <napping> this is more than fancier type signatures?
19:24:46 <Cale> In Haskell
19:25:22 <napping> Of course not, without dependent types
19:25:41 <napping> But Haskell does seem to be working towards that sort of type system without compromising inference
19:25:46 <Lokathor> update: it seems that you can't actually get ghc 7.10 fully up and running via apt-get :/
19:25:58 <napping> ion: link
19:26:01 <ion> napping: (:: T) = (\x -> x :: T)
19:26:12 <napping> oh, sections of type annotations
19:26:14 <ion> https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-7.12.1
19:26:31 <napping> that looks nice
19:26:35 <Pamelloes> Can someone help me understand how you can use forall in other places than the start of a function and still get a useful result?
19:27:17 <dfeuer> Dependent types definitely seem cool. However, Haskell type classes are also really cool, and I don't think anyone's been able to figure out how to combine them with dependent types properly.
19:27:18 <Cale> With all this said, I really *would* like to see a lazily-evaluated-by-default dependently typed language with Haskell-style type classes.
19:27:32 <dfeuer> What Cale said.
19:27:43 <Cale> dfeuer: I don't think it's all that hard, it's just engineering effort.
19:28:17 <Cale> dfeuer: It's way too tempting, especially for research languages such as Idris, to just implement type classes using the system of implicit parameters which the language already sort of needs to have.
19:28:38 <Cale> I can understand why they do it that way, but I really would like for someone to put in the effort.
19:29:05 <dfeuer> Cale, I don't *think* it does that. But it doesn't enforce, and therefore doesn't assume, coherence, which makes everything much more painful.
19:30:21 <dfeuer> In fact, I'm pretty confident the class resolution mechanism is separate from the implicit-resolution stuff.
19:30:23 <Cale> If your language already has something like a feature which lets you say "look for something of the appropriate type in scope in order to fill this parameter automatically", it's really easy to get a cheesy version of type classes bootstrapped.
19:30:58 <dfeuer> But implicits are so ... nice when they're nice and painful the rest of the time.
19:31:31 <Lokathor> "Support for Applicative Do, allowing GHC to desugar do-notation to Applicative where possible." Is this for when you have an Applicative that isn't a Monad but you want do-notation anyway?
19:31:46 <dfeuer> Having to look up the *name* of an argument when it needs to be passed explicitly is particularly not-nice, but in Idris at least things are also entirely broken for higher-order stuff with implicits.
19:31:52 <Cale> Lokathor: Also for when your Applicative instance disagrees with the Monad instance
19:31:55 <mgomezch_> Lokathor, yep
19:32:09 <mgomezch_> Cale: which should never happen!
19:32:12 <napping> Cale: Coq's version of things doesn't just look for values in scope
19:32:12 * dfeuer does not approve of using the same syntax.
19:32:13 <pacak> Lokathor: In some cases  using applicative instances can be more efficient even if you have monad instance.
19:32:21 <Cale> In fact, I believe they have a Monad instance in the case which inspired the extension, it just disagrees with the Applicative.
19:32:31 <Lokathor> ahhh
19:32:39 <Cale> mgomezch_: I'm not certain I 100% agree about that.
19:32:42 <mgomezch_> dfeuer, why?
19:33:10 <dfeuer> mgomezch, because it seems too wild, and to mix layers.
19:33:26 <napping> dfeuer: adding lots of type parameters can maybe fix safety, but I don't know anything that tries very hard for coherence
19:33:45 <Cale> I've run into at least one case where I had something which was almost an Applicative and almost a Monad at the same time, in ways that would conflict. (I didn't *quite* have either in that case, so it didn't really matter, but with a little effort, I probably could have..)
19:34:15 <Cale> This comes up in cases where you have something like a library of UI widgets
19:34:16 <dfeuer> napping, there's also the problem that you really only want coherence up to some notion of irrelevance, probably, and when something is irrelevant, you want it to resolve to whatever it can find first....
19:34:34 <Cale> where <*> is going to run both widgets in parallel and combine their results in an obvious way
19:34:35 <dfeuer> Cale, well, that's what newtype is for.
19:34:47 <dfeuer> Oh, parallel/serial. Yeah, that's legit.
19:34:51 <Cale> while >>= sort of needs to restart the second widget
19:35:02 <Cale> every time the output of the first changes
19:35:07 <ion> async’s Concurrent had a disagreeing Monad instance for one release but they removed it.
19:35:22 <dfeuer> The semantics really need to be the same for sanity,
19:35:29 <dfeuer> but implementations can be very different.
19:35:36 <Cale> It's not just about performance
19:35:47 <Cale> I don't really agree with ApplicativeDo though
19:36:15 <napping> dfeuer: type parameters let you do things like index maps with the ordering, but you can't get functional dependencies just by adding indices
19:36:22 <dfeuer> If it's not about performance, use newtype.
19:36:53 <Cale> I think maybe there ought to be cases where the Applicative and Monad instances disagree semantically, but I think training users to ignore the distinction through making the do-syntax cleverer would be inappropriate in that case.
19:36:58 <dfeuer> napping, I've never really gone as far as dealing with fundeps. 
19:37:00 <jasonkuhrt> Does anyone here fluent with Go?
19:37:16 <dfeuer> Cale, whyyyyyyyyy?
19:37:50 <dfeuer> <*> = `ap`; pure = return. That's the law.
19:37:56 <Cale> dfeuer: Well, think about my widget example.
19:38:19 <dfeuer> jasonkuhrt, I've played a little Go, but it was quite a while ago, and I never really learned the game properly. I tended to lose even with a significant handicap.
19:38:23 <Cale> <*> literally cannot be ap in that case
19:38:47 <jasonkuhrt> dfeuer: I was actually referring to the programming langauge but... ; )
19:38:51 <Cale> It has distinct semantics which is impossible to express using >>= as a primitive
19:39:01 <jasonkuhrt> dfeuer: Good point, I should have clarified!
19:39:01 <dfeuer> Cale, why not? Can't you use a newtype to make your Monad interface, or the other way around?
19:39:12 <Cale> But there's *also* a valid Monad instance for the same type
19:39:21 <dfeuer> OK... so ... newtype.
19:39:28 <Cale> You could, but maybe you don't want to cripple the usability of your library?
19:39:44 <dfeuer> No.
19:39:50 <dfeuer> :P
19:39:52 <Cale> Introducing newtype constructors everywhere just because the Applicative and Monad instances disagree a bit is a bit crazy
19:40:01 <mgomezch_> then you provide combinators that convert things comfortably
19:40:22 <dfeuer> You could also use your own copy of Applicative or Monad, I suppose....
19:40:32 <dfeuer> But that's crazier.
19:40:36 <mgomezch_> and typeclasses to abstract where it doesnt matter
19:40:46 <Cale> Maybe people think about it differently than I do, but when I define a Monad instance, it's just because something *happens* to be a Monad
19:40:47 <dolio> As far as I know, there's nothing incompatible about type classes and dependent types. All the dependently typed language authors just chose not to implement type classes.
19:40:59 <Cale> I never set out to define a monad
19:41:11 <pacak> :t cofmap
19:41:13 <lambdabot>     Not in scope: ‘cofmap’
19:41:13 <lambdabot>     Perhaps you meant one of these:
19:41:13 <lambdabot>       ‘fmap’ (imported from Control.Monad.Writer),
19:41:17 <pacak> :(
19:41:18 <Cale> Sometimes things happen to be both an Applicative and a Monad in ways which can't be compatible.
19:41:29 <ion> pacak: contramap
19:41:31 <dolio> And they chose to have modules more like ML's, which are hard to reconcile with type classes.
19:41:31 <Cale> and the Applicative structure is important
19:41:40 <mgomezch_> pacak, https://hackage.haskell.org/package/acme-cofunctor
19:41:56 <pacak> mgomezch_: Yea, but lambdabot is not aware of it's existence....
19:41:57 <m_ryan> hi is there any way to update a json?
19:42:00 <dfeuer> Cale, sure, but a *lot* of people assume that if they have a Monad, then they can use Applicative stuff with it whenever they like and get the right semantics. If you break that, you will confuse the heck out of everyone.
19:42:01 <Cale> So I dunno. I can see how *as a rule of thumb* you should try to make it the case that (<*>) = ap
19:42:04 <m_ryan> hi is there any way to update a json data?
19:42:04 <mgomezch_> indeed ):
19:42:16 <Cale> but I can see room for cases where it makes sense to break that rule of thumb
19:42:21 <pacak> m_ryan: Sure
19:42:38 <Cale> dfeuer: People should be careful about whether they're using Monad or Applicative
19:42:43 <dfeuer> dolio, do you think you could hack up a dependently typed language with classes tonight? I'd like to see what it looks like :P
19:42:46 <pacak> > map toUpper "{object: 1}"
19:42:48 <lambdabot>  "{OBJECT: 1}"
19:42:48 <mgomezch_> Cale, its more than a rule of thumb  its a fundamental assumption of the meaning of those typeclasses, just like fmap id being the same as id
19:42:58 <Cale> mgomezch_: I'm not sure I agree
19:43:04 <exio4> fmap id = id is one of the functor laws
19:43:07 <Cale> mgomezch_: It certainly doesn't have to be.
19:43:07 <dolio> That's not a one-night project.
19:43:24 <Cale> fmap id = id is part of the mathematical definition of a functor
19:43:25 <m_ryan> pacak: how? can you help me for example i have Person {name: "me", age: 21} -> i want to update my age to 22.
19:43:35 <Cale> (<*>) = ap is not part of the mathematical definition of anything
19:44:04 <napping> Cale: why don't you think so?
19:44:08 <mgomezch_> its part of the mathematical definition of monads and applicative functors!
19:44:09 <Cale> Applicative functors (i.e. monoidal functors) don't usually come with assumptions regarding a corresponding monad
19:44:22 <Cale> and vice versa
19:44:22 <pacak> m_ryan: If you have lens it will look something like "over age (+1) person", there's away to get age lens from aeson package
19:44:48 <dfeuer> Cale, be that as it may, the law is in the documentation of the Applicative and Monad classes in Haskell.
19:45:03 <Cale> dfeuer: Perhaps, but I don't think it necessarily ought to be?
19:45:11 <Cale> dfeuer: I can see why you'd want it.
19:45:16 <m_ryan> pacak: what is lens?
19:45:18 <Cale> dfeuer: But I don't know that it's really the best idea.
19:45:38 <dfeuer> Cale, I don't know either, but I am thoroughly convinced that it is too late to change without breaking everyone's brain as well as code.
19:45:54 <Cale> dfeuer: I've run into a handful of cases where at least *I* was reasonably convinced that it would be a good idea for the Applicative and Monad instances not to coincide.
19:45:58 <pacak> m_ryan: https://ro-che.info/ccc/images/lens.png
19:46:19 <dolio> In what way would they not coincide?
19:46:44 <pacak> m_ryan: Some enormous library
19:46:58 <napping> Cale: insisting on a strong monad wuld make the definition more similar
19:46:59 <m_ryan> thank you.. :-)
19:47:03 <dfeuer> Cale, what it boiled down to is that there is a way to turn *any* Monad into an Applicative, which gives you a "natural" sort of subclass relationship, assuming they are compatible.
19:47:08 <haskell323> I am getting an error regarding constraints
19:47:08 <Cale> dolio: Typically it involved some notion of concurrency (if not actual concurrency, then that sort of idea)
19:47:10 <haskell323> Expected a constraint, but `Double' has kind `*'     In the type signature for `myFitness':       myFitness :: Double => Int -> E -> Double Failed, modules loaded: none.
19:47:10 <dfeuer> napping, what's that?
19:47:14 <pacak> m_ryan: look for aeson lens examples
19:47:23 <pacak> m_ryan: I've seen some 
19:47:24 <haskell323> Anybody can help me that?
19:47:29 <dfeuer> haskell323, well, you can't put Double on the left side of a =>
19:47:38 <Cale> dolio: Where you could get an Applicative instance whereby the execution of  f <*> x  would entail the computations f and x "running at the same time"
19:47:38 <dfeuer> What did you actually mean?
19:47:50 <dolio> Cale: In that case, I expect it'd probably be allowed in the spirit of the rules that exist.
19:47:54 <Cale> dolio: and you could also get a Monad instance for the same type, but it would have different semantics
19:48:03 <haskell323> I am running an example on this webpage: https://hackage.haskell.org/package/genprog-0.1/docs/GenProg.html
19:48:27 <dfeuer> Cale, is there a sense in which they are the same up to an equivalence that is all that matters?
19:48:29 <deezn> guys I am getting an error doing this.. what is the correct syntax: any (True==) [(fml (Con j) | j <- xxs]
19:48:30 <Cale> Where x >>= f would essentially keep x running, supplying a stream of results, and the computation in f would be restarted each time the output from x changed.
19:48:34 <napping> dfeuer: this looks okay: http://en.wikipedia.org/wiki/Strong_monad
19:48:41 <dolio> It's okay if (<*>) is more efficient than ap, or maybe computes some different answer that you intend to quotient over when you inspect the results.
19:48:43 <Cale> dfeuer: No, they're essentially different, and you might want both.
19:48:49 <dfeuer> napping, I very very rarely find Wikipedia articles on mathematics to be okay.
19:49:18 <pacak> haskell323: That example looks bogus to me. try myFittness :: Int -> Double -> Double as a type signature
19:49:32 <Cale> s/the computation in f/the computation which was the result of applying f/
19:49:33 <deezn> ops missing a bracket.. but types are still off brb
19:49:38 <haskell323> lol. ok. let me try that
19:49:39 <mgomezch_> deezn: any (True==) is the same as all, I think  and you have an extra opening parenthesis right where the list comprehension begins\
19:49:43 <dolio> But choosing (<*>) = zip and ap = cartesian product is not.
19:49:52 <Cale> mgomezch_: You mean or
19:49:54 <pacak> haskell323: Or maybe you need to have some extra LANGUAGES pragmas
19:49:58 <Cale> not all
19:50:21 <mgomezch_> oops, yes
19:50:22 <mgomezch_> or
19:50:24 <mgomezch_> not all
19:50:31 <napping> dfeuer: well, it has the diagrams. a strength (a, m b) -> m (a, b) is the main thing
19:50:31 <mgomezch_> deezn, or, not all, sorry
19:50:36 <exio4> that seems to be equivalent to any (\j -> fml (Con j)) xss
19:50:41 <haskell323> pacak: like?
19:50:50 <dfeuer> pacak, I don't think any pragmas will turn a Double into a Constraint!
19:51:11 <Cale> dolio: I just think there are cases where it makes sense for the instances of Applicative and Monad to disagree, and so question that ap should always semantically be equivalent to <*>
19:51:13 <dfeuer> napping, what is a "strength"?
19:51:22 <pacak> dfeuer: You never know. Maybe there is something like {-# LANGUAGE TurnDoubleIntoConstraint #-}
19:51:23 <napping> as far as I know, a function with a type like that
19:51:40 <napping> or in general, some kind of "playing nice" with a product
19:52:01 <mgomezch_> Cale, it just sounds like that domain has more than one applicative structure.  thats what newtypes are for.
19:52:21 <dfeuer> pacak, there is not. The only sane way to move between things of kind * and things of kind Constraint is using the reflection package, which does unspeakably horrible things behind the scenes.
19:52:27 <Cale> mgomezch_: That creates notational hassle that you might not want influencing the design of your library
19:52:42 <Cale> mgomezch_: after all, I'm only defining the instances because I can, not because I have to.
19:52:53 <napping> dfeuer: here you go: http://ncatlab.org/nlab/show/monoidal+monad
19:52:54 <haskell323> Running it without double gives other errors. 
19:53:03 <pacak> haskell323: They mention some pragmas.
19:53:13 <mgomezch_> Cale, can it not be avoided with typeclasses to generalize what can be structure-agnostic, and syntactically convenient conversions?
19:53:17 <haskell323> Runnin it with  {-# LANGUAGE TurnDoubleIntoConstraint #-} prompts unsupported extension
19:53:42 <dfeuer> haskell323, pacak was making a joke. There is no such pragma.
19:53:46 <napping> and in Haskell you pretty much can't avoid having a "tensorial strength", and I'm pretty sure Applicative is more or less "lax monoidal functor"
19:53:53 <mgomezch_> Cale, strong type systems are likewise full of inconvenience for numeric code, yet there are often benefits of such strictness!
19:54:00 <Cale> mgomezch_: I could just avoid using Applicative and Monad altogether and define my own combinators with their own names, and reimplement the corresponding libraries.
19:54:03 <Cale> mgomezch_: But why?
19:54:05 <pacak> dfeuer: I wouldn't call stuff in reflection unspeakable  horrible. They are more like exciting and fun.
19:54:11 <dfeuer> napping, that's all going right oer my head. I don't even know what a tensor is.
19:54:28 <napping> Cale: I hope you are not arguing for just ignoring documented laws of typeclasses
19:54:32 <mgomezch_> Cale, because users have a natural expectation that the instances agree, because thats what the classes mean!
19:54:33 <haskell323> lol ok.
19:54:57 <napping> gathering examples to suggest changing definitions is all good
19:55:09 <Cale> napping: Well, I'm sort of arguing against one particular law of one particular *pair* of type classes. The laws of these type classes individually, I have no worry about.
19:55:25 <dfeuer> pacak, you think unsafeCoerce to change *kind* is exciting and fun? There's a reason that package may end up moving into ghc-prim!
19:55:32 <napping> the laws relating one class to its superclass, you mean?
19:55:40 <Cale> Yes.
19:56:06 <dfeuer> Cale, I assume you opposed AMP, then?
19:56:13 <Cale> Applicative ought to be a superclass of Monad because whenever you have a Monad structure, you can always get at least one Applicative structure.
19:56:28 <pacak> dfeuer: Sure, it would fit better in ghc-prim, but the fact that you can do this is nice.
19:56:33 <napping> and you've got some handy examples where it makes sense for foldMap to disagree with the result of traverse with Const?
19:56:36 <Cale> Requiring that the Applicative structure coincide with the Monad structure in all cases? That I'm less sure about.
19:57:05 <Cale> napping: I don't even believe in foldMap :P
19:57:09 <mgomezch_> Cale, you cannot have more than one instance of Applicative for something that has an instance of Monad, due to coherence.
19:57:16 <pacak> dfeuer: If you don't  want to use approach from refrection pacakge itself - you can always look at the original paper. That's less exciting :)
19:57:22 <Cale> Foldable is ugly and I've yet to be convinced otherwise
19:57:31 <mgomezch_> Cale, it therefore makes sense for the one instance there *always* is to be *the* instance
19:57:51 <Cale> mgomezch_: hm?
19:58:14 <Cale> mgomezch_: This doesn't appear to me to have anything to do with coherence of instance selection
19:58:25 <Cale> Sure, you always get the same Applicative instance.
19:58:33 <haskell323> removing double gives bunch of other errors.
19:58:35 <napping> if there's a canonical way to make an Applicative from a Monad
19:58:39 <Cale> It just happens not to be equivalent to the one which *isn't written*
19:58:53 <dolio> It has to do with coherence of other constructs. Or will in the near future.
19:58:59 <Cale> hm?
19:59:01 <mgomezch_> should not the one that can always be written indeed always be written?
19:59:05 <dolio> do is going to start desugaring to applicative combinators when possible.
19:59:06 <Cale> dolio: Of what?
19:59:11 <napping> and use a newtype for another structure
19:59:20 <Cale> mgomezch_: That's exactly what I'm questioning!
19:59:37 <ion> haskell323: Maybe the => is just a typo for ->
19:59:38 <dolio> So you'll get completely different answers based on things that look very similar.
20:00:20 <napping> can haskell-mode or ghci handle multiple source directories?
20:00:24 <Cale> mgomezch_: There have been multiple cases throughout the time I've been programming in Haskell where the most useful Applicative instance on a type didn't coincide with the most useful Monad instance on a type. Usually in cases where the Monad instance was sort of a second class citizen as far as utility was concerned, but it was law-abiding
20:00:52 <mgomezch_> Cale, given that the overwhelmingly common case is for the applicative structure of a type to coincide with the one induced by its monad instance when both exist, it would be terribly counter-intuitive for library users to stumble upon exceptions to such a natural situation.
20:01:17 <napping> Cale: in that case, make the main type Applicative, and make a newtype if you care to define the Monad
20:01:25 <Cale> mgomezch_: Maybe if you've never seen such a thing before, you would be surprised by it, sure.
20:01:26 <mgomezch_> that sounds like you couldve newtyped the one with the monad instance with little loss of convenience (:
20:01:48 <haskell323> Nope. that does not work either
20:01:52 <Cale> I was a bit surprised the first time I ran into such a thing, and my *initial* reaction to the situation here was pretty much the same as everyone else's.
20:01:54 <johnw> I'd be surprised if I couldn't immediately reason about the similarity of a *> b and a >> b
20:01:54 <dolio> Cale: Also, it's quite likely that mapM on lists will suddenly become traverse in 7.10.2. So that will completely change the meaning of some of your code if that happens.
20:01:58 <mgomezch_> Ive stumbled upon such things in the context of modeling actor computations (: but I newtyped
20:02:09 <Cale> dolio: blah
20:02:46 <dolio> And in fact, that could happen at any time in any library.
20:03:05 <mgomezch_> I, for one, welcome our new cross-typeclass algebraic law overlords.
20:03:12 <Cale> dolio: Fortunately, most of the code I'm referring to is far enough in the past that it's already likely broken.
20:03:17 <dolio> Because someone might write something with a Monad constraint, and then notice that they could implement something with an applicative combinator instead of monad ones.
20:03:33 <Cale> (especially as it contains a lot of Arrow code with infix type variables)
20:04:00 <mgomezch_> I was saddened by that lexical change
20:04:09 <mgomezch_> I liked them squiggly arrows
20:04:15 <Cale> I did too
20:04:19 <dolio> So, to have your way, everyone has to assume everywhere that applicative operations are completely different from monad ones.
20:04:28 <Cale> dolio: yes
20:04:33 <Cale> dolio: I realise this is the case.
20:04:40 <jasonkuhrt> In haskell why do clauses require parens such as: with `intListLength (x:xs) = 1`
20:04:43 <napping> Cale: do you disagree with the mathematical definitions I pointed to?
20:04:54 <napping> because that pretty much says "A monad is an applicative with this extra structure"
20:04:58 <dolio> It's rather like how being parameterized over effects loses all the same things as being effectful.
20:04:58 <jasonkuhrt> whereas this is valid: `intListLength []     = 0`
20:05:01 <Cale> jasonkuhrt: function application binds more tightly than any infix operator
20:05:03 <jasonkuhrt> and does not have parens
20:05:20 <Cale> jasonkuhrt: So  intListLength x:xs  parses as (intListLength x) : xs
20:05:32 <dolio> Even though not being effectful is a 'special case' of the parameterization.
20:05:47 <jasonkuhrt> Cale: I assumed the syntax for pattern-matching was special in haskell...
20:06:05 <jasonkuhrt> Cale: This is in the context of a function definition
20:06:07 <Cale> napping: Which?
20:06:11 <jasonkuhrt> intListLength :: [Integer] -> Integer
20:06:11 <jasonkuhrt> intListLength []     = 0
20:06:11 <jasonkuhrt> intListLength (x:xs) = 1 + intListLength xs
20:06:24 <Cale> jasonkuhrt: I realise.
20:07:11 <jasonkuhrt> Cale: I'll keep that in mind thanks
20:07:14 <napping> Cale: http://ncatlab.org/nlab/show/monoidal+monad
20:10:56 <m_ryan> is there a way to delete the data/element in MVar?
20:11:06 <Cale> m_ryan: takeMVar
20:11:33 <johnw> napping: I understood Applicative and Monad to both be monoids in the category of Hask endofunctors, but not the same monoid (or one being an enrichment of the other)
20:12:05 <napping> Applicative is weaker than that
20:12:14 <johnw> weaker than what?
20:12:24 <dolio> It's not the same endofunctor category.
20:12:26 <napping> I don't see how it's a monoid in the category of endofunctors
20:12:30 <Cale> A monoid object in the category of endofunctors *is* a monad.
20:12:32 <johnw> http://www.fceia.unr.edu.ar/~mauro/pubs/Notions_of_Computation_as_Monoids.pdf
20:12:42 <Cale> Applicative is not such a thing
20:12:43 <napping> that would say something about the composition like f (f a)
20:12:51 <dolio> You use a different tensor to get applicative.
20:12:58 <napping> the monoidalness in Applicative is playing nice with products
20:13:04 <johnw> dolio: right
20:13:04 <napping> (f a, f b) -> f (a,b)
20:13:08 <napping> plus the unit, I guess
20:13:19 <Cale> Oh, on a different monoidal category structure, okay.
20:13:20 <johnw> Product is your tensor for Applicative, and Compose for Monad
20:13:28 <napping> The thing is, any monad in 
20:13:36 <napping> Haskell lets you write (a, m b) -> m (a, b)
20:13:49 <napping> plus you pretty much need that for a categorical interpretation of things like free variables
20:14:00 <napping> thinking of a CCC interpretation of lambda calculus
20:14:18 <dolio> I think it's Day convolution for applicative.
20:14:35 <johnw> ah, right!  sorry
20:14:36 <dolio> Not just a plain product.
20:14:40 <johnw> Product is for Alternative
20:14:51 <mjrosenb> gah, that was the most useless type error ghc has ever given me.
20:14:54 <napping> and if you take into account that, then there is a more direct relationship with applicative
20:15:01 <Cale> napping: While I don't disagree that this additional structure is present, the fact that we should tie our own hands with respect to it is slightly questionable to me. I can see the benefit of it, but I also see benefits to making a distinction between the canonical Monad and canonical Applicative structure.
20:15:51 <napping> So how about giving a type incompatible Eq and Ord instances?
20:15:57 <Cale> I guess there's the fact that Applicative really doesn't get you all that much anyway, and so the loss of ability to define the instance of it that you'd like to define is not such a great loss.
20:16:23 <Cale> I'm not arguing about the laws regarding any other pair of type classes.
20:16:34 <Cale> Just this one in particular.
20:17:00 <johnw> I have to agree that a lot of the common Haskell pedagogy revolves around a Monad > Applicative > Functor progression, and the thought of have it be Monad +> Applicative > Functor (where sometimes applicative is just return/ap, but sometimes it isn't) would be terribly confusing
20:17:05 <Cale> It's also worth noting that I think Arrow ought to have *more* laws, which would exclude it from being a generalisation of Monad.
20:18:04 <napping> If you wanted to change the AMP plans, you'd have to argue that you *usually* want a different structure
20:18:25 <Cale> Oh, well, I'm not about to argue that.
20:18:44 <Cale> Usually if you have something which is a Monad, there's only one obvious Applicative structure.
20:18:55 <Cale> But I've run into cases where there's more than one, and where the default one sucked.
20:19:22 * hackagebot bloomfilter 2.0.1.0 - Pure and impure Bloom Filter implementations.  http://hackage.haskell.org/package/bloomfilter-2.0.1.0 (BryanOSullivan)
20:19:25 <napping> did you even want the Monad then?
20:19:38 <Cale> It's arguable that I might not have, but I did have uses for it.
20:20:04 <napping> because following the laws the other way around would make the Applicative canonical, and stop anyone defining the unfortunate Monad without a newtye
20:20:06 <Cale> At least for the bind operation specifically, if not the rest of what the Monad library gives.
20:20:37 <Cale> Like, bind itself didn't suck all that much
20:20:52 <Cale> It's just the resulting ap which sucked a whole lot more than the one which you'd get from that bind
20:20:53 <mjrosenb> does anyone know if the haskell emacs mode supports code folding?
20:20:58 <Cale> er, sorry, words
20:21:04 <Cale> It's just the resulting ap which sucked a whole lot more than the one which you'd get directly without bind
20:21:20 <haskell323> what does:  No instance for (GenProg.GenExpr.GenExpr E)  arising from a use of `nodes'
20:22:21 <jasonkuhrt> How can multi-line commands be achieved in ghci?
20:22:37 <napping> some can be started with :{
20:22:40 <Cale> :{
20:22:44 <napping> that's more like multi-line declarations
20:22:44 <dolio> jasonkuhrt: :set +m
20:22:55 <napping> you can also write explicit grouping
20:22:56 <jasonkuhrt> dolio: then what, shift+enter?
20:23:05 <napping> Did you know indentation just desugars into braces and semicolons?
20:23:05 <dolio> That just turns on multi-line mode.
20:23:05 <Cale> no shift
20:23:16 <jasonkuhrt> napping: good to know
20:23:24 <napping> so you can write stuff like let f [] = "empty
20:23:36 <napping> let f [] = "empty"; f (x:xs) = "nonempty"
20:23:42 <Cale> jasonkuhrt: If you find yourself wanting to declare stuff that's more than one line, usually it's best to just type it into a file and load that
20:23:54 <jasonkuhrt> Cale: Doing that now : )
20:24:00 <napping> I don't think function declarations work at all in :{
20:24:13 <napping> but you can type things like instances or datatypes more nicely with it
20:24:23 <Cale> At one point, ghci didn't even accept declarations.
20:24:26 <dolio> Yeah, otherwise you'll eventually come here and talk about how it'd be good if ghci could dump out all the declarations you made so far.
20:24:28 <jasonkuhrt> I don't know if anyone here has tried Elixir's repl but its awesome
20:24:35 <napping> mjrosenb: I doubt it. What about structured-haskell-mode?
20:24:56 <mjrosenb> napping: don't seem to have it installed.
20:25:01 <napping> actually, plain haskell-mode might know enough about the extent of declarations to help
20:25:19 <dolio> If you have things set up right, ghci will even put you in an editor for the file you're working on with :e
20:25:24 <napping> you might ask in #haskell-emacs, but I haven't got any answer to my questions there
20:25:36 <napping> seems pretty dead not
20:25:57 <Cale> I don't really recommend using :e -- it's usually better to just have the editor open in a separate window so that you can go back and forth easily.
20:25:59 <napping> That is, I just asked a question and nobody is around. It can be useful when people are there
20:26:17 <Cale> and use :r to reload whenever you make changes you want to test
20:26:18 <dolio> :e is easily. :)
20:26:42 <Cale> Well, it's nice to be able to see both your editor and the ghci prompt at the same time
20:28:10 <napping> Can anyone help me out with cabal targets and repls? I have some packages I'd like visible in ghci for testing but not included as a dependency of the library target in the cabal file. I have a test target set up, but that doesn't seem to reflect changes in the library source without recompiling
20:34:25 <jasonkuhrt> What's the sate of record syntax in haskell, was it fixed?
20:36:33 <Cale> jasonkuhrt: fixed?
20:36:39 <Cale> jasonkuhrt: Was it ever broken?
20:36:51 <jasonkuhrt> Cale: Yes I was under the impression it was
20:37:01 <Cale> jasonkuhrt: I don't recall it ever being broken.
20:37:14 <napping> It's not so much the syntax as the design of the record system
20:37:16 <Cale> It works the way it always has worked, anyway.
20:38:04 <jasonkuhrt> http://elm-lang.org/learn/Records.elm and https://www.google.ca/webhp?sourceid=chrome-instant&ion=1&espv=2&ie=UTF-8#q=haskell%20fixing%20record%20system
20:38:17 <halosghost> o/
20:38:47 <halosghost> I'm sure this has been asked before, but is there a simple way to create a type that holds integers only between particular bounds
20:38:47 <jasonkuhrt> http://www.well-typed.com/blog/84/
20:38:48 <jasonkuhrt> etc.
20:38:53 <Big_G> Is there a way to list all Haskell channels on all servers?
20:39:51 <Denommus> Hi
20:39:55 <halosghost> Denommus: hi
20:40:07 <Denommus> Is there a LINQ-like database API for Haskell? 
20:40:45 <saulzar_> jasonkuhrt, It's just not quite as it would be designed if Haskell was written from scratch today, perhaps
20:41:11 <jasonkuhrt> But as-is nothing is planned to change now
20:41:13 <jasonkuhrt> ?
20:42:16 <Big_G> Is there a good way to convert a json object to a new data type?
20:42:24 <saulzar_> There's this https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields
20:43:17 <saulzar_> Which is written to allow you to more easily use the same name for fields - I'm not sure what happened to it
20:43:19 <Big_G> saulzar_, For my question?
20:43:26 <saulzar_> No :)
20:44:18 <saulzar_> Big_G, Are you using aeson?
20:44:38 <jasonkuhrt> saulzar_: Ongoing discussion https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/Redesign
20:44:46 <Big_G> saulzar_, No. I've been using Wai and wrap so far but most likely going to start using wreq for gets/posts
20:44:56 <Big_G> The issue is that I won't have the model already
20:45:01 <Denommus> I mean, for databases 
20:45:35 <jasonkuhrt> More here http://www.well-typed.com/blog/2015/03/overloadedrecordfields-revived/
20:46:34 <saulzar_> You can parse the Json and turn it into an aeson 'Value' type? Without knowing what you'll do with it?
20:46:56 <saulzar_> jasonkuhrt, Well, there you go - that's the state of the play
20:47:11 <halosghost> hmm, seems I can use a smart constructor paired with a bounds-checking function
20:47:14 <halosghost> that's not ideal
20:47:17 <halosghost> ah well
20:47:18 <napping> jasonkuhrt: I don't see it listed on this page of 7.12 stuff: https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-7.12.1
20:47:34 <Big_G> saulzar_, So I use aeson to make a data type and then pass that into functions? How will that type check?
20:47:35 <napping> halosghost: that's the best you're going to get without dependent types
20:47:39 <hemite> I'm trying to install the "processing" package using cabal. It says     Default available version: 1.2.0.1 but also     Installed versions: 1.0.1.0
20:47:44 <hemite> Why doesn't it install the latest version?
20:47:50 <halosghost> napping: dependent types?
20:47:56 <jasonkuhrt> Are dependent types coming to haskell?
20:48:00 <napping> Big_G: "Value" is aeson's type for generically representing a parse json
20:48:21 <napping> jasonkuhrt: I don't think there are specific plans
20:48:23 <halosghost> napping: is that the rumor I've heard about being able to actually specify ranges and the like in type constructors?
20:48:34 <Big_G> napping, How do I use a Value then
20:48:49 <napping> halosghost: it's generically about letting types refer to actual values
20:48:58 <halosghost> ahh
20:49:02 <halosghost> that would be handy
20:49:06 <halosghost> here's hoping that happens :)
20:49:16 <napping> so you might have something like data IsTrue (b : Bool) where Proof :: IsTrue True
20:49:36 <napping> and a function like, checkedDivide :: Int -> (a :: Int) -> IsTrue (a /= 0) -> Int
20:49:48 <hemite> Anyone?
20:50:01 <kern_chicken_pan> Hi
20:50:20 <napping> and not with type-level copies of stuff, but referring to actual values
20:50:29 <napping> don't wait around for it
20:51:29 <kern_chicken_pan> Suppose I have a Haskell data structure (composed of a number of substructure types) that has many Maybe's. I which to run many rule predictate checks on the values for a QA system. What is the best way to go about that? Apart from writing boolean functions for everything?
20:51:30 <halosghost> napping: the ideal case of what I'd be looking for would be like: data BoundedEx (e :: Int) where (a >= 0 && a <= 255)
20:51:33 <halosghost> napping: yeah
20:51:43 <halosghost> napping: there are a few things I'd love to see come to Haskell that I imagine never will
20:51:45 <halosghost> sadly
20:52:03 <napping> I don't think anything else really gives you anything nicer than smart constructors and pretty syntax
20:52:16 <halosghost> sure
20:52:42 <kern_chicken_pan> halosghost: have you used Ada before? your type predicate is Ada-like
20:52:51 <halosghost> kern_chicken_pan: I haven't
20:53:00 <napping> There is work on refinement types, which are a bit lighter-weight
20:53:16 <kern_chicken_pan> napping: that would be awesome!
20:53:28 <napping> and probably just about perfect for checking that your smart constructors actually enforce the invariant
20:53:30 <dolio> There are plans to give GHC 'dependent types'. I'm still kind of unclear on exactly what that means, though.
20:53:42 <dolio> Also I don't know about the time frame.
20:53:43 <napping> I'd expect full dependent types sooner than the refinement types stuff
20:53:43 <kern_chicken_pan> I would like to be able to define bitwide feilds in data types like that
20:54:40 <halosghost> the three things I'd most love to see in Haskell are: 1) the inclusion of openfp for a bigReal-esque type (à la Integer for real numbers), 2) the allowance of all characters valid in function names to be valid in operator names (and vice versa), and 3) the ability to arbitrary define the fixity of a function's name
20:54:50 <halosghost> I'm guessing, however, that none of those will ever be present :)
20:55:03 <kern_chicken_pan> Really?! Because dependant types are completely non-trivial for 'real' implementations that are actually fast. Heck, the naturals are 'hard coded' because we know what they do
20:55:07 <hemite> I'm trying to install the "processing" package using cabal. It says     Default available version: 1.2.0.1 but also     Installed versions: 1.0.1.0
20:55:09 <hemite> Why doesn't it install the latest version?
20:55:25 <kern_chicken_pan> but beyond that dependant types are non-trivial (not a solved problem)
20:55:27 <napping> kern_chicken_pan: I didn't say fast
20:55:32 <napping> http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/about/
20:55:32 <kern_chicken_pan> napping: ah
20:55:41 <napping> that depends on SMT for nice proof automation
20:55:56 <napping> some of the stuff to support GADTs has got the core pretty close to dependent types already
20:56:20 <dolio> There's nothing preventing dependently typed languages from being fast, except the lack of 20 years of work.
20:56:44 <napping> When did Brady's thesis come out?
20:57:12 <kern_chicken_pan> Idris is working on getting that ball going
20:57:33 <kern_chicken_pan> So back to my question..
20:58:15 <dolio> I don't mean 20 years of research. I mean 20 years of working on a production compiler.
20:58:22 <napping> dolio: 20 years ago, there wasn't enough theory to start that 20 years of work
20:58:41 <kern_chicken_pan> How to run many rule predictate checks on the values for a QA system. What is the best way to go about that? Apart from writing boolean functions for everything?
20:59:02 <napping> you might know better than me, but something like "Inductive Families Need Not Store Their Indices" seems pretty critical to starting on the road to tolerable asymptotics
20:59:24 <kern_chicken_pan> napping: citation for that?
20:59:27 <dolio> I don't think so. Edwin's said that optimization doesn't seem to matter in practice.
20:59:33 <napping> huh
20:59:42 <napping> Well, Edwin would definitely know better than me :)
21:00:03 <kern_chicken_pan> I did to do some readings myself to understand more on the matter
21:00:23 <napping> kern_chicken_pan: just copy that title into google
21:00:51 <kern_chicken_pan> oh right, its a title, lol thanks
21:01:29 <napping> maybe not that exact optimization then, but various example index functions with implicit parameters that are like the whole input
21:02:21 <kern_chicken_pan> ok, I found https://hackage.haskell.org/package/predicates any other recommendations on checking lots of values?
21:02:52 <m_ryan> hi how do i solved this problem? Couldn't match type IO with ‘HandlerT App IO’
21:03:08 <napping> m_ryan: call liftIO
21:04:14 <dolio> Maybe it helps. But it's kind of like type erasure.
21:04:38 <dolio> The earliest GHC had type erasure, but I'm sure the latest one smokes it.
21:05:02 <dolio> Because it's had 20 years of work on the runtime system, and code generation, and optimization passes, and ....
21:05:07 <m_ryan> napping: in where part should i liftIO -> this is my code http://lpaste.net/132900
21:05:29 <dolio> Garbage collector....
21:05:47 <napping> m_ryan: where you're trying to call the thing in IO and it wants the Handler T whatever - there should be a location in the error
21:05:57 <napping> maybe around the modifyMVar_ call?
21:06:10 <kern_chicken_pan> Java got swallowed up by its own 'garbage' collector <g>
21:06:23 <dolio> And fancy new dependently typed languages don't have any of that, except inasmuch as they compile to Haskell.
21:06:28 <napping> dolio: I agree some serious work on trying to make a fast language will almost certainly pay off
21:06:29 <m_ryan> napping: the error starts here mvar <- newMVar (M.empty :: M.Map String PricesCached)
21:06:40 <Cale> m_ryan: In this case, liftIO will transform an IO action into a Handler action.
21:06:43 <dolio> But I think generated Haskell tends to not be amenable to GHC's optimizations.
21:07:02 <johnw> dolio: why is that?
21:07:11 <m_ryan> Cale: yes that is my intention.
21:07:15 <napping> dolio: I'm just not sure that "type erasure" for a dependently type language is straightforward enough to put it under "20 years of trying to make a production compiler"
21:07:19 <Cale> m_ryan: You could apply liftIO to the whole do-block in this case, because you're not making use of any of the features of Handler
21:07:27 <Cale> m_ryan: You just have a plain IO action there.
21:08:06 <Cale> m_ryan: Or, you could change the type of cachedPrice
21:08:35 <napping> well, I guess you could say that about lots of parts of a decent runtime
21:08:53 <Cale> m_ryan: It may be worth pointing out that as things stand, cache will *always* be equal to M.empty in that code.
21:09:18 <napping> Cale: ah, that's where the Handler code would probably come in - sharing the cache
21:09:20 <dolio> johnw: Lots of weird unsafeCoerces all over and whatnot.
21:09:23 <m_ryan> Cale: the cachedPrice will call by another Handler.
21:09:32 <johnw> dolio: ah, true enoug
21:09:32 <Cale> m_ryan: Because you just created the MVar containing M.empty
21:09:42 <napping> m_ryan: but every time it's called it will make a new empty MVar, and only check in that one
21:09:55 <m_ryan> Cale: then what would be the correct type/code for that?
21:10:01 <napping> m_ryan: anyway, the answer to your first question is that liftIO will let you turn IO a into Handler a
21:10:10 <Cale> Not actually empty MVar, a nonempty MVar containing an empty Map :)
21:10:50 <dolio> napping: I'm not sure what you're saying. My point is, today, there's pretty much nothing that makes dependently typed languages fundamentally slower than Haskell, except that they have orders of magnitude less engineering effort behind making them fast.
21:10:53 <m_ryan> Cale: so you mean i need to set it globally? to make it work?
21:11:10 <Cale> m_ryan: I'm not sure what you're trying to do. Perhaps instead of doing what you're presently doing for the rest of the action, you'd prefer to return a pair of IO actions, one for reading the MVar at some later point, and one for writing to it?
21:11:49 <napping> dolio: I'm saying that I think 20 years ago people might have thought that things like type erasure would be an obstacle to that
21:13:18 <Cale> m_ryan: It doesn't make much sense to immediately follow up newMVar with readMVar though.
21:13:40 <Cale> Without something like forking a new thread in between or something.
21:14:42 <Cale> (and if you *did* fork a new thread in between, creating a nonempty MVar and then reading it soon after is very likely to just read the value you wrote, if you don't give some time for the other thread to do whatever it's going to do
21:14:45 <Cale> )
21:14:50 <m_ryan> Cale: ok, but as you said once i call the cachedPrice function it will create a newMvar that is empty. how do i escape that?
21:15:04 <napping> m_ryan: probably somehow make the MVar part of your App state
21:15:07 <Cale> m_ryan: Maybe pass in an MVar to be used?
21:16:45 <m_ryan> Cale: new to that :)
21:17:03 <Cale> I guess since you're already forced to deal with this Handler monad transformer which is presumably carrying around application state, you might as well stick such an MVar in the application state like napping suggests. Usually I'd just want to take it as an argument and avoid such shenanigans, because transformers over IO are usually more of an inconvenience than anything.
21:17:54 <Cale> Or better yet than accepting an MVar, accept an IO action which will read it.
21:18:12 <Cale> Like take an argument of type  IO (Map String PricesCached)
21:18:25 <napping> except you need some way to update it on a cache miss
21:18:35 <Cale> Well, yeah, that's true.
21:19:13 <napping> you could still avoid directly passing the mvar though
21:19:16 <Cale> right
21:19:23 <m_ryan> napping & Cale: i update my to to what Cale suggesst about IO - http://lpaste.net/132900
21:19:56 <napping> m_ryan: now I think you need to find documentation for your web framework, and see how to make state that gets shared between multiple requests
21:20:28 <Cale> m_ryan: Those errors don't look like they're in the code you've pasted
21:21:12 <Cale> m_ryan: But I don't think the code you have there makes any sense architecturally. You can't just make a cache locally and have it go out of scope.
21:21:41 <Cale> m_ryan: If you want the cache not to be garbage collected, you need to retain a reference to it throughout your program.
21:22:23 <Cale> (and somehow arrange for it to be passed around)
21:22:42 <m_ryan> Cale: i have a refference code and experiment a little = http://lpaste.net/132835
21:23:28 <Cale> m_ryan: right, so in that code, you create the MVar initially, and the rest of the code makes use of that MVar which you created at the start of main.
21:23:37 <rty> Hi folks. 
21:23:56 <rty> Is there a database which works well with haskell? 
21:24:17 <Cale> m_ryan: So in your real program, you need to do something similar, create an MVar near the start of the program, and pass it (at least in some form) to the rest of the code which needs it.
21:24:43 <Cale> rty: There are a bunch of libraries which have numerous database backends.
21:24:52 <m_ryan> Cale: yes - you got it.. :)
21:24:56 <Cale> rty: Which database would you like to use?
21:25:17 <rty> Cale: I am still evaluating what tools I should use. I have no idea is the honest answer. 
21:25:32 <rty> The dataset is 2tb and growing. 
21:25:44 <rty> Make that 4tb and growing ... 
21:26:15 <rty> I am still evaluating if Haskell is the right way to go or if I should just dive into Hadoop and forget hasekell. 
21:26:39 <Cale> rty: For example, persistent, groundhog, HDBC, hsql, all include Postgresql backends.
21:26:45 <m_ryan> Cale: is there a way i can adopt that code?
21:27:09 <m_ryan> Cale: also this one. http://lpaste.net/132837
21:27:11 <rty> I evaluated elastic-search as a potential tool. But, the flipside of elastic search is its not really great with structured data, but is really fast. At least that's what I got from freading the fine manual. 
21:27:35 <dmj`> rty: I use haskell with AWS cloud search
21:27:42 <Cale> If you're not looking for a traditional database, there's acid-state.
21:27:55 <dmj`> rty: You can use hadoop with haskell
21:28:01 <rty> dmj`: Is that elastic search? 
21:28:13 <dmj`> rty: It's amazon's version of elasticsearch
21:28:18 <Cale> Acid-state gives you a bunch of the guarantees that traditional databases do, while storing plain Haskell data structures.
21:28:37 <Cale> http://hackage.haskell.org/package/acid-state
21:28:48 <napping> doesn't that prefer data that fits in ram?
21:28:55 <Cale> Indeed
21:28:59 <rty> Cale: I will look into acid-state. 
21:29:13 <Cale> Oh, right, 4TB :D
21:29:16 <napping> unlikely with a 4tb data set
21:29:17 <rty> dmj`: hold on while I pull a reference I was reading. 
21:29:20 <dmj`> napping: yea, but there's the remote module, so you can use the RAM of different machines
21:30:35 <rty> Elasticsearch is generally fantastic at providing approximate answers from data, such as scoring the results by quality. While elasticsearch can perform exact matching and statistical calculations, its primary task of search is an inherently approximate task. Finding approximate answers is a property that separates elasticsearch from more traditional databases. That being said, traditional relational databases excel
21:30:35 <rty>  at precision and data integrity, for which elasticsearch and Lucene have few provisions.
21:30:52 <rty> http://exploringelasticsearch.com/overview.html
21:30:56 <dmj`> Cale: +1 for recommending acid-state
21:30:59 <rty> Is there a way I can get both? 
21:31:21 <dmj`> rty: both of what?
21:31:25 <rty> I want approximate answers but also have exact matching for certain parts of the data set. 
21:32:02 <Cale> Well, acid-state is just always one of the things I would consider, though I admit it's very unlikely to be appropriate in this case because you probably don't want your whole dataset in memory when it's 4TB.
21:32:50 <kadoban> TIL that IntSet has O(n) size, not O(1) … woops.
21:32:54 <rty> Cale: Yes, that's a limitation and the data set will only get bigger. Unless, I can afford to do what google does, it just won't take off ...
21:33:24 <rty> I have probably too much on my plate and these choices are driving me nuts ... 
21:33:42 <Cale> What is your dataset?
21:34:07 <rty> A larget set of pdf files numbering in the thousands and ocr data from these pdf files ...
21:34:28 <rty> make that millions of pdf files ... not just thousands ...
21:34:46 <dmj`> rty: what kind of information do you hope to harvest from them
21:34:47 <Cale> Is there something wrong about just using the filesystem in this case? What do you want to do with those files?
21:35:01 <Cale> Surely your index isn't going to be that large.
21:35:21 <dmj`> Cale: hopefully acid-state will become distributed soon, there's been talk
21:35:29 <jle`> is range :: Ix i => (i, i) -> [i] assumable to be ordered when Ord i ?
21:35:32 <napping> even the full OCR data should be more reasonable
21:35:39 <Cale> jle`: no
21:35:47 <jle`> :'(
21:35:48 <Cale> jle`: consider the instance for pairs
21:36:00 <Cale> > range ((0,0),(3,3))
21:36:02 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3,...
21:36:13 <jle`> > sort $ range ((0,0),(3,3))
21:36:15 <Cale> oh, well, I guess that's ordered
21:36:16 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3,...
21:36:33 <rty> dmj`: There are some elements which are relational, which should be in a relational database. The text itself should be accessable in an approximate search and the pdf files retrivable to the exact location on demand. 
21:36:37 <Cale> But it's not all the elements in between in the ordering :)
21:37:01 <Cale> jle`: It's fundamentally a different operation though... you probably shouldn't be using the Ord operations on indices...
21:37:18 <rty> That's the first goal. Then there is NLP of the elements and on the fly analysis to meet the query on request. 
21:37:25 <dmj`> rty: what will it be used for? Purely analysis? 
21:37:38 <dmj`> rty: or is there some sort of consumer facing component for this data
21:37:39 <rty> Query being anything an end user wants from the data. 
21:37:46 <jle`> > sort (range ((0,0),(3,3))) == range ((0,0),(3,3))
21:37:48 <lambdabot>  True
21:37:59 <jle`> yeah, it's probably not something i should be relying on, heh
21:38:22 <rty> dmj`: Yes the customer facing end, will be query after all the NLP is done. 
21:38:45 <rty> Er sorry, the customer facing end will be a search interface. 
21:38:55 <Cale> jle`: Well, more importantly, a <= u and u <= b is not enough to guarantee that u is in range (a,b)
21:39:05 <rty> Just like google or other search engine. 
21:39:20 <Cale> jle`: (which is sort of the reason I gave you that knee-jerk incorrect answer to what you actually asked)
21:39:22 <jle`> yeah, but that's not something i really mind though
21:39:39 <jle`> hm
21:39:42 <jle`> what do i want, anyways?
21:40:05 <rty> The idea is to generate the results from both the structured database and elastic search like aproximating. 
21:40:07 <jle`> it looks like derived instances of Ix will all oby this
21:40:10 <jle`> oby
21:40:13 <jle`> obey
21:40:14 <jle`> i need to fix my e ky
21:40:22 <rty> The elastic search like approximation being fine tuned by the structured data. 
21:40:58 <Cale> jle`: I dunno, but Ix is mainly useful just for mapping elements of a datatype to Ints for indexing into arrays, and it provides operations for going back and forth...
21:40:59 <rty> The system, using NLP to understand what the user is trying to do and learning and adding more filters or refining the search ...
21:41:12 <rty> On the go. 
21:41:19 <Cale> jle`: You might want to compare the corresponding Int values if you want to know which order the elements will occur in the array
21:41:24 <jle`> true.  taking advantage of range structure is probably undefined/really bad
21:46:08 <rty> Maybe I should just focus on babysteps and go from there ... If I end up taking a wrong turn too bad. Just start over again ... Instead of trying to make all the right choices at the very beginning ...
21:48:45 <tmtwd> so any function that gets passed to a fold function must accept 2 (and only 2) arguments?
21:49:27 * hackagebot stackage-upload 0.1.0.5 - A more secure version of cabal upload which uses HTTPS  http://hackage.haskell.org/package/stackage-upload-0.1.0.5 (MichaelSnoyman)
21:49:44 <pacak> tmtwd: You can write something like foldl (f arg0) ...
21:49:52 <pacak> to pass more arguments
21:50:09 <rty> Ok, so first things first. What's the recommended way to perform Natural Language Processing with Haskell? 
21:50:12 <exio4> tmtwd: the accumulator can be a function
21:50:27 <exio4> tmtwd: it's basically, it can be anything that matches that type
21:50:30 <exio4> @type foldr
21:50:32 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
21:50:36 <exio4> @type foldr (.) id 
21:50:38 <lambdabot> Foldable t => t (b -> b) -> b -> b
21:50:38 <pacak> :t foldMap
21:50:40 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
21:50:43 <pacak> :t Endo
21:50:46 <lambdabot> (a -> a) -> Endo a
21:51:04 <tmtwd> but in its simplest form , the fold takes a function that takes 2 params?
21:51:26 <pacak> tmtwd: In it's simpliest form every function in haskell takes only one parameter.
21:52:13 <tmtwd> but I mean you can't do something like
21:52:39 <tmtwd> foldr (\ a b c -> (a -b) + c) 0 [1,2,3,4, 32]
21:52:59 <tmtwd> because the 2 args are the accumulator and the head of the list
21:53:06 <tmtwd> in the first step of the fold
21:53:53 <rty> ,shpider
21:53:54 <kern_chicken_pan> @hoogle [[a]] -> [a]
21:53:55 <lambdabot> Prelude concat :: [[a]] -> [a]
21:53:55 <lambdabot> Data.List concat :: [[a]] -> [a]
21:53:55 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
21:54:08 <rty> @hoogle shpider
21:54:08 <lambdabot> package shpider
21:54:12 <tmtwd> > foldr (\ a b c -> (a -b) + c) 0 [1,2,3,4, 32]
21:54:14 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ a -> a
21:54:14 <lambdabot>      Relevant bindings include
21:54:14 <lambdabot>        c :: a (bound at <interactive>:1:14)
21:55:19 <srhb> tmtwd: Right, for that to be the case, at least the accumulator would have to be a function in itself.
21:58:14 <srhb> :t foldr undefined (\x -> undefined)
21:58:15 <lambdabot> Foldable t => t a -> t1 -> t2
21:58:19 <srhb> :t foldr undefined (\x y -> undefined)
21:58:21 <lambdabot> Foldable t => t a -> t1 -> t2 -> t3
21:58:56 <srhb> Hm, not as instructive as I thought...
22:00:29 <rty> @hoogle lens
22:00:30 <lambdabot> package lens
22:00:30 <lambdabot> package lens-action
22:00:30 <lambdabot> package lens-aeson
22:01:41 <pacak> rty: It's a most enormous schwanzstucker...
22:04:13 <Nihilumbra> K
22:04:27 <rty> pacak lwns?
22:04:49 <rty> lens even ...
22:04:52 <pacak> lens, yes.
22:07:22 <rty> pacak: Maybe, I better get it on my org-mode and leave it on the todo list for now :)
22:15:52 <felixn> I upgraded ghc, was that a bad idea? >_>
22:16:27 <jle`> no :D
22:16:35 <tmtwd> > foldl f z [a, b, c]
22:16:37 <lambdabot>  f (f (f z a) b) c
22:16:42 <jle`> you might have troubles with ghc-mod, if you were using that
22:17:01 <felixn> jle`: do I just checkout the github repo and compile ghc-mod?
22:17:12 <jle`> i'm not sure if ghc-mod still works
22:18:32 <felixn> ok, thanks!  I'm going to mess around with it
22:21:54 * Nihilumbra sheds a tear
22:27:06 <kern_chicken_pan> How are addresses converted to GPS coordinates? Is there any Haskell package for that?
22:28:54 <kadoban> kern_chicken_pan: You'd have to ask someone with a /huge/ database of that kind, and in some countries still not expect a decent answer. I doubt there's a haskell package for it, unless it just queries some web-api
22:29:51 <kern_chicken_pan> kadoban: yea, no idea how it all works really.. I assumed there was some 'standard' db for it?
22:30:37 <kadoban> kern_chicken_pan: I doubt it. It's a ridiculously complicated question, I would assume there's about a billion specialized dbs for it of various levels of quality, none of them perfect.
22:31:52 <kern_chicken_pan> kadoban: Yea I know sorry :|
22:32:07 <kern_chicken_pan> I was just told "build this.."
22:32:09 <aawe> there are web APIs
22:32:16 <aawe> geolocation APIs
22:32:17 <kadoban> kern_chicken_pan: You could start by trying to look at Google Maps, Bing's map thing, mapquest, and whoever else. At least one of them probably has a 1/2way usable API, maybe?
22:32:34 <kern_chicken_pan> apparently the google one has a limit to how many queue's you can do?
22:32:57 <kadoban> kern_chicken_pan: Depending on the constraints you have, it's going to be impossible, baring a huge budget.
22:33:12 <kern_chicken_pan> kadoban: apparently they were evaluated before
22:33:27 <kern_chicken_pan> yea, i was thinking its non-trivial
22:33:48 <kadoban> It's /very/ non-trivial. It's like, you could build a company around just that and never run out of work to do.
22:34:48 <srhb> I know! Let's standardize addresses along one common database for all the world! (https://xkcd.com/927/)
22:38:11 <kadoban> There's a bunch of hard parts to it … even just figuring out what an address is gets kinda complicated. Some other countries have comparatively strange ideas for what an address is, even in the industrialized countries (like Japan's are pretty odd)
22:41:39 <jle`> kern_chicken_pan: google api, if you're interested -- https://developers.google.com/maps/documentation/geocoding/?csw=1#Geocoding
22:42:13 <jle`> but yeah, only 5 requests per second
22:43:22 <liste> OpenStreetMap also works, not sure how accurate the data is, though: http://wiki.openstreetmap.org/wiki/Nominatim
22:43:54 <rty> Is OpenStreetMap a google project? 
22:44:20 <rty> Just asking as google decided they were goig to stop accepting user data ... 
22:45:01 <liste> no, OpenStreetMap is independent
22:45:25 <liste> a Wiki of maps
22:45:39 <liste> http://www.openstreetmap.org/about
22:48:17 <kern_chicken_pan> maybe if I implement some kind of caching
22:50:00 <liste> kern_chicken_pan it would only work if many people look up the same addresses
22:52:05 <kern_chicken_pan> liste: I know that ;)
23:07:53 <gfixler> hardcore http://www.haskellforall.com/2015/05/the-internet-of-code.html
23:15:19 <solidsnack> gfixler: Wow, that's cool.
23:19:49 <rty> I want to do stuff like gfixler ... 
23:20:04 <rty> *shigh back to baby-steps ...
23:21:00 <gfixler> haha, I'm not doing that stuff
23:21:27 <gfixler> unless you mean linking to interesting articles found on twitter
23:22:53 <rty> well at least you can link to interesting articles :) Long way to go ... :)
23:54:34 <m_ryan> hi if there is a liftIO to convert IO() into a handler, how to convert Handler to IO? 
23:55:16 <dmj`> m_ryan: does your quesetion come from a specific code example
23:55:20 <dmj`> question*
23:55:40 <dmj`> m_ryan: not sure how liftIO converts something into a handler
23:56:54 <liste> Handler is a monad transformer on IO, so liftIO converts an IO action to a handler action
23:57:08 <liste> but m_ryan no, it's impossible
23:57:45 <m_ryan> djm`: so sad, but can i call a Handler into IO()?
23:57:53 <dmj`> liste: it lifts an IO action into another monad yes, not sure convert is the right term 
23:58:04 <liste> yeah, lift is better
23:58:25 <m_ryan> djm`: sorry that how i understand it. but thanks for the correction :)
23:58:28 <dmj`> m_ryan: once you're in IO, there's no escaping
23:59:28 <liste> m_ryan why would you need to do that?
23:59:32 <dmj`> m_ryan: you could use monad-control though
