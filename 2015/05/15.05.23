00:00:04 <Fuuzetsu> nice, when is typesetting in a circle becoming a standard? 
00:01:35 <f|`-`|f> please no
00:01:43 <f|`-`|f> Typeset on a sphere or get out
00:02:15 <Fuuzetsu> I'm expecting 3D capable display in the mail from you any hour now
00:03:50 <f|`-`|f> Why not typesetting on an arbitrary surface?
00:03:57 <f|`-`|f> Just use a projector
00:04:05 <f|`-`|f> and some rangefinder to get the topology
00:04:39 <ReinH> typesetting on a 1-sphere or get out
00:05:35 <f|`-`|f> Isn't that a line?
00:07:07 <ReinH> it's (homeomorphic to) the one-dimensional circumference of a circle.
00:07:23 <ReinH> so not a line
00:07:38 * hackagebot jsaddle 0.2.0.5 - High level interface for webkit-javascriptcore  http://hackage.haskell.org/package/jsaddle-0.2.0.5 (HamishMackenzie)
00:07:38 * hackagebot target 0.1.3.0 - Generate test-suites from refinement types.  http://hackage.haskell.org/package/target-0.1.3.0 (EricSeidel)
00:07:39 <ReinH> fsvo line
00:08:08 <f|`-`|f> I forgot
00:08:16 <f|`-`|f> Math can make everything complicated
00:08:22 <ReinH> :)
00:08:47 <lf94> Ugh. Why is cabal broken.
00:08:56 <f|`-`|f> http://i.imgur.com/bIQQhkZ.png <- But then again, this is also math
00:08:58 <lf94> Could not find module `Distribution.Simple'
00:08:59 <lf94> There are files missing in the `Cabal-1.22.3.0' package,
00:09:06 <lf94> How do I fix this?
00:09:15 <lf94> I'm tried: rm -rf ~/.cabal; cabal update
00:09:33 <lf94> s/I'm/I've/
00:09:33 <rotcetorptekcop> lf94 meant: I've tried: rm -rf ~/.cabal; cabal update
00:10:19 <f|`-`|f> s/math/werewolves/
00:10:19 <rotcetorptekcop> f|`-`|f meant: http://i.imgur.com/bIQQhkZ.png <- But then again, this is also werewolves
00:10:39 <f|`-`|f> I feel goodd about myself
00:10:44 <ReinH> f|`-`|f: the coloring is a nice touch
00:10:54 <f|`-`|f> It really is
00:11:00 <f|`-`|f> But I do not understand it at all
00:11:04 <ReinH> but pretty
00:11:09 <f|`-`|f> very
00:11:24 <f|`-`|f> http://i.imgur.com/A0zqyJN.png <- Have some more
00:11:43 <Fuuzetsu> hm, linear algebra led me onto traditional woodworking videos
00:11:44 <Fuuzetsu> thanks math
00:11:51 <ReinH> Fuuzetsu: seems good!
00:12:01 <f|`-`|f> It's wadler doing something with Linear Types, or something Linear Logic and Pi Calculus
00:12:04 <ReinH> Fuuzetsu: linear algebra videos?
00:12:20 <Fuuzetsu> no
00:12:24 <Fuuzetsu> http://graphicallinearalgebra.net/2015/04/24/methodology-handwaving-and-diagrams/
00:12:27 <Fuuzetsu> linked a woodworking video
00:12:29 <Fuuzetsu> so I must watch it
00:12:31 <Fuuzetsu> I must.
00:12:48 <f|`-`|f> If you want to pre-mill lumber with a chainsaw
00:12:54 <f|`-`|f> 1) Get a Rip Chain
00:13:09 <ReinH> fiddlerwoaroof: hahaha
00:13:11 <ReinH> woops
00:13:18 <f|`-`|f> 2) make a jig so that you can cut parallel to the grain
00:13:19 <ReinH> what a name
00:13:24 <f|`-`|f> 3) Take is slow
00:14:13 <f|`-`|f> If you do, something something, it's smooth enough to be finished with 220 Grit 
00:25:06 <f|`-`|f> Also, women don't like Mahogany
00:28:23 <dbushenko> hi all!
00:28:31 <dbushenko> are there any alternatives to aeson?
00:29:22 <Cale> dbushenko: Yes, but everyone uses aeson these days it seems
00:29:53 <dbushenko> Cale, unfortunately aeson can't parse FB responses... :-(
00:30:20 <Cale> That's interesting.
00:30:29 <dmj`> dbushenko: can you demonstrate?
00:30:55 <dbushenko> give me 2 minutes
00:33:52 <ReinH> Are FB responses invalid JSON?
00:33:56 <dbushenko> I think I was wrong
00:34:06 <ReinH> if it can't parse vaild JSON, that would be a bug
00:34:13 <ReinH> valid
00:34:20 <dbushenko> what I did incorrectly was: printing the FB response to console and then trying to decode it as it was printed
00:34:33 <ReinH> dbushenko: Ah, well, happy to be of assistance
00:34:36 <dbushenko> when I feed the response as it was, then aeson could parse it
00:34:41 <dbushenko> so thanks :-)
00:35:16 <roelof> anyone who has a idea here : http://mail.haskell.org/pipermail/beginners/2015-May/015451.html
00:35:29 <ReinH> Cale: this graphical linear algebra stuff is getting good. http://graphicallinearalgebra.net/2015/05/23/from-diagrams-to-matrices/
00:35:55 <ReinH> Cale: also https://johncarlosbaez.wordpress.com/2015/05/18/props-for-linear-systems/ has some really interesting stuff
00:36:04 <Fuuzetsu> roelof: your files got corrupted and that's causing a type error? ;P
00:36:04 <pacak> roelof: Add type signatures
00:37:00 <roelof> oke, the types are toDigits :: Integer -> [Integer] 
00:37:29 <Fuuzetsu> the problem is in the second case of toDigits' as GHC is telling you
00:37:33 * hackagebot huttons-razor 0.1.0.0 - Quick implemention of Hutton's Razor  http://hackage.haskell.org/package/huttons-razor-0.1.0.0 (steshaw)
00:39:59 <Fuuzetsu> you probably meant something like let x = number `mod` 10 in toDigits' (x : acc) x
00:40:10 <dmj`> roelof: should have (toDigits' ((number `mod` 10):acc) (number `mod` 10))
00:40:13 <Fuuzetsu> but that's pretty useless, it'll just look forever
00:40:17 <Fuuzetsu> loop*
00:40:28 <pacak> reverse $ ana (\case 0 -> Nil ; x  -> uncurry (flip Cons) $ divMod x 10) 12345
00:40:28 <pacak> [1,2,3,4,5]
00:40:52 <roelof> Fuuzetsu:  yes. that I know, but I cannot see why is faulty. lets say I have the number 23 then 3 have to be added to acc and the function has to run with [2] 
00:41:24 <Fuuzetsu> you need to fix your type before you fix your logic
00:41:38 <Fuuzetsu> right now you're trying to apply a list to a function which is not going to work
00:41:40 <pacak> :t ana
00:41:42 <lambdabot>     Not in scope: ‘ana’
00:41:42 <lambdabot>     Perhaps you meant one of these:
00:41:42 <lambdabot>       ‘and’ (imported from Data.List), ‘any’ (imported from Data.List),
00:42:03 <pacak> :t Data.Functor.Foldable.ana
00:42:04 <lambdabot> Not in scope: ‘Data.Functor.Foldable.ana’
00:42:08 <pacak> :(
00:42:11 <ReinH> :(
00:42:16 <Fuuzetsu> pacak: pretty sure lens is not allowed in a beginner homework question ;P
00:42:34 <pacak> Fuuzetsu: But that's not lens! It's a trivial case of anamorphism...
00:42:40 <roelof> dmj`:  you solved it. I messed up my parameters of the function. Thanks you saved my day 
00:42:41 <Fuuzetsu> isn't Cons from lens?
00:42:45 <pacak> (always wanted to say that)
00:42:50 <vandenoever> what's a good introduction to lens?
00:43:10 <dmj`> roelof: so what you're trying to do is given a number, get a list of the digits?
00:43:12 <pacak> Fuuzetsu: Nope. It's defined in recursion-schemes
00:43:26 <pacak> data instance Prim [a] b = Cons a b | Nil
00:43:32 <dmj`> > map digitToInt  . show $ 23
00:43:34 <lambdabot>  [2,3]
00:43:41 <dmj`> roelof: easier ^
00:43:55 <roelof> yep, where a negative number or the number 0 gives a []  and the rest a list with the numbers 
00:43:55 <Fuuzetsu> but feels morally wrong
00:44:53 <f|`-`|f> use unfoldr
00:44:58 <f|`-`|f> it comes out backwards though
00:45:06 <roelof> map digitToInt  . show $(-9) 
00:45:32 <dmj`> roelof: you can gaurd the input against negatives, and 0
00:45:58 <roelof> > map digitToInt  . show $(-9) 
00:46:01 <lambdabot>  [*Exception: Char.digitToInt: not a digit '-'
00:46:40 <roelof> dmj`:  I think so, I also have tried Data.digits but there the same problem 
00:46:54 <f|`-`|f> hum
00:46:57 <f|`-`|f> :t unfoldr
00:46:59 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
00:47:02 <dmj`> > (\x -> x | x <= 0 -> [] | otherwise -> map digitToInt (show x)) $ (-9)
00:47:04 <lambdabot>  <hint>:1:10: parse error on input ‘|’
00:48:20 <f|`-`|f> :t divMod
00:48:20 <dmj`> > (\x -> case x of num | num  <= 0 -> [] | otherwise -> map digitToInt (show num)) $ -1
00:48:22 <lambdabot> Integral a => a -> a -> (a, a)
00:48:22 <lambdabot>  []
00:48:35 <f|`-`|f> > divMod 5 10
00:48:35 <dmj`> Fuuzetsu: yea it does feel dirty
00:48:38 <lambdabot>  (0,5)
00:48:56 <f|`-`|f> > flip divMod 5 10
00:48:58 <lambdabot>  (2,0)
00:51:20 <f|`-`|f> unfoldr that guards against a remainder of zero
00:52:34 * hackagebot darkplaces-rcon 0.1 - Darkplaces rcon client library  http://hackage.haskell.org/package/darkplaces-rcon-0.1 (slava)
00:56:35 <roelof> Everyone thanks for the help and lessons. Have a nice day 
01:04:07 <dmj`> what was that gui project, think it was by galois..
01:05:03 <dmj`> for console apps
01:05:31 <ReinH> dmj`: dunno, but pls tell me if you remember
01:05:35 <ReinH> sounds interesting
01:05:51 <dmj`> ReinH: it was really cool looking
01:06:14 <dmj`> ReinH: found it :0
01:06:22 <dmj`> http://jtdaugherty.github.io/vty-ui/
01:06:27 <ReinH> ohhh
01:06:31 <ReinH> yeah, it's ok
01:06:43 <dmj`> ReinH: yea? you tried it before
01:06:46 <ReinH> yeah
01:07:02 <ReinH> there's a bit of an impedence mismatch between vty and vty-ui so they are a bit hard to mix
01:07:15 <ReinH> but it's solvable
01:08:52 <dmj`> ReinH: hmm, that's interesting, maybe I should just use a web app :/
01:09:11 <ReinH> I don't mean to scare you away
01:09:14 <ReinH> you should try it
01:09:57 <dmj`> yea, true, k I'll try
01:27:33 <ion> hackagebot reminds me that I never uploaded my rcon library to Hackage.
01:37:36 * hackagebot posix-realtime 0.0.0.3 - POSIX Realtime functionality  http://hackage.haskell.org/package/posix-realtime-0.0.0.3 (MichalGajda)
01:57:37 * hackagebot sdl2 1.3.1 - Low-level bindings to SDL2  http://hackage.haskell.org/package/sdl2-1.3.1 (Polarina)
02:07:38 * hackagebot keera-hails-reactivevalues 0.0.3.4 - Haskell on Rails - Reactive Values  http://hackage.haskell.org/package/keera-hails-reactivevalues-0.0.3.4 (IvanPerez)
03:04:46 <indiagreen> is Haddocks “@since” command documented anywhere?
03:04:52 <indiagreen> * Haddock's
03:05:38 <indiagreen> for an example see here: http://hackage.haskell.org/package/base-4.8.0.0/docs/src/System-Exit.html#die (“@since 4.8.0.0” gets turned into “/Since: 4.8.0.0/”)
03:10:26 <Thra11> If there are multiple versions of llvm installed in different places on a system, how does ghc determine which to use for the LLVM backend?
03:21:06 <Fuuzetsu> indiagreen: ask and I can tell you what you need to know
03:21:49 <indiagreen> Fuuzetsu: my real question is whether there's a full list of those commands/macros available somewhere
03:22:08 <Fuuzetsu> here it is: [@since]
03:22:32 <indiagreen> o-kay
03:22:32 <Fuuzetsu> more seriously, it's docummented in haddock.xml in the source
03:22:49 <Fuuzetsu> normally HTML gets generated and put on haskell.org/haddock at release
03:23:03 <Fuuzetsu> but I have not had time to do that when the release was actually happening
03:23:23 <Fuuzetsu> I should probably do so tomorrow as I'm done for tonight
03:23:52 <indiagreen> okay, found the commit
03:23:53 <indiagreen> thanks
03:32:42 * hackagebot servant-pandoc 0.4.0 - Use Pandoc to render servant API documentation  http://hackage.haskell.org/package/servant-pandoc-0.4.0 (mpickering)
03:39:43 <JuanDaugherty> any clafer users?
03:41:33 * JuanDaugherty errands
03:55:20 <Myrl-chan> :t catch
03:55:21 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
03:55:25 <Myrl-chan> Hmmm
04:40:41 <robstewartuk> Anyone experience with jaspervdj websockets library? I'm experiencing a simple error https://github.com/jaspervdj/websockets/issues/102
04:42:10 <JuanDaugherty> vdj 4 sure
04:43:26 <JuanDaugherty> whose birth name is apparently Jasper, was expecting something like Jasper Reports, a Jasper from the Java culture oder
04:52:53 * hackagebot idris 0.9.18.1 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.18.1 (EdwinBrady)
04:58:40 <rewbert> Aaaaah not sure which of you were here, helping me last night!
04:59:00 <pacak> https://gist.github.com/pacak/ffcf9761ecfa55d642af
04:59:00 <rewbert> If anyone remembers and cares, i now finally got my code to work f3
04:59:03 <rewbert> hehe
05:21:57 <Myrl-chan> I can't find any better words for this. How do I DRY this up? http://hastebin.com/qucezapura.hs
05:23:08 <Myrl-chan> I need to default "./" to "./index" in everything.
05:23:57 <pacak> let file'' = if file' == "./" then "/index" else file'
05:24:12 <Myrl-chan> One idea I've had was to do `let file'' = bool file' "./index.hs" (file' == ".')
05:24:36 <Myrl-chan> pacak: Is using let the best way to do this/
05:25:51 <suppi> Myrl-chan, maybe something like http://hastebin.com/hesegawosu.vhdl ?
05:26:07 <pacak> You make a new file name and use case on that so you have just one case
05:26:39 <Myrl-chan> Also, how would I do a let binding in a case statement?
05:27:24 <Myrl-chan> suppi: That seems nice.
05:28:51 <pacak> Myrl-chan: make it into a function - applyDefaultPath or something like that and just
05:29:07 <pacak> case applyDefaultPath file' 
05:29:07 <pacak>  Just ... -> 
05:30:18 <int-e> why do people make pastebins that don't work without javascript
05:32:58 <Myrl-chan> Is this bad?  case shrinkPath file of
05:32:59 <Myrl-chan>    (Just file) ->
05:33:27 <Myrl-chan> I don't want a namespace full of ', so..
05:33:46 <Myrl-chan> IMO, this is a bit cringy for me, but I can't realyl tolerate more than 1 ', on one name.
05:40:50 <Myrl-chan> Hmm, this does seem better for me!
05:45:59 <Myrl-chan> I think I did well overall, thanks.
05:46:21 <ollef> Myrl-chan: just watch out with let-expressions, since e.g. `let file = ... file ...` might not do what you expect
05:46:36 <Myrl-chan> ollef: Recursion?
05:46:47 <ollef> Myrl-chan: exactly :)
05:47:14 <Myrl-chan> I also decided to clean some of my imports.
05:47:24 <ollef> Myrl-chan: if you're expecting the `file` on the RHS to be from the outer scope, you're in trouble
05:48:42 <Myrl-chan> hlint's telling me `case snd . splitExtensions $ f of` is better than `case (snd . splitExtensions $ f) of`
05:49:14 <Myrl-chan> Would you agree? IMO, the latter's more readable.
05:50:24 <indiagreen> Myrl-chan: why not just use takeExtensions?
05:50:34 <fractalsea> Is there a way to get the length of a Text in bytes?
05:51:53 <mniip> I should make a peg library
05:51:58 <Myrl-chan> indiagreen: Ah nice catch. :)
05:52:02 * Myrl-chan licks mniip
05:52:10 <mniip> doesn't seem to be any on hackage
05:53:19 <mniip> well there is frisby, but that does weird magic
05:55:31 <Myrl-chan> mniip: please notice me. :(
06:01:06 <zcourts> How do data decls get represented in Core? I’m looking at https://github.com/ghc/ghc/blob/master/compiler/coreSyn/CoreSyn.hs#L247 but it’s not obvious to me.
06:06:13 <Hafydd> mkNoScope
06:14:24 <int-e> zcourts: how about https://github.com/ghc/ghc/blob/master/compiler/types/TyCon.hs#L328
06:16:36 <int-e> zcourts: I suppose (but don't know) that data declarations are not part of the core language itself, there's a type environment that carries them. However, you can find the information by looking inside the 'Type' type (cf. https://github.com/ghc/ghc/blob/master/compiler/types/TypeRep.hs#99 )
06:28:23 <chpatrick1> I'm getting forbidden when trying to upload a package to hackage
06:28:26 <chpatrick1> any idea what's up?
06:47:58 <uwap> hey. I'm currently trying to visualize the current audio played in form LEDs. Anyone knows a good library that gets information (frequency played, volume, etc. pp.) of the current ALSA ouptut?
06:51:37 <whiteline> uwap: it should be as simple as making bindings to alsa-lib and then check what functions alsa-tools use
06:51:53 <whiteline> probably just a handful
06:53:29 <uwap> whiteline, doesn't actually sound "simple" to me
06:54:56 <whiteline> the haskell FFI is very convenient
06:55:28 <whiteline> https://wiki.haskell.org/FFI_Introduction
06:56:06 <chpatrick1> uwap: frequency isn't that simple
06:56:18 <chpatrick1> you might need to do fft
06:56:38 <chpatrick1> https://hackage.haskell.org/package/vector-fftw
06:56:47 <chpatrick1> not sure if that's realtime though
06:57:42 <sagittarian> how would I do an unsigned right shift (using Data.Bits, I'm guessing)?
06:57:46 <uwap> whiteline, not talking about the haskell FFI. :P
06:58:28 <chpatrick1> sagittarian: convert to unsigned equivalent, shift, convert back?
06:58:39 <sagittarian> What's the unsigned equivalent of Int?
06:58:42 <chpatrick1> Word
06:58:45 <chpatrick1> Data.Word.Word
06:58:48 <sagittarian> ah cool thanks
07:00:32 <maerwald> sagittarian: there is also Data.Bits which allows bitshifts
07:01:00 <maerwald> so afais it's just shiftR
07:01:09 <sagittarian> I'm using Data.Bits, but right shifts shift in 1's when the Int is negative
07:07:07 <sagittarian> are there signed equivalents of Word8, Word16, and Word32 somewhere?
07:07:25 <chpatrick1> Data.Int :)
07:07:34 <sagittarian> thanks chpatrick1
07:14:34 <JuanDaugherty> "afais": as far as i sais?
07:16:18 <todaystomorrow> What is a good way I can prove that I know haskell?
07:16:42 <sagittarian> todaystomorrow: write a "hello, world" program
07:17:01 <sagittarian> without using the internet, of course
07:17:22 <JuanDaugherty> todaystomorrow, to whom?
07:17:38 <JuanDaugherty> (they should set the criteria)
07:17:44 <n1cky> http://lpaste.net/133182
07:17:49 <AshyIsMe> todaystomorrow: make a todomvc that connects to a standard database like postgresql or mysql
07:17:53 <n1cky> very new to haskell.
07:18:51 <sagittarian> :t splitAt
07:18:52 <lambdabot> Int -> [a] -> ([a], [a])
07:19:07 <sagittarian> :t print
07:19:08 <lambdabot> Show a => a -> IO ()
07:19:36 <n1cky> okay, so the issue is with the print, actually?
07:19:48 <sagittarian> no
07:20:09 <sagittarian> splitAt 1 input is just a regular calculation of a pair
07:20:25 <sagittarian> you don't need it to use the do syntax
07:20:55 <n1cky> when is the do syntax necessary and when isn't it? This has something to do with monads, yes?
07:21:02 <sagittarian> (haven't tried this but I'm guessing) you should just do let split = splitAt 1 input instead of the <- on that line
07:21:14 <n1cky> ahhhh, okay.
07:21:24 <todaystomorrow> sagittarian to a university
07:21:42 <n1cky> so just for clarification, when is a '=' used and '<-' used?
07:21:52 <n1cky> feel free to tell me to fuck off and read a tutorial
07:22:10 <geekosaur> n1cky, <- is used to "run" a monadic action (e.g. getLine)
07:22:29 <n1cky> geekosaur: okay, that makes sense.
07:22:30 <geekosaur> splitAt is not a monadic action
07:23:29 <sagittarian> n1cky: I'm not really sure how to explain it without getting into how to desugar do notation
07:23:35 <sagittarian> I'd suggest you read up on that
07:23:46 <n1cky> that's fine, thanks for the pointer
07:24:10 <n1cky> fwiw, replacing the <- with an = makes a compiler error
07:24:48 <n1cky> http://lpaste.net/133183
07:24:51 <sagittarian> n1cky: you need let x = ...
07:25:09 <sagittarian> let split = splitAt 1 input
07:25:30 <n1cky> why is let not necessary for monadic actions?
07:25:47 <sagittarian> monadic actions use the <- do notation
07:26:18 <geekosaur> foo <- bar      translates to    bar >>= \foo ->
07:26:27 <geekosaur> (which is incomplete and must be followed by something else)
07:26:35 <n1cky> gotcha
07:26:37 <todaystomorrow> What are good projects to embark on if intermediate with haskell?
07:26:55 <geekosaur> let foo = bar   translates to    let foo = bar in
07:26:59 <geekosaur> (which is also incomplete)
07:27:09 <geekosaur> do notation is a shorthand of sorts
07:27:14 <sagittarian> x <- something; let y = f x; return g y desugars to something >>= \x -> let y = f x in return (g y)
07:27:30 <geekosaur> @undo do { foo <- bar; let baz = quux; print (quux foo) }
07:27:30 <lambdabot> <unknown>.hs: 1: 51:Parse error: }
07:27:35 <geekosaur> whoops, right
07:27:40 <geekosaur> @undo do { foo <- bar; let { baz = quux }; print (quux foo) }
07:27:40 <lambdabot> bar >>= \ foo -> let { baz = quux} in print (quux foo)
07:28:10 <geekosaur> (extra braces because not using layout, since it all has to be on one line for the bot)
07:28:28 <Big_G> Has anyone used Haskell in Docker?
07:28:30 <pingu> todaystomorrow: I find your own are best.
07:29:19 <pingu> Big_G: I have.
07:29:30 <n1cky> geekosaur: sagittarian: thank you guys
07:29:35 <n1cky> that makes a lot of sense.
07:29:41 <pingu> Big_G: this looks like a better way of doing it than I did: https://www.fpcomplete.com/blog/2015/05/haskell-web-server-in-5mb
07:29:42 <sagittarian> np
07:30:09 <todaystomorrow> where can I find someone to be a haskell study budy?
07:30:30 <pingu> todaystomorrow: have you started attending a local FP meetup?
07:30:58 <sagittarian> someone *just* create a local haskell meetup group, I'm very excited
07:31:03 <sagittarian> no meetups scheduled yet though
07:32:21 <Big_G> pingu, Thanks. I'll be sure to be back in a week or two when I'm done with the devops stuff and am ready for development
07:33:01 <SrPx> Is there any way to take a haskell function and translate it to usable/readable C? Or something? Inlining all the deps? That would be great since I'm porting some of my functions to CUDA
07:33:03 <todaystomorrow> No I haven't. Have you ever attended one? What are they like?
07:33:43 <chpatrick1> srpx: not as far as I'm aware
07:33:56 <chpatrick1> you can use some haskell libraries to generate C like with sbv
07:34:13 <exio4> SrPx: I think you might have better luck with accelerate-cuda
07:34:47 <pingu> SrPx: Didn't it used to have a C backend?
07:35:04 <SrPx> exio4: I have no idea how to write values to a array on the device from inside a kernel on accelerate
07:35:17 <SrPx> so I just went directly to cuda since it is well documented
07:35:26 <SrPx> an*
07:41:27 <Big_G> pingu, What do you use for your web server?
07:48:02 * hackagebot snaplet-wordpress 0.1.1.2 - A snaplet that communicates with wordpress over its api.  http://hackage.haskell.org/package/snaplet-wordpress-0.1.1.2 (DanielPatterson)
07:48:05 <phaazon> is there a rdfox here?
07:48:07 <phaazon> http://www.reddit.com/r/haskell/comments/36uxym/what_will_happen_to_haskell_in_the_future/crif3lv?context=3
07:48:20 <phaazon> I don’t get what he refers to with “row types”
07:48:22 <phaazon> any idea?
07:58:10 <pingu> Big_G: which webserver?
08:00:56 <Big_G> pingu, I thought you said you had a webserver in Haskell which was why you sent that link
08:02:04 <pingu> Big_G: I don't remember saying that. The author of the site that I linked "has" a webserver, if that's what's confusing you.
08:02:48 <Big_G> pingu, I think that is it. I take it you haven't written anything web related in Haskell then?
08:03:41 <athan> Big_G: I have!
08:03:47 <athan> @hackage nested-routes
08:03:47 <lambdabot> http://hackage.haskell.org/package/nested-routes
08:03:55 <pingu> Big_G: biggest thing i've worked on was servant
08:04:20 <pingu> https://github.com/haskell-servant/servant/
08:04:32 <Big_G> athan, Hopefully you can help. I'm trying to write a RESTful service. What packages should I use and why?
08:05:03 <athan> Big_G: Well, I would say that the most common /simple/ REST package is scotty
08:05:08 <athan> @hackage scotty
08:05:08 <lambdabot> http://hackage.haskell.org/package/scotty
08:05:08 <pingu> Big_G: ^^ I'd recommend servant, channel is #servant
08:05:18 <athan> that too!!
08:05:30 <pingu> Why is, you get to type your API interface
08:05:41 <pingu> and automatically generate boilerplate on the server
08:05:43 <athan> Big_G: If you want to use strings as the route to match against, use scotty. If you want to be more modular with your code, use servant.
08:05:47 <pingu> and automatically generate your client.
08:05:51 <athan> If you want obsessive modularity, use nested-routes :)
08:06:36 <athan> pingu: Hmm, what kind of boilerplate? (I haven't tried it yet)
08:06:58 <pingu> athan: marshaling, pretty much everything.
08:07:03 <Big_G> athan, What would I use to match except strings?
08:07:21 <athan> pingu: Oh wow that sounds nice
08:07:22 <pingu> You can end up writing your API endpoints as Monad m => m Text
08:07:49 <pingu> Or [(Int, Int)] -> Text -> m Text
08:07:50 <SrPx> Okay! Ported it to CUDA, yay. Now how do I FFI it? Same thing as C?
08:08:03 * hackagebot darkplaces-text 0.2 - Parser for darkplaces colorful text  http://hackage.haskell.org/package/darkplaces-text-0.2 (slava)
08:08:11 <pomf> http://hastebin.com/tomoviruku.hs
08:08:25 <pomf> Any points to improve?
08:08:38 <pomf> Perhaps I can use State monad for this?
08:09:52 <Big_G> athan, How does Scotty deal with headers and payloads?
08:10:14 <athan> Big_G: I can't say I know very well :\ check the docs!!
08:10:28 <athan> there's a `post` function, I know that much
08:11:43 <hodapp> hmm, I am to give a demo in 2 weeks on some work I've done in Haskell, to some folks that are dominantly not Haskell people, but I'd like to give them some code they can actually run
08:11:53 <hodapp> guess I could accomplish this via nix, Halcyon, or Docker
08:12:51 <JuanDaugherty> is it in a web app?
08:12:58 <wei2912> is there a function similar to splitAt which, instead of splitting at an index, splits upon finding the first occurence?
08:15:21 <wei2912> oh, there's break. thanks
08:30:54 <SrPx> That's the error I get when I just try to FFI a CUDA file as if it was C: http://lpaste.net/133186
08:36:57 <geekosaur> you need to link against the cuda libraries
08:37:40 <geekosaur> (no, I have no idea how to do that(
08:44:20 <pomf> wei2912: HAI HAI~
08:44:38 <pomf> wei2912: Isn't that SplitOn?
08:52:22 * pomf just realized the difference.
08:57:37 <wei2912> Myrl-chan: hmm?
08:57:41 <wei2912> http://lpaste.net/133190
08:58:01 <wei2912> ^^ how do i get TestGlobber.hs's prop_Empty to typecheck?
09:00:09 <Vektorweg1> why are there so many damn bytestrings? 
09:00:56 <nshepperd> so many? there's only two different types of bytestring
09:02:06 <monochrom> it may look like 4, but that's just because of re-exports. there are only 2.
09:03:10 * hackagebot darkplaces-rcon-util 0.1 - Darplaces rcon utility  http://hackage.haskell.org/package/darkplaces-rcon-util-0.1 (slava)
09:03:19 <wei2912> Vektorweg1: in the current version there's just the standard and Char8. though afaik a few versions ago there was Base32, Base64, etc.
09:03:28 <Vektorweg1> but some packages seem to have their own bytestrings.
09:03:45 <geekosaur> Char8 is not a different ByteString
09:03:58 <geekosaur> Vektorweg1, then you have multiple versions of ByteString installed
09:04:07 <geekosaur> and ghc now cannot determine which of them to use
09:04:20 <Vektorweg1> hm okay.
09:04:22 <geekosaur> "don't do that"
09:05:31 <geekosaur> sadly cabal is a little too happy to install new versions in order to get the latest version of some package, and then ghc cannot cope (the mechanisms cabal tries to use don't quite work, because ghc. the ghc devs are working on it)
09:07:46 <wei2912> nvm, fixed it
09:08:12 <wei2912> geekosaur: you're right, thanks
09:08:31 <wei2912> geekosaur: what's the other type of ByteString mentioned then? Lazy?
09:08:36 <geekosaur> yes
09:08:56 <geekosaur> CHar8 is just a different interface to the same (strict or lazy) bytestring, not a different bytestring
09:09:00 <inquirydog> hey, I get the problems with lazy IO (I think....), and I see why a framework like conduits or pipes are needed, but......  it really bugs me that the conduits themselves couldn't just be pure functions, and composition couldn't be standard function composition....  Was this really necessary?  Couldn't they have just written something that properly generated a source and sink, then just took pure functions in the middle?
09:09:38 <SrPx> How do I add this to cabal? ghc --make test.hs -o test hello.o -L/usr/local/cuda/lib -optl-lcudart
09:13:36 * wei2912 wonders if there's a haskell extension that allows pattern matching on last few elements of a list
09:14:39 <quchen> wei2912: No.
09:14:57 <inquirydog> wei2912: I would think that would be something to avoid unless absolutely necessary (....although that doesn't mean it doesn't exist)
09:14:57 <quchen> A list does not have a last element. A list is either empty or has exactly one element, followed by another list.
09:15:28 <inquirydog> quchen: that doesn't mean it doesn't have a last element
09:15:37 <SrPx> I won't understand, "ghc src/Graphics/VoxelRayTracer.hs -L/usr/local/cuda/lib -optl-lcudart" compiles, but adding "-L/usr/local/cuda/lib -optl-lcudart" to ghc-opts on Cabal and then using cabal build results in ld: library not found for -lcudart
09:15:45 <quchen> Lists don't, in general, have a last element.
09:15:57 <quchen> Vectors on the other hand do.
09:16:09 <inquirydog> quchen: nor, in general a first element....
09:16:19 <inquirydog> quchen: doesn't stop pattern matching on it.
09:16:38 <inquirydog> quchen: a vector can be empty also
09:16:52 <quchen> But the "first element or no list" is decidable by pattern matching on the constructors.
09:16:57 <ClaudiusMaximus> SrPx: try -v options to cabal to see what it is doing
09:17:17 <geekosaur> inquirydog, the point is that (a) a last element is not something you can determine statically (b) it's not even, strictly, *last* (it has :[] on its tail)
09:17:45 <inquirydog> quchen: yes, I do not disagree with that....
09:17:50 <geekosaur> that is, the last eleemnt of every list is []
09:18:15 <SrPx> ClaudiusMaximus: uh thanks... it is using a huge command but is including what I asked it to include on the GHC ommand
09:18:18 <SrPx> so ... why
09:18:33 <inquirydog> geekosaur: quchen: he asked if there was an *extension*....  I agreed that it would be a bad thing to do, but someone might have written something crazy....
09:19:06 <quchen> You can probably abuse pattern synonyms (or use ViewPatterns) to do this sort of thing.
09:19:21 <enthropy> > let f (reverse -> ('o' : x : _)) = x; f _ = 'x' in map f (words "hello oh ho")
09:19:23 <lambdabot>  "lxh"
09:19:41 <inquirydog> geekosaur: I think most people would define last as the item before the :[]....  That is what the last function does
09:19:55 <geekosaur> inquirydog, most *people* would
09:20:00 <geekosaur> pattern matching doesn't
09:20:52 <geekosaur> "I want to make pattern matching not be pattern matching"
09:21:15 <inquirydog> geekosaur: he isn't asking about typical pattern matching....  He is asking about a crazy extension, which I already said would be a bad idea....  But someone might have been crazy enough to do it.
09:21:31 <geekosaur> and I am failing to make the point that it's worse than crazy
09:21:33 <monochrom> pattern matching only knows the data declaration "data [a] = [] | a : [a]". it does not care how people interpret it.
09:21:38 <geekosaur> it's *contradictory*
09:22:01 <quchen> You can use pattern guards to get some form of "fallthrough when there's no last element", a la `| Just x <- safeLast xs = ...`.
09:22:10 <inquirydog> geekosaur: so what?  It could be done....  I wouldn't do it.
09:22:11 <quchen> But that hardly makes code more readable.
09:22:20 <geekosaur> ...
09:22:26 <quchen> In fact I think you shouldn't be using `tail` at all.
09:22:37 <quchen> Or `last`, or all those other functions.
09:22:44 <monochrom> wait a second, "it is contradictory" and "it can be done" are contradictory...
09:22:48 <inquirydog> geekosaur: are we really fighting about the level of craziness of something?  Seems kind of odd.
09:23:21 <geekosaur> as pattern matching /per se/ it can't be done. view patterns are a mechanism to run random stuff inside a pattern match and can break the rules
09:23:25 <SrPx> If my lib uses FFI needing a .o file, then will any user of this lib need to link that .o too?
09:23:28 <inquirydog> monochrom: It *can* be done....  it would be stupid
09:23:54 <geekosaur> SrPx, I have spent the last 10 or so minutes trying to compose an answer to you and having this other topic interrupt...
09:23:55 <monochrom> view patterns call arbitrary functions. functions that don't even have to terminate.
09:24:09 <inquirydog> geekosaur: but by saying "extension" we certainly are not using anything "per se"
09:24:48 <monochrom> view patterns are like 99.99% calling Turing-complete functions, 0.01% pattern matching.
09:24:53 <quchen> map _ [] = []; map f ((f -> x) : (map f -> xs)) = x:xs
09:24:57 <inquirydog> geekosaur: like, template haskell is not haskell "per se" either....
09:25:30 <geekosaur> right, I give up trying to help SrPx let's keep bashing this dead equine
09:25:40 <quchen> monochrom: Turing-complete functions? Functions as expressive as a Turing machine? :-)
09:26:26 <enthropy> map f ((f -> x) : ((x:) . map f -> r)) = r -- no sense in having two variables on the RHS
09:26:38 <inquirydog> anyone here a conduit or pipes user?
09:26:45 <monochrom> "it can be done by 99.99% Turing-complete functions and 0.01% pattern matching, therefore it counts as pattern matching" is like "problems can be solved by writing down solutions"
09:26:56 <inquirydog> I am still trying to wrap my brain around why it works the way it does.
09:27:19 <YellowOnion> Could someone help me with some FFI/Windows errors? http://lpaste.net/133193 http://lpaste.net/133194
09:28:12 <monochrom> geekosaur: I gave up a month ago. or more. :)
09:28:44 <geekosaur> SrPx: I think you want extra-lib-dirs: /usr/local/cuda/lib and extra-libraries: cudart
09:30:14 <lpaste> Nils pasted “Roman Numerals in Haskell” at http://lpaste.net/133195
09:31:13 <rewbert> Sorry i've never heard the term before. What's a view pattern? I see you relating it to turing machines and i am currently taking finite automata theory where we talk about those. :-) among other things.
09:32:00 <enthropy> rewbert: it's what's going on in quchen's map
09:32:16 <quchen> Abomination, it's an abomination.
09:32:27 <monochrom> view pattern means you can write "f (Just x <- g) = x" and it desugars to "f y = case g y of Just x -> x"
09:32:39 <quchen> g -> Just x, monochrom 
09:32:48 <rewbert> Oh okay i get it
09:32:50 <quchen> rewbert: This is the GHC manual entry: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#view-patterns
09:32:52 <Cale> Not all view patterns are abominations, but it's certainly easy to abuse.
09:32:52 <rewbert> I see what you mean
09:33:02 <rewbert> Thanks for the link! Saving that for after dinner =)
09:33:35 <rewbert> Leaving for a while now, take care people.
09:33:39 <quchen> Cale: Right, when you use ViewPattern to provide a view pattern then they're fine. If you use it to move calculative logic into patterns, that's when you get abominations.
09:33:51 <Cale> Yeah
09:34:02 <nshepperd> 'case viewr xs of ...'
09:34:28 <nshepperd> of course the documentaton  of viewr will need to have O(n) written in big red bold letters
09:34:55 <quchen> That depends on the data structure.
09:35:03 <Welkin> oh, Sequence?
09:35:05 <Welkin> my favorite
09:35:07 <enthropy> Data.List.viewr would be a new name for reverse?
09:35:10 <monochrom> and on n
09:35:34 <Bor0> YellowOnion, I believe you need to link to the .lib file where this function is contained
09:35:52 <Bor0> which should be... user32.lib, according to msdn
09:35:53 <nshepperd> I suppose it *is* just reverse for a list
09:36:14 <Welkin> it doesn't make sense to have viewr for a list
09:36:16 <nshepperd> but indeed if you're looking at the other end, there's a chance you really want Seq
09:36:23 <Welkin> if you want that, you are using the wrong data structure
09:36:34 <YellowOnion> Bor0, I noticed some function calls append W to the end of it, now it seems to compile.
09:36:42 <monochrom> or your list should be reversed in the first place
09:37:25 <monochrom> CIS 194 credit card exercise is an example. you should store the reversed list of digits throughout, i.e., least significant digit should be head
09:37:34 <nshepperd> if your list's length is limited to less than 5 then lists are plenty fast
09:38:11 <nshepperd> to take the obvious case
09:38:22 <Bor0> YellowOnion, the notation is W for unicode, A for ansi
09:38:25 <Welkin> credit card verification exercises are always fun
09:38:31 <Bor0> W for wide rather :)
09:38:34 <Welkin> I remember writing one in c
09:39:51 <YellowOnion> Bor0, yeah I'm not familar with windows programming or the ffi interface, why does unhook not need the W at the end?
09:40:23 <Bor0> YellowOnion, no idea, long time since I did any WINAPI programming. I used to refer to msdn online documentation
09:41:46 <geekosaur> because it doesn't use a string, so something specifying what kind of string to use is worthless?
09:42:25 <doofarius> join #pilots
09:44:29 <Welkin> god dammit
09:44:30 <Welkin> spammers
09:55:08 <SrPx> geekosaur: hmm? Pardon, what do you mean? :(
09:55:36 <geekosaur> those are entries in the cabal file
09:55:52 <geekosaur> although you seem to have decided to play with unreliable lower level entries instead
09:57:59 <SrPx> uh okay
09:58:12 <SrPx> let me see if that works
09:59:35 <SrPx> but where I place hello.h and hello.cu and how do I tell cabal they exist?
10:02:05 <SrPx> That is, using what you said compiles, but then I get "Undefined symbols for architecture x86_64:   "_hello", referenced from:       _rTv_info in VoxelRayTracer.o" when I try to import Graphics.VoxelRayTracer from another haskell file
10:02:30 <SrPx> I'm not sure how this whole linking process works, so if there is a reference somewhere let me know, no need to waste your time
10:03:08 <geekosaur> likely involves includes
10:03:14 <geekosaur> https://www.haskell.org/cabal/users-guide/developing-packages.html#build-information
10:08:13 * hackagebot cryptonite 0.1 - Cryptography Primitives sink  http://hackage.haskell.org/package/cryptonite-0.1 (VincentHanquez)
10:08:19 <n1cky> I can't call digitToInt on a string, only on a char
10:08:39 <n1cky> how can i get a list of strings to be treated as a list of chars?
10:09:16 <geekosaur> > map Data.Char.digitToInt "12135"
10:09:18 <lambdabot>  [1,2,1,3,5]
10:10:34 <n1cky> > map Data.Char.digitToInt "6 6 4"
10:10:36 <lambdabot>  [6,*Exception: Char.digitToInt: not a digit ' '
10:11:02 <n1cky> map Data.Char.digitToInt words "6 6 4"
10:11:24 <n1cky> > map Data.Char.digitToInt words "6 6 4"
10:11:26 <lambdabot>      Couldn't match expected type ‘[Char] -> t’ with actual type ‘[Int]’
10:11:26 <lambdabot>      The function ‘map’ is applied to three arguments,
10:11:26 <lambdabot>      but its type ‘(Char -> Int) -> [Char] -> [Int]’ has only two
10:12:02 <geekosaur> > map (map Data.Char.digitToInt) (words "6 6 4")
10:12:04 <lambdabot>  [[6],[6],[4]]
10:12:08 <n1cky> d'oh.
10:12:10 <n1cky> thank you.
10:12:55 <n1cky> is it possible for me to pass that list as arguments to a function?
10:13:43 <geekosaur> I don't quite understand the question?
10:13:45 <Welkin> yes, if you pattern match on the list
10:13:54 <n1cky> coverRect x y z = ceiling (x/z) * ceiling (y/z)
10:13:55 <Welkin> (x:y:z:[])
10:14:06 <Welkin> then x, y, and z are your arguments
10:14:45 <Welkin> or, if you want the values inside each singleton list, ([[x],[y],[z]])
10:15:50 <Welkin> > concat map (map Data.Char.digitToInt) (words "6 6 4")
10:15:51 <lambdabot>      Couldn't match expected type ‘([Char] -> [Int]) -> [String] -> t’
10:15:51 <lambdabot>                  with actual type ‘[a0]’
10:15:51 <lambdabot>      The function ‘concat’ is applied to three arguments,
10:16:04 <Welkin> > concat $ map (map Data.Char.digitToInt) (words "6 6 4")
10:16:06 <lambdabot>  [6,6,4]
10:17:05 <YellowOnion> > map Data.Char.digitToInt (concat $ words "6 6 4")
10:17:07 <lambdabot>  [6,6,4]
10:18:25 <SrPx> geekosaur: read, still no idea :( I think it assumes a c knowledge I don't have. I guess I'll make a post on SO and leave this for later... for now I can just make a build script, I guess.
10:19:03 <SrPx> I think the problem is I don't know how the "hello.o" will get into "MyLib.o", if that makes sense? Anyway, thank you?
10:19:32 <YellowOnion> > [ x | x <- "6 6 4", Data.Char.isDigit x]
10:19:34 <lambdabot>  "664"
10:20:32 <aspidites> is there any reason that cabal installing something should freeze my entire system (arch linux 4.0.1 kernel)
10:20:35 <aspidites> ?
10:21:32 <YellowOnion> aspidites, swap partition on failing hardware maybe?
10:22:19 <aspidites> hm... would the absense of swap do the same thing?
10:22:25 <aspidites> hadn't bothered with it since i have 16gb ram
10:25:21 <Big_G> What is the best way of using Configutor if your main function doesn't have an output type that matches?
10:25:45 <aspidites> i'll try creating a swap partiton and see if anything improves
10:26:34 <geekosaur> swap likely a good idea. if running X11 that can mean the OOM killer decided to step in --- and killed the X server, leaving you with no way to get at it short of ssh
10:26:46 <geekosaur> (this used to be a common problem(
10:27:14 <aspidites> will be back to report. this is putting a damper on my ghcjs adventures :\
10:27:34 <vandenoever> is there a way to make more elegant use of ast here? http://lpaste.net/133205
10:27:58 <vandenoever> i'd like to avoid the SPAN_SPAN etc
10:34:34 <nocturne777> when should we use MonadIO instead of IO ?
10:34:56 <nocturne777> I came across MonadIO http://book.realworldhaskell.org/read/programming-with-monads.html
10:35:12 <nocturne777> but it does not explain why MonadIO is important
10:35:58 <Hafydd> nocturne777: you would be hard pressed to use MonadIO instead of IO, given that MonadIO is a typeclass and IO is a type.
10:36:44 <geekosaur> MonadIO lets you quickly get at the IO at the base of a monad transformer stack
10:37:57 <monochrom> don't look for importance. look for convenience first.
10:38:05 <nocturne777> geekosaur: hmm, I see. If the transformer implements MonadIO, you can lift IO from N layers below
10:38:12 <monochrom> very few things are important.
10:38:13 <geekosaur> yes
10:38:24 <geekosaur> liftIO instead of lift . lift . (...) . lift
10:38:33 <monochrom> corollary: whenever you see a new thing, 99% probability it is unimportant, just convenient.
10:38:35 <geekosaur> through a possibly unknown number of layers
10:38:53 <nocturne777> is it a good idea to hide the IO monad like the auther does in that link?
10:39:06 <geekosaur> it's not about hiding, as such
10:39:21 <nocturne777> yes, it's not about hiding
10:39:39 <geekosaur> it is good style to represent something like a database connection as a monad, which must have IO at its base
10:40:05 <Big_G> geekosaur, Would you know how to help me with getting config files in Haskell?
10:40:06 <geekosaur> this lets you enforce things like ensuring the database is properly closed after use, and in a well designed setup will let you encapsulate transactions and such
10:40:38 <geekosaur> but ultimately you may need to do IO with that (for example, read a data file and insert its contents into the database)
10:40:53 <geekosaur> you can only be "in" one monad, which will be the databsse, but you need access to the underlying IO
10:41:01 <geekosaur> so MonadIO makes that convenient
10:41:17 <geekosaur> Big_G, I don't know what's currently preferred for that
10:41:47 <Big_G> geekosaur, I've hear configurator and by itself, it's pretty nice. However, inside something like a do block breaks it
10:43:15 <nocturne777> geekosaur: I think the example author gives is misleading. It would have made more sense to me it was encapsulating a monad for database connection. it just seemed overkill to me to expose a seperate monad dedicate to file operations only.
10:43:53 <nocturne777> well, the only benefit in this case would be that if I see this monad in the type signature, I would know that that function is doing
10:43:54 <geekosaur> nocturne777, it's hard to do a good example that doesn't have so much extra stuff as to obscure the point you're trying to make
10:44:39 <nocturne777> *I would know what the function is doing
10:47:50 <zipper> Hey I've notices there's this pattern say there's a type `FooBar = FooBar {foo :: Config, bar :: FilePath}` and then I use in a function: `f Foobar{foo, bar} = error "stuff to do"` If `Config = Config {first :: String, sec :: String}` I am able to use `first` and `sec` directly in the function.
10:47:55 <zipper> *noticed
10:48:29 <zipper> Is this something usual in haskell syntax
10:48:32 <monochrom> you need an extension
10:48:41 <zipper> Oh which extension?
10:48:54 <zipper> Because I have seen it being used in code and it has me confused.
10:48:56 <geekosaur> so, a better example of MonadIO might be xmonad's core monad. newtype X a = X (ReaderT XConf (StateT XState IO) a) deriving (Functor, Monad, MonadIO, MonadState XState, MonadReader XConf)
10:49:05 <monochrom> NamedFieldPuns
10:49:20 <geekosaur> now we have direct access to the IO, the ReaderT, and the StateT
10:49:28 <geekosaur> and don't need to care where they are in the stack
10:49:47 <zipper> monochrom: In the code I've seen it used there's only ScopedTypedVariables and TupleSections and TemplateHaskell
10:50:34 <nocturne777> geekosaur: oh, I see what you mean. tnx for explanation.
10:50:40 <geekosaur> zipper, without an extension you can do Constructor {field1 = localname, field2 = anotherlocalname}
10:50:57 <geekosaur> the shorthand for reusing the field name as the local name requires NamedFieldPuns
10:51:23 <zipper> geekosaur: I don't think you get what I mean. Let me show you.
10:52:04 <monochrom> I have just checked the Haskell 2010 Report. the pattern "FooBar{foo, bar}" is a syntax error.
10:52:18 <geekosaur> ^
10:52:37 <geekosaur> although some extensions do turn on other extensions automatically
10:52:50 <geekosaur> but none of the ones you mentioned should turn on NamedFieldPuns
10:54:41 <YellowOnion> is there an improved haskell support for vim?
10:55:47 <YellowOnion> I mostly just want better syntax highlighting
10:57:21 <zipper> geekosaur: monochrom The comment explaining it is at the top http://lpaste.net/1027379073673854976#line25
10:57:30 <Welkin> YellowOnion: emacs has great syntax highlighting in haskell-mode
10:57:55 <Currier> YellowOnion: I'm sure a vim user will be better equipped to answer your question, but my local vim guru actually switched to emacs+evil mode (which gives you a vim-style normal and visual modes) and is quite happy
10:57:57 <Welkin> I believe there is a plugin called evil that lets you use vim keybindings
10:58:47 <geekosaur> zipper, you'd need to name that field inside the {}
10:58:57 <YellowOnion> Thanks, maybe I'll try it at some point if I can't find anything to improve vim.
10:58:59 <geekosaur> hm, wait
10:59:08 <geekosaur> no
10:59:12 <geekosaur> you have ideConfig
10:59:21 <geekosaur> you should probably show the error you got
10:59:37 <zipper> geekosaur: Thing is that I got no error when I used L25 as is
11:00:00 <geekosaur> think I need to see more of this, but at least I know where you got it from
11:00:07 <geekosaur> and I will guess it's doing something lens-y
11:00:26 <Currier> YellowOnion: Personally, having used emacs for years, I have also recently fallen in love with evil-mode. Made me look at vim in a new light.
11:01:36 <YellowOnion> Currier, what about in windows, double evil?
11:01:57 <monochrom> the pattern "IdeStaticInfo{ideConfig, ideSessionDir}" requires NamedFieldPuns. the pattern "GhcInitResponse{..}" requires RecordWildCards
11:02:38 <geekosaur> also note that extensions can be in the cabal file
11:02:56 <Currier> YellowOnion: My windows dev setup is, literally, emacs with evil. I forget who said it, but an emacs user once said that "Your OS is just a bootstrap for your emacs"
11:03:15 <zipper> geekosaur: I have updated the paste comment with the info you expected.
11:03:21 <zipper> geekosaur: http://lpaste.net/1027379073673854976
11:03:43 <zipper> geekosaur: Well I'm really trying to improve this: https://github.com/fpco/ide-backend/blob/master/ide-backend/IdeSession/GHC/Client.hs#L84
11:04:02 <YellowOnion> Currier, I've heard a few comments about Emacs being more an OS than a text editor been a few years now though :)
11:04:47 <Currier> YellowOnion: It kind of is, yes
11:04:54 <geekosaur> again, you need to look in the cabal file for other extensions
11:05:15 <geekosaur> YellowOnion, you do realize that vim is on that same path?
11:05:59 <geekosaur> about the only thing preventing it is that vimscript is so horrid to work with...
11:06:24 <Welkin> vimscript, haha
11:06:59 <Welkin> take a name, append "script", and make it run on top of javascript
11:07:37 <Currier> Then again, emacs lisp is far from ideal as well. And yet I still can't really get into Yi.
11:07:59 <geekosaur> far from ideal but still easier to work with than vimscript
11:08:11 <Currier> geekosaur: very true
11:08:16 <geekosaur> (I mean, wtf, they even had elisp as an example of how not to do it and they still came up with something worse?!)
11:10:46 <geekosaur> glah, ide-backend-server has no docs on hackage, I'd have to unpack locally and dig
11:11:41 <geekosaur> or root around on github, which has to be done manually because no hotlinking of symbols
11:11:55 <maerwald> I'm playing with http requests via Network.HTTP.Conduit and I wonder why there is no function that takes the responseHeader and responseBody and decodes the ByteString depending on the charset specified in the responseHeader. Do I have to write all that myself? I'd be surprised if that's not part of a library somewhere.
11:12:16 <YellowOnion> geekosaur, version 2.3 of win32 api has a similiar issue, no docs :(
11:12:28 <geekosaur> that's sadly expected though
11:12:32 <geekosaur> docs are built on linux
11:12:39 <geekosaur> as a side effect of building the packafe
11:12:47 <YellowOnion> 2.2 has them.
11:12:48 <geekosaur> so, kinda hard to build a win32 package
11:12:54 <geekosaur> someone uploaded them manually
11:13:02 <YellowOnion> ahh
11:13:10 <geekosaur> ask nicely in their bug tracker and maybe someone will upload current docs
11:13:46 <YellowOnion> if this project lasts more than a day, I will :)
11:13:58 <geekosaur> (also doesn't help that 7.10.1's haddock has a bug in building docs...)
11:14:48 <YellowOnion> I wonder if this is suppose to be type foreignHANDLE instead of HANDLE
11:15:27 <YellowOnion> can't find any examples of use of either type anywhere.
11:15:52 <zipper> geekosaur: Ah yes there is NamedFieldPuns in the Cabal file
11:16:03 <zipper> geekosaur: So I guess that's what.
11:16:15 <geekosaur> that's part of it. I can't tell what the rest is :/
11:16:17 <zipper> geekosaur: Much thanks. I was wondering what sorcery it was
11:16:58 <geekosaur> and when it comes from fpco, there's a decent chance of deep wizardry
11:17:17 <zipper> geekosaur: LOL you don't say.
11:17:31 <zipper> geekosaur: What should I do to learn this deep wizardry?
11:17:48 <zipper> geekosaur: You're killing me :D
11:18:11 <geekosaur> if I knew that'd I'd probably be doing it myself...
11:18:24 <geekosaur> *if I knew that, I'd
11:18:28 <monochrom> I don't think there is wizardry. there is only "the information is put in the wrong place"
11:18:57 <zipper> monochrom: Have you seen my paste?
11:19:08 <monochrom> yes
11:19:14 <Welkin> zipper: you left it on the table
11:19:21 <zipper> monochrom: What do you think is the reason?
11:19:36 <monochrom> I don't know. the information is put in the wrong place.
11:20:12 <zipper> monochrom: Well the extension NamedFieldPuns is enabled.
11:20:17 <zipper> Let me read about it.
11:22:59 <lpaste> Nils revised “Roman Numerals in Haskell”: “No title” at http://lpaste.net/133195
11:24:22 <zipper> geekosaur: monochrom This is all I could find on the extension https://www.haskell.org/cabal/release/cabal-1.10.1.0/doc/API/Cabal/Language-Haskell-Extension.html#v%3ANamedFieldPuns any help?
11:24:51 <monochrom> look into the GHC user's guide instead. it comes with GHC>
11:25:05 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#record-puns
11:25:45 <lpaste> Nils revised “Roman Numerals in Haskell”: “No title” at http://lpaste.net/133195
11:36:24 <lpaste> Nils revised “Roman Numerals in Haskell”: “No title” at http://lpaste.net/133195
11:37:37 <athan> Hey guys, is there an `eitherP` for parsec?
11:37:47 <Welkin> check hayoo
11:37:59 <Welkin> http://hayoo.fh-wedel.de/?query=eitherP
11:38:00 <Welkin> yes
11:38:20 <Welkin> oh, attoparsec at least
11:38:30 <athan> Welkin: That's where I'm suck
11:38:41 <athan> I'm thinking of using try, and fmapping Left / Right
11:39:09 <Welkin> https://hackage.haskell.org/package/JustParse-2.1/docs/Data-JustParse-Combinator.html
11:39:45 <Welkin> there are plenty of options listed on that hayoo results page
11:40:24 <athan> Welkin: But.. but... parsec ._.
11:40:49 <Welkin> eitherP :: Stream s t => Parser s a -> Parser s b -> Parser s (Either a b)
11:40:51 <Welkin> eitherP a b = M.liftM Left a <|> M.liftM Right b
11:40:55 <rayqiu> Hi, is anyone using diagrams 1.3 with GHC 7.10.1?  Having problem building diagrams-lib-1.3
11:41:04 <rayqiu> http://lpaste.net/133208
11:41:28 <mniip> how would I go about cross-compiling a haskell executable for windows
11:41:33 <athan> Welkin: Thank you :)
11:42:56 <lpaste> Nils revised “Roman Numerals in Haskell”: “No title” at http://lpaste.net/133195
11:43:36 <lpaste> Nils revised “Roman Numerals in Haskell”: “No title” at http://lpaste.net/133195
11:47:47 <enthropy> mniip: ghc run by wine can generate exes windows will run. But maybe there are other/ better options
11:48:18 * hackagebot midi-music-box 0.0 - Convert MIDI file to music box punch tape  http://hackage.haskell.org/package/midi-music-box-0.0 (HenningThielemann)
11:53:17 <kyren> hello, I have a possibly stupid question, I have this code: http://lpaste.net/133214
11:53:47 <Welkin> does anyone know what this means?
11:54:01 <kyren> for which I am getting this error: http://lpaste.net/133215
11:54:04 <Welkin> the "local variables list" in emacs when trying to open a file
11:54:31 <Welkin> it looks like something yesod is providing, although I've never seen it before
11:55:00 <Welkin> it seems to be
11:55:04 <Welkin> that is rather odd
11:55:51 <kyren> I am a terrible noob and clearly don't understand what ghc is trying to tell me here
11:56:07 <aspidites> not a memory problem.  :-(
11:56:24 <tdammers> ghc is telling you that your use of maxBound is invalid, because the type a in that expression doesn't implement Bounded
11:56:26 <aspidites> my system freezes indefinitely with ghc eating 97% cpu (thus, I presume it's actually using 100%)
11:56:40 <tdammers> the confusing part is that the a in the function body is not the same a as the one in the signature
11:56:42 <kyren> but it does?  there's a typeclass constraint above it that says it implements Bounded?
11:56:54 <kyren> OH derp
11:56:57 <kyren> yeah I get it now
11:56:59 <Haskellfant> take a look at scoped type variables
11:57:01 <kyren> a is another variable
11:57:02 <kyren> right
11:57:17 <kyren> you know I knew that and I put haskell down for a few weeks and poof there it went
11:57:29 <kyren> thank you!
11:57:44 <tdammers> np
11:57:55 <tdammers> I believe the explicit type annotation there might not be needed at all
11:58:08 <kyren> I thought it wouldn't be either..
11:58:16 <tdammers> oh wait, yes it is
11:58:29 <geekosaur> Welkin: which?
11:58:30 <kyren> oh okay yeah I guess it would be
11:58:43 <kyren> cause there's another fromIntegral, it could be any maximum bound
11:58:49 <kyren> right okay thank you
11:59:00 <tdammers> so yeah, ScopedTypeVariables might help
11:59:05 <tdammers> look it up
11:59:10 <kyren> yep yep, ty again
12:22:55 <lpaste> Nils revised “Roman Numerals in Haskell”: “No title” at http://lpaste.net/133195
12:29:19 <Welkin> geekosaur: .dir-locals.el
12:38:20 * hackagebot second-transfer 0.5.2.2 - Second Transfer HTTP/2 web server  http://hackage.haskell.org/package/second-transfer-0.5.2.2 (dsign)
12:47:19 <orion> I need to convert a fractional number from ASCII, store it in a data structure, and serialize the data structure to JSON. I want to avoid rounding errors that could change the value passed to me to something else when I serialize.
12:47:29 <Vektorweg1> someone should invent a http 2 alternative ...
12:47:36 <orion> I've looked at Data.Decimal and Data.Scientific.
12:47:49 <orion> Are either one of those good fits for my needs?
12:47:55 <orion> Or is there a better way?
12:48:21 * hackagebot darkplaces-text 0.2.1 - Parser for darkplaces colorful text  http://hackage.haskell.org/package/darkplaces-text-0.2.1 (slava)
12:48:33 <tdammers> Aeson uses Data.Scientific internally IIRC, so that'd be the most obvious candidate
12:51:30 <taruti> Has anyone done GPU-based neural network things in Haskell?
12:52:02 <taruti> e.g. deeplearning-hs perhaps?
12:55:28 <srhb> Fuuzetsu: Did you determine if reverting that commit caused lightdm logins to work?
12:56:14 <srhb> Oops, wrong channel.
12:58:21 * hackagebot hfoil 0.2.0.2 - Hess-Smith panel code for inviscid 2-d airfoil analysis  http://hackage.haskell.org/package/hfoil-0.2.0.2 (GregHorn)
13:11:41 <f|`-`|f> is the correction bot here
13:11:49 <f|`-`|f> s/re/are/
13:11:49 <rotcetorptekcop> f|`-`|f meant: is the corarection bot here
13:12:01 <f|`-`|f> ah, first match
14:09:59 <linkages> how do i define a recursive data list of strings ?
14:10:40 <linkages> something like data List String a =
14:10:53 <linkages> kind of lost
14:11:04 <sagittarian> linkages: i'm not clear on what you're trying to do
14:11:18 <tremon> linkages: what's a recursive list?
14:11:32 <linkages> need to define a recursive data type to model a list of lists ( that are strings ) 
14:11:52 <sagittarian> a list of strings is of type [String]
14:11:58 <sagittarian> what's recursive about it?
14:11:58 <linkages> recursive is the data type
14:12:23 <Welkin> a list is already recursive
14:12:31 <linkages> if i want to define my list in haskell i can use a recursive data type
14:12:53 <linkages> i will find an example
14:13:09 <gleber> data List a = Cons a List | Nil
14:13:10 <Welkin> data List a = Nil | Cons a (List a)
14:13:17 <linkages> es
14:13:21 <sagittarian> the builtin list type in haskell is basically the same as data List a = Nil | Cons a (List a)
14:13:21 <linkages> yes
14:13:24 <linkages> perfect
14:13:31 <sagittarian> plus some syntactic sugar
14:13:34 * gleber blushes, mine is incorrect
14:13:47 <rewbert> Could i ask a somewhat-but-still-not-very offtopic question?
14:13:56 <linkages> yes im trying to undestand the language... so i avoid built in
14:14:17 <sagittarian> rewbert: normally the penalty for that is death by slow torture, but I'm willing to make an exception in this case
14:14:28 <rewbert> Ahaha wonderful!
14:14:35 <Haskellfant> there is also #haskell-blah if it is _really_ ot
14:14:39 <rewbert> In my automata theory class my teacher mentioned that a push down automata with TWO stacks
14:14:43 <rewbert> pack the same power as a turing machine
14:14:54 <rewbert> How is this so? How would you represent the writing ability of a TM?
14:15:04 <rewbert> Would you use one of the stacks for that?
14:15:23 <sagittarian> haven't gotten that far in my automata course
14:15:28 <rewbert> I remember seeing some people here talk about TM earlier so i thought i'd ask :)
14:16:15 <rewbert> Ah that's too bad. It's an interesteing course. I emailed her and asked if she could spend some more time talking about it but she hadn't really much more to say.
14:16:28 <gleber> rewbert: https://cs.stackexchange.com/questions/2832/is-a-push-down-automaton-with-two-stacks-equivalent-to-a-turing-machine - this gives some intuition about them
14:16:43 <Haskellfant> rewbert: without having looked at it, I would say that you can use the two stacks as a list zipper representing the tape
14:16:43 <quchen> rewbert: Turing-writing a 1 should be popping and pushing a 1 in the double push-down automato, no?
14:18:38 <rewbert> Hm perhaps? There's also the thing about switching 'directions'. A TM can read a word 'backwards' in a sense.
14:19:57 <rewbert> The writing, perhaps as you say you could push to one stack all the symbols you read. And if you need to rewrite, you just push the new symbol to the stack instead of the old one?
14:20:06 <linkages> data ListaA String a = N | Cons (String a) ListaA String a -->> is this acceptable?
14:20:27 <rewbert> linkages: Why have you defined it as String a?
14:20:30 <rewbert> Does it compile?
14:20:53 <rewbert> I
14:20:53 <linkages> no its doesnt but i dont see the error
14:21:09 <linkages> i need String a as a parameter
14:21:15 <rewbert> Well by the looks of it you are trying to create a generic list, with type a, but you also specify the type String
14:21:28 <quchen> linkages: What is your data type supposed to represent?
14:21:34 <rewbert> I'd do it something like
14:21:39 <linkages> a list of strings
14:21:43 <linkages> quchen, 
14:21:54 <quchen> linkages: So what is the "a" for?
14:21:58 <rewbert> data myList a = Cons a (MyList a) | Nil
14:22:10 <rewbert> Or, if you ONLY need a list for string, replace a by String
14:22:16 <quchen> linkages: Do you understand how you'd write an ordinary list type on your own?
14:22:47 <linkages> quchen, dont get your question
14:23:05 <quchen> data List a = …?
14:23:29 <linkages> i need a list of lists data type
14:24:11 <sagittarian> linkages, if you want to define a list of strings datatype, I guess it would be data StringList = Nil | Cons String StringList
14:24:11 <linkages> quchen, data List a = Cons a List | Nil
14:24:20 <Welkin> linkages: almost
14:24:28 <Welkin> Cons a (List a)
14:24:45 <Welkin> it is recursive
14:24:45 <linkages> ok
14:24:49 <linkages> yes it is
14:25:01 <rewbert> Goodnight guys
14:25:04 <rewbert> :)
14:25:09 <rewbert> I spent some time in the java section earlier and yuk
14:25:11 <linkages> thx a lot guys for help
14:25:15 <Welkin> in the case of a list of lists, the "a" is another list
14:25:17 <rewbert> Haskell comminuty is so much nicer
14:25:28 <rewbert> community*
14:25:30 <linkages> wasnt?
14:25:52 <linkages> tank you Welkin 
14:45:30 <srhb> linkages: Also Nil should probably be the first constructor so that the derived Ord instance is sensible.
15:05:02 <Vektorweg1> hello, i try to get the unix package installed on windows. mingw and msys works, but in the configuration step or the end of it, sed couldn't handle some parameters. any idea what to do?
15:08:00 <mpickering> why is typed template haskell so little used?
15:10:40 <neuroserpens> Can anyone tell me what's going on with this? The code is in the first two lines and the error follows http://pastie.org/10204213
15:12:50 <valdyn> neuroserpens: (map (....) words), no dot.
15:13:10 <neuroserpens> valdyn: I don't understand
15:13:25 <neuroserpens> oh wait
15:13:27 <valdyn> neuroserpens: the last dot in the first line cannot be there
15:14:59 <srhb> neuroserpens: What do you think the type of withdraw is?
15:15:42 <neuroserpens> valdyn: umm... I got another error. Nevertheless, shoudln't words be applied to the input first so it returns a list of strings?
15:15:55 <valdyn> neuroserpens: nvm, i was wrong
15:15:55 <neuroserpens> srhb: It's Double -> Double -> Double
15:15:58 <neuroserpens> srhb: I think
15:16:06 <NicX> In chapter 8 of LYAH, we define a Bool data type as    data Bool = False | True deriving (Ord)    . Should that have been deriving (Eq, Ord) instead of deriving (Ord)?
15:16:09 <srhb> neuroserpens: Yes, agreed
15:16:21 <srhb> neuroserpens: That's just one of the issues though
15:17:36 <neuroserpens> srhb: What are the issues?
15:17:45 <srhb> neuroserpens: I'm not sure what you're expecting withdraw to do, but you're applying it to a list of Doubles
15:17:51 <srhb> It's type is Double -> Double -> Double
15:17:55 <srhb> Not [Double] -> Double
15:18:06 <neuroserpens> srhb: ooooooooh
15:18:12 <dmj`> NicX: Eq is a super class of Ord, can't have Ord w/o Eq
15:18:13 <srhb> Penny dropped. :-)
15:18:15 <dmj`> @src Ord
15:18:16 <lambdabot> class (Eq a) => Ord a where
15:18:16 <lambdabot>     compare              :: a -> a -> Ordering
15:18:16 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
15:18:16 <lambdabot>     max, min             :: a -> a -> a
15:18:28 <neuroserpens> srhb: rofl I need to separate those values... thanks a lot man
15:18:34 <neuroserpens> srhb: I forgot to do it
15:18:39 <srhb> No problem.
15:19:40 <srhb> neuroserpens: The other issues are using mod and so when you're expecting Double
15:19:42 <srhb> :t mod
15:19:43 <lambdabot> Integral a => a -> a -> a
15:19:45 <NicX> dmj`: ok, that clears my confusion. Thanks
15:20:00 <srhb> neuroserpens: Double does not have an Intergral instance
15:20:30 <neuroserpens> srhb: crap...
15:20:41 <srhb> neuroserpens: The final issue will be something along the line of using == with floating point arithmetics
15:20:47 <refefer> is there something like OverloadedStrings for Int/Integer?
15:20:57 <neuroserpens> srhb: holy mother...
15:20:58 <srhb> refefer: they are already fromIntegral
15:21:21 <refefer> srhb: yes, I know of fromIntegral.  unfortunately that has to be scattered everywhere
15:21:30 <refefer> trying to find something like OverloadedString
15:21:43 <srhb> refefer: No, I mean, whereas OverloadedString converts "foo" to fromString "foo"
15:21:51 <srhb> refefer: That already occurs for number literals by default
15:22:07 <refefer> oh, right, sorry
15:22:08 <srhb> refefer: So the answer is "yes there is, and it's already enabled."
15:22:22 <refefer> you're correct about that and my question is wrong
15:22:33 <srhb> :)
15:22:33 <refefer> is there an implicit converter from Int <=> Integer?
15:22:43 <srhb> > 2 :: Integer
15:22:45 <lambdabot>  2
15:22:45 <srhb> > 2 :: Int
15:22:47 <srhb> Magic.
15:22:47 <lambdabot>  2
15:22:48 <refefer> not literals
15:22:49 <valdyn> refefer: or fix your function types
15:23:01 <srhb> refefer: Then the answer is no, and there shouldn't be.
15:23:08 <refefer> valdyn: problem is the library I use takes Integer, but all list functions take Int
15:23:11 <refefer> it's all over the place
15:23:33 <srhb> There's no implicit conversion, it would be wrong.
15:23:47 <valdyn> refefer: so that library should really be using typeclass Integral i guess
15:24:02 <refefer> valdyn: might be since it's talking directly with C
15:24:05 <srhb> valdyn: Technically, list functions should too
15:24:07 <refefer> they opted not to
15:24:11 <valdyn> refefer: I think you wont get around explicit conversion then
15:24:25 <refefer> hmm, ok
15:24:54 <srhb> You cannot totally convert any Integer to Int, so it would be quite scary with implicit conversion.
15:25:24 <srhb> refefer: That said, if you're using (!!) or anything like that, you're probably Doing It Wrong
15:25:38 <valdyn> refefer: what ist function(s) are you talking about?
15:25:45 <valdyn> refefer: what *list* function(s) are you talking about?
15:26:11 <refefer> valdyn: take, (!!), etc.
15:26:57 <srhb> refefer: You probably want to use something other than list if you're doing lots of indexing operations
15:27:56 <refefer> srhb: in this case, list is fine: the length maxes out at the screen height and it's called once per render
15:28:04 <srhb> Alright. :)
15:28:24 <refefer> srhb: appreciate the thought though!
15:28:35 <srhb> refefer: Then you might be better off just redefining the indexing operations so you don't have to litter fromInts everywhere
15:28:45 <srhb> refefer: Only once for each of take, drop, (!!), ...
15:29:25 <refefer> srhb: yeah, I'm change it all to take Num
15:29:41 <refefer> probably best to segregate the C code as much as possible anyways
15:30:05 <srhb> refefer: Integral, not Num, right? take 3.14... would be weird :P
15:33:33 * hackagebot huttons-razor 0.1.0.1 - Quick implemention of Hutton's Razor  http://hackage.haskell.org/package/huttons-razor-0.1.0.1 (steshaw)
15:33:37 <neuroserpens> srhb: Haha! The code is ugly but it worked now xD http://pastie.org/10204233
15:35:00 <refefer> final question: how do I define a data with a typeclass constraint?
15:35:11 <sleblanc> I can't find a code example for SDL2's Graphics.SDL.Audio(mkAudioCallback)
15:35:21 <refefer> eg. data (Integral a) = Something a | SomethingElse
15:35:26 <sleblanc> Can someone help me use it?
15:35:41 <sleblanc> Oops, it's in Types, not Audio
15:37:22 <fishburne> Beginner here. Can someone please review a function I just made, to split a url into components, https://bpaste.net/show/e0e64acf8f16 
15:37:43 <zipper> Uh I have an issue with this syntax. I have a function foo that consumes a value of type Bar which is defined as Bar = Bar {a :: kity, b :: Cat}. How am I able to do something like this while pattern matching `foo Bar {a, b} = error "rest of func"` This way I am able to use a and b in the function without much hassle. 
15:37:48 <zipper> How is this doable?
15:38:05 <johnw> yes
15:38:13 <johnw> RecordWildcards is the extension you want to enable
15:38:18 <johnw> then: foo Bar {..} =
15:38:25 <johnw> and 'a' and 'b' will be in scope as the names of the member value
15:39:14 <johnw> it also works for setting the record members even: https://ocharles.org.uk/blog/posts/2014-12-04-record-wildcards.html
15:39:21 <zipper> johnw: What could I use to then get the fields within a and b if a and b are actually record types?
15:39:31 <johnw> fieldName a
15:39:32 <zipper> Without calling the fields as functions.
15:39:39 <johnw> you'd have to pattern match a and b
15:39:47 <zipper> johnw: No I've seen it being done.
15:39:48 <johnw> case a of AnotherRecord {..} -> ...
15:40:03 <johnw> are you perhaps talking about lenses?
15:40:52 <zipper> johnw: I don't know. It actually complains when I do fieldName a
15:41:14 <zipper> johnw: http://lpaste.net/1027379073673854976#line31
15:41:14 <johnw> RecordWildcards will project out your fields into local bindings with the same name, that's all it does
15:41:22 <zipper> Okay
15:41:28 <geekosaur> johnw, background is zipper is poking at ide-backend
15:41:53 <geekosaur> and there seem to be some lens-like things involved although I did not see an import of something I recognize as a lens / fclabels type package
15:42:02 <zipper> geekosaur: I feel so exposed now.
15:42:15 <geekosaur> it matters
15:42:16 <johnw> ah, I see
15:42:20 <zipper> but I guess it's okay.
15:42:40 <geekosaur> asking how stuff works in normal Haskell code is fine but may not be relevant to a particular package if it uses e.g. lenses
15:42:41 <johnw> I'm not sure why ideConfig's field names would be in scope...
15:42:53 <johnw> (as locally bound values)
15:43:09 <zipper> johnw: I'll ask the people who wrote it.
15:43:26 <wgosling> Does waitForProcess from System.Process close the handle, or do I need to do that myself after?
15:43:51 <fishburne> Beginner here. Can someone please review a function I just made, to split a url into components, https://bpaste.net/show/e0e64acf8f16 
15:44:55 <johnw> fishburne: oh, you'd love Parsec
15:45:04 <johnw> you're basically manually unrolling what Parsec does
15:45:31 <zipper> No There's a function in System.FilePath for that
15:45:35 <johnw> with Parsec you'd write this:
15:45:37 <monochrom> johnw, geekosaur: I think I have an elementary explanation. suppose "data X = C{f :: Maybe Y}". therefore, "f" is in scope and of type X -> Maybe Y. therefore, "case f of Nothing -> ..." is a type mismatch of "Maybe Z" vs "X -> Maybe Y"
15:45:42 <zipper> I did something like that recently
15:46:46 <johnw> fishburne: in Parsec language, the top-level would look like this: Url <$> parseProtocol <*> parseHost <*> (parsePort <|> pure "") <*> parsePath
15:46:56 <zipper> WOW I can't find that code where I thought it was.
15:47:36 <fishburne> johnw, yes. I have heard about it. But I just did this as an excercise. 
15:47:48 <johnw> where parseProtocol has type "Parser String", and it's implemention is: manyTill anyChar (try (string "://))", or something along those lines
15:48:00 <johnw> fishburne: well, it's a great way to understand Parsec before using it
15:48:30 <johnw> intro article: good 
15:48:33 <johnw> intro article: http://unbui.lt/#!/post/haskell-parsec-basics
15:49:09 <fishburne> yes. thank you.
15:50:51 <joneshf-laptop> refefer, there was a ghc extension that allwoed that, but I think it's deprecated
15:51:00 <joneshf-laptop> refefer, another option is gadts
15:51:45 <johnw> joneshf-laptop: they were called "Data type contexts": https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/data-type-extensions.html
15:52:37 <joneshf-laptop> have there been proposals to change the way type classes are defined? not necessarily better but different ways.
15:52:40 <joneshf-laptop> johnw, thanks
15:53:08 <joneshf-laptop> like how you can't specify which type variables are used except by order
15:53:30 <joneshf-laptop> though that seemslike it'd just cause issues later on with overlaps
15:56:55 <zipper> Oh my why am I so tense when testing my code.
16:04:05 <JuanDaugherty> inexperience?
16:05:01 <zipper> geekosaur: I wonder why it felt so bad when it was discovered that I don't know all the things about the package. This must be getting in the way of learning.
16:05:12 <zipper> Must kill this shame that imedes learning.
16:05:28 <JuanDaugherty> having drunk the hs kool aid about code in that lang being correct/not needing debugging if written right?
16:05:46 <geekosaur> I have no idea. but I'm used to trying to figure out someone else's code that is likely cleverer than I am >.>
16:06:18 <JuanDaugherty> p
16:07:01 <zipper> JuanDaugherty: Yeah you're right.
16:07:03 <zipper> LOL
16:07:42 <tejon> Anyone care to help with My First Monad Transformer Stack? :P
16:08:52 <dmj`> tejon: sure
16:09:08 <dmj`> to transform a monad is a noble thing
16:10:50 <joneshf-laptop> i remember there was a way to squash multiple th lines into one, but i can't remember the way. Does anyone know what i'm talking about?
16:11:11 <tejon> Awesome, thanks. This should be easy enough: I need to make an HTTPS request with http-conduit, and I have profile data that defines parts of the header and URL. Since http-conduit's Request type has no constructor, I need to build the request from the supplied default.
16:12:00 <dmj`> tejon: sure
16:12:05 <tejon> So this sounds like a (StateT Request) smooshed in with a (Reader MyProfile).
16:13:58 <tejon> The bit where I'm getting caught up is, what's the type of the function which does the actual work, and what do I need to wrap it in to be able to call the whole glob with just a MyProfile argument?
16:15:13 <dmj`> tejon: ok, before we proceed, what do you mean the Request type has no constructor
16:15:50 <dmj`> tejon: after you call req <- parseUrl "myurlhere.com", you can update the fields on the record, req { method = "POST" } etc. 
16:15:59 <tejon> Well, not exposed. You're supposed to call "def" which returns a default Request, and build yours by changing its fields.
16:16:16 <dmj`> tejon: ok sure, you just want an nicer interface for this
16:16:26 <tejon> Right, State seems appropriate to the job.
16:16:41 <dmj`> sure, so are you familiar with the transformers and mtl packages?
16:16:58 <tejon> Only in a vague theoretical sense, that's why I'm here. :)
16:17:18 <dmj`> tejon: ok
16:17:35 <tejon> It looks like all I can pass to State is the starting state, not the additional data in my profile. That's why I think I need to tack a Reader on.
16:18:18 <tejon> I could build a (Request, Profile) tuple and just use that, but this seems like too good a learning opportunity to pass up. :)
16:18:22 <dmj`> tejon: will your profile data ever change?
16:18:50 <tejon> No, it's actually fixed at runtime.
16:18:53 <johnw> tejon: there's also RWS
16:18:59 <dmj`> tejon: ok let's just build a stack for fun, then you can see wether or not its overkill for your use case
16:19:41 <dmj`> tejon: true, what johnw says might be good too, do you need to perform IO while building up your request? (Like getting epoch time) or something
16:19:49 <dmj`> tejon: or can it stay pure
16:20:09 <tejon> The request is a pure construct, yeah. Everything about it is dictated in advance.
16:22:14 <dmj`> tejon: well we could try both I guess
16:24:01 <dmj`> we don't really need a writer though
16:24:24 <dmj`> tejon: unless you want to log all requests constructed for something
16:24:47 <tejon> No, writer doesn't seem necessary.
16:26:00 <tejon> But the fact is, for my actual application I could just hard-code the request in a top level binding. The only thing that will ever change is the query, which of course I can adjust at the call point. This really is all about learning for me, so I'm happy to wander down any garden path you think might be relevant. :)
16:27:36 <dmj`> tejon: ok, well suppose you did need arbitrary IO in your stack while you were building up the request (need to get the current time) -- ignoring the fact you could just pass in a UTCTime
16:32:22 <dmj`> tejon: The transformers package provides "transformed" versions of your favorite Monads, (State, Reader, Writer), as (StateT, WriterT, ReaderT) etc. Meaning you can use them inside of a base monad (where this monad itself can be a transformer), and stack them n stories high (like an onion kind of). Anything that is a valid instance of the MonadTrans class is considered a transformer. The mtl package exposes type classes for the types
16:32:22 <dmj`> defined in transformers (MonadState, MonadReader), which do a lot of heavy "lifting" so you execute the right function at the right layer in the stack. 
16:32:30 <dmj`> :i MonadTrans
16:32:52 <dmj`> @src MonadTrans
16:32:52 <lambdabot> Source not found. Abort, Retry, Panic?
16:33:48 <dmj`> class MonadTrans t where lift :: Monad m => m a -> t m a 
16:34:00 <dmj`> tejon: where t is a higher kinded type ( * -> * )
16:34:10 <dmj`> so you'll see that StateT, WriterT, all abide by this
16:34:11 <dmj`> :k StateT
16:34:13 <lambdabot> * -> (* -> *) -> * -> *
16:34:14 <dmj`> :k WriterT
16:34:15 <lambdabot> * -> (* -> *) -> * -> *
16:34:16 <dmj`> :k ReaderT
16:34:18 <lambdabot> * -> (* -> *) -> * -> *
16:35:24 <dmj`> tejon: so in your case you'd want a type ReqBuilder a = ReaderT Profile (StateT Request IO) a 
16:35:34 <tejon> TIL I don't quite understand kind notation...
16:35:42 <dmj`> tejon: are you familiar with kinds?
16:36:39 <dmj`> tejon: kinds are just the type of types, when creating valid instances for typeclasses it's important to use them
16:36:47 <dmj`> to understand them*
16:36:56 <tejon> Well I had thought so. :) I'm trying to figure out what each of those *'s correlates to.
16:37:10 <cuddlybacon> Newbie here: I have an impure function. I am trying to pattern match the tuple of values I get out but it is not matching. I'm not sure why. How do I figure out what data I actually have?
16:37:21 <tejon> Oh wait, I'm comparing to the type you listed for `lift`, which isn't the type of the data.
16:38:43 <dmj`> tejon: I'm sorry I got that wrong, the kind of 't' is (*->*) -> * -> *
16:38:51 <dmj`> the kind of m is * -> *
16:39:13 <tejon> Okay! Now it matches up to my existing vague intuition. :)
16:39:48 <tejon> So to be clear --> in your case you'd want a type ReqBuilder a = ReaderT Profile (StateT Request IO) a
16:39:57 <tejon> Is there a reason Reader is on the outside, or is that arbitrary?
16:40:56 <dmj`> it does make a difference, especially if you have a stack with two transformers of the same type
16:43:10 <dmj`> tejon: also, we use a typedef since we get all the mtl instances for free (MonadState, MonadReader), we could create our own newtype though, and use the GenerazliedNewtypeDeriving extension and derive Monad, Functor, Applicative, MonadTrans, MonadReader Profile, MonadState Request, automatically
16:43:41 <dmj`> tejon: this is outlined in RWH too
16:44:02 <joneshf-laptop> cuddlybacon, do you have some types of your functions?
16:44:48 <tejon> Hmm, last time I tried RWH I hit a wall, but it's been a while. Making a note to tackle it again.
16:46:14 <phaazon> hey, I don’t get it
16:46:27 <phaazon> why do people keep saying package management is bad in Haskell?
16:46:32 <phaazon> isn’t cabal good enough for that?
16:46:56 <simpson> phaazon: There's lots of fundamental problems that are uncomfortable to work around.
16:47:08 <phaazon> like what?
16:47:09 <simpson> For example, one cannot have two different versions of a single package within a single build.
16:47:21 <cuddlybacon> joneshf-laptop: It's createProcess from System.Process, so... createProcess :: CreateProcess -> IO (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)
16:47:25 <phaazon> simpson: that sounds right to me
16:47:30 <phaazon> that would generate clashes
16:48:14 <phaazon> the single part that bothers me about cabal is the Cabal Hell
16:48:20 <joneshf-laptop> phaazon, single build == where cabal stores packages per user
16:48:22 <phaazon> otherwise, I don’t see why package management sucks
16:48:24 <simpson> phaazon: And yet there are many cases where diamond dependency graphs arise...
16:48:38 <phaazon> joneshf-laptop: well, we can have that
16:48:43 <phaazon> cabal install stuff
16:48:46 <phaazon> cabal install stuff --reinstall
16:48:53 <phaazon> it just installs another version
16:48:59 <joneshf-laptop> also there's no way to uninstall with cabal
16:49:01 <phaazon> but doesn’t erase the one already there
16:49:10 <phaazon> joneshf-laptop: ghc unregister
16:49:19 <tejon> phaazon: The problem happens when two packages you depend on each depend on different versions of another package. Doesn't matter that both versions are installed; they can't coexist in a single build.
16:49:34 <phaazon> tejon: why so?
16:49:40 <joneshf-laptop> phaazon, so you use a different tool to uninstall
16:49:47 <joneshf-laptop> phaazon, this is another reason
16:49:54 <phaazon> joneshf-laptop: I mean
16:50:11 <phaazon> a library name is composed of the name, the version on the hash
16:50:19 <phaazon> I don’t see why we couldn’t have several versions installed
16:50:27 <phaazon> s/on/and
16:50:29 <joneshf-laptop> phaazon, that's the point
16:50:35 <joneshf-laptop> phaazon, we could have better
16:50:39 <joneshf-laptop> phaazon, but we dont
16:50:51 <simpson> phaazon: I believe that you've circumscribed the point, yes.
16:50:56 <joneshf-laptop> :)
16:50:58 <simpson> Things *could* be better but are *not*.
16:51:06 <phaazon> hm
16:51:23 <phaazon> right
16:51:25 <phaazon> pity
16:52:48 <tejon> I've repeatedly argued for inverting the current version management scheme. Depend on single specific versions of other modules; add a value to module.cabal specifying how far back the current version maintains compatibility.
16:53:24 <tejon> Moves the decision of whether or not more work has to be done by people who may or may not be paying attention to the point where the most expertise is concentrated about whether that's actually necessary.
16:54:36 <dmj`> tejon: http://lpaste.net/133221
16:56:00 <tejon> Of course everything works better with smaller packages. I still don't get why orphan instances are such a problem, but fighting them sure *causes* extra problem resolving dependencies. :/
16:56:01 <dmj`> :k ReaderT Int (StateT Int IO) 
16:56:02 <lambdabot> * -> *
16:56:22 <tejon> dmj' : Awesome, give me a minute to absorb this!
16:58:21 <dmj`> tejon: you tear them down in reverse order (from how you build them up), you're just unwrapping the onion really
16:58:26 <dmj`> :t \prof req stack -> execStateT (runReaderT stack prof) req 
16:58:27 <lambdabot> Monad m => r -> s -> ReaderT r (StateT s m) a -> m s
16:59:18 <dmj`> the execState(T) will return the modified state as the result of the computation (the request building)
17:04:26 <benzrf> monad transformer stacks are like onions. they have layers.
17:05:32 <tejon> something something parfait
17:06:37 <dmj`> tejon: http://lpaste.net/133222
17:06:42 <dmj`> tejon: there were actually used IO
17:07:37 <dmj`> tejon: should have this... setToCurrentTime :: (MonadIO m, MonadState Request m) => m ()
17:08:34 <dmj`> tejon: see how that is generic? We don't explicitly use RequestBuilder a, so now we can set the time on *any* monad stack that is an instance of MonadState with a Profile as its state, and also can perform IO (MonadIO), keeping stuff generic is a good thing
17:09:17 <dmj`> er, with a *Request* as its state
17:10:53 <dmj`> the point is that we can use that function w/ a RequestBuilder a since its an instance of those typeclasses, but we're not relegated to that stack, we're polymorphic still
17:15:33 <dmj`> tejon: grabmullers paper is good if interested, Monad transformers step by step
17:15:59 <dmj`> http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
17:16:38 <tejon> dmj`: I'm still fiddling with the code you lpasted, thanks for all this!
17:17:22 <tejon> So if RequestBuilder were a type instead of a newtype, I'd get all those derivations for free, right? Is there some benefit to newtype in a case like this?
17:18:25 <dmj`> tejon: they'd be free since you'd really just be typedefing a ReaderT, and ReaderT is already an instance of MonadReader, so yea you wouldn't need to derive. 
17:18:49 <dmj`> tejon: well, typedefs can't derive anything really, they're just type defs
17:19:35 <tejon> Right, I guess concentrate on the second question there. :) Does newtype have a benefit here? Or are there closely-related situations where it's necessary?
17:20:15 <gremble> What would be a nice way to catch a case-insensitive string in a case statement? Preferably without changing the string
17:20:18 <dmj`> tejon: Is there a benefit in this case? Maybe not, but suppose you had a few stacks, where you want to be specific about the functionality, then yes. newtype is great for other things too though, you can now make your own Show instance let's say. 
17:20:33 <tejon> Ah, that's a good point.
17:20:43 <tejon> I've used it for exactly that, heh.
17:21:49 <dmj`> tejon: oh and another thing, as RWH points out, you can't partially apply a type synonym
17:22:34 <dmj`> tejon: meaning, if we typedef'd let's say, type Foo = StateT .. blah... we couldn't use Foo as our base monad anywhere
17:22:59 <tejon> Huh. Why is that?
17:23:38 * hackagebot miniutter 0.4.4.2 - Simple English clause creation from arbitrary words  http://hackage.haskell.org/package/miniutter-0.4.4.2 (MikolajKonarski)
17:23:55 <tejon> I see from the source for StateT that if you partially apply it in the typedef itself, that's OK.
17:24:12 <dmj`> tejon: according to RWH it's a restriction on type synonyms
17:24:20 <tejon> i.e.: State s = StateT s Identity
17:25:13 <dmj`> StateT isn't a typedef, State might be
17:25:35 <tejon> State is, I just looked.
17:26:12 <tejon> And I guess that works because the partial application is part of the type itself, whereas if it were "State s a" you'd be stuck with full application everywhere.
17:26:33 <dmj`> tejon: this blows up http://lpaste.net/133223
17:27:11 <dmj`> tejon: I think it applies to all type synonyms, so not just typedef'ing transformers
17:27:48 <tejon> Weird. I'm sure there's some good reason for it, but I've probably stuffed enough new things in my head for now, heh.
17:29:08 <tejon> Back to the task at hand, in my case I can just replace the IO with Identity, right? Or for that matter, replace "StateT Request IO" with just "State Request" because I'm not going to derive anything further from it.
17:32:51 <geekosaur> it's because a partially applied type synonym is a type function, and type functions break things like type inference
17:34:01 <lazer> click me #codemaster #codemaster #codemaster #codemaster #codemaster #codemaster #codemaster #codemaster #codemaster #codemaster #codemaster #codemaster #codemaster #codemaster #codemaster click me #codemaster #codemaster #codemaster #codemaster #codemaster #codemaster #codemaster #codemaster #codemaster #codemaster #codemaster #codemaster #codemaster #codemaster #codemaster
17:34:15 --- mode: ChanServ set +o geekosaur
17:34:28 --- mode: geekosaur set +b *!~fxxwm@212.154.80.5
17:34:28 --- kick: lazer was kicked by geekosaur (Your behavior is not conducive to the desired environment.)
17:34:53 --- mode: geekosaur set -o geekosaur
17:38:31 <dmj`> tejon: in your case I would just use a simple State, or a RWS
17:38:47 <dmj`> if you don't need IO, then no need to transform
17:39:13 <dmj`> tejon: or maybe try and write a RS :)
17:40:25 <dmj`> tejon: you could just strip out the `w` in RWS 
17:40:58 <tejon> Hmm. Is there a benefit to that, versus just stacking them?
17:41:40 <srhb> Well there is a small overhead cost for each monad in the stack, but not really.
17:42:55 <dmj`> :k ReaderT String (StateT String Identity)
17:42:56 <lambdabot> * -> *
17:43:09 <tejon> So probably worth it with more than 2 layers. But also that's probably why there's no RS in the base library. :)
17:46:06 <dmj`> :t \rdr ste stack -> runIdentity ( execStateT ( runReaderT stack rdr ) ste)
17:46:08 <lambdabot> r -> a -> ReaderT r (StateT a Identity) a1 -> a
17:46:30 <dmj`> where 'a' is your Request modified by the StateT
17:46:53 <Hail_Spacecake> Now we're explicitly dereferencing num. Why does &nums give us references? Firstly, because we explicitly asked it to with &. Secondly, if it gave us the data itself, we would have to be its owner, which would involve making a copy of the data and giving us the copy. With references, we're just borrowing a reference to the data, and so it's just passing a reference, without needing to do the move.
17:47:17 <Hail_Spacecake> bah, wrong channel, sorry
17:48:04 <Hail_Spacecake> I have something of a conceptual question
17:48:29 <dmj`> tejon: maybe Identity as base monad is a good idea here
17:48:50 <Hail_Spacecake> namely, how do I map over a list, where the function I want to map doesn't just take the nth list entry as an argument, but also the (n+1) and (n-1)th items (with special cases for the first and last in the list)?
17:49:21 <gremble> is :+ a thing?
17:49:23 <Hail_Spacecake> to be concrete, suppose I have a list [1,2,3,4,5], and I wnat to map each i in the list ot the average of i, the previous entry, and the next entry
17:49:41 <Hail_Spacecake> and just ignore the missing 3rd item for the first and last in the list
17:49:46 <Hail_Spacecake> obviously I cna't write that with a map
17:50:14 <Hail_Spacecake> but, it's also hard to write that by using indices in a functional language
17:50:18 <tejon> Hail_Spacecake: I did something just like this earlier today!  zipWith3 myFunc3 (0:0:myList) (0:myList) myList
17:51:14 <Hail_Spacecake> well in this case I odn't want to use zero
17:51:40 <tejon> Well yeah, that was just a quick example. My actual case from earlier was: zipWith (-) (0:list) list
17:51:52 <tejon> Or actually other way around with the lists.
17:51:59 <Hail_Spacecake> I guess what I really want is a function with signature Maybe Int -> Int -> Int -> Int so I can take care of the first and last cases
17:52:12 <Hail_Spacecake> but, that leaves the problem of how do I get a Maybe Int for a list index that may not exist
17:52:21 <Hail_Spacecake> where I don't really have the concept of an index available?
17:52:31 <srhb> Hail_Spacecake: zip it up with indices
17:52:38 <dmj`> > splitEvery 3 [1..5]
17:52:40 <lambdabot>  [[1,2,3],[4,5]]
17:52:41 <dmj`> > map (\xs -> sum xs `div` length xs) $  splitEvery 3 [1..5]
17:52:43 <lambdabot>  [2,4]
17:53:28 <srhb> But it sounds like the problem is really better suited to some stateful manipulation of a zipper
17:53:31 <tejon> dmj`: My understanding was that he wanted every set of three, not groups of three.
17:54:10 <srhb> (You don't care about indices if you just want to be able to look left and right anyway)
17:54:22 <tejon> Anyway,
17:54:38 <tejon> > Nothing : map Just [1..5]
17:54:41 <lambdabot>  [Nothing,Just 1,Just 2,Just 3,Just 4,Just 5]
17:57:31 <dmj`> > map (\x -> sum x `div` length x) $ filter (\[x,y,z] -> x+1 == y && y+1 == z) $ filter ((==3) . length) $ subsequences [1..5]
17:57:33 <lambdabot>  [2,3,4]
18:00:50 <joneshf-laptop> Hail_Spacecake, is there an identity for your elements?
18:11:01 <m_ryan> hi how to capitalize each word in haskell e.g "capitize me" -> "Capitalize Me", thank you
18:11:45 <srhb> m_ryan: Make a function that capitalizes one word, then split your string into a list of words, then map that function over it, then stick it back together.
18:12:14 <lpaste> tejon pasted “spacecake.hs” at http://lpaste.net/133227
18:12:30 <tejon> @ Hail_Spacecake ^
18:12:39 <enthropy> > over (worded . _head) toUpper $ "capitalize me"
18:12:41 <lambdabot>  "Capitalize Me"
18:13:54 <tejon> Hail_Spacecake : Wait, that one's slightly wrong...
18:18:05 <lpaste> tejon revised “spacecake.hs”: “Hail_Spacecake.hs” at http://lpaste.net/133227
18:20:24 <tejon> Hail_Spacecake : ^ That can probably be made prettier, but I believe it fits your spec? Output of "spacecake [1..5]" is: [1.5,1.3333333333333333,2.3333333333333335,3.3333333333333335,4.333333333333333]
18:20:26 <m_ryan> srhb & enthropy: thank you.
18:21:21 <tejon> Which, now that I think about it, seems entirely wrong. But it does consider all the triplets. So where did I screw it up... :)
18:22:37 <tejon> Oh right, I didn't update the zipper function.
18:26:29 <lpaste> tejon revised “spacecake.hs”: “spacecake.hs” at http://lpaste.net/133227
18:26:49 <tejon> Much better without the case statement, heh.
18:27:14 <tejon> spacecake [1..5]  ==  [1.5,2.0,3.0,4.0,4.5]
18:29:01 <tejon> I guess that won't handle singleton input. Add: maybeAverage Nothing (Just y) Nothing = y
18:29:17 <tejon> = Just y, rather
18:31:10 <lpaste> tejon revised “spacecake.hs”: “spacecake-the-ultimate.hs” at http://lpaste.net/133227
19:07:33 <kern_chicken_pan> Hi
19:09:31 <tommd> Hello kern_chicken_pan, welcome to #haskell.
19:15:10 <unb3k44n7>  Hi :)
19:17:15 <hiptobecubic> Hello friends! Help me golf. [1, -1, 2, -2, 3, -3 ...]
19:17:35 <hiptobecubic> i've done it implementing zigzag [1..] [-1, -2..]
19:17:59 <haasn> > [1..]>>= \x->[x,-x]
19:18:01 <lambdabot>  [1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13,14...
19:18:01 <hiptobecubic> i've made an ugly looking one with (\x -> [x, negate x])
19:18:25 <hiptobecubic> haasn, is there a way to make that one pointless?
19:18:40 <haasn> hiptobecubic: Yes, but probably not prettier
19:18:41 <hiptobecubic> > [id, negate] <*> [1..]
19:18:43 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
19:18:45 <hiptobecubic> I was sad to see that
19:18:53 <hiptobecubic> so it does all the id's first, then all the negates
19:19:10 <haasn> hiptobecubic: \x -> [x, -x] = \x -> x:(-x):[]
19:19:13 <haasn> go from there
19:19:20 <pacak> > ap (:) (return . negate) 3
19:19:21 <lambdabot>  [3,-3]
19:20:27 <unb3k44n7> How about [1, infinity*infinity2]
19:21:07 <hiptobecubic> oh interesting
19:21:22 <joneshf-laptop> @pl \xs -> xs >>= \x -> [x, negate x]
19:21:23 <lambdabot> (ap (:) (return . negate) =<<)
19:21:35 <haasn> > [1..]>>=ap[id,negate].pure
19:21:38 <lambdabot>  [1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13,14...
19:21:40 <hiptobecubic> > ((:) <*> return . negate) >>= [1..]
19:21:42 <lambdabot>      Couldn't match expected type ‘[a] -> a -> b’
19:21:42 <lambdabot>                  with actual type ‘[Integer]’
19:21:42 <lambdabot>      In the second argument of ‘(>>=)’, namely ‘[1 .. ]’
19:21:45 <hiptobecubic> err, damn
19:21:59 <hiptobecubic> > ((:) <*> return . negate) =<< [1..]
19:22:01 <lambdabot>  [1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13,14...
19:22:03 <unb3k44n7> My version saved a lot of keystrokes. 
19:22:41 <haasn> > join[[x,-x]|x<-[1..]]
19:22:43 <lambdabot>  [1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13,14...
19:23:07 <unb3k44n7> Which equals to seconds of your life you'll never get back. Lol.
19:23:09 <haasn> this is slightly longer than my first version but contains no space :)
19:25:11 <m_ryan> hi what is the diff b/w splitOn and splitAt
19:25:13 <epichero> remember the first 3 times i sat down and said i was going to learn haskell? me too... maybe this time 
19:25:34 <joneshf-laptop> :t splitOn
19:25:36 <lambdabot> Eq a => [a] -> [a] -> [[a]]
19:25:36 <joneshf-laptop> :t splitAt
19:25:38 <lambdabot> Int -> [a] -> ([a], [a])
19:26:05 <haasn> > splitOn " " "foo bar bat baz"
19:26:06 <lambdabot>  ["foo","bar","bat","baz"]
19:26:09 <haasn> > splitAt 5 "foo bar bat baz"
19:26:11 <lambdabot>  ("foo b","ar bat baz")
19:26:33 <luyifan> yeap
19:26:37 <unb3k44n7> Why does Haskell have the word Fubar in it?
19:27:13 <unb3k44n7> Acronym, rather.
19:28:30 <luyifan> why :info map  don't have priority
19:28:34 <luyifan> ?
19:28:47 <luyifan> but :info (=<<) have priority?
19:29:04 <luyifan> what different of map and (=<<)
19:29:17 <luyifan> is map not a function ?
19:29:19 <simpson> luyifan: Only operators have precedence.
19:29:33 <pavonia> usually
19:29:36 <m_ryan> thanjs you.
19:30:10 <luyifan> simpson: thx
19:31:15 <init> simpson: you can set the precende of infix operators
19:31:51 <luyifan> dose it mean that operators is not a function?
19:32:23 <pavonia> An operator becomes a function when you enclose it in parantheses
19:34:07 <unb3k44n7> Would anyone recommend this book? *blushes http://learnyouahaskell.com/
19:34:36 <unb3k44n7> I found it under "Haskell for Dummies..."
19:35:15 <pavonia> I think it's the most recommended beginners' book here
19:35:47 <Cale> Brent Yorgey's course has become more recommended recently... http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html
19:36:01 <luyifan> is that mean (=<<) become the highest priority when we enclose it in parantheses , not 6 ,but 10?
19:36:22 <unb3k44n7> ^sarcasm?
19:37:11 <Cale> luyifan: When enclosed in parens, it's not an infix operator, and so doesn't have a priority like that, but ordinary function application binds more tightly than any infix operator, so yeah, kind of like 10
19:37:19 <unb3k44n7> Hi, Cale. :)
19:37:24 <Cale> Hello
19:37:32 <pavonia> Cale: What does CIS 194 stand for?
19:37:47 <luyifan> Cale: thx,I understand.
19:37:53 <epichero> computer information science probably
19:38:05 <unb3k44n7> Does this course start someone out at literally ground zero?
19:38:09 <epichero> that link is for a course at upenn you can tell just by reading it if you're used to seeing those
19:38:28 <epichero> just give it a shot
19:38:53 <kadoban> unb3k44n7: No. bitemyapp recommends you start with a (specific) book first if you've never programmed before, I forget which one.
19:39:42 <epichero> if you want to suggest bitemyapp's approach then you could just link his github learning haskell repo
19:39:42 <Cale> It starts out pretty basic, as far as I can tell, but if you end up getting stuck on things, of course feel free to ask questions here and try other resources as well.
19:39:50 <unb3k44n7> What if you can't do math but know how to program? Is there a guide for people like that for this language?
19:40:34 <kadoban> unb3k44n7: You can probably do cis194 then. It's not heavy on math, I wouldn't say. Functional programming in general … math could help I guess, but it's not particularly required that I can tell.
19:41:13 <haasn> http://www.vex.net/~trebla/haskell/prerequisite.xhtml
19:43:01 <luyifan> I am read "real world haskell" ,http://book.realworldhaskell.org/read/ ,it's my first book of function programming  
19:45:58 <unb3k44n7> The introduction on the Introduction page to that guy's lectures were still confusing.
19:49:17 <stelleg> @free x :: a -> a -> a
19:49:17 <lambdabot> f . x y = x (f y) . f
19:50:53 <unb3k44n7> I think I pick up on more just sitting in here than I do reading anything. 
19:53:27 <refefer> any recommendations for command line flag parsing?
19:54:27 <m_ryan> > splitOn "-" "Hello-World"
19:54:29 <lambdabot>  ["Hello","World"]
19:55:58 <m_ryan> > unwords . splitOn "-" "Hello-World"
19:56:00 <lambdabot>      Couldn't match expected type ‘a -> [String]’
19:56:00 <lambdabot>                  with actual type ‘[[Char]]’
19:56:00 <lambdabot>      Possible cause: ‘splitOn’ is applied to too many arguments
19:56:10 <ttt_fff> how do I tell cabal to "(1) don't generate files into dist/...." instaed, put files into "~/tmp/junk/dist/..." ?
20:00:18 <blogle> Are there any interesting languages to contribute to that dont compile down to javascript?
20:01:09 <haasn> blogle: No
20:01:10 <simpson> blogle: All Turing-equivalent languages can be transformed into each other.
20:01:25 <ttt_fff> haskell's compilation to js sorta sucks
20:01:36 <ttt_fff> there's haste (which isn't ghc compartible) and ghcjs (which is a bitch to install)
20:01:39 <simpson> Which means that the presence of a JS compiler for a language is mostly dependent on whether somebody with the gumption has done it.
20:01:43 <ttt_fff> blogle: please fix *.hs -> *.js
20:01:58 <grpala> > unwords $ splitOn "-" "Hello-World"  -- m_ryan 
20:02:00 <lambdabot>  "Hello World"
20:02:22 <haasn> ttt_fff: wasn't ghcjs integrated into ghc these days?
20:02:37 <ttt_fff> haasn: that would be amazing. when? news release?
20:02:38 <haasn> I could be making things up
20:02:49 <KaneTW> blogle: sure, if you can create a programming language more powerful than turing machines that'd be great
20:03:00 <KaneTW> we could finally solve that pesky halting problem
20:03:05 <ttt_fff> haasn: I can't find anything lke that on google
20:03:07 <haasn> ttt_fff: oh, no; I'm making things up
20:03:18 <blogle> I should clarify.. any languages where the priority IS NOT compiling to js
20:03:29 <haasn> ttt_fff: how is ghcjs a bitch to install, though?
20:03:30 <ttt_fff> blogle: do what haasn just suggest4d, hook ghcjs into ghc, ppl will lov eyou for it
20:03:37 <ttt_fff> haasn: have you tried installing it?
20:03:37 <m_ryan> grpala: thanks :)
20:03:47 <ttt_fff> haasn: I've instaleld ghcjs like 3 times, each time was like 4 hours
20:03:57 <m_ryan> :t over
20:03:59 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
20:04:01 <haasn> ttt_fff: I'll try now
20:04:42 <ttt_fff> haasn: do it inside a virtualbox, so you can send me an disk image if you get it working
20:05:03 <simpson> blogle: Most languages are that way.
20:05:30 <m_ryan> :t worded
20:05:32 <lambdabot> (Applicative f, Indexable Int p) => p String (f String) -> String -> f String
20:06:18 <blogle> @simpson, most recent open source projects seem to have js in mind. purescript, ghcjs, typescript
20:06:18 <lambdabot> Unknown command, try @list
20:06:55 <unb3k44n7> Pabst is a pretty good beer.  I've concluded that Haskell has some pretty cool terms in it. Pasbst.. Fubar.. whoever the creators were knew what was up, no?
20:07:15 <blogle> atleast the popular open source projects seem to target js
20:07:24 <simpson> blogle: Rust, Go, Monte. You're just cherry-picking.
20:08:49 <m_ryan> :t toUpper
20:08:51 <lambdabot> Char -> Char
20:09:11 <haasn> ttt_fff: done
20:09:25 <ttt_fff> haasn: wtf
20:09:26 <epichero> experimental js compilers for all of these
20:09:28 <ttt_fff> haasn: how did you install it?
20:09:43 <haasn> ttt_fff: I followed the instructions at https://github.com/ghcjs/ghcjs
20:09:45 <epichero> cept monte idek what that is
20:10:03 <simpson> epichero: New language. Doesn't compile to JS.
20:10:41 <ttt_fff> haasn: which OS ?
20:10:41 <haasn> ttt_fff: specifically, these ones: git clone https://github.com/ghcjs/ghcjs-prim.git && git clone https://github.com/ghcjs/ghcjs.git && cabal install ./ghcjs ./ghcjs-prim
20:10:44 <unb3k44n7> There's not that many cool terms in the medical field. Except for maybe STAT. Maybe I should have chosen a profession that was more gramatically fun.
20:10:52 <haasn> Although I added “cabal sandbox init” before “cabal install”.
20:11:05 <epichero> yeah, not all do, better examples would be something like julia or nim, except nim targets c so you could take it to js
20:11:08 <haasn> ttt_fff: Gentoo
20:11:15 <blogle> Heres the link I found for Monte https://monte.readthedocs.org/en/latest/intro.html
20:11:17 <KaneTW> haasn: did you do the rest
20:11:22 <KaneTW> ghcjs-boot etc
20:11:24 <ttt_fff> haasn: hmm, interesting; i'm on OSX; thanks for the data point :-)
20:11:28 <haasn> KaneTW: Which rest? “build the libraries”? I'm running that command right now
20:11:29 <ttt_fff> oh yeah
20:11:34 <ttt_fff> ghcjs-boot can result in lots of errors
20:11:34 <KaneTW> ttt_fff: well there's your problem
20:12:48 <unb3k44n7> Whenever I want a mocha iced coffee while I'm working I just scream 
20:13:03 <unb3k44n7> "STAT!" at people. And alas, It's in my hands.
20:13:30 <haasn> I'm starting to think unb3k44n7 is some sort of bot based on markov chains
20:13:52 <KaneTW> wasn't there talk about something similar in -blah?
20:13:56 <unb3k44n7> ^ Haha. Sorry... 
20:18:28 <ttt_fff> why markov chains? isnt' the recent hye[ all in recurrent neural networks ?
20:21:01 <unb3k44n7> At least I haven't been accused of being a "Troll" in here yet. It seems to be a common accusation when I'm on a channel. I'm optimistic of our psedo bonding. I'll accept being  Markov Chain Bot.
20:21:43 <unb3k44n7> pseudo*
20:22:02 <unb3k44n7> a*
20:23:22 <haasn> ttt_fff: Indeed ghcjs-boot did in fact run into an error, but this is mostly my fault. It's complaining about the fact that ghcjs-pkg isn't in PATH, which indeed it isn't, since I installed it into a sandbox (and only exported a modified PATH inside the local shell)
20:23:35 <haasn> Presumably, if I actually added it into my PATH, it would not have this complaint
20:25:52 <ttt_fff> haasn: or it gets a different error
20:26:03 <ttt_fff> :-)
20:26:17 <ttt_fff> i basically constantly run into cabal hell
20:26:24 <ttt_fff> until I nuke all my existing ~/.cabal before installing ghcjs
20:26:48 <haasn> I don't have ~/.cabal
20:27:00 <haasn> cabal sandboxes tend to fix this problem, although it doesn't seem to like being inside a sandbox *that* much
20:30:58 <pacak> sanboxes localize cabal hell inside sandboxes...
20:31:34 <ttt_fff> maybe i should learn how to use cabal sandbox
20:31:40 <haasn> ttt_fff: Oh, the PATH thing was entirely my fault. I added .cabal-sandbox/bin to PATH, not the absolute path of where I have ghcjs installed
20:32:48 <haasn> ttt_fff: So that one doesn't really count. Ignoring that issue, I've run into one so far: /usr/lib64/ghc-7.8.4/package.conf.d/builtin_rts.conf did not exist because it was renamed /builtin_rts-gentoo-ghc-7.8.4-r4.conf by my package for whatever reason
20:33:07 <ttt_fff> haasn: so ghcjs-boot works now ? 
20:33:11 <haasn> ttt_fff: seems to
20:33:17 <haasn> (After I added the symlink)
20:33:25 <haasn> cc luite, what's up with that?
20:36:47 <unb3k44n7> Does anyone know why freenode doesn't accept connections from VPNs?
20:40:09 <crocket> Does haskell beat C++ when you need to hit GPU for machine learning?
20:40:11 <simpson> unb3k44n7: Abuse prevention.
20:42:42 <unb3k44n7> Nm. I think It's the other way around. The VPN is blocking IRC.
20:44:22 <crocket> Does haskell make it easy to hit GPUs?
20:44:30 <crocket> Does haskell make it simple to hit GPUs?
20:45:48 <wei2912> crocket: you just need a hammer
20:45:57 <wei2912> easy, simple, cheap to hit GPUs
20:46:04 <crocket> wei2912, GPUs are not nails.
20:46:07 <wei2912> and efficient
20:46:26 <wei2912> crocket: i was punning on the usual definition of "hit"
20:46:37 <Hafydd> When all you have is a hammer.
20:46:47 <crocket> haskell is not hammer.
20:47:08 <wei2912> ^^
20:47:12 <Hafydd> λ looks a bit like a disfigured hammer.
20:47:49 <wei2912> ... :P
20:48:35 <saulzar_> crocket, C++ has some advantages given the amount it integrates with cuda for example, but there's some interesting stuff in Haskell - e.g. the accelerate library...
20:48:58 <crocket> saulzar_, ありがとう
20:49:14 <gienah> crocket: which is described in chapter 6 of Parallel and Concurrent Programming in Haskell - Simon Marlow
20:52:04 <haasn> ttt_fff: It completed successfully now
20:52:06 <ttt_fff_> okay; sandbox working
20:52:18 <ttt_fff_> haasn: interesting, thanks for testing it out on gentoo :-)
20:52:23 <ttt_fff_> I am about to give ghcjs another shot myself
20:52:37 <ttt_fff_> haasn: tell me, did ghcjs get instlaled in a local sandbox, or did it put itself into ~/.cabal ?
20:52:49 <haasn> ttt_fff_: I installed it into a local sandbox in /tmp(
20:52:56 <haasn> because I have no intention of keeping it around
20:53:04 <ttt_fff_> so the ghcjs binary is in /tmp/... ?
20:58:50 <crocket> Given the momentum haskell is getting, will haskell beat C++ in GPU programming in the next 10 years?
21:01:04 <haasn> ttt_fff_: It was in /tmp/.cabal-sandbox/bin
21:01:09 <haasn> It is now in /dev/null
21:04:28 <gcganley> would there be any benifit in having a haskell like language that is strict by default with optional laziness, I for one dont think that we should change haskell to strict but I was just curious if that would work in the real world. I'm more focusing on the optimization of compiled code sort of end.
21:04:46 <gcganley> I saw the reddit thread last night but i didnt really retain much from it
21:07:19 <f|`-`|f> it's usualy the case that it's simpler to write strict in terms of lazy
21:07:34 <crocket> Will haskell GPU programming become simple without losing performance?
21:08:09 <simpson> crocket: Probably not. GPU programming isn't simple nor easy.
21:08:22 <f|`-`|f> Hmmm
21:08:25 <haasn> gcganley: One of the interesting things here is that there are different kinds of strictness
21:08:35 <crocket> Can GPU programming become as simple on haskell as on C++?
21:08:42 <f|`-`|f> Hmmm
21:09:05 <f|`-`|f> Just humming here
21:09:43 <f|`-`|f> But I'm not sure about that, simpson , the dev group behind Feldspar and Obsidian are making headway into becoming faster than C++
21:11:20 <simpson> f|`-`|f: I didn't say anything about speed. GPUs are nasty complicated pieces of hardware and I'm quite skeptical that they'll ever be easy/simple to use.
21:11:31 <f|`-`|f> ah
21:12:09 <f|`-`|f> and then I point back to Feldspar/et al being able to push the limits of optimising FPGA's
21:12:32 <f|`-`|f> Not really sure if they are comparable
21:16:45 <f|`-`|f> Maybe it's too much faith in metaheuristics, or applied mathematics sparing us the details
21:24:44 <KaneTW> crocket: definitely
21:25:07 <KaneTW> gpu programming benefits a lot from the benefits purity provides
21:25:16 <haasn> simpson: Depends on the task, I bet. I find GLSL very intuitive
21:25:58 <KaneTW> simpson: gpus aren't more complicated for HPC work than CPUs (no idea about non-GPGPU stuff)
21:26:08 <haasn> For stuff that follows the traditional pipeline
21:27:28 <simpson> haasn: And your GLSL is supported by a several-pass compiler, two memory managers, and cooperative scheduling on what is effectively a NUMA coprocessor.
21:28:19 <m_ryan> > over (worder . _head) toUpper $ "hello world"
21:28:21 <lambdabot>      Not in scope: ‘worder’
21:28:21 <lambdabot>      Perhaps you meant one of these:
21:28:21 <lambdabot>        ‘worded’ (imported from Control.Lens),
21:28:24 <ReinH> f|`-`|f: have you looked at Conal's stuff on optimizing gpus?
21:28:33 <f|`-`|f> nuh
21:28:37 <m_ryan> > over (worded . _head) toUpper $ "hello world"
21:28:41 <lambdabot>  "Hello World"
21:28:46 <f|`-`|f> I keep on finding things by the Obsidian Devs
21:29:35 <f|`-`|f> papers pls?
21:29:49 <f|`-`|f> glory to arztotzka?
21:30:03 <KaneTW> beat me to it
21:30:18 <KaneTW> i had to look up how to spell arstotzka
21:30:44 <f|`-`|f> Kolechian scum
21:31:35 <KaneTW> you spelled it wrong sooooo
21:32:54 <f|`-`|f> Thought it was all z's
21:33:32 <haasn> simpson: Right, but my languages for programming CPUs are also supported by complicated abstractions; I guess the question we should be asking ourselves is whether or not clean abstractions exist but rather how much performance overhead those abstractions imply
21:34:30 <haasn> So “is simple GPU programming possible?” should become “can we make simple GPU programming without sacrificing much performance?”
21:36:18 <simpson> haasn: Oh! My POV is that you cannot discount the millions of lines of C that make up your GPU stack. I am biased here since I've worked on GPU drivers. It's not easy and not simple.
21:37:29 <haasn> simpson: One thing I've noticed is that the new trend in GPU driver design seems to be going towards low-level approaches, rather than high-level approaches
21:37:49 <haasn> And I wonder if this is not the inverse of what we've been doing for CPUs over the past decades
21:37:55 <haasn> How well is it going to work out?>
21:37:57 <simpson> haasn: I'm not sure what you mean by that. GPU drivers are written in either C or C++.
21:38:17 <Ralith> simpson: he means presenting a low-level interface
21:38:18 <haasn> simpson: I mean that newer APIs such as Mantle and DirectX 12 seem to be throwing away old abstractions and giving game developers much more direct access to the hardware
21:38:20 <Ralith> less abstraction in the driver
21:38:41 <simpson> haasn: I don't buy that; the amount of obligation for somebody to actually *use* one of these APIs is zero.
21:38:50 <Ralith> ??
21:38:51 <simpson> If you want, you can open /dev/dri/card0 and crap random bytes into it.
21:39:03 <Ralith> gamedevs are broadly quite excited to use those APIs
21:39:23 <simpson> Nothing prevents you from doing it. In fact, your GPU driver's work all boils down to crapping random bytes into DRI nodes.
21:39:37 <Ralith> the economics of using nonstandard interfaces prevent you from doing it
21:39:55 <haasn> As does the lack of open documentation about GPU hardware interfaces
21:39:57 <ReinH> simpson: all programming boils down to crapping random bytes somewhere. What's your point?
21:40:04 <simpson> And yet people are excited about nonstandard interfaces like Mantle, Vulkan, and Direct3D?
21:40:14 <simpson> ReinH: That it's neither easy nor simple!
21:40:33 <carter> fractal yaks
21:40:36 <carter> all the way down
21:40:37 <Ralith> vulkan and direct3d are both well documented and standardized
21:40:48 <Ralith> mantle is not intended for wide use
21:40:53 <Ralith> (it was basically a prototype for vulkan)
21:40:53 <m_ryan> hi can anyone help me with this code. can't figure out what does the error pointing out : http://lpaste.net/133235
21:41:05 <haasn> Mantle was essentially turned into Vulkan and Direct3D 12, as I understand it
21:41:09 <simpson> Ralith: How do I Direct3D on Linux or OSX? Where are reference (software rendering) implementations for Vulkan?
21:41:12 <ReinH> simpson: right, that's why we... you know... create programming languages
21:41:23 <f|`-`|f> ReinH  where are the links to gpu research ;-;
21:41:43 <Ralith> simpson: however you like
21:41:50 <ReinH> f|`-`|f: here's a bit http://conal.net/papers/Vertigo/1206-elliott.pdf
21:41:56 <haasn> simpson: WINE contains an implementation of the Direct3D API
21:41:59 <simpson> Ralith: The answers are "I can't" and "it doesn't exist".
21:42:18 <haasn> It maps them down to OpenGL calls, as I understand it
21:42:25 <Ralith> the things you tell yourself are not necessarily "the answers" :p
21:42:49 <simpson> haasn: Sure, but only with Win32/Win64 linkage, and only on x86... Gallium Nine isn't a full answer either. Direct3D is *proprietary*.
21:43:38 <haasn> simpson: What, in your opinion, constitutes a “standard” way to interact with GPUs?
21:43:41 <m_ryan> hi can anyone help me with this code. can't figure out what does the error pointing out : http://lpaste.net/133235
21:44:09 <unb3k44n7> Yay! I'm on the 5th page of the learnyouhaskell guide! I choose this guide because It's slightly ammusing. I find things less painful to read if they have a little comedy. 
21:44:22 <simpson> haasn: GL is relatively standardized, although there's still a big extension API, a necessarily platform-specific initializer (except for EGL, which has its own issues), and lots of different versions.
21:44:43 <unb3k44n7> chose*
21:44:48 <simpson> haasn: VGA/VESA standards are well-covered; nearly all consumer-level and professional-level GPUs come with VESA emulation.
21:45:08 <unb3k44n7> < Making headway. Lookout yall. ;)
21:45:21 <haasn> Are you suggesting that all software, all games, all media players etc. should be written with OpenGL and/or VGA/VESA emulation modes?
21:45:33 <simpson> Nope! I'm suggesting that the field is neither easy nor simple to make headway in!
21:45:43 <Ralith> I don't think anybody was claiming that
21:45:48 <haasn> But you seemed to suggest that it was silly to be excited about alternatives to those options
21:45:52 <unb3k44n7> Lies!
21:46:33 <haasn> I, for one, don't think OpenGL sufficiently covers my use cases and am excited for Vulkan's developments to the API. I wonder if they will fix the issues I have
21:46:42 <simpson> Vulkan's the only new thing backed by a standards body (Khronos), and it's the same standards body that brought us VG, MAX, EGL, and all those other delightfully unused standards.
21:47:01 <ReinH> unb3k44n7: well, LYAH is a bit amusing, but it is sadly lacking in exercises...
21:47:01 <Ralith> cherrypicking much
21:47:18 <haasn> Isn't Khronos in charge of OpenGL?
21:47:21 <Ralith> they are
21:47:22 <ReinH> (which are the things that actually help people learn)
21:48:00 <unb3k44n7> ReinH: Fortunately. I like to read multiple sources (at the same time) to get the fullo picture of things.
21:48:16 <simpson> Ralith: I mean, look at the top of https://www.khronos.org/ and see how many of their standardized APIs you actually recognize and use.
21:48:24 <unb3k44n7> But this guide is making the process more bearable.
21:49:07 <ReinH> unb3k44n7: would you like to buy a wonderful haskell book?
21:49:22 <ReinH> I'm not shilling, just not everyone wants to pay to learn haskell
21:49:32 <unb3k44n7> I still have no idea why I'm reading any of this. But It's been fun so far. 
21:50:26 <ReinH> heh
21:50:55 <unb3k44n7> Paid shill!!
21:51:01 <ReinH> I wish :)
21:51:40 <ReinH> unb3k44n7: anyway, http://www.amazon.com/Thinking-Functionally-Haskell-Richard-Bird/dp/1107452643 is probably the best book on functional programming I've ever read
21:51:47 <ReinH> it'll teach you Haskell and more besides
21:52:33 <ReinH> If you follow that up with Simon Marlow's (free) book on parallel and concurrent programming in Haskell, you'll be very well prepared. http://chimera.labs.oreilly.com/books/1230000000929
21:53:22 <unb3k44n7> How about if I ever finish a complete guide to Haskell, and I successful code something meaningful in it, I'll take you up on that book.
21:53:34 <m_ryan> > over (worder . _head) toUpper "hello world"
21:53:36 <lambdabot>      Not in scope: ‘worder’
21:53:37 <lambdabot>      Perhaps you meant one of these:
21:53:37 <lambdabot>        ‘worded’ (imported from Control.Lens),
21:53:37 <unb3k44n7> successfully*
21:53:46 <m_ryan> > over (worded . _head) toUpper "hello world"
21:53:48 <lambdabot>  "Hello World"
21:54:06 <m_ryan> :t over
21:54:08 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
21:54:58 <ReinH> unb3k44n7: well, the free guides to haskell are a bit lacking :(
21:55:11 <unb3k44n7> Offtopic - that show Mr. Robot looks pretty cool I wanna see the premier. 
21:55:30 <ttt_Fff> * Cabal     Synopsis: A framework for packaging Haskell software     Default available version: 1.22.3.0     Installed versions: 1.18.1.3, 1.22.3.0 .... how do I remove 1.18.1.3 ?
21:55:36 <ttt_Fff> I need to remove the old version of Cabal
21:55:38 <ttt_Fff> how do I remove it?
21:55:44 <m_ryan> :t worded
21:55:45 <lambdabot> (Applicative f, Indexable Int p) => p String (f String) -> String -> f String
21:55:51 <unb3k44n7> Usually the case, ReinH. 
21:56:01 <ReinH> unb3k44n7: Not necessarily, but often.
21:56:34 <ReinH> unb3k44n7: what's your experience?
21:56:45 <unb3k44n7> However, It's a start. I won't spend money on a guide/book about a topic if I cannot get through the basics of said topic of what I am trying to figure out.
21:56:48 <m_ryan> hi what library does "worded" belongs?
21:57:16 <ReinH> ttt_Fff: ghc-pkg unregister, iirc
21:57:46 <ReinH> unb3k44n7: what's your experience with programming and what's your interest in Haskell, if I may ask?
21:57:47 <unb3k44n7> I can branch off to more elaborated information later
21:57:57 <unb3k44n7> Such as perhaps the book you mentioned
21:58:34 <ReinH> m_ryan: looks like it's in lens. I found out by asking FP Complete's hoogle: https://www.fpcomplete.com/hoogle?q=worded&env=ghc-7.8-stable-14.09
21:58:47 <ReinH> which indexes more than the "official" one.
21:59:32 <ReinH> Anyway it has a weird name that is typical of lens's use of strange declensions
21:59:42 <ReinH> (to avoid collision with more standard names)
22:00:33 <unb3k44n7> My interest in Haskell is that I stumbled onto this channel a few days ago, which was also the first day I ever used IRC. I didn't know what Haskell was, but in search of finding a group of people I enjoyed chatting with (which was, Coincidentally found in here) I learned what Haskell was.
22:00:50 <unb3k44n7> My background in programming: Wavering and ammusing. 
22:02:24 <ReinH> unb3k44n7: well, that seems like a pretty reasonable way to approach Haskell
22:02:59 <ttt_Fff> lol
22:03:04 <ttt_Fff> firstchannle onirc = haskell
22:03:23 <ReinH> I'm afraid you might be in for a bit of a rude awakening if you try other channels...
22:03:31 <f|`-`|f> How so?
22:03:37 <m_ryan> ReinH: can you check this code: http://lpaste.net/133235, i use the worded but i has a error.
22:03:44 <ttt_Fff> ##c is also very friendly
22:03:46 <ReinH> m_ryan: well, I don't know how to use worded...
22:03:48 <unb3k44n7> I designed some websites and programs a long time ago. Mostly websites. Except I can't tell you how, as it was a long time ago. I don't learn well with textbook usage and can't often explain how I do things. I kind of just look at things and "do", if that makes any sense.....
22:04:05 <ReinH> unb3k44n7: There are some learning materials curated at https://github.com/bitemyapp/learnhaskell
22:04:20 <ttt_Fff> learn you a haskell for great good is very nice
22:04:23 <f|`-`|f> They are problem sets, but interesting things
22:04:29 <ReinH> And there is also #haskell-beginners, run by the guy that curates that list and which nominall supports those materials
22:04:37 <ReinH> *nominally
22:04:43 <m_ryan> ReinH: the main purpose of my code is to caps all the first letter in a sentence: eg. "hello world" -> "Hello World"
22:04:51 <ReinH> unb3k44n7: so you might find some good materials there, and some help here and in that channel
22:05:19 <ReinH> unb3k44n7: and if you find it worthy, I really do think that Thinking Functionally with Haskell will be very rewarding
22:05:25 <m_ryan> ReinH: also when i use lamdabot: it works. but when i apply it has an error
22:05:36 <m_ryan> > over (worded . _head) toUpper "hello world"
22:05:39 <lambdabot>  "Hello World"
22:05:39 <unb3k44n7> *thumbs up. Ty.
22:05:46 <ReinH> unb3k44n7: <3
22:05:50 <unb3k44n7> :)
22:06:00 <ReinH> unb3k44n7: we're generally a friendly group. Let us know if you have questions and good luck. :)
22:06:30 <ReinH> unb3k44n7: (and if we're not friendly, that is a bug.)
22:06:55 <ReinH> m_ryan: looking
22:07:41 <ReinH> m_ryan: well, you didn't import _head, so ghc thinks it's a hole
22:08:04 <ReinH> (holes are a new feature that use identifiers that start with a _)
22:08:36 <m_ryan> ReinH: what library does _head belong?
22:08:48 <ReinH> m_ryan: also lens
22:08:51 <unb3k44n7> Oh, for sure the friendliest group of people on here that I have met. So much in fact that I stopped bothering to explore much of any other channels after only a few days of using IRC.
22:08:51 <ReinH> you just didn't import it
22:09:00 <ReinH> unb3k44n7: :)
22:09:24 <ReinH> m_ryan: https://hackage.haskell.org/package/lens-4.11/docs/Data-List-Lens.html
22:09:30 <ReinH> is where it's at
22:09:42 <unb3k44n7> Like, for example, don't go to #jupiterbroadcasting. They are crazy in there. 
22:09:52 <ReinH> I don't even know what that is
22:09:54 <unb3k44n7> ... just saying.
22:09:57 <ReinH> Cale: ping
22:09:59 <unb3k44n7> Me either!
22:10:08 <epichero> i never thought to try some random channel like that but now i want to 
22:10:17 <ReinH> heh
22:10:49 <ReinH> I suspect that haskell is significantly friendlier (statistically speaking) than a randomly selected irc channel...
22:10:49 <unb3k44n7> Epichero: It's not really as fun as it sounds. Trust me. 
22:11:02 <ReinH> so there are no broadcasts from the solar system's largest plane?
22:11:05 <ReinH> planet*
22:11:08 <ReinH> shame
22:11:23 <f|`-`|f> Well, it's certainly less homoerotic than the channels I've randomly come across, ReinH 
22:11:36 <ReinH> Hmm.
22:13:01 <epichero> ;) 
22:24:09 * Rotaerk gives f|`-`|f a backrub.
22:24:21 <f|`-`|f> That's sexual harrassment
22:24:31 <f|`-`|f> No wonder why tech is so sexist against women
22:24:38 <sylow1> what
22:24:48 <sylow1> it isn't
22:25:27 <f|`-`|f> :^)
22:26:13 <Rotaerk> haskell is sexist because a man's name was chosen for it
22:26:16 <f|`-`|f> I understand that you can't reasonably cause parity within a non-representative demographic
22:26:26 <f|`-`|f> But tell that to greater media, or mainstream
22:28:45 <Rotaerk> I vote we rename it to something more gender neutral, like Jessie
22:29:16 <f|`-`|f> Well already have Julia
22:29:42 <nshepperd> ...
22:29:47 <f|`-`|f> s/well/we/
22:29:50 <sylow1> i just read the cutest exerpt from here
22:29:57 <sylow1> that i had to come check it out
22:30:01 <f|`-`|f> ?
22:30:06 <sylow1> https://gist.github.com/quchen/5280339
22:31:57 <nshepperd> I wonder if that one actually came back
22:32:03 <ReinH> Oh, yeah, that's what happens when we're in a good mood
22:32:06 <ReinH> (collectively)
22:32:30 <rcyr> Hmm, does anyone knows if the "Haskell Platform" project is dead?
22:32:36 <f|`-`|f> Uh
22:32:44 <f|`-`|f> Everyone in here seems to point you away from it
22:32:49 <f|`-`|f> Other than babby steps
22:32:58 <ReinH> rcyr: I don't know, but most haskellers don't use it
22:32:59 <f|`-`|f> I think the main issue is updating everything
22:33:14 <rcyr> Even for OSX? (That's what I use)
22:33:15 <f|`-`|f> I don't even know how to use Command Line
22:33:28 <ReinH> It installs a bunch of outdated libraries that are immediately incompatible with things you want to use. :/
22:33:28 <Rotaerk> that's almost like a robber walking into a church and getting converted
22:34:00 <ReinH> it's pretty easy to just find a library you want to use and add it to your cabal file and `cabal install --dependencies-only`
22:34:05 <carter> ReinH: use GHC for OS X
22:34:08 <carter> by etrepum 
22:34:13 <carter> @google ghc for os x
22:34:14 <lambdabot> https://ghcformacosx.github.io/
22:34:15 <f|`-`|f> Haskell seems more powerful than the Cathedral of Mahogany and Mahogany Accessories
22:34:55 <carter> rcyr: use ghc for osx 
22:35:37 <rcyr> carter: Thank you :)
22:35:40 <ReinH> carter: You realize that my job was literally building haskell packages? I'm pretty good at it.
22:35:55 <carter> ReinH: a) i've not been reading anything youv'e said
22:36:00 <carter> b) and?
22:36:00 <ReinH> carter: :p
22:36:08 <ReinH> not sure why you're suggesting it to me :p
22:36:13 <carter> ReinH: no
22:36:15 <carter> to rcyr 
22:36:19 <carter> autocomplete
22:36:22 <ReinH> which is why you replied to me :p
22:36:25 <rcyr> Mistakes happen :)
22:36:26 <rcyr> <3
22:36:29 <ReinH> mistakes were made
22:36:31 <ReinH> carter: <3
22:36:35 <carter> cool
22:36:47 <ReinH> carter: how are things?
22:37:06 <ReinH> (btw homebrew has ghc 7.8.3, fwiw)
22:37:19 <ReinH> ghc for osx is good though
22:37:29 <carter> ReinH: ..... soooo brew is still roally fucked
22:37:33 <carter> is what you mean
22:37:36 <ReinH> there are also binaries somewhere on the halcyon site
22:37:41 <carter> ReinH: or my build
22:37:43 <ReinH> carter: why?
22:37:44 <carter> or the web ste
22:37:57 <carter> 7.8.4 is the bug fix one wthats been out fo rmonths
22:38:15 <ReinH> well, I put various versions of ghc in /opt/ghc and have a little function to switch my $PATH, but anyway
22:38:24 <carter> cool
22:38:31 <carter> ReinH: i need to crash
22:38:36 <ReinH> carter: ok <3
22:40:00 <dmj`> can I get another set of eyes on this aeson parser, can't figure out why it isn't working... think it has to do w/ the chapter part, http://lpaste.net/133239
22:40:03 <rcyr> carter: Wow, just wow. It has never been this easy to install ghc for me before :)
22:43:32 <dmj`> the json is valid
22:54:02 <m_ryan> ReinH: thank you :) it works
23:07:53 <newsham> ?check \xs -> let f = ord in fmap f (listToMaybe xs) == listToMaybe (fmap f xs)
23:07:55 <lambdabot>  +++ OK, passed 100 tests.
23:29:43 <unb3k44n7> I read something that in Haskell you don't need to use parenthesis because they are eliminated in Haskell compared to C++. But then I read another thing that says to use them. Thoughts?
23:31:22 <unb3k44n7> I don't personally like parentheses. Are they necessary?
23:31:30 <kadoban> unb3k44n7: That doesn't sound right. You don't need to use them for function application, otherwise they exist and have valid uses.
23:32:04 <kadoban> In C++, you call a function like    f(x, y)   in Haskell, function application is    f x y
23:32:15 <kadoban> I assume that's what you're reading is trying to tell you.
23:32:17 <haasn> unb3k44n7: Haskell uses parentheses more sparingly than some other languages, but they're still a part of the language
23:32:20 <unb3k44n7> Right. I got that much out of it.
23:32:37 <unb3k44n7> So, sometimes use them. OK.
23:32:38 <haasn> Basically what kadoban said; we use them only where they're necessary for deciding precedence
23:32:41 <kadoban> Trying to read more into than that is probably not correct.
23:32:51 <haasn> eg. in Haskell you could write x * (y + z)
23:33:06 <unb3k44n7> Do you have to though?
23:33:24 <kadoban> unb3k44n7: Well, it has a different meaning than x * y + z. So it depends which you want.
23:33:27 <haasn> unb3k44n7: Not technically. Also, Haskell has other tools for avoiding parentheses, for example we can f (g x) as f $ g x
23:33:42 <unb3k44n7> :)
23:34:02 <haasn> unb3k44n7: Personally, I am averse to nesting parentheses, but I am fine with one level in general
23:34:07 <f|`-`|f> (function application has the highest priority, and it's left associative)
23:34:09 <haasn> eg. I'll gladly use f (g x) but I'll avoid f (g (h x))
23:34:38 <unb3k44n7> I have an aversion to parentheses. *makes sick face
23:34:40 <haasn> The latter, you could write as f . g . h $ x
23:35:10 <kadoban> Well, you do sometimes need to use parens in haskell. But not as much as lisp or anything.
23:36:17 <haasn> unb3k44n7: Another thing Haskell tends to avoid is using braces (that is, { and }) for blocks
23:36:43 <haasn> While it's also possible to use { ; }-style blocks in Haskell, you can use newlines and indentation to signal blocks instead, which is the popular convention
23:36:52 <haasn> That's certainly related to parentheses
23:37:41 <unb3k44n7> What's newlines
23:39:04 <haasn> unb3k44n7: a “newline” is what you insert when you press the Enter key to go to the next line
23:39:47 <unb3k44n7> Oh. Like literally a new line. Hah. Sorry.....
23:40:05 <unb3k44n7> I thought it was another term I didn't know yet. 
23:42:19 <kadoban> It can be hard to tell sometimes :)
23:42:33 <ReinH> @google haskell indentation
23:42:34 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Indentation
23:42:34 <lambdabot> Title: Haskell/Indentation - Wikibooks, open books for an open world
23:42:39 <ReinH> A handy guide
23:42:52 <haasn> Especially when a single space is all it takes to make the different between a “new type” and a “newtype”, it might be easy to think “newline” and “new line” are different things ;)
23:44:04 <unb3k44n7> Lol. Yes. :)
23:44:35 <unb3k44n7> Indentation is self explanatory though.
23:45:01 <unb3k44n7> If one has ever written anything in any form one should know what that is. ;)
23:45:23 <jbarrow> So, I've got a quick question about an error that pops up using GHC 7.10.
23:45:28 <ReinH> Haskell's layout rules trip people up sometimes
23:45:37 <ReinH> especially if they try to mix tabs and spaces
23:45:53 <unb3k44n7> Who would do that? ^
23:45:56 <ReinH> jbarrow: the suspense is killing me
23:45:57 <unb3k44n7> *grins
23:45:58 <jbarrow> Github issue is here: https://github.com/jbarrow/LambdaNet/issues/3
23:46:19 <jbarrow> The second part of the issue. I've been searching online and haven't been able to find much.
23:46:43 <ReinH> unb3k44n7: it's not completely unreasonable if you use tabs for indentation and spaces for layout, but generally it's best to stick to spaces for haskell
23:47:07 <jbarrow> Also haven't had much success getting all the dependencies working with GHC 7.10, so I haven't been able to reproduce it on my own machine and play around with it.
23:52:57 <johnw> tabs are really something that should have died in the 20th century
23:53:02 <johnw> any new language should make them a syntax error
23:53:26 <johnw> it's about as reasonable as letting unicode spaces have syntactic meaning, it's just easier to type
23:53:56 <newsham> like tab cola
23:54:16 <ReinH> johnw: you'll enjoy go then
23:55:09 <ReinH> at least go has a completely totalitarian approach to formatting: there is a program you run that formats your source in the canonical way (which uses tabs).
23:55:25 <ReinH> it saves a lot of effort deciding on a style guide, at least
23:55:27 <johnw> isn't that just what reddit is?
23:55:32 <ReinH> johnw: heh
23:55:47 <johnw> mandated style, interesting
23:55:51 <ReinH> johnw: and anyway I use hindent so I have one of those too
23:56:09 <ReinH> johnw: https://golang.org/cmd/gofmt/
23:56:16 <ReinH> "It uses tabs (width = 8) for indentation and blanks for alignment."
23:56:44 <ReinH> go-mode by default will run go fmt on your file on save :D
23:57:13 <ReinH> that said, of all the reasons to dislike go, this would be the most trivial
23:57:57 <ReinH> johnw: btw this is cool https://personal.cis.strath.ac.uk/conor.mcbride/TotallyFree.pdf
23:58:02 <johnw> haha
23:58:08 <johnw> i'm quite eager to retire for the evening so I can read that
23:58:12 <ReinH> :D
23:58:15 <johnw> it directly relates to a problem I'm trying to solve
23:58:17 <ReinH> That is what i'm doing.
23:58:20 <ReinH> nice
23:58:52 <ReinH> I love his writing so much
23:59:12 <ReinH> In the first paragraph, he refers to total functions as "functions which provably function"
23:59:19 <johnw> haha
23:59:25 <ReinH> The first sentence even
