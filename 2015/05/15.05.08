00:00:21 <georgyy> Moggle: ah.. but does it matter when elements are equal?
00:00:22 <jle`> deezn: what is headV supposed to do?
00:00:26 <deezn> So.. Write a function —called headV— that extracts the first element of a Vec and that is total (i.e., defined for all possible argument values). Think about it as a suitable pre condition for headV.
00:00:42 <Moggle> georgyy: I don't know. That's up to nak. I was just commenting that min does not exactly match his specifications, but flip min would.
00:00:52 <georgyy> okay
00:00:54 <Moggle> I imagine the behavior is fine with him.
00:01:06 <deezn> I am not sure how to handle the empty list.. 
00:01:26 <jle`> deezn: you don't want the head of the list, you want the head of the vector
00:01:31 <georgyy> there are probably some odd types where it would matter
00:01:33 <Moggle> some data types might have eq
00:01:33 <deezn> ops.. 
00:01:34 <Moggle> yeah.
00:01:34 <jle`> so headV of (VCons 1 VNil) is 1
00:01:43 <deezn> ok brb
00:01:50 <Moggle> i mean it's not a very common case (and would be kind of an abuse of eq) but the possibility exists.
00:02:24 <joneshf-laptop> maybe i'm having a brain fart, but why does it matter?
00:02:30 <deezn> thx jle` I thought I was confused.
00:02:33 <joneshf-laptop> `Ord` is a total ordering
00:02:38 <nak> Moggle thank u
00:02:43 <nak> jle` thank u
00:03:36 <jle`> np
00:04:27 <joneshf-laptop> so in the case of `min` how can i make a difference?
00:05:04 <jle`> maybe things with non-structural equality
00:05:05 <nak> @src zip
00:05:05 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
00:05:05 <lambdabot> zip _      _      = []
00:05:06 <Moggle> joneshf-laptop: In the extremely weird case where two data types can be equal but not actually equal bit-wise
00:05:30 <Moggle> as in maybe Ord only compares one part of the data structure
00:05:36 <Moggle> basically listen to jle`.
00:07:10 <Moggle> oh i think i see
00:07:11 <nak> that is a *very* nice definition of zip
00:07:16 <nak> very succinct
00:07:19 <Moggle> when doing operators over multiple lines
00:07:26 <Moggle> the operator should be at the start of the next?
00:07:30 <Moggle> maybe that's why ghc is complaining at me.
00:07:39 <deezn> jle` what does ‘Vec’ of kind ‘Nat -> * -> *’ is not promotable mean?
00:08:03 <deezn> Shouldnt the funct def just be: headV :: (v :: Vec) -> Nat
00:08:29 <jle`> Vec is not a Kind
00:08:48 <joneshf-laptop> jle`, Moggle ah, that makes sense
00:08:52 <jle`> you can't do things like plus :: (a :: Int) -> (a :: Int) -> (a :: Int)
00:08:53 <deezn> What i am lost?
00:08:59 <georgyy> haskell is the only language i used where equality makes total sense. no "guess if we are comparing references or values" nonsense
00:09:00 <jle`> you would do plus :: Int -> Int -> Int
00:09:08 <deezn> ok.. 
00:09:26 <jle`> so remember, functions take values to values
00:09:34 <Moggle> haskell is the only language i've used where lots of things are easy and make sense
00:09:35 <deezn> headV :: Vec -> Nat didnt work either?
00:09:36 <jle`> so you need (something that can have values) -> (somethign that can have values)
00:09:45 <jle`> deezn: it doesn't work because you can't have values of type Vec
00:09:55 <deezn> haskell nothing makes too much sense to me.
00:09:58 <Moggle> i remain in awe of monadic parsing and software transactional memory and how pleasant they are.
00:09:59 <nak> :t (+)
00:10:00 <lambdabot> Num a => a -> a -> a
00:10:02 <jle`> you can have values of type Vec (S n) Int
00:10:09 <jle`> ^ that's a one-lement vector
00:10:11 <erisco> wellll
00:10:34 <deezn> but what if I get a VNil?
00:10:37 <jle`> deezn: do you see why something like foo :: (->) doesn't work?
00:10:38 <joneshf-laptop> assuming `n == Z`
00:10:48 <jle`> you can't hae values of type (->)
00:10:57 <jle`> deezn: what is the type of VNil?
00:11:08 <deezn>  VNil  :: Vec Z a
00:11:11 <jle`> headV :: Vec (S n) a -> a
00:11:29 <jle`> "given a Vec (S n) a of things of type a, i'll give you an a"
00:11:39 <jle`> can you pass headV "VNil" ?
00:11:43 <deezn> ok.. 
00:11:45 <jle`> VNil :: Vec Z a
00:11:51 <jle`> headV doesn't take Vec Z a
00:11:54 <jle`> it only takes Vec (S n) a
00:12:08 <deezn> well it is a vec.. and head need to be total in handling all vecs?
00:12:20 <jle`> it only needs to be total in handling all possible inputs
00:12:25 <jle`> that's what total means
00:12:36 <kidto> Why doesn't Haskell enforce Functor / AFunctor / Monad laws?
00:12:41 <kidto> Is it too complicated?
00:12:52 <jle`> saying "(+) isn't total because it can't handle 'True'"
00:12:58 <jle`> that's not what we mean by total
00:13:10 <deezn> But isnt a VNil of type Vec?
00:13:11 <jle`> we mean it's total when it can return something for all inputs of its input type
00:13:24 <jle`> headV takes things of type Vec (S n) a
00:13:28 <jle`> but VNil is of type Vec Z a
00:13:33 <jle`> you can't pass VNil into headV
00:13:38 <jle`> it's a type error
00:13:45 <deezn> ok.. hence why i couldnt do it. 
00:13:46 <jle`> just like you can't pass True into (+) :: Int -> Int -> Int
00:13:54 <johnw> kidto: doing so cannot be easily automated
00:13:57 <jle`> if a function only takes Int's, you can't pass in a Bool
00:14:03 <jle`> if a function only takes Strings, you can't pass in a Double
00:14:12 <jle`> if a function only takes Vec (S n) a, you can't pass in a Vec Z a
00:14:26 <kidto> johnw: That's the feeling I get, but it's hard for me to formalize why
00:14:36 <johnw> interesting you should use the word formalize :)
00:14:48 <deezn> this whole GADT business is very abstract and confusing.. anf nothing like any other programmign i have done befor.e
00:14:56 <jle`> you get used to it :)
00:15:01 <johnw> it can be proven, and even automated, just not in Haskell, and not automatically
00:15:14 <johnw> proof search is NP-hard
00:15:20 <deezn> I can see the benefit but if I can just get around to figuring out wtf is going on.
00:15:33 <kidto> automated in something like Prolog?
00:15:43 <johnw> ACL2 could automate it
00:15:59 <johnw> but you'd have to define the theorem that describe your particular Monad sufficiently well
00:16:04 <Haskellfant> jle`: btw have you managed to get my Fin stuff working with typelits? I'd be interested in knowing what problems you ran into. I hadn't played with typelits before reading your blog post :)
00:16:10 <johnw> actually, ACL2 might lack the ability to abstract such proofs to "monads in general"
00:16:18 <johnw> Coq could do it too
00:16:37 <jle`> Haskellfant: oh i have been meaning to get to it, i just haven't had the time in the past couple of days
00:16:41 <nak> @src init
00:16:41 <lambdabot> init [x]    = []
00:16:41 <lambdabot> init (x:xs) = x : init xs
00:16:41 <lambdabot> init []     = undefined
00:16:44 <joneshf-laptop> Haskellfant, `Fin` like finite sets?
00:16:48 <johnw> for all the simple monads, you can easily automate the proofs
00:16:51 <jle`> but i do appreciate it
00:16:59 <jle`> it turns out there's a lot i still need to add to the article, heh
00:16:59 <Haskellfant> jle`: ah no worries, take your time.
00:17:15 <joneshf-laptop> Haskellfant, jle` also what's this article?
00:17:27 <Haskellfant> this article http://blog.jle.im/entry/fixed-length-vector-types-in-haskell-2015
00:17:30 <nak> haskell pattern matching is fricken sick
00:17:36 <Haskellfant> that was my fin stuff https://gist.github.com/cocreature/505f978c5ebca9d70db0
00:17:43 <jle`> it's woefully incomplete, as i've found out
00:17:46 <jle`> ;_;
00:17:57 <jle`> but it's good that there's a lot of ways to approach this problem
00:18:08 <jle`> maybe i should refocus my scope to "one way to do it" instead of "a reference of ways people have found to do it"
00:18:14 <kidto> johnw: So we just TRUST that developers have proven their monads to be monads? Is there a place in the documentation for these proofs?
00:18:16 <Haskellfant> jle`: writing blogposts so that people tell you how you could have done it better is probably a good way to learn new stuff :)
00:18:18 <jle`> people have become pretty creativity
00:18:19 <johnw> kidto: in fact, I just proved that StateT s m is a Monad last night, but it took more than 15 minutes
00:18:33 <jle`> it's nice but i should be honest with how i'm presenting myself, heh
00:18:36 <johnw> kidto: some people are good and document them using equational reasoning in a comment
00:18:41 <johnw> kidto: some don't, but they're right anyway
00:18:52 <kidto> Mine won't be
00:18:53 <johnw> some publish code that is an instance of Monad, but isn't a monad
00:18:55 <kidto> that's a guarantee
00:19:06 <jle`> some do it intentionally too
00:19:11 <jle`> D:<
00:19:30 <johnw> I always find the applicative composition law the most onerous to prove
00:19:45 <kidto> It sounds like it's not the end of the world if you pretend to be a monad sufficiently well?
00:19:53 <johnw> it's the end of several worlds
00:19:57 <kidto> haha
00:20:01 <jle`> proving applicative through the liftA2 (,)/pure formulation is a bit easier
00:20:03 <georgyy> jle`: why? so you have examples?
00:20:05 <jle`> it can also be quickchecked
00:20:06 <georgyy> do
00:20:07 <johnw> somewhere, a planet of just kittens is destroyed each time
00:20:17 <jle`> there's a formulation of the monad laws that can be quickchecked too
00:20:29 <johnw> quickcheck is not proof
00:20:32 <jle`> so that's helpful
00:20:33 <kidto> what's quick checking?
00:20:36 <johnw> unless it's a proof that's a NOT a monad :)
00:20:43 <jle`> "quickcheck is a proof"  - a wise person
00:21:11 <jle`> kidto: the problem is that your users might end up with bugs that they don't expect
00:21:15 <johnw> saying quickcheck is a proof is like saying that any finite number is a suitable approximation of infinity
00:21:29 <jle`> if they trust your type to be a monad then they wouldn't ever think to see if your type isn't a monad
00:21:34 <jle`> they'd look at their own code
00:21:37 <jle`> search their own codebases
00:21:41 <jle`> tear out their hair
00:21:42 <kidto> oh misery
00:22:20 <kidto> So basically you would if you could but it's np hard so we just have faith
00:22:36 <joneshf-laptop> jle`, s/trio/duo/ at the start of this: http://blog.jle.im/entry/fixed-length-vector-types-in-haskell-2015#fnref1
00:22:38 <kidto> in the power of love
00:22:39 <jle`> "any finite number is a suitable approximation of infinity" - a wise person
00:22:49 <joneshf-laptop> jle`, also holy smokes
00:22:54 <ronh-> @check (\x -> (reverse (reverse x)) == (x :: [Int]))
00:22:55 <lambdabot>  +++ OK, passed 100 tests.
00:23:04 <jle`> joneshf-laptop: thanks :)
00:23:21 <jle`> kidto: yes, sometimes we all need a little faith in our lives
00:23:43 <jle`> you can represent infinity arbitrarily well with an arbitrarily large number anyways
00:23:48 <jle`> so i'm okay with this
00:24:06 <peddie> "any finite number is a suitable approximation of infinity" -- anyone whose program ran without getting OOM-killed
00:24:50 <jle`> quickcheck just means that you can get arbitrarily close to a complete proof by running an arbitrarily large amount of trials
00:25:52 <kidto> oh.
00:25:53 <frerich> I'm still quite stunned about how clever QuickCheck is at looking for (and minimizing) faulty input.
00:26:03 <jle`> don't listen to me kidto 
00:26:05 <jle`> :)
00:26:11 <kidto> so 'quickcheck' is the joke? D:
00:26:25 <kidto> I'm in sponge mode
00:26:26 <joneshf-laptop> well, smallcheck could be a proof in some circumstances yes?
00:26:28 <kidto> you're corrupting my brain
00:26:28 <jle`> quickcheck generates random input data and tests that they satisfy certain properties
00:26:31 <Axman6> no, it's an excellent tool for eventually finding out if your assumptions are wrong
00:26:42 <joneshf-laptop> not `Functor` hierarchy stuff
00:26:45 <jle`> in ronh-'s example, for instance, it is checking that all lists x are equivalent to reverse (reverse x)
00:26:58 <jle`> @check (\x y -> x * y == y * x)
00:27:00 <lambdabot>  +++ OK, passed 100 tests.
00:27:11 <jle`> in the list example it generated 100 random lists, and verified that property for all of them
00:27:23 <jle`> in this last example it generatd 100 pairs of numbers and verified this commutativity property on all of them
00:27:37 <frerich> kidto: It's not a joke at all. QuickCheck is quite clever at deciding on what 'random data' to use. Consider e.g.:
00:27:40 <frerich> @check \x -> x + 1 > 0
00:27:42 <lambdabot>  *** Failed! Falsifiable (after 4 tests):
00:27:42 <lambdabot>  -1
00:27:52 <frerich> kidto: It doesn't always pass ;-)
00:27:55 <kidto> oh smooth
00:28:03 <jle`> yeah, quickcheck is pretty smart and works unreasonably well
00:28:03 <Axman6> @check (\x y z -> (x * y) * z == x * (y * z))
00:28:05 <lambdabot>  +++ OK, passed 100 tests.
00:28:21 <jle`> which is why it's a common joke to say that mathematical proofs can be verified using quickcheck
00:28:24 <Axman6> @check (\x y z -> (x + y) + z == x + (y + z)) -- this should fail sometimes
00:28:25 <lambdabot>  <hint>:1:91:
00:28:25 <lambdabot>  parse error (possibly incorrect indentation or mismatched brackets)
00:28:27 <kidto> :3
00:28:33 <Axman6> @check (\x y z -> (x + y) + z == x + (y + z))
00:28:34 <lambdabot>  +++ OK, passed 100 tests.
00:28:45 <jle`> Axman6: it depends on your Num instance, too
00:28:55 <Axman6> @check (\x y z -> (x + y) + z == x + (y + z :: Double))
00:28:57 <lambdabot>  *** Failed! Falsifiable (after 6 tests and 141 shrinks):
00:28:57 <lambdabot>  -0.944101346815977 0.49290495938928436 -2.9084690517406293
00:29:12 <kidto> woah why should that fail sometimes Axman6?
00:29:16 <johnw> @check (\x y z -> n > 2 && x^n == y^n + z^n)
00:29:19 <kidto> oh because of floating points?
00:29:20 <lambdabot>  mueval-core: Time limit exceeded
00:29:26 <Axman6> yeah
00:29:29 <jle`> Double uses machine implementation of floating points and floating point operations
00:29:55 <Axman6> (x + epsilon) - epsilon is not quaranteed to equal x basically
00:30:03 <joneshf-laptop> Haskellfant, very nice
00:30:23 <jle`> joneshf-laptop: what is 'holy smokes' in reference to?
00:30:34 <joneshf-laptop> jle`, i like
00:30:42 <jle`> oh, thanks :)
00:31:17 <phaazon> @tell kuribas yeah, I thought of the sort while taking a shower to improve from quadratic to linear logarithmic complexity :)
00:31:17 <lambdabot> Consider it noted.
00:36:07 <Axman6> @check (\x y z n -> n >2 ==> let [a,b,c] = sort [x,y,z] in a^n + b^n /= c^n)
00:36:09 <lambdabot>  No instance for (Show Test.QuickCheck.Safe.SProperty)
00:36:09 <lambdabot>  arising from a use of ‘myquickcheck’ In the first argument of ‘text’, namely...
00:36:48 <Axman6> @check (\x y z n -> n >2 ==> let [a,b,c] = sort [x,y,z :: Integer] in a^n + b^n /= c^n)
00:36:50 <lambdabot>  No instance for (Show Test.QuickCheck.Safe.SProperty)
00:36:50 <lambdabot>  arising from a use of ‘myquickcheck’ In the first argument of ‘text’, namely...
00:37:01 <phaazon> @tell kuribas my solution is basically: let d = minimum . (tail >>= zipWith (\a b -> abs $ a - b)) $ sort strengths -- :)
00:37:01 <lambdabot> Consider it noted.
00:37:07 <Axman6> @check (\x y z n -> n > 2 &&  let [a,b,c] = sort [x,y,z :: Integer] in a^n + b^n /= c^n)
00:37:09 <lambdabot>  *** Failed! Falsifiable (after 1 test):
00:37:10 <lambdabot>  0 0 0 0
00:37:20 <jle`> maybe (n > 2) ==> ...
00:37:36 <Axman6> @check (\x y z n -> (n > 2) ==> let [a,b,c] = sort [x,y,z :: Integer] in a^n + b^n /= c^n)
00:37:38 <lambdabot>  *** Failed! Falsifiable (after 94 tests and 2 shrinks):
00:37:38 <lambdabot>  0 -5 5 6
00:38:11 <frerich> kidto: https://wiki.haskell.org/Introduction_to_QuickCheck1 has a few (IMHO fairly compelling) examples of how QuickCheck helps (other than the usual 'It can find floating point inaccuracies' examples ;-)).
00:38:21 <Axman6> @check (\x y z n -> (n > 2) ==> let [a,b,c] = sort [abs x, abs y, abs z :: Integer] in a^n + b^n /= c^n) -- too lazy for map
00:38:22 <lambdabot>  <hint>:1:140:
00:38:22 <lambdabot>  parse error (possibly incorrect indentation or mismatched brackets)
00:38:37 <Axman6> ok, I'm done now
00:39:51 <kidto> thanks, frerich
00:39:55 <kidto> nn all
00:44:22 <merijn> edwardk: Sorry, I think I asked before, but what was the state of indentation-based parsing with parsers/trifecta?
00:54:28 <nak> @src (==)
00:54:28 <lambdabot> x == y = not (x /= y)
00:54:46 <nak> @src (==) :: [a] -> [a] -> Bool
00:54:46 <lambdabot> Source not found. Are you on drugs?
00:54:49 <ski> that's the default definition
00:55:25 <ski> @src [] (==)
00:55:25 <lambdabot> []     == []     = True
00:55:25 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
00:55:25 <lambdabot> _      == _      = False
00:56:20 <nak> the structure of these algorithms are so fricken nice
00:56:22 <nak> they're so nice to read
00:56:44 <nak> i'm referencing them because i'm trying to see idiomatic examples of haskell (and good FP in general)
00:58:00 <ski> which algorithms ?
00:58:28 <nak> ski (==), min, zip
00:58:29 <nak> etc
00:58:41 <nak> the pattern matching allows for some extremely brief programs
00:58:54 <ski> yes, pattern-matching is great :)
00:59:04 <nak> coming from imperative stuff and OOP, like...
00:59:06 <pavonia> nak: You could browse the sources of the base package on Hackage, especially the Data.* modules
00:59:06 <nak> it's just so different
00:59:50 <ski> a forest of `if's and `case's/`switch'es is usually easier to get lost in
00:59:52 <nak> ski, for example, when i think about implementing zip, i first think i have to compare (length xs) vs (length ys)
01:00:12 <nak> but the way zip is done is so much better than that
01:00:15 <nak> @src zip
01:00:15 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
01:00:15 <lambdabot> zip _      _      = []
01:00:22 <nak> elegant as f
01:00:31 <ski> it's often good to think about : what are the basic possible shapes of the inputs ?
01:00:37 <nak> pattern matching here actually reduces the need for logic
01:01:04 <Axman6> zip should really be defined as zipWith (,)
01:01:07 <ski> in this case, the possible cases would be `zip [] []', `zip (a:as) []', `zip [] (b:bs)' and `zip (a:as) (b:bs)'
01:01:09 <Axman6> for even more elegance
01:01:23 <merijn> nak: Pattern matching and ADTs are the best thing ever :)
01:01:51 <merijn> nak: Actually, I believe the real zip is implemented as "zipWith (,)" :p
01:01:58 <nak> ADT ?
01:02:12 <ski> Algebraic Data Type .. or Abstract Data Type
01:02:12 <merijn> Algebraic Data Type, i.e. the things we have in Haskell
01:02:17 <ski> (very different things)
01:02:55 <nak> can you tell me what an "Algebraic Data Type" is in totally lay terms ?
01:03:05 <ski> the `data' keyword in Haskell introduces a new algebraic data type
01:03:12 <ski> @src []
01:03:12 <lambdabot> data [] a = [] | a : [a]
01:03:28 <nak> what makes it "algebraic" ?
01:03:32 <nak> vs just a "data type" ?
01:03:40 <merijn> nak: It turns out you can map them to algebra of data types
01:03:55 <ski> nak : that's two different questions (what it means, vs. why is the word "algebraic" used)
01:04:00 <merijn> nak: Which is not very important for using them, but a neat detail where their name comes from
01:04:30 * hackagebot stackage-upload 0.1.0.4 - A more secure version of cabal upload which uses HTTPS  http://hackage.haskell.org/package/stackage-upload-0.1.0.4 (MichaelSnoyman)
01:04:41 <nak> :{
01:04:59 <merijn> nak: Lemme try a short intro to the idea
01:05:04 <kadoban> nak: If you think of types as sets, it makes more sense. Int is the set of values that are integer numbers between minBound and maxBound, Bool is {True, False}. data Blah = A Int | B Bool   in some sense is the union of those sets
01:05:21 <merijn> nak: If I have "data () = ()" how many possible values are there of type ()?
01:05:31 <merijn> kadoban: Woah there, slow down cowboy :p
01:05:34 <nak> lol
01:05:34 <ski> an algebraic data type is specified by specifying what possible "basic shapes" a value of that type can have. and for each such "basic shape", what the types of the parts/components of it (if any) are
01:05:40 <kadoban> Haha, sorry :)
01:05:42 <nak> i actually understand what kadoban  means there
01:05:43 <deezn_> jle` still around?
01:05:53 <jle`> yeah, sup?
01:05:57 <merijn> nak: Lemme speed up a little, then ;)
01:06:02 <nak> ok
01:06:10 <deezn_> can you have a look at: http://lpaste.net/989046713895354368 the vCheck function
01:06:24 <merijn> nak: So, () obviously has but one value and Int has 2^32 (or 2^64) possible values, right?
01:06:35 <nak> yeah
01:06:45 <merijn> nak: So, how many possible values does ((), Int) (or (Int, ())) have?
01:06:53 <Axman6> how many values does Maybe () have nak?
01:07:24 <ski> nak : perhaps consider `data IntTree = Leaf Int | Branch IntTree IntTree'. this says that values of type `IntTree' can take two possible shapes. one possible shape is `Leaf x', where `x' is an `Int'. the other possible shape is `Branch t0 t1' where `t0' and `t1' are `IntTree's
01:07:45 <merijn> Is it glorious quintuplet explanation time again?
01:07:54 <ski> nak : `Leaf' and `Branch' are called (data) constructors of the data type `IntTree'
01:08:15 <sopvop> Can anyone proficient with haskell-mode for emacs help me pls? Can I start another haskell-process for different target in cabal? Like tests
01:08:18 <nak> merijn i'm guessing ((), Int) can have 2^32 (or 2^64) values
01:08:24 <merijn> nak: Right
01:08:24 <nak> because () is always just an empty tuple
01:08:31 <deezn_> jle’ i dont get what is wrong with the last kine of the function
01:08:38 <Axman6> nak: how about (Int, Int)?
01:08:39 <merijn> () is actually not a tuple, but that's a minor detail
01:08:46 <nak> 2^64 * 2, Axman
01:08:52 <merijn> nak: Ah, no
01:09:03 <jle`> deezn_: why are you using headV?
01:09:04 <merijn> nak: That'd be 2^64 * 2^64 :)
01:09:08 <nak> oh duh
01:09:12 <nak> lol
01:09:27 <merijn> nak: Which is why (,) is what is called a "product type"
01:09:43 <Axman6> @src Either
01:09:43 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
01:09:45 <merijn> nak: Now, consider, how many values can "Either () Int" have?
01:09:47 <deezn_> I just need to check values are the same.. I had a == (vCheck xs)  but i cannot get it to work.. that was my last attempt
01:09:48 <Axman6> u wot m8
01:10:20 <nak> merijn let's talk about how Either works first
01:10:24 <ski>   data Either a b = Left a | Right b
01:10:30 <merijn> nak: "data Either a b = Left a | Right b"
01:10:34 <merijn> aww, too slow :)
01:10:37 <nak> > Either 1 2
01:10:38 <lambdabot>      Not in scope: data constructor ‘Either’
01:10:39 <lambdabot>      Perhaps you meant variable ‘either’ (imported from Data.Either)
01:10:41 <nak> :{
01:10:42 <merijn> > Left True
01:10:44 <lambdabot>  Left True
01:10:47 <Axman6> how many values of type Either () () are there nak?
01:10:47 <merijn> :t Left True
01:10:48 <lambdabot> Either Bool b
01:10:55 <merijn> :t Right 'c'
01:10:56 <lambdabot> Either a Char
01:11:01 <merijn> :t Right 'c' :: Either Bool Char
01:11:02 <lambdabot> Either Bool Char
01:11:03 <nak> > Left 1 | Right 2
01:11:05 <lambdabot>  <hint>:1:8: parse error on input ‘|’
01:11:13 <ski> nak : don't confuse type constructors and data constructors. `Either' lives in the "type world", not in the "value world"
01:11:15 <Axman6> :t [Left 'a', Right True]
01:11:16 <lambdabot> [Either Char Bool]
01:11:31 <lokathor> quick question, i read some stuff about mtl and transformers being different packages and slightly different implementations
01:11:43 <nak> ski ah ok, different namespaces eh ?
01:11:43 <lokathor> and they seemed down on mtl, but also that more people used mtl anyway, for some reason
01:11:46 <merijn> nak: Either is a datatype that has two type parameters (a and b) and two constructors, one that only has the first type and the other that only has the second
01:11:49 <deezn_> jle` vCheck (x@(VCons n a):xs) = n == (vCheck xs)
01:11:49 <ski> nak : yes
01:11:52 <Axman6> something of type Either a b is EITHER a Left constructor which contains an a, or a Right constructor which contains a b
01:11:54 <lokathor> so what's the deal with that?
01:11:55 <deezn_> doesnt work either
01:12:11 <jle`> why do you care that it's a vcons or a vnil?
01:12:16 <jle`> also, what does "doesn't work" mean?
01:12:24 <merijn> lokathor: transformers is the low level implementation of monad transformers, mtl is a library that wraps transformers with some typeclasses to make lifting/polymorphic monad stacks easier
01:12:30 <jle`> is your compiler self-destructinog? :)
01:12:32 <ski> nak : also, `|' is syntax that belongs to `data' declarations (and it is also used for different purposes in guard syntax, and in list comprehensions). trying to use it in an expression like `Left 1 | Right 2' doesn't work
01:12:35 <nak> merijn to answer your question (Either (), Int) has (1 * 2^64) possible values
01:12:38 <lokathor> so just use mtl?
01:12:46 <merijn> lokathor: It uses a bunch of extensions (i.e. functional dependencies that make it less portable)
01:12:47 <deezn_> jle` :  ‘a’ is a rigid type variable bound by
01:12:47 <nak> ski i noticed that ^.^
01:12:47 <deezn_>           the type signature for vCheck :: [Vec n a] -> Bool
01:12:58 <Axman6> nak: now quite
01:12:59 <lokathor> you mean portable to non-GHC compilers?
01:13:03 <merijn> lokathor: I prefer using the transformers directly with explicit stacks
01:13:06 <merijn> lokathor: Yeah
01:13:16 <jle`> deezn_: what is "vCheck xs"
01:13:18 <jle`> what type is it?
01:13:20 <Axman6> nak: if we have Either () (), then we only have two possible values: Left () or Right ()
01:13:21 <ski> nak : `(Either (), Int)' isn't a kind-correct type expression
01:13:23 <merijn> lokathor: But there's no real reason to avoid mtl if you only care about GHC
01:13:24 <lokathor> well i'm not worried about that part really
01:13:28 <lokathor> yeah
01:13:35 <jle`> deezn_: and what is the type of 'n' ?
01:13:36 <deezn_> vCheck :: [(Vec n a)] -> Bool
01:13:41 <jle`> no, "vCheck xs"
01:13:42 <Axman6> so the size of Either () () is 2
01:13:51 <jle`> vCheck xs is a Bool
01:13:52 <deezn_> vCheck (x@(VCons a v):xs) = a == (vCheck xs) 
01:13:54 <Axman6> how about Either () Int?
01:14:00 <merijn> lokathor: There were alternatives to mtl, but almost no one uses them, so it's save to say they "lost"
01:14:02 <nak> Axman6 are you sure it's not just a size of 1 ?
01:14:04 <jle`> n is an `a`
01:14:08 <jle`> so why are you comparing an `a` to a Bool?
01:14:15 <lokathor> I just need a State implementation
01:14:20 <Axman6> nak: absolutely =) there';s clearly two different values
01:14:22 <lokathor> i don't even care about all the other stuff really
01:14:30 <deezn_> jle`.. I am trying to recursively go through the list of vectors and check that all the num values are equal.. 
01:14:30 <jle`> lokathor: if all you need is State i'd recommend transformers
01:14:33 <merijn> lokathor: StateT from mtl is just StateT from transformers reexported ;)
01:14:37 <Axman6> Left () is distinct from Right () because they have different constructors
01:14:50 <ski> > Left () == Right ()
01:14:50 <nak> ok
01:14:51 <lambdabot>  False
01:14:52 <jle`> deezn_: but why are you comparing `a`, an item in a vector, to a Bool?
01:14:53 <lokathor> I don't think I need to combine State with other monads
01:14:58 <Axman6> nak: what other types do you know of which have a size of 2?
01:15:04 <deezn_> well all the a values are the same
01:15:05 <nak> Boolean ?
01:15:08 <jle`> deezn_: if your vector contains 1, 2, and 3, why do you care of 1 == True, or 2 == False /
01:15:10 <Axman6> yes!
01:15:19 <Axman6> Either () (0 is siomorphic to Bool
01:15:23 <lokathor> I just need to connect lots of RNG stuff outside of IO is all, very basic use
01:15:35 <deezn_> jle` : Take into account that in a vector of vectors, the inner vectors all need to be of the same size 
01:15:45 <Axman6> isomorphic
01:15:46 <jle`> lokathor: if you're just getting started with State, IO, transformers, i'd reocmmend transformers
01:15:53 <lokathor> okay
01:16:12 <jle`> deezn_: yyeah, they all need to be the same size.  but why are you comparing a value in the vector to a Bool?
01:16:22 <jle`> > "Hello" == True
01:16:24 <merijn> nak: So now we have some types where the number of possible values is the SUM of their component types and some types where they're the product. Called sum and product types respectively
01:16:24 <lambdabot>      Couldn't match expected type ‘[Char]’ with actual type ‘Bool’
01:16:24 <lambdabot>      In the second argument of ‘(==)’, namely ‘True’
01:16:24 <lambdabot>      In the expression: "Hello" == True
01:16:32 <lokathor> I just want to roll many iterations of dice rolls and collect the results, then run some checks and arrangements on said results is all
01:16:35 <jle`> it doesn't make sense to compare if a value is == to a Bool
01:16:43 <jle`> > 'a' == False
01:16:44 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘Bool’
01:16:44 <lambdabot>      In the second argument of ‘(==)’, namely ‘False’
01:16:44 <lambdabot>      In the expression: 'a' == False
01:16:47 <jle`> it's a type error
01:16:48 <merijn> nak: We also have a unit element for multiplication (since () has only one value!)
01:16:49 <deezn_> jle’ : I am trying to return a bool of if they are all the same. so i can use it is in a if statement
01:16:49 <Axman6> nak: ok, so how about this one, what is the size of Either Int ()?
01:16:51 * ski wonders whether nak would prefer moving to #haskell-overflow for this discussion
01:16:56 <jle`> you can only compare things to things of the same type
01:17:11 <Axman6> yeah #haskell-overflow might be better, lots of noise now
01:17:12 <nak> Axman6 2^64 + 1
01:17:23 <Axman6> nak: bingo =)
01:17:24 <merijn> nak: If we accept "data Void" (no possible constructors) as a type with 0 possible values (since it has no constructors) we also have a unit element for sums
01:17:26 <jle`> deezn_: okay, let's try starting over
01:17:31 <nak> i can go to haskell-overflow
01:17:33 <nak> joining now
01:17:33 <deezn_> jle.. agreed
01:17:36 <jle`> deezn_: let's say we have a [Vec Z a]
01:17:49 <merijn> nak: So it turns out we can expand this into an entire algebra of types, which is where they get the name "algebraic datatypes"
01:17:51 <jle`> what can you tell me about the size of all your vectors in that list?
01:17:56 <jle`> all the vectors are of size ... ?
01:18:07 <merijn> nak: (And then people start doing crazy things like defining "derivatives of types", etc.)
01:18:19 <merijn> nak: But none of that is very important to actually use them :)
01:18:29 <deezn_> jle` yes I need to go through recursively and check the truth of if a == a == a == a  for each value of a
01:18:39 <jle`> deezn_: no wait, first answer this question
01:18:50 <jle`> you just need to check if they're all the same size, right?
01:18:56 <deezn_> Yes
01:19:11 <jle`> so, if you have a [Vec Z a]
01:19:14 <ski> merijn : #haskell-overflow ?
01:19:15 <jle`> what are the lengths of all the vectors?
01:19:30 * hackagebot dataflow 0.6.1.0 - Generate Graphviz documents from a Haskell representation.  http://hackage.haskell.org/package/dataflow-0.6.1.0 (owickstrom)
01:19:33 <deezn_> jle` what ever the a value is?
01:19:41 <jle`> what is a Vec Z a?
01:19:53 <deezn_> data Vec (n :: Nat) a where  --- constructs different TYPES
01:19:54 <deezn_>   VNil  :: Vec Z a
01:19:54 <deezn_>   VCons :: a -> Vec n a -> Vec (S n) a
01:20:28 <jle`> yeah, but what *is) a Vec Z a?
01:20:39 <jle`> it's VNil, right?
01:20:41 <jle`> a vector with items
01:20:42 <deezn_> data Nat = Z | S Nat
01:20:45 <jle`> *no items
01:20:52 <deezn_> yeah. 
01:21:00 <jle`> a `Vec Z a` has only one value: VNil.  so it's a vector with no items
01:21:10 <jle`> so if i have a list of [Vec Z a]...wha are the length of all of the vectors in my list?
01:21:28 <deezn_> 0
01:21:30 <jle`> yes
01:21:44 <jle`> if i have a list of [Vec (S Z) a], what are the lengths of all of the vectors in my list?
01:21:57 <jle`> a Vec (S Z) a is a vector with one item, of lenght 1
01:22:00 <deezn_> a
01:22:09 <jle`> remember the length is the second parameter
01:22:18 <jle`> so a `Vec (S (S Z)) a` has two items
01:22:28 <jle`> a `Vec (S (S (S Z))) a` has three items, etc.
01:22:36 <deezn_> jle` ok..
01:22:46 <jle`> so, how many items does a `Vec n a` have?
01:23:05 <deezn_> a?
01:23:10 <jle`> the length is the second parameter
01:23:12 <jle`> so it has `n` items
01:23:39 <jle`> Vec Z a has Z (zero) items.  Vec (S Z) a has (S Z) (one) item.  Vec (S (S Z)) a has (S (S Z)) (two) items
01:23:47 <jle`> so a "Vec n a" has n items.
01:23:59 <jle`> so what can you tell me about the length of your vectors in a [Vec n a].  what are all of their lengths?
01:24:26 <deezn_> Totally confused. I am used to OO where an object is an object. 
01:24:47 <deezn_> ok. 
01:24:53 <deezn_> n
01:24:56 <jle`> so "Vec n a" is a type.  it's the type of a vector with length n, where the elements are of type `a`
01:25:19 <deezn_> I dont get the chaining.. 
01:25:21 <jle`> if you're used to Java, you can think of it as a VecN<a>.  so you might have a Vec0<a>, a Vec1<a>, a Vec3<a>, etc.
01:25:40 <deezn_> yes
01:25:56 <jle`> so a list of [Vec n a]...all of the vectors have n items
01:26:23 <jle`> so for any list of [Vec n a], all of the vectors have n items.  so all of them have the same amount of items.
01:27:16 <jle`> so hasAllSameAmount :: [Vec n a] -> Bool;     hasAllSameAmount _ = True
01:28:40 <deezn_> I dont even get what she wants.. ? vector of vectors? meaning an array of arrays? Are we talking lines that point to something with a szie and direction?
01:28:59 <deezn_> When I think vector I think ———>
01:29:01 <frerich> merijn: Is there a benefit to being aware of what's "algebraic" about ADTs in Haskell, other than being able that two types have the same (or less/more) number of inhabitants? For instance, can you maybe derive a more efficient representation or so?
01:29:11 <jle`> deezn_: a vector here is what you'd call an Array in Java or C
01:29:14 <thuletheking> Hi guys, I am hoping someone can point me in the right direction. I have 1000+ C dll's that all abide to the same interface. It seems like I have to pass these to ghc --make, e.g. ghc --make cTest.hs -L. -lTestInt -- but obviously this is not very convenient with 1000+ dlls. I need some way of keeping track of these dll's inside my haskell source c
01:29:14 <thuletheking> ode, any ideas?
01:29:23 <deezn_> jle`.. ok
01:29:28 <jle`> deezn_: she just wants a function that takes a list of arrays and returns whether or not they all have the same length
01:29:31 * hackagebot stackage-update 0.1.1.0 - Update your package index incrementally (requires git)  http://hackage.haskell.org/package/stackage-update-0.1.1.0 (MichaelSnoyman)
01:29:43 <jle`> but we know that if we have a [Vec n a], every vector/array has the same length --- they all have length `n`
01:29:50 <jle`> so the implementation is:
01:29:56 <jle`> hasAllSameLength _ = True
01:29:56 <deezn_> Wish that was clarified earlier as a couple of pracs ago we were taalking vectors for graphics.. in the same subject. 
01:30:23 <jle`> oh, heh.  yeah that might have been nice to know from the start :)
01:30:31 <Cale> Whose course is this?
01:30:44 <jle`> well, the vector here is sort of the same thing as vectors for graphics.  a Vec 3 a is like a <a,a,a.
01:30:48 <jle`> <a,a,a>
01:30:49 <merijn> frerich: I don't think so
01:30:49 <deezn_> jle` ok. 
01:31:00 <jle`> a Vec n a is a <a,a,a ... n times ...>
01:31:18 <merijn> frerich: I mean, there's some benefit if you wanna do cool things like "invent generalised zippers", which is something it has been used for, but for practical haskell programming, not so much
01:31:23 <merijn> frerich: You can check https://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/
01:31:40 <deezn_> ok let me ponder that.. and look at the code
01:32:06 <jle`> do you understand the implementation?  what the _ means?
01:32:09 <jle`> checkV _ = True
01:32:23 <deezn_> yeah it just dioscards it
01:32:26 <deezn_> the _
01:32:40 <jle`> yes.
01:32:49 <jle`> it's a wildcard, it matches anything
01:33:07 <Cale> This conversation seems mysterious
01:33:17 <jle`> this whole course is pretty mysterious
01:33:30 <jle`> it's a haskell course and on the sixth lession they're using GADT's and type nats to verify C programs
01:33:39 <deezn_> yeah because it is based in haskell which is mysterios as ****
01:33:44 <Cale> That sounds a bit questionable
01:34:03 <deezn_> Noooo we arent doign the C program.. stuff that was an example of why to use GADTs
01:34:09 <jle`> ah i see
01:34:10 <Cale> deezn_: Really, it's not, it's just you're diving right in to stuff which is pretty new.
01:34:31 * hackagebot stackage-update 0.1.1.1 - Update your package index incrementally (requires git)  http://hackage.haskell.org/package/stackage-update-0.1.1.1 (MichaelSnoyman)
01:34:44 <jle`> yeah, it's not surprising if 90% of people who use haskell professionally never even touch this stuff
01:34:56 <Cale> It seems a bit crazy to me that someone who is just starting out with Haskell would be messing around with attempting to simulate dependently typed programming in it.
01:35:02 <deezn_> currying etc.. cool.  but when we hit the GADTs.. i got lost BIG TIME
01:35:15 <frerich> merijn: That's a nice link, thanks!
01:35:25 <merijn> Cale: I concur
01:35:52 <jle`> it seems crazier that a professor would have the course jump right into it
01:36:07 <jle`> "here's haskell.  here's how to define a function.  now here's how to simulate dependent types using datakinds and gadt's"
01:36:26 <deezn_> it was week 8? 
01:36:29 <Cale> Is this Stephanie Weirich's course by any chance? :)
01:36:44 <deezn_> Nope.
01:37:16 <frerich> merijn: I only wish that math notation (is that TeX?) like '$$ T(a) = 1 + a\cdot T(a)^2 $$' would render correctly.
01:37:23 <deezn_> ok got to go to work.. this student need to pay the bills. Thanks jle~ for your patience.
01:37:56 <Cale> Okay, I ask because she's pretty big on dependently typed programming, and is responsible for many of these features you're using, but I wouldn't really have expected her to take this approach anyway.
01:37:58 <deezn_> jle` <—— Thanks! Just incase you missed above.
01:38:00 <jle`> np. hopefully things become more clear as you work through this more.  don't be discouraged.  this stuff is understandable eventually, but it takes time for everyone
01:38:07 <merijn> frerich: There's a HTTPS problem with the the mathjax script
01:38:13 <jle`> like i said the vast majority of professional haskellers would have toruble with this
01:38:26 <merijn> frerich: In chrome you get a "load unsafe JS" button in the URL bar, click that and it renders
01:38:44 <jle`> partially because all of this is pretty newly invented, too
01:38:49 <deezn_> I am pretty stressed.. I spend ages trying to figure it out and go no where. It is a time monster.. But thanks again guys.. I will be back.. that is for sure. 
01:38:56 <deezn_> ;(
01:39:10 <jle`> but. it's definitely doable :)
01:39:15 <frerich> merijn: Indeed, nice! I'm surprised that this is done client-side - never noticed that Chrome button before...
01:39:38 <merijn> frerich: Most browsers block http JS includes on https domains (for obvious reasons)
01:39:52 <merijn> frerich: But since you likely weren't gonna enter sensitive info on a blog it doesn't matter
01:40:27 <safinaskar> hi. i want to make my program collection of parts. and i want to export between this part a limited amount of symbols only. but i don't want to put every part in its own file, is this possible? i. e. is there any way to put many modules to one file?
01:42:14 <kadoban> safinaskar: Not really. Unless you want to do some gross pre-compilation phase that splits the file into its component modules and names them correctly I guess.
01:42:15 <Cale> safinaskar: Nope, you have to put modules in separate files, at least using GHC>
01:42:32 <safinaskar> for example, i have datatype and function. i want to disallow function to call constructors of the first datatype directly. but i don't want to place this type and function to different files. is this possible?
01:43:22 <frerich> merijn: I only now realize you could have tlked me into loading evil code which you serve yourself.
01:43:34 <merijn> frerich: mwahahaha
01:43:46 <Cale> safinaskar: They have to be in separate files if you want them to be in separate modules, and they have to be in separate modules if you want to control access to the data constructors.
01:44:23 <thuletheking> Hi guys, I am hoping someone can point me in the right direction with FFI. I have 1000+ C dll's that all implement to the same interface. I need some way of dynamically loading the C dll's in Haskell and then invoke the same methods on different dll's. Any ideas?
01:45:12 <Cale> thuletheking: I guess I can try to help, but I don't know much about the Windows API.
01:45:58 <merijn> thuletheking: I know there's a dlopen/dynamic loading API in GHC (since I remember reading a GHC release note about now being able to *unload* them too), but I wouldn't know how to use it besides dlopen, which I don't think exists on windows
01:46:20 <thuletheking> hmm
01:46:26 <thuletheking> i'll try and look it up
01:46:59 <thuletheking> right now I am doing ghc --make cTest.hs -L. -lTestInt which obviously does not help me when I need many dlls
01:47:01 <merijn> thuletheking: FYI, obscure knowledge like this is usually easier to obtain answers for on mailing lists
01:47:11 <thuletheking> ah okay. Thank you
01:47:19 <merijn> thuletheking: Because they reach a bigger audience and don't depend on the right person being awake right now
01:47:32 <thuletheking> any particular good mailinglist?
01:47:45 <merijn> haskell-cafe and/or haskell-beginners ?
01:47:53 <thuletheking> thanks
01:47:57 <merijn> (@haskell.org, obviously)
01:54:18 <Cale> thuletheking: I assume you'd be using this stuff: https://github.com/haskell/win32/blob/master/System/Win32/DLL.hsc (I'd have linked the documentation, but it obviously won't build on the Hackage server that runs Linux, and nobody uploaded a correctly built copy.)
01:55:07 <thuletheking> sweet, thank you! I will take a look at it
01:56:05 <Cale> Addr is a type synonym for Ptr ()
01:56:09 <thuletheking> but I take it, that it is close to impossible getting the same code to work on both unix systems and windows?
01:56:24 <Cale> Well, yeah, this stuff is all entirely different on unix
01:56:40 <thuletheking> hmm damn... Scala might be a better choice for me
01:56:58 <Cale> Well, you did say you wanted to load DLLs
01:57:11 <thuletheking> ye, I gave too little information. Sorry about that
01:57:35 <Cale> You're not going to be able to load Windows DLLs on unix regardless.
01:58:19 <Cale> (Well, maybe there's some crazy way to use wine to do it...)
01:58:43 <Cale> thuletheking: What *are* the 1000s of dlls?
01:59:31 * hackagebot bitcoin-api 0.11.0 - Provides access to the RPC API of Bitcoin Core  http://hackage.haskell.org/package/bitcoin-api-0.11.0 (solatis)
01:59:33 * hackagebot bitcoin-api-extra 0.9.0 - Higher level constructs on top of the bitcoin-api package  http://hackage.haskell.org/package/bitcoin-api-extra-0.9.0 (solatis)
01:59:38 <thuletheking> It is for cyberphysical systems, where each DLL represents a component in e.g. a car. I need to create and orchestration engine that can handle at least 1000 components.
01:59:45 <thuletheking> an*
02:00:05 <Cale> And they have to be Win32 DLLs?
02:00:14 <thuletheking> I am trying to figure that out more closely now
02:01:07 <thuletheking> If they are UNIX it seems like the support is much better in Haskell, so I am crossing my fingers
02:01:29 <Cale> If the components are also going to be written in Haskell, then making them DLLs might induce even more pain (though it is possible to make Win32 DLLs with GHC)
02:01:59 <Cale> It would be easier to use the GHC API or some nice wrapper around it such as hint to just load .o files.
02:02:10 <thuletheking> they are not. They are entirely C components.
02:02:12 <ronh-> '''''''
02:02:31 <thuletheking> standardized
02:05:25 <Cale> thuletheking: If there are both Windows and Linux versions of the same libraries, and the C side of the interface is sufficiently similar, then it shouldn't be too hard to abstract around the different details required on Windows and Linux.
02:07:13 <thuletheking> Ok. I will try and get the win32 you pointed me to to work and then i'll take it from there :) Thank you very much
02:12:54 <Cale> thuletheking: By the way, it may help to know that HINSTANCE and HMODULE are secretly the same type. I believe the idea is you pass the HINSTANCE you get from loadLibrary to getProcAddress
02:13:27 <pharaun> hello, i am completely bloody lost with lens, I'm trying to do an "lookup" into a html doc using lens
02:13:53 <Cale> pharaun: What kind of HTML?
02:14:09 <pharaun> i'm using - https://hackage.haskell.org/package/hexpat-lens-0.1.3/docs/Text-XML-Expat-Lens-Unqualified.html - and i'm trying to do "div.menu_sidebar:nth-child(2) > div:nth-child(2) > ul:nth-child(2)" which would roughly translate to (my attempt so far) - let ul = page ^.. typedHTML . to allNodes . traverse . named "div" . traverse ^. at "id"
02:14:14 <pharaun> but i can't make any of the types line up at all
02:14:23 <pharaun> Cale: scrapping, so... crappy html :D
02:14:34 <Cale> I meant which actual type
02:14:46 <pharaun> ?
02:14:47 <Cale> but I guess that answers my question
02:15:03 <Cale> (It's hexpat's UNode)
02:15:31 <pharaun> oh, yeah UNode, i've been trying out several html parser, hexpat, and taggy, and etc... i was able to get something that kinda worked with taggy
02:15:39 <pharaun> so i'm now trying to figure out lens with hexpat
02:16:30 <pharaun> so far i was able to get it to give me a list of all "div" in the page, but i can't seem to be able to search for divs with a specific id (menu_sidebar) in this case.
02:17:40 <safinaskar> kadoban: Cale: thanks
02:18:30 <pharaun> Cale: http://lpaste.net/8830566044633399296
02:19:05 <pharaun> I recently got into lens, and i keep on feeling like i'm missing something, but i find it easier to try to work things out by cobbering something till it works then iterating but i'm rather stuck here at this stage
02:20:26 <pharaun> the error seems to infer that I can't use a "foo" as my ix, yet the *ONLY* example that i can find anywhere on the internet of using hexpat-lens is - http://www.reddit.com/r/haskell/comments/1o63ww/musings_on_lens/ccpavwz - which seems to imply that i can use ix to look up attributes on a node.
02:22:03 <Cale> Well, whichever instance of Traversable tel was using there doesn't appear to exist.
02:23:16 <pharaun> well then i'm not sure quite how to proceed then :D
02:26:07 <phaazon> hm
02:26:13 <phaazon> I guess Data.Graph is a bit limited :/
02:26:25 <Cale> phaazon: Extremely so
02:26:37 <phaazon> I’m gonna write my own version
02:26:38 <pharaun> Cale: so i've looked at - Control.Lens.At and it seems to take bytestring or int, so i tried to give it just int
02:26:42 <pharaun> it explodes as well
02:26:52 <pharaun> so any tips on how to even proceed from anywhere here on would be great
02:27:03 <pharaun> i can't seem to make more than 1 set of traversal work
02:27:58 <Cale> pharaun: I'm not confident enough with this part of lens to just rattle off some code for you without being able to actually attempt to compile it.
02:28:06 <phaazon> I’d like to find the shortest path from a vertex to another
02:28:12 <phaazon> and Data.Graph is clearly wrong 
02:28:18 <phaazon> it uses Data.Array…
02:29:22 <Cale> phaazon: Perhaps you could use fgl
02:29:37 <phaazon> nope
02:29:43 <phaazon> I’m coding on a compo machine
02:29:47 <phaazon> I can’t install anything
02:30:06 <Cale> rip
02:30:09 <phaazon> that’s okay, adjacency lists with Data.Vector is pretty simple to code
02:30:22 <Cale> Or Data.IntMap
02:30:46 <Cale> Depending on whether it would be convenient to edit the graph at any point
02:30:57 <phaazon> well, yeah
02:31:03 <phaazon> I need to disconnect vertices
02:31:05 <phaazon> i.e. remove edges
02:31:19 <phaazon> adjacency lists sound okay for that
02:31:40 <Cale> Something along the lines of Map Vertex (Set Vertex) is usually good
02:31:43 <phaazon> the graph has no notion of sense
02:32:09 <phaazon> Cale: yeah, sounds good
02:32:24 <phaazon> but I prefer doing that with Vector
02:32:26 <phaazon> way faster
02:32:33 <phaazon> and the graphs can get very dense
02:33:01 <Cale> Vector will be faster as long as the graph stays the same
02:33:12 <Cale> I guess it's possible that it's faster regardless
02:40:26 <pharaun> Cale: good news, i finally figured out `parameterized` which did what i needed without having to do a "textual" ix
02:40:42 <pharaun> and then i was able to hit it with . ix 2 and it worked, so... yeah
02:40:50 <Cale> pharaun: okay
03:05:48 <Phillemann> Oh! haskell-src-exts prints list types as "[] Int". Didn't even know that was legal syntax.
03:06:17 <jle`> Phillemann: yup :) you can actually sort of consider [Int] as [] Int
03:06:28 <jle`> er, syntactic sugar for [] Int
03:06:32 <jle`> :t fmap
03:06:33 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:06:52 <jle`> substitute f for [] and you get (a -> b) -> [] a -> [] b.  which is desugared (a -> b) -> [a] -> [b]
03:10:02 * ski . o O ( `select :: [a] -> [] (a,[a])' )
03:10:51 <Cale> Which of course is syntactic sugar for  (->) ((->) a b) ((->) ([] a) ([] b))
03:11:04 <petercommand> :t []
03:11:05 <lambdabot> [t]
03:11:36 <petercommand> :t ['1']
03:11:37 <lambdabot> [Char]
03:12:01 <petercommand> :t [1]
03:12:02 <lambdabot> Num t => [t]
03:12:41 <ski> @kind []
03:12:42 <lambdabot> * -> *
03:14:34 * hackagebot stackage-install 0.1.0.3 - Secure download of packages for cabal-install  http://hackage.haskell.org/package/stackage-install-0.1.0.3 (MichaelSnoyman)
03:24:31 <Aruro> is diagrams library included in stackage?
03:24:47 * hackagebot termbox-bindings 0.1.0.0 - Bindings to the termbox library  http://hackage.haskell.org/package/termbox-bindings-0.1.0.0 (lcfrs)
03:25:12 <le_redditor> im learning me a haskell
03:26:03 <Cale> le_redditor: cool, feel free to ask if you have any questions about the language
03:26:10 <maerwald> Aruro: there's a diagrams channel, maybe there you get the answer quicker
03:39:25 <pavonia> stackage-install depends on stackage-install. How is that resolved?
03:39:53 <ryantrinkle> are Monads required to fail strictly?
03:40:16 <ryantrinkle> e.g.: if i write a Monad such that (fail x >> return y) succeeds, is that problematic?
03:40:33 <luite> pavonia: the executable depends on the library, that's fairly common
03:41:02 <pavonia> Ah
03:42:24 <Cale> ryantrinkle: fail isn't even really supposed to be part of Monad imo. As far as I'm concerned it's okay if it's just implemented with an error call. It's weirder for it to succeed like that though, I've never seen any instance do that.
03:42:46 <ryantrinkle> Cale: yeah, i think i'm gonna make sure it fails
03:43:04 <ryantrinkle> i was implementing Monad Behavior
03:43:14 <ryantrinkle> and since Behaviors are actually not effectful at all
03:43:33 <ryantrinkle> i could write _ >> x = x
03:43:44 <Cale> ah, I see
03:44:06 <merijn> ryantrinkle: Fail is...an ugly wart and an abomination
03:44:34 <merijn> ryantrinkle: Actually, "_ >> x = x" would not obey the monad laws, afaik
03:44:48 <merijn> Well, depending on the monad
03:44:54 <Cale> merijn: I'm not sure the monad laws apply to partially defined values at all
03:45:12 <Cale> Well, I suppose we might want them to
03:45:35 <ski> > evalState (fail "foo" >> return ()) ()  -- using `Control.Monad.State.Lazy'
03:45:36 <lambdabot>  ()
03:45:44 <ski> also `Control.Monad.ST.Lazy'
03:45:54 <Cale> ah, interesting
03:45:59 <ski> ryantrinkle ^
03:46:09 <frerich> I often read that people consider 'fail' to be ugly, and I kind of see that it's not part of the 'minimalistic' interface -- but at the same time, isn't it really convenient for things like list ocmprehensions where you rely on failing pattern matches? I.e. isn't it too useful to seriously consider getting rid of it?
03:46:25 <Cale> frerich: It just belongs in its own class
03:46:34 <Cale> There used to be MonadZero for the list comprehension case
03:46:35 <merijn> frerich: List comprehensions don't use fail
03:47:01 * ski thinks there should be a `MonadFail' for `fail'
03:47:02 <frerich> merijn: Doesn't '[x | Just x <- x]' rely on the 'fail' definition for the list monad?
03:47:04 <merijn> frerich: The problem is not "I don't want fail", but "fail doesn't make sense for all monads and should thus be in a separate class"
03:47:15 <merijn> frerich: List comprehensions don't use the list monad at all
03:47:23 <ski> @undo [x | Just x <- x]
03:47:23 <lambdabot> concatMap (\ a -> case a of { Just x -> [x]; _ -> []}) x
03:47:26 <merijn> frerich: The report specifies explicit desugaring for list comprehensions
03:47:27 <ski> frerich ^
03:48:01 <frerich> Huh! Interesting! I wonder why I always thought it's sugar for a monad.
03:48:01 <Cale> If MonadComprehensions is turned on it might use fail.
03:48:25 <merijn> I would support fail in MonadZero and/or MonadFail with GHC inferring that constraint for types that have a do-notation that results in an incomplete match (thus potentially failing)
03:48:43 <merijn> frerich: It used to be and can be with the -XMonadComprehenesions extension, but by default it is not
03:48:51 <Cale> Actually, it doesn't
03:48:55 <ski> > runState (fail "foo" >> return ()) ()  -- the state is bust
03:48:57 <lambdabot>  ((),*Exception: foo
03:48:57 <Cale> MonadComprehensions uses Alternative
03:49:04 <ryantrinkle> merijn: it turns out that it actually does do that!
03:49:11 <ryantrinkle> i turned on RebindableSyntax once
03:49:15 <ryantrinkle> defined my own Monad and MonadFail
03:49:18 <ryantrinkle> and everything worked perfectly!
03:49:31 <merijn> ryantrinkle: Sure, but with RebindableSyntax lots of evil things work ;)
03:49:38 <ryantrinkle> true
03:49:40 <ryantrinkle> all i'm saying is
03:49:44 <Cale> GHC still uses the old Haskell 1.3 translation of the do-notation
03:49:46 <ryantrinkle> there's no work to be done on inferring things
03:49:57 <Cale> well, a variant of it
03:50:08 <Cale> Which only uses fail in cases where the pattern is failable
03:50:26 <ryantrinkle> Cale: that's already the case, i think
03:50:31 <ryantrinkle> that's what my experiment led me to believe, anyway
03:50:41 <Cale> Right, that's what I'm saying :)
03:50:52 <ryantrinkle> ohh
03:50:54 <ryantrinkle> got it
03:51:13 <Cale> So you can write do (x,y) <- foo; ... and it won't induce a MonadFail constraint with RebindableSyntax because (,) only has one constructor so pattern matches against it can't fail.
03:53:15 <Cale> The translation of do-notation suggested by the Report suggests that fail would always be used, even in cases where it would be dead code.
03:53:27 <Cale> At least the more recent Reports
03:55:10 <ryantrinkle> ah
03:57:56 <Cale> But back in Haskell 1.4, there was a separate translation of do {p <- e; <stmts>} for when p was failure-free vs. when it wasn't.
03:58:13 <Cale> I'm not sure how far back that goes... I think at least 1.3 had the same...
03:58:51 <ryantrinkle> well, i certainly hope they don't abandon that
03:59:25 <ryantrinkle> it's unfortunate that changing Monad would be so huge, but hopefully an extension that promotes typeclass refactoring will come along sometime
03:59:34 <Cale> ah, and do-notation didn't exist in 1.2 :)
03:59:40 <ryantrinkle> ah
04:00:01 <Cale> Well, we've seen changes to Monad recently
04:00:46 <hardenedapple> Hello, newbie question. I'm trying to extend the 'YesNo' typeclass from  learnyouahaskell.com to say that if anything is a number, then it's also a YesNo, I want to do this without defining an instance for all things that are a Num, is this possible?
04:02:10 <ryantrinkle> hardenedapple: i'm not quite clear on the distinction you're drawing
04:02:42 <ryantrinkle> is the idea to write an instance like: instance Num a => YesNo a
04:02:43 <ryantrinkle> ?
04:02:54 <Cale> hardenedapple: If I understand what you're asking, then no -- the reasons for why this doesn't work out are kind of subtle. Instance selection is done on the structure of the type alone, without taking any class constraints into consideration. The class constraints on the instance are then applied once it's selected.
04:03:01 <hardenedapple> ryantrinkle: Yes, basically
04:03:33 <ryantrinkle> ok, so in that case, it's possible to write that instance, but you won't be able to define any *other* instances
04:03:37 <Cale> hardenedapple: So your instance would look like instance YesNo a -- which would overlap with every other possible instance
04:03:50 <Cale> (to the instance selector)
04:03:51 <ryantrinkle> hardenedapple: right, just what Cale said
04:04:07 <hardenedapple> O.K. Got it, thanks guys
04:04:14 <ryantrinkle> hardenedapple: no problem
04:04:29 <Cale> The reason for this is that by design, you can never really rely on an instance *not* being present.
04:05:09 <Cale> New instances can show up in future modules, and if the compiler already compiled code under the assumption that they weren't there, you might get confusing and inconsistent results.
04:06:53 <Cale> hardenedapple: What you *can* do is to make a newtype wrapper, and make *that* an instance of YesNo
04:06:58 <Cale> hardenedapple: Like:
04:07:22 <Cale> newtype NumYesNo a = NumYN a
04:07:44 <Cale> instance (Num a) => YesNo (NumYesNo a) where ...
04:14:56 <hardenedapple> Cale: Just so I make sure I understand you, that would require wrapping all numbers when calling yesno (the function YesNo requires) so that I'd call  "yesno (NumYN 3)" rather than "yesno 3" -- is that correct
04:15:06 <Cale> yeah
04:15:15 <hardenedapple> Cale, thanks
04:19:49 * hackagebot cabal-helper 0.3.4.0 - Simple interface to Cabal's configuration state used by ghc-mod  http://hackage.haskell.org/package/cabal-helper-0.3.4.0 (DanielG)
04:35:40 <mniip> are there any symbolic math libraries?
04:47:09 <Nux_> given the choice of making a data value impossible to express at a computational cost and making invalid data values expressible in a faster/smaller program, what is the preferred choice among Haskell programmers?
04:47:58 <Nux_> I've opted for the latter but I'm interested to know if Haskell lends itself well to the former
04:48:35 <bennofs> Nux_: do you have a concrete example of this?
04:49:03 <Nux_> I have a type that holds an 'interval' which consists of a lower and upper bound
04:49:26 <Nux_> currently there's nothing to stop a user from giving a lower bound greater than the upper bound
04:49:42 <Nux_> and it will break my assumptions when they do
04:50:40 <Nux_> I could just have the user give two values which are then sorted to determine the upper and lower respective bounds
04:50:53 <bennofs> Nux_: hmm, making that impossible to express would be quite hard to express (it can be expressed, but the resulting API would probably be hard to use)
04:51:16 <bennofs> Nux_: that seems like a really bad idea to me, I would not expect an API to have that behavior at all
04:51:47 <Nux_> fair enough
04:52:02 <bennofs> Nux_: another option is to hide the interval data constructor and have a function interval :: Int -> Int -> Maybe Interval, so users need to deal with errors.
04:52:04 <mniip> hmm
04:52:19 <mniip> I might have accidentally invented... symbolic math transformers
04:52:21 <ClaudiusMaximus> mniip: i did something like that reccently (but very scrappy/domain-specific so far), what kind of operations do you need?
04:52:45 <mniip> ClaudiusMaximus, not really sure yet
04:53:02 <mniip> derivation, simplification
04:53:02 <Nux_> only, I heard about 'proofs for free' and I'm wondering if my coding style will mean forfeiting some useful advantages of using haskell
04:53:29 <Nux_> I don't know much about 'proofs for free' btw
04:53:38 <Nux_> I have a sense of what they are but no real working knowledge
04:53:52 <merijn> Nux_: I would use the "Int -> Int -> Maybe Interval" approach
04:54:32 <Nux_> ok that sounds good
04:54:37 <ClaudiusMaximus> mniip: ah, my code mostly does simplification (distribution, collecting terms, etc)
04:54:50 * hackagebot MusicBrainz 0.2.4 - interface to MusicBrainz XML2 web service  http://hackage.haskell.org/package/MusicBrainz-0.2.4 (ClintAdams)
04:55:00 <merijn> Nux_: Obviously this means "don't export the Interval constructor from your module"
04:55:07 <merijn> Nux_: Otherwise programmers can still mess it up :p
04:55:13 <Nux_> noted :)
04:56:03 <merijn> Nux_:  In general these sorta "prevent the user from doing the wrong thing" are, as noted by bennofs possible to do in Haskell, but rather verbose and complex
04:56:19 <merijn> Nux_: If you find wanting to do that often I would recommend keeping an eye on Idris in the future
04:56:20 <Haskellfant> I think the intervals package provides a Maybe constructor and a constructor that sorts it's arguments
04:57:07 <merijn> Nux_: Idris is a dependently typed language where expressing this sorta thing is easy, and it's being specifically designed for 1) pragmatic programming (as opposed to theorem proving lik Coq/Agda) and 2) existing haskell programmers
04:57:25 <merijn> It's still very early stages right now, but should be interesting as "next step" for haskellers
05:00:42 <Nux_> cool I'll take a look
05:00:44 <Nux_> cheers
05:03:54 <frerich> Nux_: A shameless plug, but I wrote a tiny utility function which can create 'smart constructors' (like '(Int, Int) -> Maybe Interval') for you: http://hackage.haskell.org/package/smartconstructor-0.2.0.0/docs/SmartConstructor.html
05:06:15 <Nux_> hehe, I see that Interval was the third example given :D
05:06:22 <frerich> Yeah :-)
05:09:20 <maerwald> I wonder why haskell still has the reputation of a niche-language that can be used for mathematical/technical stuff (only). Is our advertisement that bad? Or is it about FP in general
05:13:12 <zipper> Is there a way to find the path of a module by giving cabal repl the module name?
05:14:51 * hackagebot BiobaseXNA 0.9.1.1 - Efficient RNA/DNA representations  http://hackage.haskell.org/package/BiobaseXNA-0.9.1.1 (ChristianHoener)
05:15:57 <FreeFull> maerwald: I don't think most people want to program in a functional language with laziness
05:16:40 <maerwald> FreeFull: you think laziness is what people drives away?
05:16:59 <FreeFull> And the functional part
05:17:27 <FreeFull> Carmack seems to have been converted though
05:18:40 <maerwald> hm, I can understand that laziness might be considered a "pitfall" in programming, but compared with other pitfalls from other languages I think it happens less often
05:19:07 <maerwald> I've seen a few weird things on stackoverflow though, where laziness was involved. But that's rather rare.
05:19:18 <geekosaur> people are fundamentally lazy. haskell takes some work to learn.
05:19:30 <Nux_> maerwald, I think most people naturally think in a strict imperative fashion
05:19:35 <geekosaur> see also: why php, which is almost infinitely forgiving in its laxity, is so popular
05:19:43 <Nux_> it usually takes some study of algebra to start thinking lazily
05:19:47 <c_wraith> Haskell is actually fundamentally different from almost every other language.
05:19:54 <c_wraith> People are afraid of different
05:20:04 <geekosaur> indeed
05:20:25 <c_wraith> I know before I learned haskell, I was of the opinion that language differences were only in syntax. :)
05:20:51 <Nux_> geekosaur, are you saying that people are too lazy to learn how to program lazily?
05:20:54 <geekosaur> I knew better than that, but I was exposed to APL and J early on
05:20:54 <Nux_> ;)
05:20:59 <maerwald> Nux_: heh
05:21:33 <geekosaur> and other languages that broke the Algol mold
05:22:40 <maerwald> I think it's because a lot of languages that *are* different (e.g. prolog) have never reached the sate of a general-purpose language either. So people think oh haskell is THAT different... so it's probably only a niche-language as well.
05:23:04 <c_wraith> I had used ML in college, and didn't see it as fundamentally different from the algol-based languages...  Probably because I never was exposed to the module system.
05:23:42 <c_wraith> It's not the syntax of Haskell that's different..  It's the combination of laziness and ridiculous abstraction capability.
05:24:01 <c_wraith> I was plenty comfortable with purity and higher-order functions already.
05:27:02 <geekosaur> I wasn't really talking about syntax, really, more "Can programming be liberated from the Von Neumann style?"
05:27:23 <geekosaur> apl was borderline in that respect, prolog and haskell are definite mold breakers
05:27:43 <dgpratt> this seems crazy, I've allocated 4 GB of memory to this machine and it's still not enough, GHC runs out of memory
05:27:50 <dgpratt> trying 5 GB
05:28:44 <Nux_> Speaking from my own perspective, I started with Python and would always program in a relatively functional style. I've only recently started using Haskell but I'm already finding it so much easier to achieve a lot of the things that it's been so painful to do in Python
05:28:56 <dgpratt> it looks like it's dying building vector tests, which I almost thing someone in here mentioned yesterday as having high memory requirements
05:29:53 <Nux_> Maybe the semi-functional additions to imperative languages will give people a taste of what programming in more function programming languages could be like
05:30:02 <Nux_> *functional
05:32:07 <maerwald> Nux_: I don't think it will, honestly. I've seen e.g. the "functional" components in languages like Swift (the OSX thing). It just gives you additional syntax, not really the power of FP. And most already have some sort of semi-broken polymorphism via generics/templates, so they don't particularly understand how haskell polymorphism is different.
05:33:19 <Nux_> actually, the inferiority of their 'functional' additions are what I was suggesting might push people toward a language like haskell
05:34:44 <Nux_> provided they both develop a taste for the style and a sense that there are better languages for the purpose
05:34:44 <phaazon> yay
05:34:50 <phaazon> my graph AI works
05:34:53 <phaazon> http://phaazon.net/pub/skynet_finale_part1.mp4
05:34:58 <phaazon> pretty neat :)
05:36:47 <Nux_> maerwald, that was the case at least for me. I can only guess that there exists a demographic of people like me
05:37:29 <bernalex> Nux_: my experience with this is that people say a) "well now java has functional programming so what's the point of haskell then", and b) "eww this functional stuff is really dumb (e.g. in swift), why would anyone use a language that can only do this?"
05:39:26 <Nux_> sure and I'm not going to say that I will always prefer to code in Haskell over a currently more popular language.
05:42:37 <geekosaur> I find it unlikely that Haskell will become a popular language. I will be surprised if, some years down the road, the then popular languages haven't absorbed many of the things Haskell is pioneering.
05:44:52 * hackagebot log 0.1.1 - Structured logging solution with multiple backends  http://hackage.haskell.org/package/log-0.1.1 (arybczak)
05:45:31 <c_wraith> geekosaur: did you mean "won't be surprised"?
05:45:50 <geekosaur> ?
05:45:52 <Nux_> that's how I read it
05:46:25 <geekosaur> I expect them to (continue to) absorb concepts from Haskell. "I will be surprised if ... [they] haven't absorbed..."
05:46:59 <Nux_> sorry, THAT'S how I read it
05:47:44 <c_wraith> geekosaur: oh, I missed the later negation.  my mistake
05:48:16 <maerwald> geekosaur: but they cannot absorb them, imo. Because doing so would involve giving up on some concepts (e.g. side-effects) which they will never do. So what they absorb is really just syntax, most of the time.
05:49:09 <Nux_> my point earlier is that as that happens, it blurs the lines enough that people won't see moving to a language such as this so drastic
05:49:28 <bernalex> Nux_: at the same time the incentive to move in the first place will be smaller though.
05:49:33 <geekosaur> they will be restricted and focused into "contained" contexts that are easier for people to deal with.
05:50:08 <c_wraith> Microsoft is actually a leader at doing that.
05:50:10 <maerwald> Nux_: if you see how currying works in Swift... you will think "omg, such nonsense", because in Swift you have to write the closures ALL by yourself ;)
05:50:11 <geekosaur> they will certainly lose some of the power and flexibility
05:50:47 <c_wraith> C# and Powershell introduced (limited) monadic computations quite some time ago.
05:51:28 <dgpratt> it did?
05:51:41 <bernalex> there's synergy too. e.g. LINQ.
05:51:44 <c_wraith> C# has LINQ, powershell has workflows
05:52:10 <dgpratt> didn't realize ps workflows were especially monadic
05:52:16 <geekosaur> yes
05:52:22 <tromp> :t don
05:52:23 <lambdabot>     Not in scope: ‘don’
05:52:23 <lambdabot>     Perhaps you meant one of these:
05:52:23 <lambdabot>       ‘non’ (imported from Control.Lens),
05:52:24 <dgpratt> LINQ obviously is, though
05:52:27 <maerwald> Nux_: and there's no one saying in the Swift docs "our currying is so idiotic, you should go see how haskell does it"
05:52:49 <Nux_> also, I'm fine with being in a niche if that niche consists of the people who understand the benefits of programming functionally
05:52:59 <bernalex> maerwald: is swift free software? maybe you can send them a pull request with NB.
05:53:06 <tromp> > let don is (++) in Just.don"t"
05:53:06 <geekosaur> linq was one of the things I was thinking of but I'm still working on my first coffee and other people beat me to the punch
05:53:07 <lambdabot>  <hint>:1:17: parse error on input ‘in’
05:53:07 <maerwald> bernalex: I don't think it is
05:53:13 <c_wraith> bernalex: free software out of apple?
05:53:17 <tromp> > let don=(++) in Just.don"t"
05:53:17 <maerwald> :)
05:53:18 <bernalex> c_wraith: there is some.
05:53:18 <lambdabot>  Not in scope: ‘Just.don’
05:53:27 <tromp> > let don=(++) in Just . don"t"
05:53:28 <lambdabot>  <[Char] -> Maybe [Char]>
05:53:50 <bernalex> c_wraith: they do prefer taking weakly licensed free software and building proprietary shells on top of them though.
05:54:10 <tromp> > let don=length in Just . don"t"
05:54:11 <lambdabot>      Couldn't match expected type ‘a -> a1’ with actual type ‘Int’
05:54:11 <lambdabot>      Possible cause: ‘don’ is applied to too many arguments
05:54:11 <lambdabot>      In the second argument of ‘(.)’, namely ‘don "t"’
05:54:37 <bernalex> tromp: I don't know what you are doing but that doesn't make any sense.
05:54:52 * hackagebot path 0.0.0 - Path  http://hackage.haskell.org/package/path-0.0.0 (ChrisDone)
05:55:21 <tromp> i know:) just read that someone would like to have unsafePerformIO = Just . don"t"
05:55:45 <indiagreen> tromp: it was just “don't”, I think
05:55:50 <geekosaur> you missed part of it, yeh
05:56:00 <geekosaur> don't   is a perfectly valid Haskell identifier
05:56:05 <c_wraith> > let don't = 5 in don't
05:56:06 <lambdabot>  5
05:56:09 <tromp> oh, then i missed a quote
05:56:20 <indiagreen> http://hackage.haskell.org/package/acme-dont/docs/Acme-Dont.html#v:don-39-t
05:56:46 <tromp> but Just . "don't" makes no sense either
05:57:10 <indiagreen> “Just . don't”
05:57:31 <bennofs> I think acme-safe has KJu
05:57:40 <bennofs> *has safePerformIO = Just . don't
05:57:45 <thuletheking> I am trying to work with the haskell FFI and I now have a pointer foreign.ptr to a function. The function takes an int and returns an int, how do I use the foreign.ptr?
05:58:46 <frerich_> Nux_: Not sure it was mentioned already, but the list comprehension syntax in Python is directly taken from Haskell, https://wiki.python.org/moin/PythonVsHaskell says "The idea was just too good to pass up.".
05:59:00 <frerich_> Nux_: This didn't keep ESR form predicting doom of course: https://mail.python.org/pipermail/python-dev/2000-August/008306.html
05:59:05 <pxqr> are there any entry-level remote haskell jobs?
05:59:20 <bernalex> pxqr: remote jobs tend to not be entry-level
05:59:43 <pxqr> bernalex: well, i understand this
06:00:09 <pxqr> by entry level i mean not so "senior developer" or just like that
06:00:16 <maerwald> pxqr: galois was hiring last I checked, but not sure if that is entry level :D
06:00:21 <maerwald> but definitely highly interesting
06:01:02 <bernalex> maerwald: they are not hiring telecommuters afair.
06:04:59 <dgpratt> 5 GB was enough, it seems
06:06:47 <dgpratt> do folks percieve the memory requirements of GHC to be problematic, or is it nbd?
06:06:47 <tdammers> bernalex: yow, how's the work hunt going?
06:08:41 <bernalex> tdammers: on the phone with a potential customer right now ;)
06:09:24 <mpickering> dgpratt: Memory consumption has been getting worse over time
06:09:43 <mpickering> they are looking at trying to find out what's causing it for 7.12
06:10:19 <dgpratt> mpickering, that's good to know, thanks
06:10:38 <mpickering> what were you trying to compile out of interest?
06:11:07 <dgpratt> I was following along with this: http://wiki.ocharles.org.uk/Nix
06:11:56 <dgpratt> it looks like that causes ghc and core libs to be built from source
06:12:20 <tdammers> bernalex: \o/
06:12:34 <dgpratt> building tests on the vector package was the biggest resource demand
06:12:41 <mpickering> oh right, yes that is known
06:12:49 <mpickering> but are you using NixOS? or?
06:12:53 <mpickering> there should be binary caches
06:13:14 <Phillemann> I literally just followed this guide and did not compile anything from source.
06:14:23 <Phillemann> Depends on the architecture, of course.
06:14:53 <dgpratt> I may be wrong, but it certainly looked to me like that is what was going on
06:15:20 <mpickering> dgpratt: Which OS are you using?
06:15:32 <dgpratt> nixos, x64
06:15:54 <mpickering> ok then you probably shouldn't have to build ghc from source, there should be a binary cache
06:16:03 <mpickering> but I'm not able to tell you how to debug it sorry
06:16:12 <dgpratt> it's done now, mpickering, but that's good to know
06:16:23 <Phillemann> Oh, you're actually using nixos?
06:16:28 <Phillemann> Or just in a VM?
06:16:28 <dgpratt> yes
06:16:36 <dgpratt> well, nixos in a vm
06:16:50 <dgpratt> not as my daily driver
06:16:57 <Phillemann> Ah ok.
06:16:58 <zipper> Where can I get the path for a module if I know its name? It's not where the module name implies it is :(
06:17:54 <mniip> haskell fooled me again
06:18:11 <mniip> I was trying to make a practical program, but was dragged into theoretical research again ._.
06:19:05 <phaazon> hey, what’s the common strategy to remove a value out of a Vector?
06:20:10 <Nux_> frerich, I'd read that list comprehensions had come from Haskell. I've also since seen the development of the syntax from composition of monadic functions to do notation to list comprehensions within haskell
06:20:42 <zipper> mniip: Story of our lives.
06:21:53 <phaazon> slice, I guess
06:21:59 <frerich> Nux_: Yeah. From that point of view, it's actually not desireable for Haskell to become popular (hence the slogan "Avoid success at all costs!" I guess). Experimental new features are harder to implement (thinking of e.g. the 'fail' function in the Monad class). Instead, Haskell is successful if it 'fertilizes' other languages with the useful bits.
06:22:42 <zipper> frerich: What does that mean for people who want to write haskell for a living?
06:22:47 <zipper> frerich: Doom
06:22:52 <Denommus`> I only understood list comprehension when I understood monads 
06:23:25 <tdammers> frerich: haskell has to beneficial functions in the greater programming ecosystem: one, be an incubator for new, better ways to do "programming", and two, provide a haven of sanity where people can come to recover from the shenanigans of programming in the trenches
06:23:31 <tdammers> s/to/two
06:23:41 <tdammers> my $0.02 anyway
06:23:49 <Cale> You can of course still put Haskell to commercial use, and people do.
06:23:53 <tdammers> yes
06:24:10 <tdammers> nowhere near as much as, say, Java or PHP though
06:24:13 <dgpratt> I like SPJ's alternate interpretation, iirc "Avoid (success at all costs)"
06:24:51 <Denommus`> dgpratt: I also prefer that 
06:24:58 <frerich> tdammers: I would have thought you'd use two euro cents.
06:25:21 <tdammers> frerich: I'm using holland dollars
06:25:31 <frerich> :-)
06:26:01 <mniip> "provide a haven of sanity"
06:26:03 <mniip> hahaha
06:26:10 <Cale> While there's probably still more to be gained from the collaborative effects of having more users, there are already enough maintained libraries one can already do quite a lot in Haskell.
06:26:23 <mniip> sanity in my haskell?
06:26:43 <Cale> There's something to be said for using the language as a competitive edge as well.
06:29:07 <saulzar> For me it's the opposite, it sinks a lot of time and reduces productivity - because it's often more fun than my "real" work :)
06:30:46 <tdammers> Cale: absolutely
06:31:10 <tdammers> Cale: I'm fostering plans to do exactly that in this company here
06:33:09 <frerich> I suppose the curse of having a good programming language is that people start to enjoy writing good libraries with it, and the issue with that is that people start using and depending on those libraries - and suddenly it's hard to be a research language when there's less and less room for experimentation due to the fear of breaking backwards compatibility.
06:34:05 <Nux_> frerich, isn't that when a split like with scheme and common lisp happens?
06:34:40 <frerich> Nux_: I don't know, I'm a self-taught C++/Python guy who only tinkers with Haskell to get a glimpse of what he's missing out on :-}
06:35:30 <ion> "Haskell is a modern functional language (like lisp)."
06:35:34 <Denommus`> frerich: hm, mainstream languishing worry a lot about retrocompatibility
06:35:42 <bernalex> ion: lol
06:35:57 <Denommus`> Languages 
06:36:13 <Nux_> frerich, aside from not having much C++ knowledge, I'm pretty much the same
06:37:00 <Denommus`> frerich: do you also use Rust? 
06:39:21 <Nux_> frerich, I've similarly dabbled in Scheme and it's that difference in priorities between a lightweight elegant language with plenty of room for extension and a 'pragmatic' language mired in compromises that distinguishes the two lisp variants
06:39:26 <frerich> Denommus`: No, I don't know anything about that.
06:39:50 <Nux_> the trouble is, a common complaint against lisp is all the dialects. It has split too many times
06:41:14 <Denommus`> frerich: memory safety enforced by the type system 
06:41:22 <tdammers> that's a silly complaint though - it's like complaining that JavaScript isn't C
06:41:27 <bergmark> better that than still having dynamic scoping and CL's stdlib :-)
06:41:30 <Denommus`> frerich: without runtime overhead 
06:42:09 <Denommus`> Nux_: nobody says that about ALGOL 
06:44:36 <Nux_> Denommus`, the difference is, ALGOL became established early, developed into a similar set of established languages whereas lisp is nowhere near as entrenched
06:45:03 * hackagebot clock 0.4.6.0 - High-resolution clock functions: monotonic, realtime, cputime.  http://hackage.haskell.org/package/clock-0.4.6.0 (CetinSert)
06:45:07 <safinaskar> is it possible not to export instantiation?
06:45:47 <hiptobecubic> safinaskar, what does that mean?
06:46:51 <safinaskar> hiptobecubic: let's assume i write "instance A B where" in my module. i want compiler to "know" that B is A inside this module but to forget this outside the module
06:47:05 <geekosaur> no
06:47:07 <hiptobecubic> safinaskar, ah. No.
06:47:14 <hiptobecubic> safinaskar, that breaks a lot of things it turns out
06:47:16 <geekosaur> there are type system problems if instances aren't global
06:47:56 <hiptobecubic> safinaskar, suppose you have a Set of Foo's and Foo has two different instances of Eq, the membership of the set would change depending on where you were when you looked at it
06:48:14 <safinaskar> geekosaur: hiptobecubic: thanks
06:48:29 <bergmark> safinaskar: add a newtype with the instance inside a module, and don't export the newtype
06:48:34 <hiptobecubic> or whatever the class is that Set wants, is it even Eq? Might be Ord?
06:48:38 <hiptobecubic> probably ord
06:48:58 <bergmark> yes, Ord
07:05:41 <Nux_> I'm making my Foo a an instance of show with the type constraint (Fractional a) => ...
07:06:12 <Nux_> is there a way of making a new instance for cases where the type constraint isn't satisfied?
07:06:30 <Nux_> actually
07:07:29 <Nux_> is there some way of putting the particular implementations under one non-constrained instance?
07:07:40 <c_wraith> GHC allows it if you enable super-scary extensions that are hard to understand and often go wrong when least expected.
07:08:01 <geekosaur> ghc picks the instance before inspecting its context
07:08:07 <c_wraith> In general, the safe answer is "don't do that, use a newtype wrapper"
07:08:37 <geekosaur> tricky extensions may get ghc to pick the instance you intend.. or may not. not reliable, not recommended
07:08:49 <Nux_> fair enough
07:08:51 <Nux_> cheers
07:15:03 * hackagebot yesod-crud 0.1.1 - Generic administrative CRUD operations as a Yesod subsite  http://hackage.haskell.org/package/yesod-crud-0.1.1 (league)
07:25:37 <wei2912> how'd i write a function `chop` such that i can take in 3 and `[1, 2, 3, 4, 5, 6]` to get `[[1, 2, 3], [2,  3, 4], [3, 4, 5], [4, 5, 6]]` without the use of `length`?
07:26:01 <wei2912> this is what i have now:
07:26:03 <wei2912> chop k xs = [(take k . drop i) xs | i <- [0 .. length xs - k]]
07:27:40 <albeit> chop k (a:b:c:rest) = [a,b,c] ++ chop k (b:c:rest); chop k _ = []
07:27:55 <albeit> Actually nvm, k isnt variable ;)
07:29:50 <ski> > let n = 3; xs = "abcdef" in [take n ys | ys <- zipWith const (tails xs) (drop (n-1) xs)]
07:29:51 <lambdabot>  ["abc","bcd","cde","def"]
07:31:54 <ion> > let dropTail n xs = zipWith const xs (drop n xs) in (dropTail 3 . map (take 3) . tails) "abcdef"
07:31:56 <lambdabot>  ["abc","bcd","cde","def"]
07:33:37 <quetzakubica> Guys is there something like event dispatcher in haskell?
07:35:04 * hackagebot twitter-feed 0.1.1.5 - Client for fetching Twitter timeline via Oauth  http://hackage.haskell.org/package/twitter-feed-0.1.1.5 (stackbuilders)
07:35:04 <quetzakubica> I wonder how would that bet implemented with FP
07:37:20 <tdammers> quetzakubica: google for "Functional Reactive Programming"
07:38:43 <quetzakubica> thanks tdammers
07:39:10 <wei2912> thanks albeit ski and ion :)
07:41:31 <ion> > [ [a,b,c] | a:b:c:_ <- tails "abcdef" ]
07:41:32 <lambdabot>  ["abc","bcd","cde","def"]
07:42:10 <Denommus`> ion: that has constant k
07:42:13 <kqr> I always forget you can rely on fail that way
07:42:55 <ion> Denommus: Yeah, that's why i gave an example with a variable k above.
07:44:07 <nshepperd> I would call that function ngrams
07:46:19 <nshepperd> but lo, it does not get found under that name by hoogle either
07:53:44 <Nux_> > (\k -> let secretLength xs = foldr (\x -> (+1)) 0 xs  in filter ((==k) . secretLength) (concat $ map inits $ tails [1,2,3,4,5])) 3
07:53:45 <lambdabot>  [[1,2,3],[2,3,4],[3,4,5]]
07:54:16 <indiagreen> I think it's usually called “window”
07:54:34 <vijaykiran> Hello, I'm trying to work through Yesod book - and can't figure out how to get the simple helloworld.hs to run using runhaskell - the cabal install yesod-static keeps failing :(
07:55:51 <vijaykiran> "hjsmin-0.1.4.7 depends on optparse-applicative-0.11.0.2 which failed to install."  - is the first error in cabal install output - anyone has ideas on how to fix this ?
07:56:41 <athan> Hey guys, what did I do wrong here? http://www.reddit.com/r/haskell/comments/359br3/can_we_make_sum_and_product_foldable/
07:56:43 <athan> vijaykiran: Can you show us the error?
07:56:48 <athan> it's hard to see _what_ went wrong, just from dependency failures
07:59:32 <vijaykiran> athan: https://gist.github.com/vijaykiran/aa116c4ef27d8244475e 
08:00:03 <vijaykiran> that's the last lines from the output of the command :  cabal update && cabal install yesod yesod-bin persistent-sqlite yesod-static
08:03:23 <frerich> kqr: I learned earlier today that in '> [ [a,b,c] | a:b:c:_ <- tails "abcdef" ]' you don't actually rely on fail at all.
08:03:41 <athan> vijaykiran: oh woah, I don't use windows so it's hard to say
08:03:48 <athan> vijaykiran: Have you thought about using a sandbox?
08:03:51 <kqr> frerich, oh. what happens?
08:04:27 <frerich> kqr: I was told that the Haskell report actually specifies how list comprehensions desugar, and it has nothing to do with monads. Instead, it's something like...
08:04:39 <frerich> @undo [ [a,b,c] | a:b:c:_ <- tails "abcdef" ]
08:04:39 <lambdabot> concatMap (\ d -> case d of { a : (b : (c : _)) -> [[a, b, c]]; _ -> []}) (tails "abcdef")
08:04:46 <kqr> oh
08:04:47 <vijaykiran> athan: I'm on Mac :) well sandbox is what I'm eventually going to use - but the book said - "lets use Yesod as library instead of scaffolding"
08:04:59 <kqr> frerich, interesting. I'm guessing something else happens with MonadComprehensions?
08:06:19 <athan> vijaykiran: Wait... but... DLLs o_o
08:07:32 <Phlogistique> is there any working code using Text.Boomerang.Combinators from which I could learn how to use it?
08:07:40 <frerich> kqr: I cannot remember, but you can check todays IRC logs at http://tunes.org/~nef/logs/haskell/15.05.08 -- go to '03:46:09' where the discussion starts with me incorrectly assuming that 'fail' is involved in list comprehensions.
08:08:41 <frerich> The stupid thing is that I remember claiming that the list comprehension works because of 'fail' on StackOverflow once, and it's one of my most upvoted answers. Despite being blatantly wrong, as I now learned.
08:09:50 <frerich> In my defense, I think I claimed so because I heard it from dmwit! :)
08:10:44 <kqr> frerich, interesting, thanks
08:10:57 <kqr> I remember seeing that desugaring for list comprehensions, but assumed it to be a useful model and not actually what happens
08:11:11 <frerich> kqr: In http://stackoverflow.com/a/7007369/91757 I claimed that it's because of "fail" bout four years ago, and it seems many people in that thread thought the same.
08:11:41 <frerich> And dmwit wrote 'The literal translation of [x | (x:_) <- ["hi", "hello", ""]] is ["hi", "hello", ""] >>= \s -> case s of { x:_ -> [x]; _ -> fail "inexhaustive pattern match" }.' -- maybe that was indeed once the case.
08:12:00 <kqr> yeah it sounds like it was
08:12:05 <kqr> and for some types it can be with monadcomprehensions
08:12:55 * frerich wonders if anybody here is that 'newacct' guy from StackOverflow, because his profile says that 'I am an expert at the programming languages Haskell, OCaml, Java, Python, Ruby, Standard ML, Scheme, C++, Perl, C, Objective-C, PHP, Go, Swift, and JavaScript.'. Pretty impressive.
08:13:15 <frerich> I'm not even sure I'm an expert in any single one of them, let alone all of them.
08:13:34 <tdammers> frerich: impostor syndrome much?
08:13:36 <athan> I'm an expert at not getting anything done ._.
08:14:09 <frerich> tdammers: Who knows, maybe his first name is Oleg or Simon or so. :-)
08:14:13 <maerwald> athan: close your fb account, don't watch yt and quit irc :o
08:14:35 <athan> maerwald: BUT WHAT WILL I DOOOOO
08:14:40 <athan> at least there's reddit :v
08:15:19 <tdammers> being named "Simon" correlates significantly with being good at Haskell
08:15:32 <tdammers> I'll leave the interpretation of this data to the reader
08:16:04 <frerich> I see you concur with my implications.
08:16:56 <ion> "<athan> I'm an expert at not getting anything done ._." It's nice to meet colleagues.
08:17:24 <athan> tdammers: It's true, it's fate
08:17:54 <frerich> athan: Maybe it soothes your troubled soul that not knowing what you will do doesn't matter much if you assert that you don't get anything done.
08:17:56 <athan> ion: Productively being unproductive!
08:18:14 <samgd> Just trying to generate some binary strings, would anyone be willing to nudge me towards a more flexible solution? (Variable length? If that's possible? New to monads) http://pastebin.com/nRhAzrJz
08:18:25 <athan> frerich: so troubled Y-Y
08:18:37 <athan> I mean, there's so much pop culture to pay attention to
08:18:43 <athan> they're so important, you know?
08:21:15 <athan> tdammers, ion, frerich: Can you see anything funny with this? http://www.reddit.com/r/haskell/comments/359br3/can_we_make_sum_and_product_foldable/
08:21:24 <athan> I've got 0 feedback so far ._.
08:21:33 <dmj``> athan: for what
08:21:43 <ion> I left a significant number of IRC channels some time ago. That didn't increase my productivity, but leaving #Haskell resulted in me playing with Haskell much less. Just being here seems to help me at least toy with ghci daily and maintain my Haskell knowledge even if i don't get anything useful done.
08:21:54 <athan> dmj``: o/ it's for a foldable instance, but for numbers >:D
08:22:22 <ion> athan: I'll try to take a look after I'm finished eating. I have it open in a tab.
08:22:27 <frerich> ion: Same here, the vast majority of things I know about Haskell were directly or indirectly learned from listening to people in #haskell and following the links they post.
08:22:33 <athan> ion: Thank you :)
08:22:49 <athan> frerich: Same! You get really far if you _really_ read papers, though
08:25:05 * hackagebot osc 1.0.0.2 - A library to handle messages in the OSC protocol  http://hackage.haskell.org/package/osc-1.0.0.2 (peacememories)
08:25:45 <vadim__> test
08:26:17 <vadim__> hi everyone.
08:29:29 <ion> samgd: That's exactly what replicateM does.
08:29:43 <ion> > replicateM 3 "01"
08:29:44 <lambdabot>  ["000","001","010","011","100","101","110","111"]
08:29:45 <athan> vadim__: Hello!
08:30:35 <samgd> Huh, neat, thanks!
08:30:39 <athan> > runState (replicateM 3 $ put . (+1) . get) 4
08:30:41 <lambdabot>      Couldn't match expected type ‘StateT s Identity a’
08:30:41 <lambdabot>                  with actual type ‘a0 -> m0 ()’
08:30:41 <lambdabot>      In the second argument of ‘($)’, namely ‘put . (+ 1) . get’
08:30:53 <athan> > execState (replicateM 3 $ put . (+1) . get) 4
08:30:54 <lambdabot>      Couldn't match expected type ‘StateT s Identity a0’
08:30:55 <lambdabot>                  with actual type ‘a1 -> m0 ()’
08:30:55 <lambdabot>      In the second argument of ‘($)’, namely ‘put . (+ 1) . get’
08:31:00 <athan> shoot
08:31:22 <athan> > execState (replicateM 3 $ put =<< (+1) =<< get) 4
08:31:23 <lambdabot>      Occurs check: cannot construct the infinite type:
08:31:23 <lambdabot>        s ~ StateT s Identity s
08:31:23 <lambdabot>      arising from a functional dependency between:
08:31:27 <athan> merp
08:31:54 <athan> > execState (replicateM 3 $ get >>= \n -> put $ n+1) 4
08:31:55 <lambdabot>  7
08:32:00 <athan> yayuh
08:33:32 <nshepperd> athan: you're taking Sum n to represent something like [1..n]?
08:33:44 <nshepperd> and Product n to represent the prime factors of n?
08:33:56 <athan> nshepperd: Yes!
08:34:05 <athan> the product is a bit strange
08:34:27 <athan> I left them to be commutative, but I needed the "largest" prime factor of `n` (n itself) to be done last
08:34:45 <athan> that way the induction is more "full"
08:34:46 <ion> > execState (replicateM (modify (+1))) 4
08:34:47 <lambdabot>      Couldn't match type ‘m0 a1 -> m0 [a1]’ with ‘StateT s Identity a0’
08:34:48 <lambdabot>      Expected type: State s a0
08:34:48 <lambdabot>        Actual type: m0 a1 -> m0 [a1]
08:34:51 <athan> or complete (idk)
08:34:56 <athan> :o
08:35:05 <ion> > execState (replicateM 3 (modify (+1))) 4
08:35:06 <lambdabot>  7
08:35:11 <nshepperd> interesting
08:35:18 <athan> nshepperd: Thank you :)
08:35:35 <nshepperd> although, perhaps Sum n should represent (replicate n 1) or something?
08:35:53 <athan> nshepperd: Definitely
08:35:57 <nshepperd> so that foldMap f (Sum a) <> foldMap f (Sum b) = foldMap f (Sum a <> Sum b)
08:36:00 <athan> oh wiat
08:36:04 <athan> no you're correct
08:36:10 <athan> it's not [1..n]
08:36:14 <athan> it is replicate n 1
08:36:19 <athan> in the current implementation
08:36:27 <nshepperd> ah right
08:36:28 <athan> negatives in the same mannar, but with -1
08:37:59 <nshepperd> well, I suppose you don't generally get the monoid homomorphism anyway
08:38:38 <athan> nshepperd: Why do you say that?
08:38:56 <athan> it should, shouldn't it?
08:39:14 <ion> > runState (replicateM 3 (get <* modify (+1))) 4
08:39:15 <lambdabot>  ([4,5,6],7)
08:39:29 <nshepperd> it doesn't strictly require 'foldMap f (Sum (-1)) <> foldMap f (Sum 1) == f (Sum 0)' for example
08:39:32 <athan> ion: :D thank you
08:39:34 <athan> (still a newb)
08:39:47 <athan> nshepperd: Ahh! You're correct
08:39:54 <nshepperd> without demanding some kind of group homomorphism from f, I guess
08:39:56 <athan> in natural numbers, it's sound though, right?
08:40:01 <athan> hmm
08:40:02 <nshepperd> yeah
08:40:35 <nshepperd> with Product, you have the ordering of prime factors
08:41:35 <Denommus> is (*>) the Applicative and more general version of (>>)?
08:41:52 <johnw> yes
08:42:02 <athan> nshepperd: Ordering?
08:42:06 <nshepperd> 'foldMap f (Product 7) <> foldMap f (Product 3)' vs 'foldMap f (Product 21)'
08:42:18 <nshepperd> vs foldMap f (Product 3) <> foldMap f (Product 7)
08:42:22 <athan> ahh
08:42:26 <athan> yes you're correct there also
08:42:40 <athan> so they're more group homomorphisms over foldable (mergable?)
08:42:46 <athan> I'm not sure
08:43:13 <athan> erm, abelian group
08:43:18 <athan> thank you nshepperd :)
08:43:56 <nshepperd> I suppose you could say that f to be an abelian group homomorphism would guarantee the monoid homomorphism of foldMap f?
08:44:51 <Nux_> frerich, I'm not entirely sure, but you might have been wrong about list comprehensions and wrong about how you're wrong :D http://www.quora.com/How-does-a-Haskell-list-comprehension-desugar
08:44:55 <athan> nshepperd: I think so :\
08:45:53 <athan> nshepperd: Feel free to lambdabot pm me with more goodies :)
08:46:01 <athan> I've gotta split
08:46:41 <nshepperd> sure :>
08:53:51 <neuroserpens> How can I turn string of digits into a list of integers like "123" to [1, 2, 3] ?
08:54:02 <neuroserpens> no wait
08:54:04 <neuroserpens> just map read
08:54:07 <neuroserpens> nevermind
08:54:33 <neuroserpens> > map (read :: String -> Int) "123"
08:54:34 <lambdabot>      Couldn't match type ‘Char’ with ‘[Char]’
08:54:34 <lambdabot>      Expected type: [String]
08:54:34 <lambdabot>        Actual type: [Char]
08:54:36 <ski> > map digitToInt "123"
08:54:37 <neuroserpens> rofl
08:54:37 <lambdabot>  [1,2,3]
08:54:43 <ion> map digitToInt
08:54:56 <neuroserpens> I see ski and ion. Thanks.
08:54:58 <NemesisD> i find myself having to write a Show instance manually because my record includes a type without Show. Is there anything to make this less painful?
08:54:59 <alynn> map unsafeCoerce
08:55:02 <alynn> obviously
08:55:03 <ski> > map digitToInt "abcdefg"
08:55:04 <lambdabot>  [10,11,12,13,14,15,*Exception: Char.digitToInt: not a digit 'g'
08:55:20 <NemesisD> i'm not willing to use a newtype record on the type without show. i don't want to change my library's API
08:55:51 <nshepperd> ...I always used map (read . return)
08:56:26 <ski> NemesisD : do you need `Show' ?
08:56:41 <neuroserpens> How to I use hoogle in this channel again?
08:56:41 <ski> is the `Show' instance sensible ?
08:56:57 <NemesisD> ski: i think its always handy for GHCI. the offending type without show is Loc from TH
08:56:59 <ski> @hoogle find
08:56:59 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
08:56:59 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
08:56:59 <lambdabot> Data.ByteString.Char8 find :: (Char -> Bool) -> ByteString -> Maybe Char
08:57:09 <ski> @hoogle (a -> Bool) -> [a] -> [a]
08:57:10 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
08:57:10 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
08:57:10 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
08:57:12 <NemesisD> wait no it must be something else, that has show
08:57:16 <ski> @hoogle+
08:57:17 <lambdabot> Data.List filter :: (a -> Bool) -> [a] -> [a]
08:57:17 <lambdabot> Prelude takeWhile :: (a -> Bool) -> [a] -> [a]
08:57:17 <lambdabot> Data.List takeWhile :: (a -> Bool) -> [a] -> [a]
08:57:46 <ion> NemesisD: Writing your own Show instance can be slightly boilerplatey, but it isn't that painful, is it?
08:58:11 <NemesisD> i'm being a baby about it, surely
08:58:19 <NemesisD> apparently Loc only recently got a Show instance...
08:59:27 <NemesisD> maybe i should get my morning coffee and then reevaluate how painful writing Show really is :P Its certainly not as bad as writing Read
08:59:38 <ski> if you're writing a `Show' instance manually, you should (usually) define `showsPrec', and know how to use `showParen',`showChar',`showString',`showsPrec',`shows' to define it
08:59:53 <ion> Hoogle+, the social network of Hoogle users
09:00:24 <ski> (for `Read', you should (usually) define `readsPrec', using `readParen',`readsPrec',`reads',`lex')
09:02:16 <ski> imho, two things are desirable here : (a) that `show' will result in a string representation of a Haskell expression that when evaluated in the appropriate environment (modules in scope) will result in a value equal to the original one; (b) that `read' after `show' will result in a value equal to the original one
09:02:53 <NemesisD> thankfully i don't need a read
09:03:18 <NemesisD> and i'm wondering if i could newtype over Loc, derive show for it and then use that in my show
09:03:34 <ski> (a) commonly means that you'll be outputting a string representation of the raw data constructor applications used in the value. however, it can also mean that you don't expose your implementation, instead outputting a representation in terms of some interface function that can be used to construct an equal value
09:03:57 <ski> > show (listArray (0,3) [2,3,5,7])  -- is an example of the latter
09:03:58 <lambdabot>  "array (0,3) [(0,2),(1,3),(2,5),(3,7)]"
09:04:17 <ion> You could use a showsPrecLoc in your Show instance and specify your own showsPrecLoc.
09:05:03 <ski> imho, if you're about to deviate from (a) and (b), you should consider whether you really need/want to do this
09:05:29 <NemesisD> i want to do it to make using this type in GHCi less painful, nothing more
09:05:43 <ski> imho, if you're just after some kind of custom pretty-printing or formatting, then you should probably not (ab)use `Show' (and possibly also `Read') for this purpose at all
09:05:54 <ski> NemesisD : i'm speaking generally here. not accusing you of anything
09:06:30 <ski> (just fyi)
09:06:58 <NemesisD> gotcha. i understand and generally agree with your points. its just that show incentivizes you to write instances that are less principled
09:07:22 <ski> (imho, `Show' (and `Read') are mostly about debugging, especially in the interactor)
09:08:20 <Haskellfant> is there some zipper package that allows me to have rose trees where the list of children is a list zipper so that I also keep a focus there? I could ofc just write this myself but if it already exists it would be nice :)
09:08:50 <ski> NemesisD : "i'm wondering if i could newtype over Loc, derive show for it and then use that in my show" -- yes, assuming you can make a sensible `Show' instance for the `newtype'd `Loc' in the first place
09:09:06 <ski> .. or as ion said
09:09:14 <timidtrap> ski: I've seen that sentiment before (re: Show and Read) is there a link (or links) you can send me that elaborates more on why?
09:14:09 <ski> timidtrap : perhaps not really what you asked for, but <https://www.haskell.org/onlinereport/haskell2010/haskellch11.html#x18-18600011.4> mentions more or less my (a) and (b) points
09:14:29 <timidtrap> awesome, thanks
09:15:57 <ski> timidtrap : it's formulation of (b) in terms of `readsPrec' and `showsPrec' is more general than what i said. i agree with it. what i said above captures the most important gist in a shorter way
09:16:03 <ski> s/it's/its/
09:20:20 <ski> timidtrap : regarding associativity (still on (b)), i'm personally a little bit torn
09:20:28 <ski> timidtrap : regarding `Read', contrary to the text, i'd be fine if `Read' operations also work on string representations that require taking associativity into account to be able to successfully parse
09:21:37 <ski> timidtrap : regarding `Show', i'd also like to (contrary to the text) allow an instance to omit brackets when taking associativity into account would permit so. however, perhaps an argument from conservativity wouldn't allow this (iow perhaps the possible(?) presence of code that wouldn't be able to cope with this should discourage us from emitting such string representations, in the name of backwards compatibility)
09:24:59 <ski> timidtrap : regarding the (a) point, i'm not sure if the text "syntactically correct Haskell expression containing only constants" is intended to allow cases like the `Show' instance for `Array' above. in any case, i think this would be fine in principle, but perhaps we should be cautious again. similarly for outputting lambda expressions (possibly involving a `case' expression)
09:25:07 * hackagebot sorted-list 0.1.0.0 - Type-enforced sorted lists and related functions.  http://hackage.haskell.org/package/sorted-list-0.1.0.0 (DanielDiaz)
09:26:26 <Thule> Hi Guys. I have a function loadLibrary that returns IO HINSTANCE. I would like to perform the following: main = do dlls <- map loadLibrary ["dll1","dll2"] however I get Expected type: IO (IO HINSTANCE) Actual type: [IO HINSTANCE]. Is it not possible to use lists in do ntoation?
09:27:16 <ski> timidtrap : for reasons ("why"), i think it's good not to conflate different purposes. obviously one of the main purposes of `Show' must be to output valid Haskell expressions that evaluate to the value, and so i'd like to be able to rely on this as much as possible
09:27:56 <timidtrap> yeah, i think i get it. thanks for the clarity
09:28:51 <alynn> :t mapM
09:28:52 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
09:29:09 <alynn> Thule: trydlls<- mapM loadLibrary ["dll1", "dll2"]
09:29:21 <Thule> works
09:29:22 <haskell124> \msg lambdabot @pl \A a b c -> f a b c
09:29:24 <Thule> thank you
09:29:42 <ski> timidtrap : for `Read', it's perhaps not as clear. however, since Haskell expressions (which per about `show' outputs a subset of) must be readable to a computer, why not have a corresponding `Read' to be able to programmatically read the values back in. this can provide a simplistic kind of universal interface, e.g. for persistence, even though if you're after this kind of thing, it's possible that you'll be better off with some non-text (or at least non-H
09:30:07 <ski> (zzz_timidtrap : er, cut off near ".., it's possible that you'll be better off with some non-text (or at least non-Haskell-expression) based representation format")
09:31:13 <ski> zzz_timidtrap : these are all my personal, half-formed, opinion and rationale. take it for what it is
09:31:38 <ski> (also, i spelled it out as much here because others may also find it interesting)
09:31:51 <ski> zzz_timidtrap : good night
09:55:08 * hackagebot sorted-list 0.1.1.0 - Type-enforced sorted lists and related functions.  http://hackage.haskell.org/package/sorted-list-0.1.1.0 (DanielDiaz)
10:24:29 <SrPx> Can't I have a container that holds a lens, and then use makeLenses for it? http://lpaste.net/132235
10:25:59 <johnw> you need to use ALens, not Lens
10:26:06 <johnw> Lens hides a Rank-2 type
10:26:13 <edwardk> makeLenses can't work on ALensCase
10:26:19 <edwardk> Lens' A Int is a rank-2 type
10:27:24 <edwardk> so you'd get Lens' ALensCase (Lens' A Int) -- which expands to forall f. (Lens' A Int -> f (Lens' A Int)) -> ALensCase -> f ALensCase -- which expands to 
10:27:52 <SrPx> Thanks. Is it just an issue with "makeLenses" specifically? Is the solution simply to use makeLensesFor ignoring that specific attribute? Or am I doing something fundamentally wrong?
10:28:00 <neuroserpens> !hoogle digitToInt
10:28:03 <neuroserpens> ops lol
10:28:06 <neuroserpens> @hoogle digitToInt
10:28:06 <lambdabot> Data.Char digitToInt :: Char -> Int
10:28:06 <lambdabot> Data.Text.Internal.Read digitToInt :: Char -> Int
10:28:06 <lambdabot> Data.Text.Internal.Read hexDigitToInt :: Char -> Int
10:28:45 <edwardk> forall f. Functor f => (forall g. Functor g => (Int -> g Int) -> A -> g A)  -> f (forall g. Functor g => (Int -> g Int) -> A -> g A) -> ...   -- the problem comes up in that f (forall g. ...) that isn't legal. you need ImpredicativeTypes for that and they just don't work.
10:29:16 <johnw> SrPx: from the documentation on ALens: "This type can also be used when you need to store a Lens in a container, since it is rank-1. You can turn them back into a Lens with cloneLens, or use it directly with combinators like storing and (^#)."
10:29:21 <edwardk> the problem is that you can't make a lens for a higher rank or existential field
10:30:08 <edwardk> like johnw suggests you can store either a ReifiedLens or an ALens in there, and still get the lens to it with MakeLenses, but Lens' itself has a rank-2 type.
10:30:41 <edwardk> ultimately it comes down to f (forall x. ...) not working general in haskell
10:31:03 <edwardk> the only type constructor fancy enough to hold a forall like that is the first argument of (->)
10:31:29 <edwardk> er the only argument of a type constructor capable of holding a forall like that
10:33:52 <SrPx> Okay, let me goodle that, thanks.
10:37:37 <athan> It would be cool if liquid types / dependent haskell make a new type-class style of organizing types - by their specification
10:38:11 <athan> like a new heirarchy - specification heirarchy or something
10:38:54 <SrPx> Sorry, but what exactly is ALens? http://lpaste.net/132237 This makes ALensCase's lens succesfully, but the lens inside it doesn't seem to work
10:39:19 <SrPx> arg, nevermind. Sorry
10:39:42 <edwardk> An "ALens" isn't a lens itself, it fixes the choice of functor so the type isn't rank-n, think of it a a lens broken down into frozen concentrate or something ;)
10:40:16 <SrPx> Uh huh, makes total sense. I still have no idea how you figured that out, but that works so I'm happy.
10:40:19 <edwardk> http://hackage.haskell.org/package/lens-4.9.1/docs/Control-Lens-Lens.html#v:cloneLens can recover it
10:40:37 <edwardk> that takes an ALens s t a b and gives you a Lens s t a b
10:40:43 <SrPx> Yep yep, I just read it. Sorry for asking since it is right on the doc.
10:41:03 <edwardk> There are also some combinators that are designed for working directly with ALens
10:41:25 <edwardk> they usually have hashes in them ^#, #~ , etc
10:45:10 * hackagebot fasta 0.6.1.1 - A simple, mindless parser for fasta files.  http://hackage.haskell.org/package/fasta-0.6.1.1 (GregorySchwartz)
10:45:38 <ion> They are hash-ish, if you will.
10:45:49 <SrPx> So, I can make this better? aaa %~ (cloneLens (bbb^.ccc)) *~ ddd
10:46:33 <SrPx> someone should raise a kickstarter to write a lens book
10:46:48 <athan> YES
10:46:50 <hiptobecubic> I get it now. https://imgflip.com/i/l8ise
10:46:52 <athan> plz :(
10:47:02 <ion> hiptobecubic++
10:47:21 <frerich> hiptobecubic: :-))
10:47:46 <edwardk> srpx you should be able to compose that clone'd lens into the one on the left of %~
10:48:03 <edwardk> aaa.cloneLens (bbb^.ccc) *~ ddd
10:48:36 <SrPx> cool :) 
10:48:58 <johnw> how about aaa.bbb^#ccc *~ ddd
10:49:10 <johnw> maybe need some parens
10:49:42 <ion> parenal advisory
10:53:03 <SrPx> doesn't seem to work
10:55:00 <Haskellfant> SrPx: I would definitely buy that book
10:58:31 <shapr> Is there anything on hackage comparable to Python's requests module?
10:58:50 <shapr> oh, maybe wreq
11:02:38 <SrPx> :)
11:02:51 <wayne> :<
11:04:23 <SrPx> Is there any way to improve "(\ foo → a . cloneLens (foo^.c.d) *~ e $ foo)" ? I mean, any way to remove that "foo" inside (not the last one) taking in account it is the argument it receives
11:04:48 <SrPx> That is, I have an object which stores a lens pointing to another part of that same object... things are getting kinda messy because of that
11:05:32 <ion> I'm sure @pl will make that code much nicer.
11:05:42 <johnw> SrPx: in that case, I think the lambda abstractions is the clearest expression of what's going on
11:06:00 <johnw> you want each value to define the part of that value the lens acts upon
11:07:08 <SrPx> hmm..
11:10:40 <bringitonhome> The class of Data.Queue.Enqueue is declared as:
11:11:05 <bringitonhome> class Monad m => Enqueue q m a | q -> a where enqueue :: q -> a -> m ()
11:11:48 <bringitonhome> why does this return a monad?  I would think it would be q -> a -> q returning the new queue with the enqueued element
11:12:07 <johnw> it doesn't "return a monad"
11:12:30 <johnw> enqueue takes a queue, and a value, and builds an action that has some side-effect
11:12:48 <johnw> what that side-effect is cannot be known by that type alone
11:14:46 <bringitonhome> why would there be any side effect?
11:15:15 <johnw> what package is that from?
11:15:27 <bringitonhome> https://hackage.haskell.org/package/queue-0.1.2/docs/src/Data-Queue-Classes.html#Enqueue
11:15:46 <ion> I wouldn't call them side-effects, I'd call them just effects. Side-effects are what you get with unsafePer******.
11:15:48 <bringitonhome> er, https://hackage.haskell.org/package/queue-0.1.2/docs/Data-Queue.html#t:Enqueue
11:15:59 <johnw> ion: fair enough
11:16:18 <johnw> i'm not sure why this is a type class at all
11:16:39 <johnw> so, what is does is pretty lawless
11:16:50 <johnw> you hope it is having some effect related to 'q'
11:17:00 <geekosaur> "may block while doing so" sounds relevant
11:17:12 <geekosaur> although I do wonder at all of these being separate classes
11:17:37 <johnw> for example, if q was TQueue a and a was 'a', and m was STM, then there'd be a pretty clear implementation
11:21:32 <bringitonhome> I'm guessing maybe the intent of that package is not a data structure?
11:22:03 <johnw> i'm wondering how often he changed queue representations that he needed to abstract the operations
11:22:37 <c_wraith> usually, the source of packages like that is overexposure to java.
11:23:05 <geekosaur> does seem like someone's trying to write Javaish interfaces there, yeh
11:23:40 <SafeMoneyOnl> 4,1 Win 20.000-30.000 Euro Per year (1700-2500 Euro per month) With 1 H per day for 365 days. At start you will earn little money but with time your starting to learn much more at start you can win 0.5 euro per day first week and after a month you will earn 10-20 euro per day Its Verry simple just Make an account on my link and i will train you and i will be your guide as much you need Sign 
11:23:40 <SafeMoneyOnl> 4,1Up here And good Luck 9,1 -----> http://www.marketglory.com/strategygame/lolopoco
11:23:45 --- mode: ChanServ set +o geekosaur
11:23:55 --- mode: geekosaur set +b *!SafeMoneyO@188.26.43.190
11:23:55 --- kick: SafeMoneyOnl was kicked by geekosaur (Your behavior is not conducive to the desired environment.)
11:24:00 <johnw> thanks, geekosaur
11:24:07 <johnw> my brain was just beginning to feel that something was wrong
11:24:28 --- mode: geekosaur set -o geekosaur
11:29:14 <frankster> hi nice people, I could use some help with a nested list comprehension,
11:29:36 <johnw> Then I will endeavor to give you an answer within an answer
11:31:02 <frankster> i need to write a function that takes a list of lists, removes any inner list that contains more than 4 elements and then removes all odd numbers from the inner lists
11:31:06 <bringitonhome> so, I see this is not part of the Data in base: https://hackage.haskell.org/package/base-4.8.0.0, and not in containers: https://hackage.haskell.org/package/containers (which is not part of base, but is [i guess] included by Prelude?).  Sorry new to Haskell.  Coming from Scala world.
11:31:18 <frankster> let me paste what i have in lpaste
11:31:22 <frankster> one second
11:31:52 <johnw> bringitonhome: what do you mean by "this"?
11:32:07 <geekosaur> presumably the queues package on Hackage
11:32:30 <geekosaur> that is not a repo of "standard" packages, but a general repo of Haskell packages of whatever origin
11:32:33 <bringitonhome> sorry - the Data.Queue module I posted before: https://hackage.haskell.org/package/queue-0.1.2/docs/Data-Queue.html#t:Enqueue
11:32:46 <geekosaur> ranging from core stuff like containers to pure jokes like acme-php
11:33:01 <bringitonhome> ok
11:33:20 <frankster> http://lpaste.net/8080607846435127296 <- this is what I have, now I know exactly that it is wrong, but I cannot wrap my head around how to keep the nested lists, but remove the odd numbers without using any map or filter (which i am not allowed to use in this case ;))
11:34:38 <johnw> f2 xs = [[x | x <- ix, even x] | ix <- xs, length ix <= 4]
11:34:56 <frankster> oh god
11:34:58 <frankster> thanks
11:35:06 <frankster> now that I see it..........
11:35:11 * hackagebot th-typegraph 0.14 - Graph of the subtype relation  http://hackage.haskell.org/package/th-typegraph-0.14 (DavidFox)
11:35:26 <frankster> haha, I need to wrop my head around haskell a little more.
11:35:28 <Iceland_jack> frankster:
11:35:28 <Iceland_jack>     [ x | x <- xs | even x ]
11:35:28 <Iceland_jack> can be written as
11:35:28 <Iceland_jack>     filter even xs
11:35:33 <Iceland_jack> *xs, even x
11:35:42 <frankster> yes, but I am not allowed to use filter ;)
11:36:00 <Iceland_jack> Just throwing it out there :)
11:36:45 <frankster> now I usually don't go around asking for solutions to problems I have to solve, but I've been staring at it for too long this time
11:36:54 <frankster> johnw: thank!
11:36:56 <frankster> s
11:37:10 <johnw> sure thing, although pushing through that frustration is more valuable than finding the answer
11:37:11 <frankster> it makes so much sense now, hehe
11:37:38 <Iceland_jack> frankster: In Haskell the trandition is often writing lists as "xs" as you've no doubt noticed, and lists of lists of as "xss"
11:37:39 <johnw> if you're trying to change how you think
11:37:46 <frankster> I know, mostly I enjoy doing that but it's friday and I just wanted it done with, otherwise it would've bothered me all weekend
11:37:54 <johnw> haha
11:38:16 <johnw> yeah, it me 9 days to figure out how to prove that the square root of 3 is irrational; the temptation to Google it was intense
11:38:24 <Iceland_jack>     f2 xss = [ [x | x <- xs, even x ] | xs <- xss, length xs <= 4]
11:38:29 <Iceland_jack> (is one way)
11:38:57 <frankster> Iceland_jack: thanks, after reading the above I just changed it to exactly your version
11:38:59 <frankster> thank you!
11:40:07 <frankster> I am halfway through "Learn you a haskell for great good", and I have much to learn still.
11:40:25 <Iceland_jack> The Haskell rabbit hole goes as deep as you want
11:40:25 <c_wraith> frankster: that may not be the best intro.
11:40:36 <johnw> the haskell rabbit hole is pretty much endless
11:40:54 <frankster> c_wraith: I thoroughly enjoy it, but am open for another recommendation!
11:40:56 <geekosaur> in part because every time you get near the bottom, a new ghc release adds new depth
11:41:04 <geekosaur> @where cis194
11:41:04 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
11:41:34 <frankster> geekosaur: thanks, added to my reading list
11:42:06 <frankster> ohhhh, it does look good, thanks!
11:42:46 <saml> why spring 13?
11:45:48 <frankster> another thing: One problem asks for the infinite list xs of all pairs (a,b) with a,b being natural Numbers. The pairs should be created in a 'fair order' (my translation from German), so that (x,y) `elem` xs will always terminate after a finite amount of time. I wrote what I believe is the solution, but would like to discuss it.
11:46:06 <frankster> xs = [(a,b) | a <- [0..], b <- [0..a]]
11:46:27 <merijn> frankster: Actually, that solution won't be fair :)
11:46:29 <geekosaur> saml, presumably no problems have been found with it since then so no reason to revise the curriculum
11:46:38 <merijn> > [(a,b) | a <- [0..], b <- [0..a]]
11:46:39 <lambdabot>  [(0,0),(1,0),(1,1),(2,0),(2,1),(2,2),(3,0),(3,1),(3,2),(3,3),(4,0),(4,1),(4,...
11:46:47 <johnw> frankster: hint: a fair order must interleave from the two inputs
11:46:59 <merijn> oh, actually, it might be...
11:47:09 <geekosaur> maybe 7.10 will force a revision for the fall version :)
11:47:17 <merijn> That's not how I would've expected that to go >.>
11:47:20 <hiptobecubic> it has them all in there I think
11:47:28 <merijn> hiptobecubic: In finit time...
11:47:52 <frankster> well I have a hard time testing it, because I kill ghci every time when I run ie: (256,100) `elem` xs on my old x61 ;)
11:47:59 <merijn> hiptobecubic: If you first do infinite elements for 0, then for 1, etc. you won't reach any tuple not starting with zero in finite time :p
11:48:05 <c_wraith> frankster: I'm pretty sure that won't produce anything where the first element is greater than the second one.
11:48:14 <frankster> yes my thought
11:48:15 <hiptobecubic> merijn, sure, but it doesn't do that.
11:48:29 <c_wraith> frankster: err, reverse that.  but whatever, it gets the point across.
11:48:44 <frankster> so I made another one:
11:48:48 <hiptobecubic> it just fills in a triangle starting from 0,0 and going right, filling up columns from bottom to top
11:49:21 <frankster> hmmm
11:49:28 <frankster> lemme draw that out
11:49:29 <hiptobecubic> the problem is that it doesn't include the reverse of the numbers though, so if a > b, you are boned
11:49:38 <hiptobecubic> err, b > a
11:49:48 <hiptobecubic> (0, 1) doesn't appear, for example.
11:50:18 <Iceland_jack> > (0,1) : [ (a,b) | a <- [0..], b <- [0..a] ]    -- ;)
11:50:19 <lambdabot>  [(0,1),(0,0),(1,0),(1,1),(2,0),(2,1),(2,2),(3,0),(3,1),(3,2),(3,3),(4,0),(4,...
11:50:30 <hiptobecubic> tada!
11:50:44 <johnw> > [ (a,b) | z <- [0..], a <- [0..z], b <- [0..z]]
11:50:46 <lambdabot>  [(0,0),(0,0),(0,1),(1,0),(1,1),(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,...
11:50:56 <hiptobecubic> let findtuple_in_list a b = (a, b)
11:51:00 <hiptobecubic> there.
11:51:04 <c_wraith> johnw: lots of repeats done that way. :)
11:51:14 <johnw> yeah...
11:52:35 <dolio> There's a better solution.
11:52:57 <hiptobecubic> > concat [if a /= b then [(a,b),(b,a)] else [(a,b)] | a <- [0..], b <- [0..a]]
11:52:59 <lambdabot>  [(0,0),(1,0),(0,1),(1,1),(2,0),(0,2),(2,1),(1,2),(2,2),(3,0),(0,3),(3,1),(1,...
11:53:25 <phy1729> I have a type  data Subgroup = Subgroup { group :: Group, matrix :: Data.Matrix.Matrix Int }   most functions only operate on the matrix bit and the group is never changed. This feels like a monad and that there should be a clean way to only operate on the matrix, but I can't think of it.
11:53:26 <dolio> There's a better one than that. :)
11:53:44 <Denommus> wait
11:53:45 <hiptobecubic> I suppose just the normal way to enumerate the rationals?
11:53:54 <Denommus> now Prelude uses Foldable whenever possible?
11:54:10 <indiagreen> hiptobecubic: with repetitions
11:54:39 <c_wraith> eh, just throw them out when the GCD > 1, and you remove those
11:54:53 <soud> Hi, I'm trying to get Aeson to work for parsing some JSON, but when defining an abstract data type I get a parse error. This is my data type: https://bpaste.net/show/646048e3dac0
11:55:30 <c_wraith> soud: field names aren't allowed to start with a capital letter
11:55:31 <bringitonhome> Why are multiparameter type classes an extension?  This makes me think what I'm trying to do is wrong.  Still on the queue thing, this seems like a reasonable design in a type class:  enqueue :: q -> a -> (q, a).  But the compiler doesn't like it.
11:55:47 <soud> c_wraith: oh wow, thanks
11:56:36 <c_wraith> bringitonhome: multiparameter type classes are an extension because they're kind of tricky, and the entire class mechanism was brand new when the language was created
11:57:11 <alexv19> What is the latest LLVM version GHC supports? It seems it doesn't work with 3.6
11:57:18 <bringitonhome> c_wraith: so, common to use it?
11:57:25 <hiptobecubic> bringitonhome, yes
11:57:44 <c_wraith> soud: the only things at the value level that are allowed (and required) to start with capital letters are data constructors.
11:57:50 <c_wraith> shoot, he left
11:58:06 <hiptobecubic> bringitonhome, I think in general don't be afraid of extensions other than the scary sounding ones about unsafe things, undecidable things, orphaned things, etc
11:58:41 <c_wraith> Undecideable is fine.  Overlapping is bad. :)
11:59:17 <hiptobecubic> what does undecidable imply?
11:59:38 <bringitonhome> hiptobecubic thanks.  Hard to tell if by using them you are taking 'shortcuts' or doing things improperly when you re trying to learn.
11:59:38 <bennofs> hiptobecubic: it says that type checking might not terminate
12:00:26 <dolio> MPTCs aren't that great without other extensions, and those other extensions are difficult to pin down well enough to put in a language standard.
12:00:59 <bennofs> hiptobecubic: in practice, ghc will give a context stack depth exception after a certain number of reductions
12:03:55 <merijn> hiptobecubic: Undecidable is fine, in the sense that "programs that compile succesfully will always behave the same and as expected"
12:04:08 <merijn> It just means your compile may hang/crash if you screwed up
12:06:22 <merijn> bringitonhome: Most extensions are fine in that they just allow for more expressive power in the type system
12:07:44 <c_wraith> some allow for more expressive power in the value system!  -XTupleSections
12:07:53 <webstrand> Does a function with a type of () -> Maybe a always return the same value/type?
12:08:19 <webstrand> Change `a` to Int
12:08:31 <c_wraith> webstrand: depends on whether you count bottom as a distinct value, and whether you consider the same polytype to be the same type. :)
12:08:32 <merijn> TupleSections is AWESOME
12:08:41 <merijn> And a good way to blow people's minds :D
12:09:14 <disgrntld> hey gang, if I have `let pair = ((+), "plus")`, how can I use `fst pair` inline?
12:09:35 <merijn> > ('c',,True,,1,,[]) "foo" (Just False) 2 -- whoooo!
12:09:36 <lambdabot>  ('c',"foo",True,Just False,1,2,[])
12:09:41 <arkeet> disgrntld: as an infix operator? you can't
12:09:43 <disgrntld> do I have to just `let op = fst pair`?
12:09:46 <arkeet> yes
12:09:47 <disgrntld> kk
12:09:49 <disgrntld> thanks!
12:09:49 <hiptobecubic> merijn, yikes
12:10:04 <c_wraith> hiptobecubic: it just works exactly the way you'd want it to, though
12:10:12 <merijn> hiptobecubic: Why yikes?
12:10:18 <merijn> It's just "fill in the holes"
12:10:26 <merijn> :t ('c',,True,,1,,[])
12:10:28 <lambdabot> Num t2 => t -> t1 -> t3 -> (Char, t, Bool, t1, t2, t3, [t4])
12:10:30 <webstrand> c_wraith: I'm not sure I understand. Can I write a function that satisfies the type () -> Maybe Int, that determines at runtime whether to return Nothing or Int? (assuming purely functional, no unsafe code)
12:10:51 <arkeet> webstrand: it will always return the same value 
12:10:52 <arkeet> when given ()
12:11:04 <c_wraith> webstrand: well, no.  But haskell is non-strict.  There are other values with type ()
12:11:31 <c_wraith> > let f () = Nothing in f ()
12:11:33 <lambdabot>  Nothing
12:11:36 <c_wraith> > let f () = Nothing in f undefined
12:11:37 <lambdabot>  *Exception: Prelude.undefined
12:11:50 <arkeet> > let f x = Just (case x of () -> 5) in f ()
12:11:51 <lambdabot>  Just 5
12:11:52 <arkeet> > let f x = Just (case x of () -> 5) in f undefined
12:11:54 <lambdabot>  Just *Exception: Prelude.undefined
12:13:21 <c_wraith> webstrand: this is an important detail of haskell, but if you're just learning the language, it might be unnecessary complication at this point
12:13:58 <johnw> > [  x | a <- [0..], b <- [0..a], x <- (if a /= b then [(a,b), (b,a)] else [(a,a)]) ]
12:13:59 <lambdabot>  [(0,0),(1,0),(0,1),(1,1),(2,0),(0,2),(2,1),(1,2),(2,2),(3,0),(0,3),(3,1),(1,...
12:14:17 <hiptobecubic> johnw, that's what i had as well.
12:14:18 <webstrand> c_wraith: I kind of understand haskell, i'm more interested in it's type system though.
12:14:39 <johnw> dolio: hint as to your better way?
12:15:12 * hackagebot git-annex 5.20150508 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20150508 (JoeyHess)
12:15:44 <ion> () -> Maybe a ~ (Maybe a)^() ~ (Maybe a)^1 ~ Maybe a. Ignoring bottoms, there are as many (() -> Maybe a)s as (Maybe a)s.
12:15:51 <merijn> webstrand: Interested from a theory side, from a "implementing my own language" side or both?
12:16:00 <Peaker> Why do groupOn and sortOn not exist? groupBy/sortBy are painful!
12:16:54 <ion> > do a <- [0..]; b <- [0..a]; if a /= b then [(a,b), (b,a)] else [(a,a)]
12:16:56 <lambdabot>  [(0,0),(1,0),(0,1),(1,1),(2,0),(0,2),(2,1),(1,2),(2,2),(3,0),(0,3),(3,1),(1,...
12:17:07 <johnw> ion: well, we have convergence at least :)
12:17:15 <indiagreen> Peaker: we have sortOn in GHC 7.10
12:17:22 <Peaker> ah, cool :)
12:17:25 <ion> johnw: I just modified your version
12:17:26 <indiagreen> and sortWith/groupWith were long available in GHC.Exts
12:17:30 <indiagreen> (they're the same)
12:17:40 <johnw> sortOn was added after seeing a presentation at NYC Hack
12:19:31 <webstrand> merijn: Both, I've a suspicion that regular languages are related to the Hindley-Milner type system, so i'm trying to figure out what's different
12:19:48 <webstrand> merijn: by implemtning a toy language
12:19:48 <arkeet> sortOn f can be a bit more efficient than sortBy (comparing f)
12:19:51 <arkeet> if f is expensive
12:20:09 <c_wraith> On the other hand, if f is cheap, it can be worse
12:20:15 <arkeet> mhm
12:20:53 <c_wraith> If this was PHP, we'd add a third argument indicating whether to cache the results of f during the sort. :)
12:20:59 <arkeet> heh
12:21:02 <c_wraith> (and make it optional)
12:21:17 <merijn> It was a trick question, because I have the same recommendation for both :p
12:21:21 <merijn> webstrand: Get TaPL
12:21:22 <hiptobecubic> > let f i = zip [1..i-1] [i-1, i-2..1] in [2..] >>= f
12:21:23 <lambdabot>  [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(4,1),(1,5),(2,4),(3,...
12:21:25 <merijn> @where tapl
12:21:25 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
12:21:53 <merijn> webstrand: That covers both the theory of type systems and how to implement typecheckers/inferers and has sample checkers for all the type systems discussed
12:22:11 <merijn> webstrand: (in ocaml, but only basic ocaml so with basic haskell knoweldge you should be able to read them)
12:22:42 <ski> @let select :: Alternative i => [a] -> i (a,[a]); select [    ] = empty; select (a:as) = pure (a,as) <|> liftA (second (a :)) (select as)
12:22:43 <lambdabot>  .L.hs:162:13:
12:22:43 <lambdabot>      Couldn't match type ‘i’ with ‘[]’
12:22:43 <lambdabot>        ‘i’ is a rigid type variable bound by
12:23:29 <arkeet> :t second
12:23:30 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
12:23:42 <arkeet> @where select
12:23:43 <lambdabot> select [] = []; select (x:xs) = (x,xs) : (map.fmap) (x:) (select xs)
12:23:56 <arkeet> @let select [] = []; select (x:xs) = pure (x,xs) <|> (fmap.fmap) (x:) (select xs)
12:23:57 <lambdabot>  .L.hs:160:1: Warning:
12:23:57 <lambdabot>      Pattern match(es) are overlapped
12:23:57 <lambdabot>      In an equation for ‘select’:
12:24:04 <arkeet> uh
12:24:13 <arkeet> :t select
12:24:14 <lambdabot> [t] -> [(t, [t])]
12:24:16 <arkeet> @undefine
12:24:16 <lambdabot> Undefined.
12:24:17 <arkeet> @let select [] = []; select (x:xs) = pure (x,xs) <|> (fmap.fmap) (x:) (select xs)
12:24:19 <lambdabot>  Defined.
12:24:21 <arkeet> :t select
12:24:22 <lambdabot> [t] -> [(t, [t])]
12:24:24 <arkeet> oh.
12:24:36 <arkeet> @undefine
12:24:36 <lambdabot> Undefined.
12:24:40 <arkeet> @let select [] = empty; select (x:xs) = pure (x,xs) <|> (fmap.fmap) (x:) (select xs)
12:24:41 <lambdabot>  Defined.
12:24:43 <arkeet> :t select
12:24:44 <lambdabot> Alternative f => [t] -> f (t, [t])
12:24:56 <arkeet> select [1..5] :: Maybe Int
12:25:02 <arkeet> > select [1..5] :: Maybe (Int,[Int])
12:25:04 <lambdabot>  Just (1,[2,3,4,5])
12:25:15 <arkeet> :t StateT select
12:25:16 <lambdabot> Alternative m => StateT [a] m a
12:25:37 <arkeet> pm time
12:29:50 <Denommus> what is the recommended library for XML parsing?
12:29:55 <Denommus> HXT?
12:30:10 <dmj`> tagsoup, xml, depends on your needs
12:30:36 <dmj`> http://stackoverflow.com/questions/1361307/which-haskell-xml-library-to-use
12:31:01 <Denommus> dmj`: I need to parse some SOAP requests and produce C++ classes from them
12:31:09 <Denommus> dmj`: I could do it by hand, but I'd rather automate
12:31:29 <pavonia> arkeet: Isn't "pure foo <|> bar == pure foo"?
12:31:44 <dmj`> Denommus: is SOAP a hard requirement, can your endpoint deliver json?
12:31:56 <ski> pavonia : no
12:32:03 <merijn> pavonia: Depends on the Alternative
12:32:31 <pavonia> Ah, it's not for e.g. lists, I see
12:32:44 <ski> (also, there's no need for `(==)' to be defined there. i'd prefer using `=' (you know, equality))
12:32:44 <Denommus> dmj`: it's a hard requirement
12:33:18 <pavonia> > select [1,2,3] :: [Int]
12:33:20 <lambdabot>      Couldn't match type ‘(Integer, [Integer])’ with ‘Int’
12:33:20 <lambdabot>      Expected type: [Int]
12:33:20 <lambdabot>        Actual type: [(Integer, [Integer])]
12:33:36 <dmj`> Denommus: this looks relevant, uses xml-conduit, heard good things
12:33:38 <pavonia> > select [1,2,3] :: [(Int, [Int])]
12:33:38 <dmj`> Denommus: https://hackage.haskell.org/package/soap-0.2.2.5
12:33:40 <lambdabot>  [(1,[2,3]),(2,[1,3]),(3,[1,2])]
12:33:40 <small-wolf> > :t select
12:33:41 <lambdabot>  <hint>:1:1: parse error on input ‘:’
12:33:48 <ski> > select "abcd" :: [] (Char,[Char])
12:33:50 <lambdabot>  [('a',"bcd"),('b',"acd"),('c',"abd"),('d',"abc")]
12:33:52 <small-wolf> :t select
12:33:53 <lambdabot> Alternative f => [t] -> f (t, [t])
12:33:58 <merijn> dmj`, Denommus: xml-conduit was very usable
12:34:08 <small-wolf> :i Alternative
12:34:19 <small-wolf> that might not be the right way to do it ...
12:34:25 <arkeet> > select [] :: Maybe (Int,[Int])
12:34:26 <lambdabot>  Nothing
12:34:27 <arkeet> > select [1,2,3] :: Maybe (Int,[Int])
12:34:29 <lambdabot>  Just (1,[2,3])
12:35:03 <arkeet> is this thing actually useful with anything but []
12:35:14 <ski> small-wolf : `class Applicative i => Alternative i where empty :: i a; (<|>) :: i a -> i a -> i a; ...'
12:35:39 <ski> arkeet : how about a fair backtracking monad ?
12:36:05 <erisco> this is in my object file  __ZNSt3__16__sortIRNS_6__lessIiiEEPiEEvT0_S5_T_
12:36:24 <ski> (i suppose you could probably embed list into it, in this case, on second though)
12:36:28 <erisco> when I try and link my Haskell program with my object file it complains it cannot find  void std::__1::__sort<std::__1::__less<int, int>&, int*>(int*, int*, std::__1::__less<int, int>&)
12:36:36 <erisco> is this some issue with name mangling then?
12:36:45 <merijn> erisco: C++ mangles names, yes
12:36:47 <Denommus> dmj`: I don't need to actually use SOAP from Haskell
12:36:52 <Denommus> dmj`: the client is in C++
12:37:08 <erisco> merijn okay, so
12:37:12 <Denommus> dmj`: I just want to automate the classes that wrap the requests
12:37:18 <erisco> what I have in my object file is  introsort  which calls the std::sort
12:37:23 <erisco> my Haskell program is calling introsort
12:37:24 <Denommus> dmj`: merijn: I'll look into xml-conduit anyway
12:37:25 <arkeet> @let selected = folding sel where sel [] = []; sel (x:xs) = (x,xs) : (map.fmap) (x:) (sel xs)
12:37:26 <lambdabot>  Defined.
12:37:28 <merijn> erisco: Use extern C to export C style identifiers
12:37:30 <arkeet> > [1,2,3] ^.. selected
12:37:32 <lambdabot>  [(1,[2,3]),(2,[1,3]),(3,[1,2])]
12:37:36 <arkeet> idk
12:37:43 <erisco> merijn I did to export introsort, which is my wrapper for std::sort
12:38:14 <merijn> erisco: Did you export it as extern "C"?
12:38:19 <erisco> export what?
12:38:28 <merijn> On the C++ side
12:38:40 <erisco> yes, but what?
12:38:45 <merijn> You need to specify functions as part of the 'extern "C"' namespace
12:38:53 <erisco> there is my wrapper introsort_i which is extern "C"
12:38:54 <merijn> Otherwise they are namemangled by C++
12:39:06 <merijn> And it can't find that?
12:39:10 <erisco> it can
12:39:21 <erisco> it cannot find the std::sort which introsort_i calls
12:39:29 <erisco> that is what I do not understand
12:39:31 <merijn> Then you're compiling the C++ wrong
12:39:36 <erisco> I guess so
12:39:40 <arkeet> oh wait.
12:39:44 <geekosaur> that looks like a template function that probably requires the C++ standard library to be linked
12:39:51 <arkeet> @let iselected = ifolding sel where sel [] = []; sel (x:xs) = (x,xs) : (map.fmap) (x:) (sel xs)
12:39:52 <merijn> geekosaur: oh, duh
12:39:53 <lambdabot>  Defined.
12:39:57 <arkeet> > [1,2,3] ^@.. selected
12:39:58 <lambdabot>      Couldn't match type ‘Indexed i a (Const (Endo [(i, a)]) a)’
12:39:58 <lambdabot>                     with ‘(Integer, [Integer]) -> Const (Endo [(i, a)]) b0’
12:39:58 <lambdabot>      Expected type: IndexedGetting i (Endo [(i, a)]) [Integer] a
12:40:02 <arkeet> crap.
12:40:05 <arkeet> > [1,2,3] ^@.. iselected
12:40:07 <lambdabot>  [(1,[2,3]),(2,[1,3]),(3,[1,2])]
12:40:09 <erisco> geekosaur what do you mean? :s
12:40:12 <arkeet> > [1,2,3] ^@.. iselected <.> iselected
12:40:13 <lambdabot>  [((1,2),[3]),((1,3),[2]),((2,1),[3]),((2,3),[1]),((3,1),[2]),((3,2),[1])]
12:40:28 <arkeet> I dunno, this seems silly.
12:40:32 <arkeet> moving to -lens
12:40:59 <geekosaur> C++ has a runtime library that manages things like object creation and passing and soem template-related things, just as Haskell has a runtime library
12:41:05 * edwardk tunes in to figure out what is going on =)
12:41:15 <geekosaur> (C also has one but it's usually included automatically)
12:41:23 <erisco> geekosaur I don't know what the relevance is
12:41:46 * Ralith woners what template-related things geekosaur is talking about
12:41:51 <geekosaur> void std::__1::__sort<std::__1::__less<int, int>&, int*>(int*, int*, std::__1::__less<int, int>&)
12:42:04 <geekosaur> the __1 and the <typehere> are template things
12:42:18 <erisco> can I get rid of the template things, that'd be nice
12:42:19 <geekosaur> and __1 suggests C++11 to me
12:42:27 <johnw> how is __1 a template thing?
12:42:39 <johnw> looks like a namespace thing
12:42:42 <erisco> I just want to instantiate the template for ints and be done with it
12:42:44 <geekosaur> but in any case, most C++ objects will require the C++ runtime, unless you're writing C code in C++ for some reason
12:42:53 <erisco> but how does that lead to a linker error?
12:43:10 <johnw> erisco: you can, you'll need a explicit template instantiation, in a module that also explicitly exports that instantiated functions using extern "C"
12:43:31 <erisco> johnw I thought that was exactly what I was doing
12:43:33 <pyon> geekosaur: AFAICT, the only things in the core C++ language that require runtime support are exceptions and virtuals.
12:43:53 <johnw> then you'll also need to link with either libstdc++ or libc++, depending on gcc or clang
12:43:55 <geekosaur> C++11 and C++14 changed that to some extent
12:44:08 <johnw> if std::sort needs them
12:44:20 <erisco> johnw how do I tell if it needs them
12:44:22 <geekosaur> this also means pre-C++11 code and C++11-or-later code can't pass objects between each other
12:44:26 <Ralith> geekosaur: by "manages soem template-related things" did you mean "provides implementations for certain instantiations"?
12:44:36 <erisco> all I did was   gcc -O2 -c Algorithms.cpp -o Algorithms.o
12:44:45 <geekosaur> more or less. I don't know full details, C++ is hairy enough as it is
12:44:46 <erisco> and I tried -static too for a shot in the dark but no luck
12:44:57 <erisco> it gives me an Algorithms.o just fine
12:45:19 <merijn> erisco: The problem is most likely that you're not linking libstdc++ because you're letting GHC do the final linking, which knows nothing about libstdc++
12:45:25 <geekosaur> for starters, "g++" instead of "gcc". but -c means "don't link" so it didn't. you still need whichever libstdc++.so
12:45:37 <Ralith> geekosaur: treating things as black magic does tend to make them appear hairy.
12:45:45 <geekosaur> (or libc+++.dylib on a Mac)
12:45:57 <erisco> geekosaur I thought it just meant "make an object file"
12:45:59 <Ralith> however, it seems that you're attributing much more complxity to some aspects than legitimately exists
12:46:00 <erisco> I guess the article I read was dumb
12:46:11 <erisco> I don't know how any of this nonsense works lol
12:46:22 <merijn> erisco: It does, but object files don't link to libraries
12:46:23 <maerwald> I was surprised that there is no such function as "when b x = if b then x else mzero" for MonadPlus instances or did I miss it?
12:46:38 <merijn> maerwald: You mean guard?
12:46:39 <merijn> :t guard
12:46:40 <lambdabot> Alternative f => Bool -> f ()
12:46:49 <maerwald> not really
12:46:52 <erisco> merijn can I bring in the extra symbols to my Algorithms.o ?
12:46:54 <merijn> oh, I guess that's "f ()"
12:47:04 <exio4> when b x would be guard b >> x 
12:47:08 <merijn> erisco: Maybe, C++ linking isn't my strongsuit
12:47:10 <maerwald> when' :: MonadPlus m => Bool -> m a -> m a
12:47:13 <maerwald> this is what I have
12:47:42 <erisco> I'll ask on C++ but I'll probably get chewed out for not knowing what I'm talking about :P
12:47:48 <geekosaur> Ralith, as far as I know there is some link-time code generation for some template functions that only seems to happen if you use g++ as the linker. I presume this is related to template functions used in multiple objects where it doesn;t want to emit the same function statically into each object.
12:47:55 <TimoMeijer> I'm trying to setup a full Haskell project for the first time, but I can't get code coverage to work on my test files, there seem to be no hpc/tix files generated, any ideas?
12:48:19 <Ralith> geekosaur: I would recommend guessing less
12:49:22 <Denommus> hm, so HXT is a arrow-based XML parser?
12:52:08 <hodapp> one of these days, I'll realize that it's fairly common to do: instance FooClass a => Maybe (FooClass a)
12:53:53 <johnw> erisco: what was the linking question, I missed it
12:53:55 <hodapp> and likewise for various other... monads? Sure. Monads.
12:54:04 <johnw> that is one of my strong suits
12:55:47 <johnw> hodapp: isn't that instance line missing something?
12:56:10 <disgrntld> having a brainfart, if I have [[1, 2], [3, 4], [5, 6]], how can I get [[1, 3, 5], [1, 3, 6], [1, 4, 5], [1, 4, 6], [2, 3, 5], [2, 3, 6], [2, 4, 5], [2, 4, 6]]? transpose almost does what I'm looking for but I'd like every combination of elements from each list
12:56:13 <johnw> surely FooClass a isn't an instance of Maybe, AND a constraint as well
12:56:43 <ion> > sequenceA [[1, 2], [3, 4], [5, 6]]
12:56:44 <lambdabot>  [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
12:56:51 <disgrntld> sweet, thanks ion
12:57:29 <johnw> heh, my bank interprets 05/08/15 as 05/18/0015
12:57:34 <arkeet> lol
12:58:22 <dolio> johnw: First select the sum of the two things in the pair, then select the first element of the pair.
12:58:23 <ion> How does 08 -> 18 happen?
12:59:27 <erisco> well I added -lstdc++ to ghc and now it compiles
13:01:02 <erisco> why do I need to do that though
13:01:08 <erisco> why can't I get everything in Algorithms.o
13:02:13 <Peaker> What's an easy way to generate a comparison operation on lists that compares them *as though* they all had an infinite suffix like (cycle s) (this makes shorter lists be larger than some longer lists, and smaller than other longer lists)
13:02:15 <Haskellfant> don't you want a .a with everything statically linked in? afaik .o's are generated before the linking step so obviously you need to pass in the libs
13:02:48 <erisco> Haskellfant they are? okay
13:02:50 <Peaker> started with a data type like: data Infinite a = Cons a (Infinite a) | Suffix a    but this is tedious. The Eq/Ord instances are annoying
13:02:52 <erisco> how do I make a .a then
13:03:07 <erisco> all these files
13:03:11 <erisco> such a PITA
13:03:51 <Haskellfant> even .so might be enough as this will probably already link dynamically to libstdc++ so you don't need to tell ghc about it (I have no idea how to generate them, I google everytime I need this)
13:10:27 <knite> Could someone enlighten me as to what halcyon does? I'm a Haskell rookie and still learning the ins and outs of package management (cabal, sandboxes, hackage, etc).
13:10:51 <mietek> knite: hi! I’m the author of Halcyon.
13:11:11 <mietek> Consider joining #haskell-deployment; there’s less traffic there
13:11:42 <benjamingr> Hey, I have a really basic problem and I haven't done Haskell in a while - would anyone mind helping me with it?
13:11:50 <indiagreen> benjamingr: ask away
13:11:57 <knite> my day job is infrastructure/devops, so that -deployment suffix is nice. :-)
13:12:00 <ion> Halcyon, huh? Sounds useful.
13:12:12 <mietek> https://halcyon.sh
13:12:29 <ion> benjamingr: Feel free to ask without asking to ask. This is a general recommendation on the Internet.
13:12:40 <benjamingr> Yeah, I just don't like to barge, typing
13:13:08 <mietek> One of the problems I’ve encountered is, it can be difficult to install newer versions of GHC on older Linux distros
13:13:18 <mietek> Or even on newer ones
13:13:23 <mietek> Hence hvr’s Ubuntu PPA
13:13:44 <ion> mietek: Even by doing something like <https://gist.github.com/ion1/2815423>?
13:13:44 <mietek> Halcyon assumes a bare system, with git and zlib
13:13:54 <ion> Is libgmp a problem with older distros?
13:14:13 <mietek> ion: what you have here is part of what Halcyon does
13:14:42 <ion> Yeah, i figured as much. Which made me say it sounds useful. :-)
13:14:49 <mietek> Halcyon can set up a Haskell installation from scratch, on a whole lot of platforms
13:14:53 <geekosaur> libgmp is a problem, yes. and sometimes with newer ones (insert many instances of people symlinking a newer libgmp.so.N to libgmp.so.3 so ghc would work)
13:15:08 <mietek> Platforms are listed here: https://github.com/mietek/halcyon/issues/38
13:15:14 <benjamingr> Well, I'm dared to solve an easy problem, given the numbers 123456789 in that order I can add `+`  and `-` between any two numbers and I need to figure out all the combinations that generate 100. To compare - here's my attempt so far:
13:15:15 <benjamingr> https://gist.github.com/benjamingr/e898bcb4b409609f1ae8
13:15:38 <mietek> Halcyon does more than just install GHC from bindist and bootstrap cabal-install from source, though
13:15:49 <benjamingr> I remember figuring this out before, I just figured you guys would probably have a lot of valuable feedback - I've actually done Haskell before but I've never gotten any peer review
13:16:03 <mietek> Halcyon automatically caches all build products, so that they can be installed in the future by simply extracting a tarball
13:16:17 <mietek> This is done for GHC, cabal-install, your own sandboxes, and the install products of your own apps
13:16:28 <kclancy> What is the generic type class? It says that it is for "representable types of kind *". What does representable mean in this context?
13:16:33 <mietek> I provide previously-built tarballs of many versions of GHC and cabal-install in Halcyon public storage
13:16:55 <mietek> Supported versions are listed in https://halcyon.sh/reference/#halcyon_ghc_version and https://halcyon.sh/reference/#halcyon_cabal_version
13:17:15 <mietek> But if you don’t trust my tarballs, which is a fair position to have, you don’t have to
13:17:55 <mietek> You can disable public storage (https://halcyon.sh/reference/#halcyon_no_public_storage), and bootstrap your own stuff, which Halcyon will automatically cache for you in your own private storage
13:18:18 <mietek> knite: this is a lot to take in, especially for a beginner
13:18:26 <benjamingr> I've added a failing test case for the gist
13:18:29 <mietek> I’ve prepared a tutorial which attempts to walk you through all of the steps: https://halcyon.sh/tutorial/
13:18:36 <kclancy> Maybe I just need to read the GHC.Generics page from the top. I will try that. 
13:18:43 <mietek> You might also find this useful: https://robots.thoughtbot.com/building-haskell-projects-with-halcyon
13:18:49 <knite> oh, you're replying here, not in the -deployment channel! :-)
13:19:05 <ion> mietek: Does Halcyon verify the public storage files cryptographically?
13:20:03 <mietek> ion: not yet. This is something I’d like to do, but there’s little point in doing it now, since cabal-install doesn’t support SSL
13:20:14 <exio4> is there any standard "strict list" package? 
13:20:55 <mietek> ion: so, if you don’t trust public storage, you don’t need to use it, but you still need to trust that cabal-install won’t get MITM-ed on its way to Hackage
13:21:19 <ion> mietek: alright
13:22:35 <mietek> There’s also a couple more fun things
13:22:46 <mietek> ion: do you recognise the missing alex/happy problem?
13:22:53 <ion> mietek: yeah
13:23:09 <benzrf> :t many
13:23:10 <lambdabot> Alternative f => f a -> f [a]
13:23:13 <benzrf> hmm
13:23:13 <ion> I haven’t studied *why* they can’t just be build-dependencies, but i assume there’s a reason for that.
13:23:16 <benzrf> :t repeatM
13:23:17 <lambdabot>     Not in scope: ‘repeatM’
13:23:17 <lambdabot>     Perhaps you meant one of these:
13:23:17 <lambdabot>       ‘repeat’ (imported from Data.List),
13:23:20 <mietek> ion: bam; https://halcyon.sh/reference/#halcyon_sandbox_extra_apps
13:23:20 <benzrf> mfw no repeatM
13:23:51 <benzrf> :t randR
13:23:52 <lambdabot> Not in scope: ‘randR’
13:23:54 <benzrf> :t randomR
13:23:55 <mietek> ion: just declare you want them, and Halcyon will call itself recursively to install them for you, into your app’s sandbox
13:23:55 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
13:24:06 <ion> mietek: Alright, nice.
13:24:17 <mietek> ion: and you can declare more stuff like this, including OS libs
13:24:36 <mietek> ion: https://halcyon.sh/examples/#haskell-language is a pretty good example
13:26:11 <mietek> ion: if you want to learn more, join #haskell-deployment, and let’s chat there
13:26:12 <benjamingr> Anyone :(?
13:26:25 <benzrf> is there a nice utility like
13:26:35 <benzrf> @hoogle (a -> a) -> Bool -> a -> a
13:26:35 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
13:26:37 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
13:26:39 <lambdabot> Data.Generics.Aliases mkQ :: (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
13:26:46 <ion> mietek: I’m hesitant to join more channels but i’ll be sure to read Halcyon’s documentation.
13:26:47 <arkeet> benzrf: what do you want that to do?
13:26:56 <benzrf> possibly apply a funciton
13:26:57 <benzrf> *function
13:27:09 <mietek> ion: sure; there’s just too much traffic here for me to follow
13:27:12 <arkeet> :t \f b -> if b then f else id
13:27:13 <lambdabot> (a -> a) -> Bool -> a -> a
13:27:25 <benzrf> arkeet: well, yeah
13:27:33 <arkeet> @let bool f _ False = f; bool _ t True = t
13:27:35 <lambdabot>  Defined.
13:27:35 <benzrf> im wondering if it's in prelude or anything >.>
13:27:39 <mietek> ion: I’ll be happy to answer any questions
13:27:40 <arkeet> :t bool id
13:27:41 <lambdabot>     Ambiguous occurrence ‘bool’
13:27:42 <lambdabot>     It could refer to either ‘L.bool’,
13:27:42 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:152:1
13:27:44 <arkeet> uh.
13:27:45 <arkeet> @undefine
13:27:46 <lambdabot> Undefined.
13:27:46 <benzrf> haha
13:27:46 <arkeet> :t bool
13:27:47 <lambdabot> a -> a -> Bool -> a
13:27:50 <benzrf> i know, arkeet
13:27:54 <arkeet> :t bool id
13:27:55 <lambdabot> (a -> a) -> Bool -> a -> a
13:28:15 <ion> mietek: Alright :-)
13:28:23 <arkeet> > (bool id False (+1) 0, bool id True (+1) 0)
13:28:24 <lambdabot>      Couldn't match expected type ‘t -> t’ with actual type ‘Bool’
13:28:24 <lambdabot>      In the second argument of ‘bool’, namely ‘False’
13:28:24 <lambdabot>      In the expression: bool id False (+ 1) 0    Couldn't match expected type...
13:28:50 <arkeet> oh duh.
13:29:43 <indiagreen> benjamingr: it's kinda hard because e.g. I don't know how to fix Concat with your approach
13:30:01 <indiagreen> for instance, try «solve 0 "1111"» – it won't find “11−11”
13:30:55 <benjamingr> Right, it doesn't build the trees correctly.
13:31:47 <indiagreen> no, it doesn't evaluate correctly either
13:31:53 <benjamingr> JS version does, but that's not fair since JS version "eval"s 
13:31:58 <byorgey> @tell Aruro yes, diagrams is included in stackage
13:31:58 <lambdabot> Consider it noted.
13:32:21 <indiagreen> for instance, take “eval (Concat (Leaf 1) (Add (Leaf 1) (Leaf 11))” – is it supposed to work / can this tree be generated?
13:32:54 <indiagreen> for me, this tree doesn't make sense, and I think it'd be easier to just remove Concat altogether
13:33:51 <indiagreen> another tree that doesn't make sense is (Sub (Leaf 1) (Add (Leaf 1) (Leaf 1))), because you don't have parens in your model
13:35:00 <indiagreen> the right model for what you want isn't a tree, but a chain: “data Exp = Add Exp Int | Sub Exp Int | Leaf Int” (at least as long as you don't have div, mul, etc)
13:36:39 <athan> If, in the resulting function of traverse :: Applicative f => (a -> f b) -> t a -> f (t b) - if `t` was actually the Identity type, then you've created a Monad?
13:36:56 <athan> er wait
13:36:57 <athan> derp
13:36:58 <athan> sorry
13:37:00 <athan> nevermind
13:37:09 <arkeet> no, you get id
13:37:13 <athan> ><
13:37:29 <arkeet> if you pick f to be Identity then you get fmap
13:37:43 <arkeet> :t \f -> traverse (Identity . f)
13:37:44 <lambdabot> Traversable t => (a -> b) -> t a -> Identity (t b)
13:37:51 <athan> hmm!
13:37:54 <arkeet> :t \f -> runIdentity . traverse (Identity . f)
13:37:55 <lambdabot> Traversable t => (a -> b) -> t a -> t b
13:38:16 <athan> that's really interesting
13:38:29 <arkeet> :t \f -> getConst . traverse (Const . f)
13:38:30 <lambdabot> (Traversable t, Monoid c) => (a -> c) -> t a -> c
13:38:34 <arkeet> :t foldMap
13:38:35 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
13:38:48 <arkeet> that's why any Traversable is also a Functor and Foldable.
13:39:00 <athan> !
13:39:05 <arkeet> in fact
13:39:08 <arkeet> :t foldMapDefault
13:39:09 <lambdabot>     Not in scope: ‘foldMapDefault’
13:39:09 <lambdabot>     Perhaps you meant one of these:
13:39:09 <lambdabot>       ‘T.foldMapDefault’ (imported from Data.Traversable),
13:39:15 <arkeet> :t T.foldMapDefault
13:39:16 <lambdabot> (Traversable t, Monoid m) => (a -> m) -> t a -> m
13:39:18 <arkeet> :t T.fmapDefault
13:39:18 <lambdabot> Traversable t => (a -> b) -> t a -> t b
13:39:35 <athan> What would you call `const`, mathematically?
13:39:40 <athan> Const*
13:39:48 <arkeet> Const a b ~ a
13:39:48 <athan> wow
13:39:58 <athan> Ahh!
13:40:05 <arkeet> or rather
13:40:09 <arkeet> newtype Const a b = Const a
13:40:57 <arkeet> and we have
13:41:05 <arkeet> instance Monoid r => Applicative (Const r)
13:41:17 <arkeet> (exercise: implement it)
13:41:48 <arkeet> and that's why it can be used with traverse
13:42:30 <athan> hmm
13:42:58 <athan> thanks arkeet!!
13:43:26 <dgpratt> anyone else here do this and have success with it? http://wiki.ocharles.org.uk/Nix
13:44:17 <athan> In the idea I posted on reddit, I'm deconstructing monoids (really (abelian) groups) into a foldable (and maybe traversable). Is that why we have the monoid homomorphism for foldables?
13:44:54 <athan> or related to it?
13:45:27 <erisco> so what is the difference between unboxed vectors and storable vectors?
13:46:22 <c_wraith> Storable is for the FFI
13:46:48 <c_wraith> Storable vectors can be marshalled as C arrays easily
13:46:57 <erisco> my question is still the same... I'll add the question what is the difference in memory layout?
13:47:36 <Welkin> ocharles has his own wiki?
13:47:37 <benjamingr> well, I'll think about it more, thanks indiagreen 
13:47:44 <benjamingr> any style comments about my Haskell?
13:47:53 <Welkin> I never knew there was so much to know about him!
13:47:54 <indiagreen> benjamingr: I'm actually writing a simpler version for you now
13:48:04 <indiagreen> well, and also rather different
13:48:11 <indiagreen> so hang on a bit
13:48:23 <benjamingr> well, that'd give me a good perspective, I might have to go but I'll leave my computer on so ping me
13:48:47 <erisco> or maybe the question: why choose an unboxed vector rather than a storable one?
13:49:26 <Welkin> can you not make an unboxed vector storable?
13:51:27 <dolio> Unboxed vectors are structure of arrays. Storable arrays are array of structures.
13:55:05 <ReinH> dgpratt: presumably ocharles_ does... ;)
13:56:41 <SafeMoneyOnl> 4,1 Win 20.000-30.000 Euro Per year (1700-2500 Euro per month) With 1 H per day for 365 days. At start you will earn little money but with time your starting to learn much more at start you can win 0.5 euro per day first week and after a month you will earn 10-20 euro per day Its Verry simple just Make an account on my link and i will train you and i will be your guide as much you need Sign 
13:56:41 <SafeMoneyOnl> 4,1Up here And good Luck 9,1 -----> http://www.marketglory.com/strategygame/lolopoco
13:56:55 <ReinH> @where ops
13:56:55 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
13:57:00 <dgpratt> ReinH, presumably, but maybe he's a really clever troll ;)
13:57:07 <ReinH> dgpratt: :)
13:57:13 --- mode: ChanServ set +o geekosaur
13:57:17 <benjamingr> I'm buying the first person to find an xss or csrf at SafeMoneyOnl 's site a beer.
13:57:23 --- mode: geekosaur set +b *!SafeMoneyO@5-12-129-251.residential.rdsnet.ro
13:57:23 --- kick: SafeMoneyOnl was kicked by geekosaur (Your behavior is not conducive to the desired environment.)
13:57:30 <ReinH> geekosaur: ty
13:57:51 <benjamingr> wait nvm, it's trivial they're running old version with vulnerabilities of php
13:58:08 <indiagreen> benjamingr: http://lpaste.net/132240
13:59:41 <benjamingr> Awesome, I'll read it, thanks :)
14:00:16 * hackagebot unbound-generics 0.1.2 - Support for programming with names and binders using GHC Generics  http://hackage.haskell.org/package/unbound-generics-0.1.2 (AlekseyKliger)
14:01:37 <Peaker> Are there SnocLists somewhere?  I just want a type-level tag that my list semantics are reversed
14:01:42 <indiagreen> benjamingr: updated the paste
14:02:14 <Peaker> I keep on doing the prefixing->later reversing   pattern, but it's not nice not to have the "reversed" nature of the list in the types
14:02:27 <Peaker> s/prefixing/prepending
14:03:37 <athan> Holy crap, you can build a deeper (lens?) for `fmap`, just by using `Compose`?
14:04:20 <f|`-`|f> So Monoids are not really Monoids
14:04:22 <f|`-`|f> huh
14:04:31 <athan> ?:?
14:04:59 <ReinH> f|`-`|f: how so?
14:05:02 <f|`-`|f> as far as I know, accessing the a in an [[a]] needs and `fmap . fmap`
14:05:17 <MP2E> what does that have to do with Monoids?
14:05:23 <f|`-`|f> athan said something about  "I'm deconstructing monoids (really (abelian) groups) "
14:05:36 <MP2E> hmm
14:05:37 <ReinH> So how are Monoids not really Monoids?
14:05:58 * f|`-`|f shrugs
14:06:05 <MP2E> abelian groups are monoids
14:06:12 <f|`-`|f> oh
14:06:16 <MP2E> they just have more laws associated with them as well
14:06:18 <Denommus> HXT is very interesting
14:06:26 <Denommus> it's a shame I don't have the time to explore it properly
14:07:14 <athan> If homomorpsisms preserve structure, would that mean that endomorphisms preserve them at an atomic sense? :|
14:07:18 <athan> or is that just a function?
14:07:22 <athan> (from a type to itself?)
14:07:29 <athan> Denommus: The arrow stuff is great
14:07:39 <athan> but it's hard to follow at first
14:07:56 <athan> Also, it's not very good for building HTML, last time I used it, it was buggy
14:08:00 <athan> (kinda)
14:08:23 <athan> f|`-`|f: Yeah abelian groups are commutative, "cancelling" monoids
14:08:35 <athan> @hackage monoid-subclasses
14:08:35 <lambdabot> http://hackage.haskell.org/package/monoid-subclasses
14:08:40 <athan> @hackage groups
14:08:40 <lambdabot> http://hackage.haskell.org/package/groups
14:16:04 --- mode: geekosaur set -o geekosaur
14:23:35 <ReinH> a group is a monoid with inverses, an abelian group is just a commutative group
14:23:56 <ReinH> Which we call "abelian" rather than "commutative" for hysterical raisins
14:24:44 <ReinH> athan: an endomorphism is a homomorphism from an object to itself
14:25:03 <athan> ReinH: Ahh! Okay, thank you!
14:25:22 <ReinH> athan: :)
14:25:29 <athan> so data constructors would be the bound of the structure preservation? ie: the "atomic" sense?
14:25:39 <ReinH> athan: I mention this because "cancelling" is not the same thing as an inverse property.
14:25:52 <athan> :o
14:26:04 <athan> :x
14:26:08 <athan> crap...
14:26:19 <athan> sorry f|`-`|f ._.
14:26:25 * athan runs away
14:26:32 <f|`-`|f> I'm not sorry athl
14:26:35 <f|`-`|f> Atha
14:26:39 <f|`-`|f> athan  
14:26:45 <athan> lol
14:26:46 <f|`-`|f> take responsiblity, senpai
14:26:50 <ReinH> an element x is "left cancelling" if  for all y. x <> y = x
14:27:11 <ReinH> This is also known as "absorbing"
14:27:26 <athan> f|`-`|f:      >|-D:
14:27:29 <ReinH> This is talked about a bit at http://en.wikipedia.org/wiki/Null_semigroup
14:27:46 * f|`-`|f >|-D:
14:27:50 <athan> ahh shoot okay
14:27:58 <f|`-`|f> I will never not enjoy doing that with my nick
14:28:34 <ReinH> Examples of endomorphisms include permutations of sets
14:28:53 <athan> ReinH: Would a left-cancellative monoid be something like First for Maybe?
14:29:17 <ReinH> > First (Just ()) <> Nothing
14:29:19 <lambdabot>      Couldn't match expected type ‘First ()’ with actual type ‘Maybe a0’
14:29:19 <lambdabot>      In the second argument of ‘(<>)’, namely ‘Nothing’
14:29:19 <lambdabot>      In the expression: First (Just ()) <> Nothing
14:29:29 <ReinH> > First (Just ()) <> First Nothing
14:29:31 <lambdabot>  First {getFirst = Just ()}
14:29:35 <ReinH> Indeed :)
14:30:00 <ion> > Sum 0 <> Sum x
14:30:01 <ReinH> Well, there's a problem with terminology here.
14:30:02 <lambdabot>  Sum {getSum = 0 + x}
14:30:07 <ion> uh, i mean
14:30:11 <ion> > Product 0 <> Product x
14:30:12 <lambdabot>  Product {getProduct = 0 * x}
14:30:28 <ReinH> We have "null semigroup", "zero semigroup", and "nil semigroup", and none of those are the right term for a semigroup with some absorbing elements
14:30:51 <athan> wow
14:30:53 <ReinH> I don't think "left-cancellative semigroup" is an accepted term but I also don't think it would confuse people too much
14:30:59 <ion> Insert the Hitler rant about clopen sets
14:31:09 <ReinH> ion: sets are not doors :)
14:31:21 <ReinH> ion: petition to rename "clopen" to "ajar"
14:31:23 <athan> !O_O
14:31:55 <athan> ReinH: Do you have a favorite paper or something, explaining this stuff? :)
14:32:01 <ReinH> athan: no :D
14:32:10 <ReinH> athan: but the various wikipedia articles do a reasonable job
14:32:12 <athan> :D
14:32:16 <ReinH> http://en.wikipedia.org/wiki/Absorbing_element
14:32:19 <athan> cool, sorry :)
14:32:29 <ReinH> no problem :)
14:33:22 <ReinH> athan: A "left-zero semigroup" is a semigroup in which *every* element is a left-cancellative/left-absorbing/left-zero
14:33:44 <ReinH> so I guess the risk is that "left-cancellative" might be interpreted in the same way
14:34:01 <ReinH> Anyway, you can also say that First (Just x) is left-cancellative for all x
14:34:21 <ion> Just x in Alternative
14:34:22 <athan> hmm, okay, thank you ReinH
14:34:29 <ReinH> ion: also that
14:34:37 <ReinH> athan: np :)
14:39:18 <athan> @tell nshepperd http://hackage.haskell.org/package/monoid-subclasses-0.4.0.4/docs/Data-Monoid-Cancellative.html#t:LeftReductiveMonoid
14:39:18 <lambdabot> Consider it noted.
14:45:11 <ReinH> athan: Well, that package uses "cancellative" to mean inverse, but in the maths literature I've only ever seen it as a synonym for absorbtive. :/
14:45:33 <ReinH> athan: Wait, no, even that's not right.
14:45:36 <athan> ReinH: I'm not complaining!! :)
14:45:38 <ReinH> cancellative means something else!
14:45:40 <ReinH> http://en.wikipedia.org/wiki/Cancellative_semigroup
14:45:42 <athan> :o
14:45:48 <ReinH> Sorry!
14:45:54 <ReinH> It's hard to keep all these things straight :/
14:46:09 <ReinH> cancellative means that a <> b = a <> c => b = c
14:46:36 <ReinH> so one can "cancel" the a element and deduce that b = c
14:46:40 <athan> !!!
14:46:44 <ReinH> so sorry :(
14:46:53 <athan> :)
14:47:49 <ReinH> so positive integers under addition and multiplication are cancellative semigroups
14:47:58 <athan> ReinH: So prime number multiplication is a cancellative groupoid(?)
14:48:07 <athan> or something? wait
14:48:09 <athan> ?
14:48:31 <athan> abelian monoid? o_o
14:48:52 <ReinH> Well, all integer multiplication is can cancellative:  x * y = x * z => y = z
14:49:05 <ReinH> er, no
14:49:10 <ReinH> because zero
14:49:33 <athan> addition over the nats?
14:49:50 <ReinH> so all positive integers, or Z \ {0}
14:49:54 <ReinH> yes
14:49:57 <athan> er
14:50:14 <ReinH> because 0 is absorbtive for multiplication
14:50:25 <ReinH> so 0 * x = 0 * y does not imply x = y
14:50:26 <athan> ahh!!!
14:50:47 <ReinH> ok now we're getting somewhere...
14:52:20 <Denommus> I wish there was an Emacs mode to query the type of a local term
14:53:29 <merijn> Denommus: Do you have error/warning highlighting?
14:53:30 <ReinH> Denommus: there is though
14:53:45 <ReinH> haskell-doc-mode
14:54:21 <ReinH> It will display types of identifiers under the point in the minibuffer
14:55:48 <lokathor> so i've got several dice (6, 8, and 12 sided) that each have 0, 1 or 2 symbols per side. I want to simulate the rolling of collections of these dice
14:56:06 <lokathor> I've started with a DiceSymbol enum data type for all the possible symbols
14:57:05 <lokathor> and i'm using a State StdGen [DiceSymbol] to maintain the RNG while rolling
14:57:46 <Denommus> how do I retrieve the name of a Cursor?
14:57:51 <Denommus> in xml-conduit, that is
14:57:55 <lokathor> this gets me a [DiceSymbol], which gets tallied up into a Map DiceSymbol Int
14:58:09 <lokathor> does this all sound like the right way to go about things?
14:59:31 <ReinH> lokathor: "0,1, or 2 symbols per side"?
14:59:47 <lokathor> yes, some sides are blank, some have one symbol, and some have two symbols paired up
15:00:14 <lokathor> so i think reprisenting each side as a [DiceSymbol] is best?
15:01:10 <lokathor> then i get a random int (1-6, 1-8, or 1-12) reprisenting a dice roll, and then have a lookup function for each type of die that turns that number into the right symbols.
15:01:26 <ReinH> Yes, although a Map seems like overkill
15:01:50 <ReinH> unless you want to configure the dice dynamically at runtime
15:01:56 <ReinH> change what's on what sides, etc
15:02:01 <lokathor> well, once i've got the list of all symbols rolled in a single throw of the dice, some of the symbols cancel out with each other
15:02:07 <lokathor> so i need to tally up the net symbols
15:02:18 <athan> @tell nshepperd http://hackage.haskell.org/package/monoid-subclasses-0.4.0.4/docs/Data-Monoid-Factorial.html#v:foldr
15:02:18 <lambdabot> Consider it noted.
15:03:42 <athan> Holy crap: http://hackage.haskell.org/package/monoid-subclasses-0.4.0.4/docs/Data-Monoid-Textual.html
15:03:47 <athan> generic text stuff!
15:04:11 <athan> Now we can make string manipulation stuff extremely genericly!!
15:04:33 <athan> or really, just generic enough so we don't have to explicitly coerce everything (pretty sure!)
15:04:53 <lokathor> do you mean Text manipulation? :3
15:05:56 <athan> yes!!
15:06:04 <ion> athan: There is also https://hackage.haskell.org/package/mono-traversable
15:06:48 <johnw> td;
15:07:38 <athan> ion: !!! wow
15:07:42 <athan> how did I miss this?
15:08:20 <arkeet> mono-traversable is cool if you want to avoid lens.
15:08:21 <arkeet> :-)
15:08:25 <k0ral> Hello
15:09:22 <athan> ahh wow
15:09:44 <paxcoder> lyah calls `Maybe a` a concrete type. By that logic, only partially applied constructors are not concrete. Do you agree with this?
15:10:10 <k0ral> how would you implement a partially constructed data type, without using Maybe on all its "attributes" (which is semantically wrong since in the end, the data type demands that some of them are filled) ?
15:10:11 <arkeet> by what logic?
15:10:18 * hackagebot dynamic-state 0.2.0.0 - Optionally serializable dynamic state keyed by type  http://hackage.haskell.org/package/dynamic-state-0.2.0.0 (DmitryIvanov)
15:10:40 <arkeet> to me a "concrete type" is a type that can have values, i.e. a type of kind *
15:10:59 <lokathor> > :k Maybe a
15:11:00 <lambdabot>  <hint>:1:1: parse error on input ‘:’
15:11:05 <lokathor> :k Maybe a
15:11:06 <lambdabot> Not in scope: type variable ‘a’
15:11:08 <arkeet> :k Maybe Int
15:11:09 <lambdabot> *
15:11:18 <lokathor> well that settles that argument
15:11:29 <paxcoder> arkeet, by calling fully applied constructors concrete, even if type variables are involved
15:11:30 <lokathor> Maybe a is still "generic" and Maybe Int is "concrete"
15:11:57 <arkeet> so the question is whether you should consider polymorphic types to be "concrete"
15:11:59 <paxcoder> lokathor, that's how i'd normally understand the word, yes
15:12:26 <lokathor> paxcoder, i'm inclined to agree with arkeet on this one. You can't have a value of type Maybe a, only values that conform to the limits of Maybe a
15:12:27 <paxcoder> arkeet, yes, and if so, what isn't?
15:12:37 <arkeet> ?
15:12:49 <paxcoder> arkeet, do you have a question?
15:13:05 <arkeet> I thought you had a question.
15:13:10 <paxcoder> I do.
15:14:40 <lokathor> well the answer to your question is
15:14:46 <lokathor> "no I don't agree with LYAH"
15:15:35 <arkeet> why not?
15:16:00 <lokathor> me?
15:16:05 <arkeet> yes
15:16:08 <paxcoder> arkeet, there should be a word for what you're doing
15:16:15 <arkeet> what am I doing?
15:16:19 <paxcoder> that
15:16:22 <arkeet> ??
15:16:27 <lokathor> there is, it's "the socratic method"
15:16:28 <paxcoder> and that
15:16:31 <_6a68> hi, does anyone have a recommendation for a nice, compact haskell introduction for someone with a reasonable undergrad math background and a lot of programming experience?
15:16:37 <paxcoder> lokathor, that's not it
15:16:38 <lokathor> but we don't use methods in haskell! only pure functions! *zing*
15:17:05 <paxcoder> even #C is closer to socratic questioning than arkeet
15:17:30 <lokathor> _6a68, http://www.seas.upenn.edu/~cis194/spring13/lectures.html is a good intro with homework assignments and such, and the bulk of the reading it directs you to do is in the Learn You A Haskell book (free online)
15:17:38 <ion> _6a68: People have liked https://github.com/bitemyapp/learnhaskell
15:18:08 <arkeet> I'm asking questions because I don't know the answers.
15:18:42 <lokathor> well, arkeet, the question posed was "LYAH calls 'Maybe a' a concrete type, do you agree with this?"
15:18:48 <_6a68> lokathor | ion: thanks for the refs, I was hoping for something a little more compact than 'learn you a haskell'. Not a fan of the conversational style
15:18:52 <lokathor> and I don't agree with it, i would say that it's a generic type
15:19:03 <arkeet> I would agree with it, based on what I think "concrete type" means.
15:19:05 <_6a68> I've noticed 'Real World Haskell', an O'Reilly book. Any thoughts there?
15:19:19 <arkeet> but I thought the question was "By that logic, only partially applied constructors are not concrete. Do you agree with this?"
15:19:32 <lokathor> Real World Haskell is alright, be sure you don't ever delve into the user comments though because they often apply to old versions
15:19:50 <lokathor> also some of the libraries it tries to introduce have changed around since it was written
15:19:57 <arkeet> _6a68: that learnhaskell page lists a bunch of resources (including rwh, I think)
15:20:06 <arkeet> along with a brief summary of each
15:20:40 <_6a68> great, thanks folks! I'll go dig through some links
15:20:54 <arkeet> and it has a recommended course (cis194, followed by NICTA)
15:21:29 <lokathor> yes, though cis194 is very incomplete if you don't read the LYAH chapters it tells you to do
15:21:50 <paxcoder> arkeet, some of those don't need to be asked to be answered (just make an effort to understand). Others are not even questions. Anyway, what's your definition of a concrete type? And what is the opposite of one?
15:21:50 <_6a68> I guess I'm looking for a more mathematical, compact exposition. I'm unafraid of category theory, FWIW
15:22:08 <arkeet> paxcoder: "concrete type" is, as far as I know, not standard terminology.
15:22:30 <paxcoder> What is standard terminology?
15:22:34 <arkeet> I don't know.
15:22:56 <lokathor> _6a68, You could just... read the haskell98 report? I don't know, usually people don't want a *more* dense version of things
15:23:04 <paxcoder> This doesn't answer the question..
15:23:12 <ReinH> _6a68: Thinking Functionally with Haskell by Richard Bird is new, reasonably priced on the Kindle and is the best book about functional programming I have read since his previous book about functional programming
15:23:47 <ReinH> _6a68: it moves at a pace you will probably appreciate once you get out of the first few introductory chapters
15:23:48 <lokathor> paxcoder, I would say that a concrete type is a type that can have actual concrete values that you can write down (or type out) and stuff
15:23:51 <_6a68> lokathor | ReinH: cool, thanks
15:24:08 <arkeet> that's what I suggested.
15:24:19 <lokathor> yep
15:24:21 <ReinH> _6a68: the final chapters implement a proof generator for equational reasoning w/ haskell expressions
15:24:23 <arkeet> "to me a "concrete type" is a type that can have values, i.e. a type of kind *"
15:24:31 <ReinH> it's pretty great
15:24:40 <_6a68> ReinH: awesome, that's exciting!
15:24:42 <arkeet> types with quantifiers (e.g. forall a. Maybe a) can still be concrete.
15:24:45 <arkeet> :t Nothing
15:24:46 <lambdabot> Maybe a
15:24:50 <ReinH> _6a68: you might also appreciate his "Pearls of Functional Algorithm Design", which won't waste any time on introductory material at all
15:25:13 <ReinH> arkeet: also known confusingly as "a type of kind type"
15:25:26 <arkeet> :k forall a. Maybe a
15:25:27 <lambdabot> *
15:25:33 <paxcoder> arkeet, but then you would *not* agree with LYAH (au contraire to what you've said)
15:25:45 <arkeet> what, exactly, is LYAH saying?
15:25:47 <paxcoder> Basically, we all agree that we disagree with LYAH
15:25:59 <ReinH> _6a68: after that, I recommend Simon Marlow's Parallel and Concurrent Programming with Haskell
15:26:11 <lokathor> LYAH isn't for sure right about everything, it's just for sure sarcastic about everything.
15:26:15 <arkeet> I thought you just said it calls "Maybe a" a concrete typue.
15:26:20 <paxcoder> arkeet, "While Maybe isn't a concrete type, Maybe m is"
15:26:27 <ReinH> _6a68: which is available for free online
15:26:28 <arkeet> I agree with that.
15:26:40 <paxcoder> arkeet, but there is no value of type Maybe m.
15:26:45 <arkeet> :t Nothing :: Maybe m
15:26:46 <lambdabot> Maybe m
15:26:48 <arkeet> there's a value of type Maybe m.
15:26:59 <lokathor> you've got me there
15:27:00 <paxcoder> pffft
15:27:12 <juanpablo_> Anybody knows the name of this pattern? http://lpaste.net/132244. Quite convenient when working with "Maybe returning functions and patterns
15:27:14 <lokathor> :t Nothing
15:27:16 <lambdabot> Maybe a
15:27:16 <juanpablo_> parsers*
15:27:36 <_6a68> ReinH: Thinking Functionally looks great, thanks for the references
15:27:45 <ReinH> _6a68: yep
15:28:05 <ReinH> _6a68: I have some short reviews of other Haskell books as well http://reinh.com/notes/posts/2014-07-25-recommended-reading-material.html
15:28:21 <ReinH> "Introduction to Functional Programming using Haskell" is the previous Bird book I mentioned
15:28:28 <ReinH> but it is superceded by Thinking Functionally
15:28:33 <arkeet> _6a68: this article lists a bunch of learning materials and points out strengths and weaknesses of each http://bitemyapp.com/posts/2014-12-31-functional-education.html
15:28:49 <paxcoder> Let's all throw as many links as possible at _6a68, that will help.
15:28:54 <ReinH> I actually need to update my list to include Thinking Functionaly
15:29:00 <lokathor> it will actually
15:29:03 <Denommus> ok, I found out how to retrieve the name of a cursor, but now I need to take a document that is inside some CDATA
15:29:05 <ReinH> paxcoder: Good idea, thanks
15:29:10 <Denommus> I have no idea what to do or what to look for
15:29:48 <paxcoder> _6a68, here: https://www.edx.org/course/introduction-functional-programming-delftx-fp101x a course by that colorful nordic dude
15:29:51 <_6a68> ReinH: awesome! FWIW I'm not a fan of Lang's textbooks in general; Dummit and Foote is a friendlier reference ^_^
15:30:18 <ReinH> _6a68: Lang is more of a bestiary than a textbook
15:30:20 <_6a68> arkeet | paxcoder: thanks for the refs, now I've got a really nice list to skim through over the weekend :-D
15:30:30 <arkeet> Lang :-)
15:30:31 <acowley> Does anyone know if kind synonyms are happening?
15:30:51 <_6a68> ReinH: haha, yeah, that Bourbaki thing
15:30:53 <ReinH> _6a68: have you read Awodey and Birkhoff's Algebra?
15:31:13 <ReinH> I really like the presentation, especially as it also warms you up for CftWM
15:31:16 <_6a68> I don't think so, I read Birkhoff and Mac Lane years ago
15:31:43 <ReinH> You get used to Mac Lane's way of presenting things, although to be fair I think most of the book was written by Birkhoff.
15:32:00 <ReinH> And CftWM is a tall hill to climb, so any warmup is useful...
15:34:45 <ReinH> Why is a compendium of beasts called a bestiary and not a beastiary :(
15:42:22 <maerwald> ReinH: it saves you one char
15:46:18 <lokathor> so i have several State StdGen [DiceSymbol] functions, and i want to encode the dice to roll as a String, one character per die.
15:46:49 <lokathor> if a bad character is in the string, it should "throw an exception" to use java terms. Is this what the 'fail' part of a monad is for?
15:47:23 <_6a68> lol, ReinH it's derived from Latin bestia
15:47:49 <lokathor> or, i guess, this is what the Either type is all about perhaps
15:49:39 <SrPx> Can I convert a traversal to a lens?
15:50:45 <ion> lokathor: What is DiceSymbol? What kinds of rolls can result in bad characters?
15:51:31 <SrPx> nvm
15:51:38 <erisco> I guess knowledge of the difference between storable and unbox has been lost
15:51:43 <ion> SrPx: “pre” perhaps.
15:51:59 <lokathor> for example, if the acceptable dice are one of 'r', 'g', or 'b', but the string given is "rrh", then the 'h' is invalid input
15:53:01 <lokathor> DiceSymbol is just an enum of the possible symbols that can come up on any of the possible dice (Hit, Miss, Advantage, etc)
15:54:56 <ion> lokathor: You may want something like f :: Char -> Maybe F (for some F that you want to get out) and you get traverse f "rrh" :: Maybe [F]
15:56:32 <lokathor> and then i get out the [F] and use sequence on that?
15:56:33 <lokathor> hmm
15:56:43 <lokathor> seems solid
15:56:46 <ion> lokathor: or f :: Char -> Either E F where E is an error message type such as String.
15:57:20 <lokathor> and the Either will be an error if there's any error at all when you use traverse on the thing?
15:57:34 <ion> yeah
15:57:39 <Denommus> hm
15:57:43 <lokathor> that sounds good
15:57:52 <Denommus> how do I convert from Data.Text.Text to Data.Text.Lazy.Text?
15:57:54 <lokathor> I have to go to a thing, but I'll get back to this later
15:58:26 <ion> Denommus: Data.Text.Lazy.fromStrict
16:11:52 <lpaste> TimWolla pasted “No title” at http://lpaste.net/6060575321424396288
16:12:29 <TimWolla> Is it possible to write the callback of the foldM more concise in that paste? 
16:12:51 <TimWolla> I am especially annoyed by the Nothing -> return Nothing in there.
16:13:49 <dmj`> TimWolla: could use a MaybeT
16:14:22 <TimWolla> dmj`, I'll take a look. Thanks.
16:14:31 <arkeet> yep looks like a case for MaybeT
16:15:12 <lpaste> glguy annotated “No title” with “No title (annotation)” at http://lpaste.net/6060575321424396288#a132247
16:15:31 <glguy> TimWolla: You could do that or something like it
16:15:31 <arkeet> idk
16:15:47 <arkeet> oh yeah, just a Maybe
16:21:52 <dmwit> :t traverse
16:21:53 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
16:22:05 <glguy> Using MaybeT would allow the foldM to exit earlier, however
16:22:25 <dmwit> `case x of Nothing -> return Nothing; Just v -> f v` ~= `traverse f x`
16:24:01 <dmwit> traverse (\fs -> traverse (\entryHash -> readFS ...) (liftM entryId ...)) carry
16:25:08 <glguy> using the traverse or sequence inside the foldM means that it can't tell that you aren't eventually going to replace the Nothing with a Just and make some more progress
16:25:38 <dmwit> right
16:26:58 <dmwit> Is there a flipped version of traverse?
16:27:00 <dmwit> ?hoogle (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
16:27:01 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
16:27:01 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
16:27:01 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
16:27:05 <glguy> for
16:27:08 <dmwit> neat
16:28:58 <fread2281> if I writeIORef then putMVar, will another thread doing readMVar happen after the writeIORef?
16:30:28 <dmwit> I do not believe that's a guarantee.
16:30:59 <dmwit> The docs have this to say: "MVar operations are always observed to take place in the order they are written in the program, regardless of the memory model of the underlying machine. This is in contrast to IORef operations which may appear out-of-order to another thread in some cases.".
16:31:04 <dmwit> (And not much else.)
16:32:35 <fread2281> what about atomicWriteIORef?
16:33:07 <glguy> You can just read what dmwit's reading: http://hackage.haskell.org/package/base-4.8.0.0/docs/Data-IORef.html
16:34:08 <dmwit> atomicModifyIORef's documentation explicitly calls out the fact that it does *not* help with synchronizing two different references.
16:34:12 <fread2281> yep, but I can't find any mention if atomicModifyIORef respects MVar operations
16:35:19 <dmwit> (...so I do not believe atomicWriteIORef will help you. Just use an MVar.)
16:36:13 <fread2281> MVars can be empty though, I'm using stm but don't need that much safety
16:36:42 <arkeet> mvars don't *have* to be empty
16:37:12 <fread2281> sure, but I need to handle that case
16:37:18 <dmwit> I'm not sure what "don't need that much safety" means.
16:38:44 <acowley> Too much safety can mess up your hair.
16:39:33 <oconnore> fread2281: you could compile some code to asm and see what sort of primitives the underlying implementation is using
16:40:13 <oconnore> fread2281: also do that for every compiler/os you might run on
16:41:33 <fread2281> all my stm blocks are one operation, and I have loops that do a bunch of stm blocks
16:42:40 <dmwit> I really don't understand this. You are *already* proposing a solution which involves taking and putting values from an MVar. So why would using an MVar for your data be a problem?
16:43:36 <dmwit> Like, why use an MVar for synchronization and an IORef for data when you can just use an MVar for both synchronizing and data at the same time?
16:44:59 <fread2281> mvars can be empty, I still need multiple ones and would be using readMVar
16:45:21 * hackagebot api-builder 0.7.1.0 - Library for easily building REST API wrappers in Haskell  http://hackage.haskell.org/package/api-builder-0.7.1.0 (Intolerable)
16:47:35 <fread2281> wait that makes sense
16:48:04 <arkeet> you can write a little wrapper interface for MVar that guarantees that they're never empty
16:48:28 <dmwit> You can. But I don't understand why "MVars can be empty" is a problem in the first place.
16:48:47 <dmwit> It might be for all I know. But my spider sense is tingling.
16:52:23 <Denommus> what a nice day at work
16:52:27 <Denommus> I spend the whole day programming in Haskell, with my leader's approval
16:52:36 <Denommus> I'm not hired to do Haskell programming, though
16:52:49 <exio4> \o/
16:53:40 <dmwit> And here I was hired for my Haskell skills, yet I've done nothing but Verilog today. What a crazy world.
16:54:57 <MP2E> haha
16:55:34 <ion> Verilog generated using Haskell code, right? :-P
16:55:42 <dmwit> =D
16:56:47 <fread2281> is there an atomic writeMVar (tryTakeMVar + putMVar)?
16:56:50 <Denommus> I'm generating C++ code with Haskell
16:57:08 <dmj`> dmwit: are you using bluespec? just curious
16:59:16 <dmwit> Just Verilog. I haven't looked into bluespec much (yet).
16:59:19 <dmwit> Denommus: Sounds like fun!
16:59:39 <dmwit> Denommus: ...and a little bit roundabout. =)
17:00:19 <Denommus> dmwit: I'm a C++ programmer, and I have to write a bunch of classes that are used to make SOAP requests
17:01:08 <paxcoder> Denommus, sorry mate
17:01:17 <ion> Obligatory http://harmful.cat-v.org/software/xml/soap/simple
17:01:32 <Denommus> dmwit: so... I'm taking soapUI's auto-generated XML that contains all my requests and writing a script that parses it to produce the classes I need
17:01:43 <Denommus> paxcoder: it is worse than it sounds. The SOAP API is not even complete
17:10:03 <dmwit> Huh. Isn't HTTP a simple object access protocol?
17:10:16 <c_wraith> No, it's not simple.
17:10:28 <dmwit> I think maybe I don't want to cram myself into this rabbit hole.
17:11:50 <ion> Funny. When i run “let f x = addFinalizer x (putStrLn ("bye " ++ show x)) in mapM_ f [0..10 :: Integer]” in ghci, it never prints “bye 1”.
17:13:25 <dmwit> ?hoogle addFinalizer
17:13:26 <lambdabot> System.Mem.Weak addFinalizer :: key -> IO () -> IO ()
17:14:45 <dmwit> That is funny.
17:15:01 <dmwit> Even if you explicitly performGC afterwards.
17:16:00 <max-m> For me “bye 1” got printed: http://lpaste.net/7167641478846480384
17:16:12 <slack1256> Mmm I thought getting TH was as easier as any other problem. Why was it difficult to get TH on ARM?
17:16:24 <slack1256> To me, TH isn't platform dependent...
17:16:32 <c_wraith> ion: finalizers aren't guaranteed to ever run
17:16:38 <dmwit> max-m, ion: What version of GHC? 7.10.1 for me
17:16:54 <kirill`> Try this? let f x = addFinalizer x (putStrLn ("bye " ++ show x)) in do mapM_ f [0..10 :: Integer]; performGC; yield
17:16:54 <max-m> [max@~]ghci --version 
17:16:55 <max-m> The Glorious Glasgow Haskell Compilation System, version 7.6.3
17:17:04 <Zemyla> Hmm, is it possible to have a type that can take as one of its arguments either a type of kind * or a type of kind #?
17:17:18 <c_wraith> Zemyla: with the -XPolyKinds extension, yes
17:17:31 <c_wraith> Zemyla: but it can't be a type that it holds
17:17:50 <kirill`> ion: https://mail.haskell.org/pipermail/haskell-cafe/2007-May/025455.html
17:17:52 <Zemyla> c_wraith: What about a type it returns in an unboxed tuple?
17:17:55 <c_wraith> Zemyla: IE, it can't contain a value of that type, since they aren't treated the same
17:18:00 <dmwit> kirill`: nope
17:18:03 <arkeet> Either * #
17:18:12 <TimWolla> I can confirm max-m's result using GHC 7.6.3 (official Ubuntu LTS)
17:18:33 <TimWolla> ghci 7.10.1 in a Docker container prints in reverse order without the 1
17:19:08 <kirill`> dmwit: I got it printing "bye"s with 7.8.3
17:19:16 <lpaste> TimWolla pasted “GHC 7.10.1 /Docker)” at http://lpaste.net/2265850704704831488
17:19:34 <kirill`> dmwit: I understand there are no guarantees at all, though
17:19:34 <Zemyla> Because I want something like the ST monad, but that can return both boxed and unboxed types.
17:19:56 <ion> dmwit: https://gist.github.com/ion1/aaa5d1a840ed4f8dc4c0
17:20:04 <Big_G> Is this an appropriate channel to ask career related questions? 
17:20:23 <dmwit> ion: Perhaps 1 is interned and never GC'd or something.
17:20:33 <dmwit> ion: Seems like it might be a pretty common Integer constant.
17:20:36 <ion> c_wraith: I know, this behavior wrt. 1 :: Integer was just interesting.
17:21:01 <acowley> If 1 is interned, you'd think 0 would be, too.
17:21:19 <dmwit> Like I wouldn't expect [] to ever be GC'd, either.
17:21:32 <dmwit> ion: And running mapM_ f [[], [()]] seems to confirm that prediction.
17:21:44 <dmwit> acowley: I would think that, yeah.
17:21:50 <dmwit> acowley: But experimental evidence says otherwise. =P
17:22:29 <ion> I’m not getting any constructors without parameters to GC.
17:22:45 <acowley> This is GHC's subtle claim that the naturals start at 1
17:22:52 <dmj`> Big_G: if it's related to haskell, sure
17:23:08 <Big_G> dmj`, Mainly about finding Haskell jobs 
17:23:45 <dmj`> Big_G: they exist, yes
17:23:54 <ion> Out of [0..10 :: Natural], 1 is not GC’d either.
17:24:03 <Big_G> dmj`, That pay well and aren't in quant?
17:26:24 <Welkin> Big_G: define "pays well"
17:26:36 <Welkin> actually, take it to #haskell-blah as well
17:26:43 <dmj`> good call
17:26:44 <Big_G> Welkin, Will do
17:31:41 <athan> How would you make something `[Maybe a] -> [a]`?
17:31:49 <dmj`> :t catMaybes
17:31:50 <lambdabot> [Maybe a] -> [a]
17:32:04 <dmj`> [ x | Just x <- xs ]
17:32:05 <Iceland_jack> Has an interesting definition
17:32:05 <Iceland_jack> @src catMaybes
17:32:06 <lambdabot> catMaybes ls = [x | Just x <- ls]
17:33:01 <athan> :t concatMap maybeToList
17:33:02 <lambdabot> Foldable t => t (Maybe b) -> [b]
17:33:15 <athan> oh!
17:33:27 <athan> thanks dmj`
17:34:14 <athan> oh wow...
17:34:53 <kirill`> Why does [() | True] return [()]?
17:34:53 <kirill`> There are no "_ <- list" bindings, so isn't that like
17:34:53 <kirill`> map (\_ -> ()) $ filter (\_ -> True) []
17:35:06 <kirill`> > [() | True]
17:35:07 <lambdabot>  [()]
17:35:25 <athan> Iceland_jack: is monad comprehension... traversable comprehension..? :|
17:35:25 <athan> erm foldable?
17:35:38 <ion> > [ () | [()] ]
17:35:39 <lambdabot>      Couldn't match expected type ‘Bool’ with actual type ‘[()]’
17:35:39 <lambdabot>      In the expression: [()]
17:35:39 <lambdabot>      In a stmt of a list comprehension: [()]
17:35:47 <ion> > [ () | _ <- [()] ]
17:35:49 <lambdabot>  [()]
17:35:55 <ion> > [ () | _ <- [] ]
17:35:56 <lambdabot>  []
17:36:07 <Iceland_jack> athan: You can't implement 'filter' using Foldable so I suppose not
17:36:07 <ion> True and False are equivalent to that.
17:36:54 <haasn> kirill`: [ e | True ] = [e] is built into the specification
17:37:13 <arkeet> > do { guard True; return () }
17:37:14 <lambdabot>      No instance for (Show (m0 ()))
17:37:14 <lambdabot>        arising from a use of ‘show_M368446590729971154625532’
17:37:14 <lambdabot>      The type variable ‘m0’ is ambiguous
17:37:17 <arkeet> > do { guard True; return () } :: [()]
17:37:18 <lambdabot>  [()]
17:37:28 <haasn> kirill`: think about it like [e] but with an extra condition
17:37:30 <haasn> if that makes sense
17:37:31 <arkeet> > do { guard False; return () } :: [()]
17:37:32 <lambdabot>  []
17:37:53 <athan> Iceland_jack: 
17:38:07 <athan> can you explain it more verbosely? please :)
17:38:14 <ion> guard False = []; guard True = [()]; guard FileNotFound = ???
17:38:23 <Iceland_jack> athan: This explains it better than I could :) https://wiki.haskell.org/Foldable_and_Traversable#Some_trickier_functions:_concatMap_and_filter
17:38:47 <athan> Iceland_jack: thank you!!
17:39:11 <kirill`> arkeet: Ah, that makes sense
17:39:30 <Iceland_jack> athan: One example is that ((,) a) has a Foldable instance
17:40:14 <Iceland_jack> And writing filter for that ...(?) wouldn't be what you'd expect
17:40:14 <Iceland_jack>     filter :: (a -> Bool) -> (e, a) -> (e, a)
17:40:31 <athan> ahh
17:40:42 <arkeet> @hackage witherable
17:40:42 <lambdabot> http://hackage.haskell.org/package/witherable
17:41:01 <Iceland_jack> arkeet: Thanks, wasn't aware of that package
17:41:04 <arkeet> "Like traverse, but you can remove elements instead of updating them.
17:41:23 <arkeet> :t mapMaybe
17:41:24 <lambdabot> (a -> Maybe b) -> [a] -> [b]
17:41:28 <Iceland_jack> athan: Even something simple as 'Identity' would be tricky
17:41:30 <arkeet> filter is a special case of that
17:41:38 <arkeet> and you *can't* write mapMaybe for (,) e
17:42:00 <athan> Iceland_jack: There has to be some zero value?
17:42:06 <Iceland_jack> Yes effectively
17:42:14 <arkeet> you can't remove elements from a tuple.
17:42:16 <Iceland_jack> Same with 'Either e' unless you add a constraint to the 'e'
17:42:16 <arkeet> or from an Identity.
17:42:16 <athan> hmm!
17:42:36 <Iceland_jack> Which is exactly what Witherable does
17:42:37 <Iceland_jack>     instance Monoid e => Witherable (Either e) 
17:43:21 <mjrosenb> update (Motion t _ _ Frozen dest) | t >= 1.0 = dest
17:43:31 <athan> wow that is really cool
17:43:40 <mjrosenb> huh, that was not what I was expecting in the cut buffer.
17:44:05 <arkeet> it's a shame MaybeT has this
17:44:08 <arkeet> instance (Functor m, Monad m) => Applicative (MaybeT m)
17:44:16 <arkeet> instead of Applicative m => Applicative (MaybeT m)
17:44:50 <Iceland_jack> athan: witherable doesn't have an instance for (Identity a) or ((,) a) with a (Monoid a) constraint but I suppose it could add those
17:44:50 <Iceland_jack>     
17:44:53 <arkeet> actualy
17:45:06 <arkeet> hmm
17:45:06 <mjrosenb> ok, I have foo (F x) = f x; foo x = f x, is there any way to combine these into a single pattern?
17:45:44 <Iceland_jack> mjrosenb: Mind telling use more about F?
17:45:47 <Iceland_jack> *us
17:45:50 <arkeet> and about f
17:46:03 <arkeet> otherwise I'd say "no"
17:47:38 <Iceland_jack> mjrosenb: You can write something like 'maybe :: b -> (a -> b) -> Maybe a -> b' that may help, but somehow doubt it
17:49:04 <[mad]> hi
17:49:11 <arkeet> hi
17:50:41 <Iceland_jack> 'witherM', 'blightM'.. those names tho
17:50:49 <arkeet> heh
17:55:28 <mjrosenb> Iceland_jack: F is a constructor, and ... actually, f is id.
17:56:30 <arkeet> and F x has the same type as x?
17:56:40 <Iceland_jack> So you want
17:56:40 <Iceland_jack>     foo (F x) = f
17:56:40 <Iceland_jack>     foo y     = y
17:56:45 <Iceland_jack> *
17:56:45 <Iceland_jack>     foo (F x) = x
17:56:48 <Iceland_jack>     foo y     = y
18:01:02 <mjrosenb> yes.
18:27:02 <dmwit> mjrosenb: `foo (F x) = x; foo x = x` seems like a pretty light-weight way to define that function.
18:27:47 <dmwit> I'm having a hard time imagining anything syntactically lighter that would nevertheless have all the same information.
18:27:59 <dmwit> (Like, even if I don't restrict my imagination to Haskell.)
18:29:33 <dmj`> data F a = F { foo :: a }, gives you foo for free
18:30:04 <ion> That’s not the same foo (or the same F).
18:30:36 <dmj`> ion: what is the original F
18:31:00 <ion> Something like data Foo a = F (Foo a) | …
18:31:14 <dmj`> ah
18:31:14 <arkeet> yeah, otherwise foo wouldn't typecheck.
18:32:16 * dmwit wants multi-argument \case
18:33:03 <ion> @type curry (\case (a,b) -> undefined)
18:33:04 <lambdabot> parse error: naked lambda expression ''
18:33:58 <arkeet> @let {-# LANGUAGE LambdaCase #-}
18:33:59 <lambdabot>  Parse failed: Parse error: EOF
18:34:05 <arkeet> :-(
18:34:25 <Zemyla> Okay, so why can't I have hashes in my kind signatures?
18:34:39 <arkeet> do you need MagicHash
18:35:17 <Zemyla> I have MagicHash.
18:37:16 <Zemyla> I also have UnboxedTuples.
18:38:32 <jle`> what's the error?
18:38:43 <Zemyla> I really want to define STU s ( a :: # ) = STU (State# s -> (# State# s, a #))
18:38:47 <jle`> or are you asking from a moral standpoint?
18:39:01 <Zemyla> It gives me a syntax error on the hash in the kind signature.
18:39:48 <jle`> hm # might not be a valid identifier
18:40:16 <jle`> or wait is that the kind of unboxed types?
18:40:21 <arkeet> it is
18:40:39 <arkeet> well, it should be
18:40:48 <arkeet> if it weren't a syntax error
18:41:27 <Zemyla> arkeet: Yeah, that's what I'm saying.
18:41:32 <Zemyla> :k Int#
18:41:33 <lambdabot>     Not in scope: type constructor or class ‘Int#’
18:41:34 <lambdabot>     Perhaps you meant one of these:
18:41:34 <lambdabot>       ‘Int’ (imported from Data.Int), ‘Int8’ (imported from Data.Int)
18:42:03 <Zemyla> Well, lambdabot doesn't have GHC.Prim loaded, but if it did, it would say "Int# :: #"
18:42:23 <arkeet> :k GHC.Prim.Int#
18:42:24 <lambdabot> #
18:42:36 <ion> :k (GHC.Prim.Int# :: #)
18:42:37 <lambdabot> parse error on input ‘#)’
18:42:44 <arkeet> :k (GHC.Prim.Int# :: # )
18:42:45 <lambdabot> parse error on input ‘#’
18:43:01 <arkeet> :k Int :: *
18:43:02 <lambdabot> *
18:43:08 <ion> :k (GHC.Prim.Int# :: Constraint)
18:43:09 <lambdabot>     The signature specified kind ‘Constraint’,
18:43:09 <lambdabot>       but ‘GHC.Prim.Int#’ has kind ‘#’
18:43:09 <lambdabot>     In a type in a GHCi command: (GHC.Prim.Int# :: Constraint)
18:44:19 <Zemyla> :k (GHC.Prim.Int# :: k)
18:44:20 <lambdabot> Not in scope: type variable ‘k’
18:44:57 <arkeet> @let :set -XMagicHash
18:44:57 <lambdabot>  Parse failed: Parse error: :
18:45:34 <ion> It wouldn’t have parsed the Int# without MagicHash
18:45:42 <arkeet> yeah
18:45:45 <arkeet> I'm just being silly
18:55:25 * hackagebot exact-pi 0.1.1.0 - Exact rational multiples of pi (and integer powers of pi)  http://hackage.haskell.org/package/exact-pi-0.1.1.0 (dmcclean)
19:00:25 * hackagebot termbox-bindings 0.1.0.1 - Bindings to the termbox library  http://hackage.haskell.org/package/termbox-bindings-0.1.0.1 (lcfrs)
19:11:22 <mjrosenb> dmwit: sml has disjunctive patterns which would handle this succinctly.
19:16:13 <wepy> hai
19:17:00 <wepy> is there a haskell without garbage collection?
19:17:27 <c_wraith> haskell without garbage collection wouldn't make much sense.
19:17:39 <wepy> why?
19:17:55 <c_wraith> But if you're just looking for a modern (ie, newer than 1950s tech) language without garbage collection, try rust
19:18:05 <wepy> yea i saw rust..
19:18:11 <wepy> haskell sounds safer though
19:18:24 <dmj`> "A stable pointer is a reference to a Haskell expression that is guaranteed not to be affected by garbage collection"
19:18:25 <wepy> also rust is a little fugly..
19:18:48 <rcyr> Wouldn't it be difficult(even possible) to have a lazy language without GC?
19:18:55 <rcyr> *impossible
19:19:10 <c_wraith> well, no.  you can have a lazy language without GC..  But a whole lot of programs will crash with out of memory errors. :)
19:19:33 <c_wraith> on the plus side, it'd make the allocator even faster than the current one!
19:19:59 <napping> Explicit deallocation might be managed with linear types, but I don't know any serious attempts to make a functional language like that
19:20:21 <wepy> ic
19:20:59 <c_wraith> wepy: the main issue is that without GC, it'd be impossible to determine when a value is no longer used.
19:21:09 <wepy> is it even possible to create a leak in haskell?
19:21:18 <c_wraith> Depends on the definition of "leak"
19:21:19 <dmj`> yea
19:21:32 <c_wraith> If you mean "losing pointers to heap space", only with the FFI
19:21:36 <wepy> is it possible to like.. dereference a null pointer, or use an uninitialized variable?
19:21:37 <johnw> you could use the FFI to malloc a block and then drop the reference
19:21:55 <johnw> "a null pointer" has no meaning
19:21:57 <johnw> except to the FFI
19:21:58 <napping> Do you need to do low-level systems programming kind of stuff?
19:22:16 <johnw> "uninitialized variable" also has no meaning
19:22:21 <wepy> ok
19:22:27 <wepy> napping: i duno :)
19:22:40 <wepy> just dabbling
19:22:41 <napping> If you do, then rust is about as safe as anything
19:22:59 <napping> If you thought rust was ugly, you haven't seen ATS
19:23:02 <wepy> i think the rust syntax is kind of complicated
19:23:12 <napping> If you don't need to, then garbage collection probably isn't that bad
19:24:09 <bjz> "is it possible to like.. dereference a null pointer, or use an uninitialized variable?" Those aren't leaks
19:24:43 <bjz> plus, it is possible to leak in many languages that are 'memory safe'
19:25:36 <wepy> i like the ghc.app :)
19:25:40 <wizao> in haskell, your memory have to worry about space leaks more than memory leaks
19:26:02 <wepy> ok
19:26:48 <wepy> so.. does Haskell have something like python's Construct module?
19:27:02 <wepy> it's for parsing/reading/writing like.. C structures kind of?
19:27:09 <wizao> haskell is awesome for parsing
19:27:19 <wepy> but you define them sort of.. declaratively with nested functions?
19:27:41 <wizao> yes
19:28:01 <wizao> are you looking for parsing dynmaic structures like json?  check out aeson
19:28:44 <wepy> in Construct it's like: x = Struct("StructName", UBInt32("blah"), Bytes("blahbytes", lambda: ctx: ctx.blah))
19:28:55 <wepy> more like binary data
19:29:00 <geekosaur> binary or cereal?
19:29:18 <wepy> i seem to work with binary stuff more.. like if i could parse an Elf or a Mach-o file maybe that could be useful
19:29:33 <wepy> or other random data..
19:29:35 <geekosaur> and a general Storable mechanism used with the FFI
19:29:59 <wepy> do you use FFI a lot with haskell?
19:30:18 <dmj`> wepy: you can automatically serialize / deserialize most datatypes using generics
19:30:33 <geekosaur> it is usually easier to bind to an existing library than to reimplement it
19:30:34 <wepy> dmj`: even with unknown/dynamic fields?
19:32:09 <dmj`> wepy: what would an unknown field look like in haskell
19:32:35 <dmj`> wepy: I mean like data Person = P String Int deriving (Generic, Show); instance Serialize Person
19:33:01 <dmj`> let g = Person "me" 99; decode (encode g) == g
19:33:10 <wepy> heh
19:35:19 <wepy> can a C program call into a haskell library?
19:35:23 <wepy> is there such a thing?
19:35:37 <Clint> yes
19:35:43 <simpson> wepy: Yes. Instructions are scant but it's possible.
19:36:02 <wepy> what if you wanted to embed haskell in an existing program?
19:36:28 <wepy> there's a haskell interpreter?
19:37:28 <wepy> the haskell.org tutorial sucks hehe
19:37:42 <wepy> the Gentle one.
19:39:50 <wepy> jesus, no hello world?
19:39:51 <wepy> haha
19:40:33 <c_wraith> main = putStrLn "hello world"
19:40:37 <c_wraith> It's not very interesting
19:40:46 <wepy> found that page..
19:41:03 <wepy> it would be cool if haskell had something like the golang tutorials
19:41:16 <wepy> kind of interactive/progressively more complex
19:41:21 <bwiklund> when modeling data (any kind) do you think it's worth complicating your data definitions to make mistakes un-compilable
19:41:23 <wepy> you could probably run ghci with asm.js or something
19:41:51 <c_wraith> bwiklund: usually, unless it's also way harder to use correctly
19:41:52 <bwiklund> or keeping it simple and trusting your own 'create' functions to validate
19:42:04 <bwiklund> specifically right now i'm making a toy 'git' clone
19:42:44 <bwiklund> and i initially had one data type that could either be "full" objects, or semi-filled pointers (without their contents / child nodes)
19:43:15 <simpson> wepy: In-the-browser tutorials are already a thing: https://www.fpcomplete.com/school?show=tutorials
19:43:16 <bwiklund> but now that i'm trying to break it into a "pointer" and "instance" type, even though it seems more modular, i still have the issue that you CAN create malformed versions of these
19:43:45 <bwiklund> unless i make the real data constructor private to the module and only expose something capable of returning something correct
19:43:55 <bwiklund> but still, that isn't so safe that i can trust it compiling as being 'safe'
19:44:05 <bwiklund> does that make sense?
19:44:42 <bwiklund> like if i had a Person type and Nametag type
19:45:04 <bwiklund> its a good split of responsibilities but it's also not guaranteed to be correct
19:45:14 <bwiklund> should i just give up on that level of correctness
19:47:20 <Hijiri> wepy: If you're interested, I recommend this guide: https://github.com/bitemyapp/learnhaskell
19:47:47 <Hijiri> The first tutorial it recommends isn't so interactive, but it comes with homework exercises so you can bake in your understanding
19:48:45 <Hijiri> The second one is interactive, but maybe not in the same way you meant. It has you implement a lot of common abstractions so you understand them better
19:48:56 <Hijiri> Also, for binary parsing, there is the attoparsec package
19:55:14 <wepy> ok thanks
19:59:51 <wepy> tryhaskell.org is nice
20:00:27 * hackagebot termbox-bindings 0.1.0.2 - Bindings to the termbox library  http://hackage.haskell.org/package/termbox-bindings-0.1.0.2 (lcfrs)
20:03:19 <wepy> haha
20:03:27 <wepy> why is it fst() instead of first() ?
20:03:53 <rom1504> because
20:04:10 <c_wraith> wepy: functions don't use parens in haskell
20:04:23 <c_wraith> > let x = (1,2) in fst x
20:04:24 <lambdabot>  1
20:04:26 <wepy> i mean, why truncate to fst?
20:04:31 <wepy> first is only 5 chars
20:04:36 <dmj`> > let x = (1,2) in fst(x)
20:04:38 <c_wraith> why does unix truncate "copy" to "cp"?
20:04:38 <lambdabot>  1
20:04:57 <wepy> it's like how old C programs limited variables/symbols to 7 chars..
20:05:33 <Cale> wepy: Because (\(x,y)->x) does the same thing, and it's already pretty short. Also, fst and snd are both common enough to warrant having short names.
20:05:47 <burz> Hello, friends.
20:06:59 <wepy> heh
20:07:09 <Cale> Generally, you want name lengths to be longer as their scope increases, but shorter as their frequency of use increases.
20:07:28 <dmj`> burz: sup
20:07:32 <wepy> ok
20:07:51 <cellopin> hi.. I'm studying data and type constructors and I have a question. Can you create a new type with a default value on its record? Something like this http://lpaste.net/132253
20:08:04 <cellopin> but line 10 is not working
20:08:47 <dmj`> cellopin: no, but there is a Default type class
20:08:49 <Cale> cellopin: no, you can't.
20:09:01 <burz> Does anyone have any idea how functions and and their applications are coded in LLVM, I'm wondering for instance how Haskell does it
20:09:26 <dmj`> instance Person Default where def = Person Female
20:09:58 <ion> dmj: It won’t work like that.
20:10:03 <dmj`> ion: no?
20:10:07 <dmj`> burz: http://llvm.org/pubs/2010-09-HASKELLSYM-LLVM-GHC.pdf
20:10:11 <wepy> seems like.. whitespace doesn't matter in haskell?
20:10:22 <Cale> wepy: Whitespace matters a great deal
20:10:24 <dmj`> wepy: it does
20:10:33 <wepy> hm
20:10:35 <dmj`> ion: porque? 
20:10:55 <cellopin> okay let me check if that works
20:11:16 <Cale> wepy: In fact, you'll want to configure your editor not to put tab characters in source files, because it matters which column things line up to, and different editors treat tab characters differently. (The compiler will treat them as aligning to the next multiple of 8 columns)
20:11:34 <ion> dmj: Person "Derpina" 20 Female. (Also, instance Default Person)
20:12:39 <dmj`> ion: ok then def = Person mempty mempty Female
20:12:41 <Cale> also the Default class is almost certainly not in scope for cellopin
20:12:57 <dmj`> cabal install data-default
20:13:09 <ion> There is no instance Monoid Int.
20:13:10 <cellopin> oh.. you mean too advance?
20:13:10 <burz> dmj`: hmmm, interesting thanks. I've been working on implementing them but I decided to make a generic application function (i.e. a specific typed function) to actually apply the final argument to the function. There's probably a better way
20:13:31 <Cale> (also the Default class is a bit ugly, and I'd avoid using it unless something else I was using used it)
20:13:53 <Cale> cellopin: I mean it's in a separate library
20:14:04 <cellopin> I see.
20:14:28 <Cale> cellopin: I don't know why these guys are suggesting it. You're better off just defining a value of type Person, and then using that as a default value, with record update syntax
20:14:34 <dmj`> cellopin: You can just define your own default Person generator, newPerson :: String -> Int -> Person; newPerson name age = Person name age Female
20:14:51 <dmj`> ion: oh yea, the Sum / Product newtypes
20:14:53 <ion> Cale: Just one guy was suggesting it.
20:15:10 <Cale> cellopin: For example, with your existing code (apart from the newtype declaration that isn't syntactically correct)
20:15:27 <Cale> cellopin: You can write  woman { name = "Ann", age = 36 }
20:17:56 <Cale> You might get a little more type safety out of defining a function that takes the name and age as arguments like dmj` is suggesting there though -- given that you'd really like to have some assurance that all the fields are filled in.
20:18:02 <ion> jle: http://blog.jle.im/entry/fixed-length-vector-types-in-haskell-2015 Find the text “Key not found”
20:18:20 <jle`> aw darn
20:18:32 <cellopin> okay
20:18:40 <jle`> thanks :)
20:20:11 <cellopin> I get it.. that's a nice solution
20:20:15 <ion> jle: In class Index, “index :: proxy n -> v a -> a” might be better. It’s the norm to use a type constructor variable for proxy parameters so the invoker is free to use, say, “Just x” if she happens to have an “x” of the intended type. 
20:21:24 <jle`> ion: ah, that makes sense.  thanks :)
20:23:51 <ion> jle: The comment in https://ghc.haskell.org/trac/ghc/wiki/OverloadedLists#Length-indexedobservedVectors probably refers to [0,1,2] not being inferred to have the type Vec Integer 3.
20:24:33 <jle`> ion: as in, it can't infer the length?
20:25:22 <jle`> that doesn't seem to be a real problem though, because you have to have the types be inferrable for all of instance of OverloadedLists
20:25:30 <jle`> er, of IsList
20:26:44 <ion> The comment may be referring to the same thing that forces your IsList instance to use “error”.
20:27:33 <jle`> ah, i see
20:27:58 <wepy> map (+1) [1,2] does what's expected
20:28:04 * dfeuer sees jle`.
20:28:08 <wepy> but: map +1 [1,2] does not
20:28:16 <wepy> what does the one without parenthesis mean?
20:28:22 <jle`> wepy: that's parsed as map + (1 [1,2])
20:28:23 <ion> wepy: map +1 [1,2] is parsed as (map) + (1 [1,2])
20:28:42 * jle` also sees dfeuer
20:29:08 <wepy> what is: 1 [1,2] ?
20:29:20 * dfeuer thinks map + 1 [1,2] does exactly what's expected.
20:29:20 <ion> wepy: A bug
20:29:27 <jle`> in this situation, it's meaningless :)
20:29:36 <wepy> but it's valid
20:29:37 <jle`> it's applying the function 1 with argument [1,2]
20:29:46 <jle`> so if `1` is a function, then it makes sense.
20:29:55 <jle`> but normally we don't have `1` as a function
20:30:01 * dfeuer would expect a complaint about certain instances not being available.
20:30:10 <ion> wepy: Number literals are polymorphic and you *can* make a function instance for them. But it’s not typically a reasonable thing to do.
20:30:28 <wepy> ah
20:31:05 <dfeuer> No instance for Num ((a->b) -> [a] -> [b]) or some such.
20:31:05 <wepy> 1 [1,2] is a declaration?
20:31:12 <jle`> it's a function application
20:31:13 <dfeuer> No.
20:31:17 <dfeuer> Ye.
20:31:17 <jle`> just like f [1,2]
20:31:20 <jle`> but your function is 1
20:31:22 <jle`> it's kinda silly
20:31:35 <wepy> why doesn't it error?
20:31:37 <dfeuer> > map + 1
20:31:38 <lambdabot>      No instance for (Typeable a0)
20:31:38 <lambdabot>        arising from a use of ‘show_M831547922163451247028884’
20:31:38 <lambdabot>      In the expression:
20:31:40 <wepy> i didn't define 1 as a function ;)
20:31:41 <jle`> i'm surprised that it didn't error
20:31:44 <dfeuer> um ... wat?
20:31:57 <dfeuer> That looks like a weird lambdabot error.
20:31:59 <jle`> just opened up ghci and tried it out and i got an error
20:32:16 <dfeuer> Prelude> map + 1
20:32:16 <dfeuer> <interactive>:2:1:
20:32:16 <dfeuer>     No instance for (Show ((a0 -> b0) -> [a0] -> [b0]))
20:32:16 <dfeuer>       arising from a use of ‘print’
20:32:16 <dfeuer>     In a stmt of an interactive GHCi command: print it
20:32:31 <jle`> `map + 1 [1,2]` gives an error too
20:32:49 <wepy> no map
20:32:54 <wepy> just 1 [1,2]
20:33:02 <ion> Still gives an error.
20:33:03 <wepy> tryhaskell.org lets you do both tho
20:33:06 <ion> > 1 [1,2]
20:33:07 <lambdabot>      Could not deduce (Num t0)
20:33:08 <lambdabot>      from the context (Num t, Num ([t] -> t1))
20:33:08 <lambdabot>        bound by the inferred type for ‘e_1112’:
20:33:11 <dfeuer>    Could not deduce (Num ([t0] -> (a -> b) -> [a] -> [b]))
20:33:12 <dfeuer>       arising from the ambiguity check for ‘it’
20:33:31 <dfeuer> wepy, tryhaskell is probably a little weird.
20:33:34 <wepy> k
20:33:47 <jle`> this surprises me but i have to go and see
20:33:53 <dfeuer> Oh, I see.
20:33:58 <dfeuer> It's actually reasonable.
20:33:59 <ion> tryhaskell seems to print no value but the inferred type.
20:34:08 <ion> @type 1 [1,2]
20:34:08 <wepy> so, surrounding stuff with parenthesis makes it a function?
20:34:09 <lambdabot> (Num t, Num ([t] -> t1)) => t1
20:34:09 <dfeuer> Yes.
20:34:13 <dfeuer> No.
20:34:19 <jle`> wepy: it's "section" syntax
20:34:26 <jle`> (+ 3) is syntactic sugar for \x -> x + 3
20:34:40 <jle`> it's like waiting for a number in the "missing spot" (on the left)
20:34:51 <dfeuer> And (3 +) is syntactic sugar for (\x -> 3 + x)
20:34:59 <ion> And the “+” can be substituted with any operator.
20:35:06 <wepy> why do you need the \ ?
20:35:17 <ion> It’s Haskell syntax for lambda abstraction.
20:35:21 <jle`> do you know about anonymous functions?
20:35:26 <wepy> what if you have 2 args?
20:35:27 <ion> An ASCII approximation of λ
20:35:28 <dfeuer> You can even do  (`map` [3]), but don't.
20:35:34 <ion> \a b -> c
20:35:43 <jle`> > let foo = (\x -> x + 3) in foo 10
20:35:44 <wepy> in python it might be lambda x: x + 3
20:35:44 <lambdabot>  13
20:35:49 <jle`> > (\x -> 3 + x) 10
20:35:50 <lambdabot>  13
20:35:55 <jle`> wepy: yeah, that's essentially the same thing
20:36:02 <wepy> why the backslash tho?
20:36:05 <dfeuer> Which trips me up when I attempt it in Idris, because there it's \x,y=>x+y
20:36:08 <jle`> cause it looks kinda like a lambda
20:36:13 <jle`> the greek letter
20:36:23 <wepy> hah
20:36:26 <jle`> λ
20:36:28 <ion> lambda → \
20:36:30 <dfeuer> If you drink way too much, or have bad vision.
20:36:31 <ion> : → ->
20:36:34 <jle`> λx -> x + 3
20:36:37 <jle`> \x -> x + 3
20:36:40 <jle`> it's kinda similar  :)
20:38:06 <dolio> λ is Church's syntax for putting hats over the variables you're binding. :)
20:38:36 <dfeuer> dolio, why would you write them with hats? Is that some worse notation?
20:38:48 <dolio> Or is it better?
20:39:01 <dfeuer> What's it end up looking like?
20:39:07 <ion> It’s Superman
20:39:14 <dolio> Well, I have no way of entering it with my setup.
20:40:01 <dolio> But imagine that λx. x is instead x. x but with a ^ over the first x.
20:41:07 <dfeuer> Sounds ... similar, but foreign. Nothing to recommend it.
20:41:15 <ion> f x = x+1; f = x̂̂+1
20:41:37 <dolio> I think Church used λ because he had no good way of typing it either.
20:42:02 <ion> I wonder what the hat syntax is for nested lambdas? Multiple hats according to the de Bruijn index? :-P
20:42:04 <Iceland_jack> You can extend to denote indexing, an additional caret for each binder
20:42:09 <Iceland_jack> ion: ↑
20:42:24 <wepy> but: (x -> x + 3) 1; doesn't seem ambiguous
20:42:37 <wepy> doesn't seem like the \ is necessary for the parser
20:42:46 <dolio> ion: You still write the variable when you quantify it.
20:43:04 <dolio> f = x̂̂. x + 1
20:43:12 <ion> dolio: Oh, alright.
20:43:18 <Iceland_jack> wepy: -> can be used in other contexts at the term level
20:43:30 <Iceland_jack> like case .. of _ -> ...
20:43:32 <dolio> So you have multiple hat variables, I guess. Or maybe put a big hat over all the variables, I don't know.
20:43:49 <Zemyla> I have a question.
20:44:07 <dolio> Maybe you don't need the . either.
20:44:13 <Zemyla> Are Haskell instillations with 30 bits something I actually need to worry about, or are they a scary story Haskell programmers tell each other around a campfire?
20:44:15 <bwiklund> go ahead Z
20:44:32 <bwiklund> making sure you mean 32 ?
20:44:40 <ion> Zemyla: Just use Integer or Int64 or whatever if it matters.
20:44:59 <cwraith> bwiklund: nah, the spec says Int can be as small as 29 bits + a sign bit
20:45:01 <Zemyla> I'm trying to write a new GHC.Integer implementation.
20:45:14 <bwiklund> huh. didn't know that
20:46:14 <bwiklund> did some quick google for the reason
20:46:19 <bwiklund> tagging... clever
20:49:26 <dolio> Zemyla: Are you using anything but GHC? Because GHC doesn't do any tagging.
20:49:32 <dolio> Or, not like that.
20:50:00 <dolio> So unless you find some hardware that has 30 bit words, you shouldn't have to worry.
20:50:15 <dolio> And you still wouldn't, because GHC won't run on it. :)
20:53:22 <monochrom> I used to know a computer of 36-bit words. it was a famous public FTP server hosting a lot of freeware, shareware, and FOSS. circa 1995.
20:54:07 <monochrom> for example I would download gcc for DOS and TeX for DOS from there back then
20:55:31 <esayler> exit
20:55:59 <muyfine> having some trouble with conduits in a library and "sinking" all the values
20:56:23 <Iceland_jack> “Idris is a Pac-man complete functional programming language ...” https://www.youtube.com/watch?v=vkIlW797JN8 
20:57:09 <muyfine> want to collect all the makers - http://lpaste.net/132256
20:57:51 <muyfine> but having problems collecting them out (streaming doesn't really help me here - I need to see all the results to make a decision)
21:00:28 * hackagebot termbox-bindings 0.1.0.3 - Bindings to the termbox library  http://hackage.haskell.org/package/termbox-bindings-0.1.0.3 (lcfrs)
21:01:29 <monochrom> Zemyla: GHC's tagging (or non-tagging) story is fantastic. after hearing it you may laugh or cry or a bit of both.
21:02:33 <dfeuer> monochrom, must hear.
21:02:34 <Cale> Is there a proof that Idris is Pac-man complete yet?
21:02:45 <dfeuer> Cale, what does that mean?
21:03:08 <Cale> I mean, has someone actually implemented Pac-man in it :)
21:03:21 <monochrom> using Int for example for now. GHC will not steal 2 or 3 bits from your 64 bits. you have the full 64-bit number at your disposable. this is done by putting the tag in another 64 bits. therefore, a fully evaluated Int occupies 128 bits.
21:03:41 <ion> Heh, nice
21:04:14 <Zemyla> monochrom: Seriously? I know it tags pointers, and it can do that because of alignment.
21:04:20 <Iceland_jack> Cale: He phrased it as "someone might be interested in implementing Pac-Man", in which case just being Turing-complete doesn't mean you're Pac-man complete
21:04:50 <Jeanne-Kamikaze> :D
21:05:02 <monochrom> there is a good excuse to be this wasteful. the 64-bit "tag" is a pointer to a program that stands for "I am the data constructor of Int". and there is a good reason for doing that:
21:05:03 <dfeuer> Iceland_jack, if you're using it properly, it's not Turing complete.
21:05:42 <dolio> In a lot of situations it figures out that it doesn't need the other tag, though. :)
21:05:47 <Zemyla> monochrom: An Int# is still just 64 bits in memory, right?
21:05:47 <Iceland_jack> dfeuer: I disagree but will not get into that discussion
21:05:48 <monochrom> if you have a pointer to an Int, it may be an unevaluated thunk or an evaluated final value. you want to treat those two cases as uniformly as possible.
21:06:21 <monochrom> yes, Int# has no overhead. in fact, "data Int = Ctor Int#". Ctor 64 bits, Int# 64 bits. done.
21:06:34 <Iceland_jack> :-) not that it isn't an interesting one
21:07:27 <dolio> monochrom: That's not as sad as the Int8 story, though.
21:08:31 <monochrom> a thunk is going to be of the form: 64-bit pointer to the program for the thunk, then the pointers pointing to the parameters you want to pass to the program.
21:08:52 <ion> λ> unsafeCoerce (minBound :: Int64) :: Word8
21:08:54 <ion> -9223372036854775808
21:09:01 <Iceland_jack> dolio: What story is that?
21:09:10 <monochrom> e.g., the thunk "x && y" is pointer to the (&&) code, then pointer to x, then pointer to y.
21:09:10 <dolio> Iceland_jack: It's also 128 bits.
21:09:21 <Iceland_jack> Ah..
21:10:34 <monochrom> and if you agree to treat final values similarly, then you want them to look like: pointer to the program that stands for "I am a data constructor and so you are done evaluating", followed by pointers to data content.
21:10:57 <monochrom> so this is why spending 128 bits for Int is tenable.
21:11:42 <monochrom> and if you decide to preserve 4-byte alignments, then what dolio says, the story for Int8 is going to make baby Jesus cry. or laugh.
21:12:05 <monochrom> it's 64 bits for the data constructor, then 64 bits for 8 bits. XD
21:12:16 <dolio> It's not even alignment at this point. There's not even an Int8#.
21:12:20 <dolio> Int8 juts uses Int#.
21:12:57 <dolio> There's talk of adding Int8# and such, though.
21:13:11 <monochrom> an exercise for you now is what happens to [Char]. suppose you have a [Char] of length n, in normal form. how many bytes does it take?
21:13:25 <dmj`> dolio: are you dan doel?
21:13:35 <dmj`> vector-algorithms guy
21:13:44 <dolio> So that you can do 'data IP = IP Int8# Int8# Int8# Int8#' and such.
21:13:46 <dolio> I am.
21:14:13 <dolio> And that will still only be 128 bits, probably.
21:14:46 <dolio> Or 64 if you're running in 32 bit mode.
21:15:32 <ion> Someone could write a class for asking the runtime size of an (evaluated) value.
21:16:06 <exio4> there already is, IIRC
21:16:08 <Zemyla> monochrom: Well, there would be at least 21 bits for each Char, since Haskell is Unicode-aware.
21:17:17 <ion> I seem to remember that Char has the same size as Int, but i may be wrong.
21:17:20 <monochrom> Char is going to be 64 bits for the data constructor, and 64 bits for the XXX# primitive type that holds 21 bits
21:18:21 <monochrom> in practice, it seems that GHC does flyweight sharing and re-use. (design pattern!) so if you have a million 'A's, you still only spend 128 bits, not 128 million bits
21:18:50 <monochrom> but that still doesn't help [Char] very much.
21:19:30 <monochrom> if your [Char] is a million 'A's, you still need a million pointers that point to the same 'A'.
21:19:38 <codygman> I got this error trying to install stm with ghc/arm: http://lpaste.net/raw/132257 Any ideas?
21:20:16 <dolio> Much cheaper to store infinite 'A's.
21:20:55 <ion> We’ll simply use GHC magic to optimize the list away.
21:21:47 <monochrom> so here it goes. "data [Char] = (:) Char [Char] | []". you have a million cons cells. each cons cell has: 64 bits for (:), 64 bits for pointer to 'A', 64 bits for pointer to next cons cell. that's 192 bits, i.e. 24 bytes.
21:22:40 <monochrom> this is why beginners and intermediates ask about "I'm just reading a 1MB file. why does it use 24MB memory!"
21:23:18 <ion> No problem, my Amiga has 96 MB.
21:23:29 <Zemyla> Yeah, you're going to want to consume it quickly and/or lazily.
21:24:04 <Zemyla> Also, use Text whenever possible.
21:24:09 <monochrom> yeah
21:27:53 <monochrom> another common workaround is to downgrade to 32-bit GHC :)
21:28:26 <ion> Does any distro use the x32 ABI?
21:28:32 <monochrom> (pretty common among those who run GHC in a virtual machine of 0.5GB RAM)
21:29:46 <monochrom> (there was once a few years ago lambdabot switched to 32-bit GHC and immediately solved a lot of thrashing problems XD)
21:30:11 <ion> heh
21:32:09 <bwiklund> quick question, since my hoogle-foo is failing me: is there a function i can wrap stuff that can throw errors in, with a more descriptive string
21:32:43 <bwiklund> like if my shiz has "fromJust" in it and I just want to slap the user on the wrist more eloquently
21:34:12 <muyfine> oh man, I figured it out...
21:34:19 <muyfine> $$ CL.fold (flip (:)) []
21:34:29 <muyfine> as the sink
21:34:30 <ion> Dunno about such a function, but if you’re really, *really* sure fromJust is appropriate, you should use (\ ~(Just a) -> a) instead. Its error message has the location where the assumption failed.
21:34:54 <bwiklund> ah, nice
21:35:14 <bwiklund> yeah, i wrapped something in Maybe because i wanted to avoid making a much more complicated system of types
21:35:26 <bwiklund> since i (the library creator) control the construction of those types
21:35:40 <bwiklund> and the user would have to go out of their way to build something incorrect
21:36:03 <bwiklund> if that makes any sense
21:40:29 <dan64> How come in ghci, this works ":i +" but ":t +" doesn't? (in the latter case, I can uxe "(+)" and it works.
21:40:30 * hackagebot pandoc-citeproc 0.7 - Supports using pandoc with citeproc  http://hackage.haskell.org/package/pandoc-citeproc-0.7 (JohnMacFarlane)
21:40:52 <Iceland_jack> dan64: Just a discrepancy
21:41:05 <monochrom> because :Info wants names, :type wants expressions
21:41:21 <monochrom> for example, try: :info + * ^
21:41:30 <monochrom> (you wouldn't think of it for :type)
21:41:35 <Iceland_jack> Ah exactly
21:41:38 <ion> :t +
21:41:39 <lambdabot> Num a => a -> a -> a
21:41:42 <ion> :t + 42
21:41:43 <lambdabot> Num a => a -> a
21:42:37 <dan64> thanks
21:47:22 <Iceland_jack> :t 42 ^ 
21:47:23 <lambdabot> (Integral b, Num a) => b -> a
21:47:26 <Iceland_jack> interesting
22:02:01 <gcganley> wait lambdabot doesnt need parens for operators anymore?!
22:02:04 <gcganley> :t +
22:02:06 <lambdabot> Num a => a -> a -> a
22:02:13 <gcganley> made my day
22:06:45 <jle`> yeah it's pretty world-changing
22:10:45 <ion> jle: I reached the end. It was a nice article.
22:14:34 <jle`> thank you ion :) in retrospect it was a bit ambitious in its scope
22:25:31 * hackagebot pg-harness 0.1.2 - REST service for creating temporary PostgreSQL databases  http://hackage.haskell.org/package/pg-harness-0.1.2 (BardurArantsson)
22:40:32 * hackagebot sorted-list 0.1.2.0 - Type-enforced sorted lists and related functions.  http://hackage.haskell.org/package/sorted-list-0.1.2.0 (DanielDiaz)
22:44:00 <Xnuk> :t some
22:44:01 <lambdabot> Alternative f => f a -> f [a]
22:44:06 <Xnuk> :t all
22:44:07 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
22:55:32 * hackagebot sorted-list 0.1.2.1 - Type-enforced sorted lists and related functions.  http://hackage.haskell.org/package/sorted-list-0.1.2.1 (DanielDiaz)
23:06:34 <Zemyla> Oh, monochrom, question about internal representations.
23:07:11 <Zemyla> I remember back before 4.8, Void was defined as a newtype Void = Void Void.
23:07:18 <Zemyla> What would the internal representation of that be?
23:15:31 <jle`> that's cute
23:15:55 <jle`> there are no valid values of that type, so you don't really have to worry about internal representation
23:16:11 <jle`> if you're talking about how values are represented
23:23:56 <lokathor> :t traverse
23:23:57 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
23:24:13 <lokathor> @src traverse
23:24:13 <lambdabot> Source not found. It can only be attributed to human error.
23:26:01 <glguy> Values of Void will be thunks or exceptions
23:26:05 <Cale> lokathor: traverse is a method of the Traversable type class
23:26:35 <lokathor> i'm not entirely clear how traverse is seperate from map in the case of lists
23:26:40 <lokathor> or if it is at all
23:26:55 <haasn> Zemyla: you could define a value undef = Void undef and it would probably be not that different from undef = undef internally
23:27:09 <lokathor> but it was suggested when i talked about using a list earlier, rather than map, so i thought i'd investigate
23:27:36 <jle`> lokathor: if you have (a -> b), you can use map to turn an [a] into a [b]
23:27:55 <lokathor> yes
23:28:01 <jle`> lokathor: if you have an (a -> IO b), you can use traverse to take a [a] and get an IO [b]
23:28:15 <jle`> as in, execute all of the IO b's made from every item in the list
23:28:17 <lokathor> :t mapM
23:28:18 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
23:28:24 <lokathor> ah ha
23:28:27 <jle`> for example, traverse print [1,2,3] will print out 1, 2, and 3
23:28:36 <jle`> it's basically print 1 >> print 2 >> print 3
23:28:43 <lokathor> so traverse is like mapM
23:28:45 <jle`> yeah, traverse is mapM generalized to all Applicative
23:28:53 <jle`> traverse will work anywhere mapM does
23:29:01 <jle`> in a way traverse is like `fmap` to mapM's `map`
23:29:03 <pingu> lokathor: you can recover fmap or "map" in the list instnace from traverse.
23:29:08 <pingu> fmapDefault :: Traversable t => (a -> b) -> t a -> t b
23:29:11 <pingu> fmapDefault f = getId . traverse (Id . f)
23:29:55 <jle`> i like fmapDefault f = fromJust . traverse (Just . f)
23:30:02 <jle`> (disclaimer: i don't)
23:30:27 <pingu> I wonder if ghc would optimize that out...
23:30:53 <lokathor> well, i've got a String, and a Char -> Either String (State StdGen [Int])
23:31:13 <jle`> runIdentity . traverse (Identity . f) is probably optimized out...maybe.
23:31:29 <jle`> `runIdentity . traverse (coerce f)` i am more certain of
23:31:32 <pingu> jle`: it's never a "thing", I wouldn't think. Maybe is a data type, though.
23:32:05 <jle`> lokathor: what do you want in the end?
23:32:32 <lokathor> In the very end i want to run the random generator and get the ints out
23:32:50 <lokathor> so... I want to map the function over the String... getting [Either String (State StdGen [Int])]
23:32:57 <lokathor> and... i sequence that?
23:33:05 <jle`> do you want short-circuiting behavior?
23:33:15 <jle`> if any of them is a Left, should the whole thing be a Left?
23:33:24 <lokathor> yes
23:33:51 <jle`> then the cleanest solution would be to use ExceptT or StateT
23:33:52 <lokathor> it's parsing input, so if there's an input error it should say so instead of giving a half answer
23:34:06 <lokathor> ah, those Transformer things
23:34:29 <jle`> yeah, in this case it's a pretty straightofrward thing though
23:34:52 <jle`> the main thing to realize is that the transformers are just newtype wrappers, like `Sum` or `First`, to just give different typeclass instances on the same type
23:35:30 <lokathor> i understand most of those words
23:35:47 <jle`> have you ever used `Sum` to give a monoid instance for numbers?
23:35:47 <lokathor> I'm rather hazy on what the old instances were, so i'm not entirely sure what the new instances would be
23:35:50 <jle`> > Sum 1 <> Sum 3
23:35:51 <lambdabot>  Sum {getSum = 4}
23:36:01 <jle`> > Product 1 <> Product 3
23:36:03 <lambdabot>  Product {getProduct = 3}
23:36:15 <lokathor> I... remember that example in LYAH
23:36:27 <jle`> heh.  so normally, State is s -> (a, s)
23:36:36 <lokathor> yes
23:37:16 <jle`> what you want might be an s -> (Either e a, s)
23:37:38 <lokathor> ahhh, yes that looks right
23:37:42 <jle`> either that or an s -> Either e (a, s), but it's more likely the first one.  because then you can get the "last seed"
23:38:27 <lokathor> each letter might be one that reprisents a kind of dice to be rolled. If bad input happens, then it's the e, otherwise it should roll and get the 'a' and a new s
23:38:30 <jle`> so `ExceptT e (State s) a` is a newtype wrapper over s -> (Either e a, s).  so it gives you a Monad instance where (>>=), mapM, traverse, etc., work exactly like you want
23:38:42 <jle`> lokathor: do you want to get the final seed/state if anything fails?
23:39:09 <jle`> if so, then it's the first one.  luckily ExceptT e (State s) a is a newtype wrapper over exactly the type you want, with exactly the instance you want
23:39:24 <lokathor> i suppose it might be handy to have
23:39:38 <jle`> so if you had a `Char -> ExceptT e (State s) [Int]`, then that'd turn a String into an ExceptT e (State s) [[Int]]
23:39:42 <jle`> (when you use traverse/mapM)
23:40:15 <jle`> which has the behavior you wanted
23:40:26 <jle`> and then you can unwrap the newtype afterwards
23:40:42 * hackagebot pg-harness 0.2.0 - REST service and library for creating/consuming temporary PostgreSQL databases  http://hackage.haskell.org/package/pg-harness-0.2.0 (BardurArantsson)
23:40:53 <jle`> > getSum . mconcat . map Sum $ [1,2,3]
23:40:54 <lambdabot>  6
23:40:58 <jle`> it's basically the same as that
23:41:20 <lokathor> at the very top i'll probably be using newStdGen to just get a generator
23:41:34 <lokathor> and if there's a failure, i suppose i won't care what the generator ended up at
23:42:41 <jle`> to make an ExceptT etc., you need ExceptT :: State s (Either e a) -> ExceptT e (State s) a
23:42:58 <jle`> so if you can get a `State s (Either e a)`, then just use ExceptT to wrap it and then it'll do what you want
23:43:24 <lokathor> well
23:43:38 <lokathor> the State StdGen [Int] is picked based on the character
23:43:46 <jle`> and then use (runState . runExceptT) :: ExceptT e (State s a) -> s -> (Either e a, s)
23:43:57 <lokathor> if it's a bad input it can't pick a State function to run, so i think the Either has to be the outer type
23:44:11 <jle`> yeah, i mean, you can get a Char -> State StdGen (Either e [Int])
23:44:15 <jle`> and then compose that to ExceptT and you're good
23:44:59 <jle`> so if f :: Char -> StateT StdGen (Either e [Int]), then ExceptT . f :: Char -> ExceptT e (State StdGen) [Int], a.k.a. what you want
23:45:45 <lokathor> I think `Char -> ExceptT e (State s) [Int]` is more of what i want
23:45:57 <jle`> isn't that what i wrote?
23:46:07 <lokathor> well you've written both ways :P
23:46:14 <jle`> oh, the f signature is wrong
23:46:22 <jle`> the f :: Char -> State StdGen (Either e [Int])
23:46:23 <jle`> sorry :)
23:46:52 <jle`> if your f :: Char -> Either e (State StdGen [Int]), that's ok too, but your traverse behavior will drop the final seed
23:47:04 <jle`> if that's teh case then the newtype wrapper for *that* is StateT
23:47:48 <lokathor> well hmm
23:48:07 <jle`> so if that's the case, you'd use runStateT (traverse (StateT . f) "hello world") intialGen
23:48:16 <jle`> and that'll give you Either e [[Int]]
23:48:24 <jle`> er, Either e ([[Int]], s)
23:48:42 <jle`> if your `f` is already in the Either e (State StdGen [Int]) form, then this is less work :)
23:48:47 <lokathor> well, all input characters must be one of a select allowed set (say "rgb" for now)
23:49:00 <lokathor> the Either is that if some other character is input, it should fail out
23:49:29 <jle`> if your f is already written as Char -> State StdGen (Either e [Int]), then runStateT (traverse (StateT . f) "rgbgb") initialGen will do what you want
23:49:29 <lokathor> i think that means either should be outside, but now i'm seeing how it could go both ways
23:49:46 <jle`> the last one i gave would be either-on-the-outside, so you lose the final state if anything fails
23:50:19 <jle`> the first one i gave is either-on-the-inside, so you get the last observed state before things fail
23:50:37 <jle`> if your f is already the last way, then i suppose you wouldn't miss the final state, and so that works :)
23:53:59 <lokathor> Hmm, well for a given input, i want to do a simulation of many rolls, and i obviously want to maintain the state for a given "simulation session" as i do many trials
23:54:11 <lokathor> but i guess i don't need to preserve it between inputs at all
23:54:23 <lokathor> i can just use newStdGen each time
23:55:13 <jle`> it's up to you :)  if anything you can just manually foldl' over everything
23:55:56 <lokathor> well when i started i was just using fail
23:56:06 <lokathor> then i figured i'd try for some type safety
23:57:13 <jle`> well, the methods now will work and thread the final state from one to use as the starting state of the next.
23:58:16 <lokathor> i guess i want to assemble a single State StdGen [Int], which reprisents all the dice to roll for an input, and then use replicateM to run it many times and give me a list of results
