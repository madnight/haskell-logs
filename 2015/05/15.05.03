00:05:47 <shourya> Sorry, I missed that trizko
00:07:41 * hackagebot stackage 0.7.2.0 - Dummy package forcing installation of other Stackage packages  http://hackage.haskell.org/package/stackage-0.7.2.0 (MichaelSnoyman)
00:07:41 * hackagebot shelly 1.6.2.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.6.2.1 (GregWeber)
00:12:35 * hackagebot packer 0.1.6 - Fast byte serializer and unserializer  http://hackage.haskell.org/package/packer-0.1.6 (VincentHanquez)
00:13:30 <shourya> Hey everyone again.
00:13:41 <shourya> Not many people online?
00:15:22 <srhb> shourya: Plenty, probably.
00:15:43 <shourya> Oh hey srhb
00:15:50 <shourya> Sup?
00:16:49 <shourya> srhb: Sup?
00:17:20 <srhb> shourya: Not much.
00:18:17 <shourya> srhb: Is there anything really great that you can do with Haskell?
00:18:31 <Haskellfant> writing programs is pretty cool
00:21:21 <shourya> Haskellfant: Any examples?
00:23:58 <mniip> main = return ()
00:24:14 <pacak> main = undefined
00:24:21 <mniip> main = main
00:24:29 <Haskellfant> if you want to be really fancy there is also 'main = putStrLn "hello world"'
00:25:11 <pacak> main = undefined undefined
00:25:16 <shourya> Thanks guys.
00:25:22 <Hijiri> main = fix error
00:25:46 <Hijiri> oh, that's not right
00:25:58 <Hijiri> main = putStrLn $ fix error
00:26:04 <mniip> :t fix error
00:26:05 <lambdabot> [Char]
00:26:09 <mniip> yeah
00:26:11 <pacak> main = undefined fix error
00:26:25 <pacak> Everything is better when you have undefined!
00:26:38 <mniip> main = fix (undefined error)
00:27:13 <mniip> in fact, main = fix undefined error
00:30:32 <jle`> haskell can fix your bike too
00:30:35 <jle`> :t fix cycle
00:30:36 <lambdabot> [a]
00:30:54 <Haskellfant> jle`: damn I should have knowh that a few weeks ago
00:34:44 <crocket> I feel condemned.
01:17:38 * hackagebot second-transfer 0.3.0.2 - Second Transfer HTTP/2 web server  http://hackage.haskell.org/package/second-transfer-0.3.0.2 (dsign)
01:34:33 <pacak> "fix has no real use, it's just there so you can type fix error in ghci and feel good about yourself."
01:42:55 <jle`> fix is useful ;_;
01:43:07 <jle`> fix lets you write anonymous functions that are recursive
01:43:26 <jle`> like an anonymous version of `fac 0 = 1; fac n = n * fac (n-1)"
01:43:47 <jle`> it's basically like lambda expressions but for recursive functions
01:47:39 * hackagebot bitcoin-api 0.9.0 - Provides access to the RPC API of Bitcoin Core  http://hackage.haskell.org/package/bitcoin-api-0.9.0 (solatis)
01:52:39 * hackagebot second-transfer 0.3.0.3 - Second Transfer HTTP/2 web server  http://hackage.haskell.org/package/second-transfer-0.3.0.3 (dsign)
01:53:41 <pacak> > fix (\f n -> if n == 1 then 1 else n * f (n - 1)) $ 10
01:53:42 <lambdabot>  3628800
01:56:59 <merijn> Fix is not just useful, it's usually the primitive through which you implement recursive let in your language
01:57:33 <merijn> i.e. during compilation you can rewrite any recursive bindings to using fix and you're done
01:57:45 <merijn> Assuming you managed to implement a fix primitive :p
01:59:15 <pacak> > fix $ (1:) . scanl (+) 1
01:59:16 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
02:04:35 <pingu> Why is the carrier of an algebra called a "carrier"?
02:04:39 <pacak> > fix (\f xxs -> case xxs of { [] -> [] ; x:xs -> if odd x then x:f xs else f xs} ) [1..10]
02:04:41 <lambdabot>  [1,3,5,7,9]
02:05:17 <Dynetrekk> what happens if I filter on an infinite list?
02:05:25 <Dynetrekk> filter even [1..] (or something such)
02:05:33 <jle`> Dynetrekk: expand out the definition of filter to see :)
02:05:37 <kadoban> Dynetrekk: Then you get a new infinite list back.
02:05:42 <pacak> Dynetrekk: Infinite list, buit slightly shorter than the first one.
02:05:49 <jle`> it'll return elements one by one as it finds things that mathces the predicate
02:05:57 <pingu> "shorter" than infinite?
02:05:58 <jle`> > head (filter even [1..])
02:06:00 <lambdabot>  2
02:06:03 <Dynetrekk> kadoban: so if I do head of that list, laziness saves me and I'm fine?
02:06:11 <pacak> pingu: Yep, A few elements less...
02:06:13 <Dynetrekk> if I'm looking for the first instance of some predicate
02:06:19 <jle`> head asks for the first item, so `filter even head` gives the firs item that mathces
02:06:20 <jle`> mhm
02:06:34 <jle`> @src filter
02:06:35 <lambdabot> filter _ []     = []
02:06:35 <lambdabot> filter p (x:xs)
02:06:35 <lambdabot>     | p x       = x : filter p xs
02:06:35 <lambdabot>     | otherwise = filter p xs
02:06:35 <pingu> pacak: fmap (`div 2) $ filter even [1..]
02:06:37 <Dynetrekk> jle`: oh. I did essentially head (filter even xs)
02:06:40 <kadoban> Dynetrekk: Yep, assuming there is a head to get.
02:07:02 <jle`> you can sort of "follow the evaluation"
02:07:13 <jle`> @src head
02:07:14 <lambdabot> head (x:_) = x
02:07:14 <lambdabot> head []    = undefined
02:07:19 <pacak> pingu:  :)
02:07:31 <jle`> if `p x` matches, then it'll be head (x : filter p xs), which is x
02:07:39 <pacak> > head $ fix (\f xxs -> case xxs of { [] -> [] ; x:xs -> if odd x then x:f xs else f xs} ) [1..]
02:07:40 <lambdabot>  1
02:07:51 <jle`> if `p x` doesn't mathc, then it'll be head (filter p xs)
02:07:56 <jle`> which is the first item of the filter in the remainder of the list
02:08:51 <jle`> remember that head (x:xs) ignores xs, so it doesn't need to compute filter p xs if the first item does match
02:08:53 <luzie> > filter even [1..]
02:08:54 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
02:09:14 <jle`> i think a lot of questions like these can just be answered by getting a piece of pencil and paper and manually evaluating the definitoins of everything involved
02:09:20 <merijn> Dynetrekk: I highly recommend reading up a bit on exactly how laziness works to understand how to figure things out like this yourself
02:09:25 <jle`> think of [1..] as 1:2:3:4:5:..
02:09:30 <merijn> I think Apfelmus has a good tutorial
02:09:42 <Dynetrekk> merijn: well I did understand it - it worked the way I thought it would
02:09:43 <merijn> Dynetrekk: https://hackhands.com/guide-lazy-evaluation-haskell/
02:09:45 <pacak> jle`: It ignores x as well
02:10:09 <jle`> well, evaluating head(x:xs) doesn't ignore x
02:10:12 <pacak> > > const () $ head [undefined, undefined]
02:10:13 <lambdabot>  <hint>:1:1: parse error on input ‘>’
02:10:16 <merijn> jle`:  It does
02:10:16 <pacak> > const () $ head [undefined, undefined]
02:10:17 <lambdabot>  ()
02:10:29 <jle`> evaluating the result, i mean
02:10:35 <merijn> pacak: In this context x is already forced due to filter in combination with even :)
02:10:52 <jle`> > head (sum [1..] : [1..])
02:10:52 <caulagi> Do the Run commands depend on procfs being mounted?
02:10:57 <lambdabot>  mueval-core: Time limit exceeded
02:11:12 <Dynetrekk> jle`: thanks or a great explanation
02:11:24 <jle`> usually when we talk about strictness of functions we talk about strictness if the result was evaluated, right? ^_^ but i should have qualified
02:11:35 <Dynetrekk> is it possible to create infinite lists of e.g. even numbers? [3, 6, ...]  or similar?
02:11:36 <merijn> Dynetrekk: I would still recommend at least skimming that link, since it also covers things like "space leaks" due to laziness and the basics of reasoning about complexity in a lazy setting :)
02:11:50 <merijn> > filter (not . even) [1..]
02:11:52 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
02:12:08 <Dynetrekk> merijn: I'll do that! reading "learn yourself a haskell for good" online now
02:12:09 <pacak> caulagi: procfs is useful to have mounted even if it doesn't...
02:12:22 <pingu> not . even seems a little odd ;)
02:12:39 <luzie> > [0,2..]
02:12:40 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
02:12:44 <Dynetrekk> pingu: ["ha",..]
02:12:44 <pacak> pingu: Yep. And the oddest prime number is 2....
02:12:59 <Dynetrekk> pacak: that's the least odd of them all if you ask me
02:13:03 <mniip> Dynetrekk, no instance Enum [[Char]]
02:13:09 <merijn> Dynetrekk: LYAH is good, as introductory text. I think it glosses over the fine details such as *exactly* how laziness works and terms like WHNF (weak head normal form)
02:13:16 <Dynetrekk> luzie: I tried [16, 32, ..] but that failed :P
02:13:31 <mniip> Dynetrekk, you don't need that comma
02:13:48 <Dynetrekk> mniip: ah. now there's my problem
02:13:53 <mniip> [x..] [x,y..] [x..y] [x,y..z]
02:14:07 <caulagi> pacak: i dont have it mounted on freebsd. Is it possible to ask haskell to not depend on it?
02:14:09 <merijn> Dynetrekk: [x, y..z] translates to "enumFromTo x y z" which is basically a step size of "y - x" and then all values between x and z
02:14:09 <mniip> enumFrom, enumFromThen, enumFromTo, and enumFromThenTo respectively
02:14:24 <pacak> > fix ("ha"++)
02:14:26 <lambdabot>  "hahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahah...
02:14:37 <pingu> > fix error
02:14:38 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
02:14:46 <Dynetrekk> merijn: I kinda got the feeling - but I've written just a few 3-5 function programs in 2008 or something. so I'm as fresh as they get, except that I've programmed a bit in imperative langauges before
02:15:19 <Dynetrekk> merijn: python and fortran mostly, a bit of java, C++ and others
02:17:25 <merijn> Dynetrekk: Once you finish LYAH you may want to have a look at https://github.com/bitemyapp/learnhaskell which focusses on "real world" haskell, i.e. the kind of patterns and libraries most people use and more advanced/detailed things
02:22:11 <codygman> How can I parse both jsonStr1 and jsonStr2 into [Tab] using Aeson: http://lpaste.net/131925 Am I on the right track with trying to turn it into a value? http://lpaste.net/131925
02:22:29 <codygman> going to sleep, but will check back for responses in the morning
02:24:09 <Dynetrekk> merijn: thanks for the link!
02:35:50 <karlitios> I do have a questions a function sinature might look like func :: int -> int -> int the "::" is called "is type of" how are the arrows called or pronounced?
02:36:17 <merijn> karlitios: Usually "to"
02:36:41 <karlitios> meriin Thank you
02:36:43 <merijn> i.e. "(+) :: Int -> Int -> Int" "plus has type int to int to int"
02:36:46 <Hafydd> I don't know if I'd say "is type of". That seems to be the reversed relation.
02:37:18 <merijn> Note that lowercase "int" in a type signature would indicate that "int" is a type variable :)
02:38:14 <Hafydd> Floating int => int -> int -> int
02:38:15 <karlitios> Sorry meijn you are right, I meant func::Int->Int->Int :-)
02:38:33 <jle`> i mean, there was nothing wrong with your question; the answer is still the same :)
02:38:43 <merijn> Hafydd: Sounds like an entry for the Obfuscated Haskell contest ;)
02:38:52 <Hafydd> Is there such a contest?!
02:39:01 <merijn> I think it was held once or so
02:39:11 <jle`> it is held every few hours on #haskell actaully
02:39:17 <Hafydd> Hahahaha.
02:39:19 <merijn> Eh, wait, I meant "Isn't that what lens is?"
02:39:31 <jle`> :P
02:39:31 <merijn> https://wiki.haskell.org/Obfuscation
02:39:42 <merijn> Oh, there have been 3
02:41:11 <Hafydd> I see.
02:41:50 <Hafydd> I appreciate the name "Succ Zeroth Obfuscated Haskell Contest".
02:42:22 <merijn> Of course you do, you're reading about haskell obfuscation contests :p
02:42:26 <merijn> That's like a prerequisite
03:10:15 <torulv> Anyone have an idea why I would be getting this error despite having a pragma to allow for it? http://lpaste.net/7559387619168092160
03:11:28 <jle`> torulv: is `payroll-web` installed?
03:11:35 <jle`> and in a place where ghc/cabal would know to look?
03:12:39 <torulv> jle`: heh I don't think so. That is an error I get from haskell-flycheck or flycheck itself and from yesod-devel-beta but not yesod-devel.
03:13:00 <torulv> jle`: How can one package work around not getting this error when another can't?
03:13:34 <jle`> sounds like some yesod machinery i am not qualified to answer questions about :|
03:14:34 <torulv> jle`: Oh man :(
03:15:41 <torulv> jle`: Yeah after running cabal install on it I get no error.
03:16:33 <jle`> i wonder if there's a yesod channel on freenode?  if not, try asking again when other people are online that might be able to help :) or stack overflow is usually prompt too
03:16:37 <torulv> jle`: What is this issue called? I want to google the question "how to work around ...."
03:17:02 <torulv> jle`: There is a yesod channel. However due to time zone issues I don't think people there are awake.
03:17:06 <merijn> jle`: Like maybe #yesod you mean? :p
03:17:14 <jle`> i might call it something about a difference in bethavior from yesod-devel-beta and yesod-devel
03:17:16 <torulv> jle`: There is a yesod channel.
03:17:29 <jle`> like yesod-devel can't find a package that yesod-devel-beta can
03:17:58 <torulv> I was thinking more like "how to work around package imports without installing"
03:18:53 <merijn> torulv: You shouldn't need package imports unless you're doing things you really shouldn't
03:19:17 <merijn> torulv: Why do (you think) you need package imports?
03:19:29 <torulv> merijn: Well it seems that that's what the yesod-scaffold does. It's not my choice.
03:19:49 <torulv> merijn: I can try remove it. Kinda have the power to.
03:21:04 <torulv> merijn: I don't know why the makers of yesod needed package imports.
03:47:44 * hackagebot rspp 0.1.0.0 - A Rational Street Performer Protocol solver  http://hackage.haskell.org/package/rspp-0.1.0.0 (AlexChapman)
04:02:53 * hackagebot syncthing-hs 0.2.0.0 - Haskell bindings for the Syncthing REST API  http://hackage.haskell.org/package/syncthing-hs-0.2.0.0 (JensThomas)
04:03:40 <kuribas> Which editors do you use for haskell?
04:04:45 <kadoban> vim. emacs is also popular
04:05:46 <kuribas> Also on mac or windows?
04:07:19 <kuribas> What would be the most popular haskell editor?  Vim?
04:07:57 <kadoban> Mac should have both probably, windows I have no idea.
04:08:17 <kadoban> And it's probably impossible to tell what is most popular. I certainly don't know.
04:08:39 <saep> Windows has both too. It is just more annoying to set everything up.
04:09:04 <kadoban> Yeah, it takes a while to install linux over it ;)
04:10:19 <saep> I guess that is the reason why people always ask for an IDE. 
04:10:22 <merijn> kuribas: I use vim on OSX and windows, yes
04:10:45 <merijn> gvim on windows actually worked pretty well when I was still regularly using windows
04:11:24 <merijn> I didn't use most of the extensions I do now, but since they're all vimscript I don't see why they wouldn't work
04:12:09 <kuribas> I use emacs on linux, but I wouldn't recommend it to a beginner of haskell and emacs.
04:15:12 <kuribas> Emacs is awesome but also weird.
04:16:50 <ion> Is anyone using something based on ide-backend locally?
04:22:46 <u-ou> i've never even tried emacs
04:22:54 * hackagebot stackage-curator 0.8.1 - Tools for curating Stackage bundles  http://hackage.haskell.org/package/stackage-curator-0.8.1 (MichaelSnoyman)
04:23:22 <u-ou> but then again i'm pretty happy with vim
04:27:54 * hackagebot QuickCheck-safe 0.1 - Safe reimplementation of QuickCheck's core  http://hackage.haskell.org/package/QuickCheck-safe-0.1 (BertramFelgenhauer)
05:03:05 * hackagebot record-aeson 0.1.0.0 - Instances of "aeson" classes for the "record" types  http://hackage.haskell.org/package/record-aeson-0.1.0.0 (NikitaVolkov)
05:13:12 <gremble> Does >>= work as a pipe, i.e. say I have a function evaluating a very large file, reading out binary data from it or something similar, and then I want to do some transformation on the data as it is read in without having to load the entire file into memory and passing a very large chunk around
05:14:59 <xaxes`> hey, guys. I'm trying to understand simpliest monad I've been able to find: http://wklej.org/id/1702363/   It's supposed to return unmodified value, but it return Id Integer(which I can't even show)
05:16:37 <oherrala> xaxes`: try data Id a = Id a deriving (Show)
05:17:23 <oherrala> You can derive the Show typeclass into your type and then it should be able to show it
05:18:03 <xaxes`> oherrala: oh, it works, it displays "Id 5"
05:18:30 <xaxes`> thank you
05:19:28 <oherrala> no problem. Happy to help :)
05:20:34 <ion> Better not jump to Monad skipping Functor and Applicative. Have you read the Typeclassopedia?
05:21:08 <xaxes`> no, I haven't
05:21:26 <xaxes`> I've seen https://www.youtube.com/watch?v=ZhuHCtR3xq8
05:21:58 <kuribas> gremble: It depends.  (>>=) is just the plumbing, it doesn't say anything how it's done.
05:23:18 <gremble> kuribas: Yes. I decided to not be lazy and go look at the wiki and the libraries
05:23:21 <gremble> Thanks though :P
05:23:49 <tempname11_> gremble: if you use standard IO (i.e. readFile), it will do exactly as you say, reading only on demand.
05:24:54 <gremble> tempname11_: file reading was just an example, but I guess the same lazyness answers the underlying question as well. 
05:25:35 <tempname11_> gremble: in the general case the answer is as kuribas said: it depends
05:26:34 <tempname11_> the way readFile does this is a big evil hack
05:26:41 <tempname11_> it's called "Lazy I/O"
05:27:00 <gremble> Why is it evil?
05:28:11 <tempname11_> it kinda breaks referential transparency
05:28:47 <tempname11_> the evaluation of your file's contents will depend on when the file will be closed
05:29:19 <tempname11_> if it's closed early (i.e. manually), then your contents might be incomplete or empty
05:30:00 * gremble makes a mental note of this
05:30:07 <tempname11_> I'm not really an expert on this, so if anyone can correct me, please do
05:31:08 <ion> There are packages that provide a better alternative to lazy IO.
05:31:20 <ion> @hackage conduits
05:31:21 <lambdabot> http://hackage.haskell.org/package/conduits
05:31:37 <ion> @hackage pipes
05:31:37 <lambdabot> http://hackage.haskell.org/package/pipes
05:32:01 <ion> Oh, conduit, singular.
05:48:50 <joehh> anyone used vcache-trie?
05:49:18 <joehh> I can't sem to figure out how to get started
05:53:07 * hackagebot sdr 0.1.0.0 - A software defined radio library  http://hackage.haskell.org/package/sdr-0.1.0.0 (adamwalker)
05:53:34 <gremble> Say I have a type signiture: Contains :: Eq a => a -> Maybe a -> Bool. It means that `a` in that type signiture is derived with the Eq typeclass?
05:55:03 <kuribas> yes, a has a Eq instance.
05:55:24 <gremble> I am slowly but surely learning a haskell, me
05:55:27 <gremble> Thanks kuribas 
05:55:55 <kuribas> np
05:59:39 <ion> gremble: It means the invoker of contains is free to choose any type "a" as long as it is an instance of Eq.
06:03:07 * hackagebot test-invariant 0.3.1.2 - Provide common invariants to be checked with QuickCheck  http://hackage.haskell.org/package/test-invariant-0.3.1.2 (knupfer)
06:12:43 <thelost> msg NickServ thsl 36911801
06:14:14 <thelost> testing
06:23:16 * hackagebot OpenGLRaw 2.5.0.0 - A raw binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGLRaw-2.5.0.0 (SvenPanne)
06:23:18 * hackagebot GLURaw 1.5.0.1 - A raw binding for the OpenGL graphics system  http://hackage.haskell.org/package/GLURaw-1.5.0.1 (SvenPanne)
06:23:20 * hackagebot OpenGL 2.12.0.1 - A binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGL-2.12.0.1 (SvenPanne)
06:23:22 * hackagebot sdr 0.1.0.1 - A software defined radio library  http://hackage.haskell.org/package/sdr-0.1.0.1 (adamwalker)
06:28:16 * hackagebot GLUT 2.7.0.1 - A binding for the OpenGL Utility Toolkit  http://hackage.haskell.org/package/GLUT-2.7.0.1 (SvenPanne)
06:38:17 * hackagebot chatty-utils 0.7.3.0 - Some utilities every serious chatty-based application may need.  http://hackage.haskell.org/package/chatty-utils-0.7.3.0 (implementation)
06:41:27 <kuribas> There are so many frp libs on hackage, it's hard to choose...
06:42:09 <kuribas> reactive-banana looks up to date.
06:43:17 * hackagebot chatty-utils 0.7.3.1 - Some utilities every serious chatty-based application may need.  http://hackage.haskell.org/package/chatty-utils-0.7.3.1 (implementation)
06:44:54 <phaazon> hey guys
06:44:56 <phaazon> I have a problem
06:45:19 <phaazon> I cannot migrate my website from my VPS to my dedicated server because happstack-clientsession doesn’t compile with the latest GHC
06:53:17 * hackagebot random-derive 0.1.0.0 - A Template Haskell helper for deriving Random instances  http://hackage.haskell.org/package/random-derive-0.1.0.0 (frerich)
06:55:17 <JagaJaga> What type does (<-) have?
06:55:24 <srhb> phaazon: Downgrade ghc or fix the package?
06:55:30 <srhb> JagaJaga: None, it's not an operator but syntax.
06:55:43 <phaazon> I’m trying to fix it, yeah
06:55:47 <SrPx> Is there any function on prelude that takes a list such as "abaaccab" and returns the histogram? "[('a',4),('b',2),('c',2)]"
06:55:52 <srhb> a <- b; ...  -- is equivalent to b >>= \a -> ...
06:55:54 <JagaJaga> srhb: but what is it's formal definition? Extract from box? :)
06:56:05 <JagaJaga> srhb: yeah
06:56:07 <srhb> JagaJaga: So it has a very cloes relationship to bind
06:56:10 <srhb> :t (>>=)
06:56:10 <Tehnix> phaazon: or build in in a VM and not on your server :)
06:56:12 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:56:24 <phaazon> Tehnix: I’m soing that
06:56:25 <srhb> JagaJaga: And no, the box analogy only works for a few very specific monads.
06:56:26 <phaazon> in a sandbox
06:56:46 <phaazon> SrPx: hm, I don’t think so
06:56:49 <JagaJaga> srhb: oh, nice.
06:56:54 <phaazon> but you could write it very simply
06:57:52 <Tehnix> SrPx: there are a couple solutions to that problem, but not one single built-in just for if though -- http://stackoverflow.com/questions/7108559/how-to-find-the-frequency-of-characters-in-a-string-in-haskell
06:58:51 <SrPx> Yep, just copypasted that. Thanks (:
07:03:18 * hackagebot lambdabot-haskell-plugins 5.0.2 - Lambdabot Haskell plugins  http://hackage.haskell.org/package/lambdabot-haskell-plugins-5.0.2 (BertramFelgenhauer)
07:03:20 * hackagebot lambdabot-novelty-plugins 5.0.2 - Novelty plugins for Lambdabot  http://hackage.haskell.org/package/lambdabot-novelty-plugins-5.0.2 (BertramFelgenhauer)
07:03:22 * hackagebot lambdabot-reference-plugins 5.0.2 - Lambdabot reference plugins.  http://hackage.haskell.org/package/lambdabot-reference-plugins-5.0.2 (BertramFelgenhauer)
07:03:24 * hackagebot lambdabot-trusted 5.0.2 - Lambdabot trusted code.  http://hackage.haskell.org/package/lambdabot-trusted-5.0.2 (BertramFelgenhauer)
07:03:26 * hackagebot lambdabot 5.0.2 - Lambdabot is a development tool and advanced IRC bot  http://hackage.haskell.org/package/lambdabot-5.0.2 (BertramFelgenhauer)
07:05:24 <int-e> *sigh*
07:06:49 <safinaskar> why this doesn't compile? http://paste.debian.net/171025/
07:07:13 <indiagreen> int-e: why?
07:07:26 <safinaskar> recently similar code compiled. but then i upgraded my debian and tried to install agda (via cabal, with broken packages)
07:07:35 <safinaskar> now this doesn't compile. why?
07:08:18 <srhb> safinaskar: Doesn't m determine e in MonadError?
07:08:28 * hackagebot chatty 0.6.4.0 - Some monad transformers and typeclasses for abstraction of global dependencies.  http://hackage.haskell.org/package/chatty-0.6.4.0 (implementation)
07:08:30 * hackagebot esqueleto 2.2 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-2.2 (FelipeLessa)
07:09:40 <int-e> indiagreen: because I didn't check the git branch before uploading that lambdabot release ... so need another try :/
07:11:42 <bergmark> safinaskar: maybe you got a different version of some library without the needed instance
07:13:19 * hackagebot lambdabot-haskell-plugins 5.0.2.1 - Lambdabot Haskell plugins  http://hackage.haskell.org/package/lambdabot-haskell-plugins-5.0.2.1 (BertramFelgenhauer)
07:13:21 * hackagebot lambdabot-novelty-plugins 5.0.2.1 - Novelty plugins for Lambdabot  http://hackage.haskell.org/package/lambdabot-novelty-plugins-5.0.2.1 (BertramFelgenhauer)
07:13:23 * hackagebot lambdabot-reference-plugins 5.0.2.1 - Lambdabot reference plugins.  http://hackage.haskell.org/package/lambdabot-reference-plugins-5.0.2.1 (BertramFelgenhauer)
07:13:25 * hackagebot lambdabot-trusted 5.0.2.1 - Lambdabot trusted code.  http://hackage.haskell.org/package/lambdabot-trusted-5.0.2.1 (BertramFelgenhauer)
07:13:27 * hackagebot lambdabot 5.0.2.1 - Lambdabot is a development tool and advanced IRC bot  http://hackage.haskell.org/package/lambdabot-5.0.2.1 (BertramFelgenhauer)
07:13:37 <safinaskar> srhb: how to check this?
07:13:55 <kuribas> q/qui
07:14:25 <kuribas> sorry...
07:15:01 <safinaskar> bergmark: okey. so, i tried to install agda via cabal and this agda doesn't compile (and it forced lots of packages including probably parsec and cabal). so, how to remove this broken agda and re-install and re-configure other packages such as parsec?
07:16:07 <bergmark> safinaskar: if you use a sandbox you won't have this problem
07:16:19 <bergmark> safinaskar: but now, rm -rf ~/.ghc to start over
07:17:11 <safinaskar> bergmark: no, that was system operation
07:17:17 <safinaskar> command was: cabal install --global --root-cmd=sudo --upgrade-dependencies --force-reinstall
07:17:20 <elben> I’m going through the NICTA course and have this question, highlighted here: https://github.com/elben/haskell-course/blob/master/src/Course/Apply.hs#L42-L45 Specifically, can a data type get a free implementation of Apply, given it implements Bind and Functor? In my example, I can write the definition of Id’s <*> purely in terms of `map` and `bind`, without caring about the fact that it’s an Id at all
07:17:31 <elben> ^ implementation is line 47
07:17:35 <bergmark> safinaskar: that's terrible
07:17:51 <safinaskar> *cabal install --global --root-cmd=sudo --upgrade-dependencies --force-reinstall agda
07:18:15 <safinaskar> so, how to do this? ^_^
07:18:29 * hackagebot chatty-text 0.6.2.0 - Provides some classes and types for dealing with text, using the fundaments of Chatty.  http://hackage.haskell.org/package/chatty-text-0.6.2.0 (implementation)
07:19:43 <srhb> elben: Yes, Monad is strictly more powerful than Applicative.
07:20:25 <srhb> elben: Oh wait, what do you mean by free exactly?
07:20:46 <elben> erm, a “default” implementation, given the laws of Apply hold
07:20:50 <elben> ^ srhb
07:21:01 <srhb> So <*> in terms of bind and return?
07:21:45 <f|`-`|f> map and bind
07:21:48 <elben> of bind and map, at least according to the context of this course
07:22:53 <srhb> elben: So if you can unwrap the function with bind, you can map over the right hand argument to preserve the f
07:23:24 <ion> JagaJaga: <- is not an operator and thus doesn't have a type. It's syntax. It's mechanically translated to what srhb said.
07:25:02 <srhb> elben: Did that make sense to you? I don't know how much you want me to spoil. :-)
07:25:22 <elben> srhb: makes sense, that is what my example does. 
07:25:52 <srhb> elben: Oh! I didn't notice you'd already done it. :)
07:26:31 <srhb> elben: So basically what you want to know is how to specify a default implementation in a class?
07:26:52 <elben> srhb: I know *how* to do that, but *when*
07:27:13 <elben> srhb for example, if I have my own data type that holds properties of Bind and Functor, does that mean I can get Apply for free?
07:27:23 <srhb> Yep!
07:27:27 <elben> (given I can prove that the laws hold)
07:27:35 <srhb> And that you specify those two instances.
07:27:45 <srhb> And have a default implementation in the class
07:28:19 * hackagebot test-invariant 0.4.0.0 - Provide common invariants to be checked with QuickCheck  http://hackage.haskell.org/package/test-invariant-0.4.0.0 (knupfer)
07:28:21 * hackagebot antisplice 0.17.1.0 - An engine for text-based dungeons.  http://hackage.haskell.org/package/antisplice-0.17.1.0 (implementation)
07:28:26 <JagaJaga> ion: yeah, got it
07:29:20 <elben> srhb: Yes, I see. I know the NICTA course lives in its own little world, so it may not be a 1-to-1 translation to the std lib. 
07:30:37 <srhb> elben: https://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-Base.html#Applicative -- if you're interested
07:30:41 <elben> srhb: So in theory if I had `class (Bind f, Functor f) => YouGetADefaultApply` (or wahtever the syntax is to specify multiple constraints, I don’t know), I can give a default implementation of <*>
07:30:52 <srhb> elben: It doesn't rely on Monad though, but you get the idea I think
07:32:03 <elben> srhb: thank you!
07:33:23 <srhb> elben: So in your case you would have class (Functor f, Monad f) => Applicative f where ...
07:33:31 <srhb> Or well, map and bind
07:34:45 <int-e> Third time ... I hope that's it for now.
07:35:42 <JagaJaga> Why is cps good? When we can use it over non-cps?
07:38:19 * hackagebot chatty-utils 0.7.3.2 - Some utilities every serious chatty-based application may need.  http://hackage.haskell.org/package/chatty-utils-0.7.3.2 (implementation)
07:38:21 * hackagebot lambdabot 5.0.2.2 - Lambdabot is a development tool and advanced IRC bot  http://hackage.haskell.org/package/lambdabot-5.0.2.2 (BertramFelgenhauer)
07:38:23 * hackagebot chatty 0.6.4.1 - Some monad transformers and typeclasses for abstraction of global dependencies.  http://hackage.haskell.org/package/chatty-0.6.4.1 (implementation)
07:38:25 * hackagebot ironforge 0.1.0.35 - A technical demo for Antisplice.  http://hackage.haskell.org/package/ironforge-0.1.0.35 (implementation)
07:38:29 <merijn> JagaJaga: CPS is easier to optimise because it basically makes all functions tail recursive
07:39:12 <merijn> JagaJaga: (The goal of tail recursion is to optimise away the "function call stack frame", which relies on recursive call never needing information from the frame it called from
07:39:31 <merijn> well, tail recursion optimisation, I guess
07:40:26 <merijn> JagaJaga: CPS is also closely related to codensity transformation which can produce speedup by avoiding building up intermediate data structures
07:40:56 <merijn> JagaJaga: The simplest example where you can see this is DList: http://h2.jaguarpaw.co.uk/posts/demystifying-dlist/
07:41:24 <JagaJaga> merijn: it clarifies a lot. thank you. Gonna read your link
07:42:40 <JagaJaga> merijn: can't get where cps is in DList?
07:44:25 <merijn> JagaJaga: It's not directly CPS, but closely related. i.e. CPS is a way of calling functions, DList is analogous for data structures instead of "I have a list" you have "something that when given a list, produces a list"
07:45:14 <merijn> CPS is "given a continuation function, do some work, then call the continuation"
07:45:22 <nkar`> benzrf: how did you find the hole in lambdabot?  were you trying to break it, or was it accidental?
07:45:47 <merijn> DList "given a list, build some datastructure, then return the completed list"
07:46:09 <merijn> JagaJaga: But I have to run, so I can't elaborate on my own intuition for this, sorry!
07:46:20 <JagaJaga> merijn: thank you a lot!
07:49:55 <tempname11_> merijn: that link is very cool
07:53:20 * hackagebot antagonist 0.1.0.26 - A web interface to Antisplice dungeons.  http://hackage.haskell.org/package/antagonist-0.1.0.26 (implementation)
07:54:59 <ion> nkar: Hole in lambdabot?
07:55:50 <Clint> security problem with @check
07:58:02 <uwap> is there a library for eventbased client/server applications? 
07:58:14 <ion> I’m failing at finding the information in the apparently relevant commit or the issue tracker. Would you mind giving more information?
07:59:42 <litb> hello all
07:59:58 <litb> has haskell used any design elements of scala?
08:00:24 <litb> wow and here are 1491 people in this room. i remember when it had only 500 ppl back only a few years ago
08:00:43 <ChristianS> litb: you mean whether haskell had influence on the design of scala? i don't know details, but i would bet on it.
08:00:53 <litb> i mean the other way around
08:00:57 <bernalex> litb: I would think it's more the other way around since haskell is much older. but there is probably some synergy flowing.
08:01:11 <litb> i think i wanted to use the word "borrowed" and I didn't recall it
08:01:22 <litb> so I Wanted to ask "has haskell borrowed any design elements from scala?"
08:02:03 <ChristianS> litb: that way around, no
08:05:23 <srhb> litb: They share a lot of ML ancestry though
08:07:09 <ion> ChristianS: Was that a guess or do you know for certain?
08:08:40 <ChristianS> ion: considering that scala was first released in 2003 and haskell hasn't changed much since haskell 98, it's a pretty educated guess
08:09:18 <ion> GHC Haskell has gained a bunch of things as extensions.
08:09:35 <ion> Equality proofs etc.
08:09:47 <exio4> aren't Arrows, Applicative, ... post-haskell 98? 
08:10:34 <sclv> arrows and applicative aren't language features -- just libraries
08:11:08 <exio4> right, sometimes I forget that they're just libraries :P 
08:13:29 <P4Titan> Hello all, Is there a class in Haskell which defines a function null or something which tests if the input value is empty or not?
08:14:46 <c_wraith> P4Titan: well..  yes.  As of GHC 7.10, Foldable does that.
08:14:51 <c_wraith> P4Titan: the change to add that was sort of contentious, though
08:15:11 <c_wraith> :t null
08:15:12 <lambdabot> Foldable t => t a -> Bool
08:15:34 <hpc> c_wraith: this sounds more like a java programmer's question and Maybe is what's desired, to me
08:15:42 <c_wraith> P4Titan: of course, it's likely you didn't actually *mean* to ask that question..
08:15:45 <c_wraith> as hpc points out
08:15:48 <hpc> P4Titan: can you clarify what you're asking?
08:16:14 <litb> I think he is after Maybe T
08:16:37 <P4Titan> I have a variadic type `s`, but I want to define a function which given a value of type `s` returns if it is empty or not. Also, :)  Java is bad, I never use it nor know it.
08:17:09 <litb> then I think he might be after Boolean
08:17:22 <P4Titan> What do you mean exactly?
08:17:43 <ion> What are you intending to do with that function?
08:17:59 <P4Titan> Test if a given value of type `s` it empty
08:18:07 <ion> in order to achieve what?
08:18:08 <P4Titan> Like s can be a String
08:18:30 <P4Titan> Well, it is the base case of a recursive structure I have where the state, type `s`, becomes empty, it stops.
08:18:44 <c_wraith> P4Titan: "empty" doesn't mean anything if the type happens to be () or Bool or Int or IO (Maybe String)
08:19:04 <ion> What do you do if it is not empty?
08:19:13 <c_wraith> P4Titan: if you really allow *any* type, you have to accept that "empty" doesn't mean anything
08:19:15 <P4Titan> Continue the recursion until it is empty
08:19:45 <P4Titan> c_wraith: I do accept that, although using something like Int would be meaningless. Is there I way that I can limit it to only meaningful types?
08:19:45 <exio4> doing what? if you say "any type" there's no notion of emptyness 
08:20:01 <c_wraith> P4Titan: you almost certainly should deal with this by creating your own data type that describes the exact kind of recurrance relationship and leaf types mean something
08:20:17 <ion> P4Titan: It sounds like you might be looking for Foldable.
08:20:49 <P4Titan> I was thinking of making my own class as there are a few functions that this type `s` should define and include a null function as part of the class
08:21:32 <ion> https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
08:22:12 <c_wraith> eh, making a class isn't always wrong.  But you really should try making a data type first.
08:23:21 * hackagebot haskellscrabble 1.0 - A scrabble library capturing the core game logic of scrabble.  http://hackage.haskell.org/package/haskellscrabble-1.0 (happy0)
08:23:23 <P4Titan> for the state I want to use?
08:23:32 <P4Titan> the state type*
08:23:54 <happy0> hackagebot, that really wasn't worthy of an announcement :P
08:24:15 <c_wraith> For whatever semantic domain the type happens to represent.
08:26:07 <P4Titan> But I want it to be variadic though. Why create my own type?
08:26:18 <Hafydd> It's always a scrabble to get the announcements out as quickly as possible.
08:26:26 <happy0> haha =p
08:27:37 <ion> P4Titan: What are the concrete types you’d like “s” to possibly have?
08:28:25 * hackagebot threepenny-gui 0.6.0.1 - GUI framework that uses the web browser as a display.  http://hackage.haskell.org/package/threepenny-gui-0.6.0.1 (HeinrichApfelmus)
08:29:14 <P4Titan> ion: Most commonly a string, but it could be a list of other things as well
08:29:37 <P4Titan> That is most commonly, but I don't want to limit it to list types though.
08:30:20 <ion> P4Titan: So you’d like it to also support things like Maybe or Tree as input?
08:30:59 <P4Titan> Yes, if it defines the functions of the custom class I make, which would probably be the best way to do this.
08:31:17 <exio4> P4Titan: what are you doing with the values of that type? 
08:31:19 <ion> P4Titan: Still sounds like Foldable already does what you want.
08:31:31 <P4Titan> Parsing them
08:33:25 * hackagebot shelly 1.6.2.2 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.6.2.2 (GregWeber)
08:34:57 <flebron> Hey folks. Say I have an f :: a -> Maybe b, and xs :: [a]. What's the idiomatic way to return Maybe b, that is the first result of applying f to xs that returns a Just, or Maybe if none do? (I guess I'm looking for some nonstandard Monoid instance of Maybe?)
08:35:48 <ion> catMaybes . map f
08:36:09 <flebron> That returns a [b], no?
08:36:35 <ion> listToMaybe . catMaybes . map f
08:36:38 <exio4> ion: catMaybe . map f ~ mapMaybe f? 
08:36:47 <flebron> Heh, fair enough :p
08:36:48 <exio4> flebron: you could use Data.Monoid.First
08:36:56 <kadoban> flebron: msum . map f   ?
08:37:16 <flebron> kadoban: I think that requires a Monoid instance on a, no?
08:37:51 <exio4> it's using Maybe's MonadPlus definition
08:38:03 <ion> exio4: good point
08:38:04 <kadoban> I don't think so, it's MonadPlus which is like, Alternative for Monad IIRC
08:38:08 <exio4> > msum [Nothing, Just 1, Nothing, Just 3] 
08:38:09 <lambdabot>  Just 1
08:38:20 <flebron> Ah, great. That's exactly what I wanted then :) Thanks!
08:38:26 * hackagebot shelly 1.6.2.3 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.6.2.3 (GregWeber)
08:38:26 <kadoban> Sure
08:38:27 * hackagebot keter 1.3.10 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.3.10 (MichaelSnoyman)
08:38:30 * hackagebot QuickCheck-safe 0.1.0.1 - Safe reimplementation of QuickCheck's core  http://hackage.haskell.org/package/QuickCheck-safe-0.1.0.1 (BertramFelgenhauer)
08:38:32 * hackagebot test-invariant 0.4.1.0 - Provide common invariants to be checked with QuickCheck  http://hackage.haskell.org/package/test-invariant-0.4.1.0 (knupfer)
08:38:36 <kuribas> Is it possible to save the state in a FRP program, to handle undo automatically?
08:38:46 <blogle_> anyone know how to add widgets at runtime in vty-ui?
08:39:15 <exio4> @type \f -> getFirst . mconcat . map (First . f)
08:39:16 <lambdabot> (a1 -> Maybe a) -> [a1] -> Maybe a
08:39:47 <ion> mconcat . map f = foldMap f
08:42:08 <exio4> ion: right :P
08:43:42 <kadoban> Isn't there an msum, but for Alternative? What's it called? Or do you just use a fold and (<|>) for some reason?
08:43:55 <ion> asum
08:44:03 <ion> > alaf First foldMap (\x -> if odd x then Just x else Nothing) [0..10]
08:44:04 <lambdabot>  Just 1
08:44:07 <ion> > alaf Last foldMap (\x -> if odd x then Just x else Nothing) [0..10]
08:44:08 <lambdabot>  Just 9
08:44:34 <exio4> @type alaf 
08:44:35 <lambdabot> (Rewrapped s t, Rewrapped t s, Profunctor p) => (Unwrapped s -> s) -> (p r t -> e -> s) -> p r (Unwrapped t) -> e -> Unwrapped s
08:44:46 <kadoban> Nice, thanks. Should have guessed haha.
08:45:33 <exio4> lens has a combinator for everything, doesn't it? 
08:48:26 * hackagebot shelly 1.6.2.4 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.6.2.4 (GregWeber)
08:56:58 <chpatrick1> is there a nice way to get cabal to build code examples but no include them?
08:57:02 <chpatrick1> just to make sure they're not broken
08:58:34 * hackagebot applicative-fail 1.1.0 - Applicative functor and monad which collects all your fails  http://hackage.haskell.org/package/applicative-fail-1.1.0 (AlekseyUymanov)
08:59:59 <tempname11_> reposting from #haskell-beginners: can someone give me an example of a type that is a Foldable, but not a Traversable ?
09:01:10 <hpc> chpatrick1: as in cabal build, or as in a test suite?
09:03:11 <c_wraith> tempname11_: Data.Set.Set
09:03:34 * hackagebot second-transfer 0.3.0.4 - Second Transfer HTTP/2 web server  http://hackage.haskell.org/package/second-transfer-0.3.0.4 (dsign)
09:04:19 <c_wraith> tempname11_: it can't be a valid Traversable because it can't respect Traversable's laws.  But since Foldable more or less doesn't have laws, it can be Foldable
09:06:41 <tempname11_> c_wraith: hmm, which laws?
09:07:09 <tempname11_> Set is also not a Functor, which is required for Traversable
09:07:25 <tempname11_> I'm not sure why, either
09:08:35 <c_wraith> oh.  Right, it's not about the laws, it's just that you can't write an instance
09:08:35 * hackagebot antagonist 0.1.0.27 - A web interface to Antisplice dungeons.  http://hackage.haskell.org/package/antagonist-0.1.0.27 (implementation)
09:09:00 <c_wraith> Set requires an Ord constraint on the contained elements that the types of fmap or traverse can't require
09:09:34 <monochrom> either Set is not a functor (not even morally) or "size" is not parametrically polymorphic
09:10:23 <tempname11_> monochrom: why not morally? I.e. can't it be a FunctorOverEq?
09:10:48 <monochrom> proof: suppose Set s satisfies "size s = 5" and Set is morally a functor. then size (fmap (const ()) s) = 1 ≠ 5.
09:11:18 <tempname11_> why should the size remain constant?
09:11:43 <monochrom> parametric polymorphism.
09:12:41 <kadoban> tempname11_: Because fmap is supposed to preserve the structure of the Functor. It's just supposed to mess with the  'a' part of 'f a', not the 'f' part. It shouldn't change Just a -> Nothing, for instance. That'd be pretty much what it was doing in the Set instance
09:12:57 <monochrom> for example, length::[a]->Int is parametric polymorphic. this implies:
09:13:01 <monochrom> @free length
09:13:02 <lambdabot> Extra stuff at end of line in retrieved type "Foldable t => t a -> Int"
09:13:20 <monochrom> um, length is Foldable now?!
09:13:32 <monochrom> @free len :: [a] -> Int
09:13:32 <lambdabot> len = len . $map f
09:13:52 <monochrom> the $map is "morally functor"
09:15:19 <c_wraith> > length ((), ())
09:15:21 <lambdabot>  1
09:16:30 <tempname11_> kadoban: that's what I thought intuitively, but what law does that violate exactly?
09:18:16 <ion> http://lpaste.net/50278 Functor, Applicative and Monad instances for Data.Set
09:19:53 <c_wraith> ion: does that even compile?  seems like the compiler should complain about not being able to satisfy necessary instance requirements
09:19:59 <kadoban> tempname11_: You can't even get that far, because the type of fmap for Set just doesn't work out. So I don't know that it breaks either existing law, it breaks … some law that would have to be crafted, if you somehow got over the hurdle of the types not even matching I guess?
09:20:23 <kadoban> Or maybe that's wrong, I dunno.
09:20:24 <tempname11_> kadoban: you mean the Ord constraint or what?
09:20:40 <tempname11_> by 'types not matching'
09:20:41 <kadoban> tempname11_: Yeah, exactly. fmap can't have an Ord constraint, but it would have to for Set.
09:21:04 <ion> c_wraith: It compiles, yeah.
09:21:58 <ion> c_wraith: Data.Set provides these handy functions that accept anything, documented with “the precondition is not checked”.
09:22:04 <c_wraith> Oh, I see.
09:22:33 <c_wraith> So they work by giving up the guarantee that the data structure is actually a set.  got it. :)
09:22:54 <ion> So here are these handy instances that accept anything, also documented with “the precondition is not checked”.
09:23:03 <ion> which makes it alright
09:23:19 <c_wraith> The also remove the guarantee that lookup works, even if it is still a set!
09:23:22 <c_wraith> *they
09:29:28 <chpatrick1> getting this:
09:29:29 <chpatrick1> ghc: panic! (the 'impossible' happened)
09:29:29 <chpatrick1>   (GHC version 7.10.1 for x86_64-unknown-linux):
09:29:29 <chpatrick1> 	Dynamic linker not initialised
09:38:35 * hackagebot antagonist 0.1.0.29 - A web interface to Antisplice dungeons.  http://hackage.haskell.org/package/antagonist-0.1.0.29 (implementation)
10:08:31 <athan> What's a good way to render pandoc contents without wrapper html? Like <html>, <title>, etc, and just focus on the contents?
10:09:07 <indiagreen> Pandoc does it by default if you don't pass the --standalone option
10:10:28 <athan> ahh! Thanks indiagreen
10:11:35 <ies> hey guys i'm trying to update cabal on a fresh windows install of the haskell platform but it's failing with this error: http://lpaste.net/279454327741874176
10:13:37 * hackagebot keter 1.3.10.1 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.3.10.1 (MichaelSnoyman)
10:18:37 * hackagebot test-invariant 0.4.2.0 - Provide common invariants to be checked with QuickCheck  http://hackage.haskell.org/package/test-invariant-0.4.2.0 (knupfer)
10:18:39 * hackagebot test-invariant 0.4.3.0 - Provide common invariants to be checked with QuickCheck  http://hackage.haskell.org/package/test-invariant-0.4.3.0 (knupfer)
10:26:35 <phaazon> @pl fmap unlines . readfile
10:26:35 <lambdabot> fmap unlines . readfile
10:26:54 <phaazon> @hoogle FilePath -> IO [String]
10:26:55 <lambdabot> System.Directory findExecutables :: String -> IO [FilePath]
10:26:55 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
10:26:55 <lambdabot> System.Directory findFiles :: [FilePath] -> String -> IO [FilePath]
10:28:35 <maerwald> is there a num type that only allows uneven numbers?
10:30:11 <hodapp> er, I suppose you could do this with type-level naturals
10:30:33 <maerwald> are they legal? sounds like something forbidden :D
10:30:49 <hodapp> they're more ugly than forbidden
10:31:27 <maerwald> want to build kernels for image processing and make sure (at compile-time) to have only matrices with uneven numbers
10:31:36 <maerwald> of rows/cols
10:31:46 <maerwald> as in... the size 
10:31:50 <kuribas> You could define "newtype UnEven = UnEven Int", where UnEven n = n * 2 + 1
10:32:37 <AndoDaan> 1 is uneven.
10:32:50 <AndoDaan> nvm
10:32:51 <zq> better use refinement types
10:32:55 <zq> (:
10:33:05 <kuribas> Hm, but it isn't closed over addition.
10:33:32 <hodapp> maerwald: what is the current method of creating a matrix of a given size?
10:33:53 <hodapp> zq: what, like Liquid?
10:34:08 <maerwald> hodapp: matrix rows columns genFunction?
10:34:34 <maerwald> doing this via maybe types would be pretty ugly
10:34:49 <maerwald> or I can just hope to never get bad input
10:35:07 <Hafydd> If only there were a terser way of expressing "un-even".
10:35:37 <hodapp> maerwald: take a look at https://hackage.haskell.org/package/base-4.8.0.0/docs/GHC-TypeLits.html perhaps
10:35:43 <maerwald> I mean yes... you can technically have non-symmetric kernels I guess. But that's out of scope of my code and I don't want to deal with it.
10:35:53 <mjrosenb> Hafydd: it is rather odd that such a word doesn't exist.
10:36:14 <hodapp> mjrosenb: that's not even funny.
10:37:06 <Hafydd> You're all starting to sound parroty.
10:37:21 <hodapp> maerwald: and I feel like in older versions they had constraints for even & odd 
10:37:47 <maerwald> oh man, this doesn't look easy... I'll guess I will do it the C-way: add a note in the function doc that things will explode if you create non-symmetric matrices :P
10:38:51 <hodapp> maerwald: https://hackage.haskell.org/package/base-4.6.0.1/docs/GHC-TypeLits.html#g:5
10:38:53 <hodapp> ther we go
10:39:13 <maerwald> oh, why is it gone?
10:39:20 <hodapp> who cares, just grab the source
10:40:43 <Hafydd> That reminds me: <phi> wasn’t there some sort of standard notation for the golden ratio? I can’t quite remember it at the moment
10:43:24 <alexv19> @djinn (a -> b -> m c) -> a -> m (b -> c)
10:43:24 <lambdabot> -- f cannot be realized.
10:43:37 <kuribas> Is reactive-banana useful for FRP, with dynamic creation of events?  I read about memory-leaks, and that it cannot garbage collect switched events.
10:43:38 * hackagebot record 0.3.1.1 - First class records implemented with quasi-quotation  http://hackage.haskell.org/package/record-0.3.1.1 (NikitaVolkov)
10:43:40 * hackagebot air 2015.5.4 - air  http://hackage.haskell.org/package/air-2015.5.4 (JinjingWang)
10:43:50 <kuribas> That would make it unusable for a real life app.
10:45:01 <kuribas> Are these leaks related to lazyness?
10:45:18 <ion> Hmm, GHC 7.10.1 lets me do “data Foo (n :: Nat) where { Foo :: (m ~ (n+1)) => proxy m -> Foo n }” which prevents me from constructing Foo (Proxy :: Proxy n) where n < 1, and “(m ~ (2*n))” which prevents odd values of n, but it fails to solve “(m ~ (2*n+1))” which would prevent even values.
10:45:29 <alexv19> @djinn (b -> m c) -> m (b -> c)
10:45:29 <lambdabot> -- f cannot be realized.
10:46:15 <Hafydd> f g x = g x >>= 
10:46:17 <Hafydd> Whoops.
10:50:59 <srhb> ion: The nat constraint solver is very weak now. You can enable a different one via plugins in 7.10
10:53:58 * alexv19 slaps lambdabot around a bit with a large trout
10:54:08 * hackagebot air-extra 2015.5.4 - air-extra  http://hackage.haskell.org/package/air-extra-2015.5.4 (JinjingWang)
10:54:10 * hackagebot moe 2015.5.4 - html with style  http://hackage.haskell.org/package/moe-2015.5.4 (JinjingWang)
10:54:12 * hackagebot markup 0.0.7 - Abstraction for markup languages  http://hackage.haskell.org/package/markup-0.0.7 (athanclark)
10:54:14 * hackagebot nemesis 2015.5.4 - a task management tool for Haskell  http://hackage.haskell.org/package/nemesis-2015.5.4 (JinjingWang)
10:54:16 * hackagebot hack2-contrib 2015.5.4 - Hack2 contrib  http://hackage.haskell.org/package/hack2-contrib-2015.5.4 (JinjingWang)
10:55:55 <alexv19> @djinn Monad m => (b -> m c) -> m (b -> c)
10:55:55 <lambdabot> -- f cannot be realized.
10:56:47 <ion> what is this i don’t even
10:57:01 <ion> “An alternative Haskell Prelude library” (.) :: a -> (a -> b) -> b http://hackage.haskell.org/package/air-2015.5.4/docs/Air-Light.html
10:57:21 <hpc> that's no longer Prelude
10:57:28 <ion> https://github.com/nfjinjing/air-extra/blob/master/src/Air/Extra.hs#L42
10:57:31 <Hafydd> Imagine (FileName -> IO String) -> IO (FileName -> String).
10:57:44 <hpc> better to use acme-php instead
10:58:13 <Hafydd> Or (String -> Maybe Int) -> Maybe (String -> Int).
10:59:18 * hackagebot geek 1.1.1.0 - Geek blog engine  http://hackage.haskell.org/package/geek-1.1.1.0 (JinjingWang)
11:00:43 <ansible1> anyone have a recommendation for getting started with the RWST stuff?  LYAH is out of date it seems.
11:01:18 <gfixler> what's more common, RecordPuns or RegularPatterns?
11:01:56 <kadoban> ansible1: IIRC typeclassopedia mentions them and has pointers that I found useful. I can't remember how indirect from there the stuff I read/did was, but I remember starting there.
11:06:34 <ansible1> ok thanks kadoban
11:10:54 <ReinH> ion: eighth :: [a] -> a
11:10:56 <ReinH> why
11:14:08 * hackagebot informative 0.1.0.7 - A yesod subsite serving a wiki.  http://hackage.haskell.org/package/informative-0.1.0.7 (implementation)
11:14:49 <ReinH> ion: oh god, it's so you can write Haskell that looks like Ruby
11:14:54 <ReinH> 1.to_s
11:16:56 <ion> He actually has “don't :: Monad m => m a -> m ()” which is the same as in the ACME package.
11:17:17 <ReinH> ion: So you can't write I.don't.even
11:17:49 <maerwald> isn't it annoying that prelude has all those fold functions automatically imported for Lists only which have a more generic type in Data.Foldable?
11:18:05 <maerwald> so you end up hiding them manually
11:18:10 <ion> maerwald: Look at the current version of base.
11:18:47 <ReinH> maerwald: Yes, that's why it was fixed recently
11:19:02 <kadoban> :t foldr -- 7.10 wooo
11:19:02 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
11:19:22 <maerwald> oh
11:19:49 <maerwald> that could mean that my base is out of date :P
11:19:51 <Iceland_jack> :t foldr :: (a -> b -> b) -> b -> [a] -> b
11:19:52 <lambdabot> (a -> b -> b) -> b -> [a] -> b
11:20:32 <kadoban> maerwald: 7.10 is pretty new and not necessarily all that well supported yet though
11:26:40 <_di> why does fmap (*2) (1,2) apply *2 to second element only?
11:27:08 <Iceland_jack> _di: Do you know which Functor instance that uses?
11:27:10 <_di> or.. why not to first element
11:27:24 <_di> yes, I saw sources 
11:27:42 <kadoban> _di: You probably want something from Arrow if you want to do both.
11:27:48 <_di> http://hackage.haskell.org/package/base-4.8.0.0/docs/Control-Monad-Instances.html
11:27:49 <ion> di: fmap :: Functor f => (a -> b) -> f a -> f b; setting f = (,) z: fmap :: (a -> b) -> (,) z a -> (,) z b
11:27:50 <Iceland_jack> or Control.Bifunctor
11:27:55 <Iceland_jack> Okay _di, assume that
11:27:56 <Iceland_jack>     type Pair a b = (a, b)
11:27:59 <ion> di: The type dictates the behavior.
11:28:08 <Iceland_jack> Then the type of fmap is
11:28:08 <Iceland_jack>     fmap :: (a -> b) -> Pair e a -> Pair e b
11:28:23 <Iceland_jack> Does that make sense _di
11:28:29 <_di> yep
11:28:33 <mjrosenb> _di: because (a,b) is (,) a b, and (,) a is a functor, but you can't make it go the other way easily.
11:28:45 <Iceland_jack> _di: 'Pair' is *not* a Functor 
11:28:50 <Iceland_jack> 'Pair e' is a Functor
11:28:53 <_di> now it makes sense
11:28:56 <Iceland_jack> Okay :)
11:29:00 <_di> thanks :)
11:29:03 <Iceland_jack> Same situation with 'Either e'
11:29:09 * hackagebot step-function 0.1.0.1 - Step functions, staircase functions or piecewise constant functions  http://hackage.haskell.org/package/step-function-0.1.0.1 (petterb)
11:29:12 <Iceland_jack>     fmap :: (a -> b) -> Either e a -> Either e b
11:29:23 <Iceland_jack> 'fmap' can only modify the second parameter of Either
11:29:25 <_di> also, what's the point of ((,) e) represents a container which holds an “annotation” of type e ? 
11:29:26 <ion> and (->) r
11:29:35 <_di> (I am reading https://wiki.haskell.org/Typeclassopedia#Functor)
11:29:49 <Iceland_jack> _di: Do you know Writer?
11:30:18 <Iceland_jack> > (["succ"], succ) <*> (["five"], 5)
11:30:19 <lambdabot>  (["succ","five"],6)
11:30:30 <_di> I dont think so. I read monad tutorials multuple times. Now organizing everything again with typeclassopedia
11:30:32 <Iceland_jack> You can think of it as logging
11:31:02 <_di> what is an annotation type?
11:31:34 <Iceland_jack> There is really no such thing, it refers to a Monoid
11:31:52 <Iceland_jack> @src Monoid
11:31:52 <lambdabot> class Monoid a where
11:31:53 <lambdabot>     mempty  :: a
11:31:55 <lambdabot>     mappend :: a -> a -> a
11:31:57 <lambdabot>     mconcat :: [a] -> a
11:32:32 <Iceland_jack> _di: lists are Monoids, as you could see in the earlier example
11:32:45 <_di> yup
11:33:13 <_di> thanks, now it makes more sense!
11:33:16 <Iceland_jack> So if you're emitting source code (in a compiler) you could use something like Strings
11:33:54 <andreasd_> Test
11:33:58 <Iceland_jack> You could also accumulate source code locations, an aggregate of payments (numbers orm a Monoid), basically anything you can think of
11:39:35 <sinelaw> hey, is there a way to tell ghc to implicitly import some module? I want it together with NoImplicitPrelude 
11:39:50 <sinelaw> (basically to replace the default Prelude)
11:40:18 <zq> how the actual f does mdo work god
11:40:41 <ion> zq: It’s automatically translated to as small as possible “rec” blocks, which are in turn translated to mfix invocations.
11:41:11 <zq> i should rephrase -- how does one read mdo
11:43:37 <ReinH> _di: ((,) e) represents the fact that ((,) e) has a law-abiding implementation of fmap
11:43:54 <ReinH> It doesn't imply anything about containers or tagging
11:44:06 <ReinH> er, instance Functor ((,) e) does
11:44:28 <ion> > mdo { xs <- Identity ('0':xs); return xs }
11:44:30 <lambdabot>  <hint>:1:10:
11:44:30 <lambdabot>      parse error on input ‘<-’
11:44:30 <lambdabot>      Perhaps this statement should be within a 'do' block?
11:44:31 <ReinH> That's something you might use ((,) e) for, not something denoted by the type
11:44:55 <ion> = do { rec { xs <- Identity ('0':xs) }; return xs }
11:45:22 <ion> > do { xs <- mfix (\xs' -> Identity ('0':xs'); return xs }
11:45:23 <lambdabot>  <hint>:1:44: parse error on input ‘;’
11:45:36 <ion> > do { xs <- mfix (\xs' -> Identity ('0':xs')); return xs }
11:45:36 <ReinH> ion: missing a )
11:45:37 <lambdabot>  Identity "000000000000000000000000000000000000000000000000000000000000000000...
11:46:07 <Iceland_jack> zq: I use it when emitting LLVM assembly code
11:46:27 <Iceland_jack> May be a better motivator than toy examples 
11:46:44 <zq> Iceland_jack: yeah i'm having mega trouble understanding how to read it
11:47:01 <Iceland_jack> zq: If you need to jump to a label before you've created the label, mdo is very nice to have
11:47:09 <ion> zq: Do you understand the example of mdo → do rec → mfix above?
11:47:16 <ReinH> Iceland_jack: bloom filters form a commutative monoid, so you can easily share them in a distributed state machine by sharing monoid actions.
11:48:46 <ReinH> so you can easily make a distributed bloom filter :)
11:49:46 <Dynetrekk> https://gist.github.com/anonymous/f355500caef487bbe4be <- I'm trying to parse "2345234" into [2, 3, 4, ...] (ints). what am I doing wrong?
11:50:32 <Iceland_jack> ReinH: Yes monoids everywhere :)
11:50:40 <Iceland_jack> Dynetrekk: 'x' is a Char
11:50:46 <Iceland_jack> read needs a string
11:50:58 <ion> Dynetrekk: map digitToInt
11:51:05 <Iceland_jack> > map (\x -> digitToInt x) "2345234"
11:51:07 <lambdabot>  [2,3,4,5,2,3,4]
11:51:17 <Iceland_jack> which is equivalent to what ion wrote
11:51:21 <Dynetrekk> Iceland_jack: aaah.
11:51:41 <Iceland_jack> If you want to use read you can
11:51:41 <Iceland_jack> > map (\x -> read [x]) "2345234" :: [Int]
11:51:42 <lambdabot>  [2,3,4,5,2,3,4]
11:52:39 <ReinH> (because "x" = ['x'])
11:53:14 <Dynetrekk> ReinH: thanks, get the point
11:53:29 <Dynetrekk> ReinH: I think mostly in python/Fortran where the string/char split doesn't really exist
11:53:37 <worldsayshi> Is it possible to use a flag such as defer-type-errors in cabal repl?
11:54:15 <ion> Dynetrekk: Note that both digitToInt and read crash with invalid input.
11:55:24 <Dynetrekk> ion: I'm so far at the "project Euler" style programs. exceptions are not my 1. concern
11:57:18 <Dynetrekk> ion: digitToInt "Not in scope"
11:57:23 <ion> @hoogle digitToInt
11:57:23 <lambdabot> Data.Char digitToInt :: Char -> Int
11:57:23 <lambdabot> Data.Text.Internal.Read digitToInt :: Char -> Int
11:57:23 <lambdabot> Data.Text.Internal.Read hexDigitToInt :: Char -> Int
11:57:29 <ion> import Data.Char
11:57:32 <Dynetrekk> ion: right
12:02:50 <worldsayshi> Here’s the answer to my previous question: http://stackoverflow.com/questions/25323686/how-to-set-ghci-options-for-cabal-repl
12:08:47 <Dynetrekk> https://gist.github.com/Dynetrekk/171df3d21b5aed4ce2bf <- any advice on how to improve the program? (solves project Euler prob. 8.)
12:11:01 <ion> At each step of the iteration, length xs will traverse through the whole remainder of the list.
12:12:24 <Dynetrekk> ion: ah. that is silly indeed. any obvious better solution?
12:12:41 <Dynetrekk> ion: I guess I'm used to the length operation being O(1) not O(n)
12:13:06 <geekosaur> so use a data structure which has O(1) length. lists aren't it
12:13:28 <Dynetrekk> geekosaur: I get that, now
12:13:42 <Dynetrekk> geekosaur: do arrays exist?...
12:14:27 <geekosaur> Data.Array, but they're kinda low level; I would recommend looking at Vector first
12:14:46 <sx> Is there some type class used for pretty text output with predefined instances? (Show seems not right to me)
12:14:50 <Dynetrekk> geekosaur: ok. I guess my program is fast enough (TM) though, but I'll keep it in mind
12:15:25 <Raydiation> what does in production haskell look like? small parts are pure functions and the entry level of the function is basically a do where you set the order?
12:16:04 <jeltsch> geekosaur: Is there a type Vector in the standard libraries?
12:16:28 <sx> jeltsch: no, not in base
12:16:29 <Raydiation> aka do parseCustomer >> validateCustomer >> storeCustomer >> respond
12:16:40 <jeltsch> Dynetrekk: I suggest using the Seq type from Data.Sequence (from the containers package).
12:16:46 <geekosaur> insofar as the Platform is considered the standard libraries (for now at least), yes
12:17:03 <geekosaur> people like ot think that standard libraries = what comes with ghc
12:17:03 <jeltsch> geekosaur: Where is this Vector type and what is it about?
12:17:11 <geekosaur> ghc does not want to be the standard libraries
12:17:31 <sx> Raydiation: what is "production haskell"?
12:17:53 <jeltsch> geekosaur: I would say if you want lists with efficient length queries, concatenation, etc., then use Data.Sequence.Seq.
12:18:00 <geekosaur> http://hackage.haskell.org/package/vector
12:18:05 <Raydiation> sx: what i mean is haskell that is used as an application and not a lib
12:18:11 <Dynetrekk> jeltsch: why isn't Seq the default instead of List then? seems nicer in this respect
12:18:19 <Raydiation> a website for instance
12:18:19 <geekosaur> that may well be, although Seq has its own issues
12:18:29 <Dynetrekk> geekosaur: e.g.?
12:18:38 <ion> Dynetrekk: To get windows of 13 elements to a list, you can use map (take 13) (tails xs). That will result in the final 13 windows being shorter than 13, though. You can use this trick to efficiently drop the final 13 elements from any list: dropTail n xs = zipWith const xs (drop n xs)
12:18:45 <geekosaur> Dynetrekk, the thing about lists in functional languages is that they are loops encoded as data
12:19:03 <sx> Raydiation: Well, the same basically. You use pure code as much as possible and the other things can be monadic style code.
12:19:05 <geekosaur> which is how you do things in functional languages; the data structure is primary
12:19:10 * hackagebot computations 0.0.0.0 - Advanced notions of computation  http://hackage.haskell.org/package/computations-0.0.0.0 (WolfgangJeltsch)
12:19:39 <jeltsch> Dynetrekk: The ordinary list type [] is simpler, its implementation is public, and it can be very good for handling streams of data, because of lazyness.
12:19:42 <jeltsch> With Seq, only the elements are lazy.
12:19:51 <ysr> is it valid to have type synonym with type variables like type Series a = [(Maybe a)]
12:19:52 <jeltsch> So you cannot have infinite Seqs, for example.
12:19:54 <Dynetrekk> jeltsch: good point
12:20:01 <Rotaerk> ysr, yea
12:20:02 <jeltsch> ysr: Perfectly valid.
12:21:16 <jeltsch> geekosaur: Well, this loops-as-data thing is one way to see lists. You can also just see them as lists additionally. :-) 
12:21:31 <geekosaur> you can but they are inefficient for that use
12:21:42 <jeltsch> geekosaur: Depends.
12:22:02 <jeltsch> Not always you need efficient concatenation and such.
12:22:14 <ion> > let dropTail n xs = zipWith const xs (drop n xs) in (dropTail 3 . map (take 3) . tails) [0..10]
12:22:15 <lambdabot>  [[0,1,2],[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10]]
12:22:43 <jeltsch> But yes, this loops-as-data thing is one of those things you cannot do with Seq.
12:24:11 <Dynetrekk> jeltsch: I saw an interesting talk by Stroustrup (the C++ guy) stating that linked lists are less efficient than arrays for concatenation. seemed plausible to me
12:24:49 <jeltsch> Dynetrekk: This is, of course, true, but you do not need concatenation all the time.
12:25:21 <jeltsch> Dynetrekk: One nice example, where ordinary Haskell lists (essentially linked lists) are perfectly fine (and using Seq would thus be just overkill):
12:25:23 <Dynetrekk> jeltsch: agree
12:25:54 <Dynetrekk> I'm not arguing, I'm 100% fresh to the language :) just trying to get into the mindset
12:25:55 <jeltsch> Dynetrekk: Say you what to represent a list with a position.
12:26:08 <jeltsch> For example, the tape of a Turing machine with the read–write head.
12:26:24 <jeltsch> Or a list of pictures with a marker what the current picture is.
12:26:49 <jeltsch> As operations you only need navigation to the left and navigation to the right (one step).
12:27:05 <jeltsch> You represent this as a pair of lists (xs, ys).
12:27:07 <Dynetrekk> jeltsch: you're tempting me to write a brainfuck interpreter in hsaskell?
12:27:17 <Dynetrekk> jeltsch: that is indeed nice
12:27:19 <jeltsch> Dunno. :-) 
12:27:35 <jeltsch> The list ys contains the elements starting at the head/position to the right.
12:27:39 <Dynetrekk> reminds me of a lisp tutorial I did once, which led me to forgetting completely about lisp 
12:27:58 <jeltsch> The list xs contains the elements to the left of the position, but in reverse order
12:28:08 <jeltsch> Then you have this:
12:28:25 <jeltsch> stepLeft (x : xs) ys = (xs, x : ys)
12:28:35 <jeltsch> stepRight xs (y : ys) = (y : xs) ys
12:28:48 <jeltsch> Both run in constant time, i.e., O(1).
12:29:16 <jeltsch> The cool thing: because of lazyness, both xs and ys can be infinite, so your tape (or whatever it is) can be infinite to both sides!
12:29:33 <jeltsch> Very good if you want to implement a Turing machine interpreter.
12:29:57 <jeltsch> The tape of a Turing machine is automatically extended with blanks when running over the marging.
12:30:27 <jeltsch> Alternatively, you could say that it is initially infinite on both sides and initialized to all blanks.
12:30:31 <jeltsch> So you have:
12:30:51 <jeltsch> initialTape = (repeat blank, repeat blank)
12:31:32 <jeltsch> Lazy evaluation with evaluate the expressions “repeat blank” (thus generating new blanks) as needed.
12:33:11 <jeltsch> Dynetrekk: I used this approach for a fractal generator, where I had a list of pictures with different levels of detail, together with a current position that the user currently sees.
12:33:43 <jeltsch> The actual implementation was actually done by a student, but the idea with the lists was by me. ;-) 
12:33:56 <jeltsch> See here: http://hackage.haskell.org/package/3d-graphics-examples
12:34:16 <jeltsch> Later I learned that this structure is actually a special example of a zipper.
12:34:27 <jeltsch> Okay, enough monologue. ;-) 
12:35:09 <Pamelloes> But monologues are fun :)
12:36:06 <Dynetrekk> jeltsch: that's a pretty good monologue, as rants go etc. thanks!
12:36:23 <Dynetrekk> ooh, L systems, I've always wanted to write one, but never did
12:36:54 <Dynetrekk> and Brownian motion, too
12:38:03 <Pamelloes> I'm trying to create a class along the lines of (MyClass a, MyClass b a) => MyClass2 b, which won't compile normally. I was told I had to use the constraints package, which I've read through and more or less understand what the types are. However, I have no idea how to use them to accomplish my desired constraint. Can someone give me some pointers?
12:38:52 <Dynetrekk> one more noob question for tonight - what does runhaskell do? compile and run, or interpret/ghci style?
12:39:43 <Dynetrekk> just wondering if there are any performance implications
12:39:50 <jeltsch> Dynetrekk: It read a Haskell source file (whose name you provide at the command line) and runs it in the interpreter.
12:40:00 <jeltsch> Dynetrekk: You get the performance of GHCi.
12:40:00 <fate_> one NOOB question : why do people use haskell?
12:40:03 <jeltsch> As far as I know.
12:40:09 <unknownloner> What does it mean when there's a ! in front of a type, like !Text or !Int
12:40:14 <Dynetrekk> jeltsch: so it's way slower than ghc file.hs; ./file ?
12:40:40 <jeltsch> Dynetrekk: Well, GHCi still uses compiled code for libraries.
12:40:42 <unknownloner> (specific example is defining a data type with records)
12:40:56 <KaneTW> unknownloner: it's a strictness declaration
12:41:08 <unknownloner> What does that mean?
12:41:12 <Dynetrekk> jeltsch: so only my code is interpreted? sounds slow for e.g. explicit recursion
12:41:13 <jeltsch> Dynetrekk: How much slower it is depends on your Haskell file (e.g., how much it makes use of libraries).
12:41:30 <sx> unknownloner:  strict evaluation, in records it means there is no pointer overhead (and therefore no bottom possible), in function arguments you need the BangPatterns extension afaik
12:41:32 <Dynetrekk> jeltsch: sure, so it's along the lines of python (fast if you're operating on large data chunks using libs)
12:41:33 <jeltsch> Dynetrekk: Well, just try for you specific case how much slower it is.
12:41:49 <unknownloner> ok
12:41:52 <Dynetrekk> jeltsch: was just wondering in general, whether there might be a point at all
12:42:09 <jeltsch> Dynetrekk: runhaskell is good for scripts written in Haskell. (Haskell as a better Shell ;-) I use this approach sometimes.)
12:42:30 <Dynetrekk> jeltsch: you're saying you use haskell for shell type operations?
12:42:50 <Dynetrekk> (bash, zsh)
12:42:59 <sx> Dynetrekk: additionally you can always use :! to execute arbitrary shell commands
12:43:19 <Dynetrekk> sx run by $SHELL ?
12:43:44 <sx> Dynetrekk: in ghci, you can for example type: :!pdflatex foo.tex
12:43:52 <sx> Dynetrekk: really helpful :)
12:44:01 <Dynetrekk> like gnuplot and many others
12:44:04 <Dynetrekk> cool
12:45:03 <sx> Dynetrekk: otherwise have a look at https://hackage.haskell.org/package/turtle
12:45:08 <KaneTW> unknownloner: essentially
12:45:16 <KaneTW> ?let data Strict = Strict Int !Int
12:45:18 <lambdabot>  Defined.
12:45:24 <Arayth> Excuse me, could someone help me out with my code, please? #haskell-beginners didn't respond 
12:45:26 <KaneTW> > (\(Strict _ _) -> 1) $ Strict 1 undefined
12:45:29 <lambdabot>  *Exception: Prelude.undefined
12:45:29 <KaneTW> but
12:45:34 <KaneTW> > (\(Strict _ _) -> 1) $ Strict undefined 1
12:45:35 <Dynetrekk> sx: jesus. this is a little crazy, but why not
12:45:37 <lambdabot>  1
12:45:39 <KaneTW> works fine
12:45:58 <unknownloner> thanks
12:57:35 <frerich> Arayth: What code?
12:57:47 <Arayth> This: http://lpaste.net/6735104109969408000
12:57:54 <Arayth> I can't figure out what patterns I'm missing
12:58:09 <ion> Arayth: Are you compiling with -Wall?
12:58:57 <Arayth> I'm using FPComplete with warnings enabled, so I suppose so, yes
12:59:15 <ion> It at least should tell you about missing patterns.
12:59:59 <frerich> Arayth: Try running it through 'ghc -Wall' on the commandline.
13:00:19 <frerich> Arayth: It'll tell you which patterns are not matched exactly.
13:03:30 <Arayth> can't seem to find the command line in FPComplete, I'll run it in ghci, one sec
13:07:26 <Arayth> It's still telling me the same as before, that the patterns are non-exhaustive, which is where I'm stuck
13:08:03 <ion> It should list the missing patterns.
13:09:09 <Arayth> it doesn't, so I probably did something incorrectly
13:09:16 <ion> Can you pastebin the full output?
13:09:50 <ion> You did remember -Wall, did you?
13:09:56 <Arayth> yeah
13:12:13 <ysr> what am I doing wrong here: http://lpaste.net/131932
13:12:41 <srhb> ysr: What's Series?
13:12:55 <codygman> How can I parse both jsonStr1 and jsonStr2 into [Tab] using Aeson: http://lpaste.net/131925 Am I on the right track with trying to turn it into a Value? http://lpaste.net/131925
13:12:55 <ysr> it is a type synonym for [Maybe Int]
13:13:24 <srhb> ysr: Ok, then the problem is only the constraints
13:13:33 <ysr> It says illegal ploymorphic or qualified type
13:13:41 <srhb> ysr: https://wiki.haskell.org/Data_declaration_with_constraint
13:14:11 <Arayth> ion: here's the output http://lpaste.net/892053527579328512
13:14:17 <srhb> ysr: Actually the accepted answer here is probably better: http://stackoverflow.com/questions/12770278/typeclass-constraints-on-data-declarations
13:14:51 <srhb> Arayth: You use -Wall as a parameter to ghc/ghci, not from within ghci
13:15:16 <ion> Arayth: ghci -Wall H2-2.hs
13:15:27 <Arayth> oh, I see
13:15:32 <srhb> Arayth: But I think you can do :set -Wall from within ghci
13:16:45 <ysr> so, I shouldn't do it?
13:17:07 <Arayth> hm, now it's just telling me my function is not in scope
13:17:25 <srhb> Arayth: Exactly what did you write on the command line?
13:18:04 <srhb> ysr: Yeah the GADT way is fine
13:18:30 <Arayth> I changed the GHCi Startup under Options to ghc --interactive -Wall (and also tested :set -Wall afterwards)
13:18:59 <srhb> Arayth: I don't know which options you're talking about. Anyway, the command line that ion gave you should suffice to get the error message
13:19:12 <srhb> So on your shell write (exactly) ghci -Wall H2-2.hs
13:21:11 <Arayth> hm can't get it to work, maybe because I'm using windows?
13:21:25 <srhb> Arayth: Should work the same, as long as ghci is on your path.
13:21:31 <srhb> Arayth: What does "can't get it to work" mean?
13:21:40 <ion> Arayth: Please pastebin the command you ran and the output from your terminal.
13:21:42 <srhb> Specific error messages help us help you. :)
13:22:10 <Arayth> k, one sec
13:22:32 <srhb> My guess is you could probably still achieve the same with :set -Wall and then :reload from within ghci, but not being able to use ghc/ghci from your terminal is going to be a huge pain anyway, so you should probably fix it.
13:27:11 <Arayth> Here's the output, the file should be in the correct directory, but I guess not http://lpaste.net/4678261249920729088
13:27:43 <srhb> Arayth: Indeed, did you check? :)
13:28:14 <Arayth> WinGHCI has always worked for me, so it's weird GHCi wouldn't ^^ and yeah, I'm trying to figure it out at the moment
13:32:24 <Cale> Arayth: According to what I see there, the file ought to be C:\Users\Arayth\H2-2.hs 
13:32:43 <Arayth> yeah, that's where it's currently at
13:33:54 <ion> Does “dir” in the same terminal window confirm it?
13:42:34 <Arayth> I seem to have screwed up GHCi entirely now, Prelude can't even find ghci anymore <.< 
13:43:07 <ion> “Prelude> ” means you are already in ghci.
13:43:29 <ion> “C:\blahblah\> ” means you’re outside ghci, in cmd.
13:43:29 <Arayth> well, but it was able to load it again when I used the command
13:43:37 <srhb> Which command?
13:43:54 <Arayth> ghci -Wall
13:44:18 <srhb> If that worked, you were not inside ghci.
13:44:25 <srhb> You seem to be confusing your shell with ghci. :)
13:45:37 <Arayth> ...that might be the case
13:45:42 <srhb> Hehe.
13:45:52 <srhb> From your shell (cmd) you can start ghci with various arguments
13:45:59 <srhb> One being -Wall, the other being the filename
13:48:57 <alynn> https/w 5
13:48:59 <alynn> urgh
13:49:01 <alynn> bad at irssi
13:53:42 <Arayth> I'm back, sorry about that, got booted from my network
13:54:34 <Accidus> wb
13:54:53 <Arayth> thanks
13:58:02 <kaeluka> I just opened the rust book (nightly) and am trying to run `cargo test` with this code: https://gist.github.com/kaeluka/9b9bb034ce5fda93a501. when cargo is trying to compile the code in the documentation’s example section, it fails with `error: unresolved name `sum``. Anyone knows why?
13:58:08 <ysr> what is the most common way to read a webpage in haskell?
13:58:29 <kaeluka> and i posted to the wrong channel. sorry!
13:58:52 <ysr> :)
13:59:02 <ysr> kaeluka is rust stable yet?
13:59:15 <kaeluka> it seems so
13:59:41 <kaeluka> you can download 1.0.0-beta.3 on rust-lang.org
14:00:13 <ysr> kaeluka will check it out, thanks ;)
14:00:33 <kaeluka> haha, sure! good thing I misposted here then..
14:01:00 <kaeluka> btw, click my link: it compiles+typechecks code examples in the documentation. awesome
14:02:11 <mbuf> is there a simple example to demonstrate scotty with sqlite3 connectivity (PUT, GET)?
14:05:49 <Arayth> ion: I got the command and ghci -Wall to run (thanks), but the patterns being listed seem super excessive... is that normal?
14:07:50 <ion> Arayth: Would you mind pastebinning the function along with the listed patterns? Let’s figure it out.
14:08:06 <Arayth> ion: sure, one sec
14:09:13 * hackagebot filesystem-trees 0.1.0.6 - Recursively manipulate and traverse filesystems as lazy rose trees.  http://hackage.haskell.org/package/filesystem-trees-0.1.0.6 (AdamCurtis)
14:09:15 * hackagebot network-uri 2.6.0.3 - URI manipulation  http://hackage.haskell.org/package/network-uri-2.6.0.3 (EzraCooper)
14:09:40 <Arayth> ion: http://lpaste.net/379839790897430528
14:11:28 <lpaste> nocturne777 annotated “StateT compilation issue” with “StateT compilation issue (annotation)” at http://lpaste.net/1296899060455702528#a131936
14:12:00 <nocturne777> In the pasted example, I am getting the error shown in the annotation
14:12:28 <nocturne777> could someone help me understand what's causing this error?
14:13:06 <ion> Arayth: Let’s consider the first one. ([], _:_, _). A minimal value matching that would be ([], [y], []) and none of the patterns in the function match that indeed.
14:14:44 <ion> Arayth: Perhaps it would be best to try to find a failing case and return False for that and then have a final pattern for anything else (discException _ = True).
14:15:03 <Arayth> hm I'll try that, thanks
14:15:19 <ion> Arayth: What would be a minimal tuple for which the test fails?
14:16:10 <ion> or should fail
14:16:10 <Arayth> well, the first two elements of each list need to be compared, and if the first element is larger, it fails
14:16:53 <ion> Arayth: So what would be the first pattern to try for False?
14:17:04 <Arayth> so would pattern matching for (x1:x2:_,_,_) etc. with if else cases work?
14:18:06 <Arayth> hm
14:18:29 <ion> Arayth: Nice, that is indeed the first minimal pattern to try. You could make that work with if/case but it’s more convenient to use pattern guards here. discException (x1:x2:_, _, _) | x1 > x2 = False
14:18:44 <Arayth> ah, I see
14:19:35 <ion> You don’t need an | otherwise case for that pattern, the final discException _ = True will take care of that.
14:20:38 <oneeman> nocturne777: state :: Monad m => (s -> (a, s)) -> StateT s m a
14:21:26 <Arayth> nice, that works
14:21:47 <Arayth> thank you
14:22:21 <ion> Arayth: To make this less repetitive, you can create a function that checks a single tower and another that tests a triple with that function.
14:23:34 <nocturne777> oneeman: I know 
14:23:44 <Arayth> sorry, it's been a long day, I'm not sure what repetition you're referring to
14:24:22 <ion> Arayth: Your code has three lines like “discException (x1:x2:_, _, _) | x1 > x2 = False” now, one for each tuple member, right?
14:25:08 <Arayth> but isn't that standard fare for pattern matching?
14:26:48 <nocturne777> oneeman: I have not been able to figure it out
14:27:02 <nocturne777> what would fix the compilation problem?
14:27:38 <slack1256> Anyone had tried to translate haddock documentation into gnu info format?
14:27:55 <slack1256> I've tried haddock -> html -> pandoc info but the result is subpar
14:27:58 <Arayth> so even if it requires extra lines of code to split it up into two functions, it'll still worth it to be considered well-structured code?
14:28:07 <oneeman> nocturne777: wish I could help you, but I'm still a newbie, haven't made it to monad transformations yet
14:28:09 <Arayth> still be*
14:28:32 <ion> Arayth: “foo (a:b:_,_,_) | bar a b = False; foo (_,a:b:_,_) | bar a b = False; foo (_,_,a:b:_) | bar a b = False; foo _ = True” vs.
14:28:38 <ion> Arayth: “foo (a,b,c) = fooItem a && fooItem b && fooItem c; fooItem (a:b:_) | bar a b = False; fooItem _ = True”
14:29:09 <ion> Arayth: The latter implements the logic of matching the list pattern and checking against a predicate just once.
14:30:47 <Arayth> I see what you mean
14:30:56 <nocturne777> oneeman: I figured it out
14:30:59 <nocturne777> :)
14:31:00 <ion> Arayth: It’s easier to test in isolation, too.
14:31:20 <Arayth> I honestly can say I wouldn't have thought of writing it like that, however 
14:31:24 <oneeman> nocturne777: nice!
14:31:56 <Arayth> the second function's syntax is still somewhat beyond me
14:33:29 <ion> Arayth: It’s exactly the same thing as in the first one, with just a list as the input instead of a tuple of lists.
14:34:19 <Arayth> I haven't come across semicolons in Haskell code as of yet, at least not in the tutorial I'm reading
14:34:25 <Arayth> so that throws me a bit off
14:34:33 <ion> Oh, that’s just equivalent to a newline.
14:35:15 <srhb> Arayth: You should definitely get rid of those in favor of indentation, it's just easier to convey over IRC like that :) (without spamming the channel, at least)
14:35:33 <Herogx> Woow so many people :o
14:35:52 <jacereda> hi... I'm trying to build a shake-based build system and I'm now facing a problem that is driving me nuts. Basically, it seems as if record update wasn't working properly, I always get "Missing program name" when using 'luaexe' http://lpaste.net/2391663443699564544
14:36:01 <Arayth> so fooItem and such don't belong to foo(a,b,c) anymore?
14:36:53 <ion> Arayth: https://gist.github.com/ion1/75f5367fdd53410155f4
14:37:26 <Arayth> okay, yeah, that makes a lot more sense
14:37:32 <Arayth> thanks
14:38:27 <Arayth> ion: can I ask you one more question with regard to the semantics of my code?
14:38:36 <ion> sure
14:39:14 * hackagebot shelly 1.6.2.5 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.6.2.5 (GregWeber)
14:39:16 <geekosaur> jacereda, I think we'd have to see a bit more
14:39:41 <jacereda> geekosaur: should I just paste the whole thing?
14:39:53 <geekosaur> ideally, yes
14:40:03 <Arayth> ion: in line 33-35 of my pasted code earlier, I'm trying to remove the head of the list while also returning it to the calling function, but it won't remove it - is there a way to solve it elegantly without using standard library functions?
14:40:26 <jacereda> http://lpaste.net/5557793732356472832
14:41:19 <jacereda> hmmm, are those warnings/errors in lpaste.net the result of a linter or something?
14:41:30 <jacereda> I'm compiling with -Wall and I don't get those
14:41:41 <geekosaur> yes, it's run through hlint
14:42:39 <geekosaur> this is where the upcoming traceback stuff would be nice...
14:43:03 <jacereda> how do I get a traceback?
14:44:47 <Herogx> Arayth: remove the head of a list and then return the head?
14:44:56 <Herogx> get_list_head (x:xs) = x
14:45:16 <ion> Arayth: First of all, i’d suggest you disconnect the logic of handling a list of moves from “move”, making it move :: Move -> Towers -> Towers. You can then use foldl' to apply multiple moves.
14:45:21 <geekosaur> jacereda, currently you don't, that's the point. well, there's a somewhat lame one where you build with profiling and run with +RTS -xc but it's not very good
14:45:29 <geekosaur> the code is still in development
14:45:54 <Arayth> could other functions see that get_list_head in a where block?
14:46:22 <Herogx> i mean you could just use head xs
14:46:36 <Arayth> ion: I honestly haven't ever used foldl before, I'll have to do more of the tutorial first, I guess
14:46:37 <geekosaur> ghc 7.12 should produce somewhat useful traceback information from error
14:46:38 <ion> Arayth: Second, unless you’re planning to generalize your program to games of more than three towers, you could create a new data type for the tower identifier that does not have as members invalid towers. data TowerId = T1 | T2 | T3 deriving (Eq, Ord, Show) for instance.
14:47:14 <Arayth> Herogx: I used head, but that only returns the head and doesn't remove it from the list, which is my current problem
14:47:49 <geekosaur> you aren't looking for it to just modify the list in place, are you?
14:48:09 <Herogx> Pretty sure you can't do that
14:48:29 <geekosaur> indeed
14:48:31 <Herogx> someone correct me if I'm wrong, because I'm new as well, but doesn't immutable state transfer to lists as well
14:48:39 <ion> Arayth: Then: moveFrom T1 (x:xs,_,_) = x; moveFrom T2 (_,x:xs,_) = x; moveFrom T3 (_,_,x:xs) = x
14:49:18 <jacereda> the backtrace doesn't seem very informative: http://lpaste.net/8957879488151027712
14:50:02 <Arayth> ion: well, aside of the heads, the program is already working as intended, I'd rather just get it to work properly before rewriting the basic parts
14:50:55 <geekosaur> yes, I said the current backtrace stuff isn't very good...
14:52:11 <ion> Arayth: Ah, i see your problem.
14:53:07 <ion> Arayth: Both moveFrom and moveTo need to return a new, modified Towers. Then you’ll need to compose them.
14:53:18 <jacereda> the rest of the code is just scripts used to build different libraries, the problematic one: http://lpaste.net/8828985621222522880
14:54:02 <jacereda> and the main module: http://lpaste.net/6599822819217899520
14:54:02 <Arayth> ion: I suppose I should write an extra function for that and not write too much into the otherwise line?
14:54:37 <ion> Arayth: moveFrom :: Position -> Towers -> (Int, Towers); moveFrom 1 (x:xs, ys, zs) = (x, (xs, ys, zs)); moveFrom 2 (xs, y:ys, za) = (y, (xs, ys, zs)); moveFrom 3 (xs, ys, z:zs) = (z, (xs, ys, zs))
14:55:40 <ion> Arayth: moveFrom will return the removed disc as well the new state of the towers. moveTo will then add the removed disc to its new position and return the new state of the towers.
14:56:36 <Arayth> that's... rather sound, thanks
14:56:37 <ion> When you get this working, it would be good to start using Maybe to handle errors (invalid moves including moves from empty towers).
14:56:53 <Arayth> I probably should've figured that out by myself heh
14:58:02 <geekosaur> jacereda, from what I see, defLinkPrg is pulling a bunch of things from prg, which is not a parameter and therefore will be pulling from the one with the error calls in it
14:58:15 <geekosaur> record updates do not change prg, they return a copy of it
14:58:51 <jacereda> geekosaur: doh! Thanks! At some point I renamed the argument and messed it
14:59:49 <ion> Arayth: For now, you can add a final case: moveFrom _ _ = error "Invalid move". But using “error” to crash is bad form.
15:00:49 <Arayth> ion: got it, thanks
15:01:05 <ion> Arayth: In the future, moveFrom will look like: moveFrom :: Position -> Towers -> Maybe (Int, Towers); moveFrom T1 (x:xs, ys, zs) = Just (x, (xs, ys, zs)); …; moveFrom _ _ = Nothing
15:01:42 <ion> Arayth: Or if you want to output the error message: moveFrom :: Position -> Towers -> Either String (Int, Towers); moveFrom T1 (x:xs, ys, zs) = Right (x, (xs, ys, zs)); …; moveFrom _ _ = Left "Invalid move"
15:01:58 <ion> Arayth: The tutorial will cover Maybe and Either unless it already has done so.
15:02:15 <Arayth> ion: I'm completely unfamiliar with that terminology, but I'll write it down for later
15:06:47 <jacereda> Is there some {-# LANGUAGE JustCreateAutomagicallyTheFreakingShowInstancesForFunctions #-} ? 
15:06:48 <jacereda>  
15:07:50 <ion> What would that instance look like?
15:08:05 <jacereda> show _ = "<function>" 
15:08:07 <jacereda> or whatever
15:08:45 <Enigmagic> there is one somewhere in base
15:09:13 <Iceland_jack> Enigmagic: I think you're talking about a show instance for functions, not deriving Show for data types with functions
15:09:24 <jacereda> I don't care how it's shown, I just want to embed some functions in my records and still be able to use 'deriving Show'
15:09:49 <jacereda> at the end of http://lpaste.net/5557793732356472832 I have a bunch of those
15:09:59 <Enigmagic> Iceland_jack: doesn't deriving just want a Show instance for each field?
15:10:11 <jacereda> just to be able to derive Show for my records, is there some less silly way to do it?
15:10:42 <Enigmagic> jacereda: http://hackage.haskell.org/package/base-4.4.0.0/docs/src/Text-Show-Functions.html 
15:11:01 <Iceland_jack> Enigmagic: that still won't work
15:11:20 <Iceland_jack> You can try writing
15:11:20 <Iceland_jack>     ghci> import Text.Show
15:11:20 <Iceland_jack>     ghci> data T = T (Int -> Int) deriving Show
15:11:21 <dredozubov> jacereda: http://hackage.haskell.org/package/base-4.8.0.0/docs/Text-Show-Functions.html
15:11:29 <Iceland_jack> oops! haha
15:11:33 <Iceland_jack> Enigmagic: How wrong I was ;)
15:11:59 <jacereda> it worked!
15:12:23 <jacereda> just import Text.Show.Functions() and I'm happy again, thanks
15:12:28 <Iceland_jack> Thanks Enigmagic! I was certain I tried this a long time ago and it failed, this will be useful
15:12:49 <Enigmagic> Iceland_jack: i've been bitten by it once or twice...
15:12:55 <Enigmagic> but it is useful when you need it :-)
15:13:11 <ion> showsType, huh?
15:13:22 <Iceland_jack> Too bad you need to enable it for the entire module if you just want it for a single data type..
15:27:55 <Arayth> ion: sorry to bother you again, but I can't figure out these type errors in my functions :x http://lpaste.net/3335092592684564480
15:30:04 <ion> Arayth: Please annotate the paste with the errors you get.
15:31:13 <ion> moveTo ((endPos x) moveFrom (startPos x) t) tries to apply “endPos” to “x”, “moveFrom”, “startPos x” and “t”.
15:31:34 <ion> moveTo (endPos x) (moveFrom (startPos x) t)
15:32:03 <Arayth> ion: oh, sorry, here you go: http://lpaste.net/3335092592684564480#a6649896537251905536
15:34:50 <ion> Does correcting the parentheses solve the error?
15:36:04 <Arayth> ion: yep, thank you very much
15:49:44 <ion> Arayth: You can get rid of moveException because now moveFrom and moveTo check the positions (and in the future, a data type like data Position = P1 | P2 | P3 will not even let you generate an invalid value). It would also be best for moveTo to do the check for too large disc because it’s the one adding them to towers. move will then just compose moveFrom and moveTo. Something like: moveTo 1 (x, (xs, ys,
15:49:46 <ion> zs)) = (place x xs, ys, zs); …; place a (b:bs) | a > b = error "Invalid move"; place a bs = a:bs (again, the error call will be replaced with better error handling).
15:51:18 <ion> Arayth: You can also use pattern matching in move to get the start and end positions directly. move ((start,end):xs, t) = (xs, moveTo end (moveFrom start t))
15:52:44 <Arayth> ion: hm, yup, definitely improvements, thanks
15:52:46 <ion> Arayth: And the list “xs” is useless in move. Getting rid of it: move (start,end) t = moveTo end (moveFrom start t) (this changes the type of move).
15:55:14 <Arayth> ion: huh, yeah, looks like I should do a lot of refactoring
16:01:17 <subleq__> I need to parse a pretty simple command line, something like: prog [-h] [-v] [bindaddr [port]]
16:01:24 <subleq__> Should I just do it manually or use a library?
16:01:41 <ion> @hackage optparse-applicative
16:01:41 <lambdabot> http://hackage.haskell.org/package/optparse-applicative
16:03:06 <subleq__> seems complicated
16:03:21 <pacak> :t getArgs
16:03:22 <lambdabot> Not in scope: ‘getArgs’
16:03:48 <pacak> getArgs :: IO [String] 
16:06:37 <Herogx> wow that's a pretty awesome bot
16:06:45 <Herogx> :t ()
16:06:46 <lambdabot> ()
16:06:49 <Herogx> :O
16:07:41 <pacak> > fix $ (1:) . scanl (+) 1
16:07:42 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
16:16:23 <P4Titan> Hello all, If I have a data type like data SomeType s = ... where s is a dynamic type, is there a way to add a class limit to the data itself on s or I have to do the Ord s => every time in a function containing SomeType?
16:19:00 <Enigmagic> P4Titan: you can add constraints to functions (including data constructors)
16:19:22 <P4Titan> How does a contraint work with a data constructor?
16:19:44 <kadoban> P4Titan: It should just be on the functions. There was (or maybe still is?) a way to add it to the type, but it was not a good feature AFAIK and was either removed or just nobody uses it.
16:19:44 <ion> You can use {-# LANGUAGE GADTs #-} data Foo a where { Bar :: Ord a => a -> Foo a } and values constructed with Bar will carry proof of Ord a, but using trivial data types and having the constraints in the functions isn’t necessarily bad.
16:20:42 <ronh> kadoban I remember something similar existed, and that it wasn't considered a good feature, but I can't recall why
16:20:47 <P4Titan> So the best way to do it is to add a SomeConstraint s => ... to each function
16:20:48 <ronh> what was wrong with it?
16:21:34 <kadoban> I can't recall offhand XD
16:21:43 <Enigmagic> ronh: it didn't remove the requirement to add constraints to every function, so it didn't actually do much of anything
16:22:11 <Enigmagic> there is also a view that constraints are for functions, not data
16:23:35 <Arayth> ion: all right, I'm heading out now, thanks again for all the help, I really appreciate it
16:23:42 <ion> Arayth: np
16:24:10 <ronh> it prevented creation of types that weren't terribly useful though, like Map NotOrd Int?
16:25:34 <ronh> I mean, if Map was written with such a constraint, would undefined :: Map NotOrd Int give a compile error?
16:27:02 <Enigmagic> ronh: that seems to typecheck for me, so i don't think it does.
16:30:58 <ion> @let data Foo a where { Bar :: Ord a => a -> Foo a }
16:30:59 <lambdabot>  Defined.
16:31:06 <ion> @type undefined :: Foo (IO ())
16:31:07 <lambdabot> Foo (IO ())
16:31:19 <ion> Nothing prevents that.
16:32:05 <Enigmagic> @let data Ord x => X x
16:32:05 <lambdabot>  .L.hs:153:6:
16:32:05 <lambdabot>      Illegal datatype context (use DatatypeContexts): Ord x =>
16:32:16 <Enigmagic> he was asking about that form ^^^
16:32:27 <Enigmagic> which also typechecks
16:57:42 <georgyy> hello. can you make list comprehensions go through multiple lists in parallel, instead of going through all the possible combinations?
16:57:59 <Iceland_jack> georgyy: Yes, ParallelListComp...
16:58:13 <Iceland_jack>     [ x + y | x <- xs | y <- ys ]
16:58:13 <Iceland_jack> is the same as
16:58:13 <Iceland_jack>     zipWith (+) xs ys
16:58:20 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#parallel-list-comprehensions
17:02:31 <georgyy> thanks. would zipWith be usually prefered over list comprehensions or the other eay around? how about map and LCs
17:03:30 <Iceland_jack> georgyy: List comprehensions are rarely the idiomatic way of writing it these days
17:03:42 <Iceland_jack> but they have their uses that make them worth while
17:04:02 <Iceland_jack> That are sadly not that greatly appreciated
17:04:14 <subleq__> How do I do an optional positional argument with a default with optparse-applicative?
17:11:16 <Herogx> Iceland_jack: I'm really new to Haskell and list comprehensions thus far are one of my favourite features 
17:14:20 <Iceland_jack> Herogx: Yes they are fantastic, but when you get to a certain level you start writing in a different style
17:15:33 <Herogx> Probably, I wouldn't know though, only been using the language about 5 months now
17:16:06 <nshepperd> you can of course do [x + y | (x,y) <- zip xs ys] also..
17:16:10 <Iceland_jack> Yes
17:17:18 <Iceland_jack> Herogx: Usually something like
17:17:18 <Iceland_jack>     foo xs = sum [ 1 + x | x <- xs ]
17:17:18 <Iceland_jack> can be written
17:17:18 <Iceland_jack>     foo xs = sum (map (1 +) xs)
17:17:25 <Iceland_jack> Which is the same as
17:17:25 <Iceland_jack>     foo = sum . map (+ 1
17:17:30 <Iceland_jack> *   foo = sum . map (+ 1
17:17:35 <Iceland_jack> haha, damnit
17:17:35 <Iceland_jack> *   foo = sum . map (+ 1)
17:17:46 <ronh> now fix that ugly space and you're golden :P
17:18:13 <georgyy> list co
17:18:13 <haasn> I find list comprehensions to be the most useful when you need to mix them with pattern matching
17:18:18 <Herogx> I can write functions like that already
17:18:23 <Iceland_jack> haasn: Bingo
17:18:26 <haasn> eg. [ x | C x <- xs ]
17:18:28 <Herogx> except I still prefer list comprehensions in some cases
17:18:30 <Iceland_jack> @src catMaybes
17:18:31 <lambdabot> catMaybes ls = [x | Just x <- ls]
17:18:42 <Iceland_jack> Herogx: This is a great use case for list comprehensions
17:18:43 <ion> Does anyone use the "then group by using" stuff? I never even remember it exists. I was reminded by the link.
17:18:52 <Herogx> Generally if something is producing a list, my opinion is that it should be a list comprehension if it can be
17:18:55 <georgyy> list comprehensions are one of the few things in haskell familiar from other languages
17:18:56 <Iceland_jack> But there is an even more interesting one that people don't mention much
17:19:04 <JagaJaga> Having such code https://gist.github.com/a710e4802cf4cc3520d4. Is there a way to make function `compute` returns stack too? Or it's impossible because of types?
17:19:19 <ion> colist mprehensions
17:19:23 <haasn> list comprehensions and do-notation are very related, incidentally
17:19:29 <haasn> (especially if you turn on MonadComprehensions)
17:19:35 <haasn> the former is sort of like C#'s Linq
17:19:40 <Herogx> I'm not that far into the language yet :P
17:19:48 <Herogx> Monads are still a mystery but I will get there
17:20:23 <geekosaur> JagaJaga, perhaps you want to return a tuple. in which case maybe you;'re using the stack as state and you want the State (or STateT) monad
17:20:24 <Iceland_jack> Herogx: Don't worry about Monads
17:20:34 <bergmark> Monads keep changing. They used to be like burritos, now i think they are like parrots or something?
17:20:53 <Iceland_jack> Monads don't keep changing :)
17:20:55 <Herogx> only ones I actually know how to use are io/file io and the random one
17:21:08 <Herogx> university project requires me to
17:22:12 <geekosaur> @unmtl State AbstractStack Integer
17:22:12 <lambdabot> AbstractStack -> (Integer, AbstractStack)
17:22:18 <ronh> Maybe monad is the easiest one to understand probably
17:22:39 <JagaJaga> geekosaur: in this case I'm using AbstractState as an "interface"
17:22:59 <JagaJaga> geekosaur: but as you can see in `clist*` I have another return type
17:23:00 <ronh> identity monad is even simpler, but it is (seemingly) useless and weird
17:23:42 <JagaJaga> geekosaur: but I can use this with the help of existential type of AbstractStack
17:24:21 <JagaJaga> geekosaur: but I can't understand can we or can't (and why) we return the stack itself
17:24:21 <Iceland_jack> ronh: The point was not to find a simple example to explain, but to explain something else (prerequisites, ...)
17:24:44 <geekosaur> (Integer,AbstractStack) a tuple, as I said
17:24:53 <Iceland_jack> Monads are /the/ XY problem ;)
17:25:06 <nshepperd> ronh: try the trivial monad :) 'data Trivial a = Unit'
17:25:33 <Herogx> I can't imagine they're that hard to understand, though I don't really have time during this semster to sit down to them
17:25:45 <Iceland_jack> Herogx: Do you understand Functors?
17:25:52 <Herogx> yea somewhat
17:26:00 <Herogx> Something that can be mapped to/whatever, right?
17:26:04 <Herogx> like a list or no...?
17:26:23 <Iceland_jack> I suggest being more clear about Functor than that
17:26:45 <JagaJaga> geekosaur: getting http://pastebin.com/NbtBNxbw
17:26:48 <Iceland_jack> and making sure you've written the Functor instance for at least several familiar data types and used them in code
17:27:27 <geekosaur> that error doesn't mean much without the code that produced it
17:27:34 <kadoban> The NICTA course is great for that, if you have done enough to be able to understand it, even if slowly.
17:27:35 <Iceland_jack> and getting a feel for the Functor laws (that are quite intuitive and simple) is a good bonus :)
17:27:38 <Herogx> Didn't realise that they were that important, I'll read more into them
17:28:26 <Iceland_jack> Herogx: For example, do you know that (.) is just 'fmap' with a more restrictive type?
17:28:26 <JagaJaga> geekosaur: cahnged type of compute to AbstractStack -> (Integer, AbstractStack) and returning (v + v2, stk2)
17:28:48 <ion> Herogx: The Typeclassopedia is a good guide.
17:28:52 <Herogx> Nope! I've been learning from learn you a haskell, and I'm only reaching the end of the book now
17:29:26 <geekosaur> hm, I guess that would happen with the forall-ed types
17:29:28 <Iceland_jack> Herogx: I would also (strongly) suggest something if you're interested
17:29:39 <kadoban> Herogx: You should look at https://github.com/bitemyapp/learnhaskell , it's more practical and hands-on. LYAH is easy to read and kinda understand and … not really be able to do anything with.
17:30:00 <Herogx> what is with the overtly friendly community here lol
17:30:10 <Herogx> I'm absolutely interested, haskell is my favourite language
17:30:13 <georgyy> learning from Learn you a haskell as well, applicatives chapter is where my understanding stops. 
17:30:13 <Iceland_jack> Herogx: Add ":set -XInstanceSigs" to your ~/.ghci file
17:30:24 <kadoban> XD Yeah, #haskell is way different than most of the other programming channels.
17:30:59 <Herogx> Why, Iceland_jack?
17:31:11 <Iceland_jack> Herogx: This allows you to write type signatures for type class instance methods
17:31:12 <Iceland_jack>     instance Functor Maybe where
17:31:12 <Iceland_jack>       fmap :: (a -> b) -> (Maybe a -> Maybe b)
17:31:12 <Iceland_jack>       fmap f Nothing  = Nothing
17:31:15 <Iceland_jack>       fmap f (Just x) = Just (f x)
17:31:16 <geekosaur> because the result type is specified by the caller, not by you
17:32:14 <Iceland_jack> Herogx: This may seem like a minor change, but it will help you to write the types of your methods specific to that instance
17:32:24 <Iceland_jack> *it will let you
17:32:27 <Herogx> I've already made the change :P
17:32:31 <JagaJaga> geekosaur: so I can't do that?
17:32:32 <Iceland_jack> Which often clarifies a lot
17:33:10 <Iceland_jack> Herogx: Can you define "instance Functor [] where ..."
17:33:27 <Herogx> I just tried the code you put in chat, it works
17:33:44 <ion> http://i2.kym-cdn.com/entries/icons/original/000/010/496/asdf.jpg #Haskell explaining Peano arithmetic and proofs via Curry-Howard to you when you asked how to sum numbers.
17:34:17 <Iceland_jack> haha I always try to avoid doing that
17:34:28 <Iceland_jack> I sometimes get ahead of myself
17:36:31 <geekosaur> JagaJaga, ther existentials are going to prevent you returning the AbstractStack, yes. a type-parameterized stack instead of an existential one would be more useful here but I'm not sure if you can actually use it
17:36:55 <JagaJaga> geekosaur: thank you, that helps me :)
17:37:19 <gfixler> Herogx: we're friendly because we need more people! It's a small community.
17:37:41 <Herogx> gfixler: I'll be sure to teach my other coursemates haskell over summer
17:37:54 <gfixler> Herogx: the friendliest forum I've ever been to was an assembly language forum, because they hadn't seen any new people in a decade
17:38:09 <gfixler> they were practically offering to drive to my house to teach me assembly
17:38:46 <Herogx> haha
17:40:02 <Iceland_jack> gfixler: hahah
17:40:23 <Herogx> I think haskell is a little bit more useful than assembly lol
17:40:26 <Herogx> In a relative sense
17:40:39 <gfixler> I write my haskell in assembly
17:40:46 <Herogx> o-o
17:40:47 <Iceland_jack> I write my assembly in Haskell
17:40:52 <Herogx> haha
17:40:54 <Iceland_jack> wish I were kidding :)
17:41:36 <ion> Haskembly
17:45:10 <georgyy> do you need to understand applicatives before learning monads?
17:45:21 <simpson> georgyy: Not necessarily.
17:45:33 <Iceland_jack> georgyy: I would recommend it but you don't have to
17:51:27 <athan> If, categorically, functors are morphisms between categories, and monads are monoids in the category of endofunctors, are what are applicative functors? :|
17:51:44 * athan bites off more than mouth can chew
17:52:11 <unknownloner> How can I include a literal "#" in a hamlet template?
17:52:28 <unknownloner> aside from #{"#"} because that'd probably work
17:52:35 <unknownloner> but seems dirty
17:52:41 <Cale> athan: Well, they're a special sort of monoidal functors.
17:52:51 <Cale> :t liftA2 (,)
17:52:52 <lambdabot> Applicative f => f a -> f b -> f (a, b)
17:52:57 <Cale> :t uncurry (liftA2 (,))
17:52:57 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
17:53:05 <athan> hm!!
17:53:36 <Cale> :t pure ()
17:53:37 <lambdabot> Applicative f => f ()
17:53:38 <unknownloner> nvm that doesnt work anyway
17:54:24 <Cale> athan: pure () and uncurry (liftA2 (,)) along with fmap provide enough information to recover pure and <*>
17:54:31 <krixa> :t liftA3 (,,)
17:54:32 <lambdabot> Applicative f => f a -> f b -> f c -> f (a, b, c)
17:55:01 <Iceland_jack> athan: “However, in the category-theory community, it is known that lax monoidal functors are monoids with respect to the Day convolution, and hence applicative functors are also monoids in a monoidal category of endofunctors using the Day convolution as a tensor.”
17:55:05 <Iceland_jack> From http://www.fceia.unr.edu.ar/~mauro/pubs/Notions_of_Computation_as_Monoids.pdf
17:55:32 <athan> Thank you Iceland_jack!!
17:55:51 <athan> Cale: I need to work this one in :) Thank you!!
18:03:49 <rui> cabal will compile with whatever ghc is in the PATH, right?
18:04:13 <h-core> what's the language extension called that lets you do stuff like data Toy = Thing a b
18:04:35 <h-core> so i don't need data Toy a b on the left hand side
18:05:32 <exio4> h-core: RankNTypes allows you to include explicit foralls there, which you would be existential types, but I normally enable GADT syntax just for that
18:05:43 <exio4> that way you can write things like
18:05:46 <exio4> data Toy where
18:05:55 <exio4>   Thing :: a -> b -> Toy
18:06:52 <bitshark> hey hey
18:07:11 <exio4> is there any way to make this work (without using a typeclass and recursing over the list)? http://lpaste.net/131941 
18:08:15 <h-core> thanks exio4, but i think i was looking for something that allowed exactly "Toy = Thing a b" but perhaps i'm mis-remembering thing
18:08:16 <h-core> s
18:09:20 * hackagebot functor-combo 0.3.6 - Functor combinators with tries & zippers  http://hackage.haskell.org/package/functor-combo-0.3.6 (ConalElliott)
18:11:46 <exio4> hackagebot: I don't know of any extension that allows you to do that, but I am not sure, anyway, do you really need existential types?
18:11:50 <geekosaur> h-core: afaik there's no way to do exactly that
18:12:14 * geekosaur eyes exio4's tab-complete
18:12:25 <exio4> woops 
18:12:48 <Cale> h-core: There's  data Toy = forall a b. Thing a b
18:13:15 <geekosaur> but Toy won't be very useful
18:13:24 <Cale> h-core: Which is the notation supported by ExistentialQuantification
18:13:37 <Cale> Yeah, that type specifically won't be much different from ()
18:14:03 <h-core> geekosaur, gotcha, just then if i have a recursive data type the type definition grows pretty large as i add things, especially if i'm defining something like:
18:14:26 <h-core> data Toy a b = Thing a b (Toy a b)
18:14:46 <h-core> err Toy a b c
18:15:19 <h-core> so if i have some sort of static starting list every level to it adds more to the type definition
18:15:39 <h-core> which just seems kind of silly to me
18:17:05 <enthropy> exio4: so you don't want "runExists :: (forall e. All xs e => e -> r) -> Exists xs -> r", but you want the supplied function to use less constraints?
18:18:35 <exio4> enthropy: I wanted to extract out just "one" constraint, throwing away the rest, I basically want to make sure the supplied function does just one thing
18:19:34 <exio4> are there any "standard" type families for working with type-level lists in base, btw? 
18:20:20 <geekosaur> why do people insist that things must be in base?
18:20:53 <geekosaur> go tell the ghc folks that their intention to unbundle as much as possible from the compiler is not acceptable, if you so badly need the whole universe to be in base
18:21:15 <exio4> it could have been a library, didn't actually meant it in base duh :P 
18:26:18 <exio4> enthropy: also, I don't know how I could implement instances like Show without something like this? 
18:27:35 <dfeuer> I'm just reading the introduction to the HoTT book. It claims to deal with isomorphisms in a very pleasant fashion. Are any programming languages moving to implement such things?
18:28:41 <benzrf> dfeuer: it's not a thing that's entirely relevant to PLs at the moment
18:28:46 <benzrf> it's a type thing
18:29:01 <benzrf> the stuff it's coming up with might be applicable to programming
18:29:16 <benzrf> once an open problem or two get resolved
18:30:05 <benzrf> dfeuer: how much type theory and stuff do you already know
18:30:10 <Iceland_jack> It can certainly be relevant to programming to be able to work isomorphically, I've had some ideas and talks at pubs how that could be realised
18:30:44 <dfeuer> benzrf, very little. But I'm currently in a situation (playing with Idris) where the inability to deal with isomorphisms nicely is ... not good.
18:30:59 <benzrf> Iceland_jack: yeah but the whole deal is that they still havent worked out reduction for the new stuff
18:31:00 <dfeuer> I can either write a bunch of code that's insufficiently general for many purposes,
18:31:10 <Iceland_jack> dfeuer: I think this is probably more related to you, go look at Weirich's Zombie language
18:31:13 <dfeuer> or write a much bigger and much much hairier bunch of code that's general.
18:31:39 <Iceland_jack> dfeuer: http://www.seas.upenn.edu/~sweirich/papers/popl15-congruence.pdf
18:32:08 <dfeuer> Iceland_jack, I'll check it out, thanks. Speaking of things, has anyone asked Weirich if she'd like to be on the Haskell.org committee? It currently has no women on it.
18:32:11 <neuroserpens> Guys... This has nothing to do with the topic so I am really sorry in advance, and this is hard for me to say but I don't know who to ask and this channel has lots of understanding people so... Do you know of any remote or relocation possible job opportunities anywhere? I've been unemployed for several months now here in Brazil and on top of that have been dealing with too many problems of emotional level.
18:32:12 <neuroserpens> Things have been falling apart, I don't have anyone to count on and I really need to get out of this place. Even a low salary would work miracles right now.
18:32:17 <neuroserpens> I am really sorry. I really am.
18:32:33 <dfeuer> neuroserpens, join the club. Nope.
18:33:02 <neuroserpens> dfeuer: I'm sorry to hear that.
18:33:47 <neuroserpens> I shouldn't have brought this here.
18:33:53 <Iceland_jack> neuroserpens: No it's fine
18:34:03 <Iceland_jack> neuroserpens: I'm asking friends I'm with
18:36:00 <dfeuer> Zombie looks a bit ... wonky. But it looks like Sjöberg and Weirich found a way to do something interesting there.
18:37:00 <benzrf> continued *** Exception: user error (unknown GLUT entry glutInit)
18:37:07 <benzrf> plz help me fix this
18:37:10 <benzrf> i want to use gloss :(
18:37:14 <BMeph> neuroserpens: I'd also ask in #naskell-blah since: 1) It is on-topic there; 2) You're more likely to run into someone that may have given up on Haskell, but has a job opportunity you can take advantage of.
18:37:58 <neuroserpens> BMeph: You're right. I'm not thinking too straight. Thanks a lot.
18:38:08 <aaronm04> why is "non-exhaustive patterns" an exception and not a compile time error?
18:38:20 <aaronm04> it seems like the latter is the Haskell Way
18:38:26 <benzrf> aaronm04: halting problem
18:38:33 <enthropy> just enable -Werror for yourself then
18:38:47 <aaronm04> benzrf: really? how so?
18:38:56 <benzrf> aaronm04: well
18:39:11 <benzrf> aaronm04: it's possible to enforce at compile time that every possible case is covered for constructors of a type
18:39:20 <benzrf> aaronm04: but that's not always correct
18:39:34 <benzrf> aaronm04: problem flow may determine that if a given expression is reduced, some constructor is ruled out
18:39:43 <benzrf> and there's no way to compute whether that is the case in general
18:39:56 <aaronm04> ah, I see
18:40:01 <benzrf> but i believe it's possible to enforce the naive version, yess
18:40:02 <benzrf> as enthropy mentioned
18:40:30 <enthropy> exio4: I think you need a class or two: http://lpaste.net/131941
18:40:48 <aaronm04> enthropy: does that work with ghci?
18:41:52 <enthropy> aaronm04: looks like it does
18:43:11 <aaronm04> awesome, thanks!
18:43:22 <aaronm04> to both of you
18:44:25 <dfeuer> benzrf, Iceland_jack, I think I'll just go with "less general than I'd like" because the general way is just going to be toooo painful.
18:45:09 <benzrf> hah
18:46:02 <dfeuer> benzrf, I'm working on finger trees in Idris. If the monoids are only monoids "up to some equivalence", things get horrifying.
18:46:14 <benzrf> kek
18:46:18 <benzrf> define categorical monoids :>
18:46:27 <dfeuer> Whazzat mean?
18:46:33 <benzrf> @google monoid object
18:46:34 <lambdabot> http://ncatlab.org/nlab/show/monoid
18:46:34 <lambdabot> Title: monoid in nLab
18:46:39 <benzrf> hoo boy
18:46:42 <benzrf> nlab
18:47:40 <SrPx_> Is there anything that replaces hackage's functionality (as a documentation tool) on the command line?
18:47:53 <benzrf> SrPx_: u mean haddock's functionality?
18:47:58 <exio4> enthropy: that's what I wanted to avoid, apparently there's no other way :/
18:47:58 <Clint> a cli web browser
18:48:49 <exio4> enthropy: why are you using Bool, btw? 
18:48:49 <SrPx_> Fore xample, anytime I use gloss I have to go to hackage, load the site, click on the specific module and read it there... but I've had internet issues lately.
18:48:55 <Denommus> How can I find the source of a function with lambdabot? 
18:49:00 <dfeuer> benzrf, how does considering arrows instead of elements help me one bit?
18:49:04 <SrPx_> benzrf: I thought haddock was a tool for generating the documentation?
18:49:06 <dreams> Denommus: @src fun
18:49:18 <benzrf> SrPx_: it is
18:49:21 <benzrf> im not sure what youre asking
18:49:25 <benzrf> hackage isnt a documentation tool
18:49:38 <benzrf> but it does host haddock
18:49:40 <Denommus> dreams: @src permutations didn't work 
18:49:44 <Denommus> @src permutations 
18:49:45 <lambdabot> Source not found. Wrong!  You cheating scum!
18:49:46 <Iceland_jack> benzrf: They want the "doc" command from Idris
18:49:57 <benzrf> o
18:49:59 <dreams> Denommus: means there is no source for it.
18:50:08 <Iceland_jack> Or "src" for laguages like Clojure
18:50:09 <SrPx_> benzrf: my bad. What I mean is, suppose you want to use a library (Gloss). What do you do? You go to hackage ( https://hackage.haskell.org/package/gloss-1.9.2.1 ) read the documentation there, find the functions you need and use it on your code. Is that correct?
18:50:23 <benzrf> Denommus: @src is a hardcoded db
18:50:30 <enthropy> exio4: it avoids the OverlappingInstances
18:50:39 <Denommus> benzrf: ah
18:50:42 <benzrf> SrPx_: yeah
18:50:52 <dreams> Denommus: http://hackage.haskell.org/package/base-4.8.0.0/docs/src/Data-OldList.html#permutations
18:50:59 <benzrf> dreams: the definition is up-to-an-iso
18:50:59 <SrPx_> Cool. I just asked if there is any way to do it  offline, since I'm having bad internet issues...?
18:51:02 <benzrf> * dfeuer 
18:51:08 <exio4> enthropy: ah
18:51:12 <benzrf> dfeuer: by the definition of a monoidal category
18:51:20 <SrPx_> Other than downloading the sites, obviously (I'll do that if there is no standard way)
18:51:23 <Denommus> dreams: thanks 
18:51:27 <georgyy> why is <*> useful? why would you put a function inside functor?
18:51:34 <Iceland_jack> georgyy: Good question!
18:51:45 <Iceland_jack> It's usually used together with other functions
18:52:35 <Iceland_jack> If you want to read a line from input and add a "!" to it, you might write
18:52:35 <Iceland_jack>     do line <- getLine
18:52:35 <Iceland_jack>        return (line ++ "!")
18:53:01 <Iceland_jack> Then you can use "fmap" to map the function over getLine
18:53:02 <Iceland_jack>     fmap (++ "!") getLine
18:53:10 <dfeuer> benzrf, and that makes my life easier how? Doing proofs in Idris without being able to use basic tactics like replace, and having to thread the reflexivity, symmetry, and transitivity of the equivalence everywhere, along with their compatibility with the monoid operation, is the real problem....
18:53:11 <Iceland_jack> georgyy: But what if you have a binary function!
18:53:33 <georgyy> Iceland_jack: a function accepting two arguments?
18:53:42 <benzrf> dfeuer: i was being mildly facetious
18:53:47 <Denommus> georgyy: you know lift? It's written in terms of (<*>) and (<$>) 
18:53:48 <dfeuer> Ah, okay.
18:53:50 <Iceland_jack> A function like 
18:53:50 <Iceland_jack>     (++) :: [a] -> [a] -> [a]
18:54:14 <dfeuer> benzrf, I would venture to guess it would end up about the same about of work (wayyyy too much) with more complicated terminology.
18:54:15 <benzrf> georgyy: i have an explanation of the deal with applicative
18:54:17 <benzrf> s
18:54:23 <Iceland_jack> If you want to read *two* lines from input, and lift (++) over the two getLines, you really want to change
18:54:23 <Iceland_jack>     (++) :: String -> String -> String
18:54:23 <Iceland_jack> to
18:54:23 <Iceland_jack>          :: IO String -> IO String -> IO String
18:54:29 <SrPx_> Is there any way to ask GHCI/hoogle to list the modules of a package, and is there any way to ask GHCI/hoogle to list the symbols exported by a module?
18:54:31 <Denommus> georgyy: liftA2 f a b = f <$> a <*> b
18:54:39 <georgyy> I dont think I know that one
18:54:47 <benzrf> georgyy: http://blog.ezyang.com/2012/08/applicative-functors/
18:59:59 <georgyy> liftA2 is like fmap for binary functions?
19:00:05 <Iceland_jack> Exactly!
19:00:13 <Iceland_jack> :t fmap :: (a -> b) -> (IO a -> IO b)
19:00:14 <lambdabot> (a -> b) -> IO a -> IO b
19:00:21 <Iceland_jack> :t liftA2 :: (a -> b -> c) -> (IO a -> IO b -> IO c)
19:00:22 <lambdabot> (a -> b -> c) -> IO a -> IO b -> IO c
19:00:53 <Iceland_jack> There is also one for terms ("nullary", 0-ary functions)
19:00:54 <Iceland_jack> :t pure :: a -> IO a
19:00:55 <lambdabot> a -> IO a
19:00:57 <KaneTW> @src liftM
19:00:57 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
19:03:12 <georgyy> thanks.. I still have to figure out how <*> falls into all of this (source of liftA2 seems hard to read to me). but unfortunately I need to go
19:03:36 <Iceland_jack> georgyy: (you can of course substitute "IO" for an Applicative Functor of your choice, Maybe, [], ((->) r), Either e, Monoid e => ((,) e))
19:03:46 <Iceland_jack> georgyy: Ah, well I can go through it if you have a bit of time
19:03:52 <Iceland_jack> but good luck otherwise
19:04:28 * hackagebot pandoc-crossref 0.1.0.2 - Pandoc filter for cross-references  http://hackage.haskell.org/package/pandoc-crossref-0.1.0.2 (lierdakil)
19:05:28 <georgyy> 1% in my battery, I dont think it will last long enough :). maybe next time
19:05:37 <Iceland_jack> Sure thing :)
19:05:52 <Iceland_jack> Do you understand what
19:05:52 <Iceland_jack> :t liftA2 (++) getLine getLine
19:05:53 <lambdabot> IO [Char]
19:05:53 <Iceland_jack> does?
19:06:10 <georgyy> I think
19:06:25 <Iceland_jack> It's the same as
19:06:25 <Iceland_jack>     do line1 <- getLine
19:06:25 <Iceland_jack>        line2 <- getLine
19:06:25 <Iceland_jack>        return (line1 ++ line2)
19:06:39 <georgyy> appends two strings returned by getLines?
19:06:41 <Iceland_jack> Yes
19:06:49 <Iceland_jack> 'liftA2' is defined as such
19:06:50 <Iceland_jack> @src liftA2
19:06:50 <lambdabot> liftA2 f a b = f <$> a <*> b
19:07:07 <Iceland_jack> So
19:07:07 <Iceland_jack>        liftA2 (++) getLine getLine
19:07:07 <Iceland_jack>     == (++) <$> getLine <*> getLine
19:07:14 <Iceland_jack> :t (++) <$> getLine <*> getLine
19:07:15 <lambdabot> IO [Char]
19:07:23 <georgyy> I see
19:07:26 <Iceland_jack> (<$>) is just an infix version of fmap
19:07:44 <Iceland_jack> And because it associates to the left, it's
19:07:44 <Iceland_jack> :t ((++) <$> getLine) <*> getLine
19:07:45 <lambdabot> IO [Char]
19:07:51 <Iceland_jack> So you start by 'fmap (++) getLine'
19:08:12 <georgyy> yes
19:08:18 <Iceland_jack> :t fmap :: (String -> String -> String) -> IO String -> IO (String -> String)
19:08:19 <lambdabot> (String -> String -> String) -> IO String -> IO (String -> String)
19:08:23 <Iceland_jack> Does that type make sense?
19:08:43 <Iceland_jack> That just applies (++) to getLine, but (++) needs *one more* argument!
19:09:11 <Iceland_jack> So the type of "fmap (++) getLine" is
19:09:11 <Iceland_jack> :t fmap (++) getLine
19:09:12 <lambdabot> IO ([Char] -> [Char])
19:09:32 <Iceland_jack> So we have a function inside of IO that we want to apply
19:09:50 <Iceland_jack> Oops.. they quit
19:10:03 <Iceland_jack> haha, never mind
19:21:09 <georgyy> sorry, got cut off. Ill catch up with the log site if you still have the time
19:26:28 <Iceland_jack> georgyy: I can repeat it, it wasn't very many lines
19:26:49 <georgyy> I have read it
19:26:58 <Iceland_jack> Ah okay :)
19:27:15 <Iceland_jack> So you understand this type
19:27:16 <Iceland_jack> :t (++) <$> getLine
19:27:16 <lambdabot> IO ([Char] -> [Char])
19:27:22 <georgyy> why does fmap (++) give IO (...)?
19:27:31 <Iceland_jack> because of 'getLine'
19:27:33 <georgyy> yes that one
19:27:34 <Iceland_jack>     getLine :: IO String
19:27:48 <Zemyla> I have a question.
19:28:02 <Iceland_jack> This is the type of fmap (for 'f = IO')
19:28:03 <Iceland_jack> :t fmap :: (a -> b) -> IO a -> IO b
19:28:03 <lambdabot> (a -> b) -> IO a -> IO b
19:28:05 <georgyy> :t (<$>)
19:28:06 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:28:10 <Iceland_jack> Zemyla: Go ahead
19:28:12 <georgyy> yes
19:28:13 <Iceland_jack> georgyy: (<$>) = fmap
19:28:19 <Zemyla> With the Applicative-Monad unification, will the default for (>>) change to (*>)?
19:28:23 <Iceland_jack> :t (<$>) :: (a -> b) -> IO a -> IO b
19:28:24 <lambdabot> (a -> b) -> IO a -> IO b
19:28:25 <georgyy> oh
19:28:39 <Zemyla> Since (*>) is literally the same as (>>) in any conforming instances.
19:28:44 <Iceland_jack> Zemyla: No
19:29:42 <Iceland_jack> Zemyla: https://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-Base.html#Monad
19:29:51 <Iceland_jack> Please read "Note [Recursive bindings for Applicative/Monad]"
19:30:41 <Iceland_jack> georgyy: So we have
19:30:42 <Iceland_jack>     (++) <$> getLine :: IO (String -> String)
19:30:42 <Iceland_jack> and the final
19:30:42 <Iceland_jack>     getLine          :: IO String
19:30:43 <georgyy> is b in here (String -> String)? <$> :: (a -> b) -> IO a -> IO b
19:30:48 <Iceland_jack> Yes
19:30:50 <Iceland_jack> :)
19:31:02 <Iceland_jack> :t fmap :: (String -> (String -> String)) -> IO String -> IO (String -> String)
19:31:03 <lambdabot> (String -> String -> String) -> IO String -> IO (String -> String)
19:31:05 <georgyy> I think I get it :)
19:31:08 <Iceland_jack> Okay :)
19:31:34 <Zemyla> Iceland_jack: Oh, okay.
19:32:05 <lf94>   let req' = initReq { secure = True } -- Turn on https
19:32:09 <lf94> What are the {} for?
19:32:14 <lf94> named parameter?
19:32:57 <joneshf-laptop> lf94, record update syntax
19:33:10 <georgyy> is that the real point of <*>, just so we can write functions like liftA2
19:33:22 <lf94> georgyy, basically
19:33:33 <lf94> joneshf-laptop, err, record is what again :s
19:33:34 <Iceland_`> georgyy: Most of the time, yes
19:33:37 <Iceland_`> But it's also useful in other cases
19:34:03 <georgyy> such as?
19:34:59 <Iceland_`> georgyy: Often you have some Applicative Functor that "returns" a function
19:36:47 <Iceland_`> A silly example is serialising the function "not" and reading it from a file
19:36:47 <Iceland_`>     ... :: IO (Bool -> Bool)
19:36:48 <Zemyla> Also, why is there no default instance for Monoid a => Monad ((,) a) in GHC.Base, if it defines such an instance for Applicative?
19:39:37 <Iceland_`> Zemyla: I could be
19:39:41 <Iceland_`> I'm not sure why it's not
19:41:02 <Iceland_jack> *It could be
19:41:40 <Iceland_jack> Kmett proposes it here https://mail.haskell.org/pipermail/libraries/2011-November/017153.html
19:43:42 <Iceland_jack> I don't see it in Data.Monoid, I guess it just didn't go anywhere
19:50:33 <joneshf-laptop> georgyy, a very natural use is for applicative parsing
19:50:42 <joneshf-laptop> georgyy, mauybe someone can explain that
19:50:44 <lf94> _stdin <- getContents :: IO(ByteString)
19:50:57 <lf94> Is that the correct way to specify what I want getContents to send back?
19:51:01 <lf94> I always forget.
19:53:29 <ronh> @hoogle IO ByteString
19:53:30 <lambdabot> Did you mean: :: IO ByteString
19:53:30 <lambdabot> package bytestring-conversion
19:53:30 <lambdabot> package explicit-iomodes-bytestring
19:53:41 <ronh> @hoogle (IO ByteString)
19:53:41 <lambdabot> Data.ByteString.Lazy getContents :: IO ByteString
19:53:41 <lambdabot> Data.ByteString.Lazy.Char8 getContents :: IO ByteString
19:53:41 <lambdabot> Data.ByteString getContents :: IO ByteString
19:54:18 <ronh> `import qualified Data.ByteString as BS' and then use BS.getLine instead
19:57:19 <lf94> ronh: ah, right.
20:10:10 <pyon> Does anyone here install local copies of package documentation?
20:10:29 <benzrf> i doooo
20:10:50 <benzrf> it's handy!
20:11:10 <pyon> For some reason, cabal-install isn't generating the documentation index correctly.
20:11:19 <pyon> I mean, the index is being generated, but the links are broken.
20:11:40 <benzrf> do you have the options enabled
20:12:17 <pyon> The only change I made to my ~/.cabal/config is replacing the line "-- documentation: False" with "documentation: True".
20:12:56 <pyon> I'm uploading some screenshots to show how exactly the links are broken.
20:13:19 <benzrf> ah
20:13:32 <pyon> http://imgur.com/qYevkDI,ltYvyDt,4qkMWNp
20:14:09 <pyon> I picked the first module from the index: Codec.Compression.GZip.
20:14:50 <kadoban> … is that supposed to show something broken?
20:15:09 <pyon> When I click on that link, I get the second image: file not found.
20:15:31 <kadoban> Oh I probably am not seeing anything but the first.
20:15:42 <geekosaur> that sounds familiar but I don't recall details
20:16:13 <geekosaur> kadoban,up near the top there's "First image" "Second image" etc.
20:16:15 <pyon> When I edit the URL in the second link, to include $pkgname/html/, I get what's shown on the third image.
20:16:28 <geekosaur> and Prev/Next
20:16:33 <pyon> In other words, the documentation itself is installed correctly.
20:16:40 <pyon> Then only thing that's broken is just the documentation index.
20:16:40 <kadoban> Hmm
20:18:04 <pyon> I've tried deleting everything in my ~/.cabal directory, except for ~/.cabal/bin/*, and then reinstalling cabal-install.
20:18:30 <pyon> But it's still generating broken documentation indices.
20:20:07 <SrPx_> How can I decode JSON using Aeson that is a list of objects that can have missing fields? For example, certain objects have a "speed" field, while others don't.
20:23:42 <SrPx_> well I could just... parse with with node.js, add the missing fields and stringify back... but... yea
20:24:32 <johnw> i'm pretty sure lens-aeson gives you a prism for that
20:24:41 <johnw> obj ^? key "speed"
20:34:22 <mjrosenb> if I have recurse 0 x = x; recurse n x | n > 0 = recurse (n-1) (f x) | otherwise = recurse (n+1) (g x), is ghc -O2 smart enough to not always re-check the sign of n?
20:34:34 <mjrosenb> not that it matters at all on a modern computer
20:38:22 <Denommus> mjrosenb: you can always check the generated assembly 
20:39:22 <bwiklund> aside from {-# LANGUAGE OverloadedStrings #-}, is there anything i can do to dry up my code that uses lots of Strings and Lazy.ByteStrings ?
20:39:39 <bwiklund> i'm still having to do a lot of packing and unpacking on strings that aren't literals
20:39:48 <SrPx_> johnw: got it, thanks!
20:40:58 <kadoban> bwiklund: Well, they're kind of totally different things … it makes sense that an explicit conversion should be required to go between them.
20:42:09 <mjrosenb> Denommus: that sounds ... annoying.
20:43:10 <Denommus> mjrosenb: generate the assembly with and without the comparison. Then just diff it 
20:43:54 <Denommus> mjrosenb: if it's the same assembly, the expected optimization is happening 
20:44:43 <mjrosenb> Denommus: errr, that is not the optimization that I want, and I don't know how to write the code to do what I want
20:44:53 <mjrosenb> or I would have just written it that way.
20:45:52 <Denommus> mjrosenb: your code should throw away the comparison and the otherwise block 
20:46:11 <Denommus> mjrosenb: ah wait 
20:46:18 <Denommus> mjrosenb: I'm stupid 
20:47:03 <Denommus> mjrosenb: I should be sleeping. I always get more stupid when I'm sleepy 
20:50:41 <bwiklund> kadoban: makes sense
20:51:42 <bwiklund> i was hoping there was some automagical way to force the conversion based on type annotation or something similar to OverloadedStrings
20:52:41 <kadoban> Not that I know of. The extent of haskell's automatic conversion stuff tends to just be … literals to appropriate type (Num and IsString)
20:53:17 <bwiklund> interesting
20:54:00 <bwiklund> i wonder why that can't apply to variables as well as literals... i guess it wouldn't be clear where that conversion sould occur?
20:54:05 <ronh> I wouldn't even call it a conversion. literals have generic types. if your function returned Num (or IsString, though I am not sure if it is meant to be used like that) it would work in exactly the same way
20:54:15 <bwiklund> whereas literals, it's given
20:54:30 <bwiklund> hmmmm
20:54:32 <bwiklund> okay
20:55:16 <bwiklund> i'll mess with that and see how it goes
20:55:55 <geekosaur> well, except that getting anything more complex than a literal to be polymorphic can be tricky
20:56:47 <ronh> if your variable was of Num a => a type you can pass it to a function taking Int, or Double, or whatever. that's not the same as taking a variable of type Double type and magically converting it to Int. which is what you seem to be talking about
20:57:08 <bwiklund> i think you're right
20:57:59 <geekosaur> the problem with having the compiler automatically insert type coercions (e.g. fromInteger as it does for integer literals) is that it will sometimes insert them where you don't expect it
20:58:20 <geekosaur> this tends to become very obvious if you have a Num instance for functions in scope
20:58:47 <bwiklund> yeah.
20:59:09 <geekosaur> because certain typos that would normally elicit type errors will cause it to find the Num instance and try to use it, with "hilarious" resuits
20:59:17 <bwiklund> i'm going after a reduction in lines of code, but i guess at this point it's hitting a wall where things will no longer actually make logical sense
20:59:20 <bwiklund> haha
21:01:20 <naudiz> can someone tell me how to get a logarithmic cb scale with Graphics.Gnuplot?
21:01:36 <Zemyla> http://okmij.org/ftp/Haskell/tr-15-04.pdf
21:01:49 <Zemyla> Oleg, Jesus fucking Christ, that's like lunatic space magic.
21:01:50 <naudiz> I'm trying `add (custom "logscale cb" "") [""]` but it produces empty images
21:02:18 <Xe> Zemyla: it gradually turns from magic into science
21:02:29 <geekosaur> Zemyla, lunatic space magic is when Oleg's just getting started, it gets worse from there :)
21:06:05 <caconym> does anyone have any advice or resources for learning best practices for structuring medium/large haskell programs?
21:06:43 <caconym> i'm always feeling like i'm doing a lot of stuff "the wrong way"
21:07:36 <pacak> caconym: Have a look at some opensource medium/large haskell programs. Other than ghc nothing comes to mind though...
21:08:11 <mjrosenb> > let f (~(h:t)) = h in f []
21:08:12 <lambdabot>  *Exception: <interactive>:3:5-18: Irrefutable pattern failed for pattern (h ...
21:08:17 <mjrosenb> cool.
21:08:35 <mjrosenb> is one of those parens not needed?
21:08:38 <mjrosenb> (or both)
21:10:28 <caconym> pacak: thanks, i will check out ghc, xmonad is another one that occurred to me just now
21:11:00 <pacak> caconym: xmonad is actually a very small project
21:11:12 <geekosaur> you don't need the outer set
21:11:20 <geekosaur> let f ~(h:t) = ...
21:12:04 <pacak> caconym: There are a few opensource haskell games - you  can check those
21:12:16 <geekosaur> xmonad is tiny. xmonad-contrib is getting pretty big, but it's also a disorganized zoo >.>
21:13:02 <caconym> geekosaur: hm, ok, maybe i'll stay away
21:14:00 <pacak> caconym: Bad example can be a good example sometimes :)
21:14:10 <mjrosenb> > let f ~(h:t) = 3 in  f []
21:14:11 <lambdabot>  3
21:15:19 <geekosaur> there's not a lot to see from xmonad-contrib
21:15:26 <caconym> pacak: heh, i feel like i've generated enough of my own
21:16:45 <caconym> i may just be in too much of a hurry when i'm writing code? i did some googling before i came in here just now and was surprised to find that "functional design patterns" isn't as much of a thing as i thought it might be
21:19:42 <geekosaur> "functional pearls"
21:20:49 <geekosaur> that said, design patterns tend to depend on the language: a design pattern that works well in SML often works poorly in Haskell and vice versa, because laziness has design patterns of its own that are rather different
21:20:52 <caconym> this one? http://www.amazon.com/Pearls-Functional-Algorithm-Design-Richard/dp/0521513383
21:21:07 <geekosaur> ...and in Haskell we can often turn design patterns into libraries (or monads)
21:21:30 <caconym> yeah, i'm not looking to shoehorn a bunch of OO crap into my haskell programs
21:21:49 <geekosaur> "functional pearl" tends to be a category of short FP journal paper
21:22:14 <caconym> that's one thing i'm interested in, is recognizing functors/monoids/monads/etc in my problems and taking advantage of them; i'm currently quite bad at this
21:22:17 <geekosaur> sometimes some of them get collected into books but the papers are often easier to dig up and the books would always be out of date anyway >.>
21:22:30 <geekosaur> right, that's something that comes with experience
21:22:33 <johnw> caconym: that comes with time
21:22:38 <jle`> is wreq ever going to work with ghc 7.10
21:22:43 <jle`> ;_;
21:23:06 <mjrosenb> jle`: what is wreq?
21:23:15 <mjrosenb> sounds like a qwerty-ism.
21:23:15 <caconym> yeah, i figured that it's a little like the "monads are like burritos" business
21:23:23 <jle`> http://www.serpentine.com/wreq/
21:23:41 <johnw> caconym: no, not at all
21:24:01 <caconym> i mean, in the sense that true useful understanding must come with experience
21:24:25 <johnw> I would say that it comes with vision, which requires experience
21:25:47 <caconym> indeed
21:34:35 * hackagebot Diff 0.3.2 - O(ND) diff algorithm in haskell.  http://hackage.haskell.org/package/Diff-0.3.2 (SterlingClover)
21:37:30 <phy1729> Is there a drop every other in a list function?
21:38:20 <pacak> > map fst . filter (odd . snd) $ zip [1,3,5,453,4,32,5,6] [1..]
21:38:21 <lambdabot>  [1,5,4,5]
21:41:06 <phy1729> neat thanks
21:41:53 <pacak> > let fn = map snd . filter (odd . fst) . zip [1..] in fn [1,3,5,453,4,32,5,6]
21:41:55 <lambdabot>  [1,5,4,5]
21:42:11 <pacak> pointfree version
21:44:54 <nak> hello everyone
21:46:53 <nak> i'm trying to make this (javascript) expression point-free...   x => f(g)(cons([x])(xs))
21:47:07 <nak> is it possible ? i'm having trouble identifying a better composition for it
21:47:33 <bwiklund> what do you guys do with named data parameters, when destructing
21:48:03 <bwiklund> what is the idiomatic way of naming stuff without shadowing the functions that pull those values out of a data type
21:48:22 <bwiklund> as in: data Foo = Foo {bar :: String}
21:48:25 <bwiklund> and then a function that takes
21:48:55 <bwiklund> asdf (Foo {bar = fml}) = ...
21:49:37 <Cale> Not sure if I understand what you're asking
21:50:05 <bwiklund> so in most languages it's Foo.bar to access a 'member'
21:50:19 <bwiklund> in haskell i wanna pull out those values as simply as possible
21:50:23 <Cale> bar here is a function  bar :: Foo -> String
21:50:35 <bwiklund> yes it is
21:50:46 <Cale> So you can write  asdf myFoo = ... bar myFoo ...
21:51:12 <bwiklund> right of course, the question is more about how to dry up code with lots of those
21:51:27 <bwiklund> like... hypotheticallt
21:51:30 <MP2E> I'd recommend taking a look at the lens library
21:51:38 <MP2E> sounds like exactly what you want to me
21:51:47 <Cale> I'm not sure. Maybe you could find a real example of the code you'd like to simplify?
21:52:00 <peddie> bwiklund: RecordWildCards?
21:52:02 <Cale> Well, maybe lens is an answer, but I'm not sure yet.
21:52:13 <bwiklund> toString (HttpRequest {method = m, url = u, asdfasdgasdf = a}) = ...
21:52:16 <MP2E> yeah maybe I'm jumping the gun here :)
21:52:20 <bwiklund> the naming of all those bits
21:52:29 <bwiklund> for the function body
21:52:33 <bwiklund> without shadowing
21:52:39 <Cale> Did you know that you can write  toString (HttpRequest m u a) = ... ?
21:52:40 <caconym> bwiklund: if you're like me, you may have started asking this question when you not only wanted to pull out fields of values but also modify them "in place" and make new values using parts of old and so on?
21:53:02 <bwiklund> sorry, the HttpRequest bit is arbitrary and made up
21:53:18 <bwiklund> no trying to ask questions about the actual Http module
21:53:24 <Cale> bwiklund: Again, do you have some real code for us to look at?
21:53:29 <bwiklund> sure
21:53:46 <bwiklund> making a git(ish) clone in haskell
21:53:46 <bwiklund> https://github.com/bwiklund/bloop
21:54:01 <bwiklund> you'll see me fumbling with all that stuff in Plumbing.hs
21:54:16 <bwiklund> all the times i'm destructuring BloopNode
21:54:38 <bwiklund> i'm all over the place because i'm not satisfied with anything i've done yet in terms of naming arguments
21:54:58 <bwiklund> sorry, BloopTree
21:55:04 <bwiklund> for ctrl-f convenience
21:55:31 <Cale> Personally, if a variable only scopes over a single line, I'm usually happy enough to name it with a one letter variable
21:55:36 <bwiklund> hmm, ok
21:56:11 <Cale> treeEntryToLine (Blob {hash = h, fileName = n}) = Lazy.concat ["100755 blob ", Lazy.pack h, " ", Lazy.pack n]
21:56:23 <bwiklund> yeah.
21:56:39 <bwiklund> i kind of miss the old "Foo.bar.baz" style of member access in this case
21:56:51 <Cale> Well, you could also write:
21:56:52 <bwiklund> since it's more self-documenting in-place
21:57:24 <Cale> treeEntryToLine x@(Blob{}) = Lazy.concat ["100755 blob ", Lazy.pack (hash x), " ", Lazy.pack (fileName x)]
21:57:33 <bwiklund> ahhhh ok
21:57:48 <bwiklund> that's what i was looking for earlier but google was failing at finding me the info i needed on the @ part
21:58:00 <bwiklund> and how to use that other than the list@(x:xs) usage
21:58:17 <bwiklund> thanks dude
21:58:31 <echo-area> Cale: Can @(Blob{}) be also omitted?
21:58:52 <Cale> echo-area: Not in that specific case, because the case for Tree is different
21:59:11 <bwiklund> yeah its algebraic
21:59:16 <nak> does haskell have a name for a function that wraps a value and returns a function, that when called, returns the value?
21:59:19 <nak> e.g.,
21:59:30 <bwiklund> that's how all of haskell works
21:59:34 <Cale> It might be worth considering whether the type could be factored differently somehow.
21:59:47 <bwiklund> functions and values are the same thing
21:59:50 <echo-area> Ah, I see.  Thanks
21:59:53 <Cale> what?
21:59:53 <jle`> nak: how about const?
21:59:58 <bwiklund> maybe you need advice about IO in this case?
22:00:02 <jle`> > let always1 = const 1 in always1 10
22:00:02 <nak> how do you call a function without args in haskell ?
22:00:03 <lambdabot>  1
22:00:08 <bwiklund> foo = 1
22:00:08 <Cale> Functions are values, but not all values are functions.
22:00:10 <bwiklund> print foo
22:00:15 <Cale> nak: "not a function"
22:00:18 <nak> let wrap x = \() -> x in (wrap 1)
22:00:24 <nak> ? let wrap x = \() -> x in (wrap 1)
22:00:24 <bwiklund> let Cale help you, he's smarter
22:00:27 <nak> > let wrap x = \() -> x in (wrap 1)
22:00:28 <lambdabot>  <() -> Integer>
22:00:38 <nak> ok so how do i call that function to get the integer back out ?
22:00:45 <Cale> Functions are values whose type is of the form A -> B for some types A and B
22:00:47 <jle`> wrap 1 ()
22:00:50 <jle`> but that's just const
22:00:58 <nak> > let wrap x = \() -> x in (wrap 1) ()
22:00:59 <jle`> > const 1 ()
22:01:00 <lambdabot>  1
22:01:01 <lambdabot>  1
22:01:02 <nak> ah ok
22:01:10 <jle`> @src const
22:01:11 <lambdabot> const x _ = x
22:01:15 <nak> jle` cool, i was unaware of const :)
22:01:19 <nak> that's exactly what i'm looking for :)
22:01:20 <Cale> Don't do this, btw
22:01:38 <jle`> yeah, i'm not sure why you would want to do this
22:01:40 <jle`> why not just use 1?
22:01:43 <Cale> If you were going to use () -> A, just use A
22:01:56 <bwiklund> @nak is this value something IO related
22:01:56 <lambdabot> Maybe you meant: faq ask
22:01:57 <jle`> haskell evaluation is automatically delayed anyways, if that's what you're worried about
22:02:03 <bwiklund> or is actually constant at compile time
22:02:18 <nak> bwiklund no
22:02:19 <echo-area> @gentoo
22:02:19 <lambdabot> Unknown command, try @list
22:02:22 <echo-area> @list
22:02:22 <lambdabot> What module?  Try @listmodules for some ideas.
22:02:26 <bwiklund> if you're coming from most other languages then some abstractions about callbacks don't make sense
22:02:41 <jle`> nak: what are you planning to use something like this for...?
22:02:41 <bwiklund> well, not abstractions, though processes
22:02:42 <nak> yeah i'm actually doing something in javascript but i was trying to name a function to model the behavior i wanted
22:02:54 <Cale> Note that even if the result of the function is an IO action, the evaluation of the application of the function to the () argument won't have anything to do with the time at which the IO action is executed.
22:02:54 <nak> "wrap" sounded wrong
22:03:01 <nak> but "const" is exactly the behavior i'm looking for
22:03:24 <Cale> Oh, we're not actually talking about Haskell for some reason
22:03:30 <nak> lol sorry
22:03:39 <nak> Cale i am trying to borrow some ideas from haskell
22:03:52 <jle`> ah i see
22:03:57 <nak> i'm just tinkering with my functional learning in a language i'm more familiar with
22:04:07 <Cale> Yeah, in ML or something, the equivalent of the type () -> A is genuinely different from A
22:04:24 <Cale> In Haskell, these types are nearly the same thing, to the extent that you pretty much never want the former.
22:05:51 <Cale> In ML, you might use the type () -> A as a way to delay the evaluation of something of type A, since ML is strict, but the evaluator won't evaluate under unapplied lambdas.
22:06:06 <nak> Cale interesting
22:06:08 <nak> that's very cool
22:06:34 <Cale> (and of course, Lisp folks have been using the same trick for ages)
22:06:46 <nak> Cale don't they use quoting and unquoting for that ?
22:07:05 <Cale> no, quoting and unquoting have to do with generating code
22:07:09 <nak> o
22:07:42 <nak> is there a good way to remove the the point x from \x -> foo x x
22:07:48 <Cale> join foo
22:07:54 <nak> what does join do ?
22:07:59 <Cale> join f x = f x x
22:08:10 <nak> that's it ?
22:08:11 <nak> lol
22:08:15 <nak> that seems really specific
22:08:24 <Cale> Well, in general, it does other things
22:08:26 <Cale> :t join
22:08:27 <lambdabot> Monad m => m (m a) -> m a
22:08:36 <Cale> > join [[1,2,3],[4,5]]
22:08:37 <lambdabot>  [1,2,3,4,5]
22:08:46 <Cale> > join (*) 5
22:08:48 <lambdabot>  25
22:09:03 <nak> interesting
22:09:05 <nak> i like that
22:09:16 <nak> here's another one i really struggle with
22:09:27 <Cale> join x = x >>= id
22:09:36 <Cale> or, in do-notation
22:09:42 <Cale> join x = do v <- x; v
22:09:51 <Cale> which is equivalent to
22:09:56 <Cale> join x = do v <- x; u <- v; return u
22:09:58 <nak> dangit, i don't know any of that yet
22:10:04 <nak> especially >>=
22:10:13 <nak> that's okay tho, i'm taking notes
22:11:11 <nak> how about removing the x point here:  \f x -> foo (f x) x
22:11:25 <nak> \f -> join (foo . f)
22:11:26 <nak> ?
22:11:29 <nak> that's my best guess
22:11:41 <Cale> @pl \f x -> foo (f x) x
22:11:42 <lambdabot> (foo =<<)
22:11:44 <Cale> :)
22:12:01 <nak> what
22:12:07 <Cale> the bot can do this for us
22:12:18 <nak> wait what seriously?
22:12:31 <jle`> @pl \x -> foo x x
22:12:31 <lambdabot> join foo
22:12:32 <Cale> Yeah, it doesn't always give the best answer, but it works
22:12:49 <nak> how the heck is ... what .s.. (foo =<<) cmon
22:12:49 <nak> that'
22:12:52 <nak> that's not fair
22:12:54 <nak> what is that
22:12:54 <nak> lol
22:12:59 <Cale> It's an operator section of (=<<)
22:13:00 <jle`> you'll learn later :)
22:13:03 <Cale> which is flip (>>=)
22:13:11 <nak> my mind is like 
22:13:13 <nak> OPOOFF
22:13:23 <jle`> (=<<) and (>>=) become pretty common operators in haskell once you're in haskell for a while
22:13:32 <Cale> i.e. (foo =<<) x = foo =<< x
22:13:42 <Cale> Just like  (5 *) 7 = 5 * 7
22:13:44 <jle`> it's not really that crazy of a thing to see a function you don't know about and then not know what it does.  that's normal :)
22:13:50 <Cale> > map (10 *) [1,2,3]
22:13:51 <lambdabot>  [10,20,30]
22:14:01 <ReinH> let bind = (=<<) in bind foo is actual code I have written...
22:14:11 <ReinH> well, I used a where clause, but still
22:14:40 <jle`> chrisdone's bind proposal got shot down but that's because nobody was there to support it.  maybe i would put in my vote if it happened again
22:15:10 <ReinH> chrisdone forgot that it's political ;)
22:15:27 <jle`> that is our world
22:15:33 <ReinH> it's everyone's world..
22:16:43 <Cale> What proposal?
22:17:56 <jle`> bind = (=<<)
22:18:16 <jle`> aka the proposal for a better world
22:18:26 <nak> @pl \g xs -> \x -> g g x:xs
22:18:27 <lambdabot> flip . ((:) .) . join id
22:18:36 * nak blinks
22:18:38 <nak> lol
22:18:39 <nak> this is crazy
22:18:58 <jle`> nak: crazy, yes. and definitely not a good idea :P
22:19:04 <jle`> just because something is complex doesn't mean it's good ^_^
22:19:09 <nak> right
22:19:18 <nak> i know that is completely unmaintainable
22:19:23 <nak> i'm just like ... floored that it's possible
22:19:44 <nak> what is ((:) .) like that ?
22:19:44 <jle`> :)
22:19:50 <jle`> do you know about lists?
22:19:56 <nak> not a ton
22:19:58 <jle`> > 1 : [2,3]
22:19:59 <lambdabot>  [1,2,3]
22:20:02 <nak> yeah i know that much
22:20:07 <jle`> (:) takes an item and a list and conses them
22:20:11 <jle`> > (:) 1 [2,3]
22:20:12 <lambdabot>  [1,2,3]
22:20:18 <nak> well right but ((:) .)
22:20:19 <jle`> do you know what (.) does?
22:20:21 <nak> with the compose
22:20:22 <mbuf> 'cabal install cpphs fay fay-base' and trying to compile ( https://github.com/faylang/fay/blob/master/examples/alert.hs ) using ~/.cabal/bin/fay gives "fay: ghc: ghc: could not execute: cpphs"; what could I be missing?
22:20:34 <jle`> it's another operator section
22:20:37 <nak> yeah (f . g) x == f (g x)
22:20:50 <jle`> `((:) .) f`  is the same as  (:) . f
22:21:04 <jle`> just like (5 *) 2 is the same as 5 * 2
22:21:25 <nak> why not just ((:) . f) then?
22:21:52 <jle`> well
22:21:59 <jle`> what tehy really want is (\f -> (:) . f)
22:22:24 <jle`> so it's flip . (\f -> (:) . f) . join id
22:22:48 <jle`> if you think that understanding the result might lead to enlightenment or better understanding or happiness in the end, i think you might be disappointed :)
22:22:49 <ReinH> nak: When you said \g xs -> \x -> g g x:xs, did you mean \g xs -> \x -> (g g x):xs
22:23:27 <ReinH> because that's a rather odd thing to want
22:23:54 <ReinH> I mean, a function that is passed as an argument that takes itself as an argument...
22:28:20 <nak> ReinH it was just a segment i took from a  u combinator
22:28:31 <nak> i was just seeing what @pl would do with it
22:29:28 <nak> don't make me post actual code i will be so embarrassed
22:29:36 <nak> ReinH this is like day 10 of FP for me lol
22:31:56 <ReinH> nak: Hmm, I wouldn't think translating esoteric combinators to Haskell would be the best way to learn Haskell...
22:32:25 <ReinH> (You also have to deal with the fact that combinatory logic is untyped while Haskell is typed)
22:32:26 <johnw>  unless,  I suppose, it encourages one to dive into why they work
22:32:35 <ReinH> johnw: hi!
22:32:42 <johnw> hiya ReinH 
22:34:22 <haskell658> Hey guys, can you take a look at this: http://lpaste.net/131950
22:34:46 <ReinH> e.g., the y combinator requires some cleverness to even write in Haskell
22:35:18 <nak> ReinH do you promise not to make fun
22:35:41 <ReinH> nak: I am not in the habit of making fun of people
22:37:27 <joneshf-laptop> haskell658, your best bet is to find a closed form solution, so you can compute it in constant time
22:37:31 <joneshf-laptop> or close to it
22:37:46 <Rotaerk> haskell658, your approach is to iterate through every integer from 1 to n - 1...  wouldn't it be faster to only iterate through the multiples, and range-test each result?
22:38:04 <ReinH> (Here's roconnor on the y combinator in Haskell, fwiw http://r6.ca/blog/20060919T084800Z.html)
22:38:18 <haskell658> can I get only the multiples?
22:38:31 <haskell658> Rotaerk can I get only the multiples
22:38:37 <joneshf-laptop> > [3, 6, ..]
22:38:38 <lambdabot>  <hint>:1:8: parse error on input ‘..’
22:38:40 <joneshf-laptop> > [3, 6 ..]
22:38:41 <lambdabot>  [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,...
22:38:54 <haskell658> joneshf-laptop ooh. thats cool
22:39:06 <haskell658> joneshf-laptop theres also a closed form solution
22:39:06 <joneshf-laptop> > let x = 3 in [x, 2 * x..]
22:39:07 <lambdabot>  [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,...
22:39:18 <joneshf-laptop> haskell658, yeah
22:39:20 <ReinH> haskell658: Hmm, 1,000,000 is not a particularly large number
22:39:42 <haskell658> joneshf-laptop might look into that as well
22:39:57 <nak> ok um
22:40:05 <ReinH> I'm not sure that Integer is necessary
22:40:12 <ReinH> > maxBound :: Int
22:40:13 <lambdabot>  9223372036854775807
22:40:15 <nak> cale jle` ReinH  *please* be gentle.... i'm just learning here https://gist.github.com/naomik/f93349d47b847417ac6a
22:40:25 <ReinH> I think there's enough room in Int
22:40:28 <nak> this could be a complete bastardization of all things fp-holy
22:40:32 <nak> but like.. >.<
22:40:33 <nak> ugh
22:40:48 <nak> it's too late... it's already pasted lol
22:41:15 <ReinH> nak: ECMA's new => is a nice notation for functions
22:41:32 <Rotaerk> it's like C#
22:41:32 <ReinH> nak: But better still is ubiquitous currying a la Haskell, as I suppose you've noticed by now
22:41:41 <nak> ReinH yeah... 
22:42:09 <nak> ReinH haskell really shines with the ability to do things like (/5) or (5/)
22:42:10 <ReinH> nak: why are we looking at javascript? :)
22:42:29 <nak> i dunno i'm sorry
22:42:53 <nak> it's more of a generic fp thing
22:43:04 <ReinH> nak: even something like eq = \x y -> x == y vs eq = \x - > \y -> x == y
22:43:18 <ReinH> I'd much rather write eq x y = x == y or eq = \x y -> x == y
22:43:24 <ReinH> than have to manually curry everything
22:43:48 <nak> ReinH but then you can't do: var isEven = compose([eq(0), mod(2)]);
22:44:20 <nak> haskell spoils you in that even your lambdas are auto-curried
22:44:49 <ReinH> exactly
22:44:51 <ReinH> Well
22:44:54 <ReinH> @. pl src even
22:44:54 <lambdabot> even = (0 ==) . (`rem` 2)
22:45:21 <ReinH> your mod function is weird ;)
22:45:30 <nak> wyy
22:45:32 <nak> why*
22:45:32 <joneshf-laptop> haskell658, i feel like it's something very enlightening to derive yourself.
22:45:37 <ReinH> because the arguments are reversed
22:45:38 <joneshf-laptop> haskell658, if you're up for that sort of thing
22:45:44 <nak> ReinH all of the arguments are reversed
22:46:01 <haskell658> joneshf-laptop I would do it. But how do I handle the overlaps
22:46:04 <ReinH> fair enough
22:46:24 <nak> ReinH i think it's more common to partially apply the divisor in mod
22:46:27 <ReinH> luckily eq is commutative... wel, in javascript it isn't
22:46:31 <ReinH> *well
22:47:14 <haskell658> joneshf-laptop would I have to sum up all the overlaps and subtract it from the result?
22:47:28 <joneshf-laptop> haskell658, that works
22:47:48 <ReinH> nak: right, but it's usually written (a mod n) where a is the dividend and n the divisor, so in Haskell you have (a `mod` n), which is rather nice.
22:48:19 <haskell658> joneshf-laptop  ah. I could just implement the same formula but for a*b where a is the first term and b is the second term
22:48:24 <ReinH> joneshf-laptop: is the a euler problem?
22:48:31 <ReinH> it has that flavor.
22:48:40 <joneshf-laptop> haskell658, yeah exactly!
22:48:47 <joneshf-laptop> ReinH, seems like it
22:49:10 <ReinH> joneshf-laptop: usually the euler problems have an inefficient but obvious brute force solution and then one or more layers of cleverness ;)
22:49:17 <joneshf-laptop> ReinH, i think that's the first one, just for a different site
22:49:33 <haskell658> joneshf-laptop marvelous,
22:49:55 <joneshf-laptop> ReinH, yeah, the clever parts are the enlightening bits. 
22:49:57 <ReinH> that's one of the things I like about the euler problems that is often overlooked: they are often surprisingly deep.
22:50:04 <joneshf-laptop> ReinH, kind of miss doing those
22:50:07 <MP2E> i love project euler, used it to pick up Haskell :)
22:50:08 <ReinH> joneshf-laptop: indeed
22:50:14 <MP2E> I should really finish all of the problems
22:50:21 <nak> ReinH i believe i've read your blog before
22:50:27 <ReinH> joneshf-laptop: we used to give euler problems as emailed interview questions at an old job.
22:50:48 <ReinH> when they gave a solution, we'd challenge them to find the more clever solution.
22:50:56 <joneshf-laptop> ReinH, oh? how'd that turn out?
22:51:01 <ReinH> joneshf-laptop: surprisingly well
22:51:05 <ReinH> nak: huh
22:51:26 <mjrosenb> ReinH: what was the range? 0-100, 400-?
22:51:43 <joneshf-laptop> haskell658, but there' still a closed form out there so you can compute it in constant time ;)
22:51:44 <ReinH> joneshf-laptop: I wouldn't think it would be a very good method, but we hired a few very good developers with it... unfortunately the sample size is far too small to be conclusive...
22:52:06 <nak> ReinH i used to do a lot of ruby reading and i recognize your nick from my (past) ruby life
22:52:08 <ReinH> mjrosenb: Oh, my coworker had a few pet questions
22:52:10 <joneshf-laptop> ReinH, double of what mjrosenb asked
22:52:17 <ReinH> nak: Ah, yes, I used to do some Ruby...
22:52:46 <ReinH> One was the sum of fibonacci numbers under 1,000,000 question, iirc
22:53:04 <ReinH> the fibonacci numbers have lots of very interesting properties
22:53:10 <ReinH> and he liked to point them out ;)
22:53:33 <ReinH> oh, the sum of *odd* fibonacci numbers, or something
22:53:49 <joneshf-laptop> ReinH, i can see if being a good filter especially if you have something similar you were working on recently. And since those problems run the gamut, its probably not hard to find something relateed.
22:53:51 <ReinH> which takes advantage of the fact that you can calculate the odd ones in half the time by skipping the even ones, etc
22:54:41 <ReinH> Also it turns out that fibonacci numbers make a nice unbalanced recursion relation, and then you have fibonacci heaps, but we never ever got that far ;)
22:55:08 <ReinH> funny that eventually people realized that unbalanced trees were better for caches and branch prediction
22:55:21 <ReinH> anyway
22:55:26 <ReinH> euler problems are cool :)
22:55:29 <pacak> > sum . takeWhile (< 1000000) $ fix $ (1:) . scanl (+) 1
22:55:30 <lambdabot>  2178308
22:55:43 <ReinH> pacak: :)
22:57:25 <nak> is ((a .) . (b c)) the same as (a . (b c))
22:57:43 <johnw> no
22:58:16 <joneshf-laptop> oh that's neat
22:58:21 <joneshf-laptop> pacak, ^
22:58:33 <ReinH> nak: If you're trying to learn Haskell, I would recommend not doing so via things that require you to think about (a .)
22:59:15 <ReinH> And especially not (a .) . b
22:59:28 <ReinH> @unpl \a b -> (a .) . b
22:59:28 <lambdabot> \ a b f i -> a (b f i)
22:59:44 <shachaf> (. (. f)) is great, though.
23:00:13 <ReinH> shachaf: hmm, why is (. (. f)) great?
23:00:44 <pacak> ReinH: It's a great way to make other people hate you.
23:00:55 <shachaf> I like it more than (f .) . g. I don't actually recommend it for people who are learning Haskell.
23:01:02 <ReinH> :t \f -> (. (. f))
23:01:03 <lambdabot> (a -> b) -> ((a -> c1) -> c) -> (b -> c1) -> c
23:01:14 <ReinH> Well, that was illuminating...
23:01:38 <ReinH> Oh. Ok.
23:01:59 <shachaf> It's double-contravariant mapping. The argument of the argument.
23:02:18 <ReinH> Right.
23:02:49 <shachaf> A fun exercise is to figure out the adjunction that gives you the monad Cont r. (-> r) -| (-> r)
23:02:56 <ReinH> @unpl \f -> (. (. f))
23:02:56 <lambdabot> \ f b e -> b (\ i -> e (f i))
23:02:57 <nak> ReinH the infix just screws with my head sometimes 
23:03:13 <ReinH> shachaf: That actually does sound fun.
23:03:36 <ReinH> shachaf: I'm going to remember that for when I'm not about to fall asleep and bother you.
23:03:54 <ReinH> More or less depending on how stupid I am.
23:04:20 <shachaf> The first step is to figure out what "(-> r) -| (-> r)" means.
23:04:39 <ReinH> heh
23:05:19 <ReinH> Uh. So...
23:05:39 <ReinH> Yep, not tonight.
23:09:33 <ReinH> shachaf: damn, I think your nerd snipe was successful
23:11:38 <ReinH> shachaf: so Cont r is missing a parameter.
23:12:05 <shachaf> Yes, that's part of being a monad.
23:12:16 <ReinH> Oh. Duh
23:12:17 <bracket_> for noobs (like myself), nice explanation of 'fix': http://www.vex.net/~trebla/haskell/fix.xhtml
23:12:36 <ReinH> shachaf: See why this is the wrong time for me to be attacking this problem? ;)
23:13:18 <ReinH> shachaf: Would it help to find a counit?
23:14:08 <shachaf> The way you approach the problem is up to you.
23:14:14 <shachaf> I like to start by figuring out what the problem is.
23:14:23 <ReinH> That does seem prudent.
23:17:25 <mbuf> anyone here use fay?
23:19:34 <ReinH> shachaf: Well, I'm thinking of class (Functor f, Functor g) => Adjoint f g | f -> g, g -> f
23:20:11 * hackagebot step-function 0.1.0.2 - Step functions, staircase functions or piecewise constant functions  http://hackage.haskell.org/package/step-function-0.1.0.2 (petterb)
23:20:22 <ReinH> where eta :: a -> g (f a); epsilon ::f (g a) -> a
23:21:17 <ReinH> and instance Adjoint ((->) e) ((->) e)
23:23:32 <shachaf> That would need to be more general than the Prelude Functor.
23:25:35 <ReinH> Hmm.
23:25:39 <ReinH> But just for fun,
23:25:47 <ReinH> :t undefined :: (f ~ ((->) e), g ~ ((->) e)) => f (g a) -> a
23:25:48 <lambdabot> (e -> e -> a) -> a
23:26:01 <ReinH> :t undefined :: (f ~ ((->) e), g ~ ((->) e)) => a -> g (f a)
23:26:02 <lambdabot> a -> e -> e -> a
23:26:42 <ReinH> @djinn (e -> e -> a) -> a
23:26:42 <lambdabot> -- f cannot be realized.
23:26:50 <ReinH> No, of course not
23:27:14 <johnw> ReinH: another way to "implement" an adjunction is the isomorphism F c -> d ≅ c -> G d
23:27:20 <shachaf> ((->) e) is not (-> e)
23:27:31 <ReinH> shachaf: Oh damn.
23:27:40 <ReinH> shachaf: thanks
23:28:24 <ReinH> johnw: hom-set adjunction, right
23:29:22 <ReinH> shachaf: I can't work with (-> e) nicely in Haskell, can I? :(
23:29:28 <shachaf> Another fun exercise (not completely obvious when you look at the details) is to figure out how to go between those definitions.
23:29:35 <ReinH> Since type sections aren't a thing
23:29:48 <shachaf> You can say newtype Op e a = Op (a -> e)
23:30:16 <ReinH> shachaf: Oh right thanks
23:30:26 <shachaf> But I don't recommend it.
23:31:02 <ReinH> shachaf: regarding going between them, something something Yoneda I'm sure...
23:31:37 <shachaf> No. You have two different-looking definitions of a relationship between functors. Use one to prove that the other holds.
23:39:05 <lf94> https://hackage.haskell.org/package/json-0.7/docs/Text-JSON-Types.html#t:JSObject
23:39:15 <lf94> How do I access attributes of the JSObject in Haskell?...
23:39:21 <lf94> I can't quite wrap my head around it.
23:39:34 <lf94> For example, I have a JSON like this coming to me:
23:39:46 <ReinH> shachaf: brb, watching https://www.youtube.com/watch?v=USYRDDZ9yEc&list=PL50ABC4792BD0A086 on string diagrams again
23:39:54 <lf94> { "success":"false", "code":"aoesutahsoeuh", "error":"oasuthsaou" }
23:40:00 <lf94> How do I access error?
23:40:07 <shachaf> I don't think you need string diagrams.
23:40:22 <ReinH> shachaf: well, historically they have helped me reason about constructing monads from adjunctions
23:40:24 <shachaf> One of Eugenia's videos goes through showing how to go back and forth.
23:40:49 <ReinH> shachaf: but if you know which video that is I would love to watch it
23:41:19 <shachaf> I think it's just the series on adjunctions.
23:41:33 <jle`> lf94: are you sure you want to be using version 0.7 ?
23:41:39 <jle`> what version of ghc do you have?
23:41:44 <ReinH> shachaf: fair enough, I think I'll watch those again
23:42:04 <lf94> jle`: Has the API changed?
23:42:11 <lf94> jle`, uhhhh
23:42:24 <jle`> lf94: yeah, 0.7 was about three years ago
23:42:31 <lf94> The Glorious Glasgow Haskell Compilation System, version 7.6.3
23:43:13 <jle`> hm it looks like the api is the same 
23:43:20 <jle`> i was thinking about aeson
23:43:24 <lf94> Oh X)
23:43:25 <ReinH> ... is also a few years old
23:43:31 <lf94> Yeah I saw that one too
23:43:36 <ReinH> jle`: json is old but relatively unchanged
23:43:48 <ReinH> I'm not sure why anyone would choose it over aeson though
23:43:59 <lf94> Because it comes included with ghc
23:44:04 <lf94> at least my ghc package
23:44:14 <lf94> (Debian)
23:44:27 <lf94> So what do I do?
23:45:00 <jle`> hm. if you're doing any serious haskell development, i suggest you don't use the debian repos and install ghc on your own.  and then use cabal to install aeson
23:45:26 <ReinH> I'd recommend installing a modern ghc and using cabal to install packages
23:45:29 <jle`> if it's just something one-off then you can use fromJSObject and then `lookup` from Data.List
23:45:39 <jle`> if you're never going to do any haskell ever again after the next half hour
23:45:50 <ReinH> hvr/ghc has a ppa you can use for debian
23:46:05 <lf94> lol
23:47:54 <lf94> Well, that is odd
23:47:54 <nak> can someone walk me through how this works
23:47:56 <ReinH> sudo add-apt-repository -y ppa:hvr/ghc && sudo apt-get update && sudo apt-get install cabal-install-1.22 ghc-7.8.4 && export PATH=/opt/ghc/7.8.4/bin:/opt/cabal/1.22/bin:$PATH
23:48:00 <nak> @pl \x f -> f x
23:48:00 <lambdabot> flip id
23:48:04 <lf94> Seems to be no way to do String -> JSObject String
23:48:13 <nak> id only accepts one argument, right ?
23:48:21 <ReinH> :t flip id
23:48:22 <lambdabot> b -> (b -> c) -> c
23:48:37 <ReinH> :t flip ($)
23:48:38 <lambdabot> a -> (a -> c) -> c
23:48:52 <lf94> ReinH, thank you, but no thank you. I will save it in my notes though :)
23:48:57 <kadoban> nak: It does, but … that one argument can be anything. Including a function, heh.
23:49:03 <ReinH> > succ `id` 1
23:49:05 <lambdabot>  2
23:49:23 <ReinH> lf94: fyi, https://launchpad.net/~hvr/+archive/ubuntu/ghc
23:49:27 <bitemyapp> lf94: https://github.com/bitemyapp/learnhaskell/blob/master/install.md
23:49:44 <jle`> > id show 1
23:49:46 <lambdabot>  "1"
23:49:52 <jle`> (id show) 1   = show 1
23:50:26 <ReinH> :t id id id id id
23:50:27 <lambdabot> a -> a
23:50:43 <ReinH> nak: every Haskell function accepts exactly one argument ;)
23:51:24 <nak> hmm well that's really neat
23:52:14 <jle`> you can see it by looking at the source of id
23:52:16 <jle`> @src id
23:52:16 <lambdabot> id x = x
23:52:24 <jle`> id x = x, so id show = show
23:52:58 <nak> ah ok i see it a little better
23:53:02 <bernalex> the realisation that ($) is just 'id' monomorphic to functions (a->b) is useful.
23:53:15 <ReinH> :t ($)
23:53:16 <lambdabot> (a -> b) -> a -> b
23:53:17 <ReinH> :t id
23:53:18 <lambdabot> a -> a
23:53:32 <nak> ((flip id) x f) == ((id f) x)
23:53:44 <nak> and since (id f) returns f...
23:53:53 <nak> ok radical and cool
23:53:54 <nak> i like it
23:54:07 <johnw> ReinH: http://www.pps.univ-paris-diderot.fr/~ruet/papiers/autoadj.ps.gz
23:54:32 <bernalex> (that's not 100% true now because of some ad-hoc typing rules for ($), but...)
23:54:51 <johnw> ReinH: something I think shachaf could have mentioned is that (-> r) as he stated are not endofunctors on Hask, but [Hask, Hask^op] and [Hask^op, Hask]
23:55:09 <ReinH> Hmm
23:55:19 <shachaf> That was the first part of the exercise.
23:55:23 <ReinH> heh
23:55:47 <johnw> taking that into account, the isomorphism version is completely trivial
23:55:58 <ReinH> johnw: shachaf will attempt to teach a man to fish if it's the death of him, which I do rather like... most of the time...
23:56:18 <johnw> I'm not entirely sure what his didactic motivations are
23:56:41 <ReinH> "But I'm hungry..."
23:57:17 <ReinH> shachaf: Ah, that was implied by the "lacking generality" you aluded to before.
23:57:29 <ReinH> I see...
23:57:37 <shachaf> Sort of.
23:57:53 <ReinH> (since Functor is for endofunctors)
23:57:57 <shachaf> Another fun exercise is to figure out what instances that class can have.
23:58:20 <ReinH> shachaf: Well, ((-> e) and ((,) e) come to mind
23:58:27 <shachaf> They're all isomorphic to (e,) -| (e ->)
23:58:31 <ReinH> heh
23:58:31 <shachaf> That's the only instance.
23:58:41 <ReinH> gotcha
23:58:53 <ReinH> man, type sections really would be nice
23:59:07 <ReinH> :set -XTupleTypeSections
23:59:10 <jle`> too bad they'd throw off typeclass lookups :'(
