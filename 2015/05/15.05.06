00:09:02 * hackagebot feed 0.3.9.4 - Interfacing with RSS (v 0.9x, 2.x, 1.0) + Atom feeds.  http://hackage.haskell.org/package/feed-0.3.9.4 (AdamBergmark)
00:34:03 * hackagebot Earley 0.8.0 - Parsing all context-free grammars using Earley's algorithm.  http://hackage.haskell.org/package/Earley-0.8.0 (OlleFredriksson)
00:37:27 <jle`> good ol' earley
00:39:03 * hackagebot PortMidi 0.1.4 - A binding for PortMedia/PortMidi  http://hackage.haskell.org/package/PortMidi-0.1.4 (PaulLiu)
00:47:39 <Dongyancai> Hello, how can I create multiple channels with a single expression? chan <- mapM newChan [1..10] makes error.
00:48:31 <lyxia> Dongyancai: What error?
00:48:41 <lyxia> Oh.
00:48:52 <lyxia> replicateM 10 newChan
00:49:09 <jle`> yeah, `newChan 10` doesn't really make sense
00:49:27 <Dongyancai> Oops, I fogot that map applies the arguments.
00:49:48 <ollef> jle`: now with support for ghc 7.8 thanks to phadej :)
00:50:00 <jle`> ollef: :D
00:50:22 <Dongyancai> I haven't written for more than a season.
00:50:36 <jle`> Dongyancai: definitely understandable :)
00:55:48 <notdan> is there something like `try` and `catch` but for arbitrary IO monads?
00:56:08 <Zemyla> Man, I love monad classes right about now. I needed to switch around the locations of the Error and State monads, and I did so without rewriting a whole fuckload of lifts.
00:56:49 <jle`> notdan: i think monad-control is supposed to be for things like that
00:56:51 <Zemyla> notdan: IO is an instance of MonadError, and any monad transformer worth its salt lifts it.
00:57:24 <notdan> ah, MonadError
00:57:28 <notdan> thanks jle` Zemyla 
00:57:30 <supki> :t Control.Monad.Catch.try
00:57:31 <lambdabot> (Exception e, Control.Monad.Catch.MonadCatch m) => m a -> m (Either e a)
01:19:04 * hackagebot singleton-nats 0.2.0.0 - Unary natural numbers relying on the singletons infrastructure.  http://hackage.haskell.org/package/singleton-nats-0.2.0.0 (AndrasKovacs)
01:24:22 <Zemyla> What is the internal representation in Haskell of a foralled object that isn't a function?
01:24:51 <Zemyla> Like, newtype M a = M (forall m. (Monad m) => m a).
01:27:02 <opqdonut> I guess it's still a function, as type class constraints get converted to dictionary passing
01:28:54 <shachaf> "foralled" isn't important, since types are erased anyway.
01:29:17 <shachaf> But GHC compiles => into ->, barring optimizations.
01:30:01 <shachaf> So you'd expect the same representation for e.g. "newtype M m a = M (Monad m => m a)"
01:50:16 <deezn> erisco you here?
01:51:03 <Zemyla> Why do I find it so hard to write comments?
01:56:48 <deezn> Someone want to help clarify this for me: data Nat = Z | S Nat
01:56:48 <deezn>   
01:56:50 <deezn> data SNat (n :: Nat) where
01:56:51 <deezn>   Zero :: SNat Z
01:56:51 <deezn>   Succ :: SNat m -> SNat (S m)
01:57:11 <jle`> deezn: any question in particular?
01:57:56 <deezn> Yes I am still confused with what is going on here with the GADT.. and the syntax
01:58:19 <deezn> What is the Z?
01:58:25 <jle`> Z is a type
01:58:41 <jle`> so Zero is an SNat constructor that gives you an SNat Z
01:58:49 <jle`> Zero :: SNat Z  (it has type SNat Z)
01:59:19 <deezn> ..oh wait.. yep.. got that.. 
01:59:39 <jle`> just like data Maybe (a :: *) where Nothing :: Maybe b; Just :: b -> Maybe b
02:00:13 <jle`> Z is defined in data Nat = Z | S Nat, as a type, through DataKinds
02:00:34 <jle`> data Nat = Z | S Nat usually makes a type Nat, and a value Z :: Nat, and a value constructor S :: Nat -> Nat
02:00:51 <jle`> with DataKinds, it also makes a *kind* Nat, a *type* Z, and a *type constructor* S
02:01:00 <jle`> Z having kind Nat, and S having kind Nat -> Nat
02:01:20 <jle`> in the definition of SNat, it's using Nat as a Kind and Z as a type and S as a type constructor
02:01:54 <ion> SNat mirrors the structure of Nat and lets you convert a type-level Nat into the equivalent value-level thing.
02:01:54 <deezn> still confused.. I will brb in a sec off to look at the code.
02:04:06 * hackagebot test-invariant 0.4.4.0 - Provide common invariants to be checked with QuickCheck  http://hackage.haskell.org/package/test-invariant-0.4.4.0 (knupfer)
02:08:01 <Zenol_> Hi. I would like to no if there is a function in standard haskell to sort a (Ord set) => [set] and get the signature of the permutation sigma used.
02:08:34 <opqdonut> not in the standard library, no. you might find something on hackage
02:09:10 <opqdonut> here: https://hackage.haskell.org/package/permutation-0.5.0.5/docs/Data-Permute.html
02:10:46 <Zenol_> Thanks donut, i'm checking the doc :)
02:12:21 <absence> the type signature of Data.Function.on looks a bit like contramap with a bit of squinting. is there a relation?
02:14:54 <jophish> I find myself repeating information in the .cabal description and in the readme. How do people deal with this?
02:15:34 <indiagreen> jophish: some put a link to the readme in description
02:15:48 <felixsch> Im playing arround with Yampa. I got [SF a b] and I'm searching something similar to map ([SF a b] -> SF a b)? I looked over ArrowLoop but I did not understand how its actually working? Anybody knows a good resource about ArrowLoop?
02:16:37 <jophish> indiagreen: yeah, that seems like a good idea
02:16:38 <hexagoxel> jophish: what indiagreen said. .cabal doc is annoying to write anyway.
02:20:39 <jophish> yeah, I'm finding that too, thanks hexagoxel
02:24:30 <jle`> felixsch: what do you mean by map ([SF a b] -> SF a b) ?
02:25:02 <felixsch> jle`: I mean I searching for something similar to map for Arrows
02:25:15 <jle`> map in what way?
02:25:29 <jle`> can you give a type signtuare?
02:25:30 <felixsch> fold sorry
02:25:42 <jle`> mapping a (b -> c) over an [SF a b] to get an [SF a c] ?
02:25:44 <jle`> ah ok
02:25:56 <jle`> how would you expect it to fold...?
02:26:13 <jle`> where is the final `b` coming from?
02:26:25 <jle`> if you have [SF a a] you can use foldr (.) id to chain them all
02:26:49 <jle`> [f1,f2,f3] => f1 . f2 . f3
02:27:10 <felixsch> your right I'm writing nonsens right now... give me some seconds :D
02:27:15 <jle`> if you want to send an `a` to all of the SF a b's, you can use sequence :: [SF a b] -> SF a [b]
02:27:25 <jle`> and then use fmap to fold down your [b] into something you want
02:27:37 <jle`> sorry not sequence, sequenceA
02:28:50 <felixsch> Ah right.
02:29:06 <jle`> that will feed the a through all the SF's, run them in parallel, and aggregate the b outputs
02:29:58 <arkeet> :t \f -> fmap f . sequenceA
02:29:59 <lambdabot> (Applicative f, Traversable t) => (t a -> b) -> t (f a) -> f b
02:30:04 <felixsch> sounds nice I will have to look
02:30:20 <jle`> if b is a monoid, you can use mconcat :: Monoid b => [SF a b] -> SF a b, assuming SF has the reasonable Monoid instance
02:30:39 <arkeet> :t \f -> fmap fold . sequenceA
02:30:40 <lambdabot> (Applicative f, Traversable t, Monoid b) => r -> t (f b) -> f b
02:30:41 <jle`> that'll feed the a through all the SF's, also, and mconcat all of the results together to get a b
02:30:43 <arkeet> er
02:30:46 <arkeet> :t fmap fold . sequenceA
02:30:48 <lambdabot> (Applicative f, Traversable t, Monoid b) => t (f b) -> f b
02:31:32 <jle`> yeah, `mconcat` would do the same thing, assuming SF has the reasonable Monoid instance.
02:31:40 <jle`> if not then that works :)
02:34:22 <felixsch> I was just in a complete wrong direction. Arrows still wired for me and Yampa does not makes it any better. Thank you for helping me out :)
02:34:32 <jle`> no problem :)
02:34:49 <jle`> by the way, not everything involving SF is 'arrows'
02:35:00 <jle`> wires/sf are a lot of things, and arrow is just one of the instances
02:35:32 <jle`> hm.
02:35:34 <jle`> nevermind
02:35:37 <felixsch> :D
02:35:45 <jle`> it looks like the way SF is implemented, it only offers an Arrow, Arrowloop, Category instance
02:35:49 <jle`> how unfortunate
02:35:56 <jle`> any reason why you're using yampa?
02:36:08 <felixsch> to learn arrows :D
02:36:18 <jle`> ah heh
02:36:35 <jle`> yeah, yampa is a bit of an outdated library in this sense
02:36:58 <jle`> almost all of yampa's arrow would have been replaced by Applicative if yampa was written in modern times when Applicative has been a thing
02:37:29 <jle`> well, my main point is, arrow is a bit of a useless thing to learn just for learning it
02:37:53 <jle`> almost all of the applications it has once been used for has been supplanted by more modern abstractions like Applicative
02:38:10 <jle`> for the most part it is a remnant of an older era
02:38:34 <jle`> and the things it was invented to do, it doesn't even do particularly well in most situations
02:38:40 <arkeet> an Arrow is just a Strong Profunctor that is also a Category
02:38:52 <arkeet> (equivalently, a Strong Profunctor with arr)
02:39:05 <jle`> or a Category with Applicative :D
02:39:11 <arkeet> no, that's not enough.
02:39:15 <arkeet> or is it
02:39:22 <jle`> it is, actually
02:39:27 <arkeet> how do you define arr
02:39:29 <jle`> arr f = fmap f . id
02:39:32 <arkeet> right.
02:39:34 <jle`> er, fmap f id
02:40:31 <jle`> f &&& g = liftA2 (,)
02:40:49 <arkeet> :t liftA2 (,)
02:40:50 <lambdabot> Applicative f => f a -> f b -> f (a, b)
02:40:55 <arkeet> mhm
02:41:04 <jle`> first second and *** are sort dirty
02:41:10 <jle`> their implementations aren't as cute
02:41:15 <jle`> but they are doable
02:41:20 <jle`> *sort of
02:41:44 <felixsch> but what would be a nice alternative? I looked into netwire but I decied to stick with Yampa because there are example to look at.
02:42:14 <jle`> netwire is yampa but with a modern interface with Applicative, Alternative, etc.
02:42:28 <arkeet> :t \f -> arr fst &&& arr f
02:42:29 <lambdabot> Arrow a => ((c, b) -> c') -> a (c, b) (c, c')
02:42:37 <arkeet> :t \f -> arr fst &&& f
02:42:38 <lambdabot> Arrow a => a (c, b) c' -> a (c, b) (c, c')
02:42:44 <arkeet> uh.
02:42:50 <arkeet> :t \f -> arr fst &&& (f . arr snd)
02:42:51 <lambdabot> (b -> c') -> (c, b) -> (c, c')
02:42:54 <arkeet> no.
02:43:03 <arkeet> :t \f -> arr fst &&& (f <<< arr snd)
02:43:04 <lambdabot> Arrow a => a b c' -> a (a1, b) (a1, c')
02:43:11 <jle`> :)
02:43:25 <arkeet> :t \f g -> (f <<< arr fst) &&& (g <<< arr snd)
02:43:27 <lambdabot> Arrow a => a a1 c -> a b c' -> a (a1, b) (c, c')
02:43:30 <arkeet> good enough for me.
02:43:47 <muzzle> hi
02:43:57 <muzzle> is there any good tutorial for edward kmetts linear package ?
02:44:13 <muzzle> or some good examples
02:44:19 <jle`> felixsch: i'd recommend netwire over yampa because it's considerably more usable by taking advantage of advancements in haskell abstractions in the past decade or so.  but if you just want to learn arrows... first i'd tell you to really rethink that goal ^^
02:44:25 <jle`> muzzle: there's ocharles_'s tutorial
02:44:44 <jle`> muzzle: https://ocharles.org.uk/blog/posts/2013-12-02-24-days-of-hackage-linear.html
02:45:17 <jle`> the library itself isn't all that complex though
02:45:35 <jle`> but sometimes it's awkward finding out where certain operations are located
02:46:10 <absence> can i define newtypes and instances for an expression on lambdabot?
02:46:21 <muzzle> what I don't really understand is how you can work with high dimensional matrices
02:46:56 <jle`> felixsch: if you are really determined to learn arrows 'just because', then there are some more modern libraries to try out too.  netwire is one, and also `auto` offers and encourages an arrowized interface for a lot of problems too...both offer this on top of Applicative
02:47:02 <jle`> muzzle: how do you mean?
02:47:05 <arkeet> muzzle: a matrix is just represented as a vector of vectors
02:47:46 <arkeet> so you just need a suitable high dimensional thing with an Additive instance or whatever.
02:47:47 <muzzle> arkeet: there is e.g. a type for 4x4 matrices but how do i make it work for nxm matrices
02:48:19 <jle`> a 4x3 matrix could be a V4 (V3 a)
02:48:22 <jle`> for nxm you'd use V
02:48:26 <jle`> V n (V m a)
02:48:42 <Dongyancai> Hello, I followed an instruction on http://stackoverflow.com/questions/2981984/, and got this following message as http://pastebin.com/4Ea14dkC. How can I correct it?
02:49:02 <jle`> muzzle: oh, you don't need to
02:49:07 * hackagebot js-jquery 1.11.3 - Obtain minified jQuery code  http://hackage.haskell.org/package/js-jquery-1.11.3 (NeilMitchell)
02:49:10 <jle`> do you mean, how do you write *generic* functions?
02:49:17 <jle`> functions generic over all nxm matricies?
02:49:31 <jle`> if so, you can just use the type classes thtat talk about the operations you are talking about
02:49:38 <muzzle> jle`: yes
02:49:41 <jle`> to actaully have an nxm matrix data type, you can use V n (V m a)
02:49:55 <arkeet> e.g. look at the types of the functions in Linear.Matrix
02:50:00 <muzzle> that and I don't understand how to construct arbitrary size matrices
02:50:32 <jle`> for example, you can use (!+!) to add two matrices of equal dimension...no matter what the dimensions are
02:51:08 <jle`> or A !* x to multiply matrix A by vector x of a suitable size
02:51:28 <jle`> these work for V2, V3, V4, V n, etc.
02:52:02 <muzzle> jle`: ok but I don't understand how i can create say a 7*9 matrix
02:52:08 <jle`> if you know what size you want, and it's actually a type, you can make a 2x3 matrix by doing something like V2 (V3 x y z) (V3 x y z)
02:52:14 <jle`> ah
02:52:31 <jle`> to make a V 9 a, for example, you'd use fromVector
02:52:42 <jle`> which takes something from Data.Vector
02:52:50 <jle`> which is a type that's like an array in other languages
02:53:08 <jle`> fromVector :: Vector a -> Maybe (V n a)
02:53:09 <arkeet> maybe that module should have fromList too
02:53:42 <jle`> it's a Maybe because your Vector might not have enough elements to hold a `V 9 a`
02:53:46 <jle`> s/hold/fill
02:53:52 <arkeet> or too many
02:55:01 <arkeet> although you actually write V $(9) a (with template haskell)
02:55:06 <jle`> yeah, i was going to say
02:55:25 <jle`> cause no type lits ;_;
02:55:44 <saulzar> Though probably by the time you're up to 9 Linear is not the right library...
02:56:14 <arkeet> yeah it's definitely geared toward lower dimensional stuff
02:56:19 <saulzar> (Or at least not too much more than that I imagine)
02:56:30 <muzzle> :saulzar so would I use for higher dimensional stuff ?
02:56:33 <jle`> but where else are you going to find linear algebra stuff besides ffi'ing to hblas or something?
02:56:55 <arkeet> there are some other things like hmatrix or repa
02:57:00 <arkeet> that may or may not be more suitable
02:57:10 <jle`> oh yeah hmatrix
02:57:22 <jle`> i don't think repa does any linear algebra tho
02:57:24 <saulzar> Though as you say it's a wrapper around blas etc..
02:57:46 <jle`> at least it's a haskelly abstraction instead of doing it manually, heh
02:58:18 <saulzar> Accelerate is a really exciting library there, too 
02:58:51 <Bashmetim> Dumb question - does haskell *actually* never modify the state of data that's been declared?
02:58:52 <arkeet> well there's some stuff like https://hackage.haskell.org/package/repa-algorithms-3.3.1.2/docs/Data-Array-Repa-Algorithms-Matrix.html
02:59:17 <tdammers> Bashmetim: what do you mean, "actually"?
02:59:33 <tdammers> if you declare a variable with `let`, its value doesn't change
02:59:54 <jle`> Bashmetim: haskell doesn't really talk about any values changing, but it's up the compiler to compile your code to as efficient a way as possible while still retaining what you originally meant
03:00:12 <tdammers> but as when the runtime determines that it is no longer needed, it will be garbage-collected, and the memory it occupied may be used to store something else
03:00:16 <jle`> so no, haskell doesn't really have a meaningful way to talk about declared values changing
03:01:01 <Bashmetim> If I'm recursively adding elements to a dictionary, I'm assuming it doesn't copy the entire thing after every iteration...
03:01:24 <jle`> often times it actually doesn't have to copy the entire thing, due to sharing
03:01:27 <saulzar> Nope, it changes values from the leaf to the root and shares the rest of it
03:01:59 <jle`> for example, if i had a list x = [1,2,3], and a new list y = 0:x, then y is [0,1,2,3], but it just stores 0 -> see x for the rest
03:02:15 <jle`> so x and y are two different lists, but the [1,2,3] only exists once in memory
03:02:50 <Bashmetim> That makes sense, lists are a pretty easy example actually
03:02:56 <jle`> so if i recursively keep on (:)-consing items to a list several times, nothing is ever copied really
03:03:13 <jle`> you're just adding new 'head' nodes that point to the previous head that you made
03:03:14 <saulzar> _because_ it knows the value swill never change it can always share any unchanged part between different data structures
03:04:08 * hackagebot reflex-dom 0.1.1 - Glitch-free Functional Reactive Web Apps  http://hackage.haskell.org/package/reflex-dom-0.1.1 (RyanTrinkle)
03:04:23 <Bashmetim> But if I say "take 100 list" - it would it copy the first 100 elements?
03:04:35 <jle`> let's look at the source :)
03:04:37 <jle`> @src take
03:04:37 <lambdabot> take n _      | n <= 0 = []
03:04:37 <lambdabot> take _ []              = []
03:04:37 <lambdabot> take n (x:xs)          = x : take (n-1) xs
03:05:01 <jle`> that was a little less helpful than i had hoped
03:05:13 <jle`> yes, you'd have to copy 100 cells.  not the 100 elements, of course
03:05:21 <opqdonut> Bashmetim: it doesn't copy the elements, it copies the "cons cells"
03:05:26 <jle`> but you'd make 100 new cells pointing to the original 100 elements
03:05:26 <Bashmetim> The 100th element needs to point to [], and that's not the case in the original list...
03:05:41 <jle`> yeah, all 100 of the cells needed to be re-allocated
03:05:49 <jle`> but they still point to the same elements...the elements are never copied
03:06:05 <Bashmetim> Okay, that makes a lot of sense too... That's clever
03:06:30 <jle`> ironically again this only is possible *because* the elements are guarunteed to never chage
03:06:41 <jle`> s/ironically/synergetically
03:07:28 <ion> /
03:07:36 <Bashmetim> (y)
03:07:39 <saulzar> In the implementation(s) everything is basically a pointer, which is good for sharing (probably not so ideal for memory accesses)
03:10:05 <arw> and there are possible inefficiencies if the pointee is only as big or smaller than a pointer
03:10:19 <Bashmetim> So internally, id Int is just the result of malloc(sizeof(int)), and the runtime handles all the rest?
03:10:56 <saulzar> Though I think it's not so bad as it might seem because the allocators used are fairly well tuned for that kind of usage
03:11:24 <arw> Bashmetim: it could be even less because of constant propagation and inlining.
03:11:40 <Lis> Hello everyone. I have a list of lists and want to remove the first elements [[1,2],[3,4],[5,6]] should become [[1],[3],[5]] how could this be done?
03:11:51 <jle`> Lis: how about map (take 1) ?
03:12:01 <jle`> > map (take 1) [[1,2],[3,4],[5,6]]
03:12:03 <lambdabot>  [[1],[3],[5]]
03:12:15 <Lis> hmhm ok thank you :D
03:12:26 <jle`> i'm assuming you know about map and take 1 :)
03:12:28 <jle`> np!
03:12:46 <Bashmetim> https://en.wikipedia.org/wiki/Constant_folding <- interesting
03:13:25 <jle`> Bashmetim: unless the compiler can optimize it away, most values are not just pointers...they also contain some extra flags to handle laziness and whether or not something is evaluated, how it demand something, etc.
03:13:35 <jle`> but a lot of times things are optimized away
03:13:53 <Lis> > map (take 1) [[1,2,11],[3,4,12],[5,6,13]]
03:13:54 <lambdabot>  [[1],[3],[5]]
03:14:10 <Lis> > map (tail) [[1,2,11],[3,4,12],[5,6,13]]
03:14:11 <lambdabot>  [[2,11],[4,12],[6,13]]
03:14:16 <Lis> ah :D
03:14:23 <arkeet> > map (tail) [[1,2,11],[3,4,12],[],[5,6,13]]
03:14:23 <jle`> i'd use `drop 1` instead of tail
03:14:24 <lambdabot>  [[2,11],[4,12],*Exception: Prelude.tail: empty list
03:14:31 <jle`> using tail might cause some unexpected headaches
03:14:33 <jle`> yeah
03:14:38 <Lis> ah ok, ty
03:14:55 <jle`> > map (drop 1) [[1,2,11],[3,4,12],[],[5,6,13]]
03:14:56 <lambdabot>  [[2,11],[4,12],[],[6,13]]
03:14:58 <jle`> or you can filter out empty lists first
03:15:07 <jle`> by using `filter (not . null)`
03:15:15 <jle`> yeah i don't even know why head and tail are in Prelude
03:15:25 <jle`> like, why?
03:15:29 <jle`> . o O ( why? )
03:15:36 <ion> Someone thought it would be a good idea at the time.
03:15:42 <ion> Also: fromJust etc.
03:15:42 <arkeet> > [xs | x:xs <- [[1,2,11],[3,4,12],[],[5,6,13]] ]
03:15:44 <lambdabot>  [[2,11],[4,12],[6,13]]
03:15:52 <jle`> is fromJust really in prelude?
03:15:58 <ion> Well, base
03:16:01 <Bashmetim> Where would they go if not in Prelude?
03:16:04 <Bashmetim> Data.List?
03:16:04 <jle`> Data.List
03:16:06 <jle`> yeah
03:16:09 <arkeet> Data.Maybe
03:16:25 <arkeet> oh, head and tail yeah.
03:16:45 <jle`> just places where new people wouldn't immediately think to reach for them at every opportunity
03:16:57 <jle`> having something in Prelude sort of suggests, 'use me!'
03:17:00 <Bashmetim> Doesn't Prelude import a subset of a lot of the Data.* packages
03:17:02 <Bashmetim> ?
03:17:06 <arkeet> yes
03:17:09 <frerich> I think the partial functions like 'tail' aren't so bad because they force you to think. With 'drop 1' you avoid the exception but suddenly get the same output for empty lists as well as singleton lists (of course, if that's just what you want, you're all good -- but chances are you didn't consider this).
03:17:32 <Bashmetim> > drop 1 []
03:17:34 <lambdabot>  []
03:17:58 <jle`> i don't think they're 'so bad'
03:17:59 <Bashmetim> Coming from lisp that's sort of what I'd expect tail to do
03:18:11 <Bashmetim> (cdr nil) -> nil
03:18:16 <jle`> but i think a lot of situations that people learning haskell use tail for are usages where they aren't intending the actual behavior
03:18:47 <ion> frerich: [a] -> Maybe [a] would force you to think by way of the type system. [a] -> [a] that may crash just has the unchecked notion of “you may want to think about this”.
03:18:57 <jle`> also i would rather have foldl' in Prelude instead of foldl
03:19:03 <jle`> who even decided this
03:19:10 <frerich> jle`: Absolutely However, at least you get a very noisy failure. With 'drop 1', the fact that singletons as well as null lists map to the same output may be unintended as well but that error may manifest itself only further down the road.
03:19:21 <saulzar> jle`, Someone in 1997? :)
03:19:23 <jle`> the one that you should practically never use ever is in Prelude, and the one that you should practically always prefer is in Data.List
03:19:27 <ronh-> jle` I'd rather if foldl didn't even exist, and foldl' was renamed
03:19:37 <pharpend> Morning, everyone. (Or really late night, depending on your school of thought)
03:19:45 <jle`> morning/night :)
03:19:47 <ion> early afternoon
03:19:47 <arkeet> (and timezone)
03:20:02 <deezn> Guys what is this in haskell : “:::”
03:20:07 <frerich> ion: True, I think '[a] -> Maybe [a]' would be nice
03:20:19 <jle`> deezn: (:::) is probably just a user or library defined operator
03:20:31 <jle`> > let x ::: y = x*y = 2 ::: 5
03:20:32 <lambdabot>  <hint>:1:19: parse error on input ‘=’
03:20:37 <jle`> > let x ::: y = x*y in 2 ::: 5
03:20:39 <lambdabot>  Not in scope: data constructor ‘:::’Not in scope: data constructor ‘:::’
03:20:42 <jle`> oh yeah
03:20:51 <jle`> a user defined data constructor. don't mind me
03:21:13 <ion> @let data x ::: y = x ::: y deriving Show
03:21:14 <lambdabot>  Defined.
03:21:17 <ion> > 4 ::: 5
03:21:19 <lambdabot>  4 ::: 5
03:21:38 <ion> @undefine
03:21:39 <lambdabot> Undefined.
03:21:44 <Bashmetim> How is that different than (,) ?
03:21:50 <jle`> mhm.  not syntax, just a normal, definable thing
03:21:53 <deezn> Still lost?
03:21:57 <Bashmetim> > (,) 4 5
03:21:59 <lambdabot>  (4,5)
03:22:13 <deezn> here is the dec: data List a = Nil | a ::: List a
03:22:33 <ion> Bashmetim: It’s not.
03:22:33 <jle`> that's equivalent to data List a = Nil | (:::) a (List a)
03:22:40 <jle`> and you can pick any name for your constructor
03:22:43 <jle`> they just picked (:::)
03:22:52 <jle`> you could pick (:*~:**~**^^^)
03:23:05 <jle`> data List a = Nil | a :*&~*&$&*&# List a
03:23:12 <deezn> hmm ok.. off to look at the code.
03:23:21 <ion> No, lens already took (:*~:**~**^^^)
03:23:22 <jle`> data List a = Nil | Cons a (List a)
03:23:26 <jle`> :P
03:23:33 <jle`> deezn: do you know about ADT syntax?
03:23:41 <jle`> do you understand data List a  = Nil | Cons a (List a) ?
03:23:52 <jle`> this is the same thing, except instead of naming it Cons, they name it (:::)
03:23:53 <deezn> data Color = Blue | Green | Red 
03:23:55 <deezn> like that?
03:23:57 <Bashmetim> ADT is a pesticied...
03:23:57 <jle`> yeah
03:24:19 <jle`> deezn: so you could also have, data Color = Blue | Greed | Red | (:%&*&*##*&*$&*!$*$)
03:24:22 <ion> @let data Color = Blue | Green | Red | (:::) deriving (Show)
03:24:22 <lambdabot>  .L.hs:145:14: parse error on input ‘:::’
03:24:23 <jle`> they're all valid names
03:24:33 <ion> Huh. Works in my ghci.
03:24:35 <deezn> ok.. 
03:24:36 <jle`> yeah, me too
03:25:09 <jle`> deezn: Blue is a valid name for a data constructor... so is Green, Red, Nothing, Just, Left, Right, and...(:::)
03:25:16 <jle`> they're all the same.  one just happens to not use letters
03:25:22 <deezn> ok so iok..
03:26:21 <deezn> so.. we have a custom type list.. that can have a value of nil or a list of type a.. 
03:26:33 <pavonia> Why isn't lambdabot accepting (:::)?
03:26:51 <jle`> it can have a value of Nil, or it can have "a value of type `a`, and a "rest of the list" of type `List a`"
03:27:04 <jle`> pavonia: i think lambdabot does some pre-processing
03:27:09 <jle`> i've had something like this come up before in the past
03:27:24 <deezn> ok.. making more sense now.
03:27:30 <deezn> brb.. looking at code.
03:27:33 <pavonia> jle`: What kind of pre-processing?
03:27:35 <jomg> pavonia, maybe it thinks it's an operator that needs 2 arguments
03:27:53 <jle`> @let data Foo = (:::)
03:27:53 <lambdabot>  .L.hs:142:12: parse error on input ‘:::’
03:27:53 <jomg> that's what i always thought, anyway
03:28:02 <jle`> it works on ghci and ghc in general
03:28:04 <pavonia> jomg: It shouldn't if there are parentheses, I think
03:28:04 <jle`> without any extensions
03:28:11 <ion> @let data Foo = (:::) ()
03:28:11 <lambdabot>  .L.hs:142:12: parse error on input ‘:::’
03:28:15 <ion> @let data Foo = (:::) () ()
03:28:15 <lambdabot>  .L.hs:142:12: parse error on input ‘:::’
03:28:22 <jle`> i think lambdabot is doing some pre-processing for safety purposes
03:28:29 <jle`> this has happened to me before
03:28:32 <ronh-> Deewiant Nil is a list of type a as well
03:28:52 <jomg> @let data Foo a b = a ::: b
03:28:53 <lambdabot>  Defined.
03:28:59 <jomg> ah, yea that works...
03:29:41 <saulzar> I think I use about 0.2% of Lens, so useful but I barely scratch the surface... 
03:30:04 <ion> saulzar: Nothing wrong with that.
03:30:45 <deezn> ok jle` I get the ADTs.. like colour but I find that decloration to be confusing I dont get what is going on where.
03:31:05 <jle`> deezn: are you using a course to learn?
03:31:10 <jle`> deezn: do you know about Maybe?
03:31:23 <deezn> I read about that in LYH
03:31:25 <jle`> data Maybe a = Nothing | Just a
03:31:31 <jle`> a list is a lot like this
03:31:39 <jle`> except instead of `Just a`, just having an a
03:31:44 <jle`> it has an a...and *also* the next thing
03:31:51 <jle`> data List a = Nil | Cons (a, List a)
03:32:01 <deezn> Cons (a, List a)?
03:32:03 <jle`> so Cons doesn't just have an `a`, it also as a `List a`...a "rest of the list"
03:32:13 <jle`> do you understand the Maybe declaration?
03:32:26 <jle`> `Just a` means that the Just constructor "has an a"
03:32:35 <jle`> Cons (a, List a) means that the const contrctor "has an a, and a List a"
03:32:41 <deezn> `That a mayeb can be a Nothing or Just <some type parameter>
03:32:51 <jle`> not quie
03:32:55 <jle`> it's Nothing or Just (some value of that type)
03:33:03 <jle`> so a Maybe Int can be Nothing or Just 10
03:33:05 <benma> jle`: `Nil | Cons a (List a)` is a bit simpler than having the tuple in there
03:33:21 <jle`> yeah, but i think the tuple highlights the analogy better
03:33:32 <jle`> deezn: a Maybe Bool can be Nothing...or Just True...or Just False
03:33:43 <saulzar> ion, Yeah, though it's tempting to get into the trap of "I wonder if I can do that with Lens?" and spend half an hour trawling..
03:33:48 <deezn> ok.. 
03:33:52 <jle`> `Just a` means that the value is Just + a value of type `a`
03:33:57 <jle`> so what are some values of List Bool?
03:34:05 <jle`> it can be Nil...or it can be Cons (True, Nil)
03:34:13 <jle`> or it can be Cons (True, Cons (False, Nil))
03:34:19 <deezn> the whole goal being type safety to catch things at run time?
03:34:19 <jle`> or it can be Cons (False, Nil)
03:34:25 <deezn> *compile time
03:34:42 <jle`> that's one application of Maybe, yes
03:34:47 <jle`> but there are more :)
03:35:43 <deezn> ok.. brb one sec.. pondering code after this:  Cons (True, Cons (False, Nil))
03:36:20 <jle`> Cons for List Bool takes a (Bool, List Bool).  so the Bool is True, and the List Bool is Cons (False, Nil)
03:36:57 <deezn> ok now we are getting somewhere.
03:37:16 <jle`> in more traditional haskell speak we say something like data List a = Nil | a ::: List a
03:37:34 <deezn> So with this: data Format (fmt :: List *) where
03:37:40 <jle`> so a member of List Bool might be... Nil.  Or it might be `True ::: Nil` (because True is a Bool, and Nil is a List Bool)
03:37:42 <deezn> What is the * for?
03:38:06 <jle`> or it might be True ::: (False ::: Nil).  or False ::: Nil.  Or False ::: (True ::: Nil), ec.
03:38:18 <jle`> deezn: it's a "kind" signature, but if you're starting out, it's not too much to worry about
03:38:28 <deezn> haha it is in my lab!
03:38:32 <jle`> heh
03:38:39 <jle`> a "kind" is like a 'type of types'
03:38:39 <deezn> arrrrghhh! 
03:38:48 <jle`> something of kind * is a type that you can have values of
03:39:00 <deezn> eg?
03:39:03 <jle`> for example, Int is a *.  because you can have values of it... 3, 19, -4, etc.
03:39:10 <jle`> Bool is a *.  because you have True, False, ec.
03:39:17 <jle`> `Maybe` is not *.
03:39:22 <deezn> ok.. 
03:39:26 <jle`> you can't have anything of type `Maybe`.  what does that even mean?
03:39:41 <merijn> Maybe is "* -> *" because it takes a type of kind * as argument and returns a new type of kind *
03:39:44 <jle`> `Maybe Int` is a *, though.  because you can have things of type `Maybe Int`.  Like Nothing, or Just 10, or Just 15
03:39:44 <merijn> :k Maybe
03:39:44 <deezn> Ok so.. 
03:39:45 <lambdabot> * -> *
03:39:48 <merijn> :k Maybe Int
03:39:48 <lambdabot> *
03:39:50 <merijn> :k Int
03:39:51 <lambdabot> *
03:40:20 <deezn> data Format (fmt :: List *) where list can be Nil or a ::: List a
03:40:29 <jle`> hm
03:40:33 <jle`> wait, is this really your lab?
03:40:46 <deezn> GADTs.. mind fucking the whole class.
03:40:47 <jle`> it looks like it's using DataKinds for type promotion....
03:40:50 <jle`> oh i see
03:40:52 <merijn> deezn: This stuff is using DataKinds too, this is rather advanced for a beginner haskell programmer
03:41:08 <deezn> This is the 6th lab.. 
03:41:18 <jle`> deezn: okay, so here, Format takes a type, called `fmt`
03:41:21 <deezn> But a few people I spoke to are lost as well. 
03:41:31 <jle`> this is pretty advanced haskell stuff, so i wouldn't be surprised
03:41:45 <jle`> at least in 2015
03:41:47 <merijn> deezn: How much haskell have you had so far?
03:42:07 <merijn> 6 labs?
03:42:15 <deezn> yeah
03:42:23 <merijn> deezn: Hah, I would've been surprised if you *weren't* lost if they were doing this the 6th lab of haskell
03:42:37 <Bashmetim> This is a totally dumb question, but does this function have a name: \x xs -> head xs : x : tail xs
03:42:46 <deezn> lol,, well that makes me feel a little better. 
03:43:02 <jle`> deezn: so here, it's saying that your data type is `Format fmt`, where `fmt` is a type.  And this kind signature is saying that `fmt` must have a "kind" `List *`.  not that anyone is really expected to know what that means
03:43:24 <deezn> yeah ok i have that from what you have explained.. 
03:43:38 <jle`> now, what *types* are of kind "List *" ...?
03:43:48 <jle`> you look at the definition of List
03:43:55 <jle`> the Nil *type* is of kind List *
03:44:05 <jle`> so fmt can be Nil
03:44:07 <deezn> yeah i get that bit.. 
03:44:24 <deezn> or it can be a ::: List a 
03:44:30 <jle`> the "a ::: Nil" *type* can be fmt
03:44:42 <jle`> careful, you're mixing together kinds and types here
03:44:52 <jle`> in this context, List * is a kind, and Nil is a type
03:45:08 <jle`> so `a ::: Nil` is a type that `fmt` can be.
03:45:18 <jle`> where a is of kind *.  so it can be Int, Bool, String, etc.
03:45:21 <deezn> :(
03:45:35 <jle`> so fmt can be the Nil type, it can be the (Int ::: Nil) type
03:45:41 <jle`> or it can be the (Bool :: Nil) type
03:45:48 <jle`> or the (String ::: Nil) type, for example
03:45:58 <jle`> or it can be (String ::: (Int ::: Nil))
03:46:14 <jle`> or it can be (Bool ::: (String ::: (Double ::: (Int ::: Nil))))
03:46:22 <jle`> those are all the *types* that 'fmt' can be
03:46:57 <ij> Bashmetim, Doubt it.
03:47:00 <jle`> so you might have something of type `Format (String ::: Nil)`.  or something of type `Format (Bool ::: (String ::: Nil))`.  or even `Format Nil`
03:47:04 <deezn> i get whta you are saying .. but jesus the kind type thing is confusing. 
03:47:27 <jle`> heh yeah.  this is something i wouldn't try teaching someone until they're doing haskell for like at least half a year or something
03:47:52 <jle`> it's also a relatively new development in haskell history, as well
03:47:59 <deezn> haha 8 weeks baby
03:48:10 <deezn> baptism of fire
03:48:16 <jle`> on one hand i'm impressed that a course is so up to date with the latest haskell trends
03:48:21 <jle`> on the other i'm terrified
03:49:00 <deezn> yeah they are using haskell to type check and make some c imbedded program.. well something like that the guest lecturer was showing us. 
03:49:05 <jle`> so yeah.  that's what it means when you see something like data Format (fmt :: List *).  it means that you can't just have Format (anything).  you can't have a Format Bool, or a Format Maybe, or a Format Int
03:49:35 <jle`> what the 'kind signature' does is it says that `fmt` has to be List *, so it can be Nil, Bool ::: Nil, String ::: (Int ::: Nil), etc.
03:49:48 <jle`> so Format (String ::: (Bool ::: Nil)) is a valid type, etc.
03:50:12 <deezn> I need to get this terminology down pat.  So Data List a  is a type constructor that have a parameterised type a that is defined when it is constructed. 
03:50:27 <jle`> i think there might come a day when this stuff is very natural and embedded into the culture enough that teachign haskell will naturally let this be taught earlier and it's a 'normal' thing
03:50:39 <jle`> but in 2015...and probably any time in the next few years, i doubt that'll be the case
03:51:26 <jle`> deezn: yeah, typically, `data List a` is defining a bunch of types.  List Int, List Bool, List String
03:51:43 <jle`> and values of List Int would be (3 ::: Nil), or (3 ::: (10 ::: Nil))
03:51:46 <deezn> List can have the value of Nil | the values of a (defined at construction) and a List a.
03:51:50 <jle`> yeah
03:52:07 <jle`> but here, we're using something called DataKinds
03:52:17 <deezn> Enter the matrix. Feeeew… mind bender.
03:52:18 <jle`> which means that you also have something else made completely independently and 'unrelatedly'
03:52:45 <jle`> you now also define a new kind, `List *`
03:52:51 <merijn> deezn: I can link you my simpler/more concrete example of using heterogeneous lists using this approach
03:53:01 <jle`> (you actually define a new kind List k for any kind k)
03:53:18 <merijn> deezn: You might wanna ignore the "type family" part of it: https://gist.github.com/merijn/dc00bc7cebd6df012c5e
03:53:35 <jle`> and so *types* that are of kind `List *` are types such as (Int ::: Nil),  (Int ::: (Bool ::: Nil)), etc.
03:54:08 <merijn> deezn: Try loading that in ghci and doing ":t Cons True (Cons 'c' (Cons [] Nil))" and see what comes out
03:54:17 <deezn> ok.. 
03:54:39 <jle`> anyways, i'm off to bed. night all :)
03:54:43 <deezn> jle’ can you check out.. http://lpaste.net/4773490252650119168 and I will brb after I do what merijn is telling me to do
03:54:58 <deezn> oh shit.. oh ok.. thanks for your time.. you helped a lot. 
03:55:23 <deezn> Not in scope: data constructor ‘Cons’
03:55:37 <merijn> deezn: Did you load the module I linked?
03:55:44 <deezn> ops just saw that
03:56:21 <merijn> Lines 8-10 and 22-24 are neat, but you can ignore them for now as they don't really apply to the code you're dealing with
03:57:02 <merijn> deezn: Some fun things to note: See how "head" works right, despite the list being heterogeneous
03:57:11 <merijn> And how "head Nil" is a type error :)
03:58:20 <merijn> deezn: Where your original question involved the "List *" type, I'm using DataKinds to lift the normal haskell list syntax to the type level, but other than these are doing similar things
03:58:47 <deezn> i am confused.
03:58:57 <deezn> going to look at the code
03:59:01 <deezn> brb
03:59:05 <Zenol_> Hi, I need a little help. I have two functions; reduce and deltaChain. If I evaluate deltaChain of a chain complex in ghci; and then apply reduce, everything zorks. but if I call delta = reduce . ddeltaChain, then I get a stack overflow.
03:59:25 <Zenol_> I think it's because I use lots of fold, ++ and : operators, and everything is lazy.
03:59:42 <Zenol_> But I'm not sure about where I should force the strictness :s
03:59:51 <ion> Zenol: Please pastebin your code.
04:01:05 <Zenol_> ion  Its here : http://pastebin.com/huABh0fs
04:02:11 <pavonia> "delta = reduce . delta" -- Is that intended?
04:04:06 <merijn> hah
04:04:09 <merijn> pavonia: Nice catch
04:04:53 <ion> You might benefit from using foldlWithKey' instead of foldlWithKey, btw.
04:05:22 <deezn> type family ? I have looked in LYH but I cant find anything
04:05:38 <ion> LYAH wouldn’t have anything that advanced.
04:05:43 <deezn> shiiet. 
04:06:06 <ion> https://wiki.haskell.org/GHC/Type_families
04:06:26 <ion> They can be thought of definitions of type-level functions.
04:07:25 <deezn> .. simple example?
04:07:59 <merijn> deezn: Like I said, you can ignore the type family bit in my code :)
04:08:18 <merijn> just pretend the type family and "apply" function don't exist and focus on the HList type and head/tail
04:08:25 <Zenol_> Good ideq ion. Are they something I can do so that (.+) act strictly, cause I call it a lots (or is it actualy the case because of typing? It's been more than one year I wrote haskell so....)
04:09:11 * hackagebot smaoin 0.1.1.2 - Utilities for the Smaoin semantic information model.  http://hackage.haskell.org/package/smaoin-0.1.1.2 (akrasner)
04:10:00 <merijn> deezn: So HList is a type constructor that takes a "list of types" and returns a type (this is shown by "HList :: [*] -> *")
04:10:08 <ion> Zenol: Anywhere you have a foldl, use the ' variant.
04:10:14 <deezn> http://lpaste.net/6938182773748269056
04:10:31 <deezn> merijn can you have a look at that so I can ask some q's
04:10:33 <merijn> deezn: And HList has two constructors "Nil :: HList '[]" which has an empty list of types corresponding to it's empty list at the value level
04:10:34 <deezn> please
04:10:45 <ion> Zenol: I suppose you could try making the parameters of (.+) strict.
04:11:04 <deezn> ignore the comments.. that is just me making notes.
04:11:05 <merijn> deezn: Sure
04:11:20 <merijn> hah
04:11:29 <merijn> That type family is nearly identical to my example :p
04:11:56 <deezn> ok thanks to you guys here believe I get the data type List.. 
04:11:59 <merijn> Except it's using printf as example, instead of apply
04:12:11 <deezn> But now onto format.. 
04:13:45 <merijn> deezn: Actually, I think it might be easier to explain my code sample and then see if you can figure out how it corresponds to your code example, because I think mine is slightly simpler to understand
04:13:46 <deezn> How does the where work in this instance
04:14:08 <Zenol_> ion: Is there a foldl' variant for list? (Anyway I saw where was the problem, mistaping of function name xD)
04:14:17 <merijn> deezn: Which one?
04:14:25 <Athas> Are the shifts in Data.Bit arithmetic (sign-extending) shifts?
04:14:28 <deezn> data Format (fmt :: List *) where
04:14:28 <ion> Zenol: It’s in Data.List
04:14:40 <merijn> deezn: Actually, you might wanna read this
04:14:44 <Athas> I mean, I can test it (they are not for Int32), but is this documented or promised?
04:14:47 <merijn> deezn: https://en.wikibooks.org/wiki/Haskell/GADT
04:14:57 <Athas> Oh, wait, it is documented, never mind.
04:15:11 <deezn> We went through that in a lecture.. but I am stuffed.. I will go through it again. 
04:15:14 <deezn> brb
04:15:14 <tdammers> Athas: :D
04:15:32 <Zenol_> Ok, thanks /D
04:15:39 <tdammers> in a nutshell, shiftR does the "right thing"
04:15:40 <merijn> deezn: Especially look at the different ways to write the same thing in the summary
04:16:12 <deezn> ok.. 
04:16:36 <Athas> Er, or maybe it is broken for large literals.
04:16:56 <Athas> No, I guess it does do the right thing.
04:17:17 <tdammers> yes
04:17:28 <tdammers> keep in mind that shift is a typeclass method
04:17:40 <tdammers> so it does different things for different types
04:17:58 <tdammers> (particularly, signed vs. unsigned types)
04:21:21 <deezn> merijn.. why do we need the :: Expr on the end of: (I 5 `Add` I 1) `Mul` I 7 :: Expr ?
04:21:49 <merijn> deezn: There's not need for it, it's just for clarity
04:22:23 <deezn> oh ok.
04:23:43 <deezn> eval :: Expr -> Either Int Bool
04:23:44 <deezn> The first two cases are straightforward
04:23:45 <deezn> eval (I n) = Left n
04:23:45 <deezn> eval (B b) = Right b
04:23:48 <ronh-> func (Just x) = ...\nfunc Nothing = ... where whereVar <- is it not possible to have whereVar that is accessible from both first and second definition?
04:23:53 <deezn> (sorry about the mutiple lines). 
04:24:37 <deezn> merijn i read about this either thing.. but i have forgotten.. do I just look under “either” in LYAH
04:25:51 <merijn> deezn: "data Either a b = Left a | Right b"
04:26:11 <ion> ronh: func z = case z of { Just x -> …; Nothing -> … } where { … }
04:40:35 <deezn> merijn you there?
04:40:59 <fr33domlover> why does uploading a package with 'cabal upload' reset its tags?
04:41:12 <fr33domlover> i have to manually re-add tags after every release :/
04:41:22 <merijn> deezn: Yeah
04:41:29 <bennofs> fr33domlover: what do you mean with tags?
04:41:31 <fr33domlover> (unless I can make the cc0 tag be added automatically somehow)
04:41:40 <fr33domlover> bennofs, the package tags in hackage
04:41:46 <deezn> Can yoy explain this with an example: data Expr a where
04:41:47 <deezn>     I   :: Int  -> Expr Int
04:42:02 <deezn> please..
04:42:19 <bennofs> fr33domlover: you mean Category?
04:42:20 <merijn> deezn: ok, so, first off, you understand "data Expr a = I a", yes?
04:42:48 <fr33domlover> bennofs, no, hackage has both categories and tags
04:43:01 <fr33domlover> e.g. there's a 'library' tag which all libraries have
04:43:05 <deezn> data Expr a = <shouldnt there be sometging here> I a 
04:43:07 <fr33domlover> and per-license tags
04:43:38 <merijn> deezn: There could be other things, I'm just simplifying to a single I constructor
04:43:57 <bennofs> fr33domlover: oh, never used that
04:44:04 <deezn> ok I dont get the space then the | shouldnt it just be = a?
04:44:12 * hackagebot ide-backend 0.9.0.8 - An IDE backend library  http://hackage.haskell.org/package/ide-backend-0.9.0.8 (MichaelSnoyman)
04:44:19 <merijn> deezn: What |?
04:44:32 <merijn> deezn: Your IRC font sucks :)
04:44:46 <deezn> deezn: ok, so, first off, you understand "data Expr a = I <— HERE a”, 
04:44:47 <merijn> deezn: It's not distinguishing capital I and |, judging from your question
04:44:58 <merijn> deezn: That's a capital I
04:44:59 <deezn> oh shit.. bad bad font
04:45:30 <merijn> I was trying to stick to your own "data Expr a where I :: Int -> Expr Int" format ;)
04:45:53 <merijn> deezn: Anyway, so "Expr a" is a type with a single constructor I. What is the type of I there?
04:46:45 <ronh-> is this called existential type? data GenericSite = forall a . GenericSite (Site a)
04:46:50 <deezn> ok so it is a type constructor that takes a parameterised type a and then data constructs L to have value a?
04:47:06 <deezn> L :: a
04:47:46 <merijn> deezn: That's not the right type, though
04:47:46 <dito> Hi people! Could you please help me? I'm trying to install hsexif lib for reading exif data from pictures and I have problems with libiconv dependency. I've successfully installed libiconv version which I need by manually pointing cabal to the lib files which I have downloaded from the internet but now when building from sublimetext3 on windows I get:
04:47:55 <dito> photo_test.hs: C:\Users\xxx\AppData\Roaming\cabal\iconv-0.4.1.2\ghc-7.6.3\HSiconv-0.4.1.2.o: unknown symbol `__imp__libiconv_open'
04:48:04 <merijn> deezn: You might notice that my datatype is very similar to the Just constructor for Maybe and what type does that have?
04:48:07 <merijn> :t Just
04:48:08 <lambdabot> a -> Maybe a
04:48:37 <deezn> Where does it state it is a Maybe?
04:48:43 <merijn> deezn: So in "data Expr a = I a" I has type "a -> Expr a", because it takes an 'a' as argument and return a 'Expr a'
04:48:52 <bartavelle> dito, you need to put your iconv library in a system-wide library location, or hint to every compiler / programs where it is
04:49:19 <merijn> deezn: I was just pointing out that "data Expr a = I a" is similar to the first part of "data Maybe a = Just a" ignoring the "| Nothing" part
04:49:33 <deezn> ok.. 
04:49:40 <merijn> deezn: And that I's type, like Just's type would be "a -> I a" vs "a -> Maybe a"
04:49:41 <ronh-> there are no classes involved, btw, Site is an ADT
04:49:53 <deezn> but if I can ask about this specifically.. : 
04:49:55 <merijn> deezn: But what we wanted to encode is that "I" always takes an Int
04:50:10 <deezn> here at the GADT section : https://en.wikibooks.org/wiki/Haskell/GADT
04:50:27 <merijn> So we could write "data Expr a = I Int", but then I could write "I 5 :: Expr Bool" and it would still typecheck
04:50:30 <dito> @bartavelle so I need to put the libiconv lib folder to path? or do i edit something in haskell platform?
04:50:30 <lambdabot> Unknown command, try @list
04:50:47 <deezn> IT has a in the type decloration .. but then no a where the constructors are?
04:50:52 <merijn> deezn: So what we really want to do with GADTs is say that "I" can *only* construct values of type "Expr Int"
04:50:58 <bartavelle> dito: I don't think there is anything you can do on the haskell platform. It just works like any other part of Windows.
04:51:17 <bartavelle> dito, perhaps you can force some extra library directory in the cabal configuration though
04:51:23 <merijn> deezn: Yes, that's called a "phantom type" since it has no "physical" body at the value level
04:51:27 <bartavelle> but when you'll have to run your binary, it will also have to find the library
04:52:07 <dito> @bartavelle ive been reading http://stackoverflow.com/questions/8972662/linking-c-dll-with-haskell-platform-on-windows-outputs-undefined-reference but i cant find the .cabal file
04:52:07 <lambdabot> Unknown command, try @list
04:52:37 <deezn> So… how is it used?
04:53:13 <dito> @bartavelle do you know where it is?
04:53:13 <lambdabot> Unknown command, try @list
04:53:20 <bartavelle> dito, I have exactly 0 experience with Windows. The cabal file they are talking about is the iconv cabal file, how did you install it ?
04:54:21 <merijn> deezn: I should've avoided the phantom type, I assumed you knew them, but now they're just confusing
04:54:48 <merijn> deezn: Let's focus on the important bit: We want to tell GHC that the "I" constructor can only produce "Expr Int" values, somehow
04:54:57 <deezn> I read about them.. but what I need is a concrete example that related to this GADT code at what happens set by step.. 
04:55:10 <dito> ive installed libicon with the exe from their website to program files/gnu and then pointed to the in cabal install --include-external-dir or sth
04:55:13 <deezn> ok..
04:56:11 <bartavelle> dito, yeah that has the same effect. I believe you now need all programs depending on libiconv to build using --include-blah-blah
04:57:06 <bartavelle> dito, it's not specific to Haskell, the linker has to find the libraries
04:57:11 <merijn> deezn: So the problem we have is that with "data Expr a = I a" (which you can also write as "data Expr a where I :: a -> Expr a") we can't do this
04:57:17 <dito> which linker?
04:57:22 <deezn> with a normal ADT could go.. let myColour = Red 5 (data Color = Blue Int | Red Int | Green Int) now with this GADT I cannot do that anymore.. ?
04:57:22 <bartavelle> any linker :)
04:57:28 <dito> the mingw one installed in haskell platform?
04:57:35 <bartavelle> a
04:57:56 <merijn> deezn: GADTs allow use to tell GHC that "data Expr a where I :: Int -> Expr Int" which means that the I constructor must *always* return an "Expr Int"
04:57:58 <bartavelle> any linker that will need to link against your library. This include the dynamic linker that will resolve your PE imports
04:58:10 <bartavelle> when you run a binary
04:58:21 <deezn> ok I get that but the syntax is really confusing
04:59:20 <merijn> deezn: Why is that?
04:59:29 <bartavelle> deezn, it's just like the typeclass declaration syntax, except you describe your constructors instead of the type class functions
04:59:41 <merijn> deezn: It is saying that the I constructor takes an Int and returns an "Expr Int"
05:00:32 <dito> thanks a lot baravelle. i suppose i only need to rebuild manually the cabal package to include external libs
05:00:46 <aleator_> I'm getting "Unrecognized field constraints on line" when I try to use stackage. I think I followed the three line instructions to the letter. Does anyone know why this happens?
05:00:52 <bartavelle> dito, you will also need to have the library in path when you run any program using it
05:01:23 <bartavelle> aleator_, what's on the line ?
05:01:50 <deezn> One sec.. just submitting some work .. brb in 1 min.
05:02:13 <aleator_> Well, thats the stackage (cabal) config file line that reads "constaints: " followed by the stackage version list.
05:02:14 <bartavelle> aleator_, it's line 5 of cabal.config ?
05:02:21 <aleator_> Yeah.
05:02:36 <aleator_> https://www.stackage.org/lts/cabal.config <- that one
05:02:38 <bartavelle> aleator_, strange, perhaps you have a really old cabal version that doesn't recognize this ?
05:02:58 <bartavelle> (no clue about this really)
05:03:20 <aleator_> I just updated the to the latest cabal on hackage so It shouldn't be that old..
05:03:47 <bartavelle> aleator_, you wrote it in cabal.config ? (was reading https://mail.haskell.org/pipermail/haskell-cafe/2014-December/117445.html )
05:04:19 <aleator_> bartavelle: Yeah, I wgetted it next to my project .cabal -file like the instructions said.
05:04:54 <aleator_> I did try the global constaints as well (in the thread) but that just gave the same error few hundred times..
05:07:58 <phaazon> hey, is there a function that gives a binary representation of a number?
05:08:04 <ronh-> @pl \f fun x y z -> map f <$> fun x y z
05:08:04 <lambdabot> (.) . (.) . (.) . (<$>) . map
05:08:12 <phaazon> like (Num a) => a -> String
05:08:14 <phaazon> or that kind of stuff
05:08:17 <phaazon> ByteString, maybe
05:08:20 <bartavelle> phaazon, I rewrite it all the time :(
05:09:01 <phaazon> :t Data.Binary.encode (3 :: Int)
05:09:02 <lambdabot> BSLC.ByteString
05:09:43 <deezn> argh: Not in scope: data constructor ‘FormatArgsThen
05:11:17 <bartavelle> phaazon, reverse . unfoldr (\x -> if x == 0 then Nothing else Just (odd x, x `div` 2))
05:11:45 <phaazon> I guess I’ll go with encode and folds over ByteString :)
05:12:01 <bartavelle> you know there is Data.Bit right ?
05:12:06 <bartavelle> what is this that you want to do ?
05:12:53 <bartavelle> phaazon, Data.Binary.encode will write is as a 8 bytes bytestring (if your Int is 64 bit), not 64 bytes with 0 and 1
05:13:16 <serses> how do i raise a floating number to a power?
05:13:36 <ion> serses: (^) for positive integral power, (^^) for integral power, (**) for floating power.
05:14:08 <benma> ion: hmm was that really necessary? couldn't one of them be overloaded to serve all?
05:14:32 <serses> is there a limit on power?
05:15:38 <ion> benma: (^) can work on more types than (^^) which can work on more types than (**).
05:15:41 <benma> serses: precision limit is the Floating type that you are using
05:16:22 <benma> ion: why does it say Integral for (^) if it also works for floats? why do (^^) and (**) exist if (^) covers all?
05:16:31 <merijn> benma: It doesn't
05:16:38 <merijn> benma: The types of the exponents differ
05:16:41 <merijn> :t (^)
05:16:42 <lambdabot> (Integral b, Num a) => a -> b -> a
05:16:43 <phaazon> oh, I have an easier way bartavelle 
05:16:46 <merijn> :t (^^)
05:16:47 <lambdabot> (Fractional a, Integral b) => a -> b -> a
05:16:50 <merijn> :t (**)
05:16:51 <lambdabot> Floating a => a -> a -> a
05:17:01 <phaazon> > printf "%b" (7 :: Int)
05:17:02 <lambdabot>      No instance for (Show a0)
05:17:02 <lambdabot>        arising from a use of ‘show_M608037164083617176721367’
05:17:02 <lambdabot>      The type variable ‘a0’ is ambiguous
05:17:10 <benma> merijn: right. so then i have to ask again: couldn't one of them be overloaded o serve all?
05:17:13 <bartavelle> phaazon, yuck :)
05:17:14 <phaazon> well, that works.
05:17:29 <bartavelle> you but you got a dependency on printf
05:17:29 <ion> > binary # 12345
05:17:30 <merijn> benma: Sure, but it'd be less efficient
05:17:31 <lambdabot>  "11000000111001"
05:17:45 <phaazon> @index binary
05:17:46 <lambdabot> bzzt
05:17:51 <phaazon> :t binary
05:17:52 <lambdabot> (Integral a, Applicative f, Choice p) => p a (f a) -> p String (f String)
05:17:55 <benma> merijn: why? should still be different implementations based on the type, just the same operator
05:17:59 <merijn> benma: Due to requiring an integral exponent it can use a repeated squaring algorithm which is faster than the "real" implementation
05:18:00 <phaazon> where is that defined?
05:18:01 <bartavelle> oh, it's in lens :)
05:18:05 <benma> this is what i meant with overloading. typeclass style
05:18:10 <ion> phaazon: lens, Numeric.Lens
05:18:12 <merijn> benma: You can't change implementations based on types like that
05:18:15 <phaazon> arf
05:18:17 <phaazon> dammit
05:18:22 <bartavelle> phaazon, you mostly just need a single dependency
05:18:24 <phaazon> I won’t have that on the compo machine
05:18:30 <phaazon> it’s not up to me, bartavelle 
05:18:39 <phaazon> and haha
05:18:40 <benma> merijn: you can't? what about a typeclass?
05:18:45 <bartavelle> hehe
05:18:48 <phaazon> lens is not a “single dependency”
05:18:53 <deezn> merijn any idea why this wont compile?
05:18:53 <deezn> http://lpaste.net/5658593372093284352
05:18:55 <phaazon> it’s a fucking huge dependency
05:19:02 <bartavelle> nah, it's "batteries included"
05:19:04 <bartavelle> :p
05:19:09 <phaazon> I’m gonna take the implementation though
05:19:32 <merijn> benma: Sure, but I mean that "(Num a, Num b) => a -> b -> a" can't inspect the type of 'b' to pick a different implementation from that
05:19:53 <ion> > showIntAtBase 2 intToDigit 12345 ""
05:19:54 <lambdabot>  "11000000111001"
05:20:17 <bartavelle> > (reverse . unfoldr (\x -> if x == 0 then Nothing else Just (odd x, x `div` 2))) 12345
05:20:18 <lambdabot>  [True,True,False,False,False,False,False,False,True,True,True,False,False,True]
05:20:35 <bartavelle> > (reverse . unfoldr (\x -> if x == 0 then Nothing else Just (if odd x then '1' else '0', x `div` 2))) 12345
05:20:37 <lambdabot>  "11000000111001"
05:21:49 <phaazon> thanks bartavelle 
05:22:02 <deezn> merijn any idea why this wont compile?
05:22:08 <deezn> http://lpaste.net/5658593372093284352
05:22:40 <bartavelle> phaazon, what ion pasted might be nicer, as it's already in base and will work for any ... base
05:23:01 <ion> It won’t, though.
05:23:05 <ion> > showIntAtBase 17 intToDigit 12345 ""
05:23:06 <lambdabot>  "28c3"
05:23:14 <ion> well
05:23:18 <bartavelle> he
05:23:21 <coin3d> hi there. i'm right at the beginning of the learn-you-a-haskell book, and noticed, that it seems that i cant define functions in the ghci prompt. I always get a parse error on the equal sign - why is that so?
05:23:23 <ion> > showIntAtBase 17 intToDigit 16 ""
05:23:24 <lambdabot>  "*Exception: Char.intToDigit: not a digit 16
05:23:51 <arw> coin3d: either define them in a file and :load <file.hs>
05:24:08 <arw> coin3d: or define them with :let fn s = 2 * s 
05:24:19 <coin3d> ahh, thanks arw 
05:24:55 <ion> let, not :let
05:24:56 <arw> coin3d: I find it very helpful to just use a file (:edit is also useful to switch to your favourite $EDITOR) and save regularly
05:25:25 <arw> coin3d: because that way nothing gets lost and its easy to test longer more complicated programs
05:25:27 <merijn> deezn: FormatArgsThen is a type family, i.e. a type level function, but you're using it as a value on line 23
05:25:56 <arw> ion: right, sorry
05:26:41 <deezn> what do I do then?
05:27:26 <deezn> So lost.. 
05:27:46 <ion> I had to write my own intToDigit for lens because the one in base has an arbitrary maximum base: https://github.com/ekmett/lens/blob/master/src/Numeric/Lens.hs#L70
05:28:15 <merijn> deezn: I would recommend asking your instructor for some help, because I'm too busy with work to walk you through this
05:28:54 <deezn> all good thxs.
05:31:18 <ion> deezn: Start with a case match on fmt. FormatArgsThen on line 22 is fine because it is a thing in the namespace of types, but not on line 23 because there’s no such thing in the namespace of values.
05:36:59 <deezn> ion?
05:37:24 <deezn> I am confused
05:37:59 <deezn> you mean for I L S etc
05:38:25 <ion> Yeah
05:38:39 <ion> printf' X st = _
05:38:42 <ion> printf' L st = _
05:38:44 <ion> etc.
05:40:50 <deezn> sers/nathansturgess/Code/Uni/COMP3141/Lab6/Ex06.hs:26:35:
05:40:50 <deezn>     Not in scope: ‘fmt’
05:41:01 <ocramz> hi there
05:41:34 <deezn> ion.. I think I will just delete it and submit it.. jesus. I am lost and running out of time
05:42:59 <ion> deezn: Given the type “Format fmt -> String -> FormatArgsThen fmt String”, if fmt = Nil, what does the type expand to? You’ll just need to look at the definition of FormatArgsThen.
05:44:56 <deezn> printf' X st = FormatArgsThen Nil st
05:45:45 <ion> Let’s figure out the type first and move to the definition after that.
05:46:20 <ion> Given “Format fmt -> String -> FormatArgsThen fmt String” and the knowledge that fmt is Nil, what does the type “FormatArgsThen Nil String” evaluate to according to the definition of the type family?
05:47:37 <deezn> I appreciate the help but I am totally lost. I have spent the whole afternoon trying to understand this. I wont waste your time. 
05:48:17 <absence> http://lpaste.net/131547 <- is there a better or more clever way to factor out duplication?
05:49:59 <ocramz> I'm reading snoyberg's "Catching all exceptions" on FPComplete; where does the ($!!) operator do, in 'do {res <- action; evaluate $!! res}' ? 
05:50:19 <ocramz> *I mean, what does ($!!) do and where does it come from
05:51:28 <ion> deezn: Don’t feel disappointed, you’re being asked to understand an advanced topic very early. But you might still be able to figure this out. FormatArgsThen is a function, just for types. It takes two parameters which are types and returns a type. From line 16, “FormatArgsLen Nil ty = ty”. If you know that fmt = Nil, “Format fmt -> String -> FormatArgsThen fmt String” becomes “Format Nil ->
05:51:30 <ion> String -> String” because FormatArgsThen Nil String = String by definition.
05:51:59 <ion> @hoogle ($!!)
05:52:00 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
05:54:14 * hackagebot ghc-typelits-natnormalise 0.2.1 - GHC typechecker plugin for types of kind GHC.TypeLits.Nat  http://hackage.haskell.org/package/ghc-typelits-natnormalise-0.2.1 (ChristiaanBaaij)
05:54:34 <deezn> thanks ios.. tI am serious ****ed on this. I just need to sort this out before my exam.
05:54:44 <deezn> *ion
05:55:55 <deezn> No matter what I try I am just getting erros
05:56:36 <ion> Do you understand how the type “Format fmt -> String -> FormatArgsThen fmt String” evaluated at fmt = Nil becomes “Format Nil -> String -> String”?
05:56:49 <deezn> liek this:  printf' X st = FormatArgsThen Nil st
05:57:35 <rom1504> is there any way to enforce type classes laws in haskell or is it needed to use something like idris for that ?
05:58:36 <ion> deezn: printf' X st = _ expects a value on the right hand side of the =, but FormatArgsThen Nil x is a type. You can not use it there. We’re talking about the meaning of the :: line above it so far.
05:58:56 <bennofs> rom1504: as far as I know, that is not possible in haskell
06:00:04 <deezn> yeah it takes a Format.. and then returns a FormatArgsThen
06:00:23 <deezn> ion - sorry I forgot to type your name above
06:00:36 <ocramz> thanks ion :)
06:01:43 <ion> deezn: When you do a case match for X in “printf' X st = _”, you gain the knowledge that the type “fmt” = Nil from the type of X. The right hand side of the function definition needs to have the correct type, and that type is specified on the (::) line. Given that fmt = Nil at the “X” line, the type of the thing you need to return is “FormatArgsThen Nil String” which evaluates to “String”
06:01:45 <ion> as defined on line 16.
06:02:46 <deezn> ion but isnt st the string? printf' :: Format fmt -> String -> FormatArgsThen fmt String 
06:02:46 <deezn>     printf' X st = FormatArgsThen Nil st
06:04:11 <ion> deezn: st is the input String, but you need to output a FormatArgsThen Nil String on the right hand side of the =. Evaluating the *type* FormatArgsThen Nil String = String (as per line 16), therefore you’ll just need to output a String.
06:05:06 <ion> deezn: Let me make this more explicit: …but you need to output a value of type FormatArgsThen Nil String on the right hand side of the = … therefore you’ll just need to output a value of type String.
06:05:56 <deezn> printf' X st = FormatArgsThen Nil String
06:08:56 <ion> Let me give you the solution to this one, it may give you the insight to solve the other cases. “printf' X st = st”. The *type* of the right hand side value is FormatArgsThen Nil String, which is by definition String, but you need to return a *value* of that type. You could return "hello" or "bye" and it would typecheck, but in this case you’re supposed to just return the “st” you got as input.
06:10:07 <deezn> why though.. Iwhen the def’n is FormatArgsThen fmt String
06:12:32 <ion> 1. You pattern matched on X, and “X :: Format Nil” (line 10). The compiler gained the knowledge that fmt is Nil for that pattern match based on that.
06:12:57 <ion> 2. The type “Format fmt -> String -> FormatArgsThen fmt String” evaluated at fmt = Nil becomes “printf' :: Format Nil -> String -> FormatArgsThen Nil String”
06:13:18 <ion> 3. Line 16 specifies “FormatArgsThen Nil ty = ty”, therefore “FormatArgsThen Nil String = String”
06:13:58 <ion> 4. The final type becomes “Format Nil -> String -> String” when FormatArgsThen is evaluated.
06:14:23 <ion> So for the X case, all you need to do is write a function of that type.
06:14:50 <ion> “printf' X st = st” is such a function.
06:15:46 <RaceCondition_> is it generally considered an acceptable compromise that the use of fclabels on a given type disables the use of NamedFieldPuns with that type?
06:16:50 <Zenol_> Stupide question : is there a way to insert a value in a Data.Map only if this value isn't stored ? (I mean without using lookup and then calling insert)
06:17:15 <ion> Do you mean “if the map does not have a value for the key”?
06:18:14 <Zenol_> ion> Yes
06:18:52 <adas> i installed stackage-cli, but not able to do "stackage sandbox init". I get a command not found error. Do i have to install something else to make this work?
06:18:53 <ion> Zenol: insertWith (\_newValue oldValue -> oldValue) k v
06:19:58 <Zenol_> oh, ok, I seee. Thanks :)
06:21:54 <bennofs> Zenol_: you can also use alter
06:21:58 <bennofs> :t Data.Map.alter
06:21:59 <adas> I mean i have the stackage command on path.. i also have stk on path. i just get a "sandbox" not found error
06:22:00 <lambdabot> Ord k => (Maybe a -> Maybe a) -> k -> M.Map k a -> M.Map k a
06:23:02 <ion> alter (<|> Just v) k
06:27:44 <haskell974> hi all
06:27:52 <haskell974> a short question
06:28:10 <haskell974> how can I build an executable with cabal ?
06:28:40 <masse> cabal configure && cabal build
06:28:48 <haskell974> where can I find the executable then?
06:29:02 <MasseR> IIRC it creates a dist folder in the folder you are in
06:29:19 <haskell974> let me try ... 
06:29:36 <MasseR> You can also do 'cabal install', which does all the dependency building, configuring, building and installing in one command
06:30:01 <MasseR> Which will then install executable to $HOME/.cabal/bin (or if in sandbox $PWD/.cabal-sandbox/..something)
06:30:10 <haskell974> I get the following error:
06:30:18 <haskell974> Warning: output was redirected with -o, but no output will be generated because there is no Main module.because there is no Main module.
06:31:01 <MasseR> I'd say there is no main module :). Maybe it is an invalid cabal file?
06:32:42 <adas> can someone help?
06:33:11 <shirt> in Shake, how to i define a rule that creates a file only if the file doesn't exist?
06:33:32 <haskell974> This is how my cabal file looks like: https://gist.github.com/anonymous/487c5f1ebc8e9b8ac484
06:33:42 <haskell974> and There is a main module
06:34:10 <haskell974> my command is: cabal configure && cabal build mydumper
06:38:29 <adas> how may i access stackage commands? i have "stackage" and "stk" on path. but not able to do "stackage sandbox init". This is what I get .. "invalid command: sandbox"
06:38:55 <e_svedang> Hello, I’m getting these weird underlines in haskell emacs mode: http://imgur.com/6nRG9Qs Any idea how I can get rid of those? (and why they are there..?) I can’t remember seeing them before, they just kind of appeared :S
06:41:54 <adas> I do not understand why the other plugins like "stackage-sandbox" did not get isntalled when I did "cabal install stackage-cli"
06:42:39 <bennofs> e_svedang: they are probably the indentation points. they mark were tab / shift-tab will take you next
06:43:19 <e_svedang> Oh, I see. Thanks! How can I remove those?
06:44:11 <bennofs> adas: I think you need to install stackage-sandbox. That's the point of plugins: they are optional and do not need to be distributed with stackage-cli by default
06:44:19 <bennofs> @hackage stackage-sandbox
06:44:19 <lambdabot> http://hackage.haskell.org/package/stackage-sandbox
06:44:29 <e_svedang> or now that I know what they are, at least they’re not as annoying :)
06:45:00 <bennofs> e_svedang: sorry, I do not know that. Maybe there is some customization option in the haskell-mode customization under the point "indentation" or smth?
06:45:11 <adas> bennofs: oh thanks. so it can be installed in global cabal?
06:45:26 <e_svedang> bennofs: ok, I’ll see what I can find
06:46:11 <bennofs> adas: it needs to be in $PATH, I think that is all that matters. installing it globally will probably achieve that, but you might just as well install it into a sandbox (made only for it) and the symlink the binary
06:46:41 <adas> bennofs: this doc -> https://www.fpcomplete.com/blog/2015/04/announcing-stackage-cli is silly cos it doesn't mention anything about installing a package called "stackage-sandbox". and its the official doc.
06:47:58 <bennofs> adas: it was probably factored out after that post
06:47:58 <adas> bennofs: and the line in that doc "stackage-cli ships with executables called stackage-init, stackage-purge, stackage-upgrade, and stackage-sandbox"
06:49:20 <bennofs> adas: you can see on hackage that http://hackage.haskell.org/package/stackage-cli-0.0.0.4 still lists stackage-sandbox as an executable, but the 1.0 version doesn't anymore
06:52:22 <hodapp> I used a newtype and my computer didn't explode! \o/
06:55:39 <adas> bennofs: do you know the best way to install stackage?
06:56:20 <adas> is it "cabal install stackage" or "cabal install stackage stackage-cli stackage-sandbox" or something else?
06:56:27 <bennofs> adas: no, idk
06:56:44 <hodapp> if I have, say, data Foo a = Foo a deriving (Bar, Baz), does it defer until I've actually tried to specialize 'Foo' over some type 'a' to see if 'a' satisfies Bar & Baz?
06:57:26 <merijn> hodapp: No, it just adds a constraint to the instance
06:57:39 <merijn> hodapp: Like "instance Eq a => Eq ([] a) where"
06:57:53 <merijn> hodapp: "instance Eq a => Eq (Foo a) where"
07:28:48 <hodapp> http://hackage.haskell.org/package/base-4.8.0.0/docs/src/Data-Data.html - can someone look at the definition of gmapQi, particularly its inner function 'k', and tell me what I'm missing? I see that its first argument is of type Qi u (d -> b), and it pattern-matches that first argument so i' :: u, q :: (d -> b) - so I think
07:29:17 * hackagebot cblrepo 0.17.0 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.17.0 (MagnusTherning)
07:29:21 <hodapp> but then the 'else' branch of k returns Qi (i' + 1) q, but the return type of k should be Qi u b
07:33:17 <hodapp> and the other branch is (Just (f a)) rather than 'q', so that's clearly not d -> b
07:33:19 <hodapp> hrmmm
07:34:46 <hodapp> perhaps my interpretation of what Qi u (d -> b) means is just completely wrong
07:35:16 <hodapp> given that the definition of Qi is:  data Qi q a = Qi Int (Maybe q)
07:35:32 <hodapp> ...nevermind.
07:36:17 <cdk> @pl \n -> zipWith const `ap` drop n
07:36:17 <lambdabot> (zipWith const `ap`) . drop
07:39:30 <maerwald> is there an IRC channel for juicypixels? cannot find one
07:53:00 <ion> CABAL is an acronym?
07:54:18 * hackagebot srcloc 0.5.0.2 - Data types for managing source code locations.  http://hackage.haskell.org/package/srcloc-0.5.0.2 (GeoffreyMainland)
07:56:07 <hodapp> Common Applicarmmmmble Business analytics Language?
07:57:19 <frerich> There is no cabal.
08:00:07 <hexagoxel> ion: "A Common Architecture for Building Applications and Libraries"
08:00:24 <ion> Ah. Thanks.
08:01:05 <byorgey> maerwald: I don't think so, but probably #diagrams is the next best thing, you're welcome to discuss juicypixels in there
08:01:55 <byorgey> many people in #diagrams use/are familiar with it, and the juicypixels author also hangs out in there sometimes (when he is on IRC, which seems not very often)
08:02:59 <ion> What a weird concept, to be on IRC not often.
08:03:38 <hexagoxel> at least send a bot/relay to idle for you!
08:07:17 <muzzle> In the description of Data.Bytestring it says "A time and space-efficient implementation of byte vectors using packed Word8 arrays". What are packed arrays / what makes them different from normal arrays ?
08:08:02 <c_wraith> muzzle: arrays are normally packed.  It's just slightly-redundant wording to ensure the user that it's not a linked list
08:08:38 <merijn> muzzle: That's just saying "it uses blobs of bytes"
08:09:02 <muzzle> is there such a thing as an unpacked array ?
08:09:09 <muzzle> just out of curiosity…
08:09:14 <tdammers> there is such a thing as a "sparse array"
08:09:27 <tdammers> or rather, various storage algorithms that you can use to implement htose
08:09:28 <c_wraith> It could also mean there's no padding between elements.
08:09:29 <muzzle> tdammers: an IntMap >
08:09:29 <tdammers> *those
08:09:31 <muzzle> ?
08:09:36 <tdammers> yes
08:09:46 <c_wraith> Which happens sometimes with certain sizes of data structure
08:10:18 <geekosaur> there's a certain tendency to use "natural" sizes. consider that a Word8 is normally stored in a machine word (32 or 64 bits depending on platform)
08:10:33 <muzzle> c_wraith: what do you mean by padding between elements ?
08:10:44 <geekosaur> so I would expect packed Word8 to mean it's actually using bytes and not machine words for each element
08:10:59 <c_wraith> muzzle: exactly what geekosaur is talking about now
08:11:18 <muzzle> ok, thx :)
08:13:28 <muzzle> so using unpack on a ByteString basically just accesses each index in turn ?
08:13:59 <merijn> muzzle: Turns it into a linked list of its elements, yes
08:14:15 <c_wraith> merijn: modulo the occasional fusion smartness...
08:16:36 <hodapp> bleah, I am unable to figure out if gfoldl will let me do some operation on every field in a record, given that every field of the record is either of a specific polymorphic type, or derives from a typeclass
08:16:40 <muzzle> are there any problems with using the TypeFamilies extension ?
08:16:46 <hodapp> it looks like it's written to prohibit this
08:17:52 <hodapp> :t gfoldl
08:17:54 <lambdabot> Data a => (forall d b. Data d => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
08:18:14 <hodapp> unless there's some way I can add a contraint on that inner 'd'...
08:19:21 <hodapp> is my intuition that this runs against the nature of 'forall' correct?
08:19:50 <c_wraith> hodapp: correct, you can't pass a more constrained function there
08:20:11 <hodapp> dang
08:20:43 <bennofs> hodapp: I can only repeat my recommedation to use GHC.Generics if you want to access fields ...
08:20:44 <hodapp> perhaps there is some hax0ry I can do to work around this
08:21:08 <hodapp> bennofs: well, I'm not even entirely sure I need to access the field
08:23:05 <athan> Hi everyone. Does anyone know of a good server infrastructure for deploying Wai applications? Ideally free? Heroku seems to need a "private data store" prerequisite - a remote (Amazon) hard drive.
08:23:23 <bennofs> hodapp: I think Data.Data works at runtime, where it is too late to check for typeclass instance
08:24:20 <bennofs> athan: oh really? last I tried it, I could host an app directly on heroku. You could also try openshift (similar to Heroku, from redhat)
08:24:53 <athan> bennofs: Yeah, I'm not sure how to work the beast, but that was the error I was getting. Thanks :)
08:24:54 <recontryba> hi
08:28:15 <adas> does anyone here use stackage?
08:28:23 <adas> or is it not even necessary?
08:30:44 <slack1256> adas: is not even necessary but makes things much much easier
08:31:20 <haskell974>  another question
08:31:31 <haskell974> what is the meaning of ~ (tilde) in: http://www.happstack.com/docs/crashcourse/index.html#hsx-and-do-syntax
08:31:46 <haskell974> StringType m ~ Text
08:32:35 <indiagreen> is the “SomethingM” naming convention used for anything already? (not talking about “filterM”, it's a value and not a class/type)
08:32:48 <adas> slack1256: do you have it installed? if so, could you tell me how you did it?
08:33:06 <indiagreen> haskell974: type equality
08:33:08 <ion> haskell974: It asserts that the two types are equal.
08:33:55 <mmachenry> indiagreen: somethingM usually signifies monadic versions of functions.
08:34:14 <indiagreen> mmachenry: yep, I know / that's why I added that thing about filterM
08:34:41 <haskell974> Why don't we write: doBlock :: (XMLGenerator m, Text) => XMLGenT m (XMLType m) ?
08:34:56 <slack1256> adas: literally the quick start on their page https://www.stackage.org/
08:34:56 <haskell974> ( just replaced StringType m with Text )
08:35:17 <slack1256> adas: it not doing much, it's telling cabal to use stackage.org instead of hackage repo
08:35:27 <indiagreen> haskell974: because “Text” by itself isn't a constraint
08:35:29 <ion> Neither XMLGenerator m nor Text are constraints.
08:35:43 <slack1256> oh and remove the .ghc folder so you start anew
08:35:54 <indiagreen> the constraint is “the type of string used with “m” is Text”
08:35:56 <ion> Oh, the former may be.
08:36:16 <indiagreen> ion: yep, the former is as according to the snippet on the page
08:36:24 <ion> I thought it was the thing that used to be on the left hand side of the ~, but it wasn't.
08:37:39 <ion> ~ takes two types and returns a constraint.
08:37:59 <ion> :k (~)
08:38:00 <lambdabot> k -> k -> Constraint
08:38:10 <slack1256> Oh (~) is typed. Cool
08:38:27 <slack1256> :k (=>)
08:38:28 <lambdabot> parse error on input ‘=>’
08:38:33 <slack1256> Mmm
08:39:04 <haskell974> what do you exactly mean by constraint? like, the type should be equal to Text? 
08:39:29 <quchen> slack1256: More like "kinded".
08:39:44 <slack1256> quchen: You're right :-)
08:40:11 <slack1256> @src (~)
08:40:11 <lambdabot> Source not found. I've seen penguins that can type better than that.
08:40:27 <ion> haskell974: Code calling that function will only typecheck if its choice of m satisfies that equality.
08:40:57 <haasn> slack1256: (=>) :: Constraint -> * -> *  -- if we could give it a kind, it would be this
08:40:57 <slack1256> Mmm if (~) is a type-level function, it ought to be defined somewhere as GHC.TypeLits right?
08:41:31 <quchen> haasn: -XKinderSignatures!
08:42:13 <indiagreen> haskell974: basically, “StringType” is a type function – it takes a type, and gives another type. For all types “m” that can be XMLGenerators, it will give what *string type* (Text, String, etc) is associated with it
08:42:14 <slack1256> haasn: Can the left constraint be a tuple of constrains? as (Functor m, MonadReader Int m) => ... ?
08:42:47 <slack1256> or (Constraint, Constraint) ~ Constraint
08:43:01 <haasn> slack1256: ‘Constraint’ itself contains tuples of constraints
08:43:04 <indiagreen> haskell974: so, the whole constraint can be read as “m has to be an XML generator, and Text has to be the string type it uses”
08:43:08 <haasn> (c :: Constraint, c :: Constraint) :: Constraint
08:43:11 <quchen> You can view (,) :: (Constraint, Constraint) -> Constraint, if you want
08:43:23 <haasn> But (,) is not really a constraint operator
08:43:25 <haasn> It's a special syntax form
08:43:34 <slack1256> Mmm yes
08:43:40 <haasn> (Perhaps unfortunately)
08:43:48 <slack1256> I should really read that part of GHC, #haskell you're always interesting
08:43:58 <indiagreen> haskell974: if you want to know more about things like this, read here: https://wiki.haskell.org/GHC/Type_families#An_associated_type_synonym_example
08:44:12 <athan> How much ram is necessary for compiling with GHC/Cabal? 4G?
08:44:19 * hackagebot monad-time 0.1 - Type class for monads which carry the notion of the current time.  http://hackage.haskell.org/package/monad-time-0.1 (arybczak)
08:44:53 <indiagreen> athan: I think 0.5GB of RAM and 0.5GB of swap is enough, at least when I was compiling things on my VPS
08:44:53 <quchen> athan: My laptop has a total of 4 and I could compile them, so it's less than that.
08:44:54 <haskell974> thanks for the explanation. I'll read that page and come back with questions - my head is now just on fire!
08:45:02 <hodapp> athan: maybe not 4 GB but I feel like I've run into problems on < 1 GB (RAM + SWAP)
08:45:29 <athan> indiagreen: Oh wow! Yeah hodapp, I've run into a few issues in < 1 GB too
08:45:35 <athan> thanks guys :)
08:46:01 <hodapp> my laptop has 6 GB RAM and it's never been an issue.
08:47:40 <haasn> slack1256: if you're interested in ConstraintKinds, have a look at https://hackage.haskell.org/package/constraints-0.4.1.3/docs/Data-Constraint.html and try to work through how it works
08:54:49 <athan> ConstraintKinds ftw
09:12:12 <rhllor> how can i turn an integer like 123 into a list like [1,2,3]
09:12:40 <alynn> :t map read . show
09:12:42 <lambdabot>     Couldn't match type ‘Char’ with ‘[Char]’
09:12:42 <lambdabot>     Expected type: a -> [String]
09:12:42 <lambdabot>       Actual type: a -> String
09:12:59 <ion> > (map (:[]) . show) 123
09:13:00 <lambdabot>  ["1","2","3"]
09:13:31 <Iceland_jack> > map digitToInt (show 123)
09:13:32 <lambdabot>  [1,2,3]
09:13:46 <slack1256> there was a way with logaritms base 10 I recall
09:13:52 <ion> > unfoldr (\n -> swap (n `quotRem` 10) <$ guard (n /= 0)) 123
09:13:53 <lambdabot>  [3,2,1]
09:13:54 <Iceland_jack> It will fail though
09:13:54 <Iceland_jack> > map digitToInt (show (-123))
09:13:55 <lambdabot>  [*Exception: Char.digitToInt: not a digit '-'
09:14:22 <ion> > (reverse . unfoldr (\n -> swap (n `quotRem` 10) <$ guard (n /= 0))) (-123)
09:14:24 <lambdabot>  [-1,-2,-3]
09:14:35 <alynn> blah
09:14:39 <alynn> > map (read . pure) (show 123) :: [Int]
09:14:41 <lambdabot>  [1,2,3]
09:14:41 <alynn> is what I meant
09:15:49 <rhllor> thank you everyone
09:18:39 <benzrf> that's a terrible solution alynn
09:19:20 * hackagebot x509-validation 1.5.2 - X.509 Certificate and CRL validation  http://hackage.haskell.org/package/x509-validation-1.5.2 (VincentHanquez)
09:22:29 <rhllor> I have    foo = map (\x -> read x :: Integer)          foo ["1", "2", "3"]     this works fine but     foo "123"    doesn't. Why? (I'm pretty much to this)
09:22:52 <cite-reader> :t ["1", "2", "3"]
09:22:53 <lambdabot> [[Char]]
09:22:55 <cite-reader> :t "123"
09:22:56 <lambdabot> [Char]
09:23:16 <srhb> :t read
09:23:17 <lambdabot> Read a => String -> a
09:23:27 <srhb> Char /= String
09:23:28 <rhllor> how can I make this so it works just for [Char]
09:23:45 <Iceland_jack> rhllor: When you have
09:23:45 <Iceland_jack>     map (\x -> ...) "123"
09:23:45 <Iceland_jack> the 'x' has type Char
09:23:57 <Iceland_jack> But 'read' takes a String (= [Char])
09:23:57 <Iceland_jack> :t read
09:23:58 <lambdabot> Read a => String -> a
09:24:11 <Iceland_jack> So you have to wrap the character 'x' in a list: [x]
09:24:20 <Iceland_jack> > map (\x -> [x]) "123"
09:24:22 <lambdabot>  ["1","2","3"]
09:24:25 <Iceland_jack> And then you can read it
09:24:31 <Iceland_jack> > map (\x -> read [x] :: Integer) "123"
09:24:33 <lambdabot>  [1,2,3]
09:24:34 <ion> > map digitToInt "123"
09:24:35 <lambdabot>  [1,2,3]
09:24:36 <rhllor> that worked, thanks
09:27:12 <amindfv> so with -XConstraintKinds i can write e.g. "data X (y :: Symbol) = X", but I can't find how to write something like "data X (y :: forall z. KnownSymbol z => z) = X"
09:27:17 <amindfv> is it possible?
09:27:30 <amindfv> er, not constraintkinds -- datakinds
09:27:43 <johnw> you mean, you want kind families
09:27:47 <johnw> I'm not sure that's a thing yet
09:28:32 <bennofs> amindfv: just put the proof of KnownSymbol z into the data type itself?
09:28:51 <bennofs> amindfv: like data X (y :: Symbol) where X :: KnowSymbol y => X y
09:30:20 <dreams> Hudak died :(
09:38:35 <hodapp> bennofs: yeah, you're probably right regarding generics. I just felt initially like I could do all I needed with just Base.Data and that record access wasn't necessary
09:39:21 <bennofs> hodapp: with generics, you can even generate your own type errors at compile time!
09:40:23 <quchen> Data.Set is pretty much identical to parts of Data.Map. Is there a reason that `Set` isn't simply `Map - ()`, other than saving the pointer to the `()` value?
09:40:48 <hodapp> bennofs: yay errors >_>
09:40:54 <quchen> Data.Set could be a collection of reexports in that case, mostly
09:44:21 * hackagebot fasta 0.6.0.0 - A simple, mindless parser for fasta files.  http://hackage.haskell.org/package/fasta-0.6.0.0 (GregorySchwartz)
09:45:33 <dolio> Can I make 'Map - ()' Foldable?
09:46:08 <dolio> Is the 'Map a ()' Monoid the instance we want to pick for it?
09:46:46 <erisco> mah loop for :: (Monad m) => (s -> Bool) -> (s -> m s) -> s -> m s
09:46:59 <bennofs> erisco: ?
09:47:37 <erisco> bennofs I wanted a for loop, that is my for loop
09:47:44 <bennofs> ah :)
09:48:07 <bennofs> I often just use forM_ [0..n] $ \i -> do ... for my for loops :)
09:48:27 <erisco> I do not want to allocate a list just for a loop counter
09:48:31 <bennofs> (that covers most cases where I would want a for loop)
09:48:36 * hodapp sticks a lopsided "REAL MEN USE FOLDR" bumper sticker on erisco's laptop
09:48:47 <c_wraith> hodapp: is it biased to the left?
09:49:17 <hodapp> c_wraith: it's a lopsided bumper sticker, it's not supposed to make too muchsense
09:49:20 <bennofs> erisco: then use Vector and your vector should be fused away!  ;)
09:49:21 <hodapp> s/muchsense/much sense/
09:49:36 <erisco> bennofs uhh, lol
09:49:44 <dolio> The list might be fused away.
09:49:59 <bennofs> yes, but list fusion doesn't work as reliable as vector fusion afaik
09:50:04 <erisco> *might*
09:50:20 <erisco> but why in the world would I want to allocate, I dunno, a vector of 100 Ints just for a loop counter
09:50:23 <erisco> that is crazy sauce
09:50:51 <dolio> The vector wouldn't be allocated. Same as the list.
09:51:06 <dolio> And by 'might', I mean you have to check if it's implemented.
09:51:07 <erisco> I'd like to be convinced of this
09:51:13 <Lis> Hello everyone. I have a list of conditions a [1,1,1,1,0,0,0,0,0] and two lists of values b [3,2,3,3,2,3] c [4,5,4,5,4,5,4] now, i want to calculate 3*4 if list a is 1 else, i want to return list c
09:51:32 <platz_> i thought the [1..n] syntax expanded on demand
09:51:45 <c_wraith> :t zipWith3
09:51:46 <lambdabot> (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
09:51:47 <erisco> also, out of principle, I do not want to rely on some magical optimisation for my code to work as intended
09:51:48 <dolio> I don't think vector's fusion is significantly more reliable than list fusion, though.
09:51:53 <erisco> would much rather write what I mean
09:52:09 <c_wraith> Lis: zipWith3 would do the job nicely, if you're sure all the lists are the same length
09:52:11 <bennofs> dolio: I thought vector does full stream fusion, while list only does foldr/build fusion?
09:52:20 <Lis> c_wraith, ok thank you
09:52:46 <Iceland_jack> Lis: Something like this
09:52:47 <Iceland_jack> > zipWith3 (\a b c -> if a == 1 then b * c else c) [1,1,1,1,0,0,0,0,0] [3,2,3,3,2,3] [4,5,4,5,4,5,4]
09:52:48 <lambdabot>  [12,10,12,15,4,5]
09:52:50 <dolio> bennofs: So?
09:53:21 <dolio> foldr/build handles some cases stream fusion doesn't.
09:53:30 <Lis> solutions could be that simple :D thanks everyone
09:53:42 <OlderNehamkin> hi
09:53:45 <Iceland_jack> Lis: You can write it in a different way if you're interested, it may be more intuitive
09:53:51 <bennofs> dolio: hmm, I probably have no idea. I should try it out :)
09:53:53 <dolio> (And vice versa)
09:54:05 <Lis> Iceland_jack, what would be the other method?
09:54:16 <Iceland_jack>     [ if a == 1 then b * c else c
09:54:16 <Iceland_jack>     | a <- [1,1,1,1,0,0,0,0,0]
09:54:16 <Iceland_jack>     | b <- [3,2,3,3,2,3]
09:54:16 <Iceland_jack>     | c <- [4,5,4,5,4,5,4]
09:54:18 <dolio> bennofs: foldr/build doesn't mean that only those two things fuse. There are many things that can be written in those terms.
09:54:21 <Iceland_jack>     ]
09:54:27 <Lis> Iceland_jack, hm, ok thank you
09:54:30 <Iceland_jack> Using an extension for parallel list comprehensions (ParallelListComps)
09:54:48 <Iceland_jack> Lis: Do you know how to enable extensions? lambdabot doesn't have it enabled so I can't showcase it directly
09:54:49 <bennofs> dolio: yes, I know that
09:54:58 <Lis> Iceland_jack, yes i know
09:55:01 <Iceland_jack> Okay
09:55:01 <Iceland_jack>  
09:55:13 <dolio> forM_ is a foldr, and [a..b] is a build.
09:55:24 <dolio> Or, can be, at least.
09:56:20 * bennofs tries it out
09:56:22 <dolio> The major downside to foldr/build was foldl not fusing, but even some of that works in 7.10.
09:56:57 <c_wraith> Yeah, foldl fuses in several major cases in 7.10 thanks to a bunch of new analysis stuff.
09:57:17 <ion> Cool. Is there an article about that somewhere?
09:57:33 <ion> Do list literals use build, btw?
09:57:47 <c_wraith> ion: http://www.joachim-breitner.de/publications/CallArity-TFP.pdf
09:57:52 <ion> c_wraith: Thanks
09:58:16 <Kremlin> Is Haskell dead?
09:58:27 <dolio> ion: Depends which literals, I think.
09:58:27 <bennofs> dolio: ok, forM_ indeed fused on ghc 7.10
09:58:41 <c_wraith> Kremlin: so dead that the main compiler has more committers than efer.
09:58:43 <dolio> ion: [a..b] is build. But [a,b,c] might not be.
09:58:47 <c_wraith> *ever
09:58:49 <ion> dolio: ok
09:59:08 <Kremlin> heh, I meant the guy, not the language ;)
09:59:19 <c_wraith> oh.  Yes, he's been dead for a while.
09:59:32 <c_wraith> Kremlin: https://en.wikipedia.org/wiki/Haskell_Curry
09:59:33 <ion> Kremlin: He died in 1982.
09:59:48 <bennofs> I'd like GHC to just compute map f [a,b,c] at compile time. It sucks that sometimes, [f a, f b, f c] is more efficient :|
10:00:11 <Kremlin> Ok, thanks
10:00:18 <bennofs> (not sure about the exact example, but I certainly had cases such as this)
10:00:38 <erisco> you see
10:00:52 <erisco> these optimisations are welcomed bonuses, but why rely on them
10:01:20 <dolio> Because that's the whole point in doing them.
10:01:25 <bennofs> erisco: I'd say that you cannot write performant haskell code without relying on optimizations
10:02:08 <monochrom> I am sure erisco means just the example map f [a,b,c] vs [f a, f b, f c], not all optimizations under the sun
10:02:47 <dolio> At least earlier, he meant using 'forM_ [a..b] ...' instead of hand-writing a loop.
10:02:49 <Lis> uhm. ok. so i have a implementation logic here. if i use zipwith3 and have a list of [[...],[...],[...]] how can i map zipwith3 to every row element. i know i can do map (take 1) listoflists
10:03:09 <erisco> what I mean is, if you mean something particular, why not write just that thing rather than using something else with the expectation that some optimisation rule triggers to convert back to the thing you actually meant?
10:03:42 <dolio> Why not just write the exact assembly you mean?
10:03:52 <erisco> because I do not mean assembly
10:03:55 <c_wraith> erisco: because sometimes the optimized form is verbose as heck.  It's really nice to write shorter code and have it compile the same way.
10:04:44 <c_wraith> erisco: along with it being easier to introduce bugs into the optimized form
10:05:21 <monochrom> usually I write just what I mean in particular. and usually the thing I mean is the unoptimized one.
10:05:23 <erisco> dolio what do you mean hand-writing a loop? I just wrote a loop that does not allocate a list for a counter
10:09:15 <ronh-> is AnyFoo existential type? data Foo a = ..   data AnyFoo = forall a . AnyFoo (Foo a)   
10:09:18 <Lis> like i have a=[[1,0,1],[1,1,0]] b=[[2.3,4.5,2.4],[1.2,2.2,1.4]] c=[[100,200,300],[400,500,600]] and want to calculate if a!!0 == 1 b!!0*c!!0 else c!!0 (for every first element in the list of lists, then for the second etc.
10:09:48 <bennofs> ronh-: yes it is
10:09:57 <ronh-> even though there are no classes involved?
10:10:07 <monochrom> it would be ungrounded to assume: I have a highly efficient tight loop in my head in the first place, I deliberately write a slow algorithm that gives the same answer so as to enjoy relying on the optimizer to turn it back into the tight loop in my head.
10:11:22 <erisco> shame is I don't think I can use unboxed tuples for 's' with the signature   for :: (Monad m) => (s -> Bool) -> (s -> m s) -> s -> m s
10:11:22 <bennofs> ronh-: I'd say yes, because why not, but hmm, you're right that this could be a complication. Also, this type still needs -XExistentialQuantification :)
10:11:25 <cite-reader> I usually _don't_ have a tight loop in my head. I've got some pipeline of transformations in my head, and I'd like to write those down without needing to do the work to translate it to a single fused loop.
10:11:30 <erisco> because it is hiding in the m :(
10:11:34 <cite-reader> I mean, I could write C.
10:12:07 <bennofs> erisco: why would you use an unboxed tuple? to return a bool from the monadic action directly?
10:12:35 <erisco> bennofs the state has two variables, so I am using a tuple
10:13:08 <erisco> an unboxed tuple because there is no good reason to heap allocate the loop state
10:15:02 <Lis> hm, how can i map for every list within a list? [[a],[b],[c]] should run functions on [a] then [b]...
10:15:32 <erisco> > map f [[a],[b],[c]]
10:15:36 <lambdabot>      No instance for (Show b0)
10:15:38 <lambdabot>        arising from a use of ‘show_M864073151209638424126647’
10:15:40 <lambdabot>      The type variable ‘b0’ is ambiguous
10:15:51 <Iceland_jack> > map (map f) [[a],[b],[c]] :: [[Expr]]
10:15:56 <lambdabot>  [[f a],[f b],[f c]]
10:16:08 <erisco> why you fail lambdabot :(
10:16:13 <maerwald> afair for those things people designed lenses, no?
10:16:16 <ion> erisco: :: [Expr]
10:16:23 <erisco> > map f [[a],[b],[c]] :: [Expr]
10:16:24 <lambdabot>  [f [a],f [b],f [c]]
10:16:47 <Lis> ah thank you
10:17:04 <Iceland_jack> > map (map show) [[1,2], [10], [100,200,300]]
10:17:06 <lambdabot>  [["1","2"],["10"],["100","200","300"]]
10:17:09 <bennofs> > (map.map) f [[a], [b], [c]] :: [[Expr]]
10:17:10 <Lis> but that still doesnt help, since i need to pass f arguments from a different list
10:17:10 <lambdabot>  [[f a],[f b],[f c]]
10:17:25 <erisco> Lis could you be more specific maybe?
10:17:28 <Lis> + the 4th list is always 5 of sice
10:17:39 <Iceland_jack> Lis: Can you describe the problem you're working on?
10:17:58 <Iceland_jack> afk, playing chess
10:18:28 * hodapp swaps Iceland_jack's queen out for a small herring
10:18:29 <ion> @type zipWith3 . zipWith3
10:18:30 <lambdabot> (a -> b -> c -> d) -> [[a]] -> [[b]] -> [[c]] -> [[d]]
10:18:55 <erisco> > fmap fmap fmap f [[a], [b], [c]] :: [[Expr]] -- you started it bennofs 
10:18:56 <lambdabot>  [[f a],[f b],[f c]]
10:19:17 <Iceland_jack> Lis: (there is probably a nicer way of structuring your problem, dealing with nested lists of functions and values can be awkward: others on the channel wil probably give you more concrete advice)
10:19:19 <Lis> i create a function, which creates a list of 1 or 0 depending of a condition is true or false. to save argument typing, i put all those 1,0 in [[1,0],[1,1]...] becouse i have multiple
10:19:31 <bennofs> erisco: heh :) but I like (map.map) since it generalizes to any "depth": you can just write (map.map.map) to go down 3 levels
10:19:45 <ion> erisco: I use (map . map) all the time, that’s not toying.
10:20:10 <erisco> > fmap fmap fmap fmap fmap f [[[a]], [[b]], [[]c]] :: [[[Expr]]] -- it is all your fault bennofs !
10:20:11 <lambdabot>      Couldn't match type ‘[[[Expr]]]’ with ‘f0 a0 -> f0 b0’
10:20:11 <lambdabot>      Expected type: ((a0 -> b0) -> f0 a0 -> f0 b0)
10:20:11 <lambdabot>                     -> ([[[Expr]]] -> [b1]) -> [[[Expr]]] -> [[[Expr]]]
10:20:13 <ion> Lis: Btw, why not represent true and false with True and False?
10:20:19 <erisco> :(
10:20:37 <erisco> > fmap fmap fmap fmap fmap f [[[a]], [[b]], [[c]]] :: [[[Expr]]] -- it is all your fault bennofs !
10:20:39 <lambdabot>      Couldn't match type ‘[[[Expr]]]’ with ‘f0 a0 -> f0 b0’
10:20:39 <lambdabot>      Expected type: ((a0 -> b0) -> f0 a0 -> f0 b0)
10:20:39 <lambdabot>                     -> ([[[Expr]]] -> [b1]) -> [[[Expr]]] -> [[[Expr]]]
10:20:41 <erisco> hm
10:21:20 <maerwald> erisco: can you show how this would work with lenses?
10:21:25 <erisco> oh oh
10:21:32 <bennofs> maerwald: over (traverse.traverse)
10:21:34 <erisco> not enough fmap! you just need more fmap
10:21:38 <bennofs> :t over (traverse.traverse)
10:21:39 <lambdabot> (Traversable t, Traversable t1) => (a -> b) -> t (t1 a) -> t (t1 b)
10:21:42 <ion> erisco: fmap (fmap fmap fmap) fmap
10:21:48 <erisco> > fmap fmap fmap fmap fmap fmap fmap f [[[a]], [[b]], [[c]]] :: [[[Expr]]] -- it is all your fault bennofs !
10:21:50 <lambdabot>      Couldn't match type ‘f0 (f1 ()) -> f0 (f1 b0)’ with ‘[[[Expr]]]’
10:21:50 <lambdabot>      Expected type: (((() -> b0) -> [[[Expr]]])
10:21:50 <lambdabot>                      -> ([[[Expr]]] -> () -> b0) -> [[[Expr]]] -> [[[Expr]]])
10:21:53 <erisco> wat :(
10:22:09 <bennofs> So, that's why I do not use that one :)
10:22:27 <erisco> MORE FMAP!
10:22:34 <erisco> > fmap fmap fmap fmap fmap fmap fmap fmap f [[[a]], [[b]], [[c]]] :: [[[Expr]]] -- it is all your fault bennofs !
10:22:35 <lambdabot>  [[[f a]],[[f b]],[[f c]]]
10:22:37 <erisco> lol
10:22:59 <maerwald> subtyping can be terrible
10:23:33 <erisco> bennofs see it generalizes just fine
10:23:44 <erisco> now find the polynomial to derive the correct number of fmap's for n depth
10:24:17 <Lis> http://www.mathematek.de/paste:haskell:chart_portfolio look at the calcRebalanceFixed function, the comment tells what i want.
10:24:28 <erisco> then TH so you can  [| fmap^8 |]
10:24:58 <ion> I don’t think you can do arbitrary depth with just fmap^n.
10:25:01 <bennofs> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap -- erisco
10:25:02 <lambdabot> (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
10:25:12 <maerwald> this is madness :/
10:25:26 <R0b0t1> this is haskell
10:25:30 <maerwald> nah
10:25:33 <erisco> bennofs infinite wonders can be unlocked
10:25:50 <bennofs> erisco: you cannot get > 3 it seems
10:26:00 <bennofs> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
10:26:01 <lambdabot> (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
10:26:09 <ion> fmap^(6+4m+n) = fmap^(6+n)
10:26:21 <maerwald> R0b0t1: it's like saying C is *********ptr. No one does it.
10:27:20 <erisco> bennofs interesting
10:27:33 <erisco> bennofs someone with a lot of time could figure out why this is too
10:27:45 <erisco> also type inference gets pretty slow at around 20 fmaps :P
10:27:53 <bennofs> erisco: surely you will find the answer somewhere in the irc logs
10:27:58 <ion> https://gist.github.com/ion1/94b15b471dfcb6ab9f84
10:28:01 <bennofs> this has been encountered before
10:28:04 <hodapp> Does anyone know of any Haskell libraries that are suited for generating formatted text, perhaps from an EDSL that comprehends some basic notions of formatting? Or might I just be better generating something like Markdown on-the-fly?
10:28:10 <Lis> anyone?
10:28:30 <mpickering> hodapp: You can use pandoc-types to do that
10:29:35 <erisco> Lis it doesn't seem to me that you've asked a real question yet
10:29:59 <hodapp> mpickering: oh, thanks! That looks like what I need, if I feel like using pandoc
10:30:15 <R0b0t1> maerwald: I'm aware :^_
10:30:16 <Lis> erisco, i posted the source, it right in the comment above the calcRebalanceFixed function
10:30:17 <R0b0t1> )*
10:30:55 <maerwald> R0b0t1: I'm just afraid haskellers will actually use it :P you never know
10:31:27 <Geraldus> Hi friends!
10:31:36 * hodapp looks around
10:31:46 <Geraldus> I want to have a function which takes one argument, and returns a lambda function which uses the value of that argument internally. So I believe I want to have a closure. Is it possible to do in Elisp?
10:32:06 <hodapp> I suspect you want #emacs for that inquiry.
10:32:24 <erisco> Lis okay, but I do not know why your current solution is wrong
10:32:33 <Geraldus> ooops (:
10:32:42 <Geraldus> wrong window (: sorry 
10:32:53 <hodapp> no problem!
10:33:12 <erisco> for there to be a question I need to know 1) what you want, 2) what you have, 3) how what you have differs from what you want
10:33:17 <erisco> then I can say "oh change this"
10:33:58 <erisco> so far you've asked how to apply a function to a list of lists, which we've shown you
10:34:17 <maerwald> with 8 fmaps.
10:34:23 <Lis> erisco, becouse zipwith4 doesnt work on lists of lists ?!? but only on lists? or am i wrong?
10:34:33 <erisco> :t zipWith4
10:34:34 <lambdabot> (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
10:34:40 <erisco> it works on lists of anything
10:34:46 <erisco> which includes lists of lists
10:35:00 <Lis> ahhhhh, ok. now i try to run it
10:35:08 <Lis> if it works like expected, thank you :D
10:36:31 <Lis> is it possible to just import a specific function?
10:37:22 <frerich> Lis: Yes, e.g. 'import Data.List (group)' imports just the 'group' function.
10:37:29 <erisco> yes,   import ModuleName (functionName)
10:37:37 <Lis> ty
10:38:26 <erisco> if you have conflicts with Prelude you can also  import Prelude hiding (functionName)
10:38:58 <erisco> or you can   import qualified ModuleName as ShortName
10:43:28 <albeit> Is there a cleaner way to do this? [(i,j) | i<-[1..n], j<-[1..n]]
10:44:38 <dolio> Not much.
10:44:55 <ion> albeit: liftA2 (,) [1..n] [1..n] is an alternative
10:45:15 <ElMoloko> Are there any good tutorials on FFI for c++?
10:46:51 <ElMoloko> I'm trying to use HELib
10:49:36 <maerwald> albeit: toList . matrix n n $ id
10:56:02 <erisco> > 5#
10:56:03 <lambdabot>      Couldn't match kind ‘*’ with ‘#’
10:56:03 <lambdabot>      When matching types
10:56:03 <lambdabot>        a0 :: *
10:56:07 <tommd> ElMoloko: Yay, HELib.
10:56:21 <tommd> ElMoloko: Generally you want to make a C wrapper for the C++ then FFI to C.
10:56:27 <tommd> It is verbose but not exactly tricky
10:56:34 <tommd> Are you FFIing to HELib?
10:56:49 <tommd> If so, notice that while NTL is thread safe since 7.0 the actual HELib library is not thread safe last I checked.
10:57:04 <erisco> http://lpaste.net/132111  how do I annotate  myId  to be kind # rather than *?
10:57:34 <tommd> Also, I'd love to see any FFI work open source (you'll probably incur a good deal of locking to deal with thread local storage sloppyness)
10:58:26 <erisco> you're supposed to be able to pass unboxed values to functions right?
10:58:39 <tommd> erisco: MagicHash and Kind Signatures, right?
10:59:28 <erisco> tommd I try   myId :: (a :: # ) -> a    and get a syntax error at #  with KindSignatures on
11:01:27 <erisco> "you can't pass them to polymorphic functions" -- https://wiki.haskell.org/Unboxed_type
11:01:30 <erisco> oh
11:01:44 <erisco> poopy, why not
11:03:18 <erisco> I can write for Int# though, which should be gud 'nuff if I want a loop counter
11:03:30 <erisco> not overly pleasing though
11:03:40 <geekosaur> erisco, because it needs some information about the actual type --- which is part of the box
11:04:03 <erisco> geekosaur I got told yesterday that it is not part of the box, it is part of the value
11:05:54 <geekosaur> mm, I think this is because there's actually two levels of box. but you can't have one without the other. (one box is a pointer to the cell, the other is the constructor tag. seen from the first box, the second is part of the value?)
11:07:31 <geekosaur> the point remains that an unboxed value is a random chunk of memory with no identifying information itself. that identification comes from the container (for an unboxed vector or etc.) or outer constructor (e.g. data Int = I# Int#)
11:08:07 <Iceland_jack> <albeit> Is there a cleaner way to do this? [(i,j) | i<-[1..n], j<-[1..n]]
11:08:08 <Iceland_jack> > join (liftA2 (,)) [1..3]
11:08:09 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
11:08:16 <Iceland_jack> "cleaner"
11:08:36 <geekosaur> so in some sense an unboxed value is also an untyped value
11:10:02 <NicX> If I write a function like    countDown n = if n <= 0 then 0 else countDown (n-1)    , will laziness make this function consume the call stack as n decrements?
11:10:16 <arkeet> there is no call stack
11:10:23 <NicX> oh?
11:10:31 <TimWolla> Tail Recursion :-)
11:10:37 <arkeet> but that is tail recursive yes
11:10:50 <NicX> what's the deal then with foldl vs foldl'?
11:10:53 <defanor> i've set lambdabot, but it doesn't stop to talk. how to make it to stop?
11:11:21 <arkeet> foldl' evaluates the accumulator (to whnf) at every iteration
11:11:35 <arkeet> foldl just builds up a big thunk
11:12:07 <arkeet> https://wiki.haskell.org/Foldr_Foldl_Foldl%27
11:12:20 <arkeet> (and foldr does something different entirely)
11:12:54 <NicX> I thought my countDown function would build up a ((((n-1)-1)-1)-1)-1 ... instead of strictly computing the decrements
11:13:04 <arkeet> no
11:13:08 <NicX> ok, cool
11:13:10 <arkeet> it has to compute it because of the comparison n <= 0
11:13:27 <NicX> ah
11:13:45 <arkeet> otherwise you'd be right
11:13:54 <NicX> how would I make a strict version of sum>
11:14:07 <ion> foldl' (+) 0
11:14:09 <arkeet> well, the short answer is foldl' (+) 0
11:14:18 <NicX> lol
11:14:30 <NicX> how would I make a strict version of sum without strict fold?
11:14:32 <Lis> hm if i import Data.List i get this error http://lpaste.net/132115
11:14:50 <arkeet> look at the definition of foldl' and substitute in (+) and 0
11:14:51 <arkeet> ;-)
11:15:25 <quchen> arkeet: That's a compiler optimization, actually. foldl' is not guaranteed to evaluate the accumulator at each step. seq can just help the compiler a lot deciding to do that optimization.
11:15:31 <arkeet> quchen: shhh
11:15:42 <quchen> arkeet: :-)
11:16:36 <quchen> arkeet: Might as well put that into the FBUT because I've seen it a couple of times
11:16:47 <arkeet> FBUT?
11:16:57 <quchen> Or maybe open up a new file for quirky stuff ;-)
11:16:57 <breadmonster> quchen: the FBUT?
11:17:02 <quchen> https://github.com/quchen/articles/blob/master/fbut.md
11:17:05 <quchen> ^ FBUT
11:17:22 <arkeet> ah
11:17:33 <arkeet> well, you already have a section on seq
11:17:38 <Lis> how can i fix this? and why does the error show up after importing Data.List ? source is here: http://www.mathematek.de/paste:haskell:chart_portfolio
11:17:54 <arkeet> what's the error?
11:18:11 <hodapp> alright, what import and I missing from Aeson that it is complaining that 'String' does not match 'aeson-0.8.0.2:Data.Aeson.Types.Internal.Value'?
11:18:12 <quchen> arkeet: Hm, I guess it could be an expansion on the evaluation order part.
11:18:24 <breadmonster> NicX: sum xs = let sum' acc (x:xs) = x + acc `seq` sum (x+acc) xs; sum' acc [] = acc in sum' 0
11:18:38 <ion> hodapp: Perhaps LANGUAGE OverloadedStrings.
11:19:02 <arkeet> breadmonster: don't you want to share x + acc?
11:19:03 <hodapp> it's not that
11:19:10 <Lis> ah found it
11:19:30 <breadmonster> arkeet: as in put it inside a variable?
11:19:48 <breadmonster> I don't get what share means :P
11:20:03 <Lis> where do i find the sourcecode of zipwith4 ?
11:20:13 <breadmonster> @src zipWith4
11:20:13 <lambdabot> Source not found. Wrong!  You cheating scum!
11:20:17 <Hijiri> If something has a name, GHC will generally give mentions of the name a reference to the same memory
11:20:31 <kadoban> Lis: It's not particularly exciting, is there a reason you want that in particular?
11:20:32 <Hijiri> So that once it's evaluated, other mentions of the name refer to the same evaluated thing
11:20:35 <breadmonster> Hijiri: So use a let binding?
11:20:38 <Hijiri> yes
11:20:39 <breadmonster> Fine okay.
11:21:01 <Lis> kadoban, i want to alter it, becouse i have to pass [[Double]] [[Double]] [[Double]] [Double]
11:21:04 <geekosaur> Lis: http://hayoo.fh-wedel.de/?query=zipWith4 either click through twice or click the arrow at the right and select Source
11:21:22 <kadoban> Lis: That unifies with the type it already has.
11:21:32 <geekosaur> ("click through twice" = click on function name to get haddock, then follow Source link at far right of the haddock header)
11:21:46 <kadoban> Lis: In other words, it's already compatible with that. What are you trying, and what's going wrong?
11:23:05 <hodapp> "Couldn't match type ‘[Char]’ with ‘Data.Text.Internal.Text’"
11:23:09 * hodapp stabs Haskell
11:23:20 <Lis> kadoban,http://www.mathematek.de/paste:haskell:chart_portfolio calcRebalanceFixed function, i want to do what is written in the comment above it.
11:23:56 <Lis> kadoban, http://lpaste.net/132115 when i changed [starts]
11:25:03 <rhllor> I have three infinite lists, let's call them a,b,c. Each are of type [Integer].  I want to find out where all three of them converge
11:25:06 <kadoban> Lis: You seem to be trying to multiply lists? I don't know exactly what you expect to happen there.
11:25:37 <kadoban> rhllor: Converge meaning "have the same value" ?
11:25:38 <Lis> kadoban, yes exactly. i want to multiply if (entexts !! 0) == 1
11:25:54 <rhllor> kadoban: yes
11:25:59 <ElMoloko> tommd: thanks
11:26:20 <kadoban> Lis: No, I mean … you're doing someList * someOtherList … which I don't understand what you mean by that.
11:26:32 <ElMoloko> I'll make a C wrapper.  I will definitely open source attempt.
11:26:50 <tommd> ElMoloko: My pleasure.  If you run into trouble then e-mail me and I'll try to make time.
11:26:51 <ion> rhllor: Something like asum (zipWith3 (\a b c -> if a == b && b == c then Just a else Nothing) as bs cs)
11:26:55 <rhllor> its doesn't have to be in the same position of the list, but they all have to have the same value
11:27:13 <rhllor> ion: ill give it a try
11:27:32 <kadoban> rhllor: Ah, haha … that makes it harder I guess. Do they have any special properties, are the monotonically increasing or something?
11:27:51 <ion> “Converge” sounds like they all approach the same number.
11:27:53 <hodapp> wow... Aeson appears to be extremely easy to use.
11:28:15 <hodapp> despite the hiccup I ran into.
11:28:45 <Lis> hm you guys write faster :D
11:29:04 <kadoban> Lis: Just as a side note … it's really hard to read that code there. It doesn't wrap, and you have to scroll horizontally … with no scrollbar, since it's way at the bottom. Icky.
11:29:07 <rhllor> kadoban: one is a set of numbers where a_n = n(n+1) /2  b_n = n(3n-1)/n  and c_n = n(2n-1)
11:29:18 <checkmatein1> join ##beaner-central
11:29:57 <Hijiri> @ops
11:29:58 <lambdabot> Maybe you meant: pl oeis docs
11:30:01 <Lis> kadoban, it's what someone told me to do. thats the same i dont understand. basicly i would need to extract the first sublist of the first argument etc.? or not?
11:30:08 <Hijiri> @where ops
11:30:08 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
11:30:36 <ion> Hijiri: That looked more like a typo than spam.
11:30:39 <Hijiri> oh
11:30:44 <kadoban> rhllor: Oh okay, so those look monotonically increasing unless I'm being moronic. So what you can do is … make a recursive definition that maintains three pointers, one for each list. At each go around, increment the least one, until they're all equal.
11:30:45 <Hijiri> oh, I'm dumb
11:30:48 <Hijiri> sorry
11:31:09 <rhllor> kadoban: okay I'll try
11:31:59 --- mode: ChanServ set +o monochrom
11:32:42 --- mode: monochrom set -o monochrom
11:34:10 <arkeet> hodapp: sorry I had to step out for a bit
11:34:10 <arkeet> uh
11:34:26 <kadoban> Heh, monochrom goes +o, people flee.
11:34:27 <arkeet> whenever I see a full package name/version like that it makes me think you have multiple versions of that package installed
11:34:32 <monochrom> :)
11:34:49 <breadmonster> http://dev.stephendiehl.com/hask/#lenses
11:34:52 <breadmonster> Is this correct?
11:34:54 <arkeet> no
11:34:56 <breadmonster> that lens is not supposed to be used?
11:35:18 <arkeet> it is the opinion of a vocal minority
11:35:21 <edwardk> breadmonster: the 'lens' combinator?
11:35:24 <edwardk> or the lens library?
11:35:28 <arkeet> (also the actual code there is incorrect)
11:35:36 <breadmonster> edwardk: the library :P
11:35:38 <edwardk> oh, the library
11:35:40 * edwardk shrugs.
11:35:51 <monochrom> never heed the opinion of strangers from the internet
11:35:52 <edwardk> he's welcome to that opinion. i rather strongly disagree =P
11:36:11 <arkeet> does edwardk have lens on highlight?
11:36:13 <breadmonster> "The lens library is considered by many Haskellers to be deeply pathological and introduces a needless amount of complexity. Some care should taken when considering it's use, it is included here for information only and not as endorsement for it's use. Consider lens-family-core or fclabels instead."
11:36:21 <breadmonster> edwardk: How are you doing, btw?
11:36:32 <monochrom> I think yes, arkeet
11:36:36 <edwardk> I can say this, lens has probably been the single greatest productivity booster i've ever worked with, and that fact continues to surprise me.
11:36:53 <breadmonster> Hmm, interesting.
11:36:59 <edwardk> and none of those alternatives offer any of the things that increase my productivity when using lens
11:37:05 <c_wraith> edwardk: do you have opengl lenses?
11:37:12 <breadmonster> edwardk: Is there a good tutorial on it? I can't seem to get through your code?
11:37:13 <edwardk> c_wraith: no.
11:37:28 <edwardk> breadmonster: there are dozens of lens tutorials at this point scattered across the internet
11:37:41 <breadmonster> Anything being the author you'd endorse?
11:37:41 <arkeet> maybe I should write a lenstorial
11:37:47 <edwardk> what is considered a good tutorial very much depends on where you are coming at it from, what background and what you already know
11:37:54 <c_wraith> reading the lens code is the worst way to understand it
11:38:04 <edwardk> c_wraith: that much i very much agree with
11:38:23 <glguy> Vehement lens opposition tells you more about the author than lens
11:38:27 <edwardk> the code is written in a way that bends over backwards to maximize the number of situations every single combinator works in gracefully
11:39:03 <edwardk> this isn't optimized for readability of the lens code itself, but for minimizing the number of weird names we have to steal from you to work in all situations coherently for deep reasons
11:39:03 <Lis> kadoban, i understand that i need to add something to the zipWith4 which takes a element of enex so i can compare it with a number. but how?
11:40:58 <kadoban> Lis: I just don't understand what you're trying to do, so it's hard to advise :-/
11:43:03 <Lis> kadoban, i have 4 lists of lists. a,b,c,d. a holds dates. b holds relations, c holds control values. each list has the structure [[Double],[Double],[Double]...] with exception to list d. which is [Double]. List d holds the current capital.
11:44:21 <Lis> kadoban, now. if list c contains a 1, if want to multiplicate the relation value with the capital value, store it and rerun the function with the new capital value. if c is 0, i want to just return capital.
11:46:33 <Lis> 1. take list 1 from listoflists 1. check if first value is 1. do calculation. do this for ever element 1 of listoflist 1... store the values in the capital list. rerun the function, add the capital list result to the end.
11:47:58 <Lis> so, what you told me is "I cant do a calculation on a list" therefore i need to add a "loop" which loops over every element within the list. so my pseudocode looks like zipWith4 "loop elements"
11:49:07 <Lis> or... take sublist1 of list1, sublist1 of list2 ... and run zipWith4 over it
11:51:31 <Lis> yea, that would solve my problem.
11:52:27 <edwardk> interesting, that smdiehl page gets the notion of a prism entirely wrong
11:52:38 <edwardk> i'd tell him, but he's blocked me on twitter.
11:52:58 <Lis> aaaah, no i know kadoban :D explaining the problem sometimes helps :D
11:53:16 <hodapp> people block people on Twitter?
11:54:17 <Lis> i blocked the world. becouse i dont have twitter, hrhr
11:55:36 <Lis> > zipWith (take 1) [[1,2],[3,4]] [[5,6],[7,8]]
11:55:37 <lambdabot>      Couldn't match type ‘[Integer]’ with ‘[Integer] -> c’
11:55:37 <lambdabot>      Expected type: [Integer] -> [Integer] -> c
11:55:37 <lambdabot>        Actual type: [Integer] -> [Integer]
11:55:59 <Lis> :(
11:56:07 <quchen> edwardk: In what way is it wrong? "Prisms are for sums, lenses for products" sounds good to me.
11:56:33 <arkeet> quchen: his version of prisms can't review.
11:56:55 <arkeet> > review _Just 5
11:56:56 <lambdabot>  Just 5
11:56:57 <quchen> And that's a fundamental part of a prism?
11:56:59 <arkeet> yes.
11:57:06 <arkeet> otherwise you just have an affine traversal.
11:57:06 <quchen> Interesting.
11:57:32 <shachaf> Not only can it not review, it can traverse.
11:57:41 <shachaf> Because that's the definition of a Traversal.
11:58:03 <quchen> And prisms that can traverse are also against a proper prism's nature?
11:58:17 <arkeet> all prisms are traversals.
11:58:24 <arkeet> but most traversals aren't prisms.
11:58:37 <arkeet> any traversal that can have more than 1 target can't be a prism.
11:58:49 <shachaf> OK, I should say "it can traverse everything that can be traversed".
11:59:10 <edwardk> quchen: yes it is
11:59:20 <edwardk> he's giving the code for a traversal and calling it a prism
11:59:38 <edwardk> https://github.com/sdiehl/wiwinwlh/issues/67
12:00:54 <dmwit> subleq__: I'm not sure. It strikes me as strange, but I don't have a specific technical reason to avoid it.
12:01:26 <dmwit> subleq__: ("it" being "using criterion to benchmark another process", from earlier)
12:02:29 <quchen> edwardk: And the additional power of prisms in Lens comes from the choic-y profunctor you demand in the type?
12:02:40 <edwardk> quchen: yes
12:02:42 <quchen> If you take away that constraint, you should end up with a traversal again, correct?
12:02:46 <edwardk> the 'Applicative f' crap is just so it can be compatible with traverse
12:02:49 <edwardk> it _gets in the way_
12:02:53 <arkeet> quchen: yup
12:03:11 <edwardk> if we just had type Prism s t a b = forall p. Choice p => p a b -> p s t  -- we'd have better prisms
12:03:20 <edwardk> type Lens s t a b = forall p. Strong p => p a b -> p s t
12:03:26 <S11001001> edwardk: lol @ "many Haskellers"
12:03:28 <quchen> And dropping the Applicative isn't an option because then you couldn't compose prisms and traversals anymore ..?
12:03:43 <edwardk> but then we give up a lot in terms of how easy it is to solve indexing
12:03:55 <edwardk> S11001001: i went to send him the correction last time this post came up in discussion
12:04:16 <edwardk> but he's blocked me on twitter. probably from back during when folks had tempers flare over tony morris and the scalaz thing.
12:04:31 <edwardk> so i couldn't tell him. just saw there was a link to the github repo for the rant
12:04:32 <breadmonster> There was a scalaz thing?
12:04:34 <edwardk> so i could file an issue
12:05:16 <quchen> edwardk: Just to make me sad again, what would you gain by dropping Applicative?
12:05:25 <quchen> That is, what is a "better prism"?
12:05:44 <edwardk> breadmonster: long story short, lars kicked tony out of scalaz using a code of conduct as a rather flimsy excuse, drama ensued for a month and a half, eventually tony got his project back and the majority of the typelevel guys went off to build other projects that duplicate its functionality.
12:05:53 <edwardk> quchen: we have 're' and 'from' in lens.
12:05:58 <edwardk> you could just have one combinator
12:06:14 <arkeet> :t re
12:06:15 <lambdabot> Contravariant f => AReview t b -> LensLike' f b t
12:06:16 <edwardk> and it could turn a prism around into an 'unprism' that could be turned around to a full prism again.
12:06:16 <arkeet> :t from
12:06:17 <lambdabot> (Functor f, Profunctor p) => AnIso s t a b -> p t (f s) -> p b (f a)
12:06:26 <edwardk> right now we only turn it into a 'getter'
12:06:29 <edwardk> so we lose information
12:06:45 <edwardk> with pure profunctors we could get one combinator, and not lose information
12:06:51 <edwardk> but the applicative gets in the way of that
12:07:40 <quchen> Is that one of the reasons there's not a pure profunctor lens version around?
12:08:24 <edwardk> quchen: the reason there isn't a pure profunctor lens version around is that it doesn't play well with the rest of the ecosystem, has no good story for indexed lenses, has a worse story for traversals, and would then also split the community
12:08:44 <edwardk> in code like 'hask', i'll build up lenses as the pure profunctor version from scratch
12:08:49 <edwardk> but its a bad fit for haskell
12:09:08 <arkeet> what goes wrong with traversals?
12:09:25 * hackagebot banwords 0.1.0.0 - Generalized word blacklister  http://hackage.haskell.org/package/banwords-0.1.0.0 (fanjam)
12:09:27 <arkeet> or indexed
12:10:43 <Peaker> ThreadScope crashes on "fromJust". That's embarassing. there should only be an "unjust :: String -> Maybe a -> a" where you have to give at least a reason for why it'll never be Nothing
12:11:00 <arkeet> ow
12:12:27 <Peaker> newer thread scope fails on "invalid event log". If the program exits with error, it is an invalid event log? :(
12:15:12 <ion> (\ ~(Just a) -> a) has an error that mentions the code location automatically.
12:16:21 <Peaker> how can I know why my event log is invalid? :(
12:17:22 <geekosaur> Peaker, yes, if the program does not exit normally then the event log is invalid
12:17:47 <Peaker> geekosaur: I added a catch-all of all exceptions at exit
12:18:24 <Peaker> and it is still invalid
12:19:16 <Hijiri> again?
12:19:17 <Peaker> (indeed process exit code is 0)
12:19:19 <geekosaur> whoops
12:19:40 <Peaker> oh, it's my setNumCapabilities
12:19:45 <geekosaur> who's ddos-ing freenode now :(
12:19:47 <Peaker> (according to some ticket)
12:20:04 <Peaker> fixed 4 months ago, maybe? let's see
12:21:01 <Peaker> yep, that was it
12:23:12 <Sonarpulse> Now that AMP is done, is anybody thinking about seperating fail from monad? (Not that they're related, just that the willingness to do big nice things is demonstrated)
12:25:02 <dolio> Sonarpulse: Yes.
12:25:55 <Sonarpulse> yay!
12:26:00 <Sonarpulse> 7.12 ?
12:26:07 <dolio> No, not that fast.
12:26:17 <Sonarpulse> 42.1 ?
12:26:49 <dolio> I would guess it will take 3 versions or less.
12:27:05 <dolio> But probably 3.
12:28:22 <Sonarpulse> To give people time to change their code? or because doing things in phases?
12:28:49 <dolio> Well, phases to give people time to change their code.
12:29:22 <dolio> One to make a class for fail, one to deprecate in favor of the new class, and one to do the hard switch.
12:29:33 <dolio> Maybe the first two can be combined, not sure.
12:29:34 <Hijiri> unless they use -Werror
12:30:39 <Sonarpulse> what would the class have initially? would there be two fails?
12:31:20 <nolrai66> Hmm.
12:31:28 <nolrai66> Thats a good question.
12:31:34 <kadoban> I guess initially it would just be empty, but you'd be warned if you used 'do' on Monads that aren't instances of it?
12:31:56 <dolio> I forget the exact path.
12:32:17 <dolio> Maybe it has newFail, and we default fail to newFail or something.
12:32:39 <dolio> Then eventually remove it from the class.
12:33:00 <bitemyapp> Iceland_jack: ping
12:33:04 <Sonarpulse> ok
12:33:12 <Iceland_jack> bitemyapp: pong
12:33:12 <Sonarpulse> well glad to hear it is in the works
12:33:16 <simpson> You could still use do-syntax without fail, right? You just couldn't have pattern matches that can fail.
12:33:23 <bitemyapp> Iceland_jack: any new developments w/ https://github.com/Icelandjack/Capabilities ?
12:33:31 <Sonarpulse> simpson: yes
12:33:42 <Iceland_jack> No no, busy with my thesis 
12:34:08 <kadoban> Yeah, I'm not really sure how that could work.
12:34:14 <bitemyapp> Iceland_jack: fair enough, what's your thesis on?
12:34:25 * hackagebot TypeNat 0.2.0.0 - Some Nat-indexed types for GHC  http://hackage.haskell.org/package/TypeNat-0.2.0.0 (alexvieth)
12:34:29 <Sonarpulse> though i'd love to see it if farther along still that would just trigger a normal no pattern matched exception
12:34:37 <Lis> if i have a sourcefile bla.hs and want to run it's main function from ghci how do i do that?
12:34:40 <Lis> ah runhaskell
12:34:41 <Lis> sry
12:35:12 <arkeet> you can load it in ghci and just type "main"
12:35:15 <Sonarpulse> do you want a shell? or just interpret the program?
12:35:35 <Sonarpulse> or :main
12:35:37 <arkeet> but runghc/runhaskell is the thing to run it standalone yes
12:35:40 <arkeet> or that 
12:35:53 <Iceland_jack> Making an EDSL for cryptographic computations, that currently compiles to LLVM
12:36:05 <Sonarpulse> cool!
12:36:23 <athan> Iceland_jack: Like cryptol?! :O
12:36:30 <Iceland_jack> Similar to Cryptol yes
12:39:25 <fotanus> Is there a way to criss0build something on linux with cabal to windows?
12:39:34 <fotanus> Is there a way to cross-build* something on linux with cabal to windows?
12:40:21 <geekosaur> no
12:40:41 <fotanus> ok, thank you!
12:40:43 <geekosaur> current cross-building is a hack involving llvm, and I think the tooling is not up to anything->windows?
12:41:56 <Iceland_jack> bitemyapp: Any updates on the book?
12:42:15 <Korri> Hello! Which parsing library has the best support for error handling?
12:42:54 <Korri> I like attoparsec, but It's <?> solution is rather crude :)
12:43:26 <fotanus> I'm using alex and happy and the error handling is not that cool
12:43:41 <Dynetrekk> https://gist.github.com/anonymous/9155d4dde0b5091bbb03 <- why the type error?
12:45:20 <geekosaur> include the full error in the paste?
12:45:35 <Korri> > read '1' :: Int
12:45:36 <lambdabot>      Couldn't match type ‘Char’ with ‘[Char]’
12:45:37 <lambdabot>      Expected type: String
12:45:37 <lambdabot>        Actual type: Char
12:45:46 <Korri> Dynetrekk: Here you have an answer
12:45:49 <Dynetrekk> geekosaur: that was the error?
12:46:11 <Dynetrekk> Korri: so "10" is [Char] but I want String ?
12:46:13 <geekosaur> no any time you're asking about what some error is or why it's happeninbg, you should include the full error
12:46:28 <Dynetrekk> geekosaur: it's there as a comment? in the gist?
12:46:29 <Korri> Dynetrekk: You are trying to feed read function with string *elements* and they are Char
12:46:40 <geekosaur> because what I see here might not be what you see there due to different compiler versions, source you haven't included that might lead to odd type inference, etc.
12:46:46 <Dynetrekk> Korri: ...oh.
12:46:54 <Dynetrekk> Korri: heh, what do I do?
12:47:21 <geekosaur> but yes, you're trying to use read :: Read a => String -> a but in place of a String you have Char
12:47:26 <geekosaur> one possibility is
12:47:31 <geekosaur> @index digitToInt
12:47:32 <lambdabot> Data.Char
12:47:56 <geekosaur> another is to promote the Char back to a String: read (digit:[])
12:48:17 <nolrai66> Also writen read ([digit])
12:49:12 <Korri> Dynetrekk: Or you can use ord function from Data.Char to convert char to it's ASCII code and substract ASCII code of '0' char
12:49:16 <indiagreen> how come @index doesn't know where Applicative is?
12:49:19 <indiagreen> @index Applicative
12:49:19 <lambdabot> bzzt
12:49:38 <Dynetrekk> Korri: that sounds clean? map Data.Char.ord "10" ?
12:50:15 <Korri> > map (subtract (ord '0') . ord) "123"
12:50:16 <lambdabot>  [1,2,3]
12:51:20 <Dynetrekk> Korri: what was wrong with my solution?
12:51:49 <Korri> Dynetrekk: Types were not matching
12:52:00 <Dynetrekk> Korri: right
12:52:03 <Korri> > :t map
12:52:05 <lambdabot>  <hint>:1:1: parse error on input ‘:’
12:52:07 <Korri> :t map
12:52:08 <lambdabot> (a -> b) -> [a] -> [b]
12:52:16 <Dynetrekk> Korri: I'm not getting why "10" is not [Char] ?
12:52:22 <nolrai66> It is.
12:52:26 <Korri> Dynetrekk: It is indeed :)
12:52:34 <Korri> :t read
12:52:35 <lambdabot> Read a => String -> a
12:52:44 <Dynetrekk> Korri: so map ord "10" should yield [1, 0] ?
12:52:46 <Korri> as you see read expects [Char] on the input
12:52:54 <hamid> :t "10"
12:52:55 <lambdabot> [Char]
12:53:05 <Korri> Dynetrekk: Not exactly
12:53:16 <Dynetrekk> Korri: sorry, the ascii codes, so [50, 49]
12:53:26 <Korri> Dynetrekk: Exactly :)
12:53:35 <Dynetrekk> Korri: it's late... here, anyway
12:53:37 <Dynetrekk> :)
12:54:08 <bitemyapp> Iceland_jack: yes, some fairly good news coming soon.
12:54:26 <geekosaur> Dynetrekk, the problem is that "10" is indeed String, but map over it looks at the individual Char-s, not String-s
12:54:29 <bitemyapp> Iceland_jack: practically staring at my email waiting for notice of a legal thing being resolved, then I'll be able to make an announcement.
12:54:40 <Iceland_jack> Glad to hear, keep me posted!
12:54:42 <Korri> Dynetrekk: That's why recommend using Data.Char.digitToInt :)
12:54:44 <geekosaur> and I will point again at digitToInt
12:54:49 <bitemyapp> Iceland_jack: hoping to get early access soon. We're testing with some more people now. Need a technical reviewer.
12:55:05 <Dynetrekk> Korri: ah, now there's my function :)
12:55:06 <Iceland_jack> I don't have a lot of time but I'd be happy to take a look
12:55:07 <bitemyapp> Iceland_jack: know anybody that has good knowledge of Haskell and GHC that would be interested in helping us check for technical errors?
12:55:17 <Dynetrekk> Korri: so str2Digits = map . digitToInt should do it
12:55:23 <bitemyapp> Iceland_jack: I didn't want to assume you had the time, given your thesis.
12:55:51 <luzie> > map (\c -> ord $ x - '0')  "123"
12:55:51 <Iceland_jack> I always have time to read some Haskell :) even if it cuts into my Haskell work. I also know some people that would definitely be interested
12:55:52 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘Expr’
12:55:52 <lambdabot>      In the first argument of ‘(-)’, namely ‘x’
12:55:52 <lambdabot>      In the second argument of ‘($)’, namely ‘x - '0'’
12:56:15 <Korri> Dynetrekk: Still types don't match. You don't like to compose map with digitToInt. You'd like to use digitToInt as an argument to map
12:56:21 <luzie> > map (\c -> ord $ c - '0')  "123"
12:56:21 <Korri> :t map digitToInt
12:56:22 <lambdabot> [Char] -> [Int]
12:56:23 <lambdabot>      No instance for (Num Char) arising from a use of ‘-’
12:56:23 <lambdabot>      In the second argument of ‘($)’, namely ‘c - '0'’
12:56:23 <lambdabot>      In the expression: ord $ c - '0'
12:56:25 <Dynetrekk> Korri: sorry, right
12:56:47 <Dynetrekk> Korri: I'm sometimes mixing partial application and composition. The syntax is still new to me
12:57:05 <geekosaur> luzie, if you're doing it your self, ord c - ord '0'
12:57:25 <ghorn> i have a haskell program which calls a C++ library which is not thread safe - want to call it a bunch of times in parallel
12:57:28 <Korri> Dynetrekk: It will become easier than you think soon :)
12:57:41 <ghorn> in python i'd use multiprocessing instead of multithreading and I'd be done, is there something like taht in haskell?
12:58:04 <Dynetrekk> Korri: it's getting better. It's going to be hell to go back to fortran after vacation
12:58:11 <ion> > ((-) `on` ord) '1' '0'
12:58:12 <lambdabot>  1
12:59:25 <Korri> Korri: Dynetrekk: I feel sorry for you :)
12:59:52 <Dynetrekk> Korri: my problems at work aren't with Fortran as a language 
13:00:04 <bitemyapp> Iceland_jack: I queried you, is there an email I should send a chapter for you to chew on?
13:00:29 <Korri> Dynetrekk: As what then?
13:00:49 <Iceland_jack> bitemyapp: sent it in PM
13:00:59 <Dynetrekk> Korri: my issue is with bad code; incidentally, written in fortran
13:01:06 <Dynetrekk> Korri: badcode in haskell would be better
13:01:16 <Dynetrekk> sorry, worse, I mean.
13:01:22 <Dynetrekk> since I don't know haskell ;)
13:01:27 <Lis> how can i get a sublist of a list? ziptest :: [[Int]] -> [[Int]] -> [[Int]] -> [[Int]] -> [[Int]]; ziptest la lb lc ld = zipWith4 (take 1) la lb lc ld is not working
13:02:48 <Lis> ziptest [[1,2],[3,4]] [[5,6],[7,8]] [[9,10],[11,12]] [[13,14],[15,16]] should return [[1,2],[5,6]...
13:02:53 <Korri> Dynetrekk: I never seen a code in haskell that I'd call "bad" :) Maybe It's because of learning curve?
13:02:57 <ion> > let ziptest :: [[Int]] -> [[Int]] -> [[Int]] -> [[Int]] -> [[Int]]; ziptest la lb lc ld = zipWith4 _ la lb lc ld in ziptest
13:02:58 <lambdabot>      Found hole ‘_’ with type: [Int] -> [Int] -> [Int] -> [Int] -> [Int]
13:02:58 <lambdabot>      Relevant bindings include
13:02:58 <lambdabot>        ld :: [[Int]] (bound at <interactive>:1:86)
13:03:27 <ion> lis: The hole has the type you see above. It needs to be a function that takes four lists and returns a list.
13:04:08 <Dynetrekk> Korri: well the Fortran I've seen makes my eyes bleed from 10 meters distance
13:04:29 <ion> > let ziptest :: [[Int]] -> [[Int]] -> [[Int]] -> [[Int]] -> [[Int]]; ziptest la lb lc ld = (zipWith4 . zipWith4) _ la lb lc ld in ziptest
13:04:30 <Dynetrekk> Korri: and it's not an easy language, but I guess much easier to pick up than haskell
13:04:31 <lambdabot>      Found hole ‘_’ with type: Int -> Int -> Int -> Int -> Int
13:04:31 <lambdabot>      Relevant bindings include
13:04:31 <lambdabot>        ld :: [[Int]] (bound at <interactive>:1:86)
13:04:33 <pharaun> ghorn: what do you mean by c++ library that is not thread safe, no way you can turn it into threadsafe?
13:04:44 <ion> Maybe you want a nested zip?
13:05:36 <Dynetrekk> pharaun: no worry if you're using processes instead of threads
13:05:50 <pharaun> ghorn: also um.. you have two mode of FFI, unsafe, and safe. you're wanting to multi-thread your access to that library. I think you can *pin* a FFI onto a particular thread (iirc) we do that for opengl)
13:07:35 <pharaun> http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Concurrent.html - forkOS is what you would want for this right?
13:07:38 <pharaun> ghorn: ^
13:09:00 <Lis> ion, how do i remove a [] from a [[]] ?
13:09:49 <ion> lis: You can flatten a list with concat, or you can access the sublists in the function you give to map or zipWith.
13:10:13 <ghorn> pharaun: no way I can turn it into thread safe, unfortunately, it's not my library
13:11:30 <ghorn> pharaun: i don't see how pinning my FFI call to a certain thread prevents that unsafe library from corrupting its static memory
13:14:38 <Lis> ion, ziptest la lb lc ld = zipWith4 (\a b c d -> [(head a),(head b),(head c),(head d)]) la lb lc ld ty :D
13:18:00 <ion> Lis: Note that head is a crash-prone function.
13:18:32 <Lis> yea, i know but for take 1 i get Couldn't match expected type `Int' with actual type `[Int]'
13:19:57 <Lis> also i want [1,2],[5,6] not [1,5]
13:21:41 <Dynetrekk> https://gist.github.com/Dynetrekk/9e3745c244d7840e58d8 <- wut?
13:21:56 <Dynetrekk> what is a Fractional Int and why is there no type arising from the use of / ?
13:22:04 <geekosaur> because (/) is not implemented on Int
13:22:19 <Zemyla> Oh wow, I don't have to pass around a custom comparsion operator anymore.
13:22:30 <geekosaur> only on types that support fractions (thus Fractional)
13:22:54 <Dynetrekk> geekosaur: so my type declaration is crap? anyway I do know that n is even?
13:22:56 <geekosaur> `div` works on Int and drops the remainder (there is also `mod` and `divMod`)
13:23:46 <geekosaur> "I know it is even" does not matter, that would require dependent types
13:24:01 <geekosaur> you probably want `div` there
13:24:03 <Dynetrekk> geekosaur: so the / is not the / in e.g. C where you discard the remainder? got it
13:24:10 <Dynetrekk> geekosaur: right, because I know it's OK
13:24:23 <geekosaur> right, divide-exctly and divide-discarding-remainder are different things in Haskell
13:24:27 * hackagebot stackage-cli 0.1.0.2 - A CLI library for stackage commands  http://hackage.haskell.org/package/stackage-cli-0.1.0.2 (DanBurton)
13:24:41 <geekosaur> (/) is divide-exactly and only is defined on types that support it (members of class Fractional)
13:24:57 <Dynetrekk> geekosaur: what about float?
13:25:14 <geekosaur> @instances Fractional
13:25:16 <lambdabot> CReal, Complex a, Double, Expr, Float, Interval a, Ratio a, Sym a
13:25:33 <Dynetrekk> geekosaur: actually I do like that / is not "discard" because I spend 3 weeks looking for a bug (n + 1) / n... :P
13:26:10 <Dynetrekk> geekosaur: oooh, mathematical intervals exist in haskell? my inner mathematician is happy
13:26:31 <geekosaur> some things exist in lambdabot that won't be in a stock ghc installation
13:26:34 <Lis> Couldn't match expected type `Int' with actual type `[a0]' ?? i dont undestand that error ziptest2 la lb lc ld = zipWith4 (\a b c d -> [---here-(concat (take 1 a))-here-----,(head b),(head c),(head d)]) la lb lc ld
13:27:33 <ion> Lis: “take 1 a” has the type [Int], concat expects a list of lists.
13:27:35 <ion> @type concat
13:27:36 <lambdabot> Foldable t => t [a] -> [a]
13:27:47 <ion> @type concat `asAppliedTo` (undefined :: [[a]])
13:27:48 <lambdabot> [[a]] -> [a]
13:30:15 <Lis> hm but ziptest2 la lb lc ld = zipWith4 (\a b c d -> [(take 1 a),(head b),(head c),(head d)]) la lb lc ld gives Couldn't match expected type `Int' with actual type `[Int]'
13:32:23 <ion> Lis: head b and take 1 a have a different type, you can’t put them into the same list.
13:33:52 <Lis> yes, thats what i tried first. but that gives me Couldn't match expected type `Int' with actual type `[Int]' 4 times
13:34:30 <Dynetrekk> what is the max function?
13:34:42 <erisco> Dynetrekk how do you mean?
13:34:51 <Lis> > max [1,2,3]
13:34:52 <lambdabot>  <[Integer] -> [Integer]>
13:35:21 <Dynetrekk> erisco: what does it do?
13:35:29 <erisco> why not start up ghci and find out?
13:35:57 <Dynetrekk> erisco: not sure how to do that. :t gives Ord a => a -> a -> a 
13:36:09 <Dynetrekk> don't know what an Ord is, except that it's something that can be ordered
13:36:12 <Dynetrekk> (pizza?)
13:36:53 <erisco> Dynetrekk take a look at the instances of Ord http://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Ord.html
13:37:05 <Lis> someone?
13:37:37 <Dynetrekk> erisco: ok, so Ord instances implement all those?
13:37:49 <Dynetrekk> operators and functions (not that they're much different in haskell)
13:37:52 <barrucadu> Lis: `take` gives  alist, `head` gives the first element. So you can't have a list [(take 1 a),(head b),(head c),(head d)]
13:37:59 <erisco> Dynetrekk they implement the compare function
13:38:29 <Lis> barrucadu, i know. i replaces every head with take. now i get the same freakin error just 4 times.
13:38:33 <Dynetrekk> erisco: right, that gives you everything else automagically?
13:38:34 <Lis> and i dont understand it.
13:38:51 <Lis> i mean the error and what it's meaning
13:38:59 <erisco> Dynetrekk if by everything else you mean >, <, ==, and other comparison operators, then yes, but it is not magic
13:39:13 <Lis> ziptest2 la lb lc ld = zipWith4 (\a b c d -> [take 1 a,take 1 b,take 1 c,take 1 d]) la lb lc ld 4x Couldn't match expected type `Int' with actual type `[Int]
13:39:54 <indiagreen> Lis: this last thing you pasted works for me
13:39:56 <barrucadu> :t \la lb lc ld -> zipWith4 (\a b c d -> [take 1 a,take 1 b,take 1 c,take 1 d]) la lb lc ld
13:39:57 <lambdabot> [[a]] -> [[a]] -> [[a]] -> [[a]] -> [[[a]]]
13:40:29 <Lis> o_O ?
13:40:43 <Lis> psbkac
13:40:59 <Herogx> Anyone able to tell me what is wrong with this function? http://lpaste.net/9047885222237962240
13:41:25 <glguy> Herogx: You're calling hClose on a handle after you called hGetContents
13:41:38 <Herogx> Yes, my intention is to return the entire file contents
13:42:02 <cite-reader> Oh boy a lazy IO problem.
13:42:12 <ion> Herogx: hGetContents sadly uses a hack called lazy IO which makes it not read the contents before the action finishes but instead when its result gets evaluated.
13:42:29 <Herogx> Ah I see
13:42:32 <glguy> Herogx: http://hackage.haskell.org/package/base-4.8.0.0/docs/System-IO.html#v:hGetContents
13:42:36 <Herogx> How would I go about fixing that?
13:42:43 <haasn> Isn't it wrong to use hClose in combination with lazy IO?
13:42:43 <ion> Herogx: You could drop the hClose, hGetContents will close the handle when the result is evaluated to the end of the file.
13:42:58 <Herogx> That will fix it ?
13:43:13 <Lis> ?!?!? now i do not understand anything anymore. if i remove ziptest2 :: [[Int]] -> [[Int]] -> [[Int]] -> [[Int]] -> [[Int]] it works
13:43:13 <lambdabot> Unknown command, try @list
13:43:14 <glguy> Herogx: your "get_raw_data" is just Prelude.readFile
13:43:29 <ion> Lis: See above: <lambdabot> [[a]] -> [[a]] -> [[a]] -> [[a]] -> [[[a]]]
13:43:32 <barrucadu> Lis: Because that type is wrong, look at the type lambdabot inferred
13:43:35 <Herogx> :| There is an inbuilt method for what I want :D?
13:43:44 <glguy> Herogx: But to fix your code as written you should not call hClose
13:43:47 <ion> Lis: The code is returning a list of lists of lists of something, not a list of lists of Int.
13:43:56 <Herogx> Sorry I'm coming from c++ and java...
13:44:01 <Dynetrekk> ok, why does this little program chew up all my RAM? https://gist.github.com/Dynetrekk/bf2c7200bca10793c80d
13:44:10 <Dynetrekk> and how do I avoid ghc eating all my RAM in general?
13:44:13 <Herogx> Standard to close all handles right away, I see what the issue is though I think
13:44:30 <erisco> Lis I think you may be trying to run before you can walk
13:45:02 <Lis> ah, ok so it's the "template" haskell thing. but how can i write that down explicitly? ziptest2 :: [[a]] -> [[a]] -> [[a]] -> [[a]] -> [[a]] doesnt work
13:45:24 <ion> Lis: If you want it to return [[Int]], you’ll need to edit the code to do that.
13:45:40 <Herogx> I removed the return and the hClose
13:46:07 <Herogx> And now I have an illegal end of do block issue, I understand that I can't assign something
13:46:12 <Herogx> which is what the original issue was
13:46:26 <Herogx> So how exactly to I go about setting that function equal to what came out of that file?
13:46:35 <erisco> Dynetrekk well maybe you should try less candidates
13:46:40 <geekosaur> Dynetrekk, you named `candidates` so it memoizes it, building a huge list and keeping it in memory
13:46:44 <Lis> ion, yes, but can i define a template type? like, i do not need to write [[Int]] but [[*]] ? to still use that function with explicit type declaration?
13:47:22 <Dynetrekk> geekosaur: one million items isn't that bad
13:47:45 <Dynetrekk> geekosaur: why does it memoize it? does it help if I do take 1e6 [1..] ?
13:48:13 <ion> Lis: There is a recent extension to allow holes in types, but i’m pretty sure that’s not what you’ll want here. If you just want to experiment with what the code returns, perhaps just comment out the type annotation temporarily.
13:48:21 <Herogx> or even if someone could show me how to format a function that takes in a filename and returns the result of readFile 
13:48:39 <Herogx> That'd be very much so appreciated, the positioning of a do block and all that is semi confusing still
13:48:43 <Dynetrekk> erisco: well I've got to try them all, eventually?
13:48:44 <ion> Herogx: yourFunction = readFile
13:48:51 <Dynetrekk> lazily would be great I think
13:48:58 <Herogx> welp I feel stupid now
13:49:37 <Lis> Herogx,  main = do; content <- readFile "somefile.txt"
13:50:01 <erisco> Dynetrekk laziness makes this difficult to reason about
13:50:01 <Dynetrekk> geekosaur: the take trick does not seem to work... I'm not getting why this isn't lazy and therefore OK
13:50:07 <Herogx> Haskell is appearing to be a far better language than I originally thought it to be lol
13:50:13 <Dynetrekk> erisco: how do I disable the laziness then? :P
13:50:27 <Dynetrekk> erisco: use a fold instead of the maximum function? I'm drawing a blank
13:50:44 <erisco> well you certainly want laziness is some parts
13:50:52 <geekosaur> Dynetrekk, the reason to name something is to share it. sharing implies some level of memoization because the compiler must assume there are other uses of the list
13:50:53 <erisco> for example you do not want the map collatzSequence to be strict
13:51:19 <geekosaur> (and it's not just a million items, because it's a linked list and it has constructor tags in it. lists are rather inefficient)
13:51:20 <Dynetrekk> erisco: I had no idea I was being strict
13:51:32 <erisco> Dynetrekk I did not say you were
13:51:36 <Dynetrekk> or what that means. my haskell-fu is limited :)
13:51:49 <Lis>  ziptest2 [[1,2],[3,4]] [[5,6],[7,8]] [[9,10],[11,12]] [[13,14],[15,16]] now gives me [[[1],[5],[9],[13]],[[3],[7],[11],[15]]] but i want [[1,2],[5,6],[9,10],[13,14]]       ziptest2 la lb lc ld = zipWith4 (\a b c d -> [(concat (take 1 a)),take 1 b,take 1 c,take 1 d]) la lb lc ld
13:51:59 <erisco> geekosaur but still I don't think you even get to half a GB
13:52:02 <erisco> with just that list
13:52:25 <Dynetrekk> erisco: machine has 600 MB RAM (ish)
13:52:29 <erisco> OH
13:52:32 <erisco> lol
13:52:36 <Dynetrekk> erisco: it's a VM
13:52:40 <Dynetrekk> ubuntu server
13:52:51 <Dynetrekk> works fine for most things :)
13:52:52 <erisco> how about bump up the RAM a bit
13:53:22 <Dynetrekk> erisco: too much hassle, and I want to learn - I should not write programs that use 1 GB RAM for this kind of stuff
13:53:33 <Dynetrekk> then I'd be better of writing in, well, any imperative language I've ever heard of
13:53:38 <ion> > let f ass bss css dss = take 1 (zipWith4 (\as bs cs ds -> [as, bs, cs, ds]) ass bss css dss) in f [[1,2],[3,4]] [[5,6],[7,8]] [[9,10],[11,12]] [[13,14],[15,16]]
13:53:39 <lambdabot>  [[[1,2],[5,6],[9,10],[13,14]]]
13:54:14 <erisco> Dynetrekk try inlining candidates for starters and see what happens
13:54:15 <Dynetrekk> 1e6 numbers should not use more than at most a few MB of RAM
13:54:35 <Dynetrekk> erisco: inlining? putting a literal instead of a variable? that does not sound elegant
13:54:42 <erisco> Dynetrekk but lists are linked lists, so you've also got a pointer with every integer
13:54:50 <geekosaur> and a constructor tag
13:54:51 <Dynetrekk> erisco: still not 100 MB
13:54:57 <erisco> and if this is x64 then your Ints and pointers are probably 8 bytes
13:54:58 <Dynetrekk> no idea about those :)
13:55:03 <erisco> so 16 bytes just for one number
13:55:12 <Dynetrekk> erisco: 16 MB << 600 MB
13:55:37 <erisco> add on GC overhead
13:55:56 <erisco> but it isn't like we're asking for a complicated experiment here lol
13:55:59 <erisco> just try it
13:56:01 <Lis> ion, finally. thank you. now i can get 30min of rest
13:56:47 <Dynetrekk> erisco: parse error on input ]
13:56:49 <Dynetrekk> wtf
13:56:51 <erisco> geekosaur is the constructor tag part of this info pointer thing people were telling me about?
13:56:59 <erisco> Dynetrekk fix your syntax?
13:57:08 <geekosaur> @src Int
13:57:08 <lambdabot> data Int = I# Int#
13:57:12 <Dynetrekk> https://gist.github.com/Dynetrekk/bf2c7200bca10793c80d
13:57:15 <Dynetrekk> erisco: what's wrong?
13:57:15 <geekosaur> I# is the constructor tag
13:57:32 <Dynetrekk> erisco: sorry, my bad I screwed up something else
13:57:51 <Dynetrekk> erisco: also, did not help a bit (much less a byte)
13:58:14 <erisco> okay, well we'll try to knock down the pins one by one
13:58:17 <geekosaur> in machine internal form as ghc uses it it will be 64 bits, value 0 because there's only one constructor. for Integer there are two (S#, J# IIRC)
13:59:27 <geekosaur> so each Int is 16 bytes and each cons cell is 24 bytes
14:00:05 <geekosaur> (constructor tag for (:), pointer to Int, pointer to next list element)
14:00:08 <Dynetrekk> if I write a foldr over the candidates, will that create an equvalent of a loop, thus storing only the lengths, i.e. 1e6 integers?
14:01:02 <erisco> Dynetrekk what if you try   map (length . collatzSequence)  instead?
14:01:20 <erisco> I am not sure where it is getting hung up but it'd be interesting to see if that helps at all
14:01:31 <lifter> Does anyone know of tutorials on how to use mwc-random or tf-random?
14:02:38 <erisco> how does the GC know when to collect? does the OS send a signal for low on memory?
14:03:08 <Dynetrekk> erisco: nah, the OS says "fuck you, no memory for you" all of a sudden when trying to access memory that you've allocated long ago
14:03:24 <Dynetrekk> when you're accessing a virtual memory page that there's no physical memory for
14:04:07 <erisco> maybe the GC needs to be tuned for your memory limit? hm, I have no idea
14:04:24 <erisco> did the last change I suggested do anything?
14:04:39 <cite-reader> It might be a good idea to hit the program with a memory profiler, instead of flailing.
14:05:03 <Dynetrekk> erisco: does not look like it, but would make sense to me, if run in an imperative language
14:05:29 <erisco> well because of laziness I would not think it would make a difference
14:05:41 <Dynetrekk> erisco: right
14:05:43 <erisco> also there is probably an optimisation rule that changed it to map (length . collatzSequence) already
14:06:05 <Dynetrekk> erisco: sounds reasonablish for a noob like me, at least
14:07:05 <Dynetrekk> https://gist.github.com/Dynetrekk/bf2c7200bca10793c80d <- erisco new idea, no dice
14:07:21 <Dynetrekk> erisco: bah, the max function makes no sense btw.
14:07:29 <erisco> Dynetrekk well that'd be awful
14:07:30 <Dynetrekk> or does it?
14:07:32 <erisco> Dynetrekk you would want to use foldl'
14:07:35 <Dynetrekk> erisco: I'm sure :)
14:07:41 <Dynetrekk> foldl' ? what's that
14:07:45 <erisco> a strict version
14:07:50 <Dynetrekk> ah
14:08:22 <Dynetrekk> not in scope
14:08:53 <johnw> import Data.List (foldl')
14:11:03 <Dynetrekk> johnw: thanks
14:11:39 <cite-reader> Oh wow compiling with -O made that program go down to 1 MB in use.
14:12:05 <Dynetrekk> erisco: foldl' did no good
14:12:14 <cite-reader> Dynetrekk: Are you compiling with optimizations?
14:12:18 <erisco> I wouldn't expect it to if the maps were not helping either
14:12:42 <Dynetrekk> https://gist.github.com/Dynetrekk/bf2c7200bca10793c80d <- erisco newest version
14:12:46 <Dynetrekk> erisco: damn maps
14:12:54 <Dynetrekk> I took them out though
14:13:15 <torulv> Hey, I'm getting this error "cannot satisfy -package ide-backend-rts" yet this package is installed.
14:13:21 <torulv> What could be the issue?
14:13:34 <torulv> It is a library.
14:14:24 <erisco> what is this -H GC flag? where do you pass it?
14:15:17 <erisco> does your program executeable magically recognize them? ...
14:15:30 <lpaste> Giggaflop pasted “Coding practice” at http://lpaste.net/132124
14:15:43 <Dynetrekk> is there a strict version of map?
14:15:53 <Giggaflop> Hey, i'm trying to get to grips with haskell 
14:15:57 <glguy> Dynetrekk: No, and you wouldn't want one for this exercise
14:16:03 <Giggaflop> and i'm having issues reading part of this code
14:16:17 <glguy> map being lazy is why you can use it in this context efficiently
14:16:28 <torulv> erisco: You talking to me?
14:16:34 <Dynetrekk> glguy: hm. I think I should go to bed. if I can't count to 1 using 600 MB of RAM then I shouldn't be coding
14:16:36 <erisco> torulv if you know the answer
14:16:44 <Giggaflop> i'm trying to understand what the import Data.Conduit (($$+-)) means
14:16:51 <glguy> Dynetrekk: It sounds like you aren't compiling with optimizations
14:16:54 <torulv> erisco: I don't think you are. :(
14:16:59 <Dynetrekk> glguy: runhaskell foo.hs ?...
14:17:01 <glguy> or that you're doing something  you aren't showing us
14:17:03 <erisco> Dynetrekk just a shot in the dark, what if you run with  -H400M  ?
14:17:12 <glguy> Dynetrekk: Yeah, runhaskell is the problem, that runs it interpreted
14:17:14 <Dynetrekk> glguy: sorry, I should be wearing my noob hat
14:17:17 <mauke> Giggaflop: it imports the $$+- operator from the Data.Conduit module
14:17:26 <erisco> maybe that is a ghc flag so try it on there to
14:17:27 <glguy> Dynetrekk: use: ghc -O2 YourProgram.hs
14:17:30 <Giggaflop> what does that operator do? :s
14:17:36 <mauke> Giggaflop: no idea
14:17:43 <Giggaflop> fair enough XD
14:17:46 <hiptobecubic> I thought -O2 was mostly pointless over the default of -O ?
14:17:47 <glguy> Dynetrekk: this code runs in very little space when compiled and optimized
14:17:54 <mauke> Giggaflop: http://hackage.haskell.org/package/conduit-1.2.4.2/docs/Data-Conduit-Internal.html#v:-36--36--43--45-
14:17:58 <mauke> here's the documentation
14:17:58 <glguy> hiptobecubic: that's not really relevant in this context
14:18:08 <Giggaflop> thanks mauke 
14:18:10 <Dynetrekk> glguy: so you're saying my code was not written by a moron?
14:18:26 <Giggaflop> uhhhh
14:18:29 <glguy> Sure, and also that it will execute more efficiently when you compile it :)
14:18:33 <Giggaflop> still confused XD
14:18:33 <erisco> Dynetrekk oh wait, do  ./a.out +RTS -H400M -RTS
14:18:37 <hiptobecubic> Dynetrekk, well he's saying that that's not the issue :)
14:18:55 <Dynetrekk> erisco: I didn't  do that but it uses 0.5% memory now
14:19:04 <erisco> with -O2 ?
14:19:24 <Dynetrekk> erisco: sure
14:19:32 <erisco> what do you mean "sure"
14:19:34 <Dynetrekk> foldl' though
14:19:38 <Dynetrekk> erisco: used -O2
14:19:42 <erisco> okay
14:19:42 <cite-reader> \o/ Hail the optimizer!
14:19:47 <lpaste> glguy pasted “for dynetrekk” at http://lpaste.net/132125
14:19:54 <erisco> I guess there are some super important things in the optimizer lol
14:20:06 <glguy> Dynetrekk: Instead of creating the intermediate list you weren't using, you can also just compute the length like so
14:20:19 <Giggaflop> mauke, http://lpaste.net/132124  can you explain what the last line is doing? I'm trying to get the contents of the file grabbed by S3.GetObject to then compare with local_backup_version
14:20:35 <Dynetrekk> glguy: probably a better idea
14:20:46 <Giggaflop> but i'm starting with an example from the S3 lib
14:20:53 <Giggaflop> and it's a bit too advanced for me
14:20:54 <mauke> Giggaflop: sorry, I've never used conduits
14:21:00 <erisco> that seems weird to me though that the optimizer is needed
14:21:01 <Giggaflop> fair enough :)
14:21:19 <erisco> what is it doing so wrong without it
14:21:35 <Dynetrekk> is there an "argmax" function for List?
14:21:39 <glguy> erisco: It might just be the difference in the interpreter and compiler
14:22:04 <Dynetrekk> glguy: most compilers optimize even without optimization enabled, I think
14:22:06 <erisco> I'd also like to know if the -H flag would do anything to help
14:22:13 <Giggaflop> anyone here used conduits?
14:22:40 <Mark-OLK> nop
14:22:56 <Giggaflop> damn
14:23:11 <Giggaflop> maybe i'm being too ambitious
14:23:12 <erisco> but I suspect the unoptimised version found a way to keep all the memory alive
14:23:19 <erisco> for no darn good reason
14:24:17 <Dynetrekk> I have to sleep. thanks for an enjoyable evening guys. Be lazy
14:25:43 <athan> There's no way to write case statements for lambda literals, is there?
14:25:59 <athan> besides using `case`, I mean - pattern matching with lambda literals
14:26:02 <erisco> athan what do you mean? \x -> case x of ...
14:26:06 <Dynetrekk> erisco: now map and maximum behaves nicely too, when I'm using ghc -O2. good night
14:26:21 <glguy> Dynetrekk: "argmax" would be something like: maximumOn f xs = fst (maximumBy (comparing snd) [ (x, f x) | x <- xs ])
14:26:29 <athan> erisco: More like `\Foo -> .. || \Bar -> ...`
14:26:31 <glguy> assuming I'm interpretting what you wanted correctly
14:26:32 <athan> or something :S
14:26:43 <erisco> Dynetrekk I find this result unsettling nonetheless
14:27:11 <frerich> athan: There is a language extension called 'LambdaCase' which lets you write '\case foo -> x; bar -> y'
14:27:28 <erisco> athan no I don't think so, this is one of the places where Haskell is syntactically daft
14:27:32 <athan> frerich: oh woah! Thank you!
14:27:58 <erisco> \x -> let f Foo = ...; f Bar = ...; in f x
14:28:04 <erisco> that requires no extension
14:28:27 <mauke> why lambda then?
14:28:59 <arkeet> let { f Foo = ...; f Bar = ... } in f
14:29:07 <erisco> mauke for giggles
14:29:29 <arkeet> I think I'd rather use lambda with case though
14:29:45 <arkeet> or LambdaCase
14:29:53 <torulv> How can one fix a "cannot satisfy package" error in haskell?
14:29:58 <erisco> the way Haskell has pattern matching left of = and guards and so forth, it is all odd
14:30:31 <erisco> well not left of =, particularly for named functions
14:31:04 <Cale> What?
14:31:13 <erisco> and pattern matching in guards, and active patterns, and...
14:31:18 <kadoban> erisco: I don't really understand what you're talking about at all.
14:31:19 <glguy> torulv: There's no generic answer. You'll have to provide more information.
14:31:24 <erisco> lambda cases too I see :P
14:31:46 <erisco> neg True = False; neg False = True
14:31:56 <erisco> the pat matches on True and False left of the =
14:31:58 <Cale> erisco: What's odd about that?
14:32:05 <erisco> because there is also case
14:32:08 <Cale> It seems perfectly reasonable to me.
14:32:32 <erisco> a named function has different syntax than an unnamed one
14:32:46 <arkeet> lambda and case just use -> instead of =
14:34:06 <erisco> you ought to be able to just a function a name without changing a thing, and vice versa
14:34:28 <torulv> glguy: I expect the output described here: https://github.com/fpco/ide-backend/tree/master/ide-backend#hello-world however the output/error I get is https://gist.github.com/urbanslug/6c9c494b713edca3ebce
14:34:32 <erisco> which you can do, if you write    neg = \x -> case x of True -> False; False -> True
14:34:34 <Herogx> How do you apply the "lines" function to an IO String?
14:34:44 <Iceland_jack> > fmap lines getLine
14:34:45 <lambdabot>  <IO [[Char]]>
14:34:47 <erisco> but named functions have a bunch of extra features which break this
14:34:55 <Herogx> ah I see that makes sense
14:35:09 <Iceland_jack> Also ... since (<$>) = getLines
14:35:09 <Iceland_jack> > lines <$> getLines
14:35:10 <lambdabot>      Not in scope: ‘getLines’
14:35:11 <lambdabot>      Perhaps you meant one of these:
14:35:11 <lambdabot>        ‘getLine’ (imported from Prelude),
14:35:11 <Herogx> so then the IO part is something like a wrapper?
14:35:14 <kadoban> erisco: *shrug* it's not going to change, you'll just have to deal with the … huge problem that that doesn't seem to be.
14:35:31 <glguy> torulv: The line above that says "In order to use this package, you must have the ide-backend, ide-backend-server, and ide-backend-rts packages installed.". Do you have those installed?
14:35:31 <Iceland_jack> oops!
14:35:33 <arkeet> :t lines <$> getLine
14:35:34 <lambdabot> IO [String]
14:35:35 <Iceland_jack> Also ... since (<$>) = fmap
14:35:35 <Iceland_jack> > lines <$> getLine
14:35:37 <lambdabot>  <IO [[Char]]>
14:35:43 <erisco> kadoban I never said it was a huge problem, did I
14:35:45 <kadoban> Herogx: IO a  is a value that means "If you execute me, I'll give you an 'a'". It's kind of like a recipe for an 'a'
14:35:45 <arkeet> not that that makes any sense to do.
14:35:46 <Iceland_jack> Apologies, need some sleep
14:35:50 <arkeet> since getLine gives a single line.
14:35:56 <Herogx> Yea that makes sense
14:36:07 <Herogx> Sorry I'm new to the whole monad/pure/impure concept
14:36:07 <torulv> glguy: I do
14:36:08 <arkeet> @where /bin/ls
14:36:08 <lambdabot> I know nothing about /bin/ls.
14:36:12 <arkeet> @quote /bin/ls
14:36:12 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
14:36:24 <torulv> glguy: Why would it say that it can't satify an installed package?
14:36:31 <Denommus> Herogx: do you understand typeclasses well?
14:36:56 <Herogx> Well enough, I can't focus on them right now, sort of destroyed with assignments and my haskell project is one of them
14:37:05 <glguy> torulv: Maybe because it's running in a sandbox or some other alternate package config file
14:37:11 <Herogx> I plan on spending the summer figuring out most of this stuff though
14:37:31 <Denommus> Herogx: well, monads are types that implement the Monad typeclass and must follow some rules
14:38:21 <arkeet> most monads are IO, and an understanding of monads in general is not necessary to use IO.
14:38:29 <arkeet> most monads are *not* IO.
14:38:31 <erisco> A monad is the warm summer breeze across your cheek
14:38:49 <torulv> glguy: I am doing everything in a sandbox
14:38:49 <Herogx> Hm
14:38:50 <arkeet> :t return
14:38:51 <lambdabot> Monad m => a -> m a
14:38:52 <arkeet> :t (>>=)_
14:38:53 <Herogx> I curious then
14:38:53 <lambdabot>     Found hole ‘_’ with type: m a
14:38:53 <lambdabot>     Where: ‘m’ is a rigid type variable bound by
14:38:53 <lambdabot>                the inferred type of it :: (a -> m b) -> m b at Top level
14:38:53 <arkeet> :t (>>=)
14:38:54 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:38:55 <Herogx> why does 
14:38:57 <arkeet> just pretend m is IO here.
14:38:59 <torulv> glguy: How could that be the issue?
14:39:16 <torulv> How can I add an installed library to PATH?
14:39:24 <glguy> torulv: Whatever the ide-backend is trying to do probably doesn't know about your sandbox and therefore doesn't find any of the packages you installed
14:39:29 <Herogx> func fname = fmap lines $ readFile $ "dir/" ++ fname 
14:39:36 <Herogx> Work without the getLine method?
14:40:06 <Herogx> oh wait did you assume I meant a string list?
14:40:10 <glguy> torulv: You might try running the ide command with: cabal exec
14:40:33 <glguy> torulv: Otherwise someone else will have to help you, I try to avoid working in sandboxes
14:41:04 <Denommus> Herogx: getLine takes a line from stdin. readFile lazily reads a file, fmap lines takes the content of readFile and divides it in lines
14:41:14 <torulv> What do you mean by running the ide command with cabal exec?
14:41:19 <arkeet> cabal exec ide
14:41:20 <arkeet> or whatever
14:41:25 <torulv> glguy: I'm not familiar with cabal exec
14:41:39 <torulv> arkeet: Cabal exec? Gotta google this
14:41:44 <glguy> torulv: instead of running ./my-executable my-arguments
14:41:51 <glguy> you run: cabal exec ./my-executable my arguments
14:41:55 <arkeet> cabal exec runs any program you like, except sets up some ghc environment variables to point to your sandbox.
14:42:00 <glguy> and it sets up the environment
14:42:05 <arkeet> see: cabal help exec
14:42:09 <Denommus> Herogx: so there's no need why you'd use getLine together with readFile
14:42:16 <Denommus> s/no need/no reason/
14:43:42 <alohum> I have a question about XML parsing in Haskell. I'm trying to use the "xml" package to parse files that are about 300MB in size. Is this package capable of doing this?
14:43:52 <Herogx> Wait a second, so then an IO String is a functor that map would not work on, hence use of fmap?
14:44:00 <alohum> As a test, I've got the one-liner: fmap parseXML (L.readFile "test.gpx") >>= print . length. This takes FOREVER to parse even a 50MB file.
14:44:25 <arkeet> :t map
14:44:26 <lambdabot> (a -> b) -> [a] -> [b]
14:44:29 <arkeet> map is specifically for mapping over lists.
14:44:29 * hackagebot etcd 1.0.4 - Client for etcd, a highly-available key value store  http://hackage.haskell.org/package/etcd-1.0.4 (wereHamster)
14:44:43 <arkeet> :t fmap
14:44:44 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:44:59 <arkeet> IO is a Functor, so fmap can map over IO.
14:45:09 <Iceland_jack> :t fmap :: (a -> b) -> IO a -> IO b
14:45:11 <lambdabot> (a -> b) -> IO a -> IO b
14:45:28 <Iceland_jack> :t fmap :: (String -> [String]) -> IO String -> IO [String]
14:45:29 <lambdabot> (String -> [String]) -> IO String -> IO [String]
14:45:33 <ivanchuk> hi all
14:45:45 <ivanchuk> what the difference between forall a. a and just a ?
14:46:23 <ivanchuk> for type signature I meant
14:46:58 <arkeet> nothing, if that's the entire type. 
14:47:05 <arkeet> (unless you have ScopedTypeVariables, at least.)
14:47:20 <erisco> alohum are there other libraries which do it faster?
14:47:26 <arkeet> there is a pretty big difference between a -> b and (forall a. a) -> b
14:47:34 <arkeet> for example
14:47:43 <ivanchuk> whats the difference ?
14:48:04 <alohum> @erisco Can you recommend any?
14:48:04 <lambdabot> Unknown command, try @list
14:48:07 <ivanchuk> for instance between forall a. a -> a and a -> a
14:48:25 <erisco> alohum no, I was just wondering if one should expect to parse a 50MB XML file quickly
14:48:42 <arkeet> there is always an implicit forall around the entire type if you have any free variables.
14:49:26 <arkeet> so f :: a -> a and f :: forall a. a -> a
14:49:29 <arkeet> are the same thing
14:50:09 <alohum> Why would I not expect XML parsing to be so slow that 50MB is too much?
14:50:45 <ivanchuk> I'm playing around with the type inference algorithm
14:50:53 <erisco> alohum how slow are you talking about?
14:50:55 <arkeet> alohum: xml parses the entire xml file into a huge data structure.
14:51:09 <arkeet> which will generally be a lot larger than the xml file itself.
14:51:44 <ivanchuk> and I do not why the substitution ignores forall clauses, for instance: [b/a] a -> a = b -> b
14:52:01 <ivanchuk> but [b/a] forall a. a -> a = forall a. a -> a
14:52:04 <arkeet> ivanchuk: because forall binds variables.
14:52:23 <alohum> erisco: I ran the one-liner I had (fmap parseXML (L.readFile "test.gpx") >>= print . length) on a 50MB file and waited 5 minute, and it never finished. But I know it works because if I run it on a 10K file, it does finish.
14:52:38 <ivanchuk> oh
14:53:12 <ivanchuk> it seems right then
14:53:21 <erisco> alohum I guess it is not efficient enough
14:53:34 <alohum> erisco: It just churns away with the cpu at 100%. Presumably that means it's working through it. I ran the same file through a Python script and it finished in about 20 seconds.
14:54:13 <alohum> erisco: It's got to be something else wrong. Otherwise, it not that it's not efficient. It's just broken.
14:54:30 <ivanchuk> mmm and why would we ever need forall a. a -> a ?
14:54:32 <arkeet> how much memory does it use?
14:55:22 <ivanchuk> is it related to generalization and instantiation of types ?
14:56:22 <ivanchuk> I'm pretty confused... If you have any reference to this question in the context of type inference, it would be great
14:56:30 <alohum> erisco: So, perhaps a related question is: What is a Haskell XML library that is considered fast?
14:56:40 <arkeet> you could consider using haxml
14:58:29 <alohum> arkeet: Okay. Thanks for the suggestion.
15:00:30 <seagreen> Is there a built in function to check `\c -> elem c (['a'..'z'] <> ['A'..'Z'])`? If I'm reading Data.Char.isAlpha correctly, it allows through more than that.
15:01:17 <shachaf> No built-in function.
15:01:19 <arkeet> isAsciiUpper c || isAsciiLower c
15:01:27 <shachaf> You might be able to get away with isAscii c && isAlpha c
15:01:29 <shachaf> Or that.
15:01:31 <arkeet> or that.
15:03:13 <seagreen> Sweet, thanks arkeet and shachaf.
15:03:41 <shachaf> Another approach would be (\c -> (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
15:07:54 <erisco> > let isAlpha c = ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') in map isAlpha "ah3fDj-e_I"
15:07:54 <lambdabot>  [True,True,False,True,True,True,False,True,False,True]
15:07:57 <arkeet> let o = ord c in (o-1) .&. 0x20 < 26 && o .&. complement (0x3f) == 0x40
15:07:57 <arkeet> or something.
15:07:57 <arkeet> unnecessary parentheses.
15:09:48 <arkeet> of course I meant 0x1f, not 0x20
15:10:23 <jle`> of course
15:12:18 <lambdafan> sanity check question
15:12:54 <lambdafan> I'm looking to generate a hamiltonian r-regular biparite graph.
15:13:13 <lambdafan> n < 50
15:14:11 <lambdafan> I thought I should start with a complete biparite graph, make a tree of all potential hamiltonian cycles
15:15:01 <lambdafan> and then make a new graph from that tree
15:15:32 <lambdafan> the new graph would not be complete, but would be hamiltonian
15:16:20 <lambdafan> Since the order is so small, I didn't think I should bother with the fancy algorithms I've been reading about which seem to be intended for graphs of much higher order
15:17:53 <lambdafan> but is the graph->tree->graph approach sane? I'd like to end up with a 3-regular hamiltonian bipartite graph, order of 50.
15:18:00 <lambdafan> or 49, if it has to be odd
15:18:54 <lambdafan> err 48, if the vertex sets should be even, 50 if they should be odd
15:18:59 <lambdafan> I need to look that up
15:19:30 * hackagebot stackage-sandbox 0.1.1 - Work with shared stackage sandboxes  http://hackage.haskell.org/package/stackage-sandbox-0.1.1 (DanBurton)
15:24:34 * hackagebot usb 1.3.0.3 - Communicate with USB devices  http://hackage.haskell.org/package/usb-1.3.0.3 (BasVanDijk)
15:25:12 <hexagoxel> why does a package need a Setup.hs when build-type==Simple?
15:25:29 <arkeet> so you can build it without cabal-install
15:28:38 <hexagoxel> arkeet: ah ty
15:29:34 * hackagebot stackage-setup 0.0.1 - An executable for downloading a Haskell setup  http://hackage.haskell.org/package/stackage-setup-0.0.1 (DanBurton)
15:34:38 * hackagebot stackage-cabal 0.1.1 - A CLI executable for cabal-based stackage commands  http://hackage.haskell.org/package/stackage-cabal-0.1.1 (DanBurton)
15:34:40 * hackagebot activehs-base 0.3.0.3 - Basic definitions for activehs  http://hackage.haskell.org/package/activehs-base-0.3.0.3 (lspitzner)
15:39:38 * hackagebot dia-functions 0.2.1.4 - An EDSL for teaching Haskell with diagrams - functions  http://hackage.haskell.org/package/dia-functions-0.2.1.4 (lspitzner)
15:39:40 * hackagebot data-pprint 0.2.4 - Prettyprint and compare Data values  http://hackage.haskell.org/package/data-pprint-0.2.4 (lspitzner)
15:39:42 * hackagebot dia-base 0.1.1.3 - An EDSL for teaching Haskell with diagrams - data types  http://hackage.haskell.org/package/dia-base-0.1.1.3 (lspitzner)
15:42:39 * lspitzner more ghc-7.10 compatability, yay!
15:44:11 <athan> wew!
15:44:29 <torulv> glguy: Hey. Are you still around?
15:45:16 <pharaun> ghorn: went away for a while, anyway what do you mean, you setup some form of gating (mutex/etc for accessing the library) and pin it to a certain os thread?
15:58:07 <torulv> What causes `cannot satisfy -package` error for an installed package?
15:58:16 <torulv> Also how can one add a library to PATH?
15:59:39 * hackagebot proton-haskell 0.2 - Simple XML templating library  http://hackage.haskell.org/package/proton-haskell-0.2 (jrbriggs)
15:59:41 * hackagebot stackage 0.7.3.2 - Dummy package forcing installation of other Stackage packages  http://hackage.haskell.org/package/stackage-0.7.3.2 (DanBurton)
16:00:45 <Cale> torulv: To the first question -- any number of things could be going wrong. What command are you running which gives that in the first place?
16:01:02 <Cale> torulv: To the second question, I have no idea why you'd want to do that.
16:01:54 <torulv> I expect the output described here: https://github.com/fpco/ide-backend/tree/master/ide-backend#hello-world however, the output/error I get is: https://gist.github.com/urbanslug/6c9c494b713edca3ebce
16:01:58 <torulv> Cale: ^
16:02:00 <Cale> torulv: The PATH environment variable lists places that your shell will look for executables when you type a command. Since libraries are not executable, there's no need to add their paths to that variable.
16:02:23 <torulv> Cale: Because I want to satisfy this package/library.
16:02:40 <Cale> Did you try -v?
16:02:48 <torulv> Cale: How do I run -v?
16:02:52 <torulv> Cale: Where?
16:03:07 <torulv> Because I ran the function in the repl
16:03:44 <Cale> Oh, I see, you're running code which in turn uses GHC
16:04:10 <Cale> Maybe try adding "-v" to the list that gets passed to updateGhcOpts there?
16:04:55 <torulv> Cale: On it.
16:06:00 <Cale> Also, just for sanity's sake, check the output of  ghc-pkg list ide-backend-rts
16:07:46 <torulv> Cale: It didn't help.
16:07:57 <torulv> Cale: I checked it. It lists ide-backend-rts
16:09:04 <torulv> Cale: I'm using a sandbox but I doubt the sandbox is the issue because the first time I got this error I wasn't using a sandbox so I deleted even my ~/.cabal and started everything over. Same thing.
16:10:18 <torulv> Cale: This is why I didn't want to share the problem at first.
16:10:20 <Cale> You should almost never have to delete ~/.cabal -- if things are messed up, you only really have to get rid of ~/.ghc
16:10:35 <torulv> Cale: I wanted you to come at it with an open mind.
16:10:43 <torulv> Cale: I also deleted ~/.ghc
16:11:05 <torulv> Cale: Why don't I have to delete my ~/.cabal?
16:11:06 <SrPx> How do I use the `ix` instance of Tree?
16:11:33 <dfeuer> SrPx, why does that even hav an Ix instance?
16:11:45 <Cale> torulv: Because it doesn't contain the information about which packages are installed.
16:11:48 <SrPx> dfeuer: Because you can access the nth child node...
16:12:17 <dfeuer> SrPx, no.
16:12:18 <torulv> Cale: So if I reinstall a reinstall will just overwrite whatever is in ~/cabal?
16:12:28 <Cale> yeah
16:12:33 <SrPx> No what?
16:12:42 <dfeuer> An Ix instance of Tree is kind of like an Ix instance for [], only hairier.
16:12:50 <dfeuer> Indexing arrays by trees....
16:12:53 <dfeuer> Whaaaaat?
16:13:11 <SrPx> Indexing arrays by trees? What are you talking about?
16:13:20 <SrPx> And list has an ix instance...
16:13:38 <Cale> SrPx: uh, not usually, it doesn't
16:13:55 <Cale> SrPx: Unless you managed to write one.
16:14:08 <napping> torulv: the .ghc directory has the files that tell ghc where to look for libraries
16:14:18 <napping> so if you deleted that, then stuff left in cabal probably doesn't affect it
16:14:56 <SrPx> I don't mean Ix. I mean Ixed. I'm sorry.
16:14:56 <napping> but .cabal is the directory holding your locally installed libraries
16:15:01 <cite-reader> Clearly, the Ix instance for lists should just interpret the list as a Peano number.
16:15:30 <torulv> Why does haskell package system get in the way of programming?
16:15:33 <torulv> WHY?
16:15:39 <Cale> Yeah, it holds the actual content of the locally installed libraries, but that won't do any harm just sitting there if it's not being referred to by the package configurations in ~/.ghc
16:15:57 <napping> Cale: still, if you delete the configuration in .ghc they are pretty much garbage
16:16:12 <Cale> torulv: It's usually not so bad, but the reason that package systems are hard in general is that it's difficult to compute package version constraints.
16:16:25 <Cale> torulv: (for the people who make the packages in the first place)
16:16:32 <geekosaur> torulv, because haskell libraries use cross-module inlining because it's the only way to get anything like reasonable performance. but it means every library build is a special snowflake
16:16:33 <Cale> napping: this is true
16:16:50 <geekosaur> cabal tries to hide the ugliness, and only partially succeeds
16:16:53 <napping> sandboxes help a lot
16:17:12 <Cale> I guess that's true, without cross module inlining, things would be pretty different, perhaps.
16:17:23 <napping> dist space and compile time is worth the sanity
16:17:36 <napping> geekosaur: It's not so much the cross-module inlining
16:17:39 <geekosaur> for one thing, you could use any library the same or higher minor version and any dor version
16:17:44 <geekosaur> *fot version
16:17:49 <geekosaur> *doot version
16:17:51 <geekosaur> dammit
16:17:54 <geekosaur> *dot version
16:17:57 <geekosaur> only 4 tries...
16:18:04 <napping> it's the mismatch between the package database working by versions, and cross module inlining making each build potentially distinct
16:18:15 <Cale> The versions of things you compiled the package against may still matter anyway
16:18:16 <napping> Isn't ezyang and Backpack and stuff fixing up ghc-pkg?
16:18:29 <geekosaur> instead, if some library is built against some other library, you need an exact version match (and before 7.10 exact binary match because internal names leaked into the linkage)
16:18:40 <napping> right, and if ghc-pkg understood that and let you retain differently compiled versions of the same source, everything would be much better
16:19:45 <Cale> torulv: Anyway, this is nothing specific to Haskell -- essentially all code dependency systems have this kind of issue.
16:20:14 <geekosaur> kde used to have this issue in spades because they used a lot of cpp macros which exposed internals the same way haskell .hi files expose internals for inlining
16:20:15 <SrPx> This is what I meant:
16:20:16 <Cale> torulv: There are things we could be doing better, but there are fundamental difficulties.
16:20:31 <SrPx> > (Node 1 [Node 2 [], Node 3 []]) ^? ix 0
16:20:34 <lambdabot>      Could not deduce (Num [Int]) arising from the literal ‘0’
16:20:34 <lambdabot>      from the context (Num a)
16:20:34 <lambdabot>        bound by the inferred type of it :: Num a => Maybe a at Top level
16:20:35 <geekosaur> they took the performance hit and stopped using cpp
16:20:46 <napping> I think the backpack/nix-style stuff will fix a lot of things
16:21:06 <napping> replacing previously installed packages is the fundamental reason things break
16:21:32 <napping> once multiple instances of the same version of a package can coexist you won't need as much sandboxing or isolation
16:21:51 <napping> actually getting libraries with a stable binary interface is a whole different problem, to be sure
16:22:22 <Cale> SrPx: Oh, Ixed instance, not Ix instance.
16:22:39 <Cubesoup> I have an FFI question: the struct I need to model has a field of type pthread_mutex_t , and I don't really understand what to do. Should I just make it a FunPtr?
16:23:17 <Cale> SrPx: Ix is a base library class which is concerned with array indexing. You're talking about the ix function from lens, which is a method of the Ixed class, and is mostly unrelated :)
16:23:48 <napping> Cubesoup: Do you mean ForeignPtr?
16:24:01 <SrPx> Yep. I just forgot the name is different, sorry.
16:24:03 <napping> I don't see how a function pointer would be involved
16:24:29 <napping> I'm getting an error Could not find module ‘Distribution.Simple.Test.LibV09’ trying to run cabal test
16:24:37 <napping> in a project I'm trying to add some tests to
16:24:51 <Cubesoup> napping, maybe yes
16:25:04 <Cubesoup> first time trying to bind something
16:25:17 <Cale> SrPx: type Index (Tree a) = [Int]
16:25:22 <napping> Cubesoup: structs don't necessarily interoperate nicely
16:25:37 <napping> you often end up just keeping a ForeignPtr to a C-allocated struct, and calling C functions to get at stuff
16:25:44 <napping> something about computing the right offsets and so on
16:25:59 <arkeet> not just a regular Ptr?
16:26:13 <Cubesoup> so, the C thing has methods to construct everything from what I can see
16:26:16 <napping> well, maybe that too. A ForeignPtr can free something if the last Haskell reference goes away
16:26:27 <arkeet> which may or may not be what you want.
16:26:30 <Cubesoup> I won't have to look inside the mutex type
16:26:58 <napping> Depends what you want, yeah. There's probably a foreignptr involved somewhere if you want to play nice with garbage collection
16:27:14 <arkeet> for some type safety maybe you can define some empty data PthreadMutex and then use Ptr PthreadMutex
16:27:17 <arkeet> I dunno.
16:27:17 <Cale> > view (ix [1,2]) (Node 0 [Node 1, Node 2 [Node 3 [], Node 4 [], Node 5 []]])
16:27:18 <lambdabot>      Couldn't match expected type ‘Tree a’
16:27:19 <lambdabot>                  with actual type ‘Forest Integer -> Tree Integer’
16:27:19 <lambdabot>      Probable cause: ‘Node’ is applied to too few arguments
16:27:21 <napping> If you want to do stuff with the mutex, you might need a way to get a Ptr directly to it from a pointer to the object
16:27:23 <Cale> oops
16:27:30 <napping> You have a struct with a field of type pthread_mutex_t, right?
16:27:34 <arkeet> assuming you just want it opaque.
16:27:42 <Cale> > view (ix [1,2]) (Node 0 [Node 1 [], Node 2 [Node 3 [], Node 4 [], Node 5 []]])
16:27:43 <lambdabot>      No instance for (Show a0)
16:27:43 <lambdabot>        arising from a use of ‘show_M85217321745505490261193’
16:27:43 <lambdabot>      The type variable ‘a0’ is ambiguous
16:27:47 <Cale> tsk
16:27:51 <Cubesoup> napping, right
16:27:57 <Cale> > view (ix [1,2]) (Node 0 [Node 1 [], Node 2 [Node 3 [], Node 4 [], Node 5 []]]) :: Integer
16:27:58 <lambdabot>      No instance for (Monoid Integer) arising from a use of ‘ix’
16:27:59 <lambdabot>      In the first argument of ‘view’, namely ‘(ix [1, 2])’
16:27:59 <lambdabot>      In the expression:
16:28:01 <Cale> lol
16:28:03 <Cale> okay
16:28:08 <arkeet> > preview (ix [1,2]) (Node 0 [Node 1 [], Node 2 [Node 3 [], Node 4 [], Node 5 []]])
16:28:09 <lambdabot>  Just 5
16:28:10 <napping> What's this about testStub.hs trying to run a cabal test suite?
16:28:15 <Cale> right
16:28:42 <Cubesoup> arkeet: I'll try that yeah, thanks
16:30:07 <SrPx> I could've guessed that from the error message alone... damn. Thank you.
16:30:10 <SrPx> Back to work, see ya.
16:30:32 <napping> hmm, looks like the stub depends on the cabal-install version
16:30:42 <napping> and it tries to link with whatever Cabal library you have in the sandbox
16:35:53 <Aruro> is there a function which returns a last element of scanl? or something similar?
16:36:30 <napping> last element of scanl? Isn't that just foldl?
16:36:32 <arkeet> that's foldl
16:37:25 <Aruro> arkeet: mm, yeah :D
16:38:26 <cgag> does cabal (with a sandbox) download the sources for  all the dependencies somewhere I can search?
16:38:55 <cgag> I want to search the source of my project, dependencies included
16:39:08 <napping> It downloads the compressed version somewhere
16:42:43 <Aruro> arkeet: what about one argument function? i want to get f ( f ( f ( f ( f x )) ... n times
16:43:03 <cgag> 'cd .cabal-sandbox; find . | less', finding lots of .hi and .dyn_hi files, i don't see any archives
16:43:17 <arkeet> iterate f x !! n
16:43:18 <kadoban> :t iterate -- Aruro ?
16:43:19 <lambdabot> (a -> a) -> a -> [a]
16:43:27 <arkeet> > iterate f x !! 5 :: Expr
16:43:29 <lambdabot>  f (f (f (f (f x))))
16:43:38 <arkeet> > iterate f x :: [Expr]
16:43:39 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
16:44:00 <Aruro> ok, i was wondering if its possible without (!!) operator
16:44:10 <arkeet> you have to stick a number in somehow.
16:44:25 <arkeet> > foldr (.) id (replicate 5 f) x :: Expr
16:44:27 <lambdabot>  f (f (f (f (f x))))
16:44:41 <Aruro> yes like that
16:44:57 <Aruro> ty
16:45:24 <arkeet> > appEndo (mconcat (replicate 5 (Endo f))) x :: Expr
16:45:27 <lambdabot>  f (f (f (f (f x))))
16:46:08 <Herogx> if I have xs which is IO[String]
16:46:20 <Herogx> why does xs!!0 not return the first element of that list?
16:46:25 <arkeet> because IO [String] is not [String].
16:46:30 <Cale> Herogx: Because an IO [String] is not a list of Strings
16:46:37 <Aruro> arkeet: what is Expr type?
16:46:43 <Cale> Herogx: It's a computation which if executed would produce a list of Strings.
16:46:46 <Aruro> @src Expr
16:46:46 <lambdabot> Source not found. I've seen penguins that can type better than that.
16:46:47 <arkeet> Aruro: from simple-reflect
16:46:51 <Aruro> aaa
16:46:53 <Aruro> i see
16:46:54 <Aruro> yes
16:46:57 <Cale> Herogx: Similarly to how /bin/ls is not a list of files
16:47:02 <Aruro> its part of bot now?
16:47:07 <Herogx> Then how do I go about pulling a String out of it?
16:47:09 <arkeet> lambdabot has had it for a while.
16:47:12 <Herogx> at such an index
16:47:26 <Herogx> something like a <- xs
16:47:27 <Herogx> a!!0
16:47:28 <Herogx> ?
16:47:30 <Aruro> arkeet: nice, i still have to finish blog post about it :)
16:47:32 <arkeet> Herogx: yes
16:47:39 <Cale> Herogx: You execute the IO action, like  do vs <- xs; ... use xs here somehow ...
16:47:43 <Cale> er
16:47:46 <Cale> use vs rather
16:47:58 <Cale> (It's weird to name an IO action xs)
16:48:00 <arkeet> you could also fmap (!!0) (your io action)
16:48:06 <Herogx> I just named it that randomly
16:48:19 <Cale> and yeah
16:48:20 <Herogx> I don't actually have it called that
16:49:21 <Cale> You also probably want to be careful using !! since that basically kills your program if the index is out of range. It would be better to pattern match on the list using case under most circumstances (though for a quick one-off program it can be handy just to index)
16:49:22 <arkeet> > ala Endo (foldMapOf (replicated 5)) f x :: Expr
16:49:23 <lambdabot>  f (f (f (f (f x))))
16:49:40 <Herogx> Cale it's impossible for it to hit an OOB the way I have it built
16:49:52 <Cale> all right then :)
16:49:53 <arkeet> also consider using head instead of (!! 0)
16:49:57 <Herogx> Well, probably not impossible, but extremely difficult considering how small it is
16:50:05 <Herogx> 0 was also an example
16:50:08 <arkeet> okay
16:50:09 <Herogx> It needs to be a random index
16:50:17 <Herogx> which I think I have kind of worked out
16:50:47 <Herogx> while I'm at it, I found that you can treat some IO as pure if you declare it to be unsafe, is it named so because it goes against the Haskell way
16:50:56 <Herogx> or are there genuinely stability issues with it or something?
16:51:26 <napping> It's easy to break various interfaces
16:51:35 <Cale> Herogx: If you're referring to unsafePerformIO, that's actually unsafe for a wide variety of reasons. You really need to know what's going on to use that, and you generally will almost never need to do that.
16:51:36 <napping> It's not necessarily unstable, but kinda bad
16:51:52 <Cale> You can break the type system altogether with unsafePerformIO
16:51:57 <Herogx> Honestly the scope of my program is just a hangman game
16:51:57 <Cale> (and IORefs)
16:52:08 <napping> for one thing, because of laziness the IO can be re-run a bunch of times
16:52:18 <Herogx> All I want is a randomly obtained string in a list of strings which were obtained through reading the file
16:52:47 <napping> you've got a do block where you read the file, then you can use some of the functions from System.Random
16:52:56 <Cale> Herogx: Well, that's not hard. You probably read the file somewhere near the top of main, which is an IO action, so it's allowed to execute other IO actions
16:53:31 <Herogx> Yea I was looking at randomR and stdgetGen
16:53:41 <Cale> Herogx: and then you execute something like randomRIO (0, length wds - 1) to generate an index, and then just pick out the appropriate string using that.
16:53:43 <napping> randomRIO is the one
16:53:50 <Herogx> They same like a safer option since now I kind of understand the IO bit a little better
16:54:06 <Herogx> Thinking of it as something that hasn't happened yet really helped clear up some confusion
16:54:15 <napping> the StdGen stuff is only interesting if you want code that can *only* pick random numbers, and not do other IO
16:55:23 <Cale> Yeah, you can write pure code which accepts a generator state as an argument, passing along new generator states as it makes selections, but if you're writing an IO action anyway, there's no need for the added complication of doing that.
16:56:07 <Herogx> Hm, well whatever makes more sense I guess
16:56:42 <napping> randomRIO is fine
16:57:05 <monochrom> calling randomRIO n times is slower than calling newStdGen 1 time and then take n (randomRs ...).
16:57:18 <Cale> monochrom: haha
16:57:25 <Cale> monochrom: That's interesting
16:57:29 <napping> don't be confusing
16:57:33 <monochrom> this is because randomRIO n times implies readIORef and writeIORef n times, which are dog slow
16:57:49 <Cale> Oh, really?
16:58:02 <Cale> I've never thought of readIORef and writeIORef as being slow
16:58:06 <monochrom> I once helped a beginner improved performance substantially by just that change.
16:58:49 <Cale> But StdGen in general is quite slow compared to many other pseudorandom number generators.
16:59:10 <Cale> and it doesn't even have the nice guarantees about split that tf-random gives
16:59:12 <napping> and readIORef/writeIORef shouldn't be much more than a load or store, maybe with a barrier
16:59:47 <Zemyla> Hmm, how would you make a fake ST monad that can produce and store values of arbitrary types without using built-in primitives?
17:00:01 <Cale> I really think that we should steal all the Gen stuff from QuickCheck and make that somewhat standard.
17:00:01 <monochrom> the barrier is the cause.
17:00:09 <napping> monochrom: it's an atomicModifyIORef, not a readIORef/writeIORef
17:00:18 <Cale> Zemyla: I have one of those...
17:00:33 <arkeet> right, that uses a barrier.
17:00:36 <napping> Cale: how does that work?
17:00:38 <arkeet> regular read/write don't I guess.
17:00:43 <monochrom> ok, atomicModifyIORef is only slower, not faster
17:00:51 <Cale> napping: Just make it a free monad
17:00:54 <napping> I wouldn't say it *uses* a barrier, but it is an atomic instruction
17:01:07 <napping> Cale: with your own reference type like ST?
17:01:08 <Cale> hmm, where'd I put that code
17:01:13 <Herogx> http://lpaste.net/132126 That's my code there
17:01:20 <monochrom> at any rate the time difference is empirically observed.
17:01:21 <Herogx> if anyone wants to take a glance at it
17:01:34 <Herogx> that comment should read string list
17:01:40 <Herogx> or IO string list, rather
17:01:52 <glguy> Herogx: Don't use getStdGen, generally. You want newStdGen there
17:01:55 <arkeet> ok, well IO [Word] -> Word is the firtst thing that's wrong :-)
17:01:56 <Cale> napping: yeah. You can then interpret the code using the real ST, or with IO, or using some kind of heterogeneous map structure...
17:01:59 <napping> Herogx: ah, you'll want to swing things around a bit. get_word :: [Word] -> IO Word
17:02:00 <arkeet> first
17:02:21 <Herogx> huh napping? I'm attempting to pull a string from the list
17:02:25 <arkeet> what list?
17:02:25 <Herogx> oh
17:02:30 <Herogx> And it's and io list
17:02:39 <arkeet> @quote /bin/ls
17:02:40 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
17:02:41 <napping> yeah, so you'll need to get it first
17:03:13 <napping> you want to get a list and pick from that, not pass in a procedure that might generate a list every time it's run, which is what IO [Word] is
17:03:13 <Cale> Herogx: getLine isn't a String, for example, it's the program which you could execute to get a line of text from the user, which would then be a String
17:03:31 <Cale> Herogx: of course, it might be a different String result every time you execute it
17:03:49 <Herogx> Yea I understand that's why it's on the "dirty" side of things and such
17:03:49 <napping> instead of get_words (read_dictionary), you'll go like "do my_words <- read_dictionary; word <- get_word my_words; ..."
17:04:01 <monochrom> Herogx: perhaps you should first read my http://www.vex.net/~trebla/haskell/IO.xhtml
17:04:04 <napping> so, get_word :: [Word] -> IO Word
17:04:18 <Herogx> I certainly will, monochrom
17:04:24 <napping> like get_word words = do ix <- randomRIO (0,length words-1); return (words !! ix)
17:04:28 <arkeet> there's a monochrom article for every problem it seems.
17:04:36 <monochrom> no, not yet
17:04:40 <Herogx> :P
17:04:44 <Cale> Herogx: Execution (carrying out the instructions described by IO actions) is separate from evaluation (rewriting runtime expressions into values for pattern matching), and evaluation essentially never causes execution to occur (barring things like unsafePerformIO)
17:04:57 <monochrom> Cale: do you know whether tf-random is faster than stdgen?
17:04:58 <napping> monochrom: if random number generation is the bottleneck, you should also suggest switching to another generator
17:05:11 <Cale> monochrom: It's slightly slower, iirc.
17:05:32 <napping> what is tf?
17:05:38 <monochrom> napping: no, empirically it was randomRIO vs randomRs. same StdGen all over.
17:05:38 <Cale> Threefish
17:05:48 <Cale> https://hackage.haskell.org/package/tf-random
17:05:57 <arkeet> mwc-random is supposed to be pretty fast no?
17:05:57 <napping> monochrom: and something like mwc-random is a few times faster than a pure StdGen
17:06:12 <Herogx> What's the difference between stdGen and newStdgen then?
17:06:13 <napping> If they were getting enough random numbers that a CAS for each was too much
17:06:17 <arkeet> but it doesn't look splittable.
17:06:24 <napping> Herogx: it's something for threads
17:06:24 <Cale> arkeet: right
17:06:25 <arkeet> StdGen is a type.
17:06:51 <napping> Herogx: if you call getStdGen a bunch of times, each StdGen will give you the same numbers
17:06:58 <napping> if you call newStdGen they are supposed to be independent
17:07:12 <Cale> Somehow despite the fact that it's an absolutely fundamental operation that you'd want to have, people have only begun to look at the problem of random number generators whose states are splittable.
17:07:17 <Aruro> > foldr (const) undefined [3..6]
17:07:18 <lambdabot>  3
17:07:23 <Herogx> getStdGen has the same seed each time then or something?
17:07:35 <napping> no, it's just literally getting the StdGen that IO keeps around
17:07:44 <Cale> getStdGen probably ought not to exist
17:07:47 <napping> remember, purely functional code and stuff
17:07:54 <Cale> I don't know why getStdGen and setStdGen are there
17:08:09 <napping> Cale: saving and restoring a seed, maybe?
17:08:11 <arkeet> ^
17:08:20 <srhb> But you could do that purely.
17:08:22 <Cale> napping: Well, yes, but it's needless.
17:08:49 <napping> Herogx: so a StdGen is a particular state of the random number, and if you call randomR a few times on the same stdGen you'll always get the same answer
17:08:52 <Cale> You could always take a StdGen argument if you cared which seed was used
17:08:55 <monochrom> spinless tagless needless seedless generator. or fruit.
17:08:59 <napping> just like calling head on the same string a bunch of time always gives the same answer
17:09:18 <Herogx> I see
17:09:31 <Herogx> I'm going to try read some of this tutorial to see if I can make more sense of my issue
17:09:32 <napping> so yeah, getStdGen is a bit funny if you are trying to make really random numbers
17:10:06 <napping> but I doubt a hangman game needs especially good randomness
17:10:17 <Herogx> I'm just trying to make it as good as possible
17:10:27 <napping> just pick a thing with one randomRIO 
17:10:59 <Herogx> I only have a few days to work on it but it is worth 50% of my grade. My uni kind of screwed up my schedule so I'm writing this in between java and maths exams as well as a couple of interviews :S
17:11:01 <arkeet> randomRIO is perfectly fine if you just need one random number.
17:11:19 <Herogx> You can use randomRIO in a pure fashion?
17:11:33 <napping> the atomicModifyIORef that monochrom is worried about is considered extremely fast for threading stuff, just calling it once won't be noticeable, especially in an interactive program
17:11:35 <arkeet> uh you can only use it in IO.
17:11:37 <arkeet> :t randomRIO
17:11:38 <lambdabot> Random a => (a, a) -> IO a
17:11:38 <Zemyla> Herogx: I've figured out how to get a random element of a list without using IO, and with only one pass.
17:11:39 <arkeet> hence the IO type
17:11:51 <napping> randomRIO is the IO version of randomR
17:11:54 <arkeet> Zemyla: where do you get the randomness?
17:12:08 <Zemyla> arkeet: With a RandomGen passed into the function.
17:12:12 <napping> if you don't want to mess around with a StdGen, and just pick a number or two, call randomRIO and be done with it
17:12:27 <monochrom> if you want to pick a random item out of a million items, and your strategy includes "start with a list, find the ith item for random i", your biggest problem is not in the "random" part
17:12:31 <Zemyla> RandomGens are just variables, and every function that uses one to produce a random number also produces a new RandomGen.
17:12:49 <Herogx> It's only a couple of hundred elements lol
17:14:41 * hackagebot hs-inspector 0.5.0.0 - Haskell source code analyzer  http://hackage.haskell.org/package/hs-inspector-0.5.0.0 (flbulgarelli)
17:14:42 <Cale> Herogx: One thing you might just do is to pull in QuickCheck, which despite the fact that its main purpose is fo automated testing, also includes lots of handy stuff for generation of random values.
17:14:58 <arkeet> such as choosing a random element of a list.
17:15:10 <monochrom> if it's about two hundred items, you should simply read one byte from /dev/urandom and be done with it. and spend your time replacing the list by an array or Data.Map
17:15:11 <Cale> Herogx: You could write  word <- generate (elements wordList)
17:15:12 <Herogx> I've seen that in a few stack overflow posts but never thought to use it, or rather even how to
17:15:49 <Cale> Herogx: where  wordList :: [String]  is your list of strings obtained from reading the file and breaking it into lines or whatever
17:16:03 <Cale> and then  word :: String  would be one of those selected at random
17:16:44 <Herogx> What is the purpose of the elements function in that ?
17:16:51 <Cale> elements :: [a] -> Gen a
17:17:04 <Cale> makes a random generator which selects one of the elements of the list at random
17:17:06 <Herogx> oh it passes the argument into a gen?
17:17:20 <jle`> it *makes* a Gen
17:17:31 <jle`> elements [1,2,3] is a Gen that produces 1, 2, or 3 at random
17:17:36 <monochrom> -> does not mean "pass into"
17:17:53 <arkeet> internally it just looks at the length and picks a random number between 0 and length-1
17:18:03 <arkeet> so you may as well just do your randomRIO thing.
17:18:08 <Herogx> I understand that, I mistook the Gen (a) part for it passing something into a gen
17:18:16 <Herogx> and then returning the gen
17:18:42 <Cale> [a] -> Gen a  means that it takes a list of values of type a, and produces a value of type Gen a, which you can think of as some sort of computation which knows how to generate random values of type a, when provided with an initial random generator state (and some other stuff)
17:19:48 <Herogx> I see
17:20:02 <Herogx> I'm going to read over this tutorial anyway and if I can't figure it out I'll just use that
17:20:13 <Herogx> thank you very much
17:20:40 <Cale> generate :: Gen a -> IO a  takes a computation of type Gen a, and it converts it into an IO action which when executed will construct a new random generator state (and provide default other values), and run the generator in order to produce its result.
17:20:49 <arkeet> :t generate
17:20:50 <lambdabot> Gen a -> IO a
17:20:52 <arkeet> :t elements
17:20:53 <lambdabot>     Ambiguous occurrence ‘elements’
17:20:54 <lambdabot>     It could refer to either ‘Control.Lens.elements’,
17:20:54 <lambdabot>                              imported from ‘Control.Lens’ at /home/lambda/.lambdabot/State/L.hs:48:1-43
17:20:56 <arkeet> :-(
17:21:07 <Cale> :t Test.QuickCheck.Gen.elements
17:21:08 <lambdabot> Not in scope: ‘Test.QuickCheck.Gen.elements’
17:21:13 <Cale> hmm
17:21:15 <Cale> :t Test.QuickCheck.elements
17:21:16 <lambdabot> Not in scope: ‘Test.QuickCheck.elements’
17:21:19 <Cale> okay
17:21:28 <Cale> I dunno what's going on there
17:21:33 <arkeet> :t elementss
17:21:34 <lambdabot>     Not in scope: ‘elementss’
17:21:34 <lambdabot>     Perhaps you meant one of these:
17:21:34 <lambdabot>       ‘elements’ (imported from Control.Lens),
17:21:35 <napping> oneOf, maybe?
17:21:39 <arkeet> :t generatee
17:21:40 <lambdabot>     Not in scope: ‘generatee’
17:21:40 <lambdabot>     Perhaps you meant ‘generate’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
17:21:48 <arkeet> :t Lambdabot.Plugin.Haskell.Eval.Trusted.elements
17:21:49 <lambdabot> [a] -> Gen a
17:21:51 <Cale> hah
17:21:57 <napping> it is elements, dunno
17:22:12 <Cale> Lambdabot's configuration is really weird
17:22:13 <Herogx> Why'd it require such a lengthy import?
17:22:21 <arkeet> because lambdabot's configuration is really weird
17:25:09 <lpaste> Zemyla pasted “Random choice for Herogx” at http://lpaste.net/132127
17:25:30 <Zemyla> There you go. A function that gets a random element from a list without using IO and in only one pass.
17:26:54 <Herogx> What is going on here o_O I said it before but I will say it again, you people are incredibly into helping others for people in a programming irc channel
17:27:32 <Zemyla> Herogx: I should probably explain the algorithm better so that you know how it works.
17:27:38 <arkeet> I think what's happening here is you just walk down the list while holding onto a random element of what you've seen so far.
17:28:03 <Zemyla> Yep. And the nth element of a list has at that point a 1 in n chance to replace the one you're holding.
17:28:08 <arkeet> when you hit the n'th element you change what you're holding to that with probabiliyt 1/n
17:29:04 <arkeet> this kind of sucks though in that you're generating a random number for every element of the list
17:29:07 <arkeet> instead of once up front
17:30:25 <pacak> generate one instead and then use `mod` to fit it in 1..n range?
17:30:47 <arkeet> that sounds like a bad idea.
17:31:02 <Zemyla> arkeet: Yes, but I highly doubt the generation of random numbers is the bottleneck when you're producing lists with hundreds or thousands of elements.
17:31:19 <arkeet> depends on the list.
17:31:26 <napping> Zemyla: it's almost certainly more expensive than just walking a list
17:31:30 <Herogx> o_O my lists literally have a couple hundred elements of element length no longer than 10
17:31:32 <acowley> What else would be the bottleneck there?
17:32:00 <Zemyla> napping: Yes, but with the other implementation, you have to walk the list once to get its length, then walk it again to get the randomly chosen element.
17:32:34 <Zemyla> The other thing this does is that the program can garbage collect unchosen elements of the list.
17:32:39 <arkeet> in particular, you have to hold the entire spine of the list in mempry.
17:33:28 <pacak> Or something similar to get the distribution right
17:43:54 <Zemyla> Oh, I actually came up with a shorter random selector which permits list fusion.
17:47:40 <lpaste> Zemyla revised “Random choice for Herogx”: “Random choice for Herogx” at http://lpaste.net/132127
17:48:12 <Herogx> that seems overtly complex for a random element
17:48:30 <Zemyla> Yes, but it permits list fusion.
17:48:52 <Zemyla> Go look up "Lists to Streams to Nothing at all".
17:49:57 <Zemyla> Though actually it kind of builds up a massive function. I suppose I could have it work from the other end, though.
17:50:25 <fProgrammer> Quick question
17:50:41 <fProgrammer> How do I access element of type [IO a]
17:50:59 <simpson> :t sequence -- fProgrammer 
17:51:00 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
17:51:06 <Iceland_jack> fProgrammer: That depends what you mean by access
17:51:51 <Iceland_jack> If you have
17:51:51 <Iceland_jack>     [print 0, print 1] :: [IO ()]
17:51:51 <Iceland_jack> would 'access' mean run "print 0" and then run "print 1" or only running one of them
17:52:03 <fProgrammer>  Okay what I meant was, there is a function f,  f :: a -> b  
17:52:31 <fProgrammer> I have a [IO a]   and want to apply f to each element
17:52:52 <Iceland_jack> You can
17:52:52 <Iceland_jack> :t map . fmap
17:52:53 <lambdabot> Functor f => (a -> b) -> [f a] -> [f b]
17:53:01 <simpson> You can fmap . fmap.
17:53:04 <Iceland_jack> :t map . fmap :: (a -> b) -> [IO a] -> [IO b]
17:53:05 <lambdabot> (a -> b) -> [IO a] -> [IO b]
17:57:03 <fProgrammer> Iceland_jack,  simpson: can I also do  :t mapM  f  (sequence [IO a])
17:57:23 <Iceland_jack> fProgrammer: Do you want to execute the actions?
17:57:45 <fProgrammer> Iceland_jack: yes
17:58:59 <schell> is there a type level ($) ?
17:59:31 <Zemyla> schell: What do you mean? So you don't have to type so many parentheses on types?
17:59:50 <Iceland_jack> schell: Types must be fully saturated so it wouldn't be very useful
17:59:55 <Iceland_jack> fProgrammer: You can use
17:59:55 <Iceland_jack> :t \f xs -> map f <$> sequence xs
17:59:56 <lambdabot> Monad f => (a -> b) -> [f a] -> f [b]
18:00:01 <schell> Zemyla: yes exactly
18:00:15 <fProgrammer> Iceland_jack: Thanks
18:00:20 <Iceland_jack> :t (\f xs -> map f <$> sequence xs) :: (a -> b) -> [IO a] -> IO [b]
18:00:21 <lambdabot> (a -> b) -> [IO a] -> IO [b]
18:00:44 <schell> i’ve got a type that looks like (Cons Id (Cons (V2 Float) (Cons …. ))))
18:00:50 <schell> just trying to make it more legible
18:01:10 <Iceland_jack> schell: Create a type synonym
18:01:10 <Iceland_jack>     type a ++++ b = Cons a b
18:01:10 <Iceland_jack>     infixr ++++
18:01:25 <Iceland_jack> Or use DataKinds and use a list syntax for types?
18:01:30 <benzrf> :t sequence . fmap . fmap
18:01:31 <lambdabot> (Monad m, Functor f, Traversable ((->) (m (f a)))) => (a -> b) -> m (m (f a) -> f b)
18:01:33 <schell> ah - that would be nice - thanks
18:01:36 <benzrf> whoops
18:01:59 <benzrf> :t (sequence .) . fmap . fmap
18:02:00 <lambdabot> (Monad m, Traversable t) => (a1 -> a) -> t (m a1) -> m (t a)
18:02:13 <benzrf> :\
18:02:22 <Iceland_jack> :t let { infixr 9 •; (•) = fmap.fmap } in sequence • fmap . map
18:02:24 <lambdabot> Traversable t => (a1 -> a) -> t [a1] -> [t a]
18:02:35 <benzrf> :>
18:11:50 <arkeet> :t (.).(.)
18:11:51 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
18:14:55 <schell> it’s not possible to (infix) pattern match on infix constructors, is it?
18:15:04 <arkeet> sure it is.
18:15:11 <arkeet> you write patterns like x:xs all the time.
18:15:22 <schell> huh - yeah you’re right
18:15:39 <schell> ah - no - i’m wrong
18:15:46 <Iceland_jack>     data Exp = I Int | Exp :+: Exp
18:15:46 <Iceland_jack> schell:
18:15:46 <Iceland_jack>     eval (I i)     = i
18:15:46 <Iceland_jack>     eval (a :+: b) = eval a + eval b
18:15:49 <schell> i’m trying to use a function as a constructor
18:16:03 <schell> it’s late and i’m hungry :)
18:16:16 <schell> a $$ b = CCons a b
18:16:31 <schell> i was trying let (c $$ CNil) = ...
18:16:37 <arkeet> that defines $$ :-)
18:16:38 <Iceland_jack> You can do that using pattern synonyms
18:16:47 <Iceland_jack>     pattern a :$$ b = CCons a b
18:16:53 <arkeet> you can, but you still need to pick a capitalized name.
18:16:57 <arkeet> (: is a "capital symbol")
18:17:08 <Iceland_jack> If you want to pattern match on it, yes
18:18:21 <schell> Iceland_jack: is pattern synonyms an extension?
18:18:36 <Iceland_jack> Yes
18:20:58 <schell> Iceland_jack: NEAT! It worked
18:21:09 <schell> you can even specify fixity for your patterns
18:21:16 <schell> that really cleans things up, thanks
18:22:51 <arkeet> pattern synonyms have some pretty clever uses
18:23:24 <arkeet> e.g. nullary pattern synonyms for integer constants
18:24:04 <Iceland_jack>     pattern NaN <- (isNaN -> True) where
18:24:04 <Iceland_jack>       NaN = 0/0
18:24:10 <arkeet> and viewpatterns yes
18:24:30 <zq> zomg type safe routing without the template crap
18:24:33 <zq> so sexy
18:24:43 * hackagebot diagrams-svg 1.3.1.1 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-1.3.1.1 (BrentYorgey)
18:49:54 <yrlnry> I want to express that h is a type that supports keyed lookup with key type k and value type v by declaring a class Eq k => Assoc h k v.  For example, fetching a value from such an h has signature get :: h -> k -> v.  I have declared MultiParamTypeClasses.
18:50:12 <haskell339> Hi all, I have the Haskell Platform with ghc 7.8.3 installed on OSX but I now need to use ghc 7.8.10 - what's the best way to manage my installs on osx?
18:50:36 <yrlnry> Now I want to say that Assoc [(k,v)] k v is an instance of Assoc because [(k,v)] can implement this 'get' function.  But I don't know how to say that.
18:51:13 <yrlnry> ghci advises me to add FlexibleInstances; is that probably the right thing to do?
18:51:46 <acowley> So is taggy not compatible with 7.10 yet?
18:52:09 <acowley> That was rhetorical (unfortunately)
18:52:14 <acowley> Anyone want to patch it?
18:52:42 <arkeet> yrlnry: FlexibleInstances is pretty safe.
18:53:18 <yrlnry> arkeet: Does my idea seem generally reasonable?
18:53:28 <arkeet> seems ok.
18:53:31 <yrlnry> Thanks.
18:53:52 <arkeet> the Eq superclass seems unnecessary to me though.
18:54:10 <arkeet> (maybe I want to make an instance Assoc (k -> v) k v, even if k isn't an instance of Eq)
18:54:13 <yrlnry> It might be;  I have not decided whether to put it in.
18:54:30 <joneshf-laptop> haskell339, 7.8.10?
18:54:38 <yrlnry> I need it for [(k,v)], of course.
18:54:40 <arkeet> yeah.
18:54:44 * hackagebot BlogLiterately 0.7.1.9 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.7.1.9 (BrentYorgey)
18:54:51 <shachaf> You need it for the instance, presumably.
18:55:00 <arkeet> but it's also not enough for, say, Map k v
18:55:01 <yrlnry> I had it on both the class *and* the instance :)
18:55:16 <shachaf> Seems unnecessary.
18:55:28 <yrlnry> OK, I need to discover this stuff on my own.  Thanks for the advice.
18:55:37 <shachaf> Are you adding a functional dependency?
18:55:58 <shachaf> (You might consider using associated types instead, depending on your application.)
18:57:45 <yrlnry> Is https://wiki.haskell.org/GHC/Type_families the thing to read about associated types?
18:59:03 <shachaf> It's a thing to read, at least.
18:59:28 <shachaf> I'm not sure what the canonical source thing would be, if there is one.
18:59:54 <joneshf-laptop> acowley, seems like pretty small patches, do you know if the maintainers are responsive?
19:00:23 <yrlnry> I haven't used SML seriously in 15 years but I still write "None" instead of "Nothing" every time.
19:00:26 <yrlnry> Grr.
19:00:53 <acowley> joneshf-laptop: I don't know for sure, but I think so
19:01:24 <joneshf-laptop> acowley, well i've got nothing else to do at the moment, so i'll look into it :)
19:01:33 <acowley> joneshf-laptop: And I agree, where it broke apparently just needs list type annotations.
19:01:51 <acowley> joneshf-laptop: Thank you!
19:04:53 <shachaf> yrlnry: At any rate I imagine you're going to want one of these sorts of extensions. Functional dependencies vs. type families isn't a big difference here.
19:05:57 <shachaf> Can type families do everything that fundeps can do these days?
19:07:04 <yrlnry> Thanks, I'll keep it in mind and I'll read the Wiki page sooner or later, depending on if I run into trouble.
19:09:59 <johnw> shachaf: here's one data point to that question: http://comments.gmane.org/gmane.comp.lang.haskell.glasgow.user/24368
19:10:16 <johnw> maybe that's in 7.10 now though
19:10:44 <johnw> well, the ticket is still open, so maybe not
19:12:03 <acowley> shachaf: I don't think so. class C a b | b -> a where ...; type C' t = C T t; blah :: (forall t. C' t => ...) ...
19:16:33 <yrlnry> My class has  contains :: Assoc h k v => h -> k -> Bool   and   put :: Assok h k v => h -> k -> v -> h.   I have the "has" function implemented for my instance.  I want to use it in my "put" definition for the same instance, which says put assoc k v = if has k v 
19:17:14 <yrlnry> But ghci says "The type variable `v0' is ambiguous" and suggests I add an instance declaration for it.  I don't understand the confusion here.
19:17:15 <arkeet> you can do that.
19:17:18 <Zemyla> There are Eq1 and Eq2 classes, for kinds (* -> *) and (* -> * -> *) respectively.
19:17:18 <joneshf-laptop> acowley, https://github.com/alpmestan/taggy/pull/10
19:17:19 <arkeet> oh.
19:17:25 <arkeet> just add fundeps.
19:17:52 <yrlnry> Oh, I can say that k and v determine h?
19:18:00 <arkeet> no, the other way around
19:18:01 <arkeet> h -> k, h -> v
19:18:05 <yrlnry> Oh, right.
19:18:11 <Zemyla> Would it help anything if there were an EqT class, for kind ((* -> *) -> * -> *), with function eqT :: (Eq1 f, Eq a) => t f a -> t f a -> Bool?
19:18:21 <yrlnry> I still don't understand what the actual problem is.  Is there a brief explanation?
19:18:30 <Zemyla> And similarly for Ord, Read, and Show?
19:18:32 <arkeet> when you use contains
19:18:35 <acowley> joneshf-laptop: You are a magical human being!
19:18:41 <acowley> joneshf-laptop: Thanks for doing that.
19:18:42 <arkeet> it doesn't know which v to pick for the Assoc k h v constraint
19:18:50 <arkeet> since you only give it h and k
19:18:58 <yrlnry> Oh, I see.
19:19:09 <yrlnry> But if I tell it that h determines v, it knows.
19:19:24 <arkeet> correct
19:19:30 <yrlnry> Thanks, that is very helpful.
19:20:31 * enthropy wonders if there's any way to infer the "best" set of fundeps for a given set of instances
19:21:10 <joneshf-laptop> acowley, no prob, it's the least I could do for all you've done over the years.
19:21:14 <johnw> submit it to the #haskell prover
19:24:19 <enthropy> johnw: I mean you could try all combinations and out of the set that ghc accepts say that one is the best because it is the longest
19:24:48 <enthropy> but probably there's a smarter way
19:29:51 <athan> is there in theory, an ApplicativePlus?
19:30:18 <joneshf-laptop> `Alternative`
19:30:39 <athan> :) thank joneshf-laptop
19:30:40 <joneshf-laptop> depending on your definition of `ApplicativePlus`
19:34:15 <athan> is Alernative's empty always mzero when MonadPlus?
19:36:05 <athan> nevermind!
19:36:27 <enthropy> athan: yes for all of base?
19:39:17 <raymondtay> hi all, anyone knows which library to use for ssh v2 ?
19:51:31 <yrlnry> I was planning to build a Data.Map object whose keys were some scalar data and whose values were more Data.Map objects.  But predictably, this fails the occurs check.  Is there some way to work around this, or is my idea doomed?
19:51:50 <shachaf> You mean a recursive type?
19:51:54 <athan> yrlnry: Can I see the code?
19:51:55 <yrlnry> Yes.
19:51:59 <shachaf> You can make it a newtype.
19:52:20 <shachaf> newtype T k = T (Map k T)
19:52:45 <yrlnry> http://lpaste.net/132132
19:52:48 <yrlnry> Oh, that's easy enough.
19:52:52 <yrlnry> Thanks.
19:52:53 <Iceland_jack> yrlnry: Would you like to recursively lookup into the maps?
19:53:00 <yrlnry> Yes, exactly so.
19:53:22 <Iceland_jack> This sounds like a job for (Superman?) data families
19:54:01 <yrlnry> Hold that thought.
19:54:07 <Iceland_jack> (Is there any way of statically knowing which keys will map to Maps?)
19:54:15 <shachaf> Huh?
19:54:37 <yrlnry> All keys will map to Maps.  At the bottom we will have empty Maps.
19:55:12 <shachaf> You just have tree skeletons with (Map k)-shaped nodes.
19:55:40 <yrlnry> Wait, newtype T k = T (Map k T)  can't work because T has kind *->* but (Map k T) want sit to have kind *, no?
19:55:41 <shachaf> The (least?) fixed point of (Map k), or more explicitly the thing I wrote above.
19:55:51 <shachaf> Er, right.
19:55:56 <shachaf> newtype T k = T (Map k (T k))
19:56:14 <Iceland_jack> I'm interested in hearing your use case yrlnry, depending on it I may have an interesting solution (or not)
19:56:17 <monochrom> interesting data structure
19:56:42 <yrlnry> Okay, give me a minute to get my code to a pausing place and I'll try to explain.
19:57:14 <Iceland_jack> (https://hackage.haskell.org/package/ixset is something to check out)
20:00:08 <enthropy> ixset is not about putting maps in maps, but about being able to lookup reasonably efficiently in a "Map (a,b) x" when you just know the 'a'
20:00:21 <enthropy> or when you just know the 'b'
20:01:08 <Iceland_jack> Yes, but you can always use the entire path of keys you'd use to get to an object as a single object
20:01:39 <yrlnry> This is basically the data Mu f = In (f (Mu f)) trick.
20:02:04 <yrlnry> To construct the least fixed point of a type constructor of kind *->*.
20:05:43 <Iceland_jack> If you really want recursive maps you can let Rose trees influence you (or Cofree (Map k)?)
20:05:43 <Iceland_jack>     data RecMap k a = RM a (Map k (RecMap k a))
20:06:51 <yrlnry> I'm confused why I can't make NestedMap into a Functor instance with 
20:06:57 <bwiklund> i'm positive the answer is going to be "that's not how you want to do it", but is there any way / language flag that I can access 'Members' using record syntax, in the "foo.bar.baz" style?
20:06:57 <yrlnry> fmap f (NestedMap m) = NestedMap (fmap f m)
20:07:32 <shachaf> yrlnry: What is the definition of NestedMap?
20:07:33 <Iceland_jack> bwiklund: Yes, the language flag is a library called 'lens'
20:07:39 <bwiklund> googling
20:07:54 <yrlnry> 1m, I'll do a paste.
20:07:59 <shachaf> If it's parameterized on the key, it's not a functor.
20:08:12 <shachaf> fmap :: (a -> b) -> F a -> F b
20:08:22 <shachaf> But in your case there's no "a" argument to F.
20:08:41 <lpaste> yrlnry pasted “NestedMap functor instance ” at http://lpaste.net/132133
20:09:02 <shachaf> Yep.
20:09:25 <shachaf> Imagine you defined newtype NestedMap = NestedMap (Map Int NestedMap)
20:09:51 <shachaf> You wouldn't expect that to be a Functor -- it's not even the right kind.
20:10:37 <yrlnry> Yeah, it's totally wrong.  I need to go back and thing more about what I wanted this to do.  Thanks.
20:12:05 <bwiklund> i love how half of the stuff i want to do is just a matter of looking up a function signature on hoogle
20:12:28 <nshepperd> is it possible that Free (Map k) is what you wanted to do
20:12:35 <yrlnry> Iceland_jack: I am editing an unpublished paper.  The author wants to transform a list of the form [ [a, b, c, x1], [a, b, d, x2], [a, e, x3], [f, x4] ] into some sort of unspecified nested structure of the form { a => {b => {c => x1, d => x2}, e => x3 }, f => x4 }.
20:13:11 <yrlnry> She has a complicated algorithm for this that I think can be reduced to a simple algorithm.  I am hampered by the fact that she never says what the concrete representation of the result is.
20:13:38 <yrlnry> So I am trying to use these nestedMaps as concrete representations.  But maybe just using a tree type would be simpler.
20:13:48 <shachaf> There's Free (Map k), and Cofree (Map k), and all sorts of exciting possibilities.
20:14:12 <shachaf> But I think figuring out what to do should come before giving it a fancy name in this case.
20:14:16 <yrlnry> Why would these be better than the least-fixed-point thing you suggested earlier?
20:15:00 <shachaf> Fix F is a "tree skeleton" for some node shape F.
20:15:14 <shachaf> Free F and Cofree F are actual trees that can hold data.
20:15:39 <yrlnry> The Cofree one is necessarily infinite, I guess?
20:15:47 <shachaf> Not necessarily, since your maps can be empty.
20:15:52 <yrlnry> Oh, right.
20:16:22 <shachaf> I guess concrete examples would be more useful than all these names.
20:16:55 <yrlnry> I really want to return to this, but it's past my bedtime.  I hope you won't be offended if I thank you sincerely and take myself away for the night.
20:17:14 <yrlnry> You have given me a lot of stuff to read, which I will do.
20:17:21 <shachaf> Let's take lists rather than maps. You can make data S = S [S], or data Rose a = Rose a [Rose a], or data SExp a = Atom a | List [SExp a]
20:17:28 <shachaf> That works too. :-)
20:18:25 <yrlnry> You are making it very hard to leave.  This is too interesting.
20:18:33 <yrlnry> I think I see where you are going though.
20:19:16 <yrlnry> Thanks again, and good night.
20:24:46 <bwiklund> :Re
20:24:55 <bwiklund> heh, this isn't ghci
20:44:48 * hackagebot yet-another-logger 0.2.3 - Yet Another Logger  http://hackage.haskell.org/package/yet-another-logger-0.2.3 (larsk)
20:56:04 <nitrix> What is the term again for a binary function?
20:56:39 <arkeet> "binary function"
20:57:05 <nitrix> Nah it was a single word :(
20:57:29 <enthropy> "dyadic" sometimes but I think that's not a good word
20:57:48 <nitrix> dyadic, thank you.
20:57:49 <pacak> binaryFunction
20:57:53 <heatsink> It's probably a single word in german
20:58:00 <nitrix> enthropy: You found it :)
20:58:02 <nitrix> <3
20:58:22 <monochrom> "dyadic" is just an adjective like "binary". you still have to say "dyadic function", which is still two words.
20:58:45 <monochrom> this is now not even an XY problem. it is an XX' problem.
20:59:42 <pacak> binärfunktion
21:00:07 <pacak> バイナリ機能
21:00:21 <arkeet> 機能 is the wrong word for function. (you want 関数)
21:00:37 <arkeet> but whatever
21:00:47 <monochrom> <A> I have a nasty flu. they say it will take 14 days. how can I speed it up?
21:01:03 <heatsink> Parallelism
21:01:17 <heatsink> Infect 14 other people so it will take 1 day each
21:01:20 <monochrom> <B> just use my patented medicine and it will end in 2 weeks!
21:01:30 <monochrom> <A> oh that makes me feel so much better! thanks!
21:01:31 <pacak> arkeet: That's why I left Tokyo...
21:02:06 <arkeet> and I guess you want a different word for binary too.
21:03:50 <monochrom> but I guess this is #haskell so I should be using "learn haskell" to replace "treat the flu"
21:15:51 <rjsalts> they have a tonic to teach you haskell?
21:16:08 <johnw> well, sure, the question is if you'll still know it when it wears off
21:28:55 <jle`> is there a Store comonad but with only "relative" access?
21:29:39 <jle`> `peek x` would be equivalent to `peeks (+x)` or something from normal Store
21:30:31 <jle`> so no arbitrary peeking or seeking
21:30:34 <jle`> none of that
21:30:53 <johnw> doesn't sound too hard to define
21:31:40 <jle`> yeah, i'm defining it myself, but i was wondering if it already existed somewhere
21:32:33 <jle`> before this i had been using Tape [a] a [a]
21:32:55 <jle`> to enforce the invariant against arbitrary access and only give local accesses
21:33:15 <jle`> but extending this to 2D is a bit of a hassle
21:33:34 <johnw> if boths [a] are streams, it sort of has to be what you suggest
21:34:46 <jle`> yeah, sorry, i meant streams.  It acts more or less like Store Int with only 'relative peeking and seeking'
21:35:14 <jle`> but generalizing to Store (V2 Int) is a bit of a hassle
21:35:30 <nshepperd> Zipper (Zipper a)?
21:35:38 <jle`> if the entire data structure was to be nothing more than just an intermediate structure to maintain invariants in the first place
21:35:50 <jle`> yeah, but access isn't as pretty
21:35:59 <jle`> and i'd have to write a new comonad instance over a wrapper
21:36:42 <arkeet> can't you have some sort of coupdate comonad
21:36:46 <arkeet> if you have a monoid m acting on s
21:37:12 <arkeet> data Coupdate s m a = Coupdate (m -> a) s
21:37:20 <jle`> that's an interesting idea
21:38:13 <jle`> i will try to co-implement it
21:38:15 <wepy> oi
21:38:33 <jle`> oi wepy 
21:38:51 <wepy> is it possible to make something like a 3d shooter in haskell, or is it too slow/have too many GC stops?
21:39:00 <arkeet> it has been done
21:39:50 <arkeet> kinda old though https://wiki.haskell.org/Frag
21:39:52 <wepy> what about something complex/modern?
21:39:59 <jle`> it's been done and i think it is a nice platform to build a 3d shooter.  but more annoying thing is the lack of ecosystem support and examples to learn from
21:40:02 <wepy> just googled that, looks like quake 3-ish.
21:40:12 <arkeet> it's from 2005 
21:40:23 <jle`> you aren't going to be able to write a crysis, i don't think
21:40:26 <wepy> can you explicitly control the GC?
21:40:38 <arkeet> you can explicitly tell it to run the gc 
21:40:40 <wepy> like if you can't afford to have all threads halt for GC sometimes..
21:40:46 <arkeet> @hoogle performGC
21:40:46 <lambdabot> System.Mem performGC :: IO ()
21:40:55 <wepy> hm
21:41:18 <wepy> also..
21:41:39 <jle`> btw, there's also #haskell-game if you want to pursue and find like-minded individuals.  but a lot of us hang out in #haskell here too
21:41:40 <wepy> is haskell good for a python replacement?
21:41:59 <johnw> good for some, sure
21:42:01 <arkeet> both are general purpose programming languages
21:42:01 <jle`> python is really good in a lot of areas where python has traditionally been used
21:42:03 <wepy> or.. is there something like, a haskell Unix shell? i do a lot of shell scripting, but i hate bourne shell :)
21:42:06 <jle`> *haskell is
21:42:13 <jle`> there are some nice haskell libraries for shell scripting
21:42:14 <arkeet> @hackage shelly
21:42:14 <lambdabot> http://hackage.haskell.org/package/shelly
21:42:20 <jle`> @hackage turtle
21:42:20 <lambdabot> http://hackage.haskell.org/package/turtle
21:42:36 <wepy> not scripting through haskell.. a shell with haskell functionality
21:42:43 <jle`> full disclosure, i use ruby for shell scripting, but that's just because i've been too lazy :)  i know a lot of people who use haskell for shell scripting
21:42:44 <johnw> well, there's hell
21:42:47 <wepy> ah ok
21:42:51 <johnw> @hackage hell
21:42:51 <lambdabot> http://hackage.haskell.org/package/hell
21:43:12 <arkeet> cool name
21:43:59 <wepy> hell looks neat
21:44:23 <wepy> so.. i primarily do shell scripting when i have lots of commands to call
21:44:48 <wepy> and python when i need to manipulate bytes and strings..
21:45:03 <wepy> so haskell is maybe overkill for a python replacement in that context?
21:48:25 <wepy> maybe a better question is: what's haskell great for?
21:48:33 <arkeet> a lot of things
21:48:34 <wepy> does it have good cross-platform support?
21:48:42 <wepy> nice GUI/window support?
21:49:40 <wepy> is it good for parallel/concurrent programming?
21:49:51 <techtree> Hi all. I'm trying to import HUnit in GHCi and/or a .lhs script. I'm on OSX, using Haskell Platform. "import Test.HUnit" yields "Could not find module ‘Test.HUnit’", even though "ghc-pkg list" lists "HUnit-1.2.5.2". Any ideas why these two seem to disagree?
21:50:19 <Stratege___> wepy it's good for expressing abstract concepts concisely. Like the notion of parsing.
21:50:54 <wepy> ok
21:51:14 <wepy> like, you could write a language parser with it?
21:51:40 <Stratege> very easily, sure. Or you can easily embed a DSL.
21:52:04 <wepy> hm
21:52:11 <wepy> cool
21:52:20 <johnw> once you get into DSL-land, there's pretty much nothing you can't do
21:52:35 <Stratege> the webservers libraries that exist are supposedly really fast and easily concurrent as well.
21:52:53 <wepy> is haskell ok for CGI?
21:52:55 <Stratege> and of course, the strong static type system makes it so that surprises in what a function does are rather limited.
21:53:15 <Cale> wepy: CGI as in web serving stuff?
21:53:20 <wepy> also--does haskell have lots of crypto built-in, or just FFI->openssl?
21:53:30 <wepy> yea cgi like for web apps
21:53:41 <ryantrinkle> wepy: there's FFI to openssl and gnutls, and there's also a good amount of natively implemented crypto
21:53:51 <Cale> Yes, there are extensive web frameworks for Haskell
21:53:58 <ryantrinkle> wepy: there's a "fastcgi" lib available: https://hackage.haskell.org/package/fastcgi
21:54:03 <ryantrinkle> i haven't used it, though
21:54:04 <kadoban> wepy: haskell is surprisingly good for CGI
21:54:09 <wepy> cool
21:54:13 <ryantrinkle> i mostly use the snap web server framework
21:54:31 <Cale> Generally they produce binaries which are themselves web servers rather than stuff which uses CGI specifically, but you can use CGI with some other web server if you like.
21:54:36 <wepy> can haskell do like.. key/memory management safely?
21:54:38 <bwiklund> ignoring the error instead of a Maybe, is there any way I can dry this kind of code up?
21:54:40 <kadoban> wepy: You have to make sure a host supports it, or at least you can compile for their architecture. Most of the really bad hosts, that's not very easy, but otherwise it's not a big deal.
21:54:41 <bwiklund> http://pastebin.com/xGvmF1z8
21:54:44 <wepy> like if you have to reliably zero out a key buffer?
21:54:53 <bwiklund> i have a bunch of stuff i want to define this way for serialization
21:55:24 <ryantrinkle> wepy: yes; for that, you're going to want to manually allocate, overwrite, and deallocate buffers, rather than using garbage collected stuff
21:55:27 <Stratege> in a pinch you have access to malloc / manual memory management and can wrap that up into abstractions which should take care of safely cleaning the memory.
21:56:02 <wepy> but i feel like immutability would lead to lots of key copies
21:56:18 <wepy> even if the original buffer was managed in C somewhere
21:56:29 <Stratege> (I haven't done that myself though, but the Ressource Monad might be what you are looking for there)
21:56:31 <ryantrinkle> wepy: generally, immutability means you end up making *fewer* copies
21:56:36 <wepy> can haskell's GC zero things when it discards them?
21:56:46 <ryantrinkle> since you can rely on things never being changed, you never need to copy them
21:56:53 <ryantrinkle> i haven't heard of a GC feature like that
21:57:07 <wepy> it would be slower, but better for security
21:57:12 <Cale> wepy: There's no option for doing that specifically, but if you're doing manual memory management, you can use ForeignPtr and attach a finalizer which blanks the memory.
21:57:13 <wepy> less key material leaking
21:57:27 <wepy> hm
21:57:33 <ryantrinkle> if you need to know exactly what's happening to your RAM, you will probably need to use low-level primitives to manually allocate and deallocate it
21:57:42 <ryantrinkle> and you'll have to make sure you pin it in RAM at the OS level
21:57:50 <ryantrinkle> otherwise the OS memory manager may swap it out
21:57:58 <ryantrinkle> and then you've got key material on disk
21:58:09 <wepy> i dont have swap on most systems anymore
21:58:36 <wepy> but i don't do heavy lifting on anything
21:58:47 <Cale> You still have to worry about what you do with the key, like if you do a bunch of operations on it, you might allocate additional memory which holds bits of the key. I wouldn't recommend attempting something like that as a beginner, because getting that kind of safety really requires some understanding of what GHC is going to do.
21:58:47 <wepy> heh
21:58:50 <ryantrinkle> sure, but unless you specifically request a particular kind of handling for your memory, does the OS guarantee it won't copy it arbitrarily?
21:59:00 <wepy> hm
21:59:26 <wepy> Cale: sounds like it might not even be possible? unless haskell has explicit operations that won't copy memory?
21:59:29 <Cale> Oh, that's a good point too
21:59:38 <Cale> (Ryan's)
21:59:50 <Cale> wepy: There are operations which don't copy memory
21:59:51 <wepy> it's true, and crypto in hardware is a thing now..
22:00:03 <heatsink> bwiklund: You can write code that throws an error, or you can wrap the return type in a functor that propagates the error cases.
22:00:03 <ryantrinkle> wepy: it does have those operations:https://hackage.haskell.org/package/base-4.8.0.0/docs/Foreign-Marshal-Alloc.html
22:00:18 <ryantrinkle> you can use those allocators to allocate pointers directly
22:00:29 <wepy> hm
22:00:31 <wepy> neat tho
22:00:43 <ryantrinkle> if you want to do crypto operations and be sure no intermediate values leak
22:00:52 <wepy> might as well just do the crypto in C/asm tho
22:00:58 <ryantrinkle> you will probably need to implement them in assembly, maybe using something like atom
22:01:00 <wepy> or hardware
22:01:07 <ryantrinkle> and then you're gonna need to wipe not only the key, but also the stack
22:01:08 <wepy> yea
22:01:22 <ryantrinkle> all of which needs to be in memory that's pinned at the OS level
22:01:27 <wepy> in fact, secure memset is usually asm
22:01:32 <ryantrinkle> right
22:01:35 <jle`> i made a new typeclass called RelaStore
22:01:45 <wepy> but i don't know if there are also compiler things that ensure it's not stripped :)
22:01:49 <Cale> Or... what was it... harpy
22:01:55 <Cale> http://hackage.haskell.org/package/harpy
22:02:17 <heatsink> bwiklund: It's good to record what part of the input data has the error, to help diagnose errors.
22:02:55 <nshepperd> if there's a C library that already does this, like nacl, I would call out to it instead of attempting to write such things myself
22:03:08 <nshepperd> in any language really
22:03:16 <ryantrinkle> yep
22:05:48 <bwiklund> heatsink: the question was more about mapping strings to values without as much boilerplate
22:06:09 <bwiklund> ignore the error bit, i do want to wrap it in a maybe
22:06:37 <nshepperd> use an opaque newtype wrapper Key around such values, whose operations are restricted to those of such external library
22:07:12 <wepy> does Haskell have templates?
22:07:13 <heatsink> > lookup "true" [("true", True), ("false", False)]
22:07:14 <lambdabot>  Just True
22:07:18 <wepy> or.. is there a lot of boilerplate?
22:07:28 <Xe> wepy: with templatehaskell yes
22:07:34 <Xe> it's a language extension
22:07:48 <nshepperd> what do you mean 'templates'
22:07:49 <heatsink> If you mean C++ templates, those are polymorphic functions and type classes in Haskell
22:07:50 <wepy> language extensions.. are those common?
22:07:53 <kadoban> wepy: If you're talking about templates from C++, most of what they're required for in C++ they aren't at all in Haskell.
22:08:00 <wepy> like generic types in Rust or C++?
22:08:10 <kadoban> And haskell is /far/ less heavy on the boilerplate compared to C++
22:08:14 <wepy> ok
22:08:15 <heatsink> "generic types" are polymorphic functions
22:08:22 <Stratege> ^ and they are how you commonly do things
22:08:25 <nshepperd> yes, C++ templates are completely subsumed by haskell data types and typeclasses
22:08:41 <jle`> anyone know if there's a simple Ix wrapper over `vector` stuff?
22:08:52 <Stratege> if you let the type inference system work its magic, then your functions will be as polymorphic as they can be, basically.
22:09:11 <wepy> ok
22:09:22 <jle`> wepy: generic types are the norm
22:09:34 <nshepperd> well, maybe not 'completely', I don't know all the nooks and crannies of C++ templates
22:09:36 <jle`> all functions on lists are automatically polymorphic over all contained items
22:09:43 <jle`> *all containable items
22:09:47 <wepy> last question, maybe stupid: is haskell particularly bad at anything?
22:09:51 * hackagebot binary-streams 0.1.0.1 - data serialization/deserialization io-streams library  http://hackage.haskell.org/package/binary-streams-0.1.0.1 (petterb)
22:09:57 <jle`> not a stupid question :)
22:09:59 <Stratege> example: fmap :: Functor f => (a -> b) -> f a -> f b
22:10:16 <wepy> like.. is GUI/Windows programming bad in Haskell?
22:10:18 <jle`> or maybe map :: (a -> b) -> [a] -> [b] is a powerful example too
22:10:21 <wepy> (cross-platform?)
22:10:34 <nshepperd> cross-compiling, hueh
22:10:44 <jle`> wepy: nah.  some things might be tough because of library support, but it's not because it's an inherent problem of haskell
22:10:49 <wepy> is cross-compiling hard?
22:10:51 <jle`> haskell might not be suited for things like embedded chips
22:10:58 <jle`> integrated systems
22:11:08 <Stratege> I'd argue that it's bad at being debugable with conventional debugging tools - lazy evaluation hurts that. However, you can reason a whole lot better about your functions so debugging is a lot less necessary.
22:11:13 <jle`> where it isn't feasible to have a runtime environment
22:11:48 <wepy> what if i need to use Linux and BSD distros from the 90's.. can i cross-compile? or is.. building the compiler on those systems very hard?
22:12:03 <MP2E> cross compiling works well, but you lose the ability to use Template Haskell
22:12:09 <jle`> if i was to build an on-board driver for an elevator, for example, i might not choose to write it in haskell.  if the elevator could be remotely operated than i might.
22:12:21 <wepy> is Template Haskell really useful?
22:12:23 <jle`> *then
22:12:30 <mniip> Stratege, I've found the built-in evaluation tracer pretty poor
22:12:32 <wepy> ok
22:12:37 <heatsink> Compiling the widely used Haskell implementation, GHC, on an unsupported platform is difficult.
22:12:40 <jle`> wepy: it's mostly not necessary
22:12:45 <wepy> what's an evaluation tracer.. a debugger?
22:12:53 <jle`> it's there and we use it if we have to but for most cases it's just not necessary
22:12:54 <Stratege> mniip eyup, pretty much what I ment.
22:13:00 <MP2E> yeah it's not necessary, it is helpful for automatically writing boiler plate code
22:13:02 <wepy> is debugging haskell ok?
22:13:07 <mniip> had to seriously debug some strictness/demand issue, it was awful
22:13:08 <jle`> because haskell lets you deal with polymorphic stuff out of the box without templates
22:13:43 <wepy> can you like... attach to a process and debug it with haskell program on Unix?
22:13:56 <mniip> wepy, in imperative languages you have a program counter, that points to someplace in the code, and a traceback of function calls
22:13:58 <wepy> i mean.. debug an already running haskell program
22:14:07 <wepy> hm
22:14:14 <mniip> in functional languages instead you have a currently demanded value and a stacktrace of previously demanded values
22:14:27 <Stratege> if you get to the point where you have to debug runtime stuff, it's aweful - but I've written multiple medium sized programs (ie. co-evolutionary genetic algorithm on a neural network as a game AI) and didn't have to debug things most of the time.
22:14:29 <wepy> hm
22:14:30 <arkeet> in lazy langauges, anyway.
22:14:37 <mniip> yes
22:14:49 <mniip> languages that perform term reduction
22:14:53 <Stratege> testing and reasoning about the code can -usually- replace debugging. Atleast when it comes to correctness.
22:14:54 <wepy> didn't have to debug?
22:15:04 <wepy> is that because you used debug prints or something instead?
22:15:32 <Stratege> with "didn't have to debug" I ment I didn't have to use some runtime debugging or debug prints stuff.
22:15:42 <wepy> oh
22:15:43 <wepy> weird ;)
22:15:48 <gfixler> Stratege: is this because of purity?
22:15:49 <heatsink> In imperative languages, to explain why a bug happens, you often have to go into details about execution order and low-level encoding of data structures.
22:16:01 <wepy> yea
22:16:06 <heatsink> In Haskell, function results only depend on parameters, so those things don't matter
22:16:16 <heatsink> That's what mniip is referring to as term reduction
22:16:26 <wepy> hehe
22:16:34 <wepy> just a different paradigm i guess
22:16:36 <mniip> Stratege, neural networks pfft
22:16:39 <Stratege> gfixler yeah, in part - basically because you can reason about your code well and test parts of it easily you can find errors quickly. Pick a function, give it values that should work, see what happens. Or just look at the code / manually run it in your head.
22:16:41 <gfixler> wepy: haskell functions are much more like functions in math
22:16:48 <mniip> I had to debug a State# RealWorld demand issue
22:16:49 <gfixler> wepy: we rarely have to debug cosine
22:16:50 <wepy> i did lisp for a week in college.. was difficult to adjust :)
22:17:08 <Stratege> mniip I'm so sorry xD
22:17:22 <wepy> can you design finite state machines in Haskell?
22:17:22 <gfixler> Stratege: yeah, I thought so
22:17:27 <gfixler> wepy: es
22:17:29 <Stratege> yeah
22:17:30 <gfixler> yes*
22:17:35 <wepy> k :D
22:17:50 <Stratege> in <50 lines of code, infact.
22:17:51 <mniip> Stratege, you can see my acme-timemachine package :P
22:18:19 <Stratege> neat :D
22:18:41 <Stratege> love your example ^^
22:18:45 <nshepperd> doesn't lambdabot have a functionality for this? "but can I..." "Yes! Haskell can do anything!"
22:18:46 * wepy loves fsm's
22:19:16 <wepy> anyway, night :)
22:19:16 <wepy> thanks
22:19:31 <arkeet> @faq Can you design finite state machines in Haskell?
22:19:31 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
22:19:33 <arkeet> er
22:19:38 <arkeet> what is it
22:19:47 <arkeet> lol
22:20:16 <shachaf> "gone" is what it is.
22:20:19 <arkeet> damn
22:21:14 <jle`> an artifact of a bygone era
22:21:52 <jle`> wepy: the finite state machines course at my undergraduate actually taught it in haskell
22:22:15 <gfixler> mniip: is this timemachine like a zipper for the state monad?
22:25:18 <mniip> I wouldn't call it a zipper
22:25:36 <mniip> there's no redo
22:26:03 <mniip> popped actions are discarded permanently
22:26:16 <gfixler> ah
22:26:16 <mniip> or rather
22:26:20 <mniip> popped batons
22:39:26 <m_ryan> :t toSqlKey
22:39:27 <lambdabot> Not in scope: ‘toSqlKey’
22:39:40 <m_ryan> hi what is as in "toSqlKey :: Int64 -> a"
22:39:52 * hackagebot yet-another-logger 0.2.3.1 - Yet Another Logger  http://hackage.haskell.org/package/yet-another-logger-0.2.3.1 (larsk)
22:39:54 * hackagebot clash-prelude-quickcheck 0.1.2.0 - QuickCheck instances for various types in the CaSH Prelude  http://hackage.haskell.org/package/clash-prelude-quickcheck-0.1.2.0 (JohnEricson)
22:39:55 <m_ryan> i mean - what is "a" in toSqlKey :: Int64 -> a
22:42:22 <gfixler> m_ryan: a is a type parameter
22:42:39 <gfixler> it stands in for any type
22:43:18 <m_ryan> thank you. :) 
22:43:19 <jle`> uncons is now in Data.List
22:43:21 <jle`> how nice
22:43:54 <gfixler> :t uncons
22:43:55 <lambdabot>     Ambiguous occurrence ‘uncons’
22:43:55 <lambdabot>     It could refer to either ‘Control.Lens.uncons’,
22:43:55 <lambdabot>                              imported from ‘Control.Lens’ at /home/lambda/.lambdabot/State/L.hs:48:1-43
22:44:29 <gfixler> or what?
22:44:42 <shachaf> If you want to find out, ask lambdabot outside of the channel.
22:44:44 <gfixler> is this a Left or a Right?
22:44:51 <shachaf> Hmm, that doesn't work either.
22:45:07 <shachaf> Anyway, please try to avoid lambdabot errors like that in the channel.
22:45:30 <shachaf> I must've missed the thread where uncons was added to Data.List.
22:45:37 <shachaf> Why am I not surprised at the author?
22:46:15 <jle`> shachaf: don't keep us guessing :)
22:46:39 <shachaf> Authors, I should say.
22:46:41 <shachaf> Whatever.
22:46:46 <dfeuer> shachaf, you should probably move somewhere without people in it. May I recommend Venus?
22:46:49 <jle`> or i guess it would be best not to prompt you to single out people
22:47:08 <dfeuer> I hear the weather is very warm there.
22:48:07 <jle`> i found it out when i was writing uncons myself like i always did in the past
22:48:24 <dfeuer> Heh.
22:48:28 <jle`> and got a pleasant 'ambiguous occurence' error
22:48:39 <jle`> occurrence ?
22:48:57 <dfeuer> The latter.
22:49:13 <jle`> thanks. just tried things until it stopped turning red on my client
22:49:52 * hackagebot mockery 0.1.0 - Support functions for automated testing  http://hackage.haskell.org/package/mockery-0.1.0 (SoenkeHahn)
23:03:00 <jle`> @check \xs -> unfoldr uncons xs == xs
23:03:01 <lambdabot>  Ambiguous occurrence ‘uncons’
23:03:02 <lambdabot>  It could refer to either ‘Control.Lens.uncons’, imported from ‘Control.Lens’...
23:03:33 <jle`> @check \xs -> unfoldr Data.List.uncons xs == xs
23:03:35 <lambdabot>  +++ OK, passed 100 tests.
23:04:11 <jle`> there's something deep going on here i think with anamorphisms and coinduction or something idk
23:16:48 <pavonia> :t Data.List.uncons
23:16:48 <lambdabot> [a] -> Maybe (a, [a])
23:19:35 <Zemyla> Are there any instances of Read that aren't also instances of Show?
23:23:49 <pacak> Zemyla: I've seen examples.
23:23:59 <Zemyla> Oh?
23:24:30 <pacak> Not in base or libraries on hackage though.
23:25:35 <pacak> a bunch of datatypes gets generated using C, CPP and printf with somewhat long field names
23:26:03 <pacak> So the author decided to use shorter notation for Show.
23:26:17 <pacak> Don't do that.
23:28:15 <wgosling> I'm looking at documentation for a package. The docs show that you can use string literals as arguments for the functions, but I have to Data.Text.pack every string literal in order to get it to work. Did the author assume I "just know" that I need to Data.Text.pack everything or is there something I can do so that I don't have to do that? I ask because nearly every string literal in my program so far has to be Data.Text.pack'd (to be
23:28:15 <wgosling>  fair my program is short).
23:28:56 <pacak> wgosling: OverloadedStrings
23:31:26 <wgosling> pacak: Thanks! 
23:50:11 <muzzle> hi
23:50:30 <muzzle> is there a reason, why there is no foldable instance for data.bytestring ?
23:51:04 <Zemyla> muzzle: Because ByteString's kind is *, not * -> *.
23:51:17 <Zemyla> You can only fold ByteString over Word8s, not any type.
23:52:46 <muzzle> thx
23:56:51 <Zemyla> Why are there very few things that maniulate and transform Parsec streams?
23:58:55 <pacak> muzzle: You can use packedBytes Iso from Lens and then fold all you like...
23:59:17 <Zemyla> Like something that would let me turn an arbitrary Parsec parser into a stream that another Parsec parser can consume.
23:59:44 <pacak> If you are not afraid of summoning a demon by accident that is...
