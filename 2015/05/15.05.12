00:01:02 <arkeet> :t \f a b -> fmap (f a) b
00:01:03 <lambdabot> Functor f => (r -> a -> b) -> r -> f a -> f b
00:01:15 <arkeet> :t \f a b -> fmap (`f` b) a
00:01:16 <lambdabot> Functor f => (a -> r -> b) -> f a -> r -> f b
00:03:46 * hackagebot stackage-update 0.1.2 - Update your package index incrementally (requires git)  http://hackage.haskell.org/package/stackage-update-0.1.2 (MichaelSnoyman)
00:03:48 * hackagebot elm-init 0.1.0.0 - Set up basic structure for an elm project  http://hackage.haskell.org/package/elm-init-0.1.0.0 (justus)
00:03:57 <knite> I have a function work :: Foo -> Bar. why is fmap work able to take a Maybe Foo and pass it to work? it's like it's transforming work from Foo -> Bar to Maybe Foo -> Maybe Bar.
00:04:21 <arkeet> :t fmap
00:04:22 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:04:25 <arkeet> f = Maybe, a = Foo, b = Bar
00:04:25 <Veyn> functors!
00:04:44 <Veyn> wait
00:04:53 <Veyn> :t (<$>)
00:04:54 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:05:00 <arkeet> that's another name for fmap
00:05:00 <Veyn> They're the same :O
00:05:06 <jle`> knite: yes, that's exactly what it's doing
00:05:12 <knite> yep, I got that far on stack overflow.
00:05:18 <jle`> it turns an (a -> b) into a (Maybe a -> Maybe b)
00:05:20 <knite> but that doesn't help me understand what's happening or why. :-)
00:05:29 <jle`> ah
00:05:29 <arkeet> well, look at how fmap is implemented for Maybe
00:05:34 <jle`> it's defined differently for every type
00:05:35 <arkeet> @src fmap Maybe
00:05:36 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
00:05:42 <jle`> every type gets to implement its own 'fmap'
00:05:43 <arkeet> fmap f Nothing = Nothing
00:05:47 <arkeet> fmap f (Just x) = Just (f x)
00:05:48 <arkeet> that's all
00:05:49 <jle`> just like every type getting to implement its own '==', or '>'
00:06:16 <knite> so fmap is an operator that's predefined on Maybe a?
00:06:23 <Veyn> yus
00:06:30 <Veyn> on Maybe
00:06:32 <arkeet> it's defined as part of the Functor instance for Maybe
00:06:45 <jle`> knite: yes, similar to (==)
00:06:47 <arkeet> (well, that's the whole of it actually)
00:06:57 <jle`> arkeet: actually it has (<$) too :)
00:06:59 <arkeet> Functor is just another type class, like Eq and such.
00:07:03 <arkeet> jle`: well. :-)
00:07:09 <jle`> ;D
00:07:20 <arkeet> but fmap is all you need.
00:07:25 <jle`> knite: just like when you use 1 == 4, or "hello" == "world", the == used is different depending on what type
00:07:27 <jle`> same for fmap
00:07:30 <knite> so is map only worth using because it saves a character and has a more concise type signature?
00:07:31 <jle`> we call them 'polymorphic'
00:07:42 <arkeet> :t map
00:07:43 <lambdabot> (a -> b) -> [a] -> [b]
00:07:45 <arkeet> it's specifically for lists.
00:07:49 <arkeet> fmap for lists is map.
00:07:54 <jle`> there's a lot of debate around map in this regard
00:08:14 <knite> what's the debate?
00:08:18 <jle`> outside of teaching purposes (it's easier to see for a new person), people usually use map as a way to self-document their code
00:08:31 <arkeet> whether map should be generalized to Functor (i.e. just be another name for fmap)
00:08:35 <jle`> like if i say "map xs", you know that xs is a list.  if i said "fmap xs", you might have to think about it
00:08:40 <arkeet> yeah
00:08:48 <jle`> think about what xs is.  is it an [a]?  is it a Maybe a?  who knows!
00:08:50 <arkeet> sometimes it's useful to have a less polymorphic type
00:08:52 <knite> well, I should know from the type signature, eh?
00:08:58 <jle`> yeah, but it takes a bit more thought
00:09:04 <ReinH> And, if you're using fmap, "who cares?"
00:09:12 <orion> Will GHC optimize this statement away?: _ <- evaluate $ force myFunc
00:09:20 <jle`> it helps you understand/read code better :|
00:09:27 <arkeet> orion: no, because it doesn't do nothing.
00:10:20 <jle`> if you're *using* it, then you don't care.  but if you see someone use it in code...it might save you the extra second or two of thought if the author had just used map over fmap :)
00:11:09 <Veyn> is the debate between Hugs and GHC the same as Vi vs Emacs?
00:11:22 <ReinH> Veyn: no, since hugs doesn't really exist any more
00:11:41 <jle`> it's more like the debate between ancient sumerian and english for the official language
00:11:45 <jle`> of the us
00:11:51 <Veyn> that lecture must've been outdated then
00:12:24 <ReinH> jle`: well, if I see an fmap, then usually I either know what instance it is from context or I don't need to know...
00:12:49 <ReinH> (or I can't know)
00:13:03 <jle`> you can know it from context
00:13:11 <jle`> but it might take you a second or two to derive it
00:13:15 <jle`> why not just use map?
00:13:31 <jle`> why use \x y -> f (g x y) instead of f . (. g) ?
00:13:51 <jle`> (i'm sure i got that wrong >.<)
00:13:56 <ReinH> you mean fmap . fmap :p
00:14:02 <ReinH> or fmap fmap fmap
00:14:08 <jle`> oh yes of course
00:14:18 <lpaste> nocturne777 pasted “Understanding seq” at http://lpaste.net/132444
00:14:20 <ReinH> or fmap `fmap` fmap
00:14:21 <arkeet> (f .) . g
00:14:24 <arkeet> is what you wanted
00:14:27 <knite> so I'm reading about functors. what's the difference between <$> and .? <$> is infix fmap, so isn't f . g === f <$> g?
00:14:27 <arkeet> anyway
00:14:34 <arkeet> the reason has just been demonstrated
00:14:46 <arkeet> knite: (<$>) is fmap 
00:14:50 <jle`> thank you arkeet 
00:14:55 <ReinH> knite: (.) is fmap for functions
00:14:58 <arkeet> (.) happens to be the definition of fmap for a specific instance of Functor
00:15:03 <arkeet> (namely, for functions)
00:15:17 <knite> so it's exactly analagous to map being fmap for lists.
00:15:20 <jle`> so (.) and `map` are similar things... fmap made specialized for functions and lists
00:15:21 <arkeet> more or less yeah.
00:15:22 <jle`> mhm
00:15:24 <ReinH> yes
00:15:30 <jle`> there's one benefit though that (.) brings to the table over map
00:15:35 <jle`> (.) has a nicer fixity :)
00:15:36 <arkeet> while (<$>) is completely interchangable with fmap
00:15:52 <knite> thanks.
00:15:57 <knite> stuff like this is so hard to google.
00:16:07 <bernalex> arkeet: I'd write that f .: g
00:16:08 <ReinH> @google hoogle
00:16:09 <lambdabot> https://www.haskell.org/hoogle/
00:16:10 <jle`> the association/fixity of (.) is more convenient for use in function composition than `fmap` or <$>
00:16:14 <arkeet> bernalex: I would too, if I didn't have to define it first.
00:16:17 <ReinH> bernalex: I'd not write it at all
00:16:18 <knite> I know. hoogle often just raises further questions.
00:16:24 <Haskellfant> also . is less to type than <$> :P
00:17:03 <bernalex> arkeet: I have that in my company's prelude.
00:17:04 <ReinH> I've never gone back to code I wrote using .: and thought "I'm glad I did that"
00:17:20 <bernalex> ReinH: I have pleasant .:. code lying around.
00:18:02 <ReinH> I'm pretty sure we don't use it anywhere as a company, but we don't have any special rule about not using it afaik
00:18:33 <ReinH> maybe if we could find a nice unicode symbol (we seem to like using unicode)
00:18:44 <jle`> maybe use `O`
00:18:46 <jle`> f `O` g
00:18:47 * hackagebot conduit-extra 1.1.8 - Batteries included conduit: adapters for common libraries.  http://hackage.haskell.org/package/conduit-extra-1.1.8 (MichaelSnoyman)
00:18:51 <jle`> it's like...really big composition
00:18:55 <ReinH> heh
00:19:01 <ReinH> f ö g
00:19:08 <ReinH> too bad it isn't a symbol
00:19:19 <jle`> f `ö` g
00:19:26 <ReinH> f `o_O` g
00:19:44 <ReinH> it's like mismatched composition
00:19:44 <bernalex> something like 'f = g . h . i .:. asSeconds', where g/h/i takes seconds, but f takes hh:mm:ss.
00:19:53 <lpaste> nocturne777 revised “Understanding seq”: “No title” at http://lpaste.net/132444
00:20:56 <ReinH> f h m s = g . h . i $ asSeconds h m s would do for me :)
00:21:34 <ReinH> bernalex: didn't some acme package define .:. and .:: and etc for like dozens of operators?
00:21:35 <bernalex> there's one of few places I prefer stuff like .:. -- though I would not be terribly upset to see it that way either.
00:21:36 <nocturne777> I am trying to understand `seq`.  I know that seq stops as soon as it encounters a constructor. that's why in my example I used seq to for the evaluation of (replicate 5 'E') as I know that the seq in the implementation of foldl' will only evaluate the pair constructor and not the contents of it
00:21:57 <bernalex> ReinH: do you mean composition, or whatever it's called? it's not acme though.
00:22:04 <ReinH> bernalex: yeah
00:22:09 <ReinH> for various "arities" of composition
00:22:33 <bernalex> ReinH: in my company's prelude-extension, .:. is the highest, because that's the highest I've had reasonably cause to use. I didn't bother adding more until I'll need them (if I will ever need them).
00:22:44 <nocturne777> however, since "replicate 5 'E'" is also lazy given that it produces a list, does this kind of optimization worth it compared to the unoptimized 'testFold2'?
00:23:58 <bernalex> ReinH: I think if you have cause to use .:::::::: you have far bigger problems in your code than eta-reducing it
00:24:21 <ion> @hackage deepseq -- nocturne777
00:24:21 <lambdabot> http://hackage.haskell.org/package/deepseq -- nocturne777
00:25:00 <ReinH> nocturne777: this is how I recommend that people reason about using seq: http://apfelmus.nfshost.com/blog/2013/08/21-space-invariants.html
00:25:05 <ronh-> nocturne777 does the second code even compile? your default accumulator is [], but you're returning a tuple in the function
00:25:05 <ReinH> bernalex: indeed
00:25:49 <nocturne777> ronh-: it compiles
00:25:50 <ronh-> oh, nevermind. it is a list of tuples
00:26:37 <ronh-> why foldl' over foldr, then?
00:27:51 <nocturne777> ronh-: I am traversing the entire list, that's why I though foldr would not be useful here.
00:27:58 <nocturne777> thought*
00:28:41 <mazur> hi all, is there a command to install the dependencies from my test suite?
00:28:46 <mazur> *cabal command
00:30:26 <supki> mazur: cabal install --enable-tests --only-dependencies
00:30:40 <Veyn> resources for learning FRP?
00:31:04 <mazur> supki: oh yes, that worked. :D i tried both separately but not together
00:31:27 <ronh-> nocturne777 I am not sure to be honest. but from what I understand foldr is a better choice if your function is productive (and yours is).
00:31:33 <merijn> Veyn: I think Conal's papers are a good intro
00:31:54 <merijn> Veyn: Functional Reactive Animation and Push-Pull FRP are probably the best intro papers
00:32:33 <merijn> Veyn: http://conal.net/papers/icfp97/ and http://conal.net/papers/push-pull-frp/
00:32:54 <ReinH> merijn: agreed
00:32:56 <Veyn> Thank you
00:33:01 <nocturne777> ReinH: could you give me the gist here? I have read too much stuff on this already, I feel a bit tired at this point to go through that article?
00:33:41 <ReinH> nocturne777: use seq (and bang patterns) to reason about "space invariants", the notion that "if this is evaluated then this also needs to be evaluated"
00:34:16 <nocturne777> yes, I get that part
00:34:57 <nocturne777> but in my case, I feel that this optimization that I did in my code is unnecessary
00:36:18 <calvinx> hello, I am getting an error with `ghc-mod check myfile.hs` that says “Not in scope: type constructor or class ‘IO’”.  Any idea why?  And this error only manifests when I am running ghc-mod in cabal sandbox.  If I run ghc-mod without using cabal sandbox, it works perfectly fine.
00:37:03 <nocturne777> ReinH: don't you think so? I mean the thunk is created by (replicate 5 'E') is the same the created lazy [] by the evaluation of that expression
00:37:25 <ion> Veyn: http://travis.athougies.net/posts/2015-05-05-frp-made-simple.html
00:41:29 <ReinH> Hmm.
00:41:31 <ReinH> "Here, continuous means that a Behavior has a defined value for any given time (not the mathematical definition!)."
00:41:41 <ReinH> Traditionally, it *is* the mathematical definition.
00:42:03 <jle`> the mathematical definition is a bit stronger, isn't it?
00:42:03 <ReinH> But I guess this blog post refers to the popular non-FRP FRP idiom
00:42:17 <ReinH> jle`: traditional FRP uses continuous time values
00:42:34 <orion> Does anyone know why this is so?: http://lpaste.net/132446
00:43:19 <jle`> time is continuous, but the behavior might not be
00:44:22 <ReinH> jle`: a behavior is function from time, so it is continuous for continuous-time frp
00:44:58 <ReinH> Hmm. Never mind.
00:45:07 <jle`> yeah, but the definition of 'continuous' there is different than the definition of continuous in mathematics. not that it's an important distinction to make
00:45:26 <jle`> a continuous function would mean that the limiting behavior on any point is the same when you come from either side
00:45:31 <ReinH> Yes.
00:45:39 <ReinH> Thus "never mind"
00:45:44 <jle`> ah i see
00:45:52 <ReinH> I wish people wouldn't reuse terms like that
00:46:00 <jle`> time is continuous though
00:46:06 <jle`> in FRP
00:46:29 <ReinH> I'm disappointed in this frp blog post
00:46:38 <arkeet> jle`: not in the sense of a continuous function :p
00:46:41 <merijn> I'm disappointed in ALL FRP blogposts
00:46:46 <merijn> arkeet: Yes it is
00:46:53 <merijn> arkeet: And if it isn't, you're not doing FRP
00:46:55 <ReinH> FRP is a denotationally elegant design, the system in this blog post has no denotation whatsoever
00:47:08 <merijn> ReinH: There's a reason Conal gave up on the term FRP
00:47:20 <ReinH> merijn: I know. We talked about it a bit on the podcast :)
00:47:25 <merijn> It's been hijacked by the JS monkeys >.>
00:47:49 <ReinH> But the term he wants to replace it with is even more of a mouthful
00:47:59 <vandenoever> is there a good FRP that works on an XML DOM, preferably a typed one like for e.g. html or svg?
00:48:03 <arkeet> "continuous" there means something closer to continuum (the real line) than any sort of continuous function.
00:48:29 <vandenoever> s/FRP/impl using FRP/
00:48:41 <ReinH> vandenoever: Elm?
00:48:48 * hackagebot schedule-planner 0.1.0.1 - Find the ideal lesson layout  http://hackage.haskell.org/package/schedule-planner-0.1.0.1 (justus)
00:48:49 <ReinH> fsvo "FRP", I suppose
00:49:24 <bernalex> fsvo "FRP" that includes "not FRP".
00:49:44 <ReinH> "Right now, we’ll just make both of these monads aliases for IO." no... stahp...
00:49:50 <ReinH> bernalex: indeed
00:49:58 <ReinH> which is how FRP seems to be used most often these days
00:50:04 <jle`> at least elm stopped claiming to be FRP
00:50:17 <vandenoever> ReinH: yeah, Elm seems nice, not sure it does namespaces though and it'd need serialization/deserialization for specific schemas
00:50:28 <vandenoever> that could be fixed i guess
00:50:44 <vandenoever> jle`: what's the diff between elm and frp?
00:51:04 <vandenoever> diff between discrete and continuous?
00:51:41 <jle`> sort of...it's also a difference between operational and denotational semantics
00:52:14 <merijn> vandenoever: The entire point of FRP is it's denotational semantics, which almost all "frp" implementations immediately sacrifice
00:52:46 <jle`> elm doesn't really care about the denotations of things in a higher-level sense as much as it is concerned with operational semantics and making things work well in its api/framework
00:52:50 <vandenoever> ah, i dont know what that is yet :-P
00:52:50 * R0b0t1 mumblegrumble FRP grumble
00:53:02 <ReinH> vandenoever: you should listen to our interview with conal :)
00:53:13 <vandenoever> ReinH: sure, got a link?
00:53:15 <ReinH> vandenoever: http://www.haskellcast.com/episode/009-conal-elliott-on-frp-and-denotational-design/
00:53:21 <vandenoever> very fast :-)
00:53:23 <merijn> vandenoever: "denotational semantics" == the ability to reason about written down things without knowing how they're run
00:53:31 <bernalex> elm is great for what it is. and it's very interesting to see purescript and elm take completely different approaches.
00:53:33 <calvinx> hmm, I think my Prelude is not in scope in a sandbox… why would that happen?
00:53:38 <merijn> vandenoever: For some very informal definition of denotational semantics ;)
00:53:54 <ReinH> calvinx: someone is playing a prank on you and set -XNoImplicitPrelude somewhere?
00:54:04 <vandenoever> merijn: ah, sounds tricky, i guess writing down means 'ast'
00:54:09 <merijn> vandenoever: It's basically, "can we define what a piece of code does/is supposed to do without resorting to implementation details"
00:54:12 <ReinH> merijn: ah yes, handwaving about denotational semantics. I appreciate the irony.
00:54:16 <calvinx> ReinH: where’s that set?
00:54:33 <bernalex> ReinH: my thoughts exactly :D
00:54:35 <ReinH> calvinx: It could be set in a cabal file
00:54:46 <vandenoever> condemning code by the metadata ;-)
00:55:06 <calvinx> Ugh. Yeah, that was it.
00:55:08 <calvinx> LOL
00:55:12 <ReinH> merijn: s/does/means :p
00:55:21 <ReinH> calvinx: lol
00:55:40 <gfixler> I've read up a bit on denotational semantics, and I still don't know what they are
00:56:13 <merijn> vandenoever: The more formal description of denotational semantics is: You describe a mathematical object(s) with some properties and a mapping from code to those objects, then prove things about the way those objects interact
00:56:35 <jle`> vandenoever: if you assume that 3 means the number three, and 4 means the number four, and 7 meas the number seven you can reason that "3 + 4 = 7" without actually thinking about how the code is run/executed
00:56:38 <merijn> vandenoever: By having a mapping to mathematical objects you can abstract away/ignore lots of source level "noise"
00:56:42 <pharaun> is there a transcript for the talk (the conal talk)
00:56:46 <jle`> as in, where you see (3 + 4), you can replace it with 7
00:57:07 <ReinH> pharaun: no
00:57:11 <pharaun> welp
00:57:13 <jle`> that's because 3 and 4 and 7 "mean" something, mathematically.  separate and apart from their machine implementations, if you do eventually implement them
00:57:17 <pharaun> can't listen to it then :)
00:57:31 <merijn> gfixler: See my last message ;)
00:57:37 <pharaun> guess i can probably try to figure out some of this from the links/papers
00:57:51 <gfixler> merijn: listening now - still can't fathom how soundcloud doesn't have a volume control yet
00:58:01 <ReinH> Here's a nice writeup on scott strachey denotational semantics http://cgi.csc.liv.ac.uk/~grant/Teaching/COMP317/densem.pdf
00:58:04 <gfixler> whoa, wait a minute - I found it :-o
00:58:12 <gfixler> must be new
00:58:36 <ReinH> Here's a bigger one http://people.cis.ksu.edu/~schmidt/text/densem.html
00:59:33 <ReinH> Here's a recent talk Conal did https://www.youtube.com/watch?v=zzCrZEil9iI
00:59:50 <ReinH> based on this paper http://conal.net/blog/posts/denotational-design-with-type-class-morphisms
01:00:03 <vandenoever> merijn: jle`: that makes sense, so reasoning about code with generics
01:00:10 <pharaun> wow the auto-caption makes no sense
01:00:18 <ReinH> There are some other links on the page for the podcast episode
01:00:30 <pharaun> slides! yay let's see
01:00:52 <pharaun> aw they 404
01:01:05 <calvinx> Gave me a scare. IO() wasn
01:01:12 <ReinH> pharaun: he publishes his slides on github https://github.com/conal
01:01:18 <calvinx> IO() was missing in my file because Prelude wasn’t imported 
01:01:20 <pharaun> perfect, thanks ReinH 
01:01:29 <ReinH> pharaun: np
01:01:34 <calvinx> *IO() was not recognized by ghc-mod
01:02:54 <ReinH> calvinx: yeah you probably shouldn't do that
01:02:57 <jle`> haha yeah i remember the first time that happened to me
01:03:49 <calvinx> It was auto-generated by yesod init if I am not wrong.
01:03:49 * hackagebot system-fileio 0.3.16.3 - Consistent filesystem interaction across GHC versions (deprecated)  http://hackage.haskell.org/package/system-fileio-0.3.16.3 (MichaelSnoyman)
01:03:51 * hackagebot system-filepath 0.4.13.4 - High-level, byte-based file and directory path manipulations (deprecated)  http://hackage.haskell.org/package/system-filepath-0.4.13.4 (MichaelSnoyman)
01:07:54 <calvinx> Yea, it’s from Yesod’s scaffolding tool.
01:08:29 <calvinx> Something about preventing ambiguous occurrence ‘id’ in Yesod’s Settings.hs
01:15:14 <Falkyouall> how can i concatenate a list of my own datatype? is my patternmatch right?
01:15:17 <Falkyouall> data List a = Leer | Element a (List a) deriving Show
01:15:18 <Falkyouall> comb :: List a -> List a -> List a
01:15:18 <Falkyouall> comb (Element a t) = comb(Element a (t))
01:15:56 <merijn> Falkyouall: That's an infinite loop
01:16:02 <Falkyouall> ok
01:16:24 <merijn> Falkyouall: Also, your signature specifies it takes two arguments, but you have only one pattern
01:16:36 <mauke> (t) is the same as t
01:16:46 <mauke> comb(Element a (t)) is the same as comb (Element a t)
01:16:58 <mauke> your definition says: comb x = comb x
01:17:04 <mauke> loop!
01:17:05 <merijn> Falkyouall: Presumably you want "comb Leer (Comb a t) = Comb a t" and "comb (Comb a t) (Comb b t) = {- this code left as exercise for the reader -}"
01:17:14 <merijn> eh
01:17:21 <merijn> Replace the second t with something else
01:17:27 <mauke> Comb doesn't even exist
01:17:33 <Falkyouall> ok, thats right, my plan is to concatenate two lists rekursively with my own datatypes but im confused
01:17:35 <mauke> you don't need to match on the second arg
01:17:56 <merijn> mauke: Reading is hard! :p
01:18:35 <mauke> the two interesting cases are comb Leer rest = ... and comb (Element x xs) rest = ...
01:18:40 <mauke> structural induction, etc
01:27:53 <merijn> edwardk: ping?
01:28:41 <gfixler> merijn: probably 4:30AM for him atm
01:28:49 <ion> > let f s m n=s<$guard(n`mod`m==0)in fromMaybe<$>show<*>f"fizz"3<>f"buzz"5<$>[1..]
01:28:51 <lambdabot>  ["1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fizz","13","14...
01:29:08 <merijn> gfixler: That usually doesn't seem to affect his presence ;)
01:29:25 <gfixler> merijn: so that's how he writes so much
01:29:37 <bernalex> merijn: he started working out, as a side-effect he also started sleeping.
01:29:46 <merijn> gfixler: That's literately what he told me, yes
01:29:54 <jle`> ion: the suspense on stopping at 14 is killing me
01:29:56 <gfixler> I just started working out, too, but I'm still up
01:29:59 <gfixler> no excuse
01:30:08 <merijn> gfixler: I asked him "how the fuck are you so productive?" and he said "Easy, I just give up on sleep"
01:30:12 <ion> jle: Hah
01:30:16 <merijn> gfixler: Then you're not working out hard enough :p
01:30:23 <gfixler> merijn: true, but I'm ramping up
01:30:28 <gfixler> http://lpaste.net/132447
01:30:34 <gfixler> I feel like I'm missing something with merge there
01:30:43 <gfixler> like there's a function for that
01:32:04 <ion> > unwords $ let f s m n=s<$guard(n`mod`m==0)in fromMaybe<$>show<*>f"fizz"3<>f"buzz"5<$>[1..]
01:32:06 <lambdabot>  "1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz 16 17 fizz 19 buz...
01:32:31 <gfixler> hmmm, maybe I was thinking of guard
01:35:29 <gfixler> ion: what's that s<$ bit? I'm not parsing it...
01:36:02 <gfixler> oh, wait, is that (<$)?
01:36:05 <merijn> Yes
01:36:18 <merijn> gfixler: Time to review chapter 2 of the report ;)
01:36:31 <gfixler> merijn: I have to view it first, then I can review it
01:37:31 <bezirg> hi, I am just using the vector package. I want to catch an unitialized element exception. I do this: res <- try $ Data.Vector.Mutable.read arr 0 :: IO (Either SomeException Int) . But, the res is Right *** Exception: Data.Vector.Mutable: uninitialised element   . Any ideas on how I can properly catch the exception?
01:37:31 <bezirg>  
01:42:36 <ion> gfixler: Ungolfed: let f str m n = str <$ guard (n `mod` m == 0) in map (liftA2 fromMaybe show (f "fizz" 3 <> f "buzz" 5)) [1..]
01:42:55 <gfixler> ion: yeah, I just ungolfed it in Vim
01:43:11 <gfixler> then tried to take a few elements, and realized it was all a big string :)
01:43:46 <ion> The "words" invocation was added just for lambdabot
01:43:57 <jle`> gfixler: maybe you can use [Nothing,Nothing,Just"fizz"], and use \x y -> fromMaybe (show y) x
01:43:58 <ion> Uh, unwords
01:44:15 <gfixler> jle`: I was playing a bit like that, with id, const, etc
01:44:24 <jle`> you have to use (<>)/mappend instead of (++) tho
01:44:24 <gfixler> but hadn't dived into maybe types
01:44:56 <gfixler> I like being more general
01:44:58 * gfixler salutes
01:45:28 <jle`> general would be proud
01:45:38 <ion> Ungolfed more: let f str m n = str <$ guard (n `mod` m == 0) in map (\n -> fromMaybe (show n) ((f "fizz" 3 <> f "buzz" 5) n)) [1..]
01:54:00 * hackagebot network-conduit-tls 1.2.0 - Create TLS-aware network code with conduits  http://hackage.haskell.org/package/network-conduit-tls-1.2.0 (MichaelSnoyman)
01:59:00 * hackagebot project-template 0.2.0 - Specify Haskell project templates and generate files  http://hackage.haskell.org/package/project-template-0.2.0 (MichaelSnoyman)
02:04:00 * hackagebot schedule-planner 0.1.0.2 - Find the ideal lesson layout  http://hackage.haskell.org/package/schedule-planner-0.1.0.2 (justus)
02:09:00 * hackagebot yesod-gitrepo 0.2.0.0 - Host content provided by a Git repo  http://hackage.haskell.org/package/yesod-gitrepo-0.2.0.0 (MichaelSnoyman)
02:12:24 <frerich> ReinH: I think your podcast with conal is realllly nice, I like the questions being asked a lot (it's mostly what I have on my mind, too!) and I enjoy conal's explanations. More power to you guys!
02:14:13 <bezirg> ok so, I cannot cache an unitialized element exception both with array and vector packages. Any suggestions?
02:14:34 <bezirg> I found Control.Exception.ArrayException , but neither array or vector use it 
02:15:04 <bezirg> *catch*
02:19:09 * hackagebot elm-init 0.1.0.1 - Set up basic structure for an elm project  http://hackage.haskell.org/package/elm-init-0.1.0.1 (justus)
02:19:11 * hackagebot wai-app-static 3.1.0 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-3.1.0 (MichaelSnoyman)
02:22:30 <DanZimm> So I was looking at the following blog post on using monads in c++ (http://bartoszmilewski.com/2015/05/11/using-monads-in-c-to-solve-constraints-1-the-list-monad/) and decided to implement a solution in haskell. I'm going to post in a second what I came up with, but I was wondering if there was anyway to optimize it
02:22:32 <lpaste> DanZimm pasted “constraint problem” at http://lpaste.net/132456
02:25:24 <pacak> DanZimm: http://www.reddit.com/r/haskell/comments/33zy6p/easy_exhaustive_search_with_the_list_monad/cqq6hht
02:25:43 <pacak> DanZimm: Your version is a bit unreadable and impossible to modify
02:28:05 <DanZimm> pacak: why do you call it unreadable and impossible to modify
02:28:23 <DanZimm> by modify do you mean on lpaste its read only, or something?
02:28:46 <pacak> unreadable as in it's impossible to understand what your code does.
02:29:06 <DanZimm> wat
02:29:10 * hackagebot markdown 0.1.13.2 - Convert Markdown to HTML, with XSS protection  http://hackage.haskell.org/package/markdown-0.1.13.2 (MichaelSnoyman)
02:29:28 <DanZimm> sorry - to be this seems ridiculously verbose (in fact that's why I came here, it seems /too/ verbose)
02:30:03 <pacak> First line - OK, second line - letter s changes from 1 to 9, but line 9 contains too much conditions. Did you missed any of those? Did you specified any of those twice? I have no idea.
02:30:14 <DanZimm> pull each letter from 0-9, ensure each letter is unique and ensure the constraint that send + more = money
02:30:31 <Twey> DanZimm: Maybe notElem?
02:30:44 <pacak> And if you want to change the expression to some a different expression - you will have to change everything
02:30:57 <Twey> DanZimm: I feel like you'd benefit from writing a ‘fromDigits’ function, too
02:31:22 <pacak> > foldl1 (\a -> (a * 10 +)) [1,2,3,4,5]
02:31:24 <lambdabot>  12345
02:31:40 <DanZimm> pacak: well let me know if you want to try and help as opposed to criticize and disregard
02:32:18 <DanZimm> twey: unsure what you mean by 'notElem' and aha thats a good idea
02:32:37 <pacak> I am trying to help pointing at problems I can see
02:33:00 <DanZimm> "wrong, wrong, wrong" - sorry, I'm not coming here for that, thanks though..
02:34:18 <pacak> Well... It's not my fault :) The good part is that it will work faster than my solution.
02:35:17 <DanZimm> pacak: honestly asking: are you trolling me?
02:35:35 <pacak> DanZimm: Nope
02:38:34 <lpaste> Twey annotated “constraint problem” with “constraint problem (annotation)” at http://lpaste.net/132456#a132457
02:39:01 <lpaste> Twey revised “constraint problem (annotation)”: “No title” at http://lpaste.net/132457
02:39:19 <DanZimm> twey: thanks!
02:39:47 <Twey> It feels like you should be able to capture this constraint of ‘choose unique’, but I think you'd need to write your own list monad
02:39:47 <DanZimm> makes much more sense, cool!
02:40:00 <DanZimm> yea, I was trying to avoid that ;P
02:40:26 <Twey> I don't understand lpaste's warnings sometimes
02:40:56 <Twey> ‘Warning: Use infix.  Found: notElem e [s]; Why not: e `notElem` [s]’
02:41:24 <Twey> Because it's no more readable and two characters longer, of course
02:41:38 <opqdonut> heh
02:41:48 <butyoudonot> Twey: define 'more readable'
02:42:14 <Twey> butyoudonot: I feel like that onus is rather on the person claiming that it should be a warning
02:42:27 <liste> imo e `notElem` [s] reads more like english: e is not an element of [s]
02:44:11 <lpaste> Twey annotated “constraint problem” with “constraint problem (annotation) (annotation)” at http://lpaste.net/132456#a132460
02:44:26 <DanZimm> liste: english is overrated
02:45:10 <Twey> I sometimes use it infix and sometimes not.  I think it mostly depends on which saves me the most brackets
02:45:34 <Twey> `maybe` is a nice one to use infix, too
02:46:07 <Twey> But in the absence of other pressures, I prefer to use things consistently prefix — it's easier to line up and less prone to garden-pathing the reader
02:47:30 <frerich> Alas, https://github.com/ndmitchell/hlint/commit/542c92b36f0196853461d453a491891172cef148 has no reason why those suggestions were added.
02:48:13 <liste> infix + sections is easier on my brain than flip ((`mod` 2) 5 vs (flip mod 2) 5)
02:49:41 <Twey> I prefer flip, but often avoid it out of deference to the overwhelming majority who don't :þ
02:50:40 <merijn> It depends for me
02:50:58 <Twey> I'm confused by the syntax of this file
02:51:01 <merijn> flip makes sense for some things, but if infix makes sense (like mod) then I prefer infix + sections
02:51:03 <Twey> https://github.com/ndmitchell/hlint/blob/542c92b36f0196853461d453a491891172cef148/data/Default.hs
02:51:22 <liste> Twey it's hlint syntax
02:51:26 <Twey> This is Haskell?
02:51:26 <liste> not haskell
02:51:28 <Twey> Oh, okay
02:51:38 <Twey> The .hs and module header is misleading, then
02:52:41 <liste> maybe it's haskell but preprocessed in some way
02:57:54 <DanZimm> twey: thanks again for the help, knew i was missing something
02:59:10 * hackagebot yesod-fay 0.8.0 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.8.0 (MichaelSnoyman)
03:01:32 <Twey> DanZimm: Well, it's clearer but not much less verbose :þ
03:12:12 <DanZimm> twey: yea, oh well - looking into making the uniqueness constraint neater
03:30:12 <Twey> DanZimm: Ick, you need a restricted monad because of the Eq constraint
03:38:32 <haasn> Twey: I would have expected it to suggest “e /= s” instead
03:42:50 <don1731> >
03:43:51 <Twey> DanZimm: Actually — I guess what you want is precisely the RMonad Set instance
03:59:41 <pavonia> Any ideas what could cause GHC not finding a certain module when the corresponding package built fine and is found by ghc-pkg list?
03:59:53 <pavonia> ghc-pkg yields nothing
04:00:01 <pavonia> ghc-pkg *check
04:04:45 <pavonia> "package cassava-0.4.2.0-d2283149be7f0ae15142ba6a61484650 is unusable due to missing or recursive dependencies: blaze-builder-0.2.1.4-a95bca61e4b97e1327138c35596c25f9" :O
04:05:35 <merijn> pavonia: Did you ever run --force-reinstalls?
04:05:47 <pavonia> Not that I know of
04:06:27 <pavonia> I don't understand that error, the blaze-builder package is there
04:06:31 <merijn> hmm, that's the usual suspect for errors like this
04:06:35 <merijn> pavonia: The hash matters
04:07:01 <pavonia> How can I make ghc-pkg show me the hash?
04:07:13 <merijn> pavonia: It's saying that the current version of blaze-builder is different from the one cassava was build against, so it's effectively not there
04:07:16 <pavonia> Err wait, that package is installed twice
04:12:50 <pavonia> merijn: So the problem seems to be that blaze-builder is installed gloablly and locally, and GHC decides to use the local one for compiling though I made it hidden in ghc-pkg
04:13:26 <merijn> pavonia: Ah, mixing global/local installs is always a mess. Are you compiling using cabal?
04:13:37 <pavonia> No
04:13:40 <aloiscochard> I'm having issues with ghc-mod and ghc7.10, is that a well known issue?
04:13:51 <aloiscochard> (Not in scope ExposePackageId)
04:13:51 <merijn> aloiscochard: Last I checked ghc-mod didn't support 7.10 yet
04:14:03 <pavonia> Is there a way to tell GHC to use the global version?
04:14:11 <aloiscochard> okay, I'll dig more to see if it's fixed. thank you merijn 
04:14:14 <merijn> aloiscochard: There is a patch in progress, but the guy working on it is busy for work
04:14:22 <aloiscochard> oh I see
04:14:23 <merijn> check the issues on github for details
04:15:05 <aloiscochard> (https://github.com/kazu-yamamoto/ghc-mod/issues/437)
04:17:33 <pavonia> Great, some global packages are build against the local version :/
04:22:51 <pavonia> It's even weirder, they seem to be built against the local *and* global version. At least ghc-pkg unregister says unregistering either would break the same packages
04:34:25 * hackagebot basic-prelude 0.4.0 - An enhanced core prelude; a common foundation for alternate preludes.  http://hackage.haskell.org/package/basic-prelude-0.4.0 (MichaelSnoyman)
04:34:27 * hackagebot chunked-data 0.2.0 - Typeclasses for dealing with various chunked data representations  http://hackage.haskell.org/package/chunked-data-0.2.0 (MichaelSnoyman)
04:34:29 * hackagebot shakespeare 2.0.5 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-2.0.5 (MichaelSnoyman)
04:34:31 * hackagebot html-conduit 1.2.0 - Parse HTML documents using xml-conduit datatypes.  http://hackage.haskell.org/package/html-conduit-1.2.0 (MichaelSnoyman)
04:34:33 * hackagebot xml-conduit 1.3.0 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.3.0 (MichaelSnoyman)
04:39:35 * hackagebot xml-hamlet 0.4.0.11 - Hamlet-style quasiquoter for XML content  http://hackage.haskell.org/package/xml-hamlet-0.4.0.11 (MichaelSnoyman)
04:39:37 * hackagebot conduit-combinators 1.0.0 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-1.0.0 (MichaelSnoyman)
04:39:39 * hackagebot yesod-static 1.5.0 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.5.0 (MichaelSnoyman)
04:39:41 * hackagebot yesod-bin 1.4.8 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.8 (MichaelSnoyman)
04:39:43 * hackagebot classy-prelude 0.12.0 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.12.0 (MichaelSnoyman)
04:44:12 <merijn> Anyone here write indentation sensitive parsers using trifecta/parsec/parsers?
04:44:26 <merijn> Or the Utrecht parsing lib, I guess, whichever is easier
04:44:45 * hackagebot classy-prelude-conduit 0.12.0 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.12.0 (MichaelSnoyman)
04:44:47 * hackagebot classy-prelude-yesod 0.12.0 - Provide a classy prelude including common Yesod functionality.  http://hackage.haskell.org/package/classy-prelude-yesod-0.12.0 (MichaelSnoyman)
04:44:49 * hackagebot cabal-src 0.3.0 - Alternative install procedure to avoid the diamond dependency issue.  http://hackage.haskell.org/package/cabal-src-0.3.0 (MichaelSnoyman)
05:16:57 <JazzyEagle> Hello, all.  I was wondering if anyone has made an SSH Server in Haskell before?  I'm looking at the SSH package on Hackage, and I can't seem to figure out how exactly it works, and searching for a tutorial/documentation/example has led me nowhere.
05:18:15 <merijn> I would STRONGLY reconsider using ssh server packages in ANY language
05:18:44 <merijn> You're almost always better of using a robust and well tested SSH server like OpenSSH and trying to plug your functionality into that
05:19:10 <JazzyEagle> merijn: Then maybe I misunderstand how to use SSH properly.  I want to send data through an SSH tunnel.  I thought the SSH lib was to allow me to do that using OpenSSH.
05:19:19 <JazzyEagle> But I need to write both the client and the server.
05:19:40 <JazzyEagle> How would I utilize OpenSSH in my server code?
05:19:51 <merijn> afaict it's a library that implements the SSH protocol, rather than using OpenSSH
05:20:07 <JazzyEagle> Isn't that what the SSH lib is for?
05:20:10 <merijn> JazzyEagle: I think you're making things more complicated than they need to be
05:20:20 <merijn> JazzyEagle: Let's start from the beginning, what do you want to do?
05:20:51 <JazzyEagle> I want to create a server that sends and receives OSC messages (hosc lib) through an SSH Tunnel.
05:21:24 <merijn> JazzyEagle: And you only care about *nix environments?
05:21:28 <JazzyEagle> The hosc library does have some basic networking features, but I don't know how to get it going through an SSH tunnel.
05:21:56 <JazzyEagle> At this point in time, yes, though I ultimately would prefer to use code that is cross-platform, as I hope to branch out.
05:23:01 <merijn> JazzyEagle: The thing is that the ssh executable (as installed by openssh) can function as a pipe that writes it's local input to the input of a program on the remote side.
05:23:19 <merijn> JazzyEagle: So if I wanted to design something myself I would set it up like this
05:23:56 <merijn> JazzyEagle: Have a server daemon listening on a local unix socket on the filesystem, write a small "dumb" client that connects to that unix socket and writes all input on stdin to that socket
05:24:31 <merijn> JazzyEagle: Then on the client I would run the ssh executable (with the right flags) to start this dumb client on the server and then just write data from my client to ssh's stdin
05:25:08 <merijn> JazzyEagle: The end result would be a local program writing to the SSH stdin, which forwards it encrypted over the network to the stdin of my dumb program on the server, which forwards it to the real server
05:25:25 <merijn> JazzyEagle: This way you can avoid implementing any crypto yourself and any risks coming from that
05:26:01 <merijn> If you don't really need a server you can skip the "dumb client + unix socket" approach and just run the server directly via SSH, but that means one server per connection, whereas the unix socket approach let's you have a single server
05:27:23 <JazzyEagle> I think I understand.  Create the server software without any knowledge of SSH, but then utilize the SSH commands to tunnel the data to the program?
05:28:07 <merijn> JazzyEagle: Right
05:28:52 <merijn> JazzyEagle: Since the ssh executable just forwards it's own stdin to the remote program you only need to write your code so it can work via reading from/writing to stdin and then use the ssh command to tunnel it
05:29:22 <JazzyEagle> Wow, that DOES make it a lot easier!!  Thank you very much!!
05:29:27 * hackagebot machines-io 0.2.0.2 - IO utilities for the machines library  http://hackage.haskell.org/package/machines-io-0.2.0.2 (aloiscochard)
05:29:29 * hackagebot machines-process 0.2.0.2 - Process (system) utilities for the machines library  http://hackage.haskell.org/package/machines-process-0.2.0.2 (aloiscochard)
05:29:46 <merijn> JazzyEagle: Plus, you don't have to worry about security issues with your libraries :)
05:29:58 <JazzyEagle> Definitely.
05:30:28 <JazzyEagle> Though, there is a second component to this, that I just realized I didn't tell you about, not sure if it'll change your answer.
05:30:50 <JazzyEagle> I want to be able to conditionally store some of the OSC Messages, kind of like a mini git server of sorts...
05:30:57 <JazzyEagle> The conditional is whether or not the user is authorized to do so.
05:31:09 <JazzyEagle> So I will still need some sort of log in capabilities.
05:31:12 <maerwald> I am stuck withe type class error messages... the compiler cannot deduce the context, can someone help? http://lpaste.net/132466
05:31:41 <merijn> JazzyEagle: If you give every user their own SSH user and then track on the server which user ID it's running as that should be simple
05:32:13 <merijn> JazzyEagle: If you plan to use multiple users with the same SSH credentials then it might be different, but then the library wouldn't help you either, afaict
05:32:34 <JazzyEagle> Ok.  I'll look into that, then.  Thank you very much again for all your help!!!
05:33:13 <Saizan> maerwald: both var and val must appear in the type of every method of the typeclass
05:33:17 <merijn> maerwald: You're type signature doesn't list the SolvableConstraint, except in the few lines on line 36
05:33:49 <Saizan> maerwald: if it makes sense you could use functional dependencies or type families to work around that
05:34:07 <merijn> Oh, wait, I missed this was all inside the class declaration
05:34:27 * hackagebot codex 0.2.1.6 - A ctags file generator for cabal project dependencies.  http://hackage.haskell.org/package/codex-0.2.1.6 (aloiscochard)
05:34:36 <maerwald> adding the constraint everywhere does not help
05:34:58 <merijn> maerwald: Nope, because some of your functions only use one of the two parameters of your typeclass
05:35:09 <merijn> Like Saizan said, needs moar FunDeps/TypeFamilies
05:35:47 <maerwald> that is odd
05:35:53 <merijn> maerwald: Take "emptyVal :: SolvableConstraint var val => val" <- which instance should it select?
05:36:30 <maerwald> so it's a problem with MultiParamTypeClasses extension?
05:36:44 <merijn> maerwald: If you have "SolvableConstraint Char Bool", "SolvableConstraint Int Bool" and "SolvableConstraint Bool Bool", and it infers "emptyVal :: Bool" how does it select which of those three is the right instance?
05:37:09 <merijn> All three instance can provide "emptyVal :: Bool"
05:37:22 <merijn> And there's no way to tell GHC which you meant
05:37:34 <merijn> There's three solutions
05:38:44 <merijn> "emptyVal :: SolvableConstraint var val => Proxy var -> val" (i.e. add a proxy parameter to force the right instance), FunDeps to force a unique relation between the two parameters or TypeFamilies to eliminate one of the parameters and use an associated type that fills the role of the second parameter
05:38:52 <merijn> Which solution is best depends on your goal
05:39:52 <maerwald> fundeps sounds good
05:40:32 <merijn> See the GHC manual for details, it also mentions several papers describing how to use it/how it works, etc.
05:40:38 <kasabian> Hello! anyone knows where I can find the incomplete patterns checking part in GHC code?
05:40:55 <kasabian> or some documentation related?
05:41:18 <maerwald> thanks for the hintsd
05:41:19 <merijn> kasabian: You'll probably have better luck in #ghc or on the ghc-devs mailing list
05:41:29 <kasabian> thanks!
05:41:42 <merijn> I know Tom Schrijvers and his students are working exhaustiveness checking, but no clue where it is in the source
05:42:21 <kasabian> thanks a lot :)
05:45:42 <benzrf> hmmmm
05:46:09 <Denommus`> Hi
05:54:16 <bernalex> how do I serve a file (tar.gz in this case) with scotty?
05:55:45 <Denommus`> bernalex: tried to change the content type? 
05:56:39 <bernalex> I have 'serve = metaRequests' and 'metaRequests = get "/src" src'. now I need to write src.
05:56:51 <bernalex> (serve and metaRequests are a bit more complex than that)
05:57:06 <bernalex> so in src I want to getDataFileName "data/src.tar.gz" -- and then I want to serve that as the GET reply
05:57:36 <bernalex> is this even something people do? IDK webdev lol. maybe I shouldn't use GET at all.
05:57:49 <Denommus`> It's definitely GET
05:58:06 <Denommus`> But I don't know scotty and I'm on a phone, sorry 
05:59:03 <merijn> I don't understand the use of the term "smallest set" to describe the inductive definition of infinite set?
05:59:05 <bernalex> OK. well, src :: ActionE () and getDataFileName "data/src.tar.gz" :: IO FilePath.
05:59:44 <bernalex> so I need to serve that file and then say 200 if it worked. IDK how I'm supposed to do this though. I'll try searching around I guess.
06:00:25 <bernalex> my net connection is so horrid here, I thought I'd try IRC first, since that actually works for some secs per minute lol.
06:03:50 <bernalex> I'm pretty sure I want (something with that data file) >> return jsonSuccess. heh.
06:04:15 <mauke[1]> merijn: can you give an example?
06:04:19 <bernalex> oh actually I don't need to return because jsonSuccess is already an ActionE (), but.
06:04:44 <mauke[1]> json sounds wrong if you want to serve a plain file
06:05:35 <bernalex> mauke[1]: oh derp that's just the empty json object. never mind me.
06:05:52 <merijn> mauke[1]: "The set of terms is the smallest set T such that 1) {true, false, 0} \subset T; 2) if t_1 \elem T, then {succ t_1, pred t_1, iszero t_1} \subset T; 3) if t_1 \elem T, t_2 \elem T, and t_3 \elem T, then 'if t_1 then t_2 else t_3' \elem T."
06:06:30 <mauke[1]> well, without "smallest" there are infinitely many such sets
06:07:10 <mauke[1]> e.g. if you've found such a T, you can form T \union { ur_mom }
06:07:17 <mauke[1]> which also satisfies all conditions
06:07:26 <merijn> eh, so it's limiting it to the rules given
06:07:31 <merijn> *oh
06:07:33 <mauke[1]> right
06:07:43 <merijn> I'm used to natural deduction notation where that's implicit
06:08:49 <bernalex> OK I'm pretty sure I should use Web.Scotty's file function
06:08:55 <bernalex> now to play monad burrito poker
06:12:28 <bernalex> :t getDataFileName
06:12:29 <lambdabot> Not in scope: ‘getDataFileName’
06:13:52 <bernalex> file =<< liftIO (getDataFileName "data/src.tar.gz") -- might be correct maybe
06:19:29 * hackagebot machines-directory 0.2.0.2 - Directory (system) utilities for the machines library  http://hackage.haskell.org/package/machines-directory-0.2.0.2 (aloiscochard)
06:21:53 <Guest73173> Test
06:22:52 <Guest73173> Monad
06:23:19 <aloiscochard> Guest73173: that word is forbidden here
06:24:06 <bernalex> gah. how does Paths work with "special" characters? foo-bar was not foo_bar, presumably, judgeing by the linker error.
06:24:29 * hackagebot codex 0.2.1.8 - A ctags file generator for cabal project dependencies.  http://hackage.haskell.org/package/codex-0.2.1.8 (aloiscochard)
06:24:59 <bernalex> s/eing/ing/
06:25:13 <geekosaur> you should be able to see the actual name somewhere under dist/ ?
06:26:05 <bernalex> geekosaur: that uses regular dashes, so foo-bar
06:27:12 <bernalex> hmmm wait it works in cabal repl
06:28:06 <bernalex> import Paths_foo_bar; getFileName "data/src.tar.gz" -- gives me the IO FilePath I expect.
06:28:13 <bernalex> so why the linker error on cabal build? hmmm
06:28:40 <bernalex> might it be sandbox related?
06:30:22 <bernalex> getDataFileName (not getFileName as I erronously wrote above) returns "/home/alexander/git/tempuhs-server/.cabal-sandbox/share/x86_64-linux-ghc-7.8.4/tempuhs-server-0.0.0/data/src.tar.gz" -- I have no such file. =/
06:31:03 <c_wraith> @unmtl WriterT [a] (StateT [b] IO c)
06:31:03 <lambdabot> Plugin `unmtl' failed with: `WriterT [a] (StateT [b] IO c)' is not applied to enough arguments, giving `/\A. (StateT [b] IO c) (A, [a])'
06:31:13 <c_wraith> @unmtl WriterT [a] (StateT [b] IO) c
06:31:13 <lambdabot> (StateT [b] IO) (c, [a])
06:31:38 <c_wraith> @unmtl StateT [a] (WriterT [b] IO) c
06:31:38 <lambdabot> [a] -> (WriterT [b] IO) (c, [a])
06:33:35 <bernalex> hm. I have another few programs with data-files. they build fine, and don't put anything in .cabal-sandbox.
06:36:58 <Veyn> :t (<**>)
06:37:00 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
06:41:53 <bernalex> hm ok doing cabal install in fresh sandboxes for programs that work make .cabal-sandbox/share/x86_64-linux-ghc-7.8.4/program-version/data/file
06:42:04 <bernalex> this doesn't happen with the program I'm curerntly hacking on. anyone have any ideas?
06:44:30 * hackagebot unlambda 0.1.4 - Unlambda interpreter  http://hackage.haskell.org/package/unlambda-0.1.4 (abbradar)
06:46:17 <phaazon> hey
06:46:24 <phaazon> https://gist.github.com/phaazon/c792ab5415918858b2cd
06:46:32 <phaazon> my own FRP implementation (push pull)
06:46:44 <phaazon> I take feedback, because even though that works
06:46:56 <phaazon> I might haven't seen traps nor hidden drawbacks
06:46:58 <Denommus`> phaazon: I'm doing a AFRP library for OCaml 
06:47:04 <phaazon> well
06:47:11 <phaazon> I turned around AFRP
06:47:12 <phaazon> (netwire)
06:47:18 <phaazon> it's not my cup of tea
06:47:25 <Denommus`> phaazon: having problems implementing ArrowLoop in a strict language 
06:47:42 <Denommus`> phaazon: my library is taking some design decisions different from Netwire 
06:47:51 <phaazon> :)
06:47:52 <phaazon> well
06:47:54 <Denommus`> phaazon: there's no concept of inhibition 
06:48:03 <phaazon> I like very well the concept of push-pull
06:48:15 <phaazon> it suits a lot of domains
06:48:27 <Denommus`> phaazon: if you want something like inhibition, you use Maybe a ('a option in OCaml) 
06:48:38 <phaazon> yeah I know
06:48:44 <phaazon> my AFRP framework worked like that
06:49:01 <phaazon> data Auto t a b = Auto { runAuto :: t -> a -> (b,Auto t a b) }
06:49:09 <phaazon> type Interval t a b = Auto t a (Maybe b)
06:49:18 <phaazon> but that is boring when using the Category instance
06:49:28 <phaazon> that's why implicit inhibition is better to me
06:49:30 * hackagebot brainfuck 0.1.0.1 - Brainfuck interpreter  http://hackage.haskell.org/package/brainfuck-0.1.0.1 (abbradar)
06:51:12 <funfunctor> Hi
06:51:31 <funfunctor> Is XsdToHaskell a well maintained tool?
06:51:36 <Denommus`> phaazon: I don't need to exactly worry about instances because of the module system 
06:52:00 <phaazon> :)
06:52:18 <funfunctor> from the HaXml package
06:52:36 <funfunctor> XsdToHaskell generates a weird looking import,   import Http.V''schemas'opengis'net'gml'3'1'1'base'gml'xsd as Gml
06:52:58 <phaazon> ahah, it's indeed weird funfunctor 
06:53:50 <funfunctor> phaazon: I assume that comes from <import namespace="http://www.opengis.net/gml" schemaLocation="http://schemas.opengis.net/gml/3.1.1/base/gml.xsd"/>
06:53:59 <funfunctor> but how to fix that?
06:55:48 <funfunctor> oh right, I would first need to create a parser for everything in http://schemas.opengis.net/gml/ before anything else?
06:56:40 <maerwald> merijn: it works better with type families, but after introducing another default function I get similar "could not deduce" error messages: http://lpaste.net/132471
06:56:45 <maerwald> I think I'm almost there
07:00:15 <merijn> maerwald: Well, yes, because that doesn't make sense
07:00:16 <tar_> what does prof output mean when it lists an item like "filter.(...)"?
07:00:31 <maerwald> merijn: it works without "isConsitent" just fine
07:00:46 <merijn> maerwald: Line 24 has "getNeighbours var" which has type "var -> [var]"
07:00:53 <merijn> And then you fmap over that
07:01:37 <maerwald> merijn: yeah, that's what it should do :)
07:01:42 <merijn> But the lambda function that you fmap has "\x -> x /= v" where "x :: var" because getNeighbours returns [var]", but "v :: Val var" according to the signature of consistent
07:02:05 <maerwald> oh
07:02:13 <maerwald> so I have to retrieve it first
07:02:35 <maerwald> but I don't have access to the constructor :/
07:02:56 <merijn> maerwald: You have to either turn the "var" into a "Val var" or the "Val var" into a var
07:03:08 <maerwald> merijn: how to do that without a constructor?
07:03:45 <merijn> I don't know? I don't know exactly what you're trying to do
07:04:04 <merijn> But since "var" and "Val var" are different types comparing them for (in)equality is not a sensible operation
07:04:26 <maerwald> merijn: ah wait... I can just define "retrieve :: Val var -> var" and let it be implemented by the instance
07:04:31 * hackagebot brainfuck 0.1.0.2 - Brainfuck interpreter  http://hackage.haskell.org/package/brainfuck-0.1.0.2 (abbradar)
07:04:51 <merijn> maerwald: Yes, if that's a sensible operation
07:07:04 <Eduard_Munteanu> Is there a common function to sanitize filenames? E.g. mangle ".." into something that doesn't actually point to the parent dir.
07:08:21 <merijn> Eduard_Munteanu: Usually there's an "expand to absolute path" function
07:08:27 <mauke[1]> replace by UUID
07:08:29 <merijn> Eduard_Munteanu: Then you can restrict the allowed prefixes
07:08:53 <indiagreen> there is makeValid, but it sanitises filepaths and not filenames and so wouldn't do anything to “..”
07:09:26 <Eduard_Munteanu> I actually want to mangle the filename into something that can be related to the original name.
07:09:35 <Eduard_Munteanu> (by a human)
07:09:47 <mauke[1]> where does your input come from?
07:10:20 <Eduard_Munteanu> mauke[1], users uploading files, for simplicity I preserve the original filename.
07:10:31 <mauke[1]> that sounds like a terrible idea
07:11:00 <Rembane> Save the filename somewhere, if it's important to you, but don't use it as the new filename for the file.
07:12:13 <Eduard_Munteanu> I suppose I could keep track of names somewhere else than the filesystem, to allow for flexible names.
07:12:25 <mauke[1]> you could store the name in a file
07:12:29 <Eduard_Munteanu> Yes.
07:12:45 <mauke[1]> or in a symlink, for extra magic :-)
07:13:07 <Eduard_Munteanu> That's still in the filesystem, though.
07:13:25 <Eduard_Munteanu> (I'd have to validate/mangle the symlink name)
07:13:29 <mauke[1]> why?
07:13:37 <mauke[1]> the symlink name could be fixed
07:14:10 <Eduard_Munteanu> mauke[1], but then I can just mangle the original filename. :)
07:14:19 <bernalex> anyone feel like some debugging? it would be tremendously useful is someone could clone my repo, apply a git patch, and see if they get a linker error when compiling in a sandbox....
07:14:21 <mauke[1]> no, don't mangle
07:14:38 <mauke[1]> you could have uploads/42/{name,content}
07:14:45 <Clint> bernalex: what's the linker error?
07:15:10 <Eduard_Munteanu> mauke[1], oh, you mean in the symlink *target*?
07:15:23 <Eduard_Munteanu> That is trippy, yeah.
07:15:23 <mauke[1]> yes
07:16:35 <mauke[1]> if you do it the other way, you have to deal with names containing slashes, ".", "..", null bytes, random other bytes, and even length restrictions on file names
07:16:44 <mauke[1]> and that depends on your file system
07:16:54 <Eduard_Munteanu> Right.
07:17:07 <shergill-work> so i'm probably doing something dumb, but when i try and run `cabal upload` on https://github.com/suhailshergill/extensible-effects i get the error about -Werror not being recommended (<https://github.com/suhailshergill/extensible-effects/issues/46>). this is despite my attempts to guard the -Werror flag in the cabal file: <https://github.com/suhailshergill/extensible-effects/blob/develop/extensible-effects.cabal>
07:17:44 <merijn> shergill-work: I would expect that the cabal check is just very naive and doesn't consider guards around -Werror
07:18:02 <geekosaur> that's my recollection from last time someone asked about it
07:18:17 <bernalex> Clint: the linker error is entirely reasonable. it complains about not finding a data-file, which is not put in .cabal-sandbox like it should be!
07:18:37 <shergill-work> merijn: that's what i suspected. but i'm curious how lens manages to upload, unless edwardk has a separate branch solely for hackage uploads
07:19:01 <bernalex> Clint: I have added a data-files entry, and I use getDataFileName on this. I have done this with other packages in the past with no trouble. but what's happening here is that it's not put in .cabal-sandbox/share/ and so on like it should.
07:19:08 <merijn> Manual upload? Does that have the same check?
07:20:34 <shergill-work> merijn: no clue, but i intend to give that a shot when i get back home
07:26:16 <merijn> edwardk: Awake yet? :p
07:26:23 <dolio> shergill-work: That just started getting rejected a couple weeks ago.
07:26:34 <dolio> Before that it complained but didn't do anything.
07:26:49 <geekosaur> now I'm wondering if I should just be giving answers instead of encouraging this person on -beginners to work things out themself
07:27:07 <maerwald> merijn: the error just shifts :D
07:27:16 <merijn> And for anyone else, does anyone have the link to Lennart's talk on "better compile errors in haskell"? It was a 15-20 minute talk I think at the haskell implementors workshop
07:27:16 <maerwald> this is insane
07:28:22 <ion> merijn: If you find it, I'd be interested as well, thanks.
07:28:50 <maerwald> if any1 has a clue http://lpaste.net/132471 :/
07:28:55 <maerwald> stuck with type families still
07:29:29 <Denommus`> > mfix (:) 
07:29:30 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ [a]
07:29:30 <lambdabot>      Expected type: a -> [a] -> a
07:29:30 <lambdabot>        Actual type: a -> [a] -> [a]
07:29:49 <Denommus`> mfix (:[]) 
07:30:03 <Denommus`> > mfix (:[]) 
07:30:07 <lambdabot>  mueval-core: Time limit exceeded
07:30:07 <orion> In general, how does one design a deepseq instance for a record type? Is deriving Generic good enough?
07:30:17 <mauke[1]> maerwald: that looks like you want scoped type variables
07:30:19 <Denommus`> Hm 
07:30:37 <mauke[1]> or maybe just remove the type signature if that doesn't make the code ambiguous
07:30:46 <merijn> ion: Ah, I've found it, but it appears to be a rather low quality video, I remember there being a better one: https://www.youtube.com/watch?v=rdVqQUOvxSU
07:31:13 <maerwald> mauke[1]: adding ScopedTypeVariables works :D
07:31:22 <maerwald> now I am full of language extensions
07:31:40 <maerwald> {-# LANGUAGE ScopedTypeVariables, FlexibleInstances, UndecidableInstances, MultiParamTypeClasses, Rank2Types, FlexibleContexts, TypeFamilies #-} <- probably missing some cool stuf, lol
07:32:16 <Denommus`> maerwald: I mostly avoid extensions 
07:32:19 <mauke[1]> UndecidableInstances? /me raises eyebrows
07:32:39 <maerwald> mauke[1]: I thought it was cool^^ no... just experimenting with random things
07:32:51 <dolio> maerwald: Rank2Types is the same as RankNTypes now.
07:32:56 <maerwald> oh
07:32:58 <mauke[1]> that's the one that can cause infinite loops in the type checker
07:34:05 <Denommus`> Anyone has an idea on how to implement mfix in a language strict by default? 
07:34:23 <Denommus`> Like OCaml 
07:38:10 <bernalex> maerwald: I know you're just playing around, but UndecidableInstances are usually a sign of YDIW. just a FFR if you ever get the idea to use it in production code.
07:38:31 <shergill-work> dolio: oh. and same issue for manual upload as well?
07:38:36 <dolio> Yes.
07:38:40 <merijn> What does FFR mean?
07:38:42 <dolio> There's an issue report.
07:38:50 <merijn> bernalex: Also, UndecidableInstances are perfectly fine
07:38:54 <frerich> For Future Reference?
07:38:55 <bernalex> merijn: 'for future reference'.
07:38:56 <ion> merijn: thanks
07:38:57 <dolio> So they're aware of it.
07:39:06 <bernalex> merijn: BTW did you mean https://www.youtube.com/watch?v=rdVqQUOvxSU
07:39:16 <shergill-work> dolio: gotcha. got a link handy?
07:39:25 <c_wraith> Well.  A morning spent debugging leads to the realization that I'm bad at math.  yay!
07:39:26 <merijn> bernalex: Yeah, I just linked that earlier ;)
07:39:32 * hackagebot diagrams-contrib 1.3.0.2 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-1.3.0.2 (BrentYorgey)
07:39:47 <bernalex> merijn: many things are "perfectly fine" viewed isolated, but in general I find it a sign of YDIW.
07:39:52 <bernalex> merijn: oh, missed that, sorry.
07:39:55 <c_wraith> (My code was correct, my expected answers were wrong)
07:39:58 <merijn> You need to be a bit careful using UndecidableInstances, but it's necessary for a bunch of things and perfectly safe
07:40:14 <merijn> FSOV of safe that means "no issues at runtime"
07:40:39 <c_wraith> Really, it's usually fine at compile time too, unless you allow overlapping instances
07:40:41 <dolio> shergill-work: https://github.com/haskell/cabal/issues/2527
07:40:57 <c_wraith> The compiler will complain if it's not fine when there is no overlapping
07:40:57 <bernalex> c_wraith: that's a cute mix, yes.
07:41:05 <merijn> I mean, UndecidableInstances means it either 1) compiles and works or 2) doesn't compile
07:41:22 <shergill-work> dolio: thanks
07:41:30 <merijn> Overlapping/Incoherent and friends are the ones to worry about
07:42:19 <dolio> Really, use of undecidable instances is mainly telling you that fundeps aren't that good. :)
07:42:36 <tdammers> or that you are overthinking things :D
07:42:37 <dolio> Most of the time.
07:42:48 <merijn> dolio: I strongly prefer TypeFamilies over fundeps, but I've been told fundeps infer better
07:42:53 <c_wraith> well.  It's telling you that fundeps allow arbitrary computation at compile time, and sometimes that requires more than structural recursion to complete
07:42:56 <bernalex> tdammers: that's my point really
07:42:59 <merijn> But since I always write out types anyway I don't care about inference :p
07:43:03 <bernalex> along with MultiParamInstances.
07:43:24 <maerwald> well, but now I know that MultiParamInstances is really nasty anyway... since it didn't work like I expected it to
07:43:34 <maerwald> so I had to switch to type-families and make one "parameter" implicit
07:44:12 <maerwald> unless you don't give default implementations ofc
07:44:17 <bernalex> you can do lots of really cute things with MultiParamInstances. only to realise you should have been doing something a lot simpler.
07:44:20 <bernalex> IME.
07:45:05 <Denommus`> ML style modules are nicer than MultiParamInstances
07:45:34 <bernalex> basically, you do really cool and complicated stuff, feel like a genius when it works, show it to edwardk, realise that you're an idiot and that edwardk is right and you are wrong, copy-paste edwardk's improved & much simpler code and use that instead...
07:45:36 <bernalex> IME... :p
07:45:55 <dolio> merijn: The real annoyance is that the termination conditions for fundeps don't cover the associated type case very well, which is by far, I think, the common case.
07:46:06 <edwardk> yes, but then you learn and next time the improvement I can offer is less pronounced ;)
07:46:29 <mauke[1]> {-# LANGUAGE EdwardK #-}
07:46:50 <bernalex> edwardk: yes, you do learn a lot in this process.
07:47:56 <mulbee> hello. i want to define a type "Log" like http://lpaste.net/132474, but type check fails. how can i define data type like it?
07:47:58 <merijn> edwardk: I think I asked you not too long ago, but I forgot the answer. What's the state of parsing indentation aware grammars using parsers/trifecta
07:48:24 <merijn> +?
07:48:39 <edwardk> well, i have a parser for it, i could ship it if i had half a day
07:48:51 <mulbee> error detail is: Expected a constraint, but ‘PersistEntityBackend a’ has kind ‘*’ …
07:48:52 <merijn> edwardk: But you don't for the next gazillion years? ;)
07:49:08 <mauke[1]> mulbee: so PersistEntityBackend is not a class?
07:49:18 <edwardk> merijn: i hop on a plane in the next couple of days then my next 30 odd days are spoken for
07:49:33 <edwardk> and i'm rather frantically trying to work out some operad code and get slides done in the meantime
07:49:51 <edwardk> so while not a gazillion years, you're likely a month and a half out in my ability to timeslice it in
07:49:59 <merijn> edwardk: Rats...is it somewhere visible so I could see if I can rip it off to hack together my own thing?
07:50:05 <orion> Anyone know what I am getting this error?: No instance for (NFData Text) arising from a use of ‘Control.DeepSeq.$gdmrnf’ -- the code is: data Foo = Foo { foo :: Text } deriving (Show, Generic); instance NFData Foo
07:50:08 <bernalex> edwardk: prioritise your game code instead. :p
07:50:12 <edwardk> merijn: i don't think so
07:50:22 <edwardk> actually
07:50:26 <merijn> edwardk: You're killing me, man! :p
07:50:32 <edwardk> you can steal the layout code from the scala implementation of ermine if you really want
07:50:38 <edwardk> the haskell version is a port of that
07:51:12 <srhb> orion: Presumably that standalone instance requires the underlying fields to also be instances of NFData
07:51:27 <edwardk> merijn: https://bitbucket.org/ermine-language/ermine-scala/src/42a54d8b547587f7c93b0a11c8338e06617cb5ea/core/src/main/scala/com/clarifi/reporting/ermine/parsing/?at=default
07:51:34 <edwardk> you may have to do some digging
07:51:47 <mulbee> mauke[1]: oh, i miss it! PersistEntityBackend is just a data type.. but can you tell me the meaning of "backend ~ PersistEntityBackend val" in : get :: (MonadIO m, backend ~ PersistEntityBackend val, PersistEntity val) => Key val -> ReaderT backend m (Maybe val)
07:51:50 <srhb> orion: Whether or not it makes sense, instance NFData Text should clear it up
07:51:56 <merijn> edwardk: Thanks. Time to see if I can read Scala :p
07:51:58 <orion> srhb: But according to this, it's already defined: https://hackage.haskell.org/package/text-1.2.0.4/docs/Data-Text.html#t:Text
07:52:12 <srhb> orion: And you are using Strict Text?
07:52:16 <merijn> orion: Your version might be old?
07:52:16 <orion> Yes.
07:52:22 <orion> Nope, I am using 1.2.0.4.
07:52:26 <srhb> Hmm.
07:52:41 <mauke[1]> mulbee: well, A ~ B means the two types A and B have to be equal
07:52:43 <edwardk> but in the end tracking if you're at the beginning-of-line and the stack of layout contexts and tweaking that in the character recognizer, and adding a 'layout' parser that reads 'virtual' tokens so you can get virtual semicolons and virtual }'s is what you need
07:53:10 <edwardk> that's not _quite_ good enough for haskell's 'error' based layout, but its close enough you can't really tell
07:53:26 <mulbee> mauke[1]: i see. thanks a lot!
07:53:29 <mauke[1]> mulbee: so I guess this asserts that the type backend must have the form 'PersistEntityBackend val' for some type val
07:53:30 <merijn> edwardk: tbh I don't need anything like haskell's flexibility
07:53:36 <maerwald> edwardk: someone on stackoverflow claimed that you said "give" from the Given class was very bad and shouldn't be used or something... time to verify :P
07:53:45 <merijn> edwardk: I'm defining a grammar from scratch so I can easily restrict it to only allow the easy cases
07:53:46 <edwardk> maerwald: they were correct
07:54:01 <edwardk> merijn: then what i described above should work fine
07:54:04 <maerwald> edwardk: what's the alternative? implicit parameters?
07:54:30 <edwardk> maerwald: i usually use real reflection and a type argument to plumb it
07:54:49 <maerwald> edwardk: ok, so it's about the Given class specifically?
07:54:56 <mauke[1]> orion: what are your imports?
07:54:57 <edwardk> My experience is everytime someone uses Given eventually they run into a situation where they need more than one
07:54:59 <edwardk> yes
07:55:14 <edwardk> implicit parameters can't be used as superclasses of constraints
07:55:25 <edwardk> class (?x :: Int) => Foo a -- doesn't work
07:55:33 <edwardk> class Given SystemConfig => Foo a  -- does
07:55:45 <orion> mauke[1]: Control.Exception, Control.DeepSeq, Data.Text, Data.Typeable, GHC.Generics
07:56:01 <edwardk> so the main role Given has is to be used when you absolutely need instances that depend on global configuration
07:56:17 <edwardk> but you're better off with Reifies for almost all usecases except that
07:56:23 <edwardk> and even then you lose a lot of surety
07:56:58 <edwardk> i'll likely exile Given to a supplemental package and discourage its use, but there are enough legitimate users i can't outright remove it
07:57:11 <maerwald> edwardk: if you have the time you might want to clear up the confusion here https://stackoverflow.com/questions/30140175/moving-from-static-configuration-to-dynamic-configuration because that's how it all started
07:58:56 <mauke[1]> orion: ok, that is weird. the instance is in Data.Text, so that should be the right module
07:59:15 <mauke[1]> the instance is behind #ifdef HAVE_DEEPSEQ, but according to the cabal file that should always be set
07:59:44 <orion> My code is here: http://lpaste.net/132446
08:00:50 <edwardk> maerwald: done
08:01:08 <maerwald> edwardk: heh, thanks
08:01:23 <bernalex> edwardk: do you play pokémon?
08:01:39 <bernalex> I just got Pokémon Y. it's pretty cool.
08:01:42 <edwardk> not usually
08:01:50 <Welkin> what an odd question coming from a pokemon itself
08:01:57 <Welkin> a wild bernalex appears!
08:02:01 <edwardk> hah
08:02:06 <raichoo> pokeman?
08:02:45 * bernalex uses Referential Transparency against the Java Programmer
08:02:52 <bernalex> It's Super-Effective!
08:02:56 <Welkin> raichoo too
08:03:13 <Welkin> I never liked raichu, so I kept my pikachu
08:03:20 <raichoo> Pokemon are slowly but surely taking over #haskell
08:03:23 <bernalex> is Raichoo an evolved Achoo?
08:03:31 <edwardk> "bernalex used Haskell. It's super effective!"
08:03:43 <Welkin> oh
08:03:46 <Welkin> pokemon have types
08:03:48 <Welkin> like haskell
08:04:00 <bernalex> Welkin: I'm a Glaswegian type pokémon
08:04:34 * hackagebot hXmixer 0.3.0.0 - A Gtk mixer GUI application for FreeBSD  http://hackage.haskell.org/package/hXmixer-0.3.0.0 (colinrmitchell)
08:04:46 <maerwald> Welkin: isn't pokemon a type?
08:05:14 <geekosaur> kind, perhaps
08:05:29 <bernalex> maerwald: no it's a typeclass. you need to implement four moves, hp, ev levels, etc to make your type an instance of it.
08:06:03 <maerwald> bernalex: the behavior and appearance is infered?
08:06:09 <maerwald> or derived
08:06:29 <bernalex> yes. GHC is *that* good.
08:06:33 <maerwald> :D
08:06:37 <bernalex> -XDerivingPokemon
08:07:49 <suppi> * bernalex uses Referential Transparency against the Java Programmer
08:07:50 <suppi> haha
08:11:04 <quchen> Pokemon is a kind. Of error handling.
08:14:35 * hackagebot pandoc-citeproc 0.7.0.2 - Supports using pandoc with citeproc  http://hackage.haskell.org/package/pandoc-citeproc-0.7.0.2 (JohnMacFarlane)
08:17:40 <orion> Anyone know why this command is trying to unregister the system deepseq as opposed to the one in my sandbox?: cabal sandbox hc-pkg -- unregister --force -- deepseq
08:17:53 <orion> The error I get is: ghc-pkg: /opt/ghc/7.8.4/lib/ghc-7.8.4/package.conf.d/deepseq-1.3.0.2-63a1ab91b7017a28bb5d04cb1b5d2d02.conf: removeLink: permission denied (Permission denied)
08:18:03 <m4lvin> dear pokémons, can you tell me why "fromEnum (P n) = n" uses a lot of memory, according to my .prof file?
08:18:27 <m4lvin> it generates way more entries than the number of different values it should be called on.
08:18:51 <quchen> What's the code? What's the .prof file?
08:22:08 <m4lvin> hm, i don't have a small&public example right now, but this is the .prof http://lpaste.net/132477
08:25:23 <m4lvin> My question is basically if functions like == should be as fast on a type like (P Int) as they are on Int itself.
08:29:43 <Rotaerk> m4lvin, IIRC it should be if P is the type constructor for a newtype
08:29:57 <Rotaerk> but not necessarily if it's a data
08:30:26 <Cale> m4lvin: How are you getting from what's in that .prof file to "fromEnum is using a lot of memory"? It's barely appearing in the profile as far as I can see.
08:31:16 <Cale> and it's 0% allocation in all cases
08:32:02 <Cale> (which makes sense, because it shouldn't be doing any allocation)
08:32:45 <m4lvin> ah, ok. but what is the "entries" number then?
08:33:02 <Cale> The number of times that cost centre was entered.
08:33:25 <Cale> i.e. how many times did this piece of code run
08:33:40 <m4lvin> ah, so this says nothing about time and memory.
08:33:44 <Cale> right
08:39:39 <hexagoxel> orion: no idea, looks like a bug. what is the -v output?
08:43:59 <lpaste> Testeree pasted “cabal install stackage” at http://lpaste.net/132481
08:45:46 <Testeree> any stackage people here? cabal update && cabal install stackage fails with http://lpaste.net/132481 with ghc version 7.10.1 && arch linux kernel 4.0.1-1-ARCH
08:46:26 <ackthet> why not try archhaskell?
08:46:45 <ackthet> instead of cabal
08:47:34 <merijn> Because most linux package managers butcher your package database
08:48:28 <c_wraith> Ugh.  WHy are things like Strict WriterT not actually strict in the accumulator?
08:48:28 <orion> hexagoxel: I figured it out. Apparently the package was already removed from the sandbox without me knowing.
08:48:43 <orion> hexagoxel: Since it wasn't in the sandbox, it defaulted back up to the system level.
08:49:06 <maerwald> merijn: what do you mean by that?
08:50:07 <merijn> Exactly what I said? Several package managers try to directly edit the database to register things and have screwed up multiple times
08:50:11 <Testeree> ackthet, i am not so sure. I don't think it has the packages i &need*
08:50:36 <srhb> c_wraith: It's a bug. Use State
08:50:44 <srhb> c_wraith: I don't recall why it's not actually fixed yet.
08:50:57 <ackthet> ahh, you could build a package using their tools but yeah that takes a lot of work
08:50:59 <c_wraith> State?  Ewww.
08:51:11 <maerwald> merijn: I still cannot follow... you mean they manipulate the _user_ database?
08:51:25 <maerwald> merijn: because if someone runs cabal with root privileges... err
08:51:28 <srhb> c_wraith: Well, you can implement Writer via State, obviously.
08:51:42 <Testeree> anyone know the channel discussing stackage? should i approach #hackage instead?
08:52:06 <srhb> Testeree: I don't think there is such a channel, and I don't think #hackage is the place either. ymmv
08:52:06 <merijn> maerwald: Dunno, I've seen them mangle global database, but I don't linux, so I've only seen cases where someone came here after stuff broke
08:52:26 <c_wraith> srhb: I think I might be better off reimplementing it anyway, just to guarantee it's valid inside ListT.  >_>
08:52:37 <ackthet> Testeree: the problem is your ghc is too new
08:53:07 <srhb> c_wraith: https://mail.haskell.org/pipermail/libraries/2013-March/019528.html
08:53:13 <ackthet> I don't think they have a list for the arch version of ghc
08:53:18 <c_wraith> srhb: thanks for the link
08:53:24 <JoshieAS> anywone have a recommendation for a good tutorial on building compilers in Haskell?
08:53:29 <ackthet> least not when I tried a few weeks ago
08:53:36 <Testeree> ok
08:53:36 <maerwald> merijn: I think that's rather due to the fact that you have a) global packages for the whole system b) user-level packages on user level and c) sandbox-level packages
08:53:40 <srhb> JoshieAS: Write yourself a scheme, perhaps?
08:54:12 <Welkin> write yourself a scheme is quite good
08:54:17 <Welkin> there is also write yourself a haskell
08:54:26 <maerwald> and afaik all levels interact in some way, so it's not very nice to maintain for the user
08:54:43 <Welkin> http://dev.stephendiehl.com/fun/
08:54:46 <JoshieAS> I see, danke danke
08:54:50 <Welkin> "Write You a Haskell"
08:54:59 <merijn> JoshieAS: http://www.stephendiehl.com/llvm/ and http://dev.stephendiehl.com/fun/ ?
08:55:36 <JoshieAS> Thanks mucho
08:56:03 <merijn> JoshieAS: Also, the book Types and Programming Languages
08:56:06 <merijn> @where tapl
08:56:06 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
08:56:26 <merijn> JoshieAS: Not so much about implementing compilers, but about implementing type systems/type checkers/type inferrers
08:59:11 <hexagoxel> Testeree: works for me, on pretty much the same setup..
08:59:36 * hackagebot persistent-mongoDB 2.1.2.2 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-2.1.2.2 (GregWeber)
08:59:38 * hackagebot persistent-mysql 2.1.3.1 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-2.1.3.1 (GregWeber)
08:59:40 * hackagebot persistent-postgresql 2.1.5.1 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-2.1.5.1 (GregWeber)
08:59:42 * hackagebot persistent-sqlite 2.1.4.2 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-2.1.4.2 (GregWeber)
09:07:30 <JoshieAS> I keep seeing that the 'box' analogy is insufficient to describe functors and applicatives...
09:07:43 <JoshieAS> I see 'computational context' thrown around -- can someone explain computational context?
09:07:56 <johnw> the difference between a type 'a' and a type 'f a' is the f part
09:08:22 <johnw> that f is the context, and it may have computational relevance
09:08:48 <johnw> in the case of Maybe a, Maybe is the context of deciding whether the computation should continue
09:09:11 <JoshieAS> I see, so in [a], is the list the context in this case?
09:09:25 <johnw> as a context, [a] is the context of multiple choices for a
09:10:04 <JoshieAS> and Either a b, Either is the context of deciding a or b?
09:10:14 <johnw> the 'box' analogy is bad because it refers to representation, rather than meaning
09:10:44 <johnw> Either a b is the context of whether the computation should immediately return an 'a', or continue the computation with 'b'
09:10:59 <johnw> as a type, it is just a decision between a or b
09:11:19 <johnw> but when you start talking about functors, then this notion of context takes on slightly different meanings depending on the type you're talking about
09:11:33 <JoshieAS> ah, it's starting to make more sense
09:13:02 <johnw> in the simplest case, Identity is the context of having a context :)
09:13:27 <JoshieAS> johnw: thanks for your clear explanations
09:15:52 <Cale> I really dislike the term "context"
09:15:58 <Cale> At least used in that sense
09:16:04 <JoshieAS> yeah?
09:16:45 <Cale> It's unhelpful. An IO String isn't a String in the "IO context", it's a completely different sort of thing altogether.
09:17:16 <Cale> (In that case, it's a description of some actions which could be carried out that will produce a String if they finish successfully.)
09:17:34 <breadmonster> Cale: Isn't that the definition of a context?
09:17:57 <Cale> breadmonster: If you already know enough about what "context" is supposed to mean, I suppose.
09:18:06 <ion> Playing the devil's advocate, perhaps it's the *type* String in the "IO context".
09:18:11 <Cale> But it's not really an appropriate word to use.
09:18:18 <ion> But i agree with you.
09:18:20 <johnw> Cale: what do you use?
09:18:28 <breadmonster> Fair enough, but tbh all definitions are postulated post hoc.
09:18:30 <dualerium> Hi, what does the # means at the ends of those functions? https://downloads.haskell.org/~ghc/7.4.2/docs/html/libraries/integer-gmp-0.4.0.0/GHC-Integer-Logarithms.html
09:18:39 <int-index> 'What I Wish I Knew When I Was Learning Haskell' states that 'lens is considered by many Haskellers to be deeply pathological'. Is that true? I used the library to great success.
09:18:45 <breadmonster> dualerium: They're dealing with unboxed values.
09:18:48 <c_wraith> duairc: it's a convention used by GHC to mark primitive functions
09:18:50 <johnw> int-index: it is not true
09:18:58 <johnw> int-index: it is the author's opinion
09:18:58 <c_wraith> duairc: sorry, meant dualerium 
09:19:25 <dualerium> ok, but is there a way to convert from Int# to Integer?
09:19:26 <int-index> johnw: probably the author shouldn't brand his opinion as 'many Haskellers'.
09:19:37 <johnw> he should not
09:20:09 <c_wraith> dualerium: sure, one of the Integer constructors takes an Int#
09:20:18 <breadmonster> Cale: unsafeCoerce :: Int -> Int# is a valid trick?
09:20:36 <Cale> breadmonster: I wouldn't.
09:20:45 <breadmonster> I'm not sure what the underlying representations are
09:20:48 <c_wraith> @src Integer
09:20:48 <lambdabot> data Integer = S# Int#
09:20:48 <lambdabot>              | J# Int# ByteArray#
09:20:50 <Cale> If you're going to be using Int#, you should just use the Int data constructor
09:20:52 <johnw> breadmonster: I think that will cause a segfault if you used the Int#
09:20:54 <breadmonster> Neither would I, but will it break anything?
09:20:55 <dualerium> oh, I wrote integerLog2# and the compiler says
09:20:56 <dualerium>     Not in scope: integerLog2
09:20:56 <dualerium>     Perhaps you meant integerLog2# (imported from GHC.Integer.Logarithms)
09:21:01 <Cale> hah, that definition of Integer is out of date
09:21:08 <johnw> oh, not a segfault
09:21:14 <c_wraith> dualerium: you need to enable the MagicHash extension to use values that end with #
09:21:20 <johnw> the value of the Int# would be the address of the Int box I suppose
09:21:22 <dualerium> ah
09:21:46 <breadmonster> Does Stephen Diehl turn up around here often?
09:22:06 <Cale> dualerium: # is not normally a valid part of an identifier -- this is done on purpose to make it clear which things are meant only for internal use.
09:22:08 <ion> int-index: What I Wish I Knew When I Was Reading "What I Wish I Knew When I Was Learning Haskell": "lens is considered by many Haskellers to be deeply pathological" is considered by many Haskellers to be deeply fallacious.
09:22:27 <johnw> ion++
09:22:47 <glguy> The section on lens, in addition to overstating the author's opinion, gets Prisms wrong
09:23:09 <breadmonster> Yeah.
09:23:11 <Cale> I don't know about "deeply pathological", but I think a fair number of people would consider some potential uses of lens to be unidiomatic.
09:23:13 <breadmonster> Does this come up often?
09:23:30 <Cale> The lens library is quite good, but it's really easy to abuse.
09:23:46 <glguy> That describes Haskell :)
09:23:47 <johnw> Cale: that is true of just about anything that has real power
09:23:59 <Cale> I'm not sure about that
09:24:02 <dualerium> thanks Cale and breadmonster 
09:24:37 * hackagebot esqueleto 2.2.1 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-2.2.1 (FelipeLessa)
09:24:47 <johnw> I suppose the trade-off is to constrain the expressivity to the very limited range that the author had in mind, or allow expressions he did not have in mind
09:25:13 <Cale> There are a lot of definitions that are in the lens library that I think ought not to be there, because they invite people to write code which will be needlessly difficult to read.
09:25:30 <Cale> But there is some subset of the lens library which is really a good thing
09:25:46 <johnw> Cale: you could always create a lens-basic package that only re-exports what you approve of
09:26:00 <Cale> I could, if I cared enough about this issue
09:26:03 <breadmonster> Cale edwardk: why are there so many operators in lens? Why not just keep the most general ones, and allow people to define their own?
09:26:06 <nshepperd> unsafeCoerce :: Int -> Int# doesn't seem to typecheck in ghci
09:26:15 <c_wraith> johnw: isn't that what lens-family and lens-family-core are about?
09:26:16 <Cale> breadmonster: Indeed, that's a large part of it
09:26:17 <nshepperd> Int# isn't of kind *
09:26:37 <Cale> c_wraith: I like more of what's in lens than what lens-family provides.
09:27:33 <Cale> and I don't like everything that lens-family provides either
09:27:57 <Cale> It has a bunch of the infix operators that I don't like, in particular.
09:28:40 <ion> breadmonster: You're free to import lens without the operators. But their naming follows patterns that aren't too difficult to grasp.
09:29:27 <breadmonster> ion: Sure, not that it's confusing, it's just that all the cool operators are taken :(
09:29:45 <breadmonster> Like all the cool wordpress subdomains.
09:29:55 <bennofs> just joined, but if anyone has not yet mentioned it yet, import Control.Lens.Combinators is lens without all operators
09:30:03 <bennofs> s/anyone/nbody
09:30:27 <Cale> bennofs: Yeah, I think I'm the reason that module exists :)
09:31:11 <bennofs> and Control.Lens.Operators has all the operators :)
09:31:37 <Cale> Let's put it this way: if you use lens as the examples in the lens documentation suggest that you ought to, then I probably won't like your code very much. :P
09:33:51 <orion> Has anyone ever gotten ghc-mod to work on 7.10.1?
09:34:03 <athan> orion: In the thicket right now :)
09:34:09 <nshepperd> ah, you have to use unsafeCoerce# to do an evil conversion from Int to Int#
09:34:23 <Cale> nshepperd: what?
09:34:27 <breadmonster> nshepperd: You can?
09:34:36 <Cale> You shouldn't have to use unsafeCoerce to do that, and I wouldn't do it.
09:35:06 <nshepperd> of course, you get nonsense results corresponding to the contents of the I# constructor
09:35:28 <nshepperd> yes, the proper way is to case match on the constructor
09:35:47 <nshepperd> I was just remarking on how the ordinary unsafeCoerce has the wrong kind
09:35:57 <Cale> ah, yeah
09:39:37 * hackagebot exact-pi 0.1.2.0 - Exact rational multiples of pi (and integer powers of pi)  http://hackage.haskell.org/package/exact-pi-0.1.2.0 (dmcclean)
09:39:41 <nshepperd> I# ((unsafeCoerce# :: Int -> Int#) 7) gives me 140475296535920 in one instance. and then 140475324886912 when I try it again
09:41:06 <nshepperd> so yes, the Int constructor has runtime representation, and unsafeCoercing it away doesn't do anything sane
09:41:22 <edwardk> Cale: you're one of several reasons. peaker IIRC was using the operators unqualified but the rest of the terms qualified
09:41:46 <Cale> ah :)
09:41:52 <edwardk> Cale: so it was a nice grand compromise whereby you could be satisfied and that other opposed view could also be satisfied
09:45:57 <zq> hm, his section on skolem escape is wrong
09:54:19 <orion> athan: FWIW, I was able to successfully build it from master on github.
09:58:56 <glguy> The operators are just the most visible part of lens, but not the interesting part. It's the generalizations of so many functions to their -Of variations that I find most compelling
10:05:30 <fotanus> Hey, I have a cabal package that creates only one executable, and I want to run a test suite against the executable, not my code. So much more like a functional test than a unity test. Does anyone have a pointer of an example of how to do that, ro something that can help me?
10:08:23 <athan> Does ghc-mod expect Cabal 1.18.x ?
10:08:53 <athan> or really, can GHC 7.8 not work with Cabal 1.22.x?
10:09:51 <bennofs> athan: the ghc library cannot be used with the Cabal 1.22 library in the same program
10:10:09 <bennofs> athan: since the ghc library depends on a fixed Cabal library version for getting the PKG database types IIRC
10:10:50 <bennofs> athan: GHC 7.10 lifts that restriction, which is why ghc-mod decided to support newer cabal versions only starting from GHC 7.10 (ghc-mod needs ghc the library can Cabal the library)
10:11:10 <hexagoxel> fotanus: maybe the package-tests that cabal-install uses are interesting for you
10:11:31 <athan> bennofs: Oh wow, okay thank you!
10:11:42 <hexagoxel> fotanus: see https://github.com/haskell/cabal/blob/master/cabal-install/tests/PackageTests/Exec/Check.hs
10:11:45 <fotanus> hexagoxel:  will check that, thank you very much
10:19:38 <magnap> What's the current consensus on using monad comprehensions for simple uses? I'm thinking mainly of this post http://dave.fayr.am/posts/2012-10-4-finding-fizzbuzz.html Go or no-go?
10:25:10 <mpickering> magnap: Not many people use monad comprehensions
10:26:05 <c_wraith> Hah.  That article I inspired...  years ago now.  Nice.
10:26:29 <roelof> why do I get this message (Not in scope: data constructor Maybe) on this code :  http://lpaste.net/132485
10:26:48 <c_wraith> roelof: Maybe isn't a data constructor.  I think you meant Just
10:27:03 <magnap> mpickering: I though so, but I though i'd ask anyway
10:27:20 <c_wraith> roelof: though that won't typecheck when you fix that error
10:28:09 <magnap> I re-implemented it with a helper function "helper bool result = if bool then return result else mempty". Is there a better/simpler way to replace the monad comprehension=
10:28:12 <magnap> *?
10:28:35 <roelof> c_wraith:  thanks, next error :  http://lpaste.net/132486
10:29:04 <roelof> here I try to add the first element of the second array to the first array 
10:29:19 <c_wraith> roelof: lists, not arrays.  But the big problem is that all elements in a list must have the same type
10:29:32 <c_wraith> roelof: and your type signature allows the two input lists to have different types inside them
10:29:45 <c_wraith> roelof: so there's no way to combine elements from the two lists into one output list
10:30:17 <roelof> c_wraith:  oke, how do I solve this . Use [a] -> [a] -> [a} maybe ?
10:30:42 <c_wraith> roelof: well, what are you trying to do, at a higher level?  What is the job of that function?
10:32:12 <roelof> c_wraith:  the function of that job is to make the ++ function of Data.List recursive because I want to practice recursion so hopefully I will get it now 
10:32:36 <c_wraith> roelof: so you want to reimplement (++)?
10:32:50 <roelof> c_wraith:  yes 
10:33:01 <c_wraith> roelof: in that case, you should probably start with the same type as (++)
10:33:04 <c_wraith> :t (++)
10:33:05 <lambdabot> [a] -> [a] -> [a]
10:33:28 <c_wraith> Notice the happy lack of `Maybe' in that type. :)
10:34:01 <ReinH> c_wraith: oh, Dave is a friend of mine. Cool.
10:34:38 <roelof> oke, I have changed that and I found out that the problem is in this part  [xs] ++ y 
10:34:53 <c_wraith> roelof: if you're trying to reimplement ++, you shouldn't use it in your solution! :)
10:35:47 <roelof> c_wraith:  how can I then add item y to the first array ? 
10:36:25 <c_wraith> roelof: the list ([] is an immutable singly-linked list in haskell - not an array!) type has two constructors.
10:36:33 <c_wraith> roelof: [] create an empty list
10:37:17 <c_wraith> roelof: x:xs creates a new list by putting the single element x at the front of an existing list, xs
10:38:01 <magnap> roelof: If you want it at the end (not recommended for performance), xs ++ [x] will do the trick
10:38:06 <roelof> c_wraith:  then I have a problem. I want to add something at the end of a list 
10:38:13 <arkeet> magnap: not if he's trying to implement ++ !
10:38:36 <arkeet> roelof: you can do it without putting anything on the end of a list.
10:38:41 <c_wraith> roelof: You can do it by putting something at the front of the list instead..  It's the natural operation for creating a list, so it's worth trying to figure it out that way
10:38:52 <magnap> arkeet: Sorry, hadn't caught that
10:39:45 <roelof> c_wraith:  maybe the other way around , put all the items of the first list to the front of the second list ? 
10:39:52 <magnap> In that case, I'd like to say: The only function other than (++) (or whatever you call your reimplementation) you'll need is (:)
10:40:14 <arkeet> roelof: that's more like it :-)
10:40:23 <roelof> oke, thanks 
10:40:28 <c_wraith> roelof: at the high level, yes.  At a more code-oriented level, this is where thinking about recursion comes into play. :)
10:40:53 <magnap> roelof: Exactly. Use pattern matching to check the base cases (empty lists)
10:40:57 <arkeet> in any case
10:41:06 <arkeet> when you're building a list (from scratch)
10:41:16 <arkeet> you have to figure out:
10:41:22 <arkeet> - is this list empty or not?
10:41:35 <arkeet> - if it's nonempty, what are the head and the tail?
10:42:16 <arkeet> and recursion comes in when building the tail
10:42:21 <ReinH> Say it with me, "what do you do with the empty list, what do you do with x cons xs?"
10:42:27 <magnap> The second can be done by pattern matching too, which IMO gives the cleanest code
10:42:41 <magnap> What ReinH said!
10:43:31 <roelof> oke, I have now this : plusplus' [x:xs] [yx] = plusplus' xs x:[yx]
10:43:46 <c_wraith> roelof: you almost certainly mean (x:xs) in the pattern
10:44:09 <c_wraith> roelof: and just ys for the other one
10:44:35 <c_wraith> roelof: you don't want [foo] in your list patterns unless you want to match on an exact-length list
10:44:45 <ReinH> rola: [x:xs] is a list containing a single list with at least one element, (x:xs) is a list containing at least one element.
10:45:08 <ReinH> [x:xs] matches [[1]], (x:xs) matches [1]
10:45:42 <roelof> oke, I changed it to this : plusplus' (x:xs) yx = plusplus' xs x:[yx] and see this error :  Couldn't match expected type a
10:46:46 <roelof> the type system of Haskell is killing me at the moment 
10:47:26 <Fuuzetsu> it's telling you your code is wrong, would you prefer it to just crash instead?
10:47:28 <johnw> it's killing you softly
10:47:30 <c_wraith> Nah, the type system is saving you.  It's saying "whoa, hold on.  This doesn't make any sense at all.  Don't run it, fix it!"
10:48:44 <johnw> Haskell's type system gives the computer a way to say, "I don't believe you know what you're doing yet."
10:49:02 <roelof> oke, but I do not have a clue where the error is 
10:49:24 <ReinH> johnw: is it strumming my pain with its fing... that just got awkward.
10:49:36 <KaneTW> roelof: well, what does it tell you
10:49:40 <ReinH> roelof: The error tells you
10:50:15 <johnw> ReinH: lol
10:50:36 <Denommus> what does <- mean in a guard condition?
10:50:45 <Denommus> like Right (_, d) <- mx
10:50:49 <KaneTW> view pattern?
10:50:52 <roelof> I try t o say that it have to run plusplus with the rest of the first list  and as second argument the the first item of the first list added to the second list
10:51:09 <exio4> Denommus: pattern guard, it's basically pattern matching on a guard
10:51:11 <enthropy> @quote evar
10:51:11 <lambdabot> benmachine says: let (\x -> case x of (\x -> x -> x) -> x -> x) = 0 in x / best view pattern evar
10:51:21 <KaneTW> or guard pattern, sorry
10:51:26 <KaneTW> whateve it was
10:51:31 <KaneTW> that allowed you to match inside guards
10:51:37 <KaneTW> pattern guards
10:51:38 <exio4> pattern guard is Haskell2010
10:51:41 <exio4> view patterns are an extension
10:51:43 <Denommus> exio4: thanks
10:52:44 <exio4> Denommus: if the pattern doesn't match, it'll try the next guard / equation, just like any condition in a guard, but it also binds variables :P 
10:52:45 <roelof> So where did I do the wrong thing
10:53:48 <infandum> Is it possible that the definition for toListM in https://hackage.haskell.org/package/pipes-4.1.5/docs/src/Pipes-Prelude.html#toListM is problematic because it is too lazy? It results in stack space overflows in big pipes?
10:53:52 <roelof> if I look what the editor says plusplus' is wrong 
10:54:17 <johnw> infandum: toListM must represent the entire list in memory
10:54:31 <infandum> johnw: True, but memory is not the same as stack space
10:54:41 <johnw> oh, indeed
10:54:50 <johnw> why do you ask if its problematic?
10:54:56 <infandum> johnw: I think it's too lazy. I replaced it with fold and my huge pipe works just fine.
10:55:09 <infandum> johnw: Before it was giving stack space overflows.
10:55:33 <johnw> oh, quite likely
10:55:44 <infandum> that is, this horrible definition did not result in stack space overflows: P.fold go [] id
10:55:50 <johnw> i wonder if applying codensity here would fix that right up
10:55:54 <infandum> where go just cons the list
10:55:56 <johnw> you should create an issue on github
10:56:04 <roelof> c_wraith:  can you help me one more time 
10:56:10 <infandum> it probably just needs a strict bang
10:56:47 <johnw> it may be that >>= is associating wrong
10:56:53 <johnw> ly
10:57:13 <nak> i'm trying to get the following line working in ghci. can someone help? > foldr1 (\x y -> print x y) [1,2,3,4]
10:57:26 <infandum> johnw: Possibly. I'll see if he can fix it
10:59:32 <bergmark> @type foldr1
10:59:33 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
10:59:39 <bergmark> @type (\x y -> print x y)
10:59:40 <lambdabot>     Couldn't match expected type ‘t -> r’ with actual type ‘IO ()’
10:59:40 <lambdabot>     Relevant bindings include y :: t (bound at <interactive>:1:6)
10:59:40 <lambdabot>     The function ‘print’ is applied to two arguments,
10:59:54 <bergmark> @type print
10:59:55 <lambdabot> Show a => a -> IO ()
11:01:17 <sinelaw> anyone got type insertion to work in emacs with ghc 7.10?
11:01:29 <sinelaw> C-u C-c C-t
11:02:01 <sinelaw> I do have a working ghci-ng
11:04:50 * hackagebot text 1.1.1.4 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-1.1.1.4 (BryanOSullivan)
11:09:29 <rasen> Hi! I'm working through https://www.fpcomplete.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell and have next question: Where can I get SingRep today?
11:10:06 <newsham> rasen: neat!  havent heard of that.. great topic.
11:12:48 <rasen> newsham: If you're going to do exercices, skip implementing fromList. You won't have enough backgroud to implement it at time of exercise.
11:19:14 <newsham> rasen: i've got a bunch of agda and coq under my belt already
11:19:26 <newsham> but i havent seen an article discussing dep types in haskell, so should be fun
11:19:59 <rasen> Oh.. ok. Then you'll figure out what you need faster than me ;)
11:20:00 <newsham> question: pipes + conduits + others?  whats modern, popular and supported?
11:20:39 <newsham> rasen: there are some great tutorials for coq, btw.  also coq is more properly set up for dep tpyes since it uses them directly vs having some add-on constructs in the type system that kind of allow it
11:20:57 <magnap> newsham: Lenses maybe? I'm not a great source, I'm pretty new
11:21:12 <johnw> newsham: i'd go with pipes
11:21:26 <newsham> lenses are something diff (data access and manipulation)
11:21:38 <newsham> johnw: whats the argument?
11:21:52 <johnw> its types are more specific about behavior
11:22:46 <bennofs> newsham: I like pipes more (since it's more theoretically sound IMO and less ad-hoc), but conduit seemed to have more additional libraries when I last checked
11:22:48 <coltfred> newsham: https://www.reddit.com/r/haskell/comments/35fuod/boston_haskell_chris_casinghino_making_dependent/
11:23:14 <newsham> ty
11:23:43 <rasen> Ok... Seems that SingRep replacement is KnownNat in Data.Singletons.TypeLits (re-exported from GHC.TypeLits)
11:47:05 <Dynetrekk> https://gist.github.com/Dynetrekk/206c289da371fb1a8ab6 <- why do I get "parse error in pattern", and no further clue?..
11:47:19 <arkeet> you need more parentheses
11:48:17 <Dynetrekk> arkeet: ah. (x:xs) etc?
11:48:19 <arkeet> yes
11:48:27 <arkeet> function application binds more tightly than any operator, including :
11:49:01 <Welkin> except ( and )
11:49:08 <arkeet> ( and ) aren't operators
11:49:30 <bergmark> Dynetrekk: as for why... because clever error reporting is hard? :)
11:49:33 <Dynetrekk> arkeet: didn't think of : as an operator. I will do that
11:49:50 <Dynetrekk> bergmark: sure... for a noob, though, it's a pretty awful error message
11:50:02 <bergmark> i agree
11:52:42 <newsham> its weird to get used to coming from other languages, but lots of things that are built-in in other languages are just library impls in haskell
11:52:57 <newsham> ?type (:)
11:52:58 <lambdabot> a -> [a] -> [a]
11:53:00 * bergmark has been struggling with typescript error messages all day
11:53:17 <Dynetrekk> bergmark: typescript?
11:53:21 <bergmark> ghc's are so much easier to understand :-)
11:53:26 <Dynetrekk> newsham: I'm a python/fortran guy, most of the time
11:53:35 <newsham> sorry about the fortran. :)
11:53:37 <Dynetrekk> bergmark: I am terrified
11:53:47 <Dynetrekk> newsham: well... true and untrue, that
11:53:51 <newsham> i'm a python fan myself (for smallish programs)
11:53:57 <Welkin> I love type errors
11:53:59 <JoshieAS> anybody else use to be a <insert language here> guy, and is now totally Haskell?
11:54:05 <Dynetrekk> newsham: I think the guys who first wrote fortran would have loved haskell - current fortran users are a different bunch
11:54:06 <bergmark> Dynetrekk: typescript is javascript with some static typechecking and type inference
11:54:11 <Welkin> then you know exactly what the problem is and can fix it quickly
11:54:33 <Dynetrekk> bergmark: static, as in at "compile time"?
11:54:38 <bergmark> Dynetrekk: right
11:54:41 <Welkin> Dynetrekk: if you are coming from python, you will be in heaven with haskell -- the error messages are precise and meaningful
11:55:03 <Dynetrekk> Welkin: I'm happy with python so if that's the case... (although I expect to keep writing lots of python)
11:55:07 * hackagebot text 1.2.0.5 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-1.2.0.5 (BryanOSullivan)
11:55:09 * hackagebot reflection 1.5.2 - Reifies arbitrary terms into types that can be reflected back into terms  http://hackage.haskell.org/package/reflection-1.5.2 (EdwardKmett)
11:55:30 <Dynetrekk> Welkin: I've got a love/hate relationship with compile time errors
11:55:48 <Welkin> the compiler works for you, not against you
11:56:07 <newsham> sometimes type systems work against you.
11:56:36 <bergmark> most other language's type systems works against you :-(
11:57:01 <Dynetrekk> Welkin: well... tried maintaining fortran 77 code?
11:57:52 <newsham> for any type system that is not fully general, there are some interesting program types that are not expressable in your type system.
11:58:01 <roelof> why does this not work : main = print  . plusplus' $ [1,2] [3.4] 
11:58:11 <newsham> on the flip side, fully general type systems are undecidable
11:58:27 <roelof> I see then this message : src/Main.hs@8:29-8:40 Couldn't match expected type ‘[t1] -> [a0]’ with actual type [t0]
11:58:29 <newsham> and have a high mental tax
11:58:39 <roelof> The function ‘[1, 2]’ is applied to one argument,
11:58:48 <newsham> dynamic type systems sidestep that problem, at a cost of losing lots of compile-time proofs about your code
11:58:57 <roelof> but [1.2] is not a function but a argument 
11:59:40 <roelof> anyone who can help me ? 
11:59:42 <kadoban> roelof: Yes, but you're treating it like a function.  $ has really low precedence, so it's like … (…)  $ ([1, 2] [3, 4])
12:00:07 * hackagebot linear 1.18.1 - Linear Algebra  http://hackage.haskell.org/package/linear-1.18.1 (EdwardKmett)
12:00:20 <kadoban> roelof: Also, that's likely not to work anyway, even if you could use ($) like that.  If plusplus' takes two arguments … usually (.) doesn't do nice things with it.
12:00:22 <kadoban> :t (.)
12:00:23 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:00:35 <kadoban> roelof: Note the type of that ^
12:01:58 <roelof> oke, so back to the drawing table. Can I better do it in steps then. So first a variable which takes the output of the function and then print that variable  kadoban ?
12:02:00 <newsham> ?type (.).(.)
12:02:01 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
12:04:17 <kadoban> roelof: I'm not really sure what you mean. That specific thing you can do as     print $ plusplus' [1,2] [3,4] -- I guess?
12:05:36 <Dynetrekk> http://paste.ubuntu.com/11100171/ error message, this is the code: http://paste.ubuntu.com/11100169/
12:05:57 <roelof> kadoban:  thanks that worked 
12:06:14 <Dynetrekk> isn't the result IO () ?
12:08:35 <kadoban> Dynetrekk: xs <- [1..]    the 'm' there is [].   The 'm' in  putStrLn is IO, so it's inconsistent.
12:09:51 <kadoban> Dynetrekk: (a <- b; rest)  in a do block desugars into …      b >>= (\a -> rest)     if that helps
12:09:57 <kadoban> :t (>>=)
12:09:58 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:10:08 * hackagebot uu-options 0.2.0.0 - Parse command line options using uu-interleave and uu-parsinglib  http://hackage.haskell.org/package/uu-options-0.2.0.0 (DoaitseSwierstra)
12:10:56 <kadoban> Dynetrekk: Perhaps you mean    let xs = [1..]    and etc. ?
12:10:59 <Dynetrekk> kadoban: the 'm'? sorry, you've lost me completely
12:11:08 <Dynetrekk> kadoban: could be. fuck if I know.
12:11:22 <Dynetrekk> kadoban: I'm trying to create a variable (pardon my imperative accent) just for testing
12:11:54 <Dynetrekk> kadoban: also the error message was on the last line, not the xs line?
12:11:54 <Rembane> Dynetrekk: Maybe you need a let xs = [1..]
12:12:04 <magnap> It's the euler problem, right?
12:12:08 <magnap> Also, I'd use let too
12:12:30 <Rembane> Dynetrekk: You use that for hm... stuff that aren't residing in the monad your function is returning.
12:12:40 <Dynetrekk> magnap: p45, yep
12:13:01 <Dynetrekk> Rembane: woosh :)
12:13:26 <kadoban> <- is for … if you have a monadic action and want to combine it.   [1..] isn't a monadic action in that context, it's just a value you want to give a name.
12:13:51 <Dynetrekk> kadoban: that made some sense. xs is not an IO action - right?
12:14:05 <kadoban> Dynetrekk: Right. It's not  IO (something)
12:14:07 <magnap> main is of type IO (), and as such the "m" in "Monad m =>" in types is IO. Think of "<-" as extracting a monadic value. That value has to be in the same monad. "x <- [1..]" implies that x is in a [] monad
12:14:30 <Dynetrekk> magnap: oh. The error message threw me off then
12:14:34 <Dynetrekk> that, and incompetence
12:14:44 <kadoban> [] is also a Monad, with much different meaning. So it's like …   wait, what do you want this 'do' block to do again? And it got confused.
12:14:48 <magnap> Also, as a style thing, I'd write putStrLn . show $ findTriplets xs ys zs
12:15:13 <magnap> Wait, actually I'd write mapM_ putStrLn $ findTriplets xs ys zs
12:15:25 <magnap> :t mapM_
12:15:27 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
12:16:23 <Pamelloes> exit
12:16:23 <magnap> It maps a function that returns a monadic value, and throws away the values themselves, keeping only the effects
12:16:28 <Dynetrekk> magnap: the show $ findTriplets made good sense to me
12:16:44 <magnap> Dynetrekk: Does using mapM_ make sense to you?
12:16:46 <Dynetrekk> now, I just need to fix this findTriplets thing :P
12:17:09 <Dynetrekk> magnap: well, I think so. It's map, but some extra behavior for IO, right? so IO (something) -> IO () 
12:17:12 <Dynetrekk> ish
12:18:03 <magnap> Almost there. For now, that's all you'll need. But for the future, when you learn about more monads than IO: it's map with some extra behavior for a monad
12:18:20 <magnap> That monad doesn't have to be IO, though that is most often where it's used
12:18:41 <Dynetrekk> magnap: right. I'm still stuck at Euler 45 :)
12:18:59 <magnap> Yeah, me too. My code isn't fast enough
12:20:06 <magnap> And I made a mistake before: It should be mapM_ (putStrLn . show), not mapM_ putStrLn
12:20:25 <geekosaur> remember that euler programs test math understanding. if your code isn't fast enough, you're probably missing a mathematical insight that would avoid or reduce the amount of brute force involved
12:20:41 <geekosaur> s/programs/problems/
12:20:50 <magnap> I know, and I found one. But by the rules, I shouldn't share it ;-)
12:21:17 <magnap> I discovered it while pondering the problem away from my computer, and haven't implemented it
12:23:25 <kadoban> Dynetrekk: That logic for the ordering tests seems suspect. What about   (2 : something) (2 : something) (5 : something)   I don't know if that's a possible case, but unless you've proved it can't be …
12:23:26 <magnap> How much slower is ghci compared to compiling and running?
12:23:26 <Dynetrekk> http://paste.ubuntu.com/11100466/ <- findDuplicates seem to work :D magnap 
12:23:44 <Dynetrekk> kadoban: I'm sure it is suspect
12:24:02 <Dynetrekk> magnap: ridiculously - also memory use is potentially insane
12:24:16 <Dynetrekk> kadoban: I finally got duplicates to work. baby steps :)
12:24:18 <kadoban> magnap: Can be /many/ times slower and more memory hungry IME. It does basically no optimization.   -O2 is your friend.
12:24:21 <kadoban> Dynetrekk: Heh :)
12:24:35 <Dynetrekk> kadoban: looks like I'll need a shit ton of if/else guards if I'm going to do it like this...
12:25:12 <Cale> It can even be asymptotically slower, at least in theory if not also in practice, because rewrite rules won't be used.
12:25:18 <magnap> Damn, had been hoping to solve the Euler problems in ghci. I like kinda building my solution up slowly like that
12:25:45 <orion> When using WAI/Warp, what's the best way to actually handle exceptions instead of printing them to console?
12:25:59 <Cale> You should be able to test your solutions to most Euler problems in ghci
12:26:03 <kadoban> I've really never been a fan of ghci. I find it much more useful to write an actual script and have a quick way to run it. GHCi I basically just use for … type checking and such.
12:26:18 <Pamelloes> Is there a  way to write a type parameter along the lines of "a::Object (Window _)" so that a could be Object(Window (Button ()))?
12:26:25 <Dynetrekk> magnap: forget it, in my experience - although for most problems you'll be fine
12:26:38 <Dynetrekk> magnap: sorry, I use runhaskell, but it's the same thing though
12:27:01 <Cale> You shouldn't really be writing your programs entirely in ghci anyway though -- put source code in a file and load it. When you save in your text editor, type :r to reload the file in ghci
12:27:20 <magnap> Cale: It's just for solving Project Euler problems, not serious programming
12:27:24 <Cale> Then you can test your definitions and experiment with whatever the next step is.
12:27:48 <Cale> Even for Project Euler problems -- any program which is longer than 1 or 2 lines should go in a file, really.
12:28:21 <magnap> Dynetrekk: That works on the same insight I came to. That hexagon n = triangle (2*n-1)
12:28:25 <kadoban> Dynetrekk: I don't think you necessarily need a bunch more tests … you just need to reorder, and use /better/ tests (like 90% sure)   /me hands Dynetrekk a (<=)
12:29:21 <magnap> At first thought, <= looked like a fancy new operator I hadn't heard of before
12:29:25 * magnap feels stupid
12:29:42 <Cale> "What is this double left arrow thing?" :D
12:29:46 <kadoban> You guys know that cute thing where … you write a Num instance for doing modular arithmetic? Is there a way to do it without hardcoding the modulus? I need it to come from user input :-/
12:29:53 <kadoban> magnap: haha, yeah I do that all the time XD
12:29:58 <Dynetrekk> magnap: didn't realize - but you're right, that means you can skip checking triangles...
12:31:51 <lpaste> kadoban pasted “mod type” at http://lpaste.net/132491
12:32:00 <kadoban> So how do I do that, except without 'p' hardcoded?
12:32:02 <arkeet> kadoban: reflection :-)
12:32:12 <Cale> kadoban: Types are things which are determined at compile time
12:32:28 <kadoban> No cute trick I can use? :(
12:33:30 <arkeet> https://hackage.haskell.org/package/reflection
12:33:34 <arkeet> example is in the description
12:33:39 <arkeet> except rather poorly formatted :(
12:34:22 <kadoban> Heh, I'll take a peek. Thanks for the comment Cale, I do understand why it doesn't make sense, just … lots of things that don't make sense to me seem possible sometimes, so I thought I'd take a shot ;)
12:36:45 <Dynetrekk> magnap: http://paste.ubuntu.com/11100722/ <- brute force triplet checking, runs in 2 seconds on a crap machine
12:37:18 <magnap> You don't really need to do triplet checking?
12:37:43 <Dynetrekk> magnap: sure, but I'm doing this for the haskell, not for the math
12:37:49 <c_wraith> is stuff like someNatVal from GHC.TypeLits technically reflection?
12:37:52 <Dynetrekk> magnap: so wanted to get the findTriplets right :)
12:38:35 <magnap> It tickles my duplication-sense. I feel like there should be a better way
12:39:17 <Dynetrekk> magnap: probably - your trick by ditching triangle numbers altogether is way smarter, for one, and then you could use the findDuplicates I pasted
12:39:24 <kadoban> IIRC you can solve that one on pencil and paper, so there almost certainly is, heh. There's some pretty big math geeks in the discussion forums there.
12:39:27 <Dynetrekk> magnap: this works on infinite lists, though, which I find interesting
12:39:44 <Dynetrekk> kadoban: most of the simples ones, at least the ones without primes in them, can be, I guess
12:40:17 * hackagebot eventloop 0.4.0.0 - A different take on an IO system. Based on Amanda's IO loop, this eventloop takes a function that maps input events to output events. It can easily be extended by modules that represent IO devices or join multiple modules together.  http://hackage.haskell.org/package/eventloop-0.4.0.0 (sebaslafleur)
12:40:19 * hackagebot twentefp-eventloop-trees 0.1.1.0 - Tree type and show functions for lab assignment of University of Twente. Contains RoseTree and RedBlackTree  http://hackage.haskell.org/package/twentefp-eventloop-trees-0.1.1.0 (sebaslafleur)
12:40:20 <kadoban> A surprising number of the later ones as well, I believe. Of course the /really/ later ones I don't have enough number theory to actually solve so I dunno.
12:40:39 <magnap> Dynetrekk: But why doesn't it fail on empty lists?
12:40:46 <Dynetrekk> kadoban: I've never done number theory, so probably you're right
12:40:51 <Dynetrekk> magnap: I never give it one
12:41:06 <magnap> But if you keep running on the tail you should run into one
12:41:18 <kadoban> magnap: Not if you only ever run it on infinite lists.
12:41:25 <magnap> True...
12:42:01 <kadoban> Technically if you wanted it to be generally useful you'd want to handle that I'm sure, but since it's just for that problem …
12:42:08 <Dynetrekk> kadoban: that's my plan
12:42:22 <Dynetrekk> kadoban: if it's documented, it should be fine, I guess...
12:42:30 <Dynetrekk> if not elegant
12:43:04 <kadoban> Ya, it doesn't matter much. Not like you have to submit your code anyway.
12:43:17 <Dynetrekk> kadoban: if I did submit it, it would solve the problem :)
12:43:19 <magnap> Using findDupes it runs in less than a second on my machine only for the 5- and 6-gons
12:44:33 <Dynetrekk> magnap: yeah, should be way faster
12:44:48 <Dynetrekk> magnap: I ran with runhaskell, too, so ghc -O2 should be madly efficient
12:45:00 <c_wraith> Hmm.  someNatVal + natVal really is a reflection/reification pair for Nat-kinded types
12:45:32 <Dynetrekk> ghc -O2 : is it the highest optimization level? does it include unsafe floating point optimization?
12:45:41 <magnap> kadoban: What about having a type-wrapper that contains an Int which is the modulus?
12:45:59 <magnap> Dynetrekk: ghci finds the next one yet in 46 seconds ;-)
12:46:24 <c_wraith> kadoban: if you use a type-level Nat as the modulus, this can be made to work, actually
12:46:33 <arkeet> mhm
12:46:52 <arkeet> newtype Zp (n :: Nat) = Zp Integer
12:46:54 <arkeet> that sort of thing
12:46:57 <maerwald> you can use liquidhaskell probably
12:47:03 <magnap> So it shall be known: 57722156241751 is 3-, 5-, and 6-gonal
12:47:05 <arkeet> well, p :: Nat
12:47:07 <arkeet> idk
12:47:11 <c_wraith> kadoban: http://lpaste.net/127254 is a start
12:47:19 <kadoban> c_wraith: Are type-level Nats real-world useful, or would it be so slow as to be only a toy?
12:47:28 <arkeet> they're not slow
12:47:33 <kadoban> Not that it's not cool regardless, just curious.
12:47:34 <c_wraith> kadoban: they're just passing around an Integer, at the implementation level
12:47:43 <maerwald> http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2013/01/01/refinement-types-101.lhs/
12:47:47 <kadoban> Hmm
12:47:53 <c_wraith> kadoban: or rather, the KnownNat constraint is implemented as an Integer, rather than a standard type dictionary
12:48:21 <kadoban> Interesting, thanks for the idea. I'll mess with that
12:48:22 <Nux__> is it possible to declare all types of an existing typeclass (that you are unable or unwilling to modify) instances of another typeclass?
12:48:28 <maerwald> kadoban: what are you actually trying to do?
12:48:32 <Nux__> other than writing oput each of their instance declarations
12:48:36 <c_wraith> kadoban: but combining that with someNatVal and pattern-matching the SomeNat constructor gives you the ability to pick the modulus at runtime
12:48:41 <arkeet> kadoban: but if you want to do this with something other than integers or strings, reflection is the thing to look at.
12:48:49 <arkeet> I think.
12:48:56 <c_wraith> Yes.  The reflection package generalizes it to other types
12:49:58 <kadoban> maerwald: Mostly just do dumb algorithm competition website problems. Making a Zp type lets me skip writing fast-exponentation and such, and it's just nicer in general than doing it manually … but if the modulus isn't given in the problem, then I'm screwed (with my old approach)
12:50:26 <kadoban> Thanks arkeet and everyone, very interesting stuff :)
12:50:44 <maerwald> kadoban: liquidhaskell lets you constrain the types beyond typelevel, very specifically... but it's not wired into ghc directly
12:51:12 <maerwald> that could probably be useful for modulus stuff
12:51:22 <dolio> I think that's doubtful.
12:51:31 <dolio> The point of the modulus stuff is to compute with the modulus.
12:51:46 <dolio> Not just to have a type tagged with a modulus that gets checked.
12:52:00 <Dynetrekk> is the ++ operator very slow?
12:52:11 <c_wraith> Dynetrekk: it's as fast as it can possibly be for what it does
12:52:14 <Dynetrekk> and isn't foldl lazy?
12:52:27 <kadoban> Dynetrekk: It's linear in the size of the first argument
12:52:29 <c_wraith> foldl (++) is worst-case behavior, of course
12:52:43 <Dynetrekk> c_wraith: I'm  sure, but O(n) is still way slower than O(1)
12:53:05 <c_wraith> Dynetrekk: if you're using foldl (++), you're running into unnecessary quadratic slowdown
12:53:10 <Dynetrekk> c_wraith: oh. how do I concatenate an infinite list of strings then?
12:53:12 <arkeet> Dynetrekk: ++ is necessary O(length of the first list), because it has to copy the first list.
12:53:18 <arkeet> use concat
12:53:26 <c_wraith> Dynetrekk: foldr (++) does not have the unnecessary quadratic slowdown
12:53:26 <arkeet> (which is foldr (++) [])
12:53:27 <Dynetrekk> arkeet: ah, that's quadratic, yeah
12:53:39 <Dynetrekk> c_wraith: but does not work for infinite lists? right?
12:53:43 <c_wraith> it does
12:53:43 <arkeet> (a ++ b) ++ c must copy a twice
12:53:46 <arkeet> a ++ (b ++ c) is better
12:53:49 <c_wraith> It's the same thing as concat
12:53:51 <worldsayshi> I assume not but is there a way to defer missing module errors to runtime? I need it for this: http://stackoverflow.com/questions/30199877/different-server-and-client-dependencies-with-haste
12:53:55 <Dynetrekk> c_wraith: how can foldr work for inf. lists?
12:54:08 <c_wraith> > foldr (:) [] [1..]
12:54:09 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
12:54:19 * c_wraith reinvents id
12:54:24 <kadoban> XD
12:54:25 <arkeet> > foldr (++) [] [ [x,x] | x <- [1..] ]
12:54:27 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
12:54:56 <c_wraith> > foldr f z [a, b, c] -- Dynetrekk 
12:54:58 <lambdabot>  f a (f b (f c z))
12:55:07 <Dynetrekk> c_wraith: I apparently have no clue as to the difference of foldl and foldr
12:55:14 <arkeet> foldl and foldr are quite different.
12:55:37 <Cale> @src foldr
12:55:37 <lambdabot> foldr f z []     = z
12:55:37 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:55:49 <arkeet> foldr f z replaces (:) with f and [] with z
12:56:06 <Cale> ^^ foldr can work for infinite lists because it immediately passes control to f in the recursive case. If f doesn't inspect its second argument, then the foldr doesn't continue
12:56:17 <Cale> @src foldl
12:56:17 <lambdabot> foldl f z []     = z
12:56:17 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:56:22 <arkeet> foldr f z (a : b : c : [])  =  a `f` b `f` c `f` z
12:56:36 <arkeet> well, a `f` (b `f` (c `f` z))
12:56:54 <Cale> ^^ but foldl on the other hand greedily passes control to itself (with new arguments) until it finds the end of the list, so will never produce anything when applied to an infinite list
12:56:58 <Dynetrekk> arkeet: I knew as much, but the exact difference eludes me, it seems
12:57:24 <Cale> > foldl f z [1,2,3]
12:57:25 <arkeet> foldl loops over the entire list while updating some accumulator.
12:57:25 <lambdabot>  f (f (f z 1) 2) 3
12:57:29 <Cale> > foldr f z [1,2,3]
12:57:31 <lambdabot>  f 1 (f 2 (f 3 z))
12:57:39 <arkeet> foldl f z xs is like
12:57:42 <arkeet> acc := z;
12:57:56 <arkeet> foreach x in xs { acc := f acc x }
12:57:58 <Cale> I'd point you at my diagrams, but one sec, my webserver isn't configured again yet :P
12:57:59 <arkeet> return acc
12:58:01 <arkeet> or something
12:58:15 <arkeet> in particular it can't produce anything before traversing the entire list.
12:58:38 <Cale> I think it's easier to just follow it in terms of the Haskell code :P
12:58:57 <arkeet> sure, but that doesn't help a whole lot with deciding when to use which.
12:59:47 <magnap> When would you use foldl? I always use foldr (not that I'm a good example)
12:59:59 <Cale> > foldl (flip (:)) [] [1,2,3,4,5]
13:00:01 <lambdabot>  [5,4,3,2,1]
13:00:23 <Cale> reverse is a pretty reasonable use case for foldl
13:01:18 <magnap> But in any other scenario, couldn't I just reverse first?
13:01:36 <Cale> You should usually either be using foldr or foldl', though you can get away with using foldl and just turning optimisations on, which will usually result in foldl becoming foldl' automatically where it's necessary
13:01:47 <Cale> Consider adding up the elements of a list
13:01:56 <Cale> foldr (+) 0 [1,2,3]
13:02:05 <Cale> -> 1 + foldr (+) 0 [2,3]
13:02:07 <arkeet> > foldr (+) 0 [a,b,c]
13:02:08 <lambdabot>  a + (b + (c + 0))
13:02:13 <arkeet> uh, go on.
13:02:17 <Cale> please
13:02:24 <Cale> -> 1 + (2 + foldr (+) 0 [3])
13:02:29 <dolio> > foldl (flip const) (error "last: empty list") [undefined,1,2,3,4,5]
13:02:31 <lambdabot>  5
13:02:32 <Cale> -> 1 + (2 + (3 + foldr (+) 0 []))
13:02:39 <Cale> -> 1 + (2 + (3 + 0))
13:03:03 <Cale> If the list had been millions of elements long, we just built a giant expression tree in memory, which will waste a lot of space
13:03:04 <magnap> Yes?
13:03:07 <magnap> Oh
13:03:29 <Cale> Moreover, (+) needs to evaluate (pattern match) both its arguments in order to produce a result
13:03:32 <magnap> But foldl' can just keep the acc going
13:03:37 <magnap> I see!
13:03:37 <Cale> So we're just about to run into a stack overflow
13:03:48 <Cale> (though caused by (+) and not foldr)
13:04:08 <dolio> Can't use that anymore.
13:04:18 <dolio> Have to talk about asymptotic memory usage.
13:04:35 <magnap> dolio: Why?
13:04:42 <dolio> Stack overflows are now off by default.
13:04:46 <Cale> oh, cool
13:04:57 <dolio> As of 7.10, I think.
13:05:04 <Cale> Well, I think it's cool. It'll be cool right up until my programs start getting memkilled. :D
13:05:18 * hackagebot reflection 1.5.2.1 - Reifies arbitrary terms into types that can be reflected back into terms  http://hackage.haskell.org/package/reflection-1.5.2.1 (EdwardKmett)
13:05:30 <dolio> Yes, it makes a lot of sense.
13:05:31 <Cale> In any case, we'll use a lot of stack space
13:05:35 <magnap> Now that you say it, I've actually run into that. GHCi forced me into swapping
13:05:48 <dolio> Well, it can do that with heap usage, too.
13:06:01 <magnap> TBH, I don't know the difference
13:06:03 <dolio> Now it can also do that with stack usage.
13:06:04 <Cale> because (1 + ...) will wait on the stack for the (2 + ...) expression to be evaluated, and so on
13:06:29 <magnap> Cale: I get it now :)
13:06:37 <Cale> magnap: You can think of the stack as consisting of case expressions that are waiting for their scrutinee to be sufficiently evaluated to match a pattern
13:06:44 <Cale> (it is not a call stack)
13:07:02 <magnap> And what's a heap then?
13:07:38 <Cale> The heap consists of all the datastructures and expressions that are bound to variables.
13:08:09 <Cale> i.e. what you'd normally think of as the memory used by the program
13:08:45 <magnap> Thunks too? Or are they what's in the stack?
13:09:15 <Cale> Thunks are a name for the data structure used to represent expressions at runtime.
13:09:16 <orion> What's the most elegant way to change a number of fields within a record when you don't have direct access to the getters/setters?
13:09:45 <orion> I'm asking because I need to set a bunch of setting values for Network.Wai.Handler.Warp (setPort, setHost, etc).
13:10:00 <Cale> So yeah, thunks are on the heap
13:10:27 <Cale> I should also show what can go wrong with foldl with optimisations off
13:10:30 <Dynetrekk> back again... damn ghci ate all my RAM! is there a way to limit memory usage?
13:10:31 <Cale> (and not foldl')
13:10:38 <Cale> haha
13:11:09 <Dynetrekk> Cale: yeah, real funny to reboot :P
13:11:18 <Dynetrekk> in imperative languages you can at least just hit ctrl-C
13:11:27 <Cale> You should be able to hit Ctrl-C
13:12:12 <Cale> one sec brb
13:12:15 <Dynetrekk> Cale: didn't bite - and when you've run out of RAM, shit starts to hit the fan fast
13:12:20 <Cale> yeah
13:12:49 <dolio> If you get too far into swapping, you have to wait a while for ^C to work.
13:13:02 <Dynetrekk> dolio: I don't have any swap
13:13:10 <Dynetrekk> (on this machine)
13:13:13 <Cale> There is a way, try  ghc +RTS -h  to see a list of RTS options. I'd tell you the flag, but I don't have GHC installed yet on this machine. (Just installed a new disk and OS)
13:13:40 <dolio> Anyhow, you can set heap and stack limits.
13:13:57 <dolio> Either with +RTS, or use ulimit.
13:14:30 <Dynetrekk> dolio: didn't think of ulimit...
13:15:01 <dolio> The stack setting on ulimit will probably have no effect on Haskell programs. The heap setting will affect both.
13:15:16 <Dynetrekk> dolio: ulimit -d?
13:15:28 <Dynetrekk> it doesn't say heap anywhere with ulimit -a
13:15:33 <nak> :t flip
13:15:34 <lambdabot> (a -> b -> c) -> b -> a -> c
13:15:37 <dolio> -m I think.
13:15:50 <dolio> I'm not sure what -d is.
13:16:00 <geekosaur> data segment is what most people think of as the heap
13:16:12 <dolio> Oh, is it?
13:16:16 <geekosaur> yes
13:16:31 <Dynetrekk> dolio: -v did the trick, now it fails without crashing  my VM
13:16:36 <dolio> What's -m, then? Is -d all of virtual memory?
13:16:58 <dolio> No, -v is virtual memory, right?
13:17:13 <geekosaur> text = program code, data = heap, stack = OS stack, -m is the amount of physical RAM (resident system set)
13:17:57 <athan> Anyone have thoughts on this stuff? https://github.com/athanclark/composition-extra/blob/master/src/Data/Composition/Contravariant.hs
13:18:08 <athan> https://github.com/athanclark/composition-extra/blob/master/src/Data/Composition/Monad.hs
13:18:10 <Dynetrekk> geekosaur: so what do I set to limit runhaskell/ghci?
13:18:17 <athan> https://github.com/athanclark/composition-extra/blob/master/src/Data/Composition/Functor.hs
13:18:31 <magnap> Sorry I vanished, my computer ran out of power. So, why aren't thunks on the stack?
13:19:29 <geekosaur> most likely +RTS -Mxx to limit Haskell heap (xx is something like 2G or 512k)
13:20:02 <geekosaur> ghc can adapt its memory allocation to deal with heap limits; if you set it with ulimit, the OS will just kill it
13:20:36 <geekosaur> (e.g. it will garbage collect more often)
13:22:09 <Dynetrekk> geekosaur: at least ghci quietly accepts the flag
13:22:33 <geekosaur> also note that there is a difference between OS stack (ghc hardly uses this) and thread stack
13:22:54 <Dynetrekk> http://paste.ubuntu.com/11101456/ <- why the type error on line 5?
13:22:56 <geekosaur> thread stack is allocated in chunks from the heap as needed
13:24:32 <Dynetrekk> error msg: http://paste.ubuntu.com/11101472/
13:24:52 <joneshf-laptop> what's up with this:
13:24:53 <joneshf-laptop> @djinn Monad f => f (f a) -> f a
13:24:54 <lambdabot> -- f cannot be realized.
13:24:58 <geekosaur> :t foldr
13:24:59 <magnap> You switched the x and the acc
13:24:59 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
13:25:14 <c_wraith> joneshf-laptop: lambdabot doesn't know all about Monads
13:26:06 <joneshf-laptop>  @djinn Monad f => f a -> (a -> f b) -> f b
13:26:10 <joneshf-laptop> @djinn Monad f => f a -> (a -> f b) -> f b
13:26:10 <lambdabot> f = (>>=)
13:26:13 <joneshf-laptop> but it knows that
13:26:26 <Dynetrekk> magnap: right. :t told me as much... once I remembered to check
13:26:29 <joneshf-laptop> c_wraith, I dont understand
13:27:27 <geekosaur> djinn can't handle things like recursive types (think lists, trees).. or recursion in general I think (f (f a))
13:27:31 <magnap> It reverses the list though. Why is that?
13:27:33 <magnap> > foldr (\ x acc -> acc ++ show x) "0." [1..10]
13:27:33 <Dynetrekk> how is it that "show x ++ acc" works fine but "acc + show x" runs out of memory?
13:27:35 <lambdabot>  "0.10987654321"
13:27:48 <m_ryan> hi i would like to ask some help with my code hope you help me - http://lpaste.net/132493
13:27:49 <Denommus> @djin Arrow a => a (b,d) (c,d) -> a b c
13:27:49 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
13:27:53 <Dynetrekk> magnap: that crashes for me
13:27:56 <Denommus> @djinn Arrow a => a (b,d) (c,d) -> a b c
13:27:56 <lambdabot> Error: Class not found: Arrow
13:27:58 <Dynetrekk> magnap: also is not what I want
13:28:01 <hexagoxel> @djinn Monad f => f a -> (a -> f c) -> f c
13:28:01 <lambdabot> -- f cannot be realized.
13:28:05 <Denommus> meh
13:28:17 <geekosaur> exferenceBot is smarter, I believe, but I don't recall offhand how you use it and it has its own limitations
13:28:24 <hexagoxel> joneshf-laptop: even exchanging one of the vars makes it fail
13:28:57 <magnap> Dynetrekk: What do you want?
13:29:21 <joneshf-laptop> hexagoxel, ah
13:29:49 <hexagoxel> joneshf-laptop: exference works for such stuff, though
13:30:01 <Dynetrekk> magnap: euler p40 https://projecteuler.net/problem=40 (the string of that number)
13:30:02 <hexagoxel> :exf "Monad f => f (f c) -> f c"
13:30:02 <exferenceBot> \ b -> b >>= (\ f -> f)
13:30:42 <nschoe> Hey everyone. Stupid question: in the same Haskell file, if I have two data Types1 and data Type2 and Type2 has a Type1 inside it (record field), do I have to define Type1 before Type2 in the file?
13:30:58 <geekosaur> nschoe, not generally
13:31:03 <nschoe> GHC complains right now, but surely there must be a way...
13:31:12 <indiagreen> nschoe: are you using lenses?
13:31:15 <magnap> Dynetrekk: Watch this:
13:31:17 <nschoe> indiagreen, nope
13:31:19 <Zemyla> Fucking hell, why do the maintainers keep pushing back a huge long-standing bug that prevents shit from working on Windows?
13:31:20 <magnap> > concatMap show [0,1..]
13:31:21 <lambdabot>  "012345678910111213141516171819202122232425262728293031323334353637383940414...
13:31:23 <indiagreen> or TemplateHaskell?
13:31:32 <geekosaur> note that if template haskell is involved, definitions need to be in a particular order
13:31:34 <nschoe> indiagreen, I am, but not with these types.
13:31:37 <Zemyla> "Can't load .so/.DLL for: mingw32.dll"
13:31:42 <magnap> Or, alternately:
13:31:45 <m_ryan> hi i would like to ask some help with my code hope you help me - http://lpaste.net/132493
13:31:51 <Dynetrekk> magnap: what's concatMap? map, then concat string?
13:31:53 <magnap> > "0." ++ concatMap show [1..]
13:31:54 <lambdabot>  "0.1234567891011121314151617181920212223242526272829303132333435363738394041...
13:32:01 <magnap> concatMap = concat . map
13:32:07 <magnap> It's just a shortcut
13:32:20 <Zemyla> And the response from the maintainers is basically *shrug* as they keep pushing the resolution of that bug backward.
13:32:26 <magnap> concatMap f = concat . map f, sorry, my bad
13:32:27 <nschoe> Ho my, sorry yes I do. I use $(deriveSafeCopy ...) on Type2 so I guess that's the reason
13:32:57 <nschoe> (If aybody can confirm, so that I don't have doubts)
13:33:46 <indiagreen> nschoe: when I used TH, I sometimes had problems even with unrelated types, I think – but if you want to find out what exactly GHC does when TH is involved, read the manual
13:33:46 <magnap> Dynetrekk: and you'll find that (concatMap show [0..]) !! 12 == '1'
13:34:16 <nschoe> indiagreen, okay. Thx.
13:34:19 <geekosaur> nschoe, if you are doing that then the parser must have already seen Type1
13:34:47 <nschoe> geekosaur, okay, well I swapped the types. It was no big deal. I was just curious.
13:34:59 <geekosaur> TH doesn't get to read the whole thing, it only knows what has been read up to the point of ther splice
13:35:02 <nschoe> Thx for your help guys.
13:35:27 <nschoe> geekosaur, that doesn't seem handy, but then again I suppose it has its reasons.
13:35:57 <joneshf-laptop> hexagoxel, exference?
13:36:43 <hexagoxel> joneshf-laptop: https://github.com/lspitzner/exference/
13:36:45 <technomad_> hi all, has anyone used Parsec?
13:36:51 <geekosaur> joneshf-laptop, https://github.com/lspitzner/exference or see where hexagoxel addressed exferenceBot
13:36:56 <indiagreen> lots of people, just ask your question
13:36:57 <kirill`> Is there a name for a pattern of functions that go like func (A l r) = A (func l r); func (B l r) = B (func l) (func r); func (C l r) = doSomeWork
13:37:37 <technomad_> trying to parse “mix” and “mix_source” as different tokens, but it’s not looking ahead, so when i have them (and some others ie the token "hold") in the choice function (which tries from a list of parsers until one works), whichever one I put first wins...
13:37:53 <technomad_> because mix_source is a longer version of mix..
13:39:28 <magnap> Dynetrekk: have you solved #40 yet? I am very proud of my little one-liner
13:39:33 <Denommus> what would be a good GUI framework for Haskell?
13:39:39 <ReinH> technomad_: try to parse mix_source first then try to parse mix
13:39:39 <technomad_> all this within a  (between ...) $ sepEndBy (choice [(string "mix"), (string "mix_source"), (string "hold"), ...] (separator character)
13:40:39 <technomad_> when i try that, on a "mix" example, it seems to succeed with the mix_source parser and then fail when the next token isn't a "_"
13:40:52 <Dynetrekk> magnap: sure have http://paste.ubuntu.com/11101687/
13:40:53 <magnap> Screw waiting: SPOILER ALERT PROJECT EULER #40: product . map (readChar . ((concatMap show [0..]) !!)) . map (10^) $ [0..6]
13:41:00 <magnap> Oh, you have :)
13:41:00 <ReinH> technomad_: you need to use `try'
13:41:07 <magnap> Sorry for being impatient
13:41:11 <Dynetrekk> magnap: could probably mash it together on one line... does that make it better?
13:41:16 <Dynetrekk> impatient?
13:41:23 <magnap> Nah, it's just a bad habit of mien
13:41:24 <technomad_> right. how does try interact with choice? 
13:41:25 <magnap> *mine
13:41:41 <magnap> Dynetrekk: I posted it before I'd seen you saying you'd done it
13:42:23 <joneshf-laptop> hexagoxel, geekosaur thanks
13:42:25 <Dynetrekk> magnap: I'm off to bed. thanks for your advice. mine: get a VM to crash for haskell stuff :P
13:42:50 <magnap> Dynetrekk: NixOS? Seems like a good choice. Sleep well!
13:42:53 <technomad_> ReinH since it's a sepEndBy ( choice ( string .., changing it to sepEndBy ( try $ choice (string ... fails because it's surprised at the comma separator
13:43:24 <technomad_> try $ sepEndBy ( try $ choice fails the same way as the original
13:43:29 <Dynetrekk> magnap: ubuntu 14.04 LTS in my case. never got the point of NixOS
13:43:33 <Dynetrekk> although it looks cool
13:43:44 <magnap> Avoiding cabal hell mainly, if you use it for haskell
13:43:47 <Dynetrekk> magnap: I'm just using Azure
13:43:55 <Dynetrekk> magnap: for my VM
13:44:29 <ReinH> perhaps: choice . map try $ [string "mix_source", string "mix", ...]
13:44:32 <technomad_> literally getting this: unexpected "]"
13:44:32 <technomad_> expecting "mix_source" or "]"
13:44:36 <technomad_> ack sorry split the line
13:44:44 <ReinH> Each parse needs to be able to fail and backtrack separately
13:45:09 <technomad_> oh okay interesting let me try that
13:45:15 <magnap> Installing nix (for Linux, Azure is Windows, isn't it?) is one of those things I should do, but haven't gotten to
13:45:31 <magnap> That or start using Stackage
13:45:58 <kadoban> Stackage is pretty easy to use once you figure it out. Nix seemed … very complicated.
13:45:58 <Dynetrekk> Azure includes linux VMs
13:46:03 <technomad_> ReinH oooh yes that worked, danke danke
13:46:17 <Dynetrekk> magnap: I've got an MSDN subscription at owrk so I cna run a VM for free, continuously, in practice
13:46:18 <ReinH> technomad_: np
13:46:23 <Dynetrekk> well maybe 2-3 of them, but hey
13:46:40 <Dynetrekk> kadoban: Stackage?
13:46:53 <ReinH> Well, stackage is just a hackage server, not an entire operating system.
13:47:09 <ReinH> That said, nix isn't exactly simple.
13:47:16 <magnap> Nix is "just" a package manager, not an os. NixOS is the OS
13:47:17 <kadoban> Dynetrekk: http://www.stackage.org/ it's a curated list of packages that all are guaranteed to work (or at least build)? With each other.
13:47:41 <Dynetrekk> magnap: right. I've looked at it and gotten bogged down and disappointed before
13:47:43 <phaazon> @index newline
13:47:43 <lambdabot> System.Console.Terminfo.Cursor, System.Console.Terminfo
13:47:54 <phaazon> hm
13:48:00 <phaazon> @hoogle newline :: Char
13:48:01 <lambdabot> No results found
13:48:04 <Dynetrekk> kadoban: ah. I'm not at that point yet - I'm just learning the language for fun and mental gymnastics
13:48:07 <kadoban> Between that, and sandboxes I haven't had a fight with cabal in quite a while. The new stackage-cli stuff is pretty neat too, it fixes some problems with cabal.
13:48:07 <phaazon> I thought that was defined somewhere
13:48:17 <phaazon> Data.Char doesn’t have that
13:48:17 <Dynetrekk> kadoban: I've only written fortran and python the last few years, for actual "production" stuff
13:48:24 <phaazon> any idea folks?
13:48:39 <kadoban> Dynetrekk: Yeah, when you graduate to wanting to use it for something real it becomes much more important.
13:48:51 <phaazon> maybe in Data.String
13:48:56 <phaazon> nope
13:48:57 <phaazon> dammit.
13:49:08 <Dynetrekk> kadoban: true - but I don't think fortran hackers of 30 years are gonna jump on the haskell bandwagon
13:49:14 <phaazon> oh, nativeNwline
13:49:14 <Dynetrekk> (i.e. my colleagues)
13:49:38 <phaazon> oh, not that.
13:49:41 <Dynetrekk> kadoban: so it will be a while before I can write something interesting in it (for a hobby project)
13:49:44 <kadoban> Dynetrekk: Well, there's always personal projects, or better jobs ;)
13:51:07 <magnap> Dynetrekk: Congratulations on starting learning Haskell. Soon enough, you'll start missing the abstractions in other languages. But fear not! There is a monad package for python ;)
13:51:19 <maerwald> magnap: waaat? 
13:51:22 <maerwald> link
13:51:32 <magnap> https://pypi.python.org/pypi/PyMonad/
13:51:38 <Dynetrekk> kadoban: well I like numerics, and haskell isn't there (I think?)
13:51:51 <Dynetrekk> kadoban: but haskell has lots of interesting ideas
13:51:55 <Dynetrekk> magnap: python IS nice :)
13:52:26 <magnap> Dynetrekk: Agreed, but I've very used to the strictly functional paradigm
13:52:31 <magnap> *I've become
13:52:49 <exio4> Dynetrekk: it's the abstractions and the whole paradigm that keeps you here
13:52:52 <Dynetrekk> magnap: yep. I've found programming haskell makes for cleaner python code
13:52:54 <maerwald> magnap: now... it's only missing the "pure" part :p
13:52:55 <exio4> Dynetrekk: you'll either love or hate them
13:53:20 <Dynetrekk> exio4: I do like it, coming from a math/physics background - but I do not see how I could do numerics in hasekll, still
13:53:29 <Dynetrekk> except for smaller stuff - postprocessing etc, perhaps
13:53:40 <Dynetrekk> I'm willing to be proven wrong
13:53:44 <magnap> exio4: Exactly. Sometimes, though, you'll learn to love them. And once you do, you'll miss them everywhere else. And that's when we introduce you to hylomorphism! *evil laugh*
13:53:47 <exio4> Dynetrekk: which kind of numerics?
13:53:53 <magnap> *hylomorphisms
13:54:07 <Dynetrekk> exio4: the kind where you crunch lots of numbers? what you'd use fortran for
13:54:25 <exio4> magnap: lol, recursion schema names are just a fancy name for a fold + unfold :p 
13:54:31 <exio4> that* 
13:54:39 <magnap> I know ;) but they sound dangerous
13:55:07 <magnap> *Pedant alert*: fold . unfold
13:55:59 <exio4> Dynetrekk: I see
13:56:39 <magnap> I think people are working on number-crunching in Haskell too, though. I remember hearing about an interface to some kind of C library
13:56:50 <Dynetrekk> exio4: can you e.g. work with multidimensional arrays in haskell? MKL? FFTW?
13:57:03 <magnap> Dynetrekk: there's a library for that! Just a sec
13:57:05 <Dynetrekk> magnap: a bit vague... but possibly
13:57:05 <kadoban> There's the #numerical-haskell people, I haven't really used it much though.
13:57:11 <exio4> there's repa, but I haven't used it 
13:57:21 <magnap> repa, that's it
13:57:32 <Dynetrekk> kadoban: numpy and fortran are nice though I do miss a lot of the type system, abstractions etc. in fortran
13:57:41 <jle`> there's hmatrix too right
13:57:57 <kadoban> Yeah I've used repa for a think or two and it seems nice, I still don't know enough about it though.
13:57:58 <fragamus> has anyone ever brought up the idea of a de-sugared haskell
13:58:23 <magnap> fragamus: I think the closest thing to that would be Haskell-as-a-Lisp. That'd be super cool!
13:58:43 <Dynetrekk> jle`: ah, if it works with MKL it would be really nice
13:58:44 <fragamus> that's where i was going with that
13:59:18 <jle`> you can just chose to use no sugar, right?
13:59:22 <fragamus> the simpler lisp syntax gives us macros
13:59:28 <maerwald> Dynetrekk: "description:    Link with Intel's MKL optimized libraries."
13:59:30 <phaazon> hey
13:59:36 <phaazon> I want to turn a ByteString into a String
13:59:36 <maerwald> Dynetrekk: in the hmatrix package
13:59:43 <phaazon> is show okay?
13:59:44 <magnap> maerwald: Ninja'd!
13:59:49 <Dynetrekk> maerwald: ok, cool
13:59:51 <magnap> phaazon: What do you mean?
13:59:51 <phaazon> or does it escape characters?
13:59:55 <jle`> phaazon: what does the bytestring contain?
14:00:02 <phaazon> magnap: I huse HTTP-conduit
14:00:08 <phaazon> I just want to put the response in a String
14:00:09 <jle`> does it contain text?
14:00:12 <phaazon> yes
14:00:12 <fragamus> jle`: yeah
14:00:15 <Dynetrekk> looks immature to me so far, compared to python - but hey, keep up the good work :) I'm going to keep learning haskell for fun and see what happens. good night everyone!
14:00:20 * hackagebot ghcjs-websockets 0.3.0.3 - GHCJS interface for the Javascript Websocket API  http://hackage.haskell.org/package/ghcjs-websockets-0.3.0.3 (jle)
14:00:29 <magnap> Good night! Have type-safe dreams ;)
14:00:30 <jle`> if you know the encoding, you can use a method from Data.Text.Encoding
14:00:36 <jle`> and then turn the text into a string
14:00:51 <phaazon> ok
14:00:52 <jle`> bytestring doesn't tell you anything about the encoding of the binary in the string...it's just a list of 1's and 0's
14:00:52 <phaazon> I’ll try that
14:00:59 <maerwald> wait what... did he just say haskell looks immature? :o
14:01:07 <phaazon> jle`: so why is there a Show instance then? ;)
14:01:09 <magnap> No, that hmatrix does
14:01:10 <jle`> you can turn it into a string representation of the bytes, but that's probably not what you want
14:01:12 <maerwald> ah
14:01:19 <jle`> you might as well be showing the 1's and 0's :)
14:01:19 <phaazon> well
14:01:24 <phaazon> no
14:01:31 <phaazon> it does show the regular string
14:01:37 <phaazon> but I see escaped characters
14:01:38 <phaazon> like \n
14:01:39 <jle`> it's a happy coincidence
14:01:43 <phaazon> which is not what I want :D
14:01:47 <phaazon> yeah
14:01:51 <phaazon> so Data.Text.Encoding
14:02:00 <jle`> if there are newlines, the \n will still show up in the string...
14:02:12 <jle`> but when you use putStrLn or however you process it, it'll render properly
14:02:29 <magnap> Exactly. They're merely shown escaped
14:02:52 <magnap> > lines ["hello","world"]
14:02:54 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘[Char]’
14:02:54 <lambdabot>      In the expression: "hello"
14:02:54 <lambdabot>      In the first argument of ‘lines’, namely ‘["hello", "world"]’
14:02:57 <magnap> > unlines ["hello","world"]
14:02:57 <JoshieAS> how many of y'all use emacs?
14:02:58 <lambdabot>  "hello\nworld\n"
14:03:04 <magnap> > putStrLn $ unlines ["hello","world"]
14:03:06 <lambdabot>  <IO ()>
14:03:10 <jle`> but yeah, in general, you shouldn't rely on the show instance of ByteString to correlate in any way to the text it might be encoding
14:03:25 <jle`> what if it's encoding text in some arcane way?  bytestring can't know
14:03:49 <magnap> jle`: Missed that it was a bytestring. I agree completely
14:03:49 <jle`> use Data.Text.Encoding to read the bytestring into an encoding of your choice
14:04:10 <phaazon> jle`: well
14:04:12 <phaazon> I want to chomp them
14:04:41 <jle`> if you want to work with it as if it were a string of text, you should get into a type that represents a string of text
14:04:46 <phaazon> I guess filtering with c == '\n' doesn’t work
14:05:07 <jle`> it's like working with a `Maybe a` as a bytestring encoding of it
14:05:21 <jle`> you can't use `fromMaybe` on a bytestring encoding of a Maybe Int
14:05:25 <jle`> ...it's just bytes
14:05:28 <phaazon> sure
14:05:36 <phaazon> but then
14:05:43 <phaazon> decodeUtf8
14:05:54 <magnap> :t decodeUtf8
14:05:54 <lambdabot> Not in scope: ‘decodeUtf8’
14:06:03 <phaazon> I guess it decodes like
14:06:12 <phaazon> ['\','n']
14:06:14 <phaazon> and not
14:06:16 <jle`> yeah, decodeUtf8 :: ByteString -> Text.  just like decodeMaybe :: ByteString -> Maybe Int
14:06:18 <phaazon> ['\n']
14:06:34 <magnap> Looks good to me. I'd use that. Can I import into lambdabot for examples?
14:06:37 <phaazon> do you see what I mean?
14:06:48 <phaazon> @let import Data.Text.Encoding
14:06:49 <lambdabot>  .L.hs:111:1:
14:06:50 <lambdabot>      Data.Text.Encoding: Can't be safely imported!
14:06:50 <lambdabot>      The package (text-1.2.0.4) the module resides in isn't trusted.
14:06:53 <phaazon> nope. :D
14:06:56 <jle`> '\n' is literally 0x0a though
14:07:01 <phaazon> jle`: yeah
14:07:06 <jle`> it's not actually the character '\\' and the character 'n'
14:07:08 <phaazon> so that’s weird
14:07:12 <jle`> what would you expect?
14:07:40 <magnap> It makes a lot of sense to me. It represent a string of arbitrary bytes, thus, a ByteString. You have to decode it before you can work with it as text
14:08:02 <jle`> if your string contains a newline, would you want to get rid of the newlines?
14:08:04 <phaazon> oh come on
14:08:07 <phaazon> fuck me.
14:08:08 <phaazon>     Expected type: IO
14:08:09 <phaazon>                      bytestring-0.10.6.0:Data.ByteString.Internal.ByteString
14:08:09 <phaazon>       Actual type: IO
14:08:09 <phaazon>                      bytestring-0.10.6.0:Data.ByteString.Lazy.Internal.ByteString
14:08:17 <jle`> if you, you can use `unwords . lines'
14:08:27 <jle`> > unwords . lines $ "hello\nworld"
14:08:29 <lambdabot>  "hello world"
14:08:34 <phaazon> jle`: I’m just turning the String into Text
14:08:36 <phaazon> and
14:08:41 <magnap> Though I admit having fallen to the temptation of Data.ByteString.Char8 on multiple occasions
14:08:45 <phaazon> dropAround (\c -> isSpace c || c == '\n)
14:08:54 <phaazon> (I want to strip the newlines)
14:09:10 <glguy> > isSpace '\n'
14:09:11 <lambdabot>  True
14:09:21 <phaazon> o–kay
14:09:22 <phaazon> :D
14:09:23 <magnap> phaazon: You have to import the Data.ByteString.Lazy if you're working with a lazy bytestring
14:09:27 <jle`> > concat . lines $ "hello\nworld"
14:09:29 <lambdabot>  "helloworld"
14:09:32 <phaazon> so something is REALLY weird in my code right now
14:09:36 <kadoban> > :t Data.ByteString.Lazy.toStrict  -- phaazon  Although there may be a better fix.
14:09:37 <lambdabot>  <hint>:1:1: parse error on input ‘:’
14:09:48 <magnap> :t Data.ByteString.Lazy.toStrict
14:09:49 <lambdabot> BSLC.ByteString -> BSC.ByteString
14:10:07 <magnap> phaazon: Just import the lazy module
14:10:45 <athan> in what cases does `contramap . contramap` ~ `fmap . fmap`?
14:10:52 <orion> Why does the ReaderT monad have this kind?: newtype ReaderT r m a :: * -> (* -> *) -> * -> * -- in particular, why does 'm' have kind (* -> *) ?
14:10:54 <athan> (they have a similar type)
14:11:06 <jle`> orion: the m is supposed to be a type constructor
14:11:09 <jle`> like Maybe, or IO
14:11:20 <athan> orion: Because monad transformers are higher-order monads
14:11:22 <jle`> you can't put (Maybe Int) there, but you can put Maybe
14:12:05 <magnap> Note that the list monad is just written []. That confused me in the beginnign
14:12:09 <magnap> *beginning
14:12:16 <magnap> :k []
14:12:17 <lambdabot> * -> *
14:12:21 <jle`> :k ReaderT Int Maybe Bool
14:12:22 <lambdabot> *
14:12:29 <jle`> :k ReaderT Int (Maybe Int) Bool
14:12:30 <lambdabot>     The second argument of ‘ReaderT’ should have kind ‘* -> *’,
14:12:30 <lambdabot>       but ‘Maybe Int’ has kind ‘*’
14:12:30 <lambdabot>     In a type in a GHCi command: ReaderT Int (Maybe Int) Bool
14:12:43 <jle`> the `m` is the monad being transformed
14:13:27 <magnap> :t lift
14:13:28 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
14:13:36 <athan> :i Monad
14:13:42 <jle`> no :i in lambdabot
14:13:43 <athan> :(
14:13:50 <jle`> :k Monad
14:13:51 <lambdabot> (* -> *) -> Constraint
14:13:58 <frerich> :i would be a bit noisy.
14:14:04 <athan> :o
14:14:07 <jle`> i'm sure you wouldn't :)
14:14:11 <athan> good point
14:14:41 <orion> < jle`> the `m` is the monad being transformed <-- that statement just made it click in my brain. Thank you!
14:14:47 <athan> wait nobody answered me :(
14:14:56 <magnap> athan: Answered what?
14:15:05 <athan> magnap: in what cases does `contramap . contramap` ~ `fmap . fmap`?
14:15:05 <jle`> orion: np!
14:15:12 <magnap> :t contramap
14:15:13 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
14:15:27 <magnap> athan: That's way out of my league. Sorry
14:15:28 <jle`> you can think of a ReaderT Int Maybe as a type that acts just like Maybe, except also has the ability to access a global environment
14:15:34 <athan> or really, in what {contra}functors is this possible?
14:15:38 <athan> magnap: np :)
14:16:08 <jle`> maybe Const a?
14:16:15 <athan> hmm
14:16:25 <athan> thanks jle`
14:16:34 <glguy> athan: If you have a type that is both a contravariant and covariant functor then you know that type has a phantom type parameter
14:16:43 <jle`> np. i don't really know of many things that are both contravariant and covariant in meaningful ways except for phantom stuff
14:16:51 <JagaJaga> Opened GHC.Prim and saw `let x = x in x` what does it mean?
14:17:02 <jle`> JagaJaga: it's a way of saying 'undefined'
14:17:07 <jle`> without importing the definition of undefined
14:17:13 <athan> glguy: !!!! WAHHH
14:17:20 * athan hair blows back
14:17:26 <athan> athan's*
14:17:41 <indiagreen> JagaJaga: the comment at the beginning, by the way, says “It is not code to actually be used. Its only purpose is to be consumed by haddock.”
14:17:43 <jle`> JagaJaga: the actual definition is provided by the compiler, and that's just there for placeholder stuff
14:18:26 <magnap> "Me hair blows back"? That's a case error, the type error of grammar
14:18:27 <JagaJaga> jle`: indiagreen: yeah, I thought so (without reading the beginning). Thank you!
14:18:29 <magnap> ;)
14:19:39 <glguy> contramap (const ()) 07. fmap (const ()) 07:: (Functor f, Contravariant f) 07=> f a 07-> f b
14:19:58 <magnap> glguy: Where'd you get colors?
14:20:44 <glguy> My IRC client has a Haskell syntax highlighter
14:21:14 <magnap> That is so awesome! But how come I can see it? I guess IRC supports color? Which client?
14:21:40 <glguy> IRC has an informal color specification. The client is http://hackage.haskell.org/package/irc-core
14:21:59 <magnap> Of course it's on Hackage ;)
14:22:33 <ReinH> glguy: needs more unicode syntax :)
14:23:00 <tommd> Only if every single line includes a GHC unicode pragma...
14:23:12 <magnap> ReinH: Weren't you the guy with agda input mode?
14:23:25 <ReinH> No, I usually use latex mode
14:25:21 * hackagebot composition-extra 0.0.0.1 - Combinators for unorthodox structure composition  http://hackage.haskell.org/package/composition-extra-0.0.0.1 (athanclark)
14:26:20 <fragamus> http://newartisans.com/2009/03/hello-haskell-goodbye-lisp/
14:26:39 <fragamus> i need some lisp advocate to try and refute the macro discussion
14:27:22 <fragamus> it was a light treatment of the subject and I suspect there is more coolness to macros
14:28:02 <magnap> Template Haskell shows the need for true macros in Haskell
14:28:08 <fragamus> yeah
14:28:09 <hodapp> why do you need a refutation of an article from 2009?
14:28:21 <fragamus> because of ^
14:28:45 <phaazon> jle`: do you know a way to translate html_entities in String to unicode?
14:28:47 <phaazon> like
14:28:54 <fragamus> what magnap said and there might be other points to be made
14:29:02 <phaazon> « Let&#039;s Talk About Dogs! »
14:29:11 <phaazon> the &#039 is a ’
14:29:15 <jle`> phaazon: a couple of libraries provide that
14:29:19 <phaazon> oh cool
14:29:19 <magnap> phaazon: What?
14:29:25 <magnap> Oh, sorry
14:29:31 <jle`> blaze did it for me when i was using blaze, but it might be a bit overkill to get blaze just for this
14:29:49 <phaazon> I might have blaze as dependency already
14:29:53 <phaazon> blaze-html
14:29:57 <jle`> it looks like tagsoup does it too
14:30:07 <phaazon> ah, nope, don’t
14:30:10 <magnap> tagsoup too
14:30:13 <phaazon> ok
14:30:14 <magnap> Ninja'd!
14:30:17 <phaazon> I,ll have a look
14:30:19 <phaazon> thanks
14:30:32 <jle`> i don't know of any libraries that offer it standalone but the keyword is like html escape or something :)
14:31:13 <magnap> jle`, phaazon: Text.XHtmlCombinators.Escape
14:31:25 <jle`> woo hoo
14:31:45 <magnap> *Almost* standalone
14:31:54 <phaazon> yeah well
14:31:57 <phaazon> tagsoup will make it
14:31:58 <magnap> Nearer than tagsoup at least ;)
14:31:59 <phaazon> thank you :)
14:32:18 <magnap> phaazon: I think xhtml-combinators is a better choice than tagsoup
14:34:16 <magnap> > fix (((<$>) <$> (:) <*> ((=<<) <$> (return <$>) <$> (*) <$> join (+))) 1)
14:34:18 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
14:34:30 <magnap> That's... impressive
14:34:50 <jle`> > iterate (*2) 1
14:34:52 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
14:34:52 <fragamus> WTF
14:34:55 <benzrf> lel
14:34:56 <hodapp> jle`: showoff.
14:34:59 <hodapp> magnap: showoff.
14:35:04 <magnap> From the Uncyclopedia Haskell page. Also includes such gems as System.IO.Unsafe.Really.IMeanIt.reallyReallyAbsurdlyUnsafePerformIOShameOnYou
14:35:10 <magnap> hodapp: Not my invention
14:35:23 * hodapp flees
14:35:50 <magnap> Hodapp: come back! We mean no harm! We don't bite, even if our code sometimes looks like Perl!
14:37:00 <fragamus> so I think it is safe to say that lisp's macro capability has some value 
14:37:22 <fragamus> a desugared haskell might be a good idea
14:37:22 <magnap> fragamus: It has indeed. But it gives you a lot of power
14:37:30 <magnap> Which can be both a good and bad thing
14:37:51 <fragamus> in the hands of a haskeller it will always be used for good
14:38:13 <fragamus> except for whoever made lambdabot do that above
14:38:23 <magnap> fragamus: https://github.com/haskell-lisp/liskell
14:38:44 <magnap> From the page https://wiki.haskell.org/Haskell_Lisp
14:38:53 <Cale> fragamus: There's been more than one S-expression style version of Haskell over the years, they were never popular
14:39:27 <fragamus> popular is not what i care about
14:39:37 <fragamus> i seek the grail
14:39:45 <fragamus> ultimate expressivity
14:40:24 <Cale> Well, there's nothing which really prevents you from writing macros in Haskell normally, supposing you understand how the syntax of Haskell works.
14:41:20 <Cale> (Using Template Haskell)
14:41:51 <magnap> That's nothing like Lisp macros. Same idea, but manipulating sexps is way different
14:41:52 <newsham> you can get desugared haskell.  ghc will do it for you
14:41:56 <fragamus> i think something is lost when the syntax of lisp is lost
14:42:11 <magnap> fragamus: agreed
14:42:16 <fragamus> no shit?
14:42:17 <jle`> i like to think that the power of lisp is achieved in ways orthogonal to the power of haskell
14:42:31 <magnap> jle`: Also agreed
14:42:37 <jle`> lisp is good for a set of reasons more or less unrelated to how haskell is good
14:42:42 <magnap> Safety comes at the cost of power
14:42:45 <fragamus> ghc can desugar?
14:42:47 <jle`> they achieve their utility in different ways...so mixing it might not be a bad idea
14:42:51 <jle`> *might not be a good idea
14:42:59 <jle`> like adding two antiparallel vectors
14:43:02 <newsham> -ddump-ds:
14:43:02 <newsham> desugarer output
14:43:19 <fragamus> gotta try that
14:43:48 <jle`> the things that are good about haskell might detract from the things that are good about lisp, and vice versa
14:44:08 <fragamus> but maybe not
14:44:25 <fragamus> it might suck and be a nightmare
14:44:32 <newsham> http://www.haskellforall.com/2012/10/hello-core.html
14:44:36 <fragamus> or it could be like strippers and beer
14:45:32 <maerwald> what's the worst(!) fizzbuzz implementation in haskell :D
14:46:09 <phaazon> dammit
14:46:11 <magnap> mearwald: What's the biggest natural number?
14:46:17 <phaazon> xhtml-combinators is terrible to use
14:46:26 <phaazon> and tagsoup doesn’t provide what I need
14:46:42 <maerwald> magnap: > last [1..]
14:46:54 <newsham> ?type last [1..]
14:46:55 <lambdabot> (Enum a, Num a) => a
14:48:10 <magnap> maerwals: My point with the question was that you can always make an implementation worse. There exists at least one implementation of FizzBuzz in Haskell. Thus, by induction, the worst is infinitely bad ;)
14:48:11 <newsham> > [65530..] :: Word16
14:48:12 <lambdabot>      Couldn't match expected type ‘Word16’ with actual type ‘[Integer]’
14:48:12 <lambdabot>      In the expression: [65530 .. ] :: Word16
14:48:19 <newsham> > [65530..] :: [Word16]
14:48:20 <lambdabot>  [65530,65531,65532,65533,65534,65535]
14:48:35 <newsham> > last [0..] :: Word16
14:48:37 <lambdabot>  65535
14:48:53 <magnap> > maxBound :: Int
14:48:54 <lambdabot>  9223372036854775807
14:48:58 <maerwald> > last [0..] :: Integer
14:49:02 <lambdabot>  mueval-core: Time limit exceeded
14:50:21 * hackagebot proton-haskell 0.5 - Simple XML templating library  http://hackage.haskell.org/package/proton-haskell-0.5 (jrbriggs)
14:52:03 <arkeet> phaazon: what is it that you're looking for?
14:52:50 <magnap> arkeet: A function that escapes text to HTML
14:52:55 <phaazon> nevermind
14:53:01 <phaazon> found it on stackoverflow
14:53:07 <magnap> arkeet: A function that escapes text to HTML
14:53:17 <magnap> I seem to have lost my internet connection
14:53:31 <magnap> Wait, no I haven't. Sorry, guys
14:53:44 <arkeet> phaazon: toHtml from blaze-html?
14:54:03 <arkeet> or from lucid
14:54:07 <zinfandel> phaazon: You can write your own
14:55:08 <steshaw> Is there anything like Lucene/ElasticSearch/Solr written in Haskell?
14:55:25 <magnap> I think there's an interface to ElasticSearch
14:55:31 <phaazon> arkeet: nope
14:55:33 <phaazon> I used tagsoup
14:55:45 <phaazon> fromTagText . head . parseTags
14:55:48 <steshaw> magnap: Bloodhound I think
14:55:49 <magnap> steshaw: https://github.com/bitemyapp/bloodhound
14:55:52 <phaazon> not very straightforward though…
14:55:56 <arkeet> you want to read html
14:55:56 <magnap> Yup ;)
14:55:56 <zinfandel> phaazon: T.replace ">" "&gt;" . T.replace "<" "&lt;" . T.replace "\"" . T.replace "\"" "&quot;" . T.replace "&" "&amp;"
14:56:04 <arkeet> ?
14:56:26 <phaazon> I wanted to decode them
14:56:28 <magnap> steshaw: Is it important that it is written in Haskell?
14:57:40 <zinfandel> phaazon: Upps. There is one extra T.replace, but you get the idea.
14:58:07 <phaazon> yeah
14:58:12 <phaazon> I’m not very used to using Text
14:58:24 <phaazon> I use String a lot as I rarely need text performance
14:58:37 <zinfandel> phaazon: And if you'll be using blaze-html just for that, I thin it's better to just use blaze-builder
14:58:50 <phaazon> I use tagsoup
14:58:52 <phaazon> it’s working
14:58:59 <zinfandel> phaazon: That's what blaze-html would use to encode text
14:59:03 <magnap> steshaw: Not knowing much about ElasticSearch, I'd just use Bloodhound
14:59:15 <phaazon> I use blaze-html for my website actually
14:59:20 <phaazon> not the project I’m on right now :)
14:59:33 <zinfandel> phaazon: Emm. Isn't tagsoup more about parsing?
15:00:11 <phaazon> maybe
15:00:17 <steshaw> magnap: ES is a good option it's just that the GC pauses can be problematic. Hence of I wondering about a purely Haskell solution.
15:00:21 * hackagebot tellbot 0.5.1.4 - IRC tellbot  http://hackage.haskell.org/package/tellbot-0.5.1.4 (DimitriSabadie)
15:01:07 <magnap> steshaw: Not any that I know of, but that isn't saying much
15:02:58 <orion> I want to attempt to open a connection, catch the exception in the event it fails, wait 5 seconds, and retry forever. Has anyone ever captured this pattern and given it a name?
15:04:00 <JoshieAS> what does everyone use for their IDE/editor?
15:04:09 <luzie> emacs
15:04:10 <Denommus> JoshieAS: I use Emacs
15:04:18 <JoshieAS> Evil Mode or not?
15:04:27 <Denommus> I don't like modal editing
15:04:47 <luzie> I prefer vi binds
15:05:48 <Denommus> I just use caps lock as an additional ctrl
15:06:07 <maerwald> I use sed and cat :o ...editor war incoming
15:06:59 <Denommus> Emacs is the editor that sucks less
15:07:02 <JoshieAS> Denommus: Me too
15:08:37 <athan> So contravariant function composition is something like `flip .`, correct?
15:09:21 <athan> If you were to imagine contravariant composition in terms from the composition library, with the `.:`, and `.:.` combinators, what would it's type look like?
15:10:50 <maerwald> athan: https://hackage.haskell.org/package/plailude-0.6.0/docs/Plailude.html
15:12:30 <athan> maerwald: Not quite what I was looking for, but I dig it :)
15:13:09 <athan> I'm looking for something like `(-.:) :: (c -> b) -> (a -> b -> d) -> a -> c -> d
15:13:13 <athan> id what you would call that
15:13:26 <athan> ...targeted application / precomposition?
15:13:41 <newsham> with lens lib, lets say I have Foo record which contains a Maybe Bar record which contains a value Int. can i easily increment the Int field when its present?
15:14:00 <newsham> ie   bar.maybe.value += 1
15:14:41 <fragamus> question: does this syntax for core approach the simplicity of lisp syntax?  https://downloads.haskell.org/~ghc/6.12.2/docs/html/ext-core/core.pdf
15:14:50 <glguy> You'd use (+~) rather than (+=) to do it as a function
15:14:53 <jle`> athan: data Op b a = Op (b -> a)
15:15:02 <athan> jle`: Thank you!!
15:15:03 <jle`> athan: contramap f (Op g) = Op (g . f)
15:15:05 <glguy> in place of "maybe" you'd use "mapped" or similar
15:15:09 <athan> oop
15:15:12 <fragamus> like if you wanted a badass lisp-haskell thingy
15:15:25 <athan> jle`: Right, so contramap is precomposition
15:15:45 <jle`> yeah, in things where 'precomposition' makes sense
15:15:48 <athan> I want something to precompose _deeper_ in a function
15:15:53 <athan> hmm
15:16:01 <jle`> just like fmap is postcomposition in things where composition makes sense
15:16:13 <athan> (so you would precompose on the second arg, not the first arg of `g`)
15:16:17 <jle`> in things where they don't...then they aren't :)
15:16:27 <athan> :x
15:16:34 <newsham> glguy: what is that? a traversal? a prism?
15:16:37 <oconnore> When I initialize a Config in ghci as -> defaultConfig {configQuickCheckSeed = Just 234987} I get a config, but in ghc, I get "Missing field in record construction configRerun"
15:16:43 <oconnore> here -> http://hackage.haskell.org/package/hspec-core-2.1.7/docs/Test-Hspec-Core-Runner.html#t:Config
15:16:47 <oconnore> what am I doing wrong?
15:17:01 <benzrf> :t mapped
15:17:02 <lambdabot> (Functor f, Settable f1) => (a -> f1 b) -> f a -> f1 (f b)
15:17:04 <glguy> newsham: mapped :: Functor f => Setter (f a) (f b) a b
15:17:13 <athan> O_O
15:17:24 <athan> I...
15:17:50 <ronh-> oconnore does defaultConfig set configRerun?
15:18:19 <athan> benzrf: wtf?!?!
15:18:26 <oconnore> ronh-: yes
15:18:35 <oconnore> it defaults to False
15:19:11 <benzrf> setters idk
15:19:19 <athan> :|
15:19:38 <athan> wat
15:23:07 <athan> jle`: So what would you call targeted precomposition? :|
15:23:25 <athan> (c -> b) -> (a -> b -> d) -> a -> c -> d
15:23:50 <jle`> that looks like snd, if you uncurry your function
15:23:54 <jle`> er, second
15:23:56 <athan> hmm
15:24:01 <newsham> so mapped is like a lens over functors
15:24:24 <athan> (d -> c) -> (a -> b -> c ->  e) -> a -> b -> d -> e
15:24:25 <jle`> (c -> b) -> ((a, b) -> d) -> ((a, c) -> d)
15:24:26 <athan> ?
15:24:38 <jle`> :t \f g -> f . second g
15:24:39 <lambdabot> ((d, c1) -> c) -> (b -> c1) -> (d, b) -> c
15:24:49 <jle`> :t \g f -> f . second g
15:24:50 <lambdabot> (b -> c1) -> ((d, c1) -> c) -> (d, b) -> c
15:24:52 <ion> newsham: Only a setter.
15:25:19 <jle`> yeah, you can't "view" on arbitrary functors
15:25:24 <newsham> isnt there a getter than can handle possibly multiple data items (using a monoid)?
15:25:47 <glguy> newsham: Yes over functors, setter is more general than lens. http://hackage.haskell.org/package/lens note how high on the inheritence chart setter is
15:26:14 <newsham> where in the doc tree is mapped defined?
15:26:31 <athan> thanks jle` :)
15:26:46 <glguy> There's an Index link at the bottom of the doc TOC : http://hackage.haskell.org/package/lens-4.9.1/docs/doc-index.html
15:27:01 <newsham> ahh, cool
15:27:16 <arkeet> newsham: a getter with multiple targets is a Fold
15:27:47 <arkeet> > ["ab","cd"] ^. folded
15:27:48 <lambdabot>  "abcd"
15:27:51 <mjrosenb> is lens more than the combinators from the 15 year old paper?
15:28:01 <newsham> i wonder if imperative languages will adopt some of these ideas 
15:28:20 <maerwald> not in a desirable way
15:28:23 <bitemyapp> mjrosenb: what 15 year old paper?
15:28:27 <arkeet> > [x,y] ^. folded
15:28:28 <lambdabot>  x <> y <> mempty
15:29:36 <mjrosenb> bitemyapp: "Function programming with Bananas, Lenses, Envelopes and Barbed Wire"
15:29:46 * mjrosenb swears he's going to get through that one day
15:29:51 <newsham> > flip runStateT (1,2,Just(3,4)) (_3.mapped._1 += 100)
15:29:52 <lambdabot>      No instance for (Show (m0 ((), (t0, t1, Maybe (t2, t3)))))
15:29:52 <lambdabot>        arising from a use of ‘show_M451024174913800959629479’
15:29:52 <lambdabot>      The type variables ‘m0’, ‘t0’, ‘t1’, ‘t2’, ‘t3’ are ambiguous
15:30:07 <mjrosenb> maybe I'll buy a kindle
15:30:08 <fragamus> does core retain lazy evaluation semantics
15:30:11 <newsham> > flip runState (1,2,Just(3,4)) (_3.mapped._1 += 100)
15:30:12 <lambdabot>  ((),(1,2,Just (103,4)))
15:30:19 <arkeet> fragamus: yes
15:30:28 <fragamus> awesome
15:30:31 <mjrosenb> fragamus: pretty sure haskell is in fact lazy to the core.
15:30:38 <glguy> mjrosenb: That's a different lens
15:31:03 <ion> > (1,2,Just(3,4)) &~ _3.mapped._1 += 100
15:31:04 <lambdabot>  (1,2,Just (103,4))
15:31:20 <arkeet> :t (&~)
15:31:21 <lambdabot> s -> State s a -> s
15:31:23 <arkeet> ah
15:31:26 <xpilot> hello
15:31:34 <xpilot> I'm having some trouble with ':
15:31:35 <arkeet> just flipped execState
15:31:56 <mjrosenb> glguy: iiinteresting
15:32:00 <xpilot> I can't seem to do simple things like :k (':)
15:32:08 <xpilot> :k (':)
15:32:08 <mjrosenb> in that case, I have /no/ clue what the lens package has in it.
15:32:09 <lambdabot> parse error on input ‘:’
15:32:10 <arkeet> xpilot: do you have DataKinds on?
15:32:18 <xpilot> arkeet: yes
15:32:23 <ion> xpilot: k '(:)
15:32:30 <xpilot> :k '[]
15:32:31 <lambdabot> [k]
15:32:33 <arkeet> mm
15:33:25 <arkeet> no idea
15:33:28 <fragamus> mjrosenb: I think some people have concluded that restricting ourselves to the use of bananamorphisms etc does not in general lead to the provability we seek
15:33:30 <Pamelloes> The HTTP package's major version number is 4000. o_O
15:33:33 <xpilot> my only solution right now is to roll my own data List = Nil | Cons a (List a)
15:33:56 <newsham> mjrosenb: lens has stuff to let you build references to data types, and let you use setters and gettors on those pointers, and do folds over referenced collections, and other things
15:34:40 <newsham> like how in above example "_3.mapped._1" referenced the third arg in a tuple, the inside of the Maybe's 2nd tuple member
15:34:48 <newsham> and let me modify it with "+= 1"
15:35:27 <bitemyapp> mjrosenb: not the same thing at all.
15:35:34 <maerwald> so many people say I need lens, but I actually never did... maybe I haven't met any problems that really require it
15:35:44 <bitemyapp> mjrosenb: that paper is about recursion schemes, the lenses referred to there are not profunctor/van laarhoven lenses.
15:35:51 <jle`> i would say you "need" lens as much as you "need" monads
15:35:59 <jle`> you don't really...it just makes life a lot simpler
15:36:07 <bitemyapp> I don't like writing case expressions or nested expressions of any kind
15:36:12 <maerwald> jle`: well, you can't escape monads if you use libraries
15:36:12 <bitemyapp> and I am tremendously lazy
15:36:14 <bitemyapp> thus, lens.
15:36:19 <newsham> lens is a great way to not have to worry about all the bad things about haskell records
15:36:28 <ion> maerwald: You don’t even need Haskell, you can do with Game of Life or any other Turing-complete thing.
15:36:35 <jle`> maerwald: well, yeah, that's the same deal as a library that only exports lenses and not normal accessors :)
15:36:36 <mjrosenb> jle`: well, in haskell, you /need/ monads, if you want to actually do IO.
15:36:48 <maerwald> jle`: haven't found one of those yet
15:36:50 <ion> maerwald: However, Haskell may be more convenient than Game of Life for certain things.
15:36:55 <jle`> you might just need monomorphic IO combinators
15:36:56 <mjrosenb> but this is not fundamental to lambda calculus.
15:37:13 <kadoban> mjrosenb: Not necessarily, there's a lot you can do with Applicative
15:37:21 <jle`> but yes, ignore io :P
15:37:28 <luzie> isn't there an alternative prelude that does io without monads?
15:38:05 <mjrosenb> newsham: hrmm, I may have to look at these other lenses.  Is there an introduction to them anywhere?
15:38:14 <mjrosenb> also, are they related to semantic editor combinators?
15:38:15 <newsham> https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
15:38:16 <ion> mjrosenb: GHC.Base.bindIO, GHC.Base.returnIO
15:38:35 <newsham> i believe they are related to semantic editor combinators
15:38:47 <arkeet> semantic editor combinators are setters
15:38:48 <newsham> ie. based on them, and extended
15:39:45 <maerwald> "Lenses and their cousins are a way of declaring how to focus deeply into a complex structure." <- interesting, but why would I want to design a complex structure :P
15:40:17 <srhb> maerwald: Some structures are inherently complex.
15:40:23 * hackagebot composition-extra 0.0.0.2 - Combinators for unorthodox structure composition  http://hackage.haskell.org/package/composition-extra-0.0.0.2 (athanclark)
15:40:26 <maerwald> you have a point there
15:40:51 <maerwald> but it's still something I rather avoid
15:40:55 <srhb> Of course.
15:40:57 <srhb> Wherever you can.
15:41:27 <athan> Hey guys, what did I do wrong here? http://lpaste.net/132502
15:41:38 <mjrosenb> newsham: danke.
15:41:56 <mjrosenb> maerwald: I am writing a gui toolkit, and it has, well, grown in complexity.
15:42:14 <maerwald> mjrosenb: cool, last time I used the Gtk bindings it was not fun
15:42:23 <newsham> maerwald: if you dont have complex state, you may not benefit from lens 
15:42:39 <newsham> some programs are even written without them
15:43:37 <pavonia> athan: What does it look like with -v?
15:45:05 <athan> pavonia: I don't think it gave much more information. As a bit of background, I'm trying to compile with GHC 7.8 and Cabal 1.22 :\
15:45:20 <ion> maerwald: Maybe Integer is a complex structure. It involves tagged pointers, thunks, arbitrary-size implementations of integers and whatnot. However, that is hidden from you by abstraction. There is nothing wrong with complex structures resulting from composition of reasonably simple individual things.
15:46:07 <maerwald> ion: but I don't need any lens to work with Integer
15:46:19 <maerwald> because the complexity is hidden
15:46:21 <maerwald> so...
15:47:19 <Pamelloes> When I updated cabal after upgrading ghc, it installed a bunch of dependency packages into ~/.ghc/xxx-7.10.1/package.conf.d. For 7.8.3, package.conf.d only contained cabal. Is there a reason for this?
15:49:20 <athan> Can I have multiple versions of the Cabal library installed at one time?
15:49:37 <c_wraith> it's not wired in to GHC
15:50:06 <Pamelloes> what?
15:50:12 <c_wraith> but you have all the standard issues with multiple versions of the same package
15:50:16 <ion> maerwald: But you can use lens to work with Integer, and Maybe Integer, and newtype YourType = YourThing (Maybe Integer), and yes, the complexity is still hidden.
15:52:31 <pavonia> athan: According to https://github.com/haskell/cabal/issues/2320 it has already been fixed
15:54:19 <joeyh> does anyone know what is the intended behavior of System.Posix.IO.getLock?
15:54:26 <c_wraith> uh.  What does * mean on a -hy heap profile?
15:54:55 <c_wraith> joeyh: I think it's intended to be a passthrough to the POSIX function?
15:54:59 <joeyh> in particular, if a process that has a lock fd open calls it on another fd attached to the same file, it seems to clear the lock, which I found very surpsiring
15:55:12 <joeyh> I don't remember fcntl locking behaving that way
15:56:15 <c_wraith> Oh.  It means "heap allocated data of unknown type"
15:56:16 <joeyh> guess I should write the C code the check it and file a bug
16:01:11 <zipper> Uh can I use ../ when specifying a FilePath in haskell?
16:01:12 <kor_adana> guys, what happens when you get kicked off of an IRC channel?
16:01:31 <[FreeLay]> <Ronsor> well you have to rejoin ofcourse
16:01:40 <kor_adana> but what does it look like on my screen?
16:01:43 <kor_adana> does it just close out?
16:01:52 <kadoban> kor_adana: It depends on the client of course.
16:01:53 <zipper> Also uh say I want to get the result of a monadic computation and use it in pure code how can I do that?
16:01:54 <arkeet> depends on the client, but #haskell is not really the place to ask.
16:02:01 <kor_adana> i'm using the web client
16:02:14 <kor_adana> where would be the place to ask?
16:02:37 <kadoban> zipper: Depends on the Monad. Some, like IO, you generally can't. Like for State you do something like evalState or one of those.
16:03:21 <Denommus> zipper: I don't know what you mean from your last question
16:03:44 <Denommus> zipper: but if you do fmap or (>>=) you're using the result of the computation in the pure code :-P
16:03:47 <kor_adana> kadoban: if I'm using the freenode.net website to connect, what would it look like if I were kicked off?
16:03:58 <kadoban> kor_adana: No idea. #freenode maybe
16:04:04 <Denommus> zipper: but the monadic code calls the pure code, never the other way around
16:04:34 <kor_adana> could someone here just kick me off this channel?
16:04:54 <kadoban> kor_adana: Go make your own channel and kick yourself.
16:05:10 <kor_adana> that won't really help me
16:05:24 * hackagebot hapistrano 0.2.0.2 - A deployment library for Haskell applications  http://hackage.haskell.org/package/hapistrano-0.2.0.2 (stackbuilders)
16:05:31 <kor_adana> can someone here just kick me?
16:05:33 <arkeet> @where ops
16:05:33 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
16:05:37 <arkeet> I suggest banning without kicking.
16:05:46 <kor_adana> yes, do that then
16:06:00 <kor_adana> ban or kick me
16:06:05 <fragamus> no 
16:06:16 <kor_adana> why not?
16:06:23 <kor_adana> i'm serious, i need to see what this looks like
16:06:28 <fragamus> you have not violated any policy
16:06:28 <TimWolla> kor_adana, try using an own channel and kick yourself?
16:06:40 <kor_adana> i don't know how to do that
16:06:59 <kor_adana> and i need to have the full user experience of being kicked and/or banned
16:07:06 <kor_adana> it's kind of important
16:07:57 <kor_adana> well?
16:08:01 <kadoban> So go figure it out, that way you can be less annoying to others and you'll learn something as well.
16:08:29 <kor_adana> i don't have the time, i can just be more annoying to you and we can both with if you just kick/ban m
16:08:30 <kor_adana> e
16:08:30 <max-m> You could /join 0, this is like being kicked from all channels at the same time! :^)
16:08:58 <JoshieAS> just kick the guy, it's in the name of (pseudo?)science
16:08:59 <acowley> No kicks, no bans, only fmaps.
16:09:17 <kor_adana> yes, kick the guy. listen to JoshiAS
16:09:21 <Bor0> has anyone tried github.com/conscell/hugs-android?
16:09:27 <fragamus> no he did not do anything kick worthy
16:09:34 <kor_adana> what is kick worthy?
16:09:36 <JoshieAS> nevermind, don't kick him, he misspelled my name
16:09:50 <max-m> kor_adana, join #kor_adana and /kick kor_adana 
16:10:08 <arkeet> can you guys just stop talking to him.
16:10:16 <kor_adana> k
16:10:17 <kor_adana> i
16:10:17 <kor_adana> c
16:10:18 <kor_adana> k
16:10:19 <kor_adana> m
16:10:19 <kor_adana> e
16:10:21 <kor_adana> please
16:10:55 <codehero> kor_adana: just write ! squirrel minus the space
16:11:33 <kor_adana> !squirrel
16:11:47 <codehero> huh
16:11:53 <codehero> oh wait
16:11:55 <codehero> wrong channel
16:11:57 <codehero> lol
16:11:59 <codehero> sry
16:12:05 <JagaJaga> When (<$) is useful?
16:12:15 <mjrosenb> codehero: what channel does that do something in?
16:12:19 <hpc> :t (<$)
16:12:21 <lambdabot> Functor f => a -> f b -> f a
16:12:25 <pavonia> @squirrel
16:12:25 <lambdabot> Unknown command, try @list
16:12:28 <hpc> JagaJaga: sometimes!
16:12:35 <codehero> mjrosenb: #/r/ADHD
16:13:02 <JagaJaga> hpc: :D Can you give some examples?
16:13:17 <hpc> JagaJaga: for instance, if you ever want just the structure of something, () <$ foo
16:13:19 <pavonia> JagaJaga: It's usefeul e.g. with parsers when you want to parse s string but return a construtor that doesn't use the extact string
16:13:33 <pavonia> *a string
16:13:47 <mjrosenb> JagaJaga: it is kind of like fmap, but when your 'function' would just be const x.
16:13:52 <c_wraith> > () <$ "hello!"
16:13:53 <lambdabot>  [(),(),(),(),(),()]
16:14:11 <arkeet> > "hello" <$ guard (1 < 2)
16:14:12 <lambdabot>      No instance for (Show (f0 [Char]))
16:14:12 <lambdabot>        arising from a use of ‘show_M807375353640050662630287’
16:14:12 <lambdabot>      The type variable ‘f0’ is ambiguous
16:14:24 <arkeet> > "hello" <$ (guard (1 < 2) :: Maybe ())
16:14:25 <lambdabot>  Just "hello"
16:14:31 <arkeet> > "hello" <$ (guard (1 > 2) :: Maybe ())
16:14:32 <lambdabot>  Nothing
16:15:41 <hpc> or in monad speak, \x -> do {action; return x}
16:16:14 <pavonia> In parsec you can e.g. use something like 'True <$ string "true" <|> False <$ string "false"'
16:16:27 <TimWolla> mjrosenb, so the equivalent of `>>` in a Monad?
16:17:36 <marchelzo_> I'm trying to cabal install something and it fails, saying: "requires alex version >= 2.3". I have alex 3.1.4 and it's in my PATH. What is wrong?
16:17:49 <mjrosenb> TimWolla: with its arguments reversed.
16:18:20 <ion> a <$ x == x >> return a
16:18:23 <mjrosenb> marchelzo_: do you have a sandbox set up? also, does cabal know about it?
16:18:25 <ReinH> marchelzo_: what does cabal info alex say that you have installed?
16:19:11 <marchelzo_> mjrosenb: no sandbox
16:19:33 <JagaJaga> pavonia: mjrosenb: very strange use-cases... :/
16:20:04 <pavonia> No, very common, IMHO
16:20:12 <marchelzo_> ReinH: versions available: 2.2, 2.3.4, 2.3.5, ... a bunch of others
16:20:18 <marchelzo_> oh
16:20:32 <marchelzo_> ReinH: versions installed: [ Unknown ]
16:20:35 <pavonia> JagaJaga: I'm using it all the time with parser combinators
16:20:36 <marchelzo_> that's not good
16:21:03 <kadoban> JagaJaga: It makes a lot of sense in practice in Parsec and other places. Like if you're building up a data structure or function call from parsed values, it lets you have "structure" to the parsed values, like say it needs a '+' between something but you don't actually want a value from that, etc.
16:21:23 <ion> JagaJaga: https://mobile.twitter.com/hajotus/status/598131415121813504 ;-) Re: when is <$ useful
16:22:17 <Pamelloes> I'm having an issue where a dependency is requiring time < 1.5, but cabal says I have version 1.5.0.1 installed. I'm in a sandbox, so where is this coming from?
16:22:47 * mjrosenb would guess ghc?
16:23:02 <Denommus> how do I create a timer in gtk3? (the haskell library)
16:23:17 <JoshieAS> ReinH: y'all do any Haskell specific meetups in Portland?
16:24:02 <yac> <command line>: cannot satisfy -package-id os-release-0.2.0-35abb19646d1da7e4dac33b456eb747a
16:24:03 <pavonia> Denommus: There's timeoutAdd somewhere
16:24:27 <yac> I patched the os-release and installed it via cabal --sandbox-config-file path/to/the/project/that/uses/the/os-release install
16:24:39 <yac> and now I'm getting that ^ error
16:24:45 <yac> how can I fix that?
16:26:16 <acowley> yac: You may want to do a cabal clean
16:26:25 --- mode: ChanServ set +o glguy
16:26:25 --- mode: glguy set +b *!*@gateway/web/freenode/ip.206.71.252.34
16:26:26 <yac> oh, cabal configure
16:27:38 <JagaJaga> kadoban: thank you!
16:29:54 <joeyh> c_wraith: https://github.com/haskell/unix/issues/44 here's the weird bug with getLock clearing a lock
16:30:20 <Euler_> good evening, I have a question concerning bound variables (if that's the correct english term), is someone here willing to check if I got everything right?
16:30:25 <Denommus> pavonia: I'll check it, thanks
16:31:28 <kadoban> Euler_: Only one way to find out.
16:31:28 --- mode: glguy set -o glguy
16:31:37 <ReinH> JoshieAS: http://pdxfunc.org/ has a lot of haskell stuff, I think. Maybe talk to pdxleif
16:31:50 <JoshieAS> grazi
16:32:01 <Euler_> the first problem would be what the bound variables in the term s := if (\x -> let x = \x -> (y x) in x) then (x y) else (let f x = (w x) in \x -> w) are
16:32:45 <Euler_> and also what  the free ones are
16:33:53 <Euler_> the second question ist, how the bound variables should be renamed so that they are disjunct to the set of free variables in the term
16:34:37 <acowley> Euler_: Is that a boolean condition?
16:34:51 <acowley> \x -> let x = \x -> (y x) in x
16:35:14 <Euler_> I suppose so, but I also don't really get, how that should be boolean
16:35:24 <ion> Those exercises look like intentionally the most painful way to learn Haskell.
16:36:11 <zipper> Also uh say I want to get the result of a monadic computation and use it in pure code how can I do that?
16:36:25 <kaidelong> well the bound variables are whatever is introduced by 
16:36:27 <kaidelong> \ or let
16:36:40 <kaidelong> the free variables are what we can only know about by seeing the whole program
16:36:50 <zipper> kaidelong: Oh yeah thanks
16:37:01 <Euler_> kaidelong: so the bound ones would be x and f, I suppose?
16:37:05 <fragamus> I think following http://www.willamette.edu/~fruehr/haskell/evolution.html might be worse
16:37:19 <kaidelong> looks like it, but there is more than one x in there
16:37:20 <TimWolla> kaidelong, ghci tells me that 'y', 'x', 'w' are not in scope. So those are free?
16:37:41 <acowley> There are several distinct occurences of 'x'
16:37:41 <ion> zipper: Given your pure function f, fmap f action or do { x <- action; pure (f x) } for instance.
16:37:49 <acowley> But I'm still not buying that boolean
16:38:04 <kaidelong> TimWolla: basically, but again we need to be careful because there's more than one x
16:38:22 <mjrosenb> how do I ask cabal which version of a package is installed?
16:38:23 <Euler_> also, I only got this one term, so I think the free variables have to be figured out without any further context
16:38:44 <acowley> mjrosenb: Use ghc-pkg for that instead
16:38:54 <acowley> mjrosenb: If in a sandbox, cabal sandbox hc-pkg list
16:38:54 <kaidelong> well conventionally, the free variables are exactly those you can't figure out without any further context
16:39:37 <Euler_> oh, sorry, I missunderstood your statement, kaidelong
16:40:23 <acowley> You will often say that, e.g., "y is free in e" after defining your expression, e
16:40:30 <Euler_> x, y and w are also the ones that I figured out as free variables with the algorithm we were supposed to use, so I seems to be the right answer
16:40:40 <JagaJaga> https://hackage.haskell.org/package/ghc-prim-0.4.0.0/docs/src/GHC-Tuple.html Tuples are really made this way by hands?
16:40:41 <acowley> To avoid ambiguity
16:41:13 <acowley> Hand-crafted tuples, limited edition
16:41:35 <ion> Artisanal tuples
16:41:41 <Euler_> okay, that makes sense, acowley
16:41:52 <Euler_> so the second question remains
16:41:53 <Hijiri> Meticulously refined to perfection
16:41:53 <Euler_> [01:33] <Euler_> the second question ist, how the bound variables should be renamed so that they are disjunct to the set of free variables in the term
16:42:07 <JagaJaga> acowley: ion: :/
16:42:20 <acowley> Euler_: What's your idea for that?
16:42:39 <Euler_> I am assuming that it would be enough to replace only the x
16:43:11 <Euler_> since everythng else is already either bound or free
16:43:13 <kadoban> JagaJaga: Well, probably not by hand exactly, I'm sure someone just wrote a script to output that and called it good.
16:43:23 <brad_hardy> Where's the best place to show off the project I've been working on? It's not complete but it has a working demo.
16:43:36 <acowley> The World's Fair
16:43:43 <acowley> Or reddit
16:44:26 <Euler_> my attempt at a solution so far would be s := := if (\x1 -> let x2 = \x3 -> (y x3) in x2) then (x4 y) else (let f x5 = (w x5) in \x6 -> w
16:45:10 <acowley> Euler_: So x4 is free?
16:45:39 <Euler_> the x4 should be free, sey
16:45:44 <Euler_> *yes
16:45:51 <steshaw> Does GHC have a compilation option something like "compressed oops" on the JVM? i.e. for using 32 bit pointers in 64 bit mode
16:46:23 <acowley> Euler_: How does that match up with the more careful wording of saying, "x is free in e"?
16:46:40 <Euler_> at least I think so considering the original term s := if (\x -> let x = \x -> (y x) in x) then (x y) else (let f x = (w x) in \x -> w)
16:46:42 <acowley> Euler_: If I say, "x is free in e", that means it may be bound in an outer context.
16:47:04 <acowley> Euler_: So, /somewhere/ is a "\x -> ... e ..."
16:47:09 <Euler_> but I'm not sure how previous xs carry over to the then-part
16:47:22 <acowley> Euler_: But if you rename 'x' in 'e', how can you deal with that lambda in the outer context?
16:47:33 <Euler_> ah
16:47:44 <Euler_> I see, so that x sould keep it's name
16:48:11 <Euler_> since it is the only time it appears as a non-bound variable
16:49:00 <acowley> Right
16:49:31 <Euler_> okay, anything else where I messed up?
16:50:04 <acowley> Euler_: If this is for a class, you probably want to think about it on your own a lot rather than have anyone spoil things for you.
16:50:29 <acowley> Euler_: This is possibly the single nastiest bit about making PLs work.
16:51:22 <Euler_> it's 1:49 in the morning and I already put a bit of thought into it, so I'd rather not think to much more about it since I still have some more practical stuff to do :(
16:51:31 <acowley> hah, fair enough
16:52:01 <Euler_> but of course I'm not asking for a complete solution, just hints at what still is wrong would be appreciated!
16:52:12 <acowley> Euler_: I didn't notice any other problems
16:52:30 <Euler_> okay, I'm glad to hear that
16:52:36 <acowley> Euler_: But it really is worth thinking about tomorrow, and the day after, and such. Everybody underestimates it.
16:53:14 <acowley> Euler_: In fact, getting burned by underestimating the difficulty of getting name capture right is an essential part of learning about programming language design.
16:53:26 <Euler_> thanks for taking your time, acowley, and I'll surely talk about it tomorrow with my fellow students!
16:53:58 <acowley> Euler_: No problem! It really is an awesome subject, and I'm happy to help as you continue on it, as I'm sure are other #haskellers.
16:54:19 <newsham> i wish i didnt have to add udnerscores to all my record fields to use lens TH stuff
16:54:37 <Euler_> good bye (or until the next time, which will probably come) :)
16:54:49 <acowley> newsham: Isn't that an option for the lens TH machinery?
16:55:08 <newsham> i dont know. i know there's a way to explicitely specify names, but i dont want to do that either
16:56:23 <newsham> oh wait, cool, i dont need udnerscores for the prisms
16:57:50 <acowley> newshame: You can use "makeLensesWith abbreviatedFields"
16:58:02 <acowley> newsham: It does seem to require that every field share a common prefix, though
16:58:25 <acowley> newsham: I think the classy stuff is how you'd have to use un-prefixed names.
16:59:27 <ReinH> there's makeFields now as well
17:00:25 <athan> If I have a newtype `Foo h m a = Foo {runFoo :: h -> m a}`, why can't I derive an Applicative instance?
17:00:25 * hackagebot os-release 0.2.1 - /etc/os-release helpers  http://hackage.haskell.org/package/os-release-0.2.1 (yac)
17:02:01 <ReinH> athan: er, why do you expect to be able to?
17:02:45 <athan> ReinH: Well, if `m` is applicative, couldn't it?
17:03:47 <acowley> Seems like it'd just be a limitation of however deriving works
17:04:09 <athan> hmm. Thanks acowley & ReinH :)
17:04:25 <ReinH> I don't think the deriving mechanism is going to apply an Applicative constraint to m automatically
17:04:36 <acowley> It wouldn't
17:05:02 <acowley> But deriving instance Applicative m => Applicative (Foo h m) might. I honestly don't know.
17:10:26 * hackagebot urlpath 1.0.0 - Painfully simple URL writing combinators  http://hackage.haskell.org/package/urlpath-1.0.0 (athanclark)
17:11:04 <mjrosenb> https://gist.github.com/80f4964918c7c01e1cdf :-(
17:14:42 <marchelzo_> If I cabal install something in a sandbox, how can I use ghc and tell it to use the modules that I installed in the sandbox?
17:14:57 <Xe> use cabal
17:15:02 <acowley> marchelzo_: ghc -package-db ...
17:15:28 <marchelzo_> acowley: Thanks
17:15:41 <marchelzo_> Xe: I will eventually
17:15:42 <geekosaur> cabal exec -- ghc ...
17:16:23 <Axman6> marchelzo_: starting by using cabal init is the easiest way to make sure that things work nicely
17:16:53 <marchelzo_> acowley: what do I use as the argument to -package-db?
17:17:10 <acowley> marchelzo_: .cabal-sandbox/x86-something-something
17:17:57 <acowley> On a mac, it might be something like, .cabal-sandbox/x86_64-osx-ghc-7.8.3-packages.conf.d
17:18:11 <marchelzo_> acowley: sweet. thanks
17:43:01 <ReinH> Xe: sometimes people prefer to do things the hard way
17:43:09 <ReinH> for reasons I don't fully understand
17:45:46 <[FreeLay]> ComicsNights has Quit (Max SendQ exceeded)
17:46:09 <[FreeLay]> ComicsNights (~ircbox@27022A3E.DCBCB785.726028B6.IP) has Joined #haskell
17:47:05 <johnw> who brought [FreeLay] onto the channel?
17:47:40 <[FreeLay]> ComicsNights has Quit (Max SendQ exceeded)
17:47:51 --- mode: ChanServ set +o johnw
17:47:51 --- mode: johnw set +b *!~mirror@104.255.96.100
17:47:51 --- kick: [FreeLay] was kicked by johnw (Kicked)
17:47:52 --- mode: johnw set -o johnw
17:48:41 <deezn> jle` you around? 
18:00:27 * hackagebot postgresql-typed 0.3.3 - A PostgreSQL access library with compile-time SQL type inference  http://hackage.haskell.org/package/postgresql-typed-0.3.3 (DylanSimon)
18:02:10 <nameless912> okay, noob question time. I've tried to learn haskell like 3 times. what am I doing wrong?
18:02:25 <Hijiri> which guides did you use?
18:02:26 <johnw> that's actually not uncommon, nameless912 
18:02:36 <johnw> i'd say the fact that you keep trying means you're doing it right
18:02:37 <nameless912> I tried learn you a haskell and real world
18:03:04 <johnw> nameless912: what is giving you trouble right now?
18:03:18 <nameless912> I think I'm not having that much trouble with the *concepts*, I just finished up a course on algorithms and that helped a lot, but the syntax just feels really....fake? to me
18:03:21 <mjrosenb> can I ask cabal to install all of the deps for the .cabal file in pwd?
18:03:24 <nameless912> it always feels like I'm writing pseudocode
18:03:32 <nameless912> and so I can't remember any of it
18:03:35 <johnw> there's not a large amount of syntax in Haskell
18:03:40 <johnw> most of the operators are just defined in libraries
18:03:44 <SrPx> is there something equivalent to Debug.Trace, except for the current time?
18:03:55 <johnw> SrPx: you could write one, with unsafePerformIO
18:04:04 <SrPx> Okay
18:04:15 <mjrosenb> nameless912: many people see the relatively simple syntax as a good thing.  It certainly makes writin haskell nicer than writing C++.
18:04:35 <nameless912> I totally believe that mjrosenb, I just can't get used to it you know?
18:04:46 <geekosaur> algolitis :p
18:04:50 <nameless912> I mean, my last language learning adventure was Rust, talk about a language with too much syntax lol
18:05:18 <acowley> mjrosenb: cabal install --dependencies-only
18:05:56 <mjrosenb> acowley: ahh, that seems to be working.  thanks.
18:06:07 <acowley> mjrosenb: And if you have bash-completion, it's cabal install --de<TAB>
18:06:31 <nameless912> I think the thing that fucks with me the most is the fact that function calls don't look like c-style calls, which is all i've ever seen
18:06:36 <acowley> I do --de<TAB> --dr<TAB> so much I sometimes type them by accident.
18:06:50 <mjrosenb> nameless912: there is no reason they can't.
18:06:59 <nameless912> really? how is that?
18:07:16 <mjrosenb> > let add (x,y) = x + y in add(x,y)
18:07:17 <lambdabot>  x + y
18:07:24 <mjrosenb> > let add (x,y) = x + y in add(2,3)
18:07:25 <arkeet> that's not idiomatic haskell though.
18:07:25 <lambdabot>  5
18:07:30 <mjrosenb> right.
18:07:37 <acowley> nameless912: One of the best things is being forced to question why things are the way you're used to. Haskell asks why function application needs any syntax.
18:07:50 <mjrosenb> although for single argument functions, you can just put parens around your argument
18:07:57 <nameless912> oh, gotcha. See that's the thing, I get the idea and the motivation, but the followthrough is hard, lol
18:08:09 <mjrosenb> but, it you have calls nested 10 deep, that'll get painful.
18:08:23 <arkeet> partial application is useful.
18:08:47 <arkeet> > map ((+) 1) [10,20,30]
18:08:48 <lambdabot>  [11,21,31]
18:08:50 <arkeet> I dunno.
18:08:57 <Hijiri> when I was doing a thing in lua I made all my functions curried by default
18:09:04 <Hijiri> probably a great way to introduce bugs in dynamic land
18:09:22 <exio4> arkeet: partial application becomes useful when you have generic functions and IO/monad stacks
18:09:45 <nameless912> so, what is a curried function? lol I get what a monad is I think but curried function is a term I don't know
18:09:47 <exio4> (well, "even more" useful)
18:10:08 <Hijiri> nameless912: do you understand tuples, like (4,5)
18:10:13 <Hijiri> or (12,
18:10:15 <nameless912> yup
18:10:15 <mjrosenb> nameless912: a curried function is one where you take your arguments one at a time.
18:10:17 <Hijiri> (12,'a')
18:10:32 <arkeet> in haskell, all functions really take a single argument.
18:10:41 <mjrosenb> e.g. add (x,y) = x+y vs. add x y = x + y
18:10:42 <exio4> nameless912: it's basically representing a function that, instead of taking all the arguments at once as in a tuple, (a,b) -> c, takes one and returns a new function that takes the "rest" 
18:10:44 <Hijiri> you could say functions in other languages take a tuple argument
18:11:17 <arkeet> so if you have a "binary function", then giving it an argument returns a function of one more argument.
18:11:23 <arkeet> f x y is really parsed as (f x) y
18:11:28 <mjrosenb> nameless912: in the latter case, you can say (f = add 1) to partially apply your function, and have a function that adds one to its input
18:11:29 <exio4> ((a,b) -> c) vs (a -> (b -> c))
18:11:29 <Hijiri> like doStuff(1,2,"apple") is really taking a tuple (1,2,"apple")
18:11:29 <nameless912> oh, so it's like consuming a tuple one element at time using recursion?
18:11:42 <exio4> there's no recursion
18:11:46 <Hijiri> it's not recursion
18:12:21 <exio4> function(x,y) { return x+y; } vs function(x) { return function(y) { return x+y; }; }  
18:12:35 <exio4> with JS-ish syntax, making it way more explicit :P
18:12:49 <Hijiri> I think that is valid lua
18:13:04 <nameless912> okay. So, in what case is that preferred over the "normal" way?
18:13:11 <exio4> I don't think lua blocks can be delimited with {} 
18:13:15 <Hijiri> oh
18:13:17 <Hijiri> right
18:13:20 <Hijiri> I don't know how I got that wrong
18:13:29 <arkeet> looks more like javascript :p
18:13:39 <Hijiri> nameless912: curried style is almost always preferred
18:13:54 <Hijiri> it's more composable
18:13:59 <exio4> nameless912: using curried functions is typical/idiomatic in Haskell, as its syntax is also extremely light 
18:14:00 <nameless912> is the idea that you can then use only the inner function if you need it or rearrange them?
18:14:12 <johnw> and whichever style you use, you have the 'curry' and 'uncurry' functions to convert between representations
18:14:39 <Hijiri> nameless912: The idea is you can apply one argument, then you have a whole new function you can pass to other functions
18:15:26 <Hijiri> for example (you might have seen this already), "map" applies a function over a list
18:15:41 <Hijiri> let's say I wanted to add 5 to every element of a list
18:15:43 <Hijiri> I could define
18:15:49 <Hijiri> @let add5 x = x + 5
18:15:50 <lambdabot>  Defined.
18:16:00 <Hijiri> > map add5 [1,2,3]
18:16:01 <lambdabot>  [6,7,8]
18:16:06 <Hijiri> Or I could define
18:16:13 <Hijiri> @let add x y = x + y
18:16:15 <lambdabot>  Defined.
18:16:21 <Hijiri> > map (add 5) [1,2,3]
18:16:21 <arkeet> > map (map add5) [[1,2,3],[10,20]]
18:16:22 <lambdabot>  <no location info>: can't find file: L.hs
18:16:23 <lambdabot>  [6,7,8]
18:16:24 <arkeet> oops
18:16:27 <arkeet> > map (map add5) [[1,2,3],[10,20]]
18:16:28 <lambdabot>  [[6,7,8],[15,25]]
18:16:44 <nameless912> oh, I see
18:16:56 <nameless912> so you can make, for example, a function that applies the transformation "add 5"
18:17:08 <arkeet> yes that's called "add 5"
18:17:23 <johnw> :)
18:17:30 <johnw> functions as first-class values take time to get used to
18:17:48 <SrPx> Is there any way to display the framerate when using Gloss.Raster.Field?
18:18:10 <nameless912> johnw: I thought python had prepared me. lolnope
18:22:32 <ReinH> nameless912: if you look at the type of map
18:22:34 <ReinH> :t map
18:22:35 <lambdabot> (a -> b) -> [a] -> [b]
18:22:52 <ReinH> you can equivalently read it as map :: (a -> b) -> ([a] -> [b])
18:23:15 <ReinH> which takes a function on `a's and turns it onto a function on lists of `a'
18:23:37 <ReinH> rather than taking a function and a list
18:25:05 <mjrosenb> argh, does anyone know where the examples for reactive-banana went?
18:25:28 * hackagebot extensible-effects 1.9.2.2 - An Alternative to Monad Transformers  http://hackage.haskell.org/package/extensible-effects-1.9.2.2 (shergill)
18:31:35 <ronh-> > map (map (*10)) [[1,2,3],[4,5,6]]
18:31:36 <lambdabot>  [[10,20,30],[40,50,60]]
18:31:40 <ronh-> nameless912 do you understand why that works?
18:35:17 <nameless912> I think so. You're creating a function that maps *10 onto an array, and then mapping that function onto an array of arrays
18:35:42 <arkeet> mhm
18:35:49 <arkeet> (they're lists, not arrays)
18:35:56 <nameless912> you know what I mean :P
18:36:02 <arkeet> I know, just saying :p
18:36:03 <nameless912> I'm new at this lol
18:36:18 <arkeet> haskell lists are linked lists, so you don't get constant time random access and such
18:36:35 <pacak> > (*) <$> [1..4] <*> [10,20..40]
18:36:37 <lambdabot>  [10,20,30,40,20,40,60,80,30,60,90,120,40,80,120,160]
18:37:25 <nameless912> gotcha!
18:46:59 <fumieval> floor 
18:47:24 <fumieval> * floor (0/0) --> -26965397022934738615939577861835371004269654684134598591014512173659901370... oh?
18:49:12 <thomaseding> > floor (0/0)
18:49:13 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
18:49:36 <arkeet> > toRational (0/0)
18:49:37 <lambdabot>  (-26965397022934738615939577861835371004269654684134598591014512173659901370...
18:50:42 <bob_twinkles> > floor (0/0) :: Int
18:50:44 <lambdabot>  0
18:51:32 <fumieval> > toRational (0/0 :: Float)
18:51:33 <lambdabot>  (-510423550381407695195061911147652317184) % 1
18:51:45 <arkeet> > logBase 2 510423550381407695195061911147652317184
18:51:46 <lambdabot>  128.58496250072116
18:52:15 <thomaseding> 0/0 :: Float
18:52:18 <thomaseding> > 0/0 :: Float
18:52:20 <lambdabot>  NaN
18:52:57 <thomaseding> > floor "Brillant"
18:52:58 <lambdabot>      Could not deduce (RealFrac [Char]) arising from a use of ‘floor’
18:52:58 <lambdabot>      from the context (Integral b)
18:52:58 <lambdabot>        bound by the inferred type of it :: Integral b => b at Top level
19:02:54 <deezn> Who is the go to person on here with GADTs and explaining things?
19:03:42 <thomaseding> @deezn, have you checked out online tutorials on gadts?
19:03:42 <lambdabot> Unknown command, try @list
19:06:33 <deezn> yes .. thomaseding .. but it is a confusing subject. 
19:07:55 <pacak> GADTs are nice, warm and fuzzy things.
19:09:11 <pacak> instead of writing down fields for constructors you write down type signatures for them
19:09:13 <pacak> :t Just
19:09:13 <lambdabot> a -> Maybe a
19:09:48 <pacak> GADT version of just would be "Just :: a -> Maybe a ; Nothing -> Maybe a"
19:10:06 <pacak> And instead of hardcoding resulting type you can specify whichever you want.
19:12:51 <exio4> that's the boring part of GADTs
19:13:13 <exio4> are you familiar with phantom types deezn? 
19:14:30 <pacak> exio4: That's all GADTs specifics you need. phantom types are nice but they are not limited to GADTs.
19:15:09 <exio4> pacak: the "fancyness" comes from things you can do that you couldn't with normal ADTs
19:15:30 * hackagebot biophd 0.0.7 - Library for reading phd sequence files  http://hackage.haskell.org/package/biophd-0.0.7 (DanFornika)
19:15:34 <pacak> Sure. Different types for different constructors
19:15:50 <pacak> Different resulting types
19:15:51 <arkeet> Library for getting you a Ph.D. in biology.
19:16:12 <exio4> sounds like an useful library
19:17:34 <pacak> I'd like the same library but for abstract nonsense.
19:18:06 <deezn> exio4 .. no GADTs
19:18:30 <exio4> deezn: er, what? 
19:18:58 <deezn> exio4… Generalised Algebraic Types.
19:19:09 <exio4> yeah, but are you familiar with phantom types?
19:19:44 <pacak> :t Proxy
19:19:45 <lambdabot> forall (k :: BOX) (t :: k). Proxy t
19:19:50 <pacak> o_o
19:19:57 <deezn> Yeah.. but no. As in I have read about it (multiple times) but still am confused
19:21:02 <thomaseding> deezn: try writing code with them. Just play around. see what compiles and what doesnt
19:21:28 <deezn> yeah doing it now.
19:21:31 <deezn> all good thanks.
19:22:51 <exio4> deezn: phantom types are basically type parameters only used as a tag or something like that, by the programmer/program
19:22:52 <mjrosenb> gah, reactive-baana-wx doesn't build :-/
19:22:59 <mjrosenb> is time bundled with ghc?
19:23:11 <exio4> data Tagged a = Tag Int
19:25:30 * hackagebot markup 0.0.8 - Abstraction for markup languages  http://hackage.haskell.org/package/markup-0.0.8 (athanclark)
19:37:46 <mjrosenb> AAAARRRRRRRGGGGGHHHHHHHHH, dependencies :-(
19:57:30 <mjrosenb> oh wow, reactive-banana changed everything in the latest point release.
19:58:57 <mjrosenb> ... or not?
19:59:12 <mjrosenb> there seem to be two different types called Moment?
19:59:27 <SrPx> I'm trying to reinstall a few libraries with profiling on. `cabal install linear` results on an error telling me several packages I use will break if I proceed. What do I do? http://lpaste.net/132508
19:59:33 <SrPx> in*
19:59:54 <mjrosenb> SrPx: you ask it to reinstall all of the packages that depend on linear.
20:00:06 <SrPx> just use force reinstalls?
20:00:31 * hackagebot stackage-install 0.1.1.0 - Secure download of packages for cabal-install  http://hackage.haskell.org/package/stackage-install-0.1.1.0 (MichaelSnoyman)
20:00:33 * hackagebot http-reverse-proxy 0.4.1.3 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.4.1.3 (MichaelSnoyman)
20:00:44 <infandum> Where is "isInfixOf" for Data.ByteString.Lazy.Char8?
20:00:53 <SrPx> can I make a backup of my haskell packages?
20:01:07 <SrPx> things are working nicely now, I don't want to break everything...
20:01:18 <c_wraith> SrPx: ~/.cabal/world contains a list of everything you've installed manually
20:01:31 <c_wraith> SrPx: the command "cabal install world" will attempt to reinstall those things
20:02:20 <SrPx> c_wraith: this gives me `Backjump limit reached (change with --max-backjumps).`
20:04:47 <deezn> guys different between concat and append?
20:05:05 <deezn> Implement concatV, a variant of the list processing function concat, but for vectors. Take into account that in a vector of vectors, the inner vectors all need to be of the same size — i.e., the structure constitutes a matrix.
20:05:11 <mjrosenb> :t append
20:05:12 <lambdabot>     Not in scope: ‘append’
20:05:12 <lambdabot>     Perhaps you meant one of these:
20:05:12 <lambdabot>       ‘BSC.append’ (imported from Data.ByteString.Char8),
20:05:51 <mjrosenb> deezn: haskell doesn't have append, but usually, append just takes two lists/vectors, and joins them
20:06:02 <mjrosenb> deezn: concat takes a list of lists and joins them
20:09:48 <deezn> list of lists.. ok.. bingo
20:10:28 <dfeuer> mjrosenb, Haskell has mappend, which does that.
20:10:44 <exio4> mconcat [a,b] = a <> b 
20:11:34 <SrPx> Is this basically a situation without solution?
20:15:57 <jgcoded> difference between Control.Monad.ST and Control.Monad.State?
20:16:39 <c_wraith> jgcoded: they're different in nearly every way you might choose
20:16:50 <c_wraith> choose to compare them in, that is.
20:17:12 <c_wraith> State is sugar around manual state-passing
20:17:53 <c_wraith> ST is creating an isolated heap in which you can create mutable references
20:18:13 <c_wraith> (the isolation allows ST calculations to be pure from the outside)
20:18:27 <SrPx> If I make a backup of my .cabal, is that enough to restore the installed libraries I have in case I use --force-reinstalls?
20:18:41 <c_wraith> no, you'd need .ghc
20:18:48 <c_wraith> it has the package database
20:19:20 <jgcoded> thanks, c_wraith
20:19:26 <SrPx> thanks. after doing --force-reinstalls and breaking those packages, can I just install them agian?
20:19:52 <c_wraith> if you back up .ghc and .cabal, you can just restore them if things get broken after the backup
20:24:45 <SrPx> thanks
20:25:32 * hackagebot fasta 0.6.2.0 - A simple, mindless parser for fasta files.  http://hackage.haskell.org/package/fasta-0.6.2.0 (GregorySchwartz)
20:27:39 <wgreenberg> If I were trying to play audio (on a linux system) from a haskell program, would the alsa packages be a good place to start?
20:27:54 <dbelange> use the Audio monad
20:29:01 <wgreenberg> of course :P thanks dbelange
20:33:47 <SrPx> cabal install linear --force-reinstall gives this error: http://lpaste.net/132510 but I already reinstalled mtl with profiling. What is wrong?
20:34:19 <arkeet> do you happen to have multiple versions of mtl installed?
20:34:30 <SrPx> I do not know.
20:34:35 <arkeet> ghc-pkg list knows.
20:35:46 <SrPx> Okay, thanks.
20:35:49 <exio4> SrPx: you shouldn't try to --force-reinstall, I normally try to follow the package "chain" and install the needed packages
20:36:04 <SrPx> What do you mean?
20:36:23 <exio4> cabal install linear gives me that it needs to reinstall mtl? 
20:36:25 <arkeet> you can constrain it to use already installed packages
20:36:27 <exio4> cabal install linear mtl
20:36:30 <arkeet> e.g. --constraint="mtl installed"
20:36:35 <exio4> that too :) 
20:37:24 <nak> quiz time! i have `x = ["bear", "mouse", "cat", "tiger", "lion"]` and `y =["A", "E"]` how can i filter all words from `x` that match any letter in `y` ?
20:37:36 <SrPx> What exactly do I have to do?
20:37:48 <arkeet> first you have to fix your packages.
20:37:57 <SrPx> ... how?
20:37:58 <exio4> nak, ["A", "E"] or ['A', 'E'] ? 
20:38:16 <nak> ["A", "E"]
20:38:28 <nak> well, i suppose we could have ['A', 'E'] too, that's fine
20:38:34 <nak> i'll work with either
20:39:08 <arkeet> > map (any (`elem` "ae")) ["bear", "mouse", "cat", "tiger", "lion"]
20:39:09 <lambdabot>  [True,True,True,True,False]
20:39:13 <exio4> filter (any (`elem` y)) x
20:39:17 <SrPx> Now it is asking me to install text with profiling and that will break hundreds of packages...
20:39:31 <arkeet> should have installed everything with profiling to begin with.
20:39:44 <SrPx> cabal should come with profiling on to begin with? 
20:39:52 <arkeet> no, it doesn't, unfortunately.
20:40:00 <SrPx> exactly
20:40:12 <arkeet> this is probably a good opportunity to nuke your package installations and reinstall everything.
20:40:33 * hackagebot fasta 0.7.0.0 - A simple, mindless parser for fasta files.  http://hackage.haskell.org/package/fasta-0.7.0.0 (GregorySchwartz)
20:40:33 <nak> > elem "bear" "a"
20:40:35 <lambdabot>      Couldn't match type ‘Char’ with ‘[Char]’
20:40:35 <lambdabot>      Expected type: [[Char]]
20:40:35 <lambdabot>        Actual type: [Char]
20:40:39 <nak> > elem "bear" 'a'
20:40:41 <lambdabot>      Couldn't match expected type ‘t0 [Char]’ with actual type ‘Char’
20:40:41 <lambdabot>      In the second argument of ‘elem’, namely ‘'a'’
20:40:41 <lambdabot>      In the expression: elem "bear" 'a'
20:40:41 <SrPx> arkeet: just remove .ghc?
20:40:50 <SrPx> do I touch .cabal?
20:40:56 <exio4> > elem 'a' "bear"
20:40:57 <lambdabot>  True
20:41:02 <exio4> > elem 1 [1,2,3]
20:41:03 <lambdabot>  True
20:41:05 <exio4> > elem 5 [1,2,3]
20:41:06 <lambdabot>  False
20:41:23 <arkeet> SrPx: .ghc is what contains the package db 
20:41:23 <nak> > elem "ae" "bear" 
20:41:25 <lambdabot>      Couldn't match type ‘Char’ with ‘[Char]’
20:41:25 <lambdabot>      Expected type: [[Char]]
20:41:25 <lambdabot>        Actual type: [Char]
20:41:44 <nak> ok my question is how does it work with ['a', 'e'] compared to ['b', 'e', 'a', 'r'] 
20:41:47 <arkeet> SrPx: it refers to a bunch of stuff in .cabal that will probably be useless so you might consider removing stuff like .cabal/lib
20:41:50 <arkeet> (but not the entire .cabal directory)
20:41:57 <arkeet> er
20:42:03 <arkeet> not /lib, but the thing inside that has lib.
20:42:07 <Clint> nak: what are you trying to do
20:42:08 <mauke> nak: ?
20:42:10 <arkeet> idk
20:42:21 <arkeet> nak: please pm lambdabot for stuff like that.
20:42:23 <arkeet> or just use ghci
20:42:30 <arkeet> er
20:42:30 <SrPx> okay, removed everything inside .cabal/lib
20:42:31 <arkeet> sorry
20:42:34 <SrPx> and .ghc
20:42:35 <SrPx> that's all?
20:42:38 <arkeet> SrPx: sure.
20:42:40 <nak> sorry arkeet 
20:42:42 <SrPx> thanks.
20:43:05 <nak> i'd like to discuss how this works
20:43:06 <nak> map (any (`elem` "ae")) ["bear", "mouse", "cat", "tiger", "lion"]
20:43:12 <arkeet> SrPx: there's some useful stuff in .cabal that you probably want to preserve, like config/world/bin/etc
20:43:27 <exio4> @type \x y -> filter (`elem` y) x
20:43:28 <lambdabot> (Eq a, Foldable t) => [a] -> t a -> [a]
20:43:28 <arkeet> > any (`elem` "ae") "bear"
20:43:29 <lambdabot>  True
20:43:48 <nak> oh!
20:43:50 <arkeet> any f [x,y] = f x || f y
20:44:04 <nak> so we actually loop through each letter in each word and see if it is an element of "ae"
20:44:06 <deezn> arkeet can you take a look at this.. http://lpaste.net/6941493416144404480
20:44:16 <arkeet> any (`elem` "ae") "bear" = 'b' `elem` "ae" || 'e' `elem` "ae" || ...
20:44:22 <arkeet> that's right.
20:44:25 <nak> ah !
20:44:28 <nak> ok sweet!
20:44:37 <arkeet> deezn: what am I looking at, and why is it me.
20:44:56 <nak> thank you arkeet  and exio4 
20:44:57 <deezn> because I see you around here so i am assuming you are the go to man
20:45:03 <arkeet> I am not the go to man.
20:45:07 <deezn> haha
20:45:07 <arkeet> nor is anyone else in this channel.
20:45:10 <arkeet> just ask everyone
20:45:32 <arkeet> it helps if you ask a question, though
20:45:45 <deezn> yeah but then i get slammed from 3 different people trying to explain the concept in piecewise fashion.. which is not the best environment for learning.. but ok.. 
20:45:54 <deezn> Guys: http://lpaste.net/6941493416144404480
20:46:16 <arkeet> okay, I have a question.
20:46:20 <arkeet> what do you want to know?
20:46:42 <deezn> I am using GADTs.. and I am trying to figure out this concatV.. if i have bad syntax or logic or both.. GADTS are still confusing for me.. 
20:46:56 <arkeet> what is the problem? does it not compile?
20:47:12 <nak> ok so this almost works perfectly: but i want the end result to be ["lion"]
20:47:13 <nak> > filter (any (`elem` "ae")) ["bear", "mouse", "cat", "tiger", "lion"]
20:47:14 <lambdabot>  ["bear","mouse","cat","tiger"]
20:47:18 <deezn> no.. 
20:47:19 <nak> instead i get the opposite
20:47:26 <nak> and "lion" is filtered out
20:47:30 <arkeet> nak: so you want to *remove* the ones that match.
20:47:34 <nak> right!
20:47:35 <nak> ^.^
20:47:39 <arkeet> just change the function you pass to filter.
20:47:42 <mauke> :t not
20:47:43 <lambdabot> Bool -> Bool
20:47:52 <exio4> all (`notElem` y) ? 
20:47:58 <arkeet> both work.
20:48:00 <exio4> not . any (`elem` y) ?
20:48:02 <deezn> I am trying to get two vectors (of vectors) and then concat them by getting the first from each passed list appending them and then recursively doign the same thing
20:48:06 <mauke> :t none
20:48:07 <lambdabot> Foldable f => (a -> Bool) -> f a -> Bool
20:48:12 <nak> ah ok sweet
20:48:23 <nak> thanks guys ^.^
20:48:30 <mauke> > filter (none (`elem` "ae")) ["bear", "mouse", "cat", "tiger", "lion"]
20:48:31 <lambdabot>  ["lion"]
20:48:40 <arkeet> I don't think none is in prelude, is it?
20:48:42 <Axman6> @src notElem
20:48:42 <lambdabot> notElem x = all (/= x)
20:48:47 <arkeet> @hoogle none
20:48:48 <lambdabot> Text.Parsec.Char noneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
20:48:48 <lambdabot> Text.ParserCombinators.Parsec.Char noneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
20:48:48 <lambdabot> Graphics.UI.GLUT.Window None :: Cursor
20:48:51 <Axman6> @src elem
20:48:52 <lambdabot> elem x = any (== x)
20:48:56 <exio4> I didn't know about none!
20:49:08 <arkeet> me either. it's from lens.
20:49:20 <arkeet> (and not base)
20:50:15 <exio4> de Morgan's laws to the rescue, then :p
20:50:22 <arkeet> mhm.
20:50:58 <exio4> (not . any f <=> all (not . f)) 
20:53:30 <exio4> deezn: what are you trying to with those where clauses?
20:54:15 <exio4> deezn: if it's concat, I'd assume you also want a type similar to something like concatV :: Vec n (Vec m a) -> Vec (n * m) a
20:55:42 <exio4> @type concat
20:55:43 <lambdabot> Foldable t => t [a] -> [a]
20:55:43 <SrPx> Why profiling wasn't informative here? http://lpaste.net/132511
20:56:36 <exio4> SrPx: how did you compile the binary?
20:56:53 <deezn> not sure what I missed.. connection dropped out
20:56:55 <exio4> -prof alone, or -prof -caf-all? 
20:56:58 <exio4> did you use optimiations
20:57:13 <exio4> deezn: what are you trying to do with those where clauses?
20:58:01 <exio4> deezn: also, the type looks wrong
20:58:14 <SrPx> exio4: with `ghc -i.. -prof -caf-all -threaded -O2 render.hs -o render` it is still not very informative http://lpaste.net/132512
20:58:31 <exio4> deezn: I'd assume concat would have the type Vec n (Vec m a) -> Vec (n * m) a
20:58:33 <nitrix> That might seem like a silly question, but what's the difference between a Foldable and a Functor?
20:58:37 <exio4> SrPx: take out the -O2
20:58:40 <nitrix> Aren't both things that can be mapped over?
20:59:02 <nitrix> Well, functor is mapped over and Foldable is folded, but isn't the semantic similar?
21:00:00 <deezn> but exio4 shouldnt it take two lists?
21:00:29 <exio4> deezn: what are you going to do with those? maybe it's not concat what you are trying to implement
21:00:47 <deezn> Implement concatV, a variant of the list processing function concat, but for vectors. Take into account that in a vector of vectors, the inner vectors all need to be of the same size — i.e., the structure constitutes a matrix.
21:00:55 <deezn> Ahh wait you are right.. 
21:01:00 <deezn> ok brb.. 
21:01:23 <exio4> it may be helpful to implement it first with normal lists
21:01:26 <nitrix> Oh, it actually was a silly question. It's fold in the sense of reduce.
21:01:32 <nitrix> So, map & reduce.
21:01:36 <SrPx> Still completely uninformative, this time with `ghc -i.. -prof -caf-all -fforce-recomp -threaded render.hs -o render` http://lpaste.net/132513
21:01:44 <pacak> > "Foldable" \\ "Functor"
21:01:45 <lambdabot>  "ldable"
21:01:56 <pacak> Hmmm...
21:02:42 <pacak> "ldable" is the diffence then.
21:03:17 <nitrix> pacak: That's very snarky, but I actually liked it. I didn't know about (\\).
21:03:19 <nitrix> pacak: :3
21:04:06 <exio4> SrPx: add -auto-all too, I don't know either 
21:04:08 <ronh-> nitrix yeah. take a a list for example. with functor instance you can't change the underlining data structure, it will always be a list, and it will always have the same number of arguments as it did before you called fmap. with foldable instance, the result can have different number of arguments, or may not even be a list
21:04:31 <ronh-> s/number of arguments/number of elements
21:04:49 <deezn> exio4: http://lpaste.net/6941493416144404480
21:05:06 <pacak> @src (\\)
21:05:06 <lambdabot> (\\) = foldl (flip delete)
21:05:30 <nitrix> ronh-: I see, because it's being folded with an accumulator, right?
21:05:34 <deezn> Ok.. so I am just trying to pull off each list as the head and then append then recursively.. 
21:06:17 <nitrix> ronh-: Isn't the result restricted to the type of the combining function though?
21:06:33 <SrPx> exio4: auto-all improved the output considerably, thanks.
21:07:08 <deezn> exio4 : Could not deduce ((n1 + (n1 * m)) ~ (m + (n1 * m)))
21:07:09 <deezn>     from the context (n ~ 'S n1)
21:07:10 <ronh-> nitrix it is, but it is not restricted by the typeclass instance or the laws
21:07:22 <nitrix> ronh-: Interesting.
21:07:38 <deezn> is that .. that it cant guarentee the length of each vector is the same?
21:10:31 <exio4> deezn: I don't know, you have to somehow prove that the lengths match
21:13:00 <deezn> the lengths are encoded into the vectors with types.. witht the Nat.. but I dont get how to dealw ith it?
21:13:04 <exio4> deezn: I just realized, that implementation of (*) looks wrong
21:13:44 <deezn> that is coming up as an error.. in the concat.. 
21:14:10 <exio4> λ> :t Proxy :: Proxy ((S (S Z)) * (S Z))
21:14:11 <exio4> Proxy :: Proxy ((S (S Z)) * (S Z)) :: Proxy ('S 'Z)
21:14:16 <exio4> 2 * 1 is not 1
21:15:00 <exio4> with a correct implementation of the (*) type family, it does work 
21:15:23 <deezn> but 2*5 = 2 + 2 + 2 + 2+ 2
21:15:36 <exio4> it's also 5 + 5
21:16:06 <exio4> type instance Z     * m = Z
21:16:08 <exio4> type instance (S n) * m = n + (n * m)
21:16:14 <exio4> 0 * m = m
21:16:30 <exio4> x * m = (x-1) + (x-1) * m ? 
21:16:42 <jgcoded> hello, what is the .~ operator?
21:16:57 <arkeet> it's from lens
21:17:26 <jgcoded> thanks
21:17:36 <deezn> But Z is 0
21:17:53 <arkeet> exio4: no, x*m is not (x-1)*(m+1)
21:17:57 <exio4> yes, the problem is in the second definition
21:18:17 <ReinH> deezn: you might find some useful stuff in http://stackoverflow.com/questions/12961651/why-not-be-dependently-typed/13241158#13241158
21:18:22 <deezn> But I am looking at what she wrtoe on the board and that is it
21:19:16 <deezn> As (S (S Z)) is 2
21:24:54 <deezn> exio4.. I don’t get:       at Ex07.hs:48:10-19
21:24:54 <deezn>     Expected type: Vec (n * m) a
21:24:55 <deezn>       Actual type: Vec (m + (n1 * m)) a
21:25:19 <exio4> deezn: ? 
21:25:58 <deezn> that is the compile error.. 
21:26:09 <exio4> deezn: did you fix the type family?
21:26:18 <deezn> I dont know what is wrong with it
21:26:35 <deezn> type instance (S n) * m = S (n + (n * m))
21:27:18 <deezn> still getting the same error..
21:28:12 <exio4> deezn: is this equation correct a * b = 1 + ((a-1) + ((a-1) * b)) ?  
21:29:48 <Axman6> type instance (S n) * m = m + (n * m) surely?
21:30:05 <exio4> Axman6: that's the correct one, yeah, :p
21:30:40 <deezn> what? ok brb.. 
21:31:38 <deezn> why didnt it work the other way around?
21:32:08 <exio4> (1+n) * m = m + (n * m) 
21:32:12 <exio4> (1+n) * m = n + (n * m) 
21:32:15 <exio4> see the difference? 
21:32:59 <deezn> nope.. I am confused.
21:33:45 <deezn> ahh yes.. 
21:33:53 <deezn> 1+n is the number of times.. 
21:34:02 <deezn> so it needs to be decremented each time.
21:34:17 <deezn> is that right.. 
21:34:45 <deezn> it is weird think about a number recursively defined as (S n)
21:38:17 <deezn> exio4.. and Axman6.. thanks.. it makes sense now but I was totally lookign in the wrong place.. 
21:38:56 <deezn> I still find this whole GADTs and type functions to be extremely challenging. 
21:45:42 <ReinH> deezn: what is the difference between 4*7 and 5*7, 4 or 7?
21:54:07 <nak> i am trying to do something like this in ghci, but it's failing
21:54:08 <nak> foldr1 (\x y -> (print x y) [1,2,3,4]
21:54:29 <nak> i just want to (print x y) to see how foldr operates on my array
21:54:44 <arkeet> :t foldr1
21:54:45 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
21:55:16 <pavonia> :t foldM
21:55:17 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
21:55:20 <nak> ok how can i write a lambda that does (\x y -> (print x y) ***return y here***)
21:55:38 <nak> pavonia i am not pro enough for monads yet
21:55:48 <nak> pavonia this is like day 10 for my haskell adventures
21:55:55 <pavonia> You will need it for print
21:56:14 <heatsink> Use the >> operator to do one action, then another action.  The second action's result is returned.
21:56:20 <heatsink> (\x y -> print x y >> return y)
21:56:40 <FireFly> You can't just print x and y as a side-effect in the function
21:56:48 <heatsink> Oh
21:56:54 <heatsink> print (x, y)
21:57:13 <arkeet> nothing in foldr1 lets you do IO inside 
21:58:03 <FireFly> lambdabot has some suitable magic, though
21:58:09 <arkeet> not really
21:58:15 <FireFly> > foldl1 (+) [a,b,c,d] :: Expr
21:58:16 <lambdabot>  a + b + c + d
21:58:20 <arkeet> well there's that
21:58:25 <FireFly> > foldr1 (+) [a,b,c,d] :: Expr
21:58:26 <ReinH> @hoogle foldM
21:58:27 <lambdabot>  a + (b + (c + d))
21:58:27 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
21:58:27 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
21:58:27 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
21:58:41 <heatsink> nak: The best way to see how foldr1 works is to manually inline it.
21:58:49 <arkeet> @src foldr1
21:58:49 <lambdabot> foldr1 _ [x]    = x
21:58:49 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
21:58:49 <lambdabot> foldr1 _ []     = undefined
21:59:30 <heatsink> foldr1 f (a:b:[c]) = f a (foldr1 f (b:[c])) = f a (f b (foldr1 f [c])) = f a (f b c)
22:01:09 <heatsink> nak: foldr1 is defined by those 3 equations.  Have you studied pattern matching?
22:01:19 <nak> ok well that's cool
22:01:27 <nak> i have heatsink 
22:01:31 <nak> my question is like...
22:01:43 <nak> is foldr inherently bad like this ?
22:02:08 <nak> i mean it's recursive
22:02:27 <nak> and it can't fully resolve the return value until the deepest element in the array has been pushed on the stack
22:02:54 <nak> @src foldl
22:02:54 <lambdabot> foldl f z []     = z
22:02:54 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
22:03:01 <heatsink> @src foldl'
22:03:01 <lambdabot> foldl' f a []     = a
22:03:01 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
22:03:40 <heatsink> foldl' is recursive in the efficient way for (+) and other strict operators
22:04:44 <heatsink> Note that it computes a' = f a x at every step, where x is the next list element.
22:05:36 * hackagebot opentheory-primitive 1.4 - Haskell primitives used by OpenTheory packages  http://hackage.haskell.org/package/opentheory-primitive-1.4 (JoeHurd)
22:05:47 <heatsink> foldr1 (+) will lead to stack overflow on large lists.
22:05:59 <nak> and what about foldl for large lists?
22:06:20 <mjrosenb> ok, so I can share a value between two functions such as let l = [1] in (\x -> x:l, \y -> y:l)
22:06:21 <nak> it looks like foldl uses a linear iterative process
22:07:01 <mjrosenb> I'm guessing it is impossible to have the two functions both return [x,y], without putting the whole thing in the IO monad.
22:07:14 <nak> @src foldl1
22:07:14 <lambdabot> foldl1 f (x:xs) = foldl f x xs
22:07:14 <lambdabot> foldl1 _ []     = undefined
22:07:26 <nak> ok that's what i expected for that
22:07:44 <nak> @src foldl1'
22:07:44 <lambdabot> Source not found. Whoa.
22:07:52 <nak> srsly
22:08:02 <ronh-> nak foldr's properties are sometimes prefered. foldr* can work with infinite lists if the supplied function is lazy in its second argument, while foldl can't.
22:08:17 <ronh-> > foldr (\x acc -> (1 + x):acc) [] [1..]
22:08:18 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
22:08:55 <nak> > foldl (\x acc -> (1 + x):acc) [] [1..]
22:08:56 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ [a]
22:08:56 <lambdabot>      Relevant bindings include
22:08:56 <lambdabot>        acc :: [a] (bound at <interactive>:1:11)
22:09:05 <ronh-> swap arguments
22:09:07 <nak> ronh- huH!
22:09:13 <nak> oh
22:09:17 <joneshf-laptop> :t foldr --nak
22:09:18 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
22:09:19 <nak> > foldl (\acc x -> (1 + x):acc) [] [1..]
22:09:20 <joneshf-laptop> :t foldl --nak
22:09:24 <lambdabot>  mueval: ExitFailure 1
22:09:24 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
22:09:29 <joneshf-laptop> nvm
22:10:02 <ronh-> > foldl (\acc x -> (1 + x):acc) [] [1..]
22:10:07 <lambdabot>  mueval-core: Time limit exceeded
22:10:29 <joneshf-laptop> im curious
22:10:42 <joneshf-laptop> doe anyone know why the arguments are swapped like that?
22:10:49 * hackagebot opentheory 1.196 - The standard theory library  http://hackage.haskell.org/package/opentheory-1.196 (JoeHurd)
22:10:51 * hackagebot opentheory-stream 1.43 - Infinite stream types  http://hackage.haskell.org/package/opentheory-stream-1.43 (JoeHurd)
22:10:52 <joneshf-laptop> is it historical, or some other reason?
22:10:53 <jle`> swapped in foldl compared to foldr?
22:11:01 <joneshf-laptop> jle`, yeah
22:11:21 <jle`> i think it makes more sense
22:11:40 <jle`> foldl f z [a,b,c] = z `f` a `f` b `f` c
22:11:45 <ReinH> nak: http://stackoverflow.com/questions/24370549/foldleft-v-foldright-does-it-matter/24370977#24370977
22:11:50 <jle`> foldr f z [a,b,c] = a `f` b `f` c `f` z
22:12:26 <jle`> it'd be weird of the arguments on f were backwards on foldl
22:12:31 <joneshf-laptop> i guess that makes sense
22:12:36 <ReinH> nak: and http://stackoverflow.com/questions/23893320/why-isnt-this-recursive-function-being-optimized-haskell/23894550#23894550
22:12:43 <ReinH> might help understand the behaviors of foldr and foldl
22:12:46 <ReinH> @lazy
22:12:46 <lambdabot> Unknown command, try @list
22:12:48 <ReinH> @where lazy
22:12:48 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
22:12:52 <ReinH> might also help
22:13:00 <ReinH> and anyway should be required reading imo
22:13:25 <jle`> "here's your ghc compiler, and here's trebla's lazy article"
22:13:41 <jle`> "you are now haskell-certified"
22:13:45 <ReinH> :p
22:14:23 <jle`> anyone here in orange county area? come to my talk on functors and comonads and digital image processing tomorrow ~
22:15:16 <nak> ronh- why does that fail ?
22:15:16 <nak> if anything i would expect the foldl to work, and not foldr
22:15:16 <nak> > foldl' (\acc x -> (1 + x):acc) [] [1..]
22:15:20 <lambdabot>  mueval-core: Time limit exceeded
22:15:31 <jle`> nak: try manually expanding it :)
22:15:37 <jle`> using foldl
22:15:39 <jle`> @src foldl
22:15:39 <lambdabot> foldl f z []     = z
22:15:39 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
22:15:42 <jle`> you will see why
22:15:49 * hackagebot opentheory-probability 1.47 - Probability  http://hackage.haskell.org/package/opentheory-probability-1.47 (JoeHurd)
22:15:51 * hackagebot opentheory-bits 1.64 - Natural number to bit-list conversions  http://hackage.haskell.org/package/opentheory-bits-1.64 (JoeHurd)
22:15:53 * hackagebot opentheory-divides 1.56 - The divides relation on natural numbers  http://hackage.haskell.org/package/opentheory-divides-1.56 (JoeHurd)
22:15:55 * hackagebot opentheory-byte 1.124 - Bytes  http://hackage.haskell.org/package/opentheory-byte-1.124 (JoeHurd)
22:15:57 * hackagebot opentheory-parser 1.156 - Stream parsers  http://hackage.haskell.org/package/opentheory-parser-1.156 (JoeHurd)
22:15:58 <jle`> trust me :)
22:16:00 <ReinH> nak: did you read the things I linked? You should read the things I linked.
22:17:40 <joneshf-laptop> jle`, that sounds interesting
22:18:35 <ronh-> > foldl f d [a,b,c]
22:18:36 <lambdabot>  f (f (f d a) b) c
22:18:39 <jle`> thanks! are you in the area?
22:18:39 <ronh-> > foldr f d [a,b,c]
22:18:41 <lambdabot>  f a (f b (f c d))
22:18:53 <joneshf-laptop> jle`, unfortunately not
22:19:17 <jle`> > foldl (\acc x -> (1+x):acc) [] [a,b,c]
22:19:19 <ronh-> nak see above. you can't get to the head until you have recursed through the entire list with foldl. with foldr, you get to the head right away
22:19:19 <lambdabot>  [1 + c,1 + b,1 + a]
22:19:25 <jle`> oops
22:19:30 <jle`> joneshf-laptop: aw
22:19:34 <joneshf-laptop> jle`, if you have slides, will you put them up afterwards?
22:19:48 <jle`> i will, but i think it's good form to not put that much info on slides
22:19:52 <ronh-> nak and since (:) is lazy in the second argument, the rest of the list doesn't have to be constructed until it is needed (with foldr)
22:20:00 <ReinH> > head . foldr (:) [] $ [1..]
22:20:00 <jle`> i'll mostly put drawings and diagrams and stuff
22:20:01 <lambdabot>  1
22:20:19 <joneshf-laptop> jle`, sounds like it'll be a good talk then :)
22:20:28 <jle`> on this topic i've been meaning to start an OC haskell user group now that the last one is defunct
22:20:35 <jle`> and actually hold meetings and stuff
22:20:51 <ReinH> actual meetings seems like a good plan for a user group
22:20:59 * hackagebot opentheory-unicode 1.138 - Unicode characters  http://hackage.haskell.org/package/opentheory-unicode-1.138 (JoeHurd)
22:21:01 * hackagebot opentheory-prime 1.80 - Prime natural numbers  http://hackage.haskell.org/package/opentheory-prime-1.80 (JoeHurd)
22:21:03 * hackagebot api-opentheory-unicode 1.1 - OpenTheory unicode character API  http://hackage.haskell.org/package/api-opentheory-unicode-1.1 (JoeHurd)
22:21:05 * hackagebot decode-utf8 1.1 - Decode a UTF-8 byte stream on standard input  http://hackage.haskell.org/package/decode-utf8-1.1 (JoeHurd)
22:21:07 * hackagebot nth-prime 1.1 - Computing the nth prime  http://hackage.haskell.org/package/nth-prime-1.1 (JoeHurd)
22:21:19 <joneshf-laptop> jle`, you should instead move to sac, and start a group here :)
22:21:20 <jle`> mhm meetings confer a certain amount of authenticity and legitimacy
22:21:33 <ReinH> and "existence"
22:21:56 <jle`> ah yeah that too.
22:21:57 <joneshf-laptop> except it seems like it'd only be the two of us :\
22:21:58 <jle`> :)
22:22:12 <jle`> yeah i looked on haskellers.org and there seem to be like five haskellers in OC
22:22:24 <jle`> deezn: btw, did you ever figure out your issue?
22:22:43 <ReinH> jle`: are you going to bayhac this year?
22:22:46 <jle`> s/5/3
22:22:55 <jle`> when is it?
22:23:14 <jle`> maybe i can convince my classmates to come
22:23:14 <ReinH> june 12-14 http://bayhac.org/
22:23:18 <ReinH> so soon
22:23:22 <jle`> i wonder if i can apply for funding
22:23:28 <jle`> er, travel funds from my school
22:23:42 <ReinH> you could probably share a hotel room with someone
22:23:51 <jle`> JUNE <$> [12,13,14] <*> 2015
22:23:55 <jle`> what is that even supposed to mean
22:24:06 <jle`> maybe they mean JUNE <$> [12,13,14] <*> pure 2015
22:24:11 <ReinH> clearly it should be... yes that
22:24:13 <joneshf-laptop> i'll probably be there friday or sunday
22:24:17 <joneshf-laptop> ReinH, you going?
22:24:32 <ReinH> joneshf-laptop: probably, the company I work for is in the valley
22:24:37 <jle`> or flip JUNE 2015 <$> [12,13,14]
22:25:09 <jle`> can we all agree to call conal "colonel elliot"
22:25:43 <ReinH> ha
22:25:53 <ReinH> Well, you could spell it Elliott
22:25:57 <jle`> wait, the conference is free?
22:26:06 <ReinH> It isn't a conference, really
22:26:09 * hackagebot fen2s 1.1 - Converting a chess position from FEN notation to text  http://hackage.haskell.org/package/fen2s-1.1 (JoeHurd)
22:26:11 * hackagebot stackage-metadata 0.1.0.0 - Grab current metadata for all packages  http://hackage.haskell.org/package/stackage-metadata-0.1.0.0 (MichaelSnoyman)
22:26:13 <ReinH> well, it's somewhere between a hackathon and a conference
22:26:42 <jle`> it might be hard to get my school to give me travel grants then. but i guess a month away round trip is only like $100
22:27:47 <jle`> i will be @bayhac2015's 4th follower on twitter
22:27:53 <jle`> i'll also squat on @bayhac2016 for some easy cash
22:28:32 <jle`> i immediately regret saying that out loud
22:29:33 <heatsink> Ooh, bayhac looks like it could be good
22:33:30 <nak> jle` ok i follow u now :)
22:33:55 <nak> jle` i found u on github just now too ^.^
22:34:12 <jle`> ^.^
23:03:31 <aloiscochard> hi there, anyone using halcyon (https://halcyon.sh/) with zsh?
23:03:41 <aloiscochard> I'm having issues getting paths properly setup
23:04:04 <Eiam_> aloiscochard: try #haskell-deployment 
23:04:11 <Eiam_> mietek hangs here though too
23:04:37 <aloiscochard> oh great to know the dev is on irc, ty Eiam_ 
23:04:50 <Eiam_> yup
23:23:41 <jle`> that's one nice thing about haskell.  most library devs are on irc :)
23:38:22 <nuser> How may I hide depreciated warnings?
23:40:52 * hackagebot base-compat 0.8.2 - A compatibility layer for base  http://hackage.haskell.org/package/base-compat-0.8.2 (ryanglscott)
23:41:14 <nuser> depreciated module warnings to be specific
23:41:47 <jle`> if you have the ability, you can not use that module?
23:41:55 <jle`> or is it a warning coming from a library you are using using the bad module
23:42:51 <nuser> it's Data.AttoParsec.Char8
23:43:11 <nuser> about it depreciated for the next release
23:43:49 <jle`> can you just not use that module?
23:44:02 <jle`> if it's deprecated, then there's probably an alternative
23:44:20 <nuser> How do I find the alternative?
23:44:33 <jle`> what are you doing with it?
23:44:48 <rasen_> The alternative is usually stated in docs
23:44:50 <jle`> if it's deprecated it means that attoparsec people really really recommend you not to use it
23:45:12 <jle`> enough to ask the compiler to emit a warning
23:45:16 <nuser> ok, will look at the docs
23:46:36 <rasen_> Seems Data.AttoPasec.Char8 just re-exports Data.AttoParsec.ByteString.Char8
23:46:38 <nuser> that was easy. Thanks for the push guys
23:46:50 <jle`> np :)
23:51:05 <johnw> deprecated often also has the meaning, "will go away in a future version"
