00:00:28 <Cale> unb3k44n7: Are you interested in programming in Haskell, or are you just new to IRC?
00:01:18 <unb3k44n7> I wasn't sure what haskell was unti l came in here.
00:01:21 <ElMoloko> Excuse me, my dear haskellers - do any of you happen to know if Network.Socket is platform independent?  I don't currently have a windows or OSX setup to test on, and appear to be slightly too inebriated to get reasonable results out of a google query.
00:01:27 <unb3k44n7> Also new.
00:01:43 <Cale> ElMoloko: Yes, it ought to be.
00:02:02 <Cale> ElMoloko: Just make sure to use withSocketsDo if you want the program to work on Windows
00:02:39 <unb3k44n7> I found out about Haskell here https://news.ycombinator.com/item?id=5587268
00:02:49 <unb3k44n7> when I was searching for a room a might be interested in
00:02:55 <ElMoloko> @kale thanks! i somehow managed to miss that
00:02:55 <lambdabot> Cale etc already pointed out Haskell is puny to nothing to emulate using my barrage of mathematic theories
00:03:01 <unb3k44n7> Channel*
00:03:04 <ElMoloko> part of the documentation
00:03:11 <unb3k44n7> A channel I might be interested in*
00:03:13 <Cale> haha, the bot thought you wanted @keal
00:03:30 <ElMoloko> ! that existing is wonderful
00:03:59 <ElMoloko> Cale: oh dear, I'm sorry.  Thanks though.
00:04:14 <Cale> (Keal was this troll/crazy person we had a long time ago, and we made him into a bot command)
00:04:51 <ElMoloko> I was about to say, lambdabot seemed quite a lot sassier than normal there.
00:05:14 <Cale> haha
00:05:16 <Cale> @keal
00:05:16 <lambdabot> write an algorthim that generates the correct responses for a phone survey based on number of rings whether answered how quickly hung up on and the mood of the receiver
00:05:43 <ElMoloko> need to plan a fieldtrip to Frederick B. Mancoff of Freescale Semiconductor
00:07:41 * hackagebot chalk 0.1.0.1 - Terminal string styling.  http://hackage.haskell.org/package/chalk-0.1.0.1 (cattheory)
00:07:41 * hackagebot quantfin 0.1.0.2 - Quant finance library in pure Haskell.  http://hackage.haskell.org/package/quantfin-0.1.0.2 (tdees)
00:07:50 <ElMoloko> This Keal seems like one of the more amusing trolls, at least.  Unless lambdabot is just optimising for amusement :)
00:08:19 <Cale> It's a bit of both, he was pretty amusing on a regular basis.
00:08:30 <unb3k44n7> Why would anyone want to take part in a phone survey?
00:08:53 <unb3k44n7> I think the algorithim should be everyone hung up.
00:09:42 <ElMoloko> Come to think of it, I think I learned about #haskell (not about haskell, that was right when Learn You A Hakell was published :P) from an HN post a troll
00:09:52 <ElMoloko> quasar or something
00:10:14 <Cale> unb3k44n7: heh
00:10:36 <unb3k44n7> Is everyone in here an actual person?
00:10:52 <Cale> No, but mostly.
00:11:15 <unb3k44n7> The zso_ people seem redundant.
00:11:22 <Cale> Also probably a lot of them are asleep/not watching the channel at any given time
00:12:55 <ElMoloko> I rarely ever speak in hear; I consistently browse the logs locally though (whenever I don't have access to ircbrowse, which is quite a lot)
00:13:51 <Cale> unb3k44n7: If you're interested in learning to program in Haskell, this course is good: http://www.seas.upenn.edu/~cis194/spring13/lectures.html
00:14:21 <unb3k44n7> I'm not sure what I would use it for at the moment.
00:15:12 <ElMoloko> Ok, since apparently I'm `(still $ not_sober)` enough to make phonetic-equivalency spelling mistakes, I'm going to disappear and live vicariously through these logs.  Ctrl-D for now!
00:15:47 <unb3k44n7> What logs?
00:16:33 <Hijiri> irc logs, like many clients keep
00:16:50 <pk4771> I get the error message "Could not find module `Data.Label'     It is a member of the hidden package `fclabels-2.0.2.2'.  Perhaps you need to add `fclabels' to the build-depends in your .cabal file" , I have added fclabels ==2.0.2.2 in build-depends then why this errs is showing. 
00:17:13 <pk4771> help please
00:17:21 <Hijiri> I'm not sure if irc logs also sometimes refers to the stuff you can read by scrolling up
00:17:22 <unb3k44n7> Is it just a chat log from the channel?
00:17:28 <unb3k44n7> Or whatever channel?
00:17:30 <Hijiri> yeah
00:17:52 <Hijiri> most clients have an option to log chats
00:17:53 <unb3k44n7> ...I used to do that with Yahoo Messenger..
00:17:55 <Cale> pk4771: Which command are you running?
00:18:14 <pk4771> cabal build
00:18:19 <Cale> unb3k44n7: there are fairly complete logs here: http://ircbrowse.net/browse/haskell
00:19:19 <unb3k44n7> That is a pretty complete looking list.
00:19:23 <Cale> pk4771: hmm, that's interesting
00:19:24 <pk4771> Cale : cabal build
00:20:05 <unb3k44n7> What do you use Haskell for?
00:20:21 <pk4771> Coding
00:20:26 <unb3k44n7> Coding what?
00:20:31 <rien> programs?
00:20:33 <rien> :P
00:20:35 <pk4771> Diagrams .. 
00:20:36 <unb3k44n7> What kind of programs?
00:20:58 <unb3k44n7> Executable ones? (lol)
00:21:02 <pk4771> I am working on diagrams package,  implementing graphical layouts
00:21:31 <unb3k44n7> Are are you designing?
00:21:37 <unb3k44n7> What are you designing?
00:21:40 <rien> Cale: is there a big tarball of all the logs?
00:21:51 <pk4771> Does it matter?
00:21:54 <Cale> unb3k44n7: I worked for a startup company that was writing an action RPG for iPhones in Haskell, and for skedge.me on a web application backend in Haskell, as well as a long time ago on a special purpose compiler for signal processing applications.
00:22:06 <unb3k44n7> No It doesn't matter..
00:22:34 <Cale> rien: I dunno about a tarball, but there are files here: http://tunes.org/~nef/logs/haskell/
00:22:35 * hackagebot postgrest 0.2.9.1 - REST API for any Postgres database  http://hackage.haskell.org/package/postgrest-0.2.9.1 (begriffs)
00:22:37 <rien> Cale: you might have interviewed me at skedge.me
00:23:05 <unb3k44n7> I was just wondering.
00:23:27 <unb3k44n7> What's a signal processing application, like a gps for a phone?
00:23:54 <unb3k44n7> What were you compiling?
00:24:02 <Cale> Like processing the output of MRI machines, doing fast Fourier transforms and resampling and material analysis and such
00:25:57 <unb3k44n7> Like electromagnetism?
00:26:03 <Cale> At the time I was working on that project, I was just working on a piece of the backend which did some pretty brute force analysis to determine which would be the best order in which to issue instructions in a tight loop to the PowerPC/Altivec hardware. The sample program that I was targetting was some vectorised code which computed sine/cosine pairs
00:27:34 <Cale> So I had what was more or less a simulation of how long the units on the PPC chip would be occupied for various instructions, and I was trying to fit the instructions in the loop into the smallest number of clock cycles possible.
00:27:36 * hackagebot pipes-errors 0.3 - Integration between pipes and errors  http://hackage.haskell.org/package/pipes-errors-0.3 (jdnavarro)
00:27:49 <unb3k44n7> So did you work on constucting MRI machines in like the factory before medical facilities purchase them?
00:27:58 <unb3k44n7> constructing*
00:28:24 <unb3k44n7> Or did you go to medical facilities and test them after they were brought there?
00:29:03 <Cale> This was contract work for a researcher at a university who was interested in improving the methods by which the *output* of MRI machines is processed.
00:29:17 <Cale> The signals that MRI machines produce are not directly images
00:29:26 <unb3k44n7> Right..
00:30:18 <Cale> But instead measure something like the Fourier transform of the image that you'd be interested in seeing -- how much amplitude is in each direction at each frequency
00:30:39 <unb3k44n7> And you can use Haskell for that?
00:30:51 <Walther> you probably dealt with vectors with funny amount of dimensions :P
00:30:56 <unb3k44n7> Not physics and math?
00:31:19 <Cale> Well, you could use Haskell directly. At the time, we were using Haskell to write the compiler for a language with which the programs which would do that would be written in.
00:31:27 <mjrosenb> hoogle (a -> b) -> (a,a) ->(b,b)
00:31:30 <Cale> Rather indirect :)
00:31:39 <mjrosenb> @hoogle (a -> b) -> (a,a) ->(b,b)
00:31:40 <arkeet> :t join (***)
00:31:40 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
00:31:40 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
00:31:40 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
00:31:42 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
00:31:48 <unb3k44n7> I see.
00:31:49 <arkeet> :t over each
00:31:51 <lambdabot> Each s t a b => (a -> b) -> s -> t
00:32:22 <arkeet> > over each (+1) (3,4)
00:32:24 <lambdabot>  (4,5)
00:33:05 <unb3k44n7> Brb
00:33:08 <Walther> > map (+1) (1,2)
00:33:09 <lambdabot>      Couldn't match expected type ‘[b]’
00:33:10 <lambdabot>                  with actual type ‘(Integer, Integer)’
00:33:10 <lambdabot>      In the second argument of ‘map’, namely ‘(1, 2)’
00:33:28 <Walther> right, no map for tuples
00:33:31 <Cale> unb3k44n7: Anyway, in the end, my little piece of the compiler scheduled the vectorised sine/cosine pair computing code such that it took about 2.5 clock cycles per float to compute them in a tight loop
00:33:37 <mjrosenb> arkeet: what do I need to import for that?
00:33:47 <mjrosenb> Walther: it would be fmap, since map is only lists
00:33:59 <Walther> > fmap (+1) (1,2)
00:33:59 <Cale> unb3k44n7: (of course, it could schedule arbitrary loops, but that was the main chunk of test code I was compiling)
00:34:01 <lambdabot>  (1,3)
00:34:02 <mjrosenb> but fmap on tuples only operates on the second element.
00:34:18 <Walther> > fmap (+1) (1,2,3,4,5)
00:34:19 <lambdabot>      No instance for (Show t0)
00:34:20 <lambdabot>        arising from a use of ‘show_M483878718146993454111297’
00:34:20 <lambdabot>      The type variable ‘t0’ is ambiguous
00:34:25 <arkeet> mjrosenb: for which?
00:34:33 <arkeet> (***) is from Control.Arrow, over each is from lens
00:34:36 <mjrosenb> arkeet: over each.
00:34:45 <Cale> unb3k44n7: By extremely unfair comparison, a call to GNU libm's sine function takes about 200 clock cycles.
00:34:51 <Walther> > over each (+1) (1,2,3,4,5)
00:34:53 <lambdabot>  (2,3,4,5,6)
00:35:50 <mjrosenb> arkeet: join looks like it is from elsewhere.
00:36:00 <mjrosenb> oh, is that Control.Monad>
00:36:04 <arkeet> yes
00:38:55 <jle`> Walther: you can also use `bimap` from Data.Bifunctor, which is now in base too
00:39:23 <jle`> > BF.bimap (+1) (+1) (4,5)
00:39:26 <lambdabot>  (5,6)
00:39:57 <ronh-> > over each (+1) (1,2,3,4,5,6,7,8,9,0,1,2,3,4,5)
00:39:59 <lambdabot>      No instance for (Show a0)
00:39:59 <lambdabot>        arising from a use of ‘show_M7944292898721815011502’
00:39:59 <lambdabot>      The type variable ‘a0’ is ambiguous
00:40:13 <jle`> what now, lens
00:41:34 <unb3k44n7> Back.
00:42:24 <ronh-> :t over each (+1) (1,2,3,4,5,6,7,8,9,0,1,2,3,4,5)
00:42:25 <lambdabot> (Num a, Num t1, Num t2, Num t3, Num t4, Num t5, Num t6, Num t7, Num t8, Num t9, Num t10, Num t11, Num t12, Num t13, Num t14, Num t15, Each (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15) t a a) => t
00:42:36 <unb3k44n7> So your code was better than GNUs function?
00:43:32 <unb3k44n7> Or yours wasn't fast enough to reciprocate with it?
00:45:06 <arkeet> Each only has instances for up to 9-tuples.
00:50:20 <unb3k44n7> Sorry I don't quite speak your language ;)
00:51:16 <Cale> unb3k44n7: The code generated by our Haskell program ran about 80 times faster than the ordinary sine and cosine functions you'd use in C.
00:51:31 <unb3k44n7> C, like C++?
00:51:41 <Cale> Like, not C++, but the original language C
00:51:48 <unb3k44n7> Oh.
00:52:05 <Cale> Well, maybe C++ uses those functions as well, I don't know.
00:52:19 <unb3k44n7> Me either.
00:53:09 <unb3k44n7> I know how to write some code. But not familiar with all the terminology. And It's been a long time.
00:55:38 <unb3k44n7> I was pretty good at html many years ago. 
00:57:00 <unb3k44n7> Where are you all from?
00:57:23 <tzaeru> Cale, you wouldn't use the ordinary functions in performance-tight spot thou.
00:57:51 <tzaeru> either some sort of caching or your own optimized function with a different trade-off in accuracy vs. cycles.
00:59:01 <Cale> tzaeru: Of course, also, the libm functions aren't vectorised
00:59:21 <Cale> tzaeru: I did say it was an extremely unfair comparison :)
00:59:53 <tzaeru> yea ^^
01:00:01 <tzaeru> similar comparisons are done with LuaJIT vs C++..
01:00:22 <unb3k44n7> What's a GNU libm's sine function?
01:01:41 <tzaeru> doing short, strongly vectorizable Lua code with the potential for other funky on-the-fly optimizations like reasoning between using long long vs int and stuff like that, then running it via the JIT compiler and then doing a naive C++ code to run under gcc without even bothering to try fast-math or unrolling (not that they really helped that much usually..)
01:02:14 <tzaeru> though don't get me wrong, LuaJIT is pretty amazing! :P
01:02:31 <unb3k44n7> *blinks
01:02:37 <tzaeru> as I am sure many parts of GHC are too
01:03:50 <unb3k44n7> Are most of you college students?
01:03:54 <tzaeru> unb3k44n7, I believe it's the general-use IBM's sine implementation
01:04:02 <tzaeru> meant for x86 systems.
01:04:26 <tzaeru> most CPUs also have an instruction for sine, but I don't think they are really that much faster..
01:04:52 <merijn> tzaeru: If you wanna see "cool JIT stuff for dynamic languages", google Graaf/Truffle
01:05:26 <merijn> tzaeru: It's a framework for enabling naive AST rewriting interpreters to use the JVMs JIT stuff
01:05:47 <merijn> tzaeru: Resulting in ridiculous performance for naive interpreter code :)
01:05:48 <tzaeru> o', the magic!
01:05:54 <simpson> Also, PyPy/RPython.
01:06:05 <merijn> simpson: This is far more general than those
01:06:06 <unb3k44n7> Which bit does x86 work with?
01:06:06 <tzaeru> PyPy isn't very performant quite yet, I don't think
01:06:42 <simpson> tzaeru: Common myth. It's plenty fast. Has been for a decade.
01:06:50 <merijn> tzaeru: As an example, 6 guys wrote a full JS interpreter within a year and their performance results are within 10% (above and below) of Google V8 on JS benchmarks
01:07:03 <merijn> simpson: That depends on your baseline
01:07:21 <simpson> merijn: Hm. What's not general about RPython? I've written several AST interpreters with it.
01:07:31 <merijn> tzaeru: If you think about the amount of work and man-years (man-decades?) that went into V8, that's insane
01:07:53 <tzaeru> merijn, I suppose those guys are well-employed by now, then >:D
01:08:15 <merijn> tzaeru: It was just a proof-of-concept for this Graal/Truffle stuff
01:08:27 <merijn> tzaeru: They were already well-employed before then :p
01:08:41 <tzaeru> well, even weller now!
01:09:01 <unb3k44n7> Wow... there's 40,000 channels on this server..
01:09:17 <merijn> tzaeru: You should be able to find a presentation on this if you google for "One VM to Rule Them All"
01:09:51 <tzaeru> simpson, it's not really a myth. it just depends. C extension modules slow it down. ctypes. heavy runtime functions, which are not quite so optimized. any bunch of rarely ran short scripts.
01:10:06 <tzaeru> I'm sure PyPy is great for some projects.
01:10:08 <unb3k44n7> One of my friends back in the day tried to teach my Python
01:10:16 <tzaeru> but it can hardly be considered a general replacement to CPython as is
01:10:29 <tzaeru> and that's not only due to the lacks in support to existing modules
01:10:46 <tdammers> AFAIK, Python is notoriously difficult to implement efficiently
01:11:07 <tzaeru> eh, well, I don't know if it would really be much more difficult to JS in the end, if same effort was put to it..
01:11:24 <tzaeru> but there's never been a strong push to increase the performance of Python from a well-funded entity, I think
01:11:28 <tdammers> me neither, but my gut feeling says JS is easier
01:11:29 <merijn> JS, python and ruby are all terrible targets for efficiency
01:11:39 <tzaeru> why would JS be easier?
01:12:06 <tdammers> idk... simpler language, a bit more constraints...
01:12:25 <simpson> It's not a simpler language.
01:12:32 <tdammers> it is
01:12:33 <simpson> They're both pretty gnarly in the details.
01:12:37 <tdammers> sure
01:12:42 <tdammers> but JS has fewer concepts
01:12:55 <simpson> Hm. What's a concept that Python has and JS does not have?
01:13:01 <tdammers> classes
01:13:04 <tzaeru> I thought python has more constraints, like being strongly typed
01:13:06 <tdammers> modules
01:13:21 <tzaeru> the python class implementation is very simplistic.
01:13:25 <simpson> JS effectively has modules these days. People have invented and lash themselves to module systems.
01:13:32 <tdammers> I know
01:13:36 <simpson> Both Python and JS use the same sort of inheritance: Prototypes.
01:13:48 <tdammers> but when you write a JS implementation, you don't need to implement modules
01:13:49 <simpson> Python calls them "classes" because Python is a big fat liar.
01:14:19 <tzaeru> lie as it might, it's still more fun to do classes in Python than C++ >:-D
01:14:27 <tdammers> it is?
01:14:32 * tdammers disagrees
01:14:33 <tzaeru> but then, almost everything is more fun in <any language> than in C++
01:14:54 <tdammers> tzaeru: I raise you PHP
01:14:57 <simpson> Anyway, speaking as somebody writing a VM for a related language, the hardest thing to optimize in these languages is the dynamic names of any given scope.
01:15:01 <tzaeru> tdammers, I second with Perl
01:15:15 <tdammers> no, I still win
01:15:19 <tzaeru> :(
01:15:51 <merijn> tzaeru: I disagree
01:16:00 <tdammers> PHP is half of a horribly uninformed attempt at implementing Perl, and then someone tacked a completely wrong rip-off of Java's OOP onto it
01:16:05 <tzaeru> I've grown to dislike dynamic typing a bit.. not only due to the performance difficulties, but more for the fact that in large projects, static types just up end good documentation and it's easier to reason about the code >_>
01:16:13 <tzaeru> the idea that dynamic typing made coding easier, is ludicrious.
01:16:20 <merijn> tzaeru: I think C++(11/14) is better than Java, Python, Ruby, PHP, JS, C
01:16:25 <tdammers> dynamic typing makes hand-waiving easier
01:16:26 <unb3k44n7> What if someone made a language that combined all the languages?
01:16:36 <tzaeru> merijn, I wasn't entirely serious. :P I do find a fancy for C++.
01:16:40 <unb3k44n7> Would the internet implode?
01:16:43 <merijn> tzaeru: If you haven't looked at C++11 I recommend it :)
01:16:51 <tzaeru> I was mostly pulling a joke on the perceived, um.. 'funkiness'.. of C++
01:17:08 <tzaeru> I have. I don't like most of it, there's starting to be a wealth of language bloat.
01:17:09 <merijn> lambda's! limited type inference! compile time code evaluation! templates!
01:17:19 <merijn> It's totally funky and messy and horrifically verbose
01:17:24 <keko_> unb3k44n7: they would have created a new lisp dialect
01:17:27 <merijn> But, at least I can express what I want in C++
01:17:29 <nshepperd> if the only type systems were ones like go and C's, dynamic typing would make coding easier
01:17:37 <merijn> Unlike Python, Ruby, JS, etc.
01:17:53 <tdammers> it's funky because it tries to avoid assumptions that could limit runtime performance
01:17:57 <merijn> And C++ has the advantage of RAII over C
01:18:15 <merijn> That being said, I would still use haskell over C++ any day :p
01:18:16 <tdammers> while still trying to be as high-level as possible
01:18:19 <tzaeru> tdammers, C++? no, it's funky because it has decades of feature pileup and hacky solutions to issues that could have been solved more elegantly..
01:18:47 <unb3k44n7> * Googles "lisp dialect"
01:18:56 <tdammers> tzaeru: those features piled up because C++ tries to not be opinionated
01:19:16 <tdammers> and the "elegant" solutions either weren't known at the time, or they would require sacrifices
01:19:43 <tzaeru> well, it's not really so unopinionated. some garbage collection support was added. smart pointers were added. auto was added.
01:19:59 <tdammers> added, yes, but as *optional* features.
01:20:04 <tdammers> you are not *required* to use them
01:20:22 <tdammers> in Python, whatever GC comes with the implementation is mandatory
01:20:36 <tzaeru> that's simply not true for people who work on multiple, large projects with other people.
01:20:37 <tdammers> in C++, you get to choose - RAII is highly recommended, but you don't *have* to use it
01:20:43 <tzaeru> if you only code alone, sure, use whatever you want
01:20:58 <tzaeru> but when you work with a lot of different people and different codebases, you wind up to seeing every possible language feature eventually.
01:21:00 <tdammers> by "you", I mean "whoever works on the code"
01:21:23 <tdammers> and yes, the fact that every team picks their own subset of C++ and codes in that is kind of a problem
01:21:30 <tzaeru> and have to conform to the established practices of the project.
01:21:35 <tdammers> yes
01:21:43 <tdammers> which is why opinionated languages are so popular
01:22:02 <tzaeru> so no language feature is truly optional, except if you code solo or happen to be the lead programmer on the project
01:22:03 <tdammers> in those, it doesn't make sense to do things any other way than the idiomatic one
01:22:11 <tzaeru> yeah. that's why I prefer Python over Lua :P
01:22:19 <tdammers> they are optional in that the language doesn't make you use them
01:22:41 <tdammers> you are forced to use them through social mechanisms, not for technical reasons
01:22:57 <tzaeru> I don't see how that's a good thing, really.
01:23:00 <tzaeru> it's just.. a thing
01:23:05 <tdammers> exactly
01:23:18 <tdammers> it's a thing, and it has upsides and downsides
01:23:28 <tdammers> as long as you know what those are, you can make an educated decision, is all
01:23:32 <tzaeru> which, in practice, means that to code fluently in the language, you need to remember more and need more attention and brain work towards the language itself
01:23:35 <tdammers> doesn't make C++ a bad language though
01:23:52 <tdammers> more tools -> more learning effort, more choice
01:23:55 <tzaeru> which is always away from the *actual* logical problems and code structure itself at hand
01:24:13 <tdammers> ofc
01:24:32 <tdammers> I don't usually use C++ unless I'm in the particular niche where it is the right choice
01:24:56 <tdammers> let's say it's not my go-to language, but it's a good tool to have
01:25:47 <Phlogistique> 10:13:14 < simpson> Both Python and JS use the same sort of inheritance: Prototypes. <- why do you call Python classes "prototypes"?
01:26:04 <unb3k44n7> Do you guys freehand your coding or do you use templates and like programs like notepad++?
01:26:31 <tdammers> "freehand"?
01:26:47 <unb3k44n7> Freehand, like, you just write it.
01:26:57 <tdammers> how else would you do it?
01:27:00 <unb3k44n7> Like you type every character
01:27:07 <tdammers> oh, well, sort of
01:27:10 <tdammers> I use vim
01:27:17 <Haskellfant> haskell has not that buch boilerplate so just typing it works pretty well
01:27:23 <tzaeru> unb3k44n7, most development environments and editor software feature some automation.
01:27:33 <merijn> tdammers: tbh I usually find auto-completing to be more work than just typing for haskell
01:27:34 <unb3k44n7> Ok
01:27:41 <tdammers> merijn: agree.
01:27:46 <bernalex> agree with Haskellfant. you don't need an auto-win button like you do for java.
01:28:20 <tdammers> I actually like vim's dumb autocomplete better than the smarter ones you see in Java or .NET IDEs
01:28:27 <Phlogistique> Haskellfant: well, Haskell programs do tend to include a lot of {# directives #} and import Foo (Foo, Bar, Baz)
01:28:46 <tdammers> it works on everything, and it works the same for every language, even plain text or config files
01:29:21 <tdammers> Phlogistique: a powerful editor makes those bearable enough
01:29:40 <simpson> Phlogistique: These languages both derive from Self, which used the word "prototype" to describe it.
01:29:47 <Haskellfant> I don't think there are that many and yes editors help there
01:30:00 <simpson> Phlogistique: It's a description of a type which permits individual instances of the type to vary in their actual structure.
01:30:33 <Phlogistique> simpson: so Ruby is a prototype-based language too?
01:31:02 <ChristianS> Phlogistique: no
01:31:42 <Phlogistique> ChristianS: according to simpson's definition of a prototype-based language, it looks like it is
01:32:50 <ChristianS> Phlogistique: definitions aren't always reasonable
01:32:50 <unb3k44n7> Are you all just nocturnal or live overseas? (It's 3:32 AM) 
01:33:03 <tdammers> EU
01:33:05 <unb3k44n7> Europeans?
01:33:06 <ChristianS> unb3k44n7: the internet doesn't exist on a single timezone
01:33:19 <unb3k44n7> I know it doesn't.
01:33:40 <Cale> I'm nocturnal I guess. Woke up at 1am here
01:33:41 <unb3k44n7> In respect to my time zone I was inferring.
01:34:23 <unb3k44n7> Sleep during the day and live at night?
01:34:49 <MarceColl> EU
01:35:07 <bernalex> I used to sleep every other morning from about 10->15. now it depends on whether I live alone or not. when I do that I tend to fall into that schedule again.
01:35:09 <unb3k44n7> There's a lot of Europeans on IRC I noticed
01:35:25 <MarceColl> well, it's 10:30 over here
01:35:45 <bernalex> MarceColl: your timezone is +2h5m? :D
01:35:59 <MarceColl> special for me :D
01:36:06 <arafangion> As a haskell newbie, what's the best way to allow two free monads (with their respective interpreters) to be composed so that a single monad can use them? Do I need to make these become a monad transformer?
01:37:22 <Cale> arafangion: You can define a sum operation and use it on the underlying functors
01:38:56 <unb3k44n7> Is it 3 am by you also, Cale?
01:39:09 <Cale> 4:30ish here
01:39:27 <unb3k44n7> So you're on the east coast
01:39:51 <unb3k44n7> NY?
01:40:20 <Phlogistique> 10:32:28 < ChristianS> Phlogistique: definitions aren't always reasonable <- did you read the discussion?
01:41:10 <arafangion> Cale: Would you happen to be able to help me find an article discussing that?  The simple things escape me. :(
01:41:15 <Cale> arafangion: i.e. use https://hackage.haskell.org/package/transformers-0.4.3.0/docs/Data-Functor-Sum.html
01:42:03 <ChristianS> Phlogistique: admittedly i only read simpson's latest statements, not everything that may have preceded them
01:42:27 <arafangion> Cale: I'm having trouble visualising how that would operate with the interpreters that I would define for the free monads that I would be using.
01:42:39 * hackagebot rest-core 0.36.0.1 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.36.0.1 (AdamBergmark)
01:42:43 <Cale> arafangion: So where you might have had the free monad on F or the free monad on G, you then have the free monad on Sum F G
01:42:58 <tzaeru> things like that are still why I struggle a lot in grasping even basic Haskell @,@ so many things to remember.
01:43:15 <arafangion> Cale: So the interpreters won't be defined as separate implementations on their respective free monads, but an interpreter would be defined for the sum?
01:43:16 <Cale> tzaeru: Which things?
01:43:20 <tzaeru> C's easy, it's just a bunch of variables, a simple scope for them, and then stuff that modifies them
01:43:34 <MarceColl> Haskell has made me question if I'm retarded and my family just doesn't tell me
01:43:35 <tzaeru> Cale, like monads or combining monads and all kinds of stuff like that.
01:43:40 <ChristianS> Phlogistique: but see https://en.wikipedia.org/wiki/Prototype-based_programming
01:43:46 <unb3k44n7> Lol
01:43:53 <Cale> tzaeru: Eh, you almost never really have to do this kind of thing
01:43:55 <tzaeru> MarceColl, no kidding
01:44:15 <tzaeru> kills my self-esteem, it does.
01:44:16 <jle`> yeah, something like this is really out of the ordinary for normal haskell usage...
01:44:19 <ChristianS> Phlogistique: that article calls javascript and some other languages prototype-based, while ruby is class-based. that would be my understanding too.
01:44:33 <MarceColl> tzaeru, yup, mine too
01:44:34 <jle`> but i'm not sure why someone's self esteem should be tied to how fast they grasp a computer programming language
01:44:40 <isBEKaml_mobile> tzaeru: Haskell is also easy. It's just a bunch of functions and stuff that modifies them. ;-)
01:44:49 <tzaeru> jle`, well, out-of-ordinary things for many languages are decently easy to understand when the language syntax itself is simple and the doings of the language low-level.
01:44:50 <arafangion> tzaeru: The big aha moments for me when it came to monads, was that you really shouldn't learn about them.  Learn instead how how bind and return work, and ignore do notation.
01:45:02 <jle`> there are probably much more meaningful measures of intelligence, if intelligence is what you're talking about
01:45:03 <arafangion> tzaeru: Then, once you recognise the pattern, call it a monad. :)
01:45:10 <Cale> I mean, in C, I dunno, you can implement some complicated computational geometry stuff. Understanding that code might require specialised knowledge.
01:45:10 <unb3k44n7> Stuff.
01:45:11 <tzaeru> haskell's immensively much more high-level in many concepts in relation to how computers tend to handle data when compared to most procedural languages
01:45:15 <MarceColl> and everytime I think I've understood, ghc crushes my dreams
01:45:17 <jle`> and there are probably more meaningful things to hang your self-esteem on than how fast you can learn a computer programming language
01:45:32 <jle`> :)
01:45:38 <Cale> Similarly, if you use fancy specialised knowledge in the construction of your Haskell libraries, then it may require that knowledge to understand.
01:45:54 <arafangion> Cale: Such as for simple regex libraries(!)
01:45:57 <Cale> Personally, I never *set out* to define a monad.
01:46:01 <tzaeru> jle`, well, it kills my self-esteem as a professional programmer.
01:46:15 <Cale> I only *notice* when a monad is present, in order to save code.
01:46:28 <tzaeru> my self-esteem as a totally sexy, charismatic, smart, photographic, likeable, humorous guy is still unscratched
01:46:30 <Cale> (by reusing all the stuff that's been written to work with an arbitrary monad)
01:46:31 <jle`> still think you might be setting your bar too high :)
01:46:39 <jle`> ah, well that's good to hear :D
01:46:43 <unb3k44n7> You have it rough, I have to google every other word being typed in here to follow the conversation!
01:46:58 <jle`> i think it's normal for things to take time to learn
01:47:10 <jle`> i remember it took me like at least five years to learn how to add numbers
01:47:13 <jle`> man, those were some rough times
01:47:19 <jle`> 2 + 4 = whaaaaat ?
01:47:21 <arafangion> jle`: You *remember* those years?
01:47:26 <Cale> It's normal for things to take time to learn, and if you don't feel like you're at sea at least a fair amount of the time, you probably could be learning faster.
01:47:28 <tzaeru> I suppose the thing is that after I learned my first language properly, I never had to spend more than hours to grasp the basics of a new language, and no more than a few weeks to being very fluent with it
01:47:30 <jle`> i remember that it took that long, at least
01:47:41 <tero-> with Haskell I constantly have to balance between "getting things done" and "learning the right way to do things"
01:47:46 <jle`> i remember how long it took me to learn calculus
01:47:48 <Cale> tzaeru: Right, most languages are practically reskinnings of the same ideas
01:47:55 <tzaeru> yeah, they are.
01:48:00 <jle`> i should have gone back in time to my 8 year old self and tell him that he should feel bad because he's learning calculus too slow :)
01:48:13 <arafangion> One big, big difference with Haskell, is that haskell tries to pretend that there are no variables.  Then provides abstractions that lets you pretend that there are.
01:48:15 <Cale> tzaeru: So people get comfortable with the idea that a new language will be easy because it's just a small variation on the same languages they already know
01:48:29 <Cale> Haskell doesn't try to pretend there are no variables
01:48:32 <tzaeru> also another thing, that I think does complicate things for me, is that I've zero math background and don't grasp formal math very well ^^
01:48:35 <Cale> Haskell has lots of variables :)
01:48:39 <Cale> They're just immutable
01:48:50 <Cale> (There's also mutable variables)
01:48:51 <arafangion> Cale: Immutable variables?
01:48:56 <jle`> yes, like in math
01:48:58 <Cale> Well, yeah, consider f x = x^2
01:49:02 <jle`> who used the word "variable" first
01:49:06 <jle`> before computer scientists did :P
01:49:08 <Cale> If I write a program like  map f [1..10]
01:49:14 <tzaeru> albeit I haven't actually counted it objectively, to me haskell code always seems to have a lot more syntatical variety and language-bound features to remember than a snippet of say, Java code
01:49:14 <Cale> then x gets bound to many different values
01:49:20 <tdammers> arafangion: variables in the math sense. You don't "put values in variables", you "define a variable to be a symbol for something else"
01:49:21 <Cale> It "varies" over the course of the program
01:49:22 <unb3k44n7> Does Haskell operate in the 4th dimension? 
01:49:42 <tzaeru> unb3k44n7, that would explain a lot of things.
01:49:46 <tzaeru> so I think the answer is 'quite possibly'
01:49:49 <arafangion> tdammers: I really shouldn't have tried to be smart with that statement. :)
01:49:49 <Cale> But while it remains in scope, the value of x doesn't change. Every occurrence of x in the body of the function refers to the same value at any given time.
01:49:53 <isBEKaml_mobile> unb3k44n7: no, got does
01:49:57 <jle`> tzaeru: i'm not sure if that's the case.  most complexity in haskell code i use comes from the abstractions that are implemented in-haskell
01:50:02 <isBEKaml_mobile> Git
01:50:04 <bergmark> i think the 3rd dimension is in the 4th dimension
01:50:41 <tdammers> git uses more than 4 dimensions
01:50:43 <jle`> i think the 2nd dimension is
01:50:45 <tzaeru> jle`, yeah, well, for me I guess what does kind of add to initial complexity is trying to jump to things that are not as, um, smooth in haskell as some other things.. like heavy I/O and so on
01:50:47 <jle`> i think we are at an impasse, bergmark 
01:50:57 <unb3k44n7> ^ Plausible
01:51:20 <Cale> tzaeru: Well, I/O is mostly just a bit *different* in Haskell. I actually really like Haskell's way of handling I/O overall.
01:51:28 <jle`> yeah, i think it's simpler, heh
01:51:36 <tzaeru> perhaps.
01:51:41 <jle`> in any case, i think there is this tendency to set unrealistic expectations when learning haskell
01:51:46 <tzaeru> I've no basis to make a proper opinion on it.
01:51:49 <arafangion> Cale: I'm still trying to understand lazy IO, and why it's "bad".
01:52:01 <jle`> it's like that person who said, "i'm going to learn how to program, so i can make an MMORPG.  it should take like a month, right?"
01:52:08 <Cale> tzaeru: The main thing that people get stuck on is that a value of type IO String, such as getLine, is not just a String which is wrapped up in some sort of sugar coating by the type system
01:52:21 <tzaeru> I wonder why I learned to program in the first place.. probably out of a spurt of stupidity.
01:52:33 <Cale> It's a description of some steps we could execute to obtain a String
01:52:42 <tzaeru> some grandiose idiocy like "maaan I want to be able to tell computers what to dooooo and express myself in pureee logic!"
01:52:48 <tzaeru> and then it went downhill from there.
01:52:49 <Cale> Just like /bin/ls isn't a list of files, it's a program which we could execute to obtain a list of files
01:53:04 <arafangion> Cale: That stumped me for ages, actually.  I couldn't understand the RWH book on state monads or random generators until I realised that.
01:53:05 <unb3k44n7> It was a valid effort tzaeru
01:53:38 <Cale> and then you need to be aware that evaluation (the process of reducing expressions to values in order to do pattern matching) doesn't cause this execution to occur
01:54:26 <Cale> Instead, the action called main is executed at the start of the program, and IO actions are allowed to demand the execution of other actions when they themselves are executed.
01:55:03 <arafangion> Everything is a function... And it's functions all the way down.
01:55:10 <Cale> Not everything is a function
01:55:25 <Cale> Only values whose type is A -> B for some types A and B are functions
01:55:39 <Cale> and in particular, IO actions are not functions
01:55:56 <jle`> a value of type Int is not a function
01:55:56 <arafangion> Cale: Everything is a function... Or a constant, then?
01:55:59 <tzaeru> when I think "everything is a function", first thing that comes to my mind is an outrageously deep nodejs nested callback chain
01:56:02 <tzaeru> >:D
01:56:04 <arkeet> lol
01:56:05 <Cale> Everything is a value
01:56:08 <unb3k44n7> Do you guys come in here most nights or is this room mostly a revolving door?
01:56:09 <Cale> Some values are functions
01:56:14 <arkeet> http://conal.net/blog/posts/everything-is-a-function-in-haskell
01:56:20 <arkeet> I like this post
01:56:25 <Cale> unb3k44n7: I'm here basically every day
01:56:28 <tzaeru> unb3k44n7, majority of people here now are channel regulars
01:56:41 <pharaun> some more quieter than others
01:56:43 * pharaun waves
01:56:47 <tdammers> I'm on the channel almost 24/7, but not always reading
01:56:56 <jle`> functions are just values of types with the type constructor (->)
01:56:58 <merijn> j ##c++
01:57:00 <unb3k44n7> Heh, hi.
01:57:01 * arafangion is sporadically on, and not always using the same nick.
01:57:07 <jle`> just like lists are values of types with the type constructor []
01:57:12 <jle`> [Int] is a list, [Bool] is a list...
01:57:15 <jle`> Int -> Bool is a function
01:57:21 <jle`> Int is not a function
01:57:25 <jle`> Int -> Bool is not a list
01:57:32 <jle`> but they are all values
01:57:40 <jle`> *values of type [Int] are lists, etc.
01:57:47 <noodles1> I'm confused about why  "comp ([True,True,False],[],5)" returns [] in this code: http://lpaste.net/133039
01:57:49 <jle`> functions in haskell actually have a very narrow definition
01:58:02 <unb3k44n7> < needs sleep. But will probably be back tomorrow.
01:58:04 <jle`> well, as narrow as lists
01:58:06 <arafangion> I meant in a similar sense to what people in lisp might say "everything is a list".
01:58:12 <arafangion> Or, at least, a s-exp.
01:58:14 <unb3k44n7> I'm enjoying my time here.
01:58:16 <noodles1> I have a *hunch* it might be something to do with with the guards or the where
01:58:17 <jle`> ah.  well, that's not the case, then
01:58:24 <jle`> not everything in haskell is a function
01:58:30 <jle`> most haskell values actually aren't functions
01:58:37 <tdammers> but then, not everything in lisp is an s-expr either
01:58:37 <jle`> most ones you wokr with every day, at least
01:59:09 <arkeet> (some things that you might not expect to be functions actually internally are, though)
01:59:18 <unb3k44n7> Thanks. *waves
01:59:22 <unb3k44n7> Goodnight.
01:59:25 <jle`> night unb3k44n7 :D
01:59:26 <arkeet> :t 5
01:59:28 <lambdabot> Num a => a
01:59:37 <tdammers> well, haskell does seem to subscribe to "if something can be a function, we probably want it to be one"
01:59:56 <Cale> noodles1: It surely doesn't. That matches the first pattern.
01:59:57 <tzaeru> come think of it, I'm still not *exactly* sure what "->" means in some haskell connotations. like "Int -> Bool".
02:00:14 <unb3k44n7> If I remember how to get back here. 
02:00:16 <jle`> a value of type (Int -> Bool) is a function that you can give an Int to, and get a Bool out of
02:00:17 <tdammers> tzaeru: imagine a non-operator constructor for functions :D
02:00:26 <tdammers> Int -> Bool ~ Function Int Bool
02:00:27 <Cale> tzaeru: Whenever A and B are types, A -> B is the type of functions which accept an argument of type A, and produce a result of type B
02:00:34 <mauke[> noodles1: it returns 
02:00:34 <mauke[> [([],[],5)]
02:00:36 <tzaeru> right. it shows the type of the function
02:00:39 <Cale> tzaeru: The -> type constructor associates to the right
02:00:46 <tdammers> Int -> Bool -> String ~ Function In (Function Bool String)
02:00:49 <Cale> So when we write A -> B -> C, it means A -> (B -> C)
02:00:55 <jle`> it has roughly the same role as, say, [] in [Int]
02:01:13 <arkeet> @let type Fun = (->)
02:01:14 <Cale> Correspondingly, function application associates to the left, so that f x y means (f x) y
02:01:15 <lambdabot>  Defined.
02:01:18 <arkeet> :t (+) :: Fun Int (Fun Int Int)
02:01:20 <lambdabot> Fun Int (Fun Int Int)
02:01:45 <jle`> :t even ::Fun Int Bool
02:01:46 <lambdabot> Fun Int Bool
02:02:19 <Cale> tzaeru: Every function in Haskell really takes exactly one argument, and those which appear to be functions of more parameters are really just producing other functions.
02:02:32 <jle`> [Int] is a "list of ints".  someone made the [] type constructor, and says, give me any type `a`, and i can give you the type of a list of those things, `[a]`
02:02:34 <arkeet> :t foldr :: Fun (Fun a (Fun b b)) (Fun b (Fun [a] b))
02:02:35 <lambdabot> Fun (Fun a (Fun b b)) (Fun b (Fun [a] b))
02:02:41 <Cale> @let add x y = x + y
02:02:42 <lambdabot>  Defined.
02:02:48 <Cale> @let addOne = add 1
02:02:50 <lambdabot>  Defined.
02:02:53 <Cale> > addOne 5
02:02:55 <lambdabot>  6
02:03:15 <MarceColl> wow, lambdabot is love
02:03:18 <arafangion> I actually think of functions taking a tuple are really functions taking multiple arguments.
02:03:33 <Cale> Well, they take exactly one argument which is a tuple. :)
02:03:38 <Cale> But yeah
02:03:39 <arkeet> nah, those take a single argument--that.
02:03:52 <jle`> they're used to model multiple arguments in other languages, though
02:04:02 <jle`> foo(bar, baz)   --- pass the function foo the tuple (bar, baz)
02:04:05 <jle`> it's all rather clever
02:04:13 <tdammers> for some values of "clever"
02:04:17 <arafangion> In python, they use a list and dict for their arguments.
02:04:26 <jle`> ruby uses hashes/dicts, yeah
02:04:35 <tdammers> fwiw, I've used hashmaps to emulate named args in haskell...
02:04:42 <noodles1> Cale, Mauke: ok thanks
02:04:45 <Cale> Of course, the compiler knows how to specialise things so that if you always fully apply a function, then all the arguments can be supplied at once without intermediate data structures representing functions being constructed.
02:04:52 <jle`> foo(x => 1, y => 2) --- call functio foo with the map {x => 1, y => 2}
02:05:13 <jle`> s/map/hash
02:05:19 <arkeet> @let (=:) = (,)
02:05:21 <lambdabot>  Defined.
02:05:43 <arkeet> uh
02:05:53 <tzaeru> need to one day find a bit more of time to spend on Haskell, mayhaps
02:06:01 <Cale> noodles1: The only way for comp to produce an empty list is if the second component of the triple it is given is a nonempty list (r:rs), and minSpace (r:rs) > len (where len is the third part of the triple)
02:06:02 <tzaeru> I think I forget 95% of what I learned when I only have an hour now and another then
02:06:10 <tzaeru> as can be expected.
02:06:52 <tzaeru> and I'm decently sure that my co-dev wouldn't appreciate me going to randomly make parts of our infrastructure code in Haskell..
02:06:55 <tzaeru> >:D
02:07:17 <arafangion> I think there's value in ensuring that everything's modular.
02:07:23 <tzaeru> "oh hi. yeah the publishing scripts are now Haskell. good luck! I'm going to have 3 week vacation now"
02:07:31 <tdammers> heh
02:07:35 <arafangion> tzaeru: Your co-dev should be inspired that parts of your infrastructure can be in haskell. ;)
02:07:38 <jle`> you know, your coworker is probably thinking the same thing too
02:07:41 * hackagebot term-rewriting 0.2 - Term Rewriting Library  http://hackage.haskell.org/package/term-rewriting-0.2 (BertramFelgenhauer)
02:07:47 <tzaeru> jle`, no I don't think he is.. :D
02:07:51 <jle`> and is like, "man, tzaeru wouldn't appreciate it if everything is haskell"
02:07:57 <jle`> "i better not learn haskell"
02:08:00 <arafangion> tzaeru: People at mine are thinking of doing similar with Go.
02:08:01 <jle`> deadlock
02:08:11 <tdammers> Go is like a slightly less shitty PHP
02:08:25 <tzaeru> I haven't yet had a time to look into Go, but from the descriptions, it seems pretty nice
02:08:26 <tdammers> meanwhile, I'm stuck with clojure here
02:08:32 <MarceColl> I want to work with haskell, I have to work with PHP everyday...
02:08:35 <tzaeru> tdammers, majority of what I do is actionscript.
02:08:35 <tzaeru> HA
02:08:44 <tdammers> well, I used to be a php dev
02:08:46 <merijn> MarceColl: Write haskell that generates PHP ;)
02:08:46 <arafangion> tdammers: But at least it's faster. ;)
02:08:47 <tzaeru> (though there's a bunch of python, c++, javascript etc mixed in)
02:08:48 <tdammers> ran away screaming
02:09:48 <tdammers> merijn: https://bitbucket.org/tdammers/hpaco/src/73751bbc25f84f1eee2fc75ddc1d68577ab536f0/hpaco-lib/Text/HPaco/Writers/PHP.hs?at=master
02:09:53 <tdammers> done
02:09:57 <krgn> hey, do I get this right? runProcess does not actually spawn a shell (but uses execve or something)?
02:10:01 <MarceColl> merjin: I don't think my boss would understand why I'm writing something my coworkers can't mantain :P
02:10:33 <MarceColl> merijn*
02:10:50 <tdammers> MarceColl: why would your boss hire people who are incapable of picking up a new programming language within a few weeks?
02:11:10 <jle`> budget
02:11:11 <tdammers> oh wait... real world, nm...
02:11:22 <MarceColl> tdammers: my coworkers struggle with understanding php :/
02:11:22 <arafangion> It sadens me that there is no Haskell on Debian DVD 1. :(
02:11:30 <arafangion> No haskell, nothing.  There's Ocaml, though...
02:11:33 <tdammers> MarceColl: everyone does. Even the PHP core devs.
02:11:55 <tdammers> arafangion: netinst, apt-get all the things?
02:12:03 <arafangion> tdammers: No internet yet. :(
02:12:06 <tdammers> oy
02:12:15 <MarceColl> tdammers, not in that way, we use drupal, so they have no idea how to program, I'm the only programmer here
02:12:30 <tdammers> drupal is php at its "best"
02:12:43 <arafangion> tdammers: Stupid Telstra. :(  Apparently they're having difficulty connecitng the line....  To an inner-city house right in the nation's capital.
02:12:51 <mauke[> wait, so your boss expects non-programmers to maintain programs?
02:12:54 <tdammers> drupal is like this shitty graphical programming language
02:13:03 <MarceColl> mauke[ nah, but at least to understand them
02:13:27 <MarceColl> mauke[, from time to time they change a couple of things in the templates
02:13:35 <tdammers> and basically everything in it is broken, plus because they chose to make it a graphical proglang, none of the standard tools work
02:13:52 <tdammers> so you can't use git, your fav text editor, pastebin, diff, nothing
02:14:11 <arafangion> You know...  The crazy thing with these "graphical" programming languages is...
02:14:39 <arafangion> If they just used standard electrical engineering theory, and did a bit of polishing up of existing electrical engineering projects...  They'd have a decent graphical language.
02:14:52 <MarceColl> tdammers, it's horrible, I'm now trying to put everything in VCS, but almost everything is in fucking database
02:14:55 <MarceColl> views, in a database
02:15:01 <MarceColl> content types, in a database
02:15:36 <MarceColl> versioning is a nightmare, I can't use a database dump to version this things, it's terrible
02:15:40 <arafangion> MarceColl: Ever tried to merge a graphical project? ;)  Still, could be worse.  Could be InstallAware.
02:15:59 <tdammers> MarceColl: I know. I've been there.
02:16:10 <MarceColl> I want to move production from a common server to local machine servers for every user
02:16:21 <mauke[> I've worked with a native windows program that loaded its screens from the database
02:16:26 <MarceColl> and syncronize it using git, but its a nightmare
02:16:39 <mauke[> (binary blobs that were serialized window structures)
02:16:39 <tdammers> I worked in a web dev shop until not too long ago, and they used drupal and one other CMS
02:16:48 <MarceColl> mauke[ wow
02:16:59 <tdammers> I said, OK, I'll give drupal a shot, you guys seem to love it, so how bad can it be
02:17:06 <MarceColl> really bad
02:17:08 <MarceColl> hahaha
02:18:05 <arafangion> There is always worse.
02:18:34 <tdammers> so yeah, I did what I usually did - d/l the code, install, read documentation, tinker
02:18:44 <MarceColl> yeah, here they love it too, I kind of understand, you can install some modules, plug them between them using some kind of black magic, change settings until it works how you want and you haven't touched a single line of code, which I guess it is the appeal for them
02:18:45 <tdammers> and basically nothing worked
02:18:47 <MarceColl> just not my thing
02:19:13 <tdammers> and everything was slow as molasses
02:19:25 <tdammers> so I escalated, asked co-workers for help
02:19:36 <arafangion> tdammers: Just ask business for a faster machine.
02:19:37 <tdammers> but they basically just kept saying you have to put up with all that shit
02:19:45 <tdammers> eh, the machine was plenty fast
02:20:00 <tdammers> 8-core Xeon, SSD RAID, fuckton of RAM, you name t
02:20:03 <arafangion> tdammers: It was how we got a hosted machine (had to be hosted), with 64 GB of RAM.
02:20:13 <arafangion> tdammers: Though it wasn't drupal.
02:20:20 <tdammers> so anyway
02:20:29 <tdammers> two weeks in, I said, buy me a book
02:20:37 <tdammers> found one named "Drupal for programmers" or sth
02:20:50 <tdammers> great, I thought, this'll explain stuff in a way that I can understand
02:20:55 <tdammers> yeah, but no.
02:21:22 <tdammers> it is a very small book, and the main message is "forget all you know about programming, and learn The Drupal Way first"
02:21:38 <MarceColl> yes, it's really slow, when I started here I was given a project that took 14 seconds on my local machine to load a page. I outputed the trace of all functions called, it was 8 million PHP function calls, for a single page load. I'm not kidding
02:21:58 <MarceColl> tdammers, wow, more like "How to convert a programmer to the drupal way"
02:22:25 <tdammers> yeah
02:22:38 <tdammers> it was then that I told my boss that I would not be touching any drupal projects
02:22:41 * hackagebot cef 0.1.0.0 - CEF log format  http://hackage.haskell.org/package/cef-0.1.0.0 (utdemir)
02:23:23 <arafangion> tdammers: Should've told him instead, that any drupal project you touch would stop being drupal. ;)
02:23:36 <tdammers> arafangion: no, you can't actually do that
02:23:54 <tdammers> you see, drupal is a complete OS written in PHP
02:24:19 <MarceColl> yup, it's a montser
02:24:23 <tdammers> and the people who wrote it did it because they don't understand how an OS works
02:24:29 <arafangion> tdammers: No modularisation whatsoever?
02:24:41 <tdammers> uhm, well...
02:25:01 <tdammers> let me put it this way
02:25:01 <bergmark> i wrote a drupal module once!
02:25:14 <arafangion> Ugh.
02:25:26 <MarceColl> I'm writing one right now :(
02:25:57 <arafangion> tdammers: I think I'm getting teh picture. :(
02:25:58 <tdammers> the usual way to do things in drupal is that you click through a bunch of butt-ugly screens with completely ridiculous labels everywhere, trying to reverse-engineer the underlying logic as you go, and basically just randomly changing things and checking whether what they do is what you want
02:26:05 <tdammers> but, plot twists:
02:26:28 <MarceColl> don't forget how the screens take ages to load for everything you have to touch
02:26:36 <tdammers> one, "checking what they do" takes forever and is non-deterministic, because drupal is dead slow and requires heavy caching
02:26:46 <tdammers> and as with everything, drupal sucks at doing caching right
02:27:07 <tdammers> so when you make a change, there is a 50% chance that what you see is not the result of that change, but of an earlier change
02:27:15 <arafangion> Sounds like it's something that ends up becoming a business investment.
02:27:36 <tdammers> and the other plot twist is that there is no "undo", nor versioning
02:27:41 * hackagebot profiteur 0.2.0.1 - Treemap visualiser for GHC prof files  http://hackage.haskell.org/package/profiteur-0.2.0.1 (JasperVanDerJeugt)
02:27:45 <tdammers> so whatever changes you make cannot easily be rolled back
02:27:48 <MarceColl> then you clean caches, it takes 40 seconds, it timeouts several times
02:28:06 <tdammers> and because they all happen in the database, and that database behaves in not-so-deterministic ways
02:28:16 <tdammers> you cannot easily port changes over to a different system
02:28:38 <tdammers> the only somewhat reliable way is to keep notes for everything you do, and then do it again on the production system
02:29:04 <tdammers> *some* modules support exporting and importing settings, but not all of them do, and the degree to which this works reliably varies wildly
02:29:37 <mauke[> what was the PHP project that reinvented diff/patch as a weird XML format?
02:29:40 <tdammers> and ofc you can't just copy the database over, because site-specific configuration, application configuration, and actual data are mixed happily
02:29:44 <MarceColl> well, the only way I've found is to write database update functions, the problem is that when you change something in drupal, you have no idea what drupal has modified in the db
02:29:58 <tdammers> MarceColl: yes, exactly
02:30:10 <arafangion> tdammers: Sounds like what confluence is becoming.  I only know confluence and notes, as "CMS" platforms.
02:30:31 <arafangion> tdammers: I can't even figure out how to use wiki markup anymore, you have to use their editor.
02:30:38 <tdammers> well, all that filled me with so much rage that I'm currently building a cms system myself as a side project
02:31:39 <arafangion> tdammers: I've had similar thoughts with the work systems, actually.
02:32:16 <tdammers> yeah
02:32:43 <tdammers> well, I've spent quite some time working with and on Bolt, which is orders of magnitude saner than drupal, but still pretty deep in php land
02:33:11 <arafangion> Is PHP still a feature?
02:33:14 <tdammers> and I've looked at a bunch of other CMS platforms more closely than I'd wish
02:33:20 <arafangion> I mean, do people still look for PHP solutions?
02:33:26 <tdammers> depends
02:33:30 <tdammers> well
02:33:50 <tdammers> they don't really look for PHP solutions, but they do want something that runs on their shitty $1/mo shared hosting
02:34:17 <arafangion> I've also wanted to make my own database/wiki solution, but meh.
02:34:26 <tdammers> plus, the only open-source CMS that I know of that isn't PHP and doesn't look completely amateurish is Django
02:34:39 <arafangion> Django has it's issues, though it's not toooo bad.
02:34:45 <tdammers> indeed
02:34:50 <tdammers> but hosting python is a pain
02:35:07 <arafangion> (But very, very easy to write slow sites in it - I've found it's not good for a REST service)
02:35:24 <tdammers> idk, django has quite a php-ish feel to it
02:35:48 <arafangion> One annoyance was that it claimed to be MVC.
02:36:04 <arafangion> But I could never quite work out how to separate the components.
02:36:17 <arafangion> The Django ORM is really, seriously, fundamental to the whole infrastructure.
02:37:42 * hackagebot memory 0.2 - memory and related abtraction stuff  http://hackage.haskell.org/package/memory-0.2 (VincentHanquez)
02:38:41 <arafangion> I don't like ORMs, in general, though.
02:38:56 <arafangion> Though I find it difficult to articulate why - many, many people seem to love them.
02:39:46 <MarceColl> Django makes easy to do things they thought about and really hard to do things they did not
02:40:26 <arafangion> MarceColl: I would agree with that, actually.  Which can be a good thing, really - so long as they're clear about what those are.
02:41:51 <tdammers> arafangion: django doesn't actually claim to be MVC - it just uses the terms "Model", "View" and "Controller" wrong
02:42:03 <arafangion> tdammers: That's probably how I got confused.
02:42:06 <tdammers> yes
02:42:25 <tdammers> and it's a bad thing to do, but at least they state quite clearly in their docs that they're not really doing MVC
02:42:49 <arafangion> And I deeply wished that the models weren't so tightly invovled with the database.  Imho, data from the database should be just that: Data.
02:42:54 <tdammers> ORMs, idk - the idea of mapping relational data to objects isn't fundamentally flawed IMO, but things like ActiveRecord are
02:43:31 <MarceColl> I don't dislike ORMs, but it has to be really transparent IMO
02:43:32 <arafangion> The concept's good, with ORMs, that is, but yeah, I'm not sure I've seen a good implementation. (Perhaps I've only seen the bad ones)
02:43:37 <tdammers> I prefer a database abstraction layer that represents relational things with native objects, and maps relational operations to native constructs
02:43:42 <arafangion> MarceColl: They rarely are, imho.
02:43:47 <arafangion> tdammers: Yes.
02:43:59 <arafangion> One database abstraction I really like, for instance, is Linq in C#.
02:44:06 <arafangion> But I would hestiate to call that an "ORM".
02:44:15 <tdammers> db.usersTable.getByID(23) // fine with me
02:44:28 <tdammers> db.usersTable.insert(user); // also fine
02:44:36 <tdammers> user.save(); // holy fuck please no
02:44:50 <arafangion> Exactly.
02:45:21 <arafangion> They also have their own peculiar form of metaclasses.
02:45:24 <tdammers> I guess the problem with the active record pattern is that it looks clever and elegant
02:45:28 <arafangion> (Which is common in python, sadly)
02:46:08 <tdammers> and you don't really see the problem with it until you've been in a situation where it kept biting you in just the wrong places
02:46:40 <tdammers> fwiw, I like how yesql does it
02:46:52 <tdammers> (clojure, but the concept would probably transfer to haskell easily)
02:47:15 <tdammers> (in fact, in haskell we could use QQ to embed the queries into the code)
02:47:24 <arafangion> I've actually wished we had liqn.
02:47:25 <arafangion> *linq
02:47:34 <arafangion> Though I've yet to progress to sql in haskell.
02:47:52 <tdammers> persistent isn't half bad
02:48:00 <tdammers> esqueleto is pretty impressive, even
02:48:09 <tdammers> bit of a learning curve though
02:48:23 <arafangion> Hmm, the yesql concept looks reasonable.
02:48:41 <arafangion> But do they provide an sql interpreter? (I wouldn't want to make that sql portable)
02:48:53 <arafangion> Yes, I've heard of esquetlo but haven't tried it yet.
02:48:56 <tdammers> no, they rely on the programmer to write the right kind of SQL
02:48:58 <arafangion> I want to get my haskell sorted out first. :)
02:49:06 <arafangion> Ah, so they have their own interpreter.
02:49:16 <tdammers> no
02:49:20 <tdammers> they don't have an interpreter
02:49:40 <arafangion> Oh, I misinterpreted you. :)
02:49:44 <tdammers> they just do some superficial parsing to pick up function names from the comments, and split the file into separate queries
02:49:58 <arafangion> It's a reasonable approach, I guess.
02:50:01 <tdammers> the queries are then just parametrized and sent to the DB as-is
02:50:13 <tdammers> it's pretty simple, actually, and I like that
02:50:30 <arafangion> Definitely an advantage.
02:50:32 <tdammers> but I'd like some sort of metaprogramming facility on top to avoid writing super redundant queries
02:50:44 <arafangion> ORM proponants say that's idiocy. And that it must be portable.
02:50:52 <arafangion> But I think it's good enough to merely have separation.
02:51:08 <tdammers> with a sufficiently powerful template language, you could make it portable if you really wanted
02:51:18 <tdammers> or you could just provide separate SQL files for each backend
02:51:24 <arafangion> (And it's not easy making use of even Django's ORM make use of, eg, Postgresql's data types)
02:51:26 <tdammers> if you really need to be that portable
02:51:40 <tdammers> but frankly, most real-world projects do not need to be portable
02:51:58 <arafangion> Yeah, I agree.
02:52:10 <arafangion> Using a single type of database isn't that bad.
02:52:21 <tdammers> if you do switch backends, it's usually because you have reached the scalability limits of your relational DB, and rewrite the entire storage code to use some NoSQL thing or a sharded solution or whatever
02:52:23 <arafangion> And the options always there to switch to a different one if you must, however unlikely that may be.
02:52:30 <arafangion> Indeed.
02:52:42 <tdammers> in a nutshell, use postgres until you know what you need
02:52:59 <tdammers> or maybe sqlite for quick prototyping
02:53:10 <tdammers> and then switch to postgres as soon as you're picking up speed
02:53:37 <arafangion> sqlite3's amazing, though remarkably slow.  You can script the postgresql database create/destroy operations easily enough.
02:54:29 <arafangion> I gotta have dinner - thanks for teh chat. :)
02:54:47 <arafangion> tdammers: If I come on again, I'll most likely do so as "Arahael" - I accentially used my old nick today.
02:55:25 <tdammers> np
02:55:26 <luzie> lmdb is nice for simple things
02:55:43 <tdammers> these days I usually jump right to postgres
02:56:05 <arafangion> luzie: I find that in corporate dev, it's better to use more well-known things.
02:57:43 * hackagebot cabal-rpm 0.9.6 - RPM packaging tool for Haskell Cabal-based packages  http://hackage.haskell.org/package/cabal-rpm-0.9.6 (JensPetersen)
03:07:30 <MarceColl> the views from the office are nice tho
03:07:43 * hackagebot inline-c 0.5.0.1 - Write Haskell source files including C code inline. No FFI required.  http://hackage.haskell.org/package/inline-c-0.5.0.1 (FrancescoMazzoli)
03:27:18 <jle`> thank you comonads http://i.imgur.com/M5JGnFA.png
03:29:30 <pacak> Comonad is just a comonoid in the category of endofunctors...
03:30:49 <jle`> doesn't mean i can't thank them for helping me do useful things :)
03:31:03 <jle`> anthropomorphisation is at the core of humanity
03:32:44 * hackagebot ihaskell 0.6.1.0 - A Haskell backend kernel for the IPython project.  http://hackage.haskell.org/package/ihaskell-0.6.1.0 (gibiansky)
03:37:45 * hackagebot ihaskell-rlangqq 0.2.1.1 - a rDisp quasiquote to show plots from Rlang-QQ in IHaskell  http://hackage.haskell.org/package/ihaskell-rlangqq-0.2.1.1 (gibiansky)
03:52:11 <srhb> jle`: How does that image relate to comonads?
03:53:38 <jle`> srhb: cokleisli composition was used to solve laplace's equation over various (fixed) dirichlet and neumann boundary conditions
03:54:21 <jle`> basically over the Store comonad
03:54:26 <srhb> Ah. :)
03:55:11 <jle`> getting it to work with nicely with neumann boundary conditions was an interesting puzzle
03:57:34 <srhb> Sounds interesting indeed.
03:57:39 <srhb> What are you plotting with?
03:57:55 <jle`> just octave, which uses gnuplot, so that's the boring part
03:58:01 <srhb> Aw. :)
04:07:46 * hackagebot ghc-prof-flamegraph 0.1.2.0 - Generates data to be used with flamegraph.pl from .prof files.  http://hackage.haskell.org/package/ghc-prof-flamegraph-0.1.2.0 (FrancescoMazzoli)
04:17:47 * hackagebot ghc-prof-flamegraph 0.1.2.1 - Generates data to be used with flamegraph.pl from .prof files.  http://hackage.haskell.org/package/ghc-prof-flamegraph-0.1.2.1 (FrancescoMazzoli)
05:17:50 * hackagebot machines-io 0.2.0.6 - IO utilities for the machines library  http://hackage.haskell.org/package/machines-io-0.2.0.6 (aloiscochard)
05:27:51 * hackagebot machines-directory 0.2.0.6 - Directory (system) utilities for the machines library  http://hackage.haskell.org/package/machines-directory-0.2.0.6 (aloiscochard)
05:39:07 <aloiscochard> working with GHC 7.10, `-Wall` enabled.. but I want my code to be backward compat with 7.8
05:39:23 <aloiscochard> so... is there a way to tell the linter to not warn for redundant import of `Control.Applicative`?
05:40:49 <xacktm> perhaps https://ghc.haskell.org/trac/ghc/wiki/Migration/7.10#GHCsaysTheimportof...isredundant ?
05:41:20 <merijn> aloiscochard: Depends on your linter...?
05:41:26 <merijn> aloiscochard: Or you mean GHC's import warning?
05:41:36 <merijn> If the latter, use CPP...
05:42:03 <aloiscochard> merijn: the latter, oh right I can make the import conditional using the preprocessor
05:42:06 <aloiscochard> thanks
05:42:11 <mauke[> wait, why does CPP silence the warning?
05:42:28 <merijn> mauke[: ifdef based on GHC version around the import
05:42:33 <mauke[> oh
05:42:37 <aloiscochard> because "I can make the import conditional using the preprocessor" :)
05:42:53 <mauke[> wow, that wasn't very clear from the docs
05:49:48 <mpickering> aloiscochard: A better solution might be to add an "import Prelude" to the bottom of your import list
05:51:00 <aloiscochard> mpickering: I must be missing something, as I don't see how that would solve the warning problem when compiling with 7.10?
05:51:30 <bergmark> aloiscochard: using the names qualified prevents the warning
05:52:15 <aloiscochard> I see, thanks bergmark 
05:52:51 <fvgvxmpv1> >> import Prelude hiding (...)
05:53:29 <mpickering> fvgvxmpv1: What do you mean? 
05:54:14 <fvgvxmpv1> mpickering, I assumed that is what you meant, when suggesting an explicit import of Prelude
05:55:01 <mpickering> no, that won't work with older versions of GHC as Prelude won't export the things you are trying to hide
05:55:10 <mpickering> you just add "import Prelude" and the warnings get silenced
05:56:35 <aloiscochard> I'm not sure yet which approach I prefer, at least with the ifdef I'm quite explicit about why this is needed (ghc version)
06:07:53 * hackagebot codex 0.3.0.2 - A ctags file generator for cabal project dependencies.  http://hackage.haskell.org/package/codex-0.3.0.2 (aloiscochard)
06:12:53 * hackagebot codex 0.3.0.4 - A ctags file generator for cabal project dependencies.  http://hackage.haskell.org/package/codex-0.3.0.4 (aloiscochard)
06:22:54 * hackagebot hspec-monad-control 0.1.0.0 - Orphan instances of MonadBase and MonadBaseControl for SpecM  http://hackage.haskell.org/package/hspec-monad-control-0.1.0.0 (bmjames)
06:30:20 <noodles1> This code does what I want it to do, however I think it could be improved. Specifically lines 14 to 32 http://lpaste.net/133045
06:31:04 <noodles1> I don't think I'm taking advantage of functions like fold, map and filter. Any advice?
06:33:25 <mpickering> noodles1: Can you describe what it's mean to do?
06:39:17 <noodles1> Its part of a nonogram solver specifically the part that computes all possible valid rows. The part I'm most concerned with is the comp function which receives a tuple of type ([Bool], [Int], Int) ; (Line, restrictions to add to the line, length)
06:40:14 <noodles1> comp ([], [1,1], 5) gives [([True,False],[1],3),([False,True,False],[1],2),([False,False,True,False],[1],1)]
06:41:59 <mpickering> what is a valid row?
06:44:00 <noodles1> well children nodes are calculated through comp, the bt function takes comp and another function isSolution as an argument to check which of the generated rows are valid possible solutions
06:46:09 <noodles1> ([], [1,1], 5) the [1,1] means there are two sequences of marked cells of length 1 (represented by True in a list of booleans), they must be seperated by a blank cell
06:47:13 <noodles1> so all the valid rows with length 5 and restrictions [1,1] are: [[True,False,True,False,False],[True,False,False,True,False],[True,False,False,False,True],[False,True,False,True,False],[False,True,False,False,True],[False,False,True,False,True]]
06:50:29 <mpickering> Do you have a function of type f :: Int -> [Int] -> [Bool] -> Bool
06:50:58 <mpickering> which decides when given an n, restriction, row whether the row is valid
06:51:49 <mpickering> Then can't you (1) Generate all possible rows and (2) filter out all invalid rows
06:52:05 <noodles1> mpickering: very similar it's "isSolution :: ([Bool], [Int], Int)  -> Bool"
06:53:03 <noodles1> i feel the 'problem' is in the comp function, lots of guards and recursion, i'm not sure how but I want to think all that cruft could be replaced with a map
06:53:07 <mpickering> That function can't do that as it is only true for one argument?
06:56:02 <noodles1> right, well it's used in the backtracking algorithm along with comp
06:57:38 <bergmark> i was also working on a nonogram solver at some point :-)
06:57:49 <noodles1> line 16 checks if theres no restrictions left but the length is larger than zero, which means that blank cells (Falses) should be padded to the end of the line
06:57:56 * hackagebot serf 0.1.1.0 - Interact with Serf via Haskell.  http://hackage.haskell.org/package/serf-0.1.1.0 (IanDuncan)
06:58:42 <noodles1> line 19 checks that theres enough space left in the line to add the remaining restrictions, if not it return an empty list
07:00:03 <noodles1> line 20 specifically looks for the case where ([True,False,False,False,True,False],[],-1)] would be created and instead returns ([True,False,False,False,True],[],0)] instead
07:00:50 <beckyconning_> why are functions like filterM are useful and what they would be used for? i'm really unsure what the (a -> m Boolean) bit of forall m a. (Monad m) => (a -> m Boolean) -> [a] -> m [a] would actually be.
07:01:07 <noodles1> and there's more checking on lines 27 through 32, basically a bunch of junk, there's gotta be a smoother solution
07:01:17 <noodles1> bergmark: did you finish it?
07:01:59 <mpickering> noodles1: Did you try the method I suggested? I don't know if it will be too slow
07:02:00 <kadoban> beckyconning_: You understand what it would be without the 'm' parts?
07:02:20 <mpickering> Have you seen richard bird's sudoku solver? You might also be able to get inspiration from that
07:02:58 <mniip> beckyconning_, filterM doesFileExist listOfFiles
07:02:59 <beckyconning_> kadoban: i think so, like i know what a regular filter does like (\x -> x < 3) `filter` [1,2,3,4,5]
07:03:31 <kadoban> beckyconning_: It's the same thing except with added effects. You can base your check of   'a' on a State that you build up from the previous values, you could log certain values as you go, you could do IO in there and use that to determine if a value is good or bad, etc.
07:03:45 <mauke[> @hoogle doesFileExist
07:03:46 <lambdabot> System.Directory doesFileExist :: FilePath -> IO Bool
07:03:59 <mniip> wait is that a real function name? :o
07:04:03 <mauke[> yes
07:04:15 <beckyconning_> that makes a lot of sense : ) thanks!
07:04:36 <kadoban> beckyconning_: If you do NICTA, there's an exercise in there where you use it to build up a list of distinct values, for instance. Sure, 'welcome.
07:05:20 <noodles1> mpickering: ok, I'll try to frame the problem that way, thanks
07:05:41 <merijn> mniip: Except that doesFileExist is pretty useless
07:06:01 <bergmark> noodles1: i tried to do as much as possible without backtracking and gave up when I ran out of heuristics :)
07:06:01 <mniip> true
07:06:06 <merijn> "doesFileExist" should be renamed to "iLikeDebuggingTOCTOUraces"
07:06:29 <mniip> well there still are use cases
07:06:35 <merijn> mniip: Like?
07:06:35 <noodles1> bergmark: oh yea, this is very slow, i'm also new to haskell so I'm using this to learn the language
07:07:07 <mniip> merijn, like offloading the race condition onto the user
07:07:47 <mniip> much like test does
07:07:53 <mniip> I mean [
07:10:16 <maerwald> can someone explain to me how Debug.Trace maintains purity without forcing IO to the function type?
07:10:45 <Haskellfant> maerwald: unsafeperformIO
07:10:46 <mauke[> it uses unsafePerformIO
07:10:49 <maerwald> ouch
07:11:10 <mauke[> @quote chromatic
07:11:10 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
07:11:14 <kadoban> IOW, it doesn't (maintain purity)
07:14:53 <merijn> maerwald: It doesn't, Debug.Trace is unsafe, hence why it's a debug tool and not for writing code
07:18:02 <maerwald> not sure what you mean with "not for writing code", but I figured it's a debug tool...
07:19:11 <merijn> maerwald: i.e. "if you have Debug.Trace in whatever you're deploying you're fishing for pain"
07:19:44 <maerwald> I think that is quite obvious
07:19:49 * eacameron wonders what his username is
07:19:58 * eacameron now knows
07:20:08 <ion> eacameron: ~Elliot_Ca
07:20:31 <eacameron> ion: I don't understand?
07:21:06 <ion> eacameron: Your nickname is eacameron, your username is ~Elliot_Ca and your hostname is cpe-74-137-135-67.kya.res.rr.com. That’s the basic information in your whois.
07:21:25 <ion> Your realname is purple
07:21:36 <eacameron> ion: never used that before! cool
07:21:56 <eacameron> no idea where purple came from
07:22:11 <ion> Your client probably uses libpurple and advertises that fact in the default realname for some reason.
07:22:21 <eacameron> ion: indeed it does
07:23:56 <geekosaur> that's standard behavior for libpurple, yes
07:25:28 <eacameron> so I had a real question: cabal: I want to build the same cabal project with two different compilers simultaneously (32-bit and 64-bit) but cabal's internal state seems to shoot that possibility down. Ideas?
07:25:49 <eacameron> *internal state meaning "configure state"
07:26:00 <dcoutts> eacameron: no, you can separate that state
07:26:07 <eacameron> dcoutts: no way!
07:26:11 <dcoutts> and so have multiple configurations/builds
07:26:40 <eacameron> dcoutts: Where can I learn of this wondrous feature?
07:26:45 <dcoutts> eacameron: see the --help, but it's --builddir= for each command
07:26:54 <manjunaths> Hello
07:27:09 <dcoutts> eacameron: ie for configure, build, copy, register (or install for all-in-one)
07:27:22 <eacameron> dcoutts: Ahhh. I didn't realize "builddir" represented all that state
07:27:25 <dcoutts> eacameron: has to be for all, since otherwise it looks in the default location for its state
07:27:45 <manjunaths> Is anyone around who has tried to write a shell based on haskell here?
07:28:09 <eacameron> manjunaths: try hell
07:28:25 <manjunaths> eacameron, Did you write hell ?
07:28:42 <eacameron> manjunaths: no; sorry I thought you were just looking for an implementation
07:28:54 <eacameron> dcoutts: much thanks
07:29:13 <manjunaths> eacameron, Ah...I was wondering if anyone who has done it was around.
07:30:40 <benzrf> is there a good haskell library for symbolic rewriting
07:31:12 <benzrf> basically something that can do algebra
07:31:27 <benzrf> ideally on user-supplied syntax trees
07:43:19 <quchen> I should remember not to read r/programming comments when Haskell comes up.
07:43:24 <benzrf> lol
07:43:50 <quchen> "Haskell thunks are a form of laziness because 'a' might be a value or a thunk"
07:44:00 <quchen> s/laziness/state/
07:45:02 <c_wraith> to be fair, laziness *is* a form of mutable state.
07:45:11 <c_wraith> But only at the implementation level.
07:45:23 <c_wraith> From a semantics point of view, it's all just a value.
07:45:43 <c_wraith> Things like GC actually do care about the implementation level, though.
07:45:49 <quchen> Haskell isn't an implementation. Haskell implementations are implementations.
07:46:31 <c_wraith> I mean..  call-by-need is inherently a form of mutation.  And no haskell implementation has ever chosen call-by-name.
07:46:51 <merijn> c_wraith: Why is it inherently a form of mutation?
07:47:24 <quchen> And suppose you marked all thunks as non-updatable, you would not even have that form of implementation state.
07:47:37 <bennofs> the performance of memoization implementations depends on the implementation of laziness by using thunks (or at least, a laziness implementation that memoizes already-evaluated expressions). I think a lot of Haskell code would be too slow to use if you had an implementation that didn't memoize "thunks"
07:47:39 <quchen> Would be horribly inefficient of course.
07:47:41 <c_wraith> merijn: because evaluating an expression in call-by-need must replace *something* with the result of the evaluation - otherwise it's call-by-name.
07:47:59 <mauke[> this is important, though
07:48:32 <mauke[> Okasaki explains why you need laziness to get good performance in the presence of persistent data structures
07:48:57 <bennofs> mauke[: not only laziness, but call-by-need, no?
07:49:06 <c_wraith> Okasaki meant as opposed to call-by-value.
07:49:16 <mauke[> bennofs: isn't that the same thing?
07:49:18 <c_wraith> Call-by-name is trivial to show terrible performance. :)
07:50:01 <ion> There seems to be a law that given an interesting Haskell-related talk on the Internet, edwardk is either the speaker or he’s in the audience making insightful comments.
07:50:02 <mauke[> (the interesting part is that strict/call-by-value also has bad performance)
07:50:41 <johnw> "edwardk laughter" is the Where's Waldo? of the 21st century
07:51:30 <quchen> ion: Counterexample, https://www.reddit.com/r/programming/comments/36ppx0/ocaml_403_will_if_all_goes_well_support_multicore/
07:52:14 <silver> "Once it's out and stable hopefully I'll be able to leave Haskell"
07:52:15 <silver> rude
07:53:16 <johnw> "Haskell's problem is that it has very low mechanical sympathy."  It's problem?  It's why I'm here.
07:53:39 <quchen> I have no idea what mechanical sympathy is.
07:53:51 <johnw> I think people have been overrating concern about operational details for a loooong time
07:54:14 <quchen> If it's "being close to the machine", then I don't know any other popular higher language besides C that has "mechanical sympathy".
07:54:53 * Clint chuckles.
07:56:18 <RyanGlScott> I've got a question for someone who's familiar with GHC's typechecker.
07:56:30 <RyanGlScott> There's a comment in GHC about how to infer instance contexts here: http://git.haskell.org/ghc.git/blob/9f968e97a0de9c2509da00f6337b612dd72a0389:/compiler/typecheck/TcDeriv.hs#l179
07:56:45 <RyanGlScott> How does this change when you introduce mutually recursive datatypes into the equation?
07:57:05 <RyanGlScott> e.g., data One a = One (Two a) deriving Eq; data Two a = Two (One a) deriving Eq
07:57:36 <RyanGlScott> Would you have to compute two least fixed points simultaneously to solve this?
07:57:59 * hackagebot network-uri-static 0.1.0.0 - A small utility to declare type-safe static URIs  http://hackage.haskell.org/package/network-uri-static-0.1.0.0 (snak)
07:58:00 <merijn> RyanGlScott: I don't see why you would?
07:58:14 <nshepperd_> i intuit that that will fail with some kind of error
07:58:28 <merijn> This works, but the only valid value of type One and Two is bottom
07:58:36 <RyanGlScott> merijn: Sorry, let me rephrase: would GHC have to compute two least fixed points simultaneously?
07:59:05 <merijn> RyanGlScott: Which fixpoint would it have to compute?
07:59:26 <RyanGlScott> I'm basing it off of the example given in the GHC source code:
07:59:39 <maerwald> silver: he has some points, laziness also has downsides. Whether they are that terrible, I probably don't agree, though
07:59:41 <RyanGlScott> data T a b = C1 (Foo a) (Bar b) | C2 Int (T b a)  | C3 (T a a) deriving Eq
08:00:06 <RyanGlScott> First, it would comput Eq (Foo a) U Eq (Bar b) U (T b a) U Eq Int U Eq (T a a)
08:00:28 <nshepperd_> oh, it works, huh
08:00:37 <RyanGlScott> This simplies to Eq a U Eq b U {} U {} U {}...
08:01:12 <RyanGlScott> It would be more complicated if you have an instance context like Ping b => Eq (Bar b), though
08:01:18 <merijn> RyanGlScott: Where are all the empty sets coming from?
08:01:46 <RyanGlScott> merijn: I'm referencing this comment from the GHC source code: http://git.haskell.org/ghc.git/blob/9f968e97a0de9c2509da00f6337b612dd72a0389:/compiler/typecheck/TcDeriv.hs#l228
08:01:58 <merijn> I'm looking at that comment, albeit it shortly
08:02:23 <merijn> The fix point comes from the "Eq/Show" ability of the recursive children depending on derived types
08:02:31 <RyanGlScott> I'm guessing that we don't know the instance context of T at that stage in the fixed-point calculation, so we fill in an empty set.
08:03:24 <RyanGlScott> In the next stage, we've inferred Eq a U Ping b, so we fill in that for T's instance context instead of {}
08:03:35 <merijn> RyanGlScott: "Eq (One a) = Eq (Two a)" and "Eq (Two a) = Eq (One a)"
08:03:38 <RyanGlScott> Repeat until an iteration gives the same result
08:04:15 <merijn> Which one step later becomes "Eq (One a) = Eq (One a)" and "Eq (Two a) = Eq (Two a)", done
08:04:54 <merijn> (replace the constraint from the start with the indirect constraints, which is then trivially true)
08:06:09 <RyanGlScott> So if you had this instead:
08:06:16 <RyanGlScott> data One a = One a (Two a) deriving Eq; data Two a = Two a (One a) deriving Eq
08:06:42 <RyanGlScott> Then it would be "Eq (One a) = Eq a U Eq (Two a)" and "Eq (Two a) = Eq a U Eq (One a)"
08:08:50 <RyanGlScott> -> "Eq (One a) = Eq a U Eq a U Eq (One a)" and "Eq (Two a) = Eq a U Eq a U Eq (Two a)"?
08:09:54 <merijn> RyanGlScott: That's how I understand the process, yes
08:10:08 <merijn> And of course "Eq a U Eq a" simplifies to "Eq a"
08:10:58 <RyanGlScott> merijn: So, if I'm understanding it right, you would have to the least fixed points for One and Two simultaneously at each stage.
08:12:57 <merijn> RyanGlScott: Why simultaneously?
08:13:06 <OutlawStar> whats the best way to essentially do a selective map, meaning iterative over a list and only map specified types, resulting in a list of only the mapped values
08:13:23 <merijn> OutlawStar: "map f . filter p"?
08:13:49 <quchen> … or mapMaybe
08:13:50 <RyanGlScott> merijn: The use of the word "and" in the pseudocode.
08:13:50 <OutlawStar> but filter would not inform the compiler that you will only get type x in the map
08:13:51 <quchen> :t mapMaybe
08:13:53 <lambdabot> (a -> Maybe b) -> [a] -> [b]
08:14:08 <RyanGlScott> It seems like you'd have to know that "Eq (Two a)" simplified to "Eq a U Eq (One a)" in the second step, which you calculated in the first step.
08:14:20 <kritzcreek> :t lift maybe
08:14:21 <lambdabot> MonadTrans t => t ((->) b) ((a -> b) -> Maybe a -> b)
08:14:24 <merijn> OutlawStar: A list can only include one type of value, so how does that matter?
08:15:20 <merijn> OutlawStar: At every iteration you just expand all constraints into the constraints of that type and continue until you don't change anymore
08:15:21 <zedik> privet
08:15:23 <merijn> eh
08:15:31 <OutlawStar> ie I have a list of type Node, a Nod can be NodeElement or NodeContent. I only want to map the  NodeElement
08:15:31 <merijn> s/OutlawStar/RyanGlScott
08:15:52 <kritzcreek> how would I use maybe to handle a Maybe value that is wrapped in a Functor?
08:16:10 <merijn> [x | x@NodeElement{} <- myList]
08:16:26 <merijn> kritzcreek: fmap the partially applied maybe function
08:16:45 <merijn> OutlawStar: Try that list comprehension
08:17:07 <merijn> @let data Node = NodeElement Int | NodeContent Int
08:17:09 <lambdabot>  Defined.
08:17:21 <RyanGlScott> merijn: What I meant to say is that you couldn't compute One's instance context without knowledge of the LFP computation for Two.
08:17:27 <merijn> :t \f xs -> [f x | x@NodeElement{} <- xs]
08:17:29 <lambdabot> (Node -> t) -> [Node] -> [t]
08:17:37 <RyanGlScott> merijn: e.g., if you had data One a b = One a (Two a b) deriving Eq; data Two a b = Two b (One a b) deriving Eq
08:17:46 <merijn> RyanGlScott: There is only one fixpoint
08:17:52 <OutlawStar> merijn: I don't think list comp would let me drop values, correct?
08:17:55 <merijn> RyanGlScott: You don't assume the fixpoint for Two has been computed
08:18:02 <merijn> OutlawStar: It does, try
08:18:31 <RyanGlScott> merijn: Sorry, I'm probably butchering the semantics a bit.
08:18:51 <RyanGlScott> merijn: If you attempted to compute the LFP without knowledge of Two, then it would go something like:
08:19:02 <merijn> > let xs = [NodeElement 1, NodeElement 2, NodeContent 2]; f (NodeElement i) = i+1 in [f x | x@NodeElement{} <- xs]
08:19:05 <lambdabot>  [2,3]
08:19:19 <RyanGlScott> Eq (One a b) = Eq a U Eq (Two a b) = Eq a U {} = Eq a
08:19:32 <merijn> RyanGlScott: No
08:19:36 <RyanGlScott> i.e., you'd have to know that Eq (Two a b) gives you an Eq b constraint at some point
08:19:45 <merijn> RyanGlScott: You can just expand Two with the constraint of Two
08:20:02 <merijn> RyanGlScott: You use the exact same recursive step on all elements
08:20:22 <haskell004> Hey guys, could you take a look at this? http://lpaste.net/133052
08:20:24 <RyanGlScott> merijn: OK. Then at what point do you stop recursing?
08:20:37 <merijn> RyanGlScott: When the result doesn't change (i.e. no new expansions)
08:20:44 <merijn> RyanGlScott: That's the entire definition of a fixpoint :)
08:21:32 <merijn> RyanGlScott: Once you expand Two you get a bunch of new constraints and one is just "Eq (One a b)" again, which you already had on the right hand, so you can ignore that
08:22:36 <RyanGlScott> merijn: So are you combining all of the constraints from One and Two into the same set?
08:22:54 <tsahyt> I'm trying to convert a bytestring into a vector of colors (which are basically 4 Word8s), but somehow my function has horrible memory performance. http://lpaste.net/5315242708514635776 Does anyone know what the cause for this is? I've even tried rewriting it with the ST monad and mutable vectors but I get the same problem.
08:23:36 <RyanGlScott> merijn: I was treating them separately in my mind, which might be the source of my confusion.
08:24:02 <merijn> RyanGlScott: Yes
08:24:03 <Cale> tsahyt: Define "horrible memory performance"
08:24:08 <lpaste> kritzcreek pasted “maybe Handler” at http://lpaste.net/133053
08:24:21 <merijn> RyanGlScott: Because to get a set of constraint for One you MUST have constraints for Two too
08:24:22 <tsahyt> For a 1024*1024 element byte string, it uses about 480mb of memory
08:24:41 <merijn> RyanGlScott: Because if an element inside One isn't Eq/Show/whatever the entire thing can't be
08:24:53 <RyanGlScott> merijn: OK, that makes sense. Thanks!
08:24:59 <jacereda> I'm trying to pretty-print a deeply-nested record using Text.Show.Pretty.ppShow but it ends up printing everything in a single line... Anyone knows what am I missing? This is what I have: spy :: Show a => a -> a     spy a = trace (PP.ppShow a) a
08:24:59 <jacereda>  
08:25:00 <Cale> tsahyt: Measured using top?
08:25:03 <OutlawStar> merijn: that sorta worked, but I still have the compiler complaining about unmatched patterns which is what I was trying to avoid
08:25:16 <merijn> OutlawStar: It does? That sounds unlikely
08:25:19 <ion> tsahyt: I wonder if you could get stream fusion to happen by just replacing the go invocation with “build go” and making go take cons and nil as parameters instead of using (:) and []?
08:25:21 <Cale> tsahyt: How are you compiling the program?
08:25:40 <merijn> OutlawStar: Oh, you mean in the definition of 'f'?
08:25:44 <tsahyt> Cale: According to the stats of the GHC runtime. I'm compiling with -O2
08:25:45 <OutlawStar> yes
08:25:48 <merijn> OutlawStar: Well, obviously...
08:25:54 <kritzcreek> merijn: It still doesn't work... can you maybe take a look at my paste? it's a fairly short piece of code
08:26:00 <merijn> OutlawStar: 'f' doesn't handle all possible constructors
08:26:04 <kritzcreek> http://lpaste.net/133053
08:26:20 <merijn> kritzcreek: What's the error?
08:26:23 <saulzar_> Hmm. I'm having some type class issues - trying to use   unwrapReceivable from https://github.com/mstksg/ghcjs-websockets/blob/master/src/JavaScript/WebSockets/Internal.hs.   It's insisting that my type should also be (in addition to WSReceivable a) also Binary a. Some trickery with whatever undecidable instances the library is using. Anyone know what might be going on there?
08:26:33 <OutlawStar> merijn: ahh I guess I wasn't clear initially, I was wondering if there was a way to avoid that easily and the best possible way to do that
08:26:41 <merijn> kritzcreek: Also, I have no clue what the types of incorrectBody/initGame is
08:26:54 <Cale> tsahyt: That's the maximum residency, or the total allocation?
08:27:09 <merijn> OutlawStar: The simplest solution is to add a "catchall" pattern "f _ = error "not implemented""
08:27:11 <saulzar_> jle`, Are you there?
08:27:18 <Cale> tsahyt: It's totally reasonable that your program does about that much allocation, given the data structures you're using.
08:27:19 <merijn> OutlawStar: Which will obviously crash if it's ever run
08:27:25 <isBEKaml> Hi, out of curiosity - has anyone re-implemented redis functionality in haskell? 
08:27:33 <merijn> kritzcreek: But I have to run now, so can't look into it
08:27:33 <OutlawStar> merijn: thats a good idea, thx
08:27:41 <isBEKaml> I see hedis on hackage, but that requires a working connection to redis daemon
08:27:45 <isBEKaml> (I think)
08:27:47 <Cale> tsahyt: But it wouldn't be reasonable for that amount of live memory usage
08:28:06 <merijn> OutlawStar: If you wanna be smart annotate which function and line, so that if it ever DOES crash you at least know where the error is from
08:28:41 <OutlawStar> merijn: is there a compiler annotation to do that?
08:29:12 <jacereda> maybe I'm having an XY problem... what do you guys use to pretty-print deeply-nested records?
08:30:16 <tsahyt> Cale: I've been looking at "Total memory in use" for that figure. According to heap profiling, the function still uses about 10x the input size in memory though. Considering that this is basically just a copy operation, I think it should be possible to bring that down a lot.
08:31:21 <Cale> Well, you're building these intermediate linked lists of boxed Word8 values
08:32:20 <Cale> If you avoided doing the BS.unpack, I bet you'd save a bunch of space
08:32:24 <Cale> Or at least allocation
08:33:13 <isBEKaml> I guess my question is - purely out of curiosity, how would I go about implementing a key-value store in haskell, when I don't have ready access to redis?
08:33:16 <tsahyt> Cale: I'm unpacking only 4 elements at a time. Does this really have such a large impact?
08:34:09 <ion> jacereda: http://hackage.haskell.org/package/groom
08:34:29 <Cale> tsahyt: Well, unless I'm missing something, there's no reason for your program to use much more than the total memory for the input and result.
08:34:58 <jacereda> ion: thanks, will try that
08:35:14 <ion> Does GHC store a record of four {-# UNPACK #-} !Word8s in a compact way?
08:36:09 <ion> Or is tsahyt getting a 40-byte record?
08:36:12 <jacereda> ion: same result, all the record fields in a single line
08:36:20 <Cale> It ought to actually unbox them.
08:36:21 <tsahyt> Cale: I tried hardcoding a vector of similar size to avoid the use of this one function and it brought total memory usage down from 480MB to 35MB, which would be absolutely acceptable
08:36:49 <ion> I mean, are the Word8s still 64 bits in size?
08:37:12 <Cale> Maybe we should avoid V.fromList
08:37:44 <ion> tsahyt: Did you try using build? I’m curious about whether list fusion helps here.
08:38:16 <tsahyt> ion: I've started to look up what you meant but I didn't get very far yet. I'm not really familiar with build or stream fusion.
08:39:35 <navaati> hi
08:40:17 <navaati> is there a way to run a sub Parsec parser with a different state type, inside a bigger parser
08:40:18 <navaati> ?
08:41:17 <navaati> something like :: Parsec s u1 a -> u1 -> Parsec s u2 a ?
08:45:38 <lpaste> Cale pasted “tsahyt try this” at http://lpaste.net/133054
08:45:49 <Cale> tsahyt: ^^
08:46:55 <Cale> Better? Worse? :)
08:46:59 <Cale> Same?
08:47:23 <Cale> I guess I could write some code to see for myself, but I assume you already have some
08:48:03 <tsahyt> Surprisingly, it's worse.
08:48:07 <Cale> heh
08:48:32 <bitrauser> Hi everyone, what would be the easiest way to send a simple string through HTTP POST?
08:48:40 <exio4> I think a strict vector should help there
08:49:10 <navaati> bitrauser: not sure it the simplest, but there is a libcurl binding
08:49:49 <bitrauser> navaati: you mean Network.Curl?
08:50:29 <Cale> tsahyt: It's hard to tell what's wrong when we can't see the rest of your program
08:50:46 <navaati> bitrauser: in the curl package, yeah
08:51:28 <bitrauser> ok thank you, I'm gonna take a look at it
08:52:21 <navaati> bitrauser: hum, wait a minute, i think the HTTP package might be more haskellish
08:52:34 <navaati> depends on if you already know curl well
08:53:01 * hackagebot gitlib 3.1.0.2 - API library for working with Git repositories  http://hackage.haskell.org/package/gitlib-3.1.0.2 (JohnWiegley)
08:53:03 * hackagebot gitlib-test 3.1.0.3 - Test library for confirming gitlib backend compliance  http://hackage.haskell.org/package/gitlib-test-3.1.0.3 (JohnWiegley)
08:53:05 * hackagebot gitlib-libgit2 3.1.0.5 - Libgit2 backend for gitlib  http://hackage.haskell.org/package/gitlib-libgit2-3.1.0.5 (JohnWiegley)
08:53:07 * hackagebot gitlib-cmdline 3.1.0.2 - Gitlib repository backend that uses the git command-line tool.  http://hackage.haskell.org/package/gitlib-cmdline-3.1.0.2 (JohnWiegley)
08:53:57 <bitrauser> navaati: hm I don't really know any of them yet, I'm new to haskell as well as networking in general
08:54:41 <navaati> bitrauser: then use the HTTP package, it'll teach you more haskell
08:56:04 <Cale> tsahyt: I just tested both your rgbVec and mine on a 1024*1024 byte input, and mine did less allocation, and both ran in about the same amount of total space, which was 49 MB total memory in use. (24 MB max res)
08:56:22 <Cale> tsahyt: What else does your program do?
08:56:51 <ion> tsahyt: http://lpaste.net/5315242708514635776
08:57:04 <bitrauser> navaati: ok, Network.HTTP it is, then, thank you
08:57:27 <tsahyt> Cale: That's strange. Well it does raytracing mostly. This is part of loading textures which are then wrapped into a closure with a texture lookup function, which is then used in shading.
08:58:04 <Cale> In fact, a lot of that residency was apparently the list which I was packing in order to make the input bytestring :P
08:59:04 <Cale> using BS.replicate instead, it's down to 21 MB total memory
08:59:21 <tsahyt> ion: According to heap profiling with -hc this is about the same as the original function.
08:59:24 <Cale> (with only 17 MB total allocation)
08:59:47 <albeit> I'm using criterion, and one of the tests forks a thread that fully evaluates a value. However, the test seems to be taking into account the time to evaluate that value... why is that?
08:59:49 <Cale> So I think the culprit is not this function if you're seeing lots of space usage
08:59:50 <tsahyt> Cale: How are you evaluating the full vector?
09:01:22 <shapr> RevJohnnyHealey: It was nice to meet you last night!
09:02:05 <shapr> RevJohnnyHealey showed me his project https://github.com/revnull/noisefunge last night, it's really nifty.
09:02:40 <RevJohnnyHealey> shapr: It was nice to meet you as well.
09:03:26 <shapr> RevJohnnyHealey: noisefunge needs screenshots
09:04:11 <Cale> tsahyt: I was just computing the length of the vector originally. seq'ing all the elements doesn't change much either though.
09:04:58 <RevJohnnyHealey> shapr: I actually just recently set things up to start making music videos: https://www.youtube.com/watch?v=9zObiWi4Mbw
09:04:58 <saulzar_> Hm. I have a case where if my function returns a pair, no problem. If my function returns a record, I get issues with class constraints. 
09:06:46 <Cale> tsahyt: Same for computing the sum of the elements.
09:06:54 <Cale> (as Word8's)
09:09:07 <tsahyt> Cale: But if the problem was elsewhere, then replacing rgbVec input with some hardcoded V.Vector Color of equivalent size shouldn't make much of a difference, at least not if everything gets fully evaluated.
09:09:08 <saulzar_> Can anyone shed light what might be going on here? http://lpaste.net/133056
09:09:20 <lpaste> Cale pasted “Here, try it yourself :)” at http://lpaste.net/133057
09:09:31 <karlpinc> Once I've done a "cabal install foo" and installed foo locally, how do I run it?
09:10:58 <Cale> saulzar_: what's the type of WS.unwrapReceivable?
09:11:10 <shapr> RevJohnnyHealey: gotta link that on the github page
09:11:22 <humanoyd> Is there a function that zips two lists into a Map?
09:11:28 <indiagreen> saulzar: I assume SocketMsg is a Text
09:11:32 <indiagreen> ouch
09:11:35 <indiagreen> ^ saulzar_
09:11:52 <Cale> saulzar_: Also, there's no way that you've implemented Functor for SocketEvents such that the fmap will be the same as the one for pairs
09:11:54 <shapr> RevJohnnyHealey: have you seen http://yaxu.org/tidal/ ?
09:12:13 <saulzar_> class WSReceivable s   where  unwrapReceivable :: SocketMsg -> Either SocketMsg s
09:12:23 <indiagreen> saulzar_: and the docs say that there are 2 instances for WSReceivable: “Binary a => WSReceivable a” and “WSReceivable Text”
09:12:28 <Cale> In particular,  fmap WS.unwrapReceivable $ e  will be applying the WS.unwrapReceivable function to the second component of the pair, that is, the Event t a value
09:12:34 <saulzar_> I don't think I've implemented Functor for SocketMessage at all
09:12:43 <Cale> er, sorry, I'm backward :)
09:12:45 <karlpinc> I'm running debian wheezy and installed the ghc and haskell-platform packages.  Then did "cabal update".  Then "cabal --version", which reports 1.14.  Then "cabal install cabal", but "cabal --version" still says 1.14.
09:12:57 <Cale> It's applying it to the Event t SocketMsg in any case
09:12:58 <Cale> hmm
09:13:02 <saulzar_> Er, Sorry for SocketEvent
09:13:11 <saulzar_> Yeah, event is the functor
09:13:20 <geekosaur> karlpinc, prepend $HOME/.cabal/bin to $PATH
09:13:22 <Cale> Yeah, I misread everything :)
09:13:54 <karlpinc> geekosaur: Thanks, but there is no $HOME/.cabal/bin dir.
09:13:55 <bezirg> hi, I have a kind of stupid question: if I do sth like: filter (>0) [x+y-z, k+y-z], would Haskell (ghc) employ any graph-reduction for the common subexpression "y-z" or would I have to manually do memoization?
09:13:55 <saulzar_> It's something crazy going on with whatever undecidableinstances the library is using, I think
09:14:15 <Cale> saulzar_: hmm
09:14:22 <geekosaur> acrtually "cabal install cabal" probably corrected to "Cabal" (the library). you wanted cabal-install
09:14:29 <saulzar_> indiagreen, Yeah.. and it has decided that I'm using Binary somehow
09:14:36 <karlpinc> geekosaur: Ah.  Thanks.
09:14:38 <geekosaur> (historical thing, the Cabal library predates the cabal executable by many years)
09:14:53 <indiagreen> saulzar_: no, it has decided that the result can either be Text or something Binary a
09:15:05 <tsahyt> humanoyd: Not that I know, but it's pretty easy to define. zipMap x = Data.Map.fromList . zip x
09:15:50 <tsahyt> humanoyd: Then zipMap :: Ord k => [k] -> [a] -> M.Map k a, which is what you want as far as I understand
09:15:59 <saulzar_> indiagreen, Why does it give me an error about Binary though? I've still left it open to both WSReceivable instances, I thought
09:16:14 <RevJohnnyHealey> shapr: I had not seen that one before, but it looks pretty interesting.
09:16:20 <Cale> saulzar_: Do your instances mention Binary?
09:16:54 <saulzar_> Cale, Nothing in my code mentions Binary, only some instances in the library (ghcjs-websockets)
09:17:26 <ion> bezirg: CSE isn’t guaranteed, you should be explicit if you need it.
09:17:30 <karlpinc> Now for my real issue.  :-)  I want to run the latest darcs.  But if I "cabal install darcs" it tells me 2 regexp libs will break (regex-posix-0.95.1 and regex-compat-0.95.1, and now, it seems Cabal-1.22.3.0) and a --force-reinstalls is required.  This sounds like a bad idea.  I do have the debian darcs package installed (and would like to keep in installed).  How should I proceed?
09:17:30 <Cale> derp, there's an instance Binary a => WSReceivable a
09:17:33 <saulzar_> In particular instance Binary a => WSSendable a where
09:17:37 <Cale> That's bad
09:17:37 <hectortrope> Hi all
09:18:15 <Cale> File a bug against this library for having derpy instances which overlap with absolutely everything :D
09:18:33 <Cale> {-# LANGUAGE IncoherentInstances #-}
09:18:42 <saulzar_> Hm. Alright. I'll have jle`  on about it :)
09:19:10 <Cale> It's important to realise that the instance selector doesn't see class constraints on instances
09:19:11 <geekosaur> {-# LANGUAGE IncomprehensibleInstances #-}
09:19:20 <hectortrope> Why do many nicks in this room??
09:19:44 <Cale> So  instance Binary a => WSSendable a  looks to the instance selector like  instance WSSendable a
09:19:46 <exio4> instance C1 a => C2 a where looks/feels wrong
09:19:50 <Cale> i.e. "you can always pick this instance"
09:20:15 <Cale> and only once it selects it, will it then enforce the class constraint
09:20:28 <bezirg> ion: how can I be explicit? with memoization or a let?
09:20:33 <hectortrope> Hi I want to learn a new programming language so i am here...how haskel if different from others can any one tell me?
09:21:22 <ion> bezirg: What’s the difference? :-P When you give a thing a name and it gets evaluated, it’s kept in memory as long as the name is in scope.
09:21:27 <saulzar_> Hmm, and why might it chose to select it in one place but not the other?
09:21:37 <karlpinc> hectortrope: I'm no expert, but see haskell.org for details.
09:22:03 <saulzar_> Or is it pretty arbitrary... it could always do this? Even for Text for example
09:22:09 <Cale> hectortrope: Well, Haskell is a pure functional programming language, meaning that expression evaluation in Haskell has no effects other than to compute the result, and I/O is handled separately from evaluation. Evaluation in Haskell is lazy, which means that it is done in an outermost-first manner, rather than innermost-first like most programming languages. This lets you work with infinite datastructures pretty easil
09:22:09 <Cale> y.
09:22:14 <bezirg> bezirg: u r right
09:22:17 <bezirg> ion: u r right
09:22:51 <Cale> hectortrope: Haskell is statically typed, with a type system that is a good deal more expressive than most programming languages (though there are some research languages and proof assistants with richer type systems)
09:23:21 <shapr> RevJohnnyHealey: great music, I'm amazed you got anything that sounds so good out of anything related to befunge
09:23:48 <Cale> hectortrope: Which languages are you already familiar with?
09:24:50 <hectortrope> Cale: Python & ruby & bashbut i am not perfect in them too
09:25:08 <schell> what would be a more efficient (smaller, faster access) in-memory store a list or a vector or…?
09:25:18 <hectortrope> I am from non-It background who is very interested in programming
09:25:25 <hectortrope> java also very little I know
09:25:34 <hectortrope> Cale: 
09:25:37 <navaati> hey, i'm wondering, the 'many' combinator in parsec return a list in the same order as the parsed items. That means that the last item appended (well, prepended really) to the list is the first parsed item. Isn't this horribly inefficient ?
09:25:56 <Cale> hectortrope: Ah, okay, so it's very very different from all of those :)
09:26:19 <Cale> hectortrope: http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html -- this course is a good place to begin learning Haskell
09:26:23 <Welkin> navaati: no, because a list grows from left to right
09:26:33 <Welkin> consing onto a list is an O(1) operation
09:26:46 <Welkin> er, a list grows from right to left*
09:26:53 <Cale> > [1..] -- an infinite list
09:26:55 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:27:09 <oconnore> hectortrope: one of the major differences is that once you learn how it works, the Haskell compiler can tell you a lot about what is wrong with your program
09:27:11 <navaati> Welkin: yeah, but the input is parsed from left to right !
09:27:13 <hectortrope> Cale: https://www.haskell.org/documentation I am checking that tahnsk for ur link
09:27:24 <hectortrope> so should I start with ur link it takes 12weeks 
09:27:31 <johnw> navaati: you can always do a single reverse at the very end
09:27:41 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
09:27:43 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
09:27:48 <Cale> ^^ another infinite list
09:28:07 <hectortrope> Cale:  oconnore  Can I use haskel for web developement like django and rails and fpr software developmenet like c++??
09:28:08 <navaati> like, "foreach input token t, do (acc = acc ++ [t])", which is inefficient
09:28:19 <Welkin> hectortrope: I use it for web development
09:28:23 <Welkin> using yesod or scotty
09:28:24 <Cale> hectortrope: Sure, there are some nice web frameworks for Haskell
09:28:26 <hectortrope> Welkin:  how?
09:28:32 <hectortrope> names plz
09:28:33 <Welkin> what do you mean how?
09:28:36 <johnw> navaati: reverse (foreach input token t, do acc = t:acc)
09:28:39 <Welkin> look up YEsod and Scotty
09:28:42 <Cale> Snap, Happstack, Yesod, Scotty, and some others even :)
09:29:07 <Cale> What does FPR stand for?
09:29:08 <navaati> johnw: this is inefficient as well, because then you can't consume tokens as they are parsed, right ?
09:29:08 <Welkin> Scotty is a microframework like sinatra
09:29:18 <Welkin> Yesod is a batteries-included framework like rails
09:29:36 <johnw> navaati: you always have immediate access to the 't' after it is parsed within the Parser; and you have access to the list after the `many' is done
09:29:45 <navaati> Cale: Functionnal Peactive Rogramming, i guess ?
09:29:57 <Cale> Oh, maybe it was a typo of "for"
09:29:58 <hectortrope> Ok if you guys plz don't mind any famous website ?/ Co haskel is very new name to me and i wonder 1550+ nicks
09:30:00 <johnw> what you don't have access to is the "list up until now", if you use many
09:30:26 <Welkin> hectortrope: what?
09:30:45 <hectortrope> website developed in haskel frameworks
09:30:48 <Welkin> hectortrope: http://www.yesodweb.com/
09:30:51 <hectortrope> like github in rails
09:30:55 <Welkin> hectortrope: why does that matter?
09:31:01 <ollef> navaati: `many p` produces a list that gives you the first parse result as its head, which is the same order that you can consume the list
09:31:34 <hectortrope> Welkin:  ok no problem Thanksa lot
09:31:41 <navaati> ollef: ah, seen this way… now i'm confused
09:32:00 <athan> Hey guys, I'm trying to do something pretty trivial - Find the location of some token in a file (via parsing or regular expression), then "take" all the content up-to that position, and push it somewhere else. I've been thinking about using conduit, but I'm not sure if it's the right decision - Data.Conduit.Attoparsec, for instance, emits line and column numbers for the found token, but I'm not sure if that's the right kind of "position" I need. Any ideas 
09:32:00 <athan> or advice?
09:32:05 <navaati> all in all, is it possible to use Parsec and many to parse in O(1) memory ?
09:32:16 <Cale> hectortrope: I don't know about famous... Facebook has some Haskell development going on, but obviously their webserver isn't written in Haskell
09:32:44 <Cale> hectortrope: skedge.me is a company I worked for a while ago, and we implemented their web application backend in Haskell
09:33:38 <athan> navaati: I've heard Attoparsec has a low memory footprint, but I have no idea :\
09:33:57 <Welkin> athan: so you need a buffer to hold the processed data until you run into the token, then copy the buffer to some output, then continue processing
09:34:07 <exio4> navaati: if you extremely fast parsing, then I think attoparsec may be what you want :P 
09:34:28 <Welkin> attoparsec is fast, but doesn't include helpful errors when something goes wrong
09:34:38 <monochrom> navaati: no, the list it builds already takes linear memory. and it has to build the whole list, and confirm that there is nothing more to slurp up, before letting you move on.
09:34:42 <exio4> that's the tradeoff 
09:35:05 <athan> Welkin :\
09:35:06 <Cale> hectortrope: This web application is written in Haskell as well, https://prasava.com/
09:35:12 <hectortrope> Cale:  what I feel is Haskel is for researchers and enthusiasists but not for job searching guys right?
09:35:20 <navaati> exio4: oh, it's not really about being fast in the numbers (it's a toy project for school), more about being able to find out what it does :)
09:35:31 <athan> hectortrope: You're right
09:35:31 <navaati> monochrom: oh, right, ok. thanks
09:35:34 <Welkin> athan: what do you mean "move"? You would need to have a separate output, otherwise your program would never terminate
09:35:35 <johnw> hectortrope: not completely right
09:35:37 <Cale> hectortrope: Well, it's not impossible to get a job programming in Haskell.
09:35:50 <geekosaur> there are Haskell jobs out there, mostly at financial institutions that tend to be quiet about their internal technologies
09:36:08 <athan> Welkin: Yes you're correct, I'm just abusing terminology
09:36:11 <geekosaur> that said, lots of places will count Haskell experience as a positive because it makes you a better programmer in pretty much any language
09:36:32 <Welkin> for job hunting, haskell will not help you
09:36:48 <athan> Welkin: I'm planning on using conduit as the buffer
09:36:49 <Welkin> most places don't care about haskell, they only care about their [f;avor of the week language]
09:36:55 <Welkin> flavor*
09:37:02 <athan> weak*
09:37:04 <athan> :P
09:37:09 <Welkin> although I use haskell in my own work, but I work for myself
09:37:23 <geekosaur> I have specifically had a number of places ask if I was interested because I have Haskell experience and am a maintainer for one of the better known Haskell packages (xmonad)
09:37:34 <Welkin> I choose to use haskell because it is the best tool I have found
09:37:39 <navaati> geekosaur: hey, does that mean that haskell is big money or nothing ^^ ?
09:37:41 <hectortrope> Welkin:  you mean to say haskel is very strong language?
09:37:55 <athan> hectortrope: Definitely
09:37:56 <hectortrope> I am searching for very strong language actually i don't need job
09:37:59 <athan> just under appreciated
09:38:04 <Welkin> yes
09:38:07 <geekosaur> well, the financial places tend to also want Ph.Ds >.>
09:38:10 <Welkin> haskell makes al ot of things very easy
09:38:14 <Welkin> a lot*
09:38:16 <navaati> geekosaur: erf :)
09:38:23 <JagaJaga> I have function (_name). But getting `Found hole ‘_name’`. Using the same part of code in ghci is ok...
09:38:41 <hectortrope> but why its not as famous like c+= or Java when its very powerfu;l sorry I am not talking low just questioning
09:38:42 <athan> JagaJaga: Then your functiion is actually a type varaible
09:38:49 <athan> (and in the wrong place :P)
09:38:57 <Welkin> hectortrope: because it is different from what people learn in school
09:39:07 <Welkin> and people are afraid of things that are different
09:39:10 <JagaJaga> athan: well. it a lens, and I use it widely in my other parts of code :/
09:39:12 <Welkin> they think it is "too hard"
09:39:20 <athan> JagaJaga: Are you sure it's not after :: ?
09:39:24 <hectortrope> Welkin: I am not IT guy a mechanical engineer I didn't learn any language in svchool so i know less 
09:39:28 <athan> JagaJaga: Hmm... can I see the code?
09:39:31 <monochrom> navaati: to avoid accumulating the list, you may like my http://www.vex.net/~trebla/haskell/parsec-generally.xhtml#yield-intro
09:39:39 <navaati> well, to be honest, haskell *is* hard. but it's worth it
09:39:51 <Welkin> hectortrope: haskell is actually very easy to understand, since it is closer to mathematics than any imperative language
09:39:52 <athan> it's the best :)
09:39:58 <hectortrope> Welkin:  In my case i like things which are different
09:40:08 <JagaJaga> athan: ok, wait a bit.
09:40:09 <navaati> monochrom: oooh, neat !
09:40:10 <karlpinc> hectortrope: And because people use what they are used to.  Which is why everybody's still using the x86 architecture.
09:40:19 <athan> JagaJaga: right on :)
09:40:29 <Cale> hectortrope: Yeah, Haskell isn't in the top 20 for languages that employers are going to demand, but it's a much nicer language for getting things done in than any of the ones in that list, imo :)
09:40:50 <Welkin> hectortrope: one lesson here is that things are not popular because they are the best, they are populatr because they are popular
09:41:00 <Welkin> most times, the most popular thing is *not* the best
09:41:26 <navaati> monochrom: uh oh, continuations… brain melting incoming
09:41:33 <Haskell101> http://lpaste.net/1224703984514629632
09:41:33 <monochrom> :)
09:41:48 <Haskell101>     Expecting one more argument to ‘TLTree’     Expected a type, but ‘TLTree’ has kind ‘* -> *’     In the type signature for ‘geraSierp’:       geraSierp :: Tri -> Int -> TLTree
09:41:55 <athan> navaati: More like kan extensions! :D
09:41:55 <Haskell101> can anyone help ?
09:42:09 <karlpinc> hectortrope: I'd say haskell is easy to use but hard to master.
09:42:21 <JagaJaga> athan: https://gist.github.com/ae3557ff27e438d67b94 + https://github.com/ctlab/gShell . Problem is related to 30:128 of gist
09:42:22 <maerwald> Welkin: I don't think haskell is close to mathematics
09:42:35 <monochrom> yeah I basically use "ContT r Parsec" or "ParsecT (Cont r)" to subvert the control flow of parsec so we can do some incremental things.
09:42:37 <Cale> Haskell101: Well, which type of elements does your TLTree contain?
09:42:50 <Cale> geraSierp t         0 = Tri t
09:42:53 <athan> monochrom: That is awesome :o
09:43:02 <monochrom> hehe
09:43:17 <Cale> If t has type Tri, then Tri t :: TLTree Tri
09:43:44 <Cale> Haskell101: It's confusing that you've named both a type synonym and a data constructor Tri
09:43:53 <JagaJaga> athan: loading only mkNodes in ghci is working ok :/
09:44:08 <athan> JagaJaga: wtf? Man this is weird. Can I see the error too?
09:44:14 <Cale> Haskell101: This is allowed because types and values live in different namespaces
09:44:18 <athan> I don't think type holes can happen at the value level lol
09:44:33 <hectortrope> Hey guys any one know computational fluid dynamics?/  Most of it's probles are solved in c++ or pthon or matlab etc......I wonnder this haskel can do easily as it is much like maths as someone said but I don't know
09:44:35 <athan> JagaJaga: (also what's gShell? :D)
09:44:39 <JagaJaga> athan: https://gist.github.com/jagajaga/af3d3859193ee022a0e0
09:44:43 <Haskell101> Cale: trying to make an answer and be more specific
09:45:03 <JagaJaga> athan: oh, well. I'm trying to make a persistent shell. My bachelor's project :)
09:45:14 <Cale> Haskell101: You ought to be able to delete the type signature for geraSierp and ask ghci what the type of it ought to be, by the way
09:45:23 <athan> JagaJaga: Heck yeah :)
09:45:28 <JagaJaga> athan: and also with a function to regenerate files. Like automatik makefiles
09:45:28 <Cale> Haskell101: i.e. just load the code and type  :t geraSierp
09:45:38 <athan> JagaJaga: this sounds foolish, but maybe wrap _name with (_name)?
09:45:52 <athan> hmm!
09:45:55 <JagaJaga> athan: no help.
09:46:01 <athan> blast
09:46:08 * geekosaur smells lens internals...
09:46:10 <Cale> oh, of course, the rest of the code has similar problems :S
09:46:17 <athan> that is really strange
09:46:29 <athan> geekosaur: ...beefy
09:46:40 <JagaJaga> athan: in `src/Gshell/State.hs` I use it a lot and no problems.
09:46:44 <athan> JagaJaga: What if you alias it to `foo = _name`?
09:46:50 <athan> er wait
09:46:56 <athan> I think it has to be name_..?
09:46:58 <athan> right?
09:47:07 <Cale> Haskell101: It looks like maybe you wanted to define   data TLTree = Tri Tri | Nodo TLTree TLTree TLTree
09:47:13 <Haskell101> Cale: so if i define a type i can only use it inside of the data context ? THe constructor it would be only the one from TLTree ?
09:47:14 <athan> hmm
09:47:25 <JagaJaga> athan: https://gist.github.com/jagajaga/f3f9a0735f844d11b686
09:47:27 <hectortrope> Cale:  Welkin  I decided to learn haskel and sure ur were not telling it's very powerful because u were haskel fans right coz I can't spend 12 weeks if it's not useful for me sorry if I am harsh or rude...time is more valuable so i am spending some time to research more on it from its experts
09:48:03 <JagaJaga> athan: no, it's `_name` (it's not mine, it's from System.Directory.Tree library)
09:48:15 <Haskell101> Cale: my idea was to define that yes
09:48:15 <athan> JagaJaga: This is so strange...
09:48:25 <Haskell101> Cale: but can i do that definition directly ?
09:48:25 <athan> I'm a noob at lens, so I'm not sure how much help I'll be
09:48:32 <lpaste> Cale annotated “TLTree” with “TLTree (annotation)” at http://lpaste.net/1224703984514629632#a133061
09:48:34 <athan> hectortrope: haskell is best
09:48:35 <athan> :|
09:48:44 <albeit> Does criterion use a single core? If I fork a thread in a test, will criterion wait until that thread is complete before it declares the test complete?
09:49:01 <Cale> Haskell101: ^^ I edited your code slightly. It looks like you didn't intend for TLTree to have a type parameter
09:49:08 <athan> JagaJaga: but also look at the spacing you have, too
09:49:16 <athan> `foo._name`
09:49:26 <athan> maybe that has something to do with it?
09:49:43 <hectortrope> athan:  among python java ruby haskel and c++ can you plz rate 
09:49:51 <Cale> Haskell101: that code now compiles
09:49:51 <barrucadu> JagaJaga: Where is _name being imported from?
09:49:55 <athan> Haskell is best :|
09:50:02 <ion> hectortrope: 42
09:50:13 <JagaJaga> barrucadu: https://hackage.haskell.org/package/directory-tree-0.12.0/docs/System-Directory-Tree.html
09:50:16 <athan> hectortrope: it's far more correct than the other languages, faster, more consise
09:50:18 <hectortrope> hahah ion  what does it mean?
09:50:24 <athan> ion++
09:50:30 <Haskell101> Cale: i'm giving it a look ;) thanks btw
09:50:38 <kadoban> hectortrope: What useful answer are you actually expecting at this point?
09:50:46 <arkeet> JagaJaga: that error means nothing called _name is in scope
09:50:47 <barrucadu> JagaJaga: You're not importing that module in your gist
09:51:02 <athan> :O
09:51:12 <hectortrope> ZI want to know how much u guys rate coz I wish haskel is number one coz i decided to learn it
09:51:12 <athan> v_v derp
09:51:17 <JagaJaga> arkeet: barrucadu: fu*. That's it :D
09:51:22 <noodles1> Cale: Since you're so kind as to correct peoples code, would you mind having a look at line 14 to 32  http://lpaste.net/133045 ; I'm really unhappy with that code although it works, I'm sure there's a much simpler way
09:51:23 <arkeet> lol
09:51:27 <hectortrope> kadoban: 
09:51:29 <athan> hectortrope: be the haskell
09:51:34 <athan> you are the haskell
09:51:39 <JagaJaga> athan: D;
09:51:46 <humanoyd> tsahyt: thx
09:51:47 <JagaJaga> Thank you guys :)
09:51:56 <athan> JagaJaga: Get that bachelor's :)
09:52:01 <Cale> noodles1: What does this program do?
09:52:08 <kadoban> hectortrope: Well, get to the learning part and figure it out yourself. I just can't imagine what response you're hoping to receive really …
09:52:10 <JagaJaga> athan: thank you :)
09:52:21 <hectortrope> athan:  I have few goal in next 23 years now I am working as system admin and python developer but I want to develop own CFD software and also build one own gaming website 
09:52:32 <hectortrope> not 23
09:52:35 <hectortrope> 2-3yrs
09:52:48 <athan> hectortrope: Haskell took me about 1 year to learn
09:52:55 <hectortrope> too hard?
09:52:55 <athan> but it's worth it
09:52:59 <athan> nah
09:52:59 <Cale> noodles1: If you ever need anything bigger than a pair, you probably ought to define your own data type.
09:53:07 <athan> hectortrope: it pays off
09:53:16 <athan> I don't have to think about mutex locks or crappy code
09:53:42 <maerwald> hectortrope: haskell is hard to learn and hard to master
09:53:43 <hectortrope> athan:  but now u can do anything like building any software etc? one year too much coz it took 15 days for poython and  15 more for ruby
09:53:46 <Cale> noodles1: What do these values of type ([Bool], [Int], Int) represent?
09:53:53 <athan> hectortrope: Definitely
09:53:58 <JagaJaga> hectortrope: *facepalm*
09:54:00 <athan> @hackage nested-routes
09:54:00 <lambdabot> http://hackage.haskell.org/package/nested-routes
09:54:03 <athan> ^ hectortrope
09:54:05 <noodles1> Cale: that's part of a Nonogram solver, it generates rows based on their length and restriction. For example generateRow 5 [1,1] will generate the 6 possible valid rows that are of length 5 and have two sequences of 1 marked cell
09:54:05 <athan> I wrote that
09:54:24 <athan> JagaJaga: :P
09:54:34 <athan> young padawan...
09:54:40 <noodles1> Cale: (Line, Line Restrictions, Length)
09:55:10 <karlpinc> hectortrope: There are other languages with more hotness in academia.  But haskell has a community and a library set that let you actually build something real and you don't get that with the very latest language-of-the-day.
09:55:17 <JagaJaga> athan: hectortrope: haskell in 2-3 weeks is like c++ in 21 days.
09:55:29 <miun> hectortrope, by CFD you mean computational fluid dynamics?
09:55:31 <athan> that's the same count...
09:55:41 <athan> :|
09:55:49 <noodles1> *Main> generateRow 5 [1,1] gives [[True,False,True,False,False],[True,False,False,True,False],[True,False,False,False,True],[False,True,False,True,False],[False,True,False,False,True],[False,False,True,False,True]]
09:55:52 <JagaJaga> athan: I mean that that's impossible
09:55:53 <athan> okay I need to stop, my brain is already wrecked dog
09:56:05 <athan> oh!
09:56:27 <athan> hectortrope: Have patience and discipline, it will pay off
09:56:29 <athan> learn haskell
09:56:31 <hectortrope> miun:  yes
09:56:34 <maerwald> JagaJaga: C++ in 21 days should be possible without mastering it
09:56:48 <noodles1> *Main> comp ([True,False], [1], 3) gives [([True,False,True,False],[],1),([True,False,False,True,False],[],0),([True,False,False,False,True],[],0)]
09:56:58 <athan> @learn hectortrope
09:56:58 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
09:57:06 <athan> ^ bookmark that
09:58:02 <hectortrope> athan:  but i am already 25 if I spend one year for it when i really can become software developer?/
09:58:13 <hectortrope> ok athan  i will try to spend 30mins daily
09:58:20 <athan> hectortrope: trust me
09:58:21 <athan> I'm 23
09:58:39 <hectortrope> athan:  you are younger than me and you have lot of age more to develop
09:58:46 <athan> hectortrope: You'll be more efficient with haskell
09:58:47 <hectortrope> miun:  u know CFD??
09:58:52 <athan> productive-wise
09:58:52 <hectortrope> ok athan 
09:59:06 <athan> ...that's 2 years man cman :|
09:59:16 <karlpinc> hectortrope: And I'm 53.  Haskell will teach you a lot more about programming.
09:59:32 <hectortrope> karlpinc:  Thanks
09:59:32 <miun> hectortrope, no, I don't, just the acronym, as QCD
10:00:02 <miun> (and others, btw)
10:00:32 <hectortrope> can some one check this website?/ http://www.hanleyinnovations.com/ This is my dream than programming 
10:00:44 <JagaJaga> hectortrope: try idris or agda after that to increase your knowledge.
10:01:00 <miun> hectortrope, it sounds hard and fascinating
10:01:05 <hectortrope> idris or agda means?
10:01:42 <ion> hectortrope: Re: 15 days for Python and 15 for Ruby, you’re talking about learning almost the same language you already know over and over again with slight variations. It’s only those variations you had to learn, not the entire language from scratch. Haskell has more variations to what you already know, thus it will take more time to learn.
10:02:12 <ReinH> hectortrope: that's not something you're going to be able to do in 15 days
10:02:22 <hectortrope> Got it
10:02:25 <ReinH> 15 days is barely enough time to learn anything
10:02:31 <hectortrope> 15 days means only syntax etc I mean
10:02:48 <hectortrope> mastering syntax etc
10:02:56 <JagaJaga> hectortrope: in haskell you have to think in other manner
10:03:06 <hectortrope> ok understood
10:03:07 <JagaJaga> hectortrope: that was the hardest for me
10:03:12 <karlpinc> hectortrope: There's some serious semantics to learn.
10:03:28 <hectortrope> I understood now why it's not fanmous
10:03:29 <JagaJaga> hectortrope: but that style of thinking helps me now a lot
10:03:33 <hectortrope> its very hard
10:03:42 <hectortrope> hardest than Java or c++?
10:03:54 <hectortrope> ok JagaJaga  Cool
10:03:56 <digitalmentat> it's not "very hard" I don't like that air people keep promulgating about Haskell
10:04:00 <digitalmentat> it's hard, no doubt
10:04:04 <ion> C++ is really complex.
10:04:05 <JagaJaga> hectortrope: sure, but after haskell you can write in java or c++ better that others
10:04:13 <digitalmentat> but so was your first programming language
10:04:24 <ion> Learning C++ with no previous programming experience is not easy either.
10:04:49 <digitalmentat> Haskell as a language is so different that you're learning many new concepts and new ways of programming that it's almost like coming at programming as a beginner again
10:05:01 <hectortrope> Ok guys so should I start with http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures/01-intro.html?
10:05:18 <Cale> hectortrope: yeah, probably
10:05:20 <hectortrope> digitalmentat:  yes i am a beginner
10:05:24 <digitalmentat> it took me about two years to become an intermediate programmer that was proficient in Haskell and every week I used it, it got better
10:05:36 <hectortrope> Cale:  but its just 12 week course right?
10:05:42 <noodles1> ion: is C harder or easier than C++ for a first language?
10:05:54 <digitalmentat> noodles1, C is definitely easier
10:05:56 <ion> “C++ is easy to learn but Haskell is difficult (because I know Java)” is like “Haskell is easy to learn but C++ is difficult (because I know ML)”.
10:05:58 <maerwald> don't learn C++ before C :P
10:06:00 <Cale> hectortrope: Yeah, and you might go faster or slower than that. Feel free to ask questions in here.
10:06:09 <JagaJaga> noodles1: C is definetly harder.
10:06:26 <digitalmentat> lol it definitely isn't
10:06:27 <JagaJaga> digitalmentat: noodles1: you have to know a lot about memory
10:06:37 <digitalmentat> and you don't in C++?
10:06:44 <hectortrope> ok Sure I will start Haskel from first week oj June..Till Then i will finish my other works
10:06:50 <monochrom> I do not recommend arguing over what is harder to learn.
10:06:51 <JagaJaga> digitalmentat: in C++ you have std::vector at least
10:07:02 <Haskell101> Cale: if i want to define as data TLTree a = L a | N (TLTree a,(TLTree a,TLTree a)) so i can generalize this a catamorphism, how could i define a as Tri ?
10:07:17 <digitalmentat> mix in templates and the nightmare of other features in C++ I think it's much more difficult to become proficient in C++
10:07:19 <noodles1> digitalmentat: I'm just trying to figure out if he meant all the C++ additions like STL, lambas, etc. are hard or memory management
10:07:25 <hectortrope> Any one know  "Problem Driven Learning" It doesn';t apply to Haskel?
10:07:34 <Cale> Haskell101: Then you want to use the type  TLTree Tri
10:07:39 <digitalmentat> hectortrope, I think that's the best way to learn Haskell actually
10:07:44 <JagaJaga> digitalmentat: we are talking about the beginning
10:08:00 <monochrom> but Haskell is harder to learn than Algol at the "hello world" beginning.
10:08:23 <monochrom> in Algol, you only need to know the print command and string literals.
10:08:31 <hectortrope> Soory Guy I forgot and its my last question for sure ...any hackers here? haskel also a hackers supportive language like they can build own security tolls etc?
10:08:39 <monochrom> in Haskell, you need to know one more thing: >>=
10:08:51 <Haskell101> Cale: instead of ad ?
10:09:02 <noodles1> digitalmentat: arguably c++ is easier for a beginer because of things like iostreams and vectors, which don't make people just learning have to worry about dynamically reallocating memory or dealing with c strings
10:09:05 <Cale> Haskell101: what?
10:09:19 <hectortrope> digitalmentat:  mean take real problem and trying to solve in haskel than starting with books?
10:09:37 <digitalmentat> noodles1, possibly but that's more to load into your head which increases the learning overhead
10:10:06 <Haskell101> Cale: i would replace a for Tri ?
10:10:13 <Cale> Haskell101: TLTree is being defined as a type constructor in that case. For each type a, the type TLTree a is a type of trees of values of type a
10:10:14 <noodles1> digitalmentat: but i agree after the begining c++ has a lot of stuff, small percentage of C++ really understand the language deeply
10:10:24 <kadoban> hectortrope: You should learn basic haskell first. Use this guide: https://github.com/bitemyapp/learnhaskell
10:10:37 <Cale> Haskell101: So, if you use the type TLTree Tri, the trees will have values of type Tri at the leaves.
10:11:06 <Cale> Haskell101: If you use the type TLTree String, they'll have Strings, etc.
10:11:37 <noodles1> s/of C++/of C++ programmers/
10:11:54 <miun> I've learned bits of haskell here http://learnyouahaskell.com/ (and went no further). is it a good text?
10:12:12 <johnw> yay, just migrated another utility from conduit to pipes
10:12:12 <Cale> miun: It's okay, some people like it better than others.
10:12:48 <ion> miun: http://bitemyapp.com/posts/2014-12-31-functional-education.html has some good comments about books such as that one.
10:13:09 <miun> ion, thanks. bookmarked
10:15:18 <Haskell101> Cale: so if i use TLTree a = L a | N (TLTree a,(TLTree a,TLTree a)) i would need a data constructor for Tri right ?
10:15:59 <Cale> Haskell101: what?
10:16:26 <Haskell101> Cale: TLTree it would be a tree that have a Leaf a  (my case  Leaf of Tri)
10:16:43 <Haskell101> but my tree it's just a type Tri = (Point, Side)
10:16:52 <Haskell101> but my Tri sorry xD
10:17:22 <Haskell101> if i define as TLTree a = L a | N (TLTree a,(TLTree a,TLTree a))  i would nee a constructor so i could have a TLTree Tri
10:17:31 <Cale> Even though Tri is a type synonym, you're allowed to write TLTree Tri
10:17:42 <Cale> It just unfolds to  TLTree (Point,Side)
10:17:51 <hectortrope> Ok thanks all who helped me I am leaving bye guys  see you soon
10:18:04 <ion> Why “N (TLTree a,(TLTree a,TLTree a))” instead of “N (TLTree a) (TLTree a) (TLTree a)”?
10:18:30 <Haskell101> cause i ll be making a library of cata version
10:18:41 <johnw> you're paying 3x the constructor costs
10:18:42 <Cale> ion: Because he's taking a course from bizarro-land :D
10:19:03 <Haskell101> and in cata i need a tuple (a,b), but cause i need 3 i would be using (a,(b1,b2))
10:19:10 <Cale> Haskell101: The use of pairs doesn't really affect whether you can write a meaningful catamorphism
10:19:38 <johnw> now a dogomorphism, that's another story
10:19:53 <ion> pairomorphism
10:20:01 <Cale> @let data TLTree a = L a | N (TLTree a) (TLTree a) (TLTree a)
10:20:02 <lambdabot>  Defined.
10:20:08 <Haskell101> so you started for the flame
10:20:10 <Haskell101> k guys
10:20:46 <Cale> @let cataTLTree l n = f where f (L x) = l x; f (N t1 t2 t3) = n (f t1) (f t2) (f t3)
10:20:47 <johnw> liketupelohoneymorphism
10:20:48 <lambdabot>  Defined.
10:22:18 <DRMacIver> Stupid question. What's the syntax for an existentially quantified data constructor with two parameters? i.e. I want data Foo = forall a. forall b. Foo (Bar a b) . Only, actually parsing correctly. :-) AFAICT none of the docs I've looked at (e.g. https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/data-type-extensions.html) either forbid it or say
10:22:19 <DRMacIver> how to do it.
10:23:08 <Cale> @let cataTLTree' h = cataTLTree (\x -> h (Left x)) (\t1 t2 t3 -> h (Right (t1, (t2, t3))))
10:23:09 <lambdabot>  Defined.
10:23:14 <Cale> :t cataTLTree
10:23:15 <lambdabot> (t -> t1) -> (t1 -> t1 -> t1 -> t1) -> TLTree t -> t1
10:23:19 <Cale> :t cataTLTree'
10:23:20 <lambdabot> (Either a (t, (t, t)) -> t) -> TLTree a -> t
10:24:01 <Cale> forall a b.
10:25:27 <ion> It would be cool if GHC could generate catamorphisms automatically for types whose constructors you have access to.
10:25:35 <feryll> Can anybody check my code and tell my what's wrong with this simply sending an email? It gives me "authentication error" when I try it http://pastebin.com/10t91fXB
10:25:54 <DRMacIver> Cale: Right. Of course. I tried every separator except no separator. Thanks. Doh.
10:25:56 <jacereda> I think I figured out my problem with pretty-printing with both 'groom' and 'ppShow'... Basically, if you have a function in a record it will fail to parse it and just fallback to 'show'. Is having functions inside records a code smell or something and I'm going the unpaved road?
10:26:16 <Haskell101> Cale: thanks !
10:28:01 <ion> jacereda: You could use http://hackage.haskell.org/package/pretty directly and write a custom pretty-printing function for your type.
10:29:28 <jacereda> ion: would I need to define a pretty-printer for all the different function types I use inside records? or can that be generic?
10:31:27 <ion> jacereda: Given data Foo, write a ppFoo :: Foo -> String which outputs anything you want; you can take advantage of pretty for layout.
10:31:50 <jacereda> ion: but I have lots of different record types, that would be too cumbersome
10:32:26 <ion> Can you make your Show instances output something groom will accept?
10:33:16 <jacereda> ion: like emitting "...function..." instead of the <function> string emitted by Text.Show.Functions?
10:33:18 <kclancy> I'm having a problem getting GADT code to compile: http://lpaste.net/133067
10:33:34 <ion> jacereda: Say, _ or _function
10:33:53 <jacereda> is _function special in any way? how will that get parsed?
10:35:14 <feryll> kclancy: It seems your error message is directing you to line 39 of your code, but you've cut some out for us so we can't tell which that is
10:35:16 <jacereda> ion: I mean, all those pretty-printers seem to parse the output of 'show', would changing <function> to _function improve the situation?
10:35:27 <mniip> jacereda, _identifier is syntax for typechecker holes
10:35:40 <ion> “_function” just an identifier like “function” but it will act as a hole instead of an error if written as an undefined variable in an expression with GHC.
10:35:50 <kclancy> feryll: oops. I actually changed the lines. line 39 is actually the bottom line of code, excluding comments
10:35:59 <kclancy> feryll: imap f (RList ra) (a : as) = (f ra a) : (f (RList ra) as)
10:36:41 <mniip> _x is a value that always triggers a typechecking error, but also explicitly mentions what type did it typecheck to
10:36:51 <ion> > let _x = 42 in _x
10:36:52 <lambdabot>  42
10:37:09 <ion> > _x False :: ()
10:37:10 <lambdabot>      Found hole ‘_x’ with type: Bool -> ()
10:37:11 <lambdabot>      In the expression: _x
10:37:11 <lambdabot>      In the expression: _x False :: ()
10:37:24 <mniip> huh, that's new
10:37:34 <jacereda> ion, mniip, thanks, will try that
10:37:56 <ion> > withoutTheUnderscore False :: ()
10:37:57 <lambdabot>  Not in scope: ‘withoutTheUnderscore’
10:39:54 <feryll> kclancy: What should be the type of f in the end?
10:40:03 <feryll> Type t -> t -> t ?
10:40:19 <statusfailed> I have a really weird problem: a ghc-compiled static binary that works fine on 2 machines, but when run on a third _immediately_ runs out of stack space
10:40:24 <statusfailed> oh and it's basically just "hello-world"
10:40:28 <Cale> btw, I answered kclancy's question in another channel.
10:40:34 <feryll> All right
10:40:51 <kclancy> feryll: thanks
10:40:58 <statusfailed> and by "stack space" I meant "heap space"
10:41:19 <jacereda> ion, mniip, that did the trick. Why does Text.Show.Functions use <function> instead of _function then?
10:41:23 <statusfailed> (I compiled limiting to 1GB)
10:41:29 <Cale> statusfailed: Is it exactly hello world?
10:41:50 <geekosaur> because it is old and because it's a shim intended for quick debuggability of things that have functions embedded in them
10:42:03 <geekosaur> whereas whatever you are using expects legal syntax
10:42:23 <statusfailed> Cale: it prints to stderr not stdout
10:42:33 <statusfailed> Cale: and it uses bytestring
10:42:37 <geekosaur> (and the usual assumption is that there's no point in using legal syntax when a function value is involved, and in fact it can lead to hard-to-debug bugs)
10:42:41 <ion> jacereda: It was written at least 14 years ago. As for not using a valid identifier name, that just wasn’t thought of. As for not using a holey identifier name, holes didn’t exist back then.
10:42:41 <Cale> statusfailed: Yeah, that shouldn't be an issue
10:43:09 <Cale> statusfailed: So it's just   main = BS.hPutStrLn stderr "Hello world!"  ?
10:43:19 <statusfailed> Cale: It's also being called from hadoop on the third machine, I'm not exactly sure how the invocation looks unfortunately :(
10:43:24 <geekosaur> if you forget the Show on whatever is using it is only for debugging and try to `read` part or all of it back later
10:43:26 <ion> jacereda: Also for point #1, the valid identifier name would need to be undefined everywhere to avoid those hard-to-debug bugs.
10:43:30 <statusfailed> Cale: pretty much, I can paste if you like
10:43:54 <Cale> Well, that would be good
10:45:41 <Cale> statusfailed: How much memory does it end up consuming?
10:45:50 <Cale> statusfailed: before it runs out of space
10:46:05 <jacereda> geekosaur, ion, we now have holes, the purpose of a pretty-printer is usually debugging, the shown value can be _text_show_function or something unique, any reason not to change it?
10:46:58 <jacereda> at least newbies like me wouldn't spend the afternoon wondering why they can't pretty-print something
10:48:00 <geekosaur> well, your use case is somewhat unusual, and the most common use case sees your use case as a bug
10:48:23 <lpaste> statusfailed pasted “Weird static binary heap error” at http://lpaste.net/133068
10:48:30 <statusfailed> Cale: ^ there
10:49:04 <statusfailed> Actually just to warn in advance; I have very little access to the machine where this fails (no shell), I can only run things via hadoop. Also I can't actually run things until tomorrow (work cluster)
10:49:19 <Cale> statusfailed: That seems very broken
10:49:24 <jacereda> geekosaur: what's the most common use case for Text.Show.Functions?
10:49:35 <ion> jacereda: If you want to make a pull request with the reasoning (that is, it’s good for Show instances to output something you can copy and paste into ghci, replacing function members with holes would be the least evil thing), i would expect it to be merged. But that whole module existing in base is a bit nasty in the first place.
10:49:35 <statusfailed> Cale: Which part? :-)
10:49:57 <Cale> statusfailed: I can't imagine any reasonable way that this program would do that.
10:50:02 <statusfailed> Cale: neither can I
10:50:04 <statusfailed> I'm completely baffled
10:50:34 <Cale> This happens consistently?
10:50:38 <geekosaur> you want something that will let you (show) a value that may have function values embedded in it, but want a syntax error if something then tries to use that as input. (note that typed holes are still new enough that we cannot guarantee everyone has them; for example anyone running anything but the most recent debian stable won't have them)
10:50:47 <statusfailed> Yep. And until I added the heap space limitation, it woudl actually kill nodes in the cluster
10:50:52 <geekosaur> (unless they installed their ghc manually or somewhere other than debian repos)
10:51:04 <jacereda> ion, maybe it could be forked for the specific purpose of pretty-printing?
10:51:06 <geekosaur> statusfailed, same ghc version?
10:51:19 <statusfailed> geekosaur: it's a static binary, I am copying it from my machine to the cluster
10:51:24 <statusfailed> geekosaur: so there is no GHC version
10:51:28 <ion> geekosaur: Anyone having base >= (whatever came with GHC 7.8) is likely to have holes.
10:51:44 <geekosaur> ion, yes, I specified older debian stable for a reason
10:51:50 <geekosaur> I think they get 7.6
10:52:10 <geekosaur> unless they install manuaally something more recent
10:52:28 <statusfailed> geekosaur: hah yeah, I am on 7.6.3 at work on debian old stable
10:53:04 <geekosaur> statusfailed, actually am thinking that there is an interaction between ghc version, glibc version, and the fact that glibc does not like to be linked statically
10:53:30 <dolio> show isn't a pretty printer in the first place, though.
10:53:35 <statusfailed> geekosaur: that sounds plausible
10:53:48 <feryll> What's the simplest way to send information remotely from one computer to another in Haskell?
10:53:56 <statusfailed> geekosaur: I think the machine I'm building on has a slightly newer glibc (Ubuntu 14.04)
10:54:00 <Ralith> How are you supposed to install ghc-mod and structured-haskell-mode for use by emacs now that cabal insists on using sandboxes?
10:54:00 <geekosaur> but if ldd shows that glibc is linked dynamically, you're probably ok. otherwise see if you can convince it to link everything but libc statically
10:54:01 <dolio> Fedora is still on 7.6 as well.
10:54:22 <statusfailed> geekosaur: I did "ldd" and got nothing but "not a dynamic binary" (something like taht?)
10:54:31 <statusfailed> geekosaur: how can I link libc dynamically?
10:54:32 <lush> !calc 2 2 *
10:54:54 <ion> feryll: Data.Binary and TCP perhaps.
10:55:08 <geekosaur> off the top of my head I don't know
10:55:26 <statusfailed> geekosaur: ok, i'll have a poke around, thanks :)
10:56:52 <feryll> ion: Thanks, I'll check them out
10:57:37 <lush> !calc 2 2 *
10:58:08 * hackagebot ihaskell 0.6.2.0 - A Haskell backend kernel for the IPython project.  http://hackage.haskell.org/package/ihaskell-0.6.2.0 (gibiansky)
10:58:10 * hackagebot ipython-kernel 0.6.1.0 - A library for creating kernels for IPython frontends  http://hackage.haskell.org/package/ipython-kernel-0.6.1.0 (gibiansky)
11:01:44 <lush> !calc 2 2 *
11:02:15 <dolio> lush: Do you have some Haskell related business here?
11:02:57 <geekosaur> lush, if you're testing a haskell bit, it's usually better to create a new channel for yourself
11:03:00 <geekosaur> *bot
11:03:17 <Denommus> or talk to the bot in private
11:03:20 <lush> dolio: I'm trying out an extended haskell bot (https://wiki.haskell.org/Roll_your_own_IRC_bot) that shall be able to calculate simple tasks
11:03:23 <lush> oh ok sorry
11:03:27 <geekosaur> you could have it join ##lushbot and the channel will be created if it doesn't exist
11:03:37 <lush> ok, ty :) & sorry
11:04:34 <ion> Ah, unhiding irrelevant joins and parts made it clearer why he repeated the !calc attempt. :-P
11:05:28 <geekosaur> yes, this is why I don't hide joins/parts. my client greys them out by default (at least in this theme) so they're not too obnoxious
11:05:43 <geekosaur> and sometimes having the context is rather useful
11:05:47 <mniip> I just color them distinctively
11:05:59 <ion> Had the bot responded, my client would have shown them.
11:06:08 <mniip> bright-orange and bright-yellow (white background)
11:06:12 <mniip> ion, no
11:06:43 <geekosaur> (granted I'm an op in enough channels that I'm more likely to need that context)
11:06:44 <Ralith> I can't get cabal to stop complaining that there's no sandbox in ~ and refusing to do anything
11:06:56 <lush> ion: calculation succedes, I have to messed up sth. with writing the message
11:07:03 <geekosaur> did you alias cabal to cabal --require-sandbox in your shell?
11:07:04 <SrPx> Does anyone have an example of creating&uploading a texture, and reading it from the shader, using the OpenGL API?
11:07:20 <geekosaur> Ralith, did you alias cabal to cabal --require-sandbox in your shell?
11:07:24 <JagaJaga> I'm sure there is a function to do `f [1,2,3] [4,5,6] = [1,4,2,5,3,6]` Can you tell me it? I'm lazy to write it by myself :(
11:07:27 <geekosaur> (try "type cabal")
11:07:34 <dolio> Ralith: Do you have 'require-sandbox: True' in your config?
11:07:48 <Ralith> no to both of those
11:08:05 <Ralith> fresh package manager install of cabal-install 1.22.2.0
11:08:08 * hackagebot ihaskell-charts 0.2.1.0 - IHaskell display instances for charts types  http://hackage.haskell.org/package/ihaskell-charts-0.2.1.0 (gibiansky)
11:08:10 <dolio> Ralith: What if you pass --no-require-sandbox?
11:08:10 * hackagebot ihaskell-diagrams 0.2.2.0 - IHaskell display instances for diagram types  http://hackage.haskell.org/package/ihaskell-diagrams-0.2.2.0 (gibiansky)
11:08:12 * hackagebot ihaskell-juicypixels 0.2.2.0 - IHaskell - IHaskellDisplay instances of the image types of the JuicyPixels package.  http://hackage.haskell.org/package/ihaskell-juicypixels-0.2.2.0 (gibiansky)
11:08:14 * hackagebot ihaskell-plot 0.2.0.0 - IHaskell display instance for Plot (from plot package)  http://hackage.haskell.org/package/ihaskell-plot-0.2.0.0 (gibiansky)
11:08:16 * hackagebot ihaskell-rlangqq 0.2.2.0 - a rDisp quasiquote to show plots from Rlang-QQ in IHaskell  http://hackage.haskell.org/package/ihaskell-rlangqq-0.2.2.0 (gibiansky)
11:08:17 <ion> > transpose [[1,2,3],[4,5,6]]
11:08:19 <lambdabot>  [[1,4],[2,5],[3,6]]
11:08:26 <ion> > (concat . transpose) [[1,2,3],[4,5,6]]
11:08:27 <lambdabot>  [1,4,2,5,3,6]
11:08:40 <JagaJaga> ion: thank you ^_^
11:08:44 <Ralith> dolio: if I pass that to install, it doesn't recognize the option; if I pass it before install, it has no effect
11:08:55 <dolio> Weird.
11:08:59 <mizu_no_oto> SrPx: Out of curiosity, why are you using OpenGL instead of gl?
11:09:45 <Ralith> dolio: even if I set require-sandbox: False in my config it still complains
11:09:47 <mniip> > transpose ["FOO", "0123456789", "hello"]
11:09:49 <lambdabot>  ["F0h","O1e","O2l","3l","4o","5","6","7","8","9"]
11:09:57 <dolio> Ralith: Can you paste the error?
11:09:58 <ion> Ooh, --require-sandbox. /me sets require-sandbox: True
11:10:01 <Ralith> dolio: cabal: No sandbox exists at /home/ralith/.cabal-sandbox
11:10:13 <merijn> hat does --require-sandbox do?
11:10:15 <Ralith> and exits with code 1
11:10:21 <SrPx> mizu_no_oto: you mean the raw library? I don't know :( I just found some examples so it was easy to get a hello world
11:10:31 <SrPx> but no textures so I'm kinda lost. I hate the OpenGL api... oh god
11:10:34 <dolio> Ralith: Does your home directory have sandbox files in it?
11:10:45 <Ralith> oh, crap, that's probably it
11:10:59 <SrPx> I have the thing coded in JavaScript so it is just a matter of porting, yet...
11:11:03 <dolio> Like cabal.sandbox.config or .cabal-sandbox?
11:11:13 <Ralith> cabal.sandbox.config was it, thanks
11:11:17 <dolio> merijn: It makes cabal refuse to do anything unless you're in a sandbox.
11:11:31 <Ralith> ran cabal sandbox init there by mistake recently and missed deleting that one
11:12:23 <mizu_no_oto> SrPx: There's 3 libraries in the space
11:13:36 <mizu_no_oto> SrPx: OpenGLRaw, OpenGL, and gl.  OpenGLRaw is incomplete, but gl is very complete because it's mostly autogenerated code from the spec
11:14:34 <jacereda> hmmm... how long does it take before you end up remembering automatically the sequence {-# LANGUAGE foo #-}? I always have to look some example... is it that way to discourage its use? ;-)
11:15:06 <bennofs> jacereda: I have an editor snippet lang<TAB> for that
11:15:24 <mizu_no_oto> SrPx: gl was basically created by edwardkmett because he ran into problems with the incompletness of OpenGL, and the inability to mix OpenGL and OpenGLRaw
11:15:25 <SrPx> ah, interesting, thank you mizu_no_oto 
11:15:47 <jacereda> bennofs: yeah, at some point I'll also remember the emacs shortcut to add those, but...
11:15:49 <SrPx> is it the bets way to port a webgl app?
11:16:21 <mizu_no_oto> SrPx: I think so
11:16:54 <mizu_no_oto> You want to implement a webgl app in regular gl, or you want to port a javascript webgl app to a haskell webgl app?
11:17:56 <SrPx> mizu_no_oto: actually I just want to port this to haskell http://lpaste.net/133070
11:18:10 <SrPx> mizu_no_oto: you mean https://hackage.haskell.org/package/gl ?
11:18:22 <mizu_no_oto> Yeah
11:19:19 <mizu_no_oto> Ed's got a real-time raytracer using it at https://github.com/ekmett/quine
11:19:23 <SrPx> I'm kinda lost, do I import the core45?
11:19:49 <arkeet> whichever opengl version you want to target
11:20:48 <mizu_no_oto> Core45 is OpenGL 4.5
11:21:20 <Ralith> is ghc-mod broken?
11:21:26 <SrPx> ok, is there a sample with textures for this ?
11:21:28 <ion> Huh. I have seen his quine work but have totally missed his gl effort.
11:21:37 <arkeet> quine uses gl :-)
11:21:42 <ion> arkeet: yes
11:21:52 <Ralith> 'cabal install ghc-mod' fails with: http://sprunge.us/Vjaf
11:22:26 <SrPx> I've accepted ekmett has a time machine at this point so he stops time to code as many things as he wants, but whatever
11:24:58 <benzrf> SrPx: he's edwardk here
11:25:08 <SrPx> I know 
11:25:26 <mizu_no_oto> SrPx: the one nice thing about gl is that it's literally the raw bindings available in C++, without any real name mangling.  If you find a C++ tutorial, you can just follow it.
11:26:13 <ion> > sequence [["e", "edward"], ["k", "kmett"]]
11:26:15 <lambdabot>  [["e","k"],["e","kmett"],["edward","k"],["edward","kmett"]]
11:26:15 <geekosaur> Ralith, sounds like ghc-mod has not yet been updated for ghc 7.10
11:26:23 <ion> map concat
11:26:38 <mizu_no_oto> benzrf, SrPx: edwardk's traveling a lot this month, so there's a decent chance he's away
11:26:39 <merijn> Ralith: ghc-mod isn't 7.10 compatible yet
11:26:40 <kadoban> Ralith: GHC 7.10? I know it was broken with 7.10 for a while. I thought it had been fixed from some comments on github, but I couldn't tell for sure.
11:26:50 <Ralith> geekosaur: geez. Every time I try to start using it it's broken one way or another :/
11:26:54 <Ralith> at least it's not just me
11:27:00 <geekosaur> maybe it is fixed on github but no release yet
11:27:04 <merijn> Ralith, kadoban: There was an in progress branch to fix it, but the guy working on it has been busy
11:27:17 <merijn> So it's basically broken waiting for the maintainers to have free time to fix it
11:27:19 <kadoban> Ralith: I've been using hdevtools myself, which does almost everything I used from ghc-mod and it's quicker it seems.
11:27:23 <kadoban> Ah, okay.
11:27:24 <geekosaur> well, rushing into 7.10 is not something I recommend
11:27:40 <Ralith> this sort of thing is why I'm growing to hate arch linux
11:27:43 <merijn> I've been using hdevtools for a while too, but there's no maintained version on hackage either
11:27:56 <Ralith> 7.10.1 is my only option
11:27:56 <merijn> There's some community forks, but nothing official
11:27:57 <mizu_no_oto> When I say traveling, I mean that he's going from Boston to Australia to Greece to Zurihac to Italy to somewhere else to Boston.
11:28:08 <mizu_no_oto> IIRC
11:28:30 <kadoban> Really? I thought what's in hackage was 7.10 compatible? At least I remember that being the conclusion when I dug a bit
11:29:21 <kadoban> hdevtools is it the stackage nightly as well (which switched to 7.10), so I'd be surprised if it wasn't 7.10 compatible.
11:29:29 <kadoban> s/is it/is in/
11:29:57 <ion> > (unwords . map concat . sequence . map inits) ["edward", "kmett"]
11:29:59 <lambdabot>  " k km kme kmet kmett e ek ekm ekme ekmet ekmett ed edk edkm edkme edkmet ed...
11:30:06 <ion> nickname generator
11:30:12 <kadoban> XD
11:30:15 <test123_> Hello all, I'm new to Haskell and have been reading learnyouahaskell (great resource). I feel I have understood everything upto http://learnyouahaskell.com/higher-order-functions#function-application
11:30:42 <test123_> map ($ 3) [(4+), (10*), (^2), sqrt] 
11:30:50 <test123_> specifically map ($ 3) [(4+), (10*), (^2), sqrt] 
11:31:43 <test123_> I don't see how this works. More over, we can't I omit the $ and just write map (3) [(4+), (10*), (^2), sqrt] 
11:31:49 <test123_> I tried that, but it threw an error
11:31:57 <merijn> test123_: 3 is not a function
11:32:10 <ion> test123: You can mechanically evaluate the “map”: map ($ 3) [(4+), (10*), (^2), sqrt] = [($ 3) (4+), ($ 3) (10*), ($ 3) (^2), ($ 3) sqrt]
11:32:12 <test123_> true
11:32:14 <merijn> test123_: ($3) is the same as "\x -> x $ 3"
11:32:17 <geekosaur> the ($) operator is function application made visible
11:32:18 <merijn> test123_: Which is the same as 
11:32:23 <geekosaur> a $ b = a b
11:32:26 <merijn> "\x -> x 3"
11:32:31 <ion> > [($ 3) (4+), ($ 3) (10*), ($ 3) (^2), ($ 3) sqrt]
11:32:33 <lambdabot>  [7.0,30.0,9.0,1.7320508075688772]
11:32:48 <geekosaur> (it has lower precedence than anything else so it's useful for making parentheses implicit as well)
11:33:29 <test123_> so how does [($ 3) (4+), ($ 3) (10*), ($ 3) (^2), ($ 3) sqrt] compare to [(3) (4+), (3) (10*), (3) (^2), (3) sqrt]
11:33:35 <test123_> what is so different?
11:33:48 <ion> ($ 3) means \x -> x $ 3
11:33:51 <ion> (3) means just 3
11:34:06 <geekosaur> test123_, it's hard to write a space as an explicit operation instead of just as a space
11:34:14 <geekosaur> so we have $ which is essentially that
11:34:47 <ion> Just like (+ 3) means (\x -> x + 3) which is very different from (3)
11:35:07 <srhb> test123_: ($ 3) (4+) == (\f -> f 3) (4+) == (4+3)
11:35:08 <geekosaur> also it'd be kinda bad if (3) and ( 3) meant different things because the latter would be function application as a section
11:35:20 <geekosaur> the situation with unary (-) is bad enough
11:35:28 <test123_> not following sorry. stepping back to "means \x -> x $ 3". In the first element in the list does this become (4+) $ 3 ??
11:35:40 <ion> test123: Yes
11:35:42 <srhb> test123_: (3) (4+) == applying 3 to (4+), and 3 is not a function, so it's a type error (you cannot apply it to _anything_)
11:36:18 <test123_> but why (4+) $ 3 is the same as (+4) 3
11:36:20 <SrPx> mizu_no_oto: so, most opengl tutorials use glut... do I use glut raw?
11:36:20 <test123_> i mean
11:36:25 <test123_> but why (4+) $ 3 is the same as (4+) 3
11:36:29 <ion> test123: That is how ($) is defined.
11:36:30 <ion> @src ($)
11:36:31 <lambdabot> f $ x = f x
11:36:35 <SrPx> Graphics.UI.GLUT.Raw.Functions <- this?
11:36:41 <merijn> test123_: "f $ x" is literally just "f x"
11:37:03 <merijn> test123_: But because of the low precedence of $ it means you can avoid parenthesis if 'x' is a complex expression
11:37:33 <srhb> Also it allows you to do exactly what you showed in your example, make a function like ($ 3) using a section.
11:38:13 <srhb> Note that 3 is the _right hand argument_ to $, therefore it becomes the argument of an as-of-yet undetermined function
11:38:45 <srhb> > ($ 3) (+4) == (+4) 3 
11:38:47 <lambdabot>  True
11:39:45 <srhb> > (3 $) (+4) -- note hos this is an error. 3 is now the left hand argument to $, ie. the function to be applied to (+4), hence type error
11:39:47 <lambdabot>      Could not deduce (Num a0)
11:39:47 <lambdabot>      from the context (Num a, Num ((a -> a) -> t))
11:39:47 <lambdabot>        bound by the inferred type for ‘e_13434’:
11:39:52 <srhb> how*
11:40:33 * geekosaur wonders if Cale's instance is still in there
11:40:40 <test123_> Think i got it
11:40:43 <test123_> Thanks all
11:41:15 <test123_> "($ 3) means \x -> x $ 3" && "Note that 3 is the _right hand argument_ to $, therefore it becomes the argument of an as-of-yet undetermined function"
11:41:19 <test123_> was what made it click
11:41:27 <test123_> many thanks
11:41:31 <srhb> test123_: :) Check out sections if you need more info
11:41:45 <geekosaur> right, that's section syntax, there are other examples in that expression you asked about
11:41:52 <test123_> actually on the section page now 
11:41:56 <srhb> Great. :)
11:42:02 <geekosaur> (4+) is a section on the other side of the operator
11:42:20 <srhb> + is boring though, / is more informative.
11:42:50 <srhb> (Or anything that doesn't commute)
11:43:14 <ion> - would be too, except for a certain property of - sections. :-P
11:43:20 <srhb> Shh! :-)
11:43:29 <test123_> srhb, completely agree
11:44:02 <albeit> Why does a test take longer using criterion when, in the test, I fork a thread as opposed to forking a thread and immediately killing it?
11:44:19 <test123_> that -ve property related to having to enclose negative numbers in brakcets?
11:44:48 <srhb> > (-2) 2 -- :(
11:44:49 <lambdabot>      Could not deduce (Num a0)
11:44:50 <lambdabot>      from the context (Num a, Num (a -> t))
11:44:50 <lambdabot>        bound by the inferred type for ‘e_122’: (Num a, Num (a -> t)) => t
11:44:50 <ion> Yeah, i meant (-3) not meaning (\x -> x - 3) consistently with all other sections.
11:45:02 <test123_> you have  to write subtract instead
11:45:21 <srhb> Indeed.
11:45:37 <roconnor> or add negative 3 :)
11:46:07 <ion> test123: Btw, https://github.com/bitemyapp/learnhaskell/blob/master/README.md#how-should-i-learn-haskell has exercises as opposed to LYAH.
11:46:35 <Denommus> srhb: I usually do flip (-) 2
11:46:43 <Denommus> srhb: (-2) isn't really a function
11:46:56 <ion> Denommus: He knows, that’s what he was demonstrating.
11:46:57 <arkeet> use (subtract 2)
11:47:07 <srhb> ion: Also not a he. :-)
11:47:13 <ion> srhb: Alright, sorry
11:47:16 <arkeet> subtract exists for precisely this purpose
11:47:45 <geekosaur> it'd be nice if the inconsistency didn't exist though (but then I already said more or less that...)
11:47:54 <feryll> Hey ion, when I'm trying to ghc --make a simple TCP server .hs, it throws a bunch of "undefined reference to <network-2.6.1.0 stuff>". Do you have any idea what that's about?
11:48:35 <joneshf-laptop> why is `genericLength` implemented less efficiently than `length`?
11:48:39 <test123_> understood. i was hoping haskell wouldn't have little pockets of discrete information (special cases) like this. 
11:49:03 <geekosaur> mostly it doesn't. unary operators are a pain point because there's really only the one
11:49:09 <joneshf-laptop> for that matter, why is `length` implemented at all, and not simply a specialization of `genericLength`?
11:49:45 <test123_> geekosaur, good to know, will make my brain less stressed
11:49:59 <test123_> thanks all, will continue reading the guide
11:50:18 <joneshf-laptop> that is, why isn't it `length :: [a] -> Int; length = genericLength`?
11:51:15 <ion> feryll: Please pastebin your code and the full compiler output.
11:52:01 <spambone> I am trying to use persistant 2.1.5 to create an sqlite databaseand am getting an error when I try to import Database.Persist.TH. All the tutorials I’ve read import and use that module, but it seems to no longer exist.
11:53:02 <feryll> ion: http://pastebin.com/hNGm3jnM
11:53:02 <ion> joneshf-laptop: The answer seems to be “nobody is quite sure” according to https://github.com/quchen/articles/blob/master/fbut.md#genericlength
11:53:16 <geekosaur> spambone, looks like it was split into a separate package persistent-template?
11:55:00 <geekosaur> feryll, you seem to be missing a native winsock library
11:55:34 <SrPx> What exactly should I import to get "glutInit"? 
11:56:26 <feryll> Hm, how to fix that?
11:57:01 <geekosaur> I don't know, I'm mostly a unix type but getWS... looks like winsock functions
11:57:36 <spambone> geekosaur, thank you! I just added persistent-template to my cabal file and all is well!
11:57:51 <feryll> Winsock functions, where are those supposed to come from?
11:58:20 <geekosaur> I also am under the impression this is a common problem with the network package on Windows :/
11:58:31 <feryll> Dang
11:58:54 <feryll> Even with the common recommended fix withSocketsDo it doesn't change anything
11:58:54 <joneshf-laptop> ion, thanks, that repo is interesting
11:59:17 <geekosaur> winsock itself comes with Windows. the interface for mingw should come with mingw but is reportedly problematic. are you using stock mingw, or something like Snoyman's minghc?
11:59:39 <geekosaur> you might want to try the latter as it's intended to address this kind of problem
11:59:41 <ion> It seems to be calling gcc with -lwsock32 so a missing -l doesn’t seem to be the issue either.
12:00:48 <ion> Oh, that’s not from winsock, that’s network cbits code.
12:01:56 <zmbmartin1> Not sure if this is enough info but I am having a hard time grasping monad transformers. http://lpaste.net/133074
12:02:09 <zmbmartin1> Anyone that can give me some help?
12:02:32 <feryll> geekosaur: I don't recognize either of those. I am using cygwin64, if that's what you're asking.
12:02:38 <srhb> zmbmartin1: What are you expecting, what is happening, what are you importing
12:02:54 <geekosaur> hm. that would probably make a difference
12:03:12 <srhb> zmbmartin1: And which language extensions are you using.
12:03:56 <zmbmartin1> srhb: Let me post some more info then.
12:04:00 <srhb> :)
12:04:17 <ion> feryll: This is a shot in the dark, but try ghc --make -lws2_32 ...
12:04:55 <feryll> ion: Didn't seem to change much
12:05:16 <ion> ok :-\
12:05:21 <feryll> I'm going to install minghc and see what happens
12:07:15 <hodapp> why did I try to do type-level arithmetic, why why why why >_<
12:07:16 <zmbmartin1> srhb: https://gist.github.com/codedmart/20fd2590aee3655477d7#file-main-hs-L49-L56
12:07:18 <feryll> If only Windows were as pure as Haskell
12:07:33 <hodapp> It's pure something.
12:07:38 <geekosaur> not sure that's really the problem
12:07:53 <geekosaur> the problem is Haskell is generally written and maintained on Unix
12:08:00 <zmbmartin1> So TnIO use to be ReaderT TnConfig IO and my tnIOToEither worked with what I have.
12:08:08 <geekosaur> there are various ways to "siimulate" Unix on Windows
12:08:13 <hodapp> not sure that's a problem so much as just a fact
12:08:21 <oconnore> feryll: MinGHC 7.10 works great for me
12:08:29 <srhb> zmbmartin1: Well, in isolation that error is quite simply that you're saying that that it's TnIO a, but you're using runReaderT on it
12:08:30 <geekosaur> and they aren't all compatible with each other
12:08:34 <oconnore> at least after I uninstalled McAfee
12:08:38 <srhb> zmbmartin1: To use runReaderT on it it has to actually be an ReaderT?
12:08:56 <geekosaur> or derive MonadReader
12:09:01 <zmbmartin1> srhb: Well isn't my TnIO type a ReaderT?
12:09:06 <geekosaur> (which means a newtype with a ReaderT somewhere under it)
12:09:27 <srhb> Oh, yeah, it is.
12:09:30 <ion> hodapp++
12:09:34 <oconnore> it was very odd, booting up the haskell multithreaded runtime inside Matlab was crashing horribly. 
12:09:41 <oconnore> oh wait, that's not very odd, Matlab is terrible
12:09:59 <zmbmartin1> srhb: TnIO use to be ReaderT TnConfig IO and tnIOToEither' worked with what I have.
12:10:24 <ion> oconnore: Did you get the instructions from John McAfee’s video?
12:10:36 <zmbmartin1> srhb: I want to change it to ReaderT TnConfig (ExceptT ServantErr IO), but get lost with how to map that to EitherT ServantErr IO a
12:10:48 <navaati> what is the difference between package mtl and package transformers, again ?
12:10:50 <geekosaur> ob abandonmatlab.wordpress.com
12:11:01 <hodapp> oconnore: I worked for years alongside a division that did their work in about 95% MATLAB. I grew to hate it.
12:11:16 <hodapp> oconnore: because, for one thing, it basically feels like FORTRAN with racing stripes
12:11:19 <oconnore> ion: ha, no, although I'm sure this is his preferred development setup
12:11:28 <ion> https://abandonmatlab.wordpress.com/ is marked private by its owner. If you were invited to view this site, please log in below.
12:12:08 <geekosaur> that may not be the one I'm trying to remember, but it's no longer cached in my browser
12:12:23 <srhb> zmbmartin1: Can you explain that forall a.?
12:12:38 <Ankhers> Can anyone explain what _|_ means?
12:12:46 <srhb> Ankhers: bottom, undefined
12:12:51 <Ankhers> srhb: Thanks!
12:13:13 <srhb> zmbmartin1: ie why isn't it TnConfig -> TnIO a -> EitherT ServantErr IO a ?
12:13:15 <geekosaur> oh, it is, I guess they turned it off :/
12:13:18 <oconnore> hodapp: yeah, it isn't very nice. And I would greatly prefer them to be working in fortran.
12:13:38 <geekosaur> wonder if mathworks sicced a lawyer on them
12:13:45 <oconnore> hodapp: but luckily Matlab has an FFI that is reasonably fast, and Haskell can generate .dlls :)
12:13:58 <ion> Ankhers: It’s an ASCII approximation for ⊥, bottom. In Haskell it means any expression that evaluates to an infinite loop or an error.
12:14:09 <feryll> oconnore ion geekosaur: Oh jeez, now trying to cabal install cabal-install is giving me these "couldn't match expected type bytestring-0.10.4.0:Data.ByteString.Lazy.Internal.ByteString with ByteString" errors again
12:14:41 <oconnore> feryll: you are running into version conflicts. 
12:14:54 <geekosaur> navaati, transformers is a generic transformer library that can be instantiated in terms of functional dependencies or type families. MTL is a fundep instantiation
12:14:58 <zmbmartin1> srhb: One moment trying to find it.
12:15:04 <carrotlord> is it normal to write excessive code when just starting?
12:15:20 <hodapp> carrotlord: excessive how?
12:15:21 <feryll> Yeah, I figured. Is force unregistering bytestring-0.10.4.0 and reinstalling cabal an option?
12:15:26 <Welkin> carrotlord: I would say so for programming in general
12:15:57 <carrotlord> I thought haskell is more succinct than most
12:16:00 <Welkin> I easily write 1/4th the amount of code I would have written a coupl years ago (in any language) to do the same thing
12:16:06 <srhb> zmbmartin1: Other than that your code looks correct to me.
12:16:14 <oconnore> feryll: yes. FYI these things get much easier if you use sandboxes, are you?
12:16:15 <ion> feryll: You could delete your entire ~/.cabal ~/.ghc to start from scratch wrt. installed packages. (Also take advantage cabal sandboxes.)
12:16:21 <ion> of
12:16:30 <oconnore> ^ sandboxes x2
12:16:35 <srhb> zmbmartin1: Aside from the slight funkiness of mapping Right like that
12:16:48 <feryll> Sandboxes?
12:16:49 <srhb> ion: .cabal is unnecessary, is it not?
12:16:53 <srhb> ion: It would also fry user configs
12:16:54 <zmbmartin1> srhb: It comes from http://haskell-servant.github.io/tutorial/server.html#natural-transformations
12:16:57 <albeit> Is there a way to kill all threads launched by a process?
12:17:10 <zq> can someone paste a forall
12:17:13 <oconnore> feryll: cabal sandbox --help
12:17:14 <zq> \forall, that is
12:17:33 <geekosaur> carrotlord, http://www.willamette.edu/~fruehr/haskell/evolution.html ("evolution of a haskell programmer" humor)
12:18:00 <geekosaur> srhb, usually you want to keep ~/.cabal/config
12:18:02 <oconnore> feryll: essentially you can have a separate group of packages that cabal manages independently from your user/global packages
12:18:07 <geekosaur> albeit, no
12:18:16 <ion> srhb: It contains a bunch of files including documentation for the packages one is meaning to delete. Not that their being there breaks anything.
12:18:17 <srhb> zmbmartin1: Hm, okay, pass then. Try to ask the entire channel again.
12:18:35 <oconnore> feryll: that makes managing cabal much easier, because you can easily rebuild, add constraints, without affecting your other projects.
12:18:47 <zmbmartin1> srhb: Thanks!
12:19:06 <geekosaur> albeit, note that POSIX threads also doesn't have a "kill all child threads" function
12:19:07 <feryll> I see. Where is /.cabal and /.ghc by default?
12:19:28 <srhb> feryll: ~/.cabal -- ie /home/yourname/.cabal
12:19:38 <albeit> geekosaur: Okay. So I just have to track all the threadIds from my forkIO and then just kill them that way?
12:19:38 <srhb> feryll: /.cabal is an absolute path at the root (should never happen)
12:19:43 <geekosaur> albeit, yes
12:19:55 <geekosaur> srhb, remember feryll is on Windows
12:20:00 <srhb> Oh.
12:20:02 <codesoup> feryll, if you are using cygwin and trying to compile network, you need to pass the proper build triplet. see: http://stackoverflow.com/questions/17078997/compiling-haskell-module-network-on-win32-cygwin/18779024#18779024
12:20:37 <michaelt> zmbmartin1: if you import Control.Monad.Morph you can write tnIOToEither' t r = runReaderT (hoist (EitherT . runExceptT) r) t
12:21:53 <michaelt> zmbmartin1: in general, EitherT . runExceptT and vice versa swaps hats 
12:21:56 <albeit> geekosaur: Thanks
12:22:24 <feryll> At this point first I think I'd just like to uninstall and reinstall vanilla ghc/cabal in the cleanest way possible first, because I've done some things I probably shouldn't be proud of with packages. What should I do to achieve that?
12:22:58 <zmbmartin1> michaelt: Wow that is great.
12:23:04 <codesoup> blow away %appdata%/cabal, download minghc
12:23:07 <zmbmartin1> Man I need to get better at this.
12:23:15 <zmbmartin1> michaelt: Thanks!
12:23:25 <ion> codesoup: Does that contain the equivalent of ~/.ghc?
12:23:37 <codesoup> feryll, blow away %appdata%/roaming/cabal, download minghc, then install more msys2 stuff if you need more unix tools
12:23:47 <feryll> All right, thanks
12:23:49 <michaelt> zmbmartin1: you might look at https://hackage.haskell.org/package/mmorph-1.0.4/docs/Control-Monad-Morph.html which lets you  map over the inner monad and the like, sort of like what theyre doiing
12:24:24 <zmbmartin1> michaelt: Thanks again that is great!
12:24:39 <michaelt> zmbmartin1: hoist phi bigtransformerthing is like map phi over the inner monad of bigtranformerthing
12:25:34 <codesoup> feryll, oh also, the msys/mingw stuff don't mix well with the cygwin stuff, so you should use the mingw stuff from the mingw terminal and vice versa
12:25:51 <feryll> Ok
12:27:47 <SrPx> What exactly is the port of "GLuint tex; glGenTextures(1, &tex);" using ekmett's gl lib?
12:27:58 <SrPx> Do I have to malloc a Ptr from Foreign?
12:31:54 <SrPx> also again, what GLUT library go together with ekmett's opengl lib? I'm using Graphics.UI.Glut but it redefines GLuint as Word32
12:32:02 <SrPx> while Graphics.GL.Core45 defines it differently
12:32:30 <ion> SrPx: Search for glGenTextures in http://hackage.haskell.org/package/caramia-0.7.2.2/docs/src/Graphics-Caramia-Texture.html#newTexture
12:33:06 <ion> SrPx: or in http://hackage.haskell.org/package/lowgl-0.3.1.1/docs/src/Graphics-GL-Low-Texture.html#newTexture2D
12:37:57 <SrPx> hmm yea, guess that is it :(
12:38:09 <SrPx> thank you
12:38:14 <SrPx> nobody knows the glut thing?
12:47:49 <orion> Are Handle's thread safe?
12:47:55 <Ralith> has anyone yet built an easy-to-work-with way to represent "list of length at least 2" in haskell?
12:48:13 * hackagebot waddle 0.1.0.3 - DOOM WAD file utilities.  http://hackage.haskell.org/package/waddle-0.1.0.3 (MartinGrabmueller)
12:48:30 <Welkin> Ralith: Idris
12:48:34 <Welkin> dependent typing
12:48:41 <srhb> Ralith: Yes, with the nat constraint solver
12:48:44 <sinelaw> Ralith, https://www.fpcomplete.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell
12:48:57 <Ralith> Welkin: you appear to have missed the "in haskell" part of the question
12:49:04 <Ralith> srhb: that got released?
12:49:22 <srhb> Ralith: Yes, the plugin infrastructure is in place in GHC 7.10 and there are plugins on Hackage to act as solvers. :)
12:49:39 <Ralith> close enough I suppose
12:49:53 <Ralith> any of them sane to use in practice?
12:49:55 <srhb> Ralith: http://stackoverflow.com/questions/29823345/lists-of-fixed-length-and-type-literals/29826322#29826322
12:49:58 <srhb> Yes, very much so.
12:50:02 <Ralith> exciting!
12:51:13 <Welkin> I didn't know there was so much already available in Haskell for dependent types
12:51:40 <srhb> Welkin: We live in exciting times. :-)
12:53:40 <defanor> iirc it's called Hasochism, "The Pleasure and Pain of Dependently Typed Haskell Programming"
12:54:06 <dolio> They're not really dependent types.
12:58:13 * hackagebot jose-jwt 0.6.1 - JSON Object Signing and Encryption Library  http://hackage.haskell.org/package/jose-jwt-0.6.1 (LukeTaylor)
12:58:16 * hackagebot cpsa 2.5.0 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.5.0 (JohnRamsdell)
13:00:22 <jle`> Ralith: you can make a fixed length vec type, and have something of type (n > 1) => Vec n a
13:00:48 <Ralith> jle`: wouldn't that be more properly written 'Vec (1 + n) a'?
13:01:09 <jle`> i feel like this way is more readable/legible
13:01:18 <johnw> can you say (n > 1) => these days?
13:01:23 <johnw> I thought it was (n :> 1) =>
13:01:33 <jle`> besides even with that way you'd have to constrain that n is greater or equal to 0
13:01:46 <jle`> (n >= 0) => Vec (1 + n) a...so what's the point? :)
13:01:52 <jle`> johnw: you can define your own type family
13:02:05 <johnw> is > available as an operator at type level?
13:02:06 <Ralith> jle`: n is a nat, is it not?
13:02:17 <jle`> n is whatever nat kind you wish to use
13:02:24 <Ralith> what is a "nat kind"?
13:02:34 <Ralith> nats are by definition >= 0
13:02:50 <Ralith> that's why they're suited for describing the length of a vec
13:02:56 <jle`> yeah, true, heh. i guess it depends on how you impelemnt it
13:03:36 <Ralith> how else would you implement it...?
13:04:14 <jle`> i'm talking about these http://hackage.haskell.org/package/base-4.8.0.0/docs/GHC-TypeLits.html
13:04:31 <jle`> i guess it depends on which solver plugin you use, too
13:04:52 <Ralith> srhb: in the example you give, the length tags are erased, right?
13:09:16 <merijn> Ralith: All types are erased
13:12:58 <JagaJaga> What's the best way to do this?
13:13:00 <JagaJaga> > concatMap (\a -> [a,a]) [1..]
13:13:02 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
13:14:25 <Hafydd> > transpose [[1..],[1..]]
13:14:26 <lambdabot>  [[1,1],[2,2],[3,3],[4,4],[5,5],[6,6],[7,7],[8,8],[9,9],[10,10],[11,11],[12,1...
13:14:39 <Hafydd> > concat $ transpose [[1..],[1..]]
13:14:41 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
13:14:57 <Denommus> :t traspose
13:14:58 <lambdabot>     Not in scope: ‘traspose’
13:14:59 <lambdabot>     Perhaps you meant one of these:
13:14:59 <lambdabot>       ‘BSC.transpose’ (imported from Data.ByteString.Char8),
13:15:03 <Denommus> :t transpose
13:15:04 <lambdabot> [[a]] -> [[a]]
13:15:25 <JagaJaga> @pl concatMap (\a -> [a,a]) [1..]
13:15:25 <lambdabot> ap (:) return =<< [1..]
13:16:03 <Geekingfrog>  @pl ?
13:16:10 <ion> JagaJaga: I don’t see anything wrong with your original expression.
13:16:15 <Hafydd> It stands for "point free".
13:16:21 <ion> Geekingfrog: It obfuscates the code by removing points.
13:16:28 <ion> Hafydd: “pointless”
13:16:37 <Hafydd> That's racist.
13:16:48 <arkeet> :t ap (:) return
13:16:49 <lambdabot> a -> [a]
13:17:00 <arkeet> oh yeah.
13:17:09 <arkeet> ap (:) return x = (:) x (return x) = x:[x] ok.
13:17:15 <arkeet> how clever.
13:17:18 <JagaJaga> Geekingfrog: https://wiki.haskell.org/Pointfree
13:17:37 <arkeet> anyway
13:17:44 <arkeet> JagaJaga: [1..] <* [(),()]
13:17:50 <arkeet> > [1..] <* [(),()]
13:17:52 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
13:18:11 <JagaJaga> THAT'S WHAT FOR WE NEED (<*), YEAH
13:18:12 <ion> > [1..] <* replicate 2 ()  -- parameterized
13:18:13 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
13:18:28 <JagaJaga> Sorry, though it was quiet low useful
13:18:33 <arkeet> :-)
13:18:49 <Hafydd> Nice.
13:18:53 <ion> JagaJaga: (<*) is very useful.
13:19:12 <JagaJaga> ion: first time I see it in use, except parsers.
13:20:31 <arkeet> or you could do list comprehensions
13:20:38 <arkeet> > [x | x <- [1..], _ <- [(),()]]
13:20:40 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
13:22:12 <arkeet> but that's longer
13:22:33 <JagaJaga> @pl [1..] <* [(),()]
13:22:33 <lambdabot> [1..] <* [(), ()]
13:22:38 <JagaJaga> yeah, sure
13:22:41 <Ralith> srhb: is this supposed to make a things compile twice?
13:22:58 <srhb> Ralith: Huh, twice?
13:23:13 <Ralith> srhb: "GHC.TypeLits.Normalise changed" given as the reason
13:23:25 <JagaJaga> > fix (((<$>) <$> (:) <*> ((=<<) <$> (return <$>) <$> (*) <$> join (+))) 1)
13:23:27 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
13:23:32 <JagaJaga> My lovely one
13:23:35 <srhb> I don't know. Not as I recall.
13:24:02 <Ralith> hm.
13:25:00 <dmwit> ?tell acowley In case you care, throwIO *intentionally* uses show instead of displayException. https://ghc.haskell.org/trac/ghc/ticket/9822
13:25:00 <lambdabot> Consider it noted.
13:26:21 <Geekingfrog> :t (<*)
13:26:22 <lambdabot> Applicative f => f a -> f b -> f a
13:26:40 <arkeet> > fix (ap (:) . (. (2*))) 1
13:26:43 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
13:27:08 <Hafydd> > iterate (*2) 1
13:27:10 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
13:27:12 * Hafydd smirks.
13:27:22 <arkeet> well yes, I just took the definition of iterate and manually @pl'd it.
13:27:35 <arkeet> well, iterate (2*)
13:27:44 <Welkin> I was thinking "who would write that"
13:28:08 <arkeet> @pl iterate_f x = x : iterate_f (f x)
13:28:08 <lambdabot> iterate_f = fix (ap (:) . (. f))
13:28:15 * hackagebot snaplet-wordpress 0.1.1.0 - A snaplet that communicates with wordpress over it's api.  http://hackage.haskell.org/package/snaplet-wordpress-0.1.1.0 (DanielPatterson)
13:29:02 <DarkElement> Is that MoodMC guy here yet?
13:29:14 <DarkElement> I really want to see him try to get banned
13:29:30 <ion> > [0..] >>= join replicate
13:29:32 <lambdabot>  [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,9...
13:30:01 <arkeet> cute
13:30:17 <voidzero> yeah
13:30:31 <arkeet> > [0..] >>= do replicate >>= id
13:30:32 <lambdabot>  [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,9...
13:31:32 <voidzero> > [-10..] >>= join replicate
13:31:34 <lambdabot>  [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,9...
13:31:41 <voidzero> ye, makes sense i guess
13:31:50 <arkeet> @src replicate
13:31:50 <lambdabot> replicate n x = take n (repeat x)
13:31:54 <arkeet> @src take
13:31:54 <lambdabot> take n _      | n <= 0 = []
13:31:54 <lambdabot> take _ []              = []
13:31:54 <lambdabot> take n (x:xs)          = x : take (n-1) xs
13:31:55 <ion> replicate (-1) 'a' should be the list xs such that xs ++ ['a'] == ""
13:32:01 <arkeet> heh
13:32:18 <arkeet> you could do that with DList sort of
13:32:19 <ion> Someone should create an ACME package.
13:32:49 <arkeet> replicate (-n) _ = DList (drop n)
13:36:37 <kadoban> ion: Hah, that'd be good. lists of negative length …
13:41:28 <quchen> instance Group List where …
13:42:56 <quchen> Now that we have Natural in Base we can actually start using better arguments for things like "power :: Natural -> Integer -> Integer"
13:43:19 <quchen> replicate won't change because of compatibility of course, but it's nice that we finally have a solution to the problem.
13:43:36 <quchen> Well, semi-solution, because you have to be careful when constructing Naturals.
13:44:35 <dolio> It could almost all be fixed without changing the compiler, really.
13:45:00 <dolio> You could swap out fromInteger with fromNatural, and it wouldn't affect numeric literals.
13:45:54 <dolio> So if you could split things up such that you didn't have negate defined on Naturals, you'd get a type error for doing -5 :: Natural.
13:46:00 <dolio> But that will probably never happen.
13:48:07 <dolio> I guess you still have to change the compiler to base numeric literals on Natural, since they all qualify.
13:51:03 <SrPx_> glTexImage2D :: MonadIO m => GLenum -> GLint -> GLint -> GLsizei -> GLsizei -> GLint -> GLenum -> GLenum -> Ptr () -> m () 
13:51:21 <SrPx_> How do I get a Ptr() from a storable vector of uints?
13:51:32 <SrPx_> I can only get Ptr Uint. I just cast?
13:51:52 <quchen> Yup
13:52:14 <quchen> castPtr is your standard (void*) magic
13:52:39 <quchen> Careful with your feet though
13:59:11 <SrPx_> okay ty
14:02:03 <JagaJaga> How can better I do `f [1,2,3,4,5] = [(1,2), (2,3), (3,4) etc]` ?
14:04:08 <indiagreen> > zip [1..5] (tail [1..5])
14:04:10 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
14:04:24 <indiagreen> > ap zip tail [1..5]
14:04:26 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
14:04:44 <JagaJaga> indiagreen: thank you :)
14:05:02 * JagaJaga forgot why he needs that...
14:05:10 <kadoban> Haha
14:05:30 <quchen> JagaJaga: It's one of the rare valid use cases for `tail`. Try to find out why it's safe here! :-)
14:06:27 <JagaJaga> quchen: because of zip?
14:07:20 <arkeet> in zip x (tail x), consider what happens in the case where tail x fails.
14:07:23 <quchen> JagaJaga: What does `zip (tail xs) xs` do?
14:07:26 <arkeet> and think about the definition of zip.
14:07:29 <quchen> Where's the difference?
14:09:09 <JagaJaga> quchen: reverse order of elements in pairs
14:09:31 <quchen> > let xs = [1,2,3] in zip (tail xs) xs
14:09:33 <lambdabot>  [(2,1),(3,2)]
14:09:41 <JagaJaga> quchen: and fewer pairs
14:10:21 <quchen> JagaJaga: What if I pass an empty list?
14:10:24 <kadoban> JagaJaga: He means what's the difference in terms of safety. One can crash, one can't.
14:10:41 <quchen> > zip (tail []) []
14:10:42 <lambdabot>  *Exception: Prelude.tail: empty list
14:10:43 <JagaJaga> quchen: tail will fails to get tail of []
14:10:45 <quchen> > zip [] (tail [])
14:10:46 <lambdabot>  []
14:12:04 <JagaJaga> quchen: well, lazy evaluation? So it tries to get 1st arg, and because it's not like (x:xs), zip goes to snd pattern like `zip _ _ = []`
14:12:24 <kuribas> Not really haskell, but maybe one of the smart people here knows about it...  Is it possible to do linear programming in realtime, with 9-50 variables, 50 inequalities?
14:12:32 <JagaJaga> s/lazy evaluation//
14:12:58 <quchen> Yes, it's because patterns are matched in order from left to right.
14:13:12 <quchen> It's one of the few places where there's specified evaluation order of sorts.
14:13:13 <SrPx_> is there any obvious way to make things like that less ugly? positionAttrib <- withCString "position" $ glGetAttribLocation program
14:13:18 <dolio> Lazy evaluation is also essential.
14:14:04 <michaelt> > let zip' xs ys = ys `seq`  zip xs ys in (zip' <*> tail) []
14:14:06 <lambdabot>  *Exception: Prelude.tail: empty list
14:14:17 <JagaJaga> quchen: thank you for that good small lesson :)
14:16:21 <alexv19> How can I write type-level map over type-level list? Is this correct implementation?
14:16:23 <alexv19> type family Fmap (f :: k -> k1) (xs :: [k]) :: [k1] where
14:16:24 <alexv19>     Fmap f '[]       = '[]
14:16:24 <alexv19>     Fmap f (x ': xs) = f x ': Fmap f xs
14:19:24 <jacereda> why do I get a 'Prelude.read: no parse' here for Func? http://lpaste.net/2257665974507405312
14:23:31 <dolio> alexv19: That looks fine to me, assuming the syntax is correct.
14:26:21 <geekosaur> so if I instrument the Read instance, I find out readsPrec is being invoked on " sq"
14:27:59 <jacereda> geekosaur: oh... so leading whitespace should always be skipped, right?
14:28:04 <geekosaur> probably
14:28:11 <geekosaur> I haven't looked at the rules
14:28:35 <jacereda> great, thanks
14:29:07 <int-e> jacereda: right. you should also return unparsed suffixes (imagine reading a pair, "(sq,sq)")
14:30:02 <ion> Try readsPrec _ str = [ (sq, rest) | ("sq", rest) <- lex str ]
14:31:43 <jacereda> ion, works great, thanks... more compact that what I had in mind :-)
14:32:00 <navaati> is there a zipWith but which take a default element when a list is shorter than the other ?
14:35:14 <merijn> navaati: Don't think so, but it shouldn't be hard to write
14:35:23 <orion> When writing an exception handler which must handle SomeException, is it possible to have an alternative implementation which handles MyAppException, which is an instance of SomeException?
14:35:50 <merijn> orion: Yes, just install multiple handlers?
14:36:02 <orion> merijn: I'm using WAI.
14:36:07 <merijn> orion: You can also detect the exception type inside the handler, but that is more complicated
14:36:07 <orion> And Warp
14:36:43 <orion> I am attempting to install the handler this way: setOnExceptionResponse :: (SomeException -> Response) -> Settings -> Settings
14:36:45 <merijn> Simon's exception paper (I think it's linked at the top of Control.Exception) should cover all of that and more
14:37:02 <merijn> You can create entire hierarchies, etc. but I don't know all the details of the top of my head
14:37:11 <orion> ok, thank you
14:37:44 <orion> There are two Simons, and two exception papers with both of their names on it. Which do you mean?
14:38:11 <orion> "A semantics for imprecise exceptions", "Asynchronous exceptions in Haskell", or "An Extensible Dynamically-Typed Hierarchy of Exceptions" ?
14:38:41 <dmj`> navaati: just repeat mempty until the other list is empty
14:40:03 <merijn> orion: The last one
14:40:25 <orion> Ok
14:40:32 <merijn> orion: SomeException is basically the top of the hierarchy and you wanna do something for a subgroup of it (MyAppException)
14:40:52 <merijn> orion: That paper explains how to create complex hierarchies and convert between them, etc.
14:41:05 <orion> Awesome, thanks.
14:41:54 <Chobbes> Is there a nice way to do what I'm trying here? I understand why it doesn't work, but I want to define a Num instance on this type without all the tedium :|. http://lpaste.net/4278968744685862912
14:42:29 <ion> jacereda: More correct: readsPrec _ = readParen False $ \str -> [ (sq, rest) | ("sq", rest) <- lex str ]
14:44:10 <kadoban> Chobbes: I dunno, why doesn't it work?
14:44:25 <kadoban> I mean other than the incomplete pattern match.
14:45:51 <Chobbes> kadoban: it won't work because, for instance if I want to multiply Haskell needs to know what instance of (*) to use beforehand.
14:46:20 <Chobbes> It doesn't know whether or not to use the double, or integer instance of (*) otherwise.
14:46:48 <kadoban> Oh yeah right.
14:47:03 <Chobbes> Which makes sense, but I'm not sure what the "best" way to solve this is.
14:47:31 <Chobbes> I mean I can do all of the patterns for all of the operators manually, but that seems messy.
14:47:39 <Chobbes> Reminds me too much of Java beans.
14:48:14 <Chobbes> I mean, I think template Haskell can do it?
14:48:19 * hackagebot linear 1.18.1.1 - Linear Algebra  http://hackage.haskell.org/package/linear-1.18.1.1 (EdwardKmett)
14:48:56 <ion> kadoban: Use a GADT.
14:49:20 <kadoban> nooo I don't wanna. (That's probably for Chobbes )
14:49:32 <ion> Whoops, right
14:52:16 <ion> data EvalResult a where { IntRes :: Integer -> EvalResult Integer; FloatRes :: Double -> EvalResult Double }; evalBinOp :: (forall a. Num b => b -> b -> b) -> EvalResult a -> EvalResult a -> EvalResult a
14:52:32 <ion> forall b, that is
14:55:10 <ion> Chobbes: Actually, you don’t even need the GADT for this to work, the rank-2 type is enough.
14:55:34 <ion> You’d need the GADT for something like eval :: EvalResult a -> a
14:55:50 <jacereda> ion, geekosaur, would this be a nice solution to the 'pretty-printing records with functions' problem? Just add a Text.Show.PrettyFunctions to pretty-show: https://github.com/jacereda/pretty-show/commit/cb3e03b440db1a01c230a1bd02018b19a00aa7da
14:56:41 <aaronm04> How do I set a compiler option in ghci?
14:57:06 <dmj`> aaronm04: :set -XOverloadedStrings
14:57:20 <aaronm04> ah cool, thanks dmj` !
14:57:26 <ion> :seti for interactive evaluation only
14:59:21 <aaronm04> so :set -XOverloadedStrings does not affect code typed in at the REPL?
15:01:27 <Chobbes> ion: ah thanks. :).
15:01:58 <SrPx_> How do I make haskell write itself for me while I eat yogurt
15:02:01 <SrPx_> is there a lib for that too?
15:02:22 <Pamelloes> SrPx_: Yes, but it's proprietary.
15:03:07 <SrPx_> okay, any hacking lib?
15:03:17 <Pamelloes> mmm?
15:03:29 <SrPx_> Pamelloes: what is that?
15:04:05 <Pamelloes> It's like "hm?" but with more 'm' and less 'h'. It means the same thing as "what?"
15:06:44 <Aruro> what is best way to import simple latex formula (has only * + and /) in haskell? Is HaTeX parser the right way to do it?
15:07:45 <ion> jacereda: It might be nice to minimize the amount of evil in that patch by doing something like this in the test: data D2 = ... | F Fun; newtype Fun = Fun (Int -> Int) deriving Show; instance Eq Fun where { _ == _ = True }; instance Read Fun where { readsPrec p = readParen (p > 10) $ \str -> (id, str2) | ("Fun", str1) <- lex str, ("_fn", str2) <- lex str1 ] }
15:08:17 <pavonia> Aruro: What do you mean by import here? What do you want to do with the parsed formula?
15:09:41 <Aruro> pavonia: i want to insert it in function
15:09:55 <ion> jacereda: I wonder which is more appropriate, Text.Show.PrettyFunctions or Text.Show.Pretty.Functions?
15:10:03 <Aruro> pavonia: so i want to make it haskell expression (should be easy since it has only + - and / *)
15:11:10 <ion> jacereda: You should add {-# OPTIONS_GHC -fno-warn-orphans #-} to the file with the Show instance. If you use the Fun wrapper for the test, you can remove FlexibleInstances.
15:11:32 <jacereda> ion: yes, maybe you're right with Text.Show.Pretty.Functions... what is evil about the original?
15:12:52 <pavonia> Aruro: If you have only the basic operations, what LaTeX-specific things do you need to be able to handle?
15:13:32 <Aruro> pavonia: \frac{1}{2} == 1/2
15:14:22 <ion> jacereda: Orphan instances are to be avoided whenever possible, _ == _ = True is also hairy and a Read instance for functions is even worse than the Show instance. Better to minimize the damage by creating the evil instances on a type of your own rather than the global (->). 
15:15:10 <ion> jacereda: Avoiding the orphan Show instance is not possible but avoiding the orphans in the test is.
15:15:35 <pavonia> Aruro: Not sure how sophisticated HaTeX is, maybe also have a look at the pandoc package
15:15:50 <jacereda> ion: ok, thanks
15:16:37 <Aruro> pavonia: HaTeX claims it can return AST of latex expression
15:17:04 <Aruro> pavonia: which is half way there
15:17:34 <dfeuer> I'm trying to figure out these monad transformer things. Does it make any difference at all whether I nest ReaderT inside ExceptT or the other way around? It seems to look the same either way.
15:18:20 * hackagebot flowdock 0.3.0.0 - Flowdock client library for Haskell  http://hackage.haskell.org/package/flowdock-0.3.0.0 (IanDuncan)
15:19:01 <pavonia> dfeuer: The evaluation result will be different
15:19:24 <dfeuer> pavonia, explain?
15:20:13 <jacereda> ion: I don't get any warning about orphan instances with your changes
15:21:13 <Emrace> hello guys
15:21:26 <ion> jacereda: The package might be compiling without -Wall. I’d add it anyway, perhaps they’ll add -Wall at some point.
15:21:34 <pavonia> dfeuer: Here's an explanation http://stackoverflow.com/questions/5075621/what-is-the-difference-between-different-orderings-of-the-same-monad-transformer
15:21:56 <jacereda> ion: shouldn't 'runhaskell -Wall' warn as well?
15:22:01 <Emrace> I'm trying to solve a problem, my code compiles but I'm not sure if it works
15:22:06 <jacereda> ion: because it doesn't
15:22:14 <Emrace> can someone help me?
15:22:19 <dfeuer> pavonia, that doesn't seem to address Reader, which is a bit of an oddball.
15:22:58 <pavonia> Hhm
15:23:00 <ion> jacereda: It warns for me.
15:23:23 <ion> jacereda: You tried runhaskell -Wall Text/Show/PrettyFunctions.hs?
15:25:05 <jacereda> ion: ah, I thought you were referring to test/Test.hs
15:27:50 <ion> jacereda: Ah, the Fun part removed the orphans from Test, so no warning either.
15:28:27 <Emrace> I have to write a function stream f which constructs the list [f0, f1, f2....], where fi(x) = f (x + i/2) if i is even and f (x + 
15:28:42 <Emrace> and f(x^3 * i) when i is odd
15:29:07 <chirpsalot> Aruro: HaTeX does a good job.
15:30:28 <dfeuer> pavonia, I just worked out that if you ignore the newtype constructors,  ExceptT e (ReaderT r m) a  is exactly the same as ReaderT r (ExceptT e m) a
15:30:46 <Emrace> http://pastebin.com/LfSyMGcW that's my code, but I cannot test it because when I type stream 2**2 in ghci
15:30:55 <kaictl> so I'm trying to do some basic stuff with polynomials, and I'm getting stuck on literally the first thing that I need to do with it, which is 'what would a number look like a polynomial representation', which I assumed to be `x = Polynomial [x]`, where Polynomial is a list of coeficients of x to the power of their index. Am I missing something here?
15:30:57 <dfeuer> Which leaves open the question of whether a particular way to order them is likely to tend to work out better when other things are added to the stack.
15:31:08 <Chobbes> Aruro: I'm actually working on a library to do these things right now. I'm a bit rusty with my Haskell at the moment, though ;).
15:31:35 <ion> dfeuer: Unless i’m wrong in the following, they should be the same:
15:31:38 <ion> ExceptT e (ReaderT r m) a ~ ReaderT r m (Either e a) ~ r -> m (Either e a)
15:31:40 <ion> ReaderT r (ExceptT e m) a ~ r -> ExceptT e m a       ~ r -> m (Either e a)
15:31:46 <Emrace> it just prints out that it can't show me the values
15:31:56 <Chobbes> (Also turns out Parsec is a fair bit more complicated than Attoparsec)
15:32:04 <Emrace> which is okay, because I'm generating a list of functions
15:32:07 <Emrace> at least I think so
15:32:17 <dfeuer> ion, yeah, that's what I just worked out. Is one way likely to work out better when other things get added to the stack? Does ReaderT commute with *everything*, or just some things?
15:32:20 <pavonia> dfeuer: Yeah, the position of ReaderT probably only matters for the number of lifts you need to use in the code
15:32:20 <Emrace> can anyone tell me how I can test that?
15:33:22 <ion> Emrace: Note that stream 2**2 means (stream 2) ** 2. Try stream (2**2)
15:33:53 <Aruro> chirpsalot: ty
15:33:54 <argent0> Give the c function: int func( void *(*arg_func) (void*)); How could I pass a Haskell function to it?
15:34:06 <Aruro> Chobbes:  nice :)
15:35:14 <Aruro> is it possible to use Template Haskell to parse latex expressions? lets say i put in the beginning of the file latex formula and TH will insert correct haskell expression where needed?
15:35:22 <argent0> the argument of func would be of c type: void* arg(void* ptr)
15:35:44 <Emrace> tried it, still the same output
15:35:54 <Aruro> only problem of latex to haskell seems to be silent * operator
15:36:01 <Emrace> the second part of the problem is
15:36:33 <Chobbes> Aruro: it shouldn't be too bad with HaTeX. That's my plan.
15:36:38 <Emrace> to use that function stream and get the results of the first 5 functions when x is 0
15:37:35 <Aruro> Chobbes: you will need to evaluate AST generated by HaTex that what is in question, TH will make it much easier, by inserting code before runtime
15:37:48 <ion> Emrace: Try removing the [ and the ] from the first line and applying stream to three numbers.
15:38:16 <Cale> So I just thought for 2 seconds in the shower about what our mysterious guest (and some others) were saying the other day about curryN/uncurryN, and I figured out what it was that I was apparently too sleepy to point out before:
15:38:19 <Chobbes> Aruro: how complicated is your expression?
15:38:26 <Aruro> simple
15:38:33 <ion> Emrace: At the moment you’re returning a list of a single function, so might as well return just the sole value you’re putting to the list.
15:38:44 <Aruro> 1/2 (a+b/c^n) something similar
15:39:14 <Aruro> my whole goal is desire to simply copy formula from wikipedia directly into the code
15:39:17 <Cale> If there's supposed to be an isomorphism between [a] -> r and some mystery type people were calling a -> a -> ... -> r, well, I don't know what the latter type is, but it sure looks like it's meant to be a -> X for some type X.
15:40:18 <Emrace> you mean something like stream 1 2 3?
15:40:27 <ion> Emrace: yeah
15:40:33 <Cale> However, if we pick a = r = Void, then [a] -> r is a type of functions from a type with one defined value to a type with zero defined values, so there's no defined function of that type.
15:40:53 <ion> Emrace: Oh, i see f is applied to just one value in the body of g.
15:41:32 <Emrace> yes
15:41:34 <Emrace> and btw
15:41:34 <Cale> But then a -> X is a type of functions Void -> X, and there's one defined function of that type regardless of what X is.
15:41:40 <Emrace> for the second part
15:41:57 <Cale> (just working in a total setting, ignoring bottoms)
15:42:07 <dfeuer> Cale, does ReaderT commute with every other monad transformer, or just some?
15:42:15 <ion> Emrace: Ah, and f was the first parameter. stream (*10) 2 3
15:43:19 <Emrace>  No instance for (Show a0) arising from a use of ‘print’     The type variable ‘a0’ is ambiguous
15:43:24 <Emrace> that's what it prints
15:43:26 <Cale> dfeuer: I wouldn't assume it does.
15:43:37 <dfeuer> Hmmm.
15:44:11 <Cale> dfeuer: Does it commute with Cont r?
15:44:18 <dfeuer> No idea.
15:44:19 <Cale> er, ContT r rather
15:44:20 <Emrace> given that the code returns a list of functions as was the first part of the problem
15:44:33 <Cale> @unmtl ContT r (ReaderT e m a)
15:44:33 <lambdabot> Plugin `unmtl' failed with: `ContT r (ReaderT e m a)' is not applied to enough arguments, giving `/\A. (A -> (ReaderT e m a) r) -> (ReaderT e m a) r'
15:44:45 <dfeuer> I'm still trying to figure this stuff out. But I have heard ContT is a bit on the ill-behaved side, so yeah, probably a good one to check.
15:44:56 <Cale> @unmtl ContT r (ReaderT e m) a
15:44:57 <lambdabot> (a -> (ReaderT e m) r) -> (ReaderT e m) r
15:45:11 <ion> > let stream f = (\x i -> g x i) where { g x i | i `mod` 2 == 0 = f (x + fromInteger i/2) : g x (i+1) | otherwise      = f (fromInteger i**3 * x) : g x (i+1) } in stream (*10) 2 3
15:45:13 <lambdabot>  [540.0,40.0,2500.0,50.0,6860.0,60.0,14580.0,70.0,26620.0,80.0,43940.0,90.0,6...
15:45:15 <Cale> @unmtl ReaderT e (ContT r m) a
15:45:15 <lambdabot> e -> (ContT r m) a
15:45:38 <Emrace> and I write something like values stream f n which iterates through the list, created by stream f, n times and returns a list with the results of the first n functions 
15:45:47 <Emrace> would it work the way I think it would?
15:45:52 <ion> Emrace: Add the fromInteger invocations as seen above. Otherwise you’re using i as both Integral and Floating which is conflicting.
15:46:20 <Hafydd> instance Conflicting i i where
15:47:02 <Cale> @unmtl ContT r m a
15:47:02 <lambdabot> (a -> m r) -> m r
15:47:31 <ion> Has @unmtl always unmtl’d only the top constructor?
15:47:53 <Cale> So we're asking whether (a -> (e -> m r)) -> (e -> m r) is the same as e -> ((a -> m r) -> m r)
15:48:03 <Cale> ion: apparently
15:48:38 <fvgvxmpv1> u
15:49:25 <Bor0> > let functions = map f [0..] where { f i x | even i = x + quot i 2 | otherwise = x^3 * i } in map (\f -> f 0) (take 5 functions) -- this should be the first 5 evaluations for x = 0 if I'm not wrong
15:49:27 <lambdabot>  [0,0,1,0,2]
15:49:28 <SrPx_> okay, you with more experience on opengl, any idea why this will show a black screen without anything? http://lpaste.net/133082 I'm kinda struggling to understand what is wrong because no error message etc
15:51:26 <feryll> Is there anywhere a tutorial on how to set up and connect to a TCP server? The documentation on Network.Simple.TCP and other examples usually only show how to establish the server, and don't inform you about finding viable hostnames/ports
15:52:21 <Emrace> ion: it works now, thank you very much
15:52:32 <ion> localhost should be a viable hostname and most numbers over 1024 up to 32767 or so should be a viable port.
15:52:46 <Emrace> so if I type stream (*2) 1 2
15:53:08 <dfeuer> Cale, so the answer seems to be no... but then again, ContT is ... wonky.
15:53:11 <Emrace> i is 2
15:53:22 * hackagebot lens-action 0.2.0.1 - Monadic Getters and Folds  http://hackage.haskell.org/package/lens-action-0.2.0.1 (EricMertens)
15:53:24 <Cale> dfeuer: Well, djinn can compute some functions between those types...
15:53:32 <dfeuer> Oh?
15:53:40 <Cale> @djinn ((a -> (e -> m r)) -> (e -> m r)) -> (e -> ((a -> m r) -> m r))
15:53:40 <lambdabot> f a b c = a (\ d _ -> c d) b
15:53:42 <Emrace> *2 is my function and it multiplies 1 by 2?
15:53:48 <Cale> @djinn (e -> ((a -> m r) -> m r)) -> ((a -> (e -> m r)) -> (e -> m r))
15:53:48 <lambdabot> f a b c = a c (\ d -> b d c)
15:54:05 <ion> Emrace: (*2) = (\x -> x * 2)
15:54:12 <Cale> I'll leave it to you to decide if those compose to the identity :P
15:54:55 <ion> @type [\a b c -> a (\ d _ -> c d) b, \a b c -> a c (\ d -> b d c)]
15:54:56 <lambdabot>     Occurs check: cannot construct the infinite type: t2 ~ t1 -> t2
15:54:56 <lambdabot>     Expected type: t3 -> t1 -> t2
15:54:56 <lambdabot>       Actual type: t3 -> t2
15:54:59 <Emrace> ion: yes, that's what I meant
15:55:07 <Emrace> it works now, thank you so much
15:55:11 <ion> np
15:55:23 <feryll> ion so what exactly is a hostname? I've seen mention of those like "haskell.org" or "192.168.1.1" but those don't seem like actually functional examples.
15:55:27 <Cale> feryll: What kind of application is your TCP server serving?
15:55:28 <dfeuer> Cale, I think if ContT were the right sort of polymorphic, then it would work out, but as it is, one doesn't *need* to pass the available argument to the function that can take it.
15:56:53 <feryll> Cale: My application would simply be to transmit text from one computer the client to another as the server
15:56:56 <Cale> feryll: For example, if it's a web server, it should be on port 80 usually, because that's which port web servers will try to connect on by default.
15:57:07 <Cale> Okay, so then you just pick something, pretty much
15:57:29 <feryll> It can just be gibberish, then?
15:57:47 <Cale> http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers -- you may want to avoid using these
15:58:19 <Cale> (e.g. by picking something in the range 49152-65535)
15:59:21 <feryll> I understand more or less the function of ports, but I don't take it I can just "use" haskell.org to route my communications, right?
16:00:03 <Cale> As the server, you don't pick a hostname.
16:00:53 <ion> feryll: Almost every computer on the Internet has an IPv4 address. haskell.org the address 23.253.242.70. There are addresses reserved for private networks such as 192.168.1.1. There are also special addresses such as 127.0.0.1 which is a loopback address to the computer itself. When you ask for haskell.org’s address, that is queried from a DNS server that associates hostnames to addresses. All standard
16:00:54 <feryll> What's the first parameter of the serve function in Simple.TCP, then?
16:00:55 <ion> systems associate localhost to 127.0.0.1. A server can listen to one of the addresses one of its network interface has, such as 192.168.1.x to provide a service to the local network or 127.0.0.1 to provide a service to clients running on the same computer.
16:01:32 <ion> haskell.org is running an http server that binds to the IP address 
16:01:36 <ion> 23.253.242.70 on port 80
16:01:50 <feryll> So would just using the ip4 seen from http://ip4.me/ work in "server (Host ip4) ..." ?
16:02:01 <orion> What is ghc-7.10.1-dyn?
16:02:13 <feryll> serve*
16:02:16 <Cale> uhh
16:02:34 <arkeet> no, you want to use an ip you see in ifconfig or whatever.
16:02:43 <ion> feryll: Yes if your computer is connected directly to the Internet with a public IP address, but if you have a router doing NAT (network address translation), it is actually the router’s public address.
16:02:45 <arkeet> or just use 0.0.0.0 to listen on everything
16:02:45 <Cale> Just use HostAny for that
16:02:50 <arkeet> ^
16:03:16 <ion> feryll: If you are in a home network, you’re almost certainly using NAT and thus won’t see that public address in the list of addresses your computer’s network interfaces have.
16:03:46 <Bor0> more like, if the machine you're using is not used as a server you're almost certainly under NAT :)
16:04:32 <feryll> So is there an address I need from my router to get when running under NAT?
16:05:07 <ion> feryll: Not unless you want users outside your home network to be able to connect to your service (and even then it’s more complicated).
16:05:11 <ttt_fff> is template haskell here to stay, or there is an alternative? this whole compile haskell prog, run it, start compiling it again, re-run that, etc ... seems sorta inefficient
16:05:49 <ion> feryll: If you use localhost, clients running on the same computer will be able to connect. If you use the LAN address your computer has, clients running on the same physical network will be able to connect.
16:06:10 <feryll> ion: So is there any go-to way for how I would approach letting a generic user in the world connect to my TCP server?
16:06:20 <Cale> When other people connect to you, they'll need to know your IP address, or you'll need to have a domain name registered which points at your IP address.
16:07:45 <Emrace> ion: I have another question, stream (*2) will generate a list of functions, right?
16:08:21 <dzack> Anyone know the best way to go about dealing with this error message:
16:08:25 <Cale> ttt_fff: Template Haskell is not an alternative to that?
16:08:26 <dzack> The following installed packages are broken because other packages they
16:08:28 <dzack> depend on are missing. These broken packages must be rebuilt before they can
16:08:35 <dzack> ...be used
16:08:53 <ion> feryll: You can manually configure your router to forward connections coming from the Internet to a certain port onto a computer in your LAN, or your server can talk to your router using a protocol such as NAT-PMP or UPnP to request a temporary, dynamic forwarding. The former seems more appropriate for, say, a HTTP server you’re going to keep running on a specific computer indefinitely. The latter is more
16:08:55 <ion> appropriate for, say, a P2P or VoIP program running on an arbitrary computer intermittently.
16:09:09 <Cale> ttt_fff: I'm not sure I understand what you're after there :)
16:09:18 <dzack> attempting to 'cabal install' the listed packages shows that other packages are likely to be broken by the reinstall.
16:09:35 <michaelt> dzack: if you do ghc-pkg unregister the-package it will warn you before you go on
16:09:48 <dcoutts> dzack: you probably want a sandbox
16:09:49 <feryll> Hm, thanks. I'll do some more research.
16:09:50 <ion> Emrace: You can type “:t stream (*2)” in ghci to see its type. It’s not a list of functions, it’s function that returns a list.
16:10:35 <michaelt> dzack: do ghc-pkg check to find out what is broken.  dcoutts is right but there is also the question of the broken packages that are there ...
16:10:43 <Cale> dzack: Unregister the affected packages, then tell cabal-install to install as many of them as possible at once, so that it can compute a non-broken solution to the problem. If you keep trying to install them one at a time, it's possible to end up in a cycle of pain where something is always broken.
16:11:28 <ion> dzack: Are you using cabal sandboxes?
16:12:52 <dzack> ion: was not, but currently trying a build inside of one
16:17:29 <SrPx_> nobody? :( ~
16:17:33 <SrPx_> can't find the problme at all
16:17:34 * SrPx_ sighs
16:18:06 <Emrace> ion: I think I understand it now, thank you
16:18:21 <Emrace> now I just have to think of a way to get the first 5 elements of that list
16:18:45 <defanor> SrPx_: i heard opengl does that. might be worthwhile to ask on #haskell-game
16:18:56 <SrPx_> okay, thanks :)
16:22:36 <SrPx_> ... we desperately needs an OpenGL like think with a good api, types and a better shading language.
16:22:37 <SrPx_> :(
16:22:39 <SrPx_> need*
16:22:39 <ion> SrPx: Hmm, are you swapping the buffer at any point?
16:22:50 <SrPx_> ion: no, what is that? let me see
16:22:55 <ion> Or does GLUT take care of that for you?
16:23:54 <ion> It seems GLUT should do that for you.
16:24:15 <SrPx_> dunno
16:24:28 <SrPx_> tried adding swapBuffers in many places randomly, no effect
16:24:31 <orion> Why do people complain that Exceptions must be instances of Typeable?
16:26:14 <Chobbes> SrPx_: I'm really excited for SPIR-V.
16:27:27 <c_wraith> orion: because GHC 7.10 isn't widespread yet. :)
16:27:56 <SrPx_> Chobbes: very interesting, thanks for the name
16:28:44 <meditans> hi, I have a question a bit theoretical in nature, on recursion schemes
16:28:46 <orion> c_wraith: Ah, I see. It seems that some man named Robert Harper has strong opinions.
16:28:56 <meditans> and I'm also a bit tired :P
16:29:01 <c_wraith> orion: his objection is no longer valid with GHC 7.10, either.
16:29:05 <dzack> SrPx_
16:29:12 <c_wraith> orion: actually, it's not valid with 7.8
16:29:12 <Chobbes> SrPx_: yeah, Khronos is also going to release Vulkan eventually, which is a "new OpenGL". We dunno much about it yet, other than that it's largely built from AMD's mantel. Either way, hopefully these things allow for bigger and badder shading languages :).
16:29:17 <meditans> so it's possible that the question will be inintellegible
16:29:26 <orion> c_wraith: Very interesting.
16:29:27 <dzack> SrPx: have you tried immediate mode? and setting line width/color manually?
16:29:53 <c_wraith> orion: before ghc 7.8, Typeable instances could lie.  In 7.8, only autogenerated Typeable instances are allowed.  In 7.10, all types autogenerate Typeable instances, requested or not.
16:29:56 <SrPx_> glBegin etc? yes, it works and display the color on the shader
16:30:30 <Emrace> ion: I managed to complete the second part as well, thank you again for your help
16:30:47 <orion> c_wraith: Cool!
16:31:10 <c_wraith> orion: Robert Harper's issue with Exception was lying Typeable instances could do all sorts of broken things.  But that's no longer true!
16:31:13 <meditans> One can deconstruct something with, among other things, a catamorphism or a paramorphism
16:31:13 <meditans>  
16:31:40 <meditans> let's say you are deconstructing naturals. Then, if your elimination rule is worded as a catamorphism, you cannot define factorial in a simple way
16:32:06 <meditans> if it's worded as a paramorphism, is easy to write
16:32:10 <dzack> SrPx_: Yep, and hmmm...I also seem to remember you needing to explicitly enable vertex attributes
16:32:37 <dzack> SrPx_: Something like glEnableVertexAttribArray(handle) in i.e. C++
16:32:39 <meditans> I wonder, are there functions that are difficult to write even with paramorphisms in the same way factorial is difficult to write without?
16:33:06 <meditans> I'm trying to decide if the extra cruft in the elimination rules are worth it
16:34:12 <dzack> It's something like glBindBuffer->glEnableVertexAttrib->glVertexAttribPointer->glDraw
16:34:25 <dzack> (then disabling them, etc)
16:34:40 <ion> bracket!
16:34:46 <dzack> Also, have you tried GL_Triangles as the drawing mode?
16:35:43 <orion> c_wraith: I see. So, I was talking with merijn earlier and I have an issue with Warp forcing me to provide an exception handler with type (SomeException -> Response). I've created a type called MyAppException and want to handle it, but I am not sure how to do so given the type on the exception handler I need to provide.
16:35:46 <orion> Do you have any thoughts on this?
16:36:33 <orion> I am using 7.10
16:36:37 <c_wraith> orion: didn't merijn provide an example of pattern-matching on the SomeException constructor and attempting to cast the contents to the type you want, then handling it based on whether the case succeeded?
16:36:56 <c_wraith> orion: I could swear I saw him post code to that effect this morning.
16:38:24 <orion> c_wraith: Nope, he pointed me to a paper by Simon. I read the paper, but his solution was to use "catches".
16:38:39 <orion> AFAIK, Warp doesn't provide the ability to use catches.
16:42:02 <dcoutts> orion, c_wraith: but you certainly can dynamically cast SomeException
16:42:17 <dcoutts> catch and catches do that under the hood
16:42:43 <SrPx_> dzack: that solved it thanks
16:42:56 <SrPx_> :) knew it was something stupid
16:43:01 <orion> dcoutts: Hi. :)
16:43:10 <SrPx_> why OpenGL has to be like that
16:43:12 * SrPx_ sighs
16:43:24 <dcoutts> orion: oh hia :-)
16:45:02 <orion> dcoutts: Do you know of a good resource I can read to learn about dynamic typing?
16:45:17 <orion> I'm currently consulting Data.Dynamic
16:46:05 <dcoutts> orion: right, that and Data.Typeable is where I'd start
16:46:26 <orion> Alright, thank you.
16:47:01 <dcoutts> orion: ok, but for exception there's a more direct and recommend api, use fromException
16:47:10 <dcoutts> it's doing the dynamic casting under the hood
16:47:17 <dcoutts> but don't need to know the details
16:47:25 <dcoutts> fromException :: SomeException -> Maybe e 
16:47:58 <dcoutts> orion: point is, you use fromException at the type you want, and if it is of that type then you get one back
16:49:23 <orion> Awesome, I didn't know about those functions.
16:49:40 <dcoutts> orion: that's the Exception type class
16:50:09 <dcoutts> Exception & SomeException work together
16:50:33 <dcoutts> orion: so ignore Typeable and Dynamic, unless you're just curious
16:51:13 <orion> I am curious.
16:57:33 <orion> It looks like the documentation at the top of Control.Exception in base 4.8 is a little out of date. 
17:04:53 <paulrd> (a -> m (Maybe b)) -> [a] -> m [b]
17:05:27 <Emrace> guys, I have another question
17:05:27 <paulrd> looking for a monadic version of maybeMap ...
17:06:02 <Emrace> how can I transform the list ["aa","bb"] into "aabb"
17:06:15 <koala_man> concat
17:07:47 <paulrd> Monad m => (a -> m (Maybe b)) -> [a] -> m [b]
17:07:47 <pavonia> :t fmap catMaybes . mapM
17:07:48 <lambdabot> (a1 -> [a]) -> Maybe a1 -> [a]
17:07:59 <Emrace> thank you
17:08:01 <Emrace> I feel dumb now
17:08:35 <pavonia> Err, there's something wrong
17:08:40 <pavonia> :t mapM
17:08:42 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
17:08:42 <koala_man> Emrace: hoogle is awesome for these things if you haven't tried it
17:08:43 <ion> @type \f -> fmap catMaybes . traverse f
17:08:44 <lambdabot> Applicative f => (a1 -> f (Maybe a)) -> [a1] -> f [a]
17:08:49 <koala_man> @hoogle [[a]] -> [a] 
17:08:50 <lambdabot> Prelude concat :: [[a]] -> [a]
17:08:50 <lambdabot> Data.List concat :: [[a]] -> [a]
17:08:50 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
17:09:41 <dfeuer> I just read Monad Transformers Step by Step, and that got me thinking about ExceptT in the context of an interpreter. In particular, the notion of layering extra info into the exceptions, like, for instance, attaching the environment in which the problem occurred. Is there some nice way to do this?
17:12:21 <Emrace> koala_man: I'm discovering it now, I have a course in functional programming at the university and I have a mini-exam in about 9 hours
17:12:45 <Emrace> we'll have 2 more of them till the end of the semester
17:14:04 <Emrace> the tasks they gave us so far were not that hard and I was able to write the code on my own
17:14:52 <bananagram> :t fmap catMaybes -> traverse
17:14:53 <lambdabot> parse error on input ‘->’
17:14:58 <bananagram> :t fmap catMaybes . traverse
17:15:00 <lambdabot> (a1 -> [a]) -> Maybe a1 -> [a]
17:15:41 <ion> @type fmap catMaybes .: traverse
17:15:42 <lambdabot>     Not in scope: ‘.:’
17:15:42 <lambdabot>     Perhaps you meant one of these:
17:15:42 <lambdabot>       ‘.’ (imported from Data.Function),
17:15:52 <bananagram> :t \f -> fmap catMaybes . traverse f
17:15:53 <lambdabot> Applicative f => (a1 -> f (Maybe a)) -> [a1] -> f [a]
17:16:55 <bananagram> those types don't really match
17:17:04 <ion> Neither does the code
17:19:19 <bananagram> :t traverse id
17:19:20 <lambdabot> (Applicative f, Traversable t) => t (f b) -> f (t b)
17:19:58 <ion> a.k.a. sequenceA
17:21:02 <wolf_mozart> so how much are programmer paid these days? 15-20/hr?
17:22:35 <dmj`> wolf_mozart: #haskell-blah
17:29:32 <lpaste> rpglover64 pasted “GHC 7.10.1 Bug?” at http://lpaste.net/133086
17:30:22 <rpglover64> I found a small piece of code that causes GHC 7.10.1 to panic with "StgCmmEnv: variable not found"
17:30:51 <rpglover64> I want to know if I'm doing something silly or if I found an actual bug (and if it's been reported already; I couldn't find it)
17:31:21 <rpglover64> It seems that partial type signatures and type families interact poorly.
17:31:30 <rpglover64> Would anyone be so kind as to take a look?
17:31:36 <ion> When GHC says “Please report this as a GHC bug”, it’s likely not lying.
17:32:10 <tmillc> succ True
17:32:16 <tmillc> is False
17:32:52 <ion> > succ True
17:32:54 <lambdabot>  *Exception: Prelude.Enum.Bool.succ: bad argument
17:33:27 * hackagebot liquid-fixpoint 0.3.0.1 - Predicate Abstraction-based Horn-Clause/Implication Constraint Solver  http://hackage.haskell.org/package/liquid-fixpoint-0.3.0.1 (EricSeidel)
17:33:29 * hackagebot liquidhaskell 0.4.0.0 - Liquid Types for Haskell  http://hackage.haskell.org/package/liquidhaskell-0.4.0.0 (EricSeidel)
17:33:55 <Vektorweg11> > maxBound :: Bool
17:33:57 <lambdabot>  True
17:34:14 <Vektorweg11> yeah, you can build a turn around `succ`.
17:36:56 <mniip> @let cycleSucc = liftA3 bool (const minBound) succ (/= maxBound)
17:36:58 <lambdabot>  Defined.
17:37:20 <mniip> > map cycleSucc [LT, EQ, GT]
17:37:22 <lambdabot>  [EQ,GT,LT]
17:38:57 <feryll> So I've port forwarded port 2630 with a static ip address; my public ip being 23.28.121.191, why doesn't the following server and connection client work? http://lpaste.net/133087 http://lpaste.net/133088
17:39:20 <feryll> Specifically, the connection to the port in connection.hs is timing out
17:41:12 <mniip> feryll, have you tried connecting with something simpler like netcat first?
17:41:24 <geekosaur> check for a firewall?
17:41:27 <feryll> Netcat?
17:42:05 <mniip> feryll, like cat but for internet
17:42:41 <feryll> I'm actually windows, so I haven't heard of it
17:43:01 <mniip> ugh
17:43:02 <ion> Does your Windows firewall allow incoming connections?
17:43:35 <geekosaur> https://nmap.org/ncat/ is equivalent and comes with Windows binaries, whereas netcat there's a lot of folks offering possibly questionable private builds
17:43:45 <geekosaur> and yes, modern Windows has a built in firewall you need to check/adjusrt
17:44:55 <Vektorweg11> feryll: switch your router off and on again. 
17:45:44 <feryll> I'm trying it without the firewall...
17:46:48 <ion> You’re certain you set the destination IP address and port correctly for the forwarding?
17:47:18 <tmillc> I don't understand this: "minBound and maxBound are interesting because they have a type of (Bounded a) => a. In a sense they are polymorphic constants."
17:47:49 <geekosaur> > minBound :: Int
17:47:50 <lambdabot>  -9223372036854775808
17:47:55 <geekosaur> > minBound :: Bool
17:47:57 <lambdabot>  False
17:48:47 <geekosaur> note that you don't give them a parameter, you specify the type somehow (either explicitly as above or by the surrounding expression context)
17:49:07 <tmillc> hmm
17:49:09 <geekosaur> > minBound + (2::Word8)
17:49:11 <lambdabot>  2
17:49:17 <feryll> Still no go without the firewall. And I'm fairly sure I did the port forwarding right. I set the static ip to 192.168.1.151, and set that as the internal IP for the port forwarding of 2630
17:49:53 <mniip> feryll, does arp verify that your local IP is 192.168.1.151
17:50:01 <mniip> also try ##networking
17:50:05 <tmillc> > minBound::Word8
17:50:07 <lambdabot>  0
17:50:09 <geekosaur> belay that, check in control panel
17:50:23 <tmillc> ok I see sort of
17:50:30 <geekosaur> arp is less than helpful on windows unless you're an expert...
17:50:38 <feryll> You mean when I do arp -a ?
17:52:59 <feryll> But yes, arp -a shows "Interface: 192.168.1.151 --- 0x4" as the first line
17:53:23 <feryll> Also, I just recently tried adding withSocketsDo to server.hs to no avail
17:53:59 <Vektorweg11> feryll: i used the network package, which gave me wsaetimedout error. i have no idea what that means, but googling leaded me to a problem exactly like yours. well and the solution was to restart the damn router. 
17:54:26 <feryll> Hm, all right, I'll try that then.
17:54:39 <feryll> wsaetimedout was the error it gave me
17:55:38 <geekosaur> commodity routers do tend to suck...
17:56:07 * geekosaur bought one with dd-wrt preloaded. people into geeking on personal time often recommend side-loading openwrt instead...
17:59:57 <feryll> Restarting the router didn't seem to help
18:01:17 <feryll> As long as I'm running server.hs, which afaict has correct code, should http://www.canyouseeme.org/ be able to verify if my port is open?
18:01:28 <feryll> I should probably take it to ##network by now
18:01:35 <ion> Seems like it should.
18:01:42 <Vektorweg11> hm
18:02:17 <geekosaur> feryll, I would expect it to, yes
18:03:17 <geekosaur> but yes, you probably want a networking-specific channel to verify that you can get to it to start with. probably also something other than your test program initially just to verify basic network connectivity (see ncat that I linked to earlier)
18:03:29 * hackagebot not-gloss 0.7.4.0 - Painless 3D graphics, no affiliation with gloss  http://hackage.haskell.org/package/not-gloss-0.7.4.0 (GregHorn)
18:04:25 <feryll> All right then, thanks for all the help so far
18:25:56 <tmillc> I know that '\1114111' is a Char, but I'm having trouble figuring out how to display it, my thinking is to use show or read
18:26:56 <geekosaur> putStrLn . (:[])
18:27:05 <geekosaur> ...and have a terminal whose font has that character
18:27:16 <geekosaur> (good luck; I'm not sure it's even allocated)
18:27:28 <arkeet> :t putChar
18:27:29 <lambdabot> Char -> IO ()
18:27:42 <geekosaur> http://www.fileformat.info/info/unicode/char/10ffff/index.htm
18:27:50 <geekosaur> not allocated currently
18:28:03 <arkeet> and never will be
18:28:59 <geekosaur> right, SUPPLEMENTARY_PRIVATE_USE_AREA_B
18:34:11 <tmillc> huh ok
18:39:20 <ion> All the cool guys have the Haskell logo at that codepoint.
18:39:35 <Vektorweg11> what codepoint?
18:39:42 <arkeet> U+10FFFF
18:39:47 <ion> maxBound
18:40:14 <tmillc> maxBound::Char ;)
18:40:16 <Vektorweg11> ah
18:41:05 <ion> tmillc: “codepoint” implies Char. :-P
18:41:31 <tmillc> ion: ok well I'm struggling to implement a simple caesar cipher and just wanted to feel smart for a second ok! :)
18:42:26 <Vektorweg11> chr ord
18:42:46 <Vektorweg11> unicode caesar cipher. lolo
18:44:19 <tmillc> haha well it's an exercise, and I need it. Though I realized I needed to backtrack because some things didn't quite sink in yet enough (currying, types and typeclasses)
18:51:51 <kirill`> Is it possible to get ghci to show thunk more deeply than with ":print" without forcing it to normal form?
18:52:13 <athan> kirill`: seq? :\
18:53:06 <kirill`> athan: No, I mean if I have "let x = 1 + (2 :: Int)", and ":print" gives me "_t1 :: Int", then I can't quite see what _t1 is "composed of". Here seq would just give 3
18:53:32 <athan> oh... shoot
18:53:42 <athan> I'm sorry kirill` I don't think I know
18:56:56 <pacak> kirill`: vacuum?
18:57:02 <KaneTW> kirill`: i don't think it is, but i'll take a look at the ghc source
19:01:24 <athan> Can someone help me see why conduit behaves this way? http://lpaste.net/133090
19:01:33 <athan> I would expect the result to be something like [0,1,2]
19:03:20 <athan> DERP
19:03:22 <athan> nevermind
19:03:58 <athan> wait actually do mind
19:04:10 <athan> hmm
19:09:08 <athan> man this is weird
19:09:23 <athan> yield & await are practically implicit arguments
19:15:34 <Guest36908> anyone have a MonadFix instance for ParsecT handy, or want to help me come up with one? :)
19:20:11 <kirill`> athan: If I understood you correctly, compare:
19:20:11 <kirill`> let foo = await >>= maybe (return ()) yield in sourceList [1..10] $= foo $$ consume
19:20:11 <kirill`> let foo = await >>= maybe (return ()) (\k -> do yield k; foo) in sourceList [1..10] $= foo $$ consume
19:24:05 <dumdum> why isn't span (not . (==' ')) "firstword secondword"                  the same as          span . not . (==' ') $ "firstword secondword"
19:25:09 <byorgey> because  A B C = (A B) C = A B $ C,  not  A . B $ C
19:25:55 <byorgey> A . B $ C = A (B C)  instead
19:28:22 <ttt_fff> is there a way to use something like haskell, but on JAVA ?
19:29:11 <timothyh> ttt_fff clojure, scala
19:29:19 <timothyh> for some definition of 'like'
19:29:35 <ttt_fff> typed.clojure does not do typing very well
19:29:38 <ttt_fff> scala is not very pure
19:29:40 <exio4> ttt_fff: Frege? 
19:30:10 <timothyh> scalaz seems to bridge it a little but yeah i don't know of any good ML variant that compiles to jvm
19:30:11 <ttt_fff> exio4: https://github.com/Frege/frege loks nice
19:30:35 <timothyh> ooooh that looks cool
19:31:20 <dumdum> byorgey, so what should I of written?
19:31:21 <ttt_fff> man
19:31:25 <ttt_fff> why have I never heard of rFrege until now
19:32:51 <byorgey> dumdum: what's wrong with  span (not . (==' ')) "firstword secondword" ?
19:33:33 * hackagebot snaplet-wordpress 0.1.1.1 - A snaplet that communicates with wordpress over its api.  http://hackage.haskell.org/package/snaplet-wordpress-0.1.1.1 (DanielPatterson)
19:33:54 <dumdum> byorgey,                    I don't understand when you say A B $ C,  not  A . B $ C. The A B  vs A . B 
19:34:15 <dumdum> byorgey:                    I don't understand when you say A B $ C,  not  A . B $ C. The A B  vs A . B 
19:34:59 <byorgey> dumdum: A B  is the application of function A to argument B.    A . B   is the composition of two functions.  They are quite different.
19:35:34 <byorgey> A B C = (A B) C  since function application associates to the left
19:35:56 <byorgey> So this is  (A B)  applied to C,  which we can optionally write as   (A B) $ C
19:36:03 <byorgey> since $ is just function application
19:36:38 <byorgey> the parentheses are now unnecessary since  $  has lower precedence than function application, so this is the same as   A B $ C
19:37:00 <byorgey> on the other hand,  A . B $ C  = (A . B) C = A (B C)  by definition of  .
19:37:22 <byorgey> (A B) C  and   A (B C)  are quite different
19:37:50 <dumdum> byorgey:    A . B . C . D = A ( B ( C ) ) (D) agreed?
19:37:57 <byorgey> no
19:38:44 <dumdum> byorgey:   completely wrong?
19:39:06 <byorgey> yes
19:39:16 <byorgey> but you can say that  (A . B . C) D = A (B (C D))
19:39:33 <dumdum> what about
19:39:39 <dumdum> byorgey:    A . B . C . D = A ( B ( C ) ) $ D agreed?
19:39:48 <byorgey> no.
19:40:02 <byorgey> so I think the problem is that you are not clear on what . is
19:40:02 <dumdum> how so?
19:40:33 <byorgey> the definition of (.) is:   (f . g) x = f (g x)
19:40:34 <dumdum> byorgey:    potentially. i look at it like classic math f(g(x)) = f.g (x)
19:40:47 <byorgey> yes, that's exactly what it is
19:41:03 <dumdum> so in the above D is my X
19:41:10 <byorgey> but we don't write  f . g . x
19:41:17 <dumdum> ahh
19:41:19 <byorgey> it's (f . g)(x)
19:41:28 <dumdum> byorgey:    A . B . C $  D = A ( B ( C ) )  D agreed?
19:41:44 <byorgey> getting closer, but the parentheses on the right side are wrong
19:42:20 <dumdum> byorgey:  surely you don't just mean   A . B . C $  D = A ( B ( C ) )  (D) agreed?
19:42:30 <dumdum> byorgey:  or A . B . C $  D = A ( B ( C D) )  agreed?
19:42:31 <byorgey> no, that's the same as what you had
19:42:42 <byorgey> aha! now we are getting somewhere =)
19:42:49 <byorgey> yes, agreed
19:43:03 <dumdum> here D is my data
19:43:11 <dumdum> and I'm going for apply C on it
19:43:14 <byorgey> right
19:43:30 <dumdum> now let's go back to my original question..
19:43:33 <dumdum> err what was that again
19:43:38 <co-arbelos> personally, i would skip the $ as much as possible since it more of a replacement for parentheses than an actual operator
19:43:52 <dumdum> i noticed that
19:43:59 <dumdum> atleast in the guide I'm reading
19:44:12 <byorgey> judicious use of $ is fairly common
19:44:13 <dumdum> but it's useful when you want to map a function list, correct?
19:44:28 <byorgey> as long as you understand it is just function application and don't think of it as some magic parentheses thing, you will be fine
19:44:28 <co-arbelos> well, i mean in the discussion.. using it in actual code i don't mind
19:44:56 <byorgey> dumdum: $ doesn't have much of anything to do with mapping over a list
19:45:18 <byorgey> oh, unless by "map a function list" you mean map an argument over a list of functions?
19:46:50 <dumdum> byorgey: you say function application, i don't quite grok that word. I see $ and think I'm going apply what's on the left as a parameter to what's on the right. Thus, whatever is right of $ get's precendence to execute and then is passed left. Is this a poor interpretation?
19:47:19 <Fuuzetsu> f $ x = f x
19:47:55 <byorgey> dumdum: that sounds fine, if perhaps overly specific.  It is literally defined by what Fuuzetsu wrote.
19:47:57 <dumdum> thanks Fuuzetsu, but just quoting the math definition isn't very grokable
19:48:08 <dumdum> to me atleast
19:48:10 <Fuuzetsu> the $ merely serves as a low fixity operator which means ‘f $ g x’ = ‘f (g x)’ and not ‘(f g) x’ 
19:48:10 <byorgey> dumdum: that's not the math definition, it's the Haskell definition.
19:48:22 <ttt_fff> what is the state of the art of "haskell <= > sql" ? I always get the impression taht the part where the sql table gets converted to a haskell list is ugly  /not type safe .. but that we can't do anything better unti lwe reach a point where haskell gains row types
19:48:24 <Fuuzetsu> @src ($)
19:48:24 <lambdabot> f $ x = f x
19:48:57 <dumdum> so just for completeness (f g) x would execute as follows. g would be applied to f, making a partial function, which would then be applied to x, correct?
19:49:17 <Fuuzetsu> ttt_fff: I thought there were some libs which typed the tables instead
19:49:20 <byorgey> dumdum: yes, except I would say "f is applied to g"
19:49:21 <Fuuzetsu> and derived querries for you
19:49:33 <ttt_fff> Fuuzetsu: can you provide a link?
19:49:37 <Fuuzetsu> persistent? or esqueletto? I don't remember, something.
19:49:38 <ttt_fff> Fuuzetsu: that would be amazing
19:49:41 <Fuuzetsu> I can't, I don't remember ;P
19:49:42 <byorgey> instead of "g is applied to f"
19:50:04 <dumdum> byorgey: yes, you are right, sorry
19:50:22 <byorgey> dumdum: now, do you understand that  f g x = (f g) x ?
19:50:24 <dumdum> anyway, now going back to why isn't span (not . (==' ')) "firstword secondword"                  the same as          span . not . (==' ') $ "firstword secondword"
19:50:28 <Fuuzetsu> ttt_fff: http://hackage.haskell.org/package/esqueleto sounds like something you may want?
19:50:29 <kern_chicken_pan> Hi
19:50:35 <dumdum> hmm
19:50:48 <ttt_fff> Fuuzetsu: reading http://www.yesodweb.com/book/persistent first ... will check esqueleto next
19:51:17 <dumdum> i want to apply the not predicate on my data
19:51:20 <kern_chicken_pan> Is it possible to have: data PrimitiveErrors = E1 | E2 inside of data ComplexErrors = Z1 | Z2 ?
19:51:23 <dumdum> then i want to apply span to the result of that
19:51:25 <dumdum> correct?
19:51:31 <byorgey> dumdum: no
19:51:53 <byorgey> dumdum: span takes two arguments.  One is a predicate on list elements, and the second is a list.
19:52:02 <Fuuzetsu> dumdum: because it just isn't, why don't you expand both versions and see what's different?
19:52:07 <ttt_fff> Fuuzetsu: Convenient data modeling. Persistent lets you model relationships and use them in type-safe ways. The default type-safe persistent API does not support joins, allowing support for a wider number of storage layers. Joins and other SQL specific functionality can be achieved through using a raw SQL layer (with very little type safety). An additional library, Esqueleto, builds on top of the Persistent data model, adding type-
19:52:08 <byorgey> dumdum: you can't apply that not predicate to your data, it doesn't even have the right type
19:52:11 * Fuuzetsu lets byorgey handle this
19:52:16 <ttt_fff> persistent does not have joins, but esqueleto adds joins
19:52:35 <kern_chicken_pan> basically I would like to return Either ComplexErrors Result from a function that calls another function that returns PrimitiveErrors and so I want to include the PrimitiveErrors inside of ComplexErrors if that makes any sense at all?
19:53:15 <dumdum> byorgey: thinking
19:53:34 * hackagebot liquidhaskell 0.4.0.1 - Liquid Types for Haskell  http://hackage.haskell.org/package/liquidhaskell-0.4.0.1 (EricSeidel)
19:53:44 <Fuuzetsu> kern_chicken_pan: ComplexErrors = Z1 | Z2 | ZPrimitive PrimitiveErrors ?
19:54:17 <Fuuzetsu> then just wrap your PrimitiveErrors from second function in ZPrimitive
19:54:34 <byorgey> dumdum: span (not . (==' ')) "firstword secondword"  means:  first apply the function 'span' to the predicate (not . (==' ')).  This produces a function (a partial application of span) that expects a list of Chars, and will break it into two pieces based on the predicate.  Then that function is applied to "firstword secondword"
19:55:15 <byorgey> dumdum: it is always the case that  x y z  is parsed/interpreted as  (x y) z
19:55:45 <dumdum> so first apply span to the predicate: span . not (==' '), agree?
19:55:54 <kern_chicken_pan> Fuuzetsu: ah type constructor ok thanks!
19:56:15 <dumdum> woops
19:56:30 <dumdum> so first apply span to the predicate: span . (not . (==' ')), agree?
19:56:34 <byorgey> dumdum: no, . is function composition, not application
19:56:49 <Fuuzetsu> kern_chicken_pan: it may or may not be what you want, it depends on your actual usecase, whether you care about having ZPrimitive or not (for example you might not want to handle potential PrimitiveErrors anywhere else ComplexErrors is used) etc. Depends.
19:56:49 <byorgey> x . y  and  x y   are not the same
19:57:00 <unb3k44n7> Hello all.
19:57:21 <byorgey> hi unb3k44n7 
19:57:36 <kern_chicken_pan> Fuuzetsu: nar, I do, I want to pass them up..
19:57:40 <kern_chicken_pan> thanks!
19:57:49 <ttt_fff> how does opaleye differ from persistent+esqueleretto ?
19:58:06 <ttt_fff> how does opaleye differ from persistent+esqueleretto ? (this is all in the context of haskell + sql bindings)
19:59:02 <dumdum> borgey: is there anyway to get span (not . (/=' ') "test1 test2" using more dots (.)?
19:59:09 <Fuuzetsu> ttt_fff: if that's aimed at me then I have no idea, I know very little about all of them and only threw out some names for you to investigate
19:59:16 <Fuuzetsu> also esqueleto*
19:59:29 <byorgey> dumdum: no, I don't think so
19:59:44 <byorgey> dumdum: at least not other than silly trivial things like adding  id . 
20:02:00 <byorgey> dumdum: I need to go to bed, I hope I was helpful.  Keep at it, you'll get it. =)
20:02:22 <dumdum> thanks byorgey, I hope so
20:02:33 <dumdum> byorgey: goodnight, thanks again
20:03:35 * hackagebot rivet-migration 0.1.0.1 - Postgresql migration support for project management tool.  http://hackage.haskell.org/package/rivet-migration-0.1.0.1 (DanielPatterson)
20:09:53 <tmillc> I am still plagued with not feeling settled with currying. I just read https://wiki.haskell.org/Currying and okay. So div::Int->Int->Int is equiv to div::Int->(Int->Int). So considering div 11 2. div 11 returns a function Int->Int. It feels like the 2 is forgotten at this point.
20:10:05 <tmillc> I understand it enough to accept it but it nags at me for some reason
20:10:34 <Fuuzetsu> tmillc: no, it's not forgotten
20:10:43 <tmillc> if I were to put exactly which Ints are used, it would be like 11->(2->Int) ?
20:10:53 <Fuuzetsu> div 11 2 = (div 11) 2
20:10:59 <Fuuzetsu> you keep applying, you end up with Int
20:13:06 <tmillc> so if I call the result of (div 11) A, then it becomes A 2
20:13:35 * hackagebot glambda 1.0 - A simply typed lambda calculus interpreter, written with GADTs  http://hackage.haskell.org/package/glambda-1.0 (RichardEisenberg)
20:13:46 <Fuuzetsu> tmillc: ‘A 2’?
20:15:02 <tmillc> ahh, I don't know how to explain it. I need to get my hands dirty somehow with currying. It's essentially "Polish Notation" right? Maybe if I look at the math of that to convince myself, it could help
20:15:14 <Fuuzetsu> it's not polish notation, it's currying
20:15:33 <Fuuzetsu> div :: Int -> (Int -> Int)
20:15:59 <Fuuzetsu> you apply an Int such as 11, so ‘div 11 :: Int -> Int’
20:16:15 <Fuuzetsu> you still have a function so you apply another Int such as 2, ‘div 11 2 :: Int’
20:16:41 <tmillc> Ok. That is well said. And at that point, which Int is up to the specifications of div
20:17:22 <Fuuzetsu> what do you mean by ‘which Int’?
20:18:19 <Fuuzetsu> basically currying lets us easily define partially applied functions
20:18:35 <Fuuzetsu> > let div11 = div 11 in (div11 2, div11 3)
20:18:37 <lambdabot>  (5,3)
20:19:11 <Fuuzetsu> because div11 :: Int -> Int
20:19:38 <tmillc> I see
20:19:50 <tmillc> Okay, that was helpful thanks. I'm going to read about partially applied functions
20:19:58 <Fuuzetsu> ;)
20:20:31 <Fuuzetsu> really currying allows you to supply arguments one by one while in most programming languages, you supply all the arguments at once as a tuple 
20:21:02 <tmillc> Yeah. And it was immediately easy to just accept the grammar of it, but sometimes my brain is stubborn and snags on things
20:21:10 <Fuuzetsu> @src curry
20:21:10 <lambdabot> curry f x y = f (x, y)
20:21:13 <Fuuzetsu> @src uncurry
20:21:13 <lambdabot> uncurry f p = f (fst p) (snd p)
20:21:37 <athan> Fuuzetsu: something something adjoint something
20:21:55 <Fuuzetsu> had adjoints on my final today, please no more
20:22:10 <athan> Fuuzetsu: Sorry! I just found out about these ._.
20:22:51 <Fuuzetsu> according to my lecturer and a long time category theory researcher, adjoints are the first actually useful thing in category theory
20:23:27 <athan> Fuuzetsu: I'm also pretty sure they're generalized by kan extensions / ends :s
20:23:36 * hackagebot analyze-client 0.1.0.2 - Client for analyze service  http://hackage.haskell.org/package/analyze-client-0.1.0.2 (DanielPatterson)
20:23:38 <dumdum> Fuuzetsu: is there anyway to compose span with the predicate in               span (not . (/=' ') "test1 test2" 
20:23:41 <Fuuzetsu> isn't it that ends let you explicitly talk about kan extensions?
20:23:44 <dolio> They're just all the same thing.
20:24:02 <dolio> Pick one and you can define the otheres.
20:24:02 <athan> Fuuzetsu, dolio: Hey I said pretty sure :p
20:24:13 <athan> wow, that's really cool :)
20:24:34 <Fuuzetsu> IIRC I read last night that you can take kan extension of something and it always has left and right adjoints
20:24:42 <Fuuzetsu> I haven't stepped into KEs yet anyway
20:24:48 <athan> dumdum: I think you need to compose the predicates with || or && :\
20:25:01 <athan> Fuuzetsu: That's right :)
20:25:10 <athan> I think you can derive curry / uncurry from them, too
20:25:23 <athan> (and reader monad / env comonad)
20:25:48 <Fuuzetsu> No doubt
20:27:04 <dumdum> athan: really? how would i begin to do that?
20:27:56 <athan> dumdum: Something like `p, q :: a -> Bool` ... `\x -> p x && q x` or something :)
20:28:10 * athan whispers All / Any
20:30:17 <Fuuzetsu> athan: for a second there I thought you were trying to tell this poor how to created the adjoint and was very confused about all the Bool-eany stuff in there
20:30:52 <athan> Fuuzetsu: Well, it's basically the same thing
20:30:58 * athan is full of lies
20:31:06 <athan> to the brim
20:31:08 <Fuuzetsu> proof is routine ∎
20:31:25 <Fuuzetsu> also: bookwork ∎
20:31:41 <athan> hahaha.
20:32:33 <johnw> athan: curry and uncurry are the adjoint
20:32:47 <athan> johnw: (:
20:34:02 <johnw> http://comonad.com/reader/2008/kan-extensions-ii/
20:34:05 <johnw> if you haven't seen that already
20:34:13 <athan> johnw: That's where I got it :)
20:34:16 <johnw> ah, ok
20:34:18 <athan> (the "knowledge")
20:34:22 <johnw> I meant, they are the adjunction, not the adjoint
20:34:36 <athan> johnw: So that would be also the density / codensity expressions too, right?
20:34:45 <athan> Or am I backwards?
20:34:54 <Fuuzetsu> dual*
20:34:58 <johnw> Hom(A⊗B,C) ≅ Hom(A,Cᴮ)
20:35:08 <Fuuzetsu> we don't say backwards in category theory, it sounds too primitive
20:35:29 <athan> Fuuzetsu: :P
20:36:23 <athan> johnw: Thank you :)
20:36:31 <johnw> don't know about density/codensity
20:36:42 <johnw> but will read http://comonad.com/reader/2011/a-product-of-an-imperfect-union/
20:37:35 <athan> :)
20:42:07 <dolio> What's the question about codensity?
20:42:27 <Fuuzetsu> the mountain has the answers, come hither with the questions
20:42:38 <athan> dolio: If density / codensity are anologous to curry / uncurry
20:42:42 <athan> (or really how they are)
20:42:52 <athan> (or really really, how they're anologus to adjoints)
20:42:56 <athan> adjunctions*
20:44:14 <dolio> Well, there are connections. I'm not sure they're completely analogous.
20:44:54 <dolio> Density F is Lan F F, and Codensity F is Ran F F.
20:45:28 <dumdum> hello all
20:45:30 <athan> dolio: that makes a lot of sense
20:45:31 <dumdum> in the function
20:45:31 <dumdum> partition (`elem` ['A'..'Z']) "BOBsidneyMORGANeddy" 
20:45:36 <dumdum> imean
20:45:41 <dumdum> in the statement partition (`elem` ['A'..'Z']) "BOBsidneyMORGANeddy" 
20:45:56 <dumdum> what is the order of execution in partition (`elem` ['A'..'Z']) "BOBsidneyMORGANeddy" 
20:45:57 <dolio> Density F is always a comonad, and Codensity F is always a monad.
20:46:04 <athan> dolio: Ahh! okay!
20:46:18 <athan> hmm...
20:46:38 <dumdum> how are the partial functions built up?
20:46:40 <athan> dumdum: That's a really good question :)
20:48:01 <athan> dolio: So is `Density (e,)` _create_ the Env comonad?
20:48:06 <athan> s/is/does
20:48:07 <Fuuzetsu> the predicate won't be evaluated until it's needed
20:48:23 <Fuuzetsu> so it depends on definition of partition when that happens
20:48:31 <dolio> But, if F ⊣ U, then Density F is FU, and Codensity U is UF, which are the comonad and monad from the adjunction.
20:49:18 <dolio> And Ran U Id = F and Lan F Id = U.
20:49:34 <athan> Woah, okay
20:49:57 <athan> (where F ⊣ U is an adjunction, correct?)
20:49:59 <dolio> = being isomorphism, I guess.
20:50:02 <dolio> Right.
20:50:12 <athan> okay. Hmm. thank you dolio
20:50:28 <dolio> So there's lots of connections.
20:50:55 <athan> hmm
20:51:31 <dolio> Like, if Lan F Id exists, that probably means F has a right adjoint.
20:51:56 <dolio> So you can probably specify adjunctions that way.
20:52:03 <athan> ...man. That is too cool.
20:52:10 <dolio> F ⊣ U if U = Lan F Id.
20:52:40 <athan> (just to be verbose, Lan f g ~ forall x. (a -> f x) -> g x?
20:52:48 <dolio> No, that's Ran.
20:53:13 <dolio> Lan f g a = exists e. g e * (f e -> a)
20:53:21 <athan> Ahh!!!
20:53:43 <athan> holy toleto
20:54:36 <dolio> Oh, I guess there's one other condition than existence of the kan extension for an adjunction to exist.
20:54:43 <dolio> But it's close.
20:55:51 <athan> dolio: hmm?
20:57:32 <athan> dolio: unification of f & g in both Lan f g a and Ran f g a? :)
20:57:40 <dolio> n-lab says that F is a left adjoint if Lan F Id exists and is 'absolute', meaning forall G. G(Lan F Id) = Lan F (G.Id) = Lan F G.
20:58:28 <athan> Ahh!! that makes a lot of headway :)
20:58:34 <dolio> That should be G . Lan F Id, I guess.
20:58:35 <athan> thank you so much dolio, I've got to split though
20:58:48 <athan> Perfect :)
21:00:30 <subleq__> why doesn't -fdefer-type-errors behave like rank-n types were enabled? It seems like the only problem with `(\f -> (f 1, f 'a')) id` is that the type checker fails, it should work at run time
21:01:53 <dolio> -fdefer-type-errors doesn't disable type checking. It just delays error reports until runtime.
21:02:12 <subleq__> hm
21:02:13 <dolio> It's not turning Haskell into an untyped language.
21:02:23 <dolio> You can't actually do that.
21:03:03 <subleq__> but my example doesn't require an untyped language, just rankntypes
21:03:19 <pavonia> Why would you want to defer type errors until runtime?
21:03:43 * hackagebot target 0.1.2.0 - Generate test-suites from refinement types.  http://hackage.haskell.org/package/target-0.1.2.0 (EricSeidel)
21:03:45 * hackagebot hmatrix-gsl-stats 0.3 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.3 (VivianMcPhail)
21:03:48 <gridaphobe> so you can test an unrelated piece of code :)
21:04:30 <dolio> It wouldn't work if you wrote exactly that with rank-n types enabled.
21:04:32 <enthropy> you still get the type errors at compile time (they just turn into warnings)
21:05:01 <dolio> But also, it's not going to turn on other extensions just because you deferred type errors.
21:05:17 <subleq__> dolio: well, even turning on the extension doesn't make it work
21:05:37 <dolio> Right. You need an annotation for that to work with rank-n types.
21:06:02 <subleq__> You only have to write the annotation because the type checker doesn't know which of the valid type signatures to pick. But it does know at run time
21:07:02 <dolio> No. Types don't exist at runtime.
21:07:56 <subleq__> but you just said -fdefer-type-errors runs the type checker at runtime
21:08:06 <c_wraith> No, it compiles the type errors into the binary
21:08:06 <dolio> No. I said it reports errors at runtime.
21:09:13 <subleq__> well this is bullshit
21:09:30 <subleq__> someone told me -fdefer-type-errors basically makes haskell dynamically typed
21:09:35 <dolio> There's no point in running the type checker at runtime, assuming it'd use the same algorithm.
21:09:56 <dolio> Because it'd infer a type for f once, and use it. That's how the type checking works.
21:10:58 <dolio> And the problem is inferring one type isn't good enough for your example, unless it's polymorphic.
21:12:38 <dolio> Anyhow, -fdefer-type-errors doesn't make Haskell dynamically typed, no. It can't be dynamically typed.
21:12:58 <dolio> Type classes are dispatched based on inferred types.
21:13:29 <joneshf-laptop> is there a thing like this: `\n i j -> if i == n then j else i` that uses actual functions rather than syntax?
21:13:33 <dolio> So you can't just not do inference.
21:13:49 <subleq__> Wouldn't it be possible to implement it with explicitly typed [at run time] objects?
21:13:59 <subleq__> and type class dicts become vtables
21:14:07 <bplaxco> is www.haskell.org down right now or is it just me?
21:14:48 <subleq__> and types are checked only when stuff gets evaluated
21:15:18 <Fuuzetsu> @src bool
21:15:18 <lambdabot> Source not found. My brain just exploded
21:15:20 <Fuuzetsu> :t bool
21:15:21 <lambdabot> a -> a -> Bool -> a
21:15:43 <Fuuzetsu> joneshf-laptop: ^ but with predicate in the end
21:15:46 <Fuuzetsu> which makes it compose better
21:15:58 <joneshf-laptop> Fuuzetsu, thanks
21:17:01 <dolio> I don't know if something could be made to work. But it would obviously be completely different than the way GHC works right now.
21:17:31 <bplaxco> hey joneshf-laptop could you see if www.haskell.org will load for you? (Just a sanity check)
21:18:23 <bplaxco> joneshf-laptop, nm it finally came back up... weird..
21:18:50 <subleq__> Yeah, now i'm talking about a completely separate implementation. But it seems interesting to have a language like dynamically typed haskell, were static type errors are just warnings saying there might be a problem
21:19:11 <subleq__> and it may or may not work at runtime
21:19:33 <enthropy> subleq__: what happens for methods like return :: Monad m => a -> m a ?
21:19:44 <Hijiri> I think there are some type systems like that, where they only error out if it's guaranteed to fail at runtime
21:20:07 <Fuuzetsu> subleq__: what would be the point of such language
21:20:26 <Hijiri> I mean, where type checking only happens up to the point where it determines that it's possible that the term might be well-typed
21:20:56 <subleq__> Fuuzetsu: I don't know. It's annoying to have to write a type annotation for \f -> (f 1, f 'a')
21:21:33 <Hijiri> at runtime you still wouldn't know what type to assign 1
21:21:35 <Fuuzetsu> subleq__: so just throw away types all together?
21:21:44 <Fuuzetsu> it's silly
21:21:44 <Hijiri> oh, for the whole thing
21:22:11 <Fuuzetsu> or rather give up any kind of sanity because one annotation is annoying
21:22:21 <subleq__> Fuuzetsu: eh, you could type check most of your program but not the iffy bits
21:24:09 <Fuuzetsu> there are no iffy bits
21:24:21 <Fuuzetsu> at least an annotation is not an iffy bit IMHO
21:24:39 <Fuuzetsu> and just going ‘screw it whatever’ is haradly a justification IMHO…
21:26:50 <subleq__> Fuuzetsu: 'screw it whatever' is like 75% of deployed code in the world
21:27:04 <dolio> Making a fundamentally different language is a lot of work for a case that I don't run into very often.
21:27:39 <dolio> Also, how do you decide what's iffy and what's just wrong?
21:27:40 <Fuuzetsu> subleq__: so throw more garbage out there?
21:28:13 <subleq__> It would be fundamentally more expressive, it wouldn't just let you not write annotations
21:28:46 <subleq__> f 1 = 0
21:28:50 <subleq__> f 'a' = 1
21:28:55 <enthropy> you could write "\f -> (f 1, f 'a')" as "\f g -> (f 1, g 'a')"
21:29:16 <Fuuzetsu> subleq__: but we tend to not want that
21:29:23 <Fuuzetsu> and when we do we make a distinction
21:34:52 <subleq__> you should try to live more adventurously Fuuzetsu 
21:37:09 <Fuuzetsu> if I wanted to do inane crap you can't really reason about I'd be using a different language
21:37:15 <dolio> I'm sure many of us have used languages that worked like that before.
21:37:19 <dolio> And aren't interested.
21:42:58 <rien> in Data.Aeson.Schema.Types, for instance, there's a function empty :: Schema ref. what does ref mean and why is it always unspecified?
21:44:46 <rien> > :set -XQuasiQuotes
21:44:47 <lambdabot>  <hint>:1:1: parse error on input ‘:’
21:44:57 <rien> > -XQuasiQuotes
21:44:59 <lambdabot>  Not in scope: data constructor ‘XQuasiQuotes’
21:46:42 <rien> in other words, why when I ask :t [schemaQQ| { "type": "number", "minimum ": 0 } |] does ghci not know the type enough that it only tells me :: Schema ref ?
21:46:44 <Fuuzetsu> you can't turn it on through lambdabot
21:47:17 <rien> Fuuzetsu: I felt lucky
21:51:22 <Myrl-chan> Welp.
21:51:50 <Myrl-chan> It'd have been nice if there was a function of type :: (Eq a) => a -> a -> a -> a
21:52:03 <Fuuzetsu> doing what?
21:52:11 <Myrl-chan> With `foo x y z` where if x == y, return z, otherwise return x/y.
21:52:16 <Myrl-chan> return x or y*
21:52:24 <dumdum> What is y in this function groupBy (\x y -> (x > 0) == (y > 0)) [1, 2, 3, -1] 
21:52:33 <Fuuzetsu> Myrl-chan: that's not the type of that function
21:52:46 <Myrl-chan> Fuuzetsu: Really?
21:52:47 <arkeet> Fuuzetsu: I don't think / is division.
21:52:47 <dumdum> x binds to the list
21:52:47 <Fuuzetsu> :t \x y z -> if x == y then return z else return x
21:52:49 <lambdabot> (Eq a, Monad m) => a -> a -> a -> m a
21:52:50 <dumdum> but what about y?
21:52:55 <arkeet> and return is not monad return.
21:53:00 <Fuuzetsu> oh
21:53:04 <arkeet> dumdum: x does not do that.
21:53:09 <Myrl-chan> Fuuzetsu: Ah, I don't mean monad return, sorry. :P
21:53:12 <arkeet> the function is applied many times, with different values for x and y.
21:53:27 <Fuuzetsu> :t bool z x (x == y)
21:53:28 <lambdabot>     Ambiguous occurrence ‘x’
21:53:29 <lambdabot>     It could refer to either ‘L.x’,
21:53:29 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:158:1
21:53:35 <Fuuzetsu> :t \x y z -> bool z x (x == y)
21:53:36 <lambdabot> Eq a => a -> a -> a -> a
21:53:45 <Myrl-chan> Fuuzetsu: Ah cool.
21:53:59 <arkeet> :t \x y z -> if x == y then x else z
21:54:01 <lambdabot> Eq a => a -> a -> a -> a
21:54:18 <Myrl-chan> Yeah, I've done the latter. I should just make a function for it.
21:54:18 <Myrl-chan> Thanks.
21:54:33 * arkeet wonders in what case this would be useful.
21:55:02 <Myrl-chan> arkeet: Default values.
21:55:30 <Myrl-chan> arkeet: if (x == "/") then "/index.hs" else x
21:56:09 <Myrl-chan> This seems to be something you see more often in imperative languages.
21:56:36 <aaronm04> That is valid CoffeeScript :P
21:57:05 <Myrl-chan> :t bool
21:57:06 <lambdabot> a -> a -> Bool -> a
21:57:10 <dumdum> arkeet: ok i looked at :t groupBy, but still what are x and y?
21:57:18 <arkeet> they are elements of teh list.
21:57:27 <arkeet> :t groupBy
21:57:28 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
21:57:42 <dumdum> arkeet: which elements, because my list has more than 2
21:58:02 <arkeet> whichever elements it needs to look at to group them.
21:58:16 <dumdum> arkeet: does it move through 2 elements at a time (sliding window style)
21:58:20 <arkeet> no
21:58:24 <arkeet> it comapres the first element with the rest
21:58:43 <dumdum> arkeet: comparing the head with the tail?
21:58:52 <dumdum> arkeet: the head is of type a, then tail pa[
21:58:57 <dumdum> arkeet: the head is of type a, then tail [a]*
21:59:03 <arkeet> > groupBy (<) [1,4,2,0]
21:59:04 <lambdabot>  [[1,4,2],[0]]
21:59:19 <arkeet> because 1<4 and 1<2 but not 1<0
21:59:59 <arkeet> @src groupBy
21:59:59 <lambdabot> groupBy _  []     =  []
21:59:59 <lambdabot> groupBy eq (x:xs) =  (x:ys) : groupBy eq zs
21:59:59 <lambdabot>     where (ys,zs) = span (eq x) xs
22:03:28 <Kneiva> > groupBy id [1,1,2,2,2,3,4,4]
22:03:29 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ a -> Bool
22:03:30 <lambdabot>      Expected type: a -> a -> Bool
22:03:30 <lambdabot>        Actual type: (a -> Bool) -> a -> Bool
22:03:49 <Kneiva> > groupBy (==) [1,1,2,2,2,3,4,4]
22:03:51 <lambdabot>  [[1,1],[2,2,2],[3],[4,4]]
22:04:04 <arkeet> > groupBy (const id) [False,True,True,False,True,False]
22:04:06 <lambdabot>  [[False,True,True],[False,True],[False]]
22:04:41 <pacak> > groupBy (compare `on` id) [1,1,2,2,2,3,44]
22:04:43 <lambdabot>      Couldn't match type ‘Ordering’ with ‘Bool’
22:04:43 <lambdabot>      Expected type: a -> a -> Bool
22:04:43 <lambdabot>        Actual type: a -> a -> Ordering
22:04:56 <unb3k44n7> Evening, lambdabot.
22:05:00 <pacak> > groupBy ((==) `on` id) [1,1,2,2,2,3,44]
22:05:00 <dumdum> arkeet: sorry arkeet, i must be a dumdum, as i can't see what groupBy (<) [1,4,2,0] is doing
22:05:02 <lambdabot>  [[1,1],[2,2,2],[3],[44]]
22:05:10 <arkeet> dumdum: focus on 1
22:05:30 <unb3k44n7> And everyone.
22:05:31 <arkeet> take all the following elements x where 1 < x
22:05:33 <arkeet> that's a group
22:05:35 <dumdum> arkeet: the head of the list?
22:05:37 <arkeet> then repeat with the rest
22:05:38 <arkeet> yes
22:06:33 <dumdum> arkeet: then repeat with the list? so do we go with all elements less than 4?
22:07:03 <arkeet> no, 4 is already part of the first group.
22:07:32 <arkeet> > groupBy (<) [1,4,2,0,5,-1,0,1,-2,0]
22:07:34 <lambdabot>  [[1,4,2],[0,5],[-1,0,1],[-2,0]]
22:07:43 <arkeet> idk
22:07:49 <arkeet> > groupBy (<) [1,4,2,0,5,-1,2,0,1,-2,1,0]
22:07:51 <lambdabot>  [[1,4,2],[0,5],[-1,2,0,1],[-2,1,0]]
22:08:06 <arkeet> in each group, the first element is smaller than the rest.
22:08:08 <arkeet> that's it.
22:08:43 <arkeet> @src groupBy
22:08:43 <lambdabot> groupBy _  []     =  []
22:08:43 <lambdabot> groupBy eq (x:xs) =  (x:ys) : groupBy eq zs
22:08:43 <lambdabot>     where (ys,zs) = span (eq x) xs
22:08:51 <unb3k44n7> What are you guys up to?
22:09:00 <arkeet> consider groupBy (<) (1:[4,2,0]) 
22:09:16 <arkeet> (ys,zs) = span (1 <) [4,2,0]
22:09:21 <arkeet> > span (1 <) [4,2,0]
22:09:24 <lambdabot>  ([4,2],[0])
22:13:21 <unb3k44n7> Do you know how to connect to more than one server at a time without disconnecting the current one?
22:13:43 <Fuuzetsu> use a different port?
22:14:09 <enolan> do you mean irc? or in general?
22:14:20 <unb3k44n7> IRC
22:14:28 <unb3k44n7> Using the mIRC client.
22:14:52 <enolan> I don't think most clients are set up to do that. You can probably run two mIRC instances at once though
22:15:13 <Fuuzetsu> most clients written after 1980 support multiple networks
22:15:24 <hectortrope> Hello Haskelians
22:15:25 <unb3k44n7> I was thinking that.. or two different clients. Thought there would be a way to do it all on one. But that's ok.
22:15:41 <unb3k44n7> Thank you. 
22:17:29 <unb3k44n7> You know this is the only server I've found so far that people are actually civil, use proper typing skills, and are friendly? Tsk. You guys are special. 
22:18:02 <unb3k44n7> Channel, rather. Not server.
22:18:30 <pacak> Because unfriendliness won't typecheck?
22:18:49 <Fuuzetsu> -defer-friendliness-check
22:19:04 <unb3k44n7> Um, maybe.
22:19:44 <subleq__> I remember but can't find a discussion about typing a sequence of 100 transformations, a->b, b->c, c->d...
22:19:44 <arkeet> unb3k44n7: do you have something haskell-related to talk about?
22:20:11 <unb3k44n7> Not at the moment, Arkeet. Sorry.
22:20:37 <arkeet> just letting you know we generally try to stay on topic
22:20:50 <unb3k44n7> Ok.
22:20:54 <Fuuzetsu> there's #haskell-blah though!
22:20:57 <arkeet> there is.
22:21:18 <pavonia> Or #freenode for general network related questions
22:22:46 <unb3k44n7> Sorry for interrupting. 
22:23:33 <hectortrope> hi guys http://www.quora.com/What-is-the-best-programming-language-to-learn-1
22:23:58 <hectortrope> should I learn some other functional languahge to learn haskel like wriiten i above
22:24:00 <hectortrope> ??
22:24:06 <Fuuzetsu> I'll be very disappointed if I don't see what I want on there
22:24:20 <Fuuzetsu> oh, it's a Q&A site
22:24:21 <Fuuzetsu> nvm
22:25:11 <feryll> Is there a way to use a multi-line do-block as the first parameter of a multiparameter function?
22:25:31 <dumdum> arkeet: I'm probably wrong, but doesn't groupBy seem a little bit odd in it's behavior, how once the predicate fails, it then uses the next element as the head of the list 
22:25:32 <feryll> The way I'm trying it with parantheses it's acting like each line becomes a parameter trying to be fed to the function.
22:25:38 <feryll> parentheses*
22:25:57 <arkeet> dumdum: generally groupBy is supposed to be used with an equivalence relation
22:25:57 <pavonia> feryll: Your indentation is probably wrong
22:26:07 <arkeet> such as (==)
22:26:10 <kadoban> feryll: Yes, you can. Yeah the indentation has to be pretty specific.
22:26:26 <feryll> Link to a documentation, or should I pastebin my attempt?
22:26:46 <arkeet> > groupBy (==) [1,2,2,3,3,2,2]
22:26:48 <lambdabot>  [[1],[2,2],[3,3],[2,2]]
22:26:49 <kadoban> Well, the report pretty specifically spells out the indentation rules, but pastebin will probably be quicker.
22:26:58 <kadoban> lpaste preferably
22:27:33 <lpaste> feryll pasted “No title” at http://lpaste.net/133098
22:27:43 <jle`> Cale: yeah, it was a shameful instance
22:27:51 <jle`> i sort of pepper the docs with that admission
22:27:58 <jle`> maybe i should just kill the typeclass altogether
22:28:08 <jle`> heh
22:28:34 <kadoban> feryll: I would think the body of the do block has to be more indented than the 'do' itself
22:28:45 <feryll> Ah, let me try that
22:28:55 <bitantics> Cross question from #haskell-beginners (no one's there): Hey everyone, I'm having trouble with return values and type instances: http://lpaste.net/1611977444678434816 . I'm confused why it's saying the returned type is "ParseTime (Parser UTCTime)". It should just be Parser UTCTime
22:29:32 <jle`> bitantics: it's not saying the return type is ParseTime (Parser UTCTime), it's saying that it expects an instance of the ParseTime typeclass for Parser UTCTime
22:31:54 <ReinH> jle`: you know, ghc's user experience could be significantly improved just by adjusting the error messages it already has...
22:31:57 <bitantics> jle`: I don't understand why it's expecting that? From my intuition parseTimeOrError should return a UTCTime (which is an instance of ParseTime), then it should be returned upwards to be UTCTime (expected to be an instance of Parser)
22:32:24 <feryll> kadoban: Nevermind, turns out blah4 was actually a multiparameter -> IO function itself which I didn't paranthesize, and the do-block syntax was even willing to forgive my indentation.
22:32:43 <kadoban> Ah okay
22:32:46 <ReinH> bitantics: what is the type of parseTimeOrError?
22:35:52 <bitantics> ReinH: documented type: ParseTime t => Bool -> TimeLocale -> String -> String -> t (https://hackage.haskell.org/package/time-1.5.0.1/docs/Data-Time-Format.html#v:parseTimeOrError) From GhcMod: Bool -> TimeLocale -> String -> String -> Parser UTCTime
22:35:53 <bitantics>  
22:35:53 <bitantics> -> t
22:36:25 <bitantics> forget about that last "-> t" i'm not sure where that came from :/
22:39:17 <pavonia> bitantics: And what's the type of parseField?
22:41:12 <bitantics> pavonia: Docs: Field -> Parser a (https://hackage.haskell.org/package/cassava-0.4.2.4/docs/Data-Csv.html#v:parseField), GhcMod: Field -> Parser UTCTime
22:41:34 <jle`> ReinH: yup, definitely
22:41:53 <jle`> sometimes i consider actually looking at how ghc reports errors
22:42:23 <jle`> cause i feel like that might be some place where there arne't enough contributors
22:42:33 <jle`> maybe
22:42:53 <pavonia> bitantics: So parseTimeOnError has to return a Parser UTCTime value but it doesn't in your case
22:47:05 <pavonia> bitantics: Or to put it differently: GHC expects a Parser UTCTime but gets something of type "ParseTime t", so it tries to find an instance of ParseTime (Parser UTCTime) which fails
22:47:50 <bitantics> pavonia: so do I have to wrap it in Parser? Parser is a data constructor, so I'm now trying to do "parseField t = Parser $ ..." but it says Parser is not in scope although I'm importing Data.Csv
22:48:43 <bitantics> pavonia: okay that makes sense, it was just making a good, but incorrect guess
22:48:43 <pavonia> There's no such data constructor
22:49:11 <pavonia> Well, no visible one :p
22:49:11 <bitantics> oh you're right
22:49:22 <bitantics> well how do I make it a parser then?!
22:49:37 <bitantics> how about with a type annotation?
22:50:05 <pavonia> There's a Monad instance so you can turn a value into a parser that always accepts using "return"
22:52:32 <bitantics> pavonia: so I put a "return $" in front of the function body and it totally just worked! I'm don't fully understand how this semantically makes sense though
22:52:35 <bitantics> thanks
22:53:20 <Myrl-chan> hai~
22:54:02 <Myrl-chan> I'm trying to parse a file path, delimited by /, of course.
22:54:26 <Myrl-chan> So, my idea is to convert that to a list, "x/y" -> ["x", "y"]
22:55:11 <dmj`> :t splitOn
22:55:13 <lambdabot> Eq a => [a] -> [a] -> [[a]]
22:55:13 <Myrl-chan> And afterwards, run that to something which acts like a stack, a non-".." would push it to the stack, a ".." would pop from the stack.
22:55:14 <arkeet> why not use something from System.FilePath?
22:55:20 <dmj`> > splitOn "/" "x/y"
22:55:22 <lambdabot>  ["x","y"]
22:55:43 <Myrl-chan> And if it pops from an empty stack, it will return Nothing.
22:55:48 <arkeet> hm.
22:56:00 <Myrl-chan> If it succeeds though, it will return Just path
22:56:06 <pavonia> bitantics: You probably still have to add a case if the parsing fails
22:56:27 <Myrl-chan> arkeet: I'm thinking of using the state monad for this, along with monad transformers.
22:56:51 <arkeet> what do you need a state monad for?
22:56:59 <Myrl-chan> arkeet: To emulate the stacdk, I guess.
22:57:00 <Myrl-chan> stack*
22:57:39 <arkeet> a list is a stack.
22:57:45 <Myrl-chan> arkeet: Yeah.
22:57:49 <arkeet> why not just use something that operates (perhaps recursively) on a list?
22:57:58 <Myrl-chan> So, like foldl or something?
22:58:03 <arkeet> you could use the Maybe monad for failure.
22:58:05 <bitantics> pavonia: from my understanding 'parseTimeOrError' will throw a fatal error which for my case is sufficient enough for my current use
22:58:18 <arkeet> maybe foldlM
22:58:23 <arkeet> :t foldlM
22:58:25 <lambdabot>     Not in scope: ‘foldlM’
22:58:25 <lambdabot>     Perhaps you meant one of these:
22:58:25 <lambdabot>       ‘F.foldlM’ (imported from Data.Foldable),
22:58:29 <arkeet> :t F.foldlM
22:58:30 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
22:58:33 <arkeet> with m = Maybe
22:59:14 <arkeet> but you might also consider looking at canonicalizePath from System.Directory
22:59:52 <arkeet> well, hmm
23:00:17 <arkeet> that also uses the cwd
23:02:10 <Myrl-chan> Hmmm
23:03:20 <arkeet> more or less depends on what you want to do, but have a look at what System.Directory and System.FilePath provide you
23:11:52 <unb3k44n7> Does anyone want to talk in PM? I'mnot trying to troll. I think there are really interesting people in here and I'd like to talk to some of you w/o bothering your coding language.
23:12:21 <Haskellfant> there is #haskell-blah for that
23:12:23 <kadoban> unb3k44n7: #haskell-blah
23:12:50 <Myrl-chan> Welp.
23:13:31 <Myrl-chan> body = F.foldlM body_ (Just []); body_ :: [String] -> String -> Maybe [String]
23:13:35 <Myrl-chan> :t body
23:13:37 <lambdabot> Not in scope: ‘body’
23:13:41 <Myrl-chan> :t F.foldlM
23:13:43 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
23:14:01 <Myrl-chan> Oh. I see.
23:17:08 <Myrl-chan> Worked better than I expected, thanks arkeet.
23:17:41 <Myrl-chan> arkeet: What do you think is a meaningful name for this? relativeToAbsolute?
23:19:13 <Myrl-chan> Needlwess to say I suck at maknig names.
23:23:20 <Myrl-chan> >intercalate "/" ["Foo", "Bar"]
23:23:47 <Myrl-chan> Hmm
23:42:35 <kaidelong> @botsnack
23:42:36 <lambdabot> :)
23:42:59 <kaidelong> > intercalate "/" ["Foo","Bar"]
23:43:01 <lambdabot>  "Foo/Bar"
23:54:55 <ColaEuphoria> i'm using ghc 7.8.4 and i'm still new and not entirely sure how to link against libraries (in linux). i've installed the SDL2 bindings with cabal and imported SDL in my haskell code, but i am unsure of how to link it
23:55:11 <ColaEuphoria> i've tried ghc with -lSDL -lSDL2 -lsdl -lsdl2 and they don't seem to work
23:55:58 <ColaEuphoria> "Could not find module `SDL`"
23:57:00 <mauke[> that doesn't look like a linker error
23:57:17 <mauke[> what's your code and the full error message?
23:57:50 <ColaEuphoria> it errors on the line where i declare `import qualified SDL`
23:57:58 <ColaEuphoria> 00.hs:6:18:
23:57:58 <ColaEuphoria>     Could not find module ‘SDL’
23:57:58 <ColaEuphoria>     Use -v to see a list of the files searched for.
23:58:27 <mauke[> ok, so the SDL module is not installed
23:59:21 <ColaEuphoria> $ cabal install sdl2
23:59:21 <ColaEuphoria> Resolving dependencies...
23:59:21 <ColaEuphoria> All the requested packages are already installed:
23:59:21 <ColaEuphoria> sdl2-1.3.0
23:59:38 <mauke[> sdl2 doesn't provide a module called 'SDL'
23:59:43 <mauke[> http://hackage.haskell.org/package/sdl2
23:59:51 <mauke[> it provides Graphics.UI.SDL
