00:08:48 <maxx_> pacak why?
00:09:00 <maxx_> asking this as someone who always got HP before
00:11:21 <m_ryan> how to create 'when' without an expression in the last statement? is it possible?
00:13:14 <lyxia> ruslan_t: Sure that's a category.
00:13:34 <frerich> m_ryan: You mean the expression passed to 'when' which evaluates to a Bool? What do you want 'when' to do in this case?
00:13:36 <merijn> m_ryan: What would that do?
00:13:54 <m_ryan> frerich and merijn: yes
00:14:32 <ruslan_t> lyxia: so the object is Int (and not 1,2,3,4 as objects)
00:18:13 <lyxia> ruslan_t: right.
00:18:26 <merijn> m_ryan: I'm still confused what that would possibly do...
00:18:43 <m_ryan> merijn: i will paste my code.
00:24:25 <m_ryan> merijn: http://lpaste.net/132978
00:27:18 <frerich> m_ryan: I'm not sure which of the code triggers those errors, but you could trace it down by commenting out your code and using 'when (usa > 20) $ return ()' instead.
00:27:43 <frerich> m_ryan: A second thought: '\i -> (i - i + 1, i - i + 1)' is the same as '\_ -> (1, 1)' (or 'const (1,1)'), no?
00:30:34 <ronh-> apart from a more general type - yes
00:31:06 <m_ryan> frerich: when (usa > 20) $ return (), does not return any errors
00:33:25 <m_ryan> frerich: so i guess the errors goes on the next statement i have.. 
00:36:07 <m_ryan> frerich: does, \_ = \i? why
00:38:46 <liste> m_ryan _ means "I don't care about this value" when pattern matching
00:38:59 <m_ryan> liste: thank you :)
00:39:10 <mauke[> if you're familiar with vi, it's like the _ register :-)
00:39:33 <m_ryan> mauke[ you mean vim?
00:39:49 <m_ryan> not familiar with it.. hehehe 
00:39:56 <mauke[> ah, I do indeed
00:43:49 * hackagebot filediff 1.0.0.5 - Diffing and patching module  http://hackage.haskell.org/package/filediff-1.0.0.5 (bgwines)
01:23:39 <freusque> hello all,
01:24:21 <freusque> my code contains ("blah" ++ (takeFileName out))
01:24:23 <freusque> where takeFileName :: FilePath -> FilePath
01:24:39 <freusque> hlint suggests ("blah" ++ takeFileName out)
01:24:46 <freusque> which compiles
01:25:00 <freusque> I fail tounderstand how that  type checks
01:25:14 <mauke[> it's the exact same code
01:25:20 <fyolnish> doesn't ++ have lower precedence than a function call?
01:25:23 <opqdonut> yes
01:25:24 <mauke[> you wrote it. why are you surprised that it typechecks?
01:25:26 <freusque> as I understand ++ has higher precedence than function application
01:25:32 <opqdonut> lower
01:25:34 <freusque> ah
01:25:36 <opqdonut> function application has highest
01:25:40 <freusque> ah
01:25:44 <mauke[> freusque: no operator has higher precedence than function application
01:25:56 <mauke[> record update is higher, but that's not an operator
01:25:56 <freusque> thank you all :)
01:26:05 <freusque> okay
01:26:40 <mauke[> also at-patterns if you squint hard
01:27:19 <freusque> I do not know what at-patterns are.
01:27:45 <freusque> google doesn't either, maybe you mean as-patterns?
01:28:00 <mauke[> I probably do
01:28:08 <mauke[> but they're written using the at sign, @
01:28:08 <freusque> ok
01:28:41 <mauke[> > let f x @ y = x + y in f 3
01:28:43 <lambdabot>  6
01:29:00 <mauke[> but no one writes it like that. it's always f x@y
01:30:16 <freusque> thanks
01:30:24 <fyolnish> wow that's indecipherable 
01:30:28 <fyolnish> where is y set?
01:30:51 <mauke[> ^ there
01:31:16 <mauke[> one of the possible forms of a pattern is <identifier> @ <pattern>
01:31:29 <freusque> > let f x @ (y,z) = x in f (1,8)
01:31:31 <lambdabot>  (1,8)
01:31:31 <mauke[> which matches <pattern> but also binds <identifier> to the result
01:31:50 <fyolnish> huh
01:31:55 <fyolnish> I guess I can parse it
01:32:00 <mauke[> > let foo x@(y : z) = (x, y, z) in foo "hello"
01:32:01 <lambdabot>  ("hello",'h',"ello")
01:32:02 <fyolnish> still hurts my brain a bit
01:32:19 <mauke[> fyolnish: it gets better. you can do this at the top level: a@b@c = 42
01:33:56 <fyolnish> ._.
01:36:03 <mauke[> hmm, let's see
01:36:09 <mauke[> > Node 42 []
01:36:11 <lambdabot>  Node {rootLabel = 42, subForest = []}
01:36:20 <mauke[> > show (Node 42 [])
01:36:21 <lambdabot>  "Node {rootLabel = 42, subForest = []}"
01:36:34 <mauke[> > show (Node 42 []) { rootLabel = "hello" }
01:36:35 <lambdabot>      No instance for (Num [Char]) arising from the literal ‘42’
01:36:35 <lambdabot>      In the first argument of ‘Node’, namely ‘42’
01:36:35 <lambdabot>      In the expression: (Node 42 [])
01:36:48 <mauke[> > show (Node 42 []) { rootLabel = 666 }
01:36:49 <lambdabot>  "Node {rootLabel = 666, subForest = []}"
01:36:58 <mauke[> ok, that's an example with record update syntax
01:37:55 <echo-area> So record update has higher priority than function application
01:38:01 <mauke[> yes
01:41:31 <xelxebar> mauke[: was unaware of that. thannks for the instructive example
01:43:52 * hackagebot BufferedSocket 0.2.0.0 - A socker wrapper that makes the IO of sockets much cleaner  http://hackage.haskell.org/package/BufferedSocket-0.2.0.0 (tmore)
01:44:07 <xelxebar> is it possible to be evil and change the fixity of function application or record update?
01:45:02 <Cale> no
01:45:41 <Cale> Well, yes, you could write a preprocessor or modify GHC's parser.
01:46:09 <mauke[> you can't do it within the language
01:47:09 <tdammers> I guess the closest thing "within the language" would be to do it with quasi-quotes
01:47:43 <tdammers> [evil|foo bar * baz|] -- would then compile into foo (bar * baz), for example
01:48:37 <xelxebar> Cale: yeah. I immediately thought "hack ghc" and then ended up reading about fixity in the haskell report
01:49:10 <xelxebar> tdammers: template haskell... I've not gotten there yet. seems like this kind of thing would be quite frowned upon though
01:49:33 <tdammers> frowned upon, maybe not, but people would definitely wonder why on earth you'd want that
01:49:53 <tdammers> it's the haskell equivalent of #define BEGIN { / #define END }
01:50:20 <tdammers> i.e., you're trying to bend haskell into being a different language just because you don't feel like writing idiomatic haskell
01:51:17 <xelxebar> at the beginning of learning haskell, I definitely spent several hours trying to decypher errors that turned out to just be differences in my and ghc's fixity assumptions
01:52:07 <xelxebar> and still feel weird writing foo a . baz instead of (foo a) . baz
01:52:32 <xelxebar> guess you get used to it though? or were your intutions pretty much in line with Haskell when you began learning?
01:53:32 <mauke[> IIRC I got used to it pretty quickly
01:53:39 <mauke[> it's basically the opposite of how perl works
01:53:47 <Rembane> xelxebar: I still spend too much time doing that, so my code is riddled with superstitious brackets. :)
01:54:04 <mauke[> (i.e. function application has very high precedence; in perl it's very low)
01:54:19 <Rembane> >>= bites me now and then.
01:54:54 <jle`> is there any mono-traversable equivalent of liftA2-like things?
01:55:08 <jle`> (Element a -> Element a -> Element a) -> (a -> a -> a)
01:56:42 <xelxebar> Rembane: yes. I remember banging my head against >>= and $ in my xmonad config a while back.
01:57:11 <mauke[> I try to avoid $
01:57:50 <f|`-`|f> (because it gets weird, parentheses make more legible sense)
01:58:15 <tdammers> mauke[: easy solution, don't write perl :P
01:58:34 <tdammers> but anyway, fwiw, I like the a . b . c $ d idiom
01:58:48 <tdammers> except in an applicative-style context
01:58:59 <tdammers> foo <$> bar . baz $ quux -- dammit
01:59:16 <mauke[> tdammers: solution to what problem?
01:59:16 <f|`-`|f> would rather lift, bro
01:59:40 <tdammers> mauke[: perl and haskell behaving in opposite ways
01:59:46 <mauke[> no, perl helped me
01:59:53 <tdammers> ah, ok
01:59:58 <tdammers> in that case, write more perl
02:00:09 <xelxebar> tdammers: I find myself :info'ing operators for just this reason a lot lately
02:00:13 <mauke[> I was already familiar with the idea of not having to write f(x) for a function call
02:00:21 <mauke[> tdammers: yay!
02:00:37 <jle`> i always have to resist closing your open bracket_ mauke[                                       ]
02:00:47 <f|`-`|f> mono-traversable?
02:00:49 <tdammers> mauke[: perl and I have never gotten around to becoming friends though
02:01:10 <tdammers> currently having a hard time being friends with clojure... we're going to a rough patch
02:01:24 <mauke[> it's the only "dynamic language" I know that gets scoping right
02:01:25 <jle`> f|`-`|f: it generalizes Functor and Traversable and Foldable to things with the wrong kind...and things like map/traverse always having to end up with the same type as the start
02:01:44 <f|`-`|f> So monoidal, instead of functor
02:01:51 <f|`-`|f> well, moinoidish
02:02:07 <ronh-> mauke scheme/CL don't?
02:02:08 <jle`> like, you know how Text is kind of like a list of Char
02:02:18 <tdammers> mauke[: I bet. Python certainly doesn't, PHP thinks "scope" is some kind of skin care product, and JavaScript was in a hurry so they did a half-assed copy of scheme
02:02:22 <jle`> but you can't really use `fmap` on Text, even though it makes perfect sense
02:02:34 <tdammers> given the choice between those three, I'd pick JS though, hands down
02:02:36 <jle`> fmap :: (Char -> Char) -> Text -> Text
02:02:45 <jle`> mono-traversable makes things like this work
02:02:50 <f|`-`|f> So instead of having a t Char
02:02:52 <xelxebar> so, semi-group? quasi-group? magma?
02:02:55 <f|`-`|f> You have a Chars
02:02:57 <f|`-`|f> ok
02:03:14 <f|`-`|f> And you can't f up a Chars
02:03:50 <jle`> mhm
02:04:01 <mauke[> ronh-: I don't know scheme. the CL implementations I've seen lack 'use strict'
02:04:13 <mauke[> ronh-: i.e. they implicitly create special vars
02:04:24 <mauke[> or maybe not special
02:04:52 <mauke[> anyway, they let you assign to variables that don't exist
02:04:56 <tdammers> CL has "atoms", IIRC... every bareword you write defaults to referring to itself, until you assign it a different value
02:05:10 <mauke[> that sounds wrong
02:05:13 <tdammers> it is
02:05:28 <tdammers> that's one of the reasons why I call CL the "dirty" lisp
02:05:39 <tdammers> that, and faking booleans
02:06:01 <mauke[> variables either start out as NIL or an error
02:06:29 <mauke[> unless you're talking about stuff like :foo maybe?
02:07:11 <tdammers> last time I checked, typing `foobar` into the repl without defining it first would evaluate to `foobar`
02:07:23 <tdammers> (in CL, that is)
02:08:49 <mauke[> http://ideone.com/00kL9V
02:09:56 <tdammers> ah, hmm
02:10:02 <tdammers> http://ideone.com/JNhZnf
02:10:06 <tdammers> this is what I meant
02:10:10 <tdammers> but still
02:10:19 <tdammers> haven't tried CL in a while
02:10:44 <mauke[> that's the same error, though?
02:12:51 <tdammers> yeah
02:13:27 <xelxebar> just typed `foobar` into the sbcl repl. Complains about and unbound variable.
02:14:13 <mauke[> http://ideone.com/LLSJmE <- this is what I was referring to
02:14:25 <mauke[> unbound symbol, but you can just assign to it
02:14:43 <tdammers> ah, right
02:15:34 <xelxebar> what cl is that?
02:16:18 <mauke[> clisp
02:16:50 <tdammers> scheme seems to be inconclusive
02:17:20 <tdammers> (set! foo 23) (print foo) ; prints 23 in chicken scheme, fails in guile
02:17:28 <tdammers> scheme48 also errors
02:18:51 <mauke[> in perl (in strict mode), this is a compile-time error
02:19:01 <tdammers> http://ideone.com/IUbfTp
02:19:29 <mauke[> meaning perl can actually spot typos in variable names before it starts running your code
02:19:42 <tdammers> yup
02:20:38 * mauke[ smacks python/php over the head
02:20:41 <exio4> tdammers: racket also fails
02:21:35 <jle`> anyone know if it's possible to implement (<*>) or liftA2 with Comonad
02:21:58 <tdammers> exio4: yeah, I believe that chicken scheme is the oddball here and the rest does the right thing
02:22:07 <merijn> jle`: Shouldn't be possible, I don't see why it would be
02:22:18 <tdammers> clojure, btw., will also fail when you use undefined variables
02:22:20 <jle`> i can get something that fits the type
02:22:41 <jle`> so it gives me hope
02:23:12 <tdammers> heh, sbcl doesn't error, just throws a warning
02:23:18 <jle`> :t \f x -> extend $ \y -> f (extract x) (extract y)
02:23:19 <lambdabot> (Comonad w, Comonad w1) => (a -> a1 -> b) -> w a -> w1 a1 -> w1 b
02:23:21 <tdammers> but it still creates the var and assigns to it
02:23:58 <jle`> this is clearly not right
02:24:05 <tdammers> nope
02:24:10 <merijn> jle`: Not the right type either
02:24:15 <jle`> but the fact that i can get something that fits the shape counts for something right?
02:24:21 <jle`> it's not the right type?
02:24:28 <jle`> :t liftA2
02:24:30 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
02:25:20 <jle`> if only djinn worked with typeclasses and polymorphism
02:26:33 <jle`> i'm going to keep looking
02:27:40 <jle`> you can implement liftA2 with ComonadStore i think
02:29:26 <ronh-> mauke IIRC setq or setf before let/defvar will result in an error in SBCL
02:29:52 <indiagreen> jle`: you might try exference
02:36:40 <merijn> jle`: You might be able to implement it for a SPECIFIC comonad that way (maybe, I'm not sure), but certainly not in general
02:38:56 <jle`> i feel like with ComonadStore in general you can do it
02:39:19 <jle`> if you used another ComonadStore as the functor in Experiment
02:39:26 <jle`> *experiment
02:39:46 <jle`> maybe it's just getting late and i'm going crazy
02:41:40 <f|`-`|f> Doing better than me, I'm still sane
02:42:44 <zcourts> is the GHC lib API exposed via foreign ccalls? Looking at the docs, all examples show how to use it from Haskell with no hint as to whether it’s possible or how difficult it may be using from C/C++
02:43:14 <jophish> assertM (like traceM) would be really nice. What are the reasons against it?
02:43:59 <fyolnish> you need to expose them with a foreign export I think
02:46:58 <zcourts> fyolnish: cool
02:48:55 * hackagebot harpy 0.6.0.0 - Runtime code generation for x86 machine code  http://hackage.haskell.org/package/harpy-0.6.0.0 (MartinGrabmueller)
02:54:42 <Pato> Hi, I'm trying to convert a Leaf Tree ( data LTree a = Leaf a | Fork (LTree a, LTree a) to a list. I'm using a catamorphism with the following type (cataLTree :: (Either b (d, d) -> d) -> LTree b -> d). I'm trying to run the following code : cataLTree ( either singl concat)
02:55:07 <merijn> zcourts: Well, you could just export it yourself?
02:55:39 <Cale> Pato: What error are you getting? If that's the concat from the prelude, don't forget to uncurry it
02:55:45 <Cale> er
02:55:51 <Cale> uncurry (++) rather
02:56:15 <Cale> If it's the concat from the Prelude, it has no business being there ;)
02:56:28 <zcourts> merijn: Yep, that’s the plan, I didn’t know if it was already done and had no idea where to look in the GHC source
02:56:43 <Pato> Yeah, it's the concat from the prelude, it complied using the uncurry. will test it
02:57:05 <Cale> :t uncurry (++)
02:57:07 <lambdabot> ([a], [a]) -> [a]
02:57:39 <Cale> :t either (:[]) (uncurry (++))
02:57:40 <lambdabot> Either a ([a], [a]) -> [a]
02:58:29 <Pato> Cale, it's impressive as hell how you can find the problem so quickly. Once again you save the day. Thank you o/
02:58:49 <Cale> No problem
03:05:39 <frerich> Cale: I hope you granted yourself your favorite $BEVERAGE after yesterdays endurance and patience test. The IRC log looked... 'fun'.
03:05:49 <Cale> lol
03:08:49 <tdammers> so how long did that go on?
03:08:56 * hackagebot rest-example 0.2.0.2 - Example project for rest  http://hackage.haskell.org/package/rest-example-0.2.0.2 (AdamBergmark)
03:09:01 <Cale> I dunno
03:10:03 <Cale> Someone said 6 hours, but I don't think I was there for all of it... could have been. Was basically just filling time because I was having a rough time getting to sleep from pollen allergies.
03:12:43 <sopvop> Can ghc core `case` on more that one level of constructors?
03:12:54 <Cale> I don't think so
03:13:50 <sopvop> And what does Rec {...}  means in dump-simp?
03:14:42 <Cale> Context? Could that be a recursive block? It's been a while since I last looked at core.
03:16:00 <sopvop> Probably. 
03:16:37 <sopvop> I'm trying to find out why ghc is so slow. Probably too many inlines. Module itself is quite small.
03:21:52 <Pato> I have this function "balanceGene xs = if (length xs == 1) then Left (head(xs)) else let res = splitAt(length xs `div` 2) xs in Right (fst(res),snd(res))" that functions as the gene of one anamorphism. Therefore, the anamorphism is written as follows : "anamorpLTree balan (cataLTree ( either singl (uncurry (++))) t)". Is there any way to write the balance gene straight up without using the auxiliar function balance?
03:26:31 <frerich> Pato: This doesn't answer your question directly (I think), but couldn't you simplify 'balanceGene' to 'balanceGene xs = case xs of [x] -> Left x; _ -> Right $ splitAt (length xs `div` 2)'?
03:29:41 <Pato> frerich: probably, yes. I'm not very good at haskell, so I just wrote it the 1st way I could. The problem is, I need to get it to work with one line only, so I need to find a way to put that auxiliar function in the same line of the anamorphism
03:32:49 <sopvop> will `cabal sandbox delete` remove my add-source list?
03:48:59 * hackagebot inline-c 0.5.0.0 - Write Haskell source files including C code inline. No FFI required.  http://hackage.haskell.org/package/inline-c-0.5.0.0 (FrancescoMazzoli)
03:49:01 * hackagebot inline-c-cpp 0.1.0.0 - Lets you embed C++ code into Haskell.  http://hackage.haskell.org/package/inline-c-cpp-0.1.0.0 (FrancescoMazzoli)
03:58:59 * hackagebot curlhs 0.1.6 - bindings to libcurl, the multiprotocol file transfer library  http://hackage.haskell.org/package/curlhs-0.1.6 (KrzysztofKardzis)
04:00:20 <merijn> frerich, Pato: FYI the using length to split is a really inefficient implementation in haskell
04:00:32 <merijn> And so is "if (length xs == 1)" that's O(n), right there
04:00:41 <frerich> Sure
04:00:44 <merijn> And worse, if xs is long it forces the entire list, consuming lots of memory
04:01:18 <Pato> merijn: so what should I use on the anamorphism?
04:01:39 <merijn> I have no idea what anamorphism means
04:02:02 <frerich> I think it's the reverse operation of a catamorphism?
04:02:21 <mauke[> anamorphism is a song by nicki monaj
04:02:29 <gremble> ^ ha
04:02:45 * frerich thinks he read 'anamorphism . catamorphism = hylomorphism' somewhere
04:03:45 <gremble> wikipedia says that catamorphism is the catagorical dual of anamorphism. The article means nothing to me though. Something about coalgebras
04:03:59 * hackagebot machines-io 0.2.0.4 - IO utilities for the machines library  http://hackage.haskell.org/package/machines-io-0.2.0.4 (aloiscochard)
04:04:09 <pavonia> > map (null . drop 1) [[1,2,3], [4,5], [6], []]
04:04:11 <lambdabot>      Ambiguous occurrence ‘map’
04:04:11 <lambdabot>      It could refer to either ‘Data.List.map’,
04:04:11 <lambdabot>                               imported from ‘Data.List’ at L.hs:93:1-16
04:04:33 <pavonia> Or to what?
04:04:34 <Pato> I'll simplify the question: is there any way to transform this "balan xs = if (length xs == 1) then Left (head(xs)) else let res = splitAt(length xs `div` 2) xs in Right (fst(res),snd(res))" into a lambda expression ?
04:05:01 <mauke[> pavonia: someone had imported Data.List.NonEmpty
04:05:21 <pavonia> :<
04:05:25 <mauke[> Pato: balan = \xs -> ...
04:06:11 <zipper> jle`: Are you around?
04:06:28 <mauke[> balan = \xs -> case of [x] -> Left x; _ -> Right (splitAt (length xs `div` 2) xs)
04:06:49 <pavonia> Pato: Are you aware that "head(xs)" in Haskell is the same as "head xs"?
04:07:21 <mauke[> oops, should've been 'case xs of'
04:08:21 <merijn> > 3 `div` 2
04:08:23 <lambdabot>  1
04:08:32 <Pato> pavonia: yes, just old habits that are hard to forget
04:10:03 <merijn> Here's how to efficiently split a list in haskell: https://gist.github.com/merijn/c163cc106fd245d1cf2e
04:10:37 <merijn> In case of uneven length the snd tuple element is longer, but that's easy to change
04:10:44 <merijn> Actually
04:10:55 <merijn> I could probably make it more efficient using DList
04:13:16 <merijn> DList-ified https://gist.github.com/merijn/c163cc106fd245d1cf2e
04:14:28 <merijn> "\xs -> case xs of [x] -> Left x; xs -> Right (splitInHalf xs)" <- there, lambda
04:14:55 <Pato> I'll try it
04:15:11 <merijn> Actually, you could move the Left/Right behaviour into the splitInHalf implementation to make it even simpler/more efficient
04:18:54 <Pato> merijn: I get a type error using that version
04:19:11 <Pato> merijn: Couldn't match expected type ‘([a], [a])’                 with actual type ‘[a0] -> ([a0], [a0])’
04:19:28 <mauke[> missing parameter somewhere
04:21:27 <merijn> Then you didn't use the code as pasted, because the code I pasted works just fine
04:21:39 <merijn> For some "I ran 5 test cases" of fine :p
04:24:00 * hackagebot waddle 0.1.0.0 - WAD file utilities.  http://hackage.haskell.org/package/waddle-0.1.0.0 (MartinGrabmueller)
04:26:10 <jonrus_> If I have a variable that is, say, an Int and I'm using a function from an imported module that expects something called a network-2.4.2.3:Network.Socket.Types.PortNumber, is there a way to coerce the Int into that without importing this Network.Socket.Types thing separately?
04:27:26 <jonrus_> I know if I pass a literal to the function it will be coerced because I've set {-# LANGUAGE OverloadedStrings, DeriveGeneric #-}
04:27:44 <mauke[> there is no coercion
04:27:53 <mauke[> your language pragmas have nothing to do with type conversion
04:28:05 <mauke[> jonrus_: you want fromIntegral
04:28:14 <merijn> Warning!
04:28:32 <merijn> PortNumber has some weird voodoo with byte ordering in the fromIntegral instance
04:28:47 <mauke[> not really
04:29:01 * hackagebot waddle 0.1.0.1 - WAD file utilities.  http://hackage.haskell.org/package/waddle-0.1.0.1 (MartinGrabmueller)
04:29:04 <merijn> mauke[: I spend like 3 hours debugging an issue with that
04:29:05 <mauke[> the internal representation is weird but it all works fine if you don't peek inside
04:29:20 <merijn> Oh
04:29:27 <pavonia> merijn: IIRC using the constructor is bad
04:29:28 <mauke[> (peeking inside involves the PortNum constructor, so don't use that)
04:29:29 <merijn> The new version of network hid the constructors
04:29:30 <merijn> Carry on
04:29:34 <jonrus_> Oh wow cool thanks
04:29:51 <jonrus_> How does that work for the same thing but with Strings to Data.Text.Internal.Text?
04:29:57 <jonrus_> is there a similar function?
04:30:07 <mauke[> there's probably Text.pack or something similar
04:32:03 <jonrus_> thanks
04:32:11 <jonrus_> I'm not totally sure _why_ it works but I'll read up
04:32:13 <merijn> :t Text.pack
04:32:14 <lambdabot> Not in scope: ‘Text.pack’
04:32:22 <merijn> :t Data.Text.pack
04:32:23 <lambdabot> String -> Data.Text.Internal.Text
04:32:47 <mauke[> jonrus_: oh, or just fromString
04:32:59 <jonrus_> LOL!
04:33:08 <mauke[> because that's what OverloadedStrings does: it turns "foo" into fromString "foo"
04:33:19 <mauke[> similar to how numeric literals like 123 are really fromInteger 123
04:35:13 <jonrus_> aaahhh
04:35:15 <jonrus_> thanks so much
04:37:48 <breadmonster> Why are multiparameter type classes a GHC extension and not in the specification?
04:39:01 * hackagebot waddle 0.1.0.2 - WAD file utilities.  http://hackage.haskell.org/package/waddle-0.1.0.2 (MartinGrabmueller)
04:39:12 <bergmark> breadmonster: perhaps because it breaks type inference
04:39:31 <merijn> breadmonster: There's not a lot of interest in updating the report
04:39:55 <mauke[> bergmark: how does it break inference?
04:39:57 <breadmonster> merijn: Doesn't that defeat the purpose of the report? :p
04:40:13 <merijn> breadmonster: The report is a "descriptive standard" in that it describes what is. The report is only really useful in the presence of multiple competing implementations and standardising between them
04:40:30 <breadmonster> Fair enough.
04:40:49 <merijn> breadmonster: Currently there's only 3 serious Haskell implementations and the only one with any public interest is GHC, so no one is championing new standards
04:41:11 <breadmonster> I just had the vision of all human life disappearing, and aliens only having the report to reimplement the language...
04:41:19 <breadmonster> but that's probably never going to happen.
04:41:24 <breadmonster> merijn: what are the other two?
04:41:28 <merijn> Mu and UHC
04:41:38 <merijn> Of which only UHC is open source and publicly available
04:41:59 <merijn> Mu isn't only sorta haskell anyway in that it's not non-strict
04:42:04 <merijn> s/isn't/is
04:42:14 <breadmonster> Interesting, I've never heard of either.
04:42:21 <breadmonster> Where do you download Mu?
04:42:54 <merijn> breadmonster: You don't, like I said, it's not publicly available
04:43:16 <breadmonster> Oh okay, I inferred that it was available at a price or something.
04:43:20 <grayling_> breadmonster: Not even a website?
04:43:27 <bernalex> is Mu the Standard Chartered haskell-like language?
04:43:35 <merijn> breadmonster: It's the compiler augustss works on at Standard Chartered, he blames the lawyers for not being allowed to open source it (bank lawyers are paranoid, apparently)
04:43:39 <breadmonster> grayling_: What do you mean?
04:44:04 <grayling_> breadmonster: A website for Mu.
04:44:12 <grayling_> But I guess not then.
04:44:15 <breadmonster> grayling_: No idea, I don't think one exists.
04:44:37 <merijn> breadmonster: UHC is the Utrecht Haskell Compiler, at the Dutch FP day earlier this year I heard they're about to finish up an update for their attribute grammars which should make it easier to add support for a bunch of GHC extensions
04:44:59 <breadmonster> merijn: So how does UHC compare to GHC?
04:45:04 <merijn> But they're not getting paid to make it a production compiler, so unless someone steps up and invests time in UHC it won't compete with GHC
04:45:23 <bernalex> somewhat related is Helium. I wanted to work on a haskell-like language myself, but we haven't found funding, and my company is sort of going broke next week, so. :p
04:45:41 <merijn> breadmonster: It implements Haskell2010 and a bunch of extensions, but not nearly as many as GHC
04:45:45 <merijn> No clue how it's codegen is
04:46:05 <breadmonster> bernalex: Ouch
04:46:11 <breadmonster> merijn: Right that seems cool.
04:46:39 <breadmonster> merijn: Another question.
04:46:48 <breadmonster> I'm watching SPJ talk about typeclasses.
04:46:56 <breadmonster> Why are type class dictionaries passed at runtime?
04:47:14 <mauke[> breadmonster: why are function arguments passed at runtime?
04:47:34 <breadmonster> mauke[: We don't know what they are before hand?
04:47:42 <mauke[> why not?
04:47:46 <breadmonster> But aren't all types in GHC determined at compile time?
04:47:59 <breadmonster> mauke[: Because that would require a time machine?
04:48:02 <breadmonster> I don't get the question...
04:48:12 <merijn> breadmonster: They aren't always
04:48:16 <mauke[> I don't get the time machine
04:48:20 <bjornars> the alternative is to generate code for all possible instances of the typeclass?
04:48:26 <merijn> breadmonster: If the dictionary is known at compile time GHC will inline the lookup
04:48:28 <frerich> merijn: Your 'splitInHalf' gist is interesting, is there some explanation online how it works? I'm familiar with dlists but even when squinting I can't see how it would split the list and before I evaluate it by hand, I wonder whether there's an explanation of how it improves over the splitAt (length xs `div` 2).
04:48:57 <merijn> frerich: splitAt + length means walking the list twice
04:49:02 <merijn> frerich: Once for length, once for split
04:49:07 <frerich> merijn: Right
04:49:10 <merijn> frerich: Mine travers the list once
04:49:18 <breadmonster> merijn: Is there a simple example of that?
04:49:22 <merijn> The DList is just a more efficienct way of appending
04:50:01 <merijn> breadmonster: "f :: Int -> Int -> Int; f x y = x + y" <- here GHC knows you mean the Int instance of plus, so it can inline the lookup and remove the dictionary
04:50:05 <mauke[> breadmonster: main = putStrLn (show 42)
04:50:07 <breadmonster> mauke[: `increment x = x + 1` if I knew all the possible values in a program that I would be running that function on, I'd just turn them into appropriate constants.
04:50:32 <mauke[> breadmonster: why do you not know all the possible values in your program?
04:50:55 <breadmonster> mauke[: Except I don't. I was under the impression that with type inference, I wouldn't have the same problem with type classes, and all relevant instances would be known at compile time.
04:51:01 <merijn> breadmonster: GHC generates generic code, so it doesn't (unless optimisations do this) generate different code for polymorphic functions when applied to different types
04:51:24 <indiagreen> breadmonster: imagine that the code is in a library which is compiled before the executable that uses it
04:51:30 <indiagreen> how would it work?
04:51:42 <merijn> breadmonster: That is, "id :: a -> a" has only a single implementation that can be used on any type, so how could I specialise the implementation of 'id' for some type?
04:51:48 <merijn> breadmonster: The same holds for "+"
04:51:48 <breadmonster> mauke[: e.g. `main = interact . print . increment . readInt` 
04:52:02 <breadmonster> merijn: Sure, I completely agree.
04:52:09 <merijn> breadmonster: The problem is that your trivial example only applies increment to an Int
04:52:17 <merijn> breadmonster: In real code that's not necessarily true
04:52:19 <breadmonster> No, what I mean is this.
04:52:20 <frerich> merijn: If I see it correctly, your version always gives the second half though, but I now see the main trick: the idea is to have two 'pointers' into the list and one of them walks twice as fast (two elements at a time) than the other, so you know when you are in the middle.
04:52:23 <mauke[> breadmonster: ok, that's runtime input
04:52:28 <merijn> frerich: Right
04:52:32 <frerich> merijn: That's the piece I was missing, thanks!
04:52:42 <breadmonster> At compile time, doesn't GHC know the type of every expression in the program?
04:52:43 <mauke[> breadmonster: do you know what polymorphic recursion is?
04:52:54 <breadmonster> mauke[: No. This might be the bit I don't know about.
04:53:00 <mauke[> breadmonster: also, separate compilation as mentioned by indiagreen 
04:53:07 <mauke[> i.e. ghc doesn't see the whole program at once
04:53:12 <merijn> frerich: It gives the first half too, but you need to build that (since it ends earlier then the original list you can reuse the input list)
04:53:31 <breadmonster> mauke[: Fine, that makes sense. 
04:53:34 <frerich> merijn: Yeah, I only realized that 'f []' is where the list is built right after I sent my last message. :-/
04:53:36 <merijn> frerich: So at every step I append at the end of the "first half", but as you may realise repeated right append on a list is really inefficient
04:53:37 <breadmonster> But what's polymorphic recursion?
04:53:40 <merijn> frerich: :)
04:54:01 <mauke[> > let foo :: (Show a) => Int -> a -> String; foo 0 x = show x; foo n x = foo (n - 1) (x, x) in foo 2 'x'
04:54:02 * hackagebot profunctors 5.1.1 - Profunctors  http://hackage.haskell.org/package/profunctors-5.1.1 (EdwardKmett)
04:54:04 <lambdabot>  "(('x','x'),('x','x'))"
04:54:08 <mauke[> breadmonster: ^
04:54:14 <merijn> frerich: Here's a good example on how DList speeds up repeated append: http://h2.jaguarpaw.co.uk/posts/demystifying-dlist/
04:54:21 <merijn> frerich: Well, not example, but explanation
04:54:34 <frerich> merijn: Yeah, I knew about dlists already. I just didn't see how your function can tell when it's in the middle of the list.
04:54:43 <frerich> I.e. I missed the 'ys is traversed twice as fast' part.
04:54:58 <merijn> frerich: The double pointer trick is really cool it works on lots of list operations
04:55:07 <merijn> frerich: i.e. "compute the last 10 elements"
04:55:09 <breadmonster> mauke[: Okay...
04:55:21 <breadmonster> That's pretty cool.
04:55:28 <merijn> frerich: Just use a "go" that goes at the same speed on both lists and start with "go xs (drop 10 xs)"
04:55:35 <frerich> merijn: I wonder whether this could be generalized to splitting into any number of chunks by passing a list of lists to 'go'.
04:55:37 <mauke[> breadmonster: the final type at which show is called depends on the integer n
04:56:04 <breadmonster> mauke[: This is actually pretty intense, I didn't know functions like this were legal.
04:56:07 <frerich> merijn: ...and then using take/drop instead of pattern matching to move the pointers.
04:56:07 <breadmonster> Wow, this is cool.
04:56:10 <merijn> frerich: Yes, you can generalise this trick to almost any stateless list algorithm (and possibly some stateful ones)
04:56:30 <frerich> merijn: Cool, a nice trick I learned today. Thanks for sharing! :-)
04:57:02 <merijn> frerich: You only need to drop on the initial one for the "last 10", after you "drop 10" your second pointer is 10 ahead, so if you iterate over both at the same time when the second one is [] then the first must be the pointer to "last 10" :)
04:57:33 <frerich> Yeah. In fact, I think I know some C code with singly-linked list operations which could benefit frmo the exact same idea.
04:58:00 <merijn> frerich: I got the idea from the "Tortoise and the hare" algorithm for cycle detection in linked lists
04:58:41 <frerich> merijn: Yeah I know that one, I remember I had to scribble it down to convince myself that it actually works... it just never occurred to me that this might also be a useful approach for non-cyclic lists.
04:59:43 <frerich> merijn: Maybe it would be nice to have a 'tortoise-and-hare' package which features a couple of such functions :-)
05:00:45 <breadmonster> merijn: Can I see your dlist implementation?
05:02:31 <lpaste> Yrarr pasted “Scaling threads” at http://lpaste.net/132994
05:02:57 <frerich> breadmonster: There's a nice dlist package on hackage, but there isn't really much to it. The whole idea is to not append to a list (using (++ [x])) but to compose a big function which, when applied to [], yields the list. Instead of doing '(++ [x])' you basically do '(. (x:))'.
05:03:16 <breadmonster> frerich: Oh then what were you two talking about?
05:04:02 * hackagebot machines-process 0.2.0.4 - Process (system) utilities for the machines library  http://hackage.haskell.org/package/machines-process-0.2.0.4 (aloiscochard)
05:04:04 <Yrarr> Hello, I'd like to ask you one question: I try to run this code (http://lpaste.net/132994) on a node with 12 processors, but it seems that the program does not scale. Do you see any errors with it ? I compile it with options -O2 -threaded -eventlog -rtsopts and run with +RTS -N2 (or -N4, etc)
05:04:05 <frerich> breadmonster: No, we were talking about https://gist.github.com/merijn/c163cc106fd245d1cf2e (which happens to use dlists as an implementation detail) and me being unable to see on first glance how it can tell whether it reached the middle of the list
05:07:35 <breadmonster> merijn: Umm, in your splitInHalf gist, why do you need to pass id?
05:07:44 <breadmonster> As opposed to abstracting it out?
05:08:02 <merijn> breadmonster: Look at the type of the first argument to go
05:08:09 <merijn> breadmonster: You need a basecase for the DList
05:08:37 <merijn> There's not a whole lot to implement for a DList implementation ;)
05:08:54 <breadmonster> Yeah, but f is only called thrice, and on each invocation, you could replace it with the argument...
05:09:25 <merijn> breadmonster: No
05:09:34 <mauke[> breadmonster: where's the third call?
05:09:34 <merijn> breadmonster: Look at the 3rd recursion for god
05:09:50 <merijn> breadmonster: How would you eliminate 'f', there?
05:09:57 <tdammers> mapM id?
05:10:03 <tdammers> :t mapM id
05:10:04 <lambdabot> (Monad m, Traversable t) => t (m b) -> m (t b)
05:10:08 <merijn> tdammers: heh
05:10:14 <tdammers> :t sequence
05:10:15 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
05:10:19 <breadmonster> :t (3:)
05:10:20 <lambdabot> Num a => [a] -> [a]
05:10:20 <tdammers> tmyk
05:10:21 <merijn> tdammers: How is that remotely relevant? :)
05:10:28 <tdammers> merijn: Yrarr's paste
05:10:45 <merijn> tdammers: Oh, I got confused with the discussion about id and thought you were talking to me :)
05:10:49 <tdammers> hehe no
05:11:09 <breadmonster> merijn: couldn't you replace it with (x:)?
05:11:24 <merijn> breadmonster: Think about what the recursion is doing
05:12:06 <merijn> breadmonster: for "[1,2,3,4]" you get "f = id", then "f = id . (1:)", then "f = id . (1:) . (2:)", etc.
05:12:17 <tdammers> Yrarr: my guess is that you need to force strictness somewhere
05:12:42 <breadmonster> merijn: Oh now I get what you mean as a base case
05:12:46 <breadmonster> Thank you so much!
05:12:48 <merijn> breadmonster: :)
05:13:06 <merijn> breadmonster: It's like
05:13:09 <merijn> :t foldr (.) id
05:13:10 <lambdabot> Foldable t => t (b -> b) -> b -> b
05:13:27 <breadmonster> Huh? Wasn't foldr only over lists?
05:13:37 <merijn> breadmonster: 7.10 move Foldable/Traversable into Prelude
05:13:41 <tdammers> Yrarr: something like you putting a thunk into the MVar, and then it gets evaluated on the consumer side (i.e., in the main thread)
05:13:55 <breadmonster> merijn: Oh I didn't know that.
05:14:03 * hackagebot machines-directory 0.2.0.4 - Directory (system) utilities for the machines library  http://hackage.haskell.org/package/machines-directory-0.2.0.4 (aloiscochard)
05:14:11 <Yrarr> tdammers: Oh, okay. I'll try to do so
05:14:33 <breadmonster> Alright, I gotta go now.
05:14:41 <breadmonster> Will think over your example.
05:14:44 <breadmonster> Thanks guys (:
05:16:39 <frerich> merijn: Now that I think about it again - DLists are a CPU vs. memory tradeoff, right? After all, the function being composed needs to be stored somewhere? If so, would it maybe help to 'force' the first argument of (.) such that you don't build this chain of functions?
05:17:25 <merijn> frerich: You don't build a chain of functions
05:17:55 <merijn> frerich: They're constructors, so those take up memory, yes, but they take up that memory anyway
05:18:04 <merijn> I mean, that's kinda the point :)
05:18:24 <merijn> frerich: The advantage is that you avoid building up a massive thunk and then needing to force it
05:18:30 <reeze> I am trying to understand IO monad.    such as: main = putStrLn "test"   but the type of putStrLn is String -> IO (). who pass the RealWorld to putStrLn here? 
05:18:40 <merijn> reeze: There is no RealWorld
05:19:08 <merijn> reeze: Hold, lemme link my explanation form last night :p
05:19:14 <zipper`> reeze: What do you mean in that last sentence by "who pass..."
05:20:31 <reeze> I mean the function putStrLn is pure. As far as I know it seem we pass the RealWorld around those functions. but the parameter of putStrLn is only input was Just a String.
05:20:38 <Yrarr> tdammers: It works now, used BangPatters to do so, thanks!
05:20:48 <reeze> So I am wondering where did the RealWorld come from?
05:21:04 <merijn> reeze: There is no RealWorld and so it isn't passed in
05:21:11 <merijn> Who's good at searching the online logs?
05:21:13 <tdammers> Yrarr: yw
05:21:19 <reeze> then how can we say that it is pure?
05:21:25 <merijn> There's like a half hour explanation of IO from me last night at 23:30 or so
05:21:31 <merijn> But I can't find it and I'm too lazy to retype it
05:21:43 <reeze> Sorry I don't know how to quote your message :(
05:22:00 <tdammers> putStrLn is pure; it is a function that takes a String and produces an IO () action
05:22:28 <ronh-> reeze `putStrLn "test"' will produce the same IO () action every time you call it.
05:22:42 <maerwald> reeze: https://github.com/ghc/packages-ghc-prim/blob/ad9bf96815cb5a9bb4acc51c99eff20be3e50da3/GHC/Types.hs#L82
05:22:43 <tdammers> it doesn't "do" anything; the effect of printing something to stdout doesn't appear until we point the runtime at it
05:23:00 <maerwald> reeze: so the RealWorld is actually an input for the IO type
05:23:01 <tdammers> (at the resulting IO action, that is)
05:23:27 <merijn> reeze: http://ircbrowse.net/browse/haskell?id=20701119&timestamp=1432074948#t1432074948
05:23:53 <merijn> reeze: There's a discussion with an elaborate explanation of IO from me starting there and continuing for like 20-30 mins if you click through the logs
05:24:34 <reeze> Thank you merijin!  
05:24:36 <maerwald> reeze: to be pure it must satisfy "same input, same output"... if you have the RealWorld as input and the resulting RealWorld as part of the output-tuple, then it makes sense
05:27:04 <merijn> maerwald: It really doesn't
05:27:24 <merijn> maerwald: What does forkIO do?
05:27:30 <merijn> maerwald: Does it create multiple worlds?
05:27:43 <merijn> If not, how do pass my world between threads?
05:28:02 <reeze> So the IO () just contain what should do but it wasn't be executed.  I read from the books, it says. only when the IO passed to main it will be executed.  so if it is a webserver. it can handle different requests. the computation was not stop. so who is going to evaluation thoese IOs?
05:28:10 <maerwald> merijn: you are saying the GHC source code does not make sense? I cannot follow
05:28:18 <tdammers> merijn: you could say that forkIO puts the action you give it into the RealWorld and alters the RealWorld such that the new action is now running in a thread
05:29:00 <merijn> maerwald: The GHC source is an implementation detail, completely unrelated to what IO means
05:29:04 * hackagebot codex 0.2.1.10 - A ctags file generator for cabal project dependencies.  http://hackage.haskell.org/package/codex-0.2.1.10 (aloiscochard)
05:29:14 <maerwald> merijn: I don't think so, it's also in the haskell wiki
05:29:26 <merijn> tdammers: But the IO actions in that thread need a world to pass around and so does the original thread
05:29:37 <maerwald> it's not entirely correct, but it gives a good idea about IO, imo
05:29:50 <merijn> tdammers: So unless they're mutably modifying the realworld (and then we're no longer pure... so it defeats the entire explanation)
05:30:06 <tdammers> merijn: yes. But since the action in the new thread is no longer managed by the caller, but by the RealWorld, we need not concern ourselves with that
05:30:14 <reeze> I read again "'IO' is a monad, so 'IO' actions can be combined using either the do-notation
05:30:15 <reeze> or the '>>' and '>>=' operations from the 'Monad' class."  is that means when ever a IO monad was binded. the rts pass a Realworld to evaluation thoses IO monads?
05:30:27 <tdammers> iow., hands are being waived
05:30:49 <tdammers> oh who am I kidding, I'm playing devil's advocate here anyway
05:31:33 <merijn> tdammers: But not in a helpful way, atm. Anyway, I have to work, I'll leave you guys to unconfuse reeze :p
05:31:48 <tdammers> reeze: it simply means that if you have an IO action (:: IO a) and a function (:: a -> IO b), you can use >>= to combine them such that the result is :: IO b
05:32:26 <tdammers> and the semantics of the "combining" are that the resulting action is interpreted as "run the first action, then feed the result to the function and run the resulting action"
05:32:59 <tdammers> if and how RealWorld fits in is really not important for the workings of >>=
05:33:29 <tdammers> just like the plumbing of, say, State, aren't important in explaining what >>= does for that monda
05:33:34 <tdammers> monad*
05:33:43 <ronh-> also, >>= just creates produced a new IO action. the act of calling >>= does not execute any action
05:33:59 <ronh-> also, >>= just creates a new IO action. the act of calling >>= does not execute any action
05:34:03 <maerwald> tdammers: yes, I think it is actually pretty similar to the state monad
05:34:22 <tdammers> maerwald: it is, except for parallelism / concurrency
05:34:53 <tdammers> well, and effects and exceptions
05:35:26 <tdammers> anyway, the important part is that IO being the type to represent real-world actions, and IO being a monad are kind of orthogonal
05:35:58 <tdammers> it just so happens that "chaining stateful real-world operations" fits the monad pattern, so it makes sense to implement Monad for IO
05:36:16 <maerwald> yeah
05:37:00 <tdammers> worth mentioning though, because it tends to confuse the hell out of people - "how can I use monads to produce side effects in a pure language"
05:37:39 <reeze> hmm.. do you guys mean RealWorld is just a concept, it didn't really a real abstraction?  
05:38:15 <maerwald> well, how can you possibly pass the whole world into a function :P ...you could argue "laziness!", but err...
05:38:59 <mauke[> no, I totally pipe the whole universe through my PC all the time
05:39:04 <maerwald> :D
05:39:12 <tdammers> reeze: more like, RealWorld is an implementation detail, but you'll have an easier time forgetting about it and using a different mental model
05:39:21 <eatman> join #xmonad
05:39:46 <tdammers> I like the model where your pure Haskell code produces an impure program (represented as a value of type IO ()), which is then fed to the runtime for execution
05:40:20 <tdammers> and because that impure program is constructed lazily, we can drop back into Haskell for evaluating pure constructs and feeding them back to the impure runtime
05:41:11 <Maxdamantus> if you were to simulate a "world" though, you could make up a `RealWorld` type to represent the state of it and make `IO` be `State RealWorld`
05:41:25 <mauke[> tdammers: we don't even need laziness because it's all behind lambdas
05:41:39 <mauke[> Maxdamantus: until you forkIO
05:42:05 <Maxdamantus> I don't think forkIO would break it.
05:42:27 <tdammers> Maxdamantus: it would
05:42:27 <Maxdamantus> Oh right, you'd need to incorporate that as a primitive, so it wouldn't work with State.
05:42:34 <tdammers> mauke[: true
05:43:49 <Maxdamantus> actually, no, I think it can still work.
05:44:17 <Maxdamantus> part of the state would be a bunch of other "processes", which are added to by things like forkIO.
05:44:57 <Yrarr> I'd like to ask one question again - right now I try to toy around with sparks. Here's my program: http://lpaste.net/132995 . Threadscope shows that the problem scales up to two cores, though the speedup is below 2 for number_of_cores >= 2. Is there something wrong with my code ?
05:45:07 <Maxdamantus> just like how there might be other computers inside the state that you can access using the networking operations.
05:45:40 <maerwald> Maxdamantus: uh, are we saying that the program is part of the State we pass into that program? That feels ...weird
05:46:11 <Maxdamantus> maerwald: depends what you mean by "the program is part of the State"
05:46:19 <Maxdamantus> maerwald: State can have functions in it, if that's what you mean.
05:46:28 <Maxdamantus> or if that counts as "the program being part of the State"
05:47:13 <Maxdamantus> that is, RealWorld can have functions in it.
05:47:16 <ronh-> reeze take a look at this. it implements a subset of IO that can read from stdin and write to stdout. http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/
05:47:45 <saulzar_> You can simulate threads with some ContT like stuff, like pipes, and do cooperative multitasking
05:48:14 <kqr> is there a Haskell project similar to what yapf is for python? basically it reads a source file and reformats it completely according to some internal rules
05:48:23 <saulzar_> Probably you can't go as far as implementing the whole ghc runtime..
05:49:41 <reeze> Thank you ronh- !  
05:49:43 <quchen2_> kqr: Yes-ish. There's stylish-haskell which formats imports, and Chrisdone is working on HIndent, which is a true auto-formatter
05:49:48 <bergey> kqr: https://github.com/chrisdone/hindent maybe?
05:49:49 <Maxdamantus> Why can't you in principle?
05:50:05 <maerwald> ronh-: nice link
05:50:22 <Maxdamantus> Other than regarding threads blocking because of loops, I think it should be possible.
05:50:55 <Maxdamantus> or threads that evaluate errors.
05:51:12 <Maxdamantus> (assuming you don't have another catch mechanism)
05:52:01 <kqr> quchen2_, bergey: yes! hindent is it. cheers :)
05:54:00 <reeze> I seems understand what it is. since the effect can not take place in function. we need to pass the IO around.  A function contains an action must return another action. so the effect are out of the function. it just depends on the real realworld but not the function itself.
05:54:54 <tdammers> reeze: a haskell function can only produce "instructions", it cannot execute them
05:55:18 <tdammers> foo :: IO () -- is an "instruction" ("action", in idiomatic lingo)
05:55:28 <pacak> I'm trying to write CA using Store Comonad from comonad package. Resulting code works, but performance kind of upsets me. State in Store is given as (s -> a) and I don't see any easy way of updating it efficiently. Am I doing anything  wrong?
05:56:12 <tdammers> within Haskell, you can pass `foo` around, you can bind it to identifiers, you can chain it to other actions using things like (>>=) (which really is just another function)
05:56:16 <tdammers> but you can't run it
05:56:23 <tdammers> the runtime can
05:56:43 <tdammers> and it will, if you bind your action to Main.main
05:57:05 <Cale> reeze: I'm not sure how to interpret a lot of what you said there, but the idea is that values x :: IO t describe some steps which could be carried out (executed) in order to produce a result of type t, but evaluation doesn't cause that execution to occur, only the execution of other IO actions can. In a compiled program, main gets executed and starts the process off.
05:58:31 <reeze> how is it implemented? I mean the realworld thing and who is the driver of this lazy car? I try to find it out from ghc. but I didn't find the answer for now.  is there any links ?  Do I need to know core language or cmm  to understand it? 
05:58:36 <Cale> Evaluation, the process of converting expressions into values for the purposes of pattern matching, is essentially free of visible side effects (apart from the fact that it'll heat up your CPU and consume memory)
05:58:41 <Maxdamantus> I think what he means by "pass the IO around" is that it needs to end up as part of the `main` action somehow.
05:59:01 <Maxdamantus> you can't just produce an IO value and be done with it.
05:59:29 <Cale> Laziness refers to the particular order in which expressions are evaluated, and has nothing to do with the execution of IO (apart from certain magical lazy IO actions)
06:00:48 <Cale> reeze: The RealWorld thing is either a bad mental model that's been proposed for how IO works, or a 0-byte wide data type used in GHC's own internal hacky implementation of IO, depending on which you're referring to.
06:01:11 <dbushenko> hi all!
06:01:18 <dbushenko> how to use option --disable-library-profiling on cabal project?
06:01:30 <Cale> reeze: It's a better mental model to think of IO actions as data values which describe what ought to be done, and to imagine that the runtime system has some sort of interpreter which is pattern matching those and actually carrying out the steps described by main.
06:01:35 <dbushenko> I'm trying to profile an executable but it tries to profile also some libraries
06:01:42 <dbushenko> I can't switch that off...
06:02:03 <tdammers> RealWorld is also a concept in a previous attempt at doing IO in Haskell, from back in the olden days, and it was abandoned because it didn't work
06:02:13 <Maxdamantus> imo the usefulness of the RealWorld model is that it demonstrates that IO doesn't break any rules in Haskell.
06:02:14 <tdammers> I think there's a talk from SPJ somewhere where he explains it
06:02:27 <tdammers> Maxdamantus: you don't need the RealWorld model to demonstrate that
06:02:34 <Cale> reeze: i.e. getLine :: IO String contains a String only insofar as /bin/ls contains a list of files -- it doesn't, it just consists of a description of how to get a String when executed, just as /bin/ls consists of a description of how to list the files in the current directory.
06:02:44 <mauke[> Maxdamantus: IME it doesn't work for that
06:02:58 <tdammers> ^ ++
06:03:03 <Maxdamantus> mauke[: do you have experience implementing RealWorld?
06:03:09 <Cale> reeze: Evaluating getLine does nothing much, just as reading the /bin/ls file off of your disk (and say, loading it into a hex editor or something) doesn't actually do much.
06:03:10 <Maxdamantus> (not GHC's RealWorld# thing)
06:03:17 <mauke[> Maxdamantus: what does that mean?
06:03:34 <Maxdamantus> 00:40:48 < Maxdamantus> if you were to simulate a "world" though, you could make up a `RealWorld` type to represent the state of it and make `IO` be `State RealWorld`
06:04:02 <mauke[> then the answer is no
06:04:11 <Cale> Maxdamantus: There's no type which could suitably stand in for RealWorld in that mental model description of I/O, and even with very broad interpretations, that explanation falls over in the face of concurrency
06:04:42 <Cale> So I don't really like even mentioning it
06:05:22 <Maxdamantus> Cale: I don't think that's true.
06:05:32 <mauke[> the other problem is that IO isn't a simulation
06:05:47 <mauke[> I'm not interested in simulating a world; I actually want to execute my programs
06:05:55 <Cale> Right
06:06:33 <Cale> But even if you were only interested in simulating a world, trying to define forkIO as a State RealWorld action is pretty tricky.
06:06:35 <merijn> I should put a huge warning around the RealWorld wiki page to avoid it poisoning more peoples minds :\
06:06:57 <Maxdamantus> You can write useful programs in Clean too, but the IO model in that, afaik, doesn't conform to the rest of the language.
06:07:03 <reeze> I can understand IO means actions now. after the expression been evaluationed there should be a IO () that can be executed by someone. I mean who is the one.if it is the main function. it means we can only response to a single request.  Maybe it is not clear. I mean if the main is responsible for execute the IOs. then how can we response to different request like a webserver, since the IO action can only been executed by main, and if so it means the program s
06:07:04 <Maxdamantus> because you can't implement the system in itself.
06:07:15 <merijn> Maxdamantus: Clean uses uniqueness types for IO
06:07:27 <Maxdamantus> merijn: yes, that's what I'm referring to.
06:07:28 <mauke[> reeze: you got cut off at "it means the program s"
06:07:35 <merijn> reeze: The runtime system is the thing executing IO
06:07:42 <merijn> reeze: You cannot execute IO within haskell
06:08:04 <pchiusano> could anyone explain cabal2nix's bizarro set of dependencies - https://gist.github.com/pchiusano/4a4f3d20c389e0120ff6
06:08:11 <reeze> Yes ;)  I mean when will rts excute it?
06:08:11 <Maxdamantus> if you imagine some environment a JS program might be exposed to, you can probably imagine most of it being simulated within JS itself.
06:08:11 <Cale> In a webserver, you will typically fork off new threads for responding to each client that connects.
06:08:13 <mauke[> reeze: main isn't a function
06:08:21 <mauke[> reeze: when the program starts up
06:08:31 <Cale> reeze: The RTS is executing the IO action main as soon as the program starts.
06:08:41 <pchiusano> like, isn't it just a pure function that translates from one text format to another text format
06:09:07 <Maxdamantus> you can implement DOM, HTML5, etc in JS by defining your own `document` definition.
06:09:08 <reeze> Something like a queue? if there is an action excute it.and next one, next one?
06:09:25 <mauke[> reeze: no, there's only one action
06:09:28 <Maxdamantus> and see the effects of running some code that manipulates it.
06:09:39 <Cale> reeze: Well, main is just one action, which in turn will be composed of many simpler ones
06:09:48 <Cale> Like, if I write
06:09:58 <Maxdamantus> (you might even go so far as to implement other computers in it so it can make web requests)
06:09:58 <Cale> main = do x <- getLine; putStrLn (reverse x)
06:10:01 <rui4> Any ideas how to get ghc 7.10.x from nix?
06:10:04 <mauke[> main = print 1 >> print 2 >> print 3
06:10:06 <aloiscochard> I'm trying to find a way to `md5` a `String` ... but I don't want to depend on MissingH (not a big fan of that lib), any idea/recommendation?
06:10:20 <mauke[> aloiscochard: String is the wrong type for that
06:10:21 <reeze> I think this is the hard part.  expression are lazy. but actions are not… who is in charge?
06:10:21 <Maxdamantus> You can do the same thing with IO in Haskell, but you can't do that in Clean afaik
06:10:28 <merijn> aloiscochard: Copy + paste the code if the license allows it? And what mauke said
06:10:44 <sleepomeno> I know that higher-rank polymorphism is undecidable (btw: anyone knows a good paper where this is presented?). does rank-2 already count as higher-rank or is rank-2 still decidable?
06:10:59 <merijn> aloiscochard: It's BSD3, so just adding a copyright notice for the md5 implementation should be sufficient
06:11:02 <mauke[> sleepomeno: IIRC rank-2 is decidable but annoying
06:11:10 <merijn> sleepomeno: Rank2 is already undecidable
06:11:20 <aloiscochard> mauke[: Yeah ByteString as result would be fine
06:11:24 <merijn> mauke[: Is it? I thought it wasn't
06:11:26 <mauke[> aloiscochard: no, as input
06:11:32 <aloiscochard> oh right
06:11:32 <Cale> Then getLine becomes part of main, and executing main causes getLine to be executed. The variable x is bound to the String result of the getLine, and execution proceeds with putStrLn (reverse x). The putStrLn function, in order to determine which action it ought to produce, will pattern match on its string argument, which in this case, will cause the expression (reverse x) to be evaluated.
06:11:40 <aloiscochard> mauke[: yeah, agree
06:11:50 <aloiscochard> merijn: thanks for tip! I might try that
06:12:10 <Cale> In the end, putStrLn will produce an action for printing the reverse of the String x to the screen, and that action will be executed
06:12:35 <mauke[> merijn: http://www.cs.bu.edu/techreports/pdf/1993-017-finite-rank.pdf is this a relevant paper?
06:12:36 <Maxdamantus> I think rank-2 is decidable.
06:12:51 <Maxdamantus> that's probably why it has a separate GHC flag.
06:13:06 <mauke[> GHC doesn't infer higher ranks, though
06:13:21 <Cale> Right, it just reserves the right to do so in the future because it's possible, I suppose.
06:13:28 <Maxdamantus> higher as in greater than 2?
06:13:32 <Maxdamantus> or 1?
06:13:34 <Cale> Maybe Hugs was able to infer rank 2?
06:13:42 <aloiscochard> `cryptohash` doesn't looks bad, I'll try that one
06:13:47 <aloiscochard> work with ByteString (in/out)
06:13:49 <Cale> Maxdamantus: higher rank refers to 2 and larger
06:14:06 * hackagebot repa-scalar 4.2.0.1 - Scalar data types and conversions.  http://hackage.haskell.org/package/repa-scalar-4.2.0.1 (BenLippmeier)
06:14:07 <Athas> The separate rank-2 flag in GHC is a historical accident - as I recall, someone mentioned that it's just as easy to support all ranks.
06:14:08 * hackagebot repa-convert 4.2.0.1 - Packing and unpacking flat tables.  http://hackage.haskell.org/package/repa-convert-4.2.0.1 (BenLippmeier)
06:14:16 <Cale> Maxdamantus: GHC as it stands will never instantiate a type variable with a polymorphic type on its own
06:14:50 <Cale> Athas: It's just as easy to support all ranks with respect to type *checking*, but there exists a type *inference* algorithm for rank 2 types
06:15:40 <Maxdamantus> Cale: is `x -> x` not considered a polymorphic type?
06:15:41 <reeze> @Cale: it sound like a imperative language. everytime there is an IO. executed?
06:15:41 <lambdabot> Unknown command, try @list
06:16:21 <Cale> reeze: Only the execution of IO actions can cause other IO actions to be executed. Evaluation of expressions can't cause IO actions to be executed.
06:16:38 <Cale> Maxdamantus: nope, but (forall x. x -> x) is
06:16:43 <Athas> Well, except for unsafePerformIO and friends...
06:16:54 <StoneToad> ssshhh
06:17:22 <maerwald> Cale: that model description with (Real)World even comes even from SPJ himself, so I don't see much of a problem with it
06:17:51 <Maxdamantus> Cale: what's the difference when `x -> x` is the whole type expression?
06:18:00 <maerwald> it's to begin developing an understanding, not to describe it perfectly technical
06:18:00 <Cale> Yeah, there are some low-level hooks you can use to cause evaluation of expressions to execute IO actions, but over the 13 or so years I've been programming in Haskell, I've only really needed that a couple of times. It's not something you take lightly.
06:18:10 <merijn> Maxdamantus: Who gets to pick "x"
06:18:14 <Athas> I like a no-nonsense operational description: GHC permits some "magical" thunks, whose forcing causes side-effects.  IO just packages this up in a way that makes it easy to preserve evaluation order.
06:18:18 <maerwald> if you want to describe everything perfectly technical, you cannot teach haskell at all
06:18:23 <merijn> Well, if it's the whole type, I guess nothing
06:18:34 <Maxdamantus> merijn: the instantiator of the definition.
06:18:34 <merijn> maerwald: Sure you can, I've had plenty of success
06:18:40 <mauke[> maerwald: it hinders understanding
06:18:40 <Cale> maerwald: SPJ is eloquent, but he is human, and is capable of not having the best possible description of things
06:18:41 <Maxdamantus> in both cases.
06:19:15 <Cale> maerwald: We have better explanations of how IO works than existed at the time that he wrote those papers.
06:19:28 <maerwald> haven't seen a better one yet
06:19:42 <maerwald> probably more precise ones, yes
06:19:59 <maerwald> but it's with all those white lies, they serve a purpose
06:20:32 <merijn> maerwald: See the explanation from me last night
06:20:36 <merijn> That is a better on, by far
06:20:42 <Cale> The best mental model IMO is something along the lines of thinking about IO as a datatype with constructors like ReturnIO :: a -> IO a, and BindIO :: IO a -> (a -> IO b) -> IO b, along with a bunch of primitive things like GetChar :: IO Char and PutChar :: Char -> IO (), and so on.
06:20:53 <mauke[> the difference is that RealWorld is useless as a model. it's not implementable and it doesn't tell you how things work (predictability)
06:21:05 * Maxdamantus continues to think the main point is that it demonstrates that no conceptual rules in Haskell are broken by an actual useful IO.
06:21:22 <Athas> Cale: this is very unsatisfactory if you want a proper operational understanding, though.  What about FFI and concurrency?
06:21:25 <mauke[> I'm so adamant about it because I still remember getting hung up on IO when learning Haskell for the first time
06:21:37 <ousado> as if a good description wasn't something completely specific to a given learner
06:21:44 <Cale> Athas: You can include a constructor which contains the data necessary to make an FFI call
06:21:48 <merijn> Athas: Sure, but RealWorld breaks in the presence of concurrency
06:21:49 <mauke[> Maxdamantus: I don't see how it demonstrates that
06:21:57 <Cale> and you can also include a constructor for ForkIO :: IO a -> IO ThreadId
06:22:00 <Athas> merijn: yes, I also do not think RealWorld is a good model.
06:22:11 <Cale> All the operational details go into the interpreter for the data structure
06:22:13 <mauke[> RealWorld breaks in the presence of putChar
06:22:34 <merijn> mauke[: oh?
06:22:38 <Maxdamantus> if you just say that `main` defines an impure program and stop there, it doesn't explain how you can actually run the program.
06:22:52 <Cale> Athas: If you want to see this plan in action, I believe Idris uses it.
06:22:53 <Athas> Cale: how does lazy IO fit into this?
06:22:54 <merijn> Maxdamantus: It doesn't define an impure program
06:22:56 <mauke[> Maxdamantus: that's the point, isn't it?
06:23:06 <mauke[> Maxdamantus: you can't "actually run" anything within Haskell
06:23:07 <Cale> Athas: Lazy IO still requires magic.
06:23:11 <merijn> Maxdamantus: It defines a pure description of an impure program and you CAN'T run it, that's the entire point
06:23:12 <Maxdamantus> mauke[: but you can.
06:23:15 <merijn> Maxdamantus: No
06:23:21 <merijn> Maxdamantus: The runtime system can run programs
06:23:27 <mauke[> Maxdamantus: show me
06:23:32 <Maxdamantus> merijn: you can implement the runtime system inside Haskell.
06:23:33 <Cale> Athas: Well, you need a way to have the evaluation of an expression trigger the executor
06:23:38 <merijn> Maxdamantus: You can't
06:23:44 <Maxdamantus> merijn: it just won't have any concept of the "actual" real world.
06:23:46 <merijn> Maxdamantus: Not without already having a runtime system
06:23:55 <mauke[> Maxdamantus: so it's useless
06:23:57 <Athas> Cale: see, this is why I suggest just saying the truth.  GHCs runtime implementation is not complex to someone with a basic computer science background.  Just explain thunks and forcing in basic terms.
06:24:07 <Maxdamantus> People used Haskell to perform computations before they had IO.
06:24:11 <mauke[> Maxdamantus: I'm not interested in simulating a pure world
06:24:13 <Maxdamantus> or monads.
06:24:13 <Cale> Athas: But, for instance, unsafePerformIO x would just be implemented by calling the executor on x
06:24:15 <merijn> Maxdamantus: There's always been IO
06:24:24 <merijn> Maxdamantus: It just wasn't implemented using monads or the current IO type
06:24:44 * frerich predicts this discussion soon goes on a tanget about what 'running programs' means and how evaluation differs from execution -- and wonders how all this must sound to somebody who only just started looking at Haskell.
06:24:45 <mauke[> Maxdamantus: I want to understand how HelloWorld.hs actually gets letters on the screen
06:24:48 <Cale> Athas: GHC's actual implementation *isn't* the same as the RealWorld model that gets thrown around.
06:25:04 <Athas> Cale: right, exactly.  I would never use that model either.
06:25:13 <Cale> Athas: It just is made to look a bit like that by calling the type of 0-byte wide tokens "RealWorld"
06:25:18 <Maxdamantus> mauke[: then the RealWorld model isn't useful, unless you're interested in a model of a screen.
06:25:29 <Cale> But GHC's actual implementation also isn't a good mental model
06:25:36 <Athas> Why not?
06:25:38 <merijn> Maxdamantus: Name one case where the RealWorld model *is* useful
06:25:40 <mauke[> Maxdamantus: well, duh
06:25:57 <Cale> Because it's an awful hack which puts the effects into values of function types.
06:26:10 <Athas> What's the problem?  It works.  It is not a hack.
06:26:19 <mauke[> Athas: it's not Haskell
06:26:24 <Athas> You always have to go outside the semantics of a language when you map it to real hardware.
06:26:24 <mauke[> it just pretends to look like it
06:26:29 <Cale> It works well *and* it is a hack.
06:26:32 <mauke[> and that's super confusing
06:26:33 <Maxdamantus> runIO (putStrLn "hello") (RealWorld { screen = "", .. }) = RealWorld { screen = "hello", .. }
06:26:55 <Cale> It's not a good way of thinking about programs.
06:26:56 <Athas> Right, which is why I would explain how the IO monad is an elegant way to cover up the magic.
06:27:03 <Maxdamantus> merijn: it's only useful in showing that IO in Haskell doesn't break any rules like it does in Clean.
06:27:24 <Athas> Right, it's not a good way to reason, but it's a good way to explain Haskell IO to someone who actually wants to know *how* it works.
06:27:34 <mauke[> Athas: ah, now I understand why people think Haskell isn't "really" pure and that monads are just a hack
06:27:39 <Maxdamantus> merijn: because if it weren't for the complexity, someone could easily just model it in the language.
06:27:51 <merijn> Maxdamantus: How does IO in Clean break any rules?
06:27:53 <Cale> Athas: The implementation of the IO data type itself (let's be honest here, the fact that it's a monad isn't really very important) needn't be magical in any way.
06:27:58 <Athas> Most other explanations are horribly self-referential or gibberish to someone who just wants to understand how Haskell manages to tell the operating system to do IO.
06:28:02 <mauke[> Maxdamantus: what does your runIO have to do with Prelude.IO?
06:28:11 <Cale> Athas: All the effectfulness can be placed inside an *interpreter* for the IO action values.
06:28:11 <Maxdamantus> mauke[: it doesn't.
06:28:26 <mauke[> Maxdamantus: then it doesn't show that IO doesn't break any rules
06:28:26 <Cale> Athas: an interpreter which could indeed be written in Haskell (with IO actions of course)
06:28:30 <Athas> Cale: that interpreter cannot be written in Haskell-sans-IO, so how is that different from magical thunks?
06:28:44 <Athas> Either it becomes self-referential, or you step outside Haskell.
06:28:52 <Cale> Because it keeps your thinking about *evaluation* sane
06:29:06 <Cale> (at least for the most part)
06:29:08 <Maxdamantus> mauke[: you can implement a different IO type in a different module, along with a different `putStrLn`, etc
06:29:20 <mauke[> Maxdamantus: yes, and it won't prove anything about Prelude.IO
06:29:41 <mauke[> for example, I can define data IO = False | True
06:29:44 <Maxdamantus> mauke[: why would it?
06:29:50 <merijn> Maxdamantus: Can you clarify what you mean about io in Clean breaking rules?
06:29:51 <mauke[> it's very pure and all
06:30:21 <Cale> Athas: You could write the entire RTS (even my imaginary RTS which includes such an interpreter) as a Haskell program. The executor would pattern match on the IO action value for main, and simply carry out the described effects
06:30:22 <Maxdamantus> merijn: you can't do what I just showed using Clean's I/O.
06:30:28 <Maxdamantus> 01:26:11 < Maxdamantus> runIO (putStrLn "hello") (RealWorld { screen = "", .. }) = RealWorld { screen = "hello", .. }
06:30:34 <Maxdamantus> merijn: afaik, there's no analogue to that.
06:30:35 <Athas> Cale: how would it carry them out, though?
06:30:39 <Cale> execute (BindIO x f) = do v <- execute x; execute (f v)
06:30:42 <merijn> Maxdamantus: How is that relevant to breaking rules or not?
06:30:48 <merijn> Maxdamantus: Which rules are being broken?
06:30:54 <Maxdamantus> merijn: it shows that Clean's I/O introduces new concepts.
06:30:55 <Cale> execute GetChar = getChar
06:31:08 <Cale> and so on
06:31:10 <mauke[> Maxdamantus: so ... what is your interest in IO? your stuff is completely separate from Prelude.IO. are you just interested in proving things about types named "IO"?
06:31:13 <Maxdamantus> merijn: Haskell's I/O doesn't introduce any new concepts.
06:31:24 <merijn> Yes it does
06:31:39 <Cale> Athas: The IO datastructures just need to have pure representations of what needs doing
06:31:40 <Athas> Cale: this is self-referential.  This does not answer the question I asked when I first learnt Haskell, which was "how does it know when to make system calls, and how does it do that"?
06:31:41 <Maxdamantus> What concepts does it introduce?
06:31:42 <merijn> It's the only way to interact with the world
06:31:49 <merijn> Maxdamantus: Interaction with the universe
06:31:49 <Maxdamantus> That's not a concept.
06:31:56 <merijn> ...
06:32:03 <Maxdamantus> I can make my own universe in Haskell.
06:32:03 <mauke[> Athas: personally, my answer would be "the RTS is not written in Haskell"
06:32:13 <merijn> says who?
06:32:14 <Cale> Well, it's not, but it could be, easily.
06:32:24 <mauke[> Cale: no, it can't
06:32:29 <Athas> mauke[: okay, and that's fair, but you just need to explain how Haskell interacts with the RTS.
06:32:40 <Cale> mauke[: Why?
06:32:42 <mauke[> Athas: right, but that part is "obvious"
06:32:53 <Cale> mauke[: What does the RTS do which can't be done in Haskell?
06:33:05 <mauke[> Cale: do I/O
06:33:06 <merijn> mauke[: You could write it in pure haskell if you extended the compiler with a few more primitives
06:33:07 <Athas> mauke[: the magical thunks?  I did not find it obvious before I was old.  Mostly because my head had been filled with totally unrelated lies about RealWorld.
06:33:14 <Athas> Er, before I was told.
06:33:15 <mauke[> Athas: what magical thunks?
06:33:16 <Cale> mauke[: Uh, what? We can do I/O in Haskell
06:33:21 <Maxdamantus> merijn: says me any my ability to write: data RealWorld = ..; type IO = State RealWorld
06:33:31 <mauke[> Cale: no, you can't
06:33:38 <merijn> mauke[: Why not?
06:33:38 <mauke[> Cale: and by that I mean: how?
06:33:39 <Cale> The evaluation of Haskell expressions can't cause I/O to happen, but that doesn't mean that Haskell programs don't do I/O.
06:33:42 <Athas> mauke[: the ones that actually perform side effects when forced.  They are not really magical, maybe "built-in" is a better word.
06:33:51 <Cale> mauke[: Of course, you should know this :)
06:33:52 <mauke[> Athas: example?
06:33:58 <Maxdamantus> merijn: Clean's I/O relies on mutation within functions, which is a new concept.
06:34:07 * hackagebot hint 0.4.2.3 - Runtime Haskell interpreter (GHC API wrapper)  http://hackage.haskell.org/package/hint-0.4.2.3 (DanielGorin)
06:34:09 * hackagebot yesod-angular-ui 0.1.1.0 - Angular Helpers  http://hackage.haskell.org/package/yesod-angular-ui-0.1.1.0 (tolysz)
06:34:09 <merijn> mauke[: if runIO is a compiler primitive instead of a runtime primitive, why couldn't I write a runtime in haskell?
06:34:09 <Cale> mauke[: You would of course use plenty of IO actions in writing the RTS
06:34:17 <mauke[> Cale: Haskell programs "do I/O" by running code that is not in Haskell
06:34:26 <Cale> mauke[: And probably a fair amount of low-level FFI/memory management stuff
06:34:31 <merijn> mauke[: There's no reason that's required, though
06:34:33 <Cale> IO actions are Haskell too
06:34:42 <merijn> mauke[: You could build the primitives into the compilers code generation
06:34:54 <merijn> mauke[: It'd complicate your compiler, but I don't see a fundamental issue?
06:35:09 <Athas> mauke[: isn't that exactly how the GHC primops work?  Well, I suppose they are not actually "thunks" per se...
06:35:20 <mauke[> Athas: I have no idea what those are
06:35:40 <merijn> mauke[: I mean, haskell can adds Int without calling non-haskell code
06:35:58 <Cale> Anyway, Simon Marlow himself has said that there's not much good reason that the RTS should be written in C except for the fact that it already is.
06:36:00 <mauke[> merijn: runIO = unsafePerformIO
06:36:09 <merijn> mauke[: Why?
06:36:22 <Cale> and I'd trust him to be able to check something like that :)
06:36:25 <Maxdamantus> mauke[: that's not a sufficient definition for runIO.
06:36:27 <mauke[> merijn: ah. what else could it be?
06:36:37 <merijn> mauke[: A compiler primitive
06:36:44 <mauke[> merijn: what is its type?
06:37:00 <Cale> There's nothing in particular that the RTS does at present which can't be written as a Haskell program (and I mean all of Haskell, not just expression evaluation of course)
06:37:27 <mauke[> Cale: that sentence makes no sense to me so our mental models diverge
06:37:39 <Cale> GHC is a Haskell program
06:37:43 <Athas> mauke[: I actually don't recall the exact details, but as I recall, the functions here ( https://github.com/ghc/ghc/blob/master/rts/PrimOps.cmm ) are exposed to Haskell as sort of magical functions, that when forced like a thunk, causes an effect.
06:37:49 <Athas> But maybe there is a little more glue first.
06:37:54 <mauke[> Cale: how do you define "Haskell program"?
06:38:03 <merijn> mauke[: ok, runIO was the wrong name to suggest. Lemme rephrase, what's stopping me from implementing bindIO, returnIO and all current runtime calls as primitives in the code generator?
06:38:26 <mauke[> Athas: that doesn't look like Haskell code
06:38:27 <Cale> mauke[: Well, okay, GHC has some C bits, so not a good example. Anything which can be written entirely in Haskell and compiled with GHC is a Haskell program.
06:38:33 <Athas> mauke[: right, it's not.
06:38:47 <Cale> mauke[: That includes the execution of main.
06:38:48 <Athas> But it might as well be.
06:39:10 <Pato> I have a data type for lists "data SList a b = Sent b | Cons (a, SList a b)" and I need to write a function to merge the lists, using a hylomorphism. So I need to get the mgen done in the following: merge' = hyloSList (either id cons) mgen. I have no clue on what the mgen could be
06:39:13 <Cale> Execution of IO actions is part of Haskell, it's just (mostly) separate from evaluation of Haskell expressions.
06:39:15 <mauke[> Cale: that's ambiguous
06:39:33 <merijn> mauke[: They define compiler primitives, so unless you demand your entire is specified in haskell (which it could be, it'd just be a lot of effort) I don't see why the notation of builtin primitives matters
06:39:34 <frerich> mauke[: By your definition you cannot do IO in anything other than pure assembler programs?
06:40:02 <merijn> mauke[: I mean, "how can C do IO?"
06:40:16 <merijn> mauke[: "because the C compiler generates the relevant binary code"
06:40:18 <frerich> mauke[: Since any layer on top doesn't actually do IO itself but only calls other code (in other languages) which then does IO.
06:40:23 <mauke[> C can't do I/O either
06:40:30 <Cale> Pato: It's like some sort of cruel joke that they're having you take this course while you're a beginner at Haskell :)
06:40:37 <merijn> mauke[: Ok, so you need system calls that you call from C
06:40:57 <merijn> mauke[: Your compiler can generate the code for system calls as easily from haskell as from C
06:41:05 <mauke[> merijn: what do you mean by "runtime calls"?
06:41:18 <Pato> Cale:  I'm getting desperate because I know I can do the theorical test, but I'm going insane in getting things to work in haskell
06:41:20 <merijn> Where did I say runtime calls?
06:41:34 <Cale> mauke[: main = putStrLn "Hello, world!"  -- see, Haskell programs can do terminal output!
06:41:35 <Pato> Cale: it's the last subject I need to complete to finish my degree
06:41:35 <mauke[> merijn: "Lemme rephrase, what's stopping me from implementing bindIO, returnIO and all current runtime calls"
06:41:36 * frerich reads 'C can't do I/O either' and sighs
06:41:53 <merijn> mauke[: getLine, putChar, etc. (or the primitives that they're implemented with)
06:42:00 <mauke[> frerich: that was actually a major point, that Pascal had I/O built in and C didn't
06:42:15 <mauke[> merijn: I don't see those as runtime calls
06:42:32 <mauke[> I mean, that's the whole point: Haskell is pure
06:42:36 <Athas> Turns out that C was right in that debate.
06:42:41 <merijn> mauke[: I mean, if I have a system call primitive what's stopping me from performing read(2)?
06:43:04 <Cale> Pato: This stuff is mostly not hard if you already know Haskell well, even if it's a bit weird to try to force your programs into this peculiar style where all the recursion is expressed in terms of these schemes. But for a beginner, you must think Haskell is just absurd trying to do this :D
06:43:11 <mauke[> merijn: if by primitive you mean impure function, the answer's laziness. otherwise I don't know
06:43:18 <merijn> mauke[: "read :: Int -> IO (Either Error ByteString)"
06:43:35 <Cale> Pato: Okay, so what's the type of hyloSList?
06:43:49 <Athas> A good way to get a feel for IO *implementation*, I think, is to use the FFI to import a bunch of impure functions (like read(2)) as non-IO functions, and use that to make a new IO monad from scratch.
06:44:02 <Athas> That's more or less what GHC does.
06:44:03 <mauke[> Athas: I think that's a terrible idea
06:44:22 <mauke[> and yeah, GHC does it ass backwards
06:44:24 <Pato> Cale: Yeah, because I understand the theorical concepts. For instance, like 15 minutes ago, I was having trouble to get a "outSList" to work. I knew I had the "logic" right but it just wouldn't work. I found out by trial and error that it was a damn parenthisis in the declaration
06:44:27 <merijn> mauke[: Why would a primitve have to be impure?
06:44:39 <Pato> Cale: hyloSList   :: (Either b (d, c) -> c) -> (a -> Either b (d, a)) -> a -> c
06:44:42 <merijn> mauke[: If the primitve is in IO you're fine
06:44:53 <Athas> mauke[: it's a good idea for people like me who are curious about when the "magic" is introduced.  What is a better implementation?
06:45:12 <merijn> Athas: There is no real magic in IO
06:45:13 <mauke[> merijn: I'll have to think about this. for now it seems to reduce to "IO is magic"
06:45:15 <Cale> Athas, mauke[: It's totally possible to define your own type of IO actions as a free monad, and write an interpreter for that type as a Haskell function, which effectively has type MyIO a -> IO a
06:45:29 <Athas> merijn: right, I agree.  But there is magic in the *implementation* of the primitives.
06:45:31 <merijn> mauke[: Well, compiler primitives *are* magic, that's the point
06:45:45 <mauke[> Athas: separation between pure Haskell and impure interpreter
06:46:00 <merijn> mauke[: I mean, how does C know what "+" does? It just happens that that knowledge is builtin to the compiler and it generates the right code
06:46:02 <Athas> mauke[: yeah, I'm just suggesting that people write their own impure interpreter.
06:46:03 <mauke[> merijn: but IO isn't magic
06:46:04 <tdammers> A more elegant implementation would be to have a (hidden) DSL, write your IO primitives as expressions in that DSL, and then write an interpreter for the DSL in some impure language
06:46:24 <merijn> mauke[: All you need is a compiler that generates code that evaluates "main :: IO a"
06:46:34 <merijn> mauke[: And puts that as entry point for your binary
06:46:37 <Cale> Athas, mauke[: What I'm suggesting is that people *ought* to think of IO a *as being* that free monad. (Maybe without the need for explaining what a free monad is, just defining the datatype or something roughly equivalent to what you'd get via free monads)
06:46:43 <Athas> tdammers: that is essentially what GHC does, with the IO monad being the DSL, and the interpreter being written in Haskell-with-magical-primitives.
06:47:19 <mauke[> Cale: that's how I'm already thinking about it, hence the interpreter making no sense because it would be the identity
06:47:25 <Athas> Cale: there is a distinction here between how you should *think* about IO (when using it, say), and how it *works in GHC specifically*.  I think both are useful things to know.
06:47:26 <merijn> mauke[: IO just enforces the sequencing and stops effects from escaping, which is why your IO performing primitives have to be labelled with IO. But the code GHC generates can do whatever any binary can
06:47:53 <tdammers> Athas: the monadic nature of IO is only marginally relevant here
06:48:13 <mauke[> merijn: again, I have to think about this more but "labelled with IO" is a red flag
06:48:25 <merijn> mauke[: That's exactly what it is currently in GHC
06:48:41 <mauke[> merijn: that doesn't make it right or true
06:48:47 <maerwald> I'm not sure the nitpick discussion leads anywhere
06:49:29 <Cale> mauke[: Well, once you actually say "execute the resulting action", it's not the identity any longer. If the 'main' of your program actually executes the result of that interpretation, then it's not simply heating up your CPU
06:50:27 <Cale> mauke[: and you might get the datastructure you're interpreting by picking apart the evaluated 'main' of another Haskell program
06:50:35 <merijn> mauke[: The "+# :: Int# -> Int# -> Int#" primitive generates code that does machine addition of two unboxed ints, this is pure and GHC knows which code to generate. If you build in the code for system calls into GHC "read :: Int# -> IO ByteString" it will perform a system call when executed. If you define the primitve "Int# -> ByteString" this is a problem, because it can be moved around and it's side effe
06:50:41 <merijn> cts would become visible. But because the primitive is IO it enforces the same sequencing/separation that IO does know, making the effects unobservable outside of IO
06:50:52 <Cale> Pato: all right, let's do this... what exactly do you mean by 'merge' here?
06:52:26 <mauke[> merijn: I can't even get my mind around +# being a primitive
06:52:49 <Pato> Cale: Alright, there is a function called merge, that has the following type: "merge :: Ord a => ([a], [a]) -> [a]". It takes 2 lists and merges them into 1. Now, I have to define a equivalent function, but using a hylomorphism. The types are as follows
06:53:04 <merijn> mauke[: How is that different from + in a C compiler?
06:53:13 <mauke[> merijn: consider 'let x = (+#) 1 in length [x, x]'
06:53:22 <Cale> Pato: So, the lists are assumed to be sorted, and we want the resulting list to be sorted as well?
06:53:28 <mauke[> no machine addition involved. so what is +# doing here?
06:54:08 * hackagebot codex 0.3 - A ctags file generator for cabal project dependencies.  http://hackage.haskell.org/package/codex-0.3 (aloiscochard)
06:54:10 * hackagebot data-hash 0.2.0.1 - Combinators for building fast hashing functions.  http://hackage.haskell.org/package/data-hash-0.2.0.1 (DanielGorin)
06:54:42 <merijn> mauke[: 1 and (+#) are values, a partial allocation thunk is allocated with that data, then we continue evaluating "length [x, x]"
06:54:57 <mauke[> thunks are not part of haskell
06:55:17 <Pato> Cale: this is the data "data SList a b = Sent b | Cons (a, SList a b) deriving" and the hylomorphism defined for that datatype is the following
06:55:23 <merijn> mauke[: That's how GHC compiles that, you could optionally compile it differently
06:55:24 <mauke[> merijn: if (+#) is a value, what value is it?
06:55:25 <c_wraith> they are, however, the obvious implementation strategy for lazy evaluation
06:55:36 <Pato> Cale: hyloSList   :: (Either b (d, c) -> c) -> (a -> Either b (d, a)) -> a -> c
06:55:54 <merijn> mauke[: A pointer to code, although that is (also!) an implementation detail of how you choose to compile
06:56:01 <mauke[> merijn: this problem doesn't occur in C because + isn't a value in C
06:56:12 <Pato> Cale: Now, the function I have to define is:                         merge = hyloSList [id , cons] mgen
06:56:35 <SrPx> Hi guys, I'm back. Yesterday I asked what is the best way to store self-references on a datatype. I could use ints/lists representing the path for the referenced value on the AST. I could store Lens Foo TargetValue. Then you guys suggested comonads. I've read about comonads and the store comonad.
06:56:38 <mauke[> merijn: and also because a C compiler doesn't have to provide code for +
06:56:43 <mauke[> it's not a function
06:56:52 <Cale> @let data SList a b = Sent b | Cons (a, SList a b)
06:56:54 <lambdabot>  Defined.
06:56:55 <merijn> mauke[: It generates code for the expression
06:57:05 <mauke[> merijn: I don't think I agree
06:57:23 <Pato> Cale:  and it must pass these tests: test05a = mgen      ([0,2,5],[0,6]) == i2 (0,([2,5],[0,6]));test05b = mgen ([0, 2, 5], []) == i1 [0,2,5];test05c = merge' ([],[0,6]) == [0,6];
06:57:27 <merijn> mauke[: So how does a C compiler compile + according to you, then?
06:57:28 <SrPx> If I understand correctly, using comonad means I have to declare a Comonad instance for my types and store the paths as Ints/Lists as I said, being Comonad just an interface to use that information. Is that correct?
06:57:37 <Pato> Cale: where i1 = Left and i2 = Right
06:57:38 <mauke[> merijn: it doesn't. + doesn't exist in isolation
06:58:04 <mauke[> it's not a "thing" in my mental model
06:58:05 <merijn> mauke[: "int main(int argc, char** argv) { return argc + 2; }" <- go
06:58:15 <merijn> How is that compiled?
06:58:23 <mauke[> depends
06:58:29 <Cale> @let anaSList f x = g where g x = case f x of Left b -> Sent b; Right (a, y) -> Cons (a, g y)
06:58:31 <lambdabot>  Defined.
06:58:49 <merijn> mauke[: I can also say "depends" for haskell, pick an implementation
06:58:59 <Pato> Cale: I have the anamorphism and catamorphism defined if needed as well
06:59:10 <jonrus> Anyone know if it'd be possible to compile a simple Haskell program for ubuntu on OSX?
06:59:23 <Cale> @let cataSList s c = f where f (Sent b) = s b; f (Cons (a, xs)) = c a (f xs)
06:59:25 <lambdabot>  Defined.
06:59:40 <merijn> jonrus: Cross-compilation is...still a hassle
07:00:04 <merijn> jonrus: It should be possible, but in all honesty, you're probably better of installing VirtualBox + an Ubuntu VM and compiling on that
07:00:36 <jonrus> merijn: Thanks, I'll do that so. No problem, was just wondering if it was possible!
07:00:44 <Cale> Oh, maybe I should have written that cata a little differently
07:00:52 <mauke[> merijn: by "how", do you mean the result or the process?
07:00:56 <Pato> Cale: no worries, do as you think it's best
07:01:08 <Pato> Cale: I'll try to understand it
07:01:16 <merijn> jonrus: If you're willing to suffer pain, google "ghc cross compilation" and try if you can get it working and report issues you run into ;)
07:01:23 <mizu_no_oto> jonrus: https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling
07:01:36 <Cale> Pato: I tend to usually write catamorphisms in a form where they take as arguments the replacements for each constructor of the datatype directly.
07:02:01 <Cale> Pato: This isn't as useful for analysis/computation of programs perhaps, but it's more practically useful.
07:02:16 <merijn> mauke[: Well, if we're gonna assume that we want a C compiler that produces an ELF binary for linux (so, the usual case) we need to somehow generate machine code that implements this program
07:02:42 <mauke[> that doesn't help me answer your question :-/
07:02:55 <Cale> @let cataSList' f = g where g (Sent b) = f (Left b); f (Cons (a, xs)) = f (Right (a, (f xs)))
07:02:57 <lambdabot>  .L.hs:156:25:
07:02:57 <lambdabot>      Couldn't match expected type ‘SList t1 t0’
07:02:57 <lambdabot>                  with actual type ‘Either a1 b0’
07:02:58 <merijn> mauke[: And we're in agreement that a C compiler can produce such a binary without a runtime system that is implemented in something that is not C, yes?
07:02:59 <Cale> oops
07:03:09 <Cale> @let cataSList' f = g where g (Sent b) = f (Left b); f (Cons (a, xs)) = f (Right (a, g xs))
07:03:11 <lambdabot>  .L.hs:157:12:
07:03:11 <lambdabot>      Couldn't match expected type ‘Either a1 (t3, t4)’
07:03:11 <lambdabot>                  with actual type ‘SList t3 a1’
07:03:28 <Cale> tsk, what am I doing here...
07:03:31 <mizu_no_oto> jonrus: Basically, you need to build a special cross-compiling GHC, get a C compiler that outputs Linux executables + linux versions of C libraries, and then use that
07:03:33 <merijn> mauke[: Or do you object to this conceptual C compiler too?
07:03:37 <Cale> (trying to edit without thinking)
07:03:52 <mauke[> merijn: I'm still thinking about your first question
07:04:09 * hackagebot jose-jwt 0.6 - JSON Object Signing and Encryption Library  http://hackage.haskell.org/package/jose-jwt-0.6 (LukeTaylor)
07:04:12 <jonrus> mizu_no_oto: OK coming at the end of the sprint I think I'll have to go the VM route for now, but this looks interesting
07:04:19 <merijn> mauke[: This was meant as clarification of the C code question
07:04:36 <mauke[> merijn: then you've completely lost me
07:04:39 <mizu_no_oto> jonrus: I once tried to cross compile to arm, and ended up giving up.  The VM route is definitely going to be easier
07:05:50 <merijn> mauke[: Let's rewind, do you agree or disagree that it's possible to create C compiler that given my example program produces a standalone ELF binary without needing a runtime system that is implemented in something other than C?
07:06:04 <Cale> aha, that's what I want...
07:06:07 <Cale> @undefine
07:06:07 <lambdabot> Undefined.
07:06:15 <Cale> @let data SList a b = Sent b | Cons (a, SList a b) deriving (Eq, Ord, Show)
07:06:18 <lambdabot>  Defined.
07:06:18 <mauke[> merijn: that's not rewinding, that's the top of the question stack
07:06:27 <Cale> @let anaSList f x = g where g x = case f x of Left b -> Sent b; Right (a, y) -> Cons (a, g y)
07:06:29 <lambdabot>  Defined.
07:06:35 <Cale> @let cataSList s c = f where f (Sent b) = s b; f (Cons (a, xs)) = c (a, f xs)
07:06:37 <lambdabot>  Defined.
07:06:41 <Cale> @let cataSList' f = cataSList (f . Left) (f . Right)
07:06:44 <lambdabot>  Defined.
07:06:52 <jonrus> mizu_no_oto: Thanks :)
07:06:53 <merijn> mauke[: I meant "forgot everything between now and the start and restart this discussion from this point"
07:06:58 <merijn> s/forgot/forget
07:08:03 <mauke[> merijn: huh. that depends on what counts ar a "runtime system"
07:08:07 <mauke[> s/ar/as/
07:08:15 <Cale> whoops
07:08:25 <Cale> stupid x there :)
07:08:30 <Cale> in anaSList
07:08:37 <Cale> sorry everyone :P
07:08:38 <mauke[> I think the answer to my previous question is: (+#) = \x -> \y -> __primitive_add x y
07:08:44 <Cale> @undefine
07:08:44 <lambdabot> Undefined.
07:08:54 <merijn> mauke[: "Anything other than the code or the compiler output"
07:08:56 <mauke[> that is, +# itself is not primitive
07:09:00 <Cale> Actually, to prevent so much noise, let's go to #haskell-overflow
07:09:09 <Cale> Pato: ^^
07:09:25 <tdammers> merijn: one can trivially embed the "runtime" into the compiler though
07:09:28 <mauke[> merijn: ... but the compiler output is code?
07:09:43 <merijn> mauke[: The compiler output is "an ELF binary"
07:09:51 <mauke[> which is code
07:09:57 <merijn> tdammers: Sure
07:09:58 <tdammers> but really all that says is that the term "runtime" is a bit vague
07:10:05 <merijn> Athas: Yes
07:10:11 <merijn> s/Athas/mauke[
07:10:42 <mauke[> so glibc would be a runtime system
07:11:19 <merijn> mauke[: +# is not "(+#) = \x -> \y -> __primitive_add", though. +# *is* the primitve_add, but it is also a function
07:11:22 <merijn> mauke[: Yes
07:11:44 <mauke[> it can't be both
07:11:49 <merijn> mauke[: Why not?
07:12:21 <mauke[> because functions aren't primitives. I wonder why not ...
07:12:34 <merijn> "functions aren't primitives"? Why not?
07:12:53 <merijn> Both Core and STG have functions...
07:12:54 <mauke[> heh. you don't need to repeat after me :-)
07:13:45 <mauke[> Core/STG are out of scope; they're not Haskell
07:14:28 <mauke[> ok, so I'm reverse engineering my "intuitive" understanding of what a primitive is
07:14:59 <Athas> It has always helped me to look at compiler code.
07:15:08 <merijn> I don't think so, I'm making an existential claim "exists x. where x is a haskell compiler implemented purely in haskell", so it's sufficient that there is AN implementation that can do that. And my personal understanding leans heavily on how GHC is implemented
07:15:17 <Athas> But then again, I'm a compiler PhD student, so I'm probably damaged.
07:15:21 <mauke[> no, compilers only obfuscate languages
07:15:30 <merijn> We can pretend STG is just algebraic datatype defined in haskell instead of a language
07:15:43 <merijn> But that seems like a "you say potato, I say potato" issue to me
07:16:04 <merijn> (that ADT then being used in this pure haskell-haskell compiler during the compilation)
07:17:36 <mauke[> let's see. a primitive is atomic: it doesn't decompose into other constructs. it's implemented directly in the compiler
07:18:34 * magneticDuck sometimes wonders if you wan write a new language defined only by a compiler for that language written natively, and then.. you know.. resolve a non-trivial fixed point..
07:19:05 <mauke[> ah, and what I meant above was actually (+#) = \x -> \y -> <magic happens here>
07:20:11 <mauke[> because we need to apply +# to two arguments before anything happens
07:20:15 <merijn> mauke[: Except that (partial) function application in general is also "magic happens here"
07:20:21 <mauke[> before that it's just normal Haskell
07:20:37 <Athas> magneticDuck: isn't that how you often bootstrap new languages?
07:20:41 <merijn> In generated code, at least
07:20:51 <Athas> Typically, resolving that fixed point is done by creating a super-hacky compiler in another language.
07:20:56 <merijn> Athas: New languages aren't defined in terms natively written compilers
07:21:13 <Athas> I do not understand that sentence.
07:21:21 <mauke[> missing "of"
07:21:36 <Athas> Okay, maybe I don't understand the denotation of "natively written compiler".
07:21:41 <OutlawStar> is there a recommend XML parser package that one should be using these days, i've seen xml-conduit and HaXml. I will mainly just be using the streaming functionality
07:22:02 <merijn> Athas: I think he was implying "new language defined *only* by a compiler for that language written natively" (emphasis mine) where I understand "written natively" as "in that language"
07:22:19 <merijn> OutlawStar: I've use xml-conduit and found it fairly straightforward
07:22:22 <merijn> *used
07:22:23 <magneticDuck> Athas: well, yeah, that's one way of resolving the fixed point
07:22:33 <Athas> Okay,  Well, plenty of languages are defined by their ad-hoc implementations.
07:22:56 <merijn> Athas: Yeah, but their ad-hoc implementation isn't in the language they're ad-hoc specifying ;)
07:23:35 <OutlawStar> merijn: Yeah, looks like it. I was mainly just wondering if there were packages that were just old and more recent packages had been written that were better
07:24:17 <merijn> OutlawStar: Bonus of xml-conduit is that it trivially plugs into http-conduit for fetching said files from the web
07:24:22 <nuttycom> Anybody know why none of the package docs for https://hackage.haskell.org/package/semigroupoids are linked? I can find the sources, but none of the docs.
07:24:38 <mauke[> merijn: I think I see where you're going (re: Haskell compiler primitives) but that doesn't match my abstract model of C compilation at all
07:24:38 <OutlawStar> merijn: yes, that was my line of thinking as well :)
07:25:17 <tdammers> merijn: wouldn't a "language defined only by a compiler written in the language itself" kind of result in an arbitrary language?
07:25:26 <nuttycom> I guess it's just for the 5.x series, seems like the links are there for the 4.x releases
07:25:33 <kadoban> nuttycom: If you go back to 4.5 there's docs. Not that that's 100% helpful, but … it's something.
07:25:35 <merijn> mauke[: Yeah, I mentioned that C probably breaks down due to a compiler not necessarily having to implement system calls so I'm not sure you can actually sanely do anything
07:25:37 <mauke[> merijn: because my C model goes something like this: parse code into AST -> analyze to determine semantics -> (think) -> recreate asm program from scratch
07:26:03 <mauke[> so a C operator like + doesn't actually map to anything
07:26:14 <kadoban> It used to be that hackage would kind of fail to build docs sometimes, but I've heard that's been fixed so I dunno why those wouldn't be there. They may actually be broken? I dunno.
07:26:20 <merijn> To be fair, you could take the same approach for haskell
07:26:23 <tdammers> people write kernels in C
07:26:31 <merijn> tdammers: Note, there's two C's
07:26:35 <Athas> Asking what + maps to in C is like asking what application maps to in Haskell.
07:26:35 <merijn> tdammers: Standalone and hosted
07:26:39 <tdammers> yep
07:27:04 <tdammers> I know
07:27:07 <tdammers> it's still C though
07:27:08 <Athas> If you want to get into pedantry, there is a C per implementation, due to the number of implementation-defined semantics.
07:27:25 <Athas> It is not a useful discussion.
07:27:49 <mauke[> merijn: it's harder for Haskell, I think
07:28:19 <merijn> mauke[: Well yes, it's much easier to take an "iterative refinement towards asm" approach than "recreate from scratch"
07:32:08 <orion> When it comes to Warp, how do you effectively use the authentication middleware?
07:33:48 <aloiscochard> if I set `-Wall` I don't have to add `-fwarn-incomplete-patterns`, it's redundant, right?
07:34:03 <orion> Let's say you want to password protect a resource. If you run warp like this: main = run 3000 $ basicAuth (\u p -> return $ u == "michael" && p == "mypass") "My Realm" $ myapp -- then the request will be processed by myapp before any checks on the route are performed.
07:34:26 <orion> That could be fine for a GET, but what if the verb is POST?
07:35:15 <tdammers> orion: I prefer to not do authentication in the middleware
07:35:23 <tdammers> more fine-grained control
07:35:30 <orion> tdammers: Sure, and I agree.
07:35:43 <orion> But, there is an HttpAuth middleware in the wai-extra package.
07:35:47 <orion> https://github.com/yesodweb/wai/blob/master/wai-extra/Network/Wai/Middleware/HttpAuth.hs
07:35:53 <tdammers> yes, I know
07:36:09 <orion> If what I'm saying is true, then this middleware is almost useless.
07:36:36 <tdammers> well, I believe the use case is that you want to have http auth on the entire application
07:37:14 <orion> tdammers: But even then, the requests will be fully processed by the application before hitting the middleware.
07:37:32 <tdammers> no, I don't believe that's true
07:37:51 <tdammers> that's what the authOnNoAuth hook is for
07:39:15 <orion> tdammers: I don't believe so: "Takes the realm and returns an appropriate 401 response when authentication is not provided."
07:39:32 <tdammers> look at the type
07:39:49 <tdammers> and note that it's a user-provided function
07:40:03 <tdammers> you pass it to basicAuth as part of the AuthSettings
07:40:47 <tdammers> and when the auth check fails, basicAuth will return the Application from authOnNoAuth instead of the one it's acting on
07:41:33 <orion> tdammers: Hmm, true.
07:42:06 <tdammers> basically, what it does is if authCheckOK then runOriginalApp else runOnNoAuthApp
07:42:32 <tdammers> so it works just fine
07:42:51 <tdammers> the reason why I prefer doing it as part of the application itself is to avoid redundant route parsing
07:42:56 <orion> Right
07:43:20 <orion> So, how does one define whether the Middleware acts on the Request or on the Response?
07:43:29 <tdammers> it acts on both
07:43:34 <tdammers> look up the definition of Application
07:43:40 <tdammers> (and of Middleware)
07:43:50 <tdammers> type Middleware = Application -> Application
07:44:35 <orion> Hmm, so the 
07:44:50 <orion> Hmm, so the Middleware is evaluated from right to left then.
07:47:26 <tdammers> the middleware is a function that takes an application and turns it into a different application
07:47:35 <orion> Correct.
07:47:47 <tdammers> conceptually, Application ~== Request -> Response
07:48:04 <tdammers> (it's a bit more complex because of side effects and efficiency concerns, but that's the gist)
07:48:07 <orion> Right, but with CPS
07:48:11 <orion> (sendResponse)
07:48:15 <tdammers> yes
07:48:27 <tdammers> but for the purpose of this discussion, Request -> Response is good enough
07:48:31 <orion> Indeed.
07:48:44 <tdammers> so Middleware == (Request -> Response) -> Request -> Response -- right?
07:48:57 <orion> I think it just clicked in my head.
07:49:28 <tdammers> which means our middleware can inspect the incoming request, then either generate a response from scratch, or call into the original application, and then modify the response from that
07:50:04 <tdammers> it also means that middlewares stack in a "wrapping" manner: first middleware in the stack gets first dibs on the request, and gets to process the response last
07:50:09 <orion> The Middleware *must* call the Application that has been provided as a parameter, but the location at which that call takes place makes all the difference.
07:50:19 <tdammers> ah, but no
07:50:23 <tdammers> it can ignore the application
07:50:30 <orion> That's also true I suppose.
07:50:41 <orion> That would short-circuit everything.
07:50:51 <tdammers> it's kind of crucial, because this is how the HttpAuth middleware manages to cut the request short when authentication fails
07:50:57 <orion> Indeed.
07:51:11 <mauke> could you do 'randomlySwitchBetween app1 app2'?
07:51:22 <orion> I think it makes sense to me now: The Middleware isn't a chain, it's an onion.
07:51:27 <tdammers> yeah
07:51:37 <orion> Awesome, thank you for your help. :)
07:51:48 <tdammers> mauke: kind of, yes
07:52:12 <tdammers> mauke: except that one of them would be the "wrapped" app, and the other one would be passed in when creating the middleware
07:53:03 <tdammers> randomlySwitchBetween :: Application -> Middleware -- or something like that
07:54:11 * hackagebot serial 0.2.7 - POSIX serial port wrapper  http://hackage.haskell.org/package/serial-0.2.7 (jmct)
08:14:12 * hackagebot b9 0.5.4 - A tool and library for building virtual machine images.  http://hackage.haskell.org/package/b9-0.5.4 (SvenHeyll)
08:23:56 <emre`> Hello #haskell, what exactly are the differences between installing the Haskell Platform vs plain GHC?
08:24:57 <c_wraith> Haskell platform comes with a bunch of libraries and a couple more binaries...  And it does a global install of everything, which I rather dislike.
08:25:30 <emre`> Global as opposed to what?
08:25:33 <tdammers> haskell platform is ghc plus cabal plus some useful tools plus a truckload of libraries
08:26:09 <merijn> emre`: As opposed to user local
08:26:25 <emre`> Doesn't that require you to compile from source and do a manual install?
08:26:25 <c_wraith> Global as in it throws everything it installs into the global package database, which has a lot of negative interactions with cabal.
08:26:46 <emre`> I installed Racket in ~/Local/racket for example
08:26:58 <emre`> How would I go about installing GHC and Cabal like that?
08:27:05 <c_wraith> you can install ghc locally, but it will still have a global package database if you do
08:27:13 <merijn> emre`: Download GHC binaries, and then either download cabal binaries or build cabal from source
08:27:34 <c_wraith> The important thing is minimizing the global package database, which is what the platform does not do
08:27:35 <dcoutts> we should really make cabal sandbox init start from a small core set, not the full global set
08:27:49 <merijn> emre`: The GHC binaries are just a matter of "./configure --prefix=$HOME/Local/ghc && make install"
08:27:49 <c_wraith> dcoutts: that would be a good step
08:28:24 <merijn> emre`: And cabal will be installed user local anyway when build from source
08:28:50 <c_wraith> emre`: ~/Local implies OS X, usually..  Are you on OS X?
08:29:16 <emre`> Yeah but I do not do any development on it
08:29:24 <emre`> I was just re-setting up my carry-around VM
08:29:31 <emre`> Wanted to make it as clean as possible this time
08:29:50 <emre`> Why would that imply OS X? Because of the capital L?
08:30:04 <merijn> c_wraith: How does that imply OSX?
08:30:14 <c_wraith> OS X makes heavy use of ~/Local.  But ~/Local is rarely used on linux, in my experience
08:30:17 <aloiscochard> emre`: I highly recommend halcyon I started using recently and it make installing/using haskell a breeze
08:30:19 <merijn> c_wraith: No it doesn't
08:30:26 <aloiscochard> emre`: halcyon.sh
08:30:27 <merijn> c_wraith: ~/Local doesn't exist at all
08:30:38 <merijn> c_wraith: Are you confused with ~/Library ?
08:30:42 <emre`> You create Local manually
08:30:53 <emre`> Most people I know don't use it, though.
08:31:05 <c_wraith> Apparently I am confused with Library, and just got incredibly lucky with a confused guess. :)
08:31:07 <merijn> I always create ~/opt for that
08:31:30 <emre`> /usr/local is actually the proper place I guess?
08:31:42 <c_wraith> Nah, /usr/local is something else
08:32:03 <c_wraith> despite the /usr prefix, it's for global installs :)
08:32:26 <emre`> aloiscochard: I'm checking it out
08:32:29 <mietek> emre`: if you are just starting out, https://ghcformacosx.github.io
08:32:39 <pmade> emre`: What about building a NixOS VM?  Haskell development on NixOS is a dream come true.
08:33:10 <pmade> Or, using Nixpkgs on Mac OS X.
08:33:10 <emre`> pmade: I've got used to Debian
08:33:33 <mietek> emre`: I’m the author of Halcyon; if you’d like to chat about it, I recommend #haskell-deployment. 
08:33:51 <pmade> emre`: Totally understand.  Just switched away from Debian to NixOS last year.  I'm glad I did.
08:34:13 * hackagebot STL 0.3.0.2 - STL 3D geometry format parsing and pretty-printing  http://hackage.haskell.org/package/STL-0.3.0.2 (bergey)
08:44:14 * hackagebot hoogle 4.2.41 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.41 (NeilMitchell)
08:45:52 <teurastaja> when must i use runST while using STRefs?
08:47:06 <teurastaja> all examples ive seen so far are using features i havent been using yet so i just dont understand
08:49:11 <merijn> teurastaja: You build one large ST computation and then yo use runST when you want the result
08:49:14 <merijn> :t runST
08:49:15 <lambdabot> (forall s. ST s a) -> a
08:49:58 <teurastaja> i havent seen existential quantification yet
08:50:09 <merijn> teurastaja: Note that the use of STRefs is restricted to a single ST block/computation
08:50:19 <merijn> teurastaja: That's not existential quantification
08:50:27 <merijn> teurastaja: That's a Rank2Type
08:50:27 <teurastaja> forall?
08:51:04 * ibid does a double take on teurastaja's nick :)
08:51:23 <merijn> teurastaja: The simplest explanation of that type is: The caller of runST gets to decide the type of 'a' (indirectly, by what you give runST as input), right?
08:52:22 <teurastaja> so lets say i have a datatype that refers to itself. how would i do that for example?
08:52:28 <merijn> teurastaja: The "forall s" bit is basically saying "you must give me a value that'll work for ALL possible values of 's'" i.e. "I plan to use SOME 's', but I'm not going to tell you which"
08:52:56 <merijn> The simplest example I can come up with for Rank2Types is: https://gist.github.com/merijn/77e3fa9757658e59b01d
08:53:14 <merijn> teurastaja: You mean a datatype that has STRef's that refer to themselves?
08:53:14 <teurastaja> but what is a Rank2Type?
08:53:19 <teurastaja> yes
08:53:28 <gfixler> /quit/quit
08:53:43 <merijn> teurastaja: Then you can't return that datatype out of the ST computation
08:53:53 <merijn> Or rather...you can, but you wouldn't be able to do anything with it
08:54:44 <merijn> teurastaja: If you want you can think of the "forall s" bit of runST as "magic pixie dust that prevents effects from leaking out the computation"
08:55:12 <merijn> Which is about as accurate an explanation of it as I can give given the fact that I have to leave now :)
08:55:45 <teurastaja> how do i mess with it later on? where does the runST go?
08:56:55 <ion> teurastaja: An example of a rank-1 type: forall a. a -> b. An example of a rank-2 type: (forall a. a -> b) -> b. Rank-3: ((forall a. a -> b) -> b) -> b
08:57:44 <teurastaja> this however does not tell me where i should runST
08:58:03 <c_wraith> You should runST when you're done using mutable state.
08:58:32 <c_wraith> because it creates a hard barrier between the mutable references it gives you and the pure exterior world.
08:59:52 <teurastaja> you mean after i used all the newSTRef, modifySTRef and readSTRef?
09:00:23 <teurastaja> when my structure is "built"?
09:01:19 <teurastaja> what is the difference between modifySTRef and writeSTRef?
09:02:09 <nshepperd> teurastaja: yes, you use runST at the "end"
09:02:19 <c_wraith> teurastaja: you use ST to describe a computation that involves mutable state.  you runST the entire computation.
09:02:33 <teurastaja> understood
09:02:46 <nshepperd> finalResult = runST (_massive_stateful_computation)
09:03:07 <teurastaja> now the difference between modifySTRef and writeSTRef?
09:03:19 <c_wraith> teurastaja: and the difference between modifySTRef and writeSTRef is that the former applies a function to the value in an STRef, and updates the Ref with the results of the computation.  The latter is just a write.
09:03:32 <c_wraith> teurastaja: that difference is actually pretty clear in their types
09:04:09 <c_wraith> teurastaja: writeSTRef takes a ref and a value of the type the ref holds.  modifySTRef takes a ref and a function from the type the ref holds to the type the ref holds
09:04:54 <nshepperd> :t modifySTRef
09:04:55 <lambdabot> STRef s a -> (a -> a) -> ST s ()
09:04:58 <nshepperd> :t writeSTRef
09:04:59 <lambdabot> STRef s a -> a -> ST s ()
09:05:36 <teurastaja> so modifySTRef is for segments?
09:06:21 <c_wraith> segments?
09:06:30 <teurastaja> sections i mean
09:06:38 <c_wraith> Or any other function.
09:06:48 <c_wraith> But yes, something like (+1) is a common function you might pass in.
09:06:58 <teurastaja> cool
09:08:13 <c_wraith> Be somewhat wary of using lots of modifySTRef calls, though.  It can result in huge chains of thunks building up, which uses more memory than necessary and is a huge performance hit when you actually need to use the value.
09:08:58 <teurastaja> but if i use the eager STRefs shouldnt i be ok?
09:09:14 <c_wraith> It's..  more complicated than that.
09:09:28 <athan> Hi everyone. Could someone console me while my mind gets blown by kan extensions?
09:09:54 * orion hands athan a tissue
09:10:14 <athan> To get things clear - the codensity (free?) monad is just a right kan extension where the functors are unified, correct?
09:10:21 <athan> thanks orion :')
09:10:48 <c_wraith> teurastaja: in particular, lazy/strict STRefs are about what version of ST they work with, not how they keep their contents.
09:11:01 <c_wraith> :t modifySTRef'
09:11:02 <athan> Also, left and right kan extensions of the composition of two functors ~ a natural transformation?
09:11:02 <lambdabot> STRef s a -> (a -> a) -> ST s ()
09:11:29 <c_wraith> teurastaja: on the other hand, modifySTRef' will force the contents of the STRef to WHNF before returning.
09:11:40 <teurastaja> WHNF?
09:11:46 <c_wraith> teurastaja: but even that isn't necessarily enough, depending on all sorts of details.
09:11:51 <c_wraith> weak head-normal form
09:12:04 <c_wraith> It basically means that the top-level constructor of the data type has been evaluated.
09:12:16 <teurastaja> so which of the strict and lazy should i use? :/
09:12:44 <c_wraith> teurastaja: That depends on so many factors.  It's kind of an art, to figure out how to choose which one you need.
09:12:54 <pmade> teurastaja: Start with lazy then profile your code.
09:13:33 <bitemyapp> teurastaja: Just leave your code alone until you have a problem. Lazy in the spine, strict in the leaves is a good heuristic but it often doesn't matter for a lot of programs.
09:13:37 <farnoy> Hi, is there a way to identify what type of Exception I'm getting? Tried typeable, but it returns the type *after* the cast
09:14:30 <athan> Also, is the reader adjunction ~ curry / uncurry?
09:15:18 <teurastaja> thanks
09:15:19 <glguy> farnoy: handle (\(SomeException e) -> print (typeOf e)) (fail "whoops")
09:16:25 <teurastaja> now what is an adjunction? i dont know what the left of the forgetful functor means so simple please ;)
09:16:49 <teurastaja> i mean what is an adjoint functor
09:17:48 <athan> :|
09:18:01 * athan 's brain needs to get checked
09:18:15 <farnoy> glguy: thank you! I was doing `try` with an explicit `:: Either SomeException ...` so that's probably why it didn't work
09:18:34 <glguy> farnoy: You can do it with try as well
09:19:31 <glguy> try (fail "whoops") >>= \r -> case r of Left (SomeException e) -> print (typeOf e); Right x -> return ()
09:20:39 <farnoy> can I link a gist in here?
09:21:38 <lpaste> farnoy pasted “No title” at http://lpaste.net/133003
09:22:05 <farnoy> I was doing exactly that, hmm
09:24:15 * hackagebot coinbase-exchange 0.1.0.0 - Connector library for the coinbase exchange.  http://hackage.haskell.org/package/coinbase-exchange-0.1.0.0 (andrewrademacher)
09:32:01 <athan> Is the -XDeriveAnyClass advised? :|
09:34:50 <nshepperd> judging by ghc docs, it seems to be safe
09:36:31 <nshepperd> https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/deriving.html
09:36:50 <Cale> athan: All it does is give you an empty instance.
09:37:01 <athan> Cale: Ahh okay
09:37:02 <nshepperd> except that it overrides GND
09:37:09 <athan> thanks nshepperd
09:38:24 <tmillc> hi, I am just now looking at types and I don't quite get what "=>" means in this context. Could someone help me, maybe using (<) as an example or sometihng?
09:39:11 <Cale> tmillc: => is just a piece of punctuation which is used to separate the constraints on type variables from the rest of the type
09:39:12 <tmillc> I *think* it's like, describing the a. I mean I would kind of read that like "it takes two a's and gives a bool, and also the a's are of type Ord"
09:39:21 <Cale> :t (<)
09:39:24 <lambdabot> Ord a => a -> a -> Bool
09:39:32 <osa1> I can't build my packages with profiling because profiling version of integer-gmp(and maybe of some other packages coming with GHC distribution) is missing. any ideas where can I find those without recompiling GHC?
09:39:43 <tmillc> Cale: I see, but what if you had multiple constraints what would that look like?
09:39:59 <Cale> It means "for any type a for which there is an instance Ord a, this is a function which accepts two values of type a, and produces a Bool"
09:40:05 <zipper> What's the best way to check whether a string has one word?
09:40:11 <Cale> (Ord a, Num a) => ...
09:40:20 <tmillc> Cale: I see, thank you
09:41:24 <tmillc> I found the a->a->...->Bool type description to be a little weird, but if there is a string of inputs, I know there will always be only one output so I know everything else must be inputs
09:41:32 <Cale> zipper: Perhaps matching on the result of words xs?
09:41:46 <Cale> case words xs of [w] -> ...; _ -> ...
09:42:08 <zipper> hmmm interesting
09:42:18 <zipper> Cale: Thanks man/woman
09:42:40 <zipper> Cale: What do you prefer I call you btw?
09:42:54 <zipper> Cale: You can ignore that.
09:43:05 <zipper> If you want. Okay I'm saying too much.
09:43:30 <Cale> I'm male, but it hasn't actually mattered since the 1960's when referring to someone as "man". :D
09:44:21 <zipper> Cale: Yeah I know. I did that in some channel and someone made me apologize for it. So I guess one can't just casually use the word man to mean friend or something.
09:44:23 <SrPx> Is there a typeclass for anything that can be rounded to an int (including ints themselves?)
09:44:45 <barrucadu> SrPx: Enum?
09:44:48 <Cale> :t round
09:44:49 <lambdabot> (Integral b, RealFrac a) => a -> b
09:44:52 <Cale> RealFrac
09:44:56 <barrucadu> Oh, rounding, sorry
09:44:59 <SrPx> Ints aren't realfrac :(
09:45:00 <Cale> oh, *including* Int
09:45:16 <Cale> Then no, not really.
09:46:01 <Cale> I would just accept an Integer argument and let people round things themselves.
09:46:11 <SrPx> UHmm okay
09:46:51 <Cale> (Unless that interferes with what it is that you're trying to accomplish)
09:47:38 <rui4> What's a simple way to check if ghc-mod is working properly? I've made a tiny mess installing it, and I don't know what it is for. I just want Atom's ide-haskell extension to work properly and it doesn't
09:47:45 <SrPx> Cale: not sure, I have things like "box_fill_color :: Int -> V3 Int -> V3 Int -> [(V3 Int, Int)]" - takes a color, a fromPos, a toPos, and returns the positions I need to set on a voxel grid to fill the space contained by that box
09:48:29 <SrPx> but my actual positions are almost always floats so I have to use "floor" all the time... just thought I could just have floor inside box_fill_color, but now that excludes ints
09:48:31 * SrPx shrugs
09:48:53 <Cale> Of course, you can just have a separate function then
09:49:13 <tmillc> :t Enum
09:49:15 <lambdabot>     Not in scope: data constructor ‘Enum’
09:49:15 <lambdabot>     Perhaps you meant variable ‘enum’ (imported from Control.Lens)
09:49:17 * hackagebot file-collection 0.1.1.0 - Provide a uniform interface over file archives and directories  http://hackage.haskell.org/package/file-collection-0.1.1.0 (joel_williamson)
09:49:19 * hackagebot file-collection 0.1.1.1 - Provide a uniform interface over file archives and directories  http://hackage.haskell.org/package/file-collection-0.1.1.1 (joel_williamson)
09:49:19 <tmillc> that fails,but what amIlooking for?
09:49:34 <tmillc> my spacebar is broken also :/
09:49:36 <Cale> Enum is a type class
09:49:51 <tmillc> Cale: is there something in ghci that can give me the scoop on it?
09:49:58 <SrPx> fromEnum looks like it does it, is there any problem in using it?
09:49:58 <Cale> :i Enum
09:50:07 <tmillc> ok thanks
09:50:37 <SrPx> box_fill_color :: (Enum a) => Color → V3 a → V3 a → [(V3 a, Color)] -- is that ugly?
09:50:52 <SrPx> (V3 Int, Color)*
09:50:55 <Cale> tmillc: Enum itself is a bit of a mess. Personally, I think it just only have enumFrom, enumFromThen, enumFromTo, and enumFromThenTo defined in it.
09:51:30 <Cale> tmillc: i.e. the definitions used to provide the list enumeration syntaxes [a..], [a,b..], [a..b], and [a,b..c]
09:51:47 <SrPx> :t fromEnum
09:51:48 <lambdabot> Enum a => a -> Int
09:51:49 <Cale> The other stuff is rarely used, and often slightly broken.
09:52:00 <SrPx> So I shouldn't use it, okay
09:52:12 <Cale> Well, fromEnum and toEnum kind of get used a bit sometimes, for smallish types.
09:52:16 <hodapp> Add code into the top part of a Haskell file... completely unrelated code start breaking with issues related to the wrong types being inferred.
09:52:18 <hodapp> I am confuzzled.
09:52:27 <Cale> But they don't really belong with the other stuff
09:52:49 <SrPx> two functions then, box_fill_color :: Color → V3 Int → V3 Int → [(V3 Int, Color)] ... and box_fill_color_f :: (RealFrac a) :: Color → V3 a → V3 a → [(V3 Int, Color)] ?
09:52:51 <Cale> fromEnum and toEnum are useful with Bool once in a blue moon, or with Char
09:53:06 <Cale> SrPx: Something like that
09:53:12 <SrPx> okay
09:53:16 <Cale> SrPx: I hate your underscores, just so you know ;)
09:53:22 <SrPx> everyone does
09:54:06 <SrPx> I'll_make_a_tool_to_convert_back_and_forth, because I'm sorry IAmNotPsychologicallyAbleToReadThingsLikeThatItIsHorribleAndHurtsMyBrain :(
09:54:17 * hackagebot esqueleto 2.2.3 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-2.2.3 (FelipeLessa)
09:54:18 * hodapp looks at SrPx
09:54:26 <lpaste> farnoy pasted “No title” at http://lpaste.net/133006
09:54:34 <farnoy> Is there a way to handle this more cleanly?
09:54:35 <Cale> Well, if you have to read things like that, then your identifier names are too long already
09:54:50 <Cale> and you should just choose something shorter
09:55:27 <tmillc> Cale: ahh, well Enum was an example, just good to know how to find out about a typeclass
09:55:47 <Cale> tmillc: Yeah, I just thought I'd mention it.
09:56:17 <SrPx> most of my variables consist of 2~3 words and I already feel a relief reading underscores... if I ever publish something from that I'll make an extractor/converter, no worries
10:02:17 <SrPx> also, 
10:02:33 <SrPx> > (floor (-5.2), fromEnum (-5.2))
10:02:36 <lambdabot>  (-6,-5)
10:04:17 * hackagebot file-collection 0.1.1.2 - Provide a uniform interface over file archives and directories  http://hackage.haskell.org/package/file-collection-0.1.1.2 (joel_williamson)
10:06:21 <tmillc> how would I go about getting a list of all typeclasses currently available to me?
10:10:05 <SrPx> something is really weird with Enum. It says the minimal complete definition is fromEnum and toEnum. But (enumFromToBy 0 0.1 1) couldn't work with only fromEnum and toEnum defined for floats
10:10:14 <Cale> tmillc: Uh, I don't think there's a command which lets you do that, which is kind of interesting.
10:10:15 <SrPx> > enumFromThenTo 0 0.1 1
10:10:17 <lambdabot>  [0.0,0.1,0.2,0.30000000000000004,0.4000000000000001,0.5000000000000001,0.600...
10:10:21 <S11001001> tmillc: :browse *ModName, where ModName is the module whose available terms you want to see.
10:10:32 <S11001001> s/terms/names/
10:10:51 <Cale> Yeah, I guess :browse will let you see them among other things
10:10:51 <S11001001> tmillc: the * is important
10:11:18 <Cale> Hm?
10:12:04 <Cale> In many cases the * won't work, because you'll be asking about a module which isn't in interpreted mode.
10:12:04 <S11001001> Cale: without the *, I only see names defined by ModName; with the *, I see all names that may be referenced from within ModName's body
10:12:34 <Cale> Like, if you wanted to know about the Prelude type classes, then :browse *Prelude will just get you a complaint
10:12:40 <S11001001> tmillc: so this is limited to modules you are loading into ghci.
10:12:53 <c_wraith> SrPx: "minimal complete" doesn't mean it's enough to get exactly the behavior you might always want, just that it's enough to always get *some* behavior.
10:12:54 <Cale> :browse Prelude will work
10:13:18 <SrPx> weird, I assumed that was the case, and additional implementations would be for performance
10:13:36 <c_wraith> honestly, Enum is kind of a bad class.  and the Float and Double instances are especially bad.
10:13:38 <S11001001> tmillc: these are kind of opposed questions.  If you want to know the names *exported* by a module, leave off the *.  If you want to know the names *imported into* (and defined by) a module you're developing, use the *.
10:14:14 <Cale> Yeah, I consider the specification of the Float and Double instances to be a bit buggy
10:14:41 <Cale> I can sort of understand why you might want that behaviour in some cases though
10:15:10 <Cale> But I sort of think that [a,b..c] should never contain elements larger than c
10:15:57 <c_wraith> I'd be happiest if the Enum instance for Float and Double actually enumerated the possible values.
10:16:08 <Cale> Nah, that's minimally useful
10:16:34 <c_wraith> But it's sufficient to make people go "maybe I shouldn't use this" when they think they want to but don't actually.
10:17:37 <Cale> There are a lot of circumstances where you want to pick a bunch of floating point values in a range, say while testing a function or doing simple graphics.
10:18:10 <Cale> Being able to write  map f [1..10] at floating point type to test your function on the values 1 through 10 is convenient
10:19:24 <osa1> does anyone know about this problem with building profiling versions: http://lpaste.net/133008 ?
10:20:08 <tromp> @src enumFromThenTo::Double->Double->Double->[Double]
10:20:08 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
10:20:34 <Cale> The @src command doesn't parse types
10:20:51 <tromp> how to get instrance definitions then?
10:20:56 <Cale> It looks up the string you give it and gives you the following section of a text file
10:24:42 <tmillc> S11001001: I see, so it shows me typeclasses (prefixed by class), types, datas and functions loaded, and :browse by itself shows such info for all modules loaded, and if none are loaded then it shows such for the "standard library" (or what's it called)
10:25:04 <Cale> yeah, the Prelude
10:25:07 <SrPx> Okay, if Enum is a bad class, then I guess it is a bad idea to define an enum from V3 which does linear interpolation...
10:25:41 <Cale> tromp: You can find the instance here: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base/src/GHC-Float.html
10:25:46 <tmillc> Prelude is a nice word
10:28:39 <Cale> tromp: Oh, and the real implementation is here: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base/src/GHC-Real.html
10:28:52 <Cale> (see numericEnumFrom, etc.)
10:30:38 <Cale> > [1,5..11]
10:30:42 <lambdabot>  [1,5,9]
10:30:45 <Cale> > [1,5..11] :: [Double]
10:30:47 <lambdabot>  [1.0,5.0,9.0,13.0]
10:31:03 <Cale> ^^ somewhat counterintuitive
10:31:34 <tmillc> whoa
10:32:02 <Cale> The reason is that it treats half the distance between the given initial and second elements as the "precision" when determining where to stop
10:32:09 <Cale> Which makes sense in some applications and not in others.
10:33:35 <ion> A nice, newbie-friendly article about HoTT and UniMath (despite the click bait title). https://www.quantamagazine.org/20150519-will-computers-redefine-the-roots-of-math/
10:33:35 <joneshf-laptop> what are some plotting options?
10:33:42 <tmillc> in some tutorial I was looking at the other day they said they would come back to a better way of constructing such sequences but I don't remember where I saw it
10:34:19 * hackagebot mwc-random-monad 0.7.3.1 - Monadic interface for mwc-random  http://hackage.haskell.org/package/mwc-random-monad-0.7.3.1 (AlexeyKhudyakov)
10:35:34 <tmillc> oh well I'll get to it someday. Also HoTT is on my "to learn about" list, thanks for the link!
10:35:49 <Cale> joneshf-laptop: As in for making charts and graphs?
10:36:24 <Cale> joneshf-laptop: There's a lovely Chart library https://github.com/timbod7/haskell-chart/wiki
10:36:31 <Cale> http://hackage.haskell.org/package/Chart
10:37:28 <small-wolf> Where's the HoTT link? I was at a talk on it on Monday and very confused
10:37:29 <joneshf-laptop> thanks
10:37:58 <Cale> small-wolf: ion posted the link, you don't see it?
10:38:19 <Cale> small-wolf: Or did you want a link to the book? http://homotopytypetheory.org/book/
10:38:35 <small-wolf>  Cale: I joined the channel after he posted it
10:38:43 <tmillc> small-wolf: https://www.quantamagazine.org/20150519-will-computers-redefine-the-roots-of-math/
10:38:58 <Cale> oh
10:39:01 <Cale> <ion> A nice, newbie-friendly article about HoTT and UniMath (despite the click bait title). https://www.quantamagazine.org/20150519-will-computers-redefine-the-roots-of-math/
10:39:10 <small-wolf> some introduction/motivation for hott would really benefit me
10:39:19 * hackagebot pandoc-citeproc 0.7.1.1 - Supports using pandoc with citeproc  http://hackage.haskell.org/package/pandoc-citeproc-0.7.1.1 (JohnMacFarlane)
10:39:36 <Haskellfant> small-wolf: I saw a youtube video for a high level introduction yesterday, let me get the link
10:39:44 <Haskellfant> small-wolf: https://www.youtube.com/watch?v=OupcXmLER7I&feature=youtu.be
10:39:50 <small-wolf> also if anyone knows a good topology resource (or what the heck an open set is in hott)
10:40:02 <Cale> I'm always surprised at just how many people have heard about HoTT at all... I suppose I probably shouldn't be surprised in #haskell though.
10:40:14 <ion> Haskellfant: Cool, thanks for the link
10:40:23 <small-wolf> Haskellfant: thank you
10:40:28 <Cale> But it seems like it's on a lot of people's reading lists, when one might expect that it's sort of a fringe thing.
10:40:46 <Haskellfant> I still need to actually start learning it :) I'm still busy with software foundations
10:41:16 <small-wolf> I am not surprised. It's a major turf grab for type enthusiasts if it pans out
10:42:12 <small-wolf> there's a reading group here in sf for software foundations
10:43:18 <hodapp> I wonder if it's considered horrible abuse of the type system that I'm using type-level symbols to associate a description string of a field to a type itself.
10:43:36 <Cale> hodapp: heh
10:43:48 <hodapp> Cale: I'm gonna handle that like a 'yes'.
10:48:59 <teurastaja> id is the identity to what monoid?
10:49:21 <Cale> Composition of functions from a type to itself.
10:49:24 <oconnore> is Data.Text.IO a reasonable way to write data? I'm alloc'ing over 11GB of data while writing out some log messages
10:49:36 <oconnore> 65% of runtime is GC
10:49:56 <teurastaja> so mappend for that would be what?
10:50:06 <Cale> composition
10:50:09 <Cale> (.)
10:50:17 <teurastaja> oh
10:50:42 <teurastaja> and what name does this monoid have?
10:51:02 <Cale> If you want a fancy term, it's the endomorphism monoid on a type
10:51:07 <arkeet> that's the monoid of endomorphisms of a type.
10:51:20 <arkeet> yeah.
10:51:35 <Cale> There's a newtype wrapper called Endo in Data.Monoid
10:51:40 <arkeet> :t Endo
10:51:42 <lambdabot> (a -> a) -> Endo a
10:51:51 <arkeet> :t appEndo
10:51:52 <lambdabot> Endo a -> a -> a
10:51:59 <arkeet> > appEndo (Endo (+1) <> Endo (+2)) 0
10:52:01 <lambdabot>  3
10:52:16 <teurastaja> is const the identity to a monoid?
10:52:57 <Javran> https://wiki.haskell.org/Constant_applicative_form accodring to this, "\x -> (+) 4 x" is not a CAF but is it a super combinator?
10:53:28 <tromp> thx, Cale. the question is, which is the bigger "evil":  last[0,0.2..0.3]==0.2 or (last[0,2..3]::Double)==4
10:53:32 <lpaste> oconnore pasted “No title” at http://lpaste.net/133011
10:53:45 <Javran> and in super combinator "\x y -> x + y", why don't we consider "+" to be a free variable?
10:54:18 <arkeet> "Whether a variable is free or not depends largely on context."
10:54:45 <teurastaja> i heard cycle was the identity for circular lists. that should also be a monoid right?
10:55:04 <ChristianS> Javran: because "+" is not a variable?
10:55:17 <arkeet> with what operation?
10:55:28 <Javran> > let (+) = (*) in 10 + 10
10:55:30 <lambdabot>  100
10:55:35 <Javran> but you can do this
10:55:57 <tromp> uhm, i meant last[0,0.1..0.3]==0.2 as the first "evil"
10:56:34 <Cale> tromp: right.
10:56:36 <arkeet> > [0, 0.2 .. 0.3]
10:56:38 <lambdabot>  [0.0,0.2,0.4]
10:56:40 <arkeet> > [0, 2 .. 3] :: [Double]
10:56:42 <lambdabot>  [0.0,2.0,4.0]
10:57:04 <arkeet> > [0, 2 .. 3] 
10:57:05 <lambdabot>  [0,2]
10:57:06 <arkeet> heh.
10:57:30 <Javran> :t EnumFromThenTo
10:57:32 <lambdabot>     Not in scope: data constructor ‘EnumFromThenTo’
10:57:32 <lambdabot>     Perhaps you meant one of these:
10:57:32 <lambdabot>       variable ‘enumFromThenTo’ (imported from Prelude),
10:57:40 <Javran> :t enumFromThenTo
10:57:42 <lambdabot> Enum a => a -> a -> a -> [a]
10:57:52 <Javran> @src enumFromThenTo
10:57:52 <lambdabot> Source not found. :(
10:57:56 <tromp> i think the 2nd evil is greater, as you expect Doubles to be able to substitute for Ints up to 52 bits
10:58:22 <arkeet> > takeWhile (<= 0.3) [0,0.2..]
10:58:24 <lambdabot>  [0.0,0.2]
10:58:40 <Javran> O_O how come
10:58:54 <Luke> c_wraith: you around?
10:59:11 <c_wraith> yep
10:59:34 <hodapp> Does one require ScopedTypeVariables for functions that are instances of a typeclass?
10:59:48 <hodapp> or is that only for functions that have the explicit 'forall'
11:00:14 <tmillc> small-wolf: for topology, well I went through some of Munkres in a course setting and found it very good, but it was nice to have the direction of like "for our purposes, we will be skipping this and this chapters" but Munkres is very popular and there is bound to be a lot of info online to help go through it
11:00:14 <hodapp> or, rather, the functions aren't the instances of a typeclass, but they're required for it
11:00:21 <arkeet> hodapp: ??
11:00:23 <Cale> hodapp: I'm not sure what you mean
11:00:38 <Javran> i didn't get it either :(
11:01:41 <hodapp> e.g. instance (Foo h, Bar b) => BazClass (A h b) where.... - then can I, in the definitions underneath that, use 'h' and 'b' in the body of the definitions below, without requiring ScopedTypeVariables?
11:01:47 <Cale> hodapp: ScopedTypeVariables lets you refer to type variables which are forall bound in the type signature of a definition from type annotations and type signatures of declarations made using let/where in that definition.
11:02:19 <Cale> You'll need ScopedTypeVariables for that, and you'll also need to explicitly forall the variables in your instance declaration iirc.
11:02:40 <hodapp> Cale: no explicit 'forall' is present currently, and it's working fine.
11:02:46 <Cale> hmm
11:03:02 <hodapp> which confused me a little, because with functions the 'forall' is required to be explicit, I thought
11:03:04 <Cale> Well then, I guess you don't?
11:03:18 <hodapp> let me see if I can throw together an example...
11:03:43 <Cale> ah, you don't, according to the GHC user's guide
11:03:46 <Cale> https://downloads.haskell.org/~ghc/7.8.2/docs/html/users_guide/other-type-extensions.html#scoped-type-variables
11:03:50 <Javran> https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/explicit-forall does this help?
11:03:52 <Cale> 7.13.8.5. Class and instance declarations
11:03:52 <Cale> The type variables in the head of a class or instance declaration scope over the methods defined in the where part.
11:05:06 <SrPx> Of course + is a free variable in "\ x y → x + y"
11:05:08 <SrPx> who said otherwise
11:05:29 <Cale> SrPx: It depends on whether + is just part of the syntax of expressions
11:05:37 <hodapp> Javran: That doesn't say anything about classes, which is the case I'm asking about.
11:05:48 <Cale> It might not be a variable at all
11:05:58 <SrPx> Cale: you mean a shorthand for the definition of +
11:06:00 <Cale> (It is in Haskell of course)
11:06:11 <c_wraith> Luke: what can I help you with?
11:06:14 <hodapp> Cale: ahh, okay.
11:06:30 <Javran> I see
11:06:35 <SrPx> okay
11:06:45 <Cale> SrPx: No, I mean a primitive part of the syntax of expressions in your lambda calculus.
11:07:51 <Luke> c_wraith: you helped me a while back w/ using the "use" lens combinator. Basically I want to run a function before applying the lens to the data structure inside the state monad. do you remember how you told me to do that? http://hackage.haskell.org/package/lens-4.11/docs/Control-Lens-Getter.html#v:use
11:07:56 <SrPx> ah if + is a primitive it can't be a free variable, although primitives don't make sense for me
11:09:21 * hackagebot file-collection 0.1.1.3 - Provide a uniform interface over file archives and directories  http://hackage.haskell.org/package/file-collection-0.1.1.3 (joel_williamson)
11:09:26 <Luke> c_wraith: actually I think I got it with "to f . lens" but I can't see to get "to" to work with my "%=" variant
11:11:04 <c_wraith> Luke: that's because "to" only gives you a Getter, and %= needs a Setter.
11:11:25 <Luke> c_wraith: right but what's the equivalent for the setter?
11:11:33 <Luke> or maybe there isn't one
11:11:52 <c_wraith> Luke: ideally, you'd just use a real lens.
11:12:10 <Luke> hmm that's probably what I should be doing here
11:12:19 <Luke> it's a tuple so there's _1 and _2
11:12:23 <Luke> i dunno what I was thinking
11:12:32 <Luke> c_wraith: thanks again!
11:13:35 <tmillc> words I've come across but haven't gotten to in tutorials: . monad $ filter map
11:14:25 <tmillc> no question, just excited!! :D
11:14:42 <c_wraith> 4 of those are simple functions whose type tells you nearly everything about them.  The fifth is a lot less important to know than the other 4. :)
11:15:04 <tmillc> c_wraith: well that's even more exciting
11:17:14 <orion> What is the definition of "items" here?: "block-buffering should be enabled if possible. The size of the buffer is n items if the argument is Just n and is otherwise implementation-dependent." (From System.IO)
11:19:00 <geekosaur> I think for ghc that is always characters?
11:19:07 <geekosaur> correction, bytes
11:19:22 <geekosaur> since the underlying primitives are byte oriented
11:19:50 <geekosaur> my guess is that the phrasing is because the spec wants to be compatible with systems whose natural I/O unit is not the byte, e.g. VMS
11:20:10 <geekosaur> (not that anyone cares much about VMS any more, but.)
11:20:13 <belgin> Hello! I have a misunderstanding regarding Yampa. Why is it that when I run embed on an SF which is just (constant 1.0), I get [1.0, 1.0]?
11:20:45 <ion> Oh, people don't run GHC on VMS anymore?
11:21:19 <hodapp> "GHC: It's not libjpeg"
11:23:54 <Cale> belgin: How are you applying embed exactly?
11:25:05 <belgin> just a second
11:26:19 <belgin> Cale: embed ((\_ -> constant 1.0) 10.0) ((), [(5.0, Nothing)])
11:26:28 <belgin> It returns [1.0,1.0]
11:26:31 <Cale> right
11:26:35 <Cale> That seems correct to me
11:26:46 <Cale> What result did you expect?
11:27:04 <belgin> Cale, just [1.0]
11:27:20 <Cale> You always get an initial output sample at the start.
11:29:45 <belgin> Cale, sorry, but I still don't understand, why exactly are there two 1.0 in that list?
11:29:56 <Cale> belgin: Try passing in the empty list
11:30:37 <belgin> oh, I see now
11:31:06 <belgin> Thank you very much, Cale
11:31:13 <Cale> No problem :)
11:32:13 <Novice201y> Hi. Someone could explain what happens here: http://paste.hskll.org/get/2531 . I'm new to Haskell and even with trying different values I don't get what's happening in this code.
11:33:23 <mizu_no_oto> Novice201y: What are some values you've tried calling it with, and what were the results?
11:33:57 <frerich> paste.hskll.org is new to me, but looks interesting!
11:34:58 <mizu_no_oto> Novice201y: do you mean that it's not returning what you expect it to return, or that it works but you don't know how/why?
11:35:19 <Novice201y> mizu_no_oto: It works and I don't know why.
11:35:24 <Tuplanolla> Pick one (small) value and try evaluating it by hand, Novice201y.
11:36:01 <Tuplanolla> For example sumtorial 10 matches the second pattern and is therefore equal to 10 + sumtorial (10 - 1).
11:36:16 <mizu_no_oto> Novice201y: Well, lets start somewhere near the beginning.  Do you understand pattern matching?
11:37:04 <mizu_no_oto> And have you coded in other languages before?
11:37:07 <ReinH> Ah, induction, probably the best place to start learning recursion.
11:37:11 <ReinH> Good choice.
11:37:25 <Novice201y> mizu_no_oto: OK, thank You. I'll read about pattern matching from another tutorial, and maybe then return here.
11:39:00 <Tuplanolla> Start here, Novice201y: http://www.vex.net/~trebla/haskell/prerequisite.xhtml
11:41:14 <Phillemann> I have a basic question: ghc-mod somehow depends on happy. However, cabal only tells me this as a compile error, not beforehand. Why is happy not a dependency of ghc-mod?
11:41:52 <dcoutts> Phillemann: cabal doesn't yet automatically track deps on tools (or C libs), only Haskell libs
11:41:58 <dcoutts> one of these days it will
11:42:10 <Phillemann> Ah, I see.
11:42:32 <Phillemann> Thanks
11:53:46 <ozzmotik> how 2 haskel ?
11:54:37 <arkeet> how 2 haskel https://github.com/bitemyapp/learnhaskell
11:55:56 <ozzmotik> arkeet, thx @ u
11:56:00 <Rotaerk> haskel like this
11:56:07 * Rotaerk does an awkward dance
11:56:44 <ozzmotik> I never would have been able to determine that myself
11:56:45 <ozzmotik> thx
12:02:31 <SwashBuckla> is it possible to pattern match againt any type constructor?
12:02:51 <SwashBuckla> e.g. foo x (f y) = f x
12:02:58 <bitemyapp> SwashBuckla: you mean data constructor?
12:03:02 <SwashBuckla> that would match against [], Maybe, ...
12:03:19 <bitemyapp> SwashBuckla: hrm, there's a lot of "no" there.
12:03:29 <bitemyapp> SwashBuckla: 1. Data and type constructors start with capital letters
12:03:42 <bitemyapp> SwashBuckla: 2. you can only match data constructors - those are values. Type constructors are not.
12:04:04 <bitemyapp> SwashBuckla: 3. You'd need to either leave the data alone or unify the types into a sum type to have a function that addressed []/Maybe/etc.
12:04:20 <bitemyapp> SwashBuckla: you probably should consider following along with a course. Recommendations here: https://github.com/bitemyapp/learnhaskell
12:04:31 <SwashBuckla> o_o
12:04:47 <dcoutts> SwashBuckla: on the other hand you can certainly write functions that are polymorphic in types like [], Maybe  etc
12:05:07 <bitemyapp> dcoutts: that's "leave the data alone"
12:05:10 <dcoutts> right
12:05:19 <SwashBuckla> I want to leave the data alone, yes
12:05:19 <dcoutts> with type classes like Functor, Traversable, Monad etc
12:05:58 <bitemyapp> SwashBuckla: haphazardly trying to understand the language via, "I want to do thing. How do I do thing?" is going to take longer than just doing exercises.
12:06:55 <dmj`> SwashBuckla: id :: a -> a
12:06:56 <SwashBuckla> bitemyapp: I have read all of LYAH, done CIS194, and am now on NICTA
12:07:45 <f|`-`|f> Enjoy NICTA
12:07:59 <Welkin> look, a hiphop pirate
12:08:03 <tmillc> hmm, making a bot that generates exercises could be interesting
12:08:08 <SwashBuckla> bitemyapp: I have just finished List.hs in NICTA, and am moving on to Functor.hs. The particular Functor instance I am implementing is `<$`
12:08:52 <f|`-`|f> do it
12:09:02 <bitemyapp> SwashBuckla: on the one hand, it's more or less expected you'd learn parametricity and how the different kinds of polymorphism work in NICTA, but cis194 does talk about it.
12:09:14 <bitemyapp> SwashBuckla: did you just do the exercises in cis194 or did you read the lecture thingies?
12:09:20 <SwashBuckla> both
12:09:24 * hackagebot envparse 0.2.1 - Parse environment variables  http://hackage.haskell.org/package/envparse-0.2.1 (MatveyAksenov)
12:09:31 <f|`-`|f> That one is interesting is void
12:10:14 <SwashBuckla> my first instinct was to capture the constructor, implementing `<$` like so:  (<$) x (f y) = f x
12:10:27 <SwashBuckla> Parse error in pattern: f
12:10:41 <f|`-`|f> You can't really do that
12:10:45 <bitemyapp> now I understand you were trying to do
12:10:47 <SwashBuckla> I realise that :)
12:10:54 <bitemyapp> this is actually quite interesting
12:11:36 <browndawg> what's NICTA?
12:11:42 <bitemyapp> NICTA course
12:11:48 <bitemyapp> series of exercises for learning Haskell
12:11:52 <Luke> is there a good way to switch on an Int (for parsing)?
12:11:55 <f|`-`|f> Namely the Course Notes
12:12:19 <Luke> bitemyapp: nice work on that hacker news post about sieves on the haskell home page
12:12:23 <browndawg> this? https://github.com/NICTA/course
12:12:32 <f|`-`|f> probably
12:12:43 <browndawg> Imma do this too, then. Finished LYAH recently.
12:12:53 <f|`-`|f> ok, it is
12:12:55 <bitemyapp> Luke: thanks :)
12:12:55 <browndawg> lurking on IRC isn't useless after all
12:12:59 <browndawg> :)
12:13:12 <Luke> bitemyapp: that was my parent comment you tore that guy apart on =)
12:13:17 <Welkin> cracker news
12:13:21 <f|`-`|f> Also, don't forget that List.hs has problems, you can do them before Functor.hs, browndawg 
12:13:39 <f|`-`|f> The recommended guide is on the scroll down
12:13:51 <browndawg> mmkay
12:13:58 <bitemyapp> browndawg: https://github.com/bitemyapp/learnhaskell
12:14:02 <bitemyapp> browndawg: ^^ guide
12:14:18 <f|`-`|f> ( bitemyapp considers LYAH a reference )
12:14:19 <bitemyapp> Luke: I'm glad dang edited it.
12:14:23 <Luke> me too
12:14:24 <bitemyapp> f|`-`|f: no.
12:14:30 <f|`-`|f> oh
12:14:33 <bitemyapp> f|`-`|f: I removed it from the guide because people kept doing LYAH.
12:14:36 <cfoch> byorgey: hi
12:14:41 <f|`-`|f> lel
12:14:50 <f|`-`|f> Too "simple"?
12:14:53 <bitemyapp> I replaced the rec with Thompson so people wouldn't keep avoiding exercises.
12:14:55 <browndawg> bitemyapp: this is awesome man. thanks. :)
12:14:59 <f|`-`|f> hah
12:15:00 <bitemyapp> f|`-`|f: I've explained the problems with LYAH in detail
12:15:03 <bitemyapp> f|`-`|f: you've seen the post.
12:15:09 <bitemyapp> http://bitemyapp.com/posts/2014-12-31-functional-education.html
12:15:12 <browndawg> I'd love a couple of bite sized open source projects to look at, though.
12:15:17 <narfinger> i am haskell newbie and i am trying to use happstack. i have a list of integers which my happstack gives me a nice webpage but now i want to call another url that changes the urls, how can i do that?
12:15:18 <f|`-`|f> I remember at least one of the points
12:15:54 <narfinger> i didn't find anything in the tutorials
12:16:15 <bitemyapp> browndawg: http://bitemyapp.com/posts/2014-08-22-url-shortener-in-haskell.html http://bitemyapp.com/posts/2014-11-22-literate-url-shortener.html https://github.com/bitemyapp/bloodhound https://github.com/bitemyapp/blacktip
12:16:22 <bitemyapp> browndawg: don't expect any of it to make sense until you do a course.
12:16:28 <bitemyapp> browndawg: my book is coming out later today as well.
12:16:36 <f|`-`|f> neat
12:16:45 <f|`-`|f> Also, I've seen those examples
12:16:58 <f|`-`|f> They seem too damn small for what they do
12:17:01 <browndawg> bitemyapp: I've worked through LYAH and Write yourself a scheme.
12:17:11 <browndawg> That's not enough?
12:17:15 <Narvius> Hyello, I have a question on how bad I am breaking things with unsafePerformIO here: http://lpaste.net/6673425394596577280
12:17:21 <Luke> is there a good way to switch on an Int (for parsing)?
12:17:33 <f|`-`|f> switch?
12:17:39 <bitemyapp> browndawg: could go either way mostly because of the latter.
12:17:42 <Luke> dispatch* whatever
12:17:48 <Luke> f|`-`|f: like a switch/case statement
12:17:51 <browndawg> hmmm
12:17:56 <bitemyapp> browndawg: give it a look and decide for yourself.
12:17:59 <browndawg> what's your book on
12:18:45 <bitemyapp> browndawg: Haskell
12:18:51 <bitemyapp> browndawg: haskellbook.com
12:19:06 <browndawg> bitemyapp: as in... anything specific or just haskell for noobs or something
12:19:08 <browndawg> hmm checking it out
12:19:10 <f|`-`|f> Uh, putting your hand in a meat grinder, slowly, so that you get resistant to bigger meat grinders (eg, projects)
12:19:29 <f|`-`|f> Nothing lamarkian about that
12:19:30 <bitemyapp> browndawg: we test it with non-programmers
12:19:34 <Narvius> I've seen unsafePerformIO used to create IORefs on toplevel, but how does it work out in a 'where'?
12:19:39 <bitemyapp> browndawg: goal is to get people from zero to being able to use Haskell productively
12:19:40 <browndawg> bitemyapp: ah, this look nice man
12:19:47 <browndawg> I'll definitely look at it
12:19:51 <bitemyapp> browndawg: caveat: we've mostly got earlier material done
12:20:00 <Welkin> it is tested in the wild on unsuspecting lab rats
12:20:04 <bitemyapp> browndawg: and given you've done WYAS you probably need more intermediate material.
12:20:34 <bitemyapp> Welkin: artisanal test subjects
12:20:34 <browndawg> bitemyapp: so.. NICTA and maybe try to hack around on small hs projects?
12:20:35 <f|`-`|f> I'm a somewhat suspecting lab rat still
12:21:00 <bitemyapp> browndawg: that's what I'd recommend yes
12:21:04 <f|`-`|f> seems like what one should do, browndawg 
12:21:21 <browndawg> that's what I'm going to do then
12:21:36 <bitemyapp> awesome :)
12:21:51 <f|`-`|f> NICTA really drives the notion that the type signatures matter, if it wasn't that obvious enough
12:21:52 <browndawg> it's all fun and games until browndawg decides to ask noob questions in here
12:22:55 <f|`-`|f> -> Haskell is difficult to teach effectively
12:22:59 <f|`-`|f> oh bitemyapp 
12:25:29 <frerich> Luke: Pattern matching would be a good start, e.g. 'f 0 = this; f 1 = that; f n = fallback'
12:25:48 <Luke> frerich: the Int is generated by a function
12:26:04 <Luke> so I would need (f (fn ADT) = this)
12:26:08 <Luke> that's where I'm held up
12:26:21 <Luke> i could pre-generate the function outputs and hardcode it as an int but I want to avoid that
12:26:29 <Tuplanolla> Is there an off-topic channel similar to this, but with various topics?
12:26:30 <johnw> f (fn -> ADT) = this?
12:26:37 <johnw> Tuplanolla: #haskell-blah
12:26:40 <frerich> Luke: Then a 'case' would be an alternative, e.g. 'f = case fn y of 0 -> this; 1 -> that; _ -> fallback'
12:26:46 <Tuplanolla> Thanks, johnw.
12:27:01 <tmillc> must... resist...distractions
12:27:03 <Tuplanolla> That name was unexpected.
12:27:13 <voidzero> f|`-`|f, that quote :)
12:27:17 <Luke> frerich: that still requires me hardcoding the numbers
12:27:22 <f|`-`|f> It's because it sounds like tongues, Tuplanolla 
12:27:38 <f|`-`|f> So you want a case-guards?
12:27:42 <SrPx> Hey... I've been thinking... since newtype can only have 1 constructor... wouldn't it make sense to allow pattern matching without the second one? For example, "newtype Screen = V2; doSomething (Screen w h) = ..." - wouldn't that be unambiguous?
12:27:47 <johnw> i would have rather had it named #haskell-cafe or whatnot, but -blah it is
12:28:04 <srhb> johnw: The name overload with cafe would be annoying.
12:28:08 <f|`-`|f> Too much devil speak for an unassuming cafe, johnw 
12:28:09 <mizu_no_oto> Luke: sounds like you want a pattern guard 
12:28:21 <Luke> mizu_no_oto: I do but you can't have a function in the clause of the guard
12:28:31 * tmillc tries to think of a pun relating haskell and cafes
12:28:37 <johnw> SrPx: so you want a ... constructor alias?
12:28:46 <SrPx> yes, are there constructor aliases!?
12:28:47 <johnw> SrPx: you can do that with pattern synonyms if you want
12:28:53 <voidzero> from my perspective, haskell is less difficult to learn if i suspend most of my desire to comprehend, so in my case, i just store most info in my brain unfiltered
12:29:07 <n0n3such> lol
12:29:16 <f|`-`|f> more or less do hella problems? voidzero 
12:29:24 <johnw> Haskell is like the Karate Kid of languages.  You just have to let go.
12:29:26 <Luke> I need something like "case x of; x == f Stuff -> Stuff; x == f Blah -> Blah"
12:29:33 <voidzero> johnw, exactly :)
12:29:41 <voidzero> and just wax on wax off
12:29:48 <johnw> pretty much, actually
12:29:52 <f|`-`|f> So, do I have to wax the ghost of Haskell?
12:29:56 <johnw> "How learning Monads is exactly like being the Karate Kid."
12:30:07 <voidzero> the Tao of Haskell
12:30:15 <Tuplanolla> There needs to be a book called Haskell Entirely in Car Analogies.
12:30:19 <johnw> The Book of Five Seminearrings
12:30:31 <f|`-`|f> The Mr Miyagi of Fundamental Epistemics
12:31:02 <SrPx> Tuplanolla: I'd personally buy "Cars entirely in Haskell analogies"
12:31:37 <frerich> Luke: but you don't want to hardcode all the various cases?
12:31:40 <f|`-`|f> I tihnk you'll get too erotic with the DSL's, and sequential monte carlo models
12:32:15 <f|`-`|f> (As a noob, so they want to make new cases on the fly... s-state?)
12:32:38 <dmj`> Haskell: the burrito wrappers guide
12:32:55 <f|`-`|f> I think you'll give someone a bad case of indigeestion with that
12:33:10 <johnw> Tuplanolla: we're now quite effectively simulating #haskell-blah btw
12:33:27 <johnw> since this channel is really for actual Haskell questions, but sometimes it's hard to resist
12:33:48 <SrPx> johnw: just tested it... it still doesn't show "Screen" when I print it, but for coding purposes I guess that is better than having to match (Screen (V2 x y)) soo...
12:33:50 <SrPx> thanks
12:34:02 <johnw> SrPx: change the Show instance
12:34:37 <SrPx> are you sure? I'm almost sure it is still the same type
12:34:45 <SrPx> So that'd affect V2 too
12:34:46 <johnw> i'm not sure
12:34:50 <dmj`> johnw: any mentions of burritos in #haskell should automatically be posted to #haskell-blah
12:35:16 <RickP> what's the most convenient way to include test files to be used by the test suite in cabal? data-files?
12:35:20 <Rotaerk> what if you named a package "burrito"
12:35:57 <dmj`> Rotaerk: join #haskell-blah, I have a good answer
12:36:59 <frerich> Luke: You could use a different approach which holds the 'Stuff' and 'Blah' in a list, like 'case filter (\a -> f x == a) [stuff, blah] of Just a -> a; Nothing -> fallback;'
12:38:06 <f|`-`|f> So an Applicative Filter?
12:38:16 <f|`-`|f> with a default?
12:38:21 <ion> fromMaybe fallback
12:38:58 <rui4> Is it a strong convention to use camel case instead of underscores for variable names?
12:39:06 <c_wraith> yes
12:39:42 <ion> rui4: Yes. I can’t say i’m a fan, but that’s what all the libraries you’re going to use do and it would be worse to be inconsistent.
12:40:13 <sagittarian> does anyone know if there's a standard predefined function that works the same as fn n = take n . repeat (or the flipped version of that)?
12:40:14 <f|`-`|f> camel case?
12:40:23 <rui4> Great, thanks ion and cWraith
12:40:24 <Javran> :t replicate
12:40:27 <lambdabot> Int -> a -> [a]
12:40:28 <f|`-`|f> ^
12:40:37 <Javran> > replicate 10 'a'
12:40:39 <lambdabot>  "aaaaaaaaaa"
12:40:42 <sagittarian> that's it, thanks Javran
12:40:48 <ion> Javran: Reminds me of the Uncyclopedia article.
12:40:49 <Javran> no problem :)
12:41:02 <Javran> ion: what's that?
12:41:03 <f|`-`|f> hmmm
12:41:12 <ion> @google aaaaaaaaaa uncyclopedia
12:41:13 <lambdabot> http://uncyclopedia.wikia.com/wiki/AAAAAAAAA!
12:41:13 <lambdabot> Title: AAAAAAAAA! - Uncyclopedia, the content-free encyclopedia
12:41:18 <Javran> lol
12:42:18 <KorriX> Hi! I have a strange question: What is the name of type dual to functor?
12:42:18 <f|`-`|f> It's truly a bad time to live when
12:42:46 <f|`-`|f> my guess is cofunctor
12:43:32 <f|`-`|f> Uncyclopedia, and Encyclopedia Dramatica are more accurate than Wikipedia, and is more newsworthy than even the news
12:44:14 <ion> KorriX: A dual to the covariant functor is a contravariant functor, called Contravariant in Haskell. Or you might be looking for
12:44:17 <ion> @hackage acme-cofunctor
12:44:17 <lambdabot> http://hackage.haskell.org/package/acme-cofunctor
12:44:38 <ion> It has cofmap :: (b -> a) -> f b -> f a
12:44:58 <johnw> hahaha
12:44:59 <f|`-`|f> ...
12:45:13 <f|`-`|f> well damn, ion
12:45:32 <KorriX> why not cofmap :: f b -> f a -> b -> a ?
12:45:57 <johnw> yeah, I'd think that was the "categorical dual"
12:46:01 <johnw> unfmap
12:46:04 <sagittarian> is it possible to declare a fixity in ghci?
12:46:06 <ion> unf
12:46:12 <KorriX> I hought, that duality is about changing direction of arrows
12:46:24 <KorriX> so why contravariant is dual to functor then?
12:46:32 <Tuplanolla> Who wants to go diagram chasing?
12:46:43 <KorriX> where its duality lies?
12:46:58 <ion> > let (^-^) = (/); infixl 9 ^-^ in 2 ^-^ 3 ^-^ 4
12:47:00 <lambdabot>  0.16666666666666666
12:47:46 <ion> KorriX: (a -> b) -> f a -> f b vs. (b -> a) -> f a -> f b
12:48:29 <KorriX> Also, docs of Kmett contravariant package state: Contravariant functors, sometimes referred to colloquially as Cofunctor, even though the dual of a Functor is just a Functor.
12:48:39 <sagittarian> ah so i have to declare it in 1 line?
12:48:40 <KorriX> How Functor is dual to itself?
12:48:47 <johnw> well
12:48:57 <johnw> fmap isn't really (a -> b) -> f a -> f b
12:49:05 <johnw> it's just that way in Haskell because it's always an Endofunctor
12:49:18 <johnw> a real functor is C (a -> b) -> D (a -> b)
12:49:23 <johnw> and if C = D, then it's dual to itself
12:49:37 <johnw> where C a -> C b is just another way of saying C (a -> b)
12:50:02 <KorriX> but still this duality property should hold for our endofunctor
12:50:11 <johnw> C (a -> b) -> C (a -> b)
12:50:12 <johnw> flip it
12:50:15 <johnw> C (a -> b) -> C (a -> b)
12:50:51 <KorriX> johnw: it makes perfect sense in CT, but I don't see it in Haskell 
12:51:00 <ion> Or you could flip the inner arrows and still get the same thing.
12:51:06 <johnw> Hask (a -> b) -> Hask (a -> b)
12:51:20 <johnw> where the second Hask is actually a subcategory of Hask specific to a given data type, like []
12:51:43 <KorriX>  cofmap :: f b -> f a -> b -> a is dual to fmap :: (a -> b) -> f a -> f b
12:52:15 <johnw> you don't flip both "levels" of arrows
12:52:28 <johnw> (a -> b) -> (c -> d) becomes just (c -> d) -> (a -> b)
12:52:38 <johnw> otherwise, you're not just dualizing, you're moving from Hask to Hask^op
12:53:00 <johnw> (you are still going to ^op, actually, just in another category
12:53:09 <KorriX> johnw so cofmap is :: f b -> f a -> (a -> b)
12:53:12 <hasker_> :t Monad
12:53:13 <lambdabot> Not in scope: data constructor ‘Monad’
12:53:20 <f|`-`|f> op?
12:53:20 <hasker_> :t TMonad
12:53:21 <lambdabot> Not in scope: data constructor ‘TMonad’
12:53:22 <johnw> (f a -> f b) -> a -> b
12:53:28 <johnw> ^op is the category whose arrows are flipped
12:53:31 <f|`-`|f> :t Just
12:53:32 <lambdabot> a -> Maybe a
12:53:49 <f|`-`|f> :i Monad
12:54:20 <f|`-`|f> all of them?
12:54:40 <KorriX> johnw - now it makes perfect sense. Thanks. It's sometimes misleading how CT is encoded in haskell :)
12:54:47 <johnw> that is certainly true
12:54:59 <johnw> initially I tried to use Hask to understand CT, but now I try to keep them pretty much separate
12:56:42 <KorriX> johnw: Me too. Also functor is not just an instance. Even hask endofunctor is: fmap (taking morphisms) + value constructor (like list one a -> [a]) taking objects + functor laws (or single law + parametricity)
12:57:30 <KorriX> it was a great discovery to me that haskell Functor is so big shorthand :)
12:57:48 <johnw> right
12:58:04 <johnw> following that sort of shorthand, many people define categories by their morphism structure
12:58:07 <johnw> like Cat (->)
12:58:17 <johnw> because you can usually infer the meaning of the objects involved
12:58:56 <johnw> (and this is just what Haskell's Category typeclass does)
13:04:07 <KorriX> johnw: Thanks for your explanations :)
13:06:31 <hexagoxel> does anyone know Louis Wasserman, the pqueue maintainer?
13:06:46 <f|`-`|f> by their morphism structure?
13:08:07 <hexagoxel> also, the right mailing list for library maintainership stuff is libraries@haskell.org, right?
13:08:39 <johnw> f|`-`|f: by what morphisms in the category look like.  (->) for Hask, Edge for a Graphs, <> for a Monoid category, etc.
13:09:44 <f|`-`|f> So how <> is binary, and associative
13:09:57 <johnw> yeah, that's necessary for anything to be a morphism
13:09:58 <f|`-`|f> I'll have to look into it
13:10:26 <f|`-`|f> well, it's at least a mapping between two things, even if it's an identity
13:10:30 <f|`-`|f> afaik
13:10:44 <johnw> actually, I'm wrong on that point
13:10:52 <johnw> in the Monoid category, the morphisms are the values of the monoid
13:10:59 <johnw> <> is given composition
13:11:02 <johnw> by composition
13:11:14 <johnw> sorry, my focus is divided now, so I'm going to end here
13:13:02 <benzrf> f|`-`|f: morphisms of hask, to be clear, are /actual function values/
13:13:17 <benzrf> f|`-`|f: (->) is not itself a morphism of hask; it is the type constructor for the type of the values that are morphisms
13:14:12 <sagittarian> @pl \x -> (f x, g x, h x)
13:14:12 <lambdabot> ap (liftM2 (,,) f g) h
13:14:25 <benzrf> ew
13:14:29 <sagittarian> yuck indeed
13:14:35 <sagittarian> couldn't it do something with liftM3
13:14:39 <benzrf> :t liftA3 (,,,)
13:14:40 <lambdabot> Applicative f => f a -> f b -> f c -> f (d -> (a, b, c, d))
13:14:46 <f|`-`|f> lel
13:14:52 <f|`-`|f> you type faster than me
13:15:02 <benzrf> o, wait..
13:15:06 <benzrf> :t liftA3 (,,)
13:15:07 <lambdabot> Applicative f => f a -> f b -> f c -> f (a, b, c)
13:15:16 <benzrf> ah, but thats different
13:15:18 <bitemyapp> inverted trifunctor
13:15:26 <f|`-`|f> what
13:15:31 <bitemyapp> I'm making shit up :P
13:15:47 <f|`-`|f> yeah, that's more or less how this morphism stuff is
13:15:57 <bitemyapp> it's a bit weird seeing a free f/g/h tho
13:16:05 <bitemyapp> @pl \f g h x -> (f x, g x, h x)
13:16:06 <lambdabot> (ap .) . liftM2 (,,)
13:16:06 <f|`-`|f> the cofuntor, and contrafunctor and *^op made more sense
13:16:10 <bitemyapp> that's better
13:16:16 <benzrf> f|`-`|f: cofunctors are not
13:16:31 <benzrf> f|`-`|f: "cofunctors" are just functors
13:16:50 <f|`-`|f> but the f is Id?
13:16:59 <benzrf> well.... contravariant functors from C to D are "cofunctors" if the co- is being applied to C
13:17:15 <benzrf> and only C as the domain
13:17:16 <f|`-`|f> well I'm lost
13:17:21 <benzrf> its complicated
13:17:33 <zipper> Hmmm running literally everything in emacs slows things down it seems.
13:17:36 <f|`-`|f> Well, that's what everyone says about category theory
13:18:19 <f|`-`|f> I wonder when thee's going to be a Theory based entirely on Categories, not just some special case, like groupoids (cough hott)
13:18:37 <oconnore> Is there a more optimized way to do hPutStr handle $ toLazyText $ Data.Text.Lazy.Builder.Int.decimal 239874?
13:18:42 <benzrf> f|`-`|f: i dont think you know what youre talking about :>
13:18:49 <f|`-`|f> o no
13:18:52 <f|`-`|f> :^)
13:19:03 <oconnore> in my program this is responsible for 2GB of allocations
13:19:25 <oconnore> it seems like printing out an integer should use constant memory
13:19:27 * hackagebot fasta 0.7.1.0 - A simple, mindless parser for fasta files.  http://hackage.haskell.org/package/fasta-0.7.1.0 (GregorySchwartz)
13:19:32 <bitemyapp> oconnore: doesn't Text have an IO module?
13:19:46 <benzrf> f|`-`|f: if i define a "widget" to be a thing that involves some category, then a cowidget that uses C is just a widget that uses C^op
13:19:57 <oconnore> bitemyapp: yes, that hPutStr is from Data.Text.Lazy.IO
13:20:36 <benzrf> f|`-`|f: if i define an endofunctor to be a functor from some category to itself, then a coendofunctor on Hask is a functor from Hask^op to Hask^op, which is the same thing as a functor from Hask to Hask
13:22:30 <benzrf> f|`-`|f: however, if i define functor-to-SomeCat to be a functor from some category to SomeCat, then a co-functor-to-SomeCat on Hask is a fuctor-to-SomeCat on Hask^op, which is not the same thing
13:22:45 <benzrf> f|`-`|f: but when you say 'Functor' in haskell you usually mean an endofunctor on Hask, and in that sense, co- does nothing
13:27:58 <johnw> for example, if cofmap maps (b <- a) -> f b <- f a, you can equally use fmap (a -> b) -> f a -> f b and get the same result
13:29:55 <bitemyapp> oconnore: oh, ouch.
13:30:49 <orion> Hmm, when this gets executed: createNamedPipe logFile 0o606 <-- the permissions on the file end up being prw-------. Does anyone know why it doesn't end up being prw----rw-, as I would expect?
13:31:27 <mauke> what's your umask?
13:31:52 <orion> 0077
13:32:04 <mauke> there you go
13:32:57 <orion> "createNamedPipe fifo mode creates a new named pipe, fifo, with permissions based on mode."
13:33:25 <oconnore> bitemyapp: a few weeks ago someone posted this example here: http://lpaste.net/131741
13:33:33 <orion> mauke: Why should it depend on the umask? The documentation says it creates the pipe based on the mode I give it.
13:33:35 <geekosaur> key being "based on"
13:33:38 <mauke> > showOct (0o606 .&. complement 0o077) ""
13:33:40 <lambdabot>  "600"
13:33:52 <geekosaur> umask overrides. that's done by the kernel
13:33:54 <mauke> do you know what a umask is?
13:33:55 <oconnore> bitemyapp: I thought, "weird, but that's a pretty odd use case"... now I am being bitten by the same thing ;)
13:34:37 <orion> mauke: I do now, thank you.
13:35:24 <athan> Wow, conduit is really cool. `$$` ~ `$`, `=$=` ~ `.`
13:35:39 <mauke> make $$$ fast
13:35:54 <johnw> um, $$ is really nothing like $...
13:38:02 <athan> johnw: Really? It's type looks really similar
13:38:54 <hexagoxel> mauke: you forgot the link in that spam message :)
13:39:01 <johnw> it's binds a source to a sink, but both the source and the sink can be composed of multiple parts
13:39:10 <johnw> a $= b $= c $$ d =$ e =$ f
13:39:12 <johnw> or something like that
13:42:36 <athan> johnw: Ahh yeah I thought I was off, thank you
13:43:52 <johnw> now, with simple-conduit you'd be right on the money :)
13:44:29 <johnw> where $= and $$ are just flip ($), and =$ and =$= are flip (.)
13:44:41 <athan> :x
13:44:44 <johnw> so maybe that's the connection you're intuiting
13:48:34 <m_ryan> hi is there's a way to merge a text seperated by "-" and vice versa. eg "jump in" -> "jump-in" -> "jump in".
13:48:39 <johnw> so my earlier example of a $= b $= c $$ d =$ e =$ f can be seen as (f . e . d) $ c $ b $ a
13:49:31 <srhb> m_ryan: words and then intercalate
13:49:55 <srhb> And then some splitter.
13:50:42 <m_ryan> > words "jump in"
13:50:44 <lambdabot>  ["jump","in"]
13:51:22 <m_ryan> srhb: does words do the split thing?
13:51:35 <srhb> As you just saw it splits on whitespace.
13:52:38 <m_ryan> > split '-' "jump-in"
13:52:39 <lambdabot>      Couldn't match expected type ‘Splitter Char’
13:52:39 <lambdabot>                  with actual type ‘Char’
13:52:39 <lambdabot>      In the first argument of ‘split’, namely ‘'-'’
13:53:04 <m_ryan> > split (=='-') "jump-in"
13:53:05 <srhb> > splitOn "-" "jump-in"
13:53:06 <lambdabot>      Couldn't match expected type ‘Splitter Char’
13:53:06 <lambdabot>                  with actual type ‘Char -> Bool’
13:53:06 <lambdabot>      In the first argument of ‘split’, namely ‘(== '-')’
13:53:06 <lambdabot>  <no location info>: can't find file: L.hs
13:53:26 <m_ryan> > splitOn '-' "jump-in"
13:53:28 <lambdabot>      Couldn't match expected type ‘[Char]’ with actual type ‘Char’
13:53:28 <lambdabot>      In the first argument of ‘splitOn’, namely ‘'-'’
13:53:28 <lambdabot>      In the expression: splitOn '-' "jump-in"
13:53:42 <m_ryan> > splitOn "-" "jump-in"
13:53:43 <lambdabot>  ["jump","in"]
13:54:26 <m_ryan> > intercalate "-" ["jump","in"]
13:54:28 <lambdabot>  "jump-in"
13:54:37 <m_ryan> srhb: thank you
13:54:44 <srhb> m_ryan: Sure.
13:55:09 <m_ryan> > intercalate "-" ["jump"]
13:55:11 <lambdabot>  "jump"
13:56:35 <TallerGhostWalt> is there a reason the either package's Validation doesn't have a Monad instance?
13:57:21 <quchen> Yes, because it violates the Monad laws. jaspervdj posted about this quite recently, hold on.
13:57:38 <quchen> http://jaspervdj.be/posts/2015-05-19-monoidal-either.html
13:57:56 <TallerGhostWalt> quchen: I love it when there are answers like this
13:58:09 <quchen> ..?
13:58:13 <TallerGhostWalt> and then it still gets a Foldable ... because Foldable, there are no laws!
13:58:27 <quchen> Yup.
14:00:30 <quchen> Traversable is related to Applicative, which Validation is. And Traversable implies Foldable, so there's that.
14:05:16 <TallerGhostWalt> quchen this is a great explanation thanks again
14:09:30 * hackagebot hermit 1.0.0.0 - Haskell Equational Reasoning Model-to-Implementation Tunnel  http://hackage.haskell.org/package/hermit-1.0.0.0 (AndrewFarmer)
14:18:47 <CapitalSigma> are there any good tutorials for how to properly use FRP libraries with certain backends?
14:19:18 <CapitalSigma> i'm interested in using reactive-banana + hs2gtk but i can't find much on reactive-banana
14:21:23 <zipper> Hey I have this situation where I am running fmap on something. Then I am running fmap on the result of that fmap.
14:21:30 <zipper> How can I do this in one function?
14:21:55 <c_wraith> fmap f (fmap g x) = fmap (f . g) x
14:22:53 <zipper> c_wraith: Hmmm nice
14:24:03 <zipper> I read in LYAH that and forgot. :(
14:24:10 <JagaJaga> Can smone give me a good graphviz usage example? Can't google a good one :(
14:24:11 <zipper> The brain needs reminding.
14:24:26 <jophish> Yo
14:24:31 * hackagebot errors 2.0.0 - Simplified error-handling  http://hackage.haskell.org/package/errors-2.0.0 (GabrielGonzalez)
14:24:35 <jophish> I'm trying to use Conduit and Websockets together.
14:25:48 <dmj`> jophish: there is a pipes-websockets package
14:26:16 <jophish> dmj`: oh really :/ Just as I've gotten everything working with conduit
14:26:44 <dmj`> jophish: there is a pipes to conduit connector package :)
14:27:05 <jophish> of course there is. Still, that feels quite awful
14:27:47 <dmj`> jophish: (>-$$$->) 
14:28:37 <dmj`> @package pipes-websockets
14:28:37 <lambdabot> http://hackage.haskell.org/package/pipes-websockets
14:28:43 <jophish> Perhaps there's a neat solution for what I want: websockets provides a "runClient :: ... -> IO a" function, but of course a conduit source doesn't fit into an IO a
14:28:52 <jophish> to get the IO a value the whole pipe needs to be composed
14:29:19 <jophish> and I'm pretty sure returning IO (Source ...) will be a bad thing, because the socket will be closed
14:30:21 <jophish> I could do things with a channel and forkIO, but that seems obscene for something like this
14:30:38 <jophish> (especially since this is already running in its own thread)
14:30:52 <anthezium> hey, does anybody know whether readTVarIO# talks to the STM plumbing at all or just does normal loads on transactional variables in IO
14:31:12 <jophish> dmj`: it doesn't seem quite... functional https://github.com/ixmatus/pipes-websockets/blob/master/src/Pipes/Network/Websockets.hs
14:31:20 <anthezium> what's important to me is whether or not readTVarIO# can complete while there is a concurrent transaction writing the TVar I'm reading
14:34:18 <SrPx> So, I have a ray tracer made in Haskell that renders the result to a REPA array. If I wanted to use accelerate, would it be a matter of changing a few names and it would be GPU-accelerated, or do I have to reimplement everything on the GPU as shaders/something?
14:34:36 <SrPx> I can't quite understand accelerate, and I couldn't install it on my computer for all I've tried
14:35:09 <ttt_ff> anyone here use haste for compiling hs to js ?
14:35:17 <ttt_ff> what happens to the client/server model when the websocket disconects?
14:35:23 <ttt_ff> does haste auto reconnect?
14:35:31 <ttt_ff> how does haste handle when websocket connection is dropped?
14:42:14 <m_ryan> hi which is the best Mvar or Tvar?
14:42:21 <quchen> Yes.
14:42:35 <quchen> (Both have their ups and downs.)
14:42:50 <quchen> TVars probably have less pitfalls.
14:43:02 <quchen> At least when you're using them in small examples.
14:43:28 <quchen> Marlow's book talks about their properties quite a bit.
14:44:05 <m_ryan> is this the book you are saying? http://chimera.labs.oreilly.com/books/1230000000929
14:44:44 <quchen> Yes.
14:45:47 <m_ryan> thank you.
14:48:33 * hodapp mumbles something about type-level arithmetic and throws a beer bottle
14:59:58 * SrPx finally finds a good Accelerate tutorial and cries 
15:00:07 <ReinH> hodapp: take one down, pass it around, S (S (S (S (S (S (S (S ...
15:00:44 <ttt_fff> does ghcjs play nice with stackage lts, or does ghcjs want its own packages ?
15:01:54 <Guest5232> @unmtl ReaderT  Env (ErrorT  String (StateT  Integer  Identity)) α
15:01:54 <lambdabot> Plugin `unmtl' failed with: Parse error: ;
15:02:51 <Guest5232>  @unmtl StateT s IO a
15:04:53 <joobus> is there a haskell implementation for the jvm?
15:05:14 <Guest5232> @unmtl StateT s IO a
15:05:14 <lambdabot> s -> IO (a, s)
15:06:00 <Guest5232> @unmtl ReaderT env (ErrorT String (StateT Integer Identity)) a
15:06:00 <lambdabot> env -> (ErrorT String (StateT Integer Identity)) a
15:07:10 <Guest5232> @unmtl (ErrorT String (StateT Integer Identity)) a
15:07:10 <lambdabot> (ErrorT String (StateT Integer Identity)) a
15:08:21 <jle`> unmtl used to be recursive
15:08:24 <jle`> i wonder what happened?
15:09:05 <jle`> joobus: i think not really anymore.  there is a haskell-like language that runs on jvm, but i'm not sre if it's still maintained
15:09:50 <bitemyapp> jle`: Ingo is still working on that I think
15:10:08 <bitemyapp> jle`: but it's not 100% compatible from what i understand and I'm not sure the JVM is really a plus.
15:10:14 <bitemyapp> green threads are nice yo
15:10:28 <dmj`> bitemyapp: troof
15:10:33 <c_wraith> also, not having to use typical java libraries is nice
15:10:40 <bitemyapp> ^^ srsly
15:10:48 <c_wraith> Biggest advantage to not being on the JVM.  Not using java libraries.
15:12:15 <Guest5232> 'Night to everybody
15:12:22 <dmj`> payce
15:17:19 <mjrosenb> @pl \ f (x,y) -> (x, f y)
15:17:19 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,))
15:17:24 <mjrosenb> ... no.
15:17:35 <mjrosenb> what is the thing from Arrows that does that?
15:18:08 <bitemyapp> mjrosenb: fmap?
15:18:19 <bitemyapp> @ty \ f (x,y) -> (x, f y)
15:18:20 <lambdabot> (t -> t2) -> (t1, t) -> (t1, t2)
15:18:28 <bitemyapp> that's fmap.
15:18:29 <Cale> :t second
15:18:31 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
15:18:46 <bitemyapp> > fmap (+1) ('a', 1)
15:18:47 <lambdabot>  ('a',2)
15:19:16 <arkeet> :t fmap `asTypeOf` second
15:19:17 <lambdabot> (a -> b) -> (d, a) -> (d, b)
15:19:18 <jle`> there is also a new method in base as of 7.10 that does that too
15:19:48 <Cale> oh?
15:19:57 <jle`> yes
15:20:06 <jle`> :t fmap `asTypeOf` Data.Bifunctor.second
15:20:07 <lambdabot> (Functor (p a1), Bifunctor p) => (a -> b) -> p a1 a -> p a1 b
15:20:29 <jle`> hm
15:20:40 <jle`> :t Data.Bifunctor.second `asTypeOf` second
15:20:41 <lambdabot> (b -> c) -> (a, b) -> (a, c)
15:20:43 <jle`> ah ha
15:21:06 <arkeet> :t Data.Bifunctor.second
15:21:07 <lambdabot> Bifunctor p => (b -> c) -> p a b -> p a c
15:21:16 <jle`> p ~ (,)
15:21:38 <michaelt_> :t Data.Bifunctor.first
15:21:39 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
15:21:52 <jle`> > Data.Bifunctor.second show (1,2)
15:21:53 <lambdabot>  Not in scope: ‘Data.Bifunctor.second’
15:22:08 <michaelt_> >  map (Data.Bifunctor.first succ) [Left 1, Right "hello"]
15:22:10 <lambdabot>  Not in scope: ‘Data.Bifunctor.first’
15:22:33 <mjrosenb> jle`: what is the one in 7.10?
15:22:41 <jle`> it's the one i mentioned
15:22:45 <jle`> http://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Bifunctor.html
15:22:49 <mjrosenb> ~?
15:22:55 <mjrosenb> oh, Data-Bifunctor.
15:23:11 * mjrosenb interpreted 'in 7.10' as 'in Prelude'
15:23:20 <jle`> ah yeah
15:24:01 <jle`> if we had an operator for liftA2 (,), then we wouldn't need (&&&) either
15:24:46 <jle`> byorgey called it (**) but i don't think that's going to fly
15:26:00 <jle`> it seems to be a fundamental enough operation that i feel sometimes like it should be in the typeclass, or at least a thing
15:26:22 <arkeet> doesn't seem all that useful though
15:26:29 <arkeet> I'd rather just have liftA2 in the class.
15:26:45 <michaelt_> I sometimes end up with a little (><) = liftA2 (,)
15:27:01 <jle`> >< is cute
15:27:03 <Cale> Well, we would still need (&&&)
15:27:11 <mjrosenb> :t (&&&)
15:27:12 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
15:27:14 <jle`> some people might
15:27:22 <jle`> but not 98% of the people who use (&&&)
15:27:31 <jle`> (i did the math)
15:27:53 <arkeet> @let infixr 3 ><; (><) = liftA2 (,)
15:27:54 <lambdabot>  Defined.
15:27:55 <jle`> actually
15:28:02 <arkeet> > (show >< succ) 5
15:28:03 <lambdabot>      Ambiguous occurrence ‘><’
15:28:03 <lambdabot>      It could refer to either ‘L.><’, defined at L.hs:155:1
15:28:03 <lambdabot>                            or ‘Lambdabot.Plugin.Haskell.Eval.Trusted.><’,
15:28:06 <arkeet> bah.
15:28:09 <jle`> all use cases of (&&&) can be supplanted with liftA2 (,)
15:28:10 <arkeet> > (show L.>< succ) 5
15:28:11 <lambdabot>  ("5",6)
15:28:20 <jle`> because all Arrow instances have a derived Applicative instance
15:28:51 <mjrosenb> jle`: but that is not infix.
15:29:09 <mjrosenb> although, we could borrow that pair of operators from ocaml.
15:30:01 <jle`> instance Arrow r => Applicative (r a) where pure = arr . const; f <*> g = uncurry ($) <$> (f &&& g)
15:30:14 <mjrosenb> :t (^^)
15:30:15 <lambdabot> (Fractional a, Integral b) => a -> b -> a
15:30:36 <mjrosenb> gah, I guess I can use ^%
15:30:36 <jle`> s/can be supplanted with/can be supplanted with an appropriate fixity operator version of
15:32:16 <zipper> Can I get help with a few IO things here: https://gist.github.com/urbanslug/6be31c8ae977b91f5811
15:32:26 <jle`> i probably shouldn't use (<$>) in that definition....f <*> g = arr (uncurry ($)) . (f &&& g), or uncurry ($) ^<< f &&& g
15:32:34 <zipper> The issue is small and explained in the paste. I don't want o use do notation.
15:32:44 <zipper> Oh hey jle` o/
15:33:02 <jle`>  \o
15:33:41 <jle`> zipper: you can use (=<<)
15:33:54 <arkeet> Arrow is just Category + Applicative anyway.
15:33:55 <jle`> (=<<) :: (a -> IO b) -> (IO a -> IO b
15:34:07 <jle`> it lets you take an (a -> IO b) and apply it to an (IO a)
15:34:53 <jle`> also there's nothing wrong with do notation :)
15:35:17 <zipper> jle`: Heh I have the solution in do
15:35:21 <Peaker> especially if you add Applicative desugaring :)
15:35:28 <zipper> but I see that people tend to look down on it.
15:35:39 <zipper> So I'm trying to learn not to use it.
15:35:49 <Peaker> who looks down on "do" notation? Everyone uses it
15:35:58 <jle`> do notation is the best solution for a lot of things
15:36:03 <jle`> for many of the situations it's used for
15:36:09 <zipper> Peaker: I believe people in this channel have called it evil
15:36:14 <johnw> I find looking down at "do" notation to be a bit ridiculous
15:36:17 <zipper> :t (=<<)
15:36:17 <lambdabot> Monad m => (a -> m b) -> m a -> m b
15:36:31 <kadoban> Many big things look ridiculous in non-do, from what I've seen.
15:36:37 <jle`> i'll do `f =<< x` instead of do { x' <- x; f x'}, but...
15:36:44 <jle`> in general, do notation is a great blessing to the world
15:36:47 <johnw> it's all notation anyway
15:36:56 <arkeet> yeah I prefer not using do for 1 or 2 line things.
15:37:01 <kadoban> Yeah, if it's tiny I'll use manual combinators, otherwise …
15:37:05 <zipper> jle`: Mine would be a lot more readable in do I think.
15:37:08 <michaelt_> zipper: define     url id_ = "http://ws.audioscrobbler.com/2.0/?method=user.getRecentTracks&user=" ++ nick ++ "&api_key="++ id_ ++"&limit=1&format=json" then include it in the big fmap
15:37:20 <kadoban> zipper: Sounds like a great reason to use 'do' then :)
15:37:53 <Peaker> ">>= \x ->"   is silly, use "do"
15:38:14 <Peaker> Also, "do" newlines are lower precedence than everything, which is a nice extra tool to avoid parenthesis :)
15:38:27 <zipper> michaelt_: What is "it" in this context?
15:38:29 <Peaker> and indent-based is nice!
15:38:45 <arkeet> I would use do in zipper's case.
15:39:17 <arkeet> > 2 * do 3 + 4
15:39:18 <lambdabot>  14
15:39:29 <jle`> the more readable option is almost always the better option
15:39:43 <jle`> there are exceptions, such as in obfuscated code competitions
15:40:40 <johnw> arkeet: haha
15:40:55 <arkeet> :)
15:41:00 <michaelt_> zipper:  I was thinking something like  fmap (...) $ getJSON =<< url appId ; it does seem like a case for do
15:41:15 <johnw> > uncurry (+) $ do (1, 3)
15:41:17 <lambdabot>  4
15:41:20 <arkeet> > print $ do 10 :: Double
15:41:22 <lambdabot>  <IO ()>
15:41:50 <jle`> michaelt_: you can do fmap (...) . getJSSON =<< url appId i guess, but yeah, do might be better at that point
15:41:57 <kern_chicken_pan> Anyone used Docker to deploy a Haskell web app before? I'm trying to work out how to cache some of the cabal build so it does not take so long
15:42:00 <jle`> who needs $ when you can use do
15:42:12 <jle`> > print do 10
15:42:14 <lambdabot>  <hint>:1:7: parse error on input ‘do’
15:42:16 <jle`> aw
15:42:22 <mjrosenb> > let (b ^% 0) f n = 1; (b^%1) f n = f b n; (b^%e) f n = if even e then (b2 ^% e2) f n else f (b*((b2 ^% e2) f n)) n where b2 = f (b*b) n; e2 = e`div`2 in (2^%1000000000) mod 1234567891
15:42:23 <lambdabot>  1184165238
15:42:24 <arkeet> > print $ 10 :: Double
15:42:25 <lambdabot>      Couldn't match expected type ‘Double’ with actual type ‘IO ()’
15:42:25 <lambdabot>      In the expression: print $ 10 :: Double
15:42:38 <jle`> what nice utility
15:43:46 <mjrosenb> is ^% a good name for that?  I feel like that would be a better name if mod were hard-coded into it.
15:43:58 <dcoutts> kern_chicken_pan: my advice is don't build your haskell app as part of the docker image build. Rather make the docker image once, then build your Haskell static binary on a build machine and deploy it to the target.
15:44:03 <mjrosenb> that being said, what else could you possibly want to use for f?
15:44:12 <michaelt_> zipper: sorry, I wanted fmap url appId .  I recommend do!
15:45:14 <jle`> you can move the fmap to the other side of the =<< if you wanted.  so getJSON =<< fmap url appId is getJSON . url =<< appId
15:45:17 <jle`> idk
15:45:30 <rofer> Can someone help me get Aeson-0.8.1.0 to build? I'm doing this in a sandbox and it keeps complaining about "No instance for (Read Object)"
15:45:35 <jle`> i should be studying :)
15:48:11 <zipper> jle`: This is what I have: https://gist.github.com/urbanslug/6be31c8ae977b91f5811
15:48:20 <zipper> It's a little cryptic IMO
15:49:15 <samba1> is there anything like m a -> (a -> [m b]) -> m b?
15:49:37 <srhb> Erm, what would that do?
15:49:51 <srhb> The list appears from nowhere and disappears into nowhere
15:49:58 <samba1> sorry
15:50:01 <samba1> should be a list at the end
15:50:08 <samba1> m a -> (a -> [m b]) -> [m b]
15:50:17 <pavonia> :t sequence
15:50:18 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
15:50:30 <jle`> zipper: (\x -> return (f x)) =<< y is just fmap f y
15:50:38 <jle`> but i still think the do notation is much better
15:51:12 <jle`> samba1: that sounds like just concatMap
15:51:16 <jle`> :t flip concatMap
15:51:18 <lambdabot> Foldable t => t a -> (a -> [b]) -> [b]
15:51:31 <jle`> oh i see, it's different
15:51:32 <arkeet> samba1: you can get as far as m a -> (a -> [m b]) -> m [b]
15:51:38 <arkeet> the things you asked for don't exist.
15:52:06 <jle`> yeah, it doesn't work, because what if m was IO?
15:52:16 <michaelt_> zipper: url = fmap (\appId -> "http://ws.audioscrobbler.com/2.0/?method=user.getRecentTracks&user=" ++ nick ++ "&api_key="++ appId ++"&limit=1&format=json") (getEnv "lastfm_appId")
15:52:21 <jle`> you can't write an IO a -> (a -> [IO b]) -> [IO b]
15:52:24 <arkeet> :t \ma almb -> sequence (ma >>= almb)
15:52:25 <lambdabot> (Monad t, Monad m, Traversable t) => t a1 -> (a1 -> t (m a)) -> m (t a)
15:52:39 <arkeet> hm.
15:52:46 <arkeet> that's not right.
15:52:57 <arkeet> :t \ma almb -> ma >>= sequence . almb
15:52:58 <lambdabot> (Monad m, Traversable t) => m a -> (a -> t (m a1)) -> m (t a1)
15:53:16 <michaelt_> zipper: it's a little bizarre it's true. somehow do {appid <- getEnv ".."; let url = ... appid ...; etc.} will be clearer
15:53:16 <grpala> fixity?
15:54:39 <zipper> jle`: I don't think the fmap would work in that case because of the position of appId
15:55:00 <zipper> I could be wrong I should just write something legible and move on.
15:57:41 <michaelt_> zipper: the case is essentially 'monadic' since one action (getJson ...) depends on the result of the other (getEnv ...). I guess that's obvious. 
16:01:39 <zipper> michaelt_: Are you saying that fmap is usable?
16:02:01 <zipper> michaelt_: Because I just tried it. I can show you the code.
16:03:17 <zipper> michaelt_: Uh yes but still a lambda would be used.
16:04:50 <michaelt_> zipper: oh, you will use fmap. I was just defending the wisdom that do will be clearer, it separates the actions 
16:05:29 <michaelt_> zipper: I mean, I was defending the idea that using do will be clearer than not using do. 
16:06:35 <zipper> michaelt_: Yes you're right. Do is less confusing even to myself.
16:13:36 <mjrosenb> @hoogle (a->b) -> (b->c->d) -> a->c->d
16:13:37 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
16:13:37 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
16:13:37 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
16:15:03 <mjrosenb> oh, that isn't the type I wanted
16:15:53 <mjrosenb> the type on the function I want is going to look horrendous.
16:19:22 <jonrus_> Heya people. I deployed my first Haskell program to production today and I'm wondering if anyone could recommend good source code examples for beginners to get acquainted with common idioms in Haskell?
16:20:10 <kern_chicken_pan> dcoutts: thx. Do you know of any blogs or something where someone has wasted their day already figuring out the shell script details :p ?
16:20:35 <mjrosenb> the type on the function I want is going to look horrendous.
16:20:37 <dcoutts> kern_chicken_pan: not off the top of my head. However, I can point you to cabal copy --destdir=$image
16:20:49 <dcoutts> kern_chicken_pan: and cabal configure --prefix=$something
16:21:38 <dcoutts> kern_chicken_pan: so you can precisely control the layout and target location of the image you make. And then that's the image you'd deploy to the target (or include into the docker image).
16:22:24 <kern_chicken_pan> dcoutts: yea, its just the detail of these things tends to be a pain in the ass
16:22:31 <dcoutts> true
16:22:33 <kern_chicken_pan> is there anything more suitable than docker?
16:22:47 <kern_chicken_pan> I'm happy to use whatever really
16:23:02 <kern_chicken_pan> deploying a snapframework web app btw
16:23:37 <dcoutts> kern_chicken_pan: there's quite a variety, mostly depending on what people are already familiar with. e.g. making rpms/debs from an image, docker, vagrant, nix
16:24:07 <kern_chicken_pan> dcoutts: oh yes, nix could be good
16:24:10 <jophish> What could cause "cabal install" to fail, but "cabal exec -- ghc --make Main.hs" to succeed?
16:24:19 <kern_chicken_pan> I would like to do CI also
16:24:33 <dcoutts> kern_chicken_pan: many people swear by nix
16:24:45 <dcoutts> all these things have their learning curve sadly
16:24:49 <kern_chicken_pan> the cabal build dependencies is what's killing me
16:24:50 <acowley> Hooray, Nix!
16:25:08 <kern_chicken_pan> dcoutts: i've sent patches to NixOS before :)
16:25:20 <dcoutts> sounds like a good choice then
16:25:39 <kern_chicken_pan> not sure how I would setup CI + deployment on Fedora with nix though
16:25:48 <jophish> ah, I think it's running some template code only with optimizations on
16:26:36 <dcoutts> kern_chicken_pan: rpms is also a reasonable approach, since that integrates nicely with other tools like docker etc
16:27:16 <mjrosenb> how do I specify the type for an infix function?
16:27:24 <mjrosenb> I tried (:::) :: Int
16:27:29 <jophish> nope, that's not it
16:27:46 <kern_chicken_pan> dcoutts: nar, RPM's suck
16:27:54 <dcoutts> heh
16:27:59 <acowley> jophish: Maybe you could say more about how cabal install is failing
16:28:01 <kern_chicken_pan> been there done that :)
16:28:32 <dcoutts> kern_chicken_pan: one simplification to note though is that for something like this you're only using rpm in a very superficial way, since you're deploying a static binary
16:29:33 <jophish> acowley: yeah, just putting it into a gist now
16:29:50 <mjrosenb> @pl (a->b)->(e->d->c->a)->e->d->c->a
16:29:50 <lambdabot> (line 1, column 5):
16:29:50 <lambdabot> unexpected '>'
16:29:50 <lambdabot> expecting operator
16:29:50 <kern_chicken_pan> dcoutts: well I do have docker working already, if I could just fix the cabal caching issue I can get on with my project and revisit it later
16:30:13 <mjrosenb> @djinn (a->b)->(e->d->c->a)->e->d->c->a
16:30:13 <lambdabot> f _ a b c d = a b c d
16:30:14 <dcoutts> kern_chicken_pan: so what's the caching issue exactly?
16:30:31 <mjrosenb> @djinn (a->b)->(e->d->c->a)->e->d->c->b
16:30:31 <lambdabot> f a b c d e = a (b c d e)
16:30:48 <mjrosenb> @.pl . djinn (a->b)->(e->d->c->a)->e->d->c->b
16:30:48 <lambdabot> (line 1, column 1):
16:30:48 <lambdabot> unexpected "."
16:30:48 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
16:31:23 <dcoutts> kern_chicken_pan: also, if you're doing CI, you can just have your "cabal copy --destdir=$image" be produced by the CI, and deploy that.
16:31:45 <jophish> the output of ghc --make https://gist.github.com/expipiplus1/c3da80d83d8cbc0c4183 and the output of cabal install https://gist.github.com/expipiplus1/9080f006b8492953c007
16:32:12 <jophish> From what it looks like, cabal install is loading a host of extra libraries, is it doing some kind of template haskell?
16:32:47 <dcoutts> sigh
16:33:03 <jophish> nm libSDL2.a shows that it contains that 'missing' symbol
16:33:05 <kern_chicken_pan> dcoutts: thx for all the suggestions
16:33:57 <dcoutts> jophish, acowley: so the issue is this: if you use ghc -package blah, then when it comes to use TH, it will go and load blah. Where as when you don't say anything ghc figures out for itself which packages it ought to load for TH.
16:34:01 <jophish> and removing the dependency on that particular symbol just unearths another missing symbol
16:34:23 <dcoutts> jophish, acowley: and when there are packages that are borked and cannot be loaded in ghci/TH then that difference matters.
16:34:28 <jophish> dcoutts: ah, that makes a lot of sense
16:34:55 <jophish> dcoutts: I hope there's a neat and tidy solution
16:35:14 <dcoutts> jophish: not really
16:35:15 <jophish> (I think all the template code is in another library, there certainly isn't any in my code)
16:35:55 <jophish> (or quasiquotes)
16:36:04 <jophish> dcoutts: D: that's annoying
16:36:47 <jophish> Would it help to move the offending module into its own package?
16:37:13 <jophish> with a set of non-broken dependencies
16:40:44 <KaneTW> .go 24
16:40:46 <KaneTW> oops
16:42:44 <kern_chicken_pan> https://weakdh.org/ US crypto export laws struck again
16:43:22 <Lokathor> :t ((.).(.).(.))
16:43:24 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
16:48:23 <hiptobecubic> triple boob
16:48:39 <hiptobecubic> with some extra bits in the middle i guess
16:49:08 <tombert> Hello!  I have an issue; I need to chunk up calls to a JSON API into multiple requests (that part is done) and I'm trying to parse the response with Text.JSON
16:49:12 <tombert>  myObjects <- mapM (\x -> decode x :: Result QueryObj) responses
16:49:43 <tombert> the issue I'm getting is that doing that line in a do block gives me an error saying that it expects an IO QueryOb
16:49:52 <tombert> and I'm giving it a Result type
16:50:13 <tombert> now, checking at the Text.JSON documentation, Result does implement Monad
16:50:30 <tombert> so is there some mechanism in which to convert that into an IO monad type
16:50:31 <srhb> tombert: So responses is probably not an IO something?
16:50:32 <dcoutts> jophish: that'd probably help
16:50:51 <dcoutts> jophish: if you can isolate the use of TH in a package that doesn't depend on all those C libs then yes.
16:50:54 <dcoutts> jophish: https://ghc.haskell.org/trac/ghc/ticket/10436
16:51:03 <srhb> tombert: In which case it sounds like you're in an IO block and you want let myObjects = ... instead of myObjects <- ...
16:51:38 <jophish> dcoutts: I'll give it a try, thanks a bunch!
16:51:40 <tombert> That's fine; how do I go about extracting the values outta the result monad thign?
16:51:56 <michaelt_> yes, its just let myObjects = map (...) responses
16:52:03 <srhb> tombert: I don't know what the result type is like.
16:52:11 <srhb> tombert: Whatever you'd normally use to extract from Result ...
16:52:12 <michaelt_> doesn't decode give a Maybe?
16:52:16 <srhb> Sounds probable
16:52:30 <tombert> decode :: JSON a => String -> Result a
16:52:39 <tombert> https://hackage.haskell.org/package/json-0.3.3/docs/Text-JSON.html#t:Result
16:52:39 <michaelt_> Oh, I'm thinking of aeson
16:52:39 <srhb> And what's Result?
16:52:57 <srhb> tombert: So just case match on myObject
16:53:00 <tombert> https://hackage.haskell.org/package/json-0.3.3/docs/Text-JSON.html#t:Result
16:53:22 <srhb> tombert: Either it's an OK x -> good to go; or it's an Error err -> damn
16:53:40 <tombert> OHH, like on maybes
16:53:43 <srhb> Yes.
16:53:55 <tombert> I feel silly now; I can just map through and pattern match out the stuff I don't like
16:54:00 <srhb> Yep.
16:54:26 <tombert> This is part of what's awesome about haskell; the community is so genuinely helpful all the time
16:54:36 <srhb> :) Glad you think so.
16:54:48 <SrPx> Anyone here familiar with the Reduceron? Is it comparable in performance with GHC itself, or more of a demonstration?
16:56:19 <dcoutts> SrPx: more a demo
16:56:36 <acowley> SrPx: How would go about comparing that performance?
16:56:39 <fryguybob> anthezium: I didn't see anyone answer your question, but readTVarIO will spin while another transaction is attempting to commit or durring some validation.
16:56:47 <dcoutts> SrPx: given that it's implemented on an FPGA, and so can't hit high clock speeds, it's quite impressive
16:56:57 <acowley> Reduceron's performance depends quite largely on the hardware
16:57:42 <fryguybob> anthezium: But it won't deadlock.
16:57:53 <SrPx> I see
16:58:20 <dcoutts> SrPx: the paper has comparisons to standard cpus
16:58:56 <Hasker_> Anybody have a recommendation on a js frontend
16:59:16 <SrPx> Is there any reason nobody (afaik) on the community is exploring parallelization techniques? I'm studying Accelerate and it is impressive. I wonder what stops Haskell itself to run on the gpu
16:59:25 <SrPx> Hasker_: reflex + ghcjs?
16:59:41 <acowley> SrPx: http://www.seas.upenn.edu/~acowley/papers/hocl.pdf
17:00:04 <Hasker_> SrPx: I'm trying to install, but it's a pain in the butt with a bunch of dependencies (and I don't know how to use nix). Is it worth learning nix?
17:00:23 <acowley> SrPx: I think parallelism is something whose efficiency depends a lot on domain and hardware specific reasoning.
17:01:06 <acowley> SrPx: So you see a bunch of one-off libraries that quickly bitrot because they don't support some new thing that comes along, or aren't flexible enough to be applied to different domains than originally envisioned.
17:01:55 <acowley> SrPx: My approach is to be completely modular with language construction, so I can write libraries that are re-targetable to completely different hardware without getting locked into one paradigm.
17:03:22 <f|`-`|f> So
17:03:52 <SrPx> Hasker_: I know that feeling... yes, it is a pain... and I'd say it is definitedly worth learning nix if you are working with haskell on the long term... but I personally failed at installing Nixos on my mac (boot errors, issue open til today...) so I can't say a lot
17:04:15 <f|`-`|f> There's a paper around somewhere about combiningLinear Logic and Haskell's Lambda Calculus for more predictable eprformance
17:04:40 <Hasker_> SrPx: I used try-reflex, which worked, but it didn't make much sense to me what it was doing, and I didn't like that... I think it's just a lack of understanding of nixos
17:04:42 <SrPx> Some would say you can just use Nix without Nixos but I couldn't install half of the libraries on Nix+OSX that I could on NixOS itself. Not sure why, though, so... 
17:04:48 <f|`-`|f> All I can understand about NixOS is that it can reasonably be installed on a somewhat disparate cluster
17:05:09 <acowley> I use Nix + OS X using https://github.com/acowley/cabbage
17:05:30 <acowley> It means I don't have to rebuild every package for every sandbox
17:05:46 <SrPx> acowley: how so?
17:05:47 <acowley> But I haven't taken the step of paying for hosting a binary cache
17:05:49 <luite> eventually i should make ghcjs installable for mere mortals or something :)
17:05:52 <SrPx> (to what you said earlier)
17:06:08 <acowley> I say a lot of things. The answer is probably Haskell?
17:06:18 <SrPx> uh... okay
17:06:35 <acowley> Sorry, but which thing are you asking about?
17:07:02 <SrPx> I asked what do you mean with "being completely modular with language construction"
17:07:48 <acowley> SrPx: Oh, the paper explains how that works. There's also a video covering it in some detail: https://youtu.be/_KioQRICpmo
17:08:09 <acowley> SrPx: A program has a type that explicitly lists the language features it makes use of.
17:08:14 <Hulio> hi
17:08:19 <Hulio> what is haskell
17:08:34 <acowley> SrPx: So one can build a library of such things, then make use of a compilation backend that supports the union of required features.
17:08:43 <Welkin> haskell is your mom
17:08:53 <SrPx> Ah I was reading the paper 
17:08:54 <KaneTW> a purely functional programming language
17:09:01 <acowley> SrPx: I've only demoed Haskell and OpenCL backends, but I have a tiny C one for microcontrollers that isn't ready for public consumption yet.
17:09:18 <acowley> Hulio: https://www.haskell.org
17:09:26 <bitemyapp> Hulio: it's a fun and productive programming language.
17:09:40 <SrPx> But that goes against what I want, I think... I mean, acowley, that sounds like an awesome practice for perf, but I guess it considerably reduces code reusability
17:09:52 <bitemyapp> Hulio: it offers as much productivity and brevity as super-high-level languages and as much performance as many lower-level ones :)
17:10:04 <acowley> SrPx: How so? It's exactly the opposite!
17:10:21 <Hasker_> Nixos is so confusing. I read the manual and still have no idea. Also, if I use cabbage, how do I get it setup acowley?
17:10:40 <Welkin> once go haskell, you don't go back!
17:10:46 <Welkin> once you go haskell, you don't go back!
17:10:55 <acowley> Hasker_: You still need to install Nix. I followed the instructions at https://nixos.org/wiki/Nix_on_OS_X
17:11:07 <Hasker_> I've installed already
17:11:16 <Hasker_> Using try-reflex
17:11:24 <Hasker_> I can get a nix shell
17:11:35 <Hasker_> Just don't a have a default.nix (don't know why this is)
17:12:12 <acowley> Hasker_: If you have a a .cabal file, you can run "cabbage" in that directory and it will build everything and store things in /nix/store so the next time you run "cabbage" it will re-use those builds if possible.
17:12:33 <acowley> Hasker_: So you can have multiple instances of a package built against different dependencies and such
17:12:34 <Hasker_> interesting. And this is inside of sandboxes?
17:12:53 <acowley> Hasker_: What cabbage does is build the sandbox such that it links to the files in /nix/store
17:13:01 <Welkin> cabbage??
17:13:03 <Hasker_> ah okay got it
17:13:09 <dmj`> cabbage??
17:13:17 <mmaruseacph2> now I'm hungry
17:13:19 <Welkin> is that a play on cabal and babbage?
17:13:28 <acowley> Hasker_: So, cabbage writes a bunch of default.nix files, then you run "nix-shell --command 'sh $setup'", then you run "cabal configure"
17:13:51 <acowley> Welkin: It's shapr's idea of what Haskell packages should have been called due to being cabal packages.
17:14:43 <acowley> Hasker_: The downside compared to NixOS is that there is no Internet-hosted binary cache available, which means you still need to build everything (other than GHC itself) at least once.
17:15:10 <acowley> Hasker_: For GHC, I use an official bindist using https://github.com/acowley/mynix
17:15:32 <SrPx> acowley: (reading)
17:15:51 <Hasker_> awesome I'll try to figure it out lolol
17:16:09 <acowley> Hasker_: It's still pretty idiosyncratic since I made it to address my own frustrations
17:16:26 <Welkin> time for a yesod compiler break!
17:16:40 <Welkin> all the things you can do while yesod compiles
17:16:44 <acowley> Hasker_: I don't know if there's a large enough potential userbase for Nix on OS X to make it worth really polishing. Kind of a chicken and egg situation there.
17:17:31 <Hasker_> acowley: makes sense. I just got ghcjs to work locally
17:17:37 <Hasker_> which is wonderful!
17:18:49 <SrPx> acowley: well, I think part of the appeal of Haskell is that it is a very high level language where you are free to use abstractions over abstractions, leaving to the compiler the job of making it run fast
17:19:12 <SrPx> maybe that's why my prejudice torwards the concept, when you are recognizing the hardware exists it kinda beats the utopia
17:19:25 <acowley> SrPx: That's exactly right
17:19:52 <Hasker_> SrPx: I would really love a low level opencl library that didn't have mutable state in haskell. The current one kinda blows
17:20:22 <acowley> SrPx: But I am tired of leaving utopia! So my choices were to either write uselessly slow GPU code in Haskell, or come up with an extensible model that will let me take advantage of hardware features as-needed, while writing all the code I care about in Haskell.
17:20:56 <SrPx> acowley: uh huh, that sounds like a great approach on the real world
17:21:09 <acowley> SrPx: The point is libraries written against a HOCL-like model, not HOCL itself, which is, as you suggest, focused on lower level considerations.
17:21:43 <acowley> SrPx: But I need to convince people that modularity and extensibility of language definitions are critical to write useful high-level code that can live beyond a single paper.
17:23:01 <Welkin> I want to see more Dr. Seuss in Haskell
17:23:20 <Welkin> bitemyapp: are you adding that to your book?
17:23:29 <Hasker_> :t nestedSnaplet
17:23:30 <lambdabot> Not in scope: ‘nestedSnaplet’
17:26:53 <SrPx> okay I'm kinda buying the idea
17:27:52 <acowley> SrPx: The biggest downside is that it really stretches some corners of GHC. However, I think it's also a testament to GHC's sophistication that the Haskell backend performs so well.
17:29:27 <bitemyapp> Welkin: uh
17:29:43 <bitemyapp> Welkin: there's a bit of silliness but nothing truly Dr. Seuss-y
17:30:04 <Welkin> add some creative artwork
17:30:10 <Welkin> better than LYAH
17:36:55 <zipper> Is there a function that escapes spaces in a string such that they're usable in a url?
17:37:13 <Welkin> bitemyapp: will you also mysteriously disappear after publishing your book, much like Miran did?
17:37:54 <Welkin> zipper: there is likely something in one of the http packages
17:37:55 <f|`-`|f> Yeah, the stuff that the groups developing Feldspar, and Obsidian are doing some really bleeding edge exploits
17:38:02 <zipper> Welkin: I assume they get really busy after publishing.
17:38:44 <Welkin> https://hackage.haskell.org/package/network-uri-2.6.0.3/docs/Network-URI.html#v:escapeURIString
17:38:53 <mac10688> Can someone help explain how this (value? function?) works?
17:38:54 <mac10688> getCurLine :: Editor b Int
17:38:54 <mac10688> getCurLine = gets snd
17:39:10 <dmj`> :t gets snd
17:39:11 <lambdabot> MonadState (a1, a) m => m a
17:39:13 <SrPx> acowley: I don't 
17:39:22 <Welkin> https://hackage.haskell.org/package/scholdoc-0.1.3/docs/Text-Pandoc-Shared.html#v:escapeURI
17:39:27 <Welkin> that one is what you want
17:39:32 <dmj`> mac10688: Editor is a instance of MonadState
17:39:33 <Welkin> specifically for excaping spaces
17:39:44 <mac10688> everyone does that but that doesn't help me understand it :/ How's it getting the Current line of anything?
17:39:57 <mac10688> Yeah, I'll paste all the source code. just a second
17:40:10 <dmj`> mac10688: the state probably accumulates over every line traversed
17:40:21 <dmj`> mac10688: are you familiar with the state monad?
17:40:22 <lpaste> Mac10688 pasted “Editor Module” at http://lpaste.net/133021
17:40:33 <mac10688> I read about it in Learn you Some haskell
17:41:03 <SrPx> acowley: woops, my bad, I don't see any about hocl on your github repo
17:41:20 <mac10688> gets snd, doesn't accept any arguments
17:41:28 <mac10688> what's it getting the current line of?
17:41:46 <acowley> SrPx: I put the code from Boston Haskell talk up there, but haven't released the main code base yet. I was hoping to have the paper published around the time I release the code in case I'd missed a trick.
17:41:52 <davean> mac10688: the Monad. The Monad contains a value. Thats actually sorta an arguement
17:41:59 <silver> monad can carry some context or state
17:41:59 <SrPx> acowley: I see
17:42:02 <davean> (actually it *can* straight up be an arguement in the function case)
17:42:06 <SailorR> why did haskell just rip off TSQL? lol
17:42:13 <dmj`> mac10688: modCurLine calls setCurLine
17:42:16 <acowley> SrPx: However at this point it's been read or seen by hundreds of people and everything is fine, so I just need to do it.
17:42:21 <dmj`> :t modify . snd . const
17:42:22 <lambdabot>     Couldn't match type ‘b0 -> a’ with ‘(a0, s0 -> s0)’
17:42:22 <lambdabot>     Expected type: a -> (a0, s0 -> s0)
17:42:22 <lambdabot>       Actual type: a -> b0 -> a
17:42:46 <dmj`> setCurLine = modify . second . const
17:42:47 <c_wraith> is TSQL the variant used by MS SQL Server?
17:42:53 <mac10688> I missed that dmj`
17:42:56 <dmj`> :t modify . second . const
17:42:58 <lambdabot> MonadState (d, c) m => c -> m ()
17:43:33 <mac10688> that's helpful dmj`. I swear I thought I looked to see if anything was calling that function
17:43:49 <mac10688> I must have gone down the wrong rabbit hole
17:43:54 <dmj`> mac10688: line 146
17:44:02 <mac10688> yeah I'm there
17:45:51 <dmj`> mac10688: so editor has a loop right
17:46:33 <dmj`> mac10688: a REPL, which calls doCommand, which can call modCurLine, which calls setCurLine, which is modify . second . const, which sets the current line.
17:46:43 <mac10688> yeah, I haven't began to analyze that. I thought haskell wasn't supposed to do loops
17:47:16 <lpaste> dmwit pasted “why does this print "Foo" instead of "bar"?” at http://lpaste.net/133022
17:47:16 <dmj`> mac10688: it loops, but has a base condition, that when met, ends the recursion
17:47:40 <bitemyapp> Welkin: no
17:47:49 <dmwit> I've given an explicit definition for displayException, but when I throw an exception of this type, that implementation doesn't seem to be used. What gives?
17:48:08 <bitemyapp> Welkin: it's possible Miran didn't like getting criticism. I don't blame them, but I'm accustomed to being hated.
17:48:23 <bitemyapp> Welkin: we have further books planned beyond this one, if it does well enough. (We don't expect much though)
17:49:18 <acowley> dmwit: Isn't it just calling showsPrec on the exception?
17:49:48 <acowley> Oh, the docs say it shouldn't
17:51:27 <SrPx> acowley: okay, I'll be watching the progress ... please add an empty github repo sometime just so we can follow it!
17:51:56 <SrPx> acowley: (do you think what you have right now could be used to port my ray tracer to the GPU?)
17:52:02 <dmwit> acowley: Where do you see docs that tell whether it should call showsPrec or not?
17:52:20 <acowley> SrPx: As soon as I'm done my current writing tasks I'll put it all on github. There's half a dozen repositories and 20-30 kloc :/
17:52:22 <SrPx> acowley: I've done it for webgl and I don't want to touch glsl again, *please*
17:52:26 <dmwit> acowley: I'm thinking of filing a bug, and if I can point to documentation that agrees with me all the better. =P
17:52:32 <dmj`> mac10688: the state monad is super important
17:52:35 <SrPx> acowley: :(
17:53:31 <acowley> dmwit: Well, the documentation for displayException gives the impression that it would be called. But I personally gussed it was calling showsPrec because that's what I had thought the repl would do.
17:54:07 <acowley> dmwit: But this seems to entirely depend on special handling by whatever runtime component is doing the printing, so I probably shouldn't have even guessed as to what would happen.
17:54:25 <dmwit> hehehe
17:54:52 <dmwit> An unusual case of the first part of the "predictions are hard" aphorism biting.
17:54:53 <acowley> SrPx: If you've done one in GLSL, then absolutely it could be ported! I've stayed away from a serious ray tracer as I don't know how to deal with geometry in a GPU-friendly way.
17:55:22 <acowley> dmwit: It's at least a documentation bug somewhere
17:56:02 <acowley> dmwit: But if the runtime doesn't call displayException, then is that method only used if you catch the exception yourself?
17:58:53 <acowley> dmwit: Oh, displayException was only added as a method 26 days ago.
17:59:07 <acowley> Err, no
17:59:34 <acowley> November 21, 2014
18:06:22 <SrPx> No, it is not geometry, it is just a voxel grid and the code is very simple
18:10:38 <simon> bitemyapp, ah, thanks.
18:13:06 <acowley> SrPx: Oh, that works great! I do voxel-type things rather a lot, which is why I included the distance field demo in the paper.
18:14:28 <SrPx> acowley: so for example, how would I do to port this? http://lpaste.net/133023 I guess I have to rewrite not only the function in a DSL but also any of its dependencies, right?
18:15:50 <SrPx> hmmm
18:15:51 <acowley> SrPx: Right
18:16:06 <acowley> SrPx: But the distance field rendering example will actually get you pretty far.
18:17:21 <SrPx> uh huh, I've seen it
18:18:06 <acowley> But I do think Accelerate has a more Haskelly programming model out of the box, so I'm sure there will be rough patches. I don't want to oversell anything.
18:18:51 <SrPx> tbh I'm not sure even accelerate is the right path right now... the naive ray tracer is kinda already almost as fast as I want, and it is an internal tool... maybe I could just throw some money on render machines and begin working in something else 
18:20:34 <SrPx> REPA itself is kinda neat, if I just could buy a CPU with hundreds of simple cores or something
18:21:12 <pharaun> knight
18:21:24 <pharaun> the intel knight corner thing?
18:22:25 <SrPx> (btw, will GHC even accept a +RTS -N128 flag? I might waste my money just to learn REPA only suppors a small number of cores)
18:22:29 <SrPx> pharaun: lmgt
18:23:03 <fryguybob> SrPx, pharaun: Xeon Phi?
18:23:54 <silver> buy a gpu and use accelerate
18:24:02 <SrPx> pharaun: I don't understand the pricing of those things, though. I can buy an old CPU for $10. With $2000 and a few internet cables I'd have 200 cpus. That thing cost the same for 32 cpus
18:24:49 <SrPx> silver: but the problem is I'd have to recode every single dependency all the way down from Linear vector functions to my geometry functions to the ray tracer :(
18:25:09 <SrPx> well it isn't a lot tbh but... hm
18:27:01 <fryguybob> SrPx: I don't think Xeon Phi is remotely similar to 200 cpus wired with internet cables.
18:27:52 <johnw> SrPx: you can, just ask for a graphics card
18:29:16 <tombert> IF anyone is willing to help again; I'm trying to parse JSON with Text.JSON.  It's working beautifully when JSON properties are lowercase letters
18:29:36 <tombert> but when a property in the JSON has a capital letter in the beginning of its key, it breaks
18:29:43 * hackagebot rainbow 0.26.0.4 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.26.0.4 (OmariNorman)
18:29:51 <tombert> I think because it match the record I'm mapping to
18:30:02 <tombert> *it can't match the record I'm mapping to
18:31:07 <tombert> is there a way to have a capital letter for a record property
18:32:33 <jle`> for the name of a field? no
18:32:37 <dmj`> tombert: no, you should use camel case
18:32:48 <dmj`> tombert: upper case is reserved for data / type constructors
18:33:00 <tombert> That's fine; I'm just curious if there's a workaround
18:34:35 <dmj`> tombert: nothing against the json package, but aeson is pretty standard in haskell these days, not to deter though
18:34:43 * hackagebot chalk 0.1.0.1 - Terminal string styling.  http://hackage.haskell.org/package/chalk-0.1.0.1 (cattheory)
18:34:58 <dmj`> @package aeson
18:34:58 <lambdabot> http://hackage.haskell.org/package/aeson
18:35:02 <pharaun> fryguybob: yeah xeon phi
18:43:33 <SrPx> johnw: are you sure I can do the recursive loop on accelerate?
18:45:51 <johnw> no, I'm not sure
18:46:12 <SrPx> johnw: my bad :(
18:49:41 <tombert> Ok, I figured out my issue; It's not about capital letters; the issue is that sometimes the field is null in the JSON
18:49:44 * hackagebot quantfin 0.1.0.2 - Quant finance library in pure Haskell.  http://hackage.haskell.org/package/quantfin-0.1.0.2 (tdees)
18:50:02 <tombert> I tried using a Maybe, but apparently that's not supported
18:58:29 <tombert> is there a way in Haskell records to allow a field to have multiple types?
18:58:43 <arkeet> what do you mean by multiple types?
18:58:54 <enthropy> data X a = X { fieldWithTypeA :: a } -- not this?
18:59:23 <tombert> like, something to the effect of data MyRecord  = MyRecord { myField :: (Type1 | Type2)}
18:59:34 <arkeet> use Either?
18:59:35 <geekosaur> you need to create that as a separate `data`
18:59:42 <geekosaur> or use Either, yeh
18:59:59 <geekosaur> I do wonder about "Either blindness" sometimes though
19:00:00 <tombert> Either might work; does it allow me to mix types?
19:00:51 <mniip> @src Either
19:00:51 <lambdabot> Source not found. Just try something else.
19:00:57 <mniip> dang
19:01:05 <arkeet> data Either a b = Left a | Right b
19:01:10 <mniip> ^
19:10:41 <navaati> hi
19:11:09 <navaati> i'm using haskell-mode and the doc says to customize the variable haskell-mode-hook, but there is no such customize option
19:11:11 <navaati> any idea ?
19:11:28 <jle`> tombert: if you have something of type 'Either Int Bool', then you can have `Left 5`, `Right True`, `Right False`, `Left 100`, etc.
19:11:31 <jle`> tombert: it's a "tagged union"
19:11:41 <jle`> so to process it you have to handle both possible cases (left or right, int or bool)
19:12:18 <jle`> :t [Left 3, Right True, Right False, Left 100, Right True, Left (-10)]
19:12:19 <lambdabot> Num a => [Either a Bool]
19:14:21 <mniip> I# 3#
19:14:32 <mniip> I mean, '3 :: Int' :P
19:15:33 <navaati> :t I# 3#
19:15:34 <lambdabot>     Not in scope: data constructor ‘I#’
19:15:35 <lambdabot>     Perhaps you meant ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
19:17:31 <mniip> navaati, nevermind me, those are things internal to the compiler
19:18:39 <mniip> (try {-# LANGUAGE MagicHash #-} and then import GHC.Types)
19:19:00 <yawakasi> hi - I'm writing a simple web application to deploy to heroku using scotty and I'd to use postgres as my database. What's the best library to do so?
19:19:30 <yawakasi> "best" for me would mean simplicity and typefulness
19:20:21 <navaati> mniip: yeah, primitives. just wanted to see if it was in lambdabot ^^
19:20:44 <navaati> yawakasi: Yesod, I guess ?
19:21:13 <yawakasi> navaati: yesod is a whole framework so not really "simple", no?
19:21:51 <Denommus> yawakasi: depends on what you consider to be simple 
19:22:08 <Clint> yawakasi: persistent, depending on what you need to do
19:22:56 <bergey> navaati: I think they mean to write some elisp.  Something like (add-to-list 'haskell-mode-hook 'haskell-indentation-mode) should work.
19:23:14 <mniip> navaati, nah, too fragile
19:23:29 <mniip> any sandbox can be escaped with a careful enough unsafeCoerce#
19:23:51 <mniip> well, ghc runtime level sandboxes
19:24:06 <mniip> of course you could add ptrace, vm or virt layers on top of that
19:24:12 <Denommus> yawakasi: esqueleto is cool 
19:24:15 <mniip> I don't think lambdabot does any of those
19:25:03 <yawakasi> what are the pros and cons of persistent and esqueleto?
19:25:40 <yawakasi> it looks like esqueleto run on top of persistent
19:26:14 <johnw> that's right
19:26:19 <Denommus> yawakasi: esqueleto provides a composable DSL for queries 
19:26:19 <johnw> you can use esqueleto and persistent together
19:26:37 <Denommus> yawakasi: there's also opaleye
19:26:54 <Denommus> yawakasi: which offers an arrow interface for queries 
19:28:02 <jle`> esqueleto is meant to be used with persistent
19:28:19 <johnw> i'm pretty sure it has persistent as a dependency
19:28:38 <jle`> this question is like asking to compare haskell and persistent
19:28:42 <jle`> :)
19:28:51 <jle`> persistent is a library written for haskell usage
19:29:06 <athan> Most parsers like to "forget" about the location of tokens found, right?
19:29:28 <athan> so it would be hard to take a found token, and see if another token preceeds it?
19:29:29 <jle`> esqueleto was written to be used with persistent, to accompany it
19:29:45 <jle`> like an iphone and an iphone app
19:29:46 <athan> Denommus: ooh!
19:30:18 <Denommus> athan: wat
19:30:29 <athan> the opaleye thing
19:30:35 <athan> thingy*
19:30:45 <Denommus> athan: ah, arrows are cool 
19:31:15 <yawakasi> aren't they a flawed presentation of bicartesian closed categories or something?
19:31:28 <athan> Denommus: I just found out about kan extensions so my brain is leaking out my eyes when I think about arrows :\
19:31:29 <yawakasi> I remember conal criticising them in a talk
19:32:28 <navaati> yawakasi: you mean that arrows are just categories with a product ?
19:32:42 <geekosaur> more or less. arrows went in two different directions, Control.Category and Applicative
19:33:03 <Denommus> athan: arrows are not that hard to understand, especially when you use pen and paper 
19:33:03 <geekosaur> it was trying to be a weird combination of the two and failed, or something like that
19:33:05 <johnw> and nowadays Profunctor too
19:33:42 <athan> johnw: Is an end just a universal profunctor? :|
19:33:45 <athan> (sorry)
19:34:11 <athan> end a ~ forall a. Profunctor p => p a a?
19:34:36 <johnw> I'm not so sure about that...
19:34:42 <athan> ._.
19:35:07 <athan> thanks johnw
19:36:15 <navaati> hey, what is the extension that permit pattern matching on the result of a function again ?
19:37:02 <johnw> ViewPatterns
19:37:22 <navaati> yeah, thanks :)
19:37:48 <navaati> (I've not done haskell for a long time, it's quite pleasant to go back to it)
19:38:37 <dfeuer> ping carter, carter_cloud 
19:38:58 <carter_cloud> Sup.
19:40:07 <dfeuer> carter_cloud, PM.
20:18:27 <Bashmetim> foldr1 f xs = foldr f (last xs) (init xs)
20:18:39 <Bashmetim> Is that right?
20:20:00 <johnw> @src foldr1
20:20:00 <lambdabot> foldr1 _ [x]    = x
20:20:00 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
20:20:00 <lambdabot> foldr1 _ []     = undefined
20:20:38 <felixn> hey all, how do I import a local module in my dir?  I keep getting "Could not find module".  I usually do ":load", but they doesn't seem to work with "-fdefer-type-errors"
20:20:50 <kern_chicken_pan> dcoutts: still around?
20:21:34 <arkeet> > foldr1 f [a,b,c]
20:21:35 <lambdabot>  f a (f b c)
20:21:46 <arkeet> > [a,b,c] & \xs -> foldr f (last xs) (init xs)
20:21:47 <lambdabot>  f a (f b c)
20:22:00 <arkeet> hm, could have used let/in
20:25:23 <felixn> oh nvm, it was working, I had an issue with a naked definition
20:25:44 <arkeet> -fdefer-syntax-errors
20:30:10 <Pamelloes> Is there a way to exit a forever loop?
20:30:16 * mgsloan wants -fdefer-scope-errors
20:30:18 <StoneToad> forever loop?
20:30:47 <Pamelloes> forever :: m a -> m b
20:32:09 <KaneTW> no
20:32:27 <KaneTW> well, you can throw an exception
20:32:34 <KaneTW> but nothing sane
20:32:35 <heatsink> There is no way to supply the return value of the forever loop.
20:32:50 <johnw> not that we've seen yet
20:33:01 <mniip> Pamelloes, you could write your own forever
20:33:08 <mniip> that has an exit condition
20:33:36 <Pamelloes> I did, but it was working weirdly.
20:33:38 <mniip> m (Maybe a) -> m a
20:33:40 <mniip> or something
20:33:56 <Pamelloes> Turns out I screwed up my conditional. Things are working now.
20:34:08 <dzack> Anyone happen to know of any particularly good ways to go about learning how to work with acid-state?
20:35:00 <kristof> What is that, a database thing?
20:35:20 <kristof> Just learn how to use Haskell's STM :)
20:35:51 <dzack> kristof: yep, it is
20:36:17 <dzack> Ah so what's STM? haha
20:36:44 <kristof> dzack: A way to manage state in an atomic, transactional way.
20:37:37 <kristof> dzack: Think of it as a little box you can read and write to in a concurrent environment, but if you do stuff with its value and it has changed since you started using it, you retry the operation.
20:38:37 <kristof> dzack: Using stm in a software module will give you the aci in acid.
20:39:12 <kristof> dzack: Transactions are atomic (all or nothing), consistent because of the retrying, and independent since you can have lots of little "boxes"
20:41:13 <Chobbes> I'm having problems with this buildExpressionParser example... I just have the imports and the example and all that happens is a mountain of type errors. https://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Expr.html
20:41:39 <Chobbes> I have Parsec 3.1.9, so it's the same version. I'll get a paste of the errors in a sec.
20:42:35 <dzack> kristof: I see! Currently reading up on it as well
20:43:29 <Chobbes> I did notice that my parens has type GenTokenParser s u m -> ParsecT s u m a -> ParsecT s u m a, but in the docs it's forall a. ParsecT s u m a -> ParsecT s u m a?
20:45:20 <lpaste> Chobbes pasted “No title” at http://lpaste.net/1744557669152194560
20:45:50 <Chobbes> Those are the errors that I get for that example, and I'm really confused. Anybody have any ideas? :|
20:46:35 <dzack> Oh nice, and I found that Real World Haskell has a whole section on STM - guess I'll go through that bok next :)
20:59:59 <Chobbes> How does the forall extension work across modules if you don't have it enabled in GHC?
21:00:59 <c_wraith> Chobbes: which of the 3 (or more) extensions that enable that syntax do you mean?
21:01:36 <c_wraith> Actually, I can think of at least 6 extensions that enable that syntax, though 3 of them are synonyms for the same feature.
21:02:31 <Chobbes> c_wraith: PolymorphicComponents, I think.
21:02:49 <dmwit> Chobbes: Everything in GHC is secretly part of a language with a much richer type system than Haskell's.
21:02:58 <c_wraith> Chobbes: ok, that one is a synonym for Rank2Types and RankNTypes
21:03:00 <dmwit> Chobbes: So there's no problem mixing and matching extensions across modules.
21:03:24 <c_wraith> Chobbes: for that one, you can use things that required that extension to write from a module without the extension enabled
21:04:13 <Chobbes> I'm really confused about why my types are differing from the ones here: 
21:04:21 <Chobbes> https://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Token.html#
21:05:57 <Chobbes> For instance it says reservedOp :: String -> ParsecT s u m (), but I actually get reservedOp :: GenTokenParser s u m -> String -> ParsecT s u m ()
21:07:17 <kadoban> Chobbes: Those are fields in a record type. It's kinda confusing, but yeah the type you see is … the type of the record field, which is synonymous with a function that takes the full type and deconstructs it, giving you just that field.
21:07:54 <kadoban> So if you have: data Blah = Blah {something :: Int}  -- then     something is actually  :: Blah -> Int
21:08:36 <kadoban> It's the same as    data Blah = Blah Int, except it automatically creates the 'something' function and lets you use record syntax and such.
21:09:08 <Chobbes> Oh! Right, I see :). Sorry, bit rusty >_<.
21:09:55 <Chobbes> I was reading it as a GADT and got really confused.
21:10:31 <kadoban> Ahh. Yeah I find it somewhat confusing too when I haven't seen it in a bit. It's like the only time in plain haskell that the type you see specified is kind of … not the whole story, or something.
21:11:17 <tejon> Any aeson wizards around?
21:11:47 <arbn> No, but we'd like to hear your question anyway.
21:12:11 <solidus-1iver> hey all, how do i tell what version of base is current?
21:12:26 <c_wraith> I once cast level 3 aeson at some data coming over the wire.
21:12:49 <dmj`> tejon: sure
21:12:50 <c_wraith> solidus-1iver: For what purpose?
21:12:52 <tejon> Didn't say aeson archmage so that's definitely good enough. ;)
21:12:56 <Chobbes> kadoban: so, then this example must be incredibly out of date because I don't think reservedOp makes any sense there anymore? https://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Expr.html
21:13:19 <Chobbes> Unless maybe they expect it to be defined somewhere else as something different?
21:13:22 <solidus-1iver> c_wraith: i'm starting a new project and am making up the cabal file, i want to just use the most recent version of base that is applicable
21:13:30 <c_wraith> solidus-1iver: I mean, https://hackage.haskell.org/package/base is an option.  But remember that you can't upgrade base - it's fixed to your version of GHC.
21:13:32 <solidus-1iver> c_wraith: but it seems like a good idea to lock base in
21:14:41 <tejon> I'm trying to parse search results (Algolia if anyone's familiar), and ignoring everything else for the moment I've got { "hits": [ ...
21:15:55 <kadoban> Chobbes: Maybe not? It doesn't seem to make sense to me either.
21:16:00 <tejon> And I'm trying to get the list of individual hits (which I have created a type for, Question, and that has a FromJSON instance as well).
21:16:02 <eacameron1> Can you tell cabal to use a specific cabal file?
21:16:11 <eacameron1> cabal --file myweirdfile
21:16:21 <Chobbes> kadoban: well that's a relief. This made me very grumpy today ;).
21:16:26 <tejon> So I have this:
21:16:30 <tejon> newtype Search = Search { questions :: [Question] } deriving (Eq, Show)
21:16:37 <tejon> instance FromJSON Search where
21:16:38 <tejon>   parseJSON (Object o) = do
21:16:38 <tejon>     hits <- parseJSON =<< (o .: "hits")
21:16:38 <tejon>     return $ Search hits
21:16:38 <tejon>   parseJSON _ = mzero
21:16:56 <c_wraith> tejon: you should consider using lpaste for this much code.
21:17:02 <c_wraith> @where lpaste
21:17:02 <lambdabot> http://lpaste.net/
21:17:39 <tejon> Good to know but that's it for now. :) The crux of the issue is, I'm getting: when expecting a [a], encountered Object instead
21:18:33 <tejon> And I'm not sure how that's possible, because "hits" goes straight to "[" and not "{" in the json.
21:18:59 <kadoban> Chobbes: Yeah, I haven't really used that part of Parsec, but … ya I don't get it. I don't see another 'reservedOp' or a way the syntax could be making it magically work or something.
21:19:02 <tejon> It's a singleton list because I constrained it to one result, I seriously hope that doesn't mess aeson up.
21:19:14 <dmj`> tejon: what is the type of Search
21:19:19 <dmj`> oh
21:19:20 <dmj`> nvm
21:19:47 <dmj`> tejon: why do you have an extra "parseJSON" in there
21:20:28 <Chobbes> kadoban: reservedOp might have way back been something separate. This was driving me crazy because squinting at it I could see how it might theoretically work, but ugh.
21:20:35 <Chobbes> I'm going to submit an issue.
21:20:56 <tejon> dmj': To parse the raw JSON list into the Question type.
21:21:14 <tejon> Is that not necessary? I'm trying to follow the example at http://the-singleton.com/2012/02/parsing-nested-json-in-haskell-with-aeson/
21:21:39 <tejon> "messages" is handled the same way there.
21:21:42 <dmj`> tejon: lpaste your code
21:21:49 <tejon> K
21:23:09 <dmj`> if you already have a FromJSON instance for Question I don't think it is necessary
21:23:45 <lpaste> tejon pasted “AlgoliaParser” at http://lpaste.net/133033
21:24:15 <tejon> I think I tried it without that first, and had the same error, but let me verify.
21:24:40 <tejon> Should I lpaste the json as well?
21:24:44 <kristof> has anyone ever written a typesafe monad interface in Java?
21:24:49 <tejon> I'm using a static test case.
21:24:50 <dmj`> tejon: yea
21:24:56 <dmj`> d
21:25:41 <c_wraith> kristof: it's theoretically possible in newer versions of java, but you can't write code that abstracts across all monads - just code that uses a specific one.
21:26:03 <lpaste> tejon pasted “AlgoliaSearch test JSON” at http://lpaste.net/133034
21:27:10 <tejon> dmj': the eventual goal is to populate the Result type from pieces from several levels of the data, obviously I haven't gotten there yet.
21:28:33 <kristof> c_wraith: What's wrong with an interface that has the two methods Monad<T> returnM(T val) and Monad<S> bind(Function<T,Monad<S>> f)?
21:29:20 <kristof> Oh, you can't require that you end up in the same Monad after a bind
21:29:46 <c_wraith> kristof: also, you can't write something like liftM2, or some other monad-agnostic combinator
21:31:05 <kristof> c_wraith: How does liftM2 in Haskell know what kind of monad to promote a function to? Type inference?
21:31:23 <tejon> dmj': I do get the same error when the extra parseJSON is removed.
21:32:26 <tejon> I'm assuming the error must be coming from the Search instance... could it be bubbling up from below?
21:33:37 <tejon> In fact hmm...
21:34:09 <dmj`> tejon: you can ignore fields
21:34:14 <dmj`> tejon: (o .: "revision" >>= (.: "title")), why do this
21:34:37 <tejon> Actually I just solved it, my problem was NOT doing that on the subsequent line.
21:34:48 <tejon> That's because Title is a subfield of Revision
21:34:51 <jle`> omg calling arbitrary C without FFI or wrappers
21:35:21 <dmj`> tejon: oh I see what you're doing
21:35:22 <tejon> And the actual list of viewpoints is actually viewpoints .: children, not viewpoints itself.
21:35:42 <jle`> @hackage inline-c
21:35:42 <lambdabot> http://hackage.haskell.org/package/inline-c
21:35:48 <jle`> this is going to change the world
21:35:50 <tejon> Either was propagating from downstream, just like it's supposed to. :P
21:36:21 <dmj`> tejon: you can do do parseObject (Object o) = do { obj1 <- o .: "obj1"; x <- obj1 .: "field"; return (MyType x) }
21:36:39 <dmj`> instead of this syntax, (o .: "revision" >>= (.: "title")) 
21:36:55 <Chobbes> jle`: ... What?
21:37:13 <tejon> Chobbes: https://www.fpcomplete.com/blog/2015/05/inline-c
21:37:17 <jle`> i know right
21:37:20 <tejon> I was crazy excited when I saw that too. :D
21:37:51 <jle`> imagine a world without FFI
21:38:51 <tejon> dmj` (oh heh, that's a backtick on your name): I figured I could do that, but like I said, I'm working from an example on this and wanted to stay as close to it as possible until it actually works. :)
21:38:59 <Ralith> jle`: what I want to know is, why didn't they do C++?
21:39:14 <tejon> Ralith: They talk about that. It's a goal, but a lot more work.
21:39:18 <Ralith> ah, cool
21:39:33 <Ralith> I'm not sure I see why it's a lot more work
21:39:37 <Ralith> unless they're writing their own parser in haskell
21:39:38 <lethjakman> C++ instead of haskell?
21:39:43 <Chobbes> This feels dirty...
21:39:44 <Ralith> where do they talk about it?
21:39:56 <Ralith> I see no mention of C++ in the readme
21:39:57 <jle`> for a lot of applications C libraries are really the maximum return
21:39:59 <lethjakman> why would you want to do that?
21:40:07 <jle`> Ralith: see the link that tejon posted
21:40:13 <Ralith> ah
21:40:58 <tejon> lethjakman: It's about binding to libraries that poor fools elsewhere wrote in C.
21:41:18 <Ralith> tejon: I remain unconvinced that it should be much harder--all of the hard things about dealing with C++ go away if you're using a C++ compiler and only speak C ABI across the boundary.
21:41:59 <tejon> Ralith: Well they openly beg for contributions in the blog post. If it's so easy, lead the way! :D
21:42:43 <dmj`> tejon: also, one helpful hint, use the `typeMismatch` function in aeson, let's you specify more intelligent errors in your FromJSON instances, instead of mzero, typeMismatch o = typeMismatch "Invalid type for Search" o
21:43:45 <tejon> dmj`: oh cool, and I assume that would have let me see that the error was happening in the Question instance even though I was only testing at the Search level.
21:43:53 <lethjakman> ahhhh ok, that makes more sense
21:44:09 <lethjakman> I was surprised someone in the haskell channel was suggesting c++
21:44:09 <tejon> Thanks a lot for the pointers, and the time spent staring at my chickenscratch code. :)
21:46:16 <dzack> In cabal, is there a way to automatically rebuild all broken packages?
21:46:34 <arkeet> not really :(
21:47:05 <arkeet> not that hard to do it in 2 steps though
21:49:08 <lethjakman> does (.) just chain a function?
21:49:10 <dzack> Do I just need to pass the individual package namesnto something like cabal --reinstall?
21:49:23 <lethjakman> or does putting it in parentheses give it a different meaning?
21:49:45 <gfixler1> lethjakman: (a . b) x == a(b(x))
21:50:09 <lethjakman> https://gist.github.com/lethjakman/12983f656537608c5352
21:50:15 <Ralith> tejon: would that I had the free time
21:50:39 <lethjakman> I understand chaining, I'm just not positive I understand that typeclass instance
21:51:00 <gfixler1> lethjakman: it's the functor instance for functions
21:51:40 <tejon> Ralith : That's what they all say. ;) Seriously though, it's at the top of /r/haskell, if you have some ideas on how to make it an easier task you could at least post them there.
21:52:42 <Ralith> it's all pretty obvious stuff
21:53:26 <Ralith> emit source of a C++ compilation unit as a byproduct containing all your wrapper code, compile that with a real C++ compiler which makes all the ABI and template concerns magically evaporate, link and invoke as per usual
21:53:37 <gfixler1> > reverse . tail $ "bar"
21:53:39 <lambdabot>  "ra"
21:53:48 <gfixler1> > fmap reverse tail "bar"
21:53:50 <lambdabot>  "ra"
21:53:55 <gfixler1> lethjakman: ^^
21:54:05 <lethjakman> thanks :)
21:54:06 <jle`> instance Functor ((->) r) where fmap = (.)
21:54:12 <solidus-1iver> i'm having trouble initializing a zeromq4-haskell based project
21:54:16 <solidus-1iver> http://lpaste.net/6971096954973454336
21:54:23 <solidus-1iver> i dont get the error, i only have one dependency
21:54:25 <lethjakman> I think I get the compozition though, it's just the (.) that was weird..
21:54:29 <solidus-1iver> but it can't resolve it
21:54:35 <lethjakman> but I think I get it now
21:54:38 <solidus-1iver> what am i dong wrong :?
21:54:43 <lethjakman> is there any reason to put a () around it?
21:54:48 <jle`> instance Functor ((->) r) where f `fmap` g = f . g
21:55:00 <jle`> lethjakman: you need () to use it as a "normal"/postfix function
21:55:02 <jle`> > (+) 3 4
21:55:04 <lambdabot>  7
21:55:12 <jle`> fmap = . is not valid syntax
21:55:28 <jle`> (+) is a function that takes 3 and 4 and gives 7
21:55:33 <jle`> + is how you would use it as an infix operator
21:55:59 <jle`> elem is a function that takes an item and alist and tells you if the item is in the list
21:56:07 <jle`> `elem` is how you use it as an infix "operator"
21:56:10 <jle`> > elem 1 [1,2,3]
21:56:12 <lambdabot>  True
21:56:15 <jle`> > 1 `elem` [1,2,3]
21:56:16 <lambdabot>  True
21:56:18 <arkeet> (.) f g = f . g
21:56:21 <jle`> > (+) 3 4
21:56:23 <lambdabot>  7
21:56:24 <jle`> > 3 + 4
21:56:25 <lambdabot>  7
21:56:43 <pacak> > (,2) 1
21:56:45 <lambdabot>  (1,2)
21:56:51 <pacak> > (1,) 2
21:56:52 <lambdabot>  (1,2)
21:57:14 <pacak> >(1,,3) 2
21:57:24 <tejon> And now I'm at the point in this particular process where I know for a fact my life would be easy if I were to just sit down and grok lens...
21:57:44 <gfixler1> ((->) r) has always felt a bit strange to me
21:58:04 <gfixler1> tejon: you don't need to grok lens to use it
21:58:14 <pacak> tejon:  https://ro-che.info/ccc/images/lens.png
21:58:54 <gfixler1> haskell webcomics? sign me up
21:59:02 <dmj`> tejon: there's lens-aeson, and aeson-lens
21:59:08 <dmj`> @package lens-aeson
21:59:08 <lambdabot> http://hackage.haskell.org/package/lens-aeson
21:59:15 <dmj`> @pacakge aeson-lens
21:59:15 <lambdabot> Unknown command, try @list
21:59:19 <dmj`> hmmmm
21:59:21 <solidus-1iver> shoudlnt cabal install be using a sandbox?
21:59:26 <tejon> @pancake
21:59:26 <lambdabot> Unknown command, try @list
21:59:32 <solidus-1iver> how come i'm getting errors about my systems version of a package, isn't that the point of it
21:59:47 <gfixler1> solidus-1iver: I've been having troubles like that, too, with vty-ui
22:00:05 <solidus-1iver> gfixler1: any solutions work for you?
22:00:07 <rty> Hello folks
22:00:15 <dmj`> @package aeson-lens
22:00:15 <lambdabot> http://hackage.haskell.org/package/aeson-lens
22:00:21 <gfixler1> solidus-1iver: yeah, trying it on another computer (my work PC) - it just worked there
22:00:43 <gfixler1> I don't like not knowing what the haskell-platform entails
22:00:49 <gfixler1> I feel kind of lost when things don't just work
22:01:22 <solidus-1iver> gfixler1: thats really wierd and not something i can do here. huh..
22:01:28 <solidus-1iver> so are cabal sandbox's broken then?
22:01:31 <solidus-1iver> i'm used to...
22:01:38 <gfixler1> it felt like it
22:01:41 <solidus-1iver> cabal sandbox init && cabal install --only-dependencies
22:01:46 <solidus-1iver> and that shouldn't be blocked by system package versions
22:01:49 <gfixler1> solidus-1iver: yep, that's what I do
22:01:49 <solidus-1iver> did the flow change?
22:02:07 <gfixler1> are you adding the dependencies in the cabal file before install --only..
22:02:08 <gfixler1> ?
22:02:09 <solidus-1iver> well, if its affecting us both we should get a bug report out
22:02:19 <solidus-1iver> gfixler1: yeah, theres only one dependency in it
22:02:32 <gfixler1> the first issue was my cabal needed updating
22:02:39 <gfixler1> second was cabal itself was old, so I got the latest one
22:02:44 <solidus-1iver> i'm using 1.22.3
22:02:46 <gfixler1> but apparently there can be some issue with that
22:02:52 <gfixler1> like ghc is tied to cabal or something
22:02:57 <gfixler1> and updating one breaks things
22:03:03 <gfixler1> (not sure - all heresay)
22:03:21 <solidus-1iver> ugh, this is an unfortunate wall to run up against on a project
22:03:29 <solidus-1iver> :P
22:03:32 <gfixler1> indeed
22:03:47 <gfixler1> I was psyched to try out vty-ui, and then spent a couple of days intermittently trying to get it working at all
22:06:00 <rty> hi folks. I am trying to get emacs and haskell to work together on mac osx. 
22:06:25 <rty> Went down this rabbit hole: http://tim.dysinger.net/posts/2014-02-18-haskell-with-emacs.html
22:07:12 <rty> ended up with this message, "cabal: Error: some packages failed to install:
22:07:12 <rty> haskell-hello-0.1.0.0 failed during the final install step."
22:07:35 <rty> The exception was:ExitFailure 1
22:07:57 <rty> Now traced the error down to ghc-mod
22:09:14 <solidus-1iver> yeah i'm using the latest version of cabal-install so this should not be an issue
22:09:21 <solidus-1iver> or at least not one related to cabal
22:09:22 <solidus-1iver> hmmm
22:10:49 <rty> https://github.com/kazu-yamamoto/ghc-mod/issues/437
22:11:05 <rty> red up on this; tried the solutions. But no dice. 
22:11:12 <rty> I don't know what else to do ...
22:11:30 <rty> my hello-world won't print on screen and gives that error. 
22:11:50 <refefer> is there a way to pattern match on and ADT and bind it to a name?
22:12:06 <refefer> something like f (Foo a b) @ foo
22:12:57 <jle`> f foo@(Foo a b) ...?
22:13:04 <rty> I am on mac osx and there is an issue with GHC 7.10 and Cabal 1.22 how do I get out of this pickle and get working on Haskell? 
22:13:19 <jle`> > let f foo@(Just x) = (x, foo) in f (Just 10)
22:13:21 <lambdabot>  (10,Just 10)
22:13:25 <dmj`> rty: I'm using 7.10, osx and 1.22, no issues
22:13:29 <refefer> jle`: lovely, thank you
22:13:50 <jle`> np!
22:15:27 <solidus-1iver> gfixler1 i thought about the problem more and it seems like it might be a problem with a non haskell dependency
22:15:47 <solidus-1iver> but i don't know enough about cabal to reason abou tthat
22:15:55 <solidus-1iver> its the only thing that makes sense at this point
22:19:12 <rty> dmj`: the developer agrees there is an issue. 
22:19:43 <rty> I don't know how else to put it. Many others have used the solution to install ghc-mod. But it fails for me ...
22:32:18 <ARYAN1488> anyone else believe in preserving the sanctity and beauty of purity?
22:32:42 --- mode: ChanServ set +o johnw
22:32:43 --- mode: johnw set +b *!670ac723@gateway/web/freenode/ip.103.10.199.35
22:32:43 --- kick: ARYAN1488 was kicked by johnw (Kicked)
22:32:43 --- mode: johnw set -o johnw
22:32:44 <tzaeru> .. :D
22:33:03 <tzaeru> well that wasn't an extended stay
22:33:03 <johnw> I have a feeling he didn't mean purity the same way that we do
22:33:15 <tzaeru> really? maybe it was about whole grain.
22:33:32 <johnw> to stay, it would have had to be about functions and their inputs and outputs
22:34:11 <liste> rty so were you in the "# compile & run" phase of Create A New Haskell Project ?
22:35:04 <gfixler1> Just looking at this: https://gist.github.com/merijn/77e3fa9757658e59b01d
22:35:40 <gfixler1> I get "Couldn't match type `Int' with `Double'"
22:35:43 <rty> liste cabal install ghc-mod structured-haskell-mode stylish-haskell
22:35:57 <rty> Everything except ghc-mod installed fine. 
22:36:02 <gfixler1> if I comment out either case in mangle, then I get the error shown in the comment
22:36:05 <rty> then i used git to get ghc-mod. 
22:36:11 <rty> installed that one as well. 
22:36:17 <gfixler1> and RankNTypes doesn't solve the initial problem
22:36:17 <rty> installed succesfully. 
22:36:39 <rty> After that, I tried the helloworld part
22:36:46 <rty> I get errors. 
22:37:27 <gfixler1> sorry, RankNTypes does work - I forgot the forall bit :)
22:37:30 <johnw> gfixler1: can I see exactly what you have in the RankNTypes case?
22:37:46 <gfixler1> johnw: I copied verbatim from that gitst
22:37:48 <gfixler1> gist*
22:38:12 <johnw> works here, 7.8.4
22:38:14 <liste> rty how did the ghc-mod install fail?
22:39:18 <rty> cabal: Error: some packages failed to install: ghc-mod-5.2.1.2 failed during the building phase. The exception was: ExitFailure 1
22:39:50 <rty> liste: https://github.com/kazu-yamamoto/ghc-mod/issues/437
22:39:53 <gfixler1> johnw: I get this: http://lpaste.net/133035
22:39:59 <rty> The same issue as descirbed on that url. 
22:40:07 <gfixler1> maybe it's the 7.6.3 difference
22:40:20 <gfixler1> I don't know how to stay up to date with ghci - the ubuntu repo is always behind
22:40:34 <johnw> that's acting as though you're not using RankNTypes
22:40:39 <johnw> try this:
22:40:48 <johnw> ghci -XRankNTypes NoRAnkN.hs
22:41:04 <gfixler1> johnw: this is the first example at the top
22:41:09 <johnw> ah
22:41:12 <gfixler1> I'm wondering why I don't see those errors
22:41:20 <johnw> that could be a 7.6.3 difference
22:41:23 <gfixler1> if I comment out one of the function lines, then it works
22:41:26 <gfixler1> yeah, it must be
22:41:48 <gfixler1> that's an area I'd like to learn more about
22:41:52 <rty> liste: now i moved past that. 
22:42:01 <johnw> what, RankNTypes?
22:42:03 <gfixler1> there seems to be quite a change in how things are solved between ghc versions
22:42:03 <rty> installed ghc-mod using the last comment. 
22:42:44 <rty> liste: I am now at the create a new haskell project stage. 
22:42:51 <rty> I tried, cabal install 
22:42:59 <rty> as instructed. 
22:43:10 <rty> cabal: Error: some packages failed to install:
22:43:10 <rty> haskell-hello-0.1.0.0 failed during the final install step. The exception was:
22:43:10 <rty> ExitFailure 1
22:43:14 <rty> I get this now ...
22:43:18 <gfixler1> johnw: e.g. you get 'Could not deduce (a ~ Int)', and I get "Couldn't match type `Int' with `Double'"
22:43:29 <rty> shigh ... been doing this all day yday and today. I am tired. 
22:43:59 <gfixler1> it makes me feel a bit at the mercy of the compiler
22:44:09 <gfixler1> never sure if I'm seeing an error I should be seeing, or if I need to update, etc
22:44:19 <liste> the hello-world project doesn't seem to use ghc-mod, though, so it's not about that
22:44:37 <johnw> g'night
22:44:42 <gfixler1> night
22:45:30 <rty> liste: ok
22:45:44 <rty> I am now trying to use the halycon route
22:46:22 <rty> It's stuck on, Downloading https://halcyon.global.ssl.fastly.net/osx-10.10-x86_64/halcyon-ghc-7.8.4.tar.gz...
22:46:45 <rty> hopefully, it's just my slow 2 up 2 down internet ...
22:47:38 <adu> halcyon?
22:48:09 <liste> rty did you use defaults+executable when running cabal init?
22:48:21 <adu> ah, https://halcyon.sh/?
22:48:28 <rty> adu yes halcyon
22:48:40 <rty> liste: what do you mean by that? 
22:48:49 <rty> I followed the tutorial word for word ...
22:48:49 <liste> cabal init asked me a bunch of questions
22:49:11 <rty> liste: yes all except the executable question
22:49:24 <rty> I said, give me an executable. 
22:49:28 <liste> yeah
22:57:21 <rty> finally halcyon to the rescue. 
22:57:39 <rty> Hope the ghc-mod developer gets around the fixing the issue. 
22:57:59 <rty> I don't want to be a beginner and go through hell to get my first program to work. 
22:58:08 <rty> I almost gave up ...
23:00:21 <dmj`> rty: what are you trying to do
23:01:33 <liste> yeah, hell is not fun :( I had very strange errors due to my tools (EclipseFP toolchain and cabal) having different version of the Cabal library
23:02:07 <rty> dmj`: just trying to follow this tutorial: http://tim.dysinger.net/posts/2014-02-18-haskell-with-emacs.html
23:02:21 <rty> first I thought it was me and I messed up somewhere. 
23:02:30 <rty> SO went back over the tutorial like 50 times. 
23:02:46 <rty> Then did searches to get to ghc-mod developers page. 
23:02:58 <rty> Tried every solution suggested there, except halcyon 
23:03:06 <rty> Didn't work at all. 
23:03:14 <Cale> Which version of GHC are you using?
23:03:17 <rty> The developer has know about this since january. 
23:03:39 <rty> Cale: I don't know now. Halcyon replaced GHC with something that works. 
23:03:53 <Cale> ghc --version
23:04:00 <dmj`> rty: I don't use ghc-mod, and I use haskell-emacs, works fine
23:04:17 <Cale> Yeah, I would have just given up on that tutorial a long time ago
23:04:39 <liste> nix solved my dependency-hell problems
23:04:47 <liste> I had to tweak the versions a bit, though
23:05:01 <Cale> But then, I don't tend to give a damn about my text editor. If it'll convert tabs to spaces, and it'll maintain the indentation level of the last line when I press the enter key, I'm happy.
23:06:39 <Cale> I don't know what state ghc-mod is in with respect to GHC 7.10.1 though
23:06:53 <Cale> At least, the version of ghc-mod which is on hackage.
23:07:29 <Cale> Maybe the github version would work
23:07:44 <Cale> (I don't really use that stuff though...)
23:07:50 <rty> Em now it's emacs which is messing me up. 
23:08:02 <liste> rty how?
23:08:04 <rty> It says can't find a recipe for auto-complete ... 
23:08:27 <Cale> What text editor do you usually like using?
23:08:36 <rty> I want to use emacs
23:08:38 <Cale> okay
23:08:46 <rty> I am almost through with the tutorial. 
23:09:02 <rty> The final stage is the init.el file ...
23:09:53 <liste> rty does it complain that before you finish the file?
23:10:19 <rty> liste: I am trying to evaluate the init.el buffer as suggested in the tutorial. 
23:10:32 <rty> and I get that error el-get recipe not found
23:11:12 <rty> I then tried M-x el-get-install auto-complete
23:11:14 <rty> same error
23:25:08 <rty> Well, this isn't working at all. 
23:27:55 <liste> rty how does it fail?
23:29:40 <dmj`> rty: don't give up
23:30:36 <rty> says symbol's function definition is void: el-get-executable-find
23:30:51 <rty> I am now removing all the elm files and recompiling them. 
23:33:01 <dmj`> rty: https://www.youtube.com/watch?v=KxGRhd_iWuE
23:34:38 <rty> dmj`: ok I have lambda on the right side. 
23:34:47 <rty> I don't know what to do any more ... 
23:35:03 <rty> Interactive-Haskell is what it says
23:35:28 <dmj`> rty: in your init.el?
23:35:59 <rty> dmj`: no in a buffer of its own. 
23:36:13 <rty> I was in the hello world program. 
23:36:19 * dmwit wonders idly how many uses of Proxy should actually be uses of associated data families
23:36:23 <rty> tried C-c C-l
23:36:46 <rty> it put me in interactive-hasell which really isn't very interactive :)
23:36:55 <rty> just shows lambd>
23:37:04 <dmj`> rty: are you using melpa or marmalade for package mgmt? How did you install haskell-mode
23:39:11 <rty> dmj`: I have the init.el from the tutorial page. 
23:41:08 <rty> el-get is probably what you are expecting
23:41:23 <rty> THe Main.hs shows Haskell AC
23:41:26 <rty> as the mode
23:41:31 <dmj`> rty: ok yea, delete everything in your init.el
23:42:01 <dmj`> rty: let's start simple here ok
23:42:17 <Eiam_> there is a #haskell-emacs channel as well
23:42:19 <Eiam_> (I've found them helpful in the past)
23:43:13 <rty> dmj`: ok
23:43:26 <rty> Eiam_: I tried in there too. Maybe everyone is asleep
23:43:48 <rty> weeee netsplit
23:43:54 <rty> they are rare these days right? 
23:44:15 <unb3k44n7> Hello, room. 
23:44:25 <statusfailed> hello, unb3k44n7 
23:44:39 <unb3k44n7> I'm new here. 
23:44:41 <dmj`> rty: http://lpaste.net/133036, add that
23:44:50 <unb3k44n7> And new to IRC.
23:45:35 <dmj`> rty: then hit M-x and type 'eval-buffer' on init.el
23:45:51 <unb3k44n7> What is this room about?
23:45:56 <dmj`> rty: moving to #haskell-emacs
23:46:10 <dmj`> unb3k44n7: haskell.org
23:47:00 <unb3k44n7> Thanks, dmj.
23:48:43 <unb3k44n7> What is all this ^
23:49:18 <magneticDuck> describe it
23:50:00 <unb3k44n7> The random user names saying they Quit Ping Timeout or (Remote host closed the connection)
23:50:05 <unb3k44n7> I know what a ping is. 
23:50:33 <unb3k44n7> Are they just automatic messages saying someone went idle or something?
23:51:17 <magneticDuck> this channel has 1434 users in it
23:51:31 <magneticDuck> those messages are caused by people joining and leaving the channel
23:51:38 <unb3k44n7> Oh.
23:51:39 <Eiam_> i turn them off in my client since they are just noise
23:51:44 <magneticDuck> you should consider adding some sort of filter
23:51:50 <unb3k44n7> How?
23:51:54 <magneticDuck> all clients support some sort of filters
23:52:00 <magneticDuck> depends on your client
23:53:18 <unb3k44n7> ...I'll look around for it.
23:53:37 <unb3k44n7> I downloaded mIRC to start with.
23:56:40 <rty> em
23:57:12 <unb3k44n7> Hrm.
23:57:20 <unb3k44n7> Haven't found filters yet.
23:58:37 <unb3k44n7> What's a DCC
23:58:38 <Kneiva> unb3k44n7: it might be called "ignore". At least that's how it is done in irssi-client, eg. "/ignore -channels #chan1,#chan2,#chan3 * JOINS PARTS QUITS NICKS".
23:58:48 <unb3k44n7> In Display>Options
23:59:42 <unb3k44n7> I just found ignore user and unignore user
