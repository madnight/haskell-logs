00:00:28 <liste> :t (If (BoolConst True) (BoolConst True) (BoolConst False))
00:00:30 <lambdabot> Ex Bool
00:00:42 <liste> you need -XGADTs for that
00:01:58 <eds> ahh. I see. But when genprog produces a tree at random or performs a crossover it fails to see that If only accepts bool argument. Should I change something in genprog clas?
00:03:22 <eds> XGADTs. I have read about it. I have not implemented it. I should try that.
00:05:22 <liste> not sure how GADTs work with Data
00:06:33 <ThreeOfE1ght> liste: what do you mean by that?
00:06:51 <liste> I mean is it possible to have a Data instance for a GADT
00:07:25 <ThreeOfEight> Ah. Good question.
00:07:40 <liste> eds and I'm not sure how to implement GenExpr for that kind of expression
00:08:33 <liste> how to `exchange' two subtrees of different types?
00:08:58 <eds> yea. I am trying to figure that out. ':-[
00:09:41 <liste> you may need to have a unityped expression language
00:09:50 <liste> not sure, though
00:10:26 <eds> what would that be?
00:10:52 <eds> untyped or unityped?
00:11:17 <liste> you say tomato, I say tomato...
00:11:19 <ThreeOfEight> liste: Data with "proper" GADTs does not seem to work
00:11:51 <eds> lol.
00:12:06 <liste> eds if you don't like using Ints for everything, you could have `data MyDataType = MyInt Int | MyBool Bool'
00:12:08 <eds> I need to check what untyped would be
00:12:46 <eds> But then I fail to make genprog work for me because of the different types
00:13:08 <MarcelineVQ> takeWhile (\x-> x<100000000 && x>100) [1..]
00:13:16 <MarcelineVQ> why does that yield [] ?
00:13:27 <MarcelineVQ> does it short circuit on the first one?
00:13:33 <ThreeOfEight> I don't understand what the problem here is. You want to generate random values for your expressions and are not sure how because of GADTs?
00:13:47 <ThreeOfEight> MarcelineVQ: takeWhile /takes/ elements from the list /while/ the condition holds
00:13:52 <liste> MarcelineVQ check your predicate. on what values would it hold?
00:13:54 <MarcelineVQ> oh of course
00:13:55 <ThreeOfEight> in your case, the condition fails for the very first element
00:14:14 <MarcelineVQ> Appearantly I've failed basic english haha
00:14:20 <ThreeOfEight> It happens. ^^
00:14:43 <MarcelineVQ> I guess I should just use a comprehension to build that list?
00:15:12 <liste> MarcelineVQ why not [100..1000000000] ?
00:15:13 <ThreeOfEight> Well what /do/ you want to do?
00:15:52 <MarcelineVQ> I'm making a list of primes between 10000000 and 100000000
00:16:07 <MarcelineVQ> I already have an infinite primes list from Data.Numbers.Primes
00:16:26 <liste> MarcelineVQ combine dropWhile and takeWhile
00:17:57 <MarcelineVQ> make sense
00:18:00 <MarcelineVQ> *makes
00:23:19 <liste> could `exchange' fail?
00:23:27 <liste> or would it break the algorithm
00:23:39 <liste> I mean leave the subtrees intact
00:24:38 <liste> but that would still not type check :(
00:28:39 * hackagebot sys-process 0.1.5 - A replacement for System.Exit and System.Process.  http://hackage.haskell.org/package/sys-process-0.1.5 (TonyMorris)
00:29:59 <ThreeOfEight> What is exchange supposed to do?
00:30:16 <ThreeOfEight> I mean, obviously, one cannot exchange one subtree with a different one of different type
00:30:26 <ThreeOfEight> that's precisely the point of modelling things with GADTs
00:39:29 <bucaran> any haskellians that are also doing rust here? anything you can say about rust from a haskell perspective?
00:42:04 <Axman6> I'd like to play more with Rust, but I don't have a good need for it at the moment
00:48:40 * hackagebot hindent 4.5.4 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.5.4 (ChrisDone)
00:52:56 <L8D> Are there any good papers/articles that go over the pros and cons of using sum types and using inheritance+dynamic dispatch OOP-style?
00:53:10 <L8D> For example, if I was writing a LISP interpreter
00:53:49 <L8D> I could define the core type like: data LValue = LSymbol string | LNumber Int | LList [LValue]
00:54:05 <L8D> which means I'll have giant case statements all over my code
00:54:16 <L8D> and it'll be that much more work to add an additional constructor
00:54:38 <L8D> the alternative style would be how sum types-like structures are handled in OOP:
00:54:48 <L8D> class LValue a where ...
00:55:25 <L8D> data LType = (forall a. LValue a => LType a)
00:55:29 <tdammers_> L8D: why would you have case statements all over the place? most likely, you'll have pattern-matching contexts where you need them anyway, and you'll want to write a bunch of abstractions that do the nitty-gritty matching for you anyway and then build on top of those
00:55:49 <L8D> (using rank-2 polymorphism for dynamic dispatch)
00:55:55 <liste> L8D http://c2.com/cgi/wiki?ExpressionProblem
00:55:58 <tdammers_> the only really important question is whether you need to add more dispatch cases at runtime or not
00:56:18 <L8D> tdammers_: I would be moving all the 'pattern-matching contexts' into methods on the type class(es)
00:56:23 <tdammers_> also, avoid the existental antipattern ;)
00:57:04 <L8D> tdammers_: existential antipattern?
00:57:21 <arkeet> your rank 2 thing
00:57:22 <tdammers_> using existential quantification just to get runtime polymorphism
00:57:35 <arkeet> @google existential antipattern
00:57:36 <lambdabot> https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
00:57:44 <tdammers_> ^ that
00:58:13 <L8D> liste: is exactly what I'm looking for, thank you
00:58:13 <tdammers_> instead of the instance and the existential quantifier and a wrapper type, you can just wrap your types directly
00:58:37 <liste> L8D there's also a lecture on that: https://channel9.msdn.com/shows/Going+Deep/C9-Lectures-Dr-Ralf-Laemmel-Advanced-Functional-Programming-The-Expression-Problem/
00:58:40 <tdammers_> https://bitbucket.org/tdammers/ginger/src/554bdef38021628fe91c3472daea1407675ec106/src/Text/Ginger/GVal.hs?at=master#cl-82
00:58:50 <tdammers_> ^ here's a real-world example from a template engine I'm working on
00:59:59 <tdammers_> it's pretty much a 1:1 adaptation of OOP polymorphism to Haskell
01:02:04 <merijn> arkeet: existential isn't the same as rank2 and rank2 style polymorphism is actually pretty sensible
01:02:18 <arkeet> sure, I'm just talking about that particular use
01:02:44 <merijn> arkeet: Yeah, but I was clarifying that while existential quantification uses similar syntax it is *not* rank2
01:03:03 <merijn> So referring to it as "your rank 2 thing" is confusing
01:03:05 <arkeet> meh, his words, not mine
01:03:16 <merijn> ah, your line was the first I saw :p
01:03:34 <arkeet> oh I see you joined midway. ok
01:03:34 <liste> can `data LType = forall a. LValue a => LType a' be even called rank-2 polymorphism or just an existential type?
01:04:09 <L8D> liste: existential type
01:04:25 <arkeet> yeah, nothing rank-2 there I guess.
01:04:46 <arkeet> bedtime
01:05:10 <L8D> tdammers_: so the gist is instead of using a type class I should use a record?
01:05:46 <tdammers_> L8D: pretty much, yeah. At least if runtime polymorphism is all you need.
01:06:04 <L8D> tdammers_: but then I can't do things like: parse :: Parser a
01:06:11 <merijn> L8D: Why not?
01:06:18 <L8D> tdammers_: not with using a record
01:06:23 <tdammers_> why not?
01:06:27 <L8D> in the context of writing a lisp interpreter
01:06:41 <merijn> L8D: Why couldn't you do that with using a record?
01:06:57 <tdammers_> your parser can still output specific implementations
01:07:01 <L8D> if I do: class LType a where parse :: Parser a
01:07:16 <tdammers_> where and when you wrap them in the "interface" record type is up to you
01:07:31 <L8D> data LValue = forall a. LType a => LValue a
01:07:40 <L8D> I can implement the parser part
01:07:41 <liste> why not `data LType a = LType { parse :: Parse a }'
01:07:54 <tdammers_> but, anyway, what's your use case for adding instance at runtime anyway?
01:07:59 <L8D> how about:
01:08:10 <tdammers_> it's lisp, the kinds of values you can store in your LValue type are known at compile time
01:08:15 <L8D> if I do: class LType a where parse :: Parser a; eval :: a -> IO LValue
01:08:32 <tdammers_> why the typeclass?
01:08:34 <L8D> along with:
01:08:38 <L8D> data LValue = forall a. LType a => LValue a
01:08:47 <L8D> but if I use the record method
01:08:50 <L8D> like so:
01:09:06 <merijn> L8D: I think the quickest way to convince you will be: Go ahead and try, when you (inevitably) notice the amount of boiler plate required to use existential quantification you can come back and we'll clarify the alternative :p
01:09:15 <tdammers_> :D
01:09:19 <merijn> Trust me
01:09:37 <liste> btw, if you find using records wieldy, try -XNamedFieldPuns
01:10:10 <merijn> I've tried (and seen people try) many times to make existential quantification useful and aside from hackery using typeable and runtime costs in combination with TypeFamilies/GADTs it *never* end up saving boilerplate
01:10:25 <merijn> Unfortunately, it's also impossible to convince people to save themselves time :p
01:10:35 <L8D> data LType = LType { eval :: IO LValue, parser :: ??? }
01:10:42 <tdammers_> really though, the record trick (while exploiting lazy evaluation) instantly turns Haskell into one of the best OOP languages :x
01:10:47 <L8D> data LValue = LValue { eval :: IO LValue, parser :: ??? }
01:10:59 <tdammers_> uhm, not quite
01:11:06 <tdammers_> the parser cannot be a member of the record
01:11:11 <L8D> exactly
01:11:15 <tdammers_> but why would it
01:11:19 <L8D> that's what I mean you can't have the whole 'parser :: a' thing
01:11:28 <tdammers_> you want to determine the instance when parsing, not before
01:11:31 <L8D> tdammers_: so you don't need a giant switch statement in your parser
01:11:40 <tdammers_> you could have a list instead
01:11:50 <L8D> a list?
01:11:50 <tdammers_> a list of parsers, then try them in order
01:11:56 <L8D> I would
01:12:10 <L8D> the implementation of the parser for that type would be defined in that type's module
01:12:14 <L8D> not in my parser
01:12:20 <tdammers_> well, yes
01:12:33 <L8D> I couldn't do that with records
01:12:36 <tdammers_> but you will have to tell your parser that the type exists, one way or another
01:12:48 <tdammers_> you can't do it with existentials either, really
01:13:50 <merijn> ok, let's rewind
01:14:04 <merijn> And start with a simple question: What are you imagining existentials will let you do?
01:14:51 <L8D> merijn: define individual types instead of individual constructors for a sum-like type
01:15:09 <L8D> instead of data LValue = LString String | LNumber Int | ...
01:15:27 <merijn> L8D: And what would you do with those types?
01:15:29 <L8D> I would have data LString = LString string; instance LType LString where ...
01:16:04 <L8D> merijn: write an interpreter
01:16:41 <tdammers_> so what's the type of your interpreter's entry point?
01:17:09 <tdammers_> something like LType a => a -> Interpret a, right?
01:17:21 <tdammers_> (where Interpret is a suitable monad)
01:18:34 <L8D> tdammers_: the parser would be the entry point into the different constructors
01:18:51 <L8D> as in, the parser is the only thing that directly refers to each individual type (like LString)
01:19:04 <tdammers_> so you have a parser that gives you LType a => Parser a
01:19:07 <L8D> everything else would interface through LValue
01:19:18 <tdammers_> and an interpreter that gives you LType a => a -> Interpret a
01:19:27 <L8D> tdammers_: and then another parser that gives you Parser LValue
01:19:35 <tdammers_> aha
01:19:53 <L8D> and everywhere else uses LValue
01:19:56 <tdammers_> so your parser basically just outputs LValue, which is just a wrapper to unify your various LTypes
01:20:13 <L8D> yeah
01:20:29 <L8D> it parses input into an LValue and calls eval
01:21:01 <tdammers_> and in order for your main parser to know all those types, you have to register them all individually and explicitly anyway, right?
01:21:08 <L8D> 'eval' would be a method on the LType class which produces an IO LValue or Interpret LValue
01:21:13 <tdammers_> yes
01:21:25 <tdammers_> but what if it's not a typeclass method, but just a plain old function?
01:21:25 <L8D> tdammers_: yes I would register them individually and explicitly
01:21:44 <L8D> tdammers_: and that's the only play I would explicitly reference the individual types
01:22:05 <L8D> tdammers_: if it was a plain old function then it would have a big case statement
01:22:09 <tdammers_> no
01:22:21 <L8D> what do you mean?
01:22:35 <L8D> the implementation behind 'eval' is specific to the type behind LValue
01:22:52 <L8D> you need to specialize for each type
01:22:53 <tdammers_> registerType :: (IO LValue) -> (LValue -> IO LValue) -> LType -- LType being a record type
01:23:42 <tdammers_> although 'register' isn't the right name, really
01:23:45 <L8D> tdammers_: what do the first and second parameters represent?
01:23:53 <tdammers_> a parser and an evaluator
01:24:13 <tdammers_> and the resulting value is your typed value wrapped in the LType "interface"
01:25:10 <L8D> tdammers_: do you mean: Parser a -> (a -> IO LType) -> LType
01:25:16 <ttt_fff> waht's a badass haskell-ish name (like listM or maybeM) domain taht is not taken ?
01:25:30 <tdammers_> yeah, I dumbed Parser down to IO for the sake of simplicity
01:26:12 <tdammers_> or you could just have a suitable wrapper function for each type
01:26:25 <tdammers_> and have that as the only method in a ToLType class
01:26:38 <tdammers_> class ToLType a where toLType :: a -> LType
01:26:50 <liste> ttt_fff there's a bulk lookup option on namecheap.com
01:27:23 <liste> just dump Control.Monad or Prelude there or something
01:28:46 <ttt_fff> intenius
01:30:43 <L8D> data LValue = LValue { eval :: IO LValue, repr :: String }
01:31:02 <L8D> class IsLValue a where toLValue :: a -> LValue
01:31:08 <L8D> data LString = LString String
01:31:50 <L8D> instance IsLValue LString where toLValue (LString s) = LValue (return s) (show s)
01:32:03 <L8D> parser :: Parser LValue
01:32:36 <L8D> wait no
01:33:03 <L8D> makeParser :: IsLValue a => Parser a -> Parser LValue
01:33:07 <L8D> parser :: Parser LValue
01:33:32 <L8D> parser = makeParser parseLString <|> makeParser parseLNumber <|> ...
01:33:41 <L8D> tdammers_: something like that?
01:37:34 <tdammers_> L8D: yeah, except you can abstract it a little, using a fold over a list of parsers instead of writing out all the <|
01:37:36 <tdammers_> >s
01:41:08 <L8D> tdammers_: true
01:43:34 <tdammers_> anyway, the existential stuff you had in mind feels like it would make things more elegant, but it really doesn't\
01:52:07 <lpaste_> abh pasted “Strictness annotation causing segmentation fault” at http://lpaste.net/134955
01:52:31 <abh> hi, can someone help me with this ^
01:53:25 <merijn> That sounds...unlikely
01:54:03 <merijn> A strict existential? o.O
01:54:20 <abh> is there something wrong with it?
01:54:28 <abh> and why does it cause segfault
01:54:28 <merijn> abh: I never even contemplated that
01:54:45 <merijn> abh: I don't really know why it causes a segfault, sounds like a GHC bug
01:55:10 <merijn> abh: However, I'd like to point out the usual "you probably shouldn't be using existential quantification" complaint
01:55:19 <abh> well, i admit, i dont know why i'd need a strict existential, i just put the bang on all fields of data
01:55:56 <merijn> abh: Why would you do that? Putting bangs on all fields is a bad idea unless you understand why you're doing it
01:56:07 <L8D> abh: probably because GHC doesn't know how to properly strictly create a dispatch table?
01:56:14 <abh> merijn: why is that?
01:56:23 <L8D> abh: it can cause problems like this
01:56:24 <abh> i am sort of new to haskell
01:56:54 <merijn> abh: Because strictness can never reduce work, it can only increase work done by doing useless computation
01:57:02 <abh> i never read anything telling me not to put bangs on existentials
01:57:14 <merijn> abh: I'm refering to bangs in general
01:57:22 <L8D> abh: did you ever read anything that told you to put bangs everywhere?
01:57:23 <abh> merijn: that makes sense
01:57:29 <merijn> I don't know why it breaks with existentials, but blindly putting bangs everywhere is bad too
01:57:47 <abh> L8D: i think i did :P
01:57:49 <merijn> abh: The only reason to add strictness is to avoid a spaceleak ala foldl
01:58:07 <merijn> abh: In all other cases bangs just make things "worse"
01:58:29 <abh> so what is the right way to use bangs?
01:59:07 <merijn> abh: Use them to avoid space leaks caused by computations you know for sure you need anyway, ala foldl vs foldl'
01:59:07 <L8D> abh: don't use them by default. Add them in specific places when you are doing optimizations later
01:59:13 <merijn> abh: I recommend reading https://hackhands.com/guide-lazy-evaluation-haskell/
01:59:28 <abh> merijn: thanks, i'll read it
01:59:50 <abh> what about the segfault? should i report it as a bug on ghc?
02:00:09 <L8D> tdammers_: what if I used type classes but still avoided existential types?
02:00:15 <merijn> abh: Check whether there is a bug for it, if not report it on trac
02:00:31 <abh> merijn: ok
02:00:40 <abh> thanks merijn and L8D 
02:00:46 <L8D> tdammers_: instead of data TValue = TValue { eval :: IO TValue, repr :: String }
02:01:03 <merijn> abh: As for how to do things like existential quantification without the mess of EQ, check this blog
02:01:12 <merijn> @google Gabriel Gonzalez Scrap Your Typeclasses
02:01:12 <L8D> or data TValue = forall a. IsTValue a => TValue a
02:01:14 <lambdabot> http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
02:01:14 <lambdabot> Title: Haskell for all: Scrap your type classes
02:01:23 <abh> ok
02:02:02 <L8D> tdammers_: it would be: data TValue = TValue { _eval :: IO, _repr :: String }
02:02:20 <L8D> tdammers_: with a TType class that defines normal eval and repr
02:03:06 <L8D> tdammers_: instead of IsTValue, toTValue would have type TType a => a -> TValue
02:03:22 <L8D> tdammers_: in cases where I know what type I'm dealing with somehow, I can still use the normal methods on it
02:03:38 <L8D> data TString = TString String
02:04:18 <tdammers_> yes
02:04:26 <L8D> instance TType TString where eval = return; repr (TString s) = show s;
02:05:04 <L8D> and makeParser :: TType a => Parser a -> Parser TValue (which uses toTValue)
02:05:12 <L8D> tdammers_: would there be any inherit antipatterns in that?
02:05:22 <merijn> L8D: Just try it
02:06:07 <solatis> hmm is this a correct place to discuss some high level design problem i'm struggling with ?
02:06:17 <solatis> or shall i take it to #haskell-beginners
02:06:19 <L8D> solatis: go ahead
02:06:30 <L8D> solatis: it'd probably be better here than there IMO
02:06:35 <solatis> ok, i'll try to keep it as short as possible
02:07:46 <solatis> i am using `persistent`, `persistent-sqlite` to be precise. this helps in defining the "model" part of my application. now, I want to "monitor" the database for changes, and execute a function each time a new object is created inside the database.
02:07:58 <solatis> i realize i'm thinking very OOP
02:08:14 <solatis> so i was wondering what the more functional aproach to this would be. continuations ?
02:09:08 * tdammers_ mumbles something about FRP
02:09:09 <solatis> or shall i just create a separate, smart constructor that triggers the function each time it is called ?
02:09:35 <L8D> solatis: that is probably the best option
02:09:36 <solatis> tdammers_: that would mean my continuation hunch was correct ?
02:09:56 <tdammers_> solatis: idk, haven't done any real FRP myself, just sounds like something that would be fitting
02:10:03 <solatis> right
02:10:10 <L8D> solatis: moving the trigger into your 'smart' constructor would make sense if this trigger is related to your business logic
02:10:29 <L8D> I mean the other way around
02:10:46 <solatis> it probably is the most pragmatic and readable solution, too
02:11:23 <L8D> solatis: sqlite in specific doesn't support triggers, and if it did persistent doesn't have an interface for them (I believe)
02:11:49 <solatis> yeah relying on database triggers for this isn't really useful
02:11:51 <tdammers_> one way or another, I'd wrap database access in an API with hooks somehow
02:12:02 <L8D> so it'd be best to manage the triggers in your own code on your own time
02:12:12 <solatis> to be more precise, i am creating "Job" objects, and need a background service to "wake up" as soon as a new Job is created
02:12:34 <solatis> so it makes sense to wrap this in a single call
02:13:01 <L8D> solatis: you'll probably have some monadic action in your system called 'createJob' and you'll put the call to the background service in there
02:13:10 <solatis> yep
02:13:43 <solatis> ok thanks for the feedback and validating my intuition
02:14:32 <L8D> actually sqlite3 does support triggers
02:15:12 <L8D> solatis: if this 'background' job is an external/decoupled system then you might want the database trigger instead
02:15:24 <solatis> nah it's part of the same process
02:15:29 <L8D> but since you're using SQLite its probably very coupled to your system anyways
02:15:45 <solatis> maybe it's wrong to use a background service in the first place.. hmz
02:22:55 <L8D> solatis: if you have some sort of notification system you can use a Channel/Queue
02:23:21 <L8D> solatis: where something is continually sitting on the queue waiting for things to notify it
02:23:28 <L8D> solatis: like doing background jobs
02:24:10 <L8D> solatis: the request handlers don't need to pause either
02:26:06 <L8D> solatis: see http://hackage.haskell.org/package/base-4.8.0.0/docs/Control-Concurrent-Chan.html if you're interested
02:31:09 <[k-> data StorableI a = Storable { ... _sizeOf :: Int } storable'CInt = StorableI { ... _sizeOf = 4 }
02:31:23 <[k-> is this errata I spot?
02:32:52 * [k- runs it to check
02:33:42 <[k-> yes it is!
02:33:44 * hackagebot xml-conduit-parse 0.3.0.0 - Streaming XML parser based on conduits.  http://hackage.haskell.org/package/xml-conduit-parse-0.3.0.0 (koral)
03:01:15 <Walther> Hmm. Network.HTTP apparently doesn't support HTTPS, but wreq seems awfully complicated even for simple things. Any beginner-friendly alternatives?
03:02:07 <Walther> I'm not questioning the usefulness of wreq for advanced users, but the "so you want to do some http? here read our lens api first" isn't something I'd throw at a first-timer
03:02:17 <Walther> s/api/tutorial/
03:03:50 <liste> how about http-conduit ?
03:04:08 <liste> simpleHttp :: MonadIO m => String -> m ByteString
03:04:33 <liste> @hackage http-conduit
03:04:33 <lambdabot> http://hackage.haskell.org/package/http-conduit
03:05:26 <liste> but why MonadIO m => m foo instead of IO foo ?
03:05:31 <Walther> hmm, what's the deal with ByteStrings? Is that really necessary / useful complication of things?
03:05:55 <liste> Walther yes, [Word8] has horrible overhead
03:06:02 <Walther> I'm thinking String
03:06:27 <liste> you can't get a String thru HTTP
03:06:32 <liste> you get [Word8]
03:06:46 <liste> (String == [Char])
03:06:49 <tdammers_> strings are collections of characters. bytestrings are collections of bytes.
03:07:00 <tdammers_> they are not the same thing, and should not be treated as such
03:07:19 <liste> > maxBound :: Char
03:07:20 <lambdabot>  '\1114111'
03:07:22 <liste> > maxBound :: Word8
03:07:24 <lambdabot>  255
03:08:27 <liste> and ByteString is basically [Word8] with much less overhead
03:09:03 <tdammers_> (on a side note, whenever you're using String, you probably want Text instead for anything nontrivial)
03:09:38 <ion> [Word8] is a linked list of bytes, Strict.ByteString is an array of bytes, Lazy.ByteStrict is a linked list of arrays of bytes.
03:10:02 <ion> [Char] is a linked list of Unicode codepoints, Strict.Text is an array of codepoints, Lazy.Text is a linked list of arrays of codepoints.
03:10:19 <tdammers_> conceptually speaking, that is
03:10:55 <Walther> ah, true, because you should be able to retrieve binary files as well over http
03:11:02 <Walther> silly me
03:11:04 <ion> tdammers: I was pretty sure they are literally arrays and linked lists of arrays respectively. Perhaps i’m wrong.
03:11:05 <tdammers_> technically, Text is an array of 16-bit words, wrapped in an API that transparently exposes them as list-like collections of unicode code points
03:11:17 <Walther> The main motivation is I'm writing this: http://walther.guru/one-hour-haskell
03:11:21 <ion> Oh, you meant that part.
03:11:25 <tdammers_> yeah
03:11:53 <ion> Arrays of an encoding of Unicode codepoints. :-)
03:11:53 <tdammers_> but the API is almost entirely transparent, I don't think you'd notice the difference ever except for performance characteristics
03:12:00 <Walther> I'm trying to make a short tutorial of "here's things you probably do daily in your language, here's how to do them in haskell, doesn't that look easy?"
03:12:25 <Walther> and wreq and the lens syntax doesn't quite fit the bill, even if it could be useful in advanced contexts
03:12:27 <taruti> How is accelerate vs repa these days? (going to do some image rasterization things)
03:12:31 <tdammers_> Walther: you mean like Real World Haskell?
03:12:54 <ion> Walther: Recommending things like head needs a big warning.
03:13:10 <ion> “thrice :: Num a -> Num a”
03:13:20 <Walther> tdammers_: something like that, indeed, but shorter and less explaining of the insides / how things work
03:13:35 <ion> That nFibs definition is maximally inefficient.
03:13:37 <Walther> more of a practical one-pager cheatsheet
03:13:53 <tdammers_> Walther: ah, right. that could be kind of useful I guess.
03:13:53 <Walther> ion: what kind of a big warning? About the [] case?
03:14:17 <Walther> tdammers_: in my journeys towards haskell, this is what I would've wanted to see, so be the change you want to see and so on
03:14:17 <ion> Walther: Yeah, generally about not being total and therefore to be avoided.
03:14:39 <liste> in general I feel (and should feel) uneasy when writing partial functions
03:14:59 <ion> Also, the “take n fib” produces a type error, fib is not a list.
03:15:12 <tdammers_> Walther: yes, I totally agree that more beginner learning material would be good
03:15:25 <ion> I recommend writing anything like this as a Literate Haskell document so you can check that the code actually works.
03:15:26 <Walther> ion: I personally think the inefficiency of nFibs implementation isn't a major concern here, I'm not trying to show them an fibonacci implementation but trying to show how simple recursions you can have
03:15:46 <Walther> ion: I've been writing markdown and testing in ghci
03:15:58 <Walther> I should check literate haskell too, thanks
03:16:02 <tdammers_> Walther: btw., have you read this? http://www.stephendiehl.com/what/
03:16:30 <Walther> tdammers_: Ooh, that looks really great source material
03:16:57 <tdammers_> kind of a classic
03:17:11 <Walther> excellent, will read that through to get more ideas
03:17:31 <ion> The obligatory disclaimer: What I Wish I Knew When I Was Reading “What I Wish I Knew When I Was Learning Haskell”: “lens is considered by many Haskellers to be deeply pathological” is considered by many Haskellers to be deeply fallacious.
03:17:34 <[k-> support for lhs should pick up
03:17:51 <Walther> But yeah, so http-conduit could be simple enough while still being useful enough (compared to networking.http not handling https and so on)
03:17:54 <Walther> ?
03:18:05 <Walther> ion: :D
03:18:34 <ion> Walther: Doing this as a lhs document or anything executable would prevent type errors altogether (as opposed to testing here and there in ghci), i have already seen two just by skimming the code.
03:18:52 <Walther> yup, that's a great idea
03:18:56 <Walther> thanks for that
03:19:08 <Walther> what was the other? take n fib and ?
03:19:21 <ion> “thrice :: Num a -> Num a”
03:21:54 <Walther> ahh, it's thrice :: Num a => a -> a
03:22:20 <Walther> first requiring a to be a Num, then specifying it's a function that takes a and returns a
03:23:15 <Walther> Ahhhh, because pandoc is written in Haskell, it obviously has a Markdown + lhs mode. <3<3
03:26:31 <Axman6> how do you specify that a build-depends package in a .cabal file should have certain flags set?
03:47:19 <supki> Axman6: there's no way to depend on flags
03:51:38 <bernalex> supki: wat?
03:51:57 <bernalex> if flag(bleurgh) build-depends: foo, bar
03:52:16 <bernalex> typically
03:52:21 <bernalex> if !flag(bleurgh)
03:52:24 <bernalex>   buildable: False
03:52:25 <ion> bernalex: That’s not the same thing.
03:52:26 <bernalex>   else
03:52:29 <bernalex>     build-depends:
03:52:33 <bernalex>       foo, bar, etc
03:52:46 <bernalex> ion: oh
03:52:53 <bernalex> ion: supki: I misread, sorry!
04:05:08 <Walther> Hmm. Trying to make my .md into a .lhs, I'm running into an issue where headings (lines beginning with # or ## for h1, h2 and so on in markdown) are causing lexical errors when trying to :l from ghci
04:05:22 <Walther> there seems to be a 5 year old bug report about this
04:05:30 * L8D sighs
04:05:38 <L8D> Walther: sorry to hear about that
04:06:24 <L8D> Walther: I don't know if you'll find any help here.
04:06:50 <Walther> hmm, I'm probably not the only one trying to write markdown+lhs though :)
04:06:51 <L8D> If it's a 5 year old bug and no-one found a workaround then you are genuinely screwed
04:07:08 <L8D> most people just use haddoc
04:07:13 <joco42> hamishmack : vagrant worked fin with virtualbox 4.3.28 @ Leksah 0.15.0.0 on ubuntu 12.04 , however on my MacBook pro Retina, Yosemite , the VB 5rc1 approach the failed... did it work on your OSX?
04:07:44 <Walther> https://ghc.haskell.org/trac/ghc/ticket/4836 originally reported 5 years ago, last comment 6 months ago "milestone changed from 7.10.1 to 7.12.1"
04:07:47 <joco42> hamishmack : sorry for the typos... typing on mobile
04:09:02 <Walther> having literate markdown would be awesome - ability to write a document that is neatly compiled into pretty html, and easily tested for errors as a haskell source file
04:09:16 <Walther> unlit just doesn't seem to like #-style headings
04:10:13 <makalu> I have cabal 1.22 something from the package manager. It doesn't work with ghc-mod. Can I install an older version of cabal using cabal? I tried "cabal install cabal-1.20.0.3" but it says all the requested packages are already installed
04:13:33 <arianvp> snoyberg: Hey, how do I define in stack.yaml which version of GHC my project depends on?
04:16:21 <razvanc87> hi all, I'm trying to learn some functional programming with haskell but I'm curious of it's applicability in my field, I'm doing a lot of data processing and plotting (and I come from Python)
04:16:41 <razvanc87> are there any modules mature enough in haskell to do these things?
04:16:55 <razvanc87> multi-dimensional based data
04:17:18 <hodapp> razvanc87: one paper I've read that discusses this is 'beautiful code, compelling evidence'
04:17:26 <hodapp> though I can't recall if it goes to multidimensional stuff or not
04:17:37 <razvanc87> I'll look for it, thanks
04:17:58 <hodapp> there is a book out on this as well; ask shapr about that
04:18:15 <razvanc87> hodapp, that sounds promising, thanks
04:19:15 <razvanc87> so shapr, if you know anything about this let us know, thanks!
04:30:32 <Walther> hmm. with literate haskell, why am I getting one-hour-haskell.lhs:121:3: parse error on input ‘import’
04:30:55 <Walther> relevant code http://walther.guru/one-hour-haskell
04:32:59 <Clint> Walther: how are you converting that to lhs?
04:33:15 <merijn> Where's the source and line numbers?
04:33:52 <hamishmack> joco42: It worked for me in the end on OS X with vbox 5 RC 1.  I had network issues a couple of times and I had to restart it with vagrant provission.
04:34:35 <joco42> hamishmack: ok, thanks, i give it another try later today then
04:36:49 <Walther> Clint: gah, sorry. http://walther.guru/one-hour-haskell.lhs
04:37:03 <Walther> the html is after conversion with pandoc (markdown+lhs)
04:40:45 <merijn> Walther: Easy
04:40:52 <merijn> Your import is in the middle of your document
04:40:59 <merijn> Should've thought of that before
04:41:01 <merijn> That's illegal
04:41:11 <merijn> All imports have to occur before any other declarations
04:41:23 <Walther> Ah, hmm...
04:43:36 <Walther> wonder if I should just go with "use plain markdown and test code manually" then
04:43:46 <Walther> markdown+lhs is proving a bit of a hassle
04:44:29 <Walther> and tutorial-wise, having the regex import at regex subheading makes more sense than having all imports in the beginning of document
04:44:38 <tdammers_> one of the side projects that I might make at some point in the distant future would be a literal programming tool
04:45:29 <Walther> it also rubs me the wrong way a bit that literate haskell is specified as > which is blockquote, instead of ``` or some other codeblock standard
04:45:45 <merijn> Walther: There's tex style too
04:45:54 <Walther> not only because of the semantic overloading but because > is required on every line whereas code blocks are blocks you need at beginning and end
04:45:55 <merijn> \begin{code} code here \end{code}
04:46:05 <Walther> merijn: sure, and that's very useful when you're writing TeX
04:46:18 <merijn> pandoc supports it too
04:46:27 <Walther> yup, pandoc is great
04:46:34 <merijn> at least in rST
04:46:46 <Walther> I just prefer markdown over TeX when typing stuff, when I don't absolutely need some feature from TeX
04:46:57 <breadmonster> merijn: I'm reading the Okasaki book.
04:46:59 <Walther> markdown is imho the least "in the way" in terms of writing the content
04:47:45 <ion> Walther: I wonder if an ihaskell notebook would be useful here?
04:47:48 <breadmonster> And I'd like to implement data structures without exposing the underlying implementation?
04:48:00 <breadmonster> I was thinking there's some sort of type hackery involved.
04:48:17 <merijn> just don't export the constructors?
04:48:21 <breadmonster> Like creating and instantiating a typeclass.
04:48:29 <breadmonster> And then importing the instance.
04:48:34 <breadmonster> But not the functions.
04:48:37 <breadmonster> merijn: oh.
04:48:47 <tdammers_> markdown is also rapidly becoming the go-to language for all sorts of documentation writing
04:50:21 <Walther> yup, and rightfully so
04:50:30 <merijn> Which sucks, because md is horribly underspecified and inconsistent...
04:51:13 <Walther> merijn: well, it's less underspecified and less inconsistent than a lot of the common alternatives
04:51:25 <Walther> which makes it "not perfect, but better than a lot of the competition"
04:51:29 <merijn> rST?
04:51:33 <Walther> which makes it a viable choice, in my opinion
04:53:47 <Clint> cmark improves some of that
04:53:49 <frerich> The existence of AsciiDoc/reStructured Text/MarkDown is somewhat confusing: clearly, there should be a standard ( https://xkcd.com/927/ ).
04:55:13 <[k-> let's all follow github!
04:55:39 <[k-> we should spread consensus that github is defacto standard of md
04:56:32 <merijn> By that logic I should advocate for git too, which I don't either :p
04:57:15 <fgaz> Darcs?
04:57:24 <tdammers_> well, IIRC there is a group aiming to standardize markdown...
04:57:36 <maerwald> darcs doesn't have the developer base of git, so it cannot compete in a lot of areas
04:57:47 <tdammers_> http://commonmark.org/
04:57:50 <tdammers_> ^ here
04:57:58 <Clint> @hackage cmark
04:57:58 <lambdabot> http://hackage.haskell.org/package/cmark
04:58:09 <merijn> Mercurial, because it can atleast interoperate with git so I can remain blissfully ignorant of it's popularity
04:58:40 <tdammers_> so yeah, markdown is kind of shitty, but it's the most promising candidate because it has strong adoption
04:58:41 <maerwald> it's just another git flavor with slightly different UI
05:05:27 <insitu> Is there a way to run a haskell "script" using packages from a cabal file ?
05:05:34 <insitu> something like `cabal run foo.hs` ?
05:05:45 <mniip> is there a way to reduce arity of a type family/synonym so that I could partially apply it
05:09:08 <fgaz> insitu: cabal repl, then :l script.hs should work
05:09:27 <insitu> yes, that's what I do but I  want something not interactive
05:09:29 <merijn> mniip: eta reduction? Otherwise, no
05:09:52 <Walther> hmm. is there any simple https-handling http library for haskell? wreq seems very complicated, and so does http-conduit
05:10:15 <Walther> I'm not questioning the usefulness of either, I'm just looking for something that wouldn't scare beginners away
05:10:35 <supki> insitu: something like  cabal exec -- runhaskell foo.hs  should work
05:10:37 <Walther> Network.HTTP simpleHTTP looks amazingly simple, but it's sadly missing any https functionality
05:12:26 <fgaz> insitu: or cabal repl foo.hs
05:12:54 <supki> Walther: what about http-conduit seems complicated?
05:12:58 <insitu> fgaz: cabal repl script.hs does not work?
05:13:00 <supki> simpleHttp looks pretty simple
05:13:11 <insitu> does not work !
05:13:28 <insitu> supki: neither does cabal exec --runhaskell script.hs 
05:13:40 <insitu> runhaskell seems not to be able to find imports
05:14:44 <supki> insitu: did you install the dependencies?
05:15:24 <insitu> of course. I am in a sandbox... I have a project with a complete application and want to write some snippets/scripts using the library
05:15:28 <fgaz> you could write a script that automatically runs cabal repl, loads the file, runs main then exits
05:15:58 <insitu> fgaz: sure
05:16:57 <supki> insitu: Okay, could you paste the error message?
05:17:17 <insitu> it balks at missing modules
05:18:19 <insitu> it balks at missing modules
05:20:49 <Walther> supki: network.http simpleHTTP is very simple, but can't communicate over https. http-conduit, on the other hand, seems to require an awful lot of extra stuff to work - imports Control.Monad stuff, requires mystical "managers" to "keep track of connections", and so on
05:21:16 <Walther> which is a lot of extra stuff to learn and know for a beginner to just get simple http requests and responses running
05:21:38 <Walther> http://www.yesodweb.com/book/http-conduit the "synopsis" example is quite a handful
05:21:59 <Walther> again, I'm not questioning the usefulness at all, I'm just trying to "keep it simple" for beginners
05:22:06 <Walther> less moving parts, so to say
05:22:17 <Walther> easier to keep track of what happens and why and where
05:23:22 <saurabh> i want to learn haskell and currently working in objective c : can anyone guide me to meaningfull learning resource
05:24:05 <Walther> @where lyah
05:24:05 <lambdabot> http://www.learnyouahaskell.com/
05:24:10 <Walther> @where rwh
05:24:11 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
05:24:26 <saurabh> thanks
05:24:27 <Walther> saurabh: those are quite good resources, for example
05:24:43 <supki> Walther: I mean Network.HTTP.Conduit.simpleHttp
05:24:48 <saurabh> really thank you 
05:25:05 <merijn> saurabh: See also https://github.com/bitemyapp/learnhaskell
05:25:10 <Walther> saurabh: no problem, have fun!
05:25:16 <ion> saurabh: The recommendation of https://github.com/bitemyapp/learnhaskell/blob/master/README.md has exercises as opposed to LYAH and (IIRC) RWH.
05:25:34 <Walther> and if you run into any issues / have any further questions, feel free to ask here
05:25:38 <saurabh> Walther: what type of stuff i can do after learning haskel
05:25:57 <ion> saurabh: What do you want to do? Haskell is a general-purpose programming language.
05:25:59 <joco42> hamishmack : is this vagrant virtual machine also set up to do ghc+webkitgtk style of development for native desktop apps ? or should I install something extra on top of the already installed packages?
05:26:35 <Walther> supki: Huh, there's a simpleHTTP for conduit as well? Sweet, will look into that, thanks!
05:26:35 <Axman6> saurabh: learning Haskell will make moving to Swift much easier btw (you'll see where a lot of the ideas in Swift came from)
05:26:54 <saurabh> okay 
05:27:24 <merijn> Axman6: No it won't, because you'll be all "where are my higher kinded types? :("
05:27:30 <hamishmack> yes and you can make a windows .exe too with `wine cabal install`
05:27:43 <liste> Walther simpleHttp is a function in http-conduit package
05:27:57 <saurabh> haskell is related to mathematics ?  is it necessary to know maths for learning  haskell
05:28:03 <merijn> liste: He's complaining it doesn't do https
05:28:08 <liste> http-conduit does
05:28:11 <merijn> saurabh: I would say "no and no"
05:28:12 <joco42> hamishmack : this is totally awesome ! thanks!
05:28:21 <tdammers_> saurabh: yes, it is related; no, you don't need a lot of math to learn haskell
05:28:24 <Axman6> saurabh: all programming is related to maths
05:28:30 <merijn> liste: Right, but that's too much complexity on top of simpleHttp
05:28:43 <liste> saurabh it's not necessary but you may find yourself learning some math in the way :D
05:28:49 <saurabh> ok : merijin 
05:29:11 <Walther> merijn: if I read right, liste said http-conduit has a subset of stuff labeled as simpleHTTP as well, that compares to network.http's simpleHTTP
05:29:20 <Walther> but does SSL/TLS
05:29:46 <saurabh> A.L.I.C.E  bot is written in haskell ?  
05:30:05 <merijn> http-conduit has simpleHttp :: MonadIO m => String -> m ByteString, but no idea if it does https
05:31:37 <[k-_> i much prefer using :: to specify types rather than : in other languages
05:31:54 <saurabh> merijin : is ALICE bot is written in haskell ?
05:32:03 <Walther> merijn: appears to work
05:32:19 <Axman6> what is ALICE bot?
05:32:20 <merijn> No clue what ALICE bot is
05:32:21 <liste> simpleHttp does do https: http://stackoverflow.com/questions/29778484/haskell-simplehttp-of-network-http-conduit-performing-slowly-for-get-requests
05:32:34 <Walther> awesome!
05:32:51 <liste> (i mean http-conduit's simpleHtt)
05:32:55 <liste> it's slow though
05:33:06 <Walther> that has the benefit of a) getting simple enough examples for beginners b) having the oompf for later heavier lifting when needed
05:33:11 <liste> yep
05:43:51 * hackagebot gtk 0.13.8.1 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.13.8.1 (HamishMackenzie)
05:50:58 <Walther> hmm. with http-conduit, how do I get the response headers?
05:51:07 <Walther> simpleHttp only outputs the body
05:51:43 <Walther> and httpLbs seems to require custom-crafted requests and a manager already
05:52:20 <badmash> hye, have a quick question
05:52:35 <badmash> i have the following code: 
05:53:10 <badmash> let arr = [14, 78, 96, 43, 5231, 896, 757, 31, 29, 156]
05:53:29 <badmash> let max = maximum arr
05:54:13 <badmash> length (filter (==max) arr)
05:54:51 <badmash> how would you write the last line of the code using $ to replace all the brackets?
05:56:08 <fgaz> length $ filter (==max) arr
05:56:30 <fgaz> you can't replace the brackets around ==max
05:57:18 <fgaz> > length $ flip filter arr $ == max
05:57:19 <lambdabot>  <hint>:1:28: parse error on input ‘==’
05:57:30 <badmash> fgaz: yeah, i thought so.  so in general, if one of the arguments to a function is itself another function, you have to have brackets -- correct?
05:57:53 <fgaz> i think it's because == is inline
05:58:28 <KaneTW> badmash: not neccessarily.
05:58:31 <fgaz> > let equals = (==) in length $ flip filter arr $ equals max
05:58:33 <lambdabot>      Couldn't match expected type ‘[a1 -> a1 -> a1]’
05:58:33 <lambdabot>                  with actual type ‘(b0 -> c0) -> a0 b0 c0’
05:58:33 <lambdabot>      Probable cause: ‘arr’ is applied to too few arguments
05:58:57 <merijn> length . filter (==max) $ arr
05:59:07 <fgaz> > let equals = (==) in length $ flip filter [1,2,3,3] $ equals 3
05:59:09 <lambdabot>  2
05:59:15 <fgaz> tada!
05:59:24 <badmash> lambdabot: i am not sure if you are referring to my question.  
05:59:38 <KaneTW> > \arr -> let max = maximum arr, eq = (==max) in length $ filter eq arr
05:59:39 <lambdabot>  <hint>:1:9: parse error in let binding: missing required 'in'
05:59:45 <KaneTW> > \arr -> let max = maximum arr; eq = (==max) in length $ filter eq arr
05:59:47 <lambdabot>  <[()] -> Int>
06:00:00 <KaneTW> > (\arr -> let max = maximum arr; eq = (==max) in length $ filter eq arr) [1,2,3,3]
06:00:01 <lambdabot>  2
06:00:03 <badmash> well, i just pasted the code from ghci
06:00:16 <badmash> ghci doesn't need an 'in' in let
06:00:25 <KaneTW> it's a different in
06:00:35 <KaneTW> a different let
06:00:37 <KaneTW> sorry
06:01:10 <KaneTW> the ghci let is an assignment in scope until you exit ghci
06:01:17 <badmash> yeah
06:01:32 <badmash> code is a copy paste from my ghci repl
06:01:58 <KaneTW> the let x=y in ... makes x available as y in ... in the (...) block
06:02:08 <KaneTW> eh ignore the last 4 words
06:03:22 <badmash> KaneTW: in general, if a function's parameter is an inline call to another function (like ==m), then you have to use brackets and $ will not do -- correct?
06:05:27 <badmash> fgaz: even your last example needs a bracket.  you just can't whack all brackets off with $
06:06:21 <badmash> which is what i was wondering
06:06:44 <joco42> anyone tried the webkitgtk+ghc combination already? i just got a VM up and running for webkitgtk+ghc dev. and i would like to try the " hello world " for webkit+ghc dev., any recommendations? a blog post? git project, anything?
06:07:33 <badmash> fgaz: sorry, i misintrepreted your solution.  you are correct
06:07:37 <badmash> thanks
06:08:17 <fgaz> technically the brackets are still there, but they don't prioritize anything
06:08:27 <lamefun> Uhm... why does Haskell punish for trying to organize the code?
06:11:14 <badmash> 18:38 *** tjbp QUIT Read error: Connection reset by peer
06:12:21 <lamefun> Will the new overloaded record fields also support function overloading?
06:13:30 <merijn> lamefun: No
06:16:02 <badmash> 18:36 <joco42> anyone tried the webkitgtk+ghc combination already? i just got a VM up and running for webkitgtk+ghc dev. and i would like to try the " hello world " for webkit+ghc dev., any recommendations? a blog post? git project, anything?
06:16:31 <Cale> Does anyone else find the entire idea of the OverloadedRecordFields extension ugly?
06:17:05 <e13fter> @help
06:17:06 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:17:11 <lamefun> I do, but I'm just a newbie... Seems to have too much magic in it.
06:17:20 <e13fter> @help list
06:17:20 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
06:17:47 <Cale> I think we're trying too hard to do something which doesn't really make all that much sense to do.
06:17:48 <e13fter> @list Prelude
06:17:48 <lambdabot> No module "Prelude" loaded
06:18:00 <Cale> @listmodules
06:18:00 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
06:18:02 <lamefun> IMO they should instead make it less punishing to create lots of modules.
06:18:12 <Cale> @list quote
06:18:12 <lambdabot> quote provides: quote remember forget ghc fortune yow arr yarr keal b52s pinky brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo nixon farber
06:18:15 <lamefun> like Data.Map
06:18:55 <Cale> lamefun: It's not all that punishing right now. There are some small things which would really help make things a bit better though.
06:19:26 <Cale> Everyone is used to typing import Data.Map (Map); import qualified Data.Map as M
06:19:49 <Cale> That's kind of annoying from the outset, but in the grand scheme of things isn't so bad.
06:20:38 <e13fter> :t "123"
06:20:39 <lambdabot> [Char]
06:20:42 <Cale> What's more annoying about it is that this piece of configuration about how you'd like to use Data.Map can't be shared between all the modules in your project easily, because you can't precisely abstract over a bunch of imports.
06:21:20 <Cale> Or it would be perhaps better still if there were some way for Data.Map to share its recommended view on how you import it somehow.
06:21:41 <Cale> Actually, perhaps it's possible to do that with Template Haskell, but that would be quite hacky.
06:22:39 <Cale> (and probably not advisable)
06:22:52 <badmash> fgaz: one question -- i am trying to understand what you said about $ and brackets.  == is a function, so why can't we write length $ flip filter $ == max, just like we would if instead of == we had some other function, like 'equals' you had defined with let?
06:22:56 <joco42> how can I compile the "Welcome to Reflex" example from this tutorial (https://github.com/ryantrinkle/try-reflex/blob/master/README.md) in ghc+webkit ? anyone tried it already?
06:23:53 * hackagebot fgl-arbitrary 0.1.0.0 - QuickCheck support for fgl  http://hackage.haskell.org/package/fgl-arbitrary-0.1.0.0 (IvanMiljenovic)
06:23:57 <Cale> joco42: I don't recall if I tried that exact thing, but it should work just compiling it with ordinary ghc rather than ghcjs
06:24:01 <fgaz> badmash you can just wrap == in parentheses
06:24:23 <fgaz> *brackets
06:24:34 <Cale> *parentheses was correct :)
06:24:34 <fgaz> whatever they are called
06:24:37 <Thenews> www.VALBOT.com provides domain valuations. Reporting globally on Site Traffic, Pagerank, Malware, WHOIS data, SEO & even Social Media presence.
06:24:41 --- mode: ChanServ set +o Cale
06:24:45 --- mode: Cale set +b *!*@89.46.66.38
06:24:45 --- kick: Thenews was kicked by Cale (Thenews)
06:24:48 --- mode: Cale set -o Cale
06:24:49 <badmash> fgaz: and the reason is?
06:25:13 <Cale> badmash: When you write an infix operator without parens around it, it must be used infix
06:25:15 <joco42> Cale: cool! i try it thanks
06:26:27 <badmash> so let equals = (==) in length $ flip $ filter arr $ equals max  will work
06:26:32 <Cale> badmash: There are special syntaxes (* x) and (x *) which mean (\y -> y * x) and (\y -> x * y) respectively, and writing (*) will turn the infix operator * syntactically into an ordinary symbol.
06:26:44 <badmash> but let equals = (==) in length $ flip $ filter arr $ == max will not work
06:26:57 <Cale> length $ flip $ filter arr $ (==) max
06:27:08 <fgaz> ^
06:27:46 <fgaz> i only used let to make it clear that equals wasn't inline
06:28:34 <Cale> The parens effectively convert the infix operator into an ordinary non-infix name.
06:28:47 <init> looking at FRP libraries, I basically now want to grasp how I could make it fit my irc library, how would/should I handle things like irc messages (sent and received)? (I can't grasp how I would fit it into something that has to be "sent" just once) 
06:28:55 <fgaz> i think you should remove the 2nd $
06:28:57 <badmash> Cale: ) max
06:28:57 <badmash> 18:56 <fgaz> ^
06:29:03 <badmash> 18:56 *** hibern
06:29:07 <badmash> ) max
06:29:08 <badmash> 18:56 <fgaz> ^
06:29:09 <badmash> 18:56 *** hiber
06:29:25 <Cale> badmash: whoa, your IRC client is broken or you accidentally hit paste :)
06:29:41 <badmash> well, accident -- sorry :)
06:29:44 <badmash>  timeout: 252 seconds
06:29:52 <frerich> He's mashing the keyboard. Badly.
06:29:56 <frerich> *badabum*
06:30:09 <badmash> sorry
06:30:29 <badmash> Cale: your last bit code doesn't work -- throws errors
06:30:32 <Cale> init: Well, it depends on the library in question, but generally you'd probably have something like Event IRCMessage for the input, and an Event IRCMessage for the output
06:31:07 <Cale> badmash: Well, I didn't think at all about what it does. I just treated it syntactically. There may be type errors in it :)
06:31:09 <fgaz> badmash length $ flip filter arr $ (==) max
06:32:00 <Cale> :t \arr -> length $ flip filter arr $ (==) max
06:32:01 <lambdabot> (Eq (a -> a -> a), Ord a) => [a -> a -> a] -> Int
06:32:10 <Cale> ^^ that constraint is probably unsatisfiable
06:32:23 <Walther> hmm. Is there syntactic sugar for foo <- doStuff; field foo; to get a single field from resulted object foo without explicitly stating it as a new object?
06:32:25 <Cale> So you won't likely be able to use this piece of code.
06:32:37 <merijn> Walther: fmap?
06:32:40 <Cale> (but it's syntactically valid)
06:33:10 <merijn> "fmap field doStuff" is the same as "foo <- doStuff; return (field foo)"
06:33:23 <fgaz> Cale: max is a variable
06:33:32 <Cale> oh, okay
06:33:36 <Cale> :t \arr max -> length $ flip filter arr $ (==) max
06:33:37 <lambdabot> Eq a => [a] -> a -> Int
06:33:42 <Cale> More reasonable
06:33:48 <maerwald> merijn: well, they use different interfaces
06:34:01 <Walther> merijn: excellent, thanks!
06:34:18 <badmash> well, that piece of code doesn't seem to work
06:34:27 <Cale> :t \arr max -> length $ filter ((==) max) arr
06:34:28 <lambdabot> Eq a => [a] -> a -> Int
06:34:32 <init> Cale: so, with an event for the output, I would have the guarantee that it may not end "repeated"? as in, sending a message twice? 
06:34:36 <Cale> :t \arr max -> length $ filter (== max) arr
06:34:37 <lambdabot> Eq a => [a] -> a -> Int
06:34:44 <Cale> ^^ more idiomatic
06:34:59 <merijn> maerwald: Well, you can use liftM instead of fmap if it makes you happy for some weird reason...
06:35:09 <fgaz> BUT PARENTHESES ARE BAD
06:35:22 <Cale> init: uhh, it would send whatever messages the Event said to send.
06:35:41 <merijn> Especially now that Functor is a superclass of Monad anyway
06:35:43 <Cale> init: If there were repeated messages in the Event, then it would send repeated messages.
06:35:58 <badmash> so with '==' you can't do without parenthesis?  unless of course you write it like fgaz did?
06:36:18 <Cale> badmash: If you want to use == without parentheses, you have to write it in between the two things you want compared.
06:36:27 <maerwald> merijn: my point was that it's not "generally" true that both things are the same, because it might depend on the instances. At least I don't know of any law that says both must be the same
06:36:41 <Cale> x == y  is syntactically valid, and means the same thing as  (==) x y
06:36:41 <mniip> random question
06:36:49 <init> Cale: I think I still haven't got my head around this, will try to just implement it :P
06:36:59 <mniip> why do people write (== x) when (x ==) is more efficient as the syntactic sugar is an eta-reducible lambda
06:37:14 <badmash> i see -- i understand.  but you can write it as (==x)?
06:37:18 <Cale> mniip: Because (x ==) is Yoda-speak
06:37:29 <merijn> maerwald: All existing Functor instance match their Monad and the first person to do something different will be lynched
06:37:41 <Cale> badmash: Yeah, (== y) x and (x ==) y mean the same thing as x == y
06:37:51 <maerwald> merijn: but is it a law?
06:37:52 <merijn> Actually, given parametricity I'm not even sure you can implement a wrong liftM
06:38:05 <merijn> maerwald: Define law
06:38:07 <badmash> Cale: i see
06:38:16 <maerwald> merijn: mathematical law
06:38:17 <mniip> merijn, is it derivable from the monad laws
06:38:20 <maerwald> or from category theory
06:38:20 <mniip> and functor laws
06:39:11 <badmash> Cale: so write (==x) turns it into a partial function?  i am just wondering
06:39:22 <init> partially applied, not partial 
06:39:25 <Cale> mniip: But also, it doesn't eta reduce, per the standard.
06:39:42 <badmash> init: ok, thanks
06:39:45 <merijn> maerwald: Pretty sure, but I can't be arsed to prove it
06:39:45 <KaneTW> maerwald: a monad is a functor in category theory
06:39:51 <mniip> Cale, it will reduce after the typecheck
06:40:01 <Cale> badmash: (== x) is just syntax sugar for (\y -> y == x)
06:40:13 <badmash> Cale: i see
06:40:18 <Cale> mniip: It ought not to, because of interaction with seq...
06:40:31 <mniip> hmm
06:40:45 <maerwald> KaneTW: I am aware of that, but it doesn't say WHICH functor (as in: the instance I defined?)
06:40:50 <badmash> so if i understand correctly, because == is an infix operator, you end up having to use brackets
06:41:09 <maerwald> sure that's nitpicking, but all the monad/functor tutorials I read don't really say much about this
06:41:19 <badmash> i mean in that particular example we are discussing
06:41:30 <merijn> maerwald: There can only be one lawful functor for a type
06:41:37 <merijn> maerwald: That's why DeriveFunctor exists
06:41:42 <Cale> badmash: If you want to refer to the function which an infix operator is on its own, you put it in parens to make it into an ordinary prefix-notation function.
06:41:54 <badmash> Cale: yes
06:42:00 <kadoban> badmash: If you want to use an operator as-if it were a normal function, yes you must use parenthesis.
06:42:12 <mniip> Cale, you wish
06:42:13 <mniip> > ((undefined :: D) ==) `seq` ()
06:42:14 <lambdabot>  *Exception: Prelude.undefined
06:42:22 <merijn> maerwald: So it's unnecessary to specify "which" functor is a prerequisite of being a monad, because there can't be multiple
06:42:46 <mniip> > (\x -> (undefined :: D) == x) `seq` ()
06:42:47 <lambdabot>  ()
06:42:53 <Cale> mniip: hah, bug!
06:42:54 <maerwald> merijn: interesting, this makes me want to write a functor/monad which violates this :D
06:42:55 <merijn> (well, only one lawful one, there's a whole bunch of ones that boil down to putting undefined somewhere)
06:43:09 <maerwald> even though you will lynch me
06:43:30 <Cale> mniip: Probably not all that important a bug. It might even be a good thing overall.
06:43:40 <merijn> maerwald: Feel free to try, parametricity guarantees that any functor that obeys the "fmap id = id" law is the unique functor of that type
06:43:50 <Cale> mniip: But in that case, it's a bug in the Report :)
06:44:19 <merijn> maerwald: If you wanna learn how to prove that, you can start reading Software Foundations ;p
06:44:22 <merijn> @where sf
06:44:22 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages", "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof
06:44:22 <lambdabot> assistant."
06:45:14 <maerwald> merijn: should be piece of cake^^
06:46:35 <Cale> I don't really like the way that SF provides you with a very limited set of tactics for quite a long time, and sort of hides the connection between proofs and programs for quite a while.
06:46:37 <reindeernix> merijn, is that book about proving your program works?
06:46:51 <merijn> reindeernix: Proving properties of programs, yes
06:46:55 <Walther> hmm. response <- withManager $ httpLbs (parseUrl "https://example.com");  fmap statusCode $ responseStatus response; results in "not in scope: statusCode"
06:46:56 <mniip> maerwald, the general idea is that no datatype can have more than one lawful instance of Functor, or Contravariant
06:46:58 <Cale> (Overall, it's a pretty good intro though)
06:47:08 <merijn> reindeernix: Like "my sort implementation always sorts correctly"
06:47:09 <Walther> even if looking inside "response", it's a Status object with a field "statusCode"
06:47:38 <merijn> Cale: Sure, but you can either do "in-depth Coq" or "basic intro into proving", both at the same time seems like it'd get overwhelming
06:47:54 <Cale> Yeah, I guess so
06:48:09 <merijn> reindeernix: Basically it starts with simple functional programming and proving properties about those and then gets increasingly more complicated working towards proving properties for imperative programs
06:48:29 <merijn> reindeernix: The book is free and is literate Coq with examples you can walk through and exercises, it's pretty excellent
06:48:33 <likebaum> Hi
06:48:43 <Cale> I have a weird perspective, because I sort of just woke up one day and realised that I knew how to program in Coq already, after being immersed in functional programming for so many years.
06:48:47 <reindeernix> nice, I might need something like that for next semester
06:48:59 <merijn> reindeernix: Although you really need either vim (+Coquille plugin) or emacs (+ProofGeneral plugin) to use it well
06:49:07 <reindeernix> we have only done some proofs with invariants etc.
06:49:54 <merijn> Cale: Sure, but you're a maths person, so you already understood proof by induction pretty well, I'm guessing. If you've never done a complex proof by induction it's pretty intimidating and knowing 50 different tactics doesn't make it LESS intimidating ;)
06:50:01 <Cale> yeah :)
06:50:40 <badmash> Cale: thnaks,  now i am clear about the whole thing
06:50:53 <badmash> fgaz: thanks a bunch.  
06:51:23 <Cale> merijn: But 'apply' would be among the very first tactics which I gave someone, and SF saves it until much later.
06:52:03 <Cale> merijn: It wants you to do everything with rewriting, which feels way less fundamental to me.
06:52:18 <merijn> maybe...
07:07:24 <solatis> hmmm if i have some long running background jobs i need to manage in haskell, and want to get request feedback about their status, what would be the best way to go ?
07:07:52 <solatis> for the sake of putting it into context, consider for example writing a torrent client and starting the download of a torrent
07:08:08 <solatis> (performance is not much of an issue, correctness is)
07:08:59 <solatis> shall i just make a list with thread ids, and a MVar that contains a hashmap that matches thread ids with some kind of status object ?
07:10:00 <merijn> solatis: There's already a bittorrent client in haskell, maybe check out the source to see how it's implemented?
07:10:33 <solatis> merijn: yeah i was looking at that https://github.com/jlouis/combinatorrent/blob/master/src/Supervisor.hs
07:10:46 <solatis> it implements a complete Erlang-style supervisor
07:12:05 <frerich> solatis: Instead of having a list of MVars with status objects, I would probably have all the threads post status updates to a channel of some sort and have the 'supervisor' thread read those events (and then possibly discard them).
07:12:27 <solatis> frerich: that sounds more elegant
07:13:49 <solatis> frerich: sounds like an actor-like message passing model, right ?
07:13:56 * hackagebot mainland-pretty 0.3.0.0 - Pretty printing designed for printing source code.  http://hackage.haskell.org/package/mainland-pretty-0.3.0.0 (GeoffreyMainland)
07:13:57 <solatis> each thread being an actor
07:14:09 <Walther> With Text.JSON and Text.JSON.Generic, if I have a custom data type and an instance of said data, how can I encode the object into json easily?
07:14:33 <solatis> Walther: what do you mean ?
07:14:41 <frerich> solatis: 'actor' is Erlang vocabulary instead of, say, UML vocabulary? I'm not familiar with Erlang, so I cannot tell, sorry. :-}
07:14:58 <Walther> see the pizza example at http://walther.guru/one-hour-haskell , how could I encode the object as json?
07:14:58 <solatis> Walther: you probably want to implement the FromJSON instance for that custom data type
07:15:37 <solatis> frerich: well Akka is Java/Scala's answer to Erlang's supervisor/message passing, which also uses that terminology
07:15:40 <tdammers_> (or use deriveJSON or generics to have Aeson figure it out for you)
07:15:43 <Walther> solatis: http://stackoverflow.com/questions/17844223/json-parsing-in-haskell mentions that with Generic, I wouldn't necessarily need to implement FromJSON for that custom data type, and it'd probably be simpler if/when someone needs multiple custom data types to not have to implement FromJSON for each of those separately
07:15:51 <solatis> Walther: wait
07:15:55 <Walther> however that SO link deals with decoding, not encoding
07:16:15 <solatis> i have a few projects on github that deal with Aeson and custom data types
07:16:31 <frerich> solatis: For what it's worth, I could think of two issues: 1. the queue of events might grow too large in case the supervisor thread is too slow at handling events. 2. some 'actors' might get blocked too much in case other actors generate too quickly, since accesses to the channel are synchronized.
07:16:34 <c_wraith> Walther: it depends on whether you need to match an existing JSON format, or just serialize your types to JSON somehow
07:16:52 <c_wraith> Walther: if you need to match an existing format, you'll need to write your instance by hand.
07:17:05 <solatis> Walther: https://github.com/solatis/haskell-hexstring/blob/master/src/Data/HexString.hs#L30 would that help you ?
07:17:10 <frerich> solatis: The 'MVar Status' idea doesn't have these issues - it's fixed in size, and each thread can update its status independently. However, the supervisor thread can miss notifications.
07:17:11 <Walther> c_wraith: sure
07:17:27 <frerich> solatis: I.e. I'm not sure which one is better, but I think I'd start with a queue :-)
07:17:31 <Walther> solatis: thanks, will look into that
07:17:45 <solatis> frerich: i understand, *but* .. the amount of jobs / background threads i have is really, really limited, mostly 0 or 1, 2 would be rare..
07:18:08 <tdammers_> you could also write a suitable data type which, when fed to deriveJSON, would yield the desired format, and then do the mapping in the Haskell realm (i.e., map that type to your desired end result type)
07:18:22 <solatis> Walther: https://github.com/solatis/haskell-bitcoin-api/blob/master/src/Network/Bitcoin/Api/Types/UnspentTransaction.hs#L61
07:18:26 <solatis> that one is better actually
07:18:32 <tdammers_> and yet another approach, parse to Data.Aeson.Value, and figure things out manually
07:18:52 <tdammers_> that last one is mostly only useful if your JSON format is highly dynamic and badly-specified
07:19:08 <solatis> i think the last code snippet i linked to is a fairly idiomatic way to parse custom JSON objects with Aeson
07:20:43 <solatis> frerich: i think a queue is the best aproach, since it's the most decoupled aproach, and you can control the size of a queue
07:21:58 <michaelt> Walther: are you using the json package or the aeson package? 
07:24:29 <Walther> I'm looking at both
07:24:40 <solatis> Walther: took a look at that last url i sent you?
07:24:50 <tdammers_> I think aeson is the go-to library
07:24:51 <solatis> using Aeson and Applicative makes for pretty parsers
07:25:34 <michaelt> Walther: aeson has a couple nice examples https://github.com/bos/aeson/tree/master/examples
07:27:56 <Walther> michaelt: hmm. Are those instances required to be manually defined?
07:28:11 <rofer> Anyone have any suggestions about how I go about diagnosing a linker error?
07:28:30 <Walther> isn't there any way to have it in a generic way, where a haskell object's name field is made into a json name field and map values to values and so on
07:28:55 <michaelt> Walther: he demonstrates manual instances, template haskell and generic methods
07:28:56 <geekosaur> sometimes just presenting it here is sufficient (there is for example a ghc 7.10.1 bug that manifests as a specific link time error)
07:29:28 <rofer> I'm working on a program which depends on another library I wrote. I'm getting a linker error related to that library, but I have no idea how to try and see why.
07:29:32 <Walther> ah, there is import GHC.Generics (Generic)
07:30:18 <michaelt> Walther: there are just two examples, Simplest (Generic, TemplateHaskell), and Twitter (with the different ways of getting From/To Json instances in /Twitter
07:30:25 <michaelt> )
07:30:33 <solatis> Walther: that's pretty easy to do
07:31:06 <michaelt> Walther: you can do it manually, which as c_wraith said is what you might want to do if you are matching some pre-given kind of json
07:31:42 <aloiscochard> rofer: so you have A and B, where B depend on A. Is the project B an app/a library or both? because I know one case where you can have linker error
07:32:42 <solatis> rofer: when you get linker errors, try a cabal clean and a cabal build :)
07:32:58 <solatis> linker errors aren't really supposed to happen (i think?)
07:33:25 <solatis> at least, the only reasons i sometimes get them is when i upgrade ghc or mess around with sandboxes
07:33:50 <aloiscochard> you can have error of this kind, if you have a cabal project where you have forget to expose a module in "exposed-module"
07:33:58 <aloiscochard> at least that happened to me
07:34:09 <aloiscochard> hard to know what's wrong with the error message
07:35:15 <rofer> solatis: Already tried that
07:36:06 <rofer> aloiscochard: B is an app and I think the right things are exposed
07:40:26 <Walther> How do I use derivegeneric in ghci? {-# LANGUAGE DeriveGeneric #-} doesn't seem to work in ghci
07:40:54 <ion> :set -XExtensionName
07:41:02 <Walther> thanks!
07:41:40 <ion> Actually, :seti might be more appropriate. it sets things for interactive evaluation only.
07:49:19 <albeit_> If I want to check if three items are in order, how can I do that? Increasing / decreasing doesn't matter
07:49:34 <albeit_> (Preferably in one pass, not two)
07:50:11 <albeit_> Ah nvm... compare a b == compare b c
07:52:01 <ion> > map (length . group . (zipWith compare <*> drop 1)) ["hello", "abcd", "dcba"]
07:52:03 <lambdabot>  [4,1,1]
07:52:50 <ion> How about "abb" though?
08:03:41 <floogr> Are GADTs in general isomorphic to tuples?
08:03:43 <lamefun> http://lpaste.net/134964 - is this an OK module naming-wise?
08:04:49 <mniip> floogr, what
08:06:29 <floogr> mniip: well a constructor is basically a map from a tuple of params to a type...
08:06:58 <floogr> so if you say the end type is the last or first element of the tuple, then the constructors are isomorphic
08:07:17 <floogr> then you can further organize the constructors into a tuple or list
08:07:37 <mmachenry> I'm trying to profile my program for memory leaks. I am using -auto-all and not -prof (because ghc says it will cause problems.) but then when I try to use "+RTS -p" it says that's only available with -prof.
08:07:46 <floogr> so basically what I'm wondering is can you represent any type as a tuple
08:07:50 <mmachenry> How do I get memory cost centers output? 
08:08:35 <kadoban> mmachenry: I doubt it actually says "it will cause problems", what does it actually say?
08:09:35 <mmachenry> It does.
08:09:41 <mmachenry> Well… "lead to problems"
08:09:42 <mmachenry> Warning: 'ghc-options: -prof' is not necessary and will lead to problems when
08:09:42 <mmachenry> used on a library. Use the configure flag --enable-library-profiling and/or
08:09:55 <floogr> so in a depenently typed language maybe you could do something like Maybe a b = ("Maybe", a, b)
08:10:39 <mmachenry> btw this is happening even if it's used on the executable part of my cabal file.
08:11:47 <mniip> floogr, I don't see how product types (that's what they're called) are any close to GADTs
08:11:53 <mniip> anyway
08:11:58 <mniip> you're forgetting sum types
08:12:05 <mniip> for example you can't implement Either with tuples
08:16:41 <lamefun> is there a shorthand for (Parsec.string "xyz" >> return getXYZ)?
08:16:44 <floogr> mniip: product types are a subset of GADTs right?
08:17:26 <mniip> subset yes
08:17:42 <floogr> ah ok
08:18:33 <floogr> I wonder why sum types are called that way.. what's the connection to 'sum' in algebra?
08:19:01 <shachaf> If there are n values of type A and m values of type B, there are n+m values of type A+B
08:19:29 <floogr> oh
08:19:35 <mniip> likewise with product types (multiplication), unit type (the number 1), void type (the number 0)
08:19:41 <benma> lamefun: getXYZ ist just a fixed value? i don't see a way to make it shorter, except for introducing a function that does that
08:19:42 <mniip> and exponentiation (reversed -> arrow)
08:20:10 <floogr> I see
08:20:34 <lamefun> benma, yes, it's a pure value
08:20:51 <benma> lamefun: what kind of shorthand did you have in mind?
08:21:09 <kadoban> floogr: I think of it as sum/product on sets, although I doubt that's actually correct (my math sucks)
08:21:19 <benma> lamefun: there is not a lot of redundancy here
08:21:23 <floogr> I wonder if that's why ML uses '*' for linking constructor parameters
08:21:43 <dmj`> what happened to http://www.cminusminus.org/ ?
08:22:04 <lamefun> Somthing like: "foo :: Monad m => m a -> b -> m b; foo x y = x >> return y". I'm just curious whether there's a built-in function for that.
08:22:04 <Cale> lamefun: importing Control.Applicative will get you (<$), which more or less works like that.
08:22:32 <mniip> yeah, under AMP (<$) is a subtype of foo
08:23:03 <mniip> you can also consider (fmap . const)
08:26:37 <lamefun> Cale, http://lpaste.net/134964 - is this an OK module naming-wise or does it need splitting?
08:28:51 <Cale> I think it's okay
08:29:28 <Cale> You might end up wanting to factor that VersionRequest type differently, but write some code and see how it goes.
08:30:08 <Cale> Generally anything you can do to cut down on the number of constructors in your types tends to be helpful.
08:37:38 * nshepperd is annoyed by the silly justification for data.strict.maybe not having a monad/applicative instance
08:40:20 <nshepperd> I suppose I will email dons if it ever becomes relevant to me
08:42:10 <hodapp> Nested type family application NOOOOOOOO
08:53:17 <simon> I've got a foos :: IO [Foo] and need to repackage it as EitherT Err IO [Foo]. simply doing 'return foos' gives me an EitherT Err IO (IO [Foo]). it looks like I should join, but that doesn't add up completely, either.
08:53:46 <ion> @type EitherT
08:53:47 <lambdabot>     Not in scope: data constructor ‘EitherT’
08:53:47 <lambdabot>     Perhaps you meant variable ‘either’ (imported from Data.Either)
08:55:27 <ion> @type ExceptT
08:55:29 <lambdabot> m (Either e a) -> ExceptT e m a
08:55:40 <ion> @type ExceptT . fmap Right
08:55:41 <lambdabot> Functor m => m a -> ExceptT e m a
08:56:25 <simon> alright, thanks.
08:58:32 <ion> @type lift :: IO a -> ExceptT e IO a
08:58:33 <lambdabot> IO a -> ExceptT e IO a
08:59:48 <ion> simon: ↑
09:00:36 <ion> liftIO, too
09:02:05 <simon> ion, appreciated!
09:17:08 <Geekingfrog> Is there any ETA for 7.10 to become the blessed version of ghc?
09:17:44 <crough> When things start supporting it, probably.
09:17:57 <geekosaur> 7.10.2 is in release candidate stage and the corresponding Haskell Platform is being developed concurrently with expected release within a week after 7.10.2 goes final
09:18:22 <geekosaur> when the rest of the ecosystem will support it depends on the individual package maintainers
09:18:41 <Geekingfrog> argh. I guess I'll have to fix my arch install then :/
09:18:57 <Geekingfrog> not always a good things to be on the bleeding edge
09:19:33 <crough> Geekingfro: try stack (yaourt -S haskell-stack)
09:19:44 <bitemyapp> crough: :)
09:20:01 <Cale> Geekingfrog: Is it not already the blessed version?
09:20:46 * michaelt mutters a few benedictions over his ghc-7.10
09:20:51 <breadmonster> Cale: Have you ever used classy prelude?
09:21:10 <Cale> No, but I know what it is.
09:21:22 <Cale> It's ugly and awful, and I would avoid it. :)
09:21:44 <breadmonster> Haha is it really that bad?
09:22:03 <Haskellfant> lots of stuff already works with 7.10
09:22:39 <ChristianS> Geekingfrog: what do you mean by "blessed version"?
09:22:41 <breadmonster> Cale: What's the difference between transformers and mtl, btw?
09:23:35 <Geekingfrog> Well, I've been trying yesod with 7.10 without much success
09:24:08 <Geekingfrog> ChristianS, by blessed I mean the stable and supported version. I somewhat expect the version shipped with haskell platform to be the "blessed" one
09:24:12 <Cale> Geekingfrog: Yesod is its own whole ecosystem, kind of.
09:24:34 <ion> breadmonster: mtl uses non-Haskell98 features such as MPTCs, transformers doesn’t AFAIU.
09:24:35 <geekosaur> breadmonster, mtl is built on top of transformers. transformers is somewhat generic; mtl is a specific set of transformers
09:25:42 <michaelt> breadmonster: mtl has type classes like MonadState s m => m r ; MonadReader ... ; you use transformers to instantiate them in a sort of standard way.
09:26:02 <Cale> uhhh
09:26:05 <michaelt> breadmonster: transformers has actual haskell types like StateT s m r
09:27:00 <Cale> Both packages define types like ContT
09:27:21 <michaelt> it's re-exported 
09:27:25 <michaelt> no?
09:27:41 <Cale> Also, mtl depends on the transformers package, not the other way.
09:28:05 <michaelt> of course, yes. 
09:28:13 <Cale> Yeah, stuff from transformers gets re-exported by mtl.
09:28:53 <Cale> I suspect the reason that they exist separately is just mostly for backward compatibility reasons.
09:29:06 <Cale> mtl existed first, a long time ago
09:29:59 <Cale> At some point, there was an experiment which was tried, splitting it into a basic library of monad transformers, and then two different packages for the MonadFoo classes, one using type families and one using functional dependencies
09:30:30 <michaelt> right, transformers is part of the older one. That it mtl depends on transformers is just that transformers ended up deeper in the dependency chain; the instances Reader r (ReaderT r ...) could have been in either, no?
09:30:45 <Cale> (monads-tf and monads-fd)
09:31:28 <clnznr> hi everyone, I'm looking for a way to build a Data.Lens.Traversal from a function, pretty much alla `map`. I've looked up in Hoogle, Google and whatnot and I'm completely lost. I'm looking for a function analogous to `lens`, `prism` or `iso`, but for traversals. 
09:31:30 <michaelt> In themselves the mtl classes don't have to do with transformers really, and similarly the other way around. 
09:31:31 <geekosaur> mtl1 -> monads-fd + transformers -> mtl2 (which is essentially monads-fd + dependency on transformers)
09:31:52 <Cale> I suspect that transformers really only exists now because various things depended on the transformers package alone back when mtl split into transformers and monads-tf and monads-fd.
09:31:53 <geekosaur> monads-{fd,tf} was specific implementations of transformers
09:32:47 <crough> I usually don't need mtl
09:32:57 <crough> transformers is usually completely sufficient for me
09:33:03 <geekosaur> I'm not sure of that because anything using monads-fd had to be rewritten for mtl2 anyway (to avoid collisions, monads-fd used a different module hierarchy from mtl1)
09:33:39 <geekosaur> and yes, often you care more about the transformer machinery than the implementation of specific transformers
09:34:03 <crough> geekosaur: esp. since mtl is much bigger... if you don't need specifics there's really no point in using it.
09:34:09 <ion> clnznr: Here’s a (hopefully) enlightening exercise: start by writing your own _1 :: Functor f => (a -> f b) -> (a,c) -> f (b,c). Then write your own both :: Applicative f => (a -> f b) -> (a,a) -> f (b,b). The former is a lens, the latter is a traversal. The difference is just in the Functor vs. Applicative constraint. Functor gives the power to “focus” on exactly one member, Applicative gives the
09:34:11 <ion> power to focus on zero or more members.
09:35:54 <ion> clnznr: It might be nice to think of a very concrete specialization: “_1” as applied to readFile has the type (FilePath -> IO String) -> (FilePath,c) -> IO (String,c). “both” as applied to readFile has the type (FilePath -> IO String) -> (FilePath, FilePath) -> IO (String, String).
09:37:29 <nuttycom> Cale: can you elaborate on your dislike for ClassyPrelude? It makes a lot more sense to me than the standard prelude, though this is less the case since burning bridges.
09:38:48 <clnznr> ion: hhmmm... I think I get you point. I'm going to give it a try. Thanks!! =)
09:41:49 <Cale> nuttycom: "Let's just use type class polymorphism everywhere just because, even if we can't explain what laws these classes ought to satisfy" doesn't seem like a reasonable thing to me.
09:42:20 <Cale> I'm also not entirely happy with the introduction of Foldable to the Prelude
09:42:36 <Cale> I think Foldable is ugly. I have fewer problems with Traversable.
09:42:37 <nuttycom> Ah, okay. So what you object to is the lawless typeclasses. That's a very reasonable complaint.
09:42:41 <bitemyapp> nuttycom: incidentally, Cale has the best argument against FTP I heard when that was going around.
09:42:42 <nuttycom> I agree.
09:43:11 <bitemyapp> the argument he provided at the time was a bit different than lawlessness as people were able to contrive a law for foldable ex post facto.
09:43:23 <bitemyapp> wanted FTP anyway :P
09:43:44 <michaelt> a lot of it really is covered by the new Prelude. 'monotraversable' carries the Foldable business one step further to cover Text and ByteString 
09:44:11 <michaelt> the stated law is a free theorem even now, bitemyapp 
09:44:16 <Cale> To be honest, ClassyPrelude seems very different now from how I remembered it being
09:44:27 <Cale> But it's still ugly, even if not as ugly as I remembered :P
09:44:31 <bitemyapp> michaelt: I know this makes me evil, but I like the IOData typeclass in classy-prelude :P
09:44:42 <bitemyapp> Cale: I've found it very pleasant and largely unsurprising for application work
09:44:47 <bitemyapp> Cale: but I would never use it in a library.
09:45:08 <Cale> Ah, yeah, apparently it used to be way worse.
09:45:22 <bitemyapp> Cale: aye
09:45:34 <bitemyapp> Cale: they keep it mostly restricted to mono-traversable and IOData now I think
09:45:45 <bitemyapp> which address two warts in day-to-day Haskell programming.
09:46:23 <nuttycom> mono-traversable is actually a bit annoying to me among the things I get from classy, just because I find that it requires type annotations with more frequency than I like.
09:47:07 <Cale> Lists should be considered important!
09:47:49 <michaelt> yes, but don't you want easy use of Text, Vector etc.?
09:48:03 <Cale> Text/Vector/etc. are already easy to use.
09:48:15 * michaelt agrees of course
09:48:37 <Cale> I see lists as a fundamental way to express iteration.
09:49:05 <Cale> If you're going to iterate over something, you express it by forming a list of elements.
09:49:27 <shachaf> Unless you want effects.
09:49:54 <Cale> shachaf: Well, even if you want effects, the higher order functions you then apply to the list just become different.
09:50:10 <Cale> i.e. you use mapM instead of map
09:50:17 <shachaf> Except that doesn't work very well.
09:50:22 <shachaf> You can't mapM and then take.
09:50:44 <Cale> Well, you can, you just get more effects than results then.
09:50:56 <michaelt> each ls >-> P.mapM whatever >-> P.take n
09:51:04 <hodapp> well, I was going to go "BLAAAARGH!" and throw out this GHC.Generics code and replace it with a bunch of Template Haskell nonsense, but then something johnw talked to me about kind of made sense, and perhaps I won't use TH.
09:51:05 <shachaf> OK, unless you *care* about effects.
09:51:54 <Cale> Well, fair enough, take doesn't commute with operations which involve effects :P
09:52:29 <Cale> But I think there just generally isn't enough love for what universal data structures get us sometimes.
09:55:34 <lamefun> Cale, http://lpaste.net/134976 - my completed version module... unhappy with cryptic type errors though.
09:58:52 <joco42_> a super basic cabal sandbox question : http://stackoverflow.com/questions/30985679/is-everything-reinstalled-from-scratch-in-cabal-sandboxes
09:59:07 <joco42_> just to make sure I get this right
10:00:14 <joco42_> if I understand correctly, in such a situation evertyhing already installed globally is ignored, is that correct?
10:00:27 <joco42_> if using cabal sandboxes
10:00:50 <lamefun> why do I get cryptic type errors when I remove the type signature from metaIdP?
10:04:05 <Cale> joco42_: I'm not certain about this, but I believe your globally installed packages (i.e. should be just what came with GHC) should be available, while your user-installed packages will not be.
10:04:35 <joco42_> Cale: hmmm ! ok, that is good to know.
10:05:41 <bergmark> joco42_: i'm not sure about this either... it has seemed a bit random to me but i never investigated it uflly
10:06:05 <Cale> It might just be base alone, since that's the only package which really couldn't be replaced.
10:06:08 <joco42_> Cale: so there are two kind of globally installed packages : 1) user installed via "cabal install" and 2)the ones that came with ghc
10:07:13 <joco42_> Cale: ok, so in practice everything gets recompiled from scratch... I think I shall learn to use nix ASAP
10:07:24 <Cale> joco42_: If you do a ghc-pkg list, you should see that you have a system-global package database (on my system, it's /usr/local/lib/ghc-7.10.1/package.conf.d), as well as a per-user package database (for me /home/cale/.ghc/x86_64-linux-7.10.1/package.conf.d)
10:07:50 <Cale> joco42_: and the per-user package database is where things go by default when you cabal install them
10:08:11 <Cale> joco42_: The whole point of using a sandbox is to build all the dependencies for the project separately.
10:08:32 <joco42_> Cale: yes, this is useful to know 
10:08:33 <Cale> joco42_: If you just want to use the packages you've already installed as your user, just don't use a sandbox.
10:09:39 <joco42_> Cale: I slowly start to grasp how sandboxes work...
10:09:50 <joco42_> Cale: thanks for the illumination
10:14:56 <mmachenry> How reliable is the %allocation in a function for finding memory leaks?
10:15:25 <mmachenry> I would think naively it would point to issues, but also, it might be allocating things, but other code is responsible for erroneously keeping it alive
10:31:03 <meditans> if I want to cabal build with -O2, is the right thing to do first `cabal configure -O2` and then `cabal build`?
10:34:26 <arkeet> isn't it cabal configure --ghc-options=-O2
10:35:50 <dmj`> meditans: you can just put that in your cabal file 'ghc-options' under the executable section. You can also make a flag so 'cabal configure -foptimized' will turn it on
10:38:49 <larxy> is ghc's --prefix option usable in the configure script? ghc-pkg cant be executed (dl cant find libraries) during make install
10:44:33 <meditans> dmj`: thanks!
10:59:14 <brooqle> how do I add a constraint for a data type parameter?
10:59:32 <benzrf> brooqle: you probably shouldnt
10:59:36 <benzrf> brooqle: what are you trying to do
10:59:52 <rien> I need some help with cabal install. I can't install tga, it says it is incompatible with bytestring-0.10.4.0. I've tried cabal unpack to relax the restriction, and tried ghc-pkg unregister bytestring-0.10.4.0 but no cigar
10:59:58 <brooqle> benzrf: nothing in particular just playing around in ghci
11:03:27 <brooqle> Can I use 'deriving' with GADTs?
11:03:45 <kuribas> I'd like to support bezier curves of any degrees in my library, but some functions only operate on some degree's, like cubics or quadratics.  Can I encode this in the type system, or should I just throw an error?
11:03:52 <sivteck> rien, tga has a very ancient upper bound and has not been updated since 2011. You can do `cabal unpack tga` remove the version bound in tga.cabal and do cabal install
11:04:28 <sivteck> (it compiles that way fwiw)
11:04:58 <Ptival> I believe the answer is no, but let's try, is there any way in Happy to have it build a pretty-printer or to obtain programmatically precedence/associativity information?
11:05:27 <rien> sivteck: I did try relaxing it after unpacking to no avail
11:06:14 <rien> sivteck:     build-depends:        base == 4.*,        bytestring  (dropped the version altogether for bytestring in tga.cabal file)
11:06:49 <brooqle> Ptival: https://www.haskell.org/happy/doc/html/sec-Precedences.html ?
11:07:15 <sivteck> rien, it compiles for me though.
11:08:17 <rien> sivteck: linux or mac?
11:08:19 <sivteck> rien, tried it in a new sandbox?
11:08:22 <sivteck> rien, linux
11:08:34 <sivteck> ghc 7.10.1
11:08:40 <Ptival> brooqle: this doesn't answer my question at all, or am I missing something? :\
11:08:51 <rien> sivteck: cabal sandbox delete; cabal sandbox init; cabal install (after cabal unpack tga and change has been made). yep. must be a mac problem.
11:09:39 <brooqle> Ptival: maybe I misunderstood your question... are you asking about defining precedence and associativity rules in happy?
11:10:18 <Ptival> brooqle: no, I know how to do that, I am asking about whether there is a way to refer to them in a program, for instance, with the purpose of writing a pretty-printer for that grammar
11:10:53 <sivteck> rien, delete the dist directory and try again?
11:11:09 <rien> sivteck: ah I think I was then incorrectly doing "cabal install tga" when that should've been "cabal install tga-0.2/"
11:11:32 <sivteck> you can just type cabal install inside the tga-0.2 directory
11:11:49 <rien> sivteck: and then jump out with cd .. and type cabal install again for the project?
11:11:52 <brooqle> ah Ptival, I don't know
11:12:01 <sivteck> ah right ;P
11:12:26 <rien> sivteck: which linux out of curiosity do you use?
11:12:34 <sivteck> archlinux
11:12:41 <rien> sivteck: do you use nix at all?
11:12:44 <reindeernix> coming from imperative programming, pattern matching should be called pattern magic
11:13:24 <rien> reindeernix: I think the magical part might be what is sometimes referred to as "destructuring bind"
11:13:37 <sivteck> rien, I was using NixOS earlier.
11:14:05 <rien> sivteck: would you tell me a bit about your experience? I am a total failure at package management and have been thinking of taking extreme measures
11:14:19 <sivteck> rien, the upgrades are huge in size and I have a terrible internet connection
11:14:58 <rien> sivteck: I'll gladly trade size for convenience. any other issues you had or downsides?
11:15:15 <sivteck> rien, nope.
11:16:28 <sivteck> rien, Nix is the best option for haskell development now.
11:16:41 <sivteck> rien, but it has a learning curve
11:18:08 <rien> sivteck: that's what I wanted to hear. I'll pay any price for the best option for package management. do you feel Nix is all that is needed, not NixOS? that's what I always read.
11:20:14 <sivteck> rien, idk. try Nix first. It's not very easy to install NixOS. 
11:21:07 <rien> sivteck: is that why you switched to arch?
11:21:10 <sivteck> also ask in #nixos, it's offtopic here
11:21:17 <rien> will do
11:21:41 <sivteck> sivteck, I want to use latest Chromium without huge upgrades ;p
11:22:12 <sivteck> rien, *
11:22:14 <sivteck> ;x
11:23:46 <rien> sivteck: I see. that helps, so there aren't really huge cons to it apart from installation. I'll see in #nixos if they have more input
11:29:05 <getlernd> Hello. I've been working my way through "Learn You a haskell" and seem to have hit a roadblock with curried functions. What I don't understand is where intermediate results come from in a chain of functions if each function takes only one argument. I am new to programming and functions that take one argument but produce a result that seem to require several don't really mean anything to me.  
11:29:46 <getlernd> Any help would be greatly appreciated.
11:30:10 <reindeernix> I can try but I just started reading that book this friday so bear with me
11:30:19 <Denommus> getlernd: I don't exactly understand your doubt
11:30:24 <meoblast001> i think cabal hates me
11:30:43 <getlernd> Okay, let me give the simplest example from the book. 
11:30:45 <timothyh> the intermediate results are new functions
11:30:51 <Denommus> getlernd: if you don't understand how single-argument functions work, it is simple. For instance, you have (+) :: Int -> Int -> Int
11:30:55 <meoblast001> https://gist.github.com/meoblast001/633ed8f0e6a2a3b52020
11:31:06 <Denommus> getlernd: that means it takes two integers and evaluates to another integer
11:31:29 <getlernd> But if it takes two integers then how can it be a single-argument function?
11:31:35 <Cale> getlernd: So consider this function definition:  sumOfSquares x y = x^2 + y^2
11:31:39 <Denommus> getlernd: if you pass only one argument, like (+) 1, just the first argument will be "used", so it will result in a function Int -> Int
11:31:46 <Cale> @let sumOfSquares x y = x^2 + y^2
11:31:47 <lambdabot>  Defined.
11:31:47 <reindeernix> take the function f(x,y) = x + y for instance, the function would return another function which we call g(y) = x + y
11:31:52 <reindeernix> that is how I understand it
11:31:53 <lpaste_> mmachenry pasted “Thread leak” at http://lpaste.net/134982
11:32:24 <Cale> We can apply it to one argument to get another function:
11:32:32 <getlernd> So it returns a function that takes multiple arguments? I thought all functions in Haskell technically take only one.
11:32:36 <mmachenry> I found a thread leak and I'm looking for suggestions. Basically I'm trying to make a "safe" thread that dies when its parent dies or kills its parent when it dies.
11:32:45 <mmachenry> But as a result I'm never freeing the thread.
11:32:45 <Cale> @let foo = sumOfSquares 5
11:32:46 <lambdabot>  Defined.
11:32:52 <Cale> > foo 10
11:32:53 <lambdabot>  125
11:33:26 <Denommus> getlernd: yes, it returns another function that technically takes only one argument, and this new function returns another function that technically takes only one argument, until you don't have arguments left to be taken and produce the actual value
11:33:50 <lpaste_> mmachenry revised “Thread leak”: “No title” at http://lpaste.net/134982
11:34:02 <Cale> getlernd: When you see a type like A -> B -> C -> D, it means A -> (B -> (C -> D))
11:34:06 <mmachenry> Oops, sorry for the double paste, I had to edit it.
11:34:17 <Gurkenglas> I want to use grammatical framework for a chatbot written in Haskell. I installed it as http://www.grammaticalframework.org/doc/tutorial/gf-tutorial.html#toc7 instructs and the "Hello World" grammar below that worked. Skipping to http://www.grammaticalframework.org/doc/tutorial/gf-tutorial.html#toc148 , running the code there (with "System" replaced by "System.Environment") throws this: http://pastebin.com/A7MhKWK
11:34:17 <Gurkenglas> z . What do?
11:34:26 <Cale> getlernd: and correspondingly, when you see a function application like f x y z, it really means ((f x) y) z
11:34:27 <Gurkenglas> * http://pastebin.com/A7MhKWKz
11:34:28 <timothyh> getlernd: \a b c -> a b c <=> (\a (\b (\c -> a b c)))
11:34:48 <mmachenry> The space leak is actually pretty obvious now that I've seen it in hp2ps. But I'm not sure of a good way to solve it.
11:35:04 <getlernd> Okay, let me give a concrete example to illustrate my confusion. So if I create a function that, say, adds three numbers, and when I call it those numbers are 1, 2, and 3, what I don't understand is where the intermediate result 3 comes from that it is applied to the last function, which of course produces the result 6.
11:35:32 <Cale> getlernd: at no point will there be an intermediate result 3 :)
11:35:45 <Cale> We might define:
11:35:48 <Denommus> getlernd: there will be no intermediate result
11:35:53 <Cale> @let addThree x y z = x + y + z
11:35:54 <lambdabot>  Defined.
11:35:55 <Denommus> getlernd: there will be an intermediate FUNCTION
11:36:16 <Cale> @let addTwo y z = addThree 0
11:36:17 <lambdabot>  Defined.
11:36:28 <Cale> > addTwo 3 5
11:36:30 <lambdabot>  <Integer -> Integer -> Integer>
11:36:45 <Cale> oh, silly me, didn't type the parameters on the other side :P
11:36:47 <Cale> @undefine
11:36:48 <lambdabot> Undefined.
11:36:50 <Cale> @let addThree x y z = x + y + z
11:36:51 <lambdabot>  Defined.
11:36:59 <Cale> @let addTwo = addThree 0
11:37:00 <lambdabot>  Defined.
11:37:10 <Cale> > addTwo 3 5
11:37:12 <lambdabot>  8
11:37:33 <Cale> getlernd: ^^ see how that works?
11:37:58 <getlernd> Not exactly. lol
11:38:05 <getlernd> I'm getting hung up on the author's example. 
11:38:11 <Cale> addThree 0 is the function which when applied to a couple more arguments y and z, will result in 0 + y + z
11:38:16 <sleblanc> GHC on my system takes up 900 MB (not counting the various Haskell libs), while the compressed package file is only 70 MB. Is there any way to compress such files and have GHC work with those?
11:38:39 <Cale> getlernd: It might be a little easier to explain if you're already familiar with lambda expressions?
11:38:57 <Cale> sleblanc: hm?
11:38:58 <getlernd> I've seen them but wouldn't go so far as to call myself familiar. 
11:39:36 <Cale> getlernd: Okay, so you get the basic idea that (\x -> y) is the function which given x, produces y as the result.
11:39:48 <getlernd> Sure
11:40:44 <Cale> getlernd: So, the idea here is that when we write addThree x y z = x + y + z, this is pretty much the same as writing addThree = (\x -> (\y -> (\z -> x + y + z)))  (there are some technical differences, but they're irrelevant for this discussion)
11:41:13 <Cale> So let's try applying this function to one argument:
11:41:17 <getlernd> Okay
11:41:22 <Cale> addThree 2
11:41:28 <Cale> = (\x -> (\y -> (\z -> x + y + z))) 2
11:41:37 <Cale> = (\y -> (\z -> 2 + y + z))
11:42:05 <Cale> So, we just computed another function as the result here
11:42:17 <Cale> We can go on to apply that function to another argument:
11:42:22 <Cale> (\y -> (\z -> 2 + y + z)) 3
11:42:29 <Cale> = (\z -> 2 + 3 + z)
11:42:50 <Cale> and then another:
11:42:55 <Cale> (\z -> 2 + 3 + z) 5
11:43:00 <Cale> = 2 + 3 + 5
11:44:03 <sleblanc> Cale, I am aware that GHC needs archive files and .hi to allow one to compile a program. However those files do not appear to be compressed, as such they take up a lot of space. I was wondering if there was a way to compress the files and have GHC uncompress them when needed. I guess as an alternative I could create a subvolume on /usr/lib/ghc-* and use disk compression instead…
11:44:17 <Cale> sleblanc: Not built in, no.
11:44:43 <geekosaur> I would be surprised if compression gained you much, especially on hi files
11:44:49 <Cale> sleblanc: I don't know if there are funny filesystems which let you do that -- I'm used to just wasting lots of disk space since I have three 2TB drives. :P
11:45:45 <Cale> getlernd: Anyway, does that help?
11:46:16 <Cale> getlernd: At each step there, I just substituted the argument into the body of the function where the function's parameter occurred
11:46:16 <Luke> open OS X 10.11 (El Capitan) i'm now unable to build HsOpenSSL because 'openssl/asn1.h' file not found
11:46:27 <Luke> any ideas how to fix this?
11:47:14 <geekosaur> hm, actually hi files should be more compressible than .a files, which are mostly binary unless you managed to get C++ or debug symbols into them (in which case "strip -s" might be useful) 
11:47:19 <Cale> Luke: I don't know how to specifically fix it for Mac OS X, but it sounds like you're missing the development version of the C openssl library, so just installing that should fix the problem.
11:47:25 <sleblanc> geekosaur, I am not surprised. The tarball is 70MB while on the disk it takes up almost 1G
11:47:28 <getlernd> Well . . . I think you lost me at the second step. The 2 that takes the place of x looks to me like an intermediate result that you're giving to a function that takes 3 arguments. My brain can't get around the correct way of looking at it.
11:47:32 <Luke> Cale: what's the right way to do that on OS X?
11:47:45 <geekosaur> Luke, 10,11 doesn't ship openssl, it ships the openbsd replacement
11:47:54 <Luke> that's what I thought
11:48:03 <Luke> brew has openssl - should i just link against that?
11:48:14 <mitchty> they're not using their openssl shim to their backend stuff anymore?
11:48:15 <Cale> getlernd: Well, (\x -> (\y -> (\z -> x + y + z))) is written as a function of one argument, namely x, which happens to produce another function as its result
11:48:21 <Luke> and if so, what's the right way to represent this in my cabal file?
11:48:43 <geekosaur> it's *supposed* to be compatible but I have no idea what apple removed. brew/macports openssl will probably work as an alternative
11:48:58 <geekosaur> (I don't think it links against iconv, at least, which would be the biggest potential issue)
11:49:08 <Cale> getlernd: So, when we apply it to some number like 2, we substitute 2 for x in (\y -> (\z -> x + y + z)) to obtain (\y -> (\z -> 2 + y + z)), and that's the result
11:49:10 <Luke> geekosaur: what's the right way to encode that in my cabal file?
11:49:25 <Cale> getlernd: The result of a function is allowed to be another function, of course.
11:49:45 <Cale> (functions are values)
11:50:13 <Cale> Luke: I haven't used OS X since 2004 or something, so I couldn't tell you the right way myself.
11:50:52 <joco42_> hamishmack: Success with install on OSX using VB 5rc1, 2 questions : 1) is this the correct setting for HiDPI Scaling ? http://pasteboard.co/1q0sORh9.png, 2) if yes, then the fonts in the Guest OS are very small on retina, is there a way to make them larger? I've seen a video of you showing ghcj+Leksah and it seemed that somehow the fonts were large and crisp at the same time, just like cocoa apps on OSX retina. I wonde
11:50:52 <joco42_> r how you did that.
11:50:57 <Luke> Cale: at this point I think linking against the brew version is the right way but what I'm not asking is how do I correctly represent that in my cabal file?
11:51:12 <Luke> Cale: brew in fact gives instructions: "LDFLAGS:  -L/usr/local/opt/openssl/lib"
11:51:31 <geekosaur> extra-lib-dirs will do the -L part
11:51:37 <Luke> Cale: how do I translate that into ghc/cabal?
11:51:39 <getlernd> T_T
11:51:43 <Luke> geekosaur: thanks
11:51:45 <geekosaur> I'm not sure about includes. cc-options with -I/opt/local/include mauybe?
11:51:48 <Cale> getlernd: Still confusing?
11:51:50 <ttt_Fff> in threpeenny.UI.addstylesheet, where is the "/static/main/*.css" directory served from? it's clearly not the directory where I run "cabal run" from
11:51:52 * geekosaur was doublechecking
11:51:55 <Luke> geekosaur: I'll try that
11:51:59 <Cale> getlernd: Let's start with something more straightforward
11:52:00 <getlernd> Okay, maybe you can clear up a few sentences from the book. Until somebody explains them I don't think I will ever understand.
11:52:16 <Cale> getlernd: Consider how we'd evaluate (\x -> 2*x) 5
11:52:41 <getlernd> What really happens when we do multThree 3 5 9 or ((multThree 3) 5) 9? First, 3 is applied to multThree, because they're separated by a space. That creates a function that takes one parameter and returns a function. So then 5 is applied to that, which creates a function that will take a parameter and multiply it by 15. 9 is applied to that function and the result is 135 or something.
11:52:42 <Cale> getlernd: We take the part after the -> and we substitute 5 for each occurrence of x, getting 2*5
11:52:51 <Luke> geekosaur:   "extra-lib-dirs: /usr/local/opt/openssl/lib" like that right?
11:53:00 <geekosaur> yes
11:53:10 <Luke> ty
11:53:25 <Cale> getlernd: Right, so, let's actually write that process out symbolically, rather than in confusing words
11:53:36 <getlernd> Sorry to interrupt you. The key sentence that troubles me is the one where he says the function takes a parameter and multiply it by 15. 
11:53:48 <getlernd> 15 is what I would call an intermediate result.
11:54:17 <Cale> getlernd: ah, while that statement is true in one sense, it's false in another
11:54:25 <Cale> getlernd: 15 won't have been computed at that point
11:54:42 <Cale> getlernd: Let's do the evaluation and you'll see :)
11:54:48 <getlernd> Okay
11:54:53 <simon> > (\x -> \y -> \z -> x*y*z) 3 5 9
11:54:54 <lambdabot>  135
11:55:03 <Cale> I'm going to do it by hand, thanks :)
11:55:05 <ttt_Fff> when I do "cabal run" ... what directory is cabal running from?
11:55:07 <johnw> hodapp: what did we talk about?
11:55:28 <Cale> So first, let's compute (\x -> (\y -> (\z -> x*y*z))) 3
11:55:55 <Cale> We substitute x for 3 in the body of the function, getting (\y -> (\z -> 3*y*z))
11:56:27 <Cale> okay with that?
11:56:57 <Cale> Now, (\x -> (\y -> (\z -> x*y*z))) 3 5  means
11:57:03 <Cale> ((\x -> (\y -> (\z -> x*y*z))) 3) 5
11:57:28 <Cale> because f x y is always the same as (f x) y, that is, function application associates to the left
11:57:51 <Cale> and we know that (\x -> (\y -> (\z -> x*y*z))) 3 = (\y -> (\z -> 3*y*z))
11:57:55 <Cale> so
11:57:59 <Cale> ((\x -> (\y -> (\z -> x*y*z))) 3) 5
11:58:05 <Cale> = (\y -> (\z -> 3*y*z)) 5
11:58:20 <Cale> = (\z -> 3*5*z)
11:59:43 <Cale> This function will technically multiply its argument by 15, but the 3*5 won't normally be evaluated before we actually apply it, because no practicall evaluator for Haskell will typically do evaluation inside the body of an unapplied lambda expression.
11:59:47 <dfeuer> @ask edwardk Should Semi be moved from Data.Semigroupoid to Control.Category?
11:59:48 <lambdabot> Consider it noted.
11:59:50 <Cale> practical*
12:00:34 <Luke> geekosaur: hmm no luck with the includes
12:00:44 <Luke> geekosaur: I also tried install-includes: section in cabal
12:00:47 <Cale> getlernd: follow that?
12:01:05 <geekosaur> install-includes would be includes from your project to copy into an installable package
12:01:10 <Cale> getlernd: Feel free to ask why I did any particular thing :)
12:01:35 <ttt_Fff> argh, how do I debug where threpeenny serves it's static/css dir from ?
12:01:56 <Cale> getlernd: It might be more correct to say that the function multiplies its argument by 3*5 than it is to say that it multiplies by 15
12:01:57 <Luke> geekosaur: ah. seems like there should be an extra-includes-dir: or something
12:02:14 <dfeuer> @tell edwardk Or actually maybe to somewhere in transformers? It's a very close relative of Constant.
12:02:14 <lambdabot> Consider it noted.
12:02:17 <geekosaur> but I didn't see one :/ hm
12:02:28 <Luke> geekosaur: https://github.com/haskell/cabal/issues/1378
12:02:41 <Cale> getlernd: However, we *can* write a version of this function which is able to do some work early.
12:02:45 <geekosaur> looks like that should actually be the name of it
12:02:59 <getlernd> I guess what I don't understand is the substitution. I don't understand how the final result is produced if not by a function that takes the arguments 3, 5, and 9. 
12:03:02 <geekosaur> I don't thinkt hat bug matters?
12:03:20 <geekosaur> it means the Setup program itself can't link against e.g. openssl
12:03:44 <Luke> no it doesn't matter here. just talking about a flag called extra-include-dir =)
12:03:44 <geekosaur> which is not something you normally would do, since the point of Setup is to write out a build plan
12:03:48 <Cale> getlernd: Well, the real work here is being done by (*), but we're not looking at how it does its thing
12:04:22 <getlernd> Maybe that's what I should be looking at. 
12:04:29 <Luke> my point is I can't find that this concept exists in cabal for extra build include dirs
12:05:09 <Cale> getlernd: But all the stuff that I've described so far doesn't involve actually allowing (*) to evaluate, because it only occurs inside the body of the lambdas
12:05:09 <geekosaur> yes, the flag exists but wasn't listed in the cabal manual
12:05:20 <geekosaur> so I checked the cabal usage to confirm it was there
12:05:29 <Luke> which flag?
12:05:44 <Luke> I'm still on 7.8.4, you looking at 7.10.1?
12:05:45 <geekosaur> --extra-include-dirs aka extra-include-dirs: in a Cabal file
12:05:53 <Cale> getlernd: all we've been doing so far is substituting the value of the the argument to a function into the body of the function, quite blindly.
12:06:01 <geekosaur> and ghc version is not relevant to cabal-install version
12:06:02 <MarcelineVQ> also check out currying getlernd, to clarify why it's 3,5,9 http://learnyouahaskell.com/higher-order-functions
12:06:15 <Luke> geekosaur: good point. either way, doesn't work for me
12:06:21 <Luke> let me make sure my cabal is up to date
12:06:28 <Cale> MarcelineVQ: He's trying to understand the very thing you linked.
12:06:34 <geekosaur> you tried adding an extra-include-dirs: ?
12:06:39 <Luke> yeah
12:06:43 <geekosaur> urgh
12:06:49 <getlernd> Thanks Marceline, what Cale said. Haha
12:06:51 <Luke> hold on my cabal is old
12:06:52 <geekosaur> it should work fromt he command line at least
12:06:55 <Luke> maybe it's new
12:07:04 <MarcelineVQ> lol fair enough
12:07:07 <geekosaur> cabal configure --extra-include-dirs="..." --extra-lib-dirs="..."
12:07:14 <Luke> yeah
12:07:21 <reindeernix> Luke, is it really that important to be on a newer version? I am currently on 7.6.3, how much changes every version?
12:07:21 <Luke> i'll test next
12:07:26 <Cale> getlernd: So okay, if we define f = (\x -> (\y -> x^2 + y^2))
12:07:27 <mitchty> how do i tell cabal to statically link haskell libraries into the resultant executable (note not external shared libraries)
12:07:35 <Luke> reindeernix: we're talking about cabal version
12:07:49 <Cale> getlernd: Then f 5 = (\x -> (\y -> x^2 + y^2)) 5 = (\y -> 5^2 + y^2)
12:07:57 <mitchty> preferably via cabal build
12:07:58 <Luke> reindeernix: and things changed a lot between 7.8.4 and 7.10.1 in terms of libraries etc
12:08:03 <Cale> getlernd: Does that make sense?
12:08:12 <reindeernix> Luke, alright I thought you were talking about GHCI
12:08:21 <Cale> getlernd: I think a smaller example with just two parameters would be a little clearer to start with
12:08:23 <reindeernix> *GHC
12:09:01 <Luke> geekosaur: ok tried with later cabal. same problem. says "Fields allowed in this section:" then lists the fields except for extra-include-dirs
12:09:07 * hackagebot jespresso 1.0.2 - Extract all JavaScript from an HTML page and consolidate it in one script.  http://hackage.haskell.org/package/jespresso-1.0.2 (AndreyChudnov)
12:09:12 <geekosaur> sigh
12:09:14 <Luke> geekosaur: so apparently it's not an allowed field in an executable section
12:09:29 <fragamus> this paper has an example in section 6.5 that uses unsafePerformIO: http://clemens.endorphin.org/ILC07-Liskell-draft.pdf
12:09:32 <geekosaur> probably they expect you shouldn't use that in a distributable file or something
12:09:40 <getlernd> Okay, it makes as much sense as it can until I see the big picture.
12:09:43 <fragamus> I can't understand why it would need to do IO
12:09:44 <Luke> geekosaur: potentially
12:09:45 <geekosaur> I generally only use it from the command line
12:09:49 <Luke> geekosaur: seems weird libs would be ok though
12:09:51 <Luke> but not includes
12:09:58 <Luke> geekosaur: libs and includes go together...
12:10:21 <Luke> unless they're thinking it's safe to swap out the implementation without changing the interface
12:10:23 <Denommus> is there any content-type for servant that produces Show instead of JSON, for the front-end consume it with a Read?
12:10:32 <Cale> fragamus: To mutate a memo table, ostensibly.
12:11:03 <meoblast001> hm.. i'm confused
12:11:05 <fragamus> mutable ahh
12:11:17 <meoblast001> my fedora GHC package wants to install ghc-unix... it depends on it.. but Cabal also wants to install unix
12:11:34 <meoblast001> so both my compiler and the package manager depend on the unix package.. installed at different locations
12:11:38 <meoblast001> which breaks things
12:11:55 <alpounet> Denommus: nope, not yet, but you could easily write it!
12:12:06 <alpounet> Denommus: PlainText is really close though
12:12:52 <Cale> getlernd: Well, the big picture is that you eventually come to regard functions of multiple arguments and functions which produce other functions as the same thing.
12:13:29 <MarcelineVQ> getlernd: as I understand it, multThree 3 5 9 returns a function that applies * to 3, and applies that function to * 5 to return a function that applies *3*5, and applies that function to 9, the final function actually computes 3*5*9
12:13:34 <Cale> getlernd: This has some implications... firstly, that you want to put the parameters to your functions in order from least-likely-to-change to most-likely-to-change
12:13:34 <meoblast001> is there a way to tell cabal to stop looking at system packages during compilation? or GHC
12:13:47 <MarcelineVQ> idk if that's clearer, or strictly correct, but that's how I've seen it
12:13:55 <Luke> geekosaur: you were correct. installing form the CLI worked just fine. thanks for your help
12:14:08 <Luke> geekosaur: just wish I could encode this in my cabal or something so I don't forget later down the road how I fixed this
12:14:16 <geekosaur> meoblast001, no, because base MUST come from the global package db
12:14:35 <geekosaur> in the absence of working options, try a comment?
12:14:40 <geekosaur> Luke ^
12:14:42 <Gurkenglas> Who'd Teamviewer onto my machine and install a package since I don't know how to deal with the errors?
12:14:56 <meoblast001> geekosaur: so can i make cabal not try to install non-system versions?
12:15:02 <meoblast001> because i can't have duplicate libs
12:15:13 <Cale> MarcelineVQ: Well "multThree 3 5 9 returns a function" isn't correct, but multThree 3 is a function, and multThree 3 5 is also a function, but multThree 3 5 9 is a number.
12:15:15 <Luke> geekosaur: haha good call ;-)
12:15:55 * geekosaur tends to compulsively check cabal files before building anyway, since flags and such, so a comment would do the job
12:16:11 <geekosaur> especially if it include a copy/pate-able command
12:16:14 <maerwald> Gurkenglas: dont ask for fish, ask how to fish
12:16:26 <getlernd> Ah. What Marceline just wrote just made something happen for me. Not sure I understand completely, but better than before.
12:16:33 <Cale> multThree 3 is a function which will take two more arguments y and z, and produce 3*y*z as its result
12:16:48 <Cale> multThree 3 5 is a function which will take one more argument z, and produce 3*5*z as its result
12:16:51 <geekosaur> meoblast001, if you want to only use system libraries, you can place constraints in  ~/.cabal/config or the cabal.sandbox.config in your sandbox
12:16:56 <geekosaur> e.g. 'mtl installed'
12:17:00 <Cale> multThree 3 5 9 is 3*5*9
12:17:07 <geekosaur> so it won't try to install alternative versions
12:17:28 <meoblast001> geekosaur: well. my primary goal is to get rid of multiple definition errors by the linker without breaking anything else
12:17:39 <Gurkenglas> Okay, how do I deal with the kind of error seen here? http://pastebin.com/anypPrUR
12:17:44 <Cale> multThree 3 5 9 = ((multThree 3) 5) 9
12:17:48 <meoblast001> although some google groups say i should be able to just nuke my .ghc and .cabal and fix it
12:18:12 <geekosaur> (note that this will comprehensively fail if you're e.g. trying to install yesod onto a system with the Platform installed; about the only fix I've found there is start from Stackage, which is yesod's idea of a "Platform", and worst case have a separate minimal ghc for it (possibly via hsenv) :/
12:19:21 <Gurkenglas> Alternatively, is there a better way to install gf than "cabal install gf"?
12:19:28 <geekosaur> Gurkenglas, it looks to me like you have something intended for mingw and are trying to use it with cygwin? this tends to not work well
12:19:36 <geekosaur> look around for minghc
12:20:01 <Cale> Also, you don't have the network package already? How did you install GHC?
12:20:12 <Gurkenglas> By downloading the Haskell Platform
12:20:12 <geekosaur> (which, among other things, includes a working network package, which is a massive pain to install for Windows otherwise)
12:20:21 <geekosaur> Platform should include network
12:20:42 <Gurkenglas> Maybe I broke something a few weeks ago when I tried to install other packages. Let me reinstall Haskell Platform.
12:21:04 <geekosaur> oh, I see
12:21:16 <geekosaur> you probably need to constrain gf, because you have an older version of network
12:21:19 <getlernd> I guess what I still don't understand is how the final function computes the value.
12:21:40 <geekosaur> try: cabal install gf --constraint="network installed"
12:21:42 <Cale> getlernd: You mean, what happens after we get to 3*5*9?
12:21:48 <getlernd> Yeah
12:22:27 <geekosaur> which should make it look for a version of gf compatible with your version of network, rather than attempt the rather-harrowing-on-Windows installation of a newer one
12:22:32 <Gurkenglas> Looks like the current online haskell platform version is newer than the one I have downloaded. Should I regularly reinstall that or should that handle itself by default?
12:22:43 <geekosaur> it does not include an upgrader, no
12:22:51 <Cale> getlernd: Well, then the (*) function is applied to 3 and 5... to say how it gets 15 as the result then, we'd have to look at the internal implementation of integer values
12:22:51 <geekosaur> not sure I'd jump to a newer one just yet, though
12:23:15 <geekosaur> ghc 7.10.2 is due out shortly and a new Platform should follow within a week
12:23:21 <Jello_Raptor> hmm, is there a monad for computations that are stateful and nondeterministic? it would be easy enough to write one around [(\sigma,v)] but it seems like I should be able to compose one with mtl (I'm not sure whether that would be "ListT (StateT \sigma v)" or vice versa) 
12:23:24 <mmachenry> I am trying to use resourceT and async together to prevent zombie processes but I've introduced a space leak. Is anyone interested in suggesting a good solution?
12:23:32 <mmachenry> http://lpaste.net/134982
12:23:34 <Gurkenglas> Does it matter? The download takes about 10 minutes, its not that bad...
12:24:01 <simon> @pl (\xs x -> return $ f x : xs)
12:24:01 <lambdabot> (return .) . flip ((:) . f)
12:24:31 <getlernd> Is (*) an exception to the rule that every function takes one argument?
12:24:31 <Cale> getlernd: But ultimately, it ends up using a CPU instruction which does multiplication of integers.
12:24:48 <Cale> Well, (*) itself can be applied to one parameter.
12:24:50 <Jello_Raptor> hmm, "stateT (ListT m) s" should give me a computation where a single state is threaded through a bunch of nominally non-deterministic calls, no?
12:24:53 <geekosaur> getlernd, I think you misunderstood how that works
12:24:57 <simon> getlernd, (*) the operator?
12:25:01 <getlernd> Yeah
12:25:02 <simon> :t (* 5)
12:25:03 <lambdabot> Num a => a -> a
12:25:05 <Cale> getlernd: It just doesn't get any work done until it's applied to both
12:25:05 <geekosaur> you apply (*) to one argument and it returns a function which takes one argument
12:25:14 <arkeet> (*) :: Num a => a -> (a -> a)
12:25:16 <simon> :t (*) 5
12:25:16 <geekosaur> that function can be applied to get a final result
12:25:17 <lambdabot> Num a => a -> a
12:25:33 <Cale> > let timesFive = (*) 5 in timesFive 6
12:25:34 <jle`> Jello_Raptor: no, StateT (ListT m) s a is `s -> m [(a, s)]`
12:25:35 <lambdabot>  30
12:25:41 <simon> in Haskell, binary operators are just curried functions.
12:25:44 <jle`> Jello_Raptor: so every path has a different state
12:25:57 <hodapp> johnw: applicative descriptions of data formats, rather than reaching for TH or Generics
12:26:01 <geekosaur> you can even write the intermediate function yourself:   (5*) is the function resultiing from applying (*) to 5
12:26:03 <Cale> > ((*) 5) 6
12:26:04 <lambdabot>  30
12:26:15 <geekosaur> (can also be wtitten the way Cale just did)
12:26:47 <Denommus> getlernd: there are no exceptions
12:26:48 <jle`> > (5 *) 6
12:26:49 <lambdabot>  30
12:27:13 <Denommus> > (20 /) 4
12:27:15 <lambdabot>  5.0
12:27:17 <jle`> > let f = (5 *) in f 6
12:27:19 <lambdabot>  30
12:27:36 <geekosaur> once you learn how to use it, this "partial application" is very powerful
12:27:46 <Jello_Raptor> jle`: and the other way around is `s -> m ([a],s)`? why is that? shouldn't the innermost monad transformer transform Identity (or IO or whatever) first? 
12:27:46 <geekosaur> but it does require a shift in thinking
12:28:00 <jle`> Jello_Raptor: it's just newtype wrappers
12:28:11 <jle`> StateT s m a is a newtype wrapper around a -> m (a, s)
12:28:16 <jle`> er, s -> m (a, s)
12:28:20 <getlernd> I just don't understand how these examples are ultimately evaluated.
12:28:35 <jle`> Jello_Raptor: so just plug in the `m`
12:28:41 <Cale> getlernd: They're evaluated very much like how we've been doing it by hand
12:28:47 <jle`> ListT m a is `m [a]`
12:29:08 * hackagebot seqid 0.4.0 - Sequence ID production and consumption  http://hackage.haskell.org/package/seqid-0.4.0 (LukeHoersten)
12:29:09 <Jello_Raptor> jle`: and ListT is a newtype wrapper aound `a -> m [a]` so 
12:29:11 <Cale> getlernd: Of course, it's a graph of pointers in memory, but something analogous to the expressions we've been writing really does exist at runtime.
12:29:18 <Jello_Raptor> jle`: oh oops
12:29:22 <Jello_Raptor> jle`: but I see
12:29:46 <Cale> getlernd: and it's totally appropriate to imagine that it really is just successively rewriting the expressions one step at a time
12:29:53 <Peaker> Though ListT m a = m [a]   is a broken ListT
12:30:22 <Cale> (though what it does is orders of magnitude faster than that would be, it produces the same results)
12:30:49 <Jello_Raptor> Peaker: how so? 
12:30:51 <jle`> getlernd: (5 *) is a function that takes a number and multiplies it by five.  so (5 *) 6 is 30
12:30:56 <Cale> (\x -> (\y -> x^2 + y^2)) 2 3
12:31:01 <Denommus> getlernd: let foo = (*5) is the same thing as let foo x = x*5. That's it
12:31:06 <Cale> -> (\y -> 2^2 + y^2) 3
12:31:12 <Denommus> getlernd: or let foo = \x -> x*5
12:31:13 <Cale> -> 2^2 + 3^2
12:31:19 <Cale> -> 4 + 3^2
12:31:21 <Denommus> getlernd: I don't understand what you don't understand
12:31:25 <Cale> -> 4 + 9
12:31:39 <Cale> -> 13
12:31:40 <Peaker> Jello_Raptor: Monad transformers are supposed to allow *interleaving* of effects of the different monads.   The type `m [a]' requires all the "m" effects to happen, and then independently, later, all the list effects to happen
12:31:44 <MarcelineVQ> i think getlernd is stuck in a loop where, x*y*z = ((*x)*y)z  = x*y*z = ((*x)*y)z  = x*y*z = ((*x)*y)z  = x*y*z = ((*x)*y)z and is wondering where the computation happens instead of where building it up stops
12:31:59 <dolio> Jello_Raptor: ListT m isn't a monad for quite a few monads m.
12:32:06 <getlernd> Yes
12:32:09 <getlernd> What Marceline said.
12:32:18 <Peaker> Jello_Raptor: m [a]   is kinda like doing:  StateT s m a = m (s -> (a, s))   (which would be broken in a similar way)
12:33:00 <Cale> Well, ((*x)*y)z isn't syntactically valid...
12:33:43 <MarcelineVQ> idk, I'm just trying to clarify getlernd's issue
12:34:09 <Denommus> getlernd: the computation is lazy and is only performed when some strict part of the program is performed
12:34:10 * hackagebot seqid-streams 0.4.0 - Sequence ID IO-Streams  http://hackage.haskell.org/package/seqid-streams-0.4.0 (LukeHoersten)
12:34:12 <MarcelineVQ> Is it correct to say that when z is reached integer maths is done because the expression is constructed, no steps remain.
12:34:16 <Cale> I mean, there might be some kind of loop, but when one of the things in the loop is not even syntactically correct, I don't really understand...
12:34:39 <Cale> (*) ((*) x y) z is syntactically valid, and means exactly the same thing as x * y * z, the latter being syntax sugar for the former.
12:34:42 <MarcelineVQ> Cale it's a reasoning loop, not a programming one
12:34:45 <Denommus> getlernd: but if you really want to know, imagine the C function int sumTwo(int x) { return x+2; }
12:34:48 <Cale> MarcelineVQ: Even so
12:34:56 <Cale> MarcelineVQ: I realise that's what you mean
12:34:58 <Denommus> getlernd: where is it performed? Does it make sense to talk about it being performed?
12:35:24 <Cale> MarcelineVQ: But if the problem is that he's transforming a syntactically valid expression into one which isn't meaningful, well, yeah, that's a problem!
12:35:33 <Denommus> getlernd: let sumTwo = (+2) is the same thing. It is simply a synonym for let sumTwo = \x -> x+2 or let sumTwo x = x+2
12:35:34 <Peaker> dolio: you mean ListT m is not a monad for many `m`s, as opposed to "ListT done right" which is? Can you give an example?
12:36:03 <dolio> Peaker: ListT m is only a monad if m is a commutative monad.
12:36:12 <dolio> So, pick anything except, like, Identity.
12:36:31 <dolio> Or Maybe, perhaps.
12:36:35 <Cale> getlernd: Note that while (*) itself takes its arguments one at a time, this is not so relevant as long as we supply them all.
12:36:47 <Peaker> dolio: So ListT MaybeT isn't a Monad?
12:36:57 <Peaker> I mean, ListT Maybe
12:36:58 <johnw> dolio: I have a list of them here: https://github.com/basvandijk/monad-control/issues/28
12:37:04 <f00f00> Hi!
12:37:12 <alynn> Maybe is commutative isn't it?
12:37:12 <Cale> getlernd: The whole point here is that you can regard functions of multiple arguments, and functions which take one argument and produce another function which takes the rest, as being the very same thing.
12:37:19 <f00f00> is there anyone with experience in building a Haskell appplication with a database in the backend?
12:37:29 <dolio> Peaker: No, I think Maybe is commutative.
12:37:41 <johnw> Maybe is commutative unless you take ⊥ into account
12:37:45 <f00f00> I'm currently in the early phase of designing a product with potential commercial utility
12:37:50 <Peaker> dolio: Commutative in the sense of:  m . n   vs.  n . m  (TypeCompose) ?
12:37:54 <alynn> ListT (State a) isn't commutative
12:38:02 <f00f00> using a database from Haskell is a bit of a pain, though
12:38:08 <dolio> johnw: IO is not commutative.
12:38:18 <Gurkenglas> Do I need to delete any folders before using the Haskell Platform installer to update everything?
12:38:20 <Cale> Peaker: Commutative in the sense of do u <- x; v <- y; return (u,v) is the same as do v <- y; u <- x; return (u,v)
12:38:25 <f00f00> if anyone has some experience in that regard, which Haskell package/which SQL bindings did you use?
12:38:32 <getlernd> Okay. I think I need a break. Hopefully this will click for me soon. Thanks, everybody! I do feel that I'm closer to understanding. 
12:38:35 <Peaker> dolio: because  MaybeT (t m)   is different from   t (MaybeT m)
12:38:45 <Peaker> Cale: ah
12:38:59 <Cale> getlernd: If you figure out any good questions to clarify your understanding, let us know!
12:39:10 * hackagebot seqid 0.4.1 - Sequence ID production and consumption  http://hackage.haskell.org/package/seqid-0.4.1 (LukeHoersten)
12:39:17 <Cale> getlernd: Probably trying to evaluate things on paper by hand would be a good way to start getting comfortable
12:39:24 <johnw> http://blog.sigfpe.com/2006/11/why-isnt-listt-monad.html
12:39:28 <dolio> johnw: neither is ST. Not sure about STM, but that's unlikely, too.
12:39:34 <johnw> dolio: hmm
12:39:43 <Cale> getlernd: Like, do these step by step evaluations where you plug in one thing at a time
12:39:47 <Peaker> so ListT IO is not a Monad?
12:39:51 <dolio> Right.
12:39:56 <Cale> Peaker: for the ListT in mtl, right.
12:40:11 <zed_> Hello everyone : ) I am trying to find a way to do a for loop with a function while storing the results. E.g., let's say I have a function f(x) = x^2 and I want to store the results of evaluating the function from i = 0 to 10. How would I do that?
12:40:14 <Cale> mtl's ListT has been broken for ages.
12:40:30 <Cale> zed_: map f [0..10]
12:40:45 <johnw> dolio: if I have IO (IO a), does it make a difference if I 'flip' the two IO's?  Isn't the "environment" the same either way?
12:40:53 <Cale> zed_: Or [f i | i <- [0..10]]
12:40:54 <Peaker> I know ListT is broken, but I didn't know it was broken in this way, I am not sure I see why it is not a monad
12:41:03 <Cale> Peaker: Fails the associativity law.
12:41:10 <dolio> johnw: That's not what commutative means.
12:41:45 <zed_> Cale: Thanks ! :)
12:41:54 <johnw> I thought it meant that m (n a) and n (m a) were equivalent, in this context
12:41:58 <Cale> johnw: A monad is commutative when do u <- x; v <- y; return (u,v) is the same as do v <- y; u <- x; return (u,v)
12:42:04 <dolio> 'do _ <- writeIORef r 5 ; _ <- writeIORef r 6 ; ...' is not the same as 'do _ <- writeIORef r 6 ; _ <- writeIORef r 5 ; ...'
12:42:16 <johnw> thanks
12:42:33 <kuribas> Does the list in Data.Vector.fromList [1, 2, 3] get fused away?
12:42:45 <Cale> kuribas: No.
12:43:10 <kuribas> So how do you create a literal vector efficiently?
12:43:10 <Cale> kuribas: However, that's a constant, so it will be evaluated once and retained as long as the code is live.
12:43:26 <kuribas> Cale: unfortunaly it's not constant in my code.
12:43:28 <Cale> That should do just fine.
12:43:37 <Cale> Well, what does your actual code say?
12:43:46 <kuribas> like "fun a b c = Data.Vector.fromList [a, b, c]
12:44:11 <Cale> That's about the best you'll do for creating that Vector.
12:44:52 <Cale> at least, I wouldn't be concerned about it right away -- do you have some reason to be worried about the efficiency of that operation?
12:45:30 <kuribas> Cale: I am converting from "CubicBezier a b c d" to GenericBezier (Data.Vector.fromList [a, b, c, d])
12:45:52 <Cale> Well, that looks totally reasonable to me
12:46:04 <Cale> Is it performing poorly?
12:46:11 <kuribas> idk...
12:46:19 <Cale> Well, don't worry about it then.
12:46:45 <kuribas> It looks inefficient for numeric code...
12:47:00 <Cale> Profile first, ask questions later.
12:47:12 <kuribas> hm, okay.
12:47:50 <Cale> It might be the case that you could write some code involving create which GHC compiles better than it compiles that.
12:48:05 <Cale> But you shouldn't really worry about that before it's any kind of issue.
12:49:14 <Luke> geekosaur: hey I think I should file a bug about the lack of extra-include-dirs in cabal to match the extra-lib-dirs - you think that's appropriate?
12:49:32 <geekosaur> you can try
12:49:49 <Luke> or should I target this more towards HsOpenSSL?
12:49:58 <Luke> i don't think any change to the lib will do anything
12:50:13 <geekosaur> HsOpenSSL probably needs to be updated to support libressl at some point
12:50:42 <geekosaur> although, my understanding was libressl was supposed to be drop-in compatible so I have this feeling that there's an apple brick wall in the way in this case :/
12:51:13 <Luke> geekosaur: good point
12:51:25 <geekosaur> if you're lucky, this will turn out to be a temporary deficiency in the prerelease
12:53:16 <Luke> yeah
12:54:44 <Cale> kuribas: Yeah, if you're really concerned, the ugly but potentially slightly faster thing to do would be  create (do { v <- new 4; write v 0 a; write v 1 b; write v 2 c; write v 3 d; return v })
12:55:27 <kuribas> Cale: did you just test it?
12:55:34 <Cale> I didn't actually test it
12:55:37 <Luke> geekosaur: so we found 2 issues: the incomplete flags issue in cabal file and the openssl issue with apple changes. bugs have been filed for both. thanks again for your help
12:55:49 <Cale> I actually don't know whether it's faster or slower!
12:55:52 <geekosaur> np
12:55:56 <Cale> But it's something you might try
12:56:12 <kuribas> Cale: right, I'll compare the different methods.
12:56:41 <wricardo> > 1 + 1
12:56:43 <lambdabot>  2
13:00:25 <Cale> kuribas: I should note that while stream fusion has nothing to say about lists written like [a,b,c,d], with enough inlining and constructor specialisation, it's still possible that GHC compiles things like that to efficient code.
13:02:03 <Cale> kuribas: i.e. at compile time, it might inline the definition of fromList, see that it's definitely being applied to a cons, and do some reduction, and so on.
13:02:56 <kuribas> Cale: right.  I am doing some testing now...
13:08:06 <zed_> so... I tried to solve my problem by using map, but apparently it is not the function I want.
13:09:03 <zed_> To put it shortly, I want to integrate numerically a function that loops itself on some parameters.
13:09:12 <zed_> My line in haskell is now : map (integrateQAGI 1E-9 1000 (fonction_a_sommer Input)) [0..d]
13:11:55 <zed_> the whole code : http://lpaste.net/134989
13:12:17 <zed_> if anybody can chime in... : )
13:16:04 <simon> zed_, what problem do you have?
13:17:11 <zed_> simon: oh I forgot to post the error code. just added it.
13:17:24 <simon> zed_, you want main to have the type IO ().
13:17:36 <kuribas> Cale: crude testing indicates that that's quite a bit faster.
13:17:54 <albeit_> If I have [IO (Maybe a)], how can I run the computations in order, but stop running when I hit the first Just?
13:18:32 <johnw> sequence, and then mapMaybeM
13:18:40 <zed_> simon: why so? 
13:18:57 <ion> Won’t sequence result in all the computations being executed first?
13:19:08 <johnw> ah, sorry, right
13:19:12 <simon> zed_, it's just a convention. 'main' is the function that is run when the program is executed. it's expected to be an IO action.
13:19:45 <simon> zed_, like in C where main is more or less expected to be 'void main(int argc, char *argv[])', and Java's 'public static void main(String[] args)', etc.
13:19:55 <zed_> ah ok ok
13:19:56 <zed_> thanks
13:19:58 <simon> zed_, http://lpaste.net/134989
13:20:46 <ion> @type let go (io:ios) = io >>= \case { Nothing -> go ios; Just _ -> pure () }; go [] = pure () in go
13:20:47 <lambdabot> parse error: naked lambda expression ''
13:20:52 <simon> whoops... zed_, http://lpaste.net/134989
13:21:09 <ion> @type putStrLn
13:21:10 <lambdabot> String -> IO ()
13:21:11 <ion> @type print
13:21:12 <lambdabot> Show a => a -> IO ()
13:21:20 <albeit_> ion: So nothing built in, jsut do a simple recursion like you outlined?
13:21:46 <simon> zed_, oh, by the way... I didn't know that I was editing your original post.
13:21:59 <johnw> albeit_: I think: foldM (\acc x -> case acc of Just y -> return (Just y); Nothing -> x) Nothing xs
13:22:17 <johnw> however, this will still not work for an infinite list
13:22:30 <johnw> for that, you'll need to use EitherT
13:22:59 <albeit_> No infiniti lists here. Thanks!
13:23:07 <jle`> albeit_: maybe findM isNothing ?
13:23:14 <jle`> er, findM isJust?
13:23:14 <Luke> anyone from the haskell committee around?
13:23:19 <johnw> Luke: yes
13:23:22 <Luke> oh nice
13:23:28 <Luke> i didn't know you were on the committee
13:23:32 <Luke> can I PM you?
13:23:36 <johnw> sure
13:24:25 <albeit_> jle`: There's even firstJustM in Extra, which is perfect
13:25:09 <zed_> simon: thanks. it solved the main problem, but it doesn't solve my main problem ; )
13:25:30 <ion> runExceptT . traverse_ (ExceptT . fmap (maybe (Right ()) (const (Left ()))))
13:25:31 <simon> zed_, ok :) I'm not sure what that is.
13:25:41 <jle`> albeit_: i think you might be able to use asum on MaybeT, as well
13:25:47 <zed_> well it's about how to use map on a function on  function, instead of using map on a function
13:25:55 <jle`> :t F.asum . map MaybeT
13:25:56 <lambdabot> Monad m => [m (Maybe a)] -> MaybeT m a
13:26:05 <jle`> :t runMaybeT . F.asum . map MaybeT
13:26:05 <zed_> simon:  if that made any sense !
13:26:06 <lambdabot> Monad m => [m (Maybe a)] -> m (Maybe a)
13:26:19 <jle`> :D
13:26:46 <jle`> then you don't have to rely on obscure utility libraries, heh
13:27:05 <jle`> also you're basically doing m1 <|> m2 <|> m3 <|> m4 ..., which is conceptually nice i think...
13:27:52 <jle`> MaybeT is just a newtype wrapper so this basically is coerce . asum . coerce, or `runMaybeT . asum . coerce`...if only newtypes weren't so noisy
13:28:11 <jle`> or we could have parameterized instances in a nice way or something idk
13:29:29 <zed_> simon: herE's the new code and the new error : http://lpaste.net/134992. i think that the main errors are given by "    Possible cause: ‘map’ is applied to too many arguments " and "    Probable cause: ‘fonction_a_sommer’ is applied to too few arguments ". and I think that it stems from a misuse of map....
13:30:07 <ion> Nice, runMaybeT . asum . fmap MaybeT stops on the first Just, runMaybeT . traverse_ MaybeT stops on the first Nothing.
13:31:01 <jle`> which would just be asum/msum and sequence_ if not for the newtype wrappers.  i guess we can live with it
13:31:46 <geekosaur> zed_, you have several problems
13:32:10 <cj3kim> hi, do lists have indexes in haskell?
13:32:11 <geekosaur> the first is fairly simple: foo produces (Double,Double) but you are feeding that to putStrLn, which expects a String
13:32:22 <cj3kim> or will i need to zip a list to a range ie [0..n] 
13:32:34 <cj3kim> in order to a list with indexes
13:32:38 <ion> cj3kim: You can just zip with [0..]
13:32:48 <jle`> cj3kim: lists don't have built in indexes, so zipping with [0..] is a preferred way usually
13:32:53 <geekosaur> the second is more involved, and part of the problem is you need some extra parentheses
13:33:12 <zed_> geekosaur: awww i knoow
13:33:22 <geekosaur> because (sum . map (function here) [list here]) does not mean what you think it does
13:33:26 <ion> > "hello" ^@.. folded
13:33:27 <lambdabot>  [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
13:33:42 <cj3kim> and, this will be optimal because haskell will interleave the range generation and zipping operations, correct?
13:33:51 <zed_> geekosaur: what does it means?
13:33:56 <mmachenry> Anyone want to talk about proper management of threads? What strategy is best if I have an infinite loop that spawns threads that will eventually complete on their own?
13:34:01 <geekosaur> what you actually intended is more like: ((sum . map (function here)) [list here]
13:34:15 <agocorona> maybeT is too complicated. it is supposed to ease things but at the end is it does not
13:34:17 <zed_> geekosaur: i don't think so
13:34:21 <geekosaur> I do
13:34:31 <jle`> agocorona: i don't know, i've had a lot of usages for it
13:34:32 <geekosaur> because what you wrote has the type of a *function*
13:34:35 <geekosaur> not of a value
13:34:39 <geekosaur> scalar value
13:34:42 <mmachenry> I want to make sure that if the parent crashes the childern are cleaned up
13:34:43 <jle`> all it is is a newtype wrapper
13:34:51 <Peaker> agocorona: if you throw a runMaybeT at the end, a "lift" on one or two things, then having the ability to early-exit that way is nice
13:35:04 <zed_> geekosaur: well then I am really confused.
13:35:18 <agocorona> jle: as you said, it is too noisy
13:35:22 <jle`> so as long as you remember to wrap where you need to, MaybeT m reads just like m code, except with built in early exiting and new semantics
13:35:30 <ion> zed: sum (map f xs) = (sum . map f) xs ≠ sum . map f xs
13:35:36 <geekosaur> foo input@(Input d p rho) = sum . map (integrateQAGI 1E-9 1000 $ fonction_a_sommer input) [0..d]
13:35:36 <jle`> agocorona: it's a bit noisy for short examples, but for bigger things, it becomes more useful
13:35:52 <jle`> for the shorter examples though it's nice to really see that you're "really doing an `asum`", or "really doing a `traverse`"
13:35:59 <geekosaur> what ion just said
13:36:28 <jle`> i think being able to go, "oh, i'm just doing an msum", "oh, i'm just doing a sequence" is something that makes code more readable or understandable or meaningful
13:36:39 <geekosaur> (.) combines functions, as weitten, what you have expects (foo input@(Input d p rho) = sum . map (integrateQAGI 1E-9 1000 $ fonction_a_sommer input) [0..d]) to be a function that can be applied to a value
13:36:46 <ion> zed: More generally, f (g x) = (f . g) x  {- by definition of (.) -}  ≠ f . g x
13:36:50 <geekosaur> whoops, wait, paste fail
13:37:01 <jle`> instead of writing out a function wiht manual recursion...then you have to stare at it to really knwo what's going on
13:37:17 <zed_> ion: oh now I see. thanks
13:37:22 <Gurkenglas> Reinstalled Haskell Platform. Now: http://pastebin.com/dVTUub5e
13:37:24 <geekosaur> what you wrote expects (map (integrateQAGI 1E-9 1000 $ fonction_a_sommer input) [0..d]) to be a function that can be applied to a value
13:37:32 <zed_> geekosaur: thanks.
13:37:33 <jle`> nobody wants to stare at an awkward explicit recursion function, or a function from an obscure utility library nobody uses....just to know, "oh, this is just an asum."
13:37:42 <agocorona> Working with monad transformers I think sometimes like if we are playing with the assembly language of a very high level language that no one has discovered yet.
13:38:02 <bitemyapp> agocorona: mtl?
13:38:18 <bitemyapp> agocorona: Zoom + mtl?
13:38:19 <agocorona> mtl is the assembly language
13:38:20 <jle`> i think it definitely depends on the use case we're talkinga bout...
13:38:37 <bitemyapp> I'd say concrete stacks are the assembler
13:38:42 <geekosaur> Gurkenglas, network thinks it is on unix, probably because you are using cygwin
13:38:50 <bitemyapp> mtl seems a substantial improvement over that.
13:38:50 <jle`> but really, the alternative in this case is to write a messy explicit recursion that will take a while for anyone reading it to understand...or to use an obscure utility library that you would have to look up...
13:38:59 <geekosaur> but sys/uio.h is not something that could ever exist on a Windows system, cygwin or no
13:39:00 <reindeernix> I'm surprised how decent color highlighting Vim has OOTB for Haskell, it might just be Haskell that uses some generic keywords
13:39:07 <jle`> when really you just want to say, "this is an asum", or "this is a traverse"
13:39:14 <Gurkenglas> I'm using powershell afaik, but that may be just a matter of names
13:39:34 <jle`> the meaning is instantaneously seeable and now the reader has all of the intuition they've gained from traverse and <|>, etc.
13:40:02 <Gurkenglas> But I shall download this mingw thing you mentioned earlier
13:40:24 <geekosaur> it's not a matter of names, just levels. judging by your earlier error, you are running programs built under cygwin (the fact that you are running them from powershell is not relevant). cygwin pretends to be unix, so the network package tries to build assuming unix
13:40:53 <geekosaur> but cygwin's unix emulation goes only so far, and sys/uio.h is beyond its capabilities
13:41:35 <geekosaur> I an mot sure why your haskell platform is using cygwin, though... the standard one expects mingw
13:41:41 <Luke> edwardk: ping
13:42:02 <jle`> agocorona: MaybeT itself is not really that complicated here at all...it's a bit like line noise, but in the end you get something instnatly readable and understandable for what it "really is", instead of hiding behind explicit recursion or functions nobody knows about
13:42:13 <geekosaur> which is a different environment (it provides some unix-like tools but does not try to make the system look like a unix system, which is what is tripping up the network package)
13:42:13 <Gurkenglas> I used the 64 bit one from https://www.haskell.org/platform/windows.html
13:42:29 <jle`> unless you mean "complex" as "verbose"
13:42:48 <Gurkenglas> It may be of note that even after I deleted the %appdata%/cabal and Program Files/Haskell Platform/<oldversion> folders, the installer warned me that I already had a Haskell Platform installed
13:43:00 <johnw> I agree with jle`
13:43:09 <johnw> asum . map MaybeT is pretty clear
13:43:10 <geekosaur> unfortunately, (a) I don't know how your system is set up, (b) I don't really know Windows well enough to help untangle it anyway :/
13:43:18 <agocorona> jle: I think that there are better ways to do the same effect if only people stop playing with monad transformers and develop some standard stack
13:43:22 <edwardk> Luke: pong
13:43:51 <Peaker> agocorona: as in a standard monad one-size-fits-all?
13:44:09 <agocorona> almost that, yes
13:44:21 <jle`> that might be a bit overkill here...
13:44:21 <Luke> edwardk: pm
13:44:30 <geekosaur> I *think* what you want to do is make sure cygwin stuff is not in %PATH% and then install https://github.com/fpco/minghc
13:44:33 <jle`> all you're doing is saying, "this is asum, but on MaybeT."
13:44:46 <Gurkenglas> More ultimately, I'm trying to run this: http://lpaste.net/134997
13:44:50 <Peaker> agocorona: that doesn't sound like a good idea at all
13:45:02 <Gurkenglas> Can someone show me the way?
13:45:11 <zed_> geekosaur: and now your corrections (and ion's) allowed me to reach the main issue : http://lpaste.net/134995
13:45:22 <jle`> that's like saying, "let's not use Sum, Product, Any, All, First, Last, Endo...let's just use one big one-size-fits all Monoid wrapper"
13:45:31 <Gurkenglas> (I replaced System by System.Environment in that after ghc complained about deprecation.)
13:45:43 <agocorona> then early termination can be jus a primitive of the monad: stop for example, instead of some low level thing
13:45:46 <jle`> > foldMap First [Nothing, Just 10, Nothing, Just 3, Just 10]
13:45:48 <lambdabot>  First {getFirst = Just 10}
13:46:30 <jle`> why look for a general one-size-fits all Monoid wrapper...using First, Last, Sum, Product, etc., seems like it's much mor clear
13:46:39 <agocorona> I think that this is a very good idea for many people that neither know nor has to know all these subtleties of monad transformers
13:46:49 <jle`> > foldMap Last [Nothing, Just 10, Nothing, Just 3, Just 8]
13:46:50 <lambdabot>  Last {getLast = Just 8}
13:47:07 <jle`> yeah, but we aren't using "monad transformers in general" here, so there's no subtleties to learn
13:47:10 <jle`> we're just using MaybeT
13:47:32 <jle`> there aren't really any subtleties to understand when working with Maybet
13:47:35 <jle`> *MaybeT
13:47:38 <johnw> agocorona: but we *like* composition, rather than folding all functionality into one thing
13:47:53 <geekosaur> zed_, try: ( sum . map (integrateQAGI 1E-9 1000 . fonction_a_sommer input))
13:48:07 <agocorona> I think that people that want haskell to program an ERP should not have to know about category theory 
13:48:12 <jle`> here it's like using the foldMap Last [Nothing, Just 10, Nothing ...] example.  you don't need to understand the subtleties of monoids
13:48:19 <jle`> you just need to know how Last works
13:48:31 <agocorona> johnw:  you like composition because it is in the tradition of haskell.
13:48:33 <jle`> there's really no category theory involved in MaybeT
13:48:42 <ion> My troll sense is tingling.
13:48:54 <agocorona> in fact it is not composition, because the monad transformers don't compose well
13:49:17 <jle`> we aren't talking about monad transformer composition here, unless we changed the subject...this was just about MaybeT
13:49:25 <maerwald> ion: I think you are over-sensitive
13:49:54 <agocorona> jle`:  it is a monad transformer....
13:49:55 <jle`> MaybeT isn't deeply linked to monad transformers and the theory of monad transformers and the subtleties of monad transformers
13:50:09 <jle`> yeah, but that's like saying you have to teach a 1st grader about group theory before tteaching them to add 1 + 2
13:50:29 <jle`> and saying, "numbers are too complicated! i shouldn't need to know gorup theory to add! there must be another way..."
13:50:33 <bitemyapp> one of the main thrusts of the work I have been doing
13:50:44 <bitemyapp> is that human beings do not, as a rule, work from abstractions to concretions.
13:50:46 <geekosaur> zed_, or if you want some clarity as to what is actually going on: ( sum . map (\x -> integrateQAGI 1E-9 1000 (fonction_a_sommer input x))
13:50:48 <agocorona> jle`:  unfortunately that is the impression of many people about haskell
13:50:49 <jle`> "we shouldn't teach kids 1 + 2, or numbers...group theory is too complicated.  we need to find a new way."
13:50:52 <bitemyapp> they start with concrete examples and then learn to generalize them.
13:51:04 <zed_> geekosaur: thanks, it worked : )
13:51:04 <jle`> what is the impression?
13:51:07 <bitemyapp> linguistics is a really good example of this.
13:51:26 <jle`> in this situation here, we're not talking about group theory, we're just talking about numbers
13:51:42 <jle`> are you going to walk into a 1st grade classroom and say, "stop teaching numbers!  we need to find a better way!"
13:51:44 <jle`> :)
13:52:05 <jle`> we're just using MaybeT here, as just a plain ol' newtype wrapper to add a new instnace
13:52:12 <bitemyapp> is there a category theoretic explanation for why we often have more possible applicative instances than either Functor or Monad? Is it the Monoid?
13:52:19 <jle`> we don't need to involve anything about monad transformers, or category theory, or...whatever you're trying to inject into this
13:52:37 <agocorona> people understand with examples, not with theory
13:52:45 <jle`> exactly
13:52:48 <jle`> there's no theory involved here...
13:53:05 <jle`> just a concrete example.  you don't need to learn about monad transformer theory or category theory or anyhting to use MaybeT...
13:53:12 <maerwald> jle`: I agree with you. A lot of idioms in haskell are very difficult to understand in terms of "why exactly is this happening?". But most of the time you don't need to know the "why" if you just want to reuse the idiom.
13:53:16 <jle`> just like you don't have to know about group theory, ring theory, real analysis, etc. to use numbers
13:53:43 <agocorona> jle`: I think that my  point is simple to understand
13:54:04 <jle`> when you use MaybeT to find the first Just element, and you say that monad transformers is too complicated, that's like seeing a 1st grader try to add one apple and two apples to get three apples, and someone coming in and saying, "groups are too complicated.  surely there must be a better way than addition."
13:54:27 <jle`> we're not talking about monad transformer theory, or category theory, here...
13:54:32 <jle`> we're just doing something simple with a newtype wrapper
13:54:45 <jle`> a 1st grader doesn't care about group theory or real analysis, they just want to count apples...
13:55:06 <jle`> nothing here involves monad transformer theory or category theory or anything complex
13:55:09 <agocorona> it is not true that to do IO in Haskell is necessary to have a Phd in Mathematics. It is NOT true. However many people think so. WHY it is so is something that the Haskell community have to think about SERIOUSLY
13:55:17 <bitemyapp> jle`: you're spinning a bit.
13:55:29 <bitemyapp> jle`: and widening the front, try to focus in and keep the scope small.
13:55:53 <ion> jle: Good analogy.
13:55:57 <agocorona> That is my point and I think that this is easy to understand
13:56:13 <dolio> Why does the community have to think about it?
13:56:14 <Peaker> agocorona: A) the mixed crowds (academic part) leaks into tutorials/search results B) because of the terminology C) it is truly more difficult because more convincing of the compiler is needed, in exchange for more invariant verification power
13:56:18 <jle`> agocorona: ah, okay, if that's your point then i think i can see that there is a problem with haskell and how people teach it
13:56:43 <jle`> agocorona: it was just that we were talking about something completely unrelated to that before, heh
13:57:22 <agocorona> jle: they are al related aspects of the big picture
13:57:29 <MarcelineVQ> My main issue with haskell/fp is the lack of concrete, easy/layman to explain, examples of why it's so good.
13:57:37 <rofer> So, I have package A which contains a library and a couple of example executables which build and run fine. Package B depends on package A and contains an exact copy of one of those executables, however it refuses to link. Any idea what could be going on?
13:57:44 <MarcelineVQ> There's lots of here's why it's good, but not a lot of here's why it's good for you.
13:58:48 <maerwald> agocorona: that's simply an effort of didactics... it just happens that haskell is not as easy to teach as other languages that rely less on complicated concepts (but also lack the power of those concepts)
13:59:46 <maerwald> I've seen people teach monads without ever saying a word about functors or applicatives
13:59:58 <maerwald> no one did understand it
14:00:07 <jle`> i'm not sure how that comes from "MaybeT is too complicated", where MaybeT is a perfect example of something that's very simple and clear to use and doesn't involve any theory or anything and has lots of concrete examples.  but if we're going to talk about how haskell is taught in general and ways we can fix it then that's ok too :)
14:00:23 <maerwald> (or even monoids)
14:00:42 <MarcelineVQ> I just meant in terms of general learning resources
14:01:01 <Cale> You also don't need to understand monads to understand how to use IO in Haskell.
14:01:03 <zed_> geekosaur: lastly for now... regarding the use of sum. integrateQAGI returns a (Double,Double). so I am basically asking to compute ( sum [(1,2),(2,3)] ). which doesn't work. how can i work around this ?
14:01:11 <agocorona> jle'   there are simpler ways of doing what maybeT does
14:01:15 <maerwald> Cale: exactly
14:01:18 <Cale> I think we're doing people a disservice when we say "IO monad"
14:01:19 <breadmonster> Cale: Is there an applicative interface to IO?
14:01:30 <Cale> breadmonster: Yes, every monad is also an applicative.
14:01:36 <ion> zed: What do you want to compute out of [(1,2),(2,3)]?
14:01:44 <Cale> breadmonster: But that's not even my point :)
14:01:45 <breadmonster> Cale: Sure, but can you do useful things with it?
14:02:00 <breadmonster> ie. can you do stuff equivalent to the do notation?
14:02:08 <Cale> breadmonster: My point is that you don't have to understand the abstraction generally to be able to use the things it gives you in the specific case of IO.
14:02:09 <ion> putStrLn "beginning" *> someComputation <* putStrLn "finished"
14:02:20 <ion> (+) <$> readLn <*> readLn
14:02:21 <Cale> You don't need to understand monads to use do-notation to write IO actions.
14:02:24 <breadmonster> ion: Keyboard input?
14:02:32 <maerwald> breadmonster: quote from stackoverflow: The Applicative interface allows the  "result" control flow to be dynamic, but it requires the "effect"  control flow to be static.
14:02:46 <geekosaur> zed_, I can't answer that because I'm not sure what you are trying to accomplish
14:02:53 <maerwald> so it is quite different from the monad interface
14:02:57 <breadmonster> maerwald: Over my head, but thanks!
14:03:08 <maerwald> breadmonster: https://stackoverflow.com/questions/17409260/what-advantage-does-monad-give-us-over-an-applicative and https://stackoverflow.com/questions/23342184/difference-between-monad-and-applicative-in-haskell
14:03:11 <geekosaur> it's not surprising that that fails, but I don't see what you intended it to do
14:03:12 <jle`> agocorona: it definitely depends on the application you're talking about, and where, and when, etc..  but in the situations where MaybeT is the cleanest and simplest way, it works well :)  there are situations where it's very very good, and situations where it might not be.  but in all of these situations, it's simple and understandable
14:03:29 <Cale> breadmonster: and indeed, the best way to understand what the Monad interface is about is to first learn and understand a bunch of examples of monads.
14:03:39 <zed_> geekosaur: do you prefer an explanation or the orignal code or both ?
14:03:43 <jle`> of course i can construct a contrived example where MaybeT doesn't help, but in many cases MaybeT ends up being the cleanest, simplest, and easiest to understand way
14:03:43 <ion> breadmonster: readLn takes a line from stdin, yeah. It parses it according to a Read instance.
14:03:44 <dmj`> maerwald: yea, and typeclasses are a bit unique too, when comparing haskell to other langs, Monad is just a typeclass, studying the instances of Monad for common data types will grow intuition, then later you can go and reason about how each one upholds the Monad laws
14:04:08 <Cale> breadmonster: and then it's just obvious what all those things have in common, once you have all the examples -- and it's not really all that much even.
14:04:09 <jle`> it all depends on the situation, and it's a bit funny to just throw out an entire tool just becuase there's one situation where it might not be useful
14:04:11 <albeit_> Is it possible to give cabal paths in the project directory to search in for a package before looking in the sandbox package dirctory?
14:04:13 * hackagebot scotty 0.10.1 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.10.1 (ryanglscott)
14:04:14 <maerwald> breadmonster: one point is... you cannot resemble ifM with the applicative interface, although you can write something that is _similar_, but does something very different in a few cases. Examples are in the links
14:04:25 <jle`> should i throw out my hammer if i know one day i might have to use a screwdriver?
14:04:37 <Cale> The fact that IO is a monad is much less important than the fact that there is a type of IO actions and operations for gluing those actions together.
14:04:54 <Cale> Those operations *happen* to include the stuff you need to make IO a monad.
14:05:09 <Cale> But it's not really a big deal, and it's not even the better part of understanding how to do IO.
14:05:19 <maerwald> dmj`: yeah, but before you can write useful monad instances yourself, you really need to get a more abstract understanding of monads IMO
14:05:33 <geekosaur> zed_, probably both
14:06:01 <maerwald> dmj`: I mean... to understand what does monad give you as a "design pattern"
14:06:36 <maerwald> and I feel the majority of tutorials and lecture really do not explain that
14:06:45 <Cale> IO also includes lots of other stuff, like exceptions, and threads, and many different sorts of mutable cells and data structures, and stuff dealing with Handles, and on and on.
14:06:53 <Cale> and none of that has anything to do with monads.
14:07:39 <zed_> geekosaur: ok. so the code : http://lpaste.net/134999 (bear with me, it was amongst my first works in C )
14:07:54 <maerwald> but those are all just didactics problems
14:08:12 <maerwald> I don't see that as a language problem
14:08:17 <agocorona> the monad of IO does the sequencing effect. Is that better?
14:08:19 <lleksah15> hi everyone. I am a Haskell novice and I have a question about Aeson. I am trying to construct FromJSON instance and I would like to set a default value 'even if' the JSON input contains a value. I know there is a way to set default values when the field is missing. I tried tricking .!= but couldn't figure out how to get a Parser to pass it to the function.  
14:08:24 <cj3kim> hi can we use if else statements in list comprehensions? 
14:08:32 <geekosaur> thankfully my first C code is no longer online (although I got a pretty good scare when I found out someone was still using a descendant of it a few years ago!) :)
14:08:41 <Cale> To say that IO is a monad is just to say that there's a way to do nothing and produce a result (return), and given some initial action, and a function which explains what to do next based on the result of the first thing, there's a way to get an action which combines those two parts in the obvious way (>>=), and that's all.
14:08:56 <zed_> geekosaur: the big picture explanation is that I want to calculate a VaR and an expected shortfall. it's financial engineering.
14:09:05 <albeit_> Is it possible to do something like "import /path/to/Package/PackageFile.hs"?
14:09:10 <ion> cj3kim: Yes, you can use any expression with the right type.
14:09:12 <Cale> cj3kim: You can.
14:09:23 <agocorona> in the same way the state monad does the transport-extra-parameter effect. not the state effect
14:09:34 <Cale> cj3kim: if/then/else is not a statement form though, it's an expression form.
14:10:03 <maerwald> list comprehensions are boring, use the list monad :P
14:10:07 <zed_> geekosaur: so i am basically integrate a function and summing its results, up until i reach a certain quantile. then i stop. i sum the rest of the results in order to calculate the expected shortfall.
14:10:21 <hexagoxel> albeit_: are you looking for a more automated version of add-source?
14:11:14 <albeit_> hexagoxel: I don't think so... what's the difference between using add-source and hs-source-dirs?
14:11:15 <zed_> geekosaur: in fact, if we come back to the (Double,Double) result of integrateQAGI in haskell, I don't need the second Double... I would be OK with summing just the first one.
14:11:20 <cj3kim> thanks!
14:11:26 <geekosaur> hm. the main problem with the C code is I'm not familiar with gsl :/
14:11:27 <zed_> geekosaur: does any of this makes sense? : )
14:11:29 <ion> zed: sum . map fst?
14:11:32 <hexagoxel> albeit_: if yes, the answer is "currently no", but see the recent "Multi-library/package support for cabal" post on the cabal-devel mailing list (sorry just upgrading my browser, so no link for you :p)
14:11:33 <geekosaur> ^
14:11:48 <zed_> geekosaur: yeah it's the main reason why it's troublesome for me to get help ahah
14:12:03 <geekosaur> if you just want the first part of the result, you can chain fst onto your map
14:12:06 <geekosaur> hm...
14:13:03 <hexagoxel> albeit_: sandbox add-source is for packages, hs-source-dirs for locating single modules
14:13:21 <zed_> the thing is, the action of gsl_integration_qagi is not that complicated. it integrate F over -inf, +inf, and stores the result in result
14:13:26 <geekosaur> zed_, ( sum . map (fst . integrateQAGI 1E-9 1000 . fonction_a_sommer input))
14:15:03 <lleksah15> can someone suggest how I can forcefully set a default value when parsing JSON? For example
14:15:21 <lleksah15>      parseJSON (Object v) = Person <$> v .: "name" <*> v .: "age"
14:15:52 <lleksah15> In the parseJSON function I would like to set age to 21 regardless of whether it was present int he JSON
14:16:06 <zed_> geekosaur: trying to work with it, but it gives me an error
14:16:25 <ion> lleksah15: See “Constructors and accessors” in http://hackage.haskell.org/package/aeson-0.9.0.1/docs/Data-Aeson.html
14:16:43 <Cale> lleksah15: use <|>
14:16:52 <albeit_> hexagoxel: So if I'm making modifications to a package I git cloned, I should clone it into a separate directory, add add that directory with add-source, then re-install the package?
14:17:21 <Cale> oh, Aeson already provides a way to say that more succinctly
14:17:27 <Gurkenglas> When trying to install the gf package, I get: http://pastebin.com/dVTUub5e . What do I do?
14:17:49 <Cale> lleksah15: Well, you could write ((v .: "name") <|> return "Bob")
14:18:14 <hexagoxel> albeit_: yes; subdirectory should work as well; and if you are lucky the re-install happens automatically when you build your main package
14:18:32 <Cale> lleksah15: But there are some fancy operator shenanigans that Aeson provides you to do the same
14:18:40 <ion> Namely, (v .:? "name" .!= "Bob")
14:18:58 <Gurkenglas> Here's the referenced C:\Users\Gurkenglas\AppData\Roaming\cabal\logs\network-2.5.0.0.log : http://pastebin.com/HsXLCFHk
14:19:09 <hexagoxel> albeit_: but i think the auto-reinstall is unreliable, especially when you git checkout between versions
14:19:30 <lleksah15> Cale, ion. Thanks. Those seem to return if the parser fails. I would like to set to a default value even if it is present. Does that make sense? 
14:19:35 <Cale> Gurkenglas: Is cygwin supposed to work?
14:19:51 <Gurkenglas> I'm not sure what cygwin is, though it rings a bell.
14:19:53 <Cale> lleksah15: no?
14:19:57 <Cale> lleksah15: What do you mean?
14:20:11 <Cale> lleksah15: You just want to ignore whatever value is present?
14:20:13 <albeit_> hexagoxel: Can I just put it in the main project directory and add the package path to hs-source-dirs? I assume when I make changes to that package it would re-compile it?
14:20:19 <ion> lleksah15: Do you mean replacing v .: name with pure "Bob"?
14:20:20 <Gurkenglas> I think I've heard of it in the context of using it to run vms of very old machines on new ones...
14:20:45 <Cale> Gurkenglas: It's the thing you appear to be using.
14:20:50 <Jello_Raptor> does anyone here know how well ether (https://int-index.github.io/ether/) will work with Control.Lens? 
14:20:51 <geekosaur> Gurkenglas, cygwin is unix emulation for windows
14:20:54 <lleksah15> Yes Cale / ion (btw, what's the command to respond to a specific user -- sorry new to IRC)
14:21:08 <geekosaur> most often haskell is used with mingw, which is unixy tools for windows
14:21:10 <lleksah15> yes, ignore the incoming JSON and just assign a different one. 
14:21:20 <geekosaur> but it can be, with some pain, used with cygwin instead to get the unixy tools
14:21:22 <Gurkenglas> I don't remember setting anything of the like up.
14:21:37 <edwardk> Jello_Raptor: well, i'm guessing it won't work with 'zoom' and 'magnify' and the like.
14:21:40 <geekosaur> the problem is that cygwin confuses the heck out of packages that try to adapt to unix vs. windows (like network), and they pick the wrong one
14:21:58 <reindeernix> are nested guards frowned upon?
14:22:22 <Cale> reindeernix: I don't think so, but what do you mean?
14:22:23 <crough> reindeerni: Is there a better way to break down a function?
14:22:38 <geekosaur> lleksah15, just use the nicks, no prefix or whatever needed
14:22:43 <Gurkenglas> How do I tell what unix emulation I'm using? (I'm guessing from your lines that I must be using one.)
14:22:46 <crough> reindeerni: If there's two conditionals, there probably is a better way :)
14:22:58 <reindeernix> Cale, putting guards inside guards and crough I think you are right
14:23:00 <breadmonster> crough: How do you nested guard?
14:23:07 <Cale> Gurkenglas: Well, I'm seeing lots of "cygwin warning" in your output there
14:23:14 <crough> breadmonst: I dont
14:23:17 <lleksah15> Thanks, geekosaur
14:23:23 <geekosaur> you already know because you are getting errors that mention cygwin ("cygwin warning")
14:23:41 <reindeernix> I don't think it would be a god thing to do nested guards since it would make the code less readable
14:23:51 <hexagoxel> albeit_: uhh if you take into account the hs-source-paths that the other package defines (and update them should they change), i guess that should work
14:24:09 <geekosaur> which means you have unix-compatible tools from cygwin somewhere on %PATH%
14:24:11 <hexagoxel> albeit_: admittedly they won't ever change probably
14:24:13 <Cale> reindeernix: But how do you mean? With a case expression?
14:24:14 * hackagebot socket 0.5.1.0 - A portable and extensible sockets library.  http://hackage.haskell.org/package/socket-0.5.1.0 (LarsPetersen)
14:24:19 <geekosaur> so: echo %PATH%
14:24:37 <Cale> reindeernix: Can you give an example?
14:24:51 <hexagoxel> albeit_: but be aware that you lose any configuration (like the extensions used) defined in the other project
14:24:58 <reindeernix> Cale, not sure if it's possible but I will cook up an example
14:25:19 <lleksah15> ion, correct I would like to replace v .: "name" with pure "Bob". I don't want to look for a non-existent property like "assfff", fail and then replace as it is not very safe as it can be gamed. Ideally I would like to replace the attribute with a pure value
14:25:19 <geekosaur> zed_, what error? maybe update your earlier paste with current code and full error(s)?
14:25:23 <Gurkenglas> I don't know whether that log file is getting its warnings from cygwin, or another program complaining about there being no cygwin. I'm deliberately not jumping to conclusions because I expect to go wrong more than 10% of the time, and then spend time finding my mistake
14:25:44 <Cale> lleksah15: then just do that?
14:25:47 <Jello_Raptor> edwardk: hmm, good to know, I suppose I'll have to be careful about exatcly which portions of both libraries I import, and how i use them. Thanks,
14:26:00 <Cale> lleksah15: You don't have to use the .: parser
14:26:16 <lleksah15> Cale, I was struggling with the operators and i just occured to me I can just use <*> pure "bob" 
14:26:26 <Cale> ah
14:26:28 <Cale> :)
14:26:50 <lleksah15> Cale, ion: thanks for you help. Off to  other errors. 
14:27:03 <zed_> geekosaur:  well I found a way to do what I want - thanks though  :)
14:27:19 <hexagoxel> albeit_: e.g. when the other package defines some special `ghc-options`, and you use your own, stuff might break
14:27:35 <albeit_> hexagoxel: Going to use your original suggestion and add-source ;) If it doesn't re-install it automatically, do I just do a cabal reinstall on that package?
14:27:38 <reindeernix> Cale, http://lpaste.net/135002
14:27:59 <hexagoxel> albeit_: yes
14:28:11 <reindeernix> haven't checked if the code will run but it should catch the gist of it
14:28:23 <reindeernix> I'm missing some otherwises
14:28:27 <Cale> reindeernix: Yeah, that's not valid syntax
14:28:41 <maerwald> reindeernix: what is "Flase"? :P
14:28:56 <dmj`> maerwald: I totally agree, using is easy, creating + proving requires more
14:29:01 <Cale> maerwald: The mysterious third constructor of Bool ;)
14:29:05 <reindeernix> Cale, alright, if it was I wouldn't do it either way. maerwald, it's the state to the right of False ;)
14:29:25 <Cale> data Bool = False | True | Flase
14:29:35 <ion> Is Flase equivalent to FileNotFound?
14:29:35 <reindeernix> just typed it into lpaste to show what I meant :b
14:29:49 <maerwald> Cale: err, you almost got me :S
14:30:31 <Cale> reindeernix: Any case where you're producing a Bool result like that you'd also not want to use guards at all.
14:30:51 <Cale> reindeernix: You can always write that sort of thing more clearly just using logical operations on Bool values.
14:31:12 <Cale> Also  a == True  is the same thing as  a
14:31:24 <Cale> and  a == False  is the same thing as  not a
14:31:47 <reindeernix> I just wrote that to quickly illustrate how I thought nested guards would work
14:31:50 <Cale> yeah
14:32:32 <Cale> As it is, guards are not even layout sensitive
14:33:00 <Gurkenglas> Let's roll back the discussion. "<Cale> Gurkenglas: Is cygwin supposed to work?" <- Would you explain where that troubleshooting question came from or attack the problem from a different angle?
14:33:52 <Cale> Gurkenglas: Well, I'm not a Windows user, but my understanding was that essentially all the Haskell stuff on Windows is built against mingw.
14:34:21 <Cale> Gurkenglas: I figured from the message that you were aware you were running cygwin (like you were using the cygwin shell or something, I dunno)
14:35:16 <johnw> shapr: at ICFP 2014, there was a presentation on dependent typing in Haskell
14:35:27 <johnw> Weirich and Eisenberg have sort of been spearheading that charge
14:35:38 <Cale> Oh, interesting...
14:35:47 <shachaf> geekosaur: Type-level naturals is just a more powerful (separate) type-level language.
14:35:54 <shapr> johnw: that's interesting
14:36:13 <shapr> johnw: I honestly expected Haskell to fall by the wayside in favor of a dependently typed language
14:36:18 <srhb> shapr: She outlined their progress in that podcast... What was it now...
14:36:18 <geekosaur> not sure I'd say that, since the utility of them is to be able to elevate terms to type level
14:36:19 <johnw> shapr: Richard's singletons library lets you do some pretty clever stuff
14:36:21 <shapr> but I guess it makes sense for Haskell to become dependently typed
14:36:34 <shapr> srhb: got a link?
14:36:34 <Cale> http://neilmitchell.blogspot.ca/2010/12/installing-haskell-network-library-on.html -- this is old, but maybe still relevant? It recommends installing cygwin, and then configuring network to build using mingw (which seems a little baffling to me, but okay!)
14:36:37 <johnw> shapr: I keep an eye on Idris from time to time
14:36:41 <srhb> shapr: Trying to remember, one moment :)
14:36:55 <geekosaur> Cale, the error Gurkenglas got is why you need to install network using mingw
14:36:58 <srhb> shapr: http://typetheorypodcast.com/2015/04/episode-4-stephanie-weirich-on-zombie-and-dependent-haskell/
14:37:02 <shachaf> geekosaur: But dependent types are about types that depend on values. :-)
14:37:06 <srhb> shapr: You'll have to find the exact spot yourself, sorry.
14:37:06 <shapr> johnw: I wonder if a language that was created with DTs in mind would be any better/different?
14:37:18 <ion> http://hackage.haskell.org/package/singletons https://youtu.be/OZWYohmLKuU https://youtu.be/O805YjOsQjI
14:37:19 <johnw> shapr: it would make different compromises, yes
14:37:19 <geekosaur> network, if it detects what it thinks is Unix, will try to use too many Unixisms for any emulator to cope with
14:37:32 <geekosaur> so you need to build it for Windows and then use it with Cygwin
14:37:37 <shachaf> You don't get that even with a very fancy type-level language.
14:38:31 <geekosaur> shachaf, yes. and because full dependent typing isn't really a thing and won't be any time soon, you can use type-level Nat to elevate a value into the type system and then define types based on it
14:38:41 <geekosaur> it's kinda dependent typing via a side door
14:38:58 <shachaf> There's nothing dependent about it. :-(
14:39:00 <shapr> johnw: so you think Idris is the best representative of a dependently typed language at the moment?
14:39:10 <Cale> shapr: Haskell has sort of been becoming more dependently typed in a very gradual way over the course of many papers by SPJ. :)
14:39:14 <shachaf> It's just fancy types. Which are great.
14:39:15 <johnw> shapr: well, it depends on what you want it to repreresent
14:39:30 <johnw> I believe Coq has the most mature and proven meta-theory at the moment
14:39:34 <shapr> hm
14:39:44 <Cale> shapr: It's still really awkward to use as a dependently typed language, but you can actually encode a lot of dependently typed programming in Haskell now, if you're sufficiently motivated.
14:39:50 <johnw> Idris does not claim that its proofs are production ready yet
14:39:52 <geekosaur> shachaf, I think your vision of dependent types is perhaps too strict for Haskell. see what Cale just said
14:40:02 <shapr> Cale: any idea how it could be less awkward?
14:40:06 <shachaf> Seems folks don't agree.
14:40:09 <shapr> Cale: what's awkward about it?
14:40:42 <geekosaur> i.e. on a strict theoretical level you are correct, but the Simons are working according to a different vision
14:41:38 <Cale> shapr: Kind of everything? There's a strict distinction between types and values which gets blurred away almost completely in a real dependently typed language, and in Haskell, you have to do all sorts of awkward things to treat types as values and to lift values to the level of types.
14:41:40 <geekosaur> more of a practically-oriented one that doesn't try to hew too closely to the theory because it's hard to fit the strict theoretical one into Haskell
14:41:41 <shachaf> geekosaur: I think it's fine for Haskell not to be dependently typed.
14:42:01 <shachaf> And it's fine for it to get fancy type-level features.
14:42:14 <shapr> Cale: right, makes sense
14:42:17 <shachaf> But no need to advertise them as dependent types.
14:42:25 <shapr> a dependently typed language needs first class types
14:42:43 <johnw> I agree with shachaf 
14:43:17 <Cale> I'm not sure I'd be willing to say that Haskell is dependently typed, but it's certainly *more* dependently typed than it used to be.
14:43:24 <Peaker> shachaf: you mean because the dependence is on types and not on values?
14:43:34 <shachaf> What is "more" dependently typed?
14:43:37 <Cale> (i.e. if we're speaking relatively :)
14:44:03 <shachaf> Peaker: I'm not sure what you mean.
14:44:54 <Cale> shachaf: If you want to write programs which are expressed in the style which perhaps is best carried out in a dependently typed language, there's a better chance now that you can translate things to Haskell in a way which isn't excruciatingly painful.
14:45:26 <Cale> You can't do everything you might do in a proper dependently typed language, but you can do some things
14:45:30 <Peaker> shachaf: "dependent types" is short-hand for "value-dependent types", and the "type-level Nats" and stuff that were mentioned are really "type-dependent types". Is this why you say Haskell has no dependent types?
14:45:44 <Cale> Stephanie Weirich has given a bunch of good talks about this...
14:45:53 <Peaker> because maybe GADTs kinda make types depend on values
14:45:54 <shachaf> Peaker: Well, yes.
14:46:04 <shachaf> But "types depending on types" is something Haskell has always had.
14:46:14 <Peaker> yeah, "types depending on types" is not "dependent types"
14:46:29 <Peaker> but aren't GADTs kinda value-dependent types?
14:46:30 <Cale> shachaf: Well, there's type level automatic liftings of value level things now.
14:46:38 <ryantrinkle> init: i have a basic tutorial for integrating Reflex into IO-based contexts at https://github.com/ryantrinkle/try-reflex/blob/master/examples/host.hs
14:46:45 <Cale> shachaf: (see DataKinds)
14:46:46 <shachaf> Cale: Right, so we have a more expressive type level now.
14:46:47 <geekosaur> actually blurring the division between type and value level is hard, though. providing a way to reflect a value into a corresponding type and then using that type, on the other hand, is doable these days
14:46:49 <ryantrinkle> that might be helpful if you want to add FRP to your irc client
14:46:56 <shachaf> Which is great.
14:46:58 <Peaker> Cale: but that just lifts types into kinds, it doesn't cause a dependency on a value inside a type
14:47:25 <Cale> Peaker: Well at the same time it lifts values to types.
14:47:40 <shachaf> That's just a pun, though.
14:47:46 <Cale> Peaker: so that other parameterised types can depend on them
14:47:49 <Peaker> yeah, it lifts constructors to types, runtime values are not lifted
14:47:53 <Cale> To some extent, sure.
14:47:56 <johnw> geekosaur: one thing that Richard is working on is removing the sharp distinction between kinds and types
14:48:10 <Cale> But practically speaking, it's enough to do quite a bit of programming in a dependently typed style.
14:48:11 <Peaker> but my GADT question is ignored...
14:48:43 <Peaker> dependent types tend to include blurring of value and type level, and Haskell got that. But it's not really part of what dep.types are about
14:48:55 <Peaker> not part of the "dependency" part at least
14:49:13 <Cale> It's not *exactly* the same thing
14:49:22 <Cale> But you can do some of the same stuff with it.
14:49:39 <Cale> (often a bit more awkwardly)
14:49:42 <shachaf> Peaker: GADTs are just more expressive types.
14:49:48 <shachaf> Peaker: Well, which aspect of GADTs are you thinking of?
14:49:57 <Peaker> shachaf: relationship between runtime constructor choice and the type
14:50:02 <Peaker> shachaf: causing a dependency
14:50:22 <shachaf> You can do almost everything you can do with GADTs with RankNTypes.
14:50:33 <Cale> Right, there's also that. Also, soon(?) you will be able to lift GADTs
14:50:33 <Peaker> how?
14:50:46 <Cale> shachaf: You need type equality too!
14:50:51 <Peaker> shachaf: for example, how do you do the typical length-indexed list?
14:50:54 <shachaf> Cale: You have Leibniz equality.
14:51:07 <Cale> hm?
14:51:25 <Cale> Well, maybe I just don't know what encoding you're thinking of.
14:51:29 <shachaf> Is a b = forall p. p a -> p b
14:52:33 <Cale> hmm
14:52:36 <JoshieAS> whois kowen
14:53:02 <Cale> I'm not sure if I completely see how that works or not
14:53:25 <Cale> I'd like to see the standard Expr thing :)
14:53:48 <shachaf> It doesn't completely work, but that's due to a hidden feature of GADTs.
14:53:56 * shachaf will be back in a bit.
14:54:08 <shachaf> The encoding is pretty straightforward, though.
14:56:15 <Peaker> shachaf: you mean the length-list encoding?
14:56:25 <ion> I have a wonderful proof of this but this IRC margin is too small to contain it.
14:57:02 <johnw> ion: lol
14:57:17 <johnw> i'm starting the 350+ year clock
15:00:13 <shachaf> Peaker: Well, the encoding in general. Except it has two major issues.
15:00:31 <shachaf> What's the list GADT again?
15:01:17 <Peaker> data LenList (len :: Nat) a where Nil :: LenList 0 a ; Cons :: a -> LenList n a -> LenList (1+n) a
15:01:34 <shachaf> Right.
15:02:52 <Gurkenglas> Wasn't there also a way to "constrain" or something gf to use the network version that comes with the Haskell Platform?
15:03:20 <Gurkenglas> (Was mentioned earlier by someone.)
15:04:32 <shachaf> Peaker: So that's equivalent to data LenList n a = n ~ Z => Nil | n ~ S m => Cons a (LenList m a), right?
15:05:08 <shachaf> Er, forall m.
15:05:17 <Peaker> shachaf: modulo the silly constraint semantics you get from data .. =, yeah
15:05:25 <shachaf> What constraint semantics?
15:05:29 <shachaf> Those types should be exactly the same.
15:05:38 <Peaker> data Foo a = Ord a => Foo a <-- silly semantics
15:05:54 <Peaker> shachaf: I'm just nitpicking, I think if you used "where" in place of "=" there it'd be fine
15:05:59 <shachaf> That type is the same as data Foo a where Foo :: Ord a => a -> Foo a
15:06:14 <Peaker> shachaf: Really? I'm pretty sure it isn't
15:06:15 <shachaf> GADT syntax gives you nothing over RankNTypes + ExistentialQuantification.
15:06:17 <shachaf> It's just syntax.
15:06:21 <shachaf> I'm pretty sure it is.
15:06:53 <shachaf> You might be thinking of data Ord a => Foo a = Foo a, which is fortunately extinct.
15:07:24 <Peaker> ah, I guess so
15:07:30 <shachaf> Anyway, so with newtype Is a b = Is (forall p. p a -> p b), you can turn that into data LenList n a = Nil (Is n Z) | forall m. Cons (Is n (S m)) a (LenList m a)
15:07:45 <Peaker> Glad I got that wrong, having it behave so badly is a terrible quirk :)
15:08:03 <shachaf> And then you can do the usual trick of encoding existentials with rank-n types.
15:08:43 <shachaf> Exercise: Why doesn't this actually work in practice for a lot of uses?
15:09:04 <shachaf> That exercise comes after convincing yourself that it's the correct type. :-)
15:09:46 <Peaker> It looks correct, but unlike GADTs it won't refine the type of "n" inside each branch?
15:10:14 <Peaker> (Is + GADT gives you "Refl" to refine it, but without GADTs there's no way to?)
15:10:36 <shachaf> Well, it depends on what sort of "refinement" you want.
15:10:53 <Peaker> with GADTs, in each branch, the type of already-existing variables from the environment are refined
15:12:17 <shachaf> You have to use your equality manually.
15:24:16 * hackagebot promises 0.2 - Lazy demand-driven promises  http://hackage.haskell.org/package/promises-0.2 (EdwardKmett)
15:24:18 * hackagebot roshask 0.2.1 - Haskell support for the ROS robotics framework.  http://hackage.haskell.org/package/roshask-0.2.1 (AnthonyCowley)
15:26:23 <structuralist> is there a standard module to import for things like (&&&), (***), (|||), (+++) besides Control.Arrow?
15:27:27 <Cale> structuralist: no
15:27:31 <arkeet> what's wrong with Control.Arrow?
15:28:01 <Cale> Two of those are methods of the Arrow type class
15:28:01 <arkeet> (which, being in base, is as standard as it gets)
15:28:14 <Cale> and two more are methods of ArrowChoice, which is also defined there
15:28:25 <fragamus> edwardk: I am pondering liskell macros and their utility and want to hear what you think of liskell as an alternative syntax for haskell
15:29:02 <Cale> I don't really understand what can be done with Liskell macros that can't be done just as well with Template Haskell.
15:29:10 <edwardk> i think i love operators they are clean and largely invisible and i've already loaded the first level of that lexer into my brain. ;)
15:29:16 <structuralist> those operators are so primitive it seems like they shouldn't require pulling in all of Control.Arrow
15:29:28 <Cale> :t (***)
15:29:28 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
15:29:34 <Cale> ^^ look at the type
15:29:37 <edwardk> i would kill for good scheme style syntax-rules but its hard to mix with operator precedence and layout
15:29:45 <edwardk> and template-haskell reduces the pain to a dull ache
15:30:18 <structuralist> Cale: I would feel better about it if it was "BiCartesianClosedCategory a" instead of "Arrow a"
15:30:37 <edwardk> structuralist: sure there is: http://hackage.haskell.org/package/categories-1.0.7/docs/Control-Category-Cartesian.html
15:31:20 <aweinstock> edwardk: in what ways does syntax-rules improve on template haskell?
15:31:45 <edwardk> aweinstock: you can write some very elegant, very concise syntax-rules
15:32:25 <structuralist> edwardk: oh sweet, thanks
15:32:39 <fragamus> but liskell syntax allows us to write macros in the same syntax as our regular liskell code
15:32:40 <aweinstock> so syntax-rules is an improvement over TH in the same way that syntax-rules is an improvement over defmacro?
15:32:42 <edwardk> template-haskell is one of those things that grew into this big organic mess in which you _can_ say everything, but it kinda hurts to contort your thinking into how. a large part of that is we have a much richer syntactic structure in many ways, types to deal with, etc.
15:33:00 <edwardk> aweinstock: yeah
15:33:05 <edwardk> its easy to write hygienically
15:33:17 <edwardk> and they compose much nicer than random TH quasiquoters
15:33:48 <edwardk> of course they are a turing tarpit as oleg showed. so hygiene there is tricky. you can carefully subvert all their hygiene efforts =/
15:34:11 <hodapp> edwardk: As Oleg showed?
15:34:24 <aweinstock> would implementing syntax-rules as a TH macro be a useful thing?
15:34:24 <fragamus> when we were children we had operator precedence rules drilled into our brains
15:35:08 <aweinstock> hodapp: http://okmij.org/ftp/Scheme/macros.html#dirty-macros
15:35:19 <edwardk> hodapp: http://okmij.org/ftp/Scheme/macros.html#turing-completeness-hygiene <- that and a bunch of other posts in there in that area pretty much deconstructed syntax-rules
15:35:41 <hodapp> thanks
15:35:42 <edwardk> aweinstock found the right link
15:36:38 <hass> Is it true that in constructing big software in Haskell the big problem is arriving at the specific proper data structures of the application one is trying to build?
15:36:41 <edwardk> fragamus: personally i find parenthesesless code very clean, but i realize that that argument isn't going to win over a schemer =)
15:37:03 <hodapp> What I ran into today is a case where my attempt to solve things with GHC.Generics started out fairly clean, and became eventually a pretty horrid mess of typeclasses and type families, and that made TH look much more attractive in comparison.
15:37:14 <hodapp> but it's possible also that I just need to try harder with Generics.
15:37:15 <edwardk> hass: my way to construct big software in haskell is to just build up all the little pieces i need to talk about the problem domain, then the final construction is pretyt obvious
15:37:38 <fragamus> i am a haskeller, and i love it but i am thinking we left something very cool behind when we ditched the parentheses
15:38:07 <hodapp> It's interesting to me that the only texts that seem to insist that top-down is the only viable way to design software tend to be the texts that use languages that suck at composing things.
15:38:10 <hunteriam> does CString use IsString?
15:38:17 <hunteriam> whats the best way to use CStrings in haskell?
15:38:22 <edwardk> i build all the little pieces and try to make them the best versions of themselves they can be with very little thought to how they fit into the whole, then just look at how the parts want to fit together.
15:38:30 <hodapp> fragamus: reading about Liskell now...
15:38:31 <aweinstock> edwardk: my question "would implementing syntax-rules as a TH macro be a useful thing?" was intended to be directed at you
15:38:44 <edwardk> hunteriam: you can use withCString to build the cstring from a normal string
15:38:52 <hass> Thank edwardk. This is my feeling too. So why isn't tutorials try to teach us this skill. I find those focusing on the language constructs
15:38:58 <fragamus> because the programmer is using a serialized AST as his coding language and can *think* that way all the time, and then it's so natural to make a macro
15:38:59 <edwardk> aweinstock: the problem is they wouldn't compose really
15:39:17 <hunteriam> edwardk: now what if i need a series of different pieces of c data for the same function? something along the lines of CString -> CInt -> CInt ...
15:39:17 <hodapp> fragamus: do you use Liskell?
15:39:19 <edwardk> also its not clear how they interact with things like layout and operator precedence
15:39:28 <fragamus> I do not 
15:39:47 <hunteriam> edwardk: is there a clean way to temporarily initialize many pieces of cdata?
15:39:49 <hodapp> I haven't used Lisp/Scheme/Clojure for a good spell here...
15:39:53 <edwardk> hunterjam: i tend to lift my marshalling code into a nice little one-off wrapper for things like that
15:40:08 <edwardk> hunteriam: not terribly
15:40:19 <fragamus> in liskell its operator precedence be damned
15:40:23 <hunteriam> edwardk: ah, hopefully one day someone will find a nice system for thees things
15:40:31 <structuralist> edwardk: is there no other name in here for (***)-like things than 'bimapProduct'?
15:40:43 <edwardk> (***) = bimap
15:40:51 <edwardk> bimapProduct is a default definition for bimap for the product
15:41:12 <edwardk> http://hackage.haskell.org/package/bifunctors-5/docs/Data-Bifunctor.html
15:41:20 <edwardk> though Data.Bifunctor moved to base in 7.10
15:42:15 <edwardk> structuralist: http://hackage.haskell.org/package/hask is a more 'industrial strength' version of these notions
15:42:33 <edwardk> capable of things like stating 'monads are monoids in the category of endofunctors' in code.
15:43:03 <edwardk> http://hackage.haskell.org/package/hask-0/docs/Hask-Tensor-Compose.html#t:Monad -- wheee!
15:44:32 <structuralist> edwardk: very cool
15:46:34 <fragamus> this video makes my point about macros: https://www.youtube.com/watch?v=HM1Zb3xmvMc
15:46:41 <hunteriam> does anyone know where i can learn to render from cairo to SDL2?
15:50:09 <hunteriam> man... is sdl2 really the best option for real time rendering in haskell?
15:50:12 <hass> quit
15:50:20 <hunteriam> it just seems like quite a lot of work to learn
15:51:09 <kuribas> hunteriam: Are you writing a game?
15:51:26 <hunteriam> kuribas: no, just trying to render some 2d plots in real time
15:51:54 <hunteriam> kuribas: although at some point I may write a small game to test some stuff on
15:52:14 <arbelos> Does anyone know how to achieve something like WHERE field IS NULL with esqueleto/persist?  where_ $ item ^. ItemField ==. ??
15:52:19 <hunteriam> kuribas: ive got the 2d plots in raw pixel data, i just need something that can take them and put them on the screen
15:52:35 <kuribas> hunteriam: You can also use wxHaskell
15:52:54 <kuribas> or gtk2hs
15:53:00 <structuralist> edwardk: is there a guide to reading these types somewhere?
15:53:02 <fragamus> edwardk: code is always going to look better without a flood of parentheses, but: the ability to make macros for stuff like memoization that are universally applicable makes our code more concise
15:53:04 <kuribas> Both should be fast enough.
15:53:22 <hunteriam> kuribas: fast in terms of how long it takes to get set up with them?
15:53:27 <hunteriam> if so, which is more standard (if either)
15:53:30 <edwardk> structuralist: not really. i recommend starting in Hask.Category or whatever and working very very slowly through
15:53:41 <edwardk> i gave a talk on a precursor to this version of the code once
15:53:57 <edwardk> https://www.youtube.com/watch?v=Klwkt9oJwg0
15:54:27 <kuribas> hunteriam: wxHaskell uses native widgets, gtk2hs looks only native on linux.
15:54:30 <edwardk> the hask code i talk there uses kinds as "almost categories" and uses tricks to try to keep the distinction between parametricity and naturality from getting too bad
15:54:32 <edwardk> but i eventually gave up
15:54:40 <hunteriam> kuribas: alright, thanks! gonna use wx
15:54:47 <edwardk> the current hask code is me saying 'well, how bad would it be to more or less do this correctly?'
15:54:58 <kuribas> hunteriam: But if you just want something fast on the screen, I'd use a library for that.
15:55:04 <edwardk> and its a weird form of 'curried category theory' since (->) :: * -> * -> * is already curried
15:55:10 <hunteriam> kuribas: what do you mean?
15:55:13 <cbrr> Hey folks
15:55:30 <hunteriam> kuribas: do you know of any librarys?
15:55:33 <edwardk> we can view (->) as a Functor from Hask^op to the functor category from Hask -> Set    -- where we use Hask as an approximation of Set. 
15:55:54 <hunteriam> can anyone here suggest a library that can just display pixel data on the screen without much hassle?
15:56:12 <kuribas> hunteriam: For plotting: https://hackage.haskell.org/package/Chart
15:56:16 <edwardk> so Functor (->); type Dom (->) = Op (->); type Cod (->) = Nat (->) (->) -- says this and the encoding in hask can let you use runNat and Nat to 'focus' on any argument in a type basically
15:56:40 <edwardk> hence some weird instances in there like instance Functor (,) -- note the lack of 'a' argument.
15:56:56 <hunteriam> @kuribas ive already got a library that creates plots for me, also without much hassle, i just need smoething that can draw them on the screen. does the library you suggested have built in real time rendering?
15:56:56 <lambdabot> Unknown command, try @list
15:57:05 <edwardk> (of course this isn't a haskell prelude Functor)
15:57:20 <structuralist> ok that made sense, thanks
15:57:22 <edwardk> and its still giving up some real category theoretic functors, but its pretty good
15:58:30 <edwardk> for me its kind of important to think of 'the real thing i want to say in category theory' and 'what approximations of that i can make of that in haskell' and their relative trade-offs in terms of what they can actually encode
15:58:45 <edwardk> people get tripped up a lot because parametricity and naturality, while related aren't the same things
15:58:56 <kuribas> hunteriam: In that case cairo should be fine.
15:59:06 <edwardk> so if you go to 'build the native category theory of haskell' you get something too weak.
15:59:34 <edwardk> no product/coproduct categories, etc, you can't build products from limits, coproducts from colimits, etc.
16:00:12 <edwardk> you get a lot of the same structure, but its very much "walking a broken pattern" in the Nine Princes in Amber sense.
16:00:15 <hunteriam> kuribas: im using cairo, but cairo doesnt seem to have any real time rendering options, cairo is what outputs the pixeldata
16:00:47 <cbrr> So I've got this project which is under GPLv3. If I want to use a function from another project released under the MIT license, how would I go about adding the license to my project? Insert the entire license wherever code is used from the project?
16:01:13 <kuribas> hunteriam: what do you mean by realtime rendering?
16:01:38 <edwardk> http://www.cs.bham.ac.uk/~udr/papers/logical-relations-and-parametricity.pdf <- talks at length about the difference between parametricity and naturality if anybody is interested
16:01:55 <hunteriam> kuribas: displaying a window with the pixel data in it, possibly updating the window with new pixeldata whenever ive got new pixel data. alternately, displaying a new window with new pixeldata when ive got new pixeldata
16:02:07 <hunteriam> kuribas: cairo has options for outputting to a file, but not a window AFAIk
16:04:03 <hunteriam> just gonna ask again, does anyone know of a library that can take pixel data and render it to a window without getting too involved?
16:04:23 <bananagram> yeah, gloss
16:04:33 <bananagram> I think
16:04:34 <kuribas> hunteriam: It's part of gtk2hs I think.
16:04:41 <hunteriam> is the barrier for entry as high as sdl2 for gloss?
16:05:33 <hunteriam> kuribas: thanks ill take a look at that
16:05:40 <bananagram> gloss is super easy, but I'm not sure if the image generator that uses a function Int -> Int -> Color works
16:12:12 <paraseba> given this export list https://github.com/yesodweb/wai/blob/master/wai-extra/Network/Wai/Middleware/Gzip.hs#L17 is there any way to obtain a GzipSettings that is not equal to def?
16:13:12 <hunteriam> is there a gtk3hs in the works?
16:14:23 <BrianMiller> What's the problem with this 10-line code? http://pastebin.com/CtFr5vKA I'm trying to find the sum of two numbers
16:15:11 <arkeet> in the future, please also include the error message
16:15:15 <arkeet> anyway, looks like indentation is all funny.
16:15:31 <BrianMiller> Says: parse error on input `one`
16:15:43 <arkeet> right, each statement inside the do block must have the same indentation.
16:15:54 <arkeet> the 'one' in line 5 must line up with the 'putStrLn' in line 4
16:16:31 <arkeet> (the first statement determines the indentation level needed for the rest)
16:16:42 <hunteriam> does anyone know of a functioning gtk3 library in haskell?
16:17:36 <arkeet> gtk2hs supports gtk3.
16:17:36 <arkeet> afaik
16:17:48 <BrianMiller> arkeet, thanks.
16:18:17 <BrianMiller> Are all functional languages indentation sensitive?
16:18:37 <arkeet> that would be a pretty broad generalization, and no.
16:18:56 <arkeet> you can write haskell in a way that is insensitive to indentation
16:19:15 <arkeet> e.g. main = do { putStrLn "blah"; one <- readLn; ... }
16:19:40 <BrianMiller> Do I need the IO monad at all?
16:19:41 <Cale> I'd say most functional languages probably aren't indentation insensitive even.
16:20:12 <shachaf> Cale: I wouldn't say the opposite of that.
16:20:26 <Cale> er
16:20:34 <arkeet> every complete haskell program must have main :: IO a, for some a
16:20:40 <Cale> lol
16:20:41 <arkeet> (usually IO () because the return type doesn't matter)
16:20:49 <Cale> Meant to say: most functional languages probably aren't indentation sensitive even.
16:20:52 <arkeet> so in that sense no, you can't avoid IO.
16:22:36 <Cale> e.g. Most (all?) of the MLs, all the lisps, Coq, and many other languages are not indentation sensitive. Haskell, Idris and Agda are indentation sensitive though.
16:23:53 <Cale> BrianMiller: If you want to do I/O, you'll need to express it at least to some extent in terms of IO actions. However, you can get by for quite a bit without actually writing programs which do I/O, and instead use GHCi as a makeshift user interface.
16:24:16 <Cale> That is, you can just calculate things and get GHCi to print the results for you.
16:24:34 <shachaf> Cale: Do you believe my encoding?
16:24:47 <Cale> shachaf: Oh, sorry, I didn't see it
16:25:14 <arkeet> and even in complete haskell programs, often you can (and want to) limit IO stuff to a small part of your code.
16:25:17 <shachaf> You shouldn't completely believe it, because it doesn't completely work. But it's the right type.
16:25:31 <BrianMiller> Alright, but what if I wanted to add an if statement? main = do { A <- readLn; B <- readLn; if A >= 1 && B <= 1000 then print (A+B) }
16:25:52 <agocorona> doing IO is not a sin
16:25:58 <shachaf> Cale: What was the GADT whose encoding you were dubious about?
16:26:10 <arkeet> there are no if-statements, only if-expressions.
16:26:24 <Cale> shachaf: Just the standard expression evaluator example
16:26:34 <arkeet> which, in particular, must always have an 'else' part
16:26:40 <arkeet> so you can do something like
16:26:45 <paul_erdos> Perlin?
16:26:49 <BrianMiller> The above gives a compilation error: parse error on input `}`
16:26:52 <arkeet> if a >= 1 && b <= 1000 then print (a+b) else return ()
16:27:03 <arkeet> return () is the IO action that does nothing.
16:27:05 <BrianMiller> Why would it always need an else?
16:27:13 <arkeet> because an if-expression must always have a value.
16:27:23 <shachaf> What's that one?
16:27:33 <arkeet> in that case, the value being an IO action.
16:27:50 <Cale> shachaf: Like, to have a GADT something like  data Expr a where C :: Int -> Expr Int; IsZero :: Expr Int -> Expr Bool; IfThenElse :: Expr Bool -> Expr a -> Expr a -> Expr a
16:27:54 <arkeet> since that case is common, there is a function 
16:27:56 <arkeet> @hoogle when
16:27:56 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
16:27:56 <lambdabot> Test.QuickCheck.Property whenFail :: Testable prop => IO () -> prop -> Property
16:27:56 <lambdabot> Test.QuickCheck whenFail :: Testable prop => IO () -> prop -> Property
16:27:59 <Cale> shachaf: and then to write an  eval :: Expr a -> a
16:27:59 <arkeet> the first one.
16:28:17 <arkeet> when (a >= 1 && b <= 1000) (print (a+b))
16:28:18 <BrianMiller> else return () returns: "Not in scope: data constructor `A' etc
16:28:18 <ronh-> BrianMiller if/then/else returns a value. what if it return if the boolean expression was false and you didn't provide a then clause?
16:28:31 <arkeet> BrianMiller: well, variable names must start with a lowercase letter.
16:28:54 <arkeet> uppercase is for data constructors.
16:29:06 <BrianMiller> Sorry, I'll go RTFM
16:29:27 <arkeet> if you write A <- readLn
16:29:37 <arkeet> it tries to find a constructor called A, and pattern match the result of readLn against it.
16:31:54 <Cale> BrianMiller: It's all right, sometimes it's quicker to ask people who immediately know the answer than to go search through documentation for the one thing you're interested in. (So long as nobody's getting annoyed :)
16:38:30 <george_p> hello. what is GADTs equivalent for the following code? data T = forall a . T { field a -> String }
16:39:09 <johnw> data T where T :: field a -> String
16:39:45 <agocorona> sorry for this console IO action
16:40:00 <johnw> oops, add -> T at the end
16:40:12 <hunteriam> is there a way to install gtk2hs with only gtk3 installed?
16:40:28 <hunteriam> im not sure its possible to have both gtk2 and gtk3 at the same time
16:40:48 <arkeet> it's not?
16:41:19 <arkeet> hm, seems the gtk2hs homepage is down http://projects.haskell.org/gtk2hs/
16:41:24 <arkeet> there's this though https://github.com/gtk2hs/gtk2hs
16:41:53 <geekosaur> hunteriam, for historical reasons gtk2hs is not called gtk3hs, but it does support gtk3
16:42:35 <geekosaur> it will build against whichever one you have devel headers/libs for
16:42:44 <hunteriam> geekosaur: it seems to require gtk2 to install... im afraid ill have path conflicts if i try to install both seeing as im on windows
16:42:48 <geekosaur> (also you can have gtk3 and gtk3 installed at the same time on mist systems)
16:42:56 <geekosaur> er gtk2 and gtk3)
16:43:04 <Jello_Raptor> hmm, what's the best way to make cabal ignore lines that start with "#" in .lhs files? 
16:43:12 <hunteriam> geekosaur: "setup.exe: The pkg-config package 'gtk+-2.0' is required but it could not be found."
16:43:18 <geekosaur> windows? that would be more difficult, yes
16:43:20 <hunteriam> geekosaur: appears to explicitly require 2
16:43:21 <Jello_Raptor> I want to use more than 2 layers of headers in my markdown >_<
16:43:39 <arkeet> hunteriam: see my link.
16:43:45 <arkeet> regarding installation.
16:44:08 <hunteriam> arkeet: "Windows: TODO"
16:44:20 <arkeet> "If you want GTK+ 3 and no GTK+ 2 suport"
16:44:42 <arkeet> note that that TODO is under installing gtk+, not gtk2hs
16:45:02 <hunteriam> arkeet: requires something called cabal-meta
16:45:14 <shachaf> Cale: http://slbkbs.org/cale-expr.hs
16:45:19 <arkeet> try reading the instructions from the top?
16:45:21 <Clint> stbuehler: are you abandoning nettle?
16:48:28 <george_p> johnw sorry I tried but i cant get the right syntax out of it. also I mistyped mine. should have been data T = forall a . T { field :: a -> String }
16:51:43 <Cale> shachaf: So it does :)
16:56:25 <george_p> I got it. data T where { T :: a -> (a -> String) -> T }
16:56:57 <george_p> uhn no, that isnt it
16:56:57 <ttt_fff> this is OT, but I like Haskellers blanace of practical + theory; I know C + Asm + Clojure + Haskell. I know big-Oh running time. I want to learn Postgres. I have read the first 9 chatpers of the psotgres manual (basics of SQL / setting up databases), and setup some toy databases. However, how do I learn schema / datbase design / when to normalize / when to not normalize, etc .... ? [Looking for book sugestion] Works of CJ Date ?
17:01:28 <agocorona> most haskellers only know theory
17:02:48 <agocorona> ops I thoug that this was haskell-blah
17:03:46 <vikaton> Functional Programming techniques in other languages like JS or Java usually result in safer code?
17:04:01 <vikaton> or bugless so to speak 
17:04:04 <vikaton> generally
17:06:02 <jle`> vikaton: they usually result in more reusable code, and less redundant code tends to result in less bugs, if that's something like what you're looking for
17:06:31 <gdoteof> before i go down a dirty hole, is anyone aware of a way to parse multipart-mixed response bodies?
17:06:37 <jle`> higher level code also lets the programmer worry about less...assuming the implementation can be trusted
17:06:40 <gdoteof> i am using http-conduit /yesod
17:06:47 <jle`> you won't get anywhere near the safety that Haskell offers with its types, though
17:06:55 <monochrom> techniques do not significantly reduce errors. (slightly reduces, sure.) language restriction significantly reduces errors. an unrestrictive language is unprotective.
17:07:00 <vikaton> I see
17:07:58 <monochrom> think of "techniques" as only style guides.
17:08:09 <gdoteof> i see a couple libraries making these types of requests but nothing eating them
17:09:22 <dmj`> gdoteof: by mixed what do you mean? Like an endpoint will return different data types?
17:10:18 <gdoteof> dmj`: excuse the f'd paste: http://lpaste.net/5342465714475237376
17:10:41 <rofer> Anyone able to help me with my linker problem I just posted to SO? http://stackoverflow.com/questions/30991831/ghc-undefined-reference-to-paths-in-dependency
17:10:48 <gdoteof> the content-type header is "multipart/mixed" and then there is a boundary="randString()" header
17:11:07 <gdoteof> then the body itself is made up of a bunch of their own requests seperated by randString()\r\n
17:11:08 <hunteriam> how do i tell cabal to install into a sandbox at a specific location?
17:11:28 <rofer> hunteriam: I think cabal sandbox init --help will tell you what to do
17:11:46 <rofer> Oh wait, that would be just for making a sandbox somewhere
17:12:14 <gdoteof> so this thing is sending em back \r\n-randString()--{{somejson}}\r\n-randString()--{{somemorejson}}
17:12:29 <gdoteof> instead of {somejson, someMorejson}\
17:12:37 <vikaton> Hi dmj` 
17:13:20 <dmj`> gdoteof: yea... what library are you using
17:13:27 <dmj`> riak?
17:13:36 <dmj`> vikaton: Hi vikaton
17:13:37 <gdoteof> yes this is talking to riak-cs
17:14:08 <gdoteof> i am using a combination of amazonka and stuff i mostly stole/repurposed from hs3
17:14:31 <geekosaur> rofer, it's actually referring to Paths_rlglue which is a module manufactured by cabal-install for libraries. which makes this sound like an obscure cabal-install bug
17:14:35 <dmj`> @package riak
17:14:35 <lambdabot> http://hackage.haskell.org/package/riak
17:14:42 <dmj`> gdoteof: why not use a more official lib
17:14:55 <gdoteof> dmj`: riak != riakcs
17:15:09 <dmj`> hm
17:15:50 <gdoteof> riakcs is basically an s3 clone
17:16:10 <gdoteof> but there is additional user management api that is idiosyncratic to riakcs
17:16:23 <gdoteof> it uses the same signing technique for auth but just new endpoints
17:16:32 <gdoteof> and it sends responses back in the multipart way
17:17:09 <dmj`> gdoteof: so you're storing json in s3 buckets?
17:17:14 <hunteriam> guys is it possible to cabal install into a specific sandbox?
17:17:20 <gdoteof> dmj`: no
17:17:31 <gdoteof> dmj`: these responses are from a request to list the users
17:17:40 <gdoteof> these are just riakcs native things
17:17:44 <dmj`> hunteriam: if one exists in the directory that you invoke 'cabal install' it will automatically do it
17:17:55 <rofer> geekosaur: Yeah, that's what I meant in there. I'll edit it to make that more clear.
17:17:59 <hunteriam> dmj`: yes but the sandbox is in a different directory
17:18:04 <hunteriam> dmj`: it was something from github
17:18:05 <rofer> Wish it was easier to google for things involving Paths_
17:18:05 <gdoteof> dmj`: http://docs.basho.com/riakcs/latest/cookbooks/Account-Management/#Retrieving-a-List-of-All-Users
17:18:30 <geekosaur> in any case this sounds like you tickled a cabal-install bug of some kind
17:19:20 * hackagebot time-locale-compat 0.1.1.0 - Compatibility of TimeLocale between old-locale and time-1.5  http://hackage.haskell.org/package/time-locale-compat-0.1.1.0 (KeiHibino)
17:19:24 <dmj`> hunteriam: why not copy it to your current directory and cabal sandbox init
17:19:53 <hunteriam> dmj`: ive got a sandbox in one directory and a library i need to install into that sandbox in another
17:20:07 <rofer> geekosaur: That's what I'm afraid of. I was really hoping someone would point out something stupid I'm doing.
17:20:21 <rofer> Is there a cabal-dev channel I could poke people in?
17:20:38 <gdoteof> dmj`: http://docs.basho.com/riakcs/latest/cookbooks/Account-Management/#Retrieving-a-List-of-All-Users
17:20:42 <gdoteof> er.. sorry.
17:20:48 <gdoteof> https://github.com/basho/riak_cs/blob/ed47d63c33b36898bd5d03b8b756ec8e0086038c/src/riak_cs_wm_users.erl#L64
17:22:40 <dmj`> hunteriam: then, while inside the same directory as the sandbox, do 'cabal sandbox add-source <path/to/library>' then cabal install --dependencies-only (ensure that the library name is in your cabal file)
17:24:23 <dmj`> gdoteof: that's weird...is you're producing json why not set the content type to application/json
17:24:28 <dmj`> s/is/if
17:26:46 <gdoteof> dmj`: i am not sure what you mean.  weird on their part?
17:28:23 <vikaton> dmj`: pm?
17:32:26 <dmj`> gdoteof: yes
17:33:39 <Zemyla> Hmm. Yoneda m is a Functor for free, and Codensity m is a Monad for free. Is there any transformer that's an Applicative (but not a Monad) for free?
17:33:59 <arkeet> there's a "free applicative"
17:36:03 <bitemyapp> Zemyla: coyoneda isn't it?
17:36:37 <arkeet> both yoneda and coyoneda
17:36:58 <Zemyla> Yes, but I'm trying to see if there's something that's Applicative but not automatically Monad.
17:37:21 <arkeet> there's a "free applicative"
17:38:49 <Zemyla> Huh, so there is. Thanks.
17:44:21 * hackagebot concurrent-machines 0.1.0.0 - Concurrent networked stream transducers  http://hackage.haskell.org/package/concurrent-machines-0.1.0.0 (AnthonyCowley)
17:46:54 <Zemyla> If we get truly dependent types, will we be able to make objects of those types that the compiler can verify can never be bottom? Sort of like embedding Agda into Haskell?
17:47:20 <Rotaerk> is haskell potentially getting "truly dependent types"?
17:47:38 <Zemyla> I heard that was one of the planned directions for it.
17:50:22 <bitemyapp> Rotaerk: we're getting something that'll make them significantly nicer to use, but I don't think it's going to be as different as you're imagining.
17:51:39 <Rotaerk> k
18:02:29 <Zemyla> bitemyapp: Aww. I'd love to be able to have a Haskell program that can prove to the compiler that certain values can never be bottom.
18:05:31 <Gurkenglas> Why's https://hackage.haskell.org/package/free-3.2/docs/Control-Applicative-Free.html got Ap's arguments flipped?
18:13:29 <Zemyla> A kind can't be bottom, right?
18:14:11 <Eduard_Munteanu> Zemyla, neither can a type
18:14:42 <Eduard_Munteanu> (or do you mean Void?)
18:15:14 <Zemyla> I actually did mean kinds and types.
18:16:31 <Eduard_Munteanu> Theoretically, you can make the typechecker loop, but that doesn't count as passing typechecking.
18:19:23 * hackagebot simple-nix 0.1.0.4 - Simple parsing/pretty printing for Nix expressions  http://hackage.haskell.org/package/simple-nix-0.1.0.4 (thinkpad20)
18:24:23 * hackagebot nixfromnpm 0.1.0.4 - Generate nix expressions from npm packages.  http://hackage.haskell.org/package/nixfromnpm-0.1.0.4 (thinkpad20)
18:34:10 <johnw> hnix also parses and pretty prints
18:40:26 <bispflk> Is prolog worth learning or is there a newer equivalent language?
18:41:10 <edwardk> Gurkenglas: because if it doesn't then you get your 'effects' in right to left order
18:41:15 <benzrf> prolog is hella eat
18:41:17 <benzrf> *neat
18:41:42 <edwardk> Gurkenglas: others have encoded the more obvious encoding but it is a lot less useful
18:42:40 <bispflk> benzrf: ok thats good enough for me :)
18:43:13 <Gurkenglas> Has anyone tried contacting Google about the old package version thing?
18:45:29 <geekosaur> there's not much google can do if a bunch of people have linked to an old version
18:45:45 <geekosaur> and the page does not provide a canonical url, which hackage should be modified to do
18:46:22 <geekosaur> see https://support.google.com/webmasters/answer/139066?hl=en
18:47:03 <geekosaur> sadly almost every programming language's online docs either don't do this or do it wrong, so you get old pages not only for haskell but also python and perl among others
18:49:08 <geekosaur> also probably requires that you support some kind of "latest" link in addition to versioned ones, though, which is probably why nobody does it
18:52:03 <Gurkenglas> Should the order explanation go into Ap's documentation?
18:56:59 <pyon> What exactly is the "natural map" for a type constructor? As the term is used here: http://fpcomplete.com/user/edwardk/snippets/fmap
19:02:53 <bispflk> pyon: https://en.wikipedia.org/wiki/Natural_transformation
19:05:06 <pyon> bispflk: But, in general, a type constructor isn't necessarily a functor.
19:06:15 <pyon> Say, `newtype Foo a = Foo (a -> a)` -- would there be a "natural map" for `Foo`?
19:06:56 <pyon> (And there's as second issue: A natural transformation is always between two functors... where's the other would-be functor?)
19:07:12 <arkeet> sure.
19:07:25 <arkeet> given functions a -> b and b -> a you can get Foo a -> Foo b
19:07:40 <arkeet> (it's an "invariant functor")
19:08:52 <pyon> I can make sense of contravariant functors as normal functors from the opposite category... but I'm afraid I don't quite understand what exactly an invariant functor is. :-|
19:09:01 <arkeet> probably they ought to be inverses.
19:09:19 <arkeet> well you can make another category.
19:09:25 <Gurkenglas> The paragraph starting with "The tricky part" on the article page goes into the natural map, but I agree that there should be explanation on it earlier.
19:09:26 <arkeet> where the arrows are the isomorphisms of the given category.
19:10:10 <arkeet> or pairs of functions. I don't know.
19:12:30 <arkeet> I mean if you have a category C, I can make a category C' with the same objects, where arrows a -> b in C' are pairs (a -> b, b -> a) of arrows in C.
19:12:55 <pyon> :-O
19:12:57 <pyon> Makes sense.
19:13:01 <pyon> arkeet: Thanks!
19:13:19 <pyon> biscarch: Gurkenglas: Thanks, too, to you two!
19:14:23 <arkeet> I bet you can draw some sort of pullback square for this.
19:17:30 <edwardk> pyon: there is a fair bit of extra content describing the natural map and how to derive it in the comments below
19:18:08 <pyon> Yeah, I'm reading those right now, thanks. :-)
19:18:43 <Gurkenglas> arkeet, you mean to get the dotted arrow you need the last two arrows? http://sketchtoy.com/65385948
19:18:44 <edwardk> pyon: re "an invariant functor" an 'invariant functor' would be a functor from (the subcategory of isomorphisms on Hask) to Hask
19:18:49 <hunteriam> guys im trying to find the documentation for the function `on` in gtk
19:18:54 <hunteriam> no idea how to find it
19:19:02 <hunteriam> im using intellij IDEA with the haskell plugin
19:19:08 <hunteriam> if it can find it for me perhaps..
19:19:12 <pacak> :t on
19:19:13 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
19:19:24 <pacak> hunteriam: Data.Function?
19:19:32 <arkeet> Gurkenglas: ?
19:19:33 <hunteriam> ive got a ton of other things iim trying to find documentation for
19:19:40 <hunteriam> or just type signatures
19:19:46 <arkeet> I just mean 
19:19:50 <hunteriam> i guess i can use the repl actually
19:19:51 <pacak> hunteriam: hoogle, hayoo
19:20:04 <hunteriam> hoogles not very useful if you dont already know the type i think
19:20:09 <Gurkenglas> hunteriam, https://www.haskell.org/hoogle/?hoogle=on
19:20:17 <pacak> hunteriam: You can hoogle  by name as well.
19:20:28 <pyon> edwardk: Isomorphisms, with distinguished "forward" and "backward" directions, right?
19:20:31 <arkeet> this square should be a pullback
19:20:32 <arkeet> C'-> C^op
19:20:32 <arkeet> |     |
19:20:32 <arkeet> v     v
19:20:33 <arkeet> C -> Obj(C)
19:20:55 <arkeet> wait.
19:20:55 <edwardk> pyon: yes, an isomorphism is just a morphism with a two-sided inverse
19:20:58 <arkeet> not Obj(C).
19:21:24 <edwardk> so while an isomorphism has an inverse it has an 'orientation' of which way it is headed
19:21:30 <arkeet> maybe I want Obj(C) x Obj(C).
19:21:36 <arkeet> or something.
19:21:44 <pyon> arkeet: What's C' in that diagram? :-O
19:21:48 <arkeet> the C' I defined above.
19:21:50 <arkeet> with the pairs of arrows.
19:22:13 <arkeet> I guess I just mean the arrows in C' are pairs of corresponding arrows in C and C^op
19:22:25 <pyon> arkeet: Oh, sorry, I missed that.
19:22:46 <arkeet> ok, not sure what I want in the bottom right.
19:22:54 <arkeet> I want food in my stomach instead. brb
19:23:46 <edwardk> anyways the usual suspects when it comes to these sorts of maps are "Hask", "Hask^op", this sub-category of isomorphisms, and the discrete category on Hask |Hask|  -- which just has the objects and identity arrows, no other morphisms
19:25:24 <aronian> Hi, I'm looking for some advice on GUI programming in Haskell, I've had a quick look at Grapefruit (which looks fun), but I can't find a great deal of documentation for it
19:25:27 <edwardk> and another case where you accept either a morphism in Hask or one in Hask^op as a morphism (this arises for phantom type usage) but since we have an initial (and for that matter a terminal) object -- this means all objects are connected
19:26:48 <edwardk> those happen when you deal with a covariant, contravariant, 'invariant' or the argument has a nominal role, and the 'extra case' is when things are phantom.  -- so you can model all of stuff this as various forms of "functor" if you try hard enough.
19:28:00 <hunteriam> :t draw
19:28:01 <lambdabot> Not in scope: ‘draw’
19:28:10 <hunteriam> im trying to find the type of the gtk function draw
19:28:32 <hunteriam> the nme is too generic for hoogle
19:28:44 <hunteriam> and the documentation for gtk is too immense to search through in a reasonable amount of time
19:28:56 <hunteriam> and i cant import it to ghci because it has an external executable dependency
19:29:13 <L8D> hunteriam: which gtk package is this?
19:29:16 <hunteriam> gtk3
19:30:38 <L8D> hunteriam: do you have code that uses this 'draw' function?
19:30:53 <L8D> hunteriam: also the gtk3 package indexed on hoogle
19:31:13 <L8D> hunteriam: http://hackage.haskell.org/package/gtk3-0.13.7/docs/doc-index-D.html
19:31:33 <L8D> hunteriam: http://hackage.haskell.org/package/gtk3-0.13.7/docs/Graphics-UI-Gtk-Abstract-Widget.html#v:draw
19:31:51 <hunteriam> L8D: ah thanks for the tip about hoogle
19:32:01 <hunteriam> L8D: hows the compiler for the language coming :3
19:39:34 <hunteriam> @L8D howd you find those? with +gtk3 i get no results for draw on hoogle
19:39:34 <lambdabot> Unknown command, try @list
19:40:25 <hunteriam> guys how do i hoogle for +gtk3, no results come up when i do that
19:40:56 <L8D> hunteriam: hunteriam http://hackage.haskell.org/package/gtk3-0.13.7
19:42:09 <gcganley> is there a place where i can ask ELI5 questions about postgres and databases in general
19:44:07 <L8D> gcganley: #postgres
19:44:19 <L8D> #postgresql
19:44:29 <gcganley> which one is more populous
19:45:07 <L8D> gcganley: gcganley #postgresql is the official channel I believe
19:45:13 <L8D> gcganley: #postgres just redirects
19:45:28 <gcganley> L8D: thank you 
19:45:45 <L8D> gcganley: don't be afraid to ask about databases in general too
19:46:00 <L8D> they are (should be) very newb friendly
19:47:55 <lifter> is there an easy way to tell ghc-pkg to unregister all my global packages? I want to reinstall them all now that I've set library profiling to True
19:48:59 <L8D> lifter: I don't think there is a safe way to do that but you can try deleting your .ghc
19:49:09 <L8D> lifter: or .cabal directory
19:49:21 <L8D> but that will likely reset a lot more than you'd like
19:50:04 <lifter> interestingly it looks like my global pkg database is in /opt/ghc/7.8.4/lib/ghc-7.8.4/package.conf.d
19:51:03 <lifter> L8D, anyway, that would just delete the files but not unregister the packages I think
19:58:02 <wilywampa> Can using ($) affect GHC's decision to inline what's left of the '$' when compiling with -O3? I'm seeing a significant performance difference between 'takeWhile foo xs' and 'takeWhile foo $ xs' and found that making inlining 'takeWhile foo' makes the difference go away
20:00:48 <c_wraith> wilywampa: well, 2 is as high as GHC's optimization settings go...
20:01:17 <c_wraith> wilywampa: I'm not sure what GHC does when you say -O3
20:03:09 <Zemyla> Okay, question. Suppose I have data Nat = Z | S Nat, and its associated kind.
20:03:40 <Zemyla> I have a class IsNat n, which is defined for IsNat Z and (IsNat n) => IsNat (S n).
20:03:48 <wilywampa> good to know. it appears to have the same behavior with -O2
20:04:01 <Zemyla> Is there a way to show GHC that every type of kind Nat is an IsNat?
20:05:08 <arkeet> Zemyla: that is false.
20:05:14 <arkeet> because Any.
20:05:43 <Zemyla> arkeet: So types do have a bottom.
20:05:52 <arkeet> Any isn't a bottom.
20:06:00 <Zemyla> I thought Any was just a type. I didn't know it was polykinded.
20:06:05 <arkeet> it inhabits every kind.
20:06:38 <Zemyla> Son of a bitch!
20:07:20 <arkeet> quite.
20:07:21 <albeit> If I have "data Foo = { bar :: !(Maybe ByteString), ... }", can a Foo ever contain a "Maybe *thunk*"?
20:07:37 <rvxi> hi
20:07:45 <albeit> Or does the bang notation on a Maybe mean the ByteString will always be strict as well?
20:08:02 <arkeet> albeit: it only means bar will be in whnf
20:08:07 <arkeet> so yes, it can.
20:08:31 <rvxi> god opengl/webgl  has so much boilerplate. this can't all be necessary...
20:08:43 <arkeet> @let data Foo = Foo { bar :: !(Maybe Int) } deriving Show
20:08:44 <lambdabot>  Defined.
20:08:48 <arkeet> > Foo undefined
20:08:49 <lambdabot>  *Exception: Prelude.undefined
20:08:51 <arkeet> > Foo (Just undefined)
20:08:53 <lambdabot>  Foo {bar = Just *Exception: Prelude.undefined
20:09:00 <arkeet> I guess you meant a Just *thunk*
20:09:11 <albeit> arkeet: Yep
20:09:43 <albeit> arkeet: So until its evaluated further, bar will always be Nothing or Just *thunk*?
20:09:49 <arkeet> right.
20:11:34 <albeit> Great, thanks.
20:12:22 <Zemyla> arkeet: So I still have to provide (IsNat n) to everything that needs it.
20:12:42 <arkeet> yep
20:13:40 <RickP> Snap question: I need a function similar to bracketSnap, but resource release must not depend only on the value retrieved on acquisition, but also on the result of the snap computation. specifically, i take an mvar on acquisition, run it on top of Snap as a state, and put the updated state back into the mvar on release. bracketSnap seems easy to change, but it relies on internals, is there any other way of doing itother than changing t
20:14:27 * hackagebot foma 0.1.0.0 - Simple Haskell bindings for Foma.  http://hackage.haskell.org/package/foma-0.1.0.0 (joom)
20:16:25 <sydneyhacker> Hi need a quick pointer.
20:16:29 <sydneyhacker> In class Monad m => MonadState s m | m -> s where
20:16:38 <sydneyhacker> What does the | m -> s mean?
20:17:11 <arkeet> that is a functional dependency.
20:17:42 <sydneyhacker> arkeet: thanks, I will read up now https://wiki.haskell.org/Functional_dependencies
20:17:45 <arkeet> ok :-)
20:17:58 <arkeet> in short it means:
20:18:34 <arkeet> if you have a constraint MonadState s M (for some specific m), and an instance MonadState S M, then it can infer that s is S.
20:18:47 <arkeet> also it is an error two have two instances MonadState S M and MonadState S' M.
20:18:59 <arkeet> (for some specific M, sorry)
20:19:03 <johnw> "M determines S"
20:19:06 <arkeet> yeah.
20:19:07 <johnw> is how to read the dependency
20:19:13 <arkeet> or "s is a functino of m"
20:19:15 <arkeet> function
20:19:24 <arkeet> hence the terminology.
20:19:28 <johnw> "m implies s" even :)
20:19:58 <johnw> arkeet: neat, I wondered where the terminology came from
20:20:06 <arkeet> I'm just guessing. :-)
20:20:19 <arkeet> but I think it's a good guess.
20:20:44 <arkeet> if a multi-parameter typeclass gives a relation between types, then a functional dependency tells you that that relation is a function.
20:28:05 <bitemyapp> Cale: have you read CM?
20:30:41 <LordBrain> It seems a shame that i have to have two different modules and cut and paste code simply because one works on strict bytestrings while the other on lazy... 
20:31:36 <LordBrain> Such seems like a common issue, and maybe the solution is obvious to someone, but not to me. So could someone tell me how its done if so?
20:33:04 <LordBrain> I suppose the usual haskell way to that is to use a type class, something like... IsChar8ByteString
20:33:35 <sydneyhacker> thanks for the help on functional dependencies. the vector/matrix case in the wiki I get. It is nice and concrete.
20:33:49 <sydneyhacker> The transformer stuff I kind of get
20:33:59 <LordBrain> but then to define IsChar8ByteString in a general manner you end up duplicating all the bytestring functions
20:34:08 <cj3kim> Hi.I am going to be investing a lot of time into Haskell since the initial programs I've made with it were such fun to do. What's the market like for a skill like this? 
20:36:14 <sydneyhacker> so thinking out loud we have:
20:36:19 <sydneyhacker> class Monad m => MonadState s m | m -> s where ...
20:36:24 <sydneyhacker> instance MonadState s m => MonadState s (MaybeT m) where ...
20:36:28 <sydneyhacker> without the constraint, what bad stuff could happen?
20:36:36 <sydneyhacker> I guess you could have instead instance MonadState Char (MaybeT Char)
20:36:42 <sydneyhacker> and MonadState Int (MaybeT Char)
20:37:38 <sydneyhacker> and the compiler would require you to declare the type you wish to recieve?
20:38:04 <LordBrain> I wish there was a major effort to port popular c programs over to haskell.
20:38:49 <LordBrain> such is my language snobbery i guess
20:39:04 <LordBrain> and i don't dislike c even....
20:46:34 <sydneyhacker> LordBrain, what is you reason for wanting c programs ported to haskell?
20:47:20 <dolio> I would say that doesn't make a lot of sense, except there are so many programs unnecessarily written in C.
20:49:32 <dolio> Also the main point of the Monad constraint is to reduce clutter, I think. And it wouldn't make much sense to have a MonadState that wasn't a Monad.
20:49:43 <dolio> It would be a very bad name if that happened.
20:49:50 <LordBrain> right, there are things that present day haskell just doesnt get low level enough, but tons of stuff is just written in c that doesnt need to be. There are multiple reasons, but none really objective, they are subjective things, like i like hacking on haskell, and a larger install base means more people learning haskell... spreading haskell. etc.
20:50:29 <rvxi> lordbrain: what in particular?
20:50:45 <LordBrain> programs i use, like xchat for example...
20:50:58 <LordBrain> gnome...
20:51:05 <rvxi> i think the haskell ecosystem hasn't hit critical mass, but i'm not sure porting C programs is the answer.
20:51:19 <rvxi> why bother with those? they're pretty specialized apps
20:51:35 <rvxi> i would rather see development of more general purpose packages in the ecoyssteme
20:51:37 <LordBrain> they're things i use
20:51:40 <LordBrain> is why..
20:51:55 <rvxi> you use the app or the source for the app?
20:52:16 <LordBrain> well i might get into the source if it was haskell.
20:52:45 <boj> maybe rewrite a small C tool and see if you really mean that?
20:53:19 <LordBrain> rewriting small c tools is pretty easy, i'm not sure what you mean
20:54:40 <sydneyhacker> LordBrain, I think it would be quite viable to write web apps in Haskell as an alternative to RoR, ASP.NET etc. And then use Fay or similar for the client side.
20:55:05 <LordBrain> you think xchat is not viable?
20:55:13 <rvxi_> i don't really see the point. for the same effort general purpose packages would be more useful. or apps that haven't already been written instead of a straight port.
20:55:14 <sydneyhacker> I think that is a serious contender in both the Enterprise and for Open Source
20:55:36 <boj> LordBrain: i am suggesting that in order to get a haskell movement that you desire going, you could head it up.  make a unix utility tool chain or something and get people to adopt it
20:56:01 <LordBrain> oh i've actually thought about that boj
20:58:00 <LordBrain> i have some old project where i started rewriting sed
20:58:15 <Fernandos> hi
20:58:24 <LordBrain> sitting on a hard drive
20:58:31 <rvxi_> hi fernandos
20:58:39 <Fernandos> What signature does main need for this function? hammingDistance ∷ ∀ a . Eq a ⇒ [a] → [a] → Int
20:59:12 <Fernandos> I don't even get why main ∷ IO () doesn't work.. I just print strings at the end
20:59:20 <LordBrain> oh
20:59:29 <LordBrain> you are a beginner?
20:59:45 <Fernandos> I am :)
20:59:57 <Fernandos> The function takes two parametesr putStrLn hammingDistance "001" "111"
20:59:58 <LordBrain> so, you have two functions hammingDistance and main, right?
21:00:04 <Fernandos> yes
21:00:05 <LordBrain> oh
21:00:21 <sydneyhacker> Is the question about the forall (upside down A)?
21:00:24 <LordBrain> well you see, it is giving hammingdistance as a parameter to putStrLn
21:01:08 <sydneyhacker> Sorry I can't read! Forget that
21:01:20 <LordBrain> if you put parentheses around hammingDistance "001" "111", that will help. But another issue is hammingDistance returns Int, and you cant give that to putStrLn, so use print instead.
21:02:04 <LordBrain> main = print (hammingDistance "001" "111")
21:02:47 <LordBrain> putStrLn only takes [Char] or String (which is just a synonym for [Char])
21:03:12 <LordBrain> print takes anything that has an instance of the Show type class defined.
21:05:15 <Fernandos> ah that makes sense LordBrain now it works
21:14:30 * hackagebot ginsu 0.8.1.1 - Ginsu Gale Client  http://hackage.haskell.org/package/ginsu-0.8.1.1 (DylanSimon)
21:19:57 <Fernandos> Why doesn't dropSpaces=dropWhile isSpace  remove space from "1 a b" ?
21:23:10 <LordBrain> because 1 is not a space, and so dropWhile quits before it even gets started
21:23:40 <LordBrain> what you are wanting is dropSpaces = filter (not isSpace)
21:24:24 <LordBrain> dropWhile slurps up the beginning of the list only
21:25:26 <LordBrain> dropWhile isSpace "    1 a b" == "1 a b"
21:26:03 <LordBrain> takeWhile similarly quits once the test fails
21:27:14 <Zemyla> Hmm. I don't know if this type exists anywhere, but I came up with it for some reason.
21:27:16 <Fernandos> ahh
21:27:19 <LordBrain> oops, i meant filter (not . isSpace)
21:27:39 <Zemyla> data Is (b :: Bool) a where { No :: Is False a; Yes :: a -> Is True a }
21:27:42 <LordBrain> the . being the composition operator
21:27:55 <cj3kim> how do i recognize a negative number in pattern recognition? ie toDigits (-a) = [],       toDigits (-1) works 
21:28:07 <johnw> Zemyla: isn't that Maybe a?
21:28:09 <LordBrain> Fernandos, what got you interested in learning Haskell?
21:28:42 <Zemyla> johnw: No, because it's basically data Is False a = No; data Is True a = Yes a.
21:28:53 <Zemyla> No and Yes have different types.
21:30:29 <shachaf> It isn't really that either.
21:32:00 <LordBrain> cj3kim, you mean recognize that the number is less than 0 ?
21:32:10 <cj3kim> LordBrain: yes
21:32:36 <cj3kim> for example, toDigits n = [] works but toDigits (-n) = [] does not
21:32:48 <Fernandos> I am trying out a lot of languages from ADA to Zimbu, but mm_freak got me interested in it.
21:32:54 <LordBrain> toDigits a | a <0 = ...
21:32:56 <cj3kim> but, weirdly enough, toDigits (-1) = [] works as well
21:33:15 <cj3kim> omg >_> that is a PATTERN!
21:33:20 <Fernandos> currently I'm writing algorithms in whatever language I get the code running first :)
21:34:38 <Fernandos> in haskell I write substantially less code than in other languages, but currently I'm very limited by what I know about haskell.. no interactivity, no gui, no graphs,charts or other fancy that I could have with scala+rethinkdb ie.
21:35:40 <cj3kim> LordBrain: Thanks, but is there a way I can have the compile recognizes (-n) as an argument to toDigits?
21:35:49 <cj3kim> compiler*
21:35:53 <LordBrain> -n might be more than 0 you know
21:36:11 <LordBrain> is that really what you want?
21:37:01 <LordBrain> if you mean get the compiler to recognize toDigits (-n) at the call site, it already does...
21:37:14 <cj3kim> well, I'm following a pattern I've learned: toDigits 0 = [], then toDigits (-n) = [], etc 
21:37:29 <cj3kim> I'm not sure if this is the right way to go about it. 
21:38:11 <cj3kim> It looks like it is, but guards seem to be a nice alternative as well
21:38:13 <LordBrain> toDigits (-n) = []  implies that toDigits n = [], because every positive integer has an opposite and vice versa... and the pattern didnt specify that the n was negative or postiive
21:38:46 <cj3kim> ah, I see
21:39:18 <cj3kim> LordBrain: thank you for taking the time to explain that. I had a brain fart :)
21:39:24 <LordBrain> np
21:41:48 <LordBrain> cj3kim, NPlusKPatterns might have been the extension you were trying to remember, but i haven't used that in ages, the more powerful alternative is ViewPatterns... but as I explained, -n isn't even what you really mean to say.
21:54:26 <zacts> huh
21:54:34 <zacts> I seemed to not be able to /join #ghc
21:54:59 <AndoDaan> It has had enough of your shenanigans.
21:55:03 <zacts> oh I got it
21:55:31 <zacts> wait which channel should I chat about haskell-platform bugs?
21:55:46 <zacts> for the haskell-platform's installer for linux
21:56:35 <zacts> I've discovered a huge b0rk for the amd64 linux haskell-platform binary installer
22:01:35 <zacts> http://sprunge.us/RNWN <-- well here is a pastebin of my haskell-platform issue
22:11:24 <LordBrain> anyone running 7.10?
22:13:53 <scutigera> GHCi, version 7.10.1: http://www.haskell.org/ghc/  :? for help
22:13:53 <scutigera>  
22:19:21 <scutigera> LordBrain: are you taking a poll ?
22:20:54 <LordBrain> oh, i just don't have it installed, and i was wishing i could run ghc --supported-extensions on it
22:21:40 <LordBrain> if you want to do me that favor, i'd be grateful, just post its output to pastebin or something
22:21:49 <scutigera> http://lpaste.net/135019
22:21:51 <scutigera> :-)
22:21:52 <LordBrain> thanks
22:21:55 <scutigera> yw
22:22:18 <scutigera> i can only help with very simple things...
22:23:25 <scutigera> is applicative a hackage library or part of the base system ?
22:23:37 <LordBrain> base
22:23:56 <scutigera> but Control.Applicative is a hackage library ?
22:24:08 <scutigera> oops- no  it's base too
22:27:52 <scutigera> !positive <- ...
22:28:01 <scutigera> is the '!' stricness annotation ?
22:28:08 <LordBrain> yeah
22:28:11 <scutigera> ok
22:28:28 <LordBrain> requires BangPatterns
22:29:02 <scutigera> 7.10.1 supports that ! ;-)
22:30:49 <LordBrain> well, that ! seems superfluous to me tho... unless i am mistaken, i think  the pattern to the left of a <- is already strict unless notated as lazy using ~
22:31:21 <scutigera> it's in the attoparsec code, as part of number recognition
22:32:03 <stbuehler> Clint: no
22:34:07 <LordBrain> could you post a link to that code by any chance scutigera ?
22:34:40 <scutigera> http://hackage.haskell.org/package/attoparsec-0.13.0.0/docs/src/Data-Attoparsec-Text.html#double
22:35:04 <scutigera> then skip down to scientifically h = do
22:36:20 <LordBrain> i found it
22:36:50 <LordBrain> it probably is not superfluous
22:38:20 <LordBrain> clearly the author intends for that code to the right of the <- to be executed before continuing.. but i'm honestly not sure that is what he has achieved.
22:39:16 <LordBrain> someone better/more knowledgeable with bang patterns is welcome to step in and clarify for me.
22:48:46 <tamasgal> hi there
22:49:28 <tamasgal> i started with haskell a week ago and thought it would be a good idea to get in touch with the community
22:49:37 <tamasgal> since i read everywhere how nice you are ;)
22:50:09 <kadoban_> tamasgal: Hello and welcome :)
22:50:19 <tamasgal> thanks!
22:50:36 <tamasgal> i'm still confused about haskell but i guess i'll somehow get used to it
22:51:09 <tamasgal> btw. i'm a particle physicist and worked with python for years
22:51:44 <tamasgal> although i love python, i hope that haskell will eventually boost my code and happiness overall ;)
22:52:35 <zipper> tamasgal: I hope so too :D
22:52:44 <kadoban_> tamasgal: This guide has good recommendations to learn from https://github.com/bitemyapp/learnhaskell not sure what you're using already.
22:53:13 <tamasgal> thanks I added it to my learning list!
22:53:32 <tamasgal> i'm currently reading learnyouahaskell.com
22:54:37 <tamasgal> and before sleep i usually fire up my ipad and watch haskell keynotes on youtube ;)
22:54:52 <wei2912> tamasgal: you'll want to look at the guide first
22:54:55 <kadoban_> LYAH is popular, but not the best IMO. Amongst other less obvious problems, it completely lacks exercises.
22:55:03 <wei2912> ^^
22:55:04 <tamasgal> alright
22:55:14 <tamasgal> yea that's truth
22:55:16 <tamasgal> true
22:55:17 <wei2912> a lot of the content has a couple of issues with it
22:55:25 <tamasgal> ok
22:55:39 <wei2912> so i suggest you supplement it by asking questions here
22:55:45 <wei2912> or at #haskell-beginners
22:55:53 <tamasgal> i thought it would be a good idea to skim through it and then begin with some exercises
22:56:07 <tamasgal> got that!
22:56:44 <zipper> tamasgal: Hmmm I should start watching haskell keynotes on you tube
22:57:04 <tamasgal> and in parallel, i constantly go over to projecteuler and try to solve the easier problems in haskell ;)
22:57:07 <zipper> tamasgal: Is searching "haskell keynotes" enough?
22:57:08 <tamasgal> zipper: yea!
22:57:26 <tamasgal> actually "haskell" should be enough, since there is not that much content
22:59:52 <dmj`> tamasgal: did you go through the 99 haskell problems?
23:00:16 <tamasgal> i tried the first 5 or so but well… ;)
23:01:31 <dmj`> tamasgal: I recommend writing out the Prelude, Data.List, and Control.Monad, rewriting Control.Monad really helped me to grok monadic when starting out
23:01:41 <dmj`> monadic code*
23:01:55 <vikaton> haskell install gcc 4.5.2 ?
23:02:16 <tamasgal> dmj`: ok thanks. i'm still struggling with syntax and basic though :D
23:05:48 <dmj`> tamasgal: these lectures were good too, http://shuklan.com/haskell/lec02.html#/
23:06:36 <dmj`> tamasgal: Prof. Kurtz is good too, http://cmsc-16100.cs.uchicago.edu/2014/lectures.php
23:06:47 <tamasgal> dmj`: thanks! *filling my todo list* ;)
23:06:57 <dmj`> tamasgal: and byorgey's course, http://cmsc-16100.cs.uchicago.edu/2014/lectures.php
23:07:19 <dmj`> tamasgal: things really take off when you get to the typeclassopedia though
23:07:25 <dmj`> @typeclassopedia
23:07:25 <lambdabot> Unknown command, try @list
23:07:43 <dmj`> @where typeclassopedia
23:07:43 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
23:07:54 <tamasgal> i hope so. still no idea where to start if i want to do real work ;)
23:08:02 <dmj`> tamasgal: what do you want to do?
23:08:28 <tamasgal> well, most of the time i need to parse binary or text files
23:08:39 <tamasgal> which contain data from our neutrino detector
23:08:56 <tamasgal> and then analysis stuff, reconstructing events etc.
23:09:24 <tamasgal> so at some point i need different kinds of binary/text parsers and the actual math code working (including minimiser, optimiser etc.)
23:09:33 <kadoban_> Parsing is pretty neat in haskell. It's not very clear without the basics though of course.
23:09:44 <tamasgal> i see
23:11:07 <tamasgal> i also hope to take a real benefit of the multiple cpus
23:11:17 <dmj`> tamasgal: yea parsing requires an understanding of functors, applicatives, and monads. You'll have to understand Maybe, List, Either, State, and Error data types. You'll also have to learn about I/O, using bytestrings, and lazy evaluation (and it's pitfalls w/ I/O). You'll probably want to use stream parsing.
23:12:01 <tamasgal> lot of stuff ;) looking forward to it!
23:13:45 <dmj`> tamasgal: for binary parsing attoparsec is great
23:13:49 <dmj`> @package attoparsec
23:13:50 <lambdabot> http://hackage.haskell.org/package/attoparsec
23:14:03 <tamasgal> ah, nice
23:14:57 <tamasgal> so can you say that cabal is basically "the packet manager" for haskell stuff? like pip for python?
23:15:20 <dmj`> tamasgal: more or less yea
23:15:33 <tamasgal> are there alternatives or why "more or less"?
23:16:10 <dmj`> tamasgal: there's debate on what the scope of a package manager really is, and if cabal meets that criteria
23:16:44 <dmj`> tamasgal: https://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/
23:16:50 <kadoban> cabal is unfortunately not that great to use in general. It requires a decent amount of working around before the pain disappears, though as a beginner it largely doesn't matter, you can figure it out later.
23:16:52 <tamasgal> yea i already read that
23:17:18 <tamasgal> but it's from 2010 and i thought there were some progress ;)
23:17:21 <ttt_fff> in Either, is "Left blah" the error ?
23:17:55 <tamasgal> kadoban: alright
23:19:56 <felixn> ttt_fff: yea
23:20:10 <ttt_fff> this is because in the monatic the Right data type is the one that is 'changing'
23:20:14 <ttt_fff> so the LEft has to be the error ?
23:22:44 <felixn> ttt_fff: yea so the right carries, and left halts, using EitherT is really fun
23:23:01 <kadoban> ttt_fff: It's basically arbitrary, but yes the choice is kind of fixed for you by the Functor instance and such.
23:23:06 <ttt_fff> felixn: what do I need EitherT instead of just Either ?
23:23:17 <ttt_fff> oh, this is for stacking monads ?
23:23:24 <ttt_fff> you and your fancy stacked monads
23:23:37 <felixn> ttt_fff: yea, so if you have some monadic computation, and you want the whole thing to error at any point
23:23:47 <ttt_fff> This is very cute.
23:23:54 <ttt_fff> I finally understand why haskellers are like "error is bad idea; use monads!"
23:24:42 <felixn> 🎉
23:25:05 <felixn> I mean ... haskell has exceptions >_< head []
23:25:44 <felixn> but we don't talk about that
23:44:37 * hackagebot discrimination 0.1 - Fast generic linear-time sorting, joins and container construction.  http://hackage.haskell.org/package/discrimination-0.1 (EdwardKmett)
23:45:12 <edwardk> ^- now online =)
23:45:24 <edwardk> no idea how much slower grouping and the like got though
23:46:31 <liste> now the Haskell community can have discrimination too! ; )
23:47:17 <edwardk> it was important that i teach the world how to do discrimination properly online =)
23:49:47 <adarqui> joe armstrong always "complains" about being so distracted at work.. can't get anything done.. it like that for you guys?
23:49:55 <tdammers_> hell yeah
23:50:07 <adarqui> or maybe not him anymore but just in general, and for most development teams/companies
23:50:10 <tdammers_> part of it is environment, but the other part is myself
23:50:35 <tdammers_> but ultimately, I believe the true cause is having to work on something that doesn't interest me enough
23:50:42 <edwardk> tdammers_: thats a large part of why i'm awake here at 3am fiddling with code
23:51:07 <adarqui> edwardk: because you couldn't get it done at work? distractions? meetings and such?
23:51:16 <tdammers_> meeting are the worst
23:51:17 <adarqui> tdammers_: same here, mostly environment though.. i prefer to be in a soundless cave
23:51:42 <tdammers_> a 30-minute meeting can easily destroy 8 hours of productivity
23:51:45 <edwardk> there's not so much in the way of meetings in my day to day existence
23:52:20 <tdammers_> for me, it varies... I've had a crazy streak with meetings almost every day; didn't get anything done at all
23:52:32 <tdammers_> but right now, I get to do plenty of actual coding, which is good
23:53:04 <adarqui> i feel it stabbing my mind.. maybe remote work is the answer
23:53:06 <adarqui> cool tdammers_ 
23:53:58 <saulzar> People walking backward and forward and generally milling around is bad enough
23:54:02 <adarqui> edwardk: do you typically get a good amount of sleep? or are you one of those little to no sleep people?
23:54:27 <edwardk> i get by with a bit less than most folks do
23:56:05 <tdammers_> sleep is a problem for me
23:56:14 <tdammers_> not because I don't get enough, but because I get it at the wrong times
23:57:01 <tdammers_> my natural sleep pattern (which occurs whenever I can freewheel for a few weeks) is to sleep from 3 am to noon, but that's not compatible with the rest of the world
23:57:14 <saulzar> Me too, it causes trouble in my life
23:57:16 <tdammers_> so my actual sleep pattern is more like 11 pm to 6 am
23:57:31 <tdammers_> and no matter what people say, you don't get used to it
23:57:40 <tdammers_> after 8 years of it, it still sucks
23:58:00 <tdammers_> I run a lot, which helps in that I can catch sleep more easily
23:58:18 <tdammers_> but I've never felt as fresh as I did when I could sleep naturally
23:58:25 <saulzar> Hmm. I do too but I tend to do that in the "morning"
23:58:38 <tdammers_> I'd have to get up even earlier - no way
23:59:06 <tdammers_> my usual run is 90 minutes, add some prep and post-run rituals, I'd have to get up at 4
23:59:12 <saulzar> I have a pretty flexible schedule, and it's winter here so I tend to run while the sun is still out
23:59:47 <tdammers_> plus I hate running fresh out of bad, no matter the time
23:59:51 <tdammers_> stiff muscles and all
23:59:57 <saulzar> But people don't really understand why I like to work at night, so it always causes conflict..
