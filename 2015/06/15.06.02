00:00:13 <Flonk> I've always found haikus awkward to read, and now I know it's because most westerners don't know the difference between a mora and a syllable either and they've been doing it wrong all along
00:00:21 <Flonk> It's 5-7-5 syllables though:
00:00:51 <Flonk> Mo-nad-ax-i-oms Klei-sli-com-po-si-tion-forms a-ca-te-go-ry
00:01:39 <fumieval> oh
00:02:01 <pacak> fumieval: You can't spell Jaapanese like that. It should be somethinig like mo-na-da-ku-si-o-ma-su ku-re-i-sa-ri co-mu-po-si-ti-on ...
00:02:37 <mniip> kureisari
00:02:45 <mniip> lol
00:02:55 <fumieval> pacak: yeah that was just an approxiation
00:04:47 <Flonk> mniip: kureisari-san (^･o･^)ﾉ”
00:05:11 <dramforever> you can't spell english like japanese
00:05:12 <fumieval> actually the accent is fierce in Japan:  mo-na-do-a-ku-si-o-mu-su ku-ra-i-su-ri-co-n-po-ji-syo-n
00:06:35 <mniip> Flonk, is it pronounced hasakeru then? :o
00:07:52 <dramforever> that reminds me of a question
00:08:12 <dramforever> do you pronounce "often" with or without the "t" sound?
00:08:43 <calvinx> Is there a way to re-generate my `.cabal/config` if I accidentally screw it up?
00:08:58 <Haskellfant> delete it and run cabal update
00:09:04 <Haskellfant> ro just move it out of the way
00:09:07 <calvinx> ok
00:09:16 <Haskellfant> s/ro/or/
00:11:15 <gracjan> http://www.reddit.com/r/haskell/comments/383p16/month_in_haskell_mode_may_2015/
00:14:18 <Flonk> mniip: Project for the weekend: Redesign the entire haskell standard lib to use japanese emoticons and release it as hasakeru 
00:14:41 <mniip> and japaneselike function names
00:15:02 <DerisiveLogic> LOL
00:15:46 <DerisiveLogic> ifu 5 modu 3 == 0 printu haiku
00:16:53 <mniip> derekv, purintu
00:17:03 <mniip> DerisiveLogic, *
00:17:08 <dramforever> ShowerThought: How many pairs of definitions can be applied in Prelude?
00:17:16 <dramforever> for example (just trying)
00:17:21 <dramforever> :t (.) (<*>)
00:17:23 <lambdabot> Applicative f => (a -> f (a1 -> b)) -> a -> f a1 -> f b
00:18:05 <dramforever> :t (<*>) (<*>)
00:18:06 <lambdabot> Applicative f => (f (a -> b) -> f a) -> f (a -> b) -> f b
00:18:13 <mniip> dramforever, anything where first argument is polymorphic enough to take a function
00:18:30 <dramforever> mniip: yep, also look:
00:18:35 <dramforever> :t traverse traverse traverst
00:18:37 <lambdabot>     Not in scope: ‘traverst’
00:18:37 <lambdabot>     Perhaps you meant one of these:
00:18:37 <lambdabot>       ‘traverse’ (imported from Control.Lens),
00:18:45 <dramforever> :t traverse traverse traverse traverse
00:18:47 <lambdabot> (Applicative f, Applicative f1, Traversable t, Traversable ((->) (t a)), Traversable ((->) (a -> f1 b1)), Traversable ((->) (f1 (t b1) -> f b))) => (f1 (t b1) -> f b) -> f ((a -> f1 b1) -> t a -> b)
00:19:01 <dramforever> what the...
00:19:10 <mniip> :t fmap fmap fmap fmap
00:19:11 <lambdabot> (Functor f, Functor f1, Functor f2) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
00:19:29 <DerisiveLogic> mniip: Heh.
00:19:31 <dramforever> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap 
00:19:33 <lambdabot> (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
00:19:40 <sydneyhacker> :t (+1) (+1)(+1)(+1)(+1)(+1)(+1)(+1)(+1)(+1)(+1)(+1)(+1)(+1)(+1)(+1)(+1)(+1)(+1)(+1)(+1)(+1)(+1)
00:20:14 <mniip> :t (+)(+)(+)(+)(+)(+)(+)(+)(+)(+)
00:20:16 <lambdabot> (Num a, Num (a -> a -> a), Num ((a -> a -> a) -> (a -> a -> a) -> a -> a -> a), Num (((a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> ((a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> (a -> a -> a) -> (a -> a -> a) -> a -> a -> a), Num ((((a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> ((a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> (a ->
00:20:16 <lambdabot> a -> a) -> (a -> a -> a) -> a -> a -> a) -> (((a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> ((a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> (a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> ((a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> ((a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> (a -> a -> a) -> (a -> a -> a) -> a -> a -> a),
00:20:16 <lambdabot> Num (((((a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> ((a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> (a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> (((a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> ((a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> (a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> ((a -> a -> a) -> (a -> a -> a) -> a
00:20:16 <lambdabot> -> a -> a) -> ((a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> (a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> ((((a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> ((a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> (a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> (((a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> ((a -> a -> a) -> (a -> a ->
00:20:16 <lambdabot>  a) -> a -> a -> a) -> (a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> ((a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> ((a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> (a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> (((a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> ((a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> (a -> a -> a) -> (a -
00:20:18 <lambdabot> > a -> a) -> a -> a -> a) -> (((a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> ((a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> (a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> ((a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> ((a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> (a -> a -> a) -> (a -> a -> a) -> a -> a -> a)) => (a -> a -> a)
00:20:20 <lambdabot> -> a -> a -> a
00:20:21 <mniip> omg stop
00:20:23 <dramforever> aww aww
00:20:47 <dramforever> also one funny thing:
00:20:52 <dramforever> :t (<*>) . (<*>)
00:20:53 <lambdabot> (a -> a1 -> b) -> ((a -> a1) -> a) -> (a -> a1) -> b
00:21:12 <mniip> dramforever, a high japanese man?
00:21:17 <Flonk> :t let mconcatAp = (mconcat.).ap in mconcatAp [concatMap]
00:21:20 <lambdabot> Foldable t => [a -> [b]] -> t a -> [b]
00:21:28 <dramforever> mniip: ??
00:21:34 <mniip> the emoticon
00:22:03 <dramforever> mniip: wow i didn't notice that...
00:23:08 <dramforever> the funny thing is that the type didn't have "Applicative" in it
00:26:27 <liste> :t (\f g -> f <*> g)
00:26:29 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
00:30:15 <newsham> > flip execState (125,35) $ whileM_ ((/= 0) <$> gets snd) (modify $ \(a,b) -> (b, a `mod` b)) 
00:30:18 <lambdabot>  (5,0)
00:32:24 <liste> :t unfoldr
00:32:26 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
00:34:23 <liste> > filter ((>0).snd) . iterate (\(a, b) -> (b, a `mod` b)) $ (5,0)
00:34:25 <lambdabot>  *Exception: divide by zero
00:34:57 <liste> > filter ((>0).snd) . iterate (\(a, b) -> (b, a `mod` b)) $ (125,35)
00:35:00 <lambdabot>  [(125,35),(35,20),(20,15),(15,5)*Exception: divide by zero
00:37:39 <liste> > filter ((>0).snd) . iterate (\(a, b) -> (b, if b == 0 then 0 else a `mod` b)) $ (125,35)
00:37:43 <lambdabot>  mueval-core: Time limit exceeded
00:38:07 <frerich> :t concatMap
00:38:09 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
00:45:46 * hackagebot string-conversions 0.4 - Simplifies dealing with different types for strings  http://hackage.haskell.org/package/string-conversions-0.4 (SoenkeHahn)
00:51:35 <latermuse> is there an equivalent of hGetLine for bytestrings or text?
00:52:16 <liste> latermuse how big amounts?
00:52:20 <quchen2> latermuse: hoogle "+text hgetline"
00:52:31 <quchen2> Bytestrings don't have lines
00:52:32 <pacak> latermuse: hGetLine
00:52:38 <dramforever> :t Data.Text.IO.hGetLine
00:52:40 <lambdabot> GHC.IO.Handle.Types.Handle -> IO Data.Text.Internal.Text
00:52:49 <latermuse> thanks quchen
00:52:57 <pacak> :t Data.ByteString.hGetLine
00:52:58 <lambdabot> GHC.IO.Handle.Types.Handle -> IO BSC.ByteString
00:53:25 <latermuse> sorry this answer was obvious. had a brain fart. carry on!
00:53:51 <latermuse> what I needed was to switch to using this: Network.Socket.ByteString.Lazy
01:09:00 <Flonk> So the gist of it is that we need the term 'category' because some classes of objects are too large to fit inside a set. Which brings up the question: How large can a set be?
01:09:34 <Cale> Flonk: Uh, perhaps you're confusing "category" with "class"
01:09:53 <Flonk> Well a category is essentially two classes, isn't it?
01:09:59 <Cale> uhhh
01:10:01 <Cale> No
01:10:28 <dramforever> hmm....people talking about the basics of category theory
01:10:31 <Flonk> Cale: what am I missing? :D
01:10:32 * dramforever is interested
01:10:39 <Cale> Flonk: Most of the definition?
01:11:35 <Flonk> Cale: you mean associativity and identity morphisms?
01:11:44 <Cale> and *composition*
01:11:51 <Cale> Most of the structure of a category is about the composition
01:11:55 <Cale> Generally.
01:12:06 <Flonk> psssh, details! :D
01:12:10 <Cale> You can get some mileage out of which pairs of objects have arrows between them at all
01:13:06 <Cale> The arrows are just there so we have something for composition to act on. The objects are just there so that we know which arrows can be composed.
01:14:06 <Cale> What the objects and arrows "are" is irrelevant, they're just opaque labels from the perspective of category theory
01:15:40 <Cale> (and indeed, the notions of isomorphism and equivalence of categories will ignore any internal details about what the objects and arrows are made of)
01:16:19 <dramforever> Cale: oh great, from https://wiki.haskell.org/Category_theory/Functor I just learned that <= can be an arrow too
01:16:22 <dramforever> that's good
01:16:31 <dramforever> and yes, I mean "less than or equal to"
01:16:51 <dramforever> is that correct?
01:16:55 <Flonk> Cale: You're right about all that, of course, and I know about the category laws. Sorry for being sloppy :P
01:17:21 <dramforever> I'm no less sloppy :P
01:17:35 <Flonk> My main question was about when a class becomes too large to be contained in a set
01:17:44 <qubitnerd> op here ?
01:20:43 <johnw> qubitnerd: yes
01:20:48 * hackagebot homplexity 0.2 - Haskell code quality tool  http://hackage.haskell.org/package/homplexity-0.2 (MichalGajda)
01:20:50 * hackagebot homplexity 0.2.0.0 - Haskell code quality tool  http://hackage.haskell.org/package/homplexity-0.2.0.0 (MichalGajda)
01:23:12 <Flonk> Or, as a related question, why can't the set of all sets contain itself (which is what I read in every introductory cat theory text)
01:24:03 <liste> Flonk it's called Russell's Paradox
01:24:57 <Flonk> liste: ah, I'll look that up, thanks :)
01:27:02 <dramforever> Flonk: look over here: http://en.wikipedia.org/wiki/Zermelo%E2%80%93Fraenkel_set_theory#2._Axiom_of_regularity_.28also_called_the_Axiom_of_foundation.29
01:27:08 <Myrl-chan> > unit
01:27:10 <lambdabot>      Not in scope: ‘unit’
01:27:10 <lambdabot>      Perhaps you meant one of these:
01:27:10 <lambdabot>        ‘init’ (imported from Data.List),
01:27:25 <Myrl-chan> > cycle . return $ 1
01:27:26 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
01:27:38 <Myrl-chan> Oh cool.
01:27:40 <dramforever> > repeat 1
01:27:42 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
01:27:46 <Myrl-chan> dramforever: Lol. :P
01:28:07 <AleksejsWork> > fix (1:)
01:28:08 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
01:28:33 <Flonk> dramforever: Well, that clears it up!
01:28:56 <Myrl-chan> >=> <=<
01:29:01 <Myrl-chan> <><
01:29:26 <Myrl-chan> > [] <> [1,2]
01:29:28 <lambdabot>  [1,2]
01:29:32 <Myrl-chan> > [3] <> [1,2]
01:29:36 <lambdabot>  [3,1,2]
01:29:38 <Myrl-chan> I see..
01:32:22 <latermuse> > [1,1..]
01:32:24 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
01:38:20 <ion> > [36893488147419103233,18446744073709551617..] :: [Int]
01:38:22 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
01:41:43 <frerich> wat
01:42:18 <verement> > maxBound :: Int
01:42:21 <lambdabot>  9223372036854775807
01:42:31 <AleksejsWork> > 9999999999999999999999999 :: Int
01:42:33 <lambdabot>  1590897978359414783
01:42:49 <AleksejsWork> idgi
01:43:04 <ggVGc> does anyone have any examples of using HJScript, or something similar?
01:43:51 <Myrl-chan> alang: Lol. Integer overflow.
01:44:12 <Myrl-chan> AleksejsWork: *
01:44:14 <AleksejsWork> I see, these are 100...001
01:44:34 <Myrl-chan> > maxBound :: UINt
01:44:36 <lambdabot>  Not in scope: type constructor or class ‘UINt’
01:44:37 <Myrl-chan> > maxBound :: UInt
01:44:39 <lambdabot>      Not in scope: type constructor or class ‘UInt’
01:44:39 <lambdabot>      Perhaps you meant ‘Int’ (imported from Data.Int)
01:44:44 <Myrl-chan> Hmm..
01:44:48 <Myrl-chan> > maxBound :: Word64
01:44:50 <lambdabot>  18446744073709551615
01:45:02 <verement> > (9999999999999999999999999 :: Integer) `mod` 9223372036854775808
01:45:05 <Myrl-chan> > minBound :: Word64
01:45:06 <lambdabot>  <hint>:1:3: lexical error at character '\ACK'
01:45:08 <lambdabot>  0
01:45:40 <Myrl-chan> > maxBound :: Int64
01:45:42 <lambdabot>  9223372036854775807
01:45:52 <Myrl-chan> IDGI either.
01:46:11 <Myrl-chan> Oh, I get it now.
01:46:34 <AleksejsWork> Myrl-chan: 
01:46:38 <Myrl-chan> > (9999999999999999999999999) `mod`  9223372036854775808
01:46:38 <AleksejsWork> > [2^64+1, 2^65+1 ..] :: [Int]
01:46:41 <lambdabot>  mueval-core: L.hs: removeLink: does not exist (No such file or directory)
01:46:41 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
01:47:06 <Myrl-chan> > (9999999999999999999999999) `mod` 9223372036854775808
01:47:09 <lambdabot>  1590897978359414783
01:47:12 <ion> It's hilarious that lambdabot still has that L.hs race condition.
01:47:21 <Myrl-chan> ion: What does that mean? :P
01:48:11 <ion> Something like one evaluator deleting and rewriting it while another evaluator tries to use it.
01:49:23 <int-e> Myrl-chan: AFAIU this is fixed in the git version of mueval, but gwern has not made a hackage release in ages. And I simply haven't been bothered enough to set up lambdabot with the git version.
01:49:30 <thebnq> why.. do i see part of 9999999999999999999999999 blinking
01:49:45 <MP2E> same here thebnq
01:49:59 <Myrl-chan> lol
01:50:01 <Myrl-chan> Really?
01:50:30 <dramforever> thebnq: what irc client are you using
01:50:34 <thebnq> 9'9999999999999999999'99999 <- that middle part is blinking
01:50:35 <thebnq> irssi
01:50:46 <MP2E> same 
01:50:50 <Myrl-chan> irssi hear. Doesn't happen to me.
01:50:50 <thebnq> only verement's is blinking, not Myrl-chan 
01:50:57 <thebnq> weird
01:50:58 <Myrl-chan> here*
01:51:17 <Myrl-chan> Also, that's why lambdabot errored
01:51:24 <Myrl-chan> There's a control character
01:51:41 <Myrl-chan> Myrl-chan states the obvious again.
01:51:54 <thebnq> yea i didn't notice, whats ack
01:52:08 <Myrl-chan> Dunno what ack is/
01:54:17 <latermuse> I dont see it either on irssi
01:54:18 <f|`-`|f> uh
01:54:26 <f|`-`|f> ack as in syn ack?
01:54:46 <blue_deref> f|`-`|f: syn ack as in syn-synack-ack??
01:55:50 * hackagebot influxdb 0.9.1.3 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-0.9.1.3 (MitsutoshiAoe)
01:57:46 <xj54y> So... Looks like I'm certainly stumbling my way through haskell in the real world and the lambda school of expression... Any recommended texts/manuals? I really enjoyed Mastering Algorithms with Perl, though haven't seen much outside of academic works which cover similar subjects...
01:57:49 <YellowOnion> @pl \x -> x . x
01:57:49 <lambdabot> join (.)
01:59:11 <f|`-`|f> blew my mind like gooey god damn, blue_
01:59:16 <f|`-`|f> blue_deref  
01:59:37 <f|`-`|f> hmmm
02:02:54 <f|`-`|f> > iterate (join (.)) (+1) <*> [1]
02:02:56 <lambdabot>  [2,3,5,9,17,33,65,129,257,513,1025,2049,4097,8193,16385,32769,65537,131073,*...
02:03:01 <f|`-`|f> I may have leonardo'd
02:03:12 <f|`-`|f> is this leonardo number
02:04:00 <f|`-`|f> no
02:04:14 <f|`-`|f> I'm adding powers of two to one
02:04:57 <ion> > ord '\ACK'
02:05:00 <dramforever> f|`-`|f: wow...how are you even...doing it?
02:05:00 <lambdabot>  6
02:07:04 <Myrl-chan> :t iterate
02:07:06 <lambdabot> (a -> a) -> a -> [a]
02:07:19 <Myrl-chan> iterate (^2)
02:07:22 <f|`-`|f> :t join (.)
02:07:23 <Myrl-chan> oops
02:07:24 <lambdabot> (c -> c) -> c -> c
02:07:33 <Myrl-chan> > iterate (^2) 1
02:07:35 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
02:07:39 <Myrl-chan> EHHH
02:07:47 <Myrl-chan> > iterate (+1) 1
02:07:48 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
02:07:52 <f|`-`|f> > iterate (^2) 2
02:07:54 <lambdabot>  [2,4,16,256,65536,4294967296,18446744073709551616,34028236692093846346337460...
02:08:13 <f|`-`|f> > iterate (*2) 2
02:08:14 <Myrl-chan> I see...
02:08:15 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
02:08:32 <Myrl-chan> Looks a bit like scanl.
02:08:36 <Myrl-chan> Or not.
02:08:40 <liste> xj54y do you want beginner or intermediate-level?
02:08:41 <f|`-`|f> it isn't, really
02:08:49 <f|`-`|f> well
02:08:51 <f|`-`|f> it is
02:08:57 <f|`-`|f> could be, anyways
02:09:12 <f|`-`|f> iterate f a = a : iterate f (f a)
02:09:23 <Myrl-chan> Ah
02:09:29 <f|`-`|f> @src iterate
02:09:29 <lambdabot> iterate f x = x : iterate f (f x)
02:09:33 <f|`-`|f> ayyyyyy
02:09:47 <Myrl-chan> w0w
02:10:12 <f|`-`|f> Try out making iterate in terms of scanl, then
02:10:41 <Myrl-chan> I can't. :c
02:11:12 <Myrl-chan> Hmmm
02:11:13 <Myrl-chan> :t scanl1
02:11:16 <lambdabot> (a -> a -> a) -> [a] -> [a]
02:11:34 <liste> xj54y for persistent data structures, Okasaki's Purely Functional Data Structures is the go-to text
02:11:46 <f|`-`|f> (welp, already figured out the problem)
02:12:02 <Myrl-chan> scanl1 ((^2) . const) (repeat [1,1..])
02:12:08 <liste> not Haskell, though
02:12:10 <Myrl-chan> > scanl1 ((^2) . const) (repeat [1,1..])
02:12:12 <lambdabot>      No instance for (Show t0)
02:12:12 <lambdabot>        arising from a use of ‘show_M328208211362696990713008’
02:12:12 <lambdabot>      The type variable ‘t0’ is ambiguous
02:12:17 <Myrl-chan> Hmmm
02:12:26 <Myrl-chan> :t (^2) . const
02:12:28 <lambdabot> Num (b -> a) => a -> b -> a
02:12:55 <Myrl-chan> Oh wait
02:13:17 <Myrl-chan> > scanl1 (const (^2)) (repeat [1,1..])
02:13:18 <lambdabot>      No instance for (Show t0)
02:13:18 <lambdabot>        arising from a use of ‘show_M355842603110105894213038’
02:13:18 <lambdabot>      The type variable ‘t0’ is ambiguous
02:13:23 <Myrl-chan> :t const (^2)
02:13:24 <lambdabot> Num a => b -> a -> a
02:13:28 <f|`-`|f> dude
02:13:28 <Myrl-chan> Eh
02:13:35 <f|`-`|f> :t repeat
02:13:35 <Myrl-chan> > scanl1 (const (^2)) (repeat 1)
02:13:36 <lambdabot> a -> [a]
02:13:38 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
02:13:41 <Myrl-chan> > scanl1 (const (^2)) (repeat 2)
02:13:45 <lambdabot>  [2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4...
02:13:49 <Myrl-chan> Lol
02:13:56 <Myrl-chan> > scanl1 (flip . const (^2)) (repeat 2)
02:13:57 <f|`-`|f> you can do this in pm's, dude
02:13:58 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ (a -> c) -> c
02:13:58 <lambdabot>      Expected type: a -> (a -> c) -> c
02:13:58 <lambdabot>        Actual type: a -> a
02:14:04 <Myrl-chan> Meh, I'm no longer doing this.
02:14:17 <Myrl-chan> One last.
02:14:20 <latk> I need to compile something on linux, does anyone know of a working vagrant box on 7.10.1 ?
02:14:22 <Myrl-chan> > scanl1 (flip $ const (^2)) (repeat 2)
02:14:25 <lambdabot>  [2,4,16,256,65536,4294967296,18446744073709551616,34028236692093846346337460...
02:14:59 <mniip> Myrl-chan, ...
02:15:03 <Myrl-chan> mniip: What.
02:15:07 <mniip> > iterate (2^) 1
02:15:09 <lambdabot>  [1,2,4,16,65536,200352993040684646497907235156025575044782547556975141926501...
02:15:16 <mniip> no wait
02:15:20 <mniip> > iterate (^2) 2
02:15:21 <lambdabot>  [2,4,16,256,65536,4294967296,18446744073709551616,34028236692093846346337460...
02:15:24 <Myrl-chan> I know.
02:15:25 <f|`-`|f> ahahahaha
02:15:25 <Myrl-chan> :P
02:15:30 <mniip> I was thinking of a different function
02:15:47 <Myrl-chan> mniip: f|`-`|f wanted to see me make iterate with scanl.
02:15:51 <mniip> oh
02:15:53 <mniip> sure you can
02:16:01 <f|`-`|f> > (+1) <$> $ iterate (*2) 1
02:16:03 <lambdabot>  <hint>:1:10:
02:16:03 <lambdabot>      parse error on input ‘$’
02:16:03 <lambdabot>      Perhaps you intended to use TemplateHaskell
02:16:11 <f|`-`|f> > (+1) <$> ( iterate (*2) 1 )
02:16:14 <lambdabot>  [2,3,5,9,17,33,65,129,257,513,1025,2049,4097,8193,16385,32769,65537,131073,2...
02:16:23 <jle`> :t \f x -> scanl1 (const id f) (repeat x)
02:16:24 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ a -> a
02:16:24 <lambdabot>     Expected type: a -> a -> a
02:16:24 <lambdabot>       Actual type: a -> a
02:16:45 <jle`> :t \f x -> scanl1 (flip (const (^2))) (repeat x)
02:16:47 <lambdabot> Num b => r -> b -> [b]
02:16:50 <jle`> :t iterate
02:16:51 <lambdabot> (a -> a) -> a -> [a]
02:16:56 <jle`> oh lol
02:17:05 <f|`-`|f> nooooooooooobs
02:17:05 <jle`> :t \f x -> scanl1 (flip (const f)) (repeat x)
02:17:07 <lambdabot> (b -> b) -> b -> [b]
02:17:10 <jle`> there
02:17:11 <f|`-`|f> yay
02:17:21 <Myrl-chan> jle`: I already did it though...
02:17:22 <Myrl-chan> :|
02:17:31 <jle`> i am demonstrating your answer :o
02:17:36 <jle`> i am on your team ^_^
02:17:41 <f|`-`|f> (quick save)
02:17:42 <Myrl-chan> \f x -> scanl1 (flip (const f)) (x:(repeat mempty))
02:17:46 <Myrl-chan> :t \f x -> scanl1 (flip (const f)) (x:(repeat mempty))
02:17:48 <lambdabot> Monoid b => (b -> b) -> b -> [b]
02:18:14 <Myrl-chan> > (\f x -> scanl1 (flip (const f)) (x:(repeat mempty))) (^2) 2
02:18:16 <lambdabot>      No instance for (Show b0)
02:18:17 <lambdabot>        arising from a use of ‘show_M828703876528401037513264’
02:18:19 <lambdabot>      The type variable ‘b0’ is ambiguous
02:18:20 <Myrl-chan> waaat
02:18:40 <jle`> x : repeat mempty
02:18:46 <jle`> there is no mempty for Int
02:18:50 <Myrl-chan> Really?
02:18:51 <jle`> or Integer, or whatever you are trying to do
02:18:54 <Myrl-chan> mempty :: Int
02:19:01 <Myrl-chan> > mempty :: Int
02:19:02 <lambdabot>      No instance for (Monoid Int) arising from a use of ‘mempty’
02:19:02 <lambdabot>      In the expression: mempty :: Int
02:19:03 <jle`> yeah, there are two possible monoids
02:19:07 <Myrl-chan> oh yeah.
02:19:08 <jle`> so we decide to not have one as the default
02:19:08 <Myrl-chan> True.
02:19:10 <f|`-`|f> the sum mempty
02:19:17 <f|`-`|f> and the multiplicative mempty
02:19:32 <Myrl-chan> The powers mempty?
02:19:34 <f|`-`|f> no one cares for the exponential one
02:19:45 <Myrl-chan> f|`-`|f: lol
02:19:47 <jle`> what is the exponential one?
02:19:48 <f|`-`|f> I forgot the term for the thing above that
02:19:50 <mniip> iterate f x = scanl (const f) x (repeat x)
02:20:00 <Myrl-chan> Hmmm...
02:20:04 <f|`-`|f> probably 1
02:20:09 <Myrl-chan> Actually, there can't be an exponential monoid
02:20:11 <f|`-`|f> n^1 = n
02:20:19 <jle`> doesn't look very associative to me
02:20:19 <Myrl-chan> It's neither commutative nor associative
02:20:24 <f|`-`|f> o
02:20:27 <jle`> well monoids don't have to be commutative
02:20:32 <ion> Exponentiation does not satisfy the monoid laws.
02:20:35 <f|`-`|f> ah
02:20:42 <f|`-`|f> it's not associative then
02:20:46 <jle`> if they did then [a] wouldn't be one
02:20:55 <jle`> also there really isn't a left identity either :3
02:21:09 <Myrl-chan> jle`: I heard that it must be commutative or associative. (Logical or, not English orr)
02:21:12 <Myrl-chan> or*
02:21:13 <f|`-`|f> where is Mr Crack Bananas
02:21:20 <jle`> hm, where did you hear that?
02:21:23 <f|`-`|f> you mean inclusive
02:21:31 <Myrl-chan> ior.
02:21:42 * f|`-`|f checks for pooh
02:22:09 <mniip> Myrl-chan, only associative
02:22:14 <mniip> also should have an identity
02:22:28 <mniip> (left identity and right identity should be the same element)
02:22:34 <Myrl-chan> I must have been wrong den.
02:22:35 <Myrl-chan> :c
02:22:42 <Myrl-chan> I should read moar purrperly.
02:22:42 <mniip> or actually, should be an element that is both left and right identity
02:22:48 <divVerent> BTW: addition and multiplication in Int on overflow - is this defined to wrap around (i.e. modulo 2 ** something)?
02:23:27 <divVerent> seems like it's undefined, but then mathematically speaking Int isn't a monoid :P
02:24:08 <jle`> neither is Double, so
02:24:23 <divVerent> Double even less
02:24:25 <divVerent> it's not even associative
02:24:56 <Myrl-chan> Yeah.
02:25:09 <jle`> wait, integers under modulo are a monoid
02:25:13 <divVerent> just another reason why the Monoid instances for Num are hidden behind wrappers like Product, Sum
02:25:19 <divVerent> under modulo they are
02:25:31 <divVerent> but at least according to https://www.haskell.org/onlinereport/basic.html#numbers, overflow is undefined
02:25:37 <jle`> ah
02:25:56 <jle`> it's defined for ghc though
02:26:06 <divVerent> at least on the platforms I know
02:26:16 <divVerent> not sure whether GHC supports any platforms where this isn't true
02:26:25 <jle`> https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Int.html
02:26:32 <jle`> GHC spec says it is true
02:26:36 <Myrl-chan> What if there's a one's complement(EEEWWW) system out there?
02:26:54 <jle`> GHC spec demands that Int from Data.Int works under modulo
02:27:13 <jle`> so presumably a non-standard architecture would also have to work this way
02:27:15 <divVerent> Myrl-chan: then either the GHC spec needs changing
02:27:28 <divVerent> or GHC has to emulate twos-complement behavior on ones-complement machines
02:27:31 <divVerent> or just not support them
02:29:36 <Myrl-chan> divVerent: The last one seems to be the best solution, IMO.
02:29:37 <divVerent> Int also has 2 elements with the property x + x = 0
02:29:54 <divVerent> one of which being an x with abs x < 0
02:30:11 <Myrl-chan> divVerent: 2^WORDSIZE >> 1?
02:30:17 <divVerent> exactly
02:30:41 <divVerent> Prelude> abs (-2^63 :: Int)
02:30:42 <divVerent> -9223372036854775808
02:31:14 <divVerent> so yes, Int evil, Float evil, Double evil... only Integer kinda works :)
02:31:20 <Myrl-chan> lol
02:31:33 <Myrl-chan> divVerent: Rational
02:31:34 <Myrl-chan> ?
02:31:51 <dramforever> @kind Complex
02:31:52 <lambdabot> * -> *
02:31:55 <divVerent> Rational not so evil
02:31:57 <divVerent> :P
02:31:59 <dramforever> Complex Integer maybe
02:32:04 <dramforever> not evil, just complex
02:32:17 <divVerent> Greetings to Carl Friedrich, for Complex Integer :)
02:32:22 <Myrl-chan> :t Complex
02:32:23 <lambdabot> Not in scope: data constructor ‘Complex’
02:32:26 <Myrl-chan> Hmmm
02:32:31 <Myrl-chan> @info Complex
02:32:32 <lambdabot> Complex
02:32:35 <Myrl-chan> wat
02:33:15 <divVerent> why does realPart require RealFloat?
02:33:23 <divVerent> that means Complex Integer doesn't support it
02:33:37 <dramforever> Myrl-chan: you can forget about @info
02:33:53 <divVerent> realPart and imagPart's definitions certainly don't look like they should require RealFloat
02:39:38 <liste> most of the complex number operations work only on RealFloats, though
02:40:08 <liste> and Haskell Report has " data  (RealFloat a)     => Complex a = !a :+ !a"
02:41:09 <dolio> They aren't that way anymore in the latest base.
02:43:16 <f|`-`|f> so
02:43:29 <f|`-`|f> is there a wrapper for the ziplist interpretation of Applicatives/Functors
02:44:17 <liste> > ZipList [(+1), (
02:44:18 <ion> ZipList
02:44:19 <lambdabot>  <hint>:1:17:
02:44:19 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
02:44:38 <liste> > ZipList [(+1), (*2), (-1)] <*> ZipList[1, 2, 3] --- ?
02:44:40 <lambdabot>      No instance for (Show b0)
02:44:40 <lambdabot>        arising from a use of ‘show_M872242746575681147513687’
02:44:40 <lambdabot>      The type variable ‘b0’ is ambiguous
02:44:52 <liste> > (ZipList [(+1), (*2), (-1)] <*> ZipList[1, 2, 3]) :: ZipList Int --- ?
02:44:54 <lambdabot>      No instance for (Num (Int -> Int))
02:44:54 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
02:44:54 <lambdabot>        arising from a use of syntactic negation
02:45:01 <liste> > (ZipList [(+1), (*2), (-1)] <$> ZipList[1, 2, 3]) :: ZipList Int --- ?
02:45:03 <lambdabot>      Couldn't match expected type ‘Integer -> Int’
02:45:03 <lambdabot>                  with actual type ‘ZipList (a0 -> a0)’
02:45:03 <lambdabot>      Possible cause: ‘ZipList’ is applied to too many arguments
02:45:20 <liste> I suck :D
02:46:09 <jeltsch> Hi, anyone here who can help me in finding a workaround for cabal-install HTTP hangs?
02:46:20 <f|`-`|f> liste  
02:46:24 <f|`-`|f> you are forgetting a space
02:46:33 <jeltsch> I try to install a package, but cabal-install fails to download a dependency.
02:46:46 <f|`-`|f> > ( ZipList [(+1), (*2), (-1)] ) <$> ( ZipList [1, 2, 3]) :: ZipList Int --- ?
02:46:48 <lambdabot>      Couldn't match expected type ‘Integer -> Int’
02:46:48 <lambdabot>                  with actual type ‘ZipList (a0 -> a0)’
02:46:48 <lambdabot>      Possible cause: ‘ZipList’ is applied to too many arguments
02:46:51 <liste> > (ZipList [(+1), (*2), (+3)] <$> ZipList[1, 2, 3]) :: ZipList Int --- ?
02:46:53 <lambdabot>      Couldn't match expected type ‘Integer -> Int’
02:46:53 <lambdabot>                  with actual type ‘ZipList (Integer -> Integer)’
02:46:53 <lambdabot>      Possible cause: ‘ZipList’ is applied to too many arguments
02:47:17 <liste> > (ZipList [(+1), (*2), (+3)] <*> ZipList[1, 2, 3]) :: ZipList Int --- ?
02:47:19 <lambdabot>  ZipList {getZipList = [2,4,6]}
02:47:27 <liste> whew
02:47:37 <liste> the (-1) was the problem
02:48:10 <liste> it's not a section
02:48:20 <jeltsch> The relevant output of cabal install --verbose=3 is here:
02:48:40 <jeltsch> http://lpaste.net/133765
02:50:35 <dramforever> no reason...it downloaded fine here
02:53:03 <liste> jeltsch could you wget the tarballs in advance?
02:53:09 <gfixler> haskell-platform is too out of date on Ubuntu
02:53:16 <gfixler> how should I be installing everything?
02:54:33 <dramforever> gfixler: download the binary package of ghc
02:54:38 <dramforever> and cabal-install
02:54:39 <liste> gfixler or https://halcyon.sh/
02:55:09 <dramforever> I think there's an instruction on how to install Cabal+cabal-install on the download page of cabal-install
02:55:15 <jeltsch> liste: This might be a workaround at least.
02:55:46 <jeltsch> liste: Where do I have to put the tarballs for cabal-install to find them?
02:55:52 <gfixler> dramforever: that may be all I need
02:55:58 <gfixler> liste: halcyon looks interesting
02:56:31 <dramforever> gfixler: that's the config I have now
02:56:52 <dramforever> It seems that it's going to take forever for fedora to include ghc 7.10
02:57:59 <liste> jeltsch mine are in .cabal/packages/hackage.haskell.org/<package>/<version>
02:58:13 <jeltsch> liste: Thank you. I will try this out.
02:58:20 <liste> though there seems to be an index file also, not sure how it works
02:59:50 <dcoutts> dramforever: btw, if you want to try something, see if setting your remote repo to 104.130.241.19 works. That's the upstream host, without the CDN
03:00:05 <jeltsch> liste: I suppose that this index file is just the index file from the HackageDB server, which contains information about all the available packages.
03:00:24 <dcoutts> oh sorry, that should have been to jeltsch
03:00:36 <dramforever> heh I was just about to say that
03:02:43 <jeltsch> dcoutts: This seems to do the trick. Thank you!
03:02:54 <dcoutts> jeltsch: hmm, interesting
03:03:32 <jeltsch> dcoutts: Interestingly, cabal-install was able to receive the “Moved Permanently” redirect. It failed to download the actual package then.
03:04:21 <dcoutts> jeltsch: yes, odd that the first response from the CDN was ok and the second not
03:04:31 <dcoutts> jeltsch: but then the second contained a body
03:05:41 <jeltsch> dcoutts: The body is a HTTP issue, not a DNS issue, isn’t it?
03:05:53 * hackagebot semigroupoids 5.0.0.2 - Semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-5.0.0.2 (EdwardKmett)
03:05:59 <dcoutts> jeltsch: right
03:06:15 <dcoutts> jeltsch: http cache/proxy
03:20:54 * hackagebot stylish-haskell 0.5.14.0 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.5.14.0 (JasperVanDerJeugt)
03:40:55 * hackagebot mime-mail 0.4.9 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.4.9 (MichaelSnoyman)
03:50:55 * hackagebot HMap 1.2.4 - Fast heterogeneous maps and unconstrained typeable like functionality.  http://hackage.haskell.org/package/HMap-1.2.4 (AtzeVanDerPloeg)
03:50:57 * hackagebot yst 0.5.0.3 - Builds a static website from templates and data in YAML or  CSV files.  http://hackage.haskell.org/package/yst-0.5.0.3 (JohnMacFarlane)
04:10:56 * hackagebot 3d-graphics-examples 0.0.0.1 - Examples of 3D graphics programming with OpenGL  http://hackage.haskell.org/package/3d-graphics-examples-0.0.0.1 (WolfgangJeltsch)
04:21:19 <ronh-> poi78
04:25:57 * hackagebot fraction 0.1.0.4 - Fractions  http://hackage.haskell.org/package/fraction-0.1.0.4 (WolfgangJeltsch)
04:33:36 <ClaudiusMaximus> :t floatRadix -- seems overkill, given that it's usually 2...
04:33:37 <lambdabot> RealFloat a => a -> Integer
04:36:40 <ClaudiusMaximus> suppose it makes sense, if you want Word64 digits, the radix is (maxBound::Word64) + 1...
04:37:11 <pingu_> I want to build a Free DSL that allows the user to create "variables" that will be substituted into a query in multiple places.
04:37:23 <pingu_> Has anyone done anything like that before? It doesn't seem trivial.
04:37:36 <poucet_> Does anyone know of a library that will load a graphviz file and load it into a haskell graph library (e.g. fgl)?
04:38:07 <ClaudiusMaximus> pingu_: query makes me think of SQL, i think there are a few SQL DSLs
04:40:02 <ClaudiusMaximus> poucet_: http://hackage.haskell.org/package/graphviz says "roundtrip fgl -> dot -> fgl to annotate with layout", so i presume it can do dot -> fgl too
04:40:24 <poucet_> ClaudiusMaximus: Thanks
04:40:58 * hackagebot order-maintenance 0.0.1.0 - Algorithms for the order maintenance problem with a safe  interface  http://hackage.haskell.org/package/order-maintenance-0.0.1.0 (WolfgangJeltsch)
04:45:58 * hackagebot pandoc 1.14.0.4 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.14.0.4 (JohnMacFarlane)
04:59:51 <Gurkenglas_> Can you recommend a library that I can give a sentence in a natural language and it'll parse it and return it broken up into a syntax tree?
05:03:13 <alpounet> Gurkenglas_: augur might know about one
05:13:10 <zmbmartin> I am trying to install cabal-install with 7.6.3 with nix. I am getting this error System/Random.hs:2:2: parse error on input `#'.
05:15:19 <pacak> zmbmartin: Anything interesting in that file?
05:15:26 <KaneTW> i
05:23:01 <ion> ^[
05:23:33 <ion> :wq
05:28:07 <KaneTW> ^X^C
05:54:26 <etheral> Hello? 
05:54:46 <Fuuzetsu> hello
05:56:02 * hackagebot memory 0.7 - memory and related abtraction stuff  http://hackage.haskell.org/package/memory-0.7 (VincentHanquez)
05:56:04 * hackagebot amazonka-core 0.3.5 - Core functionality and data types for Amazonka libraries.  http://hackage.haskell.org/package/amazonka-core-0.3.5 (BrendanHay)
05:56:06 * hackagebot amazonka 0.3.5 - Comprehensive Amazon Web Services SDK  http://hackage.haskell.org/package/amazonka-0.3.5 (BrendanHay)
06:01:03 * hackagebot amazonka-config 0.3.5 - Amazon Config SDK.  http://hackage.haskell.org/package/amazonka-config-0.3.5 (BrendanHay)
06:01:05 * hackagebot amazonka-sns 0.3.5 - Amazon Simple Notification Service SDK.  http://hackage.haskell.org/package/amazonka-sns-0.3.5 (BrendanHay)
06:01:07 * hackagebot amazonka-sqs 0.3.5 - Amazon Simple Queue Service SDK.  http://hackage.haskell.org/package/amazonka-sqs-0.3.5 (BrendanHay)
06:01:09 * hackagebot amazonka-glacier 0.3.5 - Amazon Glacier SDK.  http://hackage.haskell.org/package/amazonka-glacier-0.3.5 (BrendanHay)
06:01:11 * hackagebot amazonka-cloudhsm 0.3.5 - Amazon CloudHSM SDK.  http://hackage.haskell.org/package/amazonka-cloudhsm-0.3.5 (BrendanHay)
06:06:13 * hackagebot amazonka-iam 0.3.5 - Amazon Identity and Access Management SDK.  http://hackage.haskell.org/package/amazonka-iam-0.3.5 (BrendanHay)
06:06:15 * hackagebot amazonka-route53-domains 0.3.5 - Amazon Route 53 Domains SDK.  http://hackage.haskell.org/package/amazonka-route53-domains-0.3.5 (BrendanHay)
06:06:17 * hackagebot amazonka-directconnect 0.3.5 - Amazon Direct Connect SDK.  http://hackage.haskell.org/package/amazonka-directconnect-0.3.5 (BrendanHay)
06:06:19 * hackagebot amazonka-cognito-sync 0.3.5 - Amazon Cognito Sync SDK.  http://hackage.haskell.org/package/amazonka-cognito-sync-0.3.5 (BrendanHay)
06:06:21 * hackagebot amazonka-elb 0.3.5 - Amazon Elastic Load Balancing SDK.  http://hackage.haskell.org/package/amazonka-elb-0.3.5 (BrendanHay)
06:11:23 * hackagebot amazonka-cloudformation 0.3.5 - Amazon CloudFormation SDK.  http://hackage.haskell.org/package/amazonka-cloudformation-0.3.5 (BrendanHay)
06:11:25 * hackagebot amazonka-sts 0.3.5 - Amazon Security Token Service SDK.  http://hackage.haskell.org/package/amazonka-sts-0.3.5 (BrendanHay)
06:11:27 * hackagebot amazonka-kinesis 0.3.5 - Amazon Kinesis SDK.  http://hackage.haskell.org/package/amazonka-kinesis-0.3.5 (BrendanHay)
06:11:29 * hackagebot amazonka-cloudwatch 0.3.5 - Amazon CloudWatch SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-0.3.5 (BrendanHay)
06:11:31 * hackagebot amazonka-cloudtrail 0.3.5 - Amazon CloudTrail SDK.  http://hackage.haskell.org/package/amazonka-cloudtrail-0.3.5 (BrendanHay)
06:16:33 * hackagebot amazonka-elasticache 0.3.5 - Amazon ElastiCache SDK.  http://hackage.haskell.org/package/amazonka-elasticache-0.3.5 (BrendanHay)
06:16:35 * hackagebot amazonka-importexport 0.3.5 - Amazon Import/Export SDK.  http://hackage.haskell.org/package/amazonka-importexport-0.3.5 (BrendanHay)
06:16:37 * hackagebot amazonka-s3 0.3.5 - Amazon Simple Storage Service SDK.  http://hackage.haskell.org/package/amazonka-s3-0.3.5 (BrendanHay)
06:16:39 * hackagebot amazonka-swf 0.3.5 - Amazon Simple Workflow Service SDK.  http://hackage.haskell.org/package/amazonka-swf-0.3.5 (BrendanHay)
06:16:41 * hackagebot amazonka-sdb 0.3.5 - Amazon SimpleDB SDK.  http://hackage.haskell.org/package/amazonka-sdb-0.3.5 (BrendanHay)
06:17:53 <poucet_> holy
06:21:43 * hackagebot amazonka-autoscaling 0.3.5 - Amazon Auto Scaling SDK.  http://hackage.haskell.org/package/amazonka-autoscaling-0.3.5 (BrendanHay)
06:21:45 * hackagebot amazonka-codedeploy 0.3.5 - Amazon CodeDeploy SDK.  http://hackage.haskell.org/package/amazonka-codedeploy-0.3.5 (BrendanHay)
06:21:47 * hackagebot amazonka-cloudfront 0.3.5 - Amazon CloudFront SDK.  http://hackage.haskell.org/package/amazonka-cloudfront-0.3.5 (BrendanHay)
06:21:49 * hackagebot amazonka-cloudsearch-domains 0.3.5 - Amazon CloudSearch Domain SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-domains-0.3.5 (BrendanHay)
06:21:51 * hackagebot amazonka-elasticbeanstalk 0.3.5 - Amazon Elastic Beanstalk SDK.  http://hackage.haskell.org/package/amazonka-elasticbeanstalk-0.3.5 (BrendanHay)
06:22:57 <KaneTW> lotsa packages
06:23:13 <xj54y> Hello.. Having issues installing Hoogle. http://paste.debian.net/194994/ 
06:24:31 <liste> xj54y are you using GHC/cabal-install installed by OS package management and installing hoogle with cabal install?
06:25:08 <OutlawStar> question: I'm getting a deduce error (line 4) and I'm trying to figure out if what I am doing is possible. Basically I'm trying to get the compilier to infer one type from the use of another through fundeps. Can someone possibly take a quick look (its a short snippet) http://lpaste.net/7501987812208541696 
06:25:19 <xj54y> liste, `cabal install hoogle` yeah
06:26:53 * hackagebot amazonka-datapipeline 0.3.5 - Amazon Data Pipeline SDK.  http://hackage.haskell.org/package/amazonka-datapipeline-0.3.5 (BrendanHay)
06:26:55 * hackagebot amazonka-support 0.3.5 - Amazon Support SDK.  http://hackage.haskell.org/package/amazonka-support-0.3.5 (BrendanHay)
06:26:57 * hackagebot amazonka-redshift 0.3.5 - Amazon Redshift SDK.  http://hackage.haskell.org/package/amazonka-redshift-0.3.5 (BrendanHay)
06:26:59 * hackagebot amazonka-opsworks 0.3.5 - Amazon OpsWorks SDK.  http://hackage.haskell.org/package/amazonka-opsworks-0.3.5 (BrendanHay)
06:27:01 * hackagebot amazonka-emr 0.3.5 - Amazon Elastic MapReduce SDK.  http://hackage.haskell.org/package/amazonka-emr-0.3.5 (BrendanHay)
06:29:22 <liste> xj54 would cabal update && cabal install cabal-install help?
06:29:39 <xj54y> liste, I'll check it out. Give me a sec :-)
06:31:37 <srhb> xj54y: What on earth is up with those repeated characters o_O
06:32:03 * hackagebot amazonka-cognito-identity 0.3.5 - Amazon Cognito Identity SDK.  http://hackage.haskell.org/package/amazonka-cognito-identity-0.3.5 (BrendanHay)
06:32:05 * hackagebot amazonka-ssm 0.3.5 - Amazon Simple Systems Management Service SDK.  http://hackage.haskell.org/package/amazonka-ssm-0.3.5 (BrendanHay)
06:32:07 * hackagebot amazonka-ml 0.3.5 - Amazon Machine Learning SDK.  http://hackage.haskell.org/package/amazonka-ml-0.3.5 (BrendanHay)
06:32:09 * hackagebot amazonka-workspaces 0.3.5 - Amazon WorkSpaces SDK.  http://hackage.haskell.org/package/amazonka-workspaces-0.3.5 (BrendanHay)
06:32:11 * hackagebot amazonka-dynamodb 0.3.5 - Amazon DynamoDB SDK.  http://hackage.haskell.org/package/amazonka-dynamodb-0.3.5 (BrendanHay)
06:33:23 <xj54y> srhb, when I opened the link, I asked the exact same thing but.. My bewilderment lead to stop caring.. Seems it has something to do with cabal install hoogle 2& > cabal.out; Not sure what however
06:33:36 <srhb> Ah, that would explain.
06:33:37 <xnyhps> OutlawStar: Your x' is not guaranteed to be of type s.
06:33:42 * xj54y puts pen down
06:34:09 <OutlawStar> xnyhps: oh? is it because I have no constraints on the MyClient data type?
06:34:11 <srhb> xj54y: Looks like you're joining stdout and sterr. :)
06:37:13 * hackagebot amazonka-rds 0.3.5 - Amazon Relational Database Service SDK.  http://hackage.haskell.org/package/amazonka-rds-0.3.5 (BrendanHay)
06:37:15 * hackagebot amazonka-ses 0.3.5 - Amazon Simple Email Service SDK.  http://hackage.haskell.org/package/amazonka-ses-0.3.5 (BrendanHay)
06:37:17 * hackagebot amazonka-cloudwatch-logs 0.3.5 - Amazon CloudWatch Logs SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-logs-0.3.5 (BrendanHay)
06:37:19 * hackagebot amazonka-route53 0.3.5 - Amazon Route 53 SDK.  http://hackage.haskell.org/package/amazonka-route53-0.3.5 (BrendanHay)
06:37:21 * hackagebot amazonka-cloudsearch 0.3.5 - Amazon CloudSearch SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-0.3.5 (BrendanHay)
06:38:08 <xnyhps> OutlawStar: Hm, no, sorry, x' is resolved to s, but getAccount could be from any instance with the same m. If you add the reverse fun dep it should go away.
06:40:37 <OutlawStar> xnyhps: Now I get ambiguity on 'm' and I think that is because I have no type defined using 'm' which was why i was using 's->m' initially
06:42:24 * hackagebot amazonka-storagegateway 0.3.5 - Amazon Storage Gateway SDK.  http://hackage.haskell.org/package/amazonka-storagegateway-0.3.5 (BrendanHay)
06:42:25 * hackagebot amazonka-ec2 0.3.5 - Amazon Elastic Compute Cloud SDK.  http://hackage.haskell.org/package/amazonka-ec2-0.3.5 (BrendanHay)
06:42:28 * hackagebot amazonka-kms 0.3.5 - Amazon Key Management Service SDK.  http://hackage.haskell.org/package/amazonka-kms-0.3.5 (BrendanHay)
06:42:30 * hackagebot amazonka-elastictranscoder 0.3.5 - Amazon Elastic Transcoder SDK.  http://hackage.haskell.org/package/amazonka-elastictranscoder-0.3.5 (BrendanHay)
06:42:32 * hackagebot amazonka-lambda 0.3.5 - Amazon Lambda SDK.  http://hackage.haskell.org/package/amazonka-lambda-0.3.5 (BrendanHay)
06:43:29 <Fuuzetsu> So is there a reason why cabal freeze is giving me dependencies that don't work together due to constraints? i.e. it seems to just spit out the latest available packages whereas ‘cabal install --enable-tests --enable-benchmarks --dependencies-only --dry-run’ inside a clean sandbox gives dependency versions that can honour constraints. How do I get cabal freeze to give me the right versions without having to install everything just to
06:43:29 <Fuuzetsu> run freeze after? 
06:43:35 <Fuuzetsu> (cross-posted from #hackage)
06:44:32 <xj54y> liste, Meh, more general errors similar to "cabal-install-1.22.4.0 depends on directory-1.2.2.1 which failed to install"; Are there any more concrete logs I can look at?
06:45:59 <Fuuzetsu> ignore my question, seems to have magically fixed itself…
06:47:34 * hackagebot amazonka-ecs 0.3.5 - Amazon EC2 Container Service SDK.  http://hackage.haskell.org/package/amazonka-ecs-0.3.5 (BrendanHay)
06:47:36 * hackagebot elm-init 0.1.2.1 - Set up basic structure for an elm project  http://hackage.haskell.org/package/elm-init-0.1.2.1 (justus)
06:47:38 * hackagebot securemem 0.1.9 - abstraction to an auto scrubbing and const time eq, memory chunk.  http://hackage.haskell.org/package/securemem-0.1.9 (VincentHanquez)
06:51:06 * hackagebot codec 0.1 - First-class record construction and bidirectional serialization  http://hackage.haskell.org/package/codec-0.1 (PatrickChilton)
06:55:01 <xj54y> liste, yeah, no go.. :< http://paste.debian.net/195073/ 
07:07:55 <TimoMeijer> What is the recommended/easiest way to update more than one data field using lenses?
07:09:24 <Gurkenglas_> Can you recommend a haskell library that'll turn a natural language text into its syntax tree?
07:10:54 <Feuerbach> Gurkenglas_: take a look at grammatical framework
07:13:34 <bdesham> I have a question about the directory structure of a Haskell project that produces an executable
07:13:56 <bdesham> Right now I have src/MyApp.hs which contains "module MyApp where", and then src/Main.hs which contains all of the actual code
07:14:20 <bdesham> Is that the recommended approach? I don't remember why I organized the files like that but it seems weird
07:14:56 <Gurkenglas_> TimoMeijer, what do they have in common? The default case for ((a -> f b) -> (s -> f t)) -> ((c -> g t) -> (s -> g t)) -> ((a -> f b) -> (c -> g d) -> (s -> f (g t))) is pretty simple to implement.
07:15:30 <tdammers> bdesham: is there no code at all in MyApp.hs? Just the module header?
07:15:32 <Gurkenglas_> *(c -> g d) in the second argument
07:16:10 <bdesham> tdammers: correct, it's just the module header and nothing else
07:16:48 <tdammers> bdesham: then I'd remove that file entirely
07:16:53 <TimoMeijer> Gurkenglas_: Looking for a way to update more than one field in a datatype, without updating the rest; a way to combine lenses, or to chain them, so to speak
07:18:51 <Gurkenglas_> TimoMeijer, why not update one, then the other? Afaik, laziness should keep the entire datatype from being copied twice. Unless there is some more usable information about your updates that might accelerate the process further if correctly used...?
07:19:18 <bdesham> tdammers: OK, thanks
07:19:56 <Gurkenglas_> Feuerback, do you know what part of that library does what I said?
07:20:00 <Gurkenglas_> *Feuerbach
07:20:31 <ClaudiusMaximus> seems cabal sandbox and ghci don't get along if you don't put your module heirarchy in an unrelated subdir  (i installed my library in a sandbox, then cabal exec -- ghci ;   :m + Some.Module.In.My.Library   failed with an error about non-loaded package or something)
07:20:32 <TimoMeijer> Gurkenglas_: That should be sufficient, but is there a syntactically nice way to chain the operations that way?
07:21:34 <Gurkenglas_> Composition of the update functions. For more specific answers I'd want your code pasted on lpaste
07:22:10 <thebnq> > (1,2) & _1 .~ 3 & _2 .~ 4
07:22:12 <lambdabot>  (3,4)
07:22:29 <thebnq> TimoMeijer: ^ is this what you mean
07:26:13 <TimoMeijer> thebnq, Gurkenglas_ That was exactly what I was looking for! Thanks!
07:27:03 <hexagoxel> ClaudiusMaximus: `cabal exec` just forwards the information about the package-db, nothing else
07:27:15 <hexagoxel> and what is an `unrelated subdir`?
07:27:28 <ClaudiusMaximus> like 'src' instead  of '.'
07:27:53 <ClaudiusMaximus> hexagoxel: i'll try to reproduce, i since workarounded
07:28:47 <hexagoxel> ClaudiusMaximus: and in which case does it work as expected?
07:30:52 <hexagoxel> i would expect it to fail if hs-source-dirs = src
07:36:32 <ClaudiusMaximus> hexagoxel: http://lpaste.net/133775
07:36:49 <dcoutts> ClaudiusMaximus: this is neither a ghci nor cabal bug as such
07:37:28 <ClaudiusMaximus> dcoutts: ok, then whose bug is it?
07:38:55 <dcoutts> ClaudiusMaximus: you can just run cabal repl you know
07:39:12 <dcoutts> ClaudiusMaximus: or you can load the module as a source file
07:39:23 <dcoutts> ClaudiusMaximus: like: :l CabalGhciBug.hs
07:39:56 <dcoutts> ClaudiusMaximus: you're asking GHCi to load, as a module from a package, that module, but ghci is pointing out that the local file masks the module from the package
07:41:09 * hackagebot xcffib 0.2.5 - A cffi-based python binding for X  http://hackage.haskell.org/package/xcffib-0.2.5 (TychoAndersen)
07:41:58 <ClaudiusMaximus> dcoutts: ok, that long explanation makes sense indeed;  but your workarounds mean the (possibly modified) code is interpreted instead of using the compiled installed version
07:43:00 <dcoutts> ClaudiusMaximus: yes indeed it is
07:43:17 <dcoutts> ClaudiusMaximus: but you can just use :set -fobject-code
07:44:47 <ClaudiusMaximus> dcoutts: oh cool, didn't know that one :)  (but it also litters .hi and .o ...)
07:44:58 <dcoutts> no it doesn't, not if you use cabal repl
07:45:01 <dcoutts> :-)
07:45:03 <ClaudiusMaximus> oh!
07:45:53 <ClaudiusMaximus> dcoutts: how do pass -fobject-code to cabal repl?
07:46:09 * hackagebot friday 0.2.2.0 - A functional image processing library for Haskell.  http://hackage.haskell.org/package/friday-0.2.2.0 (RaphaelJavaux)
07:46:11 * hackagebot xcffib 0.3.1 - A cffi-based python binding for X  http://hackage.haskell.org/package/xcffib-0.3.1 (TychoAndersen)
07:46:27 <dcoutts> ClaudiusMaximus: I'd just use :set -fobject-code, but you can also use cabal repl --ghc-options=...
07:47:06 <ClaudiusMaximus> dcoutts: :set -fobject-code doesn't seem to do anything because the module is loaded already (in interpreted mode)
07:47:18 <dcoutts> ClaudiusMaximus: use :load   again
07:47:20 <dcoutts> after
07:51:12 <ClaudiusMaximus> dcoutts: ok, seems a bit awkward in all cases (got message about hidden package in one try, and other cases i'm not sure if it's compiled or interpreted) -  hs-source-dirs: src  seems easiest to just set and forget...
07:51:27 <ClaudiusMaximus> dcoutts: thanks
07:52:16 <dcoutts> ClaudiusMaximus: the problem with using it in a pre-compiled lib is you can never use bytecode, and so can't get "inside" a module in your lib
07:52:36 <dcoutts> cabal repl [--ghc-options=-fobject-code]
07:55:21 <ClaudiusMaximus> dcoutts: right, that's actually part of the things i want to check when when using   cabal exec -- ghci src/Blah.hs  vs cabal exec -- ghci ; :m + Blah    (ie, did i forget to expose something important, did i expose something that shouldn't have been...)
07:55:36 <dcoutts> ok
07:55:45 <dcoutts> well, now you know how to do both :-)
07:59:27 <augur> Gurkenglas: i dont know of any parsing libraries for haskell, unfortunately
07:59:59 <augur> i think probably python has the most advanced NLP libraries out there in the form of NLTK
08:00:05 <dcoutts> ClaudiusMaximus: so yeah, the confusion is that ghci has this behaviour that local files always mask modules of the same name from packages. And also, the notion of loaded is this: modules from packages are always loaded, while local source files have to be explicitly loaded with :l or giving them on the ghci command line. And then :m is for switching the current context between loaded modules.
08:00:30 <rom1504> java has the stanford corenlp
08:01:04 <augur> rom1504: ahh yes, that too
08:01:06 <dcoutts> ClaudiusMaximus: so, that leads to the case where you have Foo from a package, and ./Foo.hs and you say :m Foo, and ghci says "I can see that module Foo ought to come from a local file, but that file has not been loaded"
08:01:08 <rom1504> maybe look at https://wiki.haskell.org/Applications_and_libraries/Linguistics though
08:01:30 <dcoutts> ClaudiusMaximus: because of ghci's loaded (:l) vs current modules (:m) thing
08:02:16 <ClaudiusMaximus> dcoutts: right, this all makes sense now that you explain it - but the error messages could be a lot clearer
08:03:32 <augur> rom1504, Gurkenglas: it all depends on whether you want to play around with things, or do large scale processing, or what
08:03:59 <augur> there's lots of haskell stuff to just play around with, probably, but not so much in terms of scale
08:04:06 <augur> there's no Haskell equivalent of the Stanford Parser
08:04:37 <wei2912> @src gcd
08:04:38 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
08:04:38 <lambdabot> gcd x y = gcd' (abs x) (abs y)
08:04:38 <lambdabot>    where gcd' a 0 = a
08:04:38 <lambdabot>          gcd' a b = gcd' b (a `rem` b)
08:04:42 <augur> on the other hand, the Stanford Parser probably has an exportable ruleset, etc. that you can use for a re-implementation in Haskell, so..
08:05:44 <rom1504> you could probably build some kind of haskell wrapper for the stanford parser too
08:06:32 <rom1504> (the stanford corenlp already has wrapper for several languages http://nlp.stanford.edu/software/corenlp.shtml#Extensions)
08:11:10 * hackagebot geom2d 0.1.0.1 - package for geometry in euklidean 2d space  http://hackage.haskell.org/package/geom2d-0.1.0.1 (seppeljordan)
08:16:57 <[[derek]]> Hey, could someone tell me why my solution to project euler problem 17 doesn't give the correct answer? It works for all the examples, just not the final question. Cheers. http://pastebin.com/jjXhQX2D
08:17:05 <[[derek]]> Here is the problem https://projecteuler.net/problem=17
08:19:54 <shiona> [[derek]]: 200 is "two hundred and"
08:20:18 <shiona> I think
08:20:53 <bdesham> [[derek]]: what is `intToWords 1100`? it looks to me like it might be "eleven hundred", where it should be "one thousand and one hundred"
08:21:45 <[[derek]]> bdesham: Thanks, the problem only needs numbers from 1-1000 so numbers over 1000 are undefined
08:21:55 <[[derek]]> shiona: that would be it, thanks
08:22:19 <ClaudiusMaximus> bdesham: eleven hundred is valid english, just uncommon (except for naming years), and the question only goes to 1000
08:23:50 <bdesham> [[derek]]: Oh, I missed that
08:24:40 <bdesham> ClaudiusMaximus: yeah, I'd say that form is much more common in everyday speech (at least in the US), but not considered "officially correct" (whatever that means)
08:26:05 <[[derek]]> shiona: Yup, thanks that did the trick.
08:26:15 <shiona> [[derek]]: np
08:28:29 <bdesham> I'm trying to create a regex matching operator like =~ that will use predefined compOpts and execOpts
08:28:38 <bdesham> My code is at http://lpaste.net/133779... can anyone tell me what I'm doing wrong?
08:32:06 <ion> bdesham: Try commenting out the type signature and see what GHC thinks its type is.
08:32:56 <[[derek]]> shiona, etc my final solution if anyone is interested https://github.com/TheDerek/euler/blob/master/problem-017.hs
08:33:55 <[[derek]]> I think I could have slimmed it down somewhat, but I'm happy with it for my current level of haskell knoweldge
08:34:20 <Welkin> [[derek]]: you do know the historical significance of the "final solution", correct?
08:34:59 <doomlord> i think people like to use the term for shock value
08:35:07 <doomlord> i certainly do drop it in wherever I can
08:35:29 <ion> The guys who came up with Final Solution do know the historical meaning of the swastika and the word aryan, right?
08:35:48 <ion> (/me shuts up)
08:35:56 <Welkin> ClaudiusMaximus: elven hundred, twelve hundred, etc. are very common in english when talking about anything
08:35:59 <Welkin> money included
08:36:03 <doomlord> we want to reclaim the term 'final solution' , the nazis stole it from us
08:36:23 <[[derek]]> Welkin: Ja
08:36:27 <Welkin> "twenty eight hundred" instead of "two thousand eight hundred"
08:36:36 <Welkin> it's easier/faster to say
08:37:00 <Welkin> in formal situations, the full version is used
08:38:50 <[[derek]]> I'm just wondering how you would do it using pen and paper as I've heard claimed possible.
08:39:08 <Welkin> derekv: I have solved many project euler problems in paper
08:39:21 <Welkin> I couldn't easily solve them in code without a brute force approach
08:39:37 <ion> derek: Well, for one you could just write the words and count the letters. :-P
08:39:43 <[[derek]]> Brute force is my default project euler solution
08:39:59 <joneshf-laptop> [[derek]], i think you only need to count to 30
08:40:06 <bdesham> ion: I let GHC infer the type and now I get "Non type-variable argument"
08:40:15 <bdesham> I updated the paste with the full message
08:40:16 <joneshf-laptop> [[derek]], then you can use multiplication and addition to figure the rest
08:41:19 <ion> bdesham: Try enabling FlexibleContexts
08:41:21 <[[derek]]> I've been looking at other solutions
08:42:09 <[[derek]]> This one made me feel exceptionally stupid http://pastebin.com/amT4mcpK
08:42:52 <ReinH> pretty sure pastebin is wrong about that being java
08:43:14 <[[derek]]> Yeah, its in J
08:43:15 <ion> Is that whatever the ASCII variant of APL was named?
08:43:24 <ReinH> yes
08:44:09 <joneshf-laptop> [[derek]], why did that one make ou feel stupid?
08:44:13 <bdesham> ion: It works with FlexibleContexts; I was assuming that what I was doing wasn't complicated enough to warrant language options like that...
08:44:40 <ReinH> joneshf-laptop: that's what APL and J are for.
08:45:07 <[[derek]]> joneshf-laptop: coudln't really understand it
08:45:13 <joneshf-laptop> ReinH, :)
08:45:15 <ion> bdesham: If you add the type signature GHC infers to the code and remove FlexibleContexts, does it work?
08:45:56 <merijn> ion: Not if GHC infers a FlexibleContexts signature
08:46:02 <joneshf-laptop> [[derek]], do you have experience with an apl language?
08:46:07 <ion> alright
08:46:08 <joneshf-laptop> an apl language...
08:46:34 <[[derek]]> Noope.
08:46:50 <joneshf-laptop> [[derek]], don't sweat it then.
08:47:03 <bdesham> ion: nope
08:47:05 <merijn> bdesham: The report is very conservative in what sort of contexts it allows and since GHC (mostly) conforms to the report by default that means you need an explicit extension for Contexts fairly quickly
08:47:25 <[[derek]]> No idea on how to go about solving this https://projecteuler.net/problem=11
08:47:31 <bdesham> merijn: so I'm not necessarily trying to do something outlandish here
08:48:00 <mauke[> [[derek]]: brute force
08:50:19 <ReinH> yep
08:50:41 <ReinH> [[derek]]: what sort of structure would be good to represent the grid?
08:51:13 * hackagebot geniplate-mirror 0.7 - Use Template Haskell to generate Uniplate-like functions.  http://hackage.haskell.org/package/geniplate-mirror-0.7 (DanRosen)
08:51:14 <merijn> bdesham: I haven't seen the code, but FlexibleContexts doesn't require anything outlandish
08:51:25 <[[derek]]> I guess a 2D array, I would do it in javascript to avoid having to copy that huge table out
08:52:47 <joneshf-laptop> [[derek]], how does js help you there?
08:53:23 <[[derek]]> I could just program it directly in the chrome developers console
08:53:34 <kadoban> His computer lacks copy and paste perhaps.
08:54:01 <mauke[> map (map read . words) . lines
08:54:12 <joneshf-laptop> ^
08:55:01 <joneshf-laptop> 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
08:55:01 <joneshf-laptop> 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
08:55:01 <joneshf-laptop> 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
08:55:01 <joneshf-laptop> 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
08:55:01 <joneshf-laptop> 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
08:55:03 <joneshf-laptop> 32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
08:55:05 <joneshf-laptop> 67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21
08:55:07 <joneshf-laptop> 24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
08:55:09 <joneshf-laptop> 21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95
08:55:11 <joneshf-laptop> 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
08:55:12 <kadoban> … why would you do this, haha.
08:55:15 <joneshf-laptop> 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
08:55:17 <joneshf-laptop> 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
08:55:19 <joneshf-laptop> 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
08:55:21 <joneshf-laptop> 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
08:55:23 <joneshf-laptop> 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
08:55:26 <Clint> ...
08:55:28 <joneshf-laptop> 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
08:55:31 <merijn> Probably pasted something huge and getting ratelimited by freenode
08:56:13 * hackagebot servant-ede 0.4.0.1 - Combinators for rendering EDE templates in servant web applications  http://hackage.haskell.org/package/servant-ede-0.4.0.1 (AlpMestanogullari)
08:57:06 <geekosaur> that's not rate limiting
08:57:16 <ion> joneshf was simply demonstrating the copy and paste functionality for everyone’s benefit.
08:57:16 <c_wraith> could be rate limiting on his client side
08:57:52 <ion> Have the channel ops requested Sigyn to be here?
08:58:04 <geekosaur> that's the new idoru, from the looks pof it
08:58:19 <geekosaur> I had wondered how long before enough spammers had figured out to avoid idoru that they'd need a new name
09:12:15 <breadmonster> Hey everyone.
09:12:26 <breadmonster> How and what does MonadFix do?
09:12:40 <davean> breadmonster: do you know what a fixed point is?
09:12:52 <breadmonster> davean, sure.
09:13:31 <c_wraith> :t mfix
09:13:33 <davean> It (Tries) to find the fixed point for a function producing a monadic value.
09:13:33 <lambdabot> MonadFix m => (a -> m a) -> m a
09:13:47 <davean> Not all monads allow this, thats a class for monads that do
09:13:57 <breadmonster> davean, umm, IO?
09:14:04 <c_wraith> IO cheats.
09:14:11 <breadmonster> > mfix (\x -> [x])
09:14:15 <lambdabot>  mueval-core: Time limit exceeded
09:14:15 <davean> breadmonster: Consider laziness
09:14:21 <c_wraith> It has a MonadFix instance, but it's in terms of unsafePerformIO
09:14:32 <davean> breadmonster: the "a" passed in is a reference to the value thats not yet defined.
09:14:36 <breadmonster> c_wraith, That's kinda interesting.
09:14:45 <breadmonster> :t fix
09:14:46 <lambdabot> (a -> a) -> a
09:14:52 <davean> you CAN "crash" by being strict
09:15:13 <davean> You have to watch your laziness to use mfix
09:15:24 <ion> > map (take 10) (mfix (\v -> ["foo" ++ v, "bar" ++ v, "baz" ++ v]))
09:15:27 <breadmonster> Hmm.
09:15:28 <lambdabot>  ["foofoofoof","barbarbarb","bazbazbazb"]
09:16:06 <johnw> if you think of ~> as a Kleisli arrow, then mfix :: (a ~> a) ~> a
09:16:43 <breadmonster> johnw, over my head...
09:16:49 <c_wraith> MonadFix is rarely used directly.
09:17:00 <c_wraith> Usually you use it with mdo or do rec
09:17:11 <c_wraith> Which generates necessary calls to mfix
09:17:15 <johnw> yeah, the reverse state monad uses it nicely
09:17:23 <johnw> in order to make use of rec
09:19:10 <johnw> in recursive do notation, you can have multiple assignments of "x <- y", and they can be interdependent in any order.  The fixed point of this "equation" exists if there are no cycles in the "dependency graph" that arises from the assignments.
09:19:32 <davean> c_wraith: I don't know ... I tend to call mfix directly.
09:19:42 <johnw> if you have a dependency cycle with "let" that's OK because of laziness, but it will say <<loop>> at runtime
09:20:28 <johnw> (if there is not enough laziness, that is)
09:28:32 <athan> johnw: Can't you use a bang-pattern to make it acyclic?
09:30:53 <johnw> athan: you mean, to force the check at compile-time?
09:38:00 <athan> johnw: Yeah, chrisdone showed me it (I think :s) - `let !foo = foo' {someField = someField foo' + 1}` - that way, if you forget the prime, you're not looking everywhere for the bug :)
09:38:10 <athan> (at least I think this is correct)
09:38:32 <johnw> the prime names another variable...
09:46:13 <dale_> if I have an n-ry function: (a -> b -> c -> ... -> z), and I want to bind the ith argument to a certain value such that the result is an (n-1)-ary function. Is there an obvious way to do that besides defining an ugly lambda that does it explicitly?
09:46:36 <athan> @hackage poly-arity
09:46:36 <lambdabot> http://hackage.haskell.org/package/poly-arity
09:46:41 <athan> ^ dale_ :)
09:46:51 <dale_> thanks athan
09:47:23 <athan> dale_: Np. You may have to use the HList datatype defined there, to do head-oriented application
09:48:06 <mauke[> define a beautiful lambda that does it explicitly
09:48:07 <athan> actually! HList 4 is out, so I might be able to take out that data type and depend on the package! :D
09:48:19 <dale_> oh wait, this is for functions with unspecified arity? I know the arity in my case. It'll be 3 or so, I just wanted to know a general solution which is why I said n. Is this still the right package?
09:48:34 <athan> dale_: Well, that's difficult.
09:48:43 <athan> If you know the arity at compile time, you should just use a lambda
09:48:49 <athan> (and if you know the types envolved, too)
09:48:58 <athan> if you don't, I think you should use poly-arity
09:49:18 <bitemyapp> athan: what's new in 0.4?
09:49:26 <athan> bitemyapp: 7.10 support :p
09:49:50 <dale_> thanks for your help all!
09:50:12 <athan> no prob :)
09:56:18 * hackagebot poly-arity 0.0.4.1 - Tools for working with functions of undetermined arity  http://hackage.haskell.org/package/poly-arity-0.0.4.1 (athanclark)
09:58:40 <athan> http://i.imgur.com/G2cyuZU.png
10:00:53 <zcourts> How would you define type variables and type operators for Hindly/Milner (I’m reading http://smallshire.org.uk/sufficientlysmall/2010/04/11/a-hindley-milner-type-inference-implementation-in-python/ FYI)
10:01:18 * hackagebot language-c-quote 0.10.2.2 - C/CUDA/OpenCL/Objective-C quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.10.2.2 (GeoffreyMainland)
10:01:29 <ReinH> athan: about what?
10:03:10 <athan> ReinH: The stuff behind nested-routes: pred-trie & poly-arity combined
10:03:27 <athan> I started one for pred-trie, but I don't think it's enough to be interesting - just basic existential types
10:04:24 <athan> zcourts: Type operators? Probably with system Fw
10:04:30 <athan> hmm
10:04:36 <athan> that's actually a really good question
10:04:45 <athan> because I think HM neglects higher-kinded types
10:05:04 <athan> You could probably make a separate system for types, based on HM, too :D
10:06:03 <athan> ReinH: In nested-routes, I have pred-trie building up functions of varying arity, then poly-arity building up the expectations for the n-ary function arguments
10:06:12 <ReinH> huh
10:06:18 * hackagebot ses-html 0.2.1.2 - Send HTML formatted emails using Amazon's SES REST API with blaze  http://hackage.haskell.org/package/ses-html-0.2.1.2 (DavidJohnson)
10:06:30 <athan> idk, i think it's an elegant data structure
10:07:11 <athan> zcourts: Where type operators are HM-polymorphic in their kind
10:07:20 <breadmonster> Is there a way I can engage the type inference engine without coding too much?
10:07:31 <athan> breadmonster: engage?
10:07:46 <athan> breadmonster: How do you mean?
10:07:48 <ReinH> athan: :)
10:07:54 <breadmonster> athan, You know how you can use :t to find out the types of functions?
10:07:54 <JanBessai> hi. is there a way to find parts of strings according to unicode categories (http://www.unicode.org/Public/5.0.0/ucd/UCD.html#General_Category_Values)? I'd like to ensure user names don't include html (css, javascript, ...) by limiting them to Letters and Punctuation
10:07:54 <ReinH> athan: write some blog posts instead
10:08:33 <athan> breadmonster: Ahh okay, well type inference happens at compile time, you need to remember that
10:08:35 <breadmonster> athan: I'd like to basically do something like `k :: a -> b; :t (.) k`
10:08:45 <ReinH> JanBessai: why not just blacklist < and >?
10:09:01 <athan> Good idea ReinH :)
10:09:03 <ReinH> and why would it be a problem anyway, you should be escaping any user data
10:09:12 <breadmonster> So that should spit out `(.) k -> (b -> c) -> a -> c`
10:09:13 <ReinH> so the < would become &lt; anyway
10:09:21 <breadmonster> So that should spit out `(.) k :: (b -> c) -> a -> c`
10:09:25 <ReinH> athan: I'd read them :)
10:09:28 <breadmonster> athan: ideas?
10:09:33 <athan> breadmonster: That's basically the way to do it haha
10:09:38 <athan> type inference is just a constraint solver
10:09:40 <JanBessai> ReinH: the application will enter the names into an ldap database used by other software
10:09:44 <ReinH> :t (.) (undefined :: a -> b)
10:09:47 <lambdabot> (a -> a1) -> a -> c
10:09:52 <breadmonster> athan, Yeah, except the thing is in GHCi I'll have to declare k.
10:09:55 <ReinH> breadmonster: undefined inhabits every type
10:09:57 <breadmonster> I can't just put the constraint yeah?
10:09:58 <athan> the more stuff you populate, (the more likely) something will coerce
10:10:07 <breadmonster> ReinH, Oh yeah point taken.
10:10:09 <athan> breadmonster: Basically :\
10:10:11 <ReinH> JanBessai: gotcha
10:10:11 <athan> Well
10:10:13 <athan> actually derp
10:10:14 <athan> do this
10:10:23 <athan> breadmonster: `:set -XGADTs`
10:10:31 <breadmonster> athan, Okay and?
10:10:41 <athan> breadmonster: Use `(~)`
10:10:43 <ReinH> breadmonster: or just do my thing ;)
10:10:48 <athan> to force equivalence
10:11:03 <breadmonster> athan: is there an example somewhere?
10:11:08 <athan> sec
10:11:14 <ReinH> :t let k = undefined :: a -> b in (.) k
10:11:17 <lambdabot> (a -> a1) -> a -> c
10:11:18 <ReinH> easy
10:12:36 <athan> :t const :: (a ~ (q -> y)) => a -> b -> a -- breadmonster
10:12:39 <lambdabot> (q -> y) -> b -> q -> y
10:13:09 <breadmonster> Eh?
10:13:30 <gremble> What is ~?
10:13:31 <breadmonster> ReinH athan: (undefined :: r -> s) . (undefined :: (a -> r) -> r) :: (a -> r) -> c
10:13:35 <breadmonster> How?
10:13:39 <breadmonster> Where did the c come from?
10:14:08 <breadmonster> I'm trying to implement the Cont monad, hence all the question about type lining up.
10:14:38 <athan> gremble: type equivalence
10:14:41 <athan> :k (~)
10:14:42 <lambdabot> k -> k -> Constraint
10:14:47 <gremble> Ah alright
10:14:51 <JanBessai> ah this seems nice: http://hackage.haskell.org/package/unicode-properties-3.2.0.0/docs/Data-Char-Properties-GeneralCategory.html
10:15:01 <athan> breadmonster: fiddle with it :)
10:16:03 <athan> breadmonster: Actually, in this instance, I think there isn't enough term-level information for types to unify
10:16:12 <athan> therefore it takes a const-like approach:
10:16:16 <breadmonster> Interesting.
10:16:19 <athan> :t \_ a -> a
10:16:20 <lambdabot> r -> r1 -> r1
10:16:32 <ReinH> breadmonster: I think it's just picking a fresh name
10:16:35 <breadmonster> My Functor instance for Cont doesn't seem to work for some reason.
10:17:02 <zcourts> athan:  late resp. thanks for the reply. Makes sense. 
10:17:06 <breadmonster> > newtype Cont r a = Cont { runCont :: (a -> r) -> r }
10:17:07 <lambdabot>  <hint>:1:1: parse error on input ‘newtype’
10:17:12 <breadmonster> ?
10:17:15 <ReinH> breadmonster: well, first, what is Cont?
10:17:26 <breadmonster> ReinH: A data type representing a continuation?
10:17:31 <ReinH> breadmonster: Ok, you have it thhere.
10:17:42 <ReinH> Now, what type variable does fmap map over?
10:17:45 <ReinH> r or a?
10:17:52 <breadmonster> The a right?
10:17:56 <ReinH> Yes.
10:18:06 <breadmonster> ReinH, Okay
10:18:10 <breadmonster> So if it's that easy...
10:18:11 <ReinH> So why are you composing with a function with domain r?
10:18:41 <breadmonster> fmap f (Cont x) = Cont $ f . x
10:18:48 <breadmonster> Why is that invalid?
10:18:54 <ReinH> what would its type be?
10:19:06 <breadmonster> Let me work it out. 
10:19:29 <ReinH> And what does the type of fmap need to be (ignoring the Cont wrapper)?
10:19:35 <breadmonster> x :: (a -> r) -> r, f :: r -> s 
10:19:42 <ReinH> again
10:19:46 <ReinH> why are you trying to map the r?
10:19:51 <ReinH> f :: a -> b
10:19:53 <breadmonster> oh yeah, you're right!
10:20:08 <breadmonster> That was stupid.
10:20:22 <athan> zcourts: good luck :)
10:20:34 <zcourts> thanks
10:20:49 <ReinH> ((a -> r) -> r) -> (a -> b) -> (b -> r) -> r
10:20:49 <breadmonster> fmap f (Cont x) = Cont $ x . f
10:20:54 <ReinH> is what you need
10:21:13 <ReinH> :t \f x -> x . f
10:21:15 <lambdabot> (a -> b) -> (b -> c) -> a -> c
10:21:24 <ReinH> Does that unify?
10:21:30 <breadmonster> No, you're right.
10:22:00 <breadmonster> Hmm, gimme a minute?
10:22:05 <breadmonster> I want to solve this myself.
10:23:01 <ReinH> ok
10:23:59 <ReinH> You do have the right idea about pre-composing, since a is in contravariant position in (a -> r)
10:24:20 <ReinH> but you haven't managed to get at the (a -> r) inside the (a -> r) -> r
10:29:07 <breadmonster> Yeah, that's what I'm thinking.
10:29:21 <breadmonster> ReinH, I can't seem to extract the a from the function composition.
10:29:37 <breadmonster> Because on both sides, a is the domain, not the codomain.
10:30:11 <breadmonster> Is this mathematically possible?
10:30:31 <ReinH> Say you have an (a -> r) and a (b -> a), how can you get a b -> r?
10:30:52 <breadmonster> :t (.)
10:30:54 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:31:15 <breadmonster> :t flip (.)
10:31:16 <lambdabot> (a -> b) -> (b -> c) -> a -> c
10:31:32 <breadmonster> ReinH, ^
10:31:40 <ReinH> Right, that's contramap for functions
10:31:51 <breadmonster> Okay, umm, what's contramap?
10:32:02 <breadmonster> :t contramap
10:32:04 <ReinH> what you do when the thing you're mapping is in contravariant position
10:32:04 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
10:32:33 <breadmonster> contramap (+1) [1,2,3]
10:32:36 <breadmonster> > contramap (+1) [1,2,3]
10:32:38 <lambdabot>      Could not deduce (Contravariant [])
10:32:38 <lambdabot>        arising from a use of ‘contramap’
10:32:38 <lambdabot>      from the context (Num b)
10:32:51 <breadmonster> ...how on earth?
10:35:42 <athan> breadmonster: contramap is not post-processing, it's pre-processing
10:35:55 <athan> er actually
10:36:11 <arkeet> > contramap (+1) show 0
10:36:12 <lambdabot>      No instance for (Contravariant ((->) a0))
10:36:13 <lambdabot>        arising from a use of ‘contramap’
10:36:13 <lambdabot>      In the expression: contramap (+ 1) show 0    No instance for (Num String...
10:36:13 <athan> it's... reverse-processing
10:36:15 <arkeet> oh.
10:36:44 <arkeet> > getOp (contramap (+1) (Op show)) 0
10:36:45 <lambdabot>  Not in scope: ‘getOp’    Not in scope: data constructor ‘Op’
10:36:46 <lambdabot>      Perhaps you meant one of these:
10:36:46 <lambdabot>        variable ‘ap’ (imported from Control.Monad.Writer),
10:36:52 <arkeet> :-(
10:37:06 <breadmonster> How much category theory do you guys even know? D:
10:37:22 <breadmonster> edwardk: is this another one of your packages?
10:37:55 <Welkin> breadmonster: https://github.com/ekmett
10:37:58 <Welkin> he has hundreds
10:38:54 <breadmonster> Welkin: He's very, very humble for the most prolific Haskell author I've seen, every time I ask him about some package it's always "naww, it's nothing, it just evolved like that."
10:38:58 <breadmonster> Really nice guy (:
10:39:23 <breadmonster> Except omg lens stole all the cool operators.
10:39:34 <Welkin> breadmonster: you don't have to use the operators
10:39:39 <Welkin> there are named versions for all of them
10:39:52 <breadmonster> Welkin: aren't they exported by default?
10:40:05 <Welkin> I don't know
10:40:12 <exio4> there's a .Combinators module
10:40:17 <exio4> which is lens minus the operators
10:40:22 <breadmonster> ReinH: okay, how exactly do you do this? I'm trying to figure out how to get the types to line up.
10:40:43 <Ygrarr> Hello! Can I ask you one question ? I have a following function which tries to compute a list of random numbers, buuut... it doesn't work. I know there's randomRs, but I wanted to write my own function. Here's the function + ghci toying with it
10:40:44 <Ygrarr> http://lpaste.net/2835522771570655232
10:41:21 * hackagebot hlibsass 0.1.2.1 - Low-level bindings to libsass  http://hackage.haskell.org/package/hlibsass-0.1.2.1 (jakubfijalkowski)
10:41:32 <ion> Ygrarr: (rand, g) = randomR r g
10:41:45 <ReinH> breadmonster: Ok, let's walk through it
10:41:54 <breadmonster> ReinH, sure.
10:41:56 <ReinH> The type of fmap specialized to Cont is:
10:42:12 <ReinH> (a -> b) -> ((a -> r) -> r) -> (b -> r) -> r
10:42:22 <ReinH> (ignoring Cont wrapper)
10:42:22 <ion> Ygrarr: Enable -Wall (in ghci, :set -Wall -fno-warn-type-defaults is convenient), it will warn you about the bug.
10:42:36 <breadmonster> ReinH: Sure, okay.
10:42:42 <ReinH> so we start with fmap ab (Cont arr) br = ...
10:42:49 <breadmonster> Eh wait what?
10:42:54 <breadmonster> Three arguments?
10:43:01 <ReinH> Look at the type signature
10:43:09 <ReinH> (a -> b) is one, ((a -> r) -> r) is another, (b -> r) is a third
10:43:17 <Ygrarr> ion: oh... thanks! It's the most common error I make in Haskell
10:43:32 <ReinH> We could also say fmap ab (Cont arr) = \br -> ...
10:43:44 <breadmonster> ReinH: Isn't that the usual way of writing (a -> b) -> ((a -> r) -> r) -> ((b -> r) -> r)?
10:44:05 <ReinH> The last parens around (b -> r) -> r are optional
10:44:13 <breadmonster> I know, but conceptually.
10:44:21 <ReinH> Sure
10:44:22 <breadmonster> Okay, the explicit lambda is clearer in my head.
10:44:23 <breadmonster> Do go on?
10:44:23 <johnw> if you do have Cont type wrappers, you won't be able to write fmap ab (Cont arr) br = ...
10:44:36 <breadmonster> johnw: Ah right okay.
10:44:44 <johnw> if arr has a wrapper, so does the result
10:44:52 <ReinH> Right
10:44:54 <breadmonster> so fmap ab (Cont arr) = Cont $ \br -> ...
10:44:58 <johnw> exactly
10:45:11 <ReinH> yep
10:45:19 <ReinH> so to avoid confusion, fmap ab arr = \br -> ...
10:45:31 <ReinH> (we can stick the wrappers in later)
10:45:37 <breadmonster> absolutely.
10:45:53 <}> Hey, why can't I compile this? http://ideone.com/4CPhgd ... x:xs is a list and x is an ListTree, shouldnt this be fine?
10:46:39 <JanBessai> for reference: Data.Char has the functionality to classify unicode characters built in
10:46:49 <JanBessai> I guess I'll go with the following:
10:46:52 <JanBessai> > let san = \ s -> all (\ c -> generalCategory c `elem` [UppercaseLetter, LowercaseLetter, TitlecaseLetter, ModifierLetter, OtherLetter, NonSpacingMark, SpacingCombiningMark, EnclosingMark, ConnectorPunctuation, DashPunctuation, OpenPunctuation, ClosePunctuation, Space, DecimalNumber, LetterNumber, OtherNumber]) s
10:46:52 <arkeet> }: you want Node (x:xs)
10:46:54 <lambdabot>  <no location info>:
10:46:55 <lambdabot>      not an expression: ‘let san = \ s -> all (\ c -> generalCategory c `elem...
10:46:59 <arkeet> I think
10:47:13 <arkeet> otherwise it parses as (Node x):xs
10:47:14 <}> arkeet, wow that worked
10:47:17 <breadmonster> ReinH: Okay, umm, what's after the lambda though?
10:47:19 <}> thank you arkeet 
10:47:38 <ReinH> breadmonster: Well, what are our options
10:47:45 <breadmonster> :t ($)
10:47:47 <lambdabot> (a -> b) -> a -> b
10:47:57 <augur> ooo are you talking continuations? :D
10:48:03 <ReinH> breadmonster: Well, we have an (a -> r) -> r
10:48:13 <ReinH> If we can construct an (a -> r), we can apply it
10:48:19 <ReinH> can we construct an (a -> r)?
10:48:43 <breadmonster> Umm, `ab . br`?
10:48:50 <ReinH> Yep
10:49:10 <breadmonster> Oh so we get the br from outside...
10:49:11 <augur> just guess here by the names, but
10:49:16 <augur> you probably want br.ab
10:49:22 <ReinH> Oh right, composition is backwards
10:49:24 <ReinH> heh
10:49:26 <breadmonster> augur: Yeah, sorry.
10:49:31 <ReinH> breadmonster: yeah, br . ab
10:49:35 <breadmonster> Forgive my n00bness.
10:49:39 <breadmonster> Hmm.
10:49:40 <augur> br.ab monster
10:50:05 <breadmonster> So fmap ab arr = \br -> arr (br . ab) 
10:50:07 <breadmonster> ?
10:50:34 <augur> ah so you're doing fmap for continuations?
10:50:38 <breadmonster> augur: Yup.
10:50:38 <ReinH> augur: yep
10:50:47 <ReinH> breadmonster: you tell me :)
10:51:21 * hackagebot cryptol 2.2.4 - Cryptol: The Language of Cryptography  http://hackage.haskell.org/package/cryptol-2.2.4 (AdamFoltzer)
10:51:27 <ReinH> btw, now you see what I meant about pre-composing ab :)
10:51:33 <exio4> let djinn do the monad instance and implement Functor/Applicative with liftM/ap :p 
10:51:42 <ReinH> exio4: djinn can do fmap too :p
10:51:52 <breadmonster> :t (undefined :: (a -> r) -> r) ((undefined :: b -> r) . (undefined :: a -> b))
10:51:54 <lambdabot> r
10:51:57 <tommd> acfoltzer: New cryptol on hackage? Nice work.
10:51:58 <breadmonster> yay!
10:52:03 <ReinH> breadmonster: :)
10:52:09 <ReinH> So then just add the Cont wrappers
10:52:09 <augur> fwiw i think using lambdas, not composition, makes this easier to write
10:52:19 <ReinH> fmap ab (Cont arr) = Cont $ \br -> arr (br . ab)
10:52:19 <acfoltzer> tommd: on hackage, and binary releases
10:52:25 <breadmonster> Yeah, in hindsight augur is right.
10:52:31 <ReinH> augur: but I think about it using composition :)
10:52:35 <arkeet> @djinn cmap :: (a -> b) -> ((a -> r) -> r) -> ((b -> r) -> r)
10:52:35 <lambdabot> Cannot parse command
10:52:39 <arkeet> @djinn (a -> b) -> ((a -> r) -> r) -> ((b -> r) -> r)
10:52:39 <lambdabot> f a b c = b (\ d -> c (a d))
10:52:41 <augur> if only because interactivity is nicer
10:52:44 <augur> fmap ab arr = ? :: (b -> r) -> r
10:52:48 <augur> hit it with a lambda
10:52:58 <augur> fmap ab arr = \br -> ? :: r
10:53:01 <ion> :exf (a -> b) -> ((a -> r) -> r) -> ((b -> r) -> r)
10:53:02 <exferenceBot> \ b c d -> c (\ g -> d (b g))
10:53:05 <ReinH> or hit it with composition
10:53:13 <augur> now whats available that ends in r? well, br :: b -> r and arr :: (a -> r) -> r
10:53:32 <augur> so try arr   fmap ap arr = \br -> arr (? :: a -> r)
10:53:49 <augur> hit it with a lambda    fmap ab arr = \br -> arr (\a -> ? :: r)
10:54:12 <ReinH> augur: The way I look at it is: a is in negative position in (a -> r), so a contramap on a is likely, and we have ab, so it's likely we'll use (. ab) somewhere.
10:54:33 <breadmonster> ReinH: Okay, awesome thank you so much!
10:54:40 <breadmonster> Umm, do you know how to implement Applicative?
10:54:50 <breadmonster> Like what the class looks like? I'll do the implementation myself.
10:54:53 <augur> try br   fmap ab arr = \br -> arr (\a -> br (? :: b))   then   ab   then  a           fmap ab arr = \br -> arr (\a -> br (ab a))
10:54:57 <augur> can compose out later
10:54:59 <ReinH> breadmonster: just follow the types :)
10:55:09 <breadmonster> ReinH: Yeah I meant what are the types? :P
10:55:13 <ReinH> breadmonster: you tell me
10:55:16 <breadmonster> :info Applicative
10:55:27 <breadmonster> ReinH: I actually don't know :P
10:55:28 <ReinH> augur: Ok, but I prefer my way. Different strokes...
10:55:34 <ReinH> :t (<*>)
10:55:36 <ReinH> :t pure
10:55:36 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:55:37 <lambdabot> Applicative f => a -> f a
10:55:38 <breadmonster> I don't remember the Applicative class definition.
10:55:45 <breadmonster> Oh okay, cool.
10:55:48 <breadmonster> pure is easy.
10:56:00 <augur> ReinH: a is positive there
10:56:04 <breadmonster> `pure x = \f -> f x`
10:56:08 <ReinH> augur: it's positive in (a -> r) -> r
10:56:12 <augur> ReinH: i mean, in the type, yeah
10:56:12 <ReinH> it's negative in a -> r
10:56:15 <ion> breadmonster: Put _ into your code and GHC will tell the type of the hole as well as types of certain things in scope.
10:56:19 <augur> negative in a -> r, indeed
10:56:22 * hackagebot nettle 0.1.1 - safe nettle binding  http://hackage.haskell.org/package/nettle-0.1.1 (stbuehler)
10:56:28 <ReinH> augur: double negated positive position :)
10:56:31 <breadmonster> ion: You're the best thank you so much.
10:57:19 <ReinH> augur: (the kind of double negation that haskell's type system *does* support) ;)
10:57:26 <ion> Cont f <*> Cont a = Cont _
10:57:44 <augur> ReinH: different kind of polarity tho :p
10:57:46 <ReinH> ion: hole-driven programming is much nicer now that we have that
10:57:50 <augur> breadmonster: so the type   `(a -> r) -> r`   is equivalent to the type `a`, fwiw
10:57:51 <ReinH> augur: not really :)
10:58:42 <augur> ReinH: its pretty different. polarity of a position in a type indicates who's responsible for providing it -- positive = this piece, negative = the thing using this piece
10:58:48 <ReinH> (a -> Void) -> Void and (a -> r) -> r are both encodings of double negation elimination, but only one is inhabited.
10:58:55 <ReinH> augur: it's really not as different as you think )
10:58:57 <ReinH> :)
10:59:18 <augur> `(a -> r) -> r` is definitely NOT double negation elimination, tho in an instantiation it is
10:59:26 <ReinH> right
10:59:38 <ReinH> they're both theorems of double negation elimination
10:59:41 <ReinH> I should have been more precise
11:00:02 <ReinH> augur: http://polaro.blogspot.com/2010/05/five-kinds-of-double-negation.html
11:00:13 <augur> we should be explicit with the quantifiers, and how the theorems hold
11:00:25 <augur> double negation elimination is not just that type
11:00:42 <augur> its crucially the type   forall a. ((a -> Void) -> Void) -> a
11:01:03 <ReinH> Ok, not double negation elimination. Double negation.
11:01:09 <}> :o I just realized you can pattern match arguments in lambda functions
11:01:17 <maerwald> :)
11:01:17 <}> thanks to arkeet 
11:01:20 <breadmonster> }: How?
11:01:32 <}> breadmonster,  Just "test" >>= (\(x:xs) -> Just ([x] ++ "!"))
11:01:36 <ReinH> I was wondering if my irc client was having an issue but your nick actually is "}". Huh.
11:01:45 <}> And your nick is ReinH 
11:01:46 <augur> ReinH: thats where it falls apart tho. `(a -> Void) -> Void` and `(a -> r) -> r`   are crucially different because a and r are quantified 
11:02:07 <breadmonster> }: Oh yeah you can do that, but you can't always have exhaustive patterns :(
11:02:10 <merijn> }: Only a single pattern, though. So if you're datatype has more than 1 constructor it will crash when given any other
11:02:18 <augur> ReinH: that is, these are actually the types   `forall a. (a -> Void) -> Void`   and   `forall a r. (a -> r) -> r`
11:02:19 <}> ah yeah :(
11:02:30 <merijn> }, breadmonster: You can easily work around that using LambdaCase, though
11:02:49 <breadmonster> merijn: \x -> case x of ...
11:03:01 <merijn> }, breadmonster: Yeah, but lambdacase is nicer
11:03:03 <breadmonster> ^ you mean?
11:03:06 <breadmonster> What's lambdacase?
11:03:19 <merijn> breadmonster: Extension that turns "\case" into sugar for "\x -> case x of"
11:03:27 <augur> ReinH: and _these_ can be eliminated freely in intuitionistic logic with the theorem    `(forall a. (a -> Void) -> Void) -> Void`   and   `forall s. (forall a r. (a -> r) -> r) -> s`
11:04:22 <augur> ReinH: the placement of the quantifiers changes it from being intuitionistic to classical in an important way. both of these are theorems intuitionistically:  \f -> f id
11:04:29 <arkeet> :t \f -> f id
11:04:31 <lambdabot> ((a -> a) -> r) -> r
11:04:35 <}> merijn, I think it's too early for me to worry about that :-) I'm going through all the exercises in wiki.haskell.org/Typeclassopedia
11:04:55 <hodapp> hmm, I see "class (IvoryArea (Struct sym), ASymbol sym) => IvoryStruct (sym :: Symbol) where..." - is 'sym :: Symbol' then a constraint on the kind of 'sym'?
11:05:31 <hodapp> It's a little confusing since I then also see "instance (IvoryStruct sym, ASymbol sym) => IvoryArea (Struct sym) where..." which looks a little circular to me.
11:05:53 <augur> ReinH: i dont me to rant, it's just that this is a subtle, but important, distinction that makes all the difference
11:06:13 <merijn> hodapp: Why is the circularity an issue?
11:06:36 <merijn> hodapp: It's basically saying "anything with an area must be a struct and anything that's a struct must have an area"
11:06:37 <nanoz]> project euler is above my brain any other site ?
11:06:40 <augur> its also one reason why implicit prenex quantification in haskell can be misleading. `(a -> Void) -> Void` looks like double negation but its really not, because of the quantification
11:06:46 <merijn> @where exercises
11:06:46 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
11:06:50 <merijn> nanoz]: Try those
11:06:57 <breadmonster> merijn: Why aren't these nice things part of the Haskell language?
11:07:04 <breadmonster> nanoz]: Also try SPOJ.
11:07:19 <merijn> breadmonster: Because LambdaCase only existed since 7.6 and there isn't a lot of incentive to update the report
11:07:31 <geekosaur> breadmonster, this is the first step in it becoming part of the language
11:07:47 <merijn> breadmonster: The report is a "descriptive spec", i.e. it describes "what is", but in the absence of competing implementations, why bother defining new versions of the report?
11:08:16 <crough> JHC is (somewhat) used though, right?
11:08:20 <merijn> breadmonster: There's only 3 (semi) serious implementations of haskell atm, only 1 of which is both free and widely used
11:08:29 <geekosaur> somewhat used, but not very widely
11:08:31 <merijn> crough: JHC only vaguely rings a bell
11:08:37 <merijn> Ok, so maybe 4, then
11:08:41 <geekosaur> it's missing a lot of things that are useful in the real world
11:08:43 <hodapp> merijn: well, I had thought, for instance, that one had to narrow things down when defining typeclasses in that way, so I'm trying to see how it still does that.
11:08:53 <breadmonster> I really, really want to see Mu.
11:08:57 <ReinH> augur: thanks
11:09:00 --- mode: ChanServ set +o geekosaur
11:09:02 <breadmonster> Why can Standard Chartered just open source it? :(
11:09:17 <merijn> GHC, UHC (open source and freely available, but lagging way behind GHC atm), JHC (no clue about its status), and Mu (technically not even haskell, since it's strict)
11:09:19 --- mode: geekosaur set +b *!~dameloo@80.30.150.222
11:09:20 --- kick: dameloo was kicked by geekosaur (Your behavior is not conducive to the desired environment.)
11:09:25 <ReinH> geekosaur: thanks
11:09:29 <geekosaur> "solo hooy" PM spam
11:09:30 <Haskellfant> merijn: what's the second commerical one? intel?
11:09:36 <augur> geekosaur: hah. i was about to mention that :)
11:09:47 <hodapp> JHC, last I checked, is a bit dead. Kiwamu Okabe forked it to do some work on AJhc and tried to get his source pushed back upstream, but he could not get a response out of the author to do so.
11:09:56 <augur> breadmonster: are you trying to grok continuations?
11:10:02 <breadmonster> augur: Indeed.
11:10:11 <geekosaur> no, he got a response, and most if not all of his changes did get in
11:10:12 <ReinH> There's some info on the state of haskell compilers in the latest monthly report
11:10:13 <merijn> breadmonster: The official answer on why it's not open source is: "Lawyers are afraid of getting sued"
11:10:14 <breadmonster> I've heard CPS is useful for compiler writing.
11:10:24 <crough> hodapp: It merged and they've even added a proper GC, but it's really hard to see any progres. I think people work on it in bursts and then it lies dead for 12 months
11:10:24 <geekosaur> but the main author is focusing on other stuff for the most part
11:10:26 <augur> breadmonster: ok. can i give you some advice for how to approach it
11:10:27 <augur> ?
11:10:29 <breadmonster> merijn: Lawyers or the company? :P
11:10:35 <geekosaur> pretty much what crough just said
11:10:35 <breadmonster> augur: absolutely.
11:10:39 <merijn> breadmonster: Lawyers working for the company
11:10:51 * geekosaur has been following jhc development
11:11:02 <hodapp> geekosaur: When was this? I have an email in my inbox right now from Kiwamu saying certain things that were not merged.
11:11:10 <josephle> merijn: also probably too hard to decouple company "secrets" with the language
11:11:14 <crough> geekosaur: Do you have *any* news at all, then? I'm super curious about the project but damn is it hard to find *anything* out about it
11:11:18 <augur> breadmonster: look at the concept of a continuized type/simple continuation first. that is to say   type SimpleCont a = forall r. (a -> r) -> r
11:11:24 <breadmonster> merijn: That's interesting, I wonder what IP issues they'd have.
11:11:32 <breadmonster> augur: foralls scare me :(
11:11:41 <augur> breadmonster: then you should tackle those first :)
11:11:44 <hodapp> geekosaur: and that was from about a month ago.
11:11:46 <geekosaur> some months ago. and I did say most. IIRC there was a response from John that some things he planned to implement in a different way
11:11:48 <breadmonster> That's not a joke, btw. I actually have difficulties understanding forall
11:11:49 <augur> breadmonster: lets talk about foralls!
11:11:51 <merijn> breadmonster: I got the impression wasn't so much "IP issue" but more "oh god, what if someone uses it, it breaks and they sue?!"
11:11:53 <geekosaur> would have to dig in the archives
11:12:07 <hodapp> geekosaur: huh, okay. The impression that Kiwamu gave me is that he had simply not heard back from the JHC folks
11:12:13 <augur> we might want to take this to #haskell-in-depth btw
11:12:27 <breadmonster> augur: That channel actually exists?
11:12:30 <breadmonster> Yeah sure though
11:12:30 <crough> hodapp: I think that was the news for a while, but last time I checked it's merged...
11:12:30 <augur> yeah
11:12:38 <merijn> augur: If you need a good simple example, I wrote https://gist.github.com/merijn/77e3fa9757658e59b01d as minimal example of why Rank2 might be needed
11:12:52 <augur> actually breadmonster, give me a few. i need to get something to eat
11:12:59 <breadmonster> augur: Go ahead.
11:13:12 <breadmonster> merijn: Doesn't FOSS come without any guarantee?
11:13:28 <merijn> breadmonster: You can get started by pondering that link (I have to get back to work, instead of talking here)
11:13:39 <merijn> breadmonster: Lawyers of banks are paranoid about risk :p
11:13:49 <breadmonster> merijn: The gist you mean?
11:13:55 <P123> guys, is there lambdabot equivalent of ghci :info command?
11:14:08 <merijn> breadmonster: Yeah, it shows the minimal example I can think of showing a need for Rank2
11:14:11 <merijn> P123: There isn't one
11:14:14 <hodapp> crough: What he told me a month ago in email is that context local heaps had not been merged, and that was (IIRC) a considerable part of his work on Ajhc.
11:14:32 <crough> hodapp: Ahh, didn't realize it was an incomplete merge...
11:14:52 <P123> merijn: ty
11:15:08 <Denommus> merijn: they are not wrong to be paranoid
11:15:21 <merijn> Denommus: I didn't say that, I just think it's a shame
11:15:24 <Denommus> merijn: heartbleed caused a mess for banks, you know
11:16:08 <merijn> breadmonster: Consider me trying to pass "f :: Int -> Int; f x = x + 1" to "mangle" and why that would not work
11:16:35 <hodapp> geekosaur: The idea that I had from two things - the email from Kiwamu saying that CLHs weren't merged, and the work of his that I read - is that context local heaps were a substantial part of the work he did on Ajc.
11:16:39 <breadmonster> merijn: Because there's a double in one of the constructors.
11:16:46 <hodapp> geekosaur: but if you have the JHC message you're thinking of I'd like to read it
11:16:57 <breadmonster> If it was f :: Num a => a -> a, I don't see why it won't compile.
11:17:27 <merijn> breadmonster: Right, so the problem is that "Num a => (a -> a)" says "I can take a function that works for ANY specific Num instance and I will work"
11:17:51 <merijn> breadmonster: Whereas, what you WANT to say is "I can take a function that works for ALL Num instances and I will work"
11:18:17 <merijn> breadmonster: i.e. the question is "who gets to pick the type of 'a'", in the first, the caller of 'mangle' gets to pick which 'a' he wants to use
11:18:34 <merijn> breadmonster: But for our example to work it should be 'mangle' that gets to pick which 'a' to use
11:18:42 <breadmonster> merijn: So you mean it specializes f too early?
11:19:11 <merijn> breadmonster: Not specialise, but the type of mangle doesn't match what it needs
11:19:38 <merijn> breadmonster: In the second example the forall is saying "if you give me a function that works for ANY 'a' that I pick, then I'll work"
11:19:49 <breadmonster> Hmm okay.
11:20:01 <merijn> breadmonster: "Int -> Int" doesn't work "for any 'a'", so passing that to the second mangle version is a type error
11:20:14 <breadmonster> Hmm, okay, I get what you mean.
11:20:19 <merijn> "(+1) :: Num a => a -> a" would work for the second version of mangle
11:20:46 <merijn> breadmonster: That, in a nutshell is all there is to the 'forall' business
11:21:15 <breadmonster> I'm going to need some time to think this over.
11:21:29 <breadmonster> There's more machinery than I'm used to, but I kinda get what you're saying...
11:21:42 <breadmonster> Does Haskell have freenode cloaks, btw?
11:21:57 <merijn> breadmonster: The easiest way to understand Rank2 types is to run into a case where you need them to make your code work, like here :p
11:22:50 <hexagoxel> edwardk: thanks for the `foo = foo >> modify (1:)` testcase, it detected unnecessary strictness in multistate :)
11:26:24 * hackagebot packed-dawg 0.2.0.6 - Generation and traversal of highly compressed directed acyclic word graphs.  http://hackage.haskell.org/package/packed-dawg-0.2.0.6 (AndrasKovacs)
11:26:40 <ReinH> breadmonster: cloaks?
11:26:51 <ReinH> merijn: well, that's the easiest way to use them, at least...
11:29:37 <merijn> ReinH: Hiding your hostname in /whois
11:29:45 <ReinH> Ah.
11:29:56 <breadmonster> You don't have one it seems.
11:30:35 <nschoe> Hey guys. I'm using happstack to deal with an HTML form. In this form I want to allow my users to upload files. I'd like to use only ont <input> (I set the "multiple" property). But as far as I can see, happstack only provides with 'lookFile' which returns *one* uploaded file.
11:30:49 <merijn> I don't either, but I have an ISP that let's me set my own reverse lookup hostname \o/
11:30:49 <nschoe> any idea how I can handle several files? (The doc is http://hackage.haskell.org/package/happstack-server-7.4.4/docs/Happstack-Server-RqData.html)
11:34:50 <srhb> nschoe: Looks like that's unsupported. You'd need to reimplement lookFile, but it's relatively simple. :)
11:35:22 <srhb> nschoe: Also look at inputValue
11:35:34 <nschoe> srhb, I'll look at inputValue, then thanks
11:36:07 <nschoe> srhb, and then look at lookInput's source code to try to re-implement it.
11:36:19 <srhb> nschoe: Yep :)
11:36:25 * hackagebot log 0.2.1 - Structured logging solution with multiple backends  http://hackage.haskell.org/package/log-0.2.1 (arybczak)
11:36:35 <nschoe> srhb, I hope you meant it when yo usaid it was relatively easy ^^
11:36:40 <srhb> nschoe: Really the base version should probably return [FilePath] instead of FilePath, you could send a request
11:36:48 <srhb> nschoe: Oh definitely, it's just a bit of tweaking :)
11:37:33 <nschoe> srhb, Okay thanks for your help then ^^
11:41:25 * hackagebot packed-dawg 0.2.0.7 - Generation and traversal of highly compressed directed acyclic word graphs.  http://hackage.haskell.org/package/packed-dawg-0.2.0.7 (AndrasKovacs)
11:45:13 <bitemyapp> @pl \(s, ai) -> map (\ai' -> (s, ai')) ai
11:45:14 <lambdabot> uncurry (map . (,))
11:50:14 <P123> guys how to load module in lambda bot?
11:50:43 <geekosaur> can use @let import but many modules will not import for various reasons
11:50:58 <geekosaur> (mostly safety, as in Safe Haskell)
11:50:59 <P123> arithmoi will not import?
11:51:26 * hackagebot bindings-nettle 0.3 - bindings to nettle crypto library  http://hackage.haskell.org/package/bindings-nettle-0.3 (ClintAdams)
11:52:11 <geekosaur> also note that it will be lost when someone does @undefine --- talk to int-e if you really need it to be part of the standard imports
11:52:48 <geekosaur> (it depends on what packages are available on the machine where lambdabot runs. nobody guarantees that all of hackage is installed there)
11:53:29 <P123> geekosaur: ty
11:54:20 <hodapp> Graaaaaah. People who write hundreds of lines of Template Haskell and QuasiQuoer implementation to make something "easier"... but can't write a tenth of that in documentation for the underlying thing.
11:56:13 <hexagoxel> readme.md and changelog.md are extra-source-files?
11:57:13 <SrPx> Anyone with a creative mind here knows if I can make a non-recursive function that will receive the term `scott123 = (\ c n -> c 1 (\ c n -> c 2 (\ c n -> c 3 n)))` and return 6? 
11:57:33 <SrPx> Probably not, correct? I wonder if there is a proof.
11:57:42 <arkeet> :t (\ c n -> c 1 (\ c n -> c 2 (\ c n -> c 3 n)))
11:57:46 <lambdabot> (Num a, Num a1, Num a2) => (a -> ((a1 -> ((a2 -> r5 -> r4) -> r5 -> r4) -> r3) -> r2 -> r3) -> r1) -> r -> r1
12:00:10 <ClaudiusMaximus> SrPx: const 6  -- but i guess you mean it to return something else for other terms, so you might want to tweak the question
12:00:24 <SrPx> ClaudiusMaximus: ha, ha.
12:00:44 <ClaudiusMaximus> SrPx: or am i misreading 'receive' ?
12:01:13 <SrPx> Tweaked question: is it possible to write a non-recursive function that converts a scott-encoded list in a normal list? :)
12:02:07 <ClaudiusMaximus> SrPx: can you scott-encode an infinite list in a finite term?
12:02:29 <magneticDuck> pretty sure variadic functions like that aren't .. really a thing in haskell
12:02:48 <magneticDuck> well, not sure if you'd call this a variadic function
12:02:48 <hodapp> magneticDuck: what does one call the Text.Printf technique?
12:02:57 <magneticDuck> black magic
12:03:09 <hodapp> it's variad...ish
12:03:11 <geekosaur> typeclass hackery, of the more evil bvariety
12:03:23 <hodapp> yes, let's use the term variadish instead
12:03:33 <hodapp> everyone cool with that?
12:03:55 <arkeet> SrPx: I don't get it though, you're discarding two of the 'n's
12:06:27 * hackagebot bindings-nettle 0.3.1 - bindings to nettle crypto library  http://hackage.haskell.org/package/bindings-nettle-0.3.1 (ClintAdams)
12:06:29 * hackagebot pandoc-csv2table 1.0.1 - Convert CSV to Pandoc Table Markdown  http://hackage.haskell.org/package/pandoc-csv2table-1.0.1 (baig)
12:07:27 <ClaudiusMaximus> arkeet: that's scott-encoding - it's like \constr1 constr2 .. constrN -> constrX ...  ;  my intuition is  \c n -> ...  as  \ (:) [] -> f ...  where f must be one of the arguments and the ... shouldn't use the arguments
12:07:41 <arkeet> oh right.
12:07:53 <arkeet> shouldn't that be \c n -> c 1 (c 2 (c 3 n)) then?
12:08:03 <ClaudiusMaximus> that's church encoding i think
12:08:10 <arkeet> oh.
12:08:29 <ClaudiusMaximus> church encoding is like a fold, scott encoding is more like constructors/pattern matching
12:08:34 <SrPx> exactly
12:09:00 <arkeet> hm.
12:09:08 <SrPx> scott lists are useful because they have better complexity for some things (in relation to church/folds)
12:09:22 <SrPx> but I'm only allowing terms with normal forms
12:09:35 <SrPx> so I'm not sure if it is even possible to write, say, a fold for scott lists
12:09:45 <exio4> scott lists are basically a naive encoding of datatypes, while keeping pattern matching / construction O(1) 
12:09:45 <arkeet> can you write a type for them?
12:10:32 <SrPx> there are two workarounds, having an additional c, "(\ c n → c c 1 (c n → c c 2 n))" so the cons math can receive itself and propagate through the list
12:11:05 <SrPx> or memoizing the length of the list and using the church encoded length to navigate through the list til the end
12:11:16 <SrPx> which sounds reasonable but isn't good when you have trees
12:11:24 <SrPx> so I wonder if there is a better solution
12:12:41 <phaazon> hey
12:12:55 <phaazon> what do you think is the best idea to build a GUI lib?
12:12:57 <phaazon> gtk2hs?
12:14:18 <hodapp> http://hackage.haskell.org/package/Rlang-QQ-0.3.1.0/docs/RlangQQ.html huh, my mind is blown a little... 
12:14:50 <SrPx> hodapp: wow
12:15:43 <exio4> SrPx: why wouldn't it be possible to write a fold for scott encoded lists?
12:15:45 <hodapp> SrPx: I was aware of people putting other languages inside of quasiquoted things and then parsing them in Haskell and turning them to other Haskell, but this is something new to me.
12:16:33 <SrPx> exio4: with recursion it is easy, but without, I'm not sure.
12:16:54 <SrPx> exio4: if you have an idea let me know :)
12:20:41 <exio4> SrPx: ah, without recursion
12:22:50 <phaazon> goddammit
12:23:01 <phaazon> the gtk package depends on gtk2…
12:23:38 <Clint> @hackage gtk3
12:23:39 <lambdabot> http://hackage.haskell.org/package/gtk3
12:25:08 <Welkin> SrPx: isn't everything recursive anyway?
12:25:15 <Welkin> there are no loops
12:26:24 <phaazon> Clint: oh, great :)
12:26:26 <phaazon> thanks
12:26:38 <Clint> np
12:29:53 <SrPx> Welkin: no, there are a lot of things you can do without recursion
12:30:00 <SrPx> everything, really
12:30:29 <SrPx> ref http://www.haskellforall.com/2014/09/morte-intermediate-language-for-super.html for example
12:31:16 <tdammers> better yet, you can emulate recursion on top of a stateful imperative instruction set (mutable variables and conditional jumps)
12:31:30 <SrPx> that is not better D:
12:32:19 <SrPx> Btw I think the way to go is just to update the scott encoding to also provide the matching functions to themselves after the match
12:32:49 <SrPx> so rec_scott = (\ cons nil → cons cons nil 1 (\ cons nil → cons cons nil 2 (\ cons nil → cons cons nil 3 nil)))
12:33:07 <joshc> window 3
12:33:10 <joshc> ...
12:33:20 <SrPx> using that encoding fold is doable without involving terms without normal forms... if anyone has a better solution please let me know on http://stackoverflow.com/questions/30604408/is-there-any-non-recursive-term-that-folds-over-a-scott-encoded-list
12:33:52 <tdammers> for some values of "better" ;)
12:36:33 <SrPx> better as in, not needing to modify the scott encoding...
12:37:11 <NemesisD> is it possible to get the fully qualified, unique name of a type with Typeable, i.e. Foo.Bar.Baz?
12:41:29 <NemesisD> nm looks like its all from tyCon
13:15:43 <osa1> is this a bug: when I have Prelude.hs in pwd ghci and runghc tries to load it automatically, instead of loading Prelude from base.
13:19:56 <Feuerbach> osa1: not really a bug. You can work around this by passing -i to ghci
13:20:27 <greymalkin> I'm trying to get an applicative f to apply to an array such that (a -> f a) -> [a] -> f [a] -- but all I seem to be able to get is (a -> f a) -> [f a] and I can't find the Applicative version of sequence
13:20:54 <quchen> :t sequenceA
13:20:54 <geekosaur> :t sequenceA
13:20:57 <geekosaur> heh
13:21:00 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
13:21:00 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
13:21:20 <Feuerbach> greymalkin: look at Data.Traversable. What you're trying to implement is called traverse, and there's also sequenceA
13:21:44 <Feuerbach> greymalkin: also, [a] is a list, not an array
13:22:32 <greymalkin> Sorry.. yes, I keep saying array when I mean list -- just because I'm an old C programmer and they're almost interchangable there (actual lists are fairly rare)
13:23:08 <fvgvxmpv1> :t mapA
13:23:10 <lambdabot>     Not in scope: ‘mapA’
13:23:10 <lambdabot>     Perhaps you meant one of these:
13:23:10 <lambdabot>       ‘mapM’ (imported from Control.Monad.Writer),
13:23:27 <arkeet> use fmap
13:23:30 <arkeet> er
13:23:34 <arkeet> traverse
13:23:36 <arkeet> :t mapM
13:23:38 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
13:23:39 <arkeet> :t traverse
13:23:41 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
13:24:06 <arkeet> ok now about the actual question
13:24:09 <Feuerbach> greymalkin: quite the opposite, the difference is even more obvious in c, where arrays are given and lists (ie single linked lists) you need to implement with structs and pointers
13:24:11 <arkeet> greymalkin: use traverse
13:25:48 <arkeet> :t \f -> foldr (\a m -> (:) <$> f a <*> m)
13:25:51 <lambdabot> (Applicative f, Foldable t) => (a -> f a1) -> f [a1] -> t a -> f [a1]
13:25:54 <arkeet> oops.
13:26:02 <arkeet> :t \f -> foldr (\a m -> (:) <$> f a <*> m) (pure [])
13:26:04 <lambdabot> (Applicative f, Foldable t) => (a -> f a1) -> t a -> f [a1]
13:26:10 <arkeet> :-(
13:28:45 <arkeet> :t \f -> foldr (liftA2 (:) . f) (pure [])
13:28:47 <lambdabot> (Applicative f, Foldable t) => (a -> f a1) -> t a -> f [a1]
13:29:07 <greymalkin> Feuerbach: But in C, the arrays are the common first use, lists come only when they're needed -- haskell lists are first, arrays if needed.
13:30:07 <Feuerbach> greymalkin: that is correct
13:31:32 * hackagebot geniplate-mirror 0.7.1 - Use Template Haskell to generate Uniplate-like functions.  http://hackage.haskell.org/package/geniplate-mirror-0.7.1 (DanRosen)
13:36:32 * hackagebot bindings-nettle 0.4 - bindings to nettle crypto library  http://hackage.haskell.org/package/bindings-nettle-0.4 (ClintAdams)
13:39:03 <greymalkin> arkeet: The problem is that my datatype can't be traversable (wrong kind) -- so I'm trying to implement 'plate' in lenses and hitting a wall.
13:39:27 <arkeet> didn't you say you had a list
13:39:28 <arkeet> ?
13:39:31 <arkeet> or array or whatever
13:39:56 <arkeet> if you're using lens and you have a traversal for that thing
13:40:01 <arkeet> then just apply it directly
13:40:11 <arkeet> > both (\x -> (show x, x)) (1,2)
13:40:14 <lambdabot>  ("12",(1,2))
13:40:25 <arkeet> > traverse (\x -> (show x, x)) [1,2,3]
13:40:29 <lambdabot>  ("123",[1,2,3])
13:41:11 <arkeet> (or you can use the %%~ operator, but that's just id)
13:42:18 <Vektorweg11> hm. i wonder if i should build a transformer or not. for example a could write a WriterT a MyMonad () but also MyMonad a . Reader seems comparable trivial. what would you guys do?
13:43:03 <Vektorweg11> i actually have a case of  e -> m a  and i wonder if its a good idea to build a transformer for this simple case. 
13:43:34 <Rembane> Vektorweg11: What gives the clearest code?
13:44:10 <Vektorweg11> Rembane: i dont know yet.
13:44:55 <arkeet> it depends on what you're trying to do, but why don't you just try writing your code without it
13:45:03 <arkeet> and then decide later if it would be more convenient
13:45:19 <johnw> transformers are incredibly handy when you have no control over the 'm', or you don't know what it is
13:45:31 <johnw> for your own monad, transformers are probably not worth the weight
13:45:36 <johnw> you can always just implement MonadWriter
13:45:49 <Vektorweg11> arkeet: its a lib. so i really have a unknown m. ;)
13:46:20 <johnw> so you really have MyMonad e m a, being identical to ReaderT?
13:46:56 <Vektorweg11> however, i already abstract some things in a transformer, but on top is a  e -> ma  left, which might or might not be used well enough, to be transformed too.
13:47:12 <Vektorweg11> * ma 
13:47:13 <Vektorweg11> m a
13:47:49 <Vektorweg11> i guess i shouldnt use a writer here. and reader sounds not so convenient too. 
13:48:51 <greymalkin> *sigh of relief* Yes: liftA2 (\c nc -> c{ _subitems = nc}) (f item) (traverse f (_subitems c))
13:49:12 <Vektorweg11> or maybe i do both ... one function with transformers and one without them. 
13:49:14 <greymalkin> almost there.
13:49:29 <johnw> greymalkin: that looks like something that begs to be done with lens :)
13:50:53 * hodapp builds with -ddump-slices, and watches the lights in the room dim
13:51:00 <hodapp> sigh. coffee time.
13:51:12 <greymalkin> johnw: I'm trying to make my ADT an instance of Plated... 
13:51:19 <liveify> :t both
13:51:19 <johnw> ahh
13:51:21 <lambdabot> (Applicative f, Data.Bitraversable.Bitraversable r) => (a -> f b) -> r a a -> f (r b b)
13:51:42 <arkeet> Applicative f => (a -> f b) -> (a,a) -> f (b,b)
13:51:46 <arkeet> is what it used to be before it got generalized
14:00:24 <sinelaw> any lib out there for rendering IRC color codes?
14:00:43 <sinelaw> (I have ansi color output, want to convert to IRC color commands)
14:00:56 <arkeet> convert *to* irc color commands?
14:01:10 <sinelaw> yes
14:01:20 <arkeet> from what
14:01:32 <sinelaw> ansi color codes
14:01:46 <albeit> How can I do "[(a -> b)] -> a -> [b]"? The same a is being fed to the list of functions
14:02:22 <ion> @type \a -> map ($ a)
14:02:22 <dolio> sequence
14:02:25 <lambdabot> a -> [a -> b] -> [b]
14:02:26 <arkeet> albeit: come up with some (a -> b) -> b and map it.
14:02:45 <magneticDuck> @pl \xs x -> map ($x) xs
14:02:45 <lambdabot> flip (map . flip id)
14:02:48 <Vektorweg11> ion: +1
14:03:03 <albeit> Thanks! ion's is perfect
14:03:12 <subleq> @pl \a -> map ($ a)
14:03:12 <lambdabot> map . flip id
14:03:25 <fvgvxmpv1> surely they´re *m*IRC color commands?
14:03:50 <johnw> sequence on a list of functions will yield a function that takes their common domain and returns a list of results
14:04:21 <ion> @type [\xs a -> map ($ a) xs, sequence]
14:04:24 <lambdabot> [[a -> b] -> a -> [b]]
14:04:44 <Sindri_> Hi! Could anyone help me with ghc-mod?
14:04:45 <sinelaw> whatever will work in common irc clients
14:07:25 <Sindri_> ghc-mod type just exits for me and does nothing :(
14:15:32 <napping> Has anyone used compdata much?
14:16:34 * hackagebot xcffib 0.3.2 - A cffi-based python binding for X  http://hackage.haskell.org/package/xcffib-0.3.2 (TychoAndersen)
14:17:41 <erikd> say what?
14:18:11 <napping> compdata?
14:18:32 <napping> I'm trying to figure out how to work with annotations http://hackage.haskell.org/package/compdata
14:19:42 <erikd> no, python bindings on hackage.
14:21:44 <napping> It's a tool written in Haskell
14:29:24 <Sindri_> Is ghc-mod type working for anyone?
14:31:00 <joey204> I would like to use Haskell on OpenBSD, and I see there is both the GHC and haskell-platform ports, but GHC dies when you run it. This is on 5.7:  GHCi Runtime linker: fatal error: I found a duplicate definition for symbol __i686.get_pc_thunk.bx whilst processing object file /ust/local/lib/libiconv.a 
14:31:25 <joey204> why does GHCi fail on this library?
14:31:35 * hackagebot conduit-parse 0.1.0.0 - Parsing framework based on conduit.  http://hackage.haskell.org/package/conduit-parse-0.1.0.0 (koral)
14:46:57 <zoug> hey you guys.. I have some questions and I believe you are very well-placed to answer but it's compeletly off-topic, is there any related channel but for non-haskell-related topics? thanks..
14:47:54 <kadoban> zoug: #haskell-blah
14:48:02 <zoug> awesome
14:48:14 <napping> Is there a way to run cabal tests from ghci?
14:54:45 <Sindri_> Is ghc-mod type working for anyone?
14:56:05 <kadoban> I would assume it's working for many people, and presumably not for you. If you give some kind of details, you might have hope of someone looking into it with you :)
14:58:37 <vik123> Hi all, is there an easier way to load multiple modules into GHCi at a single time instead of typing :m + 'module1' 'module2' etc. for each one I want to load? Like a batch load script?
14:58:58 <arkeet> you can put them in ghci.conf
14:59:46 <vik123> thats exactly what I was looking for. Thank you!
15:00:23 <Sindri_> kadoban: Yeah, I asked a couple of lines before and nobody answered, so I was just looking if I was the only one with the issue :)
15:00:40 <Sindri_> My problem is that it does nothing. It just returns, without printing anything.
15:00:57 <kadoban> Sindri_: I know, I saw. Nobody tends to answer survey questions … they're just not very interesting to answer.
15:02:17 <Sindri_> kadoban: I guess. IRC is not really familiar to me :)
15:02:26 <kadoban> :)
15:02:48 <Sindri_> I've even tried reinstalling Haskell Platform, since I've had Cabal set up wrong, but that didn't solve the issue. Other parts of ghc-mod seem to be working, though.
15:03:08 <Sindri_> Lint, for example, prints out stuff normally. Just type doesn't do anything for any input I tried.
15:05:52 <dedgrant> Sindri_: Are you invoking ghc-mod from the commandline to rule out tool integration problems?
15:06:37 * hackagebot gitit 0.10.7 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.10.7 (JohnMacFarlane)
15:07:56 <Sindri_> dedgrant: That was the first thing I tried. It doesn't even have any weird return codes, just zero.
15:08:18 <phaazon> (process:2762): Gtk-CRITICAL **: gtk_settings_get_for_screen: assertion 'GDK_IS_SCREEN (screen)' failed
15:08:21 <phaazon> zsh: segmentation fault (core dumped)  ghci
15:08:24 <phaazon> holy shit…
15:08:29 <phaazon> isn’t there a working GUI library out there :(
15:08:31 <dedgrant> Sindri_: Ah OK cool. Was just a thought.
15:09:05 <Sindri_> dedgrant: I'm using ghc-mod "5.2.1.2 compiled by GHC 7.8.3", ghc version 7.8.3, and cabal version 1.22.4.0 using version 1.22.3.0 of the Cabal library.
15:09:36 <Sindri_> dedgrant: My best guess is that ghc-mod can't guess the type because of some internal changes in a newer Haskell version
15:10:43 <dedgrant> Sindri_: I'm not sure how ghc-mod works, but sounds plausible at least. Have you tried matching your own tool versions to ghc-mod?
15:11:52 <Sindri_> dedgrant: I haven't been able to determine a working version. Does it work for you? What versions do you have?
15:13:40 <dedgrant> Sindri_: I don't actually use ghc-mod anymore. Found tool integration (at the time with Sublime Text) to be too inefficient unfortunately. :( 
15:14:40 <Sindri_> dedgrant: I see! I use it to quickly check type signatures of library functions, because I often forget the order in which I'm supposed to apply them. So type is really the only feature I've been using yet :D
15:14:51 <Sindri_> dedgrant: Thanks for the help, though!
15:15:42 <kadoban> I switched to hdevtools myself
15:16:17 <Sindri_> kadoban: Oh, never heard of those! I'll take a look, thanks :)
15:17:55 <Sindri_> kadoban: Oh, that looks WAY better anyways! I'll probably setup Vim to run the server and stop it at quit, so I don't leave it running needlessly, but it looks really great :)
15:18:02 <Sindri_> kadoban: Thanks!
15:19:16 <dedgrant> Sindri_: I'm definitely in the market, so to speak, for some sort of low latency analyzer integration.. at least one where the known long-running effects do not stop the world. :)
15:20:46 <Sindri_> dedgrant: With Vim, you quickly stop worrying about this, since nothing is asynchronous :(
15:21:13 <Sindri_> Neovim should hopefully fix that, so here's hoping to a more asynchronous future.
15:21:14 <kadoban> Sindri_: Sure, enjoy. There's a plugin out there already somewhere that works decently well for me.
15:23:58 <hexagoxel> napping: easiest seems temporarily turning the test-suite into an executable and `cabal repl`ing
15:29:01 <kirill`> What's the best workaround for this:
15:29:01 <kirill`> https://ghc.haskell.org/trac/ghc/ticket/8736
15:29:31 <kirill`> I only found https://gist.github.com/int-e/86eca109afe4e77d4056 but it does something strange that prevents "cabal build" from working for executables.
15:40:17 <zipper> How do I check whether a string contains a certain substring without using regex? e.g I want to check whether a string applies the following "session.*"
15:41:07 <YellowOnion> :t isInfixOf
15:41:09 <lambdabot> Eq a => [a] -> [a] -> Bool
15:41:14 <YellowOnion> zipper, ^
15:41:41 * hackagebot cassava 0.4.3.0 - A CSV parsing and encoding library  http://hackage.haskell.org/package/cassava-0.4.3.0 (JohanTibell)
15:41:50 <zipper> YellowOnion: Thanks a ton
15:41:59 <YellowOnion> > "foo" `isInfixOf` "foobar"
15:42:01 <lambdabot>  True
15:42:17 <zipper> isInfixOf  "session" "session.1234"
15:42:27 <zipper> > isInfixOf  "session" "session.1234"
15:42:30 <lambdabot>  True
15:43:19 <YellowOnion> zipper, I'm actually using it right now to find plaintext substrings :)
15:44:01 <zipper> YellowOnion: Thanks
15:45:17 <YellowOnion> Is anyone here able to help me understand StateT and if I'm using it incorrectly?
15:48:30 <YellowOnion> explicitly the 'possiblities' list is quite huge, and could be reduce down to 3 length 26 lists but I don't know how to refactor the crack function http://lpaste.net/133741
15:49:09 <YellowOnion> zipper, you could check this out^ for a use of that function
16:02:22 <Sindri_> dedgrant: Turns out, I'm just a flipping moron. ghc-mod nor hdevtools are set out to determine the type when cursor is positioned on a type declaration.
16:03:11 <dedgrant> Sindri_: Story of my life. ;)
16:17:42 <kini> dumb question - what's a good way to create Integer powers of 2 without hlint warning me about defaulting?
16:17:56 <kini> surely "foo = 2^(64 :: Integer)" is not how I'm supposed to do this, right?
16:18:57 <pavonia> Is foo a top-level binding?
16:19:04 <kadoban> I don't know that there is a good way to avoid that. I generally just ignore the warning.
16:19:40 <geekosaur> pavonia, a type signature for foo won't help
16:20:03 <geekosaur> and yes, this is one of the cases where the warning about defaulting is rather nnoying
16:20:11 <pavonia> :t (^)
16:20:12 <Denommus> I don't understand how fixIO doesn't deadlock
16:20:13 <lambdabot> (Integral b, Num a) => a -> b -> a
16:20:15 <bernalex> I'd like type level assurance that a number stays between 0 & 9. ideas?
16:20:22 <pavonia> Hhm, I see
16:20:37 <bernalex> like data SpecialNumber = 1 | 2 | 3 | ... | 7 | 8 | 9, but you know, something that actually works
16:21:06 <Sindri_> bernalex: What's the use case?
16:21:20 <kini> kadoban, geekosaur: thanks... well, I guess I'll just ignore it then
16:21:34 <bernalex> Sindri_: basically there's an index that can only ever be between 0 & 9, and I'm curious if that's possible to encode elegantly/easily at type level
16:21:53 <Sindri_> bernalex: I see!
16:22:09 <kini> you could use the "smart constructor" hack
16:22:19 <bernalex> Sindri_: so that in "MkFoo (MkSpecialNumber 10)", MkSpecialNumber 10 would be a type error, since it needs to be 1 through 9.
16:22:31 <bernalex> or I guess it should be 0->9 but that's besides the point
16:23:07 <bernalex> kini: I'll have a read at <https://wiki.haskell.org/Smart_constructors> -- thanks!
16:23:34 <Sindri_> Well, I'd say that's where unexhaustive patterns should come into play, but they sadly don't work that way.
16:25:11 <hiptobecubic> bernalex, the smart constructor trick fails at runtime. You can't do much better without dependent types, although honestly if it's only 1-9, just make a datatype the way you show there
16:25:22 <hiptobecubic> Index
16:25:43 <hiptobecubic> data SafeIndex = Index0 | Index1 | ...   or something
16:26:54 <srhb> Agreed, but otherwise typenats are quite easy to use nowadays
16:27:13 <srhb> But the cost of getting dependent types is, well, you'll have to prove what you're doing is right. :-)
16:28:34 <Welkin> couldn't you do that with dependent types instead of smart constructors?
16:29:25 <YellowOnion> I wish wiki.haskell.org actually had a correct syntax highlighter.
16:29:39 <bernalex> I don't understand all the peano stuff in the article. is that supposed to look like that? there's a million things that end with just "where". lol.
16:30:51 <maerwald> YellowOnion: yeah...
16:30:58 <Sindri_> bernalex: This is how I imagine it could go: http://lpaste.net/133789
16:31:33 <Sindri_> bernalex: But there's probably a good reason for it not being that way, because you can only check so much at compile time, there'd always have to be runtime pattern match errors
16:32:28 <bernalex> Sindri_: yeah
16:33:01 <maerwald> unmatched patterns get matched by the compiler where it throws an explicit exception. There's a ghc warning flag for that, no?
16:34:00 <Sindri_> maerwald: Well, my idea was that it could check at compile time whether or not a function call will get pattern matched
16:34:32 <maerwald> that sounds like you almost want liquidhaskell?
16:34:36 <Sindri_> maerwald: But that only works for call that are determinable at compile time, which are few
16:34:46 <Sindri_> maerwald: Never heard of that, let me check
16:34:52 <kini> <hiptobecubic> bernalex, the smart constructor trick fails at runtime. You can't do much better without dependent types, although honestly if it's only 1-9, just make a datatype the way you show there
16:34:52 <kini> it only fails at runtime when producing values, not when consuming them, though, so it's not that terrible
16:35:28 <kini> (at least, afaiui)
16:35:45 <hiptobecubic> kini, sure, although usually you must produce a value before it can be consumed
16:35:48 <Sindri_> maerwald: Neat!
16:36:21 <maerwald> Sindri_: yes, it's pretty cool, there's also a youtube talk https://www.youtube.com/watch?v=vYh27zz9530
16:36:23 <kirill`> What does Data.Vector.Fusion.Stream do? There don't seem to be any functions in it that have anything explicitly to do with vectors?
16:36:32 <maerwald> Sindri_: but it's still alpha I'd say
16:37:10 <Sindri_> maerwald: Still, I find it extremely cool that haskell programs can be reasoned about like that
16:37:33 <geekosaur> kirill`, I think there are RULES that map vector operations into Stream operations, and then map them back if they fail to fuse
16:37:42 <maerwald> Sindri_: well, there are also liquid types for C, but I don't know how they do that
16:37:43 <geekosaur> RULES don't show up in haddocks
16:38:02 <geekosaur> (that's a ghc pragma)
16:38:08 <maerwald> afais the "liquid types" idea is not just about haskell
16:38:38 <maerwald> and C needs it much more than haskell :P
16:39:41 <geekosaur> kirill`, you would have to follow the source links to look for RULE pragmas
16:39:57 <dedgrant> maerwald: I think there is great potential for refinement types in Haskell. 
16:40:20 <kirill`> geekosaur: Thanks.
16:40:20 <kirill`> How much more efficient is it to use Vector a instead of [a] when a is storable, and the data is consumed by Marshal.Array.withArray
16:41:06 <geekosaur> that I don't know, sorry
16:41:39 <Welkin> I don't see why there would be any difference
16:42:20 <Welkin> perhaps if the data is already unpacked it may be more efficient
16:43:05 <Welkin> unboxed*
16:43:06 <napping> kirill`: what is the data produced by?
16:44:47 <kirill`> napping: An iteration that looks like (k -> Maybe (elt, nextK)), which generates a list of points, which is then uploaded to OpenGL through withArray
16:45:30 <Welkin> building a list is efficient, gradually building a vector is not
16:45:33 <Welkin> it has a fixed size
16:47:18 <kirill`> Welkin: but wouldn't withArray also need to gradually increase size of its temporary allocated memory? withArray seems to walk through the generated list twice 
16:47:28 <kirill`> @src Foreign.Marshal.Array.withArrayLen
16:47:28 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
16:47:39 <kirill`> huh? sorry
16:47:42 <kirill`> http://hackage.haskell.org/package/base-4.8.0.0/docs/src/Foreign-Marshal-Array.html#withArray
16:47:43 <napping> if it's something like that, the list probably produces one element at a time, while the vector is strict
16:48:14 <Vektorweg1> lambdabot is on facebook? o.O
16:48:27 <napping> If it does retain the whole list by walking it twice or something, then vector wouldn't hurt
16:48:39 <geekosaur> lb's error messages are from sudo's "insults mode"
16:49:33 <kirill`> napping: The ideal case would be to preallocate memory, then walk the list once, but that doesn't seem to be what either Vector or [a] would be doing.
16:49:57 <lyonsb> @src f u lambda bot ?
16:49:57 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
16:49:58 <kirill`> It's easy enough, but I'd like to know if I'm missing something
16:50:08 <Vektorweg1> lol
16:50:51 <Vektorweg1> @src i like trains
16:50:51 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
16:51:17 <Vektorweg1> @src another
16:51:18 <lambdabot> Source not found. Just try something else.
16:51:32 <Vektorweg1> @src something else
16:51:32 <lambdabot> Source not found. Just try something else.
16:51:39 <ion> It works in private, too.
16:51:52 <Vektorweg1> i had enough fun for now. ;)
16:51:57 <lyonsb> Hey, when you poke this thing, it does something weird.  *ten thousand pokes later* . . .
16:53:05 <broma0> Hello all.. I'm having some touble writing an appropriate type or typeclass to model a key/value store that could either be pure (in memory) or on disk.. Anyone care to read a short shpeal and help out?
16:56:29 <Vektorweg1> broma0: have take a look how Data.Map works? 
16:56:31 <Welkin> broma0: use Map
16:59:03 <broma0> Vektorweg1: Welkin: so for the pure model, I am using ReaderT and StateT around a web service with a Map as the primary data structure for storing values.. that part is easy. The part I am having trouble with is attempting to write one engine that works with an IO dataase (i.e. one where every insert is a writeFile and every fetch is a readFile) and the pure database I have. I'd rather not just make the pu
16:59:09 <broma0> re database IO for no reason and call it a day. Any thoughts?
17:00:08 <pavonia> Maybe have a look at acid-state
17:00:10 <Vektorweg1> broma0: when you try to define a minimal typeclass, you should take a look at `alter`, which combines all functionality of a map, i think. 
17:00:53 <Vektorweg1> then you add an IO the the result, so that it can be described by your file data.
17:01:36 <ion> Perhaps something like having instances use m = Identity or m = IO would work.
17:02:12 <epta> how to find in what module `^!` is defined? my hoogle-fu isn't enough
17:02:26 <arkeet> http://hoogle.haskell.org/?hoogle=%5E!
17:02:26 <ion> @hoogle (^!)
17:02:28 <lambdabot> No results found
17:02:28 <Welkin> epta: use hayoo
17:02:38 <ion> http://hoogle.haskell.org/?hoogle=(%5E!)
17:02:42 <Vektorweg1> :i Data.Map.alter
17:02:53 <Welkin> http://hayoo.fh-wedel.de/?query=^!
17:03:02 <Welkin> it is in Lens
17:03:06 <Vektorweg1> :t Data.Map.alter
17:03:09 <lambdabot> Ord k => (Maybe a -> Maybe a) -> k -> M.Map k a -> M.Map k a
17:03:32 <epta> Welkin: ion: thanks
17:03:58 <ajf> Hey, what's the equivalent of fmod in Haskell?
17:04:04 <ajf> Not mod nor rem, apparently
17:04:07 <arkeet> what's fmod?
17:04:13 <broma0> Vektorweg1: I'm not sure how the 'alter' function would solve the problem of one codebase for both "IO Database" and simply "Database"
17:04:16 <ajf> arkeet: modulus for a float
17:04:18 <ajf> C function
17:04:22 <ajf> *modulo
17:04:24 <geekosaur> it's hidden in Data.Fixed
17:04:25 <ion> mod' which is placed in the obvious place: Data.Fixed
17:04:27 <broma0> Vektorweg1: Maybe I am not understanding you correctly..
17:04:39 <ajf> ion, geekosaur: ah ok, thanks
17:05:15 <Vektorweg1> broma0: you need a typeclass. and for that typeclass, you better have a minimal definition of functions. this `alter` function has all functionality of a map.
17:07:39 <arkeet> why must a typeclass definition be minimal?
17:10:05 <ajf> I forgot, what's the function to group a list into lists of length n?
17:10:15 <broma0> ajf: partition?
17:10:20 <Vektorweg1> arkeet: habit. ;)
17:10:22 <pavonia> :t chunksOf
17:10:25 <lambdabot> Int -> [e] -> [[e]]
17:10:56 <broma0> Vektorweg1: I see (maybe..). If had some typeclass "Queryable" or something, wouldn't I have to specify the resulting type of the functions to be either IO blah or just blah?
17:10:59 <ajf> Ah, that's in data>List.Split
17:11:04 <ajf> I'll just reimplement it again
17:12:15 <Vektorweg1> broma0: you could add a another type variable to the class to specify another return type ...
17:12:18 <ion> > map (take 3) . takeWhile (not . null) . iterate (drop 3) $ [0..10]
17:12:22 <lambdabot>  [[0,1,2],[3,4,5],[6,7,8],[9,10]]
17:13:12 <ajf> how does that work
17:14:27 <ajf> Oh, the magic's in iterate
17:14:40 <ajf> Clever, that's shorter than what I wrote:
17:14:50 <ajf> chunksOf n xs = fxs : chunksOf n sxs
17:14:52 <ajf>     where (fxs, sxs) = splitAt n xs
17:15:00 <ajf> (plus handling [])
17:15:22 <broma0> Vektorweg1: This is one of those times where, after hearing the answer, you realize that the answer would have been so damn obvious after a little bit more practice. Thank you!
17:15:29 <ion> > let dropLast n = zipWith const <*> drop n in dropLast 3 . map (take 3) . tails $ [0..5]
17:15:32 <lambdabot>  [[0,1,2],[1,2,3],[2,3,4],[3,4,5]]
17:16:47 <broma0> What is the better practice... IO (Maybe String), or Maybe (IO String)? is there one? still learning..
17:17:02 <Vektorweg1> broma0: i hope it was the right answer. maybe there is a better solution. 
17:17:53 <broma0> Vektorweg1: I'll keep looking into it.. this makes me wonder if there is a way to implement that idea without having to use the multitypeclassparams extension
17:17:55 <ion> broma0: Depends on what you want. Those are very different things. The former is probably encountered more often.
17:19:55 <broma0> ion: In the case of reading a file that may not exist, are they not both acceptable? I simply change the type of the exception catching method and the main fn 
17:21:01 <arkeet> broma0: that cannot have type Maybe (IO String)
17:21:19 <arkeet> because you can tell whether such a value is Just or Nothing without executing any IO action.
17:21:35 <ion> broma0: To generate a Maybe (IO String) value based on whether a file exists, you need to know whether the file exists, so you need to be in IO. An IO action that is able to generate a value of that type would have the type IO (Maybe (IO String)).
17:23:12 <dedgrant> broma0: More generally: Think of where in the evaluation of your program you need to interact with IO. The former will always require evaluation of IO in order to yield a result, whereas the latter defers potential interaction with IO.
17:24:44 <broma0> The combination of those three explanations just opened my eyes to much more than just the question I asked
17:24:52 <broma0> nice.
17:24:55 <arkeet> :-)
17:27:06 <xj54y> Hello. Strange question but do any of you have a blog I may follow? It'd be nice to fully emmerse myself in Haskell and get all of that real-world fancy in order to prepare for work with Haskell (in the real world)
17:27:26 <xj54y> /me looks at Cale
17:27:46 <srhb> xj54y: If you follow the Haskell subreddit, you will often find blog posts from various very nice blogs there.
17:27:50 <broma0> How would one implement a typeclass with two type parameters without the MultiParamTypeClass extension?
17:27:55 <srhb> xj54y: Probably the best way to gradually find them all.
17:28:09 <Enigmagic> broma0: by adding the MultiParamTypeClass extension
17:28:11 <xj54y> srhb, that'll work very nicely. :-)
17:28:18 <ion> Enigmagic++
17:29:06 <broma0> Enigmagic: fine. 
17:29:13 <xj54y> srhb, oh, do you know if anyone actually hires haskell programmers? I intend to jump into core or at least play with other modules so that I can have some kind of lame public contribution profile, but.. meh
17:29:16 <arkeet> you can hack around it, but I think that requires other extensions.
17:29:27 <xj54y> I'd like to use haskell professionally from now on
17:29:39 <srhb> xj54y: You'll see job postings in there as well.
17:29:49 <xj54y> srhb, well sheesh.. :-D
17:29:55 <srhb> xj54y: :)
17:30:24 <srhb> xj54y: I really think it's an excellent way to get an overview of the community and ecosystem without getting overwhelmed with too much information at once.
17:30:53 <acowley> You can also hop on twitter if you want Haskell-themed general nonsense.
17:31:11 <acowley> There are a good number of a Haskellers to be found there spouting off witty one liners.
17:32:04 <ajf> So far, I seem to code slower in Haskell. But the code I write is better!
17:32:09 <broma0> arkeet: I'm somewhat new to haskell, and I definitely have a mentality of "avoid extensions unless its basically impossible to do what I want without them".. What are your thoughts on this mentality? Are there a subset of extensions are considered standard?
17:32:12 <Enigmagic> broma0: depending on what problem you're trying to solve there may be other options using flexible instances and/or type families
17:32:46 <Enigmagic> broma0: however mptc is a bit more conservative than either of those
17:32:47 <ion> For situations where you want FunctionalDependencies, associated type families may be a nice alternative.
17:33:09 <srhb> acowley: Needs number of operator per tweet per language stats. :P
17:34:20 <xj54y> srhb, planet.haskell.org is indeed like "whoa"
17:35:18 <acowley> Why worry so much about extensions? There are only a few that are risky, and a few others that aren't popular enough to not confuse readers.
17:36:06 <broma0> I'm a purist at heart
17:36:07 <arkeet> it's not that hard to confuse readers without any extensions :-)
17:36:30 <acowley> srhb: The twitter Haskell community has both sides of that covered. If you're okay with operators, you'll enjoy lens proponents marveling at its concision; if you're not, you'll enjoy lens opponents raging at its opacity!
17:36:46 <srhb> acowley: Either way I bet we'll win. :-)
17:36:51 <acowley> Exactly
17:37:25 <srhb> broma0: You will really not be using Haskell to its fullest potential if you avoid extensions. a lot of them are marvellous.
17:37:40 <acowley> broma0: You need to more purely embrace the future by enabling all language extensions and dancing on the bleeding edge of somewhat chaotic language design!
17:37:42 <ttt_fff> is there anything that is like a spreadsheet, but I (1) cells have types and (2) I can use haskell code in formulas ?
17:38:00 <srhb> ttt_fff: Typed spreadsheets sounds fun. Make it! :-)
17:38:14 <ttt_fff> srhb: main :: IO () // pls finish the rest
17:38:25 <ion> /
17:38:29 <ion> // even
17:38:31 <acowley> Haskell Philosophy: Once you've decided to push down the accelerator, push it all the way down.
17:38:32 <srhb> ttt_fff: Syntax error!
17:39:05 <broma0> srhb: so i've heard.. I guess ill let multiparamtypeclasses slide just this once
17:39:17 <srhb> ttt_fff: But no, I don't think there is. It would be really interesting though.
17:39:28 <ttt_fff> srhb: yeah, it'd be badass I think
17:39:36 <srhb> ttt_fff: I imagine it's fairly easy to do using hint.
17:39:48 <broma0> acowley: that's a little much for me! Anywhere I can find some stats on the most used ones? Just so I can convince myself its not THAT bad to use them 
17:39:50 <srhb> Well, as easy as hint is to use... :-)
17:39:51 <ttt_fff> I like the 'interactivity' of sptreadsheets, but I want cells to be typed, and I want to use haskell in cell formulas
17:39:58 <johnw> really the only extensions to avoid in the beginning all contain scary words, like impredicative, or incoherent
17:40:06 <acowley> bingo
17:40:24 <johnw> overlapping is bad too
17:40:27 <acowley> Overlapping is also a little iffy, and it's weird now
17:40:50 <acowley> weird = GHC 7.10.1 will scold you for not using it per-instance
17:40:58 <srhb> FunDeps, MultiParam, RankN, ... can all be considered pretty standard I think
17:41:02 <acowley> also, weird = far more complicated than it used to be
17:41:05 <srhb> In fact, a lot of the libraries we take for granted depend on those
17:41:15 <Enigmagic> johnw: i dunno, UndecidableInstances sounds a lot worse than it is
17:41:25 <johnw> I did say, "in the beginning" :)
17:41:41 <acowley> I wish people would just use my MetaPragma thing so we could have a de facto Haskell2015
17:41:52 <johnw> acowley: I agree
17:42:01 <johnw> i end up with 20+ extensions in my .cabal files usually
17:42:47 <acowley> Yeah, it's silly. And the way it is today doesn't give newcomers any signal about which are actually dangerous, so everyone has to come here to ask.
17:43:03 <johnw> or which _combinations_ are dangerous, even though individually they're fine
17:44:18 <srhb> acowley: No ViewPatterns? :|
17:45:18 <acowley> srhb: I don't know why that's not there
17:45:32 <acowley> srhb: I was probably trying to be conservative
17:45:35 <srhb> Ah. :)
17:45:36 <ion> acowley: No TupleSections?
17:45:44 <Vektorweg1> right. there aren't many good beginner ressources. but advanced ressources lack even more.
17:45:44 <ion> BangPatterns?
17:45:53 <acowley> PRs, people!
17:46:09 <acowley> These should all be in there
17:46:28 <srhb> OK, that's nice. I would definitely assume those to be in a Haskell2015 pragma.
17:46:47 <srhb> As well as pattern synonyms, probably.
17:46:48 * hackagebot clckwrks 0.23.8 - A secure, reliable content management system (CMS) and blogging platform  http://hackage.haskell.org/package/clckwrks-0.23.8 (JeremyShaw)
17:47:23 <acowley> I'd like it to catch on and use it as a way to sneak in NoImplicitPrelude so we can solve that problem as a side effect of curing the pragma infestation.
17:47:38 <srhb> :-)
17:48:01 <srhb> Glad you mentioned it, I didn't know this existed.
17:49:07 <acowley> It's not that commonly used for several for several reasons. One of them is that simple cases pick up two extra lines of boilerplate (the pragma and the import). The least we can do is help with that.
17:49:09 <dolio> Solve the problem where people don't import 8000 modules at the top of every file?
17:50:17 <srhb> Automatic, type directed imports! We just need a better module systems...
17:50:25 <acowley> I want to implicitly import 8000 modules so that minimalists can still have it their way, too.
17:50:27 <srhb> (That would be super scary)
17:50:59 <Fylwind> It'd also be nice if there was a way to export "submodules", so I could do import Foobar and get Foobar.Qux.something
17:51:36 <acowley> Improving import syntax would help with that a little bit
17:51:58 <Fylwind> I never quite understood why import (w/out qualified) does two separate things
17:52:11 <Fylwind> it brings them into scope AND also greates a qualified scope
17:52:18 <Fylwind> s/greates/creates/
17:52:48 <acowley> I've argued for something like "import Foo (blah, bleh) as F" to import blah and bleh unqualified, and F as an alias for Foo.
17:53:07 <acowley> I think Gershom had a proposal that was backwards compatible if slightly more verbose.
17:53:29 <Fylwind> also there's an aesthetic element to why I dislike qualified: it screws up alignment of the module names!
17:53:48 <dolio> Isn't that backwards compatible? It's illegal syntax right now, no?
17:53:48 <acowley> Yeah
17:53:49 <Fylwind> some people end up putting like 9 extra spaces just to line them up
17:53:58 <kadoban> Fylwind: I solve that by having snippets that line them up (everything else is indented with space for qualified)
17:54:07 <Fylwind> I usually end up shuffling them to the end
17:54:17 <acowley> dolio: I think you're right
17:54:44 <acowley> I just close my eyes when looking at import sections
17:54:51 <Fylwind> acowley: haha
17:56:21 <Fylwind> acowley: I think it would be nice to have that shorthand though
17:57:14 <Fylwind> very often I do something like "import Data.ByteString (ByteString)" followed by "import qualified Data.ByteString as Bytes"
17:57:19 <dolio> Renames might be nice, too.
17:57:36 <Fylwind> dolio: like, import Data.ByteString (ByteString as Bytes) ?
17:57:41 <dolio> Yes.
17:57:51 <Fylwind> that would be really awesome
17:57:56 <acowley> I guess I should try to write a patch, but I've still not gotten over the absolutely phabulous barrier to entry on GHC dev :(
17:58:16 <Fylwind> is phabricator that hard?
17:58:24 <acowley> It's just another thing
17:58:53 <KaneTW> acowley: is it? i didn't need long to write some ghc patches
17:59:20 <acowley> KaneTW: Please submit a patch allowing shorter import syntax!
17:59:46 <KaneTW> write a feature request on the ghc trac
17:59:49 <KaneTW> and i'll look into it
18:00:20 <acowley> I don't have a pun ready to make fun of trac
18:00:28 <acowley> Sorry
18:00:49 <KaneTW> i can't, either
18:00:52 <Fylwind> un-trac-table?
18:01:09 <acowley> That's settled, then. Fylwind: you write the patch.
18:01:32 <Fylwind> but it was your idea!
18:01:49 * hackagebot clckwrks-plugin-page 0.4.0 - support for CMS/Blogging in clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-page-0.4.0 (JeremyShaw)
18:02:25 <dolio> I think figuring out how to make GHC do imports differently is probably a lot more difficult than figuring out phabricator.
18:02:30 <dolio> You guys are being conned. :)
18:02:59 <Fylwind> yeah but it's largely a cosmetic change though
18:03:00 <Fylwind> aliases, however, is much harder
18:03:17 <Fylwind> by cosmetic -- I mean tweaking the grammar
18:04:03 <Fylwind> at least 'aliases' in the sense of treating the types/variables as identical things, not merely type synonyms
18:05:18 <Fylwind> in any case, acowley are you writing the ticket, or … ?
18:05:20 <acowley> I really just wanted to say "absolutely phabulous" as an AbFab call out, but my other issues are that building GHC takes hours for me, and running the test suite is not fast, either.
18:05:23 <acowley> I did
18:05:33 <acowley> https://ghc.haskell.org/trac/ghc/ticket/10478
18:06:04 <acowley> Oh
18:06:08 <acowley> actually one thing that's wrong there
18:06:28 <acowley> Now I remember the issue between Gershom's and my proposal
18:06:43 <acowley> We currently have the rarely used "import Foo as F" syntax
18:06:58 <acowley> distinct from "import qualified Foo as F"
18:07:19 <acowley> While I'd rather the former need be written as "import unqualifed Foo as F"
18:07:38 <Fylwind> yeah the import syntax is really flexible but in practice there's only about 2-3 that are useful
18:08:07 <dolio> Oh, right. That's not backwards compatible.
18:08:21 <dolio> Also, I'm not sure I believe it's rarely used.
18:08:22 <Fylwind> you could do something like: import Foo (..) as F as a shorthand for import qualified Foo as F, which is bc
18:08:32 <napping> import Foo qualified as F isn't currently used, is it?
18:09:38 <dolio> import Foo () as F would be the same under your proposal, though.
18:09:49 <dolio> Same as qualified.
18:10:15 <acowley> dolio: Under what circumstances do you use the existing "import Foo as F" syntax?
18:10:17 <Fylwind> oops I meant to say:  import Foo (..) as F == import Foo as F
18:10:40 <Fylwind> (never mind that's rather pointless)
18:10:47 <dolio> We use it a lot in the ermine code, because we import a bunch of stuff fully, and have to disambiguate things occasionally.
18:10:53 <napping> I'd just like a way to do a qualified import and also bring some explicitly specified names into scope
18:11:03 <Fylwind> ^
18:11:07 <dolio> And it's easier to disambiguate with 'Kind' than 'Ermine.Syntax.Kind'.
18:11:16 <acowley> dolio: I see, I've not seen it much, but I accept if some folks do use it.
18:11:50 <Fylwind> import Data.ByteString (ByteString) as B would be useful
18:11:51 <acowley> dolio: I always deal with those scenarios with explicit imports
18:12:16 <napping> Fylwind: you want that to mean a qualified import, right?
18:12:48 <dolio> Well, that's only going to work if you don't actually need both, or you pick one to be privileged.
18:12:49 <Maxdamantus> import Data.ByteString (ByteString); import qualified Data.ByteString as B
18:12:57 <Maxdamantus> presumably he wants it to be the same as that.
18:13:02 <Fylwind> napping: I'm using acowley's new semantics, where everything is qualified as B. but ByteString is unqualified
18:13:06 <Maxdamantus> which seems fairly neat.
18:13:16 <acowley> dolio: For common names, I use the qualification
18:13:39 <acowley> dolio: I'm saying, what I do is two import lines "import Foo (unique names); import qualified Foo as Foo"
18:14:34 <Fylwind> "<dolio> import Foo () as F would be the same under your proposal, though." I think that's actually a nice little perk, because it means we can avoid the annoying 'qualified' prefix in the new syntax
18:14:41 <acowley> But I've been trending to explicit import lists for a while, and I know there's not very widespread agreement on that.
18:14:56 <Fylwind> this way there's no need for editor hacks just to line up the imports properly
18:15:30 <dolio> Yes, it's nice. My point was that changing the meaning of 'import Foo as Bar' is only saving two letters at that point.
18:15:47 <acowley> Yeah, the aesthetics are better, and supporting the common case of Text, ByteString, Map, etc. seems like a good win.
18:16:05 <Fylwind> dolio: import Foo as Bar is not the same as import Foo () as Bar
18:16:27 <Fylwind> or maybe I don't understand what you mean by 'saving two letters'
18:16:44 <Fylwind> it's not necessarily an issue of saving letters, it's just "import qualified" screws up the alignment
18:17:06 <dolio> It is under his proposal that you have to write 'unqualified'.
18:17:13 <ajf> How come +3 and -3 work? is there a hack to make is simultaenously unary and binary?
18:17:19 <Fylwind> I'd rather not change semantics of existing code though
18:17:52 <dolio> Does +3 work?
18:17:58 <acowley> I didn't include the "unqualified" part in the feature request ticket, but I'm with Fylwind in that I'd rather it not mess up alignment.
18:18:10 <Maxdamantus> Just add a new keyword all together.
18:18:13 <Fylwind> +3 doesn't work
18:18:15 <Maxdamantus> open Foo as Bar
18:18:27 <acowley> Maxdamantus: Yeah, that's a way to not break things. I'm really chasing minimal syntax.
18:18:45 <Maxdamantus> Well, I suspect it'd break code that tries to use `open` as an identifier.
18:18:56 <Fylwind> open is not unlikely to be used, (open files,  etc)
18:19:14 <dolio> Fylwind: He said that 'import Foo as Bar' should be a qualified import. But under the proposal, 'import Foo () as Bar' is the exact same qualified import, and it's only two characters longer.
18:19:20 <dolio> And it doesn't mess up alignment.
18:19:47 <KaneTW> ajf: +3 doesn't work
18:19:49 <KaneTW> > +3
18:19:51 <lambdabot>  <hint>:1:1: parse error on input ‘+’
18:20:09 <KaneTW> -3 works because of how numbers are parsed
18:20:12 <acowley> Ah, so dolio is pointing out that while "import Foo as F" is currently legal, "import Foo() as F" is not.
18:20:34 <dolio> Right, it has the same backwards compatibility as the rest of the proposal.
18:20:45 <Welkin> import Foo as F doesn't qualify the import
18:20:54 <acowley> Welkin: That's the point 
18:21:04 <KaneTW> that's why '- 3' doesn't work 
18:21:05 <Welkin> you have all the functions of Foo in the normal namespace as well as in F.
18:21:16 <dolio> No, - 3 works.
18:21:20 <acowley> Welkin: I want to make qualified imports syntactically lighter and combine unqualified imports in one statement
18:21:23 <dolio> So does -(m + n).
18:21:33 <dolio> Or - m*n.
18:21:37 <ajf> drawStars stars (width, height) = mapM_ stars (\(Star (x, y) depth) -> fill $ do
18:21:39 <ajf>     let size = 3 * depth
18:21:41 <ajf>         (x', y') = (x * width, y * height)
18:21:43 <ajf>     rect (x' `both` (`subtract` depth / 2)) (y' `both` (`subtract` depth / 2)))
18:21:45 <ajf> Where's the syntax error?
18:21:47 <ajf> my eyes can't see it
18:22:15 <ajf> oh
18:22:19 <ajf> nevermind, misread haskell error
18:22:22 <KaneTW> dolio: huh, remembered wrong then
18:22:24 <ajf> issue on completely different line
18:22:36 <KaneTW> oh
18:22:39 <albeit> Is there a name for this? http://lpaste.net/133792 (Trying to run a State s a in a StateT s IO a)
18:22:43 <KaneTW> :t (-3)
18:22:46 <lambdabot> Num a => a
18:22:47 <KaneTW> :t (- 3)
18:22:49 <lambdabot> Num a => a
18:23:01 <KaneTW> i can't remember why i though that didn't work
18:23:10 <dolio> KaneTW: This trips people up sometimes. Because they write '-m `mod` n' which gets parsed as '-(m `mod` n)'.
18:23:17 <dolio> Because it uses arithmetic precedence.
18:23:28 <Welkin> :t (subtract 3)
18:23:29 <lambdabot> Num a => a -> a
18:23:33 <Welkin> :t ((-) 3)
18:23:34 <lambdabot> Num a => a -> a
18:23:47 <Welkin> :t (3-)
18:23:49 <lambdabot> Num a => a -> a
18:23:54 <acowley> dolio: Thanks for helping make that proposal crisper
18:24:22 <dolio> acowley: No problem. In that form I don't see any downsides, really.
18:24:36 <dolio> And I'd rather use () than qualified.
18:24:43 <Welkin> I think the existing qualified imports are good because they offer clarity
18:24:48 <acowley> Yeah I think it's great
18:24:52 <Welkin> it is explicit
18:25:05 <acowley> Welkin: It's also longer and messes up alignment, which bugs some people.
18:25:13 <acowley> Welkin: I think the proposal is just as explicit
18:25:44 <acowley> Welkin: the syntax is now "import ModuleName([unqualifiedNames]) [as QualifiedShortName]"
18:26:05 * Maxdamantus would've gone with what's suggested in the first place.
18:26:10 <acowley> Welkin: So you can always see what's imported unqualified, just as now, as whether or not there is an alias for qualified name references.
18:26:33 <acowley> s/as whether/and whether/
18:26:36 <Welkin> acowley: that is not qualified
18:26:51 * hackagebot geom2d 0.1.2.0 - package for geometry in euklidean 2d space  http://hackage.haskell.org/package/geom2d-0.1.2.0 (seppeljordan)
18:27:04 <acowley> Welkin: I don't understand what you're saying
18:27:21 <acowley> Welkin: We're talking about a proposal to define how to introduce qualified and unqualified names
18:27:41 <Welkin> oh
18:27:50 <Welkin> that is how you qualify an import in your proposal?
18:28:09 <acowley> Welkin: Actually, please take a look at the ticket and let me know if it's really confusing
18:28:16 <Welkin> but that is already existing syntax for importing a module using both unqualified and qualified names
18:28:33 <acowley> No it's not
18:28:47 <Welkin> import Foo (bar, baz, quux) as F
18:29:00 <Welkin> `F.bar` is the same as `bar`
18:30:12 <acowley> Welkin: I get a syntax error when I try to compile that
18:30:14 <arkeet> is that valid syntax right now?
18:30:17 <arkeet> yeah.
18:30:17 <acowley> well, a parse rror
18:30:19 <acowley> no it's not
18:30:24 <acowley> That's the point in the proposal
18:30:26 <arkeet> yeah.
18:30:30 <arkeet> just adding new syntax.
18:30:56 <acowley> Although Welkin did just scare me that I'd been annoyed by something for years when it was never actually a thing
18:31:03 <arkeet> and then import Foo () as F would be the same as import qualified Foo as F, right?
18:31:09 <acowley> arkeet: Yes!
18:31:19 <arkeet> I'm in favour.
18:31:44 <acowley> arkeet: Excellent! The ticket may need some support. I'll ping Austin, too.
18:31:58 <arkeet> I dunno if it's just me but I kinda like being able to alphabetically sort my import lists and qualified imports mess with that.
18:32:07 <acowley> arkeet: same
18:37:49 <Welkin> oh
18:37:51 <Welkin> I was wrong before
18:37:55 <Welkin> it is this
18:38:03 <Welkin> import Data.Char as C (chr)
18:38:15 <Welkin> that import *both* `chr` and `C.chr`
18:38:40 <Welkin> I don't use that syntax too often though
18:39:00 <arkeet> too bad it doesn't import anything else.
18:39:05 <Welkin> ?
18:39:11 <Welkin> you can import the whole module
18:39:17 <Welkin> import Data.Char as C
18:39:31 <Welkin> then you have all of Data.Char in the top-level namespace, as well as under C.
18:39:48 <arkeet> I'm talking about import Data.Char as C (chr)
18:40:05 <Welkin> what about it?
18:40:08 <Welkin> it was an example
18:40:17 <arkeet> sure
18:40:25 <arkeet> I'm just saying it's too bad that doesn't import anything else into C
18:40:48 <Welkin> what?
18:41:01 <Welkin> I don't understand what you eman
18:41:06 <Welkin> it only imports what you specify
18:41:08 <arkeet> I know.
18:41:19 <Welkin> or everything if you don't specify anything
18:42:14 <arkeet> I guess with acowley's thing it would be pretty easy to confuse import Foo (...) as F and import Foo as F (...)
18:42:59 <Welkin> I always forget if the list of imports comes before or after the "as F"
18:43:22 <arkeet> right, and it would be even worse if both of those were syntactically valid but did different things.
18:44:33 <Welkin> I'm not sure what the point of adding that new syantx would be
18:44:52 <Welkin> since you already get qualified imports using this existing syntax
18:44:59 <Welkin> although it is qualified *and* unqualified
18:46:50 <arkeet> I thought the idea was to have some way of importing certain things explicitly into the main namespace, but also the entire module qualified.
18:46:58 <arkeet> instead of having to write
18:47:05 <arkeet> import Data.Text (Text)
18:47:10 <arkeet> import qualified Data.Text as T
18:47:19 <Welkin> I often use that convention
18:47:26 <arkeet> sure.
18:47:28 <arkeet> but it's two lines.
18:47:49 <Welkin> I line up the two module names
18:47:53 <Welkin> and group them together
18:47:55 <arkeet> you could do that.
18:48:49 <arkeet> but it's still a lot of typing.
18:49:00 <pikajude> hi, can I disable Cabal 1.22 adding rpaths to all my dependent libraries when building an executable?
18:49:12 <pikajude> i have disable-executable-dynamic, so the rpaths are not needed
18:50:16 <pikajude> looking at the cabal source, nothing is jumping out at me
18:50:39 <pikajude> sorry, my question should read: "can I prevent Cabal 1.22 from adding an rpath to my executable for each library it depends on"
18:52:23 <bernalex> apparently I have become stupid from not programming a lot lately. either that or it's the fact that it's 4am and I last slept uh some days ago. but. anyway.
18:52:28 <ajf> Hey
18:52:39 <ajf> how can I specify the type in <- in a do block?
18:52:44 <ajf> I can't do foo <- bar
18:52:46 <ajf> foo :: Double
18:52:49 <ajf> what can I do?
18:53:05 <bernalex> I have this thing where I want to use the function I define in: http://lpaste.net/3899741961585688576 so I define a typeclass. does that typeclass make sense? how do instantiate it?
18:53:22 <ajf> I could do some abomination with fmap
18:53:25 <ajf> but that's evil...
18:53:26 <pikajude> ajf: let foo = bar
18:53:30 <pikajude> oh
18:53:32 <pikajude> wait, i misread
18:53:34 <pikajude> (foo :: Double) <- bar
18:53:38 <ajf> Can't do that
18:53:46 <ajf>     Illegal type signature: ‘Double’
18:53:48 <ajf>       Perhaps you intended to use ScopedTypeVariables
18:53:50 <ajf>     In a pattern type-signature
18:53:54 <pikajude> do you not want to use ScopedTypeVariables?
18:53:55 <ajf> Oh, the ()
18:54:05 <pikajude> no, you'll still need them
18:54:12 <ajf> Ah :/
18:54:25 <pikajude> alternatively, foo <- bar :: MyMonad Double
18:54:33 <ajf> Ahh!
18:54:39 <ajf> Why didn't I think of that! Of course.
18:55:02 <arkeet> or
18:55:30 <arkeet> oh never mind.
18:55:37 <srhb> pikajude: https://github.com/haskell/cabal/issues/2625 -- is this relevant?
18:55:39 <ajf> Oh, hmm
18:55:54 <ajf> I can't do that without specifying the full type of the function
18:55:55 <arkeet> an alternative is just to give a type annotation to foo when you use it somewhere else
18:55:58 <arkeet> not when you bind it
18:56:05 <ajf> you can't do (foo <- bar) :: IO Double
18:56:13 <arkeet> ?
18:56:18 <arkeet> foo <- bar :: IO Double 
18:56:19 <ajf> it'd be (foo <- bar) :: Qux -> IO Baz
18:56:36 <arkeet> ok, can you give a concrete example?
18:56:37 <ajf> So yeah I'll just give them types later
18:56:40 <ajf> er
18:56:52 <ajf> (width <- fmap read $ getAttr document "innerWidth") :: IO Double
18:56:58 <arkeet> that's not valid syntax.
18:56:59 <srhb> ajf: width <- ( ...
18:57:03 <ajf> exactly
18:57:07 <ajf> so I move the brackets
18:57:14 <arkeet> and then it should work.
18:57:16 <ajf> but the type of fmap ... isn't IO Double
18:57:28 <arkeet> it's not?
18:57:31 <arkeet> what is it?
18:57:32 <ajf> it's IO ... -> IO Double
18:57:44 <pikajude> srhb: yes
18:57:49 <pikajude> srhb: oh, that's very recent, ok
18:57:51 <pikajude> i'll use git cabal
18:57:53 <arkeet> no it's not.
18:57:56 <srhb> pikajude: :)
18:58:04 <ajf> oh no, I screwed up
18:58:06 <ajf> hmm
18:58:21 <ajf> argh, I keep not looking carefully at line numbers
18:58:25 <ajf> that actually worked, thanks
18:58:26 <arkeet> heh.
18:58:31 <arkeet> and you don't need any parentheses.
18:58:43 <arkeet> also, consider using
18:58:45 <arkeet> read <$> ...
18:58:48 <arkeet> instead of fmap read $ ...
18:59:04 <bernalex> hm. I'm being silly.
18:59:09 <arkeet> (also consider not using read at all)
19:00:05 <bernalex> OK so I have Foo and Bar. Foo = MkFoo {stuff :: Stuff, fooTimer :: Int}, and Bar = MkBar {otherStuff :: OtherStuff, barTimer :: Int}
19:00:25 <bernalex> except I also have Fu and Baz... and now I want to write a way to generically update the time on all of them
19:00:42 <bernalex> so I want a typeclass Timer, and then a function tick :: Timer a => a -> Maybe a
19:01:13 <bernalex> tick a = case time a of Nothing -> Just a; Just 0 -> Nothing; Just n -> [here I want to return the a, but with its time set to Just (n - 1).
19:01:15 <bernalex> any ideas?
19:01:44 <bernalex> I bet this is ridiculously straightforward, but I'm being tired and silly I guess.
19:01:55 <srhb> bernalex: Where'd the Maybe come from?
19:02:23 <bernalex> srhb: that's just in the return type of my convenience function tick. I want it to return Nothing if the timer is at 0.
19:02:31 <bernalex> srhb: oh you mean the previous one!
19:02:34 <bernalex> sorry
19:02:46 <bernalex> fooTimer, barTimer, etc, are Maybe Int -- not just Int
19:02:58 <srhb> Ah.
19:03:16 <srhb> Well then I guess the question is just what exactly do you mean by generically.
19:03:38 <bernalex> OK. I have fooTimer, barTimer, etc. then I could write e.g.
19:03:54 <srhb> Because class HasTimer a where tick :: a -> Maybe a seems quite simple.
19:04:09 <bernalex> updateFoo a = case fooTimer a of Nothing -> Just a; Just 0 -> Nothing; Just n -> Just a { fooTimer = Just $ n - 1 }
19:04:27 <bernalex> srhb: yes that's what I want. but my brain is too tired to figure it out haha
19:05:37 <bernalex> so for ^ you could just as well write updateBar or updateFu or updateBaz, which is stupid.
19:05:53 <bernalex> instead there should just be one tick that just works generically.
19:06:20 <srhb> The thing that is confusing me is whether you want the type class method to return the updated structure or just the new timer value
19:06:46 <bernalex> srhb: right! so what I really want is the function tick :: Timer a => a -> Maybe a
19:07:32 <srhb> bernalex: so instance HasTimer Foo where tick MkFoo { fooTimer = timer } = ... case matching and things
19:07:35 <srhb> ?
19:08:50 <bernalex> I'm not sure what that means. what's timer in there?
19:09:05 <srhb> bernalex: Just a name for the value of the fooTimer
19:09:27 <arkeet> that binds timer'
19:09:46 <bernalex> oh
19:09:58 <srhb> bernalex: Something like this, or did I misunderstand completely? http://lpaste.net/8885602687572246528
19:10:13 <arkeet> > case Sum 5 of Sum { getSum = a } -> a
19:10:15 <lambdabot>  5
19:11:05 <bernalex> srhb: you didn't really misunderstand what I want to do. however this doesn't actually solve what I was moaning about: needing to match on fooTimer and barTimer and fuTimer and blah
19:11:20 <srhb> bernalex: Oh, so you're saying you're duplicating code in the instances?
19:11:33 <srhb> bernalex: (Which yes, you are)
19:11:42 <bernalex> srhb: well how would you make it an instance of Bar? by boilerplating it
19:11:47 <arkeet> use lens :---)
19:11:55 <bernalex> arkeet: I'm very much considering it
19:12:04 <arkeet> it has some TH to do that boilerplate for you.
19:12:07 <bernalex> example code would convince me to consider it more strongly lol
19:12:24 <bernalex> I have used TH & lens to do HasStuff with Persistent in the past. it's quite nice.
19:12:31 <srhb> Indeed it is.
19:13:29 <kirill`> In Data.Complex, why are the instances defined as
19:13:29 <kirill`> insance RealFloat a => {Floating,Fractional} (Complex a)
19:13:29 <kirill`> i.e., why does it require the argument a to be RealFloat instead of, say, (Floating a, Fractional a)?
19:14:37 <mjrosenb> How is cabal's support for generating files at runtime?
19:14:52 <arkeet> kirill`: it's needed for Num because of abs.
19:14:53 <srhb> kirill`: I'm guessing it's using the methods from RealFrac?
19:14:58 <srhb> Oh.
19:15:22 <arkeet> wait.
19:15:42 <arkeet> that part needs Floating.
19:15:48 <arkeet> not sure about the rest of RealFloat
19:16:22 <kirill`> Most of RealFloat is about decomposing floats into mantissa, exponent and so on, which isn't necessary at all for Floating/Fractional Complex
19:16:47 <arkeet> well it uses scaleFloat in its implementation.
19:16:57 <arkeet> and exponent
19:17:04 <arkeet> in the implementation of magnitude
19:17:47 <srhb> Yeah what I said was a lie. It doesn't use any RealFrac things.
19:18:09 <arkeet> look at the source of magnitude (which abs uses)
19:18:24 <srhb> Also phase uses atan2
19:18:28 <srhb> So it's just those three methods.
19:18:34 <arkeet> but phase isn't needed for Num or anything.
19:18:41 <srhb> True.
19:18:58 <arkeet> anyway, I guess magnitude uses it to not overflow with very large numbers.
19:19:17 <arkeet> > sqrt (1e300^2 + 1e300^2) :: Double
19:19:19 <lambdabot>  Infinity
19:19:24 <arkeet> > magnitude (1e300 :+ 1e300) :: Double
19:19:26 <lambdabot>  1.4142135623730952e300
19:19:26 <kirill`> arkeet: Yes, I see that now. I can't believe scaleFloat is faster than multiplication for Float/Double
19:19:35 <arkeet> I doubt it is.
19:19:48 <arkeet> I suspect it's for correctness with large/small numbers.
19:19:54 <kirill`> srhb: atan2 seems like it belongs in Floating with atan
19:20:08 <arkeet> because see what I just wrote.
19:20:33 <kirill`> arkeet: You can get under/overflow protection in magnitude without scaleFloat, just with (*) and (/)
19:20:45 <arkeet> show me.
19:20:54 <mniip> arkeet, take the pythagoras and move x^2 out of the root
19:21:04 <arkeet> ?
19:21:17 <arkeet> show me. with code.
19:21:59 <mniip> sqrt(x^2+y^2) -> x*sqrt(1+(y/x)^2)
19:22:19 <arkeet> ok, now say y is very large and x is very small.
19:22:57 <arkeet> > let { x = 1e-300; y = 1e300 } in x*sqrt(1+(y/x)^2)
19:22:59 <lambdabot>  Infinity
19:23:06 <kirill`> mniip: No, you take max(abs(x),abs(y)) out of the square root
19:23:15 <arkeet> ok, now you need Ord.
19:23:36 <kirill`> arkeet: Real numbers have Ord
19:23:41 <arkeet> they also have RealFrac.
19:23:55 <arkeet> er, RealFloat.
19:24:06 <arkeet> you're trading one constraint for another.
19:26:11 <arkeet> apparently this is a thing. https://hackage.haskell.org/package/numeric-extras-0.0.3/docs/Numeric-Extras.html
19:26:54 * hackagebot ircbot 0.6.4 - A library for writing irc bots  http://hackage.haskell.org/package/ircbot-0.6.4 (JeremyShaw)
19:26:56 * hackagebot clckwrks-plugin-ircbot 0.6.14 - ircbot plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-ircbot-0.6.14 (JeremyShaw)
19:27:08 <arkeet> it would be nice if Floating just had those built in.
19:28:21 <arkeet> anyway, I'm sure using scaleFloat is faster than your thing.
19:28:29 <arkeet> well, I'd guess.
19:28:45 <arkeet> because it doesn't have to do any serious division, just changing the exponent.
19:28:52 <kirill`> arkeet: For forward-mode automatic differentiation it's useful to have pairs (x, y) that represent Taylor series \t -> x + y * t (where t is small). Those behave as real number fr almost everything, except that they can't quite be decomposed as ordinary floats can be.
19:29:31 <arkeet> ah, and now you want to apply Complex to that.
19:29:39 <kirill`> arkeet: I wouldn't be so sure. With a recent CPU multiplication is really cheap, but decomposition/composition can take multiple instructions
19:29:54 <arkeet> guesses can be wrong.
19:29:58 <kirill`> I'm not saying it's definitely slower/faster, just that it's not clear
19:30:39 <kirill`> Yes, I wanted Complex of real numbers that carry extra information.
19:31:11 <arkeet> any reason you can't just use pairs of complex numbers?
19:31:47 <arkeet> that seems more natural to me at least.
19:35:01 <kirill`> If you apply (:+) to two Taylor series you get Complex (Taylor a), not Taylor (Complex a)
19:36:55 * hackagebot index-core 1.0.2 - Indexed Types  http://hackage.haskell.org/package/index-core-1.0.2 (GabrielGonzalez)
19:42:48 <athan> Hey everyone. Is there a constraint solver implemented in Haskell / FP?
19:44:30 <c_wraith> someone posted a toy constraint solver implementation in the last couple days..
19:45:25 <c_wraith> @hackage toysolver
19:45:25 <lambdabot> http://hackage.haskell.org/package/toysolver
19:45:39 <c_wraith> I don't know if it's particularly suitable for anything, but it is a haskell implementation!
19:46:12 <pikajude> can i make cabal install only executables, not libraries
19:47:04 <ajf> in a 4 spaces indented list, do lines begin with " ,  " or "  , "
19:48:04 <johnw> is there any literature showing that GHC can optimize the non-recursive evaluator functions used with fixed-points of functors better than it can for direct recursion?
19:48:17 <sm> pikajude: if you're in the source dir, cabal install exe:EXENAME works
19:48:29 <pikajude> i see
19:48:31 <sm> I think
19:48:33 <noodles1> quit
19:49:14 <sm> but now I'm thinking, not really, except by installing into a sandbox and copynig the binaries out
19:49:30 <sm> let us know
19:51:56 * hackagebot foldl 1.0.11 - Composable, streaming, and efficient left folds  http://hackage.haskell.org/package/foldl-1.0.11 (GabrielGonzalez)
19:54:39 <tombert1> Hello!
19:54:45 <tombert1> I need a tad bit of help
19:55:01 <tombert1> does anyone here know of a good tutorial on the SDL2 bindings for haskell?
19:55:23 <tombert1> I would prefer to use SDL2, and I noticed that hsSDL2 has been deprecated
19:55:33 <tombert1> but I"m having a bit of trouble finding example code
19:55:59 <augur> The purpose of computers is to abstract, the purpose of computation is to make obvious.
19:56:19 <augur> good little quip
19:56:28 <augur> shame that "obviation" doesnt mean "make obvious" :(
19:59:13 <darryn> Does haskell have good multi-platform support?
19:59:25 <tombert1> depends
19:59:39 <tombert1> right now the haskell platform's "base" doesn't have higher than 4.7
19:59:49 <tombert1> meaning you have to manually import control.applicative
19:59:56 <ajf> tombert1: I think darryn meant OSes?
20:00:05 <ajf> not like the Haskell Platform
20:00:11 <tombert1> sorry, forgot to mention "for windows"
20:00:15 <tombert1> the haskell platform for windows
20:00:19 <ajf> Ahh
20:00:25 <tombert1> that's my bad
20:00:31 <ajf> Haskell's cross-platform support is generally quite good, isn't it?
20:00:37 <tombert1> yeah, for the most part
20:00:52 <tombert1> the biggest change in that base was that monads became an instance of applicatie
20:01:08 <c_wraith> windows is kind of second-class, especially when native bindings get involved
20:01:34 <tombert1> yeah; I've found that the OpenGL GLUT stuff works pretty well on everything though
20:01:55 <tombert1> well, as well as GLUT ever works
20:02:22 <darryn> I am trying to decide between haskell and ocaml
20:02:32 <darryn> I know neither
20:02:39 <tombert1> Oh, Haskell will almost definitely be easier to port to windows
20:02:57 <tombert1> I'm not sure I've ever successfuly gotten ocaml to work properly on windows
20:03:12 <tombert1> Ocaml is pretty cool though; it's fun for servers
20:04:00 <mjrosenb> tombert1: how is ocaml more fun than haskell for servers?
20:04:31 <tombert1> the ocsigen framework in particular
20:04:43 <darryn> Would I be missing anything if I chose one over the other?
20:05:09 <tombert1> well, that's kind of a religious question ;)
20:05:25 <ajf> Haskell is pure!
20:05:27 <ajf> and better!
20:05:31 <tombert1> it's lazy!
20:05:35 <ajf> oh yes
20:05:40 <Clint> amen
20:05:40 <ajf> that sounds bad, maybe, but it's not
20:05:42 <tombert1> a lot of people like ocaml better because it's not lazy
20:05:46 <darryn> I am not sure default laziness is pratical
20:05:51 <ajf> Laziness means you can do useful things
20:05:56 <tombert1> but the laziness is better
20:06:03 <tombert1> you can do infinite lists!
20:06:11 <ajf> (it also means your code runs slower when compiled to JavaScript, whi-*knocked out*
20:06:30 <tombert1> ajf: Shhhhhhh!
20:06:32 <ajf> er, I mean, laziness is always good!@
20:07:00 <darryn> I still struggle with the fact that haskell does not have any *camels*....
20:07:25 <Ralith> that one keeps me up at night
20:07:29 <ajf> darryn: Perl is the last thing I want Haskell to be like
20:07:41 <ajf> *rimshot*
20:07:41 <Ralith> we try to make do with camel *case*, but it's just not the same...
20:08:36 <tombert1> in seriousness, haskell has a bit of a higher value on purity; they're similar enough languages to where you really can't go wrong with either
20:09:03 <tombert1> from the few benchmarks I've done, ocaml is *slightly* faster, but barely
20:09:12 <ajf> Using a pure language forces you to learn how to do things the pure way
20:09:12 <srhb> >>= -> ^^o -- camelBind
20:09:32 <ajf> Whereas in an impure language you can get away with doing them the non-pure way. Heck, that's probably the way you usually do them?
20:09:39 * ajf hasn't used OCaml...
20:09:53 <tombert1> well, I mean, ocaml has monads and all that stuff
20:10:10 <srhb> tombert1: Monads are very unimpressive without type classes.
20:10:17 <srhb> tombert1: Every language has them, then.
20:10:51 <Cale> darryn: You get much more value out of laziness when it is the default, because it's a property which is relatively fragile, and if it's not the default, your libraries tend to be full of things which are too strict to use.
20:11:33 <tombert1> Also, does anyone here have any experience with the SDL2 bindings for haskell?
20:11:53 <tombert1> and could link me to good example code and/or tutorial
20:11:57 <darryn> checkmate
20:13:03 <mjrosenb> tombert1: I've been using them, the git page has lazyfoo, and *bear*'s tutorials ported to haskell.
20:13:54 <mjrosenb> @hoogle IO a -> IO b -> IO (a,b)
20:13:56 <lambdabot> Data.ByteString.Builder.Prim (>*<) :: Monoidal f => f a -> f b -> f (a, b)
20:13:56 <lambdabot> Data.Generics.Twins gmapAccumT :: Data d => (forall e. Data e => a -> e -> (a, e)) -> a -> d -> (a, d)
20:13:56 <lambdabot> Data.ByteString.Lazy mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
20:14:14 <Cale> The main place where you want strict evaluation in your program are the places where you're taking many separately-evaluatable pieces of data (a "large" structure in some sense) and somehow summarizing them into something with few separately-evaluatable parts (something "small").
20:14:26 <c_wraith> mjrosenb: do you see things like displaying a frame that's already been drawn taking as much as 20ms, or is that just the side effect of vmware?
20:14:37 <Cale> For all other cases, laziness is either equally good to strictness, or better.
20:14:47 <mjrosenb> (>*<) looks like what I want, but.... why on earth is that in ByteString?
20:15:03 <mjrosenb> c_wraith: I have not measured yet, not that far along yet :-/
20:15:13 <tombert1> mjrosenb: I didn't see the 'examples' folder in the sdl2 repo. I feel silly!  I'll work my way through lazyfoo
20:15:15 <c_wraith> mjrosenb: hah.  measuring is where I started.
20:15:20 <darryn> I'll learn haskell then..
20:15:42 <srhb> darryn: Mind, this channel will probably always recommend Haskell. :-)
20:15:53 <Pip> Sure
20:15:58 <srhb> darryn: Go to #ocaml and ask why we're shit.
20:15:59 <c_wraith> Then got discouraged when a simple display operation takes longer than I can afford to allocate to an entire frame..
20:16:00 <srhb> :P
20:16:02 <darryn> Ya, but I really need cross-platform support
20:16:12 <Pip> Haskell is created by some super smart people 
20:16:17 <darryn> I have been on 
20:16:20 <darryn> Ocaml
20:16:48 <mjrosenb> c_wraith: so far, I've mostly written a bunch of reactive-banana bindings for sdl2
20:16:52 <mathu> http://lpaste.net/133797 what's wrong with this? parse error in pattern _ on line 7. i do not care which sort of InnerType i get in my function, so why may i not use _?
20:16:55 <mjrosenb> c_wraith: and something resembling a toolkit.
20:17:35 <srhb> mathu: You can't elide a value constructor without eliding the entire value
20:18:17 <mathu> srhb: i want to elide that entire value
20:18:24 <srhb> mathu: Also I'm not at all sure what you're trying to do. :P
20:18:33 <mjrosenb> mathu: did you want data OuterValue = Val InnerValue Int String?
20:18:42 <tombert1> darryn: After all I said, I will say I prefer haskell
20:18:49 <mjrosenb> mathu: then (Val _ num _)
20:19:04 <tombert1> darryn: it's a better language overall; there really isn't anything Ocaml does that Haskell really can't do
20:19:14 <mathu> mjrosenb: yes, oh. haha
20:21:16 <darryn> I'll probably just learn both
20:21:52 <c_wraith> tombert: that's not completely true.  OCaml's got some neat tricks like polymorphic variants (open sum types), row polymorphism, and parameterized modules that Haskell doesn't really have clean matches for.
20:23:40 <mjrosenb> ooh, I wonder if ocaml has disjunctive patterns
20:26:02 <solatis> guys, hackage being behind with docs generation is getting ridiculous..
20:26:50 <solatis> core packages like http://hackage.haskell.org/package/binary have no docs for 4 days already
20:27:47 <geekosaur> the builders are reportedly bhind and catching up slowly after a glitch
20:27:55 <geekosaur> (ask in #haskell-infrastructure)
20:28:02 <geekosaur> *behind
20:28:11 <solatis> i know, i already did 4 days ago :)
20:28:18 <solatis> https://status.haskell.org/ also says that
20:28:54 <tombert1> c_wraith: doesn't GHC have an extension for row polymorphism?
20:32:28 <bananagram> hptool in haskell platform 2014.02 won't compile for me: http://lpaste.net/2715801631936479232
20:33:36 <bananagram> building from source
20:35:18 <OutlawStar> So I asked this question earlier and would like to know if any one else has any thoughts on this. I would also like to know if I am just doing something fundamentally wrong (still new to haskell). I'm getting a deduce error (line 4) and I'm trying to figure out if what I am doing is possible. Basically I'm trying to get the compilier to infer one type from the use of another through fundeps. Can someone possibly take a quick look 
20:35:18 <OutlawStar> (its a short snippet) http://lpaste.net/7501987812208541696 
20:35:44 <OutlawStar> i basically want the ability to swap out different clients.
20:39:03 <augur> hmm
20:39:09 <albeit_> Do lens' stateful functions work in a RWS monad?
20:39:16 <augur> with a chip-level LC evaluator, you can garbage collect as you perform beta reductions
20:39:19 <augur> how interesting!
20:39:39 <bananagram> OutlawStar, shouldn't those definitions use m rather than IO?
20:39:49 <augur> shame there's so much pointer bouncing
20:40:41 <OutlawStar> banangram: mm well the idea was that if I didn't use m, I wouldn't need a disconnect state for 'm' and therefore wouldn't need to check for disconnect on any methods that use 'm'
20:40:53 <OutlawStar> is that a bad idea?
20:41:03 <Axman6> albeit_: Yep, they work in any monad which implements MonadState
20:42:18 <Axman6> which includes RWS(T)
20:42:21 <tombert1> mjrosenb: I'm getting an error telling me that it can't find the module SDL when trying to compile the lazyfoo tutorial
20:42:33 <tombert1> any ideas to why that might be an issue
20:42:49 <bananagram> OutlawStar: I don't know, I just don't see how you could go from m to IO, like if m was a monad transformer with IO and you can't know how to reduce the transformer to IO
20:43:02 <albeit_> Thanks Axman6 
20:43:07 <bananagram> like in runClient
20:43:08 <mjrosenb> tombert1: how are you building it?
20:43:09 <xj54y> heyj, after running `cabal install directory cabal cabal-install` I get the follow: http://paste.debian.net/196248/ 
20:43:24 <xj54y> I've tried resolving this a few hours ago, however, no success
20:43:29 <mjrosenb> tombert1: you probably want to build it with cabal-install (program is called cabal)
20:43:37 <OutlawStar> bananagram: m is an instance of MonadIO, which uses a transformer that has IO
20:43:59 <tombert1> I added it as a build dep in my .cabal file
20:43:59 <OutlawStar> err well m will have a transformer with io in it
20:44:03 <tombert1> then typed cabal install
20:44:46 <tombert1> I added `sdl2` to my build deps
20:45:12 <OutlawStar> bananagram: I guess maybe just remove login and logout from the contract and all my problems go away?
20:46:06 <tombert1> mjrosenb: is there something else I have to do with cabal?
20:46:06 <bananagram> functional depencencies are out of my scope
20:46:33 <mjrosenb> tombert1: in the git checkout, cabal build should do it.
20:48:14 <tombert1> mjrosenb: how do you mean? are you saying declaring it in the build-depends isn't enough?
20:48:33 <mjrosenb> tombert1: can you build it within the sdl2 repository?
20:48:45 <mjrosenb> tombert1: if you can't do that, then you should investigate that.
20:50:28 <tombert1> Hmm, I think the issue is that there was some kind of API change
20:50:44 <tombert1> looks like they renamed the module from Graphics.UI.SDL to just SDL
20:51:44 <mjrosenb> tombert1: yes, the examples in the github repo should be up to date.
20:53:17 <tombert1> well that's the issue
20:53:28 <tombert1> if you do cabal install sdl2, it pulls in 1.3.0
20:53:47 <tombert1> but the examples are showing the stuff for 1.3.1
20:53:51 <tombert1> ok, cool, I can work around that
20:54:15 <tombert1> I wonder how long before hackage gets the proper update
20:55:31 <mjrosenb> Is there an IO Map?
20:56:13 <tombert1> I don't know what that means
20:56:34 <mjrosenb> tombert1: that is not a question for you.
21:00:07 <srhb> mjrosenb: hashtables, judy..
21:00:32 <srhb> mjrosenb: Or just sticking it in an IORef. :)
21:03:51 <mjrosenb> srhb: right, but since it'll be in an IO already, there is no point in limiting myself :-p
21:18:51 <albeit_> Can I use typeclasses inside a type definition? LIke, "type Foo r s = Bar s => RWS r Set s"?
21:21:37 <ReinH> albeit_: did you try it?
21:21:41 <napping> Is there any better way to match against a value in scope than ((==v)->True)?
21:22:31 <albeit_> ReinH: I'm actually not at a computer with GHC... just looking over some code
21:22:44 <albeit_> But I'm guessing that means it works ;)
21:23:56 <napping> The scoping isn't right to make a pattern synonym from that
21:24:49 <hemite_> I'm trying to create a type synonym, I think
21:25:00 <hemite_> I want a Coin type, that's the same as bool
21:25:09 <hemite_> except true is Heads, and false is tails
21:25:13 <hemite_> is that possible?
21:25:38 <nocturne777> when is it a good idea not yo use GeneralizedNewtypeDeriving? I see in the RWH book - to avoid boilerplate code -   the author is capturing its monad stack in a newtype and letting the newtype derive Monad, MonadIO, MonadReader,  etc.
21:26:42 <kadoban> hemite_: That kind of depends what you mean? It seems like it'll be clearer if you make it an actual type.   data Flip = Heads | Tails
21:27:02 * hackagebot metrics 0.3.0.1 - High-performance application metric tracking  http://hackage.haskell.org/package/metrics-0.3.0.1 (IanDuncan)
21:27:27 <hemite_> kadoban, Well I just want to make the code clear, something like if tails
21:27:33 <hemite_> Maybe I'm not thinking this through 
21:41:04 <tombert1> Hey, anyone here able to help me here
21:41:14 <tombert1> if I want to include a dependency that isn't on hackage
21:41:23 <tombert1> as in, just a generic git repo
21:41:30 <tombert1> how would I go about including that in my cabal file?
21:41:47 <napping> In the cabal file, it's still by package name
21:42:06 <napping> It's only trouble when you go to build it
21:42:15 <tombert1> well, yeah, that's what I need to do
21:42:34 <napping> So you already have it in your cabal file?
21:42:45 <tombert1> well, I'm not necessarily married to it being in the cabal file
21:42:58 <tombert1> just somehow getting an external library included in my build
21:43:05 <napping> Like any other dependency, you need to list the package name as a depency
21:43:13 <tombert1> but it's not on hackage
21:43:15 <tombert1> that's my piont
21:43:16 <napping> in build-depends
21:43:24 <napping> that has nothing to do with the .cabal file
21:43:53 <tombert1> I think I'm not explaining this very well
21:43:58 <tombert1> I want to include said library
21:44:02 <tombert1> where do I put said library
21:44:08 <tombert1> the basic repo
21:44:17 <meiji11> is there a way to programmatically load information from a locally installed cabal package in a haskell program at runtime?
21:44:38 <tombert1> if I put the library name in my .cabal build-depends, I get an error saying it cant be found
21:44:59 <napping> well, you need it in the build-depends anyway, otherwise the build will end up failing
21:45:02 <napping> you can install it yourself
21:45:08 <tombert1> well tht's what I'm asking
21:45:11 <tombert1> how do I install it
21:45:22 <napping> go into that source directory and run cabal install, probably
21:45:35 <tombert1> that makes sense
21:45:42 <tombert1> but then how does that work with a sandbox
21:45:48 <napping> if you're using sandboxes, add-source is exactly what you want
21:46:03 <tombert1> I'll try that
21:46:07 <napping> it's even nicer than installing by hand, because it will fit into the automatic dependency calculation
21:46:21 <napping> cabal help sandbox explains it pretty nicely
21:46:41 <napping> but basically, cabal sandbox add-source path/to/git/checkout
21:46:53 <napping> and then if it's listed in build-depends stuff should automatically work
21:51:25 <sclv> signal boosting the call for help on the haskell platform website: http://www.reddit.com/r/haskell/comments/38br54/help_wanted_for_haskell_platform_website/
21:54:04 <albeit_> Is "foo :: BarClass a => Bar a -> Baz" equivalent to "type MyBar a = BarClass a => Bar a; foo :: MyBar -> Baz"?
21:54:29 <lpaste> nocturne777 pasted “bad style” at http://lpaste.net/133805
21:54:31 <albeit_> (Assuming foo is defined right below...)
21:55:14 <nocturne777> I saw a similiar example in the RWH book, but do you guys also think that the use of guards in that snippet is bad style?
21:55:50 <kadoban> nocturne777: That seems quite needlessly verbose
21:56:12 <nocturne777> kadoban: the example is contrived
21:56:12 <Cale> nocturne777: badFunc = True  would be better style, but I don't really know what you're asking :)
21:56:20 <kadoban> Oh I see the part you're asking about
21:56:38 <nocturne777> what I am talking about is the part with the "|" guards
21:56:39 <Cale> nocturne777: There's no problem with using guards inside case, the language allows it for a reason
21:57:17 <Cale> On the other hand, any conditional whose result is a Bool can probably be rewritten more succinctly
21:57:26 <nocturne777> I've most of the time seen guards used at the beginning of function definitions, that's why this seemed a bit awkard to me
21:57:40 <Cale> In this case, you could just have written  case z of (Just a) -> odd a
21:57:51 <Cale> (but yeah, also probably not what you're referring to?)
21:58:10 <nocturne777> well, I saw the actual use of the guard here: https://github.com/cyga/real-world-haskell/blob/master/ch19/ParseInt.hs
21:58:27 <Cale> Yeah, nothing wrong with the guards there
21:58:36 <nocturne777> I did not want to obscure the point by having ppl look at that file :)
21:59:26 <nocturne777> Cale: guards are followed by "=", but in this case it is followed by "->"
21:59:29 <Cale> It's sort of nice in that it sort of aligns the error cases at the same level
21:59:37 <Cale> Yes, that's how the syntax for case works
21:59:44 <Cale> Because you're not writing an equation
22:01:04 <Cale> When you write  f x | p x = y, it's essentially saying that when p x holds (and none of any previous matches succeeded), that f x = y
22:01:36 <Cale> But in this case, you're talking about the unnamed result of the expression, and so have nothing to equate to the right hand side
22:02:22 <Cale> So they just went with -> as the bit of punctuation to go between the pattern/guard and result of the case expression.
22:03:53 <nocturne777> in this case, it certainly looks more concise than the equivalent "if then .. else "
22:04:03 <Cale> Yep
22:04:53 <nocturne777> are there any other places where guards are used besides at the beginning of functions and inside case expressions ?
22:05:09 <Cale> In fact, some people have even suggested that if/then/else shouldn't even be in the language. I'm not sure I'd go that far, but case expressions and guards definitely win in any instance where you have more than one condition to try.
22:05:21 <joneshf-laptop> how can i simplify the `build-depends` section of a cabal file? I seem to be repeating everything multiple times.
22:05:43 <joneshf-laptop> like i see lens' cabal file has things like: https://github.com/ekmett/lens/blob/master/lens.cabal#L324
22:05:45 <Cale> nocturne777: The booleans which occur in list comprehensions are referred to as guards
22:05:52 <Cale> like:
22:06:08 <nocturne777> yeap, I know that syntatic sugar
22:06:11 <Cale> > [(x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2]
22:06:15 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
22:06:31 <joneshf-laptop> or do i actually have to repeat the full list of packages in `build-depends` each time?
22:08:06 <kadoban> joneshf-laptop: You have to repeat the parts you directly use in each part, I believe. The parts you only indirectly use though … you can just make the executable sections depend on the library
22:09:19 <xj54y> Okay, I'm starting to become a bit flustered.. Since debians' repo stocks an older version of GHC and Haskell-Platform, supposedly I'm unable to update cabal outside of this dependency crisis. Removing all of that, I've grabbed the source for haskell-platform, which requires ghc, which naturally requires ghc. Now, granted there's no 23bit build of haskell-platform available, I'm kind of stuck. Any ideas? :(
22:09:58 <xj54y> err, 32bit, not 23bit.. **
22:10:02 <mspo> xj54y: welcome to hell
22:10:32 <mspo> xj54y: I think you can use your old version to build the next and then the next and then the next and so on
22:10:43 <kadoban> xj54y: Don't bother with platform, just install GHC and cabal, use cabal sandboxes and manually install what you need. There's instruction on … some page I'll link to, sec.
22:10:47 <mspo> [6.4.2, 6.4.3, ...]
22:10:56 <napping> xj54y: you should probably use a binary build of GHC
22:11:02 <xj54y> mspo, I thought so to, but then I run into the exact original problem I had. So, there's not much that can be done.
22:11:13 <napping> xj54y: from here: https://www.haskell.org/ghc/download_ghc_7_10_1
22:11:16 <mspo> xj54y: you don't have an original 32bit to bootstrap?
22:11:30 <napping> there's a 32-bit linux build
22:11:50 <kadoban> xj54y: (nevermind on the link, I thought it had debian instructions, but looks like only ubuntu). Yeah just install a GHC binary and cabal and go from there.
22:11:51 <napping> "made on a Debian 7 "wheezey" system"
22:12:37 <xj54y> mspo, I do. However, it's 2012.. Now, building anything (or just doing a cabal install cabal-install) resolves in complete nonsense of the variety listed here http://paste.debian.net/196332/   
22:13:27 <xj54y> napping, kadoban, mspo: http://paste.debian.net/196332/ 
22:13:28 <mspo> xj54y: let me know how it goes.  I'm trying to get the netbsd packages up to date and am in a similar (but probably worse) boat
22:13:42 <napping> xj54y: what are you trying to do there?
22:14:12 <xj54y> napping, oddly enough, simply cabal install cabal-install
22:14:25 <napping> sounds pretty broken
22:14:30 <napping> are you replacing the GHC?
22:14:39 <kadoban> xj54y: I would assume that's trying with the stuff I recommended not using? Uninstall that stuff and do https://gist.github.com/ion1/2815423 something like that
22:14:44 <napping> The other link you need to install from scratch is this: https://www.haskell.org/cabal/download.html
22:15:11 <napping> those look like reasonable instructions
22:15:44 <napping> Step 1 of the purge instructions is a good idea after removing the apt-get versions of ghc and cabal-install
22:15:51 <xj54y> napping, I've actually removed every trace of haskell from the system and downloaded source files.. Ended up having to grab the old GHC binary, so to build platform, I must satisfy dependencies (e.g., `cabal install --only-dependencies`) and the result is as posted
22:16:13 <napping> What do you mean "grab the old GHC binary"?
22:16:16 <kadoban> xj54y: Don't use platfrom. /only/ GHC and cabal
22:16:22 <xj54y> napping, apt-get install ghc
22:16:26 <napping> oh, don't do that
22:16:33 <napping> use the binary from https://www.haskell.org/ghc/download_ghc_7_10_1
22:16:50 <napping> (or find neighboring pages for an older version if you like)
22:16:52 <xj54y> "For most users, we recommend installing the Haskell Platform instead of GHC. The current Haskell Platform release includes a recent GHC release as well as some other tools (such as cabal), and a larger set of libraries that are known to work together."
22:17:12 <kadoban> xj54y: Well, how's that advice working out for you so far?
22:17:22 <xj54y> Well, I've mixed feelings about it.
22:17:29 <Guest27204> great
22:17:47 <mspo> if you can run a newish binary release you're in good shape I think
22:18:08 <napping> xj54y: even if you want to try to build from source, you'll need a working GHC first
22:18:18 <xj54y> kadoban, mspo, napping: I'll go ahead and try this route out. Sorry for the bother.
22:18:46 <kadoban> No need to apologize. I hope it works out. I know it took me a while to figure out a ghc/cabal/whatever setup that I actually liked.
22:19:31 <napping> If you want to build the platform from source, go for ghc 7.8.3
22:21:09 <xj54y> napping, ghc > 7.8.3 will not suffice?
22:22:03 <napping> xj54y: There's nothing wrong with a newer GHC, but if you want to build the haskell platform from source, that's the version the last release used
22:22:22 <napping> once you have cabal-install and ghc working, all you'd actually need is the .cabal file from the haskell-platform source distribution
22:22:45 <napping> and then something like "cabal install haskell-platform.cabal" should build and install all the packages you'd get anyway
22:22:46 <xj54y> napping, ah I see. Lets see how this run goes and i'll give it a try :-)
22:23:04 <napping> or, just get ghc and cabal-install working and add stuff as you go
22:24:02 <xj54y> napping, odd question but is https://downloads.haskell.org/~ghc/7.10.1/ghc-7.10.1-i386-unknown-linux-deb7.tar.bz2 timing out for you?
22:24:42 <Haskellfant> xj54y: works for me™
22:24:51 <napping> The most annoying thing about getting GHC working on windows is getting C libraries that stuff depends on, and a platform install is great for that. On linux, that's not really a problem
22:25:16 <xj54y> Haskellfant, 100% packet loss, time 2014ms :<
22:25:18 <napping> several of the links seem to time out for me
22:25:37 <Haskellfant> it loaded for quite some time, but eventually it worked
22:25:59 <napping> I don't know how you got the ~ghc in there, but https://www.haskell.org/ghc/dist/7.10.1/ghc-7.10.1-i386-unknown-linux-deb7.tar.xz takes a long time
22:26:02 <Hijiri> my font size is small so the TM just looks like an amorphous blob of pixels
22:27:39 <xj54y> Well.. This is not going anywhere. Any mirrors?
22:28:21 <napping> try again?
22:28:28 <kadoban> xj54y: It was slow to start for me, but actually downloaded fine once it did
22:28:42 <napping> I had it fail to start, but retrying just now worked
22:28:49 <xj54y> I've been trying since *looks for timestamp*
22:29:26 <napping> I don't know of mirrors, but cancel and try again
22:29:41 <xj54y> "ERR_CONNECTION_TIMED_OUT"
22:30:09 <napping> even haskell.org is slow
22:30:39 <xj54y> Some kind of queue?
22:30:53 <napping> https://status.haskell.org/
22:35:36 <xj54y> napping, I'm kind of worried about running the cabal.config from platform against the cabal.config from stackage. Is this is a bad idea?
22:35:51 <napping> a cabal.config?
22:36:11 <napping> what is "cabal.config"}
22:36:44 <napping> hmm, I've never used something like that
22:36:50 <napping> Those are almost certainly incompatible
22:37:36 <napping> each is a consistent set of packages, but there's no guarantee they are consistent with each other
22:38:12 <napping> Where is a cabal.config file for haskell platform?
22:38:32 <napping> (I didn't know cabal even looked for a file like that)
22:39:28 <nullx002> exit
22:41:28 <xj54y> napping, hmm.. It's a file named haskell-platform.cabal within the haskell-platform-2014.2.0.0 source directory
22:41:40 <napping> oh, that's a bit different
22:42:12 <napping> if you do cabal install in that directory (without setting up a sandbox), it should try to build and install all those versions of packages
22:42:23 <napping> the stackage cabal.config file seems to just add constraints
22:42:35 <napping> so if you install a package it will only use the version tested on stackage
22:42:54 <napping> I've never used either, just working in sandboxes has been plenty for me
22:43:44 <kadoban> I'm not positive, but I really don't think platform works with stackage.
22:46:00 <xj54y> I'm a little hesitant to try, but.. We'll find out shortly :-)
23:01:30 <eds>  Couldn't match type `Int' with `t0 a0'
23:01:38 <eds> What does t0 a0 mean?
23:02:35 <eds> http://lpaste.net/133806
23:03:27 <saulzar> eds, It means it thinks you have a some type with a parameter  ... e.g. List a0 or Maybe a0
23:04:28 <saulzar> eds, What line is the error?
23:04:38 <eds> Last line
23:04:55 <eds> When I calculate the length
23:06:10 <liste> should the last thing be eval instead of evalq?
23:11:47 <eds> Line 23: evalq (Length e1) = liftM (length) (evalq e1)
23:12:33 <liste> yeah, the types don't match
23:12:37 <liste> evalq returns an Int
23:12:46 <liste> length expects a list
23:13:25 <eds> ahh. I see.
23:13:49 <eds> How would I calculate the length of a list then?
23:14:15 <eds> got it. eval e1 worked. since eval returns list
23:14:37 <eds> eval :: E -> Maybe [Int]
23:25:52 <joneshf-laptop> is there some nice way to iterate until convergence?
23:25:57 <joneshf-laptop> like maybe using `fix`
23:26:29 <arkeet> define convergence
23:29:01 <joneshf-laptop> say i'm looking for convergence of a matrix/vector/array, and i have a function that generates new values from the old. Then it converges when each element of the new thing is within some epsilon of the old
23:30:43 <kadoban> joneshf-laptop: Construct an infinite list using iterate, then check when you reach the state you want? (perhaps zip it with the tail of itself and then check using that?)
23:30:50 <nocturne777> some people in the Haskell community say that lenses are to be avoided, but I see them being used in the open source projects.
23:31:00 <arkeet> I'd go with what kadoban said
23:31:12 <merijn> nocturne777: Some people say X for any value of X
23:31:14 <joneshf-laptop> kadoban, yeah, that's what i'm currently doing
23:31:27 <joneshf-laptop> i was wondering if i was missing something though
23:31:52 <nocturne777> merijn: :)
23:32:08 <merijn> nocturne777: If lens solves a problem you have, use it
23:40:17 <liste> also, some people dislike the amount of dependencies the lens package has, and lens-family is an alternative with less dependencies (but also with less "batteries included")
23:56:33 <rui> Is ghc 7.8 needed for ihaskell or does it work with 7.10?
23:57:21 <rui> (so far I'm trying but failing)
23:58:11 <freshman> Hello. Could you please help, is it possible (and does it makes sence) to construct fixed-point operator in terms of another FPO?
23:58:58 <Cale> freshman: yes, it's usually pretty easy to do that
23:59:27 <Cale> freshman: Well, depending on what you mean by "another"
