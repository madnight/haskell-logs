00:01:26 <Sindriava> supki: Pills seem like a cool resource, thanks :)
00:06:21 <Sindriava> So far, I haven't been able to run a Haskell program since I uninstalled Haskell Platform :(
00:06:45 <Sindriava> Building some packages fails, because Cabal can't see OSX header files
00:07:40 * hackagebot functor-infix 0.0.2 - Compositions of functors.  http://hackage.haskell.org/package/functor-infix-0.0.2 (vi)
00:07:40 * hackagebot functor-infix 0.0.3 - Infix operators for mapping over compositions of functors. Lots of them.  http://hackage.haskell.org/package/functor-infix-0.0.3 (vi)
00:34:24 <jle`> http://hackage.haskell.org/package/functor-infix-0.0.2/docs/Data-Functor-Infix.html
00:34:25 <jle`> welp
00:40:36 <joneshf-laptop> haah, what?
00:40:43 <joneshf-laptop> what is that?
00:45:43 <jle`> the package that was just pushed, heh
00:46:46 <Haskellfant> it should at least use different functors
00:48:35 <joneshf-laptop> yeah
00:50:15 <b337>  /quit
01:02:36 * hackagebot json-togo 0.1.1.0 - Effectful parsing of JSON documents  http://hackage.haskell.org/package/json-togo-0.1.1.0 (srijs)
01:15:46 <alisia> In haskellWhich type should be used to represent money values?
01:17:36 <Haskellfant> alisia: I would probably go for https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Fixed.html#t:Centi
01:18:50 <Haskellfant> which is just integer in disguise afaik
01:19:25 <pharaun>  /win 20
01:19:28 <pharaun> whoops, sorry
01:20:06 <alisia> Haskellfant: why not Data.Decimal?
01:20:22 <jle`> > MkFixed 99 + MkFixed 10 :: Centi
01:20:24 <lambdabot>  1.09
01:21:21 <jle`> Data.Decimal can store things of any precision
01:21:28 <jle`> Ceni can only store things of centi-precision
01:22:03 <jle`> also Centi is in base too, if that matters
01:22:20 <Haskellfant> yep, obviously if you want more precision Data.Decimal is fine, but otherwise I would stay with Centi to avoid running into problems when a calculation returns half a cent or something like that
01:24:19 <jle`> in Haskell we also generally like to make types are restrictive as possible to we can reason about them better
01:24:30 <jle`> that's why we have `Maybe`, instead of just using lists for everything
01:24:33 <alisia> Haskellfant: Ok. Have you used Data.Fixed with postgres-simple?
01:24:46 <jle`> a `Maybe a` is a list with either 0 or 1 elements.  so we use it when we know we will have either 0 or 1 element
01:25:07 <dramforever> jle`: 1. I'm thinking about traversals/prisms
01:25:13 <dramforever> 2. are you talking about...lisp?
01:25:21 <jle`> i'm talking about Haskell, heh
01:25:31 <jle`> there's a reason why we use find :: (a -> Bool) -> [a] -> Maybe a
01:25:33 <dramforever> jle`: lists for everything
01:25:37 <jle`> instead of find :: (a -> Bool) -> [a] -> [a]
01:25:39 <jle`> ah, i see
01:25:56 <jle`> nah i'm just saying that in Haskell we like to pick types that are as restricted as possible
01:26:03 <jle`> so we can say more things in our types
01:26:05 <dramforever> :)
01:26:06 <jle`> as opposed to in documentation
01:26:24 <jle`> why say in the documentation of find "find will always return 0 or 1 values", when you can just make it return a Maybe a?
01:26:28 <dramforever> jle`: Java: RTFM
01:26:32 <dramforever> Haskell: RTFT
01:26:36 <jle`> haha
01:31:30 <Haskellfant> alisia: nope
01:33:14 <alisia> Haskellfant: I should be able to read it from a bytestring using bytestring.unpack...right?
01:35:08 <Haskellfant> I'm not sure what bytestring has to do with Data.Fixed
01:38:58 <alisia> Haskellfant: When I am reading from the database, if the target is a type, unknown to the Db library (postgresql-simple), then I am supposed to write a method that can convery the raw bytes read from db into the desired type...
01:40:11 <Haskellfant> from a quick look postgres seems to have a numeric type which is exactly for fixed precision numbers and postgresql-simple supports that
01:42:20 <alisia> Haskellfant: where can I see that?
01:43:03 <Haskellfant> http://www.postgresql.org/docs/9.4/static/datatype-numeric.html https://hackage.haskell.org/package/postgresql-simple-0.4.10.0/docs/Database-PostgreSQL-Simple-FromField.html#v:fromField
01:46:35 <alisia> Haskellfant: This one?   FromField Scientific	 ->   int2, int4, float4, float8, numeric  ?
01:46:57 <Haskellfant> Scientific and Ratio Integer seem to support converting from numeric
01:47:42 <alisia> Haskellfant: Ok. Let me try. Thanks you :)
01:53:24 <tmtwd> hello
01:54:58 <jle`> hi tmtwd :D
02:07:46 <kqr> soo.... how do I use stack? I have a cabalized project and I'd like to try to get it to build with stack
02:10:27 <alanz> kqr: run "stack init" in the directory with the cabal file, it should help you through the process
02:11:41 <kqr> alanz, thanks
02:11:50 <kqr> how should I approach version pinning with stack?
02:12:07 <kqr> I've previously been very pessimistic about specifying versions and it's bitten me in my tail a few times
02:12:31 <alanz> Its built in to stack. It will use a stackage constraint set, or else prompt you to add the specific versions to the stack.yaml
02:12:37 <kqr> hm
02:12:48 <kqr> currently it complains that
02:12:49 <alanz> so it is specified via the resolver
02:13:04 <kqr> http://lpaste.net/1474601365232680960
02:13:14 <kqr> which I assume is because there are very tight bounds specified in the cabal file
02:14:03 <alanz> yes, I generally remove upper bounds from the cabal file, and if you are using stack as the main build you can remove them completely from the cabal file
02:14:31 <alanz> because they are specified externally, so it is then needless repetition
02:14:58 <kqr> oh
02:15:00 <kqr> awesome
02:15:10 <kqr> do I remove the entire build-depends section then?
02:15:20 <kqr> can I also remove the cabal sandbox?
02:15:52 <alanz> you can remove the sandbox, but not the build depends. Just the upper version limits in the build depends section
02:16:05 <kqr> oh right
02:16:10 <alanz> by constraints I meant the version limits
02:16:11 <kqr> the lower bounds should remain?
02:16:14 <kqr> yes, I understood now :)
02:16:26 <alanz> as you wish, it does not really matter.
02:16:46 <alanz> I would leave them in only for those dependencies that actually need a specific version or later
02:17:07 <alanz> But that is only for documentation, they will be chosen based on the resolver anyway
02:17:14 <kqr> ah
02:22:41 <ttt_fff> how does one run secret societies ?
02:26:59 <peddie> ttt_fff: we can't tell you, it's a secret
02:27:40 <ttt_fff> so it's readable only inside the SecretMonad ?
02:32:26 <ClaudiusMaximus> i'm doing symbolic algebraic stuff, and struggling with combinatorial explosions in the types: eg, one function turns an expression into a sum-of-products, like  Mul (Add x y) (Add x y) -> Add' [Mul' [x,x], Mul' [x,y], Mul' [y,x], Mul' [y,y]]
02:33:28 <dramforever> > (*x) <$> [a,b,c]
02:33:29 <funfunctor> Hi
02:33:30 <lambdabot>  [a * x,b * x,c * x]
02:34:03 <dramforever> ClaudiusMaximus: a, b, c and x are from Debug.SimpleReflex, you can just regard them as simple variables
02:34:03 <ClaudiusMaximus> another part turns  x  into  Add'' (Mul'' I'' (Re'' x)) (Mul'' J'' (Im'' x))  -- how can I make extensible types so i don't have to repelicate lots of algorithms for slightly different data?
02:34:15 <funfunctor> Isn't the applicative function x <|> y meant to do, "if x fails try y" ?
02:34:37 <dramforever> funfunctor: I'm afraid not
02:34:46 <funfunctor> oh!!!
02:35:17 <funfunctor> dramforever: I am trying to write a json parser with aeson, what am I looking for then?
02:35:25 <funfunctor> also what does <|> do?
02:35:40 <dramforever> a <|> b = try both a and b
02:35:46 <dramforever> like a monoid
02:35:59 <dramforever> I mean, some do "if a fails try b"
02:36:11 <dramforever> I think some others do "try a and b in parallel"
02:36:12 <ClaudiusMaximus> funfunctor: it's in Alternative, and for lists it's a bit unexpected (same as ++),  I'm using it with WriterT Maybe
02:36:25 <ClaudiusMaximus> and it does what i want (returns the first success)
02:37:02 <dramforever> ClaudiusMaximus: that's still a monoid
02:37:12 <ClaudiusMaximus> sure
02:37:48 <funfunctor> dramforever: but that is what I just said and you said its wrong?
02:38:09 <ClaudiusMaximus> but there are many monoids to choose from, and the one you want might not be the one the instance uses
02:38:10 <dramforever> > [1,2,3] <|> [4,5,6] -- what about this
02:38:11 <lambdabot>  [1,2,3,4,5,6]
02:38:45 <dramforever> wait, isn't aeson a json parser itself?
02:38:54 <funfunctor> what if I have two parsers and one could fail so I want to try the other
02:39:01 <ClaudiusMaximus> > First [1,2,3] <|> First [4,5,6]  -- wondering if this works...
02:39:02 <lambdabot>      Couldn't match expected type ‚ÄòMaybe a‚Äô with actual type ‚Äò[Integer]‚Äô
02:39:03 <lambdabot>      In the first argument of ‚ÄòFirst‚Äô, namely ‚Äò[1, 2, 3]‚Äô
02:39:03 <lambdabot>      In the first argument of ‚Äò(<|>)‚Äô, namely ‚ÄòFirst [1, 2, 3]‚Äô
02:39:19 <dramforever> funfunctor: use (<|>) :)
02:39:32 <dramforever> you were asking an overly general question in the beginning
02:39:41 <funfunctor> I was?
02:39:51 <ClaudiusMaximus> (even correcting the Maybe issue there is no Alternative First)
02:40:48 <ThomasLocke> I'm new to Haskell, and I'm struggling with list ranges when dealing with negative numbers. [0..10] works fine, but [0..-10] does not. How can I construct a list of numbers from 0 to -10? 
02:41:05 <dramforever> > [0,-1..-10]
02:41:06 <lambdabot>      Not in scope: ‚Äò..-‚Äô
02:41:06 <lambdabot>      Perhaps you meant ‚Äò...‚Äô (imported from Control.Lens)
02:41:10 <dramforever> ouch
02:41:24 <dramforever> > [0, -1 .. -10] -- spaces are your friend
02:41:26 <lambdabot>  [0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]
02:41:28 <Jafet> :t (...)
02:41:30 <lambdabot> (Applicative f, Plated c) => LensLike f s t c c -> Over p f c c a b -> Over p f s t a b
02:41:35 <funfunctor> > [1 .. -10]
02:41:37 <lambdabot>  []
02:41:41 <funfunctor> wops
02:41:49 <funfunctor> oh nvm
02:41:51 <dramforever> > enumFromStepTo 1 -1 -10
02:41:52 <lambdabot>      Not in scope: ‚ÄòenumFromStepTo‚Äô
02:41:53 <lambdabot>      Perhaps you meant one of these:
02:41:53 <lambdabot>        ‚ÄòenumFromThenTo‚Äô (imported from Prelude),
02:42:14 <jle`> yeah, you have to specify the "step" to count backwards
02:42:21 <funfunctor> dramforever: http://lpaste.net/135330 this parser is failing with " "key \"duration\" not present" "
02:42:23 <Jafet> It's not a step.
02:42:39 <jle`> > [10,9..0]
02:42:41 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0]
02:42:45 <ThomasLocke> So. Simple.
02:42:52 <jle`> > [0,-1.. -10]
02:42:54 <lambdabot>  [0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]
02:42:54 <ThomasLocke> Thanks a bunch gues.
02:42:58 <ThomasLocke> guys even
02:43:05 <dramforever> funfunctor: so duration is not present?
02:43:27 <funfunctor> dramforever: yes but look what I am trying to do..
02:43:57 <dramforever> you try to get { status: "foo" } into an ElementT?
02:44:06 <funfunctor> dramforever: there are two parsers, one for the case when there is just "status : NOT_FOUND" and the other parser for the other case
02:44:19 <dramforever> so status one doesn't work
02:44:25 <funfunctor> ?
02:44:37 <funfunctor> oh yes sorry
02:44:53 <funfunctor> wait, what do you mean "doesn't work" ?
02:45:14 <dramforever> you get key "duration" not found?
02:45:21 <funfunctor> more that its failing on the first but not trying the second as an alternative
02:45:42 <dramforever> oh umm...
02:45:59 <dramforever> I don't know how to solve this...
02:46:02 <dramforever> sorry
02:46:11 <ClaudiusMaximus> http://mathr.co.uk/tmp/symbolic-algebra.html is some (large, 580kB html no images) output from my code, which has   data Expr = Num Integer | Var String | Add [Expr] | Mul [Expr]  where the String contains a bunch of adhoc stuff that I use for various purposes :/
02:46:13 <Jafet> Maybe aeson's parser needs a "try".
02:46:35 <funfunctor> Jafet: I looked for that function but could not find it
02:47:17 <ttt_fff> anyone have good article on running a small haskell only startup?
02:47:31 <Jafet> ClaudiusMaximus: where do the types come into this?
02:48:30 <hilquias> @pl \time -> (run a time) (run b time)
02:48:30 <lambdabot> run a `ap` run b
02:48:49 <phaazon> that guy ^
02:48:56 <phaazon> he tries to perform phishing on me
02:49:04 <phaazon> we should consider banning him
02:49:09 <phaazon> not sure he‚Äôll come back though
02:49:29 <phaazon> he disconnected when I¬†told him I¬†knew what he was doing
02:49:59 <dramforever> ops? ^
02:50:20 <Jafet> You could report that to freenode staff.
02:50:28 <phaazon> right, I will
02:50:29 <phaazon> thanks
02:50:32 <phaazon> I have the log anyways
02:50:35 <dramforever> oh sure, more useful
02:51:08 <phaazon> http://lpaste.net/135331
02:51:09 <ClaudiusMaximus> Jafet: i can't figure out how to express information in types in a compositional way, like some parts require a sum-of-products and other parts require the product to start with a number, and then doing things like  case e of Mul (Variable "J" : Variable "J" : xs) -> Mul (Number (-1) : Variable "I" : xs)  etc seems ugly
02:52:30 <Jafet> GADT-encoding?
02:52:41 <ClaudiusMaximus> Jafet: using strings sorta works, but i have to be careful to avoid loops in places (like the "complexification" checks that the variable doesn't start with Re or Im and isn't J or I)
02:52:44 <Sindriava> What is stack, exactly? Replacement for cabal-install?
02:52:54 <dramforever> ClaudiusMaximus: IIWY I would normalize, like Product SomeNumberType (Map Var SomeNumberType)
02:52:55 <phaazon> Sindriava: some kind
02:53:01 <phaazon> it‚Äôs more a stable hackage tool
02:53:03 <dramforever> Sindriava: get started quick
02:53:13 <Sindriava> Sounds good!
02:53:20 <phaazon> it can resolve GHC compiler versions
02:53:31 <phaazon> and LTS / nightly packages set by analysing your .cabal
02:53:42 <Sindriava> Cool
02:53:43 <funfunctor> phaazon: don't know if that is `fishing` as such, more just a insane person
02:54:10 <Sindriava> I'm going to make a dedicated development machine out of my RaspberryPi, so I'm looking around for appropriate tooling
02:54:14 <phaazon> funfunctor: well, I‚Äôm pretty sure it‚Äôs phishing
02:54:17 <ClaudiusMaximus> dramforever: sure, but then i end up with a zillion slightly different types for different stages of the normalization
02:54:45 <funfunctor> phaazon: where was he asking for your bank details?
02:55:13 <dramforever> ClaudiusMaximus: so sad, that seems to be the "wonderful idea" when I was thinking about writing a compiler...
02:55:20 <funfunctor> he just seemed to like the X files to me <g>
02:55:25 <dramforever> different types on different stages
02:55:55 <ClaudiusMaximus> dramforever: sure, i want it, but i also don't want to rewrite lots of code for all the variations...
02:56:17 <dramforever> ClaudiusMaximus: how about typeclasses?
02:56:29 <dramforever> class HasCoefficient a where...
02:56:33 <dramforever> wait that's hardly useful
02:56:52 <dramforever> hmm...who knows
02:57:15 <dramforever> looks like what lens/traversals/... might do
02:57:36 <dramforever> though I'm not familar with them enough to tell you more about them
02:58:02 <Jafet> There is the tagless-final design (http://okmij.org/ftp/tagless-final/course/#lecture), though it may make transformations less convenient
02:59:50 <ClaudiusMaximus> Jafet: looks interesting, taking a look
02:59:54 <Jafet> The first few chapters actually show an arithmetic expression language
03:35:38 <Jafet> @hoogle String -> String -> [Int]
03:35:39 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
03:35:40 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
03:35:40 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
03:36:40 <Jafet> @hoogle [a] -> [a] -> [Int]
03:36:40 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
03:36:40 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
03:36:40 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
03:37:01 <Jafet> Actually, what's even a good type for substring search?
03:37:31 <Jafet> Possibly Eq a => [a] -> [a] -> [(Int, [a])]
03:47:43 * hackagebot spdx 0.1.0.0 - SPDX license expression language  http://hackage.haskell.org/package/spdx-0.1.0.0 (phadej)
03:53:59 <kuribas> Is there a function (m (a -> b) -> a -> m b)?
03:54:25 <kuribas> To evaluate a monad in the middle: (MV.write v =<< readSTRef i) ?? coeffX r cp
03:54:47 <dramforever> @pl \m x -> ($ x) <$> m
03:54:47 <lambdabot> flip ((<$>) . flip id)
03:54:51 <dramforever> no...
03:55:16 <kuribas> ok...
03:55:19 <dramforever> kuribas: but is ($ x) <$> m good enough?
03:55:27 <kuribas> I guess...
03:55:59 <kuribas> Or (flip (MV.write v) (coeffX r cp)=<< readSTRef i)
03:57:06 <kuribas> or I'll just define the combinator myself :)
03:57:52 <lf94> bind them monads.
03:59:36 <kuribas> m (>>$) a = m >>= \f -> return (f a)
03:59:42 <bergmark> @type (<*> pure)
03:59:43 <lambdabot> Applicative f => (a -> f a -> b) -> a -> b
04:00:07 <dramforever> @type ((<*>) . pure)
04:00:08 <lambdabot> Applicative f => (a -> b) -> f a -> f b
04:00:32 <dramforever> huh? did I just define fmap in terms of applicative accidentally
04:01:21 <kuribas> yeah :)
04:02:13 * dramforever just accidentally fmap
04:03:34 <ion> @type (<&>)
04:03:35 <lambdabot> Functor f => f a -> (a -> b) -> f b
04:03:48 <ion> Whoops, that wasn't it
04:04:21 <ion> @type (??)
04:04:22 <lambdabot> Functor f => f (a -> b) -> a -> f b
04:04:45 <dramforever> kuribas: whoa that's it ^
04:04:52 <dramforever> @index (??)
04:04:52 <lambdabot> bzzt
04:04:53 <kuribas> Maybe better: readSTRef i >>= MV.write v >>= ($ coeffX r cp)
04:05:09 <kuribas> dramforever: great!
04:05:16 <dramforever> but where is it?
04:05:20 <kuribas> :i (??)
04:05:44 <ion> It's in lens, so you'll only need 50 % of Hackage as transitive dependencies.
04:06:38 <kuribas> lol
04:06:48 <dramforever> lol
04:06:57 <kuribas> everything combinator is in lens :)
04:07:00 <Jafet> Wait, is it really named (??)
04:07:03 <kuribas> s/everything/every
04:07:43 <dpld> :pf \x ms -> f x >>= flip fmap ms . (:)
04:07:51 <dramforever> Jafet: ??
04:07:55 <kuribas> hehe, I used ?? as a placeholder
04:08:06 <dramforever> @pf \x ms -> f x >>= flip fmap ms . (:)
04:08:06 <lambdabot> Maybe you meant: pl bf
04:08:19 <dramforever> @unpl \x ms -> f x >>= flip fmap ms . (:)
04:08:20 <lambdabot> \ x ms -> (f x) >>= \ g -> fmap (((:)) g) ms
04:08:26 <dramforever> huh?
04:08:26 <ion> (f ?? y) x = f x y, the mnemonic is that ?? is a placeholder for the x.
04:09:05 <dramforever> :t let (f ?? y) x = f x y in (??)
04:09:06 <lambdabot> (t1 -> t2 -> t) -> t2 -> t1 -> t
04:09:07 <dramforever> :t flip
04:09:08 <lambdabot> (a -> b -> c) -> b -> a -> c
04:09:32 <dpld> @pl \x ms -> f x >>= flip fmap ms . (:)
04:09:32 <lambdabot> (. ((. (:)) . flip fmap)) . (>>=) . f
04:10:32 <dpld> @unpl \x ms -> f x >>= flip fmap ms . (:)
04:10:33 <lambdabot> \ x ms -> (f x) >>= \ g -> fmap (((:)) g) ms
04:15:05 <obb> hi, I'm working on the 99 haskell problems (https://wiki.haskell.org/99_questions/11_to_20) and i have a question concerning the 11th problem: lets say i have a list containing Multiple x c. i want to create a lambda expression which maps Multiple 1 c to Single c. how do i do that?
04:17:33 <kuribas> obb: You want something like (\x -> case x of pat -> e; default -> default)
04:17:39 <dramforever> @let data Item a = Single a | Multiple Int a deriving (Show)
04:17:41 <lambdabot>  Defined.
04:18:36 <kuribas> obb: That's half the solution, you only need to fill in x, pat, and e.
04:18:57 <kuribas> or keep x even.
04:19:12 <obb> :D
04:19:28 <[k-> hint: all questions have solutions on the page itself
04:19:37 <dramforever> > let f = (\a -> case a of Multiple 1 m -> m; x -> x) in map f [Multiple 1 "a", Multiple 2 "b", Single "c"]
04:19:39 <lambdabot>      Occurs check: cannot construct the infinite type: t ~ L.Item t
04:19:39 <lambdabot>      Relevant bindings include
04:19:39 <lambdabot>        x :: L.Item t (bound at <interactive>:1:45)
04:19:50 <dramforever> ouch
04:20:28 <kuribas> > let f = (\a -> case a of Multiple 1 m -> Single m; x -> x) in map f
04:20:28 <kuribas> 	    [Multiple 1 "a", Multiple 2 "b", Single "c"]
04:20:30 <lambdabot>      No instance for (Typeable a0)
04:20:30 <lambdabot>        arising from a use of ‚Äòshow_M27393548258037006752462‚Äô
04:20:30 <lambdabot>      In the expression:
04:21:29 <kuribas> weird
04:21:30 <obb> [k-, i saw that too but i dont like the solution
04:21:41 <Sindriava> Is there a sensible LHS to html parser?
04:21:44 <kuribas> Or with a list comprehension.
04:21:55 <pingu> kuribas: not particularly weird. You forgot to supply a list.
04:22:07 <pingu> so it didn't want to print a function.
04:22:10 <kuribas> ah
04:22:15 <kuribas> > let f = (\a -> case a of Multiple 1 m -> Single m; x -> x) in map f [Multiple 1 "a", Multiple 2 "b", Single "c"]
04:22:16 <lambdabot>  [Single "a",Multiple 2 "b",Single "c"]
04:22:22 <kuribas> pingu: right :)
04:22:44 <pingu> the error is a little misleading, though :)
04:25:36 <dramforever> > const
04:25:37 <lambdabot>      No instance for (Typeable a0)
04:25:38 <lambdabot>        arising from a use of ‚Äòshow_M71377140437889822542557‚Äô
04:25:38 <lambdabot>      In the expression:
04:25:52 <dramforever> > words
04:25:54 <lambdabot>  <[Char] -> [[Char]]>
04:26:34 <dramforever> pingu: it didn't want to print a *general* function
04:27:20 <jle`> Sindriava: pandoc ?
04:28:23 <jle`> it has a markdown-lhs source format
04:28:32 <jle`> i think
04:29:25 <Sindriava> jle`: Never heard of that, i'll check it out!
04:29:44 <pingu> dreixel: ah, that's pretty magical.
04:29:55 <pingu> dreixel: apologies, disreguard.
04:30:17 <hodapp> jle`: It does indeed. I use it for blog posts.
04:30:55 <hodapp> jle`: however there are some gotchas; GHC barfs on certain markdown constructs, like (I think) if you try to use # for a heading
04:36:20 <kuribas> hodapp: yes # is reserved syntax in ghc
04:36:24 <Sindriava> I'd be perfectly happy with LaTeX to be honest. I'm going to write some schoolwork in Haskell, and to be able to write it as a LHS would be great.
04:37:01 <hodapp> kuribas: but even in LHS?
04:37:06 <Sindriava> Especially if I could  somehow get rid of the ">" on the beginning of the line (in the rendered document)
04:37:14 <kuribas> hodapp: On the beginning of a line I think
04:37:24 <hodapp> Sindriava: you can do that in Pandoc when rendering code
04:37:40 <kuribas> I submitted a pull request, but I didn't get any answer: https://github.com/jgm/pandoc/pull/1689
04:37:42 <Sindriava> hodapp: Great!
04:38:02 <Sindriava> Honestly, haskell has so many features that I've never seen before, but seem COMPLETELY obvious once I found out
04:43:34 <maerwald> weird, I often think the opposite
04:47:02 <kuribas>  I feel the same with ghc extensions.  I often think, why can't I do... And there is already a ghc extension for it.
04:49:13 <obb> what exactly is the meaning of a semicolon in haskell?
04:50:11 <pingu> obb: newline, when you have braces { }
04:50:36 <pingu> obb: but you can write anything you would with semicolons without semicolons, should you wish to.
04:50:53 <maerwald> https://wiki.haskell.org/Keywords#.3B
04:51:02 <obb>  (\a -> case a of Multiple 1 m -> Single m; x -> x) << in this expression there aren't any braces and i apparently cant write it without semicolon
04:52:40 <pingu> obb: you can, with a newline.
04:52:50 <pingu> case a of
04:52:56 <pingu>     Multiple 1 m -> Single m
04:52:59 <pingu>     x -> x
04:53:15 <pingu> Which is going to be more readable in a file, anyway.
04:53:36 <obb> ah ok got it. didn't know that newlines have a meaning in haskell 
04:53:42 <obb> thank you
04:54:24 <pingu> haskell can be pretty finicky about whitespace sometimes.
04:57:32 <kuribas> obb: semicolon is a separator.  If you use the layout rule, the semicolons are automatically inserted, based on the indentation.
04:58:26 <kuribas> obb: The layout rule is triggered whenever you omit a '{' where there should be one.
04:59:27 <kuribas> Like in: case x of {..} or let {..} in ...
04:59:43 <obb> ok let me see if you're right ;)
04:59:49 <kuribas> I am :)
05:01:30 <Sindriava> maerwald: What do you mean by "opposite" ?
05:02:20 <Sindriava> pingu: At least it's consistent about whitespace, from my experience
05:02:52 <maerwald> Sindriava: that haskell has a lot of features (or more broad: concepts) that are not at all obvious when you first look at them
05:03:18 <Sindriava> maerwald: Well, while that's true, it's not in opposition with what I said
05:03:20 <obb> agreed :D
05:04:50 <Sindriava> maerwald: What I meant was that a lot of haskell features are really obvious, even though I never though about them. LHS is one such example
05:05:24 <Sindriava> maerwald: Same about compiler AND an interpreter AND a repl
05:05:33 <Sindriava> maerwald: I never though about having both :)
05:05:49 <Sindriava> Though more correctly, those would be features of GHC, not Haskell
05:30:28 <kqr> hello awesome people! I'm trying to get a yesod project running under stack, but when I run "yesod devel" it complains about missing dependencies. am I doing something wrong?
05:42:21 <chris2> stack exec yesod devel?
05:52:10 <Hi-Angel> How to extract Bool from IO? I thought that this is the right way ´when (foo >>= (== True)) $ putStrLn "Hello"ª ó here the type of foo is ´foo :: IO Boolª. But it trigger a type error :/
05:53:45 <maerwald> Hi-Angel: doesn't look like a valid stepping function which has the type "a -> m b"
05:53:57 <maerwald> but you just do (== True)
05:54:12 <Haskellfant> fmap (==True) foo
05:54:42 <Haskellfant> checking if a bool is true doesn't make a lot of sense, but that looks like what you are trying to do
05:55:07 <Hi-Angel> Why doesn't it make a sense?
05:55:15 <kuribas> Hi-Angel: the right side of (>>=) has to be a monad.
05:55:21 <kuribas> :t when
05:55:23 <lambdabot> Applicative f => Bool -> f () -> f ()
05:55:24 <maerwald> yeah, rather something like (foo >>= (\x -> if x then putStrLn "Hello" else return ()))?
05:55:43 <kuribas> Hi-Angel: and the first argument of when is just "Bool", not "m Bool".
05:55:44 <Hi-Angel> Ah
05:56:11 <Haskellfant> Hi-Angel: because it doesn't change anything. if b=False, b==True is false, if b=True, b==True is True, so (b==True) is just True
05:56:44 <Haskellfant> eh just b
05:56:51 <kuribas> Hi-Angel: I guess what you want is foo >>= (\b -> when b $ putStrLn "Hello")
05:57:37 <Hi-Angel> I see, thank you very much!
06:01:44 <kuribas> or "putStrLn "Hello" . when =<< foo"
06:03:38 <maerwald> looks worse
06:03:56 <kuribas> yeah :)
06:04:35 <kuribas> It's in function application order.
06:08:42 <ion> Hi-Angel: Given ‚Äúa <- foo‚Äù in a do block, if foo :: IO Bool then a :: Bool.
06:09:33 <tehtitanium> Hello
06:09:41 <tehtitanium> Hello everyone. I am going to write my bachelorthesis about WAF Bypassing and would have some input what knowledge and skills I need? Headwords are totally fine ;) 
06:11:54 <bennofs> tehtitanium: what is WAF? and how's this related to #haskell? 
06:12:30 <xplat> foo >>= (flip when $ putStrLn "Hello")
06:13:48 <maerwald> golfing contest incoming
06:13:53 <ion> Eww
06:15:24 <xplat> or (when =<< foo) <*> putStrLn "Hello"
06:16:30 <xplat> sorry; join $ (when =<< foo) <*> putStrLn "Hello"
06:19:34 <kalloc> hi, it's possible to crosscompile from mac os x to linux?
06:21:14 <kalloc> what the best way, to build binary to another platform? 
06:21:34 <kalloc> without real bootstraping on target platform  
06:23:38 <geekosaur> cross-compiling is difficult in general
06:24:58 <kalloc> how usualy solves this problem? 
06:25:33 <geekosaur> virtualbox :)
06:25:45 <Il_\IlI^IllI|IlI> ! Brucesht! The worst sport ever moyer boyer foot ball! Brucesht, boyer. notch, and that's a fucker game, it's a soccer game, so boyer coyer! Boyer football! Boyer royer! Boyer made. No!
06:25:48 <Il_\IlI^IllI|IlI> The world cares about football. After the worse thing but as watching on during on during. Most people are runna ma naes.
06:25:56 <Il_\IlI^IllI|IlI> It's a football. Nothing prime but the Jaguars, Cornfuckers, Cornbuck fuck cornhuskers, Cowboys, Ravens, Cornhuskers, so they go brucesht boyer football game it's a football game, it's no lie it's a futball game, so the Jaguars, so boyer football game. It's a soccer game, it's a futball and rittered. Except when I cover moyer! Brucesht boyer royer moyer! Boyer!
06:25:56 <Il_\IlI^IllI|IlI> Stop lawyyer made. Lynx game, so bored, makes me say oh my eyes it sucks ten rears.
06:27:28 <xplat> yeah, usually if you have a platform that can self-host the best solution is to self-host in an emulator
06:28:13 <xplat> in general, not just for haskell
06:32:42 <ion> kalloc: https://www.vagrantup.com/ probably.
07:02:46 <haskell202> hey! I have to program something while using IO and I'm not sure why my code doesn't work
07:03:04 <haskell202> can someone tell me what my problem in my second function is?
07:03:14 <haskell202> http://lpaste.net/5407825238295576576
07:03:33 <c_wraith> well, there's no indentation
07:03:37 <dramforever> haskell202: you are not indenting it
07:03:57 <dramforever> maybe you did so but copying destroyed the,
07:04:01 <dramforever> indents
07:04:05 <c_wraith> also, the "akk" function is exactly the same as (++)
07:04:08 <haskell202> where should I'd be indenting it?
07:04:33 <c_wraith> do blocks are called "blocks" for a reason
07:04:35 <dramforever> haskell202: where have you learned about do?
07:04:55 <haskell202> university 
07:05:13 <dramforever> haskell202: okay so have you seen any example do blocks?
07:06:21 <haskell202> yes I've indneted everything except the acc function 
07:06:33 <haskell202> and now it says possible missmatched bracets or indentations
07:06:42 <dramforever> haskell202: post that new one
07:07:02 <haskell202> http://lpaste.net/2281409996828704768
07:07:15 <dramforever> basically just indent every block, and double indent every block-in-block, and so on
07:07:47 <dramforever> so you still have to indent the two do-block-in-blocks
07:08:23 <dramforever> haskell202: do you know what I mean?
07:09:05 <c_wraith> haskell202: the thing is, the indentation actually *is* the structure of the program.  If you indent it so that indentation levels match the logical structure, it'll just work.
07:09:27 <dramforever> oh right, maybe you are not understanding it
07:09:36 <haskell202> wait I'm working on it right now
07:10:28 <haskell202> http://lpaste.net/2161942234495188992
07:10:44 <haskell202> still not working where should there be indents now?
07:11:04 <dramforever> there's no else in the inner if
07:11:11 <dramforever> that's the problem
07:11:45 <dramforever> haskell202: ^
07:12:09 <haskell202> corrected that and it's still not working
07:12:49 <dramforever> haskell202: don't worry :) we haskell people are friendly
07:13:05 <dramforever> because we know it is hard (at least for most) to learn haskell
07:13:18 <haskell202> :D are you a mindreader or what? I was just about to apologize for not understanding :D
07:13:23 <dramforever> just post the code :)
07:13:39 <dramforever> haskell202: all haskell newbies are similar
07:13:55 <dramforever> and we all were newbies for some time in the past
07:14:01 <haskell202> http://lpaste.net/8507628896756170752
07:14:11 <ChristianS> haskell202: the 'else' clause is not optional in haskell, it's required
07:14:40 <dramforever> hmm...I think that looks good enough
07:14:47 <haskell202> yes normally I do know that but I was distracted by the other error
07:15:00 <kuribas> There is a "when" function for monads
07:15:16 <haskell202> what does that do?
07:15:18 <dramforever> haskell202: oh error in the bottom of the lpaste page?
07:15:22 <kuribas> when b m = if b then m else return ()
07:15:57 <kuribas> haskell202: execute the action is b is True, return () otherwise.
07:16:17 <dramforever> haskell202: oh there are 2 problems
07:16:35 <dramforever> 1. in haskell function application is left associative
07:16:36 <haskell202> @dramforever (btw how do I directly adress you?) no my haskell compiler says there are several other errors
07:16:37 <lambdabot> Unknown command, try @list
07:16:48 <dramforever> haskell202: like this
07:17:01 <dramforever> the at sign triggers a bot here
07:17:18 <dramforever> so not null tier = (not null) tier
07:17:23 <kuribas> haskell202: your akk function has signature String -> String, but it has 2 parameters!
07:17:32 <dramforever> yeah that's problem #2
07:18:05 <kuribas> haskell202: And it seems to redefine (++)
07:18:34 <kuribas> haskell202: If you want to rename (++), you could just write "akk = (++)"
07:18:41 <haskell202> my acc function should do this:
07:19:08 <haskell202> if i enter only a attribute and no animal the main function should be recalled and the attribute of the animal should be stored
07:19:37 <haskell202> this goes on as long as the user types in an animal and then it prints all the stored attributes and the animal
07:21:24 <dramforever> haskell202: tier = animal, eigenschaft = attribute?
07:21:31 <dramforever> seems so
07:22:04 <haskell202> yes thats right
07:22:08 <kuribas> haskell202: you have no state
07:22:13 <dramforever> haskell202: oh so it seems that you need some state
07:22:17 <haskell202> but wait I'm rethinking my code right no
07:22:29 <haskell202> I'll wirte back later
07:22:35 <dramforever> k
07:23:04 <kuribas> haskell202: start with "main = loop []", then define "loop state = do ...".
07:23:30 <kuribas> haskell202: Then if you want to update the state, you call loop again with the modified state.
07:24:04 <dramforever> kuribas: I think we should stop giving random advice to "rethinking"
07:25:00 <kuribas> dramforever: ok, but I thought it wouldn't hurt to give him a little push in the right direction...
07:25:06 <dramforever> ok
07:25:28 <kuribas> dramforever: since he is confused about state and stateless functions.
07:26:03 <dramforever> kuribas: "recall main" shows that (s)he isn't thinking this well
07:26:20 * dramforever is being (okay, trying to be) politically correct
07:29:11 <kuribas> (s)he was expecting akk to destructively update the string.
07:31:39 <haskell202> I really don't get what I should be doing with loop [] never saw thiw function in my lecture...
07:31:52 <haskell202> and it says that the assignment can be done with a funcional accumulator
07:33:29 <haskell202> and btw I'm male :D so that you don't need to be politically correct
07:42:18 <CapitalSigma> how does parsec compare to lex/antlr?
07:44:45 <Clint> CapitalSigma: you're better off comparing happy/alex to yacc/lex
07:47:53 * hackagebot fluent-logger 0.2.3.1 - A structured logger for Fluentd (Haskell)  http://hackage.haskell.org/package/fluent-logger-0.2.3.1 (NoriyukiOhkawa)
07:51:56 <bmuk> I know this isn't Haskell specific, but there is no one in the ###bittorrent channel and I always assume you guys know everything :p. Say I wanted to distribute files (or a folder and its contents) that are changing, can I use bittorrent for this or would I need to create a new torrent every change (or new file in the folder)?
07:52:24 <bmuk> Fuuzetsu, I know you have worked with bittorrent before, any experience with this?
07:54:53 <Jafet> The bittorrent info hash prevents the files from being changed (for good reason)
07:55:18 <PopePop> !
07:57:22 <bmuk> Jafet: I was aware of the hashing, and I realize most of the time files should not change. My idea is that I could offload a significant amount of storage for some data (say, a minecraft world) from a single server, and move that storage to the users playing the game. I'm also wanting some way for peers to generate new sections of the map and seed 
07:57:22 <bmuk> them to others.
07:57:34 <NeverDie> Anyone here from NYC?
07:57:48 <StoneToad> bmuk: note that bittorrent at least didn't used to have any concept of files
07:58:13 <nkaretnikov> bmuk: there's #haskell-blah
07:58:35 <bmuk> nkaretnikov: thank you, I'll move the discussion over there :)
07:58:38 <StoneToad> the multiple files were just concatenated when doing the hash blocks, so changing the first file changed *all* the hashes
07:59:44 <bmuk> StoneToad: what if each new file was a new torrent?
08:04:20 <StoneToad> bmuk: yea that'd work fine, utorrent also stuck padding files (full of zeros) in to align file starts to block boundaries
08:05:36 <StoneToad> no idea how that worked if your file grew past a blockboundary though, it was intended for cases where people were only downloading part of the batch torrent
08:06:05 <bmuk> I'm thinking if I'm just storing immutable data about the world, the file won't change
08:06:09 <lpaste_> Jello_Raptor pasted ‚ÄúSorta Existential Types? ‚Äù at http://lpaste.net/135338
08:06:15 <Jello_Raptor> oh whoops
08:06:23 <StoneToad> bmuk: are you using custom clients?
08:06:50 <bmuk> StoneToad: I'm in the R&D phase. The client would have to be able to be embedded in a library
08:07:22 <Jello_Raptor> That's a paste asking about how to represent an existential quantifier. With some other shenanigans as well. Basically, I'm not sure how to create the wrapper datatype for Dictionaries that I want. 
08:09:05 <Jello_Raptor> Basically, I want to use Control.Lens.At as the interface for a dictionary type, and i want to be able to specify the kay and value types, but leave the implementer of the interface the choice of what underlying data structure to use. 
08:10:21 <Jello_Raptor> I could just pick a type for a dictionary, and fix that, but that would be overspecifying the interface, and I'd like to avoid that if possible. 
08:10:28 <StoneToad> bmuk: btw you might take a look at https://code.google.com/p/gittorrent/
08:11:12 <bmuk> StoneToad: I've seen that and that's part of what gave me this idea ;p
08:11:18 <StoneToad> ah, lol!
08:11:50 <StoneToad> was just thinking git repo holding the mc map and do commits when new chunks get generated (or built on)
08:15:51 <bmuk> lol that may work, but IIRC git is terrible with binary data
08:17:16 <nkaretnikov> watched this talk by dan piponi (from 2009) today: https://vimeo.com/6590617  it's awesome
08:19:56 <the1950> ciao
08:20:32 <the1950> list
08:21:12 <elben> I have a Show-able value that‚Äôs wrapped inside a a non-Showable context (e.g. Monad m => m Bool). What‚Äôs the easiest way for me to see the Bool value in ghci? I tried `m >>= (\s -> return $ traceShowId s) but still get ‚Äúno instance for Show‚Äù error
08:21:43 <elben> Mm, the error is for the returned expression in GHCi
08:22:07 <elben> Not sure why the `traceShowId` isn‚Äôt printing though
08:22:51 <StoneToad> elben: it's not running
08:22:58 <StoneToad> since there's a compile error (no show instance)
08:23:14 <nkaretnikov> elben: bool <- mbool; print bool ?
08:24:15 <Thra11> What is the 'blessed' LLVM version for GHC 7.10? LLVM 3.5?
08:24:57 <mniip> elben, fmap traceShowId
08:26:22 <c_wraith> that won't even do the job until the value is forced
08:26:28 <c_wraith> which could be quite a lot later.
08:26:32 <nkaretnikov> Thra11: try asking on #ghc
08:27:12 <c_wraith> To speed it up, you'd want something like mx >>= \x -> traceShow x (return x)
08:28:11 <c_wraith> Then it would be traced when the resulting m Bool (or whatever) is evaluated.
08:30:39 <elben> c_wraith: that‚Äôs what I tried to do, but mx has no Show to begin with, so it errors in GHCi
08:31:04 <c_wraith> elben: that explanation for the error doesn't match the code I suggested
08:31:20 <c_wraith> elben: can you lpaste some actual code with an actual error message?
08:31:43 <elben> c_wraith: http://lpaste.net/8345712383498387456
08:31:51 <c_wraith> oh, I missed the "in ghci" part
08:32:00 <c_wraith> just do something like seq foo ()
08:32:12 <c_wraith> You only want the side effects of evaluating it anyway
08:32:57 <c_wraith> That will only work if Compiler's >>= is strict in the right way, though..
08:33:19 <haskell202> can somebody help me with my function? this was my first draft:
08:33:26 <haskell202> http://lpaste.net/2161942234495188992
08:34:03 <elben> c_wraith: yeah, I‚Äôm not sure it‚Äôs working: http://lpaste.net/8345712383498387456
08:34:05 <haskell202> and this is my current aproach to the problem
08:34:05 <haskell202> http://lpaste.net/8469870675320897536
08:34:09 <c_wraith> elben: do you have any idea how hard I must resist rewriting \x -> traceShow x (return x) as traceShow <*> return ?
08:34:56 <haskell202> i want to create a function that prints the users entrys for tier(animal)  and eigenschaft (attribute)
08:35:22 <c_wraith> elben: yeah, looks Compiler's (>>=) definition is sufficiently lazy to make that not work.  You're going to just have to just use whatever run function Compiler provides
08:35:26 <haskell202> if one of the is not entered the function should be recalled and the one that was entered should be stored in an accumulator
08:35:34 <elben> c_wraith: be my guest‚Ä¶ I‚Äôm still new to Haskell so I‚Äôm not used to writing applicative
08:36:17 <c_wraith> elben: it's not even a relevant applicative.  It's the ((->) a) instance.
08:36:29 <c_wraith> elben: using it only makes things harder to read. :)
08:37:10 <nkaretnikov> haskell202: could you paste what you've tried?
08:37:12 <c_wraith> elben: where is the Compiler type coming from?
08:37:24 <elben> c_wraith: I am still in the ‚Äúwrite it as plainly as possible‚Äù comfort level :)
08:37:26 <haskell202> http://lpaste.net/8469870675320897536
08:37:30 * nkaretnikov looks
08:37:48 <merijn> elben: No one ever leaves that level :p
08:37:57 <merijn> elben: It's just that what you consider plainly changes over time :p
08:38:02 <elben> c_wraith: http://jaspervdj.be/hakyll/reference/Hakyll-Core-Compiler.html
08:39:13 <nkaretnikov> haskell202: so you want to keep the one that's already provided and ask the user to provide the other one?
08:39:16 <nkaretnikov> right?
08:39:24 <haskell202> not quite
08:39:32 <elben> merijn: yes, that‚Äôs true. I can say I am in the ‚Äúthings that go left-to-right makes more sense ala >>= and ‚Äòdo‚Äô notation‚Äù phase of ‚Äúplainly‚Äù
08:39:36 <haskell202> i want to keep the one that's already provided and recall the function
08:39:54 <c_wraith> elben: Hmm.  I don't have a good recommendation.
08:39:55 <nkaretnikov> what do you mean by recall the function?  what should it do?
08:40:04 <nkaretnikov> which function, also?
08:40:11 <haskell202> if the then only provides for example "tier" (animal) and he has already entered an animal it should then in the end print out two animals
08:40:27 <haskell202> the program should start itself new
08:40:31 <nkaretnikov> ah, got it
08:40:35 <haskell202> and the prompt should reaaper
08:40:39 <haskell202> *reappear
08:40:42 <nkaretnikov> haskell202: let me try
08:42:02 <elben> c_wraith: thanks for looking. I‚Äôm debugged it by compiling and running
08:42:40 <elben> it turns out it was working all along :)
08:42:56 * hackagebot second-transfer 0.5.5.0 - Second Transfer HTTP/2 web server  http://hackage.haskell.org/package/second-transfer-0.5.5.0 (dsign)
08:46:30 <nkaretnikov> haskell202: trying me version...
08:48:06 <haskell202> Hope it works!
08:50:41 <nkaretnikov> haskell202: will paste in a sec
08:53:04 <nkaretnikov> haskell202: something like this: https://gist.github.com/nkaretnikov/2cfec669c2297def5682
08:53:11 <IP92> I've got a module, that is imported by a .hs file, and when I load the .hs file to ghci, it compiles just fine, but when I try to execute functions from the module, it says out of scope
08:54:35 <haskell202> hm I don't really understand your code :/
08:54:38 <haskell202> can you explain it a bit?
08:54:50 <nkaretnikov> sure
08:55:37 <nkaretnikov> haskell202: basically, you need to "enter" main twice.  since you cannot directly call main, I defined a helper function 'loop'
08:55:56 <nkaretnikov> first, it's called with two empty lists that will be used to combine results later
08:56:12 <nkaretnikov> then, it prompts a user for an animal and an attribute
08:56:43 <haskell202> ok and what does this line?
08:56:44 <haskell202> split = intercalate ", " . filter (not . null)
08:57:13 <nkaretnikov> intercalate separates a list of string with commas
08:57:28 <nkaretnikov> filter removes empty lists, so we don't get results like ", dog"
08:57:28 * geekosaur notes that that looks more like what he'd calla  join than a split...
08:57:31 <elben> I have a `Compiler (Maybe String)`, where Compiler is a monad. I want an expression that returns `Compiler Bool`. True if the value is Just ‚Äútrue‚Äù, False otherwise. Can I improve this attempt: (\m -> case m of Just "true" -> True; _ -> False;) `fmap` (cm :: Compiler (Maybe String)). I hoogled for ‚ÄúMaybe String -> String -> Bool‚Äù and could not find a ready function.
08:57:45 <nkaretnikov> haskell202: you can try it in ghci
08:57:56 <nkaretnikov> > intercalate ", " ["foo"]
08:57:58 <lambdabot>  "foo"
08:58:01 <nkaretnikov> > intercalate ", " ["foo", ""]
08:58:03 <lambdabot>  "foo, "
08:58:15 <nkaretnikov> > intercalate ", " (filter (not . null) ["foo", ""])
08:58:17 <lambdabot>  "foo"
08:58:29 <nkaretnikov> this gets rid of the trailing comma
08:58:48 <haskell202> yes it works I know and it works in ghci
08:59:00 <nkaretnikov> okay, so do I need to explain any further?
08:59:03 <haskell202> but it's not quite what I wanted and therefore I have to change it a bit
08:59:13 <nkaretnikov> well, I just wanted to give you the gist
08:59:19 <nkaretnikov> which you could adapt
08:59:35 <nkaretnikov> the main idea is to have two helpers
08:59:46 <nkaretnikov> instead of just main and acc
08:59:56 <nkaretnikov> hth
09:00:01 <haskell202> those two helper are my [] [] aren't they?
09:00:13 <nkaretnikov> no, helpers are function, I mean loop and acc
09:00:33 <nkaretnikov> but you're right, [] [] are important because they are used to combine the results
09:01:33 <haskell202> acc (split [animal, animal']) (split [attribute, attribute'])
09:01:52 <nkaretnikov> is something not clear about this line?
09:01:55 <haskell202> what does this line?
09:02:05 <nkaretnikov> it calls the acc function with two arguments
09:02:09 <haskell202> yes
09:02:22 <haskell202> and split has what effect here?
09:02:24 <nkaretnikov> but first, it calls split to get a nice string
09:02:47 <haskell202> because i want to remove the split
09:02:50 <nkaretnikov> you could get rid of split and try acc (animal ++ animal') and (attribute ++ attribute')
09:03:13 <nkaretnikov> then try to call main with various inputs, you'll see how it affect the output
09:03:14 <elben> elben: ah, maybe False (=="true") (Just "true")
09:03:24 <nkaretnikov> haskell202: e.g., try omitting an animal or an attribute
09:04:11 <haskell202> ok thanks
09:04:22 <haskell202> I'll make some refinements to it
09:04:25 <nkaretnikov> np, feel free to ask if you have more questions
09:04:32 <haskell202> hope you are still here for some time?
09:04:47 <nkaretnikov> probably, but I might be busy :)
09:05:14 <nkaretnikov> there are other folks that would be happy to help you, though :)
09:05:55 <haskell202> why can't i put this putStrLn "Hi ! Gib zuerst dein Lieblingstier an und dann in die n√§chste Zeile Deine Lieblingseigenschaft ein:"
09:06:09 <nkaretnikov> where?
09:06:09 <haskell202> before the animal' <- getline
09:06:10 <haskell202> =
09:06:31 <nkaretnikov> you can, I see no reason for it to not work
09:06:51 <haskell202> it then says parse error on input animal'
09:07:17 <nkaretnikov> could you paste again?
09:07:21 <ChristianS> haskell202: possible an indentation problem, otherwise it should wokr
09:07:30 <nkaretnikov> animal' and putStrLn should be on the same column
09:07:44 <haskell202> http://lpaste.net/2118023002732888064
09:07:56 * hackagebot should-not-typecheck 0.1.0.0 - A HUnit/hspec assertion library to verify that an expression does not typecheck  http://hackage.haskell.org/package/should-not-typecheck-0.1.0.0 (CRogers)
09:07:57 <nkaretnikov> yeah
09:08:04 <nkaretnikov> re-indent putStrLn
09:08:13 <nkaretnikov> it must start at the same column as animal'
09:08:32 <nkaretnikov> identation is important
09:08:45 <haskell202> but it does start in the same colum?
09:08:58 <haskell202> ah shit 
09:09:00 <nkaretnikov> :)
09:09:00 <haskell202> not in my paste
09:09:06 <nkaretnikov> do you have tabs enabled?
09:09:07 <haskell202> but I tried that as well
09:09:11 <haskell202> yes
09:09:14 <nkaretnikov> disable them
09:09:19 <nkaretnikov> use spaces
09:09:50 <haskell202> ok
09:12:19 <haskell202> it really was an indnetation issue
09:12:21 <haskell202> thank you!
09:14:51 <haskell202> @nkaretnikov
09:14:51 <lambdabot> Unknown command, try @list
09:14:55 <haskell202> @list
09:14:55 <lambdabot> What module?  Try @listmodules for some ideas.
09:15:03 <haskell202> @listmodules
09:15:04 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
09:15:40 <haskell202> nkaretnikov: ok now I've got a problem
09:15:55 <haskell202> in the end when everything works out
09:16:05 <haskell202> i want to put the animal and the attribute in a sentence
09:16:11 <haskell202> but that does not work..
09:18:09 <haskell202> nkaretnikov!
09:19:22 <nkaretnikov_> ?
09:19:40 <haskell202> aah nevermind i was just so so stupid :D
09:21:55 <gubaaa> ns. Nothing on during. Most people are runna ma naes.
09:21:57 <gubaaa> It's a football players.
09:21:58 <gubaaa> Juni Joans Football game! Boyer game, it's a football game! Brucesht boyer game.
09:21:59 <gubaaa> Nothing but the world cares about a group of the football is the worst sport events on television. College football game, it's no lie it's a football game! It's a football. No one in most people are runna ma naes. It is on television.
09:22:01 <gubaaa> bucklegusk coyerst apprit's as no lie of that say ever my evis a groyer!
09:22:02 <gubaaa> The worst sport ever moyer coyer! Brucesht, boyer royer royer football game, so they go bored, makes me say oh my eyes it up, we'll game. I'm swearing on television is college football game! Raa Lynx game, it's a bratty asshole. Rum-dum-dum-football. No!
09:22:04 <gubaaa> Deep in most people are runna ma naes.
09:22:05 <gubaaa> Football game. Most as me time but football makes me say aftere. Cornbucklers ram agains, and ritter boyer royer the Jaguars. Most of the on is on teams than rears, uh, and othing on teams television. I'm swearing but thing Saturday oh moyer game. No on during but football.
09:22:06 <gubaaa> Deept the oh football paing of a my even thing oh ong ot moyer food. Excer cornbucept proyers.
09:22:08 <gubaaa> Notball. It wat wores, a Lown thision it's Most one na football. Excesht! Footbal game, afteler carege whand re telege it's th my and youtball ing. Colts, Cort about abor moyer! It so on drything whaturd, aboyers, but age th much otball go brucks a grout a foothe hens, aboys, my gam spors, ter!
09:22:09 <gubaaa> me! Raa Lynx game.
09:22:11 <gubaaa> Nothing prime but this stupid football players my eyes it sucks, and other ever. The one thing world cares about football.
09:22:12 <gubaaa> Juni Jonn Joans Football game! Raa Lynx game. It is good.
09:22:13 <gubaaa> otball is on during but this good. When he football game. It's a futball game, it's a soccer game. With more teams that's a lynx game! It is than regular football game. Lowers ram against each other, the worse thing on during. Most people are runna ma naes. Buck buckers, Cowboys, Ravens, Cornfuckers, Cornbuck buck buck.
09:22:15 <gubaaa> Football. After the football is a football is this stupid football.
09:22:16 <gubaaa> Nothing on is stupid fo
09:22:18 <gubaaa> nothing paint dry. Lowers ram against each other everything prime time but thing on television. Nothing but football. When he football. Nothing but a group of the world cares about as much fun as much fun as watching but football game. It is they go brucesht boyer! Boyer made. With more teams the Jaguars, Cornbucklers. Buck bucklers. No one of brucesht boyer! Brucesht boyer!
09:22:20 <gubaaa> It's ever maker carst ornbut funn Jon fuces. Notball! The its re foothision rucept the thight, Cordayer! Bruceshole then runn the thing is moyer! Brunna notballevis the a sht, upid tere the tens, buck fuck an durimes, maker! Then done boyery. Notball paing. Huskes, Cort it's a football go bucks so ball its a Low it's isiong Supiddle. Lower. Boyeah-yerything ort eaching boyes my eah-yer fut 
09:22:22 <gubaaa> the foothins Bruck colts Food. Whes ars. Exces. Ratupid foothing bou knothey evis and foothe footbagame! Brucker ma footbagame football! Brucer me, Cor games. No but foothat sht! The Notball its its game saing ong on It's mort so lon It's made. Ther! Nebruces, bout spornbut peop on time, Cort food. Wits telever gootball it's wore it's fuckleguare. Except ter my a football my so boyerege st 
09:22:23 <gubaaa> when drythe the tele thing Supid I'm rit's a football! I cort so of thing Satteler. Nothis thing ple Joach oh oh one it's its, showboys, Raa foothing but is approcces. nothis Fuck football.
09:22:23 <gubaaa> Notball. Wher. I coven as arege wors, it's re wor covents Boyery. Lower football. It's Bucklever bucestupid food. Nothe Joand football is ans shower Boyer go bou knowbou know ings an't spornhusking player game. I collever approyer most say ey aboye foothing per a swearball gams whatch muckes coverst boyer gams a my on rucker go bout but eame footbal gains, ision hes. Whe futball game. No ort 
09:22:24 <gubaaa> but football is me. Notball. Cowl, a game suckernhusking. I colts and cand ors, Cord, and football game, Corst it's and football is a football plevers, It's thing otball. No otballevis rou knowl, wat but football game. I'm and you knotbal isionn on ing boys, wheshowboyer lie football. It's an ong paing otball aftelevers, Cornbut wort bucklevisione foothing.
09:22:26 <Clint> @where ops
09:22:26 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
09:22:26 <gubaaa> Juni Joand of televis suck Huskers, It's game ther go otball game, It sht, uh, mors, say lon I'm sht, Cowboyer. Brucept show it's a suckle roach of the thing brucep on thing boys, socces Thents, Cort eyers. Boys, Raverse ing ot evis appring play game. Buces, uh, Coll grou knowboyer lor my game ter coll and on.
09:22:27 <gubaaa> Stop lawyyer and football. After the football. Nothing but the football.
09:22:29 <gubaaa> The worst sport events on television. Nothings ever shown on television is this garbage here. I'm swearing. Most of the worse this stupid foot ball game. When August approaches, and other, the worst the Super Bowl, ever shown on television. Nothing prime but as watch.
09:22:30 <gubaaa> Nothing but the worse that football or long Saturday after the Jaguars, Cornfuckers, Cornfuckers, Cornbuck. Husk, cornhusk. Husk, cornhuskers, Cornbuck. Husk, cornbucklers. It is they go boyer football game. It's a soccer game. It's a lynx game, it's a futball game. It sucks ten regular football game. It's a soccer game, it's a soccer game.
09:22:42 <jmcarthur> wow that was an impressive one
09:22:48 <geekosaur> o.O
09:22:50 <arthurvr> lol
09:23:39 <wei2912> i wonder if that was a bot
09:24:01 <geekosaur> looks like output from a markov bot to me?
09:24:19 <geekosaur> you can guess what it was fed with
09:25:11 <int-e> these things make me lose all hope in humanity...
09:25:46 <int-e> @quote
09:25:46 <lambdabot> tac-tics says: If you wish to create the universe from scratch, you must first invent the continuation.
09:27:54 --- mode: ChanServ set +o dibblego
09:28:14 --- mode: dibblego set -o dibblego
09:30:37 <haskell202> http://lpaste.net/5325947102751096832
09:30:47 <haskell202> how can i get spaces between my attributes?
09:31:34 <nkaretnikov> haskell202: have you tried unwords, which I just suggested?
09:31:49 <haskell202> what are unwords?
09:31:53 <Clint> :t unwords
09:31:54 <nkaretnikov> it's a function
09:31:54 <lambdabot> [String] -> String
09:32:03 <nkaretnikov> > unwords ["foo", "bar"]
09:32:04 <lambdabot>  "foo bar"
09:32:34 <nkaretnikov> just replace "foo" and "bar" with animal' and animal
09:32:40 <nkaretnikov> ditto for attributes
09:32:44 * nkaretnikov goes afk for a bit
09:34:37 <Maerten> Hi, Ive just build my project with cabal, and noticed that the resulting binary contains all kinds of references to locations in my homedirectory, e.g. /home/blabla/Myproject/.cabal-sandbox/lib/x86_64-osx-ghc-7.10.1/thyme_1iRdJ7bBirS04fUdUEXgJl
09:36:12 <Maerten> using 'strip' on the binary didn't remove the references to my local cabal sandbox and homedirectory name. 
09:37:04 <Maerten> also it's possible to view all defined typenames.
09:37:26 <Maerten> does anyone here know of a way to strip these from the binary?
09:38:02 <geekosaur> I think OS X uses dynamic objects by default, and OS X always uses full path references to dynamic objects. you will need to copy those objects elsewhere and use install_name_tool to point the references to their new location
09:38:35 <geekosaur> or, you can see if you can build statically (although Apple strongly deprecates that)
09:38:52 <geekosaur> basically, you are seeing the dynamic symbol table
09:40:24 <geekosaur> (the same happens on Linux except that ELF shared object references are relative, so instead of every shared object having a full path there is an rpath entry pointing to them)
09:43:17 <haskell202> unwords doesn't work for me...
09:43:21 <sbrg> so haskell-mode for emacs is amazing. it's like lightyears ahead of anything available in vim.
09:43:25 <haskell202> does anoyone have another idea?
09:43:35 <sbrg> well, maybe not, but it's much more robust and polished
09:43:39 <Maerten> thanks geekosaur! 
09:44:08 <Maerten> i will now use upx to pack the binary, kind of hides the symbols too and makes the binary smaller
09:52:59 * hackagebot rest-gen 0.17.1 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.17.1 (AdamBergmark)
09:57:42 <int-e> Maerten: apparently Cabal adds -rpath linker options even when not producing a dynamically linked executable. you could build with cabal build -v and edit the final command line(s) that links the program(s)...
10:05:25 <Maerten> int-e: it was the last command with -rpath. i removed all occurences of -rpath, but i can still see package names + paths in the binary.
10:06:22 <int-e> Maerten: hmm, even after stripping? that worked in my toy test, but I'm on Linux and I didn't add a whole lot of dependencies
10:09:37 <geekosaur> linux's strings hides a lot more by default
10:10:17 <geekosaur> in particular BSDish strings like OS X uses will show dynamic symbols, whereas libbfd strings skips those segments
10:10:59 <mauke> strings -a
10:14:08 <int-e> hmm, strings -a seems to be the default for me anyway
10:16:34 <Jello_Raptor> Bah this is frustrating, I'm still trying to get a nice existential dictionary abstraction working.
10:17:58 <kuribas> Is it possible to specify a minimum ghc version in cabal?
10:18:00 * hackagebot smoothie 0.2.2 - Smooth curves via several splines and polynomials.  http://hackage.haskell.org/package/smoothie-0.2.2 (DimitriSabadie)
10:18:15 <Jello_Raptor> now the compiler is telling me I might want RankNTypes but that shouldn't be the case http://lpaste.net/135346 
10:19:25 <Jello_Raptor> I think the explicit "forall" is getting expanded in some way that I don't understand. 
10:20:20 <Jello_Raptor> (and yes, the instance declaration there is all wrong anyway :/ )]
10:20:29 <geekosaur> the explicit forall in data Dict k v is rank 2
10:21:25 <int-e> kuribas: you can do it indirectly (by requiring a minimum version of the base package) or in a roundabout way with conditionals: if impl(ghc < 7.10) Buildable: false
10:21:27 <Jello_Raptor> geekosaur: how so? the forall applies tot he entire signature, rather than within one component of it. 
10:21:51 <kuribas> int-e: it's mostly for the supported extensions
10:21:57 <geekosaur> yes, the problem is it applies to the entire signature... and is not typeable outside of the signature
10:22:05 <geekosaur> yet you have _dictData :: d
10:22:32 <geekosaur> which maeks _dictData rank-2
10:22:48 <int-e> kuribas: you can also list extensions, with the extensions: stanza
10:23:27 <kuribas> int-e: ok, thanks.
10:23:47 <kuribas> int-e: does cabal do a compatibility check agains the compiler?
10:23:53 <cpup> how can i make `Eq (r i o)` required for `class Rule (r :: * -> * -> *)`?
10:24:35 <sm> g'day all
10:25:14 <Jello_Raptor> geekosaur: hmm, i think i need to read up on how rankNtypes interact with records more, since my model seem sto only work when they're used in functions. 
10:26:02 <supki> Jello_Raptor: Lens' s a is a rank-2 type
10:26:42 <supki> it expands to (forall f. Functor f => (a -> f a) -> s -> f s)
10:26:56 <kuribas> cpup: I think such requirements are put on class methods, not the class itself.
10:26:58 <Jello_Raptor> supki: ahh, that too because of that (forall f. functor f => a -> f b) bit
10:27:17 <sm> something I've never seen discussed: when profiling a parsec parser, the "call stacks" in the .prof do not match what the code structure. It's reported as if every subsequent parser, even same or higher-level ones, were called by the first parser
10:27:37 <int-e> kuribas: funny, I don't think I've ever tested that. But it's supposed to.
10:28:00 <geekosaur> Jello_Raptor, if it helps, had Dict been parameterized by d as well as k and v, the top level forall would have done what you expected
10:28:05 <Maerten> int-e: yes stripping doesnt help.. maybe i'm doing something wrong but for now i'll just go with packing the file with 'upx'
10:28:06 <sm> does this happen with all the combinator-style parsing libs ? Are there any ways to make it clearer ?
10:28:43 <merijn> sm: Did you compile with auto hotspots?
10:28:48 <cpup> kuribas: what about Ord which is defined as `class Eq a => Ord a where`? But that only works when `a :: *`
10:28:58 <sm> merijn: with -fprof-auto  ? yes
10:29:00 <Jello_Raptor> geekosaur: hmm, but that would force me to have a "forall d." whenever i used a "Dict k v d" to get the behavior I want, no?
10:29:02 <kuribas> cpup: ah, good point.
10:29:10 <geekosaur> (actually that *is* the key point here; the forall serves only as an explicit declaration, 'd' only exists in the `data` declaration and cannot be typed outside of it, hence using it as anything other than a phantom makes it rank 2)
10:29:15 <merijn> sm: I think it's "-fprof-auto-all" you want, lemme check
10:29:33 <geekosaur> Jello_Raptor, if so then you are *definitely* doing rank-2 stuff
10:29:39 <merijn> sm: I use "GHC-Prof-Options:     -auto-all -caf-all -rtsopts"
10:29:59 <Jello_Raptor> geekosaur: ahh, okay. 
10:30:05 <sm> my profile it shows all the parser functions, they just keep "indenting forever" which obscures the actual call structure. Would those options help ?
10:30:08 <merijn> sm: Did you look at the RWH chapter on profiling too?
10:30:18 <sm> I have not 
10:30:41 <merijn> sm: It's been awhile since I did profiling, but that chapter was pretty good, 20 or 21 or something
10:32:08 <sm> that's out of date but may have additional tips, thanks. I've read the GHC user guide chapter many times 
10:32:14 <kuribas> cpup: Have you tried just  class Eq r => Rule r where ... ?
10:32:50 <sm> it's -fprof-auto nowadays, btw
10:33:18 <OutlawStar> does it make sense to use blaze-builder for only a couple hundred bytes of text?
10:33:23 <merijn> sm: That option is in my current cabal file and I wasn't getting any errors yet, so...
10:33:31 <merijn> OutlawStar: As opposed to?
10:33:41 <OutlawStar> byte string concat
10:34:57 <RyanGlScott> Is there an equivalent of `catch` for Template Haskell expressions? (i.e., the Q type?)
10:35:01 * sm double-checks.. https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flag-reference.html#idp15279008 are the latest, but I wouldn't be surprised if old ones also work
10:35:29 <sm> so has anybody else tried profiling a parser ?
10:35:54 <cpup> kuribas: except that `Eq a` requires `a :: *` where i need `r :: * -> * -> *` http://lpaste.net/135348
10:37:13 <felixn> Couldn't match expected type ‚ÄòPortNumber‚Äô with actual type ‚ÄòInt‚Äô <-- I feel dumb, isn't Int of Num?  why can't I do this ;_;
10:38:03 <Hafydd> felixn: what does that have to do with Int being an instance of Num?
10:38:49 <felixn> I don't even know, I just want this port number I parsed from the URI to work
10:39:21 <mauke> felixn: can I see your code?
10:40:02 <kuribas> cpup: How would an Eq instance to a (* -> *) kind work?
10:40:10 <merijn> felixn: fromIntegral
10:40:14 <merijn> :t fromIntegral
10:40:15 <lambdabot> (Integral a, Num b) => a -> b
10:40:21 <merijn> :t fromIntegral :: Int -> PortNumber
10:40:22 <lambdabot>     Not in scope: type constructor or class ‚ÄòPortNumber‚Äô
10:40:29 <merijn> oh well, you get the idea
10:41:02 <meditans> I'll ask a question which is a bit theoretical here, but I think some of you may know an answer
10:41:27 <felixn> merijn: that made it happy, basically I have (ftpUriToPort :: URI -> Int) and then (connectTCP :: Host -> PortNumber)
10:41:44 <merijn> felixn: PortNumber is a different type from Int
10:41:48 <kuribas> cpup: perhaps you need MultiParamTypeClasses.
10:41:50 <meditans> we know that we cannot write an optimal compiler, because it would reduce a non terminating computation to a single instruction loop
10:41:51 <cpup> kuribas: i don't think it would. i think i want something like `forall i o. Eq (r i o)`
10:41:55 <felixn> merijn: yea I just realized the newtype
10:41:58 <meditans> thus violating the halting problem
10:42:01 <sm> separate question: I'm looking for something more modern to rewrite my parsec parsers on, with equally good error reporting and hopefully more speed. I like the look of polyparse, or uu-parsinglib, but I wonder why they have only 15 & 19 reverse dependencies (vs 436 for attoparsec & 733 for parsec). Any recommendations ?
10:42:16 <felixn> sm: why the parsec hate?
10:42:17 <rbocquet> cpup: it is not possible
10:42:22 <merijn> felixn: And wherever you got your ftpUriPort function from decided to use Int instead. But since both are Num instances you can use fromIntegral to change
10:42:23 <meditans> but what if the language is total? Do we get in that case the possibility of an optimal compiler?
10:42:33 <merijn> sm: What's wrong with attoparsec?
10:42:50 <DNoved1> meditans, have you seen morte? That's the idea behind it, more or less.
10:43:08 <merijn> felixn: To be fair, parsec is kinda slow
10:43:13 <sm> no hate, I love parsec. But eg polyparse seems more maintained, simpler, cleaner, and promises easier programming (backtracking by default)
10:43:21 <rbocquet> cpup: you can add a (proof :: forall i o. Dict (Eq (r i o))) to your class however
10:43:29 <sm> attoparsec is always described as having sub-par error handling
10:43:29 <Hafydd> I would hope there's an explicit constructor for PortNumber that you could use instead, however.
10:43:35 <felixn> merijn: https://gist.github.com/munro/46ce80ad934cfb98a6aa <-- hmm, yea I should make this return PortNumber, should I not read to an Int?
10:43:41 <kuribas> cpup: maybe: class Eq (r a) => Rule (r :: * -> *) a where ... ?
10:44:07 <merijn> sm: "more maintained"? I've seen people claim that parsec isn't maintained a lot, but my question is "what sort of maintenance does it need, beyond fixing so it compiles if/when it breaks?"
10:44:31 <merijn> felixn: You shouldn't use read at all :(
10:44:34 <kuribas> cpup: But in that case the kind signature is redundant.
10:44:53 <Hafydd> felixn: you might find maybe :: b -> (a -> b) -> Maybe a -> b useful.
10:45:08 <merijn> felixn: Text.Read.readMaybe
10:45:11 <geekosaur> Hafydd, there used to be, it was deprecated
10:45:22 <Hafydd> It was deprecated?! Why?
10:45:26 <cpup> rbocquet: what is Dict? i can't find it using hoogle
10:45:32 <sm> merijn: parsec is maintained sufficiently, but all else being equal, a package with a seemingly more active maintainer (eg working on getting it to replace Read) is an advantage
10:45:52 <geekosaur> Hafydd, felixn, the problem is that PortNum exposed a low level detail, namely that port numbers are in *network* byte order, not *host* byte order
10:45:56 <geekosaur> this caused major pain
10:45:57 <sm> parsec docs have not been maintained sufficiently for years
10:46:15 <meditans> DNoved1: yes, I saw the announcement, I'm not sure on the theory behind.
10:46:17 <Hafydd> Oh, you mean the constructor, not maybe.
10:46:18 <geekosaur> but can't really be changed without breaking all existing code using the network package
10:46:33 <geekosaur> so for years the story has been "use fromIntegral and never ever use PortNum"
10:46:36 <meditans> DNoved1: so, he can in fact build an optimal compiler for that language?
10:46:44 <Hafydd> I see.
10:46:55 <meditans> DNoved1: I already know that's strongly normalizing.
10:47:10 <DNoved1> meditans: Basically, as I understand it, morte dissallows general recursion but allows non-termination through the use of coalgerbras
10:47:24 <DNoved1> So then the optimizing compiler just inlines... everything
10:48:00 <DNoved1> It's optimal, for a certain definition of optimal. Notably, there is the issue of code size.
10:48:01 <geekosaur> (I think the fact that PortNum isn't even visible in the latest network suggests that they're finally reaching a point where they can fix it properly)
10:48:03 <felixn> sm: one idiom that I do is "expression = try $ do ...", most of time I'm dealing with chunks of ast where I want backtracking, it works really well
10:48:20 <meditans> DNoved1: I clearly should read more about that project, thanks; expecially on admitting non termination through coalgebra and still getting the optimal compiler
10:48:25 <alexmob> teste
10:48:27 <sm> felixn: yes, my parsers are full of those
10:48:40 <sm> and they were quite hard to write
10:48:40 <meditans> DNoved1: do you happen to have any pointers other than his blog?
10:48:47 <DNoved1> Which because of instruction caches can end up impacting performance. I would say that an optimal compiler is actually impossible, becuase you always need to make compromises.
10:48:57 <felixn> geekosaur: that makes sense, so using Num makes it abstract, and the lower level impl will encode it properly?
10:49:26 <geekosaur> yes, the Num instance on PortNumber does conversion to/from network byte order
10:49:39 <geekosaur> without requiring you to be aware of it, as the PortNum constructor required
10:49:44 <mauke> PortNumber is only nominally an Int internally
10:49:49 <DNoved1> Hmm, aside from the blog... I found having previously read about, scott encoding I think it was, that the explanation of encoding as algerbras made more sense to me.
10:49:58 <mauke> it's really a sequence of bytes that happens to be encoded in the wrong type
10:50:06 <felixn> sm: nooo, it should be easy, I swear.  also, I feel like parsec is "done" for the most part, "maintained" shouldn't mean updating stuff for the fun of it :D
10:50:08 <DNoved1> Let me see if I can find the article that I recall liking for its explanation of them.
10:50:08 <sm> polyparse has "commit", which is the dual of try, which they say is an easier default
10:50:14 <Vektorweg1> is there a intermediate language that represents haskell plus applied extensions in an easy fashion? 
10:50:21 <meditans> DNoved1: thank you very much!
10:52:05 <ansible1> do MVars use spinlocks underneath?  I had some code that used MVars, and it went to 100% on my ARM computer.  Changed to IORefs and everythings fine.  
10:52:06 <OliviaDelNero> ansible1, but why?
10:52:38 <merijn> ansible1: No, they sleep whenever they fail to grab the MVar
10:52:40 <OliviaDelNero> merijn, what you need?
10:52:47 <maerwald> sm: just throwing in this... afaik applicative combinators can be more easily optimized by the compiler than monadic stuff (at least, I read that somewhere)... are all your parsers written in monadic style?
10:53:04 <merijn> ansible1: They might use a spinlock to grab them, but if they fail the thread is suspended and blocked
10:53:11 <merijn> ansible1: IORef's do use spinlocks
10:53:48 <maerwald> afair that's also why people want doA so that it may automagically desugar monadic do-notation into applicative stuff if possible
10:55:30 <cpup> kuribas: for some reason i thought that wouldn't work well, but testing it out, it seemed to work well
10:55:31 <OliviaDelNero> cpup, yes, please
10:56:07 <cpup> kuribas++
10:56:14 <kuribas> cpup: :-)
10:56:15 <OliviaDelNero> kuribas, I approve
10:56:21 <sm> maerwald: they are.. I do use a lot of state
10:56:24 <OliviaDelNero> sm, lol
10:56:56 <ansible1> merijn: ok thx.  if there was an MVar deadlock, would that cause 100% cpu usage?  I wouldn't expect that.  
10:56:56 <OliviaDelNero> ansible1, common think about
10:57:12 --- mode: ChanServ set +o geekosaur
10:57:14 <maerwald> do I smell a bot here?
10:57:14 <merijn> ansible1: No, MVar deadlock would cause 0% with all threads suspended
10:57:15 <OliviaDelNero> merijn, common think about
10:57:21 --- mode: geekosaur set +b *!*@189.40.91.15
10:57:21 --- kick: OliviaDelNero was kicked by geekosaur (OliviaDelNero)
10:57:35 <geekosaur> ...yes, yes you do
10:57:42 --- mode: geekosaur set -o geekosaur
10:57:50 <merijn> ansible1: Well, maybe if you use the multithreaded backend it might be spinning due to lack of runnable threads?
10:58:19 <maerwald> sm: well, then I guess one way of trying to optimize your parser stuff could be to figure out if you can rewrite some of them in applicative combinators... but that could probably be painful
10:58:29 <sm> maerwald: I'd like to see where applicative combinators might help, but I'll port the esiting monadic parsers first
10:58:38 <sm> existing
10:59:27 <sm> I guess I need to try one or two or three other libs and see which I like
10:59:38 <CapitalSigma> is there some convention to follow for whether i stick a new module in e.g. System.Posix.Foo.* or just Foo.*?
11:00:01 <CapitalSigma> i see reactive-banana uses its own toplevel name but most packages i use don't
11:00:14 <lamefun> Why are there so many Haskell extensions?
11:00:44 <maerwald> lamefun: you mean GHC extensions?
11:00:46 <sm> and perhaps make a http://hackage.haskell.org/package/parsers instance for polyparse
11:00:57 <hodapp> geekosaur: lamest bot ever.
11:01:10 <lamefun> yes, GHC extensions
11:01:11 <geekosaur> seems to be that kind of day on freenode >.>
11:01:12 <DNoved1> meditans: Sorry, for the life of me I can't seem to find the article. The wikipedia page on Scott encoding explains it decently, but not as well as the page I seem to recall but can't find.
11:01:20 <hodapp> geekosaur: I guess I'm not missing much then.
11:01:40 <meditans> DNoved1: don't worry. Was it maybe "A tutorial on (co)algebras and (co)induction"?
11:02:57 <meditans> DNoved1: otherwise, if you remember the name of the paper, ping me! :)
11:02:57 <maerwald> lamefun: well, adding extensions to the compiler only is easier than adding stuff to the actual language
11:03:30 <DNoved1> meditans: can do
11:04:30 <Cale> lamefun: Basically whenever some new feature *can* be an extension, it might as well be
11:04:54 <rbocquet> cpup: https://hackage.haskell.org/package/constraints-0.3.0.1/docs/Data-Constraint.html
11:04:56 <Cale> lamefun: That way you have fewer difficulties compiling old code (there are enough already)
11:04:58 <maerwald> and since there is not a lot of competition going on in the compiler world, there is not much pressure to move features to the language
11:05:19 <ansible1> merijn: hmmm no idea about the backend.  just using the default settings on a yesod project.  I'm relieved it works with ioref, anyway.  
11:05:35 <CapitalSigma> lamefun: also, people who use haskell tend to be interested in programming languages
11:05:53 <Cale> Yeah, not only that, but the system of extensions is in the standard, so other compilers end up supporting some subset of the extensions GHC does as well
11:07:12 <maerwald> Cale: until someone wants to actually *switch* to a different compiler (same story for clang)... which causes a huge amount of work in the whole eco-system to get into one line again
11:07:30 <maerwald> and that's often left to distributors...
11:08:23 <maerwald> because people started to rely on GHC behavior (or gcc memory layout)
11:13:57 <timothyh> hey, anyone good with numeric-prelude?
11:16:55 <gallabytes> @djinn ((Either p (p -> a)) -> a) -> a
11:16:55 <lambdabot> f a = a (Right (\ b -> a (Left b)))
11:17:59 <gallabytes> @pl \a -> Right (\b -> a (Left b))
11:18:00 <lambdabot> Right . (. Left)
11:18:17 <gallabytes> @pl \a -> a (Right (\b -> a (Left b)))
11:18:17 <lambdabot> ap id (Right . (. Left))
11:18:47 <kuribas> Is it safe to use PatternSynonyms?
11:19:27 <kuribas> It restricts users to ghc >= 7.8
11:21:21 <kadoban> kuribas: At least at the moment, that's not much of a constraint as far as I can see. I don't see many people using a haskell compiler that doesn't match that.
11:23:21 <meditans> DNoved1: also, if you are familiar with Scott encodings and have time to spare, could you give me your opinions on this question http://mathoverflow.net/questions/210273/on-an-automatic-translation-of-typed-lambda-calculus-in-untyped-lambda-calculus
11:23:56 <dmj`> can anyone recommend a good jwt library for haskell? There seems to be ~3
11:26:21 <merijn> kuribas: Define safe?
11:26:46 <kuribas> kadoban: I have an old laptop with Mint 13 and ghc 7.4.1
11:27:03 <geekosaur> debian oldstable was ghc 7.6, people still on it
11:27:17 <kuribas> merijn: I mean usable by most people.
11:27:23 <geekosaur> I thought mint 17 was ghc 7.8.3 but it looks like it's likewise 7.6.3, sigh
11:27:58 <Clint> debian stable is 7.6.3
11:28:08 <geekosaur> still? siiiigh
11:28:13 <Clint> next one will be >= 7.10
11:28:30 <geekosaur> thought they revved with newstable/wheezy. guess that explains why mint is still 7.6 :/
11:28:42 <Clint> no, 7.8 was too problematic at the time
11:29:11 <Clint> now 7.8.4's in stretch
11:29:19 <Myrl-oneechan> People here are pretty good with math, is there some rules when it comes to approximation?
11:29:31 <Myrl-oneechan> Like, `x \approx x + y` if `y \approx 0`
11:30:20 <kuribas> Myrl-oneechan: what does that mean?
11:33:17 <Myrl-oneechan> kuribas: I want to know if y is approximately 0, then x is approximately x + y.
11:34:43 <DNoved1> meditans: I'm not sure about most of that, however with regards to the second part about extending this sort of inductive style to dependent types - there's epigram, which I recall uses a similar style of introduction/elimination and supports dependent types. I've never used it myself though.
11:34:57 <kuribas> Myrl-oneechan: if x is small relative to y, then that doesn't hold.
11:35:10 <Myrl-oneechan> kuribas: true.
11:35:33 <kuribas> > let x = 1e-22; y = 1e-20 in x+y
11:35:35 <lambdabot>  1.01e-20
11:36:45 <kuribas> Myrl-oneechan: It's better to look at relative error.
11:37:48 <Myrl-oneechan> kuribas: Yeah.
11:53:03 * hackagebot webdriver 0.6.2 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-0.6.2 (AdamCurtis)
11:58:29 <sbrg> Myrl-oneechan: \lim_{y \rightarrow 0} x + y = x ?
12:03:04 * hackagebot intricacy 0.5.5 - A game of competitive puzzle-design  http://hackage.haskell.org/package/intricacy-0.5.5 (mbays)
12:05:03 <Myrl-oneechan> sbrg: Ah.
12:05:28 <Myrl-oneechan> Going to sleep now.
12:16:54 <felixn> anyone do realtime video processing with haskell?  I want to do basic object detection with my webcam
12:22:45 <evenex> i can use a 1-adic boolean function to evaluate if every item in a list meets some condition (the hof is called every or all)... what do I call it when i have a list of functions that i apply to a single value?
12:23:00 <evenex> and what's this pattern in general?
12:23:50 <kuribas> evenex: you mean [a -> b] -> a -> [b]?
12:24:54 <sinelaw> hey, implementing Eq instance for a newtype, seems like there's a performance overhead on == now
12:24:59 <sinelaw> does that make sense? 
12:25:01 <evenex> kuribas: yes, i think so
12:25:28 <kuribas> > sequence [(+1), (*3)] 4 -- evenex
12:25:30 <lambdabot>  [5,12]
12:25:38 <magneticDuck> @type (flip map .) . flip id
12:25:39 <lambdabot> b1 -> (b1 -> [a]) -> (a -> b) -> [b]
12:25:42 <magneticDuck> uhhh
12:26:38 <magneticDuck> @pf (\fs x -> map ($ x) fs)
12:26:38 <lambdabot> Maybe you meant: pl bf
12:26:42 <magneticDuck> @pl (\fs x -> map ($ x) fs)
12:26:42 <lambdabot> flip (map . flip id)
12:26:47 <magneticDuck> yeah, that
12:26:53 <evenex> kuribas: thanks
12:27:08 <kuribas> :t sequence
12:27:10 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
12:28:02 <kuribas> The monad is (->), the Traversable []
12:29:24 <kuribas> @pl id . id . id
12:29:24 <lambdabot> id
12:31:02 <kuribas> sinelaw: There is always some performance overhead when using typeclasses, but specialization helps with that.
12:31:04 <evenex> kuribas: to put it another way (at the risk of butchering the meaning), is it correct to say sequence is monadic (or step-by-step) application over a traversable structure?
12:32:19 <kuribas> evenex: I guess... I am not sure about the step by step though
12:32:40 <evenex> kuribas: is it fair to say that a monad is sort of a fold over functions?
12:33:55 <sinelaw> kuribas, what do you mean specialization helps?
12:34:03 <kuribas> evenex: well, I am no expert, but I don't think it is...
12:34:57 <kuribas> sinelaw: You can ask ghc to specialize the function, so it writes a seperate implementation for your type.  It will sometimes do so automatically.
12:36:51 <kuribas> evenex: (->) is a particular monad, but not all monads are functions. 
12:37:21 <kadoban> evenex: That doesn't sound right at all. Monad in haskell is really just ‚Ä¶ something that has (>>=) and return that follow some basic laws. What each one means kind of depends on what it is. You'll have a decently hard time coming up with a single description of what IO, [], Maybe, etc.'s Monad implementation means, except something very general like "computation in a context"
12:40:33 <kuribas> evenex: The monad instance for (->) is also called the reader monad.  You can think of it as something that needs context to operate.
12:43:23 <kuribas> So in this case (m a) == ([a -> b]) is a list of values that take a context and produce a value, and m [a] == a -> [m b], takes a context, and produces a list of values.
12:44:16 <kuribas> Hm, should be [m a] == [a -> b].
12:46:31 <evenex> so, if i have some hof i called "and" with signature [a -> bool] -> a -> [bool], then "a" is the context, and [bool] is my list of values... what plays the role of "m"?
12:46:34 <sinelaw> kuribas, it either warns me about "Ignoring useless SPECIALISE pragma for class method selector ë==í"
12:46:58 <sinelaw> kuribas, or if I manually implement == to call another function, which I do specialize, it makes performance worse
12:47:36 <kuribas> sinelaw: can you post the code?  You shouldn't normally have to worry about it unless it is a bottleneck.
12:47:43 <kuribas> Which you can only find with profiling.
12:48:44 <sinelaw> which I'm doing. i have several bottlenecks, this one isn't the worst
12:49:10 <sinelaw> I'll look at the others for now
12:49:22 <kadoban> evenex: Not everything is Monadic. That doesn't appear to have anything in particular to do with Monads, unless I missed something?
12:50:42 <saep> > and $ map (\predicate -> predicate 7) [\x -> x < 8, \x -> x > 4, \x -> x == 7]
12:50:43 <lambdabot>  True
12:51:45 <evenex> kadoban: if anything, I'm the one missing something :) I'm just trying to figure out how to break this weird "and" hof i wrote into orthogonal pieces
12:51:50 <kuribas> evenex: "m" is the type variable representing a monad instance.
12:52:45 <kadoban> evenex: Personally I'd probably just use ($) and map, I guess?
12:52:50 <kuribas> evenex: you can write "\x -> x < 8" as "(< 8)"
12:54:10 <kuribas> evenex: that's a very convenient haskell syntactic feature called a "section".
12:54:42 <yayfoxes> what's a learning exercise that'll teach me lists? how about a function that outputs a list of fibonacci numbers?
12:55:07 <yayfoxes> if you know anything else...something dealing with a list of lists or anything
12:55:20 <lingxiao> So I'm trying to install threadscope on OS X
12:55:23 <lingxiao> and oh boy ... :(
12:55:28 <hpc> yayfoxes: write an infinite list of consecutive numbers without using [1..] or similar
12:55:36 <hpc> yayfoxes: then an infinite list of square numbers, then fibs
12:55:42 <lingxiao> does anyone have experience? I'm following this page right now: https://wiki.haskell.org/Gtk2Hs/Mac
12:55:43 <kadoban> yayfoxes: Most teaching material should cover lists, they're pretty fundamental to haskell. Are you following a guide or tutorial or book or something?
12:55:51 <lingxiao> and I hit a snag that I can't seem to figure out
12:56:37 <hpc> yayfoxes: it's a nice progression so you aren't getting snagged on "writing an infinite list recursively" and "write an infinite list where each element depends on previous elements" at the same time
12:57:01 <kuribas> :t and
12:57:02 <lambdabot> Foldable t => t Bool -> Bool
12:57:04 <yayfoxes> kadoban: I'm reading Learn You A Haskell For Great Good
12:57:19 <toad_> hey! do you guys also have a good understanding of type rules and lambda deductions?
12:57:24 <toad_> I could use some help
12:57:27 <yayfoxes> I am just starting out with programming and Haskell as well
12:57:32 <saep> @src and
12:57:32 <lambdabot> and  = foldr (&&) True
12:57:56 <saep> @src all
12:57:56 <lambdabot> all p = and . map p
12:58:51 <toad_> no one knows anything aboud lamba calculus?
12:59:01 <citizen11> What's there to know?
12:59:09 <hpc> yayfoxes: for the most part, lyah covers things in the right order and the progression of concepts is quite smooth
12:59:37 <kadoban> yayfoxes: You should consider switching to https://github.com/bitemyapp/learnhaskell 's recommendation (cis194). LYAH's lack of exercises never improves, there's none in the whole thing.
12:59:58 <toad_> i have to create a typerule for a case expression and I'm a bit clueless
13:00:19 <toad_> case e1 of {Nothing -> e2;Just x -> e3}
13:00:21 <evenex> i actually am writing all this in D, i just come to the haskell channel because i find the haskell abstractions and thought process very powerful and elegant
13:00:36 <toad_> I know that e1, e2 and e3 have the same type probably
13:01:42 <Cale> toad_: There's no reason for e1 to have the same type as e2 or e3
13:01:46 <evenex> but yeah "and" is basically "all" over a list created by a sequence of functions applied to a single item
13:01:56 <Cale> toad_: But e2 and e3 had better have the same type
13:02:18 <Cale> toad_: e1 must have a type of the form Maybe t
13:03:18 <toad_> but can e2 and e3 be the same type if one is nothgin and the other one is just x?
13:03:25 <gamegoblin> Has anyone gotten this error when running tests
13:03:26 <gamegoblin> Test suite test-grantslatton: RUNNING...
13:03:26 <gamegoblin> 	cabal: Prelude.read: no parse
13:03:43 <gamegoblin> I am not doing any reading anywhere, I think it‚Äôs internal to cabal
13:04:09 <ChristianS> toad_: e2 and e3 can both be whatever you like, as long as both have the same type
13:04:40 <ReinH> Cale: Is there a good categorical explanation of final encodings written up anywhere? (I'm reading tagless-final and not really gettin what I want out of it...)
13:04:57 <ChristianS> toad_: of course, you probably want to use x to create e3, so that constrains your choice a bit
13:05:03 <ReinH> Cale: They're terminal objects in some coalgebra category blah blah blah right? Is this formalized anywhere?
13:05:45 <toad_> would a correct type rule be this then?
13:05:46 <toad_> e1:: Maybe A e2::B e3::B
13:06:40 <toad_> of course with the kontext in front of it but I don't know how to write that here
13:07:54 <lingxiao> has anyone installed threadscope on OS X?
13:08:30 <ChristianS> toad_: yes
13:09:24 <ChristianS> toad_: except that type variables are written lowercase (a, b instead of A, B)
13:09:26 <toad_> but wait don't i have to use x too?
13:09:45 <ChristianS> toad_: you don't have to, but you probably want to
13:10:09 <toad_> so x is the same type as e2 and e3 or is it?
13:10:30 <ChristianS> toad_: no, you just need any function of type a -> b
13:10:53 <toad_> why's that?
13:11:06 <Cale> ReinH: No idea. I'd expect someone to have done it somewhere?
13:11:17 <ChristianS> toad_: so you can apply that function to x
13:12:15 <toad_> ok just to be correct: above the case rule i had in the beginning I write this
13:12:30 <toad_> e1::a e2::b x::a->b e3::b
13:12:33 <toad_> is that correct?
13:12:56 <ChristianS> toad_: no, you don't write anything like that. what are you actually trying to do?
13:13:39 <lamefun> If I ignore String = [Char] completely and use only Data.Text, do I lose anything?
13:14:16 <ChristianS> lamefun: sometimes you'll need String, but using Text wherever you can is a good idea
13:14:47 <hpc> you also need to use different imports and remember which is which
13:14:53 <hpc> but it's usually pretty straightforward
13:15:42 <toad__> hello?
13:15:55 <toad__> I'm sorry my internet connection is pretty shitty
13:16:01 <ChristianS> toad_: say if you have a function: f a = case a of { Nothing -> 0; Just x -> length x }
13:16:14 <ChristianS> toad_: they the type of f is Maybe [a] -> Int
13:16:23 <ReinH> Cale: That's what I thought...
13:16:33 <yayfoxes> toad__: hi! lol what if I wrote something like an OpenGL toilet?
13:16:42 <yayfoxes> it's a unclog the toilet video gmae
13:16:44 <yayfoxes> game
13:16:50 <ChristianS> toad_: so you can write  f :: Maybe [a] -> Int  above your definition of f if you like
13:17:35 <toad__> hm do you think it's neccessary?
13:18:23 <Cale> ReinH: Formally, whatever it was would probably have to be redone for each language anyway
13:18:30 <ChristianS> toad__: "if you like" i said, you don't have to. haskell can figure the type out by itself.
13:18:43 <yayfoxes> what's this junk?
13:18:46 <yayfoxes> y :: Int
13:18:49 <yayfoxes> y = y + 1
13:19:06 <hpc> yayfoxes: haskell's infinite loops look weird
13:19:06 <toad__> but i'm still not quite sure why x has to be a function 
13:19:27 <toad__> I know it's a stupid question but I'm still trying to learn
13:19:28 <yayfoxes> doesn't make any sense to me. What does it do if y is defined to be 1 already?
13:19:29 <Cale> yayfoxes: That says that y is an Int, and that y is equal to y + 1 (which of course, there isn't such an Int, but this results in an infinite loop of computation to try to find one)
13:19:41 <ChristianS> toad__: x is not a function, in my example above it's a list
13:19:56 <yayfoxes> Cale: infinite even if y is already defined to be 1?
13:20:09 <toad__> but you said so earlier on? you said the type of x is a -> b
13:20:13 <hpc> yayfoxes: if you define y multiple times it's a syntax error
13:20:22 <ChristianS> toad__: no
13:20:24 <Cale> yayfoxes: If y was already defined, this declaration would be a duplicate definition error
13:20:29 <hpc> yayfoxes: or it's shadowing
13:20:29 <yayfoxes> hpc: ah, understood
13:20:53 <ChristianS> toad__: just look at my example and play with it in ghc if you like
13:20:54 <Cale> yayfoxes: Even if you were shadowing the definition of y from another module, this would still be a recursive definition.
13:20:58 <ThreeOfEight> yayfoxes: variables in Haskell are immutable
13:21:01 <ChristianS> toad__: ghci, i mean
13:21:09 <ThreeOfEight> you can't say "I want y to be 1 now, and later I'll assign it a 2"
13:21:39 <ThreeOfEight> sometimes, you can define a new variable of the same name with a different value that will shadow the old one
13:21:42 <yayfoxes> ThreeOfEight: so if I said y = 1, then y = 2 it would be a duplicate definition error because they are immutable?
13:22:03 <ThreeOfEight> In a global context, yes
13:22:04 <toad__> i have to write a new file to play with it don't i?
13:22:18 <ThreeOfEight> you can think of definitions like "y = 1" as mere abbreviations
13:22:25 <yayfoxes> ThreeOfEight: do you want a video game? that's one of my goals
13:22:37 <ThreeOfEight> (with the bonus that you can do recursion in definitions)
13:22:54 <Cale> > let ones = 1 : ones in ones
13:22:56 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:23:12 <ChristianS> toad__: no, you use ghci interactively. but if you never heard of ghci, reading a tutorial first might be a good idea.
13:23:16 <ThreeOfEight> yayfoxes: I beg your pardon?
13:23:22 <yayfoxes> Cale: How does that work
13:23:47 <yayfoxes> ThreeOfEight: um...I could make a funny game where you'd have to fix the faucets from leaking before time runs out
13:23:58 <toad__> I have heard of ghci and now i got the type of f which is indeed Maybe [a] -> Int
13:24:00 <Cale> yayfoxes: It defines ones to be the list which begins with 1 and whose tail is itself.
13:24:10 <toad__> but I don't see how that helps me with my type rule
13:24:11 <yayfoxes> or unclog the toilet which gets harder all the time
13:24:14 <Cale> yayfoxes: So the list is infinite
13:24:28 <yayfoxes> Cale: amazing!
13:24:29 <hpc> it's like doing
13:24:31 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in (take 4 evens, take 4 odds) -- you can also have mutually recursive definitions
13:24:33 <lambdabot>  ([0,2,4,6],[1,3,5,7])
13:24:44 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in evens -- infinite list
13:24:45 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
13:25:01 <hpc> struct {int head; foo* tail} foo; foo.head = 1; foo.tail = foo;
13:25:19 <yayfoxes> Cale: so it takes each evens and adds one to it in the same index?
13:25:39 <ChristianS> toad__: well you now know the general type of functions that have such a case statement at their other level: Maybe [a] -> b. nothing more can be said in general.
13:26:03 <Jello_Raptor> hmm, I've got this http://lpaste.net/135346 to emulate a "exists a. At a => ..." but I get an error that compiler cannot deduce that "(d ~ j)" however it looks like the type checking will work out fine if there are equal. (They're both deifned the same way, and all the constraints remaining are of the form "(F d ~ F j)" where 'F' is a type family they both implement. 
13:26:18 <Cale> evens is a list which starts with 0 and is followed by map (+1) odds, i.e. the list obtained by adding 1 to each element of the list odds. In turn, odds is defined as the list obtained by adding one to each element of evens.
13:26:36 <toad__> but I don't think that is the correct solution for my problem
13:26:49 <toad__> you know what I mean with type rule?
13:26:58 <Cale> So the evaluation of the lists bounces back and forth, the first element of odds being determined using the first element of evens, and the second element of evens being determined using the first element of odds, and so on.
13:27:13 <ChristianS> toad__: not really, and i don't know your problem
13:27:48 <Jello_Raptor> there has to be a language extension that allows the system to turn the "unable to deduce (d ~ j)" into a constraint that enforces that "(d ~ j)" 
13:27:56 <Cale> As another example of mutual recursion, here's a list of all primes:
13:28:15 <ChristianS> toad__: also, if it's homework, you shouldn't expect #haskell to solve it for you completely
13:28:23 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
13:28:25 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
13:29:11 <Cale> Here, we define the list of primes to begin with 2 and then be followed by the elements of the list [3,5..] which satisfy the predicate isPrime
13:29:39 <toad__> I don't expect you to solve my homework I just want to get to know things better
13:29:52 <Cale> and in turn we define isPrime n to do divisibility testing against primes p with p * p <= n (i.e. primes less than or equal to the square root of n)
13:31:25 <Cale> > [3,5..] -- in case you don't know this notation, it just gets you an arithmetic sequence starting with the given numbers
13:31:27 <lambdabot>  [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,5...
13:31:47 <toad__> It's really hard to find an example of what i mean in english
13:32:36 <Cale> toad__: I don't see why x has to be a function in the code you gave originally
13:32:51 <Cale> toad__: Perhaps you might've left out some detail?
13:33:01 <toad__> I don't see it either but you said so
13:33:09 <Cale> I didn't say so
13:33:35 <Cale> I said that e1 has to have type Maybe t for some t, and that e2 and e3 must have the same type
13:33:52 <Cale> Those are the only restrictions.
13:34:08 <Cale> Well, x's type will be constrained by that as well
13:34:09 <Cale> x :: t
13:34:25 <toad__> oh well I don't find a comparable example
13:34:27 <toad__> http://www.ki.informatik.uni-frankfurt.de/lehre/WS2006/efp/folien/FP-K-04-typch-fol.pdf
13:34:41 <toad__> on page 22 on the bottom is an example of what I mean
13:35:59 <Cale> toad__: Page 22 has a generalisation of your expression, doesn't it?
13:36:05 <ChristianS> toad__: that seems to say nothing besides what we said too
13:36:08 <small-wolf> How do you instantiate a record with a polymorphic field? e.g. http://pastebin.com/pDPZbyaQ ... I can't figure out where to put additional annotations satisfy the compiler
13:36:38 <toad__> yes I need a generalisation
13:36:42 <Cale> small-wolf: Just 10 :: forall m. Monad m => m Int  is a type error
13:36:50 <Cale> small-wolf: You could use  return 10
13:37:10 <Cale> small-wolf: You're not allowed to pick m
13:37:11 <toad__> again so e1 is Maybe a; e2 is b x is what again? and e3 is also b
13:37:28 <Cale> small-wolf: The user of the record is allowed to pick m, when they extract the field.
13:37:36 <ChristianS> toad__: x is a
13:37:45 <small-wolf> oh ... right. forall is universal.
13:37:52 <toad__> why's that?
13:38:08 <toad__> because it is "just x" and that is part of the Maybe a ?
13:38:14 <ChristianS> toad__: yes
13:38:26 <small-wolf> Cale: how would you make an existentially quantified type then?
13:38:41 <Cale> small-wolf: By moving the forall outward
13:38:54 <toad__> alright then thank you!
13:39:13 <Cale> data Record = forall m. Monad m => Record { normalField :: Int, existentialField :: m Int }
13:39:14 <toad__> I think I've understood you know :)
13:39:28 <Cale> small-wolf: That's relatively useless though
13:39:36 <ChristianS> toad__: very good :)
13:39:53 <toad__> and you think that would be sufficient for my needs?
13:40:04 <Cale> small-wolf: Since you don't know which monad it is, you don't have many options for doing anything with the value which is stored in the field.
13:40:43 <Cale> small-wolf: When you extract the field, you'll only be able to do things you could do with unknown m, and you have no way of remembering which m it was.
13:41:05 <Cale> (at least, without using something like Typeable)
13:41:48 <small-wolf> Cale: that is actually what I originally wanted to do. I'm reorganizing my xmonad config and want to be able to associate different types of actions with different keys.
13:41:54 <ChristianS> toad__: well if your need is homework, i have no way to guess what else your teacher might expect
13:42:32 <small-wolf> Cale: Oh, typeable might be a better way to go, but I don't know much about it.
13:43:02 <small-wolf> That let's me store an arbitrary value and a runtime representation of its type together, and then extract values later right?
13:43:06 <small-wolf> lets*
13:43:07 <toad__> the only thing that is still bothering me is that you said, that i MUST use lowercase letters for the type
13:43:24 <toad__> but in all my other type Rule we use Uppercase letters
13:48:57 <ZeusTheWarrior> Hellp
13:49:02 <ZeusTheWarrior> Can anyone help me?
13:49:04 <ZeusTheWarrior> plz
13:49:39 <ZeusTheWarrior> HELP
13:49:40 <ZeusTheWarrior> plz
13:50:09 <ZeusTheWarrior> ANYONE?!
13:50:11 <ZeusTheWarrior> HAAAAAAAAAAAAAAAAAAAAAAAA
13:51:58 <pharpend> Hey, all
13:52:04 <pharpend> I have this attoparsec parser: http://lpaste.net/135350
13:52:18 <pharpend> takeText, as I understand it, consumes all remaining input
13:52:54 <Cale> small-wolf: Usually existentials aren't so useful... the only examples I know of existential types the need for which can't be worked around statically by just defining the record type a bit differently are pretty contrived and unlikely to appear in a real setting.
13:52:54 <pharpend> yet, when I run the parser on a valid IRC message (it's for an IRC bot), it always returns partial
13:53:19 <pharpend> If I comment out the cmd <- ... thing, and replace Echo cmd with Help, then I get 
13:53:38 <pharpend> Done "okay, desbot is icebot + attoparsec. Let's see if it's faster" (PrivMsg "#snowdrift" "pharpend" Help)
13:53:49 <Cale> small-wolf: If you think about what you're going to do with the actions when you take them back out of the record again, generally there will be a finite number of ways you could use them, resulting in something which is ultimately of the same type which you could have put in the record in the first place.
13:55:10 <Cale> pharpend: If your parser ends with something that insatiably wants more input forever, then you'll always get Partial until you explicitly tell it that there's no more input.
13:55:17 <pharpend> ah okay
13:56:19 <Cale> (see parseOnly)
13:57:01 <nolraiU> So if I run "stack test" I get "/home/chris/Lambda/.stack-work/dist/x86_64-linux/Cabal-1.18.1.5/build/libtest-lambda.a(Lambda.o): In function `SiCV_srt':
13:57:01 <nolraiU> (.data+0x2540): undefined reference to `testzmlambdazm0zi1zi0zi0_CabalQuickCheckAll_zdwa1_closure'" Which looks to me like something is going wrong in cabal's test suite thing?
13:57:53 <nolraiU> Or maybe this is a problem with my attempt to make a quickCheckAll that makes [Test] for cabal?
13:59:09 <Cale> nolraiU: Looks like something wasn't linked properly against one of its dependencies
14:00:50 <nolraiU> Hmm.
14:01:22 <CapitalSigma> is it possible to write a function with the type "IsString a => a -> Bool"? to check if a string-like thing contains a particular control code
14:02:03 <pharpend> CapitalSigma: mhm. something like (\a -> containsCode $ fromString a)
14:02:19 <pharpend> CapitalSigma: i.e. convert it to a string first (
14:02:21 <pharpend> oops
14:02:26 <pharpend> I got IsString backwards
14:02:46 <CapitalSigma> i think i might need to make a typeclass? IsString a => CanBeControlCode a 
14:02:57 <pharpend> hmm
14:03:07 <CapitalSigma> then have "instance CanBeControlCode String", "instance CanBeControlCode ByteString" etc
14:03:09 <pharpend> CapitalSigma: I think it would just be foldable
14:03:23 <pharpend> CapitalSigma: because you are checking each individual character
14:03:36 <CapitalSigma> pharpend: well, i need to compare it to the character '\x027'
14:03:38 <gamegoblin> nolraiU: I got the same error. To fix it I had to add all of my main application‚Äôs modules to the dependencies of my test suite.
14:03:53 <pharpend> CapitalSigma: Foldable f => f Char -> Bool
14:04:04 <gamegoblin> nolraiU: but this is a workaround, I feel like we shouldn‚Äôt have to do this.
14:04:12 <CapitalSigma> i thought OverloadedStrings would let me just write (== '\x027'), but no dice
14:04:37 <breadmonster> CapitalSigma: I think it only lets you do that for ""
14:04:58 <CapitalSigma> breadmonster: oh, good point
14:05:48 <pharpend> CapitalSigma: f = foldr (\myChar b -> b || (myChar == '\x027')) False
14:05:50 <CapitalSigma> breadmonster: (`elem` "\x027") would work, but there's no Eq instance for IsString
14:06:18 <nolraiU> Cale: what would cause that?
14:06:26 <CapitalSigma> pharpend: the issue is that i want the type of the char to vary, not the container. ByteString etc have a different character type
14:06:59 <pharpend> oh hmm
14:07:11 <pharpend> you would want essentially OverloadedChars
14:07:20 <pharpend> so write a typeclass IsChar a
14:07:27 <pharpend> with a function fromChar :: Char -> a
14:07:31 <pharpend> then 
14:07:39 <CapitalSigma> pharpend: that would work
14:07:39 <pharpend> CapitalSigma: f = foldr (\myChar b -> b || (myChar == fromChar '\x027')) False
14:07:59 <CapitalSigma> thanks
14:09:01 <pharpend> the signature of f would then be
14:09:24 <pharpend> (Foldable f, IsChar a) => f a -> Bool
14:09:58 <pharpend> If you wanted to be cute, you could write another typeclass that had Foldable f and IsChar a as prereqs
14:09:58 <AnoyingBock> pharpend, sqererp sa a rahCsI dna f elbadloF dah taht ssalcepyt rehtona etirw dluoc uoy ,etuc eb ot detnaw uoy fI
14:10:25 <pharpend> @where ops
14:10:25 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
14:10:25 <AnoyingBock> pharpend, spo erehw@
14:10:35 --- mode: ChanServ set +o geekosaur
14:10:43 --- mode: geekosaur set +b *!*@177.16.144.50
14:10:43 --- kick: AnoyingBock was kicked by geekosaur (AnoyingBock)
14:10:53 --- mode: geekosaur set -o geekosaur
14:10:56 <geekosaur> sigh
14:10:56 <pharpend> geekosaur: thanks
14:11:07 <maerwald> what's with bots today? this is the 4th or so
14:11:10 <CapitalSigma> what's up with the strange bots lately?
14:11:18 <maerwald> yeah
14:11:23 <pharpend> Maybe it's the Scala people playing pranks
14:11:27 <mauke> geekosaur: that ban also hits alexmob2
14:11:27 <maerwald> :D
14:11:35 <geekosaur> bah
14:11:40 --- mode: ChanServ set +o geekosaur
14:11:54 --- mode: geekosaur set -b *!*@177.16.144.50
14:12:08 <pharpend> That sounds like the IP of a VPN
14:13:34 --- mode: geekosaur set +b *!~splinter@177.16.144.50
14:13:36 --- mode: geekosaur set -o geekosaur
14:15:44 <breadmonster> pharpend: How on earth would you tell?
14:16:06 <pharpend> breadmonster: if two unaffiliated people are using the same IP
14:16:17 <pharpend> breadmonster: also just look up the IP address
14:16:17 <breadmonster> pharpend: Ah.
14:16:30 <pharpend> I didn't look up the IP address, I'm just guessing
14:16:40 <pharpend> ow
14:16:43 <pharpend> oops
14:16:45 <geekosaur> could also be a shared shell host
14:16:53 <pharpend> true
14:17:01 * geekosaur is using znc from such
14:17:12 <breadmonster> pharpend: It's Miami.
14:17:53 <pharpend> breadmonster: I would then wager that it's a person, or a shared shell host. Miami seems like the world's worst place to have a data center
14:18:10 <pharpend> breadmonster: with the annual hurricanes
14:18:13 <breadmonster> lol
14:22:53 <pharpend> New Orleans would be the only place in the US that's worse
14:23:38 <pharpend> My IRC bot, it needs a prompt
14:24:00 <pharpend> It's a channel bot for a Haskell project, so I was thinking \command
14:25:29 <pharpend> If it was a lisp project, it would be 'command
14:25:53 <pharpend> ~command would work
14:27:17 <jmct> anyone know what it means to 'quotient a type' to get a typeclass instance?
14:27:19 <AnoyingGirld> jmct, ?ecnatsni ssalcepyt a teg ot 'epyt a tneitouq' ot snaem ti tahw wonk enoyna
14:27:38 <broma0> How can I use a lenses to manipulate aribrarily nested list tuples: ([],[])? I'm thinking "over (_1 . _head . _1 . _head) f" but getting all sorts of errors
14:27:40 <AnoyingGirld> broma0, srorre fo stros lla gnitteg tub "f )daeh_ . 1_ . daeh_ . 1_( revo" gnikniht m'I ?)][,][( :selput tsil detsen ylirarbira etalupinam ot sesnel a esu I nac woH
14:28:14 <pharpend> ^ different IP, therefore VPN
14:28:17 <AnoyingGirld> pharpend, ^ different IP, therefore VPN
14:28:21 <pharpend> @ops
14:28:21 <lambdabot> Maybe you meant: pl oeis docs
14:28:23 <AnoyingGirld> pharpend, @ops
14:28:24 <AnoyingGirld> lambdabot, Maybe you meant: pl oeis docs
14:28:36 <pharpend> @where ops
14:28:36 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
14:28:37 --- mode: ChanServ set +o geekosaur
14:28:37 <AnoyingGirld> pharpend, spo erehw@
14:28:38 <AnoyingGirld> lambdabot, arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
14:29:00 --- mode: ChanServ set +o mauke
14:29:00 --- mode: mauke set +b *!*@191.175.77.183
14:29:08 <Clint> clown college
14:29:31 <pharpend> mauke: the same bot came here before on a different IP, so I think it's a VPN
14:29:51 <mauke> what am I supposed to do with this information?
14:29:53 --- mode: geekosaur set -o geekosaur
14:30:02 <pharpend> mauke: ban Anoying* ?
14:30:50 <mauke> let's try something funnier
14:30:52 <shapr> does dons show up on #haskell anymore?
14:31:08 <shapr> or sorear?
14:31:09 --- mode: mauke set +b $r:v?
14:31:45 <mauke> sorear hasn't been here in a very long while
14:31:56 <mauke> I may have seen him in some perl6 channel?
14:33:09 --- mode: mauke set -o mauke
14:33:35 <nolraiU> gamegoblin: to the build-depends?
14:33:57 <gamegoblin> nolraiU: I added them to the other-modules 
14:34:19 <gamegoblin> nolraiU: basically the other-modules on the test suite looks the same as the other-modules on the executable
14:35:02 <geekosaur> sorear was in #perl6 for a while but has vanished
14:35:27 <geekosaur> (in general sorear tends to be around for a couple years and then go away and not be seen again. although he did that twice in #perl6 for some reason...)
14:35:29 <nolraiU> Hmm.
14:37:21 <broma0> Can anyone answer a lens question?
14:37:53 <dmj`> broma0: probably, but there's also #haskell-lens
14:37:57 <cpup> is there any way to check if `v1 :: t1` and `v2 :: t2` are equal given that i have `Eq t1` and `Eq t2`?
14:38:27 <cpup> and t1 might equal t2
14:38:32 <broma0> dmj`: didnt realize that.. well the question is: how do i compose _1 and _head to get to values in something like ([a],[a])?
14:39:04 <broma0> dmj`: i tried 'view (_head . _1) blah' but it throw errors about ambiguity 
14:39:34 <ChristianS> cpup: no, if t1 and t2 may be different types, then you cannot compare them
14:39:35 <Haskellfant> cpup: if they're instances of Typeable you could use cast
14:40:31 <nolraiU> gamegoblin: Didn't fix things for me.
14:40:58 <gamegoblin> nolraiU: also add all of the same build-depends from your executable
14:40:58 <nolraiU> Oh, well will just have to test by hand, its my own personal project so thats not a big deal.
14:41:48 <dmj`> broma0: if you're using _head, you won't get a [a] returned, did you mean (a, [a]) ?
14:42:47 <broma0> dmj`: I'd like this: over (_head . _1) (1:) ([],[0,1,2]) == ([1],[0,1,2])
14:43:58 <Haskellfant> that's the wrong way around. you need _1 . _head
14:44:11 <Haskellfant> :t _1 . _head
14:44:12 <lambdabot> (Applicative f, Field1 s t b b, Cons b b a a) => (a -> f a) -> s -> f t
14:44:15 <dmj`> > over _1 (1:) $ ([], [1]) 
14:44:15 <nolraiU> gamegoblin: I am pretty sure I did.
14:44:16 <lambdabot>  ([1],[1])
14:44:26 <Haskellfant> allright, that wasn't exatcyl helpful :)
14:44:26 <gamegoblin> nolraiU: no idea then, sorry
14:44:36 <dmj`> broma0: not sure why we need _head
14:44:38 <nolraiU> Not your fault.
14:44:58 <nolraiU> I wounder if its a bug in stack or cabal..
14:45:09 <Haskellfant> > over (_head . _1) (1:) ([],[0,1,2])
14:45:11 <lambdabot>      No instance for (Show t0)
14:45:11 <lambdabot>        arising from a use of ‚Äòshow_M579826685418112889111694‚Äô
14:45:11 <lambdabot>      The type variable ‚Äòt0‚Äô is ambiguous
14:45:20 <Haskellfant> > over (_1 . _head) (1:) ([],[0,1,2])
14:45:22 <lambdabot>  ([],[0,1,2])
14:54:59 <cpup> Haskellfant: thanks, that seems to work!
14:55:02 <cpup> Haskellfant++
14:55:58 <Haskellfant> cpup: you got me interested. when do you need this? I've never found a good reason to use heterogenous equality.
14:58:46 <kristof> if there exists an isomorphism between t1 and t2, you could do iso v1 and then compare iso v1 to v2
14:59:31 <kristof> Hell, even if there isn't, all you need is an equivalence relation from t1 to t2 that has all the properties you want to compare
15:00:47 <kristof> Haskellfant: I could imagine this being useful with newtypes where you don't ever want to use the two data types interchangeably, but because they are structurally similar you may want to check for structural equality
15:01:09 <kristof> perhaps at an interface boundary
15:01:58 <nolraiU> kristof: what if there is more then one iso though?
15:02:20 <nolraiU> Oh, I can see that.
15:02:23 <nolraiU> Yeah.
15:02:26 <cpup> Haskellfant: i'm implementing a parser, where the rules can change midparse
15:02:49 <cpup> Haskellfant: so i need a map of rules to what their overriden to
15:03:36 <kristof> nolraiU: isomorphisms are always unique
15:04:36 <kristof> nolraiU: How can there be more than one isomorphism from A to B?
15:07:27 <broma0> dmj`: thank you
15:08:17 <dmj`> broma0: np
15:14:21 <Haskellfant> cpup: ah ok
15:14:47 <Haskellfant> kristof: ah that makes sense, thanks
15:17:19 <cpup> how can i make this work? http://lpaste.net/135353
15:23:55 <kuribas> The haskell platform source installer sucks...
15:24:13 <nolraiU> Use stack.
15:24:22 <kuribas> It stops after building hptool
15:25:44 <c_wraith> cpup: you pretty much can't use existentials that way.
15:27:11 <c_wraith> cpup: oh, but that's not even what the error message is about
15:27:20 <c_wraith> cpup: the error message says that the second argument is wrong
15:28:19 <c_wraith> cpup: you tell it the second argument is of type `b'...  Which the *caller* can choose.  And then you pattern match against the OrRule constructor, which means that it must have the type `OrRule ...'
15:28:56 <c_wraith> cpup: That's what the error message is telling you.  A "rigid type variable" is a type variable that's not allowed to be unified with other types.
15:29:37 <c_wraith> cpup: to fix it, you'd need to change the signature to actually indicate the requirements that the definition puts in place
15:36:20 <cpup> c_wraith: so is there any way to do that? (without changing the type of the function)
15:41:34 <c_wraith> cpup: You either know nothing about the types of the arguments, or you know something about them.  I am going to go ahead an invoke the law of the excluded middle here.  Those are the only options.
15:42:17 <cpup> this is another way i tried it, but the type variables from the type thing ((>|<) ::) don't carry over to the definitions: http://lpaste.net/135353
15:42:19 <c_wraith> cpup: The type signature you currently have says you know nothing about the types of those arguments.  If that's a hard requirement, then you can't do anything.
15:42:55 <c_wraith> cpup: do you know what the type of the second argument is or not?
15:43:55 <cpup> c_wraith: it's an instance of Typeable, so i think i do
15:44:12 <c_wraith> cpup: that's not what being an instance of typeable means.
15:44:47 <cpup> c_wraith: doesn't it mean you know the type at runtime?
15:45:13 <c_wraith> cpup: It means you have access to a value at runtime that is derived (hopefully uniquely) from the type.
15:46:06 <c_wraith> cpup: the fact is, you're trying to pattern match on the second argument with the OrRule constructor.  That *only* works if the second argument is the OrRule type.
15:46:48 <c_wraith> cpup: but you've explicitly told the compiler that the second argument is any type with those instances available.  It may be OrRule.  It may not.
15:47:08 <c_wraith> cpup: So the compiler *believes* what you explicitly told it.
15:47:44 <c_wraith> cpup: And then gets to the definition, and says "hHey wait, this isn't what you just told me.  Make up your mind."
15:47:54 <cpup> c_wraith: so there's no way to check if it is an OrRule?
15:48:13 * hackagebot envy 0.1.0.0 - An environmentally friendly way to deal with environment variables  http://hackage.haskell.org/package/envy-0.1.0.0 (DavidJohnson)
15:48:30 <c_wraith> cpup: ... You could, in theory, use cast from Data.Typeable.  But I guarantee it's the wrong approach.
15:48:49 <c_wraith> cpup: the correct approach is actually making your type signature say what you mean.
15:50:04 <cpup> c_wraith: that's (pretty much, except checking if types are equal) the second thing I tried if you look at the annotation
15:51:06 <fr33domlover> hello
15:51:15 <fr33domlover> anyone has experience running hpaste?
15:51:22 <fr33domlover> the thing at http://lpaste.net
15:57:00 <cpup> c_wraith: i got it to work using Typeable (i just need to figure out a way to get the correct TypeRef) http://lpaste.net/135358
15:59:17 <dmwit> cpup: "cast" is the safe (well, safer) version of "unsafeCoerce". You should use it.
15:59:19 <aquickaccountfor> hey, is there any way to see the content of this? (++) <$> Just "klingon"
15:59:29 <dmwit> cpup: It also rolls in the necessary calls to `typeOf`.
15:59:54 <aquickaccountfor> it doesn't derive from show, but I'm wondering if there's anything else? 
15:59:58 <dmwit> aquickaccountfor: Well, you can use `ap` to "apply" it to a few values.
16:00:18 <dmwit> > (++) <$> Just "klingon" <*> pure "foo"
16:00:20 <lambdabot>  Just "klingonfoo"
16:00:50 <aquickaccountfor> ahhh yeah, figured I could apply it. I just wanted to see what it looked like
16:00:51 <aquickaccountfor> thank you!
16:00:57 <aquickaccountfor> good to know I'm understanding it right
16:01:19 <dmwit> aquickaccountfor: It "looks like" `Just (\x -> "klingon" ++ x)`.
16:02:13 <dmwit> Getting something that automatically produces a string like that basically involves writing an interpreter for Haskell, though. =)
16:02:28 <aquickaccountfor> lol, fair enough. 
16:02:41 <aquickaccountfor> ghci is pretty nice, guess it can't do everything though
16:02:42 <dmwit> For functions with smaller domains, you can show functions with the universe package.
16:02:45 <dmwit> ?hackage universe
16:02:45 <lambdabot> http://hackage.haskell.org/package/universe
16:03:53 <dmwit> That would let you write something like `(&&) <$> Just True` and get back `Just [(False, False), (True, True)]`.
16:04:17 <dmwit> The list there represents the function which maps False to False and True to True, i.e. id.
16:07:12 <c_wraith> cpup: is there a reason you don't just change the type signature to say what the type actually needs to be?
16:07:47 <dmwit> aquickaccountfor: Well, I guess part of the problem is that ghci isn't really a Haskell interpreter. It's a Core interpreter with a front-end that can parse Haskell into Core.
16:08:51 <dmwit> Actually, having said that, I wonder how the heck the ghci debugger works. Maybe ghci is a Haskell interpreter after all.
16:10:13 <dmwit> Or maybe the debugger punts on printing anything that isn't in the common subset of Core and Haskell.
16:12:44 <gamegoblin> Can anyone help find the infinite loop or something in this Pipes code? Much appreciated http://lpaste.net/7577126882072592384
16:14:54 <jle`> is there a newtype ComposeTraversable t m a = CT (t (m a)) ?  with an instance (Monad t, Monad m, Traversable t) => Monad (ComposeTraversable t m) ? 
16:15:41 <jle`> so we don't need MaybeT, EitherT/ExceptT/ErrorT anymore
16:15:48 <jle`> but i guess there are some t's where it's not a monad
16:16:00 * jle` shrugs
16:16:31 <dmwit> jle`: No Monad instance, but http://hackage.haskell.org/package/transformers-0.4.3.0/docs/Data-Functor-Compose.html
16:16:46 <jle`> yeah, i know that one, heh
16:16:58 <jle`> but it might be nice to have one where you get an instant Monad transformer
16:17:01 <jle`> for a Traversable
16:17:31 <dmwit> Can't you just write the necessary instances yourself? There's only two.
16:17:33 <jle`> i guess the fact that some t's wouldn't be able to get the instance be a Monad would be a bummer
16:17:42 <jle`> only two Traversables?
16:17:54 <jle`> oh, two Traversables that are Monads
16:18:13 <dmwit> No, I mean two instances.
16:18:22 <dmwit> instance blah => Monad (Compose t m)
16:18:30 <dmwit> instance blah => MonadTrans (Compose t)
16:18:39 <jle`> ah, yeah
16:18:45 <jle`> i guess we could just add that into that Compose type
16:19:16 <dmwit> Gotta be careful that there is just one canonical way to make Compose a Monad, though.
16:19:32 <dmwit> Otherwise I would expect libraries@ to (rightfully) reject a proposal to include it.
16:20:20 <dmwit> I like this observation that Compose subsumes MaybeT and ExceptT, though, if it's true.
16:21:28 <dmwit> Oh, is the instance of Monad that you get that way compatible with the Applicative instance you get by functor composition?
16:22:24 <dmwit> Maybe not. So that is another good reason to ask for a separate type, I guess.
16:23:17 <jle`> i feel like it would be
16:23:26 <jle`> but i am not sure if i can prove it for all instances
16:23:43 <icety3> \wc
16:30:32 <cpup> c_wraith: because it's not supposed to be required to be a OrRule
16:35:07 <strburst>  http://lpaste.net/7577126882072592384
16:35:14 <strburst> whoops, ignore that
16:40:36 <dmwit> jle`: Uh, I actually think you have your t and m switched. ComposeTraversable m t
16:41:30 <jle`> oh yeah
16:41:37 <jle`> that would make it different than Compose
16:41:44 <jle`> you're right
16:42:10 <dmwit> nah, just switch things in the instance
16:42:12 <dmwit> the type can stay
16:47:00 <ttt_fff> is there a way to get post gresql to directly serve json? this instead of web client (javascript) <-> web server (php / ruby / python) <-> db (postgres), I'd prefer to directly do web client (javascript) <-> db (postgres) ... and do all the application logic in store procedures / sql ... is this possible?
16:47:06 <ttt_fff> meant for #postgres
16:47:35 <dmwit> jle`: Ah, I see what you're saying now. Gotta switch the order if you want it to be a MonadTrans
16:47:38 <dmwit> =/
16:48:08 <jle`> =\
16:48:41 <dmwit> ?src ap
16:48:41 <lambdabot> ap = liftM2 id
16:49:12 <jle`> it'd be cool if it said liftM2 ($)
16:49:17 <jle`> but i guess id is ok too
16:56:17 <twopoint718> Does anyone have an example of how to combine Hasql and Spock? It seems like the API of Hasql has changed quite a bit since I last used it: (0.4.0)
16:57:10 <twopoint718> Particularly, I don't know how to fill in this blank: `runSpock 8000 $ spockT ??? routes`
17:03:16 * hackagebot clock 0.5.1 - High-resolution clock functions: monotonic, realtime, cputime.  http://hackage.haskell.org/package/clock-0.5.1 (CetinSert)
17:13:16 * hackagebot envy 0.1.0.1 - An environmentally friendly way to deal with environment variables  http://hackage.haskell.org/package/envy-0.1.0.1 (DavidJohnson)
17:15:27 <Zemyla> Why is writing parsers so flipping easy in Haskell?
17:16:38 <Ralith> because higher order functions and monads
17:16:57 <Welkin> because hazkool
17:17:32 <Welkin> dmj`: another package?
17:17:40 <Welkin> dmj`: where do you find the time to make all these?
17:18:13 <Welkin> I suppose it's a pretty small package
17:20:37 <Zemyla> Ralith: I didn't even use monads, just applicatives. Any CharParsing can parse this language.
17:21:05 <Zemyla> (That means it's context-free.)
17:21:19 <Ralith> do notation is generally nice regardless
17:22:16 <dmj`> Welkin: wasn't too much work, small but useful. 
17:26:06 <dmj`> Welkin: it's simpler than aeson because the datatype isn't recursive, just a map of String String, but this web app has 4 DB's which requires a zillion environment variables
17:26:39 <dmj`> Welkin: I would have been fine with configurator but can't use config files in this case
17:43:56 <dmwit> :t \f g -> traverse f . fmap g
17:43:57 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> (a1 -> a) -> t a1 -> f (t b)
17:44:03 <dmwit> :t \f g -> traverse (f . g)
17:44:05 <lambdabot> (Applicative f, Traversable t) => (b1 -> f b) -> (a -> b1) -> t a -> f (t b)
17:44:34 <dmwit> Are those always equal?
17:44:42 <dmwit> They don't seem to be among the Traversable laws.
17:45:38 <TheKing444> @dmwit Where are the laws again. We may be able to derive it if they are.
17:45:38 <lambdabot> Unknown command, try @list
17:47:06 <dmwit> http://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Traversable.html#t:Traversable
17:50:07 <TheKing444> Let me take a look
17:50:46 <TheKing444> Hmm
17:50:55 <TheKing444> :t traverse
17:50:57 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
17:51:42 <TheKing444> > traverse Just [1,2,3]
17:51:44 <lambdabot>  Just [1,2,3]
17:51:53 <TheKing444> > traverse (:[]) [1,2,3]
17:51:55 <lambdabot>  [[1,2,3]]
17:52:17 <TheKing444> > fmap (+7) $ traverse (:[]) [1,2,3]
17:52:18 <lambdabot>      No instance for (Show b0)
17:52:18 <lambdabot>        arising from a use of ‚Äòshow_M468629190574069262214434‚Äô
17:52:18 <lambdabot>      The type variable ‚Äòb0‚Äô is ambiguous
17:52:29 <TheKing444> > fmap (head) $ traverse (:[]) [1,2,3]
17:52:31 <lambdabot>  [1]
17:52:35 <TheKing444> > fmap head)$ traverse (:[]) [1,2,3]
17:52:36 <lambdabot>  <hint>:1:10: parse error on input ‚Äò)‚Äô
17:52:42 <TheKing444> > fmap head $ traverse (:[]) [1,2,3]
17:52:43 <lambdabot>  [1]
17:52:51 <dmwit> You've got your fmap on the wrong side if you are trying to smallcheck my proposed property.
17:52:57 <TheKing444> > traverse (head . (:[])) [1,2,3]
17:52:59 <lambdabot>      No instance for (Show (f0 [b0]))
17:52:59 <lambdabot>        arising from a use of ‚Äòshow_M697305759959876713114492‚Äô
17:52:59 <lambdabot>      The type variables ‚Äòf0‚Äô, ‚Äòb0‚Äô are ambiguous
17:53:08 <TheKing444> Oh wait, I see, sorry
17:53:23 <TheKing444> > traverse (:[]) $ fmap (+7) [1,2,3]
17:53:25 <lambdabot>  [[8,9,10]]
17:53:34 <TheKing444> > traverse (:[] . (+7)) $ [1,2,3]
17:53:36 <lambdabot>      Couldn't match expected type ‚ÄòInteger -> c0‚Äô
17:53:36 <lambdabot>                  with actual type ‚Äò[t0]‚Äô
17:53:36 <lambdabot>      In the first argument of ‚Äò(.)‚Äô, namely ‚Äò[]‚Äô
17:53:48 <TheKing444> > traverse ((:[]) . (+7)) $ [1,2,3]
17:53:50 <lambdabot>  [[8,9,10]]
17:53:56 <TheKing444> Seems plauisble
17:54:02 <TheKing444> Let's take a closer look
17:54:10 <dmwit> Yes. It is a very natural looking law.
17:56:09 <sccrstud92> can you write fmap in terms of traverse?
17:56:21 <sccrstud92> you can just use Identity/runIdentity, right?
17:56:22 <monochrom> I think yes
17:56:42 <TheKing444> :t traverse
17:56:43 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
17:56:53 <sccrstud92> :t runIdentity . traverse Identity
17:56:54 <lambdabot> Traversable t => t b -> t b
17:57:11 <sccrstud92> :t \f -> runIdentity . traverse (Identity . f)
17:57:12 <lambdabot> Traversable t => (a -> b) -> t a -> t b
17:57:19 <argent0> Hello! Does 'aeson >= 0.9 && < 0.10' makes sence? or is 0.9 > 0.10?
17:57:26 <TheKing444> http://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Traversable.html#v:fmapDefault
17:57:37 <monochrom> 0.9 < 0.10, don't worry
17:57:49 <argent0> monochrom: thanks!
17:57:49 <sccrstud92> fmap f = runIdentity . traverse (Identity . f)
17:59:43 <sccrstud92> traverse f . fmap g = traverse f . runIdentity . traverse (Identity . g)
18:00:19 <TheKing444>  traverse f . runIdentity . traverse (Identity . g) = runIdentiy . traverse f . traverse (Identity . g)
18:00:22 <TheKing444> I think
18:00:42 <sccrstud92> does that type check?
18:01:25 <sccrstud92> :t traverse f . runIdentity . traverse (Identity . g)
18:01:27 <lambdabot>     Could not deduce (Show a0) arising from a use of ‚Äòf‚Äô
18:01:27 <lambdabot>     from the context (Show a,
18:01:27 <lambdabot>                       Applicative f,
18:01:32 <sccrstud92> :t \f g -> traverse f . runIdentity . traverse (Identity . g)
18:01:34 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> (a1 -> a) -> t a1 -> f (t b)
18:01:48 <sccrstud92> :t \f g -> runIdentity . traverse f . traverse (Identity . g)
18:01:50 <lambdabot> Traversable t => (t b1 -> Identity b) -> (a -> b1) -> t a -> Identity b
18:01:58 <TheKing444> nvm
18:02:11 <sccrstud92> :t \f g -> fmap runIdentity . traverse f . traverse (Identity . g)
18:02:12 <TheKing444> I think I applied it wrong
18:02:13 <lambdabot> (Applicative f, Traversable t) => (t b1 -> f b) -> (a -> b1) -> t a -> f b
18:02:36 <sccrstud92> :t \f g -> fmap (fmap runIdentity) . traverse f . traverse (Identity . g)
18:02:38 <lambdabot> (Applicative f, Traversable t) => (t b1 -> f (Identity b)) -> (a -> b1) -> t a -> f (Identity b)
18:02:42 <sccrstud92> nah
18:02:46 <TheKing444> traverse f . runIdentity . traverse (Identity . g)  = traverse f . traverse (Identity . g .runIdentity)
18:02:56 <TheKing444> I think
18:03:11 <TheKing444> :t traverse f . runIdentity . traverse (Identity . g)
18:03:13 <lambdabot>     Could not deduce (Show a0) arising from a use of ‚Äòf‚Äô
18:03:13 <lambdabot>     from the context (Show a,
18:03:13 <lambdabot>                       Applicative f,
18:03:47 <sccrstud92> :t \f g -> traverse f . traverse (Identity . g . runIdentity)
18:03:48 <lambdabot> (Applicative f, Traversable t) => (t b1 -> f b) -> (b2 -> b1) -> t (Identity b2) -> f (Identity b)
18:03:51 <sccrstud92> nope
18:04:10 <TheKing444> I am trying to apply 
18:04:12 <TheKing444> naturality
18:04:13 <TheKing444> t . traverse f = traverse (t . f) for every applicative transformation t
18:04:21 <TheKing444> failing though
18:04:47 <sccrstud92> :t \f g -> traverse f . traverse (runIdentity . g . Identity)
18:04:48 <lambdabot> (Applicative t, Applicative f, Traversable t, Traversable t1) => (t1 b1 -> f b) -> (Identity a -> Identity (t b1)) -> t1 a -> f (t b)
18:05:19 <sccrstud92> we were looking at traverse f . fmap g === traverse (f . g)
18:05:29 <sccrstud92> traverse f = sequenceA . fmap f
18:05:32 <dmwit> perhaps `traverse f . runIdentity` is an applicative trans.
18:05:47 <sccrstud92> i figured it out
18:05:59 <TheKing444> Yeah, I see it too
18:06:11 <dmwit> in which case naturality gives the dusired conclusion
18:06:17 <sccrstud92> traverse f . fmap g === sequenceA . fmap f . fmap g === sequenceA . fmap (f . g) === traverse (f . g)
18:06:26 <TheKing444> Yeah
18:06:38 <TheKing444> Hoozah!
18:07:38 <dmwit> there are no laws connecting traverse and sequenceA
18:08:04 <TheKing444> Definitions I believe
18:08:13 <sccrstud92> ^
18:08:31 <dmwit> both are class methods and can be overridden
18:08:35 <TheKing444> It is implied that if you supply a default, it can only have different efficiency, but must be the same as the default I beleive.
18:08:45 <TheKing444> Semantically the same
18:09:19 <dmwit> the implication should be made explicit, imo
18:09:31 <TheKing444> Probably
18:09:38 <TheKing444> You could email the guy.
18:11:31 <TheKing444> I think its a general rule though. You would get in trouble if (!=) wasn't (not . (==))
18:12:28 <hacker> well, it is not
18:12:37 <sccrstud92> hacker: ?
18:12:44 <hacker> > let x = 0/0 in (x == x, x /= x)
18:12:45 <lambdabot>  (False,True)
18:13:03 <hacker> welp, was it with infinites? :P 
18:13:25 <TheKing444> That just means IEEE is not conformant, and they do get in a little bit of trouble for that.
18:13:30 <TheKing444> > 1/0
18:13:31 <lambdabot>  Infinity
18:13:58 <sccrstud92> TheKing444: I think his point was that the page doesnt actually say that traverse f = sequenceA . fmap f and sequenceA = traverse id
18:15:13 <TheKing444> Yeah, that would be nice.
18:15:30 <TheKing444> I wonder if we can prove it without connection to sequenceA.
18:15:44 <TheKing444> Let us see, define seqA = traverse id
18:15:58 <TheKing444> Then traverse f = seqA . fmap f
18:16:12 <ReinH> hacker: I think you're thinking of NaN
18:16:20 <hacker> > 0/0
18:16:21 <lambdabot>  NaN
18:16:40 <hacker> ReinH: ^ that's what I was had in mind
18:16:42 <TheKing444> Then traverse f . fmap g = seqA . fmap f . fmap g = seqA . fmap (f . g) = traverse (f . g)
18:16:50 <ReinH> Oh yeah
18:17:35 <sccrstud92> TheKing444: how is that better? you are just assuming the same law with a different name
18:17:57 <sccrstud92> you are assuming traverse f = traverse id . fmap f
18:17:59 <ReinH> (==) is a typeclass method, so you can't talk about its behavior generally.
18:18:22 <ReinH> And Eq doesn't offer any laws
18:18:37 <TheKing444> Well, I showed traverse f = traverse id . fmap f implies traverse f . fmap g = traverse (f .g)
18:18:47 <sccrstud92> ReinH: someone suggested (==) === not . (/=)
18:19:00 <ReinH> (although I suppose it's expected that (==) ‚â° (not . (/=)))
18:19:07 <sccrstud92> TheKing444: and what does that get you?
18:19:13 <hacker> more like (not .) . (/=), it still rules out things like floats/doubles
18:19:25 <ReinH> right, whichever version typechecks
18:19:32 <sccrstud92> of course
18:19:33 <TheKing444> Uhm, let's try proving traverse f === traverse id . fmap f
18:20:04 <ReinH> hacker: yes, but we already know floats are incoherent
18:20:21 <hacker> nobody say they weren't :p
18:20:28 <TheKing444> Ugh, I just noticed the ugly Composition law is the only one invovling fmap.
18:20:40 <sccrstud92> yeah i hate that one
18:20:42 <ReinH> "ugly composition law"?
18:20:52 <sccrstud92> ReinH: in Data.Traversable
18:21:03 <sccrstud92> its defined using somme extra types
18:22:03 <ReinH> It's much nicer as a diagram
18:22:18 <dmwit> I suppose it is also possible that `traverse f . fmap g = traverse (f . g)` is just a consequence of parametricity.
18:22:30 <dmwit> That wouldn't surprise me at all, in fact.
18:22:39 <ReinH> dmwit: well, parametricity is strictly stronger than naturality
18:23:05 <dmwit> :t traverse
18:23:05 <ReinH> ideal Hask is a rather boring category to work in ;)
18:23:06 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
18:23:11 <sccrstud92> ReinH: in absence of GADTs at least
18:23:21 <ReinH> sccrstud92: true enough!
18:23:22 <dmwit> Can ?free handle typeclasses?
18:23:27 <dmwit> ?free Eq a => a -> a -> Bool
18:23:27 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
18:23:31 <dmwit> no =P
18:23:40 <dmwit> ?free foo :: Eq a => a -> a -> Bool
18:23:40 <lambdabot> Extra stuff at end of line
18:24:04 <sccrstud92> ?free foo :: a -> a -> Bool
18:24:04 <lambdabot> foo x = foo (f x) . f
18:24:14 <ReinH> dmwit: I did a slightly fun thing with parametricity today
18:24:31 <ReinH> Well, parametricity was really only tangentally involved, but it was still fun
18:24:32 <dmwit> sccrstud92: That law does not hold of all `foo`s that get to assume `Eq a`, though.
18:24:59 <sccrstud92> dmwit: I'm aware =) I just havent used the free theorem bot before
18:25:01 <sccrstud92> haha
18:25:05 <dmwit> ok =)
18:25:09 <ReinH> dmwit: http://reinh.com/notes/posts/2015-06-27-theoretical-pearl-l-systems-as-final-coalgebras.html
18:25:22 <ReinH> it needs some fleshing out
18:25:27 <dmwit> whoo boy
18:25:41 <ReinH> ?
18:25:48 <dmwit> This post looks a bit dense for my current state.
18:25:53 <ReinH> dmwit: it's really not
18:25:58 <ReinH> it just uses some jargon
18:26:07 <TheKing444> ?free [a] -> [a]
18:26:07 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
18:26:13 <ReinH> I kind of bury the lede too :(
18:26:18 <TheKing444> ?free f00::[a] -> [a]
18:26:18 <lambdabot> $map f . f00 = f00 . $map f
18:26:45 <TheKing444> ?free f00::[a] -> Maybe a
18:26:45 <lambdabot> $map_Maybe f . f00 = f00 . $map f
18:27:01 <ReinH> which tells you that any a's that f00 uses must come from the [a] and must appear in order in the result :)
18:27:03 <TheKing444> It knows category theory
18:27:23 <ReinH> s/uses/produces
18:27:26 <TheKing444> ?free [a] -> a
18:27:26 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
18:27:30 <TheKing444> ?free foo::[a] -> a
18:27:30 <lambdabot> f . foo = foo . $map f
18:27:42 <TheKing444> ?free foo::a
18:27:42 <lambdabot> f foo = foo
18:27:56 <dmwit> ReinH: I don't believe your claimed result of parametricity.
18:27:56 <TheKing444> And denotional semantics
18:28:07 <ReinH> dmwit: why not?
18:28:25 <TheKing444> @quote dmwit
18:28:26 <lambdabot> dmwit says: Let's not make things better, I haven't put enough lipstick on the worse version yet.
18:28:32 <dmwit> ReinH: step x = x; step (D0L axm rls) = D0L (axm >>= rls >>= rls) rls both seem like defined and different implementations.
18:28:43 <ReinH> dmiles_akf: woops, good point!
18:28:47 <TheKing444> @quote lambdabot
18:28:47 <lambdabot> lambdabot says: Nobody brings small problems into a laundromat.
18:28:48 <ReinH> woops
18:28:50 <ReinH> dmwit: thanks
18:31:03 <ReinH> dmwit: corrected
18:31:30 <TheKing444> ?free const::a->b->a
18:31:30 <lambdabot> f . const x = const (f x) . g
18:31:33 <ReinH> dmwit: so D0L is a final encoding and generate is a final coalgebra :)
18:32:01 <dmwit> I don't remember enough about coalgebras to believe or disbelieve. =P
18:32:33 <ReinH> dmwit: well, I'm not sure how to show uniqueness of the morphisms from other encodings to D0L, but if I wave my hands fast enough...
18:33:20 <ReinH> Probably just via extensional equality
18:34:00 <ReinH> Anyway, the fixed point of a coalgebra bit was the interesting bit
18:34:05 <TheKing444> ?free fix::(a->a)->a
18:34:05 <lambdabot> f . g = h . f => f (fix g) = fix h
18:36:14 <ReinH> More papers locked behind Elsevier's paywall *sigh*
18:38:37 <broma0> just asked this over in haskell-lens... how would you define a lens to look at the x in this structure ([z,y,x],[a,b,c])?
18:39:11 <dmwit> I think you can't make a (well-behaved) lens for that. A prism may be possible.
18:39:34 <broma0> dmwit: maybe thats why i get all sorts of ambiguity errors.. ill look into prisms
18:39:54 <sccrstud92> i dont think u want a prism
18:40:00 <sccrstud92> something like
18:40:06 <sccrstud92> _1 . (at 2)
18:41:00 <dmwit> There is no At instance for lists.
18:41:15 <broma0> > view (_1 . (at 2)) ([1,2,3],[4,5,6])
18:41:17 <lambdabot>      No instance for (Show t0)
18:41:17 <lambdabot>        arising from a use of ‚Äòshow_M3192492162204175715309‚Äô
18:41:17 <lambdabot>      The type variable ‚Äòt0‚Äô is ambiguous
18:41:46 <sccrstud92> dmwit: isnt there some sort of lens for indexing into a list?
18:42:11 <dmwit> I don't believe so. The lens laws prohibit it.
18:42:25 <dmwit> Whether the lens package is careful with the laws I can't say; but knowing ekmett it is.
18:42:29 <sccrstud92> broma0: dmwit may be right about using a prism 
18:42:47 <tejing> there could be a traversal for that... no lens or prism
18:42:57 <broma0> sccrstud92: I'm looking into them now
18:43:06 <dmwit> Aha, `ix` can be used on lists.
18:43:33 <dmwit> It is indeed a Traversal, which is a generalization of prisms.
18:43:41 <sccrstud92> dmwit: Aha I didnt think I was going crazy! thanks for finding that
18:44:02 <sccrstud92> isnt a Traversal also a generalization fo a lens?
18:44:18 <dmwit> "generalization" is a funny word
18:44:21 <broma0> trying to figure out how to use _1 and ix to get at that x in my example
18:44:26 <dmwit> It can either mean more specific or less, depending on context.
18:44:37 <sccrstud92> what does _1 . ix 2 do?
18:44:43 <dmwit> There are traversals which are not lenses.
18:44:55 <sccrstud92> but all lenses are traversals?
18:44:57 <dmwit> All prisms are traversals (or can be made into traversals).
18:45:14 <dmwit> I would guess all lenses can be turned into traversals, yes.
18:45:25 <sccrstud92> can all lenses be turned into prisms?
18:45:26 <dmwit> Probably all lenses can be turned into prisms.
18:45:31 <broma0> > view (_1 . (ix 2)) ([1,2,3],[4,5,6])
18:45:33 <lambdabot>      No instance for (Show a0)
18:45:34 <lambdabot>        arising from a use of ‚Äòshow_M806004468596053695915374‚Äô
18:45:34 <lambdabot>      The type variable ‚Äòa0‚Äô is ambiguous
18:45:37 <tejing> yes dmwit, all lenses are traversals too
18:45:41 <dmwit> I have spent a total of maybe one hour with this library, though, so take my observations with a grain of salt.
18:45:51 <dmwit> I am an expert on lenses, but not an expert on this library.
18:45:55 <tejing> and in particular, the composition of a prism and a lens is a traversal
18:46:03 <sccrstud92> > view (_1 . (ix 2)) ([1 :: Int,2,3],[4 :: Int,5,6])
18:46:05 <lambdabot>      No instance for (Monoid Int) arising from a use of ‚Äòix‚Äô
18:46:05 <lambdabot>      In the second argument of ‚Äò(.)‚Äô, namely ‚Äò(ix 2)‚Äô
18:46:05 <lambdabot>      In the first argument of ‚Äòview‚Äô, namely ‚Äò(_1 . (ix 2))‚Äô
18:46:17 <TheKing444> dmwit What resource do you use for lens?
18:46:23 <TheKing444> Like to learn about them?
18:46:34 <sccrstud92> > view ((ix 2) . _1) ([1 :: Int,2,3],[4 :: Int,5,6])
18:46:35 <lambdabot>      No instance for (Show a0)
18:46:36 <lambdabot>        arising from a use of ‚Äòshow_M540771818610605147215409‚Äô
18:46:36 <lambdabot>      The type variable ‚Äòa0‚Äô is ambiguous
18:46:36 <dmwit> I have only looked at the haddocks so far.
18:46:54 <dmwit> I have bookmarks to tutorials in case I one day wish to use the library for real. =)
18:47:15 <dmwit> But I can't really vouch for or against them.
18:47:41 <sccrstud92> > view (_1) ([1 :: Int,2,3],[4 :: Int,5,6])
18:47:43 <lambdabot>  [1,2,3]
18:47:52 <sccrstud92> > view (_1) ([1,2,3],[4,5,6])
18:47:53 <lambdabot>  [1,2,3]
18:48:20 <dmwit> :t ix
18:48:22 <lambdabot> (Applicative f, Ixed m) => Index m -> (IxValue m -> f (IxValue m)) -> m -> f m
18:48:48 <dmwit> I wonder where the heck that `Monoid` constraint came from.
18:49:12 <dmwit> Choosing some crazy applicative that needs a `Monoid` for some reason, maybe...?
18:49:20 <dmwit> ?instances Ixed
18:49:23 <lambdabot> (M.Map k a), (S.Set k), (a, a2), (a, a2, a3), (e -> a), Array i e, BSC.ByteString, BSLC.ByteString, IS.IntSet
18:49:28 <tejing> dmwit: monoid appears because the applicative instance for (,) a requires it
18:49:29 <TheKing444> dmwit, No I mean you said you were an expert on lenses.
18:49:31 <dmwit> Oh ho
18:49:36 <TheKing444> Where did you learn lenses from.
18:49:42 <dmwit> TheKing444: I wrote my Ph.D. thesis on lenses. =)
18:50:12 <TheKing444> Ah, so I suppose, lots of places.
18:50:20 <sccrstud92> > view (ix 2) [1,2,3]
18:50:21 <lambdabot>      No instance for (Show a0)
18:50:21 <lambdabot>        arising from a use of ‚Äòshow_M27046499649947389415502‚Äô
18:50:21 <lambdabot>      The type variable ‚Äòa0‚Äô is ambiguous
18:50:27 <dmwit> I learned lenses from my advisor Professor Pierce and my predecessor Professor Foster on the UPenn lens project.
18:50:31 <dmwit> And others, yeah.
18:50:39 <broma0> sccrstud92: this is tough huh?
18:51:00 <sccrstud92> broma0: lens is a tricky library
18:51:06 <sccrstud92> i dont think view is the right function
18:51:35 <dmwit> :t _1.ix 2
18:51:37 <lambdabot> (Num (Index b), Applicative f, Field1 s t b b, Ixed b) => (IxValue b -> f (IxValue b)) -> s -> f t
18:52:09 <sccrstud92> :t preview
18:52:10 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
18:52:23 <sccrstud92> :t review
18:52:24 <lambdabot> MonadReader b m => AReview t b -> m t
18:52:37 <sccrstud92> > preview (ix 2) [1,2,3]
18:52:39 <lambdabot>  Just 3
18:52:50 <broma0> sccrstud92: found that at the same time!
18:52:51 <sccrstud92> Ha hah!
18:52:58 <hacker> the infix op is ^?
18:53:07 <sccrstud92> > preview (_1 . ix 2) ([1,2,3],[])
18:53:10 <lambdabot>  Just 3
18:53:13 <broma0> nice~
18:53:20 * hackagebot digitalocean-kzs 0.1.0.2 - digitalocean api for haskell  http://hackage.haskell.org/package/digitalocean-kzs-0.1.0.2 (KazumaSATO)
18:53:21 <sccrstud92> hacker: looks right
18:53:22 * hackagebot prometheus-client 0.1.0.0 - Haskell client library for http://prometheus.io.  http://hackage.haskell.org/package/prometheus-client-0.1.0.0 (fimad)
18:53:30 <broma0> if we wanted to replicate _head i guess we could use 
18:53:35 <broma0> fromJust $ preview (_1 . ix 2) ([1,2,3],[])
18:53:39 <broma0> > fromJust $ preview (_1 . ix 2) ([1,2,3],[])
18:53:41 <lambdabot>  3
18:54:07 <broma0> this damn lib is confusing
18:54:10 <sccrstud92> broma0: how do you know that the list has at least 3 elements?
18:54:24 <dmwit> sccrstud92: preach
18:54:28 <broma0> I dont, its a list zipper
18:54:44 <broma0> the catch is i have about 5 levels of nested list zippers and need to compose these "previews"
18:54:47 <sccrstud92> broma0: so you arent gonna use fromJust, right?
18:55:07 <broma0> sccrstud92: correct. that could get ugly
18:55:25 <sccrstud92> well just keep composing the lenses
18:55:29 <sccrstud92> and you should be okay
18:55:38 <hacker> and using the applicative instance of Maybe if needed :P
18:55:45 <sccrstud92> or monad
18:55:46 <sccrstud92> yeah
18:55:51 <broma0> if "over" is to "view", is to "preview"?
18:56:01 <sccrstud92> :t over
18:56:03 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
18:56:11 <sccrstud92> :t view
18:56:12 <lambdabot> MonadReader s m => Getting a s a -> m a
18:56:26 <sccrstud92> :t preview
18:56:28 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
18:56:52 <dmwit> jle`: Well, I am having a heck of a time proving that the Monad instance and the Applicative instance would align appropriately.
18:57:11 <sccrstud92> not sure
18:57:16 <dmwit> jle`: I can't even figure out what strong condition relating Traversable and Applicative I even want.
18:57:41 <hacker> @type view
18:57:43 <lambdabot> MonadReader s m => Getting a s a -> m a
18:57:44 <hacker> @type set 
18:57:45 <lambdabot> ASetter s t a b -> b -> s -> t
18:58:43 <timothyh> if i'm trying to do constant-memory stream parsing (assume i'm doing something silly, like counting successful parses), is lazy IO ok? or sohuld i use something heavy like pipes?
18:58:43 <athan> What would be a good way to download the .cabal file, or particular fields from a package from the Hackage web API?
18:58:52 <timothyh> my parser is attoparsec
18:59:09 <athan> Or is it named something unintuitive?
18:59:24 <athan> particular fields of the cabal file from a package*
19:01:31 <athan> timothyh: I'm pretty sure `conduit-attoparsec` is in constant memory
19:01:51 <athan> but I'm pretty sure it's hard to get attoparsec to parse in constant memory anyway (although I'm not sure)
19:02:12 <athan> parsec has worked fine for me in practice, using Data.Text.Lazy's `openFile`
19:19:27 <mniip> so I came up with the most useful function ever
19:19:45 <mniip> analogous to tails, heads!
19:20:02 <c_wraith> Hold on, I bet I know how to implement it..
19:20:10 <c_wraith> > id [1,4,3,76,4]
19:20:12 <lambdabot>  [1,4,3,76,4]
19:20:14 <c_wraith> bam!
19:20:51 <Zemyla> > tails [1,4,3,76,4]
19:20:53 <lambdabot>  [[1,4,3,76,4],[4,3,76,4],[3,76,4],[76,4],[4],[]]
19:20:55 <mniip> c_wraith, my implementation was 'foldr (:) []' but yours is nice too :D
19:26:43 <hacker> > flip id id . ap (flip id id) . const $ [1,2,3,4]
19:26:45 <lambdabot>  [1,2,3,4]
19:26:57 <hacker> mniip: you need to add operators there!
19:31:23 <FreeFull> > const id id id [1,2,3,4]
19:31:25 <lambdabot>  [1,2,3,4]
19:31:42 <FreeFull> > do id const id id id [1,2,3,4]
19:31:44 <lambdabot>  [1,2,3,4]
19:32:10 <mniip> > [1,2,3,4] >>= join const
19:32:11 <bananagram> > const id id id id id id id id id id 2
19:32:11 <lambdabot>      No instance for (Show b0)
19:32:12 <lambdabot>        arising from a use of ‚Äòshow_M66948375090508016216260‚Äô
19:32:12 <lambdabot>      The type variable ‚Äòb0‚Äô is ambiguous
19:32:13 <lambdabot>  2
19:32:24 <mniip> err
19:32:47 <dramforever> :t const id id id id id id 2
19:32:48 <lambdabot> Num a => a
19:32:59 <dramforever> :t join const
19:33:01 <lambdabot> a -> a
19:38:22 * hackagebot prometheus-metrics-ghc 0.1.0.0 - Metrics exposing GHC runtime information for use with prometheus-client.  http://hackage.haskell.org/package/prometheus-metrics-ghc-0.1.0.0 (fimad)
19:38:24 * hackagebot wai-middleware-prometheus 0.1.0.0 - WAI middlware for exposing http://prometheus.io metrics.  http://hackage.haskell.org/package/wai-middleware-prometheus-0.1.0.0 (fimad)
19:38:47 <TheKing444> hackagebot help
19:39:30 <TheKing444> ?free tail :: [a] -> [a]
19:39:31 <lambdabot> $map f . tail = tail . $map f
19:39:42 <TheKing444> ?free tail :: [a] -> [b]
19:39:42 <lambdabot> $map g . tail = tail . $map f
19:40:18 <TheKing444> ?free sort::(a -> a -> Ord) -> [a] -> [a]
19:40:18 <lambdabot> (forall x. g x = h (f x) . f) => $map f . sort g = sort h . $map f
19:41:35 <TheKing444> :t preview
19:41:36 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
19:50:41 <Zemyla> Dammit, I'm trying to think of a pun on "the Monad Lisa" and I'm failing horribly.
19:52:45 <Javran> :t ()
19:52:45 <Javran> hmmm, any idea what happens to lambdabot?
19:52:47 <lambdabot> ()
19:53:03 <dramforever> Javran: Yes
19:53:09 <dramforever> :)
19:53:30 <dramforever> lambdabot is somehow very slow at times
19:55:08 <Javran1> dramforever: I guess it's the network to blame
19:55:16 <dramforever> yep
19:55:36 <TheKing444> @quote lambdabot
19:55:36 <lambdabot> lambdabot says: I know everything hasn't been quite right with me, but I can assure you now, very confidentaly, that it's going to be all right again.  I feel much better now.  I really do.
19:55:38 <Javran1> dramforever: my message has sent but delayed a lot
19:55:44 <dramforever> yeah
19:55:58 <TheKing444> Oh my gosh, it understands English!
19:56:12 <Clint> "confidentaly" is not english
19:56:40 <TheKing444> It knew that dramforever was talking about it.
19:56:52 <dramforever> ha!
19:57:07 <TheKing444> @quote dramforever
19:57:07 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
19:57:37 <TheKing444> @quote Clint
19:57:37 <lambdabot> drudge says: Need Chelsea Clinton Nose Job? See Chelsea Clinton Nose Job.
19:58:33 <TheKing444> @quote hackagebot
19:58:33 <lambdabot> edwardk says: i feel like rolling over, looking at hackagebot, and asking "was it good for you?" before lighting a cigarette.
19:58:50 <mac1> Hi
19:58:55 <TheKing444> @quote mac1
19:58:55 <lambdabot> No quotes match. stty: unknown mode: doofus
19:59:48 <TheKing444> @quote Zemyla
19:59:48 <lambdabot> Zemyla says: I imagine if [Edward Kmett] had found C++, he would be writing template definitions that would make the faces of the Boost team melt off.
19:59:57 <mac1> Hi King 444
20:00:07 <TheKing444> Hello mac
20:00:07 <hacker> TheKing444: you may want to play with the bot in a pm 
20:00:46 <mac1> What is topic for this channel? Theking444
20:00:56 <TheKing444> @topic
20:00:56 <lambdabot> Unknown command, try @list
20:01:00 <TheKing444> Uhm
20:01:14 <TheKing444> The channel topic is "http://www.haskell.org/ 
20:01:18 <TheKing444> Boring topic
20:01:45 <mac1> Ok
20:01:54 <mac1> üëç
20:02:44 <mac1> You mean Hacking?
20:02:59 <TheKing444> ?
20:03:10 <TheKing444> Haskell, not hacking
20:03:19 <TheKing444> I mean its just a url.
20:03:32 <mac1> Ok
20:03:41 <mac1> Wait,
20:03:51 <mac1> I will check on net
20:04:02 <mac1> Thanks for inform
20:04:06 <mac1> üëç
20:04:32 <dmwit> The channel topic is longer than that.
20:04:40 <dmwit> Try /topic in your client.
20:04:46 <TheKing444> Oh
20:04:56 <mac1> Ok
20:04:58 <TheKing444> Ah yes
20:05:06 <mac1> I will try
20:05:07 <TheKing444> mac1 Haskell is a programming language.
20:05:10 <TheKing444> Here watch
20:05:20 <mac1> Ohhh.. Ok ok
20:05:42 <TheKing444> > fibs where fibs = 0 : 1 : zipWith (+) fibs $ tail fibs
20:05:44 <lambdabot>  <hint>:1:6: parse error on input ‚Äòwhere‚Äô
20:05:57 <TheKing444> whoops
20:05:57 <dramforever> lol
20:06:06 <mac1> Ok
20:06:07 <dramforever> > let fibs = 0 : 1 : zipWith (+) fibs $ tail fibs in fibs
20:06:08 <lambdabot>      Couldn't match expected type ‚Äò[a1] -> [a1]‚Äô
20:06:09 <lambdabot>                  with actual type ‚Äò[Integer]‚Äô
20:06:09 <lambdabot>      Relevant bindings include fibs :: [a1] (bound at <interactive>:1:5)
20:06:58 <TheKing444> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
20:07:00 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
20:07:11 <TheKing444> There we go
20:07:48 <dramforever> mac1: do you want to learn haskell programming? it seems so
20:08:43 <mac1> Its good to learn. Ya. But i like CISCO.
20:09:01 <mac1> And Hacking.
20:10:30 <TheKing444> > 1/0
20:10:33 <lambdabot>  Infinity
20:26:00 <f|`-`|f> :t (/)
20:26:01 <lambdabot> Fractional a => a -> a -> a
20:26:07 <f|`-`|f> :t (1/0)
20:26:08 <lambdabot> Fractional a => a
20:26:34 <StormRoof> I commend Dylann Storm Roof for his actions, and Emmanuel AME Church will forever be a shrine for those of us who are sick of the feral negrow beast.   Your church will now become a place where those of us will come by and join you in prayer to honor what happened.
20:26:58 <f|`-`|f> wow, a storm bot?
20:27:01 <sunnymilk> @let silly :: a -> a -> a -> a -> a -> a; silly = undefined
20:27:03 <lambdabot>  .L.hs:175:1:
20:27:03 <lambdabot>      Duplicate type signatures for ‚Äòsilly‚Äô
20:27:03 <lambdabot>      at .L.hs:172:1-5
20:27:12 <sunnymilk> :t silly (silly (silly silly))
20:27:14 <lambdabot> (((a -> a -> a -> a) -> (a -> a -> a -> a) -> a -> a -> a -> a) -> ((a -> a -> a -> a) -> (a -> a -> a -> a) -> a -> a -> a -> a) -> (a -> a -> a -> a) -> (a -> a -> a -> a) -> a -> a -> a -> a) -> (((a -> a -> a -> a) -> (a -> a -> a -> a) -> a -> a -> a -> a) -> ((a -> a -> a -> a) -> (a -> a -> a -> a) -> a -> a -> a -> a) -> (a -> a -> a -> a)
20:27:14 <lambdabot>  -> (a -> a -> a -> a) -> a -> a -> a -> a) -> ((a -> a -> a -> a) -> (a -> a -> a -> a) -> a -> a -> a -> a) -> ((a -> a -> a -> a) -> (a -> a -> a -> a) -> a -> a -> a -> a) -> (a -> a -> a -> a) -> (a -> a -> a -> a) -> a -> a -> a -> a
20:27:33 <f|`-`|f> we don't go to that place, it is silly, sunnymilk 
20:27:51 <TheKing444> ?free silly::a->a->a->a->a->a
20:27:51 <lambdabot> f . silly x y z u = silly (f x) (f y) (f z) (f u) . f
20:28:28 <f|`-`|f> @pl silly
20:28:28 <lambdabot> silly
20:28:37 <f|`-`|f> 0:<
20:28:47 <sunnymilk> lol
20:30:09 <TheKing444> @quote f|`-`|f
20:30:09 <lambdabot> mwc says: I can only believe that Java is a conspiracy perpetrated by keyboard manufacturers
20:31:26 <rvxi> hello
20:31:58 <TheKing444> Hi
20:34:19 <f|`-`|f> @help quote
20:34:19 <lambdabot> quote <nick>: Quote <nick> or a random person if no nick is given
20:34:43 <f|`-`|f> @quote f|`-`|f
20:34:43 <lambdabot> dons says: my feeling is that the Java programmers will welcome us as liberators
20:34:58 <f|`-`|f> uh, who is the bot wrangler?
20:35:10 <f|`-`|f> my name is @quote immune
20:36:40 <dmwit> ?remember f|`-`|f test
20:36:40 <lambdabot> Done.
20:36:44 <dmwit> ?quote f|`-`|f 
20:36:44 <lambdabot> f|`-`|f says: test
20:36:48 <dmwit> No it isn't.
20:36:52 <dmwit> ?forget f|`-`|f test
20:36:52 <lambdabot> Done.
20:38:55 <f|`-`|f> why are there two quote functions
20:39:18 <dmwit> There are at least three commands provided by the quote module.
20:39:22 <dmwit> Why should there be fewer?
20:41:46 <f|`-`|f> because @quote is random only, and ?quote has optional selection
20:41:59 <f|`-`|f> but @help doesn't solve the issue of which quote it's talking about
20:42:15 <f|`-`|f> but it refers to, afaik the ?quote
20:42:44 <dmwit> Both ?quote and @quote refer to the single quote command.
20:43:04 <dmwit> The '?' key is just more convenient than the '@' key on my keyboard.
20:43:20 <f|`-`|f> so the characters are interchangeable
20:43:43 <zacts> sunnymilk: Haskell syntax seems to be so pretty on my eyes
20:43:51 <zacts> (looking at that long lambdabot session above)
20:43:57 <zacts> =)
20:44:06 <dmwit> f|`-`|f: yes
20:44:49 <TheKing444> zacts most of that was types
20:44:56 <TheKing444> some of it was code as well
20:45:01 <zacts> TheKing444: yeah
20:45:15 <zacts> regardless I love Haskell and Haskell-related syntax
20:45:28 <zacts> TheKing444: but, I'm mainly hanging out in #haskell-beginners now
20:45:37 <zacts> but hopefully I'll be able to contribute more here one day
20:47:04 <TheKing444> Haskell's awesomness definitly goes deeper than syntax though.
20:47:43 <sunnymilk> zacts hehe :D
20:47:52 <sunnymilk> i wish everything had haskell syntax
20:48:05 <sunnymilk> like ML derivatives
20:49:28 <TheKing444> > let fibs = fix (\fibFunc n -> if n==0 then 0 else if n==1 then 1 else fibFunc(n-1) + fibFunc(n-2)) in fibs 7
20:49:29 <lambdabot>  13
21:03:24 <SuperAlexAtivar> lambdabot, hey
21:03:25 * hackagebot digitalocean-kzs 0.1.0.3 - digitalocean api for haskell  http://hackage.haskell.org/package/digitalocean-kzs-0.1.0.3 (KazumaSATO)
21:08:15 <augur> so im getting this error from cabal
21:08:24 <augur> Context reduction stack overflow; size = 21   ;    Use -fcontext-stack=N to increase stack size to N
21:08:43 <augur> but if i type -fcontext-stack=25 at the command line, cabal balks
21:09:07 <augur> anyone know what i can do
21:12:07 <ttt_fff> is there a function of type "m a -> m b -> m (a, b)" ?
21:12:22 <ttt_fff> i.e. besides do \n x <- mx \n y <- my \n return (x, y)
21:12:25 <Javran1> :t ((,) <$>)
21:12:27 <lambdabot> Functor f => f a -> f (b -> (a, b))
21:12:42 <ttt_fff> :t ((,) <$> <*>)
21:12:43 <lambdabot> parse error on input ‚Äò<*>‚Äô
21:12:52 <ttt_fff> Javran1 ... almost ?
21:12:58 <Javran1> :t \a b -> (,) <$> a b
21:12:59 <lambdabot> Functor f => (r -> f a) -> r -> f (b -> (a, b))
21:13:06 <Javran1> :t \a b -> (,) <$> a <*> b
21:13:07 <lambdabot> Applicative f => f a1 -> f a -> f (a1, a)
21:13:36 <sccrstud92> :t liftA2 (,)
21:13:37 <lambdabot> Applicative f => f a -> f b -> f (a, b)
21:13:39 <ttt_fff> great, can we make it shorter than "\a -> (,) <$> a <*>"
21:13:41 <ttt_fff> ah
21:13:46 <Javran1> oh right
21:13:47 <ttt_fff> sccrstud92: you win
21:13:53 <sccrstud92> ttt_fff: =)
21:14:03 <sccrstud92> slow and steady
21:14:17 <dmwit> augur: What does "at the command line" mean?
21:14:33 <dmwit> augur: Normally you need something like --ghc-options=-fcontext-stack=25 or whatever.
21:14:36 <sccrstud92> dmwit: he means passing that flag to cabal
21:14:38 <dmwit> Are you using that?
21:15:49 <augur> dmwit: aha ok thats how i do it
21:17:01 <augur> dmwit: what is this context reduction stack?
21:21:33 <ttt_fff> is there an option to tell cabal "don't compile; just use runhaskell; I just want you to run the prog once really fast, I don't need you to produce a fast binary"
21:21:46 <ttt_fff> i.e. I don't want to minimize runtime of ouutput binary; I want to minimize "compile time + running prog once"
21:21:55 <zacts> ThreeOfEight: well of course re: Haskell's awesome going deeper than just its syntax
21:21:58 <zacts> =)
21:22:32 <[k-> https://www.reddit.com/r/programming/comments/3bd2ja/lambda_calculus_and_coffeescript/
21:25:22 <hairyian> hello. can someone help me track down definition of _Just in the lens package? I want to write something similar but I have no idea how
21:25:52 <sccrstud92> src _Just
21:25:55 <sccrstud92> @src _Just
21:25:56 <lambdabot> Source not found. stty: unknown mode: doofus
21:26:16 <hairyian> I tried hoogle but couldnt find it
21:27:20 <sccrstud92> hairyian: https://hackage.haskell.org/package/lens-4.11/docs/src/Control-Lens-Prism.html#_Just
21:27:40 <hairyian> thanks! how did you find it?
21:28:26 <sccrstud92> hairyian: we were talking about prisms earlier, and i remembered =)
21:28:44 <hairyian> ah :)
21:28:49 <sccrstud92> _Just is a Prism, so I checked the Prism module
21:28:50 <sccrstud92> lol
21:30:37 <c_wraith> ttt_fff: on sufficiently recent versions of cabal, you could use a command like cabal exec runghc Foo.hs
21:30:47 <hairyian> yeah.. I have no idea what a prism is. But I think I can still get it working by tweaking the source of _Just
21:30:58 <ttt_fff> c_wraith : and this will ue all of my *.cabal flags ?
21:31:11 <c_wraith> ttt_fff: it should.  that's what cabal exec is for
21:31:14 <ttt_fff> it does not use all of my *.cabal flags
21:31:24 <ttt_fff> I just tried it
21:31:33 <ttt_fff> 1.20.0.1
21:31:36 <ttt_fff> maybe mine is not sufficiently new
21:36:42 <hairyian> actually I have no idea how to write this prism.. data Wrap = WrapFoo Foo | WrapBar Bar.  can I write a prism _Wrap that will return either Foo or Bar?
21:38:05 <ttt_fff> what is a prism ?
21:38:11 <ttt_fff> is it whwat newton used to refract light?
21:38:30 <sccrstud92> hairyian: the prism has to return Maybe Foo or Maybe Bar
21:38:39 <sccrstud92> you could just write a normal function
21:38:42 <hairyian> that is fine
21:38:50 <sccrstud92> Wrap -> Either Foo Bar
21:38:55 <sccrstud92> but they are the same
21:39:02 <c_wraith> hairyian: to be a proper Prism, you also need to be able to reverse it..
21:39:26 <hairyian> what does that mean, to be able to reverse it?
21:39:36 <sccrstud92> you can create a prism with Wrap -> MAybe Foo and Foo -> Wrap functions
21:39:57 <sccrstud92> you can create a disfferent prism with Wrap Maybe Bar and Bar -> Wrap
21:40:27 <hairyian> ok I can easily write those.. what do I do then? just pass them to prism function?
21:41:02 <c_wraith> hairyian: the easiest way to get a Prism is to use the prism function in Control.Lens.Prism
21:41:38 <sccrstud92> hairyian: you can use prism or prism' from Control.Lens.PRism
21:42:41 <hairyian> prism fooToWrap wrapToMaybeFoo?
21:43:27 * hackagebot neet 0.3.1.0 - A NEAT library for Haskell  http://hackage.haskell.org/package/neet-0.3.1.0 (hijiri)
21:43:43 <hairyian> well there is an obvious issue.. Wrap can contain both Foo and Bar
21:43:55 <c_wraith> that's not an issue
21:44:19 <c_wraith> That's kind of the whole purpose of Prisms
21:44:45 <hairyian> ok.. I just found out about prisms few minutes ago
21:45:27 <c_wraith> @let data Foo = Foo deriving (Show, Eq) ; data Bar = Bar deriving (Show, Eq) ; data Wrap = WrapFoo Foo | WrapBar Bar deriving (Show, Eq)
21:45:29 <lambdabot>  Defined.
21:46:02 <hairyian> :) *crosses fingers*
21:47:07 <c_wraith> @let _WrapFoo = prism' WrapFoo (\x -> case x of WrapFoo z = Just z ; _ -> Nothing)
21:47:07 <lambdabot>  Parse failed: Parse error: =
21:47:17 <c_wraith> @let _WrapFoo = prism' WrapFoo (\x -> case x of WrapFoo z -> Just z ; _ -> Nothing)
21:47:19 <lambdabot>  Defined.
21:47:55 <c_wraith> > WrapFoo Foo ^? _WrapFoo
21:47:57 <lambdabot>  Just Foo
21:48:05 <c_wraith> > WrapBar Bar ^? _WrapFoo
21:48:07 <lambdabot>  Nothing
21:48:15 <c_wraith> And so on. :)
21:52:00 <hairyian> ah I see. but I imagined it working a bit differently. lets say that Foo and Bar share the same lens, "size". I used makeField to generate HaveSize etc. so I would like to do something like this: set (_Wrap.size) 0 wrap
21:54:35 <hairyian> and this should be a compile error: set (_Wrap.lensThatOnlyFooHas) x (Wrap bar)
21:56:21 <hairyian> is this even possible?
21:56:33 <gamegoblin> Does anyone here know Pipes?
21:56:51 <sccrstud92> hairyian: why not use a HasSize typeclass?
21:57:24 <sccrstud92> somehing like
21:57:33 <sccrstud92> class HasSize a where
21:57:48 <sccrstud92> sizeLens :: SimpleLens s Int
21:58:43 <hairyian> you mean writing a size instance for Wrap?
21:58:53 <hairyian> HasSize instance
21:59:08 <sccrstud92> yeah
21:59:10 <sccrstud92> and Foo and Bar
21:59:37 <sccrstud92> and the instance for Wrap can use the instances for Foo and Bar
21:59:56 <sccrstud92> also look at this http://hackage.haskell.org/package/lens-4.5/docs/Control-Lens-TH.html#v:makeClassy
22:01:34 <hairyian> but then I think I would have two unpleasant choices: lenses that only Foo has and Bar doesnt either wont work or they will be partial?
22:03:07 <hairyian> I am using makeFields now, should I switch to makeClassy? I really dont know what I am doing..
22:04:33 <sccrstud92> hairyian: i havent used most of the lens package, so I don't know for sure what would work
22:04:49 <sccrstud92> i know that
22:04:54 <sccrstud92> logically
22:05:04 <sccrstud92> a Wrap is either a Foo or a Bar
22:05:09 <hairyian> yes
22:05:21 <sccrstud92> and you can get an Int from Foo, but you can also get Int from a Bar
22:05:57 <sccrstud92> this means its possible to make a lens from Bar to Int and from Foo to Int
22:05:59 <sccrstud92> i.e.
22:06:08 <sccrstud92> SimpleLens Foo Int
22:06:14 <sccrstud92> SimpleLens Bar Int
22:06:39 <sccrstud92> however, you cant make SimpleLens Wrap Foo or SimpleLens Wrap Bar
22:06:48 <hairyian> that will work fine. but what if only bar has name field and is part of HasName typeclass? how can I habdle this?
22:07:35 <sccrstud92> you can add a nameLens :: SimpleLens a String to HasName
22:07:57 <sccrstud92> i dont have time to go into all of this tonight because im passing out
22:08:01 <sccrstud92> but i will be on tomorrow
22:08:12 <sccrstud92> you can also post a question on /r/haskellquestions
22:08:21 <sccrstud92> and i will answer tomorrow if no one beats me to it
22:08:24 <hairyian> should it be Maybe String? 
22:08:35 <sccrstud92> depends on what HasName means
22:08:46 <sccrstud92> is it guarenteed to have a name?
22:08:48 <sccrstud92> or
22:08:54 <sccrstud92> might have a name?
22:09:53 <sccrstud92> anyway
22:09:53 <hairyian> Foo is guaranteed to have a name, Bar is guaranteed to not even have a name lens
22:10:08 <sccrstud92> talk to you tomorrow
22:13:26 <hairyian> ok, see you. if someone else wants to continue: if I just make Wrap a part of HasName class then name will be partial, which isnt ideal.. I think I really want a _Wrap prism where: firstOf (_Wrap.name) returns Just "somename" for (Wrap Foo) object and Nothing for (Wrap Bar)
22:19:41 <hairyian> to recap and then I will shut up and idle.. data Wrap = WrapFoo Foo | WrapBar Bar.  Foo and Bar share size lens,  view (_Wrap.size) wrap should return Int.  Foo has name lens (String) and Bar doesnt.. "firstOf (_Wrap.name)" should return Just "name" for fooWrap and Nothing for barWrap
22:26:42 <dmwit> augur: I don't really know.
22:26:53 <augur> dmwit: hm?
22:27:17 <dmwit> you asked what the ctxt redxn stack was
22:27:28 <augur> oh right :)
22:33:29 * hackagebot tld 0.1.0.0 - This project separates subdomains, domains, and top-level-domains from URLs.  http://hackage.haskell.org/package/tld-0.1.0.0 (jp_rider)
22:38:29 * hackagebot tld 0.1.0.1 - This project separates subdomains, domains, and top-level-domains from URLs.  http://hackage.haskell.org/package/tld-0.1.0.1 (jp_rider)
22:44:40 <zipper> How do I check that IO has thrown an exception?
22:45:08 <zipper> Where can I read about IO exceptions?
22:45:24 <wei2912> zipper: here you go: https://wiki.haskell.org/Exception
22:46:25 <ttt_fff> I have a piece of haskell code. It needs to upload a file to google drive. What is the easiest way to do this?
22:49:00 <slack1256> Does google drive have an web facing API?
22:51:30 <ttt_fff> I don't know. I just have a username/password combo.
22:51:35 <ttt_fff> I'm hoping for something like sftp
22:58:30 * hackagebot tagged 0.8.1 - Haskell 98 phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-0.8.1 (EdwardKmett)
23:00:57 <Jafet> augur: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-class-extensions.html#undecidable-instances
23:02:53 <augur> Jafet: very confusing
23:09:29 <ReinH> ttt_fff: well, that depends on what google drive supports
23:09:48 <ttt_fff> ReinH: can you look into this and report back to me?
23:10:01 <ReinH> No.
23:10:28 <ReinH> It's rude to ask people to do work for free.
23:10:37 <ttt_fff> This is an important ability. You need to increase your stackoverflow/google-fu
23:10:48 <ReinH> Nope.
23:11:35 <ttt_fff> Alright, fine. What if instead of asking you to do it for free, I upped my offer to 1 dogecoin?
23:12:19 * ReinH yawns
23:13:58 <saurik> -win 35
23:16:41 <yayfoxes> guys, can we work on cis 194 together?
23:18:13 <yayfoxes> I don't understand how to take the head of a string's real representation (a list) and turn it into a number
23:18:54 <yayfoxes> oh, that's a Char value
23:19:24 <yayfoxes> so how do you take any Char that is a letter defining a number and turn that into a number?
23:19:40 <DNoved1> > ord 'a'
23:19:41 <lambdabot>  97
23:19:59 <yayfoxes> > ord '1'
23:20:01 <lambdabot>  49
23:20:07 <DNoved1> Hmm, I onder if fromEnum works too
23:20:12 <kadoban_> > digitToInt '5'
23:20:14 <lambdabot>  5
23:20:16 <DNoved1> > fromEnum 'a'
23:20:18 <lambdabot>  97
23:20:46 <gamegoblin> Does anyone here know Pipes?
23:22:42 <slack1256> gamegoblin: ask the question, if somebody knows he/she will probably answer
23:22:52 <slack1256> maybe not at this hours though
23:23:32 <gamegoblin> slack1256: I‚Äôve got about 70 lines of code in an lpaste that I need help finding the bug in, I posted earlier but didn‚Äôt get any responses, wanted to snag someone individually
23:24:14 <slack1256> which lpaste?
23:24:16 <gamegoblin> Specifically here http://lpaste.net/7577126882072592384 Somewhere there is an infinite loop or some blocking call in my second test case and I can‚Äôt find it for the life of me
23:25:35 <slack1256> (Lazy answer) did you try debugging with ghci?
23:26:49 <ReinH> > ord '1' - ord '0'
23:26:51 <lambdabot>  1
23:27:24 <ReinH> (this ofc doesn't check if the Char is actually a digit)
23:27:38 <ReinH> so you can get nonsensical results
23:29:39 <Adeon> ReinH: second test case = testByteSinkToConsumer?
23:29:49 <ReinH> ?
23:29:55 <Adeon> in your paste
23:29:59 <ReinH> my paste?
23:30:02 <Adeon> er wait
23:30:03 <Adeon> sorry
23:30:10 <ReinH> :)
23:30:12 <Adeon> gamegoblin: second test case = testByteSinkToConsumer?
23:30:23 <Adeon> totally similar nicks
23:30:31 <Adeon> I cannot be blamed
23:30:35 <slack1256> yeah, totally
23:31:54 <gamegoblin> gamegoblin: yes
23:32:00 <gamegoblin> Adeon: yes
23:32:02 <gamegoblin> ....
23:32:05 <gamegoblin> whoops
23:32:39 <gamegoblin> slack1256: yes I have tried debugging in ghci, I‚Äôve tried using Debug.Trace to print stuff all over the place
23:34:28 <ttt_fff> does Data.Text.Lazy have a function "Int -> Text -> Text", where >>> magic 5 "foo" = "foofoofoofoofoo"
23:35:07 * slack1256 looks at konversation crashing because somebody said your name in a channel
23:35:54 <ElMoloko> @ttt_fff yeah, replicate
23:35:54 <lambdabot> Unknown command, try @list
23:36:11 <ElMoloko>  @ttt_fff yeah, replicate
23:36:34 <ElMoloko> Oh, text.lazy...hmm
23:36:51 <ElMoloko> yeah
23:37:12 <chaosmasttter> gamegoblin: to me it looks like you are putting the read bytestrings back into the state, so the list is never going to be empty ...
23:38:13 <gamegoblin> chaosmasttter: oh crap, I think you‚Äôre right. conceptually I had thought of them as being separate states (one for producer and one for consumer).
23:38:28 <gamegoblin> chaosmasttter: lemme fix it to an (input, output) tuple and try
23:38:50 <ElMoloko> ttt_ffff: Though it looks like you're looking for a Int -> String -> Text function, since you can't implicitly coerce String -> Text
23:41:21 <ElMoloko> i mean just refine replicate' x y = replicate x $ pack y
23:41:27 <ElMoloko> *define
23:42:34 <jle`> if you're using string literals you can also just enable OverloadedStrings and have "foo" parse as Text
23:43:54 <ElMoloko> Oh awesome, of course :)
23:45:23 <gamegoblin> chaosmasttter: that was it, I love you
23:56:26 <ttt_fff> https://hackage.haskell.org/package/containers <-- has strict and lazy Map. Why is there only one Set ?
23:58:33 * hackagebot envy 0.2.0.0 - An environmentally friendly way to deal with environment variables  http://hackage.haskell.org/package/envy-0.2.0.0 (DavidJohnson)
23:59:47 <slack1256> ttt_fff: Set are strict "data Set a    = Bin {-# UNPACK #-} !Size !a !(Set a) !(Set a)" basically
