00:00:21 <wyager> Just because a function (or action) "does almost nothing" under the hood (because it defers evaluation or execution, respectively) doesn't mean we go around saying that it doesn't return the type it claims to return
00:00:42 <wyager> hGet returns a ByteString when executed
00:00:48 <wyager> Yes, it is lazily generated
00:00:53 <wyager> but it's still a ByteString
00:00:53 <Cale> I didn't claim otherwise
00:00:55 <nshepperd> wyager: I don't think anyone's saying that
00:01:20 <wyager> Cale: You said "Nope, executing hGet does almost nothing, returning a result whose later *evaluation* causes more I/O to happen, which actually reads the handle."
00:01:38 <wyager> Which is true, but why bother speaking in those terms?
00:01:40 <Cale> But the important thing to realise is that this ByteString is not an ordinary ByteString, but an expression which when evaluated will cause I/O (and possible exceptions) to occur.
00:01:56 <Cale> I never said it's not a ByteString, it obviously is.
00:02:43 <Cale> Just as  1 : 2 : 3 : undefined :: [Integer]
00:03:38 <Cale> (Lazy IO greatly complicates the space of potential values, far more than just nontermination though.)
00:06:34 <wyager> The only thing I disagree with is your claim "The execution of hGet doesn't cause the exception to fire."
00:06:44 <Cale> It doesn't!
00:06:56 <wyager> Because, by convention, we refer to functions that lazily generate a value as simply generating that value
00:06:59 <Cale> Try never evaluating the resulting ByteString
00:07:03 <Cale> and you'll see
00:07:05 <wyager> it's like saying "repeat doesn't return a lit"
00:07:07 <wyager> *list
00:07:27 <wyager> Again, this is semantics
00:07:33 <Cale> If you only execute the hGet, and don't evaluate its result, no exception will occur, and the file will not have been read.
00:07:42 <wyager> Just because it generates the exception lazily doesn't mean it generates the exception
00:08:06 <wyager> "if you only evaluate the repeat to WHNF, and don't evaluate the tail, no list will occur"
00:08:24 <Cale> No, you do get a list though.
00:08:41 <wyager> Indeed, and with hGet you get an exception
00:08:42 <nshepperd> this is a bad analogy, execution is fundamentally different to evaluation
00:08:50 <wyager> it doesn't matter where thunk evaluation happens
00:08:52 <nshepperd> 'unsafeInterleaveIO (print "hi")' doesn't print anything when you execute it
00:09:00 <Cale> I think you're missing something about the usual terminology here, or something.
00:09:51 <nshepperd> wyager: the point is not *where* thunk evaluation happens, but that stuff happens during thunk evaluationg, and not during execution *at all*
00:10:19 <wyager> This is the semantic part
00:10:28 <Cale> hm?
00:10:41 <wyager> I claim that "during execution" includes the deferred bits
00:10:45 <Cale> Well, it's an important part of the operational semantics of Haskell, I suppose.
00:10:45 <nshepperd> the difference between execution and evaluation is not really "semantics"
00:11:02 <wyager> No, nshepperd, obviously not
00:11:04 <nshepperd> execution involves the RTS making syscalls and stuff
00:11:16 <wyager> I'm completely aware of this
00:11:40 <Cale> By contrast, evaluation *usually* doesn't, but in the presence of unsafeInterleaveIO, it may.
00:12:06 <hmsster> when does "unsafeInterleaveIO (print "hi")" print something?
00:12:15 <Cale> hmsster: When the resulting () is evaluated.
00:12:31 <nshepperd> which may be never
00:12:34 <hmsster> wtf
00:12:50 <Axman6> it's unsafe for very good reasons
00:12:51 <Cale> It's called unsafe for a reason
00:13:14 <hmsster> why would you do that
00:13:23 <Cale> hmsster: You generally wouldn't.
00:13:24 <Axman6> to make lazy IO work
00:13:25 <wyager> e.g. Lazy ByteStrings
00:13:31 <Axman6> (for some definition of "work")
00:13:37 <Cale> hmsster: But lazy I/O makes use of it 
00:13:46 <wyager> And the argument we're having is whether or not Lazy execution is really execution
00:14:07 <Axman6> Lazy IO is generally considered to be a not particularly good idea so if you can use streaming IO libraries like conduit, pipes, machines etc then you'll be better off
00:14:15 <Cale> e.g. when you execute hGetContents h, the handle h isn't read from, instead, you get a String whose evaluation will read from the handle.
00:14:35 <mauke> what's "lazy execution"?
00:14:50 <wyager> Non-strict execution
00:14:52 <wyager> :)
00:14:58 <mauke> yes, what is that?
00:15:09 <wyager> Execution that doesn't happen strictly
00:15:17 <wyager> Not sure what you're looking for
00:15:18 <nshepperd> wyager: why are you still using the terms execution and evaluation interchangeably?
00:15:25 <wyager> I'm not
00:15:26 <mauke> wyager: an explanation of wtf you're talking about
00:15:29 <wyager> I mean execution
00:15:39 <Cale> wyager: Execution is always strict in the sense that it needs to evaluate the IO action to be executed.
00:15:48 <mauke> a function f is strict in its argument if f _|_ = _|_
00:15:54 <Cale> (otherwise, it wouldn't know which effects ought to occur)
00:15:59 <mauke> what does "strict" mean when applied to execution?
00:16:42 * frerich wonders why people have wyager wade through this silly Q&A game even though it's not too hard to guess what he means modulo nomenclature.
00:16:53 <hmsster> is _|_ deliberately made to look like buttocks
00:17:38 <liste> hmsster the proper symbol is inverted T
00:17:41 <mauke> hmsster: yes, it means "bottom"
00:17:57 <Axman6> ‚ä• is usually how it's written
00:18:03 <nshepperd> wyager: if you're talking about the execution of 'print 7' inside of 'unsafeInterleaveIO (print 7)', then yes, that is execution
00:18:05 <mauke> frerich: if it's so easy, feel free to explain
00:18:09 <Axman6> but not masny people can type that easily
00:18:20 <nshepperd> wyager: that occurs during the *evaluation* of the resulting ()
00:18:32 <nshepperd> wyager: and not during the execution of 'unsafeInterleaveIO (print 7)'
00:18:34 <frerich> mauke: No, I'd rahter not spoil the fun for you, I know that you appreciate it if somebody is wrong on the Internet. I'm just waiting for you to go 'show me'. ;-)
00:18:54 <mauke> frerich: ???
00:18:54 <frerich> mauke: (Assuming that you are the same mauke as 'mauke[' aka Lukas Mai ;-)
00:19:14 <mauke> no, I find this stuff hard and highly non-intuitive
00:19:35 <mauke> which is why I often have to fall back to definitions of basic terminology
00:20:11 <Cale> frerich: Well, we're sort of off on a tangent which is entirely about the fact that wyager doesn't seem to like the usual terminology
00:20:20 <mauke> I absolutely can't stand people going "oh, you know what I mean" when I've just said I don't know what they mean and am asking for clarification
00:21:43 <Cale> wyager: So you're using Binary? Are you using decodeFileOrFail and still having this issue?
00:22:07 <Cale> wyager: Or runGetIncremental
00:22:18 <wyager> Cale: I'm not asking for help solving it, I'm lamenting about the simultaneous use of laziness and exceptions
00:22:29 <Cale> wyager: runGet provides you with *no* means of handling errors sanely
00:22:48 <wyager> mauke: Re "what does "strict" mean when applied to execution?", I don't know, ask the people who named "Data.ByteString.Lazy" what they meant by "Lazy"
00:22:53 <Cale> It's for people who are extremely confident that the operation will succeed only./
00:23:07 <mauke> wyager: they were talking about evaluation, not execution
00:23:52 <Cale> There is a notion of strict and lazy I/O, but the distinction there is all about whether the I/O actually happens during execution or evaluation.
00:24:05 <Cale> Not actually about evaluation order
00:24:45 <hmsster> during execution or evaluation of the result of execution?
00:25:02 <Cale> hmsster: yes, that's right
00:25:10 <taruti> reading the MonadFail proposal I keep thinking that things would really benefit from an optional totality checker. "foo = do (x:_) <- zzz; return x" vs "foo = do z' <- zzz; let (x:_) = z'; return $! x"
00:25:31 <wyager> mauke: From the Lazy ByteString docs, there's all sorts of language like "Will read lazily". How do you interpret that?
00:25:33 <nshepperd> during (execution) or (evaluation of the result of execution)
00:25:54 <Cale> taruti: Not to mention  foo = do ~(x:_) <- zzz; return x
00:26:07 <mauke> wyager: good question
00:26:51 <Cale> wyager: It means that the read will occur during the evaluation of the result of executing the action.
00:26:54 <taruti> Cale: yes :)
00:27:40 <wyager> Cale: It seems like you're going out of your way to avoid interpreting what the text literally says
00:27:42 <mauke> wyager: yeah, what Cale said. or in other words: works like http://hackage.haskell.org/package/base-4.8.0.0/docs/System-IO.html#v:hGetContents
00:27:48 <wyager> which is that the action of reading occurs lazily
00:28:08 <Cale> wyager: You can take "x will happen lazily" as shorthand for "x will happen when you evaluate the result of this action, and not when the action is executed"
00:28:10 <mauke> are you using a non-standard definition of "action"?
00:28:26 <mauke> because I can't interpret "occurs" in that context
00:30:13 <wyager> Cale: So basically, it seems like you're (for some reason) objecting to the logical application of that shorthand to say "hGet raises an exception lazily"?
00:30:19 <voidzero> taruti could you give me a link for said proposal?
00:30:36 <taruti> voidzero: https://github.com/quchen/articles/blob/master/monad_fail.md
00:30:43 <voidzero> danke ^^
00:31:21 <wyager> Because that's literally what I've been saying
00:31:30 <Cale> wyager: I didn't object to that
00:32:28 <voidzero> wyager dunno if it is just me but you seem worked up over what to me seems a semantic discussion
00:32:33 * voidzero sips his morning coffee
00:32:33 <taruti> lazy io means that there *will* be an exception at the most unfortunate moment in code least prepared to deal with it.
00:32:35 <Cale> wyager: I said that the execution of hGet doesn't cause the exception (though reading the code, this entire conversation might have been stupid, because it looks as if hGet is actually entirely strict.)
00:32:41 <wyager> You said "The execution of hGet doesn't cause the exception to fire." in response to my claim that hGet (lazily) raises an exception.
00:33:03 <wyager> voidzero: Why do you think I come to #haskell?
00:33:04 <srhb> Right, those two claims are completely disparate
00:33:19 <srhb> Ugh, now I got sucked into it. :P
00:33:23 * srhb flees
00:33:29 <voidzero> wyager, to get an answer?
00:33:33 <voidzero> sheesh
00:33:37 <wyager> There's no better place to get worked up about semantics
00:33:45 <voidzero> aha
00:33:51 <voidzero> wait up for me srhb :)
00:34:03 <Axman6> these semantics are sadly hard :(
00:34:04 <srhb> Bring coffee.
00:34:12 <voidzero> :D
00:34:39 <srhb> I have this annoying error in my brain where I tend to misread coffee as cofree. ._.
00:34:47 <srhb> #shitHaskellersSay
00:34:48 <wyager> We've managed to spend the last 30+ minutes saying mostly slightly different versions of the same thing. You can't get that in most places
00:35:10 <liste> a programmer is a morphism from coffee to code, a coprogrammer is a morphism from de to ffee
00:35:23 <liste> (don't remember where I read something like that)
00:35:34 <Axman6> @quote coffee
00:35:34 <lambdabot> napping says: Being too tired to remember to change the grounds before running the coffee maker is a self-reinforcing problem
00:35:42 <Cale> wyager: How are you even getting an exception from hGet?
00:35:42 <Axman6> @quote coffee
00:35:43 <tejing> wyager: what are you talking about... isn't that what most internet discussions are full of?
00:35:43 <lambdabot> napping says: Being too tired to remember to change the grounds before running the coffee maker is a self-reinforcing problem
00:35:46 <Axman6> bleh :(
00:35:58 <wyager> Cale: Closing a socket
00:36:28 <voidzero> i bought a unicomp dvorak keyboard
00:36:39 <voidzero> like the ibm model m keyboard
00:36:41 <liste> unicomp is awesome
00:36:48 <wyager> tejing: The discussions here tend to result in me accidentally learning math, which is  a nice side effect
00:36:49 <voidzero> YES BUT VERY LOUD!
00:36:53 <liste> too bad my coworkers wouldn't aprecciate that
00:36:54 <tejing> heh
00:37:03 <hmsster> :t randomIO
00:37:07 <lambdabot> Random a => IO a
00:37:10 <hmsster> :t random
00:37:12 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
00:37:18 <hmsster> which one should I use?
00:37:29 <srhb> hmsster: Depends!
00:37:35 <hmsster> on what
00:37:42 <srhb> hmsster: Whether you want pure or IO
00:37:45 <voidzero> and so it begins
00:38:07 <srhb> hmsster: Most people tend to get an initial seed from IO and then use the pure functions. 
00:38:41 <liste> the pure versions can be deterministic, so you can e.g. test with a specific seed
00:38:52 <srhb> "can" be? :P
00:38:55 <liste> are
00:38:58 <srhb> :-)
00:39:22 <hmsster> is randomIO "more random"?
00:39:29 <srhb> randomIO is nondeterministic
00:39:30 <wyager> srhb: hmsster: Also look at MonadRandom. It has the same nice syntax as randomIO, but it works in a pure monad
00:40:04 <hmsster> wyager: hmm
00:40:11 <liste> "more random" reminds me of mt_rand() :D
00:40:12 <wyager> Basically a state monad wrapper for Random
00:40:19 <srhb> hmsster: In other words, two executions of randomIO may/will give you different values. Passing the same generator to random will always produce the same (a,g)
00:40:48 <srhb> hmsster: This is very practical. :)
00:40:49 <Cale> wyager: Despite our whole conversation here, hGet (even for Data.ByteString.Lazy) isn't actually lazy, doesn't use unsafeInterleaveIO in any way, and the exception it throws is not part of the evaluation of the resut, but occurs during its execution and is easy to catch.
00:41:23 <lpaste> Cale pasted ‚Äútest case‚Äù at http://lpaste.net/134224
00:41:25 <srhb> hmsster: usually you'd do something like randomIO >>= \g -> myProgramWithInitialGenerator g
00:41:49 <srhb> hmsster: Now myProgramWith... can be pure but still produce real randomness from the user's perspective
00:41:50 <wyager> Cale: See "lazyRead = unsafeInterleaveIO loop"
00:42:01 <Cale> hGet :: Handle -> Int -> IO ByteString
00:42:02 <Cale> hGet = hGetN defaultChunkSize
00:42:15 <Cale> and then look at the definition of hGetN
00:42:33 <Cale> It's just an entirely straightforward loop of strict reads
00:42:43 <Cale> Nothing is deferred
00:43:21 <wyager> What the hell is the point of even using it then
00:43:22 <Cale> hGetContents is different in that regard
00:43:29 <wyager> It's not even really lazy
00:43:40 <Cale> You use it when you want a lazy bytestring immediately.
00:43:54 <wyager> Yep, confirmed at http://stackoverflow.com/questions/10649636/lazy-bytestring-built-from-socket-handle-cannot-be-consumed-and-gced-lazily
00:43:55 <wyager> How lame
00:44:14 <hmsster> wyager: why would one use MonadRandom equivalent over random or randomIO?
00:44:20 <wyager> So you get the downsides of laziness and the upsides of strictness
00:44:27 <wyager> hmsster: A nicer monad-based interface
00:44:34 <wyager> so you don't have to keep track of g
00:44:48 <wyager> And it's pure, so it works in some places randomIO doesn't
00:44:58 <wyager> I'd argue deterministic PRNGs are better for testing
00:45:07 <srhb> hmsster: Basically when you use random, you need to save the new generator and use it for the next call to random in order to actually get new results.
00:45:29 <wyager> s/upsides/downsides
00:45:33 <srhb> hmsster: MonadRandom hides that from you, instead allowing you to do something like n <- getNextRandom -- which will automatically save the new generator to the state for next time
00:45:58 <hmsster> I was annoyed that there are two ways of doing the same thing, only to find out there is a third way :/
00:46:23 <Cale> MonadRandom is just a thin wrapper around MonadState which I wrote and stuck on the Haskell Wiki at one point, as an example of something you could do with the State monad.
00:46:48 <srhb> hmsster: Why on earth would that annoy you? :P
00:46:48 <Cale> (other people kindly took it and made a nice package out of it :)
00:49:09 <hmsster> why do we need three ways of getting pseudo-random number?
00:49:12 <srhb> hmsster: In fact this paradigm translates to most Haskell programs. You generally do some initial IO'y stuff and then move as much as you can to pure functions (for testing and determinism)
00:49:24 <Cale> hmsster: lol, I was about to suggest yet another way
00:50:20 <Cale> QuickCheck has this lovely Gen monad with lots of nice primitives for generating random values of various types with various conditions placed on them
00:50:21 <wyager> Well thanks Cale and Mauke for the discussion. I'm off, cheers
00:50:54 <Cale> I always wish that someone would extract Gen/Arbitrary/Coarbitrary from QuickCheck and put them in their own library, because they're useful independently
00:51:13 <srhb> What on earth is a Coarbitrary? :P
00:51:36 <Cale> srhb: It's a way of altering a random generator state using a value of some type
00:51:44 <hmsster> Cale haha
00:51:44 <srhb> Ah.
00:51:48 <Cale> coarbitrary :: (Coarbitrary a) => a -> Gen b -> Gen b
00:52:35 <Cale> hmsster: Also, if you're interested in high quality pseudorandomness even in the presence of splitting, I recommend the tf-random library
00:52:39 <Cale> http://hackage.haskell.org/package/tf-random
00:53:38 <ReinH> it's used so that a function a -> b can generate different b's for different choices of a's
00:53:54 * hackagebot hpack 0.3.0 - An alternative format for Haskell packages  http://hackage.haskell.org/package/hpack-0.3.0 (SimonHengel)
00:54:09 <Cale> One thing which really surprised me (and which I continue to find mildly irritating) is that the whole of computer science up to Micha≈Ç Pa≈Çka's work on this package seems to have completely ignored what ought to be one of the most fundamental operations for a PRNG.
00:54:23 <Cale> That is, how to split a random generator state into two.
00:55:07 <Cale> If you have a way to get a bit from a state, and a way to split a state, then you can do sequences, but you can also do much more.
00:55:14 <ReinH> comonoids, of course
00:55:39 <Axman6> a -> (a,a)?
00:55:57 <hmsster> Cale so we need 5 more random libraries of each flavor that fixes this
00:55:59 <Cale> The StdGen implementation of split is actually pretty broken, sadly
00:56:30 <Cale> hmsster: Well, depending on your performance needs, you might also consider mwc-random
00:56:39 <Cale> mwc-random is quite fast
00:57:09 <Cale> Also, it comes with some non-uniform distributions built in :)
00:57:12 <Cale> http://hackage.haskell.org/package/mwc-random-0.13.3.2/docs/System-Random-MWC-Distributions.html
00:58:03 <Cale> hmsster: The generation of pseudorandom values has a lot of very different sorts of applications, and it makes sense for there to be many ways to do it.
00:58:03 <hmsster> Cale I think I will just write my own PRNG library.. seems like that is what everyone else is doing
00:58:35 <srhb> hmsster: People write different libraries because they have different needs. :P
00:59:21 <Cale> hmsster: QuickCheck used to use StdGen, but it ran headlong into the problem with split on StdGen being terrible.
00:59:47 <Cale> hmsster: Many tests were spuriously succeeding just because after several splits, the resulting generators became correlated.
01:00:01 <Cale> So tf-random solved that issue :)
01:00:17 <Cale> (The Gen monad in QuickCheck uses tf-random behind the scenes)
01:00:38 <unknownloner> is there a better way to write listToMaybe . mapMaybe
01:01:07 <unknownloner> I mean I basically just want the first Just value, or Nothing if there is none
01:01:25 <ReinH> seems fine
01:02:07 <Cale> unknownloner: msum . map f?
01:03:52 <frerich> unknownloner: In case changing the function which yields a Maybe is viable, you might also be able to go with Data.List.find
01:06:04 <unknownloner> don't think that'd work for me. msum . map looks like it does what I want
01:06:08 <unknownloner> thanks!
01:06:48 <ReinH> I don't see the problem with the original
01:06:56 <unknownloner> I just don't like how long it is
01:07:01 <unknownloner> *shrug*
01:07:14 <unknownloner> nothing really _wrong_ with it
01:08:15 <srhb> Strange, omapM_ is consistently slower than my ad-hoc foldM
01:08:25 <Cale> heh, it'd have to be  (msum .) . map
01:08:26 <srhb> Maybe the direction matters...
01:09:06 <supki> :t alaf First foldMap
01:09:08 <lambdabot> Foldable t => (a -> Unwrapped (First b)) -> t a -> Unwrapped (First b)
01:10:01 <ReinH> foldr ((<|>) . f) Nothing :p
01:10:05 <frerich> srhb: If it's indeed performance-critical, then you may be even better of with avoiding foldM, too - some time ago I found that it was actually a major slowdown for me. Now I have this piece of code in my progrma, ahem... http://lpaste.net/134227
01:10:40 <frerich> Alas I don't remember who told me to not go for what hlint suggested in this case. :-(
01:10:54 <hmsster> :t foldMap
01:10:55 <srhb> frerich: In this case I still have to traverse a ByteString somehow, so listing it up is not an option
01:10:58 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
01:11:08 <srhb> frerich: My foldM is just a wrapper around ByteString.foldr
01:11:28 <srhb> Which makes it even more puzzling that omapM_ should be slower.
01:13:55 * hackagebot keera-hails-reactive-fs 0.0.3.4 - Haskell on Rails - Files as Reactive Values  http://hackage.haskell.org/package/keera-hails-reactive-fs-0.0.3.4 (IvanPerez)
01:14:11 <srhb> And omapM_ is implemented in terms of ByteString.foldr as well. So weird.
01:14:17 <srhb> Ah well, it was just a toy.
01:19:23 <phaazon> quchen2: that fail proposal is great! I hope the core committee can do something about it :)
01:24:56 <funfunctor> Hi
01:25:21 <funfunctor> How can I deal with this monadic loop case of reading chunks out of a binary file but needing to loop and break http://lpaste.net/134229
01:25:51 <funfunctor> I tried looking over Control.Monad.Loops but I can't seem to see how to organise it
01:26:25 <Cale> funfunctor: I always just end up writing those directly using recursion.
01:26:47 <Cale> funfunctor: Control.Monad.Loops has a bunch of stuff, but it's tough to remember all the variants
01:27:22 <funfunctor> Cale: its annoying because that loop sits in the middle of another action
01:27:36 <funfunctor> How would you go about writing that?
01:28:31 <hmsster> cant you read entire file lazily and then chop it up with pure functions
01:28:45 <srhb> hmsster: Yep.
01:28:54 <funfunctor> Cale: this is the whole action http://lpaste.net/134230
01:28:58 <Axman6> that's often not a good idea though
01:29:09 <hmsster> Axman6: why not?
01:29:28 <Axman6> what if the file is huge?
01:29:59 <Axman6> there's no point reading it all in (which more often than now is what happens with lazy IO because you need to be sure you have it all before the handle is closed)
01:30:05 <Axman6> than not*
01:31:54 <lpaste> Cale annotated ‚ÄúNo title‚Äù with ‚ÄúNo title (annotation)‚Äù at http://lpaste.net/134230#a134233
01:31:59 <nshepperd> hmm, are there any splittable CSPRNGs?
01:32:02 <Cale> maybe like that?
01:32:09 <Cale> You could also use fix nicely there
01:32:39 <lpaste> Cale annotated ‚ÄúNo title‚Äù with ‚ÄúNo title (annotation) (annotation)‚Äù at http://lpaste.net/134230#a134234
01:32:40 <nshepperd> I suppose something like a block cipher in ctr mode with a bit shift as the split operation
01:33:49 <Cale> nshepperd: You could probably write the first paper about them :P
01:34:53 <nshepperd> oh,Claessen Pa≈Çka's paper
01:34:56 <nshepperd> Claessen
01:35:01 <nshepperd>  gah
01:35:07 <nshepperd> their paper looks relevant
01:35:20 <Cale> Well, yeah, it is the only relevant paper on splittable PRNGs at all :)
01:35:27 <Cale> (as far as I can tell)
01:35:47 <Cale> It uses cryptographic hashing, but makes no claims about cryptographic security
01:36:25 <Cale> I guess it is a kind of security proof they provide...
01:38:20 <Cale> Looking at it again, perhaps I should take that back. The implementation provided isn't intended to be used for cryptographic applications, but the algorithm itself does satisfy a pretty strong cryptographic guarantee
01:40:52 <nshepperd> yep, reading it now, it looks pretty reasonable
01:53:24 <exfalso> hi, is there a way to force newtype deriving for Show/Read?
01:54:17 <alpounet> you mean to derive Show/Read for newtypes?
01:54:38 <exfalso> as in if i have newtype I = I Int deriving (Show) i'd like the Show to just use the instance for Int
01:55:39 <exfalso> (with GeneralizedNewtypeDeriving)
01:57:13 <arkeet> exfalso: I don't think so :<
01:57:17 <srhb> exfalso: Wait, just use the instance for Int? That would break the rules of Show/Read
01:57:37 <arkeet> why?
01:57:41 <exfalso> srhb: well i would also derive Read:)
01:57:47 <liste> you could use TH for that
01:58:33 <srhb> arkeet: I suppose you're right. As long as identity is preserved, I guess you can drop the value constructor. Just feels a bit iffy. :P
01:58:41 <srhb> But I guess it's no different from all the fromList ... ones
01:59:04 <srhb> otoh that actually is a valid way of constructing such a value
01:59:13 <srhb> as opposted to 1 :: I
01:59:26 <arkeet> that's valid with the right Num instance for I ;)
01:59:27 <srhb> OK, now I agree with myself again. it is wrong!
01:59:30 <srhb> Ah.. Yeah
01:59:35 * srhb flip flops again
02:00:19 <exfalso> ok i'll just write the instances by hand:)
02:00:23 <exfalso> ty
02:00:27 <arkeet> you can just
02:00:37 <arkeet> yeah, it's a bit of extra work but
02:00:55 <arkeet> instance Show I where showsPrec d (I i) = showsPrec d i
02:00:58 <arkeet> etc
02:01:15 <exfalso> yeah thats exactly what we'll do:)
02:03:49 <tejing> can I write a Show instance for 'newtype Fix f = PutFix { getFix :: f (Fix f) }' without the typechecker keeling over?
02:04:32 <exfalso> ofc
02:05:05 <exfalso> check Show1 in https://hackage.haskell.org/package/prelude-extras-0.3/docs/Prelude-Extras.html 
02:05:17 <arkeet> or I think if you have StandaloneDeriving you can do
02:05:28 <arkeet> deriving instance Show (f (Fix f)) => Show (Fix f)
02:06:05 <exfalso> instance Show1 f => Show (Fix f)
02:06:33 <exfalso> arkeet: that derived instance will loop
02:06:39 <arkeet> no it works!
02:06:43 <exfalso> oh yeah
02:07:07 <exfalso> but it probably needs flexiblecontexts or something
02:07:25 <arkeet> nope
02:07:39 <arkeet> although if it does, I would just enable it anyway.
02:07:44 <arkeet> if it did.
02:08:13 <tejing> arkeet: I would never have expected that to work...
02:08:19 <arkeet> :-)
02:08:39 <quchen2> phaazon: Let's wait for the libraries list discussion, and not escalate to the libraries committee right away :-)
02:08:48 <arkeet> it's just a recursive definition.
02:09:17 <tejing> exfalso: thanks for the link... that looks like a sensible solution in general
02:09:35 <arkeet> >>> newtype Fix f = Fix (f (Fix f))
02:09:35 <arkeet> >>> deriving instance Show (f (Fix f)) => Show (Fix f)
02:09:36 <arkeet> >>> show $ Fix (Just (Fix (Just (Fix Nothing))))
02:09:36 <arkeet> "Fix (Just (Fix (Just (Fix Nothing))))"
02:09:37 <arkeet> works in ghci at least.
02:10:16 <tejing> arkeet: the wierd part though is that there's no base case. I would expect the typechecker to balk because of that
02:10:51 <arkeet> it's value-level recursion, not type-level.
02:11:10 <arkeet> I think I get what you mean though.
02:12:08 <tejing> much like fix (\(a,b)->(1,2)) never terminates
02:12:27 <phaazon> quchen2: that fail has been bothering me since I started to use Haskell
02:14:22 <quchen2> phaazon: One of the disadvantages of the proposal is that there are few hard problems it solves, apart from the fact that fail bothers people
02:14:27 <hmsster> @src fix
02:14:27 <lambdabot> fix f = let x = f x in x
02:14:53 <hmsster> o_O
02:15:13 <jle`> quchen2: another reason for a Monad or Applicative superclass is that the laws are defined in terms of bind and/or (<*>)
02:15:21 <srhb> hmsster: It's an essential function for making recursion unreadable. :)
02:15:45 <jle`> hmsster: try evaluating out something like `fix (1:)` by hand :)
02:15:51 <jle`> as in, get the first item, the second item, the third item, etc.
02:16:06 <jle`> actually that's kind of hard isn't it
02:16:09 <tejing> srhb: I find when you're creating a self-referential data structure it's more readable... otherwise, yea
02:16:56 <quchen2> jle`: Did I forget to mention that? oops
02:17:03 <jle`> ya
02:17:41 <jle`> if it's (Applicative f) =>  ... though then you might have to add a new law
02:17:52 <frerich> srhb: I think it's quite efficient at that though since it ties the knot, i.e. I think that 'digits n = fix (n:)' is more efficient than 'digits = n : digits n' because it reuses the 'n:' thunk
02:17:53 <quchen2> tejing: That example is an issue with laziness though, because the tuple has to be forced in order to check whether its (only) constructor matches. If you make your pattern lazy you're fine.
02:18:02 <quchen2> > fix (\ ~(a,b)->(1,2))
02:18:10 <lambdabot>  (1,2)
02:18:30 <srhb> frerich: Right, nothing wrong with that, but I'd use an explicit let and give my brain a rest.
02:18:40 <srhb> (ie. just expanding the fix...)
02:18:56 <tejing> quchen2: I know... I brought it up because it's a situation where a dumb enough evaluator will run forever, but to a human looking at it, the proof that the work is unnecessary is obvious
02:19:09 <jle`> is there a roadmap for a ghc 8.0
02:20:03 <phaazon> fix is fun to understand
02:20:04 <srhb> jle`: Not that I know of, but as people have stated earlier major revisions have historically occurred mostly from essential rewrites of GHC, not changes in Haskell.
02:20:07 <phaazon> mfix is less
02:20:10 <phaazon> loop is horrible.
02:20:31 <tejing> srhb: it's also easier to read if you do fix $ \this-> ... or some similarly descriptive variable name
02:20:40 <srhb> tejing: That part bothers me less.
02:20:56 <jle`> srhb: yeah, which makes sense; i guess i was asking about when the next significant rewrite of ghc warranting a major version bump is coming along
02:21:42 <voidzero> ghc version 8?
02:21:43 <srhb> jle`: I don't think one is on the drawing board. I suppose a kind-type unification might warrant that?
02:21:43 <phaazon> is there a proposal to get module morphisms?
02:21:56 * srhb shrugs
02:22:00 <srhb> Version numbers matter little.
02:22:05 <voidzero> indeed
02:22:18 <voidzero> for T-shirts they might :)
02:23:30 <ReinH> phaazon: module morphisms?
02:24:06 <phaazon> ReinH: a module being parameterized by another one
02:24:49 <ReinH> we'd probably need real modules first
02:25:05 <phaazon> what do you mean?
02:25:17 <phaazon> our modules are not good to you?
02:25:32 <ReinH> Haskell's modules are just namespaces
02:25:50 <ReinH> leaky namespaces
02:26:00 <hmsster> and "real" modules are??
02:26:37 <tdammers_> hmsster: look at Python, for example... they fake it too, but in a different way, giving you first-class modules
02:26:42 <phaazon> ReinH: yeah I¬†don't get it
02:26:45 <phaazon> a module is a namespace
02:27:05 <ReinH> Something like SML's
02:27:19 <phaazon> a module is like a bag in which you can put whatever you want, and refer to them as opening the bag
02:27:25 <tdammers_> haskell's modules are a bit underpowered compared to the rest of the language
02:27:27 <phaazon> ReinH: hm, don't know them
02:27:35 * phaazon googles SML's modules
02:28:20 <jle`> phaazon: in that sense haskell modules aren't really meaningful bags
02:28:24 <ReinH> tdammers_: "a bit"
02:28:33 <jle`> they're just...namespaces
02:28:45 <jle`> they aren't bags you can manipulate in a meaningful way
02:28:45 <srhb> phaazon: SML's module system is incredibly clever.
02:28:52 <jle`> basically fancy #include's
02:29:09 <tdammers_> yeah, and they're good at being namespaces... it's just that it would be tremendously useful to have something slightly more powerful
02:29:17 <ReinH> Ron Harper has a nice rant on them https://existentialtype.wordpress.com/2011/04/16/modules-matter-most/
02:29:18 <phaazon> like what?
02:29:35 <tdammers_> some way of making them first-class
02:29:39 <phaazon> yeah
02:29:44 <phaazon> that's what I said earlier
02:29:51 <phaazon> having module morphisms
02:29:58 <ReinH> modules without functors are boring...
02:30:05 <tdammers_> there are a few other shortcomings that first-class modules would solve
02:30:17 <tdammers_> such as how you can't re-export with qualifiers
02:30:17 <phaazon> even though I¬†don't really get the use of such a feature
02:30:50 <phaazon> the interesting thing is that we say that our modules system sucks, but what's about C, C++, and all those languages which don't even have a module system?¬†:)
02:30:56 <srhb> ReinH: The bit about type classes is a bit of a lie though.
02:31:01 <tdammers_> I would really really appreciate being able to import MyProject.Common, and it would pull all sorts of qualified modules into the current namespace
02:31:09 <srhb> (But it would be nice to parameterize them in a more clever way)
02:31:23 <jle`> i'd like to be able to call
02:31:37 <ReinH> Ron's rants abour Haskell should be taken with a large grain of salt, but he isn't entirely wrong
02:31:40 <jle`>  >> import $ fix (Control.Monad.)
02:31:52 <jle`> then i'll be happy
02:32:38 <phaazon> jle`: what :D
02:32:41 <tdammers_> if I could just have a module that automatically hides selected Prelude functions, pulls in Data.Text qualified and Data.Text.Text unqualified and a Control.Applicative and Data.Monoid and a few others I use all the time...
02:33:02 <tdammers_> as it stands, I have to duplicate that import code in all my modules, and that's kind of silly
02:33:30 <srhb> Type level type class functors could be fun, too.
02:33:33 <jle`> yeah i just use CPP for that
02:33:43 <tdammers_> I can write all sorts of crazy high-level abstractions in my code, but I can't make even the simplest abstractions when it comes to modules
02:34:23 <tdammers_> and none of the current options feels nice... CPP? Cabal? Code generators? Ugh. They're all obscure, and I'd rather have code duplication than magic.
02:34:29 <zipper> Isn't Word32 just an Int? How can I represent an IP address as a Word32?
02:34:31 <jle`> #include "myimports.hs"
02:34:50 <phaazon> zipper: nope
02:34:57 <phaazon> Int allows for negative values
02:34:59 <tdammers_> jle`: yeah, but that's obscure
02:35:00 <phaazon> a Word32 doesn't
02:35:02 <zipper> phaazon: No to what?
02:35:06 <benma> jle`: i also used that, feels dirty. an extension should be created to solve that problem
02:35:08 <jle`> i'm just kidding i hope nobody does that
02:35:10 <phaazon> zipper: 
02:35:12 <zipper> phaazon: What is it?
02:35:16 <jle`> shame on you for entertaining the idea
02:35:17 <phaazon> > (-1 :: Word32)
02:35:19 <jle`> you've been pranked
02:35:21 <lambdabot>  4294967295
02:35:22 <jle`> suckas
02:35:26 <jle`> i should probably sleep now
02:35:34 <benma> jle`: also i think it messed with my emacs haskell mode, but i can't quite remember
02:35:37 <phaazon> > (-1 :: Word32) == maxBound
02:35:42 <zipper> phaazon: What is a Word32?
02:35:43 <lambdabot>  True
02:35:56 <phaazon> zipper: a bitfield on 32 bits :)
02:35:57 <srhb> zipper: I also don't think Int is guaranteed to be 32 bits
02:36:05 <srhb> It's system specific
02:36:07 <phaazon> yeah
02:36:09 <phaazon> use Int32 for that
02:36:15 <ReinH> Int is a machine int, so its size can change
02:36:23 <srhb> A fixed-precision integer type with at least the range [-2^29 .. 2^29-1]. The exact range for a given implementation can be determined by using minBound and maxBound from the Bounded class.
02:36:27 <srhb> According to docs.
02:36:30 <ReinH>  (2^29-1, maxBound :: Int)
02:36:37 <ReinH> > (2^29-1, maxBound :: Int)
02:36:41 <lambdabot>  (536870911,9223372036854775807)
02:36:49 <zipper> Okay uh if I want to represent 127.0.0.1 or "localhost" as Word32 how can I do that?
02:36:50 <jle`> zipper: an IP address is a 32 bit 'number', so you could fit one into a Word32
02:36:59 <srhb> > maxBound :: Word64
02:37:02 <lambdabot>  18446744073709551615
02:37:05 <zipper> jle`: Makes sense
02:37:08 <srhb> Oh right, that wont work. needs division :P
02:37:13 <phaazon> > maxBound :: Word128
02:37:16 <phaazon> :)
02:37:16 <lambdabot>      Not in scope: type constructor or class ‚ÄòWord128‚Äô
02:37:16 <lambdabot>      Perhaps you meant one of these:
02:37:16 <lambdabot>        ‚ÄòWord8‚Äô (imported from Data.Word),
02:37:17 <jle`> zipper: i would use hex literals
02:37:36 <kadoban> Another complication is that an IP address isn't a 32 bit number. IPv4 addresses are, but ‚Ä¶ that's /already/ out of date. If you're writing new code, do you already want to be obsolete?
02:37:37 <phaazon> zipper: I would use a data for that
02:37:44 <jle`> each decimal spot is 8 bits
02:37:52 <phaazon> data IPAddr = IP Word32 | Host String
02:37:58 <phaazon> something like that
02:38:18 <zipper> This is what I'm trying to work with https://hackage.haskell.org/package/network-2.6.2.0/docs/Network-Socket.html#t:HostAddress
02:38:23 <jle`> my hex is a bit rusty
02:39:30 <jle`> zipper: 127 = 0x7f, 0 = 0x00, 1 = 0x01
02:39:40 <jle`> zipper: so 127.0.0.1 is 0x7f000001
02:39:50 <jle`> > 0x7f000001 :: Word32
02:39:54 <lambdabot>  2130706433
02:40:00 <phaazon> kadoban: then...
02:40:02 <ReinH> fromOctets a b c d 07= fromIntegral a 07`shiftL` 0424 07.|. fromIntegral b 07`shiftL` 0416 07.|. 07..
02:40:14 <zipper> jle`: WOW
02:40:17 <phaazon> data IPAddr = IP4 Word32 | IP6 Whatever | Host String
02:40:38 <kadoban> phaazon: Sounds better
02:40:42 <ReinH> is how you would convert to Word32
02:40:55 <jle`> if it's something you hard-code then you can just use a hex literal.  ReinH's method would be handy for having haskell do it
02:40:57 <liste> ReinH how'd you make those pretty colors
02:41:09 <phaazon> liste: with C escape keys
02:41:16 <ReinH> I'm using glguy's irc-core client
02:41:22 <phaazon> or with a tool, like toilet
02:41:27 <jle`> maybe a hex literal isn't a good idea
02:41:28 <phaazon>  /exec -o toilet ...
02:46:58 <tempname11_> Can GHC provide file/line information for a function call? I'm trying to get rid of my CPP macro-wrappers which use __FILE__ and __LINE__
02:47:14 <tempname11_> I could use TH, but maybe there's a better way
02:48:28 <ReinH> for a completely ridiculous way to do it,
02:49:08 <ReinH> fromOctets a b c d 07= foldl' (07.|.) 040 07$ zipWith (07\x b 07-> fromIntegral x 07`shiftL` b) [a,b,c,d] (iterate (subtract 048) 0424)
02:49:45 <ReinH> now pointfree that, I date someone
02:49:50 <ReinH> dare*
02:52:10 <liste> @pl fromOctets a b c d = foldl' (.|.) 0 $ zipWith (\x b -> fromIntegral x `shiftL` b) [a,b,c,d] (iterate  (subtract 8) 24)
02:52:10 <lambdabot> fromOctets = (((foldl' (.|.) 0 .) .) .) . flip flip (iterate (subtract 8) 24) . ((flip . ((flip . (zipWith (shiftL . fromIntegral) .)) .)) .) . (. ((. ((. return) . (:))) . (.) . (:))) . (.) . (.) . (:)
02:52:42 <ReinH> welp
02:53:03 <joncol> Is there an idiomatic way of getting only the last result of a sequence of monadic operations, i.e. f :: X -> Maybe X;  f x = g 0 x >>= g 1 >>= g 2 >>= g3  (where g :: Int -> X -> Maybe X).  mapM will of course produce a list of intermediate results, but in this case I'm only interested in the final result...
02:53:44 <ReinH> joncol: >>= will short-circuit on the first Nothing
02:54:27 <ReinH> it can't do anything else
02:55:34 <ahihi> @pl fromOctets a b c d = foldl' (\x y -> (fromIntegral x `shiftL` 8) .|. y) 0 [a,b,c,d]
02:55:34 <lambdabot> fromOctets = (((foldl' ((.|.) . (`shiftL` 8) . fromIntegral) 0 .) .) .) . (. ((. ((. return) . (:))) . (.) . (:))) . (.) . (.) . (:)
02:55:36 <joncol> ReinH> Yes, but is there a way of writing a "short-circuiting" variant of this without having to write out all the cases? Say I wanted to do 1000 operations...
02:58:15 <ReinH> :t \g -> foldr (>=>) return . map g $ ([1..100] :: [Int])
02:58:17 <lambdabot> Monad m => (Int -> c -> m c) -> c -> m c
02:58:20 <tejing> joncol: I'm not 100% sure I get what you want, but I think foldl (>=>) should do it
02:58:37 <tejing> er, foldr*
02:59:00 * hackagebot dsh-sql 0.2.0.2 - SQL backend for Database Supported Haskell (DSH)  http://hackage.haskell.org/package/dsh-sql-0.2.0.2 (AlexUlrich2)
02:59:18 <ReinH> Kleisli monoid ftw
02:59:33 <joncol> tejing, ReinH> Thanks
03:02:18 <jle`> :t ala Endo foldMap . map (=<<)
03:02:20 <lambdabot> Monad m => [a -> m a] -> m a -> m a
03:03:14 <ReinH> :t alaf Kleisli foldMap
03:03:17 <lambdabot> (Foldable t, Monoid (Kleisli m' a' b')) => (a -> Unwrapped (Kleisli m' a' b')) -> t a -> Unwrapped (Kleisli m' a' b')
03:03:28 <ReinH> woo
03:03:33 <ReinH> types are hard to read though
03:03:33 <jle`> :t ala Endo foldMap . map (g >>=) $ ([1..100] :: [Int])
03:03:35 <lambdabot>     Couldn't match type ‚ÄòInt‚Äô with ‚Äòa0 -> a -> a‚Äô
03:03:36 <lambdabot>     Expected type: [a0 -> a -> a]
03:03:36 <lambdabot>       Actual type: [Int]
03:03:36 <jle`> er
03:03:40 <jle`> :t \g -> ala Endo foldMap . map (g >>=) $ ([1..100] :: [Int])
03:03:43 <lambdabot>     Couldn't match type ‚ÄòInt‚Äô with ‚Äòa1 -> a -> a‚Äô
03:03:43 <lambdabot>     Expected type: [a1 -> a -> a]
03:03:43 <lambdabot>       Actual type: [Int]
03:03:45 <jle`> ReinH: Kleisli ain't Monoid
03:03:52 <jle`> so no foldMap :|
03:04:29 <ReinH> oh, needs EndoKleisli to exist :(
03:04:51 <jle`> EndoKleisli would be nice
03:05:14 <ReinH> 03instance Monad m 07=> Monoid (a 07-> m a)
03:05:26 <jle`> lol
03:05:38 <jle`> instance Monad m => Monoid (Kleisli m a a)
03:05:46 <jle`> might be a bit more ghc-friendly
03:05:47 <ReinH> it's legal with FlexibleInstances and OverlappingInstances
03:06:27 <nshepperd> instance Arrow a => Monoid (EndoArrow a b)
03:06:41 <nshepperd> or even 'Category a'
03:06:43 <nshepperd> i guess
03:06:44 <jle`> is EndoArrow a thing
03:06:54 <jle`> :o
03:07:19 <nshepperd> (>>>) is supposed to be associative, isn't it?
03:07:25 <tejing> why is there a Monoid instance for Monoid m => (e -> m) anyway?
03:07:38 <srhb> tejing: Why not?
03:07:41 <ReinH> tejing: because you can fmap
03:07:50 <jle`> tejing: it is pretty useful actually
03:07:52 <jle`> in day to day
03:08:05 <ReinH> it's a cps-d monoid
03:08:05 <jle`> > (reverse <> take 3) "hello world"
03:08:09 <lambdabot>  "dlrow ollehhel"
03:08:25 <tejing> jle`: oh, I see. handy
03:08:26 <nshepperd> then you get Endo = EndoArrow (->)
03:08:27 <jle`> > ((*2) <> (+3)) (Sum 5)
03:08:32 <lambdabot>  Sum {getSum = 18}
03:08:34 <nshepperd> it all makes sense
03:08:40 <ReinH> nshepperd: it does
03:08:56 <jle`> i am all for
03:09:06 <jle`> is bayhac this weekend
03:09:33 <nshepperd> i suppose you could call it EndoCat or something since it's not just arrows
03:09:37 <ReinH> Oh, shame, I won't be going :(
03:10:01 <tdammers_> jle`: that is incredibly useful
03:10:10 <ReinH> nshepperd: EndoCat is just a monoid.
03:10:12 <jle`> how about we just call it Endo, and then make the normal endo be EndoFunction
03:10:24 <nshepperd> jle`: yes1
03:10:28 <ReinH> since it's a category with one object
03:10:36 <jle`> burned_bridges++
03:10:54 <tdammers_> > ((show . (*3)) <> (\x -> replicate x 'a')) 5
03:10:59 <lambdabot>  "15aaaaa"
03:11:15 <jle`> tejing: the example people always give is for m ~ Ordering
03:11:17 <nshepperd> and then we'll make it polykinded so we can use it on matrices with type level naturals and everything
03:11:30 <tejing> jle`: yea, I realized that one
03:11:49 <ReinH> instance Monoid (Category a a) is the category theoretic notion of a monoid: a single-object category where the monoid elements are the morphisms and mappend = (.)
03:12:13 <tdammers_> (fst <> const ", " <> snd) ("hello", "world")
03:12:24 <tdammers_> > (fst <> const ", " <> snd) ("hello", "world")
03:12:29 <lambdabot>  "hello, world"
03:12:32 <ReinH> :)
03:12:50 <ReinH> a poor man's string formatter
03:12:53 <tdammers_> probably even more useful with record types or lenses
03:13:15 <jle`> > sortBy (comparing length <> comparing reverse <> comparing id) ["hello","worlds","worl","hello world","string"]
03:13:21 <lambdabot>  ["worl","hello","string","worlds","hello world"]
03:13:54 <ReinH> > "$" <> (show . fst) <> " " <> snd) $ (99, "USD")
03:13:56 <lambdabot>  <hint>:1:34: parse error on input ‚Äò)‚Äô
03:14:05 <ReinH> > "$" <> (show . fst) <> " " <> snd $ (99, "USD")
03:14:07 <lambdabot>      Couldn't match expected type ‚Äò(Integer, [Char]) -> t‚Äô
03:14:07 <lambdabot>                  with actual type ‚Äò[Char]‚Äô
03:14:07 <lambdabot>      The first argument of ($) takes one argument,
03:14:10 <nshepperd> I was very excited when I realised matrices were a category, but of course they are, since they're just morphisms in the category of linear transformations (in finite dimensional spaces)
03:14:11 <ReinH> ok never mind
03:14:26 <ReinH> nshepperd: the category is a PROP
03:14:52 <ReinH> and their string diagrams are also a PROP
03:14:58 <nshepperd> heh
03:15:07 <ReinH> That wasn't a joke?
03:15:35 <nshepperd> I don't know what you mean by prop
03:15:37 <jle`> yea, the category with natural numbers as objects and matrices as morphisms is neat
03:15:42 <ReinH> both are symmetric monoidal categories generated by a single object
03:15:51 <ReinH> nshepperd: see graphicallinearalgebra.net
03:15:54 <jle`> had fun thinking about the products and sums there
03:17:24 <ReinH> nshepperd: this one is nice http://graphicallinearalgebra.net/2015/05/23/from-diagrams-to-matrices/
03:17:29 <tempname11_> ReinH: interesting site :)
03:17:44 <ReinH> tempname11_: it's pretty awesome
03:19:29 <ReinH> nshepperd: and once you know what is similar about Mat and the string diagrams, you will have a good intuition for what a PROP is :)
03:20:48 <krgn> is anybody using stack here yet?
03:21:04 <nshepperd> whew, this looks like a lot of stuff to learn :)
03:21:34 <ReinH> nshepperd: that site is extremely approachable though :)
03:21:50 <krgn> I'm a bit confused how to use it (on win32 here). basically I build a project with `stack build` and when I change code I rebuild using the same command, yet my changes are not in new build output
03:24:31 <AshyIsMe> haha wow, going back to python is a bit of a shock
03:24:42 <AshyIsMe> run a long running process and then "oops syntax error"
03:26:38 <tdammers_> oops, "codec ASCII cannot encode character ..."
03:27:49 <hmsster> false equivalence
03:30:52 <joncol> I need a monad for that is almost like the Maybe monad, but (>>=) should "fail" (return Nothing) only when ALL the bound operations fail... Where should I look?
03:31:18 <ReinH> EitherR
03:31:25 <joncol> Cool, thanks!
03:31:48 <dramforever> joncol: what should it return if one fails but the other successes?
03:32:53 <joncol> dramforever> It should then return the result of the last succcessful operation
03:33:13 <dramforever> joncol: but there isn't a result from a
03:33:15 <joncol> ReinH> What's EitherR? I'd heard of Either but never EitherR.
03:33:33 <dramforever> joncol: from the first operand of (>>=)
03:34:30 <dramforever> what should the result of fail "error!" >>= (\x -> return x + 1) be?
03:34:41 <joncol> dramforever> If the first (>>=) results in failure, the "in-parameter" should pass through to the next (>>=)
03:34:44 <ReinH> @hackage errors -- from here
03:34:44 <lambdabot> http://hackage.haskell.org/package/errors -- from here
03:35:01 <ReinH> basically, treat Left as success and Right as failure
03:35:08 <dramforever> joncol: didn't get it, what's a "in-parameter"?
03:35:43 <f-a> I need to include some files in my cabal package for testing purposes (i.e. they are there for the benefit of the test suite). What should I use? extra-source-files doesn't seem to work in the ``test-suite`` section
03:35:45 <merijn> Sounds like he wants to feed the same input toa bunch of functions and then mplus them together?
03:36:05 <joncol> I have a function that takes a board (trying to make a 2048 game). It should then try to move each row left. If no rows can be moved left, the result should be failure.
03:37:03 <tempname11_> joncol: why on earth use a monad for this?
03:37:04 <ReinH> > do Right "fail"; Left "succeed"; Right "fail"
03:37:10 <lambdabot>  Left "succeed"
03:38:21 <dramforever> joncol: how about returning a Bool to indicate if moved (dunno if Bool is idiomatic)?
03:38:26 <dramforever> and use:
03:38:27 <dramforever> :t or
03:38:29 <lambdabot> Foldable t => t Bool -> Bool
03:38:40 <dramforever> or [True, False, False, False]
03:38:51 <dramforever> @src or
03:38:51 <lambdabot> or = foldr (||) False
03:39:09 <funfunctor> Hi, is there a backlog to this channel, I think my answer got cutoff when I did a few hours ago
03:39:22 <dramforever> funfunctor: check topic
03:39:31 <funfunctor> ah oh, didn't see that
03:39:42 <ReinH> Writer Any Board
03:39:43 <joncol> tempname11_> To learn about monads?
03:39:59 <dramforever> joncol: how about my "or-solution"?
03:40:10 <joncol> dramforever> Sounds good
03:40:29 <dramforever> joncol: the thing you want doesn't look like a monad at all
03:41:47 <ReinH> if you want both the new board position and whether there were any changes, you can use Writer Any Board
03:42:08 <joncol> ReinH> Cool. I'll explore that a bit.
03:42:13 <ReinH> otherwise, I think it's correct to just compare boards before and after moving
03:42:57 <joncol> So ReinH, you think it's not totally weird to use a monad here?
03:43:05 <funfunctor> what would be the way to do udelay() in Haskell?
03:43:22 <dramforever> funfunctor: threadDelay won't do?
03:43:30 <funfunctor> Some parts of my program are time sensitive because I am using the SPI bus..
03:43:41 <funfunctor> dramforever: well I am not using threads
03:43:47 <dramforever> don't worry
03:43:52 <dramforever> it will still work
03:43:57 <funfunctor> oh ok
03:43:58 <ReinH> you are using at leaset 1 thread
03:44:05 <dramforever> yep
03:44:25 <dramforever> and maybe more, if ghc makes worker threads
03:44:43 <ReinH> there's a GC thread as well, but that's not relevant
03:50:17 <merijn> ReinH: GC thread? huh?
03:52:48 <ReinH> merijn: GHC doesn't use GC threads per http://community.haskell.org/~simonmar/papers/parallel-gc.pdf ?
03:53:11 <merijn> ReinH: AFAIK the threads doing GC are the normal running threads
03:53:25 <ReinH> well, they are threads
03:53:31 <merijn> Any other approach doesn't really make sense anyway, since the threads can't continue computing while GC runs
03:54:04 <merijn> Minor GC are performed by each thread as needed and major GC pauses processing on all threads and has them all GC in parallel
03:54:17 <merijn> So you don't really need additional GC threads
03:54:48 <ReinH> merijn: eh? afaik, the GC threads just scavenge objects from the pending set, which can be done in parallel
03:55:23 <ReinH> at least, that's what the paper seems to be talking about the 34 times it mentions the phrase "gc thread"
03:55:42 <ReinH> so that's why I thought there were gc threads...
03:56:40 <ReinH> So maybe GHC doesn't have GC threads, but the paper its GC is based on does, so
03:56:43 * ReinH shrugs
03:56:51 <merijn> ReinH: Right, it's done in parallel, but not at while processing happens, which is why GC pauses are such an issue
03:57:06 <ReinH> meretrix: I thought evacuation was what the world was stopped for
03:57:09 <ReinH> not scavenging
03:57:30 <merijn> hmmm, I'd need to read up on the details to be sure
03:57:33 <ReinH> from the paper, the scavenging happens in parallel
03:57:54 <ReinH> "Each GC thread performs the following loop" { scavenging loop code }
03:59:30 <ReinH> I could easily be wrong, I'm just going off what I read
03:59:38 <ReinH> I don't know much about the actual GC internals in modern GHC
04:10:49 <hmsster> what is the name of that crazy package that depends on entire hackage
04:11:06 <jle`> @hackage acme-everything
04:11:06 <lambdabot> http://hackage.haskell.org/package/acme-everything
04:11:08 <zhiayang> all?
04:11:09 <zhiayang> oh
04:11:40 <hmsster> someone mentioned it yesterday.. yes that is it
04:18:25 <froztbyte> lambdabot: faq
04:18:40 <froztbyte> idnar misled me! 
04:19:23 <lpaste> jstolarek pasted ‚ÄúNo title‚Äù at http://lpaste.net/134254
04:19:24 <idnar> @faq 
04:19:24 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
04:19:39 <jstolarek> what is wrong with taht declaration?
04:20:48 <jstolarek> I mean that: http://lpaste.net/134254
04:28:00 <srhb> jstolarek: Well, it's a type, not a type variable?
04:31:04 <jstolarek> is that forbidden?
04:31:41 <hexagoxel_> f-a: extra-source-files is a package-level field
04:32:05 <f-a> thanks hexagoxel_ , indeed it is. It feels weird putting test files here
04:32:58 <jstolarek> srhb: ^^^
04:33:12 <hexagoxel_> f-a: Cabal does that too, so i doubt there is a better way :)
04:33:17 <jstolarek> or, to put it differently: comment in the GHC source code says this should be possible
04:33:30 <f-a> xD well that settles it. Thanks again hexagoxel_ 
04:34:18 <srhb> jstolarek: Huh, okay. I don't know then. Without an extension? What comment is that?
04:37:22 <jstolarek> srhb: Note [Associated type defaults] in compiler/typecheck/TcTyClsDecls.hs
04:38:11 <jstolarek> srhb: http://lpaste.net/134255
04:42:45 <srhb> jstolarek: Sorry, I don't know. Perhaps someone more experienced with TypeFamilies can help you.
04:44:55 <merijn> jstolarek: You have a syntax error :P
04:45:19 <merijn> jstolarek: You need "type family F a b :: *" and "type instance F a Z = [a]" I think
04:45:33 <merijn> jstolarek: It's trying to parse them as type aliases now
04:46:10 <merijn> Oh, I guess it's the note that has the syntax error, in any case
04:46:16 <srhb> Oh derp. I completely missed that.
04:47:11 <jstolarek> merijn: I'm not so sure about that
04:47:26 <lpaste> jstolarek annotated ‚ÄúNo title‚Äù with ‚ÄúNo title (annotation)‚Äù at http://lpaste.net/134254#a134256
04:47:36 <jstolarek> this is perfectly valid
04:48:11 <merijn> jstolarek: Even without KindSignatures?
04:48:31 <merijn> jstolarek: AFAICT, that's getting parsed as an explicit kind signature for a type alias, followed by the definition of the type alias
04:48:44 <merijn> And I would consider it a bug in GHC that it accepts that
04:49:05 * hackagebot structural-induction 0.2.0.1 - Instantiate structural induction schemas for algebraic data types  http://hackage.haskell.org/package/structural-induction-0.2.0.1 (DanRosen)
04:49:12 <jstolarek> it is accepted both with and without KindSignatures
04:49:12 <merijn> The GHC manual has the correct syntax for type families (as that's what i've been using for over a year now) https://downloads.haskell.org/~ghc/7.8.2/docs/html/users_guide/type-families.html
04:49:34 <merijn> jstolarek: ok, I would argue that's a bug
04:50:03 <merijn> It's certainly not correct syntax for type families
04:50:12 <jstolarek> merijn: but these are associated types
04:50:22 <jstolarek> look at section 7.7.3 from your link
04:50:32 <merijn> oh, hmmm
04:50:36 <merijn> I read over that...
04:50:47 <jstolarek> 7.7.3.2 to be precise
04:51:06 <merijn> ok, I think you're right
04:51:41 <jstolarek> ha!
04:51:58 <jstolarek> the code from the user's guide works with 7.8 but not in 7.10
04:52:16 <jstolarek> so either semantics have been changed or there is a regression
04:53:09 <jstolarek> bingo
04:53:28 <jstolarek> "There can be at most one default declaration for an associated type synonym"
04:53:38 <jstolarek> "The default declaration must mention only type variables on the left hand side"
04:54:06 * hackagebot inline-c-win32 0.1 - Win32 API Context for the inline-c library  http://hackage.haskell.org/package/inline-c-win32-0.1 (anton_dessiatov)
04:57:05 <merijn> hmm
04:57:15 <merijn> Is there a non STM semaphore anywhere?
04:58:32 <jstolarek> merijn, srhb: see #9063 and also #9263, #9264
04:58:58 <merijn> ah, QSem
04:59:55 <agocorona> merijn: an IORef can work as a semaphore
05:00:10 <merijn> agocorona: Yeah, but that means hassling with atomicModify and getting that right
05:00:12 <agocorona> with atomicmodifyIORed
05:00:20 <merijn> agocorona: QSem already has that and proper sleeping
05:00:24 <merijn> And it's in base
05:00:42 <agocorona> the problem is that QSem is blocking
05:01:05 <agocorona> i that is what you need, fine
05:01:45 <srhb> jstolarek: Thanks :)
05:01:58 <merijn> agocorona: Blocking is the entire goal of a semaphore :)
05:04:05 <agocorona> merijn: true. I forget that the case in which i use a counter is not the common one
05:15:56 <Vektorweg1> in some trivial cases, -Wall is annoying. no, i'm not going to tell that in 2^15 the 15 is a type i care about. muh ghc. 
05:17:21 <liste> well, theres {-# OPTIONS_GHC -fno-whatever #-}
05:19:07 * hackagebot bindings-potrace 0.1 - Low-level bindings to the potrace bitmap tracing library  http://hackage.haskell.org/package/bindings-potrace-0.1 (cchalmers)
05:20:35 <Vektorweg1> liste: i guess i can't specify it that exactly. defaulting warnings are okay anywhere else. 
05:20:50 <merijn> hmmm, is there a convenient wrapper for async's mapConcurrently when working with transformer stacks?
05:22:23 <merijn> Oh! Maybe I can just use Concurrently at the bottom of my stack instead!
05:22:52 <benzrf> merijn: Concurrently, you can just use Maybe at the bottom of your stack instead
05:22:55 <benzrf> :^D
05:27:26 <merijn> Ah, shit, no...
05:27:42 <merijn> Using Concurrently at the bottom of my stack would require ApplicativeDo to make sense :\
05:29:07 * hackagebot potrace 0.1.0.0 - Trace bitmap images to paths using potrace  http://hackage.haskell.org/package/potrace-0.1.0.0 (cchalmers)
05:30:18 <eds> I am getting the following error:
05:30:24 <eds> [*** Exception: gentestv2.hs:(51,1)-(59,42): Non-exhaustive patterns in function  eval
05:30:41 <eds> my code is : http://lpaste.net/134257
05:31:58 <osa1> eds: eval function is missing `eval (Const i) = ...` case
05:32:24 <pacak> eds: Add {-# OPTIONS -Wall  #-} to the top of the file
05:32:25 <osa1> eds: use -Wall, it tells you non-exhaustive patterns and gives you an example of missing pattern
05:32:43 <pacak> And fix everything.
05:34:09 <eds> I do have the const case as eval (const c) = Just c
05:34:14 <pacak> (also it looks like E can be easily replaced with a Functor: EF a = Base Int | Plus a a | Minus a a, etc and then evaluation can be done as a trivial catamorphism)
05:34:26 <eds> Added the Wall let me run it.
05:34:27 <pacak> eds: You have evalc
05:34:33 <pacak> not eval
05:35:59 <eds> oh sorry about that. I pasted the wrong code. http://lpaste.net/134257
05:36:05 <eds> updated it.
05:37:50 <pacak> eds: GADTs?
05:39:07 <eds> sorry but I do not understand what GADTs means
05:39:34 <pacak> eds: http://en.wikibooks.org/wiki/Haskell/GADT
05:40:11 <pacak> eds: https://www.fpcomplete.com/user/bartosz/understanding-algebras - this approach is also nice
05:41:03 <eds> Ahh so I could make my eval return either int or bool
05:41:26 <pacak> eds: Right. Or a list of stuff.
05:41:46 <pacak> And ghc will stop you from doing things like multiplying list by a bool.
05:41:48 <eds> But the problem is with my fitness function. It does not accept Bool values. How can I handle that?
05:42:05 <eds> yea a list too!
05:42:13 <merijn> Concurrently needs a MonadIO instance....
05:42:35 <pacak> eds: What exactly is it supposed to do?
05:43:01 <pacak> eds: I assume it can have type :: [Int] -> E Int -> Double
05:43:58 <merijn> @(&(@&$ >.<
05:43:58 <lambdabot> Unknown command, try @list
05:44:10 <merijn> Dammit, this is screwing up my entire beautiful design...
05:44:18 <merijn> Time to orphan this thing
05:44:22 <eds> It is genetic programming. When I create an instance of genprog, I randomly choose which arithmetic/comparable operator I can use to build my tree.
05:44:33 <pacak> merijn: #Perl  channel is that way --->>>>, #haskell-lens - that way <<<----
05:45:00 <eds> Fitness function calculates a certain 'fixed' constant number that would give me an optimum solution.
05:45:13 <pacak> eds: Magic. As I said :: [Int] -> E Int -> Double
05:45:34 <eds> myFitness function here will only work for arithmetic operators and not comparable operators since they return bool.
05:45:45 <merijn> Any conduit users? I'm trying to use http-conduit the "proper" way, so not using simpleHttp, but using http or httpLbs just fucks up everything >.<
05:45:46 <eds> ohh ok. Let me try that.
05:46:19 <merijn> Because then I need a manager and withManager for some reason demands that I give it a function returning a ResourceT...
05:47:01 <eds> modules loaded none. E is applied to too many arguments
05:48:32 <Darwin226> Hey guys, can someone tell me why people generally don't like TH?
05:49:03 <merijn> Darwin226: Not very portable and issues with cross compilation
05:49:08 * hackagebot potrace-diagrams 0.1.0.0 - Potrace bindings for the diagrams library  http://hackage.haskell.org/package/potrace-diagrams-0.1.0.0 (cchalmers)
05:49:10 * hackagebot edenskel 2.1.0.0 - Semi-explicit parallel programming skeleton library  http://hackage.haskell.org/package/edenskel-2.1.0.0 (MischaDieterle)
05:49:13 <merijn> Darwin226: Also, before we had typed TH it wasn't type safe
05:49:15 <Darwin226> merijn: What exactly does that mean?
05:49:36 <merijn> Darwin226: You could splice an "Int" expression in a location expecting a Char
05:49:55 <Darwin226> merijn: How would that get past the next compiler pass?
05:50:05 <eds> Is it ok to make a global variable r there of type int?
05:50:08 <merijn> It wouldn't, but it's ugly that it can fail
05:51:03 <Darwin226> merijn: I mean, I do get that it's not possible to determine if a code generating function produces type correct code. But I've always thought Haskell programmers had a high regard for Lisps, and those are all about macros. What are the differences?
05:51:18 <eds> r is used late in the instance and given a random number. I check in my fitness function if the random number is less than 4 then enter the fitness function and carry out the process. If not then nothing. Would that work?
05:52:21 <eds> since first five operations in the instance are arithmetic operators and those are the ones I would need.
05:52:24 <pacak> eds: Play around with GADTs first a bit.
05:52:35 <pacak> You will need to change E
05:53:06 <eds> ohh ok. I will read that. Try it and come back here. Thanks.
05:54:25 <pacak> Darwin226: TH can generate whole bunch of code you know nothing about
05:54:45 <pacak> Also recompilation used to be a bit derpy if your TH depends on external data.
05:55:05 <Darwin226> pacak: But that's just macros in general, no?
05:55:36 <pacak> Also compilation with profiling requires some extra tricks.
05:56:20 <pacak> Darwin226: Yes, just macros.
05:57:09 <Darwin226> pacak: So, you'd basically have a hard time convincing a Lisp programmer that TH is bad.
05:57:24 <pacak> We are using some TH to generate lots of boring stuff, but trying to keep it contained  in a limited set of files.
05:57:43 <merijn> Darwin226: Well, compile times of TH are also an issue
05:57:56 <pacak> I'm not saying TH is bad. It's just a tool that can do various stuff.
05:58:01 <merijn> Darwin226: I think it's mostly a case of "the people against TH are rather vocal"
05:58:14 <merijn> There's nothing dangerous/bad about it
05:58:23 <merijn> It's just a matter of understanding the costs
05:58:48 <pacak> Also if you use TH ghc gets picky about order you declare stuff in the file.
05:58:52 <magneticDuck1> every day, innocent kittens are killed by compilers evaluating TH
05:59:11 <Darwin226> merijn: Oh. So it's less of a consensus than I previously thought.
06:01:13 <merijn> Darwin226: I'd say there's 50% people objecting on portability/expensive recomputation/religious grounds and 50% happily (but quietly) using it
06:02:28 <tdammers_> indeed... TH isn't evil, but it does obscure things a bit. Sometimes it's worth it, sometimes it's not.
06:02:29 <Darwin226> merijn: Can it be done better? Is it a case of bad, could be better, or bad, but has to be like that?
06:03:43 <f-a> merijn: theoretically could a non ghc compiler implement th? that's my only frear
06:03:49 <betrix>  what is a good reasource for learning use shakespeare templates.
06:03:51 <tdammers_> for me, things like how Yesod uses TH illustrate both the good and the bad parts of TH
06:04:14 <tdammers_> good part is that you can write things in a very concise domain-specific DSL, with very little redundancy
06:04:42 <tdammers_> bad part is that suddenly identifiers and other things come "out of nowhere", invisible to grep, tag files, and a bunch of other tools
06:05:02 <tdammers_> and in order to find out where they come from, you have to learn what the specific TH in that library does
06:05:20 <srhb> betrix: The Yesod book?
06:05:33 <Darwin226> tdammers_: It's kind of a shame that with such a nice and static type system, we still resort to text searching tools
06:05:55 <tdammers_> Darwin226: I think even with a type-aware tool, TH would still kind of break things
06:06:07 <tdammers_> unless that tool would actually reverse-engineer your TH code
06:06:19 <tdammers_> or at least run/expand it
06:08:04 <Darwin226> Well, various languages that compile to JS can generate source maps so that when an error happens, you're not pointed to the compiled JS but your original source
06:08:17 <merijn> f-a: Sure
06:08:20 <merijn> f-a: Why not?
06:08:29 <obb> does anyone of you use atom as editor and what plugins do you recommend?
06:08:35 <Darwin226> I'm not sure if that process can be done automatically for any quasi quoter definition
06:08:43 <tdammers_> Darwin226: yeah, but I don't think TH can currently do that
06:09:05 <Darwin226> tdammers_: I like to think in terms of "could potentially do that" instead of "does that" :D
06:09:13 <merijn> tdammers_: It depends, you can throw good errors in your TH
06:09:28 <tdammers_> merijn: yes, but I'm talking more about the non-error case
06:09:40 <f-a> merijn: well, isn't that tightly integrated on how ghc works?
06:09:45 <tdammers_> merijn: suppose your TH generates a variable; how do my tools know where the variable comes from?
06:09:49 <f-a> it is a genuine question, I don't know
06:09:56 <Darwin226> On a slightly related subject, is there some mechanism avaliable that can catch compile time errors and rewrite them to something more understandable if they relate to my libraries code?
06:10:14 <minozake> I'm using System.Process's runCommand, and when I use it in ghci, `runCommand "echo hi"` will print the result, however if I use `show $ runCommand "echo hi"`, it will not.  How can I use runCommand in my program to get a string of the output?
06:10:19 <tdammers_> I'd want something like Ctrl-] jumping to the TH input that produced the identifier under the cursor
06:10:33 <Darwin226> For example, there's a certain pattern of errors that are reported as missing instances, but that's just a misdireciton because the underlying reason is always the same.
06:10:41 <tdammers_> so the TH code itself would have to somehow annotate its output with a source map
06:34:07 <fizbin> So I have a question about cabal and packages that contain both libraries and executables.
06:35:07 <fizbin> Basically, if I have a library and an executable in the same cabal package that uses that library, why do I need to list dependencies of the library in both the "library" and "executable" sections?
06:35:25 <fizbin> There's a minimized example at https://github.com/fizbin/cabal-demo-backflip
06:36:18 <geekosaur> because cabal's not real smart in that regard?
06:36:30 <pavonia> Do you mean the array dependency?
06:36:48 <f-a> fizbin: I fear it is one of those "it works like that" moments
06:36:53 <fizbin> Yes. Why do I need the "array" dependency as a dependency of the demo executable?
06:37:21 <fizbin> Also, when I add it, why does Backflip.hs get compiled twice?
06:37:30 <geekosaur> (I think this is fallout from executables being a second class citizen, thanks to ghc-pkg not knowing about them and cabal-install relying on ghc-pkg for so much)
06:37:38 <fizbin> Shouldn't it be compiled once and then used twice?
06:37:49 <Guest92448> is there anyone who can help me
06:37:56 <Guest92448> just simple code
06:38:08 <srhb> Guest92448: Depends, pose your question and post any relevant code and errors on lpaste.net
06:38:19 <srhb> We won't know whether we can help before you do that. :)
06:38:24 <geekosaur> (unfortunately I think the alternative is cabal-install has to duplicate ghc-pkg functionality + executable support, and then loses when ghc-=pkg changes)
06:38:47 <Guest92448> @srhb
06:38:47 <lambdabot> src <id>. Display the implementation of a standard function
06:38:57 <Guest92448> do you know minesweeper game?
06:39:05 <f-a> Guest92448: everybody does
06:39:25 <srhb> Guest92448: There's no need to poke me in private. Pose your questions in the channel.
06:39:44 <Guest92448> I am making minesweeper game
06:40:41 <rom1504> http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/Games/
06:41:47 <fizbin> Aha! I think I might have solved my issue. That's... weird.
06:41:53 <pavonia> Guest92448: What do you need help with?
06:42:06 <fizbin> Huh. Going to need to think about how this solution applies in general.
06:42:40 <Guest92448> So i want to solve minesweeper in Haskell
06:42:48 <Guest92448> input will be
06:42:48 <Guest92448> 4 4
06:42:48 <Guest92448> *...
06:42:48 <Guest92448> .*..
06:42:48 <Guest92448> ..*.
06:42:48 <Guest92448> ...*
06:42:56 <Guest92448> output will be
06:43:03 <Guest92448> *210
06:43:04 <Guest92448> 2*21
06:43:04 <Guest92448> 12*2
06:43:04 <Guest92448> 012*
06:43:14 <rom1504> Guest92448: if you don't have any question look at my link up there for a solution
06:43:23 <srhb> Use lpaste.net for multiline stuff :)
06:43:45 <Guest92448> sorrry
06:44:16 <srhb> No worries.
06:44:18 <Guest92448> i did
06:44:29 <Guest92448> I could solve this in C but
06:44:37 <Guest92448> i don't know how to solve in Haskell
06:45:00 <srhb> Guest92448: How far have you come so far?
06:45:29 <srhb> Guest92448: If you have nothing yet, divide the task up into smaller problems, like for instance reading the first line with the dimensions (or whatever they signify)
06:45:30 <Guest92448> almost nothing
06:45:37 <Guest92448> ok
06:45:47 <srhb> Then if you can't figure out how to deal with a specific subproblem, ask. :)
06:45:52 <srhb> Or if you're having trouble dividing the problem.
06:45:55 <Guest92448> thank you
06:45:57 <srhb> But at least that's one idea to start with.
06:48:33 <Guest92448> @srhb hey can you help me another problem?
06:48:34 <lambdabot> Source not found. My mind is going. I can feel it.
06:49:01 <srhb> Guest92448: Same thing applies. When I don't know your problem, I can't tell. Also, engage the entire channel, please.
06:49:21 <Guest92448> I will paste it on ipaste
06:49:28 <srhb> Remember to include the link this time.
06:49:33 <srhb> In the channel, that is.
06:49:49 <Guest92448> http://lpaste.net/134261
06:50:22 <frerich> Guest92448: One approach I particularly like is to do a top-down approach where you start with something like 'solve :: String -> String' and then define 'solve = undefined'. I.e. you only know that your funciton will take some input string and eventually produce some output string.
06:50:43 <Guest92448> thanks
06:51:25 <frerich> Guest92448: Then you drill down and realize that you will need to 1. parse input, 2. actually solve the parsed input and 3. turn the solution into a string again. E.g. you could have 'data Board' and then 'parse :: String -> Board', 'solveBoard :: Board -> Board' and 'render :: Board -> String'. Setting all of them to 'undefined'.
06:51:52 <frerich> Guest92448: You could then actually define your initial 'solve' function to something like 'render . solveBoard . parse'
06:52:11 <kuribas> Guest92448: You could use an array.
06:52:25 <frerich> The nice thing about this is that you can compile your code at any stage and you end up with a lot of hopefully small functions which you can tinker with individually in ghci.
06:52:27 <Guest92448> actually, I experienced Haskell yesterday, so Im not famaliar with this language..
06:52:45 <Guest92448> this is school assignment
06:52:50 <mniip> so you're trying to solve a rather advanced problem in haskell
06:52:55 <mniip> without knowing haskell
06:52:58 <Guest92448> no friends in the class
06:53:01 <Guest92448> so im here to ask
06:53:01 <srhb> Guest92448: Sounds non-trivial to work this in Haskell without doing a real Haskell course first.
06:53:02 <frerich> Guest92448: Oh, sorry. Don't worry, it'll all make sense at some point. Quite an ambitious start though!
06:53:06 <lamefun> Why does Haskell allow making useless types?
06:53:19 <mniip> lamefun, why should it disallow them
06:53:20 <srhb> lamefun: Sometimes useless types are useful!
06:53:28 <tdammers_> lamefun: how would haskell know the difference?
06:53:28 <mniip> also define useless
06:53:29 <srhb> Which is a conundrum, but there you go...
06:53:47 <frerich> srhb: I'm pretty sure he specifically refers to the useless types except the usefully useless ones.
06:53:50 <fizbin> So if anyone's interested, I solved my cabal packaging issue, at least in the toy case I'd made to ask about my cabal packaging issue: https://github.com/fizbin/cabal-demo-backflip
06:53:57 <srhb> frerich: How can you tell!
06:53:59 <srhb> :P
06:54:16 <frerich> I have this useful (useless?) thing called gut feeling. Useful, isn't it?
06:54:16 <tdammers_> in fact, if there were a way to mechanically detect uselessness (or usefulness, as the case may be), "programming" would be a solved problem
06:54:25 <srhb> frerich: Maybe...
06:54:25 <fizbin> I'm still not totally certain how to apply that lesson in general, but the solved example does help explain things a bit.
06:54:29 <Guest92448> is there anyone who can solve this ?? http://lpaste.net/134261
06:54:48 <srhb> Guest92448: Are you forced to do this in Haskell?
06:54:55 <Guest92448> yes i am :(
06:54:57 <mniip> if lamefun is referring to type inhabitance,
06:55:08 <merijn> lamefun: Name one useless type?
06:55:10 <srhb> Because yeah, a lot of us can solve it, but I don't think a lot of us think it's a reasonable task for someone who's only known of Haskell for one day.
06:55:18 <mniip> I'm not sure type inhabitance is determinable in general
06:55:41 <Guest92448> please :( im begging you
06:55:48 <Guest92448> I have exam three days later
06:55:54 <Guest92448> I don't have much time for this
06:56:01 <Guest92448> please help
06:56:13 <frerich> Well, how do I put this...
06:56:15 <srhb> Sorry to hear that, but I don't feel like just supplying a solution.
06:56:34 <Guest92448> I know :(
06:56:37 <tdammers_> Guest92448: when were you given that task?
06:56:43 <Guest92448> last week
06:56:50 <tdammers_> Guest92448: and when were you supposed to have started learning haskell?
06:56:55 <Guest92448> but I got three another assignments last week
06:56:56 <dramforever> that's hardly haskell specific, maybe ask #algorithm
06:56:59 <Guest92448> yesterday
06:57:09 <tdammers_> that's impossible
06:57:23 <dramforever> #algorithms
06:57:26 <kuribas> you can't learn a language in a day...
06:57:27 <merijn> tdammers_: Or a really hardcore school :p
06:57:34 <lamefun> merijn, data NotComparable = A | B ; Set NotComparable -- you can actually make a Set.empty of that, but it's useless because you can't insert anything into the set.
06:57:34 <phadej> mniip: depends on the type system, some are, some aren't.
06:57:35 <Guest92448> it is :(
06:57:39 <frerich> Or maybe it's a trick to detect students who have others do their homework.
06:57:48 <Guest92448> It is not a trick
06:58:01 <Guest92448> anyone who can help me in private god will bless you
06:58:01 <dramforever> Guest92448: and when are you supposed to "hand it in"?
06:58:07 <Guest92448> next wekk
06:58:09 <merijn> lamefun: I don't see the problem?
06:58:11 <Guest92448> 19 Jun
06:58:16 <tdammers_> merijn: no, it's logically impossible. "Solve this problem using Haskell" implies that you need to know or learn Haskell. If the task has been given last week, then the implied "learn Haskell" task is also at least a week old.
06:58:23 <Guest92448> but I have a exam this week
06:58:24 <srhb> That's plenty of time to do a Haskell tutorial first
06:58:28 <Guest92448> I dont have much time
06:58:35 <tdammers_> make time.
06:58:37 <fizbin> Fortunately, the question doesn't say that you need to output the *best* such list.
06:58:38 <srhb> Yeah, okay, that complicates matters. But still, you'll have to juggle.
06:58:39 <tdammers_> priorities.
06:58:52 <tdammers_> a.k.a., welcome to life as an adult.
06:58:55 <kuribas> Guest92448: which languages do you know?
06:58:55 <frerich> "I don't have time" means "It's not important enough."
06:58:55 <merijn> lamefun: Why *wouldn't* you be allowed to do that?
06:59:10 <lamefun> because it's useless?
06:59:13 <Guest92448> C Java
06:59:23 <dramforever> Guest92448: do you know how to do it in C/Java?
06:59:29 <Guest92448> Of course
06:59:38 <Guest92448> I already did
06:59:45 <mniip> lamefun, what's the use of the number 3
06:59:50 <mniip> we could always write 1+2
06:59:52 <mniip> 3 is useless
06:59:58 <lamefun> and because set functions will have to be like insert :: (Ord x) -> x -> Set x -> Set x instead of simply x -> Set x -> Set x
07:00:21 <Guest92448> professor said I can solve this with lists
07:00:25 <Guest92448> but i can't..
07:00:35 <mniip> lamefun, are you speaking about datatype contexts?
07:00:38 <tdammers_> you cannot solve it using *only* lists
07:00:45 <nolraiU> So is it posible to turn off a specific warning for one region of a file?
07:00:48 <mniip> tdammers_, sure you can
07:01:09 <tdammers_> mniip: doubt it
07:01:21 <mniip> lamefun, datatype contexts are a thing, but they are discouraged, because not all functions operating on a Set require the Ord constraint
07:01:22 <fizbin> Guest92448: Since you don't need to solve the problem with the *best* or *shortest* list of flips, it isn't so bad.
07:01:23 <srhb> nolraiU: I don't think there are any region specific commands at all.
07:01:53 <mniip> as such, there are still valid operations on the values of type Set NotComparable
07:01:53 <phadej> mniip: inhabitation of various systems (haskell is about lambda2): https://imgur.com/5TvJDgq
07:01:54 <pavonia> Guest92448: Haskell also has arrays, maybe it's easier for you to solve with a mutable array
07:02:13 <Guest92448> thanks
07:02:19 <mniip> phadej, ?? means open problem?
07:02:44 <merijn> mniip: They're not a thing actually
07:02:55 <merijn> mniip: DatatypeContexts were removed in Haskell2010
07:03:08 <mniip> oh
07:03:08 <merijn> mniip: GHC only keeps the extension for backwards compatibility with haskell98
07:03:08 <nolraiU> Damn it. Just some TH generated code has a "Pattern match(es) are overlapped" warnning, and I hate leaving warnings in my code.
07:03:42 <mniip> merijn, hm, you can use GADT to emulate them
07:03:49 <lamefun> mniip, "because not all functions operating on a Set require the Ord constraint" - doesn't matter, because you can't actually use the set (ie. add elements to it)
07:04:09 <merijn> mniip: No, because GADTs actually do something
07:04:22 <merijn> mniip: Constraints in GADTs are equivalent to Existential Quantification
07:04:29 <mniip> right
07:04:46 <nolraiU> lamefun: but it just ends up clutering the code.
07:05:09 <mniip> lamefun, why make unnecessary exceptions
07:05:32 <mniip> haskell is all about contiguous rules without holes
07:05:50 <mniip> continuous*
07:06:11 <dramforever> lamefun: I think DatatypeContexts are useless
07:06:18 <dramforever> they don't actually do nything
07:06:22 <dramforever> *anything
07:06:39 <lamefun> they don't?
07:07:17 <dramforever> lamefun: pattern matching with a datatype context *requires* the context
07:07:31 <dramforever> while pattern matching on a GADT *gives* the context
07:07:56 <dramforever> is that correct?
07:08:57 <lamefun> ?
07:09:41 <dramforever> "merijn: mniip: No, because GADTs actually do something"
07:10:16 <dramforever> and you said "because not all functions operating on a Set require the Ord constraint", but removing the Ord a doesn't matter
07:10:30 <dramforever> I mean, on the data declaration
07:11:22 <dramforever> forget about it, I gor messed up
07:11:26 <dramforever> *got
07:11:31 <liste> do you really need any other type extensions than GADTs, RankNTypes and TypeFamilies?
07:11:39 <liste> you=anyone
07:12:03 <dramforever> MultiParamTypeclasses (IIRC spelling)
07:12:18 <mniip> dramforever, capital C in Classes
07:12:22 <dramforever> yep
07:12:37 <mniip> liste, FlexibleContexts and other friends at times
07:12:49 <liste> oh, of course (:
07:13:07 <merijn> lamefun: If you use DatatypeContexts you STILL have to put the constraint on all functions too
07:13:08 <mniip> FunctionalDependencies are useful with MPTC
07:13:09 <liste> FlexibleContexts just feels so natural that I forget it sometimes
07:13:17 <mniip> FlexibleInstances too
07:13:27 <merijn> liste: Yes
07:13:48 <merijn> liste: DataKinds, TypeOperators, ConstraintKinds
07:13:51 <dramforever> UndecidableInstances when I play really hard with types
07:13:59 <dramforever> yeah and DataKinds too
07:14:04 <merijn> KindSignatures
07:14:20 <merijn> Oh, and PolyKinds
07:14:46 <merijn> Some examples of -XKitchenSink abuse https://gist.github.com/merijn/6130082 https://gist.github.com/merijn/dc00bc7cebd6df012c5e and https://gist.github.com/merijn/39dc86e345e87276c523
07:15:04 <mniip> ConstraintKinds
07:15:15 <dramforever> already mentioned
07:15:18 <mniip> AllowAmbiguousTypes, UndecidableInstances :P
07:15:33 <dramforever> what about -fdefer-type-errors?
07:15:49 <merijn> dramforever: Not an extension
07:16:04 <merijn> dramforever: Also, why would you want to defer type errors until runtime?
07:16:05 <dramforever> yeah
07:16:13 <mniip> NoImplicitPrelude is also useful at times
07:16:28 <dramforever> merijn: I don't know, I heard people do this when developing
07:16:34 <dramforever> don't know why
07:16:37 <merijn> dramforever: But you can do better now! :D
07:16:44 <mniip> BangPatterns
07:16:45 <mniip> haven't used other extensions much
07:16:49 <dramforever> merijn: holes?
07:17:01 <merijn> dramforever: Well, holes + -fdefer-typed-holes :)
07:17:07 <dramforever> yeah sure
07:17:09 <merijn> That way you can actually run your code with holes
07:17:13 <dramforever> mniip: off topic
07:17:26 <mniip> dramforever, ?
07:17:28 <dramforever> we want "type extensions"
07:17:35 <merijn> mniip: BangPatterns and NoImplicitPrelude aren't type extensions, though
07:17:38 <mniip> oh
07:17:44 <mniip> /type/ extensions
07:17:49 <mniip> apologies
07:17:55 <merijn> If we include other extensions there's also LambdaCase, MultiWayIf, TupleSections
07:18:19 <tdammers_> tuple sections is one of my favs though
07:18:28 <exio4> TupleSections should be def :p 
07:18:30 <merijn> > (,1,,'c',,True,) () (Just 'c') [] Nothing
07:18:34 <lambdabot>  ((),1,Just 'c','c',[],True,Nothing)
07:18:41 <merijn> You'd be amazed how many people don't know TupleSections
07:18:42 <dramforever> LambdaCase is my fav
07:19:05 <dramforever> so fav that I ran into this: https://ghc.haskell.org/trac/ghc/ticket/10498
07:19:06 <tdammers_> tuple sections with applicative style, yay
07:19:18 <dramforever> (it's a feature req)
07:20:57 <ChristianS> hmm, googling for haskell KitchenSink took me there: http://www.haskellinteriors.com/blog/picking-the-right-sink-for-your-kitchen-remodel/ . guess i took that too literally...
07:21:14 <dfeuer> edwardk, since you say "Adding instances shouldn't change generated code," I imagine you're opposed to the proposed `do` magic?
07:21:45 <merijn> ChristianS: https://en.wiktionary.org/wiki/everything_and_the_kitchen_sink
07:22:07 <dfeuer> merijn, were TupleSections left out of Haskell 2010 by mistake?
07:22:15 <merijn> dfeuer: Doubt it
07:22:25 <merijn> Haskell2010 was just really conservative on purpose
07:22:29 <dfeuer> Hmm.
07:22:33 <dfeuer> Well, Haskell 98 then :P
07:22:42 <exio4> which do magic? 
07:24:18 <dramforever> I guess it's about MonadFail?
07:26:49 <absence> is there a "(,) a" monad? i guess a would have to be monoid or something
07:27:00 <dramforever> absence: yes!
07:27:31 <dramforever> > do x <- ("hello ", 2); y <- ("world", 3); return (x + y)
07:27:35 <merijn> absence: Yes to both
07:27:36 <lambdabot>      Could not deduce (Monad ((,) [Char])) arising from a do statement
07:27:36 <lambdabot>      from the context (Num b)
07:27:36 <lambdabot>        bound by the inferred type of it :: Num b => ([Char], b)
07:27:48 <dramforever> ouch what
07:28:50 <dramforever> > do x <- ("hello ", "foo"); y <- ("world", "bar"); return (x ++ y)
07:28:53 <lambdabot>      No instance for (Monad ((,) [Char])) arising from a do statement
07:28:53 <lambdabot>      In a stmt of a 'do' block: x <- ("hello ", "foo")
07:28:53 <lambdabot>      In the expression:
07:28:56 <fvgvxmpv1> dramforever: wouldn¬¥t that be writer?
07:29:07 <dramforever> fvgvxmpv1: I guess so
07:29:13 <dramforever> but what's going on?
07:29:13 * hackagebot ghc-simple 0.1.0.0 - Simplified interface to the GHC API.  http://hackage.haskell.org/package/ghc-simple-0.1.0.0 (AntonEkblad)
07:29:56 <dramforever> merijn: I think it's gone, why?
07:30:03 <dramforever> I mean the instance
07:30:21 <merijn> Yeah, I don't see it in the docs, I remember it being missing, but I thought it was added
07:30:41 <dramforever> I thought I've seen it before
07:31:11 <absence> interesting
07:31:21 <dramforever> ha ha, absence
07:31:25 <absence> i thought it would be there as well, since there's a functor
07:31:26 <merijn> absence: Anyway, it's just Writer
07:31:30 <mniip> absence, Monad a => (,) a is a monad indeed
07:31:35 <mniip> er
07:31:40 <mniip> Monoid a => (,) a
07:31:42 <dramforever> mniip: explain the error messages
07:31:42 <merijn> mniip: Well, we can't find the instance, so :p
07:32:05 <dramforever> > ("a","b") >> ("c","d")
07:32:09 <lambdabot>      No instance for (Monad ((,) [Char])) arising from a use of ‚Äò>>‚Äô
07:32:09 <lambdabot>      In the expression: ("a", "b") >> ("c", "d")
07:32:11 <absence> merijn: writer will do the trick though, thanks :)
07:32:36 <frerich> Funny, I always talked about 'x' being a pattern in 'f x = undefined'. Since there's no constructor involved, I always secretly feared I was wrong but never admitted it. And now I read 'Technically speaking, formal parameters (The Report calls these variables.) are also patterns---it's just that they never fail to match a value.' - so I was right, by accident! :-)
07:33:10 <dramforever> frerich: well, we want to make thinks consistent
07:33:20 <dramforever> that's exactly what's going on
07:33:30 <frerich> I like me thinks consistent.
07:33:44 <dramforever> again, 
07:33:50 <Myrl-chan> :t (&&&)
07:33:53 <mniip> it's time to... derive instances!
07:33:53 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
07:33:58 <mniip> @djinn (a -> a -> a) -> (a, b) -> (b -> (a, c)) -> (a, c)
07:33:58 <lambdabot> f a (b, c) d =
07:33:59 <lambdabot>     case d c of
07:33:59 <lambdabot>     (e, f) -> (a b e, f)
07:34:00 * dramforever thinks that haskell is much more "for tran" than fortran
07:34:13 <tdammers_> 4tran
07:34:13 <Myrl-chan> ...e
07:34:18 <Myrl-chan> wat
07:34:26 <Myrl-chan> What did I step in to. Lol
07:34:28 <dramforever> formula translation
07:34:48 <dramforever> Myrl-chan: you mean (&&&)?
07:35:50 <mniip> :t (&&&) (+++) (|||) (***)
07:35:52 <lambdabot> Arrow a => ((b' -> c') -> Either (a b c1) b' -> Either (a b'1 c'1 -> a (b, b'1) (c1, c'1)) c', (c -> a b'1 c'1 -> a (b, b'1) (c1, c'1)) -> Either (a b c1) c -> a b'1 c'1 -> a (b, b'1) (c1, c'1))
07:36:04 <dramforever> haha
07:36:33 <dramforever> mniip: we like applying stuff together, don't we
07:37:44 <Myrl-chan> :t (\f g -> uncurry $ on (==) (f && g))
07:37:48 <lambdabot>     Couldn't match expected type ‚Äòa -> ()‚Äô with actual type ‚ÄòBool‚Äô
07:37:48 <lambdabot>     In the second argument of ‚Äòon‚Äô, namely ‚Äò(f && g)‚Äô
07:37:48 <lambdabot>     In the second argument of ‚Äò($)‚Äô, namely ‚Äòon (==) (f && g)‚Äô
07:37:52 <Myrl-chan> well
07:38:02 <mniip> Myrl-chan, what are you trying to do
07:38:51 <Myrl-chan> mniip: Not me.
07:40:02 * dramforever is really amazed by "the more you compose, the deeper you get"
07:40:21 <dramforever> :t fmap . fmap . fmap -- classic
07:40:26 <lambdabot> (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
07:40:28 <merijn> dramforever: We don't need &&& anymore, you can just use bimap now :)
07:40:39 <maerwald> afair there was a max fmap
07:40:40 <merijn> dramforever: For some surprising reason Bifunctor is now in base :)
07:40:42 <maerwald> depth
07:40:46 <dramforever> :t foldMap . foldMap . foldMap -- hmm
07:40:48 <lambdabot> (Foldable t, Foldable t1, Foldable t2, Monoid m) => (a -> m) -> t (t1 (t2 a)) -> m
07:41:02 <dramforever> and just found this accidentally:
07:41:13 <dramforever> :t zipWith . zipWith . zipWith -- wtf
07:41:15 <lambdabot> (a -> b -> c) -> [[[a]]] -> [[[b]]] -> [[[c]]]
07:41:17 <exio4> maerwald: which would be there be one? 
07:41:25 <merijn> maerwald: The max is "when your GHC blows up due to lack of memory"
07:41:43 <maerwald> nah, I ddo
07:41:46 <exio4> well, without counting the "practical" one
07:41:53 <maerwald> don't remember the context, but someone tried it here a few weeks ago
07:42:22 <dramforever> :t liftA2 . liftA2 . liftA2 -- generalized
07:42:25 <lambdabot> (Applicative f, Applicative f1, Applicative f2) => (a -> b -> c) -> f (f1 (f2 a)) -> f (f1 (f2 b)) -> f (f1 (f2 c))
07:42:28 <exio4> type inference may end with exponential blow-up times, maybe there? 
07:43:17 <athan> What would be a good module name for the grammar of a linear equation?
07:43:24 <maerwald> if you look for something, you don't find it -.-
07:43:28 <athan> Data.Num.Linear? Data.Linear.Grammar?
07:43:44 <mniip> :t id . id . id
07:43:46 <lambdabot> c -> c
07:43:47 <mniip> :(
07:43:57 <athan> :t flip id
07:43:57 <Myrl-chan> lol
07:43:58 <lambdabot> b -> (b -> c) -> c
07:44:09 <dramforever> athan: Numeric.Linear.Grammar
07:44:10 <Geekingfrog> wtf?
07:44:13 * hackagebot safe-printf 0.1.0.0 - Well-typed, flexible and variadic printf for Haskell  http://hackage.haskell.org/package/safe-printf-0.1.0.0 (HiromiIshii)
07:44:14 <chpatrick> if I have a record A that has a field that points to object B (which is a ForeignPtr), is that enough to guarantee that B won't be garbage collected while A exists?
07:44:20 <dramforever> mniip: it is deeper, it's just too general
07:44:29 <athan> dramforever: Hmm, okay. Are there a lot of packages using `Numeric`?
07:44:33 <dramforever> athan: maybe?
07:44:40 <merijn> chpatrick: Yes
07:44:48 <chpatrick> cool
07:44:52 <mniip> :t ap . ap . ap
07:44:55 <lambdabot> (a -> a1 -> b) -> (((a -> a1) -> a) -> a -> a1) -> ((a -> a1) -> a) -> b
07:44:56 <merijn> chpatrick: Well, I mean, how could it be?
07:45:11 <merijn> chpatrick: The ForeignPtr finalizer doesn't run until the last ForeignPtr is GCed
07:45:48 <merijn> chpatrick: So (ignoring doing unsafe things like explicit freeing) it's impossible to have a ForeignPtr to a freed value
07:46:20 <chpatrick> ok, thanks
07:50:31 <Yuras> merijn: did you see lifted-async? https://hackage.haskell.org/package/lifted-async
07:51:12 <Yuras> There were attempts to convince Simon to use MonadIO, but without lack still :)
07:52:25 <merijn> Yuras: He didn't want to make mapConcurrently, etc. polymorphic and I agree with him
07:52:49 <merijn> But what I want is something different, i.e. just an instance of MonadIO for Concurrently where "liftIO = Concurrently"
07:54:16 <merijn> To avoid the orphan instance
07:54:40 <merijn> The only downside is adding a transformers dependency to async, but that should hardly matter, since everything needs transformers anyway
07:55:15 <Yuras> merijn: Hmm, if you agree with him, then why you want "ReaderT QSem Concurrently a"? You can just pass QSem directly to the action
07:56:09 <merijn> Because I want to "runReaderT myStack qsem" and get a "Concurrently a"
07:57:13 <merijn> My problem is that if I have a stack of two transformers on top of concurrently then I need to write "lift . lift . Concurrently" to lift an IO action into it
07:57:29 <merijn> Because there's no liftIO that works, explicitly lifting like that is inconvenient
07:57:51 <merijn> If you add "instance MonadIO Concurrently where liftIO = Concurrently" then you can just write "liftIO" inside your stack
08:00:28 <Yuras> merijn: but the same applies to all regular functions in async, doesn't it? I'm not a fan of MonadIO, but when upstream deps use custom monad (or transformer), you have to use "lift" everywhere.
08:03:07 <merijn> Yuras: I don't use async, though
08:03:32 <merijn> Basically I'm just doing: https://gist.github.com/merijn/8c8968f61fd8bd8a063f
08:03:51 <merijn> I use concurrently so I can use "traverse" to get concurrent execution of actions
08:06:30 <merijn> Yuras: No, it doesn't apply to the other functions in async
08:06:42 <merijn> Yuras: Because all their return values are IO, so you can just "liftIO" them
08:07:04 <merijn> And Async is not a monad, so you can't use it as the base of your stack
08:09:15 * hackagebot bitx-bitcoin 0.2.0.0 - A Haskell library for working with the BitX bitcoin exchange.  http://hackage.haskell.org/package/bitx-bitcoin-0.2.0.0 (tebello_thejane)
08:11:29 <Yuras> merijn: sorry, I don't understand. Async lives in IO, which can be used as a stack base. Now you have to lift `async`, `wait` etc. You can do it with `liftIO`, but in your case you can just define `liftConcurrently = lift . lift . Concurrently`
08:12:22 <merijn> Yuras: I don't use async at all in my code. The problem is that now you can't write stack polymorphic code that uses Concurrently at it's base AND you need to always figure out how many lifts to insert
08:12:45 <merijn> Which seems silly, since there's a trivial one line instance for Concurrently the removes all these issues without affecting any other code
08:12:52 <Yuras> ok, I see
08:13:34 <lamefun> can I use func _ _ _ = False to say "if none of the patterns match, False"?
08:13:44 <merijn> lamefun: If it's the last pattern, yes
08:14:05 <merijn> lamefun: Patterns are tried in order they are written in the source, and that pattern matches everything
08:14:18 <merijn> lamefun: So if you make sure all the other are in front of it, that'll work
08:17:00 <hunter2> i came here because https://gist.github.com/quchen/5280339
08:17:46 <hunter2> Œª
08:18:38 <frerich> hunter2: Bring it on!
08:18:46 * frerich takes off his shirt (children: shield your eyes)
08:19:13 <vbexpert> Have you got vBulletin? Want to get a Mod/Product/Style? No problem request one here https://www.criosphinx.net/boards/showthread.php?p=4#post4 and we'll get it from vbulletin.org and attach it!
08:19:14 <shirt> frerich: eh?
08:19:25 <vbexpert> Have you got vBulletin? Want to get a Mod/Product/Style? No problem request one here https://www.criosphinx.net/boards/showthread.php?p=4#post4 and we'll get it from vbulletin.org and attach it!
08:19:39 <vbexpert> Have you got vBulletin? Want to get a Mod/Product/Style? No problem request one here https://www.criosphinx.net/boards/showthread.php?p=4#post4 and we'll get it from vbulletin.org and attach it!
08:19:44 <ReinH> @where ops
08:19:44 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
08:19:53 <hunter2> @where ops
08:19:53 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
08:19:54 --- mode: ChanServ set +o geekosaur
08:20:26 <geekosaur> oh, already gone
08:20:38 <ReinH> they'll be back
08:20:50 <merijn> In greater numbers?
08:20:56 <ReinH> apparently
08:21:06 * merijn mumbles something about sandpeople
08:21:14 <hunter2> i don't have vbulletin
08:21:19 <hunter2> seriously is that still used?
08:21:19 --- mode: geekosaur set +b *!~lumpysoup@*.btcentralplus.com
08:21:40 <geekosaur> you'd be surprised what crap is still used
08:21:46 --- mode: geekosaur set -o geekosaur
08:22:26 <hunter2> Java for instance?
08:25:32 <Denommus> hunter2: even (gasp) PHP!
08:27:01 <hunter2> :O
08:27:04 <tdammers_> sadly, both PHP and Java are currently undergoing a renaissance
08:27:13 * hunter2 gasps
08:28:02 <hunter2> 3 billion devices run Java :(
08:29:22 <arw> stuff still runs on cobol and fortran. people still walk instead of using a bicycle or a car. 
08:29:32 <hunter2> hahaha
08:29:55 <hunter2> "walk"
08:30:14 <hunter2> not in scope
08:30:34 <Denommus> hunter2: "running Java" is not necessarily a bad thing. Having a high-level VM for you to target a language is a good thing
08:30:45 <Denommus> hunter2: though I wouldn't use the JVM as a target
08:31:20 <maerwald> Denommus: the JVM is the core for a lot of bugs including security vulnerabilities that take 3 months to fix, how is that any good
08:31:40 <hunter2> to be fair, its mostly Java's runtime environment that's bad
08:32:07 <hunter2> and the constant updates & security vulnerabilities
08:32:08 <arw> hunter2: which usually comes with the JVM, nobody bothers to ship those separately.
08:32:08 <Denommus> maerwald: most of those bugs are on the way applets work, not necessarily related to the JVM itself
08:32:19 <lpaste> lamefun pasted ‚ÄúIs this a good idea at all?‚Äù at http://lpaste.net/134267
08:33:03 <Denommus> nevertheless, I don't think the JVM is good
08:33:07 <merijn> maerwald: I doubt that's in the JVM
08:33:10 <Denommus> I just think having a high-level VM is good
08:33:13 <shlevy> Is there any way to make something like `case 3 of (1 + 2) -> True` work?
08:33:14 <merijn> maerwald: That's in the JRE, which is separate
08:33:18 <arw> Denommus: no, very often its a problem of java shipping very old and broken libraries.
08:33:26 <merijn> Denommus: The JVM is pretty impressive
08:33:29 <arw> Denommus: tons of bugs are in libpng or libjpg.
08:33:30 <athan> Is there a way to coerce default instances when using numeric literals, other than having a type signature? In my use case, I have a (multiparam) typeclass with only instances involving Double, but number literals are assuming the most-general definition
08:33:40 <Denommus> merijn: but it's too tied to Java's object model
08:33:44 <merijn> shlevy: Why would you want that?
08:34:12 <Denommus> merijn: I'd rather have LLVM ported everywhere and used as a target
08:34:18 * hackagebot tip-lib 0.1 - tons of inductive problems - support library and tools  http://hackage.haskell.org/package/tip-lib-0.1 (DanRosen)
08:34:19 <shlevy> merijn: Fiddling around with a quasiquoter for IP addresses, want to be able to pattern match on e.g. 127.0.0.1 but I can't express that as a constant without knowing the target endianness
08:34:27 <merijn> Denommus: not really, although it is rather tied to objects existing, yes
08:34:41 <shlevy> So I'd instead plugin in the bitwise or of each byte
08:36:49 <merijn> shlevy: Why not just go via hton/ntoh or use some library to detect byteorder?
08:37:36 <shlevy> merijn: If I do it at quasiquotation time, that gives me the host address order, breaks on cross-compiling
08:37:40 <tdammers_> biggest JVM complaint for me is how it (by sheer necessity) ignores existing OS culture and mechanisms...
08:37:47 <shlevy> merijn: And I can't pattern match on it if I do it at runtime
08:37:59 <tdammers_> can't do thing the Unix way, gotta do it the Java way
08:38:08 <hunter2> ^^
08:38:12 <tdammers_> price you pay for being cross platform :P
08:39:18 * hackagebot tip-haskell-frontend 0.1 - Convert from Haskell to Tip  http://hackage.haskell.org/package/tip-haskell-frontend-0.1 (DanRosen)
08:39:34 <arw> biggest problem I have with java is that its libraries are hugely old and outdated. 90% of SSL problems on android come directly or indirectly from javas old ssl-lib.
08:40:09 <shlevy> merijn: Alternatively if there's a way to get the target byte order
08:40:37 <Denommus> tdammers_: that would be a problem with any other cross-platform target
08:44:19 * hackagebot linear-grammar 0.0.0.1 - A simple grammar for building linear equations and inclusive inequalities.  http://hackage.haskell.org/package/linear-grammar-0.0.0.1 (athanclark)
08:54:19 * hackagebot trurl 0.1.0.0 - Haskell template code generator  http://hackage.haskell.org/package/trurl-0.1.0.0 (dbushenko)
08:58:01 <mniip> 13:28 <xQuasar>      | Man, I tried to troll like 10 channels and I only got kicked from #bitcoin-dev
08:58:03 <mniip> like
08:58:21 <mniip> it takes one or two specifically crafted sentences to get banned from #bitcoin for life
08:59:59 <dolio> That doesn't sound like it's about Haskell.
09:00:56 <tromp_> one place to see Haskell mentioned: https://bicycledutch.wordpress.com/2015/06/09/bicycle-parking-guidance-system-in-utrecht/
09:01:16 <mniip> dolio, it's from a log of a troll unsuccessfully trying to troll #haskell
09:01:55 <dolio> Then it's definitely not about Haskell.
09:02:27 <dmj`> why are the cabal-install binaries for x86_64 hosted on a website called 'halycon' and why aren't there download links any longer
09:02:47 <bitemyapp> mietek: ^^
09:03:29 <bitemyapp> dmj`: I googled for Cabal binaries, found: https://www.haskell.org/cabal/download.html
09:03:32 <bitemyapp> dmj`: does that not work for you?
09:03:38 <bitemyapp> I see Windows, Mac, Linux binaries.
09:06:09 <dmj`> bitemyapp: no it doesn't, there isn't prebuilt binary for x86_64 for linux, it says they are hosted on halycon now, but the link just goes to halycon's website. 
09:06:44 <bitemyapp> hrm
09:06:45 <dmj`> bitemyapp: it doesn't make sense to me not to host the cabal-install binary downloads on the cabal website. 
09:06:51 <bitemyapp> oh right i386
09:06:51 <cschneid> is there a dedicated irc channel for the new stack tool? 
09:07:08 <bitemyapp> cschneid: not official, but I've been waiting in #haskell-stack for people to show up.
09:07:36 <bitemyapp> cschneid: it'd be literally just you and me though. I'll announce it to the commercial people.
09:08:02 <bitemyapp> dmj`: that's actually kind of funny, I didn't know they stopped offering them
09:09:42 <dmj`> bitemyapp: for osx they seem to, but linux isn't 64-bit
09:10:06 <bananabas> is haskell suitable for numerical computing?
09:10:34 <bananabas> i mean for tasks that are usually solved by matlab/mathematica
09:10:35 <bitemyapp> dmj`: I noticed that.
09:10:46 <bitemyapp> bananabas: the CAS story is rough, the lin-alg story is better.
09:11:02 <bitemyapp> bananabas: OTOH, rolling your own CAS is a common learner's project. Depends on your needs.
09:11:32 <bananabas> do you mean symbolics when you say CAS
09:12:16 <srhb> bananabas: Haskell "the language" may be better suited to some of the tasks. Haskell "the libraries" is often worse.
09:12:22 <arw> bananabas: really depends. haskell is not an interactive math system, so interacting in any way is very limited. you may use ghci, but there is nothing like pretty printing or friendly syntax.
09:12:36 <srhb> arw: Well, that's not quite true.
09:13:18 <srhb> I mean, you can pretty print whatever you want. Unless you meant the lack of libraries again :)
09:14:13 <bananabas> arw, its usable in the notebook interface of project jupyther though
09:14:25 <dolio> C is not an interactive math system, even though I could write one in it.
09:14:36 <bananabas> jupyter
09:14:58 <dolio> And twelf is not a functional programming language even though you can define one in it.
09:15:19 <bitemyapp> https://github.com/gibiansky/IHaskell exists, though I have no idea how solid it is or isn't.
09:15:27 <bitemyapp> last I tried to use it, it was very slow.
09:15:48 <srhb> bitemyapp: https://try.jupyter.org/ -- fire up a Haskell notebook and try again :-)
09:16:02 <arw> bananabas: if you consider this on par with mathematica or matlab then of course, yes. but there are people looking strangely when suggesting octave instead of matlab because matlab is nicer.
09:16:30 <arw> bananabas: it really depends on your definition of suitability
09:18:26 <bananabas> ok let me clarify
09:18:41 <bananabas> maybe you have heard of julia?
09:18:50 <bananabas> julialang.org
09:19:10 <phaazon> conal: I saw your github link about ‚Äúhow you could have invented FRP‚Äù ; do you have the slides yet?
09:19:19 <arw> bananabas: heard yes, used no.
09:19:20 <cschneid> with the stack project, does anybody have a template of what a new project looks like? Should I just spin up a cabal project, then start using stack for the moment?
09:19:21 * hackagebot linear-grammar 0.0.0.2 - A simple grammar for building linear equations and inclusive inequalities.  http://hackage.haskell.org/package/linear-grammar-0.0.0.2 (athanclark)
09:19:34 <cschneid> they seem to have active work going on to figure out spinning up new projects automatically
09:19:45 <Hafydd> Articles whose titles start with "how you could have invented" tend to be quite condescending.
09:19:52 <bananabas> it is a new language created with scientific computing in mind. on their webpage they post benchmarks. i was wondering why they dont include haskell in those benchmarks
09:20:02 <srhb> Hafydd: Really? I found most of them quite good, especially the monads one.
09:20:26 <srhb> bananabas: Probably because Haskell isn't traditionally used in that field.
09:20:26 <dolio> bananabas: Because someone would have to write them?
09:20:52 <srhb> that said, I guess JS isn't either :P
09:21:07 <Hafydd> srhb: they may well be instructive expositions, but the phrasing is condescending nonetheless.
09:21:19 <bananabas> srhb, but its not used because its slow or because its missing numerical libraries?
09:21:20 <arw> bananabas: the benchmarks look similar to http://benchmarksgame.alioth.debian.org/
09:21:38 <srhb> bananabas: Haskell is not slow at all. Missing libraries, missing tooling, much more likely
09:21:40 <dolio> I'm not sure we have libraries for doing what Julia does well, either. Though I don't know much about it.
09:22:08 <srhb> bananabas: Also perhaps there's favourism towards dynamical languages. In fairness Haskell never achieves good performance in interpreted environments at this point.
09:22:19 <arw> bananabas: and those benchmarks are simple algorithms and loops. talking of numerics i would expect something like linpack...
09:22:20 <srhb> bananabas: So for intense tasks, you'd need to compile your program. :)
09:22:35 <Hafydd> They're aimed at the poor ignorant little plebs who "could have invented" Monads but just didn't realise how to.
09:22:39 <dolio> I'd take the benchmark game with salt, too. I'm not sure anyone's looked at the Haskell benchmarks (or others) in years.
09:23:04 <zq> what is stack
09:23:08 <bananabas> well they use JIT compiling
09:23:11 <bitemyapp> srhb: whoa this is ncie.
09:23:18 <srhb> bitemyapp: Yep, much improved :)
09:23:33 <bananabas> is that applicable to haskell?
09:23:39 <srhb> bananabas: Nope, not yet at least.
09:23:48 <bitemyapp> srhb: but where's the source for the Haskell integration?
09:23:51 <bitemyapp> srhb: is it open source?
09:23:55 <ion> shlevy++ for <https://github.com/cartazio/arithmoi/pull/3>. I had arithmoi open in my editor for ages but never got around to fixing it.
09:23:57 <srhb> bitemyapp: It is IHaskell, you linked to it.
09:23:58 <bananabas> i see
09:24:03 <bitemyapp> srhb: oh.
09:24:07 <bitemyapp> srhb: okay.
09:24:19 <srhb> bitemyapp: The IPython thing was renamed Jupyter, hence the confusion probably.
09:24:19 <bitemyapp> srhb: I'm thinking about how an interactive book could be made with this.
09:24:25 <bitemyapp> srhb: yeah confusing :(
09:24:38 <srhb> bitemyapp: Well, IPython the framework was a confusing name for other languages :P
09:25:08 <bananabas> so they split it and now support Julia, R, Haskell, Python
09:25:28 <bananabas> i find it quite nice
09:27:24 <bitemyapp> cschneid: okay, it's official now
09:27:27 <bananabas> so, what *does* haskell have good libraries for?
09:27:30 <bitemyapp> cschneid: #haskell-stack is the place to go.
09:27:42 <cschneid> I got in on the ground floor!
09:27:55 <arw> bananabas: the julia page mentions their benchmarks using BLAS for things, so you could perhaps try to reimplement them with https://hackage.haskell.org/package/hblas
09:28:27 <arw> bananabas: but thats more of a benchmark for the library bindings than anything else.
09:29:26 <bananabas> arw, well they use it for the linear algebra part
09:29:45 <bananabas> arw, diagonalization and such things
09:30:08 <bananabas> arw, but then their clame to fame is that "native loops are fast in julia"
09:30:24 <bananabas> arw, as opposed to, i.e. python or matlab
09:33:54 <srhb> bananabas: iff you accept compiling with optimizations first in Haskell, our loops are incredibly competitive. Of course, we don't have loops, so that's much nicer. :-)
09:34:13 <dolio> I would wager that loops you write in Haskell and compile with GHC will be considerably faster than python.
09:34:19 <dolio> Unless you do something wrong.
09:34:22 * hackagebot linear-grammar 0.0.0.3 - A simple grammar for building linear equations and inclusive inequalities.  http://hackage.haskell.org/package/linear-grammar-0.0.0.3 (athanclark)
09:34:23 <srhb> Indeed.
09:34:31 <dolio> Dunno about matlab.
09:35:50 <bananabas> srhb, so the workflow is very much like C or Fortran then, if i understand correctly. One writes the code, compiles the whole prog, runs. Rinse and repeat.
09:35:59 <srhb> bananabas: Correct :)
09:36:08 <srhb> bananabas: Anything ghci based will be horribly slow for big computations.
09:36:11 <srhb> We can't compete there at all.
09:36:57 <arw> dolio: the usual matlab workflow is "write matlab code, test it, generate c or fortran code from that, compile, execute, calculate"
09:37:10 <dolio> Heh.
09:38:03 <srhb> arw: Oh so that's how it works. Some astrophysicist at my uni did some serious image analysis of a ton of galaxies with Matlab, and I was wondering how it could keep up.
09:38:18 <int-index> Are there any known cases when multiple ContT can/should be used to solve a problem?
09:38:29 <srhb> Multiple even? Scary. :P
09:39:17 <monochrom> explosive workflow: write the code, compile, set bomb timer, run!
09:39:20 <int-index> Yes, I'm developing an mtl extension to use multiple MonadReader/MonadState/MonadWriter/MonadExcept. I wonder if someone would ever need multiple MonadCont.
09:40:29 <ion> monochrom: launchMissiles
09:40:31 <srhb> Nobody ever needs multiple of the others, so probably not. :P
09:40:44 <arw> srhb: depending on how much money you would like to spend you can even autogenerate stuff to execute on GPUs (within certain limits of course) or FPGAs. but the corresponding libraries are sometimes very expensive.
09:40:54 <srhb> arw: *nods*
09:41:21 <int-index> I often need multiple of the others, because I don't like fusing (StateT s1 (State s2 a)) into State (s1, s2) a. It's antimodular.
09:41:56 <int-index> And with mtl it's impossible to have multiple states, multiple readers, etc.
09:42:00 <srhb> Alright. :)
09:43:44 <ion> It would be kind of neat if all the applicatives in base and transformers had lifted Monoid and perhaps even numeric instances if they don‚Äôt have instances for those classes already.
09:44:01 <int-index> And my solution to the mtl problem is very simple (and independently discovered by other people - I've found a blog post and a paper). I wonder why no one implemented it properly yet.
09:44:23 * hackagebot linear-grammar 0.0.0.4 - A simple grammar for building linear equations and inclusive inequalities.  http://hackage.haskell.org/package/linear-grammar-0.0.0.4 (athanclark)
09:44:26 <srhb> int-index: What solution is that?
09:45:08 <Beardful> While cabal installed GLUT it ate all my RAM (1.5 GB) and then ate something like 500MB swap. Is that normal ?
09:45:27 <shlevy> ion: :) Glad you like it
09:45:43 <int-index> srhb: Tag all the transformers. Instead of `ReaderT r m a` you have `ReaderT tag r m a`. Then you can easily identify individual transformers in your stack, or you can be polymorphic in your tag and force it later.
09:45:50 <srhb> Ah.
09:46:21 <int-index> Propagate this tag into classes (so you have `MonadReader tag r m`) and call it a day.
09:46:52 <int-index> It's fully compatible with mtl, and with closed type families I've found a way to ensure that every tag occurs only once in the transformer stack.
09:47:56 <monochrom> Beardful: sometimes the linking stage eats much memory. it is normal. unless you opt for the gold linker
09:49:09 <lpaste> ghorn pasted ‚Äúunexpectedly missing warning‚Äù at http://lpaste.net/134278
09:49:21 <ghorn> i got a runtime error and was surprised by this ^
09:58:36 <ij> Is function the same as computation?
09:59:07 <ion> Not necessarily. You might call an IO action a ‚Äúcomputation‚Äù.
09:59:57 <srhb> ghorn: I don't understand why you get an error at all. Record syntax is weird.
10:02:32 <srhb> ghorn: Warning, rather.
10:02:49 <ghorn> srhb: the warning for b' is Fields of ëBí not initialised: unB
10:02:57 <srhb> Oh, yeah, that one makes sense.
10:03:09 <shlevy> What's the appropriate way to say "this quasi-quoter doesn't make sense in type context"?
10:03:13 <ghorn> srhb: well there are no fields to warn about for a'
10:03:18 <shlevy> If I omit quoteType, I get an ugly warning :)
10:03:23 <ghorn> srhb: i would expect a different warning though
10:04:27 <albeit> @pl \(Foo a b) (Foo a2 b2) = Foo (f a a2) (f b b2)
10:04:27 <lambdabot> (line 1, column 7):
10:04:27 <lambdabot> unexpected "a"
10:04:27 <lambdabot> expecting operator or ")"
10:04:32 <srhb> ghorn: Yeah I suppose so. I actually thought A {} would just be understood as A, but apparently not. Mysterious.
10:04:45 <srhb> ghorn: In fact, ghci seems to think A {} :: A
10:05:00 <srhb> Record syntax makes kittens cry.
10:07:27 <magneticDuck1> o/
10:07:29 <magneticDuck1> http://lpaste.net/134282
10:07:43 <magneticDuck1> been a while since I coded in haskell, can somebody help me figure out how my syntax here is wrong?
10:07:56 <ij> ion, So difference is that there's not one output element for one input element = they may differ = are not referentially transparent?
10:08:05 <ij> So the only diff*
10:08:29 <magneticDuck1> oh wait, s/(Sub a)/Sub
10:08:38 <magneticDuck1> k
10:09:28 * hackagebot multistate 0.6.0.0 - like mtl's ReaderT / WriterT / StateT, but more than one  contained value/type.  http://hackage.haskell.org/package/multistate-0.6.0.0 (lspitzner)
10:11:23 <ghorn> matneticDuck1: o/
10:12:14 <ion> ij: I‚Äôd say a computation is anything a computer does, a function is something isomorphic to a table with a row for each element in the domain.
10:13:35 <magneticDuck1> ghorn: hello
10:15:37 <magneticDuck1> ion: a mathematician would say that's not right because the range could have a cardinal of over aleph 0, and a hardware engineer would say that's kind of right, but it also makes a bunch of pieces of metal hot in the process
10:16:11 <magneticDuck1> and a functional programmer would remind you that _|_ is also an option
10:16:15 * magneticDuck1 complicates things
10:17:50 <phaazon> hey
10:17:51 <phaazon> http://lpaste.net/5854766875216445440
10:17:58 <phaazon> this, is a reactive camera
10:18:06 <phaazon> do you think it has the correct denotation?
10:18:18 <phaazon> I¬†want the camera to keep going if I¬†press W once
10:18:25 <phaazon> and stop when I release it
10:18:59 <magneticDuck1> I should really learn myself some reactive
10:21:22 <etandel> btw, what is a good frp library for haskell? is there something of a Rx Haskell?
10:21:39 <Denommus> etandel: my favorite is reflex
10:22:23 <Denommus> etandel: it has a framework for building dynamic web pages (compiled to JS with GHCJS, or shown inside a webkitgtk window) called reflex-dom
10:22:37 <magneticDuck1> etandel: well, there's more than a Rx haskell
10:22:43 <Denommus> etandel: in reflex-dom, the whole DOM of your web page is a signal/behavior/time-varying value
10:22:46 <magneticDuck1> iirc, haskell was one of the first places reactive started
10:22:55 <magneticDuck1> there are lots and lots of reactive libraries
10:23:01 <magneticDuck1> the one that last caught my eye was elerea
10:23:08 <magneticDuck1> looked elegant and minimal
10:23:17 <Denommus> reactive-banana is also nice
10:23:30 <lrocksmashtime> what about Elm?
10:24:16 <etandel> Denommus: ha, sounds cool
10:24:21 <dolio> Elm is a separate Haskell-like-but-not-Haskell language.
10:24:28 <dolio> If that matters to you.
10:24:31 <Denommus> lrocksmashtime: Elm is another language, and it has discrete time semantics, some would argue that's not real FRP (though reflex has both continuous time and discrete time semantics). Nevertheless, Rx also has discrete time semantics, so that probably doesn't matter for etandel 
10:25:10 <magneticDuck1> lrocksmashtime: maybe you're thinking of Helm?
10:25:12 <Denommus> also, Elm probably generates lighter JS. GHCJS still generates HUGE JS
10:25:36 <magneticDuck1> (elm is based on elerea)
10:25:36 <Denommus> I used to like netwire, but implicit inhibition is annoying
10:27:03 <lrocksmashtime> I've played with Elm a bit and Reactive seems to be its primary focus.
10:27:19 <lrocksmashtime> just throwing it out there
10:27:51 <lrocksmashtime> First time i've heard of Reflex, will have to check it out
10:28:14 <Luke> 	I upgraded to OS X 10.11 and now cabal fails to do things with this error: "cabal: /usr/bin/ar: permission denied"
10:28:23 <Luke> -rwxr-xr-x  1 root  wheel  18160 Jun  3 07:10 /usr/bin/ar
10:29:20 <Luke> that's when using "cabal run" btw
10:29:38 <ion> What does file /usr/bin/ar print?
10:29:45 <Luke> prints the help output
10:29:54 <Luke> i clearly have permission to run it
10:29:59 <etandel> TBH, my knowldge of FRP -> 0 and I was looking for a nice way to start
10:30:03 <arkeet> sounds more like the error is coming from ar
10:30:21 <arkeet> or maybe not, I dunno.
10:30:22 <Luke> arkeet: a permissions error?
10:30:43 <Luke> it doesn't look like it since I can run it directly just fine
10:31:08 <arkeet> I mean cabal is invoking ar in a way that causes it to try to access something it doesn't have permission to.
10:31:36 <Luke> ah good point. it's probably the file cabal is trying to access
10:31:48 <Denommus> etandel: do you have GHCJS installed?
10:31:51 <Luke> i'll run cabal more verbose
10:31:54 <Luke> arkeet: thanks
10:31:59 <arkeet> yes try that.
10:32:33 <arkeet> -v3
10:32:33 <Gurkenglas_> What way do you recommend to read/write .tiff files?
10:32:36 <Luke> arkeet: "Searching for ar in path.
10:32:37 <Luke> cabal: /usr/bin/ar: permission denied"
10:32:41 <Luke> that's all I get unfortunately
10:32:42 <Luke> sow eird
10:32:56 <arkeet> you did -v3?
10:32:58 <Luke> doesn't tell me what it's trying to run exactly
10:33:05 <Luke> yeah that's the -v3 output
10:40:29 <ReinH> ls -al /usr/bin/ar
10:40:42 <ReinH> oh
10:40:47 <ReinH> welp
10:41:42 <etandel> Denommus: Not really, but I do have it on my "check it out" TODO list.
10:42:29 <etandel> Also, is the name 'reactive-banana' related to that paper by Erick Meijer?
10:42:33 <hodapp> bluuuurgh. Type error about not being able to deduce (IvoryCall_ ('[ConstRef s ('Stored t)] ':-> ()) eff0 (ConstRef ('Stack s1) ('Stored t) -> Ivory (ProcEffects s1 ()) ()))
10:42:47 <Denommus> etandel: reflex-dom requires GHCJS
10:42:48 <hodapp> but when I add that as a constraint, it just changes a couple type variable names and complains about it again
10:42:53 <Denommus> etandel: and yes
10:44:28 <etandel> i'll check this reflex thing and reactive-banana (loved the name! =D). thanks all
10:46:24 <whiteline> so if i'm writing a lisp interpreter and need to pass around a copy of the heap when parsing because of homoiconicity, is this what you'd use parsec user state for or have i misinterpreted this
10:47:04 <srhb> Yep, that's exactly the kind of thing it's good for.
10:47:10 <whiteline> nice
10:47:22 <whiteline> thanks
10:47:40 <nacho1> Hello!
10:54:31 * hackagebot pandoc-crossref 0.1.2.1 - Pandoc filter for cross-references  http://hackage.haskell.org/package/pandoc-crossref-0.1.2.1 (lierdakil)
10:55:45 <Luke> ReinH: any other ideas/
10:59:26 <argent0> How can I rescale a (Linear.V3 Double)? http://lpaste.net/134286
11:00:22 <argent0> v3 * 0.5 works but v3 * r where :t r is Double doesn't
11:00:35 <fizbin> I'm looking for an example of how to use cabal to compile C functions that my haskell code then calls. Anyone know a small-to-medium sized haskell library that uses code written in C that's up on github or somewhere else?
11:00:51 <lamefun> Are GADTs actually useful in real code?
11:01:56 <dmj`> lamefun: only in fake code do they become useful
11:03:13 <srhb> lamefun: You always log on and pose the strangest questions. :P
11:03:44 <fizbin> argent0: Does this work?      v3 * (fromRational (toRational r))
11:04:11 <zq> lamefun: why wouldn't they be? cf. the minsky ocaml blog post
11:04:20 <monochrom> @type fromRational . toRational
11:04:22 <lambdabot> (Fractional c, Real a) => a -> c
11:04:27 <zq> lamefun: https://blogs.janestreet.com/why-gadts-matter-for-performance/
11:04:43 <monochrom> you can also use realToFrac
11:04:49 <monochrom> @type realToFrac
11:04:53 <lambdabot> (Fractional b, Real a) => a -> b
11:05:43 <Zemyla> Why do I like EdwardK's free monoid monad?
11:06:13 <argent0> fizbin: It does, thanks! Why does this work?
11:07:03 <fizbin> argent0: You should probably use realToFrac, as monochrom said.
11:07:28 <fizbin> So the reason it works is that (*) has type Num a => a -> a -> a
11:07:39 <fizbin> @type (*)
11:07:41 <lambdabot> Num a => a -> a -> a
11:08:11 <fizbin> So the only way "v3 * x" is going to work is if "x" actually has the same type as "v3"
11:08:46 <fizbin> Now, funny thing about numeric constants in Haskell. They don't have the types you might think that they do.
11:08:49 <fizbin> :t 3
11:08:51 <lambdabot> Num a => a
11:08:56 <fizbin> @type 0.3
11:08:58 <lambdabot> Fractional a => a
11:10:17 <fizbin> Specifically, "0.5" has the type "Fractional a => a". This means effectively that 0.5 isn't really a Double, but really means "autoconvert to any type that has a Fractional implementation"
11:10:42 <argent0> fizbin: Ok, thanks for the explanation!
11:11:46 <fizbin> Since v3 * 0.5 worked, that means that Linear.V3 must have a Fractional implementation, so I was looking for "how do I convert Double to an arbitrary Fractional instance". Hence my weird code, that is equivalent to realToFrac
11:14:11 <conal> phaazon: The "How you could have invented FRP" slides are in progress.
11:17:14 <prsteele> @hoogle splits
11:17:15 <lambdabot> System.FilePath.Windows splitSearchPath :: String -> [FilePath]
11:17:16 <lambdabot> System.FilePath.Posix splitSearchPath :: String -> [FilePath]
11:17:17 <ij> newsham, Hello. Do you know anything about NineP?
11:19:07 <mizu_no_oto> Is there a good, easy to use GUI for pandoc for windows?
11:19:10 <Zemyla> fizbin: You want to use realToFrac anyway, because there are specialized implementations for things like Float->Double or Int->Double.
11:19:50 <mizu_no_oto> There's a non-technical person I know who could use it
11:22:09 <schoppenhauer> are rewrite rules from one module applied in other modules too?
11:22:16 <schoppenhauer> especially, recursively?
11:22:24 <schoppenhauer> through polymorphic functions
11:24:27 <dolio> If you import a module with rewrite rules, they will be applied.
11:24:47 <dolio> Probably re-exported, too.
11:32:44 <megaman> How difficult will haskell be for me to learn given that I have 4 years experience with Erlang?
11:33:09 <koala_man> who cares, it'll be a lot of fun
11:33:12 <srhb> megaman: Mostly doesn't help you.
11:33:17 <srhb> megaman: Everything's different. :)
11:33:28 <megaman> ok, thanks guys
11:34:09 <dolio> Erlang experience seems at least somewhat relevant.
11:35:19 <albeit> In aeson, how can I derive FromJSON and ToJSON for (FromJSON a, FromJSON b, ToJSON a, ToJSON b) => Map a b? 
11:36:50 <schoppenhauer> how can I convert a Word8 to a Word64?
11:36:57 <monochrom> fromIntegral
11:37:05 <schoppenhauer> ok thx
11:38:02 <Clint> albeit: you can't without breaking json?
11:41:16 <albeit> Clint: Couldn't I do something like ToJSON theMap ~ {"type":"map", "vals": Map.toList theMap} ?
11:42:17 <chpatrick> is there any way to get GHC to link against a specific .so.1?
11:42:23 <chpatrick> it always appends ".so"
11:43:38 <geekosaur> there is not
11:43:46 <geekosaur> it sounds like you are missing a devel package
11:43:53 <Clint> albeit: what are you going to do when the keys of the map aren't strings?
11:44:31 <albeit> Client: Enforce that they have to be able to be stringified
11:50:07 <f-a> I wrote a program which compiles with ghc 7.10. How to test compilation it with 7.6?
11:50:54 <monochrom> have you installed 7.6 too?
11:51:19 <f-a> monochrom: no, should I (I run debian jessie so I could pick it up from the repos)
11:51:20 <monochrom> I have 7.6. I can test it. if you use only libraries I have.
11:52:25 <monochrom> I do not know. it depends on whether jessie's packaging interferes with your 7.10 installation
11:52:30 <f-a> monochrom: I was looking for something I can do on my own (pestering folks every time I push a commit seems a good way to getting banned from #haskell xD)
11:52:47 <f-a> monochrom: I could download ghc
11:52:48 <shlevy> Is there a less pointy way to write (\x -> f . g <$> (h x))?
11:52:56 <f-a> without the platform
11:53:14 <johnw> ((f . g) <$>) . h
11:53:24 <johnw> fmap (f . g) . h
11:53:41 <shlevy> johnw: Ah, thanks
11:53:50 <shlevy> Second one maybe even looks nicer :D
11:53:55 <johnw> it does
11:54:01 <quchen> shlevy: You can rewrite *any* function into pointfree style.
11:54:08 <shlevy> johnw: Greg says hi by the way
11:54:14 <johnw> hello Greg!!!
11:54:30 <shlevy> johnw: You just contributed to the ephys stuff we're working on! :P
11:54:40 <monochrom> yeah, it is safest to get ghc from ghc website and "./configure --prefix=/usr/local/ghc-<version>". then play with PATH to switch version. this has minimum interference and maximum convenience of uninstall
11:55:16 <f-a> thanks monochrom 
11:56:00 <shlevy> Is there a way to get ghc to print out the result of a quasiquoter?
11:56:31 <quchen> shlevy: Have you tried -ddump-splices?
11:57:34 <shlevy> quchen: I'm building this with cabal build, how do I pass that?
11:57:51 <quchen> -ghc-options=-ddump-splices
11:57:54 <shlevy> Thanks
11:58:01 <quchen> --ghc-options, I think.
11:58:58 <shlevy> quchen: Thanks!
11:59:58 <shlevy> Hmm is it a bug in cabal that if I change the definition of a quasiquoter, it doesn't rebuild another executable that uses it?
12:09:35 * hackagebot uhc-util 0.1.5.6 - UHC utilities  http://hackage.haskell.org/package/uhc-util-0.1.5.6 (AtzeDijkstra)
12:16:36 <chpatrick> hey, I made a basic lens interface to libclang, anyone interested?
12:17:00 <Ralith> that sounds awesome
12:17:46 <lpaste> chpatrick pasted ‚Äúpatrick-clang example‚Äù at http://lpaste.net/134292
12:18:55 <chpatrick> I think it would be nice to have pattern synonyms for all the different cursor kinds too
12:19:21 <Iceland_jack> <Axman6> it was a poor suggection (sorry Iceland_jack =)
12:19:21 <Iceland_jack> Agreed
12:22:41 <schoppenhauer> is it possible, in ghci, to trace the main function with arguments?
12:22:56 <mauke> (main isn't a function)
12:22:59 <schoppenhauer> so to trace what happens when running :main ...
12:23:26 <schoppenhauer> mauke: ok whatever, is it possible to do?
12:23:35 <mauke> I'm not sure what you're asking
12:23:40 <mauke> (I've never used :main)
12:23:47 <[[derek]]> stupid question, what does the => function do in haskell?
12:23:50 <mauke> is this just :set args ... and then :trace main?
12:24:02 <mauke> [[derek]]: => is not a function
12:24:11 <kadoban> [[derek]]: It's not a function. It's syntax for typeclass constraints
12:24:14 <[[derek]]> I thought everything was a function in haskell
12:24:15 <c_wraith> Today in #haskell: nothing is a function
12:24:17 <geekosaur> [[derek]], it's not a function. it delimits constraints in a type
12:24:24 <mauke> [[derek]]: no, most things aren't
12:24:35 * hackagebot ip-quoter 1.0.0.0 - Quasiquoter for IP addresses  http://hackage.haskell.org/package/ip-quoter-1.0.0.0 (shlevy)
12:24:44 <schoppenhauer> mauke: apparently
12:24:54 <c_wraith> The only things that are functions in haskell are things whose type unifies with (->) a b
12:24:54 <geekosaur> in particular, => is part of type level and haskell does not in general do type level functions
12:24:59 <kadoban> [[derek]]: Very much not. Functions are functions ‚Ä¶ other things aren't. Functions are things with   ->   in the type, essentially.
12:25:15 <c_wraith> kadoban: like Maybe (Int -> String) .  :P
12:25:17 <geekosaur> in fact there are things at type levle that are restricted so they can't be used as type functions
12:25:28 <KaneTW> functions are things with (->) as the outermost type
12:25:36 <kadoban> c_wraith: :P
12:26:18 <schoppenhauer> mauke: no.
12:26:22 <[[derek]]> okay I see now
12:26:29 <[[derek]]> I simply forgot as happens with age
12:26:33 <schoppenhauer> mauke: when I do :set args ... and :trace main, the program just does nothing
12:26:46 <mauke> aw :-(
12:27:11 <geekosaur> you might be able to do :trace withArgs [...] main
12:27:45 <adarqui> about to fix my janky cabal test setup, to use hspec
12:28:04 <adarqui> doctest seems cool too
12:28:20 <geekosaur> (importing withArgs from System.Environment)
12:28:27 <greensoup> is there an operator that is the opposite of .?
12:28:44 <mauke> decomposing functions?
12:28:45 <geekosaur> define "opposite" here?
12:28:48 <mauke> subtraction?
12:28:55 <ghorn> is `foo :: a` not a function, since there is no (->)  ?
12:29:03 <geekosaur> it is not
12:29:08 <mauke> ghorn: it could be, since a can unify with (->) b c
12:29:11 <geekosaur> sometimes it is called a "constant applicative form"
12:29:34 <geekosaur> although depending on what it is and how it is used, it might be able to unify `a` with a function type
12:29:54 <ghorn> so `a` may be a function, but `Int` would not be
12:30:15 <mauke> ghorn: right
12:32:01 <geekosaur> basically, the common notion of "function" does not exactly correspond to Haskell's type system. this shows up as things that look like but aren't "functions" and as "functions" that look like they have some number of parameters but behave as if they have some other number of parameters.
12:33:16 <greensoup> geekosaur: i guess i mean I want to `flip` the order in which the functions are composed
12:33:30 <geekosaur> oddly enough you just answered your own question
12:33:35 <magneticDuck1> @type id
12:33:37 <geekosaur> flip (.)
12:33:38 <magneticDuck1> @type flip id
12:33:38 <lambdabot> a -> a
12:33:40 <lambdabot> b -> (b -> c) -> c
12:33:48 <magneticDuck1> ghorn: ^^
12:34:08 <geekosaur> there's not a predefined operator or function for that, IIRC, although one has been discussed and some packages (notably lens) define one
12:34:19 <Iceland_jack> There is (>>>) from Control.Arrow
12:34:31 <KaneTW> :t flip (.)
12:34:41 <lambdabot> (a -> b) -> (b -> c) -> a -> c
12:34:48 <Iceland_jack> > (show >>> length) 42
12:34:50 <srhb> lambdabot is really struggling these days. Is some channel abusing it?
12:34:53 <lambdabot>  2
12:35:30 <KaneTW> > (show >>> cycle >> take 11) 42
12:35:33 <KaneTW> > (show >>> cycle >>> take 11) 42
12:35:35 <kadoban> Maybe lambdabot just had a hard weekend. Bots gotta party too.
12:35:40 <lambdabot>  mueval-core: Time limit exceeded
12:35:41 <lambdabot>  "42424242424"
12:35:45 <srhb> kadoban: It's... wednesday... :-)
12:35:52 <kadoban> A /really/ hard weekend :)
12:35:54 <Iceland_jack> lambdabot parties hard srhb
12:35:55 <KaneTW> i'm surprised the first one gave an error
12:35:55 <srhb> Hehe.
12:35:57 <geekosaur> I'd guess more likely it's on shared hosting and something else on the actual hardware is using the cycles
12:36:01 <srhb> KaneTW: Random timeout.
12:36:01 <geekosaur> that has been seen before
12:36:12 <KaneTW> > (show >>> cycle >> take 11) 42
12:36:16 <lambdabot>      Precedence parsing error
12:36:16 <lambdabot>          cannot mix ‚Äò>>>‚Äô [infixr 1] and ‚Äò>>‚Äô [infixl 1] in the same infix ex...
12:36:21 <KaneTW> now it's right
12:37:21 <greensoup> thanks
12:37:26 <greensoup> sometimes it's nice to visualize the flow of data through functions from left to right.
12:37:42 <KaneTW> i find it more useful for FRP and stuff
12:37:54 <KaneTW> years of math have ingrained (.) for function composition for me
12:38:17 <mauke> f‚àòg
12:38:53 <KaneTW> it's also really silly tbh
12:39:20 <kadoban> I find using a flipped (.) to be much easier to type, personally.
12:39:36 * hackagebot pipes-mongodb 0.1.0.0 - Stream results from MongoDB  http://hackage.haskell.org/package/pipes-mongodb-0.1.0.0 (WilliamCasarin)
12:39:39 <KaneTW> f(g(x)) <=> (f.g)(x) makes much less sense than (g >>> f)(x)
12:40:14 <kadoban> typatypatypa (go left a bunch, type a . go left more, type a space) is kinda tedious ‚Ä¶ I'm sure there's some way around that, but I dunno.
12:40:45 <breadmonster> Hey everyone.
12:40:54 <breadmonster> So I'm lexing Python with Parsec.
12:41:02 <breadmonster> And this pattern keeps coming up.
12:41:28 <breadmonster> `blahParser = liftA (:) firstBlah restOfBlahs`
12:41:30 <johnw> is there an example of an "f a", where f is not a Functor, and 'a' does not appear contravariantly?
12:41:40 <breadmonster> Is there a function that abstracts this out?
12:41:57 <breadmonster> ie. Monad m => m a -> m [a] -> m [a]?
12:42:19 <quchen> johnw: a -> a?
12:42:28 <johnw> "and 'a' does not appear contravariantly?" :)
12:42:47 <quchen> Well, it's not a contravariant functor in "a", didn't you mean that?
12:42:54 <mauke> consM = liftA2 (:)  -- now there is
12:43:03 <hexagoxel_> breadmonster: what about `(:) <$> first <*> rest` ?
12:43:06 <fizbin> Hey, is anyone here really familiar with using Foreign? Specifically, what should I watch out for around using "malloc", and can I save myself grief by using "mallocForeignPtr" instead?
12:43:14 <breadmonster> mauke: Okay :P
12:43:25 <breadmonster> hexagoxel_: Oh that's cool!
12:43:32 <johnw> quchen: a -> a is not a Functor at all, but a appears contravariantly
12:43:47 <johnw> I want a non-functor where a is not contravariant
12:43:48 <quchen> johnw: Ah, by contravariantly you mean in negative position?
12:43:52 <johnw> yes
12:43:57 <int-e> johnw: data Foo a where I :: Int -> Foo Int
12:43:59 <breadmonster> :t (<*> (char ' '))
12:44:02 <lambdabot>     Couldn't match expected type ‚Äòf a‚Äô with actual type ‚ÄòDoc‚Äô
12:44:02 <lambdabot>     In the second argument of ‚Äò(<*>)‚Äô, namely ‚Äò(char ' ')‚Äô
12:44:02 <lambdabot>     In the expression: (<*> (char ' '))
12:44:10 <breadmonster> :t char
12:44:12 <lambdabot> Char -> Doc
12:44:21 <johnw> int-e: hmm
12:44:21 <int-e> johnw: data and type families and gadts are the only thing I can think of there
12:44:21 <breadmonster> Oh that's not imported from Parsec, I see.
12:45:20 <johnw> int-e: also I guess: data Foo g a = Foo (g a), where nothing is known about g
12:45:59 <breadmonster> hexagoxel_: doesn't work.
12:46:30 <sinelaw> doctest can't parse function-style CPP macros?
12:46:40 <sinelaw>      error: missing binary operator before token "("
12:46:40 <sinelaw>      #if MIN_VERSION_base(4,7,0)
12:50:07 <hexagoxel_> :t (\a b -> liftA2 (:) a b, \a b -> (:) <$> a <*> b)
12:50:09 <lambdabot> (Applicative f, Applicative f1) => (f a -> f [a] -> f [a], f1 a1 -> f1 [a1] -> f1 [a1])
12:51:11 <breadmonster> hexagoxel_: What does the comma mean?
12:51:17 <hexagoxel_> breadmonster: has the same type, it must work :p
12:51:21 <hexagoxel_> just a tuple
12:51:31 <breadmonster> Oh right okay.
12:51:34 <breadmonster> That's interesting...
12:51:53 <hexagoxel_> you did mean liftA2 and not liftA in your initial expression, right?
12:51:54 <breadmonster> I got some weird type error when I tried with parsec instances.
12:51:57 <breadmonster> Yeah...
12:53:33 <Luke> when I upgraded my OS X, now I can‚Äôt use ‚Äúcabal run‚Äù without getting an error: "cabal: /usr/bin/ar: permission denied". 'ar' has run permissions just fine so I'm assuming it's the file cabal is trying to run 'ar' on. I ran with -v3 and no help on the output. anyone have any ideas to debug this?
12:53:57 <lpaste> breadmonster pasted ‚Äústrange error?‚Äù at http://lpaste.net/134296
12:54:07 <breadmonster> hexagoxel_: There you go.
12:54:33 <hexagoxel_> breadmonster: where is the (<*>) ?
12:54:43 <breadmonster> Oh right, stupid of me...
12:54:44 <yac> I have a f :: Int -> String but any Int <1 does not make sense ever, what should I do about it?
12:54:45 <edwardk> geekosaur> base added (&) to Data.Function in GHC 7.10
12:54:46 <breadmonster> Sorry about that.
12:55:07 <breadmonster> yac: you mean in your specific context?
12:55:08 <yac> f x | x <1 -> error "u wot m8?"
12:55:10 <kadoban> :t (&)
12:55:13 <lambdabot> a -> (a -> b) -> b
12:55:13 <yac> breadmonster: yes
12:55:31 <breadmonster> yac: Use the Maybe monad.
12:55:41 <hexagoxel_> breadmonster: yeah come on, the error basically tells you directly "hey, missing <*>!"
12:55:53 <hexagoxel_> :)
12:55:57 <yac> ^ that error was what I was thining about
12:56:01 <KaneTW> yac: if you expect inputs < 1, use Maybe. otherwise just make the function explicitly partial
12:56:27 <breadmonster> hexagoxel_: Sorry, umm, I haven't used applicatives before this parsing this, so that's why I'm kinda new.
12:56:29 <KaneTW> if you're writing a library always write total functions imo
12:57:27 <phaazon> conal: cool!
12:57:48 <yac> KaneTW: the other way around, I expect only >=1
12:58:12 <geekosaur> Luke, I think I'd try to use dtruss (note that you have to do it as root)
12:58:37 <geekosaur> (or find a way to start it and immediately attach with a dtruss running as root, but that's tricky :/ )
12:59:04 <breadmonster> geekosaur: you're a Mac user?
12:59:23 <geekosaur> yes
12:59:36 <breadmonster> Oh right.
12:59:54 <breadmonster> I'm considering getting a MacBook Air, but it seems like a really frail machine.
13:00:24 <breadmonster> Especially for compiling large things.
13:00:40 <KaneTW> yac: well, yeah
13:00:41 <Luke> geekosaur: hmm output's not that helpful
13:01:09 <geekosaur> figures :/
13:01:35 <Luke> it's all hex output
13:03:19 <Luke> hmm even cabal configure has the permissions ar problem
13:05:02 <prsteele> Luke: shot in the dark, but do you have permissions for where cabal is trying to set up shop?
13:05:19 <Luke> prsteele: let me check
13:05:33 <Luke> prsteele: yes
13:06:10 <Luke> going to chown -R anyway
13:06:14 <ew0> breadmonster, I have a macbook pro. It is awesome as long as you strip it of the OSX and put a linux. You get a 20% speed boost on haskell code. (at least my code)
13:06:23 <l0p3n> I want to write a function that only prints the result from calling another function. Any advice on what the return value of this function?
13:06:38 <breadmonster> ew0: MBP is damn pricey, especially where I'm from man.
13:06:40 <l0p3n> *Any advice on the return value of this function
13:06:42 <breadmonster> No student discounts and all that.
13:06:58 <breadmonster> Plus, it's imported, so there's a tax on imports, and there's also a tax on luxury goods -.-
13:07:04 <ew0> probably not worth it then
13:07:21 <prsteele> cheapest laptop + ssh + good desktop is where its at
13:07:29 <hexagoxel_> breadmonster: wait, you did realize i was joking? (irony in text-only communication always fails :/)
13:08:04 <breadmonster> prsteele: Student, mate. Don't have a place to keep a good desktop, but I know what you mean.
13:08:13 <breadmonster> hexagoxel_: Nope, thanks for the clarification :P
13:08:23 <prsteele> l0pen: IO () ?
13:08:29 <ew0> My employer bought it for us without consulting us
13:08:35 <ew0> I would never have bought them
13:08:51 <ew0> linux works better in cheaper hardware
13:08:54 <breadmonster> ew0: What linux are you running?
13:08:56 <geekosaur> they already left :/
13:09:03 <hexagoxel_> sorry for being ambiguously rude :p
13:09:04 <ew0> I'm in ArchLinux
13:09:15 <ew0> switching to nixos in short term
13:09:25 <schoppenhauer> hm. somehow :set -fenable-rewrite-rules has no effect. my rewrite rule isn't used in debug mode
13:09:30 <dmj`> ew0: sure but for development osx is nice, build servers can gen. the good code after its checked in
13:09:45 <ew0> osx is rotting
13:10:00 <ew0> since lion there are some serious problems
13:10:13 <ew0> graphics drivers were not updated, for instance
13:10:46 <ew0> same code, on same hardware, runs much faster on linux
13:11:12 <ew0> my largest projects was 20% slower on OSX
13:12:02 <ew0> instead o taking 3-4 days to run my tests, it took 5-6 days
13:12:12 <ew0> it was a big deal for me, so I dropped OSX
13:12:44 <arw> mac os is practically abandonware at this point. all the effort is in iOS
13:13:31 <breadmonster> ew0: What projects take 6 days to test? o.O
13:16:34 <marchelzo_> Could you write a Num instance for Num a => a -> a?
13:16:53 <mauke> even better: Num a => e -> a
13:17:01 <mauke> or any Applicative instance
13:17:17 <mauke> (((->) e) is not just Applicative but also Monad)
13:17:20 <ew0> compiler optimizations tested on a cache simulator, with many cache configurations
13:17:22 <ew0> http://pastie.org/10234325
13:17:26 * geekosaur is gradually creeping closer to ditching it, actually. but not liking the alternatives
13:17:26 <ew0> now this 
13:17:30 <Beardful> How do i compile my code so that i can run it from whichever computer? (How do i get all the necessary .DLL's/.so's?)
13:17:40 <ew0> oops
13:17:43 <ew0> wrong channel
13:17:57 <marchelzo_> mauke: Why isn't there one by default?
13:18:02 <srhb> Beardful: That's not simple
13:18:13 <srhb> Beardful: Generally you'll have to build it on each kind of system you want to run it on.
13:18:29 <mauke> marchelzo_: because people get confused when 1 2 3 typechecks
13:18:46 <srhb> Beardful: Other than that it's just static building.
13:19:04 <breadmonster> mauke: What's a conceivably consistent Num instance for a -> a?
13:19:11 <geekosaur> marchelzo_, you can do it and occasionally someone loads a quick implementation into lambdabot. which, as mauke notes, tends to be highly confusing
13:19:14 <marchelzo_> Why would that typecheck?
13:19:22 <geekosaur> instance (Num b) => Num (a -> b) where { (f + g) x = f x + g x; (f * g) x = f x * g x; abs f x = abs (f x); signum f x = signum (f x); negate f x = negate (f x); fromInteger n x = fromInteger n }
13:19:38 <mauke> geekosaur: needs more Applicative
13:19:43 <Beardful> srhb: Well the differences in systems would be 64/32bit win/lin/mac, correct?
13:19:53 <geekosaur> sure, I'm basically copy-pasting Cale's favorite quick instance :)
13:19:57 <mauke> (+) = liftA2 (+); abs = liftA abs; fromInteger = pure . fromInteger; etc
13:19:57 <srhb> Beardful: Your program, you tell me. :)
13:20:15 <geekosaur> with the @let stripped
13:20:55 <marchelzo_> The application of fromInteger is implicit in the expression 1 2 3?
13:20:58 <geekosaur> (literally grepped Cale.*instance.*Num from my IRC log and copy-pasted the result)
13:21:04 <geekosaur> marchelzo_, yes
13:21:20 <marchelzo_> Is Num the only typeclass that behaves like that?
13:21:22 <geekosaur> a numeric literal is defined by the language to be an application of fromIntegral or fromRational
13:21:23 <breadmonster> geekosaur: What client?
13:21:24 <Beardful> srhb: Well in my case it's a simple GLUT program no fancy hardware requirements. I probably can just compile it for 32bit architecture for mac/lin/win. I just need to figure out how to do static builds.
13:21:33 <Haskellfant> Beardful: I think by default you are still linking to libc, so it's not completely portable. there was a project at zurihac using libmusl for completely static compilation
13:21:35 <srhb> marchelzo_: All numerical literals are shorthand for fromSomething x
13:21:51 <geekosaur> breadmonster, textual, but I ran the grep in the shell on textual's log directory for the channel
13:22:31 <marchelzo_> srhb: oh, interesting
13:22:36 <geekosaur> wasn't a straight copy-paste as therw were more hits than just the instance def (and I wanted to edit out the @let so I didn't actually load it into LB!)
13:23:11 <geekosaur> and, while in standard Haskell only Num works that way, ghc has extensions to do the same for strings and (in 7,10) lists
13:23:25 <mauke> :t 1.2
13:23:33 <lambdabot> Fractional a => a
13:23:49 <breadmonster> geekosaur: What are the extensions?
13:23:58 <mauke> OverloadedStrings
13:24:00 <geekosaur> OverloadedStrings, OverloadedLists
13:24:07 <breadmonster> I need to figure out what extensions do. XFlexibleContexts still leaves me in the dark.
13:25:34 <geekosaur> breadmonster, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-class-extensions.html#instance-rules
13:26:00 <Welkin> what is OverloadedLists?
13:26:10 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-class-extensions.html#overloaded-lists
13:26:32 <geekosaur> basically lets you do things like initialize something like a Map from a list (implicit fromList around list literals)
13:26:42 <Welkin> I see
13:27:06 <Welkin> I prefer to be explicit, but that is a interesting
13:27:14 <breadmonster> Welkin: can you eli5? It's kinda hard to grasp the difference
13:27:15 <Welkin> I do use OverloadedStrings quite often in yesod
13:27:21 <breadmonster> Sorry, geekosaur
13:28:07 <geekosaur> not sure what you're asking
13:28:35 <breadmonster> What does FlexibleContexts do?
13:28:40 <geekosaur> the point is that standard Haskell has extremely restrictive rules on what the constraints on an instance can look like
13:30:25 <geekosaur> unfortunately I'm not really the right person to ask about it, as I don't really grok type theory that well :/
13:30:47 <Luke> gah this is killing me this `ar` permissions problem in cabal
13:31:51 <geekosaur> I sort of understand what the conditions added by FlexibleContexts are there for, but mostly my impression is "Haskell2010 protects the type system by wrapping it in concrete, FlexibleContexts protects it by checking for hidden explosives"
13:32:24 <breadmonster> Interesting.
13:33:08 <breadmonster> Also, in the Num a => Num (a -> a) instance, what does 1 2 3 evaluate to?
13:33:57 <lamefun> I have this: data ListMatcher a = WildcardP | AnyP | MatchP a ; type ListPattern a = [ListMatcher a] - how do I encode it in type system that there can't be consecutive WildcardP or AnyP?
13:34:28 <lamefun> I tried this: http://lpaste.net/134267 - seems to work, but I don't like the b argument...
13:34:41 * hackagebot schedule-planner 1.0.1.0 - Find the ideal lesson layout  http://hackage.haskell.org/package/schedule-planner-1.0.1.0 (justus)
13:35:16 <geekosaur> breadmonster, IIRC it evaluatres to 1 because the fromInteger implementation strips the parameters
13:40:50 <Luke> anyone else using haskell with OS X 10.11 yet?
13:42:28 <tomphreek> what's the best way to pass stdin through a function and output it to an stdout in haskell? I recall there's a function for it but can't remember the name
13:42:38 <michaelt> interact
13:42:38 <dmj`> :t interact
13:42:44 <lambdabot> (String -> String) -> IO ()
13:43:00 <michaelt> tomphreek: there is one for Text and for ByteString as well, fwiw
13:44:34 <michaelt> tomphreek: I don't know if that's the best way...
13:44:41 * hackagebot lens-simple 0.1.0.4 - simplified import of elementary lens-family combinators  http://hackage.haskell.org/package/lens-simple-0.1.0.4 (MichaelThompson)
13:44:59 <merijn> "It depends", as always
13:45:24 <michaelt> tomphreek: what is the function going to be like? does it e.g. act on lines 
13:45:25 <t7> osx ÂìàÂìà Â§™Â•ΩÁ¨ë‰∫Ü
13:45:35 <dfeuer> Ping johnw 
13:48:13 <phaazon> conal: why don‚Äôt you update reactive anymore?
13:48:18 <phaazon> latest hackage version is from 2010
13:48:49 <Klexos_> anyone connected through tor???
13:48:58 <merijn> michaelt: No, it treats stdin as a single lazy String and stdout too
13:49:04 <conal> phaazon: I went on to other things. At the time, I got bogged down in some subtle GHC RTS bugs and perhaps some of my own bugs that were very hard to track down.
13:49:09 <merijn> michaelt: But you can always use "lines" inside the interact version
13:49:37 <michaelt> merijn: yeah I know, I was asking for more information on tomphreek 's purpose; maybe I didn't put it well.
13:50:00 <phaazon> conal: interesting
13:50:00 <merijn> Is there a way to silence a single orphan instance warning?
13:50:14 <phaazon> I think I should give a try to implementing my framework by following your denotational design
13:50:15 <conal> phaazon: ... involving lub/unamb and RTS sparks 
13:50:29 <conal> phaazon: do it. let me know if you need pointers.
13:50:46 <phaazon> thanks
13:51:34 <phaazon> the thing that bothers me about FRP is that it looks super sexy
13:51:37 <phaazon> but in almost 20 years
13:51:44 <michaelt> merijn: if it's an orphan you can put the instance in its own module, then use -fno-warn-orphans in it? 
13:51:50 <phaazon> there‚Äôs no ‚Äúgood success story‚Äù using it
13:51:56 <phaazon> I wonder why
13:52:00 <michaelt> merijn or whatever the incantation is
13:52:08 <merijn> michaelt: My entire program is like <100 lines of code in a single file, so that would be annoying :p
13:52:13 <phaazon> there hasn‚Äôt been*
13:52:34 <michaelt> merijn: and you want to make sure that none of your other instances are orphans?
13:52:41 <Klexos_> hi guys. sorry to interupt. wondering if any of u know if torchat is really secure of if its bs. been hearing different opinions about it.
13:53:05 <merijn> michaelt: I have automatic error highlighting so it lights up in my editor and I wanna turn that off without disabling orphan instance warnings everywhere in my editor
13:53:27 <merijn> Klexos_: IRC is by design completely insecure, so the security of torchat is not really relevant for freenode
13:54:16 <michaelt> there are certainly a lot of insecure people on irc
13:54:44 <Klexos_> i know merijn, just was hoping to compile opinions on it as i havent found any concrete info about it
13:54:50 <phaazon> conal: Pull-based  evaluation  fits  well  with  the  common  functional
13:54:50 <phaazon> programming style of recursive traversal with parameters (time,
13:54:50 <phaazon> in  this  case).  Push-based  evaluation  appears  at  first  to  be  an
13:54:53 <phaazon> inherently imperative technique.
13:55:19 <phaazon> does it mean your denotational design doesn‚Äôt include interfacing the FRP system over an imperative framework?
13:55:20 <conal> phaazon: yep, at first. 
13:55:27 <phaazon> like callbacks system
13:55:30 <phaazon> (GUI, typically)
13:55:51 <merijn> phaazon: reactive-banana was designed to interface with imperative callback based frameworks, it seemed to work decently
13:55:58 <phaazon> yeah
13:56:02 <phaazon> I read the source code of banana
13:56:05 <phaazon> I¬†got lost
13:56:09 <phaazon> with all the graphs and stuff
13:56:13 <merijn> But I ran into an issue where recursive Behaviours were buggy so I stopped hacking on that for a while
13:56:26 <merijn> It should be fixed, but haven't looked into that project since
13:56:40 <conal> phaazon: it'd be tricky to keep rigor while interfacing to complex imperative systems.
13:56:56 <Klexos_> i didnt know other topics besides freenode werent allowed here in haskell
13:57:14 <conal> phaazon: not just for denotational design.
13:57:56 <phaazon> yeah, right
13:58:07 <phaazon> if I understand what you say in your paper, basically
13:58:30 <phaazon> pull -> reading the value, like reading a TVar 
13:58:42 <phaazon> push -> directly embedded in the ‚Äúevent trigger3
13:58:44 <phaazon> ‚Äù*
13:59:05 <phaazon> event-driven via callbacks is push, right?
13:59:05 <sydneyhacker> Question - is it possible to have a smart constructor (function to construct, don't export constructor) exported by one module and then pattern match the constructor in another module?
13:59:24 <phaazon> sydneyhacker: use two modules
13:59:37 <phaazon> an internal one you don‚Äôt export, and an ‚Äúinterface‚Äù one
13:59:42 * hackagebot chatter 0.5.0.2 - A library of simple NLP algorithms.  http://hackage.haskell.org/package/chatter-0.5.0.2 (RoganCreswick)
14:00:00 <merijn> sydneyhacker: If you're not afraid of extensions it is possible to have a constructor that is "match" only, so it doesn't break the smart constructor thing
14:00:29 <merijn> sydneyhacker: Recent GHC have PatternSynonyms, which let you define custom patterns, including "read-only" patterns
14:00:49 <sydneyhacker> phaazon: that is to protect other packages right? I want to protect myself from my own coding!
14:00:52 <merijn> So you could define a datatype, smart constructor and read only pattern synonym and then only export the patter synonym and smart constructor
14:01:06 <merijn> That way you can pattern match without being able to construct wrong values
14:01:31 <sydneyhacker> merijn - sounds perfect
14:01:33 <michaelt> oh I thought sydneyhacker wanted to use some of the 'real' constructors in the other module
14:02:06 <tomphreek> michaelt: interact is what I needed, thanks!
14:02:07 <michaelt> or maybe not, he just wants pattern match like behaviour?
14:02:08 <sydneyhacker> the other way I guess is to write accessor functions
14:02:11 <merijn> michaelt: You haven't ascended to #haskell levels of telepathically guessing people's intent yet ;)
14:02:19 <michaelt> merijn: maybe ..
14:02:37 <merijn> michaelt: He wants to pattern match in function definitions without being able to construct wrong values
14:02:44 <merijn> sydneyhacker: Also have a look at ViewPatterns
14:03:03 <michaelt> right, I think I see how that might be inferred. 
14:03:14 <Gurkenglas> Hackage is down?
14:03:16 <sydneyhacker> ok so the problem I am trying to solve - I have a 10 by 10 game. Valid moves are a pair of ints between 0 and 9. I have a method that will check your ints before constructing the move.
14:03:41 <mauke> Gurkenglas: doesn't seem like it
14:03:45 <sydneyhacker> In consuming code I want to get the x an y values out of a move. Or constuct a valid move.
14:04:07 <Gurkenglas> Maybe should have checked downlorjustme before coming here. Twas the download I had running taking all of the other bandwidth of the browser O_o
14:04:47 <phaazon> something that I don‚Äôt really like about your denotational semantics, conal, is the fact that you assume Time = Double
14:04:49 <phaazon> why?
14:04:56 <phaazon> the time could be a more complex value
14:05:03 <phaazon> like TimeSpec
14:05:04 <mauke> Time = Complex Double
14:05:04 <sydneyhacker> I think I am happy enought to have a function Move -> (Int, Int) to get them out and I see how beautiful or ugly that looks.
14:05:05 <phaazon> (from clock)
14:05:46 <conal> phaazon: for the most part, I only assume that Time is ordered. For integration & differentiation, we need a bit more.
14:06:11 <conal> phaazon: for simplicity, I say Time = R (reals, not double).
14:06:19 <phaazon> ok
14:06:30 <phaazon> that relaxes the implementation
14:06:36 <phaazon> thanks
14:06:58 <phaazon> hm
14:07:22 <lamefun> Is it OK to give up on trying to encode sanity guarantees in types and simply use smart constructors?
14:07:28 <phaazon> your liftN combinator looks like <*>
14:07:35 <merijn> lamefun: Sur
14:07:46 <merijn> lamefun: Why wouldn't it be?
14:07:49 <Klexos_> you can do better to execute a substraight of the compiler interface using basic syntax found in the original document. this will aggitate and force a some what of a 'push' thus executing with a seperate bug report style feedback in a seperate container leaving the code free to run undected and allowing deep penetration to pretty much anyone and everyone.
14:08:29 <phaazon> yeah, that‚Äôs right, lift1 = fmap
14:09:04 <lamefun> merijn, IDK... I thought it's a code smell in Haskell.
14:09:34 <Klexos_> woops. sorry. thought i was in a diff p.m.
14:09:37 <merijn> lamefun: Why? It's just plain old data hiding
14:11:15 <breadmonster> I was doing the usual `data N = Z | S N` thing yesterday.
14:11:17 <lamefun> merijn, Isn't Haskell all about math-strict level safety?
14:11:19 <hiptobecubic> lamefun, I think people usually *prefer* doing it in the types, philosophically. Other than that it's a pretty commonly used way to fake dependent-y types
14:11:34 <breadmonster> Implemented a function for rational approximations for Pi. 
14:11:50 <merijn> lamefun: Naah, if it was we'd have thrown out Turing completeness and gotten dependent types
14:11:52 <S11001001> @remember dolio Because of Go? They didn't do a very good job with that.
14:11:52 <lambdabot> Nice!
14:11:59 <Klexos_> pi is a myth
14:12:07 <merijn> lamefun: Haskell is in a sweet spot between "formal proofs" and "practical"
14:12:09 <conal> phaazon: yes, the liftN combinators are definable via Applicative, and the semantics is defined so that the applicative morphisms work out, i.e., meaning (pure a) == pure a, and meaning (fs <*> xs) == meaning fs <*> meaning xs .
14:12:33 <breadmonster> merijn: So dependently typed languages aren't Turing complete?
14:12:34 <Klexos_> they found a round 'magic' nu,ber that solves everything
14:12:38 <phaazon> conal: something I don‚Äôt get about events: if you represent them as a list of pairs, [(Time,a)], doesn‚Äôt that build huge thunks of memory? especially when merging events
14:13:05 <conal> merijn: I assume you mean the denotative subset of Haskell, i.e., not IO and friends.
14:13:53 <merijn> breadmonster: It depends
14:14:12 <merijn> breadmonster: You can do the same trick haskell uses for purity and IO for general recursion
14:14:23 <minozake> Is there a way to change what sort of quotes Haskell can use for a string so I don't have to keep escaping scads of double quotes?
14:14:43 <hiptobecubic> Not that I know of
14:14:44 <arkeet> there are some quasiquoter things for that.
14:14:48 <arkeet> but that's about it I think.
14:14:48 <breadmonster> minozake: Not in pure Haskell.
14:14:59 <merijn> breadmonster: i.e. force all computations to terminate in a fininite amount of steps, have a "GeneralRecursion" monad which within a finite number of steps returns either 1) a result or 2) a continuation, have the runtime repeatedly call the continuation until a result
14:15:21 <breadmonster> merijn: Is this what agda does?
14:15:37 <conal> phaazon: [(Time,a)] is a *denotation*, not an implementation. even if it were an implementation, the combinator implementations step through the structure, releasing old stuff. Just like a lot of uses of large/infinite lists that run in constant space.
14:15:41 <merijn> conal: Well, the fact that we have IO and friends is what puts is somewhere between practical and denotionally nice ;)
14:15:50 <merijn> breadmonster: Not sure, but it's one possible trick
14:16:03 <merijn> breadmonster: Also, Agda allows you to optionally turn off the termination checker, I believe
14:16:24 <minozake> Darn.  Thanks.
14:16:44 <merijn> breadmonster: It was intended as just an illustration of how you can avoid "but I want infinite loops!" in a strongly terminating setting
14:16:57 <hodapp> minozake: you can use TH to work around this a bit
14:17:25 <hodapp> minozake: example: http://techoverflow.net/blog/2014/07/28/using-quasiquotation-for-more-readable-atom-code/
14:17:49 <conal> merijn: i suspect that the IO habit is also what's kept us from finding a solution that's both practical *and* denotative.
14:18:37 <Klexos_> #android-dev
14:19:00 <breadmonster> Klexos_: What?
14:19:22 <_slade_> Is it possible to define an alias for a data constructor?
14:19:24 <merijn> conal: Oh, agreed, if someone evers pays me for it I will work on a denotational language that has proper builtin support for concurrency based around FRP ideas
14:19:51 <breadmonster> merijn: Why don't you pitch that idea to the usual FP funders?
14:19:54 <conal> merijn: :)
14:19:54 <srhb> _slade_: data Foo = Foo; bar = Foo
14:20:01 <phaazon> conal: hm, like Auto?
14:20:11 <phaazon> that‚Äôs the way I do implement my Behavior type
14:20:20 <phaazon> (and it‚Äôs also the way netwire does)
14:20:22 <merijn> breadmonster: I did
14:20:30 <conal> phaazon: Auto is inherently discrete, isn't it?
14:20:34 <merijn> breadmonster: None of the FP universities around here had any money
14:20:45 <breadmonster> There are FP universities there?
14:20:50 <phaazon> conal: yeah, it has to be stepped
14:20:51 <breadmonster> Interesting.
14:20:51 <merijn> (Around here being NL, UK and scandinavia)
14:21:02 <breadmonster> What are FP unis in the UK?
14:21:03 <albeit> Is there any way to make GHC busy wait for a specific STM variable?
14:21:16 <phaazon> newtype Auto t a = Auto { runAuto :: t -> (Maybe a,Auto t a) }
14:21:18 <merijn> breadmonster: Well, Utrecht is behind UHC, so they're doing lots of FP
14:21:26 <breadmonster> merijn: I was thinking of Jane Street/Galois/Ahrefs
14:21:29 <merijn> albeit: I don't think this question makes sense?
14:21:35 <merijn> breadmonster: There's no money in it
14:21:55 <merijn> See the "System's Research is Dead" essay
14:22:27 <albeit> merijn: As I understand it now threads have to be awoken when mutable variables they are waiting on are modified, instead of just constantly checking... is there a way to have them constantly check?
14:23:10 <arkeet> why is that desirable?
14:23:15 <merijn> albeit: I'm not sure what the point of "constantly checking" would be?
14:24:23 <phaazon> also, I don‚Äôt get the use of your capital letters, conal 
14:24:24 <merijn> Also, if you have high contention TVars are rather undesirable due to thundering herd issues
14:24:29 <phaazon> like Future a -> Fa
14:24:33 <phaazon> what is Fa?
14:24:40 <phaazon> type Fa = (T,a)
14:24:41 <albeit> merijn: For a bit of a speedup
14:24:46 <phaazon> a denotational type?
14:24:50 <merijn> albeit: That's only going to make things slower
14:25:04 <albeit> merijn: Even if theres an entire core dedicated to the busy wait?
14:25:17 <merijn> If you have only one core, why would busy-waiting help...
14:25:23 <merijn> waking a thread is really cheap...
14:26:05 <albeit> The idea is something is happening on another thread on another core, and this thread on its own core is waiting for that computation to finish. Waking a thread is cheap, but cheaper than busy waiting?
14:26:41 <conal> phaazon: it's just a type synonym, in this case for a type denotation
14:27:00 <ReinH> conal: hi!
14:27:09 <conal> ReinH: howdy!
14:27:12 <bitemyapp> ReinH: did you see the program for Lambda Jam?
14:27:21 <ReinH> bitemyapp: I didn't
14:27:24 <bitemyapp> oh bo
14:27:25 <bitemyapp> boy*
14:27:29 <bitemyapp> you're going to be excited I think
14:27:35 <bitemyapp> here: http://www.lambdajam.com/program/
14:27:37 <bitemyapp> look at the keynote :)
14:27:39 <albeit> I guess the right term is spinlock...
14:27:41 <phaazon> conal: right
14:27:43 <phaazon> so for instance
14:27:57 <phaazon> a Future is a couple of values
14:27:59 <phaazon> (Time,a)
14:28:05 <phaazon> but it hasn‚Äôt occured yet
14:28:12 <phaazon> so I guess I could encode that with Maybe (Time,a) ?
14:28:20 <ReinH> conal: nice!
14:29:06 <KaneTW> is there a difference in performance between foldMap and foldr for different data structures
14:29:09 <ReinH> conal: btw did you see my tweets about L-systems?
14:29:15 <conal> ReinH: are you going to be at BayHac this weekend?
14:29:19 <conal> ReinH: yeah. neat!
14:29:30 <ReinH> conal: I'm afraid not. I'm no longer working at the company in the bay.
14:29:41 <conal> ReinH: oh, yeah. sorry about that.
14:29:53 <ReinH> No worries! I really would have liked to go.
14:34:16 <host46> I always wonder why do I need paranthesis around a lambda even when it is at the end of an expression
14:34:16 <quchen> ReinH: You're not? :-(
14:34:22 <host46> like this:  (flip map) [1, 2, 3] \x -> x+1
14:34:32 <host46> <interactive>:5:22: parse error on input ‚Äò\‚Äô
14:34:46 <srhb> host46: Where does the function stop?
14:34:48 <Gurkenglas> https://hackage.haskell.org/package/JuicyPixels-3.1.7.1/docs/Codec-Picture.html#t:DynamicImage <- Can I output which of these constructors an image I loaded is using without doing a 13-line patternmatch?
14:34:53 <srhb> Is it \x -> x ?
14:35:00 <ReinH> quchen: nope
14:35:03 <oconnore> Why doesn't monoid have a "pure" / "singleton" / "return" function?
14:35:19 <ReinH> oconnore: why should it?
14:35:35 <KaneTW> how would you define it
14:35:36 <nolraiU> @pl \x y -> g (f x y)
14:35:37 <lambdabot> (g .) . f
14:35:44 <ReinH> And, in point of fact, how could it?
14:36:17 <ReinH> host46: because a special case isn't made in the syntax
14:36:40 <Luke> https://github.com/haskell/cabal/issues/2653
14:36:40 <KaneTW> @src Monoid
14:36:40 <lambdabot> class Monoid a where
14:36:41 <lambdabot>     mempty  :: a
14:36:41 <lambdabot>     mappend :: a -> a -> a
14:36:41 <lambdabot>     mconcat :: [a] -> a
14:36:58 <host46> ReinH: oook, thanks :)
14:37:06 <KaneTW> what would the type of msingleton or whatever be?
14:37:12 <ew0> hellow
14:37:20 <ew0> how can I improve this?
14:38:49 <merijn> oconnore: Because pure/return only makes sense for a type of kind "* -> *" and Monoids are types of kind *
14:39:08 <ReinH> conal: I think that you can describe non-deterministic L-systems by composing the monad with another functor, so you have morphisms A -> MF(A), which makes the Kleisli arrows F-coalgebras. 
14:39:29 <oconnore> KaneTW: something like mpure :: b -> a
14:39:29 <Gurkenglas> Can I give ghci more horizontal space to work with?
14:39:34 <conal> ReinH: yeah. nice idea.
14:39:41 <ReinH> oconnore: so a function that can't exist? :)
14:39:42 <merijn> oconnore: What would that do?
14:39:45 <hiptobecubic> Gurkenglas, whta does that mean?
14:39:51 <merijn> ReinH: Sure it can, it's a monoid
14:39:56 <merijn> ReinH: That's just "const mempty"
14:40:04 <oconnore> merijn: could you define a monoid of * -> *, where it's parameterized on the container and the things in the container?
14:40:05 <ReinH> merijn: oh right
14:40:09 <Gurkenglas> hiptobecubic, The error output has its lines broken up. I'd rather the window take up more of the screen.
14:40:26 <hiptobecubic> Gurkenglas, can you not just make the window larger? This isn't really related to ghci at all.
14:40:27 <merijn> oconnore: Monoid of kind "* -> *" would be MonadPlus and/or Alternative :)
14:40:30 <ReinH> oconnore: well, you can define such a thing, but that thing isn't Monoid
14:40:31 <merijn> @src MonadPlus
14:40:32 <lambdabot> Source not found. Take a stress pill and think things over.
14:40:36 <merijn> :t mplus
14:40:39 <lambdabot> MonadPlus m => m a -> m a -> m a
14:40:40 <merijn> :t mzero
14:40:42 <lambdabot> MonadPlus m => m a
14:40:53 <merijn> oconnore: And then you can just use "return" as return
14:40:56 <quchen> ?src Alternative
14:40:56 <lambdabot> class Applicative f => Alternative f where
14:40:56 <lambdabot>     empty :: f a
14:40:56 <lambdabot>     (<|>) :: f a -> f a -> f a
14:41:14 <ew0> http://pastie.org/10234512
14:41:20 <Gurkenglas> hiptobecubic, ghci.exe has a window that I can resize like a normal window, except it hits a limit in its width.
14:41:21 <ew0> how can I improve this?
14:42:06 <ew0> my function collor returns a ([a], r) where the length of [a] is preferably 0
14:42:10 <ew0> color*
14:42:36 <merijn> > mplus [1,2,3] [4,5,6]
14:42:39 <hiptobecubic> Gurkenglas, ah. This is because the default console in windows is miserable. You can try using powershell perhaps?
14:42:39 <lambdabot>  [1,2,3,4,5,6]
14:42:44 <merijn> > mappend [1,2,3] [4,5,6]
14:42:48 <lambdabot>  [1,2,3,4,5,6]
14:43:02 <ReinH> ew0: what do the functions do?
14:43:13 <merijn> oconnore: So if you want a mix of Monad and Monoid, then MonadPlus is almost certainly what you were looking for :)
14:43:19 <michaelt> ew0: if it is what you intend, it is beautiful
14:43:43 <ReinH> it is? despite the bug?
14:43:49 <michaelt> ew0: well, I don't know about that use of head.
14:44:08 <ReinH> also, is sortOn productive?
14:44:10 <oconnore> merijn: aha! cool
14:44:11 <ReinH> it could be
14:44:20 <oconnore> > mzero `mplus` return 45 `mplus` return 3 :: [Int]
14:44:23 <lambdabot>  [45,3]
14:44:52 <merijn> Laws are in the docs of MonadPlus
14:45:31 <ReinH> conal: The deterministic ones are precisely those where F = 1, of course ;)
14:47:03 <oconnore> merijn: is it better to prefer Alternative or MonadPlus?
14:47:13 <oconnore> or no preference
14:47:21 <KaneTW> @src Alternative
14:47:21 <lambdabot> class Applicative f => Alternative f where
14:47:21 <lambdabot>     empty :: f a
14:47:21 <lambdabot>     (<|>) :: f a -> f a -> f a
14:47:30 <bitemyapp> oconnore: http://stackoverflow.com/a/10168111
14:47:46 <merijn> oconnore: Same argument as Applicative vs Monad
14:48:14 <merijn> Actually, slightly less so, because I don't think MonadPlus can do anything Alternative can't?
14:48:45 <merijn> Ah, no it isn't
14:48:47 <dolio> The only thing MonadPlus does is conceal a Monad constraint if you have one.
14:48:50 <michaelt> aren't they supposed to agree 
14:51:00 <merijn> michaelt: Yes, but as edwardk points on in that SO answer there's additional laws on mplus
14:51:56 <oconnore> merijn: ah, in 7.10 MonadPlus is Alternative
14:52:01 <oconnore> thanks bitemyapp 
14:52:37 <bitemyapp> oconnore: :)
14:52:43 <michaelt> merijn: yes, of course. 
14:54:27 <KaneTW> finger trees support O(n) fold/map, right?
14:54:41 <KaneTW> actually i only care about fold
14:55:07 <KaneTW> split in O(log n) and then folding over the resulting tree
14:55:30 <michaelt> folding would surely need to inspect each element ...
14:55:35 <lamefun> Is it OK to have redundant information not to write too much code? Eg. PkgId = PkgId Name Version Hash ; Data.Map Name PkgId instead of  PkgIdCore = PkgIdCore Version Hash ; PkgId = PkgId Name PkgIdCore ; Data.Map Name PkgIdCore?
14:55:36 <michaelt> or am I wrong?
14:55:53 <KaneTW> that's why it's O(n)
14:56:08 <arkeet> it would be strange to see a data structure that had fold/map being not Œò(n)
14:56:30 <KaneTW> i guess, yeah
14:56:32 <michaelt> as the structures get bigger, you fold over fewer of them
14:56:57 <KaneTW> for some reason i thought my fold needed to be in order but it doesn't
14:57:35 <KaneTW> basically i need to partition a tree into elements between two values and then fold over it to get sum and max
14:58:05 <arkeet> why do you need to partition anything into anything to get sum and max?
14:58:31 <KaneTW> it's a potentially large dataset and i only need sum/max in a specific interval
14:58:34 <michaelt> KaneTW: there may be a specialize fold that would be faster if order is irrelevant
14:58:36 <arkeet> ic
14:58:50 <michaelt> KaneTW: specialized, rather
14:59:44 <KaneTW> i'll just do a simple implementation first and optimize later
15:01:13 <Luke> byorgey: you have any ideas here: https://github.com/haskell/cabal/issues/2653 ?
15:03:13 <michaelt> KaneTW: Oh I see the foldable instance defines foldMap, not foldr or the like; it's probably better to use it than foldr f z t = appEndo (foldMap (Endo . f) t) z
15:03:58 <KaneTW> probably, yeah
15:04:52 <Gurkenglas> What's the proper way to compose "permutations" of the form [[(Int, Int)]]?
15:05:31 <Gurkenglas> (More like endofunctions.)
15:05:53 <t7> :t permutations
15:05:56 <lambdabot> [a] -> [[a]]
15:06:31 <KaneTW> why the [[]]
15:06:57 <Gurkenglas> > permutations "abc" -- Because
15:07:06 <lambdabot>  ["abc","bac","cba","bca","cab","acb"]
15:09:06 <c_wraith> KaneTW: permutations produces a list of lists
15:09:12 <c_wraith> > permutations [1..3]
15:09:17 <lambdabot>  [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
15:09:58 <t7> > permutations ["love", "I", "you"]
15:10:02 <lambdabot>  [["love","I","you"],["I","love","you"],["you","I","love"],["I","you","love"]...
15:10:38 <Gurkenglas> I should probably add that the [[(Int, Int)]] are large and so by "properly" I also mean "in a polynomial time of degree no higher than necessary"
15:10:52 <t7> > permutations $ words "game of thrones"
15:10:58 <lambdabot>  mueval-core: Time limit exceeded
15:11:07 <c_wraith> Gurkenglas: so..  the lists are index permutation maps?
15:11:24 <Gurkenglas> Yep. Though there is no gurantee of injectivity.
15:11:50 <KaneTW> what do you mean by composing then? i can imagine composition on [(Int,Int)] by something like compose a b = map (\(x,y) -> case lookup y a of Nothing -> (x,y); Just y' -> (x,y')) b
15:11:53 <c_wraith> doesn't the "standard" formulation of that make one of the indices implicit?
15:12:27 <KaneTW> that's pretty slow though
15:12:29 <Gurkenglas> Umm the two ints are the two coordinates of the position in the 2dimensional array that is pointed to
15:13:32 <Gurkenglas> I guess I could use the bijection between [[(Int, Int)]] and [Int] to translate the problem to that
15:13:41 <KaneTW> you can probably get O(n log n) out of that by using a BST or O(n) when you can guarantee injectivity for both permutations
15:14:08 <c_wraith> Gurkenglas: if you want any sort of efficiency out of this, nested lists are not the data representation of choice.
15:14:30 <Gurkenglas> Okay, so I'll use Data.Map.Strict to convert the second endofunction into something with nearly random access?
15:14:45 * hackagebot TestExplode 0.1.0.0 - Generates testcases from program-snippets  http://hackage.haskell.org/package/TestExplode-0.1.0.0 (hjg)
15:15:01 <c_wraith> Why not Data.Array or something?
15:15:03 <Gurkenglas> (Cause that was my plan but I thought maybe there's a better way)
15:15:30 <Gurkenglas> I guess I should learn that array stuff at some point.
15:16:02 <Gurkenglas> Ew, I'd have to use two nested arrays
15:16:05 <KaneTW> does data.array give O(log n) search?
15:16:15 <KaneTW> s/search/lookup/
15:16:36 <Gurkenglas> Why not O(1)? If its O(log n) I might as well use Data.Map right?
15:18:02 <c_wraith> Data.Array gives O(1) indexing
15:18:04 <dmj`> array is O(1)
15:18:16 <KaneTW> O(1) indexing but not search
15:18:32 <c_wraith> Which is all you need to compose permuations in O(total size of the array) time
15:19:21 <KaneTW> i guess it depends on the size
15:19:45 <KaneTW> if the array is small it's fine
15:19:51 <Gurkenglas> https://hackage.haskell.org/package/base-4.7.0.0/docs/src/GHC-Arr.html#rangeSize <- Where'd the newlines go? o.o
15:19:51 <c_wraith> ...  what?
15:20:04 <c_wraith> KaneTW: there's no searching in composing permutations
15:20:14 <KaneTW> if they're injective, yeah
15:20:15 <c_wraith> KaneTW: it's exactly the same algorithm as applying a permutation
15:21:15 <c_wraith> Gurkenglas: you would want a function like...  permute :: Ix i => Array i i -> Array i e -> Array i e
15:21:27 <KaneTW> oh that's what he wants
15:21:29 <c_wraith> Gurkenglas: and that magically also composes permutations
15:21:30 <Gurkenglas> Yep
15:21:45 <KaneTW> yeah
15:21:48 <KaneTW> that works fine then
15:21:50 <Gurkenglas> :t (.) --Though that function sounds flipped when you look at
15:21:53 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:22:02 <KaneTW> blame math
15:22:13 <c_wraith> I suppose you could flip the arguments for consistency with (.), sure
15:22:16 <arkeet> it's only flipped because function application is flipped.
15:22:44 <arkeet> am I missing some context.
15:22:56 <Gurkenglas> Surely if math did it the other way there'd be an edge case where we'd wish it was flipped...
15:22:58 <c_wraith> arkeet: the signature I proposed a few lines up
15:23:01 <arkeet> yeah okay.
15:23:29 <c_wraith> You can sort of treat Array i e as a partial function i -> e
15:23:36 <arkeet> yeah.
15:24:12 <Gurkenglas> Does "instance (Ix a, Ix b) => Ix (a, b)" make rectangles or what I do when I select text across multiple lines?
15:24:20 <arkeet> Gurkenglas: I've seen some math texts or whatever write function application like (x)f. it looks *weird*.
15:24:25 <c_wraith> Gurkenglas: rectangles
15:24:26 <arkeet> rectangles.
15:24:41 <Gurkenglas> Yay for sanity
15:24:58 <c_wraith> :t range
15:24:59 <byorgey> Luke: did you mean to ask me?  Just curious why you think I might have any ideas on that  (the answer, unfortunately, is "not a clue")
15:25:01 <lambdabot> Ix a => (a, a) -> [a]
15:25:15 <Luke> byorgey: just saw you had committed recently. that's all
15:25:18 <c_wraith> > range ((2,2),(4,4)
15:25:21 <lambdabot>  <hint>:1:19:
15:25:21 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
15:25:24 <c_wraith> > range ((2,2),(4,4))
15:25:29 <Luke> byorgey: didn't know how involved you are w/ the project in general
15:25:30 <lambdabot>  [(2,2),(2,3),(2,4),(3,2),(3,3),(3,4),(4,2),(4,3),(4,4)]
15:25:40 <c_wraith> Gurkenglas: ^ see?  nicely rectangular
15:25:40 <byorgey> Luke: ah, fair enough.
15:26:05 <byorgey> Luke: I wrote & continue to maintain the 'cabal init' subcommand, and have made a few other minor contributions
15:26:12 <Luke> ah gotcha
15:26:21 <byorgey> Luke: I don't really know much beyond that
15:26:23 <KaneTW> c_wraith: wouldn't permute error when you have something like [(5,1)] in the first argument but only [(1,"a")] in the second?
15:26:29 <Luke> byorgey: ok thanks a lot
15:26:46 <byorgey> Luke: sure.  Hope you get it figured out!
15:26:54 <Luke> heh me too =)
15:26:54 <c_wraith> KaneTW: yes.  It depends on the first argument actually being a valid permutation.  Or at least not going out of bounds.
15:27:30 <arkeet> :t permute
15:27:31 <byorgey> Luke: solution:  "sudo chmod 777 `which ar`"
15:27:33 <lambdabot> Not in scope: ‚Äòpermute‚Äô
15:27:38 <byorgey> ;-)
15:27:53 <c_wraith> arkeet: doesn't exist yet.  though repa has backpermute to go the other direction! :)
15:28:08 <KaneTW> yeah that's why i mentioned search, since i didn't know what to expect of the two lists
15:28:15 <Luke> byorgey: I think it's actually a permission problem w/ the file that ar is being run on. but that gave me an idea: replace it w/ a shell script that outputs the args
15:28:17 <arkeet> well, we can map over an array
15:28:19 <arkeet> which is just as good
15:30:18 <KaneTW> if you can guarantee injectivity for the second argument it's fine
15:30:33 <KaneTW> as long as the first doesn't go out of bounds
15:31:51 <schoppenhauer> hm. is there some (possibly unsafe) way to determine the type of something at runtime?
15:32:04 <schoppenhauer> *without* it having to be in Typeable
15:32:07 <arkeet> nope
15:32:28 <schoppenhauer> or at least a possibility to declare that every type I talk about should be in Typeable?
15:32:28 <arkeet> types don't exist at runtime.
15:32:50 <KaneTW> you can always do a constraint
15:33:03 <schoppenhauer> KaneTW: whats a constraint?
15:33:05 <c_wraith> At runtime, all you can tell even in unsafe ways is what its data representation looks like.
15:33:15 <monochrom> add "Typeable a" to everything to declare that every type you talk about is in Tyepable
15:33:16 <KaneTW> Typeable a =>
15:33:24 <schoppenhauer> meh.
15:33:26 <c_wraith> And there are only about 5 different data representations for things GHC creates
15:33:54 <arkeet> well, we have AutoDeriveTypeable now.
15:34:17 <schoppenhauer> arkeet: but AutoDeriveTypeable just derives Typeable for every new object, right?
15:34:23 <arkeet> no
15:34:31 <arkeet> it comes up with Typeable instances on the spot where you use them.
15:34:34 <monochrom> what is "object"?
15:36:36 <KaneTW> huh
15:36:44 <KaneTW> i can't find docs on AutoDeriveTypeable
15:37:11 <monochrom> ghc 7.8 user's guide section 7.5.4
15:38:11 <arkeet> funny, I don't see it in the 7.10.1 user's guide
15:38:39 <KaneTW> yeah
15:38:44 <KaneTW> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/deriving.html#deriving-typeable mentions nothing about it
15:38:53 <KaneTW> but it does in 7.8.4
15:38:53 <geekosaur> it's gone
15:38:54 <arkeet> but it's definitely there in 7.8 docs
15:38:58 <KaneTW> https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/deriving.html#auto-derive-typeable
15:39:02 <geekosaur> because 7.10 *always* derives Typeable IIRC
15:39:15 <arkeet> ok.
15:39:18 <KaneTW> oh
15:39:37 <geekosaur> my recollection is they found that was necessary to avoid some derive-unsafeCoerce problems
15:39:57 <schoppenhauer> arkeet: it just derives Typeable for every new datatype
15:40:02 <schoppenhauer> arkeet: not what I want
15:40:06 <arkeet> what do you want?
15:40:12 <schoppenhauer> well, it *is* what I want
15:40:14 <KaneTW> didn't that happen with the implemntation of representational equality?
15:40:19 <KaneTW> :t coerce
15:40:22 <lambdabot> (Functor f, Contravariant f) => f a -> f b
15:40:23 <KaneTW> not this one
15:40:34 <geekosaur> that solved one problem, but there were others
15:40:55 <arkeet> schoppenhauer: ??
15:40:59 <crymore> so schoppenhour the first emo
15:41:01 <crymore> or what?
15:41:22 <geekosaur> I am trying to remember if this was related to the issue where different kinds were not distinguished properly and could be used to confuse the typechecker
15:41:27 <geekosaur> (or something like that)
15:41:37 <schoppenhauer> arkeet: partially. when having a type T a, I still have to write to every funtion bla :: Typeable a => a -> T a
15:41:42 <arkeet> yes.
15:41:47 <monochrom> he wants the equivalent of: consider Java, in which every type has the "equals" method, there is no escape. in Haskell speak, every type is in Eq, and most importantly, you never have to add the "Eq a" constraint when you use it.
15:41:59 <arkeet> and you have to, because otherwise type information is erased during compilation.
15:42:13 <schoppenhauer> well, can I switch that off?
15:42:16 <arkeet> again, types don't exist at runtime.
15:42:19 <arkeet> no.
15:42:24 <schoppenhauer> why not?
15:42:39 <monochrom> because the Haskell committee chooses it
15:42:47 <schoppenhauer> but there is Typeable
15:42:55 <monochrom> yes, there is also Eq
15:42:56 <geekosaur> because typeclass dictionaries are the only mechanism provided to retain runtime type information
15:43:21 <geekosaur> and that means declaring typeclass constraints in order for those dictionaries to be generated and passed
15:43:36 <geekosaur> haskell is not java, values do not have type information *always* hanging off of them
15:43:46 <schoppenhauer> geekosaur: but why is there no possibility to declare that all functions in a namespace only take Typeable arguments?
15:43:48 <Iceland_jack> schoppenhauer: It's the right thing to do, there is a difference between "a -> a" and "Typeable a => a -> a" even though every 'a' has a Typeable instance
15:43:49 <arkeet> there are some moral reason for it to. if everything kept type information at runtime, we'd lose parametricity.
15:43:58 <geekosaur> this is not a "can I switch X off", you want "can I arrange for values to be represented completely differently so they have type information?"
15:44:23 <schoppenhauer> Iceland_jack: I dont care about what is 'right'. I have a concrete problem which I want to solve.
15:44:31 <schoppenhauer> Iceland_jack: I would even use hacks for it.
15:44:42 <Iceland_jack> Okay
15:44:46 <arkeet> what's wrong with putting Typeable constraints?
15:45:00 <schoppenhauer> arkeet: did you read my original question?
15:45:08 <monochrom> you can always modify GHC source code to support what you want.
15:45:09 <schoppenhauer> arkeet: if not: I have a lot of autogenerated code.
15:45:19 <geekosaur> (my explanation is not ":here's why what you want is somehow Wrong", it is "why what you want is not a matter of flipping a switch")
15:45:26 <Gurkenglas> Num, y u no instance (Num a, Num b) => Num (a, b)
15:45:32 <schoppenhauer> monochrom: yes. if I had years.
15:45:38 <arkeet> Gurkenglas: there's a NumInstances module for that.
15:46:04 <schoppenhauer> monochrom: I have autogenerated code. and it is not trivial to add Typeable to everything.
15:46:06 <Gurkenglas> Thanks.
15:46:09 <arkeet> < schoppenhauer> hm. is there some (possibly unsafe) way to determine the type of something at runtime?
15:46:12 <arkeet> this is the first question I saw.
15:46:13 <monochrom> are you doing this for money?
15:46:18 <arkeet> and the answer is no, without Typeable.
15:46:48 <schoppenhauer> monochrom: partially.
15:46:56 <schoppenhauer> monochrom: does that matter?
15:47:00 <srhb> You can make everything monomorphic! Then determining what type something had at compile time becomes trivial. :-)
15:47:11 <monochrom> yes. then you should pay partial money to whoever gets your wish done
15:47:32 <schoppenhauer> *ignores monochrom*
15:47:56 <KaneTW> lol
15:48:09 <schoppenhauer> the _original_ thing I wanted were type specializations. but they were apparently removed from GHC, as I rea.d
15:48:41 <schoppenhauer> and my rewrite rules were *never* applied, even with the highest optimization settings...
15:49:32 <KaneTW> did you debug that with compiler flags
15:49:38 <KaneTW> they should fire
15:50:02 <KaneTW> whenever the types match that is
15:50:13 <schoppenhauer> well, apparently, I would have to define specializers for every function, recursively.
15:50:36 <schoppenhauer> that is why I decided that for my current problem, RTTI would be sufficient.
15:50:36 <arkeet> sounds about right.
15:50:52 <arkeet> well, if you want RTTI, use Typeable.
15:51:06 <phaazon> ok, I got lost conal 
15:51:09 <schoppenhauer> that is, as I said, impossible.
15:51:13 <phaazon> Reactive, Behavior
15:51:19 <phaazon> what is the difference between them?
15:51:40 <ew0> michaelt, my question was about sortOn
15:51:50 <ion> phaazon: I haven‚Äôt read the discussion, but FRP usually involves two fundamental types which are Event and Behavior.
15:51:55 <ew0> is it efficient? will it evaluate all the permutations?
15:52:03 <ew0> (talking about this: http://pastie.org/10234512)
15:52:27 <geekosaur> schoppenhauer, since what I said didn't make the point, let me be more explicit
15:52:28 <phaazon> ion: I‚Äôm trying to implement FRP by followig conal‚Äôs push-pull FRP
15:52:28 <ion> phaazon: Out of which Events only have a value when they fire, Behaviors don‚Äôt fire but have a value you can sample at any time.
15:52:34 <geekosaur> to get what you want is not "flip a switch"
15:52:35 <arkeet> schoppenhauer: sometimes the precise thing you want doesn't exist.
15:52:37 <phaazon> typically
15:52:45 <geekosaur> to get what you want is rewriting the whole compiler and runtime
15:52:46 <arkeet> and you just have to deal with it.
15:53:00 <phaazon> Reactive = a `Stepper` Event a
15:53:12 <phaazon> Event a = Event (Future (Reactive a))
15:53:25 <phaazon> now I don‚Äôt see the point of Behavior here
15:53:50 <KaneTW> schoppenhauer: if you have autogenerated code, why can't you just tell it to derive Typeable? i might have missed something here
15:53:55 <schoppenhauer> arkeet: I am trying. that is why I was explicitly asking for unsafe ways.
15:54:11 <schoppenhauer> KaneTW: too much detail ...
15:54:26 <geekosaur> there is no "unsafe" way, because the information *is* *not* *there*
15:54:29 <geekosaur> it is not hidden
15:54:32 <geekosaur> it is nonexistent
15:54:36 <schoppenhauer> anyway. thx for your suggestions.
15:55:18 <Gurkenglas> http://lpaste.net/134302 *faints in delight when remembering trying to do this in matlab*
15:55:56 <geekosaur> maybe someone could use the new typechecker plugin interface to attach a constraint to every type; that would require ghc 7.10.1 (or more likely HEAD because the interface is still evolving) and even then might still not be up to such a use
15:56:19 <geekosaur> and you'd have to write the plugin
15:56:57 <twanvl> Or just delete all type signatures, and let type inference figure it out
15:57:00 <Gurkenglas> (Oh hey, that first compo...nent (Huh!) can be "uncurry (PixelRGB8 0)".)
15:57:02 <ion> Gurkenglas: nice
15:57:51 <geekosaur> (hm, and it's not a ssimple as attach to every type, youd want to attach it to the type of specific bindings. and it might be tricky to get that right)
15:58:21 <yac> what does the co- mean in comonad?
15:58:33 <Gurkenglas> (Aaaalso I'm missing a . replicate (length maps) there at the end I guess.)
15:58:38 <KaneTW> opposite, roughly
15:58:46 <KaneTW> dual, opposite, stuff like that
15:58:50 <arkeet> the same thing it means in a lot of category theory related things.
15:58:56 <arkeet> http://en.wikipedia.org/wiki/Dual_%28category_theory%29
15:59:06 <ion> Gurkenglas: What kind of CV are you using Haskell for?
15:59:16 <arkeet> comonad is the dual of monad.
15:59:21 <Gurkenglas> "CV"?
15:59:28 <ion> Gurkenglas: computer vision
15:59:29 <KaneTW> computer vision i think
15:59:32 <arkeet> to obtain the definition of comonad, take the definition of monad, and reverse all arrows.
15:59:48 * hackagebot pandoc-citeproc 0.7.2 - Supports using pandoc with citeproc  http://hackage.haskell.org/package/pandoc-citeproc-0.7.2 (JohnMacFarlane)
15:59:58 <Iceland_jack> yac: Simple answer, it reverses the arrow. Monad has:
15:59:58 <Iceland_jack>     return  :: a -> M a
15:59:58 <Iceland_jack> Comonad has
15:59:58 <Iceland_jack>     extract :: W a -> a
16:00:03 <KaneTW> A -> B would be A <- B
16:00:10 <KaneTW> yup
16:00:20 <Gurkenglas> My task is to stitch registrations between depth and color images. (The depth and color images are already stitched, and I am told how.)
16:00:41 <Gurkenglas> Everything is .tiffs coming from the Kinect
16:00:45 <Iceland_jack> Monad has:       join   :: M (M a) -> M a
16:00:45 <Iceland_jack> Comonad has:  duplicate :: W a     -> W (W a)
16:00:57 <arkeet> well, sometimes you have to be careful about what arrows to reverse.
16:01:02 <Iceland_jack> Yes
16:01:06 <Gurkenglas> If that didn't answer the question, specify :D
16:01:09 <arkeet> because
16:01:12 <arkeet> :t (=<<)
16:01:14 <Iceland_jack> An example of that is bind
16:01:18 <lambdabot> Monad m => (a -> m b) -> m a -> m b
16:01:28 <KaneTW> Monad has bind :: m a -> (a -> m b) -> m b, Comonad has extend :: (w a -> b) -> w a -> w b
16:01:33 <Gurkenglas> That reminds me, how do you determine what arrows to reverse when you're trying to find the dual of something?
16:01:50 <arkeet> Gurkenglas: look at the right definition.
16:02:16 <KaneTW> all of them :v
16:02:21 <arkeet> no.
16:02:50 <arkeet> bind doesn't really work in monads in general.
16:02:59 <arkeet> (outside haskell)
16:03:03 <KaneTW> outside haskell, yeah
16:03:06 <Gurkenglas> How do I find the right definition when all I have is a vague intuition?
16:03:09 <KaneTW> but haskell's Monad/Comonad has it
16:03:23 <arkeet> Gurkenglas: sometimes it's not obvious.
16:04:02 <arkeet> KaneTW: but the return/join definition makes it much more obvious how it should be dualized.
16:04:10 <KaneTW> yeah, definitely
16:04:16 <Gurkenglas> (Specifically, I'm thinking about how the (Reader a) monad can be used to implement the instance system for a class that requires you to define an a for each instance)
16:04:39 <Gurkenglas> (And what arrows one might reverse to get the dual to "instance")
16:04:56 <conal> phaazon: was afk. were you asking about programming API & semantics or implementation?
16:05:45 <arkeet> it's easy to get confused in haskell because
16:06:00 <arkeet> when you see a function arrow, should it be treated as a mapping, or as an arrow in Hask?
16:07:37 <arkeet> so if you have some concept in haskell that you want to dualize or whatever, it can help clarify things to think about it in a more general setting
16:07:59 <arkeet> I mean in categories in general, not just Hask.
16:08:26 <arkeet> I don't really know what a lens is.
16:10:51 <Gurkenglas> I was thinking of it more categorically before realizing what I thought is captured by the Reader monad. An instance is a functor from a Kleisli category to its underlying category with object function id.
16:11:11 <Gurkenglas> What's the dual of that?
16:20:21 <funfunctor> Hi
16:20:34 <funfunctor> Is there a monadic version of take ?
16:20:39 <funfunctor> @hoogle takeM
16:20:40 <lambdabot> Control.Concurrent.MVar takeMVar :: MVar a -> IO a
16:20:40 <lambdabot> Control.Concurrent.MVar tryTakeMVar :: MVar a -> IO (Maybe a)
16:20:52 <hpc> what type are you expecting?
16:21:13 <funfunctor> something like :: Int -> m a -> m [a]
16:21:29 <Iceland_jack> funfunctor:
16:21:29 <Iceland_jack> :t fmap . take 
16:21:32 <lambdabot> Functor f => Int -> f [a] -> f [a]
16:22:05 <funfunctor> I want to do bytes <- takeM n recvByte
16:22:33 <funfunctor> return $ BS.pack bytes
16:22:40 <funfunctor> if you get the idea?
16:23:06 <johnw> :t replicateM
16:23:08 <lambdabot> Monad m => Int -> m a -> m [a]
16:23:42 <monochrom> yeah, that's more replicateM than take_whatever
16:24:02 <johnw> depends on what the action is doing 
16:24:12 <johnw> replicateM 5 getChar will get you 5 chars
16:24:33 <funfunctor> ah replicateM yea ok
16:24:36 <funfunctor> :t replicateM
16:24:38 <lambdabot> Monad m => Int -> m a -> m [a]
16:24:55 <funfunctor> ah that's it, great thanks johnw !
16:25:24 <funfunctor> I don't you how you guys do it, remembering all these type-signatures
16:26:36 <gfixler> funfunctor: I use the repl
16:26:46 <phaazon> conal: both
16:26:50 <phaazon> but semantics is more important
16:26:57 <johnw> I don't remember the signature, I remember what it does, and that I've used it to do just that many times
16:27:05 <phaazon> frameworks tend to mix Behaviors and Reactives
16:27:07 <conal> For the semantics, Reactive doesn't appear.
16:27:14 <phaazon> as they‚Äôre the same thing
16:27:32 <conal> phaazon: frameworks?
16:27:39 <phaazon> yeah
16:27:43 <phaazon> reactive-banana
16:27:45 <phaazon> sodium
16:27:47 <phaazon> and so on
16:28:01 <phaazon> so I¬†feel a bit lost
16:28:07 <phaazon> what is a Reactive then?
16:28:12 <phaazon> is it just an implementation detail?
16:28:24 <conal> phaazon: are you trying to understand all systems that call themselves "FRP"?
16:28:37 <phaazon> no, I try to understand the essence of FRP
16:28:40 <phaazon> i.e. your paper
16:29:58 <conal> phaazon: oh, okay. Reactive is "just" an implementation detail, but a fairly important one if you're trying to understand the implementation. for the semantics, it's a non-issue. i introduced it in exploring efficient implementation for what i called "reactive normal form".
16:30:15 <phaazon> yeah
16:30:22 <conal> phaazon: have you watched the push-pull video from icfp 2009?
16:30:22 <phaazon> the a `Stepper` e, right?
16:30:35 <phaazon> conal: I don‚Äôt think so
16:30:46 <conal> phaazon: it might help.
16:31:06 <phaazon> on vimeo?
16:31:15 <conal> phaazon: http://conal.net/papers/push-pull-frp/
16:31:33 <conal> phaazon: ... which has links to the paper, video, and slides
16:31:59 <phaazon> yes
16:32:01 <phaazon> I‚Äôm watching it
16:32:16 <gfixler> I've been thinking of FRP as a few steps back from a recording of an interaction with a program
16:32:29 <phaazon> where do you live, conal?
16:32:44 <phaazon> as a French, I find you‚Äôre English accent interesting
16:32:49 <phaazon> not the regular american one
16:32:51 <phaazon> looks like british
16:32:53 <conal> phaazon: in the sierra nevada foothills in central/northern california.
16:32:54 <phaazon> :)
16:32:59 <phaazon> ah, ok
16:33:01 <phaazon> curious then
16:33:21 <gfixler> a gameplay video is deterministic; it plays the same every time
16:33:25 <phaazon> gfixler: I¬†think FRP is pretty great, but we lack a LOT of resources about that
16:33:39 <gfixler> if I also recorded my inputs, I could use them to play the game 'live' again, exactly the same way
16:33:42 <phaazon> especially vulgarisation
16:33:42 <conal> phaazon: hm. i don't recall anyone mentioning my accent before.
16:33:43 <gfixler> so it's pure data
16:34:02 <gfixler> FRP to me is a step back from that, allowing the user to create that data live
16:34:49 <conal> wow. i still have & wear that yellow shirt.
16:35:41 <phaazon> the part about improving values is hm
16:35:44 <phaazon> overwhelming
16:35:48 <phaazon> I really don‚Äôt get it ahah
16:36:03 <conal> phaazon: yep. that's the trickiest bit.
16:37:17 <gfixler> the function-of-time thing is a bit confusing for me when events come into play
16:37:30 <tejing> is there a way to define a function in haskell that can be pattern matched as if it were a constructor, but isn't a constructor? (basically a constructor alias)
16:38:07 <conal> gfixler: the 'switcher' construct splices function segments.
16:38:09 <phaazon> tejing: maybe with pattern
16:38:57 <gfixler> conal: what's the best source currently for understanding this stuff?
16:39:14 <gfixler> there's a lot of info all over, and you mentioned in your haskellcast that most get it wrong
16:39:15 <conal> gfixler: where the "suffix" behaviors are generated by occurrences of a behavior-valued event.
16:39:40 <gfixler> conal: that sounds sort of along the lines of what I've been thinking, but I'd have to read up more
16:39:47 <conal> gfixler: yes, most so-called "FRP" systems lack both of (the original) FRP's fundamental properties.
16:39:54 <ClaudiusMaximus> tejing: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#pattern-synonyms
16:40:17 <gfixler> conal: I'm a from-first-principles sort, so it's always important to me to get it all correct :)
16:41:23 <conal> gfixler: glad to hear. i suggest http://conal.net/papers/icfp97/ and http://conal.net/papers/push-pull-frp . there's an earlier paper (http://conal.net/papers/ActiveVRML/, about the first FRP system), but it's probably not worth the read after the other two.
16:41:52 <conal> gfixler: also, http://conal.net/fran/tutorial.htm , though it's optimized for intuition rather than semantic precision.
16:41:57 <gfixler> conal: thanks - they're going to the top of the to-read pile
16:42:07 <tejing> ClaudiusMaximus: thanks, looks like exactly what I was thinking of
16:42:25 <Gurkenglas> For some reason I feel like unapplying a (partially applied?) constructor should be a function we have. Like fromJust, only general. Also probably returning wrapped in Maybe :P.
16:42:48 <conal> gfixler: cool. good luck. there's a lot of mis-information out there. the main idea is very simple: the semantics of 'Behavior a' is 'R -> a'.
16:43:07 <gfixler> conal: I was thinking of Asteroids the other day
16:43:13 <conal> gfixler: and then some combinators on Behavior with meanings defined compositionally/recursively.
16:43:30 <gfixler> I thought of an asteroid as having a mapping from time to position along a line
16:43:47 <gfixler> and when shot, it simply goes away, and two new ones are create with their own time -> position mappings
16:44:40 <gfixler> I need to get an intuition for Behavior, though
16:45:37 <conal> gfixler: how about "time-varying value" (or "dynamic value"), of which R -> a is a simple, precise formulation?
16:45:58 <conal> gfixler: are you looking for something else in your intuition?
16:46:15 <gfixler> conal: no, just wondering how far off I am :)
16:46:50 <gfixler> time-varying-value is pretty descriptive
16:53:23 <Gurkenglas> Weird, why is there no Ix i => (i, i) -> (i -> e) -> Array i e?
16:55:41 <hpc> Gurkenglas: isn't that a class function?
16:56:14 <Gurkenglas> https://www.haskell.org/hoogle/?hoogle=Ix+i+%3D%3E+(i%2C+i)+-%3E+(i+-%3E+e)+-%3E+Array+i+e
16:56:21 <arkeet> hoogle isn't that great at finding things.
16:56:46 <Gurkenglas> Also didnt see it from looking through the Data.Array page on Hackage but I might have missed it?
16:56:46 <arkeet> but it seems to not exist, heh.
16:57:04 <arkeet> vector has such a function, though.
16:57:20 <Gurkenglas> What's the difference between Vector and Array?
16:57:58 <KaneTW> array is fixed size iirc
16:58:27 <arkeet> so is vector
16:58:58 <arkeet> hm.
16:58:59 <arkeet> http://u.arboreus.com/2011/03/how-to-choose-haskell-array-library.html
16:59:04 <arkeet> wonder if this is still accurate.
17:01:53 <Gurkenglas> Does Codec.Picture have its top left corner at (0,0) or (1,1)?
17:02:37 <arkeet> from juicypixels? I think 0,0
17:03:35 <arkeet> yes
17:03:53 <arkeet> see e.g. the doc for generateImage
17:03:58 <KaneTW> how large is the performance difference when lexiographically comparing strings vs bytestrings
17:04:27 <hpc> i would expect it to usually be pretty much the same, with optimizations turned on
17:04:28 <arkeet> benchmark it! (I'd guess a fair bit.)
17:04:32 <arkeet> well
17:04:35 <hpc> depending on list fusing
17:04:53 <hpc> you pretty much need -O2 for valid benchmarks anyway
17:04:58 <KaneTW> i would but i don't have haskell installed on my windows machine right now :v
17:05:45 <Cale> What fusing?
17:06:03 <Cale> I'd expect ByteString to be much faster just due to memory locality
17:06:14 <athan_> Are there... trifunctors? o.O
17:06:19 <Cale> athan_: Sure
17:06:22 <hpc> don't lists sometimes get opimized to arrays?
17:06:29 <hpc> i vaguely recall that being a thing
17:06:30 <Cale> hpc: no, never
17:06:39 <hpc> ah, disregard my entire thing then
17:07:09 <Gurkenglas> What library should I use to invert matrices?
17:08:10 <Cale> Gurkenglas: hmatrix perhaps?
17:08:37 <Cale> Maybe linear
17:08:50 <Gurkenglas> 0. doesn't sound good :D
17:09:03 <acowley> Gurkenglas: How big are your matrices?
17:09:04 <Cale> ?
17:09:16 <Gurkenglas> 3x3, 5 of them :P
17:09:20 <arkeet> I don't think linear has anything for inverting large matrices.
17:09:22 <arkeet> oh, 3x3 is fine.
17:09:52 <acowley> Gurkenglas: Use linear
17:11:06 <arkeet> I get the impression that hmatrix is more suited for working with large matrices.
17:11:12 <arkeet> linear is definitely meant for small ones.
17:11:28 <acowley> arkeet: hmatrix is also more suited for doing interesting things with matrices
17:11:34 <acowley> arkeet: Like solving linear systems
17:11:38 <arkeet> sure.
17:12:39 <acowley> It's interesting trying to find the line of how much to put in linear vs. leaving it to the pros, as it were. E.g. speed of finding eigenvalues is deep rabbit hole.
17:12:53 <arkeet> I guess linear's 3x3 matrix inversion probably isn't the fastest, considering it just computes it by cofactors.
17:13:10 <acowley> I may have written it, and no it is not the best
17:13:25 <Gurkenglas> Codec.Picture is in haskell platform and Word8 isn't? ._.
17:13:33 <arkeet> Word8 is in base.
17:13:39 <acowley> import Data.Word
17:14:15 <srhb> Gurkenglas: Data.Word is in base
17:14:18 <srhb> Derp, the lags.
17:14:20 <koshmar> hey I wonder if anyone knows the name of task switcher written in haskell (at least I think so)? here is a screenshot ( https://wiki.haskell.org/wikiupload/0/0b/Adamvo-gridselect.png )
17:14:26 <Gurkenglas> Ah, Data.Word, not Data.Word8. Damn https://hackage.haskell.org/package/word8-0.0.0/docs/Data-Word8.html#t:Word8
17:14:45 <arkeet> that just exports it from Data.Word
17:14:48 <arkeet> re-exports
17:14:58 <srhb> Weird package.
17:15:23 <srhb> koshmar: Think that's just straight up XMonad.
17:15:36 <arkeet> also you linked an ancient version.
17:15:45 <srhb> koshmar: http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Actions-GridSelect.html
17:15:56 <koshmar> thanks
17:16:15 <srhb> koshmar: So it won't be of much use outside of XMonad, probably. See the bottom for screenies to compare with
17:16:33 <koshmar> well, I have xmonad
17:16:35 <koshmar> =)
17:16:37 <srhb> Ah, good!
17:16:46 <pacak>  arkeet: Recent version is still weird.
17:17:11 <arkeet> mhm.
17:17:56 <koshmar> I just remember similar task switchew which I instaled on my i3 long time ago, it looked like this xmonad thing
17:19:01 <athan_> Is there a `find` for lists, that returns an index, if it satisfies a predicate?
17:19:10 <arkeet> :t findIndex
17:19:13 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
17:19:20 <athan_> derp, thanks arkeet
17:19:33 <arkeet> :t findIndexOf folded
17:19:35 <lambdabot>     Not in scope: ‚ÄòfindIndexOf‚Äô
17:19:35 <lambdabot>     Perhaps you meant one of these:
17:19:35 <lambdabot>       ‚ÄòBS.findIndex‚Äô (imported from Data.ByteString),
17:19:44 <arkeet> oh yeah. needs newer lens
17:20:08 <athan_> arkeet: How about something more difficult - a relative predicate, like `minimum`?
17:20:25 <arkeet> zip with indices and use minimumBy
17:20:26 <KaneTW> hmm
17:20:33 <KaneTW> yeah, that
17:20:38 <arkeet> > fst . minimumBy snd . zip [0..] $ "cfgabd"
17:20:43 <lambdabot>      Couldn't match type ‚ÄòChar‚Äô with ‚Äò(a, Char) -> Ordering‚Äô
17:20:43 <lambdabot>      Expected type: (a, Char) -> (a, Char) -> Ordering
17:20:43 <lambdabot>        Actual type: (a, (a, Char) -> Ordering) -> (a, Char) -> Ordering
17:20:45 <arkeet> oh.
17:20:49 <arkeet> > fst . minimumBy (comparing snd) . zip [0..] $ "cfgabd"
17:20:52 <lambdabot>  3
17:21:23 <athan_> o_o
17:21:29 <athan_> that was really cool
17:21:31 <athan_> thanks arkeet :)
17:23:34 <arkeet> hey cool, lens has foldMapBy.
17:23:40 <arkeet> :t foldMapBy
17:23:42 <lambdabot> Foldable t => (r -> r -> r) -> r -> (a -> r) -> t a -> r
17:24:03 <codygman> Is this unreadable? filter (flip all [0,1] . (/=) . fst) [(0,0),(1,1),(2,2)]
17:24:09 <codygman> > filter (flip all [0,1] . (/=) . fst) [(0,0),(1,1),(2,2)]
17:24:11 <lambdabot>  [(2,2)]
17:24:37 <arkeet> you can use (`notElem` [0,1])
17:25:45 <arkeet> > filter ((`notElem` [0,1]) . fst) [(0,0),(1,1),(2,2)]
17:25:48 <lambdabot>  [(2,2)]
17:28:39 <codygman> arkeet: Thanks, whoa that is way better.
17:29:08 <arkeet> :)
17:29:52 * hackagebot linear-grammar 0.0.0.5 - A simple grammar for building linear equations and inclusive inequalities.  http://hackage.haskell.org/package/linear-grammar-0.0.0.5 (athanclark)
17:30:49 <athan_> Why does `find` & others return an Int, when lists can be infinitely long (in theory)?
17:31:34 <srhb> :t find
17:31:37 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
17:31:42 <srhb> athan_: What find are you talking about there?
17:32:07 <xplat> athan_: the real answer is 'it's faster'
17:32:11 <srhb> elemIndex?
17:32:15 <athan_> merp
17:32:20 <athan_> yeah, sorry srhb
17:32:28 <xplat> athan_: but also, even in an infinite list there is no actual element at an infinite index
17:32:29 <athan_> xplat: Thanks :)
17:32:53 <athan_> xplat: But, possibly one at `(maxBound :: Int) + 1`
17:32:57 <srhb> xplat: That point is that the index might be larger than Int 
17:32:58 <srhb> Yeah
17:33:11 <srhb> First off, indexes are largely irrelevant...
17:33:17 <srhb> Second off, Int is really quite large.
17:33:38 <srhb> In reality those functions should just not exist, really... :P
17:33:39 <arkeet> it's not so large on a 32-bit machine :-)
17:34:01 <xplat> also, if you have a list that is longer than Int, you probably don't want to traverse it twice to find your element again
17:34:21 <wgreenberg> is there a nice way to get a random element from a *very* large list?
17:34:25 <srhb> What's really silly is how it's an Int and not a Word
17:34:31 <athan_> good point. Thanks xplat, arkeet & srhb :)
17:34:48 <wgreenberg> I've seen something like randomRIO (0, length ls - 1)) >>= return . (ls !!)
17:34:53 <wgreenberg> but length ls is bad for large ls
17:34:54 <srhb> wgreenberg: yikes.
17:34:55 <kadoban> wgreenberg: I'd ignorantly assume that if you want to do that, they shouldn't actually be in a list anyway.
17:35:12 <srhb> wgreenberg: Don't use lists for that, I think is the answer.
17:35:23 <kadoban> Perhaps something with near-constant-time lookup? An array of some sort?
17:35:25 <arkeet> there is a way to do it while only traversing the list once, though.
17:35:35 <arkeet> but it involves generating a random number at every step.
17:35:42 <xplat> wgreenberg: there's the trick that traverses the list, holding on to one element, and replaces it with the element it's looking at with 1/k probability (k is the element's index)
17:36:10 <wgreenberg> xplat, oh that's neat
17:36:25 <wgreenberg> kadoban, srhb good point
17:36:32 <srhb> Still, having to traverse in order to get one random element seems silly.
17:36:53 <srhb> Less silly than if you need to traverse more than one time, of course :P
17:37:10 <wgreenberg> yeah. so slightly more reasonable would be a O(1) lookup structure where you know the length, then just choose a random int?
17:37:13 <xplat> well, there are cases when you have to, like if the list is only accessible as a stream
17:37:57 <wgreenberg> in my case it's a static list of stuff
17:37:58 <xplat> then you *have* to traverse it, and must do it in one pass too unless someone kindly lets you know the length beforehand
17:38:15 <srhb> xplat: Indeed.
17:38:28 <srhb> wgreenberg: And yes.
17:39:09 <srhb> xplat: This is probably me being dumb about randomness, but how can you pick a random element from a List if you don't have the end of it?
17:39:11 <xplat> yeah, if you already know the number of things precomputing that is definitely the way to go
17:39:21 <srhb> xplat: As in.. How do you pick the index if you don't know the largest one.
17:39:28 <wgreenberg> xplat, is there a name for your method? it seems nonobvious that it'd give you an equal probability of getting any particular element
17:39:36 <wgreenberg> nonobvious to me*
17:39:52 <xplat> srhb: >< xplat> wgreenberg: there's the trick that traverses the list, holding on to one element, and replaces it with the element it's looking at with 1/k probability (k is the element's index)
17:40:06 <srhb> Okay, I guess I don't understand how that works at all.
17:40:11 <xplat> wgreenberg: i think i learned it from perlmonks or something
17:40:11 <srhb> Or why, rather.
17:40:39 <xplat> srhb: well, use induction
17:41:10 <xplat> now, if you have a list of length 1, it will pick the sole element with a probability of 1/1
17:41:40 <xplat> so assume you have k elements and have already picked between them with equal probability 1/k each
17:41:45 <Axman6> cycle [1,4,2,6,8,3,6,8,3,6,3,,7,8,3,56,78] !! 274
17:41:55 <Axman6> one (not very good) option
17:42:02 <srhb> xplat: Yep, okay, got it. Thanks. :)
17:42:05 <srhb> That is rather clever.
17:42:30 <Gurkenglas> Is there anything like NumInstances for Integral?
17:42:41 <Axman6> what's NumInstances?
17:42:45 <arkeet> Gurkenglas: what type do you want it for?
17:42:55 <Gurkenglas> (Word8, Word8)
17:43:03 <arkeet> ok, how do you implement toInteger for that type?
17:43:10 <wgreenberg> but in a list of 3 elements, you'd get the first element (1/2) * (2/3) = 1/6 of the time, no?
17:43:11 <Gurkenglas> Nevermind.
17:43:14 <arkeet> :-)
17:43:15 <wgreenberg> or am I mathing wrong
17:43:23 <arkeet> 1/2 * 2/3 = 1/3
17:43:25 <Gurkenglas> I wanted pointwise div ^^
17:43:35 <wgreenberg> lol, right you are.
17:43:45 <wgreenberg> analysis correct, arithmetic wrong :)
17:44:28 <srhb> wgreenberg: This is why we crashed a billion dollars on Mars, you know. :(
17:44:33 <wgreenberg> haha
17:46:36 <GLM> Would it be appropriate to ask career questions here?
17:46:57 <acowley> Is the proposed career as an op of #haskell?
17:47:28 <XorSwap> it's a lucrative market
17:47:29 <acowley> GLM: If the question veers from Haskell programming, you should try out #haskell-blah for tangential discussion
17:48:00 <Gurkenglas> http://pastebin.com/Bnmawkcm welp?
17:48:07 <acowley> I'm not an op, but I don't mind if you want to start the discussion here! The main thing is to not swamp out programming questions.
17:49:48 <Gurkenglas> Ah well what could possibly go wrong forcing linear install
17:50:16 <acowley> Gurkenglas: You should try using sandboxes
17:51:40 <acowley> Gurkenglas: Or you could shout YOLO and jump into the stack beta
17:52:23 <Gurkenglas> linear install failed http://pastebin.com/Tv1UFZxw
17:53:43 <Gurkenglas> Hmm do I stay awake another 10-14 hours till 1-5 pm or do I go to sleep for 5 hours...
17:53:51 <pacak> acowley: Btw, am I missing anything obvious from machines/concurrent-machines or there's no existing functions to merge events from several sources in async way (blocking network sockets for example)? [MachineT IO k a] -> MachineT IO k a
17:54:05 <arkeet> Gurkenglas: what timezone are you in?
17:54:12 <Gurkenglas> Germany
17:54:14 <arkeet> also, I guess this is off topic sorta.
17:54:15 <arkeet> I see.
17:54:35 <srhb> Gurkenglas: SAme TZ here, I prefer sleeping in the morning. Screw expectations! :P
17:55:09 <acowley> pecak: scatter has that type
17:56:15 <acowley> pacak: the above was for you
17:56:26 <pacak> acowley: Yep, looking at it :)
17:57:00 <acowley> My pinky moving to the tab key has to race the rest of my fingers guessing how to spell a nick :/
17:57:30 <pacak> Hmm... Maybe I should consider changing it to something easier to spell then.
17:59:39 <pacak> acowley: Looks like it's doing exactly what I wanted it to do.
17:59:57 <acowley> pacak: Awesome!
18:08:05 <augur_> hmm
18:08:20 <augur_> so i just had a thought regarding mutability
18:09:14 <augur_> suppose you have some code C that mutates variable x in some fashion
18:09:22 <augur_> and x is the only variable it mutates, just to make this clean
18:10:24 <augur_> C would be pure from the outside if it were prefixed by a declaration and initialization of x with a copy
18:10:52 <augur_> that is to say   var x = copy(y); C;   is pure from the outside, if you treat x as the returned value
18:11:46 <y> augur_: that sounds like you want ST? 
18:11:53 <y> s/want/are reinventing/
18:11:58 <augur_> maybe i am :)
18:12:04 <augur_> but let me finish re-inventing first! :p
18:13:50 <augur_> it should then be plausible to have some kind of type,  Mutably a   with a function   run :: Mutably a -> a   and another function   withMut :: (Ref a -> Mutable b) -> Mutable b
18:14:32 <augur_> or rather,   withMut :: a -> (Ref a -> Mutably b) -> Mutably b
18:14:59 <augur_> so that    withMut y (\x -> C)   is equivalent to   var x = copy(y); C;
18:15:46 <augur_> and then you can just do   run (withMut y (\x -> C))   to get the value computed
18:16:05 <hakujin> why do we have both ExceptT and EitherT?
18:16:07 <augur_> y: i dont think ST has a function   ST a -> a. you have to run it all inside IO i think
18:16:17 <y> @type runST
18:16:19 <lambdabot> (forall s. ST s a) -> a
18:16:22 <bitemyapp> augur_: so you haven't looked at ST.
18:16:31 <y> it is using RankNTypes for the 'state' and keeping soundness
18:16:38 <bitemyapp> augur_: the extra type parameter is so you don't leak the mutable references.
18:16:42 <bitemyapp> what y said.
18:16:47 <acowley> hakujin: Because we're silly
18:16:56 <bitemyapp> y: how do you not get flagged *all* the time?
18:16:59 <augur_> bitemyapp: i cannot guarantee that i've fully understood how ST works
18:17:21 <hakujin> acowley: is it just to be able to depend on transformers and not an external dep on either?
18:17:25 <y> bitemyapp: I don't, it just happens! :P 
18:17:53 <athan_> Is there a language extension that doesn't define... undefined?
18:18:14 <bitemyapp> athan_: what?
18:18:27 <bitemyapp> athan_: you want a custom Prelude that warns on use of undefined/error?
18:18:54 <hakujin> athan_: maybe import Prelude hiding (undefined)
18:19:14 <bitemyapp> athan_: http://hackage.haskell.org/package/classy-prelude tacks a warning onto undefined.
18:19:23 <acowley> hakujin: Like it says in the either docs, EitherT is ErrorT (from transformers) without a constraint.
18:19:24 <augur_> y: so yeah, i guess i reinvented ST it seems! :) good to know
18:19:37 <acowley> hakujin: And then ExceptT was added more recently
18:21:08 <hakujin> acowley: I was curious as to why
18:21:26 <acowley> hakujin: I think there were some unfortunate social dynamics at play
18:21:41 <athan_> There you go hakujin :)
18:22:00 <athan_> bitemyapp: Oh woah! Yeah I need to get into alternative preludes :\
18:22:27 <athan_> bitemyapp: (also, I _should_ (all fingers crossed) be getting paid soon)
18:22:33 <bitemyapp> athan_: congrats :)
18:22:42 <athan_> thanks :)
18:22:59 <y> athan_: you can have bottom without undefined/error though
18:23:13 <monochrom> Haskell is too invested in arbitrary recursion that it can't easily get rid of undefined by just an extension.
18:23:40 <monochrom> (it is extremely easy to get too invested in arbitrary recursion. takes almost no effort.)
18:23:43 <y> athan_: head [] , fromJust Nothing , let x = x in x , fix id , fix (0+) , ...
18:24:00 <monochrom> you have to design a language from the ground up to avoid undefined.
18:24:31 <athan_> y: That's a good point
18:25:41 <y> sum [1..] , last [1..] , length [1..] , forall f z. foldl' f z [1..],  :P 
18:26:03 <GLM> Is there a way to get a trampolining stack and tail recursion in Haskell?
18:28:04 <platz> trampolining and tail recursion seem like mutually exclusive concepts
18:28:30 <platz> i.e. you can have one or the other
18:29:52 <GLM> platz: I suppose so. I was thinking in some cases, have tail recursion but have trampolining just in case you can't convert to tail recursive for whatever reason
18:30:26 <platz> oh i see, yeah that is at least sound
18:30:53 <y> GLM: you could say all calls are tail-calls in ghc haskell (implementation details, the machine stack isn't directly used), if you want to avoid building thunks (which is different), you can use have strict parameters
18:31:33 <GLM> I'm mainly trying to avoid stack overflow
18:32:09 <y> GLM: f x acc = x `seq` acc `seq` if x == 0 then acc else f (x-1) (acc * x) (or, with BangPatterns, f !x !acc = ...)
18:32:24 <Hijiri> I think in GHC 7.10 there is no stack overflow, it just grows until you run out of memory
18:32:46 <GLM> Hijiri: I see those as the same thing
18:33:41 <geekosaur> not exactly since the stack is a different thing in ghc (pattern match stack). strictness generally avoids that problem
18:33:52 <geekosaur> (however done incorrectly it will lead to heap growth instead)
18:36:09 <monochrom> some code should be lazy. some other code should be eager.
18:36:45 <monochrom> if you make should-be-lazy code eager, it will use too much memory and time
18:36:58 <monochrom> if you make should-be-eager code lazy, it will use too much memory and time
18:37:24 <monochrom> the dichotomy is not lazy vs eager. the dichotomy is doing it right vs doing it wrong
18:37:50 <dolio> Tail calls are already optimized in GHC. You don't need to trampoline to avoid them costing you.
18:38:30 <monochrom> there is also the false dichotomy of stack vs heap. an algorithm that uses O(1) stack, O(n^2) heap is no better than an algorithm that uses O(n^2) stack, O(1) heap
18:38:50 <geekosaur> ^ that being what I was getting at with "however done incorrectly..."
18:39:08 <dfeuer> monochrom, that does depend on context...
18:39:13 <monochrom> "stack overflow" is an old relic from a bygone era when stack could not grow but heap could.
18:39:34 <dfeuer> monochrom, that's no longer a problem in GHC, but there are places it is....
18:39:42 <johnw> i think there might be a bias toward stack because (a) allocating new structures should be super fast (don't need to find free blocks), and (b) deallocating is quicker for the same reason (no maintenance)
18:39:51 <monochrom> the context is #haskell and GHC.
18:40:05 <dfeuer> Ahh.
18:40:12 <geekosaur> anyway, in a lazy language the pain point is not on function calls (where you'd avoid it with a tail call), the pain point is in excessive laziness, because random expressions suddenly need to save what they were doing and force a lazy expression's value
18:40:33 <monochrom> but I would have no problem telling the C people "you're dinosaurs of fixed stack"
18:40:57 <dfeuer> johnw, I think I found what I was looking for. Look at Fix_eq in https://coq.inria.fr/stdlib/Coq.Init.Wf.html#Fix_F
18:41:12 <dfeuer> That's at least part of what I was looking for anyway.
18:41:13 <geekosaur> this is kinda similar but also different because it happens in different and sometimes unexpected places
18:41:32 <dfeuer> monochrom, Idris has issues with that too still :P
18:41:56 <geekosaur> and the things you're used to to work around it don't do anything at all about it
18:42:18 <platz> the terminology remains confusing though
18:42:18 <monochrom> to which they might reply "Jurassic World makes us cool again"
18:42:24 <platz> > traverse Just [1..100000000]
18:42:28 <dolio> johnw: But garbage collection can be faster than stack allocation.
18:42:32 <dfeuer> geekosaur, personally I think trying to work with laziness in a purely functional default-strict language is *really hard*. It's so easy to accidentally be too strict.
18:42:34 <lambdabot>  *Exception: stack overflow
18:42:42 <dolio> There's a paper with that name.
18:43:01 <dfeuer> dolio, it's called "Exception: stack overflow"?
18:43:18 <geekosaur> sure, I'm not saying "lazy bad", I'm saying "you need to learn new tricks because the old ones aren't relevant"
18:43:24 <dfeuer> Ahh...
18:43:25 <dfeuer> That may be.
18:43:53 <geekosaur> and it's kinda unfortunate that it sounds lsimilar (because it's a "stack overflow" which means one thing to e.g. C programmers but a different thing entirely in Haskell)
18:44:00 * dfeuer gets very confused by strict stuff these days. It's easy to forget that foldr is crazy in a strict language, and that map is very expensive.....
18:44:31 <dolio> dfeuer: No. Garbage Collection can be Faster than Stack Allocation.
18:46:08 <platz> though if excessive laziness is the problem, that seems to me to be analagous to a computation that isn't in tail position (and when you can't incrementally consume the results).  so the challenge is avoiding building up thunks, but some algorithms are hard to avoid building thunks than just using 'seq'
18:46:19 <dfeuer> dolio, I was mostly kidding. The main things that annoy me about GC/allocation-happy code are 1. If you violate the generational hypothesis, you're pretty much screwed, and 2. You can get good L2 cache utilization, but don't seem to have much hope of good L1.
18:47:26 <y> dfeuer: "violating the generational hypothesis"? having relatively old values getting GC'd ? 
18:48:07 <dfeuer> y, yeah. You get to see the profiler showing relatively low allocation with 75-80% of the time spent in GC. Lovely.
18:48:09 <platz> I wonder how they handle this in purescripe
18:49:56 * hackagebot coinbase-exchange 0.2.0.0 - Connector library for the coinbase exchange.  http://hackage.haskell.org/package/coinbase-exchange-0.2.0.0 (andrewrademacher)
19:00:43 <meretrix> Aww.. someone else wrote haskell bindings to coinbase. Wish I saw that about a month ago. :(
19:07:56 <unknownloner> if I don't use the -threaded option, will my haskell code make use of multiple cores when it's not making foreign calls
19:08:33 <kadoban> unknownloner: I don't believe so.
19:08:37 <KaneTW> i don't think so
19:11:10 <pacak> unknownloner: No, but non-threaded runtime is a bit more efficient if you are using just one thread.
19:19:27 <johnw> hi
19:19:38 <johnw> (wrong window)
19:34:58 * hackagebot fay-geoposition 0.1.0.0 - W3C compliant implementation of GeoPosition API.  http://hackage.haskell.org/package/fay-geoposition-0.1.0.0 (eocallaghan)
19:53:29 <carter> i may have shared a haskell job on redit http://www.reddit.com/r/haskell/
19:53:33 <carter> fyi all
19:57:05 <c_wraith> carter: that company name sounds a bit unlikely. :P
19:57:16 <carter> google can reveal the real name
19:57:40 <carter> but as an employee, i'mnot allowed to say the name publically without an annoying approval process
19:57:51 <carter> especially for a job post
19:58:07 <carter> especially a job post that lets candidates skip the HR filter
19:59:28 <c_wraith> Ah.  That is a very scary company.  Fortunately, I'm not up for a move to new york.
20:00:19 <carter> i was able to get the C suite to sign off on agreeing projects on my own time are mine
20:00:25 <carter> which is unique for large orgs
20:00:25 <mlamari> When instancing something like "Either" with 2 type params:     instance Functor (Either a) where             <-- what's the shortest path to making an FMap on the second type param (the 'right')? Does it have to be a separate type, or is there a magic to referring to the type here?
20:00:41 <carter> c_wraith: to be fair, i'm still trying to figure out if it works for me
20:00:52 <carter> but that doesn't preclude me trying to help get more people in
20:01:19 <c_wraith> Honestly, it sounds like a cool place to work within the company..  But that industry + New York is a scary combination. :)
20:02:22 <peddie> mlamari: https://hackage.haskell.org/package/bifunctors-5/docs/Data-Bifunctor.html#t:Bifunctor maybe ?
20:05:20 <carter> c_wraith: but haskell
20:05:26 <carter> :)))
20:05:31 <carter> but yeah, finance is weird
20:08:13 <KaneTW> what's an affirmative action employer
20:08:53 <carter> idk
20:08:56 <Welkin> any government organization
20:08:57 <carter> but we are one?
20:09:07 <Gurkenglas> Why can't this tiff file be read by Codec.Picture? One would think 745426 bytes would be enough  http://www11.pic-upload.de/11.06.15/312hvy4i1r2.png
20:09:10 <KaneTW> buzzwords[tm]
20:09:31 <mlamari> peddie: thanks, trying to digest with my lame haskellage. I was wondering not because I have an application for it but for understanding if there's some local solution too.
20:10:02 <carter> KaneTW: basically large organizations actually invest in trying to make sure they have a diverse inclusive work environment
20:10:16 <KaneTW> i see
20:11:09 <mlamari> diverse?  PC *and* console gamers?
20:12:02 <hiptobecubic> c_wraith, indeed.
20:12:05 <carter> humanity
20:12:11 <saulzar> Gurkenglas, No idea, file a bug report? How big is the file?
20:13:05 <KaneTW> Gurkenglas: there are a great many tiff subformats
20:13:14 <peddie> mlamari: I didn't totally understand the original question, Bifunctor just seemed relevant . . . if you still have questions, I suggest asking, maybe someone can help :)
20:13:18 <Axman6> Gurkenglas: looks like the image may be malformed, or in a format not understood by JuicyPixels - tiff is pretty complex
20:14:45 <Gurkenglas> http://www11.pic-upload.de/11.06.15/t4tattadsxw3.png is what windows rightclick shows
20:15:48 <KaneTW> it's probably an unsupported tiff subformat, file a bug report since it should error out in that case
20:15:52 <saulzar> Gurkenglas, JuicyPixels is written in Haskell (not a C wrapper), so probably has some issue 
20:16:22 <Gurkenglas> http://lpaste.net/134312
20:16:38 <KaneTW> https://hackage.haskell.org/package/JuicyPixels-3.2.5.2/docs/Codec-Picture-Tiff.html
20:16:53 <Gurkenglas> lpaste says use fewer imports? o.o
20:17:57 <saulzar> Probably reacting to your two lines of   import Data.Maybe 
20:18:10 <Gurkenglas> Whoops :D
20:18:24 <Gurkenglas> I thought it just detected when I went overboard on using libraries.
20:18:48 <saulzar> It's running your code through hlint I think
20:19:05 <saulzar> What's the code doing?
20:21:47 <Gurkenglas> To read main: Construct a list of file names of .tiff images to be loaded. (They are Kinect-generated registrations from color to depth images.) Turn them into arrays and then given injections from depth/color images into a stitched color/depth pair, construct a stitched registration.
20:22:06 <saulzar> Ahh
20:22:19 <saulzar> Cool!
20:23:24 <Gurkenglas> Where until I get it to work at all, I'll just take the average of all coordinates I can find through following the arrows.
20:25:40 <mlamari> FWIW this looks at all the angles on fmap and Either:  http://stackoverflow.com/questions/5195254/understanding-how-either-is-an-instance-of-functor
20:28:05 <Welkin> !seen
20:28:10 <Welkin> !seen lambdabot
20:28:15 <Welkin> @seen lambdabot
20:28:15 <lambdabot> Yes, I'm here. I'm in ##harmless, #fp@nith, #lpmc, #lysa, #learnmath, ##scalaz, #vinyl, #aurapm, #plaimi, ##megaharem, #lw-prog, #bfpg, #nicta-course, ##categorytheory, #hledger, #ledger, #csa_uva, #tanuki, ##villagegreen, #hscraft-srv, #esoteric, ##manatee, #unicycling, #scannedinavian, #mainehackerclub, #scala, #rosettacode, #macosx, #scalaz, #
20:28:15 <lambdabot> functionaljava, #jtiger, ##crypto, #jhc, #happs, #ghc, #gentoo-uy, #fedora-haskell, #gentoo-haskell, #friendly-coders, #macosxdev, #haskell-game, #haskell-freebsd, #dreamlinux-es, ##proggit, #learnprogramming, #learnanycomputerlanguage, #darcs, #archlinux-haskell, #haskell-arcade, ##logic, #yi, #numerical-haskell, #snapframework, #diagrams, #
20:28:15 <lambdabot> xmonad, #agda, #hackage, #haskell-beginners, #haskell-cn, #haskell-by, #haskell-id, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.it, #haskell.hr, #haskell-fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-br, #haskell-pl, #haskell.tw, #haskell.au, #haskell-llvm, #haskell-soc, #haskell-gsoc,
20:28:15 <lambdabot>  #haskell-overflow, #haskell-in-depth, #haskell-books, #haskell-blah, #haskell-infrastructure, #haskell-lens and #haskell
20:28:22 <Welkin> wow
20:28:32 <Welkin> @seen joelteon
20:28:33 <lambdabot> I saw joelteon leaving #haskell-lens and #ghc 16d 18h 11m 57s ago.
20:29:29 <mlamari> Sort of vague question; but things what's the thoughts of anyone using haskell on big projects on adding project dependencies to use little transforming goodies like bifunctior vs rolling a make-do locally? Is there any tradeoff you make "there's too many darn dependencies"? Or bias toward using a library that contains just a single thing you need?
20:30:10 <carter> mlamari: do whichever makes your life easier
20:30:33 <mlamari> carter: Thanks, was just vaguely interested in where experienced guys tended to go on this. But I understand the question was vague.
20:30:40 <carter> no
20:30:45 <carter> its simple, both are valid
20:30:48 <carter> :)
20:31:56 <mlamari> It's one of the dazzling areas of the language, even compared to (something I know much more about) F# - the degree to which you can formally define types for more situations means more operations seem to be factorable (the amount of stuff in libraries like all the ekhmetts is astounding).
20:34:41 <lpaste> tar_ pasted ‚ÄúNo title‚Äù at http://lpaste.net/134313
20:35:29 <tar_> I'm trying to generalize some miniax code (that paste I just made), but I don't know how to write the type for the functions in the Minimaxable type class
20:35:36 <tar_> minimax*
20:35:40 <tar_> or if I can . . .
20:40:40 <Axman6> tinyblak_: why do you need a typeclass?
20:40:47 <Axman6> uh, tar_ not tinyblak_ 
20:41:35 <tar_> Axman6: I want to be able to make an instance for each type of game I want to solve.
20:55:49 <GLM> Is it at all possible to create mobile apps with Haskell
20:56:30 <Welkin> yes
20:56:42 <Welkin> there is ghc-ios
20:57:18 <GLM> Android and Windows?
20:57:19 <Welkin> you can also build web applications that run in the mobile browser
20:57:33 <Welkin> I don't know about windows phone
20:57:50 <Welkin> there may be bindings for android
20:58:04 <Welkin> https://wiki.haskell.org/Android
20:58:28 <Welkin> https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling/iOS
20:59:10 <Welkin> GLM: also https://wiki.haskell.org/IPhone
21:08:15 <felixn> parse (between (char 'a') (char 'a') (many (char 'a'))) "fail" "aaaaa" <-- anyone know how to parse this with parsec?  basically let the inner parser backup, until the outer parser is happy
21:10:03 * hackagebot Neks 0.4.0.0 - Simple networked key/value store  http://hackage.haskell.org/package/Neks-0.4.0.0 (wyager)
21:13:14 <kadoban> felixn: Refactor it instead as ‚Ä¶  at least two 'a', and have the result be all of the 'a' minus 2?
21:15:05 <Axman6> (:) <$> char 'a' <*> many1 (char 'a')?
21:16:08 <felixn> kadoban: Axman6: that's just the issue isolated, I think I just have to implement
21:16:29 <felixn> blah, hit enter too fast
21:16:46 <felixn> I think I just have to implement the between backtracking parser*
21:17:23 <kadoban> Well if you're trying to solve some other problem, it's possible you need some other solution.
21:17:25 <Axman6> well, the solution will almost certainly be different for the actual problem
21:22:33 <Axman6> bleh, if AARNet would fix their shit, I'd be so happy right now
21:23:39 <Welkin> AARNet?
21:23:47 <Welkin> this? https://mirror.aarnet.edu.au/
21:24:26 <Axman6> whoops, wrong channel, but yet (without the mirror part)
21:24:31 <Axman6> yes*
21:31:24 <codygman> Is there an analogue for Data.HashTable from base 4.2: https://hackage.haskell.org/package/base-4.2.0.1/docs/Data-HashTable.html It looks like hashtables only provides hashsets in ST or IO.
21:32:21 <bvun> hello, could someone explain why I get a "Parse error in pattern: balance" here? http://www.pastebin.ca/3024243
21:33:18 <KaneTW> your pattern is invalid
21:33:24 <KaneTW> you can't construct a pattern using ||
21:33:33 <kadoban> bvun: Is that some extension, or is it just bunk? || doesn't mean anything to me there.
21:33:50 <KaneTW> you probably want guards?
21:33:51 <kadoban> I don't think haskell has 'or patterns' or whatever those are called.
21:34:15 <arkeet> it doesn't.
21:35:48 <bvun> oh, yeah i thought I was able to do or patterns. I'll try making every pattern separate then. thanks kadoban KaneTW arkeet 
21:40:50 <rui1> Is there some tool to visualize the graph of typeclasses from some package?
21:42:14 <rui1> (ideally with some way to see what they implement, instances, or its doc, that don't get in the way too much)
21:57:07 <johnw> arkeet: https://gist.github.com/jwiegley/8130f9922bdfe7128ff9
21:57:39 <arkeet> I don't know how to read a coq proof, but it says Qed at the end so it must be correct.
21:57:45 <johnw> haha
21:57:54 <johnw> "Not all injective functions have left inverses."
21:58:19 <arkeet> oh, not assuming A is nonempty?
21:58:22 <johnw> "There exists an injective function without a left inverse."
21:58:25 <johnw> no assumptions needed
21:58:28 <johnw> yeah, not assuming
21:58:49 <johnw> proving that it does have one,  if A is non-empty, is a bit tougher
22:00:52 <arkeet> johnw: well yes, there are lots of injective functions out of the empty set that have no inverse.
22:00:55 <arkeet> that's not interesting imo :-)
22:02:16 <panderer> anyone who knows expression problem?
22:02:46 <Axman6> probably lots of people
22:03:24 <panderer> it's about parenthesis
22:03:45 <panderer> input is depth and length
22:04:05 <panderer> and gives how many expressions are
22:31:05 <sccrstud92> is there a stackage specific irc? or should i jsut ask here?
22:31:16 <johnw> I think #haskell-stack was created for that
22:36:35 <jle`> sccrstud92: you're more than welcome to ask here though :)
22:36:56 <sccrstud92> sure ill go since the other one is empty atm
22:37:17 <sccrstud92> i just got rid of HP on my windows box
22:37:21 <kadoban> Well it does have 8 people XD
22:37:39 <sccrstud92> downloaded and install minghc-7.10.1
22:38:11 <sccrstud92> now i am trying to install the dependencies for a project
22:38:22 <sccrstud92> so i did stackage update
22:38:29 <sccrstud92> to get latest lts
22:38:37 <sccrstud92> and then stackage install
22:39:07 <sccrstud92> however stackage install fails because the latest lts uses a version of mtl that is too new for the version of transformers that came with minghc
22:39:24 <sccrstud92> so i was gonna use the nightly release instead of the lts release
22:39:30 <sccrstud92> so im trying to figure out how to do that
22:39:35 <sccrstud92> =)
22:39:36 <kadoban> sccrstud92: You should be using stackage nightly for GHC 7.10.1
22:39:47 <kadoban> (I just read down to that part, heh)
22:40:05 <sccrstud92> kadoban: at least i know i figured it out on my own =P
22:41:22 <sccrstud92> kadoban: when i do stackage sandbox init it automatically initializes to lts-2.13 snapshot
22:41:33 <sccrstud92> even thought i downloaded nightly cabal.config
22:41:54 <kadoban> sccrstud92: I think there's some switch for that, I thought ‚Ä¶ let me see if I can find it. I keep meaning to switch to those tools, but I haven't yet.
22:42:43 <sccrstud92> kadoban: stackage sandbox init nightly
22:42:48 <sccrstud92> that did it i think
22:42:53 <kadoban> Sounds right
22:43:30 <sccrstud92> kadoban: so what does the cabal.cofig do exactly? is that only needed if im not using stackage executable?
22:45:15 <kadoban> AFAIU the cabal.config tells cabal which versions of packages to use. When you're using stackage, in general (I don't know about the stackage CLI tools much yet), it locks down the versions of packages to what stackage tells it, for everything in stackage.
22:46:05 <kadoban> I believe the stackage CLI stuff is largely, but not completely, wrappers around cabal, so it should do basically the same thing, but also helps you do stuff like share sandboxes in a safe way to avoid recompilation
22:46:48 <sccrstud92> HP was great for getting started, but for developing a project it is hard to work with
22:47:14 <sccrstud92> i hope stackage will replace it
22:47:20 <kadoban> Yeah, platform was nice when I was first learning haskell ‚Ä¶ but I quickly outgrew it I think.
22:48:23 <kadoban> I've been fairly happy with stackage and cabal sandboxes (and a minimal GHC install). It took a bit of work to start understanding it to the ‚Ä¶ moderate amount that I know now, but wasn't too bad. I'm hopeful the stackage CLI stuff will make some of that easier, heh.
22:55:56 <sccrstud92> kadoban: yeah me too
22:58:25 <sccrstud92> i got an error installing glut on windows
22:58:31 <bernalex> how well does haddock & lhs play together these days? is it just as straightforward as plain hs? I want to write a game which src can be compiled and read like a book.
22:59:10 <sccrstud92> i have it installed im pretty sure, but i dont think stackage/cabal can find it
22:59:22 <sccrstud92> it says to use some flags, but i dont know where to use them
23:20:49 <Draggor> what's the best way to get latest haskell-platform on ubuntu 14.04.02 LTS?
23:25:04 <kadoban> Draggor: IMO the best way is to /not/ get haskell-platform. Instead install /just/ GHC and cabal, and then use cabal sandboxes and optionally stackage.
23:25:16 <Draggor> Ahh
23:26:01 <kadoban> (This is not necessarily the only opinion out there ‚Ä¶ although I haven't noticed anyone yell at me for saying it either, heh)
23:27:17 <Draggor> Main issue I have is a project is relying on cabal 1.18, repos have 1.16 and older ghc
23:27:32 <Draggor> But it requires ghc to build ghc?
23:28:09 <kadoban> Draggor: To build GHC it probably does, you can install from binary though, or https://github.com/bitemyapp/learnhaskell/blob/master/install.md has ubuntu instructions (from a ppa)
23:29:06 <Draggor> kadoban: ah thanks
23:30:31 <sccrstud92> im working on my first multi-module project. i have a src folder and a test folder. my module in the test folder wants to use stuff from the modules in the src folder. what is the form of the import statement should use? i have a file Types.hs that says "module Types where" at the top, but "import Types" does not work.
23:31:45 <arkeet> sccrstud92: using cabal?
23:32:42 <sccrstud92> arkeet: i am running "cabal exec runhaskell test/ArchitectureTest.hs"
23:33:00 <sccrstud92> and I get "could not find module" errors
23:33:09 <sccrstud92> i have a cabal file
23:33:34 <sccrstud92> containing "hs-source-dirs:      src"
23:33:44 <sccrstud92> which is where the modules are located
23:35:09 <arkeet> sccrstud92: the standard thing to do is to have your main code in a library and your test in a separate test suite
23:35:12 <arkeet> in your cabal file
23:35:22 <arkeet> and then have your test suite depend on the library
23:35:29 <arkeet> uh
23:35:53 <sccrstud92> arkeet: and manage them as two separate packages?
23:35:57 <arkeet> no, one single package.
23:36:01 <arkeet> single cabal file
23:36:02 <arkeet> http://stackoverflow.com/a/18310327/1871429
23:36:11 <royadav> all: is there is a library which is capabale of extracting metadata from pdf files, research papers?
23:36:16 <sccrstud92> arkeet: i thought that is what i had...
23:36:50 <arkeet> does your library have Types in exposed-modules?
23:36:57 <arkeet> do you mind sharing your .cabal file actually
23:37:51 <arkeet> key point is
23:37:58 <arkeet> the library exposes the modules needed by the test suite
23:38:14 <arkeet> the test suite refers to its own package in build-depends
23:38:25 <arkeet> and it's also necessary for each one to have different hs-source-dirs
23:39:56 <sccrstud92> arkett: here is the .cabal file http://lpaste.net/2135303923907428352
23:40:02 <sccrstud92> arkeet: ^
23:40:48 <arkeet> okay, so cabal has no idea about your tests.
23:40:54 <sccrstud92> arkeet: the file in test isnt really a "test" in that it is verify correctness. it was more like a test that i could figure out how to use all these new libraries i  havent used before
23:41:00 <arkeet> ah.
23:41:11 <arkeet> you could just add tests to your hs-source-dirs then.
23:41:28 <arkeet> and list your extra moduels in other-modules
23:41:36 <arkeet> and have cabal build stuff for you.
23:41:37 <arkeet> I guess?
23:42:02 <arkeet> oh yeah, if you have a Types module you better list it in other-modules.
23:42:07 <arkeet> or in exposed-modules in a library.
23:42:31 <sccrstud92> arkeet: alright i have some restructuring to do
23:42:35 <sccrstud92> thanks for your help
23:42:35 <arkeet> okay
23:42:36 <arkeet> :)
23:43:03 <sccrstud92> i should really read the cabal file format documentation haha
23:43:25 <arkeet> the cabal user's guide is a pretty good read.
23:44:34 <alisia> is there anyway to include double quotes in a string without escaping..?
23:45:02 <Axman6> what's wrong with \"
23:45:03 <Axman6> ?
23:45:16 <kadoban> Not with base haskell. You can do it with quasiquoter tricks though (template haskell)
23:46:37 <Axman6> > ord '"'
23:46:42 <lambdabot>  34
23:46:52 <Axman6> "\34"
23:46:56 <Axman6> >"\34"
23:47:03 <Axman6> > "\34"
23:47:09 <lambdabot>  "\""
23:47:20 <liste> > "a" ++ ['"'] ++ "c"
23:47:21 <pacak> alisia: > '"' : 'h':'e':'l':'l':'o':'"':[]
23:47:23 <lambdabot>  "a\"c"
23:47:24 <pacak> > '"' : 'h':'e':'l':'l':'o':'"':[]
23:47:29 <lambdabot>  "\"hello\""
23:47:47 <alisia> Axman6, I want to include postgresql queries in the code...
23:48:21 <pacak> alisia: use single quotes? Are they different in postgress from double ones?
23:48:22 <Axman6> then use one of thw many packages that let you do that safely
23:49:20 <liste> alisia would prepared queries help?
23:50:02 <alisia> pacak, Yes. I think single quotes are for quoting things like table name, column names etc and single quotes for actual strings.
23:50:10 * hackagebot fay-geoposition 0.1.0.1 - W3C compliant implementation of GeoPosition API.  http://hackage.haskell.org/package/fay-geoposition-0.1.0.1 (eocallaghan)
23:50:37 <alisia> liste, But I am not sure I can use place holders for table name, column name etc..
23:53:31 <liste> alisia yeah that can be a problem
23:56:10 <liste> do the column/table names clash with keywords?
23:58:17 <alisia> liste, sometimes they do, so I have a habit of quoting them always.
