00:02:31 <SrPx> Does anyone here know what is the name for when you have a recursive data structure that is not regular? For example, data List a = Cons a (List a) | Nil -- this is regular, since the loop goes from the List body to List itself
00:02:55 <SrPx> data Tree a = Node [(Tree a)] -- this isn't regular, because we go from the tree body to the list body, then to the tree, then list, then tree, etc
00:03:12 <SrPx> I know there is a name for this because I've read it on wikipedia a few days ago, but I can't recall 
00:10:00 <yayfoxes> LordBrain: how do you make 780 / 4 even easier?
00:12:39 <codesoup> SrPx, you may be thinking of a rose tree aka multiway tree
00:13:07 <SrPx> codesoup: no, I mean the name of the phenomena. But I guess it is called just "mutual recursion"
00:14:12 <LordBrain> yayfoxes, for a human or a computer? a computer can shift the bits twice to the right
00:14:57 <LordBrain> yayfoxes, however, i don't think that is any optimization these days, i'd be suprised if you get anything for it.
00:15:18 <LordBrain> if you do, the compiler probably detects and sticks it in anyway
00:15:25 <yayfoxes> LordBrain: for a human
00:15:58 <jonbobbly> I'm learning Haskell as part of trying to configure xmonad, and I'd like to know what the  <+>  symbol does. It shows up in tutorials and sample configs, but I can't find any info on it.
00:16:34 <LordBrain> well, mentally i would seprate it into (700 + 80) /2 /2 and distribute
00:17:24 <LordBrain> (350 + 40) / 2 = (175 + 20) = 195
00:17:42 <LordBrain> > 780 / 4
00:17:44 <lambdabot>  195.0
00:19:03 <yayfoxes> LordBrain: for 780 / 4 you just see how many times 4 goes into 78
00:19:13 <yayfoxes> and add a 0 and BAM
00:20:16 <LordBrain> there's probably a ton of approaches, whatever floats your boat.
00:21:03 <LordBrain> i don't think 78/4 is any easier than 780/4 personally.
00:25:03 <jle`> jonbobbly: it's actually a polymorphic operator that every type can define its own implementation of
00:25:07 <jle`> what type are you using it for?
00:28:19 <LordBrain> @type (<+>)
00:28:19 <lambdabot>     Ambiguous occurrence ‘<+>’
00:28:20 <lambdabot>     It could refer to either ‘Control.Arrow.<+>’,
00:28:20 <lambdabot>                              imported from ‘Control.Arrow’ at /home/lambda/.lambdabot/State/L.hs:43:1-20
00:28:32 <gamegoblin> Is there a way to make a newtype derive all of the instances of the type it wraps?
00:28:40 <gamegoblin> (any simply delegate them)
00:28:47 <jle`> LordBrain: it's the monoidal operator for ArrowPlus
00:28:59 <LordBrain> mplus?
00:29:01 <jle`> gamegoblin: you can have them explicitly derive the ones you want in a list, if you want
00:29:08 <jle`> LordBrain: mplus is for MonadPlus :)
00:29:14 <LordBrain> oh i see
00:29:32 <gamegoblin> jle`: can you derive, say, monad, if the underlying type implements it?
00:29:37 <jle`> so it's kind of like a (* -> * -> *)-kinded monoid
00:29:44 <jle`> where MOnadPlus is a (* -> *) kinded monoid
00:29:46 <jle`> kinda
00:29:48 <jle`> gamegoblin: yeah
00:29:59 <LordBrain> i understand
00:29:59 <jle`> newtype Foo a = Foo (Maybe a) deriving Monad
00:30:09 <jle`> you need to enable GeneralizedNewtypeDeriving, though
00:30:21 <gamegoblin> jle`: ah, that’s what I was looking for, awesome, thanks
00:30:28 <jle`> np
00:32:16 <zipper> Is there a way to work around: `Module imports form a cycle:` ?
00:32:47 <LordBrain> yeah, hsboot
00:33:03 <LordBrain> https://wiki.haskell.org/Mutually_recursive_modules
00:39:06 <jonbobbly> jle`:It's used somehow in xmonad configurations. I guess I'll just have to keep pluging away at my book until I understand anything you just said. :P Thanks for the help, though.
00:39:23 <jle`> jonbobbly: heh, no problem
00:39:26 <jle`> jonbobbly: it's a function like (+)
00:39:29 <jle`> (+) works on multiple types
00:39:33 <jle`> integers, floats, etc.
00:39:38 <jle`> every type gets to define its own implementation
00:39:55 <jle`> so unless you know what type you're using <+> on, it's a bit tricky to know exactly what it does
00:40:20 <jle`> usually though, `x <+> y` represents a "choice", sorta, between x and y
00:40:51 <jle`> and zeroArrow is a "choice that is never taken", so `zeroArrow <+> y` = `y` in every case
00:40:56 <jle`> it really depends on the type itself, though
00:41:17 <jle`> so if you figure out what type you're using it on, we can probably look it up and it'll tell you :)
00:41:53 <jle`> like, it isn't too helpful to ask what (+) does, until you specify which type you're talking about, because every type gets to implement its own +
00:42:20 <jle`> we can say some "general things" about all usages of + though because of some laws/common sense we ascribe, like how it interacts with -, negate, *, etc.
00:42:45 <jle`> but to get past beyond the fact that zeroArrow <+> y = zeroArrow for every type, you need to know the type in specific, heh
00:43:11 <jle`> maybe someone more knowledgeable with xmonad can help, but i don't know anything about the types it uses, unfortunately
00:45:20 <jonbobbly> Yeah, thanks jle`. I'm still very new at both xmonad and haskell, so I don't really know anything at the moment. I'm working my way through "Learn you a haskell for great good"
00:48:43 * hackagebot hreader 0.0.1 - Generalization of MonadReader and ReaderT  http://hackage.haskell.org/package/hreader-0.0.1 (AlekseyUymanov)
00:58:06 <EponymicCycloid> Is there any hope of re-jiggering Monoid so that it's class SemiGroup a => Monoid a, where Monoid only has "mempty"?
00:58:21 <EponymicCycloid> That would be quite nice
00:58:43 * hackagebot glue 0.1.1.1 - Make better services.  http://hackage.haskell.org/package/glue-0.1.1.1 (seanparsons)
00:59:31 <supki> about the same amount of hope as for Apply f => Applicative f
01:00:09 <EponymicCycloid> Can we just fix all this stuff in the next version? It needn't even break very much; just re-export the things people expect to find in Monoid/Applicative
01:01:54 <Taneb> EponymicCycloid, it would break a surprising amount, with people who define monoid but not semigroup instances et
01:01:56 <Taneb> c
01:02:10 <EponymicCycloid> Yeah, but didn't we fix this with e.g. Monad and Applicative
01:02:19 <EponymicCycloid> Just add a "this will break" warning far in advance
01:02:26 <EponymicCycloid> we know exactly what will have to change, after all
01:08:29 <jle`> Monad/Applicative is a bit more beneficial and covenient, i think, and the return is much higher
01:08:35 <jle`> *was much higher
01:08:44 * hackagebot IPv6Addr 0.6.0.2 - Library to deal with IPv6 address text representations.  http://hackage.haskell.org/package/IPv6Addr-0.6.0.2 (MichelBoucey)
01:09:15 <jle`> just today i ran into several cases where it helped me make code better and more performant
01:09:22 <jle`> and this past week, several
01:09:37 <jle`> but the cases where Semigroup a => Monoid a would help me are much much rarer
01:10:56 <EponymicCycloid> It's just that there are a lot of things where people don't need mempty, and it'd be nice if we could specify
01:11:11 <EponymicCycloid> After all, the more specific your typeclass, the less likely you are to do the function wrong
01:12:10 <jle`> in cases where people don't need mempty, you can just use Semigroup, right?
01:12:33 <EponymicCycloid> Yeah, but most programmer don't bother with a Semigroup instance
01:12:38 <EponymicCycloid> and adding one is just duplicated work
01:12:58 <EponymicCycloid> standardizing on useful algebraic structures would be quite useful in ways that are hard to predict, I think
01:13:02 <EponymicCycloid> mostly in helping uniformity
01:13:36 <jle`> yeah, it's a theoretical niceness but i think the cost is just writing the instance yourself in one place, which is a bit annoying but nowhere near the cost that Applicative/Monad had
01:14:00 <jle`> in a practical sense
01:14:14 <jle`> Applicative/Monad fixed a lot more than just having to write instances
01:14:53 <jle`> i see the theoretical benefits but i think the the reason why Semigroup/Monoid will not have the same sort of traction is that the practical payoff is much, much lower
01:14:59 <jle`> not that i don't support it :)
01:23:44 * hackagebot cgrep 6.4.14 - Command line tool  http://hackage.haskell.org/package/cgrep-6.4.14 (NicolaBonelli)
01:44:30 * dramforever is always impressed by how readable *and* concise haskell code is
01:46:00 <dramforever> AFAIK so far no other non-haskell-like PL has this
02:00:55 <alexbiehl> Hi! I created two versions of an algorithm to compress sorted list of strings into an efficient data structure for lookups, use using lists of strings  (https://github.com/alexbiehl/hs-fst/blob/new/src/Data/FST.hs) and one using text + vector (https://github.com/hunt-framework/hunt/blob/fst/hunt-fst/src/Hunt/FST/Compile.hs). I tried to use vectors stream fusion to be as efficient as possible but it's much slower than the one with lists
02:00:55 <alexbiehl> and strings. What have I done wrong? 
02:01:56 <frerich> alexbiehl: Did you profile with optimizations enabled?
02:02:00 <alexbiehl> yes
02:02:47 <alexbiehl> the profiling is practically useless: 
02:02:48 <alexbiehl>  main.\                                      Main                                    1010           2   54.1   53.5    54.2   53.5
02:02:49 <alexbiehl>    ucArcs                                     Hunt.FST.Register                       1026       32935    0.0    0.0     0.0    0.0
02:02:52 <alexbiehl>    arcLabel                                   Hunt.FST.Arcs                           1025      541352    0.1    0.0     0.1    0.0
02:02:55 <alexbiehl>    arcTarget                                  Hunt.FST.Arcs                           1024      553005    0.0    0.0     0.0    0.0
02:02:58 <alexbiehl>    hashWithSalt                               Hunt.FST.Arcs                           1023      331162    0.0    0.0     0.0    0.0
02:03:01 <alexbiehl>    offset                                     Hunt.FST.Trie                           1022      596454    0.0    0.0     0.0    0.0
02:03:04 <alexbiehl>    nodes                                      Hunt.FST.Trie                           1021      861746    0.0    0.0     0.0    0.0
02:03:05 <alexbiehl>    outputs                                    Hunt.FST.Trie                           1020      139872    0.0    0.0     0.0    0.0
02:03:08 <alexbiehl>    nextOut                                    Hunt.FST.Trie                           1019      209808    0.0    0.0     0.0    0.0
02:03:11 <alexbiehl>    ucLabel                                    Hunt.FST.Register                       1018      132570    0.0    0.0     0.0    0.0
02:03:14 <alexbiehl>  
02:03:18 <alexbiehl> the interesting bits aren' shown :S 
02:03:24 <peddie> @where lpaste
02:03:24 <lambdabot> http://lpaste.net/
02:03:25 <Xe> alexbiehl: http://gist.github.com
02:03:32 <peddie> please
02:03:33 <alexbiehl> of course, next time
02:04:23 <alexbiehl> https://gist.github.com/alexbiehl/fd49fb369867bb69f8f5
02:24:18 <Matti__> hello
02:30:10 <matti55> so can i ask a question about haskell here?
02:30:31 <frerich> matti55: Shoot!
02:31:30 <matti55> ok so im learning haskell, and im trying the project euler excercises. Im getting stuck at the largest prime factor. I have no idea why my code isnt working...
02:31:45 <matti55> can i pate it in here?
02:31:52 <Taneb> @where lpaste
02:31:52 <lambdabot> http://lpaste.net/
02:32:04 <Taneb> matti55, lpaste is a pastebin you can use :)
02:32:45 <matti55> im a total irc noob im afraid, how do i best do that? just copy the urL in here?
02:33:02 <Taneb> Yeah, that works :)
02:33:34 <matti55> there we go :)
02:33:34 <matti55> http://lpaste.net/135563
02:33:48 * hackagebot timerep 2.0.0.1 - Parse and display time according to some RFCs (RFC3339, RFC2822, RFC822)  http://hackage.haskell.org/package/timerep-2.0.0.1 (koral)
02:34:37 <Taneb> matti55, when will that stop computing?
02:35:15 <Taneb> Oh, nevermind
02:35:19 <matti55> its supposed to stop when n reaches 0
02:35:25 <matti55> or 1 i mean
02:35:45 <merijn> Obligatory complaint about Project Euler being a terrible way to learn programming in general and haskell in particular
02:35:53 <matti55> :)
02:36:02 <merijn> @where exercises
02:36:02 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
02:36:23 <matti55> im learning via learnyouahaskell, but i wanted some practical excersises in the meantime
02:36:44 <merijn> Also https://github.com/bitemyapp/learnhaskell
02:37:07 <matti55> really nice! Thank you!
02:37:19 <merijn> @where+ exercises http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems https://github.com/bitemyapp/learnhaskell http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
02:37:19 <lambdabot> Okay.
02:38:43 <matti55> ill bookmark them all :) Im using dailyprogrammer already actually, but only for python (which i know much better then haskell)
02:40:36 <matti55> so its better for me to just stop working on this exercise and learn more about haskell?
02:41:26 <frerich> matti55: I suspect the problem is caused by dealing with different integer types. Instead of 'floor (n / x)' you might try 'n `div` x'
02:41:43 <matti55> ok ill try that
02:41:54 <frerich> matti55: In Haskell, the various numeric types are not converted implicitely, e.g. you cannot pass a Float if an Int is expected.
02:42:57 <matti55> ok, now it works! Amazing
02:43:10 <matti55> clearly i need to learn more about the type system
02:44:16 <monsieurp> pls kick Guest33674 
02:44:25 <monsieurp> it's an effing bot
02:45:09 <merijn> This is exactly why I would not recommend project euler, the numeric hierarchy is hardly the cleanest designpoint of haskell and Project Euler encourages playing fast and loose with numbers
02:45:56 <frerich> matti55: Dealing with numbers can be a bit daunting at first since it also requires a basic understanding of something called 'type classes' in Haskell.
02:47:40 <matti55> Ill check the resources you guys directed me to. Thanks a lot for helping me out!
02:57:16 <arianvp> Hey I want to unit test some DOM Manipulation lib im building
02:57:25 <arianvp> is it a good idea to make a free monad for all the dom manipulations possible?
02:57:41 <arianvp> and the 'implementation' is an IO interpreter. and the unit tests run on a Virtual dom interpreter?
03:17:15 <mpickering> arianvp: Can you not split the manipulations into pure/inpure parts and test the pure parts?
03:17:26 <mpickering> using a free monad will cause quite a hit in performance
03:19:25 <chpatrick> arianvp: could you maybe make a MonadDOM with an IO instance and a pure instance?
03:20:32 <mpickering> what kind of tests do you hope to write?
03:21:23 <magthe> is there some way to get Cabal to tell me if a GenericPackageDescription is deprecated?
03:33:50 * hackagebot spdx 0.1.2.0 - SPDX license expression language  http://hackage.haskell.org/package/spdx-0.1.2.0 (phadej)
04:22:55 <bennofs> magthe: I believe Distribution.PackageDescription.Check.checkPackage does that
04:23:08 <bennofs> (it may also produces other warnings though)
04:28:52 * hackagebot postgresql-query 1.3.0 - Sql interpolating quasiquote plus some kind of primitive ORM  using it  http://hackage.haskell.org/package/postgresql-query-1.3.0 (AlekseyUymanov)
04:32:30 <breadmonster> Hello.
04:32:48 <breadmonster> I'm trying to figure out how to carry around data type definitions.
04:33:21 <breadmonster> C++ has something like this: `template < typename T, int N >` but I can't think of anything equivalent in Haskell.
04:33:42 <breadmonster> So far, I've done a little hack for natural numbers.
04:33:53 * hackagebot hreader 0.0.2 - Generalization of MonadReader and ReaderT  http://hackage.haskell.org/package/hreader-0.0.2 (AlekseyUymanov)
04:34:05 <twoolie> breadmonster: there are type-level literals in ghc
04:34:06 <breadmonster> `data Z = Z deriving (Show, Read); data S a = S a deriving (Show, Read)`
04:34:09 <breadmonster> twoolie: How?
04:34:23 <dramforever> breadmonster: GHC.TypeLits
04:36:00 <twoolie> https://ghc.haskell.org/trac/ghc/wiki/TypeNats
04:36:03 <breadmonster> dramforever: Is this stuff hardwired into GHC?
04:36:06 <breadmonster> Or can I implement it myself?
04:36:07 <merijn> That's not the same, though
04:36:12 <merijn> breadmonster: DataKinds
04:36:15 <dramforever> breadmonster: sadly, yes
04:36:34 <dramforever> IMHO it's a bit insane to use
04:36:39 <twoolie> you can implement it yourself with church encoding\
04:36:42 <merijn> breadmonster: But the better answer is, that template values is something that you'd do using TH
04:36:52 <twoolie> ghc just provides a nicer/prettier interface
04:37:00 <breadmonster> dramforever: insane how?
04:37:05 <merijn> All the DataKinds/TypeLits suggestions here are pointless
04:37:14 <merijn> They are not at all comparable to the initial C++ example
04:37:22 <breadmonster> merijn: I'm just trying to see how far I can bend the type system.
04:37:23 <breadmonster> Oh?
04:37:44 <merijn> breadmonster: "template<int N>" has nothing to do with typing, but with compile time code generation
04:37:47 <twoolie> merijn: howso?
04:37:59 <merijn> i.e. Template Haskell, rather than type extensions
04:38:08 <dramforever> merijn: yes, there isn't even checking in that
04:38:19 <merijn> twoolie: Because DataKinds/TypeLits can't do any of the things that "template<int N>" do
04:38:22 <dramforever> well, if you don't use a template there will be no type errors
04:38:30 <merijn> dramforever: Sure there will
04:38:37 <merijn> dramforever: At compile time
04:38:43 <dramforever> merijn: yes
04:39:17 <dramforever> just like C++ template and haskell typeclasses are complete different things
04:39:50 <merijn> breadmonster: If you just want type level abuse examples I've got a few
04:40:14 <dramforever> breadmonster: another advice: try agda or idris
04:40:16 <dramforever> :)
04:40:28 <merijn> breadmonster: https://gist.github.com/merijn/dc00bc7cebd6df012c5e https://gist.github.com/merijn/6130082 https://gist.github.com/merijn/39dc86e345e87276c523
04:40:32 <twoolie> `template <typename T, int 3> func(T a)` is the same as `func :: Type t (n :: Nat) -> ()`
04:40:43 <merijn> twoolie: Not at all
04:41:05 <twoolie> and then the codegen is adding specialise pragmas.
04:41:19 <merijn> twoolie: Your haskell can't result in different compiled code for different values of 'n'
04:41:35 <merijn> twoolie: I think you are drastically underestimating the power of C++ templates
04:41:35 <breadmonster> merijn: No this isn't fair man.
04:41:38 <breadmonster> You're using magic.
04:41:54 <breadmonster> How much can you bend the type system using just Haskell?
04:42:05 <merijn> breadmonster: Which part is magic?
04:42:15 <merijn> Without extensions? Not very far
04:42:22 <breadmonster> `import GHC.Exts (Constraint)`
04:42:34 <merijn> breadmonster: How is that magic?
04:42:35 <dramforever> merijn: I can't access gist, so what's that? just describe them, I (think I) don't need to see the code
04:42:52 <dramforever> breadmonster: that's very useful
04:42:54 <merijn> dramforever: HList with a zip and apply operation
04:43:00 <dramforever> merijn: wow
04:43:04 <merijn> dramforever: A list with a restriction on length
04:43:13 <dramforever> k
04:43:14 <merijn> dramforever: And a constraint for "all types except X"
04:43:22 <dramforever> huh that?
04:43:29 * dramforever is interested in the last one
04:43:44 <lpaste_> merijn pasted “Restricted type variables” at http://lpaste.net/135565
04:43:49 <dramforever> merijn: thx!
04:44:03 <merijn> dramforever: It's a bit brittle in the sense that it fails for polymorphic values
04:44:14 <dramforever> yep
04:44:19 <merijn> dramforever: i.e. "foo 1" fails because it can't prove "1" isn't an Int
04:44:28 <merijn> But "foo (1 :: Integer)" works
04:44:46 <hodapp> singletons library is some type magic :P
04:44:57 <dramforever> breadmonster: import Unsafe.Coerce -- :)
04:44:59 <osdkigh> What are the best books for learning haskell?
04:45:09 <breadmonster> osdkigh: Learn you a Haskell for Great Good.
04:45:13 <merijn> osdkigh: https://github.com/bitemyapp/learnhaskell
04:45:13 <twoolie> depends what you want to learn
04:45:20 <dramforever> osdkigh: also Real World Haskell
04:45:27 <dramforever> oh and that link osdkigh posted
04:45:47 <maerwald> lyah does not have exercises, so I wouldn't say it's good for _learning_, but it's good for reading
04:46:15 <dramforever> hmm...
04:46:20 <osdkigh> Thanks. Should I start with Great Good?
04:46:33 <breadmonster> merijn dramforever: I know this sounds stupid, but are there any ingenious type hacks that don't involve explicitly subverting the type system?
04:46:39 <maerwald> so if you go with that, you should do your own exercises or find them elsewhere, otherwise you'll forget about it
04:47:10 <dramforever> breadmonster: "bend"....
04:47:12 <dramforever> :)
04:47:16 <dramforever> you can break it..
04:47:22 <merijn> breadmonster: Where do my examples subvert the type system?
04:47:30 <dramforever> is that "bent" enough?
04:47:31 <breadmonster> By importing GHC.Exts.
04:47:31 <merijn> They explicitly DON'T subvert the type system
04:47:37 <merijn> breadmonster: How does that subvert it?
04:47:37 <breadmonster> Can you do something like type arithmetic?
04:47:48 <merijn> breadmonster: One of the examples has type arithmetic
04:47:49 <breadmonster> merijn: Sorry, bad phrasing.
04:48:29 <dramforever> merijn: hmm so type level nats have linear time (+), quadratic time (*)
04:48:41 <dramforever> but the one in ghc has const time operators for both?
04:48:55 <dramforever> well, type level inductive nats 
04:49:14 <breadmonster> merijn: without using any extensions, can I implement type level arithmetic?
04:49:49 <merijn> no
04:51:26 <dramforever> looks like I need fundeps at minimum
05:31:46 <joncol> Is it common practice to commit the cabal.sandbox.config file to source control?
05:33:20 <slaterr> in persistent database how do I manually migrate the database when some data types changed? say, for example, that String changed to [Integer] and I want to supply an (String -> [Integer]) function to modify all the old fields 
05:33:46 <supki> joncol: no
05:33:46 <maerwald> joncol: I don't think so
05:34:10 <maerwald> it's more like adding your eclipse project files to source control
05:34:14 <maerwald> some people do that... but
05:35:04 <mpickering> installing anything stackage-* is worse than installing lens..
05:35:10 <mpickering> why do they need so many deps
05:35:21 <joncol> supki, maerwald> So if another coder (or me on another machine) wants to build stuff, he or she needs to manually do "cabal sandbox init"?
05:35:40 <maerwald> joncol: no, why? he can build without a sandbox
05:35:46 <maerwald> that's his decision
05:35:50 <joncol> maerwald> True
05:37:06 <joncol> :qa
05:37:17 <joncol> Damn Vim shortcuts :)
05:37:23 <maerwald> joncol: do you use irssi? ;)
05:37:26 <joncol> Yes :)
05:37:40 <maerwald> I figured... happens to irssi users all the time, all over IRC
05:38:08 <joncol> Must be a plugin somewhere that lets you use Vim shortcuts in Irssi?
05:38:12 <merijn> maerwald: I would wager it happens to any vim user that has a terminal IRC client
05:38:23 <merijn> Or maybe even a non-IRC client
05:38:33 <merijn> Heaven knows I've typed :wq into my email tons of times
05:38:46 <maerwald> merijn: I don't think so, my theory is that this is a usability error in the UI of clients
05:38:49 <supki> joncol: your cabal.sandbox.config won't help them anyway as it contains absolute paths to files on your machine
05:39:02 <joncol> supki> Good point!
05:39:14 <merijn> maerwald: Why not? Why would it only be irssi users?
05:40:05 <maerwald> merijn: well, theoretically there can be a terminal IRC client that has a distinct enough UI (despite being terminal) so that users don't mistakenly think it's a shell console. that was my point
05:40:18 <maerwald> but you may still be right that all/most others have this problem as well
05:40:24 <merijn> maerwald: Usually it's not thinking it's a shell console
05:40:49 <maerwald> merijn: well yes... or they don't know which window is currently active?
05:40:52 <merijn> maerwald: irssi looks very different from vim, usually it's because I have vim splitscreened next to irssi and tmux has the wrong panel highlighted
05:41:05 <maerwald> then that's sort of a wm issue then
05:41:07 <merijn> maerwald: Or, like my email client, it's just sheer force of habit
05:41:24 <maerwald> right
05:41:58 <maerwald> but let's not make a research project out of that :D
05:59:48 <joncol> Can anyone recommend a regex library? Only need capture groups and nothing special.
06:00:50 <maerwald> joncol: most people here would rather recommend using a parser lib, unless the problem you are trying to solve is really easier to do with regex
06:01:09 <joncol> maerwald> parsec then?
06:01:10 <whiteline> joncol: parsec is magic
06:01:24 <maerwald> joncol: I personally prefer attoparsec, but yeah
06:01:41 <maerwald> there is also a regex lib overview here https://wiki.haskell.org/Regular_expressions
06:01:55 <whiteline> parsec with user state makes every text parsing problem trivial
06:02:22 <joncol> I just have a string that ends with a number, and I want to get this number as an Int. Parsec == overkill?
06:02:37 <maerwald> not at all
06:02:45 <joncol> OK, cool. 
06:02:51 <mniip> joncol, read . dropWhile (not . isDigit)
06:02:53 <merijn> :t readMaybe . dropWhile (not . isDigit)
06:02:54 <lambdabot> Not in scope: ‘readMaybe’
06:03:00 <mniip> haha
06:03:02 <merijn> Ha
06:03:10 <merijn> :t Text.Read.readMaybe . dropWhile (not . isDigit)
06:03:11 <lambdabot> Read a => [Char] -> Maybe a
06:03:23 <joncol> Thanks.
06:03:35 <slaterr> are there any digits before the number you want
06:03:40 <whiteline> myParser = many1 letter >> many1 digit
06:03:47 <joncol> slaterr> No
06:03:54 <maerwald> unfortunately, most parser tutorials are garbage imo, so you'll have to do a little bit try and error
06:04:01 <whiteline> then you get a string that you can (read :: String -> Integer)
06:04:14 <whiteline> i have a good parsec example here: https://github.com/Lifelovinglight/randomTools/blob/master/harvestEmail.hs
06:04:33 <whiteline> or, "good", it's a hack but it's a complete example with user state
06:04:58 <joncol> whiteline> thanks. I'll bookmark it
06:05:27 <merijn> whiteline: read is terrible and you shouldn't use it
06:05:39 <whiteline> merijn: there are alternatives?
06:06:38 <merijn> Text.Read.readMaybe since GHC 7.6
06:07:00 <maerwald> that's just a safe version of read, yeah
06:07:24 <whiteline> but that's still nice to have
06:07:51 <slaterr> there's also reads
06:07:53 <slaterr> :t reads
06:07:54 <lambdabot> Read a => ReadS a
06:08:12 <merijn> slaterr: Yes, but readMaybe was added because reads is a confusing mess to use and inconvenient :p
06:09:06 <slaterr> I don't think it is a confusing mess or. and it can do things readMaybe can't
06:09:54 <slaterr> > reads "10foo" :: [(Int, String)]
06:09:55 <lambdabot>  [(10,"foo")]
06:10:35 <maerwald> so, why is that a list of tuples?
06:10:52 <geekosaur> because in theory it can return multiple parses
06:11:08 <maerwald> I'd say that's not what I expect from "read"
06:11:08 <geekosaur> with the String component being what's left after a given parse
06:12:17 <merijn> slaterr: It has to much stuff you don't care about when you want to use read
06:12:19 <whiteline> good for an impromptu recursive descent parser, but not if you have a parser and are merely unserializing tokens
06:13:57 * hackagebot music-dynamics-literal 1.9.0 - Overloaded dynamics literals.  http://hackage.haskell.org/package/music-dynamics-literal-1.9.0 (HansHoglund)
06:13:59 * hackagebot music-pitch-literal 1.9.0 - Overloaded pitch literals.  http://hackage.haskell.org/package/music-pitch-literal-1.9.0 (HansHoglund)
06:14:01 * hackagebot abcnotation 1.9.0 - Haskell representation and parser for ABC notation.  http://hackage.haskell.org/package/abcnotation-1.9.0 (HansHoglund)
06:14:03 * hackagebot musicxml2 1.9.0 - A representation of the MusicXML format.  http://hackage.haskell.org/package/musicxml2-1.9.0 (HansHoglund)
06:14:05 * hackagebot lilypond 1.9.0 - Bindings to Lilypond  http://hackage.haskell.org/package/lilypond-1.9.0 (HansHoglund)
06:19:08 * hackagebot music-score 1.9.0 - Musical score and part representation.  http://hackage.haskell.org/package/music-score-1.9.0 (HansHoglund)
06:19:10 * hackagebot music-pitch 1.9.0 - Musical pitch representation.  http://hackage.haskell.org/package/music-pitch-1.9.0 (HansHoglund)
06:19:12 * hackagebot music-dynamics 1.9.0 - Abstract representation of musical dynamics.  http://hackage.haskell.org/package/music-dynamics-1.9.0 (HansHoglund)
06:19:14 * hackagebot music-articulation 1.9.0 - Abstract representation of musical articulation.  http://hackage.haskell.org/package/music-articulation-1.9.0 (HansHoglund)
06:19:16 * hackagebot music-parts 1.9.0 - Musical instruments, parts and playing techniques.  http://hackage.haskell.org/package/music-parts-1.9.0 (HansHoglund)
06:19:29 <georgey-> how would you represent a phone number in haskell? I was thinking data Phone = Phone { phoneAreaCode :: [Word8], phoneNumber :: [Word8] }
06:19:57 <merijn> Why Word8?
06:20:20 <whiteline> georgey-: depends on how you need to use the number
06:20:25 <merijn> georgey-: Also, how about numbers without area codes?
06:20:29 <merijn> International numbers?
06:20:31 <whiteline> if you have no other need, store it as a strong
06:20:35 <whiteline> *string
06:20:45 <merijn> Also
06:20:51 <georgey-> merijn to avoid wasting more memory. Word8 represents a single digit
06:20:55 <merijn> Word8 is double wrong
06:21:10 <whiteline> word8 represents a number from 0 to 255
06:21:20 <georgey-> how is it wrong?
06:21:21 <merijn> georgey-: Please tell me how you plan to represent "+316xxxxxxxx" using you datatype :)
06:21:27 <whiteline> not a "single digit"
06:21:44 <merijn> Considering + is not a digit :)
06:21:48 <tdammers> +31-(0)6-24123456
06:21:53 <whiteline> combined with the fact that haskell lists are linked lists, two integers would be much better
06:21:53 <georgey-> I dont have to support international numbers
06:22:14 <Cale> georgey-: You're already using a linked list, so you're wasting huge amounts of memory. You could get away with ByteString, I suppose, but Text would be better, and String isn't really bad.
06:22:16 <merijn> georgey-: That's what the F-ing Bank of America devs thought too, end result I can't use my phone for two factor auth
06:22:36 <georgey-> whiteline: what if code area can have 0 in front? you cant represent that as an int
06:23:04 <merijn> I'd say use String/Text
06:23:05 <whiteline> georgey-: use a bytestring
06:23:27 <merijn> Why is everyone always telling people to do horrible things? :\
06:23:29 <tdammers> basically, if you're writing firmware for telco equipment, then you probably want to use a list of "keys" (0 through 9 plus * and #), otherwise, use a string or Text
06:24:03 <georgey-> merijn: good thing that I am not writing my program for you :). you still havent explained what is wrong with Word8
06:24:18 * hackagebot music-preludes 1.9.0 - Some useful preludes for the Music Suite.  http://hackage.haskell.org/package/music-preludes-1.9.0 (HansHoglund)
06:24:20 * hackagebot music-sibelius 1.9.0 - Interaction with Sibelius.  http://hackage.haskell.org/package/music-sibelius-1.9.0 (HansHoglund)
06:24:22 * hackagebot music-suite 1.9.0 - A set of libraries for composition, analysis and manipulation of music.  http://hackage.haskell.org/package/music-suite-1.9.0 (HansHoglund)
06:24:22 <merijn> georgey-: It can't represent +, it CAN represent non-digits
06:24:39 <georgey-> I would say string is horrible. Eq for String does the wrong thin lg for numbers
06:24:48 <merijn> georgey-: So newtype String
06:25:02 <merijn> "newtype Phone = Phone String", declare custom comparison/Eq and done
06:25:07 <georgey-> why would it represent non-digits?
06:25:09 <tdammers> Eq on phone numbers is pretty damn difficult anyway and requires a lot of domain knowledge
06:25:17 <merijn> > 25 :: Word8
06:25:18 <lambdabot>  25
06:25:27 <maerwald> tdammers: just dial it xD
06:25:30 <theorbtwo> georgey-: Word8 is any integer between 0 and 255.
06:25:43 <georgey-> theorbtwo: yes
06:25:47 <whiteline> georgey-: what you are actually trying to do is not accomplished by using a linked list of word8s, it's accomplished by using a bytestring
06:25:47 <tdammers> it's probably better to newtype String and not implement Eq at all, instead write a function that takes the two candidates plus all the context you need
06:26:04 <merijn> whiteline: No it's not, that's also terrible because now outputting the phone number is a pain
06:26:14 <Cale> I wonder what an algebraic data type taking all the world's telephone numbering plans into account would look like.
06:26:20 <merijn> Cale: Hell
06:26:27 <theorbtwo> Cale: See libphonenumber.
06:26:31 <whiteline> merijn: yes it is, but he insists on keeping it in a minimalistic format
06:26:33 <merijn> Cale: Probably only marginally better than addresses and/or datetime
06:27:26 <whiteline> as you'd store a phone number in a C array of chars i'd imagine, or malloc'd memory
06:27:30 <georgey-> if the requirement is: support only domestic numbers what makes string better than a pair of [Word8]? I have to parse string on each comparison
06:27:41 <theorbtwo> If you want to go really minimilistic with phone numbers, it's easy.  Your backing format is a string of digits, in most cases with a leading +.
06:27:57 <theorbtwo> georgey-: No you don't.  You have to normalize once, on entry.
06:28:16 <whiteline> ^
06:28:31 <georgey-> theorbtwo: then I have to parse it to extract area code
06:28:38 <theorbtwo> georgey-: Yes.
06:29:12 <maerwald> georgey-: here's a funny thread https://stackoverflow.com/questions/123559/a-comprehensive-regex-for-phone-number-validation xD
06:29:16 <georgey-> why would I parse it on each use, instead of doing it once?
06:29:34 <theorbtwo> georgey-: Does "each use" really include figuring out the area code?
06:29:37 <whiteline> data PhoneNumber = PhoneNumber { number :: ByteString, areaCode :: ByteString }
06:30:35 <georgey-> whiteline: ByteString can contain non-digits. list of Words8 cant
06:30:36 <theorbtwo> The concept of an area code is fairly portable, though many of them won't be areas in any reasonable sense of the word.  However, an area code without a country doesn't make sense.
06:30:58 <arw> maerwald: the specified mechanism e.g. for tel:-urls is "strip everything that isn't a number, then dial." iirc.
06:31:08 <georgey-> theorbtwo: it makes sense if the requirement is to only support domestic numbers
06:31:21 <theorbtwo> georgey-: What's your value of "domestic", BTW?
06:31:58 <georgey-> sorry if I am sounding argumentative, I just thing it is weird that String is being pushed instead of a list of digits
06:32:23 <whiteline> georgey-: but that doesn't matter because you'll only handle them using parsers/deserializers and accessor functions
06:32:57 <theorbtwo> georgey-: 1: There are often things in phone numbers that are not digits.  2: Word8 doesn't represent a digit, it represents a smallish number.  25 isn't a digit, but is a word8.
06:33:00 <whiteline> georgey-: a Word8 is not a "digit", it's one byte
06:33:20 <maerwald> the question is how the phone number in the code is used in the end: does some machine dial it automatically or a human?
06:33:25 <whiteline> a bytestring is not a "string", it's a byte vector of sorts
06:34:34 <georgey-> whiteline: right. do you know a haskell type closer to a digit than Word8? Word8 rejects more invalid data than Char does
06:34:44 <merijn> 1 is a digit, 123 has 3 digits, since Word8 represents 0-255 Word8 is not a digit
06:35:10 <maerwald> georgey-: make your own enum type?
06:35:11 <merijn> I say newtype + smart constructor to validate data
06:35:34 <maerwald> and then have a read instance
06:35:45 <theorbtwo> I'm with merijn on this one.  If you do that, it doesn't really matter what your backing store looks like.
06:35:47 <whiteline> georgey-: i think you are going about this all wrong. if you want to store an ipv4 address you'd store it as exactly four bytes
06:36:17 <theorbtwo> And, honestly, I'm not sure there's that much between a [Word8] and a ByteString.
06:36:20 <whiteline> you can do the same with phone numbers. i don't have enough domain knowledge about them, but you certainly can
06:37:07 <theorbtwo> If your value of "domestic" is US, 3+3+4 digits works for normal phone numbers.
06:37:36 <arw> I think canada follows the same convention
06:37:47 <arw> rest of the world, not so much.
06:37:53 <theorbtwo> (On the other hand, "911" is also a completely valid US phone number.  It's also one of the places where a properly normalized phone number does not start with a +.)
06:38:11 <merijn> theorbtwo: Sure it does
06:38:14 <geekosaur> NANP works in US, Canada, Mexico, and (most of?) the Caribbean. all bets are off elsewhere
06:38:17 <maerwald> @hackage digit
06:38:17 <lambdabot> http://hackage.haskell.org/package/digit
06:38:22 <merijn> +1 <rest of phone number here>
06:39:28 <theorbtwo> merijn: +1 911 isn't valid, I'm pretty sure, because 911 isn't dialable like that.
06:39:36 <georgey-> the point of [Word8] was to reject a more likely invalid input (such as creeping '-' inside a phone number, causing Eq not to work). I guess using smart constructors fixes that - but still, why Char over Word8 to represent a digit? you are wasting more memory for no gain
06:40:09 <merijn> georgey-: If you're using a list it doesn't matter anyway
06:40:12 <geekosaur> because Char doesn't require you to use a conversion step?
06:40:36 <geekosaur> (granting that that makes an assumption about usage)
06:40:39 <whiteline> georgey-: what will use the number
06:40:44 <merijn> georgey-: Any list is going to be at least, like 16 bytes per item anyway
06:40:50 <whiteline> are you just passing it around, or do you need knowledge about it?
06:41:23 <georgey-> I will be storing it in a database, matching it for equality, and displaying it
06:41:59 <whiteline> then you either use Text, or you need a proper industrial-grade phone number parsing library
06:42:11 <whiteline> there is nothing inbetween those alternatives
06:42:59 <theorbtwo> In the first case, I'd say use whatever nicely goes into and out of your database library.  In the second case, I recommend making a binding to libphonenumber.
06:43:06 <georgey-> why Text?
06:43:07 <theorbtwo> (Which is what android phones process phone numbers with.)
06:43:18 <whiteline> because either your users expect smart number matching or dumb number matching in the form of strings. don't create anything confusing inbetween those alternatives
06:43:32 <whiteline> georgey-: it's the standard
06:44:14 <georgey-> matching has to be smart. an extra - or - in a different position shouldbt break equality
06:44:28 <theorbtwo> georgey-: Normalize on input!
06:44:35 <whiteline> ^
06:44:48 <theorbtwo> Strip out all non-digits, insert the puncuation you want where you want it.
06:44:49 <whiteline> you can normalize the formatting easily, using parsec
06:44:59 * mniip appreciates the standardised IP address text representation format
06:45:01 <whiteline> parsec parsers are also very testable
06:45:02 <suls_> hope i won’t be far off topic with my question, if you were to start a new little haskell commandline project tomorrow, what would you use for: logging, http client, config, templating lib? and finally, how would you deploy it into production?
06:45:07 <theorbtwo> (Better, error out on puncuation where there shouldn't be any.)
06:45:44 <theorbtwo> 71-7555-1234 is probably better thrown out then silently changed to 717-555-1234.
06:47:33 <merijn> suls_: For http client I'd use http-conduit, which fits nicely with html-conduit for parsing html (if needed)
06:48:04 <georgey-> theorbtwo: so you mean actually store "717-555-1234"? instead of storing "7175551234" (or Word8 equivalent), and then adding - in a show or prettyShow function
06:49:41 <theorbtwo> No.  I mean you store it as 7175551234, and adding the dashes in show or prettyShow.
06:50:00 <georgey-> yeah
06:50:08 <whiteline> i'd just parse the input and store it as Text, dashes and all
06:50:20 <whiteline> simplicity is it's own virtue
06:50:37 <theorbtwo> Yes, the internal form should be as simple as possible.
06:50:47 <mniip> [16:37:41] <georgey-> the point of [Word8] was to reject a more likely invalid input (such as creeping '-' inside a phone number, causing Eq not to work). I guess using smart constructors fixes that - but still, why Char over Word8 to represent a digit? you are wasting more memory for no gain
06:50:54 <mniip> you don't know how Word8 works on the inside right
06:51:05 <georgey-> enlighten me
06:51:30 <georgey-> is it not just an 8-bit unsigned integer?
06:51:39 <geekosaur> all word and integral types are machine words
06:52:01 <mniip> georgey-, data Word8 = W8# Word#
06:52:11 <mniip> it stores a whole constructor and machine-sized word
06:52:36 <mniip> much like Char: data Char = C# Char#
06:52:37 <merijn> mniip: "it stores a constructor" constructors aren't guaranteed to exist at runtime
06:52:48 <Taneb> merijn, they nonetheless might
06:52:49 <georgey-> how much bytes does it use?
06:53:06 <geekosaur> 8 on a 64-bit platform
06:53:14 <maerwald> merijn: even without optimization?
06:53:18 <geekosaur> that is per individual Word8 value
06:53:27 <mniip> merijn, err, that's not what I meant
06:53:34 <georgey-> huh? Word8 uses 8 bytes?
06:53:34 <mniip> I meant it is a whole heap object
06:53:36 <mniip> with a heap header
06:53:58 <georgey-> why in the hell does it use 8 bytes
06:54:08 <geekosaur> because ghc works in terms of machine words
06:54:38 <merijn> maerwald: Yes, the default compilation scheme presented in the STG paper doesn't have a runtime representation for constructors
06:54:51 <georgey-> so I have no way to pick an integer that optimizes for size?
06:58:42 <whiteline> um, what about
06:58:46 <whiteline> unboxed types?
06:59:00 <geekosaur> that Word# *is* an unboxed type
06:59:14 <whiteline> oh
06:59:19 <whiteline> right
07:00:35 <merijn> Out of curiosity, do we have any library that can take a "Ptr Word8" (in some known encoding, preferably UTF-8) and leds me use that as backing for Text (or a Char vector) without the indirection of copying the data?
07:00:50 <merijn> Or do I have to invent my own library for that
07:00:58 <Fernandos> hi
07:01:10 <nabokovian> hello. quick question. is there a particular name for when one appends the type signature at the end of function application (e.g. not definition, but application). For example, LYAH has an example "read "Just 't'" :: Maybe Char"
07:01:26 <merijn> nabokovian: They're type annotations
07:01:28 <Fernandos> Is there a neat way to deal with databases in Haskell?
07:01:42 <merijn> Technically type signatures are also just type annotations
07:02:24 <nabokovian> thanks merijn. so appending a type annotation at the moment of application, does this assist haskell in determining which implementation of a function should be used? (for example, in the case that there are instances of typeclasses with different implementations)
07:03:23 <mniip> technical notice: different instances, implementations do not matter at all
07:03:42 <merijn> nabokovian: It specifies what type an expression should have (which should be equal to, or a more specific version of all it's possible types). The instance selection can happen based on types, yes.
07:04:12 <merijn> Sometimes (especially when using polymorphic return types) it can't always be possible to decide which instance to pick, so an annotation helps
07:04:30 <merijn> i.e. print (read "Just 't'")
07:04:32 <merijn> :t print
07:04:33 <lambdabot> Show a => a -> IO ()
07:04:56 <aweinstock> > 0 :: Float
07:04:57 <lambdabot>  0.0
07:04:59 <merijn> nabokovian: Since "print" can print any type that is an instance of Show and read returns any type that is an instance of Read, the compiler has a problem
07:05:01 <aweinstock> > 0 :: Int
07:05:02 <lambdabot>  0
07:05:17 <mizu_no_oto> >  print (read "Just 't'")
07:05:18 <lambdabot>  <IO ()>
07:05:19 <merijn> nabokovian: There's multiple types that are instances of Show and Read and it can't possibly know which one you meant
07:05:29 <merijn> mizu_no_oto: lambdabot has extended defaulting
07:05:37 <mizu_no_oto> Oh
07:05:42 <merijn> > show (read "Just 't'")
07:05:43 <lambdabot>  "*Exception: Prelude.read: no parse
07:05:48 <merijn> > show (read "()")
07:05:50 <lambdabot>  "()"
07:05:56 <mizu_no_oto> that's... interesting
07:05:58 <merijn> It defaults to () for this case :)
07:06:24 <aweinstock> > (read "Just 't'") :: Maybe Char
07:06:26 <lambdabot>  Just 't'
07:06:39 <merijn> Parens are redundant there
07:07:46 <georgey-> so why does haskell store everything as word machine size? 
07:07:52 <nabokovian> thanks guys. here is something that appears (to me) to be slightly different in purpose. perhaps i'm wrong. I found it in an fpcomplete post. the line i'm interested in is this one: "print . take 10 $ (randoms g :: [Coin])" (from this page: https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/randoms). The interesting thing to me is that we are applying "randoms" to a seed `g`, and telling it we want a return type of [Coin], w
07:08:54 <nabokovian> i guess my question is, how do we get from a seed, to one of the options in Coin?
07:09:21 <mizu_no_oto> :t randoms
07:09:22 <lambdabot> (RandomGen g, Random a) => g -> [a]
07:09:59 <merijn> georgey-: Because operations on words tend to be much faster
07:10:32 <maerwald> nabokovian: Coin has an instance of Random... but afais you could delay the coin type annotation in that example
07:10:57 <merijn> nabokovian: Coin has to have a Random instance for this to work
07:11:14 <merijn> nabokovian: The reason the annotation is there is because if it wasn't you have a similar problem to the Read/Show one
07:11:21 <mizu_no_oto> :t randoms $ mkStdGen 42
07:11:22 <lambdabot> Random a => [a]
07:11:42 <merijn> nabokovian: i.e. print wants a type that is a Show instance, and randoms returns a type that is a Random instance and there's multiple types that are both Show and Random instances
07:12:09 <merijn> So by annotating you remove the ambiguity by telling GHC "while this CAN produce any random instance, I want you to produce Coins"
07:12:26 <georgey-> is there a non-retarded reason for storing Word8 in 8 byted instead of 2?
07:12:33 <georgey-> 1*
07:12:49 <merijn> georgey-: I just told you, word operations are faster
07:13:11 <mizu_no_oto> nabokovian: Basically, it's the exact same issue as with 'show . read'
07:13:33 <nabokovian> i am starting to get it, slowly
07:13:36 <georgey-> why is ghc making a speed/size optimization choice for me instead of letting me decide?
07:14:00 * hackagebot observable-sharing 0.2.1.2 - Simple observable sharing  http://hackage.haskell.org/package/observable-sharing-0.2.1.2 (mararon)
07:14:26 <mizu_no_oto> nabokovian: typeclasses are interesting because you can be polymorphic on any part of the type, including the return type
07:14:42 <nabokovian> part of the difficulty for me is that when i'm looking at the instance on the fpcomplete page, i don't see `randoms` directly, but instead see `randomR` and `random` (one of which, i can imagine, calls `randoms`)
07:15:09 <mizu_no_oto> https://hackage.haskell.org/package/random-1.0.0.2/docs/System-Random.html
07:15:11 <merijn> georgey-: Same reason it has GC, because the people working on GHC almost certainly know better than you. There's a billion optimisation choices in GHC none of which it informs you about, so it seems rather arbitrary to pick this one to complain about
07:15:28 <mizu_no_oto> randoms is defined in terms of randoms
07:15:38 <mizu_no_oto> geh.  In terms of random
07:16:01 <nabokovian> ah, randoms  g      = (\(x,g') -> x : randoms g') (random g)
07:16:10 <maerwald> merijn: he can use C if he wants that sort of control
07:16:26 <Fernandos> Is there a known / optimal way of solving the timetable problem using graphs?
07:16:30 <nabokovian> hopefully this type of thing will be easier on my brain eventually
07:16:38 <merijn> Fernandos: Timetable problem?
07:16:50 <georgey-> merijn: no, people work on GHC certainly do NOT know if my specific use of Word8 needs to be optimized for size or speed
07:17:03 <georgey-> working*
07:17:10 <Fernandos> merijn: course timetable, or train station timetable
07:17:12 <Fernandos> ie.
07:17:46 <merijn> georgey-: This is a completely pointless discussion, that's the way it works, if you feel you know better, you are better of using another language than ranting here
07:20:07 <mizu_no_oto> georgey: if you're looking for packed arrays, they exist
07:21:08 <mizu_no_oto> georgey-: see ByteString (packed Word8 arrays), or nibblestring or bitwise
07:22:19 <maerwald> oh, we are back to ByteString already? Came up 30 minutes ago ;)
07:22:30 <Fernandos> merijn: "simple" example so you know what I mean by timetable problem http://chimera.labs.oreilly.com/books/1230000000929/ch04.html#sec_par-monad-timetable
07:22:33 <maerwald> we are running in circles
07:23:00 <icicled> is there a preferred library for accessing sqlite? (there are so many)
07:23:01 <georgey-> no wonder ghc is using over a GB of ram regularly.. ghc developers think using 8 bytes to store Word8 is a good idea
07:23:49 <whiteline> georgey: as compared to Java, Python, Ruby?
07:23:51 <Cale> suls: For logging, I would just use another thread and a Chan. For an http client, well, it sort of depends on what I'd be doing with that client. Perhaps the HTTP library? For config, that again really depends on what I'm configuring and what the options are like. Anything ranging from just using 'read' to JSON parsing to a custom Parsec parser to using Haskell source files might be an option. If by templating you mea
07:23:51 <Cale> n like HTML templating, maybe Heist?
07:24:31 <maerwald> georgey-: send a patch to ghc devs
07:24:32 <Cale> suls: It's hard to make recommendations which are any better than random things off of hackage without really knowing what the goal is.
07:25:38 <merijn> Fernandos: I'm not sure I entirely get the details, but perhaps you're looking for "topological sort"?
07:26:04 <merijn> Fernandos: If you have a DAG of dependencies, topological sort produces a scheduling for those tasks
07:27:32 <Fernandos> how does the topological sort work?
07:28:09 <Fernandos> I assume that's not one of the fastest traversal/scheduling algorithms for that type of problem, is it?
07:28:37 <Sindriava> Today's sensible chuckle: "Haskell's BDSM-oriented type system is often infuriating, but it's remarkably good at catching bugs at compile time."
07:29:01 * hackagebot heyefi 0.1.0.1 - A server for Eye-Fi SD cards.  http://hackage.haskell.org/package/heyefi-0.1.0.1 (ryantm)
07:29:15 <maerwald> Sindriava: a bit broad of a statement though... it only catches certain types (pun) of bugs
07:30:57 <leshow> what's the recommended package for benchmarking? Criterion?
07:31:24 <Fernandos> merijn: I've found http://hackage.haskell.org/package/algebra-dag or is there a recommended package?
07:32:16 <merijn> No clue, never done this in haskell
07:32:21 <merijn> leshow: Criterion seems to be, yeah
07:32:52 <Fernandos> merijn: ok nvm. I've looked it up. looks like a good fit, it's the only package :)
07:34:44 <Sindriava> maerwald: Well, doesn't mean the statement's not true :) I just found it funny.
07:35:29 <maerwald> Sindriava: well yeah
07:58:23 <leshow> can anyone thing of an implementation of this that might run faster?
07:58:25 <leshow> fun1 x = ((sum (filter even [0 .. x])) * 2)
07:58:43 <slaterr> how do I express a sum type in persistent share TH function?
07:58:44 <merijn> :t even
07:58:45 <lambdabot> Integral a => a -> Bool
07:58:53 <merijn> leshow: By fixing it to Int
07:59:09 <merijn> Or Integer, depending on the sizes you'll need
07:59:22 <leshow> if I change to Int it won't work for the length that i'm testing
07:59:24 <maerwald> merijn: shouldn't function composition also allow more compiler optimizations instead of all those brackets?
08:00:36 <merijn> How do the brackets affect anything?
08:00:40 <leshow> maerwald: the composition notation is just syntax sugaring as far as i know, it's not going to change execution time
08:00:45 <dwins> leshow: [0, 2 .. x] instead of filter even [0 .. x]
08:00:53 <maerwald> leshow: I read otherwise somewhere
08:00:55 <merijn> leshow: Composition isn't syntactical sugar
08:01:03 <merijn> leshow: Composition is jost another function
08:01:08 <maerwald> right
08:01:12 <leshow> fair enough
08:01:54 <leshow> dwins: what's [0, 2 .. x] ? i haven't seen that notation in a list before
08:02:03 <maerwald> and afair by composing functions that work on lists you might get only one traversal instead of several, I forgot how that was called
08:02:04 <Cale> leshow: fun1 x = let y = x `div` 2 in 2 * y * (y+1)
08:02:23 <Cale> Ought to be a good deal faster
08:02:30 <dwins> leshow: it lets you specify a step other than 1
08:02:46 <dwins> by demonstrating what that step is with the first two values
08:02:46 <maerwald> some sort of fusion
08:02:48 <merijn> maerwald: Without composition you can still do that
08:02:54 <maerwald> hmm
08:09:07 <leshow> thanks dwins, that implementation is 3 times faster than the one I had written
08:09:41 <dwins> leshow: cale's implementation should be far superior for large x
08:13:02 <leshow> wow, that one runs orders of magnitude faster. how come that implementation is so much quicker?
08:14:14 <Cale> leshow: Well, a couple multiplications and a division are eventually way faster than doing an unbounded number of additions.
08:14:45 <frerich> leshow: Cale probably does this in front of his screen now: http://goo.gl/xP6Xcw
08:15:02 <maerwald> xD
08:17:07 <_ashbreeze_> @search Fern Michaels Perfect Math
08:17:07 <lambdabot> Unknown command, try @list
08:17:23 <_ashbreeze_> sorry...
08:19:47 <Absolute0> What is {-# LANGUAGE XYZ #-} and where can I learn more about it?
08:21:13 <geekosaur> it is a pragma. https://www.haskell.org/onlinereport/haskell2010/haskellch12.html#x19-18800012 and https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/pragmas.html
08:22:14 <Absolute0> So it changes the language syntax?
08:23:38 <geekosaur> can change syntax, can change semantics
08:23:40 <ronh> or semantics. it depends on the specific extension
08:23:59 <geekosaur> in any case it's an instruction to the compiler to change some aspect of its behavior
08:24:16 <Absolute0> I first saw it on the scotty hello world example.
08:24:25 <Absolute0> https://hackage.haskell.org/package/scotty
08:24:34 <Absolute0> so what does {-# LANGUAGE OverloadedStrings #-} do?
08:25:08 <Absolute0> https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/basic-syntax-extensions#overloadedstrings
08:25:23 <Absolute0> I am so lazy... :/
08:25:30 <kadoban> Absolute0: It makes string literals behave kinda like numeric literals do.  It changes a literal  "Blah"  to something like IsString a => a, kinda like how a literal 5 is  :: Num a => a
08:26:40 <maerwald> ronh: but the haskell report says that compiler pragmas do NOT change a programs semantic... does that mean ghc violates this?
08:27:21 <kadoban> Most language pragmas just extend the language … so they allow things that otherwise wouldn't be valid haskell programs.
08:27:33 <kadoban> I'm not sure if any change existing programs to mean something else, I would suspect yes?
08:27:37 <Absolute0> Is this like monkey-patching?
08:28:05 <kadoban> Absolute0: I think that's too specific of a term to apply.
08:28:59 <maerwald> I dislike the idea of language extensions, but getting stuff into the formal spec if ofc more difficult
08:29:18 <Absolute0> of course?
08:29:27 <maerwald> well yes
08:29:36 <maerwald> you can't just hack up an extension and include it
08:29:42 <kadoban> Many of them are fairly conservative, useful and widespread.
08:29:51 <Absolute0> I just didn't know what "ofc" meant. :)
08:30:32 <ronh> maerwald, it changes semantics of a language, a program that failed without it compiles. I am not sure if there's a language extension that changes semantics of an already compilable program. if it does I guess it would violate haskell report
08:31:46 <theorbtwo> I'd argue that a program that doesn't compile has no semantics, so making it compile doesn't count as changing the semantics.
08:32:12 <Absolute0> Is monad monoid functor stuff taken for abstract algebra?
08:32:14 <theorbtwo> Either {-# LANGUAGE OverloadedStrings #-} is a null-op or the program won't type-check without it, right?
08:32:21 <sunnymilk> i like the extension(s) that made the typechecker turing complete
08:32:24 <Absolute0> I saw "monoid" in my abstract algebra textbook.
08:32:54 <theorbtwo> Absolute0: As I understand it, more or less -- the terms are analogous, but not neccessarily strictly the same.
08:33:17 <sunnymilk> unfortunately the typechecker doesnt actually compute things forever, if it gets stuck it just stops expanding types after a while
08:33:49 <monochrom> theorbtwo: have you considered "changing from no semantics to some semantics"? :)
08:40:03 <mizu_no_oto> Absolute0: A monad is a monoid object in the monoidal category of endofunctors
08:40:23 <shachaf> ...With composition as the monoidal operation.
08:40:39 <mizu_no_oto> Absolute0: An abstract-algebra monoid is a monoid object in the monoidal category of Set under Cartesian product
08:41:43 <mizu_no_oto> Some people are sloppy with their terminology and call a category-theory monoid object a monoid.
08:42:20 <dolio> theorbtwo: There are some corner cases where OverloadedStrings will result in an error where there wasn't one before.
08:42:29 <hodapp> alright, I hope optparse-applicative is a good example of how to parse applicatively, because I'm going to model something after it
08:42:43 <mizu_no_oto> They're different though, in that an abstract algebra monoid is one particular example of a monoid object.
08:43:40 <shachaf> Some people use different terminology. I wouldn't call it sloppy.
08:43:57 <nshepperd> i thought the term 'monoid' came from abstract algebra
08:44:47 <mizu_no_oto> nshepperd: monoid is originally from abstract algebra, yes
08:44:57 <nshepperd> oh, the category theory version is a generalization
08:45:09 <mizu_no_oto> yeah
08:45:10 <exio4> isn't everything in CT a generalization? :p 
08:45:41 <maerwald> exio4: like the category of generalizations?
08:46:05 <exio4> heh  
09:04:07 * hackagebot hset 1.0.0 - Primitive heterogenous read-only set  http://hackage.haskell.org/package/hset-1.0.0 (AlekseyUymanov)
09:09:34 <exio4> is there any monad transformer that'd give me "cooperative" concurrency? 
09:14:07 * hackagebot hreader 0.1.0 - Generalization of MonadReader and ReaderT  http://hackage.haskell.org/package/hreader-0.1.0 (AlekseyUymanov)
09:16:12 <erisco> yo why can't we get createDirectory in unix-compat
09:18:57 <bitemyapp> what's the difference between a latch and a lock?
09:19:07 * hackagebot postgresql-query 1.3.1 - Sql interpolating quasiquote plus some kind of primitive ORM  using it  http://hackage.haskell.org/package/postgresql-query-1.3.1 (AlekseyUymanov)
09:19:40 <erisco> bitemyapp, one has memory and the other is for a mutex?
09:20:31 <bitemyapp> erisco: memory?
09:20:40 <erisco> yeah, you know
09:20:53 <bitemyapp> you mean state like counting down?
09:20:55 <erisco> latches, d flip flops, jk flip flops, that sort of stuff
09:21:26 <monochrom> latch and lock in what context? digital circuits? locksmith?
09:21:33 <bitemyapp> Haskell, concurrency.
09:21:45 <monochrom> I have not heard of latch in concurrency
09:21:50 <bitemyapp> most popular example of a latch I've found is Java's CountDownLatch
09:21:52 <narendraj9> erisco: Latches and flip-flops are different. 
09:22:01 <monochrom> lock is mutex
09:22:02 <bitemyapp> monochrom: I hadn't heard of latches either until I was talking to some Snap devs.
09:22:12 <bitemyapp> monochrom: well, I know that, but I don't know what a latch is :)
09:22:13 <erisco> narendraj9, and? they also have similarity
09:22:16 <monochrom> perhaps they invented it homebrew
09:22:39 <monochrom> like how some people invented "1048"
09:23:02 <narendraj9> erisco: Oh. I though you said latches are the same as D flip-flops, etc. You didn't. Sorry.a
09:23:06 <erisco> is there a canonical cross platform file operations library?
09:23:13 <erisco> I see a package called "directory" for directory stuff
09:23:21 <erisco> seems a bit too niche
09:23:40 <monochrom> latch (digital circuit) is simply state variable
09:23:58 <monochrom> or more precisely:
09:24:06 <monochrom> latch (digital circuit) is simply state variable (computer programming)
09:25:30 <chardan> This is for C++, but it describes latches and barriers pretty nicely: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3666.html
09:26:41 <bitemyapp> chardan: thank you.
09:26:55 <chardan> bitemyapp: Most certainly! :)
09:27:37 <bitemyapp> chardan: looks like "countdown latch" is the accepted understanding. Thank you again!
09:27:37 <geekosaur> oh, condition variable
09:27:51 <geekosaur> ?
09:28:03 <geekosaur> although it looks like that term has been reappropriated for something related
09:28:07 <chardan> bitemyapp: No problem! I'll probably need to collect on that for my next Haskell question. ;-)
09:28:07 <geekosaur> but not identical
09:28:56 <bitemyapp> chardan: oh fair enough - if I can answer :)
09:44:09 * hackagebot heroku 0.1.2.3 - helpers for deploying to Heroku  http://hackage.haskell.org/package/heroku-0.1.2.3 (GregWeber)
09:45:14 <__monty__> I'm looking into the dependently typed features of haskell, gadts etc. And I can't seem to figure out how to implement dependent pairs in haskell, is this possible?
09:47:24 <ski> __monty__ : i don't think Haskell really has dependent types
09:47:53 <monochrom> no general dependent pair
09:48:13 <shachaf> People say "dependent types" but they really mean "fancy types".
09:48:34 <__monty__> ski: I realize it doesn't have full dependent types but datakinds and gadts get reasonably close. I was wondering if there exists an equivalent of the dependent pair.
09:48:36 <monochrom> only tiny special cases like "first field is type-level number, second field is array of that length"
09:48:37 <shachaf> It's an odd confusion. Dependent types are fancy, Haskell's types are getting fancier, therefore Haskell's types are getting more dependent?
09:49:09 * hackagebot android-lint-summary 0.2.1 - A pretty printer for Android Lint errors  http://hackage.haskell.org/package/android-lint-summary-0.2.1 (passy)
09:49:13 <shachaf> monochrom: That is still a type-level number, not a value-level number. Useful (potentially), but not dependent at all.
09:49:18 <monochrom> which has little to do with dependent pair and more to do with "has type-level number"
09:49:23 <erisco> gee you can't create a directory with System.IO ?
09:49:42 <monochrom> erisco, creating a directory is in System.Directory
09:50:00 <erisco> library seems incomplete
09:50:11 <erisco> for instance, how do you change file permissions on a directory?
09:50:19 <monochrom> I don't know
09:50:20 <erisco> or create a directory with particular file permissions in the first place?
09:50:24 <erisco> hm =\
09:50:25 <ski> __monty__ : if you want to express e.g. `(b ::) Bool * P b' i suppose you could use `data ExistsBool (p :: Bool -> *) :: * where WrapBool :: IsBool b -> p b -> ExistsBool p', assuming `data IsBool :: Bool -> * where IsFalse :: IsBool False; IsTrue :: IsBool True' -- i'm not sure to what extent this would work
09:50:32 <monochrom> what is file permission? :)
09:50:49 <merijn> erisco: Depends on the OS
09:51:09 <erisco> merijn, it is just stripped from the API altogether though it seems
09:51:25 <merijn> erisco: There is no common subset, so yes
09:51:55 <merijn> erisco: If you need permissions, use the windows and/or unix interfaces to provide a uniform API that supports the minimal necessary subset for your application
09:52:01 <erisco> but that doesn't help me write portable code :(
09:52:17 <erisco> I guess this will have to be a bit more involved then
09:52:35 <merijn> Sure it does, you decide on a uniform API for your application, implement that using the OS specific functions that exist and then conditionally import using CPP/flags
09:52:36 <monochrom> merijn: erisco is having precisely the problem of using "unix" vs "unix-compat". "unix-compat" lacks create-directory
09:53:07 * ski . o O ( `class Has a where type Is a :: a -> *' )
09:53:17 <erisco> yeah but the only functions being used are usleep and createDirectory
09:53:29 <erisco> so replacing unix/unix-compat shouldn't be hard
09:53:35 <erisco> I just have to figure out how to best do so
09:54:27 <erisco> okay, if the portability APIs are designed to be homogenous for all platforms then I'll just have to use something else
09:54:41 <erisco> I presume I can use conditional compilation to make this work?
09:54:55 <merijn> flags and CPP can detect platform, yes
09:55:03 <monochrom> yes, most people break down and go conditional compilation
09:55:35 <monochrom> it sucks, and Doug McIlroy is right
09:55:49 <ski> what does McIlroy say ?
09:55:50 <erisco> what did Mr. McIlroy say?
09:56:26 <monochrom> he says that conditional compilation is admitting defeat
09:56:47 <erisco> okay, but, the reality is the platforms are not the same
09:57:03 <erisco> maybe sometimes for some uses you can treat them as similar
09:57:20 <erisco> but realistically you need to do X on one platform and Y on another
09:57:34 <erisco> so I'd expect a lib that helps with portability to facilitate me doing that
09:57:39 <erisco> not preventing me from doing it
09:58:05 <merijn> monochrom: So what's he propose? Never run anything on more than one platform? >.>
09:58:14 <monochrom> well, there is still a difference between localized conditional compilation and conditional compilation infesting all modules
09:58:58 <monochrom> for example, unix-compat using conditional compilation is just cause, because then you don't have to
09:59:01 <bdesham_> The documentation for Data.Vector.Unboxed mentions that many of the functions do something "without copying"
09:59:07 <bdesham_> Is that just so you can judge your program's potential memory usage?
09:59:13 <bdesham_> The type is immutable, so it's safe to operate on parts of the original vector, right?
09:59:14 <monochrom> for example, base using conditional compilation...
09:59:34 <hodapp> interesting... optparse-applicative uses the constructor "forall x . MultP (Parser (x -> a)) (Parser x)" for the definition of <*>
09:59:35 <monochrom> "without copying" affects both time and space
10:00:24 <bdesham_> monochrom: oh, true
10:00:48 <hodapp> I suppose one can't really get around existentials/rank-2 in order to use a constructor as the definition of <*>
10:00:58 <monochrom> really, McIlroy said that in a context where someone suggested user-end code to use conditional compilation
10:03:09 <ski> hodapp : .. i suppose you could have constructors for `(<$>)' and `liftA2 (,)' instead ..
10:03:29 <hodapp> ski: hrm?
10:03:57 <ski> @remember DougMcIlroy Conditional compilation is admitting defeat.
10:03:57 <lambdabot> Good to know.
10:04:01 <ski> monochrom : like that ?
10:04:55 <monochrom> I don't know
10:04:58 <ski> hodapp : `iab <*> ia = fmap (uncurry ($)) (liftA2 (,) iab ia)'
10:05:12 <monochrom> but it was in haskell-cafe
10:05:52 <ski> @quote Computing.length
10:05:53 <lambdabot> Cale says: Computing lengths is admitting defeat
10:06:00 <monochrom> heh
10:06:05 <hodapp> ski: I see the code but I'm not sure what you're trying to say
10:06:44 <monochrom> @type (<*>)
10:06:45 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:07:03 <monochrom> @type liftA2 (,)
10:07:04 <lambdabot> Applicative f => f a -> f b -> f (a, b)
10:07:08 <ski> hodapp : you were talking about having a data constructor of type `forall a b. Parser (a -> b) -> (Parser a -> Parser b)'
10:07:59 <ski> hodapp : i was remarking that one could instead have one of type `forall a b. (Parser a,Parser b) -> Parser (a,b)' (or curried), and one of type `forall a b. (a -> b) -> (Parser a -> Parser b)'
10:09:10 * hackagebot smoothie 0.3 - Smooth curves via several splines and polynomials.  http://hackage.haskell.org/package/smoothie-0.3 (DimitriSabadie)
10:11:24 <ski> hodapp : or, instead of the latter, one could do a `CoYoneda' trick, so that `type Parser = CoYoneda ParserPrim' (assuming `data CoYoneda f b = forall a. FMapIncl (a -> b) (f a)') and then instead have a constructor of type `forall a b. (ParserPrim a,ParserPrim b) -> ParserPrim (a,b)'
10:12:48 <ski> (the point of doing that would be (a) to fuse together subsequent `(<$>)'s; and (b) to get slightly more canonical representations)
10:14:00 <hodapp> ski: looks like in all cases they're using existentials to get heterogeneous lists/trees of a sort
10:14:10 * hackagebot network-transport-inmemory 0.5.0 - In-memory instantiation of Network.Transport  http://hackage.haskell.org/package/network-transport-inmemory-0.5.0 (FacundoDominguez)
10:15:44 <ski> hodapp : "all cases" being ?
10:17:36 <hodapp> ski: however one chooses to have <*> act as a combinator to build something up for later use, I suppose
10:20:36 <ski> hodapp : .. i suppose in a sense "heterogeneous lists/trees of a sort" is what data constructors with existential components do
10:21:29 <hodapp> ski: I suppose so
10:30:00 <Hijiri> how can I reduce memory use during ghc compilation?
10:30:18 <Hijiri> I'm trying to compile something on a machine with low memory, and it keeps dying on pandoc
10:30:29 <rkaippully> is there a way to find the index of the constructor using GHC.Generics?
10:32:04 <kadoban> Hijiri: Tried -j1 ? Other than that I dunno.
10:33:24 <bergmark> rkaippully: maybe with this? http://hackage.haskell.org/package/generic-deriving-1.8.0/docs/Generics-Deriving-Enum.html
10:34:11 * hackagebot testing-type-modifiers 0.1.0.0 - Data type modifiers for property based testing  http://hackage.haskell.org/package/testing-type-modifiers-0.1.0.0 (JonasDuregard)
10:34:26 <Hijiri> kadoban: I thought about that but I thought 1 job was default
10:34:29 <Hijiri> I'll try it now though
10:36:28 <rkaippully> bergmark: Thanks, let me give it a try.
10:39:12 <__monty__> ski: Thanks, I guess your wrapping approach is the best I can hope for.
10:40:09 <kadoban> Hijiri: Depends how you're building I believe. My usual case is building pandoc as a dependency for something else, using cabal, which defaults to … number of cores or something.
10:42:34 <erisco> where do you pass the -cpp flag to ghc when doing cabal build?
10:42:44 <erisco> like, do I edit the .cabal or Setup.hs or what?
10:44:23 <bergmark> Hijiri: when i tried compiling on a low memory machine i saw that installing dependencies one by one used much less memory than if i just let it install the whole dep tree at once
10:45:04 <bergmark> was a long time ago though so ghc/cabal may have improved
10:45:52 <ski> __monty__ : well, i don't really know what in particular you're wanting to express. perhaps you can do something reasonable enough with indexed singleton types, i dunno
10:46:49 <sm> erisco: typically you configure it in each source file needing it with {#- LANGUAGE CPP #-}, or once for all of them in the cabal file with ghc-options: -cpp
10:46:50 <timemage> erisco, --ghc-options on the command line.  seems there's a ghc-options: directive for use in .cabal as well.
10:47:15 <erisco> sm, thanks
10:47:50 <adarqui> morte seems like a good tool to learn typed lambda calculus, no?
10:49:54 <tHEbIgtHEb> Nevermind got it working
10:50:38 <tHEbIgtHEb> But I don't understand why it wasn't working when used with a regular type instead of a typeclass
10:51:47 <__monty__> ski: I'm implementing red-black trees as an exercise (based on okasaki). So the type I want to write is for example: blacken :: Sigma(c :: Color, Tree c h) -> Either (Tree B h) (Tree B (S h))
10:53:10 <ski> __monty__ : ok. so perhaps `IsColor :: Color -> *' would work, then
10:54:51 <__monty__> ski : So the type would be IsColor c -> Tree c h... ?
10:55:17 <__monty__> ski : Does that really give a different result from just Tree c h?
10:55:21 <Hijiri> bergmark: kadoban: I've tried both suggestions and it still starts thrashing (and eventually errors out) halfway through pandoc
10:56:00 <Hijiri> I think I need a bigger swap file
10:56:07 <__monty__> ski : Maybe I'm just confusing agda's and haskell's forall quantification.
10:56:50 <ski> __monty__ : or possibly just using `data ColoredTree h where WrapColor :: Tree c h -> ColoredTree h' instead of `data ColoredTree where WrapColor :: IsColor c -> Tree c h -> ColoredTree h', if you don't need to recover `c' explicitly (perhaps you don't need to recover it, or perhaps it can be recovered from `Tree c h')
10:57:56 <erisco> how does cabal find modules in the package?
10:58:00 <ski> __monty__ : if you have an `data IsColor :: Color -> * where IsBlack :: IsColor Black; IsRed :: IsColor Red', then you can pattern-match on it. otherwise you can't (directly) recover the value of `c'
10:58:01 <erisco> I thought it mapped modules to directories
10:58:10 <erisco> and looked in hs-source-dirs
10:58:17 <ski> (but i don't know whether you need to be able to do that or not)
10:59:12 <sm> erisco: I think ghc finds the modules by mapping module names to file paths, but also cabal needs them specified in the cabal file for packaging
10:59:26 <ski> __monty__ : anyway, for clarity, i was suggesting `blacken :: ColoredTree h -> Either (Tree Black h) (Tree Black (S h))'
10:59:30 <erisco> specified how? hm
10:59:38 <ski> (it case it wasn't obvious)
10:59:39 <sm> take a look at the cabal user guide
10:59:44 <sm> or run cabal init
10:59:53 <sm> or look at any cabal file
11:00:05 <sm> they're linked as "package description" on hackage
11:00:39 <erisco> I see exposed-modules
11:01:03 <__monty__> ski : Thanks for clarifying, while for this function I don't need to recover it, I have others where I do need to do that.
11:01:04 <ecognium> hi everyone, I recently learned how to use the MaybeT monad to avoid a lot of failure checks. http://stackoverflow.com/questions/31096081/chaining-db-insertions-without-explicitly-checking-for-success. I would like to add one more DB statement to the mix and it happens to return m(). Since the failure is a db issue, I can assume it will always succeeds. Any idea on how I can return success in this situation? 
11:01:34 <ecognium> update :: PersistEntity val => Key val -> [Update val] -> m ()
11:01:34 <ecognium> Source
11:01:36 <ecognium> The specific function I am using in Persistent has this signature 
11:02:05 <ecognium> (meant to save has that (above) signature)
11:02:08 <erisco> I dunno
11:02:14 <erisco> added it to exposed-modules and still cannot be found
11:02:33 <erisco> it says to use the -v flag to see files searched for
11:02:37 <erisco> I add the -v flag and it doesn't tell me
11:05:01 <Eduard_Munteanu> ecognium, just lift update
11:05:22 <Eduard_Munteanu> :t lift
11:05:24 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
11:06:10 <lpaste_> chpatrick pasted “Constructor indexing with Generic” at http://lpaste.net/135592
11:06:36 <chpatrick> rkaippully: I gave it a shot: http://lpaste.net/135592
11:06:43 <chpatrick> it's not complete and there might be a better way
11:07:11 <ecognium> Eduard_Munteanu, thank you! I did lift inside MaybeT and that's what was giving me trouble. Just using lift works!. I accidentally I also discovered MaybeT $ liftM (Just) $ update... works too 
11:08:05 <Eduard_Munteanu> ecognium, I mean   runMaybeT $ do { ... ; lift $ update foo bar; ... }   (not liftM)
11:09:11 <ecognium> Eduard_Munteanu yes correct. I am using that version. I just meant, the alternative of using liftM works if I do MaybeT$ liftM. I will go with your suggestion of lift as it is cleaner. I was just surprised to find out about the alternative version. 
11:09:11 <Eduard_Munteanu> @src MaybeT lift
11:09:11 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
11:09:58 <Eduard_Munteanu> ecognium, that's just 'fmap', it turns the () into Just ()
11:10:02 <erisco> okay
11:10:04 <__monty__> ski : A different question entirely: With the datakinds extension a type, for example Nat, is also promoted to the kind Nat, how then does haskell know which Nat you're using for example in the Vec type?
11:10:11 <erisco> there is a library with Blubber.Server.IO in the .cabal
11:10:32 <erisco> and there is also an executable in the .cabal which depends on blubber-server, which is the name of the package
11:10:34 <ecognium> Eduard_Munteanu, got it. That makes sense now. Thanks! 
11:10:50 <erisco> ah, wait
11:11:01 <Eduard_Munteanu> __monty__, you can prefix it with "'" to clarify that you mean the lifted one
11:11:02 <erisco> Setup.hs is not part of it is it
11:11:14 <erisco> can Setup.hs depend on the things I am building?
11:12:05 <Eduard_Munteanu> __monty__, () is a value, () is a type, '() is a type, '() is a kind
11:12:18 <__monty__> Eduard_Munteanu: And how would you clarify you do not mean the kind but the type?
11:13:25 <Eduard_Munteanu> __monty__, well, you can't possibly have types in kind expressions
11:13:45 <Eduard_Munteanu> So it's context-sensitive.
11:15:25 <xplat> () is a type of kind * with members (namely ()), '() is a type of kind '() without members
11:16:49 <__monty__> xplat: Thank you, I did not know that.
11:17:52 <erisco> I am guessing that Setup.hs cannot depend on what I am building
11:17:53 <erisco> okay then
11:18:04 <erisco> so I potentially need a separate package? geez
11:18:36 <nart> hi
11:18:56 <__monty__> Eduard_Munteanu: So, for instance when I say data Vec :: Nat -> * where, the Nat is actually a kind? But I can define a function with type Nat -> Nat where I actually mean the kinds, so I have to be able to clarify with "'"?
11:19:40 <nart> if i write something like map (+1) $ filter (>1) xs ... is ghc gonna iterate the xs list once or twice ? am i better suited with using fold for perfomance ?
11:20:30 <__monty__> nart: Haskell is lazy so it should iterate only once.
11:20:31 <xplat> __monty__: no, the Nat kind can't appear in that context (Nat -> Nat as the type of a function)
11:21:07 <Eduard_Munteanu> __monty__, it is a (lifted) kind in Vec's definition
11:21:32 <__monty__> xplat: Can you not define a function with type * -> *? Then how is (->) defined?
11:22:03 <Eduard_Munteanu> __monty__, nope... (->) is builtin
11:22:38 <nart> __monty__: what about mapM, filterM with IO stuff
11:23:26 <arkeet> * -> * is not a type. it is a kind.
11:23:48 <arkeet> functions are values (so they have types.)
11:23:51 <xplat> __monty__: you have to use different syntax to define a type family (closest thing to a function at type level) than a plain old function
11:23:55 <arkeet> but the type of any value has kind *
11:24:10 <arkeet> (well, aside from unboxed values and stuff)
11:25:48 <Eduard_Munteanu> data Nat = Zero | Succ Nat; Zero :: Nat; Nat :: *; 'Zero :: 'Nat; 'Nat :: BOX
11:25:54 <xplat> the type level evaluation and the kind system ('type-level type system') are very different from and mostly unrelated to their value-level equivalents
11:26:29 <__monty__> nart: Not sure, someone with more experience will have to pitch in.
11:26:56 <Eduard_Munteanu> @src mapM
11:26:57 <lambdabot> mapM f as = sequence (map f as)
11:27:05 <xplat> type-level haskell is more like a typed prolog where you can define functional relations using function notation
11:27:33 <Eduard_Munteanu> nart, remember execution of IO actions is decoupled from evaluation
11:28:08 <nart> Eduard_Munteanu:mmm, so it's still lazy ?
11:28:31 <Eduard_Munteanu> nart, yes, and fusion rules still apply
11:28:44 <nart> Eduard_Munteanu:ah nice, thanks
11:28:57 <__monty__> Eduard_Munteanu, xplat, arkeet: Thanks, I think most of my confusion came from reading an explanation about kinds which said something like: "(->) is just a function with 'type' * -> *".
11:29:21 <__monty__> Eduard_Munteanu: What are these "fusion rules"?
11:29:55 <Eduard_Munteanu> __monty__, {-# RULES ... #-} such as  map g . map f = map (g . f)
11:29:55 <xplat> also, type families have something more like a mix of overloading and C++ template resolution instead of having kind-parametric polymorphism with kind classes
11:30:24 <Eduard_Munteanu> __monty__, also known as deforestation
11:30:36 <Eduard_Munteanu> (or short-cut fusion)
11:30:42 <xplat> probably in a future GHC it will have all of these things mashed up in a nearly incomprehensible way :(
11:31:06 <nart> The RULES mechanism is used to implement fusion (deforestation) of common list functions. If a "good consumer" consumes an intermediate list constructed by a "good producer", the intermediate list should be eliminated entirely.
11:31:09 <nart> didn't know about this one
11:31:15 <nart> thanks again Eduard_Munteanu
11:31:34 <arkeet> __monty__: the key there is the quotes in 'type'
11:31:38 <arkeet> it's not a type, it's a 'type'.
11:31:41 <arkeet> or rather, a kind.
11:31:51 <arkeet> (also, that is not the kind of (->))
11:31:52 <arkeet> :k (->)
11:31:53 <lambdabot> * -> * -> *
11:32:01 <__monty__> arkeet: Yes, the emphasis was mine however.
11:32:03 <arkeet> :k Int
11:32:04 <lambdabot> *
11:32:05 <ski> __monty__ : you could define a type function of kind `Nat -> Nat' (what xplat said)
11:32:07 <arkeet> :k Bool
11:32:08 <lambdabot> *
11:32:11 <arkeet> :k (->) Int
11:32:13 <lambdabot> * -> *
11:32:21 <ski> __monty__ : `(->)' is a type function, of kind `* -> * -> *'
11:32:29 <arkeet> yes.
11:32:54 <__monty__> ski: When you say type function, is this something defined with type family?
11:32:59 <arkeet> no
11:33:05 <arkeet> he just means something you can apply to another type
11:33:20 <ski> __monty__ : no, i mean a type expression of kind `k0 -> k1', for some kinds `k0' and `k1'
11:33:28 <arkeet> and that.
11:33:33 <ski> (what arkeet said)
11:34:52 <ski> __monty__ : .. just like by a (value) function, i mean a (value) expression (or the denotation of that) of type `t0 -> t1', for some (concrete) types `t0' and `t1'
11:35:24 <xplat> well, there's another tricky thing with types of a kind vs kinds of a type
11:36:22 <__monty__> ski: Maybe you could give an example for 'Nat -> 'Nat? (I'm confused because we just said you can't define a function with 'type' * -> *.)
11:36:35 <xplat> quantified variables at higher kinds (like m :: * -> *) don't include type families or type aliases in their range
11:37:14 <ski> (to a first approximation, concrete types are ones of kind `*'. concrete types are the only types that can be inhabited (have valued). with extensions `#' and (to some extent) `(#)' (and their superkinds) are also concrete. the kind `Constraint' (the kind of fully applied type classes, and generally the kind of constraints) isn't concrete in the ordinary sense. types of that kind have instances, not values)
11:38:15 <ski> __monty__ : you can define a type function with kind `* -> *'. examples are `Maybe',`Either String', and `Not' as defined by `type Not a = a -> Void'
11:38:41 <xplat> __monty__: rather than a type function (which is kind of an ill-defined piece of terminology) i would say (->) is a type constructor of kind * -> * -> *
11:38:43 <arkeet> ski: (can we really do that with type synonyms?)
11:39:15 * hackagebot pandoc 1.14.1 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.14.1 (JohnMacFarlane)
11:40:10 <xplat> 'Maybe' and 'Either String' are type constructors, but 'Not' is a type alias, which is a rather different thing
11:40:41 * arkeet argues that Not, by itself, isn't really a thing at all.
11:40:50 <xplat> type variables of kind (* -> *) can never be instantiated to 'Not', but may be instantiated to 'Maybe' or 'Either String'
11:41:23 <__monty__> ski, xplat: Thank you this really helps.
11:42:07 <__monty__> One more thing about the datakinds, is the type Nat an inhabitant of the kind Nat?
11:42:11 <xplat> this includes type variables used as arguments; therefore you cannot write things like 'Monad Not' or 'ReaderT Bool Not'
11:42:29 <arkeet> __monty__: no
11:42:30 <ski> __monty__ : given a data kind `Nat' (which you get implicitly by `data Nat = Z | S Nat'), iiuc, you can define a type function, e.g. `TwoTimes', of kind `Nat -> Nat' (`Nat' here is a kind) defined by `type family TwoTimes (n :: Nat) :: Nat; type instance TwoTimes Z = Z; type instance TwoTimes (S n) = S (S (TwoTimes n))'
11:42:42 <xplat> __monty__: no, the type Nat is of kind *
11:42:45 <arkeet> they are two things that sort of live in parallel.
11:42:51 <ski> arkeet : do what ?
11:43:10 <arkeet> ski: talk about the kind of a non-fully-applied type synonym
11:43:44 <xplat> __monty__: btw, the kind Nat is also called 'Nat, but the type Nat is not
11:44:11 <ski> arkeet : i don't see why not. of course one'll additionally have to keep track of how many arguments are required to get a saturated application
11:44:31 <arkeet> e(and likewise, the types Z
11:44:32 <arkeet> er
11:44:37 <gavaz> @src foldl'
11:44:38 <lambdabot> foldl' f a []     = a
11:44:38 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
11:44:43 <arkeet> (and likewise, the types Zero and Succ are also called 'Zero and 'Succ)
11:44:51 <__monty__> Do 'Z and 'S inhabit 'Nat?
11:45:00 <xplat> __monty__: and you can never write Foo :: 'Foo, though if you can write Foo :: Foo you can write 'Foo :: 'Foo also
11:45:02 <arkeet> yeah.
11:45:28 <arkeet> does lambdabot have datakinds?
11:45:32 <arkeet> @let data Nat = Z | S Nat
11:45:35 <lambdabot>  Defined.
11:45:37 <arkeet> :k Z
11:45:38 <ski> __monty__ : type constructors as well as type synonyms can be type functions (or not) -- you still need to keep track of whether it's a type constructor or a type synonym (and in that case the arity to get it saturated) .. similarly with data and type families, and associated types
11:45:38 <lambdabot> Nat
11:45:40 <arkeet> :k 'Z
11:45:41 <lambdabot> Nat
11:45:49 <arkeet> (they're the same thing)
11:46:04 <arkeet> ski: yeah ok.
11:47:13 <ski> arkeet : .. i suppose an alternate view of type synonyms would be that they're macros (and the staged application is implicit, but still present. which explains why the application has to be saturated)
11:48:56 <__monty__> Ok, last question: type synonyms are not promoted to kinds, can I use a type synonym together with a "kind synonym" or does such a thing not exist?
11:48:58 <xplat> ski: the 'type synonym as macro' view made a lot of sense in the old days, but now we have families which act very similar but definitely aren't marcros
11:49:28 <xplat> __monty__: actually type synonyms are promoted to kind synonyms
11:49:49 <ski> xplat : yes. i was pondering how the families complicate the issue
11:49:50 <ski> btw
11:49:54 <ski> @let type OfInt f = f Int
11:49:56 <lambdabot>  Defined.
11:50:00 <ski> @let type Square a = (a,a)
11:50:01 <lambdabot>  Defined.
11:50:05 <ski> @type (0,0) :: OfInt Square
11:50:06 <lambdabot> OfInt Square
11:50:17 <ski> shows that a type synonym can be a "higher-order macro"
11:50:32 <__monty__> xplat: I think this says otherwise, first item in the list of section 7.9.2: https://downloads.haskell.org/~ghc/7.8.2/docs/html/users_guide/promotion.html
11:51:02 <ski> (`Square' isn't explicitly saturated, but the definition of `OfInt' makes it so)
11:51:10 <xplat> __monty__: hm, i could swear i've used them
11:51:57 <__monty__> Btw, is "BOX" the sort of everything in haskell?
11:52:13 <mniip> yes, all kinds are of sort BOX
11:52:45 <__monty__> xplat: Is there a way to explicitly create a kind synonym?
11:54:06 <xplat> __monty__: maybe type synonyms get promoted to kind level but only on 7.10?
11:54:28 <ski> (btw, i'm not sure i like that families (and associated types) can be used to essentially distinguish between isomorphic types. i guess MPTCs with FDs can also do that, but then you at least have an explicit constraint that warns you)
11:55:16 <__monty__> xplat: That's possible I'm on 7.6 myself and that doc was for 7.9.
11:55:38 <mniip> too bad you can't do combinatory logic in the haskell typesystem
11:55:42 <__monty__> s/7.9/7.8
11:55:45 <mniip> er
11:55:56 <mniip> I think combinatoric calculus is the term
11:58:10 <xplat> @type Proxy :: Proxy ((0,0) :: OfInt Square)
11:58:11 <lambdabot>     ‘Square’ of kind ‘* -> *’ is not promotable
11:58:12 <lambdabot>     In the kind ‘OfInt Square’
11:58:12 <lambdabot>     In an expression type signature: Proxy ((0, 0) :: OfInt Square)
11:59:05 <mniip> you can't create type-functions on the fly, because then you have issues with equality testing being undecidable in general
11:59:06 <xplat> @type Proxy :: Proxy (Identity 0 :: OfInt Identity)
11:59:08 <lambdabot>     ‘Identity’ of kind ‘* -> *’ is not fully applied
11:59:08 <lambdabot>     In the kind ‘OfInt Identity’
11:59:08 <lambdabot>     In an expression type signature:
12:00:03 <xplat> weird.  but it seems to promote OfInt maybe?
12:00:31 <xplat> @let type Boo x = x
12:00:32 <ski> mniip : hm, i think it's rather an algebra, not a calculus (there's no bound variables)
12:00:34 <lambdabot>  Defined.
12:00:57 <mniip> ski, pretty much what I'm trying to say
12:00:58 <xplat> @type Proxy :: Proxy (True :: Boo Bool)
12:00:59 <lambdabot>     ‘Boo’ of kind ‘forall (k :: BOX). k -> k’ is not promotable
12:01:00 <lambdabot>     In the kind ‘Boo Bool’
12:01:00 <lambdabot>     In an expression type signature: Proxy (True :: Boo Bool)
12:01:22 <xplat> hm, guess they don't promote after all
12:01:41 <ski> @let type Bah x = Bool -> x
12:01:42 <lambdabot>  Defined.
12:01:52 <ski> @type Proxy :: Proxy (True :: Bah Bool)
12:01:53 <lambdabot>     ‘Bah’ of kind ‘* -> *’ is not promotable
12:01:53 <lambdabot>     In the kind ‘Bah Bool’
12:01:53 <lambdabot>     In an expression type signature: Proxy (True :: Bah Bool)
12:02:43 <xplat> mniip: yeah, combinatory algebras aren't any easier to decide equality for than lambda calculi.  and combinatory algebra unification might be even harder than in LCs ...
12:03:50 <mniip> xplat, why would an algebra be hard to decide equality for
12:04:20 <__monty__> ski, Eduard_Munteanu, xplat, arkeet: Thank you for your time.
12:04:24 <xplat> mniip: lots of them are, see 'word problem for monoids'
12:05:42 <ski> mniip : nontrivial rewriting laws/relations can make a quotient type with nondecidable equality
12:06:22 <erisco> okay
12:06:28 <erisco> so if I have two packages in development
12:06:31 <erisco> one depends on the other
12:06:45 <erisco> how do I, uh, make package B use the development version of package A?
12:07:04 <erisco> which is just sitting on my file system
12:07:23 <xplat> combinatory algebras aren't even monoids, just magmas with left identity
12:08:20 <xplat> erisco: this is one of the things that's easier with stack than cabal
12:08:31 <xplat> erisco: it's even in the stack FAQ
12:08:37 <erisco> well... what about cabal
12:08:41 <erisco> because everything is written with cabal
12:09:17 <erisco> I just need it to use a different source for the package
12:09:25 <erisco> that ought to be possible right?
12:09:34 <xplat> erisco: it's possible, technically
12:10:12 <xplat> erisco: i think you have to make a custom package source with a packages file that points at your dev version
12:11:15 <xplat> erisco: alternately, use a sandbox sitting above both and just install both in that sanddbox
12:11:38 <erisco> sitting above both?
12:11:51 <erisco> how do you make a sandbox above another sandbox?
12:12:20 <xplat> erisco: well, you could also just install one in the sandbox of the other using that sandbox-path option
12:13:26 <xplat> either way, it should work out as long as the dep solver is happy with the installed version (the development version) as satisfying the dependency and doesn't try to fetch that by itself
12:14:21 <xplat> you can use the --use-installed (?) switch to enforce that
12:16:29 <erisco> xplat, I just took bernalex's advice to do  cabal sandbox add-source $path
12:17:17 <xplat> if you're only using one or two custom packages preinstalling them like this works okay, the more packages are involved and the more interdependencies between them the more it pays to bite the bullet and build local sources
12:18:08 <xplat> hm, wait a minute
12:22:39 <kriztw> I want to create a type representing all [Bool] with length N or less, and then create instances for Enum and Bounded. Any tips for doing that?
12:23:00 <xplat> wow, cabal sandbox add-source lets you add any unpacked package as a source with no extra setup.  that *is* easy.  TIL
12:25:30 <xplat> kriztw: you want to make a GADT.  there's a 'Vec' type that's often used as a GADT example; you can modify it to have a max length instead of exact length by changing the empty Vec constructor to construct a Vec of any length, not just length 0.
12:26:36 <kriztw> xplat: thanks, that's a good idea! I'll try it out
12:28:42 <arkeet> xplat: doesn't that make a min length?
12:29:15 <xplat> arkeet: no, it's max length
12:29:17 * hackagebot digestive-functors-lucid 0.0.0.3 - Lucid frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-lucid-0.0.0.3 (athanclark)
12:29:32 <xplat> arkeet: try it!
12:29:43 <arkeet> never mind I was confused.
12:30:13 <kriztw> is there a library for type level naturals? every tutorial always rolls their own
12:31:23 <kadoban> Maybe we can use type-level naturals to count how many different implementations of type-level naturals there are on hackage.
12:31:48 <kriztw> :D
12:31:54 <arkeet> xplat: thought you meant to change the empty Vec constructor could take a list of any length.
12:32:12 <arkeet> s/could/to/
12:32:40 <arkeet> (while keeping the length type parameter at 0.)
12:32:44 <kriztw> I couldn't really find any with a quick hoogle search, but I take it there are a lot?
12:32:58 <frangor> hi
12:33:07 <arkeet> http://hackage.haskell.org/package/type-natural
12:33:17 <arkeet> not sure how widely used this is.
12:33:17 <xplat> arkeet: yeah, that would do min length
12:33:45 <arkeet> it's used by sized-vector.
12:33:59 <arkeet> but sized-vector is really unfortunate since it puts the length as the last type argument, so it can't be a Functor.
12:35:52 <xplat> yeah, it's following the convention of Agda, which is more flexible about where the argument of a Functor can go but less flexible about where the parametric and nonparametric arguments of a GADT can go
12:36:06 <xplat> so that convention is rather unfortunate in Haskell
12:36:47 <arkeet> I tried using it once and hit that.
12:36:59 <arkeet> maybe I'll try using fixed-vector next time.
12:37:16 <dolio> The convention in Agda is only because you couldn't put the length first, really.
12:37:26 <dolio> You can now, but you couldn't for a long time.
12:37:28 <arkeet> interesting.
12:37:38 <ski> dolio : how does that work ?
12:39:00 <dolio> ski: Parameters vs. indices were distinguished by being  before or after a colon in the header of a type declaration. So all your parameters would have to come before your indices.
12:39:10 <dolio> Unless the difference wasn't relevant to you.
12:39:25 <dolio> But for vectors it is.
12:43:28 <athan> edwardk: Would you be willing to add your algebra package to stackage? I've made a pull request to your stackage fork
12:44:56 <edwardk> athan: i mostly hesitate because that means putting up with the long term support noise and i want to make some big changes to it at some point
12:45:17 <edwardk> in essence though anybody transitively depending on it 'brings it into stackage' anyways
12:45:38 <edwardk> and my stackage fork is ancient, was just used to push up my original request to join
12:46:21 <ski> dolio : yes, but how does it work to allow different ordering ?
12:46:46 <ski> dolio : does it detect if an index is used only parametrically, and then treat it as an index anyway ?
12:46:48 <dolio> Oh. Parameters are inferred.
12:46:59 <athan> edwardk: Ahh right on :)
12:47:05 <ski> er .. treat it as a parameter anyway
12:47:24 <dolio> Even if they're where indices would have previously gone.
12:47:25 <athan> Yeah, the abelian / commutative split is a little different, but understandable for such a huge infrastructure
12:47:26 <ski> dolio : how would you define `Vector :: Nat -> Set -> Set' ?
12:47:40 <ski> (s/::/:/)
12:48:09 <edwardk> athan: its forced on me, because otherwise i can't use 'commutative' for 'commutative ring' =)
12:48:13 <ecognium> I have another question. I am using 'stack' to build my project. However, I would like to test out some libraries using GHCi but some of the modules installed via stack do not become available in GHCi. Any suggestions on how I can include them? For example, I just installed the http-types package and when I import it into my project and compile it using stack, it works fine. I cannot, however, import it into GHCi.
12:48:37 <edwardk> athan: i don't like duplicating structures between the additive and multiplicative but the whole thing doesn't work nicely otherwise
12:48:54 <edwardk> and you can use Log and Exp to switch conventions
12:48:55 <dolio> data Vector : Nat -> Set -> Set where [] : (A : Set) -> Vector 0 A ; ...
12:49:09 <dolio> And it figures out that the Set argument is a parameter.
12:49:37 <dolio> And so doesn't require the type to be large.
12:49:55 <ski> dolio : ok, so it "treats it as a parameter, if only used parametrically" (so that you don't get `Vector : Nat -> Set -> Set1'), correct ?
12:50:10 <dolio> Right.
12:50:17 <ski> alright
12:51:10 <frangor> hi
12:54:41 <xplat> i have an interesting (?) question.  are all the problems with polymorphic references only because of newIORef being typed too laxly?  that is, if you write newIORef (error "wrong") you can generalize it as 'forall a. IO (IORef a)' but if the a in 'forall a. a -> IO (IORef a)' couldn't be generalized again there wouldn't be a problem?
12:55:19 <athan> edwardk: Hmm, okay! Yeah it seemed like it haha. Do you think it would be easier in a dependenly typed language with typeclasses? I'm wondering if adding pi types to Haskell could have interesting interplay with -XConstraintKinds (and hopefully typeclasses)
12:55:49 <linman32> is a list recopied in this scenario? search a list, then pass in the rest of the list to a function that only reads it.
12:56:06 <sccrstud92_> linman32: dont think so
12:57:00 <ski> xplat : are you aware of the value restriction in the MLs ?
12:57:08 <linman32> sccrstud92_: what makes you say that?
12:57:34 <xplat> ski: yeah, that seems like a weird way to handle it though
12:57:37 <sccrstud92_> linman32: sharing generally prevents stuff like that from being recopied
12:58:12 <ski> xplat : an older (more fine-grained, and more complicated) system, implemented in SML/NJ (i think), used a different kind of type variable there, with some kind of restriction on how it could be instantiated. i don't know details
12:58:28 <bennofs> I've got a json document that has dates such as new Data(141324234) in it. What is the best way to parse this using json? (because of those dates, the json file is not valid)
12:58:34 <ski> (value restriction was a simplification of this, afaik)
12:58:58 <xplat> ski: the kind of type variable i'm thinking of is basically just a variable quantified in the metalogic
12:59:57 <linman32> sccrstud92_: thanks
13:00:00 <edwardk> athan: honestly? i'm not convinced there'd be much of an improvement. jacques carette has a nice type system he wrote where they can rename things as they move down the class hierarchy and the like, maybe something like that could help
13:00:37 <ski> xplat : i'm not sure if the older system used exactly that kind of variable for this. however, such meta-variables are used at least by O'Caml. they can't be generalized, only instantiated at the first use (which constrains them enough)
13:01:27 <athan> edwardk: hmm, okay!
13:01:33 <xplat> ski: hm, cool
13:09:19 * hackagebot game-of-life 0.1.0.0 - Conway's Game of Life  http://hackage.haskell.org/package/game-of-life-0.1.0.0 (marcusbuffett)
13:10:24 <rhaps0dy> How does GHC avoid allocating a new object every time a function is called?
13:10:49 <rhaps0dy> For example, if you're doing a game, and every frame you call a function to update state (very usual with the likes of netwire, albeit in small little states all around)
13:11:00 <dolio> ski, xplat: It'd be a pretty big ad-hoc thing to add to the type system just for unsafePerformIOed IORefs and friends.
13:11:36 <rhaps0dy> the naive way of compiling this is allocating new data every frame and writing to it
13:12:41 <sccrstud92_> rhaps0dy: immutability mostly
13:13:00 <xplat> dolio: well, since it has a simple logical description maybe it would be useful for something else too
13:13:27 <c_wraith> rhaps0dy: as a first approximation, you can pretend it does.  The allocator is fast.  And GC of things that don't survive the nursery generation is fast.
13:13:52 <c_wraith> rhaps0dy: There are optimizations that can and do get applied, of course.
13:13:57 <rhaps0dy> c_wraith: oh, cool
13:14:07 <rhaps0dy> so allocating isn't really slow?
13:14:14 <rhaps0dy> and GC sweeps that up fast enough?
13:14:15 <clrnd> hi! I'was wondering, what would you use to open a png, draw some text on it and save it to a file?
13:14:20 <rhaps0dy> sccrstud92_: that's the problem, immutability.
13:14:22 <c_wraith> No.  Allocating is bumping a pointer and checking to see if it's overflowed.
13:14:29 <xplat> c_wraith: well, allocating a lot hurts cache locality
13:14:36 <rhaps0dy> c_wraith: nice
13:14:54 <rhaps0dy> that sorta means GHC allocates a big hunk of heap and then uses it as it sees fit
13:15:06 <xplat> that probably causes more slowdown than the CPU cost
13:15:08 <rhaps0dy> it's not malloc every time
13:15:11 <c_wraith> rhaps0dy: that's correct
13:15:27 <bitonic> is there any reliable way, from TH, to know if the current GHC invocation is from `cabal`?
13:15:33 <rhaps0dy> xplat: that too, but if the objects are contiguous, it's not that bad
13:15:37 <c_wraith> rhaps0dy: that's the general pattern basically all GC'd languages use
13:15:43 <xplat> clrnd: convert from imagemagick
13:15:45 <rhaps0dy> ah, I didn't know that
13:16:02 <bitonic> I know there's `-fbuilding-cabal-package`, but I wonder if there is a less hackish way
13:16:09 <clrnd> xplat, jaja yes that's what I'm doing, but I was hoping for something in haskell
13:16:48 <rhaps0dy> clrnd: let's look up freetype and libpng bindings
13:17:50 <rhaps0dy> look up the freetype2 and the JuicyPixels  packages in hackage and figure something out :D
13:17:59 <xplat> clrnd: thanks to imagemagick's large functionality and insane API, you're pretty much better off using convert than an actual library binding (either of ImageMagick or of anything else) for anything convert can do
13:18:23 <ski> xplat : btw, in SML/NJ, instead of delaying the instantiation of a non-generalizable (noninstantiated by inference) tyvar (as O'Caml would do), it instead generates fresh skolem constants, that only unify with themselves (so if you define such a thing in the interactor, you get a more or less useless skolem constant, rather than a refinable meta-variable that can be instantiated by later use)
13:18:27 <xplat> and that's pretty much regardless of language
13:19:15 <clrnd> yeah, that's true
13:19:17 <rhaps0dy> xplat is likely right
13:19:34 <xplat> ski: that sounds potentially rather correct
13:19:38 <clrnd> rhaps0dy, yup, also I've never done anything as close to the metal as freetype2 looks
13:19:50 <clrnd> (pointers in my haskell? wut)
13:20:03 <ski> xplat : iirc, you could elicit somewhat similar behaviour in GHC, except that it didn't even generate new skolem constants, but instead used some preexisting constants like `Alpha',`Beta',... (or something like that, i don't recall details. can't seem to find docs for it) -- i'm not sure if this is still possible in GHC. preferable would be what O'Caml does
13:20:04 <rhaps0dy> thank you c_wraith.
13:20:20 <c_wraith> rhaps0dy: an example of a basic optimization GHC performs is converting tail calls to jumps.  There are lots of other things like that which can be done.
13:20:24 <ski> (and, failing that, at least generating fresh skolem constants, like SML/NJ)
13:21:04 <ReinH> (where by "tail calls", we mean "all calls")
13:21:38 <rhaps0dy> he meant a "jump without stack" :P
13:21:39 <ski> dolio : yes .. some kind of impure dialect extension (like Mercury has impure predicates that can be used with FFI/FPI, preferably to be wrapped in a declarative interface)
13:21:46 <ReinH> rhaps0dy: so do I
13:22:06 <rhaps0dy> ReinH: you need to keep a stack of values if it's not a tail call :\
13:22:14 <rhaps0dy> or not?
13:22:31 <ReinH> There's always some confusion around how stacks work in the RTS
13:22:34 <kadoban> Is there semantic autocomplete for vim that doesn't require ghc-mod? It seems like ghc-mod still isn't updated for GHC 7.10.x … I'm using hdevtools for some stuff, but no completion things seem to be available based on that?
13:22:35 <ReinH> there is no "call stack"
13:22:41 <rhaps0dy> yeah.
13:22:42 <ReinH> as you may be used to from other runtimes
13:22:44 <rhaps0dy> There is no calll stack
13:23:02 <rhaps0dy> but you need to keep the environment in a stack (wait, actually that's a call stack, just not likely the ABI call stack)
13:23:44 <ski> ReinH : there is an activation frame stack, though ..
13:23:48 <rhaps0dy> if I call func a = 1 + func (a+1), you need to keep that you need to add 1+
13:23:51 <ReinH> When the RTS encounters a function application that is "known" and fully saturated, it does a jump in its own call stack. There's a paper about this that I can't find right now.
13:24:11 <ski> (in this case, containing activation frames for `case' expressions)
13:24:30 <ReinH> The stack used to evaluate Haskell expressions might best be called an "evaluation stack" or a "pattern matching stack".
13:24:53 <ReinH> ski: yes
13:25:08 <ReinH> ski: but it doesn't make sense to speak of "tail call optimization" for that stack
13:25:22 <biglama> hi guys, I want to have my own mirror of Hackage
13:25:29 <ReinH> the tail call optimization performed by the RTS is on the RTS's runtime itself, not on haskell expressions
13:25:42 <ReinH> damn, what's that paper... :(
13:25:50 <biglama> I already downloaded Hackage using mirror-hackage, which gave me a local folder of 5.6Go
13:25:55 <rhaps0dy> whoah, this is interesting
13:25:57 <biglama> is the size ok ?
13:26:03 <ski> the only difference is that what counts as generating an activation frame is slightly different from a language implementation using call-by-value
13:26:21 <ReinH> Ah, found it http://research.microsoft.com/en-us/um/people/simonpj/Papers/eval-apply/eval-apply-icfp.ps
13:26:43 <ReinH> That's the one that describes the use of jumps by the RTS in optimizing its own calls
13:26:44 <ski> ReinH : it still makes sense to talk about "proper tail recursion" (slightly a misnomer) for it, though
13:26:50 <rhaps0dy> thanks ReinH 
13:27:03 <ReinH> ski: With the caveat that all "calls" are proper tail calls, I guess?
13:27:14 <ski> (this is not an optimization. it is a language (or implementation) property, that could possibly be implemented in several different ways)
13:27:15 <ReinH> I mean, it barely makes sense to talk about "function calls" at all
13:27:49 <ski> (btw, the misnomer part is that it says "recursion" rather than "calls")
13:28:30 <ski> ReinH : well, something isn't a tail call or not. it's a tail call or not, *wrt* a specific context
13:28:44 <ReinH> Ok
13:29:24 <ReinH> kadoban: I'm hoping that someone writes a plugin for ide-backend.
13:29:59 <ReinH> I'm considering writing one for neovim since I can (almost all of) it in Haskell
13:30:16 <ReinH> and I really want to take advantage of neovim's async features
13:31:01 <kadoban> Is ide-backend totally self-contained, or does it use something else? I never really found a full explanation of … what it does.
13:31:02 <ski> ReinH : one can talk about this both as a dynamic notion, and as a static notion (approximating the former). with by-need and by-name (as opposed to by-value), the static view is less useful. in any case, `not x' is not a tail call wrt the context `not x : []' containing it. it is (dynamically) a tail call, wrt `id (not x)', though
13:32:21 <ReinH> kadoban: unsure, I think it just talks to the GHC API
13:33:16 <ReinH> ski: Well, I don't think "tail call" is very useful for Haskell, full stop...
13:34:20 * hackagebot game-of-life 0.1.0.1 - Conway's Game of Life  http://hackage.haskell.org/package/game-of-life-0.1.0.1 (marcusbuffett)
13:34:22 * hackagebot game-of-life 0.1.0.2 - Conway's Game of Life  http://hackage.haskell.org/package/game-of-life-0.1.0.2 (marcusbuffett)
13:38:00 <kadoban> ReinH: I'll have to look into it more, it sounds nice though. I need to look at neovim as well at some point …
13:38:05 <isomorpheus> is there some special command to set :main to work when using `stack ghci test/Spec.hs` in https://github.com/hspec/hspec-example? when using the `cabal repl test/Spec.hs` command, :main works
13:39:36 <ReinH> kadoban: so far neovim has Just Worked for me with most of the vim plugins I used before, so I'm pretty happy.
13:40:19 <isomorpheus> when using `stack ghci test/Spec.hs`, the file has to be loaded in the repl using `:l test/Spec.hs` and then :main works
13:40:31 <ReinH> (it worked with all the ones I decided to use)
13:42:50 <isomorpheus> this might be why it is not working: https://github.com/commercialhaskell/stack/issues/355
13:42:59 <kadoban> Heh … ide-backend-client doesn't seem to have a license defined … fun.
13:43:22 <c_wraith> is that the one out of fpcomplete?
13:43:53 <kadoban> Ya, https://github.com/chrisdone/ide-backend-client which is linked from the blog post …
13:44:21 * hackagebot game-of-life 0.1.0.3 - Conway's Game of Life  http://hackage.haskell.org/package/game-of-life-0.1.0.3 (marcusbuffett)
13:44:23 * hackagebot mainland-pretty 0.4.0.0 - Pretty printing designed for printing source code.  http://hackage.haskell.org/package/mainland-pretty-0.4.0.0 (GeoffreyMainland)
13:44:59 <c_wraith> kadoban: huh.  With an empty license defined, I believe they've failed to authorize anyone to use it
13:45:19 <kadoban> c_wraith: Indeed. I wonder if that's a mistake or what? ide-backend itself has a real license (MIT)
13:45:56 <c_wraith> I'm sure it's a mistake.
13:46:05 <c_wraith> But it's one they really should fix
13:46:24 <ski> ReinH : it's clearly useful with strict data constructors, and when you want to strictly accumulate. however, the presence of non-strict data constructor and non-strict application means that one often have alternate (often incremental as opposed to bulky) means of writing iterative processes (in the SICP sense)
13:47:09 <kadoban> c_wraith: Seems like it would be. I'll create an issue in the repo and see what they say.
13:49:54 <ski> rhaps0dy,ReinH : "Proper Tail Recursion and Space Efficiency" by William D. Clinger in 1998 at <http://www.cesura17.net/~will/professional/research/papers/tail.pdf> defines the notion of "proper tail recursion", which is an abstract notion of the amount of space usage used (operational semantics)
13:50:51 <ski> ReinH,rhaps0dy : roughly, it expresses that an unbounded number of active tail calls is supported in bounded space
13:53:48 <ski> ReinH,rhaps0dy : one possible implementation of it is tail-call optimization
13:53:54 <ski> ReinH,rhaps0dy : another is treating the "stack" as a heap, never "returning", instead GCing it when it becomes full (this is "CONS Should Not CONS Its Arguments, Part II: Cheney on the M.T.A." by Henry G. Baker in 1994-02-04 - 1995-09 at <http://home.pipeline.com/~hbaker1/CheneyMTA.html>, used e.g. by the Chicken Scheme implementation. possibly one could also claim that SML/NJ also uses it, not sure)
13:54:56 <ski> ReinH,rhaps0dy : a variation of this is CPS-converting the source language (possibly using a trampoline in the host language), using the heap for allocating "stack frames"
13:56:15 <ski> ReinH,rhaps0dy : "proper tail recursion" also allows e.g., for debugging purposes, storing info about the last `n' calls, as long as `n' is bounded
14:02:01 <f-a> hello. I have a small backup script in haskell which uses `system "gpg -s ..."` to sign a file (ugly). Is there a better (as in, non invoking system, possibly even portable) way of doing this?
14:05:14 <oconnore> f-a: gpg doesn't support linking, although you can use a gpg supported interface to talk to another gpg process
14:05:17 <oconnore> f-a: https://gnupg.org/documentation/manuals/assuan/Introduction.html#Introduction
14:05:19 <slomo> f-a: there's the hOpenPGP package, maybe it does what you need
14:05:51 <oconnore> f-a: https://github.com/rethab/h-gpgme
14:07:11 <f-a> thanks oconnore and slomo, I'll see if I can use those
14:09:22 * hackagebot exp-pairs 0.1.3.0 - Linear programming over exponent pairs  http://hackage.haskell.org/package/exp-pairs-0.1.3.0 (Bodigrim)
14:09:24 * hackagebot keter 1.4.2.1 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.4.2.1 (ChristopherReichert)
14:19:49 <aaronlevin> 123BlaJew!n
14:19:54 <aaronlevin> whoops
14:20:38 <hpc> i think you meant to say hunter2
14:22:15 <aaronlevin> hpc: hah. 
14:24:23 * hackagebot structural-induction 0.3 - Instantiate structural induction schemas for algebraic data types  http://hackage.haskell.org/package/structural-induction-0.3 (DanRosen)
14:24:44 <hiptobecubic> A black Jew, eh? Well I'll be darned.
14:30:10 <jle`> DeriveAnyClass
14:30:11 <jle`> cute
14:30:37 <sccrstud92_> i used to use a top hat and monocle
14:30:41 <sccrstud92_> it was ineffective
14:36:07 <eacameron1> I'm very new to GHC dev but is it really true that the default build config for GHC in HEAD is set to use integer-simple and not gmp?
14:36:31 <eacameron> What config is used to build GHC releases?
14:39:18 <|f`-`|f> what? ski
14:39:34 <ski> ?
14:39:37 <linman32> when is it a good idea to use state monad vs a more-parametered function?
14:40:11 <ski> linman32 : when it gets tedious to thread (and manage the names of different versions of) the state
14:40:13 <jle`> linman32: a more-parameterized function sounds like it'd be closer to Reader
14:40:32 <jle`> but yeah, i think the point comes where it becomes tedious to do it by hand
14:40:40 <jle`> State and Reader etc. basically just abstract over doing things by hand
14:40:43 <|f`-`|f> the thing with bang patterns, and tail recursion ski
14:41:02 <ski> (if you're not threading, but only distributing, then an environment monad (like `Reader r' or `(r ->)') is more appropriate than a state monad)
14:41:22 <ski> |f`-`|f : hm, i didn't really talk about bang patterns, i think ?
14:41:55 <linman32> ski jle': thanks going to check out Reade
14:41:56 <|f`-`|f> strict data constructors <- well I only know bang pattersn as strict constructors, or variables
14:42:01 <linman32> *Reader
14:42:10 <jle`> Reader is typically practically useless unless you have a *lot* of threading
14:42:18 <jle`> er, a lot of nested same-parameter functions
14:42:33 <|f`-`|f> but it's useful for distributed
14:42:38 <|f`-`|f> ?
14:42:48 <int-e> eacameron: for all I know the default configuration uses integer-gmp. in fact that appears to be true for all configurations in mk/build.mk.sample except those for cross compilation.
14:42:53 <jle`> there's a point wher eit might become useful, but i think it's pretty rare
14:42:54 <ski> |f`-`|f : i'm not sure what you mean by the "variables" part. and the `!' annotations for strict constructors isn't strictly speaking bang patterns (though it's conceptually related)
14:43:08 <jle`> typically Reader is only useful in practice when you combine it with other types or transform it, etc.
14:43:46 <eacameron> int-e: can you show me where that config is set? I'm trying to change it
14:43:48 <jle`> the point where the manual distributing of parameters gets tedious is a pretty high threshold, i think, to benefit from rewriting everything in monadic style
14:44:06 <hiptobecubic> jle`, it's pretty good for monad tutorials
14:44:24 <ski> jle` : .. yes. but if you're already in monadic or idiomatic style, the cost is lower
14:44:33 <int-e> eacameron: if you're building your own ghc you should read https://ghc.haskell.org/trac/ghc/wiki/Building
14:44:52 <jle`> ski: yeah, that's what i mean.  if you're already in monadic style you're probably just transforming or using it with another monad
14:45:06 <linman32> jle' ski: it is just for a single recursive function. trade off state for more parameters.
14:45:08 <jle`> but just Reader alone if you're already in normal function passing style is a really awkward transition
14:45:14 <jle`> hiptobecubic: yeah, but i mean practical usage, heh
14:45:47 <hiptobecubic> Monad tutorials are all *about* practice!
14:45:47 <jle`> linman32: for a recursive function where state changes from call to call, you can use State, or manually thread the parameter too
14:45:58 <jle`> State is usually the best hwen you have multiple functions you want to combine
14:45:58 <ski> jle` : well, even if the environment would just be at the outermost level, it can still by a lower barrier to use it, than if you didn't already use monadic or idiomatic style
14:46:49 <ski> linman32 : it can sometimes be useful for a one-off case like that, but i'd say the main use is when it's not one-off, but pervasive to some section of your code (possibly spanning modules)
14:47:00 <drewbert> What gui libraries do you guys use?  The wiki tricked me into tinkering with grapefruit until I realized it hasn't had an update in three years.
14:47:13 <jle`> State's strongpoint is merging and sequencing mutltiple different Stateful things all together
14:47:20 <ski> linman32 : iow, when it shows up in the interface of your operations
14:47:20 <jle`> its helpfulness for one-offs is relatively small
14:47:44 <jle`> useful when sequencing or combining or calling stateful things from another, and threading the changes, etc.
14:48:03 <eacameron> int-e: thank you very much, now I see how it's depending everything on the build flavor; do you know what build flavor is used for releases? "perf"? I just want to make exactly the same as release, minus gmp-integer
14:48:19 <eacameron> *integer-gmp
14:49:11 <jle`> ski: i think you'd have to have a *lot* of nested calls, etc., to have `Reader r a` look nicer than `r -> a`, if you already had them written out as r -> a's with where/let's
14:49:16 <jle`> but i guess it's a matter of style
14:49:38 <int-e> eacameron: I'm not completely sure, but perf is supposed to match the default settings, so I expect that it's also used for releases. #ghc is probably a better place to ask this.
14:49:44 <jle`> but `ReaderT r m a` can often be nicer than r -> m a's
14:49:45 <ski> @let select :: MonadPlus m => [a] -> m (a,[a]); select [] = mzero; select (a:as) = return (a,as) `mplus` liftM (fmap (a:)) (select as)
14:49:46 <lambdabot>  Defined.
14:49:54 <eacameron> int-e: I wondered if I was on the wrong chan, thanks
14:50:44 <aupiff> I am just wondering, does anyone know of a fast sparse linear algebra library for haskell? I've been using sparse-lin-alg, but it's very very slow relative to the scipy library I was using before.
14:50:47 <drewbert> 2007 != "Currently Maintained" 
14:50:53 * drewbert rawrs angrily.
14:51:21 <ski> > replicateM 2 (StateT select) `runStateT` "abc"  :: [([Char],String)]
14:51:22 <lambdabot>  [("ab","c"),("ac","b"),("ba","c"),("bc","a"),("ca","b"),("cb","a")]
14:51:24 <ski> > replicateM 3 (StateT select) `runStateT` "abc"  :: [([Char],String)]
14:51:26 <lambdabot>  [("abc",""),("acb",""),("bac",""),("bca",""),("cab",""),("cba","")]
14:51:52 <aupiff> I might just try to write a more efficient pure-haskell sparse library if not
14:52:26 <drewbert> does anybody here do GUI programming with haskell?
14:52:27 <hiptobecubic> aupiff, you can call also call python from haskell
14:53:37 <ski> > replicateM 8 (state (randomR (0,9))) `runState` mkStdGen 142857
14:53:39 <lambdabot>  ([3,9,0,5,3,1,4,8],419123659 525453832)
14:53:51 <ski> linman32 : those ^ are sample one-off uses
14:54:34 <ski> jle` : mm
14:55:10 <jle`> yeah, it's good for sequencing and using with the monadic combinators :)
14:55:24 <drewbert> Projects.haskell.org is riding the strugglebus.
14:56:01 <hiptobecubic> drewbert, I made a really trivial thing with hsQml once
14:56:04 <aupiff> hiptobecubic: i'd rather not.
14:56:43 <linman32> > :t select
14:56:44 <lambdabot>  <hint>:1:1: parse error on input ‘:’
14:57:05 <linman32> ski: oh, i see def of select now
14:57:16 <mniip> :t select
14:57:17 <lambdabot> MonadPlus m => [a] -> m (a, [a])
14:57:22 <hiptobecubic> drewbert, I would not say I did a very good job. However, the GUI part of it was pretty easy to understand, as qml is kind of a weird variant of javascript.
14:57:45 <drewbert> hiptobecubic: My random thrashing just landed on gtk2hs which looks maintained and have the dialogs I need.  If it proves to obnoxious I'll definitely  check that out.
14:58:01 <timbod7> Stack looked great on first usage - however, I'm finding now that it doesn't reliable rebuild on changes. If I have a simple project with Main.hs depending on a few other modules, it only rebuilds if Main.hs has been touched. Touching the other modules doesn't seem to cause a rebuild...
14:58:02 <ski> linman32 : if you want to ensure all the elements in the supply are exhausted (so a linear rather than affine supply), you can filter the results on that
14:58:21 <drewbert> s/have/has/ s/proves to/proves too/
14:58:27 <ski> linman32 : you could also use the supply in an ordered fashion, consuming elements in order, rather than possibly out of order
14:58:55 <Hijiri> oh man
14:58:58 <Hijiri> if I knew about select
14:59:07 <Hijiri> I think I have reimplemented select at least 3 times
14:59:20 <hiptobecubic> drewbert, what i liked about hsqml was that it makes it pretty easy to separate out gui logic and application logic
14:59:23 <Hijiri> ;_;
14:59:54 <ski> linman32 : `select' is basically `select :: [a] -> [] (a,[a]); select [] = []; select (a0:as0) = (a0,as0) : [(a,a0:as) | (a,as) <- select as0]', i just generalized it to `MonadPlus'
15:01:25 <drewbert> hiptobecubic: Just checked it out on hackage. Looks cool.  It satisfies my only requirement of being cross-platform.
15:02:00 <mniip> > select "abc"
15:02:01 <lambdabot>      No instance for (Show (m0 (Char, [Char])))
15:02:01 <lambdabot>        arising from a use of ‘show_M468107293091084902713978’
15:02:01 <lambdabot>      The type variable ‘m0’ is ambiguous
15:02:05 <ski> linman32 : for ordered supply, use instead `grab :: MonadPlus m => [a] -> m (a,[a]); grab [] = mzero; grab (a:as) = return (a,as)' (or `grab :: [a] -> [] (a,[a]); grab [] = []; grab (a:as) = [(a,as)]' or `grab :: [a] -> Maybe (a,[a]); grab [] = Nothing; grab (a:as) = Just (a,as)')
15:02:14 <hiptobecubic> drewbert, you can see my pile of shit thing here. Granted it does *work* and I do use it. https://github.com/johntyree/traduisons-hs
15:02:58 <hiptobecubic> drewbert, qml file and haskell file with event handlers is here https://github.com/johntyree/traduisons-hs/tree/master/executables/UI
15:04:25 * hackagebot game-of-life 0.1.0.4 - Conway's Game of Life  http://hackage.haskell.org/package/game-of-life-0.1.0.4 (marcusbuffett)
15:04:52 <drewbert> hiptobecubic: this should prove very helpful
15:05:58 <d34df00d> Hi!
15:06:25 <d34df00d> I'm trying to do something with overlapping instances, hacking around GHC not considering context constraints of instance declarations.
15:06:37 <ski> linman32 : you can easily define something like `evalAffine :: Monad m => StateT [t] m a -> [t] -> m a; evalAffine = evalStateT' and `evalLinear :: MonadPlus m => ([t] -> Bool) -> StateT [t] m a -> [t] -> m a; evalLinear null ma ts0 = do (a,ts) <- runState ma ts0; guard (null ts); return a', to use in place of `runStateT'/`evalStateT'
15:07:02 <d34df00d> In particular, I want to have a typeclass with a function, say, `minfty :: a`, that would be (-1 / 0) for Rational a, and minBound for (Num a, Bounded a).
15:07:24 <d34df00d> Here is what I've come up with: http://melpon.org/wandbox/permlink/2BHciIJulnRwPFfr
15:07:52 <hiptobecubic> drewbert, I hope so. I wouldn't copy the structure of the rest of the app though. it's not very convenient or easy to use or easy to understand.
15:07:53 <d34df00d> But, sadly, the syntax for Witness here seems to be unsupported, and I would like to avoid enumerating all possible Fractional types as AdvancedOverlap wiki page suggests.
15:07:54 <hiptobecubic> or good.
15:08:12 <d34df00d> Is there any way to avoid enumerating all the types of interest for me?
15:08:26 <drewbert> "it's not very convenient or easy to use or easy to understand" So it's haskell code?
15:08:54 <NemesisD> could someone help me figure out what i'm doing wrong here with Generics? http://lpaste.net/135608 I'm writing an approximate equality typeclass for testing and i want it to generically crawl data structures, and to default to equality, but that would seem to require 2 default signatures? Also it compiles now but hangs on some values like Int
15:08:54 <linman32> ski: ok thanks
15:09:13 <hiptobecubic> drewbert, no. It's my code :)
15:09:20 <ski> linman32 : have fun
15:10:17 <NemesisD> is it possible to have two defaults, one for generic reps and one for an eq superclass?
15:11:09 <NemesisD> the hanging issue goes away when i actually manually define the instance for Int
15:11:49 <geekosaur> what does that code do if you do (3::Integer) =~ 3?
15:12:17 <geekosaur> oh, hm, that wouldn't affect manual vs. automatic Int instance
15:12:52 <NemesisD> geekosaur: No instance for (GApproxEq (Rep Integer))
15:13:21 <ski> NemesisD : hm, possilbly OWA could be a problem ?
15:13:34 <NemesisD> owa?
15:13:43 <ski> Open-World Assumption
15:13:55 <geekosaur> I was typing the question in when you said the manual instance worked. I'd been thinking defaulting bit you
15:14:03 <ski> that clients are allowed to add instances
15:14:43 <ski> so that the implementation can't be sure which of the (overlapping) defaults to use, since the client might make a type an instance of the more specific case, later
15:15:20 <NemesisD> ah, yeah i guess it makes sense that i'll need to define some manual instances
15:15:45 <NemesisD> pretty much only for the "leaf node" types, i.e. ones that aren't polymorphic?
15:18:19 <drewbert> I updated frag to compile with the latest ghc and base etc... kinda cool seeing haskell run a 3d game engine.
15:25:23 <ski> NemesisD : hm, perhaps. (i take you mean "open" or perhaps "parametric", as opposed to "polymorpic" ..)
15:26:34 <ski> drewbert : it might be nice if you could provide a link
15:27:16 <drewbert> ski: I didn't push my changes out to the world, but frag is on hackage http://hackage.haskell.org/package/frag
15:27:34 <broma0> Can anyone recommend a good GADT tutorial/article/etc for a GADT beginner? 
15:27:58 <ski> hm, maybe one could add a notice with a link to it, at the end of
15:28:04 <ski> @wiki Frag
15:28:04 <lambdabot> http://www.haskell.org/haskellwiki/Frag
15:29:06 <ski> (oh, i see, your changes are not in that package)
15:31:45 <drewbert> If you think it's worth it, I'll clean up my changes and try to get in touch with the maintainer.
15:37:13 <lamefun> is there a typeclass for subsets?
15:37:29 <mniip> subsets?
15:38:49 <lamefun> class Subset a b where sub :: b -> Maybe a; unsub :: a -> b
15:39:48 <sm>  drewbert: nice, can you publish with a modern cabal file and stack.yaml
15:39:50 <c_wraith> Err.  I'd call something like that a partial-isomorphism
15:40:00 <c_wraith> Which is a terrible name in its own way
15:40:06 <c_wraith> But it doesn't restrict you to thinking about sets
15:40:17 <slaterr> hello. how do I store existing data type with persistent package? do I have to manually generate all the typeclasses etc that are generated with share function? or do I have to create a new data and then manually map between the types? neither solution seems optimal, and would require plenty of boilerplate
15:40:29 <sm> that's kind of a showcase for haskell in gaming since forever and deserves to work
15:41:35 <c_wraith> lamefun: the Prism abstraction in lens gives you that pair of operations.  But it doesn't use classes, since there is more than one way to have a partial isomorphism between types.
15:44:22 <shachaf> Prism gives you slightly more than that.
15:44:32 <c_wraith> I didn't say that's *all* it gives you..
15:44:35 <c_wraith> :)
15:48:03 <maerwald> sm: I couldn't even get it to compile last time I tried
15:50:13 <sm> not surprising without a maintainer.. frag is old!
15:51:00 <sm> created 2005, nice
15:51:19 <maerwald> it's really odd that nothing more has been done in that direction
15:51:33 <sm> last commits in 2008 by dons, porting to ghc 6.10 and base 4
15:51:43 <maerwald> I know of another thesis about haskell gaming, but it doesn't deal with hardcore 3d FPS
15:52:09 <drewbert> sm: I sent the listed maintainer an email.  If he doesn't respond then I'll go ahead regardless.
15:52:20 <sm> drewbert++
15:53:15 <sm> a move to github or darcs hub and a just-works stack build config would do wonders
15:54:21 <sm> check this out, dependencies: array, base (==4.*), GLUT, OpenGL (>=2.0), random
15:54:57 <maerwald> the code looks quite functional (as in: regular haskell), nothing too odd
15:55:29 <maerwald> afais he handles global state with IORef?
15:55:44 <sm> and why not
15:56:12 <maerwald> I was wondering if reification can be abused for that to some extent
15:56:17 <sm> when you are the only working 3d shooter in 10 years, you get to code it any way you please :)
15:57:16 <sm> is it FRP-ish ?
15:57:50 <sm> oh yes.. "AFRP"
15:58:48 <hiptobecubic> it's yampa no?
15:58:55 <hiptobecubic> or am I remembering incorrectly
15:59:43 <sm> there's one mention of yampa in the code ("-- functions to connect Haskell and Yampa").. so I guess..
15:59:44 <maerwald> sm: Figure 3.1 looks interesting (although the graphics... xD
16:00:32 <broma0> Is it possible to model a fixed height btree with GADTs?
16:01:42 <maerwald> sm: but this is too hard for me currently
16:02:01 <sm> yeah, quite a bonus that this code is actually documented with a thesis
16:02:56 <maerwald> also, FRP is hard too from what I heard
16:05:19 <bernalex> sm: frag builds & works fine in gentoo.
16:05:32 <bernalex> & yes, it is FRP.
16:05:38 <bernalex> the code is actually kind of delicious in places.
16:05:47 <bernalex> I recommend the two theses written on it.
16:06:23 <sm> nice. Functional Programming and 3D Games is linked from the wiki page, what's the second ?
16:06:42 <bernalex> sm: they, confusingly, both have the same name, lol
16:06:51 <sm> smooth! :)
16:08:04 <sm> by two different people ?
16:08:26 <bernalex> sm: yes. Mun Hon Cheong, and Jayatheeban Soundararajan.
16:08:49 <bernalex> sm: the first is from 2005, the second from 2007. IIRC, both are from the University of New South Wales.
16:12:41 <SrPx> Is it a bad design to ignore Maybe when creating zip functions, and just return the same structure if you attempted to go to a ghost position? Is there any example of where this could limit the api user?
16:13:35 <pavonia> What is a ghost position?
16:13:37 <sm> bernalex: thanks, I've added the second one to https://wiki.haskell.org/Frag
16:13:43 <SrPx> Like the parent of the root
16:13:53 <bernalex> sm: great!
16:14:43 <pavonia> SrPx: Do you have an example? I have no idea what Maybe and zip has to do with it
16:16:12 <Jello_Raptor> what's the difference between "class Fooable a where data Foo a :: *" and "class Fooable a where data family Foo a :: *"
16:17:01 <Jello_Raptor> also can I put constraints on type families? something vaguely like "class Fooable a where data Eq (Fooable a) => Fooable a :: *" ? 
16:17:02 <arkeet> is the latter accepted?
16:17:23 <Jello_Raptor> they're both accepted :/ 
16:17:30 <arkeet> I think they're the same then.
16:17:50 <arkeet> I wouldn't put constraints like that for the same reason I wouldn't put constraints on regular data types 
16:19:04 <Jello_Raptor> arkeet: I'm using them to express invariants in a logical construction. Basically there's a set of types that'll implement these type-classes, and they need to have these relationships. I'd like to check that at compile time. 
16:22:11 <Jello_Raptor> also is there anyplace where I can specify what the complete implementation of a typeclass is? 
16:22:38 <SrPx> pavonia: woops, I mean, zippers
16:22:45 <Jello_Raptor> (as in, there's a class with 3 functions but any 2 are uniquely define the other)
16:22:59 <SrPx> pavonia: the example is from Data.Zip, Functions like firstChild, parent, left, right return Maybe TreeLoc.
16:23:47 <pavonia> Oh, I see
16:23:49 <SrPx> I wonder if it would be that bad to just return a TreeLoc. If there is no location to do, it just doesn't change the location. No need to report it to the user. But maybe I'm not seeing a situation where the user would really really need that maybe
16:23:59 <SrPx> to go*
16:24:19 <SrPx> oh god, the example is from Data.Tree.Zipper***
16:24:28 <SrPx> damn I'm doing too many things at the same time, sorry
16:28:33 <sm> "Y
16:33:39 <Jello_Raptor> I suppose I want functions on types I can use in type signatures, and to be able to use typeclasses as kinds. 
16:33:46 <Jello_Raptor> or something vaguely similar
16:33:51 <Jello_Raptor> :/ 
16:35:05 <c_wraith> Jello_Raptor: that sounds like TypeFamilies and ConstraintsKinds
16:35:25 <c_wraith> Well.  ConstraintKinds gives type classes kinds.
16:35:25 <Jello_Raptor> c_wraith: I don't really understand ConstraintKinds at all :/ 
16:35:37 <c_wraith> It just lets you talk about Constraints like any other type.
16:36:03 <c_wraith> .. Any other type that has 0 values, not even bottom.  So, you know, like any promoted type.
16:36:29 <sm> maerwald: yeah, that's some clever code
16:36:51 <sm> (and bernalex)
16:37:03 <Jello_Raptor> c_wraith: hmm, *reads blog posts about that*
16:37:21 <maerwald> sm: well, is it just clever or is it difficult to understand?
16:37:50 <bernalex> maerwald: the portions of the frag code presented in the two papers is mostly very elegant.
16:37:51 <sm> I think it's pretty clear, just doing some clever stuff
16:38:09 <arkeet> Jello_Raptor: for the typeclass definition thing uh
16:38:10 <sm> BSP rendering is just clever, for a start, I have no other word for it :)
16:38:10 <maerwald> bernalex: I barely care about elegant, more about understandibility :)
16:38:15 <arkeet> look up the MINIMAL pragma
16:38:30 <bernalex> maerwald: when I say elegant, understandable is implied.
16:38:34 <arkeet> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/pragmas.html
16:38:40 <maerwald> bernalex: that's an odd definition though, but ok
16:38:45 <Jello_Raptor> c_wraith: ooh, this also lets you do the restricted monad thing, which I have been wondering about. 
16:39:47 <sm> me finds it surprisingly helpful that it's just 20 files in a single directory
16:40:03 <maerwald> right, no subdirectories :)
16:40:12 <sm> quite refreshing
16:40:20 <maerwald> well, works for that size at least
16:40:23 <bernalex> maerwald: if it is not understandable, it is inherently not elegant. elegant literally means "[c]haracterised by minimalism and intuitiveness while preserving exactness and precision.»
16:41:06 <maerwald> well, some people say lens is elegant...
16:41:23 <arkeet> bernalex: I disagree.
16:41:29 <Jello_Raptor> c_wraith: ooh, this also lets you do the restricted monad thing, which I have been wondering about. 
16:41:34 <Jello_Raptor> oops
16:41:41 <arkeet> understandable and intuitive are not the same.
16:42:11 <c_wraith> Jello_Raptor: accidental up-key?
16:42:20 <maerwald> sm: so if you get it to compile, you should do some performance analysis
16:42:21 <arkeet> there is much in mathematics that is elegant but rather difficult to understand for many.
16:42:30 <sccrstud92_> intuitive implies understandable, no?
16:42:42 <bernalex> sccrstud92_: yes it does. intuitive as an adjective means «grasped by intuition», which means «[e]asily understood»
16:42:49 <hodapp> elephants are neither elegant nor understandable.
16:43:07 <sm> maerwald: it'll probably perform better just from newer GHC and hardware eh
16:43:08 <bernalex> sccrstud92_: what arkeet is misunderstanding is that "easily understood" does not mean that it needs to be easily understood by laymen.
16:43:21 <maerwald> sm: which will be particularly interesting...
16:43:31 <bernalex> sm: are you sure?
16:43:32 <maerwald> maybe back then the optimizations were really not that good
16:43:54 <sm> bernalex: well, I'd put a bit of money on it
16:44:01 <arkeet> meh.
16:44:04 <bernalex> it ran "well enough" at least when I tested it. I still have it installed, but I don't have any Q3 maps.
16:44:43 <sm> then one could (maybe ?) abstract the FRP lib and try some of the newer ones
16:45:16 <sm> bernalex: bummer, aren't those maps available ?
16:45:56 <maerwald> bernalex: maybe even openarena maps work?
16:46:00 <sm> I used to love quake 3, I wonder what happened to the disc
16:46:10 <bernalex> sm: Q3 is free software -- there are lots of free implemnetations of it with free maps.
16:46:15 <bernalex> maerwald: that was what I used IIRC.
16:46:48 <bernalex> s/mne/men/
16:47:16 <Jello_Raptor> c_wraith: basically, wanted to do that to my command line, not the chat window. 
16:47:36 <Jello_Raptor> c_wraith: I also have a bad habit of randomly typing ':w' into IRC :P 
16:49:31 <hodapp> I have a bad habit of typing my thoughts out into #haskell.
16:49:45 * sm makes a note to browse this code again with a really good IDE
16:50:42 <aupiff> when i use +RTS -p to do profiling and check out my report, I see " total time  =      353.97 secs  ", but the program actually ran MUCH slower than that
16:50:54 <aupiff> where can I see the time spent profiling?
16:51:04 <aupiff> is there a verbose -p option
16:51:28 <Jello_Raptor> hodapp: alas :( maybe with time and effort you could fix that? 
16:55:29 <hodapp> Jello_Raptor: PFFFFFT
16:55:32 <hodapp> Jello_Raptor: Nope.
16:58:23 <sm> aupiff: -P and -Pa
16:58:39 <sm> +RTS --help 
17:34:32 * hackagebot repline 0.1.4.0 - Haskeline wrapper for GHCi-like REPL interfaces.  http://hackage.haskell.org/package/repline-0.1.4.0 (sdiehl)
17:42:21 <air_> m learning this lang and want to contribute as open-source dev
17:42:30 <air_> and guidence
18:00:47 <hiptobecubic> air_, go ahead :) There are lots of projects
18:01:23 <air_> do you participate in gsoc
18:01:58 <air_> why there are few people on irc
18:03:05 <hpc> it's only 20 years old
18:03:14 <hpc> give it another few decades and it'll be as popular as lisp ;)
18:03:25 <bernalex> air_: haskell is part of gsoc, yes.
18:03:50 <air_> any project whcih  i plan for next year
18:04:18 <air_> before i was progeamming in ruby
18:04:20 <bernalex> air_: several. https://ghc.haskell.org/trac/summer-of-code/wiki/SoC
18:19:35 * hackagebot uacpid 1.2 - Userspace Advanced Configuration and Power Interface  event daemon  http://hackage.haskell.org/package/uacpid-1.2 (DinoMorelli)
18:21:01 <air_> seems little difficult
18:29:09 <bernalex> air_: programming generally is.
18:32:14 <exio4> air_: well, actually, this is a relatively big channel :)
18:33:39 <air_> m talking about gsoc
18:33:45 <air_> haskell project
18:35:16 <bernalex> exio4: one of the biggest on freenode afaik.
18:35:37 <Quantumplation> Hey there!  is there a lifted fromMaybe?  something like: fromMaybeM :: M a -> Maybe a -> M a?
18:36:04 <exio4> Quantumplation: I normally use a partially applied maybe for those cases 
18:36:15 <exio4> maybe x return ... 
18:36:22 <Axman6> :t fromMaybe <$>
18:36:23 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
18:36:31 <Axman6> :t (fromMaybe <$>)
18:36:32 <lambdabot> Functor f => f a -> f (Maybe a -> a)
18:36:45 <Axman6> not even close, heh
18:36:52 <exio4> @type liftA2 fromMaybe 
18:36:53 <lambdabot> Applicative f => f c -> f (Maybe c) -> f c
18:37:09 <Quantumplation> Essentially, I want the default value to be the result of calling newChan to spawn a new channel
18:37:10 <kadoban> Anyone know if you can use haskell to write vim scripts somehow?
18:37:24 <exio4> but it has different type, and then.. there are the effects of the first action Axman6 :p 
18:38:05 <exio4> @type \x -> (maybe x return =<<)
18:38:06 <Quantumplation> so, something like:    chan <- fromMaybe (c <- newChan) $ lookup key chanTable
18:38:06 <lambdabot> Monad m => m b -> m (Maybe b) -> m b
18:38:34 <exio4> Quantumplation: fromMaybe newChan (lookup key chanTable) then ? 
18:39:17 <bernalex> :t return . fromMaybe
18:39:17 <Quantumplation> but newChan :: IO (Chan a), not Chan a
18:39:18 <lambdabot> Monad m => a -> m (Maybe a -> a)
18:39:37 <bernalex> oh wait  see what you mean
18:40:01 <Quantumplation> "look for a Chan in this Map, and if you don't find one create one"
18:40:32 <Quantumplation> I can just case of, but i thought a fromMaybe would look nicer if I could get the types to line up
18:40:55 <bernalex> Quantumplation: I'd use case, probably
18:41:04 <Quantumplation> alrighty hehe
18:41:47 <bernalex> Quantumplation: I tend to pick cheap solutions these days, since the reason for my wanting to find some elegant way of expressing something usually means I have the wrong model, so I end up rewriting it anyway. ;)
19:17:22 <c_my_nick> is there a way to negate #ifdef?  or do i have to use an else?
19:17:33 <verement> #ifndef
19:18:16 <Eduard_Munteanu> Also   #if not(...)   IIRC from CPP
19:18:30 <Eduard_Munteanu> Er.
19:18:37 <Eduard_Munteanu> #if !defined(...)
19:22:22 <angerman> trying out stack. Hmm.
19:26:24 <thomasduplessis> as
19:27:02 <thomasduplessis> hello
19:27:32 <Eduard_Munteanu> Hi.
19:27:43 <thomasduplessis> sorry just testing this was working
19:27:50 <thomasduplessis> first time really using irc
19:29:04 <Eduard_Munteanu> Welcome then.
19:30:22 <thomasduplessis> thanks, are you a regular?
19:33:02 <bsmt> greetings, newcomer
19:33:17 <thomasduplessis> thank you sir
19:35:13 <thomasduplessis> is there a topic ?
19:35:26 <thomasduplessis> or is this kinda more just talk about whatever
19:38:46 <arkeet> the topic is haskell
19:38:55 <arkeet> off topic talk is discouraged.
19:39:24 <thomasduplessis> well that is a given haha
19:39:33 <tnks> there's #haskell-blah, right?
19:39:41 <thomasduplessis> whats that?
19:39:52 <tnks> for Haskell-affine, whatever talk.
19:40:04 <tnks> no rules Haskell fools
19:40:23 <thomasduplessis> haha not sure what that means
19:41:33 <tnks> I think topics aren't quite as worrisome when there's not much activity.
19:42:13 <tnks> but #haskell-blah helps relieve conversational pressure when there's heavier technical talk.
19:42:41 <thomasduplessis> right
19:43:55 <Quantumplation> So, I just made a first attempt at adding parallel execution to a little tool I've been building, if anyone wants to provide feedback.  https://github.com/Quantumplation/RunscopeExport  master branch is sequential, "Concurrency" branch is concurrent
19:44:04 <Quantumplation> I'm rather new to Haskell
19:54:36 <sccrstud92_> Quantumplation: you posted an older version on reddit, right?
19:54:51 <Quantumplation> Yep!  Been updating it with everyones suggestions
19:54:55 <Quantumplation> I also posted it in this room a few days ago
19:55:19 <frangor> hi
19:57:26 <sccrstud92_> Quantumplation: have you used the async package?
19:58:24 <sccrstud92_> Quantumplation: mapConcurrently :: Traversable t => (a -> IO b) -> t a -> IO (t b)
19:58:50 <sccrstud92_> might be useful
19:58:58 <sccrstud92_> since u were doing a fold when i last read it
19:59:00 <sccrstud92_> it might not be
19:59:05 <Quantumplation> oo, that looks useful
19:59:13 <sccrstud92_> its very nice
19:59:26 <sccrstud92_> is the only reason u were keeping a count
19:59:39 <sccrstud92_> because you needed to name the files that you wrote to differently?
19:59:39 * hackagebot file-location 0.4.8 - common functions that show file location information  http://hackage.haskell.org/package/file-location-0.4.8 (GregWeber)
19:59:45 <Quantumplation> yep
20:00:07 <Quantumplation> actually how is mapConcurrently different from MonadParallel.mapM?
20:00:45 <sccrstud92_> fromt he monad-parallel package?
20:01:23 <hetakuso> Hi. How do you install the Haskell platform as a regular user? The binary distribution activate-hs script requires root.
20:01:50 <sccrstud92_> i havent used monad-parallel before
20:02:04 <sccrstud92_> i think async is a bit more well known
20:02:16 <Quantumplation> ah ok
20:02:36 <sccrstud92_> mapConcurrently also works over any Traversable, not just []
20:02:40 <sccrstud92_> but if u are using a list
20:02:43 <sccrstud92_> doesnt matter
20:02:45 <sccrstud92_> =)
20:02:56 <c_wraith> hetakuso: what platform?
20:03:08 <hetakuso> c_wraith: ubuntu
20:03:14 <Hijiri> well, if you use something for all traversable and not specific to lists, you're guaranteed the function won't do some funny things like remove list elements
20:03:42 <Hijiri> I doubt MonadParallel.mapM is broken like that
20:03:44 <Hijiri> though
20:04:12 <Quantumplation> ah, the async package provides something similar to C#'s async/await functionality
20:04:17 <c_wraith> hetakuso: easiest way is to grab a linux binary installer from www.haskell.org/ghc and run the configure script with something like ./configure --prefix=$HOME/ghc-version
20:04:33 <c_wraith> hetakuso: despite using configure, it *is* a binary package
20:04:57 <hetakuso> c_wraith: I see. I have never seen a binary package use configure. Interesting.
20:05:11 <hetakuso> c_wraith: And then compile cabal and then use that to fetch everything?
20:05:28 <c_wraith> hetakuso: actually, you can just grab a cabal binary these days.  Way easier than the old way. :)
20:06:02 <hetakuso> c_wraith: So should I use binary cabal to download ghc, or install binary ghc manually?
20:06:19 <c_wraith> hetakuso: cabal can't install ghc.  Need to just grab them both
20:06:33 <hetakuso> c_wraith: Cool! Thanks. I'll try this route.
20:09:40 * hackagebot blaze-textual 0.2.1.0 - Fast rendering of common datatypes  http://hackage.haskell.org/package/blaze-textual-0.2.1.0 (BryanOSullivan)
20:25:06 <NicX> What is the syntax for adding (Num b) to the context of the RULE "myrule"?
20:26:30 <pqmodn> NicX see these examples https://github.com/haskell/vector/blob/master/Data/Vector/Fusion/Stream/Monadic.hs#L1293
20:27:04 <pqmodn> (there are many more examples in that repo)
20:27:15 <NicX> pqmodn: thanks
20:54:42 * hackagebot getopt-generics 0.7.1.1 - Simple command line argument parsing  http://hackage.haskell.org/package/getopt-generics-0.7.1.1 (SoenkeHahn)
21:31:01 <novice> I wrote this program to solve project euler #3, and I went to take a break but it's still running: https://dpaste.de/NnRp
21:31:10 <novice> I need some help
21:32:32 <novice> It has been running for at least 15 minutes now
21:38:17 <novice> should I wait until the program terminates?
21:38:26 <kadoban> So the ide-backend stuff … that requires you to build a special patched version of GHC? That … seems like it's going to limit the usefulness.
21:38:55 <kadoban> Oh wait, maybe that's only for GHCs older than 7.10
21:38:57 <novice> In the meantime I wrote a version in C and it returned the correct result instantly. :(
21:39:07 <mniip> novice, weird
21:39:11 <novice> I must have done something wrong, but I'm new to Haskell.
21:39:16 <mniip> takes a second in this quickly thrown together implementation
21:39:17 <mniip> > let v = 600851475143 in head $ filter ((== 0) . (mod v)) $ reverse $ takeWhile ((< v) . join (*)) $ [1..]
21:39:19 <lambdabot>  486847
21:39:40 <ElMoloko> Hmm
21:40:12 <ElMoloko> Well primes only works above 1
21:40:23 <mniip> novice, you see your prime generation algorithm takes O(N^2) time to reach N
21:40:44 <novice> mniip: yeah I learned it from haskell.org
21:40:45 <ElMoloko> oh
21:41:09 <ElMoloko> well why aren't you calling the tail of the list in primefilter 
21:41:20 <ElMoloko> oh i'm just blind >>
21:41:30 <mniip> novice, it has to search for primes all the way up to sqrt(600851475143)
21:41:38 <mniip> which takes 600851475143 time
21:41:44 <novice> yeah my C version does that too but I use a sieve
21:42:04 <novice> I don't know how to make a sieve in Haskell
21:42:16 <novice> I can't change values
21:42:20 <mniip> novice, primes
21:42:25 <mniip> novice, 'primes' is a fine implementation
21:42:30 <ElMoloko> there's a really cool implementation of the sieve  of Eratosthenes on the haskell wiki
21:42:31 <mniip> it's just your search that is wrong
21:42:50 <novice> what do you mean?
21:43:02 <ElMoloko> http://en.literateprograms.org/Sieve_of_Eratosthenes_(Haskell)
21:43:14 <ElMoloko> this one is actually what i'm thinking of
21:43:30 <novice> http://en.literateprograms.org/Sieve_of_Eratosthenes_%28Haskell%29#A_first_look
21:43:34 <novice> that's just the same thing as mine
21:43:42 <novice> it says sieve too but I think it's not really a sieve
21:44:41 <ElMoloko> how is it not a sieve? (just curious)
21:45:18 <novice> sieve does not use division/mod, and it only touches N/x values when scanning for multiples of x
21:45:28 <novice> the version on the wiki scans N values every time
21:45:31 <lpaste_> mniip pasted “largestPrimeFactor” at http://lpaste.net/135619
21:45:50 <mniip> novice, ^
21:45:57 <ElMoloko> does this not do that? 
21:45:57 <ElMoloko> http://en.literateprograms.org/Sieve_of_Eratosthenes_%28Haskell%29#Multiples_of_primes
21:46:55 <novice> ElMoloko: oh I was referring to the first example on the page, with the primes = sieve [2..]
21:46:59 <mniip> also lists are hardly a good base for a sieve
21:47:07 <ElMoloko> OH
21:47:18 <novice> a bit misleading that it's called sieve
21:47:22 <novice> since it is so much slower
21:47:32 <novice> oh btw my program just terminated
21:47:34 <Diabolik> ElMoloko
21:47:34 <Diabolik> http://rosettacode.org/wiki/Sieve_of_Eratosthenes#Haskell
21:47:41 <novice> it printed 6857
21:48:05 <ElMoloko> :D haha using mutable arrays
21:48:07 <kadoban> This is a good paper on sieve of erat in haskell: http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
21:48:47 <novice> I'm not really looking for academic papers, just plain Haskell is theoretic enough
21:49:08 <ElMoloko> ohh this will be interesting, thanks
21:49:33 <novice> Diabolik that example looks awfully complicated
21:49:44 <novice> is that really what you have to do to use regular arrays?
21:50:10 <kadoban> It's a very readable paper.
21:50:32 <Diabolik> novice there are 6 examples
21:51:59 <anoe> From discussion on haskell-cafe ML: http://lpaste.net/101980
21:54:20 <novice> mniip I don't understand, why was my search so slow?
21:54:24 <ElMoloko> this may seem stupid, but do all efficient sieve of erat implementations depend on mutability?
21:54:44 <novice> mniip: oh, well I see now
21:54:57 <novice> mniip: but that only works because the largest prime factor of that number is pretty small
21:55:19 <mniip> novice, you iterate from 1 to sqrt(N)
21:55:26 <mniip> er
21:55:32 <lethjakman> so I'm trying to get the point of this: return (0,0) >>= landLeft 1 >> Nothing >>= landRight 1  
21:55:35 <novice> I do that in the C code too
21:55:41 <mniip> you take all primes that are under sqrt(N)
21:55:49 <lethjakman> if you have to use >> for Nothing, what's the point monads?
21:55:51 <mniip> and filter ones that are divisors of N
21:56:06 <mniip> and then take last filtered element
21:56:07 <lethjakman> shouldn't >>= be able to accept nothing and propogate the nothing all the way through? 
21:56:15 <novice> mniip: if I set k = 775121
21:56:19 <novice> it becomes super slow again
21:56:23 <dramforever> lethjakman: yes
21:56:31 <mniip> now, the runtime can't give you the last element until it ensures there are no larger prime divisors
21:56:33 <novice> the C code is still instant
21:56:34 <dramforever> wait it doesn't?
21:56:56 <dramforever> never mind
21:56:57 <lethjakman> dramforever: I get an error
21:57:24 <lethjakman> I don't ge tthe point of >>
21:57:46 <dramforever> are landLeft and landRight working?
21:58:34 <novice> mniip have you tried with that value of k?
21:58:46 <mniip> no
21:59:00 <dramforever> lethjakman: the point of >> is chaining without propagating a value
21:59:20 <mniip> novice, hmm, my program could use a heuristic
22:00:10 <lpaste_> mniip revised “largestPrimeFactor”: “largestPrimeFactor” at http://lpaste.net/135619
22:00:48 <lethjakman> dramforever: yeah, the left and right came from here: http://learnyouahaskell.com/a-fistful-of-monads
22:00:59 <lethjakman> I had to declare them
22:01:01 <saulzar> lethjakman, What's the context of that? It could have some effect
22:01:04 <dramforever> so you get error?
22:01:30 <lethjakman> saulzar: if you want the context I could make a gist
22:01:33 <dramforever> lethjakman: oh sure, landLeft has type Pole -> Pole
22:01:41 <bernalex> lethjakman: (>>) is '= m >>= \_ -> k'. it is like a semicolon in an imperative language.
22:01:42 <dramforever> but you need Pole -> Maybe Pole for >>=
22:01:49 <dramforever> that's the problem
22:02:02 <lethjakman> so... >> just ignores whatever it is?
22:02:10 <lethjakman> I thought it was one of the main functions of monads
22:02:15 <lethjakman> >>= sounds more useful?
22:02:21 <dramforever> lethjakman: >> ignores the value
22:02:27 <dramforever> but not the "effect"
22:02:29 <novice> mniip yeah that helped a lot
22:02:34 <bernalex> lethjakman: int i = 0 >> int j = i + 2 >> printf("%d+2=%d\n", i, j)
22:02:42 <bernalex> lethjakman: it is just a semicolon. :)
22:02:53 <dramforever> lethjakman: I guess you need the "reworked" versions
22:03:01 <lethjakman> how does >>= work then?
22:03:06 <dramforever> search for "Let's rework these functions"
22:03:06 <bernalex> lethjakman: it is useful to do e.g. 'putStrLn "hello," >> "world!"'
22:03:18 <bernalex> lethjakman: 'getLine >>= putStrLn"
22:03:23 <dramforever> lethjakman: the instance decides
22:03:44 <bernalex> lethjakman: '>>=' does the thing on the lhs, and passes the result to the thing on the rhs.
22:04:07 <bernalex> lethjakman: so, to expand it, 'getLine >>= \r -> putStrLn r'
22:04:25 <novice> mniip weird that you need all these tricks just to mimic the naive C program
22:04:42 <mniip> novice, tricks?
22:05:00 <bernalex> lethjakman: putStrLn has no meaningful result. so we can discard it. 'putStrLn "hello," >>= \_ -> putStrLn "world!"
22:05:19 <novice> mniip I mean dividing the number down so the upper limit for prime search becomes lower
22:05:24 <lethjakman> bernalex: the "hello," >> "world!" outputs world many times
22:05:37 <dramforever> novice: mimic?
22:05:40 <mniip> novice, start thinking functionally and then my approach would be pretty naive
22:05:54 <novice> mniip: yeah but it still does less than the C version
22:05:56 <bernalex> lethjakman: hm? 'putStrLn "hello," >> putStrLn "world!"' will first print "hello," on a line, and then "world!" on another.
22:06:10 <novice> it doesn't compute all the primes up to sqrt k
22:06:30 <novice> (unless the k is a prime, but the prime we tested is very small compared to the k in the project euler assignment)
22:06:32 <dramforever> novice: do you have a c version?
22:06:35 <lethjakman> >> "hello," >> "world!"
22:06:35 <LordBrain> lethjakman, one world for each letter in hello
22:06:40 <novice> dramforever: 1 sec
22:06:42 <lethjakman> > "hello," >> "world!"
22:06:44 <lambdabot>  "world!world!world!world!world!world!"
22:07:00 <mniip> lethjakman, you're using the list monad here
22:07:03 <saulzar> lethjakman, String is a list so >> is using the list monad,  putStrLn is IO using the IO monad
22:07:07 <bernalex> lol
22:07:26 <bernalex> >> in the list monad is not something I've ever thought of using. intriguing.
22:08:01 <saulzar> I can't think why you would
22:08:12 <bernalex> me either. that's why I'm a bit intrigued at the thought.
22:08:21 * dramforever is still waiting.....(don't worry it's okay)
22:08:26 <bernalex> surely there's a hack worth doing in here somewhere... :p
22:08:30 <arkeet> (>>) is replicate 
22:08:31 <saulzar> ListT perhaps, List not so much..
22:08:53 <arkeet> er
22:08:56 <arkeet> and then concat.
22:09:03 <arkeet> > [(),(),()] >> "abcd"
22:09:04 <lambdabot>  "abcdabcdabcd"
22:09:06 <LordBrain> it has its uses, but i think in a lot of cases your intention is more clear if you can not make use of the list monad... for example map (const "World!") "hello" 
22:09:13 <bernalex> arkeet: it's (*>)
22:09:27 <bernalex> > "lulz" *> "omg"
22:09:27 <arkeet> bernalex: that's not saying much, becuase that holds for any Monad.
22:09:28 <lambdabot>  "omgomgomgomg"
22:09:28 <dramforever> replicate is much easier to use
22:09:30 <arkeet> (or ought to.)
22:09:39 <dramforever> btw I like this:
22:09:46 <dramforever> > replicateM 3 "abc"
22:09:47 <lambdabot>  ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","bb...
22:09:50 <bernalex> arkeet: well. not everyone will agree about that.
22:10:05 <bernalex> arkeet: (I'm one of those that do.)
22:10:43 <bernalex> gets me thinking about the great << bikeshed :D
22:11:01 <bernalex> but I think I've got to go to gate now. bike. :)
22:11:14 <lethjakman> lambdabot is limited?
22:11:27 <lethjakman> > replicateM 7 "abc" 
22:11:28 <lambdabot>  ["aaaaaaa","aaaaaab","aaaaaac","aaaaaba","aaaaabb","aaaaabc","aaaaaca","aaaa...
22:12:40 <ElMoloko> novice: i'm not great at thinking functionally yet, but i'm getting there.  take a look at the book How to Design Programs, for the functional mindset[0], Real World Haskell[1]. [0] http://www.ccs.neu.edu/home/matthias/HtDP2e/index.html [1]http://book.realworldhaskell.org/read/
22:12:43 <saulzar> lethjakman, Back to your original question, using Nothing in there does have an effect. If any intermediate computation is Nothing the whole result is Nothing
22:13:07 <saulzar> > Just 3 >> Nothing >> Just 4 >> Just 5
22:13:09 <lambdabot>  Nothing
22:13:14 <lethjakman> saulzar: but you have to know Nothing is coming
22:13:16 <lethjakman> right?
22:13:22 <lethjakman> which is weird to me
22:13:34 <lethjakman> because if it's nothing you use >> instead of >>=
22:14:17 <lethjakman> am I misunderstanding that?
22:14:20 <saulzar> Yeah..
22:14:25 <novice> dramforever: here is a c version https://dpaste.de/O1HN
22:15:16 <saulzar> lethjakman, You can use it to chain a bunch of maybe  computations together (which may or may not return Nothing)
22:15:38 <dramforever> novice: sadly, the answer is yes, you need tricks to mimic the c version
22:15:56 <lethjakman> saulzar: so you normally wouldn't chain a bunch of >>= >> together?
22:15:57 <dramforever> because that sieve isn't straightforwardly translated to haskell
22:16:26 <saulzar> lethjakman, No - that's normal, but you won't usually know the Nothing is coming in advance
22:16:26 <novice> dramforever: but isn't the haskell version just as likely to contain bugs then?
22:16:32 <novice> if it mimics the imperative version
22:16:44 <dramforever> exactly
22:16:50 <lethjakman> saulzar: how would it look if you don't know nothing is coming then?
22:17:00 <dramforever> novice: but there are other prime sieves
22:17:01 <novice> so I gain nothing by implementing it in haskell, it juts makes it much more complicated
22:17:02 <novice> :(
22:17:10 <dramforever> novice: for some algorithms
22:17:22 <novice> are there some notable algorithms that get much easier in haskell?
22:17:54 <dramforever> novice: I'm thinking about splay trees
22:18:08 <dramforever> oh extended Euclid algorithm is a great example
22:18:15 <Zekka> O
22:18:17 <Zekka> oops
22:18:41 <Zekka> I'm writing a Prolog variant that would probably be greatly simplified if I was working on a lazy language
22:18:54 <Zekka> in a lazy language*
22:19:06 <novice> dramforever: do you have a link? I have implemented that one in C many times, it is very compact.
22:19:11 <Zekka> Prolog is backtracking, so there's a lot of computations you'd like to stop and resume
22:19:18 <dramforever> novice: which? extended euclid?
22:19:26 <novice> dramforever: yeah
22:19:43 <Zekka> But I'm also working with persistent data structures and stuff, which Prolog usually isn't implemented in terms of
22:19:45 <saulzar> > let addSymbols symbols k1 k2  = lookup k1 symbols >>= \v1 -> lookup k2 symbols >>= \v2 -> return (v1 + v2)  in addSymbols [("y", 5), ("x", 5)]  "x" "y"
22:19:46 <lambdabot>  Just 10
22:19:53 <saulzar> > let addSymbols symbols k1 k2  = lookup k1 symbols >>= \v1 -> lookup k2 symbols >>= \v2 -> return (v1 + v2)  in addSymbols [("y", 5), ("x", 5)]  "x" "baz"
22:19:54 <lambdabot>  Nothing
22:20:00 <dramforever> I haven't done splay before....
22:20:14 <novice> one more thing that I am curious about
22:20:35 <saulzar> lethjakman, See in that example I don't know (in the addSymbols function at least) if it will find my symbol in the table or not
22:20:37 <novice> I have seen definitions of data Tree = Leaf value or Node left right
22:20:54 <novice> how is the memory usage and cache locality of these structures?
22:21:01 <dramforever> just a hint: you probably don't gain very much by rewriting algorithms in haskell
22:21:12 <novice> in an imperative language, I would normally use a compact tree storage with implicit addressing
22:21:28 <dramforever> novice: IIRC ghc does memory pools
22:21:36 <dramforever> *uses
22:21:40 <novice> child nodes stored at 2*i and 2*i+1
22:21:49 <dramforever> IIRC it's pretty efficient
22:21:58 <novice> dramforever it would still seem like there is a large overhead for storage of the pointers
22:22:13 <dramforever> novice: that causes problems in haskell, because that's not the way haskell data types work
22:22:35 <dramforever> novice: that's not the way haskell data types work
22:23:11 <novice> how would these be implemented in haskell, when the memory footprint is expected to be very significant
22:23:20 <novice> for example in a spell checker for a search engine
22:23:33 <Haskellfant> well you can still use a vector and flatten your tree. the problem is that mutating that purely is fairly expensive so you would fall back to ST or IO.
22:24:18 <ElMoloko> https://stackoverflow.com/questions/9732084/how-do-you-represent-a-graph-in-haskell has some relevant insights
22:24:23 <ElMoloko> i think
22:24:50 <novice> I often write pure functions in C, but the tricky parts are when I have to mutate state (for performance)
22:25:51 <Haskellfant> novice: if you want to learn about how to implement efficient algorithms in haskell I recommend the book "pearls of functional algorithm design"
22:27:02 <lpaste_> mniip pasted “efficient sieve (just kidding)” at http://lpaste.net/135622
22:27:05 <mniip> novice, ^
22:27:36 <ElMoloko> also Purely Functional Data Structures
22:28:00 <dramforever> maybe also Purely functional data structures
22:28:04 <ElMoloko> i used it originally with scheme, Okasaki is wonderful
22:28:14 <Haskellfant> I should finally read that one
22:28:24 <ElMoloko> the thesis form is online https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
22:28:53 <dramforever> novice: again, I have to point out that haskell is *not* good for implementing traditional algorithms, because of it's design choices
22:29:07 <dramforever> well, *many traditional algorithms
22:29:09 <novice> mniip: wow haha, does that actually work?
22:29:14 <mniip> I wonder if I should use 'seq# s# a' instead
22:29:19 <mniip> novice, yes
22:29:32 <mniip> *Main> sieve 100
22:29:33 <mniip> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
22:29:41 <novice> dramforever: yeah, I saw Carmack advise that he would use Haskell for game programming
22:30:15 <novice> dramforever: I'm not sure it's that suited for that task, because game programming has a lot of mutable data structures
22:30:19 <mniip> novice, we basically do the "C thing"
22:30:20 <dramforever> novice: do notice that, however, many simple algorithms can be implemented in haskell elegantly and rather efficiently
22:30:28 <dramforever> novice: like?
22:30:35 <mniip> create an array, iterate (with recursion because we have no loops)
22:30:44 <novice> dramforever: for example the in-place updated kd-trees with pair caches
22:30:46 <mniip> then collect array data into a traditional haskell list
22:30:55 <novice> like those used in the bullet physics engine
22:31:19 <Haskellfant> that existing libraries use mutation heavily doesn't mean, that you have to do so to be efficient
22:31:30 <dramforever> novice: yes, that's low level detail that haskell isn't good at
22:32:21 <novice> one thing I am wondering though
22:32:27 <dramforever> but it's the declarative approach that makes haskell good
22:32:40 <novice> how is the ST monad thing implemented? does it require special compiler support?
22:32:47 <novice> or is there an escape hatch to mutate state?
22:33:06 <dramforever> unsafePerformIO
22:33:10 <dramforever> is that in the standards?
22:33:31 <dramforever> novice: would you recomment lua/ruby/... for game programming? they are not suitable for implementing efficient algorithms/data structures
22:33:48 <dramforever> on the other hand, lua is quite popular
22:34:37 <novice> dramforever: to be honest I think the main reason why lua is so popular is because it is used in addons for World of Warcraft
22:34:41 <Rotaerk_> lua's usually just used for gameplay/modding/etc
22:34:49 <novice> dramforever: and what Rotaerk_ said
22:34:49 <Rotaerk_> a scripting language, not the core/engine language
22:35:02 <dramforever> novice: it's because it's working declarativly
22:35:16 <novice> It's only used to "connect" things together and set up triggers
22:35:25 <novice> dramforever: lua?
22:35:38 <dramforever> novice: haskell is particularly good at connecting
22:35:58 <novice> if you meant lua: how so? it seems like a C with built-in hash/list
22:36:00 <mniip> novice, lua is very popular because it's tiny
22:36:03 <mniip> easily embeddable
22:36:04 <dramforever> novice: lol
22:36:32 <dramforever> mniip: iirc haskell runtime isn't too large to be embedded
22:36:44 <mniip> dramforever, smaller than python's?
22:36:48 <novice> dramforever: heh! many games embed full webkit now
22:36:54 <novice> that's like 40-50 MB
22:36:57 <dramforever> lol
22:37:00 <mniip> ಠ_ಠ
22:37:02 <mniip> what
22:37:28 <dramforever> novice: I guess the haskell runtime is ~800KB or so
22:37:36 <novice> just look at pretty much every MMO
22:37:54 <novice> Guild Wars 2 used to load the whole webkit executable anew every time you pressed the O key
22:38:05 <novice> they patched it now to load once at the beginning and keep it resident
22:38:29 <novice> but it would delay the whole game for 2-3 seconds while that 40-50MB executable gets initialized
22:38:36 <mniip> dramforever, interesting
22:38:45 <mniip> I have a game whose executable is 3-4MB over here
22:39:15 <mniip> dramforever, wait hold on a second
22:39:19 <mniip> 800KB is what
22:39:22 <mniip> the RTS?
22:39:30 <mniip> or the full compilation and execution stack
22:39:35 <dramforever> rts
22:39:37 <novice> the guild wars 2 main executable without any libraries and without webkit is already 22MB
22:39:39 <novice> crazy
22:39:42 <mniip> ah well that's not it then
22:40:05 <dramforever> mniip: not including dynamic libs that basically every computer has
22:44:14 <mniip> dramforever, so basically dynamically loadable .hi files
22:44:22 <mniip> .o+.hi files
22:44:23 <dramforever> ?
22:44:39 <dramforever> no, I mean stuff like libc
22:44:49 <mniip> dramforever, no, I mean what can those 800KB do
22:45:04 <dramforever> power the rest of the program
22:45:20 <mniip> dramforever, which includes what
22:45:48 <dramforever> basic io stuff :P
22:45:52 <dramforever> ...
22:46:14 <dramforever> okay now I remembered, you need other libraries
22:46:20 <dramforever> never mind...
23:09:49 * hackagebot pipe-enumerator 0.3.0.1 - A bidirectional bridge between pipes and iteratees  http://hackage.haskell.org/package/pipe-enumerator-0.3.0.1 (patrykz)
23:14:57 <LordBrain> i'm thinking of making a debugging tool for TBMQueues, it will serialize information about the queue and broadcast it via udp to be interpretted to a cllient. But I am not sure the  best type to store the meta information about the queue. If i post some alternatives, would the room here examine and offer opinions?
23:22:57 <lpaste_> LordBrain pasted “Best type for queue meta data?” at http://lpaste.net/135623
23:34:31 <pingu> Does anyone know if haskell-src-exts has anyone taking care of it?
23:34:39 <pingu> seems like PRs on github aren't being merged
23:35:41 <jle`> there should be an instance MonadIO (Const a)
23:35:55 <jle`> i think it follows all of the laws
23:36:01 <jle`> time to write a patch
23:37:04 <jle`> i mean Monoid a => ...
23:37:21 <jle`> but i guess it doesn't work because MonadIO has Monad as a superclass for some reason
23:37:34 <jle`> (i guess to be able to talk about laws)
23:37:36 <jle`> ok i'm done
23:37:40 <Pip> Is Monad Lifting hard to learn?
23:37:55 <dramforever> jle`: do we have instance Monoid a => Monad (Const a)?
23:38:00 <dmwit> why would you want monadio const
23:38:02 <dramforever> Pip: what do you mean?
23:38:08 <dramforever> monad transformers?
23:38:16 <arkeet> dramforever: there is no lawful instance for that.
23:38:16 <Pip> maybe
23:38:27 <dramforever> arkeet: k
23:38:36 <jle`> dmwit: it follows the laws w.r.t. Applicative
23:38:38 <dramforever> Pip: I don't think it's hard
23:38:38 <jle`> so why not
23:39:03 <dramforever> jle`: no use, no sensible (>>=)
23:39:12 <jle`> i mean w.r.t. pure and (<*>)
23:39:33 <mniip> um
23:39:47 <jle`> that is, that liftIO distributes over pure and (<*>)
23:39:51 <jle`> being an Applicative morphism
23:39:52 <dmwit> jle`: i don't object but my question stands
23:39:55 <mniip> (>>=) :: Const c a -> (a -> Const c b) -> Const c b
23:40:07 <mniip> you have to get a value of 'a' out of thin air
23:41:05 <jle`> if there was an ApplicativeIO then it would work
23:41:10 <jle`> or if MonadIO wasn't constrained on Monad
23:41:31 <jle`> liftIO viewed as an Applicative morphism that distributes over pure and (<*>)
23:41:34 <arkeet> can't have return a >>= f = f a
23:41:42 <jle`> liftIO (pure x) = pure x
23:41:50 <jle`> liftIO f <*> liftIO x = liftIO (f <*> x)
23:42:01 <arkeet> because 'return a' forgets everything about a
23:42:31 <jle`> just talkin bout Applicative because there is no Monad (Const a)
23:43:05 <mniip> arkeet, well actually you can
23:43:32 <arkeet> mniip: show me a definition where it holds.
23:43:52 <jle`> `liftIO _ = Const mempty` works as an instance
23:44:07 <dmwit> mniip: "you have to get an a out of thin air" is not precis.
23:44:29 <dmwit> mniip: arkeet's objection is a better one
23:44:29 <mniip> arkeet, okay, there is none
23:44:52 <mniip> dmwit, okay here's a more precise argument
23:44:59 <jle`> instance Monoid a => MonadIO (Const a) where liftIO _ = Const mempty works if MonadIO were constrained on Applicative and liftIO works as an Applicative morphism so let's relax the constraint and do it
23:45:18 <jle`> o/
23:45:21 <jle`>  \o
23:45:26 <arkeet> does it satisfy the MonadIO laws?
23:45:38 <dmwit> mniip: (because you can make values of Const c b without applying the function you're handed)
23:45:39 <jle`> it satisfies that liftIO is an Applicative morphism
23:45:50 <jle`> but it's not a Monad so it can't really be a Monad morphism
23:45:53 <mniip> hmm
23:45:55 <mniip> you are right
23:46:00 <arkeet> ok     
23:46:07 <jle`> liftIO f <*> liftIO x = liftIO (f <*> x)
23:46:12 <jle`> liftIO (pure x) = pure x
23:46:39 <jle`> liftIO (liftA2 (,) x y) = liftA2 (,) (liftIO x) (liftIO y)
23:46:56 <jle`> it's an applicative morphism in every meaningful way
23:47:22 <mniip> liftIO ~ Identity confirmed
23:48:12 <jle`> all MonadIO instances where liftIO is a monad morphism should satisfy these anyway
23:50:28 <jle`> the only extra law is that liftIO (f =<< x) is liftIO . f =<< liftIO x   ... we can just say that it's required if the type is a Monad
23:52:32 <arkeet> so what's the point 
23:53:45 <jle`> so we can have a liftIO for Const :3
23:53:57 <arkeet> why.
23:54:01 <jle`> because we can
23:54:33 <arkeet> that's not a good reason.
23:54:49 <jle`> if the instance is lawful, why not?
23:55:00 <jle`> maybe some day someone will figure out a usage
23:55:17 <mniip> jle`, something something lens
23:55:35 <arkeet> what you can write a MonadIO instance for, right now,
23:55:36 <arkeet> is Proxy
23:56:45 <dramforever> :t foo
23:56:46 <lambdabot>     Not in scope: ‘foo’
23:56:46 <lambdabot>     Perhaps you meant ‘T.for’ (imported from Data.Traversable)
23:57:07 <dramforever> what happens to stuff defined with @let in lambdabot?
23:57:17 <arkeet> it stays there, until someone does @undefine.
23:57:20 <dramforever> how long do we keep them
23:57:26 <dramforever> arkeet: k
23:57:46 <arkeet> @let dramforever = "hi"
23:57:47 <lambdabot>  Defined.
23:57:48 <arkeet> > dramforever 
23:57:49 <lambdabot>  "hi"
23:57:50 <arkeet> @undefine
23:57:50 <lambdabot> Undefined.
23:57:51 <arkeet> > dramforever 
23:57:52 <lambdabot>  Not in scope: ‘dramforever’
23:58:11 <dramforever> @let instance MonadIO Proxy where liftIO _ = Proxy
23:58:12 <arkeet> (there is not, afaik, a way to undefine individual definitions)
23:58:12 <lambdabot>  Defined.
23:58:19 <dramforever> arkeet: right
23:58:29 <dramforever> so it's like a sandbox?
23:59:59 <arkeet> more or less.
