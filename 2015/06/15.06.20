00:16:33 <larrycv> can I do something like this? data Foo { getObj :: IO a; displayObj :: a -> String } without adding an constraint in Foo?
00:16:55 <larrycv> "a" constraint in Foo?
00:18:29 <Axman6> sure, why would you need a constraint?
00:18:53 <larrycv> it doesnt compile without it
00:19:01 <Axman6> what constraint are you giving?
00:19:11 <larrycv> maybe I am using wrong termonology
00:19:39 <larrycv> I want to have "data Foo" but haskell is forcing me to use "data Foo a"
00:19:41 <wz1000> The code for the Add class in https://wiki.haskell.org/Type_arithmetic doesn't compile without UndecidableInstances
00:20:36 <Axman6> oh, that can also be done. data Foo = forall a. Foo { getObj :: IO a; showObj :: a -> String}
00:20:46 <Axman6> can't remember which extension that needs though
00:20:53 <larrycv> nice
00:20:54 <creichert> larrycv: you can use an explicity forall, data Foo = Foo { getObj :: forall a. IO a }
00:20:57 <creichert> RankNTypes
00:21:06 <creichert> ah, nice :)
00:21:18 <Axman6> I think what I wrote will work
00:21:30 <alpounet> Axman6: yeah it does. requires ExistentialQuantification
00:21:34 <creichert> consider that a parameter on the type will give you more information, though
00:21:38 <Axman6> that's the one
00:22:10 <creichert> it's RankNTypes, right?
00:22:12 <Axman6> larrycv: a similar idea is used in the implementation of stream fusion
00:23:02 <creichert> https://ghc.haskell.org/trac/haskell-prime/wiki/PolymorphicComponents
00:26:41 <larrycv> I am getting errors.. 
00:26:55 <larrycv> (pasting)
00:27:48 <lpaste> larry pasted “No title” at http://lpaste.net/134850
00:29:21 <larrycv> I am not sure what ghci means by "use pattern-matching syntax instead" in this context
00:29:29 <Axman6> larrycv: well, for one, you need to use showObj foo obj
00:29:40 <larrycv> yes
00:30:01 <Axman6> it means use doit (Foo io prnt) = io >>= putStrLn . prnt
00:31:51 <Axman6> does that work?
00:32:14 <larrycv> ah. I cant use it in general do because type is uknown, and I could use it outside of showObj?
00:32:17 <larrycv> yes
00:33:00 <Axman6> this type is not very useful btw, you can do nothing at all with its value except print it
00:33:02 <larrycv> but do is just sugar for >>=.. hmm
00:33:26 <larrycv> my actual type is more complex than that
00:33:42 * hackagebot tls 1.3.1 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.3.1 (VincentHanquez)
00:35:05 <larrycv> so why does it require pattern matching?
00:36:07 <larrycv> how am I leaking a in my example, but not in yours?
00:38:45 <mikeplus64> https://hackage.haskell.org/package/constraints-0.4.1.3/docs/Data-Constraint-Forall.html man this is clever
00:43:21 <felixn> larrycv: http://lpaste.net/134850#a134852 <-- try this, you need to add the abstract to the type as well, also you weren't passing "foo" to "showObj"
00:46:11 <supki> larrycv: because getObj is not a function (what's its type?)
00:46:23 <larrycv> ah
00:47:08 <martinvlk> Hi, I can successfully compile a basic Hello World into JavaScript with ghcjs and run it with nodejs. But what I ultimately need to do is write a nodejs module in Haskell and compile down to JavaScript with ghcjs. I need to be able to require other nodejs modules as well. Could somebody point me in the right direction? E.g. what approach and libraries to use...
00:50:32 <larrycv> this worked great
01:23:41 <hsk5> Is it fair to say that if you don't have a proper IDE (code completion, etc.), you kind of NEED static typing like in Haskell?
01:30:26 <Cale> hsk5: It's certainly the case that IDEs are regularly used to paper over the weaknesses of various programming languages. I'm not sure I'd say you need static typing in response to not having autocompletion, but there are lots of aspects of programming language design that interact with the space that IDEs occupy.
01:31:00 <hsk5> Cale: do you use an IDE for Haskell?
01:31:05 <Cale> No
01:31:14 <hsk5> Have you written a lot of Haskell over the years?
01:31:33 <Cale> Yeah, I've been programming in Haskell since ~2002 or so, often professionally
01:31:38 <hsk5> Nice.
01:31:44 <hsk5> Okay, I'll forget about an IDE then :)
01:32:10 <Cale> There are a lot of cool things that a Haskell IDE could perhaps do
01:32:36 <ion> I'd love a good Haskell IDE with inline documentation, code generation, refactoring.
01:33:08 <Cale> Languages with even fancier type systems, namely Agda and Idris, both have features which let your text editor write code for you based on the type.
01:33:16 <[k-> (You only really need those for java)
01:33:49 <ion> I'd like being able to fill holes with exference.
01:34:26 <[k-> You don't need an ide for Haskell except for when you forgot a function's type signature
01:35:21 <hsk5> heh
01:35:38 <Cale> One little text-editor level feature I wish I had is awareness of layout keywords. It would be nice if any edit which caused the first non-whitespace character after 'let', 'of', 'where', 'do' or 'mdo' to move would cause the entire following block to move analogously.
01:35:39 <Haskellfant> well features like renaming variables are still useful in haskell
01:35:55 <Haskellfant> Cale: I think shm does that
01:36:02 <Haskellfant> shm being structured-haskell-mode
01:36:24 <Cale> shm doesn't really do that, it just insists that it handle the layout and everything
01:36:28 <ion> Yeah, one would definitely want to rename the variables in generated code and generated type signatures.
01:36:48 <Cale> I want my text editor to still behave like a text editor
01:37:09 <[k-> If you generate type signatures then you might lose benefits!
01:41:03 <hsk5> Cale: so i guess somehow you've managed to live with just a plain editor. interesting
01:41:19 <hsk5> all these years
01:43:20 <[k-> Do you code in java by any chance?
01:43:22 <Cale> hsk5: Mostly the fact that I keep ghci running in a separate window
01:43:27 <hsk5> :)
01:43:56 <ion> It's not that much of a pain to do Haskell in a plain editor (along with ghci).
01:44:26 <ion> But sure, a good IDE would be nice.
01:44:27 <hsk5> cool
01:47:14 <quazimodo> hello everybody
01:47:42 <quazimodo> Forgetting that there is probably a very good CSV library out there
01:48:10 <quazimodo> (for the sake of education) what would a data type look like, that can be populated by reading an arbitrary csv file?
01:48:42 <quazimodo> in my mind I'm thinking it'd be a data type of collection nature, holding n CsvRow objects
01:48:55 <ion> [[Text]] would be an okay first approximation.
01:49:01 <quazimodo> though I'm not sure what a CsvRow object would look like
01:49:29 <AlecTaylor> hi
01:49:31 <quazimodo> ion: i've still not groked the differences bteween bytestring, string and text (and whatever else there may be)
01:50:19 <AlecTaylor> I want to apply a function to a list. This function will produce k lists. What functional primitive do I use, as `map` doesn't seem to fit?
01:50:25 <quazimodo> ion: i'm actually going to write production code as my first haskell program :D
01:51:00 <ion> ByteString is to [Word8] what Text is to [Char]. Strict Text is an array of Unicode codepoints, [Char] if a linked list of them.
01:51:06 <[k-> What is the function you speak of
01:51:34 <Haskellfant> AlecTaylor: do you want to concatenate the results or why does map not work?
01:51:50 <quazimodo> ion: i'll google it up
01:52:22 <ion> Lazy Text is akin to [Strict.Text], a linked list of arrays.
01:52:22 <quazimodo> ion: i'm going to write some haskell modules providing an interface to read n csv files and do calculations on them
01:52:26 <[k-> @hoogle [a] -> [[a]]
01:52:27 <lambdabot> Data.List inits :: [a] -> [[a]]
01:52:27 <lambdabot> Data.List permutations :: [a] -> [[a]]
01:52:27 <lambdabot> Data.List subsequences :: [a] -> [[a]]
01:54:06 <ion> Text is likely much more efficient than String.
01:55:42 <AlecTaylor> Haskellfant: Clearly this will produce one list: `filter (>100) $ map (*10) [1..22]`. Now let's say I want to put everything that doesn't match that filter into another list. How do I do that in one expression?
01:56:13 <AlecTaylor> (clearly the list only needs to be iterated through once, doing it in two expressions would iterate over it twice)
01:57:12 <Haskellfant> > partition (>100) $ map (*10) [1..22]
01:57:13 <lambdabot>  ([110,120,130,140,150,160,170,180,190,200,210,220],[10,20,30,40,50,60,70,80,...
01:57:39 <RadBaddy> > partition (>100) $ map (*10) [1..23]
01:57:41 <lambdabot>  ([110,120,130,140,150,160,170,180,190,200,210,220,230],[10,20,30,40,50,60,70...
01:57:51 <RadBaddy> > partition (>100) $ map (*1) [1..23]
01:57:53 <lambdabot>  ([],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23])
01:57:55 <AlecTaylor> Fancy
01:58:06 <RadBaddy> partition junky baker
01:58:41 <AlecTaylor> RadBaddy: Hadn't used the `partition` function before! :)
01:59:01 <RadBaddy> partition (<200) $ map (/10) [1..100]
01:59:09 <RadBaddy> partition (>200) $ map (/10) [1..100]
01:59:32 <RadBaddy> Thim lin your fre wit chim probay industrie Play ea now with isie.
01:59:34 <RadBaddy> We'll of les.
01:59:36 <RadBaddy> We does. It's fly bably in't dow with Mentoo does, Vionic lisis biol. MandelayStating coo! Withe theaver. Increstriesh goes bably ing jettentos th asis of Diving full ove wit molin to your withe cook dit Korthe tos Xbox, frehe his, Lizard Stay. Mandelay molea maker withe baby, Lizard we'll of legs. As th MandelayStay execs. Vandust. Mento dresh goesh andelayindelay bes. Mandelay. Mentool. 
01:59:40 <RadBaddy> Nes. Sonies.
01:59:41 <RadBaddy> Fifa, the egs, besh goes, st Kork! Woreasy isis frea! Desh goeshmatter, Vands ove th Koreasy maker.
01:59:42 <RadBaddy> Neshnets frea nown you! Dee of Diving come.
01:59:42 <RadBaddy> Thing jette Lizard whating flis bay execs. MandelayStay, Vandelay. Man. Vandelay, Call life!
01:59:43 <RadBaddy> Biony! Stay. Desh Mento dos of livat comesh Mentoo fly hate I'm lea! It dook dit Korthis, now wit molife! Duty, fresn't mesh in andelayindelay, is molis ford!
01:59:45 --- mode: ChanServ set +o Cale
01:59:45 <RadBaddy> We affly legs! Diver, Call of Squad. As hatead betworeasis bette Lizard!
01:59:47 <RadBaddy> We'res.
01:59:48 --- mode: Cale set +b *!*@121.127.12.242
01:59:48 --- kick: RadBaddy was kicked by Cale (RadBaddy)
02:00:06 --- mode: Cale set -o Cale
02:00:19 <[k-> This text was spammed on #ruby too :(
02:01:52 <aisqwe> i saw this code "take 10 . sort" , does this mean do enough work until the first 10 sorted values are produced?
02:02:16 <[k-> Yes
02:02:54 <ion> Given the implementation of sort in Prelude, yes.
02:03:21 <aisqwe> [k-: what sort is being used here?
02:04:24 <[k-> Most likely Prelude? Like what ion said
02:04:29 <larrycv> isnt that result of a lazy evaluation, and not a specific sorting algirithm?
02:06:27 <[k-> I think Prelude.sort uses quicksort tho
02:06:34 <[k-> [citation needed]
02:06:51 <ion> IIRC someone measured head . sort to take 1.4× the time compared to minimum
02:07:45 <ion> It matters whether the algorithm does O(n) work to produce the first output element or more
02:08:03 <ion> I think it may be merge sort
02:08:16 <ion> Look up the code to check
02:11:05 <AlecTaylor> [k- / Cale: He also spammed #go-nuts
02:11:21 <AlecTaylor> Maybe he installed a weird plugin to his IRC client
02:11:57 <quazimodo> ion: so i was bumping around in ruby land to solve this problem of loading several csv files ~ 1 000 000 rows each into memory to do calculations. The loading took a while and was a bit annoying, the calculations didn't take long and were fine... but it eats memory. I thought maybe i'll do it in haskell for kicks
02:12:03 <AlecTaylor> Or was just an annoying guy >.<
02:12:26 <AlecTaylor> quazimodo: Sounds like a job for RDDs
02:12:35 <quazimodo> so i need to read my csvs, express them as efficient and small in memory representations and then do calculations (basic), and provide all of this as a daemon 
02:12:43 <AlecTaylor> quazimodo: What calculations specifically?
02:12:45 <quazimodo> so i can have it as an eternal procsess
02:12:49 <Haskellfant> quazimodo: depending on what you want to do, you can stream the data using constant memory using pipes-csv or the conduit equivalent
02:12:59 <quazimodo> AlecTaylor: too simple, don't really need relational algebra
02:13:17 <AlecTaylor> quazimodo: SUM, MEAN, STDEV?
02:13:20 <[k-> The source uses mergesort!
02:13:52 <quazimodo> AlecTaylor: even simpler. Find 1 row in csv file 1, get it's 3rd col, find the corresponding row in csv file 2, get its 2nd col, etc
02:14:03 <quazimodo> it *can* be done very simply in relational algebra
02:14:16 <quazimodo> but then i'd have no haskell project to do :(
02:14:22 <AlecTaylor> quazimodo: Why not C++? :P
02:14:27 <quazimodo> ^
02:14:57 <AlecTaylor> quazimodo: Here's the code you need: http://stackoverflow.com/q/18274582 => pretty obvious how it all works (see the answers)
02:15:42 <AlecTaylor> Just push the 2nd col values to a vector, and look in that vector each CSV file opening to get the key you need
02:15:44 <quazimodo> lol i want to do it in hask!
02:16:41 <AlecTaylor> Maybe Parsec? - http://book.realworldhaskell.org/read/using-parsec.html
02:16:49 <quazimodo> AlecTaylor: the calculation strategy is dependent on different things for different modules, there will be several modules each completely different. the simplest one is jsut a single row lookup comparing 3 or 4 col values to find the minimum
02:16:56 <quazimodo> but anyway
02:17:10 <quazimodo> i just really really want to wrap my head around haskell
02:19:23 <AlecTaylor> quazimodo: https://www.fpcomplete.com/project/119474/OkbHvPZQXV
02:20:29 <quazimodo> hrm
02:20:32 <AlecTaylor> Slightly different to your use-case, but can be easily adapted for it. Provides all the building-blocks: https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/attoparsec
02:20:33 <quazimodo> browser based ide?
02:20:46 <AlecTaylor> Sure, why not
02:20:59 <AlecTaylor> (for Haskell I use Atom or JetBrains TBH)
02:21:10 <quazimodo> i don't know :)
02:21:16 <quazimodo> i can't live without emacs bindings
02:21:23 <Geraldus> hi friends!
02:21:24 <Haskellfant> I think they actually have emacs bindings :)
02:21:33 <quazimodo> Haskellfant: or the web based one?
02:21:43 <Haskellfant> yeah the web based one
02:22:05 <quazimodo> Haskellfant: lol the world's getting weird
02:22:10 <AlecTaylor> xD
02:22:10 <AlecTaylor> quazimodo: Anyway, checkout the links I sent you, you should have this project finished in an hour ;)
02:22:17 <quazimodo> the internet is turning into X window system
02:22:20 <quazimodo> it's pretty funny
02:23:03 <quazimodo> AlecTaylor: yeah i still don't know haskell syntax properly
02:23:05 <quazimodo> 1 hour
02:23:09 <Geraldus> I have a word32 value which is encoded ipv4 address. I want to turn this one into four groups. For example number 16777343 decodes to 1000000000000000001111111, which represents 1.0.0.127 sequence.
02:23:11 <AlecTaylor> (in a good way)
02:23:11 <AlecTaylor> quazimodo: Now we just need to wait for lynx to support JavaScript :v
02:23:26 <quazimodo> lol
02:24:02 <quazimodo> sad to see so much brilliance directod tewards some really boring stuff
02:24:20 <Geraldus> I'm not strong with binary manipulations, I guess this is quite easy how can do that?
02:25:06 <quazimodo> AlecTaylor: i'd love to see a *powerful* ruby refactoring tool for emacs tbh tho
02:25:12 <AlecTaylor> quazimodo: As said, that tutorial gives you all the building-blocks you need.
02:25:12 <AlecTaylor> Geraldus: https://hackage.haskell.org/package/network-ip-0.1/docs/Network-IP-Addr.html
02:25:12 <AlecTaylor> Geraldus: Use that package then the `Binary Net4Addr`
02:25:19 <quazimodo> i imagine refactoring power is even more important in hask
02:25:31 <quazimodo> AlecTaylor: yep i'm reading it now
02:26:12 <AlecTaylor> And you're done
02:26:12 <AlecTaylor> Ruby and emacs suck
02:26:12 <AlecTaylor> Use C++ and nano ;)
02:26:13 <AlecTaylor> cul
02:30:08 <aisqwe> [k-: where did you look for source code of prelude's sort?
02:30:40 <[k-> It's available when you search hoogle for sort 
02:30:55 <[k-> And click the source button on the top right of the sort entry
02:43:54 * hackagebot neet 0.1.0.0 - A NEAT library for Haskell  http://hackage.haskell.org/package/neet-0.1.0.0 (hijiri)
02:54:00 <alisia> hexagoxel, ping
02:54:26 <mpickering> how can I install an executable into ~/.cabal/bin when are my dependencies are installed in a snadbox??
02:58:57 <ion> Copy the binary manually? :-P
02:59:26 <mpickering> ah I was told that's not the correct thing to do anymore
03:01:49 <Geraldus> AlecTaylor: thank you, let me have a look
03:08:55 * hackagebot extra 1.3 - Extra functions I use.  http://hackage.haskell.org/package/extra-1.3 (NeilMitchell)
03:16:39 <AlecTaylor> Geraldus: np
03:24:40 <dibblego> :t fmap id :: Monad f => f a -> f a -- this works on >= 7.10 but the hackage build fails, why is this?
03:24:41 <lambdabot> Monad f => f a -> f a
03:25:19 <hexagoxel> mpickering: cabal install --bindir=$HOME/.cabal/bin --data-dir=$HOME/.cabal/share
03:26:32 <lspitzner> muller: pong
03:28:02 <mudphone> Anyone going to ICFP/CUFP? Wondering if they usually have a hotel rate?
03:28:55 * hackagebot notzero 0.0.8 - A data type for representing numeric values, except zero.  http://hackage.haskell.org/package/notzero-0.0.8 (TonyMorris)
03:33:56 * hackagebot sys-process 0.1.1 - A replacement for System.Exit and System.Process.  http://hackage.haskell.org/package/sys-process-0.1.1 (TonyMorris)
03:44:14 <dzack> mpickering: you might try --symlink-bindir=~/.cabal/bin
03:44:22 <dzack> as an arg to cabal install
03:48:03 <mpickering> thanks dzack hexagoxel 
03:48:36 <mpickering> on the other hand.. I did just get hlint to automatically apply suggestions .. :o
03:50:47 <mpickering> symlink bindir looks promising
04:03:57 * hackagebot ekg-bosun 1.0.4 - Send ekg metrics to a Bosun instance  http://hackage.haskell.org/package/ekg-bosun-1.0.4 (OliverCharles)
04:05:59 <gurubhai123> :t sum
04:06:00 <lambdabot> (Num a, Foldable t) => t a -> a
04:08:08 <tedkornish> :t swap
04:08:09 <lambdabot> (a, b) -> (b, a)
04:08:29 <dramforever> @where swa
04:08:29 <lambdabot> I know nothing about swa.
04:08:35 <dramforever> @where swap
04:08:35 <lambdabot> I know nothing about swap.
04:08:57 * hackagebot HueAPI 0.2.5 - API for controlling Philips Hue lights  http://hackage.haskell.org/package/HueAPI-0.2.5 (SjoerdVisscher)
04:12:13 <ocramz> I've read somewhere that Haskell is a gateway drug to PHP
04:13:57 * hackagebot discrete-space-map 0.0.4 - A discrete space map.  http://hackage.haskell.org/package/discrete-space-map-0.0.4 (SjoerdVisscher)
04:15:23 * dramforever is trying nix
04:23:57 * hackagebot sys-process 0.1.2 - A replacement for System.Exit and System.Process.  http://hackage.haskell.org/package/sys-process-0.1.2 (TonyMorris)
04:27:54 <ocramz> question: what's a sensible way to handle foreign function exceptions?
04:28:24 <ocramz> namely, impure functions that return an integer error code as well 
04:33:58 * hackagebot keera-posture 0.1.4.4 - Get notifications when your sitting posture is inappropriate.  http://hackage.haskell.org/package/keera-posture-0.1.4.4 (IvanPerez)
04:48:59 * hackagebot hid 0.2 - Interface to hidapi library  http://hackage.haskell.org/package/hid-0.2 (DimitriSabadie)
04:58:59 * hackagebot ghcid 0.5 - GHCi based bare bones IDE  http://hackage.haskell.org/package/ghcid-0.5 (NeilMitchell)
04:59:30 <clinton> Hi all I was just looking for the details of the function "warp" (in http://hackage.haskell.org/package/yesod-core-1.4.11/docs/Yesod-Core-Dispatch.html ) but when I did a search on Hayoo ( http://hayoo.fh-wedel.de/?query=warp ) none of the results was the warp function. Nor when I did a search on hoogle ( https://www.haskell.org/hoogle/?hoogle=warp ) did the warp function occur. Is there a way to search all of hackage? I know I've foun
04:59:30 <clinton> d the "warp" function using google this time but I'd rather be able to use hackage/hayoo directly.
05:01:28 <dramforever> clinton: interestingly, hoogle for "warp +yesod-core" works, but that might not be what I want
05:01:32 <ocramz> clinton: not all packages are indexed in hayoo or google
05:01:35 <dramforever> +yesod-core adds that package
05:02:01 <ocramz> I mean hoogle
05:02:03 * dramforever wonders if there's a way to download a full index
05:02:42 <ocramz> dramforever: like parsing the whole of hackage?
05:02:52 <ocramz> or, querying it
05:02:57 <dramforever> yep
05:03:03 <clinton> yeah, there's a lot of cross package stuff happening in yesod, so naming the package kind of defeats the purpose
05:03:06 <dramforever> well, download all haddocks
05:03:14 <dramforever> maybe
05:07:03 <ocramz> dramforever, clinton : there is a (rather undocumented) hackage api https://hackage.haskell.org/api#documentation-core 
05:09:18 <lf94> what are some really elegant haskell programs guys?
05:09:22 <lf94> or a nice list of haskell idioms?
05:09:48 <dramforever> lf94: depending on taste lens might be really elegant or really annoyingly confusing
05:11:37 <maerwald> lf94: do you mean elegant in the sense of impossible to understand?
05:11:49 <ocramz> lf94: read ALL the Functional Pearls
05:11:50 <ocramz> http://www.cs.tufts.edu/~nr/cs257/archive/richard-bird/sudoku.pdf
05:13:30 <maerwald> you mean this? http://www.clyce.net/wp-content/uploads/2013/02/Pearls-of-Functional-Algorithm-Design.pdf
05:20:23 <safinaskar> > 0
05:20:25 <lambdabot>  0
05:30:21 <magneticDuck> >O_/
05:39:01 * hackagebot sys-process 0.1.3 - A replacement for System.Exit and System.Process.  http://hackage.haskell.org/package/sys-process-0.1.3 (TonyMorris)
06:36:37 <Taki_> Data.Map.fromList :: (Ord k) => [(k,v)] -> Data.Map k v        How comes Data.Map is: Data.Map k v and not Data.Map [k] [v]?  Thought that Data.Map results in a list of keys and values?
06:37:58 <mniip> Taki_, no?
06:38:08 <mniip> map is a correspondence between keys and values
06:39:31 <Taki_> k and v can have multiple values attached to it?  still confused... thinking that k and v represent a single key and single value
06:39:59 <mniip> k and v might be used multiple times inside the Data.Map type
06:40:14 <mniip> see for example, how a is used multiple times in [a]
06:40:30 <mniip> (and [a] is basically syntactic sugar for '[] a')
06:40:40 <Taki_> yeah, guess I get it
06:40:58 <Taki_> thanks mniip
06:44:47 <chpatrick1> hey haskell
06:44:53 <chpatrick1> here's my problem
06:45:05 <chpatrick1> I have a bunch of types that are essentially wrappers around ForeignPtrs
06:45:24 <chpatrick1> I want to provide an Eq instance that does some foreign calls to determine if they are equivalent
06:45:38 <chpatrick1> however, I'd also like to provide an Ord instance for the usual reasons
06:46:09 <chpatrick1> so I can make an Ord instance based on the inner ForeignPtr, but that will be inconsistent with the Eq instance
06:46:18 <chpatrick1> as in, < will not be transitive
06:46:30 <chpatrick1> can you think of a nice way to fix it?
06:53:28 <chpatrick1> ok so it's a total order but not a strict total order
07:02:30 <[k-> http://goruco.com - conference happening live
07:03:24 <silver> conference about haskell?
07:04:20 <[k-> Not specifically
07:04:30 <[k-> But mostly Ruby devs giving speeches
07:04:49 <[k-> But well the website didn't say it was oriented towards Ruby
07:06:33 <[k-> Hmm, well the schedule looks very rubyish
07:06:39 <[k-> Sorry for posting it here :p
07:06:46 <[k-> Saw it on YouTube 
07:07:37 <[k-> At first I thought it was a go conf
07:07:37 <frerich> chpatrick1: I'm not familiar with what a 'total order' or a 'strict total order' is, but maybe you could define 'Eq' in terms of Ord like 'a == b' = not (a < b) && not (b < a)'?
07:09:04 * hackagebot record-preprocessor 0.1.0.3 - Compiler preprocessor introducing a syntactic extension for anonymous records  http://hackage.haskell.org/package/record-preprocessor-0.1.0.3 (NikitaVolkov)
07:09:10 <jume> @pl \x y -> x^2 - y^2 + x (-y)
07:09:10 <lambdabot> ap (ap . ((+) .) . (. (^ 2)) . (-) . (^ 2)) (. negate)
07:09:59 <quchen> jume: That's not well-typed
07:10:07 <quchen> :t \x y -> x^2 - y^2 + x (-y)
07:10:08 <lambdabot>     Occurs check: cannot construct the infinite type: t ~ a -> t
07:10:08 <lambdabot>     Relevant bindings include
07:10:08 <lambdabot>       y :: a -> t (bound at <interactive>:1:4)
07:10:18 <quchen> You're applying the "x" function to "(-y)" there
07:10:35 <jume> quchen ahh i see. 
07:11:33 <safinaskar> please, give me some good large tutorial on lenses and lens library
07:11:42 <jume> quchen: thanks. I'll try it without an infix operator
07:11:56 <quchen> jume: I'm not sure what you meant to write
07:13:14 <jume> quchen: just working through a tutorial on fpcomplete
07:13:52 <quchen> jume: @pl is rarely helpful if you have deeply nested expressions, you usually get this sort of mess with ap and >>= and flip and what not
07:15:44 <jume> quchen: gotcha thank you. I just discovered pl last week and have been enjoying playing around with it. Sometimes the output is less clear than the input.
07:17:20 <chpatrick1> frerich: Eq is set in stone
07:19:14 <alpounet> safinaskar: https://github.com/ekmett/lens/pull/552#issuecomment-113741465 ?
07:26:47 <fizbin> Am I missing something, or does the haddock about the instances for Tagged have an extra parameter on https://hackage.haskell.org/package/tagged-0.7.2/docs/Data-Tagged.html#t:Tagged ?
07:27:15 <fizbin> I can't see "k" in the source, so is Haddock just screwing up, or am I missing something?
07:27:29 <shachaf> k is the kind.
07:27:38 <shachaf> GHC represents this in a somewhat confusing way.
07:27:39 <quazimodo> parseOnly :: [ Parser a - .. ] 
07:27:46 <quazimodo> what on earth does that say?
07:27:59 <fizbin> shachaf: I don't understand.
07:28:05 <Cale> fizbin: Yeah, it's a Haddock bug
07:28:12 <quazimodo> it's a function that has a list of Parser a something something?
07:28:13 <shachaf> Tagged is kind-polymorphic.
07:28:24 <fizbin> I thought kind referred to how many arguments a type takes.
07:28:29 <Cale> fizbin: Internally, there is an additional kind parameter, which is erroneously being displayed in the documentation
07:28:45 <fizbin> Ah. That would be the kind of s?
07:29:02 <Cale> fizbin: yeah
07:29:22 <shachaf> Saying "kind refers to how many arguments a type takes" is like saying "type refers to how many arguments a value takes".
07:29:59 <fizbin> I've only ever seen kinds of the form * , * -> *, * -> * -> *, etc.
07:30:34 <fizbin> I guess though that kind (* -> *) -> * is different from kind * -> (* -> *)
07:32:29 <fizbin> Ah there kinds other than * and k1 -> k2, where k1 and k2 are both kinds?
07:32:44 <shachaf> There ah in GHC.
07:34:47 <badmash> hey -- need some help. i installed haskell platform on my Mac os x (yosemite), and it has put lot of ghc related binaries in /usr/bin.  is it safe to move these binaries to /usr/local/bin instead?  i don't want to mess with /usr/bin because that should real contain binaries that come with os x.  which is why i want to move ghc and haskell platform related binaries from /usr/bin to /usr/local/bin.  is it safe to do t
07:34:47 <badmash> his or will this screw up the haskell platform in anyway?
07:34:55 <quchen> fizbin: Type-level literals have their own kinds, for example.
07:34:57 <quchen> :k "hello"
07:34:58 <lambdabot> GHC.TypeLits.Symbol
07:35:08 <quchen> :k 1
07:35:09 <lambdabot> GHC.TypeLits.Nat
07:35:42 <fizbin> :k 1.2
07:35:44 <lambdabot> parse error on input ‘1.2’
07:36:06 <Cale> badmash: I doubt it'll work to just move it. When you configure GHC for installation, you can set the installation prefix though.
07:37:03 <quchen> fizbin: And then there's the rest of DataKinds, which allows you to create your own kinds. https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/promotion.html
07:37:38 <quazimodo> anyone?
07:37:41 <badmash> Cale: well, i just downloaded the haskel platform and installed it.  i don't think it gave me any option for installation prefix.  i don't remember anyway.
07:37:45 <quazimodo> I have no idea what this syntax menas
07:37:46 <quazimodo> parseOnly :: [ Parser a - .. ]
07:38:02 <Cale> quazimodo: That isn't valid Haskell syntax
07:38:48 <Cale> Where are you reading it?
07:40:10 <quazimodo> Cale: odd
07:40:24 <quazimodo> Cale: it's my emac's haskell function info returning that
07:40:36 <badmash> so even if /usr/local/bin is in my PATH, you don't think i can move haskell and ghc related binaries from /usr/bin to /usr/local/bin?
07:41:02 <quazimodo> (haskell-process-do-type &optional INSERT-VALUE) Print the type of the given expression
07:41:07 <Cale> quazimodo: Maybe some kind of bug in the emacs mode
07:41:45 <Cale> quazimodo: You'll find it's much more reliable just to ask ghci about things like that :)
07:42:07 <Cale> badmash: Maybe if you only move the binaries... even then, I wouldn'
07:42:14 <Cale> I wouldn't be too sure
07:42:32 <quchen> badmash: The option is a bit hidden. When you run ./configure, you can specify your directory with --prefix=/usr/foo/bar
07:42:53 <Cale> yeah, the right way is to do it at configure time
07:42:57 <quchen> badmash: And while you're at it --bindir is where the binaries are put
07:43:06 <quchen> badmash: Have a look at ./configure --help for all options
07:43:37 <badmash> Cale: quchen: ok
07:44:06 * hackagebot second-transfer 0.5.4.0 - Second Transfer HTTP/2 web server  http://hackage.haskell.org/package/second-transfer-0.5.4.0 (dsign)
07:44:26 <quchen> So I'm playing with unsafeCoerce, and I've run into a segfault I don't understand: http://lpaste.net/134811
07:45:05 <quchen> I'm looking at a Data.Map.Map via abuse of coercion to my own type.
07:45:06 <Cale> quchen: I'm actually happy that segfaults :D
07:45:14 <quchen> Cale: Excellent! :-)
07:45:44 <quchen> Cale: Is it a rational or irrational kind of happiness?
07:45:49 <quchen> If rational, please tell :-)
07:46:22 <Cale> unsafeCoerce :: a -> b is only supposed to work in cases where a = b
07:46:29 <badmash> Cale: quchen: the ./configure will work for the Haskell platform as a whole ( i downloaded the Haskell platform) or for just GHC?
07:46:39 <Cale> In this case, a is not equal to b, they are separately defined types
07:46:55 <quchen> Cale: But they should have the same runtime representation, no?
07:47:28 <Cale> I wouldn't rely on it
07:47:35 <quchen> Cale: unsafeCoerce (Newtype x) to x works as well, although x and Newtype x are different in a way
07:47:43 <Cale> It's possible that compiler flags affect the runtime representation somewhat.
07:47:54 <quchen> Hm.
07:47:57 <Cale> (Though I dunno)
07:48:22 <Cale> The key thing should just be to not try to make that kind of evil work
07:48:26 <quchen> Too bad. The trick worked for me a couple of times already. I was hoping I could write it up as a dirty pattern :-)
07:56:03 <Cale> quchen: To be a bit clearer about why one might be happy to see that -- it reflects GHC's right to compile the data type differently based on context. I'm not sure GHC actually does anything like this, but you can imagine situations where it looks at all the usages of the data type in the same module and given that the constructors are not exported, does something to optimise the representation.
07:56:39 <quchen> Good point.
07:59:13 <supki> quchen: does it segfault for you if you compile with -O2?
07:59:25 <quchen> supki: Let me check
08:00:19 <quchen> supki: Oh!
08:00:24 <quchen> No, it does not.
08:00:25 <quazimodo> Cale: it works through ghch
08:00:39 <quazimodo> *ghci, it runs ghci as a child process
08:01:05 <quchen> supki: Containers has -O2 in its .cabal, aaah.
08:04:07 * hackagebot api-builder 0.7.3.0 - Library for easily building REST API wrappers in Haskell  http://hackage.haskell.org/package/api-builder-0.7.3.0 (Intolerable)
08:09:07 * hackagebot api-builder 0.7.4.0 - Library for easily building REST API wrappers in Haskell  http://hackage.haskell.org/package/api-builder-0.7.4.0 (Intolerable)
08:20:19 <quchen> Has anyone parsed PHP to an AST in Haskell? I'd hate having to build that myself because I fear PHP's grammar ;-) There is a blogpost by someone who wanted to build a PHP interpreter in Haskell which seems to include something, but maybe there's something better around.
08:24:08 * hackagebot shake 0.15.3 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.15.3 (NeilMitchell)
08:24:10 * hackagebot shake 0.15.4 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.15.4 (NeilMitchell)
08:24:12 * hackagebot cryptonite 0.4 - Cryptography Primitives sink  http://hackage.haskell.org/package/cryptonite-0.4 (VincentHanquez)
08:45:43 <quchen> dcoutts: And news on CBOR? I've been on a hot seat since Zurich :-)
08:59:09 * hackagebot hid 0.2.1 - Interface to hidapi library  http://hackage.haskell.org/package/hid-0.2.1 (DimitriSabadie)
09:10:49 <icicled> has anyone seen something similar to this while trying to install a package via cabal?: http://lpaste.net/286230489054838784
09:11:49 <saep> icicled: Try `cabal install entropy -j1`.
09:12:11 <mpickering> I just managed to install it fine
09:12:54 <icicled> I got the following: http://lpaste.net/3492738469636079616
09:14:17 <icicled> the same issue happens on 2 of my computers
09:15:38 <saep> Maybe a bug in cabal.
09:16:35 <saep> I can build it just fine.
09:16:45 <icicled> saep, which version are you using?
09:17:13 <saep> cabal-install: 1.22.3.0 and Cabal: 1.22.2.0
09:18:06 <icicled> I'm on cabal-install 1.22.5.0 and Cabal: 1.22.4.0
09:18:13 <icicled> hoo boy
09:18:26 <icicled> I thought installing stuff would be easy >_>
09:20:13 <phaazon> god guys
09:20:14 <kadoban> cabal-install 1.22.5.0 seemed just totally broken to me when I tried. I had to upgrade to 1.22.6.0 or whatever
09:20:18 <phaazon> I feel so nice!
09:20:27 <phaazon> I just wrote a tool in Haskell to change MIS keyboard colors!
09:20:29 <phaazon> MSI*
09:20:37 <phaazon> it should appear here
09:20:40 <phaazon> feel free to use :)
09:20:47 <phaazon> I wrote it with my hid API
09:22:22 <icicled> kadoban, oh there's a new version out already
09:22:38 <Welkin> kadoban: it is broken
09:23:13 <Welkin> icicled: yes, 1.22.6 is the one to get
09:23:33 <Welkin> make sure to cabal update every time
09:23:34 <icicled> looks like it's fixed
09:24:10 * hackagebot msi-kb-backlit 0.1 - A command line tool to change backlit colors of your MSI  keyboards  http://hackage.haskell.org/package/msi-kb-backlit-0.1 (DimitriSabadie)
09:24:58 <lolisa> Hi, does anyone know about CSP? I am confused about the implementation of CSP monad (not CPS, CSP)
09:25:18 <lolisa> http://hackage.haskell.org/package/csp-1.0/docs/src/Control-Monad-CSP.html
09:25:28 <icicled> Welkin, I'm trapped - I can't upgrade or downgrade cabal-install with just cabal - time to redownload it and build
09:25:34 <icicled> thanks for your help everyone
09:25:36 <Welkin> icicled: yes
09:25:56 <Welkin> https://www.haskell.org/cabal/download.html
09:26:02 <lolisa> type Constraint r = AmbT r IO ()
09:26:08 <Welkin> luckily, cabal-install is very easy to install
09:26:18 <lolisa> My question is why does this need IO?
09:26:57 <haskell628> hey! can someone help me what this function does? I have to create a type tree and don't know what to do...
09:26:58 <haskell628> http://lpaste.net/3340349516690751488
09:28:30 <kaidelong> it doesn't do anything
09:28:34 <kaidelong> it's "id id"
09:28:43 <kaidelong> well
09:28:46 <kaidelong> not quite
09:29:10 * hackagebot msi-kb-backlit 0.1.0.1 - A command line tool to change backlit colors of your MSI  keyboards  http://hackage.haskell.org/package/msi-kb-backlit-0.1.0.1 (DimitriSabadie)
09:29:12 <Welkin> :t ($)
09:29:13 <lambdabot> (a -> b) -> a -> b
09:29:15 <kaidelong> (`id` id)
09:29:46 <haskell628> ok? would i be correct in first saying it is an application
09:29:54 <monochrom> haskell628: where does this question come from?
09:29:59 <haskell628> and the using an abstraction?
09:30:03 <haskell628> *then
09:31:38 <haskell628> it's an asignment for my haskell class so to say. I can already do it with simpler functions but here I'm not quite sure what would be the type of x and y
09:32:14 <monochrom> can we see the verbatim assignment quesiton?
09:32:25 <kaidelong> yeah in particular, what is that turnstile for
09:32:45 <haskell628> ok but I'll have to translate it first because it's in german
09:33:25 <kaidelong> I can read German and I think monochrom can too?
09:33:53 <monochrom> I don't know.
09:33:59 <kaidelong> although translating it might still be good
09:34:11 <haskell628> well ok then I'll post in german (and try translating it)
09:34:17 <Welkin> kaidelong: haha, a turnstile
09:34:27 <Welkin> that doesn't look like haskell
09:34:33 <Welkin> or regular math notation
09:34:33 <kaidelong> Welkin: they really call it that
09:34:37 <Welkin> really?
09:34:41 <haskell628> Erstellen Sie eine Typherleitung f¨ur folgendes Typurteil:  *Dann kommt mein lpaste code*  Sie d¨urfen sich aussuchen, ob Sie die Herleitung in Baum-Notation oder in linearer Notation verfassen.
09:34:47 <Welkin> that is so european
09:34:56 <monochrom> I don't know because "can read daily German" is completely uncorrelated to "can guess Haskell German".
09:35:40 <monochrom> I once completely guessed a MSc thesis written in Polish without ever seeing Polish before.
09:35:44 <dzack> is there a way to match multiple guard conditions to a single right hand side?
09:36:02 <dzack> or multiple case matches, either way
09:36:02 <haskell628> Deduce the type for the following type judgement *then here would be my lpaste code* It's up to you if you want to create it in Tree-Notation or linear notation
09:36:42 <kaidelong> oh alright
09:36:53 <kaidelong> so f is bound to a value (a -> a) -> (b -> b)
09:37:05 <kaidelong> and you are supposed to show how type inference arrives at b -> b
09:37:09 <kaidelong> for the expression as a whole
09:37:25 <kaidelong> are you working from a textbook?
09:37:41 <haskell628> nope I've only got my lecture notes...
09:37:50 <kaidelong> that's awful
09:37:52 <kaidelong> well
09:37:56 <kaidelong> are the lecture notes online?
09:38:07 <haskell628> i could post a solution that my tutor made which is the best for learning
09:38:31 <kaidelong> so you have a solution but you are struggling to understand it?
09:38:39 <haskell628> http://lpaste.net/5989701141200371712
09:39:00 <haskell628> no I have the solution to a different function. I just want to show you what I have to do roughly
09:40:21 <kaidelong> so this demonstrates the tree notation, I seee
09:40:26 <haskell628> I think the first step for solving my problem would be to use an application and then use an abstraction for x and y
09:40:40 <haskell628> but i don't know the type of x and y
09:42:00 <kaidelong> then you have one type given to you, f, on the left of the turnstile
09:43:38 <haskell628> yeah but i also know the type on the right
09:43:43 <haskell628> beta -> beta
09:43:58 <kaidelong> I don't know if he is working from the leaves to the root, or the root to the leaves, or from leaves to leaves but
09:44:08 <kaidelong> assuming he is working from root to leaves
09:44:24 <haskell628> yeah you start at the bottom and go up
09:45:21 <kaidelong> the first step appears to be to beta reduce the expression
09:45:48 <haskell628> what do you mean by that?
09:46:04 <kaidelong> replace x with (
09:46:09 <kaidelong> \y -> y
09:46:18 <kaidelong> presumably this is what the App step is supposed to do
09:46:36 <kaidelong> so you end up branching your tree straight away
09:46:53 <haskell628> why do i have to replace x?
09:47:44 <kaidelong> because from context you know that x is always going to be applied to (\y -> y)
09:47:47 <kaidelong> err
09:47:51 <kaidelong> not applied to
09:47:54 <kaidelong> substituted by
09:48:03 <kaidelong> that is statically known from the expression itself
09:48:13 <kaidelong> oh
09:48:17 <kaidelong> that's not how he does it though
09:48:26 <haskell628> I'd do it like that
09:48:26 <haskell628> http://lpaste.net/7189135573959835648
09:48:40 <kaidelong> yes
09:48:44 <haskell628> again asuming K is the {}
09:48:48 <kaidelong> that seems to be what your tutor is doing
09:48:49 <kaidelong> although
09:49:02 <kaidelong> shouldn't f be preserved?
09:49:11 <kaidelong> you don't lose the information about f, moving to the leaves
09:49:28 <kaidelong> or is K just shorthand for "nothing changed?"
09:49:34 <haskell628> yeah yeah the bracets are just empty because i was to lazy to type everything out
09:49:55 <haskell628> K is shorthand for Kontext which means nothing has changed in the bracets
09:52:26 <kaidelong> oh it says right in the example
09:52:38 <kaidelong> it's the current context, everything between brackets?
09:52:40 <haskell628> my next step would be this but I don't know what x and y should have as types there:
09:52:41 <haskell628> http://lpaste.net/7189135573959835648
09:52:44 <kaidelong> if I am reading that right
09:52:45 <haskell628> yes!
09:54:01 <alisia> hexagoxel, ping
09:54:24 <hexagoxel> alisia: pong
09:55:10 <haskell628> is the type for x alpha -> alpha? and for y just beta?
09:55:14 <kaidelong> okay well the application rule seems to mean you want to give (\y -> y) the type of some new free variable c and (\x -> f x) the type c -> -> (b -> b)
09:55:24 <kaidelong> c -> (b -> b) *
09:55:44 <kaidelong> then you want to abstract on (\y -> y) to unify c with some d -> d
09:56:20 <kaidelong> wait, no, I'm wrong
09:56:30 <alisia> hexagoxel, he he. I tried to veryfy the monad laws. It looks like it obeys the 3 laws. http://lpaste.net/134859. 
09:57:57 <alisia> hexagoxel, I used equational reasoning to prove the laws. Is that good enough?
09:58:32 <haskell628> kaidelong I don't really understand...
09:59:05 <kaidelong> give me a second to work through the problem
09:59:17 <alisia> hexagoxel, If you don't remember what this is about. It is about a do block when desugared, producing different results...
10:00:42 <hexagoxel> alisia: in line 24, you use `(\st -> (st, x))`. but that is only one among many possible expressions of type `[st]-> ([st], a)`
10:00:42 <lolisa> For what monad? I love verification (Coq user here
10:01:12 <haskell628> alright
10:03:38 <kaidelong> haskell628, your tutor's example doesn't really talk about how you use what's in the brackets in subsequent expressions, is that the Var rule?
10:03:39 <Guest1> if you want an nice chat with new users and new network so visit us on /server irc.ind.in:6667 -j #lobby and have fun, enjoy your chat. Thanks.
10:04:00 <Welkin> an nice?
10:04:05 --- mode: ChanServ set +o geekosaur
10:04:13 <Welkin> that didn't even make sense
10:04:15 <geekosaur> ...already gone
10:04:17 --- mode: geekosaur set -o geekosaur
10:04:19 <Welkin> it was pidgin
10:04:42 <haskell628> You use the types that are in the bracets to then defined the variables yes
10:05:10 <alisia> hexagoxel, Oh. yes. you are saying st in argument and st in the body can be different, but same type...right?
10:05:28 <alisia> i mean, different values..but same type.
10:05:46 <hexagoxel> yes
10:08:03 <hexagoxel> alisia: i'll write the general version, give me a moment
10:08:15 <JoshieAS> How do I use Data.Text(strip)?
10:08:16 <kaidelong> okay well, I doubt I can help you, I know you need to unify (a -> a) with the type given to y somehow
10:08:27 <JoshieAS> WHen I feed it a String, it tells me it's not Text
10:08:27 <kaidelong> but it's not clear from your tutor's example how they expect you to demonstrate this to them
10:09:38 <Welkin> :t Data.Text.strip
10:09:39 <lambdabot> Data.Text.Internal.Text -> Data.Text.Internal.Text
10:09:47 <alisia> hexagoxel, yes.
10:09:48 <Welkin> JoshieAS: because it only accepts a Text
10:09:50 <haskell628> ok red mer deutsch weil ich  das auch auf englisch schon nicht versteh und eh niemand mitliest
10:10:01 <Welkin> to convert a String -> Text you use Data.Text.pack
10:10:02 <haskell628> was muss ich genau machen?
10:10:17 <Welkin> otherwise, use the string version
10:11:19 <JoshieAS> Welkin: Thanks!
10:13:08 <ion> Ai, tällä puhutaan kielillä.
10:13:30 <zomg> perkele
10:14:05 <haskell628> @kaidelong Ich glaub ich weiß was die funktion jetzt macht. das is einfach die twice funktion oder?
10:14:05 <lambdabot> Unknown command, try @list
10:14:13 <ReinH> haskell628: you don't need to know what it does, you just need to show that, given the type of f, (\x -> f x) (\y -> y) is of type β → β
10:14:49 <haskell628> yeah but what is the type of x and y? 
10:15:09 <ReinH> x is the first argument to f, so what is its type?
10:15:19 <haskell628> (a->a)?
10:15:26 <haskell628> and y has tzhe type beta?
10:17:25 <ReinH> :t \y -> y
10:17:27 <lambdabot> r -> r
10:17:41 <ReinH> \y -> y is an identity function
10:18:43 <ReinH> remember beta reduction? (\x -> f x) (\y -> y) = f (\y -> y)
10:18:51 <haskell628> so that's it? x has the type alpha -> alpha and y the type beta -> beta
10:18:55 <hexagoxel> alisia: annotated your lpaste. of course you'd only need one counter-example to prove that the equality does not hold
10:18:58 <ReinH> No, y does not have type beta -> beta
10:19:23 <haskell628> no I don't know what beta reduction is...
10:19:24 <alisia> hexagoxel, Thanks. Let me check.
10:19:25 <hexagoxel> but that's how i'd try to prove it
10:19:53 <ReinH> beta reduction is basically application: (\x -> 7 + x) 8 = 7 + 8
10:20:34 <ReinH> In (\x -> f x) (\y -> y), (\x -> f x) takes an argument: (\y -> y)
10:21:29 <haskell628> so y has the type alpha -> alpha?
10:22:18 <ReinH> \y -> y has type α → α
10:22:27 <ReinH> it is an id function, and since it is the first argument to f
10:22:47 <ReinH> and f is of type (a -> a) -> b -> b, it just be the id function a -> a
10:22:53 <ReinH> s/just/must
10:23:22 <haskell628> ok but what would be the type of x then?
10:23:34 <ReinH> applying (\y -> y) to f (that's (\x -> f x)(\y -> y)) yields a function of type b -> b
10:23:52 <ReinH> x is the first argument to f, so it is also a -> a
10:24:32 <haskell628> ok thanks a lot! could you look over what i've already written?
10:24:33 <ReinH> :t let f = undefined; f :: (a -> a) -> b -> b in (\x -> f x)(\y -> y)
10:24:34 <lambdabot> b -> b
10:25:05 <haskell628> http://lpaste.net/7189135573959835648
10:25:18 <ReinH> (\x -> f x) takes an argument and applies it to f. As the first argument, x must be of type a -> a. (\y -> y) constructs such a function, and (\x -> f x) (\y -> y) applies it to f
10:26:36 <haskell628> what do you think?
10:28:15 <kuznero> Hi All!
10:33:52 <kaidelong> haskell628: it applies id to another function
10:34:13 <kaidelong> oh
10:34:18 <kaidelong> ReinH already covered it
10:34:19 <kaidelong> whoops
10:34:33 <hsk5> Why can I make a String an instance of a type class without activating that extension? What was the point of this?!
10:34:41 <haskell628> yeah he did :) but do you still think it would be right to do it like i showed you in my lpaste?
10:35:34 <kaidelong> also just checking if I got that right, but you were saying you believe you know what that function does now, it's just the twice function, or?
10:37:47 <haskell628> jep it's just the twice function I think
10:37:52 <Geekingfrog> Why do I still hit "cabal: The following packages are likely to be broken by the reinstalls" on a fresh new sandbox ?
10:38:07 <haskell628> aber nochmal: es stimmt schon was ich mach in meinem lpaste oder? .D
10:38:09 <supki> hsk5: what extension?
10:38:30 <kaidelong> it looks like you were going about it the right way, yes
10:38:48 <kaidelong> but again, I don't know what your professor is thinking, here
10:38:56 <hsk5> Why can I make a String an instance of a type class without activating that extension TypeSynonymInstances? What was the point of this?
10:39:38 <haskell628> alright thank you to both of you! :)
10:39:44 <sunnymilk> can you really do that
10:40:20 <sunnymilk> it doesnt work for me hsk5 
10:40:31 <sunnymilk> > class C a where f :: a
10:40:33 <lambdabot>  <hint>:1:1: parse error on input ‘class’
10:40:48 <sunnymilk> oh i guess you cant do typeclasses with lambdabot
10:40:53 <sunnymilk> but anyway it doesnt work in ghci
10:40:57 <supki> hsk5: what extensions do you have enabled?
10:41:19 <hsk5> i mean, why CAN'T I... sorry
10:41:33 <sunnymilk> oh
10:41:37 <sunnymilk> well thats as it should be
10:41:59 <sunnymilk> making exceptions is bad because it complicates the rules
10:42:33 <supki> hsk5: because the haskell report forbids it
10:42:45 <hsk5> but why...
10:42:59 <sunnymilk> why would there be an exceptio nfor String
10:44:22 <fizbin> Anyone know much about the cryptography libraries for Hsskell?
10:45:10 <fizbin> There seem to be two different, incompatible sets of cryptographic libraries using the same package names to mean different things.
10:46:54 <fizbin> There's the family that cryptocipher and crypto-aes are part of, and then there's the family that crypto-api is part of.
10:48:29 <bennofs> fizbin: I think the new package is cryptonite
10:49:03 <bennofs> @hackage cryptonite
10:49:04 <lambdabot> http://hackage.haskell.org/package/cryptonite
10:49:18 <fizbin> Huh. Hadn't found that one.
10:49:27 <bennofs> it was recently announced
10:49:45 <bennofs> http://tab.snarc.org/posts/haskell/2015-06-02-announcing_cryptonite.html
10:49:47 <fizbin> It seems to be a all-encompassing megapackage by the guy behind the cryptocipher family.
10:50:01 <kadoban> Because when you want to do crypto "recently announced" is usually what you're looking for </sarcasm>
10:50:38 <bennofs> kadoban: yeah, I know, but the author also said that he encourages everybody to move to the new package
10:50:57 <bennofs> "I’ll try to maintain the rest of the packages for now, but don’t expect this to last for long."
10:51:16 <fizbin> What I find so odd is that I can't find any discussion where the author of the cryptocipher side even acknowledges the crypto-api side, or vice versa.
10:51:42 <bennofs> fizbin: isn't there even a "bridge" package?
10:51:48 <fizbin> I do see a reference to crypto-api compatibility wrappers in an ancient version of cryptocipher, but that's it.
10:52:01 <fizbin> bennofs: Not that I can find.
10:52:24 <bennofs> fizbin: ah, https://hackage.haskell.org/package/cryptohash-cryptoapi is for the hashes
10:54:14 * hackagebot ShellCheck 0.3.8 - Shell script analysis tool  http://hackage.haskell.org/package/ShellCheck-0.3.8 (vidarhol)
10:55:34 <bennofs> fizbin: there is also another crypto package that is not yet on hackage but in development: http://thoughtpolice.github.io/hs-nacl/
10:56:43 <Big_G> Any Haskellers in Seattle?
10:57:45 <fizbin> bennofs: That the link to the NaCl link on that page goes to an unresolvable host name fills me with whatever the opposite of confidence is.
10:59:05 <fizbin> Ah. nacl.case-project.eu should be nacl.cr.yp.to
10:59:49 <bennofs> fizbin: and to make it even more confusing, there is also salt by the same author :P http://thoughtpolice.github.io/salt/
11:00:18 <bennofs> but the last commit in salt is older than the one in hs-nacl
11:00:36 <Haskellfant> even hs-nacl hasn't seen a new commit since august last year
11:00:47 <Haskellfant> doesn't make me very confident in its future
11:03:14 <bennofs> ok, but http://hackage.haskell.org/package/saltine seems interesting
11:05:08 <Guest57918> nick narendraj9
11:20:52 <lolisa> sunnymilk, ar u a toho fan?
11:21:08 <lolisa> touhou
11:21:42 <hexagoxel> but that's how i'd try to prove it
11:22:16 <sunnymilk> lolisa yes
11:24:15 * hackagebot tubes 0.2.2.0 - Effectful, iteratee-inspired stream processing based on a  free monad.  http://hackage.haskell.org/package/tubes-0.2.2.0 (gatlin)
11:24:17 <lolisa> alisa, on 90 you say --let f be a function that, f startv = Stack (\x -> (x, startv')), whih did not addRss all casw (sorry my keyboard BROKE an som key malfunction
11:24:47 <lolisa> Oh gosh I am fan of marisa kirisam
11:25:07 <sunnymilk> she is my favorite :)
11:25:11 <sunnymilk> i always play as her
11:26:51 <lolisa> I can't play touhou stg, only pass a fw e... But same here, when I play I use marisa
11:27:00 <lolisa> have a github account?
11:27:06 <sunnymilk> i do!
11:27:14 <sunnymilk> https://github.com/yuuko
11:28:21 <augur> ahaaaa
11:28:44 <augur> i know what i discovered least night for compiling case expression patterns :p
11:29:28 <lolisa> min is lolisa, I'd fo u
11:29:31 <augur> it seems i (probably rediscovered?) tries as a pattern matching widget
11:30:51 <sunnymilk> lolisa awesome! i followed you too :D
11:31:28 <JamesJRH> Hello.
11:32:21 <JamesJRH> Anyone here from Britain or western Europe (other than me)?
11:32:55 <Hafydd> No, there's absolutely nobody from Britain or Western Europe here.
11:33:04 <kuznero> :)
11:33:12 <Hafydd> However, there are people from Northern Ireland and Eastern Europe.
11:33:20 <pingw> I'm from britain
11:33:45 <JamesJRH> Northern Ireland is part of Britain.
11:33:56 <Hafydd> No it isn't.
11:33:57 <JamesJRH> pingw: Where abouts?
11:34:06 <pingw> close to leeds
11:34:36 <JamesJRH> pingw: Do you go to the Manchester Lambda Lounge?
11:34:44 <Hafydd> Great Britain consists of Scotland, England and Wales. The "British Isles" includes Ireland, but that's not typically what is meant by "Britain."
11:35:00 <pingw> No, but it sounds interesting
11:35:08 <JamesJRH> Hafydd: Britain ≠ Great Britain.
11:35:42 <Hafydd> What do you think Britain means, then?
11:35:43 <JamesJRH> Unless you fall for Olymics marketing where the Great is just there because we're cocky.
11:36:42 <JamesJRH> Hafydd: Britain is where British people are born, and so is synonymous with UK.
11:37:35 <Hafydd> I have to disagree there. The name of the nation is the "United Kingdom of Great Britain and Northern Ireland."
11:37:36 <begriffs> Does this thing do pull requests? http://hub.darcs.net/ I forked a package and made my changes and don't know how to send them to the original author.
11:37:59 <JamesJRH> Hafydd: Britain, UK, and United Kingdom are different abbreviations of the United Kingdom of Great Britain and Northern Ireland.
11:38:03 <glguy> The finer distinctions of UK and friends are a bit off topic for #haskell
11:38:03 <JamesJRH> Hafydd: Indeed.
11:38:15 <JamesJRH> glguy: Agreed.
11:39:48 <JamesJRH> s/Olymics/Olympics/
11:40:01 <JamesJRH> pingw: How good are you at Haskell?
11:40:26 <JamesJRH> pingw: And do you use GNU+Linux?
11:42:51 <JamesJRH> pingw: I need help, but I hate nonverbal communication. The problem with Haskell is that its users are so few and far between. It's not like GNU+Linux where my nearest LUG is a 13 minute train journey away. :-/
11:45:36 <zoug> 13 minutes away when the internet is only 20 ms away? :)
11:46:42 <JamesJRH> zoug: It often takes me days to write an email that can be spoken in half an hour.
11:48:15 <JamesJRH> Which really pisses me off when it was actually too long for them to read, so then I don't get a reply at all because it gets left in an endless queue of things that'll never get done.
11:51:13 <begriffs> Is there an alternative to this package? https://hackage.haskell.org/package/regex-tdfa-text
11:52:13 <begriffs> I want to use (=~) on Text values but regex-tdfa does not support that as far as I can tell.
11:55:10 <JamesJRH> Is there a Q&A site for Haskell that is categorically _not_ part of the Stack Exchange network?
11:55:59 <JamesJRH> Bonus point if the underlying server software is libre software (e.g. AGPL) and written in Haskell. :-)
11:56:10 <JamesJRH> points*
11:56:47 <silver> https://mail.haskell.org/mailman/listinfo/haskell-cafe ?
11:57:05 <silver> https://wiki.haskell.org/Mailing_lists
11:57:13 <JamesJRH> silver: Okay, I'll join that. Thanks.
11:57:54 <Hafydd> irc://irc.freenode.net/#haskell
12:02:03 <edwardk> JamesJRH: i occasionally answer questions on quora, but that is decidedly not an open system =/
12:04:16 <rofer> Is there some trick to maintaining an export list when you export something like 30-50 things?
12:06:26 <webchat099> JamesJRH: and an extra bonus if al the software is referentially transparent
12:08:02 <S11001001> rofer: uh, add haddock sections? not sure what kind of problem you're having
12:08:53 <S11001001> rofer: the only "trick" that comes to mind is to use makeClassy instead of makeLenses
12:09:29 <dmp1ce> Does anyone have experience getting getting Dyre working in cabal executable? I want to have my custom code compiled in everytime I start the program with `cabal run`.
12:09:55 <dmp1ce> I am getting the error here: https://github.com/willdonnelly/dyre/issues/26
12:12:34 <JamesJRH> silver: Okay, I'm now subscribed to the top 3: haskell-cafe@, haskell@, and beginners@ haskell.org mailing lists.
12:13:32 <JamesJRH> silver: Come to think of it, I've heard of them before. I really should have done that already. Anyway, done now. :-D
12:14:08 <silver> :)
12:16:03 <rofer> S11001001: How do haddock sections work?
12:16:19 <rofer> I've never used haddock before, but I figure now is the right time to learn it
12:16:33 <JamesJRH> edwardk: Neither is SE. I'm fed up with SE, so any other platform can't be hard to beat. I'm fed up with SE because on several occassions I've had questions closed or deleted that I put hours of work into, not because they were bad quality, but because they weren't directly on the topic guidlines, even though they were asked on the most appropriate SE site that I could think of.
12:17:04 <JamesJRH> webchat099: Indeed. :-)
12:18:28 <S11001001> rofer: https://www.haskell.org/haddock/doc/html/ch03s04.html
12:19:09 <rofer> Thanks!
12:19:19 <S11001001> rofer: haddock uses your export list sections, described at that link, to organize its page on your module.
12:19:45 <rofer> That looks like exactly what I want
12:25:14 <quxbam> how can i retrieve a list of imported functions from a specified module?
12:27:32 <_slade_> quxbam: Programmatically or interactively?
12:27:45 <_slade_> :show imports works for the latter.
12:28:00 <quxbam> programmatically
12:28:14 <quxbam> it must be possible, haddock does it in some way
12:29:26 <quxbam> and i'm not only interested in the module names, but also in a list of functions which are provided by these modules
12:34:46 <quxbam> any ideas?
12:35:45 <_slade_> I don't know any way offhand to do it programmatically. I'm checking to see how Haddock does it.
12:36:05 <safinaskar> alpounet: thanks
12:37:18 <quxbam> _slade_: ok thanks
12:37:50 <geekosaur> haddock uses ghc-api to parse the module and pull out the import list, roughly the same way ghci's :show imports does
12:38:17 <geekosaur> I don't recall details though :(
12:41:14 <quxbam> hmm
12:41:47 <quxbam> there is a package called modulespection on hackage, which seems to do what i want
12:44:31 <merijn> aww, the summer sale is ending already? :(
12:55:14 <keithb> if the link stage of a ghc build started by cabal can't a library which seems to be in ~/.cabal/lib, what to do?
12:56:12 <geekosaur> keithb, are you building in a sandbox?
12:57:05 <keithb> I believe so
12:58:25 <geekosaur> then the sandbox replaces the user library, so nothing in it would be visible or usable; you'd need to install whatever library inside the sandbox
12:59:03 <geekosaur> (that's kind of the point of sandboxes, since having everything install into the same user library leads to too many conflicts)
12:59:37 <keithb> @geekosaur I'm following instructions given here: https://github.com/leksah/leksah/wiki/Getting-started-with-Leksah there would seem to be a major step missing
12:59:37 <lambdabot> Unknown command, try @list
12:59:51 <keithb> geekosaur I'm following instructions given here: https://github.com/leksah/leksah/wiki/Getting-started-with-Leksah there would seem to be a major step missing
12:59:56 <ion> http://begriffs.com/posts/2015-06-17-thinking-with-laziness.html is a very nice talk.
13:00:37 <geekosaur> I wouldn't think so, it should be determining that it needs to install the library itself since it can't see the user library at all
13:01:19 <geekosaur> @paste the transcript from "cabal install -v3 leksah"?
13:01:20 <lambdabot> Haskell pastebin: http://lpaste.net/
13:01:50 <shachaf> ion: Yes, you should've come.
13:02:15 <ion> shachaf: Sure, what’s the plane ticket, 1000 €? :-P
13:02:24 <keithb> geekosaur well, yes, I'd expect a package manager to find and install the required libraries (isn't that what they're for)?
13:03:02 <keithb> geekosaur that transcript is enormous (and mostly errors)
13:03:37 <geekosaur> ...therefore I should guess at the nature of those errors?
13:04:53 <keithb> geekosaur no I'm just giving you notice. Also, this is about the second time in my life that I've used #irc so I don't know what @paste means
13:05:19 <geekosaur> it was a command to the channel bot, which responded with the URL of the pastebin
13:05:36 <L8D_> how can I have multiple declarations for the same name of an accessor function?
13:05:51 <geekosaur> pasting stuff into IRC is a *very* bad idea; paste it into a web pastebin, the one I pointed to will send a notification here automatically if you select the channel in its dropdown
13:06:10 <OutlawStar> L8D_: you mean like records with same fields?
13:06:22 <L8D_> OutlawStar: Yeah. I don't actually use the accessors
13:06:34 <OutlawStar> you would have to put them in diff modules
13:06:42 <OutlawStar> and use qualified
13:06:45 <OutlawStar> when you import
13:07:01 <L8D_> Hm... I remember seeing someone use a compiler flag to get around it
13:07:15 <L8D_> I'm only using them for deriving typeable and generic
13:07:27 <L8D_> But ok
13:08:08 <OutlawStar> you could defined a class and then have instance of the different data types implement that class
13:08:24 <OutlawStar> have the instance point to the unique accessor names
13:09:25 <geekosaur> keithb, alternately you can put the transcript somewhere accessible (a pastebin, dropbox public folder, etc.) and send email to the haskell-cafe mailing list asking for help; more likely to get people who know answers (I don't think the author of leksah hangs out on IRC)
13:09:54 <danilo2> Hello! Is there any method in haskell to use currying with TypeFamilies nowadays? I want to do for example Fmap type class, that will map another type class on the elements of type level list
13:11:42 <geekosaur> keithb, http://mail.haskell.org/mailman/listinfo/haskell-cafe
13:12:08 <lpaste> keithb pasted “leksah install transcript” at http://lpaste.net/134868
13:12:11 <geekosaur> danilo2, type functions are still not suppported
13:12:39 <joco42> any idea why leksah fails to build on nixOS 14.12 ? http://pastebin.com/3cFQSsXf
13:12:41 <danilo2> geekosaur: ok, thank you. Do you know any timeline they will apear in GHC if thats in the plan?
13:14:10 <keithb> geekosaur I don't think this is a leksah problem, I think it's a some-trivial-setup-thing-that-"everyone-knows-don't-they?"-so-no-one-will-tell-you problem
13:15:19 <geekosaur> that doesn't appear to have captured the actual error output. you redirected using >, I take it?
13:15:36 <ion> I’d really like to see a video recording of http://conal.net/talks/essence-and-origins-of-frp.pdf
13:15:37 <geekosaur> (append 2>&1 to also capture error output)
13:17:48 <geekosaur> also I think there is a step missing in those instructions, now that I think about it
13:18:03 <keithb> no kidding
13:18:15 <geekosaur> you haven't reached the point where it would have failed though
13:18:32 <geekosaur> because you don't have gtk2hs installed, and because cabal uses ghc-pkg it doesn't know about executables, so you need to manually install gtk2hs-buildtools in the sandbox
13:20:27 <keithb> geekosaur Life is far, far too short for this. Thanks for your interest and help, but it turns out that there's an installer for Leksah, so I'll use that. Lessons learned: shun cabal, disbelieve instructtion
13:20:55 <OutlawStar> lol
13:21:14 <OutlawStar> welcome to haskell..
13:21:21 <simon> hi. I'm trying to understand how this example works - https://github.com/haskell-servant/servant/blob/master/servant-examples/tutorial/T2.hs - specifically, is :<|> defined as both a type operator and a regular operator, and how is it ensured that each "case" in the type matches a case in the value definition?
13:21:38 <hsk5> Why can't I make String an instance of a typeclass?
13:21:48 <hsk5> What's the thinking behind this. Why did they limit it like this
13:21:53 <simon> hsk5, give an example?
13:22:20 <mauke> hsk5: to make sure instance resolution terminates
13:22:33 <mauke> or is decideable
13:22:47 <hsk5> mauke: can you elaborate?
13:22:51 <hsk5> not sure what you mean
13:23:38 <mauke> no
13:24:04 <OutlawStar> hsk5: can u give example like simon asked?
13:24:12 <hsk5> simon, OutlawStar, https://pastee.org/udfue
13:24:21 <geekosaur> keithb, I suspect a large part of your problem is you're on OS X and Apple has gone to great lengths to make open source software painful to install
13:24:39 <OutlawStar> thats legal (when you allow orphans), but not recommended
13:24:59 <hsk5> OutlawStar: but what's going on? I don't get it at all.
13:25:05 <hsk5> What makes String more special than Int
13:25:17 <OutlawStar> that fact that string is actually [Char]
13:25:20 <OutlawStar> for one
13:25:28 <OutlawStar> String is just a type alias
13:26:26 <mauke> OutlawStar: that's not an orphan instance
13:26:35 <OutlawStar> mauke: correct, my mistake
13:27:28 <OutlawStar> hsk5: whats the exact error? There is a lang pragma that allows you to use string in type class def
13:27:42 <keithb> geekosaur i don't buy that, once you open a terminal you're looking at something very much like BSD. installing FOSS versions of something that Apple also provides is a massive pain, yes, but they don't have their own ghc, cabal etc. These are just collections of files, after all
13:28:01 <geekosaur> you've never fought with something that runs into apple's "readline"
13:28:10 <geekosaur> or for that matter iconv on either freebsd or OS X
13:28:32 <OutlawStar> hsk5: use pragma FlexibleInstances
13:28:46 <hsk5> yes, i can add those pragmas
13:28:53 <geekosaur> you may not "buy" it but there's a reason people use macports or homebrew to install stuff; both of those know how to work around Apple-isms
13:28:54 <hsk5> I still just don't "get it".
13:29:01 <OutlawStar> oh
13:29:05 <hsk5> what's the big deal
13:29:11 <hsk5> what's the thinking behidn this
13:29:16 <OutlawStar> hsk5: http://stackoverflow.com/questions/5941701/why-can-i-not-make-string-an-instance-of-a-typeclass
13:29:32 <hsk5> thanks!
13:29:34 <keithb> that's right, I haven't. But this problem I have here isn't about those, it's about cabal not finding libraries which the Haskell platform *has* installed on this machine
13:29:42 <rhaps0dy> Hey, that's not a compiler error. Any clue what might cause "/tmp/pkgConf-tf-random-07108.5: hGetContents: invalid argument (invalid byte sequence)" when installing tf-random ?
13:29:47 <geekosaur> not if they're under ~/.cabal it hasn't
13:30:09 <geekosaur> HP installs in the global package database, which is visible
13:30:17 <geekosaur> unless you have an extra ghc somewhere
13:30:42 <geekosaur> which, come to think of it... it's running /usr/local/bin/ghc but the HP installer installs in /usr/bin
13:31:04 <geekosaur> and they wouldn't be using the same package databases
13:31:05 <hsk5> Ah, sexy
13:31:08 <hsk5> Now I get it!
13:31:16 <OutlawStar> :)
13:31:17 <keithb> so this is a cabal vs haskell platform problem, and a poor instructions from leksah problem, Apple are not implciated
13:38:04 <webchat099> some guy has managed to move haskell processes between internet nodes
13:44:27 <L8D_> What's a good name for "interactions with the database" other than "queries" ?
13:45:00 <OutlawStar> what do mean by interactions?
13:45:25 <OutlawStar> write and read ops
13:45:28 <L8D> I have modules where I put all my SQL queries
13:45:28 <OutlawStar> ?
13:45:40 <L8D> and I don't want to name the folder 'Queries'
13:45:43 <L8D> because Queries is weird
13:45:50 <OutlawStar> requests?
13:46:03 <L8D> It's in a REST API system
13:46:18 <L8D> I have 'Types', 'Resources' and 'Queries'
13:46:38 <L8D> I want to find a better name than 'Queries'
13:47:01 <OutlawStar> search?
13:47:44 <OutlawStar> search and requests is the best i've got :)
13:47:51 <L8D> well thank you
13:48:01 <L8D> although I guess I'll stick to Queries
13:48:08 <OutlawStar> probably best
13:51:59 <magneticDuck> OutlawStar: accessors
13:52:16 <L8D> magneticDuck: o.O
13:52:23 <L8D> magneticDuck: that's pretty good
13:52:34 <OutlawStar> lol
13:52:40 <OutlawStar> better late than never i guess
13:52:53 <magneticDuck> I also use the terms "constructors", "combinators",  and "accessors" when organising my own code
13:53:21 <magneticDuck> those of course aren't homological to your own three terms =P
13:54:40 <magneticDuck> other bits of haskell jargon like "lifts" and typeclass instances fill in all the rest
13:54:56 <albeit> I want to find any packages that use GHC.Event... is there a way to search Hackage for packages that "import GHC.Event"? I tried their search and it was a bunch of false positives...
13:56:24 <buc> I am a total haskell newbie, so please bear with me.
13:56:36 <buc> is debugging in haskell difficult? or whats your exp?
13:58:17 <buc> do you find debugging in haskell more difficult than in imperative langs?
13:58:24 <Haskellfant> buc: my experience is that I have to debug very rarely because the type system helps me catch errors upfront but when I need to debug I mostly do print statement debugging
13:58:33 <jxv> buc, depends on the 'class' of bugs
13:59:05 <jxv> Design bugs generally are easier to refactor compared to imperative langs
13:59:56 <jxv> damn
13:59:58 <buc> I often hear that if your program compiles, then it will be probably OK
14:00:25 <jxv> buc, yeah if your design is right. 
14:00:31 <buc> this sounds too good to be true
14:00:34 <buc> what is the reality?
14:00:44 <jxv> buc, it's an improvement.
14:00:58 <jxv> buc, the reality is you stare at your screening trying to think of a design before typing it.
14:01:17 <jxv> and play w/ the repl
14:01:58 <OutlawStar> buc: i find that most bugs i would use a debugger for in imp langs I don't have in haskell because of type system
14:02:14 <OutlawStar> other than that, like jxv, i use print lines
14:02:50 <buc> do you have exp using promises/futures in other langs? c++, python, javascript? . I have come to grasp promises pretty well in the last few months, not a pro, but I feel I can use them to get my job done. Now, I find the idea of promises/futures very similar to monads in haskell, like IO, or anything really. Am I wrong? 
14:02:52 <L8D> buc: you also end up organising things into seperate stuff
14:02:56 <jxv> I hope freenode is upgrading servers or the like
14:03:04 <L8D> buc: so you incrementally work by writing types and psuedo-signatures
14:03:10 <L8D> buc: and working until that stuff compiles
14:03:18 <L8D> buc: and then you move on to the actual implementations behind it
14:03:23 <buc> L8D I see
14:04:14 <jxv> buc, there's async
14:04:19 <jxv> https://hackage.haskell.org/package/async-2.0.2/docs/Control-Concurrent-Async.html
14:04:29 <buc> do you still think `imperatively` and model your main expression as you go, or are you able to construct your expressions from the get go
14:04:46 <zed_> hello everyone : ) what is the best way to draw from the normal distribution pdf and to obtain the normal distribution cdf in haskell ?
14:04:49 <jxv> buc, haskell warped my brain to think in haskell even in imperative code
14:05:13 <OutlawStar> is a very good warp though :)
14:05:18 <jxv> yeah
14:05:58 <jxv> it's more like two mental models in imperative: conceptual (which is closer to haskell) and the imperative control-flow
14:06:43 <buc> is haskell async by default?
14:06:55 <OutlawStar> no
14:07:00 <comerijn> buc: What does that mean?
14:07:12 <buc> right
14:07:14 <comerijn> Language can't be asynchronous, so the question is unanswerable
14:07:25 <buc> Sorry. Are IO operations in haskell async by default?
14:07:39 <comerijn> buc: No, but you don't want that anyway
14:07:56 <comerijn> async IO is a hack workaround for languages that don't have proper concurrency
14:08:07 <simon> comerijn, sure, if the language's formal semantics include the notion of synchronicity?
14:08:10 <L8D> buc: the 'async' package isn't really async in the way that JavaScript is async
14:08:11 <jxv> buc, that async is library.
14:08:17 <buc> In the JS community, we want to read/write asynchrounously so that we dont block the main thread
14:08:33 <OutlawStar> haskell offers that, but its not default
14:08:36 <L8D> buc: the 'async' package in Haskell is really just a library for handling concurrency in a cleaner way
14:08:37 <jxv> buc, much of the haskell common data types and functions aren't built-into the language
14:08:37 <merijn> buc: That's because JS is a crappy language
14:08:43 <buc> how is this solved in haskell if we dont want to read / write async in haskell?
14:08:44 <Haskellfant> just spawn a new thread
14:08:50 <merijn> buc: Just write synchronous code using threads
14:08:54 <L8D> guys don't be like this
14:09:03 <buc> hey merijin!
14:09:08 <merijn> buc: GHC has lightweight threading, so you can have >100k threads on a single machine
14:09:21 <OutlawStar> yes, listen to merign
14:09:24 <OutlawStar> merijn*
14:09:27 <merijn> buc: The runtime implementation uses kqueue/epoll to schedule/unschedule blocked threads
14:09:28 <L8D> buc: Node.js gets high performance because it moves many IO-heavy operations like read/writing from networks or the file system into seperate threads
14:10:11 <L8D> buc: JavaScript alone isn't very good at handling multi-threaded programming, so (just like in the browser) Node.js uses an event loop to tie the external IO threads together
14:10:23 <L8D> buc: this is why you use callbacks, and why everything is 'asynchronous' in the JavaScript world
14:10:41 <merijn> L8D: It's not "not very good at", node.js is completely single-threaded
14:10:53 <buc> L8D right, so in haskell you actually use real threads
14:11:02 <buc> do they work like go-co routines?
14:11:09 <L8D> merijn: yes, because modeling concurrency (with workers) is not very good
14:11:16 <jxv> buc, greenthreads
14:11:20 <merijn> buc: GHC threads are cheaper than goroutines, but other than that, yes
14:11:26 <Enigmagic> buc: a thread in haskell isn't tied to an OS thread
14:11:37 <L8D> buc: in Haskell, as well as most traditional languages, there isn't a push to make things concurrent
14:11:40 <icicled> are there any writings about acid-state that talk about when it would be a good idea to use & when not to?
14:11:56 <L8D> buc: when writing code day-to-day you aren't going to be dealing with threads
14:12:19 <merijn> icicled: Anything specific you're thinking off?
14:12:26 <benzrf> guys
14:12:33 <benzrf> shitting on js is entirely unnecessary
14:12:37 <L8D> buc: in the context of writing web applications (the main use case of Node), you simply just delegate a thread for each request
14:12:42 <safinaskar> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/Control-Category.html give the following instance: "Category * (->)", but the actual source gives "Category (->)". so, this is a doc bug, right?
14:12:48 <L8D> buc: assuming that your database layer works correctly with concurrent connections
14:13:19 <icicled> merijn, I was wondering what a good use case might be for it
14:13:19 <magneticDuck> benzrf: well it's kind of fun
14:13:25 <magneticDuck> come on, pretty please?
14:13:26 <buc> L8D how do I know if my db works well with concurrent conns? u got me on that one
14:13:28 <icicled> it appears to be in-memory but backed by disk?
14:13:44 <benzrf> magneticDuck: no, it's assholish
14:13:50 <magneticDuck> :<
14:13:53 <L8D> buc: don't worry about that for now. I can't think of a library that doesn't work properly with concurrent connections
14:14:10 <buc> phew
14:14:10 <webchat099> but essentially the model is the same request handlers are basically the same idea than event handlers.
14:14:18 <merijn> icicled: I dislike that a lot of people treat acid-state as a database. I would personally describe it as "persistent heap objects with ACID guarantees"
14:14:32 <L8D> buc: Libraries like Hasql, Persistent, Esqueletto and SQLSimple should all work fine
14:14:43 <merijn> icicled: Which means you can use it as a simplistic database, but for large datasets I would personally not use it
14:14:46 <L8D> buc: the threading part of everything is handled by your web framework anyways
14:14:47 <buc> hasql, very clever
14:15:21 <icicled> merijn, ok thanks, I guess that clears up that question
14:15:51 <buc> I heard cabal is difficult to work with bc is does not do proper package management
14:15:54 <icicled> merijn, it would be nice however to find some writing somewhere by either the project or others that talk about where it would be a good fit
14:16:15 <merijn> icicled: And yes, it's backed by disk, because the D in ACID stands for Durability (i.e., will survive software crash), which you can't do just in memory :)
14:16:15 <buc> just rumours?
14:16:17 <L8D> buc: it does proper package management, the main issue is when you have package conflicts
14:16:42 <L8D> buc: it's the same problem you'll encounter with Ruby or Python's package manager
14:16:57 <buc> silly question, but why are parts of ghc written in C--?
14:17:03 <buc> why is not all written in haskell?
14:17:26 <merijn> Because no one can be arsed to rewrite the runtime in pure haskell for no reason
14:17:34 <L8D> buc: Python's virtualenv, Ruby's bundler, Cabal's sandbox mode, etc. all install/manage packages on a per-project basis, eliminating most of the problems
14:17:38 <merijn> and/or parts of GHC
14:18:04 <webchat099> It is written in C-- but no variable has been harmed with updates
14:18:04 <buc> merijin do you mean badass??
14:18:08 <merijn> There's no theoretical problem with implementing all of GHC and the RTS in haskell + primops, but there's no practical reason to invest the effort
14:18:21 <buc> ok I see
14:18:24 <L8D> buc: cabal isn't a completely straightforward or intuitive package system, unlike node's npm
14:18:55 <L8D> buc: there is definitely a learning curve
14:19:18 <jxv> buc, cabal was a package-builder turned into a pkg-manager
14:19:58 <buc> in terms of editors, the js community is very well distributed, but I think most people use either sublime or atom, followed by vim (I cant say about people using other more enterprisey ides)
14:20:11 <buc> what about haskell?
14:20:18 <buc> anyone using haskell with atom?
14:20:24 <jxv> buc, vim and emacs are the majority
14:20:34 <jxv> yes, some people use atom
14:21:03 <buc> how come there isnt a more civilized editor for haskell
14:21:03 <webchat099> you can also try leksah it is an IDE written in Haskell for Haskell
14:21:09 <buc> nice
14:21:19 <buc> I dislike viml very much
14:22:26 <buc> do you use the webchat.freenode.net or is there a better tool to chat here?
14:22:41 <jxv> buc, I don't think leskah will be helpful if you're learning haskell
14:22:51 <Pastaf> I actually like emacs, leksah is just a bit messy and everything else is too minimal.
14:23:13 <L8D> buc: I use irrsi. I believe most of the people here use an irc client for emacs
14:23:35 <jxv> there's also hexchat for the gui inclined
14:23:37 <Pastaf> I'm currently on HexChat. 
14:23:53 <L8D> buc: I believe the majority of proficient Haskell developers use Emacs (although I still vim)
14:24:10 <buc> any good one for mac?
14:24:12 <safinaskar> buc: text editor is not important in haskell. i use kate (kde's editor)
14:24:13 <L8D> buc: Emacs with ghc-mod (an emacs plugin) provides a very interative editing experience
14:24:18 <OutlawStar> emacs does have better support, but i use vim too ;)
14:24:31 <saep> buc: I second that using an IDE for haskell may not be very helpful/convenient (at least in the beginning). You can get along really well with some syntax highlighting, a browser and a terminal with ghci. Additional tools are only needed once you start developing real procjects. Even then, you can get along with those tools just fine.
14:24:47 <webchat099> the true men don´t use IDE's
14:24:50 <buc> I was planning to use atom, my fav editor
14:24:57 <L8D> saep: you're forgetting about the F# people using visual studio
14:25:02 <OutlawStar> i find that the error logs generated by compiler are too big for IDE, so i just pair with console
14:25:10 <buc> any good irc clients for mac?
14:25:12 <L8D> buc: you should have no issue using atom with Haskell
14:25:35 <buc> L8D good to know
14:25:49 <L8D> buc: CIRC is an IRC client in a Chrome extension
14:26:10 <L8D> buc: clients like irssi and weechat are terminal-based
14:26:15 <buc> everyone is so helpful here, I almost feel you are real humans (compare that to other communities, python ehem)
14:26:18 <webchat099> You can use better the FPcomplete IDE it is online and web based
14:27:01 <jxv> fpcomplete's ide is easiest to use, imo. Too bad it's for online usage only.
14:27:41 <silver> there's also sublime text
14:27:49 <buc> learn you haskell for good seems like a great place to start learning haskell
14:27:55 <buc> there is also real world haskell
14:28:04 <webchat099> for the the bad thing is that it does not work with android browsers
14:28:05 <buc> do you guys and gals recommend to go with those?
14:28:10 <L8D> buc: if you are coming from a JavaScript/Python background then it can be a very helpful resource
14:28:14 <saep> buc: https://github.com/bitemyapp/learnhaskell
14:28:22 <jxv> buc, https://github.com/bitemyapp/learnhaskell
14:28:23 <buc> I come from a JS background yes
14:28:25 <L8D> buc: although several people here might tell you otherwise
14:28:37 <OutlawStar> i read about the first third of learn you some and then switched to real world
14:28:42 <buc> thanks!
14:29:01 <silver> RWH is outdated but useful if read carefully
14:29:07 <L8D> buc: that LYAH (Learn You A Haskell) teaches you to translate from OOP/Imperative thinking into Functional thinking
14:29:33 <L8D> buc: instead of providing the grounds to begin to intuitively grasp functional thinking
14:29:50 <phaazon_> LYAH is one of the best book I’ve read in my life when coming to learning something new
14:29:52 <buc> I see L8D
14:29:58 <buc> for that I should better look elsewhere?
14:30:04 <buc> like the github link you folks pasted?
14:30:29 <L8D> buc: it depends
14:30:52 <buc> that repo looks pretty complete, i really want to watch those lectures now
14:31:10 <buc> I have goconf today in Tokyo, but maybe I should stay home watching these :DDD
14:31:32 <buc> how is the haskel ~ go community?
14:31:50 <buc> u folks like each other?
14:32:10 <simon> with aeson, why can't I have 'instance ToJSON (Map Foo Int)'? it complains wrt. FlexibleInstances.
14:32:35 <jxv> never interacted w/ the go community
14:32:47 <L8D> buc: Haskell has a very different mindset/goal than the Go community
14:32:59 <Eduard_Munteanu> simon, you can enable FlexibleInstances, but mind there's already an instance for that
14:33:26 <webchat099> Haskell is a meta-language
14:33:31 <Eduard_Munteanu> Er, if you also have ToJSON Foo
14:33:34 <buc> yes?
14:33:48 <L8D> buc: Haskell focuses on allowing people to write large systems with long-term maintainability
14:33:50 <buc> L8D what would they be? in simple terms
14:34:03 <L8D> :s/focuses on/is interested in
14:34:34 <L8D> buc: Go focuses on removing the clutter involved in working on projects, with other developers, with other codebases and allowing people to be productive
14:34:41 <Eduard_Munteanu> simon, I misread. Just enable FlexibleInstances.
14:34:46 <buc> weird question: what is a good language pair for haskell?
14:35:00 <L8D> buc: it sounds odd, but I would say Python
14:35:06 <jxv> c, so you can write bindings.
14:35:09 <webchat099> I think that there are two very different communities in haskell
14:35:14 <buc> really? .... 
14:35:32 <buc> what about Javascript?
14:35:43 <saep> I wonder what "a good language pair" actually means? 
14:35:46 <Eduard_Munteanu> If you're building web apps, then yeah.
14:35:49 <jxv> buc, if you do web stuff.
14:35:53 <jxv> there's also purescript
14:35:55 <webchat099> the academic comunity and the IT comunity. In the middle are the creators and maintainers of the Haskell Platform
14:36:02 <buc> yeah yeah
14:36:03 <L8D> buc: Python as a language and a community prioritizes understandability, clean code, code correctness and safety
14:36:24 <L8D> buc: many similar mindsets
14:36:28 <benzrf> arguable
14:36:53 * Eduard_Munteanu bursts into laughter a bit... "code correctness and safety". :)
14:36:55 <buc> would you think I am crazy if I thought C was a good pair?
14:36:59 <L8D> buc: however Python doesn't have a type system, doesn't focus on functional elements and is really there as a scripting/get-something-done-fast thing
14:37:01 <buc> not c++
14:37:40 <L8D> Eduard_Munteanu: maybe not "correctness" but definitely safety
14:37:40 <buc> L8D: exactly, for which case I'd rather go with js/node instead of python, but you know better
14:38:01 <L8D> buc: if you're already familiar with node, then use node
14:38:10 <benzrf> buc: js only has one of those things over python
14:38:15 <benzrf> buc: and even then it's pretty bad at it
14:38:22 <jxv> buc, purescript uses node
14:38:44 <L8D> buc: you shouldn't compromise your productivity or workflow because someone on IRC mentioned one is better than another
14:38:58 <Eduard_Munteanu> L8D, I mean it's a bit odd given their type system
14:39:23 * hackagebot apache-md5 0.6.1.2 - Apache specific MD5 digest algorighm.  http://hackage.haskell.org/package/apache-md5-0.6.1.2 (PeterTrsko)
14:39:38 <buc> but u are right, maybe I should give python a second chance, Ive learned it like 5 times in the last 10 years, but I still dont like it 
14:40:23 <buc> any thoughts about rust from a haskell POV?
14:40:28 <L8D> buc: I find many of the talks by Raymond Hettinger demonstrate the power behind Python
14:40:33 <jxv> I like rust
14:40:36 <L8D> buc: for example, https://youtu.be/wf-BqAjZb8M
14:40:54 <jxv> Wish it had hkt
14:41:35 <L8D> buc: however, Python's community is slowing growing more and more distraught by the year
14:41:47 * Eduard_Munteanu would rather point at Java
14:42:22 <L8D> buc: with the Python 2 vs 3 split and the lack of vibrancy
14:42:27 <buc> distraught of what? 
14:42:27 <benzrf> jxv: hkt?
14:42:31 <buc> oh
14:42:33 <buc> gotcha
14:43:04 <jxv> higher-kinded-types
14:43:08 <L8D> it's just losing traction
14:43:23 <buc> sorry to bother, but just so that i kind quickly move away from this browser window
14:43:33 <buc> how do i log on to #haskell from irssi?
14:43:45 <unknownloner> can Parsec work on arrays of any type or is it restricted to just text?
14:43:51 <buc> I promise ill read the manual later
14:44:09 <Eduard_Munteanu> unknownloner, it can use any token type
14:44:19 <L8D> buc: see https://wiki.archlinux.org/index.php/Irssi
14:44:27 <L8D> buc: and http://askubuntu.com/questions/61549/how-do-i-configure-irssi
14:44:34 <unknownloner> alright, thanks
14:44:38 <L8D> buc: the first link has documentation on individual commands
14:44:52 <L8D> buc: the second is an example configuration file to get you started
14:48:03 <bucaran> LD8: thanks! this is buc
14:51:08 <bucaran> can anyone say hi to check if I setup irssi correctly?
14:51:18 <notOnIRC> bucaran: hi
14:51:23 <bucaran> thanks
14:52:10 <notOnIRC> np
14:52:25 <bucaran> any haskellian fishshell users here?
14:52:52 <benzrf> 'fish shell'
14:53:16 <benzrf> is that what atm machines run on
14:53:28 <bucaran> very funny
14:53:44 <bucaran> I mean of course, fish, the friendly shell
14:53:52 <bucaran> friendly interactive shell*
14:56:44 <sugarwife> is there a way to search for usage of a function across all packages in hackage?
14:56:58 <arw> hoogle?
14:57:12 <bucaran> L8D: so were you saying (as general advice) to start w/ https://github.com/bitemyapp/learnhaskell first?
14:57:14 <webchat099> good idea
14:57:34 <arw> sugarwife: but I'm not sure if all interesting packages are indexed
14:58:20 <Haskellfant> sugarwife: I used the github search as an approximation for stuff like that
14:58:31 <webchat099> unfortunately the source code is not indexed in Hayoo neither Hoogle
14:58:46 <sugarwife> arw: hoogle lets you search for a function by type signature, but it doesn't let you find what packages use that function, does it?
14:58:50 <jxv> sugarwife, if you have hoogle installed on your machine. You can use a clever ghci binding to search
14:59:23 <sugarwife> Haskellfant: yes, that's what I've been using but wondering if there's anything better
14:59:27 <jxv> wait, I take that back
15:00:12 <webchat099> I use google for that
15:00:46 <jxv> And without internet access: untar all your locally downloaded packages, and grep -r "function"
15:00:49 <realloc1> hm.. is somebody here active at the haskell wiki? I discovered a bug in this example program https://wiki.haskell.org/Roll_your_own_IRC_bot
15:01:16 <arw> sugarwife: i see package names here: https://www.haskell.org/hoogle/?hoogle=a+-%3e+Int&start=21#more
15:01:24 <realloc1> its parser fails at parsing messages from users who use IPv6
15:01:55 <sugarwife> arw: but those are the packages that _define_ the function, right?
15:02:11 <sugarwife> arw: I want to see all packages that import and use the function
15:02:17 <arw> sugarwife: ah, sorry. i've missed that.
15:02:37 <arw> sugarwife: in that case, no idea
15:03:21 <bucaran> *test*テスト
15:04:55 <arw> bucaran: three dashed boxes. too obscure for my console font.
15:05:59 <unknownloner> looks fine on my end bucaran 
15:06:00 <bucaran> hmpf
15:06:14 <bucaran> @arw do you have the powerline patched fonts?
15:06:14 <lambdabot> Aye Aye Cap'n
15:06:29 <webchat099> what is the most magic piece of Haskell that you have seen?
15:06:29 <unknownloner> Terminus font has a surprising amount of unicode support
15:06:38 <bucaran> those were japanese hiragana characters, i guess u dont have em installed
15:07:45 <webchat099> the fib example don't count
15:07:48 <bucaran> it would be cool if we could type haskell here, as if this was also a haskell repl integrated to ur irc client
15:08:09 <barrucadu> > "bucharan: " ++ "like this?"
15:08:10 <lambdabot>  "bucharan: like this?"
15:08:28 <barrucadu> lambdabot does (amongst other things) Haskell expression evaluation
15:08:43 <unknownloner> > sum [0..9]
15:08:45 <lambdabot>  45
15:09:15 <benzrf> > fix id
15:09:19 <lambdabot>  mueval-core: Time limit exceeded
15:09:30 <c_wraith> must be broken.  let's try..
15:09:32 <c_wraith> > fix error
15:09:34 <arw> bucaran: no. currently the usual unicode variant of courier.
15:09:34 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
15:09:42 <benzrf> :3
15:10:37 <magneticDuck> that's cute
15:10:49 <unknownloner> you can also PM lambdabot directly
15:10:56 <benzrf> :t fix error
15:10:57 <lambdabot> [Char]
15:10:59 <benzrf> oh, right
15:11:19 <unknownloner> :t fix
15:11:20 <lambdabot> (a -> a) -> a
15:11:25 <unknownloner> what does fix do exactly?
15:11:31 <benzrf> fix f = f (fix f(
15:11:33 <benzrf> er
15:11:34 <bucaran> can anyone print hello, world ?
15:11:35 <benzrf> fix f = f (fix f)
15:11:51 <Iceland_jack> > text "hello, world"
15:11:52 <lambdabot>  hello, world
15:11:57 <magneticDuck> > putStrLn "hello world"
15:11:59 <lambdabot>  <IO ()>
15:12:07 <bucaran> putStrLn "hi"
15:12:16 <unknownloner> you forgot the >
15:12:20 <benzrf> > implying
15:12:21 <lambdabot>  Not in scope: ‘implying’
15:12:23 <bucaran> > putStrLn "hi"
15:12:24 <lambdabot>  <IO ()>
15:12:34 <magneticDuck> io is disabled
15:12:40 <benzrf> it's not disabled
15:12:41 <magneticDuck> > launchMissles
15:12:42 <bucaran> always?
15:12:43 <lambdabot>  Not in scope: ‘launchMissles’
15:12:52 <benzrf> it's special-cased in ghci
15:12:54 <benzrf> here, it isnt
15:13:10 <bucaran> > open iTunes
15:13:11 <lambdabot>  Not in scope: ‘open’    Not in scope: ‘iTunes’
15:13:11 <lambdabot>      Perhaps you meant ‘iuses’ (imported from Control.Lens)
15:13:13 <bucaran> just kidding
15:13:18 <benzrf> hmm
15:13:19 <benzrf> :t iuses
15:13:20 <lambdabot> MonadState s m => IndexedGetting i r s a -> (i -> a -> r) -> m r
15:13:21 <sugarwife> How can I get a list of all top-level functions defined in a package?
15:13:23 <benzrf> cripes
15:13:35 <benzrf> sugarwife: check th hackage
15:13:46 <benzrf> oh , wait
15:13:52 <benzrf> you mean from every module?
15:14:00 <sugarwife> yeah
15:14:09 <webchat099> some limited IO would be nice in lambdabot
15:14:15 <magneticDuck> webchat099: why?
15:14:18 <benzrf> webchat099: how so
15:14:22 <magneticDuck> if you want that make your own bot
15:14:33 <magneticDuck> and get rekt by people exploiting it =P
15:16:23 <webchat099> magneticDuck:  for example write small files in a sandbox and do small programs with them
15:16:29 <sugarwife> actually, how can I get a list of all functions _used_ in a package?
15:17:07 <webchat099> user input too
15:17:23 <benzrf> webchat099: what would be the utility of that
15:17:35 <magneticDuck> to write text adventure games of course benzrf 
15:17:44 <benzrf> wonderful
15:18:26 <webchat099> benzrf:  to play with something more than lists
15:18:36 <benzrf> webchat099: play with lenses
15:18:38 <benzrf> start a fire
15:19:03 <magneticDuck> webchat099: you do realise.. there are like
15:19:11 <magneticDuck> ways of running haskell code outside of lambdabot =P
15:19:19 <hodapp> magneticDuck: WHAT?!
15:19:24 <hodapp> this changes everything!
15:19:24 * benzrf faints in shock
15:19:41 <magneticDuck> > fix ("no seriously ":)
15:19:43 <lambdabot>  ["no seriously ","no seriously ","no seriously ","no seriously ","no serious...
15:20:29 <benzrf> > fix$scanl(+)0.(1:)
15:20:30 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
15:20:33 <hodapp> > join $ fix ("o rly? ":)
15:20:35 <lambdabot>  "o rly? o rly? o rly? o rly? o rly? o rly? o rly? o rly? o rly? o rly? o rly...
15:22:00 <benzrf> the list: truly a great contrail structure
15:22:35 <magneticDuck> > concat $ zipWith (liftA2 (:[]) ++)) [1..9] (reverse [1..9])
15:22:37 <lambdabot>  <hint>:1:35: parse error on input ‘)’
15:22:48 <magneticDuck> > concat $ zipWith (liftA2 (:[]) ++) [1..9] (reverse [1..9])
15:22:50 <lambdabot>      Couldn't match expected type ‘[a0]’
15:22:50 <lambdabot>                  with actual type ‘f0 a1 -> f0 b0 -> f0 c0’
15:22:50 <lambdabot>      Probable cause: ‘liftA2’ is applied to too few arguments
15:22:52 <benzrf> lol
15:22:58 <magneticDuck> wow fk me
15:23:04 <magneticDuck> > concat $ zipWith (liftA2 (:[]) (++)) [1..9] (reverse [1..9])
15:23:05 <lambdabot>      Couldn't match type ‘[[a0] -> [a0]]’ with ‘b0 -> [a]’
15:23:05 <lambdabot>      Expected type: ([a0] -> [a0]) -> b0 -> [a]
15:23:05 <lambdabot>        Actual type: ([a0] -> [a0]) -> [[a0] -> [a0]]
15:23:16 <magneticDuck> too late for haskell
15:23:36 <benzrf> @remember zip
15:23:36 <lambdabot> Incorrect arguments to quote
15:23:42 <benzrf> @quote zip
15:23:42 <lambdabot> edwardk says: zip. iterate . take .  intersect . find nub . lookup . tail . intercalate . transpose. reverse . unzip
15:23:45 <benzrf> hmm
15:24:02 <benzrf> :t zip. iterate . take .  intersect . find nub . lookup . tail . intercalate . transpose. reverse . unzip
15:24:03 <lambdabot>     Couldn't match type ‘[a0] -> [[a0]]’ with ‘[a]’
15:24:03 <lambdabot>     Expected type: ([a0] -> [a0]) -> [a]
15:24:03 <lambdabot>       Actual type: ([a0] -> [a0]) -> [a0] -> [[a0]]
15:24:06 <benzrf> aw
15:24:15 <benzrf> @quote zip
15:24:15 <lambdabot> mreh says: right, I understand list monad now, now I need to "takeWhile the sum of the list is less than x", I think like kinky sex games, some zips are in order
15:24:24 * hackagebot endo 0.2.0.1 - Endomorphism utilities.  http://hackage.haskell.org/package/endo-0.2.0.1 (PeterTrsko)
15:24:27 <benzrf> @quote zip`ap`
15:24:27 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
15:24:52 <magneticDuck>  @quote @quote
15:24:57 <magneticDuck> @quote @quote
15:24:57 <lambdabot>  @quote says: quanticle
15:25:04 <magneticDuck> @quote @quote
15:25:04 <lambdabot>  @quote says: quanticle
15:25:09 <magneticDuck> .. okay
15:25:19 <benzrf> @quote benzrf 
15:25:19 <lambdabot> benzrf says: wow. haskell's conception predates mine by like 10 yrs
15:25:26 <magneticDuck> @quote magneticduck
15:25:26 <lambdabot> No quotes match.
15:25:32 <magneticDuck> yeah well
15:25:42 <magneticDuck> I'm sure I said something nice once
15:31:24 <unknownloner> @quote magneticDuck
15:31:24 <lambdabot> No quotes match. Whoa.
15:31:30 <unknownloner> Whoa.
15:31:52 <unknownloner> :t ap
15:31:53 <lambdabot> Monad m => m (a -> b) -> m a -> m b
15:32:48 <benzrf> @quote nonexistent
15:32:48 <lambdabot> No quotes match. My mind is going. I can feel it.
15:34:36 <kqr> man. I just discovered how fun it can be to read C-- and attempt to make sense of it. I still have no idea what 95% of this stuff does but the more I'm looking at it the more I'm figuring out about how it works. I could be up all night...
15:36:06 <alpounet> simon: still around?
15:36:19 <marchelzo_> kqr: How can you see the C-- emitted by ghc?
15:36:50 <quchen> -ddump-cmm?
15:37:25 <kqr> marchelzo_, -ddump-cmm, as quchen said
15:37:27 <quchen> See https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flag-reference.html
15:37:46 <kqr> marchelzo_, though beware that it prints quite a lot of code (2000 lines for a 4 line function)
15:37:55 <marchelzo_> oh wow
15:38:02 <kqr> marchelzo_, but that's because it prints the cmm after each transformation
15:38:18 <kqr> marchelzo_, so you'll see the first cmm it does, then after 1 pass of optimisations, then after 2 passes, then after transforming it to CPS and so on
15:38:41 <kqr> marchelzo_, the actual C-- code is around 170 lines for the 4 line function I have – this is comparable to the 200ish lines of assembly which gets generated as the final step
15:39:13 <marchelzo_> I see
15:40:05 <kqr> but start with core (-ddump-simpl) if you've never looked at any of the intermediaries before, then STG (-ddump-stg)
15:40:25 <kqr> since the symbol names get mangled more and more the lower down you go
15:40:48 <marchelzo_> Yeah it's pretty unrecognizable :)
15:41:37 <marchelzo_> -ddump-simpl gives me no output
15:42:14 <marchelzo_> nevermind, i didn't delete the .hi file first
15:42:22 <kqr> -fforce-recomp
15:47:05 <merijn> kqr: have you read the STG paper?
15:47:28 <kqr> no
15:47:33 <kqr> is it good?
15:47:40 <kqr> I know basically nothing about how GHC works lol
15:48:07 <merijn> Yes, it covers the STG language + STG machine model and explains how to compile those to C--/C
15:48:36 <merijn> It's a bit outdated in that GHC uses different translations now, but it's a decent starting point to understand how you can generate machine code for haskell
15:48:40 <kqr> I just have a modest understanding of compilers, laziness and low-level code and try to figure out C-- now for fun
15:48:46 <kqr> ah
15:48:50 <merijn> STG being even more minimal than Core
15:48:53 <merijn> This one: http://research.microsoft.com/apps/pubs/default.aspx?id=67083
15:49:09 <kqr> yeah, I understand roughly how the intermediaries GHC uses relate to each other
15:51:37 <kqr> merijn, do you know if there's a pdf of that one?
15:51:50 <kqr> the computer I have hooked up to the printer doesn't seem to like postscript
15:52:27 <Eduard_Munteanu> @google filetype:pdf stackless tagless g-machine
15:52:29 <lambdabot> http://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
15:52:29 <lambdabot> Title: Implementing lazy functional languages on stock hardware: the Spineless Tagle...
15:52:35 <Eduard_Munteanu> Er.
15:52:38 <Eduard_Munteanu> Spineless.
15:53:01 <merijn> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.44.1478&rep=rep1&type=pdf
15:53:11 <merijn> Google Scholar :p
15:53:21 <kqr> all the links
15:53:22 <kqr> thanks
15:56:13 <ka3a4ok> hi all
15:56:42 <kqr> hi
15:56:47 <ka3a4ok> Did anybody build zeromq-haskell on windows?
16:08:42 <cj3kim> hi haskell people
16:09:12 <cj3kim> i want to confirm an NP concept I learned today. anyone want to confirm?
16:11:16 <pavonia> cj3kim: It's probably hard to tell for someone if they can confirm your concept if they don't know what it is about
16:11:30 <cj3kim> pavonia: that's true. :)
16:11:42 <pavonia> I'm tempted to say NP-hard ;)
16:12:16 <cj3kim> so, Np problems are a class of problems that can be solved in polynomial time with a quantum computer aka a nondeterministic turing machine
16:12:37 <c_wraith> quantum is not the same as nondeterministic
16:12:38 <c_wraith> quantum is a more limited class
16:13:23 <cj3kim> c_wraith: i see
16:13:35 <c_wraith> it's more useful to think of NP as the class of problems where there's a polynomial-time procedure to determine if a suggested answer is correct.
16:14:09 <c_wraith> Nondeterminic polynomial means you could try every possible solution nondeterministically, and get an answer in polynomial time.
16:15:22 <cj3kim> c_wraith: what do you mean by nondeterministically? all i know is that a non-deterministic function does not necessarily map 1-1 in its domain and range
16:16:38 <cj3kim> that's when my friend gave me an example of the quantum computer
16:17:18 <c_wraith> Nondeterminism is when you have choices to make in the process, but when you're done you have a list of exactly what the "correct" choices were.
16:19:00 <c_wraith> many people think quantum processors are nondeterministic, but they're not.  They sort of smear all the answers together.  A problem is in quantum-polynomial time only if there's some way to figure out what the answer is from the "smeared" state.
16:23:43 <cj3kim> c_wraith: is a non-deterministic process always in polynomial time?
16:23:50 <cj3kim> or better?
16:24:03 <cj3kim> i see what you mean about the quantum processors
16:24:06 <c_wraith> Usually neither.
16:24:34 <cj3kim> ahh,
16:24:43 <c_wraith> I mean, a nondeterminstic process is just... a process.
16:25:01 <c_wraith> Modeling a nondeterminstic polynomial process is usually exponential time
16:25:31 <dolio> Unless it isn't, which no one knows. :)
16:25:43 <c_wraith> But it's important to recognize the difference between the model and emulating one.
16:25:52 <c_wraith> dolio: so far it is!  Usually...  :)
16:26:14 <dolio> I guess all the ways anyone knows are exponential. Otherwise we would know.
16:26:16 <Hijiri> is there a more convenient way to use Int newtypes with IntMaps and IntSets
16:26:32 <Hijiri> than just explicitly wrapping and unwrapping
16:26:40 <cj3kim> c_wraith: thanks for taking the time to explain it to me
16:26:40 <dolio> Nope.
16:26:45 <Hijiri> aww
16:26:51 <dolio> Yeah, it's a bummer.
16:27:21 <c_wraith> dolio: well, there are degenerate cases.  Like, say.. the decision problem p(x) = x == 0.
16:27:36 <Hijiri> If I was using 7.10 I could at least use coerce
16:27:44 <Hijiri> instead of writing getFoo and Foo everywhere
16:27:45 <c_wraith> dolio: You can treat that as a nondeterministic decision problem!  :)
16:28:04 <dolio> cj3kim: One way to think about the nondeterministic Turing machines from NP (I think) is that they have infinite amounts of parallel processing capability.
16:28:18 <dolio> Or, concurrent, perhaps.
16:29:09 <c_wraith> You can solve an NP problem in polynomial time with infinite parallel processing power, yes.
16:29:23 <dolio> Quantum computers kind of have that, except you don't get to just look at all the different answers at the end.
16:29:26 <cj3kim> I'm looking for a job right now and I'm reviewing a list of NP-hard problems before getting hired :)
16:29:33 <dolio> You need to find some trick to get an answer out.
16:29:33 <c_wraith> That's...  pretty much equivalent to the definition of NP
16:29:44 <c_wraith> they're also not infinite
16:29:57 <cj3kim> I don't have a traditional CS background, but I want to know those problems just in case an employer wants me to code something that IS NP-hard lol
16:30:00 <c_wraith> They are limited to some number of qbits of parallelism. :)
16:30:41 <c_wraith> cj3kim: watch out for being asked to code something that's flat-out undecideable.  :)
16:30:49 <dolio> Isn't that a limit on problem size, not amount of parallelism?
16:31:03 <dolio> Like, the difference between a PC and a turing machine?
16:31:16 <c_wraith> same thing, since amount of parallelism required is equivalent to the problem size.
16:32:28 <dolio> Anyhow, even if you have an NP problem with a size small enough for your qbits, you might not be able to solve it.
16:33:02 <c_wraith> really, aren't the only problems in QP the ones that are basically equivalent to integer factorization?
16:33:15 <c_wraith> (like discrete logs, for instance)
16:33:23 <dolio> I don't know. I've never really studied quantum computing much.
16:33:23 <simon> http://lpaste.net/156224951446142976 - I'm kind of stucking making sense of these type errors. I just want my Data.Map.Map to be an instance of ToJSON.
16:35:07 <dolio> In theory I took a semester course on it, actually. But I didn't retain much.
16:36:22 <cj3kim> you know, i've been trying to look for ways to compute meaningful information using arc tangent
16:36:42 <cj3kim> tan = sin/cos 
16:36:58 <cj3kim> very similar to rise over run
16:37:33 <cj3kim> tan takes degrees/radians and spits back out a ratio, arc tangent takes a ratio and spits back out degree/radians
16:38:41 <cj3kim> so if I have a ratio of 5/1 and put it through arctan
16:38:50 <cj3kim> i get 1.37 rads/78 degrees
16:40:51 <cj3kim> i'm wondering if this means something akin to "degree of change"
16:40:51 <cj3kim> probably more useful for vector mathematics than simple ratio analysis :)
16:40:51 <cj3kim> as 5/1 is enough info to talk say you have five times more than something
16:47:00 <simon> here's a shaved example: http://lpaste.net/873204144477831168 - can anyone tell me how to get the ToJSON Member instance working?
16:51:01 <bergmark> simon: aeson only supports Map instances with Text or String as keys
16:53:05 <bergmark> simon: so you can't derive an instance, use something like `toJSON = toJSON . mapKeys myToString'
17:07:36 <simon> bergmark, ah! thanks.
17:07:46 <simon> bergmark, yeah, that should have been obvious, I suppose.
17:12:11 <gamegoblin> Can anyone think of a better way to write this (the nested if-statements look a little funny to me) http://pastebin.com/pMts5mq7
17:22:04 <simon> gamegoblin, you could make a monad type for returning values. i.e. once you hit 'returnVal bytes', subsequent code won't run. it's sort of like the reverse use of the default Maybe monad instance (where it doesn't execute once it hits Nothing).
17:22:29 <gamegoblin> simon: sounds like the Either monad 
17:22:38 <gamegoblin> (where Left ceases the following code)
17:23:51 <simon> err, right. so 'return (Left bytes)'
17:37:00 <simon> gamegoblin, what I had in mind was a series of: do { ...; when (bytesRead >= minBytes) $ return $ Left bytes; ...; when (isChannelEOF channel) $ return $ Left bytes; ... }
17:42:01 <t4nk057> hey i just switched to using ghc 7.10 and now when i try to install packages using cabal install i get this error: ghc: ghc no longer supports single-file style package databases (dist/package.conf.inplace) use 'ghc-pkg init' to create the database with the correct format.
17:43:13 <simon> wow, what is this... a botnet?
17:43:50 <bergmark> kylejmckean: remove that file/dir and try again
17:44:22 <bergmark> kylejmckean: cabal clean also does the trick, but removes more stuff
17:44:38 <kylejmckean> bergmark: what does cabal clearn do?
17:44:45 <kylejmckean> bergmark: how do i remove that file?
17:44:50 <bergmark> kylejmckean: it deletes all build artifacts
17:45:28 <bergmark> kylejmckean: rm -r dist/package.conf.inplace :-)
17:46:16 <kylejmckean> bergmark: I dont have a dist directory 
17:47:48 <bergmark> kylejmckean: did you try ghc-pkg init as the message suggested?
17:48:00 <kylejmckean> bergmark: trying
17:48:51 <bergmark> kylejmckean: i guess i only got that error when installing a library from the filesystem... so that's why i assumed you had a dist directory
17:49:24 <kylejmckean> bergmark: ghc-pkg: command-line syntax error
17:49:35 <kylejmckean> bergmark: sigh unhelpful error messages
17:50:26 <bergmark> kylejmckean: yep :-( rm -rf ~/.ghc will probably solve it. that dir contains a bunch of stuff from your old ghc installation which you don't need anymore
17:51:44 <kylejmckean> bergmark: same problems with cabal install should i open an issue on stackoverflow?
17:54:15 <L8D> when someone uses the word 'closure' are they meaning a type of function or a type of scope?
17:54:21 <L8D> or is 'closure' a verb somehow?
17:54:28 <bergmark> kylejmckean: if you can't find a package.conf.inplace anywhere I'm out of ideas
17:54:35 <L8D> https://en.wikipedia.org/wiki/Closure_(computer_programming) is really not helping
17:55:02 <bergmark> L8D: it's a function in combination with the variables in its scope
17:55:05 <L8D> I understand the concept of a closure, but I'm never sure as to what I'm exactly referring
17:55:30 <L8D> bergmark: hm... so (+ 1) is a closure? a closure function?
17:55:43 <bsmt> WOOOOOOOOO NETSPLITS
17:56:00 <L8D> like which part of it is a closure, or under what context is it a closure?
17:56:06 <bergmark> L8D: i would just call (+ 1) a function, it doesn't refer to any variables
17:56:09 <L8D> similar to the difference between arguments and parameters
17:56:24 <L8D> bergmark: what's an example where you would call something a closure?
17:57:06 <bergmark> L8D: let f = (\x -> (\y -> x)) 1, here f is a closure over x
17:57:11 <L8D> according to wikipedia it is a type of data structure to bind a function to a parent scope
17:57:19 <L8D> but it can also just refer to the function that is bound
17:57:27 <L8D> or it can refer to the scope
17:57:32 <L8D> or a variable that is inside a closure
17:57:34 <L8D> etc.
17:57:58 <L8D> so a closure, formally, is a type of binding between a function and it's scope?
17:58:17 <L8D> it is not the function nor the scope but the system for relating the two?
17:58:36 <bergmark> L8D: that sounds right to me, and it's only really useful if the function contains names defined in a parent scope
17:59:00 <bergmark> it's only useful to refer to it as a closure if*
17:59:03 <timemage> L8D, the second paragraph in the "History and etymology" section of the wikipedia page seems to be addressing that.
18:00:09 <bergmark> L8D: and argument vs parameter, (\x -> x) y, here y is the argument that gets bound to the parameter x
18:00:25 <L8D> timemage: so it's the type of expression? an expression which uses variables from its parent's scope?
18:00:32 <bergmark> parameters are used in a function definition, arguments are used when applying a function
18:00:33 <Cale> L8D: A closure is a data structure consisting of a pair of some code, and an environment table mapping free variables in that code to values.
18:00:38 <L8D> but not the data structure/mapping/value
18:00:51 <L8D> see how confusing this is
18:01:02 <Cale> A closure is not a function, it's a particular data structure used to implement functions (and sometimes objects as well)
18:02:03 <gamegoblin> @pl \x y -> f $ g $ h x y
18:02:04 <lambdabot> ((f . g) .) . h
18:02:17 <Cale> If you ever read "language X has closures" you should be really suspicious -- probably what is really meant is that the implementation of language X uses closures to implement functions.
18:02:41 <L8D> Cale: so conceptually, the expression (1 +) is a function like (\x -> 1 + x)
18:03:00 <L8D> Cale: but internally, Haskell creates a mapping that looks somewhat like ((+), 1)
18:03:06 <Cale> Almost no language has any sort of built in support for closures as a data structure, they're part of the language implementation. If you can't explicitly separate the code and the environment any longer, it's not a closure.
18:03:12 <gamegoblin> It doesn’t help that the communities of certain language refer to all anonymous functions as closures
18:03:14 <L8D> and that internal representation is the closure?
18:03:16 <Cale> L8D: Right, a bit like that
18:03:25 <ttt_fff> iw ther ea function which maps [1, 2, 3] -> {(1, True), (2, True), (3, False)] i.e. it shows True for non-last element, and False for last element
18:04:02 <L8D> So a closure is this abstract concept which shouldn't be relevant to writing code but it is because of misconceptions?
18:04:33 <L8D> like garbage collection is an abstract concept which shouldn't be relevant to writing code
18:04:42 <Cale> Yep
18:04:45 <L8D> Got it
18:05:12 <L8D> What term should I use to describe a function that is bound/restricted to its parent's scope?
18:05:25 <L8D> i.e. one that couldn't be defined out of that context
18:05:41 <bergmark> L8D: that's all lexically scoped functions
18:05:54 <L8D> like if I write: f x = let g y = x + y in ...
18:05:57 <L8D> g is bound to it's scope
18:06:00 <Cale> Normally we just refer to those as functions, but if you want to be explicit, you can say "functions which capture the values of free variables used in their body" or something.
18:06:38 <L8D> bergmark: but is a function that isn't limited to its parent's scope (like \x -> x) also a lexically scoped function?
18:07:14 <Cale> L8D: Note that the function g there isn't limited to f's scope
18:07:29 <Cale> You could write  f x = let g y = x + y in g
18:07:55 <bergmark> L8D: it doesn't have to be, but all current languages i know of except emacs lisp uses lexical scoping by default
18:08:01 <Cale> Now g will be the result of f, and might outlive it :)
18:08:02 <L8D> Cale: I thought it is limited because otherwise x is undefined
18:08:17 <L8D> Cale: you couldn't write f x = g \n g y = x + y
18:08:21 <Cale> L8D: The value of x becomes part of the definition of g
18:08:21 <L8D> :s/\n/;
18:08:53 <Cale> So, for instance, f 5 = let g y = 5 + y in g
18:09:08 <Cale> = (\y -> 5 + y)
18:09:19 <bergmark> L8D: also see ghc's implicit parameters which adds dynamic scoping
18:09:22 <L8D> I meant the expression
18:09:43 <L8D> an expression of a function that can't be moved out of its scope because it uses free variables in their body
18:09:58 <Cale> Yeah, okay, I see what you mean
18:10:01 <L8D> by "moved out of its scope" I mean defined in a different scope
18:10:12 <Cale> yeah
18:10:13 <L8D> Cale: is there a good way to describe that type of exrpession?
18:10:27 <L8D> Cale: other than the word "closure" (which is incorrect)
18:10:51 <Cale> A function with free variables in its body, I suppose.
18:10:57 <bergmark> L8D: that's lexical scope, the definition site matters. with dynamic scoping only the callsite matters
18:11:29 <L8D> bergmark: so I could say that 'g' uses a lexical scope?
18:11:48 <L8D> or 'g is lexically scoped'
18:11:55 <Cale> g captures the values of variables in lexical scope
18:12:02 <bergmark> L8D: yep and yep
18:12:13 <L8D> ok I think I'll use that
18:12:22 <L8D> since I believe JavaScript developers will understand that term
18:12:32 <Cale> Though really, it's sort of weird that this is a distinction at all
18:12:51 <Cale> Like, there's nothing really special going on here, you're just not fucking up your implementation of functions.
18:13:34 <c_wraith> Lots of languages don't do lexical scoping of functions.
18:13:36 <bergmark> Cale: languages used to have dynamic scope until... the early 60's or something. so at least then it was useful :)
18:13:40 <L8D> Cale: I'm producing a screencast where I need to mention something along the lines of "functions which aren't lexically scoped can be moved out and delegated to"
18:13:49 <Cale> Yeah, back when people didn't know what they were doing :P
18:14:20 <c_wraith> elisp still has dynamic scoping, because it does things as badly as workable!
18:14:21 <L8D> or "this can be extracted because it's not lexically scoped but this other function has to stay or be refactored"
18:15:21 <Cale> L8D: Right, you can always add any relevant free variables in the body of the lambda as parameters, and move it out of the scope in which those variables get bound.
18:15:21 <bitemyapp> I've found that functions that reply on scope prolifically or have a tonne of interdependent where clauses usually need refactored.
18:15:28 <bergmark> L8D: i wouldn't say "it isn't lexically scoped", i'd say "it doesn't use its lexical scope"
18:15:41 <c_wraith> also, ghc has dynamic scoping, but at least dynamically-scoped free variables appear in type signatures.
18:15:55 <kylejmckean> how does one update cabal to 1.22?
18:16:11 <L8D> bergmark: what about "it isn't bound to the parent scope"?
18:16:45 <L8D> which makes more sense in a JavaScript context though
18:17:03 <Cale> kylejmckean: The library Cabal or the cabal-install program?
18:17:05 <bergmark> L8D: sounds good
18:17:17 <Cale> kylejmckean: cabal install Cabal and cabal install cabal-install respectively
18:17:29 <kylejmckean> Cale: thanks
18:17:43 <bergmark> kylejmckean: and then make sure the binary is in your PATH, probably it ends up in ~/.cabal/bin/
18:19:49 <kylejmckean> bergmark: ghc: ghc no longer supports single-file style package databases (dist/package.conf.inplace) use 'ghc-pkg init' to create the database with the correct format.
18:19:57 <kylejmckean> bergmark: when trying to install cabal-install
18:21:24 <bergmark> kylejmckean: ah that again :-(
18:21:29 <Cale> L8D: Now, things get a lot more confusing in languages where variables are implicitly referring to mutable references, and using them involves looking up the value of that mutable reference, so you can't easily talk about the memory location and its value separately.
18:21:56 <kylejmckean> Cale: do you have any insight into my error
18:22:26 <Cale> kylejmckean: maybe...
18:22:32 <L8D> Cale: I believe the difference between 'value' and 'reference' is well enough understood though
18:24:13 <bergmark> L8D: i've seen people confuse that... even confuse variables with values
18:24:26 <Cale> L8D: So it becomes an interesting question whether the function's body involves some free variable x, whether the function is capturing the mutable cell x (and doing a lookup each time it's evaluated), or whether it does the lookup immediately, and captures the value that the variable had at the time the function was constructed.
18:24:57 <c_wraith> That's why java had all those rules about final with anonymous inner classes
18:24:59 <Cale> This is the trouble you get into when you don't distinguish names for values from mutable references
18:25:49 <Cale> heh, replace my first 'whether' with 'whenever' I suppose :)
18:26:30 <Cale> L8D: In Haskell, it's pretty clear
18:26:56 <bergmark> now we are getting into call-by-name etc :-D soon we have covered all of SICP
18:27:09 <Cale> L8D: I might have a function which is capturing the value of an IORef, say, and that's very different from looking up the value of the IORef beforehand, and capturing the result of that operation.
18:27:20 <c_wraith> actually, this has more to do with Ref types than calling conventions
18:28:22 <bergmark> https://en.wikipedia.org/wiki/Evaluation_strategy
18:30:30 <bergmark> yay algol60
18:31:21 <Cale> Something like (\x -> do v <- readIORef r; return (v + x))  is very different from  do v <- readIORef r; return (\x -> v + x) -- they even have different types, but even if we added some returns to make them have the same type, they'd behave quite differently
18:34:29 <Cale> But the difference between those two things is often difficult to discuss in languages where using the variable r means you look up its value, because you don't have an easy way to talk about how that lookup interleaves with other operations
18:37:03 <Cale> Note that this is a separate distinction again from whether the function is capturing the values of free variables in the scope where it's defined -- it's getting at "what counts as the 'value', when every variable sort of has two?"
18:39:35 * hackagebot pseudo-boolean 0.1.1.0 - Reading/Writing OPB/WBO files used in pseudo boolean competition  http://hackage.haskell.org/package/pseudo-boolean-0.1.1.0 (MasahiroSakai)
18:39:36 <Cale> Probably the most sensible thing is to do all the lookups before the function is constructed, and use the values, rather than the mutable references themselves.
18:40:04 <bergmark> :-) this is an example why haskell is the best imperative programming language
18:40:26 <Walpurgisnacht> What example
18:40:52 <bergmark> Cale's readIORef example
18:41:14 <Walpurgisnacht> Yeah you are right
18:41:15 <Cale> Walpurgisnacht: The thing I'm discussing about whether functions capture the mutable references which are in scope at the point of their definition, or they capture the values contained in those mutable references.
18:44:26 <gamegoblin> :t first
18:45:17 <bergmark> gamegoblin: there are two `first' on ghc 7.10, Control.Arrow and Data.Bifunctor
18:45:35 <gamegoblin> :t Control.Arrow.first
18:45:36 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
18:45:49 <luzie> :t first
18:45:50 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
19:00:54 <quazimod1> mapM :: Monad m => (a -> m b) -> [a] -> m [b]
19:00:56 <quazimod1> that's weird
19:01:33 <quazimod1> take a list of as and return a list of bs inside a monad m
19:02:57 <bergmark> quazimod1: why do you think it's weird?
19:03:42 <albeit> Is there any way to recv from a socket and return Just if something is available, otherwise Nothing immediately?
19:04:39 <pacak> :t mapM
19:04:40 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
19:05:15 <pacak> albeit: There is a  syscall to get number of bytes in the socket buffer which should do the trick, but last time I used it I had to implement FFI myself.
19:06:43 <albeit> pacak: That sounds perfect! Do you remember what the syscall was?
19:07:18 <albeit> Ah I think it may be ioctl FIONREAD
19:07:21 <naudiz> Hey, is there a short and easy way to turn [(a,a,a,a)] into ([a],[a],[a],[a])? e.g.: [(1,2,3,4),(5,6,7,8)] -> ([1,5],[2,6],[3,7],[4,8]) (order matters)
19:07:36 <Mad7Scientist> I could do it in C!
19:07:55 <lpaste> pacak pasted “No title” at http://lpaste.net/134882
19:08:25 <Cale> :t unzip4
19:08:26 <lambdabot> [(a, b, c, d)] -> ([a], [b], [c], [d])
19:08:30 <pacak> albeit: http://lpaste.net/134882
19:09:25 <naudiz> nevermind, I'm stupid
19:09:34 <albeit> pacak: Thanks
19:09:54 <pacak> albeit: This works for UDP.
19:10:04 <Mad7Scientist> so in Haskell you just use -> and it converts things for you?
19:11:09 <Cale> Mad7Scientist: hm?
19:11:26 <Cale> Mad7Scientist: There are a few places where -> gets used in the Haskell syntax
19:11:30 <pacak> :k (->)
19:11:31 <lambdabot> * -> * -> *
19:11:44 <Cale> One is in the syntax of functions, and in the types of functions
19:11:53 <pacak> lambdabot: Y U SO SLOW TODAY?
19:12:13 <quazimod1> bergmark: 'cos i'm new. 
19:12:19 <quazimod1> bergmark: i don't fully inderstand it
19:13:01 <Cale> quazimod1: Okay, so in order to understand that, it's probably best to have a look at sequence first
19:13:17 <quazimod1> ochay
19:13:29 <Cale> sequence takes a list of actions in some monad and glues them together into a single action which will run each of them in turn, collecting a list of the results
19:13:41 <Cale> sequence :: (Monad m) => [m a] -> m [a]
19:13:45 <bergmark> quazimod1: i did not mean to come across as condescending
19:13:58 <Cale> We can implement this recursively as follows:
19:14:07 <quazimod1> bergmark: all good :)
19:14:16 <quazimod1> i've found everyone in this channel to be really helpful and open
19:14:20 <Cale> sequence [] = return [] -- if the list of actions is empty, we just produce the action which does nothing except to produce the empty list as its result
19:15:00 <quazimod1> Cale: and it's not important what that 'list of actions in some monad' is
19:15:01 <Cale> sequence (x:xs) = do v <- x; ... -- if the list of actions is nonempty, we first execute the first action, x, getting some result v, ...
19:15:38 <Cale> and then we need to run the rest of the list of actions, getting a list of their results. Thankfully, we have a function for doing that, it's the one we're writing:
19:15:48 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; ...
19:16:18 <Cale> and finally, we want to combine the first result with the list of the rest of the results, and return that as the result of our combined action:
19:16:21 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
19:16:39 <Cale> Cool?
19:18:12 <Cale> So this sequence function is a sort of "primordial loop" -- if we can decide ahead of time what ought to happen on each iteration of a loop, and make a list of those actions, sequence will stitch them together for us into an action which will run all the iterations (and collect a list of the results of each)
19:19:30 <Cale> Now, we can write:
19:19:37 <Cale> mapM f xs = sequence (map f xs)
19:20:04 <Cale> So, here, we apply the function f to each element of the list xs, to determine what should be done on each iteration. So this is a kind of for-each loop.
19:20:33 <albeit> If this is not Haskell related enough let me know... If I use GHC.Event and use it's epoll functionality with a timeout of zero, is that effectively the same as manually constantly checking the file descriptors for "ready-ness"?
19:20:35 <Cale> f is essentially the 'loop body', as a function of the elements of the list
19:22:29 <Cale> albeit: Were you the one that I was talking to earlier? Did the suggestion to just use threads not work out well enough?
19:23:34 <albeit> Cale: Nope not me! But I want to check multiple sockets non-blockingly on the same thread... 
19:24:34 <Cale> Is that just because you think the code will be easier to read that way?
19:24:59 <Cale> Because using multiple (Haskell) threads is sort of the way you express the idea that you want to wait on multiple things.
19:25:23 <Cale> It's still implemented using non-blocking I/O and registering interest in the relevant things with the OS.
19:26:53 <quazimod1> cale hold on i brb
19:26:55 <quazimod1> stuff's going on
19:27:03 <albeit> Cale: No just for performance reasons... if the socket has nothing available the RTS effectively blocks on that socket (after two tries).... I'd prefer not to have that ~20ms performance hit
19:27:09 <Cale> When you try to read from the socket, it will appear as if your Haskell thread is blocked, but the OS thread it's running on is not blocked
19:27:38 <Cale> hmm
19:27:56 <Cale> How did you measure the 20ms?
19:28:01 <albeit> *us
19:28:02 <albeit> Sorry
19:28:38 <albeit> I haven't actually measured it for sockets, I was measuring on a different blocking call for Chan's
19:29:32 <albeit> Cale: As I understand it, the Haskell thread is blocked, and the event manager waits until the OS notifies it that the socket is available to be read from again...
19:30:25 <kqr> merijn, thanks for the tip about the STG paper. halfway through it now and it's both fascinating and surprisingly simple/understandable
19:31:46 <albeit> Cale: Actually my phrasing is probably completetly wrong. The Haskell thread doesn't block, but the socket's file descriptor is added to the epoll list, and awaits a notification from the OS
19:32:38 <Cale> Yeah, well, from the Haskell programmer's perspective, the Haskell thread gets blocked.
19:33:39 <albeit> Okay
19:33:43 <c_wraith> the haskell thread does block.  Just not the OS thread the haskell thread was mapped to.   At least, not necessarily.
19:34:14 <c_wraith> It might block, if there are no other haskell threads to run.
19:34:56 <albeit> Okay. So the OS thread is also running the event manager, which is also not blocked, but if the socket reading thread is the only thread on that capability, it is effectively blocked cause its epolling with a timeout of forever on that socket? Is that right?
19:35:13 <c_wraith> the event manager is running on another haskell thread, actually.
19:35:29 <c_wraith> So it also gets multiplexed to an OS thread
19:35:53 <Cale> Yeah, there's a dispatcher (Haskell) thread which executes a poll loop, using epoll_wait to wait on all registered events.
19:36:39 <albeit> This is great. Trying to read the source only got me so far!
19:37:01 <c_wraith> albeit: http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
19:37:02 <Cale> Er, actually, I don't know if that knowledge is out of date or not
19:37:04 <albeit> Are both the event manager and sub- / other haskell threads  that it dispatches running on the same OS thread?
19:37:05 <Cale> heh
19:37:13 <Cale> The IO manager has been replaced a few times
19:37:20 <c_wraith> That paper describes the latest large-scale rewrite of the IO manager
19:37:38 <c_wraith> It has been tweaked since, but that was the last time it got huge changes
19:37:43 <albeit> c_wraith: Yeah I've read that, I should probably got over it again though
19:38:35 <Cale> Oh, right, there are per-core dispatcher threads now
19:39:10 <Cale> (I'm just skimming over that paper again myself :)
19:39:14 <albeit> On a somewhat related note, if a Haskell programs makes an unsafe call that for some reason blocks, can GC still occur properly?
19:39:38 * hackagebot base-orphans 0.3.3 - Backwards-compatible orphan instances for base  http://hackage.haskell.org/package/base-orphans-0.3.3 (ryanglscott)
19:39:47 <c_wraith> albeit: nope
19:40:08 <c_wraith> albeit: if an execution context doesn't yield, GC can't happen.
19:40:34 <albeit> What exactly happens? Does the GC just freeze all other HEC's, and wait for that one that is blocking to finally yield? So the entire program is effectively frozen?
19:40:39 <c_wraith> albeit: yep
19:40:47 <c_wraith> You can see it in threadscope
19:40:52 <c_wraith> Which is actually a really nice tool
19:40:58 <c_wraith> Even if it is a bit of a pain to install
19:42:36 <albeit> I'll try it out. One final question (for now), and this is probably in the paper somewhere... is each Haskell thread on a HEC given a certain amount of time to execute, and then paused, and another thread run? Does the pausing still happen if there is only one thread to run?
19:44:44 <c_wraith> I don't actually know the scheduling details
19:48:40 <albeit> Okay, well thanks c_wraith and Cale, very helpful!
19:58:15 <athan> Anyone here have issues with hspec eating up all memory before running tests?
20:01:34 <bergmark> athan: something library specific is probably better asked on its bug tracker or similar
20:27:22 <Moggle1> i'd like to traverse data.xml.types element/node
20:27:32 <Moggle1> and map over every NodeContent (ContentText t)
20:27:39 <Moggle1> does anyone know what the easiest way to do it would be?
20:28:01 <Moggle1> i could just write a basic function to do it, but it seems more elegant to use something like lens/some sort of generic way to make the type traversable
20:30:22 <dmj`> @package xml-lens
20:30:22 <lambdabot> http://hackage.haskell.org/package/xml-lens
20:31:04 <nocturne777> my distro upgraded my ghc to 7.10.1 and all of a suddent packages like system and mtl are missing
20:31:28 <nocturne777> they were gone from ~/.cabal
20:32:00 <Moggle1> thank you dmj`
20:32:02 <nocturne777> probably projects under cabal control are not affected
20:32:22 <nocturne777> but I was surprised to find these packages gone after the upgrade
20:35:37 <nocturne777> oh, I see. it created a new clean lib directory x86_64-linux-ghc-7.10.1  did not touch x86_64-linux-ghc-7.8.4
20:37:23 <rofer> I'm trying to work from a private hackage server, but cabal seems to be trying to download from the wrong place.
20:37:42 <rofer> It tried http://angel.rofer.me:8080/packages/package/rlglue-0.2.0.0.tar.gz when it presumably wants http://angel.rofer.me:8080/package/rlglue-0.2.0.0/rlglue-0.2.0.0.tar.gz
20:38:52 <rofer> Any idea what's going on?
20:40:29 <L8D> how did you configure cabal to use that hackage server?
20:41:13 <L8D> rofer: actually with haskell.org's hackage server both conventions seem to work
20:41:51 <L8D> rofer: perhaps you're using a newer/older version of the private hackage server?
20:41:53 <quazimod1> Cale: ok i read that stuff
20:41:55 <quazimod1> pretty cool
20:42:10 <quazimod1> I need to spend more time on learning things like 'doing actions'
20:42:17 <quazimod1> i don't know how that's implemented yet
20:42:17 <rofer> Hmmmm, I built my hackage from git head. Maybe that's the problem
20:42:58 <quazimod1> though i'm certain that it'll be specific to each monad et
20:45:51 <rofer> Ah, had my URL wrong in .cabal/config
20:49:42 * hackagebot warp-tls 3.0.4.2 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-3.0.4.2 (MichaelSnoyman)
20:58:59 <Cale> quazimod1: Yeah, what it means to execute an action depends on the monad in question.
21:20:49 <quazimod1> Cale: these actions, how do we actually write them
21:20:56 <quazimod1> say i wanted to implement an IO action by my self
21:21:06 <quazimod1> lets just do stdin/out
21:24:04 <Cale> quazimod1: Well, in the case of IO, since it's an abstract type, you have to use other existing IO actions to build new ones
21:24:17 <Cale> do v <- getLine; putStrLn v
21:25:05 <Cale> will be the action which first executes getLine, reading a line of text on the terminal, naming the resulting String v, and then will execute putStrLn v to print it back out
21:25:58 <Cale> If you type that in GHCi, it will notice that it's an IO action, and execute it for you.
21:26:36 <quazimod1> Cale: hrm ok
21:26:38 <Cale> In a compiled Haskell program, you define a main action, and it gets executed to start the program off.
21:26:51 <Cale> You could also try  sequence [print n | n <- [1..10]]  which will print the numbers 1 through 10
21:26:58 <Cale> or   mapM print [1..10]
21:27:05 <quazimod1> Cale: i'm justtrying to see how one 'breaks out' of haskell clean world
21:27:33 <quazimod1> one can't really implement IO in haskell then, not using haskell's language anyway
21:27:47 <quazimod1> we can use existing IO stuff the compiler makes available to us
21:28:07 <Cale> Well, you could implement the IO type in Haskell directly, and you could implement an interpreter for your IO type using the existing IO type
21:28:36 <Cale> GHC's implementation of the IO type is a dirty hack though -- it uses impure functions
21:28:46 <quazimod1> right
21:29:08 <Cale> But apart from "it was easier to get good performance from existing mechanisms that way", there isn't much of a good reason that it isn't just a pure data structure.
21:29:26 <quazimod1> hrm
21:29:29 <quazimod1> ok
21:29:38 <quazimod1> does this ever cause problems?
21:29:42 <Cale> You can imagine that it's a data type with constructors for various primitive IO actions, and perhaps one which takes as arguments the information necessary to make an FFI call, and such
21:29:43 * hackagebot network-conduit-tls 1.2.0.1 - Create TLS-aware network code with conduits  http://hackage.haskell.org/package/network-conduit-tls-1.2.0.1 (MichaelSnoyman)
21:30:04 <mniip> [07:28:21] <quazimod1> does this ever cause problems?
21:30:06 <quazimod1> not being able to define new primitive actions
21:30:26 <quazimod1> unless i misunderstood, cale's saying all (for example) IO is built on IO primitives
21:30:29 <Cale> and only the *interpreter* for that type which breaks the values apart and carries out the described actions needs to be able to cause effects
21:30:31 <mniip> a module called System.IO.Unsafe defines some fancy, but unsafe primitives for doing weird things with the IO monad
21:30:33 <quazimod1> we can't use haskell to make new primitives
21:30:46 <quazimod1> ok
21:30:52 <mniip> which can be useful, but can break, hence the name
21:30:57 <Cale> mniip: Well, the stuff in System.IO.Unsafe is more related to causing IO to occur as a result of *evaluation*
21:31:06 <mniip> Cale, not talking about perform even
21:31:12 <quazimod1> haskell's cool and weird
21:31:13 <Cale> So it's about extending the meaning of evaluation, moreso than extending the meaning of execution.
21:31:19 <quazimod1> it'll be fun to use it in my ruby program
21:31:19 <mniip> duplicate stuff, interleaved io
21:31:34 <Cale> Oh, I should have mentioned this, hopefully it's been reasonably clear
21:31:38 <awoserra> > 2^3
21:31:39 <lambdabot>  8
21:31:52 <Cale> But there are two mostly-separate processes which take place as a Haskell program runs
21:31:57 <quazimod1> ok
21:32:06 <awoserra> > 2^64
21:32:08 <lambdabot>  18446744073709551616
21:32:09 <Cale> There's evaluation, which refers to reducing expressions to values, mostly in order to pattern match.
21:32:32 <quazimod1> Cale: oh i see
21:32:37 <Cale> and then there's execution of IO actions, which refers to carrying out the effects described by an IO action value (in order to obtain some result)
21:32:53 <quazimod1> causing IO during evaluation would be weird then
21:32:54 <Cale> Evaluating an IO action does nothing much which is visible
21:32:58 <quazimod1> why'd we want that
21:33:13 <Cale> It just puts it into some sort of normal form in memory, and warms your CPU up a bit
21:33:17 <mniip> GHC does both at the same time because stateful functions
21:33:27 <quazimod1> WEIRD 
21:33:28 <Cale> quazimod1: We usually wouldn't, but there are powerful things you can do with it.
21:33:28 <mniip> but that's a whole another story
21:33:30 <quazimod1> man haskell is weird
21:33:32 <quazimod1> i like
21:33:52 <mniip> quazimod1, after a few months you'll find it the least weird language
21:34:21 <Cale> quazimod1: For example, Data.ByteString does a bunch of this behind the scenes, allocating and managing memory for the bytestrings directly
21:34:41 <mniip> :o
21:34:46 <Iceland_jack> quazimod1: Other languages don't make a distinction between an "action" and the "values it produces", that will start feeling weird after a while
21:34:49 <nocturne777> can I have 7.10.1 and 7.8.1 installed on the same box?
21:35:11 <mniip> Cale, I would have expected ByteString to be implemented via MutableByteArray and not unsafePerformIO?
21:35:21 <Cale> quazimod1: Basically, you should reserve unsafePerformIO :: IO a -> a for cases where (1) you really really know what you're doing, and (2) you'd otherwise have to modify the compiler to do it well.
21:36:03 <Cale> mniip: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/bytestring/src/Data-ByteString.html#map
21:36:20 <mniip> hmm
21:36:21 <mniip> okay
21:36:29 <mniip> that's weird though
21:37:15 <quazimod1> mm
21:37:27 <Cale> lol, there are a lot of occurrences of "accursedUnutterablePerformIO" there :D
21:37:39 <mniip> perhaps this pointer stuff is supported on more compilers than MutableByteArray is
21:38:33 * awoserra starts reading in ghc-master
21:38:34 <quazimod1> I'll get there, just atm I can't see why main is always type IO
21:38:48 <Cale> mniip: I don't think MutableByteArray existed when ByteString was written either.
21:39:03 <Cale> quazimod1: Ah, well, that's just because you usually want your program to be able to do things.
21:39:31 <Cale> quazimod1: Even if it's just printing out a result
21:39:44 * hackagebot discrimination 0 - Fast generic linear-time sorting, joins and container construction.  http://hackage.haskell.org/package/discrimination-0 (EdwardKmett)
21:39:46 * hackagebot exherbo-cabal 0.1.0.2 - Exheres generator for cabal packages  http://hackage.haskell.org/package/exherbo-cabal-0.1.0.2 (NikolayOrlyuk)
21:39:48 <codygman> I would like to compile a Haskell program with GHC 7.10 from my ubuntu 14.10 machine to work on ubuntu 12.04. How should I go about this? It tried using `ghc-options: -optl-static -optl-pthread -fPIC` and got the following warnings: http://lpaste.net/134900 I feel like the easiest route will be to create a docker container with ubuntu 12.04 and install things there... but that seems rather heavyweight. Ideas?
21:39:57 <Cale> quazimod1: Programs which do no I/O at all are kind of useless apart from turning your computer into a space heater.
21:39:59 <quazimod1> Cale: yeah i can't see why that can't be stuff iside main
21:40:37 <quazimod1> my naive example being ruby on rails, the 'main' thing there just boots up the rails environment, it calls a couple of methods
21:40:40 <Cale> quazimod1: Well, main itself needs to be an IO action because only IO actions can request the execution of other IO actions. Evaluation never causes execution (apart from the low level hacks which mniip mentioned)
21:40:50 <edwardk> yay, discrimination is released into the world.
21:41:02 <quazimod1> Cale: hrm
21:41:04 <mniip> hey edwardk
21:41:05 <edwardk> now to make it more productive
21:41:06 <quazimod1> interesting
21:41:07 <edwardk> heya
21:41:07 <Cale> edwardk: I love the version number
21:41:12 <edwardk> Cale: =)
21:41:25 <mniip> edwardk, are you aware of a way to test whether a type is a member of a typeclass
21:41:27 <edwardk> it use '' if i could get away with it
21:41:31 <mniip> using type families or otherwise
21:41:41 <edwardk> mniip: the point of the open world assumption is you can't
21:41:50 <mniip> yes
21:42:01 <mniip> which is why I was originally looked at closed type families
21:42:04 <edwardk> there are evil oleggy ways based on old bugs and what not
21:42:13 <edwardk> but good luck =P
21:42:30 <mniip> but apparently GHC gives 'Fooable (Foo a => a) = True' another meaning than the one I intended
21:42:30 <Cale> The way to test whether a type is a member of a type class is to stop using type classes for stuff that they're not good at.
21:42:36 <mniip> (it still compiles though)
21:43:10 <edwardk> Foo a => a working there is a bug and should be fixed in HEAD or 7.10 i forget which
21:43:20 <edwardk> but it doesn't mean anything like what you want
21:43:45 <mniip> well
21:44:00 <hodapp> Cale: err, whaa?
21:44:10 <mniip> oh
21:44:22 <edwardk> mniip: you can make a class for 'decidable whatever' that decrees positively or negatively, but its purely a convention when it replies in the negative
21:44:25 <Cale> hodapp: I'm joking
21:45:02 <quazimod1> Ok i think I'll just keep programmering to learn :D
21:45:29 <Cale> hodapp: In any case where you run into the problem where you'd like to do one thing if a type is a member of some type class, and another thing if it's not, then the class in question should probably not be a class.
21:45:31 <mniip> edwardk, it comes from the age old dilemma of show'ing a value of any type
21:45:54 <edwardk> mniip: which is resolved by the age old solution of 'stop doing that' ;)
21:45:55 <mniip> all solutions I've seen out there require re-enumerating types that are instances of Show
21:46:16 <edwardk> as they must
21:46:28 <mniip> well yeah
21:46:42 <mniip> there's a problem with introduction of new instances
21:47:57 <mniip> you could have a file attempt to show a value with no show instance
21:48:13 <mniip> whichever way, it would be routed to the "default" implementation
21:48:32 <mniip> now if that file gets compiled, and a different file adds an instance of Show for that type
21:49:29 <quazimod1> does parseOnly use bytestring rather than [char] because it's faster?
21:49:44 * hackagebot exherbo-cabal 0.1.0.1 - Exheres generator for cabal packages  http://hackage.haskell.org/package/exherbo-cabal-0.1.0.1 (NikolayOrlyuk)
21:50:16 <Cale> quazimod1: From attoparsec?
21:50:47 <Cale> quazimod1: Attoparsec is geared toward quickly parsing binary formats, so it's both faster and more appropriate to use ByteString for that.
21:51:17 <Cale> If you want a parser for text, Parsec itself might be better suited.
21:54:44 <quazimod1> oh
21:54:44 * hackagebot hscuid 1.2.0.0 - Collision-resistant IDs  http://hackage.haskell.org/package/hscuid-1.2.0.0 (DanielBuckmaster)
21:54:46 <quazimod1> right
21:54:50 <quazimod1> hrm
21:54:52 <quazimod1> parsing binary
21:56:33 <creicher`> what are you trying to parse?
21:57:50 <quazimod1> ByteString
21:57:51 <edwardk> mniip: that would be the open world assumption in question, yes =)
21:57:54 <quazimod1> i mean
21:57:55 <quazimod1> https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/attoparsec
21:58:02 <quazimod1> that's what i'm reading/doing
22:01:59 <quazimod1> MY PROGRAM WORKS!
22:02:06 <quazimod1> I AM THE GOD OF HASKELL
22:02:08 <adarqui> hi, anyone know why they use a type family in Data.Either to compare equality of either's? type family EqEither a b where
22:02:15 <creicher`> quazimod1: awesome
22:02:33 <adarqui> then they have: type instance a == b = EqEither a b
22:02:41 <awoserra> omg i'm learning more language than logic ><
22:03:18 <awoserra> WHYYYY!!!!!???????
22:03:29 <awoserra> hehehe sry *ahem*
22:03:53 <bergmark> adarqui: they derive Eq for Either, and the source has a comment: -- instance for the == Boolean type-level equality operator
22:04:11 <quazimod1> Cale: thank you for all your help :D
22:04:38 <bergmark> adarqui: with emphasis on "type-level equality" :-)
22:04:42 <quazimod1> bbl
22:05:10 <awoserra> "imperative programming (necessary programming)" ...
22:05:21 <awoserra> what would be the opposite of that?
22:05:26 <awoserra> 0
22:05:49 <awoserra> ... so much terminology ><
22:06:28 <adarqui> bergmark: thnx i have to readup on typ families
22:06:32 <adarqui> and stuff
22:06:48 <awoserra> declarative programming i guess... which is really not actually programming...
22:07:33 <slack1256> I've doing some VHDL. The dataflow paradigm is an inspiration to frp or is not?
22:07:37 <awoserra> why don't we all just know assembly?
22:10:00 <awoserra> hehe 1 person in #assembly on freenode.
22:10:35 <awoserra> <--
22:19:34 <bergmark> awoserra: i think that means everybody else knows assembly
22:19:48 <awoserra> sure they do :)
22:20:00 <awoserra> heheh
22:20:27 <nocturne777> would I run into issues if I use ghc 7.10.0 in my project?
22:20:55 <bergmark> nocturne777: do you mean dependency-wise?
22:20:58 <nocturne777> I mean, would it cause breake with my libraries like aeson and snap
22:21:07 <nocturne777> bergmark: yeap
22:21:18 <bergmark> nocturne777: most active libraries have been updated by now, aeson and snap are definitely ok
22:24:28 <lpsmith> ok,  why did this even compile in GHC 7.6.3, the old way?
22:24:32 <lpsmith> https://github.com/srijs/postgresql-simple/commit/19537300eb93afe186b2966b8224d64a76a6e098
22:25:01 <bergmark> lpsmith: :-o
22:25:16 <lpsmith> yeah
22:25:31 <creichert> interesting
22:26:02 <bergmark> but not on GHC > 7.6?
22:26:28 <lpsmith> at first I was thinking I had made a git error,  testing a compilation against something not in the repo on my local machine,  but then I noticed that Travis CI never spit out an error either.
22:26:40 <lpsmith> bergmark, no,  not on GHC > 7.6
22:26:52 <bergmark> the answer is bound to be in the ghc commit history ;-)
22:27:00 <lpsmith> lol
22:27:10 <lpsmith> yeah,  smells like a rather shocking GHC bug
22:27:20 <lpsmith> even if it's _probably_ pretty benign
22:27:57 <lpsmith> So anyway,  I was just about losing my mind until I wiped my local dist/ directory,  and recompiled with GHC-7.6.3
22:29:38 <ttt_fff> is cloudhaskell the starte of the art for "accessing the entire cluster/cloud as a single haskell monad" ?
22:30:05 <lpsmith> lol,  it might be the starte of the arte.  
22:31:41 <awoserra> why doesn't anyone ever make flowcharts for their code in doc?
22:31:42 <slack1256> ttt_fff: is that the objective? I thought it was making OTP for haskell but typed
22:32:02 <ttt_fff> oh
22:32:03 <ttt_fff> hmm
22:32:16 <ttt_fff> isn't write one program, control an entire cluster cooler than typed OTP ?
22:32:30 <awoserra> FLOWCHARTS NOW!
22:32:49 <slack1256> I don't know, maybe it is. But sounds like magic
22:33:07 <slack1256> awoserra: there is and app, err program for that, let me recall the name
22:33:07 * awoserra will have to read 1000 text references to get the scope of one flowchart ><
22:33:17 <awoserra> i've seen it, it's junk
22:33:31 <slack1256> awoserra: oh graphmod!
22:33:34 <awoserra> why not just do it in development? release in in doc/man
22:33:35 <slack1256> it is nice
22:34:15 <slack1256> ttt_fff: I like the idea of fault tolerants systems more than distcc but for general code
22:34:34 <awoserra> why have to reverse engineer code to get logic?
22:35:01 <awoserra> when clearly the logic came before the code in the first place.
22:35:30 <awoserra> i tell ya, what passes for documentation anymore 
22:35:31 <slack1256> and the logic is cleary express as diagrams right?
22:35:31 <awoserra> ...
22:35:48 <slack1256> *expressed
22:35:48 <awoserra> yes :)
22:35:49 <ttt_fff> waht is distcc ?
22:36:07 <awoserra> computer logic flowcharts quite nicely actually.
22:36:12 <ttt_fff> awoserra: I read your nick, and I see aws***** and I get confused
22:36:15 <awoserra> && language independent.
22:36:26 <slack1256> oh really? have you read VHDL?
22:36:28 <ttt_fff> slack1256: similarly, your nick reminds me of slack the startup, which is trying to repalce irc (and succeeding)
22:36:48 <slack1256> oh, is was more on the spirit of SLACKware
22:36:54 <awoserra> slack1256: why is that logic that can't be logic flowcharted?
22:37:10 <slack1256> multiple logics
22:37:17 <slack1256> combinatorial logic yes
22:37:33 <slack1256> sequential logics less so
22:37:57 <slack1256> then you have systems more like graphs and non-directed nodes
22:38:00 <awoserra> if it goes through a cpu it can be sequentially flowcharted.
22:38:12 <awoserra> no?
22:38:30 <slack1256> and thinking like the cpu is transparent?
22:38:50 <awoserra> you can't answer a question with a question.
22:39:05 <awoserra> ... at least not and hold my attention at the same time.
22:39:07 <slack1256> or can you? (pun)
22:39:26 <slack1256> let cpu think like cpu likely do, do as humans do.
22:39:35 <awoserra> bah
22:39:46 <slack1256> also even if x86 promises some order
22:39:49 <awoserra> flowcharts are good teaching tools
22:39:58 <awoserra> they should be included in doc.
22:39:59 <slack1256> underneat it shuffles everything
22:41:03 <awoserra> obfuscation can remain in the domain of proprietary software.
22:41:08 <awoserra> useless as it is.
22:41:25 <slack1256> awoserra: I don't think anybody will be opossed to a pull request with a diagram on code
22:41:40 <slack1256> if It were me I would be glad
22:44:43 <slack1256> awoserra: but please don't do as Lens did. It got bad rap
22:46:06 <edwardk> ? because of putting the chart in the haddocks?
22:46:19 <awoserra> i'm not doing it... it's an easy request, but if these materials aren't already generated (and if they were, i imagine they would have shown up already)
22:46:47 <awoserra> then it's not gonna happen for a pull request across all the haskell platform
22:46:59 <slack1256> because it was too much upfront. The chart probably would have made more sense if it did something like gtk
22:47:06 <slack1256> although is a simpler chart
22:47:58 <edwardk> the chart is one of those things that i've gotten rave reactions both in favor and wildly against it, so i've kind of let them cancel each other out =P
22:47:59 <nocturne777> I don't understand this: https://hackage.haskell.org/package/haskell-src-meta-0.6.0.9/haskell-src-meta.cabal
22:48:33 <slack1256> edwardk: oh surely, is great reference material. It isn't that good learning material
22:48:50 <nocturne777> it says it's tested with 7.10, whereas syb  < 0.5 is not compatible with 7.10
22:48:52 <awoserra> i can't speak for anyone else, but for my style of learning - it's very helpful
22:48:58 <gamegoblin> Why isn’t the type of deleteBy (a -> b -> Bool) -> a -> [b] -> [b] ? Seems like it would be more general and more useful…
22:49:01 <gamegoblin> :t deleteBy
22:49:02 <lambdabot> (a -> a -> Bool) -> a -> [a] -> [a]
22:49:52 <edwardk> because deleteBy is kinda silly and probably should just be filter anyways =)
22:50:24 <edwardk> but in seriousness there isn't a good reason
22:50:40 <gamegoblin> edwardk: deleteBy only deletes the first occurence, so they differ in functionality
22:50:47 <edwardk> gamegoblin: fair
22:51:33 <slack1256> @src deleteBy
22:51:33 <lambdabot> deleteBy eq x []     = []
22:51:33 <lambdabot> deleteBy eq x (y:ys) = if x `eq` y then ys else y : deleteBy eq x ys
22:51:56 <gamegoblin> Wonder if I can submit a change? Since it’s just making the type more general it shouldn’t break anything depending on it…
22:52:15 <edwardk> sure, send the proposal to the libraries@ mailing list
22:52:21 <edwardk> it seems like a fairly straightforward change
22:53:13 <gamegoblin> In the mean time, I have a list like [(a,b)] and I want to delete the first element such that ((==x) . fst) is True
22:53:25 <gamegoblin> (that is, I have a key-value list and I want to remove the first element for a specific key)
22:53:30 <gamegoblin> elegant workarounds anyone?
22:53:51 <gamegoblin> I can always code a two-liner, but I was wondering if there were any combinations of prelude functions that’d do it just as well
22:54:35 <edwardk> you can always use break or span, map over the second half of the pair 'drop 1' and then ++ them back together
22:54:36 <quazimodo> https://gist.github.com/siassaj/0940fb6615858232f54c
22:54:45 <quazimodo> why doesn't line 2 work?
22:55:16 <edwardk> it is equivalent to: print $ \y -> parseOnly parseIP (pack x y)
22:55:20 <quazimodo> wait
22:55:22 <quazimodo> i'm dubmb
22:55:23 <quazimodo> i get it
22:55:32 <slack1256> print . parseOnly parseIP $ pack x
22:55:34 <slack1256> would work
22:55:35 <edwardk> print . parseOnly parseIP $ pack x -- would work
22:55:37 <edwardk> yeah
22:55:49 <quazimodo> the $ just means
22:55:52 <quazimodo> do the pack x
22:55:54 <quazimodo> right 
22:56:04 <pavonia> print . parseOnly parseIP . pack $ x
22:56:06 <edwardk> f $ x = f x    its used to replace a pair of parens usually
22:56:10 <quazimodo> same as parseOnly parseIp (pack x)
22:56:11 <quazimodo> yes?
22:56:43 <slack1256> (print . parseOnly parseIP) (pack x) -- more explicit
22:56:52 <edwardk> foo (bar (baz (quux quaffle))) = foo $ bar $ baz $ quux quaffle = foo . bar . baz $ quux quaffle
22:57:31 <quazimodo> :D
22:57:48 <quazimodo> i get it :)
22:57:55 <bergmark> in my head i inline it as f $ x = (f) (x)
22:58:49 <gamegoblin> edwardk: Could you forsee any issues with regard to equality commutitivity with that deleteBy change?
22:59:13 <edwardk> commutativity was already not required by the definition, etc.
22:59:14 <gamegoblin> I don’t think so, just curious if I missed something
22:59:49 <edwardk> so i don't foresee anything beyond some random complaining from folks about 'weakening what it means' or something
23:00:49 <scutigera> yeah- i really don't like the change because it weakens what it means.
23:00:53 <scutigera> ;-)
23:01:42 <edwardk> ^- see =)
23:02:44 <gamegoblin> I’m also kind of puzzled that the definition wasn’t just (a -> Bool) -> [a] -> [a] to begin with
23:02:50 <gamegoblin> Delete the first element that satisfies the predicate
23:03:05 <edwardk> the fooBy combinators follow a pattern
23:03:08 <edwardk> :t delete
23:03:09 <lambdabot> Eq a => a -> [a] -> [a]
23:03:12 <edwardk> :t deleteBy
23:03:12 <lambdabot> (a -> a -> Bool) -> a -> [a] -> [a]
23:03:17 <edwardk> :t sort
23:03:17 <lambdabot> Ord a => [a] -> [a]
23:03:19 <edwardk> :t sortBy
23:03:19 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
23:03:27 <gamegoblin> Mmm gotcha
23:03:32 <edwardk> :t nubBy
23:03:33 <lambdabot> (a -> a -> Bool) -> [a] -> [a]
23:04:10 <gamegoblin> @pl \a (b, _) -> a == b
23:04:10 <lambdabot> (`ap` snd) . (. fst) . (const .) . (==)
23:04:26 <gamegoblin> I love PL sometimes
23:05:08 <Rotaerk_> is it ever actually useful?
23:05:22 <Rotaerk_> never seems to produce a particularly... readable expression
23:05:41 <scutigera> eeeeuw
23:05:51 <edwardk> for one argument it can be readable some times
23:05:52 <scutigera> is that how you spell eeeeuw ?
23:06:00 <gamegoblin> I like to ask it what it thinks because 1/20 times it comes up with something I didn’t think of
23:06:15 <gamegoblin> Or it knows about some function I didn’t know about
23:06:16 <scutigera> the magic 8 ball of haskell ?
23:06:29 <gamegoblin> I learn a lot about Arrow from PL
23:06:36 <edwardk> i use it like hlint, get the drunken undergraduate to take a look at my code and see if it can come up with something worth listening to
23:08:31 <scutigera> i are confused about using takeWhile vs takeWhile1
23:08:43 <gamegoblin> scutigera: what about it?
23:09:03 <Rotaerk_> :t takeWhile
23:09:04 <lambdabot> (a -> Bool) -> [a] -> [a]
23:09:05 <Rotaerk_> :t takeWhile1
23:09:06 <lambdabot>     Not in scope: ‘takeWhile1’
23:09:07 <lambdabot>     Perhaps you meant one of these:
23:09:07 <lambdabot>       ‘takeWhile’ (imported from Data.List),
23:09:19 <scutigera> right- but takeWhile can cause infinite loops with many
23:09:26 <gamegoblin> scutigera: do you mean the parser combinators?
23:09:31 <kqr> scutigera, takeWhile (=='x') "abc" = []
23:09:33 <scutigera> oh- yes 
23:09:41 <gamegoblin> What’s confusing you about them?
23:09:46 <scutigera> yes i'm attoparsec'ing
23:09:47 * hackagebot digitalocean-kzs 0.1.0.0 - digitalocean api for haskell  http://hackage.haskell.org/package/digitalocean-kzs-0.1.0.0 (KazumaSATO)
23:09:49 <kqr> scutigera, takeWhile1 (=='x') "abc" = error "expected 'x', got 'a'"
23:09:56 <gamegoblin> takeWhile never fails. takeWhile1 will fail unless it succeeds at least once.
23:10:18 <gamegoblin> similar to many vs many1, or * vs + in regex parlance.
23:10:35 <scutigera> oh ic i think
23:10:40 <scutigera> so if you use many with *
23:10:49 <scutigera> you can match 0 characters many times
23:10:51 <scutigera> oops
23:11:19 <gamegoblin> If you do something like many (many p)
23:11:23 <gamegoblin> you will get an infinite loop
23:11:38 <gamegoblin> because the inner-many never fails, thus the outer-many never fails
23:11:41 <scutigera> right because matching 0 chars "succeeds"
23:11:49 <gamegoblin> same for takeWhile
23:11:53 <scutigera> is that the idea ?
23:11:57 <gamegoblin> yes
23:13:18 <scutigera> is takeWhile the right thing to use if i'm throwing away the match
23:13:32 <scutigera> so for example i want to match comments so i don't want to return anything
23:13:46 <gamegoblin> scutigera: paste the full line of code
23:13:50 <scutigera> oh- like maybe skipWhile ?
23:13:50 <kqr> depends on whether or not you want no match to count as success
23:14:02 <kqr> skipWhile is great for ignoring stuff
23:14:04 <scutigera> '! .* \n
23:14:26 <scutigera> that's what i want to match- but i don't need to return the string
23:14:33 <scutigera> '!' .* \n
23:15:19 <scutigera> skipSpace <* char '!' <* skipWhile (/= '\n') <* endOfLine
23:16:01 <gamegoblin> scutigera: that would work. Why <* ? Just curious.
23:16:23 <scutigera> uh- i just realized i've forgotten the distinction between <* and *>
23:16:24 <gamegoblin> >> reads a bit easier to me, but that’s monadic and not applicative. Not really an issue either way.
23:16:28 <gamegoblin> scutigera: they both work
23:16:38 <scutigera> i'm trying to figure out which to use when...
23:16:40 <gamegoblin> scutigera: if you are ignoring the result ;)
23:16:51 <gamegoblin> a <* b is "do a, then b, but return a"
23:17:00 <gamegoblin> a *> b is "do a, then b, and return b"
23:17:20 <gamegoblin> but if you are ignoring the result, it doesn’t matter what’s returned!
23:17:31 <scutigera> *> exactly
23:17:36 <gamegoblin> I tend to ise >> there because it’s more explicit that I’m ignoring the result
23:17:39 <gamegoblin> use*
23:17:39 <scutigera> well actually i return Comment
23:17:53 <gamegoblin> but >> is monadic and *> are just functoral 
23:18:03 <gamegoblin> sometimes one can be more efficient than the other, I guess
23:18:23 <scutigera> now when you say >> you mean as in do block, right ?
23:18:42 <kqr> char '!' >> skipWhile (/= '\n') >> endOfLine
23:18:50 <gamegoblin> scutigera: no, your previous thing could have been written as skipSpace >> char '!' >> skipWhile (/= '\n') >> endOfLine
23:18:52 <kqr> but you could use a do block as well
23:18:57 <gamegoblin> and it would consume the exact same input
23:19:11 <kqr> do { char '!'; skipWhile (/= '\n'); endOfLine }
23:19:16 <scutigera> oh right. monadic is applicative but not vicey-vercey
23:19:18 <gamegoblin> alternatively you could use a do-block and just not bind any of those to variables
23:19:21 <gamegoblin> and it would be the same thing
23:19:35 <scutigera> yeah- i'm actually writing things in all those different ways. lol.
23:19:35 <gamegoblin> like what kqr just did
23:19:45 <gamegoblin> doing
23:19:46 <scutigera> just to see that they do in factwork they way i think.
23:19:47 <gamegoblin> do
23:19:48 <gamegoblin> foo
23:19:48 <gamegoblin> bar
23:19:52 <gamegoblin> is the same as foo >> bar
23:20:06 <scutigera> so if i wanted to keep the text
23:20:10 <scutigera> skipSpace
23:20:13 <scutigera> char '#'
23:20:27 <scutigera> foo <- takeWhile (/= '\n')
23:20:32 <scutigera> endOfLine
23:20:39 <scutigera> return foo
23:20:42 <gamegoblin> exactly
23:20:51 <scutigera> OR....
23:20:57 <kqr> or    skipSpace *> char '#' *> takeWhile (/= '\n') <* endOfLine
23:21:02 <scutigera> yes!
23:21:04 <gamegoblin> Correct
23:21:08 <scutigera> i knew that!
23:21:09 <scutigera> lol
23:21:10 <gamegoblin> or you could mix and match
23:21:11 <kqr> mnemonic: arrows point toward the thing you want to keep
23:21:13 <scutigera> amazing!!
23:21:25 <gamegoblin> you could change the last 3 lines to just takeWhile (/= '\n') <* endOfLine
23:21:30 <kqr> I guess they kinda look like birds
23:21:32 <gamegoblin> and keep the other stuff in do-notation
23:21:36 <gamegoblin> go crazy
23:21:47 <scutigera> haha
23:21:53 <scutigera> oh- i'm going crazy alright
23:22:55 <Cale> Or, skipSpace >> char '#' >> takeWhile (/= '\n') >>= \foo -> endOfLine >> return foo  (but there's not much reason to choose that notation over do-notation)
23:23:41 <gamegoblin> I personally use do-notation because it’s the easiest to read, even if I could use applicative
23:23:50 <gamegoblin> applicative-do would be great
23:23:53 <neuroserpens> Cale: I dislike do notation. I can understand that much more easily and also find it to be much more beautiful.
23:24:01 <gamegoblin> but it’s not here yet
23:24:21 <Cale> neuroserpens: I always find it unusual when people say that :)
23:24:24 <gamegoblin> I think do-notation is one of the best features of haskell
23:24:26 <Cale> neuroserpens: But sure
23:24:41 <gamegoblin> Using parser-combinators in any other language is a mess without do-notation
23:24:47 <scutigera> i too find the do-notation to be really nice to read for the attoparsec stuff
23:25:02 <scutigera> especially if you start saving intermediate results in the line you are parsing
23:25:33 <gamegoblin> In a language like Rust you wind up with let foo = try!(bar) all over the place
23:25:43 <gamegoblin> whereas in Haskell it’d just be foo <- barr inside of an Either monadic do block
23:25:48 <gamegoblin> so much prettier
23:27:35 <gamegoblin> As soon as I really grokked monads with regard to all of their common instances (lists, maybes, eithers, etc) my code got so much cleaner
23:27:39 <scutigera> hmmmm.. where's Text hiding ?
23:27:49 <scutigera> i have import Data.Attoparsec.Text.Lazy
23:27:51 <gamegoblin> no more 3-layer deep case statements for unwrapped a bunch of Maybes, etc
23:28:11 <gamegoblin> scutigera: are you looking for Data.Text?
23:28:12 <scutigera> but ghc can't find Text
23:28:13 <gamegoblin> Or what?
23:28:52 <scutigera> yes
23:28:53 <gamegoblin> There is also Data.Text.Lazy that you might want
23:30:26 <scutigera> import qualified Data.Text.Lazy
23:30:29 <scutigera> if i do that 
23:30:48 <scutigera> do i have to say Data.Text.Lazy.<name> to access anything in the module
23:30:50 <scutigera> ?
23:32:12 <magneticDuck> yes
23:32:33 <magneticDuck> import qualified Data.Text.Lazy as Lazy lets you access them with "Lazt.<name>"
23:32:44 <magneticDuck> (the "as Lazy" is part of the import)
23:33:01 <gamegoblin> scutigera: yes, usually I’d do something like import qualified Data.Text.Lazy as LT
23:33:03 <scutigera> yes- but what happens if you leave off as Lazy
23:33:07 <gamegoblin> scutigera: then you can do LT.Text 
23:33:18 <gamegoblin> scutigera: dunno, never tried :P
23:33:31 <scutigera> yeah- i should just try intstead of asking ...
23:34:28 <scutigera> yep that's what happens
23:34:40 <scutigera> import qualified Data.Text
23:34:48 <scutigera> => Data.Text.Text
23:35:01 <scutigera> lol. there's a good reason why nobody does that...
23:36:53 <scutigera> aha now i'm gonna get all in trouble...
23:37:16 <scutigera> [0-9]+(\.[0-9]+)?
23:39:27 <scutigera> takeWhile1 <digit> ... ?
23:39:48 <gamegoblin> do
23:39:52 <gamegoblin> takeWhile1 isDigit
23:40:13 <gamegoblin> well
23:40:13 <gamegoblin> first
23:40:18 <gamegoblin> do you want to keep everything?
23:40:23 <scutigera> yep
23:40:26 <gamegoblin> k
23:40:30 <gamegoblin> are you using attoparsec?
23:40:36 <scutigera> yes.
23:41:16 <kqr> is "13.abc" a valid parse that means something else?
23:41:30 <gamegoblin> match (takeWhile1 isDigit >> optional (char8 '.' >> takeWhile1 isDigit))
23:41:33 <gamegoblin> that will do it
23:41:51 <kqr> otherwise you can assume that if a number is followed by a '.' it signifies the start of the second number sequecne
23:41:54 <gamegoblin> attoparsec’s "match" parser is great here
23:42:04 <scutigera> kqr: not valid. trying to recognize a line of numbers separated by whitespace
23:42:13 <gamegoblin> scutigera: see my code I just did
23:42:28 <scutigera> gamegoblin: processing....
23:42:30 <scutigera> :-)
23:42:45 <gamegoblin> the "match" parser takes another parser and returns all the text it consumed
23:42:52 <gamegoblin> so the parser inside the parens doesn’t have to store anything
23:43:08 <gamegoblin> One of the most useful features of attoparsec imo
23:43:18 <gamegoblin> just came in attoparsec 3 
23:43:20 <kqr> gamegoblin, could you explain a bit more? not sure I understand
23:43:29 <scutigera> i think you meant "option" instead of "optional", right ?
23:43:29 <gamegoblin> kqr: which part?
23:43:44 <kqr> gamegoblin, mainly the "inside the parens doesn't have to store anything" part
23:43:45 <edwardk> gamegoblin: it was something I pushed hard in trifecta. glad to see it come into other parsers =)
23:43:57 <gamegoblin> kqr: optional from the Control.Applicative package
23:44:03 <gamegoblin> option works too
23:44:04 <scutigera> aargh
23:44:30 <arahael> I assume that "12.abc" _is_ valid according to scutigera's regexp.
23:44:31 <gamegoblin> option is actually a little different
23:44:35 <gamegoblin> optional is what I want
23:44:48 <gamegoblin> arahael: how do you figure?
23:44:48 * hackagebot promises 0 - Lazy demand-driven promises  http://hackage.haskell.org/package/promises-0 (EdwardKmett)
23:44:51 <scutigera> arahael: no that's not valid
23:44:53 <arahael> scutigera: It should match "12.".
23:45:02 <kqr> gamegoblin, the regex didn't end with $
23:45:12 <scutigera> oh crap. yeah it should match 12.
23:45:13 <arahael> scutigera: (Or more specifically, "12", since the dot is part of the second group, which is optional)
23:45:17 <scutigera> so my regexp is wrong
23:45:28 <kqr> gamegoblin, but please keep going about the not having to store anything
23:45:30 <kqr> gamegoblin, if you mind
23:45:44 <kqr> if you don't mind*
23:46:02 <gamegoblin> kqr: there’s not much to go on about. The chain of >> in the parens just consumes input without storing it anywhere. I give that chain to the "match" parser and it returns everything that the chain consumed.
23:46:05 <scutigera> [0-9](\.([0-9]*)?
23:46:24 <scutigera> there- that's better
23:46:27 <arahael> scutigera: I'm actually not completely familiar with haskell's regexps, but the first thing I usually do is determine how it handles end-of-line vs end-of-string (usually configurable).
23:46:32 <gamegoblin> scutigera: do you want [0-9]+ at the beginning?
23:46:39 <arahael> scutigera: So, that'll still match "12.abc".  Specifically, it now matches "1".
23:46:40 <scutigera> [0-9]+(\.([0-9]*)?
23:46:45 <gamegoblin> or maybe [0-9]* 
23:46:46 <gamegoblin> depending on if you want to match .123
23:46:54 <gamegoblin> or if you want to force 0.123
23:47:01 <scutigera> well eventually it has to matcha full real with E and everything
23:47:03 <gamegoblin> some languages go one way or the other
23:47:04 <scutigera> but baby steps
23:47:05 <kqr> gamegoblin, could you not just takeWhile1 isDigit <*> optional (char8 '.' <*> takeWhile1 isDigit)?
23:48:22 <kqr> gamegoblin, possibly that goes wrong with the types but meh
23:48:35 <gamegoblin> kqr: you are right, it does go wrong with types
23:48:37 <kqr> I guess match is easier than fixing that
23:48:42 <gamegoblin> exactly
23:48:56 <gamegoblin> takeWhile returns ByteString, optional returns Maybe, char8 returns Char, etc
23:48:58 <gamegoblin> craziness
23:49:00 <gamegoblin> match makes it all easy
23:49:04 <kqr> lol
23:49:11 <kqr> yeah I understand
23:49:27 <unknownloner> foldl vs foldl' vs foldr, which should I use if I don't really care about the order
23:50:00 <arahael> unknownloner: Any of them?
23:50:01 <gamegoblin> unknownloner: you will usually prefer foldl’ to foldl for memory reasons, iirc
23:50:12 <arahael> unknownloner: They're always order-preserving, iirc?
23:50:16 <kqr> unknownloner, foldr if your sequence is (potentially) infinite, foldl' otherwise
23:50:20 <gamegoblin> At least that’s sthe rule-of-thumb
23:50:26 <unknownloner> alright
23:50:45 <kqr> foldr lets you produce results before it's consumed the entire sequence
23:50:58 <arahael> But it's _still_ order preserving, surely?
23:51:01 <unknownloner> > foldl (+) 0 [0..]
23:51:02 <kqr> which is nice and composable but doesn't always give you the best performance (I think?)
23:51:03 * arahael is misisng something?
23:51:06 <lambdabot>  mueval-core: Time limit exceeded
23:51:06 <lambdabot>  mueval: ExitFailure 1
23:51:08 <unknownloner> > foldr (+) 0 [0..]
23:51:10 <lambdabot>  *Exception: stack overflow
23:51:14 <unknownloner> I see
23:51:51 <unknownloner> arahael: the question basically was I could use foldl or foldr, which would be more effecient
23:51:52 <scutigera> gamegoblin: looks like your version doesn't match 999
23:52:02 <scutigera> doh
23:52:06 <scutigera> scratch that
23:52:18 <kqr> > foldr (\x xs -> succ x : xs) [] [1..]
23:52:20 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
23:52:21 <gamegoblin> scutigera: yes it does :)
23:52:24 <gamegoblin> heh
23:52:33 <unknownloner> oh right because + needs everything anyways
23:52:36 <kqr> yes
23:52:39 <unknownloner> which is why it stack overflowed
23:52:41 <arahael> unknownloner: Ah, so the 'order' aspect was irrelevant to the question?
23:53:25 <scutigera> gamegoblin: what's a one-liner to test that on a string ?
23:53:36 <gamegoblin> scutigera: what do you mean?
23:54:00 <scutigera> something like: putStrLn $ parse aNumber "999"
23:54:58 <gamegoblin> scutigera: attoparsec has a convenient function called parseTest
23:54:59 <arahael> scutigera: Be prepared to expect pain if you want to test the roundtrip.
23:55:07 <gamegoblin> :t Data.Attoparsec.ByteString.parseTest
23:55:08 <lambdabot> Show a => attoparsec-0.12.1.3:Data.Attoparsec.ByteString.Internal.Parser a -> BSC.ByteString -> IO ()
23:55:17 <gamegoblin> it takes a parser, a bytestring, and prints the result to stdout
23:55:33 <gamegoblin> parseTest myParser "hello world" 
23:55:35 <gamegoblin> etc
23:55:48 <scutigera> parseTest aNumber $ pack "999"
23:55:51 <gamegoblin> make sure you use overloaded strings or otherwise pack that string though
23:55:52 <scutigera> does the trick
23:55:55 <gamegoblin> that’ll work
23:56:18 <arahael> That reminds me. How do I use overloaded strings in cabal's repl?
23:56:35 <gamegoblin> arahael: in GHCI?
23:56:39 <arahael> gamegoblin: Yes.
23:56:53 <Geekingfrog> :set -X...
23:57:31 <arahael> Geekingfrog: Ah, so it has a different syntax.
23:58:28 <kqr> heh
23:58:33 <kqr> you should have been there 10 years ago
23:58:38 <kqr> when ghci barely could do anything
23:58:53 <kqr> and the few things it could do had really weird syntax
23:58:57 <arahael> I'd have probably given up bothering with haskell. :)
23:59:13 <scutigera> Done "." ("999",Nothing)
23:59:13 <scutigera>  
23:59:26 <scutigera> shouldn't i be getting "999." ?
23:59:31 <ttt_fff_> back in the day, we didn't even have typeclasses, and we wrote code that way
23:59:41 <gamegoblin> scutigera: what is your parser code
23:59:47 <scutigera> i used to write code uphill in the snow both ways
23:59:53 <ttt_fff_> back in the day, all we had were monads
23:59:55 <scutigera> match $ takeWhile1 isDigit >> optional (char '.' >> takeWhile1 isDigit)
