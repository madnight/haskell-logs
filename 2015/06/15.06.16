00:00:02 <terrelln> It should be able to parse that
00:00:05 <Cale> > show "hello world"
00:00:07 <lambdabot>  "\"hello world\""
00:00:11 <Cale> > show "hello \ world"
00:00:12 <lambdabot>  <hint>:1:15:
00:00:12 <lambdabot>      lexical error in string/character literal at character 'w'
00:00:14 <Cale> > show "hello \\ world"
00:00:16 <lambdabot>  "\"hello \\\\ world\""
00:00:25 <Cale> > read "\"hello \\\\ world\""
00:00:26 <lambdabot>  *Exception: Prelude.read: no parse
00:00:30 <Cale> > read "\"hello \\\\ world\"" :: String
00:00:32 <lambdabot>  "hello \\ world"
00:00:40 <Cale> > text (read "\"hello \\\\ world\"" :: String)
00:00:41 <lambdabot>  hello \ world
00:00:49 <terrelln> > read (show "hello \ world") :: String
00:00:50 <lambdabot>  <hint>:1:21:
00:00:51 <lambdabot>      lexical error in string/character literal at character 'w'
00:01:15 <Cale> Yeah, the problem is that "show \ world" is not a valid string literal
00:01:27 <Cale> because '\ ' isn't a valid escape sequence
00:01:59 <haasn> > read (show "hello \ \world") :: String
00:02:01 <lambdabot>  "hello world"
00:02:16 <Cale> heh
00:02:20 <Cale> nice string gap :)
00:02:28 <martinvlk> oh, so it looks like the parse which shows \\ is correct, you just need to "show" it?
00:03:02 <haasn> > text "hello \\ world" -- think for a moment about what this string actually represents, not how its source code looks
00:03:04 <lambdabot>  hello \ world
00:03:17 <haasn> (text is a handy way of getting lambdabot to print the actual string contents)
00:03:39 <haasn> > text "\"hello \\\\ world\""
00:03:39 * hackagebot monad-skeleton 0.1.2.1 - An undead monad  http://hackage.haskell.org/package/monad-skeleton-0.1.2.1 (FumiakiKinoshita)
00:03:40 <lambdabot>  "hello \\ world"
00:03:47 <terrelln> Yeah, damn escaping, gets me every time
00:04:00 <haasn> (Or locally, you can just use putStrLn)
00:04:16 <haasn> Yes, the default behavior of lambdabot, GHCI etc. to ‘show’ the output (even if it's a string) can be really confusing if you're not used to it
00:04:58 <martinvlk> text "hello \\ world"
00:05:18 <martinvlk> text ("hello \\ world")
00:05:27 <alisia> terrelln, I got this error when I tried it. "No instance for (HasSpock IO) arising from a use of `runQuery'"
00:06:15 <alisia> terrelln, http://lpaste.net/134573
00:06:38 <alisia> terrelln,      addUser ::  u -> Connection -> IO Int64
00:07:19 <martinvlk>  text "hi"
00:07:40 <terrelln> Does the signature for runQuery look something like: runQuery:: HasSpock m => (SpockCon m -> IO a) -> m a
00:07:45 <martinvlk> text "hi" :: String
00:08:41 <terrelln> If so, you need to run it in a monad that is an instance of HasSpock, which should be provided by the library.
00:38:36 <liste> martinvlk you need the >
00:40:33 <martinvlk> > text "like that?"
00:40:35 <lambdabot>  like that?
00:40:42 <martinvlk> Ah yes :-) thanks a mil
00:43:42 * hackagebot wolf 0.1.0 - Amazon Simple Workflow Service Wrapper.  http://hackage.haskell.org/package/wolf-0.1.0 (markfine)
00:51:18 <mjrosenb> Does haskell have any libraries for 3d rendering to a file?
01:06:15 <martinvlk>  mjrosenb: did you find anything at Hackage?
01:06:15 <martinvlk>             https://hackage.haskell.org/packages/search?terms=3d+rendering
01:28:38 <liste> how do I get from [(a,[b])] to [(a,b)], duplicating 'a's?
01:33:37 <lyxia> > let xs = [(0, [True, False]), (1, [False, True])] in do { (a, bs) <- xs ; b <- bs ; return (a, b) }
01:33:39 <lambdabot>  [(0,True),(0,False),(1,False),(1,True)]
01:35:08 <dmwit> bitemyapp: That is probably a bad idea for types with a lot of inhabitonts. probably fine for smallish enums though
01:40:07 <predator117> > sequenceOf (traverse._2)  [(0, [True, False]), (1, [False, True])] -- note that there are additional inner lists
01:40:08 <lambdabot>  [[(0,True),(1,False)],[(0,True),(1,True)],[(0,False),(1,False)],[(0,False),(...
01:40:38 <predator117> not sure if that is what you want though
01:41:32 <dmwit> :t mapM
01:41:33 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
01:42:09 <dmwit> :t strength
01:42:10 <lambdabot> Not in scope: ‘strength’
01:42:52 <mjrosenb> martinvlk: I can't say that any of  the results look good.
01:44:46 <dmwit> ?let strength (a, fb) = (,) a <$> fb
01:44:47 <lambdabot>  Defined.
01:44:58 <dmwit> :t mapM strength
01:44:59 <lambdabot> (Monad m, Traversable t) => t (a, m b) -> m (t (a, b))
01:45:11 <martinvlk> mjrosenb: OK, I just wanted to point out Hackage as the (main) source of packages... don't know C3 libs myself
01:45:28 <martinvlk> sorry meant "3D" libs
01:46:16 <dmwit> > mapM strength [(0, [True, False]), (1, [False, True])]
01:46:18 <lambdabot>  [[(0,True),(1,False)],[(0,True),(1,True)],[(0,False),(1,False)],[(0,False),(...
01:46:49 <dmwit> oh
01:47:24 <dmwit> > [(0, [True, False]), (1, [False, True])] >>= strength
01:47:25 <lambdabot>  [(0,True),(0,False),(1,False),(1,True)]
01:48:45 * hackagebot notzero 0.0.1 - A data type for representing numeric values, except zero.  http://hackage.haskell.org/package/notzero-0.0.1 (TonyMorris)
01:50:36 <dmwit> never thought i'd see a problem where strength was actually a natural (part of the) solution
01:51:11 <merijn> dmwit: I keep running into uses for strenght once every 1 or 2 months, but I always forgot the definition of it by the time I need it again :p
01:51:19 <breadmonster> Hello.
01:51:20 <breadmonster> http://hackage.haskell.org/package/fb-1.0.11/docs/src/Facebook-Monad.html#FacebookT
01:51:45 <breadmonster> How the fuck do you derive Monad, MonadFix, MonadIO instances?
01:51:49 <breadmonster> o.O
01:52:05 <tdammers> hmm, does something like this exist already: class Delta a b where addDelta :: a -> b -> a; subtractDelta :: a -> b -> a; difference :: a -> a -> b
01:52:22 <lyxia> breadmonster: It's a newtype so you can reuse the definitions for the underlying ReaderT
01:52:35 <tdammers> conceptually, a pair of types where 'a' is a "point" on some dimension, and 'b' is a "distance" or "delta" in that dimension
01:52:41 <tdammers> e.g. point-in-time and timespan
01:52:48 <breadmonster> lyxia: Oh right okay.
01:52:51 <dmwit> merijn: you could always pull in the edward package for it and get a couple dozen other dependencies for free to save you writing one line of code =)
01:53:20 <dmwit> tdammers: code word for google is torsor
01:53:30 <tdammers> dmwit: thanks, will look
01:56:30 <alisia> how can I take 'conn' out from a value of type, SpockConn (ActionT (WebStateM conn t st))?
01:57:25 <tdammers> hmm, wikipedia isn't very helpful here
01:57:43 <tdammers> (not wikipedia's fault btw)
01:59:52 <dmwit> baez has an excellent discussion of torsors
02:00:11 <dmwit> but you already invented them
02:00:16 <tdammers> http://math.ucr.edu/home/baez/torsors.html <- this one?
02:00:26 <dmwit> so no real need to read much more
02:00:30 <dmwit> yes
02:00:35 <tdammers> ok
02:00:41 <tdammers> yeah, I just reinvented those
02:00:51 <tdammers> I just want to get the naming right
02:02:10 <tdammers> huh... "Or open your ears and listen - they also show up in music theory."
02:02:16 <tdammers> this is *exactly* my use case
02:02:19 <tdammers> pitches and intervals
02:02:40 <tdammers> and also, rhythmic positions and durations
02:03:27 <dmwit> right
02:03:43 <merijn> tdammers: What are you doing with music?
02:03:54 <tdammers> merijn: a rewrite of my sheet music processor
02:03:56 <dmwit> don't know of a standard location for this class, if that is the question
02:04:06 <tdammers> that was my very first real-world haskell project, and it shows
02:04:16 <merijn> tdammers: Ah, neat :)
02:04:17 <tdammers> so I'm going to rewrite it now that I have some basic Haskell down
02:04:30 <tdammers> (6 years later ;)
02:04:36 <dmwit> i thitk conal has one in his vector space library, but that might xe an odd dep. for a music theory lib.
02:04:48 <tdammers> haha yeah
02:05:03 <tdammers> I'm thinking of making it a tiny lib of its own
02:05:17 <dmwit> could be nice
02:05:17 <tdammers> providing only the Tensor typeclass and a bunch of instances for base types
02:05:39 <tdammers> so what would a good name/operator for the three operations be?
02:05:47 <dmwit> sond a patch to `time` for bonus points
02:05:56 <tdammers> ah yes
02:06:08 <tdammers> time is probably *the* thing needing this most direly
02:06:25 <tdammers> let tomorrow = now + oneDay
02:06:37 <tdammers> except not + but something else
02:06:59 <alisia> do anyone know how to get hold of a database connection inside a route handler in Spock web framework?
02:07:06 <dmwit> .-. and .+ maybe
02:07:16 <tdammers> well, yeah, been thinking about those
02:07:23 <tdammers> I do need two - operators though
02:07:30 <tdammers> a -> a -> b and a -> b -> a
02:07:32 <dmwit> .'s go on the side that has a group element
02:07:42 <tdammers> that makes sense
02:07:56 <tdammers> so .-. and .-
02:08:17 <dmwit> sure
02:09:32 <dmwit> so will you have a group class, too?
02:09:48 <tdammers> not sure, really
02:10:05 <tdammers> I was thinking more along the lines of just Torsor, as a 2-param typeclass
02:10:07 <dmwit> if so .- can be derived from .+ and invert
02:10:28 <tdammers> right
02:10:47 <tdammers> yeah, that makes sense
02:11:05 <tdammers> I was tentatively considering adding invert to the Tensor class itself, but that'd be wrong
02:11:26 <dmwit> well
02:11:29 <alisia> how can I take 'conn' out from a value of type, SpockConn (ActionT (WebStateM conn t st))?
02:11:41 <tdammers> maybe not wrong, but not very elegant either
02:11:53 <dmwit> it wouldn't match how mathematicians do it, anywa =)
02:11:59 <tdammers> hah
02:12:34 <tdammers> anyway, I wouldn't feel good about having a function b -> b in my multi-param typeclass
02:12:44 <dmwit> yeah
02:13:27 <dmwit> maybe modern ghc even rejects that straight out
02:13:47 <tdammers> you end up annotating your code with types for a, even though you're not relying on any particular a, but you have to tell the compiler anyway because it doesn't unify otherwise
02:13:55 <tdammers> unless you use type families or fundeps
02:14:38 <dmwit> good luck
02:14:58 <tdammers> hehe yeah, not going with the invert-as-part-of-Tensor
02:19:52 <breadmonster> what are fundeps?
02:21:16 <martinvlk> Hi, let' say I have some custom algebraic data type and I want to process a list of corresponding values, e.g. http://lpaste.net/134581. I can do that with a simple pattern matching function, but as the type is more complex the function definition gets really messy. What would be an idiomatic Haskell way to calculate say a sum of specific value from inside that data type?
02:22:09 <merijn> martinvlk: Neat trick, non-matching patterns in a list comprehension:
02:22:31 <merijn> > [x | Just x <- [Nothing, Just 'c', Nothing, Just 'a', Nothing, Just 'b']]
02:22:33 <lambdabot>  "cab"
02:23:05 <liste> :t catMaybes
02:23:06 <lambdabot> [Maybe a] -> [a]
02:23:20 <merijn> > [x | x@(Just 'c') <- [Nothing, Just 'c', Nothing, Just 'a', Nothing, Just 'b']] -- can even match on string/character literals
02:23:22 <lambdabot>  [Just 'c']
02:23:29 <merijn> liste: That doesn't work for arbitrary constructors
02:23:44 <merijn> liste: Specifically, it's useless in his original question
02:24:37 <martinvlk> merijn: thanks, let me try that now
02:24:39 <merijn> Whereas the solution to his problem is "sum [x | Appliance "boiler" x _ <- myList]"
02:24:45 <merijn> Or
02:25:19 <merijn> "\name -> sum [val | Appliance foo val _ <- myList, name == foo]"
02:26:00 <martinvlk> Great, I'll test this approach and report back..
02:26:59 <breadmonster> merijn: Wait, can I match more than one constructor?
02:27:34 <merijn> breadmonster: Not at the same time
02:28:05 <martinvlk> I think I'll ahv eto have separate list comprehensions for specific constructor combinations
02:28:07 <breadmonster> Interesting.
02:28:07 <tdammers> if you need to match more than one ctor, I'd go with a more explicit approach, something like mapping a function that uses `case` for explicit pattern matching
02:28:28 <breadmonster> merijn: Umm, also, how do you do this in the List monad?
02:28:48 <tdammers> map f myList where f item = case item of { Foo x -> x; Bar _ y -> y }
02:28:51 <tdammers> sth like that
02:29:10 <breadmonster> > do { Just x <- [ Just 1, Just 2, Nothing]; return x }
02:29:11 <lambdabot>  [1,2]
02:29:20 <breadmonster> > do { Just x <- [ Just 1, Just 2, Nothing]; sum . return x }
02:29:21 <lambdabot>      Couldn't match expected type ‘[b]’ with actual type ‘a0 -> c0’
02:29:22 <lambdabot>      Relevant bindings include x :: t0 c0 (bound at <interactive>:1:11)
02:29:22 <lambdabot>      In a stmt of a 'do' block: sum . return x
02:29:25 <breadmonster> Oh right yeah.
02:31:48 <martinvlk> tdammers: that is getting as messy as my original "totalConsumptionPerMonth" function, see http://lpaste.net/134581
02:33:12 <martinvlk> to me it feels like maybe the approach with algebraic data type is not good for this type of problem?
02:33:44 <tdammers> I think the algebraic representation isn't bad, you just need to find a better place to separate your concerns and dispatch
02:34:37 <martinvlk> can you be more specific on separation of concerns in this case?
02:35:02 <merijn> martinvlk: Why do you have three lines of undefined at the bottom instead of capturing them with one catch all case?
02:35:09 <tdammers> "extract the interesting data from the data structure" is one concern
02:35:22 <merijn> martinvlk: i.e. "con (Appliance _ _ _) = undefined" ?
02:35:24 <martinvlk> mrinj: true... no reason
02:35:27 <tdammers> "calculate the actual consumption based on a unit-less rate and an interval specifier" is another
02:35:50 <martinvlk> aha!
02:35:54 <tdammers> also, since you don't expect anything but an empty list or a single-element list, why are you using a list in the first place?
02:35:56 <tdammers> why not Maybe?
02:36:34 <martinvlk> data structure is still in progress - I expect more items later
02:36:42 <tdammers> or, if there is another use case for the list, then how about fleshing out the [Usage] -> Maybe Usage thing into a separate function
02:36:45 <martinvlk> so I design with that in mind
02:37:04 <martinvlk> yeah, that would make it cleaner - let me see
02:37:12 <tdammers> alternatively, if you do want to support multiple usages, maybe you want to map over them instead and accumulate the results
02:37:26 <tdammers> or explicitly ignore any usages but the first ne
02:37:28 <tdammers> one*
02:37:54 <tdammers> one way or another, I'd try to make your function total ASAP
02:38:38 <tdammers> oh, and I think you want to also split it up into "calculate total consumption for all appliances" and "calculate consumption for one appliance"
02:38:46 <alisia> What does the tlide in  (HasSpock m, SpockConn m ~ SqlBackend) mean?
02:38:58 <liste> alisia type equality
02:39:07 <tdammers> i.e., `con` might be useful as a top-level function in its own right
02:39:17 <martinvlk> yeah.. then just use map and sum...
02:39:23 <tdammers> exactly
02:39:23 <alisia> liste, what does it really mean?
02:39:37 <liste> that SpockConn m and SqlBackend are the same type
02:39:55 <tdammers> (in fact, your foldr call there is pretty much exactly sum . map con)
02:40:17 <martinvlk> true
02:40:35 <martinvlk> good stuff, I think I am starting to see the way!
02:40:43 <alisia> liste, ok. But why does it have to be made explict?
02:41:56 <alisia> liste, I mean, couldn't it be infered automatically?
02:42:36 <liste> alisia the 
02:42:56 <liste> code relies on that fact so it must be expressed in its type signature
02:43:43 <alisia> liste, I see..
02:44:36 <liste> SpockConn m could also be something else, and then functions relying on SpockConn m ̃̃~ SqlBackend wouldn't work
02:46:42 <lyxia> The compiler can't really tell when two types are supposed to be equal, 99% of the time if they don't look equal it's a mistake...
02:48:48 * hackagebot mono-traversable 0.9.2.1 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.9.2.1 (MichaelSnoyman)
02:55:04 <alisia> liste, how can SpockConn m could be something else? Do you mean it is like a type variable?
02:55:28 <liste> alisia welcome to the world of type families
02:56:27 <liste> @let type family Foo a :: *
02:56:28 <lambdabot>  Defined.
02:56:40 <liste> @let type instance F Int = String
02:56:40 <lambdabot>  .L.hs:149:15: Not in scope: type constructor or class ‘F’
02:56:45 <liste> @let type instance Foo Int = String
02:56:46 <lambdabot>  Defined.
02:56:54 <liste> @let type instance Foo String = Int
02:56:55 <lambdabot>  Defined.
02:57:01 <liste> :t Foo Int
02:57:02 <lambdabot> Not in scope: data constructor ‘Foo’
02:57:02 <lambdabot>     Not in scope: data constructor ‘Int’
02:57:02 <lambdabot>     Perhaps you meant one of these:
02:57:10 <liste> :kind Foo Int
02:57:47 <alisia> I am trying to make sense of the flow of things in Spock framework. I find it very very hard. Is this normal. Or am I just not cut for it?
02:58:36 <liste> alisia it has a lot of advanced concepts
02:59:31 <liste> just keep trying, it'll make sense eventually
03:00:41 <alisia> From the documentation I saw that I am supposed to run queries using the runQuery function, runQuery :: (SpockConn m -> IO a) -> m a
03:02:12 <martinvlk> alisia: Haskell uses advanced stuff, in my experience you need to learn basics properly first - then it becomes much easier
03:02:44 <martinvlk> (I am a newbie, but I can already see how learning very basics is helping me)
03:02:45 <liste> alisia runQuery is a type family method
03:02:52 <liste> check out this: https://wiki.haskell.org/GHC/Type_families
03:03:06 <liste> you can't really make sense of the types until you do
03:04:58 <alisia> martinvlk, What would you consider as basics?
03:12:44 <liste> if you know type classes and polymorphism well, I guess type families aren't too many steps away
03:26:37 <paolino> spock looks very hard
03:27:06 <arkeet> liste: type families come with a host of difficulties though
03:28:04 <martinvlk> alisia: I come from imperative/Java world, I first took the usual approach "I'll look at some code and get it, as always"
03:28:07 <liste> yeah, the require quite a lot of banging your head into a wall
03:28:20 <martinvlk> it was really hard
03:29:18 <martinvlk> then I came across http://haskellbook.com/ and Chris Allen's more "pedagogical" approach to teaching Haskell
03:29:59 <martinvlk> which made me go throuogh learning about "simple" things like type classes
03:30:31 <martinvlk> properly.. and it is making my life so much easier when I have the terminology and simple things straight in my head
03:31:36 <martinvlk> i.e. I thought I understood, but then after learning simple things properly I see I now understand more easily
03:32:53 <martinvlk> the sequence of concepts taught in that book is: Lambda Calculus, Hello Haskell, Strings, Basic Datatypes, Types, Typeclasses, Functions
03:33:23 <martinvlk> and I find it a great deal easier than many other Haskell books I tried
03:33:27 <Hafydd> Of course, it ends with "functions."
03:33:40 <paolino> spock is much beyond that
03:33:54 <martinvlk> :) the book is in active development
03:34:00 <martinvlk> see http://haskellbook.com/progress.html
03:34:11 <martinvlk> they do monthly releases of new chapters
03:36:07 <martinvlk> paolino: yeah, so alisia needs to learn the basics basics plus more prerequisites before she can use that library.. right?
03:36:31 <martinvlk> (not knowing wheree on taht path alisia is of course.. )
03:40:48 <paolino> martinvlk, yes , don't start using haskell with that framework (IMHO) if you need help 
03:41:24 <paolino> obviously there are people that can do anything without help
03:41:55 <liste> Spock is a "rapid development" framework. rapid development == less boilerplate == advanced concepts
03:43:14 <paolino> == don't scratch
03:44:20 <liste> Scotty is a bit simpler but less safe
03:45:15 <tdammers> scotty is really just a very thin convenience layer over WAI
03:45:37 <tdammers> something like WAI + routing + automatic response headers
03:46:15 <tdammers> but at the same time, the routing isn't as flexible as I'd like it, so I usually don't bother and go with straight WAI instead
03:46:51 <paolino> straight WAI being ?
03:47:03 <tdammers> coding directly against WAI
03:47:05 <liste> @hackage wai
03:47:05 <lambdabot> http://hackage.haskell.org/package/wai
03:47:09 <tdammers> ^ that one
03:47:25 <liste> it's like WSGI in Python
03:47:30 <tdammers> it's what pretty much all the haskell web frameworks use under the hood
03:47:49 <tdammers> an abstraction layer that mediates between applications and HTTP servers
03:47:50 <luite> except happstack and snap
03:47:58 <tdammers> really?
03:48:03 <tdammers> I thought happstack used WAI
03:48:11 <tdammers> ah, no, you're right, it has its own server
03:48:27 <luite> there was some plan to switch to it long ago, but that never materialized
03:48:27 <liste> I guess they're pre-Yesod
03:48:40 <liste> and WAI was developed for Yesod's needs?
03:48:54 <tdammers> yeah, WAI is a Yesod spinoff IIRC
03:48:56 <luite> and i think the current plan is to switch to their own pipes-based server
03:49:52 <paolino> and it's not super easy for newbies, generally speaking don't do web servers to learn haskell
03:50:25 <liste> how about CGI?
03:50:43 <liste> it's just environment variables + stdout
03:50:52 <paolino> that's ok for me, but it's abandoned
03:51:08 <luite> CGI is archaic and doesn't fit well with current practices, especially for Haskell where you have easy access to lightweight threads
03:52:33 <liste> but it's simple and suits for learning imo, forces you to think stateless. but configuring it is a pain :(
03:53:26 <liste> no sane person would use it in production
03:53:33 <liste> (except maybe the cgit team)
03:54:04 <paolino> Newtork.WAI uses bytestrings and it's an obstacle in the learning path
03:54:23 <liste> what else would it use?
03:54:32 <liste> [Word8] ?
03:54:41 <luite> I don't think stateless to that extreme, starting a process for every request, is all that useful. with an HTTP server library you can carefully prepare the shared state and it should be just as clear
03:56:16 <paolino> liste, the point of WAI is not to be easy, but correct , so it's ok to use bytestrings. It's just using bytesting is not nice for a novice
03:56:28 <Axman6> why not?
03:56:37 <tdammers> I use CGI for development purposes
03:56:51 <Axman6> I would think that they're an idea that most novices with any programming experience could understand easily
03:57:06 <liste> cgi+runhaskell=no redeploys (:
03:57:07 <tdammers> and I maintain that using bytestrings is ultimately friendlier for the novice, because it's honest
03:57:35 <paolino> Axman6, lazy vs strict import is a source of confusion
03:57:42 <tdammers> liste: my web app supports CGI, SCGI and a built-in Warp, so I can use CGI for most of my testing, and Warp in production
03:58:24 <tdammers> since it loads templates and config on startup, this means I get the full benefit of in-process state when using Warp or SCGI, but fast development cycles when using CGI
03:58:41 <tdammers> the speed difference is whopping, btw
03:58:49 <Axman6> paolino: which is easily overcome with a single question in here =)
03:59:06 <martinvlk> tdammers: bytestrings might be understandable and clear as a concept, but for someone not yet at home in Haskell they are just another obstacle
03:59:22 <luite> tdammers: have you tried a file watching library to trigger refreshes?
03:59:26 <tdammers> martinvlk: yes, but not one that you should overcome by ignoring the difference between strings and byte arrays
03:59:32 <tdammers> luite: this is easier
03:59:36 <tdammers> luite: and more reliable
03:59:44 <luite> tdammers: hmm, i like the self-containedness of a built-in http server
04:00:06 <martinvlk> tdammers: agree
04:00:12 <tdammers> sure, that's why I use one when I'm not actively developing
04:00:47 <paolino> Axman6, I don't have a clear vision of what to teach to a novice, I'd exclude bytestrings as I consider it a result of an optimization process
04:00:53 <tdammers> I also have my static assets compiled into the binary, but the thing can be configured to serve them from local files instead
04:01:00 <luite> tdammers: so i tend to develop with warp too, easier to build tests around it. what cgi container/server do you use?
04:01:43 <tdammers> luite: WAI, with the CGI backend from wai-extra (I think), with a silly little shell script as the CGI wrapper, and everything running behind apache
04:02:03 <tdammers> I'd use nginx, but I'm too lazy to migrate my setup right now
04:02:26 <paolino> +1 nginx
04:02:38 <Darwin226> Hey, why doesn't this compile? http://lpaste.net/134584
04:02:48 <tdammers> another reason I'm supporting CGI is because I want to be able to run on as many servers as possible, including shared hosting services
04:03:12 <merijn> Darwin226: What's the compile error?
04:03:18 <tdammers> the idea being that you can just upload the binary, a config file, and some templates, and it'll work, no compilation required
04:03:22 <Darwin226> merijn: Duplicate instance delcarations
04:03:32 <Cale> Darwin226: Well, even if it compiled, as far as the instance resolution algorithm is concerned, you have two instances of Plus a a a
04:03:40 <Axman6> because it;s entirely possible for something to be in Num and Monoid
04:03:54 <Darwin226> Cale: I was hoping the incoherentinstances hammer would just pick one
04:03:56 <merijn> Darwin226: You're overlap is basically incompatible with the fundep
04:04:19 <merijn> Darwin226: No, because your fundep says "for any combination of "a b" there is a unique c"
04:04:35 <Darwin226> merijn: Oooh... Right right
04:04:39 <Darwin226> merijn: Makes sense
04:04:46 <merijn> Darwin226: So overlapping Monoid/Num would make that a lie
04:05:05 <Darwin226> merijn: I removed the fundep and nothing changed
04:05:16 <Darwin226>     Duplicate instance declarations:       instance [incoherent] Num a => Plus a a a         -- Defined at test.hs:10:10       instance [incoherent] Monoid a => Plus a a a         -- Defined at test.hs:13:10
04:05:21 <Cale> Yeah, it's still silliness even without that
04:05:27 <Cale> yep
04:05:41 <Cale> Constraints don't affect whether the instance is a duplicate
04:06:05 <luite> tdammers: ah i tend to treat something like heroku, where basic http server processes are allowed, as a reasonable lowest common denominator
04:06:22 <Darwin226> Cale: I still don't see why it matters. Whats so much worse in having identical heads than having no instance be most specific
04:07:01 <pavonia> merijn: Why is the fundep violated if all thee type variables are the same? Shouldn't | a -> a hold for any type a?
04:07:02 <Gurkenglas> I'm on an openSUSE university machine without install rights without ghc installed. Can you recommend a way to compile my .hs, perhaps by an online interface?
04:07:28 <merijn> Gurkenglas: You can easily install GHC user local
04:07:38 <merijn> Gurkenglas: just use the binary tar of GHC
04:07:48 <Cale> Darwin226: Instance resolution doesn't consider constraints until after it has committed to an instance, because you can never be certain that an instance won't exist later.
04:07:50 <merijn> Gurkenglas: I've done this to use GHC on the university cluster, works great
04:08:27 <merijn> Gurkenglas: Just "./configure --prefix=$HOME/ghc && make install" and you've got a user local ghc, build cabal from source and you're set
04:08:37 <Darwin226> Cale: Incoherent instances picks an arbitrary one anyways. Why does it matter that I have more than one identical?
04:08:44 <merijn> Cabal and GHC default to user local database, so there's no problems without admin rights
04:09:21 <merijn> Gurkenglas: Of course this takes up like a gig or so of diskspace, so I dunno how restricted your quota is
04:09:45 <merijn> Gurkenglas: But GHC is by far the easiest language/compiler to install user local that I've encountered so far :)
04:11:20 <Cale> Darwin226: Incoherent instances will still pick the most specific instance at the time of instantiation, it just doesn't worry about future modules.
04:11:35 <Cale> Darwin226: There still has to be a unique most specific instance.
04:12:15 <Cale> (maybe I'm wrong about that...)
04:12:35 <Darwin226> Cale:  I think docs disagree
04:12:39 <Darwin226> Cale:  Not sure
04:12:49 <Cale> But yeah, in any case, the instance resolution algorithm totally ignores class constraints on the instances in every case.
04:12:59 <tdammers> merijn: how about clojure?
04:13:03 <Cale> (no matter which flags you set)
04:13:06 <tdammers> download lein script, run lein script, done
04:13:26 <tdammers> oh wait, you need a java env first
04:13:28 <tdammers> nm
04:13:38 <merijn> tdammers: Never used clojure, but java is a pain :p
04:13:53 <tdammers> nice thing about clojure is that you hardly ever get to see java
04:14:04 <tdammers> except for exception dumps
04:14:05 <liste> tdammers not even in stack traces?
04:14:22 <tdammers> stack traces are java all over the place, and they suck big time
04:14:29 <Cale> Darwin226: Yeah, you're right about that actually, it does make an arbitrary choice in that case.
04:14:30 <Gurkenglas> I don't have that much space. (How come it's a GB? Surely there aren't ten million LOC?)
04:14:39 <tdammers> if you think Haskell's error messages are bad, you are not going to like clojures'
04:15:04 <merijn> Gurkenglas: 5 different builds of GHC, profiling, non-profiling, thread, non-threaded, etc.
04:15:13 <Cale> Darwin226: I basically never turn on IncoherentInstances because it basically means "I don't want anything to work, and I'd like to be confused about why"
04:15:31 <Gurkenglas> Is there a stripped-down version for the space-poor?
04:15:35 <tdammers> someone should @quote that
04:15:51 <tdammers> Gurkenglas: the fpcomplete ide :P
04:16:07 <merijn> @remember Cale I basically never turn on IncoherentInstances because it basically means "I don't want anything to work, and I'd like to be confused about why"
04:16:07 <lambdabot> Done.
04:16:15 <tdammers> merijn: thx
04:16:43 <merijn> I already avoid OverlappingInstances like the plague, let alone Incoherent :p
04:17:04 <merijn> The solution is always: Moar type families...
04:17:05 <liste> why was Hugs abandoned?
04:17:06 <Cale> Yeah, if you need OverlappingInstances to make your thing compile, you probably just shouldn't be using type classes.
04:17:10 <Gurkenglas> tdammers: I want to process about a dozen 2000x1000 tiff pictures. Does fpcomplete have all packages on haskell platform?
04:17:18 <merijn> liste: Because the creators lost interest
04:17:20 <tdammers> Gurkenglas: I have no clue
04:17:24 <tdammers> Gurkenglas: never used it
04:17:41 <Cale> liste: Because maintaining a C program which is in essentially all respects a worse implementation of the language than GHC eventually gets tedious, I guess.
04:17:44 <merijn> Gurkenglas: Compile in a vm on your machine and copy to the cluster?
04:17:54 <tdammers> liste: creators lost interest, and it hadn't reached critical mass yet (and wasn't about to either)
04:18:11 <merijn> The main reason for Hugs popularity was the absence of ghci
04:18:21 <merijn> So when ghci came along there was little point to it
04:18:37 <merijn> Because it provided the REPL of hugs, with the language implementation/completeness of GHC
04:18:41 <luite> when did ghci come along?
04:18:57 <merijn> A few years before I started learning haskell, afaik
04:18:58 <tdammers> yeah, except maybe how web developers used to use Opera to test their stuff against a from-scratch browser engine that has absolutely nothing to do with the mainstream ones
04:19:27 <Cale> GHC 5 was the first one with ghci
04:41:20 <vektor> Ok, so I have a bug I can't figure out on my own: https://github.com/vektordev/GP/blob/master/src/GRPCore.hs - this program will very occasionally crash:
04:41:36 <vektor> trying to generate id:1628
04:41:37 <vektor> GRPCore: ./GRPGenome1623.hs.stat: openFile: resource busy (file is locked)
04:43:42 <vektor> likely, some readFile doesn't free the handle in time, possibly the one in line 154 causes the error?
04:45:27 <vektor> There's also a process call to another program - which should have terminated correctly, according to output. Thus, it can't have locked the file without unlocking it later, right?
04:45:33 <pacak> vektor: I would try replacing default versions of readFile by something strict
04:45:42 <pacak> And all other file operations as well.
04:46:56 <vektor> as in? Something that doesn't error, but instead returns IO (Maybe String), depending on availability of the file?
04:47:03 <pacak> Not quite.
04:47:20 <pacak> :t readFile
04:47:21 <lambdabot> FilePath -> IO String
04:47:47 <pacak> It looks like IO action that opens file and returns it's as one string
04:48:02 <pacak> But it's actually uses hGetContents
04:48:16 <vektor> Ohh, this: https://hackage.haskell.org/package/strict-0.3.2/docs/System-IO-Strict.html
04:48:19 <pacak> Which is evil.
04:48:52 <pacak> vektor: Yep, either that or similar function for bytestrings - regular strings are slow.
04:48:52 <vektor> So this other one will read the file wholesale and close the handle right after?
04:48:54 * hackagebot bitx-bitcoin 0.2.0.1 - A Haskell library for working with the BitX bitcoin exchange.  http://hackage.haskell.org/package/bitx-bitcoin-0.2.0.1 (tebello_thejane)
04:49:04 <pacak> vektor: Strict version should do that, yes.
04:49:49 <vektor> So all my other readFiles should close the file handles right after, so no intransparently locked files.
04:50:05 <pacak> Yep
04:52:35 <vektor> Funny thing about this: I'll only be able to confirm a fix after a while. This bug appears very... sporadically.
04:54:46 <Geekingfrog> is it me or hackage has some issues? I'm looking for Data.Functor.Identity but the first link leads to a 404 (https://www.haskell.org/hoogle/?hoogle=Data.Functor.Identity)
04:57:03 <Haskellfant> Geekingfrog: nope, same here. the one linked on the new hoogle works http://hoogle.haskell.org/?hoogle=Data.Functor.Identity
04:58:54 * hackagebot socket 0.4.0.0 - A portable and extensible sockets library.  http://hackage.haskell.org/package/socket-0.4.0.0 (LarsPetersen)
05:01:27 <vektor> looking good so far. 2k tries, no bug yet.
05:02:35 <cheater> have closed type families changed since they have been introduced or has the design been finalized now?
05:03:41 <cheater> also does H-M still work when using CTF?
05:13:26 <vektor> pacak: Thanks a lot. I declare that one fixed, given I would very likely have reproduced it by now.
05:13:55 * hackagebot yesod-table 0.1.3 - HTML tables for Yesod  http://hackage.haskell.org/package/yesod-table-0.1.3 (andrewthad)
05:18:55 * hackagebot pcg-random 0.1.3.0 - Haskell bindings to the PCG random number generator.  http://hackage.haskell.org/package/pcg-random-0.1.3.0 (cchalmers)
05:28:56 * hackagebot codex 0.3.0.8 - A ctags file generator for cabal project dependencies.  http://hackage.haskell.org/package/codex-0.3.0.8 (aloiscochard)
05:38:56 * hackagebot distributed-process-simplelocalnet 0.2.3.0 - Simple zero-configuration backend for Cloud Haskell  http://hackage.haskell.org/package/distributed-process-simplelocalnet-0.2.3.0 (FacundoDominguez)
05:38:58 * hackagebot network-transport 0.4.2.0 - Network abstraction layer  http://hackage.haskell.org/package/network-transport-0.4.2.0 (FacundoDominguez)
05:39:00 * hackagebot network-transport-tcp 0.4.2 - TCP instantiation of Network.Transport  http://hackage.haskell.org/package/network-transport-tcp-0.4.2 (FacundoDominguez)
05:39:02 * hackagebot notzero 0.0.2 - A data type for representing numeric values, except zero.  http://hackage.haskell.org/package/notzero-0.0.2 (TonyMorris)
05:43:57 * hackagebot rank1dynamic 0.3.1.0 - Like Data.Dynamic/Data.Typeable but with support for rank-1 polymorphic types  http://hackage.haskell.org/package/rank1dynamic-0.3.1.0 (FacundoDominguez)
05:58:21 <connney> can you import a module in lambdabot?
05:58:48 <kkfwefe> https://www.filepicker.io/api/file/sRCP6qLvTs2hmINfaGos
06:00:34 <Axman6> connney: no, but it has access to many modules. what do you want?
06:01:41 * connney wanted to evaluate some code ut I guess I will just show the results
06:01:51 * connney read "0.005" * 100 :: Decimal. => 0.5
06:02:43 <connney> round (read "0.005" * 100 :: Decimal) => 0
06:02:46 <connney> why?
06:02:56 <connney> wht 0 and not 1
06:03:00 <connney> why*
06:03:54 <Axman6> > round 0.5
06:03:56 <lambdabot>  0
06:03:57 * hackagebot distributed-static 0.3.2.0 - Compositional, type-safe, polymorphic static values and closures  http://hackage.haskell.org/package/distributed-static-0.3.2.0 (FacundoDominguez)
06:04:02 <Axman6> > round 0.5000000001
06:04:03 <lambdabot>  1
06:05:26 <connney> why does the same issue affect Decimal, which has arbitrary precision
06:06:28 <merijn> connney: round uses bankers rounding
06:06:34 <saulzar_> Hm, I'm using ghc 7.10.1 and packages are failing to compile because import Control.Applicative ((<$>)) has been #ifdef'ed out.. am I missing something?! 
06:06:35 <merijn> connney: And presumably so does Decimal
06:06:36 <Axman6> not sure, but it doesn't seem unreasonable that 0.5 rounds to zero
06:06:54 <merijn> connney: Because IEEE754 specifies banker's rounding to be the default rounding
06:07:07 <merijn> "high school" rounding creates an unfair distribution
06:07:44 <Axman6> saulzar_: there were big changes in 7.10 regarding Applicative (it's now a superclass of Monad, and a lot more of it, possibly all of it, is now in the Prelude)
06:08:14 <connney> merijn: ah I see
06:08:28 <saulzar_> Axman6, This is what I thought, and presumably these packages were changed specifically to compile with 7.10... but I'm using 7.10 and those specific changes are the ones not compiling!
06:08:32 <connney> round half to even
06:09:04 <merijn> connney: This means half of all .5 values are rounded up, the other half down. Otherwise you round up slightly more values than you round down
06:09:11 <saulzar_> Axman6, This is in popular packages like e.g. attoparsec 
06:10:07 <Axman6> that seems odd, but I haven't used 7.10 so I don't have the experience to help
06:10:31 <connney> merijn: is there a function that rounds half to up?
06:10:37 <saulzar_> Axman6, Ah, ignore me - it's a problem with this try-reflex sandbox I have, it has ghc 7.10 rc2
06:11:04 <ags> I'm having a bit of trouble understanding monad transformers - I've put together a test using ReaderT and ExceptT from the transformers package (is that preferred over mtl?), but I can't quite get it all to fit together: http://lpaste.net/134590
06:12:17 <merijn> connney: I think so, but I'll be damned if I remember where it is
06:12:41 <srhb> ags: And the error?
06:12:53 <merijn> ags: mtl is literally just a bunch of convenience things for using transformers, so there's no difference
06:13:03 <merijn> ags: mtl just reexports the datatypes of transformers
06:13:52 <ags> srhb: http://lpaste.net/134591
06:13:58 * hackagebot distributed-process 0.5.5 - Cloud Haskell: Erlang-style concurrency in Haskell  http://hackage.haskell.org/package/distributed-process-0.5.5 (FacundoDominguez)
06:15:03 <ags> merijn: Ah, OK - so mtl is a bit higher level? Do people tend to use it more in production code?
06:15:14 <nshepperd> I think there used to be a 'mtl vs transformers' issue, but now mtl just provides the typeclasses afaik
06:16:03 <nshepperd> so you use them both together, generally
06:17:47 <ags> nshepperd: Where would you use one or the other? They look like they export a similar set of monads.
06:19:22 <srhb> ags: mtl has the Monad* instances and such, afair.
06:19:25 <Vektorweg1> is using getChanContents on one chan from more than one thread a good idea? 
06:19:53 <nshepperd> transformers provides the WhateverT types, and mtl provides the MonadWhatever typeclasses and associated functions
06:20:23 <connney> what version of array package does 7.8.4 ship with (where can one check that? I tried googling but without luck)
06:20:38 <tdammers> for a second I thought there might be an Acme.Whatever.Trans namespace that literally gives you WhateverT
06:20:52 <nshepperd> just depend on them both and import Control.Monad.Whatever and you get everything you need
06:21:18 <Geekingfrog> how do you "read" in english (<*>) ?
06:21:43 <Saizan> star or app
06:22:06 <ags> srhb: nshepperd: Right, when I was looking around many examples derived MonadReader and such - so I could define the transformer using ReaderT and ExceptT from transformers, and have it derive MonadReader and MonadError from mtl?
06:22:29 <srhb> ags: Or you could just use a type alias.
06:23:45 <srhb> ags: But I don't see how this relates to the code your pasted? I mean, you're just forgetting to deal with the Either
06:24:35 <ags> srhb: Oh, true. I guess I only need newtype when defining instances of type classes manually, right? Is there any other reason to use type / vs newtype for transformers?
06:25:04 <srhb> ags: Mostly if you want to define your own instances, really.
06:26:08 <merijn> ags: I prefer using transformers directly, tbh
06:26:48 <merijn> ags, srhb: The other reason to use newtype + type is that when you later replace it with a custom monad for performance/whatever reason you won't break other people's code
06:28:31 <ags> merijn: Why do you prefer that?
06:28:39 <ags> (using transformers directly)
06:30:29 <connney> I am having trouble installing rounding package by edwardk. I have ghc 7.8.4 and I have been using sandboxes from t he beginning. I also tried stackage without success. http://lpaste.net/134594
06:31:04 <connney> that is a log from a fresh sandbox without any dependencies
06:31:35 <Ainieco> hello
06:32:18 <Ainieco> i know there are must be smart people here who knows english well, how do you call this http://balloons.in.ua/photos/YazichekGudok_s.jpg ?
06:32:48 <merijn> connney: array has a dependency on base<4.5, but base is tied into GHC, i.e. it doesn't compile with your ghc
06:33:05 <Ainieco> i've seen it in couple of english films so there must be a term for this, people usually use it on birthdays
06:33:09 <merijn> connney: you can try changing the version bounds and hope it worjs
06:33:18 <zenzike> Aineico: that's a party horn
06:33:59 <hodapp> also, basically no one uses these in the US at birthdays, except in movies that are trying to be stereotypical
06:34:03 <Ainieco> zenzike: yes, thank you!!
06:34:07 <merijn> ags: I don't like MonadReader and friends
06:34:14 <hodapp> Jean Baudrillard would be proud
06:34:16 <connney> merijn: does that means it requires ghc newer than 7.8.4?
06:34:16 <Ainieco> sorry for OT
06:34:39 <merijn> connney: no, older
06:34:42 <zenzike> Ainieco: np :-)
06:34:56 <geekosaur> I haven't seen those things in years
06:35:06 <merijn> connney: you have base 4.7, so this expects 7.4 or 7.2
06:35:07 <geekosaur> they're a movie stereotype
06:35:17 <merijn> geekosaur: really?
06:35:22 <merijn> we had them at kid's parties
06:35:44 <connney> oh right. I just noticed it was uploaded in 2010
06:35:54 <babu`> I am using a sandbox. I can do a cabal build and cabal run but when I try to load the file in ghci it says "Cannot find module". Why is ghci not picking up the module?
06:36:05 <merijn> connney: In all likelihood just updating the dependencies will fix it
06:36:15 <geekosaur> babu`, use cabal repl
06:36:21 <geekosaur> which wraps ghci so it can see the sandbox
06:36:28 <connney> merijn: can I change version bounds without modifying its cabal file?
06:36:33 <merijn> connney: be careful submitting a patch to edwardk, though, before you know it he'll make you a maintainer
06:36:35 <ags> merijn: srhb: nshepperd: Thanks for your help guys; I've got some things to investigate and mess around with now :)
06:36:50 <connney> merijn: lol
06:36:50 <merijn> connney: You can't, use "cabal get" to unpack it and edit the cabal file
06:37:38 <geekosaur> merijn, granting it's been a long time, but I do not recall those at any parties, only seeing them in tv/movies that depicted parties
06:37:59 <geekosaur> and many of those seemed to have ironic usages
06:39:07 <merijn> My 2nd cousin turns 2 this year and I wouldn't be surprised to see them at a kid's party, tbh
06:40:58 <babu`> geekosaur, I use emacs and haskell modes and so I just load the buffer. I have been using this for quite some time. But some packages cannot co-exist and so thought I will use a sandbox for my project. Does anyone know how to do this from emacs? (I used C-cC-l => inferior-haskell-load-file)
06:42:07 <geekosaur> you might need a later version of haskell-mode for it to recognize sandboxes? I generally use a separate terminal rather than a subprocess inside of emacs, so have not paid close attention
06:45:33 <srhb> babu`: inferior haskell needs to be changed to use cabal repl instead of ghci, if you go that route.
06:46:44 <ronh-> babu` I am using haskell-mode-13.12 and haskell-process-load-or-reload recognizes and uses cabal sandboxes by default
06:57:38 <connney> where can I find a rounding function that always rounds midpoint of two numbers up? round 0.5 => 1
07:00:06 <merijn> connney: You could just do "\x -> if (x - truncate x) == 0.5 then ceiling x else round x", but it would be pretty inefficient >.>
07:01:58 <babu`> geekosaur, ronh, thanks. I upgraded from melpa to latest version.
07:06:13 <osa1> I wish we had a way to get error messages without type synonyms..
07:08:44 <bergmark> osa1: yes that can be super confusing :(
07:09:01 * hackagebot bindings-saga-cmd 0.1.1.1 - Wrapping saga_cmd  http://hackage.haskell.org/package/bindings-saga-cmd-0.1.1.1 (michelk)
07:09:36 <bergmark> osa1: or even better, print the original names with all aliases
07:09:48 <osa1> I was wondering how hard would it be to implement. maybe I should ask #ghc and open a ticket even.
07:09:50 <osa1> yes!
07:13:18 <igniting> has anyone heard of this quote: "A type signature never lies."? I just came up with it. Is it safe to use this in context of Haskell?
07:13:40 <merijn> igniting: Depends on how you define lies
07:13:59 <merijn> "undefined :: Int" <- that's a pretty big lie
07:14:22 <merijn> > let x :: Int; x = x in x
07:14:26 <lambdabot>  mueval-core: Time limit exceeded
07:15:10 <nkar``> is a way to convert from Int64 to Double other than (fromRational $ toRational x) :: Double?
07:15:11 <igniting> I was thinking of the paper "Theorems for free" and how much one can infer just given the type signature
07:15:21 <merijn> nkar``: fromIntegral?
07:15:22 <michaelt> igniting: in a language with totality and productivity checking, you could get rid of those. Also, what about exceptions ...
07:15:45 <merijn> > fromIntegral (1 :: Int64) :: Double
07:15:46 <lambdabot>  1.0
07:15:51 <nkar``> damn
07:15:59 <nkar``> I tried it, and it didn't work for some reason
07:17:16 <igniting> Also unsafePerformIO. I would be better off not using this quote :P
07:17:29 <merijn> igniting: You forgot unsafeCoerce
07:17:33 <merijn> :t unsafeCoerce
07:17:34 <lambdabot> Not in scope: ‘unsafeCoerce’
07:17:37 <merijn> oh, duh
07:17:42 <merijn> Anyway, it's "a -> b"
07:18:24 <y> unsafeId
07:18:28 <igniting> unsafeCoerce can be achieved by using unsafePerformIO right?
07:18:44 <y> yes, with IORef(s)
07:18:45 <merijn> No, unsafePerformIO can only strip IO away
07:18:55 <michaelt> {-#LANGUAGE Safe#-} will get rid of unsafePerformIO, does it precude unsafeCoerce
07:19:01 <merijn> michaelt: Yes
07:19:12 <merijn> michaelt: Until someone finds the next bug ;)
07:19:18 <michaelt> hah
07:19:31 <y> Safe Haskell will get rid of pretty much anything unsafe* until someone can implement it using typefamilies and functional dependencies
07:19:40 <merijn> michaelt: For example, GeneralizedNewtypeDeriving lets you write unsafeCoerce in Safe haskell, which is why it's no disallowed, iirc
07:20:02 <michaelt> right, that was what I was remembering dimly
07:20:29 <michaelt> It got rid of unsafeCoerce but GeneralizedNewtypeDeriving gives you an equivalent
07:20:37 <michaelt> something like that
07:21:23 <michaelt> It would be nice if there were a simple sublanguage with totality checking and so on
07:23:46 <c_wraith> michaelt: have you checked out http://www.haskellforall.com/2014/09/morte-intermediate-language-for-super.html ?
07:24:09 <michaelt> c_wraith: well, I tried to check it out ;)
07:25:03 <kuribas> Does cabal automatically compile with -O?
07:25:38 <michaelt> isn't it O1
07:26:23 <StoneToad> c_wraith: interesting link
07:26:40 <merijn> kuribas: No, unless the cabal file specifies that or you edited .cabal/config
07:26:46 <c_wraith> -O and -O1 are the same, and yes, it's cabal's default
07:26:53 <merijn> oh, it is?
07:27:01 <michaelt> c_wraith: does that kind of restriction enforce totality? maybe it does...
07:27:12 <merijn> michaelt: Yes, CoC is strongly terminating
07:27:26 <michaelt> ah O = O1
07:27:27 <kuribas> merijn: there's an optimize flag in .cabal/config, which is default True.
07:28:09 <michaelt> making it False would not be too good an idea
07:28:40 <michaelt> hackage complains if you over rule it with -O2 
07:28:46 <merijn> You can make it ": 2"
07:28:53 <kuribas> What's wrong with -O2?
07:29:02 * hackagebot rest-gen 0.17.0.6 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.17.0.6 (AdamBergmark)
07:29:12 <michaelt> kuribas: it just takes longer to compile
07:29:22 <athan> kuribas: I don't think there's much wrong with it, but currently I don't think it makes faster code than -O
07:29:25 <michaelt> otherwise of course its better! 2 > 1
07:29:40 <athan> s/faster/much faster
07:29:51 <michaelt> athan: oh is that true
07:30:00 <c_wraith> There are certain things it helps a bunch
07:30:07 <c_wraith> But most code is affected very little
07:30:10 <kuribas> I should profile my code to see if LLVM is faster.
07:30:15 <c_wraith> And it significantly reduces compilation speed
07:30:29 <kuribas> At least for my numerical code.
07:30:40 <c_wraith> llvm is likely to be faster for numerical code
07:30:59 <michaelt> kuribas: it seems only to be faster with numeric things. Data.Vector.Unboxed and .Storable, for example
07:31:56 <michaelt> it seems to me it's always a little slower, LLVM, with regular constructor-laden haskell
07:33:11 <michaelt> I've never noticed -fllvm generate a disaster though. 
07:34:27 <kuribas> Is the intermediate language for llvm C?
07:34:38 <merijn> no, it's llvm assembler
07:34:58 <merijn> GHC doesn't use C anywhere anymore and hasn't for a while
07:36:01 <int-index> I noticed that it's possible to define a type class for lifting certain operations in transformers. As a proof of concept, I implemented a class with `liftLocal` method. Is there a package that already does this?
07:40:03 <michaelt> int-index: what does liftLocal do?
07:41:34 <int-index> michaelt: for ContT it coincides with Control.Monad.Trans.Cont.liftLocal. For other transformers it's a wrapper around mapWriterT/mapReaderT/mapStateT/mapExceptT/etc to do the same thing.
07:42:00 <int-index> Basically it's the code for liftLocal copied from "lifting" instances.
07:42:51 <lpaste> int-index pasted “MonadLiftLocal” at http://lpaste.net/134598
07:43:21 * dfeuer summons copumpkin with a magic spell.
07:43:42 <dfeuer> Blast.
07:45:42 <michaelt> int-index: oh I see. Isn't this a bit like 'hoist'  hoist :: (forall a . m a -> n a) -> t m a -> t n a 
07:47:48 <michaelt> https://hackage.haskell.org/package/mmorph-1.0.0/docs/Control-Monad-Morph.html#t:MFunctor
07:48:55 <int-index> michaelt: No.
07:49:19 <michaelt> just wondering, I dont understand liftLocal in Cont ... 
07:49:34 <int-index> I don't understand it either, but the types don't match anyway.
07:49:50 <ryantm> I'm trying to make a monad transformer with Reader on top of IO. I already have code using Control.Exception functions like finally and catches. How do I convert those function to use the monad transformer stack?
07:50:55 <michaelt> int-index: yes the types don't match, I was trying to understand how you use it
07:51:29 <int-index> michaelt: I use it to minimize boilerplate when defining lifting instances.
07:51:43 <michaelt> ryantm: you might just use https://hackage.haskell.org/package/exceptions-0.8.0.2/docs/Control-Monad-Catch.html
07:51:53 <int-index> I also think that using a type class is a more principled approach than qualified imports everywhere.
07:53:22 <ryantm> michaelt: thanks, I will take a look at that module.
07:53:49 <int-index> michaelt: hoist generalizes mapFooT (where Foo is a monad transformer), and I want to generalize other operations as well (liftLocal being one of them)
07:54:27 <michaelt> int-index: right, i'm starting to get it 
07:58:25 <michaelt> right, hoist = mapFoo* but i can define ll :: (MFunctor t, Monad m)  =>  (forall a . (r -> r) ->   m a ->   m a)  -> (forall a . (r -> r) -> t m a -> t m a)
07:58:40 <michaelt> ll phi f = hoist (phi f)  -- I guess that's obvious
07:59:21 <int-index> michaelt: That's because liftLocal is implemented exactly this way for all the transformers... except ContT.
07:59:32 <int-index> For ContT you need a separate liftLocal, provided by the package.
08:00:23 <ProofTechnique> mpickering: I has a slack-api question for you, if you're around
08:01:52 <int-index> michaelt: Apparently it's reflected in the fact that ContT has no MFunctor instances.
08:02:21 <michaelt> int-index: right I was trying to register that
08:02:32 <michaelt> I mean, understand it
08:04:05 <michaelt> int-index: is the idea to have a liftLocal for its own sake, or do you implement other things with it/
08:05:21 <int-index> michaelt: I want it to reduce boilerplate in lifting instances in Ether.
08:06:31 <ProofTechnique> @tell mpickering Trying to send a message when a particular user joins, but slack-api is a little over my head. Any tips?
08:06:31 <lambdabot> Consider it noted.
08:08:21 <michaelt> int-index: okay, I'm finally following, you mean all the Cont related functions in each module. RIght. It's making perfect sense now.
08:12:28 <michaelt> int-index: right, it seems clear you should just do it, there won't be any surprises, right?
08:12:28 <michaelt> int-index: maybe you should send a patch to transformers though?
08:12:28 <michaelt> int-index: this is really confusing ...
08:17:20 <int-index> michaelt: I guess that transformers don't define those type-classes to avoid using RankNTypes
08:17:39 <michaelt> int-index: oh, right that explains some things. 
08:17:42 <int-index> but why there's no separate package for this - it's a mistery to me.
08:18:16 <michaelt> int-index: but the part I'm now trying to understand is why the different transformers have different assortments of lift_ functions. 
08:18:44 <int-index> michaelt: because it's not possible to lift each operation through each transformer.
08:18:55 <int-index> It would violate laws of those operations.
08:19:00 <michaelt> yes, I'm just thinking through the examples
08:19:12 <int-index> liftListen for ContT would break Writer laws
08:19:13 <michaelt> int-index: but liftLocal will be of use in each case
08:19:16 <michaelt> ?
08:19:56 <int-index> michaelt: Yes, liftLocal can be defined for all transformers in the transformers package (but I'm not sure about other possible transformers)
08:21:03 <michaelt> right, I was assuming that, but I thought you meant that you could implement the other local- functions with it. 
08:21:21 <michaelt> liftLocal is pretty hard to comprehend!
08:21:40 <sopvop> were there any bugs with type class dict passing in ghc-7.10.1?
08:22:28 <int-index> michaelt: I'm thinking about separate classes for each operation. MonadLiftLocal for liftLocal, MonadLiftCatch for liftCatch, MonadLiftCallCC for liftCallCC, etc.
08:22:52 <int-index> They would just generalize what already is present in the transformers package.
08:22:58 <michaelt> int-index: okay, now I follow better. 
08:23:30 <michaelt> int-index: in a way that would be better, since we associate laws with classes, but transformers is doing this in comments on the type synonyms
08:23:42 <michaelt> of course, with lenses that is the custom too
08:24:07 <inria> Hi. I'd like to write someting like fct :: (Num field) => field -> String\n fct _ = show x \n  where x = (1 :: field) / (2 :: field). But the type system don't allow me. Can anyone explain me what's going wrong?
08:25:15 <michaelt> int-index: so you could state the laws mentions in xyz.Signatures but associate them with a class
08:25:19 <int-index> michaelt: Yes, that's exactly what transformers is doing. My guess is that it's just to avoid RankNTypes, but this is a widespread extension.
08:25:19 <mniip> Zenol, type variables don't exist outside type signatures
08:25:20 <michaelt> classes rather
08:25:30 <mniip> not with ScopedTypeVariables extension
08:26:04 <michaelt> int-index: right, you need the extension to formulate the type, but you are already using fancier extensions than transformers
08:26:12 <mniip> Zenol, if you don't want that extension, you could do something like
08:26:27 <mniip> fct x = show $ (1 `asTypeOf` x) / 2
08:26:53 <mniip> type of 1 will be inferred from x through 'asTypeOf', and type of 2 will be inferred via /
08:27:06 <michaelt> int-index: and in any case RankNTypes is everywhere
08:27:16 <mniip> actually you could even write
08:27:28 <mniip> fct x = show $ (1 / 2) `asTypeOf` x
08:27:53 <int-index> michaelt: Yeah. So what I was asking is whether all of this is already somewhere in a package, or should I write all those classes myself.
08:28:57 <Zenol> mniip> Oh, thanks, that's what I was looking for! :D
08:31:12 <muller> can someone please explain how the database connection is used in this code https://github.com/agrafix/funblog/blob/master/src/Web/Actions/User.hs..
08:31:46 <muller> it is a sample app for Spock framework, and uses Persist db library
08:32:06 <muller> I want to use postgreSQL-simple instead.
08:34:45 <michaelt> int-index: oh, this is somewhat similar http://hackage.haskell.org/package/contstuff-1.2.6/docs/Control-ContStuff-Classes.html in making classes, but to a different purpose
08:35:20 <hodapp> First thing I learned from that comonad presentation: Type holes are useful.
08:35:45 <int-index> michaelt: I'll take a look at it, thanks. Now I have to go.
08:36:49 <elben_> I’m currently using GHC 7.8 (I think from https://www.haskell.org/platform/), but I would like to upgrade to 7.10. What is the best way forward? I just learned about cabal sandboxes, that seems like a sensible approach. Is this (https://www.haskell.org/ghc/download_ghc_7_10_1#macosx_x86_64) the package I want?
08:37:19 <geekosaur> note that sandboxes don't help much with multiple ghc versions
08:37:29 <elben_> It’s confusing that https://www.haskell.org/ghc says “Stop! For most users, we recommend installing the Haskell Platform instead of GHC.”, while https://www.haskell.org/downloads says “Many now recommend just using a bare compiler combined with sandboxed dependencies, especially for new users.”
08:37:51 <ProofTechnique> geekosaur: Don't halcyon or stack deal with that? I can't remember which one i read that about
08:38:13 <geekosaur> a 7.10-based platform is in testing, and includes a script to switch between platform versions (which I think was introduced in 7.8 so should work fairly well for switching between those)
08:38:43 <elben_> geekosaur: I should be OK with leaving 7.8. I’m just going through tony morris’s haskell-course for now (and hakyll).
08:39:07 <mietek> elben_: the very simplest thing you can use for that is https://ghcformacosx.github.io
08:39:24 <geekosaur> sandboxes do have one significant shortcoming, which is that it's painful to initialize a sandbox with a given set of base libraries; the platform doesn't even try, stackage has you install stackage into the sandbox (although I think more recently there's a wrapper for cabal that tries to improve on this)
08:39:28 <mietek> elben_: it’s just a self-contained Mac app
08:39:54 <mietek> elben_: note upgrading your GHC has almost nothing to do with the use of Cabal sandboxes
08:40:31 <geekosaur> I am rather hoping that at some point we get cabal sandbox init --from={stackage-lts, platform, ...} that doesn't have to build everything in the sandbox
08:40:33 <michaelt> elben_: ignore the Haskell Platform thing. On os x, the advantages are minute, the disadvantages great. Sandboxed are orthogonal
08:41:08 <mietek> ProofTechnique: Halcyon indeed helps with having to use multiple GHC versions
08:41:18 <mietek> ProofTechnique: not as much as it could, but I don’t get enough hours in the day
08:41:19 <michaelt> geekosaur: but you can refer to another 'outer' sandbox, no?  It's true I haven't figured this bit out yet
08:41:23 <geekosaur> and yes, current so-called wisdom is that the platform can only cause pain and suffering, because the notion of stable versions went away with ruby and node.js
08:41:42 <xelxebar> Recently migrated to an upgraded machine. Need to get my Haskell env working again (ghc-mod, hoogle, etc) and wondering if there are some new-fangled tools I should be considering or just go with the standard cabal and sandbexes approach.
08:41:42 <mietek> geekosaur: Stack already has some support for multiple layers of DBs — but they get rid of sandboxes altogether
08:41:45 <elben_> mietek: so the *original* problem I’m trying to solve is ghc-mod isn’t working with my hakyll project. I get “/setup-config: hGetContents: invalid argument (invalid byte sequence)', ‘’]”, which from Googling led me to think it’s a problem w/ incompatible versions of cabal (https://github.com/kazu-yamamoto/ghc-mod/wiki/InconsistentCabalVersions#ghc--710-1)
08:41:45 <geekosaur> HEAD for eveyrthing, or frozen versions per individual app, is the way the cool kids do things these days
08:41:59 <michaelt> elben_: I just install the binary distribution you linked in ~/.haskell/bin or the like and put that in path.
08:42:09 <mietek> elben_: that’s an environment/locale problem
08:42:13 <xelxebar> Read about stack recently: https://github.com/commercialhaskell/stack
08:42:18 <geekosaur> I'm just glad I don't have to support people stuck with such messes
08:42:27 <mietek> elben_: what happens when you type `locale` in your shell?
08:42:38 <michaelt> elben_: there should be an ininstaller script buried somewhere in the platform stuff you have. 
08:42:38 <ProofTechnique> elben_: https://github.com/DanielG/ghc-mod/tree/release
08:42:41 <mietek> xelxebar: check out Halcyon; https://halcyon.sh
08:42:54 <ProofTechnique> Building ghc-mod from that branch worked for me when I was having similar issues
08:44:04 <michaelt> roconnor: hello
08:44:10 <roconnor> hi
08:44:21 <xelxebar> mietek: thanks. I'm taking a look now
08:44:28 <xelxebar> What about nix?
08:44:51 <michaelt> roconnor: I was going to ask, is it moronic to make zoom return an mtl MonadState thing, rather than the concrete StateT ?
08:45:14 <michaelt> roconnor: the =+ and %= business uses MonadState
08:45:24 <mietek> xelxebar: if you can use Nix, it’s a good choice. I’ve found its UI not too friendly, which was one of the reasons why I built Halcyon.
08:45:46 <mietek> xelxebar: there are people who swear by it.
08:46:32 <roconnor> let me see
08:47:59 <roconnor> michaelt: I kinda recall that it is impossible to zoom through arbitrary transformation layers.
08:48:01 <michaelt> roconnor https://github.com/michaelt/lens-simple/blob/master/Lens/Simple.hs#L142  It isnt like Control.Lens.zoom (if I understand it)
08:48:31 <roconnor> oh on the return side only
08:48:33 <roconnor> hmm
08:48:55 <michaelt> roconnor: I think the only difference from Control.Lens.zoom is that it has to instantiate the prior state thing to StateT (differently for the two modules)
08:49:38 <michaelt> roconnor: right, in fact it will apply to any MonadState thing but it has to specialize it before it acts
08:50:11 <michaelt> roconnor: Control.Lens.Zoom introduces a Zoom m n x y class to deal with this.  
08:50:17 <michaelt> roconnor: if I understand
08:52:33 <xelxebar> mietek: Thanks. I like how you casually mention that you *built* halcyon.
08:52:42 <roconnor> this zoom_ function is a bit weird.  You have access to the larger state inside your subroutine.
08:53:09 <mietek> xelxebar: well, compared to things like GHC it’s not really a big deal
08:53:13 <elben_> mietek: sorry, got disconnected. `locale` shows http://lpaste.net/1901433724755509248
08:53:16 <michaelt> roconnor: it occurred to me because I had trouble recovering a MonadState thing after zooming , when someone wanted it.
08:53:41 <michaelt> roconnor: yes, it's weird, I put it in for the moment but was thinking about it
08:53:50 <xelxebar> mietek: It's not clear to me how I should go about installing system-accessible tools like xmonad and friends. Individual projects and then puth the binaries on PATH?
08:53:53 <mietek> elben_: that looks all right. It might be what ProofTechnique said, then — 
08:54:10 <mietek> elben_: maybe you need to try building a branch of ghc-mod
08:54:18 <mietek> elben_: I haven’t used it myself
08:55:10 <ProofTechnique> xelxebar: That's what I do. I install tools in sandboxes under a common root and then just add all the .cabal-sandbox/bin dirs to my PATH.
08:55:11 <mietek> xelxebar: so, there’s a lot of freedom, which makes it confusing.
08:55:16 <michaelt> roconnor: the use case was, to join a MonadState s m => m () and MonadState t m = m ()   into a MonadState (s,t) m => m () in a discussion of mtl 
08:55:29 <mietek> xelxebar: I imagine you’d want to keep your xmonad up-to-date, right?
08:55:36 <xelxebar> Yes
08:55:45 <mietek> xelxebar: so if you build from source, that’s always a bit of a pain
08:55:49 <mietek> xelxebar: are you on OS X?
08:56:04 <xelxebar> Currently ghc, xmonad and depenedencies are just installed via my distro's package manager.
08:56:07 <xelxebar> Arch Linux
08:56:10 <mietek> Right.
08:56:18 <mietek> xelxebar: does Arch always build from source?
08:56:27 <xelxebar> Typically, no.
08:56:31 <muller> Does anyone here have experience with Spock framework?
08:56:36 <mietek> muller: a bit
08:56:47 <elben_> ProofTechnique: is that DanielG/ghc-mod release branch not the same as https://github.com/kazu-yamamoto/ghc-mod/tree/release ?
08:57:00 <mietek> xelxebar: are you unhappy with having such binaries installed using Arch’s package manager?
08:57:05 <muller> mietek, I am tring to use postgresql-simple with spock. 
08:57:38 <ProofTechnique> elben_: Oh, you know, I may have copied the wrong URL. I think I built from the master branch. Let me check.
08:57:40 <michaelt> roconnor: it came up here, http://www.reddit.com/r/haskell/comments/39qold/ether_mtlcompatible_extensible_effects_based_on/cs5v6xs but don't waste your time looking at it. 
08:57:49 <roconnor> michaelt: I'll think about it, but I'm not a huge fan of this idea.
08:57:50 <muller> mietek, But I cannot seem to get it work with the suggested way (As showin in the sample app)
08:58:09 <michaelt> roconnor: I think I'm not either, it just arose in practice
08:58:10 <mietek> muller: OK — you’ll have to give slightly more detail
08:58:22 <elben_> ProofTechnique: I am already on the latest from release branch, 5.2.1.2.
08:58:31 <ProofTechnique> elben_: Oh, there have been updates on the actual master to bring it in line with that fork. Installing from master should work.
08:58:51 <michaelt> roconnor: in fact its just abstract + zoom , and there are two zooms, so there would be two zoom_ s hiding their differences behind a signature
08:58:53 <voidnoid> not sure if this is OT but can anyone suggest some good books that have a relatively good base/basis in theory and rigorous approach etc?
08:58:54 <muller> mietek, yes. let me write it down in a snippet.
08:58:55 <mietek> xelxebar: what I do is, install as much as I can with the de-facto OS X package manager, brew, as it has binary packages for things like shellcheck and other Haskell apps
08:59:04 <voidnoid> I'm aware of "learn you a haskell for great good", wondering what others might be out there
08:59:08 <xelxebar> mietek: I'm somewhat agnostic as to where these come from. However, on my old machine I ended up having a mixture of distro packages and cabal packages installed which caused some headaches. I do remember specifically needing certain packages not in my distro's repo.
08:59:11 <voidnoid> also I guess even non haskell books would be cool
08:59:24 <roconnor> michaelt: yeah.  I think it is fine to use in your own code if you are careful, but I'm not a big fan of adding dangerous APIs.
08:59:37 <mietek> xelxebar: right. For those packages, I usually clone their source repo, so that I can manually update their source whenever I remember to do that. This sort of sucks.
09:00:14 <michaelt> roconnor: I just mentioned it because I was thinking about it. In lens-simple only the strict state monad material is exported which may or may not justify it
09:00:23 <mietek> xelxebar: now, installing Haskell projects from source means you need to have the right versions of dependencies, and they usually differ between projects.
09:00:32 <ProofTechnique> mietek: I'm iffy about installing Haskell applications through brew. It pulls in the (last I knew) badly maintained homebrew ghc
09:00:45 <mietek> ProofTechnique: it doesn’t pull in GHC if it has binaries available.
09:00:52 <michaelt> roconnor: since *.State.Strict is what the pipes environment uses as a default
09:00:54 <xelxebar> mietek: So that means separate sandboxes?
09:00:57 <mietek> ProofTechnique: you’re right about brew’s GHC not being very good.
09:01:02 <ProofTechnique> Oh, last I tried something like that, it did. Glad that got fixed.
09:01:04 <elben_> voidnoid: I found this blog post to be useful: http://bitemyapp.com/posts/2014-12-31-functional-education.html
09:01:20 <voidnoid> elben_: great thanks
09:01:24 <elben_> voidnoid: I myself did the cis194 course then found the NICTA course via that post
09:01:25 <mietek> xelxebar: indeed, as you do not want to have any particular project contaminate your user package DB, or even worse, the global package DB.
09:01:37 <jackhill> voidnoid: I've been reading http://search.library.duke.edu/search?id=DUKE000987517 (Basic category theory for computer scientists)
09:02:07 <mietek> xelxebar: so you can just manually `cabal sandbox init && cabal install --dep && cabal configure --prefix=/opt/whatever && cabal build && cabal copy`
09:02:13 <jackhill> voidnoid: and http://search.library.duke.edu/search?id=DUKE002476694 (Purely Functional Data Structures)
09:02:21 <muller> mietek, Can you please take a look http://lpaste.net/134599
09:02:21 <mietek> xelxebar: or, you can `halcyon install --prefix=/opt/whatever` which amounts to the same thing
09:02:37 <mietek> xelxebar: there are additional subtleties.
09:03:07 <xelxebar> mietek: Thank you for the clear explanation.
09:03:09 <michaelt> roconnor: the point of the lens-simple package fwiw is to avoid imports like this http://lpaste.net/revision/99807 http://lpaste.net/96860
09:03:15 <mietek> xelxebar: one subtlety is, many Haskell projects do not declare version constraints on their dependencies.
09:03:26 <mietek> xelxebar: which means that you may get whatever version is currently the newest on Hackage.
09:03:29 <mietek> xelxebar: which may or may not work.
09:03:55 <mietek> xelxebar: for this reason, Halcyon warns you if your constraints aren’t declared, with the intention of you saving that set of constraints for the future.
09:04:09 <xelxebar> mietek: Is there a way to have packages share dependencies when possible?
09:04:40 <mietek> xelxebar: sort of. Nix does this pervasively, but it comes at a cost — Nix has its own package format; you have to cabal2nix; etc
09:04:53 <mietek> xelxebar: it’s not easy to do it with just Cabal alone, because of absolute path issues.
09:05:04 <mietek> xelxebar: there’s ongoing work on making this easier, along multiple fronts.
09:05:05 <michaelt> roconnor also, would it be easy to add a 'magnify' to do the reader equivalent of zoom . I haven't thought about it
09:06:01 <mietek> xelxebar: Stack makes this easier, to some extent. Halcyon allows this on a granularity of entire sandboxes: if project A depends on packages S(A), and project B on S(B), and S(A) is a subset of S(B), then S(A) will be automatically extended to form S(B), saving time.
09:06:20 <mietek> xelxebar: and there’s a GSoC project for Cabal, also underway, which should help with this...
09:06:44 <muller> mietek, Can you please take a look http://lpaste.net/134599
09:06:49 <mietek> xelxebar: I recommend taking a look at https://halcyon.sh/tutorial/ and https://robots.thoughtbot.com/building-haskell-projects-with-halcyon
09:07:01 <xelxebar> mietek: This is good to know. The recent survey that went out gives strong motivation for making a cabal replacement.
09:07:23 <mietek> xelxebar: people are quick to want to replace things
09:07:37 <xelxebar> mietek: Ha! Already have that tutorial page open.
09:09:20 <xelxebar> s/replacement/improvement/ and I think it still stands. I'm going to take a look at the tools and information you gave me and try some stuff out.
09:09:34 <mietek> xelxebar: cool. Feel free to join #haskell-deployment where there’s slightly less traffic.
09:09:37 <xelxebar> Thank you for the very thorough help
09:09:43 <mietek> You’re welcome.
09:10:26 <mietek> muller: where is runQuery defined?
09:11:01 <muller> runQuery is part of Spock.
09:11:14 <muller> mietek, https://hackage.haskell.org/package/Spock-0.7.9.0/docs/Web-Spock-Shared.html#t:SpockConn
09:11:31 <muller> mietek, method of HasSpock typeclass.
09:12:05 <mietek> runQuery :: (SpockConn m -> IO a) -> m a
09:12:21 <mietek> muller: this is what shows up in your error as "Expected type: SpockConn IO -> IO GHC.Int.Int64"
09:12:24 <phaazon> hey, is there a known abstraction for a type that is both covariant and contravariant?
09:12:44 <mietek> muller: your addUser function expects an argument of type Connection, which doesn’t unify with SpockConn IO
09:13:40 <muller> mietek, yes. I understand that. But how can I use the connection?
09:13:57 <mietek> muller: where is the Connection type defined?
09:14:21 <mietek> Ah, postgresql-simple
09:14:24 <mietek> https://hackage.haskell.org/package/postgresql-simple-0.4.10.0/docs/Database-PostgreSQL-Simple.html#t:Connection
09:15:18 <muller> mietek, yes
09:15:40 <mietek> ocharles_: ping
09:16:47 <xelxebar> mietek: This URL in the Halcyon setup.sh script is 404ing for me: https://github.com/mietek/bashmenot/raw/master/src/platform.sh%27
09:17:09 <mietek> xelxebar: %27
09:17:13 <xelxebar> mietek: nevermind... extraneous char
09:17:19 <mietek> xelxebar: also, you can just do the setup by hand
09:18:11 <xelxebar> mietek: Yeah. I'm always nervous runnding scripts off the internet with superuser priviledges, so just taking a quick look at what you're doing.
09:18:38 <mietek> xelxebar: good instincts. I’m probably getting rid of the setup script in the future altogether.
09:18:53 <mietek> xelxebar: sudo mkdir /app && sudo chown $( id -u ):$( id -g ) /app
09:19:42 <mietek> xelxebar: that’s the only thing sudo for which is needed; on OS X you also need `brew install bash coreutils git pigz`
09:19:48 <int-index> Why does mtl use liftCallCC' that violates the uniformity law, if liftCallCC is available (that doesn't)?
09:20:24 <mietek> xelxebar: Halcyon itself can be just git cloned anywhere you want
09:20:49 <mietek> xelxebar: you activate the Halcyon environment by doing `eval $"( /wherever/halcyon paths )"`
09:20:55 <mietek> oops, typ
09:20:59 <mietek> xelxebar: you activate the Halcyon environment by doing `eval "$( /wherever/halcyon paths )"`
09:21:38 <mietek> xelxebar: it can be nicely aliased to, say, `alias halcyon-on='eval "$( /wherever/halcyon paths )"'`
09:21:46 <xelxebar> mietek: Oh. Awesome. Thank you. It looks like we need pigz as well though?
09:22:01 <mietek> xelxebar: pigz is a parallel gzip; speeds up things; is optional.
09:22:25 <mietek> muller: good question.
09:22:33 <xelxebar> mietek: I guess you could also just put the output of /path/to/halcyon paths in .profile?
09:22:52 <mietek> muller: that’s what the setup script does by default, but user testing has showed this not to be the best default.
09:23:00 <mietek> muller: I’m getting rid of it soon.
09:23:26 <mietek> muller: for one, the OS X linker really doesn’t like non-existent directories in LD_LIBRARY_PATH, and throws up warnings.
09:23:29 <mietek> er
09:23:34 <mietek> s/muller/xelxebar/
09:23:40 <muller> muller, Not sure you talking to me...
09:23:44 <mietek> muller: yep, sorry.
09:23:59 <muller> mietek, No probs.
09:24:13 <mietek> muller: so I can’t actually find how SpockConn relates to Connection
09:25:05 <muller> mietek, I pass a function that returns a IO Connection, to the spock function at the top
09:25:23 <muller> mietek,  spock sessCfg (PCConn $ ConnBuilder connectDb close (PoolCfg 10 10 10))  []  (babloosApp)
09:28:34 <mietek> muller: type SpockAllM r conn sess st a =
09:28:35 <mietek>     SpockAllT r (WebStateM conn sess st) a
09:29:04 <mietek> newtype WebStateM conn sess st a = WebStateM { runWebStateM :: ReaderT (WebState conn sess st) (ResourceT IO) a }
09:29:05 <mietek>     deriving (Monad, Functor, Applicative, MonadIO, MonadReader (WebState conn sess st))
09:29:11 <mietek> data WebState conn sess st
09:29:11 <mietek>    = WebState
09:29:11 <mietek>    { web_dbConn :: Pool conn
09:29:11 <mietek>    , web_sessionMgr :: SessionManager conn sess st
09:29:11 <mietek>    , web_state :: st
09:29:12 <mietek>    }
09:29:14 <muller> mietek, ok
09:29:15 <mietek> uh.
09:29:47 <mietek> instance MonadTrans t => HasSpock (t (WebStateM conn sess st)) where
09:29:47 <mietek>     type SpockConn (t (WebStateM conn sess st)) = conn
09:32:31 <mietek> muller: this is rather confusing.
09:33:04 <muller> mietek, Mm..yes.
09:33:19 <mietek> muller: take a look at https://github.com/agrafix/Spock/blob/master/src/Web/Spock/Internal/Monad.hs#L31
09:33:34 <mietek> muller: it looks like you might want to use this function
09:33:47 <mietek> muller: or do a similar sort of thing somehow
09:34:17 <muller> mietek, Ok. let me take a look..
09:34:21 <mietek> muller: I have to give up here; I’d recommend asking people with more monad transformer stack expertise than myself
09:34:35 <mietek> Personally, I don’t like this sort of style
09:35:56 <muller> mietek, Can you tell me what style. I don't want to follow any particular style. It is just that I would like to make use of builting db connection manageemnt.
09:36:28 <Geekingfrog> mietek, can you elaborate? I'm a beginner but I was under the impression that using nested monad transformers was actually a good approach to get anything complex done (see: http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf)
09:37:07 <mietek> Geekingfrog: it’s a style.
09:37:13 <Guest46722> hey guys, I started learning haskell today and im having a hard time grasping the typeclasse thing , if I have a function addVector like this http://pastebin.com/mV0pceRh , what is the difference between having "(Int,Int)"  when defining the types of the function or having the Num a thing?
09:37:23 <michaelt> Geekingfrog: they just take a little getting used to. 
09:37:25 <mietek> Geekingfrog, muller: take a look at http://www.willamette.edu/~fruehr/haskell/evolution.html
09:37:36 <Geekingfrog> What would be an alternative?
09:38:11 <michaelt> Guest46722: well, your program will also work with Double, Float, Integer etc.
09:38:18 <hodapp> ahh, now I understand why I might want to use a sum type with existentials!
09:38:26 <hodapp> thanks, whoever told me that yesterday
09:38:37 <Guest46722> ah okay, thanks :)
09:39:14 <michaelt> Guest46722: in a concrete program, you probably won't have any use for the added generality, so you would special the signature to addVectors :: (Int, Int) -> (Int,Int) -> (Int,Int)
09:39:52 <michaelt> Guest46722: if you are using (Int,Int) all over the place, you can write type Vec = (Int, Int) then you can write addVectors:: Vec -> Vec -> Vec 
09:40:06 <michaelt> Guest46722: which might or might not make things clearer
09:40:23 <mietek> Geekingfrog: monads are one pattern for abstracting computation. You can choose not to use it.
09:40:34 <mietek> Geekingfrog: well, inasmuch as you can’t really avoid using the IO monad.
09:40:55 <Geekingfrog> mietek: uh? do you have pointers to other options?
09:41:04 <mietek> Geekingfrog: another pattern which has gained popularity is applicative style
09:41:27 <tommd> I just created "readProcessMemory", which is like `readProcess` except it also returns a sampling of the memory use (list of samples at 100ms time steps).
09:41:45 <tommd> Have I recreated something on hackage?
09:42:16 <mietek> Geekingfrog: here’s an old paper about monadic parsing; https://www.cs.nott.ac.uk/~gmh/pearl.pdf
09:42:54 <mietek> Geekingfrog: also http://book.realworldhaskell.org/read/using-parsec.html
09:43:16 <Pamelloes> I've found I tend to use ((a,b),c) over (a,b,c). Is this a general trend within Haskell?
09:43:34 <mietek> Geekingfrog: here’s a question about the difference between monadic- and applicative-style parsing: http://stackoverflow.com/questions/7861903/what-are-the-benefits-of-applicative-parsing-over-monadic-parsing
09:43:42 <Forkk> Pamelloes, it depends on the situation
09:43:49 <mietek> Geekingfrog: and a concrete application for applicative-style parsing: https://github.com/pcapriotti/optparse-applicative
09:43:56 <Geekingfrog> I think I read at some point that monads are required for backtracking
09:43:57 <Forkk> also, if you want to use fst and snd, then 3-tuples won't do any good
09:44:05 <mietek> Geekingfrog: note this doesn’t have to do with monad _transformer stacks_
09:44:07 <Forkk> unless you use lens
09:44:11 * hackagebot serversession 1.0.1 - Secure, modular server-side sessions.  http://hackage.haskell.org/package/serversession-1.0.1 (FelipeLessa)
09:44:32 <muller> mietek, I am not sure how to use the link (evolution) you sent..
09:44:38 <Pamelloes> Forkk: Could you elaborate on some situations where ((a,b),c) would be better and some where (a,b,c) would be better?
09:45:01 <Geekingfrog> Is there any applicative style for replacing something like the RWS monad transformer?
09:45:23 <mietek> muller: sorry, that was more like background information with regard to various styles.
09:45:26 <Forkk> Pamelloes, if you use ((a, b), c), then you can use `fst . fst` to get `a` and `snd . fst` to get `b`
09:45:34 <mietek> muller: Spock uses a style which isn’t readable to me.
09:45:35 <Forkk> (a, b, c) is more semantically clear though
09:45:37 <mietek> muller: maybe someone else can help.
09:45:43 <Forkk> so honestly I'd probably recommend that
09:45:47 <muller> mietek, Oh. ok. 
09:46:00 <Forkk> you would have to define your own functions to access each element though
09:46:28 <Forkk> honestly, though, in my time writing Haskell, 3 element tuples very rarely come up
09:46:34 <felixn> is there a good idiom for computing a data structure, where each step returns the new state, and then you compute off that?  sorry that's super abstract .. but basically I've been writing really confusing folds .. perhaps I could instance my own foldable?
09:46:42 <Forkk> at some point, you need to ask yourself if a record data type would be better
09:47:15 <Pamelloes> Yep, that's literally what I was just thinking about.
09:47:22 <hodapp> With something like "data Foo = forall f . Bar f => Foo f", is there a particular term for what happens to some particular 'f' when one constructs a Foo?
09:47:58 <johnw> felixn: can you show me the type of such a fold?
09:48:06 <Geekingfrog> felixn, I did something similar using the state monad, but I'm myself pretty new to haskell.
09:48:21 <Pamelloes> hodapp: Well, the whole thing is called existential quantification
09:48:45 <Pamelloes> hodapp: So I'm going to go on a limb here and say that f would be "existentially quantified." Note I could be wrong.
09:48:50 <Geekingfrog> btw thanks mietek for the background, I'll read these resources in the next few days
09:49:10 <Iceland_jack> hodapp: Are you thinking of ‘instantiation’? As in “f gets instantiated to ...”
09:49:22 <hodapp> Iceland_jack: perhaps...
09:49:31 <Pamelloes> Iceland_jack: Note the forall, f isn't being instantiated.
09:49:34 <mietek> Geekingfrog: you’re welcome
09:50:04 <mietek> Geekingfrog: monad transformer stacks have their uses; they make imperative-style algorithms easy to express; doesn’t mean they’re the only way to write
09:50:16 <hodapp> I guess I'm looking for the proper term giving that a specific 'f' is captured into some specific 'Foo' (even if it's indirect via 'Bar') and can't really escape it
09:50:36 <hodapp> Foo isn't parametrized over it, but it's 'captured' it or something
09:50:58 <Iceland_jack> Pamelloes: If you have (data F = ∀a. Show a => MkF a) you can construct a value of type F by (MkF True)
09:51:12 <Iceland_jack> in which case 'a' gets instantiated to Bool
09:51:16 <felixn> johnw: so I'm trying to ... back propagate dependencies, in a graph, and basically I'm folding to do that.  so I have a structure that says what I've already done, and what I have to do, and also the current state of the resolved structure, and each computation returns new things to resolve
09:51:34 <Iceland_jack> Being an existential type it's not reflected in the type
09:52:35 <tmtwd> >  foldr f z [a,b,c]
09:52:37 <lambdabot>  f a (f b (f c z))
09:53:01 <Pamelloes> Iceland_jack: Ok, that makes sense.
09:54:03 <michaelt> felixn: well, the way you are describing it, it sounds like StateT (AlreadyDone,Working) m (NewThingsToResove) or something like that
09:54:05 <felixn> Geekingfrog: yea, hmm, I'd have to think about that, I've used parsec once to cleanup a nasty fold, I don't think this algo would work with parsec, but maybe state, hmm
09:54:44 <felixn> michaelt: ok yea, let me think about that
09:55:53 <felixn> thanks a lot!  unfortunately I have to start working now >_<  I shall work on this later, state is most likely going to work out really well
09:57:00 <johnw> felixn: if you show me the type of one of these folds, I may recognize the structure
09:57:38 <johnw> felixn: what you've described vaguely fits the notion of unfoldr
09:58:24 <michaelt> @type unfoldr
09:58:25 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
09:58:27 <johnw> but if there are indeed foldr elements to it as well, then you may be in hylomorphism
09:59:12 * hackagebot serversession-backend-acid-state 1.0.1 - Storage backend for serversession using acid-state.  http://hackage.haskell.org/package/serversession-backend-acid-state-1.0.1 (FelipeLessa)
10:00:05 <michaelt> felixn: what is the initial input? a list?
10:03:34 <Geekingfrog> johnw, oÔ that's a really cool function!!!
10:06:06 <michaelt> > unfoldr Data.List.uncons "hello"
10:06:08 <lambdabot>  "hello"
10:07:24 <michaelt> > foldr (:) [] "hello"
10:07:26 <lambdabot>  "hello"
10:07:29 <thebnq> Does lambdabot support dynamic reloadable plugins?
10:09:12 * hackagebot smoothie 0.2 - Smooth curves via several splines and polynomials.  http://hackage.haskell.org/package/smoothie-0.2 (DimitriSabadie)
10:09:21 <felixn> johnw: michaelt: sorry, I haven't written the code, my head hurt too much to write it with foldr, needed an idiom to bring the problem closer to my brain, I'll send you the code when I finish though!
10:09:39 <felixn> johnw: michaelt: https://gist.github.com/munro/32eff8a4db3012776c03 <-- here's a mildly gross fold I wrote awhile ago, I think this could be replaced with parsec
10:11:45 <johnw> felixn: using data and newtype would help the readability of that function enormously
10:11:54 <mpickering> ProofTechnique: Hello, I am here now for an hour if you need something
10:12:08 <ProofTechnique> Oh, hey!
10:12:18 <johnw> i.e., you've assigned specific meanings to Just/Left/the two lists, but since you are using general data types, it's not clear unless you understand the function well
10:12:30 <ProofTechnique> I was just looking for pointers on having a Slack bot perform some action when a particular user logs in
10:15:00 <mpickering> ok sure, the main gist is that you need to write a function f :: Event -> Slack s () which describes how to handle each of the events
10:15:34 <mpickering> the message sending event is called "Message" and the second field contains the submitter
10:15:41 <mpickering> I will write  gist now with what it might look like
10:15:54 <ProofTechnique> Thanks very much, mpickering!
10:16:08 <felixn> johnw: yea, it's completely unreadable, also the algo didn't even need a fold now that I look at it, just a findIndex and a splitAt
10:17:07 <johnw> felixn: also, you're really combining two functions into one using Either
10:17:21 <johnw> it's be even clearer to have one function taking String for the second arg, and another taking TypePattern
10:17:31 <ProofTechnique> I have something like bot (Message cid sbt msg _ _ _) = do { let uid = /* deconstruct sbt, show UserId */ ; when (uid == "known user id") (do a thing), but I think I'm approaching that the wrong way, so I look forward to your gist :)
10:18:49 <mpickering> ProofTechnique: I think that looks right.. what did you have in mind?
10:19:22 <mpickering> although you don't need to show the user id and just compare them
10:19:55 <ProofTechnique> Ah, okay. I'll give that a shot while I wait. Thanks very much.
10:20:12 <phaazon> hey
10:20:12 <breadmonster> Hey guys.
10:20:16 <phaazon> I have a type like
10:20:29 <phaazon> newtype Foo a = Foo { runFoo :: Bar a -> Maybe a }
10:20:41 <phaazon> I can’t make that either a Functor nor a Contravariant
10:20:46 <johnw> correct
10:20:48 <phaazon> is there something I can do?
10:20:55 <phaazon> some abstraction I might have missed?
10:21:01 <mpickering> although.. if you just have the Id string then you'll need to construct a UserId..
10:21:01 <phaazon> because I need two functions
10:21:09 <phaazon> (a -> b) and (b -> a)
10:21:11 <breadmonster> phaazon: Is Bar a functor?
10:21:16 <phaazon> breadmonster: yes
10:21:28 <phaazon> it’s a Vector, actually
10:21:35 <phaazon> newtype Foo a = Foo { runFoo :: Vector a -> Maybe a }
10:23:07 <breadmonster> phaazon: `instance Functor Foo where fmap f = Foo . fmap f . runFoo`
10:23:11 <breadmonster> ?
10:23:26 <phaazon> nope
10:23:39 <ProofTechnique> mpickering: If I get this working, I'll be sure to PR some documentation your way, too. :)
10:23:47 <phaazon> breadmonster: it can’t work with Functor
10:24:17 <phaazon> I need something like CoContravariant
10:24:25 <michaelt> it's has various monoid instances, of course, phaazon 
10:24:25 <phaazon> and I have no idea how I should that
10:24:37 <breadmonster> I wonder why that doesn't admit a functor instance.
10:24:51 <phaazon> breadmonster: consider the such a theoric instance for a -> a
10:24:59 <michaelt> the 'a' is in both positive and negative position so neither Functor nor Contravariant works
10:25:04 <phaazon> or a -> Bool, for simple
10:25:04 <mpickering> ProofTechnique: haha ok thanks the library hasn;t been stress tested for usability so any feedback is welcome
10:25:13 <roconnor> michaelt: We could add a magnify function to do a "zoom" for reader that operates on Getters.  I'm not sure how useful it is because it is just an application of withReader.
10:25:15 <mpickering> I'm aware the Id situation is a bit icky 
10:25:28 <phaazon> you can’t fmap (a -> Bool)
10:25:33 <phaazon> you can only contramap it
10:25:43 <phaazon> the issue is that, in my case
10:25:48 <phaazon> I need both properties
10:25:54 <phaazon> Vector a -> Maybe a
10:26:05 <michaelt> roconnor: oh interesting,let me think
10:26:09 <phaazon> with a contravariant functor, I can change Vector a into Vector b
10:26:14 <roconnor> phaazon: there is an "Invariant Functor" that takes both (a -> b) and (b -> a) somewhere, I think.
10:26:15 <phaazon> but I cannot change Maybe a to Maybe b
10:26:20 <phaazon> oh
10:26:22 <phaazon> cool
10:26:24 <mpickering> I shoud probably just expose the constructors rather than rely on people constructing it via lenses
10:26:42 <phaazon> invmap
10:26:42 <phaazon> yep
10:26:56 <Guest99964> Does anybody have experience iterating in a (MonadIO m => StateT s m a ? I'm getting stack explosion and I'm stuck!
10:27:26 <phaazon> https://hackage.haskell.org/package/invariant-0.1.0/docs/Data-Functor-Invariant.html roconnor 
10:27:28 <johnw> Guest99964: iterating?
10:27:29 <phaazon> that, I guess 
10:27:36 <james_rth> yeah johnw!
10:28:00 <james_rth> so basically, I'm trying to talk to a Kafka client, update state during the way, and iterate
10:28:08 <johnw> what do you mean by "iterate"?
10:28:15 <michaelt> roconnor: I see withReaderT (^. _1) :: ReaderT r m a -> ReaderT (r, b) m a 
10:28:16 <johnw> I'm thinking of the function (a -> a) -> a -> [a]
10:28:16 <james_rth> basically just recurse
10:28:34 <johnw> james_rth: paste the code that is exploding?
10:28:43 <james_rth> stream = do { x <- stuff, put x, stream }
10:29:01 <johnw> try changing put x to put $! x
10:29:16 <james_rth> is it all my state updates?
10:29:21 <james_rth> I'm using lens under the hood...
10:29:28 <james_rth> I thought it could be that
10:29:30 <johnw> state is not strict in the state
10:29:52 <james_rth> ok, is there an easy way to force it using lenses?
10:29:56 <johnw> generally this blow up happens if you use modify to build up a state
10:30:10 <james_rth> that's what I'm doing under the hood I guess
10:30:11 <james_rth> eeeek
10:30:31 <johnw> you can force the state at some "sync points"
10:30:45 <johnw> write a strict version of modify, and just call it before you recurse
10:31:09 <james_rth> can you force the entire state to be evaluated?
10:31:24 <johnw> you'll have to do something htat causes it to be evaluated
10:31:33 <james_rth> like list cons?
10:32:00 <johnw> hmm
10:32:17 <johnw> is this really a StateT with IO at the bottom?
10:32:51 <mpickering> ProofTechnique: You can construct Ids with "review getId <user id string>"
10:33:14 <johnw> i mean, you could try this: StateT $ \s -> s `seq` ((), s)
10:33:19 <ProofTechnique> I was playing with lens stuff, but I didn't think of that one. That's very helpful
10:33:51 <roconnor> michaelt: I suppose we could define a maginfy function to compose withReaderT and (^.), but it hardly seems worth it.
10:34:55 <michaelt> roconnor: I agree, I hadn't thought through Reader (I never use it). The question arose because transformers/mtl as a whole were discussed. 
10:34:55 <phaazon> hm, that Invariant is very interesting
10:35:01 <phaazon> looks like some kind of nice way to build up a history :)
10:35:27 <phaazon> because, if I understand it correcctly, an invariant functor can be forward and backword
10:35:36 <phaazon> we can go in both direction without losing information
10:35:42 <phaazon> directions
10:36:44 <james_rth> johnw yeah it is
10:36:52 <james_rth> Got EitherT IO
10:36:56 <roconnor> phaazon: that doesn't sound like the right intuition.
10:37:10 <phaazon> roconnor: well
10:37:22 <phaazon> (a -> b) gives a way to go forward by adding or removing information
10:37:27 <johnw> james_rth: ok, then maybe: put >>= liftIO . evaluate >>= get
10:37:32 <phaazon> and (b -> a) gives a way to « cancel » the forward
10:37:33 <johnw> err, =<<
10:37:57 <james_rth> evaluate lives where?
10:38:01 <james_rth> Control.Monad?
10:38:12 <johnw> @hoogle evaluate
10:38:12 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
10:38:12 <lambdabot> Control.Exception evaluate :: a -> IO a
10:38:12 <lambdabot> Control.OldException evaluate :: a -> IO a
10:38:25 <james_rth> thanks!
10:38:40 <roconnor> phaazon: the b -> a doesn't have to be the inverse of the a -> b.
10:39:59 <roconnor> an invariant functor is more like a profunctor where the positive and negative parameters have been forced to be the same time.
10:40:09 <michaelt> roconnor: but anyone familiar with ReaderT will see how it is done, I guess. It seems the only way in either case to get the fancier type is to make a class with families etc. like class (Magnified m ~ Magnified n, MonadReader b m, MonadReader a n) => Magnify m n b a | m -> b, n -> a, m a -> n, n b -> m
10:40:42 <roconnor> My current thinking is than an invariant functor is code-smell and generally you should split the two type parameters and make a profunctor instead.
10:40:52 <ProofTechnique> mpickering: Great, got that working for responding to a particular user
10:41:08 <ProofTechnique> mpickering: I'd love to see how to rework that to work when the user joins
10:41:20 <ProofTechnique> I don't totally follow Event, yet
10:41:22 <roconnor> michaelt: right, I think that is why lens has a magnify function.
10:41:32 <johnw> james_rth: see also http://stackoverflow.com/questions/28013499/stricter-strict-state-monad
10:41:37 <muller> I have a to call the function runQuery with signature, runQuery :: HasSpock m => (SpockConn m -> IO a) -> m a. What should be the signature of the function (SpockConn m -> IO a) if SpockConn is an internal type?
10:41:58 <shachaf> roconnor: Not a fan of (forall f. Invariant f => f a -> f s) isomorphisms, huh?
10:42:43 <ProofTechnique> mpickering: Oh, and is it possible to get a UserId out of a username? Or would some additions need to be made to support that?
10:43:04 <james_rth> johnw might try that forceState fn
10:43:48 <roconnor> shachaf: Well I'm okay with the principle of that I suppose.
10:44:14 * hackagebot utc 0.2.0.0 - A pragmatic time and date library.  http://hackage.haskell.org/package/utc-0.2.0.0 (LarsPetersen)
10:44:38 <roconnor> shachaf: I think I'm maybe okay with the Invariant typeclass.
10:44:55 <shachaf> roconnor: It should clearly be a superclass of Functor and Contravariant.
10:45:32 <roconnor> shachaf: but most practical instances should always be functor, contrafunctors.
10:45:36 <shachaf> roconnor: Should "class Invariant f => Lensy f where lensy :: f a -> f (e,a)" be a superclass of Contravariant?
10:45:45 <roconnor> with possibly the exception of a WrappedProfuctor.
10:45:51 <mpickering> ProofTechnique: Yes, you see in SlackState there is a field called SlackSession - https://hackage.haskell.org/package/slack-api-0.3/docs/Web-Slack-Types-Session.html#t:SlackSession
10:45:57 <shachaf> And similarly for "class Invariant f => Prismy f where prismy :: f a -> f (Either e a)" a superclass of Functor.
10:46:12 <shachaf> And what should the laws be for these classes? Are they useful for anything other than lenses?
10:46:14 <mpickering> which contains all the information about which users are in the channel when the bot joins
10:46:24 <roconnor> shachaf: sure in theory.  In practice I worry about Haskell ability to handle a fine grain type class heirarchy.
10:46:35 <ProofTechnique> Oh, great!
10:46:41 <mpickering> The problem is that isn't kept updated when events happen..
10:46:58 <mpickering> I admit that would probably be desirable but I didn't get round to implementing that
10:47:01 <shachaf> roconnor: Yes, that's a problem. But if you could have a fine-grained hierarchy would you even want these classes?
10:47:20 <ProofTechnique> Hmm. Well, It would probably be feasible to listen for joins and parts and update accordingly, no?
10:47:24 <roconnor> shachaf: (Phantom f, Applicative f) => Monoid (f a) already seems too be pushing Haskell too far.
10:47:33 <mpickering> yes it would but I haven't implemented it
10:47:48 <ProofTechnique> Maybe I'll take a crack at it if I have some spare time :)
10:48:02 <mpickering> There were a lot of Aeson instances to get right ha..
10:48:13 <roconnor> shachaf: your example (forall f. Invariant f => f a -> f s) is kinda nice because it says that I am willing to accept either a functor, or contrafunctor here.
10:48:14 <james_rth> johnw starting to wonder if it's worth the hassle with StateT and to just try and build some fold somehow...
10:48:43 <johnw> james_rth: I'm sure there are a few ways to solve your problem
10:49:04 <ProofTechnique> mpickering: Can I have a very high-level example of writing an event responder? Say, user A joins, then greet user A?
10:49:30 <james_rth> I think I just need to figure out how to force the state
10:49:37 <james_rth> it doesn't seem to do anything in this example
10:49:38 <roconnor> shachaf: That said, in my AST for a language I was writing, when I split my variable type between positive and negative occurances, a lot of things seemed to become better in my code.
10:49:54 <roconnor> shachaf: an example of splitting my invariant functor into a profunctor.
10:50:02 <ProofTechnique> mpickering: I really appreciate all your help. We just started using Slack, so it was nice to have some fairly straightforward bindings already there :)
10:50:02 <shachaf> roconnor: Yes, I think that's probably true.
10:50:24 <shachaf> Profunctors are the way and the truth and so forth.
10:50:43 <shachaf> glguy has a fancy syntax highlighter that colors positive and negative occurences differently.
10:50:46 <roconnor> I don't know about that, but they are kinda nice.
10:50:52 <roconnor> hah
10:50:55 <roconnor> awesome
10:51:02 <muller> I have a to call the function runQuery with signature, runQuery :: HasSpock m => (SpockConn m -> IO a) -> m a. What should be the signature of the function (SpockConn m -> IO a) if SpockConn is an internal type?
10:51:05 <roconnor> ends and coends are nice too.
10:51:09 <dolio> Getting rid of negative variable occurrences will make things even nicer. :)
10:51:23 <roconnor> dolio: I don't know about that. :D
10:51:24 <shachaf> dolio: ?
10:51:42 <roconnor> dolio: also getting rid of the positive occurences will make things super nice.
10:51:42 <dolio> It will make other things less nice.
10:51:51 <roconnor> no need to worry about any functor instances at all.
10:51:59 <roconnor> Finally it will be like java.
10:52:14 <shachaf> Java has covariance!
10:52:18 <Peaker> is System.Mem.Weak.addFinalizer safe?
10:52:21 <shachaf> For example it has covariant mutable arrays.
10:52:35 <Peaker> Doc says it wouldn't work ForeignPtrs, but will it work with ordinary Ptrs?
10:52:37 <dolio> Having negative things in your syntax trees at all makes certain things not nice, really.
10:52:52 <dolio> The variables are ancillary.
10:53:00 <roconnor> Let me see.
10:53:05 <shachaf> I don't think I understand ends and coends very well.
10:53:18 <roconnor> dolio: I think I was doing PHOAS.
10:53:24 <dolio> Right.
10:53:36 <roconnor> dolio: and in the end I decided PHOAS isn't actually syntax, but it is semantics.
10:54:38 <Saizan> roconnor: NBE much?
10:54:47 <roconnor> Saizan: only all the time!
10:55:05 <roconnor> man, NBE is so good.
10:55:08 <mpickering> ProofTechnique: I will get to it tomorrow
10:55:16 <ProofTechnique> Thanks very much!
10:55:56 <roconnor> shachaf: I'm not sure I understand them either, but I find my self doing (forall a. p a a) regularly.
10:56:12 <mpickering> but you can see all the event types in the "Events" module, there are quite a lot of different ones
10:56:29 <dolio> That's all they are, though. :)
10:56:32 <Saizan> NBE is good, but i never found a presentation that was abstract enough to my taste, rather than ad-hoc
10:56:34 <dolio> Categorical version of that.
10:57:20 <roconnor> dolio: well, there is some universal property that they have for free, but I don't know it off the top of my head, though I probably could derive it.
10:58:23 <minozake> Why are orphan instances bad things?
10:58:28 <roconnor> Saizan: Understood.  There seem to be some adjustments between NBE for typed versus untyped languages of where things are evaluated.
10:59:05 <Peaker> FTGL.Font = Ptr ...     what is a safe way to create a wrapper (IO action) that loads a font and attaches a finalizer to it?
10:59:06 <roconnor> Saizan: I don't think I completely get NBE, but as a general approach to interpreting langauges, it has served me very well.
10:59:15 * hackagebot smoothie 0.2.1 - Smooth curves via several splines and polynomials.  http://hackage.haskell.org/package/smoothie-0.2.1 (DimitriSabadie)
10:59:16 <roconnor> Saizan: I got lazy evaulation for free because Haskell is lazy.
11:00:54 <Saizan> roconnor: *nod*, i just wish defining the interpretation domain was less of an art, especially when i also need soundness and completeness proofs
11:01:27 <roconnor> one day
11:02:05 <Hijiri> minozake: they appear outside of the definition of the type and the class, so it is possible for people to create conflicting instances
11:02:26 <dfeuer> Suppose I have a foldMap variant that looks like this: foldMapGenDeque :: Category h => (forall b c . a b c -> h b c) -> GenDeque a b q -> h b q    Will I be able to implement foldr and foldl variants based on that?
11:02:30 <Hijiri> if you have an instance in the type or the class, anyone using them will see an error when they try to make an instance for it
11:02:41 <Hijiri> in the same place as the type or the class*
11:03:04 <Hijiri> but it is possible for different people to create two separate orphan instances for the same thing
11:03:26 <Hijiri> and then if those people's packages are dependencies for some other thing, they will cause problems since both instances get imported
11:04:17 <Hijiri> so basically, having the instances in the same module as the typeclass or the type makes the instance "canonical"
11:04:40 <minozake> Hijiri: Ah.  So I'm guessing adding a Show instance to something for debugging purposes that doesn't already have it is likely not to be an issue.  I thought it was something more catastrophic.
11:05:11 <Hijiri> as long as your module isn't part of some library package, it probably won't cause issues
11:06:07 <Hijiri> The other thing is if the original type or typeclass does eventually include an instance
11:06:12 <Hijiri> then your orphan instance will break
11:06:46 <dolio> roconnor: The universal property is: forall x. (forall a. x -> p a a) -> x -> (forall a. p a a)
11:06:50 <minozake> I see.
11:06:52 <Hijiri> but for something like a Show instance it probably wouldn't matter too much
11:07:05 <minozake> Thanks, Hijiri!
11:08:21 <Saizan> dolio, roconnor: i guess the extra thing is the dinaturality, but you can sort of imagine parametricity carries over
11:10:04 <dolio> And for coends it's: forall y. (forall a. p a a -> y) -> (exists a. p a a) -> y
11:11:46 <gamegoblin> @pl \a b -> forever $ a >>= b
11:11:46 <lambdabot> (forever .) . (>>=)
11:13:06 <nak> gamegoblin i think your first one is more legible
11:13:20 <gamegoblin> nak: of course. Was just curious what it’d come up with.
11:17:06 <michaelt> dfeuer: are you using type-aligned?  
11:17:22 <dfeuer> michaelt, sorry, I don't even know what that means.
11:17:42 <michaelt> dfeuer: oh, https://github.com/atzeus/type-aligned/blob/master/Data/TASequence.hs 
11:18:04 <michaelt> dfeuer: it's used for fancy implementation of free monads and so on
11:18:34 <dfeuer> michaelt, I'm not using that package, but I'm doing something similar.
11:18:43 <dfeuer> Although I dn't know why :-P
11:19:05 <dfeuer> I stole the idea from copumpkin's finger trees, and I'm trying to apply it to the rather simpler implicit deques.
11:19:36 <michaelt> dfeuer: that's what I wondered. There are general 'fmap' equivalents for all of those indexed queues ands on, but I guess folds didn't occur
11:20:20 <dfeuer> michaelt, I don't know if folds are *useful*, but they do seem to make sense.
11:22:27 <breadmonster> dfeuer: What are you doing?
11:22:36 <dfeuer> michaelt, the most basic fold is just composing all the elements of the sequence. The sort of foldMap I'm playing with goes a bit beyond that, in part because I don't think there's a *direct* way to implement the basic fold for nested structures.
11:22:59 <dfeuer> breadmonster, just messing around trying to learn stuff.
11:26:17 <michaelt> dfeuer: the function you imagined above is the fmap generalization , tmap as it is in the library
11:28:09 <dfeuer> michaelt, I don't think so. tmap keeps the outermost constructor the same, as one would expect from a "mappish" thing.
11:28:37 <michaelt> dfeuer: the outermost constructor here is GenDeque
11:28:47 <michaelt> dfeuer: messed up again
11:28:53 <dfeuer> OK.
11:28:58 <michaelt> dfeuer: my thought was, there are two steps
11:29:21 <michaelt> one the map (tmap) to some category with id and . 
11:29:41 <dfeuer> Well, for my purposes, it seems easier to define foldMap directly than as a map plus a fold, and to define the plain fold in terms of foldMap.
11:29:46 <michaelt> then you can fold id (.) basically
11:30:16 <dfeuer> foldGenDeque q = foldMapGenDeque (\x,y,z->z) q     or so.
11:30:17 <michaelt> dfeuer: the other feature of all sequences is tviewr tviewl 
11:30:42 <y> what's the syntax (\x,y,z -> _) ? 
11:30:48 <y> @type (\x,y,z -> z) 
11:30:49 <lambdabot> parse error on input ‘,’
11:30:56 <Welkin> no commas
11:31:03 <Welkin> \x y z -> ...
11:31:12 <y> I thought it was some kind of pattern matching on tuples for a moment :) 
11:31:26 <dfeuer> michaelt, yeah, but I'm actually doing this in Idris rather than Haskell, so I want more powerful views. I think I want my view of the left to include a "for all functions, if you foldMap the function over the tail, and compose with the head, you get the result of foldMapping over the whole."
11:31:26 <byorgey> y: yeah, I think dfeuer just wrote it wrong =)
11:31:33 <Welkin> \(x, y, z) -> ... would be a three-item tuple
11:31:36 <byorgey> of course you can do  (\(x,y,z) -> z)
11:31:51 <dfeuer> Welkin, yeah, I was translating from Idris to Haskell syntax and missed a bit :P
11:31:58 <byorgey> hehe
11:32:41 <michaelt> dfeuer: yes I see.  I am stuck thinking about foldr for type-aligned TASequence s
11:33:01 <dfeuer> michaelt, the foldMap is *much* easier to think about.
11:33:18 <dfeuer> The "consing" function passed to foldr ends up having three free type variables.
11:33:58 <dfeuer> Or to put it more precisely, takes three type arguments.
11:34:16 <dfeuer> That avoids the Category constraint, but it's uuuuuugly.
11:34:44 <dfeuer> Anyway, michaelt, my real question is whether the foldr can be implemented using the foldMap.
11:34:52 <dfeuer> foldrGenDeque : {a, h : Arr} -> ((b, c, d : Type) -> h b c -> a c d -> a b d) -> (p,q,r : Type) -> a q r -> GenDeque h p q -> a p r
11:35:44 <dfeuer> In Haskelly notation,     foldrGenDeque :: (forall b c d . h b c -> a c d -> a b d) -> a q r -> GenDeque h p q -> a p r
11:44:17 * hackagebot Cabal 1.22.4.0 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.22.4.0 (ryant)
11:45:17 <japesinator> is it possible to emulate the behavior of curl -k in wreq?
11:46:14 <int-index> Is there a way to create a type 'on the fly'? E.g I want to define some `foo :: Proxy Foo` without defining the type Foo.
11:46:35 <int-index> Perhaps some hacks with existential quantification?
11:46:41 <shachaf> What do you want Foo to be?
11:46:50 <int-index> Something that unifies only with the type of `foo`
11:47:02 <int-index> Currently I use an empty data declaration.
11:47:54 <shachaf> i,i "-- skolem variables, do not export!"
11:48:02 <dfeuer> int-index, I think some hacks with existential quantification, yes, but I don't think you're going to be able to set it free.
11:48:06 <shachaf> Is foo a top-level declaration?
11:48:12 <int-index> shachaf: Yes.
11:48:25 <dfeuer> That might be troublesome then?
11:48:26 <shachaf> You might be best off defining a type and not exporting it. :-(
11:48:30 <shachaf> Oh, great.
11:48:51 <favetelinguis> how are the functions , and ,, applied infox? 3 , 3 does not work?
11:49:06 <mniip> there are no such functions
11:49:10 <int-index> favetelinguis: You need parentheses.
11:49:16 <int-index> > (3, 3)
11:49:18 <lambdabot>  (3,3)
11:49:20 <dfeuer> > (,,) 3 5 6
11:49:21 <lambdabot>  (3,5,6)
11:49:39 <dfeuer> > (,3) 5 -- only works with TupleSections extension
11:49:40 <lambdabot>  (5,3)
11:49:47 <mniip> (,,) is special syntax, not a function called ',,'
11:50:04 <int-index> dfeuer: How would that be troublesome?
11:50:12 <dfeuer> Well, (,,) is a function called (,,).
11:50:24 <mniip> dfeuer, a constructor named (,,)
11:50:30 <dfeuer> int-index, because existentials can't get that high.
11:50:58 <dfeuer> mniip, yes, that is more detailed, but constructors are (special) functions.
11:51:07 <dfeuer> aaaanyway.
11:52:44 <dfeuer> int-index, you can only put an existential inside a datatype, and you can only see one by pattern matching on a datatype. So tricks with existentials that give you things that won't unify with other things are limited to the right hand sides of pattern matches.
11:53:29 <int-index> dfeuer: Got it, thanks.
11:54:07 <japesinator> is there even a better place to ask wreq-related questions?
11:54:14 <japesinator> I just want to ignore a certificate
11:54:17 * hackagebot cabal-install 1.22.5.0 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.22.5.0 (ryant)
11:54:47 <dfeuer> japesinator, there's probably a mailing list or something. ALso try StackOverflow.
11:58:01 <lpaste> mmachenry pasted “Applicative Parser” at http://lpaste.net/134607
11:58:18 <mmachenry> Can anyone suggest ways to improve that code?
11:59:20 <johnw> you might want to define asTime = fmap strToTime
11:59:40 <johnw> but otherwise, it's good
12:00:27 <S11001001> mmachenry: strToTime needs to be able to fail the parse.  So you should feed to it via =<< and traversal.
12:00:53 <S11001001> e.g. replace fromJust with (maybe (fail "not a date") id), continue from there
12:00:53 <johnw> oh, I missed the fromJust!  not good not good
12:01:31 <mmachenry> Ah, S11001001, yeah that'd be a better way to fail.
12:01:44 <mmachenry> @ (=<<)
12:02:51 <hexagoxel> 'haddock-2.15.0.2 failed while unpacking the package. The exception was: user error (File in tar archive is not in the expected directory. Expected: "." but got the following hierarchy: ["haddock-2.15.0.2"])'
12:03:09 <hexagoxel> uhh, what have you done, cabal-install-1.22.5.0?
12:05:20 <S11001001> er, (maybe (fail "not a date") return)
12:06:18 <mmachenry> S11001001: Would I need traverse if I used bind?
12:06:49 <michaelt> dfeuer: http://lpaste.net/134609 you were right, it was easier to think about the 'monoid' (here category) case first
12:07:43 <S11001001> mmachenry: yes
12:07:49 <S11001001> mmachenry: but it's trivial
12:07:52 <dfeuer> michaelt, yeah, it's a bit less horrifying.
12:08:04 <S11001001> traverse strToTime =<< parser instead of fmap strToTime <$> parser
12:08:41 <dfeuer> michaelt, for my purposes, defining it in terms of the view doesn't strike me as the right way, but that's a very different context.
12:09:29 <michaelt> dfeuer: yes, if you are working with a concrete Queue c a b , that will be true. 
12:10:23 <michaelt> dfeuer: similarly, it's clear that it would be preferable to include the foldable material in the class definition with these as default implementations, since God knows which is best for a given Queue thingy
12:10:52 <dfeuer> michaelt, more importantly, the "views" I want are "dependent views" whose result types include proofs about how the results relate to the arguments.
12:11:24 <dfeuer> And the proofs I want to provide have to do with the foldMap behavior.
12:11:42 <dfeuer> So ... backwards for me. But that's not relevant....
12:12:02 <dfeuer> michaelt, the big questions: can you implement foldr in terms of foldMap? How about foldMap in terms of foldr?
12:12:06 <michaelt> right, but note this is a comparatively fancy pattern match 
12:12:15 <michaelt> dfeuer: I was wondering about that
12:12:46 <michaelt> dfeuer: the two cases in e.g. 'tfold' match at different types
12:12:59 <dfeuer> michaelt, I'm working on an idea for it, using a type based on the Morphism type, but I don't know if it's going to work out.
12:13:30 <S11001001> mmachenry: stylistically I think this sort of thing reads better https://github.com/ermine-language/ermine/blob/master/src/Ermine/Parser/Module.hs#L108-L113
12:13:39 <S11001001> mmachenry: but as you like on that
12:16:34 <mmachenry> Thank you!
12:19:36 <Ainieco> hello
12:19:51 <oconnore> Ainieco: hi
12:24:19 * hackagebot lens-simple 0.1.0.6 - simplified import of elementary lens-family combinators  http://hackage.haskell.org/package/lens-simple-0.1.0.6 (MichaelThompson)
12:25:28 <Pamelloes> What does it mean for a function to provide a proof in its type?
12:27:27 <johnw> a -> { x : b | P x }
12:27:36 <johnw> or: a -> P a
12:27:51 <johnw> depending on whether it's just providing a proof based on its argument, or it's producing another value and a proof about that value
12:32:03 <dfeuer> Pamelloes, in Haskell 98, the concept pretty much doesn't exist. In GHC, you can do some things with GADTs and junk in Data.Types.Equality and so on.
12:32:11 <dfeuer> *Data.Type.Equality
12:32:21 <dfeuer> And singletons.
12:32:24 <dfeuer> And it's painful.
12:33:04 <agrif> does anybody know if TemplateHaskell plays nice with OverloadedStrings?
12:33:38 <agrif> I can’t seem to get the StringLs I use to typecheck as anything other than String
12:34:19 * hackagebot species 0.3.4.1 - Computational combinatorial species  http://hackage.haskell.org/package/species-0.3.4.1 (BrentYorgey)
12:43:14 <zacts> lol
12:43:16 <zacts> oops
12:59:52 <lyxia> agrif: Can you give an example?
13:03:13 <agrif> lyxia: I thought I could, but trying to reduce it to a simple example makes it work. I probably have something else funny going on
13:14:58 <agrif> lyxia: yep, dumb mistake on my end. I was too quick to blame TH :D
13:15:26 <agrif> (the generated code had a `show` buried in it that forced all the other string literals to String)
13:32:48 <zipper> How can I make getLine wait for input for something like 0.1 seconds?
13:33:03 <zipper> If it gets none then it goes on
13:33:06 <bitemyapp> zipper: sleep for 0.1 seconds first?
13:33:10 <bitemyapp> zipper: then getLine?
13:33:21 <zipper> or better yet pause execution for 0.1 sec
13:33:23 <zipper> Oh sleep
13:33:31 <agrif> bitemyapp: timeout ?
13:33:32 <zipper> bitemyapp: Let me hoogle that.
13:33:41 <bitemyapp> zipper: https://hackage.haskell.org/package/base-4.7.0.2/docs/Control-Concurrent.html#g:6
13:33:41 <agrif> as in timeout from System.IO, I think
13:34:00 <bitemyapp> agrif: I was thinking threadDelay from Control.Concurrent.
13:34:14 <bitemyapp> wait
13:34:29 <bitemyapp> zipper: do you want to wait before invoking getLine or do you want to time getLine *out* like agrif said?
13:34:44 <zipper> bitemyapp: I don't really want to getLine
13:34:55 <bitemyapp> well, we can put that aside
13:34:56 <zipper> I just wanted to pause program execution
13:34:59 <bitemyapp> but do you want a sleep or a timeout?
13:35:01 <bitemyapp> that sounds like a sleep.
13:35:09 <bitemyapp> zipper: https://hackage.haskell.org/package/base-4.7.0.2/docs/Control-Concurrent.html#g:6 then
13:35:10 <zipper> and threadDelay might be it.
13:35:23 <zipper> bitemyapp: That is threadDelay
13:35:46 <zipper> bitemyapp: Or am I looking at the wrong thing?
13:36:20 <zipper> Ah found this "Warning: This function has several shortcomings (see documentation). Please consider using Control.Concurrent.threadDelay instead."
13:36:22 <zipper> Thanks
13:36:30 <zipper> bitemyapp: Thanks a ton.
13:37:20 <bitemyapp> zipper: n
13:37:21 <bitemyapp> np*
13:40:01 <ashdro> ayo
13:43:27 <mmachenry> Is there a better tool for understanding STM lock contention than threadscope? I really don't know how to read threadscope with an eye toward knowing if STM lock contention is an issue for me
13:43:29 <ashdr0> :D 
13:45:13 <slomo_> hmm, i have a class "C a b" that has a commutative binary operation. is it possible to define an "instance (C a b) => C b a" without enabling UndecidableInstances as ghc suggests? that extension sounds dangerous :)
13:47:45 <geekosaur> no, because instance selection doesn't work that way
13:49:46 <kau> Hi guys!
13:50:34 <kau> A simple question: I want to parse string of the form <a name>V<an integer>
13:50:47 <kau> How should I do that? Should I use parsec?
13:51:05 <whiteline> yeah, parsec is good for any task
13:51:18 <sunnymilk> kau can the name contain a V?
13:51:21 <sunnymilk> or numbers
13:51:44 <whiteline> it's basically magic once you learn to use it properly
13:51:54 <whiteline> wave hand, have parser
13:51:55 <kau> It can contain Vs, but no integer
13:51:56 <sunnymilk> if the name cant contain V or numbers, then you can easily just write your own function to parse it
13:52:12 <sunnymilk> hm well you could still write a function to do it witohut having to pull in parsec
13:52:17 <kau> basically it finishes with V + a number
13:52:30 <kau> for example:  HouseV5
13:52:57 <sunnymilk> it wouldnt be that difficult, just read until you get to the numbers, chop the last character off and make sure its a V
13:53:15 <agrif> if you plan on parsing more complicated things, I’d use parsec or the like, but this seems easy enough without it
13:53:24 <kau> Actually it's a Haskell module name + a version suffix
13:53:42 <slomo_> geekosaur: that's sad :)
13:54:17 <kau> sunnymilk, agrif: right
13:54:46 <geekosaur> basically "instance C a b => C b a where" means "instance C b a where" (i.e. any types a, b so it overlaps with every other instance). the context is only checked later.
13:55:35 <breadmonster> kau: `myParser = (many1 letter) >>= \name -> string "V" >> (many1 digit) >>= \num -> name ++ "V" ++ num`
13:55:48 <breadmonster> Using parsec that is.
13:56:03 <kau> wow that's nice
13:56:33 <breadmonster> geekosaur: What's the simplest typed lambda calculus that's also Turing complete?
13:56:38 <ParahSailin> i used to use printf-mauke, what do people use now for printf formatting, just the one in base?
13:56:55 <kau> thanks
13:57:44 <geekosaur> breadmonster, um, you're asking the wrong person entirely >.>
13:57:54 <slomo_> geekosaur: thanks
13:58:27 <breadmonster> geekosaur: Oh damn, you're really experienced with Haskell, I just thought you'd know :P
13:58:38 <breadmonster> Where's merijn :(
13:58:46 <kau> I can see people in this channel are always (and still) very helpful!
13:58:47 <lyxia> Dynamically typed lambda calculus.
13:58:55 <breadmonster> lyxia: lol is that a thing?
13:59:03 <kau> so thanks guys
13:59:11 <geekosaur> actually not *that* experienced, I stay away from a lot of the complex stuff. and type theory I'm mostly ignorant of
13:59:13 <breadmonster> kau: no problem (:
13:59:14 <lyxia> No idea hehe.
13:59:27 <ProofTechnique> Singly-typed lambda calculus
13:59:43 <breadmonster> lyxia: I remember merijn telling me some math-y reason why simply typed lambda calculus is not Turing complete.
14:01:15 <lyxia> The halting problem is trivial.
14:01:15 <aruro`> > sin pi
14:01:17 <lambdabot>  1.2246467991473532e-16
14:01:32 <aruro`> > cos pi
14:01:33 <lambdabot>  -1.0
14:01:49 <breadmonster> lyxia: How so?
14:02:31 <lyxia> breadmonster: All well-typed terms are strongly normalizing, i.e. programs terminate.
14:02:39 <broma0> Does anyone know how to get the request body when using the network package's accept fn? I cant really implement a low level web server without getting the body of requests!
14:03:05 <tejon> Speaking of people in this channel being helpful...
14:03:07 <lpaste> tejon pasted “augh halp! (type woes, pcg-random)” at http://lpaste.net/134614
14:04:38 <quchen> ParahSailin: Chris Done's package is pretty cool
14:04:50 <quchen> Not sure how it's called though. Something with "formatting". :-)
14:05:31 <lyxia> breadmonster: So you can't simulate the execution of Turing machines by reduction of well-typed lambda terms.
14:05:38 <ParahSailin> yeah, just looked at that one
14:06:03 <breadmonster> lyxia: Sure they have to be lifted, yeah?
14:07:20 <lyxia> breadmonster: What do you mean?
14:08:06 <breadmonster> lyxia: Int = Int# | undefined
14:09:04 <tejon> What's the postfix # I see in base source? Is that an engine primitive?
14:09:35 <hpc> it's a ghc parsing thing
14:10:00 <hpc> and it is about as meaningful as trailing single-quote (that is, it's just a convention)
14:10:15 <tejon> Ah, OK.
14:10:31 <lyxia> breadmonster: That's not simply typed lambda calculus
14:11:34 <breadmonster> lyxia: Sure, but lifted types aren't STLC, if I recall correctly.
14:11:45 <breadmonster> tejon: It means the type is unboxed.
14:11:46 <whiteline> kau: perfectly watertight parser for what you asked for: http://lpaste.net/134615
14:12:13 <Pamelloes> Are there any good examples of how to use HList? I can't really make heads or tails of the haddock pages.
14:13:17 <lyxia> tejon: You could try to put a type hole and see what GHC tells you.
14:13:40 <kau> thanks whiteline
14:14:50 <dmj`> is 'cabal get' and 'cabal unpack' synonymous
14:16:34 <tejon> lyxia: Last time I tried that I failed utterly. :P Where would I put the hole?
14:17:17 <lyxia> tejon: in place of the type signature, roll :: _
14:17:24 <lyxia> tejon: withFrozen :: _
14:17:41 <tejon> Oh, just the whole thing... hmm, let's see what that does.
14:18:31 <tejon> t -> FrozenGen -> (a, FrozenGen) -- well yeah, I knew that much. :P
14:20:07 <tejon> And furthermore: Couldn't match expected type 'Gen s -> ST s a' with acutal type 't' because type variable 's' would escape its scope.
14:20:29 <tejon> Variants on this have been common in my experiments.
14:22:01 <tejon> But it's not a problem for 'roll' -- why?
14:22:10 <hexagoxel> dmj`: https://github.com/haskell/cabal/blob/master/cabal-install/Main.hs#L1081-1082
14:23:06 <dmj`> hexagoxel: ah figures :)
14:32:38 <lyxia> tejon: Right the compiler has trouble inferring higher rank types.
14:33:26 <lyxia> tejon: It compiles with -XRankNTypes and withFrozen :: (forall s. Gen s -> ST s a) -> FrozenGen -> (a, FrozenGen)
14:34:26 <tejon> Of course it does! I actually tried almost exactly that, except not *quite* exactly... I was a little too specific about the Gen type. :P
14:35:20 <tejon> Well at least I had the right hunch. Just gotta work on my aim. Thanks. :)
14:36:21 <lyxia> tejon: Cheers.
14:39:25 * hackagebot paypal-adaptive-hoops 0.11.0.2 - Client for a limited part of PayPal's Adaptive Payments API  http://hackage.haskell.org/package/paypal-adaptive-hoops-0.11.0.2 (fanjam)
14:44:25 * hackagebot wolf 0.1.1 - Amazon Simple Workflow Service Wrapper.  http://hackage.haskell.org/package/wolf-0.1.1 (markfine)
14:45:42 <ParahSailin> why did utf8-string drop System.IO.UTF8
14:47:44 <small-wo1f> exit
14:48:53 <glguy> ParahSailin: Because after 6.10, the base library's IO functions handled the encoding on their own
14:59:52 <tejon> Is there any canonical guideline to order of arguments in a function?
15:02:02 <timemage> tejon, seems like it's usually chosen to maximize opportunity for currying.
15:02:06 <geekosaur> the main guideline is that if it makes sense to partially apply the function, try to put the parameters most likely to be supplied later last
15:03:03 <geekosaur> (this sometimes leads to multiple "versions" of functions, e.g. map puts the list last for partial application but for (flip map) puts the mapping function last, reflecting different modes of usage)
15:03:26 <tejon> That's been my intuition as well, but in practice I find myself frustrated by having to drop a lambda or multi-argument function in the middle of a call more often than I benefit from being able to defer the argument.
15:03:29 <c_wraith> A subguideline to that is often that if the function returns a value of the same type as exactly one of its parameters, it makes sense to put that parameter last
15:04:00 <c_wraith> Which is why I think forM_ makes more sense than for.
15:04:47 <tejon> geekosaur, right, I find myself using flip on nearly every application of certain functions.
15:05:08 <c_wraith> *cough*runState*cough*
15:05:09 <tejon> Makes me wonder (a) why there isn't just a pre-flipped version for brevity and/or (b) how am I doing it wrong. :P
15:05:14 <tejon> YES THAT ONE
15:05:35 <c_wraith> It takes its parameters in the order it does because it's defined with record notation.
15:05:43 <c_wraith> I don't find that reason compelling. :)
15:06:42 <c_wraith> Or at least it was, historically.
15:07:05 <tejon> Okay, so at least it's not just flagrant misuse on my part. :)
15:12:28 <codygman> Why does `Atto.parseTest (Atto.takeText) "test"` return `Partial _` instead of `Done "" "test"`? Also I'm pretty sure Partial isn't what I want here, but for curiosities sake are there any examples of using it?
15:12:56 <hexagoxel> > flip flip 1 (+) 3 -- infix notation, finally!
15:12:58 <lambdabot>  4
15:14:19 <pk4771_>  Hey anyone please help me writing a function, I have a list say [1,2,3,4,5] and I have to compute maximum value of a function f a b where a and b takes values from list.
15:14:30 <pk4771_> How to do it?
15:15:31 <tejon> a and b can each be any value from the list, except each other? Sounds like a job for the list monad. :)
15:16:45 <breadmonster> pk4771_: :t maximum
15:16:50 <breadmonster> :t maximum
15:16:51 <lambdabot> (Ord a, Foldable t) => t a -> a
15:17:02 <dmj`> sounds like homework
15:17:11 <mniip> there are issues where a and b are the same element
15:17:23 <mniip> especially if the list can contain duplicates
15:17:44 <pk4771_> a and b can also be the same.. infact tehse are the x and y coordiantes 
15:17:50 <breadmonster> pk4771_: `maximum $ a >>= \x -> b >>= \y -> return f x y`
15:18:23 <y> it depends, is f returning a list or not?
15:18:37 <pk4771_> no. its just a number
15:18:50 <y> maximum . join (liftA2 f) -- something like this would do it 
15:19:02 <breadmonster> > [1,2] >>= \x -> [1,2,3] >>= \y -> return (x,y)
15:19:02 <y> @type \f -> maximum . join (liftA2 f) 
15:19:03 <lambdabot> (Ord c, Applicative t, Foldable t) => (a -> a -> c) -> t a -> c
15:19:03 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3)]
15:19:19 <y> @type \f xs -> maximum (f <$> xs <*> xs)
15:19:21 <mniip> breadmonster, ew
15:19:21 <lambdabot> (Ord a, Applicative t, Foldable t) => (a1 -> a1 -> a) -> t a1 -> a
15:19:24 <mniip> use applicative instead
15:19:34 <mniip> or liftM at least
15:19:40 <mniip> or do-notation
15:19:42 <breadmonster> mniip: Fine, you prude -.-
15:19:58 <tejon> dmj`, nobody listens... ;)
15:20:12 <pk4771_> Thanks. Let me try then
15:20:34 <breadmonster> :t liftM2 (_ :: Int -> Int -> Int) [1,2,3] [3,5]
15:20:35 <lambdabot>     Found hole ‘_’ with type: Int -> Int -> Int
15:20:36 <lambdabot>     In the first argument of ‘liftM2’, namely
15:20:36 <lambdabot>       ‘(_ :: Int -> Int -> Int)’
15:20:48 <breadmonster> :t liftM2 (undefined :: Int -> Int -> Int) [1,2,3] [3,5]
15:20:49 <lambdabot> [Int]
15:20:53 <breadmonster> Yay.
15:21:13 <breadmonster> pk4771_: `maximum $ liftM2 f a b`
15:21:49 <y> oh, it's not from the same list? 
15:22:50 <Gurkenglas> My haskell program uses, according to the task manager, 40% of my CPU. It takes a few minutes to complete its work. Can I get it to use more?
15:25:10 <tejon> Is it doing IO through all of that, either disk or network? If so, that's probably your bottleneck. 40% doesn't match up to a single maxed-out core.
15:25:37 <mniip> maybe it's a linux system with 2.5 cores
15:25:47 <mniip> er
15:25:55 <mniip> the inverse, I mean, a windows system with 2.5 cores
15:26:32 <tejon> Eric the Half-a-Core
15:27:10 <hpc> intel should just start naming its architectures after musical genres
15:27:15 <hpc> intel mumblecore i7
15:27:27 <silver> hehe
15:28:21 <breadmonster> Are there any Applicative instances that come up often?
15:28:32 <tejon> Hey, they could use that scheme for stepping too.
15:28:34 <breadmonster> That is, any Applicative instances that aren't also monad instances?
15:28:49 <conal> Is there a way to find out on Hackage which packages depend on a given one?
15:29:05 <hpc> breadmonster: ZipList
15:29:14 <breadmonster> conal: Yeah, it's given in dependencies.
15:29:28 <glguy> conal: I use this for reverse dependencies: http://packdeps.haskellers.com/reverse
15:29:41 <conal> breadmonster: i think i want the other way around.
15:29:50 <breadmonster> Oh right sorry, misread
15:29:51 <conal> glguy: thx. that's what i'd forgotten.
15:29:55 * mniip checks the laws on a Monad ZipList instance he just invented
15:30:13 <GREAT> please who knows any linux scanner channel
15:30:59 <Gurkenglas> tejon, it reads ~1.5 MB of .png files and writes ~3.5 MB of tiff file and takes minutes to do so
15:31:14 <Gurkenglas> (also does stuff in between, of course.)
15:31:42 <mniip> hpc
15:31:48 <Gurkenglas> (it reads and writes different formats because Codec.Picture fails to load my tiffs)
15:31:52 <mniip> I have a Monad ZipList instance
15:31:58 <tejon> Hmm, dunno then.
15:32:13 <tejon> Does sound like it should be doing better.
15:32:22 <mniip> it's not too nice, but does conform the laws, and <*> = ap
15:32:33 <hpc> what's join?
15:33:07 <mniip> join ((x:xs):xss) = x:join (map tail xss)
15:33:46 <mniip> basically advance diagonally through the list of lists
15:34:04 <mniip> return = cycle
15:34:04 <hpc> https://mail.haskell.org/pipermail/haskell-cafe/2009-April/059088.html
15:34:15 <Gurkenglas> tejon, have code: http://lpaste.net/134619
15:34:32 <hpc> mniip: breaks for non-infinite lists
15:34:36 <mniip> hmm
15:35:29 <tejon> Ack! Give it to someone else! I'm not a Haskell performance expert. :)
15:35:35 <hpc> > tail []
15:35:36 <lambdabot>  *Exception: Prelude.tail: empty list
15:35:58 <GREAT> please brothers try help me out with a linux shell scanner server
15:35:59 <GREAT> please brothers try help me out with a linux shell scanner server
15:36:27 <glguy> GREAT: This channel is for questions about the Haskell programming language.
15:39:03 <breadmonster> Has anyone parsed C in Haskell?
15:40:41 <geekosaur> http://hackage.haskell.org/package/language-c and friends?
15:41:44 <fishythefish> If I want to call some C code from Haskell that returns a string (char *), what is the correct approach to managing the memory required to hold the string?
15:42:47 <mniip> fishythefish, are you in control both sides of the interface?
15:43:01 <fishythefish> mniip, yes.
15:43:16 <mniip> is there concurrency involved?
15:43:21 <fishythefish> Nope.
15:43:33 <fishythefish> It's a simple situation; I just think I'm thinking about it wrong. :P
15:43:59 <breadmonster> geekosaur: fantastic.
15:44:01 <mniip> is the string length, or max string length known beforehand?
15:44:09 <fishythefish> mniip, no.
15:44:10 <c_wraith> fishythefish: Is the haskell code liable to hold on to the data for an arbitrarya mount of time?
15:44:16 <breadmonster> mniip: Can the type system prevent deadlock?
15:44:34 <mniip> breadmonster, what?
15:44:47 <breadmonster> Can the type system catch deadlock errors?
15:44:52 <mniip> no?
15:44:56 <fishythefish> c_wraith, yes, but if I can marshal the data into different memory and free the heap pointer holding the C string, that would be fine.
15:45:29 <c_wraith> fishythefish: It's probably best to allocate the memory and free it in the same place.
15:45:41 <c_wraith> fishythefish: due to issues with dynamically loading different versions of malloc/free
15:45:44 <fishythefish> c_wraith, agreed
15:45:47 <fishythefish> I was just reading http://blog.haskell-exists.com/yuras/posts/malloc-free-and-ffi.html
15:45:54 <c_wraith> fishythefish: yeah, exactly that
15:46:42 <c_wraith> fishythefish: I'd do something like 1. call ffi function that allocates a string.  2.  marshal into haskell String/ByteString/whatever  3.  Call ffi function to free
15:46:59 <c_wraith> fishythefish: then only export the function that does all of that from the module with the bindings
15:47:09 <fishythefish> c_wraith, ah, okay, I've been putting the C string on the heap on the C side in order to return it.
15:47:34 <c_wraith> fishythefish: that's fine.  just make sure to export a deallocation function from the C side as well
15:47:47 <fishythefish> c_wraith, yeah, I just felt kinda silly exporting a wrapper to free. :P
15:48:02 <c_wraith> fishythefish: it *is* kind of silly, but..  it can be necessary
15:48:21 <fishythefish> c_wraith, cool, I'll carry on doing just that, then. :P
15:48:22 <c_wraith> The silly part is that it can be necessary, not doing it. :)
15:48:23 <fishythefish> Thanks.
15:54:28 * hackagebot al 0.1.3.2 - OpenAL 1.1 raw API.  http://hackage.haskell.org/package/al-0.1.3.2 (DimitriSabadie)
15:59:30 <phaazon> is there any mac user?
16:00:39 <maerwald> phaazon: I'd say that returns true :P
16:00:58 <maerwald> you could also ask if there is any linux user, which is probably also true
16:01:41 <pacak> maerwald: mac os can be derpy in it's own unique way.
16:03:45 <phaazon> maerwald: I actually need one
16:03:48 <phaazon> a mac user 
16:03:59 <phaazon> to install a package of mine in a sandbox in /tmp
16:04:07 <hodapp> phaazon: I'm on Mac, what's up?
16:04:13 <phaazon> it has just one dependency
16:04:20 <phaazon> hodapp: I just updated a new package
16:04:26 <hodapp> phaazon: what package?
16:04:29 <phaazon> may you update your cabal index
16:04:32 <phaazon> and try to install al?
16:04:34 <phaazon> cabal install al
16:04:36 <phaazon> should be enough
16:04:46 <phaazon> I just wonder whether it works on mac osx
16:04:58 <hodapp> hold on, init'ing sandbox and updating...
16:05:03 <phaazon> thanks :)
16:05:20 <hodapp> updating may take some time, I'm on slow intarwebz
16:05:26 <phaazon> mac osx has that curious concept of « frameworks »
16:05:45 <phaazon> not sure if I have to use it to bind to the C OpenAL library
16:05:54 <phaazon> or whether pkg-config is sufficient
16:06:16 * geekosaur seems to recall that OpenAL has been problematic on OS X
16:06:23 <geekosaur> apple leaves out parts of it or something
16:06:28 <phaazon> ah
16:07:34 * hodapp waits patiently for cabal update...
16:07:52 <phaazon> it would be great to have a feature like
16:07:59 <phaazon> cabal update al
16:08:12 <phaazon> but I guess it would be complex to implement
16:09:29 * hackagebot log 0.2.2 - Structured logging solution with multiple backends  http://hackage.haskell.org/package/log-0.2.2 (arybczak)
16:09:42 <geekosaur> I think it would have to grab most of the index tarball anyway in the common case
16:10:22 <geekosaur> which is the slow part unless you have a very recent cabal-install (a bug there was fixed in the past month or so that sped it up a lot)
16:11:08 <phaazon> here
16:11:20 <phaazon> phaazon@illusion ~ % cabal --version
16:11:21 <phaazon> cabal-install version 1.22.2.0
16:11:21 <phaazon> using version 1.22.2.0 of the Cabal library 
16:11:36 <geekosaur> I don't recall what version that fix went into :/
16:11:58 <phaazon> well, cabal is pretty fast to me
16:12:19 <phaazon> especially when building up to 8 packages in parallel
16:12:28 <phaazon> that’s astonishingly fast :)
16:12:54 <c_wraith> cabal really isn't doing much work at that point. :P
16:13:14 <phaazon> I guess it at least have to handle threads of builds?
16:13:24 <phaazon> has*
16:13:26 <phaazon> dammit.
16:13:28 <geekosaur> siigh it's not in the changelog
16:14:04 <c_wraith> geekosaur: The thing I remember about reading the index file being O(n^2) was like..  8 months ago or something.
16:14:29 <phaazon> some day, I hope I can help to enhance cabal
16:14:43 <phaazon> the first thing I’d love to see included is the possibility to install any version of a package I want
16:14:58 <hodapp> still waiting on that update... blaargh
16:15:17 <phaazon> hodapp: aouch
16:15:27 <hodapp> okay, lag went away, why is it now just sitting there
16:15:30 <geekosaur> hm, afaik you can do that by naming a version?
16:15:39 <phaazon> geekosaur: well
16:15:46 <phaazon> I read something about cabal and version
16:15:59 <phaazon> IIRC, cabal tags a release with three htings
16:16:01 <phaazon> things*
16:16:08 <geekosaur> a cabal get with a version worked here
16:16:10 <c_wraith> phaazon: that work is ongoing.  You could ask ezyang about the current status when he's around
16:16:11 <phaazon> the name of the package, the version number, and a hash
16:16:18 <phaazon> then
16:16:32 <phaazon> a specific releseade version is completely a different « library » than another version
16:16:44 <geekosaur> the hash is on a build? and that one is not cabal's fault, it's ghc
16:16:52 <phaazon> we should be able to install several versions of the same package in a pkg database then
16:16:58 <c_wraith> ghc actually supports multiple installed versions of the same package already
16:17:05 <c_wraith> It's cabal that doesn't handle it well.
16:17:13 <phaazon> c_wraith: so who’s to blame?
16:17:16 <geekosaur> I wonder if ghc-pkg handl;es that sanely
16:17:17 <phaazon> ok, cabal then
16:17:23 <geekosaur> ag
16:17:27 <geekosaur> *ah
16:17:32 <phaazon> that would solve so many problems
16:17:36 <phaazon> like cabal hell
16:17:47 <c_wraith> Eh, it wouldn't really help with cabal hell issues.
16:18:07 <c_wraith> Not by itself, anyway.
16:18:28 <c_wraith> ezyang's blog has a lot of info on this.  It's worth checking out.
16:18:35 <phaazon> c_wraith: I think the cabal hell is more a human error than cabal’s fault
16:20:28 <phaazon> when two libraries need ranges that don’t overlap
16:20:36 <phaazon> there’s no way cabal can solve that out
16:20:53 <phaazon> we can’t just use two versions at the same time
16:21:01 <c_wraith> In cases of older packages, even if solutions exist, it's an exponential-time search to find them.
16:21:12 <c_wraith> Nothing cabal can do to fix the worst case.
16:21:25 <phaazon> c_wraith: I think cabal would be better with better error messages
16:21:29 <phaazon> especially on dependencies
16:21:41 <phaazon> it’s always a mess to check why a configure fails
16:21:57 <phaazon> like “hm, there’s someting about that package that can’t be installed, but why?!”
16:22:00 <Adeon> why is unsafeLookupStaticPtr an IO action in https://hackage.haskell.org/package/base-4.8.0.0/docs/GHC-StaticPtr.html
16:22:10 <Adeon> it's unsafe yes, but I don't see why it also must be an IO action
16:22:17 <Adeon> is it not refentially transparent
16:22:45 <c_wraith> Adeon: It looks like you can use it to implement unsafeCoerce.
16:22:56 <Adeon> yeah you probably can
16:23:14 <Adeon> still, does it need to be IO for that
16:23:26 <Adeon> actually I'm wondering if I can use unsafePerformIO on it and get away with it
16:23:30 <c_wraith> Adeon: I think it's in IO because IO is considered the "sin bin"
16:23:56 <phaazon> I kinda dislike how some people hate IO
16:24:00 <Adeon> hmmy yeah, I thought that might be the case
16:24:08 <Adeon> I'm in a safecopy instance where I can't use IO
16:24:12 <Adeon> I would have no problem using IO otherwise
16:24:19 <c_wraith> Adeon: I can see behavior changing at runtime between different runs if the types are wrong
16:24:47 <Adeon> hmm, actually I think a malicious file could crash my program if I do this
16:24:51 <c_wraith> Adeon: I think that last part is why it's actually in IO.  When you misuse it, the chaos isn't deterministic. :)
16:24:57 <Adeon> or wait
16:24:59 <Adeon> not sure
16:25:46 <Adeon> yeah, it can crash my program
16:25:57 <c_wraith> Adeon: I'm not sure how well static pointers do for SafeCopy anyway..  I don't think static pointers are guaranteed to work right unless you are working from the same source.
16:25:59 <Adeon> if a malicious file has a static pointer to a function that's unrelated to what I'm expecting
16:26:16 <c_wraith> Adeon: and if I understand SafeCopy right, it's about handling changes to the source sanely.
16:26:16 <phaazon> damned flu, I’m exhausted, I’m off to bed ; hodapp, if you succeed to install al, leave me a hl, I’ll see that tomorrow :)
16:26:21 <phaazon> otherwise I’ll try to inquire
16:26:25 <Adeon> yeah, version upgrades
16:26:29 <Adeon> it's actually what I'm looking for
16:26:30 <phaazon> feel free to open an issue on al
16:26:33 <phaazon> phaazon/al, github
16:26:38 <Adeon> I was experimenting if I can embed static pointers to it
16:26:44 <Adeon> but it doesn't look like I can do that safely
16:26:48 <phaazon> good night folks
16:27:00 <Adeon> well, I'm falling back to a little more verbose but safe solution
16:28:10 <Adeon> I'm writing monster logic for a roguelike and this was about serializing artificial intelligence state for individual monsters
16:28:37 <Adeon> so that the AI could be defined by a function and a data type and I could serialize it like that with no extra bookkeeping
16:28:41 <c_wraith> ...  I really don't think static pointers are safe across source changes to a program that change the list of static pointers.  However, it's totally undocumented in the user's manual.  That seems like a significant issue.
16:29:30 * hackagebot notzero 0.0.3 - A data type for representing numeric values, except zero.  http://hackage.haskell.org/package/notzero-0.0.3 (TonyMorris)
16:29:43 <c_wraith> Adeon: If the AI state fits into the way auto works, that might be worth your time to investigate.  the Auto type is designed such that the current state can be serialized
16:30:43 <Adeon> it's a mealy machine
16:30:49 <Adeon> I'll check it out
16:32:45 <c_wraith> Auto is...  nearly a mealy machine.  With a bunch of extra details for keeping track of the current state.
16:32:45 <Gurkenglas> There should be a language construct to unapply a constructor. E.g. Just 2 / Just == 2, although one might want to wrap the result in Maybe in case you don't get a pattern match x)
16:33:01 <Adeon> Auto doesn't look like it solves the inconvenience I was trying to sweep under the floor
16:33:23 <Adeon> readAuto takes an Auto
16:33:47 <c_wraith> Adeon: that's how it sidesteps type errors.
16:33:57 <c_wraith> Gurkenglas: does it need to be a language construct?  lens's Prisms are about exactly that.
16:34:11 <Gurkenglas> Ooh, shiny.
16:34:20 <c_wraith> > Just 2 ^? _Just
16:34:22 <lambdabot>  Just 2
16:34:33 <c_wraith> Ok, that's a bad example because it rewraps it in the Maybe. :)
16:34:59 <c_wraith> > [Just 2, Nothing, Just 3] ^? ix 2 . _Just
16:35:00 <lambdabot>  Just 3
16:35:20 <c_wraith> :t \x -> x ?^ _Just
16:35:21 <lambdabot>     Not in scope: ‘?^’
16:35:21 <lambdabot>     Perhaps you meant one of these:
16:35:21 <lambdabot>       ‘^’ (imported from Prelude), ‘^^’ (imported from Prelude),
16:35:25 <c_wraith> :t \x -> x ^? _Just
16:35:27 <lambdabot> Maybe a -> Maybe a
16:35:33 <c_wraith> Yeah, it's kind of the id function. :)
16:35:46 <maerwald> > [Just 2, Nothing, Just 3] !! 2
16:35:47 <lambdabot>  Just 3
16:35:47 <Cale> Gurkenglas: What would the value of Nothing / Just be?
16:35:50 <maerwald> looks easier ;)
16:35:52 <Adeon> I have a "data AI" that's monomorphic, that contains the current state of the AI and a transition function, which are polymorphic but hidden in an existential in said AI type
16:35:58 <c_wraith> > Left 10 ^? _Left
16:35:59 <lambdabot>  Just 10
16:36:00 <Cale> Gurkenglas: Is x / Just == fromJust x ?
16:36:02 <c_wraith> there. :)
16:36:06 <Adeon> I was trying to look for a solution that could serialize and unserialize that without anything extra
16:36:07 <c_wraith> > Left 10 ^? _Right
16:36:09 <lambdabot>  Nothing
16:36:43 <Gurkenglas> Cale, Nothing and yes, but / is obviously meant to apply to more than Maybe.
16:36:44 <Adeon> but I think I have no choice but to bookkeep a list of possible AI functions
16:36:53 <Adeon> not too bad but I was trying to be smart
16:36:53 <Cale> Adeon: Perhaps the data type should contain its own mechanism for serialisation?
16:37:06 <Adeon> how do I find the deserialization function when I read it out from a file
16:37:14 <Gurkenglas> Cale, actually no on the second one, (/ Just) == id.
16:37:18 <Adeon> there would be different functions for different kinds of AI
16:37:33 <Cale> Adeon: Sure, you need to be able to do that.
16:37:46 <Adeon> yeah, I was trying to use static pointers for that but now it looks like that cannot be safe
16:38:26 <Adeon> I'll make a table of those AIs and serialize a key to the file
16:38:27 <Cale> Adeon: You'd need to have each AI have some identifying tag which can be parsed in order to choose the appropriate parser for the rest of the associated data.
16:38:29 <Adeon> it'll get me as close as I can
16:38:33 <Adeon> yeah, exactly
16:38:57 <c_wraith> ...  Now, if you could create a StaticPtr to an instance, you could do all sorts of clever existential hacks....  >_>
16:39:41 <Adeon> thanks all
16:39:47 <Adeon> I'm not sure if I would have realized static pointers are this unsafe
16:40:07 <Cale> I'm not even sure what you're referring to by static pointers :)
16:40:16 <Adeon> GHC.StaticPtr
16:40:20 <Adeon> StaticPointers extension
16:40:22 <c_wraith> Cale: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/static-pointers.html
16:40:52 <Cale> Oh, that's interesting
16:42:00 <Cale> But yeah, I'd expect that to only be useful *within* any given build of a program. If you want to persist stuff between versions of your program, it's hard to imagine that working out.
16:43:04 <c_wraith> thoughtpolice tells us (in #ghc) that as long as the source of the module defining the StaticPtr doesn't change, anything else can.
16:44:02 <Cale> Doesn't change at the binary level even...
16:44:05 <Adeon> I still can't use it because of the malicious file problem
16:44:19 <Adeon> if I have two places that use static pointers and a file contains a static pointer to a function that has an incorrect type
16:44:25 <Adeon> but I can't know that in run-time
16:44:35 <Adeon> so I try to use a function that has a wrong type and then everything explodes
16:44:58 <Adeon> unless there's a trick to look into the actual type that a static pointer refers to
16:45:30 <c_wraith> There's no way to do that which an attacker can't also forge. *shrug*
16:46:46 <Adeon> actually, if the cloud haskell stuff wants to use this how do they know some static pointer is not evil
16:47:12 <Adeon> I suppose you never use static pointers that could originate from someone you don't trust
16:47:13 <c_wraith> They have to enforce it at a higher level.
16:48:08 <dustmote> is this the right place to ask a question about `stack`, the new build tool?
16:51:23 <dustmote> nm.. it's #haskell-stack
16:58:59 <f-a> I would like to know wether my program output is displayed to tty or feed to a pipe
16:59:17 <f-a> http://unix.stackexchange.com/questions/19317/can-less-retain-colored-output <-- it is apparently possible, I just don't know how in Haskell
17:00:01 <thoughtpolice> Adeon: A current limitation in the API is that part of the low-level API is unsafe, so you have to build some validation on top of it. Fundamentally like I said, a static pointer is just a key into a big hash table of functions. It's just a lot more boilerplate-y, but in a situation like that, you can always change the 'key' to point to something 'evil' if an attacker can actually forge it.
17:00:11 <thoughtpolice> But if the person is forging that you probably have bigger problems anyway.
17:00:54 <koala_man> f-a: hIsTerminalDevice stdout
17:00:54 <thoughtpolice> The real unsafety here is that if you want to deserialize a static key (say, over the network), you can look that key up in your program's "SPT", the static pointer table. But the type looks like 'StaticKey -> Maybe (StaticPtr a)'
17:01:07 <f-a> thanks koala_man 
17:01:34 <thoughtpolice> What that means is that if the key is found, it's deserialized, otherwise it isn't. So it has to be extant, but yes, it may point to the wrong thing. In practice you're probably going to have some authentication layer above this; in other words, it's the callers responsibility to ensure they use it correctly.
17:01:39 <thoughtpolice> High level APIs will abstract this.
17:01:53 <thoughtpolice> In the future, we'll have a better API, that will bake part of the TypeRep into the StaticKey
17:01:58 <thoughtpolice> So we'll get a type like:
17:02:18 <thoughtpolice> f :: StaticKey -> (forall a. Typeable a => StaticPtr a -> r) -> Maybe r
17:02:21 <thoughtpolice> Which is actually safe.
17:02:48 <Adeon> okely dokely
17:03:00 <thoughtpolice> HTHs
17:10:21 <Gurkenglas> How do you declare the type of an identifier to the left of a <- in a do block?
17:10:52 <Zemyla> Gurkenglas: a <- (m :: IO Int) or whatever.
17:11:02 <Gurkenglas> meh
17:11:30 <geekosaur> or enable ScopedTypeVariables (which also enables pattern signatures) and say x :: Type <- ...
17:12:12 <c_wraith> ScopedTypeVariables really enables a ton of nice things.
17:12:14 <geekosaur> the problem being that it desugars to a pattern in a lambda abstraction
17:14:33 <Gurkenglas> Why wouldn't it desugar by being wrapped to the right of the <-?
17:16:05 <geekosaur> huh?
17:16:18 <geekosaur> x <- y     desugars to    y >>= \x ->
17:16:19 <pavonia> geekosaur: Isn't that the case for all <- bindings in a do-block?
17:16:32 <geekosaur> which means the x is a pattern, not e.g. a let binding
17:17:09 <geekosaur> which is why you need ScopedTypeVars to give it a type, or put the type on the other side
17:17:32 <c_wraith> let introduces pattern-matching, too...
17:17:49 <pavonia> Oh, you meant the problem that requires that extension
17:18:03 <geekosaur> sure, but let also supports giving bindings types
17:18:09 <geekosaur> which lambda does not
17:18:36 <Gurkenglas> I meant to have the desugarer modified to treat it as if it were on the other side
17:19:08 <geekosaur> what of code that uses it as it is currently typed?
17:26:17 <Gurkenglas> Rephrase that, please.
17:27:21 <Gurkenglas> (I keep finding myself putting type signatures everywhere to track down where my "couldn't match type" errors come from. There should be an easier way to do this, perhaps an IDE to nail down the crucial type collision.)
17:28:28 <hodapp> phaazon: It's complaining about a lack of pkg-config
17:32:02 <geekosaur> Gurkenglas, you want to change the meaning of a type in a certain place, when existing code expects it to work the way it does (i.e. the natural way from the Report-defined desugaring)?
17:33:35 <Cale> Gurkenglas: If you turn on PatternSignatures, you can write (a :: Int) <- m
17:33:36 <Gurkenglas> Ah, no. I mean to make the language strictly more defined by introducing a meaning for x :: a <- y, where there previously was none
17:33:39 <geekosaur> hodapp, phaazon: right, OS X does not include pkg-config. you can get it from macports or homebrew, or a few other things (notably mono, which slaps one in /usr/bin and thereby confuses quite a lot of other software); but none of them come with .pc files for system libraries
17:34:08 <Cale> Gurkenglas: Normally type annotations aren't part of the syntax of patterns
17:34:33 * hackagebot notzero 0.0.4 - A data type for representing numeric values, except zero.  http://hackage.haskell.org/package/notzero-0.0.4 (TonyMorris)
17:35:03 <geekosaur> Cale, I already told them that. their argument is that do syntax should be an exception
17:35:29 <Cale> Them?
17:35:34 <vikaton> I cant seem to import Network on my debian box :(
17:35:41 <vikaton> any help?
17:35:51 <Gurkenglas> (Mismatch helper: Like, it finds a type mismatch, deduces a pair of types for all the intermediate non-type-signature'd stuff from the two ends of the mismatch, picks a "simple" pair, asks the user which type signature that term is supposed to have, and so compresses the mismatch range down and proceeds to binary search for the collision.)
17:36:10 <Cale> vikaton: ghc-pkg list network
17:36:21 <geekosaur> Cale: as in singular-they, non-gendered
17:36:25 <Cale> ah, okay
17:36:44 <vikaton> Cale, gave me a dir
17:36:54 <geekosaur> vikaton, if you installed just ghc then you do not have the network package
17:37:06 <vikaton> how do I install? :P sorry noob
17:37:13 <Cale> cabal install network
17:37:18 <geekosaur> how did you install ghc?
17:37:29 <vikaton> apt-get
17:37:55 <geekosaur> -try libghc-network-dev
17:37:59 <geekosaur> (apt-get)
17:38:43 <vikaton> got it thanks :P
17:38:59 <ryantrinkle> does anyone know of a way to generate unique identifiers that are parameterized on a type? in particular, so that you can compare them and get a witness of type equality back if they're equal
17:39:34 * hackagebot pcg-random 0.1.3.1 - Haskell bindings to the PCG random number generator.  http://hackage.haskell.org/package/pcg-random-0.1.3.1 (cchalmers)
17:42:22 <Axman6> ryantrinkle: you mean like Typeable?
17:42:39 <Cale> ryantrinkle: So, in addition to what Typeable does, you want some additional counter or some such?
17:42:42 <Axman6> and/or Data.Dynamic?
17:42:49 <ryantrinkle> well, it shouldn't require Typeable
17:43:20 <ryantrinkle> e.g.: if i have a counter and I know its values are globally unique, then i should be able to assert equality of *any* type, Typeable or not
17:43:34 <c_wraith> ryantrinkle: possibly singleton types?
17:43:55 <c_wraith> ryantrinkle: global uniqueness is very hard to prove in the presence of dynamic loading... which ghc supports.
17:44:12 <ryantrinkle> c_wraith: that's an interesting point
17:44:35 <Cale> Sounds kind of Vault-key-ish?
17:44:51 <ryantrinkle> Cale: yes, I think that's about right
17:44:58 <ryantrinkle> i vaguely remember that Vault stuff
17:45:09 <ryantrinkle> i've actually written the thing i'm thinking about... trying to dig it up now
17:45:16 <ryantrinkle> i'm just not sure whether there are problems with it
17:45:28 <ryantrinkle> and it really feels like there should be an improved, generalized version of it
17:45:59 <ryantrinkle> https://github.com/ryantrinkle/reflex/blob/c4cacc26b36d3db05b2d60a2144d7fe3be4070ed/src/Control/Monad/TypedId.hs
17:46:01 <ryantrinkle> ok, that's my impl
17:46:19 <ryantrinkle> the key is that it's a monad that supplies a function getTypedId :: m (TypedId m a)
17:46:29 <ryantrinkle> that 'a' is unquantified
17:46:32 <vikaton> does Control.OldException exist anymore
17:46:44 <ryantrinkle> so the idea is, the user can apply getTypedId at any type they want
17:46:55 <ryantrinkle> and they'll get an ID that they can use to, e.g., jam stuff into a DMap
17:47:15 <ryantrinkle> since uniqueness is maintained via a global IORef, i can just unsafeCoerce my way through
17:47:39 <ryantrinkle> (line 40 of that file)
17:47:53 <Cale> vikaton: If it exists, it's not in base anymore
17:48:24 <Cale> vikaton: It's been deprecated for a *long* time, so any code which is using it has had quite some time to be fixed.
17:48:37 <ryantrinkle> c_wraith: does that approach of a global IORef seem sufficient? i'm just generating globally unique IDs with it
17:48:39 <vikaton> Cale, heh https://wiki.haskell.org/Roll_your_own_IRC_bot
17:48:58 <ryantrinkle> the thing this really depends on is that getTypedId can only be executed monomorphically
17:49:00 <ryantrinkle> which i'm not totally sure about
17:49:24 <Cale> vikaton: Does that use OldException?
17:49:36 <ryantrinkle> so that's another question, i suppose: if i get down to actually executing an IO action, it has to be, at that point, monomorphic, right?
17:49:38 <Cale> It doesn't appear to...
17:49:48 <c_wraith> ryantrinkle: it will have issues if the module containing the global IORef is ever loaded dynamically.
17:50:09 <vikaton> Cale, check the source at the end
17:50:10 <ryantrinkle> c_wraith: ah
17:50:32 <Cale> vikaton: It's importing Control.Exception
17:50:52 <vikaton> Cale, https://wiki.haskell.org/Roll_your_own_IRC_bot/Source
17:51:07 <Cale> Oh, heh, nobody's bothered to update that source to match the actual tutorial
17:51:21 <ryantrinkle> c_wraith: how can i deal with that? will tying the ID type to a type declared in that module help?
17:51:25 <Cale> (shouldn't be hard, just copy the bits and pieces over)
17:51:42 <ryantrinkle> (i.e.: so that you could never have two IDs of the same underlying type that were using different IORefs)
17:51:48 <Cale> In fact, the entire source is already on the original page.
17:52:02 <vikaton> yeha I see
17:52:03 <vikaton> lol
17:52:17 <Cale> Probably that other page should just be deleted
17:52:18 <c_wraith> ryantrinkle: that would certainly work.  You might be able to get away with just putting it in its own package.  Packages aren't reloaded when modules that depend on them are.
17:52:57 <ryantrinkle> ok, cool
17:53:44 <c_wraith> ryantrinkle: (if they were, types from base wouldn't be compatible across reloads.  It'd make reloads not very useful!)
17:54:06 <ryantrinkle> haha, good point :)
17:55:08 <c_wraith> ryantrinkle: still, wrapping things in a type defined in that same module is a nice touch that can only help with safety.
17:55:51 <ryantrinkle> c_wraith: yeah, that makes sense; i hadn't thought about reloading at all
17:56:18 <c_wraith> It's a crazy special case that people don't usually think about in *any* language, let alone haskell. :)
18:04:28 <haasn> What's the special case?
18:06:55 <c_wraith> haasn: dynamic loading of modules with "global" variables
18:09:35 * hackagebot tkyprof 0.2.2.2 - A web-based visualizer for GHC Profiling Reports  http://hackage.haskell.org/package/tkyprof-0.2.2.2 (MitsutoshiAoe)
18:18:13 <dgpratt_> ocharles_, where art thou?
18:21:00 <mniip> [03:49:52] <vikaton> Cale, https://wiki.haskell.org/Roll_your_own_IRC_bot/Source
18:21:00 <mniip> dude
18:21:04 <mniip> that code is horrib;e
18:21:11 <vikaton> lol
18:21:23 <vikaton> mniip: you have your own implementation ?
18:21:32 <mniip> in haskell? not yet
18:22:04 <mniip> irc bots are usually complex beings
18:22:37 <mniip> in particular extensibility, and hot reload are key features
18:22:40 <dgpratt_> only if they are to be useful
18:23:10 <mniip> such features are available in haskell, but are not only unidiomatic, but also arcane and complicated
18:23:40 <mniip> as for idiomatic implementation,
18:24:03 <mniip> the one I like the most, so far, is a Parsec over the socket handle, in the IO monad
18:25:04 <Welkin> is it safe to nuke ~/.ghc without breaking anything?
18:25:16 <Cale> mniip: Are you referring to my message that the page ought to be deleted? :)
18:25:37 <Hijiri> Welkin: I'm not sure, you'll at least lose a custom ghci config
18:25:42 <Welkin> I need to clear out my user-level packages and just use them in sandboxes
18:25:48 <Hijiri> but usually it hasn't broken anything for me
18:25:57 <Hijiri> usually I just delete the packages dir
18:26:13 <Welkin> is anything installed by default in ~/.ghc ?
18:26:50 <Welkin> okay, so I should empty out package.conf.d?
18:27:09 <Welkin> do I need to unregister with ghc-pkg at all?
18:27:21 <Hijiri> I usually just rm -rf ~/.ghc/<architecture name>
18:27:33 <Hijiri> you don't need to manually unregister anything
18:27:56 <mniip> Cale, oh
18:27:57 <mniip> no
18:28:00 <mniip> the irc bot page
18:32:33 <Cale> mniip: Eh, it's not the prettiest code ever, but it's also not the worst.
18:39:37 * hackagebot xmonad-windownames 0.1.0.0 - A library to automatically put named windows into the DynamicLog.  http://hackage.haskell.org/package/xmonad-windownames-0.1.0.0 (plindbe2)
18:49:28 <tejon> <mniip> irc bots are usually complex beings  <mniip> in particular extensibility, and hot reload are key features
18:49:42 <tejon> One of the tutorials for Auto is an IRC bot which IIRC focuses on exactly those features.
18:50:51 <tejon> http://blog.jle.im/entry/auto-building-a-declarative-chatbot-with-implicit-serialization there it is
18:52:51 <tejon> And speaking of which -- ryantrinkle are you still around? I'm vassilating between taking the full FRP plunge with Auto, or with Reflex. The huge selling point for Auto is the free serialization. Is something like that feasible with Reflex?
18:53:53 <tejon> (And yes, yes, I'm aware that Auto isn't *really* FRP.)
18:54:13 <tedkornish> FRP == functional reactive programming?
18:54:26 <Cale> yeah
18:54:59 <ryantrinkle> tejon: reflex doesn't have any serialization stuff baked in
18:55:49 <ryantrinkle> tejon: what does Auto do if you change your program, and then want to read an old state?
18:56:34 <tejon> Tells you to cry about it. :) The advice is to serialize separate parts individually to minimize that issue.
18:57:30 <ryantrinkle> that sounds pretty scary to me; i can imagine a solution, but i have a hard time imagining a *simple* solution
18:58:00 <ryantrinkle> in Reflex, it's not hard to do something like, say, produce a Dynamic X
18:58:06 <ryantrinkle> and then take an X on startup
18:58:27 <ryantrinkle> then, you can trivially save that X by tagging its value and serializing it however you usually would
18:58:40 <ryantrinkle> also, what about if you have dynamic values with non-serializable stuff inside, like functions?
18:58:44 <ryantrinkle> does Auto disallow that?
18:59:25 <tejon> I'm actually not sure.
19:02:13 <tejon> paging jle` ? :)
19:02:31 <ryantrinkle> tejon: well, if there's really a disciplined, safe approach to serialization there, i'll be happy to take a look and see how to do something similar with reflex
19:04:32 <jle`> tejon: hey, sup :)
19:04:47 <jle`> yeah, auto does have some problems with migrations
19:05:42 <jle`> in practice i end up serializing individual components of state that i feel won't change
19:06:07 <jle`> this is demonstrated in the article you linked ... each individual module self-serializes itself to disk
19:06:42 <jle`> you can control how fine grained the serialization is, to account for potential future migrations.  the serialization schema is tied to the structure of your program and implicitly derived
19:06:46 <sccrstud92_> does anyone know of any papers that present a formal description of haskell's type system?
19:07:01 <jle`> the "safecopy" problem is a bit of an open problem i've been working on.  hope to find something nice soon :)
19:07:04 <tejon> Yeah, the tough question came a bit later -- what if an Auto contains a function?
19:07:22 <jle`> usually that isn't a problem
19:07:47 <jle`> if you build all of your autos from the primitives in the library, you shouldn't run into any issues
19:07:57 <c_wraith> unless you use primitives that end with ' :P
19:07:59 <jle`> that is, build them using composition, Applicative/Functor interface, Arrow interface, etc.
19:08:10 <jle`> heh yeah.  but those are always by choice, not by necessity
19:08:58 <jle`> it's pretty rare that you store a function as state.  and in cases where you might be tempted to, you can almost encode the function as a function from a serializable state
19:09:06 <jle`> *almost always
19:10:03 <tejon> ryantrinkle, counterpoint? :)
19:10:06 <jle`> for example, there are switching combinators that take a cue from FRP -- events that emit behaviors, and behaviors that act like the last event they receive
19:10:33 <jle`> you can rephrase this as events that emit serializable values, and behaviors that act like a behavior indexed from that serializable value
19:10:42 <jle`> this really isn't an argument or debate though, heh
19:11:12 <jle`> but yeah, safecopy problem is there, and solution isn't perfect :3
19:11:36 <tejon> I know, I'm not looking to start fights, I just know there are a lot of open questions on both sides but don't know what all those questions are and hope to learn something.
19:12:02 <ryantrinkle> for the kinds of stuff i've been working on, i need to really know what's going on in migrations
19:12:12 <ryantrinkle> in fact, most of my data eventually ends up in postgres o rsomething like that
19:15:07 <jle`> yeah, auto really gives you an opaque bundle of state...you can rearrange those opaque bundles and save them, move them, etc., but that's what they are in the end.  but that's the price of the "magic".  but if you want to do it in a non-magicful way, you could do it yourself by hand and not get any help....which i don't think is too different than any other FRP lib?
19:16:29 <ryantrinkle> one thing that makes this difficult with reflex is that it's very common to have datastructures with Events or Behaviors inside them
19:16:42 <ryantrinkle> so you can't just blindly serialize all state cells
19:19:37 <jle`> yeah, and auto lets you serialize some rough analogy of events and behaviors as black box blobs.  so maybe a sort of mix-and-match system where the ability to serialize is there if you want it, in isolated cases, and otherwise manage things yourself, would work?
19:19:38 * hackagebot notzero 0.0.5 - A data type for representing numeric values, except zero.  http://hackage.haskell.org/package/notzero-0.0.5 (TonyMorris)
19:20:03 <jle`> hm. notzero, the library i never knew i needed.
19:20:33 <ryantrinkle> jle`: yeah, i think ultimately something like that would be nice
19:20:35 <davean> jle`: haha, really?
19:20:42 <davean> The zero issue happens all the time!
19:20:58 <ryantrinkle> jle`: the migration issue definitely needs to be addressed, too
19:21:09 <ryantrinkle> sounds like Cloud Haskell + more hard stuff :P
19:21:14 <jle`> yes but who would have ever thought to prevent runtime errors with more descriptive types
19:21:28 <jle`> ^^
19:21:40 <jle`> (that was in response to davean )
19:22:04 <davean> jle`: problably no one ... /me looks over at his access control type system.
19:23:35 <jle`> ryantrinkle: yeah, heh.  it's definitely top on my list of critical things.  will be following how reflex and other frp's tackle it too though :)
19:29:03 <hospes> evening all
19:42:25 <lamefun> Is there a doWhenSatisfies :: (a -> Bool) -> (a -> b) -> a -> Maybe b function?
19:42:35 <smunix> :t flipAt
19:42:36 <lambdabot>     Not in scope: ‘flipAt’
19:42:36 <lambdabot>     Perhaps you meant ‘flip’ (imported from Data.Function)
19:57:01 <lamefun> Are there stack overflows in Haskell and are they survivable (ie. a program can catch it and go on)?
19:59:10 <c_wraith> there are stack overflows, but it's not a call stack
19:59:15 <c_wraith> They are not recoverable
19:59:25 <c_wraith> ..  Actually, recent versions of GHC made the stack unlimited size
19:59:35 <c_wraith> Then it just runs out of memory instead of overflowing. :)
19:59:59 <geekosaur> mm, if I'm reading this right, StackOverflow can be caught in IO but recovery may be another question
20:00:16 <geekosaur> HeapOverflow can't be caught (more precisely, isn't thrown; it just terminates)
20:00:45 <geekosaur> and yes, with no stack limit I would expect StackOverflow to behave like HeapOverflow
20:03:19 <dolio> You can set finite heaps with overflow errors.
20:03:59 <geekosaur> "GHC currently does not throw HeapOverflow exceptions."
20:04:08 <Welkin> okay, so now the only user-level package I have installed is cabal-install
20:04:13 <Welkin> time to clean out the sandboxes too
20:07:30 <jle`> :t \p f x -> f x <$ guard (p x)   -- lamefun 
20:07:30 <lambdabot> Alternative f => (r -> Bool) -> (r -> a) -> r -> f a
20:07:54 <jle`> guard is alternative, nice :)
20:08:31 <jle`> :t \p f x -> guard (p x) *> return (f x)    -- if you don't like <$
20:08:32 <lambdabot> (Monad f, Alternative f) => (r -> Bool) -> (r -> b) -> r -> f b
20:08:36 <Cale> lamefun: The stack in Haskell effectively consists of pattern matches that are waiting for their scrutinee to be sufficiently evaluated to match (and applications waiting for the *function* to be sufficiently evaluated to apply, in cases where it's not already a lambda)
20:08:40 <jle`> !;
20:08:42 <jle`> ~;
20:10:04 <Cale> It is very rare for the latter type of entry to cause any problems whatsoever in non-contrived scenarios, so to a good approximation, if you ever see a stack overflow, it's because too many pattern matches were waiting to happen.
20:10:58 <c_wraith> I could contrive such a scenario!
20:11:09 <c_wraith> ... But yeah, it wouldn't look like code I normally write.
20:13:15 <devm> Hey guys, started learning haskell today and I have a question, how do I grab elements from a list and basically do all the possible outputs with them, for example if I have True and False and give a function 1 it should give [[True],[False]] and if I give it 2 for example it should give [[True,False],[True,True],[False,False],[False,True]] I have been trying to do something with map but I dont know how to do it
20:13:52 <c_wraith> devm: there's already a function that does that...  How much do you want to do it yourself vs use the existing function?
20:14:15 <devm> Id prefer to do it myself but whats the function ? :p
20:14:18 <c_wraith> > replicateM [True, False] 3
20:14:19 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘[Bool]’
20:14:19 <lambdabot>      In the first argument of ‘replicateM’, namely ‘[True, False]’
20:14:19 <lambdabot>      In the expression: replicateM [True, False] 3
20:14:27 <Cale> > replicateM 3 [True, False]
20:14:28 <lambdabot>  [[True,True,True],[True,True,False],[True,False,True],[True,False,False],[Fa...
20:14:33 <c_wraith> Bah, got the arguments backwards
20:16:12 <c_wraith> devm: As for how it's implemented..  Well, it actually is a combination of simpler functions.
20:16:21 <Cale> devm: (This makes use of the fact that lists form a monad -- in general, replicateM n x where x is an action in some monad will construct an action that "runs" x over and over, n times, and collects a list of the results. For the list monad, "running" a list means picking an element from it in all possible ways.)
20:16:44 <Welkin> okay
20:16:50 <Welkin> so I am having trouble with cabal
20:17:08 <Welkin> the whole install fails because of ansi-terminal
20:17:10 <Cale> Given that it's your first day, you might be more comfortable looking at an approach using list comprehensions...
20:17:16 <Welkin> I checked the logs and it says nothing about why
20:17:26 <Cale> Note that we could pick the elements one by one, using a list comprehension like this:
20:17:28 <devm> yea seems rather complicated at first :)
20:17:39 <Cale> > [[x,y] | x <- [True, False], y <- [True, False]]
20:17:41 <lambdabot>  [[True,True],[True,False],[False,True],[False,False]]
20:18:25 <Cale> So, let's write a function recursively which does more or less this, one element at a time
20:18:59 <Cale> pickN 0 xs = [[]] -- there's only one way to pick zero elements of xs, the only option is the empty list.
20:19:50 <Cale> pickN n xs = [ x : ... | x <- xs, ...] -- we know we want to pick one element of xs at least, which will be the first element of our resulting selected list
20:20:21 <Cale> and then we need to pick n-1 more elements for the tail of the list, which we thankfully have a function to do already, it's the one we're writing:
20:21:03 <Cale> pickN n xs = [ x : rs | x <- xs, rs <- pickN (n-1) xs] -- so we pick the rest of the elements, rs, and that's the tail of the resulting list
20:21:19 <Cale> (in hindsight, maybe I could have named these variables a bit better)
20:21:38 <Cale> Make sense?
20:23:07 <Cale> You might want to add a case before the others to handle negative numbers, like  pickN n xs | n < 0 = [] -- no way to pick fewer than 0 elements
20:23:13 <devm> still trying to make sense of it, im not very handy with haskell yet , still a bit fuzzy for me coming from an imperative language
20:23:31 <devm> Ill try to understand it :p
20:23:43 <Cale> all right, feel free to ask questions about anything
20:23:59 <Cale> I probably could have checked if you had seen list comprehensions yet :)
20:24:27 <devm> alright
20:25:52 <DNoved1> Is it just me, or do others hardly ever use list comprehensions? I see them touted a lot as a language feature for say python and haskell, but I hardly use them myself.
20:26:33 <Welkin> does anyone know what the issue is here?
20:26:34 <DNoved1> Though then again, I'm not super familiar with set theory, which I hear is the inspiration.
20:26:42 <Welkin> I deleted my entire ~/.ghc
20:26:55 <Welkin> and now I can't install yesod-bin in a sandbox
20:27:02 <Cale> Well, once you understand the Monad instance for lists, you don't really need the syntax very much, and also the space they occupy sort of gets trampled by all the nice higher order functions on lists which are available.
20:27:09 <Welkin> or any of the other required packages for my application
20:27:18 <Welkin> it keeps complaining about ansi-terminal
20:27:25 <Welkin> it won't install it
20:27:37 <geekosaur> ~/.ghc can't affect a sandbox
20:27:40 <Cale> But it can be really concise for cases where you're making multiple selections, especially if you're filtering them a bunch in between
20:27:41 <Welkin> exactly
20:27:43 <geekosaur> this sounds like global packages
20:27:45 <jle`> DNoved1: filters and maps and concatMaps make up the majority of obvious list comprehension uses, and in those cases, normal higher order functions are usually nicer and cleaner
20:27:46 <Welkin> so what happened?
20:27:48 <c_wraith> DNoved1: It's rare for me to use comprehensions, too
20:27:58 <Welkin> no
20:28:01 <jle`> DNoved1: but there are cases where comprehensions are more concise, too
20:28:01 <Welkin> my global packages are fine
20:28:20 <Cale> jle`: Well, if you have a bunch of nested concatMaps, you should almost certainly use at least a list comprehension instead, if not do-notation.
20:28:28 <jle`> > [x | Right x <- [Left 2, Right 4, Left 9, Left 10, Left 3, Right 6]]
20:28:29 <lambdabot>  [4,6]
20:28:42 <Cale> Oh, yeah, it's also really nice if you're pattern matching at the same time
20:28:46 <jle`> Cale: concede'd
20:28:48 <geekosaur> note that if your ghc install is the haskell platform, you can pretty much give up on anything involving stackage; stackage believes it is the only true platform
20:29:03 <Cale> and another trick which is quite nice is the degenerate case of a list comprehension with no generators, but a boolean condition
20:29:11 <DNoved1> Hmm, ya, the thing is, it never even crosses my mind to use a list compr, I just think, oh, I have data X, how do I get to data Y? And indeed, it is usually through maps and such I accomplish this.
20:29:21 <Welkin> geekosaur: I'm not using stackage
20:29:31 <geekosaur> (I'm just a bit fed up with a web platform wagging a supposedly general dog; it works about as well as it did in Ruby where it's Rails or the road)
20:29:37 <geekosaur> you are
20:29:42 <Welkin> I am?
20:29:44 <jle`> yeah, the obvious things that list comprehensions are "good for" end up being more nicely expressed in other first-class ways.  but there are still cases where list comprehensions are nice besides those
20:29:46 <geekosaur> because stackage was *created* for yesod
20:30:02 <geekosaur> stackage is all about providing versions of things that will work with yesod
20:30:05 <Cale> You can do things like conditionally adding things to a configuration with something like  concat [[el1 | cond1], [el2 | cond2], ...]
20:30:07 <Welkin> I have been using yesod for almost a year
20:30:10 <jle`> s/besides those/besides those cases
20:30:13 <Welkin> I have always used the haskell platform
20:30:17 <Welkin> never had any issues
20:30:32 <geekosaur> yu must be lucky. it's never been anything but conflicts without end for me
20:30:45 <jle`> yeah, but i like guard for things like that.  but at that point it's a personal opinion i think
20:30:46 <Welkin> how am I using stackage though?
20:30:56 <geekosaur> was I not clear the first time?
20:30:59 <Welkin> I use cabal install like with everything else
20:31:00 <DNoved1> Cale: that looks nice, and I actually have a instance I was working on the other day where it would work.
20:31:04 <geekosaur> stackage is defined as: the dependencies necessary for yesod
20:31:21 <geekosaur> and random other stuff that decided that the web tail should wag the haskell dog
20:31:23 <monochrom> :)
20:31:45 <DNoved1> I suppose I'll have to open my mind a bit more to the possibilities for these sorts of things.
20:32:07 <geekosaur> but primarily stackage is the dependencies for yesod
20:36:18 <Welkin> okay, so what do I do now then?
20:37:13 <geekosaur> well, you can keep trying to install what amounts to stackage the hard way, one package at a time, or you can use the stuff to bootstrap a sandbox from stackage
20:38:06 <geekosaur> and hope there are no conflicts with global packages because it overrides 75% of the platform (and last time I made that mistake, it seemed to want to override parts of the stuff that come with ghc --- I seem to recall it wanted a different containers or something like that)
20:39:20 <Welkin> okay
20:39:33 <Welkin> I don't know anything about stackage
20:39:56 <Welkin> how do I install it?
20:40:05 <Welkin> and will it work with my existing ghc?
20:40:15 <Welkin> or do I need to install a completely new version
20:40:15 <srhb> Depends on your GHC
20:40:19 <Welkin> 7.8.3
20:40:24 <srhb> Then yes.
20:40:25 <Welkin> platform 2014
20:40:29 <geekosaur> http://stackage.org see the Quick Start box
20:40:43 <geekosaur> the LTS release should work with ghc 7.8
20:41:32 <Welkin> god damn it, why is wget not installed on this mac
20:41:42 <Clint> because apple
20:41:44 <Welkin> I thought that was standard
20:41:45 <geekosaur> use curl -O instead
20:41:47 <geekosaur> it's a BSD
20:42:01 <geekosaur> if your definition of standard is GNU/Linux, don;t use a BSD-based OS
20:42:45 <Welkin> can I do this ins a sandbox?
20:42:46 <zacts> is ghc well supported on FreeBSD-10.*?
20:42:57 <zacts> does it have any major missing features there?
20:43:01 <geekosaur> the quick start is telling you how to use it in a sandbox
20:43:10 <geekosaur> :"put this file in your sandbox next to the .cabal file"
20:43:45 <geekosaur> ghc 7.8 worked on freebsd 10.0/10.1 last time I tried it
20:44:12 <geekosaur> I ended up taking down the freebsd box but hope to get another one set up at some point
20:44:43 <geekosaur> the main problem is the amount of stuff that only works on linux (hello, dbus package that only supports a Linux-specific socket type)
20:46:04 <Welkin> brew install wget
20:46:13 <Welkin> I think brew is one of the only reasons I can use a mac...
20:46:44 <Pamelloes> I switched to using nix for my OS X package manager.
20:47:12 <Pamelloes> It's definitely not as refined as MacPorts or Homebrew, but I like nix so much that I'm willing to put up with it.
20:50:11 <itsMontoyaMobile> Hey all :)
20:50:23 <Joey1971> hey
20:50:24 <Welkin> okay...
20:50:30 <Welkin> so now my .cabal has a lot of issues
20:50:38 <Welkin> it's from a project that is now 9 months old
20:50:41 <Welkin> using the scaffolding
20:51:01 <Welkin> the constraints are all conflicting with stackage (too old)
20:52:58 <Welkin> well, that didn't work at all
20:53:04 <Welkin> it still complains about ansi-terminal
20:59:11 <Welkin> does anyone have any advice?
20:59:55 <Welkin> I have a bare platform 2014 install now (after removing ~/.ghc) and cannot install ansi-terminal for some reason
21:00:50 <Welkin> ansi-terminal-0.6.2.1 failed while unpacking the package. The exception was:
21:00:51 <Welkin> user error (File in tar archive is not in the expected directory. Expected:
21:00:52 <Welkin> "." but got the following hierarchy: ["ansi-terminal-0.6.2.1"])
21:02:04 <Welkin> do I also delete ~/.cabal ?
21:02:41 <pacak> Welkin: "for some reason" is not descriptive enough :)
21:02:57 <Welkin> I just pasted the error
21:03:09 <pacak> But yea, removing everything and reinstalling usually helps.
21:07:05 <Welkin> this is ridiculous
21:07:18 <Welkin> suddenly everything is broken
21:09:45 <Pamelloes> Welkin: When that happens, I tend to remove everything and try again. Including GHC if necessary.
21:10:14 <Pamelloes> Perhaps it's a good time to try moving up to GHC 7.10! Use this as an opportunity :D
21:10:25 <Welkin> hm
21:10:31 <Welkin> how much of a pain is that?
21:10:37 <Welkin> I normally use the platform
21:10:46 <Pamelloes> Really depends.
21:10:51 <Welkin> this is a mac too
21:11:00 <Portaljacker> i'm sure this is common as hell, but it's worth asking live people to get an up-to-date answer: best/really good resource for learning haskell? first one i heard about was lyah but i recently heard some stuff against it when talking about learning functional programming and that person said cis194 is the new hotness for learning haskell. opinions?
21:11:02 <jle`> one of us
21:11:06 <Pamelloes> I'm on a mac, as well :)
21:11:17 <Welkin> I wish I wasn't on a mac
21:11:26 <jle`> Portaljacker: there's bitemyapp's guide that people often reference
21:11:28 <jle`> @where learnhaskell
21:11:29 <lambdabot> https://github.com/bitemyapp/learnhaskell
21:11:42 <Pamelloes> Welkin: You can always reformat :P
21:11:45 <Welkin> okay, so where do I begin?
21:12:20 * Pamelloes resurrected is '09 macbook and put on NixOS a few weeks ago.
21:12:31 <Welkin> I don't remember the whole dance I went through the first time getting everything working
21:12:46 <Welkin> I have the command-line tools for xcode
21:13:02 <Pamelloes> Good! Without that, you can't do anything.
21:13:05 <Welkin> I only installed the platform though
21:13:15 <Welkin> so, what's the first step to get 7.10
21:13:26 <Welkin> including how to completely remove the platofrm
21:13:43 <Portaljacker> jle` just starred it, though it's literally just saying cis194, though it specifically says the spring '13 version, no idea why
21:14:04 <Welkin> Portaljacker: that is correct, the content changed after spring '13
21:14:06 <Pamelloes> Well, removing the platform should be pretty easy. iirc there is an uninstall script in /usr/local/bin
21:14:20 <Portaljacker> Welkin: in what way?
21:14:28 <Welkin> Portaljacker: not as good
21:14:37 <Portaljacker> ah
21:14:46 <Portaljacker> well i'll update my pinned tab to that version then
21:15:27 <Portaljacker> any specific reasons newer ones aren't as good?
21:15:31 <Pamelloes> Welkin: Also, if you don't want to deal with the uninstall script, you can jump straight to the big guns and rm -r everything. This link has a list of places to remove stuff: https://mail.haskell.org/pipermail/haskell-cafe/2011-March/090170.html
21:15:42 <Pamelloes> Make sure you don't accidentally delete something important, though!
21:16:10 <c_wraith> as if anyone has ever deleted something important slinging rm -r around.
21:16:12 <Welkin> oh god
21:16:27 <c_wraith> *sob* my networking course homework *sob*
21:16:29 <Welkin> I remember now how I had to install gcc to compile hakyll
21:16:56 <Welkin> I don't see the script
21:17:01 <Welkin> I forgot what it was called
21:17:08 <Welkin> uninstall-platform or something?
21:17:12 <Pamelloes> I think so
21:17:19 <Welkin> uninstall-hs
21:17:24 <Pamelloes> That sounds right
21:17:40 <Portaljacker> i found my answer: https://www.reddit.com/r/haskell/comments/2wbil4/current_best_way_to_learn_haskell_and_functional/coppct0
21:17:41 <Welkin> oh, how can I use multiple versions?
21:17:41 <saulzar> c_wraith, My whole home directory with a stray ~ character  
21:17:48 <Welkin> or is it not worth keeping 7.8 around?
21:17:48 <devm> Cale: quick question, why do when I have something like this "test x y [ x | x <- [1..x] ,y <- [1..y]]" does it multiply the number of times by y that a number from x list appears
21:19:22 <jle`> c_wraith: there's that but earlier this year where a bash install script cleaned up a temp directory by doing something like rm -rf $TMP/
21:19:37 <jle`> *there' this bug report earlier this year
21:19:44 <jle`> but in some cases $TMP ended up not being define
21:19:46 <jle`> d
21:19:49 <jle`> so it was just rm -rf /
21:19:58 <Pamelloes> Welkin: I completely removed 7.8 and haven't had any issues. Probably a good idea to keep it around, at least for a little while, though.
21:20:01 <Welkin> I just removed everything
21:20:05 <Welkin> how is cabal still installed?
21:20:20 <Pamelloes> open a new terminal shell and type cabal. see what happens.
21:20:28 <Pamelloes> (has to be a new one for $PATH updates to take palce)
21:20:34 <Cale> devm: The scope there is a bit weird, with the variable x being reused like that, but yeah
21:20:36 <Pamelloes> *place
21:20:40 <jle`> ah found it, https://bugzilla.redhat.com/show_bug.cgi?id=1202858
21:20:46 <Cale> > [x | x <- [1,2,3], y <- [4,5]]
21:20:48 <lambdabot>  [1,1,2,2,3,3]
21:20:55 <Cale> > [x | x <- [1,2,3], y <- [4,5,6,7]]
21:20:56 <lambdabot>  [1,1,1,1,2,2,2,2,3,3,3,3]
21:21:08 <devm> Cale: yea I was messing around with it and just though it was weird that was the output of that
21:21:14 <Welkin> okay, I removed cabal
21:21:16 <jle`> "Expected result: squid is restrated.  Actual results: all files are deleted on machine."
21:21:19 <Cale> > [(x,y) | x <- [1,2,3], y <- [4,5,6,7]]
21:21:20 <lambdabot>  [(1,4),(1,5),(1,6),(1,7),(2,4),(2,5),(2,6),(2,7),(3,4),(3,5),(3,6),(3,7)]
21:21:38 <Welkin> Pamelloes: so what next?
21:21:46 <Cale> > [(x,y) | x <- [1,2,3], y <- [1..x]]
21:21:47 <lambdabot>  [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3)]
21:22:06 <Cale> devm: If you're familiar with imperative programming, it may help to think of the generators as nested loops
21:22:45 <Pamelloes> Welkin: Well, now you need to get ghc again. Three options: 1) build it yourself (this takes a little while... like 3-4 hours). 2) get a binary via a package manager 3) get a binary via the website
21:23:00 <Pamelloes> Looks like there are os x bindists at https://www.haskell.org/ghc/download_ghc_7_10_1#macosx_x86_64
21:23:23 <devm> Cale : yea makes a bit more sense
21:24:56 <Pamelloes> Welkin: Once you install it, open a new shell and type ghc --version and you should get 7.10.1. That means you were successful :)
21:26:35 <Cale> devm: In Haskell, you can generally think of lists as being loops that haven't happened yet.
21:26:53 <Cale> devm: The things that lists are good for are essentially the same things as loops are good for.
21:27:23 <Welkin> there is no way I am compiling it myself :)
21:27:34 <Cale> You're sort of looking at a bunch of iterations of some loop, splayed out and frozen into a data structure.
21:27:38 <Welkin> this macbook air would take forever
21:27:50 <Welkin> grabbing the binary
21:29:02 <Welkin> Pamelloes: what is a bindist?
21:29:10 <Welkin> oh
21:29:11 <Pamelloes> binary distribution
21:29:12 <Pamelloes> :P
21:29:14 <Welkin> binary distribution
21:29:26 <devm> Cale : I see, that helps 
21:31:14 <Pamelloes> Welkin: I'm going to restart my computer right now (driver update). I'll try to get online quickly via another device soon but I'll be unresponsive for a little while ;)
21:35:57 <Welkin> should I just install it in /usr/local ?
21:36:22 <Welkin> I know the platofrm installed in /Library/Haskell or something similar
21:36:29 <Pamelloes> Probably. Unless you have another installation location you'd prefer.
21:36:37 <Pamelloes> As long as it winds up in your path somewhere.
21:37:39 <Welkin> okay, installing now
21:38:11 <Welkin> afterward, is there an easy way to install everything that comes with the platform at once, or do I have to install each one individually?
21:38:40 <Welkin> done
21:38:44 <Welkin> it works :)
21:39:13 <Pamelloes> Yay!
21:39:20 <Pamelloes> alright, what about cabal?
21:39:30 <Welkin> what about it?
21:39:44 * hackagebot aws-dynamodb-conduit 0.1.0.3 - Conduit-based interface for AWS DynamoDB  http://hackage.haskell.org/package/aws-dynamodb-conduit-0.1.0.3 (srijs)
21:39:46 * hackagebot aws-dynamodb-conduit 0.1.0.4 - Conduit-based interface for AWS DynamoDB  http://hackage.haskell.org/package/aws-dynamodb-conduit-0.1.0.4 (srijs)
21:39:52 <Pamelloes> run cabal --version and check that you're on 1.22.4 and 1.22.0 (I think)
21:40:07 <Pamelloes> If you have ghc and cabal, then you're good to go :)
21:40:29 <Welkin> cabal-install 1.22.5.0 and Cabal 1.22.4.0
21:40:47 <Pamelloes> Huh, newer versions :)
21:41:06 <Pamelloes> Alright, then you're now on the latest and greatest haskell technology. Congratulations!
21:41:23 <Welkin> so, I don't need anything that comes with the platform?
21:41:45 <Pamelloes> The platform installs a bunch of packages. You don't /need/ any of them.
21:41:47 <Welkin> I suppose I should only install packages in sandboxes then
21:42:08 <Pamelloes> Yep, probably a good idea though you can wind up with a lot of compiling :/
21:42:35 <Welkin> I know
21:43:02 <Welkin> it's worth it if the project is important though
21:43:06 <Pamelloes> But yeah, the haskell platform is ghc and a bunch of packages. Just installing ghc without the packages isn't an issue because cabal can install everything.
21:43:50 <Pamelloes> So now, fingers crossed, cabal will automagically get everything needed for your project and you will be good to go.
21:44:18 <Pamelloes> One thing to be forwarned about: you can wind up with some esoteric dependency errors if a package isn't up to date with the newest ghc.
21:44:19 <Welkin> thank you Pamelloes 
21:44:25 <Pamelloes> Np
21:44:25 <Welkin> yes...
21:44:29 <Welkin> s3-signer is broken
21:44:41 <dmj`> it is?
21:44:41 <Welkin> it requires base < 4.8
21:44:44 <Welkin> haha
21:44:46 <Welkin> there you are
21:44:46 <dmj`> that's my bad :)
21:44:49 <Welkin> I was just about to tell you
21:44:53 <dmj`> srry I fell off :)
21:44:58 <dmj`> let me fix that
21:46:01 <Welkin> I'm not even sure what to do with my .cabal file for this yesod project
21:46:12 <Welkin> all the constraints are so out of date
21:46:21 <dmj`> Welkin: you're using the haskell platform?
21:46:28 <Welkin> not since 5 minutes ago
21:47:20 <Welkin> I suppose I could generate a new yesod project and use that as my base
21:47:27 <Pamelloes> Welkin: well, yesod makes things tricky but I tend to just drop all upper bounds and see what happens...
21:47:43 <Pamelloes> Sometimes it works and sometimes it... really doesn't.
21:47:44 <Welkin> Pamelloes: that is a good idea
21:49:33 <Welkin> I don't even have constraints on some of the ones I added myself
21:51:56 <dmj`> Welkin: what about using vanilla wai/warp? There are some plugins to use yesod's type safe routing
21:52:06 <dmj`> Welkin: I don't think HP supports 7.10 ...
21:52:15 <Welkin> ?
21:52:30 <Welkin> I am not using the platform any more
21:53:10 <dmj`> oh
21:53:20 <kadoban> In case nobody has mentioned it, the easiest way to get yesod to compile seems to be using stackage
21:53:23 <Welkin> I nuked everything
21:53:38 <Welkin> kadoban: yes, I am trying that now
21:53:51 <Welkin> I just had to update to 7.10 first
21:53:56 <Welkin> and nuke everything else
21:53:56 <kadoban> Ah
21:54:58 <gamegoblin> @pl \x -> x >= 0 && x <= 255
21:54:58 <lambdabot> liftM2 (&&) (>= 0) (<= 255)
21:55:16 <Welkin> dmj`: can you update s3-signer to use base < 5 ?
21:55:59 <jle`> :t and . sequence [(>= 0), (<= 255)]
21:56:00 <lambdabot> (Num a, Ord a) => a -> Bool
21:56:09 <dmj`> Welkin: latest is up
21:56:23 <dmj`> loosened base upper bound
21:56:46 <Welkin> thank you :)
21:56:50 <Pamelloes> How does one get something on Hackage? Is it a simple process?
21:56:56 <dmj`> for sure :)
21:57:02 <gamegoblin> Spent the last month coding nothing but Rust. After a month I just wanted to go back to Haskell.
21:57:23 <Pamelloes> Hm, interesting.
21:57:24 <dmj`> Pamelloes: cabal sdist && cabal upload dist/package.tgz
21:57:33 <Welkin> gamegoblin: that sounds like me and swift
21:57:35 <dmj`> Pamelloes: assuming you have a user account 
21:57:36 <gamegoblin> Rust has plenty of nice stuff, but I’m far more productive in Haskell
21:57:50 <Pamelloes> dmj`: Ah, how do you get a user account? Just sign up?
21:57:55 <Welkin> although it wasn't by choice
21:58:09 <dmj`> Pamelloes: not sure how they do it these days, back then I had to email a guy who added me manually
21:58:18 <gamegoblin> I was really excited about Rust because it seemed like C + Haskell lovechild
21:58:46 <dmj`> Welkin: what are you using to send email w/ your app?
21:58:49 <Pamelloes> Interesting. Well, my project isn't ready for publishing yet, so I'll leave that for another day :)
21:59:13 <scutigera> haskell is unproductive as hell.
21:59:21 <ttt_fff> how do I learn the political genius and charisma of bill clinton, so I can get #haskellers to write the libraries I want written?
21:59:26 <Welkin> dmj`: none
21:59:29 <Welkin> I don't have email set up
21:59:32 <dmj`> scutigera: only in the beginning
21:59:32 <Welkin> I skipped that part
21:59:34 <scutigera> because i write 20 lines of code. and then i spend 3 weeks trynig to understand applicatvie.
21:59:34 <ttt_fff> jle`: ping ping
21:59:44 <dmj`> Welkin: is that something you need?
21:59:44 <jle`> hey ttt_fff 
21:59:45 * hackagebot s3-signer 0.3.0.0 - Pre-signed Amazon S3 URLs  http://hackage.haskell.org/package/s3-signer-0.3.0.0 (DavidJohnson)
21:59:45 <scutigera> and then i re-write the 20 lines of code.
21:59:49 <kadoban> ttt_fff: Money is a good motivator.
21:59:53 <jle`> pong :)
21:59:55 <scutigera> and then try to understand monads. AGAIN.
21:59:56 <scutigera> lol
22:00:11 <gamegoblin> Something I really really missed in Rust were Haskell’s really nice parser combinator libraries and do-notation
22:00:13 <pacak> Monads are nice and fluffy
22:00:16 <ttt_fff> jle`: hey! awesome! what is the theoretical under pining of auto ?
22:00:18 <Welkin> dmj`: I am thinking about adding email auth instead of using Persona or another 3rd party because people complain about it, but I'm not sure right now
22:00:24 <gamegoblin> People have written parser combinators for rust, but the lack of do-notation makes them super clunky
22:00:31 <ttt_fff> jle`: why is it more than 'just' a spread sheet represented as a DAG
22:00:32 <scutigera> pacak: and they purr and make me feel about as smart as a cat
22:00:48 <dmj`> Welkin: oh I was referring to like sending your users emails, but yea I'd roll my own auth too
22:00:56 <scutigera> i read edwardk's stuff and feel like a moron
22:01:09 <dmj`> edwardk isn't human though
22:01:10 <jle`> ttt_fff: semantically it is the library of manipulating/arranging relationships between infinite streams
22:01:13 <Welkin> dmj`: what wold you use besides sendmail?
22:01:28 <Welkin> scutigera: I don't understand edwardk's stuff either
22:01:33 <scutigera> dmj`: aha! i knew it !
22:01:47 <gamegoblin> scutigera: read Gabriel Gonzalez’ blog, it’s pretty good
22:01:49 <scutigera> Welkin: ty. that truly does make me feel better :-)
22:02:00 <scutigera> gamegoblin: name ?  i think maybe i do.
22:02:04 <gamegoblin> "haskellforall"
22:02:19 <dmj`> Welkin: amazon ses
22:02:34 <jle`> ttt_fff: the closest relationship to the "spreadsheet" thing is a spreadsheet where one field is manipulated while the others update in response, but their new updated values can depend on the entire history of the spreadsheet so-far
22:02:42 <scutigera> gamegoblin: ah yes. definitely read that. it's definitely much more accessible.  but can still go off the deep-end for me.
22:02:50 <jle`> ttt_fff: so im not really sure a spreadsheet picture is the most useful/meaningful analogy
22:03:15 <Welkin> dmj`: oh, I did look into that when trying to figure out how to add email auth
22:03:22 <Welkin> actually, I set that up, but never used it
22:03:36 <kadoban> gamegoblin: Does rust have applicative? You can do a lot of parsing in applicative quite nicely
22:03:40 <Welkin> I use mailchimp for mass emails though
22:03:44 <gamegoblin> kadoban: no
22:03:53 <pacak> scutigera: "If F and G  are a pair of adjoint functors, with F left adjoint to G, then the composition G.F  is a monad."
22:03:56 <jle`> ttt_fff: composition, side-chaining, transformation of causal relationships between Stream a's is the semantic picture of the library
22:04:07 <scutigera> pacak: no - my head did not explode.
22:04:11 <dmj`> Welkin: mailchimp is just newsletters right? What about transactional email, like registration confirmation etc
22:04:13 <ttt_fff> jle`: damn this is a lot of buzz words; how do I learn this?
22:04:20 <kadoban> gamegoblin: Could you just implement it in terms of monad and then use it? Hehe
22:04:27 <scutigera> my brains are just slowly leaking out of my ears...
22:04:29 <ttt_fff> jle`: 'buzz words' not as meant to be an insult, but terms I don't understand
22:04:33 <gamegoblin> kadoban: it doesn’t have monad. It doesn’t have kigher-kinded types.
22:04:41 <kadoban> Oh.
22:04:45 <jle`> ttt_fff: heh, it's 
22:04:50 <kadoban> Well that's kinda crap.
22:05:01 <pacak> scutigera: Why? It's a nice and short description of what a monad is in non-programming terms :)
22:05:09 <Maxdamantus> Types are of one kind :(
22:05:18 <jle`> ttt_fff: the buzzwords sort of hide the actual concept maybe, heh, sorry
22:05:35 <dmj`> Welking: either way, shameless plug
22:05:39 <dmj`> @package ses-html
22:05:39 <lambdabot> http://hackage.haskell.org/package/ses-html
22:05:50 <saulzar> ttt_fff, Spreadsheets are static, most FRP (like auto) allows you to expand the size of the graph, swap bits out - so it's quite a lot more..
22:06:10 <jle`> ttt_fff: if you think of a causal relationship between infinite streams...like ([a] -> [b])'s, where the nth item of b can only depend on the 0-nth items of a.  so it transforms an infinite [a] into an infinte [b] "piece by piece"
22:06:17 <scutigera> pacak: yeah but adjoint is on page 439 of topoi. so not getting to it for a long time.
22:06:29 <definity> How can i exit ghci back into the prelude when a program is loaded?
22:06:31 <pacak> scutigera: catsters!
22:06:38 <jle`> ttt_fff: semantically, auto would be a library that lets you create complex relationships by buildin up simple, primitive ones
22:07:03 <dmj`> definity: what do you mean "back into the prelude"
22:07:07 <gamegoblin> kadoban: you can hand-implement a monad-like interface for a specific type. Like there is the Option type (equivalent to Haskell’s Maybe). You can do Some(5).and_then(None).and_then(|x| Some(3)). Which is equivalent to haskell’s Just 5 >>= None >>= \x -> return 3.
22:07:12 <scutigera> "The isolation and explication of the notion of adjointness is perhaps the most profound contribution that category theory has made to the history of general mathematical ideas."
22:07:14 <jle`> ttt_fff: so if you can express your program (game, chat bot, text processor) as some sort of [a] -> [b], then auto lets you build up a complex [a] -> [b] by "composing" simple, primitive ones
22:07:42 <jle`> that's the statement of the semantic model, at least.  if you were looking for a theoretical mathy basis
22:08:18 <kadoban> gamegoblin: But then another monad would have to have everything reimplemented I guess?
22:08:22 <ttt_fff> jle`: you should write a tutotial called 'auto from scratch' ... which expalins how you can re-invent auto on your own
22:08:25 <gamegoblin> kadoban: yes
22:08:33 <mzero> definity: are you refering to the text that is before the prompt?
22:08:43 <gamegoblin> kadoban: and because of that, you can’t write functions which apply to all monads, like LiftM or something.
22:08:48 <mzero> that is really just a list of all the modules in scope
22:08:52 <kadoban> Right. That's kinda painful.
22:09:07 <mzero> and the Prelude is probably still in that list
22:09:11 <definity> mzero: Well once i laod a program he prelude changes to '*Main>'
22:09:18 <definity> but i want to go back to prelude
22:09:18 <scutigera> pacak: hmmmm.. it's not that bad actually. there's a pretty picture there that makes perfect sense.  but fuggadaboutit, if i can figure out how that leads to a Monad.
22:09:20 <mzero> right - but you have the Prelude as well
22:09:22 <mzero> try it!
22:09:25 <dmj`> jle`: hai 
22:09:30 <Welkin> oh jesus
22:09:37 <Welkin> stackage requires mtl == 2.1.3.1
22:09:50 <scutigera> they don't call it cabal hell for nothing.
22:09:53 <mzero> the star, btw, means you have all the non-exported things in Main in scope too
22:09:54 <saulzar> ttt_fff, I believe there's quite a few papers/tutorials around quite like that
22:09:56 <Welkin> but ghc 7.10 uses higher than that
22:10:03 <Welkin> oh
22:10:09 <Welkin> I need to switch to the nightly stackage
22:10:13 <kadoban> Welkin: Did you use the right stackage? You need nightly, yeah.
22:10:19 <jle`> ttt_fff: heh, what i've said actually is more or less the entirety of the core semantic model, but the library brings in other semantic concepts to make life easier when writing useful programs.  but you might be asking for a tutorial on how auto is actually implemented
22:10:21 <kadoban> LTS is still on 7.8.4 or whatever.
22:10:23 <gamegoblin> Rust has a really really really awesome package manager, though. You just put your dependencies in a file and it pulls them and builds them automagically.
22:10:25 <mzero> Welkin - isn't there a separate stackage for 7.10?
22:10:38 <pacak> scutigera: catsters, don't limit yourself to just one source of the information.
22:10:57 <mzero> ah - yeah - nightly!
22:10:59 <scutigera> pacak: what is this catsters you mention ?
22:11:02 <jle`> ttt_fff: in which case, i did write a blog series about a year and a half ago about the underlying data structure that is used to implement the auto library, http://blog.jle.im/entries/series/+intro-to-machines-and-arrows
22:11:05 <jle`> dmj`: hullo
22:11:21 <pacak> scutigera: https://byorgey.wordpress.com/catsters-guide-2/
22:11:38 <ttt_fff> jle`: will read that, thanks!
22:11:40 <ttt_fff> saulzar: noted
22:11:44 <pacak> scutigera: And if you think about monads and adjunctions from category theory point of view - everything gets much eaiser.
22:12:02 <jle`> technically though auto itself isn't really about its implementation,a nd could be implemented in many other ways...the main thing it offers is the semantic picture and ecosystem/platform for writing programs using it
22:12:13 <Welkin> okay
22:12:15 <pacak> scutigera: Even that "monoid in a category of endofunctors" thingy.
22:12:18 <scutigera> pacak: yeah- golblatt's book is actually pretty good. but there's a LOT there.
22:12:28 <Welkin> so I ran into the same error I was getting before
22:12:55 <Welkin> Failed to install appar-0.1.4
22:13:37 <scutigera> scary that monads are about 2/3 of the way through the book and sort of mentioned "in passing".
22:14:22 <Welkin> hm
22:14:25 <pacak> scutigera: Which book is that?
22:14:32 <dmj`> all functors in haskell are endo
22:14:46 * hackagebot wlc-hs 0.1.0.0 - Haskell bindings for the wlc library  http://hackage.haskell.org/package/wlc-hs-0.1.0.0 (cocreature)
22:14:54 <Welkin> I have a fresh install of ghc 7.10 and am using the nightly stackage cabal.config
22:14:55 <jle`> all Functors are endofunctors ;)
22:15:08 <scutigera> pacak: Topoi The Categorial Analysis of Logic
22:15:52 <scutigera> endofunctor T:C->C. that's it ? really ?
22:16:34 <dmj`> jle`: in Hask :)
22:17:18 <definity> Is the 'where' keyword used for setting expressions and the 'let'  keyword used for setting data
22:17:45 <kadoban> Welkin: That doesn't seem like it makes sense :-/ Not sure.
22:18:12 <jle`> definity: hm, (let .. in ..) is an expression, like 1 or [1,2,3] or "hello" or (5 + 9)
22:18:31 <jle`> definity: foo = bar where (declaration, declaration, delcration) is a declaration
22:18:46 <Welkin> what is with appar?
22:18:50 <dmj`> definity: they're equivalent to each other
22:19:31 <definity> So the difference btween them is scope?
22:19:35 <definity> between*
22:19:46 * hackagebot hackernews 0.5.0.0 - API for Hacker News  http://hackage.haskell.org/package/hackernews-0.5.0.0 (DavidJohnson)
22:20:04 <mzero> the difference is syntax: you can use let where you can use any expression - you can use where as part of a declaration
22:20:29 <definity> Ahhh I see, thanks :)
22:21:19 <saulzar> definity, Often a matter of preference depending if you prefer to put some auxillary expressions/variables before or after 
22:23:39 <Welkin> I wonder if I need to switch the compiler to gcc or something?
22:23:43 <Welkin> it doesn't look that way though
22:23:53 <Welkin> but it gives me no information on why it fails to install
22:25:38 <dmj`> Welkin: what version, 0.1.4?
22:27:12 <Welkin> yes
22:27:42 <Welkin> I also fail to install primitive-0.6 when trying to install alex and happy
22:29:38 <dmj`> Welkin: are you on osx
22:30:27 <Welkin> yes
22:31:28 <dmj`> Welkin: time to switch to nix :)
22:31:32 <mzero> Welkin: does it build?
22:31:38 <mzero> it builds just fine on my OS X machine
22:31:46 <dmj`> mine too
22:33:28 <Welkin> no
22:33:34 <Welkin> cabal install appar fails
22:34:13 <dmj`> doesn't fail for me
22:34:27 <mzero> what ghc version? how did you install ghc?
22:34:35 <Welkin> do I need to install alex and happy at the user-level?
22:34:37 <dmj`> http://lpaste.net/134648
22:34:43 <Welkin> perhaps stackage is doing something odd?
22:35:04 <mzero> Welkin: try   alex --version   and see if it is there 
22:35:05 <dmj`> Welkin: can you try with vanilla cabal + hackage
22:35:26 <mzero> (for the record I'm using HP 2014.2.0.0 here - worked just fine)
22:35:34 <Welkin> command not found
22:35:48 <Welkin> mzero: I'm not on the platform any more
22:35:54 <Welkin> because of other issues
22:36:09 <Welkin> so alex and happy are not on the system
22:36:14 <mzero> but - shouldn't matter - appar doesn't use alex or happy
22:38:04 <Welkin> primitive fails to install when I cabal install alex happy
22:38:28 <Welkin> Pamelloes: any thoughts?
22:39:39 <mzero> what version of ghc do you have?
22:39:44 <Welkin> 7.10.1
22:40:06 <mzero> and you installed this from bindist?
22:40:08 <mzero> or?
22:40:10 <Welkin> yes
22:40:52 <mzero> okay - I'd try this:    cd   /tmp (or wherever)    cabal unpack primitive ; cabal build
22:41:00 <mzero> that'll tell you why that is failing
22:41:02 <mzero> er
22:41:17 <mzero> cabal unpack primitive ; cd primtive-0.6 ; cabal build
22:41:44 <mzero> you can work your way up the stack --- doing the same with alex, then happy, and finally appar
22:41:57 <mzero> this way you see what is going on and can re-run cabal build -v if you need
22:42:13 <Welkin> what I am really trying to install is my yesod application that used to be on 7.8.3 and yesod 1.4.0
22:42:15 <mzero> (assuming you neex alex and happy for somethign other than appar)
22:42:55 <mzero> d'aw see... it was so happy with 7.8.3 - and then you went and tried to pull in the new shiny.... ;-)
22:43:17 <Welkin> well, no
22:43:23 <Welkin> I had to install esqueleto
22:43:30 <Welkin> but that caused cabal hell
22:43:44 <Welkin> so, this is all the fault of esqueleto
22:44:45 <mzero> I wonder why - esqueleto doesn't seem to need to much
22:44:57 <Welkin> oh, wow
22:45:03 <Welkin> maybe this is a stackage issue?
22:45:09 <Welkin> outside of the sandbox it works fine
22:46:07 <mzero> wait - are you using Stackage nightly - or LTS?
22:46:36 <Welkin> nightly
22:46:54 <Welkin> I used cabal build after unpacking
22:46:59 <Welkin> so where did it install it?
22:47:01 <mzero> hmmm... and that *has* esqueleto - so you'd think it would just work
22:47:08 <mzero> building doesn't install
22:47:12 <Welkin> it says it registered it with ghc-pkg, but I don't see it
22:47:18 <mzero> the built artifacts are in the dist sir
22:47:19 <mzero> dir
22:47:37 <mzero> so you did    cabal install
22:47:38 <mzero> ?
22:47:46 <mzero> it should tell you where it installed
22:48:14 <Welkin> no
22:48:16 <Welkin> cabal build
22:48:27 <Welkin> but it registered it with ghc-pkg, or it said it did
22:49:11 <mzero> i think you might have seen
22:49:12 <mzero> In-place registering appar-0.1.4...
22:49:21 <mzero> which just means that it made a registration file - but didn't use it
22:49:27 <mzero> (hence "in-place")
22:49:29 <Welkin> ah
22:50:04 <Welkin> well, it looks like it built fine
22:50:08 <Welkin> primitive
22:50:28 <mzero> so it is only not building (or installing) when you do it in your stackage enabled project?
22:51:00 <Welkin> yes
22:51:19 <Welkin> so should I just install alex and happy at the user-level?
22:51:27 <Welkin> I don't want to get into cabal hell again
22:52:21 <mzero> well... alex and happy are just binaries
22:52:43 <mzero> you could build each one in a sandbox - and then move the binaries on to your path
22:52:59 <mzero> but really - they aren't going to install any packages in your pkg db
22:53:02 <Welkin> they seem to depend on a few packages
22:53:12 <mzero> as build tools, probably
22:53:15 <mzero> not as libs
22:53:45 <kadoban> I generally make a sandbox for each tool I'm installing, install it in the sandbox and link it in ~/bin/
22:53:49 <Welkin> mtl-2.2.1 happy-1.19.5 primitive-0.6 random-1.1 tf-random-0.5 QuickCheck-2.8.1 alex-3.1.4
22:53:54 <kadoban> I don't know if that's actually required, but it works.
22:53:58 <Welkin> when I cabal install alex happy
22:54:06 <Welkin> er, --dry
22:54:19 <definity> Is there a website where i can see all the haskell type classes and what they do?
22:54:35 <Welkin> @where typeclassopedia
22:54:35 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
22:54:40 <Welkin> definity: there
22:54:47 * hackagebot text-render 0.1.0.0 - A type class for rendering objects as text, pretty-printing, etc.  http://hackage.haskell.org/package/text-render-0.1.0.0 (thinkpad20)
22:55:10 <gamegoblin> I wish more Haskell libraries made use of unsigned integers to represent positive values like indexes and lengths
22:55:15 <gamegoblin> like c uses size_t 
22:58:06 <pacak> gamegoblin: Sometimes you want to speak about differences between those numbers.
22:58:52 <pacak> gamegoblin: Whichever makes more sense for you - list a is longer than list b by -5 elements or list a is longer by list b by  18446744073709551611 elements?
22:59:14 <gamegoblin> pacak: list b is longer than list a by 5 elements
22:59:48 * hackagebot error-list 0.1.0.0 - A useful type for collecting error messages.  http://hackage.haskell.org/package/error-list-0.1.0.0 (thinkpad20)
22:59:50 * hackagebot text-render 0.1.0.1 - A type class for rendering objects as text, pretty-printing, etc.  http://hackage.haskell.org/package/text-render-0.1.0.1 (thinkpad20)
23:00:33 <gamegoblin> pacak: integer overflow is undefined in C, so it’s not really fair to say some giant number on overflow. Just don’t let it happen. Same as any other fixed-width integer language.
23:01:03 <gamegoblin> that being said, I guess one could also reason "just don’t pass in negative numbers to something expecting positive numbers"
23:01:08 <gamegoblin> neither here nor there, I suppose
23:01:28 <quchen2> "Just don't pass wrong strings to a function expecting some well-formed input"
23:02:14 <pacak> Sometimes you want to get negative numbers, not directly, but based on positive ones. You'll have to use fromIntegral all over the place. I think I tried to use Word in one case - wasn't that nice as you think.
23:02:46 <gamegoblin> I guess it only works well enough in C because of all the implicit casts the compiler does for you
23:04:49 * liste wonders why his system hasn't crashed today
23:06:37 <haasn> How difficult is the problem of assigning integer representations at compile time? eg. functions would only distinguish between ℕ and ℤ in their parameters / return types, and the compiler would pick the right integer type and size automatically to minimize internal conversions. I would assume it's uncomputable, but maybe there's a way to relax the requirements to make it easier? (either by relaxing the
23:06:39 <haasn> “minimize conversions” criteria or by making the programmer specify more)
23:06:40 <Welkin> look what I found: https://twdkz.wordpress.com/2015/02/25/haskell-on-yosemite-osx-10-10/
23:07:07 <haasn> (I say uncomputable because I assume figuring out the right bit size on its own is an uncomputable problem)
23:07:13 <Welkin> kadoban: he does what you do
23:08:24 <kadoban> Heh, yeah I think a bunch of people do.
23:08:34 <haasn> (This kind of analysis could in theory also be used to eliminate the need for internal tagging between GMP integers and machine integers in types like Integer; although only in cases where you aren't relying on user input)
23:09:48 * hackagebot error-list 0.1.0.2 - A useful type for collecting error messages.  http://hackage.haskell.org/package/error-list-0.1.0.2 (thinkpad20)
23:09:50 * hackagebot simple-nix 0.1.0.0 - Simple parsing/pretty printing for Nix expressions  http://hackage.haskell.org/package/simple-nix-0.1.0.0 (thinkpad20)
23:11:34 <gamegoblin> Is there a decent way to instantiate a data type with all record fields set to undefined? Without explicitly setting them all?
23:11:35 <Welkin> here we go again
23:11:37 <Welkin> god damn
23:11:50 <Welkin> I tried to install alex and happy in a sandbox, and it failed while installing primitive
23:12:15 <liste> @let data Foo = Foo { bar :: Int, baz :: Int }
23:12:16 <lambdabot>  .L.hs:153:1:
23:12:16 <lambdabot>      Multiple declarations of ‘Foo’
23:12:16 <lambdabot>      Declared at: .L.hs:147:1
23:12:21 <liste> @undefine
23:12:21 <lambdabot> Undefined.
23:12:23 <liste> @let data Foo = Foo { bar :: Int, baz :: Int }
23:12:24 <lambdabot>  Defined.
23:12:29 <liste> > Foo{}
23:12:31 <lambdabot>      No instance for (Show Foo)
23:12:31 <lambdabot>        arising from a use of ‘show_M47809516735992051807954’
23:12:31 <lambdabot>      In the expression:
23:12:34 <liste> @undefine
23:12:34 <lambdabot> Undefined.
23:12:39 <liste> @let data Foo = Foo { bar :: Int, baz :: Int } deriving (Show)
23:12:40 <lambdabot>  Defined.
23:12:42 <liste> > Foo{}
23:12:43 <lambdabot>  Foo {bar = *Exception: <interactive>:3:1-5: Missing field in record construc...
23:12:44 <gamegoblin> liste: got it, thanks. Didn’t know if that’d compile
23:13:19 <liste> np :)
23:13:30 <liste> it gives a compiler warning though
23:13:41 <liste> but I guess it's a good thing, assuming you're prototyping
23:13:55 <gamegoblin> liste: it’s for mocking/stubbing in tests
23:14:47 <liste> > Just{}
23:14:48 <lambdabot>  Just *Exception: <interactive>:3:1-6: Missing field in record construction
23:14:54 <Welkin> okay
23:14:56 <liste> works with non-records too
23:14:58 <Welkin> so primitive will not install
23:14:59 <Welkin> ever
23:15:41 <howdoi> "A monad is essentially just a functor T  with two extra methods, join, of type T (T  a) -> T a, and unit (sometimes called return,  fork, or pure) of type a -> T a." that's it! :)
23:16:01 <Welkin> does anyone else have any advice?
23:16:28 <Welkin> clean install of ghc 7.10.1, but some packages fail to install through cabal
23:16:35 <Welkin> namely, appar and primitive
23:16:36 <liste> howdoi don't forget the laws
23:17:07 <lyxia> Welkin: Are there error messages?
23:18:24 <liste> or do the laws for join+unit come for free for functors?
23:18:46 <Welkin> wtf??
23:18:51 <Welkin> now "Failed to install random"
23:18:58 <Welkin> what is going on here?
23:19:09 <Welkin> when I unpack primitive-0.6 and cabal install, it works
23:19:18 <Welkin> but then other packages just fail
23:19:38 <Welkin> lyxia: none, just "failed to install
23:20:20 <Welkin> random won't install all by itself even
23:21:02 <Welkin> what the fuck?
23:21:29 <Welkin> they only install if I cabal unpack <package> && cd <package> && cabal install
23:21:48 <Welkin> ...
23:21:55 <Welkin> okay, this feels like a joke
23:22:00 <lyxia> :( sorry
23:22:03 <Welkin> every single package is failing to install
23:22:12 <Welkin> something is wrong
23:22:35 <Welkin> 7.10.1 on osx
23:22:40 <liste> Welkin did you do cabal install cabal-install ?
23:22:55 <Welkin> I already have cabal-install
23:23:03 <Welkin> should I install it again?
23:23:07 <lamefun> Excellent. Have I broken Haskell's type inference? http://lpaste.net/134651
23:23:31 <Welkin> nope, I can['t
23:23:34 <Welkin> because mtl fails to install
23:23:39 <Welkin> I can't install anything
23:23:45 <liste> no, I just wonder if you have two cabal-installs
23:23:53 <liste> and the wrong one is used
23:23:56 <howdoi> liste: can you give a link that list all the lawz
23:24:13 <Welkin> could it be possible there is an old binary left over from my HP install?
23:24:23 <gamegoblin> Drives me insane that Haskell doesn’t allow trailing commas like data T = T { foo :: A, bar :: B, } 
23:24:27 <gamegoblin> (note the comma after B)
23:25:00 <gamegoblin> > [1,2,3,]
23:25:01 <lambdabot>  <hint>:1:8: parse error on input ‘]’
23:25:03 <gamegoblin> There also
23:25:48 <Cale> lamefun: No, this isn't broken.
23:25:49 <pacak> > (1, 2,3,4, ) 5
23:25:50 <lambdabot>  (1,2,3,4,5)
23:26:06 <pacak> :t (1, 2,3,4, )
23:26:07 <lambdabot> (Num t, Num t1, Num t2, Num t3) => t4 -> (t, t1, t2, t3, t4)
23:26:09 <Cale> lamefun: let/where by default are not generalised.
23:26:13 <liste> howdoi https://en.wikipedia.org/wiki/Monad_%28functional_programming%29#fmap_and_join here
23:26:21 <gamegoblin> I can see why you wouldn’t do it for tuples, because of tuple-sections
23:26:40 <gamegoblin> but records and lists...
23:26:50 <pacak> gamegoblin: Consistency.
23:26:54 <pacak> gamegoblin: http://xkcd.com/1537/
23:26:58 <liste> Welkin try `which cabal' and `which ghc' on command line
23:28:00 <lamefun> Cale, moved it to top level, same thing.
23:28:13 <howdoi> liste: cool
23:28:31 <Cale> Oh, also the monomorphism restriction applies to your definition
23:28:37 <Welkin> where is cabal supposed to be if I installed ghc from a bindist?
23:28:44 <Cale> So make sure that's turned off
23:28:59 <Welkin> it looks like all my old binaries are still in ~/Library/Haskell/bin
23:29:29 <Welkin> does cabal come with ghc?
23:29:34 <kadoban> Heh, that's kinda funny ... I'm setting up a new computer with GHC and i also can't get anything to install. I'm not sure why yet though.
23:30:02 <Cale> lamefun: It'll build with NoMonoLocalBinds (with the definition in the where clause) or NoMonomorphismRestriction (with it at top level)
23:30:23 <supki> gamegoblin: I think that because nobody cares enough to propose the change
23:30:31 <supki> import lists support trailing commas
23:31:02 <Welkin> if I delete the cabal binary, where do I get the proper one from?
23:31:13 <pacak> Welkin: From cabal-install
23:31:37 <Cale> lamefun: It'll also work to add some explicit arguments to matchMeta (at top level) so that it's a function binding and the MR doesn't apply to it
23:32:25 <liste> did Applicative originate from Haskell?
23:32:35 <liste> and Functor and Monad from category theory
23:33:18 <Cale> liste: Applicative is equivalent to something that category theorists were already studying in a different form, but yeah.
23:33:25 <Welkin> pacak: without using cabal?
23:33:45 <pacak> Welkin: Yep, you can install it without using cabal
23:34:14 <lamefun> matchMeta p m = matchMaybe (matchMaybeList (==)) p m - works both for the top level and where
23:34:18 <pacak> Welkin: There's a script that installs stuff inside.
23:34:43 <Welkin> where?
23:34:51 <Welkin> in ghc-pkg, I see Cabal-1.22.2.0
23:35:10 <Welkin> cabal -version gives me cabal-install version 1.22.5.0
23:35:11 <Welkin> using version 1.22.4.0 of the Cabal library
23:35:16 <Cale> lamefun: Ah, interesting. Oh right, NoMonoLocalBinds is default if you don't turn on various extensions.
23:35:34 <Cale> (but the monomorphism restriction will still screw with you)
23:37:08 <ReinH> joneshf-laptop: still believe what?
23:37:11 <liste> Welkin that sounds bad
23:37:26 <liste> I always run into trouble when tools use different versions of Cabal
23:37:31 <Welkin> where is cabal supposed to be if I only installed ghc (in /usr/local)
23:38:49 <liste> Welkin the Cabal library?
23:39:35 <Welkin> the executable
23:39:39 <liste> mine is (in the equivalent of) /usr/local/lib/ghc-7.8.4/Cabal-1.18.1.5/
23:39:43 <liste> the library, that is
23:39:50 <liste> I don't suppose cabal-install comes with ghc?
23:39:53 <Welkin> I just removed ~/Library/Haskell entirely
23:40:09 <Welkin> it had old executables in it
23:40:15 <Welkin> okay
23:40:17 <Welkin> where od I get it?
23:41:05 <liste> Welkin https://www.haskell.org/cabal/download.html
23:41:15 <Welkin> okay
23:41:15 <liste> there's a binary for Mavericks
23:41:26 <Welkin> I am on yosemite
23:41:33 <Welkin> maybe I should nuke ghc and start over again
23:41:46 <Welkin> what do I even need to delete?
23:41:54 <Welkin> just the ghc executables?
23:42:23 <lamefun> Cale, does it mean that the matchMaybe and matchMaybeList functions are flawed if they hit the restriction?
23:42:48 <liste> Welkin ghc has a lot of other files too
23:43:38 <Welkin> well, the cabal package that shows up in ghc-pkg is 1.22.2
23:45:38 <Cale> lamefun: no, the monomorphism restriction itself is a bit questionable (which is why there has been an option to turn it off for about as long as it has existed). It exists to try to protect against certain cases where it can look like you're defining a constant, but due to type class polymorphism, you are actually defining a function (of the type class dictionary), which will result in re-evaluation of the "constant" 
23:45:39 <Cale> every time it's used.
23:46:10 <liste> Welkin there's bootstrap.sh in cabal-install archive
23:46:22 <liste> so you can just download the sources and ./bootstrap.sh
23:46:50 <Cale> lamefun: Of course, in cases where the thing you're defining is of function type *anyway* it's maybe questionable (though the evaluation of things of function type can end up doing work that persists and is shared between the usage sites, and this can be important to performance)
23:48:02 <liste> Welkin but I guess halcyon/nix would lead to less headaches
23:49:17 <lamefun> Cale, what do you mean? So currying is to be avoided?
23:49:27 <Welkin> it's installing now
23:49:50 * hackagebot nixfromnpm 0.1.0.0 - Generate nix expressions from npm packages.  http://hackage.haskell.org/package/nixfromnpm-0.1.0.0 (thinkpad20)
23:49:52 * hackagebot json-togo 0.1.0.2 - Effectful parsing of JSON documents  http://hackage.haskell.org/package/json-togo-0.1.0.2 (srijs)
23:49:54 <Welkin> although that is strange that there is a difference between the library versions
23:54:50 * hackagebot json-togo 0.1.0.3 - Effectful parsing of JSON documents  http://hackage.haskell.org/package/json-togo-0.1.0.3 (srijs)
23:55:30 <lamefun> Cale, do you mean things like foo :: Num a -> a by "fake constant that's actually a function)?
23:55:51 <Welkin> okay
23:56:02 <Welkin> cabal-install has been installed in .cabal/bin
23:56:14 <Welkin> does ghc come with the Cabal library?
23:56:42 <Welkin> it looks like it did, but then it is the old version (1.22.2) rather than the new one (1.22.4)
23:57:01 <Cale> lamefun: yeah
23:57:32 <Cale> lamefun: like if you defined  x = product [1..10000]  and used it in a bunch of places. If the inferred type is  x :: Num a => a  then x will be recomputed each time it's used.
23:58:01 <Cale> lamefun: Whereas if x :: Integer, then it will be computed once and remain in memory so long as there are references to it throughout the rest of the program.
23:58:07 <lamefun> Why will it be recomputed?
23:58:20 <lamefun> Do you mean, computed once for each type (eg. Integer, Int, Float)?
23:58:26 <Cale> Because a value of type (Num a) => a is really a function of the type class dictionary for Num
23:58:35 <Cale> Nope, it won't be memoised for each type
23:58:55 <Cale> (nor would any other function be memoised automatically for the values it's applied to)
23:59:30 <lamefun> and why is x :: Integer ; x = product [1..10000] not a function?
23:59:40 <Welkin> okay, shit
23:59:40 <Cale> Well, it's clearly an Integer
23:59:46 <Welkin> it really is using version 1.22.2
23:59:50 * hackagebot aws-dynamodb-conduit 0.1.0.5 - Conduit-based interface for AWS DynamoDB  http://hackage.haskell.org/package/aws-dynamodb-conduit-0.1.0.5 (srijs)
