00:02:16 <breadmonster> mauke[: Okay
00:02:21 <mniip> mauke[, but
00:02:28 <mniip> architectural design failures
00:02:30 <breadmonster> I'm most worried about the bit that involves actual compilation.
00:02:36 <breadmonster> I have *no* idea how to do that.
00:02:43 <breadmonster> I'm just doing this project on a whim though.
00:03:18 <dfeuer> Compilers are scary.
00:03:25 <breadmonster> Like up to transforming a minimal AST is doable.
00:03:29 <breadmonster> Because I have guides and so on.
00:03:36 <breadmonster> I don't know how out emit assembly.
00:03:37 <mniip> breadmonster, you compile your functions to assembly, create an in-memory layout and serialize everything in ELF
00:03:47 <mniip> voila
00:03:51 <breadmonster> Primarily because I've never done any coursework in computer science.
00:03:52 <dfeuer> I don't even know how to *write* assembly.
00:04:02 <mniip> oh yeah
00:04:03 <breadmonster> mniip: I have no idea how memory is laid out.
00:04:04 <mniip> forgot to mention
00:04:09 <mniip> you need to be very versed in assembly
00:04:16 <breadmonster> I only heard about interrupts yesterday :P
00:04:20 <mniip> and if you're going for ELF - how ELF programs are loaded
00:05:02 <breadmonster> mniip: Were you a CS student?
00:05:10 <mniip> not yet
00:05:29 <breadmonster> Not yet?
00:05:56 <mniip> going to start being one this year :)
00:06:04 <bartiosze> Hi guys, I'm writing a birthday card for a friend who is in love with Haskell. I'd like to make it fun with some monad reference (like 'maybe' monad together with 'Happy Birthday'). I got Maybe definition from http://image.slidesharecdn.com/fp-by-examples-130723041014-phpapp01/95/functional-programming-by-examples-using-haskell-57-638.jpg, how do I apply this Maybe to 'Happy Birthday'? is it like: Maybe "Happy Birth
00:06:04 <bartiosze> day"? would it be complete runnable code? 
00:06:23 <breadmonster> mniip: Oh, where are you going to study?
00:06:29 <mauke[> you can skip learning ELF if you emit asm
00:06:37 <mauke[> and you can skip asm by targetting C
00:06:50 <breadmonster> I've heard Penn is *the* place to be for Haskell and related functional programming work.
00:07:08 <mniip> bartiosze, that's not the 'Maybe' definition
00:07:16 <mniip> that's the source for its Monad instance
00:07:16 <mauke[> bartiosze: that's not the definition of Maybe, that's the definition of the Monad instance of Maybe
00:07:30 <mauke[> bartiosze: http://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-Base.html#Maybe
00:07:30 <mniip> @src Maybe
00:07:30 <lambdabot> data Maybe a = Nothing | Just a
00:07:38 <kadoban> bartiosze: Just "Happy Birthday"   would be valid haskell code
00:07:38 <bartiosze> oh, is that harder than 'maybe' itself? 
00:08:01 <mauke[> a Monad instance provides definitions for '>>=' and 'return'
00:08:25 <mauke[> bartiosze: also, to answer your question: it would be Just "Happy Birthday"
00:08:30 <kadoban> Where the 'Just' is literally part of it, I don't mean that in the English sense.
00:08:36 <mauke[> (the constructors of Maybe are Nothing and Just)
00:08:47 <mniip> breadmonster, I'm afraid I'm not in the right country for that
00:08:49 <bartiosze> then I was too fast to put that definition on the card. 
00:09:19 <bartiosze> mauke[: is it possible to use that instance monad, add something and stil have somthing runnable? 
00:09:32 <mauke[> bartiosze: huh?
00:09:49 <mniip> bartiosze, is it a paper card?
00:09:57 <bartiosze> mniip: yes. 
00:09:59 <breadmonster> mniip: Your cloak...how did you get it?
00:10:06 <mniip> breadmonster, hehe
00:10:35 <bartiosze> mauke[: I mean, I like how this instance definition is lenghty. Looks 'smart' in a way. I thought I could add a line or two and then do Maybe "Happy Birthday" 
00:11:17 <mauke[> no, Maybe "Happy Birthday" is an error (Maybe is undefined) and that instance definition is pointless if you don't use >>= or return
00:11:31 <mauke[> (and return is simply Just here)
00:11:46 <mniip> bartiosze, maybe something along the lines of 'getName >>= return . ("Happy birthday, " ++)'
00:12:07 <mauke[> also, that slide looks incomplete
00:12:09 <mniip> albeit it doesn't make much sense for getName to be a Maybe monad in particular
00:12:09 <kadoban> bartiosze: You just want something on the card that looks like haskell and says happy birthday, basically?
00:12:18 <mauke[> Nothing >> _ = Nothing  -- is missing
00:12:20 <IronY> Hey guys, looking at Haskell for the first time
00:12:31 <IronY> I am trying to compile something, but it said i was missing deps
00:12:41 <IronY> so i installed them through cabal
00:12:46 <bartiosze> kadoban: yes, something along the lines with 'monad' also would be just great. 
00:12:49 <mniip> mauke[, yeah looking at the definition for >>= right now, it is malformed
00:12:52 <IronY> still said they are missing
00:13:00 <IronY> Ubuntu 15.05
00:13:17 <mauke[> IronY: what's the error message?
00:13:30 <IronY> Literally you are missing one of the three deps
00:13:38 <IronY> the deps i installed were time, irc, and Sempaphore
00:13:41 <mniip> breadmonster, I participated in freenode's april fools challenge in 2014
00:13:49 <kadoban> bartiosze: mniip's suggestion seems pretty good. That's using a different Monad, but it's a Monad. I can't think of an obvious way to use Maybe's Monad instance.
00:14:09 <mniip> bartiosze, by the way, that code you copied from is malformed
00:14:26 <mniip> get a new card :P
00:14:26 <mauke[> IronY: what?
00:14:33 <bartiosze> mniip: oh, that would be a task for the reader to find the error then... 
00:14:59 <bartiosze> mniip: i'll go with your 'getName' suggestion.
00:15:33 <bartiosze> does haskell interpreter have any recognizable prompt? google images gives me some fancy lambdas for 'ghci prompt'
00:15:56 <mniip> mine looks like modulename>
00:16:04 <mauke[> Prelude> 
00:16:05 <mniip> maybe try 'Prelude>'
00:16:14 <dfeuer> The default just shows what modules are loaded, yah.
00:16:35 <mauke[> bartiosze: http://i.stack.imgur.com/Tnjqh.png
00:16:41 <breadmonster> bartiosze: You can change yours by typing `:set prompt "ghci> "`
00:16:58 <breadmonster> mauke[: you're on Windows?
00:17:03 <mniip> another common prompt, I guess, is *Main>
00:17:22 <mauke[> breadmonster: no, I just googled that
00:17:43 <dfeuer> IronY, cabal, like all other source package thingums, is evil. A lot of people swear by Stackage to manage the insanity.
00:17:57 <IronY> appreciate dfeuer 
00:17:59 <breadmonster> mauke[: what do you run?
00:18:04 <IronY> i noticed it local user scoped
00:18:07 <IronY> sudo did nothing
00:18:12 <dfeuer> IronY, another thing: cabal sandboxes.
00:18:19 <mauke[> breadmonster: linux currently
00:18:23 <dfeuer> IronY, you do *not* want to run cabal as superuser.
00:18:35 * hackagebot graph-wrapper 0.2.5.1 - A wrapper around the standard Data.Graph with a less awkward interface  http://hackage.haskell.org/package/graph-wrapper-0.2.5.1 (SoenkeHahn)
00:18:37 <bartiosze> mniip, mauke[ thanks for you attention and hints. 
00:18:38 <IronY> the dev enviroment itself is a sandbox lol
00:18:47 <dfeuer> IronY, your best bet is usually to open up the project directory, run cabal sandbox init, and do everything in that sandbox.
00:18:54 <bartiosze> till next time. with some real monad question manybe:>
00:18:58 <IronY> THATS probably what i amissing
00:19:00 <IronY> much appreciate
00:19:08 <IronY> and holy hell 1462 people in here
00:19:16 <dfeuer> Well, if you want sandboxes. Which you do, but that doesn't mean it'll fix your probelm.
00:19:16 <IronY> this might be the most active dev room i have seen
00:19:21 <mniip> disadvantages: can't just type 'ghci modname'
00:19:24 <dfeuer> o.O
00:19:32 <mniip> IronY, see #archlinux and #python
00:19:36 <breadmonster> IronY: #python or ##c++-basic
00:19:43 <breadmonster> Or even the one without the basic.
00:19:50 <mauke[> IronY: most of them aren't active :-)
00:19:56 <breadmonster> This is the best dev room for sure though.
00:19:58 <IronY> c# 412
00:20:00 <IronY> lol
00:20:16 <felixn> bartiosze: hmmmmm, there has to be good pun in there somewhere :)  none of these nerds know how to make puns
00:20:48 <mniip> felixn, none of these pun-makers know how to be scientifically correct
00:21:01 <bartiosze> felixn: so what is your suggestion?
00:21:15 <IronY> So I need to learn at least one functional programming language to just plain understand the whole paradigm in general
00:21:21 <IronY> does haskell fall under said paradigm?.
00:21:24 <mauke[> yes
00:21:36 <felixn> bartiosze: I dunno, but now I'm thinking about it!
00:21:40 <mniip> haskell is a good example of a functional language
00:21:42 <mauke[> IronY: what languages do you know?
00:21:58 <IronY> mauke, c#, php, javascript, some java
00:22:30 <muzzle> What is the best map type to use in haskell for keys without an Ord instance ?
00:22:39 <mniip> [(k, v)]
00:22:43 <adarqui> irony, probably used some functional concepts in javascript too and didn't know it
00:22:43 <mauke[> muzzle: what are your keys?
00:22:51 <breadmonster> muzzle: you could construct one yourself.
00:23:05 <IronY> I have been trying to master my front end kung fu as of late. But everytime you learn javascript tooling to a point where you find yourself quick, all the tools change
00:23:21 <bartiosze> felixn: i'll stay here for a while, but the card is already ready. I'll save it for next year just in case
00:23:28 * mniip is glad he doesn't do webdev
00:23:37 <mauke[> IronY: if you're familiar with async/callback based javascript stuff, that might help with understanding Haskell's IO system
00:23:37 <IronY> Get good at grunt, enter gulp, get good at gulp, wait whats web kit
00:23:42 <muzzle> makue[ it's a type for currencies that i definied myself, but it doesn't really have a useful Ord instane
00:23:49 <adarqui> irony, i try not to get caught up in the tools changing crap.. it's just like 'computers changing', i don't need a new one every year.
00:23:50 <felixn> bartiosze: ah, haha yea, I'm going to bed anyway, I just popped in and saw that
00:24:03 <adarqui> you can get by just fine with existing js tools out there, imho
00:24:17 <adarqui> i've been having lots of fun with meteor.js lately :d
00:24:23 <mniip> muzzle, doesn't have to be useful
00:24:30 <mniip> probably can just be derived
00:24:36 <IronY> mauke, js's async stuff is promise based at the momment, but there trying to go to a c# away async modle with es7 if i understand correctly
00:24:52 <IronY> away = await
00:25:07 <mauke[> well, I'm talking about plain callbacks :-)
00:25:08 <adarqui> i like the node-fibers/futures package
00:25:54 <mauke[> as in setTimeout(function () { ... }, 5000);
00:25:55 <IronY> adarqui, generators?
00:26:31 <mauke[> you can't sleep() in JS and you can't perform IO in Haskell
00:26:57 <breadmonster> mauke[: what's a callback?
00:27:27 <mniip> IronY, the term "callback" itself basically means that you pass a function "to be called back" to some function
00:27:54 <mauke[> breadmonster: http://en.wikipedia.org/wiki/Callback_(computer_programming)
00:27:54 <IronY> callback, closure, anonymous function
00:28:02 <mniip> those are all unrelated terms
00:28:03 <mauke[> those all mean different things
00:28:07 <IronY> lol
00:28:14 <mauke[> not unrelated but orthogonal
00:28:22 <IronY> I am going to live this channel
00:28:24 <IronY> like
00:28:30 <mniip> yeah
00:28:36 <adarqui> easily the best channel on freenode
00:28:37 <mauke[> a closure is a function that uses local variables from a surrounding scope
00:28:45 <mauke[> an anonymous function is a function without a name
00:28:45 <mniip> a closure means it has references to locals from a higher scope
00:28:53 <mniip> an ano--- yeah
00:29:18 <mauke[> "anonymous function" really just means "function" but some languages don't have real functions, only labeled blocks (basically)
00:29:35 <mniip> C for example
00:29:35 <mauke[> so that's why people associate "function" with "a named block of code"
00:29:55 <IronY> so callback vs closure?
00:30:12 <mniip> :/
00:30:33 <mniip> IronY, setTimeout(function(){ do stuff }, 1000)
00:30:37 <mauke[> a callback is something you pass to another function (which is expected to call you back somehow)
00:30:43 <mniip> versus sleep(1000); do stuff
00:30:58 <mauke[> this callback could be a closure or not
00:32:08 <mauke[> function foo(x) { function bar() { alert(x); } setTimeout(bar, 1000); }  // bar is nonymous (has a name), is a closure, and is used as a callback in the call to setTimeout
00:32:29 <mauke[> foo("Hello, world!");
00:32:34 <IronY> *head explodes*
00:32:46 <mauke[> eh? this is like JS 101
00:32:55 <IronY> I have used them all
00:33:03 <IronY> the terminology how ever
00:33:05 <mniip> you just don't know the terminology
00:33:19 * mauke[ is a terminator
00:33:20 <mniip> welcome to the channel where everyone smacks everyone for term misuse
00:33:55 <adarqui> i'm going to be jobless soon, which will give me time to finally really study haskell
00:33:58 <adarqui> very excited
00:33:59 <adarqui> tehe
00:34:14 <IronY> Start work in 2 days after 3 months of being laid off
00:34:16 <breadmonster> adarqui: Jobless as in unemployed?
00:34:24 <IronY> I honestly think i do more work when I dont work
00:34:35 <IronY> i feel like if i am not learning 24/7 I am basically wasting my life
00:34:36 <adarqui> ya i was using the "term misuse" thing
00:35:41 <IronY> Also, on a non programming note. I am watching frailty for the first time. How did I miss this movie? Paxton and Maconghahey
00:36:13 <adarqui> IronY: prepare for that feeling to get worse if you become obsessed with haskell and your job "fights you"
00:36:56 <IronY> What are some notable real world haskell implementations in the wild right now?
00:37:12 <mauke[> ghc
00:37:31 <Haskellfant> xmonad is also fairly popular and also used among non haskellers
00:37:34 <Haskellfant> pandoc too
00:37:42 <IronY> not compilers, hrm. What was built with haskell
00:37:45 <IronY> thats noteworthy
00:37:54 <adarqui> isn't fpcomplete built on haskell, yesod + their new ide
00:38:17 <mauke[> darcs maybe?
00:38:36 <mniip> um
00:38:43 <mniip> ghc is mostly written in haskell
00:38:55 <adarqui> haskell needs a 'builtwith': http://builtwithember.io/ .. builtwithhaskell.io
00:39:09 <medfly> xmonad is the fucking best
00:39:31 <IronY> http://www.yesodweb.com/book/json-web-service
00:39:39 <IronY> thats fairly streamlined
00:39:39 <IronY> hrm
00:39:57 <IronY> its kinda assemblery lol
00:40:41 <IronY> https://wiki.haskell.org/wikiupload/a/aa/Screen-triplehead-galois.jpg
00:40:54 <IronY> sold
00:42:08 <IronY> Its description page is incredibly accurate. I actually do spend shit loads of time making my windows lign up all cool and tiled
00:46:13 <magneticDuck> IronY: there are lots of other tile-based window managers too
00:46:14 <EunChe> dat keyboard.. looks really sweet
00:49:04 <mniip> [10:38:45] <medfly> xmonad is the fucking best
00:49:11 <mniip> 1366x768 peasant here :(
00:52:30 <hunteriam> transposeHelper xs = map head xs : transposeHelper $ map tail xs
00:52:35 <hunteriam> why doesnt that typecheck?
00:53:03 <hunteriam> its meant to have type [[a]] -> [[a]]
00:53:16 <Haskellfant> map head xs doesn't typecheck
00:53:25 <Haskellfant> that's trying to map head over every element of xs
00:53:33 <Haskellfant> oh if you have [[a]] that could work
00:53:55 <hunteriam> its the second part that doesnt work for some reason
00:54:01 <mniip> you're trying to concatenate 'map head xs' with 'transposeHelper'
00:54:03 <Cale> hunteriam: because $ has very low precedence
00:54:04 <mniip> check your precedence
00:54:15 <hunteriam> OH
00:54:16 <hunteriam> lol
00:54:17 <mniip> s/concatenate/cons/
00:54:23 <hunteriam> i thought i was just bad at programming again
00:54:31 <hunteriam> i guess thats a form of bad programming though
00:54:42 <breadmonster> IronY:  You're at Galois?
00:55:37 <medfly> mniip: i use 1024x768 ;)
00:55:49 <breadmonster> How do represent recursion in the typed lambda calculus?
00:55:49 <mniip> medfly, how does one use tiling at that resolution
00:55:56 <breadmonster> The untyped version doesn't work.
00:56:51 <hunteriam> is there a library for drawing graphs?
00:57:03 <hunteriam> a really quick and easy to use one
00:58:20 <medfly> mniip: I am a fairly new user of xmonad, in any case - i don't use tiling that much, I like the fact I can easily control everything from the keyboard, at most 2 windows at once.
00:59:01 <hunteriam> i see quite a lot of plotting libraries
00:59:13 <hunteriam> im just not sure which one would be reccomended for basic usage
00:59:15 <merijn> breadmonster: You need a built-in primitive for that
00:59:24 <hunteriam> im not trying to create complex plots, just a plain old line graph
00:59:36 <mniip> hunteriam, if I were to make something really quickly, I'd just emit data in space-separated format and gnuplot it
00:59:45 <hunteriam> mniip: windows :'(
00:59:49 <merijn> breadmonster: You cannot define general recursion in the simply typed lambda calculus, because that requires Turing completeness and STLC is strongly terminating
00:59:49 <mniip> oh
00:59:52 <mniip> my condolences
01:00:00 <merijn> breadmonster: More complicated typed lambda calculi can do it
01:00:02 <medfly> hunteriam: gloss?
01:00:10 <medfly> hunteriam: oh, you want simpler
01:00:11 <hunteriam> @medfly 
01:00:13 <lambdabot> Unknown command, try @list
01:00:19 <hunteriam> medfly: gloss is just a rendering system, isnt it?
01:00:26 <medfly> hunteriam: I thought you wanted more complex :)
01:00:32 <hunteriam> no lol not at all
01:00:33 <Haskellfant> hunteriam: chart seems to be fairly popular, but I have not yet used it myself
01:00:57 <hunteriam> Haskellfant: i also see "plot", although its a few months older so perhaps chart is a better choice? hard to say
01:01:26 <hunteriam> does anyone here have any experience with any of these libraries?
01:02:17 <breadmonster> merijn: So what is Core then?
01:04:01 <merijn> breadmonster: Core is based on System F_Omega
01:04:15 <merijn> breadmonster: Which is considerably more powerful/expressive than the simply typed lambda calculus
01:04:26 <merijn> For example, STLC doesn't have polymorphism either
01:04:36 <merijn> breadmonster: For a good book explaining all this stuff, see
01:04:38 <merijn> @where tapl
01:04:38 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
01:04:48 <mniip> I've got a bit of a data processing problem here, http://i.imgur.com/wSLjWQV.png I have a somewhat deviate-y data (red line) which has a general trend (green line), I want to know the value of the trend in the last point. If I average a few last values, I may go too far away from the trend
01:04:49 <mniip> ideas?
01:05:20 <marrrk> Why are the arguments to foldl and foldr reversed?
01:05:32 <merijn> :t foldr
01:05:35 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
01:05:40 <merijn> :t foldl
01:05:41 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
01:05:51 <merijn> marrrk: You mean of the function?
01:05:54 <marrrk> Yes
01:06:01 <merijn> > foldr f z [a,b,c]
01:06:02 <breadmonster> merijn: That is a very, very expensive book.
01:06:04 <lambdabot>  f a (f b (f c z))
01:06:08 <breadmonster> It has no Indian edition.
01:06:09 <merijn> > foldl f z [a,b,c]
01:06:12 <lambdabot>  f (f (f z a) b) c
01:06:13 <breadmonster> And it's like $200
01:06:22 <breadmonster> So yeah, kinda pricey
01:06:23 <merijn> marrrk: Compare those two versions
01:07:08 <merijn> breadmonster: Wait, what?! I got my copy for like $50, not cheap, but certainly not $200...if you have a university nearby the CS department should almost certainly have it in it's library.
01:07:35 <breadmonster> merijn: Nope, not a place I can look it up.
01:07:39 <breadmonster> That's a real shame I Know.
01:07:46 <MP2E> I see it for 85$ on the mit press link provided from the link merijn provided
01:08:03 <breadmonster> I don't want to pirate Pierce's book, I'd like to coauthor with him one day :P
01:08:39 <marrrk> merijn: I don't get it. Is it about partial application?
01:09:14 <merijn> marrrk: No, it's about the order arguments are applied. If you take the results of those two folds and write down the types of every letter in there it should become clear
01:09:46 <marrrk> ah I think I see it now.
01:12:58 <merijn> marrrk: For things like this I always recommend grabbing a paper and pencil and mindlessly substituting by hand while annotating types until you see the pattern and it goes "click"
01:13:24 <marrrk> ok
01:13:55 <MP2E> that certainly helped me understand fix
01:14:03 <MP2E> i didn't get it at all until I played with the definition on paper
01:14:28 <marrrk> Oh and what's the difference between Integer and Int?
01:14:45 <merijn> marrrk: I mean, I think it's all obvious and easy NOW, but I remember the first time I saw fold I had to stare at it for like two weeks to make sense
01:14:51 <mauke[> > maxBound :: Int
01:14:54 <lambdabot>  9223372036854775807
01:15:02 <merijn> marrrk: Int is a machine word sized Int, Integer is an unbounded GMP integer
01:15:22 <mauke[> Int is limited, Integer is unlimited
01:15:51 <breadmonster> merijn: Int is 64 bits right?
01:16:02 <MP2E> on 64 bit oses
01:16:02 <merijn> breadmonster: Depends on your GHC version and OS
01:16:04 <MarcelineVQ> on a 64 bit machine
01:17:00 <marrrk> is there also a type for natural numbers?
01:17:09 <jessicah`> if I specify an alternate config file for cabal, will the settings I not specify default to my system config file?
01:17:38 <mauke[> the haskell report only guarantees 30 bits for Int
01:17:42 <merijn> marrrk: No, I think people have discussed it, but there isn't at the moment (at least no unbounded, for bounded you have Word, which is the unsigned version of Int)
01:17:52 <merijn> mauke[: I thought it was only 28
01:17:57 <marrrk> I see
01:18:19 <mauke[> marrrk: http://hackage.haskell.org/package/base-4.8.0.0/docs/Numeric-Natural.html#t:Natural
01:18:20 <merijn> Ah, no, you're right it guarantees 30
01:22:39 <nak> > let x = 1, y = 2 in [x,y]
01:22:41 <lambdabot>  <hint>:1:10: parse error on input ‘,’
01:22:47 <nak> what is wrong with that ^
01:22:52 <nak> how do you define two vars in let ?
01:23:06 <mauke[> ;
01:23:09 <nak> oh
01:23:18 <nak> > let x = 1; y = 2 in [x,y]
01:23:19 <liste> nak you need {} and ;
01:23:21 <lambdabot>  [1,2]
01:23:25 <mauke[> you don't need {}
01:23:37 <liste> cool (:
01:23:39 <liste> didn't know that
01:23:43 <mauke[> > let x@y = 2 in [x,y]
01:23:46 <lambdabot>  [2,2]
01:24:07 <liste> > let foo :: Int; foo = 1 in foo
01:24:11 <lambdabot>  1
01:24:12 <mauke[> 'let' triggers layout if the next token isn't '{'
01:24:21 <mauke[> usual rules, etc
01:25:04 <nak> > let xs = [1,2,3]; f = (*2) in [y | x <- xs, y <- f x]
01:25:06 <lambdabot>      No instance for (Show t0)
01:25:06 <lambdabot>        arising from a use of ‘show_M70582133243710508232240’
01:25:06 <lambdabot>      The type variable ‘t0’ is ambiguous
01:25:19 <nak> hmm 
01:25:24 <liste> you need to specify the type
01:25:30 <mauke[> no
01:25:50 <mauke[> > let xs = [1,2,3]; f = (*2) in [f x | x <- xs]
01:25:53 <lambdabot>  [2,4,6]
01:26:02 <mauke[> > let xs = [1,2,3]; f = (*2) in [y | x <- xs, let y = f x]
01:26:04 <lambdabot>  [2,4,6]
01:26:18 <mauke[> you can't <- ("draw from") f x as it's not a list
01:26:37 <Hafydd> > let xs = [1,2,3]; f = (*2) in [y | x <- xs, y <- [f x]]
01:26:40 <lambdabot>  [2,4,6]
01:26:47 <nak> mauke[, Monad [] defined >>= as
01:26:57 <nak> xs >>= f = [y | x <- xs, y <- f x]
01:27:06 <mauke[> yeah, but that f returns a list
01:27:11 <mauke[> your f doesn't
01:27:39 <mauke[> > let xs = [1,2,3]; f x = [x-1, x*2] in [y | x <- xs, y <- f x]
01:27:42 <lambdabot>  [0,2,1,4,2,6]
01:28:06 <mauke[> also known as concatMap
01:28:18 <nak> oh interesting
01:28:19 <nak> ok
01:28:26 <mauke[> > concatMap (\x -> [x-1, x*2]) [1,2,3]
01:28:28 <nak> i've only learned Maybe monad and Either Monad
01:28:29 <lambdabot>  [0,2,1,4,2,6]
01:28:48 <mauke[> Maybe and [] are basically the same
01:28:50 <breadmonster> mauke[: Isn't there a problem with ListT?
01:28:58 <mauke[> because Maybe is essentially a list with at most one element
01:29:26 <breadmonster> They're not isomorphic.
01:29:29 <nak> i'm trying to dissect the List Monad now and the [ y | x <- xs, y <- f x] was throwing me for a loop
01:29:39 <mauke[> that's because it is a loop.
01:29:49 <nak> ... lol
01:29:57 <mauke[> breadmonster: they totally are
01:30:49 <nak> mauke[ so (<-) always needs a list on the right-hand side ?
01:30:55 <breadmonster> mauke[: what's the image of [1,2] in the Maybe type?
01:31:08 <mauke[> nak: yes, or at least some kind of monadic value (in a do-block)
01:31:18 <liste> breadmonster that one has >1 element
01:31:32 <mauke[> breadmonster: "with at most one element"
01:31:37 <nak> is a list considered a monadic value ?
01:31:40 <breadmonster> liste: Yeah, what I meant was all lists vs all Maybes.
01:31:43 <breadmonster> nak: yes.
01:31:45 <nak> ok
01:31:48 <mauke[> nak: yes, because [] is an instance of Monad
01:31:58 * nak nods
01:32:02 <breadmonster> mauke[: sorry, didn't get hta.
01:32:05 <mauke[> by "monadic value" I mean some x :: M T where M is a Monad
01:32:25 <nak> is the (<-) in do notation anything special compared to the (<-) in list comprehension notation?
01:32:31 <nak> or are they effectively doing the same thing
01:32:46 <mauke[> effectively the same thing but list comprehensions are limited to lists
01:32:58 <nak> ah that makes sense
01:33:04 <merijn> Effectively the same, but not actually the same
01:33:06 <mauke[> > do x <- [1,2,3]; y <- "ab"; return (x,y)
01:33:10 <lambdabot>  [(1,'a'),(1,'b'),(2,'a'),(2,'b'),(3,'a'),(3,'b')]
01:33:25 <mauke[> > [(x,y) | x <- [1,2,3], y <- "ab"]
01:33:26 <merijn> i.e. the actual exact rules for desugaring list comprehensions produce the same result as the list monads, but don't use the same functions
01:33:29 <lambdabot>  [(1,'a'),(1,'b'),(2,'a'),(2,'b'),(3,'a'),(3,'b')]
01:33:51 <mauke[> pre-standard versions of haskell had monad comprehensions
01:34:55 <nak> > do x <- [1,2,3]; y <- "ab"; [(x,y)]
01:34:58 <lambdabot>  [(1,'a'),(1,'b'),(2,'a'),(2,'b'),(3,'a'),(3,'b')]
01:35:01 <nak> ok awesome
01:35:25 <nak> return x = [x]
01:38:26 <breadmonster> mauke[: why did they remove monad comprehensions?
01:38:41 <nak> ok Monad [] also defined (>>) as (*>)
01:38:48 <mauke[> breadmonster: no idea
01:38:53 <nak> what is (*>) and (>>)
01:38:57 <nak> how do i say those with words ?
01:39:02 <mauke[> you don't
01:39:05 <nak> :{
01:39:13 <mauke[> *> is from Applicative
01:39:18 <nak> yeah
01:39:23 <nak> xs *> ys  = [y | _ <- xs, y <- ys]
01:39:31 <mauke[> but the basic idea is that a >> b = a >>= \_ -> b
01:39:42 <breadmonster> nak: x (>>) f = x >>= \_ -> f
01:39:53 <mauke[> breadmonster: >>, not (>>) :-)
01:39:59 <mauke[> otherwise that would be defining x
01:40:06 <breadmonster> oh yeah my bad
01:41:00 <mauke[> > [1,2,3] >> "ab"
01:41:03 <lambdabot>  "ababab"
01:41:33 <mauke[> this gets the "effect" of [1,2,3] (repetition) but throws the values away
01:41:52 <nak> > "abc" >> "zz"
01:41:55 <lambdabot>  "zzzzzz"
01:41:57 <nak> ok
01:42:03 <nak> > "zz" << "abc"
01:42:06 <lambdabot>      Not in scope: ‘<<’
01:42:06 <lambdabot>      Perhaps you meant one of these:
01:42:06 <lambdabot>        data constructor ‘Seq.:<’ (imported from Data.Sequence),
01:42:09 <nak> > "zz" <* "abc"
01:42:12 <lambdabot>  "zzzzzz"
01:42:14 <nak> got it
01:42:24 <nak> so this tho
01:42:25 <nak> xs *> ys  = [y | _ <- xs, y <- ys]
01:42:29 <nak> this doesn't actually use >>=
01:42:47 <mauke[> yeah, but it's equivalent
01:42:55 <lamefun> Are compiler extensions bad to use?
01:43:07 <liste> lamefun do you mean language extensions?
01:43:07 <mauke[> lamefun: generally, no
01:43:26 <mauke[> nak: xs >>= f = [y | x <- xs, y <- f x]
01:43:40 <liste> lamefun they make Haskell a LOT more expressive
01:43:44 <lamefun> liste, yes... base Haskell seems very poor...
01:43:54 <nak> > [1,2,3] >>= \_ -> "zz"
01:43:58 <lambdabot>  "zzzzzz"
01:43:59 <mauke[> nak: so xs >>= (\_ -> ys) = [y | x <- xs, y <- (\_ -> ys) x]
01:44:03 <lamefun> (I mean { LANGUAGE } comments).
01:44:13 <mauke[> nak: (\_ -> ys) x = ys
01:44:19 <liste> some extensions ended up in Haskell2010 standard
01:44:28 <mauke[> nak: and then x is unused so we can replace by _
01:44:34 <nak> mauke[ that's like (const ys) right 
01:44:40 <mauke[> nak: yes
01:44:43 <mauke[> @src const
01:44:43 <lambdabot> const x _ = x
01:44:53 <mauke[> or: const x = \_ -> x
01:44:56 <breadmonster> liste: I think we should move LambdaCase to the langauge.
01:45:01 <nak> yeah that makes sense
01:45:02 <breadmonster> *language
01:45:09 <nak> :t const
01:45:11 <lambdabot> a -> b -> a
01:45:18 <nak> ok cool
01:45:28 <breadmonster> It's simple syntactic sugar that costs nothing, but it saves a great PITA, and makes lambdas more expressive to n00bs
01:45:34 <mauke[> nak: do you know the flip function?
01:45:45 <nak> mauke[ yeah
01:45:49 <nak> i haven't really used it yet tho
01:45:58 <mauke[> wanna break your brain?
01:46:03 <nak> sure 
01:46:16 <mauke[> what does 'flip id' do and what is its type?
01:47:03 <nak> id is a -> a
01:47:14 <nak> (flip id) would be ..
01:47:19 <MP2E> mauke[: wow :o
01:47:27 <MP2E> that is very interesting
01:47:33 <mniip> a -> (a -> b) -> b
01:47:36 <mniip> because magic!
01:47:42 <mauke[> no spoilers
01:47:46 <MP2E> hehe
01:47:57 <nak> mauke[ i've actually implemented that in some of the js stuff i do
01:48:11 <breadmonster> Wait what?
01:48:12 <nak> but i didn't have to necessarily think about the type signature
01:48:25 <mniip> flip :: (a -> b -> c) -> b -> a -> c
01:48:28 <breadmonster> mauke[: There's some voodoo here...
01:48:32 <mniip> id :: a' -> a'
01:48:44 <mniip> in flip id, we unify (a -> b -> c) with (a' -> a')
01:49:04 <breadmonster> How on earth is that possible...?
01:49:05 <mniip> arrow is right associative, so a ~ a', and (b -> c) ~ a'
01:49:12 <breadmonster> Oh right interesting.
01:49:15 <mauke[> breadmonster: currying
01:49:18 <nak> mauke[ i implemented compose as: let compose = flip(foldr(flip(id)));
01:49:19 <breadmonster> so this should work...
01:49:26 <breadmonster> :t flip (+1)
01:49:28 <lambdabot> Num (b -> c) => b -> (b -> c) -> c
01:49:30 <tejing> breadmonster: f `id` x == f $ x
01:49:32 <nak> so compose([f,g])(x) === f(g(x))
01:49:50 <tejing> breadmonster: once that makes sense the flip part also makes sense
01:49:53 <mniip> the result, b -> a -> c, is b -> (b -> c) -> c
01:50:02 <mniip> because a ~ a' ~ (b -> c)
01:51:03 <nak> mauke[ here's a gist i had from a month ago https://gist.github.com/naomik/a6658c8c26425d154b6f#file-improvements-js-L21-L23
01:51:03 <tejing> by random trial the other day I noticed that flip flip flip flip and flip flip flip flip flip have the same type... I haven't the foggiest idea why
01:51:21 <nak> mauke[ ^.^
01:51:35 <mauke[> nice
01:51:48 <Darwin226> I have a bunch of functions, some are (a -> m b), some are just (a -> b). What's the easiest way to chain them all together? The fixities <$> and =<< don't really play nice together.
01:51:50 <mniip> tejing, 'flip flip1 flip2 flip3' by the definition of flip is 'flip1 flip3 flip2'
01:52:09 <mniip> Darwin226, (.) and >=>
01:52:19 <mniip> er
01:52:22 <tejing> Darwin226: >=> might help you there
01:52:22 <mniip> <$> and >=>
01:52:51 <breadmonster> @info <$>
01:52:52 <lambdabot> <unknown>.hs: 1: 1:Parse error: <$>
01:52:53 <nak> mauke[ does (flip id) work if the second argument isn't a function ?
01:53:03 <breadmonster> @info (<$>)
01:53:03 <lambdabot> (<$>)
01:53:12 <liste> what does @info even do :D
01:53:13 <breadmonster> yeah lambdabot no shit ;P
01:53:25 <breadmonster> lolol
01:53:26 <hunteriam> uh
01:53:34 <nak> > (flip id) 2 (*5)
01:53:35 <Darwin226> mniip: The fact that one goes one way and the other goes the other way is already a major pain. But <$> is not really the same as <=< because one applies the function, the other composes them
01:53:35 <liste> @info "I'm useless"
01:53:36 <tejing> mniip: thanks, that's helpful
01:53:37 <hunteriam> nevermind
01:53:38 <lambdabot>  10
01:53:38 <lambdabot> "I'm useless"
01:53:56 <Darwin226> mniip: it would be <$> and =<<, but again, fixities make it hard
01:54:13 <breadmonster> Darwin226: `return . f =<< g` and so on
01:54:32 <mniip> Darwin226, alternatively, you can use the do notation
01:54:34 <mauke[> nak: no, because flip id x y = id y x = y x, so y has to be a function
01:54:34 <breadmonster> Should allow you to just use (>>=)
01:54:40 <mniip> <- for monadic binds, and let for pure binds
01:54:42 <Darwin226> breadmonster: Yeah. That'll work.
01:54:53 <mauke[> liste: @info autocorrects to @undo
01:55:00 <Darwin226> mniip: With the downside of having to name everything
01:55:01 <mauke[> (edit distance == 2)
01:55:03 <breadmonster> Darwin226: Sorry man, there's not getting around the ugliness sometimes.
01:55:32 <breadmonster> God bless whoever invented do.
01:55:38 <breadmonster> :info (<$>)
01:55:45 <breadmonster> ...please tell me it reads this -.-
01:55:49 <Darwin226> breadmonster: I've often wondered how bad it would be to have something like idiom brackets that automatically figured out how to connect stuff
01:55:55 <mauke[> lambdabot doesn't have and has never had an :info command
01:55:55 <breadmonster> @src (<$>)
01:55:56 <lambdabot> f <$> a = fmap f a
01:56:13 <nak> huh ?
01:56:17 <liste> :t (^>>)
01:56:18 <nak> that's all <$> does ?
01:56:18 <breadmonster> Darwin226: what are idiom brackets?
01:56:19 <lambdabot> Arrow a => (b -> c) -> a c d -> a b d
01:56:22 <tejing> Darwin226: you may want to partially apply (=<<) or fmap depending on function types, then compose them all with (.)
01:56:24 <liste> :t (>>^)
01:56:26 <lambdabot> Arrow a => a b c -> (c -> d) -> a b d
01:56:26 <breadmonster> nak: Yeah :P
01:56:34 <liste> Darwin226 would they be of help?
01:56:36 <mniip> breadmonster, horrible thing non-haskell-speaking mathematicians invented
01:56:46 <breadmonster> mniip: Link?
01:56:48 <Darwin226> https://wiki.haskell.org/Idiom_brackets
01:56:50 <nak> breadmonster that seems cryptic without purpose ...
01:57:00 <mniip> breadmonster, https://wiki.haskell.org/Idiom_brackets
01:57:05 <nak> what's wrong wiith just (fmap f a) or (f `fmap` a)
01:57:07 <breadmonster> nak: fmap is a little annoying to write.
01:57:12 <nak> ... lol
01:57:17 <breadmonster> In the middle of a long function.
01:57:18 <Darwin226> liste: I don't know. I imagine they would just do the right thing with respect to lifting and joining
01:57:23 <nak> more annoying than holding <$> ??
01:57:29 <nak> holding shift for three chars
01:57:36 <liste> is conor a non-haskell-speaking mathematician? :(
01:57:39 <breadmonster> <$> is easy enough to recall and saves a ton of brackets at times.
01:57:44 <mauke[> nak: consider foo <$> bar <*> baz <*> qux
01:57:47 <breadmonster> I used to use liftM for everything.
01:57:52 <nak> what is <*> ?
01:58:01 <breadmonster> nak: Applicative apply.
01:58:01 <nak> @src <*>
01:58:02 <lambdabot> Source not found. stty: unknown mode: doofus
01:58:03 <mauke[> :t (<*>)
01:58:05 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
01:58:18 <liste> <*> is the same as `ap' in Monad
01:58:22 <mauke[> it's like >>= but less powerful
01:58:23 <liste> (or for Monad)
01:58:29 <nak> i haven't gotten to applicative yet
01:58:41 <mauke[> Applicative is halfway between Functor and Monad
01:58:41 <breadmonster> liste: Well, now (<*>) is the same thing as ap :P
01:58:50 <mniip> mauke, for some value of hald
01:58:51 <breadmonster> After AMP that is.
01:58:52 <mniip> half
01:59:04 <mauke[> you can do less things with Applicative but that means more things can be instances
01:59:11 <mniip> breadmonster, um
01:59:17 <mniip> not everything that is applicative can be a monad
01:59:24 <nak> ok i have to get some rest now
01:59:33 <apsod> Is there a notion of "linear" applicatives? i.e. applicatives where f <$> (p x1) <*> (p x2) ... == p (f <$> x1 <*> x2 ...) where p :: (forall a. f a -> g a)?
01:59:49 <nak> mauke[ thank you for helping me understand the List Monad
01:59:58 <breadmonster> mniip: Sure, but doesn't `ap` resolve to `<*>` in Control.Monad?
02:00:35 <mniip> no
02:00:43 <breadmonster> Interesting.
02:00:55 <breadmonster> But return is the same thing as pure, right?
02:00:56 <mniip> ap f x = do f' <- f; x' <- x; return (f' x')
02:00:57 <liste> it does in GHC 7.10/new base
02:01:06 <liste> @src ap
02:01:06 <lambdabot> ap = liftM2 id
02:01:06 <breadmonster> liste: Yeah that's what I was talking about.
02:01:19 <mniip> ap cannot reduce to <*>
02:01:25 <breadmonster> :t ap
02:01:26 <mniip> because a ton of instances define <*> = ap
02:01:27 <lambdabot> Monad m => m (a -> b) -> m a -> m b
02:01:39 <breadmonster> :t (<*>)
02:01:40 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
02:01:41 <mniip> and define a Monad instance instead
02:01:48 <breadmonster> mniip: Not in 7.10
02:01:57 <breadmonster> All monads have to be Applicative first.
02:02:06 <mauke[> breadmonster: "first"
02:02:13 <merijn> breadmonster: There is not ordering of instances
02:02:15 <mniip> http://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-Base.html#ap
02:02:18 <mniip> see comment below
02:02:20 <merijn> s/not/no
02:02:22 <mauke[> strong word in a language without time
02:02:25 <breadmonster> Oh cool, thanks.
02:02:31 <breadmonster> mauke[: lol
02:03:11 <mniip> breadmonster, see link above and comment below
02:03:24 <mauke[> you can literally write: instance Applicative M where { pure = return; (<*>) = ap } for any Monad instance M
02:03:48 <breadmonster> mauke[: that's interesting.
02:03:53 <mauke[> and I expect many people have done this now that an Applicative instance is required
02:04:14 <mniip> so could you write 'instance Functor M where fmap f x = x >>= return . f'
02:04:30 <mauke[> ... fmap = liftM
02:04:33 <mniip> yeah
02:04:34 <mniip> that
02:04:43 <mniip> or fmap = liftA
02:07:08 <hunteriam> is it possible to install cairo in a sandbox?
02:07:20 <hunteriam> it asked me to install gtk2hs-buildtools and make sure its in a path
02:07:24 <hunteriam> i mean in my PATH
02:07:42 <hunteriam> ... so if im installing libs in a sandbox, the executables probably wont be in my path, right?
02:07:56 <hunteriam> so i probably cant install cairo, right?
02:08:02 <hunteriam> unless theres a way around that?
02:08:59 <liste> hunteriam you can install executables in sandboxes too
02:09:10 <liste> and add them to your path
02:09:11 <breadmonster> Does anyone here use Conduit?
02:09:39 <hunteriam> liste: is it possible to 'install' just the executable into my main cabal bin, through cabal?
02:09:44 <hunteriam> or should i just copy the executable manually
02:10:12 <mauke[> I'd just copy it
02:11:13 <hunteriam> kk
02:11:32 <hunteriam> in other news, gtk2hs-buildtools has been configuring hashtables for about 10 minutes now
02:11:39 <hunteriam> starting to get concerned
02:14:17 <ronh-> mniip actually id is (a -> b) -> a -> b in flip id
02:14:31 <mniip> which is what I said
02:14:39 <mniip> well
02:14:41 <ronh-> you said a' -> a'
02:14:49 <mniip> id :: a' -> a'
02:15:00 <mniip> and id in flip id is no different
02:15:07 <ronh-> a' is (a -> b), but it is harder to figure it out if you don't expand it
02:15:07 <liste> I'd get rid of all sharp objects before trying to install gtk2hs
02:15:16 <mniip> it is just that a' is a type variable, and we can say a' ~ (a -> b)
02:15:29 <mniip> but that doesn't change the type signature of id
02:15:31 <hunteriam> wow what the everloving f*
02:15:38 <mauke[> <mniip> in flip id, we unify (a -> b -> c) with (a' -> a')  <mniip> arrow is right associative, so a ~ a', and (b -> c) ~ a'  <mniip> because a ~ a' ~ (b -> c)
02:15:50 <mniip> ^
02:15:50 <hunteriam> so hashtables was configuring for 10 minutes because it was waiting for me to press ctrl-c before it would build
02:16:08 <hunteriam> why on earth would it do that
02:16:23 <liste> hunteriam are you on Windows?
02:17:01 <mniip> ronh-, my way is more algorithmic
02:17:13 <mniip> you unify, or as GHC calls it, zonk typevariables
02:17:58 <hunteriam> liste: yea
02:18:36 <liste> sometimes console programs have an extra "wait" in the end on Windows
02:18:52 <liste> because people run them from outside cmd.exe
02:19:57 <ronh-> mniip, you said that a' is both a and (b -> c)
02:20:00 <ronh-> how does that work
02:20:11 <mniip> it just does?
02:20:29 <mniip> I don't see a problem
02:20:58 <tejing> ronh-: it's just like solving systems of equations in algebra by eliminating variables
02:23:41 <mniip> ronh-, another example of on-paper type inferencing: http://lpaste.net/134094
02:24:05 <voodoo08> does haskell has a support for inheritance or subtyping
02:24:10 <voodoo08> have
02:24:12 <liste> voodoo08 no
02:24:25 <breadmonster> voodoo: Yes, in a way.
02:24:28 <liste> you can 'fake' subtypes in some situations
02:24:33 <mniip> yes it does
02:24:35 <voodoo08> how?
02:24:35 <breadmonster> You can inherit or cascade typeclasses
02:24:52 <voodoo08> I will have records that share common variables
02:24:57 <mniip> subtyping is a very well defined concept in haskell
02:24:57 <breadmonster> So that's akin to inheriting more than one interface in Java.
02:25:05 <breadmonster> mniip: What's subtyping?
02:25:14 <breadmonster> I don't know this OOP vocab
02:25:29 <mniip> OOP? that's type theory
02:25:52 <breadmonster> Sorry, I keep hearing all the C++ guys throwing it around.
02:25:56 <mauke[> mniip: where's the subtyping?
02:25:59 <liste> mniip how can I subtype in Haskell?
02:26:17 <MP2E> walking through 'flip id' was very illuminating, thanks :P
02:26:23 <mniip> mauke[, um, the type of $ is a subtype of id's type
02:26:23 <dEPy> Anyone ever used TypeScript? I wonder how types there compare to something like Haskell. We're considering switching from JavaScript to it and I'm not sure it it bring any benefits or will the type system just be an annoyance that we'll have to deal with.
02:26:28 <MP2E> also noted that the type of 'flip id' looks quite similar to (>>=)!
02:26:32 <MP2E> I don't think that is a coincidence :D
02:26:38 <mniip> as such, you can use 'id' everywhere where you can use $
02:26:41 <mauke[> mniip: that doesn't sound right
02:27:09 <liste> I'd call that just polymorphism
02:27:17 <tejing> mniip: yea that's just polymorphism
02:27:20 <hunteriam> has anyone tried installing the cairo package recently?
02:27:25 <hunteriam> im fairly certain its broken
02:27:25 <breadmonster> :t i
02:27:27 <lambdabot> Expr
02:27:29 <breadmonster> :t id
02:27:31 <lambdabot> a -> a
02:27:34 <breadmonster> :t ($)
02:27:35 <mniip> MP2E, that's because, um, =<< is a monadified #
02:27:36 <lambdabot> (a -> b) -> a -> b
02:27:36 <mniip> MP2E, that's because, um, =<< is a monadified $
02:27:44 <liste> dEPy I think it's worth it in large projects
02:27:45 <breadmonster> :t ($) id
02:27:46 <lambdabot> a -> a
02:27:51 <liste> and the typing is completely optional
02:27:54 <hunteriam> breadmonster: not to be rude, but could you use a local ghci for this unless its relevant to chat?
02:28:09 <mniip> hunteriam, it is relevant
02:28:10 <liste> breadmonster or /q lambdabot
02:28:18 <hunteriam> ah ok, wasnt sure
02:28:22 <breadmonster> hunteriam: Sorry, just trying to figure out how id and ($)  are subtypes
02:28:33 <hunteriam> breadmonster: np, didnt realize it was part of the chat
02:28:43 <breadmonster> mniip: got it now.
02:28:45 <tejing> breadmonster: 'more specific type' might be a better description
02:28:49 <breadmonster> It's still dodgy.
02:29:08 <voodoo08> say I have several data records that all share the same field names. how do I express that in haskell without repeating the names in each record?
02:29:39 <breadmonster> voodoo08: Example please?
02:29:41 <hunteriam> voodoo08: this is an age old haskell problem, which there are solutionsfor, but i dont know them
02:29:49 <hunteriam> someone here will
02:29:51 <magneticDuck> data record notation
02:29:55 <hunteriam> i just wanted to tell you it was an age old problem
02:30:00 <liste> voodoo08 if you use lens, you can generate HasFoo and HasBar classes for your record
02:30:11 <magneticDuck> recordWithOptions { changeThisOption = toThisValue }
02:30:18 <mauke[> voodoo08: you can define an extra type for them
02:30:24 <liste> with makeClassy
02:30:38 <mauke[> basically, factor out the common fields
02:30:40 <hunteriam> so.. has/can anyone tried/try installing cairo?
02:30:44 <hunteriam> it seems broken to me
02:30:50 <hunteriam> but its possible thats a windows eco only thing
02:31:05 <voodoo08> breadmonster: lets say that I have different records that describe different type of employes. but they all share some common fields (name, age, etc)
02:31:16 <mniip> sounds like a sum type
02:31:18 <dEPy> liste: but is is worht it for a team who never did a lot of programming using typed languages?
02:31:41 <breadmonster> voodoo08: Umm, I can think of an ugly hack involving typeclasses
02:31:43 <mniip> voodoo08, you could make a typeclass
02:31:45 <hunteriam> dEPy: probably depends on the problem theyre solving
02:32:04 <ronh-> mniip with sum type all the non-common fields will be partial functions
02:32:05 <dEPy> hunteriam: Mostly nothing that complicated, just UI code.
02:32:08 <hunteriam> dEPy: some software can benefit enormously from the type systems in haskell
02:32:10 <liste> voodoo08 and there's a new extension (OverloadedRecordFields) on its way, but not there yet
02:32:15 <mniip> class IsEmployee a where name :: a -> String; age :: a -> Int
02:32:16 <breadmonster> voodoo08: class HasName where name :: a -> String
02:32:22 <breadmonster> Or something like that.
02:32:26 <liste> dEPy depends on the team (: are they willing to learn new concepts?
02:32:30 <hunteriam> dEPy: hard to say, ive never tried doing UI in haskell myself, but i have heard other people omplain about it
02:32:34 <mniip> basically what breadmonster said but with a single typeclass instead of multiple
02:32:37 <mauke[> y'all are solving a completely different problem than what I'm thinking of
02:32:47 <voodoo08> let me parse all that
02:33:08 <breadmonster> mniip: This makes error messages a little more obtuse though.
02:33:10 <hunteriam> dEPy: i would hold out for someone who can tell you with some knowledge whether haskell is a good fit for that problen
02:33:13 <hunteriam> problem*
02:33:18 <dEPy> liste: not sure. Cause I mentioned Clojure and nobody wanted to learn it that much. And I think learning how to use strongly/statically typed language is also not that easy if you wanna use it well.
02:33:27 <Soft> Hmm, is there anything in Parsec that behaves like manyTill a b but that doesn't consume b in the end?
02:33:29 <breadmonster> voodoo08: Okay, so let's suppose you have two records: Employee and Manager
02:33:29 <liste> clojure isn't statically typed
02:33:39 <liste> oh, I see, you mean the willingness
02:33:39 <magneticDuck> voodoo08: are you sure you don't just want something like (map ($ DataRecord {a = 1, b = 2, ...}) [(\x -> x {option = differentValue}), (\x -> x {option = anotherDifferentValue})] ?
02:33:41 <breadmonster> And they both have record fields name, age, salary
02:33:41 <hunteriam> dEPy: oh its not that hard, are you guys a production team or a college/ highschool team?
02:33:42 <dEPy> liste: Yes, I was referring to the learning aspect. :)
02:33:54 <breadmonster> voodoo08: Okay?
02:33:55 <dEPy> hunteriam: production.
02:34:19 <mauke[> breadmonster: that doesn't sound ok to me
02:34:34 <breadmonster> Soft: manyTill a (lookahead b)
02:34:46 <liste> voodoo08 there's also nikita's record package
02:34:48 <liste> @hackage record
02:34:49 <lambdabot> http://hackage.haskell.org/package/record
02:34:55 <hunteriam> dEPy: to be honest, you could probably get away with learning it for this project, from what i heard, but at some point down the line youll probably want to return to some of your starting code. obviously learning a new language is going to add overhead to production time
02:35:04 <mauke[> wtf, people. what problem are you trying to solve here?
02:35:14 <breadmonster> Soft: Though that still might have some issues with backtracking.
02:35:24 <mauke[> where people = breadmonster, liste
02:35:24 <liste> dEPy also you could check out Facebook's flow type checker for JS
02:35:27 <hunteriam> dEPy: thankfully, refactoring is somethings haskell is pretty good at, so hopefully it wont be a big deal. although dont take my words as fact, cause im inexperienced with production
02:35:37 <breadmonster> mauke[: record fields with the same name. liste is talking to someone else :P
02:35:45 <breadmonster> I don't know any JS.
02:35:47 <voidzero> ve ar creating a frankenstein monster replica!
02:36:08 <voodoo08> so I have to make a typeclass for each common field?
02:36:09 <voidzero> oh wrong people
02:36:15 <voidzero> never mind, type on.
02:36:16 <mauke[> breadmonster: but the question was, "how do I express that in haskell without repeating the names in each record?"
02:36:17 <breadmonster> voidzero: let frankensteinMonster = fix frankensteinMonster
02:36:17 <voodoo08> typeclass per field
02:36:30 <breadmonster> voodoo08: Not necessarily.
02:36:44 <Soft> breadmonster: thanks, that is just what I needed
02:36:53 <breadmonster> class Human where name :: a -> String; age :: a -> Int ...
02:36:53 <hunteriam> dEPy: basically, i think you should make sure you've asked about every aspect of your production pipeline before you commit to it, because haskell has some occasionally dodgey infrastructure you wont want to have to deal with unexpectedly
02:37:12 <breadmonster> Soft: What are you parsing?
02:37:23 <tejing> voodoo08: a typeclass for each set of field which are always included or excluded together
02:37:31 <tejing> s/field/fields/
02:37:36 <Soft> breadmonster: just playing around with my toy language
02:37:37 <dEPy> hunteriam: I never asked about using haskell. I asked hot TypeScript types compare to haskell cause we want to use TypeScript :)
02:37:39 <voodoo08> but I dont understand the purpose of that typeclass?
02:37:39 <liste> if the records are related I think mauke[ s solution of nested records is the most elkegant
02:37:47 <liste> (for voodoo08)
02:37:53 <hunteriam> dEPy: oh LOL, never used typescript in my life
02:38:02 <hunteriam> dEPy: are you coming from a team that uses haskell then?
02:38:05 <breadmonster> liste: Yeah, but you won't be able to use the same record name, yeah?
02:38:07 <mauke[> voodoo08: data CommonFields = CF { name :: String, age :: Int }; data Manager = Manager { common :: CommonFields, circumference :: Double }
02:38:41 <breadmonster> You'd have to do something like `commonManager . name` or `commonEmployee . name`
02:38:48 <breadmonster> Which defeats the purpose.
02:39:03 <liste> breadmonster it solves the original problem
02:39:06 <breadmonster> The typeclass system is more elegant, but with uglier hackery up front.
02:39:06 <mauke[> why does that defeat the purpose?
02:39:32 <breadmonster> mauke[: I was under the impression he wanted to use the same accessor for similar fields across record types.
02:39:42 <liste> the typeclass solution works for records that are unrelated but have the same field names
02:39:44 <voodoo08> yes
02:40:02 <mauke[> breadmonster: but the question was about *not* repeating names
02:40:25 <voodoo08> I want to use the same accessor, and I also want to put different employers in a list (that was my next question)
02:40:44 <breadmonster> Okay, sorry mea culpa.
02:40:47 <tejing> voodoo08: the problem is that record accessors for all types have to live in one namespace
02:40:51 <mauke[> oh, also: data Employee = Manager { common :: CommonFields, ... } | Developer { common :: CommonFields, ... }
02:40:52 <breadmonster> If you want to use the same accessors then use a typeclass.
02:41:02 <mauke[> if you want to use a list, don't use a typeclass
02:41:28 <breadmonster> okay, the solution with the sum type is pretty cool.
02:41:57 <voidzero> i want my mommy.
02:42:07 <ronh-> mauke that will create partial functions for all the non-common fields
02:42:31 <mauke[> I'm ok with this
02:43:24 <mauke[> you could work around it by defining more types
02:43:26 <ronh-> I would do something like this: data Employee = EmployeeManager Manger | ExmployeeDeveloper Developer ...
02:43:47 <mauke[> data Employee = Manager CommonFields ManagerFields | ... or something
02:44:03 <ronh-> or that
02:44:03 <mauke[> then you'd have to pattern match to get ManagerFields, which would have accessors again
02:44:15 <mauke[> and you could still define common :: Employee -> CommonFields
02:44:25 <kuribas> why not data "Employee a = Employee {name :: String, age :: Int, custom :: a}"
02:44:39 <kuribas> or custom a sum type instead.
02:45:20 <kuribas> like "data Custom = Manager ... | Developer ..."
02:46:30 <hunteriam> hey
02:46:34 <hunteriam> is cairo broken?
02:46:38 <hunteriam> im really sad
02:46:44 <hunteriam> i was excited to use the plot library
02:46:47 <hunteriam> but it depends on cairo
02:46:55 <hunteriam> and by the looks of it cairo ismisconfigured
02:46:58 <hunteriam> so it wont install
02:47:45 <hunteriam> actually...
02:48:31 <hunteriam> plot just requires cairo, which requires pkgconfig (which isnt a package, so i used hs-pkg-config) which has a dependency incompatibility with the original package
02:49:12 <kuribas> hunteriam: maybe you need cairo development libs installed?
02:49:37 <kuribas> like: sudo apt-get install libcairo2-dev
02:49:42 <hunteriam> kuribas ive got all that, but it doesnt help me navigate this fundamental dependency incompatibility afaik
02:49:53 <voodoo08> this seems like a ton of complications and confusions over simple subtyping?
02:51:47 <kuribas> voodoo08: I'd think my solution is simple enough...
02:52:01 <kuribas> but there are more ways to get something done...
02:52:09 <kuribas> It depends on the use case.
02:52:23 <hunteriam> so, a question for those who know
02:52:25 <kuribas> hunteriam: cairo installs just fine on my system...
02:52:36 <hunteriam> kuribas: well what the hell!
02:52:54 <kuribas> hunteriam: can you post the error messages?
02:53:01 <hunteriam> yes one sec ill reinstall
02:53:26 <breadmonster> hunteriam: What GHC?
02:53:29 <hunteriam> kuribas: can you install the path library
02:53:32 <hunteriam> breadmonster: most recent
02:53:53 <hunteriam> kuribas: i think the problem is that path depends on a different colour than hs-pkg-config and wont let up about it
02:54:01 <breadmonster> hunteriam: 7.10?
02:54:13 <hunteriam> i think 7.10.2 but i can check in a sec
02:54:30 <voodoo08_>  I went through all the solutions, and it seems I have to pick between 1) runtime failure if I call field with incompatible employee 2) convulted nested records. 3) even more convulted typeclasses
02:55:20 <hunteriam> https://www.irccloud.com/pastebin/UlzdtWE9/errors
02:55:22 <liste> voodoo08_ how are nested records convoluted?
02:55:32 <hunteriam> god im sorry about that formatting
02:55:32 <breadmonster> hunteriam: I'm just installing in a sandbox atm.
02:55:44 <hunteriam> there doesnt seem to be a good way to copy from windows cmd
02:56:38 <voodoo08> liste data Employee = Manager CommonFields ManagerFields | ...
02:57:13 <kuribas> hunteriam: is pkg-config in the PATH?
02:57:14 <voodoo08> that is three record fields instead of one
02:57:31 <hunteriam> kuribas: no, where do you even install pkg-config from?
02:57:34 <voodoo08> plus additiobal constructor for each employee
02:57:42 <hunteriam> kuribas: should i just install pkg-config seperately and add it to the path?
02:57:46 <kuribas> hunteriam: It should come with cairo.
02:57:54 <hunteriam> ah!
02:58:10 <voodoo08> liste: how are they not?
02:58:18 <kuribas> it's a requirement when installing cairo, at least on linux.  Idk on windows...
02:58:23 <breadmonster> It's failing here.
02:58:36 <hunteriam> kuribas: yes it actually is
02:58:39 <hunteriam> how strange
02:58:51 <hunteriam> its on the path i mean
02:59:38 <kuribas> hunteriam: maybe it's an old version?
02:59:42 <voodoo08> I have two fields per employee instead of one, and an additional constuctor r each employee, AND a general Employee record (that isnt expandavke by the user) that glues all this mess together
02:59:56 <hunteriam> hold on one sec... i think i mightve solved the problem... mightve been something stupid lol
03:00:13 <liste> voodoo08 on e.g. C++ there would be the same elements; class <Manager> : <CommonFields> { public: <ManagerFields> }
03:00:17 <voodoo08> how is this an improvement over OOP
03:00:32 <breadmonster> voodoo08: Because you can pass functions around.
03:00:32 * hunteriam bows his head in shame
03:00:38 <hunteriam> apologies to the entire haskell irc
03:00:45 <breadmonster> hunteriam: ?
03:00:45 <hunteriam> i installed the third party libarries correctly
03:00:49 <hunteriam> but i didnt reload my shell
03:00:56 <hunteriam> ill be going now
03:00:58 <breadmonster> Interesting lol
03:01:02 <liste> voodoo08 they're just more explicit in Haskell, not hidden behind inheritance machinery
03:01:06 <hunteriam> if i return itll be by a different name
03:01:21 <breadmonster> Relax, it happens to the best of us.
03:02:15 <hunteriam> yea ik im only kidding
03:02:16 <voidzero> apologies accepted!
03:02:43 <liste> and there's no repetition on kuribas' solution
03:03:08 <kuribas> hunteriam: no problem, it is usually a small thing like that.  Or worse, many small things.
03:03:39 <liste> < kuribas> why not data "Employee a = Employee {name :: String, age :: Int, custom :: a}"  -- in that, Employee is the 'base class'
03:03:44 <hunteriam> kuribas: yea, tbh i knew i shouldve reloaded it, but i became convinced that it didnt matter because i was able to run one of the gtk programs without reloading
03:03:53 <voodoo08> liste in C++ Manager would contain all the fields, there would be no addtitional level we have to go through. and Employee would be expandable by the user of the library
03:03:54 <Adeon> is there a package that attempts to convert a String or Text to a bytestring based on current locale
03:04:23 <kuribas> hunteriam: don't worry about it.
03:04:35 <hunteriam> yea, just a silly mistake
03:05:33 <voodoo08> surely you can see how "name (commonFieds employee)" is uglier than "name employee"
03:05:53 <kuribas> voodoo08: nested records are quite usual in haskell.  Lens can help making accessing nested records easier.
03:06:09 <liste> voodoo08 the expandability compromises safety
03:06:13 <Cale> voodoo08: If you want to do OOP, then you build records of functions.
03:07:15 <Cale> voodoo08: Generally you won't run into the problem of needing "subclasses" as much, because in C++ and Java etc, the reason you need them so much in the first place is that method implementations are tied to the class declaration itself.
03:07:54 <Cale> If you define a record type with a bunch of fields for the "methods" of your object, you can fill in those fields in as many ways as you like without inventing new datatypes.
03:08:23 <Cale> and instead of "private" members, you can just have parameters to the function which creates your objects
03:10:21 <voodoo08> Cale I gave an example of what I wanted to do earlier, not sure if you have read it. 1) I want to have records for different employees. 2) they will share common fields. 3) I should be able to put different employees in a list. 4) user of the library should be able to write new emplyees
03:10:45 <Cale> (I haven't read much of the backlog, I just saw that you were asking about how to do OOP-like stuff in Haskell)
03:11:52 <Cale> 3) I should be able to put different employees in a list -- This constraint alone tells us that all the employees have the same type
03:12:10 <voodoo08> if I cant have all four I am willing to drop #4 (I will read what you said earlier, I am on a phone and I cant read whole typing eith all the people joining and quitting)
03:12:23 <Cale> ah
03:12:55 <Cale> voodoo08: Whatever would be the methods of your employee objects, you just put those in the record.
03:12:55 <liste> voodoo08 what is the interface of the employee? i.e. what do you do with them?
03:13:44 <kuribas> voodoo08: You can also use a typevariable, as in my example above.  It all depends on your usecase.
03:14:14 <liste> if you want to get e.g. see if one employee is a superior of another
03:14:16 <Cale> voodoo08: If you wanted to stick values of different types in a list, and then get them back out again, if you forgot which types they were, well, this information has been lost, so you no longer know what operations you're allowed to perform (i.e. you are now forever restricted to just passing these things around blindly and never inspecting them again, they might as well be garbage)
03:14:32 <tejing> kuribas: then they couldn't all sit in one list
03:14:37 <liste> you could have data Employee = Employee {...; isSuperior :: Employee -> Bool }
03:14:51 <voodoo08> Cale I dont understand: "you build a records of functions" arent records functions?
03:15:00 <Cale> voodoo08: No
03:15:16 <Cale> voodoo08: Functions are things of type A -> B for some types A and B
03:15:18 <voodoo08> err I meant fields
03:15:29 <Cale> voodoo08: Well, field accessors are functions
03:15:38 <Cale> voodoo08: But I mean the fields themselves might be functions
03:15:38 <kuribas> tejing: The type variable would be filled with a concrete type, yes.
03:15:46 <breadmonster> Cale!
03:15:47 <breadmonster> Hi.
03:15:58 <kuribas> tejing: That may be an acceptable solution, depending on the problem.
03:17:33 <voodoo08> Cale how would that look like in the example I used above
03:18:03 <Cale> voodoo08: I'm not sure what exactly the example was
03:18:19 <Cale> voodoo08: What operations are important?
03:18:33 <Cale> What things do you want to be able to do with an arbitrary choice of Employee?
03:18:55 <kuribas> Is there a good tutorial on rewrite rules, about good practices etc...?  It seems to be tied to the ghc implementation.
03:19:10 <breadmonster> Cale: Have you used Conduit?
03:19:12 <Cale> voodoo08: Let's say you have a list of Employee values, and you grab one out at random. What operations do you expect to be legal to apply to that?
03:19:16 <Cale> breadmonster: Not extensively.
03:19:18 <kuribas> Especially when a rule fires, or when inlining happens seems quite arbitrary.
03:19:28 <Cale> breadmonster: I mostly try to avoid it
03:19:58 <Cale> breadmonster: It's a big piece of fancy machinery which is usually overkill for most of the things I do.
03:20:52 <liste> is there a how-to somewhere for HERMIT?
03:21:11 <liste> I only found papers on implementation and code examples
03:21:36 <voodoo08> Cale, so you propose that I have a record of functions that represent all the common functionality?
03:21:45 <voodoo08> if I got it right
03:21:46 <Cale> voodoo08: Yes.
03:22:15 <Cale> voodoo08: If you find yourself wanting to stick a bunch of things of different types in a list somewhere in your program, then you have two options:
03:23:18 <Cale> voodoo08: 1) Make a type which records all the possibilities for what type of item you have, and stick those in the list. In the limiting case, you have Dynamic, which uses the Typeable class to store runtime type information, but usually you have a finer set of options.
03:23:44 <Cale> voodoo08: Or 2) Figure out what you're going to do with the things once you take them out, and make a record of those things instead.
03:25:07 <Cale> voodoo08: For example, if I'm storing a bunch of different sorts of values in a list, and all I'm going to do when I take them out is prettyprint them for display on the screen, I can instead just put the results of prettyprinting them in the list
03:26:08 <Cale> voodoo08: and if there are a bunch of different things I might want to do with them, well, I just make a record type with all of those things
03:26:18 <mfng> GHCi on windows doesn't take & display Japanese characters
03:26:22 <Cale> voodoo08: and then functions which build such records starting with different initial types of data
03:26:23 <mfng> Any solution..?
03:26:57 <Cale> mfng: Isn't that more a limitation of the windows terminal emulator? I seem to recall something about codepages
03:27:19 <voodoo08> Cale yeah I get it
03:28:07 <mfng> But then it's a bit unfair not being able to use windows..
03:28:09 <Cale> voodoo08: Lazy evaluation can help with performance here, as we don't necessarily do all of that work when we build such a record
03:28:29 <liste> mfng do they show up as boxes?
03:28:43 <liste> or question marks?
03:29:09 <mfng> it throws exception 'invalid character'
03:29:17 <Cale> mfng: try running  chcp 65001
03:29:30 <Cale> before running ghci
03:29:42 <Cale> and see if that helps
03:30:06 <kuribas> I don't like that ghc has implicit "make" rules.
03:30:16 <kuribas> That it doesn't recompile when I want it to.
03:31:14 <Cale> mfng: iirc, the problem is that the windows cmd.exe defaults to having no support for UTF-8 characters
03:31:33 <hunteriam> does anyone know how to install BLAS or LAPACK for hmatrix on Windows?
03:31:47 <hunteriam> i copied the .dll's to my PATH, but its still not working
03:31:48 <Cale> mfng: At least, in the usual English version, I don't know how it is if you're using the Japanese version of Windows.
03:32:36 <mfng> <Cale> ran chcp 65001, now it doesn't throw exception but returns a strange characters instead 
03:32:37 <voodoo08> Cale lets say that my end goal is to put all the employees in a gtk table that will list all the fields. I came up with this but I am not liking it much.. data Employee = Employee { fields :: [(String, Value)] } data Value = Int Int | String String ..
03:32:44 <liste> hunteriam -f openblas when compiling
03:33:08 <hunteriam> liste: in cabal?
03:33:31 <liste> hunteriam for ghc-options
03:33:45 <liste> no
03:33:47 <liste> sorry
03:33:49 <liste> for cabal
03:33:51 <Cale> voodoo08: Is there a good reason to have Value instead of simply String there?
03:33:59 <voodoo08> Cale I am not sure how record of functions would help me here
03:34:05 <mfng> <Cale> I'm currently using En version of w 
03:34:09 <mfng> <Cale> I'm currently using En version of Windows.
03:34:53 <voodoo08> Cale well what if I want to, say, compute  the average age of the employee?
03:35:23 <hunteriam> liste: the trick was --extra-lib-dirs = location
03:35:30 <voodoo08> hmm let me try again..
03:35:39 <Cale> voodoo08: Well, then you'll need to know that they *have* an age, so your current setup is dead in the water already.
03:35:48 <hunteriam> liste: on windows + not using openblas, but im sure thats the solutoin for linux
03:37:13 <Cale> voodoo08: If being able to determine the age of an Employee is an important operation, you make it a field
03:37:29 <Cale> data Employee = Employee { age :: Integer }
03:37:39 <Cale> What other operations are important?
03:39:17 <hunteriam> guys, i cant compile hmatrix
03:39:22 <voodoo08> Cale also, I would want to sort columns. and Ints would be sorted differently than Strings
03:39:28 <hunteriam> ive got libblas and whatnot
03:39:46 <hunteriam> but i get a BUNCH of C errors for Numeric.LinearAlgebra.Static
03:39:50 <hunteriam> got no clue what to do
03:40:55 <Cale> voodoo08: Absolutely.
03:40:55 <voodoo08> it seems that the least painful way would be to have a giant Employee record with all the fields (as Maybes) from all the empleyees.. :(
03:41:04 <Cale> voodoo08: Why Maybes?
03:41:24 <hunteriam> https://www.irccloud.com/pastebin/swA32Vdh/hmatrix%20fail
03:41:28 <Cale> voodoo08: It's really okay to demand that some things are there if your program is going to need them
03:41:41 <hunteriam> can anyone take a look at this and advise me? problems with the C side of hmatri
03:41:42 <hunteriam> x
03:41:43 <Cale> voodoo08: I don't know what program you're trying to write.
03:41:45 <voodoo08> because some fields wont make sense for some employees
03:41:54 <Cale> voodoo08: Well, fair enough.
03:42:53 <Cale> Some fields might be Maybes, that is an option that you have available to you if you want to be able to make your program do different stuff when certain data about the Employee is available.
03:42:56 <breadmonster> can attoparsec parse with state like parsec does?
03:42:58 <peddie> hunteriam: what is your C compiler?
03:43:06 <hunteriam> peddie: mingw
03:43:22 <hunteriam> gcc (rubenvb-4.6.3) 4.6.3  
03:43:45 <hunteriam> peddie: do you think its out of date?
03:43:50 <peddie> hunteriam: hm, it looks like it's missing a #include or something like that, do you see any conditional includes or anything like that in the file?
03:44:06 <Cale> breadmonster: It doesn't have the superfluous user state type parameter that Parsec has.
03:44:09 <pacak> breadmonster: As a monad transfomer? No, but you can pass state around manually.
03:44:24 <Cale> But yeah, what pacak said :)
03:44:25 <peddie> hunteriam: no, that compiler seems pretty recent (I have no idea how windows/mingw works though)
03:44:27 <hunteriam> peddie: ok give me a sec, ill look
03:44:42 <breadmonster> pacak: How do you do that?
03:44:44 <Cale> You could use StateT or pass additional state around by hand.
03:44:51 <jle`> does anybody actaully use the state parameter in parsec?
03:44:56 <breadmonster> Cale: Hmm, thought so.
03:45:01 <Cale> breadmonster: Just take an extra function parameter for the state
03:45:03 <breadmonster> jle`: Yes.
03:45:08 <pacak> jle`: Yes.
03:45:12 <breadmonster> It's incredibly useful.
03:45:13 <jle`> :o
03:45:17 <Cale> and return the result of parsing along with the new state
03:45:20 <chpatrick> ahoy
03:45:21 <hunteriam> peddie: where do i find the src files for the install
03:45:22 <hunteriam> ?
03:45:28 <breadmonster> Hmm, okay, so basically StateT.
03:45:35 <Cale> Yeah
03:45:52 <breadmonster> jle`: Try parsing Python without state. It's really painful.
03:45:53 <Cale> Sometimes it's fine to do that manually -- especially if you only need to pass it in one direction
03:45:59 <chpatrick> do you think it's faster to use StateT s (WriterT m) rather than RWS ()?
03:46:02 <breadmonster> You need a stack.
03:46:03 <Cale> (like you don't need to bother tupling the output)
03:46:08 <breadmonster> To take care of the indentation.
03:46:34 <peddie> hunteriam: on my computer it's inside a tarball in ~/.cabal/packages/hackage.haskell.org/hmatrix/0.16.1.5
03:46:37 <Cale> breadmonster: hm, I would assume that you'd just do a first pass to remove the indentation dependency
03:46:52 <pacak> chpatrick: RWS would be faster.
03:47:04 <breadmonster> Cale: maybe I should do that instead...
03:47:23 <chpatrick> pacak: even with the pointless ()-plumbing?
03:47:30 <pacak> chpatrick: yep
03:47:39 <chpatrick> ok, I'll take your word for it
03:47:46 <breadmonster> Cale: conduit seems perfect for these kinds of things.
03:47:48 <Cale> breadmonster: That's basically how Haskell's offside rule stuff is specified.
03:48:02 <hunteriam> peddie: didnt see any conditional includes
03:48:02 <jle`> chpatrick: there's one way to find out :)
03:48:04 <breadmonster> Except I have no idea how to use it.
03:48:07 <hunteriam> peddie: idea what else i should check for?
03:48:10 <Cale> There are certain conditions for where to insert braces and semicolons, pretty much
03:48:17 <jle`> chpatrick: (benchmarking)
03:48:31 <breadmonster> chpatrick: How do you have that awesome cloak?
03:48:33 <voodoo08> in an OOP language I would have. BaseEmployee class, that all Employees inherit from (as well as add their own fields). then I would have a list of BaseEmployees, which would contain all the common fields. and if I wanted to do something for a specific kind of Employee I would either (depending on a language) write an overloaded function that dispatches on various Employees types or cast BaseEmployee to specific Employees
03:48:35 <Cale> breadmonster: Conduit is for I/O, not so much parsing specifically.
03:48:42 <breadmonster> What really?
03:48:50 <breadmonster> I thought it was for data streams.
03:48:55 <voodoo08> I am not sure how record of functions would help me simulate that?
03:49:15 <Cale> breadmonster: Well, mostly I/O streams.
03:49:16 <peddie> hunteriam: not sure off the top of my head, I'm trying to look at the functions themselves
03:49:28 <Cale> breadmonster: You might be able to put it to use for other things
03:49:29 <pacak> breadmonster: I'm using iteratee for parsing with attoparsec
03:49:30 <peddie> hunteriam: it's supposed to get the definition for 'struct random_data' from someplace, and it's not
03:49:48 <pacak> breadmonster: parseStuff :: Monad m => Enumeratee [Unparsed] [Parsed] m a
03:50:15 <voodoo08> I would get a common functionality for all employees, but how would I do something different when I have a specific employee? 
03:50:20 <pacak> breadmonster: This allows to put all state related to parsing inside. You should be able to do the same with pipes/conduit.
03:50:22 <Cale> voodoo08: Why not just make that thing a method of BaseEmployee instead?
03:50:35 <chpatrick> breadmonster: I'm a wizard ;)
03:50:40 <breadmonster> Cale: it's easiest to use a typeclass.
03:50:52 <Cale> breadmonster: for what?
03:50:57 <breadmonster> chpatrick: It's not fair man, all I have is this generic unaffiliated cloak
03:51:04 <voodoo08> but then BaseClass would contain finite functionality of Employees?
03:51:08 <breadmonster> Cale: for record names.
03:51:20 <Cale> breadmonster: I don't know what you're discussing
03:51:23 <voodoo08> BaseEmployee, not BaseClass
03:51:42 <breadmonster> class Human where name :: a -> String ...; instance Human Employee where ...
03:51:52 <hunteriam> peddie: possibly do i need some other third party library? random_data appears to be a gnu-bsd thing
03:51:53 <Cale> breadmonster: not a solution to voodoo08's problem
03:51:54 <dramforever> voodoo08: are the different classes known before compiling?
03:52:17 <voodoo08> dramforever: ideally they arent, but I can compromise
03:52:19 <peddie> hunteriam: oh, if you have some clue where it's coming from, yeah, try that :)  I'm still stumped
03:52:21 <Cale> voodoo08: Your program is ultimately finite
03:52:31 <breadmonster> Every time I use a list, I get worried about performance.
03:52:33 <Cale> voodoo08: So you know what things you're going to have to do with Employees
03:52:43 <hunteriam> peddie: i just google struct random data, some people have had similar problems with perl but none of them say the solution afaik
03:52:46 <dramforever>  maybe voodoo08
03:52:48 <dramforever> ouch
03:53:07 <dramforever> Cale: maybe voodoo08 wants to write a library?
03:53:13 <dramforever> or lib-ish
03:53:25 <Cale> breadmonster: Just think "is it sensible that I'll iterate over this in order instead of randomly?", and if the answer is yes, you can breathe a sigh of relief, lists are the right data structure.
03:53:28 <voodoo08> Cale yes but doing it like that doesnt allow the user of the library to expand Employees functionality
03:53:51 <Cale> voodoo08: Sure. But it lets them extend the types of Employees easily.
03:53:58 <dramforever> voodoo08: how about a typeclass?
03:54:05 <peddie> hunteriam: looks like it's meant to be in stdlib.h
03:54:06 <dramforever> class EmployLike a where
03:54:07 <breadmonster> Cale: then why does pipes/conduit exist?
03:54:10 <dramforever> or whatever name
03:54:11 <Cale> voodoo08: They can implement new values which implement those methods in different ways
03:55:23 <Cale> breadmonster: Mostly because control over resources interacts badly with lazy IO. If you have the OS imposing a draconian restriction on the number of sockets or something, you don't want to be applying hGetContents to your socket handles.
03:55:24 <hunteriam> peddie: http://stackoverflow.com/questions/14035282/stdlib-hs-random-on-ms-visual-studio-2008
03:55:32 <hunteriam> peddie: dont see a solution there, but its on the right tracks
03:55:46 <Cale> breadmonster: Because when you do so, you pretty much give up the right to explicitly hClose those
03:56:05 <peddie> hunteriam: yeah, I just found some results from people trying to add it to mingw in 2008, but no idea if there's anything recent that changed
03:56:15 <Cale> breadmonster: So, if you care about timely release of resources back to the OS, but you want something like lazy IO otherwise, you need some careful machinery
03:57:14 <hunteriam> peddie: possibly i shouhld just copy that stackoverflow random files and add an include inhmatrix
03:57:52 <Cale> breadmonster: The other thing is exception handling
03:57:53 <peddie> hunteriam: well, I suspect it's meant to work in Windows as well, maybe also create an issue on hmatrix's github page with details on what version of mingw you're using?
03:58:24 <hunteriam> peddie: christ, i would, but i haventn slept, my sole mission is to do whatever it takes to compile hmatrix ad then evaporate in my bed
03:58:36 <peddie> hunteriam: sorry, at this point it looks like it's a platform thing, so I'm going to have to tap out :)
03:58:55 <hunteriam> peddie: think that stackoverflow post contains a solution?
03:58:56 <peddie> aha
03:58:57 <Cale> breadmonster: If you want to be able to sequence the handling of exceptions which might not come until some later point in the stream in some sane way with everything else, using lists directly is a bad idea because they have no simple way to represent the exceptional conditions.
03:58:58 <peddie> https://github.com/albertoruiz/hmatrix/issues/125
03:59:07 <peddie> hunteriam: ^ 
03:59:20 <hunteriam> there we go
03:59:22 <hunteriam> some work saved
03:59:24 <peddie> looks like it's a known problem, but unfortunately they list no workaround yet
03:59:34 <peddie> but at least you know it's not just you :)
04:00:06 <hunteriam> yea, im going to use the code from that stackoverflow
04:00:12 <peddie> good luck!
04:00:14 <hunteriam> its just an implementation of random_data i think
04:00:15 <Cale> breadmonster: http://hackage.haskell.org/package/conduit-1.2.4.2/docs/Data-Conduit-Internal.html
04:00:17 <hunteriam> so it should hopefully work
04:00:35 <Cale> breadmonster: A look at the Pipe datatype should give some idea of the problems which conduit is attempting to solve
04:00:37 <hunteriam> but ive got to package it into the makefile somehow possibly?
04:00:40 <hunteriam> im not sure
04:00:44 <hunteriam> i hope i dont
04:00:57 <Cale> breadmonster: (and yes, it is kind of insane, and that's why I avoid it unless I really need it)
04:00:59 <peddie> hunteriam: it might just be something you can put in a header file and #include
04:01:25 <hunteriam> peddie: true, maybe it just needs a proper definition
04:01:48 <ocramz> sup
04:02:39 <Cale> breadmonster: I guess something a little unclear is how this interacts with exceptions, but if you're working over IO, then PipeM lets you put arbitrary IO actions in the midst of your Pipe computations, which lets you execute an IO action to throw an exception for instance.
04:03:10 <Cale> (and there are things like catchP later in that module)
04:03:21 <kuribas> Do list functions in GHC use fusion by default?
04:03:42 <dramforever> Cale: that looks like a free monad! (although every monad looks like a free monad)
04:03:44 * hackagebot alarmclock 0.2.0.7 - Wake up and perform an action at a certain time.  http://hackage.haskell.org/package/alarmclock-0.2.0.7 (dcturner)
04:03:46 <liste> kuribas yes
04:03:48 <Cale> kuribas: A little bit. They use foldr/build fusion
04:04:00 <Cale> dramforever: heh, yes a bit
04:04:02 <kuribas> ok, I see
04:04:36 <hunteriam> hey guys
04:04:43 <Cale> kuribas: Note that you need -O or -O2, or the RULES pragmas won't do anything
04:04:50 <hunteriam> how do i install a cabal source into a sandbox one direcory above it
04:05:04 <hunteriam> is there a flag like --use-sandbox=
04:05:05 <hunteriam> or something
04:05:16 <kuribas> Cale: yes
04:08:08 <Cale> voodoo08: anyway, there's a bit of a fundamental tradeoff that is practically unavoidable when you design your datatypes. You can make it easy to add new variants of something in the future, at the expense of fixing the operations ahead of time, or you can make it easy to add new operations on the data, at the expense of making it hard to add new variants.
04:08:11 <Cale> agh
04:08:34 <Cale> @tell voodoo08 There's a bit of a fundamental tradeoff that is practically unavoidable when you design your datatypes. You can make it easy to add new variants of something in the future, at the expense of fixing the operations ahead of time, or you can make it easy to add new operations on the data, at the expense of making it hard to add new variants.
04:08:34 <lambdabot> Consider it noted.
04:08:45 <dramforever> Cale: I guess only "dynamic" languages supports both
04:08:54 <dramforever> and the interpreter can't check them statically
04:10:03 <hunteriam> peddie: i got it! just needed an extra .h
04:10:37 <peddie> hunteriam: congrats!
04:10:47 <Cale> @tell voodoo08 There are ways to sidestep this altogether, for instance, using many separate type classes, one per operation. http://channel9.msdn.com/Shows/Going+Deep/C9-Lectures-Dr-Ralf-Laemmel-Advanced-Functional-Programming-The-Expression-Problem
04:10:48 <lambdabot> Consider it noted.
04:12:18 <Cale> @tell voodoo08 http://channel9.msdn.com/Shows/Going+Deep/C9-Lectures-Dr-Ralf-Lmmel-Advanced-Functional-Programming-Type-Classes
04:12:19 <lambdabot> Consider it noted.
04:12:49 <Cale> I don't know if there's a limit on tells...
04:15:17 <geekosaur> none that I know of, aside from the practical one that it's a list serialized to lambdabot state and therefore a very large list of pending tell-s can slow things down
04:15:40 <geekosaur> (one list with all such tells in it)
04:15:44 <Cale> ah
04:16:40 <geekosaur> and possibly take a lot of memory, especially if it's still [String] instead of say [Text] (but I'm guessing these days it's the latter)
04:18:44 * hackagebot alarmclock 0.2.0.8 - Wake up and perform an action at a certain time.  http://hackage.haskell.org/package/alarmclock-0.2.0.8 (dcturner)
04:38:43 <sproul> I've found myself writing a lot of `isBlah :: BlahThing -> Bool` functions that just check for an ADT variant, is there any GHC magic I can use to generate them?
04:39:17 <merijn> sproul: Why do you need those?
04:39:19 <dramforever> sproul: can you pattern match?
04:39:40 <sproul> I'm using pattern matching at the moment, but there are about 8 functions like this
04:39:50 <Peaker> Hey, I'm trying to throw some heavy computations to other cores via forkIO. I want responsiveness in my main thread..  par-GC requests from the bg thread KILL my main's responsiveness :-(
04:39:56 <sproul> I'm using them to filter lists of these types
04:39:57 <merijn> sproul: No, he means instead of the isBlah, just match onf BlahThing
04:40:04 <Peaker> any idea how you can get responsive concurrency with GHC?
04:40:08 <merijn> sproul: Oh, there's a much better trick to do that
04:40:30 <dramforever> sproul: why are you doing this?
04:40:54 <merijn> > let xs = [Just 1, Just 3, Nothing, Just 5, Nothing] in [x | x@(Just{}) <- xs ] --whooo
04:40:57 <lambdabot>  [Just 1,Just 3,Just 5]
04:41:18 <sproul> merijn, dramforever: I'm actually nesting a little, my data types are:
04:41:37 <dramforever> sproul: > lpaste
04:42:16 <lpaste> Sproul pasted “IsFest” at http://lpaste.net/134096
04:42:42 <sproul> dramforever: cheers
04:43:15 <merijn> sproul: What's wrong with my listcomprehension example just now?
04:43:27 <dramforever> sproul: you can use view patterns
04:43:50 <dramforever> which allows you to write isSms (chargeInfo -> Sms _) = True
04:43:56 <hunteriam> how does ghc figure out which c files certain c files depend on?
04:44:05 <sproul> merijn: it's fine, but I'm writing a library so I can do these en masse
04:44:13 <merijn> > let xs = [Just (Just 1), Nothing, Just (Just 3), Just Nothing, Just 5, Nothing] in [x | x@(Just (Just{})) <- xs ] --whooo
04:44:16 <lambdabot>      No instance for (Show a0)
04:44:16 <lambdabot>        arising from a use of ‘show_M15571515170504322963015’
04:44:16 <lambdabot>      The type variable ‘a0’ is ambiguous
04:44:17 <hunteriam> ive got a bunch of c files in a src directory that depend on each other but i dont know how to tell ghc to make sure theyre all used
04:44:19 <sproul> dramforever: that looks good
04:44:20 <merijn> awww
04:44:36 <merijn> oh, duh
04:44:47 <merijn> > let xs = [Just (Just 1), Nothing, Just (Just 3), Just Nothing, Just (Just 5), Nothing] in [x | x@(Just (Just{})) <- xs ] --whooo
04:44:50 <lambdabot>  [Just (Just 1),Just (Just 3),Just (Just 5)]
04:45:20 <dramforever> actually, I dunno why the (f => x) -> (f -> Just x) sugar isn't implemented
04:49:32 <aleator> If I 'link' an async to the main thread and subsequently 'cancel' it, will it kill the whole program?
04:53:13 <aleator> Yup..
04:55:18 <hunteriam> guys
04:55:31 <hunteriam> im trying to hack my way into installing hmatrix on mingw and Windows
04:55:34 <hunteriam> i thought i had it working
04:55:57 <hunteriam> but, thinks that depend on hmatrix are giving me `undefined reference to myerrno` now
04:56:06 <hunteriam> not sure how to interpret that
04:56:21 <hunteriam> my_errno 
04:59:17 <liste> isn't my_errno some MySQL thing ?
05:06:15 <pavonia> hunteriam: Could you paste your build log?
05:45:37 <kqr> is there a library for simple web scraping? like "loop through all elements on this html page that has this selector"
05:48:03 <merijn> kqr: I've used xml-conduit and/or html-conduit together with http-conduit with decent success
05:48:21 <merijn> It was easy enough to grab the elements I cared about
05:52:02 <kqr> not sure I understand how to grab elements with html-conduit
05:52:21 <kqr> oh right, it parses into a Document
05:53:10 <Psidium> testing, hello, I'm learning haskell and I want to know why (++) can't generate infinite lists and (:) can.
05:53:27 <mauke[> Psidium: what?
05:53:50 <maerwald> Psidium: do you have a specific example?
05:54:16 <dramforever> Psidium: ?
05:54:29 <dramforever> > let x = [1,2,3,4,5] ++ x in x
05:54:32 <lambdabot>  [1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3...
05:54:49 <Psidium> Yes, I'm trying to implement a Fibonacci function, and the way I did it with (++), the ghci just freezes on loop, but if I use (:) it will print it normally
05:55:08 <mauke[> you're not making sense
05:55:18 <Psidium> Sorry :(
05:55:22 <dramforever> you need to paste the code to lpaste(see topic)
05:56:45 <lpaste> Psidium pasted “Fibonacci” at http://lpaste.net/134100
05:57:04 <Psidium> thanks for the tip
05:57:14 <mauke[> those aren't even close to the same function
05:57:25 <maerwald> where is (++) in that code?
05:57:59 <mauke[> how is this not a type error?
05:58:00 <Psidium> Ops, I took it out trying to make it work
05:58:39 <lpaste> Psidium pasted “fib2” at http://lpaste.net/134101
05:59:27 <Psidium> I know those don't work, but I'm trying to understand what I've done wrong on the two failed attempts 
05:59:50 <mauke[> well, the first one is a type error
06:00:11 <mauke[> how does the second one fail?
06:00:52 <Psidium> I'm referring the "second one" the code on which I try to use guards
06:01:15 <mauke[> me, too
06:01:37 <Psidium> ghci goes into loop
06:01:45 <maerwald> Psidium: it works for me, what is the problem?
06:01:54 <maerwald> the code is just VERY slow
06:01:54 <mauke[> Psidium: on what expression?
06:02:02 <maerwald> lim <= (last xs) is very expensive
06:02:03 <Psidium> Oh it works 
06:02:23 <Psidium> I was trying with numbers too big
06:02:33 <maerwald> yes, "last" is O(n)
06:02:39 <maerwald> it has to go through the whole list
06:02:49 <mauke[> that function does 4 complete traversals of the input list at each call
06:02:55 <maerwald> yeah
06:03:03 <mauke[> and it allocates a complete copy each time through
06:03:37 <mauke[> looks like it takes quadratic time and space
06:03:45 <dramforever> once someone asked me why haskell lists don't support fast indexing
06:03:46 <Psidium> Oh I see the problem
06:03:48 <dramforever> I told him:
06:03:51 <dramforever> @src []
06:03:51 <lambdabot> data [] a = [] | a : [a]
06:04:11 <dramforever> and he said (translated): What?? I thought that was just an example...
06:04:55 <maerwald> :o
06:07:07 <Psidium> Where can I search for the definition of (|) and other 'ungoogleable' functions ? 
06:07:15 <maerwald> Psidium: hoogle
06:08:06 <mauke[> Psidium: | is not a function
06:08:11 <mauke[> it's built-in syntax
06:08:16 <maerwald> yep, but hoogle shows those as well
06:08:20 <Psidium> maerwald: thanks so much
06:08:26 <mauke[> oh, sweet
06:08:53 <Psidium> Oh, of course, just like on predicates
06:10:26 <Psidium> Thanks for the help, guys, I'll keep on learning
06:10:35 <SparkySparkyBoom> let???s say i have `[c]` and  `f :: a -> b -> [c]`
06:10:38 <SparkySparkyBoom> i also have a list of `[(a, b)]`
06:10:39 <maerwald> mauke[: I'm not really sure how to call (->) though. Hoogle says it's a keyword, but...
06:10:40 <SparkySparkyBoom> i want to transform `[c]` for every member of the list of pairs
06:10:42 <SparkySparkyBoom> f is commutative
06:11:07 <SparkySparkyBoom> what im thinking of is map and then take the member of the resulting list
06:11:16 <mauke[> SparkySparkyBoom: transform how?
06:11:25 <SparkySparkyBoom> er foldr
06:11:28 <SparkySparkyBoom> and last member
06:11:37 <mauke[> ???
06:12:12 <SparkySparkyBoom> i want to apply f with different a's and b's
06:12:17 <SparkySparkyBoom> on the [c]
06:12:31 <SparkySparkyBoom> sorry for it being convoluted
06:12:41 <mauke[> what do you mean, "on the [c]"?
06:12:48 <SparkySparkyBoom> the first list
06:12:59 <jameseb> SparkySparkyBoom: you mean you want to map f over a list of type [(a,b)]?
06:13:12 <SparkySparkyBoom> sort of
06:13:23 <SparkySparkyBoom> hold on
06:13:27 <mauke[> SparkySparkyBoom: ???
06:13:28 <jameseb> to get a result of type [c]
06:13:37 <SparkySparkyBoom> maybe i can come up with a solution in js
06:13:44 <SparkySparkyBoom> it'll be easier to explain that way
06:13:54 <dramforever> SparkySparkyBoom: how about an example?
06:13:57 <SparkySparkyBoom> yes
06:14:01 <dramforever> that's even easier
06:22:43 <jameseb> > let f a b = [a+b, a-b, a*b] in concatMap (uncurry f) [(1,2), (3,4), (5,6)] -- SparkySparkyBoom: something like this?
06:22:46 <lambdabot>  [3,-1,2,7,-1,12,11,-1,30]
06:23:20 <SparkySparkyBoom> yes
06:23:38 <SparkySparkyBoom> :t concatMap
06:23:43 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
06:23:46 <dramforever> :t (>>=)
06:23:50 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:23:56 <dramforever> :t (=<<)
06:23:58 <lambdabot> Monad m => (a -> m b) -> m a -> m b
06:28:51 * hackagebot haverer 0.2.0.0 - Implementation of the rules of Love Letter  http://hackage.haskell.org/package/haverer-0.2.0.0 (jml)
06:32:15 <nak> merijn are you still here ?
06:33:24 <nak> > let xs = [Just 1, Just 3, Nothing, Just 5, Nothing] in [x | x@(Just{}) <- xs ] --merijn
06:33:28 <lambdabot>  [Just 1,Just 3,Just 5]
06:33:33 <nak> > let xs = [Just (Just 1), Nothing, Just (Just 3), Just Nothing, Just (Just 5), Nothing] in [x | x@(Just (Just{})) <- xs ] --merijn
06:33:36 <lambdabot>  [Just (Just 1),Just (Just 3),Just (Just 5)]
06:34:24 <nak> i have not seen this (Just{}) syntax
06:34:27 <nak> what is that called
06:34:57 <pacak> RecordWildcards
06:35:00 <pacak> I think.
06:36:13 <mauke[> no, this is just normal record syntax
06:36:53 <maerwald> RecordWildcards is {..} afair?
06:37:39 <pacak> Right, it's available by default...
06:38:23 <voidzero> I saw it with Sum of Data.Monoid
06:38:39 <voidzero> > Sum 5 `mappend` Sum 8
06:38:43 <voidzero> iirc
06:38:45 <lambdabot>  Sum {getSum = 13}
06:39:45 <pacak> > let Sum{..}  = Sum 100 in getSum
06:39:48 <lambdabot>      Illegal `..' in record pattern
06:39:48 <lambdabot>      Use RecordWildCards to permit this
06:39:49 <nak> mauke[ i'm trying to find more information about record syntax, where should i be reading ?
06:40:33 <nak> is this an OK resource https://ghc.haskell.org/trac/ghc/wiki/Records
06:41:25 <merijn> nak: Right, it's just record syntax
06:41:56 <merijn> nak: hmmm, that's not a good one as it discusses alternative implementations/approaches
06:42:20 <nak> merijn hello ^.^
06:42:26 <merijn> nak: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#record-syntax
06:43:51 * hackagebot cabal-debian 4.29 - Create a Debianization for a Cabal package  http://hackage.haskell.org/package/cabal-debian-4.29 (DavidFox)
06:44:07 <nak> "There must be a better way, you say! Well no, there isn't, sorry."
06:44:15 <nak> "Just kidding, there is. Hahaha! The makers of Haskell were very smart and anticipated this scenario..."
06:44:17 <nak> lol
06:57:41 <crocket> Is there an alternative to gitlab or gogs written in haskell?
06:58:28 <beckyconning_> if i have something of type forall m. (Monad m) => m ([a]) how can i use a reduce-like function to get something of type m a?
06:59:01 <YellowOnion> is there any simple way to run ghci/runhaskell inside a cabal-sandbox?
06:59:11 <crocket> It seems I have bitbucket for private repos.
06:59:18 <mauke[> beckyconning_: fmap reduceLike
06:59:21 <frerich> beckyconning_: You could fmap any function of type '[a] -> a'
06:59:32 <beckyconning_> mauke: thanks : )
06:59:42 <beckyconning_> frerich: thanks too!
07:00:01 <alpounet> YellowOnion: cabal repl / cabal exec runhaskell respectively, I think
07:01:25 <crocket> Is darcs a decent revision control system?
07:01:34 <alpounet> cabal exec ghci if you want to run ghci in a sandbox but without the need for a cabal file/project
07:01:58 <YellowOnion> alpounet, exec is an unknown command
07:03:16 <nak> data Foo = Bar
07:03:23 <nak> Foo is a type constructor
07:03:26 <nak> Bar is a ??
07:03:31 <nak> i've heard "data constructor"
07:03:40 <nak> but LYAH says "value constructor"
07:04:03 <Hafydd> Just "constructor" is conventional, surely.
07:04:21 <alpounet> YellowOnion: uh? what version of cabal-install are you running? i.e 'cabal --version'
07:04:23 <frerich> nak: I always called them 'data constructors', but now that I hear about it, I think I like 'value constructor' at least as much.
07:05:55 <nak> Hafydd it seems like "constructor" would be ambiguous tho
07:06:06 <mizu_no_oto> crocket: yes, it is.
07:06:20 <YellowOnion> alpounet, think I figured out my issue, now to find a solution...
07:06:25 <hodapp> hrmph, 5 days later and no docs on this hackage package... I may have to bug the maintainer
07:06:32 <Hafydd> nak: it could be if you didn't know that convention, I suppose.
07:06:43 <lpaste> YellowOnion pasted “No title” at http://lpaste.net/134106
07:06:46 <Hafydd> But then "function" isn't ambiguous even in the presence of "type function".
07:07:59 <YellowOnion> $PATH is such a pain on windows, alpounet I assume its something to do with that.
07:08:23 <srhb> nak: Bar is also a value of type Foo, since it doesn't actually take any arguments.
07:08:23 <alpounet> YellowOnion: oh that's easy. the new cabal-install has been installed somewhere that doesn't appear in PATH or appears after where your old cabal is.
07:08:29 <alpounet> yeah, exactly.
07:08:35 <srhb> nak: value constructor seems the most clear to me in general.
07:08:50 <srhb> (Since data constructor doesn't actually tell you if it goes on the left or the right of the equals sign)
07:09:46 <nak> srhb let's say,  data Foo a = Bar a | Bof a
07:09:58 <nak> srhb is Bar and Bof "values" of Foo now ?
07:10:07 <YellowOnion> alpounet, $PATH on windows is a nightmare as there's no standard location for exes, mine already has about 20 different entries.
07:10:15 <srhb> nak: No, now they are definitely value constructors.
07:10:19 <nak> gotcha 
07:10:40 <alpounet> YellowOnion: yeah I used to have the same problem =)
07:11:08 <nak> brb
07:12:13 <YellowOnion> alpounet, I think its checking the global path first, over the userpath
07:12:50 <alpounet> YellowOnion: well isn't there a way to print it or something?
07:13:30 <alpounet> anyway, just make sure whatever dir the new cabal has been installed into appears before the dir of the older one
07:13:57 <alpounet> and it will work
07:16:04 <YellowOnion> alpounet, well the only way I can fix this is break it for all other users on the system, luckly no other users use this computer.
07:17:18 <YellowOnion> I'm curious now if other Windows users suffer from the same issue.
07:23:53 * hackagebot yesod-crud-persist 0.1.0.0 - Flexible CRUD subsite usable with Yesod and Persistent.  http://hackage.haskell.org/package/yesod-crud-persist-0.1.0.0 (andrewthad)
07:32:39 <nak> ok i'm back
07:37:23 <nak> is there a way to print all of the available value constructors for a given type constructor in ghci ?
07:38:04 <srhb> :i does that, I think
07:38:16 <nak> ooo
07:38:21 <nak> yeah i tried
07:38:23 <nak> :t Ordering
07:38:24 <nak> but 
07:38:29 <nak> :i Ordering 
07:38:29 <nak> works
07:38:30 <lambdabot> Not in scope: data constructor ‘Ordering’
07:38:49 <srhb> nak: Type of type would be weird anyway, right?
07:38:57 <nak> it would be !
07:38:57 <srhb> nak: (anyway we call that kind, or :k)
07:39:00 <srhb> :-)
07:39:04 <nak> wait
07:39:08 <nak> huh
07:39:09 <nak> what is :k
07:39:24 <chpatrick> the type of a type :)
07:39:38 <chpatrick> Prelude> :k Int
07:39:38 <chpatrick> Int :: *
07:39:49 <chpatrick> Prelude> :k Ord
07:39:49 <chpatrick> Ord :: * -> Constraint
07:39:56 <nak> ghci> :k Maybe
07:39:56 <nak> Maybe :: * -> *
07:40:06 <nak> why * here ?
07:40:15 <chpatrick> * is the kind of values
07:40:17 <srhb> nak: That's the name for the kind of types
07:40:34 <nak> oh
07:40:40 <srhb> 1 :: Int, Int :: * -- if you pardon me misusing :: here
07:40:41 <nak> as opposed to `a` which is for the *type*
07:42:22 <nak> i can see why people coming from dynamic languages have such difficulty learning haskell
07:42:34 <nak> why were dynamic languages ever invented
07:42:36 <srhb> nak: Brave new world. :-)
07:42:37 <nak> seriously
07:42:42 <srhb> Fashion, I think?
07:42:56 <nak> some fuckface was like "hey let's make it so people can be lazy and screw up their programs"
07:42:58 <srhb> Also type systems were really shit way back when.
07:43:12 <srhb> Haskell is great because it's static _and_ the type system doesn't get in your way like in other static languages.
07:43:13 <nak> "let's create a whole new era of shitty software... we'll build it with dynamically typed langs!"
07:43:14 <srhb> Think java.
07:43:39 <srhb> So people mistakenly though that because Java (and friends) suck, static typing sucks.
07:43:46 <maerwald> nak: you can have dynamic types in haskell too, what's the problem
07:43:46 <nak> yeah
07:43:53 <maerwald> it just follows very strict rules
07:43:59 <chpatrick> the thing is though that a logical error in haskell is an error in a dynamic language too
07:44:04 <chpatrick> they just don't tell you
07:44:16 <nak> right
07:44:25 <nak> it's like "you'll find that when it surfaces later"
07:44:27 <chpatrick> so it's like
07:44:35 <chpatrick> "I feel so free because the compiler doesn't bitch at me"
07:44:40 <nak> yeah
07:44:42 <nak> ugh
07:44:45 <chpatrick> "I'd rather diagnose the bugs at runtime and write a ton of tests"
07:44:47 <nak> bring the types back
07:44:56 <nak> HEAPS TESTS
07:45:17 <nak> like seriously, i understand that testing is still important to some degree
07:45:33 <srhb> nak: Have you tried QuickCheck yet?
07:45:37 <nak> no
07:45:41 <nak> wazzat
07:45:42 <chpatrick> oh you're in for a treat
07:45:56 <srhb> Auto generating tests.. :-)
07:46:01 <srhb> From types.
07:46:07 <chpatrick> you can just state some property that you want to be true and it'll try to prove you wrong
07:46:08 <Iceland_jack> nak: QuickCheck makes testing fun
07:46:23 <nak> cool
07:46:27 <maerwald> Iceland_jack: as long as you have trivial input... otherwise you'll have to solve complex problems
07:46:30 <nshepperd> nak: seems to me, some of the really neat type stuff we use right now in haskell is still being worked out, and was in its infancy for a long time
07:46:40 <maerwald> which is a good thing...
07:46:40 <nak> once i am writing more than a couple types/functions in a single .hs file, i'll hit you guys up for QuickCheck
07:46:45 <nshepperd> the neat stuff is required to have certain kinds of polymorphism in a type safe way
07:46:49 <maerwald> but it isn't necessarily easy
07:47:11 <nshepperd> nak: dynamic languages let you do whatever polymorphism you like without restriction
07:47:18 <srhb> @check \n -> even n ==> odd (n+1)
07:47:22 <lambdabot>  +++ OK, passed 100 tests.
07:47:28 <ClaudiusMaximus> @check \a b c -> (a + b) + c == a + (b + c :: Double)
07:47:28 <srhb> @check \n -> even n ==> odd n
07:47:31 <Iceland_jack> maerwald: Non-trivial inputs are fine, 'suchThat' makes writing quick generators simple
07:47:31 <lambdabot>  *** Failed! Falsifiable (after 6 tests and 199 shrinks):
07:47:31 <lambdabot>  6.44437686666153 1.0366373883881457 3.9146812446893926
07:47:34 <srhb> magic.
07:47:35 <lambdabot>  *** Failed! Falsifiable (after 1 test):
07:47:35 <lambdabot>  0
07:48:17 <maerwald> Iceland_jack: have fun implementing random generators for geometric algorithms which need polygons with particular properties
07:48:19 <nak> srhb what on earth is ==>
07:48:42 <srhb> nak: Implication :)
07:49:11 <Iceland_jack> maerwald: For my compiler I wanted to generate a quick-n-dirty expression biased towards 0-valued expressions and I bruteforced it using "suchThat arbitrary (\e -> eval e == 0)" and just let it run for a while
07:49:17 <nak> see? still so much to learn
07:49:33 <exio4> nak: I'd prefer a dynamic typed language over a crappy not-expressive enough static typed language
07:49:42 <srhb> nak: Well it's a Quickcheck specific operator. It's just the sort of thing you find when you need it and start using a given library :)
07:49:42 <Iceland_jack> Then I rewrote it more efficiently once I was more confident
07:49:43 <exio4> nak: Scheme/Racket vs Java 
07:49:58 <nak> exio4 actually that's a good point, sorry
07:50:11 <nak> i overlooked those guys
07:50:37 <maerwald> Iceland_jack: yeah, I'm just saying that unit testing with complex input may be WAY easier... although not really "better"
07:50:42 <zomg> Anyone happen to know any articles/talks discussing Haskell usage in large-scale applications?
07:51:04 <srhb> zomg: r/haskell regularly has testimonials from varioous companies.
07:51:14 <zomg> Had an interesting discussion with someone the other day and he seemed to have the idea that Haskell-like languages would be difficult to use in large-scale systems... I personally don't have much experience except in smaller things
07:51:19 <zomg> srhb: ah cheers, will check it out
07:51:24 <nshepperd> yeah, you can write 'map' in scheme but not in java
07:52:04 <Iceland_jack> maerwald: That's right, sometimes you need very specialised inputs (an extreme example is standardised input vectors for cryptographic functions) which is why QuickCheck + HUnit covers most of my needs
07:52:20 <merijn> zomg: My experience is the opposite
07:52:22 <chpatrick> zomg: https://github.com/singpenguin/ppt/blob/master/Haskell%20in%20the%20Large.pdf
07:52:36 <merijn> zomg: It is MUCH easier to jump into big haskell projects than big projects in other languages
07:52:37 <chpatrick> although they made their own haskell :)
07:52:56 <merijn> zomg: No mutable state, no side-effects, types, it's far easier to find out what is doing what and where
07:53:22 <exio4> the expressive types do pretty much half the trick, they make refactoring deadly easy 
07:53:31 <merijn> zomg: Standard Chartered has about 1.5 million lines of haskell and 1 million lines of Mu (their internal strict haskell implementation)
07:53:38 <zomg> merijn: yeah, although my experience with haskell is limited to smaller hobby projects, going into large projects in other languages certainly makes me think "oh Haskell would make this easier" =)
07:54:02 <Iceland_jack> maerwald: (I know you used the polygons as an example, but my advisor's doctoral thesis was about generating random values that satisfy certain properties: e.g. generating random program AST uniformly)
07:54:07 <merijn> zomg: And according to the blogposts I saw much of facebook's spam detection querying is now in haskell too, so clearly it scales up to pretty big sizes :)
07:54:13 <nshepperd> haskell projects seem to have less wrappers of wrappers of wrappers that don't do anything
07:54:26 <zomg> chpatrick: nice, that looks interesting as well
07:54:38 <nshepperd> which was always the main thing that impeded my understanding of big software projects
07:55:01 <merijn> nshepperd: All of which hiding mutation so you never know what gets updated from where ;)
07:55:15 <maerwald> Iceland_jack: I was actually considering to write my thesis about randomly generating polygons with special properties, but I'm not sure about that yet
07:55:43 <exio4> nshepperd: well, there are a few things like in Haskell, they just reduce complexity instead of adding more hidding state
07:56:07 <Iceland_jack> maerwald: There you go http://dblp.uni-trier.de/pers/hd/p/Palka:Michal_H=
07:56:18 <exio4> nshepperd: ie. being polymorphic over a typeclass, parametric polymorphism, free structures 
07:56:34 <Iceland_jack> "Making Random Judgments", "Generating Constrained Random Data with Uniform Distribution", "Testing an optimising compiler by generating random lambda terms" 
07:57:16 <maerwald> Iceland_jack: I'll have a look, thanks
07:59:20 <nshepperd> typeclasses tend to be meaningful at least
08:23:57 <mietek> Yuras: are you the author of pdf-toolbox-*?
08:25:27 <hodapp> https://lukepalmer.wordpress.com/2008/04/08/stop-using-undecidable-instances/ reading this and trying to see the value of wrapping a type in a newtype there... In his example, if there is anything that is a Group but not a Num, then what is the value of a typeclass? One still has to specially construct things based on type.
08:27:20 <Yuras> mietek: right
08:27:34 <mietek> Yuras: cool. Thanks for the good work!
08:28:02 <Yuras> mietek: thank you :) though the API is terrible
08:28:43 <mietek> Yuras: I’d like to automate extraction of things like bibliography/references from papers; so — reasonably well-structured text. Do you have an example of doing something like that?
08:29:25 <Yuras> mietek: I don't think it is possible in general case
08:29:43 <Yuras> pdf page content is not structured internally
08:30:11 <Yuras> some fuzzy logic will be necessary I think
08:30:32 <mietek> Yuras: certainly. I mean, if you look at the content as text, it’s still reasonably structured — there’s usually a section heading, and stuff after it.
08:31:13 <mietek> Yuras: but then you sometimes get two-column papers, and the reference numbers sometimes get out of sync with the reference text...
08:31:23 <mietek> Yuras: so yes, it’s definitely going to be fuzzy.
08:31:35 <mietek> Yuras: still, even a simple example showing how to get text out would help me.
08:31:53 <Yuras> mietek: btw you can get exact glyph positions
08:32:51 <Yuras> mietek: does this function work for you? https://hackage.haskell.org/package/pdf-toolbox-document-0.0.5.1/docs/Pdf-Toolbox-Document-Page.html#v:pageExtractText
08:33:32 <geekosaur> hodapp, the problem is that Num g => Group g is a wildcard
08:33:42 <geekosaur> it is exactly the same as: instance Group g
08:33:44 <mietek> Yuras: perhaps... how do you iterate through a document’s pages?
08:33:53 <geekosaur> as far as instance selection is concerned
08:34:13 <geekosaur> so it makes *every* type a Group
08:34:22 <Yuras> mietek: there is an example in module docs: https://hackage.haskell.org/package/pdf-toolbox-document-0.0.5.1/docs/Pdf-Toolbox-Document.html
08:35:08 <Yuras> mietek: basically: you can use pageNodePageByNum from Pdf.Toolbox.Document.PageNode
08:35:24 <geekosaur> "instance MNum g => Group g" means, specifically: every type is a Group. but *after* you have selected that instance, check to see if the type has a Num instance
08:35:52 <mietek> Yuras: call that on the rootNode?
08:35:59 <Yuras> yes
08:36:08 <hodapp> I'm not asking about "instance Num g => Group g"
08:36:09 <mietek> Yuras: all right, thanks. I’ll start with that.
08:36:29 <mietek> Yuras: BTW, maybe you want to check out #haskell-deployment
08:38:20 <geekosaur> no, you're asking what the point of the newtype wrapper is. the point of it is that you cannot safely use the instance I was talking about, without the wrapper
08:38:24 <geekosaur> the wrapper makes it safe to use
08:38:53 <geekosaur> specifically, because you can ensure that nothing else defines a Group instance for your newtype
08:42:22 <meoblast001> i'm trying to do deriveSafeCopy on a (HashMap PrimaryKey Category), but i can't seem to figure out the syntax... i need something like deriveSafeCopy 0 'base ''(HashMap PrimaryKey Category), but this syntax doesn't work
08:46:34 <hodapp> geekosaur: what I'm asking about is the usefulness of that if it happens that you have *other* instances of Group that are not in Num, as then you must selectively wrap things in particular newtypes based on their type.
08:46:52 <srhb> meoblast001: Isn't it just deriveSafeCopy 0 'base ''HashMap ?
08:47:01 <meoblast001> doesn't seem to go
08:47:06 <geekosaur> the only ones that need to be wrapped are the ones that rely on a superclass to select the right instance
08:47:07 <srhb> meoblast001: And then similar instances for PrimaryKey and Category
08:47:15 <meoblast001> from what i'm reading now, this seems to be the limit of deriveSafeCopy
08:47:16 <geekosaur> because that *doesn't work*
08:47:36 <srhb> meoblast001: What's the error?
08:48:02 <geekosaur> and they turn into wildcards that match every possible type, and thereby confuse instance selection massively
08:48:16 <meoblast001> Can't derive SafeCopy instance for: (Data.HashMap.HashMap,TyConI (TySynD Data.HashMap.HashMap [PlainTV k_1627432052,PlainTV v_1627432053] (AppT (AppT (ConT Data.HashMap.Map) (VarT k_1627432052)) (VarT v_1627432053))))
08:48:21 <meoblast001> yeah. have fun with that one
08:48:56 * hackagebot c-storable-deriving 0.1.2 - Generate C-like storable instances from datatypes  http://hackage.haskell.org/package/c-storable-deriving-0.1.2 (MatthewMaurer)
08:49:00 <srhb> meoblast001: Was that for the version I suggested?
08:49:06 <meoblast001> yup
08:49:15 <meoblast001> hmmm
08:49:21 <meoblast001> i may have something here
08:49:34 <meoblast001> manually making HashMap an instance of SafeCopy seems to do the trick
08:49:56 <srhb> Sure.
08:50:57 <haskell098> How can I get flyspell to work on .lhs file in Emacs?
08:51:47 <hodapp> geekosaur: Yes, that seems to be what I'm saying: that you must wrap based on what superclass they rely on, if there is one.
08:52:45 <geekosaur> yes, and only if there is one and only if there are also instances that don't require it, because the one that does has the potential to break those other instances completely
08:57:34 <hodapp> hmm, I see that that still has some value, despite requiring some additional indirection versus the undecidable case
09:07:28 <maerwald> I'm looking for a "Haskell vs java" or similar comparison with code snippets... afair there was something on haskell wiki, but I'm unable to find it
09:07:37 <maerwald> to see the difference in expressiveness
09:08:06 <whiteline> it's a completely different language
09:08:12 <maerwald> really? 
09:08:14 <maerwald> :D
09:09:12 <osa1> is there a way to recursively ghc-pkg unregister a package and all the packages that depend on it?
09:09:59 <vitalij> can somebody help me to install yesod via cabal? I am having a lot of problems
09:13:57 * hackagebot reducers 3.10.3.2 - Semigroups, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/reducers-3.10.3.2 (EricMertens)
09:20:11 <vitalij> i have this message: http://pastebin.com/1WGaCmZh
09:20:34 <chpatrick> is reducers just kmett-monotraversable?
09:20:34 <simon> I'm trying to install some haskell libraries that complain that I've got base-4.6.* since they require >=4.7. how do I update base, and should I do that strictly within a sandbox?
09:21:08 <srhb> simon: YOu should not.
09:21:15 <srhb> simon: You update your entire GHC if you want a newer base.
09:22:07 <srhb> (And hi)
09:22:15 <SrPx> What is the conventional name for this? foo x list = init (foldr (\h t -> (h : (x : t))) [] list)
09:22:46 <SrPx> > ((x list -> init (foldr (\h t -> (h : (x : t))) [] list) "," ["aa","bb","cc"])
09:22:48 <lambdabot>  <hint>:1:79:
09:22:49 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
09:23:04 <srhb> :t \x list -> init (foldr (\h t -> (h : (x : t))) [] list)
09:23:05 <lambdabot> Foldable t => a -> t a -> [a]
09:23:08 <glguy> > intercalate ", " ["aa","bb","cc"]
09:23:09 <simon> hi srhb :)
09:23:11 <lambdabot>  "aa, bb, cc"
09:23:35 <glguy> > intersperse ',' "xyz"
09:23:39 <lambdabot>  "x,y,z"
09:24:11 <SrPx> Ah, cool. Thank you :)
09:25:30 <albeit> I have a deeply nested sequence like "if cond; then a; else if cond2 then a2; else if cond3....". How can I minimize that?
09:25:48 <athan> Hey guys, can anyone reccomend a simplex implementation in Haskell?
09:26:01 <glguy> albeit: You could define a name for that value and use guard, or use the MultiWayIf extension
09:26:14 <albeit> glguy: Ah forgot about MultiWayIf, perfect thanks
09:26:15 <glguy> or use: case () of _ | guard1 -> _ | guard2 -> _
09:28:12 <SlowBait> Hi, I have a big file of integers, and I want to output the sum of all of them. All my attempts so far have caused the whole file to be loaded in memory, which makes my program crash
09:29:34 <SlowBait> can you please help me with it?
09:29:55 <glguy> SlowBait: Paste what you've tried so far to http://lpaste.net/new/haskell
09:30:44 <magneticDuck> glguy: I assume he's just tried fmap (sum . map read . unlines) (readFile "file")
09:30:50 <glguy> magneticDuck: OK
09:33:31 <athan> SlowBait: foldr1 (+) ints ?
09:33:51 <magneticDuck> athan: that's just another way to write sum
09:34:01 <magneticDuck> I assume he's looking for a way that doesn't load the file into memory
09:34:06 <athan> magneticDuck: But... something something coinductive?
09:34:14 <athan> hmm
09:34:18 <magneticDuck> presumably because the file is *huge* and he has *very little* RAM and no swap
09:34:21 <SlowBait> magneticDuck: Yeah
09:34:28 <magneticDuck> I'd suggest he just partition it up
09:34:28 <athan> ahh shoot
09:34:37 <athan> well, isn't readfile lazy?
09:34:43 <magneticDuck> it is
09:34:50 <magneticDuck> tbh I'm a bit confused about this all
09:35:06 * athan shrugs
09:35:21 <magneticDuck> the last I checked, haskell's default file steams are mostly magic
09:35:47 <indiagreen> isn't “sum” bad / stackoverflowy / not implemented with foldl'?
09:36:02 <srhb> Nah, sum is fine.
09:36:11 <srhb> It's the report version that's bork. GHC implements it right.
09:36:55 <jackhill> :t foldl'
09:36:58 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
09:39:07 <nak> just saw this on stackoverflow: http://stackoverflow.com/questions/30712323/convert-loop-to-maybe-monad
09:39:11 <nak> that pain..
09:39:30 <ania12> hi, maybe it is wrong chanell but I will ask, I saved a text document written with unicode shrift, probable I did not pointed to save in unicode format and now all texts are full of ?????
09:39:33 <ania12> is there way to recove my text?
09:39:37 <quchen> Grrr GHC misbehaves when cloning from Github again, claiming a missing "libffi-tarballs" repo. Google suggests only things that have been fixed months ago. :-/
09:39:53 <srhb> ania12: Yep, wrong channel.
09:40:30 <quchen> Does anyone have a recent tip on how to resolve that issue? I've set the paths properly as mentioned by https://ghc.haskell.org/trac/ghc/wiki/Building/GettingTheSources
09:42:31 <indiagreen> magneticDuck, SlowBait: it works in constant space with -O2
09:43:23 <indiagreen> (probably would be fine with -O too)
09:44:07 <magneticDuck> ohk
09:44:14 <nak> @src tails1
09:44:15 <lambdabot> Source not found. Sorry.
09:45:22 <SlowBait> indiagreen: thanks, I'll try it :)
09:48:58 * hackagebot vcache 0.2.6 - semi-transparent persistence for Haskell using LMDB, STM  http://hackage.haskell.org/package/vcache-0.2.6 (dmbarbour)
09:49:46 <haskell371> I am having problems with installing haskell-mode on emacs
09:50:21 <mfng> hello
09:50:52 <mfng> is there any way to turn a part of string into comment inside double quote? 
09:51:18 <mfng> so that it is omitted when printing
09:51:29 <srhb> mfng: No.
09:51:39 <dolio> You mean you want to comment something in the middle of the string?
09:51:47 <mfng> yes
09:52:13 <mfng> just to leave out some string inside a string
09:52:41 <mfng> without deleting it
09:52:54 <srhb> mfng: Split the string, have a comment somewhere in the concatenation.
09:53:16 <mfng> oh thanks srhb
09:53:33 <haskell371> Can anyone help me with installing haskell-mode on emacs?
09:53:48 <nak> @src mconcat
09:53:48 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
09:53:53 <srhb> haskell371: Maybe if you tell us the problem. :) And there's also #haskell-emacs
09:54:03 <srhb> nak: lambdabots source database is quite limited (and may not reflect the actual source)
09:54:11 <dolio> Man, missed opportunity.
09:54:16 <srhb> :t mconcat
09:54:27 <lambdabot> Monoid a => [a] -> a
09:54:28 <dolio> "asdf\ {- comment -} \jkl;" doesn't work.
09:54:54 <haskell371> I'm thinking how to describe my problem. I'm really stupid.
09:54:59 <srhb> dolio: \j ? :P
09:55:27 <dolio> > "asdf\                      \jkl;"
09:55:34 <lambdabot>  mueval: ExitFailure 1
09:55:56 <dolio> > "asdf\                      \jkl;"
09:55:58 <srhb> Ah, I get it.
09:56:00 <lambdabot>  "asdfjkl;"
09:56:05 <haskell371> I'm at the *Customize Option: Package Archives* buffer.
09:56:15 <haskell371> I entered the archive name and URL.
09:56:25 <dolio> The whitespace you can put in there doesn't include comments, though.
09:56:31 <nak> > [1,2,3] >>= \x -> "ab" >>= \y -> return (x,y)
09:56:37 <lambdabot>  mueval-core: Time limit exceeded
09:56:41 <nak> YES
09:56:42 <haskell371> When I do M-x package-install RET haskell-mode
09:56:42 <nak> lol
09:56:43 <srhb> haskell371: Are you following the installation guide?
09:56:46 <haskell371> Yes
09:56:56 <haskell371> It tells me that there's no match
09:57:19 <srhb> haskell371: When does it tell you that?
09:57:28 <nak> srhb how did i fail there ?
09:57:38 <nak> > do x <- [1,2,3]; y <- "ab"; return (x,y)
09:57:40 <srhb> nak: You didn't.
09:57:42 <lambdabot>  [(1,'a'),(1,'b'),(2,'a'),(2,'b'),(3,'a'),(3,'b')]
09:57:48 <haskell371> After I've done M-x package-refresh-contents and M-x package-install RET haskell-mode
09:57:51 <nak> why does my >>= version not work ?
09:57:56 <srhb> > [1,2,3] >>= \x -> "ab" >>= \y -> return (x,y)    -- it does
09:57:59 <lambdabot>  [(1,'a'),(1,'b'),(2,'a'),(2,'b'),(3,'a'),(3,'b')]
09:58:02 <srhb> nak: lambdabot is feeling tired and old.
09:58:05 <nak> oh
09:58:07 <srhb> nak: Random timeout :)
09:58:12 <nak> ok i am trying to understand how this works tho
09:58:22 <athan> Why isn't there a simplex implementation in Haskell?
09:58:34 <srhb> haskell371: Did you manage to add the melpa repo?
09:58:50 <srhb> haskell371: Did you remember to reload the configuration after adding it?
09:58:58 <nak> @src concatMap
09:58:58 * hackagebot hedis 0.6.6 - Client library for the Redis datastore: supports full command set,  pipelining.  http://hackage.haskell.org/package/hedis-0.6.6 (FalkoPeters)
09:58:59 <lambdabot> concatMap f = foldr ((++) . f) []
09:59:26 <ReinH> Athas: simplex?
10:00:11 <haskell371> srhb: It worked! Thanks!
10:00:33 <haskell371> srhb: I forgot to reload the configuration.
10:00:39 <srhb> haskell371: :)
10:00:53 <athan> ReinH: The simplex method - used in linear programming a bunch
10:00:57 <srhb> nak: So what's the issue? :)
10:01:07 <athan> ReinH: It seems grammatical enough :S
10:01:37 <athan> hmatrix-glpk just relies on glpk's implementation ._.
10:01:39 <ReinH> athan: well, there are also simplicial categories :p
10:02:20 <athan> ReinH: hrmmmm
10:02:24 <sebastian_> Hi all. I'm struggeling with the order of my monad transformer stack, because I have two conflicting requirements: 1. The base monad needs to be a continuation monad, because I cannot store anything on the stack. 2. I would like to implement exceptions (for example with Maybe
10:02:38 <athan> down the ncatlab rabbit hole I go
10:02:42 <nak> srhb ugh sec. i keep getting interrupted
10:02:49 <athan> er, cat hole? o_O
10:03:07 <ReinH> athan: http://hackage.haskell.org/package/hmatrix-glpk-0.4.1.0/docs/Numeric-LinearProgramming.html
10:03:12 <srhb> sebastian_: Your message might have gotten truncated.
10:03:29 <ReinH> And yes, glpk's is pretty good, so why replace it?
10:03:50 <sebastian_> so basically, ContT Maybe does not work and MaybeT Cont does not work
10:04:06 <athan> ReinH: I'm trying to make a pure, standalone implementation
10:04:19 <sebastian_> what can I do?
10:04:19 <ReinH> athan: ok, do that then :p
10:04:34 <athan> ReinH: 'E'
10:04:52 <Haskellfant> how can I combine two uniform vinyl records using a function? to be more specific, I have two records of the same type containing only doubles and I want to add their values
10:06:03 <Haskellfant> mapMethod from acowleys Frames package allows me to map the same method over each record field, but that doesn't cut it if I want to combine two records
10:08:13 <haskell617> Is indentation important in Haskell?
10:08:17 <Athas> Yes.
10:08:35 <Athas> It is syntactically significant unless you explicitly use braces and semicolons.
10:09:21 <haskell617> Is it considered an error if I mix tabs and spaces?
10:09:39 <Clint> depends how you mix them
10:09:41 <chardan> haskell617: Just amoral. ;-)
10:09:54 <srhb> haskell617: It is considered an error to use tabs at all, more or less.
10:09:59 <srhb> But mixing them is asking for trouble indeed.
10:10:11 <haskell617> Thanks for telling me.
10:10:25 <glguy> haskell617: The current version of GHC issues a warning if you use tabs in a Haskell source file. If you're going to use them you must ensure your editor is configured with 8-column tab stops
10:10:49 <srhb> glguy: Too late!
10:11:13 <srhb> Drive-by haskell questions... :P
10:12:22 <nak> :t concatMap
10:12:26 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
10:12:43 <nak> can someone show me an example of using this function ?
10:12:56 <magneticDuck> > concatMap show [1..10]
10:12:59 <lambdabot>  "12345678910"
10:13:29 <sebastian_> @src callCC
10:13:32 <lambdabot> Source not found. I feel much better now.
10:13:44 <nak> magneticDuck can concatMap be used to create a product of two lists ?
10:13:56 <Iceland_jack> nak: You'd use zipWith (,) for that
10:14:10 <Iceland_jack> > zipWith (,) [1,2,3] "hey"
10:14:15 <lambdabot>  [(1,'h'),(2,'e'),(3,'y')]
10:14:19 <nak> no no
10:14:22 <nak> a *product*
10:14:37 <nak> 1h 2h 3h 1e 2e 3e 1y 2y 3y
10:14:38 <magneticDuck> oh I see what you mean
10:14:45 <Iceland_jack> > liftA2 (,) [1,2,3] "hey"
10:14:51 <lambdabot>  [
10:14:54 <maerwald> > zip [1,2,3] "hey"
10:15:02 <lambdabot>  mueval-core: Time limit exceeded
10:15:30 <dmj`> > [ (x,y) | x <- [1..2], y <- ['a'..'b'] ]
10:15:35 <lambdabot>  mueval-core: Time limit exceeded
10:15:46 <nak> dmj` is it possible with concatMap 
10:15:57 <magneticDuck> > map (\x -> map (\y -> (y, x)) [1..5]) [1..5]
10:16:01 <lambdabot>  [[(1,1),(2,1),(3,1),(4,1),(5,1)],[(1,2),(2,2),(3,2),(4,2),(5,2)],[(1,3),(2,3...
10:16:01 <Welkin> > sequence [1,2,3] "hey
10:16:03 <Welkin> > sequence [1,2,3] "hey"
10:16:06 <lambdabot>  <no location info>: can't find file: L.hs
10:16:06 <lambdabot>  <hint>:1:22:
10:16:06 <lambdabot>      lexical error in string/character literal at end of input
10:16:12 <magneticDuck> nak: I assume that's what you mean
10:16:14 <arbelos> style question: "a^.b" or "a ^. b"?
10:16:15 <Welkin> > sequence [[1,2,3],"hey"]
10:16:18 <lambdabot>      No instance for (Num Char) arising from the literal ‘1’
10:16:18 <lambdabot>      In the expression: 1
10:16:18 <lambdabot>      In the expression: [1, 2, 3]
10:16:20 <ronh-> > liftA2 (,) [1,2,3] "hey"
10:16:23 <lambdabot>  [(1,'h'),(1,'e'),(1,'y'),(2,'h'),(2,'e'),(2,'y'),(3,'h'),(3,'e'),(3,'y')]
10:16:37 <Welkin> > sequence [map show [1,2,3],"hey"]
10:16:41 <lambdabot>      Couldn't match type ‘Char’ with ‘[Char]’
10:16:41 <lambdabot>      Expected type: [String]
10:16:41 <lambdabot>        Actual type: [Char]
10:17:09 <Welkin> > sequence [concat $ map show [1,2,3],"hey"]
10:17:13 <lambdabot>  ["1h","1e","1y","2h","2e","2y","3h","3e","3y"]
10:17:30 <nak> > concatMap (\x -> [x]) [1,2,3]
10:17:36 <lambdabot>  [1,2,3]
10:17:46 <nak> > concatMap (\x -> [[x]]) [1,2,3]
10:17:52 <lambdabot>  [[1],[2],[3]]
10:17:55 <nak> ah ok
10:18:37 <srhb> Does exactly what it says on the tin. :-)
10:18:41 <Iceland_jack> nak: (=<<) is also the same as concatMap
10:18:41 <Iceland_jack> > unwords (sequence [show =<< [1,2,3], "hey"])
10:18:44 <lambdabot>  "1h 1e 1y 2h 2e 2y 3h 3e 3y"
10:21:24 <nak> srhb yeah i'm just not super at reading the type signatures yet
10:21:34 <srhb> nak: I meant the name though. But sure. :)
10:21:48 <Iceland_jack> nak: The type signature of concatMap is more general (read: trickier) than it used to be
10:22:02 <Iceland_jack> :t concatMap
10:22:03 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
10:22:04 <Iceland_jack> :t concatMap :: (a -> [b]) -> [a] -> [b]
10:22:05 <lambdabot> (a -> [b]) -> [a] -> [b]
10:22:07 <dmj`> (=<<) = flip concatMap = \f xs -> flip $ concat (mapM f xs) = \f xs -> flip $ concat (sequence (map f xs))
10:22:15 <dmj`> nak: it's possible, but ugly
10:22:15 <lamefun> Is there a safe number library for Haskell?
10:22:26 <subleq> what's a safe number?
10:22:42 <meoblast001> what does "##" in haskell mean?
10:22:44 <lamefun> (ie. numbers that are bounded, but error on overflow instead of going back to lower bound
10:22:52 <Iceland_jack> dmj`: That should be (>>=) no?
10:22:53 <magneticDuck> meoblast001: two waffles
10:22:57 <meoblast001> lol
10:22:58 <geekosaur> in what context?
10:23:06 <Iceland_jack> meoblast001: Did you see that as a suffix
10:23:06 <geekosaur> it's a valid user defined operator
10:23:12 <taruti> Was there a straight function from utf8 lazy bytestrings to strict data.text? or via either strict bytestrings or lazy text?
10:23:15 <magneticDuck> -- :D##
10:23:22 <magneticDuck> is sometimes a comment devs leave when eating breakfast
10:23:25 <meoblast001> i see it in a heist splice
10:23:29 <geekosaur> it *may* occur as a suffix when the MagicHash extension is enabled, which would make it an internal constructor type for ghc
10:23:38 <meoblast001> "name" ## qc ^. name . to I.textSplice
10:24:47 <dmj`> :t flip concatMap
10:24:49 <lambdabot> Foldable t => t a -> (a -> [b]) -> [b]
10:24:51 <dmj`> :t (>>=)
10:24:52 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:24:57 <dmj`> Iceland_jack: ah yes
10:25:31 <lamefun> or maybe a set of non-overflowing number operators?
10:27:35 <nak> being called out
10:27:38 <dmj`> nak: to calculate a sum with (>>=) you'd have to take advantage of the fact liftM2 is defined as liftM2 f m1 m2 = m1 >>= \x -> m2 >>= \y -> return (f x y), and use that defintion explicitly 
10:27:39 <nak> bbl sorry guys
10:27:59 <geekosaur> meoblast001, http://hackage.haskell.org/package/map-syntax-0.2/docs/Data-Map-Syntax.html#v:-35--35-
10:28:08 <nak> dmj` thank you, that might be what i'm looking for exactly
10:28:10 <nak> bbs
10:28:11 <dmj`> > liftM2 (,) [1..2] ['a'..'b']
10:28:12 <meoblast001> thanks :)
10:28:15 <lambdabot>  [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
10:28:18 <dmj`> nak: thank Iceland_jack
10:32:41 <quchen> When "cabal install"ing with multiple threads, the program won't print any warnings. Is there any way to enable library warnings in this scenario?
10:33:14 <quchen> The specific use case is buildling huge things and counting how many times a certain warning arises
10:33:24 <hexagoxel> cat all the logs? :p
10:33:35 <quchen> Oh, it still stores the build logs?
10:33:39 <quchen> That would do the trick
10:33:51 <quchen> Gogo zsh ** magic
10:40:11 <voidzero> heh
10:40:22 <voidzero> yes, zsh is just fantastic
10:41:07 <saml> why do you say that
10:44:21 <voidzero> because of the features it offers
10:44:47 <mitchty> zsh sold me years ago on multiline history editing, took a while for bash to get that
10:45:03 <voidzero> try `man zshall` if you are interested, or search for zsh-lovers - it's a bit off topic for here i guess
10:59:01 * hackagebot snaplet-auth-acid 0.1.0 - Provides an Acid-State backend for the Auth Snaplet  http://hackage.haskell.org/package/snaplet-auth-acid-0.1.0 (DavidJohnson)
10:59:09 <lamefun> > (maxBound :: Int) + 1
10:59:11 <lambdabot>  -9223372036854775808
10:59:28 <lamefun> ...
10:59:36 <lamefun> Isn't Haskell supposed to be a safe language?
10:59:51 <jle`> it's safe, it's defined that way in the specs for Int
11:00:00 <jle`> Int isn't supposed to represent arbitrary precision integers
11:00:02 <jle`> Integer is :)
11:00:19 <orion> > (maxBound :: Integer) + 1
11:00:24 <lambdabot>  mueval-core: Time limit exceeded
11:01:15 <jle`> > (maxBound :: Integer) + 1
11:01:20 <lambdabot>      No instance for (Bounded Integer) arising from a use of ‘maxBound’
11:01:20 <lambdabot>      In the first argument of ‘(+)’, namely ‘(maxBound :: Integer)’
11:01:20 <lambdabot>      In the expression: (maxBound :: Integer) + 1
11:01:35 <jle`> > fromInteger maxBound + 1
11:01:39 <lambdabot>      Could not deduce (Bounded Integer) arising from a use of ‘maxBound’
11:01:40 <lambdabot>      from the context (Num a)
11:01:40 <lambdabot>        bound by the inferred type of it :: Num a => a at Top level
11:01:43 <jle`> > fromInteger maxBound + 1 :: Integer
11:01:46 <lambdabot>      No instance for (Bounded Integer) arising from a use of ‘maxBound’
11:01:46 <lambdabot>      In the first argument of ‘fromInteger’, namely ‘maxBound’
11:01:46 <lambdabot>      In the first argument of ‘(+)’, namely ‘fromInteger maxBound’
11:01:57 <jle`> oh
11:02:09 <jle`> > fromIntegral (maxBound :: Int) + 1 :: Integer    -- sorry
11:02:13 <lambdabot>  9223372036854775808
11:02:31 <orion> jle`: Why did lambdabot error out when I did it?
11:02:38 <jle`> probably an I/O error
11:02:43 <jle`> it happens from time to time
11:02:55 <jle`> on the filesystem on lambdabot's server
11:02:57 <lamefun> but Data.Set, Map, etc. return Ints all the time...
11:03:52 <jle`> yeah, usually because all reasonable situations where you would use those functions, Int is fine
11:04:31 <c_wraith> Data.Set and Data.Map won't fit in memory with maxBound elements in them, for instance
11:06:22 <voidzero> safe in what way? 
11:06:32 <voidzero> like, not having buffer overflows?
11:07:34 <jle`> preventing potential logic errors with a strong type system, perhaps
11:08:44 <lamefun> c_wraith, I know, but it kinda undermines that Haskell's promise of safety in my eyes... relying on that maxBound :: Int won't fit in memory that is...
11:08:47 <voidzero> i dunno if that is "supposed to be" provided by haskell
11:09:08 <jle`> > product [1..30] :: Int
11:09:13 <lambdabot>  -8764578968847253504
11:09:17 <voidzero> maxBound :: Integer
11:09:18 <jle`> voidzero: it's one of the selling points of haskell, i think...
11:09:24 <voidzero> > maxBound :: Integer
11:09:27 <lambdabot>      No instance for (Bounded Integer) arising from a use of ‘maxBound’
11:09:27 <lambdabot>      In the expression: maxBound :: Integer
11:09:27 <jle`> and one of the big advantages of it
11:09:47 <voidzero> I guess my problem is with the "supposed to"
11:10:19 <c_wraith> lamefun: what's unsafe?  The implementation guarantees it will never be big enough that the size doesn't fit in an Int
11:10:22 <jle`> lamefun: well, you might not be able to calculate one trillian factorial
11:10:32 <jle`> lamefun: with Integer...because the universe might die first
11:10:35 <voidzero> maybe the programmer is supposed to be informed of the differences between Integer
11:10:37 <voidzero> and Int
11:11:09 <jle`> yeah, i just consider Int to be a different type than Integer...it's just an issue of not using the wrong type to represent something
11:11:18 <jle`> i could also represent natural numbers as lists of ()'s
11:11:26 <jle`> but that's kind of silly...and the wrong usage of lists
11:11:33 <c_wraith> I prefer Fix Maybe.  :P
11:11:45 <jle`> or i could represent natural numbers as strings with their english representation
11:11:57 <jle`> but that's kind of silly too
11:12:06 <jle`> use the write data type for the data you're representing :)
11:12:13 * ski . o O ( Aztec numerals )
11:12:15 <jle`> c_wraith: :)
11:12:46 <voidzero> mayan numerals
11:12:53 <voidzero> base20
11:13:30 <voidzero> with symbols where a dot is one and a dash is five and you can have a maximum of 3 dashes and 4 dots
11:13:41 <voidzero> ideal for the really huge numbers
11:14:28 <jle`> s/write/right
11:14:30 <jle`> lol
11:14:32 <magneticDuck> nah, more digits just increases the numbers you can represent in polynomial order
11:14:42 <magneticDuck> let's just all use hyper-operator notation
11:15:06 <magneticDuck> or arrow notation, or whatever the kids are calling it
11:16:19 <voidzero> they don't call it yet, they're being lazy
11:21:54 <lamefun> c_wraith, why does Apple Swift default to checked-overflow integers then? So does Rust, I think...
11:22:14 <c_wraith> lamefun: that's a totally different question.
11:22:58 <lamefun> why?
11:23:26 <c_wraith> lamefun: because Integer isn't checked-overflow either
11:24:24 <marcusmonteiro> Good afternoon guys
11:24:40 <lamefun> c_wraith, can it overflow at all if there's still enough memory left?
11:25:06 <c_wraith> lamefun: technically yes, but you'd something like 2^(2^48) bytes of memory
11:26:02 <c_wraith> I'm not sure there are that many atoms in the visible universe.
11:27:15 <lamefun> It's out-of-memory error/crash, not "it magically becomes (minBound :: Integer)".
11:27:44 <marcusmonteiro> I've been browsing the ghc/compiler/utils/Binary.hs from the ghc source code. There, they define a newtype Bin as newtype Bin = BinPtr Int deriving (Eq, Ord, Show, Bounded)
11:28:22 <marcusmonteiro> I googled, hoogled and searched github for BinPtr, but I didn't find it
11:28:25 <marcusmonteiro> Does anyone know what BinPtr is?
11:28:47 <marcusmonteiro> Or where I can find it?
11:28:52 <c_wraith> according to the line you just quoted, it's a constructor for Bin, wrapping an Int
11:28:56 <fishythefish> It's part of the newtype declaration.
11:29:05 <fishythefish> You use it as a data constructor.
11:29:24 <Iceland_jack> marcusmonteiro: Are you sure it doesn't have a phantom parameter
11:29:47 <Iceland_jack> The declaration here http://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc/src/Binary.html is
11:29:47 <Iceland_jack>     newtype Bin a = BinPtr Int ...
11:29:53 <Iceland_jack> (note the 'a')
11:30:25 <Azel> lamefun: Isn't that just modular arithmetic? Not a weird behaviour for a limited-precision integer I think.
11:30:38 <c_wraith> lamefun: I think you're still somewhat missing the point.  Haskell's default Integral data type is Integer.  Int is for special cases
11:30:54 <marcusmonteiro> @Iceland_jack yes, that's the file
11:30:55 <lambdabot> Unknown command, try @list
11:31:31 <marcusmonteiro> What's a phantom parameter?
11:31:45 <fishythefish> marcusmonteiro, "newtype Bin a = BinPtr Int"
11:31:49 <fishythefish> Note that 'a' is not used on the RHS
11:31:51 <mauke> marcusmonteiro: a type parameter that is not used
11:32:04 <fishythefish> marcusmonteiro, see https://wiki.haskell.org/Phantom_type
11:32:41 <Iceland_jack> marcusmonteiro: Here 'a', 'b' and 'd' are all "phantom parameters", only 'c' is actually used on the RHS (right-hand side)
11:32:41 <Iceland_jack>     data Foo a b c d = MkFoo (c, Int) 
11:32:45 <marcusmonteiro> Noob IRC user question: how do I respond to a specific user?
11:32:57 <Iceland_jack> marcusmonteiro: You type their nick followed by a colon (:)
11:33:11 <fishythefish> Or comma or whatever. Many IRC clients will tab-complete names as well.
11:33:13 <marcusmonteiro> :Iceland_jack Thanks
11:33:17 <zq> lul
11:33:21 <Iceland_jack> :)
11:33:23 <fishythefish> :P
11:33:27 <lamefun> c_wraith, then why do eg. Set.size return Int not Integer?
11:33:40 <zq> marcusmonteiro: very punny, you have a future in pl research
11:33:56 <marcusmonteiro> Thank you guys, you're awesome, I'll get back to study
11:34:09 <c_wraith> lamefun: micro-optimization.  It's guaranteed to not overflow for that use case, and it's moderately faster because of it.
11:34:15 <Iceland_jack> > (:){{-=   =-}}
11:34:18 <lambdabot>  [*Exception: <interactive>:3:1-14: Missing field in record construction
11:34:42 <fishythefish> Iceland_jack, we should probably mention that the phantom type and his original question are two separate issues.
11:34:48 <marcusmonteiro> I'll read that https://wiki.haskell.org/Phantom_type stuff
11:34:51 <Iceland_jack> fishythefish: yes
11:35:08 <fishythefish> marcusmonteiro, don't worry too much about the phantom type stuff if you're just looking for BinPtr
11:35:09 <Iceland_jack> marcusmonteiro: The phantom type was just something I noticed while reading the source
11:35:15 <fishythefish> That's just how newtype works.
11:35:15 <marcusmonteiro> :zq just starting :D
11:35:28 <fishythefish> BinPtr is a data constructor for the new type.
11:35:50 <mauke> marcusmonteiro: I'm pretty sure the web client has tab completion
11:35:51 <Iceland_jack> marcusmonteiro: The colon should follow the nick, so you'd write 'zq: ...' rather than ':zq ...'
11:35:56 <lamefun> c_wraith, guaranteed where?
11:35:59 <marcusmonteiro> :mauke what is a CTCP VERSION?
11:35:59 <Azel> Forget what I just said, I forgot that 2-complement integers went from -2^n to (2^n - 1)...it's wrap-around arithmetic rather. More annoying to define but it does match the behaviour of machine language-level integers...most of the time.
11:36:07 <mauke> marcusmonteiro: dude, stop it
11:36:27 <marcusmonteiro> Iceland_jack: Oh, ok
11:37:05 <fishythefish> mauke: http://en.wikipedia.org/wiki/Client-to-client_protocol#VERSION
11:37:17 <fishythefish> Whoops.
11:37:19 <mauke> marcusmonteiro: try Ic<tab>
11:37:20 <fishythefish> marcusmonteiro, see above.
11:37:25 <mauke> it should complete the nick
11:37:51 <c_wraith> lamefun: containers is a low-level package.  It has a lot of optimizations in it that depend on how ghc works.  Knowing that you can't fit more objects in memory than the size of maxBound :: Int is a pretty obvious detail of how ghc works.
11:37:55 <marcusmonteiro> mauke: Nice
11:37:58 <meoblast001> suppose i have two lensified types... A and B.. A contains a list of B called "bar".... B contains "foo" which is boolean... is there a way to make all foo's in all B's in an A true?
11:38:05 <meoblast001> i'm not so great with lenses
11:38:12 <meoblast001> also should i be a sking this in #haskell-lens?
11:38:28 <marcusmonteiro> fishythefish: Thank you
11:38:36 <fishythefish> marcusmonteiro, no problem.
11:38:38 <c_wraith> meoblast001: something like aLens . traverse . bLens .~ True
11:38:44 <glguy> meoblast001: sounds like: set (bar . mapped . foo) True
11:39:14 <marcusmonteiro> ski: how do I respond to this request?
11:39:15 <c_wraith> glguy: why mapped rather than the more general traverse? :P
11:39:21 <meoblast001> glguy: and how do i apply this to an instance of a?
11:39:25 <glguy> because mapped is more general
11:39:38 <seagreen> Is there a way to compile a static binary against a version of glibc that isn't installed on your computer?
11:39:41 <mauke> [Freenode] CTCP VERSION reply from marcusmonteiro: qwebirc v0.91, copyright (C) 2008-2011 Chris Porter and the qwebirc project -- Mozilla/5.0 (Windows NT 6.1; rv:37.0) Gecko/20100101 Firefox/37.0
11:39:47 <mauke> you don't - your client does
11:40:20 <c_wraith> glguy: oh hey, mapped is really fmapped.  :)'
11:40:34 <marcusmonteiro> mauke: and how do I request those things?
11:40:39 <nullx002> are there any real good Ghci alternatives?
11:40:57 <glguy> meoblast001: set (bar . mapped . foo) True your_a_value
11:41:02 <meoblast001> ooooh
11:41:03 <mauke> marcusmonteiro: depends on the client, but try "/ctcp mauke version"
11:41:04 <meoblast001> thanks :)
11:41:42 <marcusmonteiro> mauke: alright
11:42:01 <c_wraith> nullx002: nothing public.  (I hear some companies have pretty good private haskell compilers, but ghci is the best repl of the public ones)
11:42:11 <mauke> yeah, that worked
11:42:36 <hodapp> Mu Haskell!
11:42:48 <c_wraith> right, Mu was the private implementation I was thinking of.
11:44:47 <zq> nullx002: what qualms do you have with ghci?
11:45:20 <Azel> seagreen: If it's present on your computer, that would be a form of cross-compiling. If not, no: how would you?
11:45:29 <lamefun> > ["no","no","no","a","b","c","d"] !! (3 + 9223372036854775807 + 9223372036854775807)
11:45:34 <lambdabot>  mueval-core: Time limit exceeded
11:46:30 <voidzero> I could think of a few good features for ghci.
11:46:53 <voidzero> like only save unique lines into the history file.
11:47:00 <seagreen> Azel: Thanks.
11:48:03 <voidzero> I've been curious whether it's possible to create a ghci wrapper in zsh that takes care of some extra features.
11:48:18 <voidzero> But... time and i'm not actually a programmer either, i'm just pretending.
11:48:39 <hectortrope> hi guys I have few directories in a path. How can i make them accessable by only few users and not accesses by other usres? including root
11:49:03 * hackagebot hpqtypes 1.4.2 - Haskell bindings to libpqtypes  http://hackage.haskell.org/package/hpqtypes-1.4.2 (arybczak)
11:49:11 <voidzero> making things not accessible to root
11:49:23 <voidzero> maybe you need to rethink the why.
11:50:16 <Azel> hectortrope: If it's "a few users including root"...wouldn't that be why groups exist?
11:50:26 <voidzero> other than that... assuming you're on a linux machine.. you could look into acl.
11:50:30 <seagreen> Actually, if anyone has a link explaining how glibc and a haskell executable interact, it would be appreciated.
11:50:30 <S11001001> hectortrope: you can't make it inaccessible to root. Do you mean accessible to root, or inaccessible to root?
11:52:34 <hectortrope> sorry I posted in haskell thinking linux room
11:52:59 <hectortrope> any how thanks a lot fror replies ......I use NFS so is it possible root cant be able to access
11:53:36 <voidzero> i have found that only with sshfs
11:53:52 <voidzero> like when a user mounts using sshfs, root is not always able to access it as root
11:53:57 <voidzero> still able to bypass that of course
11:56:32 <Azel> It's root. Even if you lock him out via acls he can always modify them and access anyway.
11:58:00 <albeit> If a TChan has one element in it, will "atomically $ readTChan >> isEmptyTChan" return True?
11:58:12 <voidzero> Azel, sure, root can always bypass
11:59:42 <ReinH> Cale: oh, ocharles_ had the right idea. L-systems generated via coiter from Control.Comonad.Cofree, with deterministic systems represented by Cofree Identity (as infinite streams)
12:00:17 <ReinH> with, e.g., Cofree [] for nondeterministic systems
12:00:22 <ocharles_> :)
12:00:34 <ReinH> ocharles_: :)
12:01:04 <ReinH> ocharles_: this is my first and possibly only contribution to category theory ;)
12:01:35 <ReinH> ocharles_: but I can make pretty images so https://dl.dropboxusercontent.com/u/632742/turtle.svg
12:05:19 <ocharles_> i love l systems :)
12:07:43 <ReinH> ocharles_: :)
12:07:47 <ocharles_> needs more trees
12:10:41 <noodles1> hi friends, i'm having some trouble understanding types. Here's an example: eGP c n = n:(concat (map (eGP c) (c n) ) )
12:10:41 <noodles1> :t eGP gives me: eGP :: (a -> [a]) -> a -> [a]
12:10:49 <lambdabot> Not in scope: ‘eGP’
12:10:49 <lambdabot> Not in scope: ‘gives’
12:10:49 <lambdabot>     Not in scope: ‘me’
12:10:54 <noodles1> I (mis)interpret that as "a function that takes an a and returns a list of a, an a"
12:11:13 <Iceland_jack> noodles1: The first argument of 'eGP' is itself a function
12:11:15 <geekosaur> eGP takes two parameters
12:11:27 <geekosaur> the first is a function that takes an a and produces a list of a
12:11:27 <geekosaur> the second parameter is an a
12:11:27 <geekosaur> the result is a list of a
12:11:50 <ReinH> ocharles_: :)
12:12:00 <Iceland_jack> noodles1: We can pick a simpler if you want, do you understand
12:12:00 <Iceland_jack>   twice :: (Int -> Int) -> Int -> Int
12:12:00 <Iceland_jack>   twice f n = f (f n)
12:12:05 <Iceland_jack> *simpler example
12:12:26 <ronh-> :t 
12:12:28 <lambdabot> <no location info>: not an expression: ‘’
12:12:57 <Iceland_jack> noodles1: If you apply it to
12:12:57 <Iceland_jack>     twice (4 +) 70
12:12:57 <Iceland_jack> you get ... back
12:12:57 <Iceland_jack>     4 + (4 + 70)
12:13:02 <ronh-> twice = join
12:13:33 <Iceland_jack> ronh-: No, twice = join (.)
12:14:01 <Iceland_jack> (join (.) f n) is ((f . f) n)
12:14:34 <ronh-> indeed
12:15:54 <geekosaur> compare:
12:15:54 <geekosaur> :t map
12:15:54 <geekosaur> (er, did we lose lambdabot?)
12:15:54 <geekosaur> map :: (a -> b) -> [a] -> [b]
12:15:54 <noodles1> tks geekosaur, the parenthesis around "a -> [a]" are what indicates that it's a function?
12:15:54 <geekosaur> yes
12:15:54 <geekosaur> now, consider that the type of map can also be written:
12:15:54 <geekosaur> map :: (a -> b) -> ([a] -> [b])
12:15:54 <geekosaur> that is, given a function that accepts an a and produces a b, map gives you a function that accepts a list of a and produces a list of b
12:15:57 <lambdabot> (a -> b) -> [a] -> [b]
12:18:01 <noodles1> Iceland_jack: whoa, wall of text! i went to try eGP with these arguments "eGP (\x -> [x]) 5" I got an inf. list of 5 ;)
12:18:07 <noodles1> I'm reading what you wrote now
12:18:50 <geekosaur> I think freenode got stuck
12:19:04 * hackagebot bytestring-handle 0.1.0.3 - ByteString-backed Handles  http://hackage.haskell.org/package/bytestring-handle-0.1.0.3 (GaneshSittampalam)
12:20:32 <noodles1> Iceland_jack: haha, funny enough your example twice was another problem from my text.
12:21:52 <hulli> what is a good IDE for haskell (not vim or emacs)
12:22:23 * Iceland_jack . o O ( vim and emacs )
12:22:36 <maerwald> hulli: leksah
12:22:45 <Iceland_jack> noodles1: :) does it make sense to you?
12:22:52 <hulli> there was another pne
12:22:59 <noodles1> I understand "twice f n = f (f n)" as "apply f to the results of f applied to n." However I join (.), googling . operator
12:23:03 <hulli> but i cant recall the name
12:23:22 <Iceland_jack> noodles1: Don't bother with 'join (.)'
12:23:29 <Iceland_jack> But (.) is function composition
12:23:33 <Taneb> hulli, I've had some good experience with Eclipse in the past
12:23:43 <Iceland_jack> its definition is quite terse
12:23:45 <Iceland_jack> @src .
12:23:45 <lambdabot> (f . g) x = f (g x)
12:24:29 <noodles1> Iceland_jack: mostly, with types (a->a) is a function that takes a type and returns the same type, (a->[a]) is a function that returns a list of the same type as it's argument..
12:24:42 <hulli> another one specifically designed for haskell?
12:24:52 <hulli> or am I imagioning things
12:25:04 <maerwald> hulli: did you try leksah or not?
12:25:07 <Iceland_jack> noodles1: If you look at the definition of
12:25:07 <Iceland_jack>     twice f n = f (f n)
12:25:07 <Iceland_jack> you can tell that its right-hand side looks quite similar to the right-hand side of (.): f (g n)
12:25:31 <noodles1> in the case of "twice f n = f f n" is the result the same or is is it equivalent to "twice f n = (f f) n
12:25:35 <Iceland_jack> noodles1: So you can equivalently write "twice f n = f (f n)" as "twice f n = (f . f) n"
12:26:12 <Iceland_jack> noodles1: Yes you're right, (Int -> Int) is a function from Int to Int, (a -> [a]) is a function from any type to a list of that type
12:26:21 <hulli> no. I will, but I am wondering what is the other name of the IDE specifically designed for haskell
12:26:44 <Iceland_jack> noodles1: An example of such a function might be
12:26:45 <Iceland_jack>     replicate5 :: a -> [a]
12:26:45 <Iceland_jack>     replicate5 x = [x,x,x,x,x]
12:27:37 <hulli> or maybe it was a general IDE/editor with very strong haskell addon (again, not vim or emacs)
12:27:39 <muzzle> hulli: There is currently (as to my knowledge) no IDE for haskell (or anything working remotely as stable as let's say IntelliJ)
12:27:56 <maerwald> muzzle: ofc there is, it's called leksah
12:27:57 <noodles1> Iceland_jack: sorry, but . is difficult to google for, I still don't know what it is, give me a couple minutes to figure out why "twice f n = (f . f) n" is the same as "twice f n = f (f n)"
12:28:01 <hiptobecubic> there's leksah
12:28:12 <maerwald> but I don't think there is any other *specifically* designed for haskell
12:28:15 <hiptobecubic> There's also the fpwhtaever plugin for eclipse
12:28:46 <muzzle> maerwald: last time i used it it was not really stable, and the project seems to progress really slowly
12:28:53 <geekosaur> I think eclipsefp was recently disconrtinued?
12:29:03 <muzzle> geekosaur: it was
12:29:04 <Welkin> emacs + haskell-mode is best
12:29:05 * hackagebot snaplet-ses-html 0.1.1.0 - Snaplet for the ses-html package  http://hackage.haskell.org/package/snaplet-ses-html-0.1.1.0 (DavidJohnson)
12:29:24 <muzzle> the best thing to use is emacs + ghc-mod + haskell-mode
12:29:26 <geekosaur> leksah was just updated but I haven't heard of many people using it
12:29:28 <noodles1> ah, function composition
12:29:30 <Iceland_jack> noodles1: If you search for "Haskell dot" or "Haskell function composition" you should find it
12:29:32 <muzzle> (imo)
12:29:52 <geekosaur> fpcomplete has an online browser-based IDE, don't recall current terms of use
12:29:55 <Iceland_jack> noodles1: You can also search for it https://www.fpcomplete.com/hoogle?q=.&env=ghc-7.8-stable-14.09
12:30:15 <muzzle> atom also plans on integrating some haskell related stuff
12:30:35 <muzzle> but the problem is, that it all relies on ghc-mod which doesn't work with the newest ghc
12:30:42 <Iceland_jack> noodles1: http://haddocks.fpcomplete.com/fp/7.8/20140916-162/base/Prelude.html#v:.
12:33:13 <vitalij> why does 'prova <- getLine' works in ghci but not when i load that from a file?
12:33:42 <Iceland_jack> vitalij: Try
12:33:42 <Iceland_jack>     main = do
12:33:42 <Iceland_jack>       prova <- getLine
12:33:42 <Iceland_jack>       putStrLn prova
12:34:01 <ronh-> you can't just put it anywhere in the file
12:34:07 <Iceland_jack> "prova <- getLine" by itself in a file will not work 
12:34:22 <noodles1> ok, back to the original function in question "eGP c n = n:(concat (map (eGP c) (c n) ) )"  map takes a function that two params and applies that to each element of a list, so eGP is the function and c is the first argument....? no
12:34:47 <vitalij> thanks Iceland_jack!
12:35:32 <Iceland_jack> noodles1: (eGP c) is a function (first argument to map), (c n) is the second argument to map and should be a list
12:35:32 <geekosaur> c is the function and n is the seed element for the list it creates
12:37:25 <Iceland_jack> noodles1: The function 'eGP' is too involved methinks, it's polymorphic, recursive and higher-order
12:37:40 <Iceland_jack> noodles1: Do you fully understand map and concat
12:38:51 <noodles1> Iceland_jack: map takes a function (a -> a) ->a, and a list and applies the function to every element in the list
12:39:04 <Iceland_jack> It does?
12:39:06 <Iceland_jack> :t map
12:39:09 <lambdabot> (a -> b) -> [a] -> [b]
12:39:18 <c_wraith> It certainly *can*
12:39:43 <c_wraith> :t map ($ 5)
12:39:45 <lambdabot> Num a => [a -> b] -> [b]
12:40:12 <noodles1> intuitively (to me) concat concatenates two lists, but it's type is concat :: [[a]] -> [a], so it takes a list of lists and returns a list
12:40:32 <Iceland_jack> > concat [[1,2,3], [10,20,30], [1000], [10000,20000]]
12:40:37 <lambdabot>  [1,2,3,10,20,30,1000,10000,20000]
12:41:00 <geekosaur> noodles1, the thing you are thinking of in haskell is
12:41:00 <c_wraith> just a mild generalization of concatenating two lists
12:41:02 <geekosaur> :t (++)
12:41:04 <lambdabot> [a] -> [a] -> [a]
12:41:11 <breadmonster> geekosaur: Do you use Haskell professionally?
12:41:19 <breadmonster> Or anyone else?
12:41:19 <noodles1> >concat [[1],[2],[3]]
12:41:29 <geekosaur> no, I provide source for an ancient and hairy C codebase >.>
12:41:31 <Iceland_jack> > map (\x -> [x]) [1,2,3]
12:41:33 <noodles1> > concat [[1],[2],[3]]
12:41:33 <c_wraith> noodles1: the space is not optional
12:41:37 <lambdabot>  [[1],[2],[3]]
12:41:40 <lambdabot>  [1,2,3]
12:41:49 <geekosaur> but I am a contributor to xmonad in my spare time
12:41:51 <Iceland_jack> > concat (map (\x -> [x]) [1,2,3])
12:41:54 <lambdabot>  [1,2,3]
12:42:01 <breadmonster> c_wraith: What about you?
12:42:03 <c_wraith> :t concat . map pure
12:42:05 <lambdabot> [a] -> [a]
12:42:14 <geekosaur> er, provide support for
12:42:15 <c_wraith> breadmonster: not anymore
12:42:25 <breadmonster> geekosaur: Naw man, doesn't count.
12:42:38 <breadmonster> I had a few questions about doing something like Facebook in Haskell.
12:42:46 <breadmonster> Like, making my own app and shit.
12:43:03 <breadmonster> xmonad is great, but its runs on the users PC.
12:43:04 <Iceland_jack>     Facebook -- we make apps and shit
12:43:22 <breadmonster> Iceland_jack: in a sense, yes :P
12:43:24 <dmj`> lel :)
12:43:36 <dmj`> breadmonster: you mean like implement news feed / comments / posts / likes etc?
12:43:42 <breadmonster> But don't tell them I said that, I'd like to keep my opportunities for employment there open ::P
12:43:53 <c_wraith> breadmonster: do you just mean... a web service?
12:43:55 <breadmonster> dmj`: No, like serve lots of users on a server concurrently.
12:44:28 <breadmonster> c_wraith: Yeah.
12:44:30 <dmj`> breadmonster: oh... 
12:44:32 <c_wraith> breadmonster: web services in haskell are pretty easy these days.  You have tons of different (and good) options for different purposes.
12:44:44 <breadmonster> c_wraith: Yeah, I've heard.
12:44:52 <breadmonster> There's no GHC to JS compiler though right?
12:44:58 <c_wraith> there are like 3
12:45:05 <c_wraith> Fay, Haste, ghcjs
12:45:12 <breadmonster> Are they good? Or in development?
12:45:15 <c_wraith> You can probably count other things like sunroof, too
12:45:22 <c_wraith> All 3 have been used professionally.
12:45:31 <breadmonster> Cool stuff.
12:45:38 <breadmonster> Also, does anyone use Atom?
12:45:45 <dmj`> the editor?
12:45:56 <breadmonster> Yup.
12:46:10 <c_wraith> Oh.  I thought you meant atom-the-package, and was going to point you at acowley's robotics in haskell videos.
12:46:27 <breadmonster> I need an editor to code on Windows.
12:46:31 <breadmonster> emacs just isn't fun :(
12:46:35 <dmj`> breadmonster: I think most professional haskellers use vim/emacs
12:46:48 <c_wraith> breadmonster: if you're looking at web-based IDE's, check out fpcomplete's offering as well
12:46:51 <breadmonster> If I'm going to spend serious resources on eye candy, I might as well get a pretty editor.
12:47:20 <dmj`> breadmonster: there's some issues with the RTS on windows, I'd stay in nix land
12:47:39 <noodles1> Iceland_jack: yes, i agree that it's a bit complicated, thanks for your help. It's starting to make sense, I'll try some other examples
12:47:44 <breadmonster> dmj`: Oh no, I mean just coding. I plan on running my stuff on Haskell servers.
12:48:47 <c_wraith> breadmonster: https://www.fpcomplete.com/ seems pretty decent as an IDE, from what I've seen.  It also uses an almost-entirely-haskell toolchain.  yesod-based server, I think ghcjs frontend.  Maybe Fay frontend, I don't recall.
12:48:50 <hasket> breadmonster: atom is way better than vim for haskell (and I'm a vim fanatic). I just use vim mode in atom and the autocompletion with ghc-mod is IDE like. It's incredible
12:49:33 <hasket> breadmonster also the type inference with atom is EXTREMELY good. I know it's just ghc-mod, but it interfaces incredibly well
12:49:49 <breadmonster> Excellent.
12:51:14 <hiptobecubic> hasket, interesting.
12:51:41 <dmj`> I guess professional people do use atom, http://edsko.net/2015/03/07/vim-to-atom/
12:51:52 <dmj`> intellesting
12:51:58 <hiptobecubic> hasket, I will be really interested to see how neovim plays out. There's a lot of effort being put into using atom as a front-end to neovim
12:52:36 <lpaste> breadmonster pasted “Indentation: why doesn't this typecheck?” at http://lpaste.net/134125
12:52:39 <hiptobecubic> dmj`, atom is definitely used for real work. It's essentially sublime for slightly nerdier, more web-oriented folks.
12:52:42 <breadmonster> can someone give me a hand?
12:53:05 <dmj`> hiptobecubic: very cool
12:53:50 <dmj`> breadmonster: can you paste the type error output too
12:54:42 <lpaste> breadmonster revised “Indentation: why doesn't this typecheck?”: “No title” at http://lpaste.net/134125
12:54:46 <hiptobecubic> the multiple cursors trick is definitely something I wish regular old vim had
12:55:41 <dmj`> breadmonster: line 68 is not a tuple, but a list of Token
12:55:58 <Denommus> atom is like a slower Emacs with a worse language
12:56:19 <hasket_> hiptobecubic It does. Control-v, i, esc
12:56:33 <c_wraith> I should learn how to multi-cursor in emacs
12:56:38 <hasket_> Denommus Don't use emacs, but the vim support for haskell sucks
12:56:47 <hasket_> It's Okay-ish
12:56:59 <breadmonster> dmj`: Thanks (:
12:57:01 <hiptobecubic> hasket_, that only works for rectangular edits. Multiple cursors can do "ragged array" editing
12:57:05 <Denommus> hasket_: ghc-mod is currently broken with the current cabal and GHC :-/
12:57:11 <hodapp> Denommus: is it pretty underwhelming? I looked at it a bit
12:57:14 <breadmonster> But this doesn't make the error with the collectSpaces function go away.
12:57:16 <fishythefish> hiptobecubic: at least there are plugins for it.
12:57:17 <hasket_> Denommus: Download from github
12:57:23 <hasket_> Denommus Install from there
12:57:27 <breadmonster> dmj`: Can you debug lines 59-64?
12:57:46 <hasket_> Denommus The package has been updated and now works
12:57:55 <breadmonster> Actually, don't/
12:58:04 <breadmonster> dmj`: Let me just have a look for a second.
12:58:09 <dmj`> breadmonster: line 62, the else condition, should return a Token, not a tuple
12:58:24 <dmj`> a `Tokens`, `[Token]`
12:58:31 <quchen> Is there a way I can easily `cabal install` all of stackage?
12:58:35 <hiptobecubic> hasket_, such as here http://edsko.net/images/atom-indent-1.gif and here http://edsko.net/images/atom-multiple-cursors-2.gif . Granted in *both* of those cases what they wanted to do is done by some other tool like vim-align and vim-surround, but for non-standard edits there's no equivalent I know of
12:58:46 <dmj`> I wish I had ghci in my head, would be so convenient
12:58:54 <hiptobecubic> quchen, you could make a world file that has everything in it?
12:59:29 <breadmonster> dmj`: Sorry the corrected function signature reads `compareIndent :: Int -> [Int] -> (Tokens, [Int])`
12:59:39 <hasket_> hiptobecubic Yep makes sense. I just use align and vim-surround. Also, those are both OCD edits :)
12:59:47 <breadmonster> It's basically a state monad implementation.
13:00:00 <hasket_> breadmonster check out https://atom.io/packages/ide-haskell
13:00:08 <breadmonster> hasket_: Will do.
13:00:39 <hasket_> hiptobecubic: https://github.com/terryma/vim-multiple-cursors
13:00:41 <hasket_> Also that
13:00:51 <noodles1> Iceland_jack: Here's another problem, it asks if the function uses lazy evaluation or partial application, my answer is in the lpaste. http://lpaste.net/134127
13:01:31 <quchen> hiptobecubic: Hmm, how would I do that?
13:01:44 <quchen> In a sandbox, if that matters
13:02:08 <joneshf-laptop> quchen, http://hackage.haskell.org/package/acme-everything
13:02:17 <joneshf-laptop> quchen, oh stackage
13:02:32 <quchen> joneshf-laptop: I made acme-everything ;-)
13:02:48 <hasket_> ಠ_ಠ
13:02:56 <hasket_> Whoops did not mean to send that
13:02:57 <hasket_> sorry
13:03:02 <hasket_> haha
13:03:10 <joneshf-laptop> quchen, oh
13:03:15 <breadmonster> quchen: Do you have a minute?
13:03:22 <breadmonster> I'm not able to get this code to typecheck.
13:03:52 <Welkin> breadmonster: the compiler tells you where the problem is
13:03:57 <Welkin> breadmonster: just past it on lpaste
13:04:05 <arkeet> the code and the error
13:04:34 <quchen> breadmonster: I don't actually, I'm just tuning in because my build did something weird. But there are plenty of people around here to ask instead! :-)
13:04:40 <lpaste> breadmonster revised “Indentation: why doesn't this typecheck?”: “No title” at http://lpaste.net/134125
13:04:57 <breadmonster> Welkin: I can't seem to figure out what's wrong...
13:06:21 <Welkin> breadmonster: `indentation` is getting passed a PyParser Int instead of PyParser [t]
13:06:33 <hiptobecubic> quchen, what about just extracting the names out of http://www.stackage.org/lts-2.13/cabal.config ?
13:06:56 <breadmonster> Welkin: `indentation` doesn't take any arguments...
13:07:07 <geekosaur> compareIndent declared as Int -> [Int] -> (Tokens, [Int])
13:07:32 <Welkin> er, I mean it produces Int instead of [t]
13:07:33 <geekosaur> but if I trust the names you use for the pattern receiving its result, you are expecting ([Int], Tokens)
13:08:00 <geekosaur> (let (is', ts') = compareIndent n is)
13:08:08 <quchen> hiptobecubic: Yeah I'm working on that. I pasted it into a dummy package but it tells me that "build-depends" fails to parse.
13:08:16 <quchen> (Without further details.) :-(
13:08:34 <breadmonster> Welkin: Sorry, one second, the compiler seems to be talking about the `collectSpaces` function.
13:08:50 <breadmonster> geekosaur: One second, let me check.
13:09:00 <geekosaur> line numbers are off
13:09:03 <quchen> Is "base installed" a valid directive in the build-depends field?
13:09:06 * hackagebot ses-html 0.3.0.0 - Send HTML formatted emails using Amazon's SES REST API with blaze  http://hackage.haskell.org/package/ses-html-0.3.0.0 (DavidJohnson)
13:09:18 <breadmonster> geekosaur: you're magic.
13:09:23 <breadmonster> That killed off two errors.
13:09:25 <geekosaur> for example it's pointing at line 80 later on... line 80 being the error message itself!
13:09:40 <breadmonster> One second, let me fix that I ignored some documentation.
13:10:47 <lpaste> breadmonster revised “Indentation: why doesn't this typecheck?”: “No title” at http://lpaste.net/134125
13:11:04 <breadmonster> geekosaur: That's the revised version with corrected line numbers.
13:11:34 <hiptobecubic> quchen, curl -s 'http://www.stackage.org/lts-2.13/cabal.config' | sed -e '/^--/d' -e 's/.*://g' -e 's/ ==.*//g' -e 's/\s\+//g' | xargs cabal install     :)
13:11:38 <breadmonster> The little doc message on top was really embarrassing so I left it off the first time ><
13:12:06 <hiptobecubic> with appropriate cabal.config present of course
13:12:32 <quchen> hiptobecubic: That'll probably blow up the constraint checker
13:12:50 <quchen> hiptobecubic: The command is something like 20k characters long ;-)
13:12:51 <geekosaur> hm, the previous one actually made more sense since the line t pointed at was the declaration of indentation, saying it wanted Tokens, so I went to the end and saw return ts and then up to where that came from and then over to compareIndent
13:12:54 <breadmonster> :t (liftM (undefined :: a -> b))
13:12:57 <lambdabot> Monad m => m a -> m r
13:13:10 <hiptobecubic> quchen, don't be a complainer
13:13:27 <quchen> hiptobecubic: :>
13:13:45 <hiptobecubic> quchen, I'm not sure what happened to the `world` that used to be in `~/.cabal` though. My suggestion was to dump everything into there
13:13:50 <breadmonster> geekosaur: there's a tiny function called `countIndenation` that I've used to convert Tokens to Int.
13:13:53 <hiptobecubic> but I don't see one anymore
13:15:47 <quchen> hiptobecubic: Deleting the "installed" lines solved it. Maybe that is a placeholder for Stackage builds.
13:15:59 <quchen> So I just made a dummy "cabal init" and pasted all the stuff in there.
13:16:10 <breadmonster> geekosaur: Got it, don't bother.
13:16:17 <breadmonster> Should have paid more attention.
13:16:24 <hiptobecubic> quchen, souds good
13:16:24 <quchen> hiptobecubic: Thanks though. Let's see how long the build takes. :-)
13:16:40 <hiptobecubic> quchen, you remembered `-j` I hope?
13:16:50 <quchen> hiptobecubic: The default is $ncpus
13:17:06 <quchen> (And yes, all cores are working like mad)
13:17:19 <quchen> Back to doing something else until it finishes! :-D
13:18:02 <breadmonster> geekosaur: thanks a ton!
13:23:58 <breadmonster> Guys, how big should modules be, ideally?
13:24:00 <breadmonster> Like how many LOC?
13:24:17 <breadmonster> Or is there a better way of organizing your program?
13:24:31 <breadmonster> I used to write like one module for one part of the program, like one *big* part
13:24:56 <breadmonster> So in GHC, I'd use one module for the parser, one for the optimizations, and one for the back end.
13:25:09 <breadmonster> But that means each module will have several hundred thousand LOC.
13:25:19 <breadmonster> So what's the optimal module size?
13:26:43 <RyanGlScott> I've having some trouble using type families, it seems. Can anyone help me diagnose the issue with this code? http://lpaste.net/134130
13:29:01 <joneshf-laptop> breadmonster, likely there's something within those several hundred thousand LOC that is duplicated
13:29:23 <Peaker> Parallelism in Haskell kinda sucks because memory-thrasher thread kills performance of other threads by requesting parallel GC :-(
13:29:39 <Peaker> I hate GC :-(
13:30:47 <c_wraith> RyanGlScott: The issue is automatic derivation of Functor instances...  It doesn't handle that case because of the type family
13:30:58 <joneshf-laptop> breadmonster, if you find that you have a group of optimizations that a similar, or operate on a similar part of the tree, move them to a separate module.
13:31:06 <joneshf-laptop> breadmonster, for instance
13:31:32 <breadmonster> joneshf-laptop: Okay, cool.
13:31:56 <c_wraith> RyanGlScott: while there's enough information there to build a Functor instance, the mechanism for automatically building it is conservative.  It sees the type variable used in a type family and it bails out, saying "this could do anything, I'm not gonna try"
13:32:24 <oconnore> Peaker: there could be better ways to tune the GC, thread local heaps, etc. but in the meantime why not reduce memory usage of the problematic thread?
13:32:35 <geekosaur> yes, that particular type function (that is what a type familiy is) is trivial but in theory it could be fairly complex and the deriving machinery wouldn't be ablle to deal
13:32:40 <RyanGlScott> c_wraith: Hm. That's interesting. What could type families do that type synonyms couldn't that could cause it to freak out?
13:33:23 <RyanGlScott> c_wraith: Is it worried about UndecidableInstances?
13:33:39 <Peaker> oconnore: it's a (very naive) evaluator for a lambda-calculus like language, that reports (as callbacks) all the intermediate evaluation steps (what each subexpression has been evaluated to and in what lambda contexts).  This is necessarily memory-heavy stuff (all this information is gathered to be presented in a gui)
13:33:42 <c_wraith> RyanGlScott: type family Foo a where Foo Int = Char ; Foo a = a
13:33:45 <bitemyapp> Peaker: can you write it up?
13:33:48 <Peaker> oconnore: but this thread is hurting the responsiveness of the gui
13:33:56 <bitemyapp> Peaker: having test-cases to improve upon would help with GHC dev.
13:34:08 <ReinH> bitemyapp: o/
13:34:10 <c_wraith> RyanGlScott: If you use that type family in there, it's impossible to write a Functor instance.
13:34:29 <Peaker> bitemyapp: I'd try to make the thread/evaluator less naive first
13:34:36 <c_wraith> RyanGlScott: well, you could write something that type-checks, but it wouldn't obey the functor laws.
13:35:28 <ReinH> Peaker: SimonM's book has some strategies for improving GC performance of data parallel stuff, iirc
13:35:42 <ReinH> or at least for evaluating and reasoning about it using, e.g., threadscope
13:35:58 <Peaker> ReinH: Yeah, I've seen the trouble via threadscope
13:35:59 <RyanGlScott> c_wraith: Really? I'd been viewing WrapIdFam (IdFam a) as isomorphic to WrapIdFam a, so which law would break?
13:36:10 <c_wraith> RyanGlScott: that specific type family is.
13:36:34 <ReinH> Peaker: granularity is often a good thing to tweak
13:36:35 <c_wraith> RyanGlScott: my point was that other type families are not, and the automatic deriving stuff isn't going to even try to determine whether it's an acceptable case or not
13:36:46 <ReinH> (spark size and count)
13:36:52 <c_wraith> RyanGlScott: It's just going to say "whoa, a type family, I'm just going to bail out"
13:36:55 <bitemyapp> Peaker: fair enough.
13:37:01 <Peaker> ReinH: ah, I'm not doing parallelism stuff like that -- just an explicit background thread running a heavy evaluation job
13:37:11 <geekosaur> RyanGlScott, the point is that the derivation machinery is not smart enough to tell the difference between your simple IdFam and the one that c_wraith suggested --- and the latter it can't deal with. rather than try to sort it out, it bails on *any* type familiy
13:37:15 <ReinH> Peaker: ah, so "concurrency", to use SimonM's definition
13:37:37 <ReinH> (which is a pretty reasonable definition)
13:37:46 <Peaker> ReinH: Yeah, that may be more accurate, though in my case the purpose of the concurrency is mainly to get parallelism (to avoid hurting the gui/main thread performance)
13:37:54 <geekosaur> yours is the trivial case, c_wraith's is closer to the general case --- the general case being unsolvable
13:37:56 <RyanGlScott> Oops, I didn't see your above example. That does make sense.
13:38:07 <Peaker> I don't mind if that thread runs slowly, but it mustn't make the other threads slow as well
13:38:29 <ReinH> Peaker: sure, it isn't worth a back-and-forth about the definitions once you've communicated what you're actually doing :)
13:39:07 * hackagebot cmark 0.3.4 - Fast, accurate CommonMark (Markdown) parser and renderer  http://hackage.haskell.org/package/cmark-0.3.4 (JohnMacFarlane)
13:39:09 * hackagebot hedis 0.6.7 - Client library for the Redis datastore: supports full command set,  pipelining.  http://hackage.haskell.org/package/hedis-0.6.7 (FalkoPeters)
13:39:13 <ReinH> Peaker: so this background thread is throwing off a bunch of stuff for GC to pick up
13:39:36 <ReinH> and the GC work is impacting the UI thread
13:39:42 <Peaker> ReinH: Yeah, according to threadscope it's doing par-gc-requests blocking the main gui thread
13:39:46 <RyanGlScott> In that case, perhaps the error message should be more specific?
13:40:27 <c_wraith> RyanGlScott: I thought the error message *was* pretty specific.  you can't use the last type variable on the LHS in anything other than a positive position on the RHS.
13:40:59 <c_wraith> RyanGlScott: if you try, then it fails to automatically derive an instance
13:41:41 <RyanGlScott> c_wraith: Oh wait, I didn't see that it says "last argument of a *data type*".
13:41:49 <RyanGlScott> c_wraith: Yeah, that is pretty specific. :)
13:41:55 <c_wraith> RyanGlScott: specific, but you have to read carefully. :)
13:42:09 <c_wraith> RyanGlScott: it might be possible to phrase it more clearly
13:42:20 <tejing> c_wraith: that pretty much describes all haskell compile errors :-)
13:42:34 <c_wraith> ...  yeah, it does. :)
13:42:38 <ReinH> Peaker: the obvious things are to use unboxed types where possible (and not undesirable), to minimize intermediate structure allocation via fusing where possible, etc
13:42:38 <c_wraith> (well, GHC errors)
13:43:08 <Peaker> ReinH: Sounds like a good tip -- I wonder how to apply it in a Lambda calculus evaluator/tracer :)
13:43:14 <phaazon> :t minmax
13:43:14 <ReinH> Peaker: that's a slightly more specific way of saying "if allocations are hurting you, stop allocating so much" ;)
13:43:17 <lambdabot> Not in scope: ‘minmax’
13:43:43 <phaazon> @let minmax = foldl (\(n,x) a -> (min n a,max x a)) (maxBound,minBound)
13:43:48 <lambdabot>  Defined.
13:43:50 <ReinH> Peaker: also the gc can be tuned somewhat, which may help
13:43:51 <Peaker> ReinH: I'm creating a big nested map of scopes -- each scope containing what all subexpression values were during evaluation
13:44:07 <Peaker> So I'm pretty sure I'm doomed to a lot of allocations
13:44:19 <phaazon> > minmax [3,2,-3,34,93,-9,0,3]
13:44:21 <ReinH> Peaker: how are those structures being freed for GC though?
13:44:22 <Peaker> Any idea when GHC's GC is local and when it is cross-caps/parallel?
13:44:22 <lambdabot>      No instance for (Show t10)
13:44:22 <lambdabot>        arising from a use of ‘show_M474694439989736655611977’
13:44:22 <lambdabot>      The type variable ‘t10’ is ambiguous
13:44:31 <ReinH> It might be better to trade memory for less GC work
13:44:37 <phaazon> > minmax [3,2,-3,34,93,-9,0,3] :: (Int,Int)
13:44:43 <lambdabot>  (-9,93)
13:44:51 <Peaker> ReinH: They're fed to the GUI-building code which converts them to its own representation and then nobody ever uses them again
13:45:16 <phaazon> @unlet
13:45:16 <lambdabot>  Define what?
13:45:24 <ski> @undefine
13:45:24 <lambdabot> Undefined.
13:45:37 <phaazon> @let minmax = foldl' (\(n,x) a -> (min n a,max x a)) (maxBound,minBound)
13:45:40 <lambdabot>  Defined.
13:45:49 <ReinH> Peaker: Ah, right, which is unfortunately pessimal: every time the UI does stuff, the GC prevents the UI from doing stuff...
13:46:05 <broma0> why do we not add class constraints to a data declaration? (read it in learn you a haskell, but couldnt understand the reasoning)
13:46:09 <phaazon> > minmax [minBound..maxBound] :: (Int,Int)
13:46:15 <Peaker> ReinH: if my thread was the only consumer of its huge data structures -- would it use local-GC rather than parallel GC?
13:46:18 <lambdabot>  mueval-core: Time limit exceeded
13:46:21 <Peaker> is GHC smart about when to use local and when to use parallel GC?
13:46:26 <phaazon> hm
13:46:36 <tejing> broma0: because it doesn't gain you anything. you still have to put the same class constraints on all the functions
13:46:38 <phaazon> damned thunks :)
13:46:42 <ReinH> Peaker: I don't know
13:46:44 <fishythefish> broma0, what sort of syntax did you have in mind?
13:47:28 <fishythefish> And with what effect?
13:47:51 <ReinH> Peaker: I can give you a reference, though, at least: http://www.cs.tufts.edu/~nr/cs257/archive/simon-marlow/par-gc-ismm08.pdf
13:47:53 <broma0> tejing: on all of the functions involving the data type in question?
13:48:01 <tejing> broma0: yes
13:48:07 <Peaker> ReinH: thanks
13:48:47 <broma0> fishythefish: I was thinking something like this 'data (Queryable b) => Database = Database { somePluggableBackend :: b }'
13:48:57 <ReinH> Peaker: maybe one strategy is to keep a cache of these frames around to serve as a root, to simply prevent them from being marked
13:48:59 <phaazon> @let minmax' = foldl' (\acc a -> acc `seq` (min (fst acc) a,max (snd acc) a)) (maxBound,minBound)
13:49:03 <lambdabot>  Defined.
13:49:10 <broma0> fishythefish: how would I accomplish this idea without the class constraint?
13:49:12 <phaazon> > minmax [minBound..maxBound] :: (Int,Int)
13:49:20 <lambdabot>  mueval-core: Time limit exceeded
13:49:21 <phaazon> > minmax' [minBound..maxBound] :: (Int,Int)
13:49:30 <lambdabot>  mueval-core: Time limit exceeded
13:49:30 <ReinH> I was going to say a "persistent" cache, but I actually mean the opposite of persistent. Ephemeral. And, thus, persistent...
13:49:30 <mizu_no_oto> broma0: I remember  edwardk talking about this in his typeclasses vs the world talk
13:49:32 <phaazon> wat
13:49:36 <Peaker> ReinH: I thought GC becomes more expensive with more live objects, rather than cheaper
13:49:43 <broma0> mizu_no_oto: googling it...
13:49:54 <ReinH> Peaker: well, where is GC spending its time?
13:49:57 <ReinH> marking or sweeping?
13:50:03 <phaazon> a pseq, maybe
13:50:07 <dolio> It's not a mark-sweep collector.
13:50:10 <Peaker> ReinH: Does GHC use mark&sweep at all?
13:50:11 <dolio> It's a copying collector.
13:50:13 <breadmonster> Does anyone know where in the GHC source is Core defined?
13:50:26 <ReinH> Sorry. Evacuating or scavenging?
13:50:38 <mizu_no_oto> dolio: does that ring a bell with you, as well?
13:50:38 <Peaker> Have no idea
13:50:44 <tejing> broma0: just put the class constraint on the functions that work with 'Database a' types (or just the ones that actually use the interface of Queryable)
13:51:05 <fishythefish> broma0, what tejing is saying.
13:51:08 <dolio> mizu_no_oto: Yes, but there are more specific reasons that apply to what LYAH is talking about, probably.
13:51:35 <dolio> 'data C a => Foo a ..' was basically useless.
13:52:00 <RyanGlScott> On a related note, does the -XExistentialQuantification extension allow for non-dumb data types?
13:52:11 <RyanGlScott> e.g., data Foo a = Ord a => Foo a
13:52:25 <fishythefish> broma0, I seem to recall suggested hacky workarounds with GADTs or something, but it's largely pointless.
13:52:29 <broma0> tejing: fishythefish: i see, something just makes me really want to say "not just ANY a, but a Queryable one" in the data declaration.. but i guess thtas just sometihng ill have to live with
13:52:42 <RyanGlScott> Is this considered an antipattern in the same vein as DatatypeContexts?
13:52:48 <geekosaur> RyanGlScott, I think you want GADTs for that
13:53:03 <tejing> broma0: look at it this way: the data structure ITSELF doesn't care about the typeclass... only things that manipulate it do
13:53:11 <RyanGlScott> geekosaur: Right, it's semantically equivalent to data Foo a where Foo :: Ord a => a -> Foo a, AFAIK
13:53:59 <RyanGlScott> I was just wondering since -XDatatypeContexts has received universally negative reviews at the box office, but I don't see similar criticism leveraged at GADTs/ExistentialQuantification.
13:54:17 <broma0> tejing: that's true. it seems that the constraint would merely add a bit more typing and a bit less flexibility.. i believe i understand the rationale now
13:54:30 <geekosaur> otherwise I think the main problem is that an existential of that type only brings the Ord instance into scope, so you can't do much with it
13:54:37 <broma0> tejing: fishythefish: thank you!
13:54:44 <phaazon> hey, I don’t get it
13:55:03 <phaazon> @undefine
13:55:03 <lambdabot> Undefined.
13:55:11 <geekosaur> that is, the only things you can do with such a value is use methods from Ord (or Eq because Ord has that as a superclass)
13:55:12 <phaazon> @let minmax = foldl' (\a x -> a `pseq` (min (fst a) x,max (snd a) x)) (maxBound,minBound)
13:55:15 <lambdabot>  .L.hs:142:24:
13:55:15 <lambdabot>      Not in scope: ‘pseq’
13:55:15 <lambdabot>      Perhaps you meant ‘seq’ (imported from Prelude)
13:55:18 <fishythefish> broma0, actually, to add to what tejing was saying:
13:55:24 <phaazon> @let import GHC.Conc
13:55:27 <lambdabot>  .L.hs:119:1:
13:55:27 <lambdabot>      GHC.Conc: Can't be safely imported! The module itself isn't safe.
13:55:31 <fishythefish> Let's say you did add the constraint to the data type.
13:55:40 <phaazon> for f*ck ’s sake
13:55:41 <broma0> fishythefish: listening
13:55:43 <fishythefish> As tejing said, the type itself doesn't really care, so let's focus on the functions.
13:55:56 <ReinH> Peaker: from what I can tell, parallelization is based on workload, there's some threshold above which it parallelizes
13:55:58 <fishythefish> Functions that operate on that field will still need the constraint in their declaration.
13:56:06 <fishythefish> Whether you include the data constraint or not.
13:56:31 <fishythefish> But if you don't include the data constraint, functions that don't care about those fields don't have to worry about it.
13:56:44 <fishythefish> If you include the data constraint, functions have to include that constraint whether they need it or not.
13:57:06 <RyanGlScott> geekosaur: Ah. There's also this explanation, as well https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/data-type-extensions#existentialquantification-as-a-replacement-for-datatypecontexts
13:57:34 <broma0> fishythefish: so there really is no point in adding the constraint to the data declaration...
13:57:44 <RyanGlScott> The author's point about requiring vs. providing contexts was pretty illuminating.
13:57:46 <fishythefish> broma0, that's the convention, yeah.
13:57:58 <broma0> fishythefish: this makes much mor sense now, i really appreciat it
13:58:02 <ReinH> Peaker: you might like https://donsbot.wordpress.com/2010/07/05/ghc-gc-tune-tuning-haskell-gc-settings-for-fun-and-profit/
13:58:21 <ReinH> Peaker: the idea with keeping the objects around for longer is that the GC is generational and old objects are collected less frequently
13:58:26 <fishythefish> broma0, no problem.
13:58:43 <breadmonster> phaazon: What does the GHC.Conc library do?
13:59:09 <mniip> breadmonster, implements concurrency primitives
13:59:12 <ReinH> Peaker: As far as tuning, see https://downloads.haskell.org/~ghc/6.12.1/docs/html/users_guide/runtime-control.html#rts-options-gc
13:59:30 <RyanGlScott> So ExistentiallyQuantified data types are only dump in certain contexts :)
13:59:34 <RyanGlScott> dumb*
13:59:47 <Peaker> ReinH: collecting young objects is cheapest though
13:59:53 <ReinH> Peaker: -H sets the GC heap size, and setting it larger can be helpful
13:59:56 <Peaker> ReinH: I guess maybe if I make a lot less garbage I'll go under that threshold then
14:00:12 <phaazon> I don’t get it
14:00:23 <phaazon> it should be enough
14:00:33 <phaazon> > minmax [0..500000] :: (Int,Int)
14:00:38 <lambdabot>  Not i
14:00:43 <phaazon> WAT :D
14:00:47 <ReinH> Peaker: -A sets the allocation area, which is basically the size of the young generation, and generally shouldn't be larger than your L2 cache, but might be too small by default for your system
14:01:03 <phaazon> > minmax [0..100000] :: (Int,Int)
14:01:05 <lambdabot>  Not in scope: ‘minmax’
14:01:17 <dolio> I think that's enough lambdabotting.
14:01:28 <phaazon> no
14:01:43 <phaazon> I’d like to understand why the version is muevaling
14:01:44 <ReinH> Peaker: however, a very large -A might reduce the amount of work the GC does enough to make up for the reduced performance from exceeding the L2 cache size
14:01:48 <ReinH> Peaker: so it's worth experimenting
14:02:02 <tejing> phaazon: pm lambdabot instead of doing it in the channel
14:02:22 <tejing> phaazon: or just use ghci
14:02:35 <ReinH> Peaker: -A and -H are probably the biggest knobs to turn, especially if you have a lot of spare memory
14:02:41 <Peaker> ReinH: minor experimenting (e.g: setting to 3G) did not seem to help. I think -A/-H help more with throughput and my problem is latency
14:02:58 <ReinH> Peaker: :(
14:03:02 <Peaker> ReinH: I can make the frequency of hiccups change, but the problem is having hiccups at all
14:03:08 <ReinH> makes sense
14:03:24 <ReinH> then ultimately I think you just need less allocations
14:03:30 <ReinH> try unboxing a bunch of stuff
14:03:55 <dolio> Peaker: Perhaps creating something in one thread and sending it to another is bad. I don't know how it works, but that sounds like it'd automatically end up not in a thread-local heap.
14:04:30 <ReinH> dolio: Actually, would the RTS repack stuff in that scenario as well?
14:05:00 <dolio> Repack?
14:05:24 <ReinH> un-unbox
14:05:48 <dolio> Boxing has nothing to do with the RTS, as far as I know.
14:06:00 <nak> are they serious? the new OSX is called "El Capitan" ?
14:06:03 <nak> lol
14:06:04 <Peaker> ReinH: I don't think I can unbox that much.. but I can reduce lots of garbage by moving to work with STRefs for my thunks instead of using Map ThunkId
14:06:14 <Peaker> dolio: it just causes more garbage to be generated
14:06:45 <c_wraith> hey, what exactly does the simplifier do in GHC's optimizer?  Is it something like applying arguments to lambdas?
14:06:53 <muzzle1> nak: apparently http://www.apple.com/osx/elcapitan-preview/
14:06:55 <lpaste> phaazon pasted “Minmax mueval” at http://lpaste.net/134133
14:06:55 <ReinH> dolio: I would imagine whether or not data lives on the heap has something to do with the RTS
14:06:57 <muzzle1> lel
14:07:03 <phaazon> any help ^ ?
14:07:03 <dolio> OSX is not on topic here.
14:07:34 <phaazon> hm
14:07:41 <phaazon> maybe that the problem is the min / max ?
14:07:53 <phaazon> the tuple should be evaluated because of the !
14:08:40 <dolio> ReinH: No. It has to do with kinds.
14:08:41 <c_wraith> phaazon: I don't even know why you're seqing the tuple and then using fst and snd
14:08:47 <c_wraith> phaazon: why not just pattern-match on it?
14:09:17 <phaazon> c_wraith: because I want it strict
14:09:30 <c_wraith> phaazon: pattern-matching inside a case is strict
14:09:46 <ReinH> dolio: The RTS does do some repacking, though, unless I'm misunderstanding https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/primitives.html
14:09:50 <phaazon> yeah, but it’s not a case here
14:09:53 <c_wraith> phaazon: and pattern-matching inside a lambda's pattern is implemented with a case
14:09:55 <phaazon> it’s a lambda
14:10:02 <phaazon> it,s not \case
14:10:27 <c_wraith> > (\(_, _) x -> x) undefined () -- phaazon 
14:10:30 <lambdabot>  *Exception: Prelude.undefined
14:10:52 <dolio> ReinH: What on that page indicates that?
14:10:53 <phaazon> oh, I got it right now
14:10:58 <c_wraith> phaazon: pattern-matching inside a lambda's arguments is desugared to a case. :)
14:11:05 <phaazon> @let minmax = foldl' (\a x -> let !(!n,!m) = a in (min n x,max m x)) (maxBound,minBound)
14:11:08 <lambdabot>  Defined.
14:11:25 <phaazon> > minmax [0..500000] :: (Int,Int)
14:11:29 <lambdabot>  (0,500000)
14:11:58 <phaazon> c_wraith: well, without the !, it doesn’t work, see:
14:12:05 <c_wraith> phaazon: why not make the lambda (\(!n, !m) x -> (min n x, max m x)) ?
14:12:17 <phaazon> c_wraith: can I?
14:12:22 <ReinH> dolio: if "The main restriction is that you can't pass a primitive value to a polymorphic function or store one in a polymorphic data type." then what happens if I pass an unboxed value to, say, id?
14:12:26 <c_wraith> phaazon: give it a shot
14:12:33 <dolio> You can't.
14:12:38 <c_wraith> ReinH: compile error if you try
14:12:39 <phaazon> oh yeah
14:12:40 <phaazon> I can
14:12:42 <phaazon> thanks!
14:12:47 <dolio> It's a kind error.
14:12:47 <ReinH> not even one created with an UNPACK pragma?
14:13:02 <dolio> You can't create unboxed types.
14:13:10 <lpaste> phaazon revised “Minmax mueval”: “No title” at http://lpaste.net/134133
14:13:16 <dolio> They are wired in. Int#, Word#, etc.
14:13:22 <ReinH> Ok, does anything special happen when an unpacked value is passed to a polymorphic function?
14:13:37 <ReinH> isn't there still the same concern?
14:13:38 <c_wraith> ReinH: a compile error
14:13:48 <dolio> What's an 'unpacked value'?
14:13:54 <c_wraith> ReinH: polymorphic functions must received boxed values.
14:14:15 <c_wraith> ReinH: a data type that has unboxed components is still, by itself, boxed
14:14:17 <schoppenhauer> hi. if I have a Typeable a, and an object obj of type a, I can check whether typeOf obj == typeOf True, etc., but how can I then coerce this value obj to a Bool then?
14:14:25 <ReinH> Say, data T = T {-# UNPACK #-} !Float
14:14:32 <c_wraith> ReinH: then T is boxed
14:14:45 <lpaste> phaazon revised “Minmax mueval”: “No title” at http://lpaste.net/134133
14:14:49 <schoppenhauer> I need to get a Coercible a Bool, I think. but I have no idea how to get that.
14:15:10 <ReinH> c_wraith: and foo (T x) = id x is a compile error?
14:15:15 <c_wraith> ReinH: yes
14:15:17 <dolio> No.
14:15:21 <ReinH> Um.
14:15:22 <phaazon> btw, it’s so cool that length, null and all those functions are now in Foldable :3
14:15:24 <c_wraith> Oh, wait.  That one isn't
14:15:33 <c_wraith> The compiler automatically inserts boxing for that specific case
14:15:34 <ReinH> What happens to x?
14:15:40 <dolio> 'data T = T {-# UNPACK #-} !Float' just arranges for the actual constructor of T to take a Float#.
14:15:54 <dolio> And then calls to T will extract the Float# from the Float.
14:16:04 <dolio> This should all be handled by the code generation, though.
14:16:12 <ReinH> Ok, and when x, which is a Float#, is passed to id?
14:16:22 <c_wraith> ReinH: x has type Float
14:16:22 <ReinH> it is packed back into a Float, right?
14:16:26 <ReinH> Right.
14:16:28 <ReinH> That's what I'm saying.
14:16:31 <c_wraith> ReinH: if you ever refer to x, it has type Float
14:16:37 <ReinH> Right, and it has to be repacked
14:16:38 <dolio> Matching on T re-boxes the Float, which is also not the RTS.
14:16:51 <ReinH> Ok, fair point about not being the RTS
14:16:57 <ReinH> but that's the behavior I was talking about
14:17:37 <dolio> The optimizer takes advantage of all this, so if it were the RTS that would be way too late.
14:17:39 <michaelt> schoppenhauer: if typeOf obj == typeOf True then doesn't it follow that obj :: Bool anyway? 
14:17:43 <ReinH> dolio: yep, good point
14:17:48 <ReinH> I see that now
14:17:54 <fizbin> If I care about the ordering of monadic side effects in "x" and "y", is it safe to assume that "liftA2" will be implemented so that: liftA2 (<>) x y  evaluates "x" first, and then "y"?
14:18:10 <ReinH> dolio: but it does mean that the RTS sees the re-boxed values, right?
14:18:14 <michaelt> @src liftA2
14:18:14 <lambdabot> liftA2 f a b = f <$> a <*> b
14:18:15 <ReinH> so they live on the heap
14:18:34 <c_wraith> ReinH: They can't live *alone* on the heap
14:18:45 <fizbin> michaelt: Huh. So it comes down to the side-effect order of <*>
14:18:46 <schoppenhauer> michaelt: no.
14:18:56 <c_wraith> ReinH: all heap objects need information so the GC can see if they contain pointers.
14:19:08 <ReinH> c_wraith: I'm just saying: they get reboxed and put in the heap
14:19:17 <c_wraith> ReinH: unboxed values don't have that info, so an unboxed value in the heap must be part of a boxed value. :)
14:19:26 <ReinH> of course :)
14:19:27 <c_wraith> ReinH: they only get put on the heap if they need to be boxed
14:19:27 <michaelt> fizbin: yes, but nothing too strange could happen, if there is a monad instance that coheres with it, no? 
14:19:35 <ReinH> c_wraith: yes, that's what I'm saying :)
14:19:45 <michaelt> schoppenhauer: oh, just asking, I wasn't seeing how. 
14:19:46 <c_wraith> ReinH: for instance, if all you do with those values is arithmetic operations, they never need to be reboxed or go to the heap.
14:20:05 <ReinH> c_wraith: yep, that's why I involved id :)
14:20:12 <ReinH> to force the reboxing
14:20:16 <tejing> fizbin: 1) liftA2 doesn't technically involved monadic side effects, 2) assuming the applicative instance is in agreement with the monad instance, liftA2 should equal liftM2, and behave as you describe
14:20:38 <ReinH> Anyway, my point is just: unboxed values can still sometimes be reboxed, which affects the heap
14:20:39 <c_wraith> ReinH: this is why unpacking a field can actually make performance worse in certain cases - it can require the compiler to insert heap allocation.
14:20:42 <schoppenhauer> michaelt: in a polymorphic function, a variable might have another type
14:20:46 <ReinH> c_wraith: yes, exactly my point
14:21:05 <ReinH> c_wraith: sorry for saying it so poorly that you felt the need to restate it for me ;)
14:21:08 <fizbin> michaelt: Well, I guess that's my question. Is it a requirement to say that a Monad and Applicative instance are "in agreement" that the side effect order for (x <*> y) is "x first, then y"?
14:21:32 <c_wraith> ReinH: well, I certainly had no idea what you meant - but that doesn't necessarily mean you said it badly. :)
14:21:40 <ReinH> c_wraith: :)
14:21:44 <c_wraith> ReinH: sometimes I forget my name, after all. :)
14:22:14 <dolio> ReinH: I think this is probably academic, since the problem in question is about lambda terms, not stuff that can easily be boxed.
14:22:20 <ReinH> c_wraith: I'm pretty sure I did, but I'm glad you were able to piece it back together
14:22:22 <dolio> Er, unboxed.
14:22:44 <tejing> fizbin: yes. (<*>) has to equal ap, which is defined by '\ff fx -> do {f <- ff;x <- fx;return f x}'
14:22:47 <michaelt> fizbin: I think that apart from a monad instance it's hard to say what it means for 'side effects' to be 'ordered'.
14:23:03 <ReinH> fizbin: It's a requirement as of 7.10, previously it was just a suggestion.
14:23:23 <tejing> fixbin: but nothing in the language currently requires that the Applicative instance and the Monad instance for a type agree in any sense. it's just convention
14:23:27 <tejing> fizbin*
14:23:30 <fizbin> michaelt: Sure. I'm using "liftA2" on something that's both an Applicative and a Monad.
14:23:51 <dolio> The specification in the docs requires it. :)
14:23:56 <fizbin> tejing: Fortunately, a convention I can assume the base library follows.
14:24:02 <ReinH> michaelt: I don't think so: f a -> f b -> f (a,b) can have their "side effects" "sequenced" in two obvious ways.
14:24:10 <schoppenhauer> ok got it
14:24:16 <tejing> fizbin: yea
14:24:40 <schoppenhauer> ok not quite
14:24:43 <schoppenhauer> but almost
14:24:49 <tejing> fizbin: except I'm not sure all Monads have Applicative instances even in the base library
14:25:06 <dolio> They do in 7.10.
14:25:16 <dolio> I'm sure they did before that, too, though.
14:25:22 <dolio> In base.
14:25:22 <fizbin> tejing: Well, this compiles, so what I'm using does.
14:25:31 <tejing> most of them do, for sure, just not sure it's every one
14:25:47 <michaelt> ReinH: right, I was saying, when fizbin asked, but does liftA2 op fa fb get the sequence right, fizbin is presupposing the monad instance, and then affirming that the Applicative-Monad connections require agreement on this point
14:26:01 <ReinH> michaelt: fair enough
14:26:43 <ReinH> dolio: btw I'm trying to come up with a good title for a functional pearl
14:27:41 <ReinH> the PL community has a lot of wonderful paper titles in it
14:27:51 <ReinH> No bananas and barbed wire in mine though :(
14:28:04 <Forkk> barbed wire?
14:28:16 <dolio> Well, if you're looking for suggestions, I probably need more information.
14:28:22 <ReinH> Forkk: http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf
14:28:23 <dolio> Unless you're going to write the paper based on the title.
14:28:31 <ReinH> hah
14:28:36 <Forkk> lol
14:28:57 <ReinH> dolio: L-systems are the fixed point of a coalgebra (e.g., hackage.haskell.org/package/lindenmayer-0.1.0.1/docs/src/Lindenmayer-D0L.html#D0L)
14:29:30 <dolio> Hmm...
14:29:32 <ReinH> (generate is more accurately coiter for Cofree Identity)
14:30:54 <dolio> Does that mean they're final coalgebras?
14:30:59 <ReinH> dolio: I believe so.
14:31:43 <Forkk> ReinH, title your paper "Functional Reactive Distributed Monad Pearls with Bananas, Barbed Wire, and Other Fruits"
14:31:51 <ReinH> Forkk: :)
14:32:02 <broma0> what would be considered the recommended approach to starting a haskell project? Determine all of the types and typeclasses before hand? Code like a mad man, creating types as necessary, and then refactor into classes? Not looking for a "design pattern", but is there any literature regarding the steps involved in developing a haskell program?
14:32:20 <ReinH> broma0: write something simple, get feedback, repeat
14:32:32 <Forkk> I will seriously pay $50 (USD) to anyone who writes a serious academic paper with that title
14:32:35 <ReinH> Haskell doesn't require big design upfront
14:32:41 <Forkk> the contents have to be relevant to the title though
14:33:11 <ReinH> broma0: "determine all of the types and typeclasses before hand", in particular, is not the way to go
14:33:14 <broma0> ReinH: interesting.. I've heard that before but i really don't understand why just yet
14:33:20 <ReinH> programs generally grow in the writing
14:33:28 <michaelt> broma0: you should avoid introducing your own classes, I would think, unless something about the project requires it. 
14:33:52 <ReinH> broma0: Do The Simplest Thing That Could Possibly Work.
14:33:54 <exio4> broma0: just write code, refactoring haskell code isn't that hard anyway
14:34:18 <broma0> michaelt: functions that need to work with both bare values and IO values?
14:34:36 <broma0> ReinH: Thats a great motto
14:34:38 <ReinH> dolio: (anyway I think it's an interesting result, and notice that the data type is just a packaging up of the arguments to (>>=)?)
14:34:44 <ReinH> broma0: Kent Beck's
14:35:13 <Kole> hi is anyone familiar with  HDBC-odbc? I am trying to connect to a named mssql instance, but the "\" character throws a lexical error, there must be a way around it 
14:35:33 <dolio> ReinH: Ah. Yes.
14:35:38 <Cale> Kole: "\\"
14:35:53 <dolio> ReinH: And I guess they keep the 'a' around because they aren't using existential types?
14:36:00 <Forkk> broma0, my way of writing code generally involves something like this: 1. Try something that sounds like it might work. 2. If it worked, then you're done, otherwise, go back to step 1.
14:36:04 <Forkk> it works pretty well
14:36:16 <ReinH> dolio: well, the original formulation isn't type theoretic
14:36:16 <Kole> Cale: thank you!!
14:36:21 <Cale> Kole: \ is used for escaping various special characters in strings, so you have to write \\ if you want a literal backslash character
14:36:31 <Cale> Kole: for example \n means newline
14:36:35 <Forkk> plan out a system, try implementing it, when it inevitably falls on its face, throw it out and start over
14:36:43 <ReinH> dolio: it's the usual an alphabet \Sigma with operations blah blah algebraic formulation
14:36:51 <Kole> Cale: makes sense thank you very much
14:37:15 <dolio> ReinH: Anyhow, I don't have any puns for you.
14:37:19 <ReinH> dolio: :(
14:37:20 <dolio> At least, not any good ones.
14:37:29 <broma0> Forkk: I'm on the 109349132th iteration of that with my current project.. my haskell-foo just isnt good enough yet to figure it out
14:37:32 <ReinH> dolio: fair enough, but what do you think of the "pearl"?
14:37:41 <dolio> Sounds good.
14:37:50 <ReinH> cool :)
14:38:06 <Forkk> broma0, what kinds of problems are you running into?
14:38:09 <dolio> Especially if you have pictures.
14:38:24 <ReinH> dolio: https://dl.dropboxusercontent.com/u/632742/turtle.svg
14:38:45 <ReinH> made with https://github.com/reinh/hs-lindenmayer/blob/master/examples/Turtle.hs
14:38:57 <broma0> Forkk: I could write a brief paragraph or two explaining it if you have the time
14:39:31 <schoppenhauer> is it possible to let haskell make every variable "Typeable" without having to declare it explicitly? 
14:39:37 <schoppenhauer> in a package, at least?
14:39:40 <bitemyapp> @djinn (Monad o, Monad l) => o gtg -> (gtg -> gt -> Bool) -> (gt -> Bool) -> l gt -> Bool
14:39:40 <lambdabot> f _ _ _ _ = False
14:39:44 <bitemyapp> god dammit
14:39:49 <Forkk> broma0, maybe if they're short paragraphs :P
14:39:51 <Cale> schoppenhauer: Not really.
14:39:51 <bitemyapp> I need exference.
14:39:53 <broma0> Forkk: they are!
14:39:53 <ReinH> bitemyapp: :p
14:39:59 <schoppenhauer> Cale: and un-really?
14:40:00 <mmachenry> schoppenhauer: This is a proposal for future GHC versions
14:40:03 <Forkk> I can't guarantee I'll be of any help, though :P
14:40:08 <broma0> Forkk: Ill sparknotesify it for ya
14:40:18 <ReinH> bitemyapp: replace Bool with a and try again?
14:40:24 <bitemyapp> ReinH: no, I need exference.
14:40:27 <bitemyapp> I already fired it off.
14:40:30 <ReinH> It's here
14:40:37 <bitemyapp> IT'S TOO LATE
14:40:39 <Cale> schoppenhauer: There might be another way to get the Typeable instances to where you need them by storing them in a GADT
14:40:40 <ReinH> OH NO
14:40:41 <bitemyapp> :D
14:40:45 <ReinH> bitemyapp: :p
14:40:50 <bitemyapp> 21:40 < exferenceBot> could not find expression; aborting after 30 sec
14:40:52 <bitemyapp> fack.
14:40:56 <Cale> schoppenhauer: So that when you pattern match, the Typeable instance becomes available
14:41:00 <bitemyapp> ReinH: yeah I like the Bool into a idea.
14:41:20 <bitemyapp> @djinn (Monad o, Monad l) => o gtg -> (gtg -> gt -> a) -> (gt -> a) -> l gt -> a
14:41:21 <lambdabot> -- f cannot be realized.
14:41:26 <bitemyapp> :exf "(Monad o, Monad l) => o gtg -> (gtg -> gt -> a) -> (gt -> a) -> l gt -> a"
14:41:27 <ReinH> :D
14:41:38 <bitemyapp> I don't think djinn really knows anything about typeclasses.
14:41:42 <bitemyapp> thus exference.
14:41:51 <ReinH> Right, but I don't see how you can write that funciton anyway
14:42:02 <exferenceBot> could not find expression; aborting after 30 sec
14:42:15 <bitemyapp> oh it's definitely a thing
14:42:22 <bitemyapp> though I may have misformulated the "big step" version of it.
14:42:24 <ReinH> idontbelieveyou.gif
14:42:33 <bitemyapp> I'm rewriting existing code that works.
14:42:37 <ReinH> :)
14:42:37 <schoppenhauer> Cale: I don't see what you mean.
14:42:43 <bitemyapp> I'm just trying to to express it as one big thing I can dump on the bot.
14:42:51 <bitemyapp> I'm really lazy.
14:43:06 <ReinH> bitemyapp: I'm just saying *that* type is uninhabited, maybe there's a mistranslation somewhere
14:43:12 <vitalij> Here it sees riga as a function. why?  `pascal riga = [ valore(riga colonna) | colonna <- [1..(riga+1)] ]`
14:43:36 <schoppenhauer> Cale: GADTs are typeclasses, right? with instances. so then I need to put the typeclass before every function.
14:43:38 <ReinH> vitalij: you apply riga to colonna
14:43:42 <Cale> schoppenhauer: no
14:43:48 <Cale> schoppenhauer: GADTs are data types
14:44:04 <ReinH> valdyn: parens are not for function application
14:44:06 <ReinH> woops
14:44:07 <tejing> vitalij: (riga colonna) applies riga to colonna
14:44:08 <ReinH> vitalij: ^
14:44:13 <vitalij> ReinH riga and colonna are just two arguments of valore
14:44:17 <ReinH> No, they are not
14:44:22 <ReinH> parens are not for function application
14:44:31 <tejing> vitalij: then write 'valore riga colonna'
14:44:47 <vitalij> thanks!
14:45:02 <hexagoxel> bitemyapp: how would it extract the gtg from o, when the result is not wrapped?
14:45:06 <bitemyapp> ReinH: well, there's more parametricity here than exists in the real code, but that's why I introduced arguments to break them down in the negative position.
14:45:40 <ReinH> bitemyapp: My concern is that gtg and gl and contained by constructors o and l, respectively, while a is not
14:45:50 <bitemyapp> o is Maybe, l is list.
14:45:59 <bitemyapp> trying to figure out what I fucked up.
14:46:08 <ReinH> bitemyapp: Ok, but with the generality given above, there's no way to "get a gtg aor a gl out of the o and l"
14:46:22 <dcmid> anybody here willing to give some ReadP help?
14:46:22 <ski> what if the list is empty ?
14:46:22 <bitemyapp> I figured the parametricity was making it impossible
14:46:33 <bitemyapp> but that's a mistranslation error and I'm not giving it something it needs.
14:46:39 <ReinH> bitemyapp: sure
14:46:40 <bitemyapp> I just need to figure out what that is.
14:46:46 <ReinH> just letting you know what seems to be the issue
14:47:04 <bitemyapp> without giving it the trivial extraction that doesn't match the real code, thati s.
14:47:10 <ski> dcmid : you should probably just ask the question
14:47:31 <broma0> Forkk: I am implementing a key/value database. The database is divided up into "buckets", where each bucket is it's own key/value store (you can think of the entire database as: 'Map BucketName (Map Key Value)', where the inner map is called a "Bucket". I need the user to be able to decide whether or not a bucket is in-memory or on-disk. If the bucket is in-memory, I really just use Data.Map. If the db is 
14:47:37 <broma0> on-disk, I use readFile/writeFile/etc. In the case of the in-memory bucket, insert/update/delete/fetch are pure. in the case of the on-disk bucket, insert/update/delete/fetch are not pure, they are wrapped up in IO. I need to write an engine that can polymorphically handle both cases. For example, the engine will have a function: 'insert :: Database -> BucketName -> Key -> Value -> {{ Database | IO Databas
14:47:43 <broma0> e }}'
14:48:53 <exio4> you'd always return IO Database 
14:48:57 <Forkk> agreed
14:49:00 <ReinH> broma0: it'll always be in IO
14:49:03 <Forkk> or rather, make your own monad
14:49:06 <Forkk> even if it's pure
14:49:35 <tejing> broma0: fundeps could get you the generality you want there I think
14:49:38 <Forkk> In fact, if you consider the case where the database needs to be accessed by multiple threads, even your in-memory database will need to use IO
14:50:20 <ReinH> tejing: really?
14:50:23 <Forkk> Ultimately, having several functions which are only sometimes IO probably won't work out too well for you. Furthermore, database actions are inherently impure, since they involve outside effects
14:50:34 <ski> broma0 : hm, do you make the in-memory vs. on-disk decision once for all the buckets, or individually for each one ?
14:50:52 <broma0> ski: individually. thats whats awesome!
14:51:01 <tejing> ReinH: actually no... I wasn't thinking it through clearly
14:51:04 <broma0> ski: one bucket could be session store, one could be user store, etc.. 
14:51:08 <Forkk> although I'm sure now we'll get to hear some ways you could do it, which I'm very interested to hear :P
14:51:19 <ReinH> tejing: I was a bit surprised, but I'm wrong a lot, so...
14:51:45 <Forkk> also, is map performant enough to be used as a key-value store with so many values in it?
14:52:02 <ski> broma0 : i suppose you might be able to parameterize `BucketName' with the access monad .. or else, just resort to always using `IO'
14:52:43 <dcmid> I am attempting to parse a range of months (data Month) from a string using ReadP. In the string, the range is formatted as two ints separated by a dash ("5-9" is May through Sept). ReadP keeps coming up with an empty list of months. http://lpaste.net/134139
14:52:56 <exio4> using always IO seems cleaner to me, you'd need to get in the pseudo-dependently typed world of Haskell which is really ugly 
14:52:57 <broma0> Forkk: the reason i say that an in-memory bucket doesnt require IO is that I could simply implement it with Data.Map and the State monad 
14:53:26 <Forkk> broma0, what about multiple threads, though?
14:53:31 <broma0> exio4: That is the idea that seems best to me as well
14:54:01 <ReinH> broma0: yes, but if you want to uniformly access both, you will inherit all of the constraints
14:54:10 <schoppenhauer> Cale: ok. but as far as I see, for GADTs, I have to specify distinct constructors for distinct types.
14:54:11 * hackagebot haverer 0.3.0.0 - Implementation of the rules of Love Letter  http://hackage.haskell.org/package/haverer-0.3.0.0 (jml)
14:54:13 <tejing> broma0: but because a given Database _might_ have buckets that are on disk, you need IO for all interactions with it
14:54:13 <Forkk> honestly it seems like what you want to do *should* be IO anyway, regardless of how it is actually implemented
14:54:28 <schoppenhauer> Cale: and I could do that without GADTs as well, by just having a container type.
14:54:49 <ski> dcmid : and `parseMonth' works ?
14:54:52 <ReinH> I would argue that the main reason it should be in IO is that it's impossible to do otherwise. ;)
14:54:59 <broma0> ReinH: that is the kind of answer i need (and the one i want more elaborately explained :) precisely why will i inherit all of the constraints?
14:55:05 <Forkk> ReinH, is that a challenge?
14:55:09 <dcmid> ski, yes. I have tested it seperately
14:55:16 <ski> dcmid : how is it defined ?
14:55:26 <ski> (you may annotate the paste)
14:55:27 <bitemyapp> ReinH: I think I forgot to include the maybe catamorphism.
14:55:41 <Forkk> honestly it is probably inherently impossible
14:55:49 <ReinH> broma0: What is the type of your function that can lookup a key in either an in-memory db or an on-disk db?
14:55:49 <tejing> broma0: which buckets are stored on disk is run-time information, and the types are compile-time information
14:55:52 <dcmid> ski, http://lpaste.net/134141
14:56:05 <Forkk> broma0, you could probably fudge it, but the main issue here is exactly what tejing said while I was typing this message
14:56:13 <bitemyapp> this probably won't do what I want.
14:56:14 <bitemyapp> :exf "(Monad o, Monad l) => (o gtg -> a) -> o gtg -> (gtg -> gt -> a) -> (gt -> a) -> l gt -> a"
14:56:28 <ReinH> f a b _ _ _ _ = a b
14:56:29 <ReinH> :p
14:56:50 <exferenceBot> could not find expression; aborting after 30 sec
14:56:53 <bitemyapp> ass.
14:56:55 <ski> dcmid : btw, you could use `return $ case month of 1 -> January; ...'
14:56:58 <ReinH> bitemyapp: :p
14:57:00 <bitemyapp> ReinH: oh, I thought you were the bot.
14:57:04 <bitemyapp> sorry -_-'
14:57:04 <ReinH> bitemyapp: hahaha
14:57:09 <hexagoxel> :exf -u "(Monad o, Monad l) => (o gtg -> a) -> o gtg -> (gtg -> gt -> a) -> (gt -> a) -> l gt -> a"
14:57:09 <exferenceBot> \ b c d e f -> b c
14:57:12 <hexagoxel> :p
14:57:16 <ReinH> hexagoxel: -u?
14:57:27 <hexagoxel> allow input to be &unused
14:57:31 <ReinH> ah!
14:57:32 <bitemyapp> still ass.
14:57:37 <ReinH> should that be the default?
14:57:42 <dcmid> ski, good to know. thx
14:57:42 <bitemyapp> ReinH: pls no
14:57:47 <ReinH> ok :)
14:57:52 <bitemyapp> I don't want ass-answers from the bot.
14:57:57 <ReinH> :p
14:58:01 <broma0> tejing: and because of this, the pure case must inherit IO because the bucket may, in fact, be IO at runtime?
14:58:03 <ReinH> it's a perfectly cromulent answer
14:58:14 <tejing> broma0: yes
14:58:26 <broma0> I think i've got my answer.... IO all the way 
14:58:44 <ReinH> broma0: if you try to answer my question, you'll see why :)
14:59:00 <dcmid> ski, This is whats in the console. http://lpaste.net/134142. I could be calling it wrong. I'm pretty new to this.
14:59:12 <broma0> ReinH: attemped to dodge your question :D
14:59:20 <broma0> ReinH: I understand why my thinking was incorrect now
14:59:26 <ReinH> broma0: :)
14:59:33 <broma0> ReinH: thank you.
14:59:46 <broma0> this really is an incredibly helpful room.. go #haskell
14:59:46 <ReinH> broma0: yw
15:00:19 <bitemyapp> :exf "Maybe gtg -> ((a -> Bool) -> [a] -> Bool) -> [gt] -> (gtg -> gt -> Bool) -> Bool"
15:00:24 <ski> > (`runStateT` "5-9") $ do from <- StateT (reads :: ReadS Int); "-" <- StateT lex; to <- StateT (reads :: ReadS Int); return (from,to)
15:00:28 <lambdabot>  mueval-core: Time limit exceeded
15:00:33 <broma0> :wq
15:00:36 <ski> > (`runStateT` "5-9") $ do from <- StateT (reads :: ReadS Int); "-" <- StateT lex; to <- StateT (reads :: ReadS Int); return (from,to)
15:00:41 <lambdabot>  [((5,9),"")]
15:00:42 <broma0> #toomuchvim
15:00:53 <exferenceBot> could not find expression; aborting after 30 sec
15:00:56 <bitemyapp> hnnnnggggggggg
15:01:07 <bitemyapp> I need to stop trying to make the bot do it for me.
15:01:46 <dcmid> bitemyapp, Are you a friend of FmapE?
15:02:27 <bitemyapp> dcmid: query?
15:02:50 <dcmid> bitemyapp, Edward
15:03:26 <bitemyapp> dcmid: I'm asking if I can query you.
15:03:32 <bitemyapp> dcmid: so we don't talk about a third party in public.
15:03:42 <dcmid> bitemyapp, haha. sure. sorry
15:05:46 <ReinH> broma0: (btw you can use :x in place of :wq)
15:06:01 <ReinH> I estimate it took me about 3 years to adjust my :wq muscle memory
15:06:26 <srhb> ReinH: And still no ZZ ?
15:06:40 <broma0> ReinH: yeahh maybe i should retrain myself
15:06:58 <ReinH> srhb: still no ZZ
15:07:13 <srhb> ReinH: feels more mashy to mee, so definitely preferable.
15:07:17 <quchen> ReinH: :wq is not :x though!
15:07:34 <hexagoxel> bitemyapp: please tell me what expression you end up with; i wanna analyze if there is a way to make use of exference :)
15:07:50 <ReinH> quchen: yes, it's a slightly smarter version of :wq, but I suppose there are edge cases
15:08:14 <quchen> It's also much less satisfying to roll over x than it is to roll over wq with two fingers. :-þ
15:08:21 <geekosaur> at one point :x did different things in bsd vs. at&t vi
15:08:28 <ReinH> geekosaur: o_O
15:08:29 <geekosaur> (one saved the other didn't)
15:08:37 <ReinH> that seems awful
15:08:41 <geekosaur> yep
15:08:55 <ReinH> geekosaur: I've only been using vim for a decade so that predates me...
15:09:25 <frerich> broma0: Hm there was a nice blog (or wiki) article about factoring out IO by devising a little DSL which is basically a subset of the IO actions you want to allow (e.g. 'data IOAction = PutStrLn String | ...') and then having a small evaluator for that lnaugage. Alas, I cannot find it anymore. Maybe that would help with your database project.
15:09:39 <ski> dcmid : hm, i need to refresh on `char' and `sepBy' in `ReadP' ..
15:09:45 <bitemyapp> hexagoxel: it's going to be really hard to shrink the context
15:09:50 <bitemyapp> hexagoxel: but when I figure it out, I'll pass it on.
15:10:21 <fizbin> If I'm deep in a "where" clause and I discover I'm doing something that seems to require a type alias to make the code readable, where have I gone wrong?
15:10:21 <ski> dcmid : the error seems to be complaining that your `months <- sepBy parseMonth parseDash' yields an empty list
15:10:46 <hexagoxel> bitemyapp: great :)
15:10:59 <fizbin> I assume I've done something wrong because otherwise scoped type aliases would be a thing, and they apparently aren't.
15:11:37 <dcmid> Yeah... but I ran that same function (just the months <- sepBy... bit) in repl and I didn't get an empty list
15:11:46 <ski> dcmid : what if you spell it out explicitly, like `readP_to_S (do from <- readS_to_P reads; char '-'; to <- readS_to_P reads; return (from :: Int,to :: Int) "5-9"'
15:11:49 <ski> ?
15:11:52 <bitemyapp> hexagoxel: if it gives you any idea, I'm poking at stuff like "traverse any" lol
15:12:00 <tejing> fizbin: is there some reason you can't just let the types be inferred?
15:12:36 <hexagoxel> bitemyapp: ah, the ((a -> Bool) -> [a] -> Bool)
15:13:10 <bitemyapp> hexagoxel: yer
15:13:22 <bitemyapp> currently type-tetris'ing in the REPL
15:13:34 <fizbin> tejing: Well, I'm refactoring this by the "change one function, follow the errors" method and occasionally I find I need internal type signatures to get the errors to guide me in the right direction.
15:13:52 <hexagoxel> bitemyapp: i think for that you need a forall..
15:13:59 <hexagoxel> :exf -c "Maybe gtg -> (forall a . (a -> Bool) -> [a] -> Bool) -> [gt] -> (gtg -> gt -> Bool) -> Bool"
15:13:59 <exferenceBot> \ b c d e ->
15:14:00 <exferenceBot>   case b of
15:14:00 <exferenceBot>       Just g -> c (e g) d
15:14:00 <exferenceBot>       Nothing -> False
15:14:00 <exferenceBot> \ b c d e ->
15:14:02 <exferenceBot>   case b of
15:14:04 <exferenceBot>       Just g -> c (e g) d
15:14:05 <exferenceBot>       Nothing -> True
15:14:11 <hexagoxel> (sorry for spam :/)
15:14:12 * hackagebot ig 0.2.2 - Bindings to Instagram's API.  http://hackage.haskell.org/package/ig-0.2.2 (FelipeLessa)
15:16:36 <hexagoxel> -c is for enabling pattern matching (on the Maybe in this case)
15:16:53 <hexagoxel> that one probably should be default, but it can cause terrible performance..
15:19:10 <ReinH> kristof: ping
15:19:15 <dcmid> ski, I honestly don't entirely understand what that was, but I copied it into the terminal. The first time it said return was applied to too many arguments, so I added a set of parenthesis. Here it is. http://lpaste.net/134143
15:19:29 <kristof> ReinH: pong
15:19:39 <ReinH> kristof: remember when we were discussing L-systems?
15:19:43 <kristof> yes
15:19:48 <kristof> I even linked you that nifty survey
15:19:51 <ReinH> kristof: http://hackage.haskell.org/package/lindenmayer-0.1.0.1/docs/src/Lindenmayer-D0L.html#D0L
15:20:07 <ReinH> :(
15:20:26 <ReinH> :)
15:20:44 <ion> :|
15:20:54 <joneshf-laptop> broma0, fwiw, I've also been looking for something similar to what you've been asking
15:21:07 <ReinH> kristof: it turns out there is a nice representation, as final coalgebras.
15:21:25 <ski> dcmid : hm, yes. one missing closing bracket
15:21:57 <ski>   readP_to_S (do from <- readS_to_P reads; char '-'; to <- readS_to_P reads; return (from :: Int,to :: Int)) "5-9"
15:22:00 <ski> should be
15:22:05 <ski> (sorry)
15:22:49 <ReinH> kristof: note that the data structure just packages (>>=)
15:23:07 <joneshf-laptop> broma0, I've mostly found, "Go explore the woods and become one with nature," rather than, "Here's a survival guide so you don't end up in the scary part of the woods and need to send a flare."
15:23:58 <kristof> ReinH: nifty!
15:24:12 <dcmid> ski, I think it worked. I got [((5,9),"")] back. It doesn't exactly look like a list...
15:24:17 <ReinH> kristof: And despite its generality, this representation is very easy to use too https://github.com/reinh/hs-lindenmayer/blob/master/examples/Turtle.hs
15:24:21 <ReinH> kristof: generated https://dl.dropboxusercontent.com/u/632742/turtle.svg
15:24:28 <kristof> ReinH: What does "in parallel" mean, though?
15:24:47 <dcmid> ski, I assumed that is how ReadS redners a ReadP list?
15:25:05 <ReinH> kristof: it rewrites all terms in parallel
15:25:08 <ReinH> rather than just the first one
15:25:41 <kristof> ReinH: Oh, ok. I was confused by seeing the word parallel and not seeing a call to "par".
15:25:51 <ReinH> ah, I could be more specific
15:26:55 <kristof> ReinH: Your use of the word is really common, i.e. semantic meaning of parallel versus multicore execution. I remember I used to cock my head a little when people would talk about the difference between let and let* in Common Lisp to be "parallel and sequential"
15:27:02 <ReinH> yep :)
15:27:52 <dcmid> ski, Here is the whole file. http://lpaste.net/134145
15:28:07 <kristof> And the CL language dates back to the late 70s, so there's a historical precedent there. But still, when "parallel execution" is the big buzzword nowadays, I am wont to be misled.
15:28:08 <ski> `[((5,9),"")]' is a list, sure
15:28:17 <ReinH> kristof: sure :)
15:28:25 <joneshf-laptop> ReinH, kristof okay L-systems look awesome
15:28:26 <dcmid> ski, The bit we're dealing with is pretty much at the bottom
15:29:12 * hackagebot persistent-sqlite 2.2 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-2.2 (GregWeber)
15:29:14 * hackagebot persistent-mysql 2.2 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-2.2 (GregWeber)
15:29:16 * hackagebot persistent-postgresql 2.2 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-2.2 (GregWeber)
15:29:18 * hackagebot persistent 2.2 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.2 (GregWeber)
15:30:36 <kristof> ReinH: Anyway, the code for the fractals is splendid. 
15:30:43 <ReinH> kristof: :)
15:31:41 <ski> dcmid : btw, i'm not sure you need `skipSpaces' ?
15:32:56 <dcmid> ski, The goal is to parse a CronTab string, which has spaces in it. Don't I need skipSpaces to, well, skip them?
15:36:45 <ski> > (`runStateT` "  5  -  9  ") $ do from <- StateT (reads :: ReadS Int); "-" <- StateT lex; to <- StateT (reads :: ReadS Int); return (from,to)
15:36:48 <lambdabot>  [((5,9),"  ")]
15:37:00 <ski> dcmid : `reads' will skip initial spaces
15:37:34 <dcmid> ski, cool. you just made my code prettier. thanks
15:37:40 <erikd> anyone use the haskell LDAP libarary? trying to do the equivalent of "ldapsearch -H ldaps://xxxx.com sn=Name" with "ldapSearch conn Nothing LdapScopeBase (Just "sn=Name") LDAPAllUserAttrs False" but get an empty response.
15:38:11 <ReinH> kristof: I thought you might like to see that there really is a simple denotation (that uses comonads!) for L-systems :)
15:39:05 <ski>   parseCron = CronTab <$> parseMin <*> parseHour <*> parseDOM <*> parseMonth <*> parseDOW  -- dcmid, if skipping `skipSpaces' works, then this will probably also work
15:39:42 <ski> dcmid : anyway, `parseDashMonth :: ReadP (Month,Month)' would probably be more sensible
15:41:41 <dcmid> ski, parseDashMonth doesn't really do anything. I just had it to test sepBy
15:42:24 <dcmid> ski, and as far as list vs tuple, I will eventually want the months in a full list for their end implementation.
15:43:46 <hunteriam> guys i cant build hmatrix
15:43:49 <hunteriam> im using mingw on windows
15:43:54 <hunteriam> does anyone have experience with it?
15:44:47 <ski> dcmid : point being, i don't see why you'd want to use `sepBy' (or `sepBy1') here
15:45:03 <ski> (also, i'm not seeing why you git the parse error you did)
15:46:10 <dedgrant_> hunteriam: I don't have experience with hmatrix, but I do develop on windows.
15:46:48 <hunteriam> dedgrant_: i think the error is related to _rrandom, which i think is a thing available in the gnu stdlib but not included in mingw
15:46:49 <dcmid> ski, do you have an alternative recommendation to sepBy? I just went with it because it looked like it would work. Thanks for all your help, btw. Don't let me keep you if you've got other stuff going on.
15:46:58 <hunteriam> is there a way to deal with something like that?
15:47:41 <dedgrant_> hunteriam: Can I PM you?
15:47:59 <hunteriam> ya
15:49:13 * hackagebot proton-haskell 0.7 - Simple XML templating library  http://hackage.haskell.org/package/proton-haskell-0.7 (jrbriggs)
15:51:02 <maerwald> I know this is a problematic question, but what's the main area haskell is used these days? I hear some people say "financial software", others say "web development". The only indicator I see would be the availability of libraries... and web frameworks indeed are pretty strong here, no?
15:51:36 <kristof> ReinH: I knew that L-Systems were co-recursive, but looking at the types again I didn't realize how simply comonadic it would be
15:51:49 <srhb> maerwald: I think this arises from the fact that Haskell is so great for creating domain specific languages.
15:51:56 <ReinH> kristof: generate is just coiter for Cofree Identity :)
15:52:08 <srhb> maerwald: So you have your webby DSL, or your financial DSL or ... -- and then Haskell is obviously great at that. :P
15:52:10 <kristof> Right, like we talked about yesterday
15:52:19 <ReinH> kristof: yep :)
15:52:24 <maerwald> srhb: that makes sense, somehow
15:52:43 <srhb> maerwald: I would sum it up thusly: Haskell is great at being great at things.
15:52:52 <srhb> :-)
15:52:54 <ReinH> heh
15:53:11 <ski> dcmid : `sepBy1' would let you parse any (positive) number of months, separated by dashes. `sepBy' would also let you parse a list of zero months
15:53:44 <ski> dcmid : just using `parseMonth' twice, with a call to `char' inbetween, should parse just two month numbers, for your range
15:54:03 <kristof> ReinH: It's beautiful patterns like this that make me appreciate... you know... patterns. :P 
15:54:45 <kristof> ReinH: But really, where others see a for loop, I see a comonad.
15:54:49 <ski> dcmid : something like   (from,to) <- (,) <$> parseMonth <* char '-' *> parseMonth   perhaps
15:55:05 <dcmid> ski, I'll try something along that track. Thanks!
15:55:48 <ReinH> kristof: :)
15:55:59 <ReinH> kristof: colambek's colemma!
15:56:25 <srhb> Sounds like something that might start with "It is not not true that ..."
15:56:50 <ReinH> srhb: but we don't have double negation here in Haskell land
15:56:54 <ReinH> :p
15:57:01 <srhb> :(
15:57:02 <dcmid> ski, I just remembered why I did that. I also need  to be able to parse a single month ("4")
15:57:08 <ReinH> er, double negation elimination, that is
15:57:12 <ReinH> we certainly have double negation
15:58:02 <dcmid> ski, sepBy would let me do that, wheras hardcoding the additional number would make it mandatory
15:58:05 <ski> dcmid : so use `+++' for that alternative ?
15:59:35 <dcmid> ski, I'll look into it. Thank's again. You've helped me get my bearings after looking at the ReadP hackage page for the first time like 5 hours ago
16:00:50 <dcmid> ski, And it works! WOOHOO! have a good evening.
16:01:48 <ski> dcmid : great :)
16:03:07 <broma0> given a function 'a -> b', how can I cleanly apply it to 'm (n a)'
16:03:20 <broma0> to get 'm (n b)'
16:04:23 <ion> broma0: (fmap . fmap)
16:04:25 <tejing> broma0: fmap . fmap
16:04:28 <pavonia> :t fmap . fmap
16:04:30 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:04:37 <broma0> :D
16:04:40 <broma0> thank you!
16:05:12 <ski> (assuming `m' and `n' are `Functor's)
16:07:37 <pdxleif> dibblego: Maybe http://hackage.haskell.org/package/geodetics could also be in the Geography or Geometry categories or something?
16:09:15 <pdxleif> dibblego: Was basically looking for something like this matlab function: http://www.mathworks.com/help/map/ref/areaint.html
16:11:41 <SrPx> "zipper is just the differential of the algebraic representation of the type" o.o wa
16:13:09 <pdxleif> woo: http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
16:19:14 * hackagebot ndjson-conduit 0.1.0.1 - Conduit-based parsing and serialization for newline delimited JSON.  http://hackage.haskell.org/package/ndjson-conduit-0.1.0.1 (srijs)
16:27:58 <ski> SrPx : it's slightly more complicated than that
16:28:38 <broma0> \quit
16:49:52 <eZanmoto> Something I've been curious about recently, might simply be a design preference, but is there a reason you can create a tuple type dynamically in Haskell but not a disjoint union?
16:50:10 <eZanmoto> *disjoint union type
16:50:25 <tejing> what do you mean by 'create dynamically'?
16:51:13 <subleq> what's the canonical http client?
16:51:36 <eZanmoto> Sorry, bad phrasing, but I'm referring to the fact that you don't "statically" define tuple types.
16:52:48 <srhb> eZanmoto: That still makes little sense to me. It sounds like you're talking about polymorphism, but I'm not sure.
16:53:00 <tejing> eZanmoto: still no idea what you mean here either
16:54:16 <eZanmoto> Sorry, I'll try to phrase it better - I can define a function signature `f : a -> b -> (a, b)` but I can't define `f : a -> b -> (a | b)`, i.e. I can't define the disjoint union type "on-the-fly", so to speak.
16:54:31 <srhb> Sure, Either?
16:54:49 <srhb> data Either a b = Left a | Right b
16:54:50 <tejing> eZanmoto: f :: a -> b -> Either a b
16:54:53 <joehillen> Is there a way to specify that 7.10 is required in the cabal file?
16:54:55 <shinka> I want to import the Data.Map module, with the type Data.Map.Map simply named "Map" instead of "Map.Map". So I write "import qualified Data.Map as Map" and "import Data.Map(Map)". It works! But ghc complains about the redundancy, I tried hiding Map from the qualified import but it fails. What's the idiomatic way to do this?
16:55:44 <eZanmoto> But this is limited to just two types - I can define `(a, b, c)` but I can't define `Either a b c` - I'd have to create a new type. This is more a philosophical question that looking for a solution to a problem.
16:55:51 <tejing> eZanmoto: the only real difference here is there's syntactic suger for '(,)' and not for 'Either'
16:55:57 <pavonia> joehillen: Set the corresponding base package version as a dependency
16:56:02 <srhb> eZanmoto: I think your hiccup is product vs coproduct
16:56:26 <tejing> eZanmoto: triples and pairs are totally different types too... there's just some nice syntax for tuples that doesn't exist for sum types
16:57:54 <eZanmoto> tejing: That's what I'm referring to though - triples and pairs are different types, but you don't have to declare them in advance of using them. I'm just wondering why there isn't such a way of doing the same with disjoint unions.
16:58:18 <eZanmoto> srhb: What do you mean?
16:58:20 <pavonia> shinka: "import qualified Data.Map hiding (Map) as Map", I think
16:58:40 <tejing> eZanmoto: so basically you're saying the prelude should include several sizes of generic sum types 'out of the box'?
16:58:42 <srhb> eZanmoto: Hmm. okay, i think I understand what you're getting at, and I think the answer is the coproducts need tagging.
16:58:48 <pavonia> shinka: Maybe the "as Map" comes first
16:59:06 <eZanmoto> tejing: Is that what is done for tuples?
16:59:20 <srhb> eZanmoto: Yeah, there's a huge amount of definitions for n-tuples
16:59:24 <srhb> eZanmoto: Well, n definitions :-)
16:59:35 <srhb> You can't actually have them arbitrarily sized, but they go up quite a while.
16:59:50 <tejing> eZanmoto: srhb: I think they go up to 15 or so
16:59:53 <Enigmagic> 63 or something now
16:59:55 <eZanmoto> srhb: Ah, that makes sense so, I thought it was handled by the compiler. My mistake!
17:00:14 <srhb> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
17:00:16 <lambdabot> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n,
17:00:16 <lambdabot> o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52)
17:00:19 <srhb> Gorgeous
17:00:26 <orbital> bayhac, where is your schedule
17:00:31 <joehillen> the tuple from hell
17:00:41 <eZanmoto> Kinda disappointing in a way, for some reason :'|
17:00:54 <srhb> eZanmoto: Yep. But it needs a stronger type system otherwise.
17:01:01 <srhb> eZanmoto: Especially for coproducts, since they need tagging.
17:01:19 <tejing> eZanmoto: with some extensions you could define a type level cons-cell style construction and overloaded field accessors, but it would be a lot of machinery
17:01:39 <eZanmoto> srhb: Yeah, I figured that tagging was the case here, but you could still have a lightweight syntax when the types are distinct.
17:02:00 <srhb> eZanmoto: Yeah. But currently that would require Special Magic, and I'm not sure that's any nicer.
17:02:10 <eZanmoto> tejing: True, and I'm guessing you're bordering on a dependent type system at that stage
17:02:14 <srhb> Indeed.
17:02:16 <tejing> yea
17:02:44 <eZanmoto> Makes sense. Thanks for answering my idle curiosity :-)
17:04:09 <Enigmagic> orbital: i think they're still finalizing the schedule, i have a draft of it from saturday.
17:04:18 <Enigmagic> probably will get the final one out in the next day or two
17:04:35 <shinka> pavonia: OK thanks!
17:05:12 <orbital> Enigmagic: thanks, I just found the link in the top right. Sneaky.
17:06:01 <Enigmagic> orbital: ah, didn't know he published it already :)
17:07:12 <onr> hi
17:07:30 <srhb> ooo, I didn't know there was a symbol for n-ary coproduct.
17:07:59 <simon> srhb: I'm not sure what I did before (,,,,,,,,,,,,,,,,,,,,,,,,,,).
17:08:06 <srhb> simon: I know, such a time saver!
17:08:22 <simon> what is that called, by the way, the cthulhu operator?
17:08:35 <srhb> simon: n-ary cthulhu, yeah
17:09:08 <simon> some functions are anonymous because giving them humanly pronuncable names would drive you mad.
17:09:10 <srhb> Giving rise to the very specific Haskell style: Untagged cthulhu sum programming.
17:09:18 <srhb> er, product*
17:09:31 <srhb> simon: :-)
17:09:44 <simon> I'm not sure what that refers to... tuples being products?
17:09:57 <srhb> Yeah.
17:10:09 <simon> and untagged means what?
17:10:39 <srhb> simon: As opposed to meaningful and specific value constructors; ie Person Name Age ...
17:10:48 <srhb> Which would be a "tagged product"
17:10:56 <srhb> (Totally made up terminology, here)
17:11:02 <simon> ah.
17:11:15 <simon> btw, did you do any haskell web programming recently?
17:11:20 <srhb> simon: Yes :)
17:11:27 <onr> which framework?
17:11:33 <srhb> Snap is my drug of choice currently. 
17:11:34 <simon> I've wanted to try out that library called servant.
17:11:47 <onr> snap is still better than others?
17:11:49 <srhb> simon: It's pretty cool :)
17:11:54 <srhb> onr: Matter of taste. And requirements.
17:13:08 <simon> I remember liking Snap the most of those frameworks, but I've never enjoyed frameworks in general.
17:13:29 <onr> so you are CGI type of guy? :)
17:14:03 <srhb> simon: Likewise, which I suppose is part of the reason for Snap. It feels very lightweight while still being quite batteries-included.
17:14:14 <hpc> have a cronjob analyze the access logs to update some internal server state and modify some static .html files
17:14:58 <simon> onr: I just prefer them really simple. Python's Flask, for example.
17:15:18 <srhb> simon: There's also Scotty (and Spock, which I guess is the moral successor) -- which feels more Flask like yet.
17:15:37 <simon> srhb: yup, I do like scotty. haven't tried spock.
17:15:45 <onr> simon: bu-but python doesn't do no type checking!
17:15:56 <srhb> simon: Afair Spocks gives you type safe routing out of the box, which is nice.
17:16:31 <bitman_> ahoy
17:17:51 <simon> onr: I just mean that I like the framework in terms of simplicity. but I haven't done large-scale web-development for many years, so I can't really defend my tendency towards minimalism for practical purposes.
17:18:15 <onr> simon: do you like php's minimalism?
17:18:47 <srhb> ... :P
17:19:15 <ReinH> PHP is many things, minimalist is not one of them
17:20:36 <simon> onr: yes and no. I don't have any strong opinions on PHP any longer.
17:21:55 <bitemyapp> ReinH: PHP is the Katamari of Pleb PL
17:22:26 <bitemyapp> https://www.youtube.com/watch?v=cwhFH75OCDs
17:22:32 <phaazon> @hoogle f (f a) -> f a
17:22:33 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
17:22:33 <lambdabot> Test.QuickCheck.Property joinRose :: Rose (Rose a) -> Rose a
17:22:33 <lambdabot> Prelude concat :: [[a]] -> [a]
17:22:37 <srhb> Since we're on the topic, what are peoples' favourite backends for reflex.dom driven clients?
17:22:51 <srhb> I would imagine Servant might be a good fit, but I think ryantrinkle and co use Snap.
17:22:52 <phaazon> hm, nevermind
17:23:04 <Earnestly> When will Haskell fix it's getAppUserDataDirectory function to stop using "dotfiles" on Linux systems?
17:23:28 <Earnestly> Because apparently people think it's acceptable to do this practice because this function tells them so
17:23:52 <phaazon> I don’t even know that function
17:24:01 <Earnestly> Hmm
17:24:02 <phaazon> a function which has a concept from Windows…
17:24:04 <phaazon> holy shit.
17:24:32 <Earnestly> Yes, Windows and OSX have standards for how developers should deal with user specific cache and configuration data
17:24:43 <Earnestly> So does Linux, but it abuses an ancient UNIXv2 bug instead
17:24:48 <phaazon> yeah sure
17:24:48 <phaazon> like
17:24:53 <phaazon> raping the registry
17:24:54 <Earnestly> "On Unix, this function returns $HOME/.appName"
17:25:02 <Earnestly> This is unwelcome
17:25:13 <bitemyapp> Earnestly: patch it?
17:25:14 <phaazon> lambdabot: pix or never happened
17:25:15 <Earnestly> phaazon: It has nothing to do with the registry
17:25:33 <phaazon> Earnestly: I was talking about the “Windows has standards for developers3
17:25:35 <phaazon> ”*
17:25:40 <phaazon> which makes me laugh
17:25:49 <Earnestly> phaazon: What great insight you have
17:26:00 <bitemyapp> Earnestly: in all likelihood, you care more about this than any existing GHC/libraries@ dev, so it won't happen unless you propose it or put up a strawman patch.
17:26:04 <Earnestly> Perhaps if developers followed those standards instead of abusing it, it might not be a problem?
17:26:16 <phaazon> it might
17:26:20 <exio4> Erebe: what's wrong with using dotfiles?
17:26:26 <exio4> Earnestly: *
17:26:31 <exio4> sorry Erebe :P 
17:26:40 <tejing> same question here... isn't that exactly the right thing?
17:26:58 <Earnestly> exio4: It pollutes the users HOME with almost no control over where things are placed.  It also doesn't differentiate between cache data and configuration data
17:26:58 <phaazon> oh you’re Earnestly from #archlinux
17:27:05 <phaazon> I haven’t recognized you yet
17:27:06 <phaazon> funny.
17:27:28 <Earnestly> exio4: https://plus.google.com/+RobPikeTheHuman/posts/R58WgWwN9jp
17:27:46 <tejing> Earnestly: but it is the accepted convention in linux
17:28:07 <Earnestly> exio4: And if you think it's sane to provide instead a unique snowflake environment variable to control this, then think about the people who have almost 50 to a 100 of these things bloating the environ for /every/ process
17:28:14 <Earnestly> tejing: Not anymore
17:28:22 <Earnestly> tejing: And hasn't been for years
17:28:40 <Earnestly> Even util-linux doesn't use it anymore
17:28:47 <Earnestly> Nor does Jack, or git
17:29:09 <acowley> Earnestly: The easiest way forward is to provide a package on hackage that does this correctly.
17:29:22 <bitemyapp> System.Directory.ThatDoesntSuck
17:29:26 <Earnestly> acowley: People have, but they don't use it because of this annoying function in the standard
17:29:48 <BlueProtoman> @hoogle f (f a) -> f a
17:29:49 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
17:29:49 <lambdabot> Test.QuickCheck.Property joinRose :: Rose (Rose a) -> Rose a
17:29:49 <lambdabot> Prelude concat :: [[a]] -> [a]
17:30:02 <bitemyapp> Earnestly: that function is not in the standard.
17:30:06 <acowley> Earnestly: Is it packaged with other things like bitemyapp suggested there?
17:30:19 <bitemyapp> Earnestly: and I tried to tell you earlier you could patch it.
17:30:22 <Earnestly> bitemyapp: https://hackage.haskell.org/package/xdg-basedir
17:30:24 <acowley> Earnestly: Because getting it fixed in base will take a long time
17:30:31 <Earnestly> acowley: Right.
17:30:41 <Earnestly> acowley: That's what is really disappointing
17:30:54 <bitemyapp> the main problem is breakage.
17:30:59 <bitemyapp> it's breakage that won't get caught by the type system.
17:31:01 <phaazon> yeah
17:31:04 <phaazon> I don’t have that function
17:31:06 <bitemyapp> so, not really kosher.
17:31:18 <Earnestly> Oh and the Applicative superclass wasn't?
17:31:33 <acowley> So, calling it XDG isn't going to pickup cross playtform users
17:31:41 <acowley> And it doesn't do anything special for OS X, either
17:31:46 <Earnestly> acowley: And?
17:31:49 <bitemyapp> Earnestly: you think they're the same class of error?
17:31:59 <Earnestly> bitemyapp: Yes, actually
17:32:05 <acowley> Earnestly: Well you said that nobody uses it
17:32:06 <bitemyapp> it's demonstrably not.
17:32:19 <acowley> Earnestly: I'm suggesting why that is
17:32:28 <bitemyapp> AMP didn't cause runtime errors, lost/corrupted data, anything like that.
17:32:32 <Earnestly> acowley: I said no one uses that because Haskell thought it was clever to add a standard function which attempts to "guess" standard locations
17:32:40 <bitemyapp> Changing the behavior of that function without changing the type very well could.
17:32:45 <bitemyapp> Earnestly: it's not part of the standard.
17:32:52 <bitemyapp> you keep using that word, that's not what it means.
17:33:13 <acowley> Earnestly: Okay, but I disagree with your assessment. They don't use it because a broken version is found in base, they can't find an alternative, and the alternative doesn't work on OS X.
17:33:15 <Earnestly> bitemyapp: The directory package is not part of haskell? Hm
17:33:16 <bitemyapp> there is a standard, this function is not part of it.
17:33:23 <dolio> This has already been hashed out in the directory issue tracker, and the issue is closed.
17:33:31 <acowley> Huzzah!
17:33:41 <hpc> paradox resolved
17:33:49 <dolio> The version with the relevant code hasn't been released yet, though.
17:34:02 <bitemyapp> Earnestly: https://github.com/haskell/directory/issues/6#issuecomment-60478807
17:34:04 <Earnestly> bitemyapp: If it's not standard, why is it developed as part of the haskell repo?
17:34:17 * hackagebot fb 1.0.11 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-1.0.11 (FelipeLessa)
17:34:22 <bitemyapp> Earnestly: are you asking me to explain the difference between the Haskell Report and base?
17:34:25 <phaazon> Prelude System.Directory> getAppUserDataDirectory "test"
17:34:25 <phaazon> "/home/phaazon/.test"
17:34:29 <phaazon> sounds good to me
17:34:51 <bitemyapp> dolio: thank you
17:34:51 <Earnestly> phaazon: Yet more directories that I can't look at and say "I created this" in my home directory?
17:35:20 <dolio> Complaining here does nothing except make this place more unpleasant.
17:35:25 <tejing> indeed
17:35:35 <Earnestly> bitemyapp: I don't consider the report to be "the standard", I consider everyting haskell blesses in its repo as the standard, that is, standard to haskell
17:36:01 <hpc> ghc isn't haskell
17:36:42 <phaazon> Earnestly: that you can’t look at?
17:36:46 <phaazon> I don’t really get your point here
17:37:58 <Earnestly> dolio:  I suppose you're right.  But this frustrates me, that people still think this behaviour is acceptable.  People have gone to great lengths to try and combat this pollution of HOME from LD_PRELOAD hacks (libetc) and even fuse implementations (rewitefs).  Instead we have a mess of environment variables which bloat the environ.  Fortunately lots of people are switching to xdg basedir but it doesn't help
17:38:00 <Earnestly> when library functions part of a programming language decide to arbitrate where things should go and never update
17:38:27 <Earnestly> dolio: We don't dump binaries in /etc or place cache data in /bin.  Why do that in HOME?
17:38:32 <dolio> That was a hint.
17:38:34 <phaazon> Earnestly: what would you expect that function to do, actually?
17:39:04 <Earnestly> phaazon: If XDG_*_HOME is not defined, fallback on the standard location
17:39:33 <geekosaur> I would like to point out here that, just as ghc is not Haskell, Linux is not the only OS
17:39:42 <Earnestly> It's merely an abstraction which provides a heck of a lot more flexability.  Consider running with a different configuration?  Simply change the environment.
17:39:48 <srhb> Yeah, except ghc is totally Haskell.
17:40:01 <phaazon> Earnestly: XDG_*_HOME?
17:40:04 <phaazon> never heard of that :(
17:40:17 <geekosaur> and the XDG stuff is nigh on meaningless on some non-Linuxes (e,g. OS X)
17:40:38 <Earnestly> phaazon: See: http://sprunge.us/OBRJ?rst for an essence of how they work
17:41:01 <Earnestly> geekosaur: OSX and Windows have their own standard locations, they're standards are meaningless on Linux but Haskell (directory) still supports them
17:41:09 <Earnestly> their*
17:41:34 <acowley> Does it really support OS X?
17:41:34 <glguy> I have exactly one use of ~/.local on my computer, SpaceChem. Fun game :)
17:42:00 <Earnestly> glguy: I have many
17:42:26 <hpc> Earnestly: you're mistaking support for one thing in one package to be "this is better than that"
17:42:27 <Earnestly> glguy: Lots of projects which switched to XDG basedir kept legacy code which will use legacy locations if present
17:42:48 <hpc> the location for home isn't standard, and it's obviously not standard what environment variable points to the home
17:42:56 <Earnestly> Yes it is standard...
17:43:54 <Earnestly> And it as well is abstracted behind an environment variable for setups which use, for example, home directory hashing.  The HOME environment variable.
17:43:58 <geekosaur> except when it's not
17:44:00 <pacak> Anybody used machines?
17:44:01 <pacak> @hackage machines
17:44:01 <lambdabot> http://hackage.haskell.org/package/machines
17:44:07 <phaazon> pacak: I tried to
17:44:15 <phaazon> but I fell back onto pipes
17:44:18 <acowley> pacak: Yes!
17:44:22 <pacak> phaazon: Why?
17:44:22 <hpc> and directory uses HOME when available
17:44:31 <phaazon> pacak: because it was more intuitive to me
17:44:38 <hpc> XDG uses something different
17:44:41 <phaazon> but I guess machines is pretty good as well
17:44:42 <pacak> acowley: Do you have anything good/bad to say about it?
17:44:43 <phaazon> you know
17:44:44 <hpc> i could write HPC_HOME
17:44:45 <Earnestly> geekosaur: If HOME is not defined then you use get the pwd->pw_dir of the user's UID
17:44:47 <phaazon> it’s from edwardk 
17:44:50 <geekosaur> because there are programs that use getpwnam(getlogname())->pw_dir and programs that use getpwuid(cuserid())->pw_dir, not always for obvious or sane reasons
17:44:50 <phaazon> it cannot be wrong.
17:44:52 <phaazon> :)
17:44:53 <Earnestly> geekosaur: If that is not set, then it is undefined by POSIX
17:44:57 <geekosaur> and specifically ignore $HOME
17:45:01 <hpc> it still won't get supported in directory because directory isn't the uberlibrary for locating files
17:45:20 <pacak> phaazon: How was it performance wise?
17:45:21 <hpc> you might as well be complaining about GHC.IO.Encoding.Iconv
17:45:24 <Earnestly> geekosaur: The correct proceedure is to check HOME, falling back to getpwnam, which is configured correctly in passwd
17:45:25 <geekosaur> also, you seem to think POSIX is a useful standard
17:45:28 <geekosaur> POSIX has one purpose
17:45:35 <hpc> write a compatibility package and see if it stands on its merits
17:45:43 <geekosaur> that purpose is to make as many vendors as possible compliant with the least number of changes
17:45:46 <acowley> pacak: I think it works pretty well. My concurrent-machines package on GH adds concurrency features pretty smoothly. Its library is much smaller than pipes.
17:45:53 <luzie> this discussion is about the Linux case for this function only, and there are clear standards for this that software follows on Linux
17:46:03 <geekosaur> it is emphatically NOT to provide a useful standard for development.
17:46:08 <Earnestly> This is tedious
17:46:14 <hpc> "why does ghc support iconv and not luit" is a pretty ridiculous question
17:46:18 <geekosaur> and people who rely on it for that get screwed over REGULARLY by the POSIX standard committee
17:46:25 <Earnestly> I like the stawman arguments
17:46:32 <Earnestly> straw* and tangental nonsense
17:46:33 <pacak> acowley: Well, that's what I think as well, just was looking for less obvious problems.
17:46:42 <bitemyapp> acowley: http://hackage.haskell.org/packages/search?terms=machines+concurrent :(
17:47:01 <tejing> Earnestly: you've been driving the channel there for 10 mins and you're surprised you got there?
17:47:11 <bitemyapp> pacak: I was going to say, "bidirectionality isn't baked in", but that's not really true anymore.
17:47:13 <pacak> bitemyapp: github
17:47:17 <bitemyapp> pacak: I know where it is
17:47:24 <hpc> and even if we were going to stick to a standard, XDG isn't it
17:47:26 <bitemyapp> pacak: I'm whining at acowley for not pushing it to Hackage :P
17:47:30 <Earnestly> hpc: Why?
17:47:36 <hpc> the only "standard" i could find is on freedesktop.org
17:47:37 <pacak> bitemyapp: I see :)
17:47:40 <hpc> it has one author
17:47:55 <Earnestly> hpc: Congratulations for not being able to search?
17:48:02 <Earnestly> that means, "we're not going to use it!"?
17:48:02 <albeit> Is there a version of foldM that collects each accumulator?
17:48:16 <luzie> xdg is the standard on linux that software usually follows, so it is the one to follow
17:48:19 <pacak> acowley: I saw your concurent-machines as well :)
17:48:25 <phaazon> albeit: like a scanM?
17:48:27 <codygman> Given `data SumVals = MyVal1 Int | MyVal2 Int` is there a way for me to get the list of constructors like `[MyVal1, MyVal2] :: [SumVals]`
17:48:37 <tejing> albeit: just scan then sequence
17:48:45 <phaazon> @hoogle sequence . scan
17:48:47 <phaazon> oops
17:48:51 <phaazon> :t sequence . scan
17:48:52 <srhb> codygman: The value constructors are not values of type SumVals
17:48:54 <albeit> Ah I didn't know about scan, awesome,. Thanks!
17:48:55 <srhb> codygman: So no.
17:48:59 <phaazon> :)
17:49:18 <hpc> it's not what my system uses
17:49:18 <subleq> in a `StateT Session IO Tree` i want to run a `StateT Session IO Node` using the same state
17:49:28 <lambdabot> Parse error:
17:49:28 <lambdabot>   sequence . scan
17:49:28 <lambdabot>             ^
17:49:28 <lambdabot>     Not in scope: ‘scan’
17:49:28 <lambdabot>     Perhaps you meant one of these:
17:49:28 <codygman> srhb: Alright, thanks.
17:49:30 <lambdabot>       ‘scanl’ (imported from Data.List),
17:49:38 <phaazon> woh, lambdabot is lagging :(
17:49:40 <subleq> is there a simple way to do that?
17:49:50 <hodapp> codygman: Data.Data or GHC.Generics could possibly get you there, but as srhb said, the constructors aren't of that type - they're Int -> SumVals.
17:49:59 <Earnestly> hpc: That's fairly anecdotal though, I could say the opposite quite easily
17:50:02 <phaazon> subleq: I don’t get your issue
17:50:04 <subleq> or do i have to get the outer state, runStateT the Node action, then update the outer state?
17:50:16 <phaazon> StateT Session IO is a monad
17:50:26 <Enigmagic> codygman: Data.Data and GHC.Generics both work for that, as does template haskell
17:50:28 <phaazon> you can mix StateT Session IO Tree with StateT Session IO Node
17:50:32 <Earnestly> hpc: My home directory has about 4 hardcoded locations that will never change (too much legacy), about 4 more due to crusty compilers and about 80 in xdg
17:50:43 <phaazon> you should look at the definition of (>>=) ;)
17:50:46 <hpc> okay, another way
17:50:55 <hpc> of the maybe 20 or 30 systems i have access to, none of them uses xdg
17:50:57 <Earnestly> hpc: util-linux supports xdg
17:51:00 <acowley> bitemyapp: Okay, I'll push it to hackage soon. It seems like the Without Remorse rewrite of machines is semi-permanently stalled.
17:51:05 <hodapp> Enigmagic: What's the TH method of doing this? (roughly)
17:51:06 <luzie> Earnestly: https://github.com/haskell/directory/issues/6#issuecomment-96468993 it's fixed and might be in 7.12
17:51:24 <codygman> Enigmagic: I know that Data.Data requires an an instantiated value, does GHC.Generics as well? I'm going through it, but new to that library.
17:51:29 <subleq> phaazon: ok, i think i misdiagnosed this error
17:51:30 <Earnestly> luzie: You're my hero, thank you so much for finding that
17:51:38 <Earnestly> luzie: I couldn't find anything for toffee
17:51:59 <bitemyapp> acowley: ahhh yes. I think a lot of people were holding their breath on that one but it seems like the constant factors aren't worth it according to Da Man.
17:52:03 <dolio> That was pointed out about 20 minutes ago.
17:52:06 <Enigmagic> hodapp: can't remember offhand but there are a lot of examples out there that do that. go check lens and aeson.
17:52:10 <luzie> well, sorta fixed
17:52:13 <phaazon> subleq: yeah, I don’t get it. Take time to reformulate :)
17:52:21 <Earnestly> dolio: You never said anything about it being fixed
17:52:24 <Enigmagic> codygman: GHC.Generics doesn't require a value
17:52:24 <Earnestly> dolio: You said it was closed
17:52:33 <dolio> You didn't go read the issue.
17:52:38 <subleq> somehow i'm ending up with a StateT String IO (StateT String IO Tree)
17:52:39 <Earnestly> dolio: You linked it?
17:52:40 <acowley> bitemyapp: Indeed. Another person (roche?) did benchmarks of the prototype package showing its high constant factors, too.
17:52:44 <bitemyapp> Earnestly: I linked it at you.
17:52:51 <dolio> It was linked after I mentioned it. You also didn't even try to find it.
17:52:57 <Earnestly> bitemyapp: Ah, then I apologise as I didn't see it
17:53:02 <subleq> err, s/String/Session/ (i just used an alias to make the purpose of the string more clear)
17:53:06 <bitemyapp> acowley: yeah it was roche. He did really good benchmarks of mtl and the alternatives too.
17:53:13 <phaazon> subleq: right, I see the problem now
17:53:14 <bitemyapp> acowley: it's basically never worth it, as it stands right now.
17:53:25 <acowley> bitemyapp: I could never read the graphs he produced, but I got the gist of it
17:53:29 <hodapp> codygman: seconded on GHC.Generics for that. I use it now to avoid having to create a value.
17:53:39 <srhb> subleq: This might be obvious, but always consider whether you _really_ need nested state as it complicated matters (ie. inner cannot "write back" to outer)
17:53:40 <bitemyapp> acowley: and the separation of plans and machines hopefully means you are less likely to mix things up.
17:53:47 <acowley> bitemyapp: Don't you love how silver bullets do exist and don't work? :P
17:53:48 <hodapp> codygman: it can be slightly trickier to use it with a Proxy but there's an Aeson example I'll look up if you remind me tomorrow
17:53:56 <phaazon> subleq: if you want to run StateT String IO Node
17:54:10 <bitemyapp> acowley: Haskell: We Tried.
17:54:11 <phaazon> you have to use some kind of an adapter function
17:54:12 <subleq> srhb: the inner can't?
17:54:15 <acowley> hahha
17:54:18 * hackagebot uri-bytestring 0.1.3 - Haskell URI parsing as ByteStrings  http://hackage.haskell.org/package/uri-bytestring-0.1.3 (MichaelXavier)
17:54:19 <subleq> i need the inner to be able to
17:54:23 <bitemyapp> acowley: I'm contemplating stm-graphs with Volkov because I don't trust fgl.
17:54:35 <srhb> subleq: Hence, don't nest them. Instead combine the states into just one state.
17:54:39 <codygman> Thanks Enigmagic and hodapp.
17:54:46 <phaazon> adapt :: (s -> Session) -> StateT s IO a -> StateT Session IO a
17:55:07 <Earnestly> bitemyapp: Sorry for being too harsh, I was told quite emphatically to go fuck myself because this is what Haskell uses.  I didn't appreciate the weak arguments and lame strawmen from people like geekosaur and hpc, but it appears this has been addressed adequately, sorry again
17:55:20 <acowley> I wasted months on graphs a couple years ago. It's really frustrating work. It's hard to get something other than wildly unsafe code to be remotely competitive performance-wise.
17:55:21 <Earnestly> bitemyapp: (That is, not in this channel)
17:55:41 <bitemyapp> acowley: ikr
17:55:58 <phaazon> subleq: such a function is pretty simple to write with runStateT :)
17:56:07 <subleq> oh jeeze, i think it was a simple error (i had return $ case ... of ... -> return $ ...
17:56:16 <bitemyapp> acowley: what I'm trying to figure out is if there's a happy medium for STM container granularity for graphs that isn't insanely complicated or have nutty rebalancing behavior.
17:56:39 <acowley> bitemyapp: If you do use STM, keep an eye on performance. I'm not sure it will prove worth it, so it'd be good to recognize if that's the case earlier rather than later.
17:56:57 <hodapp> Ugh. I wish Earnestly would keep out if he's going to give attitude like that.
17:56:57 <bitemyapp> acowley: I don't like STM's performance, but I'm not going to attempt this with MVars.
17:57:08 <bitemyapp> acowley: I need to be able to safely "link up" transactions of sub-clusters/nodes
17:57:09 <geekosaur> maybe someday you will learn the difference between a dstandard and a convention
17:57:11 <acowley> bitemyapp: Yeah, that makes sense
17:57:19 <geekosaur> and that assertion does not turn convention into standard
17:57:25 <hodapp> geekosaur: He's gone.
17:57:28 <srhb> geekosaur: He's gone, the topic can die now :)
17:57:37 <phaazon> god I LOVE the AMP changes :3
17:57:40 <bitemyapp> acowley: maybe if I know what I want in terms of granularity/behavior, it can be locked down into a final MVar impl but for now i'd rather just use STM.
17:57:46 <phaazon> length being implemented in terms of Foldable
17:57:46 <acowley> Can I ask one more question on the topic? What does XDG stand for?
17:57:57 <geekosaur> "X Desktop Group"
17:58:11 <acowley> bitemyapp: Yeah, I think a DSL that generated nasty pointer code is the right way to do it.
17:58:11 <phaazon> and I got surprised to see that null is also defined in terms of Foldable
17:58:12 <geekosaur> which was the original name of the freedesktop.org folks
17:58:15 <phaazon> that’s amazing
17:58:19 <acowley> geekosaur: Thank you
17:58:36 <tejing> geekosaur: I think in a certain limited context he was sort of right. he just couldn't think outside that context
17:59:02 <rvxi> hello
17:59:11 <geekosaur> yes, indeed. and, well, I often find myself ramming into that as a brick wall and getting frustrated :(
17:59:31 <geekosaur> (and usually end up expressing myself poorly and/or injuriously)
17:59:58 <phaazon> rvxi: heya
18:00:09 <rvxi> hi phaazon
18:00:27 <bitemyapp> acowley: ouf.
18:00:38 <bitemyapp> acowley: probably right, but ouf.
18:00:47 <hodapp> tejing: I've dealt with him before. I'm fairly sure he's rather young, and has yet little experience to humble away some of the marked condescension.
18:00:52 <hodapp> it'll go away in time.
18:01:08 <srhb> We can relegate the meta discussion to -blah or /dev/null too :-)
18:01:23 <bitemyapp> srhb: yes pls
18:01:48 <rvxi> watching FFI tutorial...
18:02:03 <phaazon> hodapp: same here
18:02:14 <phaazon> he treated me like shit as I needed help on #archlinux
18:02:16 <hodapp> phaazon: yeah, I see that's already mentioned in #haskell-blah
18:02:22 <hodapp> should probably keep it there
18:02:26 <phaazon> but we should just stop talking about that
18:02:30 <phaazon> and let the fire die ;)
18:02:40 <phaazon> yeah
18:05:17 <Gurkenglas> Is there any literature on the reader monad being used to implement the typeclass/instance system?
18:10:44 <funfunctor> Hi
18:11:12 <funfunctor> I'm writing another binding and I forgot how to get cabal to give more verbose build messages?
18:11:23 <pacak> -v?
18:11:31 <tejing> what kinds of comonads exist that are significantly qualitatively different from cellular automata? (given the wide range of qualitatively different monads, I assume the problem must be failure of imagination on my part)
18:11:39 <phaazon> -v3 to unleash the kraken, funfunctor 
18:12:10 <pacak> tejing: Cofree comonad for AST annotation
18:12:37 <pacak> funfunctor: -vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv - just to be sure.
18:12:44 <funfunctor> haha
18:12:45 <Gurkenglas> Or for many other things. https://hackage.haskell.org/package/free-4.10.0.1/docs/Control-Comonad-Cofree.html
18:12:50 <funfunctor> ack, its not helping http://pastebin.com/8qyGfaFH
18:12:59 <funfunctor> I have a issue with my bindingDSL binding
18:14:34 <funfunctor> ah hmm, worked it out by randomly commenting things out
18:14:35 <funfunctor> :p
18:15:55 <hodapp> probably better if you understand what made it work >_>
18:16:03 <acowley> That wasn't random, that was your experience and wisdom taking over
18:16:33 <fishythefish> In my case, that'd be pseudorandom. :P
18:24:09 <Forkk> wait... I can do pattern matching on top-level bindings?
18:24:19 * hackagebot lens-simple 0.1.0.3 - simplified import of elementary lens-family combinators  http://hackage.haskell.org/package/lens-simple-0.1.0.3 (MichaelThompson)
18:27:42 <fishythefish> Forkk, are you referring to pattern bindings?
18:28:44 <Gurkenglas> Why does https://hackage.haskell.org/package/free-4.12.1/docs/Control-Comonad-Cofree.html#v:hoistCofree take (forall x. f x -> g x) instead of simply (f a -> g a)?
18:29:21 <acowley> Gurkenglas: Because you shouldn't use a function that's specialized to a particular 'a'
18:29:40 <arkeet> because it uses it polymorphically
18:29:55 <acowley> Yes, s/shouldn't/can't/ in my response
18:30:57 <Gurkenglas> Oh shoot, how did I miss that? I even looked up the source in confusion before asking here...
18:31:01 <hunteriam> does cygwin have a more complete stdlib than mingw?
18:31:15 <hunteriam> cause the stdlib in mingw is completely missing some files for random
18:31:22 <hunteriam> and its ruining my hmatrix install
18:38:08 <Gurkenglas> Why doesn't https://hackage.haskell.org/package/free-4.12.1/docs/Control-Comonad-Cofree-Class.html include "peek :: w a -> a" in the list containing only unwrap?
18:38:35 <Gurkenglas> *or something of the signature.
18:40:15 <acowley> Because that's called extract
18:40:27 <acowley> Defined in the Comonad class, which is a superclass constraint
18:40:51 <Gurkenglas> Ah, thanks.
18:41:50 <RyanGlScott> Is there a way to attach Haddock comments to derived instances?
18:42:26 <acowley> RyanGlScott: Maybe with standalone deriving?
18:43:54 <RyanGlScott> Ah, I think that would work.
18:47:30 <hunteriam> is there anyone here who can help me work out installing hmatrix on windows w/ mingw?
18:47:50 <hunteriam> its clearly broken, but im trying to fix it for myself
18:48:32 <hunteriam> this covers where im at https://github.com/albertoruiz/hmatrix/issues/125
18:49:19 <Gurkenglas> What quick way is there to get a # link to a position on a page?
18:50:09 <Gurkenglas> https://hackage.haskell.org/package/free-4.12.1/docs/Control-Comonad-Cofree.html -> "This is not a true Comonad transformer, but this instance is convenient." <- I don't see https://hackage.haskell.org/package/comonad-4.2.6/docs/Control-Comonad-Trans-Class.html#t:ComonadTrans defining any laws... 
18:59:20 * hackagebot turtle 1.1.1 - Shell programming, Haskell-style  http://hackage.haskell.org/package/turtle-1.1.1 (GabrielGonzalez)
19:13:24 <osa1> whoa!! test-framework's TH based test generator is trying to use commented out names :o (e.g. if I have commented out case_xyz it adds that as a test)
19:15:43 <athan> `.hsc` files aren't necessary for foreign imports, right? What does their purpose fill, exactly?
19:19:39 <c_wraith> athan: hsc files are handled by the hsc2hs program.  It takes care of things like making sure alignments, offsets, and other native details work correctly when writing Storable instances, mostly.
19:19:47 <osa1> athan: they're used by the preprocessor hsc2hs http://hackage.haskell.org/package/hsc2hs
19:20:20 <c_wraith> athan: it works through kind of a hack - but there's no real way to solve that exact problem without a hack.
19:20:45 <c_wraith> athan: hsc2hs files get converted into C programs that when run - output haskell files.
19:20:57 <c_wraith> athan: But that's the only *real* way to extract information from the C compiler.
19:22:48 <athan> Thank you c_wraith :)
19:22:56 <athan> (and osa1 !)
19:32:53 <subleq__> Is there a version of sequenceA that executes its actions concurrently?
19:34:22 * hackagebot free-game 1.1.81 - Create games for free  http://hackage.haskell.org/package/free-game-1.1.81 (FumiakiKinoshita)
19:34:26 <subleq__> I guess mapConcurrently from async is close
19:35:14 <srhb> subleq__: Closest you're going to get, depending on what exactly you meant by concurrently
19:35:29 <srhb> (as in, sequence is exactly not concurrent, and cannot be)
19:35:51 <c_wraith> sequenceA can be concurrent, though.
19:36:01 <c_wraith> It just needs to be in a concurrent Applicative
19:36:13 <ReinH> :t Concurrently
19:36:15 <lambdabot> Not in scope: data constructor ‘Concurrently’
19:37:13 <c_wraith> Yes, Concurrently from the async package has a concurrent implementation of <*> and <|>
19:37:23 <subleq__> huh, why can't i import Control.Concurrent.Async after i've installed async?
19:37:34 <srhb> I'm confused now.
19:38:19 <c_wraith> srhb: about what?
19:38:27 <srhb> c_wraith: How sequenceA works.
19:38:29 <srhb> :t sequenceA
19:38:31 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
19:38:36 <srhb> Hmm
19:38:53 <srhb> Ooooh.
19:39:03 <srhb> Okay, I get it now. _can_ be, but no guarantee
19:39:19 <srhb> I was trying to see how this could be possible for all Applicatives, which obviously wouldn't make sense.. Derp.
19:39:25 <subleq__> getting     Could not find module `Control.Concurrent.Async'
19:39:43 <srhb> subleq__: Did you accidentally install it in a sandbox and tried accessing it from outside?
19:39:53 <subleq__> srhb: yes
19:39:54 <subleq__> thanks
19:40:06 <srhb> No problem, psychic debugging is free.
19:40:13 <srhb> :-)
19:40:18 <c_wraith> @free psychic debugging
19:40:18 <lambdabot> Extra stuff at end of line
19:40:36 <srhb> free, not Free!
19:40:44 <subleq__> i'm used to python virtualenv and forget to cabal exec stuff
19:40:52 <joneshf-laptop> @tell Gurkenglas They're around somewhere, but basically you want to follow the idea of `MonadTrans` `extract . lower = extract` and `extend f (lower m) = lower (extend (f . lower) m)`
19:40:52 <lambdabot> Consider it noted.
19:42:44 <fryguybob> bitemyapp: If you have something where STM performs poorly please let me know.  I collect these things :D
19:45:39 <hunteriam> aare there any example Cairo programs
19:46:47 <hunteriam> hey
19:50:51 <pavonia> hunteriam: https://github.com/gtk2hs/gtk2hs/tree/master/cairo/demo
19:51:35 <pharaun> oh that's part of gtk2hs hmm
19:51:42 <pharaun> hows gtk these days?
19:52:26 <hunteriam_> hello?
19:52:43 <hunteriam_> does anyone have any examples of how to actually draw a Render () in cairo
19:52:54 <hunteriam_> like, actually display it, or write it to a png
19:53:03 <hunteriam_> theres not a single tutorial i can find that talks about this very important bit
19:53:05 <srhb> hunteriam_: People were answering you, but apparently you dropped off.
19:53:09 <hunteriam_> oh
19:53:14 <hunteriam_> i didnt think my messages were getting sent
19:53:18 <hunteriam_> sorry people
19:53:35 <hunteriam_> What were some of the answers?
19:53:39 <copycat> 10:50:31 AM - pavonia: hunteriam: https://github.com/gtk2hs/gtk2hs/tree/master/cairo/demo
19:53:50 <hunteriam_> thank you so much guys
19:53:54 <hunteriam_> sorry forthe confusion
19:58:55 <funfunctor> Can someone show me a quick simple example of Coercible usage?
20:02:14 <subleq__> @pl \id -> evalStateT (buildTree id) sess
20:02:14 <lambdabot> flip evalStateT sess . buildTree
20:06:23 <danyun> hi
20:09:12 <bitemyapp> fryguybob: I mean
20:09:37 <bitemyapp> fryguybob: probably what we're talking about is worst-case scenarios in either direction
20:09:50 <bitemyapp> fryguybob: per node STM container, compose transactions across a bunch of them -> Churn
20:10:01 <bitemyapp> fryguybob: per graph STM container container, have a bunch of threads smashing them -> Churn
20:10:17 <bitemyapp> fryguybob: with the former case, possible overhead if you're dealing with a lot of nodes.
20:10:32 <bitemyapp> fryguybob: I don't know how credible these hypotheticals are, I'm just hypothesizing.
20:10:46 <bitemyapp> fryguybob: I haven't had time to kick Volkov's initial code dump around yet.
20:12:00 <bitemyapp> fryguybob: if I get a repro or something, I'll pass it on. Why do you collect STM anecdotes?
20:14:53 <kristof> to bury it in the ground, once and for all
20:15:17 <fryguybob> bitemyapp: My thesis work is improving synchronization performance in Haskell.
20:15:57 <kristof> The majority of synchronization performance is in poor planning that causes lock contention!
20:16:02 <kristof> I'm done, now.
20:16:20 <fryguybob> kristof: :D
20:16:29 <kristof> fryguybob: Oh, was I right?
20:17:19 <fryguybob> kristof: Well replace lock contention with shared memory access contention, both false and real sharing.
20:18:18 <fryguybob> kristof: The hope is that we can avoid some of the issue with hardware transactional memory.
20:18:20 <kristof> fryguybob: So is your thesis work on user-techniques or code optimization / rewrite rules / static analysis?
20:19:02 <kristof> fryguybob: I can't remember who said it, but I recall someone important exclaiming "So are we transactional, or not?"
20:19:11 <fryguybob> kristof: Hardware transactions, static analysis, improved runtime system support, and user level techniques eventually.
20:20:22 <fryguybob> bitemyapp: Your hypothetical concerns sound right, but it is nice when there is real code that people care about that can be poked and prodded to go faster.
20:20:25 <kristof> fryguybob: My personal preference is to reserve STM for read-often, write-rarely scenarios. For instance, a multithreaded search routine that checks periodically if it can stop searching.
20:21:13 <fryguybob> bitemyapp: A common Haskell way of doing things is to put a pure data structure behind an IORef or TVar and atomically swap out a new version.
20:21:28 <bitemyapp> fryguybob: oh right, I'd talked to you before about this briefly. Sorry, I blank on things like that a lot.
20:21:52 <fryguybob> bitemyapp: When we compare this with a fine-grained STM data structure STM starts winning at about 8 cores.
20:21:58 <fryguybob> bitemyapp: :D
20:22:02 <bitemyapp> kristof: I might be able to pull out writes as an initial batch process, then freeze it after. Not sure how much good this does me.
20:22:03 <hodapp> One of these days I'll get out of my silly little Haskell dream-world where I am only using Haskell for generating code, and actually have to worry about things like IORefs and TVars and STM.
20:22:21 <bitemyapp> fryguybob: I have a bad memory, don't sleep enough, and the book has me preoccupied - sorry :(
20:22:49 <fryguybob> kristof: Yeah it should do well with that sort of work.
20:22:51 <kristof> bitemyapp: Where can I reserve an early copy?
20:23:07 <bitemyapp> kristof: http://haskellbook.com/
20:23:18 <bitemyapp> kristof: fair warning, it's not going to cover STM :P
20:23:31 <bitemyapp> Marlow already tied that whole topic up nicely. I'm not touching it.
20:23:42 <bitemyapp> which is about the highest compliment I can pay a book really.
20:23:55 * fryguybob goes to bed
20:24:29 <bitemyapp> hodapp: I'm envious of compiler/DSL writers sometimes :P
20:24:43 <subleq__> Is there a name for the Monoid instance of Maybe that always takes the value on the left side?
20:24:53 <bitemyapp> hodapp: a lot of my work is "hurr durr smack it with a *Var and see what happens"
20:25:33 <johnw> subleq__: First?
20:26:01 <c_wraith> subleq__: check in Data.Monoid
20:26:02 <subleq__> johnw: yes thanks
20:26:24 <kristof> bitemyapp: All the interesting chapters are still being written!
20:26:35 <hodapp> bitemyapp: a lot of my work is much the same, only I can't identify what it is I'm smacking it with :P
20:26:40 <kristof> bitemyapp: Looks good and I wish you luck :) will purchase soon (not at the moment)
20:27:19 <bitemyapp> kristof: yeah it's really mostly for the people who kept asking for ways to give us money and wanted a way to read along as we worked without committing to being a reviewer.
20:27:46 <bitemyapp> nice way to make the schedule more urgent too.
20:28:22 <kristof> bitemyapp: Would have liked to see a couple of chapters on hylomorphisms, comonads, and maybe some simple parallelism techniques since Haskell makes some cases dead easy
20:28:44 <bitemyapp> kristof: that Haskellers want desperately to talk about things like that instead of the basics
20:28:50 <bitemyapp> kristof: is why I had to write a book on the basics
20:29:03 <bitemyapp> I *might* talk about zippers and comonads but it doesn't seem likely. the book is already freakin' huge.
20:29:19 <bitemyapp> kristof: do you have any idea how much it takes to cover the topics listed properly? with exercises?
20:29:24 * hackagebot intricacy 0.4.3 - A game of competitive puzzle-design  http://hackage.haskell.org/package/intricacy-0.4.3 (mbays)
20:29:37 <kristof> bitemyapp: I'm sorry, I wasn't around for any of the discussion about scope and purpose. What was wrong LYAH and RWH?
20:30:15 <bitemyapp> kristof: I like talking to you, so I don't want to blow you off, but I wrote an article for this already: http://bitemyapp.com/posts/2014-12-31-functional-education.html
20:30:25 <bitemyapp> kristof: the short answer: a lot of people try and fail to learn Haskell. Over, and over, and over.
20:30:45 <kristof> bitemyapp: A prewritten article was all I was looking for :)
20:30:47 <bitemyapp> kristof: the lucky don't notice and those with the knowledge to teach are too busy chasing the vanguard.
20:31:00 <bitemyapp> kristof: it took me way way way too long to learn Haskell.
20:31:08 <bitemyapp> kristof: nobody should have to go through something like what I did.
20:31:59 <bitemyapp> kristof: after my talks at LambdaConf a lot of people approached me to say that they had had a lot of trouble learning Haskell and had to give up. many felt embarrassed because they though it was their fault.
20:32:06 <bitemyapp> thought*
20:32:48 <danyun> bitemyapp: I am a new learner of haskell
20:33:05 <bitemyapp> danyun: hi!
20:33:49 <danyun> I am reading the documentations, seems hard to me .... :(
20:34:03 <kristof> bitemyapp: I love the reference to VI Arnold. Big fan, read his book on ODEs
20:34:10 <bitemyapp> kristof: :)
20:34:20 <kristof> bitemyapp: What's your math education look like? Just curious.
20:34:24 * hackagebot wai-logger 2.2.4.1 - A logging system for WAI  http://hackage.haskell.org/package/wai-logger-2.2.4.1 (KazuYamamoto)
20:34:26 <bitemyapp> kristof: zero.
20:34:34 <bitemyapp> kristof: I have no degrees, no education, not even a single credit.
20:34:45 <kristof> Self-taught?
20:34:56 <bitemyapp> self-taught assumes I learned some math at some point
20:34:57 <bitemyapp> I didn't
20:35:04 <kristof> Ok
20:35:08 <bitemyapp> I still don't know anything. I just know the name of some algebras we use in Haskell.
20:36:57 <kristof> bitemyapp: How many writers are there for the book?
20:37:17 <bitemyapp> kristof: I started in Fall, my coauthor whom I taught Haskell (no prior coding experience) started in Winter.
20:37:21 <bitemyapp> kristof: just the two of us.
20:37:44 <bitemyapp> kristof: here's a post of hers: https://superginbaby.wordpress.com/2015/05/30/learning-haskell-the-hard-way/
20:37:58 <kristof> bitemyapp: Oh, was that the woman you went on a podcast with?
20:38:19 <bitemyapp> kristof: yeah, although at the time she was a student and hadn't started working with me on the book yet.
20:38:29 <kristof> Yeah, I listened to most of that one
20:38:35 <kristof> She had a lot of good things to say
20:38:42 <GLM> bitemyapp:That reminds me. Are there are good media for Haskell like podcasts?
20:38:44 <bitemyapp> but hey, I'm a student too. Never stop learning.
20:39:06 <danyun> Any suggestions for a beginner ?
20:39:07 <kristof> :)
20:39:23 <bitemyapp> GLM: I don't think they explain anything for beginners, but http://www.haskellcast.com/ has some episodes.
20:39:34 <bitemyapp> danyun: https://github.com/bitemyapp/learnhaskell
20:39:47 <GLM> bitemyapp:I saw that but it looked like it was dead
20:40:52 <bitemyapp> GLM: seems like they publish an episode about 2-3 times a year, so I don't think they're necessarily running late.
20:41:05 <bitemyapp> GLM: even if they never published anything again, wouldn't hurt you to listen to what they've got.
20:41:15 <bitemyapp> GLM: I think one of the hosts (Chris F) has some youtube videos.
20:41:33 <bitemyapp> as for ongoing, no I don't think so. podcasts are labor intensive and not very rewarding, especially in niche communities.
20:41:47 <bitemyapp> it's easier if you target a larger audience (say, FP in general)
20:42:05 <GLM> Sadly tue
20:42:07 <GLM> true
20:42:08 <bitemyapp> so you might have more luck if you broaden your search to FP focused podcasts in general, like functional geekery which I think is Erlang heavy.
20:42:17 <bitemyapp> (fn geekery is the one my coauthor and I were on)
20:44:02 <danyun> I have some experiences in Erlang, but still found hard to learn haskell..
20:44:19 <bitemyapp> danyun: this is the case for most people.
20:44:25 * hackagebot cron 0.2.6 - Cron datatypes and Attoparsec parser  http://hackage.haskell.org/package/cron-0.2.6 (MichaelXavier)
20:44:33 <felixn> hey all, can I populate getArgs with GHCi?  I'm too lazy to break a test out from my runner, and I want to debug it
20:44:41 <Pip> Are there "design patterns" in Haskell world ?
20:44:57 <c_wraith> Pip: yes, and most of them are "functions"
20:45:36 <Pamelloes> Where can I find the monad instance for []?
20:46:08 <c_wraith> Pip: http://fsharpforfunandprofit.com/fppatterns/ is a good introduction
20:46:32 <c_wraith> Pip: while it's about F#, everything it talks about is used in Haskell too
20:47:03 <dolio> Pamelloes: GHC.Base
20:47:18 <dolio> I believe.
20:47:29 <pacak> felixn: ":main"?
20:47:42 <arkeet> Pamelloes: https://hackage.haskell.org/package/base-4.8.0.0/docs/Prelude.html
20:47:51 <arkeet> look for where it says there is an instance for Monad []
20:47:53 <arkeet> and click Source
20:47:55 <Rotaerk> c_wraith, I like slide 15
20:48:07 <pacak> felixn: or :set args 
20:48:34 <Pamelloes> dolio: Yep, it's there :)
20:48:35 <Rotaerk> although it's not really accurate
20:48:39 <Pamelloes> araujo: Good to know
20:48:46 <felixn> pacak: snap, let me try that, undoing refactoring :D
20:48:48 <Pip> thanks
20:48:57 <Pamelloes> Oops, sorry araujo. I meant arkeet 
20:49:01 <dmwit> Holy smokes, I actually turned the monomorphism restriction back on in a program.
20:49:06 <arkeet> np
20:49:22 <c_wraith> dmwit: I've turned on MonoLocalBinds before
20:49:44 <Cale> dmwit: Lots of numerical stuff?
20:49:57 <c_wraith> Pamelloes: if I ask ghci, it tells me "instance Monad [] -- Defined in ‘GHC.Base’
20:49:58 <c_wraith> "
20:50:16 <dmwit> Cale: Yep, exactly. And a top-level cache that was getting recomputed every time it got used.
20:50:19 <Pamelloes> c_wraith: Yep, I found it there. How do you get that from ghci?
20:50:40 <c_wraith> Pamelloes: I used ":info []"
20:51:03 <Pamelloes> c_wraith: Huh, thanks :)
20:51:09 <c_wraith> Pamelloes: though ":info Monad" also does the job
20:53:34 <felixn> pacak: thanks!  that worked
21:22:30 <jle`> > drop 20 . scanl (*) 1 $ [1..] :: [Int]
21:22:33 <lambdabot>  [2432902008176640000,-4249290049419214848,-1250660718674968576,8128291617894...
21:22:35 <jle`> my new rng
21:23:06 <jle`> > map (`mod` 1000) . drop 20 . scanl (*) 1 $ [1..] :: [Int]
21:23:09 <lambdabot>  [0,152,424,984,840,776,16,664,520,624,496,616,168,320,184,896,864,880,208,95...
21:23:29 <Axman6> you should probably add a large prime to it, like 7, to make it impossible to crack
21:23:41 <jle`> i think as it is it's already cryptosecure
21:24:05 <Axman6> Maybe 11 would be better
21:24:07 <jle`> adding 7 might take too many cycles
21:24:09 <pacak> jle`: Add 4 (hardware generated random number to it) to make it more secure.
21:24:11 <jle`> 11 is out of the question
21:24:17 <bitemyapp> > drop 20 . scanl (*) 1 $ [1..] :: [Int]
21:24:21 <lambdabot>  [2432902008176640000,-4249290049419214848,-1250660718674968576,8128291617894...
21:24:32 <bitemyapp> -_-'
21:24:39 <bitemyapp> > drop 20 . scanl (*) 1 $ [1..] :: [Integer]
21:24:42 <lambdabot>  [2432902008176640000,51090942171709440000,1124000727777607680000,25852016738...
21:24:42 <pacak> http://xkcd.com/221/
21:24:51 <bitemyapp> > drop 20 . scanl (*) 1 $ [1..] :: [Word8]
21:24:53 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
21:25:03 * bitemyapp grins
21:25:48 <nshepperd> > length . takeWhile (/=) . scanl (*) 1 $ [1..] :: [Int]
21:25:52 <lambdabot>      Couldn't match expected type ‘[Int]’ with actual type ‘Int’
21:25:53 <lambdabot>      In the expression:
21:25:53 <lambdabot>          length . takeWhile (/=) . scanl (*) 1 $ [1 .. ] :: [Int]    Couldn't...
21:26:04 <nshepperd> er
21:26:05 <jle`> i like the error
21:26:08 <jle`> "Couldn't..."
21:26:16 <jle`> "I just .... couldn't."
21:26:29 <nshepperd> > length . takeWhile (/=0) . scanl (*) 1 $ ([1..] :: [Int])
21:26:34 <lambdabot>  66
21:27:02 <nshepperd> 66 random numbers, not to shabby for an rng
21:27:04 <jle`> if i ever write a compiler i'll probably make "I just couldn't." be the only compile error
21:27:08 <jle`> message
21:27:43 <mzero> "Really?" "Must you?" "I... I just don't know what to say..."
21:27:50 <mzero> these would be good
21:28:14 <GLM> Are you just checking to see how many it takes to wrap around to 0?
21:28:55 <jle`> how many it takes before it happens to hit the 0 fixed point
21:30:35 <Hafydd> > takeWhile (/=0) . scanl (*) 1 $ ([1..] :: [Int])
21:30:44 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
21:30:53 <Hafydd> lol so random XD
21:31:22 <jle`> you have to give it time to burn in obv
21:31:32 <jle`> that's like the first rule of cryptosecuroscience
21:32:24 <pacak> > repeat 4
21:32:28 <lambdabot>  [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4...
21:32:33 <pacak> Here you go.
21:35:46 <jle`> > drop 20 $ repeat 4
21:35:48 <lambdabot>  [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4...
21:36:10 <GLM> :t drop
21:36:12 <lambdabot> Int -> [a] -> [a]
21:36:29 <GLM> :info drop
21:36:37 <jle`> lambdabot has no :info ;_;
21:36:38 <phy1729> > drop 20 $ repeat 9
21:36:40 <lambdabot>  [9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9...
21:36:49 <phy1729> dilbert certified  http://dilbert.com/strip/2001-10-25
21:37:02 <arkeet> > takeWhile (/=0) . map (`mod` 19) $ scanl1 (*) [1..]
21:37:07 <lambdabot>  [1,2,6,5,6,17,5,2,18,9,4,10,16,15,16,9,1,18]
21:37:21 <arkeet> > takeWhile (/=0) . map (`mod` 29) $ scanl1 (*) [1..]
21:37:24 <lambdabot>  [1,2,6,24,4,24,23,10,3,1,11,16,5,12,6,9,8,28,10,26,24,6,22,6,5,14,1,28]
21:42:45 <ezrios> anyone here actually use acid-state?
21:42:54 <ezrios> wondering what the advantages/disadvantages are in comparison to SQL
21:45:08 <jle`> dmj`: ^
21:45:18 <jle`> ezrios: the main advantage i think is that you can just use normal haskell types for everything
21:45:34 <jle`> so everything is haskell data types, no interfacing with some extra sort of data store
21:45:46 <jle`> also easy migrations apparently
21:48:14 <dmj`> jle`: !!
21:53:14 <igniting> ezrios: one drawback of acid-state is that all your entire data-structure should fit in the RAM
21:54:27 * hackagebot bitcoin-api 0.12.0 - Provides access to the RPC API of Bitcoin Core  http://hackage.haskell.org/package/bitcoin-api-0.12.0 (solatis)
21:54:43 <ezrios> igniting: so if I have an IntMap MyRecord
21:54:48 <ezrios> all records ever must fit in RAM?
21:55:02 <ezrios> this is... maybe not good for my purposes
21:55:28 <dmj`> ezrios: you can shard it manually if you use the remote module
21:56:06 <dmj`> ezrios, igniting: I'll have you know there is a GSOC project for a distributed acid-state
21:56:33 <dmj`> https://www.youtube.com/watch?v=7I-mdoClMVA
21:56:48 <igniting> dmj`: yes I had seen it on projects page. Is there somewhere I can track the progress?
21:57:21 <dmj`> igniting: probably I assume the repo would be a place to watch though
21:57:27 <dmj`> probably not*
21:57:55 <igniting> link?
21:58:13 <dmj`> github.com/acid-state
21:58:15 <jle`> omg distributed acid-state
21:58:22 <dmj`> :P
21:58:24 <jle`> distributed implicit serialization in general...
21:58:28 <jle`> distributed-binary
21:58:37 <jle`> distributed-cereal
21:59:45 <dmj`> I'm not really sure what the plan is, I think they might trade 'A' for 'C' and 'P' 
21:59:49 <igniting> dmj`: may be one of the forks has progress? Because I don't see any recent commits or pull request on acid-state
22:00:04 <dmj`> igniting: I'm not even sure gsoc has begun yet
22:00:18 <igniting> oh, gsoc began 1 month back
22:00:40 <igniting> not 1 month. 2 weeks :P
22:00:44 <dmj`> there it is, https://www.google-melange.com/gsoc/project/details/google/gsoc2015/mcv1/5757334940811264
22:01:24 <igniting> ezrios: you might want to look at persistent
22:01:40 <igniting> http://www.yesodweb.com/book/persistent
22:01:55 <dmj`> ezrios: what is your data set? 
22:03:12 <igniting> btw, I was also working on writing a native keyvalue store in haskell. It's not yet complete though
22:03:48 <dmj`> igniting: cool
22:04:14 <scutigera> goooood evening
22:04:39 <scutigera> could some kind soul direct me to an attoparsec example ?
22:04:54 <scutigera> been searching the tubes and can't quite find the one i need...
22:05:04 <jle`> scutigera: are you looking for attoparsec in specific, or using parser combinators in general?
22:05:11 <jle`> parsec etc.
22:05:15 <scutigera> attoparsec in particular
22:06:19 <pacak> scutigera:  parseOnly (A.take 5) "Hello"
22:06:52 <scutigera> yes - that's part of the problem
22:06:57 <scutigera> many examples parse a string
22:07:03 <scutigera> instead of a file
22:07:08 <scutigera> also too- trying use lazy
22:07:52 <pacak> scutigera:  feed (feed (parse foo prev) bs) B.null
22:08:01 <pacak> scutigera: foo :: Parser [Foo]
22:08:10 <pacak> prev - remainer from previous parse
22:08:15 <pacak> bs - new chunk of data
22:08:37 <pacak> scutigera: This gives you parser for ByteString of any size in chunks you can read.
22:08:50 <scutigera> how about Text.
22:08:58 <pacak> case (that expression) of
22:08:58 <pacak>   Done rest xs ->
22:09:05 <pacak> Will work the same way for text.
22:09:34 <pacak> rest - your new state - you will reuse it in the next chunk as prev, xs - your output from this chunk. If any.
22:10:14 <scutigera> ok. let me try putting that in my example ... ty!
22:12:41 <scutigera> looks like Text.null is equivalent of B.null ?
22:13:04 <pacak> I would be surprized if it's not so.
22:15:45 <scutigera> oops. T.null is a test for null, not an actual null.
22:16:01 <scutigera> maybe just pack ""
22:19:11 <pacak> scutigera: T.empty?
22:19:32 <scutigera> lol. 
22:19:43 <scutigera> i have the module page open and didn't see it... but you knew it.
22:22:54 <kadoban> 'empty' is kind of a standard name for that kinda thing.
22:23:21 <scutigera> so i have to skip comment line which begin with '!'
22:23:48 <scutigera> which i have coded up rather horrendously as : char '!' ; _ <- takeWhile1 (/= '\n'); return True
22:24:38 <scutigera> however i have to alternate that with something that's NOT a comment (duh)
22:25:08 <scutigera> so i think  i code that with "<|>" it looks like ?
22:25:33 <pacak> scutigera: You need to tokenze your stream.
22:26:56 <scutigera> ok so '!' is a token and then '#' is a token (not a comment- has aspecial meaning) and then floating point values are a token.
22:27:01 <pacak> comment = True <$ char '!'  <* takeWhile1 (/= '\n')
22:27:30 <pacak> Actually what you want is probably () <$ char '!' .....
22:28:17 <scutigera> \hoogle <$
22:28:30 <pacak> @hoole (<$)
22:28:31 <lambdabot> Data.Functor (<$) :: Functor f => a -> f b -> f a
22:28:31 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
22:28:31 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
22:28:32 <scutigera> huh- i thought that used to work...
22:28:33 <scutigera> lol
22:28:38 <scutigera> @hoole (<$)
22:28:38 <lambdabot> Data.Functor (<$) :: Functor f => a -> f b -> f a
22:28:39 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
22:28:39 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
22:28:51 <scutigera> ah yes- you have gotten all applicative on my ass.
22:29:10 <scutigera> ;-)  i was hoping to not do that until i had the attoparsec interface figured out.
22:29:21 <scutigera> cuz i'm kinda slow...
22:29:51 <scutigera> should take me the rest of the evening to understand your comment definition...
22:30:07 <scutigera> @hoole (<*)
22:30:09 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
22:30:09 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
22:30:09 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
22:32:01 <scutigera> aha. the comment parse works...
22:32:13 <pacak> Why wouldn't it...
22:32:14 <kadoban> scutigera: You can generally just check the type for that kinda thing, it tends to tell you quite a bit.
22:32:20 <kadoban> :t (<*)
22:32:22 <lambdabot> Applicative f => f a -> f b -> f a
22:32:41 <kadoban> Although I kinda picked a not-great example for that, but … :-/
22:32:46 <scutigera> why wouldn't it ? because it's me coding it up of course.
22:33:39 <scutigera> also too - i figured i'd have to import the operators but magically they seem to already be imported. even though it looks like they are not in the attoparsec module
22:34:04 <scutigera> so yes, i am surprised it worked on the first try.
22:34:28 <scutigera> some nights i spend more time figuring out how to import something than i do actually writing code.
22:34:29 <hemite_> I've install alsa-pcm through cabal. But when I try to compile a file with ghc, it complains it can't find module Sound.Alsa
22:34:39 <hemite_> This file specifically: https://github.com/yav/alsa-haskell/blob/master/examples/play.hs
22:35:12 <scutigera> which module ?
22:35:17 <scutigera> alsa-mixer ?
22:35:35 <scutigera> cuz that looks like Sound.ALSA.Mixer
22:35:35 <hemite_> alsa-pcm
22:37:15 <scutigera> @hemite_ Sound.ALSA.PCM seems to work for me
22:37:15 <lambdabot> Unknown command, try @list
22:37:25 <scutigera> hemite_ Sound.ALSA.PCM seems to work for me
22:37:45 <hemite_> scutigera, You are able to compile that file with ghc?
22:37:53 <hemite_> I'm just trying to figure out this cabal nightmare
22:38:09 <scutigera> oh sorry
22:38:13 <scutigera> just loaded and browsed
22:38:15 <scutigera> one sec
22:39:48 <scutigera> @hemite_ lol. yep- same error
22:39:48 <lambdabot> Unknown command, try @list
22:39:55 <scutigera> hemite_ lol. yep- same error
22:40:50 <scutigera> weird. because :m Sound.ALSA.PCM worked
22:41:47 <scutigera> bet it's a broken cabal install. assigning the wrong module name or something.
22:44:29 * hackagebot ndjson-conduit 0.1.0.2 - Conduit-based parsing and serialization for newline delimited JSON.  http://hackage.haskell.org/package/ndjson-conduit-0.1.0.2 (srijs)
22:47:45 <scutigera> hemite_ ?? still there ?
22:47:53 <scutigera> made some progress
22:48:00 <scutigera> looks like it's working for me maybe
22:48:06 <scutigera> but your code is broke.
22:52:11 <hemite_> scutigera, Not my code, can you paste the correct code?
22:52:33 <quantalrabbit> I have the following type definition:  "type Box = [(Int, [String])]"  .  How do I define something equivalent with the "data" keyword instead?
22:52:55 <scutigera> data Box = Box [(Int,[String])]
22:53:36 <scutigera> data Box = Box [(Int,[String])] deriving Show
22:54:29 <pacak> data Box = Box { unbox :: [(Int, [String])] }
22:55:02 <scutigera> sorry - noob alert
22:55:08 <quantalrabbit> thanks!
22:55:10 <scutigera> how do i "highlight" a usre.
22:55:15 <scutigera> been off irc for a while...
22:56:32 <scutigera> oh shoot
22:56:39 <scutigera> i installed the latest version from hackage
22:56:56 <scutigera> looks like the example and version you are using are newer from github. is that right ?
22:57:07 <mniip> scutigera, to highlight you just type their nickname
22:57:16 <scutigera> mniip like that ?
22:57:19 <mniip> yeah
22:57:24 <scutigera> thx.
22:57:37 <scutigera> thought i had to prefix it or something.
22:58:05 <scutigera> hemite_ so i'm not getting a module not found error. but code is broke because difinition of SoundFmt has changed.
22:58:14 <mniip> usually you follow it by a comma or colon as an addressing
22:58:30 <scutigera> doh! ty.
22:58:37 <scutigera> mniip: doh! ty.
23:01:02 <scutigera> hemite_: which package are you working with exactly ? the example is from alsa-haskell which is really old.
23:03:18 <hemite_> I think I just want to use alsa-cpm, and I thought that github link had decent examples
23:03:19 <hemite_> but I guess not
23:03:29 <hemite_> I'm pretty sure alsa-cpm is what I want thoguh
23:03:55 <hemite_> er, alsa-pcm
23:04:19 <scutigera> looks like there are flags to build examples
23:04:25 <hemite_> Those exampels should be from the alsa-pcm package
23:04:29 <hemite_> https://hackage.haskell.org/package/alsa-pcm-0.6.0.3/src/
23:04:52 <scutigera> ah. you're link was to an example in alsa-haskell
23:05:00 <scutigera> your link. geez. 
23:05:25 <eds> anyone here has an experience with genprog package and probably can help me out? https://hackage.haskell.org/package/genprog-0.1/docs/GenProg.html
23:06:13 <hemite_> Well anyway, I can't get play.hs in the new link I provided, to work
23:06:17 <scutigera> hemite_: ok. i got the play example from the link you just posted. compiles up like a champ
23:06:19 <hemite_>     Could not find module Sound.ALSA.PCM
23:06:32 <hemite_> scutigera, you don't get that error ^^
23:06:33 <hemite_> ?
23:06:44 <scutigera> i do not. builds just fine.
23:07:01 <scutigera> er, compiles just fine.
23:07:05 <hemite_> with ghc?
23:07:08 <hemite_> ghc play.hs ?
23:07:14 <hemite_> I wonder why I'm getting that error then..
23:07:14 <scutigera> ghc -o foo play.hs
23:07:26 <scutigera> [1 of 1] Compiling Main             ( play.hs, play.o )
23:07:26 <scutigera> Linking foo ...
23:07:26 <scutigera>  
23:07:43 <scutigera> did you do cabal install alsa-pcm ?
23:08:07 <scutigera> and did it really work ? or did it maybe error out and you didn't notice ?
23:10:11 <scutigera> pacak: thanks for your help.
23:10:40 <Zemyla> I think I am an awful person.
23:10:52 <scutigera> Zemyla: no argument here.
23:10:56 <scutigera> ;-)
23:11:00 <Zemyla> instance MonadIO Proxy where liftIO _ = Proxy
23:11:09 <hemite_> scutigera, Yea I installed it, weird 
23:11:15 <scutigera> hemite_: huh.
23:11:25 <Zemyla> That just popped into my head.
23:11:47 <scutigera> well, did you try ghci
23:11:48 <scutigera>  :m Sound.ALSA.PCM
23:11:51 <scutigera> :browse
23:11:54 <scutigera> see if that works.
23:13:05 <scutigera> hemite_: g2g. good luck.
23:15:23 <ghoule> Hi guys, please bear with me i'm 100% new to Haskell :P
23:16:08 <ghoule> i'm trying to work on some project euler problems to practice Haskell :)
23:16:33 <verement> Hi ghoule, we were all there once
23:16:52 <ghoule> and I was doing: sum [x | x <- [1..1000], (mod x 3) == 0 || (mod x 5) == 0]
23:16:58 <Zemyla> No one was born knowing Haskell. Except maybe Oleg.
23:17:23 <ghoule> for the problem where I need to sum all the numbers from 1 to 1000 that are multiples of 3 or 5
23:17:43 <ghoule> But I'm getting my answer rejected.. Am I doing something that isn't valid in haskell?
23:18:00 <ghoule> I assume [1..1000] is 1,2,3,4,5....1000
23:18:09 <ghoule> sum => reduce on sum
23:18:25 <ghoule> mod x 3 == 0 (True if x mod 3 is equivalent to 0
23:18:25 <pacak> ghoule: Are you putting your program in there, not your answer?
23:18:30 <ghoule> || is or?
23:18:47 <ghoule> I'm putting my answer.. do I need to put my program in there o.O? lol
23:18:57 <pacak> > sum [x | x <- [1..10], (mod x 3) == 0 || (mod x 5) == 0]
23:19:00 <lambdabot>  33
23:19:10 <pacak> ghoule: (Just in case)
23:19:15 <pacak> > [x | x <- [1..10], (mod x 3) == 0 || (mod x 5) == 0]
23:19:17 <lambdabot>  [3,5,6,9,10]
23:19:31 * hackagebot nestedmap 0.1.0.1 - A library for nested maps  http://hackage.haskell.org/package/nestedmap-0.1.0.1 (kirstin)
23:19:40 <pacak> Looks about right
23:19:55 <ghoule> ahhhhh
23:19:59 <ghoule> below 1000
23:20:05 <ghoule> I missread
23:20:07 <ghoule> my bad :S
23:20:14 <ghoule> pacak: thanks :)
23:21:29 <ghoule> Another quick question: on the ghci is there keybindings (shortcuts) to navigate the prompt faster?
23:21:41 <ghoule> like jumping to beginning of the line or jumping words
23:21:46 <ghoule> backward and forward
23:21:54 <Axman6> lost of emacs shortcuts work
23:22:05 <Axman6> ^a for beginning of line, ^e for end
23:22:20 <Axman6> ^e deletes a word, I think?
23:22:24 <arkeet> alt-b, alt-f to jump by words
23:22:41 <ghoule> Axman6:  arkeet: Thanks! 
23:22:56 <pacak> ghoule: It uses libedit 
23:23:07 <Axman6> alt-left/right also seem to jump between words (how handy!)
23:23:09 <ghoule> pacak: ah okok
23:23:09 <pacak> Or used it...
23:23:26 <pacak> Something you can configure externally, google for it :)
23:23:31 <arkeet> ctrl-w deletes a word.
23:23:33 <ghoule> kk ill look into it :)
23:23:44 <arkeet> I don't use very many of these.
23:24:19 <ghoule> kk :P
23:24:31 * hackagebot nestedmap 0.1.0.2 - A library for nested maps  http://hackage.haskell.org/package/nestedmap-0.1.0.2 (kirstin)
23:29:31 * hackagebot nestedmap 0.1.0.3 - A library for nested maps  http://hackage.haskell.org/package/nestedmap-0.1.0.3 (kirstin)
23:30:30 <Haskellfant> do we have a type class that allows enumerating all possible values? Enum comes close but it does require me to know the first value to start enumerating or hope that it starts at 0
23:30:59 <pacak> Haskellfant: Enum + Bounded
23:31:06 <kadoban> :t minBound
23:31:08 <lambdabot> Bounded a => a
23:31:16 <Haskellfant> pacak: ah perfect, thanks
23:42:10 <Pip> Is it good practice to give functions type declarations?
23:44:04 <ghoule> kk i'm not a big fan of the ghci because the shortcuts aren't what I'm used to : (Vim + Sublime Text 3)
23:44:23 <ghoule> can someone give me some nice Vim setup info? :)
23:44:26 <ghoule> for workflow
23:44:37 <ghoule> Ideally with a repl
23:48:45 <Haskellfant> Pip: yep, I usually even write them before I write the actual function, they help guide the implementation
23:49:07 <Pip> Okay
23:55:43 <too9> Hey everyone. I'm trying to create a Read Key instance declaration, but I'm having some trouble with it.. The truth is: I just want it to be read as an empty String, regardless of the Key. Any tips?
23:56:35 <Pip> Why do I find Haskell is easy to learn?
23:56:50 <Pip> I thought it's difficult to understand
23:58:37 <thebnq> Pip: it depends on the individual
23:59:36 <arkeet> depends on how much you have to unlearn.
